{"meta":{"title":"Mrli's Blog","subtitle":"别装作很努力，结局不会陪你演戏。","description":"想和你讲，说了会心动 ，缄默会心安。","author":"Mrli","url":"https://nymrli.top"},"pages":[{"title":"","date":"2020-07-25T12:19:59.503Z","updated":"2018-12-21T09:57:11.353Z","comments":true,"path":"google6b632f121e4f7422.html","permalink":"https://nymrli.top/google6b632f121e4f7422.html","excerpt":"","text":"google-site-verification: google6b632f121e4f7422.html"},{"title":"关于我","date":"2018-08-31T07:56:42.000Z","updated":"2022-03-29T11:40:52.837Z","comments":true,"path":"about/index.html","permalink":"https://nymrli.top/about/index.html","excerpt":"","text":"本人南邮自动化本科学生一枚.热爱捣鼓计算机,涉及Python、C、Java等语言.参加Robocup,ACM,未来打算弄机器学习、数据挖掘方面"},{"title":"css","date":"2018-08-31T11:13:48.000Z","updated":"2018-08-31T11:19:21.810Z","comments":false,"path":"tags/index.html","permalink":"https://nymrli.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"开源项目代码阅读记录","slug":"开源项目代码阅读记录","date":"2022-03-29T09:54:46.000Z","updated":"2022-03-29T10:46:16.728Z","comments":true,"path":"2022/03/29/开源项目代码阅读记录/","link":"","permalink":"https://nymrli.top/2022/03/29/开源项目代码阅读记录/","excerpt":"","text":"taobao_seckill jd_seckill","categories":[],"tags":[{"name":"代码阅读","slug":"代码阅读","permalink":"https://nymrli.top/tags/代码阅读/"}]},{"title":"Python进阶","slug":"Python进阶","date":"2022-03-27T14:30:39.000Z","updated":"2022-03-28T08:45:22.726Z","comments":true,"path":"2022/03/27/Python进阶/","link":"","permalink":"https://nymrli.top/2022/03/27/Python进阶/","excerpt":"","text":"setattr setattr() 函数对应函数 getattr()，用于设置属性值，该属性不一定是存在的。如果属性不存在会创建一个新的对象属性，并对属性进行赋值。 setattr() 语法：setattr(object, name, value) getattr() getattr() 函数用于返回一个对象属性值。getattr(object, name[, default]) object – 对象。 name – 字符串，对象属性。 default – 默认返回值，如果不提供该参数，在没有对应属性时，将触发 AttributeError。 __get__,__getattr__,__getattribute__及区别 1.object.__getattribute__(self, name) 无条件被调用，通过实例访问属性、函数（点和getattr函数都会触发）。如果class中定义了__getattribute__()和__getattr__()，则只有在显式调用或引发AttributeError异常才会调用__getattr__() 注： 只要定义了__getattribute__方法，不管你访问一个存在的还是不存在的属性，都由这个方法返回，比如访问t.a，虽然a存在，但是只要定义了这个访问，那么就不是访问最开始的a了 如果__getattribute__抛出了AttributeError异常，并且定了了getattr函数，那么会调用getattr这个函数并返回getattr函数的返回值 属性访问的一个大致优先级是：__getattribute__ &gt; __getattr__ &gt; __dict__ 2.object.__getattr__(self, name) 为内置方法，当使用点号获取实例属性时，如果属性不存在(找不到attribute)的时候，会调用__getattr__，返回一个值或AttributeError异常。 1234567class p(): s = 2 def __getattr__(self, item): return \"hello\"d = p()print(d.s) # ==&gt; 2print(d.p) # ==&gt; hello 注：如果属性不存在，则不管是否有__getattribute__，都会调用__getattr__ 3.object.__get__(self, instance, owner) 方法的第一个参数是实际拥有者的实例，如果没有则为None，第二个参数是实际所属的类。 一个类只要实现了__get__、 __set__,__delete__中任意一个方法，我们就可以叫它描述器（descriptor）。如果只定义了__get__我们叫非资料描述器（non-data descriptor），如果__set__、 __delete__：任意一个或者同时出现，叫资料描述器（data descriptor）。 首先明确一点，拥有这个方法的类，应该（也可以说是必须）产生一个实例，并且这个实例是另外一个类的类属性（注意一定是类属性，通过self的方式产生就不属于__get__范畴了）。 也就是说拥有这个方法的类，那么它的实例应该属于另外一个类/对象的一个属性。直接看代码吧： owner是所有者的类，instance是访问descriptor的实例，如果不是通过实例访问，而是通过类访问的话，instance则为None。（descriptor的实例自己访问自己是不会触发__get__，而会触发__call__，只有descriptor作为其它类的属性才有意义。）（所以下文的d是作为C2的一个属性被调用） 12345678910111213class TestDes: def __get__(self, instance, owner): print(instance, owner) return 'TestDes:__get__' class TestMain: des = TestDes() if __name__ == '__main__': t = TestMain() print(t.des) print(TestMain.des)# 其中TestDes定义了__get__方法，在TestMain中，定义了一个类属性des，是TestDes的一个实例，我们访问t.des或者TestMain.des的时候访问的就是访问了TestDes的__get__方法。 至于区别，首先关注：a.x时发生了什么?=&gt;属性的lookup顺序如下: 如果重载了__getattribute__,则调用. a.__dict__, 实例中是不允许有descriptor的,所以不会遇到descriptor A.__dict__, 也即a.__class__.__dict__.如果遇到了descriptor,优先调用descriptor. 沿着继承链搜索父类.搜索a.__class__.__bases__中的所有__dict__. 如果有多重继承且是菱形继承的情况,按MRO(Method Resolution Order)顺序搜索. 针对描述器的说明： 描述器是被__getattribute__调用的，如果重写了这个方法，将会阻止自动调用描述器，资料描述器总是覆盖了实例的__dict__， 非资料描述器可能覆盖实例的__dict__。 小结：访问存在的属性，如果是描述器，描述器生效 12345678910111213class TestDes: # 方法的第一个参数是实际拥有者的实例，如果没有则为None，第二个参数是实际所属的类。 def __get__(self, instance, owner): print(instance, owner) return 'TestDes:__get__' class TestMain: des = TestDes() if __name__ == '__main__': t = TestMain() print(t.des) print(TestMain.des) # 调用时instance输出None 非资料描述器，也就是只有__get__，不管是类还是实例去访问，默认都获得的是__get__的返回值，但是，如果中间有任何一次重新赋值(t.des = 1)，那么，这个实例获得的是新的值(对象)，已经和原来的描述器完全脱离了关系(描述器__get__函数失效) 资料描述器，比如有__set__方法，后期通过实例对描述器进行赋值，那么访问的是__set__，并且永远关联起来==&gt;针对上述问题的修复。但是如果通过修改类属性的方式复制(TestMain.des = 1)，那么也会被重新获取新的值(对象)，即__set__函数失效。 总结： 可以看出，每次通过实例访问属性，都会经过__getattribute__函数。而当属性不存在时，仍然需要访问__getattribute__，不过接着要访问__getattr__，就好像是一个异常处理函数。 每次访问descriptor（即实现了__get__的类），都会先经过__get__函数。 需要注意的是，当使用类访问不存在的变量是，不会经过__getattr__函数。而descriptor不存在此问题，只是把instance标识为none而已。 参考： python的__get__方法看这一篇就足够了 more：Python进阶-----描述符(get(),set(),delete()) __dict__ Python中大多以对象的形式存在，而对象的属性则是存在__dict__属性中 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在**类__dict__**里的 对象的__dict__中存储了一些self.xxx的一些东西 注意 内置的数据类型没有__dict__属性，如list、dict、int 每个类有自己的__dict__属性，就算存着继承关系，父类的__dict__ 并不会影响子类的__dict__ 对象也有自己的__dict__属性， 存储self.xxx 信息，父子类对象公用__dict__","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"JS逆向-webpack打包网站实战","slug":"JS逆向-webpack打包网站实战","date":"2022-03-23T08:21:50.000Z","updated":"2022-03-28T13:25:35.306Z","comments":true,"path":"2022/03/23/JS逆向-webpack打包网站实战/","link":"","permalink":"https://nymrli.top/2022/03/23/JS逆向-webpack打包网站实战/","excerpt":"","text":"Webpack逆向 webpack打包是前端js模块化压缩打包常用的手段，特征明显，比如下方的形式的代码就是webpack分发器 123456// 分发器!function(x)&#123; function xx(n)&#123; return ..call(**.exports, ***, ***.exports, xx) &#125;&#125;() 又或者更直观的表现n[“xxx”]这种，你可以大概知道了这是调用了webpack打包的js模块代码。 webpack打包后JS依赖模块代码的固定结构： 12345678(this[\"webpackJsonpzsgk-pc\"] = this[\"webpackJsonpzsgk-pc\"] || []).push([[15], [function(e, t, n) &#123; \"use strict\"; e.exports = n(693)&#125;// 参数固定为e, t, n, function(e, t, n) &#123; e.exports = n(697)()&#125; 说个逆向webpack的通用方法： 先去找加密网站的加密入口。这应该是加密网站都必须要做的==&gt; 直接根据参数名搜索参数 找到分发器的位置，或者说是加载器，n[“xxx”]这种的n就是分发器，就比如下方中的exports的位置，最后执行了d函数==&gt;一般是runtimexxx.js中(提供环境)；一般以! function(e) {的形式出现 寻找分发编号、加密使用模块（用到了哪些模块就导入哪些模块）==&gt;一般在chunk-lib.js，以(window.webpackJsonp = window.webpackJsonp || []).push([的形式出现 将函数入口的地方返回全局变量，最终返回: var sign; var window = global;!function(){... sign = d}， 赋值为分发器返回的d 使用自定义的sign代替webpack代码中的n进行加密 from: https://blog.csdn.https😕/blog.csdn.net/weixin_41586984/article/details/116268341net/weixin_41586984/article/details/116268341 调试技巧 定位请求参数 打开开发者工具后，F5刷新后Ctrl + Shift + F搜索参数名，如signdata，会显示多个JS文件，选择后仔细查看(点击左下角{}美观格式化按钮)。 more： 如果文件太多，则直接通过请求的链接去找，比如user/login Network找到新发出的xhr条目后，查看Initiator里的调用栈信息，如Login； 注： 如果加密参数名称比较简单如s，比较难定位的话，可以借助请求的其他参数来查找，比如verificationCode 调试工具 断点调试breakpoints XHR断点： XHR/fetch breakpoints 附录-Js记录 时间戳: (new Date).getTime() var a = (f1(), f2(), f3())后，f1、f2、f3函数都会执行，而a最后的结果为f3的返回值 javascript:void(0): void 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值。 TypeError: window.btoa is not a function btoa-atob 模块没有输出一个编程接口，它只提供命令行工具。 如果你需要转换为Base64，你可以用Buffer来完成。 1console.log(Buffer.from('Hello World!').toString('base64')); 相反的，假设你要解码的内容是一个base64编码过的字符串。 1console.log(Buffer.from(b64Encoded, 'base64').toString()); 做题记录 n[“str”]题型： 天安财险 var m = this.newEncrypt(JSON.stringify(h)); 需要对this.privaKey的值细化下，传入拿到固定的str 123456789101112// , p = t(\"NFKh\") , s = t(\"cg2h\")l.prototype.newEncrypt = function(l) &#123; var n = p.enc.Utf8.parse(this.privaKey) , t = p.enc.Utf8.parse(this.privaKey) , e = p.enc.Utf8.parse(l) , a = p.AES.encrypt(e, n, &#123; iv: t, mode: p.mode.CBC, padding: p.pad.Pkcs7 &#125;); return p.enc.Base64.stringify(a.ciphertext) &#125; 财新网 password: this.encode(this.encrypt(this.form.password)), c = a(&quot;3452&quot;)、n = a.n(c)，看到需要依赖3452后立马Ctrl+shift+F全局搜3452，然后把整个webpack模块扒下来 中远海运 n(“MuMZ”)中又有r = n(&quot;XBrZ&quot;);，在另一个文件中，module需要放两个 天翼云： var t = encodeURIComponent(c[&quot;c&quot;].Des.encrypt(this.form.email, this.form.pwd)), webpack实现 c = (mycode(&quot;ac6a&quot;), mycode(&quot;b3ae&quot;)) 分发器和ac6a模块在同一个文件中、而ac6a模块依赖模块在另一个文件内； 分发器()({})，无感叹号 分发器()({})大括号中自带较多依赖模块 自己实现：直接扒下来encrypt加密的JS内容 看准网 分发器n(“xxx”)定位后跟一般的固定格式返回a、n、r不同，写的是个函数==&gt;还是可以根据obj.Func来赋值mycode = obj; JS逆向实战分析–看准网webpack加解密分析——Python中使用execjs示范 企名片 u = i(&quot;x4Ab&quot;) return e.encrypt_data &amp;&amp; (e.data = Object(u.a)(e.encrypt_data)), x4Ab模块依赖aqBw，aqBw又依赖YuTi、yLpj，因此依赖项中放&quot;x4Ab&quot;、“aqBw”、“YuTi”、&quot;yLpj&quot;函数定义 模拟解析函数 123function encrypt(data)&#123; return data &amp;&amp; (Object(u.a)(data))&#125; n[num]题型： 大麦 删除分发器多余代码 var navigator = {} 掌上高考： 分发器在html文件内 o = (u=a(42), a.n(u))，使用到了a.n(u)即点n函数 依赖函数的给出是以数组的形式，而不是字典的形式 模块中依赖更多模块==&gt;引入整个模块文件，但是跟&quot;xxx&quot;模式不同的是，由于没有用字典{&quot;xxx&quot;: function()}的形式，因此直接require也没用TypeError: Cannot read property '42' of undefined，而是将依赖模块数组作为参数写入到分发器依赖函数中!function(e){}([...])即方括号中，从而才能找到42函数 酷我 t.data.reqId = n, 直接通过n(109)定位可能不那么准确(双击后定位的函数)，可以试着直接在分发器位置进行断点，然后console输出e[“109”] 只要分发器定义部分(其他的删了，因为只用了l=n(109)、c=n.n(l))+依赖模块中定义109函数(整个function而不是t.exports)，以及观察其中还依赖什么如n(202)、n(203)就补充拿什么 n.n(l)是传入什么就返回什么:https://www.bilibili.com/video/BV1gq4y1D781?from=search&amp;seid=7720105602891609746&amp;spm_id_from=333.337.0.0 12345678910// 如果不删分发器中其他部分l = mycode(109)c = mycode.n(l) // ==&gt;得到lvar r = c()();console.log(r)// 由于只用到了n.n(l)，所以可以删分发器大代码中其他部分, 在使用时直接让c=ll = mycode(109)c = l();console.log(c) // 等价于 r = l(); console(r) 文章: https://blog.csdn.net/weixin_43189702/article/details/119860838 注意： require模块内容可以放在逆向JS文件里一起，而不是一定得创建新的JS文件导入 先登录然后找到加密处加断点，这个断点会在发起登录请求时才触发；往上找分发器，加上断点，分发器位置的断点是在页面刷新时触发，因此要触发这个断点需要刷新页面 找加密函数c[&quot;c&quot;].Des.encrypt(this.form.email, this.form.pwd)的时候，找完整的函数如c[“c”].Des.encrypt，而不是直接找c n(42), 或者n(“xxx”)，可以直接搜xxx，也可以在console里面输出后找到对应的FunctionLocation来快速定位 如果依赖模块是字典的形式，则分发器依赖中写字典，如!function(e){..}({ 32:function(){...}})（一般情况n(32)、n(&quot;ABCD&quot;)）， 如果不是则需要传函数数组，如n(42)，此处42表示的是第42个函数，见掌上高考。 var mycode;后赋值的位置直接在分发器的下方即可，不用在最后面 提示缺少window时，定义全局变量var window = global;，（JS逆向文件、依赖文件） window表示浏览器打开的窗口，在客户端JavaScript中window对象是全局的对象，所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。但在nodejs中直接调用window是不存在的，而代替的是global，所以要用nodejs运行时，得用var window = global; var navigator = this等价于var navigator = {}，因为在NodeJS文件中运行输出this后可以发现this={}，而在浏览器中this默认为window（函数或类作用域内为函数或者类实例） from：JS中document和window的区别 心得 ①所有webpack打包的的js都要先看懂打包后代码运行的顺序，找到加密处；②找到webpack对象，一般是 n(数字) 调用③确定分发器。④找依赖模块，有时候各包的依赖关系太多，可以直接把文件爬下来引入，如果各个包的依赖关系不多，就可以只把调用到的函数找出来放到依赖中。⑤最后剩下的就是找到你要的代码，慢慢复现调用加密/解密函数就好了。 做题案例学习视频 webpack师承：爬取webpack流程-视频——大多都是n(“Xvmd”) 而如果n中调用的不是字典的形式，而是列表的形式，则看js逆向安全指南（3）-- webpack解包指南、使用 webpack 的 js 加密参数的分析——酷我 进阶资料 9-爬虫高级实战【js逆向】 JS逆向学习笔记 - 持续更新中 webpack补充依赖项做法： https://www.jianshu.com/p/5c42730a4e84 webpack4之《模块运行机制原理》 JS逆向视频 爬虫工程师进阶必会之JS逆向(反爬) 遇到网站加密爬不了？？这几个视频教你如何学会爬虫高阶内容js逆向，入狱必学！ 掌上高考解密过程 解析响应data.text 相应的data.text是加密的，页面通过JS解密后渲染 确定加密位置 12345return null != l &amp;&amp; null !== (a = l.data) &amp;&amp; void 0 !== a &amp;&amp; a.text &amp;&amp; (l.data = (n = (e = &#123; iv: u.uri, text: l.data.text, SIGN: h &#125;).iv, 确定分发器位置，在html内 通过打断o = (u=a(42), a.n(u)) // 等价于 o = a(42) 确定依赖模块：给return e[a].call(c.exports, c, c.exports, r),打断点后console输出e[&quot;42&quot;]查看a(42)位置： 12345678function(e, t, n) &#123; e.exports = (e = n(21), n(201), n(825), ... n(847), e)&#125; 可以看到需要依赖多个，因此直接把整个文件引入 扣解密函数：注意return表达式后是逗号的情况：会从左到右执行执行，并返回最后一个。注意：JS函数并不能返回多个返回值 12345678910111213141516171819202122232425262728293031323334then((function(l) &#123;var e, a, t, b, n;return null != l &amp;&amp; null !== (a = l.data) &amp;&amp; void 0 !== a &amp;&amp; a.text &amp;&amp; (l.data = (n = (e = &#123; iv: u.uri, text: l.data.text, SIGN: h &#125;).iv, a = e.text, e = e.SIGN, e = o.a.PBKDF2(e, \"secret\", &#123; keySize: 8, iterations: 1e3, hasher: o.a.algo.SHA256 &#125;).toString(), n = o.a.PBKDF2(n, \"secret\", &#123; keySize: 4, iterations: 1e3, hasher: o.a.algo.SHA256 &#125;).toString(), a = o.a.lib.CipherParams.create(&#123; ciphertext: o.a.enc.Hex.parse(a) &#125;), n = o.a.AES.decrypt(a, o.a.enc.Hex.parse(e), &#123; iv: o.a.enc.Hex.parse(n) &#125;), // data.text解析结果 JSON.parse(n.toString(o.a.enc.Utf8)))), v &amp;&amp; (t = r, b = l, null !== (n = window.apiConfig) &amp;&amp; void 0 !== n &amp;&amp; null !== (n = n.filterCacheList) &amp;&amp; void 0 !== n &amp;&amp; n.length ? window.apiConfig.filterCacheList.forEach((function(l) &#123; new RegExp(l).test(t) || d.set(t, b) &#125;)) : d.set(t, b)), l&#125; 难点： 跟&quot;xxx&quot;模式不同的是，由于没有用字典{&quot;xxx&quot;: function()}的形式，因此直接require也没用TypeError: Cannot read property '42' of undefined，而是将依赖模块函数数组作为参数写入到分发器依赖函数中!function(e){}([...])即方括号中，从而才能找到42函数 挑选push后第二个[]中的函数数组 1234567(this[\"webpackJsonpzsgk-pc\"] = this[\"webpackJsonpzsgk-pc\"] || []).push([[15], [function(e, t, n) &#123; \"use strict\"; e.exports = n(693)&#125;, ... &#125;]]); // 第一个] 理解了a.n的含义后，可以直接把o = (u=a(42), a.n(u))转化为o=a(42) 获得加密参数signsafe 大致流程跟data.text差不多，但是p = c()(g)执行时，会报错 12345678&gt; Md5.prototype.update = function(e) &#123;&gt; if (!this.finalized) &#123;&gt; var t, n = typeof e;&gt; if (\"string\" != n) &#123;&gt; if (\"object\" != n)&gt; throw ERROR;&gt; if (null === e)&gt; 根据一步步调试之后发现，还是c = (u=a(291),a.n(u))直接替换出的问题 Ctrl + shift + F定位参数 12345678910g = void 0, g = (t = &#123; SIGN: h, str: f.replace(/^\\/|https?:\\/\\/\\/?/, \"\")&#125;).SIGN, t = t.str, g = o.a.HmacSHA1(o.a.enc.Utf8.parse(t), g), g = o.a.enc.Base64.stringify(g).toString(), p = c()(g), u.signsafe = p, 往上找c和o.a: o = (u = a(42),a.n(u)), c = (u = a(291),a.n(u)) 找到分发器扣出==&gt;这次不能删除分发器中多余的函数，比如r.a、r.d、r.n因为后面得用 将依赖模块跟data.text一样，放入分发器依赖模块中 扣加密函数 网页上是return后多段内容，以及g变量不断被修改，因此通过一步步调试确定入参，以及分解return抽离出真正的加密参数signsafe 123456789101112131415161718192021222324252627h = \"D23ABC@#56\"var o = &#123;&#125;o.a = mycode(42)// ▲c = (u = mycode(291), mycode.n(u))/** * 对url进行加密 */function encrypt(f) &#123; g = (t = &#123; SIGN: h, str: f.replace(/^\\/|https?:\\/\\/\\/?/, \"\") &#125;).SIGN, t = t.str; // console.log(t, g); g = o.a.HmacSHA1(o.a.enc.Utf8.parse(t), g); // console.log(g) g = o.a.enc.Base64.stringify(g).toString(); // console.log(g) p = c()(g); return p;&#125;res = encrypt(\"https://api.eol.cn/web/api/counter?cid=1&amp;did=263\")console.log(res) 可以看到o.a和c的赋值是不一样的，虽然说大多数情况x = a.n(u)等价于x=u，但难免有时会有不一样，因此谨慎期间，还是还原到底最好。 Python调用 123456789import execjsdef get_signsafe_by_javascript(url): # 两个 JavaScript 脚本，两种方法均可 with open('gk_signsafe.js', 'r', encoding='utf-8') as f: exec_js = f.read() signsafe = execjs.compile(exec_js).call('encrypt', url) return signsafesignsafe = get_encrypted_password_by_javascript(\"https://api.eol.cn/web/api/counter?cid=1&amp;did=263\")print(signsafe) RSA的加密步骤 获取公钥 实例化 ===&gt; 扣出网站RSA实例化对象的代码 设置公钥 对文本进行加密 ==&gt; 扣出复现RSA加密的逻辑代码 注： var window=global、var navigator={} B站RSA： 1234567// window.JSEncrypt is not a constructor 在抠出来的JS Encrypt代码中加上window.JSEncrpt = ze// 网页中位var n = new JSEncrypt ==&gt; JSEncrypt is not definedvar n = new window.JSEncrypt;n.setPublicKey...var a = n.encrypt(t.data.hash + password);console.log(a) 网易云爬评论：python通过execjs来调用JS代码，代码中用到了CryptoJS库， 需要os.environ[&quot;NODE_PATH&quot;]=&quot;F:/..../node_modules&quot;把库导入 JS逆向实战分析–某铁网分析：document返回类型，initiator是一条条文本(Other)，因为其没有用ajax(XHR)，而是通过原生的网页表单提交 12loginForm.password.value = encryptByDES(loginForm.password.value), loginForm.publickey.value);loginForm.submit(); 直接require导入CryptoJS模块 or直接扣encryptByDES的加密函数==&gt;出现cannot read property 'createEncryptor' of undefined MD5加密： JS: const crypto = require(&quot;CryptoJS&quot;); crypto.MD5('待加密字符串').toString() Python: https://blog.csdn.net/weixin_44799217/article/details/112486097 12345678# 法一：创建md5对象hl = hashlib.md5()# Tips# 此处必须声明encode，若写法为hl.update(str) 报错为： Unicode-objects must be encoded before hashinghl.update(str.encode(encoding='utf-8'))# 法二：str_md5 = hashlib.md5(str.encode(encoding='utf-8')).hexdigest() base64编码 JS: CryptoJS.enc.Base64.parse(&quot;待解密字符串&quot;).toString(CryptoJS.enc.Utf8) Python 12345678910# 字符串encode_str = base64.encodebytes(test_str.encode('utf8')) # b'aGVsbG8gd29ybGQh\\n'print(encode_str.decode()) # 默认以utf8解码，结果 aGVsbG8gd29ybGQh# 图片with open(\"D:\\\\redis.png\", 'rb') as f: encode_img = base64.b64encode(f.read()) file_ext = os.path.splitext(\"D:\\\\redis.png\")[1] print('data:image/&#123;&#125;;base64,&#123;&#125;'.format(file_ext[1:], encode_img.decode())) f.close() 加密、摘要算法结果特征 Base64特征 最常见的用于传输8Bit字节码的编码方式之一 相同内容，结果是相同的 a-zA-Z,0-9,+/共64个字符进行编码；每3个字节编码成4个字节，不足的在结尾有无意义的**=**来填补 一般情况下结尾都会有1个或者2个等号，明文长度是3的倍数时没有=； 内容越长，结果越长 注：跟下面的算法区分一下，base64是编码方式，并不能算加密算法。应用场景还有传输图片:data:image/jpg;base64,/9j/4QMZRXhpZgAASUk... md5特征 消息摘要算法 确定唯一性：相同内容，结果是相同的；但一般会有时间戳等参数，所以导致了每次不同 不可逆性：有损的加密过程，理论上无法解密（逆向推出），除非暴力破解。安全，这也是其成为校验是否被修改的最关键的性质 碰撞性：原始数据与其MD5值并不是一一对应的，有可能多个原始数据计算出来的MD5值是一样的，这就是碰撞。 一般MD5值是32位，由数字“0-9”和字母“a-f”所组成的字符串；字母可以是全大写或者全小写 密文一般为 16 位或者 32 位，其中 16 位是取的 32 位第 9~25 位的值； 长度：32个十六进制字符组成的字符串 (128位) RSA特征 相同内容，结果也是不同的 明文长度需要小于密钥长度，而密文长度则等于密钥长度。一般为1024、2048、3072、4096或512（低于1024的安全不建议） 通过公钥加密结果，必须私钥解密。 同样私钥加密结果，公钥可以解密 注：RSA加解密中必须考虑到的密钥长度、明文长度和密文长度问题； ▲.一般会使用 JSEncrypt 库，会有 new 一个实例对象的操作； SHA 系列 SHA 是比 MD5 更安全一点的摘要算法，SHA 通常指 SHA 家族算法， sha1 字母（a-f）和数字（0-9）混合 密文特征跟MD5差不多，只不过数字是40位，bit位数（160）==&gt;4位十六进制表示一个数 Sha256 字母（a-f）和数字（0-9）混合 对于任意长度的消息，SHA256都会产生一个256位的哈希值，即64位十六进制数，称作消息摘要。 HMAC 在md5和sha1加密的基础上引入了秘钥，而秘钥又只有传输双方才知道，所以基本上是破解不了的，常用于接口签名验证 AES、DES、3DES、RC4、Rabbit 等 AES、DES、3DES、RC4、Rabbit 等加密算法的密文通常没有固定的长度，他们通常使用crypto-js库来实现 参考：https://juejin.cn/post/7052978567390429215","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"}]},{"title":"2022年3月19~20日-爬虫项目记录","slug":"2022年3月19日-爬虫项目记录","date":"2022-03-19T11:06:06.000Z","updated":"2022-03-21T11:55:36.736Z","comments":true,"path":"2022/03/19/2022年3月19日-爬虫项目记录/","link":"","permalink":"https://nymrli.top/2022/03/19/2022年3月19日-爬虫项目记录/","excerpt":"","text":"2022年3月20日——公告存网站页面到数据库 文件存储 文件夹不允许出现/\\:*?|&lt;&gt;&quot; a标签中href不能有, 因为通过etree.tostring会被转义成%5C===&gt;进行了str.replace(&quot;\\&quot;, “/”) windows下路径分隔符是\\\\, 所以save_path中会有\\\\, 因此使用save_path.replace(&quot;\\\\&quot;, &quot;/&quot;)可以解决 多级创建文件夹os.makedirs()、单层创建os.mkdir() 5文件名称问题: 乱码太长报错, 将其取a标签中内容解决 12345# 乱码太长报错s = \".\\\\attaches\\\\11963218-2021年09月22日华能能源交通产业控股有限公司集团物资供应中心（甘肃区域）07月份集中物资供应--八零三电厂阀门询价采购（包093）询价书询价公告\\\\������������������������������������������07������������������������--���������������������������������������093���.wps\"with open(s, \"wb\") as f: f.write(b\"ggg\") 数据库表 varchar能存多少汉字、数字？ 具体还是要看版本的，一个字符占用3个字节 ，一个汉字（包括数字）占用3个字节=一个字符 4.0版本以下，varchar(100)，指的是100字节，如果存放UTF8汉字时，只能存33个（每个汉字3字节） 5.0版本以上**，varchar(100)，指的是100字符，⭐️无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放100个。 UTF8编码中一个汉字（包括数字）占用3个字节 GBK编码中一个汉字（包括数字）占用2个字节* varchar的最大长度是多少呢？ mysql的vachar字段的类型虽然最大长度是65535，但是并不是能存这么多数据，最大可以到65533，其中需要1到2个字节来存储数据长度（如果列声明的长度超过255，则使用两个字节来存储长度，否则1个）字节，当不允许非空字段的时候（因为要用一个字节来存储不可为空的标识），当允许非空字段的时候只能到65532(省下了存储非空的那个字节)。 mysql字段类型存储需要多少字节？ 数字类型 列类型 需要的存储量 TINYINT 1 字节 SMALLINT 2 个字节 MEDIUMINT 3 个字节 INT 4 个字节 INTEGER 4 个字节 BIGINT 8 个字节 FLOAT(X) 4 如果 X &lt; = 24 或 8 如果 25 &lt; = X &lt; = 53 FLOAT 4 个字节 DOUBLE 8 个字节 DOUBLE PRECISION 8 个字节 REAL 8 个字节 DECIMAL(M,D) M字节(D+2 , 如果M &lt; D) NUMERIC(M,D) M字节(D+2 , 如果M &lt; D) 日期和时间类型 列类型 需要的存储量 DATE 3 个字节 DATETIME 8 个字节 TIMESTAMP 4 个字节 TIME 3 个字节 YEAR 1 字节 串类型 列类型 需要的存储量 CHAR(M) M字节，1 &lt;= M &lt;= 255 VARCHAR(M) L+1 字节, 在此L &lt;= M和1 &lt;= M &lt;= 255 TINYBLOB, TINYTEXT L+1 字节, 在此L&lt; 2 ^ 8 BLOB, TEXT L+2 字节, 在此L&lt; 2 ^ 16 MEDIUMBLOB, MEDIUMTEXT L+3 字节, 在此L&lt; 2 ^ 24 LONGBLOB, LONGTEXT L+4 字节, 在此L&lt; 2 ^ 32 ENUM(‘value1’,‘value2’,…) 1 或 2 个字节, 取决于枚举值的数目(最大值65535） SET(‘value1’,‘value2’,…) 1，2，3，4或8个字节, 取决于集合成员的数量(最多64个成员） MySQL中类型后面的数字含义 形式：类型(m) 整数型的数值类型已经限制了取值范围，有符号整型和无符号整型都有，而M值并不代表可以存储的数值字符长度，它代表的是数据在显示时显示的最小长度，当存储的字符长度超过M值时，没有任何的影响，只要不超过数值类型限制的范围。当存储的字符长度小于M值时，只有在设置了zerofill用0来填充，才能够看到效果，换句话就是说，没有zerofill，M值就是无用的。 字符型如varchar(50) 可以储存50个字符，表示的是可变不定长的。 mySQL默认字符集 MySQL对于字符集的指定可以细化到一个数据库，一张表，一列，应该用什么字符集。 但是，传统的程序在创建数据库和数据表时并没有使用那么复杂的配置，它们用的是默认的配置，那么，默认的配置从何而来呢？ 编译MySQL 时，指定了一个默认的字符集，这个字符集是 latin1； 安装MySQL 时，可以在配置文件 (my.ini) 中指定一个默认的的字符集，如果没指定，这个值继承自编译时指定的； 启动mysqld 时，可以在命令行参数中指定一个默认的的字符集，如果没指定，这个值继承自配置文件中的配置,此时 character_set_server 被设定为这个默认的字符集； 当创建一个新的数据库时，除非明确指定，这个数据库的字符集被缺省设定为character_set_server； 当选定了一个数据库时，character_set_database被设定为这个数据库默认的字符集； 在这个数据库里创建一张表时，表默认的字符集被设定为 character_set_database，也就是这个数据库默认的字符集； 当在表内设置一栏时，除非明确指定，否则此栏缺省的字符集就是表默认的字符集； 最终create.sql文件 12345678910111213141516171819202122SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;CREATE DATABASE if not EXISTS `huaneng` ;use `huaneng`;-- ------------------------------ Table structure for quotation_inone-- ----------------------------DROP TABLE IF EXISTS `quotation_inone`;CREATE TABLE `quotation_inone` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, `date` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, `content` LONGTEXT NULL DEFAULT NULL, `proclamation_url` VARCHAR(512) NULL DEFAULT NULL, UNIQUE INDEX (`proclamation_url`), PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;SET FOREIGN_KEY_CHECKS = 1; 2022年3月20日-护士题目下载存Word 索引报错 MySQL 添加索引报错：BLOB/TEXT column used in key specification without a key length 当我们对一个名称为platform的字段，类型为 text 添加unique唯一性约束和索引约束时，会报错。 原因：MySQL只能将BLOB/TEXT类型字段设置索引数据的前N个字符，因此，只需要通过sql在增加索引时指定对应字段的长度即可，如： ALTER TABLE hello_world ADD INDEX key1(platform(250), platform2(250), type);, 其中，platform 和 platform2 就是 text 类型的数据 more: https://www.cnblogs.com/wqbin/p/11903878.html 根本原因： 错误发生的原因是因为MySQL只能将BLOB/TEXT类型字段设置索引为BLOB/TEXT数据的前N个字符，因此错误常常发生在字段被定义为TEXT/BLOB类型或者和TEXT/BLOB同质的数据类型，如TINYTEXT,MEDIUMTEXT,LONGTEXT ,TINYBLOB,MEDIUMBLOB 和LONGBLOB，并且当前操作是将这个字段设置成主键或者是索引的操作。在未指定TEXT/BLOB‘键长’的情况下，字段是变动的并且是动态的大小所以MySQL不能够保证字段的唯一性。因此当使用TEXT/BLOB类型字段做为索引时，N的值必须提供出来才可以让MySQL决定键长，但是MySQL不支持在TEXT/BLOB限制，TEXT(88)是不行的。 解决方案是将unique限制和索引从TEXT/BLOB字段中移除，或者是设置另一个字段为主键，如果你不愿意这样做并且想在TEXT/BLOB上加限制，那么你可以尝试将这个字段更改为VARCHAR类型，同时给他一个限制长度，默认VARCHAR最多可以限定在255个字符，并且限制要在声明类型的右边指明，如VARCHAR(200)将会限制仅仅200个字符.(注: 但是mysql不支持对TEXT/BLOB长度的限制。) https://blog.csdn.net/u012069924/article/details/28858337 ▲. 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。Java 开发手册 33/44 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。 数据库插入数据 123-- \\\\表示一个\\use xian_nurse;insert into `question` (`path`) VALUES ('书籍\\\\C-《传染病护理学习指导与习题集》-选择题'), ('书籍\\\\C-《传染病护理技术学习指导与习题集》-选择题'), ('书籍\\\\C-《传染病护理技术学习指导与习题集》-题干题'), ('书籍\\\\C-《成人护理学学习指导与习题集-人民卫生出版社》-选择题'), ('书籍\\\\C-《成人护理学学习指导与习题集-人民卫生出版社》-题干题'), ('书籍\\\\E -《儿科护理学实践与学习指导（十三五）》—选择题'), ('书籍\\\\E -《儿科护理学实践与学习指导（十三五）》—题干题'), ('书籍\\\\E-《2020年（护理学专业）副主任、主任护师职称考试习题集》-选择题'), ('书籍\\\\E-《2020年（护理学专业）副主任、主任护师职称考试习题集》-题干题'), ('书籍\\\\E-《2020康复医学与医疗技术精选习题集-人民卫生出版社》-选择题'), ('书籍\\\\E-《2020康复医学与医疗技术精选习题集-人民卫生出版社》-题干题'), ('书籍\\\\E-《2021年护士资格考试指导》-选择题'), ('书籍\\\\E-《2021年护士资格考试指导》-题干题'), ('书籍\\\\E-《2021年护理学同步练习题集（中级）》-选择题'), ('书籍\\\\E-《2021年护理学同步练习题集（中级）》-题干题'), ('书籍\\\\E-《2021年护理学（师）练习题集》-选择题'), ('书籍\\\\E-《2021年护理学（师）练习题集》-题干题'), ('书籍\\\\E-《2021护师精选习题解析》-选择题'), ('书籍\\\\E-《2021护师精选习题解析》-题干题'), ('书籍\\\\E-《2021护理儿科学（中级）精选习题》-选择题'), ('书籍\\\\E-《2021护理儿科学（中级）精选习题》-题干题'), ('书籍\\\\E-《2021护理内科学（中级）精选练习题》-选择题'), ('书籍\\\\E-《2021护理内科学（中级）精选练习题》-题干题'), ('书籍\\\\E-《2021护理外科学（中级）精选练习题》-选择题'), ('书籍\\\\E-《2021护理外科学（中级）精选练习题》-题干题'), ('书籍\\\\E-《2021护理妇产科学（中级）精选练习题》-选择题'), ('书籍\\\\E-《2021护理妇产科学（中级）精选练习题》-题干题'), ('书籍\\\\E-《2021护理学（中级）练习题集》-选择题'), ('书籍\\\\E-《2021护理学（中级）练习题集》-题干题'), ('书籍\\\\E-《2022年护理学（中级）同步练习题集》-选择题'), ('书籍\\\\E-《2022年护理学（中级）同步练习题集》-题干题'), ('书籍\\\\E-《2022年护理学（师）精选习题集》-选择题'), ('书籍\\\\E-《2022年护理学（师）精选习题集》-题干题'), ('书籍\\\\E-《2022护理学（师）同步练习题集》-选择题'), ('书籍\\\\E-《2022护理学（师）同步练习题集》-题干题'), ('书籍\\\\E-《儿科护理学实践与学习指导（十二五）》—名词解释、简答（规01）非考试题型'), ('书籍\\\\E-《儿科护理学实践与学习指导（十二五）》—选择题（规01）'), ('书籍\\\\E-《儿科护理学实践与学习指导（十二五）》—题干题（规01）'), ('书籍\\\\E-《儿童护理学实践与学习指导(十三五）》-题干题'), ('书籍\\\\E-《儿童护理学实践与学习指导（十三五）》-选择题'), ('书籍\\\\F-《妇产科和儿科护理技术》-选择题'), ('书籍\\\\F-《妇产科护理学-副主任护师、主任护师-职称考试习题集》-选择题'), ('书籍\\\\F-《妇产科护理学-副主任护师、主任护师-职称考试习题集》-题干题'), ('书籍\\\\F-《妇产科护理学实践与学习指导（十三五）》—名词解释、简答—非考试题型'), ('书籍\\\\F-《妇产科护理学实践与学习指导（十三五）》—选择题'), ('书籍\\\\F-《妇产科护理学实践与学习指导（十三五）》—题干题'), ('书籍\\\\F-《妇产科护理学实践与学习指导（十二五）》—名词解释、简答（规01）非考试题型'), ('书籍\\\\F-《妇产科护理学实践与学习指导（十二五）》—选择题（规01）'), ('书籍\\\\F-《妇产科护理学实践与学习指导（十二五）》—题干题（规01）'), ('书籍\\\\F-《妇幼保健机构医务人员“三基”训练复习题解护理分册》—名词解释简答-非考试题型'), ('书籍\\\\F-《妇幼保健机构医务人员“三基”训练复习题解护理分册》—选择题'), ('书籍\\\\F-《方剂学-易考易错练习题》-选择题'), ('书籍\\\\H-《护士“三基”训练试题精集》-选择题'), ('书籍\\\\H-《护士三基三严训练试题手册》-选择题'), ('书籍\\\\H-《护士临床“三基”实践指南测试题集》-选择题'), ('书籍\\\\H-《护理“三基”训练分册第2版》-选择题'), ('书籍\\\\H-《护理“三基”训练分册第2版》-题干题'), ('书籍\\\\H-《护理伦理与法律法规》-选择题'), ('书籍\\\\H-《护理伦理与法律法规》-题干题'), ('书籍\\\\H-《护理岗位技能训练50项考评指导（第4版）》——选择题'), ('书籍\\\\H-《护理核心制度学习与考核》—选择题'), ('书籍\\\\H-《护理法律法规-李洪峰-郑州大学出版社》-选择题'), ('书籍\\\\H-《护理管理学学习指导及习题集》—选择题'), ('书籍\\\\H-《新编护理学基础实训与实习指导（十三五）》-选择题'), ('书籍\\\\J-《健康管理师—模拟试题与精解释》-选择题'), ('书籍\\\\J-《健康管理师—模拟试题与精解释》-题干题'), ('书籍\\\\J-《健康评估实践与学习指导（十三五）》-选择题'), ('书籍\\\\J-《健康评估实践与学习指导（十三五）》-题干题'), ('书籍\\\\J-《基础护理学学习指导及习题集（十二五）》-选择题'), ('书籍\\\\J-《基础护理学实践与学习指导（十三五）》—选择题'), ('书籍\\\\J-《基础护理学实践与学习指导（十三五）》—题干题'), ('书籍\\\\J-《急危重症护理学实践与学习指导（十三五）》—选择题'), ('书籍\\\\J-《急危重症护理学实践与学习指导（十三五）》—题干题'), ('书籍\\\\J-《急危重症护理学实践与学习指导（十二五）》—名词解释、简答（规01）非考试题型'), ('书籍\\\\J-《急危重症护理学实践与学习指导（十二五）》—选择题（规01）'), ('书籍\\\\J-《急危重症护理学实践与学习指导（十二五）》—题干题（规01）'), ('书籍\\\\J-《精神科临床护理实践能力测试题库》—选择题'), ('书籍\\\\J-《精神科护理学学习指南与习题集（高职）》-选择题'), ('书籍\\\\J-《精神科护理学学习指南与习题集（高职）》-题干题'), ('书籍\\\\J-《精神科护理学实践与学习指导（十二五）》—选择题'), ('书籍\\\\J-《精神科护理学实践与学习指导（十二五）》—题干题'), ('书籍\\\\J-《经络腧穴学》-选择题'), ('书籍\\\\J-《静脉知识习题指导-人民卫生出版社》——选择题'), ('书籍\\\\K-《口腔护理学学习指导与习题集第三版》-选择题'), ('书籍\\\\K-《康复护理学实践与学习指导（十三五）》-选择题'), ('书籍\\\\K-《康复护理学实践与学习指导（十三五）》-题干题'), ('书籍\\\\K_《口腔科学学习指导与习题集》-选择题'), ('书籍\\\\L-《临床“三基”训练指南与习题集丛书(护理分册)》-选择题'), ('书籍\\\\L-《临床“三基”训练指南与习题集丛书(护理分册)》-题干题'), ('书籍\\\\L-《临床护理实践指南（2011年版）配套试题与解析》—选择题'), ('书籍\\\\L-《老年康复学学习指导及习题集》-选择题'), ('书籍\\\\L-《老年护理同步辅导习题》-选择题'), ('书籍\\\\L-《老年护理学学习指南与习题集（高职）》-选择题'), ('书籍\\\\L-《老年护理学学习指南与习题集（高职）》-题干题'), ('书籍\\\\L-《老年护理自考题》-选择题'), ('书籍\\\\M-《母婴护理学实践与学习指导（十三五）》—名词解释、简答题-非考试题型'), ('书籍\\\\M-《母婴护理学实践与学习指导（十三五）》—选择题'), ('书籍\\\\N-《内科护理学实践与学习指导（十三五）-尤黎明-吴瑛-人民卫生出版社》—选择题'), ('书籍\\\\N-《内科护理学实践与学习指导（十三五）-尤黎明-吴瑛-人民卫生出版社》—题干题'), ('书籍\\\\N-《内科护理学实践与学习指导（十二五)》—选择题（规01）'), ('书籍\\\\N-《内科护理学实践与学习指导（十二五）》—题干题（规01）'), ('书籍\\\\Q-《全国临床护理“三基”训练指南》-填空题'), ('书籍\\\\Q-《全国临床护理“三基”训练指南》-选择题'), ('书籍\\\\Q-《全国临床护理“三基”训练指南》-题干题'), ('书籍\\\\S-《实用中医护理学习题集》—选择题'), ('书籍\\\\S-《实用临床三基“理论篇”》—名词解释、简答题（规02）非考试题型'); 操作word 使用python-docx: python -m pip install python-docx， https://python-docx.readthedocs.io/en/latest/ 添加1-9级标题 12345678910111213141516from datetime import datetimefrom docx import Document# 创建新的docx文件document = Document()document.add_heading('1级标题', 1) # 添加1级标题document.add_heading('2级标题', 2) # 添加2级标题document.add_heading('3级标题', 3) # 添加3级标题document.add_heading('4级标题', 4) # 添加4级标题document.add_heading('5级标题', 5) # 添加5级标题document.add_heading('6级标题', 6) # 添加6级标题document.add_heading('7级标题', 7) # 添加7级标题document.add_heading('8级标题', 8) # 添加8级标题document.add_heading('9级标题', 9) # 添加9级标题document.save('&#123;&#125;.docx'.format(datetime.now().strftime('%Y%m%d%H%M%S'))) 添加段落 123456789101112131415from datetime import datetimefrom docx import Document# 创建新的docx文件document = Document()paragraph = \"\"\"这是一个段落\"\"\"paragraph2 = \"\"\"这是一个新的段落\"\"\"paragraph3 = \"\"\"这是一个新的段落。\"\"\"document.add_paragraph(paragraph)document.add_paragraph(paragraph2)document.add_paragraph(paragraph3)document.save('&#123;&#125;.docx'.format(datetime.now().strftime('%Y%m%d%H%M%S'))) 设置字体大小和样式 12345678910111213141516171819202122232425262728293031from datetime import datetimefrom docx import Document# 创建新的docx文件from docx.shared import Ptdocument = Document()document.add_paragraph(\"这是一个段落\") # 添加段落paragraph = document.add_paragraph(\"这是一个段落,\") # 添加段落run = paragraph.add_run('设置了字体的段落') # 在同一段添加内容, 即为了操作段落或单词的子字符串. 概念上讲，您需要为段落/文本的run每个部分创建一个实例。\"\"\"Append a run to this paragraph containing *text* and having characterstyle identified by style ID *style*. *text* can contain tab(``\\\\t``) characters, which are converted to the appropriate XML formfor a tab. *text* can also include newline (``\\\\n``) or carriagereturn (``\\\\r``) characters, each of which is converted to a linebreak.大概意思就是追加一个段落, 包含text, 且设置了格式, 我感觉是这样\"\"\"run.font.name = u'宋体' # 设置字体run.font.size = Pt(20) # 设置字号# run.font.color.rgb = RGBColor(255, 0, 0) # 设置红色run.font.underline = True # 设置下划线run1 = paragraph.add_run('\\t粗体')run1.bold = Truerun2 = paragraph.add_run('\\t斜体')run2.italic = True #图片居中设置paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER 12345678910111213Doc = Document() Doc.styles['Normal'].font.name = u'宋体'Doc.styles['Normal']._element.rPr.rFonts.set(qn('w:eastAsia'), u'宋体')Doc.styles['Normal'].font.size = Pt(10.5)Doc.styles['Normal'].font.color.rgb = RGBColor(0,0,0)Head = Doc.add_heading(\"\",level=1)# 这里不填标题内容run = Head.add_run(\"刚来csdn，这就是博客么，I了\")run.font.name=u'Cambria'run.font.color.rgb = RGBColor(0,0,0)run._element.rPr.rFonts.set(qn('w:eastAsia'), u'Cambria')Doc.add_paragraph(\"Python \")Doc.add_paragraph(\"Python 对word进行操作\")Doc.save(\"Python_word.docx\") from : https://www.pythonheidong.com/blog/article/692569/99875f167810b45f17e8/ 有序(无序)列表和引用 12345678910# 增加引用document.add_paragraph('123', style='Intense Quote')# 增加有序列表document.add_paragraph(u'有序列表元素1', style='List Number')document.add_paragraph(u'有序列别元素2', style='List Number')# 增加无序列表document.add_paragraph(u'无序列表元素1', style='List Bullet')document.add_paragraph(u'无序列表元素2', style='List Bullet') 表格和分页 12345678910111213141516171819202122# 增加图片（此处使用相对位置）# document.add_picture('jdb.jpg', width=Inches(1.25))# 增加表格table = document.add_table(rows=3, cols=3) # 3行3列hdr_cells1 = table.rows[0].cells # 第一行hdr_cells1[0].text = \"第一行,第一列\"hdr_cells1[1].text = \"第一行,第二列\"hdr_cells1[2].text = \"第一行,第三列\"hdr_cells2 = table.rows[1].cells # 第二行hdr_cells2[0].text = \"第二行,第一列\"hdr_cells2[1].text = \"第二行,第二列\"hdr_cells2[2].text = \"第二行,第三列\"hdr_cells3 = table.rows[2].cells # 第三行hdr_cells3[0].text = \"第三行,第一列\"hdr_cells3[1].text = \"第三行,第二列\"hdr_cells3[2].text = \"第三行,第三列\"# 增加分页document.add_page_break() 提取文字 123456789101112131415from docx import Documentpath = '/media/bobo/自动化办公/wordOperation/wordDemo/test2.docx'doc = Document(path)print(doc.paragraphs)# 输出的是列表，列表中一共有4份内容# [&lt;docx.text.paragraph.Paragraph object at 0x7fca95f0aba8&gt;,# &lt;docx.text.paragraph.Paragraph object at 0x7fca95f0abe0&gt;,# &lt;docx.text.paragraph.Paragraph object at 0x7fca95f0ab70&gt;, #&lt;docx.text.paragraph.Paragraph object at 0x7fca95f0ac50&gt;,]for paragraph in doc.paragraphs: print(paragraph.text) from : https://www.cnblogs.com/rainbow-tan/p/14981998.html https://www.cnblogs.com/wenshi-jj/p/15388808.html https://www.cnblogs.com/rencm/p/6285304.html https://blog.csdn.net/weixin_44576802/article/details/86552550——颜色 参考：https://www.cnblogs.com/wenshi-jj/p/15388808.html——页边距、页眉和页脚、分栏 共同点处理 文件保存 由于文件夹、文件名不允许有/\\:*?|&lt;&gt;&quot;，因此需要保存时如果出现这些字符得特别处理。 项目一：xxxx阻垢剂\\反渗透阻垢剂\\25KG询价书询价公告\\zxc.doc ==&gt; xxx阻垢剂、反渗透阻垢剂、25KG询价书询价公告\\zxc.doc，存储在attaches\\xxx阻垢剂、反渗透阻垢剂、25KG询价书询价公告\\zxc.doc 12345678910111213141516171819202122@staticmethod def format_name(name: str) -&gt; [bool, str]: \"\"\" 文件和文件夹名规范化 :param name: :return: \"\"\" invalid_char = [\"/\", \"\\\\\", \":\", \"*\", \"?\", \"|\", \"&lt;\", \"&gt;\", \"\\\"\"] rename = name valid = True for ch in invalid_char: if ch in rename: if ch == \"?\": rename = rename.replace(\"?\", \"？\") elif ch == \"&lt;\": rename = rename.replace(\"&lt;\", \"[\") elif ch == \"&gt;\": rename = rename.replace(\"&gt;\", \"]\") else: rename = rename.replace(ch, \"、\") valid = False return valid, rename 项目二：'.\\\\docx/专科题库\\\\儿科\\\\[书籍]\\\\S-《实用临床护理三基-&quot;应知应会&quot;》—名词解释、简答(规02）\\\\something.docx'===&gt;'.\\\\docx/专科题库\\\\儿科\\\\[书籍]\\\\S-《实用临床护理三基-'应知应会'》—名词解释、简答(规02）\\\\something.docx' 1234567891011121314151617181920212223242526def format_file_path(path: str) -&gt; [bool, str]: \"\"\" 文件和文件夹名规范化 :param name: :return: \"\"\" invalid_char = [\"/\", \"\\\\\", \":\", \"*\", \"?\", \"|\", \"&lt;\", \"&gt;\", \"\\\"\"] rename = path valid = True for ch in invalid_char: if ch in rename: if ch == \"?\": rename = rename.replace(\"?\", \"？\") elif ch == \"&lt;\": rename = rename.replace(\"&lt;\", \"[\") elif ch == \"&gt;\": rename = rename.replace(\"&gt;\", \"]\") elif ch == '\"': rename = rename.replace(\"\\\"\", \"\\'\") elif ch == \"\\\\\" or ch == \"/\": # 注意跟 上一个的区别， 由于上一个项目中的/和\\都是分隔符，而不是真实的分隔目录，因此需要替换，但本项目是真实路径分隔符，所以不需要转换 pass else: rename = rename.replace(ch, \"、\") valid = False return valid, rename 附录 lxml库的使用 提取Element中最近标签中的文本(不包含标签本身): ele.xpath('//*[@id=&quot;xxx&quot;]/text()') 提取Element中所有标签(标签嵌套)中的文本(不包含标签本身): ele.xpath('//*[@id=&quot;xxx&quot;]/string(.)') 注：跟//text()区别在于，string(.)的结果为合并后的str，//text()为未合并的list 提取Element中所有内容(标签本身): etree.tostring(ele, method=&quot;html&quot;) 修改Element某一属性: 123456appendixs = html_content.xpath('/html/body/div[4]/div/div[4]/div/div/div[1]/div[4]/p/a')for a in appendixs: href = a.xpath(\"@href\")[0] save_path = self.download_file(ReUtil.extra_announcement_id(detail_article_url), href, title) # html中会对\\进行转义 a.attrib[\"href\"] = save_path 注: 修改子element的某属性后，root节点tostring的结果中element也会被修改。(root抱有element的引用) Element的XML标记名通过对象的属性访问 12345678910a = &apos;&lt;a href=&quot;http://baidu.com&quot;&gt;hh&lt;span&gt;gg&lt;/span&gt;&lt;/a&gt;&apos;res = &#123;_Element: 1&#125; &lt;Element html at 0x1de3a6b9800&gt; attrib = &#123;_Attrib: 0&#125; &#123;&#125; base = &#123;NoneType&#125; None nsmap = &#123;dict: 0&#125; &#123;&#125; prefix = &#123;NoneType&#125; None sourceline = &#123;int&#125; 1 tag = &#123;str&#125; &apos;html&apos; tail = &#123;NoneType&#125; None text = &#123;NoneType&#125; None Element被组织在XML树结构中。增加子Element并指定它们的父Element，使用append方法。 12345# 法一root = etree.Element(\"root\")root.append(etree.Element(\"child1\"))# 法二childNode = etree.SubElement(root, \"child\") 删除Element下某一节点内容，与添加相同，也有实例方法和工厂方法两种 parentnode.remove(node) etree.strip_elements(html, 'element_name', with_tag=True/False) timeit模块使用 12345spider = HuaNengSpider(ifend=\"in\")# 记得setup导入 run_time = timeit.timeit(\"spider.run_parallelly()\", \"from __main__ import spider\", number=1)# 输出的单位为s print(\"耗时: &#123;&#125;s\".format(run_time)) 12run_time = timeit.timeit('HuaNengSpider(ifend=\"notin\", is_in_one=True).run_with_concurrent()', \"from __main__ import HuaNengSpider\", number=1) Python中操作SQLAlchemy,SQLAlchemy中文技术文档 参考：https://www.jianshu.com/p/0ad18fdd7eed、python3 SQLAlchemy模块使用 ArgumentParser使用 parser.add_argument(&quot;-o&quot;, &quot;--is_in_one&quot;, action=&quot;store_true&quot;, help=&quot;数据存放在一张表中&quot;), 其中action的store_true表示，如果出现–is_in_one(action)则设置未true, 所以默认为False 参数设置为True、False的最好不使用choice参数：因为 parser.add_argument(&quot;-o&quot;, &quot;--is_in_one&quot;, choices=[True, False], help=&quot;数据存放在一张表中&quot;), choice中为True、False时， 可以选择不填，此时is_in_one为None， 如果必须要这两个则选一个则加上required=True选项 加上required效果===&gt;爬虫脚本: error: argument -o/--is_in_one: invalid choice: 'q' (choose from True, False)， 但是如果输入True同样会报错: 爬虫脚本: error: argument -o/–is_in_one: invalid choice: ‘True’ (choose from True, False) 所以只有choices=[&quot;True&quot;, &quot;False&quot;]才能生效， 好在的是Python中对true判断比较宽容，下面三种都可以，因此使得choice传str类型的True也可以成功判定，即能实现相同效果，但是还是存在些歧义的，得谨慎使用 123456789a = \"true\"b = Truec = \"True\"if a: print(\"a yes\")if b: print(\"b yes\")if c: print(\"c yes\") 其他SQL文件 1234567891011121314151617181920212223242526272829CREATE TABLE `auto_bilibili` ( `id` int(11) NOT NULL AUTO_INCREMENT, `userid` int(11) NOT NULL, `name` varchar(255) NOT NULL COMMENT '创建的任务名', `sessdata` longtext NOT NULL, `bili_jct` longtext NOT NULL, `dedeuserid` longtext NOT NULL, `taskIntervalTime` int(11) NOT NULL DEFAULT '10' COMMENT '任务之间的执行间隔', `numberOfCoins` int(11) NOT NULL DEFAULT '5' COMMENT '每日投币数量', `reserveCoins` int(11) NOT NULL DEFAULT '50' COMMENT '预留的硬币数', `selectLike` int(11) NOT NULL DEFAULT '0' COMMENT '投币时是否点赞，默认 0, 0：否 1：是', `monthEndAutoCharge` varchar(10) NOT NULL DEFAULT 'true' COMMENT '年度大会员月底是否用 B 币券给自己充电，默认 true，即充电对象是你本人。', `giveGift` varchar(10) NOT NULL DEFAULT 'true' COMMENT '直播送出即将过期的礼物，默认开启', `upLive` varchar(255) NOT NULL DEFAULT '0' COMMENT '直播送出即将过期的礼物，指定 up 主，为 0 时则随随机选取一个 up 主', `chargeForLove` varchar(255) NOT NULL DEFAULT '0' COMMENT '给指定 up 主充电，值为 0 或者充电对象的 uid，默认为 0，即给自己充电', `devicePlatform` varchar(10) NOT NULL DEFAULT 'ios' COMMENT '手机端漫画签到时的平台，建议选择你设备的平台 ，默认 ios', `coinAddPriority` int(11) NOT NULL DEFAULT '1' COMMENT '0：优先给热榜视频投币，1：优先给关注的 up 投币', `userAgent` varchar(255) NOT NULL DEFAULT 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36 Edg/86.0.622.69' COMMENT '浏览器 UA', `skipDailyTask` varchar(10) NOT NULL DEFAULT 'false' COMMENT '是否跳过每日任务', `webhook` varchar(255) DEFAULT NULL COMMENT '推送地址', `enddate` datetime DEFAULT NULL, `match_enable` varchar(10) NOT NULL DEFAULT 'false' COMMENT '预测是否开启', `match_predictNumberOfCoins` int(11) NOT NULL DEFAULT '10' COMMENT '单次预测投注硬币', `match_minimumNumberOfCoins` int(11) NOT NULL DEFAULT '200' COMMENT '预测保留硬币', `match_showHandModel` varchar(255) NOT NULL DEFAULT 'false' COMMENT '押注形式', `other` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE, KEY `userid` (`userid`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"}]},{"title":"深入学习使用Spring","slug":"深入学习使用Spring","date":"2022-02-27T05:52:08.000Z","updated":"2022-02-27T05:54:23.566Z","comments":true,"path":"2022/02/27/深入学习使用Spring/","link":"","permalink":"https://nymrli.top/2022/02/27/深入学习使用Spring/","excerpt":"","text":"From : https://www.bilibili.com/video/BV1fr4y1Y7UH?p=6 创建bean的方式： 声明式 &lt;bean&gt;&lt;/bean&gt; &lt;bean&gt;&lt;/bean&gt;： 通过xml来配置bean 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\"&gt; &lt;bean id=\"p1\" class=\"top.nymrli.tryboot.po.User\"&gt; &lt;property name=\"name\" value=\"张三\"/&gt; &lt;property name=\"age\" value=\"18\"/&gt; &lt;/bean&gt;&lt;/beans&gt; @Test public void testPerson() &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); User user = annotationConfigApplicationContext.getBean(\"p1\", User.class); System.out.println(user);&#125; @Bean @Bean: 通过注解来标注SpringBean对象 12345678910111213141516171819public class Config &#123; @Bean(\"user\") public User getUser()&#123; return new User(\"name\", 20); &#125;&#125; @Test public void testPerson() &#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); ctx.register(Config.class); // 或者 AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Config.class); ctx.refresh(); User user = ctx.getBean(\"user\", User.class); System.out.println(user); &#125; AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Config.class);与ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);一样，都是指定bean的配置路径后解析，获得bean的配置。 @Component @Component: 通过标注来创建一个组件SpringBean对象，如下的User。 ==&gt; 等价于ctx.registerBean(User.class)，registerBean方法的实现最终也是调用了registerBeanDefinition 而Config不是一个bean，他的作用跟applicationContext.xml一样，他是存放bean定义路径的一个配置文件，在这里是通过ComponentScan让Spring能够找到top.nymrli.tryboot.po下的所有Bean并解析成SpringBean 1234567891011121314151617181920212223@ComponentScan(\"top.nymrli.tryboot.po\")public class Config &#123;&#125;@Data@AllArgsConstructor@NoArgsConstructor@Component // ==&gt; beanName为user, 类名小写public class User &#123; private String name; private int age;&#125;@Testpublic void testPerson()&#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(Config.class); User user = ctx.getBean(User.class); System.out.println(user);&#125; 会自动调用User的无参构造方式来创建JavaBean， 因此得到的User是User(name=null, age=0) ▲.上述三种创建方式本质上都是创建了BeanDefinition，只不过Spring进行了封装，因此使用起来比较简单直观 @Import spring4.2之后@Import注解可以实例化普通类的bean实例 1234567891011121314151617181920212223@Datapublic class Role &#123; private Long id; private String name;&#125;@Import(Role.class) // @Import(&#123;Role.class, User.class&#125;)@Configurationpublic class MyConfig &#123;&#125;@RequestMapping(\"/\")@RestControllerpublic class TestController &#123; @Autowired private Role role; @GetMapping(\"/test\") public String test() &#123; System.out.println(role); return \"test\"; &#125;&#125; Spring在创建MyConfig的时候，会根据@Import将Role也实例化成一个Bean 编程式 BeanDefinition 通过创建并配置 BeanDefinition 来创建一个Bean Q: 什么是BeanDefinition? A: BeanDefinition表示Bean的定义信息， Spring会根据BeanDefinition来创建Bean对象。BeanDefinition有很多的属性用来描述Bean， BeanDefinition是Spring中非常核心的概念。 beanClass: 表示Bean对象的类类型， Spring在创建Bean的过程中根据此属性来判断实例化对象具体的类类型 scope：作用域，[singleton、prototype]，单例或者原型bean isLazy：是否需要懒加载，原型Bean的懒加载不奏效。懒加载的单例bean，会在第一次getBean的时候生成该bean，非懒加载的单例bean，则会在Spring.启动过程中直接生成好。 dependsOn：表示一个bean在创建之前所依颗的其他bean，在一个bean创建之前，它所依赖的这些bean得先全部创建好。 primary：表示一个bean是主bean，在Spring中一个类型可以有多个bean对象，在进行依赖注入时，如果根据类型找到了多个b©an，此时会判断这些bean中是否存在一个主bean，如果存在，则直接将这个bean注入给属性。 initMethodName： 表示一个bean的初始化方法，一个bean的生命周期过程中有一个步骤叫初始化，Spring会在这个步骤中去调用bean的初始化方法。初始化逻辑由程序员自己控制，使得程序员可以自定义逻辑对bean进行加工。 通过&lt;bean&gt;&lt;/bean&gt;、@Bean、@Component标注的类都会解析为BeanDefinition，供Spring创建（实例化）具体的Bean。 123456789101112@Testpublic void testPerson()&#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(Config.class); AbstractBeanDefinition bd = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition(); bd.setBeanClass(User.class); // 将BeanDefinition注册到上下文中 ctx.registerBeanDefinition(\"user\", bd); // 获得Bean对象 User user = (User)ctx.getBean(\"user\"); System.out.println(user);&#125; FactoryBean FactoryBean是Spring.所提供的一种较灵活的创建Bean的方式，可以通过实现FactoryBean：接口中的getObject()方法来返回一个对象，这个对象就是最终的Bean对象。 FactoryBean接口中的方法 Object getObject()：返回的是Bean对象 boolean isSingleton()：返回的是否是单例Bean对象 Class getObjectType()：返回的是Bean对象的类型 1234567891011121314151617@Component(\"zhouyu\")public class ZhouyuFactoryBean implements FactoryBean &#123; @Override public boolean isSingleton() &#123; return true; &#125; @Override public Object getObject() &#123; return new User(\"cl\", 18); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return User.class; &#125;&#125; 上述代码，实际上对应了两个Bean对象： 1、beanName为&quot;zhouyu’，bean对象为getObject方法所返回的User对象。=&gt;applicationcontext.getBean(name：&quot;zhouyu&quot;，ZhouyuFactory.class); 2、beanName为&quot;&amp;zhouyu’，bean对象为ZhouyuFactoryBean类的实例对象。=&gt;applicationcontext.getBean(name：&quot;&amp;zhouyu&quot;，ZhouyuFactoryBean.class); 与BeanFactory的区别： FactoryBean对象本身也是一个Bean，同时它相当于一个小型工厂，可以生产出另外的Bean。==》指定类型的Bean对象 FactoryBean机制被广泛的应用在Spring内部和Spring-与第三方框架或组件的整合过程中。 BeanFactory是一个Spring容器，是一个大型工厂，它可以生产出各种各样的Beano Supplier 123456789101112131415161718@Testpublic void testPerson()&#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(Config.class); ctx.registerBean(User.class, new Supplier&lt;User&gt;() &#123; @Override public User get() &#123; User userx = new User(); userx.setAge(222); userx.setName(\"supplier\"); return userx; &#125; &#125;); User user = (User)ctx.getBean(\"user\"); System.out.println(user); &#125; BeanFactory BeanFactory是一种“Spring容器”， BeanFactory翻译过来就是Bean工厂，顾名思义，它可以用来创建Bean、获取Bean。 概念区分： BeanFactory将利用BeanDefinition：来生成Bean对象 BeanDefinition相当于BeanFactory的原材料 Bean对象就相当于BeanFactory）所生产出来的产品 BeanFactory的核心子接口和实现类： ListableBeanFactory ConfigurableBeanFactory AutowireCapableBeanFactory AbstractBeanFactory DefaultListableBeanFactory ··· Bean生命周期 Bean生命周期描述的是Spring中一个Bean创建过程和销毁过程中所经历的步骤，其中Bean创建过程是重点。程序员可以利用Bean生命周期机制对Bean进行自定义加工。 Bean定义：通过xml或者编写类的形式来创建BeanDefinition 构造方法推断：从bean的多个构造方法中选出一个构造方法 实例化：通过构造方法反射获得对象，在Spring中可以通过BeanPostProcessor机制对实例化进行干预 属性填充(自动注入、依赖注入)：给属性进行自动填充，比如@Value，@AutoWired 初始化：在一个对象的属性填充之后，Spring提供了初始化机制，让程序员可以对其他属性进行赋值、校验等自定义加工(利用InitializingBean接口) 初始化后：Aop、生成代理对象。常说的Aop机制就是在这个步骤中通过BeanPostProcessor机制实现的，这步之后获得的对象才是真正的Bean对象 创建过程： 生命周期图： 属性填充注解：@Autowired、@Resource、@Value @Autowired. 表示某个属性是否需要进行依赖注入，可以写在属性和方法上。注解中的required属性默认为ture，表示如果没有对象可以注入给属性则抛异常。 @Autowired：加在某个属性上，Spring在进行Bean的生命周期过程中，在属性填充这一步会基于实例化出来的对象，对该对象中加了@Autowired的属性自动给属性赋值。具体实现为： Spring会先根据属性的类型去Spring容器中找出该类型所有的Bean对象，如果找出来多个，则再根据属性的名字从多个中再确定一个。如果required属性为true，并且根据属性信息找不到对象，则直接抛异常。 当@Autowired注解写在某个方法上时，Spring在B ean生命周期的属性填充阶段，会根据方法的参数类型、参数名字从Spring容器找到对象当做方法入参，自动反射调用该方法。 @Autowired加在构造方法上时，Spring会在推断构造方法阶段，选择该构造方法来进行实例化，在反射调用构造方法之前，会先根据构造方法参数类型、参数名从Spring容器中找到Bean对象，当做构造方法入参。 @Resource @Resource注解与@Autowired类似，也是用来进行依赖注入的，@Resource是Java层面所提供的注解，@Autowired.是Spring所提供的注解，它们依赖注入的底层实现逻辑也不同。 @Resource：注解中有一个name属性，针对na me属性是否有值，@Resource的依赖注入底层流程是不同的。 @Reousrce：如果name属性有值，那么Spring会直接根据所指定的name值去Spring容器找Bean对象，如果找到了则成功，如果没有找到，则报错。 如果@Resource中的name属性没有值，则： 先判断该属性名字在Spring容器中是否存在Bean对象。 如果存在，则成功找到Bean对象进行注入。 如果不存在，则根据属性类型去Spring容器找Bean对象，找到一个则进行注入。 @Value @Value注解和@Resource、@Autowired类似，也是用来对属性进行依赖注入的，只不过@Value是用来从Properties.文件中来获取值的，并且@Value可以解析SpEL（Spring表达式）。 @Value(&quot;yuzhou&quot;): 直接将字符串“zhouyu”赋值给属性，如果属性类型不是String，或无法进行类型转化，则报错。 @Value(${&quot;yuzhou&quot;})： 将会把${}中的字符串当做key，从Properties文件中找出对应的value赋值给属性，如果没找到，则会把${zhouyu}当做普通字符串注入给属性。 @Value(#{&quot;yuzhou&quot;}):会将#{}中的字符串当做Spring表达式进行解析，Spring会把&quot;zhouyu&quot;当做beanName，并从Spring容器中找对应bean，如果找到则进行属性注入，没找到则报错。 ApplicationContext ApplicationContext是比BeanFactory更加强大的Spring容器，它既可以创建bean、获取bean，还支持国际化、事件广播、获取资源等BeanFactor y不具备的功能。 Application Context，所继承的接口 EnvironmentCapable：拥有获取环境变量的能力：操作系统环境变量和Jvm环境变量 ListableBeanFactory：拥有了获取所有beanNames、判断某个bean Name是否存在peanDefinition对象、统计Be anDefinition个数、获取某个类型对应的所有beanNames等功能。 HierarchicalBeanFactory：拥有了获取父BeanFactory、。判断某个name是否存在bean对象的功能。 MessageSource：拥有了国际化功能，比如可以直接利用Messa geSource对象获取某个国际化资源（比如不同国家语言所对应的字符） ApplicationEventPublisher： 拥有了事件发布功能，可以发布事件，这是Application Context相对于BeanFactory比较突出、常用的功能。 ResourcePatternResolver: 拥有了加载并获取资源的功能，这里的资源可以是文件，图片等某个URL资源都可以。 获得bean的方式： getBean() API 按名称获取Bean 123Object lion = context.getBean(\"lion\"); assertEquals(Lion.class, lion.getClass()); 根据bean名称获取bean，如果在spring ico容器中存在和bean，则返回Object 类的实例。否则，抛出如下异常NoSuchBeanDefinitionException。 ▲: 主要的缺点是，在获取bean之后，我们必须将它指定转换为所需的类型。如果返回的bean的类型与我们期望的不同，则可能会产生异常。 通过名称和类型获取Bean 1234567Lion lion = context.getBean(\"lion\", Lion.class);// 与按名称获取Bean相比，此方法更安全，因为我们可以编译阶段就发现错误而不是在运行阶段。assertThrows(BeanNotOfRequiredTypeException.class, () -&gt; context.getBean(\"lion\", Tiger.class));&#125; 按类型获取Bean 1234567// rightLion lion = context.getBean(Lion.class);// 注意: 在下面的情况下，需要特别注意可能存在的歧义：assertThrows(NoUniqueBeanDefinitionException.class, () -&gt; context.getBean(Animal.class));&#125; 由于Lion和Tiger都实现了Animal接口，因此仅指定类型不足以明确确定结果。因此，我们会得到一个*NoUniqueBeanDefinitionException*。即在同一个IOC 容器中，如果有相同类型的多个bean，则不能通过类型获取bean。 按名称和构造函数参数对Bean进行筛选 12345Tiger tiger = (Tiger) context.getBean(\"tiger\", \"Siberian\");Tiger secondTiger = (Tiger) context.getBean(\"tiger\", \"Striped\"); assertEquals(\"Siberian\", tiger.getName());assertEquals(\"Striped\", secondTiger.getName()); 按类型和构造函数参数对Bean进行筛选 ▲: 这个方法有点不同，因为它只适用于具有原型作用域的bean。 12Tiger tiger = context.getBean(Tiger.class, \"Shere Khan\");assertEquals(\"Shere Khan\", tiger.getName()); BeanPostProcessor机制 BeanPostProcessor是Spring所提供的一种扩展机制，可以利用该机制对Bean进行定制化加工，在Spring底层源码实现中，也广泛的用到了该机制，BeanPostProcessor通常也叫做Bean后置处理器。 BeanPostProcessor在Spring中是一个接口，我们定义一个后置处理器，就是提供一个类实现该接口，在Spring中还存在一些接口继承了BeanPostProcessor，这些子接口是在BeanPostProcessor的基础上增加了一些其他的功能。 BeanPostProcessori中的方法 postProcessBeforelnitialization()：初始化前方法，表示可以利用这个方法来对Bean在初始化前进行自定义加工。 postProcessAfterInitialization()：初始化后方法，表示可以利用这个方法来对Bean在初始化后进行自定义加工。 InstantiationAwareBeanPostProcessor BeanPostProcessor的一个子接口 postProcessBeforelnstantiation()：实例化前 postProcessAfterInstantiation()：实例化后 postProcessProperties()：属性注入后 AOP是什么？ AOP就是面向切面编程，是一种非常适合在无需修改业务代码的前提下，对某个或某些业务增加统一的功能（横向增加功能），比如日志记录、权限控制、事务管理等，能很好的使得代码解耦，提高开发效率。","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://nymrli.top/tags/Spring/"},{"name":"Web","slug":"Web","permalink":"https://nymrli.top/tags/Web/"}]},{"title":"研究生work——地图匹配","slug":"研究生work——地图匹配","date":"2022-02-26T07:24:46.000Z","updated":"2022-03-09T13:33:00.468Z","comments":true,"path":"2022/02/26/研究生work——地图匹配/","link":"","permalink":"https://nymrli.top/2022/02/26/研究生work——地图匹配/","excerpt":"","text":"地图匹配 概念： 地图匹配（Map-Matching）是将运营车辆的有序的GPS位置关联到电子地图的路网上，将GPS坐标下采样序列转换为数字路网坐标序列的过程；本质上是平面线段序列的模式匹配问题（ Alt等，2003） 地图匹配是一种将原始GPS位置映射到路网上的路段的过程，以创建对车辆所走路线的估算。 两个主要的地图匹配用例 乘车结束时，计算驾驶员行进的距离，以计算票价。——路线图匹配(EORMM) 实时 ，为ETA团队提供准确的位置并做出调度决策，并在rider应用程序上显示驾驶员的汽车。——实时地图匹配(RTMM) 不同点在于，实时地图匹配的要求比较高，必须低延时，因此相比之下，路线图匹配对等待时间的要求不那么严格，并且可以使用乘车的全部历史记录 参考： https://zhuanlan.zhihu.com/p/83039334 Lyft的地图匹配算法论文翻译 地图匹配算法的性能取决于道路网络数据的质量 解决问题的一种好的方法是使用状态空间模型 。 状态空间模型是时间序列模型，其中系统具有“隐藏”状态，这些状态无法直接观察到，但会引起可见的观察。 在这里，我们的隐藏状态是我们要估算的汽车在道路网络上的实际位置。 我们仅观察到隐藏状态的修改版本：观察值(原始位置数据)。 我们假设系统的状态以仅取决于当前状态的方式演化(马尔可夫假设)，并进一步定义了从隐藏状态到隐藏状态的转移密度和从隐藏状态到观察的密度。 常用的地图匹配状态空间模型是离散状态隐马尔可夫模型 (Newson＆Krumm [2]，DiDi的IJCAI-19教程[3]，Uber的Map Matching [4])。 在该系统中，我们通过查看路段上的最近点来生成候选对象，并使用维特比算法查找最可能的隐藏状态序列。 对于不同的建模选择和输入数据而言，它相对不灵活 它缩放严重(O(N²)，其中N是每个状态下可能的候选数) 它不能很好地应对高频观测(请参阅Newson＆Krumm [2])。 GPS定位与地图匹配方法研究 地图匹配算法从原理上可以解释为两个独立的过程：（1）找到车辆当前行使的道路——确定候选路段（2）将当前GPS定位点投影到车辆行使的道路上——候选路段匹配规则 圆心拓展半径找到最近的路段（唯一）——构建第一条边的算法 [1]苏洁, 周东方, 岳春生. GPS车辆导航中的实时地图匹配算法[J]. 测绘学报, 2001, 30(3):5. 另外，为了提高算法的鲁棒性，对于误差引起 的速度异常，我们利用推测航位法和线性插值来 进行 GPS数据补偿，以消除部分GPS接收外部 粗差 [1]李清泉, 黄练. 基于GPS轨迹数据的地图匹配算法[J]. 测绘学报, 2010(2):6. 针对传统导航系统的地图匹配方法的研究较多。其中点到线的匹配由于缺乏对整体轨迹趋势的考虑，在复杂的道路网环境下的匹配易导致误匹配。也有方法使用DR、差分GPS等辅助设备，采用滤波、模糊逻辑、证据理论等方法提高地图匹配的准确率。GPS浮动车轨迹数据提供了整体曲线的变化趋势，可以采用全局整体匹配的思想，保证轨迹的完整性和准确性14？。基于曲线相似度的算法一般 较为复杂，但匹配精度高，利于轨迹的直接恢复，适合进行数据的后处理 与整个轨迹相对 应的路径必然是连通 的路段集 ，可以基于道路拓扑与连通性设计地图匹配算法 key：除了道路的几何连通性，实际行车还会受到交通规则的限制，本文基于道路网的行车限制信息提出了一种GPS浮动车轨迹数据的全局地图匹配算法，综合考虑备选路段的几何连通性与交通网络条件约束构建整体备选路径，然后使用改进的扫描线法判断全局轨迹曲线与备选路径的相似度，完成地图匹配 。 一句话概括算法：通过行车限制将候选线段找出来后，选择曲线相似度最高的 [1]陈滨, 王平, 施文灶,等. GPS轨迹数据的综合地图匹配算法研究[J]. 电子科技, 2014, 27(12):4. 从实际的匹配效果来看，此匹配算法在交叉路口等路段较复杂的地方可有较高地匹配准确率，但该方法依赖于前后GPS定位点匹配准确度，若前一定位点匹配错误就会出现连锁反应，从而导致后面一系列点匹配错误；且历史轨迹推算匹配法计算量较大，匹配速度较慢，不利于高速实时定位。因此，需和其他地图匹配方法相结合使用才能取得较好的匹配效果。 智能交通系统中GPS地图匹配算法设计与实现_罗杰涛 模糊逻辑： 效率高，实时性好，对绝大多数的路段状况都适用。不过在车俩拐弯处以及车速较慢的情况下匹配效果不尽如人意，且不同路段建模的系数凭靠经验值，没有相应的缺乏理论依据。——01、06、08论文 高级地图匹配算法：研究现状和趋势[2021] 从实现技术或模型角度对近十年提出的算法进行分类，箭头标记算法间的继承关系。从图2可见，HMM模型是主流，其次是基于最大权重的模型.HMM-News-on、ST-Matching2 3IVMM3和HRIS8被引用对比最多，是具有开创性的工作。另外，从2019年开始，有研究采用深度学习技术来解决地图匹配问题。 Points: 另外，一个重要的实际问题是，即使车辆定位精度可以保证在10米以内，当电子地图缩放到较大的比例尺时，也会 出现车辆偏离行使的道路而造成的视觉混乱现象. 由于城区内地物特征复杂，受密集的高大建筑物、隧道、立交桥、树木等地物的反射和遮蔽等影响，车栽GPS接收机接收到的卫星信号存在严重的多径效应，在某些区域内甚至会形成GPS定位育区，解决GPS盲区问题，一种方法是采用航位推算法（DR-Dead Reckoning），这种方法需要将DR设备装在车辆前端，一般在GPS接收机卫星信号受阻时一样可以得到正确的用户位置，但这种方法需要附加设备。另一种方法是在记忆正确GPS位置信息的基础上在一段时间内预测车辆位置，这种方法的优点是易于实现，缺点是精度不够（没有，作者使用卡尔曼滤波进行位置预测，预测结果如图所示。在规则行进时，预测效果较好，见图3、图4.但是当车辆转弯时，效果很差，见图5、图6 到折线的距离定义为点到折线上所有直线段的最短距离：点到线段的距离定义为如果点到直线段所在直线的投影在直线段上，则为垂线长度，否则为其到两个端点的最短距离。 定位误差： GPS误差、电子地图库误差、坐标投影变换投影 难点： Y-junction问题——点到线的匹配方式，没有考虑全局匹配 平行双线路 MapMatching实现的思路 离散点集匹配：相对简单，随机离散点没有形状和拓扑关系，用欧氏距离作吸附即可，典型应用如离散热力图。 曲线拟合： 实际中更有应用价值的是曲线拟合匹配关系，比如轨迹和路网，GPS序列和导航路的相似性。 MapMatching算法的分类： 以使用到的信息来划分 现有的算法可被分成四类：几何、拓扑、概率、高级。 a）基于几何的算法考虑GPS点与道路的几何信息，如距离、角度等； b）基于拓扑的算法使用道路拓扑信息来控制； c）概率方法通过考虑GPS点的概率； d）高级的算法往往综合考虑使用全面信息，有卡尔曼滤波、模糊逻辑模型、隐式马尔可夫模型等等。 2.2 以考虑采样点的范围来划分 根据考虑采样点的范围，可分成局部/增量算法、全局算法。 a）局部/增量算法是贪婪算法，每次确定一个匹配点，下个点从已经确定的匹配点开始。这些方法根据距离和方向相似性来找到局部最优点或边。（在线匹配） b）全局算法是要从路网中找到一条与采样轨迹最接近的匹配轨迹。为了测量采样轨迹和匹配轨迹的相似性，大多数算法使用“Frechet距离”或者是“弱Frechet距离”。还有时空匹配算法、投票算法等。（离线匹配） 以采样点的频率来划分 根据轨迹数据的采样频率，现有的地图匹配算法可分成： a）高频采样算法（所有局部算法、部分全局算法如Frechet距离判别法等） b）低频采样算法（ST-matching算法、IVVM算法） 一般认为30s及其以上为低频采样，1s～10s为高频采样。 https://www.cnblogs.com/LBSer/p/4612031.html#!comments 智能交通系统中GPS地图匹配算法设计与实现 算法评估的标准 实时性 可靠性(鲁棒性) 匹配的精度 朴素算法： 快速匹配算法的执行步骤如下： 步1接收GPS定位数据； 步2判断定位数据是否无效，若无效，则根据历史定位数据进行推测匹配，然后转（8）； 步3判断车辆当前是否处于停止或低速滑行状态，若是，对其作相应处理，然后转（8）； 步4由车辆当前位置点计算其对应的候选网格，进而获取其中的路段； 步5对步4得到的路段进行连接性拓扑检查，将通过拓扑检查的路段作为匹配候选路段； 步6判断匹配候选路段数目，若唯一，则直接将其作为匹配路段，并由定位点向其作投影，然后转（8）；否则，计算所有候选路段的匹配度度量值f，（i=1,2，…，N），从中选出最大值fm和次大值fm； 步7判断最大值fm和次大值fm之差是否大于阈值fh，且最大值fm是否大于阈值fh，如果大于，则将路段m作为匹配路段，并由定位点向其作投影；否则，暂不对本次定位结果进行匹配，待后面对其进行延时匹配处理； 步8结束本次匹配 from : 一种适于车辆导航系统的快速地图匹配算法——2003 Key: 出行数据：采用GPS定位，那么是否是WGS-84数据，但是GIS部门的路网数据坐标是什么坐标系下的 双线路： 当下，现在很多用于MapMatching的方法，大多来自于推理、预测的数学方法，如隐马尔可夫链、贝叶斯模型、神经网络模型等，但在数据结构上的创新比较少，GIS算法，更多要在计算机的基础上，结合比如时空观念、数据特征、拓扑关系等对于GIS相关的基础理论 软件 mapinfo: 当今世界上流行的桌面地理信息系统 graphhopper: 路径规划库 arcgis openstreetmap——开源地图，简称为OSM 线要素的匹配，主要通过几何、拓扑或语义相似度来进行识别，其中通过空间距离来进行要素匹配的常用方式有： 闵可夫斯基距离(Minkowski Distance) 欧氏距离(Euclidean Distance) 曼哈顿距离(Manhattan Distance) 切比雪夫距离(Chebyshev Distance) 汉明距离(Hamming distance) 杰卡德相似系数(Jaccard similarity coefficient) 豪斯多夫距离(Hausdorff Distance) 弗雷歇距离(Fréchet距离) from：高德地图：地图数据处理之道路匹配篇 隐马尔科夫HMM HMM有三个典型(canonical)问题: 概率计算问题：已知模型参数，计算某一特定输出序列的概率.通常使用**Forward算法**解决； 预测问题或者解码（decoding）问题：已知模型参数，寻找最可能的能产生某一特定输出序列的隐含状态的序列。通常使用**Viterbi算法**解决； 学习问题：已知输出序列，寻找最可能的状态转移以及输出概率。通常使用**Baum-Welch算法**。 HMM的几个重要元素： π(startprob_): 隐藏状态初始向量 π=(πi):πi=P(q1=i),1≤i≤N\\pi=\\left(\\pi_{i}\\right): \\pi_{i}=P\\left(q_{1}=i\\right), 1 \\leq i \\leq N π=(πi​):πi​=P(q1​=i),1≤i≤N A(transmat_): 状态转移概率矩阵: A=[aij]N×N, 其中 aij=P(qt+1=j∣qt=i),1≤i,j≤NA=\\left[a_{i j}\\right]_{N \\times N} \\text {, 其中 } a_{i j}=P\\left(q_{t+1}=j \\mid q_{t}=i\\right), 1 \\leq i, j \\leq N A=[aij​]N×N​, 其中 aij​=P(qt+1​=j∣qt​=i),1≤i,j≤N B(emissionprob_): 观测状态概率矩阵 B=[bj(k)]N×M， 其中 bj(k)=P(ot=ok∣qt=j),1≤j≤N,1≤k≤MB=\\left[b_{j}(k)\\right]_{N \\times M} ， \\text { 其中 } b_{j}(k)=P\\left(o_{t}=o_{k} \\mid q_{t}=j\\right), 1 \\leq j \\leq N, 1 \\leq k \\leq M B=[bj​(k)]N×M​， 其中 bj​(k)=P(ot​=ok​∣qt​=j),1≤j≤N,1≤k≤M HMM的状态变量数目：N HMM的观察变量数目：M 如果观测序列是一维的，则观测状态的概率密度函数是一维的普通高斯分布。如果观测序列是N维的，则隐藏状态对应的观测状态的概率密度函数是N维高斯分布。高斯分布的概率密度函数参数可以用μμ表示高斯分布的期望向量，Σ表示高斯分布的协方差矩阵。在GaussianHMM类中，“means”用来表示各个隐藏状态对应的高斯分布期望向量μ形成的矩阵，而“covars”用来表示各个隐藏状态对应的高斯分布协方差矩阵Σ形成的三维张量。 from :用hmmlearn学习隐马尔科夫模型HMM MapMatching与Hmm 观察变量：从GPS设备中得到的位置信息（经度，纬度） 隐藏状态：拥有GPS设备的物体（车，人等）实际所在的位置路段。 观测概率：例如，现测的GPS点离旁边路段上的位置越近，那么这个真实点在这个路段上的概率越大状态。 状态转移概率：例如，前后两个真实的位置点的距离越近，那么状态转移的概率越大 在下面相关论文工作中会说明在这几篇论文中其实只用到了预测问题的Viterbi算法,下面也会另开一小节具体描述下Viterbi算法。 Map-Matching的两个变量： 从GPS设备中得到的位置信息（经度，纬度）：HMM中观察变量； 拥有GPS设备的物体（车，人等）实际所在的位置：HMM中的隐藏状态变量，实际地图是不知道GPS设备的准确位置的。 这样就把Map-Matching问题与HMM结合起来了。三个问题在Map-Matching中有用的是两个问题：（1）预测问题；（2）学习问题。 在论文中，定义的规则要满足人的直观上的感觉，即人的先验知识，主要有以下两种： 观测概率：观测的GPS点离旁边路段上的位置越近，那么这个真实点在这个路段上的概率越大。 状态转移概率：这里有两种解决思路：（1）前后两个真实的位置点的距离越近，那么状态转移的概率越大；或者（2）真实路段上的前后两个点的距离与GPS观测的前后两个点的距离越接近，状态转移概率越大。 from: 基于隐马尔科夫模型(HMM)的地图匹配(Map-Matching)算法 barefoot 观测概率: 测量位置与其真实位置之间的距离，用于对测量误差进行建模，测量误差用具有一些标准偏差σ的高斯分布来描述（默认为σ = 5 米）。 转移概率: 用各个位置测量之间的路由距离和视线距离的差异来量化的。转移概率呈负指数分布，速率参数λ（默认为λ = 0.1）是均值的倒数 ==&gt; 序列概率： 定义p(s 0 … s t |z 0 … z t )为最可能的序列到达匹配候选s t的概率，称为 s t 的序列概率， 可以通过递归确定 过滤概率：我们的 HMM 滤波器确定对象当前位置的估计值s̅ t，它是最可能匹配的候选对象st∈Sts_t ∈ S_tst​∈St​ 给定测量值z0 ... zt，其定义为：s̅t = argmax(st ∈ St) p(st|z0 ... zt), p(st|z0 ... zt)称为sts_tst​的过滤概率***，可以递归确定： p(st|z0...zt) = p(st|zt) · Σ(st-1 ∈ St-1) p(st|st-1) · p(st-1|z0 ... zt-1)。 from: https://github.com/bmwcarit/barefoot/wiki#stand-alone-servers Coding 在之前的HMM系列中，我们对隐马尔科夫模型HMM的原理以及三个问题的求解方法做了总结。本文我们就从实践的角度用Python的hmmlearn库来学习HMM的使用。sklearn库中将HMM弃用了，新开了一个hmmlearn的新库，安装命令为：pip install hmmlearn，关于hmmlearn的更多资料在官方文档有介绍。 hmmlearn实现了三种HMM模型类，按照观测状态是连续状态还是离散状态，可以分为两类。 GaussianHMM 观测状态连续型且符合高斯分布 GMMHMM 观测状态连续型且符合混合高斯分布 MultinomialHMM 观测状态离散型 HMM主要解决的三个问题 假设隐藏状态序列和观测状态序列分别使用Z和X表示，则解决的3个问题可表示为: 1.解码问题：已知模型参数和X，估计最可能的Z；维特比算法 2.概率问题：已知模型参数和X，估计X出现的概率；向前-向后算法 3.学习问题：仅给出X和隐藏层个数，估计模型参数。 B-W算法，通常是经过一定数量的训练以后，得到模型，然后解决问题1和2。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#coding=utf-8'''Created on 2017-12-4解码问题：本例为天气和行为的关系'''import numpy as npimport matplotlib.pyplot as plt# hmmlearn可以在安装numpy以后，再使用pip install hmmlearn安装from hmmlearn import hmmstates = [\"Rainy\", \"Sunny\"]##隐藏状态n_states = len(states)##隐藏状态长度observations = [\"walk\", \"shop\", \"clean\"]##可观察的状态n_observations = len(observations)##可观察序列的长度start_probability = np.array([0.6, 0.4])##开始转移概率，即开始是Rainy和Sunny的概率##隐藏间天气转移混淆矩阵，即Rainy和Sunny之间的转换关系，例如[0,0]表示今天Rainy，明天Rainy的概率transition_probability = np.array([ [0.7, 0.3], [0.4, 0.6]])##隐藏状态天气和可视行为混淆矩阵，例如[0,0]表示今天Rainy，walk行为的概率为0.1emission_probability = np.array([ [0.1, 0.4, 0.5], [0.6, 0.3, 0.1]])#构建了一个MultinomialHMM模型，这模型包括开始的转移概率，隐藏间天气转换混淆矩阵（transmat），隐藏状态天气和可视行为混淆矩阵emissionprob，对模型参数初始化model = hmm.MultinomialHMM(n_components=n_states)model.startprob_= start_probabilitymodel.transmat_ = transition_probabilitymodel.emissionprob_ = emission_probability#给出一个可见序列bob_Actions = np.array([[2, 0, 1, 1, 2, 0]]).T# 解决问题1,解码问题,已知模型参数和X，估计最可能的Z； 维特比算法 logprob, weathers = model.decode(bob_Actions, algorithm=\"viterbi\")print \"Bob Actions:\", \", \".join(map(lambda x: observations[x], bob_Actions))print \"weathers:\", \", \".join(map(lambda x: states[x], weathers))\"\"\"解码问题： 盒子\"\"\"import numpy as npfrom hmmlearn import hmmstates = [\"box 1\", \"box 2\", \"box3\"]n_states = len(states)observations = [\"red\", \"white\"]n_observations = len(observations)start_probability = np.array([0.2, 0.4, 0.4])transition_probability = np.array([ [0.5, 0.2, 0.3], [0.3, 0.5, 0.2], [0.2, 0.3, 0.5]])emission_probability = np.array([ [0.5, 0.5], [0.4, 0.6], [0.7, 0.3]])model = hmm.MultinomialHMM(n_components=n_states)model.startprob_=start_probabilitymodel.transmat_=transition_probabilitymodel.emissionprob_=emission_probabilityseen = np.array([[0,1,0]]).Tlogprob, box = model.decode(seen, algorithm=\"viterbi\")print(\"The ball picked:\", \", \".join(map(lambda x: observations[x], seen)))print(\"The hidden box\", \", \".join(map(lambda x: states[x], box)))('The ball picked:', 'red, white, red')('The hidden box', 'box3, box3, box3') 限制 对于不同的建模选择和输入数据而言，它相对不灵活 它缩放严重(O(N²)，其中N是每个状态下可能的候选数) 它不能很好地应对高频观测(请参阅Newson＆Krumm [2])。 基于(无味)卡尔曼滤波器的新模型——https://blog.csdn.net/weixin_26713521/article/details/108134220 help Code: https://github.com/bmwcarit/barefoot https://github.com/oldrev/mapmatchingkit 网络文章 地图匹配实例-几何匹配——效果图 定位匹配 模板匹配 地图_什么是地图匹配？ 出租车轨迹点地图匹配研究 地图匹配小结 基于隐马尔科夫模型(HMM)的地图匹配(Map-Matching)算法 工作安排 你的工作主要完成什么（概括说明就行），分为那几步，每一步完成什么（概括说明就行），每一步的工作量（预计完成这步工作需要多少个小时），每一步工作预计在什么时候完成（比如 3.5） 工作包含：地图匹配，将车辆的有序GPS位置数据关联到电子地图的路网上，将GPS坐标下采样序列转换为数字路网路径序列的过程。工作内容：解析过滤点并进行坐标转换-&gt;点过滤(点稀疏)-&gt;地图匹配算法-&gt;点映射 内容 预估时间 查阅地图匹配算法相关的论文-&gt;找到解决方案(16小时) 2022年2月28日 学习隐马尔科夫模型相关理论知识 (6小时) 2022年3月2日 找寻隐马尔科夫模型资料、代码(8小时)——barefoot、graphhopper 2022年3月4日 熟悉项目中有关地图对象的代码（4小时） 2022年3月5日 移植隐马尔科夫模型到项目中，目前参考：开源barefoot实现：熟悉代码(16小时)、坐标转换（3小时）、输入输出数据格式改造(10小时)、适配类(56小时)、效果检验（10小时） 2022年3月20日 点过滤（24小时）: 栅格化（16小时） + 双队列（8小时） 2022年3月24日 点映射（6小时） 2022年3月25日 库： geometryEngine net.sf.geographiclib com.esri.core.geometry——QuadTree graphhopper——org.locationtech.jts.geom ==&gt; Envelope --&gt; findCandidateSnapsInBBox 简单版实现思路 找到起始点O和终点D，以两点为半径画圆，把所有范围内的NormalEdge全部加入List（只要起始点or终止点有一个在范围内） 确定第一条===&gt; 找离第一个GPS点最近的边 likelyRoute.forEach从上一条的lowerNormalEdge中(保证拓扑可达连接)，从中选择得分最高（距离和方向）的边作为后续边 。 如果没有lowerNormalEdge（如果所有剩余的点都能映射到最后的这条边上，则认为是终点，此时不在意死路）， 平常如果是死路，则放弃这条序列路径。TODO：没有后续路径时是否要考虑增加可能边集？ 到达终点边结束 从likelyRoute中选择得分最高的路径 用到的结构： likelyRoute: list[list], 存放多条可能","categories":[],"tags":[]},{"title":"私有Gitlab配置SSH连接","slug":"私有Gitlab配置SSH连接","date":"2022-02-25T05:38:19.000Z","updated":"2022-02-25T06:04:05.992Z","comments":true,"path":"2022/02/25/私有Gitlab配置SSH连接/","link":"","permalink":"https://nymrli.top/2022/02/25/私有Gitlab配置SSH连接/","excerpt":"","text":"SSH连接并不是像http连接一样，输入用户名和密码就可以了。SSH连接需要一些额外的配置 生成SSH秘钥和公钥 查询有效邮箱 首先要确定使用的邮箱，是不是自己认为的邮箱，比如我以为是chenli@sucsoft.com结果，却发现是399-chenli@sucsoft.com，那么按照自认为的邮箱申请的keys那自然不会work。——一般情况不会有歧义邮箱出现，但我这边确实跟想的不太一样 查询方法(一)——新建项目 创建空的仓库，提示中提及的邮箱就是有效邮箱 查询方法(二)——个人Preference 打开User Settings-&gt;Profile，其中有Email、public email和commit email三个邮箱，其中跟我们开发命令比较有关的就是这个Commit Email，之前我的默认是399-chenli@sucsoft.com，这边要设置自己想要的，比如chenli@sucsoft.com ▲选择完成后，滑到最下面选择Update profile settings 打开User Settings-&gt;Emails可以看到，chenli@sucsoft@sucsoft.com的标签中有commit email，即设置成功 Gitlab设置公钥 确保邮箱是有效的后就可以生成秘钥了。 设置git信息 12345678910111213141516171819202122232425# 1. 设置git信息git config --global user.name \"chenli\"git config --global user.email \"chenli@sucsoft.com\"# 2. 生成秘钥和公钥$ ssh-keygen -t rsa -C chenli@sucsoft.comGenerating public/private rsa key pair.Enter file in which to save the key (/c/Users/mrli/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/mrli/.ssh/id_rsaYour public key has been saved in /c/Users/mrli/.ssh/id_rsa.pubThe key fingerprint is:SHA256:zKPeKkm0bNzDqZcHUEDcvvDqPG2znRqDrD30yoBb8MM chenli@sucsoft.comThe key's randomart image is:+---[RSA 3072]----+| ooo || . o || o || + .o ||. + B oS || = .B.O. . ||. E+o*++ || o BB.B=.. ||. ..*B=*+ |+----[SHA256]-----+ 根据命令输出结果可以看到，生成的结果在C:\\Users\\mrli\\.ssh路径下，有id_rsa、id_rsa.pub，其中id_rsa.pub为公钥。 将SSH公钥添加到GitHub账户 复制文件路径内.pub后缀里的内容 进入SSH Keys的设置页面（登录GitHub，在右上角头像点击设置） 粘贴后，Title会自动提取生成，点击Add key则完成添加 测试 12$ ssh -T git@gitlab.sucsoft.comWelcome to GitLab, @chenli! More 配置多个Git信息 将默认的id_rsa和id_rsa.pub改成指定的如id_rsa_sucsoft.pub .ssh/路径下添加config配置文件，对应填写 123456789101112Host github.com HostName github.com IdentityFile C:\\\\Users\\\\mrli\\\\.ssh\\\\id_rsa_github PreferredAuthentications publickey User FreedomisgoodHost gitlab.sucsoft.com HostName gitlab.sucsoft.com IdentityFile C:\\\\Users\\\\mrli\\\\.ssh\\\\id_rsa_sucsoft PreferredAuthentications publickey User chenli 注意：Host后写的就是ssh -T git@gitlab.sucsoft.com中@后面的内容，如果写的是sucsoft，则写成ssh -T git@sucsoft，但是这样其实跟Gitlab页面中直接提供的不一样: git@gitlab.sucsoft.com:suc-frame/xxxx.git，所以最好还是规范的写gitlab.sucsoft.com ★配置完成后最终文件夹中的内容： 注： known_host是自动生成的，如果第一次SSH连接网站，则会将host添加到这个文件中","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"Golang protoc的使用","slug":"protoc的使用","date":"2022-02-22T04:04:33.000Z","updated":"2022-02-22T06:11:07.536Z","comments":true,"path":"2022/02/22/protoc的使用/","link":"","permalink":"https://nymrli.top/2022/02/22/protoc的使用/","excerpt":"","text":"使用Grpc需要有protoc的支持, 但默认安装的/Go/bin目录下只有go.exe、gofmt.exe两个可执行文件，因此要使用protoc的话，需要自己去下载 在https://github.com/protocolbuffers/protobuf/releases中下载Windows64的压缩包，为$protoc -go_out=. *.proto使用到的命令可执行文件 编写.proto文件， 如下所示 1234567891011121314151617syntax = &quot;proto3&quot;;# 注意, 这边使用的是go_package, 类似的还有java_package, 后面的参数是output_path和包名option go_package = &quot;.;geecachepb&quot;;message Request&#123; string group = 1; string key = 2;&#125;message Response&#123; bytes value = 1;&#125;service GroupCache&#123; rpc Get(Request) returns (Response);&#125; 使用protoc -go_out=. *.proto命令，将.proto转换成要使用的go文件 1234567891011121314151617181920212223242526272829303132// Code generated by protoc-gen-go. DO NOT EDIT.// versions:// protoc-gen-go v1.27.1// protoc v3.19.4// source: geecachepb.protopackage geecachepbimport ( protoreflect \"google.golang.org/protobuf/reflect/protoreflect\" protoimpl \"google.golang.org/protobuf/runtime/protoimpl\" reflect \"reflect\" sync \"sync\")const ( // Verify that this generated code is sufficiently up-to-date. _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion) // Verify that runtime/protoimpl is sufficiently up-to-date. _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20))type Request struct &#123; state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Group string `protobuf:\"bytes,1,opt,name=group,proto3\" json:\"group,omitempty\"` Key string `protobuf:\"bytes,2,opt,name=key,proto3\" json:\"key,omitempty\"`&#125;// ... 省略更多 go get -u github.com/golang/protobuf/protoc-gen-go安装使用xxxx.pb.go文件的库 在业务代码中使用 12345678910111213141516171819202122232425262728293031323334353637383940type PeerGetter interface &#123; Get(in *pb.Request, out *pb.Response) error&#125;func (p *HttpPool) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123; // ... body, err := proto.Marshal(&amp;pb.Response&#123;Value: view.ByteSlice()&#125;) if err != nil &#123; http.Error(w, err.Error(), http.StatusInternalServerError) return &#125; // ...&#125;func (h *httpGetter) Get(in *pb.Request, out *pb.Response) error &#123; u := fmt.Sprintf( \"%v%v/%v\", h.baseURL, url.QueryEscape(in.GetGroup()), url.QueryEscape(in.GetKey()), ) res, err := http.Get(u) if err != nil &#123; return err &#125; defer res.Body.Close() if res.StatusCode != http.StatusOK &#123; return fmt.Errorf(\"server return %v\", res.Status) &#125; bytes, err := ioutil.ReadAll(res.Body) if err != nil &#123; return err &#125; if err = proto.Unmarshal(bytes, out); err != nil &#123; return fmt.Errorf(\"decoding response body: %v\", err) &#125; return nil&#125; 推荐风格 文件(Files) 文件名使用小写下划线的命名风格，例如 lower_snake_case.proto 每行不超过 80 字符 使用 2 个空格缩进 包(Packages) 包名应该和目录结构对应，例如文件在my/package/目录下，包名应为 my.package 消息和字段(Messages &amp; Fields) 消息名使用首字母大写驼峰风格(CamelCase)，例如message StudentRequest { ... } 字段名使用小写下划线的风格，例如 string status_code = 1 枚举类型，枚举名使用首字母大写驼峰风格，例如 enum FooBar，枚举值使用全大写下划线隔开的风格(CAPITALS_WITH_UNDERSCORES )，例如 FOO_DEFAULT=1 服务(Services) RPC 服务名和方法名，均使用首字母大写驼峰风格，例如service FooService{ rpc GetSomething() }","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://nymrli.top/tags/Go/"}]},{"title":"语义化的版本控制","slug":"语义化的版本控制","date":"2022-01-26T14:30:00.000Z","updated":"2022-01-26T14:40:45.998Z","comments":true,"path":"2022/01/26/语义化的版本控制/","link":"","permalink":"https://nymrli.top/2022/01/26/语义化的版本控制/","excerpt":"","text":"语义化的版本控制： 用一组简单的规则及条件来约束版本号的配置和增长 作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。 如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。 如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函数库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页链接，让别人也知道这些规则并从中受益。 Target: 版本格式：主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当你做了不兼容的 API 修改， 次版本号：当你做了向下兼容的功能性新增， 修订号：当你做了向下兼容的问题修正。 先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。 语义化版本控制规范（SemVer） 以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。 使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。 标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。 标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。 修订号 Z（x.y.Z | x &gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。 次版本号 Y（x.Y.z | x &gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。 主版本号 X（X.y.z | X &gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。 先行版本号：可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。 版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符比非数字的标识符优先层级低。若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0。 FAQ 在 0.y.z 初始开发阶段，我该如何进行版本控制？ 最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。 如何判断发布 1.0.0 版本的时机？ 当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。 这不会阻碍快速开发和迭代吗？ 主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。 对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？ 这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。 为整个公共 API 写文件太费事了！ 为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。 万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？ 一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。 如果我更新了自己的依赖但没有改变公共 API 该怎么办？ 由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。 如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中） 自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。 我该如何处理即将弃用的功能？ 弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。 语义化版本对于版本的字串长度是否有限制呢？ 没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。 版本：Alpha、beta、RC 这些叫做先行版本号。被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰，如1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92 常见的 RC 版本，全称是 Release Candidate。其中 Release 是发行、发布的意思。Candidate 是候选人的意思，用在软件或者操作系统上就是候选版本。因此 Release Candidate 就是发行候选版本。 版本名称 介绍 说明 Alpha 内测版本 内部测试版本。 Beta 公测版本 Beta 阶段会一直加入新的功能。 RC 候选版本 几乎就不会加入新的功能了，而主要着重于除错。 Release 正式版本 稳定版本。 RC 版本和 Beta 版最大的差别在于 Beta 阶段会一直加入新的功能，但是到了 RC 阶段，几乎就不会加入新的功能了，而主要着重于除错。 RC 版本，它不是最终的版本，而是最终版（RTM，Release To Manufacture）之前的最后一个版本。广义上对测试有三个传统的称呼：Alpha（α）、Beta（β）、Gamma（γ），用来标识测试的阶段和范围。Alpha 是指内测，即现在说的 CB，指开发团队内部测试的版本或者有限用户体验测试版本。Beta 是指公测，即针对所有用户公开的测试版本。然后做过一些修改，成为正式发布的候选版本时叫做 Gamma，现在叫做 RC。","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"Springboot-Kotlin-Mockito","slug":"Springboot-Kotlin-Mockito","date":"2022-01-03T09:19:10.000Z","updated":"2022-01-03T10:50:45.305Z","comments":true,"path":"2022/01/03/Springboot-Kotlin-Mockito/","link":"","permalink":"https://nymrli.top/2022/01/03/Springboot-Kotlin-Mockito/","excerpt":"","text":"初识 Mockito 这个测试框架后，我们要使用 Mock 的属性创建一个被测试类实例时，大概会下面这么纯手工来打造。 手工过程见: https://www.jianshu.com/p/bb705a56f620 如果所有的 Mock 对象全部通过手工来创建，那就不容易体现出 Mockito 的优越性出来。因此对于被测试对象的创建，Mock 属性的注入应该让 @Mock 和 @InjectMocks这两个注解大显身手了。 Mockito能力 @Mock：对函数的调用均执行mock（即虚假函数），不执行真正部分。 @Spy：对函数的调用均执行真正部分。 @InjectMocks：创建一个实例，其余用@Mock（或@Spy）注解创建的mock将被注入到用该实例中。 @Autowird 方式是基于Springboot框架启动的自动注入。在单元测试中，如果没有启动 spring 框架，此时就需要通过 @ InjectMocks完成依赖注入： @InjectMocks会将带有@Spy 和@Mock 注解的对象尝试注入到被 测试的目标类中。记住下面这两句话即可： Usually when you are unit testing, you shouldn’t initialize Spring context. So remove Autowiring. Usually when you do integration testing, you should use real dependencies. So remove mocking. 这边也解释了，@RunWith(MockitoJUnitRunner::class)的含义，其实是给下面Mockito注入的成员提供一个运行环境，为什么不直接使用@SpringBootTest的原因主要还是启动太多，运行太重的考虑。那什么时候得用@SpringBootTest呢？——最简单的情况，即要注入controller又要注入service，同时需要@mock存储层的repository，由于controller和service都需要标注@InjectMocks, 但InjectMocks字段是无法注入其他InjectMocks字段的。所以我们可以考虑使用Spring来做容器管理。 @Mock和@MockBean区别 MockBean的介绍： 1234在做单元测试时，如果想要 mock UserRepository 的逻辑，只需要声明一个变量并在上面加上 @MockBean 的注释即可，之后使用 when().thenReturn() 来设定 mock UserRepository 的行为。在运行时 SpringBoot 会扫描到你注释的 mock ，并自动装配到被测试的 controller 里面。这也是和 @Mock 注释不同的地方，后者只能生成一个 Mock 类，但是并不能自动装配到其它类里面。 因此，@Mock方便来做单元测试，@MockBean大多用来做有依赖关系的集成测试 vertify 验证行为是否发生 verify方法用于验证 mock bean 的方法调用，要求必须是mock对象 Mockito . *verify* (mockBean ).someMethod();表示：someMethod方法调用了一次，相当于times(1) Mockito . *verify* (mock Bean, Mockito.times(n) ).someMethod();表示：someMethod方法调用了n次 Mockito . *verify* (mock Bean, Mockito.never() ).someMethod();表示：someMethod方法未执行 Mockito . *verify* (mock Bean, Mockito. atLeastOnce() ).someMethod();表示：someMethod方法至少执行过一次,相当于atLeast(1) 需要注意的：Mockito.*verify* (mock Bean, Mockito.only() ).someMethod();表示： 仅有someMethod方法执行，且只有一次，不能有其他方法执行 more: https://www.jianshu.com/p/0e6a868b9da0 常用的 Mockito 方法： Mockito的使用，一般有以下几种组合：参考链接 do/when：包括doThrow(…).when(…)/doReturn(…).when(…)/doAnswer(…).when(…) given/will：包括given(…).willReturn(…)/given(…).willAnswer(…) when/then: 包括when(…).thenReturn(…)/when(…).thenAnswer(…) 方法名 描述 Mockito.mock(classToMock) 模拟对象 Mockito.verify(mock) 验证行为是否发生 Mockito.when(methodCall).thenReturn(value1).thenReturn(value2) 触发时第一次返回value1，第n次都返回value2 Mockito.doThrow(toBeThrown).when(mock).[method] 模拟抛出异常。 Mockito.mock(classToMock,defaultAnswer) 使用默认Answer模拟对象 Mockito.when(methodCall).thenReturn(value) 参数匹配 Mockito.doReturn(toBeReturned).when(mock).[method] 参数匹配（直接执行不判断） Mockito.when(methodCall).thenAnswer(answer)) 预期回调接口生成期望值 Mockito.doAnswer(answer).when(methodCall).[method] 预期回调接口生成期望值（直接执行不判断） Mockito.spy(Object) 用spy监控真实对象,设置真实对象行为 Mockito.doNothing().when(mock).[method] 不做任何返回 Mockito.doCallRealMethod().when(mock).[method] //等价于Mockito.when(mock.[method]).thenCallRealMethod(); 调用真实的方法 reset(mock) 重置mock Matchers 匹配任意参数 Mockito.anyInt() 任何 int 值 ； Mockito.anyLong() 任何 long 值 ； Mockito.anyString() 任何 String 值 ； Mockito.any(XXX.class) 任何 XXX 类型的值 等等。 1234567891011121314151617@Testpublic void with_unspecified_arguments()&#123; List list = Mockito.mock(List.class); //匹配任意参数 Mockito.when(list.get(Mockito.anyInt())).thenReturn(1); Mockito.when(list.contains(Mockito.argThat(new IsValid()))).thenReturn(true); Assert.assertEquals(1,list.get(1)); Assert.assertEquals(1,list.get(999)); Assert.assertTrue(list.contains(1)); Assert.assertTrue(!list.contains(3));&#125;class IsValid extends ArgumentMatcher&lt;List&gt;&#123; @Override public boolean matches(Object obj) &#123; return obj.equals(1) || obj.equals(2); &#125;&#125; More： 函数名 匹配类型 any() 所有对象类型 anyInt() 基本类型 int、非 null 的 Integer 类型 anyChar() 基本类型 char、非 null 的 Character 类型 anyShort() 基本类型 short、非 null 的 Short 类型 anyBoolean() 基本类型 boolean、非 null 的 Boolean 类型 anyDouble() 基本类型 double、非 null 的 Double 类型 anyFloat() 基本类型 float、非 null 的 Float 类型 anyLong() 基本类型 long、非 null 的 Long 类型 anyByte() 基本类型 byte、非 null 的 Byte 类型 anyString() String 类型(不能是 null) anyList() List 类型(不能是 null) anyMap() Map&lt;K, V&gt;类型(不能是 null) 附录 Junit中的基本注解： @Test：使用该注解标注的public void方法会表示为一个测试方法； @BeforeClass：表示在类中的任意public static void方法执行之前执行； @AfterClass：表示在类中的任意public static void方法之后执行； @Before：表示在任意使用@Test注解标注的public void方法执行之前执行； @After：表示在任意使用@Test注解标注的public void方法执行之后执行； demo： https://github.com/enesacikoglu/SpringBootKotlinApi/blob/master/src/test/kotlin/com/cengenes/kotlin/api/service/HotelServiceManagerTest.kt","categories":[],"tags":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://nymrli.top/tags/开发笔记/"}]},{"title":"理解SpringBoot注解s","slug":"理解SpringBoot注解s","date":"2021-12-30T12:30:45.000Z","updated":"2021-12-30T14:25:40.982Z","comments":true,"path":"2021/12/30/理解SpringBoot注解s/","link":"","permalink":"https://nymrli.top/2021/12/30/理解SpringBoot注解s/","excerpt":"","text":"@ReuqestBody和@RequestParam 这两个注解都是在Controller某个Mapping函数的形参前加上的，但两个具体有什么区别呢？在使用的时候我们该如何选择呢? 这跟我们希望用户以什么形式来请求接口有关。 众所周知，请求头的Content-type有多个，如 常见的媒体格式类型如下： text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml： XML数据格式 application/atom+xml ：Atom XML聚合格式 ⭐️application/json： JSON数据格式 application/pdf：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） ⭐️application/x-www-form-urlencoded ：&lt;form encType=&quot;&quot;&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的： multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 其中，POST请求最常用的是application/x-www-form-urlencoded,浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。请求类似于下面这样 此外，application/json也是POST比较常用的一种形式，也是目前比较推荐的，用来告诉服务端消息主体是序列化后的 JSON 字符串。在这种编码方式下，请求内容如下： 可以看出，无论是哪种编码，POST基本上都是从请求体中取数据解析的。而@RequestBody正是对应的请求体；@RequestParam呢，接收的参数是来自requestHeader中，即请求头。通常用于GET请求，功能是从URL中提取请求参数。比如常见的url：http://localhost:8081/spring-boot-study/novel/findByAuthorAndType?author=唐家三少&amp;type=已完结。对应的接口为public List&lt;NovelEntity&gt; findByAuthorAndType(@RequestParam(value=&quot;author&quot;, required=false,defaultValue=&quot;天蚕土豆&quot;) String author, @RequestParam(value=&quot;type&quot;) String type) @RequestParam有三个配置参数： required 表示是否必须，默认为 true，必须。 defaultValue 可设置请求参数的默认值。 value 为接收url参数的参数名（相当于key值）。 @RequestParam用来处理 Content-Type 为 application/x-www-form-urlencoded 编码的内容，Content-Type默认为该属性。 @RequestParam也可用于其它类型的请求，例如：GET、POST、DELETE等请求。比如向表中插入单条数据，Controller 层的写法如下图所示： 但是，这样不支持批量插入数据，相对之下，json来表达的优势就很明显，但是@RequestParam没办法处理application/json，点击发送的话，会报错后台接收不到值，为 null。 此时就需要使用对应的@RequestBody，它一般用于处理非 Content-Type: application/x-www-form-urlencoded编码格式的数据，比如：application/json、application/xml等类型的数据。就application/json类型的数据而言，使用注解@RequestBody可以将body里面所有的json数据传到后端，后端再进行解析。如public Map&lt;String, Boolean&gt; saveBatchNovel(@RequestBody List&lt;NovelEntity&gt; novelEntityList) 此外，针对希望用户传入的为指定参数的话，有相应的Entity，使用@RequestBody会根据请求主体中的参数名与对象的属性名进行匹配并绑定值，自动将参数封装成该对象，并且还可以通过@Valid注解对请求主体中的参数进行校验。 总结： @RequestParam的核心功能是从URL中提取请求参数，即接收的参数是来自HTTP请求头的QueryString中。 @RequestBody功能是从请求体重提取参数，并封装成对象 额外经验总结： 标准协议下，通常认为GET请求是没有请求体的，只有POST请求有请求体 get请求只能传query参数，query参数都是拼在请求地址上的 post可以同时传body和query两种形式的参数 123456789101112131415161718192021@RestController@RequestMapping(\"/hello\")public class HelloController &#123; @PostMapping(\"/post/&#123;id&#125;\") public Map&lt;String, String&gt; postHello(@PathVariable Long id, @RequestParam(value = \"name\", required = false, defaultValue = \"CL\") String name, @RequestBody User user ) &#123; System.out.println(user); return new HashMap&lt;String, String&gt;() &#123;&#123; put(\"name\", name); put(\"id\", String.valueOf(id)); &#125;&#125;; &#125;&#125;@Dataclass User&#123; private int id; private int age;&#125; talent-API postman-web 针对接口的测试，最好还是手动设置Content-type比较好 @PathVariable 承接上文，同样作为参数传入的还有@PathVariable，它可以从URL中提取变量 @PathVariable注解是将方法中的参数绑定到请求URI中的模板变量上。可以通过@RequestMapping注解来指定URI的模板变量，然后使用@PathVariable注解将方法中的参数绑定到模板变量上。特别地，@PathVariable注解允许我们使用value或name属性来给参数取一个别名。下面是使用此注解的一个示例： 1234@GetMapping(\"/users/&#123;id&#125;/roles/&#123;roleId&#125;\")public Role getUserRole(@PathVariable long id, @PathVariable long roleId)&#123;&#125; 模板变量名需要使用{ }进行包裹，如果方法的参数名与URI模板变量名一致，则在@PathVariable中就可以省略别名的定义。","categories":[],"tags":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://nymrli.top/tags/开发笔记/"}]},{"title":"Spring中的Bean","slug":"Spring中的Bean","date":"2021-12-30T02:46:34.000Z","updated":"2021-12-30T02:46:35.302Z","comments":true,"path":"2021/12/30/Spring中的Bean/","link":"","permalink":"https://nymrli.top/2021/12/30/Spring中的Bean/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SpringCloud笔记","slug":"SpringCloud笔记","date":"2021-12-29T15:14:51.000Z","updated":"2021-12-30T14:29:21.107Z","comments":true,"path":"2021/12/29/SpringCloud笔记/","link":"","permalink":"https://nymrli.top/2021/12/29/SpringCloud笔记/","excerpt":"","text":"笔记内容大多来自：尚硅谷SpringCloud框架开发教程 跟做笔记：https://blog.csdn.net/MOKEXFDGH/article/details/107209899 跟做工程代码： https://github.com/liusCoding/springcloud-2020、https://gitee.com/exclusiver/springcloud2020 MVN配置 每个module的pom配置文件中最重要的三个：GAV即 groupId、artifactId、version dependencyManagement声明依赖的版本，可以起到作用： 约定依赖的统一版本 子module不用写groupId和version 注：dependencyManagement只是声明了依赖的约定，但是在子模块中确定要使用这个依赖时，还是需要dependency指出，即dependencyManagement只是声明，并没有实际引入。此外，如果子模块想要摆脱约定版本的话，可以通过特别列出version从而指定版本 业务开发流程 建表SQL Entities Dao Service Controller 创建mysql数据库： 通过图形界面——字符集选 utf8, 排序规则选 utf8_general_ci 通过SQL 12CREATE DATABASE `wordpress` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;CREATE DATABASE `wordpress` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 请求模拟 浏览器对POST支持不太友好，需要使用如PostMan等工具：浏览器输入http://localhost:8001/create?serial=23，一旦戴上了这个?xxx=yyy的请求参数，则会被认为是Get请求 注解使用 @mapper对应@Resource(javax.annotation) @Repository对应@Autowired 在Dao层定义时，推荐使用@Mapper(apache.ibatis)，而不是@Repository(org.springframework.stereotype)，因为后者在插入的时候可能会有问题 添加热部署 添加devtools依赖到工程 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 在pom中指定添加插件 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; enabling automatic build 修改&quot;Updating Registrer&quot; （通过在pom文件中ctrl+shift+alt+/按出maintenance）==&gt;IDEA2021中不需要设置了 重启IDEA 注：上述只是重启，Jrebel才是真正意义上的热部署 RestTemplate Java中调用第三方的接口API时，是通过HttpClient库来创建请求的；而对于通过基于Http的Restful微服务接口，Springboot提供了一套方法: RestTemplate RestTemplatej提供了多种便捷访问远程Http服务的方法，是—种简单便捷的访问 restful服务模板类，是 Spring提供的用于访问Rest服务的客户端模板工具集 1234567891011121314151617181920212223public class OrderController &#123; public static final String PAYMENT_URL = \"http://localhost:8001\"; @Resource private RestTemplate restTemplate;@GetMapping(\"/consumer/payment/create\") public CommonResult&lt;Payment&gt; create(Payment payment) &#123; return restTemplate.postForObject(PAYMENT_URL + \"/payment/create\", payment, CommonResult.class); &#125; // ..&#125;// 由于postForObject会以 application/json的形式发送数据, 所以在Payment系统的接口中如果不加上 @RequestBody 的话，则无法封装成相应的对象public class PaymentController &#123; @Resource private PaymentService paymentService; @PostMapping(value = \"/create\") public CommonResult&lt;Payment&gt; create(@RequestBody Payment payment) &#123; // 加上@RequestBody注解 int result = paymentService.create(payment); // ... &#125; 注册中心 服务注册:将服务信息注册进注册中心 服务发现:从注册中心上获取服务信息实质:存key服务命取value调用地址 eureka环境搭建 服务端server 创建相应的工程或者module 12345678910&lt;dependencies&gt; &lt;!--eureka-server--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--eureka-server--&gt;&lt;/dependencies&gt; 编写yml 12345678910111213server: port: 7001eureka: instance: hostname: localhost client: # 表示不向注册中心注册自己 register-with-eureka: false # 自己就是注册中心，职责就是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 给application加上EnableEurekaServer自动注入的注解，并表明是eureka服务端 12345678910111213/** * @author MrLi * @description * @create 2021-12-30 16:46 **/@SpringBootApplication@EnableEurekaServerpublic class EurekaMain7001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMain7001.class, args); &#125;&#125; 客户端client 虽然叫客户端，但其实是相对于eureka服务而言的，对于暴露的rpc服务来看，他是接口服务的服务端 加pom 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 增加yml配置 123456789eureka: client: # 表示不向注册中心注册自己, 默认为true register-with-eureka: true # 是否从EurekaServer抓取已有的注册信息，默认为true；单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetch-registry: true service-url: # 设置于eurekaServer交互的地址查询服务和注册服务都需要依赖这个地址 defaultZone: http://localhost:7001/eureka applicaiton上加注解 12345678@SpringBootApplication@EnableEurekaClientpublic class PaymentMain8001 &#123; public static void main(String[] args) &#123; System.out.println(\"服务运行在 http://localhost:8001/\"); SpringApplication.run(PaymentMain8001.class, args); &#125;&#125; 为了防止单点故障的问题，这边可以增加一个EurekaServer的实例，从而组成EurekaServer集群，相互注册相互守望。 集群搭建 先启动eureka注册中心 启动服务提供者: payment支付服务 支付服务启动后会把自身信息(比服务地址以别名方式注册进eureka) 消费者order服务在需要调用接口时,使用服务别名去注册中心获取实际的RPC远程调用地址 消费者获得调用地址后,底层实际是利用HttpClient术实现远程调用 消费者获得服务地址后会缓存在本地jvm内存中,默认每间隔30秒更新一次服务调用地址 问题:微服务RPC远程服务调用最核心的是什么？ A: 高可用,试想你的注册中心只有一个ohly one,它出故障了那就呵呵了,这会导致整个为服务环境不可用。 所以解决办法:搭建Eureka注册中心集群,实现负载均衡+故障容错 创建多个eureka实例工程or模块 修改hosts映射文件: C:\\Windows\\System32\\drivers\\etc\\HOSTS 123127.0.0.1 eureka7001.com127.0.0.1 eureka7002.com 虽然eureka7001.com和eureka7002.com都指向的是localhost，真正区分服务的是通过后面的port。但仍然这么做的目的是模拟真实情况，不然都是localhost的话对用户而言不好区分。 修改yml配置 1234567891011121314server: port: 7002eureka: instance: hostname: eureka7002.com client: # 表示不向注册中心注册自己 register-with-eureka: false # 自己就是注册中心，职责就是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: # 7001指向7002（即在7002中注册了7001的地址） defaultZone: http://eureka7001.com:7001/eureka/ 12345678910111213server: port: 7001eureka: instance: hostname: eureka7001.com client: # 表示不向注册中心注册自己 register-with-eureka: false # 自己就是注册中心，职责就是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: defaultZone: http://eureka7002.com:7002/eureka/ 两个server相互存了对方的地址，相互守望从而实现高可用 同时运行两个application，然后输入localhost:7001，可以看到页面中DS Replicas显示有7002，打开localhost:7002同样能看到7001的DS Replicas即镜像 服务接入集群 修改配置文件，主要是把集群中的地址全部填上 12345678eureka: client: # 表示不向注册中心注册自己, 默认为true register-with-eureka: true # 是否从EurekaServer抓取已有的注册信息，默认为true；单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetch-registry: true service-url: defaultZone: http://eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka 服务负载均衡","categories":[],"tags":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://nymrli.top/tags/开发笔记/"}]},{"title":"使用七牛云作图床+PicGo","slug":"使用七牛云作图床-PicGo","date":"2021-12-29T13:48:37.000Z","updated":"2021-12-29T14:12:11.451Z","comments":true,"path":"2021/12/29/使用七牛云作图床-PicGo/","link":"","permalink":"https://nymrli.top/2021/12/29/使用七牛云作图床-PicGo/","excerpt":"","text":"自己在写博客的时候，通过图片来表达自己的思路无疑是种非常有效的方法，平常我的笔记都是通过hexo生成的，因此保存在本地路径即可。但是如果想把文章发表在第三方的平台上，那么这些相对路径的图片在上传过程中就无法被检索，因此如果能在一个大家都能访问到的地方存放这些图片，再给出这些地方的链接时那就解决了这个问题。要达到这个需求，则就需要使用OSS对象存储服务。 这边我推荐的是七牛云。七牛云在注册认证后有10G永久免费空间，每月10G国内和10G国外流量，速度相当快，七牛云是国内专业CDN服务商，插件支持比较多，有免费SSL证书，但https流量收费。同时七牛云还会提供30天的测试域名，不过要注意的一点是，七牛云30天后会回收测试域名，并且通过测试域名存储的文件会在30天后一起被杀出，因此最好还是要绑定自己的已备案的域名。 七牛云创建与配置 创建空间 可以根据自己的需求来新建自己的存储空间，点击【新建空间】，对空间进行配置，这里要注意，以下几点： 存储空间名称不能重复，我这里也新建一个名称为：onestar-blog-img 存储区域选择一个离你近点的，我选的是华东，每个地点有个编号的，后面要用来配置PicGo，这里先说一下区域对应编号: 华东：z0；华北：z1；华南：z2：北美：na0：东南亚：as0 访问控制选择公开，因为要作为外链进行访问 配置域名并绑定 点击&quot;+绑定域名&quot;按钮 2.就会进入如下的添加域名页面，需要做的就是填入一个三级域名，如我申请的二级域名为nymrli.top，那么这边我可以写xxx.nymrli.top，这个xxx就是nymrli.top下的子域名，但是这个毕竟是我们临时想出来的，因此要让他生效的话，我们还需要在DNS服务商那边进行配置。 接下来开始配置CNAME解析，由于我的域名解析是在阿里云做的，因此需要到阿里云的域名管理控制台添加这个CNAME的解析 添加好CNAME记录后等待一会让其生效后，就能到七牛云的“域名管理”页面查看状态啦，如下所示，这边的“状态”显示成功了 Picgo图床软件配置 自带免费的SM.MS图床配置，可以直接使用。但是用别人的配置，占别人的资源毕竟不太好，容易超额，而且安全性也不高。因此配置自己的存储API，这边使用上述配置好的七牛云。 accessKey和SecretKey可以点击头像到“个人中心”去查看并复制进去 存储空间名就是一开始创建空间的名字 网址的话就是自己绑定的三级域名 这边比较容易填错的是存储区域，对应的其实是华南、华东……但需要填编号，这边编号关系如下： z0；华北：z1；华南：z2：北美：na0：东南亚：as0","categories":[],"tags":[]},{"title":"Go的进阶学习","slug":"Go的进阶学习","date":"2021-12-29T08:15:07.000Z","updated":"2021-12-29T15:53:41.639Z","comments":true,"path":"2021/12/29/Go的进阶学习/","link":"","permalink":"https://nymrli.top/2021/12/29/Go的进阶学习/","excerpt":"","text":"GO中通过组合方式实现的伪继承 说到继承我们都知道，也可以了解到在Go中是没有extends关键字的，也就意味着Go并没有原生级别的继承支持。这也是为什么用了伪继承这个词。本质上，Go使用interface实现的功能叫组合，Go是通过组合(+匿名字段的技术)来实现的继承，说的更精确一点，是使用组合来代替继承 我们用很容易理解的动物-猫来举例子，废话不多说，直接看代码。 12345678910111213141516171819type Animal struct &#123; Name string&#125;func (a *Animal) Eat() &#123; fmt.Printf(\"%v is eating\", a.Name) fmt.Println()&#125;type Cat struct &#123; *Animal&#125;cat := &amp;Cat&#123; Animal: &amp;Animal&#123; Name: \"cat\", &#125;,&#125;cat.Eat() // cat is eating 代码分析 首先，我们实现了一个Animal的结构体，代表动物类。并声明了Name字段，用于描述动物的名字。然后，实现了一个以Animal为receiver的Eat方法，来描述动物进食的行为。最后，声明了一个Cat结构体，组合了Cat字段。再实例化一个猫，调用Eat方法，可以看到会正常的输出。 可以看到，Cat结构体本身没有Name字段，也没有去实现Eat方法。唯一有的就是组合了Animal父类，至此，我们就证明了已经通过组合实现了继承。 将接口优雅简明化 接口用于描述某个类的行为。对于一个接口的使用者而言，我需要在拿到这个接口的同时能一目了然的知道这个类干了什么，有哪些方法可以调用，因此上面的写法我们并不能从中看出Animal具体有哪些功能，因此，我们可以创建一个说明它功能方法的父接口。 例如，我们即将要抽象的动物接口就会描述作为一个动物，具有哪些行为。常识告诉我们，动物可以进食（Eat），可以发出声音（bark），可以移动（move）等等。这里有一个很有意思的类比。 123456789101112131415161718192021222324252627282930313233343536// 模拟动物行为的接口type IAnimal interface &#123; Eat() // 描述吃的行为&#125;// 动物 所有动物的父类type Animal struct &#123; Name string&#125;// 动物去实现IAnimal中描述的吃的接口func (a *Animal) Eat() &#123; fmt.Printf(\"%v is eating\\n\", a.Name)&#125;// 动物的构造函数func newAnimal(name string) *Animal &#123; return &amp;Animal&#123; Name: name, &#125;&#125;// 猫的结构体 组合了animaltype Cat struct &#123; *Animal&#125;// 实现猫的构造函数 初始化animal结构体func newCat(name string) *Cat &#123; return &amp;Cat&#123; Animal: newAnimal(name), &#125;&#125;cat := newCat(\"cat\")cat.Eat() // cat is eating 函数形参问题 1234567func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123; // ... c := newContext(w, req) c.handlers = middlewares c.engine = engine engine.router.handle(c)&#125; 这里和 http ServerHTTP 函数原始的两个参数对应 req 和 writer。req 是结构体，用指针可以节省内存，Writer 是一个接口类型，不能用指针。","categories":[],"tags":[]},{"title":"开发方向-技术栈","slug":"开发方向-技术栈","date":"2021-12-28T13:02:43.000Z","updated":"2021-12-28T16:10:43.781Z","comments":true,"path":"2021/12/28/开发方向-技术栈/","link":"","permalink":"https://nymrli.top/2021/12/28/开发方向-技术栈/","excerpt":"","text":"Cloud 微服务全家桶 微服务开发的主流技术栈 服务注册中心 :error:eureka 停止更新 ❌consul zookeeper ⭐️nacos 服务负载与调用 ❌ netflix oss ribbon ==&gt; spring cloud loadbalance netflix feign ==&gt; Spring cloud OpenFeign 容量限流(熔断) ❌hystrix: 最先的老大哥 resilience4j：国外使用较多 ⭐️spring cloud alibaba sentinel 配置中心 ❌spring cloud config 携程: apollo spring cloud alibaba nacos 服务开发 spring boot 流量监控 服务总线: ❌spring cloud bus spring cloud alibaba nacos 服务治理 链路追踪 spring cloud sleuth 服务网关 ❌(netflix) zuul zuul2: 胎死腹中 ⭐️spring cloud gateway matrics（指标）监控： kairosDB 日志监控： ELK 健康检查和告警： zalando zmon","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://nymrli.top/tags/开发/"}]},{"title":"Kotlin集合、流式操作","slug":"Kotlin集合、流式操作","date":"2021-12-27T03:14:40.000Z","updated":"2022-01-03T13:36:36.222Z","comments":true,"path":"2021/12/27/Kotlin集合、流式操作/","link":"","permalink":"https://nymrli.top/2021/12/27/Kotlin集合、流式操作/","excerpt":"","text":"除了最通用的Array以外，kotlin中还有一类容器统称为Colletion(集合)，他们有 List List：继承Collection。一个范性有序的只读集合。因为有序，所以，我们可以使用get(position)等查询的方法 MutableList：继承List，MutableCollection。一个有序集合。并额外提供了add/remove元素的方法 Set Set：继承Collection。一个无序并不支持重复元素的集合 MutableSet：继承Set，MutableCollection，一个无序的集合并且不支持重复元素。但是，支持add/remove元素 Map Map：一个key-value的只读集合。并且key唯一。 MutableMap：继承Map。支持put/remove元素 List any：如果至少有一个元素与判断条件相符，则 返回true all：如果全部元素与判断条件相符，则 返回true component1,…,component5：返回集合的第n个元素，越界返回ArrayIndexOutOfBoundsException contain：如果指定元素可以在集合找到，则 返回true containsAll：如果指定集合所有元素都可以在目标集合找到，则 返回true count：返回与判断条件相符的元素个数 distinct：返回一个只包含不同元素的数组，即对列表内元素去重 distinctBy：返回集合元素执行指定条件后，不同元素的数组（原始数组元素） 12val list = listOf(1, 4, 2, 2)assertEquals(listOf(1,4),list.distinctBy &#123; it%2 == 0&#125;) drop：返回所有元素的列表，但不包含前n个元素 12val list = listOf(1,2,3,4)assertEquals(listOf(3,4),list.drop(2)) dropLast：返回所有元素的列表，但不包含最后n个元素 12val list = listOf(1,2,3,4)assertEquals(listOf(1,2),list.dropLast(2)) dropWhile：返回所有元素的列表，但不包含满足判断条件的元素 1234val list = listOf(4,1,2,3,4)assertEquals(listOf(4,1,2,3,4),list.dropWhile&#123;it &lt;3&#125;)val list = listOf(1,2,3,4)assertEquals(listOf(3,4),list.dropWhile&#123;it &lt;3&#125;) elementAt：返回指定索引的元素，如果索引越界，则抛出ArrayIndexOutOfBoundsException 12345678val list = listOf(1,2,3,4)assertEquals(4,list.elementAt(3))// elementAtOrElse：返回指定索引的元素，如果索引越界，则返回指定的默认值val list = listOf(1,2,3,4)assertEquals(18,list.elementAtOrElse(6,&#123;it *3&#125;))// elementAtOrNull: 返回指定索引的元素，如果索引越界，则返回nullval list = listOf(1,2,3,4)assertEquals(null,list.elementAtOrNull(6)) filter:筛选出所有符合条件的元素 12345678910111213val list = listOf(1,2,3,4)assertEquals(listOf(2,3),list.filter&#123; it in 2..3 &#125;)filterIndexed// filterIndexed筛选出所有符合条件的元素（条件多了一个索引参数）val list = listOf(1, 4, 2, 2)assertEquals(listOf(4),list.filterIndexed &#123; index, it -&gt; index&gt;0 &amp;&amp; it &gt;2&#125; )// filterNot: 筛选出所有不符合条件的元素val list = listOf(1,2,3,4)assertEquals(listOf(1,4),list.filterNot&#123; it in 2..3 &#125;)filterNotNull// filterNotNull: 筛选出所有不为null的元素val list = listOf(1,2,3,null,4)assertEquals(listOf(1,2,3,4),list.filterNotNull()) first 返回第一个满足条件的元素,没有则抛出NoSuchElementException 12345678910111213141516171819202122val list = listOf(1,2,3,4)assertEquals(2,list.first &#123; it &gt; 1 &#125;)// firstOrNull: 返回第一个满足条件的元素，没有，则 返回Nullval list = listOf(1, 2, 3, 4)assertEquals(null, list.firstOrNull &#123; it &gt; 5 &#125;)// find :同firstOrNull。返回第一个满足条件的元素，没有，则 返回Nullval list = listOf(1,2,3,4)assertEquals(2,list.find &#123; it &gt; 1 &#125;)// findLast: 返回最后一个满足条件的元素，没有，则 返回Nullval list = listOf(1,2,3,4)assertEquals(4,list.findLast &#123; it &gt; 1 &#125;)// last: 返回符合给定函数条件的最后一个元素，不存在则抛出NoSuchElementExceptionval list = listOf(1, 2, 2, 4)assertEquals(4, list.last &#123; it % 2 == 0 &#125;)// lastIndexOf: 返回指定元素的第一个索引位置，不存在返回-1val list = listOf(1, 2, 2, 4)assertEquals(2, list.lastIndexOf(2) )// lastOrNull: 返回符合给定函数条件的最后一个元素，不存在返回nullval list = listOf(1, 2, 2, 4)assertNull( list.lastOrNull&#123; it &gt;5&#125;) single: 返回符合指定函数条件的单个元素，如果没有符合或者超过一个，则抛出异常。\\ 123456val list = listOf(1, 2, 2, 4)assertEquals(4, list.single &#123; it == 4 &#125;)// singleOrNull: 返回符合指定函数条件的单个元素，如果没有符合或者超过一个，则返回nullval list = listOf(1, 2, 2, 4)assertEquals(null, list.singleOrNull &#123; it == 2 &#125;) flatMap: 遍历所有的元素，为每一个元素创建一个集合，最后把所有的集合放在一个集合中。 12val list = listOf(1, 2)assertEquals(listOf(1,2,2,4),list.flatMap &#123; it -&gt; listOf(it,it*2) &#125;) flatten: 遍历一个单独的集合，包含给定嵌套集合里面的所有元素。 12val list = listOf(listOf(1,2), listOf(4,2), listOf(3), listOf(4))assertEquals(listOf(1,2,4,2,3,4), list.flatten()) fold： 将对集合从第一个到最后一个元素进行操作 123456//这里是进行乘法操作val list = listOf(1, 2, 3, 4)assertEquals(48, list.fold(2) &#123; total, next -&gt; total * next &#125;)// foldRight: 跟fold操作一样，不过是从最后一个到到一个元素进行操作val list = listOf(1, 2, 3, 4)assertEquals(48, list.foldRight(2) &#123; total, next -&gt; total * next &#125;) reduce： 与fold功能一样。但是，没有初始值。把集合从第一个到最后一个，按指定条件进行操作 12val list = listOf(1, 2, 2, 4)assertEquals(-7, list.reduce &#123; total, next -&gt; total -next &#125;) get:获取索引所在的元素，没有则返回ArrayIndexOutOfBoundsException 12345678// getOrElse: 获取索引所在的元素，没有就返回默认值val list = listOf(1, 2, 4, 2, 3, 4)assertEquals(10, list.getOrElse(8, &#123; _ -&gt; 10 &#125;))assertEquals(2, list.getOrElse(1, &#123; _ -&gt; 10 &#125;))// getOrNull: 获取索引所在的元素，没有就返回nulval list = listOf(1, 2, 4, 2, 3, 4)assertEquals(null, list.getOrNull(8))assertEquals(4, list.getOrNull(2)) map： 返回一个每个元素都根据给定函数条件转换的数组 12345678val list = listOf(1, 2, 2, 4)assertEquals(listOf(2, 4, 4, 8), list.map&#123; it*2&#125; )// mapIndexed: 功能同map，比map多了一个索引val list = listOf(1, 2, 2, 4)assertEquals(listOf(0, 2, 4, 4), list.mapIndexed &#123; index, it -&gt; if (index % 2 == 0) index * it else it &#125;)// mapNotNull: 同map。但是，元素转换不包含Nullval list = listOf(1, 2,null, 2, 4)assertEquals(listOf(2, 4, 4, 8), list.mapNotNull &#123; it?.times(2) &#125;) max: 返回集合最大元素。不存在返回null 1234567891011121314val list = listOf(1, 2, 2, 4)assertEquals(4, list.max())val list = emptyList&lt;Int&gt;()assertEquals(null, list.max())// maxBy:返回根据指定函数转换后，产生的最大值的原始元素（返回的还是原始元素）。如果没有元素，则返回null。val list = listOf(1, 2, 2, 4)assertEquals(1, list.maxBy &#123; -it &#125;)// min:返回集合最小元素，不存在返回nullval list = listOf(1, 2, 2, 4)assertEquals(1, list.min())// minBy: 返回根据指定函数转换后，产生的最小值的原始元素（返回的还是原始元素）。如果没有元素，则返回null。val list = listOf(1, 2, 2, 4)assertEquals(4, list.minBy &#123; -it &#125;) none： 如果没有任何元素与指定的函数条件匹配，则返回true。 12val list = mutableListOf(1, 2, 2, 4)assertTrue(list.none &#123; it &gt; 4 &#125;) orEmpty： 如果没有任何元素与指定的函数条件匹配，则返回true。 12val list = mutableListOf(1, 2, 2, 4)assertTrue(list.none &#123; it &gt; 4 &#125;) sorted：返回所有元素分类排序列表。 1234567891011121314val list = listOf(1, 4, 2, 2)assertEquals(listOf(1, 2, 2, 4), list.sorted())// sortBy:返回所有元素分类排序列表。顺序按照指定函数条件排列val list = listOf(1, 4, 2, 2)assertEquals(listOf(4,2,2,1), list.sortedBy &#123; -it &#125;)// sortDescending:返回所有元素分类排序列表。顺序按降序排列val list = listOf(1, 4, 2, 2)assertEquals(listOf(4,2,2,1), list.sortedDescending())// sortedByDescending:返回所有元素分类排序列表。顺序按指定函数条件的降序排列val list = listOf(1, 4, 2, 2)assertEquals(listOf(1,2,2,4), list.sortedByDescending&#123; -it &#125;) slice: 返回一个list中指定index的元素。 123val list = listOf(1, 4, 2, 2)assertEquals(listOf(4,2,2), list.slice(1..3))assertEquals(listOf(1,4), list.slice(listOf(0,1))) take: 返回从第一个元素开始的n个元素。 12val list = listOf(1, 4, 2, 2)assertEquals(listOf(1,4), list.take(2)) zip: 返回一个列表，该列表由两个集合中相同索引元素建立的元素对。这个列表长度为最短集合的长度。 12val list = listOf(1, 4, 2, 2)assertEquals(listOf(Pair(1,10),Pair(4,20),Pair(2,30)), list.zip(listOf(10,20,30))) groupBy 返回一个根据给定函数分组后的map， value为list 12val list = listOf(1, 2, 2, 4)assertEquals(mapOf(\"error\" to listOf(1), \"right\" to listOf(2, 2, 4)), list.groupBy &#123; if (it % 2 == 0) \"right\" else \"error\" &#125;) associateBy 通过指定的条件，把list转换成map，value为单元素 2种，第一只转换map的key;第二map的key-value都转换 123val list = listOf(1, 4, 2, 2)assertEquals(hashMapOf(\"key1\" to 1, \"key4\" to 4, \"key2\" to 2), list.associateBy &#123; it -&gt; \"key\" + it &#125;)assertEquals(hashMapOf(\"key1\" to \"value1\", \"key4\" to \"value4\", \"key2\" to \"value2\"), list.associateBy(&#123; it -&gt; \"key\" + it &#125;, &#123; it -&gt; \"value\" + it &#125;)) associateBy和groupBy区别 函数associateBy和groupBy构建来自由指定键索引的集合的元素的映射。key在keySelector参数中定义。 还可以指定可选的valueSelector来再选择定义将存储在map元素值中的内容。 区别 associateBy和groupBy之间的区别在于它们如何使用相同的键处理对象： associateBy使用最后一个合适的元素作为值。 groupBy构建所有合适元素的列表并将其放入值中。 12345678910111213141516171819data class StreamPractise( val id: Int, val name: String, val age: Int)fun main() &#123; val l = listOf(StreamPractise(1, \"hello\", 19), StreamPractise(1, \"cl\", 31)) var res = l.associateBy &#123; it.id &#125; println(res)&#125;// &#123;1=StreamPractise(id=1, name=cl, age=31)&#125;fun main() &#123; val l = listOf(StreamPractise(1, \"hello\", 19), StreamPractise(1, \"cl\", 31)) var res = l.groupBy &#123; it.id &#125; println(res)&#125;// &#123;1=[StreamPractise(id=1, name=hello, age=19), StreamPractise(id=1, name=cl, age=31)]&#125; Map getOrElse() 与 list 的工作方式相同：对于不存在的键，其值由给定的 lambda 表达式返回。 getOrDefault() 如果找不到键，则返回指定的默认值。 filter: 可以使用 filter() 函数来过滤 map 或其他集合。 对 map 使用 filter() 函数时， Pair 将作为参数的谓词传递给它。 它将使用谓词同时过滤其中的键和值。 123val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)val filteredMap = numbersMap.filter &#123; (key, value) -&gt; key.endsWith(\"1\") &amp;&amp; value &gt; 10&#125;println(filteredMap) put()添加新的kv putAll()要一次添加多个条目，请使用 putAll() 。它的参数可以是 Map 或一组 Pair ： Iterable 、 Sequence或 Array 。 123val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)numbersMap.putAll(setOf(\"four\" to 4, \"five\" to 5))println(numbersMap) remove: 要从可变 Map 中删除条目，请使用 remove() 函数。 调用 remove() 时，可以传递键或整个键值对。 如果同时指定键和值，则仅当键值都匹配时，才会删除此的元素。 12345val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)numbersMap.remove(\"one\")println(numbersMap)numbersMap.remove(\"three\", 4) //不会删除任何条目println(numbersMap) plus 与 minus 操作 由于需要访问元素的键，plus（+）与 minus（-）运算符对 map 的作用与其他集合不同。 plus 返回包含两个操作数元素的 Map ：左侧的 Map 与右侧的 Pair 或另一个 Map 。 当右侧操作数中有左侧 Map 中已存在的键时，该条目将使用右侧的值（覆盖）。 1234val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)println(numbersMap + Pair(\"four\", 4))println(numbersMap + Pair(\"one\", 10))println(numbersMap + mapOf(\"five\" to 5, \"one\" to 11)) minus 将根据左侧 Map 条目创建一个新 Map ，右侧操作数带有键的条目将被剔除。 因此，右侧操作数可以是单个键或键的集合： list 、 set 等。 123val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)println(numbersMap - \"one\")println(numbersMap - listOf(\"two\", \"four\")) containsKey, containsValue isNotEmpty sort map:根据键或者值排序 1234567val mmp = mapOf(1 to \"aone\", 3 to \"three\", 2 to \"two\", 4 to \"four\")val sortedMap: SortedMap&lt;Int, String&gt; = mmp.toSortedMap(Comparator &#123; o1, o2 -&gt; println(\"o1=$o1,o2=$o2\") if (o1 &gt; o2) 1 else if (o1 &lt; o2) -1 else 0&#125;) println(sortedMap) // &#123;1=aone, 2=two, 3=three, 4=four&#125; ⭐️Convert Map to List 12345678val keyList = ArrayList(mmp.keys)val valueList = ArrayList(mmp.values)println(\"Key List: $keyList\") // Key List: [1, 3, 2, 4]println(\"Value List: $valueList\") // Value List: [aone, three, two, four]val list = mmp.toList().map &#123; \"$&#123;it.first&#125;_$&#123;it.second&#125;\" &#125;println(\"list=$list\") // list=[1_aone, 3_three, 2_two, 4_four] ⭐️Converting a List to Map in Kotlin 12345678910 val user1 = User(\"John\", 18, listOf(\"Hiking\", \"Running\", \"Reading\")) val user2 = User(\"Sara\", 25, listOf(\"Chess\", \"Music\")) val user3 = User(\"Dave\", 34, listOf(\"Games\", \"Programming\")) val myList = listOf(user1, user2, user3) val myMap = myList.map &#123; it.name to it &#125;.toMap() println(myMap) // &#123;John=User(name=John, age=18, hobbit=[Hiking, Running, Reading]), Sara=User(name=Sara, age=25, hobbit=[Chess, Music]), Dave=User(name=Dave, age=34, hobbit=[Games, Programming])&#125; val amap = myList.associateBy &#123; it.age &#125; println(amap) // &#123;18=User(name=John, age=18, hobbit=[Hiking, Running, Reading]), 25=User(name=Sara, age=25, hobbit=[Chess, Music]), 34=User(name=Dave, age=34, hobbit=[Games, Programming])&#125;","categories":[],"tags":[]},{"title":"开发过程中Mysql API记录","slug":"开发过程中Mysql-API记录","date":"2021-12-26T12:52:57.000Z","updated":"2021-12-26T13:27:57.967Z","comments":true,"path":"2021/12/26/开发过程中Mysql-API记录/","link":"","permalink":"https://nymrli.top/2021/12/26/开发过程中Mysql-API记录/","excerpt":"","text":"时间操作 TIME_TO_SEC MySQL TIME_TO_SEC(time) 函数返回将参数 time 转换为秒数的时间值，转换公式为“小时 ×3600+ 分钟 ×60+ 秒”。 12345678910111213mysql&gt; SELECT TIME_TO_SEC(&apos;15:15:15&apos;);+-------------------------+| TIME_TO_SEC(&apos;15:15:15&apos;) |+-------------------------+| 54915 |+-------------------------+1 row in set (0.00 sec)mysql&gt; select TIME_TO_SEC(&quot;2021-02-02 04:04:04&quot;); -- 只会考虑时分秒，不会考虑年月日+-------------------------+| TIME_TO_SEC(&quot;2021-02-02 04:04:04&quot;) |+-------------------------+| 14644 |+-------------------------+ 具体实例： 12SELECT SEC_TO_TIME(TIME_TO_SEC(时间字段)- TIME_TO_SEC(时间字段)%(15*60)) as intervals from tablenamegroup by intervals SEC_TO_TIME 返回将参数 seconds 转换为小时、分钟和秒数的时间值。 1234567mysql&gt; SELECT SEC_TO_TIME(&apos;54925&apos;);+----------------------+| SEC_TO_TIME(&apos;54925&apos;) |+----------------------+| 15:15:25 |+----------------------+1 row in set (0.00 sec) DATE_FORMAT 用于以不同的格式显示日期/时间数据: DATE_FORMAT(date, format) 123456789DATE_FORMAT(NOW(),&apos;%b %d %Y %h:%i %p&apos;)DATE_FORMAT(NOW(),&apos;%m-%d-%Y&apos;)DATE_FORMAT(NOW(),&apos;%d %b %y&apos;)DATE_FORMAT(NOW(),&apos;%d %b %Y %T:%f&apos;)Dec 29 2008 11:45 PM12-29-200829 Dec 0829 Dec 2008 16:25:46.635","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://nymrli.top/tags/Mysql/"},{"name":"开发记录","slug":"开发记录","permalink":"https://nymrli.top/tags/开发记录/"}]},{"title":"Python科学计算常用API记录","slug":"Python科学计算常用API记录","date":"2021-12-26T09:44:24.000Z","updated":"2021-12-28T11:57:10.265Z","comments":true,"path":"2021/12/26/Python科学计算常用API记录/","link":"","permalink":"https://nymrli.top/2021/12/26/Python科学计算常用API记录/","excerpt":"","text":"pandas to_numeric：类别离散化 参数 描述 arg scalar, list, tuple, 1-d array, or Series errors {‘ignore’, ‘raise’, ‘coerce’}, default ‘raise’ downcast {‘integer’, ‘signed’, ‘unsigned’, ‘float’} , default None,指定转换的类型,默认返回float64或int64 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; s = pd.Series(['1.0', '2', -3])&gt;&gt;&gt; pd.to_numeric(s)0 1.01 2.02 -3.0dtype: float64&gt;&gt;&gt; pd.to_numeric(s, downcast='float')0 1.01 2.02 -3.0dtype: float32&gt;&gt;&gt; pd.to_numeric(s, downcast='signed')0 11 22 -3dtype: int8&gt;&gt;&gt; s = pd.Series(['apple', '1.0', '2', -3])&gt;&gt;&gt; pd.to_numeric(s, errors='ignore')0 apple1 1.02 23 -3dtype: object&gt;&gt;&gt; pd.to_numeric(s, errors='coerce')0 NaN1 1.02 2.03 -3.0dtype: float64 总结： errors一般采用&quot;ignore&quot;或者&quot;coerce&quot;；downcast按照需求来填写 缺失值(空值)处理 相关函数 df.dropna() df.fillna() df.isnull() df.isna() 相关概念 空值：在pandas中的空值是&quot;&quot; 缺失值：在dataframe中为nan或者naT（缺失时间），在series中为none或者nan即可 dropna删除缺失数据 DataFrame.dropna(axis=0, how='any', thresh=None, subset=None, inplace=False), 函数作用：删除含有空值的行或列 how:&quot;all&quot;表示这一行或列中的元素全部缺失（为nan）才删除这一行或列，&quot;any&quot;表示这一行或列中只要有元素缺失，就删除这一行或列 thresh:一行或一列中至少出现了thresh个才删除。 subset：在某些列的子集中选择出现了缺失值的列删除，不在子集中的含有缺失值得列或行不会删除（有axis决定是行还是列） inplace：刷选过缺失值得新数据是存为副本还是直接在原数据上进行修改。 默认参数：删除行，只要有空值就会删除，不替换。 Fillna填充缺失数据 处理Series对象 1234567import pandas as pdfrom numpy import nan as NaNs = [1, NaN, 2, 3, NaN]df = pd.Series(s)df = df.fillna(5)print(df) 处理DataFrame对象 为所有的NaN的位置填充一个确定值 1234567891011121314151617import pandas as pdfrom numpy import nan as NaNdf = pd.DataFrame([[1, NaN, 2, 3, NaN], [1, 2, NaN, 3, NaN]])print(df)print(\"-\"*10)df = df.fillna(5)print(df)\"\"\" 0 1 2 3 40 1 NaN 2.0 3 NaN1 1 2.0 NaN 3 NaN---------- 0 1 2 3 40 1 5.0 2.0 3 5.01 1 2.0 5.0 3 5.0\"\"\" 通过字典为不同的列填充不同的常数 1234567891011121314df = pd.DataFrame([[1, NaN, 2, 3, NaN], [1, 2, NaN, 3, NaN]], columns=[\"1st\", \"2nd\", \"3rd\", \"4th\", \"5th\"])print(df)print(\"-\"*10)df = df.fillna(&#123;\"5th\": 100&#125;)print(df)\"\"\" 1st 2nd 3rd 4th 5th0 1 NaN 2.0 3 NaN1 1 2.0 NaN 3 NaN---------- 1st 2nd 3rd 4th 5th0 1 NaN 2.0 3 100.01 1 2.0 NaN 3 100.0\"\"\" method参数：改变替代值的方式，当为’ffill’，表示用前面的值填充，当’bfill’表示用后面的值填充。 1234567891011121314151617181920212223242526272829df = pd.DataFrame([[1, NaN, 2, 3, NaN], [1, 2, NaN, 3, NaN]], columns=[\"1st\", \"2nd\", \"3rd\", \"4th\", \"5th\"])print(df)print(\"-\"*10)df = df.fillna(method=\"ffill\") # bfillprint(df)\"\"\" 1st 2nd 3rd 4th 5th0 1 NaN 2.0 3 NaN1 1 2.0 NaN 3 NaN---------- 1st 2nd 3rd 4th 5th0 1 NaN 2.0 3 NaN1 1 2.0 2.0 3 NaN\"\"\"df = pd.DataFrame([[1, NaN, 2, 3, NaN], [1, 2, NaN, 3, NaN]], columns=[\"1st\", \"2nd\", \"3rd\", \"4th\", \"5th\"])print(df)print(\"-\"*10)df = df.fillna(method=\"bfill\") # bfillprint(df)\"\"\" 1st 2nd 3rd 4th 5th0 1 NaN 2.0 3 NaN1 1 2.0 NaN 3 NaN---------- 1st 2nd 3rd 4th 5th0 1 2.0 2.0 3 NaN1 1 2.0 NaN 3 NaN\"\"\" 参数： method：FillnaOptions，ffill/forwardfill:用缺失值前面的一个值代替缺失值；bfill/backfill，缺失值后面的一个值代替前面的缺失值。注意这个参数不能与value同时出现（value:需要用什么值去填充缺失值） axis：参数默认为0，即沿着行填充，为1则沿着列填充 limit：传入limit限制填充个数 inplace：传入inplace参数:是否在原来的数据上操作，默认为False，表示重新拷贝了一份数据，然后在拷贝的数据上操作。 DateFrame操作 添加行 **添加一行：**采用loc[]方法 123456# 构造一个空的dataframeimport pandas as pddf = pd.DataFrame(columns=['name','number'])# 采用.loc的方法进行df.loc[0]=['cat', 3] # 其中loc[]中需要加入的是插入地方dataframe的索引，默认是整数型# 也可采用诸如df.loc['a'] = ['123',30]的形式 添加多行==&gt;(合并另一个dateframe)： 1234567891011# 1. 采用append方法合并两个dataframe# 构造两个dataframedf = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB'))df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB'))# 合并 ignore_index设置为 True可以重新排列索引df.append(df2, ignore_index=True) A B0 1 21 3 42 5 63 7 8 添加列 采用df[]方法直接在列上操作 12345678910111213141516# 新建一个dataframedf = pd.DataFrame(columns=['name','number'], data=[['cat',3]])\"\"\"df name number0 cat 3\"\"\"# 添加一列，计算有多少条腿df['leg'] = df['number'] * 4# 添加一列，直接赋值有几个头df['head'] = 1\"\"\"df name number leg head0 cat 3 12 1\"\"\" 采用insert()方法(过时deprecated) 123456# 使用方法是DataFrame.insert(loc, column, value, allow_duplicates=False)# 即df.insert(添加列位置索引序号，添加列名，数值，是否允许列名重复)df.insert(1, 'tail', 1, allow_duplicates=False)df name tail number leg head0 cat 1 3 12 1 合并多个DataFrame https://blog.csdn.net/milton2017/article/details/54406482/ 获得满足条件的行或者列 123456# 获取DataFrame中numTest列的值大于2的行内容arr1 = arr[arr['numTest']&gt;2]print(arr1)# 获取哪几行符合条件，也就是获取符合条件的行的索引值result = arr[arr['numTest']&gt;2].index.tolist()print(result) 直接筛选 直接使用列需要满足的条件，如果需要多个列同时满足条件，使用’&amp;‘符号连接即可；如果只需要某一列满足条件，则使用’|'连接多个列的条件。 12345678some = all_data[(all_data['User_id'] == 1439408) &amp; (all_data['Date'].isna())]print(some)# 得到了User_id=1439408和Date为空的数据项 User_id Merchant_id Coupon_id Discount_rate Distance Date_received Date1 1439408 4663 11002.0 150:20 1.0 20160528.0 NaN2 1439408 2632 8591.0 20:1 0.0 20160217.0 NaN3 1439408 2632 1078.0 20:1 0.0 20160319.0 NaN4 1439408 2632 8591.0 20:1 0.0 20160613.0 NaN 基于map筛选 1234567891011user_requried = all_data['User_id'].map(lambda x : x==1439408)date_requried = all_data['Date'].map(lambda x : np.isnan(x))some = all_data[user_requried &amp; date_requried]print(some) # 结果：其中map返回的值必须是bool类型，即某一个条件。然后使用直接筛选的方式，把条件合并，最终得出筛选的结果。我认为使用此种类型的方法更加的优美。 User_id Merchant_id Coupon_id Discount_rate Distance Date_received Date1 1439408 4663 11002.0 150:20 1.0 20160528.0 NaN2 1439408 2632 8591.0 20:1 0.0 20160217.0 NaN3 1439408 2632 1078.0 20:1 0.0 20160319.0 NaN4 1439408 2632 8591.0 20:1 0.0 20160613.0 NaN 基于query方法筛选 直接写表达式，得出想要筛选的结果。 123some = all_data.query('(User_id == 1439408)')print(some)#结果：直接写表达式容易触发一些不必要的问题（值的类型容易出错，一些特殊值的表达困难等），所以并不建议使用这样的方法。 总结： 确定一个条件–&gt; df[‘money’]&gt;10000) 确定满足条件的行–&gt; df[(df[‘money’]&gt;10000)] 确定这些行的index–&gt; df[(df[‘money’]&gt;10000)].index.tolist()， 返回的是一个list 选取指定列展示 12#选取指定的列, 中间写的是条件， 类比 df = df[ df[\"sale\"] &gt; 50 ]df = df[ [\"sku\",\"ebayno\",\"sale\"] ] Jieba 文本类的数据分析，一般都是分词+词云展示 1234567import jiebadata = pd.read_csv(data_path)all_content = ''for i in range(0, len(data['评论标题'])):all_content = all_content + data['评论标题'][i]cut_text = \" \".join(jieba.cut(all_content)) WordCloud 将数据保存后就要进行可视化展示，一般文本类的都会采用词云 12345678910111213from wordcloud import WordCloudwordcloud = WordCloud(font_path=ciyunfont_path, mask=background_image, background_color='white').generate(cut_text)plt.figure(figsize=(8, 8))if not os.path.exists(result_path): os.makedirs(result_path)# 保存生成图片plt.savefig(f'&#123;result_path&#125;/ciyun.png')# 指定词云图为待显示的图片plt.imshow(wordcloud, interpolation=\"bilinear\")plt.axis(\"off\")# 显示图片plt.show()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Python中关于图片的操作","slug":"Python中关于图片的读取","date":"2021-12-26T08:16:29.000Z","updated":"2021-12-26T08:32:11.523Z","comments":true,"path":"2021/12/26/Python中关于图片的读取/","link":"","permalink":"https://nymrli.top/2021/12/26/Python中关于图片的读取/","excerpt":"","text":"写代码的时候一直记错库下对应的图片操作函数名以及他们的返回值类型，干脆写个笔记记录下。 图片读取相关的包： matplotlib PIL/ cv2 numpy 读取 matplotlib.pyplot / pylab 12345678import pylab as plt# from matplotlib import pyplot as pltimport numpy as npimg = plt.imread('examples.png')print(type(img), img.dtype, np.min(img), np.max(img))[out](&lt;type 'numpy.ndarray'&gt;, dtype('float32'), 0.0, 1.0) # matplotlib读取进来的图片是float，0-1 注：pylab和pyplot区别：前者将numpy、以及各个功能函数导入了其命名空间中。这样会使pylab表现的和matlab更加相似。现在来说我们经常使用pyplot，因为pyplot相比pylab更加纯粹。 PIL.image.open 12345678910from PIL import Imageimport numpy as npimg = Image.open('examples.png')print(type(img), np.min(img), np.max(img))img = np.array(img) # 将PIL格式图片转为numpy格式print(type(img), img.dtype, np.min(img), np.max(img))[out](&lt;class 'PIL.PngImagePlugin.PngImageFile'&gt;, 0, 255) # 注意，PIL是有自己的数据结构的，但是可以转换成numpy数组(&lt;type 'numpy.ndarray'&gt;, dtype('uint8'), 0, 255) # 和用matplotlib读取不同，PIL和matlab相同，读进来图片和其存储在硬盘的样子是一样的，uint8，0-255 PIL读取的结果是Image格式的，需要再额外转换成np.array的形式 cv2.imread 123456789101112import cv2import numpy as npimg = cv2.imread('examples.png') # 默认是读入为彩色图，即使原图是灰度图也会复制成三个相同的通道变成彩色图img_gray = cv2.imread('examples.png', 0) # 第二个参数为0的时候读入为灰度图，即使原图是彩色图也会转成灰度图print(type(img), img.dtype, np.min(img), np.max(img))print(img.shape)print(img_gray.shape)[out](&lt;type 'numpy.ndarray'&gt;, dtype('uint8'), 0, 255) # opencv读进来的是numpy数组，类型是uint8，0-255(824, 987, 3) # 彩色图3通道(824, 987) # 灰度图单通道 注意，pylab.imread和PIL.Image.open读入的都是RBG顺序，而cv2.imread读入的是BGR顺序，混合使用的时候要特备注意 保存 plt.savefig() savefig()方法用于保存绘制数据后创建的图形。使用此方法可以将创建的图形保存到我们的本地计算机中。 12345678wordcloud = WordCloud(font_path=ciyunfont_path, mask=background_image, background_color='white').generate(cut_text)plt.figure(figsize=(8, 8))if not os.path.exists(result_path): os.makedirs(result_path) # 保存生成图片 plt.savefig(f'&#123;result_path&#125;/ciyun.png') # 指定词云图为待显示的图片 plt.imshow(wordcloud, interpolation=\"bilinear\") 注意， 使用savefig的话得注意与plt.show()的位置，如果先plt.show()了则保存的是空白图片。 PIL.image - 保存PIL格式的图片 12345from PIL import Imageimg = Image.open('examples.png')img.save('examples2.png')img_gray = img.convert('L')img_gray.save('examples_gray.png') # 不管是灰度还是彩色，直接用save函数保存就可以，但注意，只有PIL格式的图片能够用save函数 cv2.imwrite 12345import cv2img = cv2.imread('examples.png') # 这是BGR图片cv2.imwrite('examples2.png', img) # 这里也应该用BGR图片保存，这里要非常注意，因为用pylab或PIL读入的图片都是RGB的，如果要用opencv存图片就必须做一个转换img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)cv2.imwrite('examples_gray.png', img_gray) 灰度图-RGB图相互转换 1 PIL.Image 123456789101112from PIL import Imageimg = Image.open('examples.png')img_gray = img.convert('L') # RGB转换成灰度图像img_rgb = img_gray.convert('RGB') # 灰度转RGBprint(img)print(img_gray)print(img_rgb)[out]&lt;PIL.PngImagePlugin.PngImageFile image mode=RGB size=987x824 at 0x7FC2CCAE04D0&gt;&lt;PIL.Image.Image image mode=L size=987x824 at 0x7FC2CCAE0990&gt;&lt;PIL.Image.Image image mode=RGB size=987x824 at 0x7FC2CCAE0250&gt; 2 cv2（注意，opencv在读入图片的时候就可以通过参数实现颜色通道的转换，下面是用别的方式实现） 123456import cv2import pylab as pltimg = cv2.imread('examples.png')img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # BGR转灰度img_bgr = cv2.cvtColor(img_gray, cv2.COLOR_GRAY2BGR) # 灰度转BRGimg_rgb = cv2.cvtColor(img_gray, cv2.COLOR_GRAY2RGB) # 也可以灰度转RGB from: numpy、cv2等操作图片基本操作","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Unity游戏开发学习","slug":"Unity游戏开发学习","date":"2021-12-16T08:23:47.000Z","updated":"2021-12-25T09:43:21.309Z","comments":true,"path":"2021/12/16/Unity游戏开发学习/","link":"","permalink":"https://nymrli.top/2021/12/16/Unity游戏开发学习/","excerpt":"","text":"组件 RigidBody 刚体，会给物体增加重力 spring joint： 弹簧关节，可以连接两个刚体，使得两个物体能够像弹簧一样运动。 Box Collision 增加碰撞检测 图片渲染器 Sprite精灵，游戏开发中指一张图片 Sprite Render 图片渲染器，是用来渲染图片的组件 1234567891011// 随机生成怪物头像void createMonster()&#123; float x = Random.Range(-2, 2); float y = 5; GameObject monster = Instantiate(MonsterPrefab); monster.transform.position = new Vector3(x, y, 0); int index = Random.Range(0, images.Length); SpriteRender render = monster.GetComponent&lt;SpriteRender&gt;(); render.sprite = this.images[index]&#125; 所以图片对象其实是, Empty Gameobject+Sprite Render组件构成的 注：UI下的Image不是Sprite API： Transform Translate() 根据 translation 的方向和距离移动变换。如果 relativeTo 被省略或设置为 Space.Self，则会相对于变换的本地轴来应用该移动。（在场景视图中选择对象时显示的 X、Y 和 Z 轴。） 如果 relativeTo 为 Space.World，则相对于世界坐标系应用该移动。 Rotate 使用 Transform.Rotate 以各种方式旋转 GameObjects。通常以欧拉角而不是四元数提供旋转。 获得键鼠操作 获取鼠标： 1234Input.GetMouseButton(int)int = 0时，获取鼠标左键int = 1时，获取鼠标右键int = 2时，获取鼠标中键 获取方向键盘： 1234Input.Getkey(KeyCode.UPArrow) 上键Input.GetKey(KeyCode.DownArrow) 下键Input.GetKey(KeyCode.LeftArrow) 左键Input.GetKey(KeyCode.RightArrow) 右键 获得对象上的组件 每个组件上都有transform组件，因此在scripts脚本中可以通过transform.position和transform.rotation来获得位置和朝向。 获得对象下的刚体组件： Rigidbody rd = bullet.GetComponent&lt;Rigidbody&gt;(); 镜头跟随——移动摄像头位置 Camera.main.transform.position = Vector3.Lerp( Camera.main.transform.position, new Vector3(Mathf.Clamp(posX, 0, 15), Camera.main.transform.position.y, Camera.main.transform.position.y,), smooth* Time.deltaTime) 注：被挂载的脚本也算个组件，其名称为脚本名称，如下GetComponent&lt;Bird&gt;的Bird为挂载的Bird.cs脚本 1collision.transform.GetComponent&lt;Bird&gt;().Hurt(); 获得脚本挂载的对象以及上级对象 123456789// 在脚本中transform为脚本挂载对象的transform组件transform// 如果要获得 脚本挂载对象 的上级对象的transform（如果有的话）transform.parenttransform.root // 如果要进一步获得gameObject的话，通过 transform.parent.gameObject来获得// 获得父级对象后进一步transform.parent.getComponent&lt;Text&gt;() 有获得父对象就有获得子对象 123for (int i = 0; i &lt; transform.childCount; i ++ )&#123; transform.GetChild(i).GetComponent&lt;Collider2D&gt;().enabled = false;&#125; 脚本获得对象： public Text TimeText将对象通过public暴露，然后手动拖拽指定 private Text TimeText指定为private，然后Aware()中TimeText = GameObject.Find(&quot;TimeText&quot;).GetComponent&lt;Text&gt;(); 1.无法查找隐藏对象 隐藏对象包括查找路径的任何一个父节点隐藏(active=false) ▲：解决方案，可以先让它设置为active=true，然后在start中找到后设置为active=false，再在用的时候设置为true 2.如果查找不在最上层，建议合理使用路径查找，路径查找是把双刃剑 **优点1:**解决查找中可能出现的重名问题。 **优点2:**如果有完全的路径，减少查找范围，减少查找时间。 注：与GameObject.Find相似的api还有GameObject.FindWithTag Transform.Find 1.可以查找隐藏对象 2.支持路径查找 3.查找隐藏对象的前提是transform所在的根节点必须可见，即active=true 实际开发中会将功能预制体放到一个可见的GameObject目录下，将这个GameObject目录作为查找根节点，下面的所有对象(隐藏、非隐藏）都可以查找到。 SetActive和enable区别 相同点： gameObject.SetActive函数控制的是上图复选框1是否勾选，不勾选，那么隐藏，勾选即显示； enabled属性控制的是复选框2是否勾选，显隐规则同上； 不同点： SetActive是针对元素对象gameObject的；enabled是针对gameObject下的某个component的 如果UI的复选框1默认不勾选, 无论复选框2是否勾选, 那么当UI显示时, MyImage.cs的所有函数都不会执行, 这就说明没有加载此脚本到内存; 如果UI的复选框1默认勾选，复选框2默认不勾选，那么当UI显示时, MyImage.cs的Awake函数会执行，其他函数均不会执行，这就说明此脚本会加载到内存中, 除了执行Awake函数外，其他函数均不执行. 123456789101112131415// enable// 通过拖拉加入public List&lt;Bird&gt; birds;birds[i].enabled = true;birds[i].sp.enabled = true;// 这边是Image UIpublic GameObject win;public GameObject lose;//输了lose.SetActive(true);win.SetActive(true);// UI ==&gt; canvas下的UI其实也是GameObjectbutton.SetActive(false); 本地持久化保存与读取的类 PlayerPrefs: 工作原理非常简单，以键值对的形式将数据保存在文件中，然后程序可以根据这个名称取出上次保存的数值。 Playerprefs静态方法 SetFloat()，SetInt()，SetString()` 写入数据 GetFloat()，GetInt()，GetString() 读取数据 DeleteKey()，DeleteAll() 删除数据 HasKey(&quot;SS&quot;) 检查数据,是否有该键 Save() 创建和销毁prefab对象 12345678910111213// 通过预制体来动态创建实例对象, Instantiate参数有很多, 具体见api文档GameObject bullet = Instantiate(myPrefab)GameObject go = Instantiate(score, transform.position + new Vector3(0,0.5f,0), Quaternion.identity);bullet.transform.position = transform.position + new Vector3(0, 1f, 0)// 销毁预制体 ==&gt; 绑定在子弹prefab上的脚本transform.Translate(0, step, 0, Space.Self)Vector3 sp = Camera.main.WorldToScreen(transform.position)if (sp.y &gt; Screen.height)&#123; Destroy(this.gameObject, 1.5f) // 延时1.5s后 // 即GameObject.Destroy&#125; 场景切换 Unity游戏开发中，单个Scene解决所有问题似乎不可能，那么多个Scene之间的切换是必然存在。如果仅仅是切换，似乎什么都好说，但是在场景比较大的时候不想让玩家等待加载或者说场景与场景之间想通过一些画面、动画表现出一些让玩家期待的东西，大家就要去认真考虑。这篇文章主要介绍两种增加切换中如何播放画面或者动画等等，提高玩家的浸入感，当然你也可以做成无缝的场景。 123456789101112// 异步切换场景// AsyncOperation async = Application.LoadLevelAsync(&quot;MyBigLevel&quot;);// 同步切换// Application.LoadLevel(&quot;Middle&quot;);using UnityEngine.SceneManagement;public void Retry() &#123; Time.timeScale = 1; // 大多数情况下使用的方法 UnityEngine.SceneManagement.SceneManager.LoadScene(2);&#125; 重玩功能：可以通过切换到当前场景来实现，由于切换会把切之前的元素销毁掉，并重新建新的元素，因此相当于重玩 游戏暂停 设置Time.timeScale = 0 将会暂停所有和帧率有关的事情。这些主要是指所有的物理事件和依赖时间的函数、刚体力和速度等，而且FixedUpdate会受到影响，会被暂停（不是Update）,即timeScale =0 时将不会调用FixedUpdate函数了。 （1）Time.timeScale = 0可以暂停游戏，Time.timeScale = 1恢复正常，但这是作用于整个游戏的设置，不单单是当前场景，记得在需要的时候重置回Time.timeScale = 1。当然也可以使用Time.timeScale来做游戏的1倍、2倍整体加速。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void Awake()&#123; // 获得 gameObject自身的动画组件 anim = GetComponent&lt;Animator&gt;();&#125;public void Retry() &#123; Time.timeScale = 1; UnityEngine.SceneManagement.SceneManager.LoadScene(2);&#125;/// &lt;summary&gt;/// 点击了pause按钮/// &lt;/summary&gt;public void Pause()&#123; //1、播放pause动画 anim.SetBool(\"isPause\", true); button.SetActive(false); // ▲ 这边可以看到除了设置动态和Time.timeScale以外还对其他做了修改 if (GameManager._instance.birds.Count &gt; 0) &#123; if (GameManager._instance.birds[0].isReleased == false) &#123; //没有飞出 GameManager._instance.birds[0].canMove = false; &#125; &#125;&#125; /// &lt;summary&gt;/// 点击了继续按钮/// &lt;/summary&gt;public void Resume() &#123; //1、播放resume动画 Time.timeScale = 1; anim.SetBool(\"isPause\", false); if (GameManager._instance.birds.Count &gt; 0) &#123; if (GameManager._instance.birds[0].isReleased == false) &#123; //没有飞出 GameManager._instance.birds[0].canMove = true; &#125; &#125;&#125;public void Home()&#123; Time.timeScale = 1; UnityEngine.SceneManagement.SceneManager.LoadScene(1);&#125; 碰撞检测 碰撞体的编辑 点εEdit collider进行编辑…，规定可碰撞的范围和形状 常见的形状： 方形 Box Collider2D 圆形 Circle collider2D 不规则边缘 Edge Collider2D 胶囊形状 Capsule Collider2D 带有collider组件的对象脚本，将组件的IsTrigger属性勾选上 1234567891011121314// 开始接触 void OnTriggerEnter(Collider collider) &#123; Debug.Log(\"开始接触\"); &#125; // 接触结束 void OnTriggerExit(Collider collider) &#123; Debug.Log(\"接触结束\"); &#125; // 接触持续中 void OnTriggerStay(Collider collider) &#123; Debug.Log(\"接触持续中\"); &#125; 带有collider组件的对象脚本，发生碰撞时会执行如下钩子函数 123456789101112131415// 碰撞开始void OnCollisionEnter(Collision collision) &#123; // 销毁当前游戏物体 Destroy(this.gameObject);&#125; // 碰撞结束void OnCollisionExit(Collision collision) &#123; &#125; // 碰撞持续中void OnCollisionStay(Collision collision) &#123; &#125; 两者的区别在于，将对象collider组件的isTriiger属性勾上后，游戏物体发生接触的时候就不会有碰撞的效果了，而是会直接穿过去，即碰撞逻辑需要我们自己手写了。 【值得注意的是，触发器回调的这三个方法的参数都是Collider类型，表示的就是被碰撞的游戏物体的触发器组件对象。】 1234567// 获得被碰撞物体的namevar name = collision.collider.name;// 获得被碰撞物体的tagvar tag = collision.collider.tag;// 感觉更好记collision.transform.GetComponent&lt;Bird&gt;().Hurt(); Resources.Load动态加载资源 使用这种方式加载资源，首先需要下Asset目录下创建一个名为Resources的文件夹，这个命名是U3D规定的方式，然后把资源文件放进去，Cube放在Resource中的Prebs中，而Sphere放在Resources跟目录下 12345private string cubePath = \"Prebs/MyCubePreb\";private string spherePath = \"MySpherePreb\";Object cubePreb = Resources.Load(cubePath, typeof(GameObject));Object spherePreb = Resources.Load(spherePath, typeof(GameObject)); DontDestroyOnLoad 新场景的负载会破坏所有当前场景对象。调用Object.DontDestroyOnLoad在级别加载期间保存对象。如果目标对象是组件或游戏对象，Unity还将保留Transform的所有子对象。对象.DontDestroyOnLoad不返回值。使用typeof操作符更改参数类型。 建议把需要DontDestroyOnLoad的游戏对象放到一个在游戏逻辑中不会返回的一个场景，比如说放到登录时加载的那个场景，，，或者代码使用一个静态变量做标志，（static bool isHave )是否DontDestroyOnLoad过，若DontDestroyOnLoad就将其赋值为True， 想要找到这个游戏物体的话，搜索Find 是可以找到的，或者使用标签的形式FindGameObjectWithTag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201// 登陆页面的Canvas挂载的必启动文件public class Main : MonoBehaviour &#123; public GameObject ClientSystem; public // Use this for initialization //180,49; void Start () &#123; // 在场景切换的时候不销毁ClientSystem对象 DontDestroyOnLoad(ClientSystem); &#125; // Update is called once per frame void Update () &#123; &#125;&#125;// ClientSystem上挂载的服务器通信脚本using System.Collections;using System.Collections.Generic;using UnityEngine;using System.Net;using System.Net.Sockets;using System.Text;using UnityEngine.UI;using UnityEngine.SceneManagement;using System.Threading;public class Client : MonoBehaviour&#123; public GameObject LoadCavas; public GameObject Ball; public GameObject StartBackGround; public GameObject InputText; float rota = 1.6f; bool isBallRota = false; string HeartBeatMsg = \"Hello\"; string otherNameMsg = \"otherName\"; string HookMsg = \"Hook\"; string ExitMsg = \"exit\"; string SendMsg = \"\"; string RecvMsg = \"\"; const string ip = \"127.0.0.1\"; const int port = 9999; IPEndPoint ipe = new IPEndPoint(IPAddress.Parse(ip), port); Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); private void Start() &#123; LoadCavas.SetActive(false); &#125; private void Update() &#123; //Loading的皮卡丘动画 if (isBallRota &amp;&amp; Ball != null) &#123; Ball.transform.Rotate(Vector3.forward, rota); &#125; //处理收到的消息 if (RecvMsg != \"\") &#123; MsgHandle(); &#125; //用SendMsg保存要发送的消息 SendMsg = GetSendMsg(); &#125; void LoadAnimate(bool Start) &#123; if (Start) &#123; LoadCavas.SetActive(true); isBallRota = true; StartBackGround.GetComponent&lt;Image&gt;().sprite = null; StartBackGround.GetComponent&lt;Image&gt;().color = new Color(0, 0, 0, 0); InputText.GetComponent&lt;InputField&gt;().text = \"Matching....\"; &#125; else &#123; if (LoadCavas != null) &#123; LoadCavas.SetActive(false); isBallRota = false; StartBackGround.GetComponent&lt;Image&gt;().sprite = Resources.Load&lt;Sprite&gt;(\"Button\"); StartBackGround.GetComponent&lt;Image&gt;().color = Color.white; InputText.GetComponent&lt;InputField&gt;().text = PlayerPrefs.GetString(\"UserName\"); &#125; &#125; &#125; public void Link() &#123; LoadAnimate(true); socket.Connect(ipe); name = PlayerPrefs.GetString(\"UserName\"); byte[] nameB = Encoding.ASCII.GetBytes(name); socket.Send(nameB); string recvStr = \"\"; byte[] recvBytes = new byte[1024]; int bytes; bytes = socket.Receive(recvBytes, recvBytes.Length, 0);//从服务器端接受返回信息 recvStr += Encoding.ASCII.GetString(recvBytes, 0, bytes); Debug.Log(\"client get message\" + recvStr); Thread thread = new Thread(Communicate); thread.Start(); &#125; private void OnApplicationQuit() &#123; if (socket.Connected) &#123; socket.Send(Encoding.ASCII.GetBytes(ExitMsg)); byte[] recvBytes = new byte[1024]; int bytes; bytes = socket.Receive(recvBytes, recvBytes.Length, 0); socket.Close(); &#125; &#125; private void Communicate() &#123; while (socket.Connected) &#123; byte[] heartBeatStrB = Encoding.ASCII.GetBytes(SendMsg); socket.Send(heartBeatStrB); string recvStr = \"\"; byte[] recvBytes = new byte[1024]; int bytes; bytes = socket.Receive(recvBytes, recvBytes.Length, 0);//从服务器端接受返回信息 recvStr += Encoding.ASCII.GetString(recvBytes, 0, bytes); RecvMsg = recvStr; Thread.Sleep(100); &#125; &#125; void MsgHandle() &#123; //先重置收到的消息 string msg = RecvMsg; RecvMsg = \"\"; if (msg.StartsWith(otherNameMsg)) &#123; LoadAnimate(false); Variable.OtherName = msg.Remove(otherNameMsg.Length); &#125; else if (msg == HookMsg) &#123; Variable.isOtherHookDown = true; &#125; else if (msg == \"Left\") &#123; isBallRota = false; Variable.isSelfLeft = true; SceneManager.LoadScene(\"Game\"); &#125; else if (msg == \"Right\") &#123; isBallRota = false; Variable.isSelfLeft = false; SceneManager.LoadScene(\"Game\"); &#125; else if (msg == \"exit\") &#123; SceneManager.LoadScene(\"Main\"); LoadAnimate(false); InputText.GetComponent&lt;InputField&gt;().text = \"Mathing Failed QAQ\"; &#125; &#125; string GetSendMsg() &#123; string msg = HeartBeatMsg; if (Variable.isExit) &#123; msg = ExitMsg; Variable.isExit = false; &#125; else &#123; if (Variable.isSelfHookDown) &#123; msg = HookMsg; Variable.isSelfHookDown = false; &#125; &#125; return msg; &#125;&#125; 问题： Unity：You must exit play mode to save the scene A: 出现上述错误时，通常是处于游戏模式也就是play mode的状态下进行保存操作，此时无法完成保存指令。 点击运行后，需要等待几秒才能正式进入Play Mode，进入后可以看到Run按钮变蓝，要退出的话不是点击Pause，而是再次点击变蓝的Run按钮（Pause是暂停） 可以加深Play Mode的观感——Unity小技巧——编辑模式Play Mode指定颜色，我是选择了加深灰色，使得有沉浸感的体验。 Visual Studio没有Unity的代码提示——unity脚本在vs2019中打开没有智能提示完美解决方案，将VS加上“使用Unity游戏开发”的选项即可。 渲染顺序： 简单总结一下， 决定Sprite render的渲染关系的层级顺序是： Camera： 不同的Camera的Depth sorting layer： 相同Camera下的不同SortingLayer sortingorder： 相同SortingLayer下的不同Z轴/Order in Layer 改变控件之间的层级关系 (1)同一canvas下： 改变控件transform的SiblingIndex, transform.GetSiblingIndex(); transform.SetSiblingIndex(int index); //index值越大，越后渲染，层级越大，越显示在前面 (2)不同Canvas下： 设置Canvas下的Sort Order //Sort Order值越大，越后渲染，层级越大，越显示在前面 Unity3D的UGUI—Canvas的渲染顺序及层次关系总结 Unity渲染顺序总结 学习参考视频: B站，Unity2021入门教程_游戏开发100集课程(含建模)——间接明了的demo展示，内含飞机大战 案例学习网站-sikiedu： 基础案例——小球发射 Unity初级案例 - 愤怒的小鸟 Unity初级案例 - 炸弹人 Unreal初级案例 - 3D吃豆人 Unity初级案例 - 贪吃蛇（Unity2017.2.0） 【游戏开发】unity项目案例《黄金矿工》 绳子的state通过gameManager来控制 绳子自己没有trigger，而是写在ore上了，当碰撞时设置ore的parent为rope 官方API文档 免费的素材网站 爱给 千库网","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://nymrli.top/tags/Unity/"}]},{"title":"软件架构课程学习笔记","slug":"软件架构课程学习笔记","date":"2021-12-12T06:44:53.000Z","updated":"2021-12-13T14:51:58.689Z","comments":true,"path":"2021/12/12/软件架构课程学习笔记/","link":"","permalink":"https://nymrli.top/2021/12/12/软件架构课程学习笔记/","excerpt":"","text":"术语 –微服务 –云化 –分布式 –高并发 –高可用 架构角色 探索者 设计师 倡导人 到底如何区分什么是架构、框架、模式和平台 ？ 设计模式&lt;框架&lt;架构&lt;平台，从复用角度讲，设计模式是代码级复用、框架是模块级复用、架构是系统级复用、平台是企业应用级复用。 模式:分为代码模式、设计模式、框架模式这些 设计模式有不同的分类，如下 创建型设计模式，如工厂方法（Factory Method）模式、抽象工厂（Abstract Factory）模式、原型（Prototype）模式、单例（Singleton）模式，建造（Builder）模式等 结构型设计模式，如合成（Composite）模式、装饰（Decorator）模式等 框架：也有叫构架的，一般等同于ＭＶＣ、MVP、MVVM这种。 举个栗子，农村要盖房，架构就是：你得考虑自己的经济实力、喜欢什么样的房子、有什么要求，选哪个靠谱的施工队。选好了之后，比如说要盖楼房，那么框架就是施工队的模式，有的施工队先这样做再那样做，而有的却相反，反正能把楼给你盖起来就行。模式就是局部的具体实现，比如说门这样安、窗户这样。 目标 达到最佳的功能和服务表现 资源利用率 灵活的开发、部署、运行、维护和创新 安全性、稳定性、可靠性等质量属性 影响结构的因素 利益相关者 开发团队 架构师 环境其他因素，比如冲突，隐性需求 Typical Design Trade-offs 功能和可用性 性能和可修改性 成本与鲁棒性效率和可移植性 快速开发vs.功能性 成本与可重用性 向后兼容性与可读性 架构：做一个基准让软件能够不断完善。架构本身在做的事情就是衔接软件从无序的需求变成有组织、有序的软件设计实现的中间转换环节。==&gt;注意架构的很多关注点都是来自于架构本身驱动的因素和非功能性的点（architectural driver）：性能、使用中的高可用、 质量属性： 易用性高——一个中等业务水平的储蓄所人员能够在5个工作日内熟练掌握本系统80%功能 问题？可修改性和性能，是否可以可以同时满足？ A: 这两个很容易冲突 近几年的毕业论文——把功能实现了，但非功能性需求就只是列了几个点。非功能性需求反应了这个系统关注的哪些指标点。同时要考虑非功能性需求之间的优先级，要体现了哪个目标是高的，是低的。这种优先级的， 单点–&gt;分布式==》集群化的，集群化服务的一些点就慢慢会形成一个高可用的架构，比如主备、热备、温备、冷备，还有一些通过集群化的方式来实现的高可用，比如多活、两地三总线。 多实例化应用：提高冗余数据虽然提高了可用性但是增加了安全性的影响、应用层管理实现方式：统一身份认证（统一的认证中心，避免了每个点的认证），权限层、认证层、网关层 组件间信息通信来探活，保证组件的可用性 性能： 优先级调度，有优先能执行 有足够的资源 安全 拦截请求 加密、认证 大型商业银行的主要特征： 24小时不间断的高效核心银行系统 跨渠道、跨业务线、跨区域的集成服务能力 集团一体化架构模式下的差异化、个性化支持能力 每一层都有不同的关注点，每一个关注点都有各自的解决方案，比如接入层有高并发的需求，业务处理层有安全可靠的去求。将关注点分层以后。 优势：每一个层能看地更清晰，并且更好地关注自身地处理方式。 劣势：层次层次交互过程中地trade-off问题 从quality地角度考虑，分布式是在解决高并发的访问，实现系统更好的应用性与交互性 核心银行系统的非功能性需求 规模 性能 安全性 可用性和弹性 运维管理 用户接入平台技术架构 所有接入的模块都不止一个，不管是tcp、http、还是身份认证的还是可视化管理的，都是通过增加多个实例来实现高可用。==&gt;主备、多活 应用平台-&gt;应用系统-&gt;系统进程-&gt;技术模块 关键技术组件模块： 数据访问接口 后台进程运行模型 容错平台架构 数据可视化 公共服务框架 监控管理 统一的数据格式 监控数据定义 统一展示 日志管理 时间管理 撮合应用框架 行情处理应用框架 交易控制架构 大型网站系统特点 高并发，大流量 高可用 用户分布广泛 需求快速变更 发布频繁 海量数据 安全环境恶劣 渐进式发展","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"Zju","slug":"Zju","permalink":"https://nymrli.top/tags/Zju/"}]},{"title":"创建Vue工程（包含Vue2和Vue3）","slug":"创建Vue工程（包含Vue2和Vue3）","date":"2021-12-08T08:28:19.000Z","updated":"2021-12-08T08:28:51.443Z","comments":true,"path":"2021/12/08/创建Vue工程（包含Vue2和Vue3）/","link":"","permalink":"https://nymrli.top/2021/12/08/创建Vue工程（包含Vue2和Vue3）/","excerpt":"","text":"@vue/cli-init vue init 是vue-cli2.x的初始化方式 vue init ： 需要npm i -g @vue/cli-init vue init webpack [project-name], webpack为模板&lt;generate a project from a remote template&gt;，然后按照交互信息提示输入即可完成工程创建 init创建工程时，交互信息中有一个比较有意思的是选择包管理工具： npm、yarn，两者见 @vue/cli 会让选择Vue2还是Vue3 vue create router_project: 需要npm install -g @vue/cli vue ui通过UI创建： 需要npm install -g @vue/cli vue create [project-name] 注：经测试，Vue CLI v4.5.15会提示选择yarn还是npm；@vue/cli 4.5.13没提示==&gt;后来发现貌似是平台的区别，linux上会提示选择，win上默认是yarn Vue CLI 的包名称由vue-cli已经改成了@vue/cli，如果通过vue-cli来构建Vue3项目则需要通过 npm uninstall vue-cli -g 或 yarn global remove vue-cli 卸载它，然后安装@vue/cli，并且@vue/cli安装好后，如果不安装yarn，那么在vue create创建的时候报错ERROR Error: spawn yarn ENOENT npm init vite-app hello-vue Vue3刚发布不久，官方文档中推荐的创建方法之一就是通过脚手架Vite来创建一个vue3项目 需要安装create-vite-app 123456$ npm init vite-app vue3-vite Scaffolding project in F:\\Documents\\HBuilderProjects\\vue3-vite...Done. Now run:$ cd vue3-vite$ npm install (or `yarn`)$ npm run dev (or `yarn dev`) 可以看到，这个时需要进入项目目录后，里面没有package-lock或者yarn.loca，而是需要自己主动选择包管理工具进行安装依赖的；vue create和vue init的不需要可以直接运行 @vitejs/app npm init @vitejs/app然后选择project的框架 注：2既可以创建Vue2，也可以创建vue3；3只能创建vue3；在创建速度上，法3比法2快上很多","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"https://nymrli.top/tags/Vue/"}]},{"title":"NodeJS包管理工具","slug":"NodeJS包管理工具","date":"2021-12-08T08:25:47.000Z","updated":"2021-12-08T08:27:06.008Z","comments":true,"path":"2021/12/08/NodeJS包管理工具/","link":"","permalink":"https://nymrli.top/2021/12/08/NodeJS包管理工具/","excerpt":"","text":"包管理工具 npm npm install &lt;package_name&gt; --dev npm init然后根据交互信息创建工程 npm install 根据目录下package.json安装依赖 npm run dev执行package.json中定义的scripts.dev指令 yarn yarn add &lt;package_name&gt; --dev yarn init然后根据交互信息创建工程 yarn 根据目录下package.json安装依赖 yarn run dev执行package.json中定义的scripts.dev指令 共同点： 两个在init创建好后，都会生成一个配置文件package.json 安装依赖后都会生成依赖管理文件夹：node_module/ 不同点：安装依赖后，npm生成的依赖管理文件为package-lock.json；yarn的为package.lock npm参数区别 npm install moduleName 命令 安装模块到项目node_modules目录下。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。 npm install -g moduleName 命令 安装模块到全局，不会在项目node_modules目录中保存模块包。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。 npm install --save moduleName 命令 安装模块到项目node_modules目录下。 会将模块依赖写入dependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install --production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。 npm install --save-dev moduleName 命令 安装模块到项目node_modules目录下。 会将模块依赖写入devDependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install --production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。 注： npm install packageName --save、yarn add packageName --dev npm 与 yarn 命令比较： NPM YARN 说明 npm init yarn init 初始化某个项目 npm install / link yarn install/link 默认的安装依赖操作 npm install taco --save yarn add taco 安装某个依赖，并且默认保存到package npm uninstall taco --save yarn remove taco 移除某个依赖项目 npm install taco --save-dev yarn add taco --dev 安装某个开发时依赖项目 npm update taco --save yarn upgrade taco 更新某个依赖项目 npm install taco --global yarn global add taco 安装某个全局依赖项目 npm publish/login/logout yarn publish/login/logout 发布/登录/登出，一系列NPM Registry操作 npm run/test yarn run/test 运行某个命令 Vue中public和assets文件夹 两者都是vue-cli3.0的放置静态资源的目录。 public处于工程根目录下；assets处于根目录src下，即src/assets public放不会改动的文件，这里面的内容可以使引用的，不是由自己编写的内容（即第三方的）。基本不会改动的内容（参考vue-cli2.x中的static） public/ 目录下的文件并不会被Webpack处理，它们会直接被复制到最终的打包目录（默认是dist/static）下，所以必须使用绝对路径引用这些文件。当然这个取决于你vue.config.js中publicPath的配置，默认的是/，（你可以自己去vue.config.js 中修改你的publicPath配置，建议不要修改。） assets放可能会变动的文件（自己的静态文件js、png，自己写的js文件等等可能需要改动的文件） assets目录中的文件会被webpack处理解析为模块依赖，只支持相对路径形式。 nodejs版本管理工具——nvm https://github.com/nvm-sh/nvm#installing-and-updating 123456# Step1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash# orwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash# Step2~/.bashrc 如果下载不下来，可以在windows上用dev-sidecar访问网页，然后ctrl+s保存发给服务器，再./install.sh运行，把仓库clone到~/.nvm下 12345672082 2021-12-08 00:05:30 nvm list2085 2021-12-08 00:06:36 nvm ls-remote# 安装最新的LTS版本Nodejs2086 2021-12-08 00:07:13 nvm install --lts$ node -v$ nvm current$ npm -v [nvm命令及解释](","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"}]},{"title":"Js-ShortCode","slug":"Js-ShortCode","date":"2021-12-07T11:18:50.000Z","updated":"2021-12-07T11:56:46.426Z","comments":true,"path":"2021/12/07/Js-ShortCode/","link":"","permalink":"https://nymrli.top/2021/12/07/Js-ShortCode/","excerpt":"","text":"js判断字符串是否为空 最近写了点前端代码，记录一下常用的shortCode 12345678910111213// 方法一：直接使用条件语句if判断function isEmpty(str) &#123; if(typeof str== null || str== \"\" || str== \"undefined\") &#123; return true; &#125; else &#123; return false; &#125;&#125;// 方法二：根据字符串的length来判断var strings = ''; if (string.length == 0) &#123; alert('不能为空'); &#125; js中和=区别 简单来说： == 代表相同， ===代表严格相同, 为啥这么说呢， 这么理解： 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则自动进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false. 双等号==： 如果两个值类型相同，再进行三个等号(===)的比较 如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较： 如果一个是null，一个是undefined，那么相等 如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较 三等号===: 如果类型不同，就一定不相等 如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断） 如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。 如果两个值都是true，或是false，那么相等 如果两个值都引用同一个对象或是函数，那么相等，否则不相等 如果两个值都是null，或是undefined，那么相等 拷贝 1. 浅拷贝 123456789101112// 法一：将父对象的属性，通过赋值拷贝给子对象。function copy(origin) &#123; let target = &#123;&#125;; for (let i in origin) &#123; target[i] = origin[i]; &#125; return target;&#125;// 法二：Objece.assign(): 方法用于对象的合并，将源对象的所有可枚举属性，复制到新的目标对象。let target = Object.assign(&#123;&#125;, origin);// 法三：扩展运算符: ES2018 中将...扩展运算符引入了对象。于是实现浅拷贝的语法更为简单。let target = &#123; ...origin &#125;; more: 包含[原型属性]一起拷贝: https://zhuanlan.zhihu.com/p/45249918 2.深拷贝 1234567891011121314151617181920212223242526272829303132333435363738// 法一:JSON.parse:这是一种很古老的方法，通过将对象转化为 JSON，再转化为对象来实现拷贝，具体的做法是这样的,这样虽然简单，但有但有两个缺点：一是不支持Function、Date等数据类型；二是不支持循环引用。let target = JSON.parse(JSON.stringify(origin));// 法二: 递归遍历:与浅拷贝的基本相同，也需要通过遍历对象属性。只是在遇到一个 Object属性时，需要再次调用拷贝函数。// 定义一个深拷贝函数 接收目标target参数function deepClone(target) &#123; // 定义一个变量 let result; // 如果当前需要深拷贝的是一个对象的话 if (typeof target === 'object') &#123; // 如果是一个数组的话 if (Array.isArray(target)) &#123; result = []; // 将result赋值为一个数组，并且执行遍历 for (let i in target) &#123; // 递归克隆数组中的每一项 result.push(deepClone(target[i])) &#125; // 判断如果当前的值是null的话；直接赋值为null &#125; else if (target === null) &#123; result = null; // 判断如果当前的值是一个RegExp对象的话，直接赋值 &#125; else if (target.constructor === RegExp) &#123; result = target; &#125; else &#123; // 否则是普通对象，直接for in循环，递归赋值对象的所有值 result = &#123;&#125;; for (let i in target) &#123; result[i] = deepClone(target[i]); &#125; &#125; // 如果不是对象的话，就是基本数据类型，那么直接赋值 &#125; else &#123; result = target; &#125; // 返回最终结果 return result;&#125;// 法三: 结构化拷贝// 法四：Lodash一个实用的第三方 JavaScript 工具库。 嫌自己写方法麻烦的话，就直接去用它的defaultsdeep方法吧。 见： https://zhuanlan.zhihu.com/p/45249918 在forEach循环里头使用splice()遇到的坑 forEach自带索引的增加规则，但是splice后数组的索引都会改变，导致有元素会被跳过，因此需要自定义索引的增加规则 应用如下： 递归去掉Array中obj.hide==true的元素 1234567891011121314151617// 过滤掉routes中hide为true的路由function filterNavs(ary) &#123; let i = 0 while (i &lt; ary.length)&#123; if ( ary[i].children )&#123; filterNavs(ary[i].children) i++ &#125;else if ( typeof(ary[i], Number))&#123; if ( ary[i].hide == true )&#123; ary.splice(i, 1); &#125;else&#123; i ++ &#125; &#125; &#125; return ary&#125; javascript 数组(list)添加/删除的实现 javascript 数组Array（list）添加/删除 unshift：将参数添加到原数组开头，并返回数组的长度 pop：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined push：将参数添加到原数组末尾，并返回数组的长度 concat：用于连接两个或多个数组。不会更改现有数组，而是返回一个新数组，其中包含已连接数组的值。 splice(start,deleteCount,val1,val2,…)：从start位置开始删除deleteCount项，并从该位置起插入val1,val2,…splice() 方法会改变原始数组。==&gt;more: http://c.biancheng.net/view/5668.html reverse：将数组反序 sort(orderfunction)：按指定的参数对数组进行排序 slice(start,end)：返回从原数组中指定开始下标到结束下标之间的项组成的新数组 6、数组的拷贝 12arrayObj.slice(0); //返回数组的拷贝数组，注意是一个新的数组，不是指向arrayObj.concat(); //返回数组的拷贝数组，注意是一个新的数组，不是指向 7、数组元素的排序 12arrayObj.reverse(); //反转元素（最前的排到最后、最后的排到最前），返回数组地址arrayObj.sort(); //对数组元素排序，返回数组地址 8、数组元素的字符串化 1arrayObj.join(separator); //返回字符串，这个字符串将数组的每一个元素值连接在一起，中间用 separator 隔开。 from: https://www.jb51.net/article/202307.htm 12345678910111213// Splice示例: // 添加: 如果不执行删除操作，第 2 个参数值应该设置为 0，但是不能够空缺，否则该方法无效。 const months = ['Jan', 'March', 'April', 'June'];months.splice(1, 0, 'Feb');// inserts at index 1console.log(months);// expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"June\"] // 边删除边添加: splice() 方法的删除和插入操作是同时进行的，且是在原数组基础上执行操作。months.splice(4, 1, 'May');// replaces 1 element at index 4console.log(months);// expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"May\"] from：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice JS删除对象中的某一属性 123456var obj=&#123; name: 'zhagnsan', age: 19 &#125;delete obj.name //truetypeof obj.name //undefined 数组中使用delete 在数组中，与普通的旧对象不同，使用delete在表单中留下垃圾，null在数组中创建一个“洞”, 而且length不变 12345var array = [1, 2, 3, 4];delete array[2];/* Expected result --&gt; [1, 2, 4] * Actual result --&gt; [1, 2, null, 4] */ js遍历对象的几种方法 12345678910111213141516171819202122232425262728293031// 第一种： for......inconst obj = &#123; id:1, name:'zhangsan', age:18&#125; for(let key in obj)&#123; console.log(key + '---' + obj[key]) &#125;/**第二种：1）、Object.keys（obj）2）、Object.values（obj）*/console.log(Object.keys(obj)) // ['id','name','age']console.log(Object.values(obj)) // ['1','zhangsan','18']Object.keys(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;);// 第三种：使用Object.getOwnPropertyNames(obj)/**返回一个数组，包含对象自身的所有属性（包含不可枚举属性）遍历可以获取key和value*/Object.getOwnPropertyNames(obj).forEach(function(key)&#123; console.log(key+ '---'+obj[key])&#125;)// 4、使用Reflect.ownKeys(obj)遍历var obj = &#123;'0':'a','1':'b','2':'c'&#125;;Reflect.ownKeys(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;); javaScript遍历数组总结 123456789101112131415161718// 1、使用forEach遍历var arr=[1,2,3,4];arr.forEach(function(val, index) &#123; console.log(val, index);&#125;);// 2、使用for..in..遍历var arr=[\"张三\",\"李四\",\"王五\",\"赵六\"];for (var i in arr)&#123; console.log(i,\":\",arr[i]);&#125;/**3、使用for-of遍历 不仅支持数组，还支持大多数类数组对象，例如DOM NodeList对象. 也支持字符串遍历，它将字符串视为一系列的Unicode字符来进行遍历.*/for (var value of arr)&#123; console.log(value);&#125; 将对象转成URL-Params 1234567891011121314151617181920212223242526272829const _parse2Params = function(data, isPrefix = false) &#123; let prefix = isPrefix ? '?' : '' let _result = [] for (let key in data) &#123; let value = data[key] // 去掉为空的参数 if (['', undefined, null].includes(value)) &#123; continue &#125; if (value.constructor === Array) &#123; value.forEach(_value =&gt; &#123; _result.push(encodeURIComponent(key) + '[]=' + encodeURIComponent(_value)) &#125;) &#125; else &#123; _result.push(encodeURIComponent(key) + '=' + encodeURIComponent(value)) &#125; &#125; return _result.length ? prefix + _result.join('&amp;') : ''&#125;const combileURLandParams = function(url, params) &#123; if (Object.getOwnPropertyNames(params).length != 0) &#123; return url + \"?\" + _parse2Params(params) &#125; else &#123; return url &#125;&#125; 根据Json数据动态生成表单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;template&gt; &lt;h1&gt;&#123;&#123; $route.params.template &#125;&#125; &lt;/h1&gt; &lt;div class=&quot;form-table-div&quot;&gt; &lt;n-form style=&quot;width: 500px;&quot; :model=&quot;configData.data&quot; :label-width=&quot;120&quot; ref=&quot;formRef&quot;&gt; &lt;!-- config为每一个配置项 --&gt; &lt;template v-for=&quot;(val, key, i) in configData.data&quot; :key=key&gt; &lt;n-form-item size=&apos;large&apos; :label=&quot;key&quot;&gt; &lt;n-input v-model:value=&quot;configData.data[key]&quot; :placeholder=&quot;val&quot; /&gt; &lt;/n-form-item&gt; &lt;/template&gt; &lt;/n-form&gt; &lt;/div&gt; &lt;div style=&quot;display: flex; justify-content: center;&quot;&gt; &lt;n-button round type=&quot;primary&quot; @click=&quot;generate&quot;&gt; 生成 &lt;/n-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; defineComponent, ref, onMounted, reactive, computed &#125; from &apos;vue&apos; import &#123; useRoute &#125; from &quot;vue-router&quot; import &#123; getOption, doGenerte &#125; from &quot;../api/index.js&quot; import &#123; combileURLandParams &#125; from &quot;../utils/index.js&quot; function simplyData(params, str) &#123; const res = &#123;&#125; for (let key in params) &#123; if (!key.includes(str)) &#123; res[key] = params[key] &#125; &#125; return res &#125; export default defineComponent( setup() &#123; const route = useRoute() const template = ref(route.params.template) const formRef = ref(null) const message = useMessage() const configData = reactive(&#123; data: &#123;&#125; &#125;) onMounted( getConfigData() ) async function getConfigData() &#123; let result = await getOption(template.value); if (result.status === 200) &#123; let d = result.data.data if (d.length == 1) &#123; configData.data = simplyData(d[0], &quot;slug&quot;) &#125; &#125; &#125; async function generate() &#123; var a = document.createElement(&apos;a&apos;); let params = &#123; ...configData.data &#125; params.template = template.value var url = combileURLandParams(&quot;http://127.0.0.1:5501/api/v1/generate&quot;, params) a.href = url; a.click(); &#125; return &#123; formRef, configData, generate &#125; &#125; &#125;)&lt;/script&gt; js中的string.format 12345delete(ids) &#123; return Axios(`/bus/cloudRoleTeam/$&#123;ids&#125;`, &#123; method: 'delete' &#125;&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://nymrli.top/tags/js/"}]},{"title":"前后端-实现上传和下载","slug":"前后端-实现上传和下载","date":"2021-12-05T02:56:46.000Z","updated":"2021-12-05T04:06:54.873Z","comments":true,"path":"2021/12/05/前后端-实现上传和下载/","link":"","permalink":"https://nymrli.top/2021/12/05/前后端-实现上传和下载/","excerpt":"","text":"前端 上传 前端上传主要是把文件发送过去，一般采用表单的形式，或者也可以针对上传接口发送请求 表单 123456&lt;form action=\"http://127.0.0.1:5000/\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"toupdate\"/&gt; # file的input不允许设置value &lt;input type=\"submit\" value=\"上传咯\" /&gt; # 按钮显示的文字&lt;/form&gt;# action为表单要提交到的路径, 必须填写，如果省略则默认当前页面 针对接口，发送网络请求 下载 a标签 1234&lt;div&gt; &lt;h2&gt;法一: 通过`a`标签来实现下载 &lt;/h2&gt; &lt;a href=\"http://127.0.0.1:5000/download\"&gt;ss&lt;/a&gt;&lt;/div&gt; 此外，HTML 5 里面为 &lt;a&gt; 标签添加了一个 download 的属性，我们可以轻易的利用它来实现下载重命名的功能。 1234&lt;div&gt; &lt;h2&gt;法一: 通过`a`标签来实现下载 &lt;/h2&gt; &lt;a href=\"http://127.0.0.1:5000/download\" download=\"something.txt\"&gt;ss&lt;/a&gt;&lt;/div&gt; JavaScript 添加a元素并点击 用 JavaScript 来下载文件也是利用这一特性来实现的，我们的 JavaScript 代码不外乎就是： 用 JavaScript 创建一个隐藏的 &lt;a&gt; 标签 设置它的 href 属性 设置它的 download 属性 用 JavaScript 来触发这个它的 click 事件 翻译成 JavaScript 代码就是： 1234567891011methods: &#123; downit()&#123; var a = document.createElement('a'); // 已经知道下载链接 var url = \"http://127.0.0.1:5000/download\" var filename = 'what-you-want.txt'; a.href = url; a.download = filename; a.click(); &#125;&#125; fetch + blob Blob 全称是 Binary large object，它表示一个类文件对象，可以用它来表示一个文件。根据 MDN 上面的说法，File API 也是基于 blob 来实现的。 我们构建 blob 的方式就是通过服务器返回的文件来创建 blob 拉！而最简单的方式就是用 fetch API 了，我们可以整合上面的例子： 123456789fetch('http://somehost/somefile.zip').then(res =&gt; res.blob().then(blob =&gt; &#123; var a = document.createElement('a'); var url = window.URL.createObjectURL(blob); var filename = 'myfile.zip'; a.href = url; a.download = filename; a.click(); window.URL.revokeObjectURL(url);&#125;)) 已知下载接口URL， 并传入相应的参数 12345678910111213141516function downLoad(option)&#123; // 下载接口+请求参数 fetch('http://somehost/download', options).then(res =&gt; &#123; if (res.code === 0) &#123; var a = document.createElement('a'); // 得到请求文件完整的请求路径 var url = res.data.url; var filename = 'myfile.zip'; a.href = url; a.download = filename; // w3c: value: filename——规定被下载的超链接目标。从这边也可以看出其实就是指定文件名 a.click(); &#125; else &#123; alert('You have no permission to download the file!'); &#125; &#125;);&#125; 流程为：通过后端服务器来计算出用户的下载链接，然后再利用之前提到的动态创建 &lt;a&gt; 标签的方式来实现下载 跟: JS实现文件下载的三种方式—a标签下载、form表单下载、blob转换url下载中的一样，也都是先计算出资源所在真实的URL位置，然后再请求 123456789101112131415161718192021function downLoadFile(res)&#123; const ele = document.createElement('a'); ele.setAttribute('href',res.url); //设置下载文件的url地址 ele.setAttribute('download' , 'download');//用于设置下载文件的文件名 ele.click();&#125;window.onload = function()&#123; $.ajax(&#123; url:\"get-file\", type:\"get\", dataType:'JSON' &#125;).then(function(res)&#123; if(res.bizNO &gt; 0 )&#123; downLoadFile(res); &#125;else&#123; alert(res.bizMsg); &#125; &#125;).always(function()&#123; alert(\"连接异常\")； &#125;)&#125; 为什么要用 JavaScript 下载文件 好拉，说了半天，其实我们一直说的都是：「不要用 JavaScript 下载文件拉，限制多多，又不好用，直接用 html 就好拉，简单方便又快捷」这个论调。事实上也确实如此，但有些时候我们确实需要通过 JavaScript 来做一些预处理， 如权限校验。 下载文件前的权限校验 有些时候，我们需要对下载做一些限制，最常见的就是权限校验了，如检查该用户是否有下载的权限，是否有高速下载的权限等等。这时候，我们可以利用 JavaScript 做一些预处理。如： 123456789101112131415161718fetch('http://somehost/check-permission', options).then(res =&gt; &#123; if (res.code === 0) &#123; var a = document.createElement('a'); var url = res.data.url; var filename = 'myfile.zip'; a.href = url; a.download = filename; a.click(); // const ele = document.createElement('a'); // ele.setAttribute('href',res.url); //设置下载文件的url地址 // ele.setAttribute('download' , 'download');//用于设置下载文件的文件名 // ele.click(); &#125; else &#123; alert('You have no permission to download the file!'); &#125;&#125;); 参考： https://blog.csdn.net/weixin_41305441/article/details/85003066 https://segmentfault.com/a/1190000005863250 前端接受后端文件流并下载的几种方法 Python Flask实现上传和下载接口 上传 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import osfrom flask import Flask, request, url_for, send_from_directoryfrom werkzeug.utils import secure_filenamefrom flask import send_from_directory, make_response# 设置上传文件允许种类ALLOWED_EXTENSIONS = &#123;'png', 'jpg', 'jpeg', 'gif'&#125;app = Flask(__name__)# 设置上传路径app.config['UPLOAD_FOLDER'] = os.path.join(os.getcwd(), \"updates\")# 设置上传文件最大大小app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024html = ''' &lt;!DOCTYPE html&gt; &lt;title&gt;Upload File&lt;/title&gt; &lt;h1&gt;Photo Upload&lt;/h1&gt; &lt;form method=post enctype=multipart/form-data&gt; &lt;input type=file name=file&gt; &lt;input type=submit value=upload&gt; &lt;/form&gt; &lt;div&gt; &lt;a href='http://127.0.0.1:5000/download'&gt;&lt;p&gt;下载&lt;/p&gt;&lt;/a&gt; &lt;/div&gt; '''def allowed_file(filename): \"\"\" 是否是允许上传的文件 \"\"\" return '.' in filename and \\ filename.rsplit('.', 1)[1] in ALLOWED_EXTENSIONS@app.route('/uploads/&lt;filename&gt;')def uploaded_file(filename): \"\"\" 获得上传后的链接 \"\"\" return send_from_directory(app.config['UPLOAD_FOLDER'], filename)@app.route('/', methods=['GET', 'POST'])def upload_file(): if request.method == 'POST': file = request.files['file'] # 可以通过requests.files属性拿到multipart/form-data上传的数据 if file and allowed_file(file.filename): filename = secure_filename(file.filename) # 保存文件 file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename)) # 获得保存后的图片链接 file_url = url_for('uploaded_file', filename=filename) print(file_url) return html + '&lt;br&gt;&lt;img src=' + file_url + '&gt;' return html 下载 12345@app.route(\"/download\")def index(): # 可以看到上传代码中也用到了send_from_directory；这边的区别主要是添加了as_attachment参数, 使得可以下载 # return make_response(send_from_directory(\"./\", \"test.txt\", as_attachment=True)) return send_from_directory(\"./\", \"./\", filename=\"test.txt\", as_attachment=True) Java实现上传下载 上传 application.properties 123456# 用来指定服务器端文件大小的限制spring.servlet.multipart.max-file-size=300MB# 用来指定客户端文件大小的限制spring.servlet.multipart.max-request-size=300MBfileLocation=static/files FileUploadController.java 12345678910111213141516// 读取配置文件中的路径 static/files@Value(\"$&#123;fileLocation&#125;\")private String fileLocation;@PostMapping(\"upload\")@ResponseBodypublic void upload(MultipartFile file) throws IOException &#123; // 获得 classpath 的绝对路径 String realPath = ResourceUtils.getURL(\"classpath:\").getPath() + fileLocation; File newFile = new File(realPath); // 如果文件夹不存在、则新建 if (!newFile.exists()) newFile.mkdirs(); // 上传 String fileName = date.getTime() +\"@\" + file.getOriginalFilename(); file.transferTo(new File(newFile, fileName));&#125; 下载 123456789101112131415161718192021@Value(\"$&#123;fileLocation&#125;\")private String fileLocation;@GetMapping(\"download\")public void download(String fileName, HttpServletResponse response) throws IOException &#123; // 获得待下载文件所在文件夹的绝对路径 String realPath = ResourceUtils.getURL(\"classpath:\").getPath() + fileLocation; // 获得文件输入流 FileInputStream inputStream = new FileInputStream(new File(realPath, fileName)); // 设置响应头、以附件形式打开文件 response.setHeader(\"content-disposition\", \"attachment; fileName=\" + fileName); ServletOutputStream outputStream = response.getOutputStream(); int len = 0; byte[] data = new byte[1024]; while ((len = inputStream.read(data)) != -1) &#123; outputStream.write(data, 0, len); &#125; outputStream.close(); inputStream.close();&#125;","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"}]},{"title":"VBA学习——正则提取单元格指定内容并加粗","slug":"VBA学习——正则提取单元格指定内容并加粗","date":"2021-12-04T03:15:12.000Z","updated":"2021-12-04T03:37:48.369Z","comments":true,"path":"2021/12/04/VBA学习——正则提取单元格指定内容并加粗/","link":"","permalink":"https://nymrli.top/2021/12/04/VBA学习——正则提取单元格指定内容并加粗/","excerpt":"","text":"今天又是女朋友打工人的一天，女朋友有需求，打excel打印出来。由于导出后行距太小，以及答案不明显，因此做了两个处理 每两行之间插入一行 将单元格内（A、xxx）的答案进行加粗 Excel中的宏指的是一段操作过程 VBA 中，过程是一切的开始，几乎所有的代码，都会被写在一个或多个过程里。实际开发中，通常一个过程，建议只完成一个特定的小目标。因此，我们的程序往往会包含多个过程。这就是 VBA 中过程概念存在的一个原因。 VBA 过程以 Sub 语句开始，以 End Sub 语句结束，包含一个或多个语句，完成一个特定的目标。 接受参数的过程基本语法如下： 123456Sub [过程名]([变量名1] As [数据类型1],...[变量名n] As [数据类型n]) 语句1 语句2 ... 语句3End Sub from : VBA 过程(Sub) 入门教程和实例 功能实现——将单元格内（A、xxx）的答案进行加粗 选择对应的sheet按下alt+F11打开 12345678910111213141516171819Sub mocro() '定义宏函数' Set re = CreateObject(\"VBScript.RegExp\") '创建正则对象, 或者Dim reg As New RegExp' re.Pattern = \"（.*?）\" '行内容' For Each Rng In Range(\"A1:A5178\") '字符' lenstr = Len(Rng) Set ma = re.Execute(Rng) For Each m In ma lenans = Len(m) For i = 1 To (lenstr - lenans + 1) tempString = Mid(Rng, i, lenans) If tempString = m Then Rng.Characters(i, lenans).Font.Bold = True End If Next i Next m Next RngEnd Sub 注：执行代码之前需要将光标移动到要执行代码的Sheet中的某个单元格 功能实现——每两行之间插入一行 添加多余列，对着已有数据从第一行开始i=1开始，每隔一行设置i+2（奇数），比如第三行为5 超出数据行数部分填入偶数，如2、4、6 选择这组功能列，进行筛选——升序，扩展选取 然后就可以看到每行之间就多出来一行了 再选择导出成pdf，每行之间的间距就变大了 参考 Excel: 通过VBA修改单元格中“部分”文字的颜色 excel如何匹配正则表达式并标色 某个单元格的部分字符变色，就要利用Characters(开始位置,结束位置).font.color 进行赋值 12Cells(i, \"A\").Characters(numB, Len(strA)).Font.Color = vbRed '如果要将某个单元格的部分字符变色，就要利用Characters(开始位置,结束位置).font.color 进行赋值'从中可以看出Range(\"A1:A22\")取出来的对象就是Cells类型的' VBA Mid()函数 截取字符串 - VBA函数学习笔记（一） 1234'设置指定cell的属性？比如字体颜色'Columns(\"A:A\").SelectSelection.Font.Bold = True 粗体Selection.Font.ColorIndex = 3 颜色 【教程】Excel VBA从入门到进阶（蓝色幻想）——可以补充点基础知识 如何在excel表中每隔一行插入一行空白行？ excel批量调整列宽和行高的方法","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"前端进行网络请求的三种方式","slug":"前端进行网络请求的三种方式","date":"2021-12-02T13:28:06.000Z","updated":"2021-12-05T14:42:57.738Z","comments":true,"path":"2021/12/02/前端进行网络请求的三种方式/","link":"","permalink":"https://nymrli.top/2021/12/02/前端进行网络请求的三种方式/","excerpt":"","text":"前端进行网络请求的三种方式 XHR技术 基于XMLHTTPRequest技术实现的，通过调用原生的XML对象实现的，非常的冗余==&gt;ajax技术 ajax Jquery.$ajax 123456789101112131415161718192021222324// 有参数，则增加data字段，有请求头则增加headers字段，有错误处理增加error字段// 默认是按照表单提交post方法，data中虽然是json但是提交时转成表单$.ajax(&#123; url:\"demo_test.txt\", data:&#123;a:10&#125;, success:function(result)&#123; console.log(result); &#125;, error:function(xhr,status,error)&#123; console.log(error); &#125;&#125;);// data在post下是表单格式，在get下是querystring格式// 通过以下方法指定为json格式[json格式本质就是body里是json字符串，头里是application/json]$.ajax(&#123; method: \"POST\", headers: &#123;\"content-type\": \"application/json\"&#125;, data: JSON.stringify(&#123;a: 10&#125;), url: \"http://localhost:9090\" success: function(data)&#123;console.log(data)&#125;&#125;)// JQuery的get和post可以简写：$.get(url,data,callback) // querystring格式$.post(url,data,callback) // x-www-form-urlencoded格式 Get: 参数放到querystring中 Post：参数放到body中， 默认application/x-www-form-urlencoded axios（推荐） 123456// axios默认是json类型的提交axios(&#123; url: \"http://localhost:9090\", method: \"POST\", data: &#123;a: 1&#125; // 这边可以直接传json data而不是字符串&#125;) POST默认的提交格式为json，而不是表单www-form-urlencode 1234567axios(&#123; url: \"http://localhost:9090\", method: \"POST\", headers: &#123;\"content-type\": \"application/www-form-urlencode\"&#125; data: \"a=3&amp;b=3\" // 这边可以直接传json data而不是字符串&#125;).then(res=&gt;res.json()) .then(d=&gt;console.log(d)) axios的get/post/put/delete等等都可以简写 1axios.post(url,data).then(callback) fetch 目前主流浏览器都支持的技术，除了IE Network捕捉到的Type不再是XHR，而直接是fetch promise特性 12345678910111213141516fetch(\"http://localhost:9090\", &#123; method: \"POST\", headers: &#123;\"content-type\": \"application/www-form-urlencode\"&#125;, body: \"a=12&amp;b=11\" // 表单写这种形式 &#125;) .then(res=&gt;res.json()) .then(d=&gt;console.log(d))fetch(\"http://localhost:9090\", &#123; method: \"POST\", headers: &#123;\"content-type\": \"application/json\"&#125;, body: JSON.stringify(&#123;a:11&#125;) // json写这种形式 &#125;) .then(res=&gt;res.json()) .then(d=&gt;console.log(d)) .catch(e=&gt;&#123;&#125;) 注意： 跟其他两个的参数为({parmas})不一样，&lt;&quot;url&quot;, {params}&gt; 参数不是通过data提交的，而是body，写data无效 请求的组成 请求头： url: uri[+query] method： header： Http Header里的Content-Type一般有这三种： application/x-www-form-urlencoded：数据被编码为名称/值对。这是标准的编码格式。(默认的) multipart/form-data： 数据被编码为一条消息，页上的每个控件对应消息中的一个部分。 text/plain： 数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符。postman软件里标的是RAW。 协议 请求体body post请求时提交的数据 from:【ajax科普】【前端】fetch、axios、jquery的ajax用法 模拟服务器文件： 链接：https://pan.baidu.com/s/1nMZRcPYY4RIW_4Rvc2mDCw 提取码：wxw4 附录 测试所用express服务器代码 1234567891011121314151617181920var app = express()// app.use(express.urlencoded(&#123; extended: false &#125;))// 通过 express.json() 这个中间件，解析表单中的 JSON 格式的数据// 在服务器，可以使用 req.body 这个属性，来接收客户端发送过来的请求体数据// 默认情况下，如果不配置解析表单数据中间件，则 req.body 默认等于 undefinedapp.use(express.json())app.use(\"/\", (req, res) =&gt; &#123; res.header(\"Access-Control-Allow-Origin\", \"*\") res.header(\"Access-Control-Allow-Headers\", \"*\") console.log(\"url: \", req.method, req.url); console.log(\"queryString: \", req.query); console.log(\"headers: \", req.headers); console.log(\"body: \", req.body); res.json(&#123; code: 200, msg: \"OK\" &#125;)&#125;)app.listen(8080) 不写html代码，直接在浏览器里运行测试： 地址栏中输入：data:text/html,后跟内容，如 data:text/html,&lt;h1&gt;hello&lt;/h1&gt;会显示大的hello data:text/html, &lt;script src=&quot;...&quot;&gt;&lt;/script&gt;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"}]},{"title":"Mongodb学习","slug":"Mongodb学习","date":"2021-12-02T03:17:52.000Z","updated":"2021-12-22T06:31:28.864Z","comments":true,"path":"2021/12/02/Mongodb学习/","link":"","permalink":"https://nymrli.top/2021/12/02/Mongodb学习/","excerpt":"","text":"Mongodb学习 创建数据库-集合（表） 使用指定数据库（没有会创建）: use DATABASE_NAME, 如果数据库不存在，则创建数据库，否则切换到指定数据库。 如: use douban， 此时db就变成了douban，之后db.xxxx()都默认在这个数据库下操作 查看所有数据库，可以使用 show dbs 创建集合：db.createCollection(name, options) 随意创建集合， db.createCollection(&quot;top250&quot;); options 可以是如下参数： 字段 类型 描述 capped 布尔 （可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。 当该值为 true 时，必须指定 size 参数。 autoIndexId 布尔 3.2 之后不再支持该参数。（可选）如为 true，自动在 _id 字段创建索引。默认为 false。 size 数值 （可选）为固定集合指定一个最大值，即字节数。 如果 capped 为 true，也需要指定该字段。 max 数值 （可选）指定固定集合中包含文档的最大数量。 创建固定集合: db.createCollection(&quot;mycol&quot;, { capped : true, autoIndexId : true, size : 6142800, max : 10000 } ) 查看已有集合，可以使用 show collections 或 show tables 命令： 插入文档 db.COLLECTION_NAME.insert(document)或db.COLLECTION_NAME.save(document) save()：如果 _id 主键存在则更新数据，如果不存在就插入数据。该方法新版本中已废弃，可以使用 db.collection.insertOne() 或 db.collection.replaceOne() 来代替。 insert(): 若插入的数据主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常，提示主键重复，不保存当前数据。 3.2 版本之后新增了 db.collection.insertOne() 和 db.collection.insertMany()。 查询find: 在MongoDB中可以使用find0函数查询文档。 语法格式为：find(){查询条件(可选)}，{指定投影的键(可选)})如果未给定参数则表示查询所有数据。 当查询所有，要制定投影键的时候得列出前面的大括号，如find({键: {操作符: 条件}}, {投影键名: 1(显示该列)| 0(不显示该列), ..}), 如果不想显示_id可以这么写: find({},{_id: 0}) prettyO函数可以使用格式化的方式来显示所有文档。 $and和$or联合使用 查询title为test5并且size等于500，或者size小于400的文档。 db.dev.find({$or:[{$and:[{title:{$eq:&quot;test5&quot;}},{size:500}]},{size:{$Lt:409}}]}) 聚合查询aggregate Java Aggregation.match 关于AGGREGATION 语法和表达式大全（最新3.4版） SQL操作函数 mongodb聚合操作 where $match 在$groupby前侧 group $group having $match 在$groupby后侧 select $project order by $sort limit $limit join $lookup 12345// aggregate中一定是个数组格式db.COLLECTION_NAME.aggregate([&#123;$group:&#123;_id:&quot;$分组键名”，$分组键名”……，别名：&#123;聚合运算：&quot;$运算列”&#125;&#125;&#125;， // 分组处理&#123;条件筛选：&#123;键名：&#123;运算条件：运算值&#125;&#125;&#125;]) 例子： 求和 查询dev集合中一共有多少个文档。 相当于sql语句：SELECT count（*）AS count FROM dev db.dev.aggregate（[{$group:{_id:null.count:($sum：1}}}]） $group：分组，代表聚合的分组条件 _id：分组的字段。相当于SQL分组语法group by column name中的column name部分。 如果根据某字段的值分组，则定义为id:’$字段名’。所以此案例中的null代表一个固定的字面值null，表示对所有列即整表。 count：返回结果字段名。可以自定义，类似SQL中的字段别名。 $sum：求和表达式。相当于SQL中的sumO。 1：累加值。如果是对某列如size求值和，则1改为&quot;&quot;$size&quot; 管道 MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。 管道操作符是按照书写的顺序依次执行的，每个操作符都会接受一连串的文档，对这些文档做一些类型转换，最后将转换后的文档作为结果传递给下一个操作符（对于最后一个管道操作符，是将结果返回给客户端），称为流式工作方式。 管道操作符：$match、$group、$sort、$limit、$skip、$unwind， 管道操作符，只能用于计算当前聚合管道的文档，不能处理其它的文档。 MongoDB 的 aggregate 是可以分为多个阶段的（pipeline） 第一阶段，$match，这里可以参考《MongoDB：查询和投影操作符》这篇文章，根据条件去查找。 第二阶段，$project，表示要哪个域，不要哪个域，或者投影成别的一个域，这里表示 value 域保留，status 域，根据条件来转换成 “confirmed” 或者 “unconfirmed”，_id 不要。 第三阶段，group，id域用前面的group，_id 域用前面的group，i​d域用前面的status来表示，balance 是对之前的$value进行求和。 常用命令： $project：使用$project操作符做聚合投影操作从而修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。如db.dev.aggregate([{Sunwind:&quot;Stags&quot;},{Sproject:{id:0,Tags:&quot;$tags&quot;,Title:&quot;$title&quot;}}])从而不显示id, 并且可以取别名 $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $lookup // Aggregation.lookup(&quot;student&quot;, &quot;student_id&quot;, &quot;_id&quot;, &quot;student&quot;) 参数含义如下 LookupOperation lookupOperation=LookupOperation.newLookup(). from(&quot;grade&quot;). //关联从表名 localField(&quot;gradeId&quot;). //主表关联字段 foreignField(&quot;_id&quot;).//从表关联的字段 as(&quot;GradeAndStu&quot;); //查询结果名 $count unwind：将文档中的某一个**数组类型字段拆分成多条**，每条包含数组中的一个值。如查询dev集合，将其中数组内的内容拆分显示(会生成多个id相同的查询结果)，`db.dev.aggregate([{unwind:&quot;$tags&quot;}])` $group：将集合中的文档分组，可用于统计结果。 操作内嵌文档 MongoDB 内嵌文档 MongoDB 几种查询嵌套数据（Embedded）的方式 操作数组 对数组根据条件查询 $all、$size、$slice、$elemMatch $all查找数组中包含指定的值的文档 $size 查找数组大小等于指定值的文档 slice⋅查询数组中指定返回元素的个数,‘slice·查询数组中指定返回元素的个数, `slice⋅查询数组中指定返回元素的个数,‘slice·可以查询数组中第几个到第几个 对数组内嵌文档查询 $elemMatch文档包含有一个元素是数组，那么$elemMatch可以匹配内数组内的元素并返回文档数据db.orders.find({&quot;items&quot;:{$elemMatch:{&quot;quantity&quot;:2}}}) elemMatch可以带多个查询条件`db.orders.find({&quot;items&quot;:{elemMatch:{“quantity”:4,“ino”:“002”}}}) ` $elemMatch同样可以用在find方法的第二个参数来限制返回数组内的元素，只返回我们需要的文档db.orders.find({&quot;onumber&quot;:&quot;001&quot;},{&quot;items&quot;:{$elemMatch:{&quot;quantity&quot;:4,&quot;ino&quot;:&quot;002&quot;}},&quot;cname&quot;:1,&quot;date&quot;:1,&quot;onumber&quot;:1}) from; MongoDB查询（数组、内嵌文档）（二） MongoDB 几种查询嵌套数据（Embedded）的方式——$ 映射操作符（Projection Operator）、$elemMatch 映射操作符（Projection Operator） MongoDB高级查询详细 完整demo: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public JobPositionDetailsVO getJobPositionDetails(String orgId, String jpId) &#123; Organization org = orgService.findByOrgId(orgId); RootOrg root = orgService.getRootOrgInfo(); // 查询组织的岗位信息设置 List&lt;SystemFieldListDTO&gt; systemList; List&lt;Map&lt;String, Object&gt;&gt; values; List&lt;JobPosition&gt; allJobPosition = Lists.newArrayList(); JobPositionDetailsVO result = new JobPositionDetailsVO(); if (org == null &amp;&amp; !orgId.equals(root.getOrgId())) &#123; throw new IllegalArgumentException(\"orgId:\" + orgId + \" 对应的组织信息不存在！\"); &#125; else if (orgId.equals(root.getOrgId())) &#123; // 根组织读取所有职务 allJobPosition = jobPositionService.list(); // 包装成List&lt;Map&gt;类型 values = getJobInfo(allJobPosition); result.setOrgId(root.getOrgId()); &#125; else &#123; // 非根组织取系统字段内岗位数据 systemList = org.getSystemFieldList(); // 校验下数据 SystemFieldListDTO dto = orgCommonService.getFirstRepeatFieldByCode(FieldConst.JOB_POSITION, systemList); if (dto == null) &#123; throw new RuntimeException(\"组织内岗位信息不能为空！\"); /*result.setPersonList(Lists.newArrayList()); result.setSettingList(Lists.newArrayList()); return result;*/ &#125; values = dto.getValues(); result.setOrgId(orgId); &#125; // 获取组织配置中的所有职务id Set&lt;String&gt; jpIds = Sets.newHashSet(); // 用来记录组织内岗位的编制数量 Map&lt;String, Integer&gt; numMap = Maps.newHashMap(); // 用来记录组织内岗位的数量范围 Map&lt;String, Integer&gt; rangeMap = Maps.newHashMap(); for (Map&lt;String, Object&gt; value : values) &#123; String curJpId = (String) ((Map&lt;String, Object&gt;) (value.get(FieldConst.VALUE))).get(FieldConst.JPID); jpIds.add(curJpId); numMap.put(curJpId, (Integer) ((Map&lt;String, Object&gt;)(value.get(FieldConst.VALUE))).get(FieldConst.NUM)); rangeMap.put(curJpId, (Integer) ((Map&lt;String, Object&gt;)(value.get(FieldConst.VALUE))).get(FieldConst.RANGE)); &#125; if (CollectionUtils.isEmpty(jpIds)) &#123; result.setPersonList(Lists.newArrayList()); result.setSettingList(Lists.newArrayList()); return result; &#125; // 查询相关的所有职务信息 List&lt;JobPosition&gt; jobPositionList = jobPositionService.query() .in(JobPosition::getJpId, jpIds).list(); // 职务列表排序 Collections.sort(jobPositionList); // 如果对应的职务信息全部被删除了，而组织内设置的职务都没有对应删除，直接返回 if (CollectionUtils.isEmpty(jobPositionList)) &#123; result.setPersonList(Lists.newArrayList()); result.setSettingList(Lists.newArrayList()); return result; &#125; // 查询在职信息中为 orgId 的人员 Criteria criteria = new Criteria(); criteria.andOperator( Criteria.where(\"form.code\").is(FieldConst.JOB_POSITION), Criteria.where(\"form.values.orgId\").is(orgId) ); List&lt;PersonInfo&gt; personInfoList = mongoTemplate.find(Query.query(criteria), PersonInfo.class); //排除离职人员 Set&lt;String&gt; userIds = personInfoList.stream().map(p -&gt; p.getUserId()).collect(Collectors.toSet()); Set&lt;String&gt; resignUserIds = employmentInfoService.getResignationByUserIds(userIds); personInfoList = personInfoList.stream().filter(p -&gt; !resignUserIds.contains(p.getUserId())).collect(Collectors.toList()); // 获取 key 为 职务id, value 为 用户id 的 map Map&lt;String, Set&lt;String&gt;&gt; reverseMap = orgService .reverseMapping(personInfoList, FieldConst.JOB_POSITION, FieldConst.JPID, false, false); // 获取 key 为 jpId, value 为 角色的 map Map&lt;String, String&gt; roleMap; if (orgId.equals(root.getOrgId())) &#123; // 根节点的话roleMap取在职表内的role信息 roleMap = allJobPosition.stream().collect(Collectors.toMap(JobPosition::getJpId, JobPosition::getRole)); &#125; else &#123; // 非根节点取组织表内职务中的role信息 roleMap = orgService.getJobPositionRoleMap(orgId); &#125; List&lt;JobPositionSettingVO&gt; settingList = constructSettingList(jobPositionList, numMap, reverseMap, roleMap, rangeMap); List&lt;JobPositionPersonVO&gt; personList = constructPersonList(jpId, jobPositionList, reverseMap, orgId); result.setSettingList(settingList); result.setPersonList(personList); return result; &#125; 使用MongoRepository完成CURD和复杂查询 与HibernateRepository类似，通过继承MongoRepository接口，我们可以非常方便地实现对一个对象的增删改查，要使用Repository的功能，先继承MongoRepository&lt;T, TD&gt;接口，其中T为仓库保存的bean类，TD为该bean的唯一标识的类型，一般为ObjectId。之后在service中注入该接口就可以使用，无需实现里面的方法，spring会根据定义的规则自动生成。 123456public interface PersonRepository extends interface DictionaryInfoDao : MongoRepository&lt;DictionaryInfo?, String?&gt; &#123; fun findByDictTypeCode(name: String): DictionaryInfo? //这里可以添加需要用到的查询方法、以及自定义额外的查询方法 &#125; 但是MongoRepository实现了的只是最基本的增删改查的功能，要想增加额外的查询方法，可以按照以下规则定义接口的方法。自定义查询方法，格式为findBy+字段名+方法后缀，方法传进的参数即字段的值，此外还支持分页查询，通过传进一个Pageable对象，返回Page集合。 123456public interface PersonRepository extends MongoRepository&lt;Person, ObjectId&gt;&#123; //查询大于age的数据 public Page&lt;Product&gt; findByAgeGreaterThan(int age,Pageable page) ; ｝ from : MongoRepository基本方法 尽管以上查询功能已经很丰富，但如果还不能满足使用情况的话可以用一下方法——基于mongodb shell查询语句的查询方式，即在DAO接口中加入 12@Query(\"&#123; 'name':&#123;'$regex':?2,'$options':'i'&#125;, sales': &#123;'$gte':?1,'$lte':?2&#125;&#125;\") public Page&lt;Product&gt; findByNameAndAgeRange(String name,double ageFrom,double ageTo,Pageable page); 注解Query里面的就是mongodb原来的查询语法，我们可以定义传进来的查询参数，通过坐标定义方法的参数。 还可以在后面指定要返回的数据字段，如上面的例子修改如下，则只通过person表里面的name和age字段构建person对象。 12@Query(value=\"&#123; 'name':&#123;'$regex':?2,'$options':'i'&#125;, sales':&#123;'$gte':?1,'$lte':?2&#125;&#125;\",fields=\"&#123; 'name' : 1, 'age' : 1&#125;\") public Page&lt;Product&gt; findByNameAndAgeRange(String name,double ageFrom,double ageTo,Pageable page); 对比mongotemplate和mongoRepository 1MongoTemplate MongoTemplate 遵循Spring中的标准模板模式，并为底层持久性引擎提供准备就绪的基本API。 1234567// 1. 校验添加的物资类型是否存在val exists = mongoTemplate.exists( Query.query( Criteria.where (\"materialTypeCode\").`is`(materialInfo.materialTypeCode) ), DictionaryInfo::class.java) 1234567891011121314val criteria = Criteria().andOperator( Criteria.where(\"parentId\").`is`(materialTypeId), Criteria.where(\"unitId\").`is`(unitId))val query: Query = Query.query(criteria)val list: MutableList&lt;MaterialType&gt; = mongoTemplate.find(query, MaterialType::class.java)val list2: MutableList&lt;MaterialInfo&gt;? = mutableListOf()list.forEach &#123; val query2: Query = Query.query(Criteria.where(\"id\").`is`(it.itemId)) val value = mongoTemplate.findOne(query2, MaterialInfo::class.java) if (value != null) &#123; list2.add(value) &#125;&#125; 2MongoRepository 以Spring Date为中心的方法，基于所有Spring数据项目中众所周知的访问模式，提供更加灵活和复杂的api操作。 mongoRepository，MongoTemplate Spring boot集成mongodb使用MongoRepository完成CURD和复杂查询 Spring Data JPA方法名命名规则 findByOrderByDictTypeCodeDescAndSortNumDesc失败 findAllByOrderByIdDesc和findByOrderByIdDesc 效果一样 dictionaryInfoDao.findAllByOrderByIdDesc(Sort.by(Sort.Direction.DESC,&quot;sortNum&quot;));后面的排序无效 12345findAllByOrderByIdDescAndOrderBySortNumDesc findAllByOrderByIdDescAndSortNumDesc(Sort sort)dictionaryInfoDao.findAll(Sort.by(&quot;dictTypeCode&quot;), Sort.by(&quot;sortNum&quot;));失效 MyBatis与JPA的区别是什么 JPA是JAVA持久层API的规范， JPA仅仅定义了一些接口，而接口是需要实现才能工作的。 所以底层需要某种实现，而Hibernate就是实现了JPA接口的ORM框架。 Mybatis优势 MyBatis可以进行更为细致的SQL优化，可以减少查询字段。 MyBatis容易掌握，而Hibernate门槛较高。 Hibernate优势 Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。 Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。 Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。 Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳 fun findAllByDictTypeCode(dictTypeCode: String): List&lt;DictionaryInfo&gt; 返回的是个List， 如果没有值则为空列表 如果findById的结果是个Optional， 如果自定义findByXxxx方法时，返回值可以定义为Optional&lt;XxxxDO&gt;也可以直接定义成 XxxxDO?","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"}]},{"title":"Gradle学习","slug":"Gradle学习","date":"2021-12-02T03:16:31.000Z","updated":"2021-12-02T03:16:51.308Z","comments":true,"path":"2021/12/02/Gradle学习/","link":"","permalink":"https://nymrli.top/2021/12/02/Gradle学习/","excerpt":"","text":"Gradle学习 在kotlin中使用mapstruct出现了些问题， 网上搜寻后得到结论：需要使用kapt(Kotlin annotation processing tool 即kotlin注解处理工具)， 但给出的大多都是通过Gradle来进行配置的。因此借此机会学习了下Gradle： plugins和apply plugin: 由于文档写到了， 由于不清楚这些在哪些位置加入， 因此查看了plugins和apply plugin:的区别： 1234567891011&gt; 添加 kapt 插件&gt; apply plugin: &apos;kotlin-kapt&apos;&gt; &gt; 然后在项目中添加如下依赖：&gt; api(&quot;com.github.pozo:mapstruct-kotlin:1.3.1.2&quot;)&gt; kapt(&quot;com.github.pozo:mapstruct-kotlin-processor:1.3.1.2&quot;)&gt; &gt; 另外，还需要添加如下依赖：&gt; api(&quot;org.mapstruct:mapstruct:1.4.0.Beta3&quot;)&gt; kapt(&quot;org.mapstruct:mapstruct-processor:1.4.0.Beta3&quot;)&gt; “plugins {}”块导入的是Gradle官方插件仓库里的插件。如果使用“buildscript {}”块指定第三方库作为Gradle插件的话，指定插件就需要使用“apply plugin”了。 刚刚翻了翻文档，“apply plugin”本身似乎还有更多的用途，而“plugins {}”块似乎是一个新引入的还不足够稳定的特性。题主想要知道更多的话直接看看文档就行了。 最终的Plain项目的依赖如下所示： 12345678910111213141516171819202122232425262728plugins &#123; id 'java' id 'org.jetbrains.kotlin.jvm' version '1.4.10'&#125;group 'org.example'version '1.0-SNAPSHOT'repositories &#123; mavenCentral()&#125;apply plugin: 'kotlin-kapt'dependencies &#123; implementation \"org.jetbrains.kotlin:kotlin-stdlib\" testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.0' testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine' api(\"com.github.pozo:mapstruct-kotlin:1.3.1.2\") kapt(\"com.github.pozo:mapstruct-kotlin-processor:1.3.1.2\") api(\"org.mapstruct:mapstruct:1.4.0.Beta3\") kapt(\"org.mapstruct:mapstruct-processor:1.4.0.Beta3\")&#125;test &#123; useJUnitPlatform()&#125; maven使用kapt 在 kotlin-maven-plugin 中的在compile 之前添加 kapt 目标的执行： 1234567891011121314151617181920&lt;execution&gt; &lt;id&gt;kapt&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;kapt&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirs&gt; &lt;sourceDir&gt;src/main/kotlin&lt;/sourceDir&gt; &lt;sourceDir&gt;src/main/java&lt;/sourceDir&gt; &lt;/sourceDirs&gt; &lt;annotationProcessorPaths&gt; &lt;!-- 在此处指定你的注解处理器。 --&gt; &lt;annotationProcessorPath&gt; &lt;groupId&gt;com.google.dagger&lt;/groupId&gt; &lt;artifactId&gt;dagger-compiler&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;/annotationProcessorPath&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt;&lt;/execution&gt; 请注意，IntelliJ IDEA 自身的构建系统目前还不支持 kapt。当你想要重新运行注解处理时，请从“Maven Projects”工具栏启动构建。 from: https://www.kancloud.cn/alex_wsc/android_kotlin/1318386#_Maven__110 gradle中api、implementation和compile的区别 我们在gradle中引用第三方maven库时，一般通过下面的语句去引用:compile 'com.android.support:appcompat-v7:26.1.0' , 然后sync project，就能成功引用对应的包到项目之中了，十分方便。除了使用compile关键字，使用implementation和api也能将包引用到项目中 api和compile关键字作用效果是一样的，使用时可以互相替换。实际上，api关键字是用来替代compile关键字的，因为compile关键字将来会被弃用。在高版本的gradle，使用compile关键字会报错并提示使用api关键字代替。 Q：看起来这三个关键字的作用是一样的，那么，他们到底有什么区别呢？ A：在同一个module下，implementation和compile的使用效果相同，但是在不同module下，就会有所区别了。 api或compile关键字引用的包对于其他module来说是可见的，而implementation关键字引用的包对于其他module来说是不可见的。 Maven仓库列表 仓库名 简介 实际地址 使用地址 jcenter JFrog公司提供的仓库 http://jcenter.bintray.com https://maven.aliyun.com/repository/jcenter https://maven.aliyun.com/nexus/content/repositories/jcenter mavenLocal 本台电脑上的仓库 {USER_HOME}/.m2/repository C:/Users/liyujiang/.m2/repository (Windows) /home/liyujiang/.m2/repository (Linux) mavenCentral Sonatype公司提供的中央库 http://central.maven.org/maven2 https://maven.aliyun.com/repository/central https://maven.aliyun.com/nexus/content/repositories/central google Google公司提供的仓库 https://maven.google.com https://maven.aliyun.com/repository/google https://maven.aliyun.com/nexus/content/repositories/google https://dl.google.com/dl/android/maven2 jitpack JitPack提供的仓库 https://jitpack.io https://jitpack.io public jcenter和mavenCentral的聚合仓库 https://maven.aliyun.com/repository/public https://maven.aliyun.com/nexus/content/groups/public gradle-plugin Gradle插件仓库 https://plugins.gradle.org/m2 https://maven.aliyun.com/repository/gradle-plugin https://maven.aliyun.com/nexus/content/repositories/gradle-plugin 1234567repositories &#123; // Use &apos;jcenter&apos; for resolving your dependencies. // You can declare any Maven/Ivy/file repository here. maven&#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;&#125; jcenter()&#125; gradle全局换源 kotlin-mapstruct https://www.imooc.com/article/309984","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"}]},{"title":"Vue-Router细节记录","slug":"Vue-Router细节记录","date":"2021-11-30T16:05:59.000Z","updated":"2021-11-30T16:08:28.712Z","comments":true,"path":"2021/12/01/Vue-Router细节记录/","link":"","permalink":"https://nymrli.top/2021/12/01/Vue-Router细节记录/","excerpt":"","text":"vue-router使用 yarn add vue-router@next --dev, 参数说明packageName@tagorpackageName@version 创建router/index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; createRouter, createWebHistory &#125; from \"vue-router\";import ShowList from \"../components/ShowList.vue\"const router = createRouter(&#123; history: createWebHistory(), routes: [ &#123; path: \"/show\", component: ShowList &#125;, &#123; path: \"/login\", name: \"Login\", meta: &#123; title: '登录' &#125;, // 懒加载 component: () =&gt; import ( /* webpackChunkName: \"login\" */ \"../views/Login.vue\") &#125;,&#123; path: '/user/:id', // 如/user/111, router-link to=\"/user/111\"也行。注id为params参数, User.vue中通过 &#123;&#123; $route.params.id &#125;&#125; 获取 components: &#123; default: User, sidebar: Sidebar &#125;, /**在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。可以使用 props 将组件和路由解耦：这样你便可以在任何地方使用该组件，使得该组件更易于重用和测试。 */ props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;)router.beforeEach((to, from, next) =&gt; &#123; document.title = `$&#123;to.meta.title&#125; | vue-manage-system`; const role = localStorage.getItem('ms_username'); if (!role &amp;&amp; to.path !== '/login') &#123; next('/login'); &#125; else if (to.meta.permission) &#123; // 如果是管理员权限则可进入，这里只是简单的模拟管理员权限而已 role === 'admin' ? next() : next('/403'); &#125; else &#123; next(); &#125;&#125;);export default router app下进行router跳转 12345678910111213&lt;template&gt; &lt;div id=\"app\"&gt; &lt;div&gt; // 下面的叫声明式 &lt;router-link to=\"/\"&gt;Home&lt;/router-link&gt; | &lt;router-link to=\"/show\"&gt;show&lt;/router-link&gt;| &lt;router-link to=\"/hello\"&gt;hello&lt;/router-link&gt;| &lt;router-link :to=\"&#123;name: 'antd', params: &#123; id: 2 &#125;&#125;\"&gt;antd&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 子vue中点击按钮后进行router跳转 12345678910111213141516171819202122232425262728293031323334 // vue2写法 function submitForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; this.$router.push(&#123;name: \"Mainwithout\", params: &#123;name: this.form.name&#125;&#125;) // 如果要传参，则为router-name；如果不传参直接push(path) sessionStorage.setItem(\"isLogin\", true) this.$store.dispatch(\"asyncUpdateUser\", &#123;name: this.form.name&#125;) console.log(\"enter\", this.$store.state) &#125; else &#123; this.$message.error('错了哦，这是一条错误消息'); return false; &#125; &#125;); &#125; // vue3写法：Vue-router 4.x为此提供了useRoute()：import &#123;useRouter&#125; from 'vue-router'setup(props,ctx)&#123; //router是全局路由对象，route= userRoute()是当前路由对象 let router = useRouter(); let start = () =&gt; &#123; // 这个叫编程式 router.push(&#123; //传递参数使用query的话，指定path或者name都行，但使用params的话，只能使用name指定 path:'/home', query:&#123; num:1 &#125; &#125;) &#125; onMounted(() =&gt; &#123; const id = router.params.id &#125;)&#125; 调用方式： 123456789101112131415// 字符串router.push('home')// 对象router.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: '123' &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;)// ▲注：同样的规则也适用于 router-link 组件的 to 属性。router.replace(location, onComplete?, onAbort?)// 跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。router.go(n)// 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。 区分router和route $router : 是路由操作对象，只写对象 $route : 路由信息对象，只读对象 123456789101112//操作 路由跳转this.$router.push(&#123; name:'hello', params:&#123; name:'word', age:'11' &#125;&#125;)//读取 路由参数接收this.name = this.$route.params.name;this.age = this.$route.params.age; 区分query和params query传参要用path来引入，params传参要用name来引入 1234567891011121314151617181920212223242526272829303132333435363738394041// path+query==&gt; /second?queryId=2222&amp;queryName=query//query传参，使用name跳转this.$router.push(&#123; name:'second', query: &#123; queryId:'20180822', queryName: 'query' &#125;&#125;)//query传参，使用path跳转this.$router.push(&#123; path:'second', query: &#123; queryId:'20180822', queryName: 'query' &#125;&#125;)//query传参接收this.queryName = this.$route.query.queryName;this.queryId = this.$route.query.queryId;/** ---------------------- **/// name+params==&gt; /second/20180822/query， 更多见：https://router.vuejs.org/zh/guide/essentials/named-routes.htmlthis.$router.push(&#123; name:'second', params: &#123; id:'20180822', name: 'query' &#125;&#125;)//params接收参数， 是$routethis.id = this.$route.params.id ;this.name = this.$route.params.name ;//路由&#123; path: '/second/:id/:name', name: 'second', component: () =&gt; import('@/view/second')&#125; params是路由的一部分, 必须要在路由后面添加参数名。query是拼接在url后面的参数，没有也没关系。 params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。（最重要的一点，params刷新会消失。query则不会） 12parmas：https://blog.csdn.net/xxxquery: https://blog.csdn.net?xxx from：https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html 跳转与视图 router-link 实现路由之间的跳转，如点击show超链接则会跳转到http://localhost:8080/show 1234567891011&lt;!-- 字符串 --&gt;&lt;router-link to=\"home\"&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href=\"home\"&gt;Home&lt;/a&gt;&lt;!-- 同上 --&gt;&lt;router-link :to=\"&#123; path: 'home' &#125;\"&gt;Home&lt;/router-link&gt;&lt;!-- 命名的路由 --&gt;&lt;router-link :to=\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"&gt;User&lt;/router-link&gt;&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;&lt;router-link :to=\"&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;\"&gt;Register&lt;/router-link&gt; 视图：router-view 当路由的path 与访问的地址相符时，会将指定的组件内容替换该 router-view，如果不点击而是直接将URL换成http://localhost:8080/show也会显示ShowList.vue的内容（为什么是ShowList.vue？是因为router/index.js中将path=''/show'与ShowList.vue绑定了） 命名视图==》存在多个、多层视图 动态传参跳转 采坑： 12:to=\"&#123;path:'invest/scattered',query: &#123;productId: list.id&#125;&#125;\"to=\"invest/scattered?productId=1\" // 如果不加冒号访问动态参数即to=\"&#123;path:'invest/scattered',query: &#123;productId: list.id&#125;&#125;\"，则会乱码 冒号可以传动态的参数(也可以传静态的)；不加冒号是静态的路径；动态路由也可以以静态路由的形式写，参数固定如:to=&quot;{name: 'antd', params: { id: 2 }}&quot;==&gt;to=&quot;/antd/2&quot;；参数为变量： 12&lt;router-link :to=\"&#123;name: 'antd', params: &#123; id: 2 &#125;&#125;\"&gt;antd&lt;/router-link&gt;&lt;router-link :to=\"`/antd/$&#123;uid&#125;`\"&gt;antd&lt;/router-link&gt; 更推荐指定url的写法，因为就不用考虑name还是path了 123456789101112131415// App.vue&lt;router-link :to=\"`/antd?name=mrli`\"&gt;antd&lt;/router-link&gt;// 要跳转的 Antd.vue&#123;&#123; $route.query.name &#125;&#125;// App.vue&lt;router-link :to=\"`/antd/3`\"&gt;antd&lt;/router-link&gt;// 要跳转的 Antd.vue&#123;&#123; $route.params.id &#125;&#125;// 还需要router/index.js中定义, 不然$route.params.id无法将那个值对应到id上&#123; path: \"/antd/:id\", name: \"antd\", component: AntdCom&#125;,","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"}]},{"title":"Vue中使用axios","slug":"Vue中使用axios","date":"2021-11-30T02:31:27.000Z","updated":"2021-12-08T08:27:47.764Z","comments":true,"path":"2021/11/30/Vue中使用axios/","link":"","permalink":"https://nymrli.top/2021/11/30/Vue中使用axios/","excerpt":"","text":"axios请求 官网网址 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 直接每次从axios库中调用axios函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;div&gt; &lt;div&gt;mmmm&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import axios from 'axios' export default &#123; name: \"post\", created() &#123; /* post常用的请求数据（data）格式有两种： （1）applicition/json （2）form-data 表单提交（图片上传，文件上传） */ //第一种写法叫做post别名请求方法 // http://localhost:8080/static/data.json?id=1 // applicition/json 请求 let data = &#123; id: 1 &#125; axios.post('../../static/data.json', data) .then((res) =&gt; &#123; console.log('数据：', res); &#125;) //第二种写法 axios(&#123; method: 'post', url: '../../static/data.json', data: data, &#125;).then((res) =&gt; &#123; console.log('数据：', res) &#125;) // form-data 请求 let formData = new FormData() for (let key in data) &#123; formData.append(key, data[key]) &#125; axios.post('../../static/data.json', formData) .then((res) =&gt; &#123; console.log('数据：', res); &#125;) &#125;&#125;&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 结合 vue使用vue-axios npm install --save axios vue-axios vue-axios是按照vue插件的方式去写的。那么结合vue-axios，就可以去使用vue.use方法了 123456// 首先在主入口文件main.js中引用import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(VueAxios,axios); 之后就可以使用了，在组件文件中的methods里去使用了 123456789getNewsList()&#123; this.axios.get('api/getNewsList').then((response)=&gt;&#123; this.newsList=response.data.data; &#125;).catch((response)=&gt;&#123; console.log(response); &#125;)&#125;, axios 改写为 Vue 的原型属性 首先在主入口文件main.js中引用，之后挂在vue的原型链上 12import axios from 'axios'Vue.prototype.$axios= axios 在组件中使用 12345this.$axios.get('api/getNewsList').then((response)=&gt;&#123; this.newsList=response.data.data; &#125;).catch((response)=&gt;&#123; console.log(response); &#125;) 创建axios实例，并封装成工具类 12345678910// utils/requests.jsimport axios from 'axios'// 创建axios实例const service = axios.create(&#123; baseURL: process.env.BASE_API, // api的base_url timeout: 5000 // 请求超时时间&#125;)export default service 组件中直接import 123456789&lt;script&gt;import maxios import \"./utils/requests.js\"maxios.get('api/getNewsList').then((response)=&gt;&#123; this.newsList=response.data.data; &#125;).catch((response)=&gt;&#123; console.log(response); &#125;)&lt;/script&gt; 注： 封装的request指定了baseURL，针对的是没有协议头的相对URL，比如/api；如果使用时加上了http协议头，则还是会走具体的链接，如http://127.0.0.1:5000/api/getword&amp;date=2020-04-01 axios进阶用法: 结合vuex再封装一层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import axios from &apos;axios&apos;import &#123; Message &#125; from &apos;element-ui&apos;import store from &apos;@/store&apos;import &#123; getToken &#125; from &apos;@/utils/auth&apos;// 创建axios实例const service = axios.create(&#123; baseURL: process.env.BASE_API, // api的base_url timeout: 5000 // 请求超时时间&#125;)// request拦截器service.interceptors.request.use(config =&gt; &#123; // Do something before request is sent if (store.getters.token) &#123; config.headers[&apos;X-Token&apos;] = getToken() // 让每个请求携带token--[&apos;X-Token&apos;]为自定义key 请根据实际情况自行修改 &#125; return config&#125;, error =&gt; &#123; // Do something with request error console.log(error) // for debug Promise.reject(error)&#125;)// respone拦截器service.interceptors.response.use( response =&gt; response, /** * 下面的注释为通过response自定义code来标示请求状态，当code返回如下情况为权限有问题，登出并返回到登录页 * 如通过xmlhttprequest 状态码标识 逻辑可写在下面error中 */ // const res = response.data; // if (res.code !== 20000) &#123; // Message(&#123; // message: res.message, // type: &apos;error&apos;, // duration: 5 * 1000 // &#125;); // // 50008:非法的token; 50012:其他客户端登录了; 50014:Token 过期了; // if (res.code === 50008 || res.code === 50012 || res.code === 50014) &#123; // MessageBox.confirm(&apos;你已被登出，可以取消继续留在该页面，或者重新登录&apos;, &apos;确定登出&apos;, &#123; // confirmButtonText: &apos;重新登录&apos;, // cancelButtonText: &apos;取消&apos;, // type: &apos;warning&apos; // &#125;).then(() =&gt; &#123; // store.dispatch(&apos;FedLogOut&apos;).then(() =&gt; &#123; // location.reload();// 为了重新实例化vue-router对象 避免bug // &#125;); // &#125;) // &#125; // return Promise.reject(&apos;error&apos;); // &#125; else &#123; // return response.data; // &#125; error =&gt; &#123; console.log(&apos;err&apos; + error)// for debug Message(&#123; message: error.message, type: &apos;error&apos;, duration: 5 * 1000 &#125;) return Promise.reject(error) &#125;)export default service demo示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 严肃声明： * 开源版本请务必保留此注释头信息，若删除我方将保留所有法律责任追究！ * 本系统已申请软件著作权，受国家版权局知识产权以及国家计算机软件著作权保护！ * 可正常分享和学习源码，不得用于违法犯罪活动，违者必究！ * Copyright (c) 2020 陈尼克 all rights reserved. * 版权所有，侵权必究！ */import axios from 'axios'import &#123; Toast &#125; from 'vant'import router from '../router'axios.defaults.baseURL = process.env.NODE_ENV == 'development' ? '//backend-api-01.newbee.ltd/api/v1' : '//backend-api-01.newbee.ltd/api/v1'axios.defaults.withCredentials = true// 允许携带cookieaxios.defaults.withCredentials = true// 请求头信息axios.defaults.headers['X-Requested-With'] = 'XMLHttpRequest'axios.defaults.headers['token'] = localStorage.getItem('token') || ''// 默认使用 application/json 形式axios.defaults.headers.post['Content-Type'] = 'application/json'axios.interceptors.request.use( config =&gt; &#123; return config; &#125;, error =&gt; &#123; console.log(error); return Promise.reject(); &#125;);axios.interceptors.response.use(res =&gt; &#123; if (typeof res.data !== 'object') &#123; Toast.fail('服务端异常！') return Promise.reject(res) &#125; if (res.data.resultCode != 200) &#123; if (res.data.message) Toast.fail(res.data.message) if (res.data.resultCode == 416) &#123; router.push(&#123; path: '/login' &#125;) &#125; return Promise.reject(res.data) &#125; return res.data&#125;)export default axios 针对后端API请求封装成Service的项目示例 https://github.com/lin-xin/vue-manage-system/blob/master/src/api/index.js——最简单的示范 https://github.com/ibwei/vue3-ts-base","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"https://nymrli.top/tags/Vue/"}]},{"title":"GoodCSS记录","slug":"GoodCSS记录","date":"2021-11-29T07:03:44.000Z","updated":"2021-12-04T14:53:31.396Z","comments":true,"path":"2021/11/29/GoodCSS记录/","link":"","permalink":"https://nymrli.top/2021/11/29/GoodCSS记录/","excerpt":"","text":"GoodCss记录 图标四角反转： 通过 @keyframes 规则，您能够创建动画。 创建动画的原理是，将一套 CSS 样式逐渐变化为另一套样式。 12&gt; @keyframes animationname &#123;keyframes-selector &#123;css-styles;&#125;&#125;&gt; animationname 必需。定义动画的名称。 keyframes-selector 必需。动画时长的百分比。合法的值： 0-100% from（与 0% 相同） to（与 100% 相同） css-styles: 必需。一个或多个合法的 CSS 样式属性。 12345678910111213141516171819202122232425262728293031@keyframes flip &#123; 0% &#123; transform: rotateY(0); &#125; 25% &#123; transform: rotateY(180deg); &#125; 50% &#123; transform: rotateY(180deg) rotateX(180deg); &#125; 75% &#123; transform: rotateY(360deg) rotateX(180deg); &#125; 100% &#123; transform: rotateY(360deg) rotateX(360deg); &#125;&#125;[v-cloak] .logo &#123; position: relative; width: 3rem; height: 3rem; overflow: hidden; background-color: hsl(241, 99%, 70%); border-radius: 50%; animation: 2s flip infinite;&#125; 注： 采用animation需要将position设置为relative 方形变圆形： 12width: 3rem;height: 3rem;border-radius: 50%; 元素在容器中正居中——Flex 12345678[v-cloak] .placeholder &#123; display: flex; // flex布局 flex-direction: column; // 元素堆叠方向, 这个无所谓, 主要的是下面两个 align-items: center; // 水平居中 justify-content: center; // 垂直居中 width: 100%; height: 100%;&#125; 放置项居中 123456.test&#123; height: 80vh; // 找到个居中的高度 weight: 100%; display: grid; place-items: center center; // 水平居中&#125; from: https://www.bilibili.com/video/BV1Zr4y1r7bx 选择器 :after 选择器向选定元素的最后子元素后面插入内容。使用content 属性来指定要插入的内容。 ::after针对所有元素的:after 123456p:after&#123; content:\"- 台词\";&#125;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;对于在 IE8 中工作的 :after，必须声明 DOCTYPE。&lt;/p&gt; :selection：针对被选择后 123::selection &#123; background: rgba(var.$color-text, 0.15); // hsl为拾色器&#125; 布局 BOX 传统布局基于盒状模型，依赖 display 属性 + position属性 + float属性。 它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 Flex 2009年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称&quot;项目&quot;。 容器的属性: flex-direction: flex-direction属性决定主轴的方向（即项目的排列方向）。 flex-direction: row | row-reverse | column | column-reverse; flex-wrap: 默认情况下，项目都排在一条线（又称&quot;轴线&quot;）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap | wrap | wrap-reverse; flex-flow justify-content: 定义了项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around; space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items: 定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; align-content: 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content: flex-start | flex-end | center | space-between | space-around | stretch; 项目属性 order: 定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow: 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink: 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间大小（main size） flex: 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 ▲align-self: 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch; 项目布局经典样例 vue、Layout 布局、Layout 属性事件、vue Layout 全部布局、vue Layout 全部属性事件 组件库 Vue2 muse-ui Vue3 引入 Antd for Vue3 版本组件库 Antdv2.x是唐金州老师（杭州校宝在线）研发的新一代适配 Vue 3.0 的组件库，我们来尝尝鲜，这边我们通过如下命令后下载： elementUI： 饿了么的vue组件库-&gt;Vue2 LayoutUI: 使用jquery实现的组件库 elementPlus: 饿了么的vue组件库-&gt;Vue3 Bootstrap-Vue UI组件库: Bootstrap-VUE提供了基于vue2的Bootstrap V4组件和网格系统的实现 Ant Design Vue UI组件库: Ant Design Vue是 Ant Design 3.X 的 Vue 实现，开发和服务于企业级后台产品。 iView： 一套基于 Vue.js 的高质量UI 组件库 Naive UI Radon UI： 一个帮助你快速开发产品的Vue组件库，简洁好用，效率高，让你摆脱各种定制化的烦恼。 Vue Antd：这里是 Ant Design 的 Vue 实现，开发和服务于企业级后台产品。 Vuetify: Vuetify是一个渐进式的框架，试图推动前端开发发展到一个新的水平。Vuetify 支持SSR（服务端渲染），SPA（单页应用程序），PWA（渐进式Web应用程序）和标准HTML页面。 移动端： Vant UI组件库: Vant是一个轻量、可靠的移动端 Vue 组件库。 Mint UI组件库: Mint UI基于 Vue.js 的移动端组件库，同样出自饿了么前端的项目。 小程序： mpvue 框架 iview UI vanz UI Vue结合TailwindCss(css框架) 安装yarn add tailwindcss@1.4.6 在 src/assets 新建 css 文件夹，并新建 tailwind.css (文件名随便，下面保持一致即可) 在 tailwind.css 文件中，添加如下内容: 123@tailwind base;@tailwind components;@tailwind utilities; main.js引入import “./assets/css/tailwind.css” 123import \"./assets/css/tailwind.css\"or import \"@/assets/css/tailwind.css\" 创建 Tailwind 配置文件(使用默认即可): npx tailwind init or npx tailwind init --full 新建 postcss.config.js 文件 1234567891011121314151617181920const purgecss = require('@fullhuman/postcss-purgecss')(&#123; content: [ './src/**/*.html', './src/**/*.vue', './src/**/*.jsx', ], // Include any special characters you're using in this regular expression defaultExtractor: content =&gt; content.match(/[\\w-/:]+(?&lt;!:)/g) || [] &#125;) module.exports = &#123; plugins: [ require('tailwindcss'), require('autoprefixer'), ...process.env.NODE_ENV === 'production' ? [purgecss] : [] ] &#125; 项目导航栏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;template&gt; // 先将组件用一个div作为容器固定起来, 并设置为relative, 之后就可以通过absolute进行定位了 &lt;div class=&quot;container&quot;&gt; &lt;n-layout position=&quot;absolute&quot;&gt; &lt;Header class=&quot;header&quot; :inverted=&quot;inverted&quot; @toggleInverd=&quot;toggleInverd&quot; /&gt; &lt;n-layout has-sider position=&quot;absolute&quot; class=&quot;content&quot;&gt; &lt;Sidebar :inverted=&quot;inverted&quot; /&gt; &lt;n-layout content-style=&quot;padding: 24px;&quot;&gt; &lt;Breadcrumb /&gt; &lt;n-message-provider&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/n-message-provider&gt; &lt;/n-layout&gt; &lt;/n-layout&gt; &lt;/n-layout&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; defineComponent, ref &#125; from &quot;vue&quot;; import Sidebar from &quot;../components/Sider/index.vue&quot;; import Header from &quot;../components/Header/index.vue&quot;; import Breadcrumb from &quot;./Breadcrumb/index.vue&quot;; export default defineComponent(&#123; name: &quot;App&quot;, components: &#123; Sidebar, Header, Breadcrumb &#125;, setup() &#123; let inverted = ref(false); const toggleInverd = (value) =&gt; &#123; inverted.value = value; &#125;; return &#123; inverted, toggleInverd, &#125;; &#125;, &#125;);&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt; .container &#123; position: relative; height: 100vh; .header &#123; height: 60px; &#125; .content &#123; min-height: calc(100vh - 56px); top: 56px; bottom: 56px; &#125; &#125;&lt;/style&gt;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"}]},{"title":"Vue3初体验","slug":"Vue3初体验","date":"2021-11-28T09:44:53.000Z","updated":"2022-03-29T12:48:01.334Z","comments":true,"path":"2021/11/28/Vue3初体验/","link":"","permalink":"https://nymrli.top/2021/11/28/Vue3初体验/","excerpt":"","text":"Vue3于2020年09月18日正式发布，映入我视野的新东西除了Vue3以外，还有yarn和vite。他们两个本身的功能并不是新东西，yarn对标的是npm包管理工具，vite对标的webpack包打包工具。 与vue2不同的是，vue3工程中没有 build 文件， 相应的build/index.js的配置改由了项目根目录下vue.config.js承担 Vue3新特性 template标签下面可以有多个节点了，终于不用先写一个DIV了 setup函数可以代替之前的data，methods，computed，watch，Mounted等对象，但是props声明还是在外面。 相比于Vue采用的OPTIONS API，Vue3使用的为Composition-API vue3.0允许一个组件有多个根节点 创建一个组件：通常，我们通过在最外层包裹一层 div 来创建一个组件，但这个div元素一般没有任何使用价值，就只是让模板符合单根需求。 123456&lt;template&gt; &lt;div&gt; &lt;!--只是来包装一下, 如果不加这一行会报错--&gt; &lt;div&gt;Node 1&lt;/div&gt; &lt;div&gt;Node 2&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 但在Vue3中支持多根即多个&lt;div&gt;、 甚至不写div也没问题 12345678&lt;template&gt; &lt;div&gt; &#123;&#123; msg1 &#125;&#125; &lt;/div&gt; &lt;div&gt; &#123;&#123; msg2 &#125;&#125; &lt;/div&gt;&lt;/template&gt; 原因是Vue.js 3.0 支持了 Fragments 的语法，具体原理没分析。 Composition-Api setup() 函数 一组低侵入式的、函数式的 API，使得我们能够更灵活地「组合」组件的逻辑。 在学习 Composition-Api 之前，我们需要先了解一下 setup() 函数。 setup() 是 Vue3 中的新增内容。它为基于 Composition API 的新特性提供了统一的入口。 在Vue3中，定义 methods、watch、computed、data数据 等都放在了 setup() 函数中 执行时机 setup()函数会在created()生命周期之前执行。 参数 setup() 函数的第一个参数是 props ，组件接收的 props 数据可以在 setup() 函数内访问到。 context 是 setup() 的第二个参数，它是一个上下文对象，可以通过 context 来访问Vue的实例 this 。 注意：在 setup() 函数中访问不到Vue的 this 实例， 需要通过context来取 具体函数 数据 在Vue2.x的版本中，我们只需要在 data() 中定义一个数据就能将它变为响应式数据，在 Vue3.0 中，需要用 reactive 函数或者 ref 来创建响应式数据。 reactive() reactive() 函数接收一个普通的对象，返回出一个响应式对象。 123456789101112// 在组件库中引入 reactiveimport &#123; reactive &#125; from '@vue/ composition-api'setup() &#123; // 创建响应式对象 const state = reactive(&#123; count:0 &#125;); // 将响应式对象return出去，暴露给模板使用 return state;&#125; ref() ref() 函数可以根据给定的值来创建一个响应式的数据对象，返回值是一个对象，且只包含一个 .value 属性。 1234567891011// 引入 refimport &#123; ref &#125; from '@vue/composition-api'setup() &#123; // 创建响应式对象 const count = ref(0); return &#123; count &#125;&#125; ref 的注意事项 在 setup() 函数内，由 ref() 创建的响应式数据返回的是对象，所以需要用 .value 来访问； 而在 setup() 函数外部则不需要 .value ，直接访问即可。 ==&gt; &lt;template&gt;中直接使用响应式数据: 响应式对象里面如果有ref包装的值类型。则Vue会实现自动拆箱 可以在 reactive 对象中访问 ref() 函数创建的响应式数据。 新的 ref() 会覆盖旧的 ref() 。 选择 reactive 还是 ref 如， new Date().getMonth()返回的是Number， 通过const m = ref(new Date().getMonth())可以直接拆包获得值，而不是使用reactive。但需要 注意的是，使用m的时候，应该使用m.value reactive无需.value来获得值，而是直接通过xx.prop获取即可 Vue3 —— 创建响应式数据使用 reactive 还是 ref ？（本周更新） computed() computed() 用来创建计算属性，返回值是一个 ref() 实例。按照惯例，使用前需要先引入。 computed创建只读计算属性 1234567const count = ref(1)// 创建一个计算属性，使其值比 count 大 1const bigCount = computed(() =&gt; count.value + 1) // 即如果只有一个函数，且没有声明是get还是set默认为get只读console.log(bigCount.value) // 输出 2bigCount.value++ // error 不可写 computed创建可读可写计算属性 1234567891011121314151617const count = ref(1)// 创建一个 computed 计算属性，传入一个对象const bigCount = computed(&#123; // 取值函数 get: () =&gt; (count.value + 1), // 赋值函数 set: val =&gt; &#123; count.value = val - 1 &#125;&#125;)// 给计算属性赋值的操作，会触发 set 函数bigCount.value = 9// 触发 set 函数后，count 的值会被更新console.log(count.value) // 8 readonly() 传入一个响应式对象、普通对象或 ref ，返回一个只读的对象代理。这个代理是深层次的，对象内部的数据也是只读的。 123const state = reactive(&#123; count: 0 &#125;)const copy = readonly(state) 函数 以前是写在methods对象中，现在是声明函数后放回 侦听 watch() composition-api 中的 watch 和 Vue2.x 中是一样的，watch 需要侦听数据，并执行它的侦听回调。默认情况下初次渲染不执行。 应用场景： 监听路由变化（路由变化的监听在Vue生命周期函数中实现都不合适，放watch中比较合适） 1234567891011121314// 侦听一个 getterconst state = reactive(&#123; count: 0 &#125;)watch( () =&gt; state.count, (count, prevCount) =&gt; &#123; /* ... */ &#125;)// 直接侦听一个 refconst count = ref(0)watch(count, (count, prevCount) =&gt; &#123; /* ... */&#125;) watch 与 watchEffect 的不同 watch 初次渲染不执行 watch 侦听的更具体 watch 可以访问侦听数据变化前后的值 from: Vue3 的新特性(二) —— Composition-Api 总结: Composition API 的入口在 setup() 函数中 reactive 响应式对象 ref 接收一个参数并返回响应式对象 原先在 Vue2 中的 methods，watch，component、data 均写在 setup() 函数，使用之前需要自行导入 回归了 function xxx 定义函数 注： OnMounted()、watch()、computed()中间传的都是匿名函数，而不是对象 在setup中取值不能使用this, this在composition中是undefine. 所以vue2代码用到vue3中时得把this删了(比如function), data的话还得加.value 双向绑定的变量在setup中定义时要加ref，修改变量的值时要加value Vue2-&gt;Vue3废弃的API filters过滤器：由于 1&lt;p&gt;&#123;&#123; accountBalance | currencyUSD &#125;&#125;&lt;/p&gt; 打破了大括号内的表达式“只是 JavaScript”的假设，这不仅有学习成本，而且有实现成本。==&gt;在 3.x 中，过滤器已移除，且不再支持。取而代之的是，我们建议用方法调用或计算属性来替换它们。 Vue optionalAPI可以使用 this.$store.state 12345678910computed: &#123; isLoginOpen() &#123; return this.$store.state.isLoginOpen; &#125;, &#125;,methods:&#123; close() &#123; this.$store.commit(\"setLoginModal\", false); &#125;,&#125; this.$refs 1this.$refs.emailRef.focus this.$data this.$axios 附录 导入vuex和vue-router vue-router使用 yarn add vue-router@next --dev, 参数说明packageName@tagorpackageName@version 创建router/index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344import &#123; createRouter, createWebHistory &#125; from \"vue-router\";import ShowList from \"../components/ShowList.vue\"const router = createRouter(&#123; history: createWebHistory(), routes: [ &#123; path: \"/show\", component: ShowList &#125;, &#123; path: \"/login\", name: \"Login\", newB: \"yes\", // 还可以自定义对象的属性值, 方便之后获取import routes from \"@/router/routes\"; ==&gt; 如naive的菜单组件中是要获得key的, 这边就可以绑定个key meta: &#123; title: '登录' &#125;, // 懒加载 component: () =&gt; import ( /* webpackChunkName: \"login\" */ \"../views/Login.vue\") &#125;,&#123; path: '/user/:id', // 如/user/111, router-link to=\"/user/111\"也行。注id为params参数, User.vue中通过 &#123;&#123; $route.params.id &#125;&#125; 获取 components: &#123; default: User, sidebar: Sidebar &#125;, /**在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。可以使用 props 将组件和路由解耦：这样你便可以在任何地方使用该组件，使得该组件更易于重用和测试。 */ props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;)router.beforeEach((to, from, next) =&gt; &#123; document.title = `$&#123;to.meta.title&#125; | vue-manage-system`; const role = localStorage.getItem('ms_username'); if (!role &amp;&amp; to.path !== '/login') &#123; next('/login'); &#125; else if (to.meta.permission) &#123; // 如果是管理员权限则可进入，这里只是简单的模拟管理员权限而已 role === 'admin' ? next() : next('/403'); &#125; else &#123; next(); &#125;&#125;);export default router app下进行router跳转 12345678910111213&lt;template&gt; &lt;div id=\"app\"&gt; &lt;div&gt; // 下面的叫声明式 &lt;router-link to=\"/\"&gt;Home&lt;/router-link&gt; | &lt;router-link to=\"/show\"&gt;show&lt;/router-link&gt;| &lt;router-link to=\"/hello\"&gt;hello&lt;/router-link&gt;| &lt;router-link :to=\"&#123;name: 'antd', params: &#123; id: 2 &#125;&#125;\"&gt;antd&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; router-link 实现路由之间的跳转，如点击show超链接则会跳转到http://localhost:8080/show 123456789101112&gt; &lt;!-- 字符串 --&gt;&gt; &lt;router-link to=\"home\"&gt;Home&lt;/router-link&gt;&gt; &lt;!-- 渲染结果 --&gt;&gt; &lt;a href=\"home\"&gt;Home&lt;/a&gt;&gt; &gt; &lt;!-- 同上 --&gt;&gt; &lt;router-link :to=\"&#123; path: 'home' &#125;\"&gt;Home&lt;/router-link&gt;&gt; &lt;!-- 命名的路由 --&gt;&gt; &lt;router-link :to=\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"&gt;User&lt;/router-link&gt;&gt; &lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;&gt; &lt;router-link :to=\"&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;\"&gt;Register&lt;/router-link&gt;&gt; 视图：router-view 当路由的path 与访问的地址相符时，会将指定的组件内容替换该 router-view，如果不点击而是直接将URL换成http://localhost:8080/show也会显示ShowList.vue的内容（为什么是ShowList.vue？是因为router/index.js中将path=''/show'与ShowList.vue绑定了） 命名视图 子vue中点击按钮后进行router跳转 12345678910111213141516171819202122232425262728293031323334 // vue2写法 function submitForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; this.$router.push(&#123;name: \"Mainwithout\", params: &#123;name: this.form.name&#125;&#125;) // 如果要传参，则为router-name；如果不传参直接push(path) sessionStorage.setItem(\"isLogin\", true) this.$store.dispatch(\"asyncUpdateUser\", &#123;name: this.form.name&#125;) console.log(\"enter\", this.$store.state) &#125; else &#123; this.$message.error('错了哦，这是一条错误消息'); return false; &#125; &#125;); &#125; // vue3写法：Vue-router 4.x为此提供了useRoute()：import &#123;useRouter&#125; from 'vue-router'setup(props,ctx)&#123; //router是全局路由对象，route= userRoute()是当前路由对象 let router = useRouter(); let start = () =&gt; &#123; // 这个叫编程式 router.push(&#123; //传递参数使用query的话，指定path或者name都行，但使用params的话，只能使用name指定 path:'/home', query:&#123; num:1 &#125; &#125;) &#125; onMounted(() =&gt; &#123; const id = router.params.id &#125;)&#125; 编程式调用方式： 123456789101112131415// 字符串router.push('home')// 对象router.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: '123' &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;)// ▲注：同样的规则也适用于 router-link 组件的 to 属性。router.replace(location, onComplete?, onAbort?)// 跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。router.go(n)// 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。 更多 $router : 是路由操作对象，只写对象 $route : 路由信息对象，只读对象 123456789101112//操作 路由跳转this.$router.push(&#123; name:'hello', params:&#123; name:'word', age:'11' &#125;&#125;)//读取 路由参数接收this.name = this.$route.params.name;this.age = this.$route.params.age; query传参要用path来引入，params传参要用name来引入 1234567891011121314151617181920212223242526272829303132333435363738394041// path+query==&gt; /second?queryId=2222&amp;queryName=query//query传参，使用name跳转this.$router.push(&#123; name:'second', query: &#123; queryId:'20180822', queryName: 'query' &#125;&#125;)//query传参，使用path跳转this.$router.push(&#123; path:'second', query: &#123; queryId:'20180822', queryName: 'query' &#125;&#125;)//query传参接收this.queryName = this.$route.query.queryName;this.queryId = this.$route.query.queryId;/** ---------------------- **/// name+params==&gt; /second/20180822/query， 更多见：https://router.vuejs.org/zh/guide/essentials/named-routes.htmlthis.$router.push(&#123; name:'second', params: &#123; id:'20180822', name: 'query' &#125;&#125;)//params接收参数， 是$routethis.id = this.$route.params.id ;this.name = this.$route.params.name ;//路由&#123; path: '/second/:id/:name', name: 'second', component: () =&gt; import('@/view/second')&#125; params是路由的一部分, 必须要在路由后面添加参数名。query是拼接在url后面的参数，没有也没关系。 params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。（最重要的一点，params刷新会消失。query则不会） 12parmas：https://blog.csdn.net/xxxquery: https://blog.csdn.net?xxx from：https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html 采坑： 12:to=\"&#123;path:'invest/scattered',query: &#123;productId: list.id&#125;&#125;\"to=\"invest/scattered?productId=1\" // 如果不加冒号访问动态参数即to=\"&#123;path:'invest/scattered',query: &#123;productId: list.id&#125;&#125;\"，则会乱码 冒号可以传动态的参数(也可以传静态的)；不加冒号是静态的路径；动态路由也可以以静态路由的形式写，参数固定如:to=&quot;{name: 'antd', params: { id: 2 } }&quot;==&gt;to=&quot;/antd/2&quot;；参数为变量： 12&lt;router-link :to=&quot;&#123;name: &apos;antd&apos;, params: &#123; id: 2 &#125;&#125;&quot;&gt;antd&lt;/router-link&gt;&lt;router-link :to=&quot;`/antd/$&#123;uid&#125;`&quot;&gt;antd&lt;/router-link&gt; 更推荐指定url的写法，因为就不用考虑name还是path了 123456789101112131415// App.vue&lt;router-link :to=\"`/antd?name=mrli`\"&gt;antd&lt;/router-link&gt;// 要跳转的 Antd.vue&#123;&#123; $route.query.name &#125;&#125;// App.vue&lt;router-link :to=\"`/antd/3`\"&gt;antd&lt;/router-link&gt;// 要跳转的 Antd.vue&#123;&#123; $route.params.id &#125;&#125;// 还需要router/index.js中定义, 不然$route.params.id无法将那个值对应到id上&#123; path: \"/antd/:id\", name: \"antd\", component: AntdCom&#125;, from : Vue3实战系列：结合 Ant-Design-of-Vue 实践 Composition API 踩坑: 嵌套子路由无法直接通过URL访问：报错原因是GET http://localhost:3000/dashboard/src/main.js net::ERR_ABORTED 404 (Not Found) 后经过测试查明，createWebHashHistory是可以直接跳转的，但createWebHistory是不能直接跳到嵌套子路由的 vuex 安装yarn add vuex@next --dev 编写store/index.js文件 12345678910111213141516171819202122232425262728293031323334353637383940import &#123;createStore&#125; from 'vuex'export default createStore(&#123; state: &#123; tagsList: [], collapse: false &#125;, mutations: &#123; closeCurrentTag(state, data) &#123; for (let i = 0, len = state.tagsList.length; i &lt; len; i++) &#123; const item = state.tagsList[i]; if (item.path === data.$route.fullPath) &#123; if (i &lt; len - 1) &#123; data .$router .push(state.tagsList[i + 1].path); &#125; else if (i &gt; 0) &#123; data .$router .push(state.tagsList[i - 1].path); &#125; else &#123; data .$router .push(\"/\"); &#125; state .tagsList .splice(i, 1); break; &#125; &#125; &#125;, // 侧边栏折叠 handleCollapse(state, data) &#123; state.collapse = data; &#125; &#125;, actions: &#123;&#125;, modules: &#123;&#125;&#125;) 在组件中使用 123const collapseChage = () =&gt; &#123; store.commit(\"handleCollapse\", !collapse.value);&#125;; 分析Vue3项目 Vue Color Avatar index.js 中的 v-cloak 指令 首先yarn dev本地运行后进入页面，会有一个Loading, coming soon的页面加载过程，之后就会取消掉。然后在项目入口的index.html中看到了实现——v-cloak 功能：使用 v-cloak 指令设置样式，这些样式会在 Vue 实例编译结束时，从绑定的 HTML 元素上被移除。 场景：当网络较慢，网页还在加载 Vue.js ，而导致 Vue 来不及渲染，这时页面就会显示出 Vue 源代码(如下图)。我们可以使用 v-cloak 指令来解决这一问题。 我们使用 v-cloak 指令来解决屏幕闪动的问题吧O(∩_∩)O~，js 不变，在 div 中加入 v-cloak 指令。 1234// html&lt;div id=\"app\" v-cloak&gt; &#123;&#123;context&#125;&#125;&lt;/div&gt; 1234# css：[v-cloak]&#123; display: none;&#125; 使用 v-cloak 指令之后的效果（demo）： 在简单项目中，使用 v-cloak 指令是解决屏幕闪动的好方法。但在大型、工程化的项目中（webpack、vue-router）只有一个空的 div 元素，元素中的内容是通过路由挂载来实现的，这时我们就不需要用到 v-cloak 指令咯。 from: https://www.jianshu.com/p/f56cde007210 注：index.html中定义的元素，在Vue实例加载完成后，将都不会显示，因此比较适合用来做Loading页面 123456&lt;div id=\"app\" v-cloak&gt; &lt;div class=\"placeholder\"&gt; &lt;div class=\"logo\"&gt;&lt;/div&gt; &lt;div class=\"text\"&gt;Coming soon...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; toRefs+解包 12345678910111213141516setup()&#123; const data = reactive(&#123; name: '小皮', age: 18, year: computed(&#123; // 设置 getter 和 setter get: () =&gt; &#123; return 2020 - data.age &#125;, set: val =&gt; &#123; data.age = 2020 - val &#125; &#125;) &#125;) return &#123;...toRefs(data), changeAge, changeYear&#125;&#125; vue 3.0 给input 获取焦点 123456789101112131415161718// 给table 循环的input 点击的时候获取焦点// 1、给input 设置ref 属性&lt;el-input v-else ref=\"refInput\" @blur=\"(scope.row.code = !scope.row.code), changeBlur()\" v-model=\"scope.row[item.prop]\" :placeholder=\"'请输入内容' + item.label\"/&gt;// 1、给input的ref属性在setup中使用? 叫什么我不清楚const refInput =ref() //记得return 出去//事件触发 记得引入 nextTick from vueconst aaaa ()=&gt;&#123; nextTick(()=&gt;&#123; refInput.value.focus() &#125;)&#125; vue2中的写法，通过this.$ref.xxx.focus()来实现 12345678910111213141516 &lt;div&gt; //获取焦点主要就是定义一个ref &lt;input v-model=\"inputvalue\" ref=\"inputVal\"/&gt; &lt;button @click=\"addItem\"&gt;提交&lt;/button&gt; &lt;/div&gt; methods:&#123; //事件调用 addItem:function()&#123; //然后调用focus方法 this.$nextTick(()=&gt;&#123; this.$refs.inputVal.focus() &#125;) &#125; &#125; 关于import 默认情况下，JavaScript中在模块内的所有声明都是本地的，外部无法访问。如果需要公开模块中部分声明的内容，并让其它模块加以使用，这个时候就需要导出功能，最简单的方式是添加export关键字导出模块。 默认导出导入： 每个模块仅有一个default的导出，导出内容可以是一个function、class，object等。因为这种方式被当做主要的导出内容，导入方式最为简单。 ▲注意：由于一个模块仅仅只允许导出一个default对象，实际导出的是一个default命名的变量。 因此导入的时候import后的名字, 实际上是给这个default命名的导出暴露的内容进行重命名，所以import后可以是任意变量名称，且不需要{}。 named导出导入export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块(即暴露接口模块)对外接口的名称相同。 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 总结： 如果是默认导出export default则可以省略花括号，且import的模块名是随意的 如果是非export default导出的接口内容，在引用时须加花括号，且引用的模块名与导出时的命名必须相同 本质是因为：一个模块中只允许一个默认导出export default，但允许多个命名导出export; from 格式： Js import的具体查找规则为： ① 如果X是内置模块，则直接返回该模块。如require(‘http’)。 ② 如果X以./、/、../的相对路径开头，则 1. 根据X所在的父模块，确定X的绝对路径。 2. 将X当做文件，依次查找下面的文件，如果找到，则直接返回。 1. X 2. X.js 3. X.json 4. X.node 3. 将X当做目录，依次查找下面的文件，如果找到，则直接返回。 1. X/package.json(查找main字段中的文件，规则同上) 2. X/index.js 3. X/index.json 4. X/index.node ③ 如果X不带路径： 1. 根据X所在的父模块，确定X可能的安装目录。 2. 依次在每个目录中，将X当成文件名或目录名加载。 ④ “not found” 因此，以下三种效果都是一样的，都可以成功 123import router from './router/index.js' // 符合 `②21`import router from './router/index' // 符合 `②22`import router from './router' // 符合 `②32` 既然如此，那么肯定有先后顺序，因此，我们做个实验。main.js为根目录下有个vu.js(目标为②22), 还有个vu的文件夹，其中包含个index.js(目标为②32)。 12345678mrli@VM-4-7-ubuntu:~/import_test$ tree.├── main.js├── vu│ └── index.js└── vu.js1 directory, 3 files 注意：本地测试时是node运行，而Node和浏览器端所支持的模块规范不同。 条目 Node 浏览器 模块规范 CommonJS ES6 导出 modules.exports export, export default;modules.exports 引入 require import；require 在windows下用node编写的测试文件如下 123456789101112// main.jsa = require(\"./vu\")console.log(a)// vu.jsexports.a = 'root';// module.exports.a = 'root';// vu/index.jsexports.a = 'vu folder';// module.exports.a = 'vu folder'; 输出的结果为：显示为 同级目录xx.js优先级高于xx/index.js 12mrli@VM-4-7-ubuntu:~/import_test$ node main.js &#123; a: 'root' &#125; 参考： 详谈 import 路径 export报错SyntaxError: Unexpected token export JavaScript笔记（CommonJS规范，以及exports、module.exports和export、export default区别） 编写注意点： 如果是在函数体内写的语句是不需要分号分隔的，如 12345678910setup()&#123; onMounted(()=&gt;&#123; &#125;) functipon xxx()&#123; &#125; return &#123;&#125;&#125; 与之对应的是在对象体内，如 1234567891011var app = &#123; data() &#123; // 等价于 data: ()=&gt;&#123;&#125; &#125;, methods:&#123; &#125;, props:&#123; &#125;,&#125; 里面会出现键值对和必须要逗号分隔开 axios请求 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 直接每次从axios库中调用axios函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;div&gt; &lt;div&gt;mmmm&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import axios from 'axios' export default &#123; name: \"post\", created() &#123; /* post常用的请求数据（data）格式有两种： （1）applicition/json （2）form-data 表单提交（图片上传，文件上传） */ //第一种写法叫做post别名请求方法 // http://localhost:8080/static/data.json?id=1 // applicition/json 请求 let data = &#123; id: 1 &#125; axios.post('../../static/data.json', data) .then((res) =&gt; &#123; console.log('数据：', res); &#125;) //第二种写法 axios(&#123; method: 'post', url: '../../static/data.json', data: data, &#125;).then((res) =&gt; &#123; console.log('数据：', res) &#125;) // form-data 请求 let formData = new FormData() for (let key in data) &#123; formData.append(key, data[key]) &#125; axios.post('../../static/data.json', formData) .then((res) =&gt; &#123; console.log('数据：', res); &#125;) &#125;&#125;&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 结合 vue使用vue-axios npm install --save axios vue-axios vue-axios是按照vue插件的方式去写的。那么结合vue-axios，就可以去使用vue.use方法了 123456// 首先在主入口文件main.js中引用import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(VueAxios,axios); 之后就可以使用了，在组件文件中的methods里去使用了 1234567891011getNewsList()&#123; this.axios.get('api/getNewsList').then((response)=&gt;&#123; this.newsList=response.data.data; &#125;).catch((response)=&gt;&#123; console.log(response); &#125;) &#125;, axios 改写为 Vue 的原型属性 首先在主入口文件main.js中引用，之后挂在vue的原型链上 12import axios from 'axios'Vue.prototype.$axios= axios 在组件中使用 12345this.$axios.get('api/getNewsList').then((response)=&gt;&#123; this.newsList=response.data.data; &#125;).catch((response)=&gt;&#123; console.log(response); &#125;) 创建axios实例，并封装成工具类 12345678// utils/requests.jsimport axios from 'axios'// 创建axios实例const service = axios.create(&#123; baseURL: process.env.BASE_API, // api的base_url timeout: 5000 // 请求超时时间&#125;) 组件中直接import 123456789&lt;script&gt;import &#123; axios &#125; import \"./utils/requests.js\"axios.get('api/getNewsList').then((response)=&gt;&#123; this.newsList=response.data.data; &#125;).catch((response)=&gt;&#123; console.log(response); &#125;)&lt;/script&gt; axios进阶用法: 结合vuex再封装一层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import axios from 'axios'import &#123; Message &#125; from 'element-ui'import store from '@/store'import &#123; getToken &#125; from '@/utils/auth'// 创建axios实例const service = axios.create(&#123; baseURL: process.env.BASE_API, // api的base_url timeout: 5000 // 请求超时时间&#125;)// request拦截器service.interceptors.request.use(config =&gt; &#123; // Do something before request is sent if (store.getters.token) &#123; config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改 &#125; return config&#125;, error =&gt; &#123; // Do something with request error console.log(error) // for debug Promise.reject(error)&#125;)// respone拦截器service.interceptors.response.use( response =&gt; response, /** * 下面的注释为通过response自定义code来标示请求状态，当code返回如下情况为权限有问题，登出并返回到登录页 * 如通过xmlhttprequest 状态码标识 逻辑可写在下面error中 */ // const res = response.data; // if (res.code !== 20000) &#123; // Message(&#123; // message: res.message, // type: 'error', // duration: 5 * 1000 // &#125;); // // 50008:非法的token; 50012:其他客户端登录了; 50014:Token 过期了; // if (res.code === 50008 || res.code === 50012 || res.code === 50014) &#123; // MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', &#123; // confirmButtonText: '重新登录', // cancelButtonText: '取消', // type: 'warning' // &#125;).then(() =&gt; &#123; // store.dispatch('FedLogOut').then(() =&gt; &#123; // location.reload();// 为了重新实例化vue-router对象 避免bug // &#125;); // &#125;) // &#125; // return Promise.reject('error'); // &#125; else &#123; // return response.data; // &#125; error =&gt; &#123; console.log('err' + error)// for debug Message(&#123; message: error.message, type: 'error', duration: 5 * 1000 &#125;) return Promise.reject(error) &#125;)export default service 父子组件间通信 props, 父向子传递数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 父组件&lt;template&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt; // 这边传给子组件 :msg&lt;/template&gt;&lt;script&gt;import HelloWorld from &apos;./components/HelloWorld.vue&apos;export default &#123; name: &apos;App&apos;, components: &#123; HelloWorld &#125;&#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;onMounted&#125; from &quot;vue&quot;export default &#123; name: &apos;HelloWorld&apos;, props: &#123; // 需要指明接收的props msg: String // 变量类型 &#125;, setup(props)&#123; // 然后这边传入 onMounted(()=&gt;&#123; console.log(props) &#125;) &#125;&#125;&lt;/script&gt; &lt;style scoped lang=&quot;scss&quot;&gt; h3 &#123; margin: 40px 0 0;&#125;a &#123; color: $bg;&#125;&lt;/style&gt; provide和inject, 祖向孙传递数据 通常，当我们需要从父组件向子组件传递数据时，我们使用 props。想象一下这样的结构：有一些深度嵌套的组件，而深层的子组件只需要父组件的部分内容。在这种情况下，如果仍然将 prop 沿着组件链逐级传递下去，可能会很麻烦。 官方文档 父组件通过 provide 选项来提供数据， 12345678910// optional api写法provide: &#123; todoLength: this.todos.length // 将会导致错误 `Cannot read property 'length' of undefined`&#125;,// 要访问组件实例 property，我们需要将 provide 转换为**返回对象的函数**：provide() &#123; return &#123; todoLength: this.todos.length &#125;&#125;, ▲.处理响应性: Q: 默认情况下，provide/inject 绑定并不是响应式的 A: 我们可以通过传递一个 ref property 或 reactive 对象给 provide 来改变这种行为。在我们的例子中，如果我们想对祖先组件中的更改做出响应，我们需要为 provide 的 todoLength 分配一个组合式 API computed property： 123456789101112131415app.component('todo-list', &#123; // ... provide() &#123; return &#123; todoLength: Vue.computed(() =&gt; this.todos.length) &#125; &#125;&#125;)app.component('todo-list-statistics', &#123; inject: ['todoLength'], created() &#123; console.log(`Injected property: $&#123;this.todoLength.value&#125;`) // &gt; 注入的 property: 5 &#125;&#125;) 子组件通过 inject 选项来开始使用这些数据。 完整案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 父组件&lt;script&gt;import HelloWorld from &apos;./components/HelloWorld.vue&apos;import &#123; ref, provide &#125; from &quot;vue&quot;export default &#123; name: &apos;App&apos;, components: &#123; HelloWorld &#125;, setup()&#123; let a = ref(&quot;&quot;) provide(&apos;a&apos;, a); function show()&#123; console.log(a.value) &#125; return &#123; a, show &#125; &#125;&#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &#123;&#123;a&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;onMounted, inject&#125; from &quot;vue&quot;export default &#123; name: &apos;HelloWorld&apos;, props: &#123; msg: String &#125;, // inject: [&apos;a&apos;], 也可以这么写, 这样在选项中定义了的话就不需要在setup中写了 setup()&#123; let a = inject(&quot;a&quot;) return &#123; a &#125; &#125;&#125; optional写法: 1234567891011// 父组件, 要拿this必须写成方法, 不能写provide: &#123;a: \"45\"&#125;了provide ()&#123; return &#123; \"a\": this.a &#125;&#125;,data()&#123; return &#123; a: \"45\" &#125;&#125; emits，子向父传递事件 emits参数有俩种形式对象和数组，对象里面可以配置带校验emit事件，为null的时候代表不校验，校验的时候，会把emit事件的参数传到校验函数的参数里面 当校验函数不通过的时候，控制台会输出一个警告，但是emit事件会继续执行 记录一个坑：比如你emit事件的名称正好和原生事件的名字重复了，那么这个事件会执行俩次，那么配置了emits这个选项的话，就能很好的解决这个问题 子组件Emiter.vue 使用 emits: 列表声明从父组件继承来的事件 $emit: 抛出事件， 通知父组件处理 在子组件中，通过$emit()来触发事件 在父组件中，通过v-on来监听子组件事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 子组件&lt;template&gt; &lt;button @click=\"handleClick\"&gt;点击emit-click事件&lt;/button&gt; &lt;button @click=\"handleOpen\"&gt;点击emit-open事件&lt;/button&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import &#123;defineComponent&#125; from \"vue\";export default defineComponent(&#123; emits: &#123; // 不声明这个也行, 但会有提示emits event listeners (clickx) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the \"emits\" option. clickx: null, //click事件没有检验 open_show: (value) =&gt; &#123; if (typeof value === \"string\") &#123; return true; &#125; else &#123; return false; &#125; &#125;, &#125;, setup(props, &#123;emit&#125;) &#123; // 注意emit不是从vue中import的 const handleClick = function() &#123; emit(\"clickx\"); &#125;; const handleOpen = function() &#123; emit(\"open_show\", 1); // 1为传递的参数 &#125;; return &#123; handleClick, handleOpen, &#125;; &#125;, /** setup(props, context)&#123; const handleClick =function()&#123; context.emit(\"name\") &#125; &#125; **/ data() &#123; return &#123;&#125;; &#125;, methods: &#123;&#125;,&#125;);&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 父组件Emit.vue 12345678910111213141516171819202122232425&lt;template&gt; // 3. 指定侦听的事件为子传上来的clickx和open_show, 并为其指定回调函数 &lt;emiter @clickx=\"onClick\" @open_show=\"onOpen\"&gt;&lt;/emiter&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import &#123;defineComponent&#125; from \"vue\"; // 1. 需要导入子componentimport Emiter from \"@/components/Emiter.vue\";export default defineComponent(&#123; components: &#123; Emiter, // 2.注册子component，才能拿到emit传上来的open事件 &#125;, data() &#123; return &#123;&#125;; &#125;, methods: &#123; onClick() &#123; console.log(\"click me!\"); &#125;, onOpen() &#123; console.log(\"open me!\"); &#125;, &#125;,&#125;);&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 例子： 关于vue3.x中的emits的用法 父子组件通信方法 之 props/$emit【Vue面试题】 注意： 使用compositionAPI也是能有数据成员的比如props, name, emits 解决yarn全局安装模块后但仍提示无法找到命令的问题 如果使用yarn global add xxxx 安装了xxxx插件之后，但是在cmd窗口中仍然提示类似命令无法找到（Command not found）的错误（如@vue/cli后输入vue &lt;create&gt;没有提示，），一般是由于yarn的环境没有配置好。可以通过以下的方法，将yarn的环境配置环境中。 首先，先查看一下yarn的bin目录， windows输入yarn global bin=&gt;C:\\Users\\leon\\AppData\\Local\\Yarn\\bin然后将该路径加入到path中，对于windows中直接将该目录加入到path中。 在Linux中which yarn后，将结果填入到~/.bashrc中，如下格式：export PATH=$PATH:/usr/bin/yarn 导入scss 安装scss/sass,node-sass sass-loader sass 属于重要依赖，所以需-D而不是-S； 123npm install node-sass sass-loader sass -D# oryarn add node-sass sass-loader@8.0.2 sass 根路径下建立文件vue.config.js 下面这个(不加也没事) 123456789const path = require('path');module.exports = &#123; pluginOptions: &#123; 'style-resources-loader': &#123; preProcessor: 'scss', patterns: [] &#125; &#125;&#125; 还有人提供的全局配置，实测可以 1234567891011module.exports = &#123; css: &#123; loaderOptions: &#123; sass: &#123; prependData: `@import \"./assets/css/test.scss\";` // 等价于：prependData: `@import \"@/assets/style.scss\";` // 因为 配置中对import中的@进行了设置'@': resolve('src'),即@ 等价于 /src 这个目录 &#125; &#125; &#125;,&#125; 如果不需要全局配置，可以直接在某个组件下的style里加@import &quot;../assets/style.scss&quot;; 调用test 123456&lt;style lang=\"scss\" scoped&gt;$bg: red;.container &#123; background-color: $bg;&#125;&lt;/style&gt; from : vue 3.x - 安装scss/sass Syntax Error: TypeError: this.getOptions is not a function——sass-loader版本太高 vue3 vue.config.js 配置 使用Vue3特性的工程： ——较为基础的使用 ——略微复杂的前端工程, 采用vue3 compositionAPI ——采用vue2的optionalAPI vue.config.js模板配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// vue.config.js 配置说明//官方vue.config.js 参考文档 https://cli.vuejs.org/zh/config/#css-loaderoptions// 这里只列一部分，具体配置参考文档module.exports = &#123;//别名设置configureWebpack: &#123; resolve: &#123; alias: &#123; 'assets': '@/assets', 'components': '@/components', 'views': '@/views', &#125; &#125; &#125;, // 部署生产环境和开发环境下的URL。 // 默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上 //例如 https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 https://www.my-app.com/my-app/，则设置 baseUrl 为 /my-app/。 baseUrl: process.env.NODE_ENV === \"production\" ? \"./\" : \"/\", // outputDir: 在npm run build 或 yarn build 时 ，生成文件的目录名称（要和baseUrl的生产环境路径一致） outputDir: \"dist\", //用于放置生成的静态资源 (js、css、img、fonts) 的；（项目打包之后，静态资源会放在这个文件夹下） assetsDir: \"assets\", //指定生成的 index.html 的输出路径 (打包之后，改变系统默认的index.html的文件名) // indexPath: \"myIndex.html\", //默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。你可以通过将这个选项设为 false 来关闭文件名哈希。(false的时候就是让原来的文件名不改变) filenameHashing: false, // lintOnSave：&#123; type:Boolean default:true &#125; 问你是否使用eslint lintOnSave: true, //如果你想要在生产构建时禁用 eslint-loader，你可以用如下配置 // lintOnSave: process.env.NODE_ENV !== 'production', //是否使用包含运行时编译器的 Vue 构建版本。设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。(默认false) // runtimeCompiler: false, /** * 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。 * 打包之后发现map文件过大，项目文件体积很大，设置为false就可以不输出map文件 * map文件的作用在于：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。 * 有了map就可以像未加密的代码一样，准确的输出是哪一行哪一列有错。 * */ productionSourceMap: false, // 它支持webPack-dev-server的所有选项 devServer: &#123; host: \"localhost\", //也可以直接写IP地址这样方便真机测试 port: 8080, // 端口号 https: false, // https:&#123;type:Boolean&#125; open: true, //配置自动启动浏览器 // proxy: 'http://localhost:4000' // 配置跨域处理,只有一个代理 // 配置多个代理 proxy: &#123; \"/api\": &#123; target: \"&lt;url&gt;\", //写地址 ws: true, // 允许跨域 changeOrigin: true, //允许跨域 pathRewrite: &#123; \"^/api\": \"\" &#125; &#125;, \"/foo\": &#123; target: \"&lt;other_url&gt;\" &#125; &#125; &#125;&#125;; 前端技术栈 eslint-plugin-vue eslint-plugin-vue axios 强大的前端请求库 fues.js fues.js Fuzzy Search 前端模糊搜索 echart echart 数据可视化 antv antv 蚂蚁数据可视化 xlsx xlsx SheetJS jszip jszip 优秀的前端压缩库 mockjs mockjs 模拟和交互数据 wangeditor wangeditor 富文本编辑器 fullcalendar fullcalendar 丰富的日历插件 文章： 上手后才知道 ，Vue3 的 script setup 语法糖是真的爽","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"https://nymrli.top/tags/Vue/"}]},{"title":"前端-跨域","slug":"前端-跨域","date":"2021-11-26T09:17:15.000Z","updated":"2021-12-09T07:22:13.901Z","comments":true,"path":"2021/11/26/前端-跨域/","link":"","permalink":"https://nymrli.top/2021/11/26/前端-跨域/","excerpt":"","text":"什么是跨域问题 跨域问题的出现是因为浏览器的同源策略问题，所谓同源:就是两个页面具有相同的协议（protocol），主机（host）和端口号（port），即指协议，端口，域名。只要这个3个中有一个不同就是跨域。它是浏览器最核心也是最基本的功能，如果没有同源策略我们的浏览器将会十分的不安全，随时都可能受到攻击。 当我们请求一个接口的时候，出现如：Access-Control-Allow-Origin 字眼的时候说明请求跨域了 展示跨域问题 前端请求后端8889端口开放的端口 12345678this.$axios(&#123; method:'get', url:'http://localhost:8889/'&#125;).then((response) =&gt;&#123; //这里使用了ES6的语法 console.log(response) //请求成功返回的数据&#125;).catch((error) =&gt;&#123; console.log(error) //请求失败返回的数据&#125;) 会出现因为跨域，所以请求失败的消息 1Access to XMLHttpRequest at &apos;http://localhost:8889/&apos; from origin &apos;http://localhost:8080&apos; has been blocked by CORS policy: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. 处理跨域 前端 jsonp 123456789101112// 后端接口app.get(\"/\", function(req, res)&#123; var func = req.query.callback // 拿到请求参数query中的callback数据 res.send(func + \"('你好')\") // 拼接成函数调用的形式==》 f(\"你好\")&#125;)// 前端请求&lt;script&gt; function f(msg)&#123; alter(msg) &#125;&lt;/script&gt;&lt;script src=\"http://localhost:8999?callback=f\"&gt;&lt;/script&gt; // 请求这个接口的时候会得到f(\"你好\")的返回结果，从而触发调用函数 Proxy 通过网络代理，通过代理服务与另一个网络终端进行非直接的连接 通过webpack搭建一个本地服务器，作为请求的代理对象，通过该服务器转发请求至目标服务器。 但存在的问题是，如果webpack服务器与web接口服务器不在一起，仍然存在跨域问题。===&gt;由于生产环境基本上后端有后端部署的服务器、前端有前端部署的服务器，因此这个无法在生产上使用 Vue 开发阶段: 配置代理 如果你是用 Vue CLI 创建的项目，也可以开发阶段，配置一下 webpack 的 devServer，它有自带一个 proxy 代理服务器。 123456789101112131415161718// Vue3中是在vue.config.js配置module.exports = &#123; devServer:&#123; host: 'localhost', open: true, // vue项目启动时自动打开浏览器 port: 8080, // 本地服务器使用的端口 proxy: &#123; //配置跨域 '/api': &#123; // `/api`是代理标识，用于告诉node，url前面是`/api`的就是使用代理的 target: 'http://127.0.0.1:5000/', // 目标地址，应该写提供接口的后台服务器的真实地址 changOrigin: true, // 是否跨域 pathRewrite: &#123; '^/api': '' // 把实际request URL中的`/api`用``来代替 /* 重写路径，当我们在浏览器中看到请求的地址为：http://localhost:8080/api/core/getData/userInfo 时, 实际上访问的地址是：http://121.121.67.254:8185/core/getData/userInfo */ &#125; &#125;, &#125; &#125;&#125; 后端配置 1234567891011121314151617181920from flask import Flaskfrom flask_cors import cross_origin app = Flask(__name__) @app.route('/')def hello_world(): return 'Hello World!' @app.route('/api')def apix(): return 'Hello api!' @app.route('/do')@cross_origin()def api(): return 'Hello do!' if __name__ == '__main__': app.run() 访问http://localhost:8080/时会出现跨域问题，http://localhost:8080/api时浏览器直接跳转到后端内容 网络请求http://localhost:8080/do由于do接口允许跨域所以成功拿到数据, /api成功拿到Hello World实现跨域 为什么get(&quot;/api&quot;)拿到的是http://localhost:8080/的数据呢？首先拼接成http://localhost:8080/, 然后符合代理规则，所以根据pathRewrite吧/api替换成了&quot;&quot;，于是请求变成了访问http://localhost:8080/。再因为vue.config.vue中target指定了axios的目标url，会把http://localhost:8080代理掉，所以就代理转向访问了http://localhost:5000/ 注： 没有指定axios的baseURL则为本身, 会自动加上http://localhost 可以测试是不是这个逻辑，axios.get(&quot;/do&quot;), 提示http://localhost:8080/do不存在, 也不符合代理规则 axios.get(&quot;/&quot;), 虽然也不符合代理规则，但其本身http://localhost:8080/是有的, 所以也能请求到数据，只不过这个是index.html的数据 如果指定axios的baseURL=“http://baidu.com”，则xxx.get(&quot;/api&quot;)会变成http://baidu.com/api 生产环境: 配置nginx转发 服务器端 根据CORS的定义，是不允许浏览器调用的前端服务主动去拿另一个域下的资源，那么就改变前端服务直接拿的方式，而是通过请求代理服务器数据从而间接请求另一个域下的资源，代理服务器再请求到数据后，再让代理把数据交给前端即实现了跨域的效果。 ==》前端服务跟代理服务器是同源的，而nginx对服务端转发的请求不会触发浏览器的同源策略。 nginx 基础使用-简单版 123456789101112131415## 配置反向代理的参数server &#123; listen 8080; server_name xx_domain.com ## 1. 用户访问 http://xx_domain.com/api，则反向代理到 https://github.com/api location /api &#123; proxy_pass https://github.com; # 下面的不写也没事 proxy_redirect off; proxy_set_header Host $host; # 传递域名 proxy_set_header X-Real-IP $remote_addr; # 传递ip proxy_set_header X-Scheme $scheme; # 传递协议 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 这里是起了一个叫xx_domain的nginx服务器，侦听8080端口(一般是localhost)。 这边写的是xx_domain，则axios中也应该请求这个链接(baseURL设置为http://xx_domain.com) 更多操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 如下的是青龙的转发配置upstream api &#123; server 0.0.0.0:5600;&#125;map $http_upgrade $connection_upgrade &#123; default keep-alive; 'websocket' upgrade;&#125;server &#123; listen 5700; root /ql/dist; ssl_session_timeout 5m; location /api &#123; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://api; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; &#125; location /open &#123; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://api; &#125; gzip on; gzip_static on; gzip_types text/plain application/json application/javascript application/x-javascript text/css application/xml text/javascript; gzip_proxied any; gzip_vary on; gzip_comp_level 6; gzip_buffers 16 8k; gzip_http_version 1.0; location / &#123; index index.html index.htm; try_files $uri $uri/ /index.html; &#125;&#125; 后端 修改响应头 根据上述CORS反馈的消息No 'Access-Control-Allow-Origin' header is present on the requested resource.来看，是由于没有设置响应头Access-Control-Allow-Origin，因此其中一个做法是可以修改响应头中的Access-Control-Allow-Origin 1234app.get(\"/\", function(req, res)&#123; res.header(\"Access-Control-Allow-Origin\", \"*\") // 允许任何域的请求 res.send(\"你好\")&#125;) 还在相应的接口上添加@CrossOrigin表示允许跨域请求 可以看做是修改响应头的变种 12345678910@RestControllerpublic class InfoController &#123; @CrossOrigin @GetMapping(\"/\") public HashMap&lt;Object, Object&gt; getInfo() &#123; HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(\"cl\", 19); return hashMap; &#125;&#125; 附录 B站视频：【跨域请求】【前端】什么是CORS，教你解决跨域问题 采坑说明： CORS是浏览器的限制，而HbuilderX中内置的浏览器是没有跨域问题的，需要打开外部浏览器才能看到。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"}]},{"title":"党员在线培训课程~免除暂停烦恼","slug":"党员在线培训课程-免除暂停烦恼","date":"2021-11-25T02:48:17.000Z","updated":"2021-11-25T03:49:28.883Z","comments":true,"path":"2021/11/25/党员在线培训课程-免除暂停烦恼/","link":"","permalink":"https://nymrli.top/2021/11/25/党员在线培训课程-免除暂停烦恼/","excerpt":"","text":"党员在线培训课程~免除暂停烦恼 女朋友反馈：刷党员在线培训课程得一直手动的解决暂停问题，无法单纯的挂机刷视频。作为一个程序猿，当然是帮她解决啦~ 首先分析页面中JS执行逻辑，如下所示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193vpn_eval((function()&#123; $(\".video_lists\").animate(&#123;scrollTop: $(\".video_red1\").offset().top - 162&#125;, 1000); var loop_flag = \"\"; var timer = \"\"; var flag = false; var video = document.getElementById(\"video\"); // 续播定时器 function current_time() &#123; timer = setInterval(function () &#123; $.ajax(&#123; type: \"POST\", cache: false, dataType: \"json\", url: \"/ybdy/lesson/current_time\", data: &#123; rid: \"18612\", time: video.currentTime, _xsrf: $(\":input[name='_xsrf']\").val() &#125;, success: function (data) &#123; if (Number(data.code) == 0) &#123; player.pause(); var msg = \"系统监测到您有异常学习行为，本视频观看无效，请您重新进行该视频内容学习。\" public_alert(1, [\"我知道了\"], '&lt;i class=\"iconfont\"&gt;&amp;#xe633;&lt;/i&gt;&lt;p&gt;' + msg + '&lt;/p&gt;&lt;p&gt;&lt;/p&gt;', 'public_cont1', function () &#123; window.location.reload() &#125;); &#125; &#125; &#125;); &#125;, 30000); &#125; var hlsSupported = Hls.isSupported(); if (hlsSupported) &#123; try &#123; var isP2PSupported = p2pml.core.HybridLoader.isSupported(); &#125; catch (err) &#123; window.location.href = \"/static/browser_error.html?v=b57810c40053fbcd20af772b6b6c48b62499dd0ba8bf87bf775a937ad28d427fd99b65bec35bef2368fd1d5dcdbc7c8ed4478c72bbb8d4e35d58eab0fd40fab7\"; &#125; var engine = isP2PSupported ? new p2pml.hlsjs.Engine() : undefined; var player = new Plyr(video, &#123; captions: &#123; active: true, update: true &#125;, controls: ['play-large', 'play', 'current-time', 'mute', 'volume', 'fullscreen'], seekTime: 0 &#125;); var hls = new Hls(&#123; liveSyncDurationCount: 7, // To have at least 7 segments in queue loader: isP2PSupported ? engine.createLoaderClass() : Hls.DefaultConfig.loader &#125;); if (isP2PSupported) &#123; p2pml.hlsjs.initHlsJsPlayer(hls); &#125; // var videoSrc = 'http://video.dangqipiaopiao.com/m3u8/3cd74e54455e95c04db1e7dc0be2e95b/3cd74e54455e95c04db1e7dc0be2e95b.m3u8'; var videoSrc = '/m3u8/b451260fbb0f72b2e643308e6a6ac95c/b451260fbb0f72b2e643308e6a6ac95c.m3u8'; hls.loadSource(videoSrc); hls.attachMedia(video); layui.use(\"layer\", function () &#123; var layer = layui.layer; layer.load(2, &#123;shade: [0.5, 'grey']&#125;); player.on('loadedmetadata', function (event) &#123; layer.closeAll('loading'); if (\"\" != \"\") &#123; var r_time = parseInt(); hour = 0, minute = 0, second = 0; //时间默认值 hour = Math.floor(r_time / 60 / 60) &lt; 10 ? '0' + Math.floor(r_time / 60 / 60) : Math.floor(r_time / 60 / 60); minute = Math.floor(r_time / 60 % 60) &lt; 10 ? '0' + Math.floor(r_time / 60 % 60) : Math.floor(r_time / 60 % 60); second = Math.floor(r_time % 60) &lt; 10 ? '0' + Math.floor(r_time % 60) : Math.floor(r_time % 60); last_time = hour + \":\" + minute + \":\" + second; public_alert(2, [\"从头开始\", \"继续观看\"], '&lt;p class=\"i_player\"&gt;同学你好！该课程视频你上次观看到：' + last_time + '&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;', 'public_cont1', function () &#123; $(\".public_close\").click(); //此为关闭方法 player.play(); &#125;, function () &#123; $(\".public_close\").click(); //此为关闭方法 player.forward(parseInt()); player.play(); &#125;); &#125; else &#123; public_alert(1, [\"我知道了\"], '&lt;i class=\"iconfont\"&gt;&amp;#xe633;&lt;/i&gt;&lt;p&gt;您需要完整观看一遍课程视频，才能获取本课学时，看到视频播放完毕提示框即为完成，然后视频可以拖动播放。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;', 'public_cont1', function () &#123; $(\".public_close\").click(); //此为关闭方法 player.play(); &#125;); &#125; &#125;); &#125;); &#125; else &#123; window.location.href = \"/static/browser_error.html?v=b57810c40053fbcd20af772b6b6c48b62499dd0ba8bf87bf775a937ad28d427fd99b65bec35bef2368fd1d5dcdbc7c8ed4478c72bbb8d4e35d58eab0fd40fab7\"; &#125; player.on('ended', function (event) &#123; clearInterval(timer); //定时器清除； $.ajax(&#123; type: \"POST\", cache: false, dataType: \"json\", url: \"/ybdy/lesson/resource_record\", data: &#123; rid: \"815724\", resource_id: \"18612\", video_id: \"6782\", lesson_id: \"587\", _xsrf: $(\":input[name='_xsrf']\").val() &#125;, success: function (data) &#123; window.clearInterval(loop_flag); window.clearInterval(flag); if (Number(data.code) == 1) &#123; public_alert(1, [\"我知道了\"], '&lt;i class=\"iconfont\"&gt;&amp;#xe633;&lt;/i&gt;&lt;p&gt;当前视频播放完毕！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;', 'public_cont1', function () &#123; window.location.reload() &#125;); $(\".public_cont\").css(\"left\", \"40%\"); $('.plyr__controls').show(); &#125; else if (Number(data.code) == -1) &#123; var msg = \"系统监测到您有异常学习行为，本视频观看无效，请您重新进行该视频内容学习。\" public_alert(1, [\"我知道了\"], '&lt;i class=\"iconfont\"&gt;&amp;#xe633;&lt;/i&gt;&lt;p&gt;' + msg + '&lt;/p&gt;&lt;p&gt;&lt;/p&gt;', 'public_cont1', function () &#123; window.location.reload() &#125;); &#125; &#125; &#125;); &#125;); // 监听播放事件 player.on('play', function (event) &#123; current_time(); // studyTime(); loop_flag = setTimeout(\"loop_pause()\", 300000); &#125;); // 监听暂停事件 player.on('pause', function (event) &#123; window.clearTimeout(flag); clearInterval(timer); //定时器清除； &#125;); // 监听倍速播放，并重置为正常倍速 player.on('ratechange', function (event) &#123; if (player.media.playbackRate != 1) &#123; player.media.playbackRate = 1; &#125; &#125;); document.oncontextmenu = new Function(\"return false;\"); document.onkeydown = document.onkeyup = document.onkeypress = function (event) &#123; var e = event || window.event || arguments.callee.caller.arguments[0]; if (e &amp;&amp; e.keyCode == 123) &#123; e.returnValue = false; return (false); &#125; &#125; // 定期暂停方法 function loop_pause() &#123; player.pause(); public_alert(1, [\"继续\"], '&lt;i class=\"iconfont\"&gt;&amp;#xe633;&lt;/i&gt;&lt;p&gt;视频已暂停，点击按钮后继续学习！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;', 'public_cont1', function () &#123; $(\".public_close\").click(); //此为关闭方法 player.play(); &#125;); &#125;; document.addEventListener('visibilitychange', function () &#123; //浏览器切换事件 if (document.visibilityState == 'hidden') &#123; player.pause() &#125; else &#123; player.on('loadedmetadata', function (event) &#123; player.play() &#125;) &#125; &#125;);&#125;).toString().slice(12, -2),\"\"); Ways1： 手动模拟 暂停修改 可以看到导致不断暂停的原因是下面一段代码： 监听播放事件123456789101112131415player.on('play', function (event) &#123; current_time(); // studyTime(); loop_flag = setTimeout(\"loop_pause()\", 300000);&#125;);// 定期暂停方法function loop_pause() &#123; player.pause(); public_alert(1, [\"继续\"], '&lt;i class=\"iconfont\"&gt;&amp;#xe633;&lt;/i&gt;&lt;p&gt;视频已暂停，点击按钮后继续学习！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;', 'public_cont1', function () &#123; $(\".public_close\").click(); //此为关闭方法 player.play(); &#125;);&#125;; 即，点击播放器的播放后会启动一个300s执行的定时器，弹出窗口并暂停播放。为此我们可以通过clearTimeout(loop_flag)清除这个定时器 之后就不会弹出暂停啦。 倍速修改 可以从JS代码中看到还监听了播放器player的ratechange倍速事件，我们可以通过F12打开开发者工具移除这个Listener 123456// 监听倍速播放，并重置为正常倍速player.on('ratechange', function (event) &#123; if (player.media.playbackRate != 1) &#123; player.media.playbackRate = 1; &#125;&#125;); 倍速插件推荐：Video speed Controller 注： 经过测试，直接通过Video speed Controller调整倍速似乎不会被限制 ▲有意思的是，因为定时暂停的间隔是300s，因此如果16倍倍速播放后基本都可以在300内完成，这样就不需要删除暂停了 页面切换修改 可以从JS代码中看到还监听了浏览器的visibilitychange切换事件，我们可以通过F12打开开发者工具移除这个Listener 123456789document.addEventListener('visibilitychange', function () &#123; //浏览器切换事件 if (document.visibilityState == 'hidden') &#123; player.pause() &#125; else &#123; player.on('loadedmetadata', function (event) &#123; player.play() &#125;) &#125;&#125;); 播放进度修改 处理完您需要完整观看一遍课程视频，才能获取本课学时，看到视频播放完毕提示框即为完成，然后视频可以拖动播放。弹窗后，点击视频暂停、再播放，然后键盘输入9，将视频播放进度推到90%，然后再倍速放完。 ▲.综上： 个人采取的是[倍速播放]+[页面切换]+[播放进度拖拉]的方案 TODO Way2：通过模拟网络请求，直接过教程 可以看到每个视频结束后其实调用的是ended事件执行的函数，会发送一个POST请求 12345678910111213141516171819202122232425262728293031323334player.on('ended', function (event) &#123; clearInterval(timer); //定时器清除； $.ajax(&#123; type: \"POST\", cache: false, dataType: \"json\", url: \"/ybdy/lesson/resource_record\", data: &#123; rid: \"815724\", // different field resource_id: \"18612\", // different field video_id: \"6782\", // different field lesson_id: \"587\", // different field _xsrf: $(\":input[name='_xsrf']\").val() // different field &#125;, success: function (data) &#123; window.clearInterval(loop_flag); window.clearInterval(flag); if (Number(data.code) == 1) &#123; public_alert(1, [\"我知道了\"], '&lt;i class=\"iconfont\"&gt;&amp;#xe633;&lt;/i&gt;&lt;p&gt;当前视频播放完毕！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;', 'public_cont1', function () &#123; window.location.reload() &#125;); $(\".public_cont\").css(\"left\", \"40%\"); $('.plyr__controls').show(); &#125; else if (Number(data.code) == -1) &#123; var msg = \"系统监测到您有异常学习行为，本视频观看无效，请您重新进行该视频内容学习。\" public_alert(1, [\"我知道了\"], '&lt;i class=\"iconfont\"&gt;&amp;#xe633;&lt;/i&gt;&lt;p&gt;' + msg + '&lt;/p&gt;&lt;p&gt;&lt;/p&gt;', 'public_cont1', function () &#123; window.location.reload() &#125;); &#125; &#125; &#125;);&#125;); 请求并不复杂， 只不过因为女朋友自己已经看完挺多了，因此就不花费时间去弄这个了。感兴趣的小伙伴可以继续完成。 提供思路： 获取“我的课程”https://webvpn1.jiangnan.edu.cn/http/xxx/user/lesson`中所有课程内容List， (v_id不同) 再进入每一个课程学习，找到该课程学习下的子课程SubList， (r_id不同) 进入每个子课程，爬取具体页面https://webvpn1.jiangnan.edu.cn/http/77726476706e69737468656265737421f4e6518c693a6151700f87ad961b2631b52fa041/ybdy/play?v_id=7007&amp;r_id=19757&amp;r=video&amp;pg=#的页面内容，找到以下数据==&gt;end_data 1234567data: &#123; rid: \"815724\", // different field resource_id: \"18612\", // different field video_id: \"6782\", // different field lesson_id: \"587\", // different field _xsrf: $(\":input[name='_xsrf']\").val() // different field&#125;, 通过requests发送POST模拟请求，发送end_data数据 附 开发者工具修改Listener 针对指定的Listener点击相应事件右边的Remove按钮即可 注： 开发者工具最好不要关闭，等过完所有视频再关","categories":[],"tags":[]},{"title":"Linux iptables学习","slug":"Linux-iptables学习","date":"2021-11-04T14:22:24.000Z","updated":"2021-11-08T03:48:53.716Z","comments":true,"path":"2021/11/04/Linux-iptables学习/","link":"","permalink":"https://nymrli.top/2021/11/04/Linux-iptables学习/","excerpt":"","text":"iptables简介 ​ netfilter/iptables（简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。 注：Iptables和netfilter的关系是一个很容易让人搞不清的问题。很多的知道iptables却不知道 netfilter。其实iptables只是Linux防火墙的管理工具而已，位于/sbin/iptables。真正实现防火墙功能的是 netfilter，它是Linux内核中实现包过滤的内部结构。 iptables基础 规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息 包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规 则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如**放行（accept）、拒绝（reject）和丢弃（drop）**等。配置防火墙的 主要工作就是添加、修改和删除这些规则。 链和表 Iptables采用“表”和“链”的分层结构。在REHL4中是三张表五个链。现在REHL5成了四张表五个链了，不过多出来的那个表用的也不太多，所以基本还是和以前一样。 表（tables）：提供特定的功能，iptables内置了4个表，即filter表、nat表、mangle表和raw表，分别用于实现包过滤，网络地址转换、包重构(修改)和数据跟踪处理。 链（chains）：是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一 条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据 该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定 义的默认策略来处理数据包。 下面罗列一下这四张表和五个链。注意一定要明白这些表和链的关系及作用。 规则表： filter表——三个链：INPUT、FORWARD、OUTPUT 作用：过滤数据包 内核模块：iptables_filter. Nat表——三个链：PREROUTING、POSTROUTING、OUTPUT 作用：用于网络地址转换（IP、端口） 内核模块：iptable_nat Mangle表——五个链：PREROUTING、POSTROUTING、INPUT、OUTPUT、FORWARD 作用：修改数据包的服务类型、TTL、并且可以配置路由实现QOS内核模块：iptable_mangle(别看这个表这么麻烦，咱们设置策略时几乎都不会用到它) Raw表——两个链：OUTPUT、PREROUTING 作用：决定数据包是否被状态跟踪机制处理 内核模块：iptable_raw (这个是REHL4没有的，不过不用怕，用的不多) 规则链： INPUT——进来的数据包应用此规则链中的策略 OUTPUT——外出的数据包应用此规则链中的策略 FORWARD——转发数据包时应用此规则链中的策略（传递数据包到后端的计算机中，与NAT的table相关性较高） PREROUTING——对数据包作路由选择前应用此链中的规则 （记住！所有的数据包进来的时侯都先由这个链处理） POSTROUTING——对数据包作路由选择后应用此链中的规则 （所有的数据包出来的时侯都先由这个链处理） iptables的基本语法格式 iptables [-t 表名] 命令选项 ［链名］ ［条件匹配］ ［-j 目标动作或跳转］ 说明：表名、链名用于指定 iptables命令所操作的表和链；命令选项用于指定管理iptables规则的方式（比如：插入、增加、删除、查看等；条件匹配用于指定对符合什么样 条件的数据包进行处理；目标动作或跳转用于指定数据包的处理方式（比如允许通过、拒绝、丢弃、跳转（Jump）给其它链处理。 链上规则常用命令选项： 选 项 功 能 -A 在链尾添加防火墙规则 -D 删除防火墙规则，默认第一条 -I 插入防火墙规则，默认插在链头 -F 清空防火墙规则 -L 列出添加防火墙规则，按表分组 -S 列出添加防火墙规则，不分组 -R 替换防火墙规则 -Z 清空防火墙数据表统计信息 -P 设置链默认规则 -V 查看版本(version) -Z 将所有表的所有链的字节和数据包计数器清零 注：使用 -A 选项添加防火墙规则会将该规则追加到整个链的最后，而使用 -I 选项添加的防火墙规则则会默认插入到链中作为第一条规则。 链操作相关命令选项 选 项 shortHand 功 能 –new -N 创建用户自定义的链 –delete-chain -X 删除用户自定义的链 –rename-chain -E 修改链名 其他辅助功能命令选项 选 项 功 能 -V 查看版本(version) -Z 将所有表的所有链的字节和数据包计数器清零 具体可以通过iptables --help查看 iptables 命令常用条件匹配参数 及各自的功能如下表所示。 参数 功能 [!]-p 匹配协议，! 表示取反 [!]-s 匹配源地址 [!]-d 匹配目标地址 [!]-i 匹配入站网卡接口 [!]-o 匹配出站网卡接口 [!]–sport 匹配源端口 [!]–dport 匹配目标端口 [!]–src-range 匹配源地址范围 [!]–dst-range 匹配目标地址范围 [!]–limit 四配数据表速率 [!]–mac-source 匹配源MAC地址 [!]–sports 匹配源端口 [!]–dports 匹配目标端口 [!]–stste 匹配状态（INVALID、ESTABLISHED、NEW、RELATED) [!]–string 匹配应用层字串 -m 增加模块：-m mac --mac-source、iptables -m tcp：表示使用TCP模块的扩展功能（tcp扩展模块提供了 --dport, --tcp-flags, --sync等功能） -n 使用数字形式（numeric）显示输出结果 -v 查看规则表详细信息（verbose）的信息 -h 获取帮助（help） 防火墙处理数据包的四种方式(目标动作) 触发动作 功 能 ACCEPT 允许数据包通过 DROP 直接丢弃数据包，不给任何回应信息 REJECT 拒绝数据包通过，必要时会给数据发送端一个响应的信息。 LOG 在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则 DNAT 目标地址转换 SNAT 源地址转换 MASQUERADE 地址欺骗 REDIRECT 重定向 iptables传输数据包的过程 ① 当一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去。 ② 如果数据包就是进入本机的，它就会沿着图向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过OUTPUT链，然后到达POSTROUTING链输出。 ③ 如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过FORWARD链，然后到达POSTROUTING链输出。 iptables防火墙规则的保存与恢复 iptables-save把规则保存到文件中，再由目录rc.d下的脚本（/etc/rc.d/init.d/iptables）自动装载 使用命令iptables-save来保存规则。一般用: iptables-save &gt; /etc/sysconfig/iptables生成保存规则的文件 /etc/sysconfig/iptables，也可以用service iptables save它能把规则自动保存在/etc/sysconfig/iptables中。 当计算机启动时，rc.d下的脚本将用命令iptables-restore调用这个文件，从而就自动恢复了规则。 DNAT和SNAT 区分SNAT和DNAT 从定义来讲它们一个是源地址转换，一个是目标地址转换。都是地址转换的功能（NAT），将私有地址转换为公网地址。 要区分这两个功能可以简单的由连接发起者是谁来区分： 内部地址要访问公网上的服务时（如web访问），内部地址会主动发起连接，由路由器或者防火墙上的网关对内部地址做个地址转换，将内部地址的私有IP转换为公网的公有IP，网关的这个地址转换称为SNAT，主要用于内部共享IP访问外部。 当内部需要提供对外服务时（如对外发布web网站），外部地址发起主动连接，由路由器或者防火墙上的网关接收这个连接，然后将连接转换到内部，此过程是由带有公网IP的网关替代内部服务来接收外部的连接，然后在内部做地址转换，此转换称为DNAT，主要用于内部服务对外发布，外网通过统一提供的外网IP来访问内网服务时，DNAT找到内网中具体的IP上的对应服务。 **SNAT：**局域网共享一个公网IP接入lnternel，好处如下 保护内网用户安全，因为公网地址总有一些人恶意扫描，而内网地址在公网没有路由所以无法被扫描，能被扫描的只有防火墙这一台，这样就减少了被攻击的可能。 Ipv4地址匮乏，很多公司只有一个ipv4地址，但是却有几百个用户需要上网，这个时候就需要使用SNAT。 省钱，公网地址付费，使用SNAT只需要一个公网ip就可以满足几百人同时上网。 **DNAT：**向internel发布内网服务器 在内网中有服务器，如果想让公网用户访问有有两种方法。 配置双网卡，一网卡对内，一网卡对外；一般是高访问量的web服务器，为了避免占用网关的流量才这样做，使用不是很广泛。 内网web服务器，或是ftp服务器，为了用户在公网也可以访问，有不想买公网ip地址，采用DNAT方案。见iptables进行DNAT（目标地址转换） 参考： iptables详解 Linux iptables命令详解","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"浙江大学期末考试——Go语言","slug":"浙江大学期末考试——Go语言","date":"2021-11-02T13:52:53.000Z","updated":"2021-12-30T05:28:27.191Z","comments":true,"path":"2021/11/02/浙江大学期末考试——Go语言/","link":"","permalink":"https://nymrli.top/2021/11/02/浙江大学期末考试——Go语言/","excerpt":"","text":"浙江大学期末考试——Go语言 期末复习对学习知识的帮助是巨大的，相比于看视频，本篇点到为止的知识点形的期末复习笔记，我相信更能让人学会。我相信，只要把本笔记全部看完了必然就会Go了。如果你做到了但还没有学会Go，那你大可来找我/doge。 概论 指令：计算机的一个最基本的功能，如实现一次加法运算或实现一次大小的判别 计算机的指令系统：计算机所能实现的指令的集合 程序：一系列计算机指令的有序组合 算法： 求解特定问题的一组有限的操作序列 目的性：算法有运算结果，程序强调过程性 抽象性：算法独立于编程语言和指令系统 研究性：算法是理论研究，载体可以是伪码，文字，图片等，载体为某一编程语言时就是程序 基本特征： 有限性：一个算法在执行有限步之后必须会终止。 确定性：一个算法的每个步骤都必须精确地定义，可以严格地、无歧义地执行。 输入：一个算法在运行之前赋给它的量，或在运行过程中动态地赋给它的量。 输出：一个算法运行结束时的结果。 有效性：一个算法在运行过程中，所有运算必须是充分基本的，是可行的，原则上人们可以用笔和纸在有限的时间内精确地完成这些运算。 结构化程序设计 程序=算法+数据结构 ----获得图灵奖的Pascal之父Nicklaus Wirth 将复杂程序划分为若干个相互独立的模块 模块：一条语句（Statement）、一段程序或一个函数（子程序）等 结构化程序设计特点 自顶向下 模块化设计 结构化编码 OOP 封装和数据隐藏 继承和重用 多态性 GO 特性 静态编译型 语法强调少即是多 强调组合，更简洁的OOP Duck模型的非侵入式接口 原生支持并发编程 支持多种操作系统和体系结构的交叉编译 大量使用内置函数和接口来提高代码复用度 支持和C 语言相互调用的机制（CGO） 语言环境变量 $GOROOT GO 语言环境在计算机的安装位置 $GOPATH GO 语言工作目录，可以有多个 Go语言的源码文件有三大类： 命令源码文件，可执行的程序的入口 库源码文件，集中放置各种待被使用的程序实体 测试源码文件，用于对前两种源码文件中的程序实体的功能和性能进行测试 Go Token(标记) 关键字：25个 标识符：40个 分隔符 字面量 变量 变量代表某块内存区域 变量的使用包括两个分开的步骤：变量声明、变量赋值 变量声明后会立即分配存储空间 变量声明后会初始化为该类型的零值 同一代码块内不能多次声明同名变量 子代码块可声明父代码块同名变量，子遮盖父 变量未声明直接使用会出现编译错误 变量在函数中声明了但未使用也会出现编译错误 GO 是强类型语言，编译器会确认每个变量应有的类型，错误使用将引发错误 GO 是静态语言，但支持编译时自动推断类型 变量声明后需按对应类型赋值 变量声明赋值可以同时进行 变量声明赋值同时进行可以忽略类型，由编译器推断 可在函数内部使用 := 进行短类型声明赋值 注： 多变量同时赋值，只能在函数体内。a, b = 3, 4 短类型声明赋值,只能在函数体内。c := true 全局变量可以不被使用 123456789101112131415package mainimport \"fmt\"var a int = 1 //声明赋值同时进行//a =bool //错误赋值var b = 2 // 声明未加类型，自动推断类型a, b = 3, 4 //多变量同时赋值，只能在函数体内//c := true //短类型声明赋值,只能在函数体内func main() &#123; a, b = 3, 4 //多变量同时赋值，只能在函数体内 c := true //短类型声明赋值,只能在函数体内 fmt.Printf(\"a address: %v value: %v \\n\", &amp;a, a) fmt.Printf(\"b address: %v value: %v \\n\", &amp;b, b) fmt.Printf(\"c address: %v value: %v \\n\", &amp;c, c)&#125; iota枚举 Go里面的关键字iota，可以在声明enum时采用，它默认开始值是0，每调用一次加1： 123456789101112const( x = iota // x == 0 y = iota // y == 1 z = iota // z == 2 w // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用\"= iota\")const v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0const ( e, f, g = iota, iota, iota //e=0,f=0,g=0 iota在同一行值相同) 除非被显式设置为其它值或iota，每个const分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是iota，则它也被设置为iota。 语法 条件语句 if GO不支持 ?: 三元运算符 if 后面的条件不需要( ) if 可带一个初始化子语句用;跟条件分开 switch case 按照从上到下的顺序进行求值，直到找到匹配的项后执行并退出switch（除非使用fallthrough）。如果 switch 没有表达式，则对 true 进行匹配，因此，可以将 if else-if else 改写成一个 switch。 switch 一样可以带初始化子语句 switch 条件表达式不要求必须为整型，类型本身也可作条件判断 case 后的break 可以省略 多个case连在一起是为了满足连续的条件范围 也可以直接把多个case条件连在一起，在最后一个case写执行语句 12345678910111213141516171819202122var a = \"hello\"switch a &#123;case \"hello\": fmt.Println(1)case \"world\": fmt.Println(2)default: fmt.Println(0)&#125;// secondvar s = \"hello\"switch &#123;case s == \"hello\": fmt.Println(\"hello\") fallthroughcase s != \"world\": fmt.Println(\"world\")&#125;/**helloworld*/ 注：新编写的代码，不建议使用 fallthrough。 循环语句 for GO 的循环语句只有for ,没有while/do while ★：for 语句后面不能加( ) for语句的三个部分,省略任何一个时，分号不能省略 只留条件判断时，可以不用分号 （相当于while语句） 全部省略,变为无限循环 转移语句 break：语句用于跳出代码块或循环, 除了用在switch之外,还用于结束整个循环，不再进行循环条件判断 continue：语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环 标签 如果存在多重循环，默认情况下break语句和continue语句都只针对最内层循环。 所以Go提供了标签，标签允许指定跳出的循环 12345678910111213// 使用标签 flag := falseend: for i := 1; i &lt; 100; i++ &#123; for j := 1; j &lt; 100; j++ &#123; if i*j == 651 &#123; flag = true //一次跳出 break end &#125; &#125; &#125; fmt.Println(flag) 数据类型 分类 命名类型： 基础数据类型（整型、浮点型等） 用户自定义类型（type关键字定义的结构、接口等） 未命名类型 集合类型（数组、切片、映射等） 函数等 Bool类型 布尔值包括true、false，类型长度为1字节 布尔类型无法被其他类型赋值，也不支持类型转换 布尔类型不支持用0和1表示真假 注：由于 Go语言是强类型的语言，如果不满足自动转换的条件，则必须进行强制类型转换。（C/C++等语言有隐式类型转换，golang中没有，即无法自动强转） 字符类型 byte ，对应整型里的uint8 ，代表 ASCII 码一个字符 rune，对应整型里的int32 ，代表Unicode码一个字符 格式化输出时，可用%c 输出对应值，如 12//浙fmt.Printf(\"%c\",27993) 字符串类型 字符串类型string，采用UTF-8编码格式的不可改变的字符序列 字符串单行用双引号 ,多行可用反引号`，空格和缩进都会被保留 字符串标准库： strings包提供了很多操作字符串的简单函数 strconv包提供了基本数据类型和字符串之间的转换 regexp包提供了正则表达式功能 unicode包及其子包 utf8、utf16 中，提供了对 Unicode 相关编码、解码的支持 strings包 1234567891011// 子串 substr 在 s 中，返回 truefunc Contains(s, substr string) bool// chars 中任何一个 Unicode 代码点在 s 中，返回 truefunc ContainsAny(s, chars string) bool// Unicode 代码点 r 在 s 中，返回 truefunc ContainsRune(s string, r rune) bool/** 子串出现次数 */func Count(s, sep string) int// 字符串重复几次 func Repeat(s string, count int) string unicode 包主要包含3个部分： unicode ：基本的字符判断函数 utf8 ：负责 rune 和 byte 之间的转换 utf16 ：负责 rune 和 uint16 数组之间的转换 12345678910111213141516func IsControl(r rune) bool // 是否控制字符func IsDigit(r rune) bool // 是否阿拉伯数字字符，即 0-9func IsGraphic(r rune) bool // 是否图形字符func IsLetter(r rune) bool // 是否字母func IsLower(r rune) bool // 是否小写字符func IsMark(r rune) bool // 是否符号字符func IsNumber(r rune) bool // 是否数字字符，比如罗马数字Ⅷ也是数字字符func IsOneOf(ranges []*RangeTable, r rune) bool // 是否是 RangeTable 中的一个func IsPrint(r rune) bool // 是否可打印字符func IsPunct(r rune) bool // 是否标点符号func IsSpace(r rune) bool // 是否空格func IsSymbol(r rune) bool // 是否符号字符func IsTitle(r rune) bool // 是否 title casefunc IsUpper(r rune) bool // 是否大写字符func Is(rangeTab *RangeTable, r rune) bool // r 是否为 rangeTab 类型的字符func In(r rune, ranges ...*RangeTable) bool // r 是否为 ranges 中任意一个类型的字符 运算符 算术运算符 自增、自减，直支持a++，不支持++a ==&gt; 设计思想是保证只有一种写法 关系运算符 因为bool类型不能转为整型，所以不支持不等式连写：比如 x&lt;y&lt;z 这种语法是错误的 逻辑运算符 注意短路 赋值运算符 位运算符 注：Go中的运算优先级跟C不太一样，比如Go中位移运算符的优先级是高于算数运算符的，而C中相反 12345// c++ --&gt; 2int res = 1 + 4 &gt;&gt; 1;cout &lt;&lt; res &lt;&lt; endl;// go --&gt; 3println( 1 + 4 &gt;&gt; 1) 见： Go语言运算符的优先级 C++运算符优先级 集合数据类型 数组（Array） 数组是同类元素的集合，它的元素排列在连续的空间中，按下标来标记和访问 数组类型定义包括元素类型，数组长度（元素个数） 元素类型相同的两个数组，数组长度不同则类型不同，相互不能复制 数组变量声明后，其元素类型、数组长度均不可变 （定长性） 注：数组传参问题——实参拷贝一份给形参，二者相互独立，传递大数组时效率较低，尽量用指向数组的指针来传参 数组声明 12345678910111213141516//只声明未赋值//数组元素都被初始化为对应类型零值var arr1 [5]int//声明3个元素的整型数组//直接赋值arr2 := [3]int&#123;11, 12, 13&#125;//声明整型数组//直接赋值//数组长度由初始化值的数量来确定arr3 := [...]int&#123;11, 12, 13, 14, 15&#125; //...不可省略//声明4个元素的整型数组//对下标为0和3的元素直接赋值//其余元素保持零值arr4 := [4]int&#123;0: 99, 3: 100&#125;fmt.Printf(\"%v,%v,%v,%v\", arr1, arr2, arr3, arr4)//[0 0 0 0 0],[11 12 13],[11 12 13 14 15],[99 0 0 100] 切片（ Slice） 数组的定长性和值拷贝限制其使用 切片封装底层的数组，提供长度可变的数组引用 切片是引用类型，不支持==运算（除了nil) 切片包括三个变量 底层数组指针 切片当前长度 切片容量（小于等于底层数组长度，超过时要变更底层数组） 切片使用 123456789101112131415// 创建指定的底层数组，然后创建切片a := [5]int&#123;76, 77, 78, 79, 80&#125;s1 := a[0:4] // from a[0] to a[3]s2 := a[:4] // from a[0] to a[3]//不指定数组大小，同时创建匿名数组和返回切片引用 d := []int&#123;6, 7, 8&#125; // 直接通过make函数创建切片i := make([]int, 5, 5) // 为什么不用构造函数 // 切片动态增加sli = append(sli, 20)// 切片合并：内置函数 append() 还支持切片的合并，用...运算符把对应切片所有元素都取出veggies := []string&#123;\"potatoes\", \"tomatoes\", \"brinjal\"&#125;fruits := []string&#123;\"oranges\", \"apples\"&#125;food := append(veggies, fruits...) //... 不可忽略 语法糖... 1234567891011121314func MySum(p ...int) (sum int)&#123; // 第一个用法主要是用于函数有多个不定参数的情况，可以接受多个不确定数量的参数。 sum = 0 for _, v := range p&#123; sum += v &#125; return &#125; func main() &#123; arr := []int&#123;2,1,3&#125; i := MySum(arr...) // 第二个用法是将slice打散进行传递。 fmt.Printf(\"i: %v\\n\", i) &#125; 映射（ Map） 映射用于存储一系列无序的键值对 映射的键（key） 只支持值类型（可以使用==运算符作比较） 映射的值(value)不限制，但所有元素的值类型一致 GO 映射的底层实现是哈希数组链表，不是 C++的红黑树 注： 只声明不初始化的映射为nil值，未分配底层存储空间，不能添加元素 用字面量或make函数进行初始化后可以添加元素 即： 1234567891011121314var m1 map[string]intfmt.Println(m1 == nil)//true//m1[\"a\"] = 1 //errorm2 := map[string]int&#123;&#125;fmt.Println(m2 == nil)//falsem2[\"a\"] = 1 //okm3 := make(map[string]int)fmt.Println(m3 == nil)//falsem3[\"a\"] = 1 //ok Map映射元素查找 映射元素通过下标直接查找访问 存在对应key的，返回对应value 不存在对应key的，返回value 类型的零值 ==&gt; Q: 如果返回零值，那如何判断是否存在呢？ A:映射元素通过下标访问其实可以返回两个值 对应的value 对应的key是否存在的布尔值 映射元素删除：使用内置函数delete()删除映射元素，如delete(personSalary,&quot;steve&quot;) 二维映射map创建： 12345678910comEmp := map[string] map[string]int &#123; \"IBM\": &#123; \"steve\": 12000, \"jamie\": 15000, &#125;, \"HP\": &#123; \"mike\": 15000, \"joe\": 9000, &#125;,&#125; 若顶级类型只是一个类型名，你可以在文法的元素中省略它。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// demo1package mainimport \"fmt\"type Vertex struct &#123; Lat, Long float64&#125;var m = map[string]Vertex&#123; \"Bell Labs\": &#123;40.68433, -74.39967&#125;, \"Google\": &#123;37.42202, -122.08408&#125;,&#125;func main() &#123; fmt.Println(m)&#125;// demo2.package mainimport \"fmt\"import \"strconv\"type IPAddr [4]byte// TODO: 给 IPAddr 添加一个 \"String() string\" 方法func (f IPAddr) String() string &#123; str := \"\" for _ ,v:= range f&#123; if str !=\"\" &#123; str += \",\" &#125; fmt.Printf(strconv.Itoa(int(v))) str += strconv.Itoa(int(v)) &#125; return str&#125;func main() &#123; hosts := map[string]IPAddr&#123; \"loopback\": &#123;127, 0, 0, 1&#125;, \"googleDNS\": &#123;8, 8, 8, 8&#125;, &#125; for name, ip := range hosts &#123; fmt.Printf(\"%v: %v\\n\", name, ip) &#125;&#125; 函数 概念： 函数是程序执行的基本语法结构： 函数或方法编译成程序体代码区的一段指令序列 进程执行模型大多基于“栈堆” 函数抽象逻辑模块 通过函数调用函数,层层叠叠的函数构成树结构组织代码 函数效率高则程序效率高，建议多用标准库函数 函数为第一等公民（与其他数据类型地位平等） 赋值给变量 作为参数传递给其他函数 作为函数的结果被返回 支持闭包 语法格式： 123func add(a, b int) int &#123; return a + b&#125; 函数可以有多个返回值 返回值可以有变量名 不支持函数重载 函数参数： 参数传递方式都是值拷贝 形参与实参是值传递时，形参的变化不影响实参 形参与实参传递指针时，形参的变化有可能会影响实参 ===&gt; 注意：引用类型其实传的就是指针 不支持默认值参数 不定参数 不定参数，形参数目可变、不确定 不定参数声明语法格式：param … type 不定参数类型必须相同 不定参数必须是函数的最后一个参数 不定参数的形参在函数内是切片 切片传递给不定参数时，要用…运算符取出各元素 ==&gt;多于函数定参数的参数将会被放到不定参数中 123456789101112131415161718192021222324252627282930//不定参数函数func sum(items ...int) (sum int) &#123; for _, v := range items &#123; //items 相当于切片 sum += v &#125; return&#125;//切片参数函数func sumS(items []int) (sum int) &#123; for _, v := range items &#123; sum += v &#125; return&#125;func main() &#123; slice := []int&#123;1, 2, 3, 4, 5&#125; //array := [...]int&#123;1, 2, 3, 4, 5&#125; fmt.Println(sum(1, 2, 3, 4, 5)) fmt.Println(sum(slice...)) //不定参数函数参数为切片时，需用...运算符 //fmt.Println(sum(array...)) //数组不支持...运算符 fmt.Println(sumS(slice)) //切片参数函数可直接用切片变量，不用...运算符 //fmt.Println(sumS(array)) //切片参数函数不能用数组传参 fmt.Printf(\"%T\\n\", sum) fmt.Printf(\"%T\\n\", sumS)&#125; 函数类型 函数类型又叫函数签名，显示函数类型fmt.Printf(&quot;%T\\n&quot;, funcname) 函数类型包括形参列表和返回值列表 形参列表：形参的次序、个数和类型（形参名无关） 返回值列表：返回值的次序、个数和类型（返回值名无关） 可以使用type定义函数类型 函数类型是引用类型，未初始化的零值为nil 标准定义的函数名为常量，不可修改指向 函数是第一公民，函数变量可赋值、传参等 匿名函数 匿名函数相当于函数字面量，可以使用函数变量的地方就可以使用匿名函数 1234567891011121314//匿名函数直接调用func(a,b int )int&#123; return a-b&#125;(5,4)//匿名函数赋值给函数变量var sum = func(a,b int )int&#123; return a+b&#125;//函数作为返回值func getFun(op string) func(a,b int )int &#123; return func(a,b int )int&#123; return a+b &#125;&#125; 闭包 闭包=函数+引用环境，常见于匿名函数引用了函数定义环境的变量 如果函数返回的闭包引用了该函数的局部变量 每次调用函数都会为局部变量分配内存 每次使用闭包都会影响局部变量 返回值 允许返回指定变量名 123456789101112func addT1(a, b int) (int, bool) &#123; //多值返回，返回值不命名 c := a + b d := a &gt; b return c, d //按顺序输入返回值&#125;func addT2(a, b int) (c int, d bool) &#123; //多值返回，返回值命名 // 注, c，d变量的类型声明在函数签名中已经声明了，因此直接赋值即可，不用:= c = a + b d = a &gt; b return //直接返回&#125; 函数作为类型，以及函数赋值给变量 12345678910111213141516func add(a, b int )int&#123; return a + b&#125;func change(f func(a, b int)int )&#123; f = func(a, b int) int &#123; return a - b &#125;&#125;func main() &#123; var f func(a, b int)int = add change(f) // 未起作用 i := f(1, 2) fmt.Printf(\"i: %v\\n\", i)&#125; defer Go 函数支持defer进行延迟调用 defer 类似OO语言异常处理中的finally子句，常用来保证系统资源的回收和释放 在注册defer函数时，会把当时的实参值传递给形参，后续实参的变化不影响函数结果，如 123456a:=5defer fmt.Println(\"defer注册函数时的a值\",a) // a=5的时候，记录了defera=10fmt.Println(\"普通函数的a值\",a) // 后续变化了//普通函数的a值10//defer注册函数时的a值5 使用多个defer时，这些defer 调用 以**先进后出（FILO）**顺序在函数返回前被执行 结构体 结构把有内在联系的不同类型的数据统一成一个整体，使它们相互关联 结构是变量的集合，从外部看是一个实体 结构支持嵌套 结构的字段类型不限 结构的存储空间连续，按声明时的顺序存放 使用： 命名类型结构 123456789101112type Employee struct &#123; firstName string lastName string age int salary int&#125;type Employee struct &#123; firstName, lastName string age, salary int&#125; 匿名类型结构（直接创建结构变量） 1234var myemployee struct &#123; firstName, lastName string age, salary int&#125; 带标签的结构体 标签是一个附属于字段的字符串，用于描述字段信息 标签还可以按key1:“value1” key2:“value2”键值对进行修饰，来提供编码、解码、ORM等转化辅助，比如JSON、BSON 等格式序列化 结构变量初始化 用命名类型结构或匿名类型结构声明的结构变量，各字段初始化为相关类型的零值 按字段名初始化，不用按顺序，未指定的字段为零值 123456emp1 := Employee&#123; firstName: \"Sam\", age: 25, salary: 500, lastName: \"Anderson\", //逗号不能忽略&#125; 用字面量初始化，按字段类型声明顺序并全部设置，顺序不对或遗漏字段报错 emp2 := Employee{&quot;Thomas&quot;, &quot;Paul&quot;, 29, 800} 访问结构体数据 采用 结构变量.字段 12emp := Employee&#123;\"Thomas\", \"Paul\", 29, 800&#125;fmt.Println(emp.age) 采用（*结构变量指针）.字段 *为间访符 12emp := &amp;Employee&#123;\"Sam\", \"Anderson\", 55, 6000&#125;fmt.Println(\"First Name:\", (*emp).firstName) 采用 结构变量指针.字段，不支持-&gt; 12emp := &amp;Employee&#123;\"Sam\", \"Anderson\", 55, 6000&#125;fmt.Println(\"First Name:\", emp.firstName) 匿名字段:结构体字段也可以省略字段名，字段名默认为对应数据类型名称（数据类型不能重复） 123456type Person struct &#123; string int&#125;p := Person&#123;\"Naveen\", 50&#125;p.int =60 嵌套结构 12345678910111213141516171819202122type Address struct &#123; city, state string&#125;type Person struct &#123; name string age int address Address&#125;func main() &#123; var p Person p.name = \"Naveen\" p.age = 50 p.address = Address&#123; city: \"Chicago\", state: \"Illinois\", &#125; fmt.Println(\"Name:\", p.name) fmt.Println(\"Age:\", p.age) fmt.Println(\"City:\", p.address.city) fmt.Println(\"State:\", p.address.state)&#125; 子结构字段提升 匿名子结构的字段可以像父结构的字段一样被父访问（没有同名父结构字段） 123456789101112131415161718192021type Address struct &#123; city, state string&#125;type Person struct &#123; name string age int Address //子结构匿名&#125;func main() &#123; var p Person p.name = \"Naveen\" p.age = 50 p.Address = Address&#123; city: \"Chicago\", state: \"Illinois\", &#125; fmt.Println(\"Name:\", p.name) fmt.Println(\"Age:\", p.age) fmt.Println(\"City:\", p.city) //city 提升, 可以直接以父.city的形式使用 fmt.Println(\"State:\", p.state) //state 提升&#125; 方法 方法是对具体类型行为的封装，本质上是绑定到该类型的函数 非命名类型不能定义方法 OO语言的方法通常有个隐藏的this或self指针来指向对象 GO 把这个隐藏指针暴露出来，称为接收者（receiver） 接收者可自定义名称，类型有值类型和指针类型两种，语法格式： 值类型：func (t Type) funcName(paramList)(resultList) 指针类型 ：func (t *Type) funcName(paramList)(resultList) 方法接收者 方法接收者的本质是形参 方法接收者为值时，方法修改对象属性将不能成功 方法接收者为值时，需要在内存复制一份对象，效率低 1234567891011121314151617181920 //方法接收者是值 func (e Employee) changeName(newName string) &#123; e.name = newName fmt.Printf(\"\\nEmployee name in func is: %s\", e.name) &#125; //方法接收者是指针 func (e *Employee) changeAge(newAge int) &#123; e.age = newAge &#125; // 实际上是拷贝了一个e对象，然后吧这个对象的name改掉了 // Print(e.Name)实际上还是没有修改 e.changeName(\"Michael\") // 而接收者为指针的函数就能修改 e.changeAge(18) // 除了上述调用以外，还可以通过类型调用的方式 Employee.changeName(e, 52) //类型调用 (*Employee).changeAge(&amp;e, 52) //类型调用 总结：Go中的方法实现跟C比较类似，都是在体外完成对方法的具体实现。C是在类中声明函数原型，在类外以Class::FuncMethod(){ xxx }中具体实现函数。 12345678910111213141516171819202122232425262728293031323334type Employee struct &#123; name string salary int currency string&#125;//定义方法func (e Employee) displaySalary() &#123; fmt.Printf(\"Salary of %s is %s%d\", e.name, e.currency, e.salary)&#125;func main() &#123; emp1 := Employee&#123; name: \"Sam Adolf\", salary: 5000, currency: \"$\", &#125; emp1.displaySalary() &#125;// Target：实际等价type Employee struct &#123; name string salary int currency string&#125;func displaySalary(e Employee) &#123; fmt.Printf(\"Salary of %s is %s%d\", e.name, e.currency, e.salary)&#125;func main() &#123; emp1 := Employee&#123; name: \"Sam Adolf\", salary: 5000, currency: \"$\", &#125; displaySalary(emp1)&#125; Q：方法可用等价函数实现，为什么还要方法？ GO 的函数不能重载(即不准存在只是参数不同的同名函数)，导致不同类型不能用同名函数，而不同类型的方法可以同名 GO 不支持class ,使用结构代替类，结构字段用来封装对象属性，方法用来封装对象的行为 方法提升 匿名子结构的方法可以像父结构的方法一样被父使用（没有同名父结构方法） 123456789101112131415161718192021222324252627282930313233343536373839404142type Address struct &#123; city string state string&#125;type Person struct &#123; firstName ptring lastName string Address&#125;func (a *Address) fullAddress() &#123; //接收者是子结构指针 fmt.Printf(\"Full Address: %s, %s\\n\", a.city, a.state)&#125;func main() &#123; p := Person&#123; firstName: \"Elon\", lastName: \"Musk\", Address: Address&#123; city: \"Los Angeles\", state: \"California\", &#125;, &#125; p.Address.fullAddress() //完整调用方法 p.fullAddress() //父结构对象直接调用子结构方法&#125;// 1. 修改匿名字段Address变成指针，则2type Person struct &#123; firstName string lastName string *Address&#125;func main() &#123; p := &amp;Person&#123; firstName: \"Elon\", lastName: \"Musk\", Address: &amp;Address&#123; // 2. 则这边传的时候应该是传地址 city: \"Los Angeles\", state: \"California\", &#125;, &#125;&#125; 自定义类型扩展方法 方法并非结构体专有，所有自定义类型都可以定义方法 123456789type myInt int // 命名类型func (a *myInt) add(b myInt) myInt &#123; return *a + b&#125;num1 := myInt(5)num2 := myInt(10)sum := num1.add(num2) 方法值 方法本质上还是函数，所以方法可以赋值给函数变量 方法值是对象变量初始化后的方法 方法值其实是带有闭包的函数变量，接收者被隐式地保存在闭包里 方法值赋给函数变量后，函数变量可直接调用 方法也可以直接通过类型来调用，把接收者作为第一个参数：e.play() &lt;==&gt;Employee.play(e), (*Employee).changeAge(&amp;e, 52) //类型调用 接口 接口是编程规约，一组方法签名的集合 方法声明的两个组件构成了方法签名 - 方法的名称和参数类型。 传统OO里，接口通常用来抽象定义对象的行为，具体过程在类里实现 ，类在定义时要声明实现了哪些接口 GO 接口采用非侵入式，即具体类型实现接口不用显式声明，只要其方法集是接口的超集，编译时会进行对应校验 GO 接口只有方法签名，没有数据字段，没有函数体代码 类型的方法集是多个接口的超集，则实现多个接口 类型定义： 命名接口类型 1234type interfaceName interface&#123;//接口类型命名通常以er为后缀 methodName(paramList)(resultList) otherInterfaceName&#125; 匿名接口类型 1234interface&#123; methodName(paramList)(resultList) interfaceName&#125; 空接口 空接口 interface{} 是一种匿名接口类型 空接口的方法集为空，所有类型都实现了空接口，都可以赋值或传递给空接口 非命名类型不能定义自己的方法，其方法集为空，只能传递给空接口==&gt;map，slice 方法需要接收类型参数，所以非命名类型不能定义自己的方法 接口初始化 只声明未赋值的接口变量为nil 接口变量初始化需要把接口绑定到具体类型实例 未初始化的接口变量不能调用其方法 方法的接收者才能给接口变量赋值 接口变量的值包括底层类型的值和具体类型 1234567891011121314type Printer interface &#123; Print()&#125;type S struct&#123;&#125;func (s S) Print() &#123; fmt.Println(\"print\")&#125; var i interface&#123;&#125; = S&#123;&#125;switch v := i.(type) &#123; //通过v才能调用接口函数 case Printer: v.Print() default: fmt.Printf(\"unknown type\\n\")&#125; 在内部，接口值可以看做包含值和具体类型的元组：(value, type) 接口值保存了一个具体底层类型的具体值。接口值调用方法时会执行其底层类型的同名方法。 12345678910111213141516171819202122232425262728293031323334353637type I interface &#123; M()&#125;type T struct &#123; S string&#125;func (t *T) M() &#123; fmt.Println(t.S)&#125;type F float64func (f F) M() &#123; fmt.Println(f)&#125;func main() &#123; var i I i = &amp;T&#123;\"Hello\"&#125; describe(i) i.M() i = F(math.Pi) describe(i) i.M()&#125;func describe(i I) &#123; fmt.Printf(\"(%v, %T)\\n\", i, i)&#125;/**(&amp;&#123;Hello&#125;, *main.T)Hello(3.141592653589793, main.F)3.141592653589793*/ GO 的面向对象 Go 没有类，而是松耦合的类型、方法对接口的实现 封装 用结构代替类 用New函数代替构造函数 继承 用类型组合来实现继承 多重继承通过内嵌多个类型实现 多态 类型断言 Go语言里面有一个语法，可以直接判断是否是该类型的变量：value, ok = element.(T)，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。 下面有个例子。只有当某个interface{}的类型 存储的是int时才打印出来。 12345678910111213141516171819package mainimport ( \"fmt\" \"math/rand\" \"time\")func main() &#123; var v interface&#123;&#125; r := rand.New(rand.NewSource(time.Now().UnixNano())) for i := 0; i &lt; 10; i++&#123; v = i if (r.Intn(100) % 2) == 0 &#123; v = \"hello\" &#125; if _, ok := v.(int); ok &#123; fmt.Printf(\"%d\\n\", v) &#125; &#125; &#125; 一个比较典型的应用场景就是：errors.(*MyError) 反射 反射可以在运行时检查变量的类型和值，是元编程的一种形式，在没有源代码时帮助调试程序 反射包 ” reflect” 通过空接口获取变量的类型和值 用接口实现多态 实例可以赋给它所实现的任意接口类型的变量 反射包 ” reflect” 通过空接口获取变量的类型和值 func TypeOf(i interface{}) Type func ValueOf(i interface{}) Value reflect.Type 和 reflect.Value 各有许多方法，比如kind方法用于返回底层类型名称的常量 123456789101112131415161718192021222324252627282930313233func add(a, b int) int &#123; return a + b&#125;// 将函数包装为反射值对象funcValue := reflect.ValueOf(add)// 生成函数参数, 传入两个整型值paramList := []reflect.Value&#123;reflect.ValueOf(10), reflect.ValueOf(20)&#125;// 反射调用函数retList := funcValue.Call(paramList)// 获取第一个返回值, 取整数值fmt.Println(retList[0].Int())type Money float64func main() &#123; var x Money = 58.9 fmt.Println(\"type:\", reflect.TypeOf(x)) v := reflect.ValueOf(x) fmt.Println(\"value:\", v) fmt.Println(\"type:\", v.Type()) fmt.Println(\"kind:\", v.Kind()) //查看底层类型 fmt.Println(\"settability of v:\", v.CanSet()) //能否被修改 x的地址不能修改 /* type: main.Money value: 58.9 type: main.Money kind: float64 settability of v: false */&#125; 错误处理 传统OO里，异常是一种程序控制机制，依附于栈结构,却可以同时设置多个异常类型作为网捕条件,从而以类型匹配在栈机制中跳跃回馈 GO 语言里没有异常机制，只有错误处理，错误通过函数的多返回值来处理 GO 语言的错误主要有： 编译错误 运行时错误 逻辑错误 GO错误处理方式 错误可处理，通过函数返回错误进行处理 错误不可处理，通过panic抛出错误，退出程序 错误实现 通过error 接口 实现错误处理的标准模式，打印错误时自动调用Error()函数 1234&gt; type error interface&#123;&gt; Error() string&gt; &#125;&gt; 实际使用 1234567891011121314type PathError struct &#123; Op string Path string Err error&#125;func (e *PathError) Error() string &#123; return e.Op + \" \" + e.Path + \": \" + e.Err.Error() &#125;f, err := os.Open(\"/test.txt\")// 类型断言if perr, ok := err.(*os.PathError); ok &#123; fmt.Println(\"File at path\", perr.Path, \"failed to open\") return&#125;fmt.Println(f.Name(), \"opened successfully\") 创建错误 根据errors 包对错误的基本定义 12345678910package errorsfunc New(text string) error &#123; return &amp;errorString&#123;text&#125;&#125;type errorString struct &#123; s string&#125;func (e *errorString) Error() string &#123; return e.s&#125; fmt包的Errorf 函数 12345678910111213func circleArea1(radius float64) (float64, error) &#123; if radius &lt; 0 &#123; return 0, errors.New(\"Area calculation failed, radius is less than zero\") &#125; return math.Pi * radius * radius, nil&#125;func circleArea2(radius float64) (float64, error) &#123; if radius &lt; 0 &#123; return 0, fmt.Errorf(\"Area calculation failed, radius %0.2f is less than zero\", radius) &#125; return math.Pi * radius * radius, nil&#125; 创建自定义错误 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport \"fmt\"type areaError struct &#123; err string //error description length float64 //length which caused the error width float64 //width which caused the error&#125;// 实现接口func (e *areaError) Error() string &#123; return e.err&#125;//error的方法用来明确错误原因func (e *areaError) lengthNegative() bool &#123; return e.length &lt; 0&#125;func (e *areaError) widthNegative() bool &#123; return e.width &lt; 0&#125;func rectArea(length, width float64) (float64, error) &#123; err := \"\" if length &lt; 0 &#123; err += \"length is less than zero\" &#125; if width &lt; 0 &#123; if err == \"\" &#123; err = \"width is less than zero\" &#125; else &#123; err += \", width is less than zero\" &#125; &#125; if err != \"\" &#123; // 1. 返回的是对象的地址 return 0, &amp;areaError&#123;err, length, width&#125; &#125; //err 文本用来给错误提示信息 return length * width, nil&#125;func main() &#123; length, width := -5.0, -9.0 // 2. 所以这边err是指针 area, err := rectArea(length, width) if err != nil &#123; fmt.Print(err) // 3. 所以这边类型断言得判断是不是areaError的指针 if err, ok := err.(*areaError); ok &#123; if err.lengthNegative() &#123; fmt.Printf(\"error: length %0.2f is less than zero\\n\", err.length) &#125; if err.widthNegative() &#123; fmt.Printf(\"error: width %0.2f is less than zero\\n\", err.width) &#125; return &#125; &#125; fmt.Println(\"area of rect\", area)&#125; 自定义错误的实现逻辑： 自定义的错误都会重写Error() string的方法，即实现了error 接口。 在抛出自定义错误的函数中错误的返回值类型都是error接口 因此，在外部使用的时候data, err = Myfunc()，这边得到的err是error接口，至于捕捉自定义的错误就是通过对接口的类型断言来判断的了，即自定义的错误都能看到下面有if errObj, ok := err.(*MyError); ok的代码 使用 goto 集中处理错误——Go特性 123456789101112131415161718192021222324252627// 常规的写法err := firstCheckError()if err != nil &#123; fmt.Println(err) exitProcess() return&#125;err = secondCheckError()if err != nil &#123; fmt.Println(err) exitProcess() return&#125;// Go借助标签特殊的写法err := firstCheckError()if err != nil &#123; goto onExit&#125;err = secondCheckError()if err != nil &#123; goto onExit&#125;// 正常处理代码onExit: fmt.Println(err) exitProcess() panic（恐慌） 通常情况下，向报告错误状态的方式是返回一个额外的error类型值。但是，当遇到不可恢复的错误状态，导致程序不能简单继续执行时引发panic 引发panic的两种情况 主动调用panic 函数，会产生一个运行时错误，该错误提供RuntimeError() 方法用于区别普通错误 程序运行时出现未处理错误自动触发，比如当发生像数组下标越界或类型断言失败等运行时错误时，Go 运行时会自动触发panic 不应通过调用panic()函数来报告普通的错误，而应该只把它作为报告致命错误的一种方式 panicking终止过程 panic 类似异常会逐级上传 在多层嵌套的函数调用中触发或调用panic，会马上中止当前函数的执行，逐级冒泡上传到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况 recover panic一旦被引发就会导致程序崩溃，但无法保证程序不会发生任何运行时错误。 recover专用于“拦截”运行时panic，让进入恐慌的程序恢复过来并重新获得流程控制权。 recover 可以阻止panic继续向上传递 ▲.为确保捕获panic， recover 必须在延迟函数（defer）中执行 总结： 程序发生的错误导致程序不能容错继续执行，应主动调用panic或由运行时抛出panic 程序发生错误，但能容错继续执行的，正常情况用错误返回值，运行时错误非关键分支用recover 捕获panic 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"fmt\")func recoverName() &#123; if r := recover(); r != nil &#123; fmt.Println(\"recovered from fullName\", r) &#125;&#125;func recoverMain() &#123; if r := recover(); r != nil &#123; fmt.Println(\"recovered from main\", r) &#125;&#125;func fullName(firstName *string, lastName *string) &#123; defer recoverName() if firstName == nil &#123; panic(\"runtime error: first name cannot be nil\") &#125; if lastName == nil &#123; panic(\"runtime error: last name cannot be nil\") &#125; fmt.Printf(\"%s %s\\n\", *firstName, *lastName) fmt.Println(\"returned normally from fullName\")&#125;func main() &#123; defer recoverMain() defer fmt.Println(\"deferred call in main\") //firstName := \"Elon\" lastName := \"Potter\" //fullName(&amp;firstName, &amp;lastName) fullName(nil, &amp;lastName) fmt.Println(\"returned normally from main\")&#125; 包 GO使用包来组织源代码和代码编译，实现代码复用 任何源代码必须属于某个包，同时源码文件的第一行有效代码必须是package pacakge packageName 语句，声明自己所在的包。 ▲.包名为 main 为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件 一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下 包的引用格式 标准引用格式 12import \"fmt\"fmt.Printf(\"Hello world！\") 通过：库/包.func的方式调用 自定义别名引用格式 12import F \"fmt\"F.Printf(\"Hello world！\") 通过：定义的名称，如F.func的方式调用 省略引用格式 123import . \"fmt\"//不需要加前缀 fmt.Printf(\"Hello world！\") 匿名引用格式 引用包，但是代码中却没有使用包，编译器会报错 在引用某个包时，如果只是希望执行包初始化的 init 函数，而不使用包内部的数据时，可以使用匿名引用格式(_) 1import _ \"fmt\" init( ) init( )是特殊的函数，不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高 init( )常用于在开始执行程序之前对数据进行检验或修复，或者在程序开始之前调用后台执行的 goroutine 每个源码可以使用 1 个 init() 函数，一个包可以有多个 init 函数，包加载时会执行全部的 init 函数，但并不能保证执行顺序 包加载顺序 程序从 main 函数引用的包开始，逐级查找包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图 每个包会先①初始化常量，然后②是全局变量，③最后执行包的 init 函数 包内标识符导出——向外暴露 一个包里的标识符（如类型、变量、常量等）要被外部访问，需将要导出的标识符的首字母大写 1234var myVar = 100 //内部引用const MyConst = \"hello\" //导出type MyStruct struct &#123; //导出&#125; 在被导出的结构体或接口中，如果它们的字段或方法首字母是大写，外部可以访问这些字段和方法 12345678type MyStruct struct &#123; //结构体要被导出 ExportedField int // 包外可以访问的字段 privateField int // 仅限包内访问的字段&#125;type MyInterface interface &#123; //接口要被导出 ExportedMethod() // 包外可以访问的方法 privateMethod() // 仅限包内访问的方法&#125; 总结：Go没有提供权限控制符，而是通过了首字母是否大小写的统一规定来加上权限控制，这个跟Python中私有权限加__，保护权限加_颇为类似 go.mod 使用GOPATH 不太方便 go.mod是Go1.11版本新引入的官方包管理工具 在项目目录下用go.mod 文件来记录依赖包具体版本，方便依赖包、源代码和版本控制的管理、 https://github.com/golang/go/wiki/Modules go.mod 文件内容 module：指定包的名字 go：用于标识当前模块的 Go 语言版本，值为初始化模块时的版本 require：指定的依赖项模块 replace：可以替换依赖项模块 exclude：可以忽略依赖项模块 go mod命令 go.sum 文件 go.sum 文件 在执行 go get xxxx之后或直接编译使用第三方包的源代码时自动生成 详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改 go.mod 使用基本过程 创建项目目录Dir 在项目目录运行 go mod init projectName,生成go.mod 文件 在项目目录执行 go get xxxx 下载第三方包， 会生成go.sum文件 （可选） 在项目目录下新建子目录，创建项目子包（可选，无需再生成go.mod) 并发 并行是在任一粒度的时间瞬间都同时执行，比如多机并行 并发是在规定的时间期限内多个任务都在执行，实际底层是分时操作 并行强调瞬时性、并发强调过程性 并行关键在于执行、并发关键在于结构 单机运行时，并行通过使用多处理器以提高速度，并发程序可以是并行的，也可以不是 应用程序具备好的并发结构，操作系统才能更好地利用硬件并行执行 进程( process )、线程( thread )和协程( coroutine ) 进程是程序在内存中运行时，操作系统对其进行资源分配和调度的独立单位 线程是进程的一个执行实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位 每个进程至少包括一个线程 每个进程的初始线程被称为主线程，主线程终止，进程终止 协程是轻量级的线程，一个线程可以拥有多个协程 进程和线程是操作系统级的，协程是编译器级的。协程不被操作系统内核管理，而完全由程序控制，因此没有线程切换的开销。 和多线程比，数量越多，协程的性能优势就越明显。协程的最大优势在于其轻量级，可以轻松创建上万个而不会导致系统资源衰竭 go routine 特性 多数语言在语法层不支持协程，而是通过库方式，效率不高，容易阻塞 Go 在语言级别支持协程 命名为goroutine，关键字go 由Go语言运行时统一调度，合理分配给各个CPU 各goroutine非阻塞，不会等待 goroutine 可以并行执行 goroutine执行的函数返回值被忽略===&gt;因此需要得到返回结果的话需要通过chan 运行时不保证各goroutine的执行顺序 goroutine之间被平等地调度和执行 main函数会单独创建和分配一个go routine 协程间的通信——通道 通道是一种特殊的类型，同时只能有一个 goroutine 访问通道进行发送和获取数据。 通道是一个队列，遵循先入先出（FIFO）的规则 通道默认是阻塞的，使goroutine有效通信，不需要使用其他语言的显式锁或条件变量 通道是引用类型，需要使用chan关键字和内置函数make 进行创建 通道写入和读取使用 &lt;- 运算符 写入 ：通道&lt;-变量 读取： 变量&lt;-通道 通道包括无缓冲通道和有缓冲通道 无缓冲通道 make(chan datatype) 有缓冲通道 make(chan datatype，capacity) 无缓冲通道只能存储一条消息，有缓冲通道可以根据make函数的capacity参数存储n条消息，按FIFO读出 缓冲与阻塞 无缓冲通道，写入等待读取，读取等待写入，在双方准备好之前是阻塞的 有缓冲通道，通道已满时的写入会等待，通道已空的读取会等待 单向通道 通道默认为双向的，单向通道只能用于发送或接收数据 所谓单向通道只是对通道作为函数参数的一种使用限制，跟C语言使用const修饰函数参数为只读类似 通常先创建双向通道，在函数形参中利用&lt;-运算符修饰通道，使之变为只读或只写通道 func pull(ch &lt;-chan int) //只读 func pump(ch chan&lt;- int) //只写 关闭通道: 关闭通道使用内置函数close(),实际上是关闭写入，即发送者告诉接收者不会再有数据发往通道 接收者能够在通道接收数据的同时，获取通道是否已关闭的参数 v, ok := &lt;-ch for range语句能自动判断通道是否已关闭 channel底层实现 src/runtime/chan.go:hchan定义了channel的数据结构 缓冲区是一个环形队列 一个channel只能传递一种类型的值，类型信息存储在hchan数据结构 12345678910111213type hchan struct &#123; qcount uint // 当前队列中剩余元素个数 dataqsiz uint // 环形队列长度，即可以存放的元素个数 buf unsafe.Pointer // 环形队列指针 elemsize uint16 // 每个元素的大小 closed uint32 // 标识关闭状态 elemtype *_type // 元素类型 sendx uint // 队列下标，指示元素写入时存放到队列中的位置 recvx uint // 队列下标，指示元素从队列的该位置读出 recvq waitq // 等待读消息的goroutine队列，读阻塞的goroutine会被向channel写入数据的goroutine唤醒 sendq waitq // 等待写消息的goroutine队列，写阻塞的goroutine会被从channel读数据的goroutine唤醒 lock mutex // 互斥锁，一个channel同时仅允许被一个goroutine读写&#125; 通道底层实现 向channel写数据 如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程； 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程； 如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒 通道底层实现 从channel读数据 如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程； 如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程； 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程； 将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒； 定时器 Timer 协程间的通信需设置超时等辅助机制 一次性定时器：定时器只计时一次，结束便停止 主要方法 12345func NewTimer(d Duration) *Timer // 指定一个时间创建一个Timer，Timer一经创建便开始计时，不需要额外的启动命令func (t *Timer) Stop() bool // 停止计时器，返回值true：定时器超时前停止， false: 定时器超时后停止func (t *Timer) Reset(d Duration) bool // 停掉定时器，再启动，返回值同上func After(d Duration) &lt;-chan Time // 创建匿名不需控制的计时器func AfterFunc(d Duration, f func()) *Timer // 延迟方法调用 注：Timer一经创建便开始计时，不需要额外的启动命令 Ticker 周期性定时器：定时器周期性进行计时，除非主动停止，否则将永久运行 12func NewTicker(d Duration) *Ticker // 指定一个时间创建一个Ticker ， Ticker一经创建便开始计时，不需要额外的启动命令func (t *Ticker) Stop() // 停止计时，但管道不会被关闭 并发函数 WaitGroup WaitGroup提供多个协程同步（平级）的机制，用来等待多个协程完成 信号量， Unix中保护共享资源的机制，用于防止多个线程同时访问某个资源 信号量&gt;0，表示资源可用，获取信号量时系统自动将信号量减1 信号量==0时，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒 WaitGroup 的方法 Add(delta int) 添加等待信号量 Done() 释放等待信号，每次减少1 Wait() 阻塞调用该方法的协程，直到等待信号量为0 12345678910111213141516func process(i int, wg *sync.WaitGroup) &#123; fmt.Println(\"started Goroutine \", i) time.Sleep(2 * time.Second) fmt.Printf(\"Goroutine %d ended\\n\", i) wg.Done() //goroutine执行结束后将信号量减1&#125;func main() &#123; var wg sync.WaitGroup for i := 0; i &lt; 3; i++ &#123; wg.Add(1) //增加信号量 go process(i, &amp;wg) &#125; wg.Wait() //主goroutine阻塞调用该方法的协程，直到等待信号量为0 fmt.Println(\"All go routines finished executing\")&#125; select 多路复用是在一个信道上传输多路信号或数据流，比如网线 select 借用网络多路复用的概念，用于监听多个通道，同时响应多个通道 多个通道都没有可写或可读的状态，select 会阻塞 有一个通道是可写或可读的， select 会执行该通道语句 有多个通道是可写或可读的， select 会随机选择其中一个执行 123456789101112131415161718192021222324func server1(ch chan string) &#123; time.Sleep(2 * time.Second) //可取消 ch &lt;- \"from server1\"&#125;func server2(ch chan string) &#123; time.Sleep(3 * time.Second) //可取消 ch &lt;- \"from server2\"&#125;func main() &#123; output1 := make(chan string) output2 := make(chan string) go server1(output1) go server2(output2) time.Sleep(1 * time.Second) var reply string select &#123; case reply = &lt;-output1: fmt.Println(reply) case reply = &lt;-output2: fmt.Println(reply) &#125;&#125; context WaitGroup用来控制多个平级goroutine同时完成 goroutine本身是平等的，但逻辑上可能有父子关系，context 表示程序上下文，是程序的运行状态，用来控制具有逻辑父子关系的多个goroutine Context接口 12345678910type Context interface &#123; //返回超时时间和是否已设置超时时间 Deadline() (deadline time.Time, ok bool) //返回信道，当Context被撤销或过期时，该信道是关闭的 Done() &lt;-chan struct&#123;&#125; //Done信道关闭后，Err方法表明Context被撤销的原因 Err() error //协程间的数据共享 Value(key interface&#123;&#125;) interface&#123;&#125;&#125; context 使用 用context的树结构来给平等的goroutine 设置父子逻辑 context树的根节点通常是一个空的context ,由第一个goroutine用Background() 函数创建，该context不能被取消、没有值、也没有过期时间 创建子节点： 12345678//将父节点复制到子节点，返回一个可以主动撤销Context的函数func WithCancel(parent Context) (ctx Context, cancel CancelFunc)//过期时间由deadline和parent的过期时间共同决定，parent过期时间优先func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)//与WithDeadline类似，只不过传入的是从现在开始Context剩余的生命时长func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)//将父节点复制到子节点，子节点可扩展新的key存储的值func WithValue(parent Context, key interface&#123;&#125;, val interface&#123;&#125;) Context e.g. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455func HandelRequest(ctx context.Context) &#123; go WriteLog(ctx) go WriteDB(ctx) for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(\"请求处理完毕\") return default: fmt.Println(\"请求处理中……\") time.Sleep(2 * time.Second) &#125; &#125;&#125;func WriteLog(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(\"写日志完成\") return default: fmt.Println(\"写日志中……\") time.Sleep(2 * time.Second) println(\"日志ing\") &#125; &#125;&#125;func WriteDB(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(\"写数据库完成\") return default: fmt.Println(\"写数据库中……\") time.Sleep(2 * time.Second) &#125; &#125;&#125;func main() &#123; //WithCancel 一旦触发该子context的cancel, 那么该context绑定上的子协程都会被关闭 /* ctx, cancel := context.WithCancel(context.Background()) go HandelRequest(ctx) time.Sleep(5 * time.Second) fmt.Println(\"所有子协程都需要结束!\") cancel() //Just for test whether sub goroutines exit or not time.Sleep(5 * time.Second) */ //WithTimeout 子context会在5s后过期, 所以其执行的协程最多只能运行5s，相当于绑定了一个定时器 ctx, _ := context.WithTimeout(context.Background(), 5*time.Second) go HandelRequest(ctx) time.Sleep(10 * time.Second)&#125; 注： 关于context.WithValue和context.Value的使用方式见：https://blog.csdn.net/u012190809/article/details/107700495 mutex 多个线程同时竞争使用某个变量可能会导致结果失控 mutex，互斥锁，用来保证某个变量在任一时刻，只能有一个线程访问 mutex 用Lock()和Unlock()来创建资源的临界区，这一区间内的代码是线程安全的，任何一个时间点都只能有一个goroutine执行这段区间的代码 mutex 也可以用通道来代替，二者无优劣之分，通常不涉及线程交互数据的用mutex，其他用通道 1234567891011121314151617181920212223242526func increment(wg *sync.WaitGroup, m *sync.Mutex) &#123; m.Lock() x = x + 1 //锁定后访问全局变量 m.Unlock() wg.Done()&#125;// 用Mutex可以用Chan中自带的Mutex来实现互斥func incrementByChan(wg *sync.WaitGroup, ch chan bool) &#123; ch &lt;- true x = x + 1 //锁定后访问全局变量 &lt;- ch wg.Done()&#125;func main() &#123; var w sync.WaitGroup // var m sync.Mutex ch := make(chan bool, 1) for i := 0; i &lt; 1000; i++ &#123; w.Add(1) // go increment(&amp;w, &amp;m) go incrementByChan(&amp;w, ch) &#125; w.Wait() fmt.Println(\"final value of x\", x) //结果确定&#125; RWMutex RWMutex在Mutex的基础之上增加了读、写的信号量，并使用了类似引用计数的读锁数量 可以同时申请多个读锁 有读锁时申请写锁将阻塞 只要有写锁，后续申请读锁和写锁都将阻塞 主要方法： 1234func (rw *RWMutex) Lock() //申请写锁func (rw *RWMutex) Unlock() //释放写锁func (rw *RWMutex) RLock() //申请读锁func (rw *RWMutex) RUnlock()//释放读锁 e.g. 12345678910111213141516171819202122232425262728func main() &#123; var wg sync.WaitGroup var rm sync.RWMutex wg.Add(2) go func() &#123; time.Sleep(20 * time.Millisecond) for i := 0; i &lt; 1000; i++ &#123; rm.Lock() j++ fmt.Printf(\"Write lock %d\\n\", j) rm.Unlock() &#125; wg.Done() &#125;() go func() &#123; time.Sleep(18 * time.Millisecond) for i := 0; i &lt; 1000; i++ &#123; rm.RLock() k++ //fmt.Printf(\"Read lock %d\\n\", j) fmt.Printf(\"Read lock %d\\n\", k) rm.RUnlock() &#125; wg.Done() &#125;() wg.Wait()&#125; Cond （ condition 条件变量） 互斥锁保证在同一时刻仅有一个线程访问某一个共享数据 条件变量在共享数据的状态发生变化时，通知其他因此而被阻塞的线程 条件变量需要用互斥锁来创建 主要方法： 12345678910// 实例化一个带有Locker的Cond变量func NewCond(l Locker) *Cond//Unlock()-&gt;阻塞等待通知(等待Signal()或Broadcast()的通知)-&gt;收到通知-&gt;Lock()func (c *Cond) Wait()//激活执行Wait()的通知队列的第一个协程func (c *Cond) Signal()//激活执行Wait()的通知队列所有协程 func (c *Cond) Broadcast()//使用内置的互斥锁cond.L.Lock()和cond.L.Unlock() e.g. 12345678910111213141516171819202122232425var locker = new(sync.Mutex)var cond = sync.NewCond(locker)func main() &#123; for i := 0; i &lt; 5; i++ &#123; go func(x int) &#123; cond.L.Lock() // wait 前，必须要先加锁 defer cond.L.Unlock() //保障释放资源 cond.Wait() fmt.Println(x) time.Sleep(time.Second * 1) &#125;(i) &#125; time.Sleep(time.Second * 1) fmt.Println(\"Signal....\") cond.Signal() // 下发一个通知给已经获取锁的goroutine time.Sleep(time.Second * 3) fmt.Println(\"Signal....\") cond.Signal() // 3 秒之后，下发一个通知给已经获取锁的goroutine time.Sleep(time.Second * 3) fmt.Println(\"Broadcast...\") cond.Broadcast() // 3 秒之后，下发通知给所有已经获取锁的goroutine time.Sleep(time.Second * 3)&#125; 附： 语言设计思想 保证只有一种写法 少即是多 GO 不支持class ,使用结构代替类，结构字段用来封装对象属性，方法用来封装对象的行为 用类型组合来实现继承 多态：Go中只要结构体实现了接口的部分方法，就可以通过接口指向该结构体，并且使用被实现的方法。因此，可以看到Go的代码中函数传参很多都是接口，但真正使用的时候传入的是实现了该接口的struct，这就是Go中多态提现的一个例子。 new 和 make区别 new和make是内建的两个函数，主要用来在堆上创建分配类型的内存 new用于普通类型的内存分配，内存清零，返回该类型指针 make（专门）用于slice、map以及channel的初始化，返回引用 golang中分为值类型和引用类型 值类型分别有：int系列、float系列、bool、string、数组和结构体 引用类型有：指针、slice切片、管道channel、接口interface、map、函数等 值类型的特点是：变量直接存储值，内存通常在栈中分配 引用类型的特点是：变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在堆中分配 问题 Go中引用类型有哪些？ 在 Go 语言中，引用类型有 切片 (slice) 、 字典 (map) 、 接口 (interface) 、 函数 (func) 以及 通道 (chan) 。 引用类型之所以可以引用，是因为我们创建引用类型的变量，其实是一个标头值，标头值里包含一个指针，指向底层的数据结构，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递，这也是引用类型传递高效的原因。 注：用户自定义类型不是引用类型===&gt;所以函数传参的时候都传的是地址，形参都是指针类型。And: 引用类型不支持==运算符，无法直接比较 总结：Go中规定的引用类型就5个：切片 (slice) 、 字典 (map) 、 接口 (interface) 、 函数 (func) 以及 通道 (chan)，但传参为这几个类型的时候，不需要传指针，直接用相应的类型即可。 课上训练题 自定义排序 标准库的 sort 包采用的是快速排序 请模仿其实现，基于Sorter 接口实现冒泡排序 请按如下要求设计协程交互代码 协程一随机给出0~100的数 协程二猜协程一的数，猜中的话协程一返回信号0，结束程序；猜小了协程一返回信号-1，猜大了协程一返回信号1，继续猜 打印猜数过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package ggimport ( \"fmt\" \"math/rand\" \"time\") var up = 100 var down = 0 var last = -1 func guest(ch chan int)&#123; for &#123; signn := &lt;- ch fmt.Printf(\"协程得到的sign: %v\\n\", signn) var ths int switch signn&#123; case -1: // down ~ last down = last ths = rand.Intn(up - down) + down fmt.Printf(\"协程随机到的ths: %v\\n\", ths) ch &lt;- ths last = ths case 1: // last ~ up up = last ths = rand.Intn(up-down) + down fmt.Printf(\"协程随机到的ths: %v\\n\", ths) ch &lt;- ths last = ths default: break &#125; &#125; &#125; func main() &#123; rand.Seed(time.Now().UnixNano()) num := rand.Intn(100) fmt.Printf(\"随机到的数为: %v\\n\", num) ch := make(chan int, 1) ch &lt;- -1 var n int go guest(ch) for &#123; n = &lt;- ch fmt.Printf(\"主线程得到数值为%v\\n\", n) if ( n == num )&#123; ch &lt;- 0 fmt.Printf(\"协程猜中啦, 数值为%v\\n\", n) break &#125;else if (n &lt; num)&#123; ch &lt;- -1 &#125;else if (n&gt; num)&#123; ch &lt;- 1 &#125; &#125; &#125; Go复习题目： Go 语言笔试面试题(基础语法)——基础知识题 ★GO语言测试题 同学推荐的Go指南——可以根据概念实现做点题 考试中容易出的坑题： ▲与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换 ▲与 C 不同，Go 没有指针运算。 容易踩的坑： nil 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。 允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map添加元素则会造成运行时 panic string 类型的变量值不能为 nil ==&gt; string 的零值为&quot;&quot; 访问 map 中不存在的 key，Go中返回的是零值，而不是报错 range后迭代对象：数组、通道、string、map 数组：for i, v := range arr，i为索引，v为arr[i]的值 通道：for data := ch, data为数据 range 迭代 string 得到的值: range 得到的索引是字符值（Unicode point / rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。 注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用norm 包。 for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。 range 迭代 map 如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。 Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的 如果你去 Go Playground 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。 string 与 byte slice 之间的转换：Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配： 在 map[string] 中查找 key 时，使用了对应的 []byte，避免做 m[string(key)] 的内存分配 使用 for range 迭代 string 转换为 []byte 的迭代：for i,v := range []byte(str) {…} 在多行 array、slice、map 语句的末尾缺少 , 号 switch 中的 fallthrough 语句：switch 语句中的 case 代码块会默认带上 break，但可以使用 fallthrough 来强制执行下一个 case 代码块。 &lt;=等价于=&gt;改写成 case 为多条件判断： 自增和自减运算： Go 特立独行，去掉了前置操作，同时 ++、-- 只作为运算符而非表达式。 不导出的 struct 字段无法被 encode。以小写字母开头的字段成员是无法被外部直接访问的，所以 struct 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值： Go程序默认不等所有 goroutine 都执行完才退出 常用解决办法：使用 “WaitGroup” 变量，它会让主程序等待所有 goroutine 执行完毕再退出。 向已关闭的 channel 发送数据会造成 panic 在一个值为 nil 的 channel 上发送和接收数据将永久阻塞： ▲若函数 receiver 传参是传值方式，则无法修改参数的原有值 从一个现有的非 interface 类型创建新类型时，并不会继承原有的方法： 跳出 for-switch 和 for-select 代码块：没有指定标签的 break 只会跳出 switch/select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块： Go里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main） 对Slice使用append，当长度超出时会返回新的Slice，因此无法在递归的时候不能直接传引用对象，而是需要传指针*[]int指针，并且在append的时候改成*ans = append(*ans, root.Val) 见Leetcode94树的中层遍历： 123456789101112131415161718192021222324252627282930313233343536373839404142434445func inorderTraversal(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; ans := []int&#123;&#125; OrderTravel(root, &amp;ans) return ans&#125;/**如果ans不传指针，而是直接ans []int传参，关注ans地址变化，输出地址得到：append前:0xc000004078append后:0xc000004078append前:0xc0000040c0append后:0xc0000040c0append前:0xc0000040a8append后:0xc0000040a8*/func OrderTravel(root *TreeNode, ans *[]int)&#123; if root == nil &#123; return &#125; OrderTravel(root.Left, ans) *ans = append(*ans, root.Val) OrderTravel(root.Right, ans)&#125;/** 修改成传指针后ans的地址就始终是一致的了append前: 0xc000004078append后: 0xc000004078append前: 0xc000004078append后: 0xc000004078append前: 0xc000004078append后: 0xc000004078*/func main() &#123; root := &amp;TreeNode&#123; Val: 1, Left: nil, Right: &amp;TreeNode&#123; Val: 2, Left: &amp;TreeNode&#123;Val: 3&#125;, &#125;, &#125; res := inorderTraversal(root) fmt.Println(res)&#125; from：Golang新手可能会踩的50个坑","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://nymrli.top/tags/Go/"},{"name":"考试","slug":"考试","permalink":"https://nymrli.top/tags/考试/"}]},{"title":"k8s之kube-proxy源码分析","slug":"k8s之kube-proxy源码分析","date":"2021-10-26T12:15:52.000Z","updated":"2022-03-29T12:52:47.391Z","comments":true,"path":"2021/10/26/k8s之kube-proxy源码分析/","link":"","permalink":"https://nymrli.top/2021/10/26/k8s之kube-proxy源码分析/","excerpt":"","text":"kubernetes 简单介绍 背景介绍 Kubernetes最初源于谷歌内部的Borg，提供了面向应用的容器集群部署和管理系统，目前为主流的微服务应用编排管理工具。 Kubernetes的目标旨在消除编排物理/虚拟计算、网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原理上进行自助运营。 Kubernetes具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。 Borg是谷歌内部的大规模集群管理系统，负责对谷歌内部很多核心服务的调度和管理。Borg的目的是让用户能够不必操心资源管理的问题，从而更专注于自己的核心业务。Borg甚至能做到跨多个数据中心的资源利用率最大化。 架构设计 Kubernetes属于主从分布式架构，主要由Master和Node组成，以及包括客户端命令行工具kubectl和其它附加项。 Master：作为控制节点，对集群所有工作节点Node进行调度管理；由kube-apiServer、kube-scheduler、kube-controller-manager和etcd组成。 Node：作为工作节点，运行业务应用的容器；由kubelet、kube-proxy和docker（目前仍是主流的运行时）组成。 代码整体分析 目录分析 通过git clone下来最新的K8S代码后，目前v1.22.2版本的代码结构通过tree命令可看到如下所示： 12345678910111213141516.├── api ├── build├── CHANGELOG├── cluster├── cmd├── docs├── hack├── LICENSES├── logo├── pkg├── plugin├── staging├── test├── third_party└── vendor k8s的程序入口都在cmd目录下面，核心逻辑都在pkg目录下面。这么做的好处是把程序入口和逻辑分开，因为程序入口只做了一些最简单的调用，具体逻辑是模块化的类库，即增强了程序的可读性，也便于一人负责一个模块多人互相协作，这一点在大型项目中非常重要。我们可以看到pkg目录下面有很多子目录，每一个子目录都包含了一个重要的组件。 proxy源码目录结构分析 要学习一份项目代码，除了学习其实现的原理外，其代码的组织结构也是非常有借鉴和学习价值的，并且先看明白目录结构更有助于我们检索想要阅读的代码段。 cmd/kube-proxy目录负责kube-proxy的创建，是启动的入口 123456789101112.├── app│ ├── conntrack.go // 全局sysctl的一个接口, 各种sysctl字段的描述和辅助方法可以在这里找到│ ├── init_others.go // 判断Cli参数中OS, 并根据结果进行设置非 Win OS配置参数│ ├── init_windows.go // 判断Cli参数中OS, 并根据结果进行设置配置Win OS参数│ ├── server.go //Options、ProxyServer 结构定义及其创建(NewProxyServerDefault)和运行(Run)的方法。│ ├── server_others.go // 非Win OS下的 NewProxyServer实现，创建好匹配 ProxyMode 的ProxyServer│ ├── server_others_test.go│ ├── server_test.go│ └── server_windows.go // Win OS下的 NewProxyServer 实现，创建好匹配 ProxyMode 的ProxyServer├── OWNERS└── proxy.go //kube-proxy的入口文件，提供main方法, 通过NewProxyCommand()产生Cobra.Command命令 pkg/proxy是kube-proxy核心实现的代码目录，通过tree -L 3展示其3层深度的目录结构如下所示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101.├── apis│ ├── config│ │ ├── doc.go│ │ ├── fuzzer│ │ ├── OWNERS│ │ ├── register.go│ │ ├── register_test.go│ │ ├── scheme│ │ ├── types.go│ │ ├── v1alpha1│ │ ├── validation│ │ └── zz_generated.deepcopy.go│ └── well_known_labels.go├── config│ ├── api_test.go│ ├── config.go //定义ServiceUpdate,EndpointUpdate结构体以及ServiceConfigHandler,EndpointConfigHandler来处理Service和Endpoint的Update│ ├── config_test.go│ ├── doc.go│ └── OWNERS├── doc.go├── endpoints.go // 定义了基础的BaseEndpoints， 实现了 endpoints 的更新与维护├── endpointslicecache.go // endpoints缓存实现├── endpointslicecache_test.go├── endpoints_test.go├── healthcheck // 健康检查, 负责service listener和endpoint的health check，add/delete请求。│ ├── common.go│ ├── doc.go│ ├── healthcheck_test.go│ ├── proxier_health.go│ └── service_health.go├── iptables //proxy mode为 iptables 的实现│ ├── OWNERS│ ├── proxier.go│ └── proxier_test.go├── ipvs //proxy mode为 ipvs 的实现│ ├── graceful_termination.go│ ├── graceful_termination_test.go│ ├── ipset.go│ ├── ipset_test.go│ ├── netlink.go│ ├── netlink_linux.go│ ├── netlink_unsupported.go│ ├── OWNERS│ ├── proxier.go│ ├── proxier_test.go│ ├── README.md│ ├── safe_ipset.go│ └── testing│ ├── fake.go│ ├── fake_test.go│ └── util.go├── metaproxier│ └── meta_proxier.go├── metrics│ └── metrics.go├── OWNERS├── service.go├── service_test.go├── topology.go // 实现对 Endpoint 的路由过滤：提供FilterLocalEndpoint、FilterEndpoints两个方法├── topology_test.go├── types.go // ServicePort、Endpoint 重要接口定义├── userspace // proxy mode为 userspace 的实现│ ├── loadbalancer.go│ ├── OWNERS│ ├── port_allocator.go│ ├── port_allocator_test.go│ ├── proxier.go│ ├── proxier_test.go│ ├── proxysocket.go│ ├── rlimit.go│ ├── rlimit_windows.go│ ├── roundrobin.go│ └── roundrobin_test.go├── util│ ├── endpoints.go│ ├── endpoints_test.go│ ├── iptables│ │ ├── traffic.go│ │ └── traffic_test.go│ ├── network.go│ ├── testing│ │ └── fake.go│ ├── utils.go│ └── utils_test.go├── winkernel // Win OS下的Kernel实现│ ├── hns_test.go│ ├── hnsV1.go│ ├── hnsV2.go│ ├── metrics.go│ ├── OWNERS│ ├── proxier.go│ └── proxier_test.go└── winuserspace // 系统为windows OS时，proxy mode为 userspace 的实现 ├── loadbalancer.go ├── proxier.go ├── proxier_test.go ├── proxysocket.go ├── roundrobin.go ├── roundrobin_test.go └── types.go kube-proxy分析 kube-proxy是管理service的访问入口，实现Kubenetes Service通信与负载均衡机制，提供了集群内Pod对Service的访问和集群外访问service的方式。当用户创建 service 的时候，endpointController 会根据service 的 selector 找到对应的 pod，然后生成 endpoints 对象保存到 etcd 中。运行在每个节点上的Kube-proxy会通过api-server 获得etcd 中 Service和Endpoints的变化信息，并调用 kube-proxy 配置的代理模式来更新主机上的iptables 转发规则，通过修改iptables规则从而改变报文的流向，让集群中服务解析。从而实现了将业务请求连接到Service后具体的执行结点（endpoints）。 接下来我将会以iptables 代理模式为例,对proxy 的功能实现进行分析。基于iptables模式的kube-proxy的主要职责包括两大块：一是侦听service更新事件，并更新service相关的iptables规则；二是侦听endpoint更新事件，更新endpoint相关的iptables规则。 分析目标 带着问题看代码能收获的内容更多，因此在此，我们在心里保留两个问题： kube-proxy如何让集群内节点无法ping通clusterIP的？ 为什么集群内节点可以通过ClusterIP:Port形式访问服务；集群外可以通过NodeIP:NodePort形式访问到服务 好了，明确了以上两个问题后就让我们来让代码吧 重要结构体说明 kubernetes/cmd/proxy-server/app/server.go作为cmd/kube-proxy入口的真正执行文件，主要是围绕ProxyServer和两个结构体进行了一系列初始化赋值的操作。因此，针对这两个结构体，我们需要详细了解下有什么内容 ProxyServer ProxyServer 结构体中定义的属性代表了kube-proxy server 运行时需要的所有变量。kube-proxy server 调用的方法均来该结构体内变量拥有的方法。 12345678910111213141516171819202122232425type ProxyServer struct &#123; Client clientset.Interface EventClient v1core.EventsGetter IptInterface utiliptables.Interface // 接口中定义了更新iptables 的方法集合，如DeleteChian,DeleteRule, EnsureChain,EnsureRule IpvsInterface utilipvs.Interface // 定义操作 ipvs 的方法集 IpsetInterface utilipset.Interface //定义了操作 ipset 的方法集 execer exec.Interface // 定义包装os/exec库中Command, Commandcontext, LookPath方法的接口 Proxier proxy.ProxyProvider //Proxier 有五种实现方式，分别对应Linux环境中三种的代理模式和Windows环境下的三种的代理模式 Broadcaster record.EventBroadcaster //接受Event，交于各个处理函数进行处理 Recorder record.EventRecorder // Event 记录者 ConntrackConfiguration kubeproxyconfig.KubeProxyConntrackConfiguration Conntracker Conntracker // if nil, ignored ProxyMode string NodeRef *v1.ObjectReference CleanupAndExit bool CleanupIPVS bool MetricsBindAddress string //127.0.0.1:10249 http prometheus metrics port; EnableProfiling bool OOMScoreAdj *int32 //通过一个数值用来表征进程当发生OOM时系统对该进程的行为 ResourceContainer string ConfigSyncPeriod time.Duration //Default 15m0s ServiceEventHandler config.ServiceHandler // EndpointsEventHandler config.EndpointsHandler // HealthzServer *healthcheck.HealthzServer // 0.0.0.0:10256 http healthz port;&#125; 根据源代码的注释提醒，以上数据成员都是必须有值的。 Options kube各组件中都以Options结构体提供配置参数，kube-scheduler中创建了专门的options目录以及options.go文件，kube-proxy中直接将其放在了cmd/app/server.go中 1234567891011121314151617/** Options中记录了创建和运行proxy服务器所需的一切 */type Options struct &#123; ConfigFile string // 记录了proxy服务器配置文件的位置 WriteConfigTo string // 默认配置将被写入的路径。 CleanupAndExit bool // 当CleanupAndExit为真时，proxy服务器将会清理iptables和ipvs规则，然后退出。 WindowsService bool // kube-proxy是否在Windows上作为一个服务运行，其对应的标志只在Windows构建中被注册 config *kubeproxyconfig.KubeProxyConfiguration // proxy服务器的配置对象，方便运行时读取配置 watcher filesystem.FSWatcher // 用于观察ConfigFile的更新变化。 proxyServer proxyRun // 启动proxy服务器的接口 errCh chan error // 发送错误的通道 // 下面的字段是占位符，不能直接映射到 config.KubeProxyConfiguration. // TODO remove these fields once the deprecated flags are removed. master string // master用于覆盖kubeconfig对apiserver的URL。 healthzPort int32 // healthz 服务器的端口 metricsPort int32 // metrics 服务器的端口 hostnameOverride string // 如果从命令行标志中设置该值，则将优先于配置文件中的`HostnameOverride`值。&#125; Proxier 在每一种代理模式下，都定义了自己的Proxier 结构体，该结构体及方法实现了该模式下的代理规则的更新方法。在Iptables 模式下，kubernetes/pkg/proxy/iptables/proxier.go文件中Proxier 结构体的定义如下所示： kubernetes/pkg/proxy/iptables/proxier.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364type Proxier struct &#123; // the ipfamily on which this proxy is operating on. ipFamily v1.IPFamily //EndpointChangeTracker中items属性为一个两级map,用来保存所有namespace 下endpoints 的变化信息。 //第一级map以 types.NamespacedName 为键，value 值为该namespace下所有endpoints 更新前（previous)、后(current)的信息：前、后信息分别为一个map ,即第二级map: ServiceMap。 //第二级map的key为ServicePortName 结构，[]Endpoint为值, 标记endpoints 对应的service，value为endpoint信息。 // EndpointChangeTracker 中实现了更新 endpoint 的方法 endpointsChanges *proxy.EndpointChangeTracker serviceChanges *proxy.ServiceChangeTracker // 同理，ServiceChangeTracker 中使用一个两级map保存所有namespace 下的service的变化信息，并定义了更新service的方法 // 互斥锁，保护下列字段 mu sync.Mutex serviceMap proxy.ServiceMap // 同serviceChanges 的第二级 map 结构，记录了所有namespace下需要更新iptables规则的service endpointsMap proxy.EndpointsMap // 同endpointsChanges 的第二级 map 结构，记录了所有namespace 需要更新iptables规则的endpoints portsMap map[utilproxy.LocalPort]utilproxy.Closeable endpointsSynced bool // Proxier 初始化时为False servicesSynced bool // Proxier 初始化时为False initialized int32 syncRunner *async.BoundedFrequencyRunner // async.BoundedFrequencyRunner 具有QPS功能，控制被托管方法的发生速率 // These are effectively const and do not need the mutex to be held. syncPeriod time.Duration minSyncPeriod time.Duration // Values are CIDR's to exclude when cleaning up IPVS rules. excludeCIDRs []*net.IPNet // Set to true to set sysctls arp_ignore and arp_announce strictARP bool iptables utiliptables.Interface // iptables 的执行器，定义了 Iptables 的操作方法 ipvs utilipvs.Interface // iptables 的执行器，定义了 IPVS 的操作方法 ipset utilipset.Interface exec utilexec.Interface masqueradeAll bool masqueradeMark string localDetector proxyutiliptables.LocalTrafficDetector hostname string nodeIP net.IP portMapper netutils.PortOpener // 已打开的UDP或TCP端口 recorder events.EventRecorder // 事件记录者 serviceHealthServer healthcheck.ServiceHealthServer healthzServer healthcheck.ProxierHealthUpdater ipvsScheduler string // Added as a member to the struct to allow injection for testing. ipGetter IPGetter // The following buffers are used to reuse memory and avoid allocations // that are significantly impacting performance. iptablesData *bytes.Buffer filterChainsData *bytes.Buffer natChains *bytes.Buffer filterChains *bytes.Buffer natRules *bytes.Buffer filterRules *bytes.Buffer // Added as a member to the struct to allow injection for testing. netlinkHandle NetLinkHandle // ipsetList is the list of ipsets that ipvs proxier used. ipsetList map[string]*IPSet // Values are as a parameter to select the interfaces which nodeport works. nodePortAddresses []string // networkInterfacer defines an interface for several net library functions. // Inject for test purpose. networkInterfacer utilproxy.NetworkInterfacer gracefuldeleteManager *GracefulTerminationManager&#125; 程序启动过程 从CLI命令接收参数输入的入口切入，我们可以看到一个从初始化到服务启动的完整的流程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// Step1. 命令入口func NewProxyCommand() *cobra.Command &#123; // 创建空的Options结构体对象 opts := NewOptions() // 创建kube-proxy命令，并定义执行函数 cmd := &amp;cobra.Command&#123; Use: \"kube-proxy\", Long: `The Kubernetes network proxy runs on each node. Thisreflects services as defined in the Kubernetes API on each node and can do simpleTCP, UDP, and SCTP stream forwarding or round robin TCP, UDP, and SCTP forwarding across a set of backends.Service cluster IPs and ports are currently found through Docker-links-compatibleenvironment variables specifying ports opened by the service proxy. There is an optionaladdon that provides cluster DNS for these cluster IPs. The user must create a servicewith the apiserver API to configure the proxy.`, Run: func(cmd *cobra.Command, args []string) &#123; verflag.PrintAndExitIfRequested() cliflag.PrintFlags(cmd.Flags()) if err := initForOS(opts.WindowsService); err != nil &#123; klog.ErrorS(err, \"Failed OS init\") // ACTION REQUIRED: Exit code changed from 255 to 1 os.Exit(1) &#125; if err := opts.Complete(); err != nil &#123; klog.ErrorS(err, \"Failed complete\") // ACTION REQUIRED: Exit code changed from 255 to 1 os.Exit(1) &#125; if err := opts.Validate(); err != nil &#123; klog.ErrorS(err, \"Failed validate\") // ACTION REQUIRED: Exit code changed from 255 to 1 os.Exit(1) &#125; // Options结构体初始化完成后, 根据配置启动proxy server if err := opts.Run(); err != nil &#123; klog.ErrorS(err, \"Error running ProxyServer\") os.Exit(1) &#125; &#125;, Args: func(cmd *cobra.Command, args []string) error &#123; for _, arg := range args &#123; if len(arg) &gt; 0 &#123; return fmt.Errorf(\"%q does not take any arguments, got %q\", cmd.CommandPath(), args) &#125; &#125; return nil &#125;, &#125; var err error // 为opts对象中的记录运行时配置的config对象进行默认初始化 opts.config, err = opts.ApplyDefaults(opts.config) if err != nil &#123; klog.ErrorS(err, \"Unable to create flag defaults\") // ACTION REQUIRED: Exit code changed from 255 to 1 os.Exit(1) &#125; // 接收命令FlagSet fs := cmd.Flags() // 增加Flag参数 opts.AddFlags(fs) fs.AddGoFlagSet(goflag.CommandLine) // for --boot-id-file and --machine-id-file // 对以下文件类型进行命令补全提示 _ = cmd.MarkFlagFilename(\"config\", \"yaml\", \"yml\", \"json\") return cmd&#125;// Step2. ①完善Options中的Config运行时配置对象；②启动具体的ProxyServer.func (o *Options) Run() error &#123; defer close(o.errCh) if len(o.WriteConfigTo) &gt; 0 &#123; return o.writeConfigFile() &#125; // 创建ProxyServer proxyServer, err := NewProxyServer(o) if err != nil &#123; return err &#125; // 如果参数为真, 则清理iptables和ipvs规则，然后退出。 if o.CleanupAndExit &#123; return proxyServer.CleanupAndExit() &#125; o.proxyServer = proxyServer return o.runLoop()&#125;// Step3. runLoop阻塞循环将不断侦听proxy server配置文件的更新变化。func (o *Options) runLoop() error &#123; // 如果有监听器的话启动监听器 if o.watcher != nil &#123; o.watcher.Run() &#125; // 另起协程运行proxy server go func() &#123; err := o.proxyServer.Run() o.errCh &lt;- err &#125;() // while循环等待, 并通过o.errCh阻塞，如果错误通道中读取到异常则退出程序 for &#123; err := &lt;-o.errCh if err != nil &#123; return err &#125; &#125;&#125; ProxyServer创建过程 cmd/kube-proxy/app/server_others.go中根据Options中已初始化好的参数创建ProxyServer实例，其中会根据getProxyMode(string(config.Mode), canUseIPVS, iptables.LinuxKernelCompatTester{})来确定具体使用哪个proxier实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244// 创建ProxyServer对象func NewProxyServer(o *Options) (*ProxyServer, error) &#123; return newProxyServer(o.config, o.CleanupAndExit, o.master)&#125;func newProxyServer( config *proxyconfigapi.KubeProxyConfiguration, cleanupAndExit bool, master string) (*ProxyServer, error) &#123; if config == nil &#123; return nil, errors.New(\"config is required\") &#125; if c, err := configz.New(proxyconfigapi.GroupName); err == nil &#123; c.Set(config) &#125; else &#123; return nil, fmt.Errorf(\"unable to register configz: %s\", err) &#125; var iptInterface utiliptables.Interface var ipvsInterface utilipvs.Interface var kernelHandler ipvs.KernelHandler var ipsetInterface utilipset.Interface // 创建iptables工具，包装了os/exec中的command,LookPath,CommandContext 方法，组装一个系统调用的命令和参数 execer := exec.New() kernelHandler = ipvs.NewLinuxKernelHandler() // 得到操作 ipset 的方法集接口 ipsetInterface = utilipset.New(execer) // 判断是否能够使用IPVS模式, IPVS在一定条件下会被退化成iptables canUseIPVS, err := ipvs.CanUseIPVSProxier(kernelHandler, ipsetInterface, config.IPVS.Scheduler) if string(config.Mode) == proxyModeIPVS &amp;&amp; err != nil &#123; klog.ErrorS(err, \"Can't use the IPVS proxier\") &#125; if canUseIPVS &#123; ipvsInterface = utilipvs.New(execer) &#125; // We omit creation of pretty much everything if we run in cleanup mode if cleanupAndExit &#123; return &amp;ProxyServer&#123; execer: execer, IpvsInterface: ipvsInterface, IpsetInterface: ipsetInterface, &#125;, nil &#125; if len(config.ShowHiddenMetricsForVersion) &gt; 0 &#123; metrics.SetShowHidden() &#125; // 从运行时配置中得到hostname hostname, err := utilnode.GetHostname(config.HostnameOverride) if err != nil &#123; return nil, err &#125; // 从给定的配置中创建与apiserver相匹配的kube客户端和event客户端。 client, eventClient, err := createClients(config.ClientConnection, master) if err != nil &#123; return nil, err &#125; // 得到proxy server使用的NodeIP nodeIP := detectNodeIP(client, hostname, config.BindAddress) klog.InfoS(\"Detected node IP\", \"address\", nodeIP.String()) // Create event recorder //EventBroadcaster会将收到的Event交于各个处理函数进行处理。接收Event的缓冲队列长为1000，不停地取走Event并广播给各个watcher; //watcher通过recordEvent()方法将Event写入对应的EventSink里，最大重试次数为12次，重试间隔随机生成(见staging/src/k8s.io/client-go/tools/record/event.go); // EnventSink 将在ProxyServer.Run() 中调用s.Broadcaster.StartRecordingToSink（） 传进来; // NewBroadcaster() 最后会启动一个goroutine 运行Loop 方法（staging/src/k8s.io/apimachinery/pkg/watch/mux.go) eventBroadcaster := events.NewBroadcaster(&amp;events.EventSinkImpl&#123;Interface: client.EventsV1()&#125;) //EventRecorder通过generateEvent()实际生成各种Event，并将其添加到监视队列。 recorder := eventBroadcaster.NewRecorder(scheme.Scheme, \"kube-proxy\") // 获得节点Node nodeRef := &amp;v1.ObjectReference&#123; Kind: \"Node\", Name: hostname, UID: types.UID(hostname), Namespace: \"\", &#125; var healthzServer healthcheck.ProxierHealthUpdater if len(config.HealthzBindAddress) &gt; 0 &#123; //服务健康检查的 IP 地址和端口(IPv4默认为0.0.0.0:10256，对于所有 IPv6 接口设置为 ::) healthzServer = healthcheck.NewProxierHealthServer(config.HealthzBindAddress, 2*config.IPTables.SyncPeriod.Duration, recorder, nodeRef) &#125; // 声明proxier接口, 是kube-proxy work的真正实现类 var proxier proxy.Provider var detectLocalMode proxyconfigapi.LocalMode // 得到代理模式，有三种: Userspace、IPTables、IPVS; 注：IPVS可能会退化成IPTables, IPTables也可能退化成Userspace proxyMode := getProxyMode(string(config.Mode), canUseIPVS, iptables.LinuxKernelCompatTester&#123;&#125;) // 选择CIDR模式，目前有两种: NodeCIDR、ClusterCIDR detectLocalMode, err = getDetectLocalMode(config) if err != nil &#123; return nil, fmt.Errorf(\"cannot determine detect-local-mode: %v\", err) &#125; // 声明节点信息 var nodeInfo *v1.Node if detectLocalMode == proxyconfigapi.LocalModeNodeCIDR &#123; klog.InfoS(\"Watching for node, awaiting podCIDR allocation\", \"hostname\", hostname) nodeInfo, err = waitForPodCIDR(client, hostname) if err != nil &#123; return nil, err &#125; klog.InfoS(\"NodeInfo\", \"PodCIDR\", nodeInfo.Spec.PodCIDR, \"PodCIDRs\", nodeInfo.Spec.PodCIDRs) &#125; klog.V(2).InfoS(\"DetectLocalMode\", \"LocalMode\", string(detectLocalMode)) // 根据IP协议确定合适的更新iptables的实现类 primaryProtocol := utiliptables.ProtocolIPv4 if netutils.IsIPv6(nodeIP) &#123; primaryProtocol = utiliptables.ProtocolIPv6 &#125; //iptInterface 赋值为runner结构体，该结构体实现了接口utiliptables.Interface中定义的方法， //各方法中通过runContext()方法调用execer的命令包装方法返回一个被包装的iptables 命令 iptInterface = utiliptables.New(execer, primaryProtocol) var ipt [2]utiliptables.Interface dualStack := true // While we assume that node supports, we do further checks below if proxyMode != proxyModeUserspace &#123; // Create iptables handlers for both families, one is already created // Always ordered as IPv4, IPv6 // 以IPv4-&gt;IPv6的顺序创建iptables处理程序 if primaryProtocol == utiliptables.ProtocolIPv4 &#123; ipt[0] = iptInterface ipt[1] = utiliptables.New(execer, utiliptables.ProtocolIPv6) &#125; else &#123; ipt[0] = utiliptables.New(execer, utiliptables.ProtocolIPv4) ipt[1] = iptInterface &#125; // 检查内核是否支持iptable接口 for _, perFamilyIpt := range ipt &#123; if !perFamilyIpt.Present() &#123; klog.V(0).InfoS(\"kube-proxy running in single-stack mode, this ipFamily is not supported\", \"ipFamily\", perFamilyIpt.Protocol()) dualStack = false &#125; &#125; &#125; // 如果代理模式为IPTables if proxyMode == proxyModeIPTables &#123; klog.V(0).InfoS(\"Using iptables Proxier\") if config.IPTables.MasqueradeBit == nil &#123; // MasqueradeBit must be specified or defaulted. return nil, fmt.Errorf(\"unable to read IPTables MasqueradeBit from config\") &#125; // 是否支持双栈 if dualStack &#123; klog.V(0).InfoS(\"kube-proxy running in dual-stack mode\", \"ipFamily\", iptInterface.Protocol()) klog.V(0).InfoS(\"Creating dualStackProxier for iptables\") // Always ordered to match []ipt var localDetectors [2]proxyutiliptables.LocalTrafficDetector localDetectors, err = getDualStackLocalDetectorTuple(detectLocalMode, config, ipt, nodeInfo) if err != nil &#123; return nil, fmt.Errorf(\"unable to create proxier: %v\", err) &#125; // TODO this has side effects that should only happen when Run() is invoked. proxier, err = iptables.NewDualStackProxier( ipt, utilsysctl.New(), execer, config.IPTables.SyncPeriod.Duration, config.IPTables.MinSyncPeriod.Duration, config.IPTables.MasqueradeAll, int(*config.IPTables.MasqueradeBit), localDetectors, hostname, nodeIPTuple(config.BindAddress), recorder, healthzServer, config.NodePortAddresses, ) &#125; else &#123; // Create a single-stack proxier if and only if the node does not support dual-stack (i.e, no iptables support). var localDetector proxyutiliptables.LocalTrafficDetector localDetector, err = getLocalDetector(detectLocalMode, config, iptInterface, nodeInfo) if err != nil &#123; return nil, fmt.Errorf(\"unable to create proxier: %v\", err) &#125; // TODO this has side effects that should only happen when Run() is invoked. proxier, err = iptables.NewProxier( iptInterface, utilsysctl.New(), execer, config.IPTables.SyncPeriod.Duration, config.IPTables.MinSyncPeriod.Duration, config.IPTables.MasqueradeAll, int(*config.IPTables.MasqueradeBit), localDetector, hostname, nodeIP, recorder, healthzServer, config.NodePortAddresses, ) &#125; if err != nil &#123; return nil, fmt.Errorf(\"unable to create proxier: %v\", err) &#125; // 注册指标 proxymetrics.RegisterMetrics() &#125; else if proxyMode == proxyModeIPVS &#123; // ... 省略 &#125; else &#123; // ... 省略 &#125; useEndpointSlices := true if proxyMode == proxyModeUserspace &#123; // userspace mode doesn't support endpointslice. useEndpointSlices = false &#125; return &amp;ProxyServer&#123; Client: client, EventClient: eventClient, IptInterface: iptInterface, IpvsInterface: ipvsInterface, IpsetInterface: ipsetInterface, execer: execer, Proxier: proxier, Broadcaster: eventBroadcaster, Recorder: recorder, ConntrackConfiguration: config.Conntrack, Conntracker: &amp;realConntracker&#123;&#125;, ProxyMode: proxyMode, NodeRef: nodeRef, MetricsBindAddress: config.MetricsBindAddress, BindAddressHardFail: config.BindAddressHardFail, EnableProfiling: config.EnableProfiling, OOMScoreAdj: config.OOMScoreAdj, ConfigSyncPeriod: config.ConfigSyncPeriod.Duration, HealthzServer: healthzServer, UseEndpointSlices: useEndpointSlices, &#125;, nil&#125; 创建完成后，即可通过err := o.proxyServer.Run()启动proxyServer，接下来我们以iptables模式为例继续分析。 iptables proxy server 代码主要在pkg/proxy/iptables/proxier.go中实现，首先以单栈proxier分析iptables proxier构造特性见NewProxier函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// 创建一个iptables proxier实例, 由于iptables的逻辑, 我们假设一台机器上只有一个Proxier在工作。如果iptables未能更新或获得初始锁，将返回一个错误。一旦代理服务器被创建，它将在后台保持iptables的更新，如果某个iptables调用失败，它将不会终止。func NewProxier(ipt utiliptables.Interface, sysctl utilsysctl.Interface, exec utilexec.Interface, syncPeriod time.Duration, minSyncPeriod time.Duration, masqueradeAll bool, masqueradeBit int, localDetector proxyutiliptables.LocalTrafficDetector, hostname string, nodeIP net.IP, recorder events.EventRecorder, healthzServer healthcheck.ProxierHealthUpdater, nodePortAddresses []string,) (*Proxier, error) &#123; // kube-proxy要求NODE节点操作系统中有/sys/module/br_netfilter模块，还要设置bridge-nf-call-iptables=1； //如果不满足要求，kube-proxy在运行过程中设置的某些iptables规则就不会工作。 if err := utilproxy.EnsureSysctl(sysctl, sysctlRouteLocalnet, 1); err != nil &#123; return nil, err &#125; // 当容器连接到Linux网桥（但不是SDN网桥）时，代理需要br_netfilter和bridge-nf-call-iptables=1。 在大多数插件处理这个问题之前，当配置缺失时要记录日志 if val, err := sysctl.GetSysctl(sysctlBridgeCallIPTables); err == nil &amp;&amp; val != 1 &#123; klog.InfoS(\"Missing br-netfilter module or unset sysctl br-nf-call-iptables, proxy may not work as intended\") &#125; // 生成用于SNAT规则的mark标记 masqueradeValue := 1 &lt;&lt; uint(masqueradeBit) masqueradeMark := fmt.Sprintf(\"%#08x\", masqueradeValue) klog.V(2).InfoS(\"Using iptables mark for masquerade\", \"ipFamily\", ipt.Protocol(), \"mark\", masqueradeMark) serviceHealthServer := healthcheck.NewServiceHealthServer(hostname, recorder, nodePortAddresses) ipFamily := v1.IPv4Protocol if ipt.IsIPv6() &#123; ipFamily = v1.IPv6Protocol &#125; ipFamilyMap := utilproxy.MapCIDRsByIPFamily(nodePortAddresses) nodePortAddresses = ipFamilyMap[ipFamily] // Log the IPs not matching the ipFamily if ips, ok := ipFamilyMap[utilproxy.OtherIPFamily(ipFamily)]; ok &amp;&amp; len(ips) &gt; 0 &#123; klog.InfoS(\"Found node IPs of the wrong family\", \"ipFamily\", ipFamily, \"IPs\", strings.Join(ips, \",\")) &#125; proxier := &amp;Proxier&#123; portsMap: make(map[netutils.LocalPort]netutils.Closeable), serviceMap: make(proxy.ServiceMap), serviceChanges: proxy.NewServiceChangeTracker(newServiceInfo, ipFamily, recorder, nil), endpointsMap: make(proxy.EndpointsMap), endpointsChanges: proxy.NewEndpointChangeTracker(hostname, newEndpointInfo, ipFamily, recorder, nil), syncPeriod: syncPeriod, iptables: ipt, masqueradeAll: masqueradeAll, masqueradeMark: masqueradeMark, exec: exec, localDetector: localDetector, hostname: hostname, nodeIP: nodeIP, portMapper: &amp;netutils.ListenPortOpener, recorder: recorder, serviceHealthServer: serviceHealthServer, healthzServer: healthzServer, precomputedProbabilities: make([]string, 0, 1001), iptablesData: bytes.NewBuffer(nil), existingFilterChainsData: bytes.NewBuffer(nil), filterChains: bytes.NewBuffer(nil), filterRules: bytes.NewBuffer(nil), natChains: bytes.NewBuffer(nil), natRules: bytes.NewBuffer(nil), nodePortAddresses: nodePortAddresses, networkInterfacer: utilproxy.RealNetwork&#123;&#125;, &#125; burstSyncs := 2 klog.V(2).InfoS(\"Iptables sync params\", \"ipFamily\", ipt.Protocol(), \"minSyncPeriod\", minSyncPeriod, \"syncPeriod\", syncPeriod, \"burstSyncs\", burstSyncs) // We pass syncPeriod to ipt.Monitor, which will call us only if it needs to. // We need to pass *some* maxInterval to NewBoundedFrequencyRunner anyway though. // time.Hour is arbitrary. proxier.syncRunner = async.NewBoundedFrequencyRunner(\"sync-runner\", proxier.syncProxyRules, minSyncPeriod, time.Hour, burstSyncs) // 开启iptables监视的协程, 主要的通过 proxier.syncProxyRules 的方法来维护iptables规则变化 go ipt.Monitor(kubeProxyCanaryChain, []utiliptables.Table&#123;utiliptables.TableMangle, utiliptables.TableNAT, utiliptables.TableFilter&#125;, proxier.syncProxyRules, syncPeriod, wait.NeverStop) if ipt.HasRandomFully() &#123; klog.V(2).InfoS(\"Iptables supports --random-fully\", \"ipFamily\", ipt.Protocol()) &#125; else &#123; klog.V(2).InfoS(\"Iptables does not support --random-fully\", \"ipFamily\", ipt.Protocol()) &#125; return proxier, nil&#125; ProxyServer.Run() 是proxyServer的启动命令，在cmd/kube-proxy/app/server.go中统一定义的模板方法，并没有被具体的proxier实现。开启了go serviceConfig.Run(wait.NeverStop)、go endpointsConfig.Run(wait.NeverStop)orgo endpointSliceConfig.Run(wait.NeverStop)、go nodeConfig.Run(wait.NeverStop)、go s.Proxier.SyncLoop()多个协程，自身被errCh通道阻塞，等待接收从子协程抛出的err 在Run() 方法中，大致做了如下工作： 准备工作，如设置OOMScoreAdj并设置连接跟踪 注册service 和endpoints 的处理方法，使用list-watch 机制对service，endpoints资源监听。 最后进入一个无限循环，对service与endpoints的变化进行iptables规则的同步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148func (s *ProxyServer) Run() error &#123; // To help debugging, immediately log version klog.InfoS(\"Version info\", \"version\", version.Get()) /** 1.1 设置oom数值 */ // //在用户空间通过写oomScoreAdj参数到/proc/self/oom_score_adj文件来改变进程的 oom_adj 内核参数； //oom_adj的值的大小决定了进程被 OOM killer，取值范围[-1000,1000] 选中杀掉的概率,值越低越不容易被杀死.此处默认值是-999。 // TODO(vmarmol): Use container config for this. var oomAdjuster *oom.OOMAdjuster if s.OOMScoreAdj != nil &#123; oomAdjuster = oom.NewOOMAdjuster() if err := oomAdjuster.ApplyOOMScoreAdj(0, int(*s.OOMScoreAdj)); err != nil &#123; klog.V(2).InfoS(\"Failed to apply OOMScore\", \"err\", err) &#125; &#125; /** 设置oom数值 */ /** 1.2 设置连接跟踪 */ if s.Broadcaster != nil &amp;&amp; s.EventClient != nil &#123; // EventSinkImpl 包装了处理event 的方法create ,update, patchs //s.Broadcaster 已经在ProxyServer 初始化中作为一个goroutine 在运行。 stopCh := make(chan struct&#123;&#125;) s.Broadcaster.StartRecordingToSink(stopCh) &#125; // TODO(thockin): make it possible for healthz and metrics to be on the same port. var errCh chan error if s.BindAddressHardFail &#123; errCh = make(chan error) &#125; // Start up a healthz server if requested serveHealthz(s.HealthzServer, errCh) // Start up a metrics server if requested serveMetrics(s.MetricsBindAddress, s.ProxyMode, s.EnableProfiling, errCh) // Tune conntrack, if requested // Conntracker is always nil for windows if s.Conntracker != nil &#123; max, err := getConntrackMax(s.ConntrackConfiguration) if err != nil &#123; return err &#125; if max &gt; 0 &#123; err := s.Conntracker.SetMax(max) if err != nil &#123; if err != errReadOnlySysFS &#123; return err &#125; // errReadOnlySysFS is caused by a known docker issue (https://github.com/docker/docker/issues/24000), // the only remediation we know is to restart the docker daemon. // Here we'll send an node event with specific reason and message, the // administrator should decide whether and how to handle this issue, // whether to drain the node and restart docker. Occurs in other container runtimes // as well. // TODO(random-liu): Remove this when the docker bug is fixed. const message = \"CRI error: /sys is read-only: \" + \"cannot modify conntrack limits, problems may arise later (If running Docker, see docker issue #24000)\" s.Recorder.Eventf(s.NodeRef, nil, api.EventTypeWarning, err.Error(), \"StartKubeProxy\", message) &#125; &#125; if s.ConntrackConfiguration.TCPEstablishedTimeout != nil &amp;&amp; s.ConntrackConfiguration.TCPEstablishedTimeout.Duration &gt; 0 &#123; timeout := int(s.ConntrackConfiguration.TCPEstablishedTimeout.Duration / time.Second) if err := s.Conntracker.SetTCPEstablishedTimeout(timeout); err != nil &#123; return err &#125; &#125; if s.ConntrackConfiguration.TCPCloseWaitTimeout != nil &amp;&amp; s.ConntrackConfiguration.TCPCloseWaitTimeout.Duration &gt; 0 &#123; timeout := int(s.ConntrackConfiguration.TCPCloseWaitTimeout.Duration / time.Second) if err := s.Conntracker.SetTCPCloseWaitTimeout(timeout); err != nil &#123; return err &#125; &#125; &#125; /** 设置连接跟踪 */ noProxyName, err := labels.NewRequirement(apis.LabelServiceProxyName, selection.DoesNotExist, nil) if err != nil &#123; return err &#125; noHeadlessEndpoints, err := labels.NewRequirement(v1.IsHeadlessService, selection.DoesNotExist, nil) if err != nil &#123; return err &#125; labelSelector := labels.NewSelector() labelSelector = labelSelector.Add(*noProxyName, *noHeadlessEndpoints) // 创建informer，过滤出期望以非默认service proxy运行的对象。 informerFactory := informers.NewSharedInformerFactoryWithOptions(s.Client, s.ConfigSyncPeriod, informers.WithTweakListOptions(func(options *metav1.ListOptions) &#123; options.LabelSelector = labelSelector.String() &#125;)) /** 2.创建配置记录变量, 创建ServiceConfig、endpointsConfig or EndpointSliceConfig 结构体，注册informer包括回调函数 */ //ServiceConfig结构体跟踪记录Service配置信息的变化 serviceConfig := config.NewServiceConfig(informerFactory.Core().V1().Services(), s.ConfigSyncPeriod) //RegisterEventHandler 是将Service的处理方法追加到serviceConfig的eventHandlers 中，eventHandlers为一个列表，元素类型ServiceHandler接口 // ServiceHandler接口定义了每个hanlder 处理service的api方法:OnServiceAdd,OnServiceUpdate,OnServiceDelete,OnServiceSynced // 此处 s.ServiceEventHandler 为proxier，s.Proxier实现了 ServiceHandler 接口定义的方法 serviceConfig.RegisterEventHandler(s.Proxier) go serviceConfig.Run(wait.NeverStop) // 如果 s.Proxier 的类型为 EndpointsHandler if endpointsHandler, ok := s.Proxier.(config.EndpointsHandler); ok &amp;&amp; !s.UseEndpointSlices &#123; endpointsConfig := config.NewEndpointsConfig(informerFactory.Core().V1().Endpoints(), s.ConfigSyncPeriod) // 注册事件处理handler endpointsConfig.RegisterEventHandler(endpointsHandler) go endpointsConfig.Run(wait.NeverStop) &#125; else &#123; endpointSliceConfig := config.NewEndpointSliceConfig(informerFactory.Discovery().V1().EndpointSlices(), s.ConfigSyncPeriod) //RegisterEventHandler 是将EndpointSliceHandler的处理方法追加到EndpointSliceConfig的eventHandlers 中，eventHandlers为一个列表，元素类型 EndpointSliceHandler 接口 endpointSliceConfig.RegisterEventHandler(s.Proxier) go endpointSliceConfig.Run(wait.NeverStop) &#125; // This has to start after the calls to NewServiceConfig and NewEndpointsConfig because those // functions must configure their shared informer event handlers first. informerFactory.Start(wait.NeverStop) if utilfeature.DefaultFeatureGate.Enabled(features.TopologyAwareHints) &#123; // Make an informer that selects for our nodename. currentNodeInformerFactory := informers.NewSharedInformerFactoryWithOptions(s.Client, s.ConfigSyncPeriod, informers.WithTweakListOptions(func(options *metav1.ListOptions) &#123; options.FieldSelector = fields.OneTermEqualSelector(\"metadata.name\", s.NodeRef.Name).String() &#125;)) nodeConfig := config.NewNodeConfig(currentNodeInformerFactory.Core().V1().Nodes(), s.ConfigSyncPeriod) nodeConfig.RegisterEventHandler(s.Proxier) go nodeConfig.Run(wait.NeverStop) // This has to start after the calls to NewNodeConfig because that must // configure the shared informer event handler first. currentNodeInformerFactory.Start(wait.NeverStop) &#125; /** 2.创建配置记录变量 */ // Birth Cry after the birth is successful s.birthCry() /** 3.开启新协程进入无限Loop循环进行工作，对service与endpoints的变化进行iptables规则的同步。*/ go s.Proxier.SyncLoop() return &lt;-errCh&#125; 注：XxxxxConfig.RegisterEventHandler(s.Proxier)中s.Proxier都是实现了对应其接口的实体proxier，详细的实现可以去找具体的proxier，如iptables/proxier.go有很多On开头的方法 附：Service和Endpoint、EndpointSlice资源类结构体，可以看到其中全都有个eventHandlers的Slice维护了处理Handler。 123456789101112131415// ServiceConfig tracks a set of service configurations.type ServiceConfig struct &#123; listerSynced cache.InformerSynced eventHandlers []ServiceHandler&#125;// EndpointsConfig tracks a set of endpoints configurations.type EndpointsConfig struct &#123; listerSynced cache.InformerSynced eventHandlers []EndpointsHandler&#125;// EndpointSliceConfig tracks a set of endpoints configurations.type EndpointSliceConfig struct &#123; listerSynced cache.InformerSynced eventHandlers []EndpointSliceHandler&#125; 那么具体的proxier是如何侦听endpoint和service的变化的呢？这个就要见上述各资源的注册过程中配置了什么，见kubernetes/pkg/proxy/config/config.go 123456789101112131415161718192021222324252627282930313233// NewServiceConfig creates a new ServiceConfig.func NewServiceConfig(serviceInformer coreinformers.ServiceInformer, resyncPeriod time.Duration) *ServiceConfig &#123; result := &amp;ServiceConfig&#123; listerSynced: serviceInformer.Informer().HasSynced, &#125; // serviceInformer.Informer() 返回一个sharedIndexInformer 实例(staing/src/k8s.io/client-go/tools/cache/shared_informer.go)，通过其AddEventHandlerWithResyncPeriod() 方法，将ResourceEventHandler实例赋值给processorListener结构体的handler属性，作为其事件发生的处理函数 serviceInformer.Informer().AddEventHandlerWithResyncPeriod( //结构体cache.ResourceEventHandlerFuncs 是一个ResourceEventHandler接口类型(staing/src/k8s.io/client-go/tools/cache/controller.go)，将ServicConfig 结构体的handleAddService 等方法赋予了cache.ResourceEventHandlerFuncs,实现一个ResourceEventHandler实例 cache.ResourceEventHandlerFuncs&#123; AddFunc: result.handleAddService, UpdateFunc: result.handleUpdateService, DeleteFunc: result.handleDeleteService, &#125;, resyncPeriod, ) return result&#125;// 如果发生了增加Service事件func (c *ServiceConfig) handleAddService(obj interface&#123;&#125;) &#123; service, ok := obj.(*v1.Service) if !ok &#123; utilruntime.HandleError(fmt.Errorf(\"unexpected object type: %v\", obj)) return &#125; for i := range c.eventHandlers &#123; klog.V(4).InfoS(\"Calling handler.OnServiceAdd\") // 转而调用 注册的事件handler接口,即proxyServer.Proxier 来处理 c.eventHandlers[i].OnServiceAdd(service) &#125;&#125; 从(s *ProxyServerproxier)Run的方法中可以看到service处理方法的被调用流程：通过serviceConfig.RegisterEventHandler()方法注册挂载了proxyServer.Proxier实例，然后在serviceConfig中的handleAddService()等方法中以c.eventHandlers[i].OnServiceAdd(service)的形式调用proxier中的OnServiceAdd()等对应的方法。 其中，可以看到proxier的处理函数都以订阅者的模式被注册好了等待事件发生触发，此时的执行权力都转交给了上层，那么serviceInformer.Informer().AddEventHandlerWithResyncPeriod就成了新的执行的入口，因此我们可以看看它是怎么work的，\\staging\\src\\k8s.io\\client-go\\tools\\cache\\shared_informer.go 123456789101112131415func (s *sharedIndexInformer) AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration) &#123; //... 省略 // 将加载好的handler注册到listener监听器中 listener := newProcessListener(handler, resyncPeriod, determineResyncPeriod(resyncPeriod, s.resyncCheckPeriod), s.clock.Now(), initialBufferSize) if !s.started &#123; s.processor.addListener(listener) return &#125; s.blockDeltas.Lock() defer s.blockDeltas.Unlock() // processor为sharedProcessor类型，其有一个 processorListener 的集合，可以向其监听器分发通知对象。 分发操作有两种， 会被同步分发到listener的子集中，（a）在运行时偶尔调用shouldResync时被重新得到的listener（b）每个最初被放入listener。 s.processor.addListener(listener) 看到上面的代码，proxier 中OnServiceAdd() 等方法的调用流程大致就有数了：在上述serviceInformer.Informer()返回之前，还将调用SharedIndexInformer.InformerFor()方法给informerFactory的informers属性赋值f.informers[informerType] = informer，如下所示\\staging\\src\\k8s.io\\apiextensions-apiserver\\examples\\client-go\\pkg\\client\\informers\\externalversions\\factory.go 123456789101112131415161718192021222324// InternalInformerFor returns the SharedIndexInformer for obj using an internal// client.func (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer &#123; f.lock.Lock() defer f.lock.Unlock() informerType := reflect.TypeOf(obj) // 判断是否有 informerType 类型的informers // f.informers为map[reflect.Type]cache.SharedIndexInformer informer, exists := f.informers[informerType] if exists &#123; return informer &#125; resyncPeriod, exists := f.customResync[informerType] if !exists &#123; resyncPeriod = f.defaultResync &#125; informer = newFunc(f.client, resyncPeriod) f.informers[informerType] = informer return informer&#125; 此段代码的意义可理解为：从api server 监听到 informerType类型资源变化的处理者记录(映射)为informer。此处的资源类型即为service, informer 便为sharedIndexInformer。具体的调用时机和最上层方法入口就要去看informerFactory这个东西了，这又是k8s 中另一个比较系统的公共组件了，即它涉及到client-go的SharedInformer的触发规则和实现原理了。 记录资源变化 Proxier 实现了 services 和 endpoints 事件各种最终的观察者，最终的事件触发都会在 proxier 中进行处理。对于通过监听 API Server 变化的信息，通过调用ResourceHandler将变化的信息保存到 endpointsChanges 和 serviceChanges。那么一个ResourceHandler是如何实现的呢？service 和endpoints 的变化如何记录为servriceChanges 和endpointsChanges？回看上边源码中被注册的对象s.ServiceEventHandler，s.EndpointsEventHandler的具体实现便可明白。 service 和endpoints 的处理原则相似，以对servcie 的处理为例，看一下对service 的处理方法，pkg/proxy/iptables/proxier.go 12345678910111213141516171819202122232425// 增加Servicefunc (proxier *Proxier) OnServiceAdd(service *v1.Service) &#123; proxier.OnServiceUpdate(nil, service)&#125; // 更新Servicefunc (proxier *Proxier) OnServiceUpdate(oldService, service *v1.Service) &#123; if proxier.serviceChanges.Update(oldService, service) &amp;&amp; proxier.isInitialized() &#123; proxier.syncRunner.Run() // 通过channel 发送一个信号，调用tryRun() &#125;&#125;// 删除Service时func (proxier *Proxier) OnServiceDelete(service *v1.Service) &#123; proxier.OnServiceUpdate(service, nil)&#125;// ...// OnServiceUpdate is called whenever modification of an existing// service object is observed.func (proxier *Proxier) OnServiceUpdate(oldService, service *v1.Service) &#123; if proxier.serviceChanges.Update(oldService, service) &amp;&amp; proxier.isInitialized() &#123; proxier.Sync() &#125;&#125; 可以看到，上述三个情况：增加、删除service 都是给proxier.OnServiceUpdate() 传入参数后，由OnServiceUpdate() 方法处理，而proxier.OnServiceUpdate() 中又是通过proxier.serviceChanges.Update(oldService, service)实现的 ，因此重点看一下serviceChanges的Update() 方法是如何实现的。见pkg/proxy/service.go 1234567891011121314151617181920212223242526272829303132333435// 根据&lt;previous, current&gt;服务对，更新给定服务的变化图。 如果项目发生了变化，它返回true。// 否则返回false。 Update可以用来添加/更新/删除ServiceChangeMap的项目。 例如。// 添加项目// - 传递&lt;nil, service&gt;作为&lt;previous, current&gt;对。// 更新项目// - 传递&lt;oldService, service&gt;作为&lt;previous, current&gt;对。// 删除项目// - 传递&lt;service, nil&gt;作为&lt;previous, current&gt;对。func (sct *ServiceChangeTracker) Update(previous, current *v1.Service) bool &#123; svc := current if svc == nil &#123; svc = previous &#125; // previous == nil &amp;&amp; current == nil is unexpected, we should return false directly. if svc == nil &#123; return false &#125; namespacedName := types.NamespacedName&#123;Namespace: svc.Namespace, Name: svc.Name&#125; sct.lock.Lock() defer sct.lock.Unlock() change, exists := sct.items[namespacedName] if !exists &#123; // 在serviceChanges 中不存在一个以namespacedName 为key 的资源 change = &amp;serviceChange&#123;&#125; // 初始化一个serviceChange change.previous = sct.serviceToServiceMap(previous) sct.items[namespacedName] = change &#125; change.current = sct.serviceToServiceMap(current) // if change.previous equal to change.current, it means no change if reflect.DeepEqual(change.previous, change.current) &#123; // 从update传递进来的资源没有变化，则从serviceChanges中删除。 delete(sct.items, namespacedName) &#125; return len(sct.items) &gt; 0&#125; Update 方法就是根据`&lt;previous ,current&gt; 参数对新生成一个change 或者修改一个存在的change。并且把无变化的资源从serviceChanges 中删除。serviceChanges.items 会在将变化信息更新到proxier.serviceMap 后清空。 IPTables相关 Iptables 创建KUBE自定义链和规则 介绍了kube-proxy关于资源监听和记录的实现后，再来看一下kube-proxy是如何将资源的变化反馈到iptables规则中的。在具体proxier的创建过程中，以iptables为例，是创建了iptable监视器的，其会通过不断调用proxier.syncProxyRules来同步更新iptables规则。 12345678910func NewProxier(ipt utiliptables.Interface, // ... )&#123; // ... 省略 // 开启iptables监视的协程, 主要的通过 proxier.syncProxyRules 的方法来维护iptables规则变化 go ipt.Monitor(kubeProxyCanaryChain, []utiliptables.Table&#123;utiliptables.TableMangle, utiliptables.TableNAT, utiliptables.TableFilter&#125;, proxier.syncProxyRules, syncPeriod, wait.NeverStop) &#125; 继续研读syncProxyRule()方法看看其实修改iptables规则的细节流程，我们将能明白在node节点观察到的新链及规则产生的方式及目的，见kubernetes/pkg/proxy/iptables/proxier.go，更新proxier.endpointsMap，proxier.servieMap以及产生和维护Kube自定义链。 proxier.serviceMap：把sercvieChanges.current 写入proxier.serviceMap，再把存在于sercvieChanges.previous 但不存在于sercvieChanges.current 的service 从 proxier.serviceMap中删除，并且删除的时候，把使用UDP协议的cluster_ip 记录于UDPStaleClusterIP 。 proxier.endpointsMap：把endpointsChanges.previous 从proxier.endpointsMap 删除，再把endpointsChanges.current 加入proxier.endpointsMap。把存在于endpointsChanges.previous 但不存在于endpointsChanges.current 的endpoint 组装为ServiceEndpoint 结构，把该结构记录于staleEndpoints。 具体相关代码流程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// syncProxyRules是所有iptables-save/restore调用发生的地方。// 唯一的其他iptables规则是那些在iptablesInit()中设置的规则。func (proxier *Proxier) syncProxyRules() &#123; // ...省略 serviceUpdateResult := proxy.UpdateServiceMap(proxier.serviceMap, proxier.serviceChanges) endpointUpdateResult := proxy.UpdateEndpointsMap(proxier.endpointsMap, proxier.endpointsChanges) staleServices := serviceUpdateResult.UDPStaleClusterIP // 利用endpointUpdateResult.StaleServiceNames，再次更新 staleServices for _, svcPortName := range endpointUpdateResult.StaleServiceNames &#123; if svcInfo, ok := proxier.serviceMap[svcPortName]; ok &amp;&amp; svcInfo != nil &amp;&amp; svcInfo.GetProtocol() == v1.ProtocolUDP &#123; klog.V(2).Infof(\"Stale udp service %v -&gt; %s\", svcPortName, svcInfo.ClusterIPString()) staleServices.Insert(svcInfo.ClusterIPString()) &#125; &#125; ...&#125; //kubernetes/pkg/proxy/servcie.gofunc UpdateServiceMap(serviceMap ServiceMap, changes *ServiceChangeTracker) (result UpdateServiceMapResult) &#123; result.UDPStaleClusterIP = sets.NewString() // apply 方法中，继续调用了merge，filter, umerge // merge:将change.current的servicemap 信息合入proxier.servicemap中。 // filter:将change.previous和change.current共同存在的servicemap从将change.previous删除 // unmerge: 将change.previous 中使用UDP 的servicemap 从 proxier.serviceMap 中删除，并记录删除的服务IP 到UDPStaleClusterIP //apply中最后重置了proxy.serviceChanges.items serviceMap.apply(changes, result.UDPStaleClusterIP) //HCServiceNodePorts 保存proxier.serviceMap 中所有服务的健康检查端口 result.HCServiceNodePorts = make(map[types.NamespacedName]uint16) for svcPortName, info := range serviceMap &#123; if info.GetHealthCheckNodePort() != 0 &#123; result.HCServiceNodePorts[svcPortName.NamespacedName] = uint16(info.GetHealthCheckNodePort()) &#125; &#125; return result&#125; //kubernetes/pkg/proxy/endpoints.gofunc UpdateEndpointsMap(endpointsMap EndpointsMap, changes *EndpointChangeTracker) (result UpdateEndpointMapResult) &#123; result.StaleEndpoints = make([]ServiceEndpoint, 0) result.StaleServiceNames = make([]ServicePortName, 0) // 从proixer.endpointsMap 中删除和change.previous 相同的elelment. // 将change.current 添加至proixer.endpointsMap // StaleEndpoints 保存了存在于previous 但不存在current的endpoints // StaleServicenames保存了一种ServicePortName,这样的ServicePortName在change.previous不存在对应的endpoints，在change.current存在endpoints。 // 最后重置了了proxy.endpointsChanges.items endpointsMap.apply(changes, &amp;result.StaleEndpoints, &amp;result.StaleServiceNames) // computing this incrementally similarly to endpointsMap. result.HCEndpointsLocalIPSize = make(map[types.NamespacedName]int) localIPs := GetLocalEndpointIPs(endpointsMap) for nsn, ips := range localIPs &#123; result.HCEndpointsLocalIPSize[nsn] = len(ips) &#125; return result&#125; 准备好更新iptables需要的资源变量后，接下来就是调用iptables 命令建立自定义链了，并在对应的内核链上引用这些自定义链。这些自定义链在k8s 服务中是必须的，不会跟随资源变化而变化，所以在更新规则之前，提前无条件生成这些链，做好准备工作，随后会在这些自定义链上创建相应的规则。 继续看kubernetes/pkg/proxy/iptables/proxier.go，就是kube自定义链的创建过程了 1234567891011121314151617181920212223242526272829303132333435363738394041// 创建并连接kube链for _, jump := range iptablesJumpChains &#123; if _, err := proxier.iptables.EnsureChain(jump.table, jump.dstChain); err != nil &#123; klog.ErrorS(err, \"Failed to ensure chain exists\", \"table\", jump.table, \"chain\", jump.dstChain) return &#125; args := append(jump.extraArgs, \"-m\", \"comment\", \"--comment\", jump.comment, \"-j\", string(jump.dstChain), ) if _, err := proxier.iptables.EnsureRule(utiliptables.Prepend, jump.table, jump.srcChain, args...); err != nil &#123; klog.ErrorS(err, \"Failed to ensure chain jumps\", \"table\", jump.table, \"srcChain\", jump.srcChain, \"dstChain\", jump.dstChain) return &#125;&#125;// ensure KUBE-MARK-DROP chain exist but do not change any rulesfor _, ch := range iptablesEnsureChains &#123; if _, err := proxier.iptables.EnsureChain(ch.table, ch.chain); err != nil &#123; klog.ErrorS(err, \"Failed to ensure chain exists\", \"table\", ch.table, \"chain\", ch.chain) return &#125;&#125;// EnsureChain is part of Interface.func (runner *runner) EnsureChain(table Table, chain Chain) (bool, error) &#123; fullArgs := makeFullArgs(table, chain) runner.mu.Lock() defer runner.mu.Unlock() out, err := runner.run(opCreateChain, fullArgs) if err != nil &#123; if ee, ok := err.(utilexec.ExitError); ok &#123; if ee.Exited() &amp;&amp; ee.ExitStatus() == 1 &#123; return true, nil &#125; &#125; return false, fmt.Errorf(\"error creating chain %q: %v: %s\", chain, err, out) &#125; return false, nil&#125; 由于涉及到iptables内容了，以目前的能力再阅读代码已经深入不进了，因此只好借助网上的代码来分析实现了。据网上资料，上边代码完成的iptables命令如下： 12345678910111213141516171819202122232425262728# 在filter表中创建KUBE-EXTERNAL-SERVICES链iptables -w -N KUBE-EXTERNAL-SERVICES -t filter# 在filter表的INPUT链头增加跳转到 自定义KUBE-EXTERNAL-SERVICES 链的规则iptables -w -I INPUT -t filter -m conntrack --ctstate NEW -m comment --comment -j KUBE-EXTERNAL-SERVICES kubernetes externally-visible service portals # 在filter表中创建KUBE-SERVICES链iptables -w -N KUBE-SERVICES -t filter # 在filter表的OUTPUT链头增加跳转到 自定义 KUBE-SERVICES 链的规则iptables -w -I OUTPUT -t filter -m conntrack --ctstate NEW -m comment --comment -j KUBE-SERVICES kubernetes service portals# 在 nat 表中创建KUBE-SERVICES链iptables -w -N KUBE-SERVICES -t nat# 在 nat 表的OUTPUT链头增加跳转到 自定义 KUBE-SERVICES 链的规则iptables -w -I OUTPUT -t nat -m conntrack --ctstate NEW -m comment --comment -j KUBE-SERVICES kubernetes service portals iptables -w -N KUBE-SERVICES -t nat# 在 nat 表的 PREROUTING 链头增加跳转到 自定义 KUBE-SERVICES 链的规则iptables -w -I PREROUTING -t nat -m conntrack --ctstate NEW -m comment --comment -j KUBE-SERVICES kubernetes service portals # 在 nat 表中创建KUBE-POSTROUTING 链iptables -w -N KUBE-POSTROUTING -t nat# 在 nat 表的 PREROUTING 链头增加跳转到 自定义 KUBE-POSTROUTING 链的规则iptables -w -I POSTROUTING -t nat -m conntrack --ctstate NEW -m comment --comment -j KUBE-POSTROUTING kubernetes postrouting rules # 在 filter 表中创建 KUBE-FORWARD 链iptables -w -N KUBE-FORWARD -t filter# 在 filter 表的 FORWARD 链头增加跳转到 自定义 KUBE-FORWARD 链的规则iptables -w -I FORWARD -t filter -m conntrack --ctstate NEW -m comment --comment -j KUBE-FORWARD kubernetes forwarding rules 可见的是，在IPTables做了以下修改： filter表： 创建 KUBE-EXTERNAL-SERVICES 链 创建 KUBE-SERVICES 链 创建 KUBE-FORWARD 链 nat 表：创建KUBE-SERVICES链 创建 KUBE-SERVICES 链 创建 KUBE-POSTROUTING 链 并且在nat和filter表上原有的固定链前都增加了跳转到Kube自定义链的转发规则，从而使得所有进入固定链的流包在nat或filter 时，都会导入自定义链中。 可见通过上述的创建，在内核固定链中引用 K8S 的链时，这些新链都是作为内核固定链在nat表或filter表中的第一条规则。这样，所有进入固定链的流包在nat或filter 时，都会导入自定义链中。特别地，PREROUTING 和OUTPUT 的首条NAT规则都先将所有流量导入KUBE-SERVICE 链中，这样就截获了所有的入流量和出流量，进而可以对k8s 相关流量进行重定向处理。 继续沿着syncProxyRules函数看下去： 1234567891011121314151617for _, chainName := range []utiliptables.Chain&#123;kubeServicesChain, kubeExternalServicesChain, kubeForwardChain, kubeNodePortsChain&#125; &#123; if chain, ok := existingFilterChains[chainName]; ok &#123; proxier.filterChains.WriteBytes(chain) &#125; else &#123; proxier.filterChains.Write(utiliptables.MakeChainLine(chainName)) &#125;&#125;// 这边新出来了三条chain：kubeNodePortsChain、KubeMarkMasqChainfor _, chainName := range []utiliptables.Chain&#123;kubeServicesChain, kubeNodePortsChain, kubePostroutingChain, KubeMarkMasqChain&#125; &#123; if chain, ok := existingNATChains[chainName]; ok &#123; proxier.natChains.WriteBytes(chain) &#125; else &#123; //KUBE-NODEPORTS，KUBE-MARK-MASQ 之前并未被创建，现在创建 proxier.natChains.Write(utiliptables.MakeChainLine(chainName)) &#125;&#125; 至此，iptables/proxier.go中定义的8个chain我们已经见到了6个了，剩下的两个分别是KUBE-MARK-DROP、KUBE-PROXY-CANARY，这两个对我们走读执行逻辑就没有太多关联了，因此就不继续分析这两个链了。 123456789101112131415161718const ( // the services chain kubeServicesChain utiliptables.Chain = \"KUBE-SERVICES\" // the external services chain kubeExternalServicesChain utiliptables.Chain = \"KUBE-EXTERNAL-SERVICES\" // the nodeports chain kubeNodePortsChain utiliptables.Chain = \"KUBE-NODEPORTS\" // the kubernetes postrouting chain kubePostroutingChain utiliptables.Chain = \"KUBE-POSTROUTING\" // KubeMarkMasqChain is the mark-for-masquerade chain KubeMarkMasqChain utiliptables.Chain = \"KUBE-MARK-MASQ\" // KubeMarkDropChain is the mark-for-drop chain KubeMarkDropChain utiliptables.Chain = \"KUBE-MARK-DROP\" // the kubernetes forward chain kubeForwardChain utiliptables.Chain = \"KUBE-FORWARD\" // kube proxy canary chain is used for monitoring rule reload kubeProxyCanaryChain utiliptables.Chain = \"KUBE-PROXY-CANARY\") KUBE-MARK-DROP和KUBE-MARK-MASQ本质上就是使用了iptables的MARK命令: 对于KUBE-MARK-MASQ链中所有规则设置了kubernetes独有MARK标记，在KUBE-POSTROUTING链中对NODE节点上匹配kubernetes独有MARK标记的数据包，当报文离开node节点时进行SNAT，MASQUERADE源IP 而对于KUBE-MARK-DROP设置标记的报文则会在KUBE_FIREWALL中全部丢弃 Service类型分析 继续往下看，终于到了重点的地方：proxy如果通过service找到对应的EndPoints 12345678910111213func (proxier *Proxier) syncProxyRules() &#123; // ... // Build rules for each service. for svcName, svc := range proxier.serviceMap &#123; svcInfo, ok := svc.(*serviceInfo) // ... allEndpoints := proxier.endpointsMap[svcName] // 对拓扑感知端点进行过滤。该函数仅在适当的功能gates被启用，并且该服务没有冲突的配置（如externalTrafficPolicy=Local）时才会过滤端点。 allEndpoints = proxy.FilterEndpoints(allEndpoints, svcInfo, proxier.nodeLabels) // svcChain通过utiliptables.Chain(\"KUBE-SVC-\" + portProtoHash(servicePortName, protocol))创建的chain svcChain := svcInfo.servicePortChainName // ... clusterIP 123456789101112131415161718192021222324252627282930 /*** Capture the clusterIP. ***/if hasEndpoints &#123; // 填充转发选项-d和--dport args = append(args[:0], \"-m\", \"comment\", \"--comment\", fmt.Sprintf(`\"%s cluster IP\"`, svcNameString), \"-m\", protocol, \"-p\", protocol, \"-d\", utilproxy.ToCIDR(svcInfo.ClusterIP()), \"--dport\", strconv.Itoa(svcInfo.Port()), ) if proxier.masqueradeAll &#123; // 生成结果-A KUBE-SERVICES ...--comment $&#123;svc-port-name&#125; cluster IP ... -d $&#123;cluster_ip&#125;/32 -dport xxx -j KUBE-MARK-MASQ args := prepend(args, \"-A\", string(svcChain)) args = append(args, \"-j\", string(KubeMarkMasqChain)) proxier.natRules.Write(args...) &#125; else if proxier.localDetector.IsImplemented() &#123; // 生成结果 -A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; cluster IP ... -d $&#123;cluster_ip&#125;/32 -dport XXX ! -s $&#123;cluster_cidr&#125; -j KUBE-MARK-MASQ args := prepend(args, \"-A\", string(svcChain)) args = proxier.localDetector.JumpIfNotLocal(args, string(KubeMarkMasqChain)) proxier.natRules.Write(args...) &#125; args = prepend(args, \"-A\", string(kubeServicesChain)) // 总是将将目的地址是&#123;cluster_ip:port&#125; 的流量导入到KUBE-SVC-XXX， 即-A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; cluster IP ... -d $&#123;cluster_ip&#125;/32 -dport xxx -j KUBE-SVC-XXX args = append(args, \"-j\", string(svcChain)) proxier.natRules.Write(args...)&#125; else &#123; // No endpoints. // 如果服务没有endpoints, 在KUBE-SERVICES链上建立filter 规则（（将规则写入proxier.filterRules ，下同），表示放弃访问目的地址&#123;cluster_ip:port&#125;的包。 省略 // 生成结果：-A KUBE-SERVICES ...--comment &#123;svc-port-name&#125; has no endpoints ... -d $&#123;cluster_ip&#125;/32 -dport xxx -j REJECT &#125; /*** Capture the clusterIP. ***/ externalIPs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 /*** Capture externalIPs. ***/for _, externalIP := range svcInfo.ExternalIPStrings() &#123; // 如果 \"外部 \"IP恰好是本机的IP，则保持本机端口开放，这样就没有其他进程可以打开它（因为套接字可能会打开，但它永远不会工作）。 if (svcInfo.Protocol() != v1.ProtocolSCTP) &amp;&amp; localAddrSet.Has(netutils.ParseIPSloppy(externalIP)) &#123; lp := netutils.LocalPort&#123; Description: \"externalIP for \" + svcNameString, IP: externalIP, IPFamily: localPortIPFamily, Port: svcInfo.Port(), Protocol: netutils.Protocol(svcInfo.Protocol()), &#125; if proxier.portsMap[lp] != nil &#123; klog.V(4).InfoS(\"Port was open before and is still needed\", \"port\", lp) replacementPortsMap[lp] = proxier.portsMap[lp] &#125; else &#123; socket, err := proxier.portMapper.OpenLocalPort(&amp;lp) if err != nil &#123; msg := fmt.Sprintf(\"can't open port %s, skipping it\", lp.String()) proxier.recorder.Eventf( &amp;v1.ObjectReference&#123; Kind: \"Node\", Name: proxier.hostname, UID: types.UID(proxier.hostname), Namespace: \"\", &#125;, nil, v1.EventTypeWarning, err.Error(), \"SyncProxyRules\", msg) klog.ErrorS(err, \"Can't open port, skipping it\", \"port\", lp) continue &#125; klog.V(2).InfoS(\"Opened local port\", \"port\", lp) replacementPortsMap[lp] = socket &#125; &#125; if hasEndpoints &#123; args = append(args[:0], \"-m\", \"comment\", \"--comment\", fmt.Sprintf(`\"%s external IP\"`, svcNameString), \"-m\", protocol, \"-p\", protocol, \"-d\", utilproxy.ToCIDR(netutils.ParseIPSloppy(externalIP)), \"--dport\", strconv.Itoa(svcInfo.Port()), ) destChain := svcXlbChain if !svcInfo.NodeLocalExternal() &#123; destChain = svcChain args := prepend(args, \"-A\", string(svcChain)) // This masquerades off-cluster traffic to a External IP. // -A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; external IP ... -d $&#123;external_ip&#125;/32 -dport xxx -m physdev ! --physdev-is-in -m addrtype ! --src-type LOCAL -j KUBE-SVC-xxx if proxier.localDetector.IsImplemented() &#123; proxier.natRules.Write( proxier.localDetector.JumpIfNotLocal(args, string(KubeMarkMasqChain))...) &#125; else &#123; proxier.natRules.Write( append(args, \"-j\", string(KubeMarkMasqChain))...) &#125; &#125; // Send traffic bound for external IPs to the service chain. // -A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; external IP ... -d $&#123;external_ip&#125;/32 -dport xxx -m addrtype --dst-type LOCAL -j KUBE-SVC-xxx args = prepend(args, \"-A\", string(kubeServicesChain)) proxier.natRules.Write( append(args, \"-j\", string(destChain))...) &#125; else &#123; // No endpoints. // -A KUBE-EXTERNAL-SERVICES ...--comment $&#123;svc-port-name&#125; has no endpoints ... -d $&#123;external_ip&#125;/32 -dport xxx -j REJECT &#125;&#125; /*** Capture externalIPs. ***/ load-balancer 1// ... Capture load-balancer ingress. 省略 NodePort. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 /*** Capture NodePort. ***/ // 如果我们有2条以上的规则，也许值得为节点端口规则做一个新的每个服务链，但只有2条规则，最终是一种浪费和认知上的负担。if svcInfo.NodePort() != 0 &#123; // 保持本地端口的开放，因此没有其他进程可以打开它（因为套接字可能会打开，但它永远不会工作）。 if len(nodeAddresses) == 0 &#123; continue &#125; lps := make([]netutils.LocalPort, 0) for address := range nodeAddresses &#123; lp := netutils.LocalPort&#123; Description: \"nodePort for \" + svcNameString, IP: address, IPFamily: localPortIPFamily, Port: svcInfo.NodePort(), Protocol: netutils.Protocol(svcInfo.Protocol()), &#125; if utilproxy.IsZeroCIDR(address) &#123; // Empty IP address means all lp.IP = \"\" lps = append(lps, lp) // If we encounter a zero CIDR, then there is no point in processing the rest of the addresses. break &#125; lps = append(lps, lp) &#125; // For ports on node IPs, open the actual port and hold it. for _, lp := range lps &#123; if proxier.portsMap[lp] != nil &#123; klog.V(4).InfoS(\"Port was open before and is still needed\", \"port\", lp) replacementPortsMap[lp] = proxier.portsMap[lp] &#125; else if svcInfo.Protocol() != v1.ProtocolSCTP &#123; socket, err := proxier.portMapper.OpenLocalPort(&amp;lp) if err != nil &#123; msg := fmt.Sprintf(\"can't open port %s, skipping it\", lp.String()) proxier.recorder.Eventf( &amp;v1.ObjectReference&#123; Kind: \"Node\", Name: proxier.hostname, UID: types.UID(proxier.hostname), Namespace: \"\", &#125;, nil, v1.EventTypeWarning, err.Error(), \"SyncProxyRules\", msg) klog.ErrorS(err, \"Can't open port, skipping it\", \"port\", lp) continue &#125; klog.V(2).InfoS(\"Opened local port\", \"port\", lp) replacementPortsMap[lp] = socket &#125; &#125; /*** Capture externalIPs. ***/ if hasEndpoints &#123; args = append(args[:0], \"-m\", \"comment\", \"--comment\", svcNameString, \"-m\", protocol, \"-p\", protocol, \"--dport\", strconv.Itoa(svcInfo.NodePort()), ) //if hasEndpoints &amp;&amp; if !svcInfo.NodeLocalExternal, 在NAT表写入：-A KUBE-NODEPORTS ... --comment $&#123;svc-port-name&#125; --dport &#123;nodeport&#125; -j KUBE-MARK-MASQ、 -A KUBE-NODEPORTS ... --comment $&#123;svc-port-name&#125; --dport $&#123;nodeport&#125; -j KUBE-SVC-xxx if !svcInfo.NodeLocalExternal() &#123; // Nodeports need SNAT, unless they're local. proxier.natRules.Write( append(prepend(args, \"-A\", string(svcChain)), \"-j\", string(KubeMarkMasqChain))...) // Jump to the service chain. proxier.natRules.Write( append(prepend(args, \"-A\", string(kubeNodePortsChain)), \"-j\", string(svcChain))...) &#125; else &#123; // 否则-A KUBE-NODEPORTS ... --comment $&#123;svc-port-name&#125; --dport $&#123;nodeport&#125; -s 127.0.0.0/8 -j KUBE-SVC-xxx、 -A KUBE-NODEPORTS ... --comment $&#123;svc-port-name&#125; --dport $&#123;nodeport&#125; -j KUBE-XLB-xxx // Fix localhost martian source error loopback := \"127.0.0.0/8\" if isIPv6 &#123; loopback = \"::1/128\" &#125; args = prepend(args, \"-A\", string(kubeNodePortsChain)) proxier.natRules.Write( append(args, \"-s\", loopback, \"-j\", string(KubeMarkMasqChain))...) proxier.natRules.Write( append(args, \"-j\", string(svcXlbChain))...) &#125; &#125; else &#123; // No endpoints. // 增加REJECT规则拒绝该流量, 省略 // -A KUBE-EXTERNAL-SERVICES ... -m addrtype --dst-type LOCAL ... --dport $&#123;nodeport&#125; -j REJECT &#125;&#125; /*** Capture NodePort. ***/ 上述代码主要针对四种情况做了规则处理： 为cluster_ip 设置访问规则 为有endpints 的服务在KUBE-SERVICES 链上建立nat表规则（将规则写入proxier.natRules ，下同）： 如果设置了proxier.masqueradeAll , kube-proxy 会对所有目的地址是{cluster_ip:port}的包打标签，进 而做SNAT；或者如果指定了–cluster–cidr , kube-proxy 会对目的地址是{cluster_ip:port} 的集群外部（! -s ${cluster_cidr}）流量包打标签，进而做SNAT；（以上规则二选一） 总是将将目的地址是{cluster_ip:port} 的流量导入到KUBE-SVC-XXX 如果服务没有endpoints, 在KUBE-SERVICES链上建立filter 规则，表示放弃访问目的地址{cluster_ip:port}的包。 得到的iptable命令如下： 12345-A KUBE-SERVICES ...--comment $&#123;svc-port-name&#125; cluster IP ... -d $&#123;cluster_ip&#125;/32 -dport xxx -j KUBE-MARK-MASQ # if proxier.masqueradeAll =True-A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; cluster IP ... -d $&#123;cluster_ip&#125;/32 -dport XXX ! -s $&#123;cluster_cidr&#125; -j KUBE-MARK-MASQ # else if len(proxier.clusterCIDR) &gt; 0-A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; cluster IP ... -d $&#123;cluster_ip&#125;/32 -dport xxx -j KUBE-SVC-XXX # 有endpoints 时总是添加此规则-A KUBE-SERVICES ...--comment &#123;svc-port-name&#125; has no endpoints ... -d $&#123;cluster_ip&#125;/32 -dport xxx -j REJECT // 没有endpoint时，直接将发往此IP：Port的包丢弃 为externalIP 类型服务建立规则 如果external IP 是本机IP，并且服务使用的协议不是SCTP, 生成结构体LocalPort 以记录这样的服务的external IP , port ,协议，以及描述信息。 确认在本机上打开服务端口(可以把这个socket理解为“占位符”，以便让操作系统为本机其他应用程序分配端口时让开该端口），并且添加{LocalPort ：socket} 到replacementPortsMap。 如果该服务有endpoints ，在KUBE-SERVICES 链添加 nat 表规则 对于到external_ip:port 的包打标签； 对于从集群外发送的目的地址是extenralIP 的包建立规则 对于目的地址和node 地址相同的包建立规则 如果该服务没有endpoints ，在KUBE-EXTERNAL-SERVICES 添加 filter 规则，表示放弃目的地址是{ {external_ip:xxx}的包 得到的iptable命令如下： 1234567-A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; external IP ... -d $&#123;external_ip&#125;/32 -dport xxx -j KUBE-MARK-MASQ-A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; external IP ... -d $&#123;external_ip&#125;/32 -dport xxx -m physdev ! --physdev-is-in -m addrtype ! --src-type LOCAL -j KUBE-SVC-xxx-A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; external IP ... -d $&#123;external_ip&#125;/32 -dport xxx -m addrtype --dst-type LOCAL -j KUBE-SVC-xxx-A KUBE-EXTERNAL-SERVICES ...--comment $&#123;svc-port-name&#125; has no endpoints ... -d $&#123;external_ip&#125;/32 -dport xxx -j REJECT 服务类型为LoadBalancer时，设置外部负载均衡相关规则 为NodePort 类型服务规则建立： 得到的iptable命令如下： 123456789101112replacementPortsMap[lp] = proxier.portsMap[lp] ,并且打开端口//if hasEndpoints &amp;&amp; if !svcInfo.OnlyNodeLocalEndpoints, 在NAT表写入：-A KUBE-NODEPORTS ... --comment $&#123;svc-port-name&#125; --dport &#123;nodeport&#125; -j KUBE-MARK-MASQ-A KUBE-NODEPORTS ... --comment $&#123;svc-port-name&#125; --dport $&#123;nodeport&#125; -j KUBE-SVC-xxx//if hasEndpoints &amp;&amp; if svcInfo.OnlyNodeLocalEndpoints，在NAT表写入：-A KUBE-NODEPORTS ... --comment $&#123;svc-port-name&#125; --dport $&#123;nodeport&#125; -s 127.0.0.0/8 -j KUBE-SVC-xxx-A KUBE-NODEPORTS ... --comment $&#123;svc-port-name&#125; --dport $&#123;nodeport&#125; -j KUBE-XLB-xxx// !if hasEndpoints ,在Filter表写入：-A KUBE-EXTERNAL-SERVICES ... -m addrtype --dst-type LOCAL ... --dport $&#123;nodeport&#125; -j REJECT 以上讲解了IPTables模式下将流量转发到相应的具体的KUBE-SERVICE-XXX上，而之后还需要解决的是将service的流量发给具体的EndPoint即执行Pod——建立 endpoints 相关的链和规则 为同一个service 的所有endpoints 在nat 表建立链 KUBE-SEP-XXX : KUBE-SEP-XXX -[0:0]，并且记录 activeNATChains[endpointChain] = true，endpointChain为endpointChain := epInfo.endpointChain(svcNameString, protocol)中创建的KUBE-SEP-XXX 如果服务设置了”clientIP“ 亲和性， 则为该服务的每一个endpoint 设置会话亲和性-A KUBE-SVC-XXX -m recent --name KUBE-SEP-XXX --rcheck --seconds xxx --reap -j KUBE-SEP-XXX //多个endpoints,则有多条类似规则 在endpointsChain 链上建立NAT规则 对于多个endpoints (n &gt;1) ,利用iptables 的随机和概率转发的功能，循环建立规则。概率计算是通过查表（precomputeProbabilities 字符串数组）或者现场计算（n&gt;= len(precomputeProbabilities) 的方式完成。 123456789/** 概率是通过1.0/float64(n-i)计算出来的，n 代表endpoints的个数 */// 前n-1个endpoints使用此规则-A KUBE-SVC-XXX -m static --mode random --probability xxx -j KUBE-SEP-XXX // 第n个endpoint 建立此规则-A KUBE-SVC-XXX -j KUBE-SEP-XXX -A KUBE-SEP-XXX -s $&#123;endpoint_ip&#125;/32 -j KUBE-MARK-MASQ-A KUBE-SEP-XXX -m recent --name KUBE-SEP-XXX --set -j DNAT --to-destination xxx // 如果设置了会话亲和性，写入该条规则-A KUBE-SEP-XXX -j DNAT --to-destination xxx //如果没有设置会话亲和性，写入该条规则 在KUBE-SEP-XXX链上通过DNAT规则，真正把流量交到了对应POD的服务上。 如果服务还具有OnlyNodeLocalEndpoints 属性，表示只将流量导入到本机上的后端pod上。挑选出和proxy 在相同机器运行的endpoints，在nat 表建立如下规则 12345678910-A KUBE-XLB-XXX ... -s $&#123;cluster-ip&#125; -j KUBE-SVC-XXX // 设置了clusterCIDR//如果没有Local POD-A KUBE-XLB-XXX ... --comment $&#123;svc-port-name&#125; has no local endpoints -j KUBE-MARK-DROP//如果有Local POD -A KUBE-XLB-XXX ... -m recent --name KUBE-SEP-XXX -rchenck --seconds xxx -j KUBE-SEP-XXX //设置了亲和性//如果有多个pods,设置-A KUBE-XLB-XXX ... -m static --mode --probability xxx -j KUBE-SEP-XXX-A KUBE-XLB-XXX ... -m static --mode --probability xxx -j KUBE-SEP-XXX 至此，我们看完了func (proxier *Proxier) syncProxyRules()中的核心内容：遍历完成了对serviceMap 中所有服务及对应的endpoints 建立规则。针对Service的不同类型，我们也知道了为什么可以Work。也知道了为什么本地服务可以通过ClusterIP:Port的方式找到服务，外网的请求可以通过NodeIP:NodePort的方式找到服务。至于如何找到相应Pod的再详细说明可以见网上的样例分析：kubernetes入门之kube-proxy实现原理 总结图 最后的最后，放张我自己画的CLI启动ProxyServer Run()的顺序图，和大佬总结的资源更新示意图以及链、规则建立顺序图吧。 Reference: spf13/cobra flag–命令行参数解析之StringVar 【kubernetes/k8s概念】kube-proxy启动参数 k8s源码分析——kube-proxy 源码分析——梳理了整体的执行过程 kubernetes入门之kube-proxy实现原理——分析了外网如何通过NodePort找到相应EndPoint的案例 理解kubernetes环境的iptables——对链上关系分析的比较好","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"源码解析","slug":"源码解析","permalink":"https://nymrli.top/tags/源码解析/"}]},{"title":"CICD-Jenkins与Travis","slug":"CICD-Jenkins与Travis","date":"2021-10-25T05:39:46.000Z","updated":"2022-01-13T05:32:47.364Z","comments":true,"path":"2021/10/25/CICD-Jenkins与Travis/","link":"","permalink":"https://nymrli.top/2021/10/25/CICD-Jenkins与Travis/","excerpt":"","text":"Jenkins与travis使用 Jenkins与Travis为CI、CD工具，其为Devops模式下的平台组件，能够让我们更好地进行开发测试与交付。由于最近云原生的课上在介绍DevOps和云监控，所以正好趁这个机会体验下Devops的交付流程，之前也有使用过Github Action作为CICD工具，但除了开源项目以外，Github使用比较少。这次呢就可以再熟悉下业内常用的CICD组件了：Jenkins or Travis DevOps发展背景 传统交付模式的串行及隔离化形成了部门壁垒，降低了工作效率 通过“在云上创建资源”-&gt;实现“云服务器自动化管理”-&gt;“应用无状态上云”后即可实现应用的持续部署、持续交付，完成一次构建、到处运行的效果 作为一种新式的开发模式，DevOps模式是在互联网应用快速迭代的需要下，结合了开发与运维以及测试流程的一种模式，解决了测试资源匮乏、手工部署工作量大、周期长，环境不统一、资源难管理的问题。 实现的功能 DevOps平台典型流程 基于镜像容器构筑具备完全一致性的开发测试环境 企业中Devops的解决方案 建设成果 Jenkins使用 Jenkins跟Gitlab一样，是发布了服务包的，为了更好的管理和使用，我这边是直接使用的Jenkins Docker镜像 拉取Jenkins镜像并运行 docker run -p 8080:8080 -p 50000:50000 --restart=always --name jenkins -v jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):$(which docker) jenkins/jenkins:lts --restart=always:能够使我们在重启docker时，自动启动相关容器 --name jenkins: 将启动的容器名取作jenkins -v jenkins_home:/var/jenkins_home： 挂载持久化卷 -v /var/run/docker.sock:/var/run/docker.sock：为了实现pipeline在另一个容器中运行，侦听docker.sock套接字，并执行挂载 -v $(which docker):$(which docker)：-v 之后使用$()表示执行命令，这里表示如果在容器上运行which docker， Docker也会在本地计算机上运行“ which container&quot;并将执行结果返回给容器，从而能在Jenkins容器中拿到另一个容器的containerID 最后的jenkins/jenkins:lts：表示要拉取的镜像以及镜像版本 将容器跑起来后需要进入容器，给docker.sock授权: 123docker exec -it --user=root jenkins bashchmod 666 /var/run/docker.sockls -ltr /var/run 以上过后就可以在浏览器上登录Jenkins了，这边登录localhost:50000后会有一系列初始化步骤如下 安装建议的插件 创建第一个管理员用户 Jenkins实例配置 开始使用 Jenkins 监听Github仓库变化 选择“新建任务”-&gt;“流水线”-&gt;勾选Github项目并输入https://github.com/Freedomisgood/iotrfid.git/-&gt;构建触发器中选择“GitHub hook trigger for GITScm polling”-&gt;流水线选择“Pipeline script”输入： 1234567891011121314151617pipeline &#123; agent &#123; docker &#123; image 'alpine' &#125; &#125; stages &#123; stage('pull project') &#123; // agent &#123; docker 'openjdk:8-jre' &#125; steps &#123; // echo 'Hello, JDK' git credentialsId: 'GithubAccount', url: 'https://github.com/Freedomisgood/iotrfid.git/' sh 'pwd' &#125; &#125; &#125;&#125; 然后保存，之后运行就可以等待触发啦，或者点击左侧的“立即构建” 注：可以看到script中有使用到docker，这边需要额外安装Docker的插件Docker Pipeline、Docker plugin（建议安装的插件中没有），如果不安装会执行失败 注：如果要监听Github仓库的变化，则需要增加Github的凭据：选择“Dashboard”到首页-&gt;系统管理-&gt;Manage Credendials-&gt;Jenkins-&gt;全局凭据-&gt;左侧的添加凭据，输入Github用户和密码后，留一个之后要使用的Credendials ID 参考：怎样用 Jenkins Docker 和 CICD 构建无服务器应用程序 Travis使用 Travis+Docker[+阿里云容器镜像、dockerhub] travis主要是关注在CI持续集成上，同时与Github关联搭配做的比较号，也能完成持续交付(持续集成的基础上，增加打包构建形成产物)的工作。因此本次就以travis+docker来完成这么一个持续集成与持续交付的步骤： 步骤如下： 去travis官网绑定travis和github Dockerhub创建镜像仓库 or 阿里云开通容器镜像服务 项目中添加.travis.yml和Dockerfile文件 1234567FROM python:3.9.1-alpineMAINTAINER Mrli 1063052964qq.comRUN tar -zcf app.tar.gz .ADD app.tar.gz /appWORKDIR /appRUN pip install -r local_requiements.txtENTRYPOINT python app/main.py 123456789101112131415161718192021222324252627language: python# sudo: enabled or requiredpython: - \"3.9.1\"branches: only: - masterinstall: - pip install -r local_requirements.txtbefore_script: - flake8 app tests - docker login -u $DOCKERHUB_USERNAME -p $DOCKERHUB_PASSWORD # dockerfile中需要拉取 python-3.9.1:alipine的镜像, 所以需要先docker loginscript: - python app/main.py - docker build -t nymrli/python:v2 .after_success: - docker login -u $username -p $password # 这里我们使用环境变量来控制，避免写死。环境变量，在travis的后台settings里面添加 - docker push - echo \"success\"services: # 需要提供docker才能在里面使用docker命令 - docker git push提交代码，travis会侦听github仓库变化触发githook从而执行任务 登录要运行app的服务器，docker-compose up将镜像启动 1234567891011121314151617181920212223242526272829303132333435version: '2'services: mysql: container_name: mysql1 image: mysql:5.7 environment: MYSQL_ROOT_PASSWORD: 数据库密码 ports: - \"3306:3306\" volumes: - /usr/local/docker/mysql/data:/var/lib/mysql - /usr/local/docker/mysql/conf:/etc/mysql - /usr/local/docker/mysql/logs:/var/log/mysql web: container_name: jafir_nginx1 image: registry.cn-hangzhou.aliyuncs.com/jafir_docker_images/web:latest ports: - 8080:80 restart: always depends_on: - java volumes: - /mydockerdata/nginx/etc/nginx.conf:/etc/nginx/nginx.conf - /mydockerdata/nginx/log/:/var/log/nginx java: container_name: jafir_gps1 image: registry.cn-hangzhou.aliyuncs.com/jafir_docker_images/jafir-images:latest restart: always depends_on: - mysql ports: - 9090:9090 volumes: - /mydockerdata/java/gps/upload:/Users/jafir/Downloads/upload - /mydockerdata/arme/out/*.nofoo.cn/*.nofoo.cn.pfx:/Users/jafir/Downloads/upload/cert/*.nofoo.cn.pfx 注：如果需要travis的构建过程中在服务器执行一些命令（如将代码部署发到自己的服务器上），还需要配置生成公钥和私匙，参看： https://juejin.cn/post/6931980888267816974 https://www.jianshu.com/p/ce648e120727 https://github.com/gopl/ci Travis CI+Coveralls 配置Travis 编写.travis.yml 使用 GitHub 账号登陆 Travis CI，Oauth登录授权，获得组织访问权限 设置 Build Status：打开指定仓库的监听状态选项 配置 Coveralls 在.travis.yml中添加coveralls内容，如go的库叫goveralls ，python的库叫 123456789101112# GObefore_install: - go get github.com/mattn/goverallsscript: - goveralls -service=travis-ci# Pythoninstall: - pip install coverallsscript: - nosetests --with-coverage --cover-package=fanpyafter_success: - coveralls 使用 GitHub 账号登陆 Coverallshttps://travis-ci.org/)，Oauth登录授权，获得组织访问权限 设置Coverage Status: 打开指定仓库的监听状态选项 自动部署 通过配合Travis的使用，我们可以实现如下的效果： 测试部署：每次push代码到dev分支，Travis会自动进行单元测试，然后自动的通过SSH将代码部署到对应的开发机器上并重启服务，以保持开发机上始终是最新的版本。 正式部署：决定上线的时候可以将代码push代码到deploy分支上，Travis会自动将代码部署到正式的开发环境。 步入正题，要完成自动部署，首先Travis要能监听Git的变化，然后Travis还需要有权限登录到我们的SSH服务器进行部署： 配置Travis，让Travis能监听Git的某个分支。 Git某个分支提交之后，Travis能自动发现提交并进行编译。 Travis将编译后的产物通过SSH部署到给我们指定的机器。 Travis添加SSH密钥 通常我们是通过ssh命令加上用户名和密码访问服务器的，虽然理论上我们也可以在travis的命令中写上诸如ssh mofei@zhuwenlong.com -p abc的脚本，但是这样的代码如果提交到了公开的仓库中会有很大的泄露服务器密码的风险，所以我们需要一个别人无法窃取密码或者密钥的方式让Travis登录我们的服务器。 通常的免密登录是基于SSH信任关系的，那么如果我们能把密钥以加密的形式保持在Travis的服务器中，Travis就能登录我们的服务器了。这里我们可以使用Travis的文件加密功能，把我们的密钥进行加密保存。 在这个过程中，我们的密钥首先会被被Travis加密，解密的密钥被存储在Travis中，就是说只有Travis可以进行解密。所以我们可以大胆的把这个加密后的文件上传到github中，不用担心其他人盗用我们的密钥。 ▲. 既然我们想要使用Travis加密文件，第一件事情就是在本地安装Travis。 因为travis是用ruby写的，首先得查看是否有ruby，ruby -V 给ruby换源，gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ 安装travis: sudo gem install travis 安装好Travis之后，我们需要在命令行中登录Travis: travis login --pro，pro指定的是API网站Travis CI Pro 注意 Travis 目前有两个官网：travis-ci.com 和 travis-ci.org. 官方通知后者即将关闭，所以我们使用前者参数为–pro，后者参数为–org。 12345678Shell completion not installed. Would you like to install it now? |y| yWe need your GitHub login to identify you.This information will not be sent to Travis CI, only to api.github.com.The password will not be displayed.Try running with --github-token or --auto if you don&apos;t want to enter your password anyway.Username: 或者直接:travis login --github-token token --pro, github-token打开github后点击个人头像Github&gt;settings&gt;Personal access tokens&gt; Generate new token &gt; Generate token&gt; Copy Token 12(env38) mrli@VM-4-7-ubuntu:~/remap/cook$ travis login --pro --github-token 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Successfully logged in as Freedomisgood! 生成并加密SSH密钥 12# 在当前目录生成密钥: 这段代码执行完成之后，会在目录中生成2个文件，私钥deploy_rsa和公钥deploy_rsa.pub，前者是用来免密登录服务器时候使用的，后者服务器用来鉴定私钥的有效性的。ssh-keygen -t rsa -b 4096 -C 'build@travis-ci.org' -f ./deploy_rsa 下面的操作得在Github仓库下 12345678# 使用Travis加密, 注意加上--pro 指定api, 执行完命令，会生成加密文件 id_rsa.enc，.travis.yml 中会被写入解密命令：这几行被自动添加的代码的意思是，在`install`之前执行解开`deploy_rsa.enc`文件的命令并放置到`deploy_rsa`以供使用，其中这里的`$encrypted_137f45644142_key`和`$encrypted_137f45644142_iv`是解开这个文件的两个变量被存储在了`Travis`的服务器上。travis encrypt-file deploy_rsa --add --pro# 添加信任关系: 这句话的意思是向目标服务器(&lt;ssh-user&gt;@&lt;deploy-host&gt;这里的user和host需要替换成自己服务器的用户名和地址)添加公钥，添加成功之后，所有用该公钥对应的私钥访问服务器都会直接被认证通过。也就是说如果Travis保持了私钥的话，就可以免密的通过ssh登录我们的服务器了。ssh-copy-id -i deploy_rsa.pub &lt;ssh-user&gt;@&lt;deploy-host&gt; # # 删除敏感文件: 私钥deploy_rsa和公钥deploy_rsa.pub已经完成了他们的使命，我们可以把它删除以免被其他人恶意使用，并把生成的加密文件deploy_rsa.enc和修改后的.travis.yml添加到git中。rm -f deploy_rsa deploy_rsa.pub# 将修改添加到git中git add deploy_rsa.enc .travis.yml 生成的.travis.yml文件内容 123before_install: # 可以看到有两个变量: encrypted_f217180e22ee_key, encrypted_f217180e22ee_iv - openssl aes-256-cbc -K $encrypted_f217180e22ee_key -iv $encrypted_f217180e22ee_iv -in id_rsa.enc -out id_rsa -d -in 表示输入文件，即我们要解密的文件 -out 表示解密后的文件，这里我们需要手动将路径修改为 ~/.ssh/id_rsa ▲.同时travis仓库中也出现了encrypted_f217180e22ee_key, encrypted_f217180e22ee_iv这两个变量 所有的一切都准备好之后，我们就可以修改.travis.yml文件让travis来进行部署了。 首先，我们需要在部署之前解密私钥，并使其生效，所以我们添加如下代码： 123456789101112131415161718before_install: # 一行是解密ssh文件，后面的3行是使ssh密钥生效 # 把项目下的deploy_rsa.enc加密文件，解密输出到/tmp/deploy_rsa中, 一般是~/.ssh/id_rsa, 不过也跟如何ssh-keygen有关 - openssl aes-256-cbc -K $encrypted_137f45644142_key -iv $encrypted_137f45644142_iv -in deploy_rsa.enc -out /tmp/deploy_rsa -d # 开启 ssh-agent，即允许使用 ssh 命令 - eval \"$(ssh-agent -s)\" # 给予 id_rsa 文件权限，避免警告 - chmod 600 /tmp/deploy_rsa # 将私钥添加到ssh(看其他教程这一步貌似不需要) - ssh-add /tmp/deploy_rsa after_success: # 下面就是一些需要远程登陆的命令啦: scp, ssh, - scp -o stricthostkeychecking=no -r target/wx-java-miniapp-0.0.1-SNAPSHOT.jar &lt;ssh-user&gt;@&lt;deploy-host&gt;:/www/wwwroot/travis-app/wx-java-miniapp - ssh &lt;ssh-user&gt;@&lt;deploy-host&gt; -o stricthostkeychecking=no \"mkdir travis_deploy_success\" - rsync -az --delete ./dist/* &lt;USERNAME&gt;@&lt;HOST&gt;:&lt;TARGET-PATH&gt; 上传触发测试, git commit -m &quot;xxx&quot; &amp;&amp; git push 123456789101112131415161718192021222324252627282930language: node_jsnode_js: - lts/*branches: only: - main - masterinstall: - npm install yarnbefore_script: # 把项目下的deploy_rsa.enc加密文件，解密输出到/tmp/deploy_rsa中 - openssl aes-256-cbc -K $encrypted_db2095f63ba3_key -iv $encrypted_db2095f63ba3_iv -in deploy_rsa.enc -out /tmp/deploy_rsa -d - eval \"$(ssh-agent -s)\" # 给予 id_rsa 文件权限，避免警告 - chmod 600 /tmp/deploy_rsa # 将私钥添加到 ssh - ssh-add /tmp/deploy_rsascript: - yarn buildafter_success: - echo \"success!\"services: - dockeraddons: ssh_known_hosts: - 49.235.118.244after_success: # 非交互方式登录 StrictHostKeyChecking=no - ssh mrli@49.235.118.244 -o stricthostkeychecking=no \"docker run -d --name cgf -p 3000:80 nymrli/sucsoft-inititializer-front\" 参考： 教程：https://juejin.cn/post/6844903780819927053——文章是2017年的，但思路是对的 示例项目：https://github.com/gongsir0630/wx-java-miniapp——文件是2021年比较新，但基本没讲解，只是跑通了 使用Travis CI部署项目到服务器——创建专门给travis使用的账户、吧travis安装在docker中 附录： CICD概念 持续集成：以前是多个开发测试完毕后，才把代码往主分支上合并，可能交叉、冲突，合并之后还可能产生新的问题。而持续集成，就是经常提交代码到主分支，一天可能好几次。并且，自动化地进行单元测试并提供测试报告等，这样的话就能拆分细度颗粒，保证产品能够一步一步地安全可靠地迭代。很多以测试驱动开发的公司就是这样做的。 持续交付：持续集成的基础上，增加打包构建形成产物。 持续部署：持续交付的基础上，增加部署到相应的线上环境。 总而言之，这些持续做的事情，就是为了经常提交代码自动化测试、运行、部署，反馈问题，解决问题，再测试、运行、部署依次循环。持续部署还有个好处，对我们个人网站来说，我们可以直接提交代码，后续一系列过程都是自动化的，就不用管了，它自己自动部署发布。 案例 1234567891011121314151617181920212223242526272829303132333435language: javaos: linuxdist: xenialjdk:- openjdk8env: global: - COMMIT=$&#123;TRAVIS_COMMIT::7&#125;addons: ssh_known_hosts: - 39.106.230.88services:- dockerscript: mvn clean package -Dmaven.test.skip=trueafter_success:- echo \"$DOCKER_PASSWORD\" | docker login -u \"$DOCKER_USERNAME\" --password-stdin- export TAG=`if [ \"$TRAVIS_BRANCH\" == \"main\" ]; then echo \"latest\"; else echo $TRAVIS_BRANCH;fi`- export IMAGE_NAME=gongsir0630/wx-java-miniapp- docker build -t $IMAGE_NAME:$COMMIT .- docker tag $IMAGE_NAME:$COMMIT $IMAGE_NAME:$TAG- docker push $IMAGE_NAME:$TAG- scp -o stricthostkeychecking=no -r target/wx-java-miniapp-0.0.1-SNAPSHOT.jar travis@yzhelp.top:/www/wwwroot/travis-app/wx-java-miniapp- ssh travis@yzhelp.top -o stricthostkeychecking=no \"sh /www/wwwroot/travis-app/wx-java-miniapp/restart.sh\"branches: only: - mainnotifications: email: - gongsir0630@gmail.combefore_install: - openssl aes-256-cbc -K $encrypted_f217180e22ee_key -iv $encrypted_f217180e22ee_iv -in id_rsa.enc -out ~/.ssh/id_rsa -d - chmod 600 ~/.ssh/id_rsa - echo -e \"Host yzhelp.top\\n\\tStrictHostKeyChecking no\\n\" &gt;&gt; ~/.ssh/config My demo: 1234567891011121314151617181920212223242526272829303132333435363738394041424344language: node_jsnode_js: - lts/*branches: only: - main - masterinstall: - npm install yarnaddons: ssh_known_hosts: - 49.235.118.244env: global: - IMAGE_NAME=nymrli/sucsoft-inititializer-front - IMAGE_TAG=latest - CONTAINER_NAME=cgfbefore_script: - docker login -u $DOCKERHUB_USERNAME -p $DOCKERHUB_PASSWORD # 把项目下的deploy_rsa.enc加密文件，解密输出到/tmp/deploy_rsa中 - openssl aes-256-cbc -K $encrypted_db2095f63ba3_key -iv $encrypted_db2095f63ba3_iv -in deploy_rsa.enc -out /tmp/deploy_rsa -d - eval \"$(ssh-agent -s)\" # 给予 id_rsa 文件权限，避免警告 - chmod 600 /tmp/deploy_rsa # 将私钥添加到 ssh - ssh-add /tmp/deploy_rsascript: - yarn buildafter_success: - docker build -t $&#123;IMAGE_NAME&#125;:$&#123;IMAGE_TAG&#125; . - docker push $&#123;IMAGE_NAME&#125;:$&#123;IMAGE_TAG&#125; # 停止和删除已有容器，删除已有镜像并运行新镜像 - ssh mrli@49.235.118.244 -o stricthostkeychecking=no \"docker stop $&#123;CONTAINER_NAME&#125;; docker rm $&#123;CONTAINER_NAME&#125; ;docker rmi $(docker images -q $&#123;IMAGE_NAME&#125;:$&#123;IMAGE_TAG&#125;);docker run -d --name $&#123;CONTAINER_NAME&#125; -p 3000:80 $&#123;IMAGE_NAME&#125;:$&#123;IMAGE_TAG&#125;\" - echo \"success!\" services: - docker travis.yml中的宏变量 123456- $TRAVIS_BRANCH- $GH_TOKEN（生成的 Personal access tokens） $GIT_NAME（部署时的提交者名称） $GIT_EMAIL（部署时的提交者邮箱） $CUSTOM_DOMAIN（自定义域名） $CUSTOM_PATH（自定义输出目录） 环境变量和非公开环境变量 .travis.yml的env字段可以定义环境变量。 1234env: - DB=postgres - SH=bash - PACKAGE_VERSION=&quot;1.0.*&quot; 然后，脚本内部就使用这些变量了。 而有些环境变量（比如用户名和密码）不能公开，这时可以通过 Travis 网站，写在每个仓库的设置页里面，Travis 会自动把它们加入环境变量。这样一来，脚本内部依然可以使用这些环境变量，但是只有管理员才能看到变量的值。具体操作请看官方文档。","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"}]},{"title":"Java Logger","slug":"Java-Logger","date":"2021-10-20T09:15:14.000Z","updated":"2021-10-25T08:32:07.610Z","comments":true,"path":"2021/10/20/Java-Logger/","link":"","permalink":"https://nymrli.top/2021/10/20/Java-Logger/","excerpt":"","text":"Java Logger——Java的日志体系 在JDK 1.3及以前，Java打日志依赖System.out.println(), System.err.println()或者e.printStackTrace()，Debug日志被写到STDOUT流，错误日志被写到STDERR流。这样打日志有一个非常大的缺陷，即无法定制化，且日志粒度不够细。 于是， Gülcü 于2001年发布了Log4j，后来成为Apache 基金会的顶级项目。Log4j 在设计上非常优秀，对后续的 Java Log 框架有长久而深远的影响，它定义的Logger、Appender、Level等概念如今已经被广泛使用。Log4j 的短板在于性能，在Logback 和 Log4j2 出来之后，Log4j的使用也减少了。 整个分类和发展历程如下： ![Java Logging](./Java-Logger/Java Logging.png) 其中，目前比较主流的使用方法和性能较高的组合是，SLF4J + Logback SLF4J-Simple Logging Facade for Java 看英文全写可以知道，这个东东是Java中日志实现的一个简单接口，是对多种日志logging框架的一个抽象，如jul:java.util.logging、logback、log4j 大家在自己写项目的时候都会用到日志记录的功能，而通常下来，我们只记得想用的时候在类内协商var logger: Log = LogFactory.getLog(VerticalAlgorithm::class.java)--Koltinorprivate Log logger = LogFactory.getLog(VerticalAlgorithm.class)--Java，而等到自己写依赖的时候却不知道是咋回事，只知道Java的日志系统貌似挺复杂的。实际上，上面的代码是使用了SLF4J的规范，如果不正确引入依赖的话运行时会报如下的错误： SLF4J: No SLF4J providers were found 然而检查依赖时，会发现已经引入slf4j-api了，然而还是报错了，这是为什么呢？其原因是，SLF4J本身不是一个日志库，而是一个日志库的抽象层，它必须依赖底层的日志库。 详情见SLF4J官网提供的图： 两层: 抽象层+实现层 从图中可知，SLF4J必须和其他日志库配合才能正常运行。因此一般来说，需要将抽象层（例如slf4j-api-xx.jar）+中间层（例如slf4j-log4j12）+实现层（例如log4j）这三层都配置好才能保证SLF4J正常运行。 另外，有的日志库可以去掉中间层，例如slf4j-api和slf4j-simple就可以直接配合。 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.8.0-beta0&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.8.0-beta0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- --&gt;注两个版本是一致的&lt;!-- --&gt; 这种方式就是抽象层+实现层的组合。使用这种方式只需要两个jar包 三层： 抽象层+实现层 按照图片所展示的，也有抽象层+中间层+实现层三层的实现方式，如下所示： 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.8.0-beta0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.8.0-beta0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 然而，直接使用的话还是会出现一点问题：No appenders could be found for logger(log4j)? 这其实是要添加一个配置文件log4j.properties声明appenders，内容如下（内容可以自定义）： 123456789# Set root logger level to DEBUG and its only appender to A1.log4j.rootLogger=DEBUG, A1 # A1 is set to be a ConsoleAppender.log4j.appender.A1=org.apache.log4j.ConsoleAppender # A1 uses PatternLayout.log4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n 最佳实践 推荐使用 SLF4J + Logback。maven依赖如下，其中version字段用占位符代替，应该根据项目的实际情况选择合适的版本： 123456789101112131415161718&lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt; &lt;/dependency&gt;--&gt;&lt;!-- 该依赖包括了上面两个依赖，所以只要引入该依赖即可 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt;&lt;/dependency&gt; SLF4J适配 因为当时Java的日志组件比较混乱繁杂，Ceki Gülcü推出slf4j后，也相应为行业中各个主流日志组件推出了slf4j的适配。因此slf4j支持各种适配，无论你现在是用哪种日志组件，你都可以通过slf4j的适配器来使用上slf4j。只要你切换到了slf4j，那么再通过slf4j用上实现组件。给大家一个整体的依赖图（网上看到的） Logback 在代码中使用方式主要参考SLF4J API如何使用即可，Logback相关的主要是其配置文件logback.xml。 首先，如果依赖了logback，但在resources中没有创建logback.xml的配置文件，则默认输出到控制台且输出级别为trace以上。 12314:59:54,588 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback-test.xml]14:59:54,589 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback.groovy]14:59:54,589 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Found resource [logback.xml] at [file:/F:/JavaCode/plainJava/target/classes/logback.xml] 如果要自定义配置，则可以像如下定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration xmlns=\"http://ch.qos.logback/xml/ns/logback\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://ch.qos.logback/xml/ns/logback https://raw.githubusercontent.com/enricopulatzo/logback-XSD/master/src/main/xsd/logback.xsd\"&gt; &lt;property name=\"LOG_HOME\" value=\"tp/log\"/&gt; &lt;!-- 输出到控制台 --&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\" &gt; &lt;!-- 输出的格式 --&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;: %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.FileAppender\"&gt; &lt;file&gt;F:\\JavaCode\\plainJava\\src\\main\\resources\\\\test1.log&lt;/file&gt; &lt;encoder&gt; &lt;pattern&gt;%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"RollAppender\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 配置滚动的策略 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 日志名称的格式 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/logback.log.%d&#123;yyyy-MM-dd&#125;&lt;/fileNamePattern&gt; &lt;!-- 保存的最长时间：天数 --&gt; &lt;MaxHistory&gt;1&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;: %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 注意： level属性也可以直接写在logger上，如： &lt;logger name=\"ws.log.logback.LogbackTest\" additivity=\"false\" level=\"INFO\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/logger&gt; --&gt; &lt;logger name=\"ws.log.logback.LogbackTest\" additivity=\"false\"&gt; &lt;level value=\"INFO\" /&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/logger&gt; &lt;!-- 相当于logger元素，只是name值已经确定为root了 --&gt; &lt;root level=\"warn\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 讲解下RollingFileAppender， 这个是我们在日常日志系统里经常能看到的模式。由于日志数量会越来越多，所以如果都放在一个文件内的话，会导致文件大小变得很大，因此通过时间间隔分割将能更好地分割日志文件，也有助于之后日常地查询。关于RollingFileAppender其中File属性的设定如下： 设置File属性 系统会将日志内容全部写入log/check.log中。 在2019-06-05凌晨，check.log会被重命名为log/check.2019-06-04.log。 然后再生成新的check.log文件，按照上面的步骤生成log/check.2019-06-05.log、log/check.2019-06-06.log等日志。 忽略File属性 系统会将日志内容直接写入log/check.2019-06-04.log中。 在2019-06-05凌晨，系统会将日志内容直接写入log/check.2019-06-04.log。 即以2019-06-04为例，如果你设置了File属性，当天你只能看到check.log日志文件，2019-06-05才会看到check.201-06-04.log文件。但是如果你忽略了，你当天就能看到check.2019-06-04.log文件，但你始终看不到check.log文件。 12345678910111213141516&lt;appender name=\"emergencyLog\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 写入日志内容的文件名称（目录） --&gt; &lt;File&gt;log/check.log&lt;/File&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 活动文件的名字会根据fileNamePattern的值，每隔一段时间改变一次 --&gt; &lt;fileNamePattern&gt;log/check.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 每产生一个日志文件，该日志文件的保存期限为30天 --&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;!-- pattern节点，用来设置日志的输入格式 --&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5level %logger [%msg]%n&lt;/pattern&gt; &lt;!-- 记录日志的编码:此处设置字符集 - --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt;&lt;/appender&gt; 以上述配置执行的话，会在工程根目录即src、.idea那层生成log文件夹，其中包含日志log。即相对路径是以根目录为起点的 附录 (J)CL使用方式 123456import org.apache.commons.logging.Logimport org.apache.commons.logging.object VerticalAlgorithm : RemappingAlgorithm &#123; var logger: Log = LogFactory.getLog(VerticalAlgorithm::class.java)&#125; slf4j使用方式 12345678910import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class LogTest &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(LogTest.class); logger.info(\"ues\"); &#125;&#125;// 或者使用lombok的@Slf4j标注类上功能时一样的 再提几点最佳实践指导原则： 总是使用 Log Facade，而不是具体的 Log Implementation 只添加一个 Log Implementation 依赖 具体的日志依赖应该设置为 optional，并使用 runtime scope ​ 设为optional，依赖不会传递，这样如果你是个lib项目，然后别的项目使用了你这个lib，不会被引入不想要的Log Implementation 依赖； Scope设置为runtime，是为了防止开发人员在项目中直接使用Log Implementation中的类，而不使用Log Facade中的类。 如果有必要, 排除依赖的第三方库中的Log Impementation依赖 ​ 这是很常见的一个问题，第三方库的开发者未必会把具体的日志实现或者桥接器的依赖设置为optional，然后你的项目继承了这些依赖——具体的日志实现未必是你想使用的，比如他依赖了Log4j，你想使用Logback，这时就很尴尬。另外，如果不同的第三方依赖使用了不同的桥接器和Log实现，也极容易形成环。 这种情况下，推荐的处理方法，是使用exclude来排除所有的这些Log实现和桥接器的依赖，只保留第三方库里面对Log Facade的依赖。 阿里日志规范 阿里对此的代码规范： 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。import org.slf4j.Logger; import org.slf4j.LoggerFactory; private static final Logger logger = LoggerFactory.getLogger(Abc.class); 让Spring统一输出 这就是为了对slf4j的适配做一个例子说明。Spring是用JCL作为日志门面的，那我们的应用是slf4j + logback，怎么让Spring也用到logback作为日志输出呢？这样的好处就是我们可以统一项目内的其他模块、框架的日志输出（日志格式，日志文件，存放路径等，以及其他slf4j支持的功能） 很简单，就是加入jcl-over-slf4j.jar就好了。 日志配置启动过程 12345678910111213141516171819202122232414:59:54,588 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback-test.xml]14:59:54,589 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback.groovy]★14:59:54,589 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Found resource [logback.xml] at [file:/F:/JavaCode/plainJava/target/classes/logback.xml]14:59:54,835 |-INFO in ch.qos.logback.core.joran.action.ImplicitModelAction - Assuming default class name [ch.qos.logback.classic.encoder.PatternLayoutEncoder] for tag [encoder]14:59:54,836 |-INFO in ch.qos.logback.core.joran.action.ImplicitModelAction - Assuming default class name [ch.qos.logback.classic.encoder.PatternLayoutEncoder] for tag [encoder]14:59:54,952 |-INFO in ch.qos.logback.core.model.processor.AppenderModelHandler - Processing appender named [STDOUT]14:59:54,952 |-INFO in ch.qos.logback.core.model.processor.AppenderModelHandler - About to instantiate appender of type [ch.qos.logback.core.ConsoleAppender]★★14:59:55,111 |-ERROR in ch.qos.logback.core.pattern.parser.Compiler@737996a0 - There is no conversion class registered for conversion word [thead]★★14:59:55,111 |-ERROR in ch.qos.logback.core.pattern.parser.Compiler@737996a0 - [thead] is not a valid conversion word14:59:55,220 |-INFO in ch.qos.logback.core.model.processor.AppenderModelHandler - Processing appender named [FILE]14:59:55,220 |-INFO in ch.qos.logback.core.model.processor.AppenderModelHandler - About to instantiate appender of type [ch.qos.logback.core.FileAppender]★★14:59:55,224 |-ERROR in ch.qos.logback.core.pattern.parser.Compiler@61dc03ce - There is no conversion class registered for conversion word [thead]★★14:59:55,224 |-ERROR in ch.qos.logback.core.pattern.parser.Compiler@61dc03ce - [thead] is not a valid conversion word14:59:55,224 |-INFO in ch.qos.logback.core.FileAppender[FILE] - File property is set to [./test.log]★14:59:55,226 |-INFO in ch.qos.logback.classic.model.processor.RootLoggerModelHandler - Setting level of ROOT logger to WARN★14:59:55,228 |-INFO in ch.qos.logback.core.model.processor.AppenderRefModelHandler - Attaching appender named [STDOUT] to Logger[ROOT]★14:59:55,228 |-INFO in ch.qos.logback.core.model.processor.AppenderRefModelHandler - Attaching appender named [FILE] to Logger[ROOT] []","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"}]},{"title":"javadoc——让大家更好写java项目","slug":"javadoc——让大家更好写java项目","date":"2021-10-17T13:57:14.000Z","updated":"2022-03-09T02:08:02.048Z","comments":true,"path":"2021/10/17/javadoc——让大家更好写java项目/","link":"","permalink":"https://nymrli.top/2021/10/17/javadoc——让大家更好写java项目/","excerpt":"","text":"近期在Github上看到一个有趣的项目，是各个技能树的挑战，并且起了个冒险岛的故事——字节传说:勇士将无惧挑战。其中除了提交Pr的教程（挑战）外，还有个比较有意思的是Javadoc，想想之前没专门写过，于是本勇士本次就毅然接收了Javadoc的挑战。 Javadoc 很多程序对Javadoc都不重视，认识不到Javadoc的作用，很多人都是这样认为的：“我只要写好功能就够了，写Javadoc太浪费时间，也没啥作用，还不如用写Javadoc的时间再多些个功能呢！”，我们知道注释是为了解释代码的作用的，是为了将来给自己或者别人快速了解代码的，在方法内一般用行注释//的比较多，是针对一小块代码做出解释的，而Javadoc的作用是针对整个方法或者整个类做一个简要的概述的，使得别人不通过看具体方法代码就能知道某个方法或者某个类的作用和功能。写了Javadoc的在别人使用到类时，将鼠标悬停到类上或者方法上，javadoc会以提示信息显示出来，这样开发者在跳进源代码中就能知道类或者方法的作用，使得可以编在码时看文档，效果最明显的就是Spingboot的Javadoc能在不知道一个接口的作用、参数时，直接看到说明。 1234567/** * &lt;概要描述&gt; * * &lt;详细描述&gt; * * &lt;Javadoc文档标记 标记说明&gt; * / 注意点：①Javadoc以/**开头，*/收尾；②文档标记后不能跟冒号:，如@param filePath中间用空格分开即可，不能加: 第一段：概要描述，通常用一句或者一段话简要描述该类或者方法的作用 第二段：详细描述，通常用一段或者多段话来详细描述该类或者方法的作用 第三段：文档标注，用于标注作者、创建时间、参阅类、参数等信息 常见Javadoc文档标记 JDK预定义好的文档标记有，@author、@version、@since、@see、@link、@code、@param、@return、@exception、@throws等。 @link： {@link 包名.类名#方法名(参数类型)}用于快速链接到相关代码 @link的使用语法{@link 包名.类名#方法名(参数类型)}，其中当包名在当前类中已经导入了包名可以省略，可以只是一个类名，也可以是仅仅是一个方法名，也可以是类名.方法名，使用此文档标记的类或者方法，可用通过 按住Ctrl键+单击 可以快速跳到相应的类或者方法上，解析成html其实就是使用&lt; code&gt; 包名.类名#方法名(参数类型)&lt; /code&gt; 1234567891011// 完全限定的类名&#123;@link java.lang.Character&#125;// 省略包名&#123;@link String&#125;// 省略类名，表示指向当前的某个方法&#123;@link #length()&#125;// 包名.类名.方法名(参数类型)&#123;@link java.lang.String#charAt(int)&#125; @code： {@code text} 将文本标记为code {@code text} 会被解析成&lt;code&gt; text &lt;/code&gt;。将文本标记为代码样式的文本，在code内部可以使用 &lt; 、&gt; 等不会被解释成html标签, code标签有自己的样式，一般在Javadoc中只要涉及到类名或者方法名，都需要使用@code进行标记。 @see 另请参阅，一般用于标记该类相关联的类（方法）、相似的类（方法） @see即可以用在类上，也可以用在方法上。 1234567/** * @see IntStream * @see LongStream * @see DoubleStream * @see &lt;a href=\"package-summary.html\"&gt;java.util.stream&lt;/a&gt; * /public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;&#125; @throws 后面跟 异常类型 异常描述 , 用于描述方法内部可能抛出(产生)的异常 1234/*** @param str the &#123;@code CharSequence&#125; to check (may be &#123;@code null&#125;)*/public static boolean containsWhitespace(@Nullable CharSequence str) &#123;&#125; @exception 用于描述方法签名明确会throws的异常 1234/*** @exception IllegalArgumentException if &lt;code&gt;key&lt;/code&gt; is null.*/public static Object get(String key) throws IllegalArgumentException &#123;&#125; @value 用于标注在常量上，{@value} 用于表示常量的值 12/** 默认数量 &#123;@value&#125; */private static final Integer QUANTITY = 1; @inheritDoc @inheritDoc用于注解在重写方法或者子类上，用于继承父类中的Javadoc 基类的文档注释被继承到了子类 子类可以再加入自己的注释（特殊化扩展） @return @param @throws 也会被继承 @version @version 用于标记当前版本，默认为1.0 12345package com.sun.org.apache.xml.internal.resolver; /** * @version 1.0 */public class Resolver extends Catalog &#123;&#125; @since @since 一般用于标记文件创建时项目当时对应的版本，一般后面跟版本号，也可以跟是一个时间，表示文件当前创建的时间 @return 返回值的描述 @param 后面跟参数名，再跟参数描述 完整示例 spring-core中的StringUtils 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243package org.springframework.util;/** * Miscellaneous &#123;@link String&#125; utility methods. * * &lt;p&gt;Mainly for internal use within the framework; consider * &lt;a href=\"http://commons.apache.org/proper/commons-lang/\"&gt;Apache's Commons Lang&lt;/a&gt; * for a more comprehensive suite of &#123;@code String&#125; utilities. * * &lt;p&gt;This class delivers some simple functionality that should really be * provided by the core Java &#123;@link String&#125; and &#123;@link StringBuilder&#125; * classes. It also provides easy-to-use methods to convert between * delimited strings, such as CSV strings, and collections and arrays. * * @author Rod Johnson * @author Juergen Hoeller * @author Keith Donald * @author Rob Harrop * @author Rick Evans * @author Arjen Poutsma * @author Sam Brannen * @author Brian Clozel * @since 16 April 2001 */public abstract class StringUtils &#123; /** * Decode the given encoded URI component value. Based on the following rules: * &lt;ul&gt; * &lt;li&gt;Alphanumeric characters &#123;@code \"a\"&#125; through &#123;@code \"z\"&#125;, &#123;@code \"A\"&#125; through &#123;@code \"Z\"&#125;, * and &#123;@code \"0\"&#125; through &#123;@code \"9\"&#125; stay the same.&lt;/li&gt; * &lt;li&gt;Special characters &#123;@code \"-\"&#125;, &#123;@code \"_\"&#125;, &#123;@code \".\"&#125;, and &#123;@code \"*\"&#125; stay the same.&lt;/li&gt; * &lt;li&gt;A sequence \"&#123;@code %&lt;i&gt;xy&lt;/i&gt;&#125;\" is interpreted as a hexadecimal representation of the character.&lt;/li&gt; * &lt;/ul&gt; * * @param source the encoded String * @param charset the character set * @return the decoded value * @throws IllegalArgumentException when the given source contains invalid encoded sequences * @since 5.0 * @see java.net.URLDecoder#decode(String, String) */ public static String uriDecode(String source, Charset charset) &#123;&#125; 导出JavaDoc 命令行导出 javadoc.exe -private -splitindex -author -charset UTF-8 -encoding UTF-8 -windowtitle 柳州交通仿真Doc -d F:\\TODO\\sucsoft\\code\\lzjt-simulation\\javadoc @G:\\os_tmp\\javadoc_args -windowtitle : 页面的header-title -d: 输出目录 -charset、-encoding：中文乱码解决方法 -overview &lt;文件&gt; 读取 HTML 文件的概述文档 -public 仅显示公共类和成员 -protected 显示受保护/公共类和成员（默认） -package 显示软件包/受保护/公共类和成员 -private 显示所有类和成员 -help 显示命令行选项并退出 -doclet &lt;类&gt; 通过替代 doclet 生成输出 -docletpath &lt;路径&gt; 指定查找 doclet 类文件的位置 -sourcepath &lt;路径列表&gt; 指定查找源文件的位置 -classpath &lt;路径列表&gt; 指定查找用户类文件的位置 -exclude &lt;软件包列表&gt; 指定要排除的软件包的列表 -subpackages &lt;子软件包列表&gt; 指定要递归装入的子软件包 -breakiterator 使用 BreakIterator 计算第 1 句 -bootclasspath &lt;路径列表&gt; 覆盖引导类加载器所装入的类文件的位置 -source &lt;版本&gt; 提供与指定版本的源兼容性 -extdirs &lt;目录列表&gt; 覆盖安装的扩展目录的位置 -verbose 输出有关 Javadoc 正在执行的操作的消息 -locale &lt;名称&gt; 要使用的语言环境，例如 en_US 或 en_US_WIN、ZN_CN -encoding &lt;名称&gt; 源文件编码名称 -quiet 不显示状态消息 -J&lt;标志&gt; 直接将 &lt;标志&gt; 传递给运行时系统 -X 输出非标准选项的提要 标准doclet选项 说明 -d &lt;directory&gt;输出文件的目标目录 -use创建类和程序包用法页面 -version包含 @version 段 -author包含 @author 段 -docfilessubdirs 递归复制文档文件子目录 -splitindex将索引分为每个字母对应一个文件 -windowtitle &lt;text&gt;文档的浏览器窗口标题 -doctitle &lt;html-code&gt;包含概览页面的标题 -header &lt;html-code&gt;包含每个页面的页眉文本 -footer &lt;html-code&gt;包含每个页面的页脚文本 -top &lt;html-code&gt;包含每个页面的顶部文本 -bottom &lt;html-code&gt;包含每个页面的底部文本 -link 创建指向位于&lt;url&gt;的 javadoc 输出的链接 from:java基础(4)–javadoc文档与命令 IDEA导出 附录： 使用HTML标签写详细文档： 第二段：详细描述 详细描述一般用一段或者几个锻炼来详细描述类的作用，详细描述中可以使用html标签，如&lt;p&gt;、&lt;pre&gt;、&lt;a&gt;、&lt;ul&gt;、&lt;i&gt;等标签， 通常详细描述都以段落p标签开始。 详细描述和概要描述中间通常有一个空行来分割 12345678910111213141516package org.springframework.util;/** * Miscellaneous &#123;@link String&#125; utility methods. * * &lt;p&gt;Mainly for internal use within the framework; consider * &lt;a href=\"http://commons.apache.org/proper/commons-lang/\"&gt;Apache's Commons Lang&lt;/a&gt; * for a more comprehensive suite of &#123;@code String&#125; utilities. * * &lt;p&gt;This class delivers some simple functionality that should really be * provided by the core Java &#123;@link String&#125; and &#123;@link StringBuilder&#125; * classes. It also provides easy-to-use methods to convert between * delimited strings, such as CSV strings, and collections and arrays. * */public abstract class StringUtils &#123; 一般段落都用p标签来标记，凡涉及到类名和方法名都用@code标记，凡涉及到组织的，一般用a标签提供出来链接地址。 package-info.java 包级注释 123// package-info.java@Deprecated // 加上了后，该包下的所有方法都会提供 过期package top.nymrli.test;","categories":[],"tags":[{"name":"技能糖","slug":"技能糖","permalink":"https://nymrli.top/tags/技能糖/"}]},{"title":"ZJU开学摸底考试——计算机网络复习","slug":"ZJU开学摸底考试——计算机网络复习","date":"2021-10-15T12:06:53.000Z","updated":"2021-10-25T08:52:57.113Z","comments":true,"path":"2021/10/15/ZJU开学摸底考试——计算机网络复习/","link":"","permalink":"https://nymrli.top/2021/10/15/ZJU开学摸底考试——计算机网络复习/","excerpt":"","text":"计算机网络核心： 主机 通信链路 交换网络 协议 多路复用 频分多路复用 时分多路复用 码分多路复用 波分多路复用 数据交换 电路交换（FDM,WDM,TDM,CDM） 报文交换（被废弃了） 分组交换（统计多路复用） 分组：报文分拆出来的一系列相对较小的数据包 分组交换需要报文的拆分与重组 统计多路复用 工作方式：存储与转发： 报文交换与分组交换均采用存储-转发交换方式 区别： 报文交换以完整报文进行“存储-转发” 分组交换以较小的分组进行“存储-转发” 报文：M bts 链路带宽（数据传输 速率）：R bps 分组长度（大小）：Lbits 跳步数：h 路由器数：n 分组交换允许更多用户同时使用网络！——网络资源充分共享 网络性能： 速率即数据率（ data rate）或称数据传输速率或比特率（ bit rate） 单位时间（秒）传输信息（比特）量 计算机网络中最重要的一个性能指标 单位：b/s（或bps）、kb/s、Mb/s、Gb/s k=103、M=106、G=109 带宽”（ bandwidth）原本指信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz） 网络的“带宽”通常是数字信道所能传送的“最高数据率”，单位：b/s（bps） 常用的带宽单位 kb/s （103 b/s） Mb/s （106 b/s） Gb/s （109 b/s） Tb/s（1012b/s） Q：分组交换为什么会发生丢包和时延？ A：分组在路由器缓存中排队 令分组到达速率超出输出链路容量时 四种分组延迟 结点处理延迟 排队延迟 传输延迟 传播延迟（光纤影响的是这个时间） 车队例子：https://www.icourse163.org/learn/HIT-154005?tid=1463162470#/learn/content?type=detail&amp;id=1240421270&amp;cid=1261896474 时延带宽积：传播时延×带宽，链路的时延带宽积又称为以比特为单位的链路长度 分组丢包： 队列缓存容量有限 分组到达已满队列将被丢弃（即丢包） 丢弃分组可能由前序结点或源重发（也可能不重发） 吞吐量表示在发送端与接收端之间传送数据速率（b/s） 即时吞吐量：给定时刻的速率 平均吞吐量。一段时间的平均速率 计算机网络是一个非常复杂的系统，涉及许多组成部分 主机（ hosts） 路由器（ routers） 各种链路（inks） 应用（ applications） 协议（ protocols） 硬件、软件 计算机网络结构 Q:是否存在一种系统结构有效描述网络？ Q:利用什么样的结构？ Q:至少用于讨论网络？ A：分层结构， 每次每层完成一种（类）特定服务/功能：每层依赖底层提供的服务，通过层内动作完成相应功能 网络体系结构是从功能上描述计算机网络结构 计算机网络体系结构简称网络体系结构（ network architecture）是分层结构 每层遵循某个/些网络协议完成本层功能 计算机网络体系结构是计算机网络的各层及其协议的集合 体系结构是一个计算机网络的功能层次及其关系的定义 体系结构是抽象的 Q:为什么采用分层结构 结构清晰，有利于识别复杂系统的部件及其关系 模块化的分层易于系统更新、维护 任何一层服务实现的改变对于系统其它层都是透明的。例如，登机过程的改变并不影响航空系统的其它部分（层） 有利于标准化 基本概念： 物理层： 比特编码 数据率 比特同步：时钟同步 传输模式 数据链路层功能 流量控制（ Flow control） 避免淹没接收端 差错控制（ Error control） 检测并重传损坏或丢失帧，并避免重复帧 访问（接入）控制（ Access control 网络层： 负责源主机到目的主机数据分组（ packet）交付 可能穿越多个网络 逻辑寻址（ Logical addressing） 全局唯一逻辑地址，确保数据分组被送达目的主机，如 P地址 路由（ Routing） 路由器（或网关）互连网络，并路由分组至最终目的主机 路径选择 分组转发 传输层功能 分段与重组 SAP寻址 连接控制 流量控制 差错控制 会话层功能 对话控制 同步（ synchronization） 表示层 数据表示转化 加密/解密 压缩解压缩 附录 采用分组转发的优缺点： 加速了数据在网络中的传输。因为分组是逐个传输，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式传输方式减少了报文的传输时间。此外，传输一个分组所需的缓冲区比传输一份报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的机率及等待的时间也必然少得多。 简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。 减少了出错机率和重发数据量。因为分组较短，其出错机率必然减少，每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。 由于分组短小，更适用于采用优先级策略，便于及时传送一些紧急数据，因此对于计算机之间的突发式的数据通信，分组交换显然更为合适些。 缺点： 尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。 分组交换与报文交换一样，每个分组都要加上源、目的地址和分组编号等信息，使传送的信息量大约增大5%～10%，一定程度上降低了通信效率，增加了处理的时间，使控制复杂，时延增加。 当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。 Q:SMTP 是一种TCP协议支持的提供可靠且有效 电子邮件 传输的 应用层 协议。 Q:计算机网络拓扑结构取决通信子网。 Q：关于Ip首部最大长度（60）和最小长度（20）","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"ZJU开学摸底考试——数据库概论复习","slug":"ZJU开学摸底考试——数据库概论复习","date":"2021-10-12T08:16:24.000Z","updated":"2022-03-19T11:10:08.489Z","comments":true,"path":"2021/10/12/ZJU开学摸底考试——数据库概论复习/","link":"","permalink":"https://nymrli.top/2021/10/12/ZJU开学摸底考试——数据库概论复习/","excerpt":"","text":"数据库概论 数据库的4个基本概念 数据（Data） 定义：描述事物的符号记录。 数据的含义称为数据的语义，数据的语义是指对具体数值进行的解释说明。数据与其语义是不可分的。 数据是数据库中存储的基本对象。 数据库（Database，DB） 定义：数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。 数据厍的基本特征 数据按一定的数据模型组织、描述和储存 可为各种用户共享、冗余度较小、易扩展 数据独立性较高 数据库管理系统（DataBase Management System，DBMS) 位于用户应用与操作系统之间的一层数据管理软件； 跟操作系统一样是计算机的基础软件，是一个大型复杂的软件系统。 主要功能： 数据定义功能：提供数据定义语言（DDL）；定义数据库中的数据对象； 数据组织、存储和管理：分类组织、存储和管理各种数据；确定数据在存储级别上的结构和存储方式；实现数据之间的练习；提供多种存取方法提高存取效率； 数据操纵功能：提供数据操纵语言（DML）；实现对数据库的基本操作（查询、插入、删除和修改）； 数据库的事务管理和运行管理：数据的安全性、完整性、多种对用户数据的并发使用；发生故障后的系统恢复数据库； 数据库的建立和维护功能：提供实用程序工具，完成数据库数据批量装载，数据库转储，介质故障恢复，数据库的重组织和性能监视等。 数据库系统（DataBase System，DBS） 是由数据库、数据库管理系统（及其应用开发工具）、应用程序和**数据库管理员（DBA）**组成的存储、管理、处理和维护数据的系统。 Q: 什么是数据库系统？ 是指在计算机系统中引入数据库后的系统构成； 在不引起混淆的情况下常常把数据库系统简称为数据库。 数据库系统的特点？ 数据结构化； 数据的共享性高，冗余度小且易扩充； 数据独立性高； 数据由数据库管理系统统一管理和控制； 数据库的发展阶段 人工管理阶段：数据不保存、不共享，不具有独立性。 文件系统阶段：可保存，但共享性差，冗余度大，独立性差 数据库管理系统：数据库系统的出现使信息系统从以 加工数据的程序 为中心转向围绕 共享的数据库 为中心的新阶段 数据的共享性高、冗余度低且易扩充：数据共享可以大大减少数据冗余，节约存储空间数据独立性高 物理独立性：是指用户的应用程序与数据库中数据的物理存储是相互独立的。 逻辑独立性：是指用户的应用程序与数据库的逻辑结构是相互独立的。 数据模型 数据模型是对现实世界数据特征的抽象。 数据模型分为两类（两个不同的层次） 概念模型，也称信息模型； 它是按用户的观点来对数据和信息建模，用于数据库设计 实体Entity：客观存在并相互区别的事物称为实体。 属性：实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。 码：唯一标识实体的属性集称为码。 实体型：用实体名及其属性名集合来抽象和刻画同类实体称为实体型。 实体集：同一类型实体的集合称为实体集 联系Relation：现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系； 实体内部的联系：是指组成实体的各属性之间的联系； 实体之间的联系：通常是指不同实体集之间的联系；实体之间的联系有一对一（1：1），一对多（1：n），多对多（m：n）。 逻辑模型和物理模型。 逻辑模型∶它是按计算机系統的观点对数据建模，主要用于数据库管理系统的实现。主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等 按计算机系统的观点对数据建模，用于DBMS实现。 物理模型：是对数据最底层的抽象，它描述数据在系统內部的表示方法和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。 数据模型由三部分组成: 数据结构–描述系统的静态特征； 数据操作–描述系统的动态特征； 完整性约束。 完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则。 层次模型，网状模型 常用的数据模型： 格式化模型：层次模型，网状模型。 关系模型：最常用的模型。 对象模型：面向对象数据模型，对象关系数据模型。 层次模型 用树形结构来表示各类实体以及实体间的联系。 表示方式： 实体型：用记录类型描述每个结点表示一个记录类型（实体）； 属性：用字段描述每个记录类型可包含若干个字段； 联系：用结点之间的连线表示记录类型之间的一对多的父子联系 层次模型的优缺点 1）优点 层次模型的数据结构比较简单清晰； 查询效率高，性能优于关系模型，不低于网状模型； 层次数据模型提供了良好的完整性支持； 2）缺点 结点之间的多对多联系表示不自然； 对插入和删除操作的限制多，应用程序的编写比较复杂； 查询子女结点必须通过双亲结点； 层次数据库的命令趋于程序化。 关系模型 在用户的观点下，关系模型中数据的逻辑结构是一张二维表。 关系必须是规范化的，满足一定的规范条件。 最基本的规范条件是关系的每一个分量必须是一个不可再分的数据项，不允许表中还有表。 注：关系数据模型是目前最重要的一种数据模型，它的三个要素分别是数据结构、关系操作、完整性约束 数据结构 关系：一个关系对应通常说的一张表。 元组：表中的一行。 属性：表中的一列。 码：也称码键，表中的某个属性组 域：是一组具有相同数据类型的值的集合：学生年龄属性的域（15-45岁）、性别的域（男、女） 分量：元组中的一个属性。 关系模式：对关系的描述 注：**关系数据模型的基本数据结构是？**A:关系 关系必须是规范化的，满足一定的规范条件。最基本的规范条件：关系的每一个 分量必须是一个不可分的数据项，不允许表中还有表。 关系模型的操纵与完整性约束 （1）数据结构是集合操作集合操作，操作对象和操作结果都是关系。 （2）提高了数据的独立性，提高了用户生产率。 （3）关系的完整性约束条件？ 实体完整性，参照完整性；（前两者为关系的两个不变性）用户定义的完整性。 关系模型的优缺点 （1）优点 建立在严格的数学概念的基础上； 概念单一； 实体和各类联系都用关系来表示 对数据的检索结果也是关系 关系模型的存取路径对用户透明； 具有更高的数据独立性，更好的安全保密性 简化了程序员的工作和数据库开发建立的工作 （2）缺点 存取路径对用户透明，查询效率往往不如格式化数据模型； 为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的复杂性。 数据库系统的结构 从数据库应用开发人员角度看：数据库系统采用三级模式结构，是数据库系统内部的系统结构 从数据库最终用户角度看：数据库系统的结构有： 单用户结构 主从式结构 分布式结构 客户-服务器 浏览器-应用服务器/数据服务器 三级模式-二级映像 模式(Schema): 是对数据库逻辑结构和特征的描述 是型的描述，不涉及具体值 模式是相对稳定的 实例（Instance） 数据库某一时刻的状态——模式的一个具体值 同一个模式可以有很多实例 实例随数据库中的数据的更新而变动 三级模式： 外模式（子模式or用户模式） 数据库用户使用的局部数据的逻辑结构和特征的描述 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 模式（逻辑模式） 数据库中全体数据的逻辑结构和特征的描述 所有用户的公共数据视图 内模式（存储模式） 是数据物理结构和存储方式的描述 是数据在数据库内部的表示方式 二级映射 外模式/模式 映射：保证数据的逻辑独立性 当模式改变时，数据库管理员对外模式/模式映像作相应改变，使外模式保持不变 应用程序是依据数据的外模式编写的，应用程序不必修，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性 模式/内模式 映射：保证数据的物理独立性 定义了数据全局逻辑结构与存储结构之间的对应关系。 如，说明某个逻辑记录对应何种存储结构。 数据库中模式/内模式映象是唯一的。 保证数据的物理独立性 当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式/内模式映象，使模式保持不变。 模式不变，则应用程序不变。保证了数据与程序的物理独立性，简称数据的物理独立性。 码 候选码（超级码）就就是可以区别一个元组（即表中的一行数据）的属性或属性的集合。候选码是最小的超码 如何选出候选码？ 只出现在左边的一定是候选码 只出现在右边的一定不是候选码 左右都出现的不一定 左右都不出现的一定是候选码 再求确定的候选码的闭包，如果可以推出全部，那么当前确定的就是候逐码，否则你要吧每一个可能的值放进当前确定的候选码里面进行求闭包 主码：从候选码里面任意跳出一个作为主码 主属性：包含在所有候选码的属性比如 ABCDE 非主属性：不包含在候选码中的属性，上题为G 全码：所有的属性都是主码 范式 Q:为什么要引入范式？ 1数据冗余 2更新异常 3插入异常 4删除异常 A: 设计关系数据库时，遵从不同的规范要求，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，又称完美范式）。 一般来说，数据库只需满足第三范式（3NF）就行了。 1NF:所有字段值都是不可分解的原子值 2NF:不包含非主属性对码的部分函数依赖：一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中 3NF:不包含非主属性对码的传递函数依赖确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 BCNF:消除每一属性对候选键的传递依赖，BCNF是修正的第三范式 函数依赖简单点说就是：某个属性集决定另一个属性集时，称另一属性集依赖于该属性集。 公理系统 Armstrong公理系统（ Armstrongs axiom）设U为属性集总体，F是U上的一组函数依赖，于是有关系模式R(U,F)，对R&lt;U,F&gt;来说有以下的推理规则 A1自反律（ reflexivity rule）：若 Y∈X∈U，则X→Y为F所蕴涵。 A2增广律（ augmentation rule）：若X→y为F所蕴涵，且Z∈U，则XZ→Yz为F所蕴涵。 A3传递律（ transitivity rule）：若X→Y及P→z为F所蕴涵，则X→Z为F所蕴涵 根据A1、A2、A3这三条推理规则可以得到下面三条很有用的推理规则。 合并规则（ union rule）：由X→Y,X→Z，有X→YZ 伪传递规则（ pseudo transitivity rule）：由X→Y,WY→Z，有X→乙 分解规则（ decomposition rule）：由X→Y及Z∈Y，有X→Z。 依赖 Q：什么是依赖？ A：依赖是指关系中一个或一组属性的值可以决定其它属性的值比如A→&gt;B这就是一个依赖 Q: 如何求最小依赖集？ 1）拆右边为多个元素的比如A-&gt;BCH拆为A&gt;B和A-&gt;C 2）出去当前元素，求它的闭包，把集合里面所有元素都弄完 3）左边最小化（通过遮住元素来看能不能退岀其他元素）比如BCD，遮住B看能退出CD吗，遮住C能退出BD吗遮住D看能退出BC吗 关系型数据库 关系模型 关系数据结构 关系模式（ Relation Schema）是型；关系是值 关系模式是对关系的描述 元组集合的结构 ●属性构成 ●属性来自的域 ●属性与域之间的映象关系 完整性约束条件 关系模式可以形式化地表示为：R（U, D, DOM, F） R 关系名 U 组成该关系的属性名集合 D U中属性所来自的域 DOM 属性向域的映象集合 F 属性间数据的依赖关系的集合 关系模式 ■对关系的描述 ■静态的、稳定的 关系 ■关系模式在某一时刻的状态或内容 ■动态的、随时间不断变化的 关系完整性约束 实体完整性和参照完整性 关系模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持 实体完整性（ Entity Integrity） 关系的主属性不能取空值 参照完整性： 若属性（或属性组）F是基本关系R的外码，他与基本关系S的主码K相对应（基本关系R和S也可以是同一个关系），则对于R中每个元组在F上的取值必须为：或取空值（F的每个属性值均为空值）；或者等于S中某个元组的主码值。 案例 1:学生(学号，姓名，性别，年龄，系号) 2:系(系号，系名，系主任) 学生关系的属性“系号”与系关系的主码“系号”相对应，因此，“系号”属性是学生 关系的外码。这里系关系是被参照关系，学生关系为参照关系；学生关系中的每个元组的“系号”属性只能取下面两类值：空值或系关系中“系号”已经存在的值。 1.学生(学号，姓名，性别，年龄，系号，班长学号) 学生关系的“班长学号”与其主码“学号”形成参照和被参照的自身参照关系，即“班 长学号”为学生关系的外码。学生关系中的每个组的“班长学号”属性只能取下面两类值： 空值或学生关系中“学号”已经存在的值。 用户定义的完整性 应用领域需要遵循的约束条件，体现了具体领域中的语义约束 用户对数据自定义的域约束值，如“学分”属性只能取值{1,2,3,4} 域–&gt;笛卡尔积 所有域的所有取值的任意组合 笛卡尔积可以看着是关系的“域”。 笛卡尔积的表示方法 笛卡尔积可表示为一张二维表 表中的每行对应一个元组，表中的每列对应一个域 关系代数 关系代数语言:用对关系的运算来表达查询要求 关系演算语言：用谓词来表达查询要求 元组关系演算语言 ●谓词变元的基本对象是元组变量 ●代表：APLHA,QUEL 域关系演算语言 ●谓词变元的基本对象是域变量 ●代表：QBE 具有关系代数和关系演算双重特点的语言 ■代表：SQL（ Structured Query Language） 关系代数是一种抽象的查询语言，它用对关系的运算来表达查询 运算对象是关系 运算结果亦为关系 关系代数的运算符有两类：集合运算符和专门的关系 运算符 关系操作(关系代数运算) 插入、查询、删除、修改 其中查询操作分为：选择、投影、连接、除法、并、差、交、笛卡尔积 五种基本关系代数运算：选择、投影、并、差、笛卡尔积 ∪ ∩ 以上三个都需要具有相同的属性（相同目），结果的属性也是一样的 笛卡尔积 两个分别为n目和m目的关系R和S的笛卡尔积是一个（n + m）列的元组的集合。若R有k1个元组，S有k2个元组，则R和S的笛卡尔积有k1 * k2个元组。 选择和投影的区别 选择的是一行记录，投影是你所需的某个字段，两者相结合为最终结果. 选择是从行的角度进行的运算；投影操作是从列的角度进行的运算。选择是在关系R中选择满足给定条件的诸元组，投影是从R中选择出若干属性列组成新的关系。 连接： 自然连接：把共同的属性进行等值连接。 ★先把所有属性去重列出来，将等值的共同属性填入后，补充其他属性值 悬浮元组（ Dangling tuple）：两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组。 外连接（ Outer Join）：如果把悬浮元组也保存在结果关系中，而在其他属性上填空值（Nu1U），就叫做外连接 左外连接（ LEFT OUTER J0IN或 LEFT J0IN）：只保留左边关系R中的悬浮元组 右外连接（ RIGHT0 DUTER J0IN或 RIGHT J0IN）：只保留右边关系S中的悬浮元组 除 保留R中满足S的，而且R中列要去掉S的列 注： 关系中，属性个数称为「度」或「目」，3度表示这个表有3列。 关系中元组的个数称为「基数」。 关系完整性 实体完整性：主码唯一且非空 参照完整性：外码要么为空，要么对应另一表的主码 用户定义完整性：你自己写的要完整比如学号多少姓名班级专业之类 关系代数 是一种抽象的查询语言，它用对关系的运算来表达查询。 三大要素：运算对象（关系）、运算符（集合运算符和专门的关系运算符）和运算结果（关系） SQL语言 Structure Query Language，结构化查询语言， 数据定义语言DDL（ Data Ddefinition Language）sQL数据定义语言主要用来定义逻辑结构，包括定义基表，视图和索引。 删除表、定义表、修改表 数据查询语言DQL（ Data Query Language）：s0L的数据查询语言主要用来对数据库中的各种数据对象进行查询。 数据操纵语言DML（ Data Manipulation Language）：s0L的数据操纵语言，用于改变数据库中的数据，包括插入，删除，修改 数据控制功能DCL（ Data Control Language）：s0L的数据控制语言，对表和视图的授权，完整性规则的描述以及事务开始和结束等控制语句。 SQL语言特点 综合统一（独立完成数据库生命周期中的全部活动，包括定义关系模式、录入数据、建立数据库、査询、更新、维护、数据库重构、数据库安全） 高度非过程化（用户只需提出“做什么”，而不必指明“怎么做”。） 非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径。 SQL只要提出“做什么”，无须了解存取路径 存取路径的选择以及SQL的操作过程由系统自动完成 面向集合的操作方式（SQL采用集合操作方式） 非关系数据模型采用面向记录的操作方式，操作对象是一条记录 SQL采用集合操作方式 操作对象、查找结果可以是元组的集合 一次插入、删除、更新操作的对象可以是元组的集合 以同一种语法结构提供两种使用方式（S0L既是自含式（独立的）语言，又是嵌入式语言。SQ语句能够嵌入到高级语言程序中，） 语言简洁，易学易用（s0L语言语法简单，接近英语口语，因此容易学习，也容易使用。） SQL功能性极强，完成核心功能只用了9个动词：SELECT（数据查询）；CREATE、ALERT、INSERT（数据定义）；DROP、UPDATE、DELETE（数据操纵）；GRANT、REVOKE(数据控制) SQL的基本概念 基本表 本身独立存在的表 SQL中一个关系就对应一个基本表 一个（或多个）基木表对应一个存储文件 一个表可以带若干索引 视图 概念 从一个或几个基本表导出的表 数据库中只存放视图的定义而不存放视图对应的数据 视图是一个虚表 用户可以在视图上再定义视图 数据库安全性 数据库的不安全因素 非授权用户对数据库的恶意存取和破坏 一些黑客（ Hacker）和犯罪分子在用户存取数据库时猎取用户名和用户口令，然后假冒合法用户偷取、修改甚至破坏用户数据。 数据库管理系统提供的安全措施主要包括用户身份鉴别、存取控制和视图等技术。 数据库中重要或敏感的数据被泄露 黑客和敌对分子千方百计盗窃数据库中的重要数据，些机密信息被暴露 数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等。 审计日志分析 安全环境的脆弱性 安全性控制 用户身份鉴别 静态口令 动态口令 智能卡鉴别 生物特征鉴别 存取控制 机制组成 定义用户权限 合法权限检查 自主存取控制（DAC）： 用户对不同的数据对象有不同的存取权限 不同的用户对同一对象也有不同的权限 用户还可将其拥有的存取权限转授给其他用户 通过SQL的 GRANT语句（权限授予）和 REVOKE语句（权限回收）实现 123456789101112131415161718GRANT语句的一般格式GRANT&lt;权限&gt;[&lt;权限&gt;]ON&lt;对象类型&gt;&lt;对象名&gt;&lt;对象类型&gt;&lt;对象名To&lt;用户&gt;,【&lt;用户&gt;】【WITH GRANT OPTION】； /** 指定该语句表示可以再转授权限*/GRANT ALL PRIVILEGESON TABLE Student CourseTO U2. U3REVOKE语句的一般格式为：REVOKE&lt;权限&gt;[,&lt;权限&gt;]ON&lt;对象类型&gt;&lt;对象名&gt;【&lt;对象类型&gt;&lt;对象名&gt;】FROM&lt;用户&gt;【&lt;用户&gt;】. [CASCADE| RESTRICT]； REVOKE UPDATE（Sno）ON TABLE StudentFROM U4 数据库角色：被命名的一组与数据库操作相关的权限 角色是权限的集合 可以为一组具有相同权限的用户创建一个角色 简化授权的过程 使用角色管理数据库权限 1234567891011121314/** S1.角色创建*/CREATE ROLE &lt;角色名&gt;/** S2.对角色授权*/GRANT&lt;权限&gt;[&lt;权限&gt;]ON&lt;对象类型&gt;对象名To&lt;角色&gt;【&lt;角色&gt;】/** 将一个角色授予其他的角色或用户*/GRANT&lt;角色1&gt;[&lt;角色2&gt;]To&lt;角色3&gt;【&lt;用户1&gt;]&lt;WITH ADMIN OPTION]/** 角色权限的收回*/REVOKE&lt;权限&gt;&lt;权限习ON≤对象类型&gt;&lt;对象名FROM&lt;角色&lt;角色&gt; 存在的缺点：可能存在数据的无意泄露：自主存取控制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记 强制存取控制（MAC）： 保证更高程度的安全性 用户不能直接感知或进行控制 适用于对数据有严格而固定密级分类的部门 军事部门 政府部门 在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类 主体是系统中的活动实体 ■数据库管理系统所管理的实际用户 ■代表用户的各进程 客体是系统中的被动实体，受主体操纵 ■文件、基本表、索引、视图 敏感度标记（ Label） ■对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记（Labe） ■敏感度标记分成若干级别 ●绝密（ Top Secret,Ts） ●机密（ Secret,S） ●可信（ Confidential,C） ●公开（ Public,P） ●Ts&gt;=S&gt;=C&gt;=P 数据库安全性机制——视图机制 授予用户查询某些行的权限？ 需要用存取谓词来定义用户权限 无法直接用 GRANT语句实现 可以用视图机制间接地实现 123456789/** 授予用户查询整个表的权限 */GRANT SELECTON TABLE StudentTO U1/** 授予用户查询某些列的权限 */GRANT SELECT（Sno, Sname）ON TABLE StudentTO U2 使用视图 12345678910111213141516/** Step1. 从基本表上导出数据建立视图 */先建立计算机系学生的视图 Cs StudentCREATE VIEW CS_StudentASSELECTFROM StudentWHERE Sdept='CS'GRANT SELECT ON CS_STUDENT TO U1/** Step2. 在视图上进一步定义存取权限 */GRANT SELECToN CS_StudentTo 王平GRANT ALL PRIVILIGES oN CS StudentTo张明； 审计 用一个专用的审计日志（ Audit Log） 将用户对数据库的所有操作记录在上面 审计员利用审计日志 监控数据库中的各种行为 发现非法存取，发现潜在威胁 C2以上安全级别的DBMS必须具有审计功能 可以被审计的事件： 服务器事件 系统权限 对系统拥有的结构或模式对象进行操作的审计 要求该操作的权限是通过系统权限获得的 语句事件 ●对SQL语句，如DDL、DML、DQL及DCL语句的审计 模式对象事件 ●对特定模式对象上进行的 SELECT或DML操作的审计 审计功能的可选性 ■审计很费时间和空间 ■DBA可以根据应用对安全性的要求，灵活地打开或关 闭审计功能 ■审计功能主要用于安全性要求较高的部门 demo 123456// 对修改SC表结构或修改SC表数据的操作进行审计AUDIT ALTER, UPDATEON SC// 取消对SC表的一切审计NOAUDIT ALTER, UPDATEON SC： 数据加密 加密方法 存储加密 透明存储加密： 内核级加密保护方式（性能好，安全完备性高），对用户完全透明 非透明存储加密：通过多个加密函数实现 传输加密 链路加密：报文、报头都加密 端到端加密：只加密报文 其他安全性保护 推理控制、 隐蔽信道 数据定义 定义数据库的各种“对象” 模式定义 定义模式实际上定义了一个命名空间（或者说目录） 在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。 在 CREATE SCHEMA中可以接受 CREATE TABLE，CREATE VIEW和 GRANT子句。 创建：CREATE SCHEMA&lt;模式名&gt; AUTHORIZATION&lt;用户名&gt;【&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt; 删除：DROP SCHEMA&lt;模式名&gt;&lt; CASCADE | RESTRICT&gt; ■ CASCADE（级联） 删除模式的同时把该模式中所有的数据库对象全部删除 ■ RESTRICT（限制） 如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。 仅当该模式中没有任何下属的对象时才能执行。 表定义 12345CREATE TABLE&lt;表名&gt; /*基本表的名称*/(&lt;列名&gt;&lt;数据类型&gt;【&lt;列级完整性约束条件&gt;】/*组成该表的列*/【，&lt;列名&gt;&lt;数据类型【&lt;列级完整性约束条件】】...【，&lt;表级完整性约束条件&gt;】) &lt;列级完整性约束条件&gt;：涉及相应属性列的完整性约束条件 &lt;表级完整性约束条件&gt;：涉及一个或多个属性列的完整性约束条件 如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上。 视图定义 索引定义 建立索引的目的：加快查询速度 关系数据库管理系统中常见索引 顺序文件上的索引 B+树索引（参见爱课程网3.2节动画《B+树的增删改》） 散列（hash）索引 位图索引 特点 B+树索引具有动态平衡的优点 HASH索引具有查找速度快的特点 关系数据库管理系统自动选择合适的索引作为存取路径，用户不必也不能显式地选择索引 CREATE[UNIQUE] |[CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;（&lt;列名&gt;【&lt;次序&gt;】【列名&gt;【&lt;次序】】） &lt;表名&gt;：要建索引的基本表的名字 索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔 次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：AsC UNIQUE：此索引的每一个索引值只对应唯一的数据记录 CLUSTER：表示要建立的索引是聚簇索引 ALTER INDEX&lt;旧索引名&gt; RENAME TO&lt;新索引名&gt; 数据字典 数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有对象的定义信息以及一些统计信息 关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息。 数据库的完整性 实体完整性 参照完整性 用户定义的完整性 完整性约束命名字句 CONSTRAINT&lt;完整性约束条件名&gt;&lt;完整性约束条件&gt; &lt;完整性约束条件&gt;包括 NOT NULL、 UNIQUE、PRIMARY KEY短语、 FOREIGN KEY短语、 CHECK短语等 删除：ALTER TABLE Student DROP CONSTRAINT C1 增加:ALTER TABLE Student ADD CONSTRAINT C1 CHECK（Sno BETWEEN 900000 AND 999999 域中的完整性限制 断言 sQL中，可以使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。 可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。 断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行 CREATE ASSERTION&lt;断言名&gt;&lt; CHECK子句&gt; 触发器 是用户定义在关系表上的一类由事件驱动的特殊过程 任何用户对表的增、删、改操作均由服务器自动激活相应的触发器 触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力 定义： 当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通常是一段SQL存储过程。 触发器又叫做事件-条件-动作（ event-condition-action）规则 1234CREATE TRIGGER&lt;触发器名&gt; &#123;BEFORE| AFTER&#125; &lt;触发事件&gt;ON&lt;表名&gt;REFERENCING NEW|OLD ROW AS&lt;变量&gt;FOR EACH &#123;ROW | STATEMENT&#125; /** 触发器类型：行级、语句级 */[WHEN&lt;触发条件&gt;] &lt;触发动作体&gt; 只有表的拥有者才能在表上创建触发器 触发事件：INSERT、UPDATE、DELETE； 或者以上操作的组合； UPDATE OF&lt;触发列&gt; 触发器类型 行级触发器（ FOR EACH ROW） 语句级触发器（ FOR EACH STATEMENT） 例子：UPDATE TEACHER SET Deptno=5，假设表 TEACHER有1000行。如果是语句级触发器，那么执行完该语句后，触发动作只发生一次；如果是行级触发器，触发动作将执行1000次 触发条件： 触发器被激活时，只有当触发条件为真时触发动作体才执行；否则触发动作体不执行。 如果省略WHEN触发条件，则触发动作体在触发器激活后立即无条件执行】、 触发动作体： 触发动作体可以是一个匿名 PL/SQL过程块，也可以是对已创建存储过程的调用 如果是行级触发器，用户都可以在过程体中使用NEW和OLD引用事件之后的新值和事件之前的旧值如果是语句级触发器，则不能在触发动作体中使用NEW或OLD进行引用 如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化 Demo Code: 1234567891011121314151617/** 当对表Sc的 Grade属性进行修改时，若分数增加了10%则将此次操作记录到下面表中：*/CREATE TRIGGER SC TAFTER UPDATE OF Grade ON SCREFERENCING OLD row As OldTuple NEW row As NewTupleFOR EACH ROW WHEN（NewTuple Grade &gt;=1.1*Old Tuple Grade)INSERT INTo Sc_U（Sno, Cno, OldGrade, NewGrade） VALUES（OIdTuple.Sno, OldTuple.Cno, oldTuple.Grade, NewTuple.Grade)/**【例522】将每次对表 Student的插入操作所增加的学生个数记录到表 StudentInsertLog中。*/CREATE TRIGGER Student Count AETER INSERT ON StudentREFERENCING NEW TABLE AS DELTA FOR EACH STATEMENTINSERT INTO StudentinsertLog（Numbers） SELECT COUNT(*) FROM DELTA 数据查询语句 连接 自然连接的结果：是采用SELECT去掉重复字段的方式实施的 嵌套循环法： 排序合并法： 索引连接（嵌套循环的一个变种） 外连接与普通连接的区别 普通连接操作只输出满足连接条件的元组 外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出 左外连接 ●列出左边关系中所有的元组 右外连接 ●列出右边关系中所有的元组 嵌套查询 一个 SELECT-FROM-WHERE语句称为一个查询块 将一个查询块嵌套在另一个查询块的 WHERE子句或 HAVING短语的条件中的查询称为嵌套查询 子查询的限制 ●不能使用 ORDER BY子句 嵌套查询求解方法： 不相关子查询：子查询的查询条件不依赖于父查询 由里向外逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件 相关子查询：子查询的查询条件依赖于父查询 （嵌套循环依次从外解决）：demo讲解 首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层査询，若 WHERE子句返回值为真，则取此元组放入结果表 然后再取外层表的下一个元组 重复这一过程，直至外层表全部检查完为止 带有N谓词的子查询 带有比较运算符的子查询 带有ANY或ALL谓词的子查询 带有 EXISTS谓词的子查询 数据更新语句 插入 : INSERT INTO &lt;Table_name&gt;[&lt;属性名&gt;, &lt;属性名&gt;…] VALUES(&lt;常量1&gt;, …) 指定要插入数据的表名及属性列 属性列的顺序可与表定义中的顺序不一致 没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致 只指定部分属性列：插入的元组在其余属性列上取空值 更新：UPDATE&lt;表名&gt;SET&lt;列名&gt;=&lt;表达式&gt;【&lt;列名&gt;=&lt;表达式&gt;】 【WHERE&lt;条件习】； ■修改指定表中满足 WHERE子句条件的元组 ■SET子句给出&lt;表达式&gt;的值用于取代相应的属性列 ■如果省略 WHERE子句，表示要修改表中的所有元组 关系数据库管理系统在执行修改语句时会检查修改操作是否破坏表上已定义的完整性规则 ■实体完整性 ■主码不允许修改 ■用户定义的完整性 NOT NULL约束 UNIQUE约束 值域约束 删除: DELETE FROM &lt;表名&gt; [WHERE&lt;条件&gt;]； ■删除指定表中满足 WHERE子句条件的元组WHERE子句 ■指定要删除的元组 ■无该子句将会删除表中的全部元组 附录 HAVING短语与 WHERE子句的区别： 作用对象不同 WHERE子句作用于基表或视图，从中选择满足条件的元组 HAVING短语作用于组，从中选择满足条件的组。、 Q:怎么理解“自然连接”，它与等值连接有什么不同？ 1、自然连接一定是等值连接，但等值连接不一定是自然连接。 2、等值连接要求相等的分量，不一定是公共属性；而自然连接要求相等的分量必须是公共属性。 3、等值连接不把重复的属性除去；而自然连接要把重复的属性除去。 Q:嵌套查询瑞和转换为连接查询？ 不相关子查询，内查询不依赖于外层。执行过程中，首先执行内查询，内查询得到结果不被显示出来，而是传递给外层查询作为外层查询的条件来使用，然后执行外层查询，并显示查询结果。 转为连接查询就是把子查询内表和外部表连接。 Q:两个查询在什么情况下可以自行UNION操作？ UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 该命令连接的结果集中有重复的值不会被显示。想忽略重复值，可以使用 union all Q:‏关系R中能唯一标识一个元组的是它的 A.主码 B.候选码 D.全码 Q‍:实体完整性规则检查的内容包括 检查主码的各个属性值是否为空，只要有一个为空就拒绝插入或修改 检查主码值是否唯一，如果不唯一就拒绝插入或修改 在关系数据库中，模式对应的是___C___。 A.视图和所有基本表 B.视图和部分基本表 C.基本表 D.索引 7 在数据 数据库常见的四种故障 (1) 事务内部的故障：事务内部故障可分为预期的和非预期的，其中大部分的故障都是非预期的。预期的事务内部故障是指可以通过事务程序本身发现的事务内部故障; 非预期的事务内部故障是不能由事务程序处理的，如运算溢出故障、并发事务死锁故障、违反了某些完整性限制而导致的故障等。 (2) 系统故障：系统故障也称为软故障，是指数据库在运行过程中，由于硬件故障、数据库软件及操作系统的漏洞、突然停电灯情况，导致系统停止运转，所有正在运行的事务以非正常方式终止，需要系统重新启动的一类故障。这类事务不破坏数据库，但是影响正在运行的所有事务。 (3) 介质故障：介质故障也称为硬故障，主要指数据库在运行过程中，由于磁头碰撞、磁盘损坏、强磁干扰、天灾人祸等情况，使得数据库中的数据部分或全部丢失的一类故障。 (4) 计算机病毒故障：计算机病毒故障是一种恶意的计算机程序，它可以像病毒一样繁殖和传播，在对计算机系统造成破坏的同时也可能对数据库系统造成破坏(破坏方式以数据库文件为主) 。 Q:要实现记录的物理顺序与索引项次序一致，应选择的索引类型是（）。 A.HASH 索引 B.聚簇索引 C.B+树索引 D.单一索引 数据库编码问题 1234567891011121、查看 MySQL 数据库服务器和数据库字符集 show variables like&apos;%char%&apos;;2、查看 MySQL 数据库服务器和数据库核对排序方式（校对规则） SHOW VARIABLES LIKE &apos;COLLATION&apos;;3、查看当前安装的 MySQL 所支持的字符集。 show charset;4、查看当前数据库编码： SHOW CREATE DATABASE db_name;5、查看表编码： SHOW CREATE TABLE tbl_name;6、查看字段编码： SHOW FULL COLUMNS FROM tbl_name; 修改数据库默认的字符集 通过命令 123456789set character_set_client=&quot;utf8&quot;; //客户端字符集set character_set_connection=&quot;utf8&quot;; //链接字符集set character_set_database=&quot;utf8&quot;; //数据库字符集set character_set_results=&quot;utf8&quot;; //结果字符集set character_set_server=&quot;utf8&quot;; //服务器字符集set character_set_system=&quot;utf8&quot;; //系统字符集set collation_connection=&quot;utf8&quot;; //链接校对set collation_database=&quot;utf8&quot;; //数据库校对set collation_server=&quot;utf8&quot;; //服务器校对 修改配置文件： LINUX 修改vi/etc/my.cnf; WINDOWS my.ini 修改数据库的字符集 ` mysql&gt;use mydb`` `` mysql&gt;ALTER DATABASE mydb CHARACTER SET utf-8(utf8) COLLATE utf8_general_ci` 123456789101》mysql&gt; set names gbk;Query OK, 0 rows affected ( 0.00 sec)它相当于下面的三句指令：SET character_set_client = gbk;SET character_set_results = gbk;SET character_set_connection = gbk;因此，这个方法也可以解决所有字符编码设置为gbk，而控制台显示中文乱码的问题。原文链接：https://blog.csdn.net/qq_27231343/article/details/52334831 MySQL中的字符集转换过程 1. MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection; 2. 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下： 使用每个数据字段的CHARACTER SET设定值; 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准); 若上述值不存在，则使用character_set_server设定值。 3. 将操作结果从内部操作字符集转换为character_set_results。 MySQL默认字符集 MySQL对于字符集的指定可以细化到一个数据库，一张表，一列，应该用什么字符集。 但是，传统的程序在创建数据库和数据表时并没有使用那么复杂的配置，它们用的是默认的配置，那么，默认的配置从何而来呢？ 编译MySQL 时，指定了一个默认的字符集，这个字符集是 latin1； 安装MySQL 时，可以在配置文件 (my.ini) 中指定一个默认的的字符集，如果没指定，这个值继承自编译时指定的； 启动mysqld 时，可以在命令行参数中指定一个默认的的字符集，如果没指定，这个值继承自配置文件中的配置,此时 character_set_server 被设定为这个默认的字符集； 当创建一个新的数据库时，除非明确指定，这个数据库的字符集被缺省设定为character_set_server； 当选定了一个数据库时，character_set_database被设定为这个数据库默认的字符集； 在这个数据库里创建一张表时，表默认的字符集被设定为 character_set_database，也就是这个数据库默认的字符集； 当在表内设置一栏时，除非明确指定，否则此栏缺省的字符集就是表默认的字符集； utf8mb4 MySQL的“utf8”实际上不是真正的UTF-8: MYSQL中的“utf8”字符集只支持每个字符最多三个字节，而真正的UTF-8是每个字符最多四个字节。(MySQL一直没有修复这个bug，他们在2010年(mysql 5.5.3)发布了一个叫作“utf8mb4”的字符集(Most byte 4用来兼容4字节的万国码)，绕过了这个问题。) 原来mysql支持的 utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了。三个字节的 UTF-8 最大能编码的 Unicode 字符是 0xffff，也就是 Unicode 中的基本多文种平面（BMP）。也就是说，任何不在基本多文本平面的 Unicode字符，都无法使用 Mysql 的 utf8 字符集存储。包括 Emoji 表情（Emoji 是一种特殊的 Unicode 编码，常见于 ios 和 android 手机上），和很多不常用的汉字，以及任何新增的 Unicode 字符等等。 然而对于新字符集utf8mb4的出现，他们并没有广而告之（可能是因为这个bug让他们觉得很尴尬），以致于现在网络上仍然在建议开发者使用“utf8”，但这些建议都是错误的，当然真正做开发的人是知道的，这也是很多sql文件中看到建库建表都出现了utf8mb4的原因。 官方手册 https://dev.mysql.com/doc/refman/5.6/en/charset-unicode-utf8mb4.html 的说明： 12345The character set named utf8 uses a maximum of three bytes per character and contains only BMP characters. The utf8mb4 character set uses a maximum of four bytes per character supports supplementary characters:- For a BMP character, utf8 and utf8mb4 have identical storage characteristics: same code values, same encoding, same length.- For a supplementary character, utf8 cannot store the character at all, whereas utf8mb4 requires four bytes to store it. Because utf8 cannot store the character at all, you have no supplementary characters in utf8 columns and need not worry about converting characters or losing data when upgrading utf8 data from older versions of MySQL.1234 MySQL在 5.5.3 之后增加了 utf8mb4 字符编码，mb4即 most bytes 4。简单说 utf8mb4 是 utf8 的超集并完全兼容utf8，能够用四个字节存储更多的字符。 但抛开数据库，标准的 UTF-8 字符集编码是可以用 1~4 个字节去编码21位字符，这几乎包含了是世界上所有能看见的语言了。然而在MySQL里实现的utf8最长使用3个字节，也就是只支持到了 Unicode 中的 基本多文本平面（U 0000至U FFFF），包含了控制符、拉丁文，中、日、韩等绝大多数国际字符，但并不是所有，最常见的就算现在手机端常用的表情字符 emoji和一些不常用的汉字，如 “墅” ，这些需要四个字节才能编码出来。 注：QQ里面的内置的表情不算，它是通过特殊映射到的一个gif图片。一般输入法自带的就是。 也就是当你的数据库里要求能够存入这些表情或宽字符时，可以把字段定义为 utf8mb4，同时要注意连接字符集也要设置为utf8mb4，否则在 严格模式 下会出现 Incorrect string value: /xF0/xA1/x8B/xBE/xE5/xA2… for column 'name'这样的错误，非严格模式下此后的数据会被截断。 提示：另外一种能够存储emoji的方式是，不关心数据库表字符集，只要连接字符集使用 latin1，但相信我，你绝对不想这个干，一是这种字符集混用管理极不规范，二是存储空间被放大（读者可以想下为什么）。 总结后的结论： MySQL的“utf8mb4”是真正的“UTF-8”。 MySQL的“utf8”是一种“专属的编码”，它能够编码的Unicode字符并不多。 from: utf8编码和utf8mb4编码（其它编码简介） 记住，永远不要在MySQL中使用“utf8” utf8mb4_general_ci 字符除了需要存储，还需要排序或比较大小，涉及到与编码字符集对应的 排序字符集（collation）。ut8mb4对应的排序字符集常用的有 utf8mb4_unicode_ci、utf8mb4_general_ci，到底采用哪个在 stackoverflow 上有个讨论，What’s the difference between utf8_general_ci and utf8_unicode_ci 主要从排序准确性和性能两方面看： 准确性 utf8mb4_unicode_ci 是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序 utf8mb4_general_ci 没有实现Unicode排序规则，在遇到某些特殊语言或字符是，排序结果可能不是所期望的。 但是在绝大多数情况下，这种特殊字符的顺序一定要那么精确吗。比如Unicode把ß、Œ当成ss和OE来看；而general会把它们当成s、e，再如ÀÁÅåāă各自都与 A 相等。 性能 utf8mb4_general_ci 在比较和排序的时候更快 utf8mb4_unicode_ci 在特殊情况下，Unicode排序规则为了能够处理特殊字符的情况，实现了略微复杂的排序算法。 但是在绝大多数情况下，不会发生此类复杂比较。general理论上比Unicode可能快些，但相比现在的CPU来说，它远远不足以成为考虑性能的因素，索引涉及、SQL设计才是。 我个人推荐是 utf8mb4_unicode_ci，将来 8.0 里也极有可能使用变为默认的规则。相比选择哪一种collation，使用者应该更关心字符集与排序规则在db里要统一就好。 这也从另一个角度告诉我们，不要可能产生乱码的字段作为主键或唯一索引。我遇到过一例，以 url 来作为唯一索引，但是它记录的有可能是乱码，导致后来想把它们修复就特别麻烦。 from: mysql使用utf8mb4经验吐血总结 MySQL大表优化方案 Mysql的row_format(fixed与dynamic) 已有建库SQL： autoplan 12345678910111213141516171819202122232425262728293031323334353637383940414243SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for auto_bilibili-- ----------------------------DROP TABLE IF EXISTS `auto_bilibili`;CREATE TABLE `auto_bilibili`( `id` int NOT NULL AUTO_INCREMENT, `userid` int NOT NULL, `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '创建的任务名', `sessdata` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL, `bili_jct` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL, `dedeuserid` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL, `taskIntervalTime` int NOT NULL DEFAULT 10 COMMENT '任务之间的执行间隔', `numberOfCoins` int NOT NULL DEFAULT 5 COMMENT '每日投币数量', `reserveCoins` int NOT NULL DEFAULT 50 COMMENT '预留的硬币数', `selectLike` int NOT NULL DEFAULT 0 COMMENT '投币时是否点赞，默认 0, 0：否 1：是', `monthEndAutoCharge` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'true' COMMENT '年度大会员月底是否用 B 币券给自己充电，默认 true，即充电对象是你本人。', `giveGift` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'true' COMMENT '直播送出即将过期的礼物，默认开启', `upLive` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '0' COMMENT '直播送出即将过期的礼物，指定 up 主，为 0 时则随随机选取一个 up 主', `chargeForLove` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '0' COMMENT '给指定 up 主充电，值为 0 或者充电对象的 uid，默认为 0，即给自己充电', `devicePlatform` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'ios' COMMENT '手机端漫画签到时的平台，建议选择你设备的平台 ，默认 ios', `coinAddPriority` int NOT NULL DEFAULT 1 COMMENT '0：优先给热榜视频投币，1：优先给关注的 up 投币', `userAgent` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36 Edg/86.0.622.69' COMMENT '浏览器 UA', `skipDailyTask` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'false' COMMENT '是否跳过每日任务', `webhook` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '推送地址', `enddate` datetime NULL DEFAULT NULL, `match_enable` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'false' COMMENT '预测是否开启', `match_predictNumberOfCoins` int NOT NULL DEFAULT 10 COMMENT '单次预测投注硬币', `match_minimumNumberOfCoins` int NOT NULL DEFAULT 200 COMMENT '预测保留硬币', `match_showHandModel` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'false' COMMENT '押注形式', `other` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE, INDEX `userid` (`userid`) USING BTREE, CONSTRAINT `auto_bilibili_ibfk_1` FOREIGN KEY (`userid`) REFERENCES `sys_user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC; 建表末尾的AUTO_INCREMENT：指定一个自增的初始值， 比如AUTO_INCREMENT = 7则是要求ID从7开始自增（初始值为7) Mysql Row_Format 参数讲解 在MYSQL中， 若一张表里面不存在varchar、text以及其变形、blob以及其变形的字段的话，那么张这个表其实也叫静态表，即该表的row_format是fixed，就是说每条记录所占用的字节一样。其优点读取快，缺点浪费额外一部分空间。 么实际开发中,这种表很少,大部分表的字段类型都是有很多种的,那么这种表就叫做:dynamic :动态表 ,优点是节省空间,缺点是读取的时间的开销 ROW_FORMAT 的值如下:DEFAULT、FIXED、DYNAMIC、COMPRESSED、REDUNDANT、COMPACT lottery 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/*SQLyog Ultimate v11.24 (32 bit)MySQL - 5.5.46-0ubuntu0.14.04.2 : Database - testbbs**********************************************************************//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`lottery` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `lottery`;/*Table structure for table `lt_blackip` */DROP TABLE IF EXISTS `lt_blackip`;CREATE TABLE `lt_blackip` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `ip` varchar(50) NOT NULL DEFAULT '' COMMENT 'IP地址', `blacktime` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '黑名单限制到期时间', `sys_created` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `sys_updated` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `ip` (`ip`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;/*Data for the table `lt_blackip` */insert into `lt_blackip`(`id`,`ip`,`blacktime`,`sys_created`,`sys_updated`) values (1,'127.0.0.1',0,0,1532606350);/*Table structure for table `lt_code` */DROP TABLE IF EXISTS `lt_code`;CREATE TABLE `lt_code` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `gift_id` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '奖品ID，关联lt_gift表', `code` varchar(255) NOT NULL DEFAULT '' COMMENT '虚拟券编码', `sys_created` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `sys_updated` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `sys_status` smallint(5) unsigned NOT NULL DEFAULT '0' COMMENT '状态，0正常，1作废，2已发放', PRIMARY KEY (`id`), UNIQUE KEY `code` (`code`), KEY `gift_id` (`gift_id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;/*Data for the table `lt_code` */insert into `lt_code`(`id`,`gift_id`,`code`,`sys_created`,`sys_updated`,`sys_status`) values (1,4,'abc\\r',1532602694,0,0),(2,4,'aa\\r',1532602694,0,0),(3,4,'cs',1532602694,0,0),(4,4,'332',1532602970,0,2);/*Table structure for table `lt_gift` */DROP TABLE IF EXISTS `lt_gift`;CREATE TABLE `lt_gift` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(255) NOT NULL DEFAULT '' COMMENT '奖品名称', `prize_num` int(11) NOT NULL DEFAULT '-1' COMMENT '奖品数量，0 无限量，&gt;0限量，&lt;0无奖品', `left_num` int(11) NOT NULL DEFAULT '0' COMMENT '剩余数量', `prize_code` varchar(50) NOT NULL DEFAULT '' COMMENT '0-9999表示100%，0-0表示万分之一的中奖概率', `prize_time` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '发奖周期，D天', `img` varchar(255) NOT NULL DEFAULT '' COMMENT '奖品图片', `displayorder` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '位置序号，小的排在前面', `gtype` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '奖品类型，0 虚拟币，1 虚拟券，2 实物-小奖，3 实物-大奖', `gdata` varchar(255) NOT NULL DEFAULT '' COMMENT '扩展数据，如：虚拟币数量', `time_begin` int(11) NOT NULL DEFAULT '0' COMMENT '开始时间', `time_end` int(11) NOT NULL DEFAULT '0' COMMENT '结束时间', `prize_data` mediumtext COMMENT '发奖计划，[[时间1,数量1],[时间2,数量2]]', `prize_begin` int(11) NOT NULL DEFAULT '0' COMMENT '发奖计划周期的开始', `prize_end` int(11) NOT NULL DEFAULT '0' COMMENT '发奖计划周期的结束', `sys_status` smallint(5) unsigned NOT NULL DEFAULT '0' COMMENT '状态，0 正常，1 删除', `sys_created` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `sys_updated` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '修改时间', `sys_ip` varchar(50) NOT NULL DEFAULT '' COMMENT '操作人IP', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;/*Data for the table `lt_gift` */insert into `lt_gift`(`id`,`title`,`prize_num`,`prize_code`,`prize_time`,`img`,`displayorder`,`gtype`,`gdata`,`time_begin`,`time_end`,`prize_data`,`sys_status`,`sys_created`,`sys_updated`,`sys_ip`) values (1,'T恤',10,'1-100',30,'https://p0.ssl.qhmsg.com/t016c44d161c478cfe0.png',1,2,'',1532592420,1564128420,'',0,1532592429,1532593773,'::1'),(2,'360手机N7',1,'0-0',30,'https://p0.ssl.qhmsg.com/t016ff98b934914aca6.png',0,3,'',1532592420,1564128420,'',0,1532592474,0,''),(3,'手机充电器',10,'200-1000',30,'https://p0.ssl.qhmsg.com/t01ec4648d396ad46bf.png',3,2,'',1532592420,1564128420,'',0,1532592558,1532593828,'::1'),(4,'优惠券',100,'2000-5000',1,'https://p0.ssl.qhmsg.com/t01f84f00d294279957.png',4,1,'',1532592420,1564128420,'',0,1532599140,0,'::1');/*Table structure for table `lt_result` */DROP TABLE IF EXISTS `lt_result`;CREATE TABLE `lt_result` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `gift_id` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '奖品ID，关联lt_gift表', `gift_name` varchar(255) NOT NULL DEFAULT '' COMMENT '奖品名称', `gift_type` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '奖品类型，同lt_gift. gtype', `uid` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '用户ID', `username` varchar(50) NOT NULL DEFAULT '' COMMENT '用户名', `prize_code` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '抽奖编号（4位的随机数）', `gift_data` varchar(255) NOT NULL DEFAULT '' COMMENT '获奖信息', `sys_created` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `sys_ip` varchar(50) NOT NULL DEFAULT '' COMMENT '用户抽奖的IP', `sys_status` smallint(5) unsigned NOT NULL DEFAULT '0' COMMENT '状态，0 正常，1删除，2作弊', PRIMARY KEY (`id`), KEY `uid` (`uid`), KEY `gift_id` (`gift_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;/*Data for the table `lt_result` */insert into `lt_result`(`id`,`gift_id`,`gift_name`,`gift_type`,`uid`,`username`,`prize_code`,`gift_data`,`sys_created`,`sys_ip`,`sys_status`) values (1,1,'T恤',2,1,'yifan',1,'',0,'',0);/*Table structure for table `lt_user` */DROP TABLE IF EXISTS `lt_user`;CREATE TABLE `lt_user` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(50) NOT NULL DEFAULT '' COMMENT '用户名', `blacktime` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '黑名单限制到期时间', `realname` varchar(50) NOT NULL DEFAULT '' COMMENT '联系人', `mobile` varchar(50) NOT NULL DEFAULT '' COMMENT '手机号', `address` varchar(255) NOT NULL DEFAULT '' COMMENT '联系地址', `sys_created` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `sys_updated` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '修改时间', `sys_ip` varchar(50) NOT NULL DEFAULT '' COMMENT 'IP地址', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;/*Data for the table `lt_user` */insert into `lt_user`(`id`,`username`,`blacktime`,`realname`,`mobile`,`address`,`sys_created`,`sys_updated`,`sys_ip`) values (1,'wangyi',0,'一凡Sir','11111111111','abcdefg',0,1532595094,'');/*Table structure for table `lt_userday` */DROP TABLE IF EXISTS `lt_userday`;CREATE TABLE `lt_userday` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `uid` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '用户ID', `day` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '日期，如：20180725', `num` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '次数', `sys_created` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `sys_updated` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uid_day` (`uid`,`day`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;/*Data for the table `lt_userday` *//*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"XML语法规则笔记","slug":"XML语法规则笔记","date":"2021-10-09T11:37:54.000Z","updated":"2021-10-09T13:04:17.528Z","comments":true,"path":"2021/10/09/XML语法规则笔记/","link":"","permalink":"https://nymrli.top/2021/10/09/XML语法规则笔记/","excerpt":"","text":"简介： XML 指可扩展标记语言（EXtensible Markup Language）。 XML 是一种很像HTML的标记语言。 XML 的设计宗旨是传输数据，而不是显示数据。 XML 标签没有被预定义。您需要自行定义标签。 XML 被设计为具有自我描述性。 XML 是 W3C 的推荐标准。 特点： 所有 XML 元素都须有关闭标签 XML 标签对大小写敏感 XML 文档必须有根元素 XML 的属性值须加引号，双引号、单引号都可以 实体引用：&amp;lt;, &amp;gt;, &amp;amp, &amp;apos, &amp;quot 在 XML 中，空格会被保留， 但多余的空格会被合并成一个 XML 以 LF 存储换行 用途： XML 把数据从 HTML 分离： 改变数据时不需要对HTML进行改变 XML 简化数据共享 XML 简化数据传输：通过 XML，可以在不兼容的系统之间轻松地交换数据。 XML 简化平台的变更 XML 使您的数据更有用 XML 元素 指的是从（且包括）开始标签直到（且包括）结束标签的部分。 元素可包含其他元素、文本或者两者的混合物。元素也可以拥有属性。 XML 命名规则 XML 元素必须遵循以下命名规则： 名称可以含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字符 “xml”（或者 XML、Xml）开始 名称不能包含空格 可使用任何名称，没有保留的字词。 最佳命名习惯 使名称具有描述性。使用下划线的名称也很不错。 名称应当比较简短，比如：&lt;book_title&gt;，而不是：&lt;the_title_of_the_book&gt;。 避免 “-” 字符。如果您按照这样的方式进行命名：“first-name”，一些软件会认为你需要提取第一个单词。 避免 “.” 字符。如果您按照这样的方式进行命名：“first.name”，一些软件会认为 “name” 是对象 “first” 的属性。 避免 “:” 字符。冒号会被转换为命名空间来使用。 XML 命名空间（XML Namespaces） 在 XML 中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。 使用命名空间案例： 12345678910&lt;rtdBusConfig xmlns=\"http://com.cgs/rtd-bus.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://com.cgs/rtd-bus.xsd rtd-bus.xsd\" id=\"producer\" persistentPath=\"./rtdcache/producer\" &gt; ...&lt;/rtdBusConfig&gt; w3c案例: https://www.w3school.com.cn/xml/xml_namespaces.asp 12345&lt;f:table xmlns:f=\"http://www.w3school.com.cn/furniture\"&gt; &lt;f:name&gt;African Coffee Table&lt;/f:name&gt; &lt;f:width&gt;80&lt;/f:width&gt; &lt;f:length&gt;120&lt;/f:length&gt;&lt;/f:table&gt; 我们在根标签中添加了一个 xmlns:f 属性，xmlns 代表的是 xml namespace，f是我们声明的命名空间前缀，f本身并没有意义，可以将它理解为是 http://www.atguigu.com/xml/b 的一个别名，我们在标签中使用 f，就相当于使用这个 uri 地址。一旦使用了f 这个前缀，就代表这个标签是属于 http://www.atguigu.com/xml/b 这个唯一标识命名空间下的元素。 我们还可以在一个文档中定义多个命名空间，如下的语法也是没有问题的： 12&lt;b:book xmlns:b=\"http://www.atguigu.com/xml/b\" xmlns:a=\"http://www.atguigu.com/xml/a\"&gt; more: https://www.cnblogs.com/xiaomaomao/p/13968976.html XML Namespace (xmlns) 属性 XML 命名空间属性被放置于元素的开始标签之中，并使用以下的语法：xmlns&lt;:namespace-prefix&gt;=&quot;namespaceURI&quot; 当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。 如果没有:namespace-prefix，为xmlns=&quot;namespaceURI&quot;，则采用的是默认的命名空间（Default Namespaces） 命名空间的实际应用 当开始使用 XSL 时，您不久就会看到实际使用中的命名空间。XSL 样式表用于将 XML 文档转换为其他格式，比如 HTML。 如果您仔细观察下面的这个 XSL 文档，就会看到大多数的标签是HTML标签。非 HTML 的标签都有前缀 xsl，并由此命名空间标示：“http://www.w3.org/1999/XSL/Transform”： 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;&lt;xsl:template match=\"/\"&gt;&lt;html&gt;&lt;body&gt; &lt;h2&gt;My CD Collection&lt;/h2&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th align=\"left\"&gt;Title&lt;/th&gt; &lt;th align=\"left\"&gt;Artist&lt;/th&gt; &lt;/tr&gt; &lt;xsl:for-each select=\"catalog/cd\"&gt; &lt;tr&gt; &lt;td&gt;&lt;xsl:value-of select=\"title\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;xsl:value-of select=\"artist\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/xsl:for-each&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; XML语法－处理指令 处理指令，简称PI （processing instruction）。处理指令用来指挥解析引擎如何解析XML文档内容。例如，在XML文档中可以使用xml-stylesheet指令，通知XML解析引擎，应用css文件显示xml文档内容，标签名为中文时，css不起作用。 如&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;css文件名.css&quot;?&gt;* 处理指令必须以&quot;&lt;?&quot;作为开头，以&quot;?&gt;&quot;作为结尾，XML声明语句(&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;)就是最常见的一种处理指令。 XML报文头 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 第一个是XML的声明，其中version属性是必须写的。 encoding属性的值表示用于读取文档的字符集，第二个是一个文档定义的描述。 XML CDATA 由于所有 XML 文档中的文本均会被解析器解析，而**只有 CDATA 区段（CDATA section）中的文本会被解析器忽略。**因此对某些不希望被解析的文本时，需要用CDATA嵌套起来。对于CDATA区域内的内容，XML解析程序不会处理，而是直接原封不动的输出 术语 CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。 CDATA 部分中的所有内容都会被解析器忽略。 CDATA 部分由&quot;&lt;![CDATA[&quot; 开始，由&quot;]]&gt;&quot;结束： 在 XML 元素中，&quot;&lt;&quot; 和 “&amp;” 是非法的。 “&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。 “&amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。 某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。 123456789101112131415&lt;script&gt;&lt;![CDATA[function matchwo(a,b)&#123;if (a &lt; b &amp;&amp; a &lt; 0) then &#123; return 1; &#125;else &#123; return 0; &#125;&#125;]]&gt;&lt;/script&gt; XML DOM DOM 把 XML 文档视为一种树结构。通过这个 DOM 树，可以访问所有的元素。可以修改它们的内容（文本以及属性），而且可以创建新的元素。元素，以及它们的文本和属性，均被视为节点。 xmlns、xmlns:xsi和xsi:schemaLocation POM 文件头示例 123&lt;project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; 初学者看到如上的内容应当有如下困惑点： xmlns:xsi , xmlns, xsi:schmeLocation 这些看上去相近的属性是什么含义， 为什么他们的值是不一样的 URL 这些 URL 是否对应一些可以访问的资源，对于该文件的解析是否会需要下载这些 URL 对应的资源 xmlns:xsi有什么作用？ 按命名空间的概念来说，xmlns:xsi就是定义了一个命名空间前缀 xsi ，其对应的唯一字符串为 http://www.w3.org/2001/XMLSchema-instance。 但是读者会发现， 这个 xmlns:xsi 在不同的 xml 文档中似乎都会出现。 这是因为， xsi 已经成为了一个业界默认的用于 XSD(（XML Schema Definition) 文件的命名空间。 而 XSD 文件（也常常称为 Schema 文件）是用来定义 xml 文档结构的。 注解： XML 解析器可以根据 一个 XSD 文件的内容来解析另一个 XML 文件， 判断该文件的结构是否和 XSD 文件中定义的一致。 XSD 文件 可以理解为 XML 文档可以自定义的语法或格式检查器。 xsi:schemaLocation有何作用？ xsi:schemaLocation其实是Namespace为http://www.w3.org/2001/XMLSchema-instance里的schemaLocation属性，因为我们一开始声明了xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;，然后再看xsi:schemaLocation的使用：xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;,上面这行的语法其实是xsi:schemaLocation = &quot;键&quot; &quot;值&quot; 即 xsi 命名空间下 schemaLocation 元素的值为一个由空格分开的键值对。 这里的xsi:schemaLocation（当然一般都使用这个前缀）。它定义了XML Namespace和对应的XSD（Xml Schema Definition）文档的位置的关系，他们总是成对出现的，通常为两个URI引用对组成，两个URI之间以空白符分隔（空格和换行均可）。 前一个“键” http://maven.apache.org/POM/4.0.0 指代 【命名空间】， 只是一个全局唯一字符串而已 后一个值指代 【XSD location URI】 , 这个值指示了前一个命名空间所对应的 XSD 文件的位置， XML Schema Parser处理器可以利用这个信息获取到 XSD 文件， 从而通过 XSD 文件对所有属于 命名空间 http://maven.apache.org/POM/4.0.0 的元素结构进行校验， 因此这个值必然是可以访问的， 且访问到的内容是一个 XSD 文件的内容 现在概念懂了，来看个spring的xml例子把 参考： 我来说说XML文件中的xmlns、xmlns:xsi和xsi:schemaLocation、dtd文件的具体含义 详解 xml 文件头部的 xmlns:xsi","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://nymrli.top/tags/学习笔记/"}]},{"title":"Makefile使用记录","slug":"makefile使用记录","date":"2021-09-30T04:16:04.000Z","updated":"2021-10-26T12:44:31.686Z","comments":true,"path":"2021/09/30/makefile使用记录/","link":"","permalink":"https://nymrli.top/2021/09/30/makefile使用记录/","excerpt":"","text":"Makefile使用记录 Makefile 文件描述了 Linux 系统下 C/C++ 工程的编译规则，它用来自动化编译 C/C++ 项目。一旦写编写好 Makefile 文件，只需要一个 make 命令，整个工程就开始自动编译，不再需要手动执行 GCC 命令。===&gt;此外拓展功能不至于C++，其相当于组合一系列Linux命令，因此也可以用来编译其他工程。 什么是Makefile？ Windows 下的集成开发环境（IDE）已经内置了 Makefile，或者说会自动生成 Makefile，因此windows下不用去手动编写makefile。但是在 Linux 下的C语言开发会碰到 S：编译的时候需要链接库的的问题——编译的时候 gcc 只会默认链接一些基本的C语言标准库，很多源文件依赖的标准库都需要我们手动链接，因为有很多的文件，还要去链接很多的第三方库。所以在编译的时候命令会很长，并且在编译的时候我们可能会涉及到文件链接的顺序问题，所以手动编译会很麻烦。 A:把要链接的库文件放在 Makefile 中，制定相应的规则和对应的链接顺序。这样只需要执行 make 命令，工程就会自动编译。每次想要编译工程的时候就执行 make ，省略掉手动编译中的参数选项和命令，非常的方便。 S：编译大的工程会花费很长的时间 Makefile 支持多线程并发操作，会极大的缩短我们的编译时间，并且当我们修改了源文件之后，编译整个工程的时候，make 命令只会编译我们修改过的文件，没有修改的文件不用重新编译，也极大的解决了我们耗费时间的问题。 使用 Makefile 的方式：首先需要编写好 Makefile 文件，然后在 shell 中执行 make 命令，程序就会自动执行，得到最终的目标文件。 makefile规则是什么样的？ 规则主要是两个部分组成，分别是依赖的关系和执行的命令，其结构如下所示： 123456targets: prerequisites command# example:test: test.c&lt;tab&gt; gcc -o test test.c# 编译 test.c 文件: test 是的目标文件，也是最终生成的可执行文件。依赖文件就是 test.c 源文件，重建目标文件需要执行的操作是gcc -o test test.c。这就是 Makefile 的基本的语法规则的使用。 targets：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签； prerequisites：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有； command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。 makfile执行流程 在我们编译项目文件的时候，默认情况下，make 执行的是 Makefile 中的第一规则（Makefile 中出现的第一个依赖关系），此规则的第一目标称之为“最终目标”或者是“终极目标”。 案例分析： 123456789main:main.o test1.o test2.o gcc main.o test1.o test2.o -o mainmain.o: main.c test.h gcc -c main.c -o main.otest1.o: test1.c test.h gcc -c test1.c -o test1.otest2.o: test2.c test.h gcc -c test2.c -o test2.o# 通过 Makefile 我们可以发现，目标 main\"在 Makefile 中是第一个目标，因此它就是 make 的终极目标 它的具体工作顺序是：当在 shell 提示符下输入 make 命令以后。 make 读取当前目录下的 Makefile 文件，并将 Makefile 文件中的第一个目标作为其执行的“终极目标”，开始处理第一个规则（终极目标所在的规则）。在我们的例子中，第一个规则就是目标 “main” 所在的规则。规则描述了 “main” 的依赖关系，并定义了链接 “.o” 文件生成目标 “main” 的命令；make 在执行这个规则所定义的命令之前，首先处理目标 “main” 的所有的依赖文件（例子中的那些 “.o” 文件）的更新规则（以这些 “.o” 文件为目标的规则）。 对这些 “.o” 文件为目标的规则处理有下列三种情况： 目标 “.o” 文件不存在，使用其描述规则创建它； 目标 “.o” 文件存在，目标 “.o” 文件所依赖的 “.c” 源文件和 “.h” 文件中的任何一个比目标 “.o” 文件**“更新”**（依赖的.h、.c在上一次 make 之后被修改）。则根据规则重新编译生成它； 目标 “.o” 文件存在，目标 “.o” 文件比它的任何一个依赖文件（&quot;.c&quot; 源文件、&quot;.h&quot; 文件）“更新”（它的依赖文件.h、.c在上一次 make 之后没有被修改），则什么也不做。 通过上面的更新规则我们可以了解到中间文件的作用，也就是编译时生成的 “.o” 文件。作用是检查某个源文件是不是进行过修改，最终目标文件是不是需要重建。我们执行 make 命令时，只有修改过的源文件或者是不存在的目标文件会进行重建，而那些没有改变的文件不用重新编译，这样在很大程度上节省时间，提高编程效率。小的工程项目可能体会不到，项目工程文件越大，效果才越明显。 变量 定义变量的基本语法如下：变量的名称=值列表 调用变量的时候可以用 &quot;$(VALUE_LIST)&quot;或者是&quot;${VALUE_LIST}&quot;来替换，这就是变量的引用。 知道了如何定义，下面我们来说一下 Makefile 的变量的四种基本赋值方式： 简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。 递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。 条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。 追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。 条件判断 ifeq 和 ifneq 12345ifeq (ARG1, ARG2)ifeq &apos;ARG1&apos; &apos;ARG2&apos;ifeq &quot;ARG1&quot; &quot;ARG2&quot;ifeq &quot;ARG1&quot; &apos;ARG2&apos;ifeq &apos;ARG1&apos; &quot;ARG2&quot; ifdef 和 ifndef 1ifdef VARIABLE-NAME 伪目标 并不会创建目标文件，只是想去执行这个目标下面的命令。 伪目标的存在可以帮助我们找到命令并执行。 使用伪目标有两点原因： 避免我们的 Makefile 中定义的只执行的命令的目标和工作目录下的实际文件出现名字冲突。 提高执行 make 时的效率，特别是对于一个大型的工程来说，提高编译的效率也是我们所必需的。 12clean: rm -rf *.o test 规则中 rm 命令不是创建文件 clean 的命令，而是执行删除任务，删除当前目录下的所有的 .o 结尾和文件名为 test 的文件。 当工作目录下不存在以 clean 命令的文件时，在 shell 中输入 make clean 命令，命令 rm -rf *.o test 总会被执行 ，这也是我们期望的结果。 如果当前目录下存在文件名为 clean 的文件时情况就会不一样了，当我们在 shell 中执行命令 make clean，由于这个规则没有依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令。因此命令 rm 将不会被执行。为了解决这个问题，删除 clean 文件或者是在 Makefile 中将目标 clean 声明为伪目标。将一个目标声明称伪目标的方法是将它作为特殊的目标.PHONY的依赖，如下： .PHONY:clean 这样 clean 就被声明成一个伪目标，无论当前目录下是否存在 clean 这个文件，当我们执行 make clean 后 rm 都会被执行。而且当一个目标被声明为伪目标之后，make 在执行此规则时不会去试图去查找隐含的关系去创建它。这样同样提高了 make 的执行效率，同时也不用担心目标和文件名重名而使我们的编译失败。 伪目标实现多文件编辑 如果在一个文件里想要同时生成多个可执行文件，我们可以借助伪目标来实现。使用方式如下： 1.PHONY:allall:test1 test2 test3test1:test1.o gcc -o $@ $^test2:test2.o gcc -o $@ $^test3:test3.o gcc -o $@ $^ 我们在当前目录下创建了三个源文件，目的是把这三个源文件编译成为三个可执行文件。将重建的规则放到 Makefile 中，约定使用 “all” 的伪目标来作为最终目标，它的依赖文件就是要生成的可执行文件。这样的话只需要一个 make 命令，就会同时生成三个可执行文件。 之所以这样写，是因为伪目标的特性，它总会被执行，所以它依赖的三个文件的目标就不如 “all” 这个目标新，所以，其他的三个目标的规则总是被执行，这也就达到了我们一口气生成多个目标的目的。我们也可以实现单独的编译这三个中的任意一个源文件（我们想去重建 test1，我们可以执行命令make test1 来实现 ）。 -l参数和-L参数 **-l**参数就是用来指定程序要链接的库，-l参数紧接着就是库名(-l&lt;packageName&gt;)，那么库名跟真正的库文 件名有什么关系呢？A: 就拿数学库来说，他的库名是m，他的库文件名是libm.so，很容易看出，把库文件名的 头lib和尾.so去掉就是库名了。 好了现在我们知道怎么得到库名了，比如我们自已要用到一个第三方提供的库名字叫libtest.so，那么我们只要①把 libtest.so拷贝到/usr/lib 里，②编译时加上-ltest参数，我们就能用上libtest.so库了（当然要用libtest.so库里的函数，我们还需要与libtest.so配套的头文件）。 注：放在 /lib 和 /usr/lib 和 /usr/local/lib 里的库直接用-l参数就能链接了，但如果库文件如果没有放在这三个目录里，而是放在其他目录里，这时我们只用-l参数的话，链接还是会出错，出错信息大概是：“/usr/bin/ld: cannot find -lxxx”，也就是提醒开发人员：链接程序ld在那3个目录里找不到libxxx.so。 这时另外一个参数**-L**就派上用场了，比如常用的X11的库，它放在/usr/X11R 6/lib目录下，我们编译时就要用-L/usr/X11R6/lib - lX11参数，-L参数跟着的是库文件所在的目录名(-L &lt;packagePath&gt;)。比如我们把libtest.so在/aaa/bb b/ccc目录下，那链接参数就是-L /aaa/bbb/ccc -ltest， 注意需要加上-ltest（RFID工程代码中的makefile就是因为没有加上这个导致的） 附录 通用范式 清除工作目录中的过程文件 我们在使用的时候会产生中间文件会让整个文件看起来很乱，所以在编写 Makefile 文件的时候会在末尾加上这样的规则语句来清除工作目录中的过程文件： 1234.PHONY:cleanclean: rm -rf *.o test# 其中 \"*.o\" 是执行过程中产生的中间文件，\"test\" 是最终生成的执行文件。我们可以看到 clean 是独立的，它只是一个*伪目标*，不是具体的文件。不会与第一个目标文件相关联，所以我们在执行 make 的时候也不会执行下面的命令。在shell 中执行 \"make clean\" 命令，编译时的中间文件和生成的最终目标文件都会被清除，方便我们下次的使用。 完整范式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152OBJS = base64.o faceSearch.o camera.o CRC.o cQueue.o myQueue.o myUart.o info.o mcuio.o global.o print.o myMQTT.o rfid.o serialscreen.o sscreenupdate.o hmiFSM.o main.oINCLUDES = -I ./include/ # 指定头文件CC = arm-linux-gcc # 指定gcc编译期CXX = arm-linux-g++ # 指定g++编译期CFLAGS = -g -Wall -c $(INCLUDES) # 指定C编译参数LIBS = -L ./lib -L./org.eclipse.mosquitto/lib -L /usr/local/arm/4.4.3/arm-none-linux-gnueabi/sys-root/lib/ #arm-linux-gcc test.c -I./org.eclipse.mosquitto/lib/ -L./org.eclipse.mosquitto/lib -lmosquitto -lpthread -lrtmes:clean $(OBJS) $(CXX) -o mes $(OBJS) $(LIBS) -lpthread -lsqlite3 -lrt -lmosquitto -lcjson -lstdc++ -lcurlmain.o : main.c $(CC) $(CFLAGS) main.c hmiFSM.o : hmiFSM.c $(CXX) $(CFLAGS) hmiFSM.c serialscreen.o : serialscreen.c $(CC) $(CFLAGS) serialscreen.c sscreenupdate.o : $(CC) $(CFLAGS) sscreenupdate.crfid.o : rfid.c $(CC) $(CFLAGS) rfid.c myMQTT.o : myMQTT.c $(CC) $(CFLAGS) myMQTT.c myQueue.o : myQueue.c $(CC) $(CFLAGS) myQueue.c cQueue.o : cQueue.c $(CC) $(CFLAGS) cQueue.c myUart.o : myUart.c $(CC) $(CFLAGS) myUart.cmyUart485.o : myUart485.c $(CC) $(CFLAGS) myUart485.cCRC.o : CRC.c $(CC) $(CFLAGS) CRC.cinfo.o : info.c $(CC) $(CFLAGS) info.cmcuio.o : mcuio.c $(CC) $(CFLAGS) mcuio.cglobal.o : global.c $(CC) $(CFLAGS) global.cprint.o : print.c $(CC) $(CFLAGS) print.cfaceSearch.o : faceSearch.cpp $(CXX) $(CFLAGS) -c faceSearch.cpp -o faceSearch.obase64.o : base64.c $(CC) $(CFLAGS) -c base64.c -o base64.omonitor: $(CC) $(CFLAGS) smartlibdaemon.c -o monitor1 clean : rm $(OBJS) mes monitor -rfupdate: scp ./smartlib root@10.82.80.234:/var/www/smartlibrary-update/ Gcc CFLAGs -I: (include)包含.h头文件 -o：(output) 指定输出文件名 gcc -o app test.c将生成可执行程序exe -c: (compile) 只编译不链接：产生.o文件，就是obj文件，不产生执行文件 gcc -c test.c将生成test.o的目标文件 ▲.gcc -c a.c -o a.o表示把源文件a.c编译成指定文件名a.o的中间目标文件(其实在这里，把-o a.o省掉，效果是一样的，因为中间文件默认与源文件同名，只是后缀变化)。 如果GCC不带-C参数，编译一个源代码文件（test.c)。那么会自动将编译和链接一步完成，并生成可执行文件。可执行文件可以有-o参数指定（test.o) 如果是多个文件，则需要先编译成中间目标文件(一般是.o文件），在链接成可执行文件，一般习惯目标文件都是以.o后缀，也没有硬性规定可执行文件不能用.o文件。 嵌入式编程： 全局变量 如果是main中声明的全局变量，工程中的其他文件都不需要引入&quot;main.c&quot; or &quot;main.h&quot;就可以直接使用 如果不是，则最好的方式还是用一个源文件里（如global.c）声明全局变量，其他cpp若使用某个全局变量，在相应的头文件中包含该头文件(global.h)即可。 Q: 为什么不直接在global.h头文件里定义全局变量？ A: 由于全局变量的定义有且只能有一次，如果是在头文件中定义了，那么就会导致重复定义。===&gt;因此头文件只能用来声明，不能用来定义。 声明与定义 函数或变量在声明时，并没有给它实际的物理内存空间，它有时候可保证你的程序编译通过； 函数或变量在定义时，它就在内存中有了实际的物理空间。 如果你在编译单元中引用的外部变量没有在整个工程中任何一个地方定义的话，那么即使它在编译时可以通过，在连接时也会报错，因为程序在内存中找不到这个变量。 函数或变量可以声明多次，但定义有且只能有一次。 sprintf C函数：将格式化的数据写入字符串， 原型为：`int sprintf(char *dest_str, char * format [, argument, …]); 123456// sprintf()最常见的应用之一莫过于把整数打印到字符串中，如：sprintf(s, \"%d\", 123); //把整数123打印成一个字符串保存在s中sprintf(s, \"%8x\", 4567); //小写16进制，宽度占8个位置，右对齐// 拓展demosprintf(mr-&gt;taskId, \"%s\", cJSON_GetObjectItem(root, \"taskId\")-&gt;valuestring);sprintf(mr-&gt;printData, \"%s\", cJSON_GetObjectItem(root, \"data\")-&gt;valuestring); sscanf C 库函数 : 从字符串读取格式化输入。原型为：int sscanf(const char *str, const char *format, ...) 1234567// example: 1sscanf(buf,\"#####%d+%[a-zA-Z]+%d#####\",&amp;sid,cmdid,&amp;id);// example: 2if(cJSON_GetObjectItem(root, \"status\") != NULL) &#123; sscanf( cJSON_GetObjectItem(root, \"status\")-&gt;valuestring,\"%d\",&amp;(mr-&gt;status));&#125;sprintf((mr-&gt;sequence), \"%s\", cJSON_GetObjectItem(root, \"sequence\")-&gt;valuestring); memcpy C 库函数: 从存储区 str2 复制 n 个字节到存储区 str1。原型为：void memcpy(void str1, const void str2, size_t n) 123int getUser(char *cmd,char *user)&#123; memcpy(user,cmd+POS_USER,iv-POS_USER );&#125; memset() C 库函数：复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。原型为：void *memset(void *str, int c, size_t n) strcpy() C 库函数：把 src 所指向的字符串复制到 dest。原型:char *strcpy(char *dest, const char *src)","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://nymrli.top/tags/配置/"}]},{"title":"物联网基础与应用-课程笔记","slug":"物联网基础与应用-课程笔记","date":"2021-09-27T15:44:21.000Z","updated":"2021-10-11T13:04:37.104Z","comments":true,"path":"2021/09/27/物联网基础与应用-课程笔记/","link":"","permalink":"https://nymrli.top/2021/09/27/物联网基础与应用-课程笔记/","excerpt":"","text":"IOT课上实验 交叉编译环境 什么是交叉编译环境？ 交叉编译其实是相对于本地编译(native build)来说的，大家最开始学习 C/C++ 这些语言的时候，都是在自己的笔记本上写程序，然后在直接在电脑上编译生成可执行文件，最后在电脑上运行。整个流程为：程序的编辑-&gt;编译-&gt;运行，整个过程都是在一台 X86 电脑上。 当我们开始接触嵌入式开发后，事情变的不一样了。你在电脑上写程序，在电脑上编译出可执行文件，最后这个可执行文件需要下载到你的开发板上运行。程序最后运行的环境变了，比如你的开发板是基于 Arm 的——程序在 X86 上编辑，编译，最终运行在另一个和 X86 完全不同的架构的 Arm 芯片上。 之所以整个流程变成了这个样子，这是由嵌入式系统的特性决定的：一般嵌入式系统里面使用的芯片性能都比较弱，而且绝大部分都不能像 X86 一样运行 Windows/Ubuntu 桌面系统，即使能运行，性能也很弱，在开发板上很难提供写代码、编译代码的环境。所以我们还是离不开 X86 电脑强大高效的桌面环境进行软件开发。 总结： 在性能强大的个人电脑上编写源码和编译程序，将可执行文件运行在开发板上。 搭建交叉编译环境 操作系统强烈推荐使用 ubuntu-12.04 以上版本的 64 位发行版， windows上不行 预安装：在安装交叉编译工具之前需要先安装 32 位的兼容库和 libncurses5-dev 库，安装兼容库 需要从 ubuntu 的源库中下载。如果主机没有安装 32 位兼容库，在使用交叉编译工具的时候可能会出现错误：-bash: ./arm-fsl-linux-gnueabi-gcc: 没有那个文件或目录因此需要先sudo apt-get install ia32-libs安装32位兼容库，然后sudo apt-get install libncurses5-dev安装 libncurses5-dev，如果没有安装libncurses5-dev，在使用 make menucofig 时会如所示的错误'make menuconfig' requires the ncurses libraries 安装交叉编译工具链：需要 root 权限。在终端执行命令：$ sudo tar –zxvf gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12.tar.gz -C /opt/， 交叉编译工具链将会被安装到/opt/ gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12目录下（注意解压时-C为改变解压目录，指定为 /opt/ 目录），交叉编译器的具体目录是 /opt/gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12/fsl-linaro-toolchain/bin/bin。 为了方便使用，还需将交叉编译器路径添加到系统路径中：修改~/.bashrc 文件，在 PATH 变量中增加交叉编译工具链的 安装路径，然后运行~/.bashrc 文件，使设置生效。在~/.bashrc 文件末尾增加一行： export PATH=$PATH:/opt/gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12/fsl-linaro-toolchain/bin/ 查看是否安装成功：在终端输入 arm-fsl-linux-gnueabi-并按 TAB 键，如果能够看到很多 arm-fsl-linux-gnueabi前缀的命令，则基本可以确定交叉编译器安装正确。 注：从ubuntu 13.10已经废弃了ia32-libs，因此如果在Ubuntu16.04的机子上安装，会出现如下报错： 123456789101112mrli@welcome:~/iot$ sudo apt-get install ia32-libssudo: unable to resolve host welcome[sudo] password for mrli: Reading package lists... DoneBuilding dependency tree Reading state information... DonePackage ia32-libs is not available, but is referred to by another package.This may mean that the package is missing, has been obsoleted, oris only available from another sourceHowever the following packages replace it: lib32ncurses5 lib32z1E: Package 'ia32-libs' has no installation candidate 编译代码 由于一直报错：/home /mrli/iot/gcc-46.2-glibc-213-linaro-multillb-201112/fsl-linaro-toolchain/bin/。/lib/gcc/arm-fsl-linux-gnueabi/4.6.2/。.//。/arm-fsl-linux-gnueabi/bin/ld:warning:libcrypto so 1.1， needed by ./lib/libcurl. so, not found（try using -rpath or -rpath-link）， 原因是LIB后没有带编译链接选项-lcurl, -lcrypto, -lssl MQTT MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的&quot;轻量级&quot;通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。 MQTT协议实现方式 实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT传输的消息分为：主题（Topic）和负载（payload）两部分： （1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）； （2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。 MQTT入门介绍——菜鸟教程 mosquitto使用 库函数API介绍：mosquitto库函数详解 12 MQTT设计了一套保证消息稳定传输的机制，包括消息应答、存储和重传。在这套机制下，提供了三种不同层次QoS（Quality of Service）： QoS0，At most once，至多一次； QoS1，At least once，至少一次； QoS2，Exactly once，确保只有一次。 客户端可以主动选择性地往某一主题推送信息，这个不需要提前设定；但在接收信息方面，需要客户端提前订阅主题，注：客户端同时可以订阅多个主题，且MQTT协议的主题解析有规则，规则如下： Springboot_MQTT: https://blog.csdn.net/yl_hahha/article/details/99246679 https://blog.csdn.net/qq_41018959/article/details/81076055?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link pthread库使用 库函数API介绍：线程以及pthread库的使用","categories":[],"tags":[{"name":"ZJU","slug":"ZJU","permalink":"https://nymrli.top/tags/ZJU/"},{"name":"嵌入式开发","slug":"嵌入式开发","permalink":"https://nymrli.top/tags/嵌入式开发/"}]},{"title":"学点Gradle","slug":"学点Gradle","date":"2021-09-26T05:37:07.000Z","updated":"2021-09-27T00:37:42.792Z","comments":true,"path":"2021/09/26/学点Gradle/","link":"","permalink":"https://nymrli.top/2021/09/26/学点Gradle/","excerpt":"","text":"Gradle学习 在kotlin中使用mapstruct出现了些问题， 网上搜寻后得到结论：需要使用kapt(Kotlin annotation processing tool 即kotlin注解处理工具)， 但给出的大多都是通过Gradle来进行配置的。因此借此机会学习了下Gradle： plugins和apply plugin: 由于文档写到了， 由于不清楚这些在哪些位置加入， 因此查看了plugins和apply plugin:的区别： 1234567891011&gt; 添加 kapt 插件&gt; apply plugin: &apos;kotlin-kapt&apos;&gt; &gt; 然后在项目中添加如下依赖：&gt; api(&quot;com.github.pozo:mapstruct-kotlin:1.3.1.2&quot;)&gt; kapt(&quot;com.github.pozo:mapstruct-kotlin-processor:1.3.1.2&quot;)&gt; &gt; 另外，还需要添加如下依赖：&gt; api(&quot;org.mapstruct:mapstruct:1.4.0.Beta3&quot;)&gt; kapt(&quot;org.mapstruct:mapstruct-processor:1.4.0.Beta3&quot;)&gt; “plugins {}”块导入的是Gradle官方插件仓库里的插件。如果使用“buildscript {}”块指定第三方库作为Gradle插件的话，指定插件就需要使用“apply plugin”了。 刚刚翻了翻文档，“apply plugin”本身似乎还有更多的用途，而“plugins {}”块似乎是一个新引入的还不足够稳定的特性。题主想要知道更多的话直接看看文档就行了。 最终的Plain项目的依赖如下所示： 12345678910111213141516171819202122232425262728plugins &#123; id 'java' id 'org.jetbrains.kotlin.jvm' version '1.4.10'&#125;group 'org.example'version '1.0-SNAPSHOT'repositories &#123; mavenCentral()&#125;apply plugin: 'kotlin-kapt'dependencies &#123; implementation \"org.jetbrains.kotlin:kotlin-stdlib\" testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.0' testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine' api(\"com.github.pozo:mapstruct-kotlin:1.3.1.2\") kapt(\"com.github.pozo:mapstruct-kotlin-processor:1.3.1.2\") api(\"org.mapstruct:mapstruct:1.4.0.Beta3\") kapt(\"org.mapstruct:mapstruct-processor:1.4.0.Beta3\")&#125;test &#123; useJUnitPlatform()&#125; maven使用kapt 在 kotlin-maven-plugin 中的在compile 之前添加 kapt 目标的执行： 1234567891011121314151617181920&lt;execution&gt; &lt;id&gt;kapt&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;kapt&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirs&gt; &lt;sourceDir&gt;src/main/kotlin&lt;/sourceDir&gt; &lt;sourceDir&gt;src/main/java&lt;/sourceDir&gt; &lt;/sourceDirs&gt; &lt;annotationProcessorPaths&gt; &lt;!-- 在此处指定你的注解处理器。 --&gt; &lt;annotationProcessorPath&gt; &lt;groupId&gt;com.google.dagger&lt;/groupId&gt; &lt;artifactId&gt;dagger-compiler&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;/annotationProcessorPath&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt;&lt;/execution&gt; 请注意，IntelliJ IDEA 自身的构建系统目前还不支持 kapt。当你想要重新运行注解处理时，请从“Maven Projects”工具栏启动构建。 from: https://www.kancloud.cn/alex_wsc/android_kotlin/1318386#_Maven__110 各种依赖方式说明 implementation 这个指令的特点就是，对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，也就是将该依赖隐藏在内部，而不对外部公开。 api 完全等同于compile指令。 compile 这种是我们最常用的方式，使用该方式依赖的库将会参与编译和打包。 testCompile testCompile 只在单元测试代码的编译以及最终打包测试apk时有效。 debugCompile debugCompile 只在debug模式的编译和最终的debug apk打包时有效。 releaseCompile releaseCompile 仅仅针对Release模式的编译和最终的Release apk打包。这里比如 gradle中api、implementation和compile的区别 我们在gradle中引用第三方maven库时，一般通过下面的语句去引用:compile 'com.android.support:appcompat-v7:26.1.0' , 然后sync project，就能成功引用对应的包到项目之中了，十分方便。除了使用compile关键字，使用implementation和api也能将包引用到项目中 api和compile关键字作用效果是一样的，使用时可以互相替换。实际上，api关键字是用来替代compile关键字的，因为compile关键字将来会被弃用。在高版本的gradle，使用compile关键字会报错并提示使用api关键字代替。 Q：看起来这三个关键字的作用是一样的，那么，他们到底有什么区别呢？ A：在同一个module下，implementation和compile的使用效果相同，但是在不同module下，就会有所区别了。 api或compile关键字引用的包对于其他module来说是可见的，而implementation关键字引用的包对于其他module来说是不可见的。 Maven仓库列表 仓库名 简介 实际地址 使用地址 jcenter JFrog公司提供的仓库 http://jcenter.bintray.com https://maven.aliyun.com/repository/jcenter https://maven.aliyun.com/nexus/content/repositories/jcenter mavenLocal 本台电脑上的仓库 {USER_HOME}/.m2/repository C:/Users/liyujiang/.m2/repository (Windows) /home/liyujiang/.m2/repository (Linux) mavenCentral Sonatype公司提供的中央库 http://central.maven.org/maven2 https://maven.aliyun.com/repository/central https://maven.aliyun.com/nexus/content/repositories/central google Google公司提供的仓库 https://maven.google.com https://maven.aliyun.com/repository/google https://maven.aliyun.com/nexus/content/repositories/google https://dl.google.com/dl/android/maven2 jitpack JitPack提供的仓库 https://jitpack.io https://jitpack.io public jcenter和mavenCentral的聚合仓库 https://maven.aliyun.com/repository/public https://maven.aliyun.com/nexus/content/groups/public gradle-plugin Gradle插件仓库 https://plugins.gradle.org/m2 https://maven.aliyun.com/repository/gradle-plugin https://maven.aliyun.com/nexus/content/repositories/gradle-plugin 12345repositories &#123; maven&#123; url &apos;https://maven.aliyun.com/nexus/content/groups/public/&apos;&#125; maven&#123; url &apos;https://maven.aliyun.com/nexus/content/repositories/jcenter&apos;&#125; mavenCentral()&#125; gradle全局换源 在C:\\Users\\mrli\\.gradle文件夹下修改init.gradle文件（如果没有则新建），写下如下内容: 12345678910111213141516171819202122232425262728293031323334allprojects&#123; repositories &#123; def ALIYUN_REPOSITORY_URL = 'https://maven.aliyun.com/repository/public/' def ALIYUN_JCENTER_URL = 'https://maven.aliyun.com/repository/jcenter/' def ALIYUN_GOOGLE_URL = 'https://maven.aliyun.com/repository/google/' def ALIYUN_GRADLE_PLUGIN_URL = 'https://maven.aliyun.com/repository/gradle-plugin/' all &#123; ArtifactRepository repo -&gt; if(repo instanceof MavenArtifactRepository)&#123; def url = repo.url.toString() if (url.startsWith('https://repo1.maven.org/maven2/')) &#123; project.logger.lifecycle \"Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.\" remove repo &#125; if (url.startsWith('https://jcenter.bintray.com/')) &#123; project.logger.lifecycle \"Repository $&#123;repo.url&#125; replaced by $ALIYUN_JCENTER_URL.\" remove repo &#125; if (url.startsWith('https://dl.google.com/dl/android/maven2/')) &#123; project.logger.lifecycle \"Repository $&#123;repo.url&#125; replaced by $ALIYUN_GOOGLE_URL.\" remove repo &#125; if (url.startsWith('https://plugins.gradle.org/m2/')) &#123; project.logger.lifecycle \"Repository $&#123;repo.url&#125; replaced by $ALIYUN_GRADLE_PLUGIN_URL.\" remove repo &#125; &#125; &#125; maven &#123; url ALIYUN_REPOSITORY_URL &#125; maven &#123; url ALIYUN_JCENTER_URL &#125; maven &#123; url ALIYUN_GOOGLE_URL &#125; maven &#123; url ALIYUN_GRADLE_PLUGIN_URL &#125; &#125;&#125; 注意：阿里源的URL使用https而不是http，否则会出现以下报错:Gradle报错Could not resolve all dependencies for configuration ‘:detachedConfiguration7‘. 参考： https://blog.csdn.net/qq_41053520/article/details/118244668 https://www.cnblogs.com/huiyi0521/p/10997152.html——gradle中执行函数 https://blog.csdn.net/qq32933432/article/details/108906687——work buildscript buildscript中的声明是gradle脚本自身需要使用的资源 123456789101112131415161718192021222324252627apply plugin: &apos;java&apos; // java项目apply plugin: &apos;eclipse&apos; // eclipse开发环境构建，生成所需要的.project,.classpath等文件apply plugin: &apos;org.springframework.boot&apos;jar &#123; baseName = &apos;shop-supplier&apos; version = &apos;1.0.0-SNAPSHOT&apos;&#125;version = &apos;1.0.0-SNAPSHOT&apos;sourceCompatibility = 1.8targetCompatibility = 1.8repositories &#123; // maven仓库地址 maven&#123;url &apos;私服地址&apos;&#125; mavenCentral()&#125;dependencies &#123; // 依赖项 // web thymeleaf compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;) compile(&apos;org.springframework.boot:spring-boot-starter-thymeleaf&apos;) // test testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;) //添加 google二维码 compile &apos;com.google.zxing:core:3.2.0&apos;&#125; gradle 工程使用mybatis 正常情况下是在src/main/java/**/xxx.xml 文件是不会被打包的，需要我们队gradle做一些特别的配置 ①，build.gradle 1sourceSets.main.resources.srcDirs = [\"src/main/java\",\"src/main/resources\"] ②，指定mapper.xml 文件所在路径，这里我用的是mp 1mybatis-plus.mapper-locations=com/mp/test/mapper/xml/*Mapper.xml ③，指定mapper接口所在路径 1@MapperScan(\"com.mp.test.mapper\") gradle中使用docker","categories":[],"tags":[]},{"title":"ZJU云原生技术及应用-课程笔记","slug":"ZJU云原生技术及应用-课程笔记","date":"2021-09-25T14:48:36.000Z","updated":"2022-03-15T15:00:13.802Z","comments":true,"path":"2021/09/25/ZJU云原生技术及应用-课程笔记/","link":"","permalink":"https://nymrli.top/2021/09/25/ZJU云原生技术及应用-课程笔记/","excerpt":"","text":"ZJU要求 课程内容 云计算基本概念和Docker容器原理（4课时） Kubernetes核心原理与关键组件 （8课时） 微服务技术原理与治理 （4课时） 容器监控与分析 （4课时） 云原生边缘计算技术（4课时） IBM讲座-混合云架构（4课时） 云原生应用实践与案例分析（4课时） 考核方式 平时（20%）+ 课程设计（80%，含报告） 课程设计（三选一） 云原生技术研究报告或综述 围绕云原生关键技术点，如容器安全、多集群管理、云边协同和边缘智能等，综述当前技术现状并进行必要的分析 源代码分析报告 分析Kubernetes或者KubeEdge等云原生项目相关源代码，撰写代码分析报告（行级代码标注+工作流分析），不少于10页，原创。 开源贡献 修改Kubernetes/KubeEdge/Docker提交PR，根据代码行数折算（100行源代码或者5个commit） 未能通过社区审核，通过测试验证的代码可以作为参考评分 云原生 Docker技术原理与实践 Docker是Docker公司开源的一个基于轻量级虚拟化技术的容器引擎项目,整个项目基于Go语言开发，并遵从Apache 2.0协议 目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术 (namespaces及cgroups等)来提供容器的资源隔离与安全保障等。 由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，不需要类 似虚拟机(VM)额外的操作系统开销，提高资源利用率，并且提升诸如IO等方面的性能。 docker本质就是进程？ A: 理解这句话得具备linux的基础知识，从基础知识角度来进行理解。首先docker的两大关键技术是Namespace和cgroup：Namespace技术改变了容器的视图，让容器以为自己在一个房间里，起到了隔离作用；cgroup(Linux Control Group)起到对容器资源的限制作用 namespace和cgroup共同为创造了一个容器沙盒。 ==&gt;容器是个进程，通过namespace作为障眼法进行屏蔽，结合cgroup进行资源限制，并以容器镜像的方式打包的一个沙盒 Docker应用场景 web应用的自动化打包和发布 自动化测试和持续集成、 发布 在服务型环境中部署和调整数据库或其他的后台应用 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 Docker优势 更低的资源损耗 更快的启动速度 更好的应用耦合 更强的弹性伸缩 Docker架构 基本要素 Docker Images是一个只读模板，用来运行Docker容器 Docker Containers负责应用程序的运行，包括操作系统、用户添加的文件以及元数据。 DockerFile是文件指令集，用来说明如何自动创建Docker镜像。 核心组件 容器和镜像的关系 好比静态的源码和运行时的程序，使用执行源码即可得到想要功能的程序，同样的依据镜像从而能够构建通过镜像制定的容器。 镜像特点： layer： 分层 读写层 init层 只读层 based on another image ： 基于其他镜像 a read-only template：是只读的模板 copy-on-write： 下层只读，上层可写 union filesystem：有独立的文件系统 DockerFile or docker commit：通过dockerfile或者docker commit生成 数据卷： ▲当一个容器被删除时，任何写入该容器的、没有存储在数据卷中的数据都会和该容器一起被删除。==&gt;因此需要个可以独立于容器存储的外存。 数据卷不受存储驱动器的控制。 你可以把任何数量的数据卷装入一个容器。 多个容器也可以共享一个或多个数据卷 docker CLI docker pull过程 docker run过程 Dockerfile指令说明 FROM：初始化一个新的构建阶段，并为后续指令设置基础镜像 ENV：为你的容器安装的软件更新PATH环境变量。 RUN： 在容器构建过程中运行的命令，如apt。为了使你的Docker文件更易读、易懂、易维护，请将长的或复杂的RUN语句分成多行，用反斜线分开 COPY and ADD: 复制文件到指定路径，ADD相比之下多个类似tar解压的功能 EXPOSE： 容器将监听连接的端口 WORKDIR： 指定工作目录，并以绝对路径的形式给出 CMD：容器构建完成后执行命令，主要目的是为执行中的容器提供默认值。这些默认值可以包括一个可执行文件，也可以省略可执行文件，在这种情况下，你必须同时指定一个ENTRYPOINT指令。一个Docker文件中只能有一条CMD指令。如果有多个CMD，那么只有最后一个CMD才会生效。 ENTRYPOINT：允许你配置一个将作为可执行文件运行的容器。 docker run &lt;image&gt;的命令行参数将被附加在exec形式的ENTRYPOINT的所有元素之后，并将覆盖所有使用CMD指定的元素。这允许将参数传递给入口点，例如，docker run -d将把-d参数传递给入口点。你可以使用docker run --entrypoint标志来覆盖ENTRYPOINT指令。 只有Docker文件中的最后一条ENTRYPOINT指令才会有效果。 Q:如何使得镜像轻量？ A:从一个合适的基础镜像开始；使用多阶段构建；如果你有多个有很多共同点的镜像，考虑用共享的组件创建你自己的基础镜像，并在此基础上创建你的独特镜像；为了保持你的生产图像的精简，但允许调试，考虑使用生产图像作为调试图像的基础图像；当建立图像时，总是用有用的tags来标记它们 云计算技术基本原理 Kubernetes核心原理与关键组件 云计算定义：云计算是一种动态扩展的计算模式，通过网络将虚拟化的资源作为服务提供 云架构图 Cloud Foundry云平台 Cloud Foundry是VMware于推出的业界第一个开源PaaS云平台，专为私有云计算环境、企业级数据中心和公有云服务提供商所打造，可以简化现代应用程序的开发、交付和运行过程，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题。 Router Router是整个平台的流量入口，负责分发所有的请求到对应的组件，包括来自外部用户对app的请求和平台内部的管理请求。 Router是PaaS平台中至关重要的一个组件，它在内存中维护了一张路由表，记录了域名与实例的对应关系，所谓的实例自动迁移，靠得就是这张路由表，某实例宕掉了，就从路由表中剔除，新实例创建了，就加入路由表。 状态服务 无状态服务在容器化的世界里很受欢迎，因为它们是一次性的，而且很容易用容器镜像重新创建。 除了像Web服务器这样的无状态服务，用户越来越多地使用容器来部署有状态服务，以受益于 “一次构建，随地运行”，并提高裸机效率/利用率。 这些 &quot;宠物 &quot;（需要满足的需求）带来了新的要求，包括更长的生命周期、配置依赖性和有状态的故障转移。容器编排必须解决这些需求，以成功部署和扩展应用程序。 K8s命令 K8s设计原则 声明式 状态驱动 用户通过声明式的配置文件（例如 YAML 文件）向 Kubernetes 告白自己希望达到的系统状态（例如：运行拥有 5 个副本的 nginx 服务）。 行动（React） Kubernetes 的控制组件负责具体执行这些指令，使得用户声明的系统状态得以实现；在此过程中不需要任何人工的参与。 观测（Observe）： Kubernetes会观测到新的用户声明，并自动分析出需要执行的操作以达到用户声明的系统状态（例如在集群中选取5个合适的节点，并在这 5 个节点上下载合适的 nginx 镜像并启动容器，以及配置相应的负载均衡策略等）。 K8s架构 Kubernetes主要组件有：API Server、Controller Manager、Scheduler、kubelet、kube-proxy，其中前三者运行于集群的Master节点，后两者运行于集群的Worker节点。 Master 集群控制节点，负责集群管理与控制，通常运行在独立物理节点或者虚拟机 运行各类关键进程 API Server （kube-apiserver）：提供REST接口的关键服务进程 集群管理的API入口 资源配额控制的入口 提供了完备的集群安全机制 Controller Manager（kube-controller-manager)：所有资源的自动化控制中心 ResourceQuota Controller Namespace Controller Endpoints Controller Scheduler（Kube-scheduler）：负责Pod资源调度 Etcd Server：所有资源对象的数据全部保存在etcd中 Node Kubernetes集群中除Master外的节点，又叫Minion，同样可以是物理主机或者虚拟机 作为集群中的工作负载节点，承担Master分配的工作负载 Node可以动态增减，新增node会自动到master节点注册 Node运行的进程： kubelet：pod启停及与master节点协作 Ø节点管理 ØPod管理 Ø容器健康检查 Ø资源监控 kube-proxy：实现Kubenetes Service通信与负载均衡机制 Docker Engine：负责本机容器的创建和管理工作 Pod： Pod是一组紧密关联的容器集合，是Kubernetes 调度的基本单位，不可分割。 一个Pod里的多个容器可以共享存储和网络，可以看作一个逻辑的主机。共享的如 namespace,cgroups或者其他的隔离资源。 创建Pod时的大概流程： 1：kubectl 向K8s API发送一个REST HTTP请求 2：调度器将其调度到一个工作节点上 3：被调度的工作节点上的kubelet会告知Node节点上的Docker engine拉取镜像，下载后运行容器。 创建pod 创建Pod可以使用两种方式，一种是通过命令行加各种命令行参数的方式，另一种是文件方式创建（推荐） 通过命令行直接创建: kubectl run ${name} --image=${imageName} --port=${port} (实际是运行了一个deployment，让deployment自动创建并维护pod) 通过yml文件创建， 文件可以为yml或者json: kubectl apply -f ${fiileName} 删除Pods 1234567891011121314151617181920212223242526272829303132333435363738394041Examples: # Delete a pod using the type and name specified in pod.json. kubectl delete -f ./pod.json # Delete resources from a directory containing kustomization.yaml - e.g. dir/kustomization.yaml. kubectl delete -k dir # Delete a pod based on the type and name in the JSON passed into stdin. cat pod.json | kubectl delete -f - # Delete pods and services with same names &quot;baz&quot; and &quot;foo&quot; kubectl delete pod,service baz foo # Delete pods and services with label name=myLabel. kubectl delete pods,services -l name=myLabel # Delete a pod with minimal delay kubectl delete pod foo --now # Force delete a pod on a dead node kubectl delete pod foo --grace-period=0 --force # Delete all pods kubectl delete pods --allOptions: --all=false: Delete all resources, including uninitialized ones, in the namespace of the specified resource types. -A, --all-namespaces=false: If present, list the requested object(s) across all namespaces. Namespace in current context is ignored even if specified with --namespace. --cascade=true: If true, cascade the deletion of the resources managed by this resource (e.g. Pods created by a ReplicationController). Default true. --field-selector=&apos;&apos;: Selector (field query) to filter on, supports &apos;=&apos;, &apos;==&apos;, and &apos;!=&apos;.(e.g. --field-selector key1=value1,key2=value2). The server only supports a limited number of field queries per type. -f, --filename=[]: containing the resource to delete. --force=false: Only used when grace-period=0. If true, immediately remove resources from API and bypass graceful deletion. Note that immediate deletion of some resources may result in inconsistency or data loss and requires confirmation. --grace-period=-1: Period of time in seconds given to the resource to terminate gracefully. Ignored if negative. Set to 1 for immediate shutdown. Can only be set to 0 when --force is true (force deletion). --ignore-not-found=false: Treat &quot;resource not found&quot; as a successful delete. Defaults to &quot;true&quot; when --all is specified. -k, --kustomize=&apos;&apos;: Process a kustomization directory. This flag can&apos;t be used together with -f or -R. --now=false: If true, resources are signaled for immediate shutdown (same as --grace-period=1). -o, --output=&apos;&apos;: Output mode. Use &quot;-o name&quot; for shorter output (resource/name). -R, --recursive=false: Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory. -l, --selector=&apos;&apos;: Selector (label query) to filter on, not including uninitialized ones. --timeout=0s: The length of time to wait before giving up on a delete, zero means determine a timeout from the size of the object --wait=true: If true, wait for resources to be gone before returning. This waits for finalizers. Pod API 对象的基本构成及书写格式 Pod各生命周期说明 Pending：挂起，Pod已被Kubernetes系统接受，但有一个或者多个容器镜像尚未创建。 等待时间包括Pod被调度的时间和通过网络下载镜像的时间 Running：运行中，该Pod已经绑定到了一个节点上，Pod中所有的容器都已被创建。至 少有一个容器正在运行，或者正处于启动或重启状态 Succeeded：Pod中的所有容器都被成功终止 Failed：失败，Pod中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也 就是说，容器以非0状态退出或者被系统终止 Unknown：因为某些原因无法取得Pod的状态，通常是因为与Pod所在主机通信失败 CrashLoopBackoff：Pod循环重启崩溃，通常是容器中的应用崩溃造成 pod配置 ImagePullPolicy Always：不管镜像是否存在都会进行一次拉取 Never：不管镜像是否存在都不会进行拉取 IfNotPresent：只有镜像不存在时，才会进行镜像拉取 RestartPolicy 在Pod中的容器可能会由于异常等原因导致其终止退出，Kubernetes提供了重 启策略以重启容器。重启策略对同一个Pod的所有容器起作用，容器的重启由 Node上的kubelet执行。 Always：只要退出就重启 OnFailure：失败退出（exit code不等于0）时重启 Never：只要退出就不再重启 注意，这里的重启是指在Pod所在Node上面本地重启，并不会调度到其他Node上去。 resources 123456789101112131415apiVersion: v1kind: Podmetadata: name: tomcatspec: containers: - name: tomcat image: tomcat:8.2.59 resources: requests: memory: \"500Mi\" cpu: \"500m\" limits: memory: \"1G\" cpu: \"1\" 健康检查 为了确保容器在部署后确实处在正常运行状态，Kubernetes提供了两种探针（Probe）探测状态： LivenessProbe：探测应用是否处于健康状态，如果不健康则删除并重启容器 ReadinessProbe：探测应用是否启动完成并且处于正常服务状态，如果不正常则不会接收来自Kubernetes Service的流量 Kubernetes支持三种方式来执行探针： exec：在容器中执行一个命令，如果命令退出码返回0则表示探测成功，否则表示失败 tcpSocket：对指定的容器IP及端口执行一个TCP检查，如果端口是开放的则表示探测成功，否则表示失败 httpGet：对指定的容器IP、端口及路径执行一个HTTP Get请求，如果返回的状态码在[200,400)之间则表示探 测成功，否则表示失败 123456789livenessProbe: httpGet: path: / port: 8080 httpHeaders: - name: X-Custom-Header value: Awesome initialDelaySeconds: 3 periodSeconds: 3 Probe的精确配置: initialDelaySeconds：容器启动后第一次执行探测是需要等待多少秒 periodSeconds：执行探测的频率。默认是10秒，最小1秒 timeoutSeconds：探测超时时间。默认1秒，最小1秒 successThreshold：探测失败后，最少连续探测成功多少次才被认定为成功。默认是1 对于liveness必须是1，最小值是1 failureThreshold：探测成功后，最少连续探测失败多少次才被认定为失败。默认是3 最小值是1 Label和Label Selector Label 定义label： kubectl label ${sourceType} ${name} key=value 查看label： kubectl get ${type} --show-labels 删除label： kubectl label ${type} ${name} key- Labels Selector： 通过标签选择器（Labels Selectors），进行查询和筛选拥有特定Label的资源对象 目前支持两种选择器：equality-based（基于平等）和set-based（基于集合）的 Equality-based：基于相等的或者不相等的条件允许用标签的keys和values进行过滤。匹配 的对象必须满足所有指定的标签约束，尽管他们可能也有额外的标签。有三种运算符是允 许的，“=”，“==”和“!=”。前两种代表相等性（他们是同义运算符），后一种代表 非相等性，多个可用逗号隔开如，非生产nginx：environment!=production,app=nginx Set-based：用一组value来过滤key。支持三种操作符: In ，NotIn，Exists，DoesNotExists， 前两个value不能为空，后两个仅针对于key，没有value labels，selector操作 Controller controller manager 是各种controller的管理者,是集群内部的管理控制中心。 在K8S 拥有很多controller 他们的职责是保证集群中各种资源的状态和用户定义(yaml)的状态一致, 确保任何时候都在运行指定数量的Pod副本。 换句话说,Controller确保一个容器或一组相同的容器始终处于可用状态。 ReplicationController ReplicaSet Deployments DaemonSet StatefulSets Deployment Deployment面向的是部署无状态应用， statefulset : 部署有状态应用 Deployment的典型应用场景 定义Deployment来创建Pod和ReplicaSet 滚动升级和回滚应用 `•kubectl rollout undo deployment/nginx-deployment •deployment “nginx-deployment” rolled back` 扩容和缩容 暂停和继续 Kubernetes上有状态服务 Volume Persistent Volume demo：创建包含3个nginx应用pod的deployment 12345678910111213141516apiVersion: extensions/v1beta1 kind: Deploymentmetadata: name: nginx-deploymentspec: replicas: 3 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 您可以决定运行 Pod，但当它们死去时，它们就会死去。 部署将使您的 pod 能够连续运行。 部署允许您在不停机的情况下更新正在运行的应用程序。 部署还指定了在 Pod 死亡时重启 Pod 的策略 replicaSets Deployment 还可以创建 ReplicaSet ReplicaSet 可确保您的应用拥有所需数量的 Pod ReplicaSets 将基于 Deployment 创建和扩展 Pods Deployments、ReplicaSets、Pods 不是独占的，但可以是 deamonSets DaemonSets 用于连续进程 他们每个节点运行一个 Pod。 每个添加到集群的新节点都会启动一个 pod 用于监控和日志收集等后台任务 StatefulSets 您的应用程序是否要求您保留有关其状态的信息？ 数据库需要状态 StatefulSet 的 Pod 不可互换。 每个 Pod 都有一个唯一的、持久的标识符，控制器在任何重新调度时都会维护该标识符。 Service详解： Kubernetes中最核心的资源对象之一，Pod、RC等其实都是Service Service是对一组提供相同功能的Pods的抽象，并为它们提供一个统一的入口，简单来说，可以把service理解为一个负载均衡器。借助Service，应用可以方便的实现 服务发现与负载均衡，并实现应用的稳定升级。Service通过标签来选取服务后端，一般配合Replication Controller或者Deployment来保证后端容器的正常运行。这些匹配标签的Pod IP和端口列表组成endpoints，由 kube-proxy负责将服务IP负载均衡到这些endpoints上。 它定义了一组Pod的逻辑集合和一个用于访问它们的策略，其实这个概念和微服务非常类似。一个Serivce下面包含的Pod集合一般是由Label Selector来决定的。 Service默认有自己的ip和端口的叫cluster-ip和port构成了endpoint，内部可以直接通过这个endpoint去访问应用。 不过有一点需要注意，这个cluster-ip是个Virtual IP，它是ping不通的，底层转发是通过node节点上的kube-proxy调用iptables生成对应的转发规则。 ClusterIP：默认类型，自动分配一个仅cluster内部可以访问的虚拟IP NodePort：在ClusterIP基础上为Service在每台机器上绑定一个端口，这样就可以通过&lt;NodeIP&gt;:NodePort来 访问该服务 LoadBalancer：在NodePort的基础上，借助cloud provider创建一个外部的负载均衡器，并将请求转发到 Service有四种类型： ClusterIP NodePort LoadBalancer ExternalName Service定义 Service的定义也是通过yaml或json，比 如下面定义了一个名为nginx的服务， 将 服 务 的 80 端 口 转 发 到 default namespace中带有标签run=nginx的Pod 的80端口 12345678910111213141516apiVersion: v1 kind: Service metadata: labels: run: nginx name: nginx namespace: default spec: ports: - port: 80 # k8s 集群内部访问service端口， 通过cluster_ip:port 请求某个service protocol: TCP targetPort: 80 selector: run: nginx sessionAffinity: None type: ClusterIP Q: 如何访问服务? 每个Pod都提供独立的EndPoint（Pod IP + Container Port），访问请求如何映射到具体的Pod？ A: 开启负载均衡器kube-proxy，客户端通过负载均衡器调度到相应的pod，每个Service分配一个全局唯一的虚拟IP地址（Cluster IP），Pod的Endpoint地址会随着pod的销毁和创新创建而改变，但是cluster ip在Service生命周期内不会改变，因此用servcie name和cluster ip作为DNS域名，就可以解决服务访问问题 外部系统访问Service: Node IP： 节点IP地址，真实网络网卡的IP Pod IP：Pod的IP地址，根据docker0网桥的IP段进行分配，虚拟二层网络，实现Pod之间的通信 Cluster IP: Service IP地址 仅服务Kubernetes Service对象 没有对应的实体网络，无法直接ping通 只能结合Service Port组成具体通信端口，集群之外无法访问 集群内可以使用内部路由规则进行通信，如何在外部访问？NodePort IP和Port 见： https://zhuanlan.zhihu.com/p/358916098 各port之间的区别： port：k8s集群内部服务之间访问service的入口（ClusterIP:Port） targetPort：容器应用运行端口（最终的流量端口），如nginx是80、mysql是3306 nodePort：外部流量访问k8s集群中service入口的一种方式(NodeIP:NodePort) 如何将服务暴露给外部客户端？ 将服务的类型设置成NodePort 每个集群节点都会在节点上打开一个端口，对于NodePort服务，每个集群节点在节点本身上打开一个端口，并将在该端口上接收到的流量重定向到基础服务。所以该服务仅在内部集群IP 和端口上才可访问 123456789101112apiVersion: v1 kind: Servicemetadata: name: my-servicespec: type: NodePort #为NodePort设置服务类型 ports: - port: 80 # k8s 集群内部访问service端口[服务集群IP (service cluster IP)的端口号]， 通过clusterip:port 请求某个service targetPort: 8080 # 背后Pod的目标端口号 nodePort: 30123 # 通过集群节点的30123端口可以访问该服务 selector: app: nginx 保存好yaml文件可用通过以下命令创建并且查看目标服务, $ kubectl apply –f service.yaml, $ kubectl get svc my-service PORT(S)列显示集群IP (80) 的内部端口和节点端口(30123) 可以通过以下地址访问该服务：10.11.254.223:80 服务暴露在两个集群节点的端口30123上，它到达任何一个端口的传入连接将都被重定向到一个随机选择的pod, 该pod是否位于接收到连接的节点上是不确定的。 在第一个节点的端口30123收到的连接， 可以被重定向到第一节点个上运行的 pod, 也可能是第二个节点上运行的pod 所以在通过节点端口访间服务之前， 有时需要配置防火墙， 来允许外部连接到该端口上的节点。 将服务的类型设置成LoadBalance（负载均衡器） 负载均衡器拥有自己独一无二的可公开访问的 IP 地址， 并将所有连接重定向到服务。用户可以通过负载均衡器的 IP 地址访问服务。 如果Kubernetes在不支持Load Balancer服务的环境中运行， 则不会调配负载平衡器， 但该服务仍将表现得像一个NodePort服务。 这是因为Load Balancer服务是NodePort服务的扩展。 1234567891011apiVersion: v1 kind: Servicemetadata: name: loadbalancer-servicespec: type: LoadBalancer # 为LoadBalance设置服务类型 ports: - port: 80 # 服务集群IP的端口号 targetPort: 8080 # 背后Pod的目标端口号 selector: app: redis PORT(S)列显示集群IP (80) 的内部端口和节点端口(31698) 可以通过以下地址访问该服务：10.99.34.164:80 创建一个Ingress资源 为什么需要 Ingress ？ 一个重要的原因是每个 LoadBalancer 服务都需要自己的负载均衡器， 以及独有的公有IP 地址，而 Ingress 只需要一个公网 IP 就能为许多服务提供访问。 当客户端向 Ingress 发送 HTTP请求时，Ingress 会根据请求的主机名和路径决定请求转发到的服务。 123456789101112131415161718192021222324252627282930313233343536373839# 单规则的 IngressapiVersion: extensions/v1beta1 kind: Ingressmetadata:name: test-ingress spec: backend: # serviceName: test # 将所有的请求发送到test服务的80端口 servicePort: 80 # # 根据不同路径转发到不同服务器…spec: rules: - host: website.com http: paths: - path: /web backend: serviceName: s1 servicePort: 80 - path: /api backend: serviceName: s2 servicePort: 8081# 根据不同的主机（host) 暴露出多种服务spec: rules: - host: foo.bar.com http: paths: - backend: serviceName: s1 servicePort: 80 - host: bar.foo.com http: paths: - backend: serviceName: s2 servicePort: 80 service与deployment区别 pod： pod 是 kubernetes 中最小的编排单位，通常由一个容器组成 (有时候会有多个容器组成) service： 一个网络下的pod集合。service 使用labels标签来选择代理的pod。 Deployment：为了在 k8s 中编排应用可以更好地做弹性扩容，负载均衡，deployment 作用于一组pods的创建和运行 ▲所以service 和deployment的区别，就是一个是从网络角度的抽象概念service，类型nginx做负载均衡提供的统一网络入口。而pod是最终的应用部署实体。 deoplyment 负责创建和保持pod运行状态 service 可以独立于deployment工作，但是需要一个个去创建pod，而不是像deployment那样一次性创建。deployment也可以独立于service工作。虽然service和deployment是有区别的，但不影响他们一同协同工作 ConfigMap ConfigMap用于保存配置数据的键值对，可以用来保存单个属性，也可以用来保存配置文件。 可以使用kubectl create configmap从文件、目录或者key-value字符串创建等创建 ConfigMap。也可以通过kubectl create -f file创建。 HPA(Horizontal Pod Autoscaler) Kubernetes资源对象，支持Pod横向自动扩容 Pod负载度量指标： CPU utilizaiton — Pod CPU利用率均值 TPS or Qps 容器化改造过程 第一步：简单容器化，应用无改造—&gt;效果：自动化应用上线、升级、版本回滚、监控、报警 第二步：应用去状态—&gt; 效果：自动化故障恢复、高可用 第三步：微服务，可重用 传统单体架构缺点： 加载、编译耗时长 代码管理复杂 横向扩展难 各模块之间耦合度高 模块问题排查困难 微服务架构优点： 允许不同语言编写，易于引入新技术 微服务商店模式，快速组合与重构 模块解耦，不同的SLA保障计划 更高的扩展性和可用性 Kubernetes网络原理 Kubernetes网络设计主要考虑了几种通信场景 同一个Pod内容器间互通 同一个Node上Pod间互通 Pod1与Pod2都是通过虚拟网络设备Veth， 连接到同一个docker0 bridge的，这两个 Pod的IP地址也是通过docker0网段动态分配 的，与docker0 bridge属于同一个网段。 Pod的默认路由都是docker0 bridge的地址， 所有非本地地址的网络数据，默认都会发送 到docker0网桥上，由docker0网桥中转 Pod与docker0之间是Veth设备对连接的，而 docker0 bridge与Node的eth0是路由转发的， Docker0上默认网关就是Node的eth0 不同Node上Pod间的互通 Service与Pod之间的通信 实现方式为kube-proxy: 以暴露NodePort的Service为例，NodePort的工作原理与ClusterIP大致相同，发送到某个 NodeIP:NodePort的请求，通过iptables重定向到kube-proxy对应的端口(Node上的随机端口)上，然 后由kube-proxy再将请求发送到其中的一个Pod:TargetPort 三种proxyMode： Userspace Mode：v1.0及之前版本的默认模式 Iptables Mode：v1.1开始增加支持，v1.2正式成为默认模式 IPVS Mode：v1.8开始增加支持，v1.11正式成为默认模式 K8s集群内外组件间通信 调用K8S服务的过程 当外部client访问服务器时，首先访问服务器一致对外提供的接口，通过这一接口再将请求workload到每台主机上（每台主机上都有相对应的NodePort端口即notePort的Service来接受这一请求），每个service服务上都有一个对应的ClusterIP,通过ClusterIP和每台主机上的IPTables表以及label筛选，service就可以将请求workload到具体的每个pod上（endpoint）。 附录： Vscode环境配置 docker插件下载： k8s插件下载: icepanel Kubernetes Tools","categories":[],"tags":[{"name":"ZJU课程","slug":"ZJU课程","permalink":"https://nymrli.top/tags/ZJU课程/"},{"name":"云原生","slug":"云原生","permalink":"https://nymrli.top/tags/云原生/"}]},{"title":"docker部署springboot项目","slug":"docker部署springboot项目","date":"2021-09-21T03:34:05.000Z","updated":"2021-10-25T08:32:49.334Z","comments":true,"path":"2021/09/21/docker部署springboot项目/","link":"","permalink":"https://nymrli.top/2021/09/21/docker部署springboot项目/","excerpt":"","text":"由于最近在学云原生的课会接触到docker和k8s，因此试验了如何通过docker来部署springboot。 由于docker的实现依赖于linux内核提供的cgroups和namespace功能，而windows支持还没找到非常好的解决方案，因此在功能上windows docker还是有缺陷。我尝试过安装docker desktop for windows但是在WSL2的安装上失败了（2021年9月21日），试了二十分钟无果后放弃，决定还是在linux上构建。 服务器上搭建Java环境和docker环境 由于将docker的构建放到了服务器上，因此这部分可以理解为是构建打包环境 构建打包环境 JDK安装 1234567891011121314151617# 1. 登录网址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html， 选择对应jdk版本下载# 2. 解压, 注文件名跟下载的jdk版本有关tar -zxvf jdk-8u144-linux-x64.tar.gz#、然后将文件夹jdk1.8.0_144移动到目录/opt下sudo mv jdk1.8.0_144 /usr/local# 4、修改环境变量sudo vi ~/.bashrc# 在~/.bashrc中添加export JAVA_HOME=/usr/local/jdk1.8.0_144export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH# 5、保存并退出，使用source命令使之生效source ~/.bashrc# 6、查看安装情况java -version mvn安装 1234567891011121314151617181920212223# 1.登陆镜像源https://mirrors.bfsu.edu.cn/apache/maven/， 选择合适的mvn版本下载wget https:``//mirrors.bfsu.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz# 解压tar -zxvf apache-maven-3.6.3-bin.tar.gz# 安装sudo mv apache-maven-3.6.3 /usr/local/# 配置环境变量sudo vim /etc/profileexport M2_HOME=/usr/local/apache-maven-3.6.3export PATH=$&#123;M2_HOME&#125;/bin:$PATH# 生效环境变量， 或者source /etc/profilesource !$# 测试效果mvn -v# 换mvn源sudo vim /usr/local/apache-maven-3.6.3/conf/settings.xml# 在&lt;mirrors&gt;&lt;/mirrors&gt;中增加下列信息后保存退出&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; docker安装 镜像build 创建springboot web工程 然后创建个最基础的controller, 添加完毕后启动项目，启动成功后浏览器访问：http://localhost:8080/如果显示正常则说明springboot配置正常 springboot项目增加docker支持 pom.xml中添加 123456789101112131415161718192021222324252627282930&lt;properties&gt; &lt;docker.image.prefix&gt;springboot&lt;/docker.image.prefix&gt;&lt;/properties&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- Docker maven plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;&lt;/imageName&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- Docker maven plugin --&gt; &lt;/plugins&gt;&lt;/build&gt; 在目录src/main/docker下创建 Dockerfile 文件，Dockerfile 文件用来说明如何来构建镜像。 12345FROM openjdk:8-jdk-alpineVOLUME /tmp# 注：spring-boot-docker-1.0.jar是需要根据自己项目mvn package生成的压缩包名来写的ADD spring-boot-docker-1.0.jar app.jarENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.jar\"] 这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下: FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载 VOLUME ，VOLUME 指向了一个/tmp的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用/tmp作为工作目录。这个命令的效果是：在宿主机的/var/lib/docker目录下创建一个临时文件并把它链接到容器中的/tmp目录 ADD ，拷贝文件并且重命名 ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT 这样 Spring Boot 项目添加 Docker 依赖就完成了。 使用 Docker 部署 Spring Boot 项目 将项目 spring-boot-docker 拷贝服务器中，进入项目路径下进行打包测试。 1234567891011121314151617181920212223# 打包mvn package# 启动java -jar target/spring-boot-docker-1.0.jar# 看到 Spring Boot 的启动日志后表明环境配置没有问题，接下来我们使用 DockerFile 构建镜像。# 注： 在打包前先确保docker启动：systemctl start dockermvn package docker:build# 第一次构建可能有点慢，当看到以下内容的时候表明构建成功：...Step 1 : FROM openjdk:8-jdk-alpine ---&gt; 224765a6bdbeStep 2 : VOLUME /tmp ---&gt; Using cache ---&gt; b4e86cc8654eStep 3 : ADD spring-boot-docker-1.0.jar app.jar ---&gt; a20fe75963ab ... [INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 54.346 s[INFO] Finished at: 2018-03-13T16:20:15+08:00[INFO] Final Memory: 42M/182M[INFO] ------------------------------------------------------------------------ 使用docker images命令查看构建好的镜像： 123docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEspringboot/spring-boot-docker latest 99ce9468da74 6 seconds ago 117.5 MB springboot/spring-boot-docker 就是我们构建好的镜像，下一步就是运行该镜像 1docker run -p 8080:8080 -t springboot/spring-boot-docker 启动完成之后我们使用docker ps查看正在运行的镜像： 123docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES049570da86a9 springboot/spring-boot-docker &quot;java -Djava.security&quot; 30 seconds ago Up 27 seconds 0.0.0.0:8080-&gt;8080/tcp determined_mahavira 可以看到我们构建的容器正在在运行，访问浏览器：http://192.168.0.x:8080/,返回 1Hello Docker! 说明使用 Docker 部署 Spring Boot 项目成功！ 踩坑： 用户权限 在执行mvn package docker:build出现com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: java.io.IOException: Permission denied需要查看下docker是否安装正常，docker是否打开，当前用户是否具有执行docker命令的权限（我的个人账号mrli就没有权限，需要将其加入docker用户组，否则得加sudo） 123sudo groupadd docker #添加docker用户组sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中newgrp docker #更新用户组 参考：http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html 进阶使用Docker： nginx+springBoot+mysql+docker-compose Docker-Compose 是 Docker 的一种编排服务，是一个用于在 Docker 上定义并运行复杂应用的工具，可以让用户在集群中部署分布式应用。 前两篇文章我们介绍了 Dockerfile 的使用Docker(二)：Dockerfile 使用介绍，我们知道使用一个 Dockerfile 模板文件可以定义一个单独的应用容器，如果需要定义多个容器就需要服务编排。服务编排有很多种技术方案，今天给大家介绍 Docker 官方产品 Docker Compose 。 Dockerfile 可以让用户管理一个单独的应用容器；而 Compose 则允许用户在一个模板（YAML 格式）中定义一组相关联的应用容器（被称为一个 project，即项目），例如一个 Web 服务容器再加上后端的数据库服务容器等。 Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。 Q: Spring Boot + Nginx + Mysql 是实际工作中最常用的一个组合，最前端使用 Nginx 代理请求转发到后端 Spring Boot 内嵌的 Tomcat 服务，Mysql 负责业务中数据相关的交互，那么在没有 docker 之前，我们是如何来搞定这些环境的呢？ 1、安装 Nginx，配置 Nginx 相关信息，重启。 2、安装 Mysql ，配置字符集时区等信息，重启，最后初始化脚本。 3、启动 Spring Boot 项目，整体进行联调测试。 大家看我只写了三行，但其实搭建这些环境的时候还挺费事的，但这还不是结局，在用了一段时间时候需要迁移到另外一个环境，怎么办又需要重新搞一次？正常情况下，测试环境、SIT 环境、UAT 环境、生产环境！我们需要重复搭建四次。有人说不就是搭建四次吗？也没什么大不了的，那么我想告诉你，Too yong ,Too Simple 。 让我们看看以下几个因素： 第一，这只是一个最简单的案例，如果项目涉及到 MongoDB、Redis、ES … 一些列的环境呢？ 第二，如果你经常搭建环境或者调试程序，你就会知道什么是环境问题？有的时候明明是一模一样的配置，但是到了另外一个环境就是跑不起来。于是你花费很多时间来查找，最后才发现是少了一个参数或者逗号的问题，或者是系统内核版本不一致、或者你最后也没搞懂是为什么！只能再换另外一台服务器，那么使用 Docker 呢就可以完美的避开这些坑。 优点总结如下： 涉及多个环境的时候，一次定义到处使用 便于实现环境地快速迁移 保证多次配置的配置一次性，以及在不同机器上的配置统一性 一键化地实现多个服务的上线和下限 A: 通过docker来提供虚拟化隔离的运行环境 Docker Compose 安装 Docker Compose 是 Docker 的独立产品，因此需要安装 Docker 之后在单独安装 Docker Compose . 123456#下载sudo curl -L https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose#安装chmod +x /usr/local/bin/docker-compose#查看版本docker-compose version 同样，如果出现了直接docker-compose version无效而sudo docker-compose version有效的情况， 重启服务加上用户权限和刷新用户组后再次尝试 123456789101112#创建docker组vagrant@ubuntu18:~$ sudo groupadd docker# &gt;&gt;&gt; groupadd: group ‘docker‘ already exists#将当前用户加入docker组vagrant@ubuntu18:~$ sudo gpasswd -a $&#123;USER&#125; docker# &gt;&gt;&gt; Adding user weiyj to group docker#重启docker服务vagrant@ubuntu18:~$ sudo service docker restart#刷新docker组成员vagrant@ubuntu18:~$ newgrp docker#再试试命令^_^vagrant@ubuntu18:~$ docker-compose version 安装补全工具(可选) 为了方便我们输入命令，也可以安装 Docker 的补全提示工具帮忙我们快速输入命令 12345#安装yum install bash-completion#下载docker-compose脚本curl -L https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 工程搭建 项目结构 1234567891011121314151617181920212223242526272829303132333435363738394041.├── app│ ├── HELP.md│ ├── mvnw│ ├── mvnw.cmd│ ├── pom.xml│ ├── src│ │ ├── main│ │ │ ├── docker│ │ │ │ └── Dockerfile│ │ │ ├── java│ │ │ │ └── top│ │ │ │ └── nymrli│ │ │ │ └── testdocker│ │ │ │ ├── controller│ │ │ │ │ ├── HelloController.java│ │ │ │ │ └── VisitorController.java│ │ │ │ ├── model│ │ │ │ │ └── Visitor.java│ │ │ │ ├── repository│ │ │ │ │ └── VisitorRepository.java│ │ │ │ └── TestdockerApplication.java│ │ │ └── resources│ │ │ ├── application-dev.properties│ │ │ ├── application-docker.properties│ │ │ ├── application.properties│ │ │ ├── application-test.properties│ │ │ ├── static│ │ │ ├── templates│ │ │ └── visiitor.sql│ │ └── test│ │ └── java│ │ └── top│ │ └── nymrli│ │ └── testdocker│ │ └── TestdockerApplicationTests.java│ └── testdocker.iml├── docker-compose.yml└── nginx └── conf.d └── app.conf 其中最核心的几个配置文件： docker-compose.yaml：docker-compose 的核心文件，描述如何构建整个服务 nginx：有关 nginx 的配置 app：Spring Boot 项目地址 Dockerfile：app中的dockerfile镜像构建文件 如果我们需要对 Mysql 有特殊的定制，也可以在最外层创建 mysql 文件夹，在此目录下进行配置。 Nginx 文件解读 nginx 在目录下有一个文件 app.conf，主要配置了服务转发信息 123456789101112131415161718192021server &#123; listen 80; # 侦听80端口 charset utf-8; access_log off; location / &#123; proxy_pass http://app:8080; # 将80端口的http请求转发到服务 app 的8080端口处理 # ▲注：这里使用是app而不是localhost，是因为他们没有在一个容器中，在一组 compose 的服务通讯需要使用 services 的名称进行访问。 proxy_set_header Host $host:$server_port; proxy_set_header X-Forwarded-Host $server_name; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; # 静态文件处理 location /static &#123; access_log off; expires 30d; alias /app/static; &#125;&#125; Dockerfile配置 1FROM maven:3.5-jdk-8 application-docker.properties 12345spring.datasource.url=jdbc:mysql://mysql:3306/test# 注：数据库的连接信息由jdbc:mysql://localhost:3306/test改为jdbc:mysql://mysql:3306/test, 原因跟nginx配置一样, URI在docker-compose中需要通过services通信spring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driver docker-compose.yml 12345678910111213141516171819202122232425262728293031323334353637version: '3' # 表示使用第三代语法来构建 docker-compose.yaml 文件。services: # 用来表示 compose 需要启动的服务，我们可以看出此文件中有三个服务分别为：nginx、mysql、app。 nginx: container_name: v-nginx # 容器名称 image: nginx:1.13 restart: always ports: - 8088:80 - 443:443 volumes: - ./nginx/conf.d:/etc/nginx/conf.d mysql: container_name: v-mysql image: mysql/mysql-server:5.7 environment: # 此节点下的信息会当作环境变量传入容器，此示例中 mysql 服务配置了数据库、密码和权限信息。 MYSQL_DATABASE: test MYSQL_ROOT_PASSWORD: root MYSQL_ROOT_HOST: '%' ports: # 表示对外开放的端口 - \"3306:3306\" restart: always # 表示如果服务启动不成功会一直尝试。 app: restart: always build: ./app/src/main/docker # 基于Dockerfile，指定Dockerfile所在路径,Compose会利用它自动构建镜像，然后启动服务容器 working_dir: /app volumes: # 加载本地目录下的配置文件到容器目标地址下 - ./app:/app - ~/.m2:/root/.m2 expose: - \"8080\" depends_on: # 可以配置依赖服务，表示需要先启动 depends_on 下面的服务后，再启动本服务。 - nginx - mysql command: mvn clean spring-boot:run -Dspring-boot.run.profiles=docker # 表示以这个命令来启动项目，-Dspring-boot.run.profiles=docker表示使用 application-docker.properties文件配置信息进行启动。 注： 由于服务器的80端口跑的是裸机运行的web程序，因此无法用nginx侦听80端口，因此在compose.yml中nginx的port映射写的是8088，这个是web应用真正想要输出的web端口（注意需要在阿里云上打开该端口的防火墙），而8088映射到容器的80端口后又会由nginx.conf转发到8080端口即真正的web app的运行端口上。 VisitorController.java 123456789101112131415161718192021222324package top.nymrli.testdocker.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import top.nymrli.testdocker.model.Visitor;import top.nymrli.testdocker.repository.VisitorRepository;@RestControllerpublic class VisitorController &#123; @Autowired private VisitorRepository repository; @RequestMapping(\"/hello\") public String say() &#123; return \"Hello\"; &#125; @RequestMapping(\"/get\") public Long get() &#123; Visitor visitor = repository.findByIp(\"192.184.4.4\"); return visitor.getTimes(); &#125;&#125; 其中数据库mysql镜像虽然创建连接好了，但是库和表都没有创建，docker-compose ps可以看见通过docker-compose创建的容器，但是compose本身除了提供服务编排的统一启动和停止外，并没有提供对单一容器的管理，因此需要通过docker进行单独管理，如docker exec -it b07acb7f4e6d /bin/bash进行容器，mysql -u root -p root进行创表 visitor.sql 123456789create DATABASE if not EXISTS `test`;use `test`;CREATE table if not EXISTS `visitor` ( `id` bigint(20) not null COMMENT \"主键\", `times` bigint(10) not null COMMENT \"访问次数\", `ip` varchar(32) not null COMMENT \"ip地址\", PRIMARY KEY (`id`))ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC; ;INSERT INTO `visitor` VALUES(1, 1, \"192.168.0.1\"); 配置完成后， docker-compose up即可启动，登陆服务器IP:nginx端口即可访问web应用。 参考：http://www.ityouknow.com/springboot/2018/03/28/dockercompose-springboot-mysql-nginx.html 代码：https://github.com/ityouknow/spring-boot-examples/tree/master/dockercompose-springboot-mysql-nginx 附录： SpringBoot打包 转载： SpringBoot简单打包部署(附工程) 首先需要明确的是，该项目打包的形态是可执行的jar包，还是在tomcat下运行的war包。 Maven打包 如果是jar包 需在pom.xml指定打成的包为： 1&lt;packaging&gt;jar&lt;/packaging&gt; 如果是war包。 需在pom.xml指定打成的包为： 1&lt;packaging&gt;war&lt;/packaging&gt; 并通过&lt;scope&gt;标签在打包的时候排除tomcat依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; SpringBoot自带的打包方式 12345678910111213141516171819202122&lt;build&gt; &lt;defaultGoal&gt;compile&lt;/defaultGoal&gt; &lt;sourceDirectory&gt;src&lt;/sourceDirectory&gt; &lt;finalName&gt;springboot-package&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin &lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;mainClass&gt;com.pancm.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build SpringBoot部署 如果是jar项目 Windows系统在项目同级目录下输入: 1java -jar springboot-package 也可以写一个bat文件进行运行。 示例: 123@echo offtitle \"springboot-package\"java -jar springboot-package.jar Linux系统在项目同级目录下输入: 1nohup java -jar springboot-package &amp; 即可启动。 关闭输入: 1kill -9 pid（jar的进程id） 也可以在init.d注册一个服务 示例: 12ln -s /home/jars/app/springboot-package.jar /etc/init.d/springboot-packagechmod +x /etc/init.d/springboot-package 然后输入: 1service springboot-package start|stop|restart 进行启动或者停止。 IDEA的Docker插件实战(Dockerfile篇) DaoCloud上部署 daocloud是个云原生应用云平台，他能够侦听我们Github代码仓库的修改变动，如push后触发CICD，因此我们采用其来完成项目的CICD功能 设置步骤 集群管理: 添加主机-&gt;选择主机系统-&gt;在主机上安装主机监控程序后等待连接成功 项目：创建新项目-&gt;设置代码源，如果是新push的项目点击右上角的同步代码-&gt;开始创建 应用：创建应用-&gt;选择刚刚运行完的项目iot_experiment_rfid点击右侧的&quot;部署最新版本&quot;，设置应用名和运行环境中的主机选择Step1配置的主机，点击下一步，配置容器暴露端口，由于tomcat应用默认8080端口，因此如果application.yml没做server.port修改的话，容器端口填8080即可，主机端口可以选择默认的动态端口，这个会从主机中找个闲置端口来做映射，如我这次分配的就是32768。接着是卷挂载，如果没有挂载卷Volume则直接立即部署即可，部署成功效果如下图所示： 集群管理效果图：可以看到应用运行容器显示了3个链接，前两个是局域网链接，第3个是公网IP:主机端口，这个需要在阿里云服务器的防火墙打开了这个端口才能显示与访问。所以如果主机端口选择了动态端口的话一定要再去阿里云设置防火墙开放端口。 项目: 流程定义-&gt; “发布阶段”-&gt;添加并行任务-&gt;发布标签下的&quot;发布到自由主机&quot;， 然后在&quot;应用&quot;的下拉框中选择刚刚配置好的应用RFID_app，点击&quot;创建任务&quot;按钮，完成配置 （可选）创建云隧道：开发者的安全云隧道，跨网络的容器云地址，让您在本地也能部署公网服务器。实际就是把可能处于内网的服务器通过内网穿透的方式将其绑定到了daocloud分配的域名上，最终通过DNS解析实现了域名访问应用的效果。提供的都是http://rfidapp.daocloudapp.com这种daocloudapp下的三级域名，2021年9月27日测试的时候貌似daocloudapp域名未备案，这个功能就暂时失效了。如果有公网IP的话，还是可以通过公网IP:主机port来访问Web应用的 Dockerfile内容 编写好springboot工程内容后，编写dockerfile： 1234567891011121314151617# 自己手动在云服务器上通过mvn package docker:build命令来运行容器的Dockerfile内容# FROM openjdk:8-jdk-alpine# VOLUME /tmp## 注：spring-boot-docker-1.0.jar是需要根据自己项目mvn package生成的压缩包名来写的# ADD spring-boot-docker-1.0.jar app.jar# ENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.jar\"]# Daocloud上的Dockerfile编写内容FROM maven:3 as bdWORKDIR /code # 指定容器启动时执行命令所在目录COPY ./ /code # 将当前工程代码复制到/code目录下COPY settings-docker.xml /usr/share/maven/conf/settings.xml # ★指定换源RUN mvn package -Dmaven.test.skip=true # 打包工程FROM java:8 COPY --from=bd /code/target/*.jar /app.jar # 复制mvn镜像中/code/target/*.jar的结果到该层镜像的工作目录下，取名为arr.jarCMD java -jar /app.jar # 运行java -jar命令 两者的区别在于第一个是已经通过mvn package把项目应用的jar包给打出来了，而在Daocloud中由于全部的CICD都是在容器中进行的，因此需要拉取maven的镜像，然后打包，而之后为什么不用mvn package docker:build也是因为已经在容器中，再使用的话，相当于是容器中创建容器是不合适的。所以直接运行java -jar xxx.jar即可","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"}]},{"title":"学点Kotlin","slug":"学点Kotlin","date":"2021-09-13T09:18:17.000Z","updated":"2021-12-02T03:17:32.619Z","comments":true,"path":"2021/09/13/学点Kotlin/","link":"","permalink":"https://nymrli.top/2021/09/13/学点Kotlin/","excerpt":"","text":"Kotlin 基础语法 Kotlin 文件以 .kt 为后缀。 函数定义 函数定义使用关键字 fun，参数格式为：参数 : 类型 123fun sum(a: Int, b: Int): Int &#123; // Int 参数，返回值 Int return a + b&#125; 表达式作为函数体，返回类型自动推断： 123fun sum(a: Int, b: Int) = a + bpublic fun sum(a: Int, b: Int): Int = a + b // public 方法则必须明确写出返回类型 无返回值的函数(类似Java中的void)： 123456789fun printSum(a: Int, b: Int): Unit &#123; print(a + b)&#125;// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：public fun printSum(a: Int, b: Int) &#123; print(a + b)&#125; 可变长参数函数 函数的变长参数可以用 vararg 关键字进行标识： 12345678910fun vars(vararg v:Int)&#123; for(vt in v)&#123; print(vt) &#125;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123; vars(1,2,3,4,5) // 输出12345&#125; lambda(匿名函数) lambda表达式使用实例： 12345// 测试fun main(args: Array&lt;String&gt;) &#123; val sumLambda: (Int, Int) -&gt; Int = &#123;x,y -&gt; x+y&#125; println(sumLambda(1,2)) // 输出 3&#125; NULL检查机制 Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理 12345678//类型后面加?表示可为空var age: String? = \"23\" // 不能为空，否则抛出空指针异常val ages = age!!.toInt()//不做处理返回 nullval ages1 = age?.toInt()//age为空返回-1val ages2 = age?.toInt() ?: -1 当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。 当 str 中的字符串内容不是一个整数时, 返回 null: 123fun parseInt(str: String): Int? &#123; // ...&#125; Kotlin 基本数据类型 Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。 Kotlin 中没有基础数据类型，只有封装的数字类型。你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所以在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。 在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。 var x = 1..16: [1,16] var x = 1 until 16: [1, 16) 变量和常量 可变变量定义：var 关键字 12var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 字符串模板 $ 表示一个变量名或者变量值 $varName表示变量值 ${varName.fun()}表示变量的方法返回值: 1var a = 1// 模板中的简单名称：val s1 = \"a is $a\" a = 2// 模板中的任意表达式：val s2 = \"$&#123;s1.replace(\"is\", \"was\")&#125;, but now is $a\" Kotlin 条件控制 Kotlin 循环控制 1// 对任何提供迭代器（iterator）的**对象**进行遍历for (item in collection) print(item)// 通过**索引**遍历一个数组或者一个 listfor (i in array.indices) &#123; print(array[i])&#125;// 索引+值，相当于Python中的enumeratefor ((index, value) in array.withIndex()) &#123; println(\"the element at $index is $value\")&#125; 1// while循环while( 布尔表达式 ) &#123; //循环内容&#125;// do循环do &#123; //代码语句&#125;while(布尔表达式); 返回和跳转 Kotlin 有三种结构化跳转表达式： return。默认从最直接包围它的函数或者匿名函数返回。 break。终止最直接包围它的循环。 continue。继续下一次最直接包围它的循环。 Break 和 Continue 的跳转标签 在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符+跟 @，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可 1loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (……) break@loop &#125;&#125; 标签限制使得 break 跳转到刚好位于该标签指定循环的后面执行点。 continue 继续标签指定的循环的下一次迭代。 标签处返回 Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 标签处返回的最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候： 1fun foo() &#123; ints.forEach &#123; if (it == 0) return print(it) &#125;&#125; 这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。 1fun foo() &#123; ints.forEach lit@ &#123; if (it == 0) return@lit print(it) &#125;&#125; 现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。 1fun foo() &#123; ints.forEach &#123; if (it == 0) return@forEach print(it) &#125;&#125; 或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回 1fun foo() &#123; ints.forEach(fun(value: Int) &#123; if (value == 0) return print(value) &#125;)&#125; 当要返一个回值的时候，解析器优先选用标签限制的 return，即 1return@a 1 意为&quot;从标签 @a 返回 1&quot;，而不是&quot;返回一个标签标注的表达式 (@a 1)&quot;。 Kotlin 类和对象 类的定义 1class Runoob constructor(name: String) &#123; fun foo() &#123; print(\"Foo\") &#125; // 成员函数 var url: String = …… // 次构造函数 constructor (name: String, alexa: Int) : this(name) &#123; println(\"Alexa 排名 $alexa\") &#125; var lastName: String = \"zhang\" get() = field.toUpperCase() // 将变量赋值后转换为大写 set var no: Int = 100 get() = field // 后端变量 set(value) &#123; if (value &lt; 10) &#123; // 如果传入的值小于 10 返回该值 field = value &#125; else &#123; field = -1 // 如果传入的值大于等于 10 返回 -1 &#125; &#125; var heiht: Float = 145.4f private set &#125; 对象的声明 1val site = Runoob() // Kotlin 中没有 new 关键字site.name // 使用 . 号来引用site.url 构造函数 Koltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后: 1class Person constructor(firstName: String) &#123; init &#123; println(\"FirstName is $firstName\") &#125;&#125; 如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。 1class Person(firstName: String) &#123;&#125; 次构造函数 类也可以有二级构造函数，需要加前缀 constructor: 1class Person &#123; constructor(parent: Person) &#123; parent.children.add(this) &#125;&#125; 如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字： 1class Person(val name: String) &#123; constructor (name: String, age:Int) : this(name) &#123; // 初始化... &#125;&#125; 如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数： 1class DontCreateMe private constructor () &#123;&#125; getter 和 setter 1var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;]// var变量可设置getter 和 setter, 都是可选// 如果属性类型可以从初始化语句或者类的成员函数中推断出来，那就可以省去类型，val不允许设置setter函数，因为它是只读的。var allByDefault: Int? // 错误: 需要一个初始化语句, 默认实现了 getter 和 setter 方法var initialized = 1 // 类型为 Int, 默认实现了 getter 和 setterval simple: Int? // 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化val inferredType = 1 // 类型为 Int 类型,默认实现 getter 抽象类 抽象是面向对象编程的特征之一，类本身，或类中的部分成员，都可以声明为abstract的。抽象成员在类中不存在具体的实现。 注意：无需对抽象类或抽象成员标注open注解。 1open class Base &#123; open fun f() &#123;&#125;&#125;abstract class Derived : Base() &#123; override abstract fun f()&#125; 嵌套类 我们可以把类嵌套在其他类中，看以下实例： 1class Outer &#123; // 外部类 private val bar: Int = 1 class Nested &#123; // 嵌套类 fun foo() = 2 &#125;&#125; 内部类 内部类使用 inner 关键字来表示。 内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。 1class Outer &#123; private val bar: Int = 1 var v = \"成员属性\" /**嵌套内部类**/ inner class Inner &#123; fun foo() = bar // 访问外部类成员 fun innerTest() &#123; var o = this@Outer //获取外部类的成员变量 println(\"内部类可以引用外部类的成员，例如：\" + o.v) &#125; &#125;&#125; 匿名内部类 使用对象表达式来创建匿名内部类： 1class Test &#123; var v = \"成员属性\" fun setInterFace(test: TestInterFace) &#123; test.test() &#125;&#125;/** * 定义接口 */interface TestInterFace &#123; fun test()&#125;fun main(args: Array&lt;String&gt;) &#123; var test = Test() /** * 采用对象表达式来创建接口对象，即匿名内部类的实例。 */ test.setInterFace(object : TestInterFace &#123; override fun test() &#123; println(\"对象表达式创建匿名内部类的实例\") &#125; &#125;)&#125; 类的修饰符 类的修饰符包括 classModifier 和_accessModifier_: classModifier: 类属性修饰符，标示类本身特性。 1abstract // 抽象类 final // 类不可继承，默认属性enum // 枚举类open // 类可继承，类默认是final的annotation // 注解类 accessModifier: 访问权限修饰符 1private // 仅在同一个文件中可见protected // 同一个文件中或子类可见public // 所有调用的地方都可见internal // 同一个模块中可见 Kotlin 继承 Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类： Any 默认提供了三个函数： equals() hashCode() toString() 注意：Any 不是 java.lang.Object。 如果一个类要被继承，可以使用 open 关键字进行修饰。 1open class Base(p: Int) // 定义基类class Derived(p: Int) : Base(p) 构造函数 子类有主构造函数 如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。 1open class Person(var name : String, var age : Int)&#123;// 基类&#125;class Student(name : String, age : Int, var no : String, var score : Int) : Person(name, age) &#123;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123; val s = Student(&quot;Runoob&quot;, 18, &quot;S12346&quot;, 89) println(&quot;学生名： $&#123;s.name&#125;&quot;) println(&quot;年龄： $&#123;s.age&#125;&quot;) println(&quot;学生号： $&#123;s.no&#125;&quot;) println(&quot;成绩： $&#123;s.score&#125;&quot;)&#125; 输出结果： 1学生名： Runoob年龄： 18学生号： S12346成绩： 89 子类没有主构造函数 如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。 1class Student : Person &#123; constructor(ctx: Context) : super(ctx) &#123; &#125; constructor(ctx: Context, attrs: AttributeSet) : super(ctx,attrs) &#123; &#125;&#125; 重写 在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词： 1/**用户基类**/open class Person&#123; open fun study()&#123; // 允许子类重写 println(\"我毕业了\") &#125;&#125;/**子类继承 Person 类**/class Student : Person() &#123; override fun study()&#123; // 重写方法 println(\"我在读大学\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val s = Student() s.study();&#125; 如果有多个相同的方法（继承或者实现自其他类，如A、B类），则必须要重写该方法，使用super范型去选择性地调用父类的实现。 1open class A &#123; open fun f () &#123; print(&quot;A&quot;) &#125; fun a() &#123; print(&quot;a&quot;) &#125;&#125;interface B &#123; fun f() &#123; print(&quot;B&quot;) &#125; //接口的成员变量默认是 open 的 fun b() &#123; print(&quot;b&quot;) &#125;&#125;class C() : A() , B&#123; override fun f() &#123; super&lt;A&gt;.f()//调用 A.f() super&lt;B&gt;.f()//调用 B.f() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val c = C() c.f();&#125; C 继承自 a() 或 b(), C 不仅可以从 A 或则 B 中继承函数，而且 C 可以继承 A()、B() 中共有的函数。此时该函数在中只有一个实现，为了消除歧义，该函数必须调用A()和B()中该函数的实现，并提供自己的实现。 输出结果为: 1AB 属性重写 属性重写使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写： 1open class Foo &#123; open val x: Int get &#123; …… &#125;&#125;class Bar1 : Foo() &#123; override val x: Int = ……&#125; 注：可以用一个var属性重写一个val属性，但是反过来不行。 Kotlin 接口 接口定义 Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现： 1interface MyInterface &#123; fun bar() // 未实现 fun foo() &#123; //已实现 // 可选的方法体 println(\"foo\") &#125; // 接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性： var name:String //name 属性, 抽象的&#125; 实现接口 一个类或者对象可以实现一个或多个接口。 1class Child : MyInterface &#123; override fun bar() &#123; // 方法体 &#125;&#125; Kotlin 扩展 Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。 扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。 将函数扩展 扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式： receiverType：表示函数的接收者，也就是函数扩展的对象 functionName：扩展函数的名称 params：扩展函数的参数，可以为NULL 1// 函数扩展原型fun receiverType.functionName(params)&#123; body&#125;class User(var name:String)/**扩展函数**/fun User.Print()&#123; print(\"用户名 $name\")&#125; 扩展函数是静态解析的 扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的: 1open class Cclass D: C()fun C.foo() = \"c\" // 扩展函数 foofun D.foo() = \"d\" // 扩展函数 foofun printFoo(c: C) &#123; println(c.foo()) // 类型是 C 类&#125;fun main(arg:Array&lt;String&gt;)&#123; printFoo(D())&#125;// 输出c 若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。 扩展一个空对象 在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。例如: 1fun Any?.toString(): String &#123; if (this == null) return &quot;null&quot; // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString() // 解析为 Any 类的成员函数 return toString()&#125;fun main(arg:Array&lt;String&gt;)&#123; var t = null println(t.toString())&#125; 实例执行输出结果为： 1null 扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。 1val Foo.bar = 1 // 错误：扩展属性不能有初始化器 扩展属性只能被声明为 val。 伴生对象的扩展 伴生对象内的成员相当于 Java 中的静态成员，其生命周期伴随类始终，在伴生对象内部可以定义变量和函数，这些变量和函数可以直接用类名引用。 如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性。 伴生对象通过&quot;类名.&quot;形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用： 1class MyClass &#123; companion object &#123; &#125; // 将被称为 &quot;Companion&quot;&#125;fun MyClass.Companion.foo() &#123; println(&quot;伴随对象的扩展函数&quot;)&#125;val MyClass.Companion.no: Int get() = 10fun main(args: Array&lt;String&gt;) &#123; println(&quot;no:$&#123;MyClass.no&#125;&quot;) MyClass.foo()&#125; 实例执行输出结果为： 1no:10伴随对象的扩展函数 注：对于伴生对象扩展函数，有两种形式，一种是在类内扩展，一种是在类外扩展，这两种形式扩展后的函数互不影响（甚至名称都可以相同），即使名称相同，它们也完全是两个不同的函数，并且有以下特点： （1）类内扩展的伴随对象函数和类外扩展的伴随对象可以同名，它们是两个独立的函数，互不影响； （2）当类内扩展的伴随对象函数和类外扩展的伴随对象同名时，类内的其它函数优先引用类内扩展的伴随对象函数，即对于类内其它成员函数来说，类内扩展屏蔽类外扩展； （3）类内扩展的伴随对象函数只能被类内的函数引用，不能被类外的函数和伴随对象内的函数引用； （4）类外扩展的伴随对象函数可以被伴随对象内的函数引用，； Kotlin 对象表达式和对象声明 对象表达式 通过对象表达式实现一个匿名内部类的对象用于方法的参数中： 1window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // ... &#125; override fun mouseEntered(e: MouseEvent) &#123; // ... &#125;&#125;) 对象声明 Kotlin 使用 object 关键字来声明一个对象。 Kotlin 中我们可以方便的通过对象object声明来获得一个单例。 当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。 1class Site &#123; var name = \"菜鸟教程\" object DeskTop&#123; var url = \"www.runoob.com\" fun showName()&#123; print&#123;\"desk legs $name\"&#125; // 错误，不能访问到外部类的方法和变量 &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var site = Site() site.DeskTop.url // 错误，不能通过外部类的实例访问到该对象 Site.DeskTop.url // 正确, 类似静态内部类，这个类是属于外部类的，而不是某个实例&#125; 伴生对象 类内部的对象声明可以用 companion 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。 对象表达式和对象声明之间的语义差异 对象表达式和对象声明之间有一个重要的语义差别： 对象表达式是在使用他们的地方立即执行的 对象声明是在第一次被访问到时延迟初始化的 伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配 kotlin 委托 委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。 Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。 类委托 1// 创建接口interface Base &#123; fun print()&#125;// 实现此接口的被委托的类class BaseImpl(val x: Int) : Base &#123; override fun print() &#123; print(x) &#125;&#125;// 通过关键字 by 建立委托类class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) &#123; val b = BaseImpl(10) Derived(b).print() // 输出 10&#125; 在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。 属性委托 属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。 1import kotlin.reflect.KProperty// 定义包含属性委托的类class Example &#123; var p: String by Delegate() // val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;&#125;// 委托的类class Delegate &#123; operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return \"$thisRef, 这里委托了 $&#123;property.name&#125; 属性\" &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; println(\"$thisRef 的 $&#123;property.name&#125; 属性赋值为 $value\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val e = Example() println(e.p) // 访问该属性，调用 getValue() 函数 e.p = \"Runoob\" // 调用 setValue() 函数 println(e.p)&#125; 标准委托 Kotlin 的标准库中已经内置了很多工厂方法来实现属性的委托。 延迟属性 Lazy 1val lazyValue: String by lazy &#123; println(\"computed!\") // 第一次调用输出，第二次调用不执行 \"Hello\"&#125;fun main(args: Array&lt;String&gt;) &#123; println(lazyValue) // 第一次执行，执行两次输出表达式 println(lazyValue) // 第二次执行，只输出返回值&#125;/*computed!HelloHello*/ 可观察属性 Observable observable 可以用于实现观察者模式。 Delegates.observable() 函数接受两个参数: 第一个是初始化值, 第二个是属性值变化事件的响应器(handler)。 在属性赋值后会执行事件的响应器(handler)，它有三个参数：被赋值的属性、旧值和新值： 1import kotlin.properties.Delegatesclass User &#123; var name: String by Delegates.observable(\"初始值\") &#123; prop, old, new -&gt; println(\"旧值：$old -&gt; 新值：$new\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User() user.name = \"第一次赋值\" user.name = \"第二次赋值\"&#125;/*旧值：初始值 -&gt; 新值：第一次赋值旧值：第一次赋值 -&gt; 新值：第二次赋值*/ 把属性储存在映射中 Not Null notNull 适用于那些无法在初始化阶段就确定属性值的场合。 1class Foo &#123; var notNullBar: String by Delegates.notNull&lt;String&gt;()&#125;foo.notNullBar = &quot;bar&quot;println(foo.notNullBar) 需要注意，如果属性在赋值前就被访问的话则会抛出异常。 局部委托属性 你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化： 1fun example(computeFoo: () -&gt; Foo) &#123; val memoizedFoo by lazy(computeFoo) if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123; memoizedFoo.doSomething() &#125;&#125; memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。 属性委托要求 对于只读属性(也就是说val属性), 它的委托必须提供一个名为getValue()的函数。该函数接受以下参数： thisRef —— 必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型 property —— 必须是类型 KProperty&lt;*&gt; 或其超类型 这个函数必须返回与属性相同的类型（或其子类型）。 对于一个值可变(mutable)属性(也就是说,var 属性),除 getValue()函数之外,它的委托还必须 另外再提供一个名为setValue()的函数, 这个函数接受以下参数: property —— 必须是类型 KProperty&lt;*&gt; 或其超类型new value —— 必须和属性同类型或者是它的超类型。 提供委托 附： Kotlin 构造函数 Kotlin 中构造函数分为主构造函数和**次构造函数，**主构造函数只能有一个，次构造函数个数不限制，可以有一个或者多个。 主构造函数就是类后的小括号中定义的，会定义类有哪些数据成员并初始化。——然而那一些初始化的方法该怎么调用呢==&gt; 在init{}中编写需要在主构造函数中完成的业务 而次构造函数需要用constructor关键字来声明。 基础概念： Kotlin 构造函数、继承 进阶： kotlin的主构造函数, 次构造函数, init代码块, 伴生对象的执行顺序, 特点, 使用场景, 及跟java的比较 123456789101112131415161718192021222324252627282930313233class Person(var name: String, var age: Int) &#123; // 次构造函数中传入了主构造函数中没有的数据成员的时候，需要在这里定义 var sex: Boolean?=null; init &#123; println(\"main constructor init $&#123;name&#125;\") &#125; constructor(name:String, age: Int, sexy: Boolean): this(name, age)&#123; println(\"constructor\") this.sex = sexy println(this.sex) &#125;&#125;class DataClassTest &#123; @Test fun test2()&#123; val person = Person(name = \"a\", age = 12) println(person.age) println(\"________________________\") val person2 = Person(name = \"b\", age = 14, sexy = false) println(person2.age) &#125;&#125;/**main constructor init a12________________________main constructor init bconstructor12*/ 默认情况下class是有不带参数的主构造函数， 当class具有有参的构造函数时， 无参的就会失效， 除非参数全有默认值。如果在定义了上述构造函数的情况下， 输入Person(), idea会提示报错，并提示如下Person类有如下构造函数。 但如果将主构造函数的参数全部设置为null，即class Person(var name: String? =null, var age: Int? = null)， 那么就可以直接创建不带参数的对象了, var person0 = Person(); 主构造函数的参数如果使用了var或val修饰符，就相当于在类中声明了对应名称的属性。 Kotlin 中规定，当一个类既有主构造函数又有次构造函数时，所有次构造函数都必须使用this关键字直接或间接的调用主构造函数（间接指多层调用次构造函数）： 调用顺序: ( 伴生对象成员变量初始化 -&gt; 伴生对象的init )-&gt; ( 主构造函数的参数赋值 -&gt; init 代码块 ) -&gt; 次构造函数代码块 Throwable kotlin demo: 1234567public open class Throwable(open val message: String?, open val cause: Throwable?) &#123; constructor(message: String?) : this(message, null) constructor(cause: Throwable?) : this(cause?.toString(), cause) constructor() : this(null, null)&#125; data class数据类 在 Kotlin 中，不需要自己动手去写一个 JavaBean，可以直接使用 DataClass，使用 DataClass 编译器会默默地帮我们生成以下函数 equals() hashCode() toString() componentN() copy() 定义一个： dataclassCountry(var id: Int,var name: String,var continent: String) 如何申明一个简单的数据类？ 有一下几点要求： 主构造函数必须要至少有一个参数 在主构造函数中的所有参数必须被标记为val或者var （var就表示可读写，val就表示只读） 数据类不能有以下修饰符：abstract，inner ,open, sealed ==》 数据类本身是不能被继承的 final data class只能实现接口（Kotlin1.1以前的规则），现在也可以继承其它类 1234567891011121314151617181920212223@Document(\"daf_FiledDetail\")@ApiModel(\"字段类型表\")data class FiledDetail( @ApiModelProperty(\"字段名称\") val name: String, @ApiModelProperty(\"字段类型\") val type: FieldTypeEnum, @ApiModelProperty(\"选项\") val choices: String, @ApiModelProperty(\"字段分组\") val fieldGroup: String): MongoTableBean()class DataClassTest &#123; @Test fun test()&#123; val filedDetail = FiledDetail(\"name\", FieldTypeEnum.ADMINISTRATIVE, \"YES\", \"NO\") println(filedDetail) &#125;&#125; 序列化 序列化和反序列化其实就是方便传输对象. 这里是需要在几个系统 Service 里通过 Bundle 传递数据. Parcelable 全部都在内存,效率高,需要实现部分多,使用繁琐.(在 kotlin 不成立) Serializable 实现简单,但是是基于反射实现的,故有性能损失,但是是最通用的. Kotlin 中class、data class、object、companion object区别 data class： kotlin中的数据类，只保存一些数据字段，类似于java bean，oc中的model。 12345data class yourClassName( // 这边是小括号 val name: String, val age: Int, val sex: Boolean) object： kotlin中使用&quot;object&quot;修饰静态类，可用于util工具类中。 对象声明（object declaration） 将类的声明和定义该类的单例对象结合在一起（即通过object就实现了单例模式） 对象声明中不能包含构造器（包括主构造器和次级构造器） 伴生对象（companion object） 对象表达式（object expression） 123456object UserUtil &#123; val guoji = \"中国\" fun getName(): String &#123; return \"小红\" &#125;&#125; 伴生对象（companion object） 因为在kotlin中是没有static关键字的，也就意味着没有静态方法和静态成员。那么在kotlin中如果想要表达这种概念，可以使用包级别函数（package-level funcation）和伴生对象（companion object）。 伴生对象语法形式 123456class ClassName &#123; // 伴生对象名可以省略，默认为Companion companion object 伴生对象名 &#123; // define field and method &#125;&#125; from ： Kotlin：object关键字总结 相应结果封装类： 12345678910111213141516171819202122232425262728293031323334353637package com.sucsoft.dispatch.utilsimport com.sucsoft.daf.enums.OperationEnum/** * @Author: Mrli * @Description: 结果返回封装类 * @Date: 2021/8/6 13:43 * @Version: 1.0 */class Result(var data: Any? = null, var code: Int? = null, var message: String? =null) &#123; companion object&#123; fun of(data: Any, code: Int, message: String): Result &#123; return Result(data, code, message) &#125; fun make(data: Any?, op: OperationEnum): Result &#123; return if (null == data) this.err(op.cn) else this.ok(data) &#125; fun ok(data: Any): Result &#123; return of(data, 200, OperationEnum.SUCCESS.cn) &#125; fun err(msg: String): Result &#123; return of(&#123;&#125;, 500, msg) &#125; fun badRequest(): Result &#123; return of(&#123;&#125;, 400, OperationEnum.PARAM_ERROR.cn) &#125; fun serverError(): Result &#123; return of(&#123;&#125;, 500, OperationEnum.SERVER_ERROR.cn) &#125; &#125;&#125; 踩坑： swagger里面不填时，对应传的值为空， 因此需要对应接口的参数类型上是否能接受空?, （即比在写swagger（required）上比java对写个对类型的限制）， data class 中字段的定义， 如果需要默认值则sortNum : Int = 0, 而对于String的话，如果是不可为空写成 id :String,即可，如果为空则定义为id: String?， 至于之后的默认值还是根据需求来看。 ?. 和?:的区分 code1?.code2 翻译为 ：if code1 Not Null 执行 code2; code1?:code2 翻译为：if code1 Null 执行 code2; ?. 翻译为： If Not Null ?: 翻译为： If Null 注意点： 【?.】后面的方法是前者的相关调用 【?:】后面的方法与前者的无关调用 ?.表示当前对象如果为空则不执行， !!.表示当前对象如果为空也执行，然后会抛出空异常 open 在 Java 中，一个类除了被手动加上 final 关键字以外，它总能能被任意一个类继承并重写它的非 final 方法，这就可能会导致某些子类出现不符合其父类的设计初衷，特别是在多人协作的开发环境下。 这类问题被 Kotlin 语言设计者注意到了并切引起了他们的重视，因此，在 Kotlin 中的类和方法默认都是 final 的，如果要继承或者重写一个类和其方法时，必须将他们都显式地声明为 open , 成员变量不需要，会自动认为是open 的。 123456789101112open class Person2&#123; var name : String = \"\" constructor(name: String)&#123; this.name = name &#125; constructor()&#123; &#125; open fun saySomething()&#123; println(\"yes\") &#125;&#125; 抛弃 Java 改用 Kotlin 的六个月后，我后悔了——Kotlin特性有哪些？","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://nymrli.top/tags/Kotlin/"}]},{"title":"ZJU开学摸底考试——操作系统复习","slug":"ZJU开学摸底考试——操作系统复习","date":"2021-09-09T06:21:21.000Z","updated":"2022-02-27T15:59:16.996Z","comments":true,"path":"2021/09/09/ZJU开学摸底考试——操作系统复习/","link":"","permalink":"https://nymrli.top/2021/09/09/ZJU开学摸底考试——操作系统复习/","excerpt":"","text":"操作系统 特性： 并发： ▲理解并发和并行的区别 共享 互斥共享方式（摄像头设备的共享使用） 同时共享方式（硬盘访问）——宏观的同时，微观上进程还是交替访问的（分时共享） 虚拟： 虚拟存储器： 空分复用 虚拟处理器： 时分复用 异步 只有系统具有并发性，才可能导致异步性 注： 并发与共享互为存在条件 操作系统发展 单道批处理系统 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。 主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待/0完成。资源利用率依然很低。 多道批处理系统： 主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。 主要缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行） 分时操作系统： 计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。 主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。 主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。 实时操作系统： 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性 OS的运行机制和体系结构 运行机制： 指令：“指令”就是处理器（CPU）能识别、执行的最基本命令。而OS运行过程就是CPU不断执行指令的过程 特权指令： 内存清零指令 非特权指令：普通加减乘除指令 处理器状态： 内核态（管态）：既可以执行特权指令也可执行非特权指令 用户态（目态）：此时CPU只能执行非特权指令 ▲：“用户态-&gt;核心态”是通过中断实现的并且中断是唯一途径。而“核心态-&gt;用户态”的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态” 内核： 内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。 实现操作系统内核功能的那些程序就是内核程序。 体系结构 中断： 为了解决最初各个程序只能串行执行，人们发明了操作系统（作为计算机的管理者），引入中断机制，从而实现了多道程序并发执行 本质：发生中断就意味着需要操作系统介入，开展管理工作 ▲：“用户态-&gt;核心态”是通过中断实现的并且中断是唯一途径。而“核心态-&gt;用户态”的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态” 中断分类： 内中断（与CPU当前执行指令有关） 自愿中断——指令中断 强迫中断——硬件故障（缺页）、软件中断（除零） 外中断（与CPU当前执行指令无关） 外设请求（IO操作完成发出中断信号） 人工干涉（用户强行关闭进程） 系统调用 操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。 “系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。 进程 定义 程序段、数据段、PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。 注意：PCB是进程存在的唯一标志！ 从不同的角度，进程可以有不同的定义，比较传统典型的定义有： 1.进程是程序的一次执行过程。 2.进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 3.进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位 ▲它是一个动态的过程。 引入进程实体的概念后，可把进程定义为：进程是进程实体的**运行过程，**是系统进行资源分配和调度的一个独立单位。 注：严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。不过，除非题目专门考察二者区别，否则可以认为避程实体就是进程。因此我们也可以说“进程由程序段、数据段、PCB三部分组成” 组织形式 链接方式：按照进程状态将PCB分成多个队列，操作系统持有指向各个队列的指针 索引方式：根据进程状态不同建立多张索引表，操作系统持有指向各个索引表的指针 进程特性 进程状态： 创建态：进程正在被创建，操作系统为进程分配资源、初始化PCB 运行态 阻塞态 就绪态 终止态： 进程从系统中撤销，操作系统回收进程拥有的资源、撤销PCB 进程控制： 用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。 这种不可被中断的操作即原子操作 原语采用“关中断指令”和“开中断指令”实现 注：显然，关/开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令 创建原语：无-&gt;创建态-&gt;就绪态 申请空白PcB 为新进程分配所需资源 初始化PCB 将PcB插入就绪队列 撤销原语：就绪态/阻塞态/运行态→终止态→无 从PcB集合中找到终止进程的PCB 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程 终止其所有子进程 将该进程拥有的所有资源归还给父进程或操作系统 删除PcB 阻塞原语： 找到要阻塞的进程对应的PcB 保护进程运行现场，将PcB状态信息设置为阻塞态&quot;，暂时停止进程运行 将PcB插入相应事件的等待队列 唤醒原语： 在事件等待队列中找到PcB 将PcB从等待队列移除，设置进程为就绪态 将pcB插入就绪队列，等待被调度 通信 各进程拥有的内存地址空间相互独立 方式： 都需要互斥 共享存储 基于数据结构：速度慢，是一种低级的通信方式 基于存储区:存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式 管道通信 “管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区 数据以字符流的形式写入管道，当管道写满时，写进程的write（）系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read（）系统调用将被阻塞。 半双工管道，如果全双工需要设置两个管道 需要互斥访问 读进程最多只能有一个——否则可能有读错数据的情况 消息传递 进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。 直接通信方式: 消息直接挂到接收进程的消息缓冲队列上 间接通信方式：消息先发送到中间实体（信箱）中，因此也成为信箱通信方式 进程互斥原则： 为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则： 1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区 2.忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待； 3.有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）； 4.让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。 进程互斥软件实现： 单标志法：算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予 单标志法存在的主要问题是：违背“空闲让进”原则。 双标志先检查：算法思想：设置一个布尔型数组flag囗，数组中各个元素用来标记各进程想进入临界区的意愿，比如flag=ture”意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检査当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志fa】设为true，之后开始访问临界区。 双标志先检查法的主要问题是：违反“忙则等待”原则。 双标志后检查:算法思想：双标志先检査法的改版。前一个算法的问题是先“检査”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。 双标志后检査法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。 Peterson算法——三标志：算法思想：双标志后检査法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。 Gary L. Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。 Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。 进程互斥硬件实现： 中断屏蔽方法 TestAndSet Swap指令 信号量 用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步 信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。 wait、 signal原语常简称为ρ、V操作（来自荷兰语 proberen和 verhogen）。因此，做题的时候常把Wait（S）、 sIgna|（S）两个操作分别写为P（S）、V（S） 整形信号量：用一个整数型的变量作为信号量，用来表示系统中某种资源的数量 存在的问题：不满足“让权等待”原则，会发生“忙等” 整型信号量的缺陷是存在“忙等”问题，因此人们又提岀了“记录型信号量”，即用记录型数据结构表示的信号量。 操作方式： S value的初值表示系统中某种资源的数目 对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此需要执行va|ue-，表示资源数减1，当S value&lt;0时表示该类资源已分配完毕，因此进程应调用 block原语进行自我阻塞（当前运行的进程从运行态→阻塞态），主动放弃处理机，并插入该类资源的等待队列SL中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。 对信号量S的一次∨操作意味着进程释放一个单位的该类资源，因此需要执行 S value++，表示资源数加1，若加1后仍是 S value&lt;=0，表示依然有进程在等待该类资源，因此应调用 wakeup原语唤醒等待队列中的第个进程（被唤醒进程从阻塞态→就绪态）。 技巧总结： 基础 互斥问题，将信号量初值设置为1 同步问题，将信号量初值设置为0——一前一后问题，进程执行有先后顺序需要同步协调 除了互斥、同步问题外还会考察有多个资源的问题，有多少资源就把信号量初值设为多少。申请资源时进行P操作，释放资源时进行V操作即可 设置一个信号量，初始值即为资源的数量（本质上也属于“同步问题”，若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续往下执行） 进阶 实现互斥是在同一进程中进行一对PV操作 实现两进程的同步关系，是在其中个进程中执行P，另进程中执行V **实现互斥的P操作一定要在实现同步的P操作之后。**V操作不会导致进程阻塞，因此两个V操作顺序可以交换。 生产消费者问题 读者和写者问题 有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求： 允许多个读者可以同时对文件执行读操作； 只允许一个写者往文件中写信息； 任一写者在完成写操作之前不允许其他读者或写者工作； 写者执行写操作前，应计口有的读者和写者全部退出 管程：信号量机制存在的问题：编写程序困难、易出错，能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢？——管程，一种高级同步机制 管程是一种特殊的软件模块，有这些部分组成： 1.局部于管程的共享数据结构说明 2.对该数据结构进行操作的1组过程（函数）； 3.对局部于管程的共享数据设置初始值的语句； 4.管程有一个名字。 管程的基本特征： 1.局部于管程的数据只能被局部于管程的过程所访问； 2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据； 3.每次仅允许一个进程在管程内执行某个内部过程。 死锁 什么是死锁 进程死锁、饥饿、死循环的区别 死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。 饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（sPF）算法 中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿” 死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是 程序员故意设计的。 死锁产生的必要条件 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。 不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。 什么时候会发生死锁 对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的 进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、 分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁 信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源） 死锁的处理策略 死锁忽略 预防死锁。破坏死锁产生的四令必要条件中的一个或几个。 避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法） 死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。 检测 资源分配图 死锁检测算法 接触： 资源剥夺法： 撤销（终止）进程法： 进程回退法： 线程 在没有引入进程之前，程序都是串行执行的。引入进程后计算机可以同时执行多个程序，但进程是程序的一次执行，比如QQ拥有视频、发丧图片等功能，程序的多个功能是不可能顺序执行就实现的，因此引出了线程。为此，引入了线程来增加并发性 ▲传统的进程是程序执行流的最小单位 ===&gt; 引入线程后，线程成了程序执行流的最小单位 ==&gt; 可以吧线程理解为轻量级进程 线程是一个基本的CPU执行单元也是程序执行流的最小单位。 引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件） 引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）==&gt; 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位 理解类比： 引人线程后，并及所带来的系统开销，比如去图书馆看书。 切换进程运行环境=有一个不认识的人要用桌子，你需要你的书收走，他把自己的书放到桌上 同一进程内的线程切换=你的舍友要用这张书桌，可以不把桌子上的书收走 用户级线程(ULT: User-Level Thread) 用户级线程由应用程序通过线程库实现。 所有的线程管理工作都由应用程序负责（包括线程切换） 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明） ==&gt; 用户线程就是从用户视角能看到的线程 内核级线程(KLT: Kernel-Level Thread) 内核级线程的管理工作由操作系统内核完成。 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。 ==&gt; 可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程” 组合方式： KLT(m个)与ULT混合(n个)共同使用， n&gt;=m 多线程模型： 多对一模型：多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行 一对一模型：一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。 ★多对多模型：用户及线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。 处理机调度 调度：当有一堆仼务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序(按某种算法选择一个进程将处理机分配给它)，这就是“调度”研究的问题。 三个层次： 作业调度（高级调度） 高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。 高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。 内存调度（中级调度）——比作业调度多了挂起队列 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。==&gt;从而提高了内存利用率和系统吞吐量 中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。 进程调度（低级调度） 主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。 不能进行进程切换的情况： 在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。 进程在操作系统内核程序临界区中 进程在操作系统内核程序临界区中不能进行调度与切换 √ （2012年联考真题）进程处于临界区时不能进行处理机调度（X 临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。 临界区：访问临界资源的那段代码。 内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PcB组成） 在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列） 调度算法评价指标 CPU利用率：指CPU“忙碌”的时间占总时间的比例。 系统吞吐量：单位时间内完成作业的数量 周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。 它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等 待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待O操作完成的时间。后三项 在一个作业的整个处理过程中，可能发生多次。 等待时间：进程作业等待被服务的时间之和 响应时间：指从用户提交请求到首次产生响应所用的时间。 调度算法： 先来先服务 非抢占式 短作业优先 非抢占式、抢占式（最短剩余时间） 高响应比优先 非抢占式 时间片轮转调度算法RR 抢占式 如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。 另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。 优先级调度算法 抢占式+非抢占式 多级反馈队列调度算法 抢占式 内存管理 内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。 内存的每个存储单元都会进行编址：①按字节编址、②按字编址 我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址存/取数据。但实际在生成机器指令的时候并不知道该进程的数据会被放到什么位置。所以编译生成的指令中一般是使用逻辑地址（相对地址） 相对地址又称逻辑地址，绝对地址又称物理地址。 编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言） 链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块 静态链接.a：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。 装入时动态链接.so：将各目标模块装入内存时，边装入边链接的链接方式。 运行时动态链接.dll：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。 装入（装载）：由装入程序将装入模块装入内存运行 装入的三种方式（用三种不同的方法完成逻辑地址到物理地址的转换）： 绝对装入 绝对装入只适用于单道程序环境。程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。 静态重定位（可重定位装入） 编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。 静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。 动态重定位（又称动态运行时装入，目前采用的方式） 编译、链接后的装入模块的地址都是从0开始的。装入程序把裝入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器（存放装入模块存放的起始位置）的支持。 采用动态重定位时允许程序在内存中发生移动。 ★并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。 操作系统需要做的事？ 1.操作系统负责内存空间的分配与回收 2.操作系统需要提供某种技术从逻辑上对内存空间进行扩充 3.操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换 内存保护： 保证各进程在自己的内存空间内运行，不会越界访问 方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界 方法二：采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检査。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址 内存空间扩充： 覆盖技术（弃用）：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。 内存中分为一个“固定区”和若干个“覆盖区”。 需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束） 不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存 必须由程序员声明覆盖结构，操作索统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。 交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）、 交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度） 暂时换出外存等待的进程状态为挂起状态（挂起态， suspend） 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态 覆盖与交换的区别 覆盖是在同一个程序或进程中的 交换是在不同进程（或作业）之间的 虚拟存储技术 基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存 传统存储管理方式的特征、缺点： 一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：①作业很大时，不能全部装入内存，导致大作业无法运行；②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。 请求分页存储管理 请求分段存储管理 请求段页式存储管理 内存空间的分配与回收： 连续分配管理方式：为用户进程分配的必须是一个连续的内存空间 单一连续分配：在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。 优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的PC操侬系统 MS-DOS）。 缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。 固定分区分配：将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。 优点：实现简单，无外部碎片。 缺点：a.当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；b.会产生内部碎片，内存利用率低。 动态分区分配：动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为64MB，系统区8MB，用户区共56MB.） 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息 空闲分区表：每个空闲分区对应个表项。表项中包含分区号分区大小、分区起始地址等信息 动态分区分配没有内部碎片，但是有外部碎片。内部碎片，分配给某进程的内存区域中，如果有些部分没有用上外部碎片，是指内存中的某些空闲分区由于太小而难以利用。 非连续分配管理方式（离散分配方式）：为用户进程分配的可以是一些分散的内存空间。 基本分页存储管理 把“固定分区分配”改造为“非连续分配版本”，将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”（或者“内存块号”、“页帧号”、“物理块号”）页框号从0开始。 将用户进程的地址空间也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号页号也是从0开始。（注：进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片） 操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系 为了方便计算页号、页内偏移量，页面大小一般设为2的整数幂 如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是2K个内存单元 如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2M个页面 一个进程对应一张页表 ▲进程的每一页对应一个页表项，每个页表项由“页号”和“块号”组成 页表记录进程页面和实际存放的内存块之间的对应关系 优点：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片 缺点：不方便按照逻辑模块实现信息的共享和保护 单级列表： 问题一：页表必须连续存放，因此当页表很大时，需要占用很多连续的页框。 多级，顶级页表 问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。 可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存 若想访问的页面不在内存中，则产生缺页中断（内中断），然后将目标页面从外存调入内存 基本分段存储管理 优点：很方便按照逻辑模块实现信息的共享和保护 缺点：如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片 段号的位数决定了每个进程最多可以分几个段 段内地址位数决定了每个段的最大长度是多少 对比： 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。 段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。 分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址 分段比分页更容易实现信息的共享和保护。 段页式存储管理 局部性原理 时间局部性 空间局部性 高速缓存技术 页面置换算法： OPT FIFO LRU CLOCK （NRU） 改进型 CLOCK（改进型NRU） 文件系统 无结构文件（流式文件） 有结构文件（记录式文件） 每条记录由多个数据项组成，而每条记录的单个数据项都通过关键字表达具体含义，如名字。 逻辑结构： 顺序文件： 链式存储（不可随机读取）、顺序存储（可变长记录不可随机读取、定长记录可以） 索引文件 索引顺序文件 注： 逻辑结构：就是指在用户看来，文件内部的数据应该是如何组织起来的。 物理结构：是在操作系统看来，文件的数据是如何存放在外存中的。 注：一般来说，考试题目中所说的顺序文件”指的是物理上顺序存储的顺序文件。之后的讲解中提到的顺序文件也默认如此。 文件目录 文件控制块(FCB)： 文件名、类型、读写权限、...、物理位置，包含逻辑结构、物理结构，存取控制信息、使用信息 目录结构 单级目录结构 两级目录结构：MFD主文件目录、用户文件目录UFD 多级目录结构（树形目录结构）： 不同目录下的文件可以重名，可以对文件进行分关不方便文件共享 系统根据“文件路径&quot;找到目标文件 从根目录出发的路径是“绝对路径（“照片/201508/自拍jpg”） 从当前目录出发的路径是相对路径（照片12015-08/自拍jpg&quot; 相对路径减少磁盘IO：是因为内存中存储了当前目录表，因此当用户想访问当前目录的某个文件的时候，就可以直接从内存中直接通过相对路径来找，自然搜索效率更高些 树形目录结构可以方便的对文件进行分类，层次结构清晰；但是不便于实现文件的共享==&gt;无环图目录结构，在树形目录的基础上，增加指向同一节点的有向边，使得整个目录成了有向无环图 无环图目录结构——方便文件共享 索引结点（对文件控制块的优化） 将FCB中除了文件名以外的信息放在索引节点上，而取而代之的将其内容换成2B的索引节点地址，从而大大减小了FCB大小，从而相同的记录项能够使用更少的磁盘块，从而加快了磁盘搜索的速度 目录文件中的一条记录就是一个FCB，FCB的有序集合称为“文件目录”，一个FCB就是一个文件目录项。 文件物理结构——管理非空闲磁盘块 文件数据怎样存放在外存中？ 类似于内存分页，磁盘中的存储单元是“块or磁盘块or物理块”，内存与磁盘之间数据交互是以块为单位的。 文件的逻辑地址空间也被分成了一个个文件“块”==&gt; 文件的逻辑地址形式：(逻辑块号, 块内地址) 用户通过逻辑地址来操作自己的文件，操作系统负责从逻辑地址到物理地址的映射 连续分配 连续分配方式要求每个文件在磁盘上占有一组连续的块。 优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快 缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片 链接分配 隐式链接（题目默认指的是隐式链接） 隐式链接——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。 优点：很方便文件拓展，不会有碎片问题，外存利用率高。 缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。 显式链接 显式链接——把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表（FAT，File Allocation Table）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存 优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。 缺点：文件分配表的需要占用一定的存储空间。 索引分配 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中文 件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表一一建立逻辑页面到物理页之间 的映射关系）。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。 可见，索引分配方式可以支持随机访问文件拓展也很容易实现（只需要给文件分配个空闲块，并增加一个索引表项即可）但是索引表需要占用一定的存储空间 Q:这种存储方式会带来一个问题，由于一个索引项占4B，一个磁盘块大小为1KB，那么最多存储256(1024/4)个索引项，也就是说存储文件最大为256*1KB=256KB。但是如果一个文件大小超过了256块，一个磁盘块装不下所有的索引表该怎么办呢？ 链接方案： 索引块的最后一个索引项存储下一个索引块的地址。 需要顺序读取每个索引块，无法根据逻辑块号随机访问，磁盘IO次数多 多层索引：建立多层索引（类似多级页表）。使第一层索引表指向第二层索引表，还可以根据文件大小建立第三层、第四层 若采用多层索引，则各层的索引表大小不能超过一个磁盘块； 二层索引，文件最大大小：256*256*1KB=64MB 可根据逻辑块号算出应该查找索引表中的哪个表项。如：要访问1026号逻辑块，则1026/256=4,1026%256=2 采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作 混合索引：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）。 题型：根据顶级索引表的结构，计算能够存储文件的最大长度 对于小文件，只需较少的读磁盘次数就可以访问目标数据块。（一般计算机中小文件更多） 超级超级超级重要考点：①要会根据多层索引、混合索引的结构计算出文件的最大长度（Key：各级索引表最大不能超过一个块）；②要能自己分析访问某个数据块所需要的读磁盘次数（Key:FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件一一顶级索引块是否已调入内存） 存储空间管理——管理空闲磁盘块 划分与初始化 将物理磁盘分成一个个文件卷（逻辑卷、逻辑盘） 初始化：将各个文件卷划分为目录区（文件目录信息FCB、磁盘储存空间管理的信息）、文件区（存放文件数据） 一个物理磁盘可以划分成多个逻辑磁盘；也可以将多个物理磁盘合并成一个逻辑磁盘 管理方法 空闲表法： 适用于连续分配方式 第一个空闲盘块号 空闲磁盘数 与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况一一 回收区的前后都没有相邻空闲区； 回收区的前后都是空闲区； 回收区前面是空闲区； 回收区后面是空闲区。 总之，回收时需要注意表项的合并问题。 空闲链表法： 空闲盘块链：以盘块为单位组成一条空闲链 适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作 分配：如果申请K个盘块，则从链头开始依次摘下K个盘块进行分配，并修改空闲链的链头指针 回收：将回收的盘块依次挂到链尾，并修改空闲链的链尾指针 空闲盘区链：以盘区为单位组成一条空闲链 操作系统保存着链头、链尾指针。 如何分配：若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。 如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。 位示图法： 每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中个字的字长是16位，字中的每一位对应一个盘块。因此可以用**（字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号）** 重要重要重要：要能自己推出盘块号与（字号位号）相互转换的公式注意题目条件：盘块号、字号、位号到底是从0开始还是从1开始 如本例中盘块号、字号、位号从0开始，若n表示字长，则（字号，位号）=（i，j)的二进制位对应的盘块号b=n*i+j， b号盘块对应的字号i=b/n取整数部分，位号j=b%n 如何分配：若文件需要κ个块，①顺序扫描位示图，找到K个相邻或不相邻的“0”；②根据字号、位号算出对应的盘块号，将相应盘块分配给文件； ③将相应位设置为“1 如何回收：①根据回收的盘块号计算出对应的字号、位号；②将相应二进制位设为“0 成组链接法： 前两者不适用于大型文件系统，因为空闲表或者空闲链表可能会太大。Unix中采用了成组链接法对磁盘空闲块进行管理 文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入內存。并且要保证内存与外存中的“超级块”数据一致。 一个分组中的块号不需要连续 当前组的空闲盘块数有上限大小 超级块记录着当前组空闲块的信息： 空闲盘块数、空闲块号（地址） 分配过程： Eg：需要1个空闲块 ①检查第一个分组的块数是否足够。1&lt;10，因此是足够的。 Eg：需要100个空闲块 ①检查第一个分组的块数是否足够。100=100，是足够的。 ②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块（超级块相当于是个链头）中。 回收过程： Eg：假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块 Eg：假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第个分组 文件操作 创建文件 参数： 文件大小 存放路径 文件名 操作系统的过程 在外存中找到文件所需的空间–&gt;根据文件存放信息找到该目录对应的目录信息（在目录中创建该文件对应的目录项） 删除文件 参数： 文件存放路径 文件名 根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项–&gt;根据目录项记录的外存位置、文件大小等信息，回收文件占用的磁盘块–&gt;从目录表中删除文件对应的目录项 打开文件 参数： 文件存放路径 文件名 对文件的操作类型 操作系统： 根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限-----&gt;将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文表的编号来指明要操作的文件。 系统的“打开文件表” 编号（索引号也叫文件描述符）、文件名、外存地址、打开计数器 用户进程A的“打开文件表” 编号， 文件名， 读写指针， 访问权限， 系统表索引号 关闭文件 进程使用完文件后，要“关闭文件”操作系统在处理Cose系统调用时，主要做了几件事： 将进程的打开文件表相应表项删除 回收分配给该文件的内存空间等资源 系统打开文件表的打开计数器 count减1，若 count=0，则删除对应表项 文件共享 多个用户共享同一个文件，意味着系统中**只有“一份”**文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。 与“复制”区分：如果是多个用户都“复制”了同一个文件，那么系统中会有“好几份文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。 基于索引结点的共享方式（硬链接） 索引节点记录cnt：用于表示链接到本索引结点上的用户目录项数 不同用户对于该共享文件的命名可以是不同的 索引节点指向的是真实地文件 基于符号链的共享方式（软链接） 索引节点指向地是Link类型地文件，它记录了真实文件的存放路径（相当于windows的快捷方式）——比硬链接经历的磁盘IO更多 即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项） 文件保护 口令保护 优点：保存口令的空间开销不多，验证口令的时间开销也很小。 缺点：正确的“口令”存放在系统内部，不够安全。 加密保护 优点：保密性强，不需要在系统中存储“密码” 缺点：编码/译码，或者说加密/解密要花费一定时间。 访问控制：ACL访问控制列表 读、写、执行、添加、删除、列表文件夹内容 精简的访问列表——组：完全控制：执行、修改、读、写（2^4=0-7） 磁盘 结构 磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据 磁道：磁盘的盘面被划分成一个个磁道这样的一个“圈”就是一个磁道 扇区：一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同（如1KB） 最内侧的扇区面积最小，因此数据密度最大 盘面：一个盘片会有多个盘面 柱面：所有盘面中相对位置相同的磁道组成柱面 磁盘的物理地址：可用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块”。在“文件的物理结构”小节中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成**（柱面号，盘面号，扇区号）**的地址形式。 如何读取数据：磁盘转起来，让磁头从目标扇区上划过，才能完成对扇区的读写操作： 可根据该地址读取一个“块” ①根据“柱面号”移动磁臂，让磁头指向指定柱面； ②激活指定盘面对应的磁头； ③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。 分类： 固定头磁盘（每个磁道都有一个固定的磁头） 移动头磁盘（一个盘面就只有一个可移动的磁头） 固定盘磁盘 可换盘磁盘 磁盘调度 一次磁盘读/写操作需要的时间 寻找（磁道）时间TsT_sTs​：在读/写数据前，将磁头移动到指定磁道所花的时间：Ts=启动磁头臂s+n条磁道*跨越每个磁道耗时m 延迟时间TRT_RTR​：磁盘旋转，等磁头转到目标扇区所需要的时间。平均所需延迟时间TR=12∗1r=12rT_R=\\frac{1}{2}*\\frac{1}{r}=\\frac{1}{2r}TR​=21​∗r1​=2r1​，r为转速（r/s,r/min），1/r是转一圈所需要的时间，1/2是找到目标扇区平均需要转半圈。 传输时间TtT_tTt​：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N，b个字节需要b/N个磁道储存则：传输时间Tt=1r∗bN=brNT_t=\\frac{1}{r}*\\frac{b}{N}=\\frac{b}{rN}Tt​=r1​∗Nb​=rNb​， 总的平均存取时间Ta=Ts+TR+TtT_a=T_s+T_R+T_tTa​=Ts​+TR​+Tt​ 注：延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间。而可以控制的时间为寻道时间Ts，这个与磁盘调度算法直接相关 算法 先来先服务（FCFS） 优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去 缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。 最短寻找时间优先（SSTF） 优点：性能较好，平均寻道时间短 缺点：可能产生“饥饿”现象 Ｅg：本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。 扫描算法（SCAN） SSTF算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法（SCAN）的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。 优点：性能较好，平均寻道时间较短，不会产生饥饿现象 缺点：①只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。②SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了） 循环扫描算法（C-SCAN） 扫描算法（SCAN）中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。LoOK调度算法就是为了解决这个问题，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。（边移动边观察，因此叫LOOK） 优点：比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进步缩短 SCAN算法对于各个位置磁道的响应频率不平均，而 C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求 优点：比起SCAN来，对于各个位置磁道的响应频率很平均 缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。 CLOOK算法:结合LOOK和C-SCAN 若题目中无特别说明，则sCAN就是LoOK, C-SCAN就是 C-LOOK 磁盘管理 磁盘初始化： step1：进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误） Step2：将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的C盘、D盘、E盘） Step3：进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表） 引导块： 计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的 初始化程序可以放在ROM（只读存储器）中。ROM中的数据在出厂时就写入了，并且以后不能再修改注：ROM一般是出厂时就集成在主板上的===&gt; 现在的做法是：ROM只存放很小的“自举装入程序”，完整的自举程序放在磁盘的启动块（即引导块/启动分区上），启动块位于磁盘的固定位置。拥有启动分区的磁盘成为启动磁盘或系统磁盘 IO设备 使用特性进行分类 人机交互类外部设备 存储设备 网络通信设备 按信息交换的单位分类 块设备：传输速率较高，可寻址，即对它可随机地读/写任一块，如磁盘 字符设备：传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式，如键盘和鼠标、串口 IO控制器 功能 接受和识别CPU发出的命令 向CPU报告设备的状态 数据交换 地址识别 寄存器的地址 内存映像I/O：控制器中的寄存器与内存地址统编址 寄存器独立编址：控制器中的寄存器使用单独的地址 IO控制方式： 程序直接控制方式： 完成一次读/写操作的流程（见右图， Key word：轮询） CPU干预的频率：很频繁，O操作开始之前、完成之后需要CPU介入，并且在等待/O完成的过程中CpU需要不断地轮询检查。 数据传送的单位：每次读/写一个字 数据的流向 读操作（数据输入）：I/O设备→CPU→内存 写操作（数据输出）：内存→CPU→I/O设备 每个字的读/写都需要CPU的帮助读入下个字 主要缺点和主要优点 优点：实现简单。在读/写指令之后，加上实现循环检查的 系列指令即可（因此才称为“程序直接控制方式”） 缺点：CPU和i/o设备只能串行工作，CPU需要一直轮询检查， 长期处于“忙等”状态，CPU利用率低。 中断驱动方式 ①CPU会在每个指令周期的末尾检查中断； ②中断处理过程中需要保存、恢复逑程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发的频率太高，也会降低系统性能。 完成一次读/写操作的流程（见右图， Key word：中断） CPU干预的频率 每次o操作开始之前、完成之后需要CPU介入 等待0完成的过程中CPU可以切换到别的进程执行。 数据传送的单位 每次读/写一个字 数据的流向 读操作（数据输入）：V/O设备→CPU→内存 写操作（数据输出）：内存→CPU→1/O设备 主要缺点和主要优点 优点：与“程序直接控制方式”相比，在“中断驱动方式”中，Ⅵo控制器会通过中断信号主动报告O已完成，CPU不再需要不停地轮询CPU和i/o设备可并行工作，CPU利用率得到明显提升。 缺点：每个字在O设备与内存之间的传输，都需要经过cPU。而频繁的中断处理会消耗较多的CPU时间 DMA方式：直接存储器存取 ①数据的传送单位是“块”，不再是一个字、一个字的传送（写入内存时是一块写入的，但从设备到DMA控制器读取数据时仍然是一个字一个字读取or写入的）；每次读写 ②数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥” ③仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。 DR（ Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。 MAR（ Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应放到内存中的什么位置；输出时MAR表示要输出的数据放在内存中的什么位置。 DC（ Data Counter，数据计数器）：表示剩余要读/写的字节数。 CR（ Command Register，命令/态寄存器）：用于存放CPU发来的/O命令，或设备的状态信息。 CPU干预的频率:仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。 数据传送的单位:每次读/写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的） 数据的流向（不再需要经过cPU） 读操作（数据输入）：U/O设备→内存 写操作（数据输出）：内存→/O设备 主要缺点和主要优点优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过Cpu再写入内存，数据传输效率进一步增加。CPU和/O设备的并行性得到提升。 缺点：cPU每发出一条IO指令，只能读/写一个或多个连续的数据块如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条IO指令，进行多次中断处理才能完成。 通道控制方式 通道：一种硬件，可以理解为是“弱鸡版的CpU”。通道可以识别并执行一系列通道指令 相比DMA，通道可以识别指令 CPU干预的频极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。 数据传送的单位每次读/写一组数据块 数据的流向（在通道的控制下进行）读操作（数据输入）：1/O设备→内存写操作（数据输出）：内存IO设备 主要缺点和主要优点缺点：实现复杂，需要专门的通道硬件支持 优点：CPU、通道、1/O设备可并行工作，资源利用率很高。 缓冲区 缓和CPU与IO设备之间速度不匹配的矛盾 减少对CPU的中断频率，放宽对CPU中断相应时间的限制 解决数据粒度不匹配的问题 提高CPU与IO设备之间的并行性 缓冲策略 单缓冲：假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块） 双缓冲： 循环缓冲 缓冲池 附录 Q: 显示器和键盘是终端TTY设备 Q:解决临界区问题要满足三个条件：互斥（Mutual Exclusion）、空闲让进/前进（Progress）、有限等待（Bounded Waiting） 最短任务优先(SJF)调度策略平均周转时间最优性","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"学习画好架构图","slug":"学习画好架构图","date":"2021-08-24T06:57:11.000Z","updated":"2022-02-27T15:15:10.449Z","comments":true,"path":"2021/08/24/学习画好架构图/","link":"","permalink":"https://nymrli.top/2021/08/24/学习画好架构图/","excerpt":"","text":"一图胜万语，做好一张架构图能让别人一眼就清晰地弄懂程序的功能与依赖，大大降低大家的理解成本和提升沟通效率。但作为新人而言，如何画出要点，提炼出核心概念是个有难度的事。 什么是架构？ 架构是结构和愿景，是对系统中的实体以及实体之间的关系所进行的抽象描述，是一系列的决策。 系统架构是概念的体现，是对物/信息的功能与形式元素之间的对应情况所做的分配，是对元素之间的关系以及元素同周边环境之间的关系所做的定义。 什么是架构图？ 系统架构图是为了抽象地表示软件系统的整体轮廓和各个组件之间的相互关系和约束边界，以及软件系统的物理部署和软件系统的演进方向的整体视图。 架构图的作用 要让干系人理解、遵循架构决策，就需要把架构信息传递出去。架构图就是一个很好的载体。那么，画架构图是为了： 解决沟通障碍 达成共识 减少歧义 架构核心要素 综合上述各种权威定义，软件系统的架构通常需要包含如下四类核心要素： 元素（elements）：将系统拆分为一组元素 - 模块、组件、结构体、子系统； 关系（relationships）：不同元素之间的关系 - 交互、依赖 、继承、组合、聚合； 属性（properties）：每个元素具备的属性 - 名称、职责、接口、实现限制等； 原理（principles）：为什么这么设计 - 拆分依据、设计原则、决策原因等。 架构图分类 搜集了很多资料，分类有很多，有一种比较流行的是4+1视图，分别为场景视图、逻辑视图、物理视图、处理流程视图和开发视图。 from：如何画好软件项目架构图？， 架构制图：工具与方法论 附录 五种常见软件架构 分层架构 事件驱动架构 微核架构 微服务架构 云架构 架构图example： 架构文章 【超赞】技术架构的战略和战术原则 画一手好的架构图是码农进阶的开始 [译] 我做基础架构学到的42件事","categories":[],"tags":[{"name":"福利","slug":"福利","permalink":"https://nymrli.top/tags/福利/"}]},{"title":"AOP学习","slug":"AOP学习","date":"2021-08-19T08:35:08.000Z","updated":"2021-09-09T05:12:21.789Z","comments":true,"path":"2021/08/19/AOP学习/","link":"","permalink":"https://nymrli.top/2021/08/19/AOP学习/","excerpt":"","text":"AOP学习 AOP 要素 Aspect切面：是切入点和通知的抽象——切面则是横切关注点的抽象，与类相似，类是对物体特征的抽象，切面则是横切关注点抽象。 切入点PointCut：定义要拦截哪些类的哪些方法 切入点表达式@Pointcut(&quot;execution(* com.service.*.*(..))&quot;) 执行exectution后的第一个参数代表的是方法的修饰范围（public、private、protected）,第二个表示拦截的方法，第一个*表示所有类，第二个*表示所有的方法，括号中的…表示任意参数 常用的切入点表达式有： execution(public *(..))执行所有公有方法 execution(* set(..))执行所有set方法 execution(* com.service.*.*(..))执行包下任意类的任意方法 execution(* com.service..*.*(..))设定指定包及其子包的任意类的任意方法 通知Advice：定义了拦截之后要做什么 Target（目标对象）:被代理的目标对象 Weave（织入）:将切面应用到目标对象并生成代理对象的这个过程即为织入 from: 程序员大神修炼秘籍 Spring AOP HelloWorld 应用场景 通知类型 JAVA中的AOP 应用最为广泛的主要包括AspectJ、Spring AOP和JBoss AOP等 AspectJ采用了源代码生成技术来实现AOP，静态织入的方式 Spring AOP和JBoss AOP在实现上属于动态织入的方式 demo code: B站最详细 Spring AOP+Spring 定时任务教程 【涨薪必备】带你一步一步搞定吃透Spring SpringAOP Spring技术自定义注解和Aop实现事务框架，阿里P7都要掌握的技术~——结合Aop技术，实现注解分析 一分钟学会自定义注解注入Spring IoC 容器——将自定义注解修饰的类注入到Ioc容器中","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://nymrli.top/tags/Spring/"}]},{"title":"JWT使用学习","slug":"JWT使用学习","date":"2021-08-11T08:44:17.000Z","updated":"2021-12-05T14:44:02.515Z","comments":true,"path":"2021/08/11/JWT使用学习/","link":"","permalink":"https://nymrli.top/2021/08/11/JWT使用学习/","excerpt":"","text":"JWT: Json Web Token 与普通Token一样都是访问资源的令牌，都可以记录用户信息，都是只有验证成功后才可以获取信息。 不同的是普通Token，服务端验证token信息时要进行数据库查询操作；JWT验证token信息就不用，在服务端使用密钥校验就可以，不用经过数据库查询。==》它是一个数字签名 JWT信息组成 JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是： Header Header header典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。 Payload Payload JWT的第二部分是payload，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。 Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。 12345678910111213&#123; // 这部分是Registered claims &quot;iss&quot;: &quot;Online JWT Builder&quot;, // 该JWT的签发者 &quot;iat&quot;: 1416797419, // iat(issued at): 在什么时候签发的(UNIX时间) &quot;exp&quot;: 1448333419, // 什么时候过期，这里是一个Unix时间戳 &quot;aud&quot;: &quot;www.example.com&quot;, // 接收该JWT的一方 &quot;sub&quot;: &quot;jrocket@example.com&quot;, // 该JWT所面向的用户// 这部分是Public claims &quot;GivenName&quot;: &quot;Johnny&quot;, &quot;Surname&quot;: &quot;Rocket&quot;, &quot;Email&quot;: &quot;jrocket@example.com&quot;, &quot;Role&quot;: [ &quot;Manager&quot;, &quot;Project Administrator&quot; ] &#125; Public claims : 可以随意定义。 Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。 下面是一个例子： Signature 签名秘钥。 为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。 注： 不要在JWT的payload或header中放置敏感信息，除非它们是加密的。 然后对每一部分进行base64加密，再通过.组合即可得到JWT。 因此，一个典型的JWT看起来是这个样子的：xxxxx.yyyyy.zzzzz JWT网络工作流程 使用场景： Authorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。 Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWT可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。 https://jwt.io/ JSON Web Tokens是如何工作的 在认证的时候，当用户用他们的凭证成功登录以后，一个JSON Web Token将会被返回。此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。一般而言，你保存令牌的时候不应该超过你所需要它的时间。 无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在**Authorization header(授权头)**中，用Bearer schema。 服务器上的受保护的路由将会检查Authorization header中的JWT是否有效，如果有效，则用户可以访问受保护的资源。如果JWT包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。 如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。 这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。 基于Token的身份认证 与 基于服务器的身份认证 的区别: 基于服务器的身份认证方式存在一些问题： Sessions : 每次用户认证通过以后，服务器需要创建一条记录保存用户信息，通常是在内存中，随着认证通过的用户越来越多，服务器的在这里的开销就会越来越大。 Scalability : 由于Session是在内存中的，这就带来一些扩展性的问题。 CORS : 当我们想要扩展我们的应用，让我们的数据被多个移动设备使用时，我们必须考虑跨资源共享问题。当使用AJAX调用从另一个域名下获取资源时，我们可能会遇到禁止请求的问题。 CSRF : 用户很容易受到CSRF攻击。 JWT与Session的差异 它们都是存储用户信息；然而，Session是在服务器端的，客户端只有session id，而JWT是在客户端的。 Session方式存储用户信息的最大问题在于要占用大量服务器内存，增加服务器的开销。而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。 基于Token的身份认证是无状态的，服务器或者Session中不会存储任何用户信息，即没有会话的概念 用Token的好处 无状态和可扩展性：Tokens存储在客户端。完全无状态，可扩展。我们的负载均衡器可以将用户传递到任意服务器，因为在任何地方都没有状态或会话信息。 安全：Token不是Cookie。（The token, not a cookie.）每次请求的时候Token都会被发送。而且，由于没有Cookie被发送，还有助于防止CSRF攻击。即使在你的实现中将token存储到客户端的Cookie中，这个Cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话! 还有一点，token在一段时间以后会过期，这个时候用户需要重新登录。这有助于我们保持安全。还有一个概念叫token撤销，它允许我们根据相同的授权许可使特定的token甚至一组token无效。 JWT与OAuth的区别 OAuth2是一种授权框架 ，JWT是一种认证协议 -无论使用哪种方式切记用HTTPS来保证数据的安全性 OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)，而JWT是用在前后端分离, 需要简单的对后台API进行保护时使用。 优点 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。 因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。 便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。 它不需要在服务端保存会话信息, 所以它易于应用的扩展 from：五分钟带你了解啥是JWT 附录 几种常用的认证机制 HTTP Basic Auth HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth OAuth OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。 这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用； Cookie Auth Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效； Token Auth Token机制相对于Cookie机制又有什么好处呢？ 支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输. 无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息. 更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可. 去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可. 更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。 CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。 性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多. 不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理. 基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）. JSON WebToken Auth 使用java库来生成JWT JJWT 加密生成JWT 解密JWT JAVA JWT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class JWTUtil &#123; // 过期时间5分钟 private static final long EXPIRE_TIME = 5*60*1000; /** * 校验token是否正确 * @param token 密钥 * @param secret 用户的密码 * @return 是否正确 */ public static boolean verify(String token, String username, String secret) &#123; try &#123; Algorithm algorithm = Algorithm.HMAC256(secret); JWTVerifier verifier = JWT.require(algorithm) .withClaim(\"username\", username) .build(); DecodedJWT jwt = verifier.verify(token); return true; &#125; catch (Exception exception) &#123; return false; &#125; &#125; /** * 获得token中的信息无需secret解密也能获得 * @return token中包含的用户名 */ public static String getUsername(String token) &#123; try &#123; DecodedJWT jwt = JWT.decode(token); return jwt.getClaim(\"username\").asString(); &#125; catch (JWTDecodeException e) &#123; return null; &#125; &#125; /** * 生成签名,5min后过期 * @param username 用户名 * @param secret 用户的密码 * @return 加密的token */ public static String sign(String username, String secret) &#123; try &#123; Date date = new Date(System.currentTimeMillis()+EXPIRE_TIME); Algorithm algorithm = Algorithm.HMAC256(secret); // 附带username信息 return JWT.create() .withClaim(\"username\", username) .withExpiresAt(date) .sign(algorithm); &#125; catch (UnsupportedEncodingException e) &#123; return null; &#125; &#125;&#125; JS——jsonwebtoken 1234567891011121314151617181920212223242526272829303132333435363738var express = require(\"express\")var jwt = require(\"jsonwebtoken\")var app = express()app.use(express.json())var secret = \"1234565\"app.get(\"/login\", (req, res) =&gt; &#123; var name = req.query.name; var pass = req.query.pass; console.log(\"url: \", req.method, req.url); console.log(\"queryString: \", req.query); console.log(\"headers: \", req.headers); console.log(\"body: \", req.body); if (name == \"mrli\" &amp;&amp; pass == \"aaa123123\") &#123; var token = jwt.sign(&#123; name &#125;, secret) res.send(&#123; token &#125;) &#125; else &#123; // res.sendStatus(401) res.json(&#123; code: 200, msg: \"401\" &#125;) &#125;&#125;)app.get(\"/bearer\", (req, res) =&gt; &#123; try &#123; var token = req.headers.authorization.split(\" \")[1]; var decode_data = jwt.verify(token, secret) console.log(decode_data.name); res.send(\"操作成功\") &#125; catch (e) &#123; res.send(401) &#125;&#125;)app.listen(8080)","categories":[],"tags":[]},{"title":"Shiro使用学习","slug":"Shiro使用学习","date":"2021-08-11T07:39:08.000Z","updated":"2021-09-07T10:18:38.073Z","comments":true,"path":"2021/08/11/Shiro使用学习/","link":"","permalink":"https://nymrli.top/2021/08/11/Shiro使用学习/","excerpt":"","text":"Apache Shiro 是一个强大易用的 Java 安全框架，提供了认证、授权、加密和会话管理等功能（如下图），对于任何一个应用程序，Shiro 都可以提供全面的安全管理服务。并且相对于其他安全框架，Shiro 要简单的多。 Shiro 的架构 从外部来看应该具有非常简单易于使用的 API，且 API 契约明确；从内部来看的话，其应该有一个可扩展的架构，即非常容易插入用户自定义实现， 交互流程如下： 应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject。 Subject：主体，代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者； SecurityManager：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器； Realm：域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。 ★也就是说对于我们而言，最简单的一个 Shiro 应用： 应用代码通过 Subject 来进行认证和授权，而 Subject 又委托给 SecurityManager； 我们需要给 Shiro 的 SecurityManager 注入 Realm，从而让 SecurityManager 能得到合法的用户及其权限进行判断。 具体的架构设计与组件： Subject：主体，可以看到主体可以是任何可以与应用交互的 “用户”； SecurityManager：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。 Authenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了； Authorizer：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能； Realm：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm； Realm Realm：域，Shiro 从 Realm获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。 身份验证 身份验证和授权是Shiro两个主要的功能。 身份验证，即在应用中谁能证明他就是他本人。一般提供如他们的身份 ID 一些标识信息来表明他就是他本人，如提供身份证，用户名 / 密码来证明。 在 shiro 中，用户需要提供 principals （身份）和 credentials（证明）给 shiro，从而应用能验证用户身份： principals：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但只有一个 Primary principals，一般是用户名 / 密码 / 手机号。 credentials：证明 / 凭证，即只有主体知道的安全值，如密码 / 数字证书等。 身份认证流程 流程如下： 首先调用 Subject.login(token) 进行登录，其会自动委托给 Security Manager，调用之前必须通过 SecurityUtils.setSecurityManager() 设置； SecurityManager 负责真正的身份验证逻辑；它会委托给 Authenticator 进行身份验证； Authenticator 才是真正的身份验证者，Shiro API 中核心的身份认证入口点，此处可以自定义插入自己的实现； Authenticator 可能会委托给相应的 AuthenticationStrategy 进行多 Realm 身份验证，默认 ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm 身份验证； Authenticator会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回 / 抛出异常表示身份验证成功了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问。 授权 from： w3cschool Shiro教程文档 附录 官方十分钟教程-独立程序篇 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// Quickstart.javapublic class Quickstart &#123; private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class); public static void main(String[] args) &#123; // The easiest way to create a Shiro SecurityManager with configured // realms, users, roles and permissions is to use the simple INI config. // We'll do that by using a factory that can ingest a .ini file and // return a SecurityManager instance: /** * 这是最简单的方法通过配置去创建一个Shiro SecurityManager。 * realms， users， roles 和 permissions都是通过这个简单的ini文件配置的 * 我们通过使用工厂方式读取配置文件并获取一个SecurityManager实例 */ // Use the shiro.ini file at the root of the classpath // 使用classpaht根目录的shiro.ini文件 // (file: and url: prefixes load from files and urls respectively): // file: 和url: 这两个前缀分别从files和urls加载的 IniSecurityManagerFactory factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\"); SecurityManager securityManager = factory.getInstance(); // for this simple example quickstart, make the SecurityManager // accessible as a JVM singleton. Most applications wouldn't do this // and instead rely on their container configuration or web.xml for // webapps. That is outside the scope of this simple quickstart, so // we'll just do the bare minimum so you can continue to get a feel // for things. /** * quickstart这个例子中，使用的SecurityManager是JVM单例的。许多应用程序不这样做。 * 比如要配置web.xml等。但是不在quickstart范围内。 * 我们只是最小限度的让你明白你在做什么。。。。。 */ SecurityUtils.setSecurityManager(securityManager); // Now that a simple Shiro environment is set up, let's see what you can do: // 现在一个简单的Shiro环境就已经设置好了 // get the currently executing user: // 获取当前执行的用户 Subject currentUser = SecurityUtils.getSubject(); // Do some stuff with a Session (no need for a web or EJB container!!!) // 用session做一些事，不需要web或者EJB容器就能使用session Session session = currentUser.getSession(); session.setAttribute(\"someKey\", \"aValue\"); String value = (String) session.getAttribute(\"someKey\"); if (value.equals(\"aValue\")) &#123; log.info(\"Retrieved the correct value! [\" + value + \"]\"); &#125; // let's login the current user so we can check against roles and permissions: // 用当前用户登录，检查角色和权限 if (!currentUser.isAuthenticated()) &#123; // 设置当前用户的信息// UsernamePasswordToken token = new UsernamePasswordToken(\"presidentskroob\", \"vespa\"); UsernamePasswordToken token = new UsernamePasswordToken(\"presidentskroob\", \"12345\"); // rememberMe功能 token.setRememberMe(true); try &#123; // 登录 currentUser.login(token); // 登录失败的一些异常捕获 &#125; catch (UnknownAccountException uae) &#123; log.info(\"There is no user with username of \" + token.getPrincipal()); &#125; catch (IncorrectCredentialsException ice) &#123; log.info(\"Password for account \" + token.getPrincipal() + \" was incorrect!\"); &#125; catch (LockedAccountException lae) &#123; log.info(\"The account for username \" + token.getPrincipal() + \" is locked. \" + \"Please contact your administrator to unlock it.\"); &#125; // ... catch more exceptions here (maybe custom ones specific to your application? catch (AuthenticationException ae) &#123; //unexpected condition? error? &#125; &#125; //say who they are: //print their identifying principal (in this case, a username): // 获取当事人。。 这个例子就是username log.info(\"User [\" + currentUser.getPrincipal() + \"] logged in successfully.\"); //test a role: // 测试角色 if (currentUser.hasRole(\"schwartz\")) &#123; log.info(\"May the Schwartz be with you!\"); &#125; else &#123; log.info(\"Hello, mere mortal.\"); &#125; //test a typed permission (not instance-level) // 测试权限，不是实例级别 if (currentUser.isPermitted(\"lightsaber:wield\")) &#123; log.info(\"You may use a lightsaber ring. Use it wisely.\"); &#125; else &#123; log.info(\"Sorry, lightsaber rings are for schwartz masters only.\"); &#125; //a (very powerful) Instance Level permission: // 实例级别 if (currentUser.isPermitted(\"winnebago:drive:eagle5\")) &#123; log.info(\"You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'. \" + \"Here are the keys - have fun!\"); &#125; else &#123; log.info(\"Sorry, you aren't allowed to drive the 'eagle5' winnebago!\"); &#125; //all done - log out! // 退出 currentUser.logout(); System.exit(0); &#125;&#125; 配置文件 shiro.ini编写 12345678910111213141516171819# -----------------------------------------------------------------------------# Users and their (optional) assigned roles# username = password, role1, role2, ..., roleN# -----------------------------------------------------------------------------[users]root = secret, adminguest = guest, guestpresidentskroob = 12345, presidentdarkhelmet = ludicrousspeed, darklord, schwartzaihe = aihe, goodguy, client# -----------------------------------------------------------------------------# Roles with assigned permissions# roleName = perm1, perm2, ..., permN# -----------------------------------------------------------------------------[roles]admin = *client = look:*goodguy = winnebago:drive:eagle5 springboot集成shrio 定义自定的Realm： 重写supports、doGetAuthorizationInfo(AuthenticationToken auth)-&gt;AuthenticatingRealm【默认使用此方法进行用户名正确与否验证】、doGetAuthorizationInfo(PrincipalCollection principals) -&gt;AuthorizingRealm 【检测用户权限的时候调用】 ： 返回值都为AuthorizationInfo 自定义Shrio过滤器集： preHandle -&gt; isAccessAllowed -&gt; executeLogin -&gt; 配置ShiroConfiguration： 创建DefaultWebSecurityManager、ShiroFilterFactoryBean这两个类型的Bean （可选）：定义自己的AuthenticationToken， 如JWTToken 在相应的接口上控制权限：注解声明式：@RequiresAuthentication、@RequiresRoles(“admin”)、@RequiresPermissions(logical = Logical.AND, value = {“view”, “edit”})、或者代码编程式：Subject subject = SecurityUtils.getSubject(); if (subject.isAuthenticated()) 认证执行过程如下： executeLogin函数中的getSubject(request, response).login(token);会调用this.securityManager.login(this, token);从而触发认证器管理器AuthenticatingSecurityManager找到认证器ModularRealmAuthenticator执行this.authenticator.authenticate(token);从而调度注册this.doSingleRealmAuthentication((Realm)realms.iterator().next(), authenticationToken)的Realm去完成认证工作：先判断当前realm是否支持解析当前出传入的AuthenticationToken，符合则调用AuthenticationInfo info = realm.getAuthenticationInfo(token);进行校验 -&gt;(AuthenticatingRealm：我们Realm继承的类) 从而调用了我们自定义重写的doGetAuthenticationInfo(AuthenticationToken auth)方法info = this.doGetAuthenticationInfo(token); 如何使用JWT做校验的流程： 在LoginController中如果用户登陆成功则返回JWT信息。 用户访问被Shrio过滤器注册的URL，则通过过滤器中执行的preHandler（设置请求头）-&gt;onHandler中会执行isAccessAllowed（规定如何通行）从而调用真正的认证判定函数executeLogin其中会调用Realm来进行login的判断（如果没有异常则表示通过） 详细的代码实践教程： https://github.com/Smith-Cruise/Spring-Boot-Shiro https://github.com/echisan/springboot-jwt-demo ——SpringSecurity demo","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"},{"name":"应用框架学习","slug":"应用框架学习","permalink":"https://nymrli.top/tags/应用框架学习/"}]},{"title":"Go的配置和使用","slug":"Go的配置和使用","date":"2021-07-27T03:10:11.000Z","updated":"2021-11-10T03:52:36.654Z","comments":true,"path":"2021/07/27/Go的配置和使用/","link":"","permalink":"https://nymrli.top/2021/07/27/Go的配置和使用/","excerpt":"","text":"Go语法学习 Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 变量声明 变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。 声明变量的一般形式是使用 var 关键字： 第一种，指定变量类型，如果没有初始化，则变量默认为零值: var identifier1, identifier2 type==&gt;bool零值为false，int为0 第二种，根据值自行判定变量类型: var v_name = value, var flag = true 使用:=, := 是一个声明语句 --&gt; intVal := 1 相等于：var intVal int和intVal =1 注：如果变量已经使用 var 声明过了，再使用 *:=* 声明变量，就产生编译错误 函数定义 123func function_name( [parameter list] ) [return_types] &#123; 函数体&#125; func：函数由 func 开始声明 function_name：函数名称，参数列表和返回值类型构成了函数签名。 parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 函数体：函数定义的代码集合。 注：Go的函数跟python一样能够返回多个返回值 Go 语言接口 Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口(并不需要指定实现的是哪个接口的方法)。 12345678910111213141516171819202122/* 定义接口 */type interface_name interface &#123; method_name1 [return_type] method_name2 [return_type] method_name3 [return_type] ... method_namen [return_type]&#125;/* 定义结构体 */type struct_name struct &#123; /* variables */&#125;/* 实现接口方法 */func (struct_name_variable struct_name) method_name1() [return_type] &#123; /* 方法实现 */&#125;...func (struct_name_variable struct_name) method_namen() [return_type] &#123; /* 方法实现*/&#125; 注： Go语言中不允许有没有使用的变量（函数可以） if和for后面必须有大括号，即使只有一句也得有大括号 slice即切片，也是一种数据结构，它是数组的抽象， 通过var identifier []type声明或者slice1 := make([]type, len)创建，如**s :=[] int {1,2,3 }** 区分于数组：var balance [10] float32、var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}、balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}、balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0} map使用： 12345// 第一种var countryCapitalMap map[string]string /*创建集合 */countryCapitalMap = make(map[string]string)// 第二种map_variable := make(map[string]string) go build和go install区别 go build 不能生成包文件, go install 可以生成包文件 go build 生成可执行文件在当前目录下； go install 生成可执行文件在bin目录下（$GOPATH/bin），如果环境变量指定了GOPATH，则可直接在cmd里输入文件，如go install mycode.go， 则编译好后可以直接在cmd里输入mycode -fpath=.., (fpath为flag要读取的参数) 区别大致与mvn package和mvn install相同，都会把工程打包成jar文件，但package的位置在root/target下面,install会安装到mvn库下 切片与数组 定义 数组是类型相同的元素的集合。例如，整数 5, 8, 9, 79, 76 的集合就构成了一个数组。Go不允许在数组中混合使用不同类型的元素（比如整数和字符串）。 切片（slice）是建立在数组之上的更方便，更灵活，更强大的数据结构。切片并不存储任何元素而只是对现有数组的引用。 声明： 1234var variable_name [SIZE] variable_type // 声明了一个长度为 3 的整型数组。数组中的所有元素都被自动赋值为元素类型的 0 值a := [3]int&#123;12, 78, 50&#125; // shorthand declaration(速记声明) to create arraya := [3]int&#123;12&#125; // 声明了一个长度为 3 的数组，但是只提供了一个初值 12。剩下的两个元素被自动赋值为 0 a := [...]int&#123;12, 78, 50&#125; // ... makes the compiler determine the length自动推导 1234567a := [5]int&#123;76, 77, 78, 79, 80&#125;var b []int = a[1:4] // 创建了一个从 a[1] 到 a[3] 的切片c := []int&#123;6, 7, 8&#125; // 创建了一个长度为 3 的 int 数组，并返回一个切片给 c。// 内置函数 func make([]T, len, cap) []T 可以用来创建切片，该函数接受长度和容量作参数，返回切片。容量是可选的，默认与长度相同。使用 make 函数将会创建一个数组并返回它的切片。i := make([]int, 5, 5) // 用 make 创建的长度和容量为5的数组并返回其切片，元素值默认为 0 值 元素类型为 T 的切片表示为： []T。 注： 数组是值类型： 在 Go 中数组是值类型而不是引用类型。这意味着当数组变量被赋值时，将会获得原数组（译者注：也就是等号右面的数组）的拷贝。新数组中元素的改变不会影响原数组中元素的值。 如果将数组作为参数传递给函数，仍然是值传递，在函数中对（作为参数传入的）数组的修改不会造成原数组的改变 切片本身不包含任何数据。它仅仅是底层数组的一个上层表示。对切片进行的任何修改都将反映在底层数组中。 想修改数组内容的时候，函数中传递数组的切片：当将一个切片作为参数传递给一个函数时，虽然是值传递，但是指针始终指向同一个数组。因此将切片作为参数传给函数时，函数对该切片的修改在函数外部也可以看到。 make golang 分配内存主要有内置函数new和make，make只能为slice, map, channel分配内存，并返回一个初始化的值。 首先来看下make有以下几种不同的用法： make(map[string]string) 缺少长度的参数，只传类型，这种用法只能用在类型为map或chan的场景，例如make([]int)是会报错的。这样返回的空间长度都是默认为0的。 make([]int, 2) 指定了长度，例如make([]int, 2)返回的是一个长度为2的slice make([]int, 2, 4) 第二参数指定的是切片的长度，第三个参数是用来指定预留的空间长度，例如a := make([]int, 2, 4), 这里值得注意的是返回的切片a的总长度是4，预留的意思并不是另外多出来4的长度，其实是包含了前面2个已经切片的个数的。所以举个例子当你这样用的时候 a := make([]int, 4, 2)，就会报语法错误。(当我们为slice分配内存的时候，应当尽量预估到slice可能的最大长度，通过给make传第三个参数的方式来给slice预留好内存空间，这样可以避免二次分配内存带来的开销，大大提高程序的性能。) 通道 123456ch1 := make(chan int) // 创建一个整型类型的通道ch2 := make(chan interface&#123;&#125;) // 创建一个空接口类型的通道, 可以存放任意格式type Equip struct&#123; /* 一些字段 */ &#125;ch2 := make(chan *Equip) // 创建Equip指针类型的通道, 可以存放*Equipch := make(chan &lt;- int, 2) // 创建一个只接收的通道，且缓冲大小为2 if 1234567if condition1 &#123; // do something&#125; else if condition2 &#123; // do something else&#125;else &#123; // catch-all or default&#125; 关键字 if 和 else 之后的左大括号{必须和关键字在同一行，如果你使用了 else if 结构，则前段代码块的右大括号}必须和 else if 关键字在同一行，这两条规则都是被编译器强制规定的。 在简单情况下，条件语句两侧的括号是可以被省略的，当条件比较复杂时，则可以使用括号让代码更易读，在使用 &amp;&amp;、|| 或 ! 时可以使用括号来提升某个表达式的运算优先级，并提高代码的可读性。 ==&gt; if后的语句必然有大括号 for 三种形式： for init; condition; post { } for condition { } for { } 跟if一样，for的执行块必须要用{}括起来，并且需要注意的是for有特定的结构，不能加小括号()! map使用 1234567891011mp := map[int]int&#123;&#125;// 遍历if _, ok := mp[i]; ok == false&#123; mp[candyType[i]] = 1&#125;// 取key长度len(mp)// 取k和vfor k := range mp&#123; fmt.Print(k)&#125; 空结构体 struct{} ▲.空结构体不占用空间 : fmt.Println(unsafe.Sizeof(struct{}{})) ==&gt; 0 空结构体的作用： 因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。一是节省资源，二是空结构体本身就具备很强的语义，即这里不需要任何值，仅作为占位符。 2.1 实现集合(Set) Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。事实上，对于集合来说，只需要 map 的键，而不需要值。即使是将值设置为 bool 类型，也会多占据 1 个字节，那假设 map 中有一百万条数据，就会浪费 1MB 的空间，因此可以将值设置为 struct{}空结构，从而减少整个数据结构的大小 2.2 不发送数据的信道(channel) 12345678910111213141516171819202122232425262728func worker(ch chan struct&#123;&#125;) &#123; &lt;-ch fmt.Println(\"do something\") close(ch)&#125;func main() &#123; ch := make(chan struct&#123;&#125;) go worker(ch) ch &lt;- struct&#123;&#125;&#123;&#125;&#125;/** Second */// 创建一个信号通道waitc := make(chan struct&#123;&#125;)// ...goroutine 1: // 发送信号: 投递元素 waitc &lt;- struct&#123;&#125; // 发送信号: 关闭 close(waitc)goroutine 2: select &#123; // 收到信号，做出对应的动作 case &lt;-waitc: &#125; 有时候使用 channel 不需要发送任何的数据，只作为通知信号用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。这种情况下，使用空结构体作为占位符就非常合适了。 这种场景我们思考下，是否一定是非 struct{} 不可？其实不是，而且也不多这几个字节的内存，所以这种情况真的就只是不关心 chan 的元素值而已，所以才用的 struct{}。 2.3 仅包含方法的结构体 在部分场景下，结构体只包含方法，不包含任何的字段。例如上面例子中的 Door，在这种情况下，Door 事实上可以用任何的数据结构替代。例如： 12type Door inttype Door bool 无论是 int 还是 bool 都会浪费额外的内存，因此呢，这种情况下，声明为空结构体是最合适的。 原理分析： 特殊变量：zerobase 空结构体是没有内存大小的结构体。这句话是没有错的，但是更准确的来说，其实是有一个特殊起点的，那就是 zerobase 变量，这是一个 uintptr 全局变量，占用 8 个字节。当在任何地方定义无数个 struct {} 类型的变量，编译器都只是把这个 zerobase 变量的地址给出去。换句话说，在 golang 里面，涉及到所有内存 size 为 0 的内存分配，那么就是用的同一个地址 &amp;zerobase 。 内存管理特殊处理 mallocgc 编译器在编译期间，识别到 struct {} 这种特殊类型的内存分配，会统统分配出 runtime.zerobase 的地址出去，这个代码逻辑是在 mallocgc 函数里面： 代码如下： 123456func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer &#123; // 分配 size 为 0 的结构体，把全局变量 zerobase 的地址给出去即可； if size == 0 &#123; return unsafe.Pointer(&amp;zerobase) &#125; // ... 小结：golang 使用 mallocgc 分配内存的时候，如果 size 为 0 的时候，统一返回的都是全局变量 zerobase 的地址。 有这种全局唯一的特殊的地址也方便后面一些逻辑的特殊处理。 from： Go 最细节篇 — 空结构体是什么? Vscode配置Go 1.首先安装好Go 2.vscode中下载Go环境插件 3.安装Go程序插件 Go语言开发的时候为我们提供诸如代码提示、代码自动补全等功能。 1234# 打开输入框ctrl + shift + p # 输入Go:Install/Update Tools ▲由于网络问题会无法安装插件，网上老版的方法是在Go目录下从github手动下载好文件，但亲测无效，转而采用新方法如下。 先设置GOPROXY 打开终端执行以下命令：go env -w GOPROXY=https://goproxy.cn,direct 环境配置中按照https://goproxy.io/zh/中写的配置Goproxy 重试下载插件 1234# 打开输入框ctrl + shift + p # 输入Go:Install/Update Tools 设置插件配置 123456789\"go.goroot\": \"\",\"go.gopath\": \"\",\"go.inferGopath\": true,\"go.autocompleteUnimportedPackages\": true,\"go.gocodePackageLookupMode\": \"go\",\"go.gotoSymbol.includeImports\": true,\"go.useCodeSnippetsOnFunctionSuggest\": true,\"go.useCodeSnippetsOnFunctionSuggestWithoutType\": true,\"go.docsTool\": \"gogetdoc\", 配置Go代码片段快捷键 还是按Ctrl/Command+Shift+P,按下图输入&gt;snippets，选择回车，然后在弹出的窗口点击选择go选项： 1234567891011121314151617181920212223&#123; \"println\":&#123; \"prefix\": \"pln\", \"body\":\"fmt.Println($0)\", \"description\": \"println\" &#125;, \"printf\":&#123; \"prefix\": \"plf\", \"body\": \"fmt.Printf(\\\"$0\\\")\", \"description\": \"printf\" &#125;, \"m\":&#123; \"prefix\": \"main\", \"body\": [ \"package main\", \"import (\\\"fmt\\\")\", \"func main() &#123;\", \"$0\", \"&#125;\" ], \"description\": \"main\" &#125;&#125; VScode配置终端 在settings.json中设置 1234// 终端设置为cmder\"terminal.integrated.shell.windows\": \"cmd.exe\",\"terminal.integrated.env.windows\": &#123;\"CMDER_ROOT\": \"E:\\\\cmder\"&#125;,\"terminal.integrated.shellArgs.windows\": [\"/k\", \"E:\\\\cmder\\\\vendor\\\\init.bat\"], from : https://www.jianshu.com/p/c3b162df3b57 vscode-go插件的这些用法 见：【教程】vscode-go插件的这些用法，你真的知道么?——图文：https://blog.csdn.net/weixin_36186183/article/details/113538572 fill stuct：输入为 接受者变量名 接受者类型 packageName.interfaceName extract to variable: go get -v github.com/godoctor/godoctor go module模块管理 go module是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。到今天Go1.14版本推出之后Go modules 功能已经被正式推荐在生产环境下使用了。 一共两种情况 在同一个模块下 各个go文件根据go.mod下定义的模块名导入即可 不在同一个模块下 将无法找到的绝对引用路径在mod中进行require重定向 12345678910111213141516171819├── p1│ ├── go.mod│ └── main.go└── p2 ├── go.mod └── p2.go// p2/go.modmodule liwenzhou.com/q1mi/p2go 1.14// p1/main.go按如下方式导入p2内容import ( \"fmt\" \"liwenzhou.com/q1mi/p2\")func main() &#123; p2.New() fmt.Println(\"main\")&#125; p1/main.go中想要导入p2.go中定义的函数。需要在moduledemo/go.mod中进行replace设置才能在moduledemo模块中使用mypackage的内容 12345// p1/go.modmodule github.com/q1mi/p1 // 当前模块名go 1.14 // go版本require \"liwenzhou.com/q1mi/p2\" v0.0.0 // 指定版本replace \"liwenzhou.com/q1mi/p2\" =&gt; \"../p2\" // 重定向模块路径，右边为文件的相对路径 https://www.liwenzhou.com/posts/Go/import_local_package_in_go_module/ 功能函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// strings库strings.Index(origin, dest)strings.Contains(origin, target)strings.Join(remainingArgs, \"-\")/*n &lt; 0 ,用 new 替换所有匹配上的 old；n=-1: 用 new 替换前 5 个匹配的 old（实际多于 5 个）fmt.Println(\"n=5: \", strings.Replace(s, old, new, 5 )) 用 new 替换前 7 个匹配上的 old，如果s中old数量不足7，则表现为全转换；*/func Replace(s, old, new string, n int) string// strings.FieldsFunc() Golang中的函数用于在每次运行的满足f(c)的Unicode代码点c处拆分给定的字符串str，并返回由str组成的切片数组。f:= func(c rune) bool &#123; return unicode.IsNumber(c) &#125; // FieldsFunc() function splits the string passed // on the return values of the function f // String will therefore be split when a number // is encontered and returns all non-numbers fmt.Printf(\"Fields are:%q\\n\", strings.FieldsFunc(\"ABC123PQR456XYZ789\", f)) // cobra是go语⾔的第三⽅命令⾏处理⼯具// os/exec包LookPath函数， LookPath在PATH环境变量命名的目录中搜索可执行文件(名为可执行文件), 然后得到输出其路径func LookPath(file string) (string, error)path, err := exec.LookPath(fmt.Sprintf(\"%s-%s\", prefix, filename))// 执行外部命令:https://blog.csdn.net/whatday/article/details/109277998cmd := exec.Command(\"/bin/sh\", \"-c\", \"ping 127.0.0.1\")// 1.后台运行Run一个命令 bash -c 方式func CmdBash(commandName string) *exec.Cmd &#123; cmd := exec.Command(\"/bin/bash\", \"-c\", commandName) fmt.Println(line)(cmd.Args) go func() &#123; var out bytes.Buffer cmd.Stdout = &amp;out cmd.Stderr = os.Stderr _ = cmd.Run() &#125;() return cmd&#125;// 2.使用管道: ps cax | grep myappfunc main() &#123; grep := exec.Command(\"grep\", \"redis\") ps := exec.Command(\"ps\", \"cax\") // Get ps's stdout and attach it to grep's stdin. pipe, _ := ps.StdoutPipe() defer pipe.Close() grep.Stdin = pipe // Run ps first. ps.Start() // Run and get the output of grep. res, _ := grep.Output() fmt.Println(string(res))&#125;// 3. 在指定位置执行命令，为cmd变量增加Dir属性即可/**Run 阻塞进程，直到命令执行结束Start 非阻塞执行- Wait 阻塞进程，等待命令执行结束, 与 Star 配合使用*/ 网络相关 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** Way 1: NewRequest */func SendDingMsg(msg string) &#123; webHook := `https://oapi.dingtalk.com/robot/send?access_token=04c381fc31944ad2905f31733e31fa15570ae12efc857062dab16b605a369e4c` content := `&#123;\"msgtype\": \"text\", \"text\": &#123;\"content\": \"`+ msg + `\"&#125; &#125;` //创建一个请求, func NewRequest(method, url string, body io.Reader) req, err := http.NewRequest(\"POST\", webHook, strings.NewReader(content)) // *Reader if err != nil &#123; // handle error &#125; client := &amp;http.Client&#123;&#125; //设置请求头 req.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\") //发送请求 resp, err := client.Do(req) //关闭请求 defer resp.Body.Close() if err != nil &#123; // handle error &#125;&#125;/** Way2 clinet.Post */client := &amp;http.Client&#123;Timeout: 5 * time.Second&#125;jsonStr, _ := json.Marshal(data) // []bytes// Post(url, contentType string, body io.Reader) resp, err := client.Post(url, contentType, bytes.NewBuffer(jsonStr)) // *Bufferif err != nil &#123; panic(err)&#125;defer resp.Body.Close()result, _ := ioutil.ReadAll(resp.Body)/** Way3. http.PostForm(url string, data url.Values) */resp, err := http.PostForm(\"http://example.com/form\", url.Values&#123;\"key\": &#123;\"Value\"&#125;, \"id\": &#123;\"123\"&#125;&#125;)/** Way4. http.Post */// Post(url, contentType string, body io.Reader) (resp *Response, err error)resp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", &amp;buf)if err != nil &#123;&#125;defer resp.Body.Close()body, err := ioutil.ReadAll(resp.Body)fmt.Println(string(body)) // Get方法 req, err := http.Get(URL) 注： 可以看出来http.NewRequest和http.Post参数中的io.Reader接口都被Reader和Buffer实现了，因此可以传入strings.NewReader和bytes.NewBuffer 如果只需要设置Content-Type那么可以使用http.Post；如果想要设置更多的请求头，那么目前来看只能使用http.NewRequest http.NewRequst+client.Do：(请求方式，URL，参数)+加请求头 http.Post：（URL，content-type，data io.Reader） http.PostForm：（URL, data url.Values） clinet.Post：（URL，content-type，data io.Reader），可以设置请求超时时间 返回值都是(resp *Response, err error)，要想读取其内容，需要通过ioutil.ReadAll(resp.Body)得到[]byte 的content，然后再将content通过string(content)转成string类型的结果 对于data传参，我们希望的是能够像Python一样直接构造Dict那么简洁，而看了上述三个方法，其中url.Values是最像的。可以看到http.PostForm是可以传url.Values的，这应该是种更专门的封装。而针对其他情况下来看，NewRequest明显更普遍适用些。好在的是，http的网络请求，data都可以以strings.NewReader(string)的形式传出，因此虽然没办法直接写Json形式的Dict，但也给了我们大差不差的方式，将JsonDict用字符串来表示 优秀代码 K8S： 接口的使用与实现 + 结构体 ===&gt; 类 类Student的构造函数: NewStudent，如options.go下定义了struct Options，然后又定义了NewOptions 除了以类的方式暴露成员函数，还可以以package.FuncName，如scheduler.New(…,scheduler.WithPodInitialBackoffSeconds(),) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// PluginHandler is capable of parsing command line arguments// and performing executable filename lookups to search// for valid plugin files, and execute found plugins.type PluginHandler interface &#123; // exists at the given filename, or a boolean false. // Lookup will iterate over a list of given prefixes // in order to recognize valid plugin filenames. // The first filepath to match a prefix is returned. Lookup(filename string) (string, bool) // Execute receives an executable's filepath, a slice // of arguments, and a slice of environment variables // to relay to the executable. Execute(executablePath string, cmdArgs, environment []string) error&#125;// DefaultPluginHandler implements PluginHandlertype DefaultPluginHandler struct &#123; ValidPrefixes []string&#125;// NewDefaultPluginHandler instantiates the DefaultPluginHandler with a list of// given filename prefixes used to identify valid plugin filenames.func NewDefaultPluginHandler(validPrefixes []string) *DefaultPluginHandler &#123; return &amp;DefaultPluginHandler&#123; ValidPrefixes: validPrefixes, &#125;&#125;// Lookup implements PluginHandlerfunc (h *DefaultPluginHandler) Lookup(filename string) (string, bool) &#123; for _, prefix := range h.ValidPrefixes &#123; path, err := exec.LookPath(fmt.Sprintf(\"%s-%s\", prefix, filename)) if err != nil || len(path) == 0 &#123; continue &#125; return path, true &#125; return \"\", false&#125;// Execute implements PluginHandlerfunc (h *DefaultPluginHandler) Execute(executablePath string, cmdArgs, environment []string) error &#123; // Windows does not support exec syscall. if runtime.GOOS == \"windows\" &#123; cmd := exec.Command(executablePath, cmdArgs...) cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.Stdin = os.Stdin cmd.Env = environment err := cmd.Run() if err == nil &#123; os.Exit(0) &#125; return err &#125; // invoke cmd binary relaying the environment and args given // append executablePath to cmdArgs, as execve will make first argument the \"binary name\". return syscall.Exec(executablePath, append([]string&#123;executablePath&#125;, cmdArgs...), environment)&#125; Golang新手可能会踩的50个坑： https://www.topgoer.com/资料下载/Golang新手可能会踩的50个坑.html golang命令行库Cobra的使用 Cobra提供简单的接口来创建强大的现代化CLI接口，比如git与go工具。Cobra同时也是一个程序, 用于创建CLI程序 Cobra提供的功能 ▲.简易的子命令行模式，如 app server， app fetch等等 完全兼容posix命令行模式 ▲.嵌套子命令subcommand 支持全局，局部，串联flags ▲.使用Cobra很容易的生成应用程序和命令，使用cobra create appname和cobra add cmdname ▲.如果命令输入错误，将提供智能建议，如 app srver，将提示srver没有，是否是app server ▲.自动生成commands和flags的帮助信息 ▲.自动生成详细的help信息，如app help 自动识别-h，–help帮助flag ▲.自动生成应用程序在bash下命令自动完成功能 自动生成应用程序的man手册 命令行别名 零活定义help和usage信息 可选的紧密集成的viper apps 概念 Cobra是建立在结构的命令、参数和标志之上。 命令代表操作,参数和标志是这些行动的修饰符。 最好的应用程序就像读取句子。用户会知道如何使用本机应用程序，因为他们将理解如何使用它。 比如下面的例子，server是命令，port是标志:hugo server --port=1313 安装 使用Cobra很简单。首先，使用go get安装最新版本 1go get -u github.com/spf13/cobra 然后在你项目里引用Cobra 1import \"github.com/spf13/cobra\" 使用Cobra库 使用Cobra，需要创建一个空的main.go文件和一个rootCmd文件。你可以选择在合适的地方添加额外的命令。 基本使用 创建rootCmd Cobra不需要特殊的构造函数。简单的就可以创建你的命令。 理想情况下你把这个放在在 app/cmd/root.go 1234567891011121314151617var rootCmd = &amp;cobra.Command&#123; Use: \"hugo\", Short: \"Hugo is a very fast static site generator\", Long: `A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://hugo.spf13.com`, Run: func(cmd *cobra.Command, args []string) &#123; // Do Stuff Here &#125;,&#125;func Execute() &#123; if err := rootCmd.Execute(); err != nil &#123; fmt.Println(err) os.Exit(1) &#125;&#125; 你会另外定义标志和处理配置init()函数。 所以cmd/root.go下完整的rootCmd为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package cmdimport ( \"fmt\" \"os\" \"github.com/spf13/cobra\" \"github.com/spf13/viper\")var ( // Used for flags. cfgFile string userLicense string rootCmd = &amp;cobra.Command&#123; Use: \"cobra\", Short: \"A generator for Cobra based Applications\", Long: `Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.`, &#125;)// Execute executes the root command.func Execute() error &#123; return rootCmd.Execute()&#125;func init() &#123; cobra.OnInitialize(initConfig) rootCmd.PersistentFlags().StringVar(&amp;cfgFile, \"config\", \"\", \"config file (default is $HOME/.cobra.yaml)\") rootCmd.PersistentFlags().StringP(\"author\", \"a\", \"YOUR NAME\", \"author name for copyright attribution\") rootCmd.PersistentFlags().StringVarP(&amp;userLicense, \"license\", \"l\", \"\", \"name of license for the project\") rootCmd.PersistentFlags().Bool(\"viper\", true, \"use Viper for configuration\") viper.BindPFlag(\"author\", rootCmd.PersistentFlags().Lookup(\"author\")) viper.BindPFlag(\"useViper\", rootCmd.PersistentFlags().Lookup(\"viper\")) viper.SetDefault(\"author\", \"NAME HERE &lt;EMAIL ADDRESS&gt;\") viper.SetDefault(\"license\", \"apache\") // rootCmd.AddCommand(addCmd) // rootCmd.AddCommand(initCmd)&#125;func initConfig() &#123; if cfgFile != \"\" &#123; // Use config file from the flag. viper.SetConfigFile(cfgFile) &#125; else &#123; // Find home directory. home, err := os.UserHomeDir() cobra.CheckErr(err) // Search config in home directory with name \".cobra\" (without extension). viper.AddConfigPath(home) viper.SetConfigType(\"yaml\") viper.SetConfigName(\".cobra\") &#125; viper.AutomaticEnv() if err := viper.ReadInConfig(); err == nil &#123; fmt.Println(\"Using config file:\", viper.ConfigFileUsed()) &#125;&#125; 添加version命令, cmd/version.go ： 123456789101112131415161718192021package cmdimport ( \"fmt\" \"github.com/spf13/cobra\")func init() &#123; rootCmd.AddCommand(versionCmd)&#125;var versionCmd = &amp;cobra.Command&#123; Use: \"version\", Short: \"Print the version number of Hugo\", Long: `All software has versions. This is Hugo's`, Run: func(cmd *cobra.Command, args []string) &#123; fmt.Println(\"this is cobra test\") &#125;,&#125; 外部可执行文件： 12345678package main// import \"github.com/spf13/cobra/cobra/cmd\"import \"ctest/cmd\" // ctest为mod文件中的moduleNamefunc main() &#123; cmd.Execute()&#125; 结合官网教程的视频：https://www.bilibili.com/video/BV16A41177o6?from=search&amp;seid=2094489749248420707&amp;spm_id_from=333.337.0.0 额外使用： 参数验证 123456// 默认情况下flag时可选的,如果你希望缺失flag的时候报错,可以标记为Required flags,如下rootCmd.Flags().StringVarP(&amp;Region, \"region\", \"r\", \"\", \"AWS region (required)\")rootCmd.MarkFlagRequired(\"region\")// 或者对于PersistentFlag来说rootCmd.PersistentFlags().StringVarP(&amp;Region, \"region\", \"r\", \"\", \"AWS region (required)\")rootCmd.MarkPersistentFlagRequired(\"region\") Positional and Custom Arguments 位置参数的验证,可以使用commnad的 args字段 下列验证器是内置的: NoArgs - 如果没有任何参数,command会报错 ArbitraryArgs - command接受任何参数 OnlyValidArgs - 如果有任何位置参数不在 validArgs的范围里面, command会报错 MinimumNArgs(int) - 当位置参数的个数少于n时,command 会报错 MaximumNArgs(int) - 当位置参数的个数大于n时,command会报错 ExactArgs(int) - 当位置参数的个数不正好是n个时,command会报错 ExactValidArgs(int) - 当不是正好有n个位置参数或者有任何位置参数不属于ValidArgs,command会报错. RangeArgs(min, max) - 如果参数的个数不是在min和max之间,command会报错 关于自定义验证器的一个例子: 123456789101112131415var cmd = &amp;cobra.Command&#123; Short: \"hello\", Args: func(cmd *cobra.Command, args []string) error &#123; if len(args) &lt; 1 &#123; return errors.New(\"requires a color argument\") &#125; if myapp.IsValidColor(args[0]) &#123; return nil &#125; return fmt.Errorf(\"invalid color specified: %s\", args[0]) &#125;, Run: func(cmd *cobra.Command, args []string) &#123; fmt.Println(\"Hello, World!\") &#125;,&#125; 预设定的模板方法： 123456789// 自定义的帮助，三种方式cmd.SetHelpCommand(cmd *Command)cmd.SetHelpFunc(f func(*Command, []string))cmd.SetHelpTemplate(s string)// 自定义usage, 当用户提供了一个无效的flag或者command,cobra会回复一份usagecmd.SetUsageFunc(f func(*Command) error)cmd.SetUsageTemplate(s string)// 自定义version flagcmd.SetVersionTemplate(s string) PreRun and PostRun Hooks 在你main函数里的run函数运行之前和之后,也是可以运行函数的.PersistentPreRun 和PreRun 函数会在Run之前执行,PersistentPostRun 和 PostRun会在Run之后执行. 符合Persistent*Run格式的函数如果子命令没有定义自己的Run,就会继承.这些函数的执行顺序如下: PersistentPreRun PreRun Run PostRun PersistentPostRun 比较全面的使用介绍文章：golang 命令行解析库cobra的使用 为命令增加参数比较优雅的写法，from K8S 123456789101112131415func NewProxyCommand() *cobra.Command &#123; // .... fs := cmd.Flags() opts.AddFlags(fs)&#125;func (o *Options) AddFlags(fs *pflag.FlagSet) &#123; o.addOSFlags(fs) fs.StringVar(&amp;o.ConfigFile, \"config\", o.ConfigFile, \"The path to the configuration file.\") fs.StringVar(&amp;o.WriteConfigTo, \"write-config-to\", o.WriteConfigTo, \"If set, write the default configuration values to this file and exit.\") fs.StringVar(&amp;o.config.ClientConnection.Kubeconfig, \"kubeconfig\", o.config.ClientConnection.Kubeconfig, \"Path to kubeconfig file with authorization information (the master location can be overridden by the master flag).\") fs.Float32Var(&amp;o.config.ClientConnection.QPS, \"kube-api-qps\", o.config.ClientConnection.QPS, \"QPS to use while talking with kubernetes apiserver\") fs.Var(&amp;o.config.DetectLocalMode, \"detect-local-mode\", \"Mode to use to detect local traffic\")&#125; pflag pflag和跟cobra都是spf13组织下的。cobra不但是一个功能强大的 Golang 包，还是一个 CLI 工具，可以用来生成应用程序和命令文件，如npm命令，以及子命令&lt;npm&gt; install；而pflag主要是丰富标准库中的flag包用来处理CLI参数，如--dev； pflag 包的设计目的就是替代标准库中的 flag 包，因此它具有更强大的功能并且与标准的兼容性更好。pflag 包与 flag 包的工作原理甚至是代码实现都是类似的，下面是 pflag 相对 flag 的一些优势： 支持更加精细的参数类型：例如，flag 只支持 uint 和 uint64，而 pflag 额外支持 uint8、uint16、int32 等类型。 支持更多参数类型：ip、ip mask、ip net、count、以及所有类型的 slice 类型。 兼容标准 flag 库的 Flag 和 FlagSet：pflag 更像是对 flag 的扩展。 原生支持更丰富的功能：支持 shorthand、deprecated、hidden 等高级功能。 安装：go get github.com/spf13/pflag 使用说明 最简单demo 12345678910111213141516package mainimport flag \"github.com/spf13/pflag\"// 一般都设置为全局变量, 局部变量也可// Way1. 将输入参数用变量记录var cliName = flag.StringP(\"name\", \"n\", \"Cl\", \"请输入你的名字\")// Way2. 将输入参数保存到变量指针var cliAge intfunc main() &#123; // Way2. 将输入参数保存到变量指针 flag.IntVarP(&amp;cliAge, \"age\", \"a\", 25, \"清输入你的年纪\") flag.Parse() println(*cliName) println(cliAge)&#125; 可以看到有两种赋值给变量的方式 将输入参数用变量记录 1234567// 定义命令行参数对应的变量var cliName = flag.StringP(\"name\", \"n\", \"nick\", \"Input Your Name\")var cliAge = flag.IntP(\"age\", \"a\",22, \"Input Your Age\")var cliGender = flag.StringP(\"gender\", \"g\",\"male\", \"Input Your Gender\")var cliOK = flag.BoolP(\"ok\", \"o\", false, \"Input Are You OK\")var cliDes = flag.StringP(\"des-detail\", \"d\", \"\", \"Input Description\")var cliOldFlag = flag.StringP(\"badflag\", \"b\", \"just for test\", \"Input badflag\") 将输入参数保存到变量指针 12fs.StringVar(&amp;o.ConfigFile, \"config\", o.ConfigFile, \"The path to the configuration file.\")fs.StringVar(&amp;o.WriteConfigTo, \"write-config-to\", o.WriteConfigTo, \"If set, write the default configuration values to this file and exit.\") 函数原型：func StringVar(p *string, name string, value string, usage string)，StringVar定义了一个有指定名字，默认值，和用法说明的string标签。 参数p指向一个存储标签解析值的string变量，对应的参数输入后会被保存到p变量中。 这种取地址赋值的做法，可以更好、更灵活地结构化编程。 参数输入 -- 表示完整的选项名称，e.g.--name；-表示 shorthand，e.g.-n 布尔类型的参数 布尔类型的参数有下面几种写法 123--flag // 等同于 --flag=true --flag=value--flag value // 这种写法只有在没有设置默认值时才生效 非布尔类型的参数 下面是传递参数的方式和参数最终的取值： 1234--age=30 cliAge=30--age cliAge=25--age 30 cliAge=30[nothing] cliAge=22 shorthand也是同样 1234-a=30-a-a 30[nothing] cliAge=22 标准化参数的名称 如果我们创建了名称为 --des-detail 的参数，但是用户却在传参时写成了 --des_detail 或 --des.detail 会怎么样？默认情况下程序会报错退出，但是我们可以通过 pflag 提供的 SetNormalizeFunc 功能轻松的解决这个问题： [](javascript:void(0)😉 123456789func wordSepNormalizeFunc(f *flag.FlagSet, name string) flag.NormalizedName &#123; from := []string&#123;&quot;-&quot;, &quot;_&quot;&#125; to := &quot;.&quot; for _, sep := range from &#123; name = strings.Replace(name, sep, to, -1) &#125; return flag.NormalizedName(name)&#125;flag.CommandLine.SetNormalizeFunc(wordSepNormalizeFunc) 标准化参数的名称 如果我们创建了名称为 --des-detail 的参数，但是用户却在传参时写成了 --des_detail 或 --des.detail 会怎么样？默认情况下程序会报错退出，但是我们可以通过 pflag 提供的 SetNormalizeFunc 功能轻松的解决这个问题： 123456789func wordSepNormalizeFunc(f *flag.FlagSet, name string) flag.NormalizedName &#123; from := []string&#123;\"-\", \"_\"&#125; to := \".\" for _, sep := range from &#123; name = strings.Replace(name, sep, to, -1) &#125; return flag.NormalizedName(name)&#125;flag.CommandLine.SetNormalizeFunc(wordSepNormalizeFunc) NoOptDefVal 用法 pflag 包支持通过简便的方式为参数设置默认值之外的值，实现方式为设置参数的 NoOptDefVal 属性： 12var cliAge = flag.IntP(\"age\", \"a\",22, \"Input Your Age\")flag.Lookup(\"age\").NoOptDefVal = \"25\" 下面是传递参数的方式和参数最终的取值： 1234Parsed Arguments Resulting Value--age=30 cliAge=30--age cliAge=25[nothing] cliAge=22 可见，通过NoOptDefVal可以实现bool flag的效果，即如果出现该flag则设置成NoOptDefVal值 pflag.FlagSet 命令参数flag集合 1234567891011121314// AddEtcdFlags adds flags related to etcd storage for a specific APIServer to the specified FlagSetfunc (s *EtcdOptions) AddFlags(fs *pflag.FlagSet) &#123; fs.StringSliceVar(&amp;s.EtcdServersOverrides, \"etcd-servers-overrides\", s.EtcdServersOverrides, \"\"+ \"Per-resource etcd servers overrides, comma separated. The individual override \"+ \"format: group/resource#servers, where servers are http://ip:port, semicolon separated.\") fs.StringVar(&amp;s.StorageConfig.Type, \"storage-backend\", s.StorageConfig.Type, \"The storage backend for persistence. Options: 'etcd3' (default), 'etcd2'.\") fs.IntVar(&amp;s.StorageConfig.DeserializationCacheSize, \"deserialization-cache-size\", s.StorageConfig.DeserializationCacheSize, \"Number of deserialized json objects to cache in memory.\") fs.StringSliceVar(&amp;s.StorageConfig.ServerList, \"etcd-servers\", s.StorageConfig.ServerList, \"List of etcd servers to connect with (scheme://ip:port), comma separated.\") fs.BoolVar(&amp;s.StorageConfig.Quorum, \"etcd-quorum-read\", s.StorageConfig.Quorum, \"If true, enable quorum read.\")&#125; 12345678910// AddFlags adds flags to fs and binds them to options.func (o *Options) AddFlags(fs *pflag.FlagSet) &#123; o.addOSFlags(fs) fs.StringVar(&amp;o.ConfigFile, \"config\", o.ConfigFile, \"The path to the configuration file.\") fs.StringVar(&amp;o.WriteConfigTo, \"write-config-to\", o.WriteConfigTo, \"If set, write the default configuration values to this file and exit.\") fs.StringVar(&amp;o.config.ClientConnection.Kubeconfig, \"kubeconfig\", o.config.ClientConnection.Kubeconfig, \"Path to kubeconfig file with authorization information (the master location can be overridden by the master flag).\") fs.Float32Var(&amp;o.config.ClientConnection.QPS, \"kube-api-qps\", o.config.ClientConnection.QPS, \"QPS to use while talking with kubernetes apiserver\") fs.Var(&amp;o.config.DetectLocalMode, \"detect-local-mode\", \"Mode to use to detect local traffic\")&#125;","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Go","slug":"Go","permalink":"https://nymrli.top/tags/Go/"}]},{"title":"Chrome插件编写-天猫秒杀插件","slug":"天猫秒杀插件-Chrome插件编写","date":"2021-03-03T13:37:15.000Z","updated":"2021-12-04T14:15:30.809Z","comments":true,"path":"2021/03/03/天猫秒杀插件-Chrome插件编写/","link":"","permalink":"https://nymrli.top/2021/03/03/天猫秒杀插件-Chrome插件编写/","excerpt":"","text":"chrome插件开发 借鉴TODO-List：Chrome插件开发简要指南 文件结构 在应用商店中下载下来的插件基本上都是以.crx为文件后缀，该文件其实就是一个压缩包（文件夹压缩而来），包括插件所需要的html、css、javascript、图片资源等等文件。 其中， manifest.json是整个插件的功能及文件配置清单，非常重要。 static目录是放置整个插件的静态资源文件的，包括css、js、图片等等资源 template目录是放置整个插件的功能页面模板的。 _locales目录是放置整个插件的国际化语言脚本的。 一般来说，清单文件manifest.json文件是必须的，且必须放在插件开发目录的根目录上。其他的目录都可以自定义。 弹出窗口和后台页面 弹出窗口一般用于插件和用户的交互，而后台页面一般用于插件本身做一些额外的事情。比如有时候，插件需要联网进行数据同步等操作，这种操作用户是无感知的，所有就要求插件需要有一个后台页面来运行这部分的逻辑。 其实后台页面还可以分为持久运行的后端页面和事件页面，这里对这两者就不多做说明了，更多的内容可以参阅具体的文档。 弹出式插件教程TODO-LIST manifest.json 1234567891011&#123; \"name\": \"todo-plugin\", \"version\": \"0.9.0\", \"manifest_version\": 2, \"description\": \"chrome plugin demo\", \"browser_action\": &#123; \"default_icon\": \"icon.png\", \"default_title\": \"Todo List\", \"default_popup\": \"popup.html\" &#125;&#125; popup.html 123456789101112131415161718192021222324252627282930313233&lt;style&gt; body &#123; width: 150px; &#125; #add-new-item &#123; cursor: pointer; color: #CCC; &#125; .hide &#123; display: none; &#125; .show &#123; display: block; &#125; .item &#123; cursor: pointer; margin: 5px 0; &#125; .item input &#123; display: inline-block; width: 12px; height: 12px; &#125; input &#123; width: 120px; &#125;&lt;/style&gt;&lt;div id=\"add-new-item\"&gt;添加新项&lt;/div&gt;&lt;div id=\"add-new-item-input\" class=\"hide\"&gt; &lt;input type=\"text\" id=\"new-item-title\" placeholder=\"添加新任务\"/&gt;&lt;/div&gt;&lt;div id=\"item-list\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt; main.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374(function () &#123; var $ = function (id) &#123; return document.getElementById(id); &#125;; var Tasks = &#123; show: function (obj) &#123; obj.className = ''; return this; &#125;, hide: function (obj) &#123; obj.className = 'hide'; return this; &#125;, $addNewItem: $('add-new-item'), $addNewItemInput: $('add-new-item-input'), $itemList: $('item-list'), $newItemTitle: $('new-item-title'), init: function () &#123; //打开添加文本框 Tasks.$addNewItem.addEventListener('click', function () &#123; Tasks.show(Tasks.$addNewItemInput).hide(Tasks.$addNewItem); Tasks.$newItemTitle.focus(); &#125;, true); //回车添加任务 Tasks.$newItemTitle.addEventListener('keyup', function (ev) &#123; var ev = ev || window.event; if (ev.keyCode == 13) &#123; //TODO:写入本地数据 var task = Tasks.$newItemTitle.value; Tasks.AppendHtml(task); Tasks.$newItemTitle.value = ''; Tasks.hide(Tasks.$addNewItemInput).show(Tasks.$addNewItem); &#125; ev.preventDefault(); &#125;, true); //取消添加 Tasks.$newItemTitle.addEventListener('blur', function () &#123; Tasks.$newItemTitle.value = ''; Tasks.hide(Tasks.$addNewItemInput).show(Tasks.$addNewItem); &#125;, true); //TODO 初始化数据，加载本地数据，生成html &#125;, //增加 Add: function () &#123; //TODO &#125;, //修改 Edit: function () &#123; //TODO &#125;, //删除 Del: function () &#123; //TODO &#125;, AppendHtml: function (title) &#123; var oDiv = document.createElement('div'); oDiv.className = 'item item-todo'; var oInput = document.createElement('input'); oInput.type = 'checkbox'; var oTitle = document.createElement('span'); oTitle.innerHTML = title; oDiv.appendChild(oInput); oDiv.appendChild(oTitle); Tasks.$itemList.appendChild(oDiv); oDiv.addEventListener('click', function () &#123; //TODO &#125;, true); &#125;, RemoveHtml: function () &#123; //TODO &#125; &#125; Tasks.init();&#125;)(); 天猫秒杀插件 Tmall_Kill Code Template： https://link.zhihu.com/?target=https%3A//github.com/cehui0303/Tmall_Tickets 代码比较简单，实现原理为，打开浏览器后执行插件，JS脚本将会在指定时间点击“结算”按钮，然后发起订单，从而锁定库存抢货。 main.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//定时器var timer = null;//检测状态function checkElementState(path,callback)&#123; var ele = document.querySelector(path); if(ele)&#123; callback &amp;&amp; callback(); &#125;else&#123; console.log('异步加载元素中....' + path ); setTimeout( function()&#123;checkElementState(path,callback);&#125;,200); &#125;&#125;//结算function checkOut()&#123; console.log('结算开始....'); var btn = document.getElementById('J_Go'); if(btn)&#123; btn.click(); &#125;else&#123; console.log('结算按钮没找到'); &#125;&#125;// S1: 1. 点击结算按钮 =&gt; 2. checkElementState()检测结算按钮是否加载出来 --&gt; 3.checkOut()点击结算按钮function checkOutAsync()&#123; checkElementState('#J_Go',checkOut);&#125;// S2: 提交订单function submitOrder()&#123; console.log('提交订单开始....'); checkElementState('.go-btn',function()&#123; var btn = document.querySelector(\".go-btn\"); if(btn)&#123; btn.click(); &#125;else&#123; console.log('提交订单按钮没找到'); &#125; &#125;);&#125;//目标时间 var dDate = new Date(); //10点和20点开抢 if( dDate.getHours() &lt; 10 )&#123; dDate.setHours(9,59,59.2); &#125;else&#123; dDate.setHours(19,59,59.2); &#125;//进入时间判断循环function enterTimeCheckLoop(callback)&#123; var date = new Date(); var diff = Date.parse(dDate) - Date.parse(date) ; console.log(diff); if(diff &lt; -90 )&#123; console.log('时间过了！'); &#125;else if(diff &lt; 50 ) &#123; callback &amp;&amp; callback(); console.log('时间到了！！！'); &#125;else&#123; setTimeout(function()&#123; enterTimeCheckLoop(callback);&#125;,400); &#125;&#125;//主要函数(function main()&#123; console.log('############################天猫枪杀脚本############################'); var href = window.location.href; //结算页面 if(href.indexOf('cart.tmall.com') &gt; -1 )&#123; //进入时间判断 enterTimeCheckLoop( checkOutAsync ); &#125;else if(href.indexOf('buy.tmall.com') &gt; -1 )&#123; //提交订单页面 submitOrder(); &#125;&#125;)() 这种理论上是可行的，只不过肯定会有刷新上的问题，效率不及网络请求，但思路依旧是值得学习的，因此借此机会也是学下Chrome插件的编写。 manifest.json 12345678910111213141516171819202122232425&#123; \"manifest_version\": 2, // manifest文件版本号。Chrome18开始必须为2 \"name\": \"Tmall-tickets\", // crx扩展名称 \"version\": \"1.0\", // 插件版本 \"description\": \"天猫超市枪杀脚本\", \"browser_action\": &#123; // 地址栏右侧图标管理。含图标及弹出页面的设置等 \"default_icon\": \"icon.png\" &#125;, \"content_scripts\": [ // 指定要向Web页面内注入的脚本。可注入多个css与js。 &#123; \"matches\": [\"https://chaoshi.detail.tmall.com/*\",\"https://cart.tmall.com/*\",\"https://buy.tmall.com/*\"], \"js\": [\"maotai.js\"], \"run_at\": \"document_idle\" &#125; ], \"permissions\": [ \"https://www.baidu.com/*\", \"background\", \"tabs\" ], //权限 \"plugins\": [&#123; \"path\": \"extension_plugin.dll\", \"public\": true &#125;], // 扩展。可调用第三方扩展&#125; content_scripts，其数组元素的字段有： matches：String数组，必须。定义content_scripts对哪些页面生效。其规则符合permissions的模式匹配。 css：String数组，可选。定义哪些css文件在web页面DOM创建前注入到web页面中。 js：String数组，可选。定义哪些js文件注入到web页面中。其js文件的注入顺序与数组中定义的顺序相同。至于这些js与web页面中所定义js的顺序关系，取决于run_at字段。 run_at：String，可选。定义content_scripts的注入时机，从而影响到js与web页面所定义js的顺序关系。取值有： document_start：所有css加载完毕，但DOM尚未创建时。 document_end：DOM创建完成，但图片及frame等子资源尚未加载时。 document_idle：document_end之后，window.onload之前。 默认是document_idle，也就是content_scripts的js都罗列在web页面的js之后。 all_frames：boolean，可选。是否运行在页面所有的frame中。若为false，则只运行在最上层的frame中。默认为false。 include_globs：String数组，可选。用于规定页面匹配的白名单。一个URL，必须同时满足：匹配matches，匹配include_globs白名单，不匹配exclude_globs黑名单这三个条件才可以。注意include_globs和exclude_globs中的匹配语法与permissions和matches所用的匹配模式不同。 exclude_globs：String数组，可选。用于规定页面匹配的黑名单。同⑥。 permissions：扩展所需要的权限。permissions是一个String数组，每一个权限都使用String来表示。某些权限在安装前会告知用户。 模式配匹：用于指定扩展会在哪些URL中生效。例如： background：启用扩展后端环境。即在浏览器运行期始终运行，与单个页面无关。可以在这里调用浏览器的API，通常在这里进行扩展主要逻辑的开发。配合manifest.json的background字段使用。 background： 这是一个比较重要的属性，如果你需要运行一些后台脚本，比如监听用户在扩展信息栏按下你的插件图标，或者你要监听用户新建tab页，这个时候你就需要有一个background的页面。background你可以指定一个HTML页面（如我的插件），也可以指定一个JS文件，如： 1234567891011&#123; \"name\": \"My extension\", ... \"background\": &#123; \"scripts\": [\"background.js\"] &#125;, ...&#125;// 需要注意两点：// 1、是HTML不能写JS代码，JS代码需要写到JS文件中后引入；// 2、不能使用jquery（没有详细测试，可能是我没用正确）； background.js 12345// background.js// @describtion: 监听用户在扩展信息栏按下你的插件图标时，显示当前活动页的URL：chrome.browserAction.onClicked.addListener(function (tab) &#123; alert(tab.url);&#125;); 改进Tmall_Kill 需要修改的功能为： 插件中设定时间=&gt;时间框选择时间 匹配网站自动运行-&gt;弹出页面手动点击运行 选中购物车商品后结算-&gt;到时间后自动勾选商品结算 弹出页+时间框 popup.html HTML5日期输入框(date) 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- * @Author: Mrli * @Date: 2021-03-02 17:19:02 * @LastEditTime: 2021-03-03 22:18:02 * @Description: --&gt;&lt;style&gt; body &#123; width: 250px; &#125; #add-new-item &#123; cursor: pointer; color: #CCC; &#125; .hide &#123; display: none; &#125; .show &#123; display: block; &#125; .item &#123; cursor: pointer; margin: 5px 0; &#125; .item input &#123; display: inline-block; width: 12px; height: 12px; &#125; input &#123; width: 200px; &#125;&lt;/style&gt;&lt;div id=\"add-new-item\"&gt;add new item&lt;/div&gt;&lt;div id=\"add-new-item-input\" class=\"hide\"&gt; &lt;input type=\"text\" id=\"new-item-title\" placeholder=\"add new\"/&gt;&lt;/div&gt;&lt;label for=\"meeting\"&gt;killTime:&lt;/label&gt;&lt;input id=\"meeting\" type=\"datetime-local\"/&gt;&lt;div id=\"item-list\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt; 配套的manifest.json 1234567891011&#123; \"name\": \"todo-plugin\", \"version\": \"0.9.0\", \"manifest_version\": 2, \"description\": \"chrome plugin demo\", \"browser_action\": &#123; \"default_icon\": \"icon.png\", \"default_title\": \"Todo List\", \"default_popup\": \"popup.html\" &#125;&#125; main.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374(function () &#123; var $ = function (id) &#123; return document.getElementById(id); &#125;; var Tasks = &#123; show: function (obj) &#123; obj.className = ''; return this; &#125;, hide: function (obj) &#123; obj.className = 'hide'; return this; &#125;, $addNewItem: $('add-new-item'), $addNewItemInput: $('add-new-item-input'), $itemList: $('item-list'), $newItemTitle: $('new-item-title'), init: function () &#123; //打开添加文本框 Tasks.$addNewItem.addEventListener('click', function () &#123; Tasks.show(Tasks.$addNewItemInput).hide(Tasks.$addNewItem); Tasks.$newItemTitle.focus(); &#125;, true); //回车添加任务 Tasks.$newItemTitle.addEventListener('keyup', function (ev) &#123; var ev = ev || window.event; if (ev.keyCode == 13) &#123; //TODO:写入本地数据 var task = Tasks.$newItemTitle.value; Tasks.AppendHtml(task); Tasks.$newItemTitle.value = ''; Tasks.hide(Tasks.$addNewItemInput).show(Tasks.$addNewItem); &#125; ev.preventDefault(); &#125;, true); //取消添加 Tasks.$newItemTitle.addEventListener('blur', function () &#123; Tasks.$newItemTitle.value = ''; Tasks.hide(Tasks.$addNewItemInput).show(Tasks.$addNewItem); &#125;, true); //TODO 初始化数据，加载本地数据，生成html &#125;, //增加 Add: function () &#123; //TODO &#125;, //修改 Edit: function () &#123; //TODO &#125;, //删除 Del: function () &#123; //TODO &#125;, AppendHtml: function (title) &#123; var oDiv = document.createElement('div'); oDiv.className = 'item item-todo'; var oInput = document.createElement('input'); oInput.type = 'checkbox'; var oTitle = document.createElement('span'); oTitle.innerHTML = title; oDiv.appendChild(oInput); oDiv.appendChild(oTitle); Tasks.$itemList.appendChild(oDiv); oDiv.addEventListener('click', function () &#123; //TODO &#125;, true); &#125;, RemoveHtml: function () &#123; //TODO &#125; &#125; Tasks.init();&#125;)(); 学习案例： cookies-list Chrome 插件开发不完全指南","categories":[],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://nymrli.top/tags/脚本/"}]},{"title":"认真学次DP——动态规划","slug":"认真学次DP——动态规划","date":"2021-01-24T05:27:08.000Z","updated":"2021-01-24T14:26:49.285Z","comments":true,"path":"2021/01/24/认真学次DP——动态规划/","link":"","permalink":"https://nymrli.top/2021/01/24/认真学次DP——动态规划/","excerpt":"","text":"动态规划DP 一般算法面试题解决最优化问题，有两种解决途径：暴力枚举、或者DP，由于其灵活和高效，无数程序员为它着迷，大厂面试也是必考。 但是，动态规划形式上非常多变，本质上没有套路，问题不同，动态规划的迭代方程就不同。而有些问题，对于计算机科学家，都难以找到迭代方程。因此，对于平平常常的我们，刷算法题时想不出动态规划的解法，也大可不必气馁。 DP组成——三个条件 某个问题是否能应用动态规划，通常需要满足 3 个条件： 具有最优子结构 具有无后续性 具有重复子问题 最优子结构性质：只需求得子问题的最优解后，原问题的最优解最能推导出来，这表明此问题具备最优子结构性质！ **后续状态无关性：**在具体的问题中就是，子数组的最大和，与后面的红块无关 **重复子问题：**使用暴力枚举会对很多子问题重复计算，也就是说这个问题具备重复子问题特性。而DP数组的存在可以很好的处理重复子问题计算。 DP组成——三个要素 最优子结构 边界 状态转移方程式 **最优子结构：**只需求得子问题的最优解后，原问题的最优解最能推导出来，这表明此问题具备最优子结构性质！ 边界：确定起始和终止边界 **状态转移方程式：**在某个状态下找到下一步的最佳计算结果 ▲.其中最重要的就是找到确定 状态表示f(v) 和 状态转移计算。目的是：讲究在一个有限集合的中找一个最值 状态表示f(v)：——化零为整 集合 属性： 最大、最小、count数量 状态转移计算：——化整为零 划分依据：寻找最后一个不同点。 讲究不重复、不遗漏 问题剖析 最常见的来讲解DP算法的是背包问题， 在此我们列出多个比较经典的题目： 国王和金矿、最大子数组的和、背包问题 国王和金矿 最大子数组的和： 题解：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/ ——为何在nums数组上直接做修改 123456789101112131415class Solution &#123; public int maxSubArray(int[] nums) &#123; int sz = nums.length; if ( sz == 0 ) return 0; int maxSum = nums[0]; for (int i = 1; i &lt; sz; i++) &#123; int pre = nums[i-1] &gt; 0 ? nums[i-1] : 0; nums[i] = nums[i] + pre; if (maxSum &lt; nums[i]) &#123; maxSum = nums[i]; &#125; &#125; return maxSum; &#125;&#125; 最长公共子序列问题 题目的要求是，从两个字符串中找到最长的公共子序列，出现先后顺序要求一致， 但是不要求连续。 所以下面解法定义的dp数组为，状态到text1的i字符、text2的j字符时最长的公共子序列的长度，如果当前的两个字符c1 == c2则需要在此基础上+1， 否则记为之前的两个的最大。 12345678910111213141516171819class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int len1 = text1.length(); int len2 = text2.length(); int [][]dp = new int[len1+1][len2+1]; for (int i = 0; i &lt; len1; i++) &#123; char c1 = text1.charAt(i); for (int j = 0; j &lt; len2; j++) &#123; char c2 = text2.charAt(j); if ( c1 == c2 )&#123; dp[i + 1][j + 1] = dp[i][j] + 1; &#125;else&#123; dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]); &#125; &#125; &#125; return dp[len1][len2]; &#125;&#125; 01背包问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* 01背包问题 */pair&lt;int,int&gt; wv[maxn];int N; // 物品数量int W; // 背包重量int dp[maxn][maxn]; //2.多了个记忆数组(称为DP数组)// 逆序推导void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; for( int i= N-1 ; i &gt;= 0 ; i--)&#123; for( int j=0;j&lt;= W ; j++)&#123; if( j &lt; wv[i].first ) dp[i][j] = dp[i+1][j]; else dp[i][j] = max( dp[i+1][j] , dp[i+1][j - wv[i].first] + wv[i].second); &#125; &#125; cout &lt;&lt; dp[0][W] &lt;&lt;endl;&#125;// 顺序推导void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; for( int i= 0 ; i &lt; N ; i++)&#123; // i为遍历第i个物品 for( int j=0;j&lt;= W ; j++)&#123; // j为背包可用重量 if( j &lt; wv[i].first ) dp[i+1][j] = dp[i][j]; else dp[i+1][j] = max( dp[i][j] , dp[i][j - wv[i].first] + wv[i].second); // 推导式也变了,下一行的依据上一行写成dp[i+1][j] = ... &#125; &#125; cout &lt;&lt; dp[N][W] &lt;&lt;endl; // 输出的结果变了&#125;int main()&#123; solve(); return 0;&#125; 安利一个视频：https://www.bilibili.com/video/BV1X741127ZM?from=search——金牌爷的传授 反思总结 最大子数组和，上面给出了动态规划的解法，还可以使用递归的解法，时间复杂度也是 O(n)O(n)，但是空间复杂度却为 O(n)O(n)，所以最大子数组的最好解法还是动态规划。 动态规划还常常使用表格，缓存之前各个状态的解，通过空间换取时间，这个也是动态规划常用的技巧之一，但这却不是动态规划最难构思出来的地方，最难的还是设计每个状态步的决策策略，这才是动规的精髓。 另外，不是所有的问题都有动规的解法，比如目前全世界最难求解的旅行商问题，更复杂的多线路配送问题，都属于NP问题，很难找到动态规划的解法，但是一旦找到动规解法，它会将 O(n!)O(n!) 问题降为 O(n多项式)O(n多项式) 问题，收益也是巨大的！","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://nymrli.top/tags/算法/"}]},{"title":"UML简单记录","slug":"UML简单记录","date":"2020-12-11T05:59:15.000Z","updated":"2022-02-23T01:21:42.095Z","comments":true,"path":"2020/12/11/UML简单记录/","link":"","permalink":"https://nymrli.top/2020/12/11/UML简单记录/","excerpt":"","text":"要学习设计模式，首先绕不开的就是UML图，同时对于一名开发而言，开发文档中也必然会出现UML的身影。之前在实习的时候，其实已经学过不少了，但不用后又很容易忘记，(在阿里实习的时候就以为记得很熟了，结果现在又忘了)——因此这也是一个防忘系列 UML UML(Unified Modeling Language)是一种标准的图形化建模语言，是一种为面对对象系统的产品进行说明、可视化、编制文档的标准语言，它是面向对象分析与设计的一种标准表示。 （1）UML是一种语言。 从上面的定义可以看出，就其本质，UML是一种语言，既然是语言，那就是用来交流的，UML用来在哪些人员之间进行交流呢？很明显，UML主要是在软件开发的整个生命周期所涉及到的人员之间进行交流的语言。 （2）UML是一种建模语言。 那么什么是建模呢？ 模型是用某种工具对事物的一种表达方式，通常会表达出事物最重要的方面而简化或忽略其他方面。比如常见的工程模型、飞机模型、车辆模型等。 模型在软件上主要的作用是，可以在一定的抽象层次上，使人们通过对模型的分析和研究，来制定出最终的软件结构和内部的相互关系。 （3）UML是一种图形化建模语言。 为什么要图形化呢？ 很简单，图形化的东西直观、简单、准确，更有利于软件开发的整个生命周期所涉及到的人员之间进行交流。因为对于一个大型的软件项目，参与的人员很多，根本不可能相互用语言来交流，图形化是一个很好的方案。 （4）UML是一种标准的图形化建模语言。 只有标准的东西，才会有更多的人学习和使用它，大家对同一表达的理解才会一样，才能真正达到相互交流的目的。 否则要是没有标准，大家各自为政，可能会出现同一个图形，大家有不同的认识和理解，那就没法交流了。 基本构件 建模的核心是模型，模型是现实的简化、真实系统的抽象。因此好的建模语言就需要提供全样的模块组成，如下就是UML的基本构件。UML主要由三部分概念组成：具体的事物、事物间的关系、事物与关系组合而成的图。 我们使用UML的目的就是确认好具体的事物以及事物间的关系，并以此来选择合适的图来表达，三者是紧紧联系的。在UML2.0中，我们使用最频繁的就是类图、时序图了。 事物 事物是抽象化的最终结果，分为结构事物、行为事物、分组事物、注释事物。其中我们比较频繁使用的是结构事物中的类和接口、行为事物中的交互和状态机 关系 UML将事物之间的关系归纳为6种： 实现、继承 实现是实现接口，继承是继承父类。 ▲两者的图形都是子指向父，并且箭头全是空心三角箭头。 依赖 概念：是一种使用的关系，即一个类的实现需要另一个类的协助。在Java中，方法参数需要传入另一个类的对象，就表示依赖这个类。 **表示方式：**虚线箭头。 关联 **概念：**表示类与类之间的联接,它使一个类知道另一个类的属性和方法，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的。 java中一个类的全局变量引用了另一个类，就表示关联了这个类。类之间存在关联关系就可以用普通关联来表达 **注意：**类A中用到类B属性，类A指向类B。 聚合 聚合在《研读设计模式》中认为是关联的子集，可分为普通聚合、共享聚合、复合聚合 聚合关系表示类之间整体与部分的关系，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。e.g.公交车司机和工作服，两者没有共同的声明周期。 **表示方式：**尾部为空心菱形的实线箭头（也可以没箭头）。 **注意：**类B为类A中的属性，类A指向类B。 组合 组合关系表示类之间整体与部分的关系，整体和部分有一致的生存期，一旦整体对象不存在，那么部分对象也将不存在，整体和部分是同生共死的关系。e.g.人由头部和身体组成，两者不可分割。 **表示方式：**尾部为实心菱形的实现箭头（也可以没箭头）。 **注意：**Head是Dog的一部分，Dog指向Head。 总结以上关系 在这6种类关系中，组合、聚合和关联的代码结构一样，可以从关系的强弱来理解，各类关系从强到弱依次是：继承&gt;实现&gt;组合&gt;聚合&gt;关联&gt;依赖。下面我们用一张完整的类图，熔前面描述的所有类与类之间的关系串联起来。 图 UML2.0一共有13中图（UML1.5定义了9种，2.0增加了4种），最常用的就是类图、对象图、时序图、状态图 附录 经典关系图 more见: 类图templates 记忆技巧 注意： 箭头方向记录两个重要点： 子类指向父类 知道对方信息才指向对方","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"防忘系列","slug":"防忘系列","permalink":"https://nymrli.top/tags/防忘系列/"}]},{"title":"浙大2020春夏-人工智能习题2——垃圾分类","slug":"浙大2020春夏-人工智能习题2——垃圾分类","date":"2020-12-11T02:25:45.000Z","updated":"2020-12-19T12:57:33.295Z","comments":true,"path":"2020/12/11/浙大2020春夏-人工智能习题2——垃圾分类/","link":"","permalink":"https://nymrli.top/2020/12/11/浙大2020春夏-人工智能习题2——垃圾分类/","excerpt":"","text":"homework for ZJU: https://mo.zju.edu.cn/homework/zju_ai_2020_ss 1. 实验介绍 1.1 实验背景 自今年 7 月 1 日起，上海市将正式实施 《上海市生活垃圾管理条例》。 垃圾分类，看似是微不足道的“小事”，实则关系到13亿多人生活环境的改善，理应大力提倡。 垃圾识别分类数据集中包括玻璃 (glass) 、硬纸板 (cardboard) 、金属 (metal) 、纸 (paper) 、塑料 (plastic) 、一般垃圾 (trash) ，共6个类别。 生活垃圾由于种类繁多，具体分类缺乏统一标准，大多人在实际操作时会“选择困难”，基于深度学习技术建立准确的分类模型，利用技术手段改善人居环境。 1.2 实验要求 a）建立深度神经网络模型，并尽可能将其调到最佳状态。 b）绘制深度神经网络模型图、绘制并分析学习曲线。 c）用准确率等指标对模型进行评估。 1.3 实验环境 可以使用基于 Python 的 OpenCV 库进行图像相关处理，使用 Numpy 库进行相关数值运算，使用 Keras 等框架建立深度学习模型等。 2.实验内容 2.1 介绍数据集 该数据集包含了 2307 个生活垃圾图片。数据集的创建者将垃圾分为了 6 个类别，分别是： 序号 中文名 英文名 数据集大小 1 玻璃 glass 457 2 纸 paper 540 3 硬纸板 cardboard 370 4 塑料 plastic 445 5 金属 metal 380 6 一般垃圾 trash 115 物品都是放在白板上在日光/室内光源下拍摄的，压缩后的尺寸为 512 * 384 2.2 图片预处理 图片生成器 ImageDataGenerator: keras.preprocessing.image 模块中的图片生成器，主要用以生成一个 batch 的图像数据，支持实时数据提升。训练时该函数会无限生成数据，直到达到规定的 epoch 次数为止。同时也可以在 batch 中对数据进行增强，扩充数据集大小，增强模型的泛化能力，比如进行旋转，变形，归一化等等。 图片生成器的主要方法： fit(x, augment=False, rounds=1)：计算依赖于数据的变换所需要的统计信息(均值方差等)。 flow(self, X, y, batch_size=32, shuffle=True, seed=None, save_to_dir=None, save_prefix=’’, save_format=‘png’)：接收 Numpy 数组和标签为参数,生成经过数据提升或标准化后的 batch 数据，并在一个无限循环中不断的返回 batch 数据。 flow_from_directory(directory): 以文件夹路径为参数，会从路径推测 label，生成经过数据提升/归一化后的数据，在一个无限循环中无限产生 batch 数据。 根据上面的介绍和我们数据集的特性，我们主要运用 ImageDataGenerator() 和 flow_from_directory() 方法。我们将数据处理过程封装成为一个函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 导入图片生成器from keras.preprocessing.image import ImageDataGeneratordef processing_data(data_path, height, width, batch_size=32, validation_split=0.1): \"\"\" 数据处理 :param data_path: 带有子目录的数据集路径 :param height: 图像形状的行数 :param width: 图像形状的列数 :param batch_size: batch 数据的大小，整数，默认32。 :param validation_split: 在 0 和 1 之间浮动。用作测试集的训练数据的比例，默认0.1。 :return: train_generator, validation_generator: 处理后的训练集数据、验证集数据 \"\"\" train_data = ImageDataGenerator( # 对图片的每个像素值均乘上这个放缩因子，把像素值放缩到0和1之间有利于模型的收敛 rescale=1. / 255, # 浮点数，剪切强度（逆时针方向的剪切变换角度） shear_range=0.1, # 随机缩放的幅度，若为浮点数，则相当于[lower,upper] = [1 - zoom_range, 1+zoom_range] zoom_range=0.1, # 浮点数，图片宽度的某个比例，数据提升时图片水平偏移的幅度 width_shift_range=0.1, # 浮点数，图片高度的某个比例，数据提升时图片竖直偏移的幅度 height_shift_range=0.1, # 布尔值，进行随机水平翻转 horizontal_flip=True, # 布尔值，进行随机竖直翻转 vertical_flip=True, # 在 0 和 1 之间浮动。用作验证集的训练数据的比例 validation_split=validation_split ) # 接下来生成测试集，可以参考训练集的写法 validation_data = ImageDataGenerator( rescale=1. / 255, validation_split=validation_split) train_generator = train_data.flow_from_directory( # 提供的路径下面需要有子目录 data_path, # 整数元组 (height, width)，默认：(256, 256)。 所有的图像将被调整到的尺寸。 target_size=(height, width), # 一批数据的大小 batch_size=batch_size, # \"categorical\", \"binary\", \"sparse\", \"input\" 或 None 之一。 # 默认：\"categorical\",返回one-hot 编码标签。 class_mode='categorical', # 数据子集 (\"training\" 或 \"validation\") subset='training', seed=0) validation_generator = validation_data.flow_from_directory( data_path, target_size=(height, width), batch_size=batch_size, class_mode='categorical', subset='validation', seed=0) return train_generator, validation_generator# -------------使用---------------------# 数据路径data_path = \"./datasets/la1ji1fe1nle4ishu4ju4ji22-momodel/dataset-resized\"# 图像数据的行数和列数height, width = 384, 512# 获取训练数据和验证数据集train_generator, validation_generator = processing_data(data_path, height, width)# 通过属性class_indices可获得文件夹名与类的序号的对应字典。 (类别的顺序将按照字母表顺序映射到标签值)。labels = train_generator.class_indicesprint(labels)# 转换为类的序号与文件夹名对应的字典labels = dict((v, k) for k, v in labels.items())print(labels)\"\"\"Found 2078 images belonging to 6 classes.Found 229 images belonging to 6 classes.&#123;'trash': 5, 'metal': 2, 'plastic': 4, 'glass': 1, 'cardboard': 0, 'paper': 3&#125;&#123;0: 'cardboard', 1: 'glass', 2: 'metal', 3: 'paper', 4: 'plastic', 5: 'trash'&#125;\"\"\" 2.3 采用 Keras 建立一个简单的深度神经网络模型 通过 Keras 构建深度学习模型的步骤如下： 1. 定义模型——创建一个模型并添加配置层 Keras 的核心数据结构是 model，一种组织网络层的方式。最简单的模型是 Sequential 顺序模型，它由多个网络层线性堆叠。 方式一: 使用 .add() 方法将各层添加到模型中 1234567891011121314# 方式一: 使用 .add() 方法将各层添加到模型中# 导入相关包from keras.models import Sequentialfrom keras.layers import Dense, Activation# 选择模型，选择序贯模型（Sequential())model = Sequential()# 构建网络层# 添加全连接层，输入784维,输出空间维度32model.add(Dense(32, input_shape=(784,)))# 添加激活层，激活函数是 relumodel.add(Activation('relu'))# 打印模型概况model.summary() 方式二：网络层实例的列表构建序贯模型 12345678910111213# 方式二：网络层实例的列表构建序贯模型# 导入相关的包from keras.models import Sequentialfrom keras.layers import Dense, Activation# 选择模型，选择序贯模型（Sequential())# 通过将网络层实例的列表传递给 Sequential 的构造器，来创建一个 Sequential 模型model = Sequential([ Dense(32, input_shape=(784,)), Activation('relu')])# 打印模型概况model.summary() 方式三：函数式模型 123456789101112131415# 方式三：函数式模型# 导入相关的包from keras.layers import Input, Dense,Activationfrom keras.models import Model# 输入层，返回一个张量 tensorinputs = Input(shape=(784,))# 全连接层，返回一个张量output_1 = Dense(32)(inputs)# 激活函数层predictions= Activation(activation='relu')(output_1)# 创建一个模型，包含输入层、全连接层和激活层model = Model(inputs=inputs, outputs=predictions)# 打印模型概况model.summary() 2. 编译模型——指定损失函数和优化器，并调用模型的 compile() 函数，完成模型编译。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# 导入相关包from keras.layers import Input, Dense, Flatten, Dropout, Activationfrom keras.layers.normalization import BatchNormalizationfrom keras.models import Modelfrom keras.callbacks import TensorBoardimport timedef dnn_model(input_shape, train_generator, validation_generator, model_save_path='results/dnn.h5', log_dir=\"results/logs/\"): \"\"\" 该函数实现 Keras 创建深度学习模型的过程. ▲.定义模型+编译模型 :param input_shape: 模型数据形状大小，比如:input_shape=(384, 512, 3) :param train_generator: 训练集 :param validation_generator: 验证集 :param model_save_path: 保存模型的路径 :param log_dir: 保存模型日志路径 :return: 返回已经训练好的模型 \"\"\" # Input 用于实例化 Keras 张量。 # shape: 一个尺寸元组（整数），不包含批量大小。 例如，shape=(32,) 表明期望的输入是按批次的 32 维向量。 inputs = Input(shape=input_shape) # 将输入展平 dnn = Flatten()(inputs) # Dense 全连接层 实现以下操作：output = activation(dot(input, kernel) + bias) # 其中 activation 是按逐个元素计算的激活函数，kernel 是由网络层创建的权值矩阵， # 以及 bias 是其创建的偏置向量 (只在 use_bias 为 True 时才有用)。 dnn = Dense(6)(dnn) # 批量标准化层: 在每一个批次的数据中标准化前一层的激活项， 即应用一个维持激活项平均值接近 0，标准差接近 1 的转换。 # axis: 整数，需要标准化的轴 （通常是特征轴）。默认值是 -1 dnn = BatchNormalization(axis=-1)(dnn) # 将激活函数,输出尺寸与输入尺寸一样，激活函数可以是'softmax'、'sigmoid'等 dnn = Activation('sigmoid')(dnn) # Dropout 包括在训练中每次更新时，将输入单元的按比率随机设置为 0, 这有助于防止过拟合。 # rate: 在 0 和 1 之间浮动。需要丢弃的输入比例。 dnn = Dropout(0.25)(dnn) dnn = Dense(12)(dnn) dnn = BatchNormalization(axis=-1)(dnn) dnn = Activation('relu')(dnn) dnn = Dropout(0.5)(dnn) dnn = Dense(6)(dnn) dnn = BatchNormalization(axis=-1)(dnn) dnn = Activation('softmax')(dnn) outputs = dnn # 生成一个函数型模型 model = Model(inputs=inputs, outputs=outputs) # 编译模型, 采用 compile 函数: https://keras.io/models/model/#compile model.compile( # 是优化器, 主要有Adam、sgd、rmsprop等方式。 optimizer='Adam', # 损失函数,多分类采用 categorical_crossentropy loss='categorical_crossentropy', # 是除了损失函数值之外的特定指标, 分类问题一般都是准确率 metrics=['accuracy']) # 可视化，TensorBoard 是由 Tensorflow 提供的一个可视化工具。 tensorboard = TensorBoard(log_dir) # 训练模型, fit_generator函数:https://keras.io/models/model/#fit_generator # 利用Python的生成器，逐个生成数据的batch并进行训练。 # callbacks: 实例列表。在训练时调用的一系列回调。详见 https://keras.io/callbacks/。 d = model.fit_generator( # 一个生成器或 Sequence 对象的实例 generator=train_generator, # epochs: 整数，数据的迭代总轮数。 epochs=5, # 一个epoch包含的步数,通常应该等于你的数据集的样本数量除以批量大小。 steps_per_epoch=2076 // 32, # 验证集 validation_data=validation_generator, # 在验证集上,一个epoch包含的步数,通常应该等于你的数据集的样本数量除以批量大小。 validation_steps=231 // 32, callbacks=[tensorboard]) # 模型保存 model.save(model_save_path) return d, model 3. 训练模型——通过调用模型的 fit() 函数来训练模型。 123456789101112131415# 开始时间start = time.time()# 数据预处理data_path = \"./datasets/la1ji1fe1nle4ishu4ju4ji22-momodel/dataset-resized\"# 图像数据的行数和列数height, width = 384, 512# 获取训练数据和验证数据train_generator, validation_generator = processing_data(data_path, height, width)# 定义模型输入大小input_shape=(384, 512, 3)# 训练模型，获取训练过程和训练后的模型res,model = dnn_model(input_shape, train_generator, validation_generator)# 打印模型概况和模型训练总数长model.summary()print(\"模型训练总时长：\",time.time()-start) 查看模型训练效果 123456789101112131415161718192021222324def plot_training_history(res): \"\"\" 绘制模型的训练结果 :param res: 模型的训练结果 :return: \"\"\" # 绘制模型训练过程的损失和平均损失 # 绘制模型训练过程的损失值曲线，标签是 loss plt.plot(res.history['loss'], label='loss') # 绘制模型训练过程中的平均损失曲线，标签是 val_loss plt.plot(res.history['val_loss'], label='val_loss') # 绘制图例,展示出每个数据对应的图像名称和图例的放置位置 plt.legend(loc='upper right') # 展示图片 plt.show() # 绘制模型训练过程中的的准确率和平均准确率 # 绘制模型训练过程中的准确率曲线，标签是 acc plt.plot(res.history['accuracy'], label='accuracy') # 绘制模型训练过程中的平均准确率曲线，标签是 val_acc plt.plot(res.history['val_accuracy'], label='val_accuracy') # 绘制图例,展示出每个数据对应的图像名称，图例的放置位置为默认值。 plt.legend() # 展示图片 plt.show() 4. 模型预测——调用模型的 evaluate()或者 predict() 等函数对新数据进行预测。 1234567891011121314def load_and_model_prediction(validation_generator): \"\"\" 加载模型和模型评估，打印验证集的 loss 和准确度 :param validation_generator: 预测数据 :return: \"\"\" # 加载模型 model = load_model('results/dnn.h5') # 获取验证集的 loss 和 accuracy loss, accuracy = model.evaluate_generator(validation_generator) print(\"\\nLoss: %.2f, Accuracy: %.2f%%\" % (loss, accuracy * 100)) # 打印模型评估的结果load_and_model_prediction(validation_generator) (预测可视化)： 12345678910111213141516171819202122232425262728from keras.models import load_modeldef plot_load_and_model_prediction(validation_generator, labels): \"\"\" 加载模型、模型预测并展示模型预测结果等 :param validation_generator: 预测数据 :param labels: 数据标签 :return: \"\"\" # 加载模型 model = load_model('results/dnn.h5') # 测试集数据与标签 test_x, test_y = validation_generator.__getitem__(2) # 预测值 preds = model.predict(test_x) # 绘制预测图像的预测值和真实值，定义画布 plt.figure(figsize=(16, 16)) for i in range(16): # 绘制各个子图 plt.subplot(4, 4, i + 1) # 图片名称 plt.title( 'pred:%s / truth:%s' % (labels[np.argmax(preds[i])], labels[np.argmax(test_y[i])])) # 展示图片 plt.imshow(test_x[i]) # 展示模型预测结果plot_load_and_model_prediction(validation_generator, labels) 5. 使用模型 123456789101112131415161718192021222324252627282930313233343536import osfrom keras.models import load_modelfrom keras.preprocessing import imageimport numpy as npdef load_and_predict(img): \"\"\" 加载模型并预测一张图片的类别 :param img: PIL.Image 对象 :return: string, 模型识别图片的类别, 共 'cardboard','glass','metal','paper','plastic','trash' 6 个类别 \"\"\" # 加载模型, 默认'results/dnn.h5',请填写你的最佳模型 model_path = 'results/dnn.h5' model = load_model(model_path) # 把图片转换成为numpy数组 img = image.img_to_array(img) # 图片放缩 img = 1.0/255 * img # expand_dims的作用是把img.shape转换成(1, img.shape[0], img.shape[1], img.shape[2]) x = np.expand_dims(img, axis=0) # 模型预测, y: [[0.22421867 0.13031775 0.15167782 0.15904953 0.21509506 0.11964121]] y = model.predict(x) # 获取labels labels = &#123;0: 'cardboard', 1: 'glass', 2: 'metal', 3: 'paper', 4: 'plastic', 5: 'trash'&#125; # 获取输入图片的类别 y_predict = labels[np.argmax(y)] # 返回图片的类别 return y_predictfrom keras.preprocessing import image# 输入图片路径和名称file_path = 'test.jpg'# 打印该张图片的类别img = image.load_img(file_path)print(load_and_predict(img)) Mycode 编写 数据处理、创建模型、训练模型、保存模型 和 评估模型 等部分的代码 完成模型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768def processing_data(data_path): \"\"\" 数据处理 :param data_path: 数据集路径 :return: train, test:处理后的训练集数据、测试集数据 \"\"\" # -------------------------- 实现数据处理部分代码 ---------------------------- # ------------------------------------------------------------------------ train_data, test_data = None, None return train_data, test_datadef model(train_data, test_data, save_model_path): \"\"\" 创建、训练和保存深度学习模型 :param train_data: 训练集数据 :param test_data: 测试集数据 :param save_model_path: 保存模型的路径和名称 :return: \"\"\" # --------------------- 实现模型创建、训练和保存等部分的代码 --------------------- # 保存模型（请写好保存模型的路径及名称） # ------------------------------------------------------------------------- return modeldef evaluate_mode(test_data, save_model_path): \"\"\" 加载模型和评估模型 可以实现，比如: 模型训练过程中的学习曲线，测试集数据的loss值、准确率及混淆矩阵等评价指标！ 主要步骤: 1.加载模型(请填写你训练好的最佳模型), 2.对自己训练的模型进行评估 :param test_data: 测试集数据 :param save_model_path: 加载模型的路径和名称,请填写你认为最好的模型 :return: \"\"\" # ----------------------- 实现模型加载和评估等部分的代码 ----------------------- # ---------------------------------------------------------------------------def main(): \"\"\" 深度学习模型训练流程,包含数据处理、创建模型、训练模型、模型保存、评价模型等。 如果对训练出来的模型不满意,你可以通过调整模型的参数等方法重新训练模型,直至训练出你满意的模型。 如果你对自己训练出来的模型非常满意,则可以提交作业! :return: \"\"\" data_path = None # 数据集路径 save_model_path = None # 保存模型路径和名称 # 获取数据 train_data, test_data = processing_data(data_path) # 创建、训练和保存模型 model(train_data, test_data, save_model_path) # 评估模型 evaluate_mode(test_data, save_model_path)if __name__ == '__main__': main() 模型预测 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from keras.models import load_modelfrom keras.preprocessing import imageimport numpy as npimport os# -------------------------- 请加载您最满意的模型 ---------------------------# 加载模型(请加载你认为的最佳模型)# 加载模型,加载请注意 model_path 是相对路径, 与当前文件同级。# 如果你的模型是在 results 文件夹下的 dnn.h5 模型，则 model_path = 'results/dnn.h5'model_path = None# 加载模型，如果采用keras框架训练模型，则 model=load_model(model_path)model = None # ---------------------------------------------------------------------------def predict(img): \"\"\" 加载模型和模型预测 主要步骤: 1.图片处理 2.用加载的模型预测图片的类别 :param img: PIL.Image 对象 :return: string, 模型识别图片的类别, 共 'cardboard','glass','metal','paper','plastic','trash' 6 个类别 \"\"\" # -------------------------- 实现模型预测部分的代码 --------------------------- # 获取图片的类别，共 'cardboard','glass','metal','paper','plastic','trash' 6 个类别 # 把图片转换成为numpy数组 img = image.img_to_array(img) # 获取输入图片的类别 y_predict = None # ------------------------------------------------------------------------- # 返回图片的类别 return y_predict# --------------------------使用-----------------------------from keras.preprocessing import image# 输入图片路径和名称img_path = 'test.jpg'# 打印该张图片的类别img = image.load_img(img_path)print(predict(img)) Mo项目上代码-&gt; accuracy为56% 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import torchfrom torch import nnimport random import numpy as npfrom PIL import Image from torchvision.transforms import transformsimport torchvision.transforms.functional as TFimport osimport torch.utils.data as Dataimport torchvisionclass MyCNN(nn.Module): def __init__(self, image_size, num_classes): super(MyCNN, self).__init__() # conv1: Conv2d -&gt; BN -&gt; ReLU -&gt; MaxPool self.conv1 = nn.Sequential( nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, stride=1, padding=1), nn.BatchNorm2d(16), nn.ReLU(), nn.MaxPool2d(kernel_size=2, stride=2), ) # conv2: Conv2d -&gt; BN -&gt; ReLU -&gt; MaxPool self.conv2 = nn.Sequential( nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, stride=1, padding=1), nn.BatchNorm2d(32), nn.ReLU(), nn.MaxPool2d(kernel_size=2, stride=2), ) # fully connected layer self.fc = nn.Linear(32 * (image_size // 4) * (image_size // 4), num_classes) def forward(self, x): \"\"\" input: N * 3 * image_size * image_size output: N * num_classes \"\"\" x = self.conv1(x) x = self.conv2(x) # view(x.size(0), -1): change tensor size from (N ,H , W) to (N, H*W) x = x.view(x.size(0), -1) output = self.fc(x) return outputdef load_model(model_path, device): net = MyCNN(32,6) print('loading the model from %s' % model_path) state_dict = torch.load(model_path, map_location=str(device)) if hasattr(state_dict, '_metadata'): del state_dict._metadata net.load_state_dict(state_dict) return net # 加载模型,加载请注意 model_path 是相对路径, 与当前文件同级。# 如果你的模型是在 results 文件夹下的 dnn.h5 模型，则 model_path = 'results/dnn.h5'model_path = 'results/cnn.pth'device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')model = load_model(model_path, device).to(device)model.eval()def predict(img): \"\"\" :param img: PIL.Image 对象 :return: string, 模型识别图片的类别, 共 'cardboard','glass','metal','paper','plastic','trash' 6 个类别 \"\"\" transform = transforms.Compose([transforms.RandomCrop(size=(384,512), padding=10), transforms.Resize((32,32)), transforms.ToTensor(), transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) ]) img = transform(img) classes=['glass','paper','carboard','plastic','metal','trash'] img = img.to(device).unsqueeze(0) pred_cate = model(img) preds = pred_cate.argmax(dim=1) # ------------------------------------------------------------------------- y_predict = classes[preds] # 返回图片的类别 return y_predict VGG16代码：accurary：92% 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215################################################################################ 重要: 请务必把任务(jobs)中需要保存的文件存放在 results 文件夹内# Important : Please make sure your files are saved to the 'results' folder# in your jobs################################################################################ ------------------------------------------提交内容-----------------------------------from keras.layers import Input, Dense, Flatten, Dropout, Activation from keras.layers.normalization import BatchNormalizationfrom keras.preprocessing.image import ImageDataGeneratorfrom keras.callbacks import TensorBoardfrom keras.preprocessing import imagefrom keras.models import load_modelfrom keras.models import Modelimport matplotlib.pyplot as pltimport glob, os, cv2, random,timeimport numpy as npfrom keras.models import Sequentialfrom keras.layers import Conv2D,Flatten,MaxPooling2D,Dense from keras.optimizers import SGDfrom keras.applications.vgg16 import VGG16def processing_data(data_path): \"\"\" 数据处理 :param data_path: 数据集路径 :return: train, test:处理后的训练集数据、测试集数据 \"\"\" train_data = ImageDataGenerator( # 对图片的每个像素值均乘上这个放缩因子，把像素值放缩到0和1之间有利于模型的收敛 rescale=1. / 225, # 浮点数，剪切强度（逆时针方向的剪切变换角度） shear_range=0.1, # 随机缩放的幅度，若为浮点数，则相当于[lower,upper] = [1 - zoom_range, 1+zoom_range] zoom_range=0.1, # 浮点数，图片宽度的某个比例，数据提升时图片水平偏移的幅度 width_shift_range=0.1, # 浮点数，图片高度的某个比例，数据提升时图片竖直偏移的幅度 height_shift_range=0.1, # 布尔值，进行随机水平翻转 horizontal_flip=True, # 布尔值，进行随机竖直翻转 vertical_flip=True, # 在 0 和 1 之间浮动。用作验证集的训练数据的比例 validation_split=0.1 ) # 接下来生成测试集，可以参考训练集的写法 validation_data = ImageDataGenerator( rescale=1. / 255, validation_split=0.1) train_generator = train_data.flow_from_directory( # 提供的路径下面需要有子目录 data_path, # 整数元组 (height, width)，默认：(256, 256)。 所有的图像将被调整到的尺寸。 target_size=(150, 150), # 一批数据的大小 batch_size=16, # \"categorical\", \"binary\", \"sparse\", \"input\" 或 None 之一。 # 默认：\"categorical\",返回one-hot 编码标签。 class_mode='categorical', # 数据子集 (\"training\" 或 \"validation\") subset='training', seed=0) validation_generator = validation_data.flow_from_directory( data_path, target_size=(150, 150), batch_size=16, class_mode='categorical', subset='validation', seed=0) return train_generator, validation_generatordef model(train_generator, validation_generator, save_model_path): \"\"\" 模型的建立 本次实验采用Vgg16模型 \"\"\" vgg16_model = VGG16(weights='imagenet',include_top=False, input_shape=(150,150,3)) top_model = Sequential() top_model.add(Flatten(input_shape=vgg16_model.output_shape[1:])) top_model.add(Dense(256,activation='relu')) top_model.add(Dropout(0.5)) top_model.add(Dense(6,activation='softmax')) model = Sequential() model.add(vgg16_model) model.add(top_model) # 编译模型, 采用 compile 函数: https://keras.io/models/model/#compile model.compile( # 是优化器, 主要有Adam、sgd、rmsprop等方式。 optimizer=SGD(lr=1e-3,momentum=0.9), # 损失函数,多分类采用 categorical_crossentropy loss='categorical_crossentropy', # 是除了损失函数值之外的特定指标, 分类问题一般都是准确率 metrics=['accuracy']) model.fit_generator( # 一个生成器或 Sequence 对象的实例 generator=train_generator, # epochs: 整数，数据的迭代总轮数。 epochs=200, # 一个epoch包含的步数,通常应该等于你的数据集的样本数量除以批量大小。 steps_per_epoch=2259 // 16, # 验证集 validation_data=validation_generator, # 在验证集上,一个epoch包含的步数,通常应该等于你的数据集的样本数量除以批量大小。 validation_steps=248 // 16, ) model.save(save_model_path) return modeldef evaluate_mode(validation_generator, save_model_path): # 加载模型 model = load_model('results/Ynnex1.h5') # 获取验证集的 loss 和 accuracy loss, accuracy = model.evaluate_generator(validation_generator) print(\"\\nLoss: %.2f, Accuracy: %.2f%%\" % (loss, accuracy * 100))def predict(img): \"\"\" 加载模型和模型预测 主要步骤: 1.加载模型(请加载你认为的最佳模型) 2.图片处理 3.用加载的模型预测图片的类别 :param img: PIL.Image 对象 :return: string, 模型识别图片的类别, 共 'cardboard','glass','metal','paper','plastic','trash' 6 个类别 \"\"\" # 把图片转换成为numpy数组 img = img.resize((150, 150)) img = image.img_to_array(img) # 加载模型,加载请注意 model_path 是相对路径, 与当前文件同级。 # 如果你的模型是在 results 文件夹下的 dnn.h5 模型，则 model_path = 'results/dnn.h5' model_path = 'results/Ynnex1.h5' try: # 作业提交时测试用, 请勿删除此部分 model_path = os.path.realpath(__file__).replace('main.py', model_path) except NameError: model_path = './' + model_path # -------------------------- 实现模型预测部分的代码 --------------------------- # 加载模型 model = load_model(model_path) # expand_dims的作用是把img.shape转换成(1, img.shape[0], img.shape[1], img.shape[2]) x = np.expand_dims(img, axis=0) # 模型预测 y = model.predict(x) # 获取labels labels = &#123;0: 'cardboard', 1: 'glass', 2: 'metal', 3: 'paper', 4: 'plastic', 5: 'trash'&#125; # ------------------------------------------------------------------------- predict = labels[np.argmax(y)] # 返回图片的类别 return predictdef main(): \"\"\" 深度学习模型训练流程,包含数据处理、创建模型、训练模型、模型保存、评价模型等。 如果对训练出来的模型不满意,你可以通过调整模型的参数等方法重新训练模型,直至训练出你满意的模型。 如果你对自己训练出来的模型非常满意,则可以提交作业! :return: \"\"\" data_path = \"./datasets/la1ji1fe1nle4ishu4ju4ji22-momodel/dataset-resized\" # 数据集路径 save_model_path = 'results/Ynnex1.h5' # 保存模型路径和名称 # 获取数据 train_generator, validation_generator = processing_data(data_path) # 创建、训练和保存模型 model(train_generator, validation_generator, save_model_path) # 评估模型 evaluate_mode(validation_generator, save_model_path)# 数据测试def test_result(): import random,cv2 import numpy as np import matplotlib.pyplot as plt from PIL import Image # 导入相关包 import glob, os # 数据集路径 data_path = \"./datasets/la1ji1fe1nle4ishu4ju4ji22-momodel/dataset-resized\" # 获取数据名称列表 img_list = glob.glob(os.path.join(data_path, '*/*.jpg')) # 打印数据集总量 print(\"数据集总数量:\", len(img_list)) print(\"数据路径和名称:\",img_list[0]) # 从数据名称列表 img_list 中随机选取 6 个。 for i, img_path in enumerate(random.sample(img_list, 6)): # 读取图片 img = cv2.imread(img_path) # 将图片从 BGR 模式转为 RGB 模式 img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) img = Image.fromarray(img) plt.imshow(img) plt.show() res = predict(img) print(res) if __name__ == '__main__':# main() test_result() VGG16说明：https://baijiahao.baidu.com/s?id=1667221544796169037&amp;wfr=spider&amp;for=pc 附录 CSDN 基于深度学习的垃圾分类识别系统 基于深度学习的计算机视觉 - 垃圾分类（附源码） Github 基于深度学习的垃圾分类 garbage_classify Deep-Learning","categories":[],"tags":[{"name":"ZJU","slug":"ZJU","permalink":"https://nymrli.top/tags/ZJU/"},{"name":"ML","slug":"ML","permalink":"https://nymrli.top/tags/ML/"}]},{"title":"细品单例模式","slug":"细品单例模式","date":"2020-12-11T02:25:26.000Z","updated":"2020-12-11T13:02:05.492Z","comments":true,"path":"2020/12/11/细品单例模式/","link":"","permalink":"https://nymrli.top/2020/12/11/细品单例模式/","excerpt":"","text":"虽然还没正式踏入开发就业浪潮中，但为了保证自己的代码质量，最近还是在学设计模式相关内容。以下为读《研磨设计模式》和《设计模式就该这样学：基于经典框架源码和真实业务场景》的读书笔记。 GoF的《设计模式》就是设计模式的始祖、经典教科书。其描述严谨，举例恰当，分类组织，是应该反复细读的经典，两本书皆提及了GoF这本书，引用了GoF中的部分例子。 单例模式 虚拟场景： 读取配置文件的内容（假设系统采用的是properties格式的配置文件） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.javass.dp.singleton.example1;import java.io.*;import java.util.*;public class AppConfig &#123; /** * 用来存放配置文件中参数A的值 */ private String parameterA; /** * 用来存放配置文件中参数B的值 */ private String parameterB; public String getParameterA() &#123; return parameterA; &#125; public String getParameterB() &#123; return parameterB; &#125; public AppConfig()&#123; //调用读取配置文件的方法 readConfig(); &#125; /** * 读取配置文件，把配置文件中的内容读出来设置到属性上 */ private void readConfig()&#123; Properties p = new Properties(); InputStream in = null; try &#123; in = AppConfig.class.getResourceAsStream(\"AppConfig.properties\"); p.load(in); //把配置文件中的内容读出来设置到属性上 this.parameterA = p.getProperty(\"paramA\"); this.parameterB = p.getProperty(\"paramB\"); &#125; catch (IOException e) &#123; System.out.println(\"装载配置文件出错了，具体堆栈信息如下：\"); e.printStackTrace(); &#125;finally&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 存在的问题： 系统运行期间，如果存在很多个AppConfig的实例对象即配置内容，会严重浪费内存资源。实际上，对于AppConfig这种类在运行期间只要一个实例对象就够了。===&gt;单例模式 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例实现思路： 一个类能够被创建多个实例的问题根源在于类的构造方法是公开的，也就是可以让类的外部通过构造方法来创建多个实例。换句话说，只要类的构造方法能让类的外部访问，就没有办法去控制外部来创建这个类的实例个数。要想控制一个类只被创建一个实例，那么首要的问题就是要把创建实例的权限收回来，让类自身来负责自己类实例的创建工作，然后由这个类来提供外部可以访问这个类实例的方法，这就是单例模式的实现方式。 单例模式的结构和说明： Singleton：私有化构造函数来隐藏构造，从而自己负责创建Singleton类自己的唯一实例，并提供一个getlnstance的方法，让外部来访问这个类的唯一实例。 基础级单例 饿汉式 所谓饿汉式，既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例，写法如下： 1234567891011public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 实现方式： 私有化构造方法 提供获取实例的方法getInstance 把获取实例的方法变成静态方法 定义存储实例的属性(成员变量)instance 将实例成员变量instance定义为静态的（由于要在静态方法中使用，被迫写成static，没用到static特性） 从而实现控制实例的创建 懒汉式 所谓懒汉式，既然是懒，那么在创建对象实例的时候就不着急，会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推托不开的时候才去真正执行工作，因此在装载对象的时候不创建对象实例，写法如下： 懒汉式体现了延迟加载的思想，lazy load，这个lazy并不是懒惰的意思，而是延迟的意思，Lazy load在实际开发中是种很常见的思想，可以尽可能的节约资源。 123456789101112131415161718192021public class Singleton &#123; /** * 定义一个变量来存储创建好的类实例 */ private static Singleton uniqueInstance = null; /** * ▲私有化构造方法，将构造方法权限回收，好在内部控制创建实例的数目 */ private Singleton()&#123; // &#125; /** * 定义一个方法来为客户端提供类实例， 提供访问方法 * @return 一个Singleton的实例 */ public static synchronized Singleton getInstance() &#123; if (instance == null) instance = new Singleton(); return instance; &#125;&#125; 实现方式： 私有化构造方法 提供获取实例的方法getInstance 把获取实例的方法变成静态方法 定义存储实例的属性(成员变量)instance 将实例成员变量instance定义为静态的（利用static在类装载的时候执行的特性，从而实现初始化） 从而实现控制实例的创建 🎯以上两种就是最基础的单例写法，在不考虑复杂的条件下仅是满足了定义所要求的功能：运行期间只会被创建一个实例，切提供了一个全局唯一访问点（即getInstance方法） 优缺点分析： 时间和空间： 饿汉：空间换时间，类加载时就创建。因此当系统有大量单例对象存在时，系统初始化就会造成大量的内存浪费 懒汉：时间换空间，每次获取时都需要判断是否需要创建实例 线程安全： 饿汉：线程安全，因为虚拟机保证智慧加载以此类推，并且加载类的时候不会并发发生。 懒汉：需要加上synchronized关键字才能确认线程安全，但synchronized加在方法上会比较影响性能，导致大批量线程阻塞，从而导致程序性能大幅下降 双重检查锁 为了保证加载时的性能-&gt;即不能采用饿汉，而是得采用懒汉lazy load的模式 那么如何较好地保证线程安全呢？===&gt;在懒汉式的基础上，我们得到了双重检查锁 懒汉式的做法好比地铁进站限流，在寒风刺骨的冬天，所有人都在站前广场转圈，用户体验会不好；而双重检查就是设置两重检查，好比在入站门处和入厅后再闸口检票处再检查一次 12345678910111213141516171819202122public class Singleton &#123; /** * 对保存实例的变量添加volatile的修饰。 */ private volatile static Singleton instance = null; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; //先检查实例是否存在，如果不存在才进入下面的同步块 if(instance == null)&#123; //同步块，线程安全的创建实例 synchronized(Singleton.class)&#123; //再次检查实例是否存在，如果不存在才真的创建实例 if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 双重检查加锁机制和懒汉不同的在于并不是进入getInstace方法需要同步(由方法加锁-&gt;方法内部加对象锁)，而是不存在实例的时候才会进入同步块。此处阻塞的不是基于整个LazyDoubleCheckSingleton类的阻塞，而是在getInstance方法内部的阻塞，只要逻辑不复杂，对于调用者是感觉不到的。 ▲注：被volatile修饰的变量的值不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存的，从而使得多个线程能够正确的处理该变量。（由于Java1.4前对volatile关键字实现有问题，因此双重检查锁适用于Java1.5以后）。此外volatile可能会屏蔽JVM一些必要的代码优化，所以会降低运行效率，因此一般建议没有特别需要，不要使用volatile。因此，不建议系统中大量使用双重检查锁。 静态内部类式（类级内部类） 虽然双重检查锁较之懒汉和饿汉有了不少优化，但双重检查锁仍存在1.volatile性能、2.synchronized性能，有没有什么办法不使用synchronized关键字，还能实现延迟加载和线程安全呢？==&gt;静态内部类式 什么是类级内部类？ 简单点说，类级内部类指的是，有static修饰的成员式内部类。如果没有static修饰的成员式内部类被称为对象级内部类。 类级内部类相当于其外部类的static成分，它的对象(类级内部类对象)与外部类对象间不存在依赖关系，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。 类级内部类中，可以定义静态的方法。在内部类的静态方法中只能够引用外部类中的静态成员方法或者成员变量。 类级内部类相当于其外部类的成员，只有在第一次被使用的时候才会被装载。 JVM隐含执行同步的情况： 由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时 访问final字段时 在创建线程之前创建对象时 线程可以看见它将要处理的对象时 123456789101112131415161718192021public class LazyStaticInnerClassSingleton &#123; /** * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系， * 而且只有被调用到才会装载，从而实现了延迟加载 */ private static class SingletonHolder&#123; /** * 静态初始化器，由JVM来保证线程安全 */ private static LazyStaticInnerClassSingleton instance = new LazyStaticInnerClassSingleton(); &#125; /** * 私有化构造方法 */ private LazyStaticInnerClassSingleton()&#123; &#125; public static LazyStaticInnerClassSingleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 解决反射破坏单例问题 123456789101112131415161718192021222324public class LazyStaticInnerClassSingleton &#123; /** * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系， * 而且只有被调用到才会装载，从而实现了延迟加载 */ private static class SingletonHolder&#123; /** * 静态初始化器，由JVM来保证线程安全 */ private static LazyStaticInnerClassSingleton instance = new LazyStaticInnerClassSingleton(); &#125; /** * 私有化构造方法 */ private LazyStaticInnerClassSingleton()&#123; if (LazyStaticInnerClassSingleton.instance != null)&#123; throw new RuntimeException(\"不允许创建多个实例\") &#125; &#125; public static LazyStaticInnerClassSingleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 枚举式单例 虽然静态内部类式已经接近完美了，但还不够优雅，还有没有更优雅的写法呢？—&gt;枚举式单例 对枚举的观点： Java的枚举类型实质上是功能齐全的类，因此可以有自己的属性和方法。 Java枚举类型的基本思想是通过公有的静态final域为每个枚举常量导出实例的类。 从某个角度讲，枚举是单例的泛型化，本质上是单元素的枚举。 12345678910111213public enum Singleton &#123; /** * 定义一个枚举的元素,它就代表了Singleton的一个实例 */ uniqueInstance; /** * 示意方法，单例可以有自己的操作 */ public void singletonOperation()&#123; //功能处理 &#125;&#125; 使用枚举来实现单实例控制会更加简洁，而且无偿地提供了防序列化（需要增加readResove方法）、反射破坏的机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。至于为什么可以这么玩，可以看《设计模式就该这样学：基于经典框架源码和真实业务场景》中的源码分析 容器式单例 适用于需要大量创建单例对象的场景，便于管理，但它是非线程安全的。Spring中有用到容器式单例的写法。容器一般就是一个Map 123456789101112131415161718192021public class ContainerSingleton &#123; private ContainerSingleton()&#123;&#125; private static Map&lt;String, Object&gt; ioc = new ConcurrentHashMap&lt;&gt;(); public static Object getBean(String className) &#123; synchronized (ioc) &#123; if (!ioc.containsKey(className)) &#123; Object obj = null; try &#123; obj = Class.forName(className).newInstance(); ioc.put(className, obj); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return obj; &#125; else &#123; return ioc.get(className) &#125; &#125; &#125;&#125; 模式讲解： 单例模式的范围为一个虚拟机的范围，因为加载类的载类的功能是虚拟机的，一个虚拟机在通过自己的ClassLoader 装载饿汉式实现单例类的时候就会创建一个类的实例。 ▲所以需要注意的是，如果一个虚拟机里面有很多个ClassLoader，而且这些ClassLoader都装载某个类的话(针对饿汉式)，就算这个类是单例，它也会产生很多个实例。当然，如果一个机器上有多个虚拟机，那么每个虚拟机里面都应该至少有一个这个类的实例，也就是说整个机器。所以这边讨论的单例都不适用于集群环境。 ▲单例模式的本质：控制实例数目 应用场景： 对于Java来说单例模式就是要保证在一个JVM中只存在单一实例 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少GC 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用 频繁访问数据库或文件的对象 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则无法保证逻辑的统一性。 p.s. 抽象工厂模式中具体的工厂类就是一个单例 单例模式的优点： 可以保证内存中只有一个实例，减少了内存的开销 可以避免对资源的多重占用 设置全局访问点，可以优化和共享资源的访问 单例模式的缺点： 没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径， 违背了开闭原则。好在的是，一般修改单例也比较简单 在并发测试中，单例不利于代码调试。在调试过程总，如果单例代码没有执行完，也不能模拟生成一个恶心的对象 单例模式的功能代码通常写在一个类中，如果功能设计不合理，很容易违背单一职责原则 附录 Lazy load-&gt;缓存思想 缓存使用场景：当某些资源或者数据被频繁地使用，而这些资源或数据存储在系统外部，比如数据库、硬盘文件等，那么每次操作这些数据的时候都得从数据库或者硬盘上去获取，速度会很慢，将造成性能问题。 一个简单的解决方法就是：把这些数据缓存到内存里面，每次操作的时候，先到内存里面找，看有没有这些数据，如果有，就直接使用，如果没有就获取它，并设置到缓存中，下一次访问的时候就可以直接从内存中获取了，从而节省大量的时间。当然，缓存是一种典型的空间换时间的方案。 缓存基本实现 在Java开发中最常见的一种实现缓存的方式就是使用Map，基本步骤如下。 （1）先到缓存里面查找，看看是否存在需要使用的数据。 （2）如果没有找到，那么就创建一个满足要求的数据，然后把这个数据设置到缓存中，以备下次使用。如果找到了相应的数据，或者是创建了相应的数据，那就直接使用这个数据。 多例控制模式 ▲单例模式的本质：控制实例数目，只要按照这种思想，我们除了控制单例以外，还可以限制实例具体数目为2、3、4… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.javass.dp.singleton.example9;import java.util.*;/** * 简单演示如何扩展单例模式，控制实例数目为3个 */public class OneExtend &#123; /** * 定义一个缺省的key值的前缀 */ private final static String DEFAULT_PREKEY = \"Cache\"; /** * 缓存实例的容器 */ private static Map&lt;String,OneExtend&gt; map = new HashMap&lt;String,OneExtend&gt;(); /** * 用来记录当前正在使用第几个实例，到了控制的最大数目，就返回从1开始 */ private static int num = 1; /** * 定义控制实例的最大数目 */ private final static int NUM_MAX = 3; private OneExtend()&#123;&#125; public static OneExtend getInstance()&#123; String key = DEFAULT_PREKEY+num; OneExtend oneExtend = map.get(key); if(oneExtend==null)&#123; oneExtend = new OneExtend(); map.put(key, oneExtend); &#125; //把当前实例的序号加1 num++; if(num &gt; NUM_MAX)&#123; //如果实例的序号已经达到最大数目了，那就重复从1开始获取 num = 1; &#125; return oneExtend; &#125; public static void main(String[] args) &#123; OneExtend t1 = getInstance(); OneExtend t2 = getInstance(); OneExtend t3 = getInstance(); OneExtend t4 = getInstance(); OneExtend t5 = getInstance(); OneExtend t6 = getInstance(); System.out.println(\"t1==\"+t1); System.out.println(\"t2==\"+t2); System.out.println(\"t3==\"+t3); System.out.println(\"t4==\"+t4); System.out.println(\"t5==\"+t5); System.out.println(\"t6==\"+t6); &#125;&#125;","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"浙大2020春夏-人工智能习题3——图像恢复","slug":"浙大2020春夏-人工智能习题3——图像恢复","date":"2020-12-09T05:20:46.000Z","updated":"2020-12-17T07:27:31.056Z","comments":true,"path":"2020/12/09/浙大2020春夏-人工智能习题3——图像恢复/","link":"","permalink":"https://nymrli.top/2020/12/09/浙大2020春夏-人工智能习题3——图像恢复/","excerpt":"","text":"习题3 - 图像恢复 3.1 实验内容 图像是一种非常常见的信息载体，但是在图像的获取、传输、存储的过程中可能由于各种原因使得图像受到噪声的影响——称为图像退化。图像复原就是重建退化的图像，使其最大限度恢复景物原貌的处理。如何去除噪声的影响，恢复图像原本的信息是计算机视觉中的重要研究问题。 常见的图像恢复算法有基于空间域的中值滤波、基于小波域的小波去噪、基于偏微分方程的非线性扩散滤波等，在本次实验中，📌我们要对图像添加噪声，并对添加噪声的图像进行基于模型的去噪。 3.2 实验要求 A. 生成受损图像。 a) 受损图像是由原始图像添加了不同噪声遮罩（noise masks）得到的。 b) 噪声遮罩仅包含 {0,1} 值。对原图的噪声遮罩的可以每行分别用 0.8/0.4/0.6 的噪声比率产生的，即噪声遮罩每个通道每行 80%/40%/60% 的像素值为 0，其他为 1。 B. 使用模型，进行图像恢复。 C. 评估误差为所有恢复图像与原始图像的 2-范数之和，此误差越小越好，其他评估方式包括 Cosine 相似度以及 SSIM 相似度。 D. 提交程序报告,请在本地编辑并命名为『程序报告.docx』或者 『程序报告.pdf』后， 上传到左侧文件列表中。 3.3 实验环境 可以使用基于Python的 OpenCV 库进行图像相关处理，使用 Numpy 库进行相关数值运算。 3.4 参考资料 OpenCV：https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html Numpy：https://www.numpy.org/ notes 图像退化/复原过程模型 图像复原处理的过程 设原始图像 f(x,y),f(x, y),f(x,y), 则退化后的图像可以表示为 g(x,y)=H[f(x,y)]+η(x,y)g(x, y)=H[f(x, y)]+\\eta(x, y) g(x,y)=H[f(x,y)]+η(x,y) 其中 HHH 为退化函数, η(x,y)\\eta(x, y)η(x,y) 为加性柬声, 复原的日标是得到基于退化图像的一个估计 f^(x,y),\\hat{f}(x, y),f^​(x,y), 使得图像能够尽可能地贴近原始图像。 *若H是线性的、空间不变的过程, 则退化图像在空间频域中可以表示为 g(x,y)=h(x,y)∗f(x,y)+η(x,y)g(x, y)=h(x, y) * f(x, y)+\\eta(x, y) g(x,y)=h(x,y)∗f(x,y)+η(x,y) 进行傅立叶变换, 有 G(u,v)=H(u,v)F(u,v)+N(u,v)G(u, v)=H(u, v) F(u, v)+N(u, v) G(u,v)=H(u,v)F(u,v)+N(u,v) 1. 图像增强与图像复原的区别 图像增强的目的是消除噪声，显现那些被模糊了的细节或简单地突出一幅图像中读者感兴趣的特征，不考虑图像质量下降的原因。图像复原是利用退化现象的某种先验知识，建立退化现象的数学模型，再根据模型进行反向的推演运算，以恢复原来的景物图像。因而，图像复原可以理解为图像降质过程的反向过程。建立图像复原的反向过程的数学模型，就是图像复原的主要任务。经过反向过程的数学模型的运算，要想恢复全真的景物图像比较困难。所以， 图像复原本身往往需要有一个质量标准， 即衡量接近全真景物图像的程度，或者说，对原图像的估计是否到达最佳的程度。 2. 噪声模型： 噪声主要来源于图像的获取和传输过程。 （1）图像传感器的工作情况受各种因素的影响，如图像获取中的环境条件和传感器元器件自身的质量。 （2）图像在传输过程中主要由于所用传输信道被干扰而受到噪声污染。 **噪声种类：**高斯噪声、瑞利噪声、伽马噪声、指数噪声、均匀分布噪声、脉冲噪声（椒盐噪声） 12345678910111213141516171819202122232425x=-4:.1:4;subplot(321)Y1=show_noise_pdf('gaussian',x,0,1);plot(x,Y1);title('高斯');subplot(322)Y2=show_noise_pdf('uniform',x,-3,3);plot(x,Y2);title('均匀');subplot(323)Y3=show_noise_pdf('salt &amp; pepper',x);plot(x,Y3);title('椒盐');subplot(324)Y4=show_noise_pdf('rayleigh',x,1);plot(x,Y4);title('瑞利');subplot(325)Y5=show_noise_pdf('exp',x,1);plot(x,Y5);title('指数');subplot(326)Y6=show_noise_pdf('gamma',x,2,5);plot(x,Y6);title('伽马'); 噪声概率密度函数probability density function： 高斯噪声 概率密度函数：p(z)=12πσe−(z−μ)22σ2p(z)=\\frac{1}{\\sqrt{2πσ}}e^{−\\frac{(z−μ)^2}{2σ^2}}p(z)=2πσ​1​e−2σ2(z−μ)2​ 均值：μμμ 方差：σ2σ^2σ2 高斯噪声是一个均值为 0 方差为 $σ_n^2 $的正态分布，是一个加性噪声（在原图的基础上加上噪声即为加噪后的图象）。但要正确地给图片添加高斯噪声，还要取决于程序中读入图片的数据格式。 瑞利噪声 概率密度函数： p(z)={2b(z−a)e−(z−a)2/b,z≥a0,z&lt;a 均值： μ=a+πb/4 方差: σ2=b(4−π)4\\begin{aligned} &amp;\\text { 概率密度函数： }\\\\ &amp;p(z)=\\left\\{\\begin{array}{ll} \\frac{2}{b}(z-a) e^{-(z-a)^{2} / b}, &amp; z \\geq a \\\\ 0, &amp; z&lt;a \\end{array}\\right.\\\\ &amp;\\text { 均值： } \\mu=a+\\sqrt{\\pi b} / 4\\\\ &amp;\\text { 方差: } \\sigma^{2}=\\frac{b(4-\\pi)}{4} \\end{aligned} ​ 概率密度函数： p(z)={b2​(z−a)e−(z−a)2/b,0,​z≥az&lt;a​ 均值： μ=a+πb​/4 方差: σ2=4b(4−π)​​ 曲线： 伽马（爱尔兰）噪声 概率密度函数： p(z)={abz(b−1)(b−1)!e−az,z≥00,z&lt;0 均值： μ=ba 方差： σ2=ba2\\begin{aligned} &amp;\\text { 概率密度函数： }\\\\ &amp;p(z)=\\left\\{\\begin{array}{ll} \\frac{a^{b} z^{(b-1)}}{(b-1) !} e^{-a z}, &amp; z \\geq 0 \\\\ 0, &amp; z&lt;0 \\end{array}\\right.\\\\ &amp;\\text { 均值： } \\mu=\\frac{b}{a}\\\\ &amp;\\text { 方差： } \\sigma^{2}=\\frac{b}{a^{2}} \\end{aligned} ​ 概率密度函数： p(z)={(b−1)!abz(b−1)​e−az,0,​z≥0z&lt;0​ 均值： μ=ab​ 方差： σ2=a2b​​ 曲线： 注意：只有当分母是Γ(b)Γ(b)时，才是伽马噪声，如表达式中的，该密度近似称为爱尔兰密度 指数分布噪声 概率密度函数： p(z)={ae−az,z≥00,z&lt;0 均值: μ=1a 方差： σ2=1a2\\begin{aligned} &amp;\\text { 概率密度函数： }\\\\ &amp;p(z)=\\left\\{\\begin{array}{ll} a e^{-a z}, &amp; z \\geq 0 \\\\ 0, &amp; z&lt;0 \\end{array}\\right.\\\\ &amp;\\text { 均值: } \\mu=\\frac{1}{a}\\\\ &amp;\\text { 方差： } \\sigma^{2}=\\frac{1}{a^{2}} \\end{aligned} ​ 概率密度函数： p(z)={ae−az,0,​z≥0z&lt;0​ 均值: μ=a1​ 方差： σ2=a21​​ 脉冲（椒盐）噪声 概率密度函数： 双极脉冲口声 p(z)={Pa,z=aPb,z=b0, 其他 p(z)=\\left\\{\\begin{array}{ll}P_{a}, &amp; z=a \\\\ P_{b}, &amp; z=b \\\\ 0, &amp; \\text { 其他 }\\end{array}\\right.p(z)=⎩⎨⎧​Pa​,Pb​,0,​z=az=b 其他 ​ 如果b&gt;a，灰度值b在图像中将显示为一个亮点，相反，a的值将显示为一个暗点。若Pa或Pb为零，则脉冲噪声为单极脉冲。如果两者都不为零，尤其在它们近似相等时，脉冲噪声将类似于随机分布在图像上的胡椒和盐粉微粒，因此双极脉冲噪声也称为椒盐噪声。 3. 空间滤波 图像滤波器又叫做掩模、核、模板或窗口，是与原图像的子图像有相同维数的子图像，滤波器子图像中的值是系数值，不是像素值，滤波器的处理结果是子图像中心位置像素值等于被掩住位置的像素值与滤波器中系数的点积和。 无论是平均平滑还是高斯平滑，在处理图像噪声时，都或多或少会对图片产生一定的模糊，损失部分信息。较为理想的情况，是可以选择性地进行滤波，只在噪声区域进行平滑，而在无噪声区域不进行平滑，将模糊的影响降到最低，这就是自适应性滤波的思想。通常噪声的存在，可能会使得附近邻域内，极值的上下差距较大，或者是方差较大，我们可以设置一定的阈值来判断该点是否需要进行平滑。不过这个不是该章节的内容。 ​ 不同的滤波器在处理不同类型的噪声是效果不同，对于线性平滑滤波，在处理像素邻域内的噪声点时，噪声或多或少都会影响该点的像素值计算(以高斯平滑为例，距离近则影响大，距离远则影响小，与距离的平方呈反比)；但是中值滤波通常可以将噪声点直接忽略掉。同时，中值滤波在降噪的同时引起的模糊效应较低。中值滤波的一种典型应用，就是用来消除椒盐(salt &amp; pepper)噪声。 **空间滤波器种类：**均值滤波器（适于高斯噪声）、统计排序滤波器（适于椒盐噪声）、自适应局部噪声消除滤波器（适于所有噪声）、自适应中值滤波器（适于椒盐噪声）。 空域滤波器分为平滑滤波器和锐化滤波器，平滑滤波用积分实现，锐化滤波用微分实现 平滑滤波器（低通滤波器）：------体现一种平均，所以模板均下来一般为1 作用：****模糊处理****:去除图像中一些不重要的细节、减小噪声 分类： 1.线性滤波器：均值滤波器 2.非线性滤波器（一般指统计排序滤波器）： 中值滤波器 **锐化滤波（高通滤波器）****-----**体现一种插值，所以模板均下来是0 作用：1.提取图像的边缘信息、2.突出图像边缘及细节、3.拟补平滑滤波造成的边缘模糊 3.1 均值滤波器——均值滤波器 算术均值滤波器 描述: f^(x,y)=∑(s,t)∈Sxyg(s,t)\\hat{f}(x, y)=\\sum_{(s, t) \\in S_{x y}} g(s, t)f^​(x,y)=∑(s,t)∈Sxy​​g(s,t) 结果：模糊了结果, 降低了口声 适用：适用于高斯口声或均匀随机噪声 几何均值滤波器 描述: f^(x,y)=[∏(s,t)∈Sxyg(s,t)]\\hat{f}(x, y)=\\left[\\prod_{(s, t) \\in S_{x y}} g(s, t)\\right]f^​(x,y)=[∏(s,t)∈Sxy​​g(s,t)] 结果：和算术均值滤波器相比, 丟失更少的细节 适用：同算术均值滤波器 谐波均值滤波器 描述: f^(x,y)=mn∑(z,y)∈Szy1g(s,t)\\hat{f}(x, y)=\\frac{m n}{\\sum_{(z, y) \\in S_{z y}} \\frac{1}{g(s, t)}}f^​(x,y)=∑(z,y)∈Szy​​g(s,t)1​mn​ 结果：谐波均值滤波器对于“盐”噪声效果更好，但是不适用于“胡椒”噪声。 适用：像高斯那样的噪声 逆谐波均值滤波器 其实Q称为滤波器的阶数，当Q值为正时，滤波器用于消除“胡椒”噪声；当Q值为负时，滤波器用于消除“盐”噪声。但它不能同时消除两种噪声，当Q值为0时，逆谐波滤波器变为算术均值滤波器；当Q为-1时，逆谐波均值滤波器退变为谐波均值滤波器。 适用：脉冲噪声 缺点：必须知道是明噪声还是暗噪声 高斯滤波 GaussianBlur， k窗口值都是奇数，如3、5、7，越靠近中心的权重越大。整个高斯核跟图像窗口做卷积后取其值 3.2 顺序统计滤波器——非线性滤波器 中值滤波器 描述: f^(x,y)=median⁡(s,t)∈Sxy{g(s,t)}\\hat{f}(x, y)=\\operatorname{median}_{(s, t) \\in S_{x y}\\{g(s, t)\\}}f^​(x,y)=median(s,t)∈Sxy​{g(s,t)}​，中值滤波本质上是一个统计排序滤波器，是以该点为中心的的邻域内的所有像素的统计排序中值作为该点的响应；而平滑就是加权平均数作为响应，概念上有一定差别。 适用：对单极或双极脉冲噪声非常有效 视频讲解：https://www.bilibili.com/video/BV1fQ4y1N7EP?from=search&amp;seid=11848827709822211739 最大值滤波器 描述: f^(x,y)=max⁡(s,t)∈Szy{g(s,t)}\\hat{f}(x, y)=\\max _{(s, t) \\in S_{z y}}\\{g(s, t)\\}f^​(x,y)=max(s,t)∈Szy​​{g(s,t)} 结果: 适用：发现图像中的最亮点，故适用于去除“胡椒”噪声（黑色） 最小值滤波器 描述: f^(x,y)=min⁡(s,t)∈Sxy{g(s,t)}\\hat{f}(x, y)=\\min _{(s, t) \\in S_{x y}}\\{g(s, t)\\}f^​(x,y)=min(s,t)∈Sxy​​{g(s,t)} 适用: 发现图像中的最暗点，适用于去除“盐”噪声（白色） 中点滤波器 描述: f^(x,y)=[max⁡(s,t)∈Sxy{g(s,t)}+min⁡(s,t)∈Sxy{g(s,t)}]\\hat{f}(x, y)=\\left[\\max _{(s, t) \\in S_{x y}}\\{g(s, t)\\}+\\min _{(s, t) \\in S_{x y}}\\{g(s, t)\\}\\right]f^​(x,y)=[max(s,t)∈Sxy​​{g(s,t)}+min(s,t)∈Sxy​​{g(s,t)}] 适用: 结合了顺序统计和求平均，对高斯和均匀随机分布的噪声有很好的效果 修正后的阿尔法均值滤波體 描述: f^(x,y)=1mn∑(s,t)∈Sxy{gr(s,t)}\\hat{f}(x, y)=\\frac{1}{m n} \\sum_{(s, t) \\in S_{x y}}\\left\\{g_{r}(s, t)\\right\\}f^​(x,y)=mn1​∑(s,t)∈Sxy​​{gr​(s,t)} 在SxyS_{xy}Sxy​邻域内取点g（s，t）最高灰度值的d/2和最低灰度值的d/2，用gr(s,t)来代表剩余的mn-d个像素，由这些剩余像素点的平均值形成的滤波器称为修正后的阿尔法均值滤波器 当d=0时，退变为算术均值滤波器；当d=（mn-d）/2时，退变为中值滤波器。 适用：对多重混合的噪声有很好的效果 3.3 自适应滤波器 自适应滤波器的行为变化基于由m*n矩形窗口Sxy定义的区域内图像的统计特性，它的性能要明显优于前面介绍的滤波器，代价是滤波器的复杂度。 自适应、局部噪声消除滤波器 描述: f^(x,y)=g(x,y)−ση2σL2[g(x,y)−mL]\\hat{f}(x, y)=g(x, y)-\\frac{\\sigma_{\\eta}^{2}}{\\sigma_{L}^{2}}\\left[g(x, y)-m_{L}\\right]f^​(x,y)=g(x,y)−σL2​ση2​​[g(x,y)−mL​] 其中 ση2,g(x,y)\\sigma_{\\eta}^{2}, g(x, y)ση2​,g(x,y) 形成的噪声方差 mL,m_{L},mL​, 局部像素点的均值 σL2,\\sigma_{L}^{2},σL2​, 局部方差 滤波器性能预期： (1) 如果 ση2\\sigma_{\\eta}^{2}ση2​ 为零, 滤波器应该简单的返回 g(x,y)g(x, y)g(x,y) 的值。 (2) 如果局部方差与 ση2\\sigma_{\\eta}^{2}ση2​ 是高度相关的, 那么滤波器要返回一个 g(x,y)g(x, y)g(x,y) 的近似值。 (3) 如果两个方差相等, 希望滤波器返回区域Sxy上像素的算术均值。 个关键的问题是 ση2\\sigma_{\\eta}^{2}ση2​ 未知, 需要进行估计，合理的估计会带来较好的滤波效果。 适用：防止由于缺乏图像噪声方差知识而产生的无意义结果, 适用均值和方差确定的加性高斯口声。 自适应中值滤波器 描述：自适应中值滤波算法分两层进行 先考虑如下符号： Zmin=Sxy中灰度值的最小值 Zmax=Sxy中灰度值的最大值 Zmed=Sxy中灰度值的中间值 Zxy=在坐标（x，y）上的灰度值 Smax=Sxy允许的最大尺寸 算法流程： A层： A1=Zmed-Zmin； A2=Zmed-Zmax； 如果A1&gt;0且A2&lt;0（即Zmin from: https://blog.csdn.net/xdmdth/article/details/46889091?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control Mycode 增加噪声 椒盐噪声 12345678910111213141516171819class NoiseGenerator: @staticmethod def add_pulse_noise(im, noise_ratios=0.3): \"\"\" 给图像增加脉冲噪声 脉冲噪声：噪声点只有两种情况，全黑or全白，因此又称为椒盐噪声 :param im: 待处理的图像 :param noise_ratios: 噪声比 :return: \"\"\" h, w = im.shape[0:2] # 获得图像的长宽 p_size = h * w # 计算出图像的平面大小 for r in range(int(p_size * noise_ratios)): # 噪声点数量 # 获得噪声的随机位置 rand_h = random.randint(0, h - 1) rand_w = random.randint(0, w - 1) # 两种处理: 1.像素点设置为全黑，2.像素点设置为全白 im[rand_h, rand_w, :] = np.array([0, 0, 0]) if random.random() &lt; 0.5 else np.array([255, 255, 255]) return im 高斯噪声 12345678910111213141516171819202122232425262728293031323334353637class NoiseGenerator: @classmethod def _normalization(cls, image): \"\"\" 将数据线性归一化 :param image: 图片矩阵，一般是np.array 类型 :return: 将归一化后的数据，在（0,1）之间 \"\"\" # 获取图片数据类型对象的最大值和最小值 info = np.iinfo(image.dtype) # 图像数组数据放缩在 0-1 之间 return image.astype(np.double) / info.max @staticmethod def add_gaussian_noise(im, mean=0, var=0.005): \"\"\" 添加高斯噪声 :param im: :param mean: 均值 :param var: 方差 :return: \"\"\" # image = np.array(im / 255, dtype=float) # 将像素值归一， (0, 1) image = NoiseGenerator._normalization(im) # 将像素值归一, (0, 1) noise = np.random.normal(mean, var ** 0.5, image.shape) # 产生高斯噪声 noised_im = image + noise # 直接将归一化的图片与噪声相加 def clip_img(noised_im): \"\"\" 将值限制在(-1或0, 1)间，然后乘255恢复 :param noised_im: 加了噪声的图片 :return: clip过的图片 \"\"\"\"\" low_clip = -1. if noised_im.min() &lt; 0 else 0. # 如果最小值小于1, 则边界设为(-1, 1) out_im = np.clip(noised_im, low_clip, 1.0) # 如果noised_im中像素小于low_clip则置为low_clip, 大于1值置为1 out_im = np.uint8(out_im * 255) # 将(-1, 1)的浮点型转成(0, 255)的整型 return out_im return clip_img(noised_im) ▲这边肯定有人会好奇out_im = np.uint8(out_im * 255)并不是将其转换到(0, 255)，而是(-255, 255)。 解释一下：——注意这边的np.uint8可以看到这边的数据类型就是8位int，所以范围是0-255，因此即使num=-55，那么计算的结果其实是201； num=-1，结果其实是255。 法二：skimage 1234567891011121314151617from matplotlib import pyplot as pltfrom skimage import ioimport skimageimport pylabimpath = \"000001.jpg\"image = io.imread(impath)img1 = image / 255.00 # 均一化处理img2 = skimage.util.random_noise(image,mode='gaussian',seed=None,clip=True)plt.figure(1)plt.subplot(121)plt.imshow(img1)plt.title(\"Origin picture\")plt.subplot(122)plt.imshow(img2)plt.title(\"Add Gaussian noise\")pylab.show()plt.savefig(\"noise_image.jpg\") 注意到：增加高斯噪声还可以用图像三方库完成的：skimage.util.random_noise(image,mode ='gaussian',seed=None,clip=True) skimage的简介 skimage即是Scikit-Image。基于python脚本语言开发的数字图片处理包，比如PIL,Pillow, opencv, scikit-image等。 PIL和Pillow只提供最基础的数字图像处理，功能有限；opencv实际上是一个c++库，只是提供了python接口，更新速度非常慢。scikit-image是基于scipy的一款图像处理包，它将图片作为numpy数组进行处理，正好与matlab一样，因此，我们最终选择scikit-image进行数字图像处理。 skimage包的全称是scikit-image SciKit (toolkit for SciPy) ，它对scipy.ndimage进行了扩展，提供了更多的图片处理功能。它是由python语言编写的，由scipy 社区开发和维护。skimage包由许多的子模块组成，各个子模块提供不同的功能。 子模块名称 主要实现功能 io 读取、保存和显示图片或视频 data 提供一些测试图片和样本数据 color 颜色空间变换 filters 图像增强、边缘检测、排序滤波器、自动阈值等 draw 操作于numpy数组上的基本图形绘制，包括线条、矩形、圆和文本等 transform 几何变换或其它变换，如旋转、拉伸和拉东变换等 morphology 形态学操作，如开闭运算、骨架提取等 exposure 图片强度调整，如亮度调整、直方图均衡等 feature 特征检测与提取等 measure 图像属性的测量，如相似性或等高线等 segmentation 图像分割 restoration 图像恢复 util 通用函数 数据加模糊——高斯模糊： 本质上是低通滤波器，输出图像的每个像素点是原图像上对应像素点与周围像素点的加权和。 即用高斯分布权值矩阵与原始图像矩阵做卷积运算。 https://blog.csdn.net/qq_37995260/article/details/100351153 Python给图像添加噪声具体操作 增加噪声noise_mask_image 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# CGK提供的，巧用了np.random.choice，学习了def noise_mask_image(img, noise_ratio): \"\"\" 根据题目要求生成受损图片 :param img: 图像矩阵，一般为 np.ndarray :param noise_ratio: 噪声比率，可能值是0.4/0.6/0.8 :return: noise_img 受损图片, 图像矩阵值 0-1 之间，数据类型为 np.array, 数据类型对象 (dtype): np.double, 图像形状:(height,width,channel),通道(channel) 顺序为RGB \"\"\" # 受损图片初始化 noise_img = None # -------------实现受损图像答题区域----------------- mask = np.random.choice([0, 1], size=(img.shape[0],img.shape[1],img.shape[2]), p = [noise_ratio, 1 - noise_ratio]) noise_img = mask * img # ----------------------------------------------- return noise_img# 符合题意版本， 但是过不了样例，说产生的比例不正确def noise_mask_image(img, noise_ratio): \"\"\" 根据题目要求生成受损图片 :param img: 图像矩阵，一般为 np.ndarray :param noise_ratio: 噪声比率，可能值是0.4/0.6/0.8 :return: noise_img 受损图片, 图像矩阵值 0-1 之间，数据类型为 np.array, 数据类型对象 (dtype): np.double, 图像形状:(height,width,channel),通道(channel) 顺序为RGB \"\"\" # 受损图片初始化 noise_img = None # -------------实现受损图像答题区域----------------- import random from copy import deepcopy noise_img = deepcopy(img) h, w = img.shape[: 2] # h为图片的长, w为图片的宽# noise_img = normalization(img) for dh in range(h): # 遍历每行 cols = range(w) mask_indexes = random.sample(cols, int(w * noise_ratio)) pixel_list = [0 if i in mask_indexes else 1 for i in cols] for c in cols: noise_img[dh, c, :] = noise_img[dh, c, :] * pixel_list[c] # ----------------------------------------------- noise_img = np.array(noise_img, dtype='double') return noise_img Python的random操作 图像恢复 中值滤波demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from PIL import Imageimport numpy as npdef AddNoise(src, dst, probility=0.05): \"\"\" salt_pepper增加噪声 :param src: :param dst: :param probility: :return: \"\"\" imarray = np.array(Image.open(src)) height, width = imarray.shape[:2] for i in range(height): for j in range(width): if np.random.random(1) &lt; probility: if np.random.random(1) &lt; 0.5: imarray[i, j, :] = 0 else: imarray[i, j, :] = 255 new_im = Image.fromarray(imarray) new_im.save(dst)def MedianFilter(src, dst, k=3, padding=None): \"\"\" 中值滤波 :param src: :param dst: :param k: 过滤器核大小 :param padding: :return: \"\"\" imarray = np.array(Image.open(src)) height, width, channels = imarray.shape if not padding: edge = int((k - 1) / 2) if height - 1 - edge &lt;= edge or width - 1 - edge &lt;= edge: print(\"The parameter k is to large.\") return None new_arr = np.zeros((height, width, 3), dtype=\"uint8\") for i in range(height): for j in range(width): for c in range(channels): # 处理3个通道 if i &lt;= edge - 1 or i &gt;= height - 1 - edge or j &lt;= edge - 1 or j &gt;= width - edge - 1: new_arr[i, j, c] = imarray[i, j, c] else: new_arr[i, j, c] = np.median(imarray[i - edge:i + edge + 1, j - edge:j + edge + 1, c]) new_im = Image.fromarray(new_arr) new_im.save(dst)if __name__ == '__main__': gray_girl = \"A.png\" tar = \"A_noised.png\" AddNoise(gray_girl, tar) src = \"A_noised.png\" dst = \"A_repaired.png\" MedianFilter(src, dst) 下图是k=3是的改进后的中值滤波策略的结果，可以看到图像的清晰度得到了较大的保留，噪声的数量就相对也残留的比较多。从中可以看到，二者之间有此消彼长的关系。至于为什么还有这么多的椒盐噪声，原因是因为我们添加噪声的代码中设置的概率太高了，导致图像中的椒盐噪声数量非常多，在小区域内有可能有许多的噪声点，导致算法所寻找到的中值仍然是噪声的数值范围。这种情况下扩大滤波模板的大小并不会有多大的改变。此时可以将已经执行过一次中值滤波的结果图像再执行一次中值滤波，效果就会更好一些。 参考：数字图像处理的python实现(8)——中值滤波https://blog.csdn.net/baidu_41902768/article/details/94451787——上述代码在j的条件判断上需要将height-1-edge改成width-1-edge 图像修复restore_image 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Filter: def __init__(self, k = 3): self.k = k self.padding = None def get_median(self, imarray): \"\"\" 中值滤波 :param imarray: :return: \"\"\" height, width, channels = imarray.shape if not self.padding: edge = int((self.k - 1) / 2) if height - 1 - edge &lt;= edge or width - 1 - edge &lt;= edge: print(\"The parameter k is to large.\") return None new_arr = np.zeros((height, width, 3), dtype=\"uint8\") for i in range(height): for j in range(width): for c in range(channels): # 处理3个通道 if i &lt;= edge - 1 or i &gt;= height - 1 - edge \\ or j &lt;= edge - 1 or j &gt;= width - edge - 1: # 除了中心点以外其他边沿的点 new_arr[i, j, c] = imarray[i, j, c] else: # 中心点为排序后的中值 new_arr[i, j, c] = np.median(imarray[i-edge: i+edge+1, j-edge: j+edge+1, c]) return new_arr def get_max(self, imarray): \"\"\" 中值滤波 :param imarray: :return: \"\"\" height, width, channels = imarray.shape if not self.padding: edge = int((self.k - 1) / 2) if height - 1 - edge &lt;= edge or width - 1 - edge &lt;= edge: print(\"The parameter k is to large.\") return None new_arr = np.zeros((height, width, 3), dtype=\"uint8\") for i in range(height): for j in range(width): for c in range(channels): # 处理3个通道 if i &lt;= edge - 1 or i &gt;= height - 1 - edge \\ or j &lt;= edge - 1 or j &gt;= width - edge - 1: # 边界处理， 当i索引&lt;=edge-1 -&gt; 或者 i &gt;= ((height-1)-&gt;图像边界-edge)-&gt;窗口在图像边界内的边界 new_arr[i, j, c] = imarray[i, j, c] else: # 中心点为排序后的中值 new_arr[i, j, c] = np.max(imarray[i-edge: i+edge+1, j-edge: j+edge+1, c]) return new_arrdef restore_image(noise_img, size=4): \"\"\" 使用 你最擅长的算法模型 进行图像恢复。 :param noise_img: 一个受损的图像 :param size: 输入区域半径，长宽是以 size*size 方形区域获取区域, 默认是 4 :return: res_img 恢复后的图片，图像矩阵值 0-1 之间，数据类型为 np.array, 数据类型对象 (dtype): np.double, 图像形状:(height,width,channel), 通道(channel) 顺序为RGB \"\"\" # 恢复图片初始化，首先 copy 受损图片，然后预测噪声点的坐标后作为返回值。 res_img = np.copy(noise_img) # 获取噪声图像 noise_mask = get_noise_mask(noise_img) # -------------实现图像恢复代码答题区域---------------------------- # --------------------------------------------------------------- return res_img 目前修复思路: 由于观察到mask基本都是胡椒噪声（黑色），因此最大值滤波效果会比较好一点，但是仍然会有少量椒盐噪声残余，因此，可以采用将降噪后的图像再次降噪（而不是扩大过滤核大小）。 在这里剩余的仍然是胡椒噪声（黑色），但是经过测试可以看出最大值滤波对图像的影响明显大于中值滤波，最大值滤波会比较模糊，因此这边采用的是“最大值滤波+中值滤波”的组合。（注：为什么先用最大值滤波？因为实验测试第一次就用中值滤波效果很差） 先用最大值滤波的效果： 组合中值滤波的效果： 组合最大值滤波效果 直接使用中值滤波实验结果： 记录坑点： 用savefig保存时，图片会有压缩，导致保存和重新从文件中读取的内容有些区别 1234567noised_im = NoiseGenerator.add_pulse_noise(im) # (1104, 828, 3)plt.imshow(noised_im)plt.axis(\"off\")plt.savefig(\"A_noised.png\")src = \"A_noised.png\"dst = \"A_repaired.png\"MedianFilter(src, dst) # (480, 640, 4) 总结： samples给的图中噪声基本都是胡椒噪声，没有什么盐噪声，因此考虑最大值滤波 当黑色占比大于0.3时使用&quot;最大值滤波+中值滤波组合&quot;， 当小于0.3时直接使用中值滤波 k=5太模糊，目前使用k=3 附录 图像复原原理及实现 读取展示图片的两种方式： 123456789101112131415161718192021222324252627282930313233343536# -----------------用cv的imshow-------------def add_noise(filename): im = cv2.imread(filename) cv2.imshow('original img', im) h, w = im.shape[0:2] pNum = h * w nRate = 0.3 for r in range(int(pNum * nRate)): randh = random.randint(0, h - 1) randw = random.randint(0, w - 1) # print(h,randh,w,randw) if random.random() &lt; 0.5: im[randh, randw, :] = np.array([0, 0, 0]) else: im[randh, randw, :] = np.array([255, 255, 255]) cv2.imshow('add noise', im) cv2.waitKey(0)add_noise('A.png')#-----------------用plt.imshow-------------def show_photo(pic_path): \"\"\" :param pic_path: 图片路径 :return: &lt;class 'numpy.ndarray'&gt; \"\"\" # 以 BGR 方式读取图片 im = cv2.imread(pic_path) # 将 BGR 方式转换为 RGB 方式 im = cv2.cvtColor(im, cv2.COLOR_BGR2RGB) # 展示图片 plt.imshow(im) # 关闭坐标轴 plt.axis('off') # show plt.show() return im imshow的参数 123456789101112131415161718192021222324252627@_preprocess_data(label_namer=None) def imshow(self, X, cmap=None, norm=None, aspect=None, interpolation=None, alpha=None, vmin=None, vmax=None, origin=None, extent=None, shape=None, filternorm=1, filterrad=4.0, imlim=None, resample=None, url=None, **kwargs): \"\"\" Display an image on the axes. Parameters ---------- X : array_like, shape (n, m) or (n, m, 3) or (n, m, 4) Display the image in `X` to current axes. `X` may be an array or a PIL image. If `X` is an array, it can have the following shapes and types: - MxN -- values to be mapped (float or int) - MxNx3 -- RGB (float or uint8) - MxNx4 -- RGBA (float or uint8) MxN arrays are mapped to colors based on the `norm` (mapping scalar to scalar) and the `cmap` (mapping the normed scalar to a color). Elements of RGB and RGBA arrays represent pixels of an MxN image. All values should be in the range [0 .. 1] for floats or [0 .. 255] for integers. Out-of-range values will be clipped to these bounds. clip 1# Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). 按照上述信息可知，如果元素为float类型且超过了1，则会被clip，这边clip就是上下限幅，而不是截取小数点后部分 1234res = np.array([ [[1.22,2.22,3.22]], [[-0.55,-0.44,-6.55]]] 图像相似度指标 SSIM（结构相似性度量） 这是一种全参考的图像质量评价指标，分别从亮度、对比度、结构三个方面度量图像相似性。SSIM取值范围[0, 1]，值越大，表示图像失真越小。 cosin相似度（余弦相似度） 把图片表示成一个向量，通过计算向量之间的余弦距离来表征两张图片的相似度。 https://blog.csdn.net/u010977034/article/details/82733137","categories":[],"tags":[{"name":"ZJU","slug":"ZJU","permalink":"https://nymrli.top/tags/ZJU/"},{"name":"ML","slug":"ML","permalink":"https://nymrli.top/tags/ML/"}]},{"title":"《人工智能:模型与算法——浙江大学公开课》笔记","slug":"《人工智能-模型与算法——浙江大学公开课》笔记","date":"2020-12-08T07:06:21.000Z","updated":"2021-09-12T13:41:59.129Z","comments":true,"path":"2020/12/08/《人工智能-模型与算法——浙江大学公开课》笔记/","link":"","permalink":"https://nymrli.top/2020/12/08/《人工智能-模型与算法——浙江大学公开课》笔记/","excerpt":"","text":".mjpage .MJX-monospace { font-family: monospace } .mjpage .MJX-sans-serif { font-family: sans-serif } .mjpage { display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0 } .mjpage * { transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none } .mjx-svg-href { fill: blue; stroke: blue } .MathJax_SVG_LineBox { display: table!important } .MathJax_SVG_LineBox span { display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none; padding: 0; border: 0; margin: 0 } .mjpage__block { text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100% } 课程笔记来源：2020公开课【人工智能：模型与算法】-浙江大学 P11.1可计算思想起源与发展 智能： 从感知、到理解、到认知、到决策与行动 计算的诞生：从可计算到不可计算-&gt;20世纪初，人们发现有许多问题无法找到解决的方法。于是开始怀疑，是否对这些问题来说，根本就不存在算法，即不可计算。 人工智能：以机器为载体的人类智能或生物智能 算术公理的相容性： 完备性：所有能够从该形式化系统推导出来的命题，都可以从这个形式化系统推导出来。 一致性：一个命题不可能同时为真或为假 可判定性：算法在有限步内判定命题的真伪 哥德尔不完全性定理：任何表达力足够强的（递归可枚举）形式系统都不可能同时具有一致性和完备性 图灵测试：指测试者与被测试者（一个人和一台机器）隔开的情况下，通过一些装置（如键盘）向被测试者随意提问。进行多次测试后，如果机器让平均每个参与者做出超过30%的误判，那么这台机器就通过了测试，并被认为具有人类智能。 摩尔定律：（计算机速度1年半增长1倍），亿级晶体管、千亿指令/秒 P21.2人工智能的发展简史 人工智能发展中的主流方法（1）：符号主义人工智能（SymbolicAl）为核心的逻辑推理 人工智能发展中的主流方法（2）：数据驱动（data-driven）为核心的机器学习 人工智能发展中的主流方法（3）：在“探索（未知空间）与利用（已有经验）（exploration vs.exploitation）”之间取得平衡为核心的强化学习 P31.3人工智能研究的基本内容 人工智能特点：至小有内、至大无外，多学科交叉内禀 从模拟人类智能角度而言，人工智能应具备如下能力： 具备视觉感知和语言交流的能力。即能够识别和理解外界信息（计算机视觉研究范畴）、能够与人通过语言交流（自然语言理解研究范畴）。 具备推理与问题求解能力。即基于已有知识，对所见事物和现象进行演绎推理以解决问题。 具备协同控制能力。即将视觉（看）、语言（说）、推理（悟）等能力统一协调，加以控制，这是常见的机器人研究领域内容。 具备遵守伦理道德能力。即模拟人类智能的智能体在社会环境中要遵从一定的伦理道德。阿西莫夫在科幻小说中按照优先级定义了机器人需要遵从的三条伦理原则：不得伤人，或弃人于危难；需服从人；在不违反上述两条原则情况下，保护机器人自己。 具备从数据中进行归纳总结的能力。即需要从数据中进行知识、规律和模式学习的模型和方法，这是机器学习研究范畴。 授课基本内容： 人工智能概述 1.1可计算思想起源与发展 1-2人工智能的发展简史 1.3人工智能研究的基本内容 搜索求解 2.1启发式搜索 2.2对抗搜索（Minimax及Alpha-Beta剪枝搜索） 2.3蒙特卡洛树搜索 逻辑与推理 3.1命题逻辑 3.2谓词逻辑 3.3兴国格推理 3.4因果推理 统计机器学习|监督学习 4.1机器学习基本概念 4.2线性回归与分类 4.3Ada Boosting 4.4线性区别分析 统计机器学习|非监督学习 5.1K-means 5.2主成分分析 5.3特征人脸方法 5.4期望极大算法（EM） 深度学习(监督学习+端到端) 6.1前馈神经网络（误差后向传播） 6.2卷积神经网络 6.3自然语言理解与视觉分析 强化学习 7.1马尔科夫决策过程 7.2强化学习中策略优化与策略评估 7.3Q-Learning 7.4深度强化学习 人工智能博弈 8.1博弈相关概念（纳什均衡） 8.2遗憾最小化算法 8.3虚拟遗憾最小化算法 搜索求解 P42.1启发式搜索 给定搜索目标，设计启发函数，来保证搜索目标最优化的求解 P52.2对抗搜索 在游戏里搜索一种解决方案，但在搜索过程中对手会阻止我们，这种情况下我们能获得最大收益的搜索方式。本文中主要讲解Minmax搜索+alpha-beta剪枝搜索 对抗搜索（Adversarial Search）也称为博弈搜索（Game Search），在一个竞争的环境中，智能体（agents）之间通过竞争实现相反的利益，一方最大化这个利益，另外一方最小化这个利益。 本课程目前主要讨论在确定的、全局可观察的、竞争对手轮流行动、零和游戏（zero-sum）下的对抗搜索 零和博弈是博弈论的一个概念，属非合作博弈。指参与博弈的各方，在严格竞争下，一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加总和永远为“零”，双方不存在合作的可能。 与“零和”对应，“双赢博弈”的基本理论就是“利己”不“损人”，通过谈判、合作达到皆大欢喜的结果。 最大最小搜索 给定一个游戏搜索树，minimax算法通过每个节点的minimax值来决定最优策略。当然，MAX节点希望最大化minimax值，而MIN节点则相反，希望最小化minimax值—&gt;让自己的收益最大，让对方的收益or己方的损失最小 优点： 算法是一种简单有效的对抗搜索手段 在对手也“尽力而为”前提下，算法可返回最优结果 缺点： 如果搜索树极大，则无法在有效时间内返回结果 改善： 使用alpha-beta pruning算法来减少搜索节点 对节点进行采样、而非逐一搜索（ie.，MCTS） alpha-beta剪枝搜索 一种对最小最大搜索进行改进的算法，即在搜索过程中可剪除无需搜索的分支节点，且不影响搜索结果。. P62.3蒙特卡洛树搜索 alphaGo三大法宝：深度学习、强化学习、MCTS 通过采样而非穷举方法来实现搜索，从而跟上述两种搜索有本质上的区别。 多臂赌博机问题是一种序列决策问题，这种问题需要在利用（exploitation）和探索（exploration）之间保持平衡。 利用（exploitation）：保证在过去决策中得到最佳回报 探索（exploration）：寄希望在未来能够得到更大回报 exploitation component(利用) 第一部分是 \\frac{Q(v_{i})}{N(v_{i})} ​ ，也称作exploitation component。 Q(Vi)为子节点获胜次数，N(Vi)为子节点参与模拟的次数 可以看做是子节点Vi的胜率估计（总收益/总次数=平均每次的收益）。但是不能只选择胜率高的下一步，因为这种贪婪方式的搜索会很快导致游戏结束，这往往会导致搜索不充分，错过最优解。 举个简单的例子。现在假设MCTS的UCT函数只用了探索成分，从根节点开始，我们对所有子节点进行了一次模拟，然后在下一步中只访问至少赢了一次的子节点。那么在第一次模拟中那些不幸未被选中的节点（实际中rollout策略函数通常是随机的）将会被立刻抛弃 exploration component(探索) c* \\sqrt{\\frac{\\log(N(v))}{N(v_{i})} }$$，这个成分更倾向于那些想对较少被探索的节点N(Vi)小。 参数c是exploitation和exploration之间的折中系数。 ##### MCTS的终止 终止条件(or)： - 达到一定的迭代次数 - 达到规定的搜索时间 当MSCT程序结束时，最佳的移动通常是访问次数最多的那个节点，也是UCT最大的点。 将上限置信区间算法UCB应用于游戏树的搜索方法，由Kocsis和Szepesvari在2006年提出包括了四个步骤：**选举（selection）**，**扩展（expansion）**，**模拟（simulation）**，**反向传播（Back-Propagation）** **选择** &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记\\MCTS1.jpg\" alt=\"MCTS1\" style=\"zoom:67%;\" /&gt; **拓展** &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记\\MCTS2.jpg\" alt=\"MCTS2\" style=\"zoom:67%;\" /&gt; **模拟、反向传播** &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记\\MCTS3.jpg\" alt=\"MCTS3\" style=\"zoom:67%;\" /&gt; ##### MCTS学习策略： &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记\\MCTS学习策略.jpg\" alt=\"MCTS学习策略\" style=\"zoom:67%;\" /&gt; ##### MCTS算法执行 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记\\processure.png\" alt=\"processure\" style=\"zoom:67%;\" /&gt; &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记\\MCTS算法执行.jpg\" alt=\"MCTS算法执行\" style=\"zoom:67%;\" /&gt; # [P125.1机器学习基本概念](https://www.bilibili.com/video/BV1c7411n7EY?p=12) &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/监督学习.jpg\" alt=\"监督学习\" style=\"zoom:67%;\" /&gt; **机器学习的目的：** 1.原始数据中提取特征 2.学习映射函数f 3.通过映射函数f将&lt;u&gt;原始数据映射到语义空间&lt;/u&gt;，即寻找&lt;u&gt;数据和任务目标&lt;/u&gt;之间的关系 ## 监督学习 ### 监督学习的两种方法： - 判别模型 - 判别方法直接学习判别函数f（X）或者条件概率分布P（YIX）作为预测的模型，即判别模型。 - 判别模型关心在给定输入数据下，预测该数据的输出是什么。 - 典型判别模型包括回归模型、神经网络、支持向量机和Ada boosting等。 - 生成模型 - 生成模型从数据中学习联合概率分布P（X，Y）（通过似然概率P(X|Y)-&gt;从输入数据产生输出、类概率P(Y)的乘积来求取） $P(Y|X）= \\frac{P(X,Y)}{P(x)}$或者$P(Y|X）= \\frac{P(X|Y)*P(Y)}{P(x)}$ - 典型方法为贝叶斯方法、隐马尔可夫链授之于鱼、不如授之于“渔” - 联合分布概率P（X，Y）或似然概率P（YIX）求取很困难 ## [P135.2线性回归分析](https://www.bilibili.com/video/BV1c7411n7EY?p=13) 线性回归定义：分析不同变量之间存在关系的研究叫回归分析，刻画不同变量之间关系的模型被称为回归模型。如果这个模型是线性的，则称为线性回归模型。 例如y = k*x + b，就是一个回归模型，其中的参数k和b需要从标注的数据中学习得到（监督学习） **线性回归模型例子** 背景：给出了莫纳罗亚山（夏威夷岛的活火山）从1970年到2005年每5年的二氧化碳浓度，单位是百万分比浓度（Parts Per Million，ppm）。 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/线性回归.jpg\" alt=\"线性回归\" style=\"zoom:67%;\" /&gt; 问题Q：1）给出1984年二氧化碳浓度值；2）预测2010年二氧化碳浓度值 解答A 1. 目标：建立回归模型y = a*x + b， 通过最佳回归模型求解参数a和b， 最佳回归模型是最小化残差平方和的均值，即要求8组（x，y）数据得到的残差平均值$\\frac{1}{N} \\sum(y-\\tilde{y})^{2}$最小。残差平均值最小只与参数a和b有关，最优解即是使得残差最小所对应的a和b的值。 2. 具体步骤： - 记在当前参数下第i个训练样本xi的预测值为$\\hat{y_i}$； - xi的标注值（实际值）yi，与预测值$\\hat{y_i}$，之差记为$\\left(y_{i}-\\hat{y}_{i}\\right)^{2}$ - 训练集中n个样本所产生误差总和为$L(a, b)=\\sum_{i=1}^{n}\\left(y_{i}-a \\times x_{i}-b\\right)^{2}$--》**误差函数** - 目标：寻找一组a和b，使得误差总和L（a，b）值最小。在线性回归中，解决如此目标的方法叫**最小二乘法**。 一般而言，要使函数具有最小值，可&lt;u&gt;对L(a, b)参数a和b分别求导，令其导数值为零--&gt;偏导&lt;/u&gt;，再求取参数a和b的取值。 ▲线性回归，可以从已标注数据出发，找寻两组变量之间的线性关系，并且可拓展为多维变量 ## [P145.3提升算法（boosting）](https://www.bilibili.com/video/BV1c7411n7EY?p=14) 对于一个复杂的分类任务，可以将其分解为若干子任务，然后将若干子任务完成方法**综合**，最终完成该复杂任务。即将弱分类器（weak classifiers）**组合**起来，形成强分类器（strong classifier） ### 为什么这样是能work的呢？ &gt; 计算学习理论（Computational Learning Theory） &gt; - 可计算：什么任务是可以计算的？Ans: 图灵可停机 &gt; - 可学习：什么任务是可以被学习的、从而被学习模型来完成？ &gt; &gt; 学习任务：统计某个电视节目在全国的收视率。 &gt; 方法：不可能去统计整个国家中每个人是否观看电视节目、进而算出收视率。只能**抽样**一部分人口，然后将抽样人口中观看该电视节目的比例作为该电视节目的全国收视率。 &gt; 霍夫丁不等式：全国人口中看该电视节目的人口比例（记作x）与抽样人口中观看该电视节目的人口比例（记作y）满足如下关系： &gt; &gt; &lt;mark&gt;当N足够大时，“全国人口中电视节目收视率”与“样本人口中电视节目收视率”差值超过误差范围e的概率非常小。&lt;/mark&gt; &gt; &gt; 对于统计电视节目收视率这样的任务，可以通过&lt;u&gt;不同的采样方法（即不同模型）&lt;/u&gt;来计算收视率。每个模型会产生不同的误差。 问题：如果得到完成该任务的若干“弱模型”，是否可以将这些弱模型组合起来，形成一个“强模型”。该“强模型”产生误差很小呢？ 这就是**概率近似正确（PAC）**要回答的问题。 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/PAC.jpg\" alt=\"PAC\" style=\"zoom:67%;\" /&gt; ### adaboosting &gt; 将一系列弱分类器组合成强分类器 Ada Boosting算法中两个核心问题： - 在每个弱分类器学习过程中，如何改变训练数据的权重：提高在上一轮中分类错误样本的权重。 - 如何将一系列弱分类器组合成强分类器：通过加权多数表决方法来提高分类误差小的弱分类器的权重，让其在最终分类中起到更大作用。同时减少分类误差大的弱分类器的权重，让其在最终分类中仅起到较小作用。 算法步骤： 1. 数据样本权重初始化——初始化每个训练样本的权重 - $D_{1}=\\left(w_{11}, \\ldots, w_{1 i}, \\ldots, w_{1 N}\\right),$ 其中 $w_{1 i}=\\frac{1}{N}(1 \\leq i \\leq N)$，初始情况下每个分类器的权重是一样的 2. -第m个弱分类器训练 $\\quad$ 对 $m=1,2, \\ldots, M$ a) 使用具有分布权重 $D_{m}$ 的训练数据来学习得到第m个基分类器（弱分类器） $G_{m}$ : G_{m}(x): X \\rightarrow{-1,1} ​ b) \\quad 计算 G_{m}(x) 在训练数据集上的分类误差 \\operatorname{err}_{m}=\\sum_{i=1}^{N} w_{\\operatorname{mi} } I\\left(G_{m}\\left(x_{i}\\right) \\neq y_{i}\\right) 这里: I(\\cdot)=1, 如果 G_{m}\\left(x_{i}\\right) \\neq y_{i} ; 否则为 0 ​ c) \\quad &lt;u&gt;计算弱分类器 G_{m}(x) 的权重&lt;/u&gt; : \\quad \\alpha_{m}=\\frac{1}{2} \\ln \\frac{1-e r r_{m} }{e r r_{m} } ，如果 e r r_{m}=\\sum_{i=1}^{N} w_{m i} I\\left(G_{m}\\left(x_{i}\\right) \\neq y_{i}\\right)=1 意味着每个样本都分类错，则 \\alpha_m \\to -\\infty ，当 \\alpha_m =1/2， 则性能相当于随机分类； \\alpha_m 权重随分类误差errm减小而增大，也就是说分类越少，分类器的权重越大。 ​ d) \\quad 更新训练样本数据的分布权重: \\quad D_{m+1}=w_{m+1, i}=\\frac{w_{m, i} }{z_{m} } e^{-\\alpha_{m} y_{i} G_{m}\\left(x_{i}\\right)}, 其中 Z_{m} 是归一化因子以使得 D_{m+1} 为概率分布, \\quad Z_{m}=\\sum_{i=1}^{N} w_{m, i} e^{-\\alpha_{m} y_{i} G_{m}\\left(x_{i}\\right)} - 对数据不断划重点： \\boldsymbol{w}_{\\boldsymbol{m}+\\mathbf{1}, i}=\\left\\{\\begin{array}{ll}\\frac{\\boldsymbol{w}_{\\boldsymbol{m}, i} }{\\boldsymbol{Z}_{\\boldsymbol{m} }} \\boldsymbol{e}^{-\\alpha_{m} }, &amp; \\boldsymbol{G}_{\\boldsymbol{m} }\\left(\\boldsymbol{x}_{\\boldsymbol{i} }\\right)=\\boldsymbol{y}_{\\boldsymbol{i} } \\\\ \\frac{\\boldsymbol{w}_{\\boldsymbol{m}, i} }{\\boldsymbol{Z}_{\\boldsymbol{m} }} \\boldsymbol{e}^{\\alpha_{m} }, &amp; \\boldsymbol{G}_{\\boldsymbol{m} }\\left(\\boldsymbol{x}_{i}\\right) \\neq \\boldsymbol{y}_{\\boldsymbol{i} }\\end{array}\\right. 可见，如果某个样本无法被第m个弱分类器Gm（x）分类成功，则需要增大该样本权重，否则减少该样本权重。这样，被错误分类样本会在训练第m+1个弱分类器Gm+1（x）时会被“重点关注”。 在每一轮学习过程中，Ada Boosting算法均在划重点（重视当前尚未被正确分类的样本） 3. 弱分类器组合成强分类器 以线性加权形式来组合弱分类器 f(x) f(x)=\\sum_{i=1}^{M} \\alpha_{m} G_{m}(x) 得到强分类器 G(x) G(x)=\\operatorname{sign}(f(x))=\\operatorname{sign}\\left(\\sum_{i=1}^{M} \\alpha_{m} G_{m}(x)\\right) - f（x）是M个弱分类器的**加权线性**累加。分类能力越强的弱分类器具有更大权重。 - \\alpha_{m} 累加之和并不等于1。 - f(x) 符号决定样本 x 分类为 1 或- 1 。如果 \\sum_{i=1}^{M} \\alpha_{m} G_{m}(x) 为正，则强分类器 G(x) 将样本 x 分类为1 ; 否则为-1。 **回看霍夫丁不等式** &gt; 假设有M个弱分类器Gm（1sm≤M），则M个弱分类器线性组合所产生误差满足如下条件： P\\left(\\sum_{i=1}^{M} G_{m}(x) \\neq \\zeta(x)\\right) \\leq e^{-\\frac{1}{2} M(1-2 \\epsilon)^{2} } - \\zeta(x) 是真实分类函数、∈（0，1）。上式表明，如果所“组合”弱分类器越多，则学习分类误差呈指数级下降，直至为零。 - 上述不等式成立有两个前提条件：1）每个弱分类器产生的误差相互独立；2）每个弱分类器的误差率小于50%。因为每个弱分类器均是在同一个训练集上产生，条件1）难以满足。也就说，“准确性（对分类结果而言）”和“差异性（对每个弱分类器而言）”难以同时满足。----&gt;Ada Boosting采取了序列化学习机制。 #### 优化目标 Ada Boost实际在最小化如下指数损失函数（minimization of exponential loss）： \\sum_{i} e^{-y_{i} f\\left(x_{i}\\right)}=\\sum_{i} e^{-y_{i} \\sum_{m=1}^{M} \\alpha_{m} G_{m}\\left(x_{i}\\right)} Ada Boost的分类误差上界如下所示： \\frac{1}{N} \\sum_{i=1}^{N} I\\left(G\\left(x_{i}\\right) \\neq y_{i}\\right) \\leq \\frac{1}{N} \\sum_{i} e^{-y_{i} f\\left(x_{i}\\right)}=\\prod_{m} Z_{m} 在第m次迭代中，Ada Boosting总是趋向于将具有最小误差的学习模型选做本轮生成的弱分类器Gm，使得累积误差快速下降。 ## 无监督学习 &gt; 无监督学习中，由于数据本身没有语义标签，因此我们对聚类结果无法知道到底代表的是怎样的高层语义 ![无监督学习](./《人工智能-模型与算法——浙江大学公开课》笔记/无监督学习.jpg) &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/无监督相似度.jpg\" alt=\"无监督相似度\" style=\"zoom:67%;\" /&gt; 数据特征和相似度函数都很重要 ### [P156.1K均值聚类](https://www.bilibili.com/video/BV1c7411n7EY?p=15)-kmeans 输入：n个数据（无任何标注信息） 输出：k个聚类结果 目的：将n个数据聚类到k个集合（也称为类簇） **算法描述** 若干定义: n个m 维数据 \\left\\{x_{1}, x_{2}, \\ldots, x_{n}\\right\\}, x_{i} \\in R^{m}(1 \\leq i \\leq n) - 两个 m 维数据之间的欧氏距离为 d\\left(x_{i}, x_{j}\\right)=\\sqrt{\\left(x_{i 1}-x_{j 1}\\right)^{2}+\\left(x_{i 2}-x_{j 2}\\right)^{2}+\\cdots+\\left(x_{i m}-x_{j m}\\right)^{2}} d\\left(x_{i}, x_{j}\\right) 值越小，表示 x_{i} 和 x_{j} 越相似; 反之越不相似 - 聚类集合数目 k 问题：如何将n个数据依据其相似度大小将它们分别聚类到 k 个集合，使得每个数据仅属于一个聚类集合。 1. 初始化——初始化聚类质心 - 初始化 k 个聚类质心 c=\\left\\{c_{1}, c_{2}, \\ldots, c_{k}\\right\\}, c_{j} \\in R^{m}(1 \\leq j \\leq k) - 每个聚类质心 c_{j} 所在集合记为 G_{j} 2. 对数据进行聚类——将每个待聚类数据放入唯一一个聚类集合中 - 计算待聚类数据 x_{i} 和质心 c_{j} 之间的欧氏距离 d\\left(x_{i}, c_{j}\\right)(1 \\leq i \\leq n, 1 \\leq j \\leq k) - 将每个 x_{i} &lt;u&gt;放入与之距离最近聚类质心所在聚类集合&lt;/u&gt;中,即 \\underset{c_{j \\in C} }{\\operatorname{argmin} } d\\left(x_{i}, c_{j}\\right) 3. 更新聚类质心——根据聚类结果、更新聚类质心 - 根据每个聚类集合中所包含的数据，更新该聚类集合质心值, 即 : c_{j}=\\frac{1}{\\left|G_{j}\\right|} \\sum_{x_{i} \\in G_{j} } x_{i} 4. 继续迭代——算法循环迭代，直到满足条件 聚类迭代满足如下任意一个条件，则聚类停止： - 已经达到了迭代次数上限 - 前后两次迭代中，聚类质心基本保持不变 **K均值聚类算法的另一个视角：最小化每个类簇的方差** - 欧氏距离与方差量纲相同 - **最小化每个类簇方差**将使得最终**聚类结果中每个聚类集合中所包含数据呈现出来差异性最小**。 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/kmeans.jpg\" alt=\"kmeans\" style=\"zoom:67%;\" /&gt; #### K均值聚类算法的不足 - 需要事先确定聚类数目，很多时候我们并不知道数据应被聚类的数目 - 需要初始化聚类质心，初始化聚类中心对聚类结果有较大的影响 - 算法是迭代执行，时间开销非常大 - 欧氏距离假设数据每个维度之间的重要性是一样的 ### [P166.2主成分分析](https://www.bilibili.com/video/BV1c7411n7EY?p=16)——Principle Component Analysis (PCA) &gt; 主成份分析是一种特征降维方法。人类在认知过程中会主动“化繁为简” &gt; 奥卡姆剃刀定律（Occam's Razor）：“如无必要，勿增实体”，即“简单有效原理” 主成份分析：**降维后的结果要保持原始数据固有结构** 啥是原始数据中的结构？: 1.图像数据中结构：视觉对象区域构成的空间分布 ; 2.文本数据中结构：单词之间的（共现）相似或不相似 若干相关概念：方差和协方差、皮尔逊相关系数 **方差** - 方差等于各个数据与样本均值之差的平方和之平均数 - 方差描述了样本数据的波动程度 **协方差** - 衡量两个变量之间的相关度 **皮尔逊相关系数** 我们可通过皮尔逊相关系数（Pearson Correlation coefficient）将两组变量之间的关联度规整到一定的取值范围内。 注：相关系数表达的是线性相关程度 **皮尔逊相关系数所具有的性质**如下： - | corr（X，Y）| ≤1 - corr（X，Y）=1的充要条件是存在常数a和b，使得Y=ax+b - 皮尔逊相关系数是对称的，即corr（X，Y）=corr（Y，X） - 由此衍生出如下性质：皮尔逊相关系数刻画了变量x和Y之间线性相关程度，如果| corr（x，Y）|的取值越大，则两者在线性相关的意义下相关程度越大。Icorr（x，Y）l=0表示两者不存在线性相关关系（可能存在其他非线性相关的关系）。 - 正线性相关意味着变量x增加的情况下，变量Y也随之增加；负线性相关意味着变量X减少的情况下，变量Y也随之增加。 **相关性（correlation）与独立性（independence）** - 如果X和Y的线性不相关，则|corr（xX，Y）l=0 - 如果X和Y的彼此独立，则一定lcorr（x，Y）l=0，且x和Y不存在任何线性或非线性关系 - “不相关”是一个比“独立”要弱的概念，即&lt;u&gt;独立一定不相关，但是不相关不一定相互独立&lt;/u&gt;（可能存在其他复杂的关联关系）。独立指两个变量彼此之间不相互影响。 #### 算法动机 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/PCA1.jpg\" alt=\"PCA1\" style=\"zoom:67%;\" /&gt; - 主成份分析思想是将n维特征数据映射到l维空间（n &gt;&gt; l），去除原始数据之间的冗余性（通过去除相关性手段达到这一目的）。 - 将原始数据向这些**数据方差最大的方向**进行投影。一旦发现了方差最大的投影方向，则继续寻找保持方差第二的方向且进行投影。 - 将每个数据从n维高维空间映射到l维低维空间，每个数据所得到最好的k维特征就是使得每一维上样本方差都尽可能大。 #### 算法描述 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/PCA2.jpg\" alt=\"PCA2\" style=\"zoom:67%;\" /&gt; #### 算法步骤 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/PCA3.jpg\" alt=\"PCA3\" style=\"zoom:67%;\" /&gt; 具体如何运行的可以看下节的特征人脸算法，讲的还是比较清楚的。 ### [P176.3特征人脸算法](https://www.bilibili.com/video/BV1c7411n7EY?p=17) &gt; 特征人脸方法是一种&lt;u&gt;应用主成份分析PCA&lt;/u&gt;来实现&lt;u&gt;人脸图像降维&lt;/u&gt;的方法，其本质是用一种称为“特征人脸（eigenface）”的特征向量按照线性组合形式来表达每一张原始人脸图像，进而实现人脸识别。==》将原有的像素点降维后，提取出新的PCA变量，即人脸特征===&gt;用（特征）人脸表示人脸，而非用像、素点表示人脸 &gt; &gt; 由此可见，这一方法的关键之处在于如何得到特征人脸。 **PCA降维计算：** &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/特征人脸-PCA运算.jpg\" alt=\"特征人脸-PCA运算\" style=\"zoom:67%;\" /&gt; #### 人脸对比方法：聚类、主成分分析、非负矩阵分解 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/人脸对比.jpg\" alt=\"人脸对比\" style=\"zoom:67%;\" /&gt; #### 特征人脸识别流程 ![人脸识别](./《人工智能-模型与算法——浙江大学公开课》笔记/人脸识别.jpg) ## 统计机器学习算法应用 ### [P187.1逻辑斯蒂回归与分类](https://www.bilibili.com/video/BV1c7411n7EY?p=18) #### 分类和回归的区别： - 在回归分析中，学习得到一个函数将输入变量映射到连续输出空间，如价格和温度等，即值域是连续空间。 - 在分类模型中，学习得到一个函数将输入变量映射到离散输出空间，如人脸和汽车等，即值域是离散空间。 问题：回归与分类可否统一，即用回归模型来完成分类任务？--&gt;demo：逻辑斯蒂回归（logistic regression） 回归分析：线性-&gt;非线性，线性回归模型难以刻画数据的复杂分布，需要寻找非线性回归模型——demo：逻辑斯蒂回归（logistic regression） #### sigmod函数性质 概率形式输出。sigmoid函数是单调递增的，其值域为**（0，1）**，因此使sigmoid函数输出可作为**概率值**。在前面介绍的线性回归中，回归函数的值域一般为（一oo，+oo） 数据特征加权累加。对输入z取值范围没有限制，但当z大于一定数值后，函数输出无限趋近于1，而小于一定数值后，函数输出无限趋近于0。特别地，当z=0时，函数输出为0.5。 这里z是输入数据x和回归函数的参数w相乘结果（可视为x各维度进行加权叠加）非线性变化。x各维度加权叠加之和结果取值在0附近时，函数输出值的变化幅度比较大（函数值变化陡峭），且是非线性变化。但是，各维度加权叠加之和结果取值很大或很小时，函数输出值几乎不变化，这是基于概率的一种认识与需要。 缺点：梯度消失 #### 概率输出：从回归到分类 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/logistics.jpg\" alt=\"logistics\" style=\"zoom:67%;\" /&gt; 对p(y=1|x)取对数的结果为 log(p(y=1|x)) = log( \\frac{p(y=1|x)}{p(y=0|x)}) = log(\\frac{p}{1-p}) = w^Tx+b - 对x作为正例可能性取对数得到线性回归模型 - x为正例的概率越大，几率取值就越大 - 线性回归模型输出结果去逼近（拟合）真实标记结果的对数几率 - 逻辑斯蒂回归函数被称为“对数几率回归（log-odds regression）\"。 - 对数几率回归模型的输出y可作为将输入数据x分类为某一类别概率的大小。 - 输出值越接近1，说明输入数据x分类为该类别的可能性越大。与此相反，输出值越接近0，输入数据x不属于该类别的概率越大。 - 根据具体应用设置一个阈值，将大于该阀值的输入数据x都归属到某个类别，小于该阈值的输入数据x都归属到另外一个类别。 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/logistics2.jpg\" alt=\"logistics2\" style=\"zoom:67%;\" /&gt; ★.从这里可以看出，logistic回归是一个线性模型。在预测时，可以通过计算线性函数wx+b取值是否大于0来判断输入数据x的类别归属。 #### 参数求解：最大似然函数 假定数据都是独立同分布的--&gt;最大似然函数==得到了--&gt;交叉熵(求解交叉熵，如果是线性模型可以用最小二乘法，但是logistics不行，可以考虑使用迭代算法——梯度下降法) **多分类**——output的时候加个softmax，并做归一化，概率最大的那个类别就是分类结果 ### [P197.2基于矩阵分解的潜在语义分析](https://www.bilibili.com/video/BV1c7411n7EY?p=19)——LSA 潜在语义分析（Latent Semantic Analysis，LSA或者Latent Semantic Indexing，LSI）是一种从海量文本数据中学习&lt;u&gt;单词-单词、单词-文档以及文档-文档之间&lt;/u&gt;隐性关系，进而得到文档和单词表达特征的方法。该方法的基本思想是综合考虑某些单词在哪些文档中同时出现，以此来决定该词语的含义与其他的词语的相似度。 潜在语义分析先构建一个单词-文档（term-document）矩阵A，进而寻找该矩阵的低秩逼近（low rank approximation）矩阵，从而来挖掘单词-单词、单词-文档以及文档·文档之间的关联关系。 举例 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/LSA.jpg\" alt=\"LSA\" style=\"zoom:67%;\" /&gt; - 当用户输入“optimization\"这一检索请求，由于文档a3标题中不包含这一单词，则文档a3被认为是不相关文档，但实际上文档a3所涉及“minimization\"内容与优化问题相关。出现这一问题是因为**单词-文档矩阵**只是刻画了&lt;u&gt;单词是否在文档中出现与否这一现象，而无法对单词-单词、单词-文档以及文档-文档之间语义关系进行建模。&lt;/u&gt; - 如果用户检索“eat an apple\"，则文档\"Apple is a great company”会被检索出来，而实际上该文档中单词\"Apple\"所指苹果公司、而非水果，造成这一结果的原因是一些单词具有“一词多义”。 - 因此需要一种方法能够建模单词-单词、单词-文档以及文档-文档之间语义关系，解决包括“异词同义”和“一词多义” 在内的诸多挑战。 #### 单词-文档矩阵（term-document）：构造与分解 &gt; 基于Latent Dirichlet Allocation（隐狄利克雷分配模型） ![LSA-TD](./《人工智能-模型与算法——浙江大学公开课》笔记/LSA-TD.jpg) 选取最大的前两个特征根及其对应的特征向量对矩阵A进行重建。下面给出了选取矩阵U、矩阵D和矩阵V的子部分重建所得矩阵A，效果如下： - 回到之前举的一个例子，用户输入“optimization”来检索与之相关的文档。尽管单词“optimization\"在文档a3中没有出现，但是在重建矩阵A2中，对应的位置被0.68取代，说明单词\"optimization\"对表征文档a3所蕴含内容具有重要作用，这也符合文档a3描述的minimization问题是一个optimization问题的事实。 - 在单词-矩阵A中，文档b3所对应network、gene和human三个单词取值为1，在重建矩阵A2中，network、gene和human三个单词取值分别为0.32、0.66和0.53。可见，network在表征文档b3时重要性降低，因为算法认为这一单词在机器学习所相关文档表达中更具有区别性。 为什么work？ 通过单词-文档矩阵（term-document）的构造与分解，可以将每个单词映射到维度为R的隐性空间、将每个文档映射到维度为R的隐性空间：统一空间，隐性空间可视为“主题空间（topic），因此就可以比较两个单词、两篇文章的主题是否一致了。 ### [P207.3线性区别分析及分类](https://www.bilibili.com/video/BV1c7411n7EY?p=20) 线性区别分析（linear discriminant analysis，LDA）是一种基于监督学习的降维方法，也称为Fisher线性区别分析（Fisher's Discriminant analysis，FDA）。 对于一组具有标签信息的高维数据样本，LDA利用其类别信息，将其线性投影到一个低维空间上，&lt;u&gt;在低维空间中同一类别样本尽可能靠近，不同类别样本尽可能彼此远离&lt;/u&gt;。==&gt;**为了获得“类内汇聚、类间间隔”的最佳投影结果** &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/LDA.jpg\" alt=\"LDA\" style=\"zoom:67%;\" /&gt; #### PCA和LDA区别 - 主成分分析（PCA）是一种&lt;u&gt;无监督学习&lt;/u&gt;的降维方法（无需样本类别标签），线性区别分析（LDA）是一种&lt;u&gt;监督学习&lt;/u&gt;的降维方法（需要样本类别标签。PCA和LDA均是优化寻找一定特征向量w来实现降维，其中PCA寻找投影后&lt;u&gt;数据之间方差最大&lt;/u&gt;的投影方向、LDA寻找“&lt;u&gt;类内方差小、类间距离大&lt;/u&gt;”投影方向。 - PCA对高维数据降维后的维数是与原始数据特征维度相关（&lt;u&gt;与数据类别标签无关&lt;/u&gt;）。假设原始数据维度为d，那么PCA所得数据的降维维度可以为小于d的任意维度；LDA降维后所得到维度是与&lt;u&gt;数据样本的类别个数K有关&lt;/u&gt;（与数据本身维度无关）。假设原始数据一共有K个类别，那么LDA所得数据的降维维度小于或等于K-1。 ## [P218.1深度学习基本概念](https://www.bilibili.com/video/BV1c7411n7EY?p=21)——深度学习 &gt; 浅层学习Versus深度学习：从分段学习到端到端学习；传统学习需要人工提取特征，深度神经网络可以通过层层网络自动提取特征。 &gt; &gt; &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/DL.jpg\" alt=\"DL\" style=\"zoom: 67%;\" /&gt; #### 神经元数学模型 1. 对相邻的前向神经元输入通过加权累加 : In =\\sum_{i=1}^{n} w_{i} * a_{i} 2. 对累加结果进行非线性变换（通过激活函数）： g(x) 3. 神经元的输出: O u t=g(i n) &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/神经元.jpg\" alt=\"神经元\" style=\"zoom:67%;\" /&gt; 注：神经元越多，非线性表达能力越强，同时参数也很变得更多，网络也会变得越复杂 ### [P228.2前馈神经网络](https://www.bilibili.com/video/BV1c7411n7EY?p=22)、[P238.3误差后向传播(BP)](https://www.bilibili.com/video/BV1c7411n7EY?p=23) - 各个神经元&lt;u&gt;接受前一级的输入&lt;/u&gt;，&lt;u&gt;并输出到下一级&lt;/u&gt;，模型中没有反馈 - 层与层之间通过“&lt;u&gt;全连接&lt;/u&gt;”进行链接，即两个相邻层之间的神经元完全成对连接，但层内的神经元不相互连接。 #### 感知机网络 感知机网络（Perceptron Networks）是一种特殊的前馈神经网络： - 无隐藏层，只有输入层/输出层 - 无法拟合复杂的数据 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/FNN-感知机.jpg\" alt=\"FNN-感知机\" style=\"zoom:67%;\" /&gt; #### 参数优化 ##### 1.GD梯度下降法 梯度下降算法是一种使得损失函数最小化的方法。一元变量所构成函数f在x处梯度为： \\frac{d f(x)}{d x}=\\lim _{h \\rightarrow 0} \\frac{f(x+h)-f(x)}{h} - 在多元函数中，梯度是对每一变量所求导数组成的向量 - 梯度的反方向是函数值下降最快的方向 ##### 2.误差反向传播BP - BP算法是一种将输出层误差反向传播给隐藏层进行参数更新的方法。= - 将误差从后向前传递，将误差分摊给各层所有单元，从而获得各层单元所产生的误差，进而依据这个误差来让各层单元负起各自责任、修正各单元参数。 ### [P249.1卷积神经网络](https://www.bilibili.com/video/BV1c7411n7EY?p=24) #### 卷积 Q：什么是卷积操作？A：可以理解为是滤波器，图像经过特定卷积矩阵滤波后，所得到的卷积结果可认为是保留了像素点所构成的特定空间分布模式 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/卷积.jpg\" alt=\"卷积\" style=\"zoom:67%;\" /&gt; &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/卷积-神经元.jpg\" alt=\"卷积-神经元\" style=\"zoom:67%;\" /&gt; 实际上卷积操作可以理解为是神经元的变形。 有一张32*32*3（RGB）的图像，使用5*5*3的卷积核Wi，步长为1对其进行卷积操作。卷积核W，在原始图像上从左到右、从上到下进行计算，改变5*5子块区域中的中心像素点值，得到28*28的特征图m1。 特征图：在深度学习里被定义为，原始图像经过卷积后得到的结果 ▲卷积参数的确定都是通过数据驱动来确定的 #### 池化 对输入的特征图进行**下采样**，以在区域内获得最主要信息 常用的池化操作有：最大池化、平均池化 ![平均池化](./《人工智能-模型与算法——浙江大学公开课》笔记/平均池化.jpg) #### 全连接、输出层 将特征从卷积操作后向输出层映射，最后通过输出层进行输出 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/全连接.jpg\" alt=\"全连接\" style=\"zoom:67%;\" /&gt; 综上：所需学习参数：卷积核、全连接层权重、激活函数参数 AlexNet：经典用来分类（识别）图像的卷积神经网络，包含5个卷积层、3个全连接层，有六千多万个参数，最终吧一个RGB的图像转换成了一个4096维的特征向量，接着将这个特征向量输入给分类函数，最后输出一个一千维的向量，一千维向量每个维度上的值表示该图像被识别为该维度指代对象的概率大小。 ### [P259.2-自然语言理解与视觉分析](https://www.bilibili.com/video/BV1c7411n7EY?p=25) #### 深度学习的应用：学习单词的表达----词向量（Word2Vec） 在基于规则和统计的自然语言传统方法中，将单词视为独立符号在向量空间中，一个单词按照其在文档中出现的有无，被表示为如下向量（按照字典序）：[0,0,0,1,...,0,0,0]（只有一个位置为1，其余为0） 上述表示方法称为One-hot向量。 缺点： - 维数灾难的困扰 - 无法刻画词与词之间的相似性：任意两个词之间都是孤立的 one-hot -&gt; 词向量: 可基于单词形成的向量进行后续操作 ##### 词向量模型的训练 通过单词 w_{t} 上下文单词的词向量来预测该单词 w_{t} 的词向量 : f\\left(w_{t}, w_{t-1}, \\ldots, w_{t-n+2}, w_{t-n+1}\\right)=p\\left(w_{t} \\mid \\text { context }\\right) 如下优化模型参数 \\theta, 以最大化训练数据的对数似然函数 : J=\\max {\\theta}\\left(\\log f\\left(w{t}, w_{t-1}, \\ldots, w_{t-n+2}, w_{t-n+1} ; \\theta\\right)+R(\\theta)\\right) &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/词向量.jpg\" alt=\"词向量\" style=\"zoom:67%;\" /&gt; 词向量模型：两种训练模式 - Continue Bag-of-Words（CBoW）：根据某个单词的上下文单词来预测该单词 - Skip-gram：利用某个单词来分别预测该单词的上下文单词 Word2 Vec的改进算法 - 对一个包含10000个单词的语料库，每个单词的词向量设为200维，则需要200*10000（2000000）和10000*200（2000000）异常庞大的权重矩阵 - 在如此大神经网络上进行梯度下降耗时为了解决这个不足，后续出现了如下改进手段： - Hierarchical Softmax（引入霍夫曼树） - Negative Sampling &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/词向量-单词类比.jpg\" alt=\"词向量-单词类比\" style=\"zoom:67%;\" /&gt; #### CNN-图像分类和定位 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/CNN图像分类和定位.jpg\" alt=\"CNN图像分类和定位\" style=\"zoom:67%;\" /&gt; #### 学习算法的改造：从浅层模型到深层模型 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/学习算法的改造从浅层模型到深层模型.jpg\" alt=\"学习算法的改造从浅层模型到深层模型\" style=\"zoom:67%;\" /&gt; ## [P2610.1强化学习定义](https://www.bilibili.com/video/BV1c7411n7EY?p=26) &gt; 人工智能领域中有三种学习的方法：1.以逻辑推理为核心的符号主义人工智能； 2.以数据建模为核心的机器学习； 3.以环境交互为核心的强化学习 建立在马尔科夫决策过程的基础之上，so what's MDP? &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/RL.jpg\" alt=\"RL\" style=\"zoom:67%;\" /&gt; #### 强化学习特点： &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/RL特点.jpg\" alt=\"RL特点\" style=\"zoom:67%;\" /&gt; #### 机器人移动：DMP-&gt;MRP-&gt;MDP ##### 离散马尔科夫过程DMP 一阶马尔科夫链： \\operatorname{Pr}\\left(X_{t+1}=x_{t+1} \\mid X_{0}=x_{0}, X_{1}=x_{1}, \\cdots, X_{t}=x_{t}\\right)=\\operatorname{Pr}\\left(X_{t+1}=x_{t+1} \\mid X_{t}=x_{t}\\right) 、t+1时刻状态仅与t时刻状态相关 二阶马尔科夫链： \\operatorname{Pr}\\left(X_{t+1}=x_{t+1} \\mid X_{t}=x_{t}, X_{t-1} = x_{t}\\right) 、t+1时刻状态与t和t-1时刻状态相关 &lt;img src=\"./《人工智能-模型与算法——浙江大学公开课》笔记/DMP1.jpg\" alt=\"DMP\" style=\"zoom:67%;\" /&gt; ##### 马尔可夫奖励过程（Markov Reward Process）： 引入奖励为了在序列决策中对目标进行优化，在马尔可夫随机过程框架中加入了奖励机制： - 奖励函数 R: S \\times S \\mapsto \\mathbb{R}, 其中 R\\left(S_{t}, S_{t+1}\\right) 描述了从第 t 步状态转移到第 t+1 步状态所获 得奖励 - 在一个序列决策过程中，不同状态之间的转移产生了一系列的奖励 \\left(R_{1}, R_{2}, \\cdots\\right), 其中 R_{t+1} 为 R\\left(S_{t}, S_{t+1}\\right) 的简便记法。 - 引入奖励机制，这样可以衡量任意序列的优劣，即对序列决策进行评价。 问题：给定两个因为状态转移而产生的奖励序列（1，1，0，0）和（0，0，1，1），哪个奖励序列更好？ A：为了比较不同的奖励序列，定义反馈（return），用来反映累加奖励：$$G_{t}=R_{t+1}+\\gamma R_{t+2}+\\gamma^{2} R_{t+3}+\\cdots 其中衰退系数（ decay factor） γ∈[0,1]\\gamma \\in[0,1]γ∈[0,1]，来表示当前的奖励越是重要，远的奖励虽然需要考虑，但是重要程度是衰减的。 假设 γ=0.99\\gamma=0.99γ=0.99 (1,1,0,0):G0=1+0.99×1+0.992×0+0.993×0=1.99: G_{0}=1+0.99 \\times 1+0.99^{2} \\times 0+0.99^{3} \\times 0=1.99:G0​=1+0.99×1+0.992×0+0.993×0=1.99 (0,0,1,1):G0=0+0.99×0+0.992×1+0.993×1=1.9504: G_{0}=0+0.99 \\times 0+0.99^{2} \\times 1+0.99^{3} \\times 1=1.9504:G0​=0+0.99×0+0.992×1+0.993×1=1.9504 可见，前一种反馈的累加更大，虽然(1,1,0,0)更好。 马尔可夫决策过程（Markov Decision Process） 马尔可夫决策过程（Markov Decision Process）：引入动作 在强化学习问题中，智能主体与环境交互过程中可自主决定所采取的动作，不同动作会对环境产生不同影响，为此： 定义智能主体能够采取的动作集合为A 由于不同的动作对环境造成的影响不同，因此状态转移概率定义为Pr（St+1∣St,at）Pr（S_{t+1}|S_t,a_t）Pr（St+1​∣St​,at​），其中atE A为第t步采取的动作 奖励可能受动作的影响，因此修改奖励函数为R（St，at，St+1）R（S_t，at，S_{t+1}）R（St​，at，St+1​） 相关术语 啥是策略 策略函数： 策略函数π：S×A→[0，1]，其中π（s，a）的值表示在状态s下采取动作a的概率。 策略函数的输出可以是确定的，即给定s情况下，只有一个动作a使得概率π（s，a）取值为1。 对于确定的策略，记为a=π（s）。 如何进行策略学习：一个好的策略是在当前状态下采取了一个行动后，该行动能够在未来收到最大化的反馈： π∗=argmaxπGt=Rt+1+γRt+2+γ2Rt+3+⋯\\pi^{*} = argmax_\\pi G_{t}=R_{t+1}+\\gamma R_{t+2}+\\gamma^{2} R_{t+3}+\\cdotsπ∗=argmaxπ​Gt​=Rt+1​+γRt+2​+γ2Rt+3​+⋯ 为了对策略函数工进行评估，定义。 价值函数（Value Function）V:S↦R,V: S \\mapsto \\mathbb{R},V:S↦R, 其中 Vπ(s)=Eπ[Gt∣St=s]V_{\\pi}(s)=\\mathbb{E}_{\\pi}\\left[G_{t} \\mid S_{t}=s\\right]Vπ​(s)=Eπ​[Gt​∣St​=s]，即在第t步状态为s时，按照策略π行动后在未来所获得反馈值的期望.(由马尔可夫性，未来的状态和奖励只与当前状态相关，与t无关。因此t取任意值该等式均成立，如“逢山开路，遇水搭桥”。) 动作-价值函数（Action-Value Function）q:S×A↦R,q: S \\times A \\mapsto \\mathbb{R},q:S×A↦R, 其中 qπ(s,a)=Eπ[Gt∣St=s,At=a]q_{\\pi}(s, a)=\\mathbb{E}_{\\pi}\\left[G_{t} \\mid S_{t}=s, A_{t}=a\\right]qπ​(s,a)=Eπ​[Gt​∣St​=s,At​=a] 表示在第t步状态为s时，按照策略π采取动作a后，在未来所获得反馈值的期望 ==&gt;这样，策略学习转换为如下优化问题：寻找一个最优策略π∗π*π∗，对任意s∈S使得Vπ∗（s）V_\\pi^{*}（s）Vπ∗​（s）值最大 价值函数与动作-价值函数的关系：对策略进行评估 Vπ(s)=Eπ[Rt+1+γRt+2+γ2Rt+3+⋯∣St=s]=Ea∼π(s,)[Eπ[Rt+1+γRt+2+γ2Rt+3+⋯∣St=s,At=a]]=∑a∈Aπ(s,a)qπ(s,a)qπ(s,a)=Eπ[Rt+1+γRt+2+γ2Rt+3+⋯∣St=s,At=a]=Es′∼Pr⁡(∣s,a)[R(s,a,s′)+γEπ[Rt+2+γRt+3+⋯∣St+1=s′]]=∑s′∈SPr⁡(s′∣s,a)[R(s,a,s′)+γVπ(s′)]\\begin{aligned} V_{\\pi}(s) &amp;=\\mathbb{E}_{\\pi}\\left[R_{t+1}+\\gamma R_{t+2}+\\gamma^{2} R_{t+3}+\\cdots \\mid S_{t}=s\\right] \\\\ &amp;=\\mathbb{E}_{a \\sim \\pi(s,)}\\left[\\mathbb{E}_{\\pi}\\left[R_{t+1}+\\gamma R_{t+2}+\\gamma^{2} R_{t+3}+\\cdots \\mid S_{t}=s, A_{t}=a\\right]\\right] \\\\ &amp;=\\sum_{a \\in A} \\pi(s, a) q_{\\pi}(s, a) \\\\ q_{\\pi}(s, a)=&amp; \\mathbb{E}_{\\pi}\\left[R_{t+1}+\\gamma R_{t+2}+\\gamma^{2} R_{t+3}+\\cdots \\mid S_{t}=s, A_{t}=a\\right] \\\\=&amp; \\mathbb{E}_{s^{\\prime} \\sim \\operatorname{Pr}(\\mid s, a)}\\left[R\\left(s, a, s^{\\prime}\\right)+\\gamma \\mathbb{E}_{\\pi}\\left[R_{t+2}+\\gamma R_{t+3}+\\cdots \\mid S_{t+1}=s^{\\prime}\\right]\\right] \\\\=&amp; \\sum_{s^{\\prime} \\in S} \\operatorname{Pr}\\left(s^{\\prime} \\mid s, a\\right)\\left[R\\left(s, a, s^{\\prime}\\right)+\\gamma V_{\\pi}\\left(s^{\\prime}\\right)\\right] \\end{aligned}Vπ​(s)qπ​(s,a)===​=Eπ​[Rt+1​+γRt+2​+γ2Rt+3​+⋯∣St​=s]=Ea∼π(s,)​[Eπ​[Rt+1​+γRt+2​+γ2Rt+3​+⋯∣St​=s,At​=a]]=a∈A∑​π(s,a)qπ​(s,a)Eπ​[Rt+1​+γRt+2​+γ2Rt+3​+⋯∣St​=s,At​=a]Es′∼Pr(∣s,a)​[R(s,a,s′)+γEπ​[Rt+2​+γRt+3​+⋯∣St+1​=s′]]s′∈S∑​Pr(s′∣s,a)[R(s,a,s′)+γVπ​(s′)]​ 贝尔曼方程（Bellman Equation）： 刻画了价值函数和行动-价值函数自身以及两者相互之间的递推关系 Vπ(s)=∑a∈Aπ(s,a)qπ(s,a),qπ(s,a)=∑s′∈SPr⁡(s′∣s,a)[R(s,a,s′)+γVπ(s′)]V_{\\pi}(s)=\\sum_{a \\in A} \\pi(s, a) q_{\\pi}(s, a) \\quad , q_{\\pi}(s, a)=\\sum_{s^{\\prime} \\in S} \\operatorname{Pr}\\left(s^{\\prime} \\mid s, a\\right)\\left[R\\left(s, a, s^{\\prime}\\right)+\\gamma V_{\\pi}\\left(s^{\\prime}\\right)\\right] Vπ​(s)=a∈A∑​π(s,a)qπ​(s,a),qπ​(s,a)=s′∈S∑​Pr(s′∣s,a)[R(s,a,s′)+γVπ​(s′)] 将右式带入左式，得到价值函数的贝尔曼方程 Vπ(s)=∑a∈Aπ(s,a)∑s′∈SPr⁡(s′∣s,a)[R(s,a,s′)+γVπ(s′)]V_{\\pi}(s)=\\sum_{a \\in A} \\pi(s, a) \\sum_{s^{\\prime} \\in S} \\operatorname{Pr}\\left(s^{\\prime} \\mid s, a\\right)\\left[R\\left(s, a, s^{\\prime}\\right)+\\gamma V_{\\pi}\\left(s^{\\prime}\\right)\\right] Vπ​(s)=a∈A∑​π(s,a)s′∈S∑​Pr(s′∣s,a)[R(s,a,s′)+γVπ​(s′)] 将左式带入右式，得到行动-价值函数的贝尔曼方程 qπ(s,a)=∑s′∈SPr⁡(s′∣s,a)[R(s,a,s′)+γ∑a′∈Aπ(s′,a′)qπ(s′,a′)]q_{\\pi}(s, a)=\\sum_{s^{\\prime} \\in S} \\operatorname{Pr}\\left(s^{\\prime} \\mid s, a\\right)\\left[R\\left(s, a, s^{\\prime}\\right)+\\gamma \\sum_{a^{\\prime} \\in A} \\pi\\left(s^{\\prime}, a^{\\prime}\\right) q_{\\pi}\\left(s^{\\prime}, a^{\\prime}\\right)\\right] qπ​(s,a)=s′∈S∑​Pr(s′∣s,a)[R(s,a,s′)+γa′∈A∑​π(s′,a′)qπ​(s′,a′)] 将利用贝尔曼方程进行策略评估，进而进行策略优化 P2710.2策略优化与策略评估 基于价值的求解方法： 第一部分：策略优化； 第二部分：策略评估 通过迭代计算贝尔曼方程进行策略评估 动态规划 动态规划法的缺点： 1）智能主体需要事先知道状态转移概率（model-base）； 2）无法处理状态集合大小无限的情况 蒙特卡洛采样 蒙特卡洛采样法的优点 智能主体不必知道状态转移概率· 容易扩展到无限状态集合的问题中 蒙特卡洛采样法的缺点 状态集合比较大时，一个状态在轨迹可能非常稀疏，不利于估计期望 在实际问题中，最终反馈需要在终止状态才能知晓，导致反馈周期较长 时序差分（Temporal Difference） P2810.3强化学习求解QLearning 基于时序差分的方法-Q学习（Q-Learning）[Q:quality] 无探索的Qlearning 使用e贪心策略的Q学习 P2910.4深度强化学习 用神经网络拟合（行动）价值函数 问题： 状态数量太多时，有些状态可能始终无法采样到，因此对这些状态的q函数进行估计是很困难的 状态数量无限时，不可能用一张表（数组）来记录q函数的值 解决思路： 将q函数参数化（parametrize），用一个非线性回归模型来拟合q函数，例如（深度）神经网络 能够用有限的参数刻画无限的状态 由于回归函数的连续性，没有探索过的状态也可通过周围的状态来估计 深度Q学习与梯度下降法 深度Q学习的两个不稳定因素-&gt;DQN 样本相关性太强 在损失函数中，q函数的值既用来估计目标值，又用来计算当前值。现在这两处的q函数通过e有所关联，可能导致优化时不稳定 DQN 经验重现 样本相关性太强=&gt;经验重现 目标网络 在损失函数中，q函数的值既用来估计目标值，又用来计算当前值。现在这两处的q函数通过e有所关联，可能导致优化时不稳定-&gt;目标网络 P3011.1博弈相关概念——人工智能博弈 博弈行为：带有相互竞争性质的主体，为了达到各自目标和利益，采取的带有对抗性质的行为。 博弈论主要研究博弈行为中最优的对抗策略及其稳定局势，协助人们在一定规则范围内寻求最合理的行为方式。 ​ 博弈的要素 参与者或玩家（player）：参与博弈的决策主体 策略（strategy）：参与者可以采取的行动方案，是一整套在采取行动之前就已经准备好的完整方案。 某个参与者可采纳策略的全体组合形成了策略集（strategy set） 所有参与者各自采取行动后形成的状态被称为局势（outcome） 如果参与者可以通过一定概率分布来选择若干个不同的策略，这样的策略称为混合策略（mixed strategy）。若参与者每次行动都选择某个确定的策略，这样的策略称为纯策略（pure strategy） 收益（payoff）：各个参与者在不同局势下得到的利益 混合策略意义下的收益应为期望收益（expected payoff）规则（rule）：对参与者行动的先后顺序、参与者获得信息多少等内容的规定 囚徒困境（prisoner’s dilemma） 数学家阿尔伯特·塔克：警方逮捕了共同犯罪的甲、乙两人，由于警方没有掌握充分的证据，所以将两人分开审讯： 若一人认罪并指证对方，而另一方保持沉默，则此人会被当即释放，沉默者会被判监禁10年 若两人都保持沉默，则根据已有的犯罪事实（无充分证据）两人各判半年 若两人都认罪并相互指证，则两人各判5年 在囚徒困境中，最优解为两人同时沉默，但是两人实际倾向于选择同时认罪（均衡解） 囚徒困境产生的原因： 对甲而言，若乙沉默，自己认罪的收益为0，而自己也沉默则收益为-0.5；若乙认罪，自己认罪则收益为-5，自己沉默则收益为-10 对乙而言，若甲沉默，自己认罪的收益为0，而自己也沉默则收益为-0.5；若甲认罪，自己认罪的收益为-5，自己沉默则收益为-10 即对个人而言，认罪的收益在任何情况下都比沉默的收益高，所以两人同时认罪是一个稳定的局势，其他三种情况都不是稳定局势 ▲.囚徒困境表明稳定局势并不一定是最优局势 博弈的分类 合作博弈与非合作博弈 合作博弈（cooperative game）：部分参与者可以组成联盟以获得更大的收益 非合作博弈（non-cooperative game）：参与者在决策中都彼此独立，不事先达成合作 意向静态博弈与动态博弈 静态博弈（static game）：所有参与者同时决策，或参与者互相不知道对方的决策 动态博弈（dynamic game）：参与者所采取行为的先后顺序由规则决定，且后行动者知道先行动者所采取的行为 完全信息博弈与不完全信息博弈 完全信息（complete information）：所有参与者均了解其他参与者的策略集、收益等信息 不完全信息（incomplete information）：并非所有参与者均掌握了所有信息 囚徒困境是一种非合作、不完全信息的静态博弈 纳什均衡 博弈的稳定局势即为纳什均衡（Nash equilibrium）： 指的是参与者所作出的这样一种策略组合，在该策略组合上，任何参与者单独改变策略都不会得到好处。换句话说，如果在一个策略组合上，当所有其他人都不改变策略时，没有人会改变自己的策略，则该策略组合就是一个纳什均衡。 Nash定理：若参与者有限，每位参与者的策略集有限，收益函数为实值函数，则博弈必存在混合策略意义下的纳什均衡。 囚徒困境中两人同时认罪就是这一问题的纳什均衡。 another Example: P3111.2遗憾最小化算法 博弈论与计算机科学的交叉领域非常多 理论计算机科学：算法博弈论 人工智能：多智能体系统、AI游戏玩家、人机交互、机器学习、广告推荐 互联网：互联网经济、共享经济 分布式系统：区块链 人工智能与博弈论相互结合，形成了两个主要研究方向 博弈策略的求解 为什么引入博弈论的动机 ·博弈论提供了许多问题的数学模型 ·纳什定理确定了博弈过程问题存在解 ·人工智能的方法可用来求解均衡局面或者最优策略 应用领域 ·大规模搜索空间的问题求解：围棋 ·非完全信息博弈问题求解：德州扑克 ·网络对战游戏智能：Dota、星球大战 ·动态博弈的均衡解：厂家竞争、信息安全 博弈规则的设计 问题描述 ·假设博弈的参与者都是足够理性的 ·如何设计一个博弈规则能确保公正性或者达到设计者的最大利益 挑战 ·规则复杂 ·计算量大 应用领域 ·拍卖竞价：互联网广告投放、车牌竞价 ·供需匹配：污染权、学校录取 ·公正选举：选举制度、表决制度、议席分配 RM算法若干定义 假设一共有N个玩家。玩家 iii 所采用的策略表示为 σi\\sigma_{i}σi​ 。 对于每个信息集 Ii∈ξi,σi(Ii):A(Ii)→[0,1]I_{i} \\in \\xi_{i}, \\sigma_{i}\\left(I_{i}\\right): A\\left(I_{i}\\right) \\rightarrow[0,1]Ii​∈ξi​,σi​(Ii​):A(Ii​)→[0,1] 是在动作集 A(Ii)A\\left(I_{i}\\right)A(Ii​) 上的概率分布函数。玩家 iii 的策 略空间用 Σi\\Sigma_{i}Σi​ 表示。 一个策略组包含所有玩家策略，用 σ=(σ1,σ2,…,σ∣N∣)\\sigma=\\left(\\sigma_{1}, \\sigma_{2}, \\ldots, \\sigma_{|N|}\\right)σ=(σ1​,σ2​,…,σ∣N∣​) σ−i\\sigma_{-i}σ−i​ 表示 σ\\sigmaσ 中除了 σi\\sigma_{i}σi​ 之外的策略（即除去玩家 iii 所采用的策略 ))) 在博亦对决中，不同玩家在不同时刻会采取相应策略以及行动。策略\\sigma下对应的行动序列 hhh 发生的概率表示为 πσ(h)\\pi^{\\sigma}(h)πσ(h) 。于是, πσ(h)=∏i∈Nπiσ(h),\\pi^{\\sigma}(h)=\\prod_{i \\in N} \\pi_{i}^{\\sigma}(h),πσ(h)=∏i∈N​πiσ​(h), 这里 πiσ(h)\\pi_{i}^{\\sigma}(h)πiσ​(h) 表示玩家 iii 使用策略 σi\\sigma_{i}σi​ 促 使行动序列 hhh 发生的概率。除玩家 iii 以外，其他玩家通过各自策略促使行动序列h发生的概率 可表示为 :π−iσ(h)=∏j∈N\\{i}πjσ(h): \\pi_{-i}^{\\sigma}(h)=\\prod_{j \\in N \\backslash\\{i\\}} \\pi_{j}^{\\sigma}(h):π−iσ​(h)=∏j∈N\\{i}​πjσ​(h) 对于每个玩家 i∈N,ui:Z→Ri \\in N, u_{i}: Z \\rightarrow Ri∈N,ui​:Z→R 表示玩家 iii 的收益函数，即在到达终止序列集合Z中某个终 止序列时，玩家 iii 所得到的收益。 玩家 iii 在给定策略 σ\\sigmaσ 下所能得到的期望收益可如下计算: ui(σ)=∑h∈Zui(h)πσ(h)u_{i}(\\sigma)=\\sum_{h \\in Z} u_{i}(h) \\pi^{\\sigma}(h)ui​(σ)=∑h∈Z​ui​(h)πσ(h) 悔值： 遗憾最小化算法：策略选择介绍 遗憾最小化算法是一种根据过去博将中的遗憾程度来决定将来动作选择的方法 在博亦中，玩家i在第T轮次（每一轮表示一次博将完成）采取策略 σi\\sigma_{i}σi​ 的遗憾值定义如 下（累加遗憾）: &nbsp;Regret&nbsp;iT(σi)=∑t=1T(μi(σi,σ−it)−μi(σt))\\text { Regret }_{i}^{T}\\left(\\sigma_{i}\\right)=\\sum_{t=1}^{T}\\left(\\mu_{i}\\left(\\sigma_{i}, \\sigma_{-i}^{t}\\right)-\\mu_{i}\\left(\\sigma^{t}\\right)\\right) &nbsp;Regret&nbsp;iT​(σi​)=t=1∑T​(μi​(σi​,σ−it​)−μi​(σt)) 通常遗憾值为负数的策略被认为不能提升下一时刻收益，所以这里考虑的遗憾值均为 正数或0 计算得到玩家 iii 在第T轮次采取策略 σi\\sigma_{i}σi​ 的遗憾值后，在第 T+1T+1T+1 轮次玩家 iii 选择策略 aaa 的概 率如下（悔值越大、越选择，即亡羊补牢） P(a)=Regret⁡iT(a)∑b∈{&nbsp;所有可选择策略&nbsp;}Regret⁡iT(b)P(a)=\\frac{\\operatorname{Regret}_{i}^{T}(a)}{\\sum_{b \\in\\{\\text { 所有可选择策略 }\\}} \\operatorname{Regret}_{i}^{T}(b)} P(a)=∑b∈{&nbsp;所有可选择策略&nbsp;}​RegretiT​(b)RegretiT​(a)​ demo石头剪刀布 为了解决博弈状态空间大的问题-&gt;虚拟遗憾最小化算法 P3211.3虚拟遗憾最小化算法 如果不能遍历计算所有节点的遗憾值，那么可以采用虚拟遗憾最小化算法来进行模拟计算 假设: 集合 AAA 是博亦中所有玩家所能采用的行为集（如在石头-剪刀-布游戏中出石头、出剪刀或出布三种行 为 ））） I为信息集，包含了博亦的规则以及玩家采取的历史行动，在信息集I下所能采取的行为集合记为 A(IA(IA(I 玩家 iii 在第 ttt 轮次采取的行动 ai∈A(Ii)a_{i} \\in A\\left(I_{i}\\right)ai​∈A(Ii​) 反映了其在该轮次所采取的策略 σit\\sigma_{i}^{t}σit​ 。包含玩家 iii 在内的 所有玩家在第t轮次采取的行动 a∈A(I)a \\in A(I)a∈A(I) 构成了一组策略组合 σ∘t\\sigma_{\\circ}^{t}σ∘t​ 在信息集I下采取行动a所反映的策略记为 σI→a\\sigma_{I \\rightarrow a}σI→a​ 。 在第t轮次所有玩家采取的行动是一条序列，记为 h∘h_{\\circ}h∘​ 采取某个策略 σ\\sigmaσ 计算行动序列 hhh 出现的概率记为 πσ(h)\\pi^{\\sigma}(h)πσ(h) 每个信息集I发生的概率 πσ(I)=∑h∈Iπσ(h),\\pi^{\\sigma}(I)=\\sum_{h \\in I} \\pi^{\\sigma}(h),πσ(I)=∑h∈I​πσ(h), 表示所有能够到达该信息集的行动序 列的概率累加。 给定博亦的终结局势z ∈Z,\\in Z,∈Z, 玩家 iii 在游戏结束后的收益记作 ui(z)u_{i}(z)ui​(z) 在策略组合 σ\\sigmaσ 下，施加博亦行动序列 hhh 后达到最终局势z的概率为 πσ(h,z)\\pi^{\\sigma}(h, z)πσ(h,z) 当采取策略\\sigma时，其所对应的行动序列h的虚拟价值（Counterfactual Value）如下 计算(注：行动序列 hhh 未能使博亦进入终结局势): vi(σ,h)=∑z∈Zπ−iσ(h)πσ(h,z)ui(z)v_{i}(\\sigma, h)=\\sum_{z \\in Z} \\pi_{-i}^{\\sigma}(h) \\pi^{\\sigma}(h, z) u_{i}(z) vi​(σ,h)=z∈Z∑​π−iσ​(h)πσ(h,z)ui​(z) 玩家i采取行动a所得到的虚拟遗憾值: r(h,a)=vi(σI→a,h)−vi(σ,h)r(h, a)=v_{i}\\left(\\sigma_{I \\rightarrow a}, h\\right)-v_{i}(\\sigma, h) r(h,a)=vi​(σI→a​,h)−vi​(σ,h) 行动序列 hhh 所对应的信息集I遗憾值为 r(I,a)=∑h∈Ir(h,a)r(I, a)=\\sum_{h \\in I} r(h, a) r(I,a)=h∈I∑​r(h,a) 玩家 iii 在第T轮次采取行动a的遗憾值为 : Regret⁡iT(I,a)=∑t=1Trit(I,a)\\operatorname{Regret}_{i}^{T}(I, a)=\\sum_{t=1}^{T} r_{i}^{t}(I, a) RegretiT​(I,a)=t=1∑T​rit​(I,a) 同样，对于遗憾值为负数的情况，我们不予考虑，记: &nbsp;Regret&nbsp;iT,+(I,a)=max⁡(RiT(I,a),0)\\text { Regret }_{i}^{T,+}(I, a)=\\max \\left(R_{i}^{T}(I, a), 0\\right) &nbsp;Regret&nbsp;iT,+​(I,a)=max(RiT​(I,a),0) 在 T+1T+1T+1 轮次，玩家 iii 选择行动 aaa 的概率计算如下 σiT+1(I,a)={Regret⁡iT,+(I,a)Regret⁡iT,+(I,a)&nbsp;if&nbsp;∑a∈A(I)Regret⁡iT,+(I,a)&gt;01∣A(I)∣&nbsp;otherwise&nbsp;\\sigma_{i}^{T+1}(I, a)=\\left\\{\\begin{array}{ll} \\frac{\\operatorname{Regret}_{i}^{T,+}(I, a)}{\\operatorname{Regret}_{i}^{T,+}(I, a)} \\text { if } \\sum_{a \\in A(I)} \\operatorname{Regret}_{i}^{T,+}(I, a)&gt;0 \\\\ \\frac{1}{|A(I)|} &amp; \\text { otherwise } \\end{array}\\right. σiT+1​(I,a)={RegretiT,+​(I,a)RegretiT,+​(I,a)​&nbsp;if&nbsp;∑a∈A(I)​RegretiT,+​(I,a)&gt;0∣A(I)∣1​​&nbsp;otherwise&nbsp;​ 玩家i根据遗憾值大小来选择下一时刻行为，如果遗憾值为负数，则随机挑选一种行 为进行博亦（由于规定regret不为负数，因此随机取的概率不会出现） demo库恩扑克（Kunh’s pocker） 库恩扑克是最简单的限注扑克游戏，由两名玩家进行游戏博弈，牌值只有1，2和3三种情况 每轮每位玩家各持一张手牌，根据各自判断来决定加定额赌注 游戏没有公共牌，摊牌阶段比较未弃牌玩家的底牌大小，底牌牌值最大的玩家即为胜者 游戏规则定义： |玩家A|玩家B|玩家A|结果| | ---- | ---- | ---- | |过牌|过牌||牌值大的玩家+1| |加注|加注||牌值大的玩家+2| |过牌|加注|过牌|玩家B+1| |过牌|加注|加注|牌值大的玩家+2| |加注|过牌||玩家A+1| 算法步骤 该问题中进行策略选择的算法步骤如下： 1.初始化遗憾值和累加策略表为02.采用随机选择的方法来决定策略 3.利用当前策略与对手进行博弈4.计算每个玩家采取每次行为后的遗憾值5.根据博弈结果计算每个行动的累加遗憾值大小来更新策略 6.重复博弈若干次 7.根据重复博弈最终的策略，完成最终的动作选择 G-S算法（Gale-Shapley） 在生活中，人们常常会碰到与资源匹配相关的决策问题（如求职就业、报考录取等），这些需要双向选择的情况被称为是双边匹配问题。在双边匹配问题中，需要双方互相满足对方的需求才会达成匹配 匹配的稳定是指没有任何人能从偏离稳定状态中获益。如果将匹配问题看做是一种合作博弈的话，稳定状态解就是纳什均衡解 1962年，美国数学家大卫·盖尔和博弈论学家沙普利提出了针对双边稳定匹配问题的解决算法，并将其应用于稳定婚姻问题的求解 稳定婚姻问题（stable marriage problem）是指在给定成员偏好的条件下，为两组成员寻找稳定匹配。由于这种匹配并不是简单地价高者得，所以匹配解法应考虑双方意愿 稳定婚姻问题的稳定解是指不存在未达成匹配的两个人都更倾向于选择对方胜过自己当前的匹配对象 最大交易圈算法（Top-Trading Cycle algorithm） 在匹配问题中，还有一类交换不可分的标的物的匹配问题，被称为单边匹配问题，如远古时期以物易物、或者宿舍的床位分配 1974年，沙普利和斯卡夫提出了针对单边匹配问题的稳定匹配算法：最大交易圈算法（TTC），算法过程如下： 首先每个交易者连接一条指向他最喜欢的标的物的边，并从每一个标的物连接到其占有者或是具有高优先权的交易者。 此时形成一张有向图，且必存在交易圈，对于交易圈中的交易者，将每人指向节点所代表的标的物赋予其，同时交易者放弃原先占有的标的物，占有者和匹配成功的标的物离开匹配市场。 接着从剩余的交易者和标的物之间重复进行交易圈匹配，直到无法形成交易圈，算法停止。 P3311.4人工智能安全 基于人工智能的信息安全技术：加密技术 将明文信息处理为难以读取的密文内容，使之不可读。 在网络环境中保障通信安全，保证数据的完整性 目前常用的加密算法有安全哈希算法（Secure Hash Algorithm，SHA）和高级加密标准（Advanced Encryption Standard，AES） 使用神经网络的加密算法 2016年谷歌大脑的研究团队提出了使用对抗生成网络GAN生成的一个加密算法，其使用了三个神经网络分别完成加密、解密和攻击的工作，以保证通信双方信息的无损传输以及第三方无法破译通信内容 基于人工智能的信息安全技术：数字水印 将特定信息（版权信息等）嵌入在数字信号中，数字信号可能是音频、视频、图片等。 当拷贝信息时，水印内容会被同时拷贝，所以水印内容可作为版权信息的证明，这样能避免或阻止数字媒体未经授权的复制和拷贝 近年来通过神经网络来添加水印和提取水印信息的成为学术研究热点。 人工智能的安全：数据安全与模型安全 人工智能很大程度是依靠数据驱动学习 可用性（availability） 训练数据是否充足且可靠 训练数据是否有足够的标注 完整性（completeness） 数据是否具有代表性 隐私性（privacy） 数据是否涉及隐私安全问题 如何保障数据不被窃取 人工智能所使用的的模型是由有限的训练数据训练得到的 鲁棒性（robustness） 模型是否易于受到噪声干扰或攻击 正确性（correctness） 模型是否正确 通用性（generality） 模型是否能够应用于现实场景 模型对输入数据是否有过高的要求 人工智能的安全：对模型的攻击 对模型的攻击 使用特定技术对输入样本进行微小的修改就可骗过模型而得到错误的结果 这种经过修改，使得模型判断错误的样本被称为对抗样本 白盒攻击 攻击者熟知人工智能模型的算法和模型参数，生成对抗样本的过程可以与模型的每一部分进行交互 对人工智能模型的白盒攻击通常会对模型的每一部分进行逐层分解，然后对每一部分添加一定的扰动，使得模型的结果逐步向误判目标类别偏移 这是一种非常隐蔽的攻击手段，通过限制扰动的大小可以使得对抗样本看起来与原样本差别很小 白盒攻击的防御策略：生成对抗网络 黑盒攻击 攻击者只能给定输入去获得模型输出，但并不知道被攻击模型所使用的算法和参数 黑盒攻击可以针对任何一个人工智能模型 常用的黑盒攻击防御策略有： ·数据压缩：通过对输入数据进行压缩或者降维，在保证识别准确率的情况下提升模型对干扰攻击的鲁棒性 ·数据随机化：对训练数据进行随机缩放、增强等操作，提升模型的鲁棒性 ·训练额外的网络来判断训练数据是否为攻击样本 P3412.1记忆驱动的智能计算 P3512.2可计算社会学 P3612.3若干挑战","categories":[],"tags":[{"name":"ZJU","slug":"ZJU","permalink":"https://nymrli.top/tags/ZJU/"},{"name":"ML","slug":"ML","permalink":"https://nymrli.top/tags/ML/"}]},{"title":"枚举类的优雅写法Java->Python","slug":"枚举类的优雅写法Java-Python","date":"2020-12-05T08:19:27.000Z","updated":"2020-12-05T08:44:17.991Z","comments":true,"path":"2020/12/05/枚举类的优雅写法Java-Python/","link":"","permalink":"https://nymrli.top/2020/12/05/枚举类的优雅写法Java-Python/","excerpt":"","text":"枚举类型作为与接口、类同一级别的存在，自然有它独特的用途。至于它性能上的优势暂且不谈，我们在这篇文章中只是考虑怎么把Enum写得更优雅 Java Enum的写法 在阿里实习的时候印象最深的就是学到了枚举的写法， 大致如下所示 123456789101112131415161718192021222324252627282930313233343536373839404142public enum EnumOperationPermission implements IEnumBehaviour &#123; // ----------------------- 实际的枚举对象 ------------------------ SAVE(\"保存\", 0), SUBMIT(\"提交\", 1), BACK(\"退回\", 2), VIEWCOMMENTS(\"查看意见\", 3), SIGN(\"签发\", 4), DISTRIBUTE(\"分发\", 5), CALLBACK(\"撤回\", 6), NODE(\"节点\", 7), BROWSINFO(\"浏览情况\", 8), FINISH(\"完成\", 9), DETAIL(\"订票明细\",10); // ----------------------- 实际的枚举对象 ------------------------ private String mName; private int mId; private EnumOperationPermission(String name, int id) &#123; this.mName = name; this.mId = id; &#125; // 一般只有get, 没有set public String getName() &#123; return mName; &#125; public int getId() &#123; return mId; &#125; // 下面的用途为自定义跟enum的valueOf相同， 即通过某个值返回enum这个类 public static EnumOperationPermission parse(String name) &#123; EnumOperationPermission[] enumList = EnumOperationPermission.values(); for (IEnumBehaviour enumInstance : enumList) &#123; if (enumInstance.toString().equalsIgnoreCase(name) || enumInstance.getName().equalsIgnoreCase(name) || String.valueOf(enumInstance.getId()).equalsIgnoreCase(name)) &#123; return (EnumOperationPermission) enumInstance; &#125; &#125; return EnumOperationPermission.SAVE; &#125; &#125; Python 最简易的写法 12345from enum import Enumclass Color(Enum): RED = 1 YELLOW = 2 BLUE = 3 枚举类的特点: 标签值不可被修改 一个标签只能对应一个值，但多个标签可以对应相同的值(别名) --&gt; 不同key可以有相同的val( 如果不允许存在相同val, 则在类前加上装饰器@unique， 需要从enum包中导入) 枚举类型可以做等值比较和身份比较，但是不能做大小比较： 12345678910from enum import Enumclass Color(Enum): RED = 1 YELLOW = 1 BLUE = 3print(Color.RED == Color.YELLOW) Trueprint(Color.RED is Color.YELLOW) True 枚举类型、枚举名称、枚举值 跟Java不同的是，Java一般自己定义有哪些属性，如name, code。 而Python中有设好的name和value属性 1234567891011&gt; class Enum(metaclass=EnumMeta):&gt; @DynamicClassAttribute&gt; def name(self):&gt; \"\"\"The name of the Enum member.\"\"\"&gt; return self._name_&gt; &gt; @DynamicClassAttribute&gt; def value(self):&gt; \"\"\"The value of the Enum member.\"\"\"&gt; return self._value_&gt; 枚举类型就是指这个枚举类； 枚举实例就是指枚举类型下的具体实例 枚举名称为枚举类型实例的key，本质是Enum.name 枚举名称为枚举类型实例的value，本质Enum.value 如何使用枚举类型 可以用读取字典的方式来读取，并且可以遍历： 12345678910111213from enum import Enumclass Color(Enum): RED = 1 YELLOW = 1 BLUE = 3print(Color['RED']) 访问for e in Color: 遍历 print(e) 当多个标签对应相同值时，第一个定义的为主名，其他的为别名 直接遍历无法输出别名，可以用__members__来全部输出for e in Color.__members__: print(e) 注意Python中是没有类似Java中EnumOperationPermission.values();来获得枚举的所有实例对象的 如何从python enum类获取所有值？ 如何像Java中一样EnumOperationPermission.values();呢？https://oomake.com/question/8760202中提到Enum有一个members字典，经翻阅源码后发现3.6中并没有这个字典，有的是__member__属性，其返回值为OrderedDict 123456789101112131415class EnumMeta(type): def __new__(metacls, cls, bases, classdict): ... enum_class._member_names_ = [] names in definition order enum_class._member_map_ = OrderedDict() name-&gt;value map @property def __members__(cls): \"\"\"Returns a mapping of member name-&gt;value. This mapping lists all enum members, including aliases. Note that this is a read-only view of the internal mapping. \"\"\" return MappingProxyType(cls._member_map_) 所有写法有: 通过类的value属性来获得所有值 12345678910111213from enum import Enumclass Color(Enum): RED = 1 GREEN = 'GREEN' BLUE = ('blue', '#0000ff') @staticmethod def list(): ''' 获得所有值 ''' return list(map(lambda c: c.value, Color))print(Color.list()) 模仿Java写法 12345678910111213141516class Chess(Enum): BLACK = &#123;'graph': 'X', 'val': 0&#125; WHITE = &#123;'graph': 'O', 'val': 1&#125; def getChess(color): for c in Chess: if color == c.value.get(\"graph\"): return c def getVal(self): return self.value.get('val') def getGraph(self): return self.value.get('graph')","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"理解科学计算(numpy,pytorch)中的dim参数","slug":"理解科学计算中的dim参数","date":"2020-12-05T03:53:10.000Z","updated":"2020-12-10T06:22:37.272Z","comments":true,"path":"2020/12/05/理解科学计算中的dim参数/","link":"","permalink":"https://nymrli.top/2020/12/05/理解科学计算中的dim参数/","excerpt":"","text":"😄理解numpy中array和pytorch中tensor的操作是开始科学运算的第一步! 首先明白维度的感念： 维度 我们通常能听到的都是2D, 3D，其实这边的D就是dimension的含义即维度。2D，我们通常理解为是平面，如我们最熟悉的直角坐标系就是平面坐标系，还有极坐标系。而3D呢，就是在平面的基础上增加了一维——高度，从而使平面的物体立起来了，同样3D也有耳熟能详的坐标系——3维坐标系。 更官方的解释呢：维度（Dimension），又称为维数，是数学中独立参数的数目。在物理学和哲学的领域内，指独立的时空坐标的数目。0维是一个无限小的点，没有长度。1维是一条无限长的线，只有长度。2维是一个平面，是由长度和宽度(或部分曲线)组成面积。3维是2维加上高度组成体积。4维分为时间上和空间上的4维，人们说的4维通常是指关于物体在时间线上的转移。（4维准确来说有两种。1.四维时空，是指三维空间加一维时间。2.四维空间，只指四个维度的空间。）四维运动产生了五维。 从哲学角度看，人们观察、思考与表述某事物的“思维角度”，简称“维度”。例如，人们观察与思考“月亮”这个事物，可以从月亮的“内容、时间、空间”三个思维角度去描述；也可以从月亮的“载体、能量、信息”三个思维角度去描述。这边的维度其实也可以理解为角度，从不同的方面去看待、确定一个事物。 所以代数上来说，维度其实是数学里在表示方面的一个重要的概念，它反映的是一个空间的本质性质。 科学计算中维度的概念 从二维点位置-&gt;编程中的坐标系 维度的考量主要集中在矩阵的运算上。首先我们来看一个元素：4，其实它就是一个点，可以被认为是0维的。但往往我们不会只有一个元素。我们最常见的是编程中的数组，如[1,2,3,4]，这个是由多个元素构成的，它的维度就是一维的，这个我们也比较好理解。 而二维是什么呢？我们能直观理解的二维是平面坐标系的那种：(1,3), (4,5)…即给一个x，一个y，那么在平面中就可以在直角坐标系下确定这个点（物）。现在我们规整下这些坐标点[ (1, 3), (4, 5) ]，从这个角度上离我们的矩阵，或是数组好像还是有点远。那么我们继续变形。 如果我们需要画出坐标系中有哪些点的话， 1.第一种做法就是跟上述一样， 把点都存一个vector中[ (1, 3), (4, 5) ]，然后遍历，再在坐标系中点出。2.第二种呢，就是在坐标系中把所有的位置都列出来，如果有点存在就把它标出来，即跟我们列出迷宫地图一样，先把地图画出来，然后再把宝藏标出来。所以上述的两个点可以理解为。在给出了map[20][20]的地图上，(1, 3)和(4, 5)位置为true， 即map[1][3] = 1, map[4][5] = 1，其他位置map[x][y] = 0，所以这样我们就从[(1, 3), (4, 5)]==&gt; 用map形式表现出了这两个点，两者成功在二维上进行了转换。接下来我们就来分析这个二维的map。 数组，在编程中，我们都不陌生，如int arr[50][50]，虽然可以通过这个二维的数组，根据val的不同来表示三维的量，但是我们这边不把它这么理解，仅是当做bool arr[50][50]来理解维度上的概念。===&gt;同样，面对numpy中的array我们也是这么个理解。 12345678910111213import numpy as npimport torch x = np.random.randint(2, size = (2,3))print(x)y = torch.randint(2, size = (2, 3))print(y)'''[[0 1 1] [1 0 1]]tensor([[1, 0, 1], [0, 0, 1]])''' 我们从numpy的x上理解，这边是创建了一个2*3的矩阵，其中x[0][1], x[0][2], x[1][0], x[0][2]全1，其余为0，输入x.shape得到的结果是(2, 3)，有两项，跟我们从map的理解上是一致的，这个地图map拥有长和宽两个维度。 然后我们从编程中观察这个2*3的矩阵或是叫数组，可以发现x[a][b]第一个[]中的内容a范围是从0-1的，第一个[]中的内容b范围是从0-2的，0的话学编程的人都能很快的理解，而第二个的范围却不太那么肯定。为什么呢？因为它跟我们普通认知的直角坐标系不一致。下面我们把x画出来(不改变输出显示的形式，而是让坐标系去适应这种表现形式)。 为什么是这样画的呢？首先明确的原则是，不改变输出显示的形式，而是让坐标系去适应这种输出形式，因此输出长啥样，我们坐标系只能去适应。由于我们碰到有x，有y的时候，习惯上把第一个出现的当作x，第二个当作y，所以就有了第一个[]为x，第二个[]为y。 好了，现在我们确定好坐标系长什么样了。接下来就是具体理解dim的含义了 编程中坐标系-&gt;科学计算中array的dim 想必大家在学习numpy或者torch的时候都被各种函数方法中的dim参数折磨过，感觉怎么理解都有问题，不敢自己使用。因此，这边就是解决，这些函数中的dim到底是怎么确定的 比如我们创建一个高维的array 123456789A = torch.randint(2, size = (1,2,3,4))'''tensor([[[[0, 0, 1, 0], [1, 1, 0, 1], [0, 0, 0, 0]], [[0, 0, 1, 1], [1, 1, 1, 0], [0, 1, 0, 0]]]])''' 举个我自己最初理解dim的笨方法：硬记x为第一维(dim = 0)， y为第二维(dim = 1) 实际上这种记法是比较低效的，最好的方法是我们怎么定义这个array就怎么记，比如我们这边创建的是一个size=(1, 2, 3, 4)，输出len(A.shape)为4，可以看到这就是个4维的tensor，那么我们顺理成章地就把把各个维度依次定义出来了。如dim = 0地指的就是size = 1的那层，dim = 1就是指size = 2的那层，依次类推。这样说可能有点抽象，因此我们回归简单的。 1234567B = torch.randint(2, size = (3, 2))print(B)'''tensor([[1, 0], [1, 1], [0, 0]])''' 按照我们刚的定义，dim=0就是size=3的这一层，也就是我们坐标系中的X轴orX面。 好了，想必大家这个时候还不知道我在说什么。接下来就带大家来测试函数。 测试dim在函数参数中的定义 提前指出把：要注意函数介绍中dim指的是&quot;沿着dim这个维度&quot;or&quot;删除、增加…dim这个维度(在dim这个维度上进行维度修改)&quot; 规约计算 一般是指分组聚合计算，表现结果就是会进行维度压缩 sum 沿着dim累加元素 123456789101112C = torch.randint(5, size = (2, 5))print(C)'''tensor([[2, 3, 3, 4, 0], [1, 0, 2, 4, 4]])'''print(C.sum(dim = 0))print(C.sum(dim = 1))'''tensor([3, 3, 5, 8, 4])tensor([12, 11])''' 可以看到sum就是比较典型的&quot;沿着dim&quot;的例子，当dim = 0时就沿着dim = 0即x轴进行累加，由于sum这个函数会进行维度的压缩，所以最后的结果为tensor([3, 3, 5, 8, 4]) cumprod 通过dim指定沿着某个维度计算累积 其他的函数还有cumsum、prod、sum，实际上两者是相同的，还有mean、median、var、std、min、max 1234567891011121314151617181920212223242526272829303132333435363738394041#x = torch.Tensor([ [2,3,4,5,6], [9,8,7,6,5,]])print(torch.cumprod(x, dim = 0))print(torch.cumprod(x, dim = 1))'''tensor([[ 2., 3., 4., 5., 6.], [18., 24., 28., 30., 30.]])tensor([[2.0000e+00, 6.0000e+00, 2.4000e+01, 1.2000e+02, 7.2000e+02], [9.0000e+00, 7.2000e+01, 5.0400e+02, 3.0240e+03, 1.5120e+04]])'''# minx = torch.Tensor([ [2,3,4,5,6], [9,8,7,6,5,]])print(torch.min(x, dim = 0))print(torch.min(x, dim = 1))'''torch.return_types.min( values=tensor([2., 3., 4., 5., 5.]), indices=tensor([0, 0, 0, 0, 1]) )torch.return_types.min( values=tensor([2., 5.]), indices=tensor([0, 4]) )'''# meanx = torch.Tensor([ [2,3,4,5,6], [9,8,7,6,5,]])print(torch.mean(x, dim = 0))print(torch.mean(x, dim = 1))'''tensor([5.5000, 5.5000, 5.5000, 5.5000, 5.5000])tensor([4., 7.])''' 索引、切片、连接 squeeze，unsqueeze unsqueeze关键字：参数dim指定在第几个维度增加&quot;[]&quot;，以提升维度 squeeze: unsqueeze的逆操作，删除dim指定的维度 unsqueeze 123456789101112131415D = torch.Tensor( [1, 2, 3, 4, 5] )y = D.unsqueeze(dim = 0)print(y, y.shape)'''tensor([[1., 2., 3., 4., 5.]]) torch.Size([1, 5])'''y = D.unsqueeze(dim = 1)print(y.shape)'''tensor([[1.], [2.], [3.], [4.], [5.]]) torch.Size([5, 1])''' 可以看到的是dim = 0的时候就是在dim = 0 维度上增加了一维， 使得变成了[1, 5]。第二个是在dim=1的位置加了一维变成了[5, 1] （这也就是为什么很多书上会说其实就是在dim维度上加了1） ▲这个典型就是要区分： 在dim维度上 和 沿着dim维度了 squeeze 123456789101112131415F = torch.Tensor( [ [0, 2, 3, 4], [22, 33, 44 ,55] ])y = torch.squeeze(F, dim = 0)print(y, y.shape)'''tensor([[ 0., 2., 3., 4.], [22., 33., 44., 55.]]) torch.Size([2, 4])'''y = torch.squeeze(F, dim = 1)print(y, y.shape)'''tensor([[ 0., 2., 3., 4.], [22., 33., 44., 55.]]) torch.Size([2, 4])''' 这边变换不大的原因是因为dim上没有size=1可以删除 split 按(沿着)dim维度将tensor分成n个部分 12345678910111213141516171819202122232425262728x = torch.Tensor([ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]])print(x)print(torch.split(x, 5, dim = 1))# 指定划分列表，表示依次有1,2,3,4个长度 (总和得跟dim维度上元素个数相同)print(torch.split(x, [1,2,3,4], dim = 1))'''tensor([[ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.], [10., 9., 8., 7., 6., 5., 4., 3., 2., 1.]]) (tensor([ # 可以看到这个是在x[:][6]的地方将tensor切成了两个 [ 1., 2., 3., 4., 5.], [10., 9., 8., 7., 6.] ]), tensor([ [ 6., 7., 8., 9., 10.], [ 5., 4., 3., 2., 1.] ])) (tensor([[ 1.], [10.]]), tensor([[2., 3.], [9., 8.]]), tensor([[4., 5., 6.], [7., 6., 5.]]), tensor([[ 7., 8., 9., 10.], [ 4., 3., 2., 1.]]))''' unbind 删除某个维度后，返回所有切片组成的元组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556x = torch.rand(1,2,3)# x = torch.rand(size=(1,2,3))print(x, x.shape)out = torch.unbind(x, dim = 1)print(out, len(out))'''tensor([ [ [0.3631, 0.6672, 0.9489], [0.4944, 0.1606, 0.6122] ] ]) torch.Size([1, 2, 3]) ( tensor([[0.3631, 0.6672, 0.9489]]), torch.Size([1, 3]) tensor([[0.4944, 0.1606, 0.6122]]) torch.Size([1, 3])) 2''' x = torch.Tensor([ [[1,2,3,4,], [5,6,7,8], [9,10,11,12]], [[13,14,15,16], [17,18,19,20], [21,22,23,24]]])print(x, x.shape)out = torch.unbind(x, dim = 1)print(out, len(out))print(out[0].shape)'''tensor([ [[1,2,3,4,], [5,6,7,8], [9,10,11,12]], [[13,14,15,16], [17,18,19,20], [21,22,23,24]]]) torch.Size([2, 3, 4])(tensor([ [ 1., 2., 3., 4.], [13., 14., 15., 16.]]), tensor([ [ 5., 6., 7., 8.], [17., 18., 19., 20.]]), tensor([ [ 9., 10., 11., 12.], [21., 22., 23., 24.]])) 删除dim = 1, 把size[1] = 3的tensor拆成了3个tensor 不要记这个： 因为dim0为z轴， dim1为x轴， dim2为y轴，所以删除dim1就是删除x轴，最后得到的就是yOz平面''' cat、stack 通过关键字dim指定按哪个维度拼接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354x = torch.randint(1, 100, size=(2,3))print(x)y = torch.randint(1, 100, size=(2,3))print(y)res = torch.cat((x, y), dim = 1)print(res)'''tensor([[71, 56, 44], [64, 30, 87]])tensor([[39, 56, 63], [68, 28, 65]])tensor([[71, 56, 44, 39, 56, 63], [64, 30, 87, 68, 28, 65]])'''# 加强高维理解x = torch.randint(1, 100, size=(2,3,4))print(x)y = torch.randint(1, 100, size=(2,3,4))print(y)res = torch.cat((x, y), dim = 1)print(res)'''tensor([[[81, 79, 10, 8], [47, 30, 48, 35], [10, 57, 68, 88]], [[33, 51, 60, 97], [27, 14, 83, 51], [51, 54, 79, 65]]])tensor([[[85, 9, 95, 95], [29, 99, 12, 8], [32, 8, 3, 84]], [[13, 24, 46, 20], [86, 83, 72, 10], [76, 33, 79, 48]]])tensor([[[81, 79, 10, 8], [47, 30, 48, 35], [10, 57, 68, 88], [85, 9, 95, 95], [29, 99, 12, 8], [32, 8, 3, 84]], [[33, 51, 60, 97], [27, 14, 83, 51], [51, 54, 79, 65], [13, 24, 46, 20], [86, 83, 72, 10], [76, 33, 79, 48]]]) torch.Size([2, 6, 4])dim=1即沿元素为3的方向上延伸，所以结果变成了6 不要记：也可以理解为沿x轴方向''' 官方文档： https://pytorch.org/docs/stable/generated/torch.cat.html?highlight=cat#torch.cat 总结 正确理解姿势 dim是指tensor在shape上的顺序(可以这么理解)，如x的shape是２ｘ３ｘ４，也就是[2, 3, 4]。故可以这样一一对应来。 比如dim = 1就是按具有3个元素的那个轴操作，从而不用死记硬背那些dim = 0是对列操作还是对行操作了。 强记三维 但还是不提倡强记，因为一旦高维就理解不了了。 附： 关于size的设置 在ones、rand等函数上，size = (2,3,4)，我们在C++数组中int arr[x][y][z]的理解是2∗32*32∗3然后z为4， 但实际上在科学运算中size = (2,3,4)的矩阵是有4个3∗43*43∗4的矩阵叠加而成，这边是要区分的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.random.randint(1, 100, [2, 3, 4])&gt;&gt;&gt; aarray([[[26, 36, 31, 21], [74, 59, 79, 32], [77, 94, 81, 32]], [[72, 76, 85, 93], [66, 34, 80, 12], [99, 17, 98, 23]]])x = torch.randint(1, 100, size=(2,3,4))print(x)print(x[1][2][3]) # 高度索引为1的, 在x = 2, y = 3的元素就是76'''tensor([[[63, 54, 57, 17], [78, 64, 76, 44], [96, 3, 59, 37]], [[86, 3, 92, 84], [89, 36, 8, 79], [10, 87, 15, 76]]])tensor(76)'''x = torch.randint(1, 100, size=(2,3,4,2))print(x)'''tensor([[[[29, 50], [50, 69], [95, 70], [21, 35]], [[58, 65], [15, 53], [96, 25], [11, 75]], [[12, 71], [36, 12], [71, 92], [87, 47]]], [[[43, 89], [88, 22], [61, 56], [47, 97]], [[71, 7], [44, 88], [54, 32], [15, 65]], [[96, 22], [90, 78], [30, 85], [65, 57]]]])''' 关于如何看图 123456789101112131415161718192021222324252627282930313233343536import numpy as npres = np.uint8(np.random.rand(5,5,3) * 255)print(res)plt.imshow(res)plt.show()\"\"\"[[[ 19 228 231] [106 28 252] [191 98 139] [171 71 202] [105 101 93]] [[155 232 228] [ 89 119 13] [142 158 200] [226 169 55] [137 187 249]] [[202 217 96] [214 44 133] [144 253 213] [ 82 4 28] [172 242 238]] [[106 103 68] [236 252 63] [ 53 49 66] [ 48 121 62] [ 64 61 209]] [[158 80 221] [220 12 199] [214 40 3] [169 142 144] [140 112 148]]] \"\"\" 画图效果如下： 可以得到的结果是针对np.random.rand(5,5,3)来说，三个通道被列成了三列，因此每一列就是一个通道。 123456789101112131415161718192021res = np.uint8(np.random.rand(5,5,3) * 255)[[[ 19 228 231] [106 28 252] [191 98 139] [171 71 202] [105 101 93]] res = np.uint8(np.random.rand(5,6,3) * 255)[[[217 210 138] [ 1 148 10] [ 25 231 128] [158 216 73] [220 208 165] [ 73 119 122]]# 单元中竖着的行数表示了图片的长，可以看到横着的长是6# 而有多少个单元就以为着图片的宽， 可以看到竖着的宽是5==&gt; 所以第几个单元意味着第几行# 所以[0][5][0]=73标志着右上角那一块绿色的第一个通道的值 # 可以设置后再绘图看看是不是右上角的图块变成白色的了res[0][5][0] = res[0][5][1] = res[0][5][2] = 255print(res[0][5][0]) 总结： RGB图像的shape：(H, W, C) pytorchAPI: https://pytorch.org/docs/stable/torch.html#torch.arange","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"ML","slug":"ML","permalink":"https://nymrli.top/tags/ML/"}]},{"title":"Lets learn 设计模式","slug":"Lets-learn-设计模式","date":"2020-12-03T03:36:53.000Z","updated":"2020-12-11T12:59:17.000Z","comments":true,"path":"2020/12/03/Lets-learn-设计模式/","link":"","permalink":"https://nymrli.top/2020/12/03/Lets-learn-设计模式/","excerpt":"","text":"《研磨设计模式》和《设计模式就该这样学：基于经典框架源码和真实业务场景》的读书笔记 设计模式是什么？ 模式：从字面上理解，模，就是模型、模板的意思；式，就是方式、方法的意思。综合起来，所谓模式就是：可以作为模型或模板的方式或方法。再简单点说就是可以用来作为样板的方式或方法，类似于大家所熟悉的范例。 所以设计模式就是设计方面的模板，具体定义为：是指在软件开发中，经过验证的，用于解决在特定环境下、重复出现的、特定问题的解决方案。 每个设计模式的构成如下： 1、模式名称：模式的一个好记的名字 2、环境和问题：描述在什么环境下，出现什么特定的问题 3、解决方案：描述如何解决问题 4、效果：描述应用模式后的效果，以及可能带来的问题 设计模式分类： 为了缩小范围，我们仅讨论Java设计模式，也就是GoF著作中的23种设计模式，对于这23种设计模式，GoF把它们分为三类。 创建型模式：抽象了对象实例化过程，用来帮助创建对象的实例。 简单工厂模式 单例模式 工厂方法模式 抽象工厂模式 生成器模式 原型模式 结构型模式：描述如何组合类和对象以获得更大的结构。 外观模式 适配器模式 代理模式 组合模式 享元模式 装饰模式 桥接模式 行为型模式：描述算法和对象间职责的分配。 中介模式 观察者模式 命令模式 迭代器模式 模板模式 策略模式 状态模式 备忘录模式 解释器模式 责任链模式 访问者模式 《设计模式就该这样学：基于经典框架源码和真实业务场景》中提到了新的设计模式： 对象池模式 规格模式 空对象模式 雇工模式 JAVA中的面向接口编程 1.Java中接口的概念 在Java中接口是一种特殊的抽象类，跟一般的抽象类相比，接口里面的所有方法都是抽象方法，接口里面的所有属性都是常量。也就是说，接口里面只有方法定义而没有任何方法实现。 2.接口用来干什么 通常用接口来定义实现类的外观，也就是实现类的行为定义，用来约束实现类的行为。接口就相当于一份契约，根据外部应用需要的功能，约定了实现类应该要实现的功能，但是具体的实现类除了实现接口约定的功能外，还可以根据需要实现其他一些功能，这是允许的，也就是说实现类的功能包含但不仅限于接口约束的功能。 通过使用接口，可以实现不相关类的相同行为，而不需考虑这些类之间的层次关系，接口就是实现类对外的外观。 3.接口的思想 根据接口的作用和用途，浓缩下来，接口的思想就是“封装隔离”。 通常提到的封装是指对数据的封装，但是这里的封装是指“对被隔离体的行为的封装”，或者是“对被隔离体的职责的封装”；而隔离指的是外部调用和内部实现，外部调用只能通过接口进行调用，外部调用是不知道内部具体实现的，也就是说外部调用和内部实现是被接口隔离开的。 4.使用接口的好处 由于外部调用和内部实现被接口隔离开了，那么只要接口不变，内部实现的变化就不会影响到外部应用，从而使得系统更灵活，具有更好的扩展性和可维护性，这也就是所谓“接口是系统可插拔性的保证”这句话的意思。 5.接口和抽象类的选择 既然接口是一种特殊的抽象类，那么在开发中，何时选用接口？何时选用抽象类呢？ 对于它们的选择，在开发中是一个很重要的问题，特别总结两句话给大家： 优先选用接口 在既要定义子类的行为，又要为子类提供公共的功能时应选择抽象类。 设计原则 面向对象的分析设计有很多原则，这些原则大多从思想层面给我们指出了面向对象分析设计的正确方向，是我们进行面向对象分析设计时应该尽力遵守的准则。而设计模式已经是针对某个场景下某些问题的某个解决方案。也就是说这些设计原则是思想上的指导，而设计模式是实现上的手段，因此设计模式也应该遵守这些原则，换句话说，设计模式就是这些设计原则的一些具体体现。 常见的面向对象设计原则——SOLID原则 单一职责原则SRP（Single Responsibility Principle） 所谓单一职责原则，指的是，一个类应该仅有一个引起它变化的原因。总体来说就是一个class、interface、method只负责一项职责。 这里变化的原因就是所说的“职责”，如果一个类有多个引起它变化的原因，那么也就意味着这个类有多个职责，再进一步说，就是把多个职责耦合在一起了。 这会造成职责的相互影响，可能一个职责的变化，会影响到其他职责的实现，甚至引起其他职责随着变化，这种设计是很脆弱的。 这个原则看起来是最简单和最好理解的，但是实际上是很难完全做到的，难点在于如何区分“职责”。这是个没有标准量化的东西，哪些算职责、到底这个职责有多大的粒度、这个职责如何细化等。因此，在实际开发中，这个原则也是最容易违反的。 ▲一句话总结：一个类只干一件事，从而便于立即额，提高代码可读性 开放-关闭原则OCP（Open-Closed Principle） 所谓开放-关闭原则，指的是，一个类应该对扩展开放，对修改关闭。一般也被简称为开闭原则，开闭原则是设计中非常核心的一个原则。 OCP的核心思想是面对抽象编程，强调用抽象构建框架，用实现拓展细节，从而额提高软件系统的可复用性和可维护性。 开闭原则要求的是，类的行为是可以扩展的，而且是在不修改已有代码的情况下进行扩展，也不必改动已有的源代码或者二进制代码。 看起来好像是矛盾的，怎么样才能实现呢？ 实现开闭原则的关键就在于合理地抽象、分离出变化与不变化的部分，为变化的部分预留下可扩展的方式，比如，钩子方法或是动态组合对象等。 这个原则看起来也很简单。但事实上，一个系统要全部做到遵守开闭原则，几乎是不可能的，也没这个必要。适度的抽象可以提高系统的灵活性，使其可扩展、可维护，但是过度地抽象，会大大增加系统的复杂程度。应该在需要改变的地方应用开闭原则就可以了，而不用到处使用，从而陷入过度设计。 ▲一句话总结：对扩展开放，对修改关闭，从而降低维护带来的新风险 里氏替换原则LSP（Liskov Substitution Principle） 所谓里氏替换原则，指的是，子类型必须能够替换掉它们的父类型。这很明显是一种多态的使用情况，它可以避免在多态的应用中，出现某些隐蔽的错误。 这条原则的定义是比较抽象的，可以理解为 一个软件实体如果使用一个父类，则一定适用于其子类，即要求所有引用父类的地方必须能透明地使用子类对象，子类能够代替父类对象，而程序逻辑不变。 子类可以拓展父类的功能，但不能改变父类原有的功能，根据这个理解，我们可以将DIP定义总结如下： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法 子类可以增加自己特有的方法 当子类的方法重载父类的方法时，方法的前置条件（入参）要比父类的更宽松 当子类的方法实现父类的方法时（重写、重载或实现抽象方法），方法的后置条件（输出、返回值）要比父类的更严格或相等 ▲一句话总结：子类重写方法功能改变，不应该影响父类方法的含义，从而防止继承泛滥 依赖倒置原则DIP（Dependence Inversion Principle） 所谓依赖倒置原则，指的是，要依赖于抽象，不要依赖于具体类。要做到依赖倒置，典型的应该做到： 高层模块不应该依赖于底层模块，二者都应该依赖于抽象。 抽象不应该依赖于具体实现，具体实现应该依赖于抽象。 很多人觉得，层次化调用的时候，应该是高层调用“底层所拥有的接口”，这是一种典型的误解。事实上，一般高层模块包含对业务功能的处理和业务策略选择，应该被重用，是高层模块去影响底层的具体实现。 因此，这个底层的接口应该是由高层提出的，然后由底层实现的。也就是说底层的接口的所有权在高层模块，因此是一种所有权的倒置。 倒置接口所有权，这就是著名的Hollywood（好莱坞）原则：不要找我们，我们会联系你。 一句话总结：高层不应该依赖底层，从而更利用代码结构的省级扩展 接口隔离原则ISP（Interface Segregation Principle） 指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口（不需要的接口对客户来说不可见）。 这个原则告诉我们的注意点为： 一个雷对另一个类的依赖应该建立在最小接口上 建立单一接口，不要建立庞大臃肿的接口 尽量细化接口，接口中的方法越少越好（适量少） 这些“高聚合、低耦合”要求的设计思想，使得类具有很好的可读性、可扩展性和可维护性。 所谓接口隔离原则，指的是，不应该强迫客户依赖于他们不用的方法。 这个原则用来处理那些比较“庞大”的接口，这种接口通常会有较多的操作声明，涉及到很多的职责。客户在使用这样的接口的时候，通常会有很多他不需要的方法，这些方法对于客户来讲，就是一种接口污染，相当于强迫用户在一大堆“垃圾方法”中去寻找他需要的方法。 因此，这样的接口应该被分离，应该按照不同的客户需要来分离成为针对客户的接口。这样的接口中，只包含客户需要的操作声明，这样既方便了客户的使用，也可以避免因误用接口而导致的错误。 分离接口的方式，除了直接进行代码分离之外，还可以使用委托来分离接口，在能够支持多重继承的语言中，还可以采用多重继承的方式进行分离。 ▲一句话总结：一个接口只干一件事，从而功能解耦，高聚合、低耦合 demo：针对动物Animal接口，显然需要将飞的、游的隔离开，因此需要针对不同动物的行为来设计不同的接口。 其他一些设计原则 最少知道原则LKP（Least Knowledge Principle）——迪米特原则LoD 指一个对象应该对其他对象保持最少的了解，尽量降低类与类之间的耦合。强调之和朋友交流、不和陌生人说话，出现在成员变量、方法的输入、输出参数中的类可以被称为成员朋友类，出现在方法体内部的类不属于朋友类。 这个原则用来指导我们在设计系统的时候，应该尽量减少对象之间的交互，对象只和自己的朋友谈话，也就是只和自己的朋友交互，从而松散类之间的耦合。通过松散类之间的耦合来降低类之间的相互依赖，这样在修改系统的某一个部分的时候，就不会影响其他的部分，从而使得系统具有更好的可维护性。 那么究竟哪些对象才能被当作朋友呢？最少知识原则提供了一些指导。 当前对象本身。 通过方法的参数传递进来的对象。 当前对象所创建的对象。——成员变量 当前对象的实例变量所引用的对象。——成员变量 方法内所创建或实例化的对象。 —&gt; ??? 请注意！！！1-5条的意思是，如果某对象是调用其他方法的返回结果，不要调用该对象的方法！即要求我们只调用以下范围的方法： （1）该对象本身； （2）被当作方法的参数而传递进来的对象； （3）此方法所创建或实例化的任何对象； （4）对象的任何组件； 总之，最少知识原则要求我们的方法调用必须保持在一定的界限范围之内，尽量减少对象的依赖关系。 ▲一句话总结：不该知道的不要知道，从而减少代码臃肿 合成复用原则 尽量使用对象组合或对象聚合的方式来实现代码复用，而不是继承关系达到代码复用的目的。 ▲一句话总结：尽量使用组合实现代码复用而不是用继承，从而降低代码耦合 除了上面提到的这些原则，还有一些大家都熟知的原则，比如： 面向接口编程； 优先使用组合，而非继承。 当然也还有很多大家不是很熟悉的原则，比如： 一个类需要的数据应该隐藏在类的内部； 类之间应该零耦合，或者只有传导耦合，换句话说，类之间要么没有关系，要么只使用另一个类的接口提供的操作； 在水平方向上尽可能统一地分布系统功能； 附录 Github图说设计模式: https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html 设计模式就该这么学：以微信订阅号来讲观察者模式(第三篇) 观察者模式实际应用：监听线程，意外退出线程后自动重启","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"玩玩油猴脚本Tampermonkey","slug":"玩玩油猴脚本","date":"2020-12-01T07:32:53.000Z","updated":"2020-12-01T12:19:48.468Z","comments":true,"path":"2020/12/01/玩玩油猴脚本/","link":"","permalink":"https://nymrli.top/2020/12/01/玩玩油猴脚本/","excerpt":"","text":"由于在研究如何优化网盘直链下载助手**baidupan，如何将直链的结果提取出来供IDM批量下载。由于baidupan**是用油猴脚本写的，因此借机学习一下。 Greasy Fork 这里是一个提供用户脚本的网站。 Tampermonkey 其为浏览器插件，目前主流浏览器皆支持，油猴叫法来源：「油猴」是从「Greasemonkey」来的。「Greasemonkey」最初是运行在Firefox浏览器中的脚本，「Tampermonkey」在Google Chrome浏览器上实现了几乎相同的功能，所以也被中文用户称之为「油猴」。 新建： 123456789101112131415// ==UserScript==// @name New Userscript// @namespace http://tampermonkey.net/// @version 0.1// @description try to take over the world!// @author You// @match https://www.1949la.com/post/10351.html// @grant none// ==/UserScript==(function() &#123; 'use strict'; // Your code here...&#125;)(); 脚本编写方法 注释——功能注释 首先来看看脚本的内容，上面是一大排注释，这些注释可以非常有用的，它表明了脚本的各个属性。下面来简单介绍一下。 属性名 作用 name 油猴脚本的名字 namespace 命名空间，类似于Java的包名，用来区分相同名称的脚本，一般写成作者名字或者网址就可以了 version 脚本版本，油猴脚本的更新会读取这个版本号 description 描述，用来告诉用户这个脚本是干什么用的 author 作者名字 match 只有匹配的网址才会执行对应的脚本，例如*、http://*、http://www.baidu.com/*等，参见谷歌开发者文档 grant 指定脚本运行所需权限，如果脚本拥有相应的权限，就可以调用油猴扩展提供的API与浏览器进行交互。如果设置为none的话，则不使用沙箱环境，脚本会直接运行在网页的环境中，这时候无法使用大部分油猴扩展的API。如果不指定的话，油猴会默认添加几个最常用的API require 如果脚本依赖其他js库的话，可以使用require指令，在运行脚本之前先加载其他库，常见用法是加载jquery connect 当用户使用GM_xmlhttpRequest请求远程数据的时候，需要使用connect指定允许访问的域名，支持域名、子域名、IP地址以及*通配符 updateURL 脚本更新网址，当油猴扩展检查更新的时候，会尝试从这个网址下载脚本，然后比对版本号确认是否更新 grant中几个常用的权限： 123// @grant GM_setValue// @grant GM_getValue// @grant GM_setClipboard 注意， match写法由于支持通配符，可以写的通用些: 12// @match *://10.10.244.11/a70.htm*// @match *://p.njupt.edu.cn/a70.htm* 脚本权限 下面简单介绍一下grant指令那里可以填写的一些权限，详情请查看油猴脚本文档。这里就简单介绍几个常用的，可以调用的函数全部以GM_作为开头。 权限名 功能 unsafeWindow 允许脚本可以完整访问原始页面，包括原始页面的脚本和变量。 GM_getValue(name,defaultValue) 从油猴扩展的存储中访问数据。可以设置默认值，在没成功获取到数据的时候当做初始值。如果保存的是日期等类型的话，取出来的数据会变成文本，需要自己转换一下。 GM_setValue(name,value) 将数据保存到存储中 GM_xmlhttpRequest(details) 异步访问网页数据的API，这个方法比较复杂，有大量参数和回调，详情请参考官方文档。 GM_setClipboard(data, info) 将数据复制到剪贴板中，第一个参数是要复制的数据，第二个参数是MIME类型，用于指定复制的数据类型。 GM_log(message) 将日志打印到控制台中，可以使用F12开发者工具查看。 GM_addStyle(css) 像网页中添加自己的样式表。 GM_notification(details, ondone), GM_notification(text, title, image, onclick) 设置网页通知，请参考文档获取用法。 GM_openInTab(url, loadInBackground) 在浏览器中打开网页，可以设置是否在后台打开等几个选项 还有一些API没有介绍，请大家直接查看官方文档吧。 GM_xmlhttpRequest DEMO： 1234567891011121314151617181920212223GM_xmlhttpRequest(&#123; method: \"POST\", url: url, headers: &#123; \"Content-Type\": \"application/x-www-form-urlencoded;charset=utf-8\" &#125;, data: form_data, onload: function(response) &#123; console.log(\"请求成功\"); let success = \"认证成功页\"; let resp = response.responseText; let flag = resp.indexOf(success); if (flag === -1) &#123; do_login_old(username, password); &#125; else &#123; //alert(\"登录成功\"); window.location.href = \"https://cn.bing.com/\"; //避免重复登录导致瞬间三个设备同时登录的状态 &#125; &#125;, onerror: function(response) &#123; do_login_old(username, password); &#125;&#125;); MyCode 我的第一个脚本，简简单单打开自己的个人博客吧，修改如下 123&gt; // @match https://www.baidu.com&gt; // @grant GM_openInTab&gt; 123&gt; const URL = \"https://nymrli.top\";&gt; GM_openInTab(URL, true)&gt; 访问百度的时候就会在当前session中打开我的个人博客了，(URL, true)不会切换到URL上 123456789101112131415161718// ==UserScript==// @name New Userscript// @namespace http://tampermonkey.net/// @version 0.1// @description try to take over the world!// @author Mrli// @match https://www.baidu.com// @grant GM_openInTab// ==/UserScript==(function() &#123; 'use strict'; const URL = \"https://nymrli.top\"; GM_openInTab(URL, true); // 打开URL后当前tab不变; false会切换当前tab为URL页面 // GM_openInTab(URL, &#123;incognito :true &#125;); options中貌似有有限级, 加了incognito后,insert会失效 // Your code here...&#125;)(); Bilibili倍速 123456789101112131415161718192021222324252627282930// ==UserScript==// @name BilibiliFast// @namespace http://tampermonkey.net/// @version 0.1// @description try to take over the world!// @author You// @match https://www.bilibili.com/video/*// @require https://code.jquery.com/jquery-2.1.4.min.js// @grant none// ==/UserScript==(function() &#123; 'use strict'; // Your code here... console.log(\"导入成功\"); $(\"body\").append(`&lt;div id='video_set' style=\"position:fixed; right:10px; top:10px; z-index:9999; background:red\"&gt; &lt;input id=\"setPlay\" value=1 type=\"number\" style=\"padding:10px;\"&gt; &lt;/div&gt;` ); // $(document).append()会报错Cannot read property 'createDocumentFragment' of undefined $(document).on(\"change\", \"#video_set #setPlay\", function()&#123; console.log(this.value); if(this.value &lt;= 16)&#123; document.querySelector('video').playbackRate=this.value; &#125;else&#123; alert(\"最大为16\") &#125; &#125;);&#125;)(); 学习baidupan源码 学到新东西：SweetAlert2 漂亮可定制的 JavaScript 弹窗 123456789101112131415161718// @require https://cdn.jsdelivr.net/npm/sweetalert2@9// 基础语法：Swal.fire(&#123; title: \"是否删除\", text: \"是否删除？一旦提交，无法恢复！\", icon: \"warning\", showCancelButton: true, confirmButtonColor: \"#DD6B55\", confirmButtonText: \"确定\", cancelButtonText: \"取消\"&#125;).then((isConfirm) =&gt;&#123; // 是否成功在then里面用if判断 if (isConfirm.value) &#123; Swal.fire(\"删除成功\", \"成功\", \"success\"); &#125;else&#123; Swal.fire(\"取消操作\", \"点击了取消\", \"error\"); &#125;&#125;); 来源于checkVersion 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function checkUpdate() &#123; setValue('up',0) GM_xmlhttpRequest(&#123; method: \"GET\", url: `https://api.baiduyun.wiki/update?ver=$&#123;version&#125;`, responseType: 'json', onload: function (r) &#123; let res = r.response setValue('lastest_version', res.version) userAgent = res.ua ids = res.ids if (res.vcode === 200 &amp;&amp; compareVersion(res.version,version)) &#123; setValue('up',1) &#125; if (res.scode != getValue('scode')) &#123; let dom = $('&lt;div&gt;&lt;img style=\"width: 250px;margin-bottom: 10px;\" src=\"https://img.tool22.com/image/5f365d403c89f.jpg\"&gt;&lt;input class=\"swal2-input\" id=\"scode\" type=\"text\" placeholder=\"请输入暗号，可扫描上方二维码免费获取!\"&gt;&lt;/div&gt;') Swal.fire(&#123; title: \"初次使用请输入暗号\", html: dom[0], allowOutsideClick: false, confirmButtonText: '确定' &#125;).then((result) =&gt; &#123; if (res.scode == $('#scode').val()) &#123; setValue('scode', res.scode) setValue('init', 1) Toast.fire(&#123; icon: 'success', text: '暗号正确，正在初始化中。。。', &#125;).then(() =&gt; &#123; history.go(0)// go() 方法可加载历史列表中的某个具体的页面。（-1上一个页面，1前进一个页面, 0就是当前页面) &#125;) &#125; else &#123; setValue('init', 0) Swal.fire(&#123; title: \"🔺🔺🔺\", text: '暗号不正确，请通过微信扫码免费获取', imageUrl: 'https://img.tool22.com/image/5f365d403c89f.jpg', &#125;) &#125; &#125;) &#125; else &#123; loadPanhelper() &#125; &#125; &#125;)&#125; 将console.log输出分组 12345678function clog(c1, c2, c3) &#123; c1 = c1 ? c1 : '' c2 = c2 ? c2 : '' c3 = c3 ? c3 : '' console.group('[网盘直链下载助手]') // 分组 console.log(c1, c2, c3) console.groupEnd() // 要想将其他内容显示在外面得取消分组&#125; 程序的逻辑 开始: 1234567$(() =&gt; &#123; //阻止在其他网站运行 if (hostname.match(/(pan|yun).baidu.com/i)) &#123; let plugin = new PanPlugin() plugin.init() &#125;&#125;) 进行检查更新-&gt;创建菜单 123456789function PanPlugin() &#123; clog('RPC：', ariaRPC) this.init = () =&gt; &#123; main() addGMStyle() checkUpdate() if (getValue('SETTING_H')) createHelp() createMenu() &#125; 主要的应用是在checkUpdate中的loadPanhelper完成的，其会根据参数创建PanHelper(网盘页面的下载助手)或PanShareHelper(分享页面的下载助手)对象， 显然PanHelper就是我们最想分析的 PanHelper逻辑 12345678910111213141516171819202122function PanHelper() &#123; let yunData, sign, timestamp, bdstoken, logid, fid_list let fileList = [], selectFileList = [], batchLinkList = [], batchLinkListAll = [], linkList = [] let dialog, searchKey let panAPIUrl = location.protocol + \"//\" + location.host + \"/api/\" let restAPIUrl = location.protocol + \"//pcs.baidu.com/rest/2.0/pcs/\" let clientAPIUrl = location.protocol + \"//pan.baidu.com/rest/2.0/\" this.init = () =&gt; &#123; yunData = unsafeWindow.yunData if (yunData === undefined) &#123; clog('初始化信息:', yunData) clog('页面未正常加载，或者百度已经更新！') return false &#125; initVar() registerEventListener() addButton() createIframe() dialog = new Dialog(&#123;addCopy: true&#125;) clog('下载助手加载成功！当前版本：', version) &#125; 最核心的逻辑： 1234567891011121314151617181920212223//我的网盘 - 获取PCS下载地址function getPCSBatchLink(callback) &#123; let fsids = [] $.each(selectFileList, (index, element) =&gt; &#123; if (element.isdir == 1) return fsids.push(element.fs_id) &#125;) fsids = encodeURIComponent(JSON.stringify(fsids)) let link = clientAPIUrl + `xpan/multimedia?method=filemetas&amp;access_token=undefined&amp;fsids=$&#123;fsids&#125;&amp;dlink=1` GM_xmlhttpRequest(&#123; method: \"GET\", responseType: 'json', headers: &#123;\"User-Agent\": userAgent&#125;, url: link, onload: (res) =&gt; &#123; let response = res.response if (response.errno === 0) &#123; callback(response.list) &#125; &#125; &#125;)&#125; 附录 官方文档 Tampermonkey油猴用户脚本API文档-教程 脚本debug建议 jquery使用 踩了几天坑，最后总结一下编写油猴脚本的一点步骤。首先要思考脚本的实现方式，需要用到什么API和权限，然后填写好脚本的注释信息。 然后将功能封装成函数的形式，最后在脚本末尾调用实现的函数。写的差不多的时候复制到浏览器中尝试运行。 遇到困难的时候，可能需要直接在F12开发者工具里进行调试。有些网页不用jQuery，为了方便，我们需要自己将jQuery导入到页面中，可以将下面的代码复制到浏览器控制台中。 123var jq = document.createElement('script');jq.src = \"https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js\";document.getElementsByTagName('head')[0].appendChild(jq); debug方法： 第一种方法就是最原始的打印日志，可以利用console.log和GM_log来将关键信息打印出来，上面的脚本就是我靠打印日志一点点发现各种参数错误的。说实话这种办法有点笨。 第二种就是利用浏览器的调试功能(推荐)，在脚本需要调试的地方插入debugger;语句，然后在打开F12开发者工具的情况下刷新页面，就会发现网页已经暂停在相应位置上。这样就可以利用F12开发者工具进行单步调试、监视变量等操作了。 将文章同步复制到Csdn和思否编辑器的脚本demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// ==UserScript==// @name copy_jianshu_to_csdn_and_segmentfault// @namespace https://github.com/techstay/myscripts// @version 0.1// @description 将简书文章复制到csdn和思否编辑器中// @author techstay// @match https://editor.csdn.net/md/// @match https://segmentfault.com/write// @match https://www.jianshu.com/writer*// @require https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js// @require https://cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.min.js// @grant GM_setValue// @grant GM_getValue// @grant GM_deleteValue// @grant unsafeWindow// @grant GM_setClipboard// @grant window.close// @grant window.focus// @grant GM_openInTab// ==/UserScript==(function () &#123; 'use strict'; const SF_URL = 'https://segmentfault.com/write' const CSDN_URL = 'https://editor.csdn.net/md/' const SF_TITLE = 'sf_title' const SF_CONTENT = 'sf_content' const CSDN_TITLE = 'csdn_title' const CSDN_CONTENT = 'csdn_content' function saveArticle() &#123; GM_setValue(CSDN_TITLE, $('._24i7u').val()) GM_setValue(CSDN_CONTENT, $('#arthur-editor').val()) GM_setValue(SF_TITLE, $('._24i7u').val()) GM_setValue(SF_CONTENT, $('#arthur-editor').val()) &#125; function copyToCsdn() &#123; var title = GM_getValue(CSDN_TITLE, '') var content = GM_getValue(CSDN_CONTENT, '') if (title != '' &amp;&amp; content != '') &#123; $('.article-bar__title').delay(2000).queue(function () &#123; $('.article-bar__title').val(title) $('.editor__inner').text(content) GM_deleteValue(CSDN_TITLE) GM_deleteValue(CSDN_CONTENT) $(this).dequeue() &#125;) &#125; &#125; function copyToSegmentFault() &#123; $(document).ready(function () &#123; var title = GM_getValue(SF_TITLE, '') var content = GM_getValue(SF_CONTENT, '') if (title != '' &amp;&amp; content != '') &#123; $('#title').delay(2000).queue(function () &#123; $('#title').val(title) GM_setClipboard(content, 'text') GM_deleteValue(SF_TITLE) GM_deleteValue(SF_CONTENT) $(this).dequeue() &#125;) &#125; &#125;) &#125; function addCopyButton() &#123; $('body').append('&lt;div id=\"copyToCS\"&gt;双击复制到CSDN和思否&lt;/div&gt;') $('#copyToCS').css('width', '200px') $('#copyToCS').css('position', 'absolute') $('#copyToCS').css('top', '70px') $('#copyToCS').css('left', '350px') $('#copyToCS').css('background-color', '#28a745') $('#copyToCS').css('color', 'white') $('#copyToCS').css('font-size', 'large') $('#copyToCS').css('z-index', 100) $('#copyToCS').css('border-radius', '25px') $('#copyToCS').css('text-align', 'center') $('#copyToCS').dblclick(function () &#123; saveArticle() GM_openInTab(SF_URL, true) GM_openInTab(CSDN_URL, true) // GM_openInTab(url, options)在新标签页打开URL。options可选的值： // active ：新标签页获得焦点; insert：新标签页在当前页面之后添加; setParent：当新标签页关闭后，焦点给回当前页面 ; incognito: 新标签页在隐身模式或私有模式窗口打开. // options可以写成&#123; active: true, insert: true, setParent :true &#125; // GM_openInTab(url, loadInBackground)：loadInBackground 可以是 Boolean 类型，如果是 true，则当前 tab 不变，如果是 false，则当前 tab 变为新打开的 tab. 当前tab就是当前标签页(显示的页面) &#125;) $('#copyToCS').draggable() &#125; $(document).ready(function () &#123; if (window.location.href.startsWith('https://www.jianshu.com')) &#123; addCopyButton() &#125; else if (window.location.href.startsWith(SF_URL)) &#123; copyToSegmentFault() &#125; else if (window.location.href.startsWith(CSDN_URL)) &#123; copyToCsdn() &#125; &#125;)&#125;)() ▲推荐：油猴脚本编写教程","categories":[],"tags":[]},{"title":"浙大2020春夏-人工智能习题3——AIforOthello","slug":"浙大2020春夏-人工智能习题1——AIforOthello","date":"2020-12-01T04:02:33.000Z","updated":"2020-12-11T03:17:16.417Z","comments":true,"path":"2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/","link":"","permalink":"https://nymrli.top/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/","excerpt":"","text":"something about Othello 黑白棋规则 传统的黑白棋棋盘由 8 x 8 方格组成。开局时，棋盘中央的4格先置黑白相间的4颗棋子 (详见下图)，并由黑子先行。 首步由黑子先下；下子时；新子必须与棋盘上任一己方棋子形成一条或多条 (横、竖、斜) 直线，并夹着对方棋子；由新子及旧子连成的直线之间，必须存有一颗或以上对方的棋子。如图，黑子开局时之可行棋步有以下4格: 双方交替下子；倘若任何一方没有棋步可行，则其必须将下子权利相认予对手；另在双方均无子可下的情况下，游戏自动结束。 游戏结束后，拥子较多一方为胜；倘若双方棋数相同的，则为和局。 黑白棋基本策略 占角子及固定子 按照黑白棋的玩法，其中一子落在佔角处的，该棋子将无法再被翻转。 危险方块 在棋盘上，棋子下在某些方块中，比起其它下子位置更为安全。档游戏开始，一般建议尽量将棋子下于棋盘 4 x 4格的中心范围内 (下图以半透明白子显示)；且应避免将棋子下于靠近边角的方块内(下图以半透明黑子显示)，棋子落于靠近边角的方块中，会让对手更容易占据边角相邻的位置。 行动力 初学者的普遍错误一般在开盘后不断占子，但在黑白棋中这并不是一个好的策略。较好的策略为专注于限制对方的落子选项，而交易进入这种策略的方法为占少子。在下面的例子中，白子虽然只有一颗棋子，但其可轻而易具的在4步内赢得整盘棋。 from : https://www.eothello.com/ 较为强悍的othello AI: https://playpager.com/play-reversi/index.html AI for Othello Coding search before Coding： Unispac/Alpha-Othello——浙大学长的（集成了很多Agent） YuMu0/ReversiAI——博弈树、α-β剪枝（有UI；单文件，结构有点差） 1011497938/Othello——MCTS、Q-learning（在浙大学长的基础上增加了几类agent） im0qianqian/Reversi-based-RL——毕设，文档说明：https://www.dreamwings.cn/reversi/3013.html faded53222/Othello——B站用户 MyCode 部分借鉴了tic-tac-toe井字棋MCTS的代码框架 MSCT-target： Start：从可行位置进行树探索 -&gt; End：一个价值比较高的action 代码中容易忘记的是，所有的board在rollout的时候都应该保存的临时变量，即确保node的self.board是不变的；board设计的时候，不要限定死color（move），这样可选择性更好 虽然加上了corner，但是对站中级还是赢少输多， 看了下比赛棋盘，发现对corner的限制并不奏效，希望能找到更好的方法吧。 战力 basic 初级WIN 中级LOSS： 加上corner： 中级tie 中级WIN 高级： 时间安排 2020/12/2 上网冲浪，搜集相关资料，看了Unispac/**Alpha-Othello**的设计报告。 2020/12/4 结合代码和[视频](AI如何下棋？直观了解蒙特卡洛树搜索MCTS！！！理了遍MCTS的原理， 列出了大致的框架， 明天开始编写逻辑代码。","categories":[],"tags":[{"name":"ZJU","slug":"ZJU","permalink":"https://nymrli.top/tags/ZJU/"},{"name":"ML","slug":"ML","permalink":"https://nymrli.top/tags/ML/"}]},{"title":"fork curlconverter for Better","slug":"fork-curlconverter-for-Better","date":"2020-12-01T02:43:34.000Z","updated":"2020-12-01T04:00:56.428Z","comments":true,"path":"2020/12/01/fork-curlconverter-for-Better/","link":"","permalink":"https://nymrli.top/2020/12/01/fork-curlconverter-for-Better/","excerpt":"","text":"终于12月了，又是一个月初，定个flag，pr一个Gitcode 由于之前写Python爬虫的时候，从curlconverter受惠很多，并且看到issue #22: Add generator for Java中有Java版本的需求还未完成，所以目标就是完成JAVA for curl curlconverter提供了一个网页版： https://curl.trillworks.com/， 其实其本质上也是用js完成的，功能如README中所写： README Install 1$ npm install --save curlconverter Usage 123var curlconverter = require('curlconverter');curlconverter.toPython(\"curl 'http://en.wikipedia.org/' -H 'Accept-Encoding: gzip, deflate, sdch' -H 'Accept-Language: en-US,en;q=0.8' -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36' -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8' -H 'Referer: http://www.wikipedia.org/' -H 'Cookie: GeoIP=US:Albuquerque:35.1241:-106.7675:v4; uls-previous-languages=%5B%22en%22%5D; mediaWiki.user.sessionId=VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y; centralnotice_buckets_by_campaign=%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D; centralnotice_bannercount_fr12=22; centralnotice_bannercount_fr12-wait=14' -H 'Connection: keep-alive' --compressed\"); Returns a string of Python code like: 123456789101112131415161718192021import requestscookies = &#123; 'GeoIP': 'US:Albuquerque:35.1241:-106.7675:v4', 'uls-previous-languages': '%5B%22en%22%5D', 'mediaWiki.user.sessionId': 'VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y', 'centralnotice_buckets_by_campaign': '%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D', 'centralnotice_bannercount_fr12': '22', 'centralnotice_bannercount_fr12-wait': '14',&#125;headers = &#123; 'Accept-Encoding': 'gzip, deflate, sdch', 'Accept-Language': 'en-US,en;q=0.8', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Referer': 'http://www.wikipedia.org/', 'Connection': 'keep-alive',&#125;response = requests.get('http://en.wikipedia.org/', headers=headers, cookies=cookies) 想要参加开发，最重要的就是看清master提出的contributing要求： Contributing I’d rather write programs to write programs than write programs. Dick Sites, Digital Equipment Corporation, September 1985 Make sure you’re running node 12 or greater. The test suite will fail on older versions of node. If you add a new generator, make sure to update the list of supported languages in cli.js or else it won’t be accessible from the command line. Further, you’ll want to update test.js and index.js for your new generator to make it part of the testing. If you want to add new functionality, start with a test. Create a file containing the curl command in fixtures/curl_commands with a descriptive filename like post_with_headers.txt Create a file containing the output in fixtures/python_output/ with a matching filename (but different extension) like post_with_headers.py Run tests with npm test. If your filenames match correctly, you should see one failing test. Fix it by modifying the parser in util.js or the generators in generators/ The parser generates a generic data structure consumed by code generator functions. You can run a specific test with this command: 1node test.js --test=test_name where “test_name” is a file (without extension) in fixtures/curl_commands You can run a specific test with this command: 1node test.js --language=R I recommend setting this up with a debugger so you can see exactly what the parser is passing to the generator. Here’s my Intellij run configuration for a single test: Before submitting a PR, please check that your JS code conforms to the code style enforced by standardjs. Use the following to fix your code if it doesn’t: 1$ standard --fix my_file.js If you get stuck, please reach out via email. I am always willing to hop on a google hangout and pair program. 翻译： 相比写程序，我更愿意写出能写程序的程序。——Dick Sites, Digital Equipment Corporation, September 1985 确保你正在运行node 12或更高版本。测试套件在旧版本的node上会失败。 如果你添加了一个新的生成器，请确保更新cli.js中的支持语言列表，否则它将无法从命令行访问。此外，你还要为你的新生成器更新test.js和index.js，使其成为测试的一部分。 如果您想添加新功能，请从测试开始。 在fixtures/curl_commands中创建一个包含curl命令的文件，文件名为post_with_headers.txt。 在fixtures/python_output/中创建一个包含输出的文件，并使用一个匹配的文件名（但不同的扩展名），比如post_with_headers.py。 用npm test运行测试。 如果您的文件名正确匹配，您应该看到一个失败的测试。通过修改util.js中的解析器或generators/中的生成器来解决。 解析器需要生成一个通用数据结构给代码生成器函数。 你可以用这个命令运行一个特定的测试。node test.js --test=test_name， 其中 &quot;test_name &quot;是fixtures/curl_commands中的一个文件（没有扩展名）。 你可以用这个命令运行一个特定的测试。node test.js --language=R，我建议用调试器来设置，这样你就可以看到解析器传递给生成器的具体内容。这是我的Intellij运行配置，用于单次测试。 在提交PR之前，请检查您的JS代码是否符合standardjs执行的代码风格。如果不符合的话，请使用下面的方法来修正你的代码。$ standard --fix my_file.js. 如果你遇到困难，请通过电子邮件联系我。我总是愿意跳上google上线、校验程序。 分析其他contributor的PR DainisGorbunovs PR说明：https://github.com/NickCarneiro/curlconverter/pull/154 Thanks / what I found helpful： 可以使用nc -l 3000，然后在另一个标签页中 curl -X POST http://localhost:3000 --data “hello=world” (感谢 @NickCarneiro) 可以使用Wireshark来检查（抓包） 可以使用httpbin服务（用途：个人感觉是将curl结果跟generate结果对比） commit详情：https://github.com/DainisGorbunovs/curlconverter/commit/5cfedbf595177aa912b78f0fde05f15da81f11f9 JAVA for Curl http库选取 在2016年的时候**NickCarneiro**就Add generator for Java #22提出增加JAVA版本， 但无奈JAVA较为繁琐，并且没有像Python的requests一样好用的库，因此现在都还未有JAVA版本 Java is super popular and super verbose, making it a good candidate for curlconverter. We need to find out if there is some modern library for sending http requests. Please advise. 1、HttpClient HttpClient：代码复杂，还得操心资源回收等。代码很复杂，冗余代码多，不建议直接使用。 HttpClient使用介绍 使用HttpClient发送请求主要分为以下几步骤： 创建 CloseableHttpClient对象或CloseableHttpAsyncClient对象，前者同步，后者为异步 创建Http请求对象 调用execute方法执行请求，如果是异步请求在执行之前需调用start方法 java原生HttpURLConnection apache HttpClient3.1 apache httpClient4.5 上述见：java实现HTTP请求的三种方式—— 有代码demo 2、okhttp okhttp：OkHttp是一个高效的HTTP客户端，允许所有同一个主机地址的请求共享同一个socket连接；连接池减少请求延时；透明的GZIP压缩减少响应数据的大小；缓存响应内容，避免一些完全重复的请求 OkHttp使用 使用OkHttp发送请求主要分为以下几步骤： 创建OkHttpClient对象 创建Request对象 将Request 对象封装为Call 通过Call 来执行同步或异步请求，调用execute方法同步执行，调用enqueue方法异步执行 3、RestTemplate RestTemplate： 是 Spring 提供的用于访问Rest服务的客户端， RestTemplate 提供了多种便捷访问远程Http服务的方法,能够大大提高客户端的编写效率。 https://www.cnblogs.com/zk-blog/p/12465951.html 4.http-request 在我们日常工作中，我们需要经常和第三方接口进行交互通信，很多时候我们都是使用http协议进行交互，java原生自带对http的支持（java.net.*），但是使用起来不太方便，除此之外，用的最多的就是apache httpclient工具包。但是个人使用这么久而言，感觉不管是原生的抑或是httpclient，使用起来都不太顺手，也略显复杂 文章见： JAVA http请求工具类http-request","categories":[],"tags":[{"name":"GitCode","slug":"GitCode","permalink":"https://nymrli.top/tags/GitCode/"}]},{"title":"github中各配置文件","slug":"github中各配置文件","date":"2020-11-29T10:10:04.000Z","updated":"2020-12-19T13:33:33.298Z","comments":true,"path":"2020/11/29/github中各配置文件/","link":"","permalink":"https://nymrli.top/2020/11/29/github中各配置文件/","excerpt":"","text":".pre-commit-config.yaml 来源：easyquotation，项目中有makefile和.pre-commit-config.yaml、.coveragerc、.pylintrc三个比较新奇的。 makefile一般都在c工程中看到， 这边作者使用是代替了一些编译工作，类似sh脚本的作用。跟setup区别：makefile提供给开发者提交代码时使用；setup当做三方库直接调用 123456&gt; init:&gt; pip install pipenv&gt; pipenv install --dev&gt; pipenv run pre-commit install&gt; @echo &amp;&amp; echo use \"pipenv shell\" to access virtual env&gt; Git钩子脚本对于在提交代码审查之前识别简单问题很有用。我们在每次提交时都运行钩子，以自动指出代码中的问题，例如缺少分号，尾随空白和调试语句。通过在代码审阅之前指出这些问题，代码审阅者可以专注于更改的体系结构，而不会浪费琐碎的样式问题。 在此介绍的pre-commit只是git hook的一部分， git hook分客户端和服务端的，pre-commit属于客户端的。 使用教程：项目管理：代码检查 pre-commit 使用详解： PIP安装-&gt;配置(在项目的根目录创建一个.pre-commit-config.yaml 文件)-&gt;pre-commit install把pre-commit安装到了项目.git的hook目录下面-&gt;Done(之后我们在执行git commit 的时候就会先调用这个文件，当然还可以在git操作的很多步骤前面做一些工作) .travis.yml .gitignore 在提交git commit的时候选择性忽略的配置文件 有各种语言的模板，至于具体的文件，可以自己修改细节。 .gitkeep 大家可能在很多的开源项目中都看到过.gitkeep这个文件，文件内没有任何内容，一个空空的文件。 那这个类型文件的作用到底是啥呢？这要从git不允许追踪(track)或者说提交一个空的文件夹说起，git本身是不允许提交一个空文件夹的，所有就有了.gitkeep的存在，可以把它看作是一个占位符，当然了，你也可以使用 .nofile或者其他的占位符，自行决定。 当然了，业内人员已经习惯使用.gitkeep，已经达成了共识，所以我们尽量还是使用.gitkeep。 代码规范与风格 .pylintrc Pylint 是一个 Python 代码分析工具，它分析 Python 代码中的错误，查找不符合代码风格标准（Pylint 默认使用的代码风格是 PEP 8，具体信息，请参阅参考资料）和有潜在问题的代码。 跟.gitignore差不多，有模板。 .flake8 请使用 Flake8 确保代码符合规范： 1flake8 --config .flake8 .style.yapf 请使用 YAPF 对代码进行格式下： 1yapf --style .style.yapf --in-place --recursive aiocqhttp scripts demo.py .coveragerc Python用来查看测试中覆盖率的配置文件，如果衡量单元测试对相应代码的测试重量，覆盖率是一个必要非充分条件，因此统计代码的覆盖率，检视单测是否充分，就尤为的重要。这里针对python-unittest的单测的覆盖率coverage进行使用说明与分析. 1234567[run]branch = Trueinclude = easyquotation/* # 项目名称xxxomit = tests/* # 忽略的目录[report]fail_under = -1 官方文档： https://coverage.readthedocs.io/en/latest/index.html","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"《漫画机器学习入门》大关真之——读书笔记","slug":"《漫画机器学习入门》大关真之——读书笔记","date":"2020-11-28T13:39:01.000Z","updated":"2020-11-28T13:40:38.925Z","comments":true,"path":"2020/11/28/《漫画机器学习入门》大关真之——读书笔记/","link":"","permalink":"https://nymrli.top/2020/11/28/《漫画机器学习入门》大关真之——读书笔记/","excerpt":"","text":"《漫画机器学习入门》总结 机器学习是指计算机通过不断地处理数据并修正算法和参数来学习各种规则， 从而不断改进模型而得到更优化的算法。书中主要讲解了玻尔兹曼机的机器学习 谁是世界上最美丽的人？ ****特征量****就是如每一个人的年龄，眼睛大小； 特征向量就是每个人的特征量放到一起，特征向量是表达特征的一个数组 误差函数： 在美丽程度这个问题上， 误差函数就是—— 计算“美丽程度”的实际输出与给定的理想输出之间的差值 最优化问题： 最小化误差函数，其实是一个求解最优化问题：我们的任务就是要找到没有误差或者误差小到满足要求的最适合的模型。这就要通过调节模型中的参数，使误差函数值尽量小，这就是求解（参数）最优化问题。 微分：稍微拉动一点摇杆，确认误差是否变小。这种操作叫做微分。 梯度下降法： 一直拉到误差不再减少，直到误差值保持不变或者反而有所上升时为止。希望不停地调整权重，使得误差一直在朝着减小的方向前进。这种调整误差的方法叫梯度下降法。 回归就是：建立模型—拟合—微调 机器学习是寻找输入数据与输出数据之间关系(model-&gt;function map)的一门学问。 每一个特征量都很重要，但是不同特征量的重要程度是不同的，所以需要寻找特征的权重矩阵 训练数据和测试数据： 学习和测试是机器学习的两项基本任务。 (1)好的算法很重要； (2)要将获得的数据分为训练用数据和测试用数据；(3)仅仅匹配训练用数据是不行的——仅仅满足训练用数据叫overfit过拟合，如果连训练数据都不符合叫underfit欠拟合 验证的方法：交叉验证：将所有的数据分成4组， 每组中1份数据用于测试，3份用于训练 复杂化模型——寻找新的特征值：sigmoid 函数：当发现检测的结果不太好，王后想把模型变得更复杂一些。王后尝试将原始的特征量组合起来获得新的特征量，再加权求输出，却发现因为只有乘法和加法的情况这种线性特性，与之前并没有本质区别。因此，引入了sigmoid函数，这个非线性函数。sig(x)=11−e−xsig(x) = \\frac{1}{1-e^{-x}}sig(x)=1−e−x1​ 加权组合，构成新的特征值： 如果我们把将特征量组合，新增加5个特征量的话（如图），摇杆的数量就变成了原来的5倍。 多层神经网络：在单层神经网络的基础上，增加一层非线性变换，结构上也就多了一个中间的曾，就是多层神经网络。 只由输入到输出方向进行信息的传递，被称为正向型神经网络； 而双方向都能够进行信息交换的结构被称为双向型神经网络。双向型神经网络典型代表是Hopfield一处的，玻尔兹曼机也是基于这种神经网络。 双向信息处理模式不同于淡出的正向信息处理， 它可以有多个输出结果， 而且从这些输出结果中它可以回忆起以前记忆过的信息，因此也被叫做联想记忆。 模型越复杂，网络就越纠缠，拉动一根线就会对整个网络产生较大的影响。反过来，网络中任何一根线又会连接很多其他的线，拉它的时候也会受到很大限制，甚至拉不动。 距离输出层越近的摇杆越容易搬动，这是有梯度的结果。因为搬动一下离输出很近的摇杆，它的效果能够很方便地传递给输出。离输出越远，梯度越难计算，越难调整。===&gt;BP算法， 以及最好不要使用Sigmod函数， 因为容易梯度消失， 可以换用tanh或者reLU（观察函数的微分结果） dropout：为了防止过度学习， 需要掌握平衡， 做出取舍： 适当地选取一定比例的特征量，剩下的全部舍弃不用。 批量学习与在线学习： 批量学习（batch learning）：将全部数据收集齐了之后一起作为训练用数据使用，这叫做批量学习（batch learning） 在线学习（online learning）:与此相对的，随着数据不断地获取而逐步进行的学习则称为在线学习（online learning） 现在批量学习也在改进，有些地方与在线学习差不多， 如使用概率梯度下降法： （采用概率的方式去分组，也叫随机选择，就是不能利用某种故意的特定意图去分组） 当利用概率分组后，对每一组数据进行训练，动一下摇杆看误差如何变化，然后再向误差变小的方向搬动摇杆，这就是概率梯度下降法。（通过适当地概率计算，让参数或左或右地跳动着变化） 这种算法考虑的是，与其冲着预先规定好的方向一直走下去，倒不如是不是地左看看，右看看。这样反倒更容易找到隐藏的近路。 在线学习和随机梯度下降法的优势在于， 可以捕捉灵光霎现的机会， 增加了跳脱鞍点的可能性。 粮食问题 感知机perceptron(弗兰克·罗森布拉特)和支持向量机SVM(Vladmir N.Vapnik) 感知机：移动分割超平面进行数据分类。感知机的缺点：非线性模型处理不好 支持向量机：使分割超平面处于一种非常“好”的状态，即所有数据点尽量都远离分割超平面，因此能够更好的识别并且使得安全裕量最大 矩阵的秩：= 模式的种类， 一个模式以一行向量表示。矩阵中两行的规律相似，应该属于同一种模式。假设数据中存在某些模式，那么在矩阵中一定会存在某一行的数值代表该模式，其他的某一行代表另一种模式。 如果模式能够从可见数据中推演出来，通过对可见数据做有效处理，就能够推测出不可见的那部分数据，这其实是一种无监督学习：希望能够完美地补充矩阵中空白的数据，并能够预测出新的模式。（计算机从大量数据中通过自己的分析来找出规律，叫做无监督学习） 预测方面有监督/无监督的不同 ： 从数据中学到东西，这一点是一致的。之后，在是否进行预测这一点上是不同的。 有监督学习是希望计算机越来越聪明并逐渐能够代替人的某些工作。 无监督学习，是希望计算机从特征量中选择出我们容易理解的某种模式，将模式分成若干或者某种形式的分类。 稀疏化：有些算法会将不重要的特征量的权重直接设定为0，舍弃一些不重要的东西， 导致矩阵中产生很多0， 这种矩阵将稀疏矩阵。 非负矩阵分解（ Nonnegative Matrix Factor ）： 非负，指在计算的时候不使用负值，也就是只做加法运算。就像用钢笔描绘人脸，先有眼睛，鼻子，再加上嘴等等。这些都是一个一个添加的。（非负好比用钢笔作画不能删除， 而普通作画是用铅笔， 所以可以有负值） 如果也用减法，就像用铅笔，还可以用橡皮擦去一些地方。 基于玻尔兹曼机器学习的图像处理方法 首先要明确的一点是， 图片是由像素组成的。每一个像素到底是呈现数模颜色，这是由数据来决定的。 玻尔兹曼机器学习:将图像的颜色数据输入到玻尔兹曼机中，计算机通过分析这些数据，就可以得到实际图像的特征，各像素点显示某种颜色的概率，以及相邻像素间的关系。这种过程叫做玻尔兹曼机器学习。 似然度： 相似的程度。 机器学习的目的要么是让误差值最小，要么是让似然度最大 采样：将实际提供的数据输入到玻尔兹曼机后， 模型会输出伪数据（重构数据）， 这个自身不断产生数据的过程就叫做采样 sampling 玻尔兹曼机器学习在进行时，采用马尔科夫蒙特卡罗方法，来逐一考虑相邻像素之间的关系，来完成双向型神经网络的信息流动。这是一种在整个网络结构中的循环，在这一过程中还要不断地采集大量的重构数据。很费时间。==&gt; 替代算法是，单纯考虑由相邻像素传送过来的信息，平均场近似法 中间结果包含每一个像素颜色的变化过程，也能够构成中间过程的许多图像。这些中间产生的图像数据就是重构数据， 也可以叫做伪数据。其实核心就是“依据临近像素的数据， 在现有的参数值情况下， 预测中心像素的颜色值” 机器学习与统计力学： 我们在研究原子和分子的时候， 位置、运动扽信息是分析研究的对象， 但是统计力学有趣的地方是利用统计学理论去获取事物整体的特征。类比机器学习， 就像我们并不去计较每一个颗粒的位置和速度， 对于机器学习我们也是希望得到大量数据间的整体组合信息， 这种整体组合信息在最优化问题求解时就是推到出函数模型 可见变量、隐含变量：在图像中， 每一个像素颜色的数值时可以直接读取的， 这一部分就叫做可见变量。由可见变量之间关联关系构成的新变量称为隐含变量， 从而可以建立出眼睛、鼻子等部件， 从而将利用各个部件就可以将图像分成各个部分了。 利用上述方式就可以以“开关”的形式来操作了，通过像素和开关之间的关系就可以决定在可见变量一侧表示出什么， 这种方法认为可见变量之间没有任何关系， 各个开关之间也没有关联。只考虑开关与像素之间的关系， 叫做受限玻尔兹曼机（RBM）， 有较好的特性， 如一定条件下的独立性 变分原理：物理学中， 指自然界中静止实物的一个普遍适用的数学定律，也称最小作用原理。比如在确定了物体的起点和终点后， 通过动能和势能之差就能计算出最短路径。 对比散度算法：将实际的颜色数据与建立的模型采集到的伪数据进行比较， 我们希望能够从中找到某些有用的东西。 深度玻尔兹曼机将图像数据作为输入， 内部作为隐含变量的各种开关来决定到底输出什么图像， 因此为了能够对应不同的图像， 建立数量巨大的复杂的隐含变量时非常必要的——深度玻尔兹曼机的目的时学习图像中隐含的特征， 知道了图像中拥有的特征可以就可以返回来看可见变量中是否有猫和狗了——传统机器学习和深度学习的区别也在于此， 传统机器学习需要自己手动提取特征（特征工程）， 而神经网络可以自己提取特征。 受限玻尔兹曼机是两层神经网络。包含输入层，隐藏层，输出层 预训练： ①运用在无监督学习中， 不告诉model特征有哪些 ②用预训练网络做微调：一般图片分类的神经网络每一类别的图片量级至少在5000-10000左右，如果没有这么多图片，（使用数据增强的方法后也不够），此时就需要用预训练网络了（在几十万张图片训练集上获得较好效果的图片多分类器）。然后用我们现有的图片在这个预训练网络的基础上继续训练， 利用现有的图片继续训练就是为了让网络重新适应现有的图片训练集， 这种适应过程往往比从头训练一个网络更快更好， 这种方法跟迁移学习的思想很像。 自我符号化（在无监督学习中具有代表性）：吧收到的输入信号原原本本地返回来。 注意， 左右知识结构上的复制，权值是不一样的。这些权值是需要进行调整后才能满足右边的“输入”等于左边输入的。在这个调整权值的过程中，输入数据所隐含的特征就可以被挖掘出来了。&gt;从而使得中间层具有能够反映输入数据中特征的能力。&gt; 中间层的自我符号化训练其实也是提取特征的过程 卷积神经网络： 在处理图像时已有已知的神经网络可以利用了——卷积神经网络。 卷积：卷积是利用了，人在看见图像识别图像时并不需要将所有的细小像素全部看清的特征而设计的。卷积就是在某种程度上将临近的像素组合起来形成新的特征量，然后利用卷积结果进行分析 池化：在图片中即使模糊我们也能通过模糊的影像大致判断出—&gt;数据即使有些差异也能够得出同样的结果。因此可以利用卷积将特征进行排序，将相近的特征进行比较并选用其中的最大值或平均值，叫做池化 ▲通过卷积和池化操作，神经网络从而可以将图像中的特征量自动地提取出来了。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://nymrli.top/tags/读书笔记/"}]},{"title":"学会Latex写作","slug":"熟悉Latex写作","date":"2020-11-28T11:55:06.000Z","updated":"2021-06-15T10:27:54.922Z","comments":true,"path":"2020/11/28/熟悉Latex写作/","link":"","permalink":"https://nymrli.top/2020/11/28/熟悉Latex写作/","excerpt":"","text":"首先开始的便是文档定义: 12345\\documentclass[bachelor]&#123;njupthesis&#125;% \\documentclass[option]&#123;class&#125;% class有article, proc, minimal, book, slides% option: a4paper(纸张大小)、10pt(字体大小)、fleqn(行间公式对齐方式)、leqno(行间公式的编号对齐方式)、onecolumn(单栏)、titlepage(文档标题后另起一页)\\end&#123;document&#125; 查看： https://blog.csdn.net/wei_love_2017/article/details/86617235 可以看到这边的documentclass是自定义的，原因是因为这个使用的是郭学长做的毕设latex模板， 因此借此机会也学习下Latex的模板制作， 主要是cls文件的编写 cls文件是什么？ LaTex中常见的文件格式有.tex, .bib, .cls, .sty, .bbl等。 .tex文件也就是我们写文档内容的文件； .bib是使用bibligraphy方式导入参考文献时，写参考文献的文档；.bbl是其编译之后形成的文件; .sty是包或者风格文件，通常使用\\usepackage导； .cls是类文件，通过文档最前面的\\documentclass命令导入 一般来说，.cls 和 .sty 文件都是增加 LaTeX 功能的补足文件。它们在我们排版文章是时对应的使用 \\documentclass{} 和 \\usepackage{} 加载；在包内部则对应的使用 \\LoadClass,\\LoadClassWithOptions 和 \\RequirePackage,\\RequirePackageWithOptions 加载。 cls与sty不同点 虽然它们都可以包含任意的 TeX 和 LaTeX 代码，但是它们的使用方式不同。我们必须通过 \\documentclass 加载一个类文件，并且在一个 LaTeX 文件中只能出现一次，通常也是第一个出现的命令。而另一方面，包是一个可选项，它可以根据我们的需求加载任意多个（在开始文档之前）。 cls文件怎么写的？ cls文件可以分为四部分，我暂且分别称之为声明、宏定义、输入数据处理以及其他四部分 所谓声明，只是说明了编译cls文件需要什么样的TeX格式以及本cls文件可以提供什么内容，基本上是万年不变的，如下： 12\\ProvidesClass&#123;resume&#125;[Mylatex] % 其中，[ ]中的内容可以随便填写呀~\\NeedsTeXFormat&#123;LaTeX2e&#125; 第二部分，宏定义，这部分内容则是各取所需了，如果有需要，可以在此进行简单的定义，我在此定义了两个\\newif，用于判断中文简历和英文简历： 12\\newif\\ifChinese\\newif\\ifEnglish 第三部分，处理输入数据，也就是上文提到的\\documentclass[a4paer,12pt]{article}中的a4paper和12pt这两条数据123456789101112131415161718192021222324252627 ```latex \\DeclareOption&#123;zh&#125;&#123;\\Chinesetrue\\Englishfalse&#125; \\DeclareOption&#123;en&#125;&#123;\\Chinesefalse\\Englishtrue&#125; \\DeclareOption*&#123;% \\PassOptionsToClass&#123;\\CurrentOption&#125;&#123;article&#125; &#125; \\ProcessOptions\\relax \\LoadClass&#123;article&#125; % 对于zh，我进行的操作是将\\Chinese这个变量设为true，\\English这个变量设为false，以便在后续使用第二部分定义的\\if， % 第三条语句为将初zh, en之外的其余参数传至article类，供article类进行处理，最后呢，就是加载继承的article类；——如郭学长njupthesis所做的处理为: \\LoadClass[12pt, openany, twoside]&#123;book&#125; ```4. 第四部分，会先导入需要用到的包，之后将上面的零散语句贴上去。在tex文件中，导入包通常使用\\usepackage命令，但是在cls中，一般要使用\\RequirePackage的方式将其导入，如： ```latex % Customize the section headers \\RequirePackage&#123;titlesec&#125; % footnote \\RequirePackage&#123;fancyhdr&#125; % Set the margins \\RequirePackage[margin=0.5in]&#123;geometry&#125; \\RequirePackage[T1]&#123;fontenc&#125; ```最后，在.tex文件中通过`\\documentclass&#123;Mylatex&#125;`来使用该cls文件即可 查看：【LaTex】cls文件编写和使用入门 \\ProvidesClass 12\\ProvidesClass&#123;njupthesis&#125;\\LoadClass[12pt, openany, twoside]&#123;book&#125; ProvidesClass为定义出的模板class名 LoadClass为documentclass中原先指定的参数 \\DeclareOption 12345\\DeclareOption&#123;bachelor&#125;&#123; \\renewcommand&#123;\\chinesedegreename&#125;&#123;本科&#125; \\renewcommand&#123;\\chinesebooktitle&#125;&#123;本科生毕业设计（论文）&#125; \\renewcommand&#123;\\englishbooktitle&#125;&#123;Bachelor Thesis&#125;&#125; 关于\\documentclass的option设置 \\newcommand 参数说明: \\newcommand\\cmd[参数个数]{命令的定义} 1234567891011121314151617181920212223242526272829303132% 姓名的字体较大，且加粗，实现方式：\\newcommand&#123;\\name&#125;[1]&#123; \\huge &#123;\\textbf&#123;#1&#125;&#125;&#125;% tex中调用方式为: \\name&#123;Zhang San&#125;\\newcommand&#123;\\wanted&#125;[1]&#123; \\normalsize &#123;\\textbf&#123;申请职位：&#125;&#125; #1 % \\textbf 为加粗 % \\normalsize 为设置常规字号&#125;\\newcommand&#123;\\address&#125;[3]&#123; \\normalsize \\raisebox&#123;-3pt&#125;&#123;\\includegraphics[height=#1]&#123;#2&#125;&#125; #3 % \\includegraphics 为插图的命令: \\includegraphics[选项]&#123;文件&#125; % \\raisebox: 升高或者降低text盒子: \\raisebox&#123;上移量&#125;[高度][深度]&#123;文本&#125; % #1表示要显示图标的高度 % #2表示图标文件完整路径 % #3表示图标后要显示的文字&#125;% tex中调用方式为: \\address&#123;12pt&#125;&#123;add.png&#125;&#123;Nanjing, China&#125;\\newcommand&#123;\\edusubsection&#125;[3]&#123; \\subsection&#123;\\textbf&#123;#1&#125; \\hfill #2&#125; % \\sunsection 预设了较大的字体 % \\hfill 设置弹性长度 \\vspace&#123;-4pt&#125; % \\vspace&#123;宽度大小&#125; 设置垂直间距 &#123;\\normalfont\\normalsize #3&#125; \\vspace&#123;-10pt&#125;&#125; 最后一个\\edusubsection的效果图 分析下语法：\\newcommand为自定义命令: \\newcommand{&lt;自命名指令&gt;}[&lt;参数个数&gt;][&lt;首参数默认值&gt;]{&lt;具体的定义行为&gt;} 注： 命令只能由字母组成，不用以\\end{}结尾 取参数时，从1开始索引 p.s. \\renewcommand重新定义已有命令， 语法跟\\newcommand相同 \\DeclareCaptionFormat 设置题目标题格式 12345678\\DeclareCaptionFormat&#123;algrule&#125;&#123;% &#123;\\@hangfrom&#123;#1#2&#125;% \\doublespacing \\small \\advance\\caption@parindent\\hangindent \\advance\\caption@hangindent\\hangindent \\caption@@par#3\\par&#125;%&#125; \\graphicspath 设置图片路径 1\\graphicspath&#123;&#123;./pic/&#125;&#125; \\titleformat 设置各个title格式 1234567891011121314\\titleformat&#123;\\chapter&#125;[block] &#123;\\centering\\fontsize&#123;15pt&#125;&#123;15pt&#125;\\selectfont\\heiti\\thispagestyle&#123;fancy&#125;&#125;&#123;\\thechapter&#125;&#123;2pc&#125;&#123;&#125;\\titleformat&#123;\\section&#125;[block] &#123;\\fontsize&#123;14pt&#125;&#123;14pt&#125;\\selectfont\\heiti&#125; &#123;\\thesection&#125;&#123;7pt&#125;&#123;&#125;\\titleformat&#123;\\subsection&#125;[block] &#123;\\fontsize&#123;14pt&#125;&#123;14pt&#125;\\selectfont\\heiti&#125; &#123;\\thesubsection&#125;&#123;7pt&#125;&#123;&#125;\\titleformat&#123;\\subsubsection&#125;[block] &#123;\\fontsize&#123;12pt&#125;&#123;12pt&#125;\\selectfont\\heiti&#125; &#123;\\thesubsubsection&#125;&#123;6pt&#125;&#123;&#125; \\newtheorem \\newtheorem{theorem}{Theorem}[Chapter] 引用 \\citing 设置引用 1当代生活\\citing&#123;pedregosa2011scikit&#125;是严肃文学大师的作品。 \\ref 如图所示 12% 可自动渲染成如图2-1所示如图\\ref&#123;c_s_structure_v2&#125;所示 \\bibliography 12\\bibliographystyle&#123;IEEEtran&#125; % 按照IEEEtran.bst的样式引用\\bibliography&#123;cog&#125; % 引用文件制定为cog.bib \\newenvironment \\newenvironment{新环境名称}[参数个数][参数默认值]{开始部分定义}{结束部分定义}、\\renewenvironment{新环境名称}[参数个数][参数默认值]{开始部分定义}{结束部分定义} 其中参数的用法和\\newcommand 相同，最多允许9个参数，顺序使用#1、#2等引用参数。如果没有使用参数，则[0]可以省略。假设myenv环境的调用如下：\\begin{myenv}{arg_1}…{arg_k} 则可以在“开始部分定义”中使用#1，…#k来引用参数，这是newenvironment传递参数的方式。需要特别注意的是，newenvironment的参数只有在“开始部分定义”中才能使用，即“结束部分定义”中的代码无法获取参数。因此，如果要在“结束部分定义”中使用新环境的参数，必须在“开始部分定义”中保存到寄存器中，比如通过\\newsavebox 和\\sbox 等命令。 举例： 先看一个简单的文章“摘要”（Abstract）的例子：假设，摘要的标题—摘要（Abstract）两个字加粗居中显示，正文使用quote格式，完整的示例文件参见2。 1234567891011121314\\documentclass&#123;article&#125;\\pagestyle&#123;empty&#125;\\setlength\\textwidth&#123;3in&#125;%限制文本宽度使得较少的文字就容易看出断行的效果\\newenvironment&#123;Abstract&#125;&#123; \\begin&#123;center&#125;\\normalfont\\bfseries Abstract\\end&#123;center&#125; \\begin&#123;quote&#125;\\par&#125;%开始部分定义&#123;\\end&#123;quote&#125;&#125;%结束部分定义\\begin&#123;document&#125;\\begin&#123;Abstract&#125; This abstract explain the approach userd to solve the problems at hand.\\end&#123;Abstract&#125;Some text following the abstract. Some text following the abstract. Some text following the abstract.\\end&#123;document&#125; bst文件 Latex: 制作和修改需要的参考文献格式（.bst） 一般的期刊或者会议都会提供参考文献格式模板(.bst)，但是如果没有提供的话，你可以选择自己制作一个bst或者寻找类似的再修改bst文件。这是一篇教你制作需要的参考文献格式(.bst)的文章。文章主要包括两方面内容：1、从头制作.bst文件，包括对book,article,proceedings等等进行格式设置；2、根据需要微调做好的bst文件。(建议看下文档A BibTEX Guide via Examples) 如果参考文献格式要求排序按出现顺序，引用方式为数字，作者只出现三个，超过三个用et al 表示。例要求参考文献格式为： Journal articles [6] Borwn, L., Thomas, H., James, C., et al.:'The title of the paper, IET Communications, 2012, 6, (5), pp 125-138 bst文件编写 write$为输出内容； missing$为缺失一般配合if$使用 1234567891011121314151617181920212223242526272829Entry&#123; note ...&#125;FUNCTION &#123;add.period&#125;&#123; &quot;. &quot; write$&#125;FUNCTION &#123;add.comma&#125;&#123; &quot;, &quot; write$&#125;FUNCTION &#123;online&#125;&#123; bibitem.begin format.title write$ add.period format.online_url write$ add.period // 下面表示如果有note则输出 &quot;note .&quot; note missing$ &apos;skip$ &#123; note write$ add.period &#125; if$ newline$&#125; njupthesis \\makecover 封面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354\\newcommand&#123;\\makecover&#125;&#123;\\thispagestyle&#123;empty&#125;\\setlength&#123;\\extrarowheight&#125;&#123;36pt&#125;\\begin&#123;center&#125; \\fontsize&#123;36pt&#125;&#123;36pt&#125;\\selectfont&#123;\\heiti 南京邮电大学 \\\\ 毕&#123;&#125;业&#123;&#125;设&#123;&#125;计（论&#123;&#125;文）\\\\&#125; \\vspace&#123;2cm&#125; \\begin&#123;tabular&#125;&#123;&gt;&#123;\\fontsize&#123;16pt&#125;&#123;16pt&#125;\\kaiti&#125;l &gt;&#123;\\centering\\arraybackslash\\fontsize&#123;15pt&#125;&#123;15pt&#125; \\kaiti&#125; p&#123;11.53cm&#125;&#125; 题\\chinesespace\\chinesespace 目&#123;&#125;&#123;&#125; &amp; \\thetitle \\\\ \\cline&#123;2-2&#125; 专\\chinesespace\\chinesespace 业&#123;&#125;&#123;&#125; &amp; \\themajor \\\\ \\cline&#123;2-2&#125; 学生姓名&#123;&#125;&#123;&#125; &amp; \\theauthor \\\\ \\cline&#123;2-2&#125; 班级学号&#123;&#125;&#123;&#125; &amp; &#123;\\large \\thestudentid&#125; \\\\ \\cline&#123;2-2&#125; 指导老师&#123;&#125;&#123;&#125; &amp; \\theadvisor \\\\ \\cline&#123;2-2&#125; 指导单位&#123;&#125;&#123;&#125; &amp; \\theschool \\\\ \\cline&#123;2-2&#125; \\end&#123;tabular&#125; \\vspace&#123;5cm&#125;\\fontsize&#123;16pt&#125;&#123;16pt&#125;\\selectfont&#123;\\kaiti 日期：\\quad \\thebegindate &#123;&#125; 至\\hspace&#123;.5pc&#125; \\thefinishdate \\\\&#125;\\end&#123;center&#125;\\newpage\\thispagestyle&#123;empty&#125;\\noindent\\begin&#123;center&#125; \\fontsize&#123;16pt&#125;&#123;16pt&#125;\\selectfont&#123;\\heiti 毕业设计（论文）原创性声明 &#125; \\\\[48bp]\\end&#123;center&#125;\\begin&#123;spacing&#125;&#123;2.0&#125;郑重声明：所提交的毕业设计（论文），是本人在导师指导下，独立进行研究工作所取得的成果。除文中已注明引用的内容外，本毕业设计（论文）不包含任何其他个人或集体已经发表或撰写过的作品成果。对本研究做出过重要贡献的个人和集体，均已在文中以明确方式标明并表示了谢意。\\\\ \\\\ \\hspace*&#123;7cm&#125; 论文作者签名：\\hspace*&#123;7cm&#125; 日期：\\quad\\quad 年\\quad\\quad 月\\quad\\quad 日\\end&#123;spacing&#125;\\newpage\\setcounter&#123;page&#125;&#123;0&#125;\\setcounter&#123;pseudopage&#125;&#123;0&#125;\\setlength&#123;\\extrarowheight&#125;&#123;5pt&#125;&#125; \\thesistableofcontents 目录 1234567% TODO: 更改目录样式\\newcommand&#123;\\thesistableofcontents&#125;&#123; \\pdfbookmark&#123;目录&#125;&#123;toc&#125; \\tableofcontents \\thispagestyle&#123;empty&#125;&#125; \\thesisappendix 附录 12345678910111213\\newcommand&#123;\\thesisappendix&#125;&#123; \\chapter*&#123;附\\chinesespace\\chinesespace 录&#125; \\setcounter&#123;section&#125;&#123;0&#125; % \\setcounter&#123;secnumdepth&#125;&#123;4&#125; %增加编号深度 % \\setcounter&#123;tocdepth&#125;&#123;4&#125; %增加目录深度 \\addcontentsline&#123;toc&#125;&#123;chapter&#125;&#123;附录&#125; \\markboth&#123;附录&#125;&#123;附录&#125; \\thispagestyle&#123;fancy&#125; \\renewcommand&#123;\\theequation&#125;&#123;a-\\arabic&#123;equation&#125;&#125; \\renewcommand&#123;\\thetable&#125;&#123;a-\\arabic&#123;table&#125;&#125; \\renewcommand&#123;\\thefigure&#125;&#123;a-\\arabic&#123;figure&#125;&#125;&#125; \\thesisacknowledgement 致谢 123456789\\newcommand&#123;\\thesisacknowledgement&#125;&#123; \\renewcommand\\thesection&#123;\\arabic&#123;section&#125;&#125; \\addtocontents&#123;toc&#125;&#123;\\protect\\setcounter&#123;tocdepth&#125;&#123;0&#125;&#125; \\setcounter&#123;section&#125;&#123;0&#125; \\chapter*&#123;致\\chinesespace\\chinesespace 谢&#125; \\addcontentsline&#123;toc&#125;&#123;chapter&#125;&#123;致谢&#125; \\markboth&#123;致谢&#125;&#123;致谢&#125; \\thispagestyle&#123;fancy&#125;&#125; \\thesischapterexordium 章绪论 1234567\\newcommand&#123;\\thesischapterexordium&#125;&#123; \\newpage \\addtocontents&#123;toc&#125;&#123;\\protect\\setcounter&#123;tocdepth&#125;&#123;2&#125;&#125; \\standardhead \\pagenumbering&#123;arabic&#125; \\setcounter&#123;page&#125;&#123;1&#125;&#125; \\thesisloadbibliography reference引用 123456789\\newcommand&#123;\\thesisloadbibliography&#125;[2][]&#123; \\ifthenelse&#123; \\equal&#123;#1&#125;&#123;nocite&#125; &#125;&#123; \\nocite&#123;*&#125; &#125;&#123;&#125; \\bibliographystyle&#123;njupthesis&#125; \\bibliography&#123;#2&#125;&#125; 使用 LaTeX 中列表环境的使用——有序序号和无序序号 enumerate: LaTeX中自定义enumerate的编号格式 enumitem: 是enumerate的封装， 增加了预设的缩进等设置 123456\\begin&#123;enumerate&#125; \\renewcommand&#123;\\labelenumi&#125;&#123;(\\theenumi)&#125; \\item \\item \\item \\end&#123;enumerate&#125; from ： latex 使用 enumitem 宏包调整 enumerate 或 itemize 的上下左右缩进间距 图片的插入及排版方法——并排插入图片 123456\\begin&#123;figure&#125;[htbp] \\centering \\includegraphics[scale=0.2]&#123;girl.eps&#125; \\caption&#123;figure title&#125; \\label&#123;figure&#125;\\end&#123;figure&#125; 解释一下每一句的功能： Line 1：\\begin{figure} ~ \\end{figure} 是固定用法，只要插入图片，就需要有这么一对儿；方括号 [] 内是控制参数，控制了整幅图的位置； 图片位置控制参数：\\begin{figure}[htbp] [h] 表示当前位置（here），也就是说图片将放在你设置的当前位置，但是如果这一页的空间不足以放下这个图片，此时图片会转到下一页； [t] 顶端（top），此时优先将图片放置在页面的顶部； [b] 底部（bottom）此时优先将图片放置在页面底部； [p] 将图片设置为浮动状态，系统会自动排版图片的位置； 一般推荐这几个参数结合使用，比如：[ht]、[htbp]，此时这几种位置具有优先级。 Line 2：\\centering 表示将图片居中显示； Line 3：\\includegraphics{} 用于插入一张图片，花括号 {} 内就是图片的名称，方括号 [] 内同样是控制参数，但这里控制的是图片的显示大小； 图片大小控制参数：\\includegraphics[scale=0.2]{girl.eps} [scale]，表示按原图比例缩放，比如 scale=0.2 表示将原图缩小 5 倍，如果要放大只需要将 scale 设置为大于 1 即可； 还可以直接设置图片宽高，比如 [height = 1cm, width = 2cm]。 Latex图片旋转 缩放 Line 4：\\caption{} 是这幅图的图例信息； Line 5：\\label{xxx} 是这幅图的标签，在写论文时需要在正文中引用，这时候用标签直接来引就省去了一些不必要的麻烦；文中通过\\ref{xxx}来引用 \\table 创建表格 12345678910111213141516171819\\documentclass&#123;article&#125;\\begin&#123;document&#125;\\begin&#123;table&#125;[h!] \\begin&#123;center&#125; \\caption&#123;Your first table.&#125; \\begin&#123;tabular&#125;&#123;l|c|r&#125; % &lt;-- Alignments: 1st column left, 2nd middle and 3rd right, with vertical lines in between \\textbf&#123;Value 1&#125; &amp; \\textbf&#123;Value 2&#125; &amp; \\textbf&#123;Value 3&#125;\\\\ $\\alpha$ &amp; $\\beta$ &amp; $\\gamma$ \\\\ \\hline 1 &amp; 1110.1 &amp; a\\\\ 2 &amp; 10.1 &amp; b\\\\ 3 &amp; 23.113231 &amp; c\\\\ \\end&#123;tabular&#125; \\end&#123;center&#125;\\end&#123;table&#125;\\end&#123;document&#125; 绘制Latex表格需要用到 table 和 tabular 环境。其中 table 环境里写表格的标题（caption）、表格的偏移之类的。 tabular 环境则是绘制表格的内容。 首先是 table 环境部分，\\begin{center}让表格居中，\\caption{Your first table.}写表格的标题。 然后是 tabular 环境部分，\\begin{tabular}{l|c|r}这里面的{l|c|r}，包含了三个字母，代表了表格总共有三列，第一列靠左偏移，第二列居中，第三列靠右偏移。竖线代表列之间用线分隔开来，如果想要左右两边都用线包围起来，应该改成{|l|c|r|}。接下来就是正式的表格绘制部分。 latex里的表格是一行行来绘制的，每一行里面用&amp;来分隔各个元素，用\\来结束当前这一行的绘制。代码中\\textbf{Value 1} &amp; \\textbf{Value 2} &amp; \\textbf{Value 3}\\绘制表格的第一行，是三个加粗的字符串。第二行α\\alphaα &amp; β\\betaβ &amp; γ\\gammaγ \\则是三个希腊字符。 接着是\\hline，它的作用是画一整条横线，注意如果想画一条只经过部分列的横线，则可以用cline{a-b}，代表的是画一条从第a列到第b列的横线。 参数说明： h here 当前位置；将图形放置在 正文文本中给出该图形环境的地方。如果本页所剩的页面不够， 这一参数将不起作用。 t top 顶部；将图形放置在页面的顶部。 b bottom 底部；将图形放置在页面的底部。 p page 浮动页；将图形放置在一只允许有浮动对象的页面上。 ref: latex表格详细教程（table, tabular, multirow, multicolumn） LaTeX表格Table使用解析 \\algorithm 算法流程图-》伪代码 概括版本 algorithm - float wrapper for algorithms. algorithmic - first algorithm typesetting environment. algorithmicx - second algorithm typesetting environment. algpseudocode - layout for algorithmicx. algorithm2e - third algorithm typesetting environment. from : https://zhuanlan.zhihu.com/p/145195565?from_voters_page=true 使用\\algorithm编写伪代码流程时，先关注类中使用的package是什么。不然会出现冲突，比如algorithm2e与algorithmicx 就会产生冲突, 报错如下： 123456789LaTeX Warning: Label(s) may have changed. Rerun to get cross-references right. ) (see the transcript file for additional information)Output written on main.pdf (24 pages).SyncTeX written on main.synctex.gz.Transcript written on main.log. 两者选其一即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546% algorithm2e的模板如下：\\begin&#123;algorithm&#125;[H] \\SetAlgoLined \\KwData&#123;this text&#125; \\KwResult&#123;how to write algorithm with \\LaTeX2e &#125; initialization\\; \\While&#123;not at end of this document&#125;&#123; read current\\; \\eIf&#123;understand&#125;&#123; go to next section\\; current section becomes this one\\; &#125;&#123; go back to the beginning of current section\\; &#125; &#125;\\caption&#123;How to write algorithms&#125;\\end&#123;algorithm&#125;% algorithmicx\\begin&#123;algorithm&#125;[h] \\caption&#123;An example for format For \\&amp; While Loop in Algorithm&#125; \\begin&#123;algorithmic&#125;[1] \\For&#123;each $i\\in [1,9]$&#125; \\State initialize a tree $T_&#123;i&#125;$ with only a leaf (the root); \\State $T=T\\cup T_&#123;i&#125;;$ \\EndFor \\ForAll &#123;$c$ such that $c\\in RecentMBatch(E_&#123;n-1&#125;)$&#125; \\label&#123;code:TrainBase:getc&#125; \\State $T=T\\cup PosSample(c)$; \\label&#123;code:TrainBase:pos&#125; \\EndFor; \\For&#123;$i=1$; $i&lt;n$; $i++$ &#125; \\State $//$ Your source here; \\EndFor \\For&#123;$i=1$ to $n$&#125; \\State $//$ Your source here; \\EndFor \\State $//$ Reusing recent base classifiers. \\label&#123;code:recentStart&#125; \\While &#123;$(|E_n| \\leq L_1 )and( D \\neq \\phi)$&#125; \\State Selecting the most recent classifier $c_i$ from $D$; \\State $D=D-c_i$; \\State $E_n=E_n+c_i$; \\EndWhile \\label&#123;code:recentEnd&#125; \\end&#123;algorithmic&#125; \\end&#123;algorithm&#125; 使用： https://blog.csdn.net/lwb102063/article/details/53046265 采坑 字体报错 在CLS类文件中定义了全局字体: ，由于重装系统后字体可能就安装的不全了，导致了编译报错 报错如下： 123456kpathsea: Running mktexmf SimKai/OT.mfThe command name is E:\\texlive\\2019\\bin\\win32\\mktexmfCannot find SimKai/OT.mf.name = SimKai/OT, rootname = SimKai/OT, pointsize = mktexmf: empty or non-existent rootfile! 原因如下： 123456\\ifwindows \\setallmainfonts&#123;Times New Roman&#125; \\setCJKmainfont[AutoFakeBold=true]&#123;SimSun&#125; \\newCJKfontfamily&#123;\\heiti&#125;&#123;SimHei&#125; \\newCJKfontfamily&#123;\\kaiti&#125;&#123;SimKai&#125; % \\newCJKfontfamily&#123;\\kaiti&#125;&#123;KaiTi&#125; 百度之后发现SimKai就是楷体_GB2312，但是fontName并不是文件中规定的SimHei，而又找不到ttf名为SimKai的字体了， 因此直接通过解决CLS文件定义来解决问题。 fc-list | grep sim查找电脑上安装的字体列表，找出 123456789101112131415C:/WINDOWS/fonts/simsun.ttc: 新宋体,NSimSun:style=常规,RegularC:/WINDOWS/fonts/simfang.ttf: 仿宋,FangSong:style=Regular,Normal,obyčejné,Standard,Κανονικά,Normaali,Normál,Normale,Standaard,Normalny,Обычный,Normálne,Navadno,ArruntaC:/WINDOWS/fonts/simsunb.ttf: SimSun\\-ExtB:style=Regular,Normal,obyčejné,Standard,Κανονικά,Normaali,Normál,Normale,Standaard,Normalny,Обычный,Normálne,Navadno,ArruntaC:/WINDOWS/fonts/simhei.ttf: 黑体,SimHei:style=Regular,Normal,obyčejné,Standard,Κανονικά,Normaali,Normál,Normale,Standaard,Normalny,Обычный,Normálne,Navadno,ArruntaC:/WINDOWS/fonts/simsun.ttc: 宋体,SimSun:style=常规,RegularC:/WINDOWS/fonts/PERTILI.TTF: Perpetua Titling MT:style=Light,Mager,Fina,Maigre,ChiarissimoC:/WINDOWS/fonts/simkai.ttf: 楷体,KaiTi:style=Regular,Normal,obyčejné,Standard,Κανονικά,Normaali,Normál,Normale,Standaard,Normalny,Обычный,Normálne,Navadno,Arrunta 因此观察到下载安装的simkai.ttf的英文名叫KaiTi 修改CLS文件中的定义， 将\\newCJKfontfamily{\\kaiti}{SimKai}改为\\newCJKfontfamily{\\kaiti}{KaiTi} 问题解决 Latex的\\cite后面的参考文献显示问号 [?] + 不显示参考文献 referer: Latex 引用参考文献显示问号[?]的几种情况及解决办法 Latex的\\cite后面的参考文献显示问号 [?]——☆work usepackage和requirepackage的区别 &quot;the convention is to use \\RequirePackage in a package or class and \\usepackage in oa document&quot;l. 123456789% right\\RequirePackage&#123;atbegshi&#125; \\documentclass ....% wrong\\usepackage&#123;atbegshi&#125; \\documentclass ...% --&gt;RequirePackage在documentclass之前定义， usepackage在文档中定义`The only difference is that \\usepackage cannot be used before \\documentclass. Otherwise there is no functional difference. ` 总结： {}中的大多为具体内容， []中的大多为option选项设置 \\newcommand{\\xxx}相当于一个宏定义替换， 在tex中直接使用指令\\xxxx即可；\\newenvironment{xxx}{}相对而言复杂一点，在tex中需要用\\begin{xxx} ... \\end{xxx} 横线： rule如\\midrule","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"深度学习+Pytorch学习笔记","slug":"深度学习-Pytorch读书笔记","date":"2020-11-28T03:24:12.000Z","updated":"2021-11-28T01:39:30.490Z","comments":true,"path":"2020/11/28/深度学习-Pytorch读书笔记/","link":"","permalink":"https://nymrli.top/2020/11/28/深度学习-Pytorch读书笔记/","excerpt":"","text":"在课程设计实验周里总共读了3本书， 《深度学习算法实践》、《深度学习框架PyTorch快速开发与实战》、《PyTorch深度学习入门》。 其中《深度学习算法实践》、《深度学习框架PyTorch快速开发与实战》比较失望，质量比较差；《PyTorch深度学习入门》的代码质量高一点，但需要理论辅助，由于事先看了李宏毅老师的深度学习，因此还算容易入手。 《深度学习框架PyTorch快速开发与实战》 网上关于《深度学习框架PyTorch快速开发与实战》的评价： 关于作者 作者一共三个，在封面内侧有简单的介绍, 三个作者的简绍里没有“深度学习”相关的内容（请注意书名）.单从这本书的作者介绍来说，这几个作者是很不专业的，换言之，这几个人可能未必够资格写这么一本书（就事论事，没有任何不尊重人的意思） 代码质量差到离谱 PyTorch版本问题（这个是技术相关书籍都会遇到的问题，可以接受） 代码不全，照着书上的代码敲下来，会发现莫名其妙就少了一部分 我第一本代码书看的就是这本， 当时觉得还行， 但在看完《PyTorch深度学习入门》后打算也敲下这本书的代码，结果发现给的样例代码很多都跑不过，并且初看时对每个函数的详细介绍现在看来可能是因为没东西写了，内容非常重复。 ▲.以后选书还是得看下作者是否相关专业 常用距离公式 （1）闵可夫斯基距离 闵可夫斯基距离（Mlinkowski distance）是衡量数值点之间距离的一种非常常见的方法。 闵可夫斯基距离定义为：(∑i=1n∣xi−yi∣p)1/p\\left(\\sum_{i=1}^{n}\\left|x_{i}-y_{i}\\right|^{p}\\right)^{1 / p}(∑i=1n​∣xi​−yi​∣p)1/p 该距离最常用的p是2和1，前者是欧几里得距离（Euclidean distance），后者是曼哈顿距离（Manhattan distance）。当p趋近于无穷大时，闵可夫斯基距离转化成切比雪夫距离（Chebyshev distance）：lim⁡p→∞(∑i=1n∣xi−yi∣p)1p=max⁡i=1n∣xi−yi∣\\lim _{p \\rightarrow \\infty}\\left(\\sum_{i=1}^{n}\\left|x_{i}-y_{i}\\right| p\\right)^{\\frac{1}{p}}=\\max _{i=1}^{n}\\left|x_{i}-y_{i}\\right|limp→∞​(∑i=1n​∣xi​−yi​∣p)p1​=maxi=1n​∣xi​−yi​∣ （2）马氏距离（Mahalanobis distance）是由印度统计学家马哈拉诺比斯（PC.Mahalanobis）提出的，表示数据的协方差距离。它是一种有效地计算两个未知样本集的相似度的方法。与欧氏距离不同的是它考虑各种特性之间的联系（例如：一条关于身高的信息会带来一条关于体重的信息，因为两者是有关联的。），并且是尺度无关的（Scale-invariant），即独立于测量尺度。对于一个均值为u，协方差矩阵为的多变量向量，其马氏距离为（x-u）Z（-1）（xu）。 （3）余弦相似度，又称为余弦相似性。通过计算两个向量的夹角余弦值来评估它们的相似度。 假设向量a、b的坐标分别为（×1，y1）、（×2，y2）。则：cos⁡θ=a∙b∥a∥∥b∥\\cos \\theta=\\frac{a \\bullet b}{\\|a\\|\\|b\\|}cosθ=∥a∥∥b∥a∙b​ 数据标准化处理 数据标准化（归一化）处理，是为了消除指标之间的量纲影响，以解决数据指标之间的可比性。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。标准化就是一种对样本数据在不同维度上进行一个伸缩变化，也就是不改变原始数据的信息（分布）。这样的好处就是在进行特征提取时，忽略掉不同特征之间的一个度量，而保留样本在各个维度上的信息（分布）。 a.Min-Max标准化（Min-Max Normalization）也称为离差标准化，是对原始数据的线性变换，使结果值映射到[0, 1]之间。转换函数如下：X∗=X−min⁡max⁡−min⁡X^{*}=\\frac{X-\\min }{\\max -\\min }X∗=max−minX−min​。这种方法有个缺陷就是当有新数据加入时，可能导致max和min的变化，需要重新定义。 b.Z-score标准化方法 这种方法给予原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。经过处理的数据符合标准正态分布，即均值为0，标准差为1，转化函数为X*= \\frac{X-μ}{σ}，其中u为所有样本数据的均值，σ为所有样本数据的标准差。 正则化 为了防止过拟合现象，我们加入了正则化项，常用的有 L1范数和 L2范数。 常用的向量的范数如下。 L0范数：||x||0为x向量各个非零元素的个数。 L1范数：||x||1为x向量各个元素绝对值之和，也叫“稀疏规则算子”（Lasso Regularization）。 L2范数：||x||2为 x 向量各个元素平方和的1/2次方，L2范数又称Euclidean范数或者Frobenius范数。在回归里面，有人把有它的回归叫“岭回归”（Ridge Regression），有人也叫它“权值衰减（Weight Decay）”。 Lp范数：||x||为x向量各个元素绝对值p次方和的1/p次方 […] 成本函数（优化函数） 在训练神经网络时，必须评估网络输出的正确性。众所周知，预期上正确的训练输出数据和实际的训练输出是可比拟的。成本函数便是测量实际和训练输出之间的差异。实际和预期输出之间的零成本将意味着训练神经网络成为可能。 BGD即Batch Gradient Descent。在训练中，每一步迭代都使用训练集的所有内容。也就是利用现有参数对训练集中的每一个输入生成一个估计输出，然后跟实际输出比较，统计所有误差，求平均以后得到平均误差，以此来作为更新参数的依据。 由于每一步都利用了训练集中的所有数据，因此当损失函数达到最小值以后，能够保证此时计算出的梯度为0，换句话说，就是能够收敛。因此，使用BGD时不需要逐渐减小学习速率。由于每一步都要使用所有数据，因此随着数据集的增大，运行速度会越来越慢。在批量梯度下降法中，因为每次都遍历了完整的训练集，其能保证结果为全局最优，但是也因为我们需要对每个参数求偏导，且在对每个参数求偏导的过程中还需要对训练集遍历一次，当训练集很大时，这个计算量是惊人的！ 所以，为了提高速度，减少计算量，提出了SGD随机梯度下降的方法，该方法每次随机选取一个样本进行梯度计算，大大降低了计算成本。SGD全名Stochastic Gradient Descent，即随机梯度下降。即随机抽取一批样本，以此为根据来更新参数。随机梯度下降算法和批量梯度下降的不同点在于其梯度是根据随机选取的训练集样本来决定的，其每次对theta的更新，都是针对单个样本数据，并没有遍历完整的参数。当样本数据很大时，可能到迭代完成，也只不过遍历了样本中的一小部分。因此，其速度较快，但是其每次的优化方向不一定是全局最优的，但最终的结果是在全局最优解的附近。 Momentum Momentum 借用了物理中的动量概念，即前几次的梯度也会参与运算。 为了表示动量，引入了一个新的变量v（velocity）。v是之前的梯度的累加，但是每回合都有一定的衰减。前后梯度方向一致时，能够加速学习。前后梯度方向不一致时，能够抑制震荡。 Nesterov Momentum这是对之前的Momentum的一种改进，大概思路就是，先对参数进行估计，然后使用估计后的参数来计算误差。 AdaGrad AdaGrad 可以自动变更学习速率，只需要设定一个全局的学习速率，但是这并非是实际学习速率，实际的速率是与以往参数的模之和的开方成反比的。 它能够实现学习率的自动更改。如果这次梯度大，那么学习速率衰减就快一些；如果这次梯度小，那么学习速率衰减就慢一些。但仍然要设置一个变量。 经验表明，在普通算法中也许效果不错，但在深度学习中，深度过深时会造成训练提前结束。 RMSProp RMSProp 通过引入一个衰减系数r，让r每回合都衰减一定比例，类似于Momentum中的做法。相比于AdaGrad，这种方法很好地解决了深度学习中过早结束的问题。 《PyTorch深度学习入门》 入门coding： 线性回归代码 1234567891011121314151617181920import torchimport matplotlib.pyplot as plt%matplotlib inlinedef Produce_X(x): # 增加一维全1给bias x0 = torch.ones( x.numpy().size) # dim = 0, 添加行； dim = 1, 添加列 X = torch.stack( (x, x0), dim = 1) return Xx = torch.Tensor([ 1.4, 5, 11, 16, 21 ])y = torch.Tensor( [14.4, 29.6, 62, 85.5, 113.4])X = Produce_X(x)inputs = Xtargets = yw = torch.rand(2, requires_grad = True) 1234567891011121314151617181920212223242526def draw(outputs, loss): plt.cla() plt.scatter( x.numpy(), y.numpy() ) plt.plot( x.numpy(), outputs.data.numpy(), 'r-', lw = 5) plt.text(0.5, 0, 'loss=%s' % (loss.item()), fontdict = &#123; 'size':20, 'color':'red' &#125;) plt.pause(0.05)def train(epochs = 1, lr = 0.01): for ep in range(epochs): outputs = inputs.mv(w) print(outputs.size()) print(targets.shape) loss = (outputs - targets).pow(2).sum() loss.backward() w.data = w.data - lr * w.grad w.grad.zero_()#更新完grad后, 必须清空grad, 否则会累加# if epochs % 80 == 0:# draw(outputs, loss) return w, lossw, loss = train(1, lr = 1e-4)print(\"final loss:\", loss.item())print(\"weights:\", w.data) 人工神经元-线性回归 1234567891011121314151617import torchimport matplotlib.pyplot as pltdef Produce_X(x): x0 = torch.ones(x.numpy().size) #用ones产生初始值为1，大小与x相同的向量 X = torch.stack((x,x0),dim=1) #stack函数将两个向量拼合 return Xx = torch.linspace(-3,3,100000)#用linspace产生（-3，3）区间内的100000个点X = Produce_X(x)y = x +1.2*torch.rand(x.size())#假设真实函数是y=x，我们在上面增加一些误差，更加符合实际情况w = torch.rand(2) #定义权重w的变量# 注意这边的x是x， 而不是X， X是神经网络的输入， 被加上了bias的plt.scatter(x.numpy(),y.numpy(),s=0.001)plt.show() 1234567891011CUDA = torch.cuda.is_available()if CUDA: inputs = X.cuda() targets = Y.cuda() w = w.cuda() w.requires_grad = Trueelse: inputs = X targets = Y w = w w.requires_grad = Truue 12345678910111213141516171819202122def draw(outputs, loss): if CUDA: outputs = outputs.cpu() plt.cla() plt.scatter( x.numpy(), y.numpy() ) plt.plot( x.numpy(), outputs.data.numpy(), 'r-', lw = 5) plt.text(0.5, 0, 'loss=%s' % (loss.item()), fontdict = &#123; 'size':20, 'color':'red' &#125;) plt.pause(0.05)def train(epochs = 1, lr = 0.01): for ep in range(epochs): outputs = inputs.mv(w) loss = (outputs - targets).pow(2).sum() loss.backward() w.data = w.data - lr * w.grad w.grad.zero_()#更新完grad后, 必须清空grad, 否则会累加# if epochs % 80 == 0:# draw(outputs, loss) return w, loss 123456789from time import perf_counterstart = perf_counter()w, loss = train(1000, lr = 1e-4)finish = perf_counter()t = finish - startprint(\"计算时间:\", t)print(\"final loss:\", loss.item())print(\"w:\", w.data)print(type(loss)) 人工神经元-线性回归-module 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import torchimport matplotlib.pyplot as pltfrom torch import nn,optimfrom time import perf_counterimport numpy as npfrom typing import Anyx = torch.unsqueeze(torch.linspace(-3, 3, 1000), dim = 1)y = x + 1.2 * torch.rand(x.size())class LR(nn.Module): def __init__(self): super(LR, self).__init__() self.liner = nn.Linear(1, 1) def forward(self, x: Any): out = self.liner(x) return out#如果支持CUDA，则采用CUDA加速CUDA = torch.cuda.is_available()if CUDA: LR_model = LR().cuda() inputs = x.cuda() target = y.cuda()else: LR_model = LR() inputs = x target = ycriterion = nn.MSELoss()optimizer = optim.SGD(LR_model.parameters(), lr=1e-4)def draw(output, loss): if CUDA: output = output.cpu() plt.cla() plt.scatter(x.numpy(), y.numpy(), marker='.') plt.plot(x.numpy(), output.data.numpy(), 'r-', lw=5) plt.text(0.5, 0, 'Loss=%.8s' % (loss.item()), fontdict=&#123;'size': 20, 'color': 'red'&#125;) plt.pause(0.005)def train(model, criterion, optimizer, epochs): for ep in range(epochs): output = model(inputs) loss = criterion(output, target) optimizer.zero_grad()# 清空权重的grad loss.backward()# 计算梯度 optimizer.step()# 利用梯度更新权重 if ep % 80 == 0: draw(output, loss) return model, lossstart = perf_counter()LR_model,loss = train(LR_model,criterion,optimizer,10000)finish = perf_counter()time = finish-startprint(\"计算时间:%s\" % time)print(\"final loss:\",loss.item())print(\"weights:\",list(LR_model.parameters())) 非线性回归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import torchimport matplotlib.pyplot as pltfrom torch import nn, optimfrom time import perf_counterimport numpy as npfrom typing import Anydef draw(output, loss): if CUDA: output = output.cpu() plt.cla() plt.scatter(x.numpy(), y.numpy(), marker='.') plt.plot(x.numpy(), output.data.numpy(), 'r-', lw=5) plt.text(-2, -10, 'Loss=%.6s' % (loss.item()), fontdict=&#123;'size': 20, 'color': 'red'&#125;) plt.pause(0.005)x = torch.unsqueeze(torch.linspace(-3, 3, 1000), dim=1)y = x.pow(3) + 0.3 * torch.rand(x.size())plt.scatter(x.numpy(), y.numpy())plt.show()class Net(nn.Module): def __init__(self, input_feature, num_hidden, outpus): super(Net, self).__init__() self.hidden = nn.Linear(input_feature, num_hidden) self.out = nn.Linear(num_hidden, outpus) def forward(self, x): x = nn.functional.relu(self.hidden(x)) x = self.out(x) return x# 如果支持CUDA，则采用CUDA加速CUDA = torch.cuda.is_available()if CUDA: net = Net(input_feature= 1, num_hidden= 20, outpus= 1).cuda() inputs = x.cuda() target = y.cuda()else: net = Net(input_feature= 1, num_hidden= 20, outpus= 1) inputs = x target = ycriterion = nn.MSELoss()optimizer = optim.SGD(net.parameters(), lr=0.01)def train(model, criterion, optimizer, epochs): for ep in range(epochs): output = model(inputs) loss = criterion(output, target) optimizer.zero_grad() loss.backward() optimizer.step() if ep % 80 == 0: draw(output, loss) return model, lossnet, loss = train(net, criterion, optimizer, 1)print(type(loss))print(\"final loss:\", loss.item()) 分类问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import torchimport matplotlib.pyplot as pltfrom torch import nn, optimfrom time import perf_counterimport numpy as npdef draw(output): if CUDA: output=output.cpu() plt.cla() # torch.max[0]是取max的值， [1]是取索引值 output = torch.max((output), 1)[1] pred_y = output.data.numpy().squeeze() target_y = y.numpy() plt.scatter(x.numpy()[:, 0], x.numpy()[:, 1], c=pred_y, s=10, lw=0, cmap='RdYlGn') accuracy = sum(pred_y == target_y)/1000.0 plt.text(1.5, -4, 'Accuracy=%s' % (accuracy), fontdict=&#123;'size': 20, 'color': 'red'&#125;) plt.pause(0.1)N = 500cluster = torch.ones(N, 2)# mean, std的正态分布data0 = torch.normal(4 * cluster, 2)data1 = torch.normal(-4 * cluster, 2)label0 = torch.zeros(N)label1 = torch.ones(N)x = torch.cat((data0, data1), ).type(torch.FloatTensor)y = torch.cat((label0, label1), ).type(torch.LongTensor)plt.scatter(x.numpy()[:, 0], x.numpy()[:, 1], c = y, s=10, lw=0, cmap='RdYlGn')plt.show()class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.linear = nn.Linear(2, 2) def forward(self, x): x = self.linear(x) x = torch.sigmoid(x) return xCUDA = torch.cuda.is_available()if CUDA: net = Net().cuda() inputs = x.cuda() targets = y.cuda()else: net = Net() inputs = x targets = ydef train(model, criterion, optimizer, epochs): for ep in range(epochs): outputs = model(inputs) loss = criterion(outputs, targets) optimizer.zero_grad() loss.backward() optimizer.step() if ep % 80 == 0: draw(outputs) # return model, lossoptimizer = optim.SGD(net.parameters(), lr=0.02)criterion = nn.CrossEntropyLoss()train(net, criterion, optimizer, 1000) torch.randn(5,2)是标准正态分布取（5,2）数 data0 = torch.normal(4 * cluster, 2) , 第一个参数是mean, 第二个是std, 维度根据传入的tensor参数决定 torch.norm() 是求范数 多分类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import torchfrom torch import nn, optimimport torch.nn.functional as Fimport matplotlib.pyplot as pltdef draw(output): if CUDA: output=output.cpu() plt.cla() output = torch.max((output), 1)[1] pred_y = output.data.numpy().squeeze() target_y = y.numpy() plt.scatter(x.numpy()[:, 0], x.numpy()[:, 1], c=pred_y, s=10, lw=0, cmap='RdYlGn') accuracy = sum(pred_y == target_y)/1500.0 plt.text(0.5, -6, 'Accuracy=%.6s' % (accuracy), fontdict=&#123;'size': 20, 'color': 'red'&#125;) plt.pause(0.1)N = 500cluster = torch.ones(N, 2) # 2是两个维度： x, ydata0 = torch.normal(4*cluster, 2)data1 = torch.normal(-4*cluster, 1)data2 = torch.normal(-8*cluster, 1)label0 = torch.zeros(N)label1 = torch.ones(N)label2 = label1 * 2x = torch.cat((data0, data1, data2), ).type(torch.FloatTensor)y = torch.cat((label0, label1, label2), ).type(torch.LongTensor)plt.scatter(x.numpy()[:, 0], x.numpy()[:, 1], c=y.numpy(), s=10, lw=0, cmap='RdYlGn')plt.show()class Net(nn.Module): def __init__(self, input_feature, num_hidden, outputs): super(Net, self).__init__() self.hidden = nn.Linear(input_feature, num_hidden) self.out = nn.Linear(num_hidden, outputs) def forward(self, x ): x = F.relu( self.hidden(x) ) x = F.softmax(self.out(x)) return xCUDA = torch.cuda.is_available()if CUDA: net = Net(input_feature=2, num_hidden=20,outputs=3).cuda() inputs = x.cuda() target = y.cuda()else: net = Net(input_feature=2, num_hidden=20,outputs=3) inputs = x target = yoptimizer = optim.SGD(net.parameters(), lr=0.02)criterion = nn.CrossEntropyLoss()def train(model, criterion, optimizer, epochs): for ep in range(epochs): outputs = model(inputs) loss = criterion(outputs, target) optimizer.zero_grad() loss.backward() optimizer.step() if ep % 80 == 0: draw(outputs)train(net, criterion, optimizer, 10000) LeNet-MNIST手写识别 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121# coding=utf-8import osimport torchfrom torch import nn, optimimport torch.nn.functional as Ffrom torchvision import datasets, transforms# 加载torchvision， 是专门做图形处理的一个库， datasets为加载数据集， transforms做图形预处理# torch.utils.data.DataLoader做数据加载transform = transforms.Compose([ transforms.ToTensor(), # 将数据转成tensor对象 transforms.Normalize((0.1307,), (0.3081,)) # 将数据做归一化处理])# 下载并存储路径， 加载训练集or测试集、是否自动下载、指定数据预处理方式trainset = datasets.MNIST('data', train=True, download=True, transform=transform)testset = datasets.MNIST('data', train=False, download=True, transform=transform)# 下载下来的raw文件夹包含了数据和标签，processsed文件夹中为处理后的数据class LeNet(nn.Module): # 定义Net的初始化函数，本函数定义了神经网络的基本结构 def __init__(self): # 继承父类的初始化方法，即先运行nn.Module的初始化函数 super(LeNet, self).__init__() # C1卷积层：输入1张灰度图片，输出6张特征图，卷积核5x5 self.c1 = nn.Conv2d(1, 6, (5, 5)) # C3卷积层：输入6张特征图，输出16张特征图，卷积核5x5 self.c3 = nn.Conv2d(6, 16, 5) # 全连接层S4-&gt;C5：从S4到C5是全连接，S4层中16*4*4个节点全连接到C5层的120个节点上 self.fc1 = nn.Linear(16 * 4 * 4, 120) # 全连接层C5-&gt;F6：C5层的120个节点全连接到F6的84个节点上 self.fc2 = nn.Linear(120, 84) # 全连接层F6-&gt;OUTPUT：F6层的84个节点全连接到OUTPUT层的10个节点上，10个节点的输出代表着0到9的不同分值。 self.fc3 = nn.Linear(84, 10) # 定义向前传播函数 def forward(self, x): # 输入的灰度图片x经过c1的卷积之后得到6张特征图，然后使用relu函数，增强网络的非线性拟合能力，接着使用2x2窗口的最大池化，然后更新到x x = F.max_pool2d(F.relu(self.c1(x)), 2) # 输入x经过c3的卷积之后由原来的6张特征图变成16张特征图，经过relu函数，并使用最大池化后将结果更新到x x = F.max_pool2d(F.relu(self.c3(x)), 2) # 使用view函数将张量x（S4）变形成一维向量形式，总特征数不变，**为全连接层做准备** x = x.view(-1, self.num_flat_features(x)) # 输入S4经过全连接层fc1，再经过relu，更新到x x = F.relu(self.fc1(x)) # 输入C5经过全连接层fc2，再经过relu，更新到x x = F.relu(self.fc2(x)) # 输入F6经过全连接层fc3，更新到x x = self.fc3(x) return x # 计算张量x的总特征量 def num_flat_features(self, x): # 由于默认批量输入，第零维度的batch剔除 size = x.size()[1:] num_features = 1 for s in size: num_features *= s return num_featuresCUDA = torch.cuda.is_available()if CUDA: lenet = LeNet().cuda()else: lenet = LeNet()criterion = nn.CrossEntropyLoss()optimizer = optim.SGD(lenet.parameters(), lr=0.001, momentum=0.9)# 用数据加载工具来加载训练数据, batch_size表示一次性加载的数据量， shuffle表示遍历不同批次数据时打乱顺序， num_workers表示用n个子进程来加载数据# 后来把workers改成2还是出错，直到最后把workers改成0才不出错。电脑不行啊！当报错时应该考虑一下是不是设置的太大或者不支持多线程进行操作。trainloader = torch.utils.data.DataLoader(trainset, batch_size=4, shuffle=True, num_workers=0)testloader = torch.utils.data.DataLoader(testset, batch_size=4, shuffle=False, num_workers=0)def train(model, criterion, optimizer, epochs=1): for epoch in range(epochs): running_loss = 0.0 for i, data in enumerate(trainloader, 0): inputs, labels = data if CUDA: inputs, labels = inputs.cuda(), labels.cuda() optimizer.zero_grad() outputs = model(inputs) loss = criterion(outputs, labels) loss.backward() optimizer.step() running_loss += loss.item() if i % 1000 == 999: print('[Epoch:%d, Batch:%5d] Loss: %.3f' % (epoch + 1, i + 1, running_loss / 1000)) running_loss = 0.0 print('Finished Training')def test(testloader, model): correct = 0 total = 0 for data in testloader: images, labels = data if CUDA: images = images.cuda() labels = labels.cuda() outputs = model(images) _, predicted = torch.max(outputs.data, 1) total += labels.size(0) correct += (predicted == labels).sum() print('Accuracy on the test set: %d %%' % (100 * correct / total))def load_param(model, path): if os.path.exists(path): model.load_state_dict(torch.load(path))def save_param(model, path): torch.save(model.state_dict(), path)load_param(lenet, 'model.pkl')train(lenet, criterion, optimizer, epochs=2)save_param(lenet, 'model.pkl')test(testloader, lenet) model.eval()是让model变成训练模式， 这主要是因为dropout和batch normalization的操作在训练和测试是不一样的 附录 Torch.size()/shape, numpy.narray.size/shape 区别 1234567# a = np.array([[1,2,3],[2,1,3]])# print(a.shape, a.size)# (2, 3) 6a = torch.Tensor([[1,2,3],[2,1,3]])print(a.shape, a.size())# torch.Size([2, 3]) torch.Size([2, 3]) unsqueeze用法 12345a = torch.linspace(-3, 3, 5)print(a, a.size())b = torch.unsqueeze(a, dim = 1)print(b, b.size()) 关于求微分-&gt;autograd-&gt;Variable 之前书上提供的代码需要求grad的时都是把tensor的requires_grad属性手动置为True(requires_grad默认为False的)， 而实际上需要求grad的tensor已经被封装成了可以自动求微分的Variable类型(from torch.autograd import Variable)` 1234567891011CUDA = torch.cuda.is_available()if CUDA: inputs = X.cuda() targets = Y.cuda() w = w.cuda() w.requires_grad = Trueelse: inputs = X targets = Y w = w w.requires_grad = True (variable)的理解， pytorch中的变量variable有三个属性，分别是data表示变量中的具体值， grad表示这个变量反向传播的梯度，这个的计算方式下面有专门的一个演示程序， grad_fn表示是通过什么操作得到这个变量的例如( 加减乘除、卷积、反置卷积) 然后定义一个tensor(张量)，以及将tensor(张量)转化成variable(变量)。之所以需要将tensor转化成variable是因为pytorch中tensor(张量)只能放在CPU上运算，而(variable)变量是可以用GPU进行加速计算的。 所以说这就是为什么pytorch加载图像的时候一般都会使用(variable)变量. 下面一段代码演示的是tensor和variable(变量)之间的转化。 12345678910111213# 然后定义pytorch中的tensor 并将tensor转化成Variable的形式x_tensor = torch.ones(3)print('张量的类型以及具体值:\\n', type(x_tensor), x_tensor)x_var = Variable(x_tensor, requires_grad = True)print('变量的类型以及具体的值:\\n', type(x_var), x_var)'''张量的类型以及具体值: &lt;class 'torch.Tensor'&gt; tensor([1., 1., 1.])变量的类型以及具体的值: &lt;class 'torch.Tensor'&gt; tensor([1., 1., 1.], requires_grad=True) '''# 可以看到这边多了一个requires_grad的属性 Tensor也可以通过x_tensor.data来获得值，因此比较下来两者的区别就是requires_grad为True、False的关系 摘自： https://blog.csdn.net/qq_41776781/article/details/93967961 《深度学习算法实践》 这本书应该是我大二见到过最多的书了， 但说实话看完也比较一般， 比较多介绍的是深度学习应用介绍。 《Pytorch深度学习实战：从新手小白到数据科学家》 这本书感觉也不错，即介绍了torch也介绍了不少pandas和sklearn PyTorch的核心概念 本节主要介绍PyTorch的基本概念（如Tensor 和Variable）、自动微分和PyTorch的核心模块。 1.3.1PyTorch的基本概念 和其他深度学习框架一样，PyTorch在实现过程中也提出了自己的概念，包括张量，PyTorch中的张量用Tensor表示。初学者可能不知道张量是什么。其实，张量可以简单地理解为一个多维数组，类似于NumPy中的narray对象。 多维数组可以用相册来形象地解释。假设小米有相册A，相册A包含N张图片，每张图片的宽度为那、高度为H。由于是彩色图片，在计算机中用RGB三通道表示（所有颜色都可以用红、景、蓝三原色按照不同的比例调配出来，红、绿、蓝三通道不同的像素亮度值叠加在一起就呈现出不同的颜色，所以整张图片呈现出彩色），所以通道数为3。. PyTorch采用四维数组表示这个相册，形如[N, W,H, C]，其中C表示通道数。这种多维数组表示的好处可以从计算机组成原理说起，现代计算机都是多核多处理器的，支持多线程和多进程，非常适合矩库的并行计算，而且计算一批数据和计算一个数据的调度时间是差不多的，因此科学计算往往都是基于矩阵的计算，并且会指定一个适当的Batch。例如，PyTorch视觉处理中通常将Bah指定为4、128或256，这也是为了充分利用计算机资源而考虑的。基于张量的乘法运算如图18所示。 张量就是多维数组，并且提供了CPU设备和GPU设备的支持。如果机器上有GPU设备，就可以在Tr上调用cuda方法，将Tensor的数据加载到GPU设备中运行，提升运行速度。张最上提供了很多有用的方法，这些方法和Numpy中的方法类似，使用过NmPy的读者肯定会觉得这些方法既眼熟又亲切。 创健张量需要借助tensor提供的Tensor方法或from_numpy方法。理论上可以创建任意维度的多为数组，但最常用的Tensor补超过五维。 除了维度，还可以指定每个维度上的SIZE，如a = torch.Tensor(3, 4, 5, 8)，表示创建了一个思维数组，因为Tensor有4个参数，每个参数表示对应维度的大小。因此，变量a可以表示Batch书为3、宽度为4。高度为5，通道数为8的特征图（Feature Map图像卷积运算产生的中间特征） 除了一二维以外，还有三维立方体：将多个二维矩阵叠加在一起就可以形成三维立方体。三维Tensor 常用于表示图片数据[width，height，channel]。四维多立方体：常见于批量的图片数据，如之前介细的相册就是多张图片的叠加，最常见的形式为[batch, width, height, channel]。五维：表示多个四维tensor相加，常见于视频数据，视频按帧数划分，如50fps（帧/s），表现形式为[frames, batch, width, height, channel] Variable PyTorch中另外一个和Tensor相关的概念是Variable变量。Variable是对Tensor的封装，是一种特殊的张量，位于torch.autograd自动微分模块中，是为实现自动微分而提出的一种特殊的数据结构。在PyTorch0.4.1之前的版本中，Variable的应用非常广泛。但是到PyTorch1.0之后，这个数据结构被标注为deprecated，表示已经过时，并且Variable中的grad和grad_fm等属性也被转移到Tensor中，这个改变进一步精简了接口。由于市面上还存在大量老版本的代码，所以本书也对Variable进行简单介绍。创建Variable需要借助 torch.autograd中提供的Variable方法，它接收Tensor类型的参数。下面通过 Float Tensor 创建 Variable。 算子有哪些 PyTorch的核心模块 任何好的软件系统必定是经过精心设计和抽象的，PyTorch脱胎于2012年使用La语言编写的To山项目，该项目无论是计算架构设计还是扩展性都是一流的，特别是动态图更是让人耳目一新。 pyTorch将系统的实现抽象为不同的模块，最核心的模块是Tensor，它是整个动态图的基础，自动微分及反向传播都需要借助该模块。Torch为创建Tensor提供了多种方法，如torchrandn、torcth.randint等，Tensor上实现了大量的方法，如sum、argmin、argmax等。Tensor也是torch模块构建网络的核心，网络构建好之后通过网络的parameters方法可以获取网络的所有参数，并且可以通过遍历这些参数对象改变requires_grad 属性来达到冻结参数的目的，这在迁移学习中特别有用。torch.nn模块通过functional子模块提供了大量方法，如conv、ReLU、polling、softmax等。这些方法在网络的forward中调用，结果输出值由torch.nn.xxxLos损失函数计算损失。torch.nn模块中提供了很多可选的损失函数，如MSELoss、CrossEntropyLoss等，将损失传递给优化模块，torch.optim优化模块提供了大量的优化器，常见的有SGD、Adam等。优化器会根据损失计算并更新梯度，达到优化的目的，最终将更新 parameters。PyTorch的核心模块如图1.14所示。 《Python深度学习基于Pytorch》 神经网络核心组件： 层：神经网络的基本结构，将输入张量转换为输出张量 模型：层构成的网络 损失函数：参数学习的目标函数，通过最小化损失函数来学习各种参数 优化器：如何使损失函数最小，这就设计优化器 多个层链接在一起构成一个模型或网络,输入数据通过这个模型转换为预测值,然后损失函数把预测值与真实值进行比较,得到损失值(损失值可以是距离、概率值等),该损失值用于衡量预测值与目标结果的匹配或相似程度,优化器利用损失值更新权重参数,从·而使损失值越来越小。这是一个循环过程,当损失值达到一个阀值或循环次数到达指定次数,循环结束。接下来利用PyTorch的nn工具箱,构建一个神经网络实例。nn中对这些组件都有现成包或类,可以直接使用,非常方便。 识别手写体步骤： 利用pytorch内置函数mnist下载数据 利用torchvision对数据进行预处理，调用torch.utils建立一个数据迭代器 可视化源数据 利用nn工具箱构建神经网络模型 实例化模型，并定义损失函数及优化器 训练模型 可视化结果 优化器 SGD SGD带动量optim.SGD(model.parameters(), lr=lr, momentum=momentum) adagrad RMSProp（通过修改AdaGrad而来） Adam(带动量项的RMSProp) torchvision 更多见：40 实战 Kaggle 比赛：狗的品种识别（ImageNet Dogs）【动手学深度学习v2】-引入预训练网络 models 预训练模型，如torchvision.models.resnet34(pretrained=True) datasets 数据集，如mnist，如datasets.MNIST 对比tensorflow：(X_train, _), (_, _) = mnist.load_data() ImageFolder，将指定目录下的数据以文件夹为界区分label 注：配合data.DataLoader使用 transforms 数据增强工具，Scale, RandomCrop、RandomResizedCrop, Pad, ColorJitter、RandomHorizontalFlip、ToTensor、CenterCrop 聚合多个变换操作，Compose utils data.DataLoader 12345678910111213# 经典用法dataloader = torch.utils.data.DataLoader( datasets.MNIST( \"../../data/mnist\", train=True, download=True, transform=transforms.Compose( [transforms.Resize(opt.img_size), transforms.ToTensor(), transforms.Normalize([0.5], [0.5])] ), ), batch_size=opt.batch_size, shuffle=True,) save_image 附录 保存模型断点： 1234567891011121314151617181920212223# 存模型参数写法： def save_checkpoint(self, folder='checkpoint', filename='checkpoint.pth.tar'): filepath = os.path.join(folder, filename) if not os.path.exists(folder): print(\"Checkpoint Directory does not exist! Making directory &#123;&#125;\".format(folder)) os.mkdir(folder) else: print(\"Checkpoint Directory exists! \") torch.save(&#123; 'state_dict' : self.nnet.state_dict(), &#125;, filepath) def load_checkpoint(self, folder='checkpoint', filename='checkpoint.pth.tar'): filepath = os.path.join(folder, filename) if not os.path.exists(filepath): raise(\"No model in path &#123;&#125;\".format(filepath)) map_location = None if args.cuda else 'cpu' checkpoint = torch.load(filepath, map_location=map_location) self.nnet.load_state_dict(checkpoint['state_dict'])# 存整个模型if j % 10 ==0 and loss &lt; loss_value: torch.save(model, \"model.cpkt\") loss_value = loss 注意点： PIL能show的图片格式不能是tensor，只能是numpy的array，所以需要可视化的话得转换一下。 10分钟快速入门PyTorch (1) https://zhuanlan.zhihu.com/p/26893755","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://nymrli.top/tags/读书笔记/"}]},{"title":"Linux服务器同步时钟","slug":"Linux服务器同步时钟","date":"2020-11-22T04:49:35.000Z","updated":"2020-11-22T04:50:08.208Z","comments":true,"path":"2020/11/22/Linux服务器同步时钟/","link":"","permalink":"https://nymrli.top/2020/11/22/Linux服务器同步时钟/","excerpt":"","text":"因为今天在集群193跑程序的时候发现时间不同步, 因此想想把集群的时间全部同步一下 在Linux中设置系统时间，可以用date命令： 1234# 查看时间$ date# 修改时间$ date -s \"20140225 20:16:00\" #yyyymmdd hh:mm:ss Linux硬件时间的设置 硬件时间的设置，可以用hwclock或者clock命令。两者基本相同，只用一个就行，只不过clock命令除了支持x86硬件体系外，还支持Alpha硬件体系。 系统时间和硬件时间的同步 同步系统时间和硬件时间，可以使用hwclock命令。 4. 不同机器之间的时间同步 为了避免主机时间因为长期运行下所导致的时间偏差，进行时间同步（synchronize）的工作是非常必要的。Linux系统下，一般使用ntp服务器来同步不同机器的时间。一台机器，可以同时是ntp服务端和ntp客户端。在生产系统中，推荐使用像DNS服务器一样分层的时间服务器来同步时间。 不同机器间同步时间，可以使用ntpdate命令，也可以使用ntpd服务。==&gt;▲. 注意两个不能同时使用: 如果使用了ntpd后还是用ntpdate会报错ntpdate[39462]: the NTP socket is in use, exiting, 要查询ntp的状态，用ntpq命令，比如看目前是否和ntp server同步，用ntpq -p 1234567891011121314 remote refid st t when poll reach delay offset jitter============================================================================== 0.ubuntu.pool.n .POOL. 16 p - 64 0 0.000 0.000 0.000 1.ubuntu.pool.n .POOL. 16 p - 64 0 0.000 0.000 0.000 2.ubuntu.pool.n .POOL. 16 p - 64 0 0.000 0.000 0.000 3.ubuntu.pool.n .POOL. 16 p - 64 0 0.000 0.000 0.000 ntp.ubuntu.com .POOL. 16 p - 64 0 0.000 0.000 0.000 ntp1.ams1.nl.le 130.133.1.10 2 u 1 64 1 305.632 -43.387 0.146*120.25.115.20 10.137.53.7 2 u 1 64 1 29.425 -1.059 0.410 203.107.6.88 100.107.25.114 2 u 1 64 1 32.056 -2.093 0.257 ntp.xtom.nl 84.199.11.211 2 u 1 64 1 175.286 -6.179 0.210 94.130.49.186 ( 195.13.23.5 3 u 2 64 1 212.348 -17.943 0.561 tock.ntp.infoma .GPS. 1 u 2 64 1 239.693 -11.135 0.175 119.28.206.193 100.122.36.196 2 u - 64 1 41.525 -4.034 0.002 可以看到*号标出的就是集群正在同步的时钟服务器: 120.25.115.20是阿里云 由于不能同时使用， 而ntpdate的稳定性不好， 因此ntpdate用来一次性同步时间（或者ntpdate+cron组合）、或者用ntpdate同步一次时间后，持续用ntpd服务器来同步。 下面使用ntpdate来同步时间：使用ntpdate前, 先将ntpd关闭: service ntpd stop或sudo systemctl stop ntp 1234# /usr/sbin/ntpdate time.stdtime.gov.twError : Temporary failure in name resolution29 Oct 14:18:59 ntpdate[25327]: can't find host time.stdtime.gov.tw29 Oct 14:18:59 ntpdate[25327]: no servers can be used, exiting 确认防火墙没有问题后，执行域名解析，发现失败 12# nslookup time.stdtime.gov.tw;; connection timed out; no servers could be reached 尝试ping外网，以确认能正常连到外网，连网正常 1234567# ping 8.8.8.8PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.64 bytes from 8.8.8.8: icmp_seq=1 ttl=53 time=1.48 ms64 bytes from 8.8.8.8: icmp_seq=2 ttl=53 time=1.40 ms--- 8.8.8.8 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1000msrtt min/avg/max/mdev = 1.404/1.445/1.487/0.056 ms 于是修改DNS文件, /etc/resolv.conf, 虽然这边提示不要手动修改, 但是临时改掉是没问题的 1234# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN#nameserver 127.0.1.1nameserver 8.8.8.8 修改后，再次执行时间同步，ok鸟！ 12apollo3d@apollo15:~/cl/Python_project/cplm/Min38$ sudo ntpdate ntp1.aliyun.com21 Nov 23:04:25 ntpdate[40285]: adjust time server 120.25.115.20 offset 0.002194 se 除了阿里云的还有pool.ntp.org可以用来同步。 ▲但是同步之后时间还是不太对， 于是观察时区， 发现集群两台电脑上其实只是时区是不同的， 同步的服务器都是一样的阿里云的。 12345apollo3d@apollo2:~$ date2020年 11月 22日 星期日 12:14:11 CSTapollo3d@apollo15:~/cl/Python_project/cplm/Min38$ dateSat Nov 21 23:14:01 EST 2020 发现一个是EST和CST。网上查询得知 EST代表英国时间, CST代表北京时间, EDT：指美国东部夏令时间 那么现在只要改成北京时间的时区CST就可以了，修改如下： 123[root@localhost ~]# mv /etc/localtime /etc/localtime.bak[root@localhost ~]# ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime[root@localhost ~]# date 但是发现两台语言不一样, 一个是中文, 一个是英文, 猜测是操作系统中英版导致的: 输出环境变量: 123456789101112131415161718192021apollo3d@apollo2:~$ date2020年 11月 22日 星期日 12:14:11 CST$ env# 可以看到时区是中国HOME=/home/apollo3dLOGNAME=apollo3dLESSCLOSE=/usr/bin/lesspipe %s %sLC_TIME=zh_CN.UTF-8LC_NAME=zh_CN.UTF-8_=/usr/bin/envapollo3d@apollo15:~/cl/Python_project/cplm/Min38$ dateSat Nov 21 23:14:01 EST 2020$ env# 可以看到语言是en_US, 但是没设置时区MAIL=/var/mail/apollo3dPWD=/home/apollo3d/cl/Python_project/cplm/Min38JAVA_HOME=/home/apollo3d/Apollo_Rescue/jdk1.8.0_161LANG=en_US.UTF-8HOME=/home/apollo3dSUDO_COMMAND=/bin/su 因此可以修改LANG: 12$ sudo vim /etc/sysconfig/i18nLANG=\"en_US.UTF-8\"改为LANG=\"zh_CN.GB2312\" 再运行我的Python脚本的时候发现竟然报错了: ValueError: Timezone offset does not match system offset: -18000 != 28800. Please, check your config files. 因为系统时区和代码运行时区不一样导致。解决办法：在创建BlockingScheduler对象时指定上海的时区scheduler = BlockingScheduler(timezone=&quot;Asia/Shanghai&quot;)","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"李宏毅机器学习_摘要","slug":"李宏毅机器学习-摘要","date":"2020-11-17T12:36:05.000Z","updated":"2020-12-20T14:35:08.357Z","comments":true,"path":"2020/11/17/李宏毅机器学习-摘要/","link":"","permalink":"https://nymrli.top/2020/11/17/李宏毅机器学习-摘要/","excerpt":"","text":"P3Regression - Case Study regularization解决overfitting(L2正则化解决过拟合问题) regularization可以使曲线变得更加smooth，training data上的error变大，但是 testing data上的error变小。有关regularization的具体原理说明详见下一部分 原来的loss function只考虑了prediction的error，即$$\\sum_{i}{n}\\left(\\hat{y}{i}-\\left(b+\\sum_{j} w_{j} x_{j}\\right)\\right)^{2}$$；而regularization则是在原来的loss function的基础上加上了一项$$\\lambda \\sum\\left(w_{i}\\right)^{2}$$，就是把这个model里面所有的Wi的平方和用λ加权(其中i代表遍历n个training data，j代表遍历model的每一项) 也就是说，*我们期待参数w i w_i*w*i*越小甚至接近于0的function，为什么呢？ 因为参数值接近0的function，是比较平滑的；所谓的平滑的意思是，当今天的输入有变化的时候，output对输入的变化是比较不敏感的。举例来说，对y=b+∑wixiy=b+\\sum w_{i} x_{i}y=b+∑wi​xi​这个model，当input变化Δ x，output的变化就是，$$w_{i} \\Delta x_{i}$$也就是说，如果w越i小越接近0的话，输出对输入就越不sensitive敏感，我们的function就是一个越平滑的function；说到这里你会发现，我们之前没有把bias——b这个参数考虑进去的原因是bias的大小跟function的平滑程度是没有关系的，bias值的大小只是把function上下移动而已 那为什么我们喜欢比较平滑的function呢？ 如果我们有一个比较平滑的function，由于输出对输入是不敏感的，测试的时候，一些noises噪声对这个平滑的function的影响就会比较小，而给我们一个比较好的结果 注：这里的λ需要我们手动去调整以取得最好的值 λ值越大代表考虑smooth的那个regularization那一项的影响力越大，我们找到的function就越平滑 观察下图可知，当我们的λ越大的时候，在training data上得到的error其实是越大的，但是这件事情是非常合理的，因为当λ越大的时候，我们就越倾向于考虑w的值而越少考虑error的大小；但是有趣的是，虽然在training data上得到的error越大，但是在testing data上得到的error可能会是比较小的 我们喜欢比较平滑的function，因为它对noise不那么sensitive；但是我们又不喜欢太平滑的function，因为它就失去了对data拟合的能力；而function的平滑程度，就需要通过调整λ来决定，就像下图中，当λ=100时，在testing data上的error最小，因此我们选择λ=100 P4Basic Concept bias和variance bias表示离靶心的距离, 而variance表示散布情况 图中所示，只有足够大的函数搜索空间，才能找到正确的“靶心”，因此就需要吧模型设计得足够复杂。而复杂模型需要大数据来降低方差， 因此需要大量的数据防止过拟合 如果来自variance的误差很大， 那么就是过拟合； 如果来自bias的误差很大，那么就是欠拟合（underfitting） bias大： 如果无法fit训练数据, 证明是欠拟合;如果能fit训练数据，但是在测试数据上有较大的误差，那么就是过拟合——做法：增大特征or增大次项 variance大： 更多的数据（数据增强）or 正则化 交叉验证： 在trainingset训练后,虽然在公开的测试集上表示良好,但是private testing set不好的话, 则还是比较糟糕的模型。因此在判断一个模型的好坏的时候， 可以将trainingSet进行交叉验证 非常不建议因为在public testing set上表现不好而反过来重新选择trainingSet的模型， 因为这相当于在训练的时候吧testing也考虑在内了， 违背了设计的初衷，并且这样的结果在private testing set上也会表现不好。 N-fold cross validation （十折交叉验证） 如果不相信某一个trainset的结果的话， 那就分很多trainset 5. P5Gradient Descent θ∗=arg⁡min⁡θL(θ)\\theta^{*}=\\arg \\min _{\\theta} L(\\theta) θ∗=argθmin​L(θ) L: loss function θ\\thetaθ : parameters(上标表示第几组参数, 下标表示这组参数中的第几个参数) 当参数有很多个的时候(&gt;3)，其实我们很难做到将loss随每个参数的变化可视化出来(因为最多只能可视化出三维的图像，也就只能可视化三维参数)，但是我们可以把update的次数作为唯一的一个参数，将loss随着update的增加而变化的趋势给可视化出来(上图右半部分) 所以做gradient descent一个很重要的事情是，要把不同的learning rate下，loss随update次数的变化曲线给可视化出来，它可以提醒你该如何调整当前的learning rate的大小，直到出现稳定下降的曲线 总结：梯度下降法指的是函数值loss随梯度下降的方向减小 Adaptive Learning rates 显然这样手动地去调整learning rates很麻烦，因此我们需要有一些自动调整learning rates的方法 最基本、最简单的大原则是：learning rate通常是随着参数的update越来越小的 因为在起始点的时候，通常是离最低点是比较远的，这时候步伐就要跨大一点；而经过几次update以后，会比较靠近目标，这时候就应该减小learning rate，让它能够收敛在最低点的地方 Adagrad Divide the learning rate of each parameter by the root mean square(方均根) of its previous derivatives Adagrad就是将不同参数的learning rate分开考虑的一种算法(adagrad算法update到后面速度会越来越慢，当然这只是adaptive算法中最简单的一种) Stochastic Gradicent Descent 随机梯度下降的方法可以让训练更快速，传统的gradient descent的思路是看完所有的样本点之后再构建loss function，然后去update参数；而stochastic gradient descent的做法是，看到一个样本点就update一次，因此它的loss function不是所有样本点的error平方和，而是这个随机样本点的error平方 Feature Scaling 概念介绍 特征缩放，当多个特征的分布范围很不一样时，最好将这些不同feature的范围缩放成一样 对gradient decent的帮助 之前我们做的demo已经表明了，对于这种长椭圆形的error surface，如果不使用Adagrad之类的方法，是很难搞定它的，因为在像w1和w2这样不同的参数方向上，会需要不同的learning rate，用相同的lr很难达到最低点 如果有scale的话，loss在参数w1、w2平面上的投影就是一个正圆形，update参数会比较容易 而且gradient descent的每次update并不都是向着最低点走的，每次update的方向是顺着等高线的方向(梯度gradient下降的方向)，而不是径直走向最低点；但是当经过对input的scale使loss的投影是一个正圆的话，不管在这个区域的哪一个点，它都会向着圆心走。因此feature scaling对参数update的效率是有帮助的 scaling method: z-score: 归一化 gradient descent数学理论 注意 learning rate需要设置好, 否则Δθ不为0, 则泰勒近似不成立。 gradient descent的限制 ▲gradient descent的限制是，它在gradient即微分值接近于0的地方就会停下来，而这个地方不一定是global minima，它可能是local minima，可能是saddle point鞍点，甚至可能是一个loss很高的plateau平缓高原 6. P10Classification_1 特征、特征向量是什么？ 要想把一个东西当做计算机能理解的function的input，就需要把它数值化 特性数值化：用一组数字来描述一只宝可梦的特性， 比如用一组数字表示它有多强(total strong)、它的生命值(HP)、它的攻击力(Attack)、它的防御力(Defense)、它的特殊攻击力(Special Attack)、它的特殊攻击的防御力(Special defend)、它的速度(Speed)，以皮卡丘为例，我们可以用以上七种特性的数值就是特征量， 而多个特征量所组成的vector就是特征向量 我们希望蓝色的这些属于class 1的宝可梦，input到Regression的model，output越接近1越好；红色的属于class 2的宝可梦，input到Regression的model，output越接近-1越好。如果使用回归来硬解分类问题的话， 异常值影响比较大。 异常值则远远大于1， 跟目标不一致 Regression的output是连续性质的数值，而classification要求的output是离散性质的点，我们很难找到一个Regression的function使大部分样本点的output都集中在某几个离散的点附近 因此，Regression定义model好坏的定义方式对classification来说是不适用的 Solution：Generative model——朴素贝叶斯分类器 ![function](李宏毅机器学习-摘要/P6 classification\\function.jpg) 我们可以把loss function定义成L^(f)=∑nδ(f(xn)≠y^n)\\hat{L}(f)=\\sum_{n} \\delta\\left(f\\left(x^{n}\\right) \\neq \\hat{y}^{n}\\right)L^(f)=∑n​δ(f(xn)​=y^​n)，即这个model在所有的training data上predict预测错误的次数，也就是说分类错误的次数越少，这个function表现得就越好 贝叶斯公式=单条路径概率/所有路径概率和 ![beyas](李宏毅机器学习-摘要/P6 classification\\beyas.jpg) 这一整套想法叫做Generative model(生成模型)，为什么叫它Generative model呢？因为有这个model的话，就可以拿它来generate生成x(如果你可以计算出每一个x出现的概率，就可以用这个distribution分布来生成x、sample x出来) 现在的问题是，怎么得到P(x∣C1)P\\left(x \\mid C_{1}\\right)P(x∣C1​) 和 P(x∣C2)P\\left(x \\mid C_{2}\\right)P(x∣C2​) 的值==&gt; 认为数据服从 高斯分布 高斯分布 fμ,Σ(x)=1(2π)D/21∣Σ∣1/2exp⁡{−12(x−μ)TΣ−1(x−μ)}f_{\\mu, \\Sigma}(x)=\\frac{1}{(2 \\pi)^{D / 2}} \\frac{1}{|\\Sigma|^{1 / 2}} \\exp \\left\\{-\\frac{1}{2}(x-\\mu)^{T} \\Sigma^{-1}(x-\\mu)\\right\\}fμ,Σ​(x)=(2π)D/21​∣Σ∣1/21​exp{−21​(x−μ)TΣ−1(x−μ)} 假设海龟的vector是[103 45]，虽然这个点在已有的数据里并没有出现过，但是不可以认为它出现的概率为0，我们需要用已有的数据去估测海龟出现的可能性 你可以想象说这已有的79只水系宝可梦的data其实只是冰山一角，假定水系神奇宝贝的Defense和SP Defense是从一个Gaussian的distribution里面sample出来的，下图只是采样了79个点之后得到的分布，但是从高斯分布里采样出海龟这个点的几率并不是0，那从这79个已有的点，怎么找到那个Gaussian distribution函数呢？ 最大似然估计_参数估计 那接下来的问题就是怎么去找出这个Gaussian，只需要去估测出这个Gaussian的均值和协方差即可 估测和的方法就是极大似然估计法(Maximum Likelihood)，极大似然估计的思想是，找出最特殊的那对u和covariance，从它们共同决定的高斯函数中再次采样出79个点，使”得到的分布情况与当前已知79点的分布情况相同“这件事情发生的可能性最大===&gt;最大似然估计 根据sample样本, 求得使出现该样本组合可能性最大(所以是每一个点产生的概率相乘)的那组参数 ![最大似然估计](李宏毅机器学习-摘要/P6 classification\\最大似然估计.jpg) ![估计出参数](李宏毅机器学习-摘要/P6 classification\\估计出参数.jpg) 预测： ![预测](李宏毅机器学习-摘要/P6 classification\\预测.jpg) ===&gt; 训练结束：再把testing data上得到的结果可视化出来，即右下角的图，发现分的不是太好，正确率才是47%我们之前用的只是Defense和SP Defense这两个参数，在二维空间上得到的效果不太好，但实际上一开始就提到了宝可梦总共是有6个features的，也许在二维空间上它们是重叠在一起的，但是在六维空间上看它们也许会分得很好，每一个宝可梦都是六维空间中的一个点，于是我们的是一个6-dim的vector，则是一个6*6的matrix，发现得到的准确率也才64%，这个分类器表现得很糟糕，是否有办法将它改进的更好？ Modifying Model 其实之前使用的model是不常见的，你是不会经常看到给每一个Gaussian都有自己的mean和covariance，比如我们的class 1用的是u1和Σ1\\Sigma_1Σ1​，class 2用的是u2和Σ2\\Sigma_2Σ2​，比较常见的做法是，不同的class可以share同一个cocovariance matrix 其实variance是跟input的feature size的平方成正比的，所以当feature的数量很大的时候，Σ\\SigmaΣ大小的增长是可以非常快的，在这种情况下，给不同的Gaussian以不同的covariance matrix，会造成model的参数太多，而参数多会导致该model的variance过大，出现overfitting的现象，因此对不同的class使用同一个covariance matrix，可以有效减少参数 案例总结 回顾几率模型 machine learning可以概况为以下三个step ![threeSteps](李宏毅机器学习-摘要/P6 classification\\threeSteps.jpg) ![threeSteps笔记](李宏毅机器学习-摘要/P6 classification\\threeSteps笔记.jpg) ![概率分布](李宏毅机器学习-摘要/P6 classification\\概率分布.jpg) 选择的概率分布为经验之谈： 可以选择任意你喜欢的， 但是最后还是得看效果： 如果你选择的是简单的分布函数(参数比较少)，那你的bias就大，variance就小；如果你选择复杂的分布函数，那你的bias就小，variance就大，那你就可以用data set来判断一下，用什么样的Probability distribution作为model是比较好的 朴素贝叶斯： 这里每一个dimension的分布函数都是一维的Gaussian distribution，如果这样假设的话，等于是说，原来那多维度的Gaussian，它的covariance matrix变成是diagonal(对角的)，在不是对角线的地方，值都是0，这样就可以更加减少需要的参数量，就可以得到一个更简单的model 我们把上述这种方法叫做Naive Bayes Classifier(朴素贝叶斯分类法)，如果真的明确了所有的feature之间是相互独立的，是不相关的，使用朴素贝叶斯分类法的performance是会很好的，如果这个假设是不成立的，那么Naive bayes classfier的bias就会很大，它就不是一个好的classifier(朴素贝叶斯分类法本质就是减少参数) 当然这个例子里如果使用这样的model，得到的结果也不理想，因为各种feature之间的covariance还是必要的，比如战斗力和防御力它们之间是正相关的，covariance不能等于0 总之，寻找model总的原则是，尽量减少不必要的参数，但是必然的参数绝对不能少 那怎么去选择分布函数呢？有很多时候凭直觉就可以看出来，比如宝可梦有某个feature是binary的，它代表的是：是或不是，这个时候就不太可能是高斯分布了，而很有可能是伯努利分布(两点分布) Analysis Posterior Probability分析后置概率的表达式 上面的推导过程可能比较复杂，但是得到的最终结果还是比较好的：(当和共用一个时，经过化简相消z就变成了一个linear的function，x的系数是一个vector w，后面的一大串数字其实就是一个常数项b) P(C1∣x)=σ(w⋅x+b)P\\left(C_{1} \\mid x\\right)=\\sigma(w \\cdot x+b)P(C1​∣x)=σ(w⋅x+b)这个式子就解释了，当class 1和class 2共用的时候，它们之间的boundary会是linear的 7. P11Logistic Regression Three Steps of machine learning Step 1：function set 这里的function set就是Logistic Regression——逻辑回归 Step 2：Goodness of a function 现在我们有N笔Training data，每一笔data都要标注它是属于哪一个class 假设这些Training data是从我们定义的posterior Probability中产生的(后置概率，某种意义上就是概率密度函数)，而w和b就决定了这个posterior Probability，那我们就可以去计算某一组w和b去产生这N笔Training data的概率，利用极大似然估计的思想，最好的那组参数就是有最大可能性产生当前N笔Training data分布的和 似然函数只需要将每一个点产生的概率相乘即可，注意，这里假定是二元分类，class 2的概率为1减去class 1的概率. fw,b(x)f_{w, b}(x)fw,b​(x)为x为C1种类的概率, 则在二元分类中(1−fw,b(x))( 1 - f_{w, b}(x) )(1−fw,b​(x)) 由于 L(w,b)L(w, b)L(w,b) 是乘积项的形式, 为了方便计算, 我们将上式做个变换: (注意这边的L(w,b) 是最大似然函数, 而不是Loss function) w∗,b∗=arg⁡max⁡w,bL(w,b)=arg⁡min⁡w,b(−ln⁡L(w,b))−ln⁡L(w,b)=−ln⁡fw,b(x1)−ln⁡fw,b(x2)−ln⁡(1−fw,b(x3))−…\\begin{array}{l} \\qquad w^{*}, b^{*}=\\arg \\max _{w, b} L(w, b)=\\arg \\min _{w, b}(-\\ln L(w, b)) \\\\ -\\ln L(w, b)=-\\ln f_{w, b}\\left(x^{1}\\right) \\\\ \\quad-\\ln f_{w, b}\\left(x^{2}\\right) \\\\ \\quad-\\ln \\left(1-f_{w, b}\\left(x^{3}\\right)\\right) \\\\ \\quad-\\ldots \\end{array} w∗,b∗=argmaxw,b​L(w,b)=argminw,b​(−lnL(w,b))−lnL(w,b)=−lnfw,b​(x1)−lnfw,b​(x2)−ln(1−fw,b​(x3))−…​ 由于class 1和class 2的概率表达式不统一，上面的式子无法写成统一的形式, 为了统一格式, 这里将Logistic Regression里的所有Training data都打上0和1的标签, 即output y^=1\\hat{y}=1y^​=1 代表class 1,1,1, output y^=0\\hat{y}=0y^​=0 代表class 2,2,2, 于是上式进一步改写成: −ln⁡L(w,b)=−[y^1ln⁡fw,b(x1)+(1−y^1)ln⁡(1−fw,b(x1))]−[y^2ln⁡fw,b(x2)+(1−y^2)ln⁡(1−fw,b(x2))]−[y^3ln⁡fw,b(x3)+(1−y^3)ln⁡(1−fw,b(x3))]−…\\begin{aligned} -\\ln L(w, b)=&amp;-\\left[\\hat{y}^{1} \\ln f_{w, b}\\left(x^{1}\\right)+\\left(1-\\hat{y}^{1}\\right) \\ln \\left(1-f_{w, b}\\left(x^{1}\\right)\\right)\\right] \\\\ &amp;-\\left[\\hat{y}^{2} \\ln f_{w, b}\\left(x^{2}\\right)+\\left(1-\\hat{y}^{2}\\right) \\ln \\left(1-f_{w, b}\\left(x^{2}\\right)\\right)\\right] \\\\ &amp;-\\left[\\hat{y}^{3} \\ln f_{w, b}\\left(x^{3}\\right)+\\left(1-\\hat{y}^{3}\\right) \\ln \\left(1-f_{w, b}\\left(x^{3}\\right)\\right)\\right] \\\\ &amp;-\\ldots \\end{aligned} −lnL(w,b)=​−[y^​1lnfw,b​(x1)+(1−y^​1)ln(1−fw,b​(x1))]−[y^​2lnfw,b​(x2)+(1−y^​2)ln(1−fw,b​(x2))]−[y^​3lnfw,b​(x3)+(1−y^​3)ln(1−fw,b​(x3))]−…​ 现在已经有了统一的格式, 我们就可以把要minimize的对象写成一个summation的形式: −ln⁡L(w,b)=∑n−[y^nln⁡fw,b(xn)+(1−y^n)ln⁡(1−fw,b(xn))]-\\ln L(w, b)=\\sum_{n}-\\left[\\hat{y}^{n} \\ln f_{w, b}\\left(x^{n}\\right)+\\left(1-\\hat{y}^{n}\\right) \\ln \\left(1-f_{w, b}\\left(x^{n}\\right)\\right)\\right] −lnL(w,b)=n∑​−[y^​nlnfw,b​(xn)+(1−y^​n)ln(1−fw,b​(xn))] 这里表示第n个样本点，表示第n个样本点的class标签(1表示class 1,0表示class 2)，最终这个summation的形式，里面其实是两个Bernouli distribution(两点分布)的cross entropy(交叉熵) 交叉熵 假设有如上图所示的两个distribution p和q，它们的交叉商就是 H(p,q)=−∑xp(x)ln⁡(q(x)),H(p, q)=-\\sum_{x} p(x) \\ln (q(x)),H(p,q)=−∑x​p(x)ln(q(x)), 这也就是之前的 推导中在 −ln⁡L(w,b)-\\ln L(w, b)−lnL(w,b) 前加一个负号的原因 cross entropy交叉嫡的含义是表达这两个distribution有多接近, 如果p和q这两个distribution一模一样的话, 那 它们算出来的cross entropy就是0(详细解释在“信息论&quot;中), 而这里 f(xn)f\\left(x^{n}\\right)f(xn) 表示function的output, y^n\\hat{y}^{n}y^​n 表示预期 的 target, 因此交叉嫡实际上表达的是希望这个function的output和它的target越接近越好 总之, 我们要找的参数实际上就是: w∗,b∗=arg⁡max⁡w,bL(w,b)=arg⁡min⁡w,b(−ln⁡L(w,b)=∑n−[y^nln⁡fw,b(xn)+(1−y^n)ln⁡(1−fw,b(xn))]w^{*}, b^{*}=\\arg \\max _{w, b} L(w, b)=\\arg \\min _{w, b}\\left(-\\ln L(w, b)=\\sum_{n}-\\left[\\hat{y}^{n} \\ln f_{w, b}\\left(x^{n}\\right)+\\left(1-\\hat{y}^{n}\\right) \\ln \\left(1-f_{w, b}\\left(x^{n}\\right)\\right)\\right]\\right. w∗,b∗=argw,bmax​L(w,b)=argw,bmin​(−lnL(w,b)=n∑​−[y^​nlnfw,b​(xn)+(1−y^​n)ln(1−fw,b​(xn))] step 3：Find the best function 实际上就是去找到使loss function即交叉嫡之和最小的那组参数 w∗,b∗w^{*}, b^{*}w∗,b∗ 就行了， 这里用gradient descent的方法进 行运算就Ok 这里sigmoid function的微分可以直接作为公式记下来: ∂σ(z)∂z=σ(z)(1−σ(z)),\\frac{\\partial \\sigma(z)}{\\partial z}=\\sigma(z)(1-\\sigma(z)),∂z∂σ(z)​=σ(z)(1−σ(z)), sigmoid和它的微分的图像如 下: 先计算 −ln⁡L(w,b)=∑n−[y^nln⁡fw,b(xn)+(1−y^n)ln⁡(1−fw,b(xn))]-\\ln L(w, b)=\\sum_{n}-\\left[\\hat{y}^{n} \\ln f_{w, b}\\left(x^{n}\\right)+\\left(1-\\hat{y}^{n}\\right) \\ln \\left(1-f_{w, b}\\left(x^{n}\\right)\\right)\\right]−lnL(w,b)=∑n​−[y^​nlnfw,b​(xn)+(1−y^​n)ln(1−fw,b​(xn))] 对 wiw_{i}wi​ 的偏微分 ,,, 这里 y^n\\hat{y}^{n}y^​n 和 1−y^n1-\\hat{y}^{n}1−y^​n 是常数先不用管它，只需要分别求出 lnfw,b(xn)lnf_{w, b}\\left(x^{n}\\right)lnfw,b​(xn) 和 ln⁡(1−fw,b(xn))\\ln \\left(1-f_{w, b}\\left(x^{n}\\right)\\right)ln(1−fw,b​(xn)) 对 wiw_{i}wi​ 的偏微分即可，整体推导过程如下： 将得到的式子进行进一步化简，可得： 梯度: θ∗=arg⁡min⁡θL(θ)\\theta^{*}=\\arg \\min _{\\theta} L(\\theta) θ∗=argθmin​L(θ) L: loss function θ\\thetaθ : parameters(上标表示第几组参数, 下标表示这组参数中的第几个参数) 正好跟gradient descent的目标一致, 因此可以直接用gradient descent来找到最好的参数θ 梯度更新公式: [Δθ1Δθ2]=−η[uv]=&gt;[θ1θ2]=[ab]−η[uv]=[ab]−η[∂L(a,b)∂θ1∂L(a,b)∂θz]\\left[\\begin{array}{l}\\Delta \\theta_{1} \\\\ \\Delta \\theta_{2}\\end{array}\\right]=-\\eta\\left[\\begin{array}{l}u \\\\ v\\end{array}\\right]=&gt;\\left[\\begin{array}{l}\\theta_{1} \\\\ \\theta_{2}\\end{array}\\right]=\\left[\\begin{array}{l}a \\\\ b\\end{array}\\right]-\\eta\\left[\\begin{array}{l}u \\\\ v\\end{array}\\right]=\\left[\\begin{array}{l}a \\\\ b\\end{array}\\right]-\\eta\\left[\\begin{array}{l}\\frac{\\partial L(a, b)}{\\partial \\theta_{1}} \\\\ \\frac{\\partial L(a, b)}{\\partial \\theta_{z}}\\end{array}\\right][Δθ1​Δθ2​​]=−η[uv​]=&gt;[θ1​θ2​​]=[ab​]−η[uv​]=[ab​]−η[∂θ1​∂L(a,b)​∂θz​∂L(a,b)​​] or θi=θi−1−η∇L(θi−1)\\theta^{i}=\\theta^{i-1}-\\eta \\nabla L\\left(\\theta^{i-1}\\right)θi=θi−1−η∇L(θi−1) 我们发现最终的结果竟然异常的简洁，gradient descent每次update只需要做： wi=wi−η(∑n−(y^n−fw,b(xn))xin)w_{i}=w_{i}-\\eta (\\sum_{n}-\\left(\\hat{y}^{n}-f_{w, b}\\left(x^{n}\\right)\\right) x_{i}^{n})wi​=wi​−η(∑n​−(y^​n−fw,b​(xn))xin​) 那这个式子到底代表着什么意思呢? 现在你的update取决于三件事: learning rate, 是你自己设定的 ⋅xi,\\cdot x_{i},⋅xi​, 来自于data y^n−fw,b(xn),\\hat{y}^{n}-f_{w, b}\\left(x^{n}\\right),y^​n−fw,b​(xn), 代表function的output跟理想target的差距有多大, 如果离目标越远, update的步伐就要越 大 Logistic Regression V.s. Linear Regression compare in step1 Logistic Regression是把每一个feature xix_{i}xi​ 加权求和, 加上bias, 再通过sigmoid function, 当做function的 output 因为Logistic Regression的output是通过sigmoid function产生的, 因此一定是介于0 1之间; 而linear Regression的output并没有通过sigmoid function, 所以它可以是任何值 compare in step2 在Logistic Regression中，我们定义的loss function, 即要去minimize的对象, 是所有example(样本点)的 output (f(xn))\\left(f\\left(x^{n}\\right)\\right)(f(xn)) )和实际target (y^n)\\left(\\hat{y}^{n}\\right)(y^​n) 在Bernoulli distribution(两点分布)下的cross entropy(交叉嫡)总和 交叉嫡的描述：这里把 f(xn)f\\left(x^{n}\\right)f(xn) 和 y^n\\hat{y}^{n}y^​n 各自看做是一个Bernoulli distribution(两点分布)，那它们的cross entropy l(f(xn),y^n)=−[y^nln⁡f(xn)+(1−y^n)ln⁡(1−f(xn))]l\\left(f\\left(x^{n}\\right), \\hat{y}^{n}\\right)=-\\left[\\hat{y}^{n} \\ln f\\left(x^{n}\\right)+\\left(1-\\hat{y}^{n}\\right) \\ln \\left(1-f\\left(x^{n}\\right)\\right)\\right]l(f(xn),y^​n)=−[y^​nlnf(xn)+(1−y^​n)ln(1−f(xn))] 之和, 就是我们要去minimize的对象, 直观来讲, 就 是希望function的output f(xn)f\\left(x^{n}\\right)f(xn) 和它的target y^n\\hat{y}^{n}y^​n 越接近越好 注：这里的“看做&quot;只是为了方便理解和计算，并不是真的做出它们是两点分布的假设 而在linear Regression中, loss function的定义相对比较简单, 就是单纯的function的output (f(xn))\\left(f\\left(x^{n}\\right)\\right)(f(xn)) 和实际 target⁡(y^n)\\operatorname{target}\\left(\\hat{y}^{n}\\right)target(y^​n) 在数值上的平方和的均值 这里可能会有一个疑惑, 为什么Logistic Regression的loss function不能像linear Regression一样用square error 来表示呢? 后面会有进一步的解释 compare in step3 神奇的是，Logistic Regression和linear Regression的update的方式是一模一样的，唯一不一样的是，Logistic Regression的target 和output 都必须是在0和1之间的，而linear Regression的target和output的范围可以是任意值 Logistic Regression + Square error？ 先说结论, 在分类问题中Square error不合适, cross entropy适合于分类问题 Square error求微分情况: 现在会遇到一个问题：如果第n个点的目标target是class 1,1,1, 则 y^n=1,\\hat{y}^{n}=1,y^​n=1, 此时如果function的output fw,b(xn)=1f_{w, b}\\left(x^{n}\\right)=1fw,b​(xn)=1 的话, 说明现在离target很接近了, fw,b(x)−y^丶xˉf_{w, b}(x)-\\hat{y} 丶 \\bar{x}fw,b​(x)−y^​丶xˉ 一项是0, 于是得到的微分 ∂L∂wi\\frac{\\partial L}{\\partial w_{i}}∂wi​∂L​ 会变成0，这件事情是很合理的; 但是当function的output fw,b(xn)=0f_{w, b}\\left(x^{n}\\right)=0fw,b​(xn)=0 的时候, 说明离target还很遥远, 但是由于在step3中求出来的update表达 式中有一个 fw,b(xn),f_{w, b}\\left(x^{n}\\right),fw,b​(xn), 因此这个时候也会导致得到的微分 ∂L∂wi\\frac{\\partial L}{\\partial w_{i}}∂wi​∂L​ 变成0==&gt;简而言之, 微分的结果不便于下一步的gradient descent 如果举class 2的例子，得到的结果与class 1是一样的 如果我们把参数的变化对total loss作图的话, loss function选择cross entropy或square error, 参数的变化跟 loss的变化情况可视化出来如下所示：(黑色的是cross entropy, 红色的是square error) 假设中心点就是距离目标很近的地方，如果是cross entropy的话，距离目标越远，微分值就越大，参数update的时候变化量就越大，迈出去的步伐也就越大 但当你选择square error的时候，过程就会很卡，因为距离目标远的时候，微分也是非常小的，移动的速度是非常慢的，我们之前提到过，实际操作的时候，当gradient接近于0的时候，其实就很有可能会停下来，因此使用square error很有可能在一开始的时候就卡住不动了，而且这里也不能随意地增大learning rate，因为在做gradient descent的时候，你的gradient接近于0，有可能离target很近也有可能很远，因此不知道learning rate应该设大还是设小 综上，尽管square error可以使用，但是会出现update十分缓慢的现象，而使用cross entropy可以让你的Training更顺利 Discriminative v.s. Generative same model but different currency Logistic Regression的方法，我们把它称之为discriminative的方法；而我们用Gaussian来描述posterior Probability这件事，我们称之为Generative的方法, 实际上它们用的model(function set)是一模一样的, 都是 P(C1∣x)=σ(w⋅x+b),P\\left(C_{1} \\mid x\\right)=\\sigma(w \\cdot x+b),P(C1​∣x)=σ(w⋅x+b), 如果是用Logistic Regression 的话, 可以用gradient descent的方法直接去把b和W找出来; 如果是用Generative model的话，我们要先去算 u1,u2,Σ−1u_{1}, u_{2}, \\Sigma^{-1} \\quadu1​,u2​,Σ−1 然后算出b和w 区别在于: 是否有假设? 你会发现用这两种方法得到的b和w是不同的，尽管我们的function set是同一个，但是由于做了不同的假设，最终从同样的Training data里找出来的参数会是不一样的 在Logistic Regression里面，我们没有做任何实质性的假设，没有对Probability distribution有任何的描述，我们就是单纯地去找b和w(推导过程中的假设只是便于理解和计算，对实际结果没有影响) 而在Generative model里面，我们对Probability distribution是有实质性的假设的，之前我们假设的是Gaussian(高斯分布)，甚至假设在相互独立的前提下是否可以是naive bayes(朴素贝叶斯)，根据这些假设我们才找到最终的b和w 例子: https://sakura-gh.github.io/ML-notes/ML-notes-html/7_Logistic-Regression.html 所以，Generative model和discriminative model的差别就在于，Generative的model它有做了某些假设，假设你的data来自于某个概率模型；而Discriminative的model是完全不作任何假设的, 完全根据数据说话 Generative model做的事情就是脑补，它会自己去想象一些事情，于是会做出一个和我们人类直觉想法不太一样的判断结果，就像toy example里，我们做了naive bayes这样一个假设(事实上我们并不知道这两个feature是否相互独立)，于是Naive bayes会在class 2里并没有出现过两个feature都是1的样本点的前提下，自己去脑补有这样的点 通常脑补不是一件好的事情，因为你给你的data强加了一些它并没有告诉你的属性，但是在data很少的情况下，脑补也是有用的，discriminative model并不是在所有的情况下都可以赢过Generative model，discriminative model是十分依赖于data的，当data数量不足或是data本身的label就有一些问题，那Generative model做一些脑补和假设，反而可以把data的不足或是有问题部分的影响给降到最低 Conclusion 对于分类的问题(主要是二元分类)，我们一般有两种方法去处理问题，一种是Generative的方法，另一种是Discriminative的方法，注意到分类问题的model都是从贝叶斯方程出发的，即 P(Ci∣x)=P(Ci)P(x∣Ci)∑j=1nP(Cj)P(x∣Cj)(1)=σ(z)=11+e−z=11+e−(b+∑kwkxk)\\begin{aligned} P\\left(C_{i} \\mid x\\right)=&amp; \\frac{P\\left(C_{i}\\right) P\\left(x \\mid C_{i}\\right)}{\\sum_{j=1}^{n} P\\left(C_{j}\\right) P\\left(x \\mid C_{j}\\right)}(1) \\\\ &amp;=\\sigma(z)=\\frac{1}{1+e^{-z}}=\\frac{1}{1+e^{-\\left(b+\\sum_{k} w_{k} x_{k}\\right)}} \\end{aligned}P(Ci​∣x)=​∑j=1n​P(Cj​)P(x∣Cj​)P(Ci​)P(x∣Ci​)​(1)=σ(z)=1+e−z1​=1+e−(b+∑k​wk​xk​)1​​ Generative model的好处是，它对data的依赖并没有像discriminative model那么严重，在data数量少或者data本身就存在noise的情况下受到的影响会更小，而它还可以做到Prior部分与class-dependent部分分开处理，如果可以借助其他方式提高Prior model的准确率，对整一个model是有所帮助的(比如前面提到的语音辨识) 而Discriminative model的好处是，在data充足的情况下，它训练出来的model的准确率一般是比Generative model要来的高的 Multi-class Classification softmax softmax的意思是对最大值做强化，因为在做第一步的时候，对取exponential会使大的值和小的值之间的差距被拉得更开，也就是强化大的值 Limitation of Logistic Regression Logistic Regression其实有很强的限制，给出下图的例子中的Training data，想要用Logistic Regression对它进行分类，其实是做不到的, 如异或 Feature Transformation 如果坚持要用Logistic Regression的话，有一招叫做Feature Transformation，原来的feature分布不好划分，那我们可以将之转化以后，找一个比较好的feature space，让Logistic Regression能够处理 但麻烦的是，我们并不知道怎么做feature Transformation，如果在这上面花费太多的时间就得不偿失了，于是我们会希望这个Transformation是机器自己产生的，怎么让机器自己产生呢？我们可以让很多Logistic Regression cascade(连接)起来 我们让一个input x的两个feature x1,x2x_{1}, x_{2}x1​,x2​ 经过两个Logistic Regression的transform, 得到新的feature x1′,x2′,x_{1}^{\\prime}, x_{2}^{\\prime},x1′​,x2′​, 在 这个新的feature space上, class 1和class 2是可以用一条直线分开的, 那么最后只要再接另外一个Logistic Regression的model(对它来说, x1′,x2′x_{1}^{\\prime}, x_{2}^{\\prime}x1′​,x2′​ 才是每一个样本点的&quot;feature&quot;, 而不是原先的 x1,x2),\\left.x_{1}, x_{2}\\right),x1​,x2​), 它根据新的 feature, 就可以把class 1和class 2分开 Powerful Cascading Logistic Regression 通过上面的例子，我们发现，多个Logistic Regression连接起来会产生powerful的效果，我们把每一个Logistic Regression叫做一个neuron(神经元)，把这些Logistic Regression串起来所形成的network，就叫做Neural Network，就是类神经网路，这个东西就是Deep Learning！ 8. P12 Brief Introduction of Deep Learning Ups and downs of Deep Learning 1958：Perceptron(linear model)，感知机的提出 和Logistic Regression类似，只是少了sigmoid的部分 1969：Perceptron has limitation，from MIT 1980s：Multi-layer Perceptron，多层感知机 和今天的DNN很像 1986：Backpropagation，反向传播 Hinton propose的Backpropagation 存在problem：通常超过3个layer的neural network，就train不出好的结果 、1989: 1 hidden layer is “good enough”，why deep？ 有人提出一个理论：只要neural network有一个hidden layer，它就可以model出任何的function，所以根本没有必要叠加很多个hidden layer，所以Multi-layer Perceptron的方法又坏掉了，这段时间Multi-layer Perceptron这个东西是受到抵制的 2006：RBM initialization(breakthrough)：Restricted Boltzmann Machine，受限玻尔兹曼机 Deep learning -&gt; another Multi-layer Perceptron ？在当时看来，它们的不同之处在于在做gradient descent的时候选取初始值的方法如果是用RBM，那就是Deep learning；如果没有用RBM，就是传统的Multi-layer Perceptron 那实际上呢，RBM用的不是neural network base的方法，而是graphical model，后来大家试验得多了发现RBM并没有什么太大的帮助，因此现在基本上没有人使用RBM做initialization了 RBM最大的贡献是，它让大家重新对Deep learning这个model有了兴趣(石头汤的故事) 2009：GPU加速的发现 2011：start to be popular in speech recognition，语音识别领域 2012：win ILSVRC image competition，Deep learning开始在图像领域流行开来 实际上，Deep learning跟machine learning一样，也是“大象放进冰箱”的三个步骤： 在Deep learning的step1里define的那个function，就是neural network Neural Network concept 把多个Logistic Regression前后connect在一起，然后把一个Logistic Regression称之为neuron，整个称之为neural network 我们可以用不同的方法连接这些neuron，就可以得到不同的structure，neural network里的每一个Logistic Regression都有自己的weight和bias，这些weight和bias集合起来，就是这个network的parameter，我们用来描述 Network Structure 如果一个neural network的参数weight和bias已知的话，它就是一个function，它的input是一个vector，output是另一个vector，这个vector里面放的是样本点的feature，vector的dimension就是feature的个数 input的地方，叫做input layer，输入层(严格来说input layer其实不是一个layer，它跟其他layer不一样，不是由neuron所组成的) output的地方，叫做output layer，输出层 其余的地方，叫做hidden layer，隐藏层 激活函数: 每一个neuron里面的sigmoid function，在Deep Learning中被称为activation function(激励函数)，事实上它不见得一定是sigmoid function，还可以是其他function(sigmoid function是从Logistic Regression迁移过来的，现在已经较少在Deep learning里使用了) ★.network structure+neuron该如何连接在一起的含义: 其实是define了一个function set(model) Feedforward network ▲.全连接: 因为layer和layer之间，所有的neuron都是两两连接，所以它叫Fully connected的network；因为现在传递的方向是从layer 1-&gt;2-&gt;3，由后往前传，所以它叫做Feedforward network Output Layer 我们可以把hidden layers这部分，看做是一个feature extractor(特征提取器)，这个feature extractor就replace了我们之前手动做feature engineering，feature transformation这些事情，经过这个feature extractor得到的就可以被当作一组新的feature output layer做的事情，其实就是把它当做一个Multi-class classifier，它是拿经过feature extractor转换后的那一组比较好的feature(能够被很好地separate)进行分类的，由于我们把output layer看做是一个Multi-class classifier，所以我们会在最后一个layer加上softmax 整个手写体识别分析: 我们唯一需要的就是一个function，这个function的input是一个256的vector，output是一个10维的vector，这个function就是neural network(这里我们用简单的Feedforward network) input固定为256维(图片)，output固定为10维的feedforward neural network，实际上这个network structure就已经确定了一个function set(model)的形状，在这个function set里的每一个function都可以拿来做手写数字识别，接下来我们要做的事情是用gradient descent去计算出一组参数，挑一个最适合拿来做手写数字识别的function 注：input、output的dimension，加上network structure，就可以确定一个model的形状，前两个是容易知道的，而决定这个network的structure则是整个Deep Learning中最为关键的步骤 所以这里很重要的一件事情是，我们要对network structure进行design，之前在做Logistic Regression或者是linear Regression的时候，我们对model的structure是没有什么好设计的，但是对neural network来说，我们现在已知的constraint只有input是256维，output是10维，而中间要有几个hidden layer，每个layer要有几个neuron，都是需要我们自己去设计的，它们近乎是决定了function set长什么样子 如果你的network structure设计的很差，这个function set里面根本就没有好的function，那就会像大海捞针一样，结果针并不在海里(滑稽 Step 1：Neural Network intput输入为16*16的图片(256维) --&gt;经过神经网络(函数) --&gt; 输出10维的vector --&gt; 经过softmax函数选出可能性最大的结果输出-output Step 2：Goodness of function input这张image的256个pixel，通过这个neural network之后，会得到一个output，称之为y；而从这张image的label中转化而来的target，称之为，有了output 和target 之后，要做的事情是计算它们之间的cross entropy(交叉熵)，这个做法跟我们之前做Multi-class classification的时候是一模一样的—&gt; 分类问题多使用交叉熵 Cross Entropy :l(y,y^)=−∑i=110y^i: l(y, \\hat{y})=-\\sum_{i=1}^{10} \\hat{y}_{i}:l(y,y^​)=−∑i=110​y^​i​lnyi_{i}i​ Step 3：Pick the best function 接下来就去调整参数，让这个cross entropy越小越好，当然整个training data里面不会只有一笔data，你需要把所有data的cross entropy都sum起来, 得到一个total loss L=∑n=1NlnL=\\sum_{n=1}^{N} l^{n}L=∑n=1N​ln （所有case的Cross Entropy ）, 得到loss function之后你要做的事情是找一组network的parameters：θ∗\\theta^{*}θ∗。它可以minimize这个total loss，这组parameter对应的function就是我们最终训练好的model 老规矩：我们使用Gradient Descent来优化total loss来获得model。实际上在deep learning里面用gradient descent，跟在linear regression里面使用完全没有什么差别，只是function和parameter变得更复杂了而已，其他事情都是一模一样的。 但是相比在liner model中求导还是比较轻松的， 在network中的function式子到底是长什么样子呢？==&gt; 需要用到反向传播—&gt;但是人工计算是比较复杂的, 因此有了pytorch, tensorflow等微分toolkit可以来计算Backpropagation Design network structure V.s. Feature Engineering(网络结构设计 vs 特征工程) deep learning: 通过network 找到一组合适的param来训练, 让机器自动学会如何提取特征==&gt;获得model 传统方法: 通过古圣先贤的先验知识对信息进行特征提取和分析==&gt;获得model 其实network structure的design是一件蛮难的事情，我们到底要怎么决定layer的数目和每一个layer的neuron的数目呢？其实这个只能够凭着经验和直觉、多方面的尝试，有时候甚至会需要一些domain knowledge(专业领域的知识)，从非deep learning的方法到deep learning的方法，并不是说machine learning比较简单，而是我们把一个问题转化成了另一个问题 原先非deep learning的model，要得到一个好的结果，往往需要做feature engineering(特征工程)，也就是做feature transform，然后找一组好的feature；一开始学习deep learning的时候，好像会觉得deep learning的layers之间也是在做feature transform，但实际上在做deep learning的时候，往往不需要一个好的feature ，比如说在做影像辨识的时候，你可以把所有的pixel直接丢进去，但是在过去做图像识别，你是需要对图像抽取出一些人定的feature出来的，这件事情就是feature transform，但是有了deep learning之后，你完全可以直接丢pixel进去硬做 但是，今天deep learning制造了一个新的问题，它所制造的问题就是，你需要去design network的structure，所以你的问题从本来的如何抽取feature==&gt;(转化成)怎么design network structure，所以deep learning是不是真的好用，取决于你觉得解决哪一个问题比较容易(如，以前做音频识别需要知道DFT些信号处理知识和方法，现在完全可以交给机器，让其自己学会DFT) 如果是影响辨识或者是语音辨识的话，design network structure可能比feature engineering要来的容易，因为，虽然我们人都会看、会听，但是这件事情，它太过潜意识了，它离我们意识的层次太远，我们无法意识到，我们到底是怎么做语音辨识这件事情，所以对人来说，你要抽一组好的feature，让机器可以很方便地用linear的方法做语音辨识，其实是很难的，因为人根本就不知道好的feature到底长什么样子；所以还不如design一个network structure，或者是尝试各种network structure，让machine自己去找出好的feature，这件事情反而变得比较容易，对影像来说也是一样的 有这么一个说法：deep learning在NLP上面的performance并没有那么好。语音辨识和影像辨识这两个领域是最早开始用deep learning的，一用下去进步量就非常地惊人，比如错误率一下子就降低了20%这样，但是在NLP上，它的进步量似乎并没有那么惊人，甚至有很多做NLP的人，现在认为说deep learning不见得那么work，这个原因可能是，人在做NLP这件事情的时候，由于人在文字处理上是比较强的，比如叫你设计一个rule去detect一篇document是正面的情绪还是负面的情绪，你完全可以列表，列出一些正面情绪和负面情绪的词汇，然后看这个document里面正面情绪的词汇出现的百分比是多少，你可能就可以得到一个不错的结果。所以NLP这个task，对人来说是比较容易设计rule的，你设计的那些ad-hoc(特别的)的rule，往往可以得到一个还不错的结果，这就是为什么deep learning相较于NLP传统的方法，觉得没有像其他领域一样进步得那么显著(但还是有一些进步的)===&gt;简言之, 这个语言问题较为容易研究, 以及前人传统方法研究已经非常深入, 效果也较好, 因此机器学习并没有太多的提升 长久而言，可能文字处理中会有一些隐藏的资讯是人自己也不知道的，所以让机器自己去学这件事情，还是可以占到一些优势，只是眼下它跟传统方法的差异看起来并没有那么的惊人，但还是有进步的 P15Why Deep- Q:参数变多,是变宽还是变深呢? 是不是暴力的方法呢? A: 论文比较相同参数, 深度效果好于宽度; DNN结构一个很大的优势是，Modularization(模块化)，它用的是结构化的架构 Modularization 就像写程序一样，shallow network实际上就是把所有的程序都写在了同一个main函数中，所以它去检测不同的class使用的方法是相互独立的；而deep network则是把整个任务分为了一个个小任务，每个小任务又可以不断细分下去，以形成modularization，就像下图一样 在DNN的架构中，实际上每一层layer里的neuron都像是在解决同一个级别的任务，它们的output作为下一层layer处理更高级别任务的数据来源，低层layer里的neuron做的是对不同小特征的检测，高层layer里的neuron则根据需要挑选低层neuron所抽取出来的不同小特征，去检测一个范围更大的特征；neuron就像是一个个classifier ，后面的classifier共享前面classifier的参数 这样做的好处是，低层的neuron输出的信息可以被高层不同的neuron重复使用，而并不需要像shallow network一样，每次在用到的时候都要重新去检测一遍，因此大大降低了程序的复杂度 理解效果：模组化： 如分类长发的女孩、长头发的男孩、短发的女孩、短发男孩。 ​ 如果按照shallow network的想法，我们分别独立地train四个classifier(其实就相当于训练四个独立的model)，然后就可以解决这个分类的问题。但是显而易见的是长头发的男生样本会非常少，没有太多的training data，所以，你train出来的classifier就比较weak，去detect长头发男生的performance就比较差 ![模组化](李宏毅机器学习-摘要/P12\\模组化.jpg 但其实我们的input并不是没有关联的，长头发的男生和长头发的女生都有一个共同的特征，就是长头发，因此如果我们分别独立地训练四个model作为分类器，实际上就是忽视了这个共同特征，也就是没有高效地用到data提供的全部信息，这恰恰是shallow network的弊端 而利用modularization的思想，使用deep network的架构，我们可以训练一个model作为分类器就可以完成所有的任务，我们可以把整个任务分为两个子任务： Classifier1：检测是男生或女生 Classifier2：检测是长头发或短头发 虽然长头发的男生data很少，但长头发的人的data就很多，经过前面几层layer的特征抽取，就可以头发的data全部都丢给Classifier2，把男生或女生的data全部都丢给Classifier1，这样就真正做到了充分、高效地利用数据，最终的Classifier再根据Classifier1和Classifier2提供的信息给出四类人的分类结果 你会发现，经过层层layer的任务分解，其实每一个Classifier要做的事情都是比较简单的，又因为这种分层的、模组化的方式充分利用了data，并提高了信息利用的效率，所以只要用比较少的training data就可以把结果train好 deep -&gt; modularization 做modularization的好处是把原来比较复杂的问题变得简单，比如原来的任务是检测一个长头发的女生，但现在你的任务是检测长头发和检测性别，而当检测对象变简单的时候，就算training data没有那么多，我们也可以把这个task做好，并且所有的classifier都用同一组参数检测子特征，提高了参数使用效率，这就是modularization、这就是模块化的精神 由于deep learning的deep就是在做modularization这件事，所以它需要的training data反而是比较少的，这可能会跟你的认知相反，AI=big data+deep learning，但deep learning其实是为了解决less data的问题才提出的 每一个neuron其实就是一个basic的classifier： 第一层neuron，它是一个最basic的classifier，检测的是颜色、线条这样的小特征 第二层neuron是比较复杂的classifier，它用第一层basic的classifier的output当作input，也就是把第一层的classifier当作module，利用第一层得到的小特征分类出不同样式的花纹 而第三层的neuron又把第二层的neuron当作它module，利用第二层得到的特征分类出蜂窝、轮胎、人 以此类推 这边要强调的是，在做deep learning的时候，怎么做模块化这件事情是machine自动学到的，也就是说，第一层要检测什么特征、第二层要检测什么特征…这些都不是人为指定的，人只有定好有几层layer、每层layer有几个neuron，剩下的事情都是machine自己学到的 传统的机器学习算法，是人为地根据domain knowledge指定特征来进行提取，这种指定的提取方式，甚至是提取到的特征，也许并不是实际最优的，所以它的识别成功率并没有那么高；但是如果提取什么特征、怎么提取这件事让机器自己去学，它所提取的就会是那个最优解，因此识别成功率普遍会比人为指定要来的高 Conclusion Deep总结： 考虑input之间的内在关联，所有的class用同一个model来做分类 modularization思想，复杂问题简单化，把检测复杂特征的大任务分割成检测简单特征的小任务 所有的classifier使用同一组参数的子特征检测器，共享检测到的子特征 不同的classifier会share部分的参数和data，效率高 联系logic circuit和剪纸画的例子 多层hidden layer对complex问题的处理上比较有优势 9. P13Backpropagation Backpropagation是神经网络中用来做gradient descent的方法， 目的是使优化函数尽可能得变成我们想要的， 假设我们现在要处理的是分类任务，loss function为交叉熵， total loss为L(θ)=∑n=1Nln(θ)L(\\theta)=\\sum_{n=1}^{N} l^{n}(\\theta)L(θ)=∑n=1N​ln(θ) 我们把training data里任意一个样本点 xnx^{n}xn 代到neural network里面, 它会output一个 yn,y^{n},yn, 我们把这个output跟样 本点本身的label标注的target y^n\\hat{y}^{n}y^​n 作cross entropy, 这个交叉嫡定义了output yny^{n}yn 与target y^n\\hat{y}^{n}y^​n 之间的距离 ln(θ)l^{n}(\\theta)ln(θ)。 如果cross entropy比较大的话, 说明output和target之间距离很远, 这个network的parameter的loss是比较大 的, 反之则说明这组parameter是比较好的， 然后总和所有training data的cross entropy ln(θ),l^{n}(\\theta),ln(θ), 得到total loss L(θ),L(\\theta),L(θ), 这就是我们的loss function, 用这个 L(θ)L(\\theta)L(θ) 对某一个参数w做偏微分, 表达式如下: ∂L(θ)∂w=∑n=1N∂ln(θ)∂w\\frac{\\partial L(\\theta)}{\\partial w}=\\sum_{n=1}^{N} \\frac{\\partial l^{n}(\\theta)}{\\partial w} ∂w∂L(θ)​=n=1∑N​∂w∂ln(θ)​ 这个表达式告诉我们, 只需要考虑如何计算对某一笔data的 ∂ln(θ)∂w,\\frac{\\partial l^{n}(\\theta)}{\\partial w},∂w∂ln(θ)​, 再将所有training data的cross entropy对参数 w的偏微分累计求和, 就可以把total loss对某一个参数w的偏微分给计算出来。 我们逐一分析，我们先考虑某一个neuron, 先拿出上图中被红色三角形圈住的neuron, 假设只有两个input x1,x2,x_{1}, x_{2},x1​,x2​, 通过这个 neuron, 我们先得到 z=b+w1x1+w2x2,z=b+w_{1} x_{1}+w_{2} x_{2},z=b+w1​x1​+w2​x2​, 然后经过activation function从这个neuron中output出来, 作为后 续neuron的input, 再经过了非常非常多的事情以后, 会得到最终的output y1,y2y_{1}, y_{2}y1​,y2​ 现在的问题是这样： ∂l∂w\\frac{\\partial l}{\\partial w}∂w∂l​ 该怎么算? 按照chain rule, 可以把它拆分成两项, ∂l∂w=∂z∂w∂l∂z,\\frac{\\partial l}{\\partial w}=\\frac{\\partial z}{\\partial w} \\frac{\\partial l}{\\partial z},∂w∂l​=∂w∂z​∂z∂l​, 这两项分别去把它计算 出来。前面这一项是比较简单的, 后面这一项是比较复杂的 计算前面这一项 ∂z∂w\\frac{\\partial z}{\\partial w}∂w∂z​ 的这个process, 我们称之为Forward pass; 而计算后面这项 ∂l∂z\\frac{\\partial l}{\\partial z}∂z∂l​ 的process, 我们称之为 Backward pass Forward pass 先考虑 ∂z∂w\\frac{\\partial z}{\\partial w}∂w∂z​ 这一项, 完全可以秒算出来, ∂z∂w1=x1,∂z∂w2=x2\\frac{\\partial z}{\\partial w_{1}}=x_{1}, \\frac{\\partial z}{\\partial w_{2}}=x_{2}∂w1​∂z​=x1​,∂w2​∂z​=x2​ 它的规律是这样的：求 ∂z∂w,\\frac{\\partial z}{\\partial w},∂w∂z​, 就是看w前面连接的input是什么, 那微分后的 ∂z∂w\\frac{\\partial z}{\\partial w}∂w∂z​ 值就是什么，因此只要计算出 neural network里面每一个neuron的output就可以知道任意的z对W的偏微分 比如input layer作为neuron的输入时，前面连接的是，所以微分值就是；前面连接的是，所以微分值就是 比如hidden layer作为neuron的输入时，那该neuron的input就是前一层neuron的output，于是的值就是前一层的z经过activation function之后输出的值(下图中的数据是假定activation function为sigmoid function得到的) Backward pass 再考虑 ∂l∂z\\frac{\\partial l}{\\partial z}∂z∂l​ 这一项, 它是比较复杂的, 这里我们依旧假设activation function是sigmoid function 公式推导 我们的z通过activation function得到a, 这个neuron的output是 a=σ(z),a=\\sigma(z),a=σ(z), 接下来这个a会乘上某一个weight w3w_{3}w3​ 再加上其它一大堆的value得到 z′,z^{\\prime},z′, 它是下一个neuron activation function的input, 然后a又会乘上另一个 weight w4,w_{4},w4​, 再加上其它一雄value得到 z′′,z^{\\prime \\prime},z′′, 后面还会发生很多很多其他事情, 不过这里我们就只先考虑下一步会 发生什公事情: ∂l∂z=∂a∂z∂l∂a\\frac{\\partial l}{\\partial z}=\\frac{\\partial a}{\\partial z} \\frac{\\partial l}{\\partial a} ∂z∂l​=∂z∂a​∂a∂l​ 这里的 ∂a∂z\\frac{\\partial a}{\\partial z}∂z∂a​ 实际上就是1. activation function的微分(在这里就是sigmoid function的微分)，接下来的问题是 ∂l∂a\\frac{\\partial l}{\\partial a}∂a∂l​ 应该长 什么样子呢? a会影响 z′z^{\\prime}z′ 和 z′′,z^{\\prime \\prime},z′′, 而 z′z^{\\prime}z′ 和 z′′z^{\\prime \\prime}z′′ 会影响 l,l,l, 所以通过chain rule可以得到 ∂l∂a=∂z′∂a∂l∂z′+∂z′′∂a∂l∂z′′\\frac{\\partial l}{\\partial a}=\\frac{\\partial z^{\\prime}}{\\partial a} \\frac{\\partial l}{\\partial z^{\\prime}}+\\frac{\\partial z^{\\prime \\prime}}{\\partial a} \\frac{\\partial l}{\\partial z^{\\prime \\prime}} ∂a∂l​=∂a∂z′​∂z′∂l​+∂a∂z′′​∂z′′∂l​ 这里的 ∂z′∂a=w3,∂z′′∂a=w4,\\frac{\\partial z^{\\prime}}{\\partial a}=w_{3}, \\frac{\\partial z^{\\prime \\prime}}{\\partial a}=w_{4},∂a∂z′​=w3​,∂a∂z′′​=w4​, 那 ∂l∂z′\\frac{\\partial l}{\\partial z^{\\prime}}∂z′∂l​ 和 ∂l∂z′′\\frac{\\partial l}{\\partial z^{\\prime \\prime}}∂z′′∂l​ 又该怎么算呢? 这里先假设我们已经通过某种方法把 ∂l∂z′\\frac{\\partial l}{\\partial z^{\\prime}}∂z′∂l​ 和 ∂l∂z′′\\frac{\\partial l}{\\partial z^{\\prime \\prime}}∂z′′∂l​ 这两项给算出来了，然后回过头去就可以把 ∂l∂z\\frac{\\partial l}{\\partial z}∂z∂l​ 给轻易地算出来 ==&gt; 上面是个递归的过程，因此需要从output计算 ∂l∂a\\frac{\\partial l}{\\partial a}∂a∂l​ ∂l∂z=∂a∂z∂l∂a=σ′(z)[w3∂l∂z′+w4∂l∂z′′]\\frac{\\partial l}{\\partial z}=\\frac{\\partial a}{\\partial z} \\frac{\\partial l}{\\partial a}=\\sigma^{\\prime}(z)\\left[w_{3} \\frac{\\partial l}{\\partial z^{\\prime}}+w_{4} \\frac{\\partial l}{\\partial z^{\\prime \\prime}}\\right] ∂z∂l​=∂z∂a​∂a∂l​=σ′(z)[w3​∂z′∂l​+w4​∂z′′∂l​] case 1: Output Layer 假设蓝色的这个neuron已经是hidden layer的最后一层了, 也就是说连接在 z′z^{\\prime}z′ 和 z′′z^{\\prime \\prime}z′′ 后的这两个红色的neuron已经 是output layer, 它的output就已经是整个network的output了, 这个时候计算就比较简单 ∂l∂z′=∂y1∂z′∂l∂y1\\frac{\\partial l}{\\partial z^{\\prime}}=\\frac{\\partial y_{1}}{\\partial z^{\\prime}} \\frac{\\partial l}{\\partial y_{1}} ∂z′∂l​=∂z′∂y1​​∂y1​∂l​ 其中 ∂y1∂z′\\frac{\\partial y_{1}}{\\partial z^{\\prime}}∂z′∂y1​​ 就是output layer的activation function (softmax) 对 z′z^{\\prime}z′ 的偏微分 而 ∂l∂y1\\frac{\\partial l}{\\partial y_{1}}∂y1​∂l​ 就是loss function对 y1y_{1}y1​ 的偏微分, 它取决于你的loss function是怎么定义的, 也就是你的output和target之间是怎么 evaluate的, 你可以用cross entropy, 也可以用mean square error, 用不同的定义, ∂l∂y1\\frac{\\partial l}{\\partial y_{1}}∂y1​∂l​ 的值就不一样 这个时候, 你就已经可以把l对 w1w_{1}w1​ 和 w2w_{2}w2​ 的偏微分 ∂l∂w1,∂l∂u2\\frac{\\partial l}{\\partial w_{1}}, \\frac{\\partial l}{\\partial u_{2}}∂w1​∂l​,∂u2​∂l​ 算出来了 另一个观点——反向计算的一句 这个式子还是蛮简单的, 然后, 我们可以从另外一个观点来看待这个式子 你可以想象说, 现在有另外一个neuron, 它不在我们原来的network里面, 在下图中它被画成三角形, 这个 neuron的input就是 ∂l∂z′\\frac{\\partial l}{\\partial z^{\\prime}}∂z′∂l​ 和 ∂l∂zn,\\frac{\\partial l}{\\partial z^{n}},∂zn∂l​, 那input ∂l∂z′\\frac{\\partial l}{\\partial z^{\\prime}}∂z′∂l​ 就乘上 w3,w_{3},w3​, input ∂l∂z′′\\frac{\\partial l}{\\partial z^{\\prime \\prime}}∂z′′∂l​ 就乘上 w4,w_{4},w4​, 它们两个相加再乘上activation function的微分 σ′(z),\\sigma^{\\prime}(z),σ′(z), 就可以得到output ∂l∂z\\frac{\\partial l}{\\partial z}∂z∂l​ 这张图描述了一个新的“neuron&quot;，它的含义跟图下方的表达式是一模一样的, 作这张图的目的是为了方便理解 值得注意的是, 这里的 σ′(z)\\sigma^{\\prime}(z)σ′(z) 是一个constant常数, 它并不是一个function, 因为z其实在计算forward pass的时候 就已经被决定好了, z是一个固定的值 所以这个neuron其实跟我们之前看到的sigmoid function是不一样的, 它并不是把input通过一个non-linear进行 转换, 而是直接把input乘上一个constant σ′(z),\\sigma^{\\prime}(z),σ′(z), 就得到了output, 因此这个neuron被画成三角形, 代表它跟我 们之前看到的圆形的neuron的运作方式是不一样的, 它是直接乘上一个constant(这里的三角形有点像电路里的运 算放大器op-amp, 它也是乘上一个constant) 知道 z′z^{\\prime}z′ 和 z′′z^{\\prime \\prime}z′′ 就可以知道 z,z,z, 知道 zaz_{a}za​ 和 zbz_{b}zb​ 就可以知道 z′,……,z^{\\prime}, \\ldots \\ldots,z′,……, 现在这个过程就可以反复进行下去, 直到找到output layer, 我们可以算出确切的值, 然后再一层一层反推回去 你可能会想说, 这个方法听起来挺让人崩溃的, 每次要算一个微分的值, 都要一路往后走, 一直走到network的 output, 如果写成表达式的话, 一层一层往后展开, 感觉会是一个很可怕的式子, 但是! 实际上并不是这个样子 做的 你只要换一个方向, 从output layer的 ∂l∂z\\frac{\\partial l}{\\partial z}∂z∂l​ 开始算, 你就会发现它的运算量跟原来的network的Feedforward path 其实是一样的 ▲注: 如果是正向做Backward pass的话, 实际上每次计算一个 ∂l∂z,\\frac{\\partial l}{\\partial z},∂z∂l​, 就需要把该neuron后面所有的 ∂l∂z\\frac{\\partial l}{\\partial z}∂z∂l​ 都给计算一 遍, 会造成很多不必要的里复运算, 如果写成code的形式, 就相当于调用了很多次里复的函数; 而如果是反向做 Backward pass，实际上就是把这些调用函数的过程都变成调用“值&quot;的过程, 因此可以直接计算出结果, 而不需要 占用过多的堆栈空间 Summary 最后，我们来总结一下Backpropagation是怎么做的 Forward pass，每个neuron的activation function的output，就是它所连接的weight的 Backward pass，建一个与原来方向相反的neural network，它的三角形neuron的output就是 把通过forward pass得到的和通过backward pass得到的乘起来就可以得到对的偏微分 11. P17Convolutional Neural Network 11_Convolutional Neural Network part1 12_Convolutional Neural Network part2 12. P14Tips for Training DNN 包含卷积层和池化层，主要用来识别位移、缩放及其他形式扭曲不变性的二维图形。特殊性特显在1.神经元之间的连接是非全连接的，2.同一层中某些神经元的连接权重是共享的（即相同的）==&gt;从而减少了权值的数量、降低了模型的复杂 P13. Recurrent Neural Network (Part I) P14. Recurrent Neural Network (Part II) P22Semi-supervised P23Unsupervised Learning - Word Embedding P24Explainable ML (1_8) P33Attack ML Models (1_8) P43Network Compression (1_6) P51Conditional Generation by RNN &amp; Attention P52Pointer Network P53Recursive P54Transformer P56Unsupervised Learning - Linear Methods P57Unsupervised Learning - Neighbor Embedding P58Unsupervised Learning - Auto-encoder 自编码模型（Auto-encoder AE），是一种无监督学习算法，使用了反向传播算法，让目标值等于输入值 P63ELMO, BERT, GPT P65Anomaly Detection (1_7) P72Generative Adversarial Network(1_10)——GAN P83Transfer Learning P86Meta Learning – MAML (1_9) P100Life Long Learning (1_7) P108Deep Reinforcemen Learning(3_1) P111RL Advanced Version_1_Policy Gradient 附录 机器学习系列10-手写数字识别(Keras2.0) ——10_Keras 机器学习系列6-分类问题(概率生成模型) P16PyTorch Tutorial P8Optimization for Deep Learning (1_2) (选学)","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"}]},{"title":"JupyterHub搭建","slug":"JupyterHub搭建","date":"2020-11-15T14:08:52.000Z","updated":"2020-11-20T05:59:09.392Z","comments":true,"path":"2020/11/15/JupyterHub搭建/","link":"","permalink":"https://nymrli.top/2020/11/15/JupyterHub搭建/","excerpt":"","text":"之前搭建的JupyterLab逐渐被使用起来了, 单用户的模式还是不太方便, 因此准备用JupyterHub来做下用户隔离 1. 安装nodejs和npm 按照JupyterLab官方教程, 先是安装最新的nodejs和npm, 但是由于16.04的apt源安装的nodejs版本比较久, 因此在后面的安装中会有坑, 这边根据网上的教程手动安装最新的nodejs 12$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -$ sudo apt-get install -y nodejs 安装成功后输入node --version看到有版本返回输出证明安装成功, 同时这种方式会同时安装npm, 同样npm --version测试npm安装成功 2. 安装 2.1 安装虚拟环境 由于我个人喜欢自己配置虚拟环境, 因此, 我先安装虚拟环境。但阿里云上的virtualenv太久不用，版本太老了， 出现了使用virtualenv创建虚拟环境报错 error code 2现象，因此通过 1234sudo pip install setuptools #安装setuptoolssudo pip install --upgrade setuptools #更新setuptools到最新版本sudo pip install virtualenv #安装virtualenvsudo pip install --upgrade virtualenv #更新virtualenv到最新版本 来更新setuptools和virtualenv到最新的版本 1$ virtualenv mlEnv 2.2 安装jupyterhub 根据官方教程，有两种方式安装：pip 安装 ; conda安装 1234567# pip安装$ python3 -m pip install jupyterhub$ sudo npm install -g configurable-http-proxy$ python3 -m pip install notebook # needed if running the notebook servers locally# conda安装$ conda install -c conda-forge jupyterhub # installs jupyterhub and proxy$ conda install notebook # needed if running the notebook servers locally 2.2.1 问题1_虚拟环境 但在安装过程中出现了以下报错 12ERROR: Could not install packages due to an EnvironmentError: [Errno 13] Permission denied: '/home/mrli/MLproject/mlEnv/lib/python3.5/site-packages/idna'Consider using the `--user` option or check the permissions. 通过which pip可以看到我使用的pip正是虚拟环境下的pip, 同时提示中的site-packages文件夹也是存在的。便按照提示加上了–user， 但是出现了如下新报错ERROR: Can not perform a '--user' install. User site-packages are not visible in this virtualenv. (注意, 不用加sudo来保证权限, 应为加上sudo pip吧库安装到的路径是在root下的) 经过查询发现, 是因为整个虚拟环境下的权限不够, 因此需要加权sudo chmod 777 -R mlEnv=&gt;遂问题解决 永久更改pip源和创建虚拟环境 2.2.2 问题2_npm安装报错 执行sudo npm install -g configurable-http-proxy时有如下报错Error: EACCES: permission denied, access '/usr/lib/node_modules'已经加上了sudo也无济于事。 ==&gt; 通过node的npm无法安装（无法过墙），也可以用阿里的自己的cnpm进行安装sudo npm install -g cnpm --registry=https://registry.npm.taobao.org,然后再输入sudo cnpm install -g configurable-http-proxy–&gt;解决! 3. 测试安装成功 jupyterhub -h、 configurable-http-proxy -h查看是否有输出, jupyterhub然后在https://localhost:8000中查看 4. 配置 生成配置文件 12$ jupyterhub --generate-config -f /etc/jupyterhub/jupyterhub_config.py$ jupyterhub --generate-config # 会在你的当前目录下生成一个jupyterhub_config.py文件, 我们在其中配置我们的网络和用户管理 1234567891011121314c.JupyterHub.ip = '192.168.2.4' # 本机局域网的ip，记得是局域网c.JupyterHub.port = 12443 # 指定服务端口c.Spawner.ip = '127.0.0.1' c.PAMAuthenticator.encoding = 'utf8'c.Authenticator.whitelist = &#123;'root','admin', 'tv', 'aiker'&#125; #默认不能使用root登录，需要修改配置. 这里面需要将linux的用户名添加进入，这样该用户就可以通过浏览器利用linux的用户名和密码登录自己的账户，jupyterhub采用和linux系统相同的认证方式，所以我们不需要另外建立用户，只需要登录linux的用户和密码即可 ==&gt; 用户白名单的用户会自动添加，但无密. 需要修改密需要创建linux用户才能登录；c.LocalAuthenticator.create_system_users = Truec.Authenticator.admin_users = &#123;'root', 'admin'&#125; # 指定admin用户c.JupyterHub.authenticator_class = 'dummyauthenticator.DummyAuthenticator'c.JupyterHub.statsd_prefix = 'jupyterhubc.Spawner.notebook_dir = '/volume1/study/' #jupyterhub自定义目录c.JupyterHub.statsd_prefix = 'jupyterhub'c.JupyterHub.ssl_cert = '/usr/syno/etc/certificate/_archive/xYa1nX/fullchain.pem'c.JupyterHub.ssl_key = '/usr/syno/etc/certificate/_archive/xYa1nX/privkey.pem' 默认情况下，要真正的实现分配用户账号，需要满足以下两点要求： c.Authenticator.whitelist 指定了用户名 在系统中创建了该用户（adduser / useradd） tips: 默认情况下，密码为系统中该用户对应的密码 用户管理 用户白名单的用户会自动添加，但无密码，需要修改密码才能登录； 新添加用户：useradd crxis -d /home/user/crxis -m 用户添加组：adduser crxis group1 修改用户密码：echo crxis:crxis|chpasswd 123456c.JupyterHub.admin_users = &#123;&apos;root&apos;, &apos;admin&apos;&#125;c.JupyterHub.bind_url = &apos;http://127.0.0.1:22223&apos;c.JupyterHub.hub_bind_url = &apos;http://127.0.0.1:22224&apos;c.JupyterHub.hub_port = 22225c.Authenticator.whitelist = &#123;&apos;root&apos;, &apos;mrli&apos;&#125;c.JupyterHub.hub_port = 22226 5. 运行 在存放jupyterhub_config.py的文件夹下执行jupyterhub启动服务 配置查看: https://blog.51cto.com/m51cto/2370679——GPU坑, 配置github登入 附录: 修改pip默认源: 1$ vim ~/.pip/pip.conf # 如果当前用户没有.pip文件夹, 则创建一个 添加下列内容 123456[global]index-url = http://pypi.douban.com/simple[install]use-mirrors =truemirrors =http://pypi.douban.com/simple/trusted-host =pypi.douban.com Linux上安装最新版的Python 查看 Python 的版本号：python2 -V, python3 -V 下载3.x新版本 可以访问python的官方网站查看最新的python版本以及下载链接：https://www.python.org/downloads/，将鼠标移到想要官网上想要下载的版本号上就可以看到下载地址，例如我需要在Linux下安装，可以使用这个链接：https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz（如果想要下载其他版本，直接修改版本号即可）。找到下载地址后，在命令行输入：wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz 下载完成后解压缩tar -zxvf Python-3.8.5.tgz 下载完成后解压缩cd Python-3.8.5/; ./configure, 由于使用3.8出现了virtualenv无法使用的情况, 因此需要对配置文件进行修改: 修改Python-3.8.5/Modules路径的Setup文件: sudo vim Setup: 编译sudo make; sudo make install 但是发现修改后报错缺少xxssl.h的头文件, wget https://www.openssl.org/source/openssl-1.0.2h.tar.gz tar zxf openssl-1.0.2h.tar.gz; cd openssl-1.0.2h ./config shared zlib; make depend sudo make; sudo make install 检测是否安装成功: openssl version -a ▲.再次到python中make install, 报错: subprocess.CalledProcessError: Command ‘(‘lsb_release’, ‘-a’)’ returned non-zero exit status 1. 解决方法 find /usr/bin -name lsb_release sudo rm -rf /usr/bin/lsb_release 此时再到Python/中make install即可","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"GithubActions","slug":"GithubAction","date":"2020-11-12T08:20:54.000Z","updated":"2021-11-08T02:34:00.211Z","comments":true,"path":"2020/11/12/GithubAction/","link":"","permalink":"https://nymrli.top/2020/11/12/GithubAction/","excerpt":"","text":"GitHub Actions 是 GitHub 的持续集成服务，于2018年10月推出。 GitHub Actions 是什么？ 大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。 如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。 GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 基础名词概念 GitHub Actions 有一些自己的术语。 （1）workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 （2）job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 （3）step（步骤）：每个 job 由多个 step 构成，一步步完成。每个 step可以定义自己的 name和id，通过 uses 可以声明使用一个具体的 action，通过run 声明需要执行哪些指令。 （4）action （动作）：每个 step 可以依次执行一个或多个命令（action）。 GitHub Actions阮一峰 具体内容说明: name自动构建的名字 on触发条件 watch监视 type:started 类型：点击了星标 也可以是数组： [push, pull_request] 123456push: # push触发 branches: [ main ]workflow_dispatch: # 手动触发schedule: # 计划任务触发 #- cron: '*/30 20-23,0-15 * * *' # cron表达式，Actions时区是UTC时间，所以要往前推8个小时(4-23) - cron: '0 */1 * * *' env环境变量 jobs任务 build工作的id run-on工作运行的环境平台:可用的虚拟机类型如下： 123ubuntu-latest，ubuntu-18.04 或 ubuntu-16.04windows-latest，windows-2019 或 windows-2016macOS-latest 或 macOS-10.14 if工作运行的判断 steps 包含一系列任务步骤 name：子任务名 uses ：使用官方的一些action库完成一些操作 run： 运行脚本 id： 运行step的id——用来设置环境变量所用：jobs.&lt;job_id&gt;.steps.env，steps.&lt;step id&gt;.outputs，再如：run: echo &quot;The time was $&quot;，此处的hello就是上一步id为hello的step 注：每个step后的路径是不相关的，定义每个step时默认的工作目录都是根目录 strategy：GitHub Actions 会将 matrix 中的每个参数排列组合，产生一个新的运行实例。 workflow 文件 GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。 workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如foo.yml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。 综上, Github actions配合GithubPages会非常方便 什么是 GitHub Pages? 打开 GitHub Pages 的首页我们会看到如下图所示： 他可以当做你或者你的项目的 Websites，那么我们可以知道 GitHub Pages 有两种最基本的用法： 作为你自己（或者组织）的网站（访问地址示例：http://username.github.io） 作为你某一个项目的网站（访问地址示例：http://username.github.io/projectname） 由于性能不太好, 因此最主要的用途是作为部署静态网页, 给demo展示: 做 demo 展示不同于做项目开发, 我们需要的是快速轻便的开发和部署, 而不是完备的一整套开发流程. Github pages 的好处 使用零成本: github pages 集成在 github 中, 直接和代码管理绑定在一起, 随着代码更新自动重新部署, 使用非常方便. 免费: 免费提供 username.github.io 的域名, 免费的静态网站服务器. 无数量限制: github pages 没有使用的数量限制, 每一个 github repository 都可以部署为一个静态网站. workflowDemo 官方demo 默认的生成模板: 会在仓库的./github/workflows目录下创建一个.yml的文件 123456789101112131415161718192021222324252627282930313233343536# This is a basic workflow to help you get started with Actionsname: CI# Controls when the action will run. Triggers the workflow on push or pull request# events but only for the main branchon: push: branches: [ main ] pull_request: branches: [ main ]# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs: # This workflow contains a single job called \"build\"——任务名 build: # The type of runner that the job will run on # To set the operating system for your job, specify the operating system using runs-on: ubuntu-latest, ubuntu-18.04, or ubuntu-16.04、windows-latest or windows-2019、macos-latest or macos-10.15 runs-on: ubuntu-latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it # 检出， 将代码从代码库中拉下来， 然后复制到本地的虚拟机上 - uses: actions/checkout@v2 # Runs a single command using the runners shell # 给操作——run, 起个操作名——name - name: Run a one-line script run: echo Hello, world! # Runs a set of commands using the runners shell - name: Run a multi-line script run: | echo Add other actions to build, echo test, and deploy your project. BiliBiliTool的workflow 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950name: bilibili-daily-taskon: push: # push触发 branches: [ main ] workflow_dispatch: # 手动触发 schedule: # 计划任务触发 - cron: '10 6 * * *' # cron表达式，Actions时区是UTC时间，所以要往前推8个小时,如上表示每天14点10分 jobs: run-bilibili-tool: runs-on: ubuntu-latest steps: # 检出 - name: Checkout uses: actions/checkout@v2 # 设置服务器时区为东八区 - name: Set time zone run: sudo timedatectl set-timezone 'Asia/Shanghai' # .Net Core 环境 - name: Setup .NET Core uses: actions/setup-dotnet@v1 with: dotnet-version: 3.1.301 # 安装依赖 - name: Install dependencies run: dotnet restore # 构建应用 - name: Build run: dotnet build --configuration Release --no-restore # 运行 - name: Run # env是从仓库settings的secrets中取值 env: userId: $&#123;&#123;secrets.USERID&#125;&#125; sessData: $&#123;&#123;secrets.SESSDATA&#125;&#125; biliJct: $&#123;&#123;secrets.BILIJCT&#125;&#125; otherConfigs: $&#123;&#123;secrets.OTHERCONFIGS&#125;&#125; run: dotnet run -p ./src/Ray.BiliBiliTool.Console -userId=$&#123;userId&#125; -sessData=$&#123;sessData&#125; -biliJct=$&#123;biliJct&#125; -closeConsoleWhenEnd=1 $&#123;otherConfigs&#125; 联通Workflow https://github.com/simo8102/88-AutoSignMachine/blob/main/.github/workflows/main.yml#L11 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 name: 联通挂机任务积分脚本on: push: # push触发 branches: [ main ] workflow_dispatch: # 手动触发 schedule: # 计划任务触发 #- cron: '*/30 20-23,0-15 * * *' # cron表达式，Actions时区是UTC时间，所以要往前推8个小时(4-23) - cron: '0 */1 * * *' jobs: daily-task: if: github.event.repository.owner.id == github.event.sender.id runs-on: ubuntu-latest strategy: matrix: node-version: [12] node-registry: ['https://registry.npmjs.org'] steps: # 检出 - name: Checkout uses: actions/checkout@v2 # 设置服务器时区为东八区 - name: Set time zone run: sudo timedatectl set-timezone 'Asia/Shanghai' - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125; uses: actions/setup-node@v1 with: node-version: $&#123;&#123; matrix.node-version &#125;&#125; registry-url: $&#123;&#123; matrix.node-registry &#125;&#125; - name: Get npm cache directory id: npm-cache run: | echo \"::set-output name=dir::$(npm config get cache)\" - name: restore npm cache uses: actions/cache@v2 id: use-npm-cache with: path: $&#123;&#123; steps.npm-cache.outputs.dir &#125;&#125; key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125; - name: restore npm dependencies uses: actions/cache@v2 id: use-npm-depends with: path: | node_modules */*/node_modules key: $&#123;&#123; runner.os &#125;&#125;-depends-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125; - name: restore task cache uses: actions/cache@v2 id: use-task-cache with: path: | /home/runner/.AutoSignMachine key: $&#123;&#123; runner.os &#125;&#125;-task-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125; - name: Install dependencies if: steps.use-npm-cache.outputs.cache-hit != 'true' || steps.use-npm-depends.outputs.cache-hit != 'true' run: npm install # 运行 unicom 签到任务 - name: Run unicom daily task env: user: $&#123;&#123;secrets.unicom_user&#125;&#125; password: $&#123;&#123;secrets.unicom_password&#125;&#125; appid: $&#123;&#123;secrets.unicom_appid&#125;&#125; notify_sctkey: $&#123;&#123;secrets.NOTIFY_SCKEY&#125;&#125; run: node index.js unicom --user=$&#123;user&#125; --password=$&#123;password&#125; --appid=$&#123;appid&#125; 压缩打包的action：archive-action 复制文件到另一个仓库：copy_file_to_another_repo_action 附录： 好用的Github Action库 构建暂存区 上传文件到Github Action工作区 根据上传的tag将工作区文件发布成release：softprops/action-gh-release： 在网页端上传release的时候，也会有tag选择，tag被用来指明和区分软件开发中的关键时期，比如版本号更新的时候可以创建tag来区分 创建本地tag：git tag -a v2.0 -m &quot;msg&quot; 上传tag： git push origin v2.0 删除本地tag：git tag -d v2.0 删除远程tag：git push origin :refs/tags/v2.0 这个动作的典型用法是在被推送到git标签上的Commit的构建过程中添加一个步骤，该步骤将会把指定的文件发布成release 某个commit想要发布时，需要打tag，整体操作如下： 12345678# 提交、标记和推送操作到 GitHub# 从您的终端，提交 action.yml、entrypoint.sh、Dockerfile 和 README.md 文件。# 最佳做法是同时为操作版本添加版本标记。 有关对操作进行版本管理的详细信息，请参阅“关于操作”。 https://docs.github.com/cn/actions/creating-actions/creating-a-docker-container-actionShellgit add action.yml entrypoint.sh Dockerfile README.mdgit commit -m \"My first action is ready\"git tag -a -m \"My first action release\" v1git push --follow-tags # 等价于git push 与 git push origin v1 合体 上述两者可以配合使用，即在作业之间共享数据，所谓的工作区是Github在workflow中提供给构建存储的空间：在作业之间共享数据 工作流程命令 您可以在Github Action中工作流程或操作代码中运行 shell 命令时，使用工作流程命令。 关于工作流程命令：操作可以与运行器机器进行通信，以设置环境变量，其他操作使用的输出值，将调试消息添加到输出日志和其他任务。大多数工作流程命令使用特定格式的 echo 命令，而其他工作流程则通过写入文件被调用。 更多信息请参阅“环境文件”。 设置输出参数 ::set-output name={name}::{value}设置操作的输出参数，如echo &quot;::set-output name=action_fruit::strawberry&quot; 具体的例子：脚本需要获取当前时间并将其设置为(作业中稍后运行的操作可以使用的输出变量)。 为便于 GitHub 识别输出变量， 您必须以特定语法使用工作流程命令： echo &quot;::set-output name=&lt;output name&gt;::&lt;value&gt;&quot;。 在作业之间共享数据 12345678910111213# 例如，您可以创建一个文件，然后将其作为构件上传。jobs: example-job: name: Save output steps: - shell: bash run: | expr 1 + 1 &gt; output.log - name: Upload output file uses: actions/upload-artifact@v2 with: name: output-log-file path: output.log 12345678# 要从单独的工作流程运行下载构件，您可以使用 `actions/download-artifact` 操作。 例如，您可以下载名为 `output-log-file` 的构件。jobs: example-job: steps: - name: Download a single artifact uses: actions/download-artifact@v2 with: name: output-log-file 10 个你该了解的 GitHub Actions 进阶技巧 Job 编排通过needs关键字控制执行顺序 workflow 执行时，传入参数 常用on解析 开发一个 Action 很简单 一个 Action 就是一个处理逻辑，接收输入参数，执行一定的逻辑，然后输出参数 有三种类型的 Action创建方式： Docker container, 适用 Linux 系统 最小的可以由4个内容组成：Dockerfile、README.md、entrypoint.sh、action.yml(操作元数据文件)，通过docker容器创建action的demo：https://docs.github.com/cn/actions/creating-actions/creating-a-docker-container-action 例子copy_file_to_another_repo_action：https://github.com/Ca11back/copy_file_to_another_repo_action/tree/add-commit-msg-test JavaScript, 适用 Linux、macOS、Windows 系统：通过执行 JavaScript 处理 Action 逻辑。官方提供了 JavaScript 和 TypeScript 的 Action 模板。在创建项目时，使用模板创建，然后编写处理逻辑，发布自己的 Action 即可。 setup-java：https://github.com/actions/setup-java actions-download-artifact：https://github.com/aochmann/actions-download-artifact Github action 的开发到发布 Composite run steps, 适用 Linux, macOS, Windows 系统 archive-action：https://github.com/ihiroky/archive-action ▲元数据语法 环境变量($GITHUB_XXX)：https://docs.github.com/cn/actions/learn-github-actions/environment-variables github.xxx.yyy 上下文： 12345678name: CIon: pushjobs: prod-check: if: $&#123;&#123; github.ref == 'refs/heads/main' &#125;&#125; runs-on: ubuntu-latest steps: - run: echo \"Deploying to production server on branch $GITHUB_REF\" 在此示例中，if 语句检查 github.ref 上下文以确定当前分支名称；如果名称是 refs/heads/main，则执行后续步骤。 if 检查由 GitHub Actions 处理，作业仅在结果为 true 时才发送到运行器。 作业发送到运行器后， 该步骤将执行并引用运行器的 $GITHUB_REF 环境变量。 术语介绍 action ： workflow最小执行单元 Artifact ： workflow运行，产生的中间文件，包括日志、测试结果等 Continuous integration (CI)：自动构建、测试 Continuous deployment (CD)： 自动部署 Event: 触发workflow GitHub-hosted runner：githut平台的虚拟机 Job: workflow的分解，可串行存在依赖；可并行 Runner： 运行环境 Self-hosted runner： 开发者自己的运新环境 Step: job的分解 Github Action 触发工作流程 以下步骤将触发工作流程运行： 仓库中发生事件，生成的事件具有关联的提交 SHA 和 Git ref。 在仓库的 .github/workflow 目录中关联的提交 SHA 或 Git ref 处搜索工作流程文件。 工作流程文件必须存在于该提交 SHA 或 Git ref 中才会被考虑。 例如，如果事件发生在特定仓库分支上，则工作流程文件必须存在于该分支的仓库中。 检查该提交 SHA 和 Git ref 的工作流程文件， 并且对其 on: 值与触发事件匹配的任何工作流程触发新的工作流程。 工作流程在触发事件的相同提交 SHA 和 Git ref 上的仓库代码中运行。 当工作流程运行时，GitHub 会在运行器环境中设置 GITHUB_SHA（提交 SHA）和 GITHUB_REF（Git 引用）环境变量。 更多信息请参阅“使用环境变量”。 采坑记录 每个step后的路径是不相关的，定义每个step时默认的工作目录都是根目录 pyinstaller打包的程序不能跨平台执行，如果需要同时生成linux和windows的可以yml上加上strategy:matrix(GitHub Actions 会将 matrix 中的每个参数排列组合，产生一个新的运行实例。)，大佬示例：build.yml 有跨平台的打包action:archive-action entrypoint.sh需要执行权限 1- `if: github.event.repository.owner.id == github.event.sender.id`，仓库所有者ID == 事件触发者ID，`if: $&#123;&#123; github.event_name == &apos;workflow_dispatch&apos; &amp;&amp; !github.event.repository.private&#125;&#125;`检查是否为手动触发、仓库是否是私有的","categories":[],"tags":[{"name":"小白文","slug":"小白文","permalink":"https://nymrli.top/tags/小白文/"}]},{"title":"南邮校园网CSDN等部分网站图片无法加载解决方案","slug":"南邮校园网CSDN等部分网站图片无法加载解决方案","date":"2020-11-10T10:14:56.000Z","updated":"2020-11-10T10:28:28.033Z","comments":true,"path":"2020/11/10/南邮校园网CSDN等部分网站图片无法加载解决方案/","link":"","permalink":"https://nymrli.top/2020/11/10/南邮校园网CSDN等部分网站图片无法加载解决方案/","excerpt":"","text":"问题定位 转自： https://blog.csdn.net/pamzerbhu/article/details/108549279 用语言描述如下： 打开页面后页面加载正常，但是图片完全没有加载。但是挂全局代理是可以看到图片的。挂代理后如下所示： 开始定位问题： 点击审查元素，接着找到我这张图的链接，直接用浏览器打开，报错**NET::ERR_CERT_COMMON_NAME_INVALID** 然后点击 高级–继续访问 img-blog.csdn.net (不安全) 图片成功加载： 好了，找到了问题。接下来就是面向搜索引擎的找方法时间。 经过查询发现是DNS的问题（或者可以打开cmd，然后输入ipconfig/all看DNS地址）： 解决方案 我们尝试修改dns，并刷新。 修改教程点我. 再次查看确认已经不再是坑爹的南邮DNS了。访问csdn发现一切正常。OK结束。 ERR_CERT_COMMON_NAME_INVALID 实际上，可以认为，ERR_CERT_COMMON_NAME_INVALID就是用一个错误的域名访问了某个节点的https资源。导致这个错误的原因，基本是 dns污染 host设置错误 官方更新了dns，但是dns缓存没有被更新，导致错误解析。","categories":[],"tags":[]},{"title":"scrcpy+AutoJS","slug":"scrcpy-AutoJS","date":"2020-11-09T03:26:19.000Z","updated":"2020-11-14T07:17:12.129Z","comments":true,"path":"2020/11/09/scrcpy-AutoJS/","link":"","permalink":"https://nymrli.top/2020/11/09/scrcpy-AutoJS/","excerpt":"","text":"scrcpy简介 特点: 利用电脑的键盘和鼠标可以控制手机。把 APK 文件拖拽到电脑窗口即可安装应用到手机，把普通文件拖拽到窗口即可复制到手机。 不需要在手机上安装任何应用。 简单地来说，scrcpy就是通过adb调试的方式来将手机屏幕投到电脑上，并可以通过电脑控制您的Android设备。它可以通过USB连接，也可以通过Wifi连接（类似于隔空投屏），而且不需要任何root权限，不需要在手机里安装任何程序。scrcpy同时适用于GNU / Linux，Windows和macOS。 它的一些特性： 亮度（原生，仅显示设备屏幕） 性能（30~60fps） 质量（1920×1080或以上） 低延迟（35~70ms） 启动时间短（显示第一张图像约1秒） 非侵入性（设备上没有安装任何东西） 此项目为开源项目，Github地址：Genymobile/scrcpy: Display and control your Android device 使用scrcpy的要求 Android设备至少需要API 21（Android 5.0以上版本）; 确保在您的设备上启用了adb调试; 在某些设备上，您还需要启用其他选项以使用键盘和鼠标控制它。 adb调试的开启一般是多次点击手机系统版本，如我用的是MIUI10，开启方法是 “设置”-&gt;“我的设备”-&gt;“全部参数”-&gt;点击7下MIUI版本，开启“开发者选项”。然后在 “设置”-&gt;“更多设置”-&gt;“开发者选项” 中同时开启 USB调试 和 USB调试(安全设置)。 使用说明 程序使用了Java语言，我们需要在电脑中搭建Java运行环境，参考：Windows10 配置 Java 开发环境 使用USB进行连接 此方式推荐使用，相对更加流畅。 手机通过USB连接到PC上，首次连接会弹出是否信任该电脑，点击始终信任即可。 运行adb usb查看是否连接成功 12D:\\Github_Run\\scrcpy-win64-v1.10&gt;adb usbrestarting in USB mode 运行scrcpy即可。 使用无线连接 可参考官方文档：Open Source Project - Scrcpy now works wirelessly 此连接方式更加方便快捷，若宽带速率高，使用效果更佳，使用方法也非常简单。 确保PC和手机在同一Wifi中 手机先通过USB与PC相连 在PC上运行 adb tcpip 服务端口，如端口为5555 12D:\\Github_Run\\scrcpy-win64-v1.10&gt;adb tcpip 5555restarting in TCP mode port: 5555 拔下你的设备，断开USB连接 在PC上运行 adb connect 手机IP:服务端口（手机IP可通过手机的状态信息查看，或者登录路由器查看，一般以192.168开头） 12D:\\Github_Run\\scrcpy-win64-v1.10&gt;adb connect 192.168.0.4:5555connected to 192.168.0.4:5555 运行scrcpy，在cmd中输入scrcpy.exe即可 注: 若要切换回USB模式：adb usb 1234# 附调节比特率和分辨率$ scrcpy --bit-rate 2M --max-size 800# 或者简写$ scrcpy -b2M -m800 AutoJS 一个支持无障碍服务的Android平台上的JavaScript IDE，其发展目标是JsBox和Workflow。 Auto.js使用JavaScript作为脚本语言，目前使用Rhino 1.7.7.2作为脚本引擎，支持ES5与部分ES6特性。 官方教程: https://hyb1996.github.io/AutoJs-Docs/#/?id=autojs 使用教程视频: 笔青居 如何连接? 手机安装使用步骤： ① 开启无障碍服务 ② 音量上键停止脚本：当脚本处于无法停止的状态时，使用音量上键强制停止脚本。 ③ 开启悬浮窗： ④ 连接手机(如果不习惯在手机上coding, 可以安装作者提供的VsCode插件, 在Vscode上编码: Auto.js-VSCodeExt——插件的使用教程也非常简洁易懂， 在此就不重复了。 微信朋友圈点赞demo 123456789comment = desc(\"评论\").findOne();log(comment);comment.click();sleep(1000);// 由于\"赞\"控件的Clickable是false, 所以点击它的父控件praise = text(\"赞\").findOne();praiseParent = praise.parent();praiseParent.click(); Js知识补充 作用域: JS只有函数作用域和全局作用域 全局作用域: 如果是显性的写在全局的, 则变量的作用域为全局 12345678910111213141516&gt; /*&gt; * 作用域&gt; * - 作用域指一个变量的作用的范围&gt; * - 在JS中一共有两种作用域：&gt; * 1.全局作用域&gt; * - 直接编写在script标签中的JS代码，都在全局作用域&gt; * - 全局作用域在页面打开时创建，在页面关闭时销毁&gt; * - 在全局作用域中有一个全局对象window，&gt; * 它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用&gt; * - 在全局作用域中：&gt; * 创建的变量都会作为window对象的属性保存&gt; * 创建的函数都会作为window对象的方法保存&gt; * 一切皆对象&gt; * - 全局作用域中的变量都是全局变量，&gt; * 在页面的任意的部分都可以访问的到&gt; 块级作用域: {}为块, {}内即为块级作用域。但是注意JS没有块级作用域， 即块里声明的变量, 作用域实际为全局。—&gt;ES6 新增了let命令，用来声明局部变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效，而且有暂时性死区的约束。==&gt;ES6用新增的let，来声明块级作用域的变量。(let另一个特性: let变量不能重复声明–var可以, 以最后的为准, 效果跟python声明变量类似) 123456for(var i = 1; i &lt; 10; i++)&#123;&#125;log(i); // 输出为10for(let i = 1; i &lt; 10; i++)&#123;&#125;log(i); // ReferenceError: \"i\" is not defined. ([remote]test.js#14)ReferenceError: \"i\" is not defined. 函数作用域: 在函数内即为函数作用域， 如果不用var表明， 则声明的是全局变量。用var表明是局部变量 123456789101112&gt; /*&gt; * 函数作用域&gt; * - 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁&gt; * - 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的&gt; * - 在函数作用域中可以访问到全局作用域的变量&gt; * 在全局作用域中无法访问到函数作用域的变量&gt; * - 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用&gt; * 如果没有则向上一级作用域中寻找，直到找到全局作用域，&gt; * 如果全局作用域中依然没有找到，则会报错ReferenceError&gt; * - 在函数中要访问全局变量可以使用window对象&gt; */&gt; 12345678function test()&#123; a = 1; var b = 2;&#125;test();log(a); // 输出1log(b); // ReferenceError: \"b\" is not defined. ([remote]test.js#19)ReferenceError: \"b\" is not defined. 数组 12345678910a = [1,2,3] // 第一种声明数组的方式a.push(4) // 往数组最后添加元素log(a);log(a.indexOf(2)); // 找出某元素在数组中的索引a.pop(); // 弹出最后一个元素log(a);b = Array(); // 第二种声明数组的方式log(b); 数据类型: string、number、boolean、nullundefined Object：Function、Array、Date 可以使用typeof来查看对象的类型 变量函数提前声明 123456789101112131415161718192021222324252627/** 变量的声明提前* - 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），* 但是如果声明变量时不使用var关键字，则变量不会被声明提前** 函数的声明提前* - 使用函数声明形式创建的函数 function 函数()&#123;&#125;* 它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数* 使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用*//*console.log(&quot;a = &quot;+a);情况1：使用 var a = 123; a是undefined，声明变量在此句之后，但var a 会使变量提前声明，情况2： 使用 a = 123; a未找到，会报错，因为a未提前声明a = 123； 等价于 window.a = 123;var a = 123;*/ 到了此句才赋值，等价于在所有代码之前 声明a var a; 执行到此句再赋值 a=123;//fun();//函数声明，会被提前创建function fun()&#123;console.log(&quot;我是一个fun函数&quot;);&#125;//函数表达式，不会被提前创建，此句只是提前声明了fun2，不知道是不是函数，可能是变量， undefined而在此次才开始赋值一个函数表达式var fun2 = function()&#123;console.log(&quot;我是fun2函数&quot;);&#125;;fun2(); Andriod开发知识： packageName： 应用包名 applicationName: 应用名 currenetActivity: 当前页面 Js是单线程的, 在任务调度上，同步任务优先级最高， 微任务其次(new Promise)， 宏任务最后(setInterval, setTimeOut): https://www.bilibili.com/video/BV1NJ411W7wh?p=336 123456789new Promise( (resolve, reject) =&gt;&#123; resolve(); // 调用resolve表示成功, 调用reject表示失败 console.log(\"yes\") // 第一个大括号里的都是同步任务, 优先级很高&#125;).then(value =&gt;&#123; // 成功执行这个. 这个是微任务 console.log(\"成功\")&#125;, reason =&gt; &#123; console.log(\"失败\") // 失败执行这个. 这个是微任务&#125;)// 输出结果: yes =&gt; 成功","categories":[],"tags":[]},{"title":"粒子滤波Matlab代码解读","slug":"粒子滤波Matlab代码解读","date":"2020-10-27T09:39:23.000Z","updated":"2020-10-31T02:12:39.559Z","comments":true,"path":"2020/10/27/粒子滤波Matlab代码解读/","link":"","permalink":"https://nymrli.top/2020/10/27/粒子滤波Matlab代码解读/","excerpt":"","text":"粒子滤波概念 理解粒子滤波(particle filter) 粒子滤波的Matlab仿真算法实现 1.1 机器人定位问题 关于机器人定位，有三大问题，它们分别是： (1)“全局定位”：指初始位置未知，机器人靠自身运动确定自己在地图中的位姿。 (2)“位姿跟踪”：指已知自身位姿或者已经通过“全局定位”得到了一个较好的位姿估计，在后续运动时补偿精度较差的运动控制误差； (3)“绑架劫持”：指机器人在已知自身位姿的情况下，得到了一个错误的位姿信息或者外界将其放到另外一个位姿，而里程计信息给出了错误的信息甚至没有给出控制信息。 1.2 粒子滤波步骤(可结合2中例题) (1)初始状态：用大量粒子模拟运动状态，使粒子在空间内均匀分布； (2)预测阶段：根据状态转移方程，将每一个粒子带入，得到一个预测粒子； (3)校正阶段：对预测粒子进行评价（计算权重），越接近于真实状态的粒子，其权重越大； (4)重采样：根据粒子权重对粒子进行筛选，筛选过程中，既要大量保留权重大的粒子，又要有一小部分权重小的粒子； (5)滤波：将重采样后的粒子带入状态转移方程得到新的预测粒子，即步骤(2)。 代码分析 虽然选修课选修了Matlab， 但是自己Matlab工程代码到底写了太少， 特别是涉及维度转换以及数学相关的玩的都不是很好， 因此这次看这份代码学到了很多基础入门的写法， 记录一下： 变量关系： X为对象的真实位置， Z是观测到对象的观测位置（在真实的坐标上加上了噪声），P是粒子群，Pcenter是所有粒子的几何中心 变量维度的确定： 行为一维，列为二维。其中X(1, :)表示X坐标， X(2, :)表示Y坐标。其中列的T表示多少测量数量，测量时间。 err大小也是(2, T)， 但是(第一行为粒子与真实路径误差 第二行为测量与真实路径误差) 权重更新方式： 权重 (权重与距离的关系 为 均值是0,方差是sqrt®的高斯分布曲线) 代码组成部分： 参数设置 初始化粒子群 开始运动 绘制轨迹 绘制误差图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128%粒子滤波(定位运动轨迹)%在二维空间,假设运动物体的一组(非线性)运动位置、速度、加速度数据,用粒子滤波方法进行处理clc,clear,close all%% 参数设置N = 200; %粒子总数Q = 5; %过程噪声(控制误差) 状态转移方程中使用R = 5; %测量噪声 由真实位置叠加测量噪声得到测量位置T = 10; %测量时间(总步数)theta = pi/T; %旋转角度distance = 80/T; %每次走的距离(步长)WorldSize = 100; %世界大小% 设定变量维度X = zeros(2, T); %存储系统状态(每列存储二维位置坐标(x,y),共T个位置)Z = zeros(2, T); %存储系统的观测状态(每列存储二维位置坐标(x,y),共T次测量)P = zeros(2, N); %建立粒子群(每列存储当前粒子的二维位置坐标,共N个粒子)PCenter = zeros(2, T); %所有粒子的中心位置w = zeros(N, 1); %每个粒子的权重err = zeros(2,T); %误差(第一行为粒子与真实路径误差 第二行为测量与真实路径误差)X(:, 1) = [50; 20]; %初始系统状态 即初始位置在坐标(50,20)Z(:, 1) = X(:,1) + wgn(2,1,10*log10(R)); %初始系统的观测状态(为真实位姿叠加高斯噪声) %y = wgn(m,n,p) 产生一个m行n列的高斯白噪声的矩阵，p以dBW为单位指定输出噪声的强度%% 初始化粒子群for i = 1 : N P(:, i) = [WorldSize*rand; WorldSize*rand]; %随机产生第i个粒子的坐标(rand为产生[0,1]之间均匀分布) dist = norm(P(:, i)-Z(:, 1)); %与测量位置相差的距离 %求权重 (权重与距离的关系 为 均值是0,方差是sqrt(R)的高斯分布曲线) % 因为均值为0且距离大于0 因此权重随着距离增加沿高斯曲线右侧递减 w(i) = (1 / sqrt(R) / sqrt(2 * pi)) * exp(-(dist)^2 / 2 / R); endPCenter(:, 1) = sum(P, 2) / N;%t=1时刻(初始时刻)所有粒子的几何中心位置% 初始状态(t=1)画图err(1,1) = norm(X(:, 1) - PCenter(:, 1));%粒子群几何中心与系统真实状态的误差err(2,1) = wgn(1, 1, 10*log10(R));figure(1);hold onset(0,'defaultfigurecolor','w')plot(X(1, 1), X(2, 1), 'r.', 'markersize',30) %真实的初始状态位置(红点表示)%grid onaxis([0 100 0 100]);set(gca,'XTick',0:10:100) %改变x轴坐标间隔显示 这里间隔为10set(gca,'YTick',0:10:100) %改变y轴坐标间隔显示 这里间隔为10plot(P(1, :), P(2, :), 'k.', 'markersize',5); %各个粒子位置(N个黑点)plot(PCenter(1, 1), PCenter(2, 1), 'b.', 'markersize',25); %所有粒子的中心位置(蓝点表示)legend('真实位置', '粒子群', '粒子群的几何中心');title('初始状态');hold off%% 开始运动for k = 2 : T %从t=2到T %模拟一个弧线运动的状态 X(:, k) = X(:, k-1) + distance * [(-cos(k * theta)); sin(k * theta)] + wgn(2, 1, 10*log10(Q)); %状态方程 Z(:, k) = X(:, k) + wgn(2, 1, 10*log10(R)); %观测方程(状态上叠加测量的高斯噪声) %粒子滤波 % 1.预测 for i = 1 : N P(:, i) = P(:, i) + distance * [-cos(k * theta); sin(k * theta)] + wgn(2, 1, 10*log10(Q));%粒子群带入状态方程 dist = norm(P(:, i)-Z(:, k)); %粒子群中各粒子 与 测量位置 的距离 w(i) = (1 / sqrt(R) / sqrt(2 * pi)) * exp(-(dist)^2 / 2 / R); %求权重(距离近权重大) end % 2.归一化权重 wsum = sum(w); for i = 1 : N w(i) = w(i) / wsum; end % 3.重采样（更新）——可以理解为转转盘 for i = 1 : N wmax = 2 * max(w) * rand; %另一种重采样规则 index = randi(N, 1);%生成一个在[1(默认值),N]之间均匀分布的伪随机整数 while(wmax &gt; w(index)) % 找到具体落在哪个区间上 wmax = wmax - w(index); index = index + 1; if index &gt; N index = 1; end end Pnext(:, i) = P(:, index); %得到新粒子放入临时集Pnext end P=Pnext;%用临时集Pnext更新粒子集P PCenter(:, k) = sum(P, 2) / N; %重采样后所有粒子的中心位置 %计算误差 err(1,k) = norm(X(:, k) - PCenter(:, k)); %粒子几何中心与系统真实状态的误差 err(2,k) = norm(X(:, k) - Z(:, k)); %画图 figure(2); set(0,'defaultfigurecolor','w') clf;%清空figure(2)中的图像 以便循环重新画 hold on plot(X(1, k), X(2, k), 'r.', 'markersize',30); %系统状态位置 plot(P(1, :), P(2, :), 'k.', 'markersize',5); %各个粒子位置 plot(PCenter(1, k), PCenter(2, k), 'b.', 'markersize',25); %所有粒子的中心位置 axis([0 100 0 100]); title('运动过程'); legend('真实状态', '粒子群', '粒子群的几何中心'); hold off pause(0.1);%停0.1s开始下次迭代end%% 绘制轨迹figure(3);set(0,'defaultfigurecolor','w')plot(X(1,:), X(2,:), 'r.-', Z(1,:), Z(2,:), 'g.-', PCenter(1,:), PCenter(2,:), 'b.-');axis([0 100 0 100]);set(gca,'XTick',0:10:100) %改变x轴坐标间隔显示 这里间隔为10set(gca,'YTick',0:10:100) %改变y轴坐标间隔显示 这里间隔为10legend('真实轨迹', '测量轨迹', '粒子群几何中心轨迹');xlabel('横坐标 x'); ylabel('纵坐标 y');%% 绘制误差figure(4);set(0,'defaultfigurecolor','w')%set(gca,'FontSize',12);%设置图标字体大小plot(err(1,:),'b.-');%err1为各时刻 真实位置与粒子群中心的几何距离hold onplot(err(2,:),'r.-');%err2为各时刻 真实位置与测量位置的几何距离hold offxlabel('步数 t');legend('粒子群误差', '测量误差');title('真实位置与粒子群中心的集合距离'); 用到的函数记录 Matlab中的norm demo代码中有关norm的运用如下, 12345678%% 初始化粒子群for i = 1 : N P(:, i) = [WorldSize*rand; WorldSize*rand]; %随机产生第i个粒子的坐标(rand为产生[0,1]之间均匀分布) dist = norm(P(:, i)-Z(:, 1)); %与测量位置相差的距离 %求权重 (权重与距离的关系 为 均值是0,方差是sqrt(R)的高斯分布曲线) % 因为均值为0且距离大于0 因此权重随着距离增加沿高斯曲线右侧递减 w(i) = (1 / sqrt(R) / sqrt(2 * pi)) * exp(-(dist)^2 / 2 / R); end 其中没有特别指出是啥范数, 因此可以通过help norm来查看一下关于norm的使用介绍. 1234567&gt;&gt; help norm norm Matrix or vector norm. norm(X,2) returns the 2-norm of X. norm(X) is the same as norm(X,2). norm(X,1) returns the 1-norm of X. 可以得到, norm(X)的效果默认是取2-范数的。 同时， norm函数既可以取向量范数又可以取矩阵范数： 1、如果A为矩阵 n=norm(A) 《Simulink与信号处理》 返回A的最大奇异值，即max(svd(A)) n=norm(A,p) 根据p的不同，返回不同的值 p 返回值 1 返回A中最大一列和，即max(sum(abs(A))) 2 返回A的最大奇异值，和n=norm(A)用法一样 inf 返回A中最大一行和，即max(sum(abs(A’))) ‘fro’ A和A‘的积的对角线和的平方根，即sqrt(sum(diag(A’*A))) 2、如果A为向量 norm(A,p) 返回向量A的p范数。即返回 sum(abs(A).p)(1/p),对任意 1&lt;p&lt;+∞. norm(A) 返回向量A的2范数，即等价于norm(A,2)。 norm(A,inf) 返回max(abs(A)) norm(A,-inf) 返回min(abs(A)) Matlab中的sum sum(A, 1)： 对一维求和， 如果A为二维数组， 则按列求和 sum(A, 2): 对二维求和， 如果A为二维数组， 则按行求和 Matlab中的wgn 12345678&gt;&gt; help wgn wgn Generate white Gaussian noise. Y = wgn(M,N,P) generates an M-by-N matrix of white Gaussian noise. P specifies the power of the output noise in dBW. The unit of measure for the output of the wgn function is Volts. For power calculations, it is assumed that there is a load of 1 Ohm. Y = wgn(M,N,P,IMP) specifies the load impedance in Ohms.","categories":[],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://nymrli.top/tags/Matlab/"}]},{"title":"范数的概念_MATLAB使用","slug":"范数的概念-MATLAB使用","date":"2020-10-27T08:13:30.000Z","updated":"2020-10-27T10:26:44.365Z","comments":true,"path":"2020/10/27/范数的概念-MATLAB使用/","link":"","permalink":"https://nymrli.top/2020/10/27/范数的概念-MATLAB使用/","excerpt":"","text":"范数 之前大二在看机器学习的时候一直看到&quot;范数&quot;这个名词, 但是一直没有去详细了解过, 就只知道2-范数相当于两个点在二维平面的距离。这次在看粒子滤波matlab实现代码的时候看到了norm函数, 正好补一下关于范数的概念。 向量的范数 定义 注: 简言之: ①向量的范数是定义在线性空间上的非负实数.②实内积空间和酉空间中向量的长度∣x∣=(x,x)|x|=\\sqrt{(x,x)}∣x∣=(x,x)​都是向量的范数③酉空间向量范数∣∣x∣∣||x||∣∣x∣∣用向量长度|x|来定义时,记作∣∣x∣∣2=∣x∣=xxH=sumi=1nξξˉ||x||_2 = |x| = \\sqrt{xx^H} = \\sqrt{sum^{n}_{i=1}{ξ\\bar{ξ}}}∣∣x∣∣2​=∣x∣=xxH​=sumi=1n​ξξˉ​​ 通式——P-范数 注: 当P-&gt;∞时∣∣X∣∣=maxξ||X|| = max{\\xi}∣∣X∣∣=maxξ 矩阵的范数 ▲以上概念来自于B站视频: 向量范数矩阵范数 Matlab中的norm demo代码中有关norm的运用如下, 12345678%% 初始化粒子群for i = 1 : N P(:, i) = [WorldSize*rand; WorldSize*rand]; %随机产生第i个粒子的坐标(rand为产生[0,1]之间均匀分布) dist = norm(P(:, i)-Z(:, 1)); %与测量位置相差的距离 %求权重 (权重与距离的关系 为 均值是0,方差是sqrt(R)的高斯分布曲线) % 因为均值为0且距离大于0 因此权重随着距离增加沿高斯曲线右侧递减 w(i) = (1 / sqrt(R) / sqrt(2 * pi)) * exp(-(dist)^2 / 2 / R); end 其中没有特别指出是啥范数, 因此可以通过help norm来查看一下关于norm的使用介绍. 1234567&gt;&gt; help norm norm Matrix or vector norm. norm(X,2) returns the 2-norm of X. norm(X) is the same as norm(X,2). norm(X,1) returns the 1-norm of X. 可以得到, norm(X)的效果默认是取2-范数的。 同时， norm函数既可以取向量范数又可以取矩阵范数： 1、如果A为矩阵 n=norm(A) 《Simulink与信号处理》 返回A的最大奇异值，即max(svd(A)) n=norm(A,p) 根据p的不同，返回不同的值 p 返回值 1 返回A中最大一列和，即max(sum(abs(A))) 2 返回A的最大奇异值，和n=norm(A)用法一样 inf 返回A中最大一行和，即max(sum(abs(A’))) ‘fro’ A和A‘的积的对角线和的平方根，即sqrt(sum(diag(A’*A))) 2、如果A为向量 norm(A,p) 返回向量A的p范数。即返回 sum(abs(A).p)(1/p),对任意 1&lt;p&lt;+∞. norm(A) 返回向量A的2范数，即等价于norm(A,2)。 norm(A,inf) 返回max(abs(A)) norm(A,-inf) 返回min(abs(A)) Matlab中的sum sum(A, 1)： 对一维求和， 如果A为二维数组， 则按列求和 sum(A, 2): 对二维求和， 如果A为二维数组， 则按行求和 Matlab中的wgn white Gaussian noise 12345678&gt;&gt; help wgn wgn Generate white Gaussian noise. Y = wgn(M,N,P) generates an M-by-N matrix of white Gaussian noise. P specifies the power of the output noise in dBW. The unit of measure for the output of the wgn function is Volts. For power calculations, it is assumed that there is a load of 1 Ohm. Y = wgn(M,N,P,IMP) specifies the load impedance in Ohms.","categories":[],"tags":[{"name":"Math","slug":"Math","permalink":"https://nymrli.top/tags/Math/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://nymrli.top/tags/MATLAB/"}]},{"title":"Python中import的细节","slug":"Python中import的细节","date":"2020-10-23T13:01:21.000Z","updated":"2020-12-08T14:21:18.357Z","comments":true,"path":"2020/10/23/Python中import的细节/","link":"","permalink":"https://nymrli.top/2020/10/23/Python中import的细节/","excerpt":"","text":"防忘系列… Pycharm并没有IDEA一样可以设置对import进行排序以及自动消除没用到的库（要用快捷键Ctrl + Alt + O）， 并且如果导入方式不正确会 1.找不到自定义包 2.Pycharm对指定内容报错（下划线或红线） Python中模块，包，库概念 模块：就是.py文件，里面定义了一些函数和变量，需要的时候就可以导入这些模块。 包：在模块之上的概念，为了方便管理而将文件进行打包。包目录下第一个文件便是__init__.py，然后是一些模块文件和子目录，假如子目录中也有__init__.py，那么它就是这个包的子包了。 库：具有相关功能模块、包的集合。这也是Python的一大特色之一，即具有强大的标准库、第三方库以及自定义模块。 标准库：就是下载安装的python里那些自带的模块，要注意的是，里面有一些模块是看不到的比如像sys模块，这与linux下的cd命令看不到是一样的情况。 第三方库：就是由其他的第三方机构，发布的具有特定功能的模块。 自定义模块：用户自己可以自行编写模块，然后使用。 总结: 我们pip install &lt;package&gt;安装的是库，库下有很多包，我们在自己的项目文件中import有以下几种用法: import numpy as np import urllib.parse import urlencode from lxml import HTML 之前大家应该碰到过，命名自己pip install xx安装的是叫xx的库，但是在用的时候写的却是from yy import zz，明显不对应嘛。因此，其实库和包的区别还可以通过setup.py打包成库来看。——使用setup.py打包python文件； Python实现打包成库供别的模块调用 其中比较重要的就是5.编写:setup.py， 注意：setup.py与要打包的test_package包同在bricewulib根目录下。 其中比较重要的几项是:name,version,packages name:描述的是你打包的文件夹名。 version描述的是文件的版本号。 packages是所有要打包的包（package），这里需要打包的是test_package包以及test_package包下的test_package。输入python setup.py sdist然后就能创建bricewulib库，使用test_package包 12345setup( name = &quot;bricewulib&quot;, version = &quot;1.0&quot;, packages=[&quot;test_package&quot;,&quot;test_package.test_package2&quot;]) import推荐顺序 我们推荐所有的模块在 Python 模块的开头部分导入。 而且最好按照这样的顺序: Python 标准库模块 Python 第三方模块 应用程序自定义模块 通过空行来分割——(Python’s Style Guide), PEP8 。 import的搜索顺序： 首先判断这个module是不是built-in即内建模块，如果是则引入内建模块，如果不是则在一个称为sys.path的list中寻找 sys.path在python脚本执行时动态生成，包括以下3个部分： 脚本执行的位置，即当前路径 环境变量中的PYTHONPATH, 即.bash_profilec. 安装python时的依赖位置 Python的import机制 运行、编写Python代码时，一定要注意的是脚本路径和脚本执行路径，以及相对路径和绝对路径 如果在项目中运用了相对路径,则一定要注意脚本执行路径 假设A是B的父目录, 如我们想在A目录调用B中模块, 而B中模板是又import了A下模板, 如login: from login import ftSession。命令行在A路径下输入python B/main.py时, 会报错。因为import其实就是在搜索目录下按相对路径找的。 Pycharm的坑: 借鉴: Python的import机制坑在哪？ pycharm里打出来的路径是更多的，它把项目根目录加进去了。(也可以设置: 进入设置，找到Console下的Python Console，勾选选项**“Add source roots to PYTHONPAT”** ) 查看搜索路径:print(sys.path) What’s resource root? 以上导致的问题就是: pycharm中，project folder是默认的source root，当你使用import语句导入模块时，Pycharm默认在project folder中寻找；所以当你在project folder下的某个subfolder导入某个同样定义在这个subfolder中的模块时，会出现导入错误。 pycharm中的第一个文件夹，即代表项目, 当在其中再次建立文件夹时，是按package处理的 如果要在这些文件夹内import其他文件，需要将完整路径导入进来 所以最终在Pycharm中导入的方式有两种: burning回答 从project folder开始相对导入 将module文件夹直接定义为source root pycharm在同目录下import划红线但实际可以运行 解决方法: 右键将model所在的文件夹设置为source root 总结：python该如何import 需要明确的一点是：在运行Python脚本的时候，Python解释器会把脚本执行的位置，即当前路径加入到搜索路径中，而绝大多数情况main函数就在工程根目录，因此对于一个工程而言，最好的是从从project folder(工程根目录，即运行main函数的那个入口文件)开始相对导入 举个栗子： 12345678910111213141516171819G:.AI-for-Othello│ .gitignore│ board.py│ config.py│ game.py│ main.ipynb│ main.py│ README.md│ __init__.py│├─ai│ │ mcts.py│ │ randm.py│ │ __init__.py│ ││ ├─utils│ │ │ mct.py│ │ │ __init__.py 在这里ai/utils中mct.py需要import board.py中的Board对象等，mct.py中import具体写法为 1234567891011from enum import Enumfrom random import choicefrom time import timefrom copy import deepcopyimport numpy as npfrom board import Boardfrom config import C# 解释一下这边为什么是直接from board， 因为我们的main函数入口是main.py文件(在工程根目录)，所以他会把AI-for-Othello这个路径给加入到包的搜索路径中，所以此时我们import就是以这个路径(工程根目录)开始相对导入 ▲需要注意的是，对于main函数如果不在根目录，而是在工程目录的子目录中的情况，需要在main.py中自己手动添加sys.path.append(&quot;..&quot;)，即想办法把工程根目录加到搜索目录中，这样以后就可以又开始从工程根目录开始import了。 还有一个对于初学者可能会产生自我怀疑的点，我也顺便提一下好了 123from config import *// 等价于from .config import * __init__文件作用 在Python工程里，当python检测到一个目录下存在__init__.py文件时，python就会把这个目录当成一个包(package)。Module跟C＋＋的命名空间和Java的Package的概念很像，都是为了科学地组织化工程，管理命名空间。 __init__.py的设计原则 __init__.py的原始使命是声明一个模块，所以它可以是一个空文件。 A、不要污染现有的命名空间。模块一个目的，是为了避免命名冲突，如果你在种用__init__.py时违背这个原则，是反其道而为之，就没有必要使用模块了。 B、利用__init__.py对外提供类型、变量和接口，对用户隐藏各个子模块的实现。一个模块的实现可能非常复杂，你需要用很多个文件，甚至很多子模块来实现，但用户可能只需要知道一个类型和接口。就像我们的arithmetic例子中，用户只需要知道四则运算有add、sub、mul、dev四个接口，却并不需要知道它们是怎么实现的，也不想去了解arithmetic中是如何组织各个子模块的。由于各个子模块的实现有可能非常复杂，而对外提供的类型和接口有可能非常的简单，我们就可以通过这个方式来对用户隐藏实现，同时提供非常方便的使用。 C、只在__init__.py中导入有必要的内容，不要做没必要的运算。像我们的例子，import arithmetic语句会执行__ini__.py中的所有代码。如果我们在__init__.py中做太多事情，每次import都会有额外的运算，会造成没有必要的开销。一句话，init.py只是为了达到B中所表述的目的，其它事情就不要做啦。 上述来自: https://zhuanlan.zhihu.com/p/115350758 __all__变量 __all__是一个字符串list； 约束作用：用来定义模块中对于from XXX import *时要对外导出的符号，即要暴露的借口，但它只对import *起作用(即如果在使用脚本中对当前包使用import *，那么可以管理当前包下模块的导入情况)，对from XXX import XXX不起作用。","categories":[],"tags":[{"name":"防忘系列","slug":"防忘系列","permalink":"https://nymrli.top/tags/防忘系列/"}]},{"title":"emplace_back与push_back","slug":"emplace-back与push-back","date":"2020-10-18T15:14:49.000Z","updated":"2020-10-25T07:08:58.265Z","comments":true,"path":"2020/10/18/emplace-back与push-back/","link":"","permalink":"https://nymrli.top/2020/10/18/emplace-back与push-back/","excerpt":"","text":"之前看1002. 查找常用字符题解的时候，发现有人用了emplace_back，将char转型成了string塞进了vector&lt;string&gt;，感觉是个骚操作。 之前也看过emplace_back和push_back的区别， 只不过又忘记了， 因此本次也算个防忘系列把… 1234567vector&lt;string&gt; ans;for (int i = 0; i &lt; M; i++) &#123; for (int j = 0; j &lt; minFreq[i]; j++) &#123; // emplace_back 骚操作 ans.emplace_back(1, 'a' + i); &#125;&#125; 在STL中，进行插入元素的时候，有insert和push两种选择方式，而在有了右值引用和移动语义的时候，在C++11中就提出了更高效的插入方法：emplace_back 目前的趋势是希望：使用emplace_back()取代push_back() 据统计，emplace_back()函数要比push_back()函数要快一倍。 empalce与push的区别： push_back()函数向容器中加入一个临时对象（右值元素）时， 首先会调用构造函数生成这个对象，然后调用拷贝构造函数将这个对象的拷贝放入容器中， 最后释放临时对象，这样造成的问题是临时变量申请的资源就浪费。但是emplace_back()函数向容器中中加入临时对象， 临时对象原地构造，只有转移的过程，没有赋值或拷贝的操作（不需要触发拷贝构造）。 emplace_back中调用构造函数 官网demo Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt; struct President&#123; std::string name; std::string country; int year; // 构造函数 President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year)&#123; std::cout &lt;&lt; \"I am being constructed.\\n\"; &#125; // 转移构造函数 President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year)&#123; std::cout &lt;&lt; \"I am being moved.\\n\"; &#125; // 拷贝赋值操作符 President&amp; operator=(const President&amp; other) = default; // 拷贝构造函数&#125;; int main()&#123; std::vector&lt;President&gt; elections; std::cout &lt;&lt; \"emplace_back:\\n\"; // noted: 这边并没有写成President(\"Nelson Mandela\", \"South Africa\", 1994) elections.emplace_back(\"Nelson Mandela\", \"South Africa\", 1994); std::vector&lt;President&gt; reElections; std::cout &lt;&lt; \"\\npush_back:\\n\"; reElections.push_back(President(\"Franklin Delano Roosevelt\", \"the USA\", 1936)); std::cout &lt;&lt; \"\\nContents:\\n\"; for (President const&amp; president: elections) &#123; std::cout &lt;&lt; president.name &lt;&lt; \" was elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; &#125; for (President const&amp; president: reElections) &#123; std::cout &lt;&lt; president.name &lt;&lt; \" was re-elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; &#125;&#125; ▲看到noted标出来的地方后, 就能知道Leetcode题解中的骚操作其实就是根据T类型判断出了调用构造函数。按如下代码得证 123string a(1, 'a'+ 1);cout &lt;&lt; a &lt;&lt; endl;// &gt;&gt;&gt; b 引申：什么是std::move? 借鉴: c++ 之 std::move 原理实现与用法总结 在C++11中，标准库在&lt;utility&gt;中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue); 左值、左值引用、右值、右值引用概念 左值的声明符号为”&amp;”， 为了和左值区分，右值的声明符号为”&amp;&amp;”。 临时对象是作为右值处理的 右值引用的意义 直观意义：为临时变量续命，也就是为右值续命，因为右值在表达式结束后就消亡了，如果想继续使用右值，那就会动用昂贵的拷贝构造函数。（关于这部分，推荐一本书《深入理解C11》） 右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。 转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。 通过转移语义，临时对象中的资源能够转移其它的对象里。 在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。 普通的函数和操作符也可以利用右值引用操作符实现转移语义。 extra： std::move执行一个无条件的转化到右值。它本身并不移动任何东西； std::forward把其参数转换为右值，仅仅在那个参数被绑定到一个右值时； std::move和std::forward在运行时（runtime）都不做任何事。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"防忘系列","slug":"防忘系列","permalink":"https://nymrli.top/tags/防忘系列/"}]},{"title":"AutoLianliankan笔记","slug":"AutoLianliankan笔记","date":"2020-10-13T10:58:47.000Z","updated":"2020-10-14T04:35:38.806Z","comments":true,"path":"2020/10/13/AutoLianliankan笔记/","link":"","permalink":"https://nymrli.top/2020/10/13/AutoLianliankan笔记/","excerpt":"","text":"近来无事，又研究其了之前看到过的自动连连看的代码，碰到了一些问题， 因此做下笔记 pywin32 win32gui：定位窗体，操作窗体 win32api：提供API，操作鼠标、键盘 win32con：具体API事件 ==&gt;对于窗体的操作使用win32gui；而对键盘、鼠标操作可以用更高级封装的库pymouse、pykeyboard；剪切板使用win32clipboard 程序的设计： getWindowPosition=&gt;先确定游戏窗口位置pos，并置顶 getScreenImage()==&gt;在窗口置顶后再截图 getAllSquare()=&gt;找到游戏边界，pos[0]+100, pos[1]+100,即中间所有图块部分。切割出所有图案；getAllSquareTypes()将所有图案进行比较分类，归纳出所有不同的种类 1234567# ndarray的切片方法，[纵坐标起始位置：纵坐标结束为止，横坐标起始位置：横坐标结束位置]square = screen_image[game_y + y * SQUARE_HEIGHT :game_y + (y+1) * SQUARE_HEIGHT, game_x + x * SQUARE_WIDTH:game_x + (x+1) * SQUARE_WIDTH]# np.shape(square) == (65, 65, 3)# 因为有些图片的边缘不一致造成干扰（主要是空白区域的切图），所以把每张小方块向内缩小一部分再# 对所有的方块进行处理屏蔽掉外边缘 然后返回return [square[SUB_LT_Y:SUB_RB_Y, SUB_LT_X:SUB_RB_X] for square in all_square] getAllSquareRecord()==&gt;将不同种类的图案做映射，转换成相对应的数字矩阵。 autoRemove(result, board_pos)==&gt;执行自动消除 Matcher类==&gt;实现游戏规则: 横消，纵消， 单拐点消除，双拐点消除。需要注意跟QQ连连看不同的是没有实现更高阶的拐点消除。 附录: 遇到的问题 列表的清空 代码中有一段，在line满了后，会将line清空，再添加 123if len(line) == V_NUM: result.append(line) line = [] 注意： 这边的写法line = []是可行的。而line.clear()是不行的。原因是涉及内存空间引用问题 原因在于: list.clear()会清除当前变量指向的内存地址内容，而line = []其实是指向了另一块地址。因此导致了最终的结果是line = []的result为[[1,2,3...], [2, 3, 4...]]；而list.clear()的result全为空[[],[],[]]] 123456789a= [1, 2, 3]print(id(a))# 1785191184200a = [1, 2]print(id(a))# 1785191276296a.clear()print(id(a))# 1785191276296 图片的维度问题: 开源代码提供的empty.png图片规格为: 25*21像素。而25对应的为y， 21对应的为x。而需要注意的是在代码中，表达为img[0: 25, 0: 21] GetWindowRect窗口大小有误 1234567891011121314# 获取窗体坐标位置(左上)def getGameWindowPosition(): # FindWindow(lpClassName=None, lpWindowName=None) 窗口类名 窗口标题名 window = win32gui.FindWindow(None,WINDOW_TITLE) # 没有定位到游戏窗体 while not window: print('定位游戏窗体失败，5秒后重试...') time.sleep(5) window = win32gui.FindWindow(None,WINDOW_TITLE) # 定位到游戏窗体 win32gui.SetForegroundWindow(window) # 将窗体顶置 pos = win32gui.GetWindowRect(window) print(\"定位到游戏窗体：\" + str(pos)) return (pos[0],pos[1]) 如图操作下来, 发现返回的pos为(408, 172)，但用spy++抓到的窗口左上角坐标为(510, 215)，研究发现横、纵都是1.25倍， 以为是分辨率的问题，所以打开了“显示设置”，结果正好看到了缩放布局是125%，因此问题可能出现在这个设置上，果然修改为100%后，程序能够正常运行。 额外，百度也找到了这个问题——win32gui.GetWindowRect在win10上获取窗口宽高不正确的另一种可能; win32gui.GetWindowRect() 取值不准的解决方案——亲测这个无效 附录: config.py中需要注意的设置 12345678910111213# 方块宽度(算上了边界)SQUARE_WIDTH = 65# 方块高度(算上了边界)SQUARE_HEIGHT = 65# ==&gt; 所以每块的大小为(65, 65, 3)# 切片处理时候的左上、右下坐标：# 注意 这里要么保证是21*25(因为开源代码里的empty.png提供的是21*25像素的)。如果不是（比如四个数据是10,10,50,50；也就是40*40像素），那么就把empty.png图片替换成对应大小的一张图片（比如40*40）。图片可以没用，但程序中不能SUB_LT_X = 5SUB_LT_Y = 5# 下面两个值得小于60, 因此还有5是边界SUB_RB_X = 26SUB_RB_Y = 30","categories":[],"tags":[{"name":"GitCode","slug":"GitCode","permalink":"https://nymrli.top/tags/GitCode/"}]},{"title":"手撕操作系统中的页面置换算法","slug":"手撕操作系统中的页面置换算法","date":"2020-09-21T11:14:25.000Z","updated":"2020-12-21T04:06:55.121Z","comments":true,"path":"2020/09/21/手撕操作系统中的页面置换算法/","link":"","permalink":"https://nymrli.top/2020/09/21/手撕操作系统中的页面置换算法/","excerpt":"","text":"操作系统基础 内存换页算法 公平算法： 随机算法、先来先出（FIFO）算法、第二次机会算法、时钟算法 非公平算法： 最优OPT算法、NRU算法、LRU算法、工作集算法、工作集时钟算法 其中LRU算法会被面试的时候要求手撕， 因此本篇就稍微介绍一下LRU和LFU两个算法， 这两个算法除了在内存换页上会被使用到， 简单介绍一些算法： 随机更换算法 需要替换页面的时候，产生一个随机页面号，替换与该页面对应的物理页面。 先来先出（FIFO）算法 更换最早进入内存的页面。其中有Belady异常现象: 缺页率随内存块数增加而增加 最优OPT算法： 最佳置换算法是由Belady于1966年提出的一种理论上的算法。其所选择的被淘汰页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面。 采用最佳置换算法通常可保证获得最低的缺页率。 ▲由于人们目前还无法预知，一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的。 Q： 既然无法实现， 那么他的价值是什么呢？ A： 他被作为评价一个内存换页算法效率的标榜 NRU算法 最近未使用算法（Not Recently Used，NRU），就是选择一个最近没有被访问的页面来替换，在所有的最近没有使用的页面里，按照各个页面的修改位和访问位的组合来进行划分。相比LRU需要较多硬件支持， NRU算法在页表项设置两个状态位：引用位R和修改位M LRU Q、什么是 LRU 算法? A: Least Recently Used最近最久未使用算法，本质一种缓存淘汰策略。 计算机的缓存容量有限，如果缓存满了就要删除一些内容，给新内容腾位置。但问题是，删除哪些内容呢？我们肯定希望删掉哪些没什么用的缓存，而把有用的数据继续留在缓存里，方便之后继续使用。那么，什么样的数据，我们判定为「有用的」的数据呢？ LRU 缓存淘汰算法就是一种常用策略。LRU 的全称是 Least Recently Used，也就是说我们认为最近使用过的数据应该是是「有用的」，很久都没用过的数据应该是无用的，内存满了就优先删那些很久没用过的数据。 ▲同时它也是一种换页算法， 在内存换页上需要较多的硬件支持（计数器or栈） 常见的缓存算法 LRU (Least recently used) 最近最少使用，如果数据最近被访问过，那么将来被访问的几率也更高。 LFU (Least frequently used) 最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。 LFU由于涉及频率, 因此在代码实现上有个计数器来统计出现次数T，在需要换页（缓存更新的时候）将替换掉最低T的key FIFO (Fist in first out) 先进先出， 如果一个数据最先进入缓存中，则应该最早淘汰掉。 LRU算法与OPT算法比较 OPT是从“向后看”的观点出发的，即它是依据以后各页的使用情况进行判断，是理想状况；而LRU算法则是“向前看”的，即根据各页以前的使用情况来判断，而页面过去和未来的走向之间虽无必然的联系，但也有一定的预测关系。 总的来说，LRU算法是一种比较好的算法。 Q: 算法要求 LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。其中， get(key)的时候会把这个新查询的key放到最前端 由于性能要求，get 和 put 方法必须都是 O(1) 的时间复杂度。 get需要O(1) --&gt; hash or 线性表 put需要O(1) --&gt;链表 Coding实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package lru;import java.util.HashMap;import java.util.Map;public class LRUCache &#123; class Node &#123; Integer key; Integer val; // 双向列表: 前后向节点 Node nxt, prev; public Node() &#123; &#125; Node(int k, int v) &#123; this.key = k; this.val = v; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"key=\" + key + \", val=\" + val + '&#125;'; &#125; &#125; class DoubleList&#123; private int size; // 头尾空指针 private final Node head; private final Node tail; DoubleList() &#123; // 初始化 this.size = 0; this.head = new Node(); this.tail = new Node(); this.head.nxt = tail; this.tail.prev = head; &#125; /** * 将节点到头部, head-&gt;nxt = node; * @param node 待插入节点 */ public void addFirst(Node node)&#123; // 4个指针关系 node.nxt = head.nxt; node.prev = head; head.nxt.prev = node; head.nxt = node; // 记得增加当前容器Size this.size ++; &#125; public void remove(Node node)&#123; // 略过当前节点, 调整前后指针 node.nxt.prev = node.prev; node.prev.nxt = node.nxt; // 调整容器Size this.size--; &#125; public Node removeLast()&#123; // 删除尾节点, 为tail.prev Node node = tail.prev; // ▲笔误写错, 查了半小时 node.nxt= tail; remove(node); // 删除的时候还要在mp中删除索引, 因此要返回值 return node; &#125; public int getSize() &#123; return this.size; &#125; @Override public String toString() &#123; return \"DoubleList&#123;\" + \"size=\" + size + '&#125;'; &#125; &#125; int capacity; Map&lt;Integer, Node&gt; mp; DoubleList list; public LRUCache(int capacity) &#123; this.capacity = capacity; list = new DoubleList(); mp = new HashMap&lt;Integer, Node&gt;(); &#125; /** * 访问过的key对应的Node需要放到队首部(最近查询) * @param key 键 * @return 有相应的key则返回对应Node的val, 无则返回-1 */ public int get(int key) &#123; if ( mp.containsKey( key) )&#123; int res = mp.get(key).val; // ★ 把当前访问的放到队首 put(key, res); return res; &#125; else return -1; &#125; /** * 1. 如果已有key, 则删除容器中原有的Node, 将其放到队首 * 2. 如果没有key, * 2.1 如果容器已满, 则将队尾的排出, 再将新Node加在队首 * 2.2 如果容器未满, 则直接将新Node加在队首 * @param key * @param value */ public void put(int key, int value) &#123; Node node = new Node(key, value); if (mp.containsKey(key))&#123; list.remove(mp.get(key)); list.addFirst(node); mp.put(key, node); &#125;else&#123; if ( list.getSize() == capacity )&#123; Node last = list.removeLast(); mp.remove(last.key); &#125; list.addFirst(node); mp.put(key, node); &#125; &#125; @Override public String toString() &#123; return \"LRUCache&#123;\" + \"capacity=\" + capacity + \", mp=\" + mp.toString() + \", list=\" + list.toString() + '&#125;'; &#125;&#125; LeetCode代码检验 : 146. LRU缓存机制 算法实现参考： LRU算法：手把手带你实现一个干啥都快的快乐算法， 思路挺清晰的， 只不过只有LRUCache的代码， 需要自己实现双向链表 LFU LFU (Least frequently used) 最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。 LFU由于涉及频率, 因此在代码实现上有个计数器来统计出现次数T，在需要换页（缓存更新的时候）将替换掉最低T的ke 算法实现思路： O(1)查询： hash+ O(1)修改+频率排序：set 附录 参考链接: 【1】简单易懂，包你学会！ | 操作系统 | 页面置换 —— 认知性了解 操作系统-页面置换算法（OPT、FIFO、LRU、——换页过程","categories":[],"tags":[]},{"title":"docsify使用记录","slug":"docsify使用记录","date":"2020-09-15T02:30:43.000Z","updated":"2020-09-15T07:45:46.873Z","comments":true,"path":"2020/09/15/docsify使用记录/","link":"","permalink":"https://nymrli.top/2020/09/15/docsify使用记录/","excerpt":"","text":"Docsify 是什么？ Docsify 一个神奇的动态生成文档网站的工具。 不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html 文件，所有转换工作都是在运行时进行。 较多使用的场景是GitHub中对某一开源程序的文档介绍，由于docsify的主题较为好看， 且轻量、易使用，因此使用也较为广泛。同时它也支持很多插件来丰富功能。但跟Hexo相比，个人感官上Hexo更适合做个人博客， 而docsify更适合专门来写程序的介绍文档 春招的时候背了很多的面经， 只不过秋招回头来看基本上又都记不太清了，于是想自己整理些面经笔记啥的。 之前也试过在个人博客上发表， 只不过感觉还是不适合阅读，因此正好想起来之前了解过Docsify，因此这次打算在写面经的时候顺便也练习、熟练下Docsify。 官方文档快速使用介绍的很全了，先贴个官方文档。 Start to Run it 1.安装docsify工具:npm i docsify-cli -g 2.初始化项目: docsify init [./docs] , []中内容为指定生成目录, 不填默认为当前目录 初始化成功后，可以看到生成 目录下创建的几个文件 index.html 入口文件、插件等配置都写在这 README.md 会做为主页内容渲染，编辑即可更新文档内容 .nojekyll 用于阻止 GitHub Pages 忽略掉下划线开头的文件 3.预览效果： docsify serve [docs]， 通过运行 docsify serve 启动一个本地服务器，可以方便地实时预览效果。默认访问地址 http://localhost:3000 。 多页文档 定制化 自定义导航栏: 设置为 true 后会加载 _navbar.md 文件，也可以自定义文件名。 自定义侧边栏: 设置为 true 后会加载 _sidebar.md 文件，也可以自定义文件名。 启用封面页: 开启后是加载 _coverpage.md 文件，也可以自定义文件名。 markdown配置 插件 index.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; window.$docsify = &#123; name: 'Java工程师成神之路', repo: 'https://github.com/hollischuang/toBeTopJavaer', loadSidebar: true, subMaxLevel: 3, autoHeader: true, search: &#123; paths: 'auto', placeholder: '🔍 搜索 ', noData: '哎呀，没有找到呀！ ', // Headline depth, 1 - 6 depth: 3 &#125;, copyCode: &#123; buttonText : '复制', errorText : 'Error', successText: 'OK!' &#125;, pagination: &#123; previousText: '上一章', nextText: '下一章', &#125;, coverpage: true &#125;&lt;/script&gt;&lt;script src=\"//unpkg.com/docsify/lib/docsify.min.js\"&gt;&lt;/script&gt;&lt;!--代码块复制插件--&gt;&lt;script src=\"//unpkg.com/docsify-copy-code\"&gt;&lt;/script&gt;&lt;!-- 图片缩放插件 --&gt;&lt;script src=\"https://cyc-1256109796.cos.ap-guangzhou.myqcloud.com/zoom-image.min.js\"&gt;&lt;/script&gt;&lt;!--搜索插件--&gt;&lt;script src=\"https://cdn.bootcss.com/docsify/4.5.9/plugins/search.min.js\"&gt;&lt;/script&gt;&lt;!--语法高亮插件--&gt;&lt;script src=\"//unpkg.com/prismjs/components/prism-java.min.js\"&gt;&lt;/script&gt;&lt;script src=\"//unpkg.com/prismjs/components/prism-bash.min.js\"&gt;&lt;/script&gt;&lt;!--分页插件--&gt;&lt;script src=\"//unpkg.com/docsify-pagination/dist/docsify-pagination.min.js\"&gt;&lt;/script&gt;&lt;!--统计访问量插件--&gt;&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 附录： To Be Top Javaer - Java工程师成神之路","categories":[],"tags":[]},{"title":"数据结构——单调栈","slug":"数据结构——单调栈","date":"2020-09-08T11:25:38.000Z","updated":"2022-03-08T07:33:50.265Z","comments":true,"path":"2020/09/08/数据结构——单调栈/","link":"","permalink":"https://nymrli.top/2020/09/08/数据结构——单调栈/","excerpt":"","text":"秋季PAT的第一题就是单调栈，之前没怎么学过， 因此这次专门学习做下笔记。 单调栈Monotone Stack 概念: 从行为上看，它不仅仅是用存储与访问受限的栈，而是一种辅助工具，用于检测数据的单调性变化并作出反应（表现: 当入栈元素会影响栈总体单调性时，要出栈一些元素以维持单调性） 场景： 向左or向右找到第一个稍大（小）的元素、其索引下标； 确定某条件（单调）下的最长区间； 确定区间构成的极值，如max f（la，b]）； Point： 单调递增栈: 指栈内元素的出栈序列递增（或递减），而栈内元素是递减（或递增），即当元素比栈顶小的时候入栈。因此需要输出下一个最大的元素。 当然也有人是直接根据栈内元素大小关系来区别， 比如栈内元素递减就叫做递减栈。 此外没有双向栈的存在。 ==&gt;2021年10月26日——明确下定义：单调递减栈为出从栈底往栈顶看，元素大小成递减排列。其实上，正确的理解应该从扫描的角度来看，比如从左往右扫描时，如果元素依次递减，则统统会入栈，e.g. [4,2,1,5,8], ==&gt; 当5入栈时，单调递减的栈[4,2,1]横过来看就是原列表单调递减的子序列。 归纳： 当从左往右扫描维护单调递减栈时，可以求元素左边第一个比他大的元素，也可以求右边第一个比它大的元素 左边第一个比他大的元素：当以入栈元素的角度看时，如果栈内元素一直比它小，则不断pop，直到pop不出去元素，那么剩下的栈顶元素就是左边第一个比它大的元素 右边第一个比它大的元素：当以栈内元素的角度看时，把他pop出去的入栈元素就是当前栈顶元素右边第一个比它大的元素 可见：从不同的角度看，能得到不同的效果，代码编写的区别在于ans数组的更新：一个在while不断pop的过程中更新（栈内被弹走元素的角度），另一个是while到pop停下后更新（入栈元素的角度）。 实际上，左边第一个大的元素和右边第一个大的元素是等价的，因为当从左往右扫描时求右边第一个大的元素问题，当吧原序列翻转（或是从右往左扫描时），得到的结果就是对原序列而言每个数左边第一个大的元素。 核心思想 在元素Y入栈的时候会跟栈顶元素X比较， 如果Y比栈内所有元素Xs都大的话，就可以拿到栈里所有的元素即区间。关键是这个比较， 就可以找到第一个满足要求的数据。 e.g.有列表[1, 3, 2, 0, 7]，从左向右遍历，当遍历为7时栈里有[3, 2, 0]，此时入栈元素为7， 能得到==&gt;那么对于0来说，右边最大的就是当前入栈元素7， 左边最小的就是栈内下一个元素2。而对3来说，此时3上边的元素就都是比3小的元素们。 Code模板： 123456789def getFirstMax(nums: List[int]): # 站内元素递减栈， 输出序列递增 stack = [] for i in range(len(nums) - 1, -1, -1): val = nums[i] if stack and val &gt; stack[-1]: stack.pop() # 入栈操作在之前逻辑都执行完之哦吼，最后再入栈 stack.append(val) 这种写法， 主要是运用的stack.pop元素 例题 Leetcode#496： 单调栈 Leetcode #496. 下一个更大元素 I 12345678910class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: hash_dict = dict() stack = [] for i in nums2: while stack and i &gt; stack[-1]: # 在原有序列中比栈顶元素大的就是当前入栈元素i hash_dict[stack.pop()] = i stack.append(i) return [hash_dict.get(i,-1) for i in nums1] Leetcode#962. 最大宽度坡： 单调栈 Q： 为什么想到了单调栈？ A：参看题解：首先把A数组中的以A[0]开头的递减序列抽取出来，我们最后要求的最大的宽度坡一定是以这个序列中的某一个i为坡底的，我们反证一下 假设存在某个元素位置k不存在于上面的递减序列中，且有最大宽度j-k，这也就说明k位置的元素一定是小于k前面所有的元素的，否则就会有更长的宽度，但是既然k小于前面所有的元素，那么k就一定会被加入到序列中，与假设矛盾，所以不存在k，解一定存在递减序列中 这样的话我们可以逆向遍历数组，每次遇到元素大于栈顶的就可以计算宽度，然后将栈顶弹出，因为是逆序遍历的，所以这个宽度一定是栈顶这个坡底i能形成的最大宽度了， 逆序遍历再往前的话即使大于这个栈顶，形成的宽度也只会减小，所以这个栈顶是可以直接pop出去的，我们遍历所有的坡底求最大值就行了，时间复杂度O(N) 作者：resolmi https://leetcode-cn.com/problems/maximum-width-ramp/solution/java-dan-diao-zhan-er-fen-jie-fa-chang-shi-jie-shi/ 12345678910111213141516171819202122232425262728293031323334353637/* * @Author: Mrli * @Date: 2020-09-14 10:16:57 * @LastEditTime: 2020-09-14 11:03:29 * @Description: */#include &lt;bits/stdc++.h&gt;using namespace std;int maxWidthRamp(vector&lt;int&gt;&amp; A) &#123; stack&lt; int &gt; st; int len = A.size(); // 维护一个递减栈 for (int i = 0; i &lt; len; i++) &#123; if (st.empty() || A[i] &lt;= A[st.top()]) st.push(i); &#125; int ans = 0; int i = len - 1; while( i &gt; ans)&#123; // 根据单调栈的含义， 此时入栈A[i]， 可以得到 st.top() 右边比其大的为A[i]， 同时栈里也都是比A[i]小的元素 while( !st.empty() &amp;&amp; A[st.top()] &lt;= A[i] )&#123; // printf(\"A[%d]:%d A[%d]:%d\\n\", st.top(), A[st.top()], i, A[i] ); ans = max(ans, i - st.top()); st.pop(); &#125; i --; &#125; return ans;&#125; int main()&#123; vector&lt;int&gt; A = &#123;6,0,8,2,1,5&#125;; int ans = maxWidthRamp(A); cout &lt;&lt;ans &lt;&lt;endl; return 0;&#125; Leetcode#1124： 前缀和+单调栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;int longestWPI(vector&lt;int&gt;&amp; hours) &#123; int len = hours.size(); // hash for(int i = 0; i &lt; len; i ++ )&#123; if ( hours[i] &gt; 8) hours[i] = 1; else hours[i] = -1; &#125; // 1, 1, -1, -1, -1, -1, 1 vector&lt;int&gt; sum(len + 1, 0); for(int i = 1; i &lt;= len; i++ )&#123; sum[i] = sum[i - 1] + hours[i - 1]; &#125; stack&lt;int&gt; st; // 顺序生成单调栈，栈中元素从第一个元素开始严格单调递减，最后一个元素肯定是数组中的最小元素所在位置 for(int i = 0; i &lt;= len; i++ )&#123; if ( st.empty() || sum[i] &lt; sum[st.top()]) st.push(i); &#125; int ans = 0; /** 常规写法： */ for (int i = len; i &gt;= 0 ; i--) &#123; while( !st.empty() &amp;&amp; sum[st.top()] &lt; sum[i])&#123; ans = max(ans, i - st.top()); st.pop(); &#125; &#125; /** 写法二: */ int i = len; // 倒序扫描数组，求最大长度坡 while( i &gt; ans)&#123; // sum[st.top()] &lt; sum[i]实际就是找到 sum &gt; 0, 即后面索引j的sum - 前面索引i的sum &gt; 0 while( !st.empty() &amp;&amp; sum[st.top()] &lt; sum[i])&#123; ans = max(ans, i - st.top()); st.pop(); &#125; i -= 1; &#125; return ans;&#125; int main()&#123; vector&lt;int&gt; A = &#123;9,9,6,0,6,6,9&#125;; int ans = longestWPI(A); cout &lt;&lt;ans &lt;&lt;endl; return 0;&#125;// 此题单调栈具体怎么来的可以看题解： https://leetcode-cn.com/problems/longest-well-performing-interval/solution/can-kao-liao-ji-ge-da-shen-de-ti-jie-zhi-hou-zong-/ 参看：Bilibili【带写03】python前缀和与单调栈.mp4 单调队列 P1886 滑动窗口 /【模板】单调队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;// 这个写法可以借鉴一下struct node&#123; int val; int id; // 下标&#125;;vector&lt;int&gt; v1; // 最小vector&lt;int&gt; v2; // 最大int n, k;deque&lt;node&gt; q1;deque&lt;node&gt; q2;int main()&#123; cin &gt;&gt; n &gt;&gt; k; int val; for (int i = 1; i &lt;= n; i++) &#123; node nd; cin &gt;&gt; nd.val; nd.id = i; // 如果当前元素小于栈顶元素， 则栈顶元素出栈 // --&gt;获得栈顶小于当前预算 while( !q1.empty() &amp;&amp; nd.val &lt;= q1.back().val)&#123; q1.pop_back(); &#125; while( !q2.empty() &amp;&amp; nd.val &gt;= q2.back().val) q2.pop_back(); q1.push_back(nd); q2.push_back(nd); if ( i - q1.front().id + 1 &gt; k) q1.pop_front(); // 如果栈底元素已经超出边界则出栈 if ( i - q2.front().id + 1 &gt; k) q2.pop_front(); if (i &gt;= k)&#123; // 当索引满足窗口大小的时候才进行操作 v1.push_back(q1.front().val); // 栈底元素为当前k窗口中最小的 v2.push_back(q2.front().val); // 栈底元素为当前k窗口中最大的 &#125; &#125; int len = v1.size(); for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; v1[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; len = v2.size(); for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; v2[i] &lt;&lt; \" \"; &#125; return 0;&#125; holiday 题目描述 经过几个月辛勤的工作，FJ决定让奶牛放假。 假期可以在1…N天内任意选择一段（需要连续），每一天都有一个享受指数W。但是奶牛的要求非常苛刻，假期不能短于P天，否则奶牛不能得到足够的休息；假期也不能超过Q天，否则奶牛会玩的腻烦。 FJ想知道奶牛们能获得的最大享受指数。 输入格式 第一行：N,P,Q. 第二行：N个数字，中间用一个空格隔开。 输出格式 一个整数，奶牛们能获得的最大享受指数。 样例数据 input 125 2 4-9 -4 -3 8 -6 output 15 Hint 选择第3-4天，享受指数为-3+8=5。 数据规模与约定 50% 1≤N≤10000，100% 1≤N≤100000 时间限制：1s， 空间限制：256MB 思路： 用前缀和处理前i天的指数和 其实就是从P的位置开始枚举，每次把i-P压入队列，如果i-Q大于队首元素的位置，弹出队首 每次取出队首让ans=max（sum[i]-sum[Day.front()]） 最后输出ans 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;#define INF 9999999999long long sum[100300];int n,p,q;long long ans=-INF;deque&lt;long long&gt; Day; int main()&#123; freopen(\"holiday.in\",\"r\",stdin); // freopen(\"holiday.out\",\"w\",stdout); scanf(\"%d%d%d\",&amp;n,&amp;p,&amp;q); long long x; // 前缀和 for(int i=1;i&lt;=n;i++)&#123; scanf(\"%lld\",&amp;x); sum[i]=sum[i-1]+x; &#125; for(int i=p;i&lt;=n;i++)&#123; int nowIndex = i - p; // 指数和小的放前面 while(!Day.empty() &amp;&amp; sum[nowIndex] &lt; sum[Day.back()] ) Day.pop_back(); Day.push_back(nowIndex); // 实际上应该理解为 当前日期i - 队首的日期 &gt; Q天, 则让pop_front while(!Day.empty() &amp;&amp; i - q &gt; Day.front()) Day.pop_front(); // sum[i] - sum[Day.front()] 为索引i~Day.front()这几天的指数和 ans=max(ans, sum[i]-sum[Day.front()]); &#125; cout&lt;&lt;ans; return 0;&#125; 总结: 单调队列对于处理线性滑动区间最值可谓游刃有余 借鉴: 数据结构之单调队列与单调栈 单调栈 P2866 [USACO06NOV]Bad Hair Day S 根据题目细品: 第N头牛站最前面, 第1头站最后面, 然后如果Hi &gt; Hn, 则能看到。要求累加第i头牛能看到前面牛的头发数， 即可以理解为第i头牛往前看， 找到比它大的Hi或者边界（边界可以看做为Hi=0的）。===&gt; 输入样例从左往右找比当前元素大的第一个元素，单调递减栈–&gt;正常for i = 0 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const long long INF = 0x3f3f3f3f;int n;struct cow&#123; int id; int height;&#125;;stack&lt;cow&gt; st;int main()&#123; int tmp; int ans = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; // C_i的高度 cin &gt;&gt; tmp; // 找到比当前元素大的一个元素， 期间小的都累计 while( !st.empty() &amp;&amp; tmp &gt;= st.top().height ) &#123; ans += ( i - st.top().id - 1); st.pop(); &#125; st.push(&#123;i, tmp&#125;); &#125; // 到最后的时候， 剩下的递减的都是前面没有比自己高的牛了， 如样例最后剩5&lt;-6， 那么6(2)前面没数字了， 所以为0， 5前面(12)只有6了，且6的2高&lt;5的12高， 因此6-5=1有1头牛 while(!st.empty())&#123; int now = st.top().id; st.pop(); ans += (n - now); &#125; cout &lt;&lt; ans &lt;&lt;endl; return 0;&#125; 思路2： 每次输入一头牛的身高，找比这头牛矮的，出栈 剩下的牛皆可以看到这只牛 ans值加等于栈中牛的个数 这头牛入栈 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int n,t;long long ans; //注意要开long long stack &lt;int&gt; a;int main() &#123; cin&gt;&gt;n; for (int i=1; i&lt;=n; i++) &#123; cin&gt;&gt;t; // 将栈内删到全都是比t的高的 while (!a.empty() &amp;&amp; t &gt;= a.top() ) a.pop(); // 那么栈里的元素都能看到i ans+=a.size(); // 注意： 先size后push a.push(t); &#125; cout&lt;&lt;ans; return 0;&#125; 气温 列表 #739 每日温度 从左往右找比当前元素大的–&gt;如果当前元素比栈顶元素大，那么栈顶元素右边比其第一个大的元素就是当前入栈元素—&gt;单调递减栈（从栈底到栈顶递减）–&gt;val &gt; st.top()，正常for i = 0 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3;int n;int ans[maxn]; // 答案struct temperature&#123; int id; int tmp;&#125;;/**input:873 74 75 71 69 72 76 73output:1 1 4 2 1 1 0 0*/int main()&#123; stack&lt;temperature&gt; st; cin &gt;&gt; n; int val; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; val ; while ( !st.empty() &amp;&amp; val &gt; st.top().tmp )&#123; ans[st.top().id] = i - st.top().id ; st.pop(); &#125; st.push(&#123;i, val&#125;); // 塞进去的是索引 &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt;ans[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; return 0;&#125; 逆序写： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3;int n;int ans[maxn]; // 答案struct temperature&#123; int id; int tmp; temperature()&#123;&#125; temperature(int _id, int _tmp): id(_id), tmp(_tmp)&#123;&#125;&#125;;/**input:873 74 75 71 69 72 76 73output:1 1 4 2 1 1 0 0*/int main()&#123; stack&lt;temperature&gt; st; cin &gt;&gt; n; int val; vector&lt;int&gt; v(n+1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125; for (int i = n; i &gt;= 1; i--) &#123; int val = v[i]; while( !st.empty() &amp;&amp; val &gt;= st.top().tmp) st.pop(); ans[i] = st.empty()? 0 : st.top().id - i; st.push(temperature(i, val)); &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt;ans[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; return 0;&#125; P5788 【模板】单调栈 模板写法 123456789101112131415161718192021222324252627// ▲不知道为啥必须点开洛谷的O2优化才不会被卡后面4个点#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3;int n;int main()&#123; scanf(\"%d\", &amp;n); vector&lt;int&gt; v; v.resize(n+1); stack&lt; pair&lt;int, int&gt; &gt; st; vector&lt;int&gt; ans(n+1); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;v[i]); while( !st.empty() &amp;&amp; v[i] &gt; v[st.top().first])&#123; ans[ st.top().first ] = i; st.pop(); &#125; st.push(&#123;i, v[i]&#125;); &#125; // 遍历完的时候栈里其实还有元素 // cout &lt;&lt; \"size: \"&lt;&lt;st.size() &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; if ( i == 1) printf(\"%d\", ans[i]); else printf(\" %d\", ans[i]); &#125; return 0;&#125; for遍历倒着写 12345678//myfor (int i = n; i &gt;= 1 ; i--) &#123; while( !st.empty() &amp;&amp; v[i] &gt;= v[st.top().first])&#123; st.pop(); &#125; ans[ i ] = st.empty() ? 0: st.top().first; st.push(&#123;i, v[i]&#125;);&#125; // 找的题解 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[3000001],b[3000001];stack&lt;int&gt; q;//开一个STL的栈 栈里面存的是数的下标即位置int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];//输入 for(int i=n;i&gt;=1;i--)&#123; while(!q.empty() and a[q.top()]&lt;=a[i])//查找第一个大于a[i]的数 q.pop(); //否则就直接出栈 if(q.empty()) //如果最后没有比a[i]大的数 b[i]=0; else b[i]=q.top(); //否则就记录下来 q.push(i); //将i入栈 &#125; for(int i=1;i&lt;=n;i++) cout&lt;&lt;b[i]&lt;&lt;\" \";//输出答案 结束 return 0;&#125; 区别在于： 站内元素是栈顶元素的右边； 而顺着写， 那么栈内元素是栈顶元素的左边， 即栈顶元素为站内元素的右边；同时还有一个区别是： 顺着先能边读边写， 而倒着写必须读完再写 不用v[]的写法, 其实直接可以用stack&lt; pair&lt;int, int&gt; &gt;st来写，可能会更直观一些 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3;int n;int main()&#123; int val; scanf(\"%d\", &amp;n); stack&lt; pair&lt;int, int&gt; &gt; st; vector&lt;int&gt; ans(n+1); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;val); while( !st.empty() &amp;&amp; val &gt; st.top().second )&#123; ans[ st.top().first ] = i; st.pop(); &#125; st.push(&#123;i, val&#125;); &#125; for (int i = 1; i &lt;= n; i++) &#123; if ( i == 1) printf(\"%d\", ans[i]); else printf(\" %d\", ans[i]); &#125; return 0;&#125; 总结 单调栈可利用的点: 剩下的元素 跟 当前元素的关系；弹出元素的个数；剩余元素的个数 栈顶 和 当前元素的关系==&gt; 找到第一个比数大、小的 递减栈的while中条件写 val &gt; st.top()的时候pop，正着写和反着写都一样， 但是要注意等于号的区别；顺着写判断条件完全满足题意（利用pop的动作做处理），而逆着则要考虑先后，如气温题，找第一个反而要加等号， 要pop掉直到左边第一个出现。 === 一般情况下，都是写while()里只有pop的，nums[i] &lt; nums[st.peek()]==&gt;st.pop();，则是维护了一个单调递增栈，对于剩下的栈顶元素而言，入栈元素是&gt;=栈顶元素的，并且对于入栈元素而言找到的是左边第一个大于他的数。单调递减栈，则求的是左边第一个比他小的数。 ===&gt; 如果要求右边的，法一：逆序构建单调栈；法二：从栈顶元素的视角来看(赋值在while里面)，只不过这种做法最终栈里会有剩余元素，因此需要对记录数组赋初值。如：2055. 蜡烛之间的盘子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123; public int[] platesBetweenCandles(String s, int[][] queries) &#123; int len = s.length(); int[] arr = new int[len]; // 当前元素前面拥有的*数 for (int i = 1; i &lt; len; i++) &#123; char c = s.charAt(i - 1); if (c == '*') &#123; arr[i] = arr[i - 1] + 1; &#125; else &#123; arr[i] = arr[i - 1]; &#125; &#125; Stack&lt;Integer&gt; minSt = new Stack&lt;&gt;(); Stack&lt;Integer&gt; maxSt = new Stack&lt;&gt;(); // 右边下标最小的蜡烛 int[] minRight = new int[len], maxLeft = new int[len]; // 得赋初值 Arrays.fill(minRight, len); Arrays.fill(maxLeft, -1); for (int i = 0; i &lt; len; i++) &#123; char c = s.charAt(i); // 如果当前是|则最近的就是自己 if ( c == '|')&#123; minRight[i] = i; maxLeft[i] = i; &#125; // **得入栈 while (!minSt.empty() &amp;&amp; c == '|' &amp;&amp; s.charAt(minSt.peek()) == '*') &#123; minRight[minSt.peek()] = i; minSt.pop(); &#125; minSt.push(i); char ch = s.charAt(len - i - 1); while (!maxSt.empty() &amp;&amp; ch == '|' &amp;&amp; s.charAt(maxSt.peek()) == '*') &#123; maxLeft[maxSt.peek()] = len - i - 1; maxSt.pop(); &#125; maxSt.push(len - i - 1); &#125; int[] ans = new int[queries.length]; for (int i = 0; i &lt; queries.length; i++) &#123; int l = queries[i][0], r = queries[i][1]; int ll = minRight[l], rr = maxLeft[r]; if (ll &lt; rr) &#123; ans[i] = arr[rr] - arr[ll]; &#125;else&#123; ans[i] = 0; &#125; &#125; return ans; &#125;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"扇区、块/簇","slug":"扇区、块-簇","date":"2020-09-06T06:29:31.000Z","updated":"2020-09-06T07:04:38.846Z","comments":true,"path":"2020/09/06/扇区、块-簇/","link":"","permalink":"https://nymrli.top/2020/09/06/扇区、块-簇/","excerpt":"","text":"扇区 概念： 扇区，顾名思义，每个磁盘有多条同心圆似的磁道，磁道被分割成多个部分。每部分的弧长加上到圆心的两个半径，恰好形成一个扇形，所以叫做扇区。扇区是磁盘中最小的物理存储单位。 扇区大小: 512B -&gt; 4KB 扇区(Sector)大小是固定的，默认情况下，每个扇区（Sector）为512字节，2009年后，硬盘厂商开始发布4KB字节扇区的硬盘了，4KB扇区硬盘已经在消费级市场广泛应用。但是同一块硬盘上的扇区大小一定是一致的。不可能存在多种不同大小的扇区。 逻辑扇区、物理扇区 物理扇区是磁盘上真实存在对应的扇区； 逻辑扇区是由于扇区大小由512B变成4KB后， 为了与老系统兼容，操作系统层面上提出来的一个概念，是为了方便操作系统读取写入硬盘数据而设置的， 给系统进行识别后，可以通过一定的公式与物理地址对应再找到到指定的物理扇区上去。 由来 关于物理扇区（physical setctor）与逻辑扇区，这个还得扯上扇区大小，由于近年来，随着对硬盘容量的要求不断增加，为了提高数据记录密度，硬盘厂商往往采用增大扇区大小的方法，于是出现了扇区大小为4096字节的硬盘。我们将这样的扇区称之为“物理扇区”。但是这样的大扇区会有兼容性问题，有的系统或软件无法适应。为了解决这个问题，硬盘内部将物理扇区在逻辑上划分为多个扇区片段并将其作为普通的扇区（一般为512字节大小）报告给操作系统及应用软件。这样的扇区片段我们称之为“逻辑扇区”。实际读写时由硬盘内的程序（固件）负责在逻辑扇区与物理扇区之间进行转换，上层程序“感觉”不到物理扇区的存在。 逻辑扇区是硬盘可以接受读写指令的最小操作单元，是操作系统及应用程序可以访问的扇区，多数情况下其大小为512字节。我们通常所说的扇区一般就是指的逻辑扇区。物理扇区是硬盘底层硬件意义上的扇区，是实际执行读写操作的最小单元。是只能由硬盘直接访问的扇区，操作系统及应用程序一般无法直接访问物理扇区。一个物理扇区可以包含一个或多个逻辑扇区（比如多数硬盘的物理扇区包含了8个逻辑扇区）。当要读写某个逻辑扇区时，硬盘底层在实际操作时都会读写逻辑扇区所在的整个物理扇区。 参考： 存储基础知识：扇区与块/簇——带物理结构图 块/簇 **概念：**块（Block）/簇（Cluster）是逻辑上的概念，或者说是虚拟出来的概念（逻辑概念）。 分别对应Linux与Windows操作系统中的概念。 通俗的来讲，在Windows下如NTFS等文件系统中叫做簇；在Linux下如Ext4等文件系统中叫做块（block）。每个簇或者块可以包括2、4、8、16、32、64…2048、4096等2的n次方个扇区。 为什么要用磁盘块/簇？ A： 读取方便：由于扇区的Size比较小，数目众多时寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。(操作系统通过操作块， 来间接操作底层磁盘对扇区的读取，先找街道再找门户) 分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位。 扇区与块/簇的区别 磁盘的读写基本单位是扇区。 磁盘的原理，物理实现，磁盘控制器是按照扇区这个单位读取等操作数据的。 文件系统就是操作系统的一部分，所以**文件系统读写(操作文件)**的最小单位是块。 操作系统是通过块/簇来做为单位读取等操作数据的。 and 从磁盘的物理结构来看存取信息的最小单位是扇区，一个扇区是512字节； 从操作系统对硬盘的存取管理来看，存取信息的最小单位是簇，簇是一个逻辑概念，一个簇可以是2、4、8、16、32或64个连续的扇区。 一个簇只能被一个文件占用，哪怕是只有1个字节的文件，在磁盘上存储时也要占用一个簇，这个簇里剩下的扇区是无用的。例如用NTFS文件系统格式化的时候默认是8个扇区组成一个簇，即4096字节。所以你如果保存了一个只有1字节的文件（例如字母N），它在磁盘上实际也要占用4096字节（4K），所以“簇”也可以理解为操作系统存取信息的最小单位。 QA: Q、为什么磁盘块大小必须是扇区大小的整数倍呢？ A: 磁盘读取数据的基本单位就是一个扇区的大小，一个块的大小对于磁盘来说就是一次获取数据读取的扇区数*扇区大小，如果是整数倍的扇区数对于磁盘的IO更好，速度更快，也会更合理的利用资源。否则会对扇区进行分割。 Q、那么分成“大簇”和“小簇”有什么区别呢？ A：我如果硬盘下很多小文件，那么每一个小文件，都会占用一个“簇”。虽然这些小文件都小于一个“簇”。 “大簇”和“小簇”当然有很多区别，但是最大的区别是：“小簇”会节省空间，而“大簇”则反之。“大簇”的优势在于有益于文件的读取存取，简单而不严谨的说就是提升硬盘性能。 “大簇”——读取存取速度快，占用空间大 “小簇”——读取存取速度慢，占用空间小 而现在TB时代，即便是“大簇”大家完全也HOLD住，即便你全部是几KB、几字节的小文件。“大簇”盘也不会“小簇”盘多占出太多空间，但是性能的提升确是最少几倍的，特别是面对大型程序或者游戏的时候。 4K 4K对齐的意思是对齐到磁盘开头的4K这个数值。和按4K来格式化不是一回事。 Ans1: 4K对齐 随着时代发展，硬盘容量不断扩展，使得之前定义的每个扇区512字节不再是那么的合理，于是将每个扇区512字节改为每个扇区4096 个字节，也就是现在常说的“4K扇区”。随着NTFS成为了标准的硬盘文件系统，其文件系统的默认分配单元大小（簇）也是4096字节，为了使簇与扇区相对应，即使物理硬盘分区与计算机使用的逻辑分区对齐，保证硬盘读写效率，所以就有了“4K对齐”的概念。 新标准的”4K扇区”的硬盘在厂商为了保证与操作系统兼容的前提下，也将扇区模拟成512B（逻辑扇区），会默认定义为4096字节大小为一个簇，但因为其引导区占用了一个磁道共63个扇区，真正的文件系统在63号扇区之后。 我们通过计算得出前63个扇区大小为：512Bx63=32256B。并按照默认簇大小得出63扇区为：32256B÷4096B=7.875簇 即从第63个扇区结束，往后的每一个簇都会跨越两个物理单元，占据前一个单元的一小部分和后一个单元的一大部分。 而“4K对齐”主要是将硬盘的模拟扇区(512B)对齐到8的整数倍个“实际”4K扇区，即4096B*8=32768B，其正好跨过了63扇区的特性，从第64个扇区对齐。 Ans2: 4K格式化 4k对齐是硬盘分区中的一个专业术语，4K对齐就是符合4K扇区定义格式化过的硬盘，并且按照4K扇区的规则写入数据。一般来说，在给固态硬盘进行分区的时候，一定要勾选上4K对齐，否则会影响到SSD固态硬盘的性能与寿命。通俗的说，如果SSD不进行4K对齐，写入数据的写入点正好会介于两个4K扇区的之间，也就是说即使是写入最小量的数据，也会使用到两个4K扇区，这样会造成跨区读写，读写次数放大，从而影响磁盘性能。 SSD中的4K对齐的4K指4096字节，其中1个扇区为512字节。固态硬盘4K对齐中的2048是指2048个扇区，即 512B*2048=1048576B=1024KB，即1M对齐（4096就是2MB对齐），并满足4K对齐，该值只要是4096B的倍数就是4K对齐，理论上4K对齐只要是4096整数倍就可以，不过标准的一般都是选择4096。从实测来看，固态硬盘4K对齐选2048还是4096，性能区别并不大，小容量固态硬盘4K对齐，选择2048扇区对齐是可以的。而在Win10或者大容量SSD场景下，建议还是选默认的4096扇区对齐。 分区操作","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"SQL练习","slug":"SQL练习","date":"2020-09-04T07:54:57.000Z","updated":"2020-11-08T05:12:45.626Z","comments":true,"path":"2020/09/04/SQL练习/","link":"","permalink":"https://nymrli.top/2020/09/04/SQL练习/","excerpt":"","text":"SQL练习 鉴于同学被字节狂问SQL题，因此也激发了我的危机感。 作为非科班的， 写SQL还是比较慌的， 因此做下专题训练。 理论知识: SQL语句执行顺序 1.sql执行顺序 12345678910(1) from (3) join (2) on (4) where (5) group by(开始使用select中的别名，后面的语句中都可以使用)(6) avg,sum.... (7) having (8) select (9) distinct (10) order by 2.sql语句执行顺序 12345678910(8) SELECT (9)DISTINCT&lt;select_list&gt;(1) FROM &lt;left_table&gt;(3) &lt;join_type&gt; JOIN &lt;right_table&gt;(2) ON &lt;join_condition&gt;(4) WHERE &lt;where_condition&gt;(5) GROUP BY &lt;group_by_list&gt;(6) WITH &#123;CUBE|ROLLUP&#125;(7) HAVING &lt;having_condition&gt;(10) ORDER BY &lt;order_by_list&gt;(11) LIMIT &lt;limit_number&gt; 用group by需要注意的: 在select指定的字段 要么就是包含在Group By语句的后面，为作为分组的依据的字段； 要么就要被包含在聚合函数中, e…g: sum, avg, count。 SQL查询语句中的 limit 与 offset 的区别： limit y 分句表示: 读取 y 条数据 limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据 limit y offset x 分句表示: 跳过 x 条数据，读取 y 条数据 分页操作 语法：limit开始索引，每页查询的记录数 注：索引从0开始 公式：开始索引=（当前页码-1）*每页查询的记录数即 index = (nowPageNum - 1) * pageSize 123456SELECT * FROM table WHERE 查询条件 ORDER BY 排序条件 LIMIT ((页码-1)*页大小),页大小;-- LIMIT (pageNum-1)*pageSize, pageSize-- 第一个参数是偏移量， 第二个是所取数据数 引号区别 在标准 SQL 中，字符串使用的是单引号。 如果字符串本身也包括单引号，则使用两个单引号（注意，不是双引号，字符串中的双引号不需要另外转义）。 但在其它的数据库中可能存在对 SQL 的扩展，比如在 MySQL 中允许使用单引号和双引号两种。 MySQL 参考手册： 字符串指用单引号'或双引号&quot;引起来的字符序列。例如： ‘a string’ “another string” 如果SQL服务器模式启用了NSI_QUOTES，可以只用单引号引用字符串。用双引号引用的字符串被解释为一个识别符。 1234567891011121314使用双字符:插入时 库中'aa''b''cc' aa'b'cc\"aa\"b\"\"cc\" aa\"b\"cc使用转义字符(\\):插入时 库中'aa\\'b\\'cc' aa'b'cc\"aa\\\"b\\\"cc\" aa\"b\"cc在单引号包裹的字符串中使用双引号、在双引号包裹的字符串中使用单引号 不需要使用双引号或转义字符。插入时 库中\"aa'b'cc\" aa'b'cc'aa\"b\"cc' aa\"b\"cc 反引号（`） 12345678910保留字不能用于表名，比如desc，此时需要加入反引号来区别，但使用表名时可忽略反引号。create table desc报错create table `desc`成功create table `test`成功drop table test成功 保留字不能用于字段名，比如desc，此时也需要加入反引号，并且insert等使用时也要加上反引号。create table `test`（`desc` varchar(255)）成功insert into test(desc) values('fxf')失败insert into test(`desc`) values('fxf')成功 +号 字符串数据是用单引号包在外面的，而+号只是用来连接这些字符串的. 数据库里的字段是整型的时候不要加单引号，是字符串的时候要加，其它类型根据实际情况来,双引号就是用来拼接字符串的，单引号是sql文的固有写法，因为你要动态的来拼接，涉及到变量，所以要用“+”来组合各个字符串片段。最终结果无非就是得出能在数据库查询分析器中执行的sql文。 123String sql = \"insert into student values ( \" + student.getId() + \" ,' \" + student.getUsername() + \" ', \" + student.getAge() + \" ,' \" + student.getClassnumber()+\" ')\"; 因为id和age是int型的所以不用加单引号，你的Username在数据库中定义的是一个varchar型的,而对字符型进行条件查询的时候是要加 ’ '号的：select count(*) from student where username= 'aaa ' 因此在后台写查询字符串的时候就必须这样写: string sql = &quot;select count(*) from student where username= ' &quot;+userName+ &quot; ' &quot;，这样映射成的查询语句就是: select count(*) from student where student= 'aaa ' 了. 题目 1 查找最晚入职员工的所有信息(入门题) 1select * from employees order by hire_date limit 1; 2查找入职员工时间排名倒数第三的员工所有信息 123select * from employees order by hire_date desc -- 递减排序limit 2,1 ; -- offset 2， 取1 SQL查询语句中的 limit 与 offset 的区别： limit y 分句表示: 读取 y 条数据 limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据 limit y offset x 分句表示: 跳过 x 条数据，读取 y 条数据 3 查找各个部门当前领导当前薪水详情以及其对应部门编号dept_no 123456select s.*, d.dept_no from salaries as s join dept_manager as d on s.emp_no = d.emp_nowhere d.to_date='9999-01-01' and s.to_date='9999-01-01'order by s.emp_no; 4 查找所有已经分配部门的员工的last_name和first_name 1234select e.last_name, e.first_name, d.dept_no from employees e inner join dept_emp d on e.emp_no = d.emp_no; 5查找所有员工的last_name和first_name以及对应部门编号dept_no 暂时没有分配具体部门的员工==&gt; employees有信息, 而dept_emp表中可能还没有信息；两表联合查询时以employees为准， 匹配不到dept_emp的数据用null填充—&gt;所以用外部联结的左联结 1234select e.last_name, e.first_name, d.dept_no from employees eleft join dept_emp don e.emp_no = d.emp_no join 内联结(Inner join) 联接仅返回两个联接表中都具有匹配项的行。例如，您可以将employees和departments表联接在一起，以创建一个显示每个雇员的部门名称的结果集。在内部联接中，没有部门信息的雇员不包括在结果集中，没有雇员的部门也不会包括在结果集中。 外联结(Outer join) 外联接是内部联接的扩展。 即使外联接在联接表中没有相关行，外联接也会返回这些行。 外联接共有三种类型：左联接（left join），右联接（right join）和完全联接（full join）。 left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等（有匹配项）的记录 ，否则用NULL right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录 inner join(等值连接) 只返回两个表中联结字段相等的行 总结: inner join是两集合取交集 FULL [OUTER] JOIN: 两集合取并集 left [outer] join: 产生表A的完全集, B中有匹配则有值, 没匹配则为null left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID). B表记录不足的地方均为NULL填充. Q: 最上层的两张图分别是全A和全B，那么left join和right join的作用是什么呢? A: 联表查询, 拓展字段 6 查找所有员工入职时候的薪水情况 两表并列查找，题目重点在于: 有多条薪水信息中找出入职时候的薪水情况 1234select e.emp_no, s.salary from employees e, salaries swhere e.emp_no = s.emp_no and e.hire_date = s.from_dateorder by e.emp_no desc 联表查询 12345select e.emp_no,s.salary from employees eleft join salaries swhere e.emp_no= s.emp_no and e.hire_date = s.from_date order by e.emp_no desc 7查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t 将select出来的数据重命名 having用法 12345select s.emp_no, count(s.emp_no) as tfrom salaries sgroup by s.emp_nohaving count(salary) &gt; 15 -- 由于吧count(s.emp_no)替换成t了, 因此这边可以写成 having t &gt; 15, 见执行顺序avg,count等聚合函数优先于having Question: Q: select count(s.emp_no) as t的执行顺序在having t &gt; 15之前吗? A: No是聚合函数count优先于having SQL 别名: AS SQL 别名用于为 表 或 表中的列 提供临时名称。 SQL 别名通常用于使 表名 或 列名 更具可读性。 SQL 一个别名只存在于查询期间。 别名使用 AS 关键字赋予。 什么情况下需要给表起别名？ 1.表名比较长 2.当需要在多个表中进行查询并把查询内容同时输出的时候 3.当需要进行表连接的时候（其实和2一个意思，一般情况下多个表进行连接主要目的就是为了从多个表中查询所需要的内容） having 在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。 HAVING 子句可以让我们筛选分组后的各组数据。 聚合函数 聚合函数对一组值执行计算并返回单一的值 聚合函数有什么特点？ 除了 COUNT 以外，聚合函数忽略空值。 聚合函数经常与 SELECT 语句的 GROUP BY 子句一同使用。 所有聚合函数都具有确定性。任何时候用一组给定的输入值调用它们时，都返回相同的值。 标量函数：只能对单个的数字或值进行计算。主要包括字符函数、日期/时间函数、数值函数和转换函数这四类。 8 找出所有员工当前具体的薪水salary情况 1234567891011select distinct salary from salarieswhere to_date = '9999-01-01'order by salary desc-- 或者使用group byselect salary from salaries where to_date = '9999-01-01' group by salaryorder by salary desc 说明： 对于distinct与group by的使用： 1.当对系统的性能高并且数据量大时使用group by 2.当对系统的性能不高时或者使用数据量少时两者借口 3.尽量使用group by 9获取所有部门当前manager的当前薪水情况 12345678910-- 用where连接并列查询的两表select d.dept_no, s.emp_no, s.salary from dept_manager as d, salaries as swhere d.emp_no = s.emp_no and d.to_date='9999-01-01' and s.to_date='9999-01-01';-- 用inner join合并两表select d.dept_no, s.emp_no, s.salaryfrom dept_manager as dinner join salaries as son d.to_date = '9999-01-01' and s.to_date = '9999-01-01' and d.emp_no = s.emp_no; 10 获取所有非manager的员工emp_no 把在dept_manager中的都筛选掉, 之前join的练习: A - A∩B 12345678910111213-- LEFT JOIN左连接 + IS NULLselect e.emp_nofrom employees as eleft join dept_manager don e.emp_no = d.emp_no where d.emp_no is null-- where d.emp_no isnull 中 isnull是个关键字, 正确用法是-- ISNULL ( check_expression , replacement_value )将被检查是否为 NULL的表达式替换为replacement_value-- NOT IN+子查询select emp_nofrom employees where emp_no not in (select emp_no from dept_manager) 使用见: #join 只有left join的效果 加上is null的效果 ==&gt; 找出B表中emp_no不匹配的(他们填充的数据都是null) 11 获取所有员工当前的manager 123456789101112-- myselect de.emp_no, dm.emp_no as manager_nofrom dept_emp as deleft join dept_manager dmon de.dept_no = dm.dept_nowhere dm.to_date ='9999-01-01' and dm.emp_no != de.emp_no-- 题解: INNER JOIN+不等于; 不等于可以用&lt;&gt;或者!=表示SELECT de.emp_no, dm.emp_no AS manager_no FROM dept_emp AS de INNER JOIN dept_manager AS dmON de.dept_no = dm.dept_no WHERE dm.to_date = '9999-01-01' AND de.to_date = '9999-01-01' AND de.emp_no &lt;&gt; dm.emp_no 12 获取所有部门中当前员工薪水最高的相关信息 12345select de.dept_no, de.emp_no, max(s.salary) from dept_emp as de inner join salaries as son s.emp_no = de.emp_no and de.to_date = '9999-01-01' and s.to_date = '9999-01-01'group by de.dept_no 使用GROUP BY子句时，SELECT子句中只能有聚合键、聚合函数、常数。 13 从titls表获取按照title进行分组 1234select title, count(title) as tfrom titlesgroup by titlehaving t &gt;= 2 14 从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略 忽略重复的emp_no， 上题的count(title) 其实可以写成count(emp_no) , 即有一条包含title的条目就++，而emp_no是其主键, 因此可以用emp_no的数目来代替title的数目。因此这题要求的不重复emp_no直接加个distinct即可 1234select title, count(distinct emp_no) as tfrom titlesgroup by titlehaving t &gt;= 2 15 查找employees表所有emp_no为奇数 12345select emp_no, birth_date, first_name, last_name, gender, hire_datefrom employeeswhere emp_no % 2 == 1 and last_name != 'Mary' -- 补充：emp_no % 2=1也可以改成MOD(emp_no, 2)=1，但是某些sql版本可能不支持后者(比如题库就不支持)order by hire_date desc 16 统计出当前各个title类型对应的员工当前薪水对应的平均工资 通过t.title来进行分组 123456select t.title, avg(s.salary)from titles as tinner join salaries as son t.emp_no = s.emp_no and t.to_date ='9999-01-01' and s.to_date = '9999-01-01'-- on t.emp_no=s.emp_no where t.to_date='9999-01-01' and s.to_date='9999-01-01' 也行, 表示在on执行后生成的虚拟表上再执行wheregroup by t.title 注意：AVG(*)是自动命名为avg的，所以不用重命名 17 获取当前薪水第二多的员工的emp_no以及其对应的薪水 考验limit用法 1234select emp_no, salary from salariesorder by salary desclimit 1, 1 18 查找当前薪水排名第二多的员工编号emp_no 1234567-- 用MAX函数，先查出最大salary，再利用&lt;得到不含最大salary的子表，在子表上再求最大值select e.emp_no, max(s.salary), e.last_name, e.first_namefrom employees as einner join salaries as son e.emp_no = s.emp_nowhere to_date = '9999-01-01'and salary &lt; ( select max(salary) from salaries as s where s.to_date = '9999-01-01') 19查找所有员工的last_name和first_name以及对应的dept_name 列出employees表里所有员工last_name, first_name, 根据employees中emp_no对应dept_emp中的dept_no,没有分配的员工找不到对应–&gt;采用LEFT JOIN 再根据dept_no对应departments表中的dept_name,没有分配的员工找不到对应–&gt;采用LEFT JOIN 123456select e.last_name, e.first_name, dm.dept_namefrom employees as eleft join dept_emp as de -- 这边使用left join因为要针对没有分配部门的员工on e.emp_no = de.emp_noleft join departments as dmon de.dept_no = dm.dept_no 20查找员工编号emp_now为10001其自入职以来的薪水salary涨幅值growth 最大值-最小值 1234-- 题解, sum的结果默认为growthselect (max(salary)-min(salary)) as growthfrom salarieswhere emp_no='10001'; 21 查找所有员工自入职以来的薪水涨幅情况 这题比较有难度 12345678910111213select la.emp_no, (now.salary - la.salary) as growthfrom (select e.emp_no, s.salary from employees as e left join salaries as s on e.emp_no = s.emp_no and e.hire_date = s.from_date ) as la -- 入职时的工资表inner join (select e.emp_no, s.salary from employees as e left join salaries as s on e.emp_no = s.emp_no where s.to_date = '9999-01-01') as now -- 现在的工资表on la.emp_no = now.emp_noorder by growth asc -- order by 默认asc 22统计各个部门的工资记录数 1234567891011121314151617181920-- myselect d.dept_no, d.dept_name, count(d.emp_no) as `sum`from (select * from dept_emp as de inner join departments as dm on de.dept_no = dm.dept_no) as dinner join salaries as son d.emp_no = s.emp_no group by d.dept_no -- 根据题目要求（统计各个部门的工资记录数）确定group by对象-- 题解select dm.dept_no, dm.dept_name, count(*)from departments as dminner join (select * from dept_emp as de -- (dept_emp as de 也可以 inner join salaries as s on de.emp_no = s.emp_no) as don dm.dept_no = d.dept_nogroup by d.dept_no 23对所有员工的当前薪水按照salary进行按照1-N的排名 SQL窗口函数（OLAP函数）中用于排序的专用窗口函数用法: RANK函数的使用 -&gt;mysql不支持 123select emp_no, salary, dense_rank() over (order by salary desc) as rankfrom salarieswhere to_date = '9999-01-01' 下面介绍三种用于进行排序的专用窗口函数： 1、RANK() 在计算排序时，若存在相同位次，会跳过之后的位次。 例如，有3条排在第1位时，排序为：1，1，1，4······ 2、DENSE_RANK() 这就是题目中所用到的函数，在计算排序时，若存在相同位次，不会跳过之后的位次。 例如，有3条排在第1位时，排序为：1，1，1，2······ 3、ROW_NUMBER() 这个函数赋予唯一的连续位次。 例如，有3条排在第1位时，排序为：1，2，3，4······ 窗口函数用法： 1&lt;开窗函数&gt; over ([partition by &lt;列清单&gt;] order by &lt;排序用列清单&gt;) 开窗函数大体可以分为以下两种： 1.能够作为开窗函数的聚合函数（sum，avg，count，max，min） 2.rank，dense_rank。row_number等专用开窗函数。 1.4 开窗函数和聚合函数的区别 （1）SQL 标准允许将所有聚合函数用作开窗函数，用OVER 关键字区分开窗函数和聚合函数。 （2）聚合函数每组只返回一个值，开窗函数每组可返回多个值。 24 获取所有非manager员工当前的薪水情况 123456789-- 方法1：多表联查+NOT INSELECT de.dept_no, de.emp_no, s.salary FROM dept_emp AS de, employees AS e, salaries AS sWHERE de.emp_no=e.emp_no AND de.emp_no=s.emp_no AND s.to_date='9999-01-01' AND e.emp_no NOT IN (SELECT emp_noFROM dept_manager WHERE to_date='9999-01-01') 25 获取员工其当前的薪水比其manager当前薪水还高的相 12345678910111213141516171819202122232425262728select de.emp_no, dm.emp_no as manager_no, s1.salary as emp_salary, s2.salary as manager_salaryfrom dept_emp as de, dept_manager as dm, salaries s1, salaries s2 where de.dept_no = dm.dept_no -- 找到部门的bossand de.emp_no = s1.emp_noand dm.emp_no = s2.emp_noand s1.salary &gt; s2.salaryand s2.to_date='9999-01-01'and s1.to_date='9999-01-01';-- 依次构造两张表, 再链表查询SELECT a.emp_no, b.manager_no, a.emp_salary, b.manager_salaryFROM ( SELECT de.dept_no, de.emp_no, s.salary AS emp_salary FROM dept_emp AS de, salaries AS s WHERE de.emp_no=s.emp_no AND de.to_date='9999-01-01' AND s.to_date='9999-01-01') AS a, ( SELECT dm.dept_no, dm.emp_no AS manager_no, s.salary AS manager_salary FROM dept_manager AS dm, salaries AS s WHERE dm.emp_no=s.emp_no AND dm.to_date='9999-01-01' AND s.to_date='9999-01-01') AS bWHERE a.dept_no=b.dept_no AND a.emp_salary&gt;b.manager_salary; 26 汇总各个部门当前员工的title类型的分配数目 1234567891011121314151617181920212223use niuke;select dp.dept_no, dp.dept_name, t.title, count(t.title) from departments as dp, dept_emp as de, titles as twhere dp.dept_no = de.dept_noand de.emp_no = t.emp_noand de.to_date = '9999-01-01'and t.to_date = '9999-01-01'group by dp.dept_no,t.title -- 题目的难点在于理解group by的条件-- 题解SELECT de.dept_no AS dept_no, d.dept_name AS dept_name, t.title AS title, COUNT(*) AS `count` -- 分好组后计算每个组内有多少行FROM (SELECT * FROM dept_emp AS de1 WHERE de1.to_date='9999-01-01') AS de, (SELECT * FROM titles AS t1 WHERE t1.to_date='9999-01-01') AS t, departments AS dWHERE d.dept_no = de.dept_noAND de.emp_no = t.emp_noGROUP BY d.dept_no, t.title 对于group by多个关键字的使用， 见B站视频 group by和distinct可以实现相同效果， 在redshift中group by快于distinct 27 给出每个员工每年薪水涨幅超过5000的员工编号emp_no 1234567-- 两个salary子查询相减: 表内根据某一列进行差值比较, 就需要分别获得两行数据, 因此可以获得两次表, on找到对应数据SELECT s1.emp_no, s2.from_date, (s2.salary - s1.salary) AS salary_growth FROM salaries AS s1 JOIN salaries AS s2ON s1.emp_no = s2.emp_no AND s1.to_date = s2.from_date WHERE s2.salary - s1.salary &gt; 5000 ORDER BY salary_growth DESC; 注意: 这边只能是(inner) JOIN, 如果LEFT JOIN, RIGHT JOIN会报错; 原数据7条, join以后变成49条(把s2的每一条都对应给了s1的每一条, 7*7)==&gt;和SELECT * FROM salaries AS s1, salaries AS s2;效果一样，但left join、right join效果不一样 12345678-- 其他题SELECT s1.emp_no, s2.from_date, (s2.salary - s1.salary) AS salary_growthFROM salaries AS s1, salaries AS s2WHERE s1.emp_no=s2.emp_noAND (STRFTIME('%Y', s2.from_date) - STRFTIME('%Y', s1.from_date) = 1OR STRFTIME('%Y', s2.to_date) - STRFTIME('%Y', s1.to_date) = 1)AND salary_growth&gt;5000ORDER BY salary_growth DESC; 28 查找描述信息中包括robot的电影对应的分类名称以及电影数目 这题题意其实是有一点绕的： 查找描述信息中包含robot的电影对应的分类名称以及电影数目，注意需要该分类包含电影总数量&gt;=5部 包含robot的数据, 通过like选出: select * from film where film.description like '%robot%'; 记录: category: 16条 film: 10条 film_category: 10条 1234567891011121314select * from film f,category c,film_category fc -- 1600条数据where f.description like '%robot%' -- 160条数据and f.film_id = fc.film_id -- 16条数据-- 题解:select c.name AS `分类名称category.name`, COUNT(fc.film_id) AS `电影数目count(film.film_id)`from film f,category c,film_category fcwhere f.description like '%robot%'and f.film_id=fc.film_idand fc.category_id=c.category_idand c.category_id in (select category_id from film_category group by category_id having count(film_id)&gt;=5) -- 需要该分类包含电影总数量(count(film_category.category_id))&gt;=5部 ▲注: 这题无论怎么写在本地的MYSQL上都跑不出来, 但是OJ上能过. 具体报错为: In aggregated query without GROUP BY, expression #1 of SELECT list contains nonaggregated column 'niuke.c.name'; this is incompatible with sql_mode=only_full_group_by, 这个是由于sql_mode设置不当引起的，修改下sql_mode即可. 做法为: https://cloud.tencent.com/developer/article/1404739 29 使用join查询方式找出没有分类的电影id以及名称 12345select f.film_id as '电影id', f.title as '名称'from film f left join film_category as fc on f.film_id = fc.film_idwhere fc.category_id is null -- 注意什么时候用on 什么时候用where, 这边是固定用法 30 使用子查询的方式找出属于Action分类的所有电影对应的title,description 要求子查询， 就需要先根据类别为Action将子表给筛选出来 1234567891011121314-- 联子表， 用inner join一样的select f.title, f.description from film as f, (SELECT fc.film_id from film_category fc, category c where fc.category_id = c.category_id and c.name = 'Action') as ffwhere f.film_id = ff.film_id;-- 题解select title,descriptionfrom film fwhere f.film_id in (select fc.film_id from category c join film_category fc on c.category_id=fc.category_id where name='Action') inner join 和 where比较(实际上是cross join笛卡尔积) 123456789A: select a.x, b.x from table1 a,table2 b where a.id=b.idB: select * from table1 a cross join table2 b where a.id=b.id (注：cross join后加条件只能用where,不能用on)C: select * from table1 a inner join table2 b on a.id=b.id 一般不建议使用方法A和B，因为如果有WHERE子句的话，往往会先生成两个表行数乘积的行的数据表然后才根据WHERE条件从中选择。因此，如果两个需要求交际的表太大，将会非常非常慢，不建议使用。 连接查询与子查询 初步实践证明：连接查询的性能优于子查询，所以能用连接查询的地方尽量少用子查询 连接查询 连接查询是将两个或多个的表按某个条件连接起来，从中选取需要的数据，连接查询是同时查询两个或两个以上的表的使用的。当不同的表中存在相同意义的字段时，可以通过该字段来连接这几个表。 32 将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分 123456789101112-- sqlite中无concat函数select (last_name||' '||first_name) as Name from employees -- mysqlCREATE TABLE if NOT EXISTS `employees`(`last_name` VARCHAR(60),`first_name` VARCHAR(60));INSERT INTO `employees` VALUES('mr', 'li');select concat(last_name, ' ', first_name) as 'Name' from employees -- sqlite 练习CRUD 33 创建一个actor表，包含如下列信息 123456789101112131415-- 发现图中有的含义列不需要用comment表示出create table if not exists `actor`( `actor_id` smallint(5) not null , `first_name` varchar(45) not null , `last_name` varchar(45) not null , `last_update` date not null, primary key(actor_id));-- 题解CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY, -- 设置主键first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime('now','localtime'))) -- 获取默认系统时间 34 批量插入数据 123insert into `actor`values (1, 'PENELOPE', 'GUINESS', '2006-02-15 12:34:33'), (2, 'NICK', 'WAHLBERG', '2006-02-15 12:34:33'); 35 批量插入数据,如果数据已经存在，请忽略，不使用replace操作 1234567-- sqliteinsert or ignore into actorvalues(3,'ED','CHASE','2006-02-15 12:34:33');-- mysqlinsert into actorvalues(3,'ED','CHASE','2006-02-15 12:34:33'); 36 创建一个actor_name表，将actor表中的所有first_name以及last_name导入改表 123456CREATE TABLE IF NOT EXISTS `actor_name`(`first_name` varchar(45) not null,`last_name` VARCHAR(45) not null);INSERT INTO `actor_name` SELECT first_name, last_name from actor; 37 对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastname 123456789-- sqlite在已有表上创建索引方式 -- 1.创建单列普通索引CREATE INDEX index_name ON table_name (column_name); -- 2.创建唯一索引CREATE UNIQUE INDEX index_name ontable_name (column_name);-- 注意, 这边索引是不能用``或者''框起来的CREATE UNIQUE INDEX uniq_idx_firstname on actor (first_name);CREATE INDEX idx_lastname ON actor (last_name); 38 针对actor表创建视图actor_name_view 123CREATE VIEW actor_name_view ASSELECT first_name first_name_v ,last_name last_name_vFROM actor; 39 针对上面的salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005, 针对salaries表emp_no字段创建了索引idx_emp_no。请强制使用索引查询emp_no为10005 123456&gt; -- sqlite使用索引查询的语法为&gt; SELECT|DELETE|UPDATE column1, column2...&gt; INDEXED BY (index_name)&gt; table_name&gt; WHERE (CONDITION);&gt; 它可以与 DELETE、UPDATE 或 SELECT 语句一起使用。 “INDEXED BY index-name” 子句规定必须用命名的索引来查找前面表中值，如果索引名 index-name 不存在或不能用于查询，SQLite 语句的查询失败。 1SELECT * FROM salaries INDEXED BY idx_emp_no WHERE emp_no = 10005 40 在last_update后面新增加一列名字为create_date 12345-- 向表中添加列 alter table table_name add col_name char-- 答案ALTER TABLE actor ADD create_date datetime NOT NULL DEFAULT('0000-00-00 00:00:00'); 41 构造一个触发器audit_log，在向employees表中插入一条数据的时候，触发插入相关的数据到audit中 12345-- 在MySQL中，创建触发器语法如下：CREATE TRIGGER trigger_nametrigger_time trigger_event ON tbl_nameFOR EACH ROWtrigger_stmt trigger_name：标识触发器名称，用户自行指定； trigger_time：标识触发时机，取值为 BEFORE 或 AFTER； trigger_event：标识触发事件，取值为 INSERT、UPDATE 或 DELETE； tbl_name：标识建立触发器的表名，即在哪张表上建立触发器； trigger_stmt：触发器程序体，可以是一句SQL语句，或者用 BEGIN 和 END 包含的多条语句，每条语句结束要分号结尾。 1234567create trigger audit_log after insert on employees_testfor each rowbegin insert into audit values(new.id,new.name); -- new为插入到employees_test的数据end 【NEW 与 OLD 详解】 MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据。 具体地： 在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据； 在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据； 在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据； 使用方法： NEW.columnName （columnName 为相应数据表某一列名） 42 删除emp_no重复的记录，只保留最小的id对应的记录。 12345delete from titles_test where id not in ( select min(id) from titles_test group by emp_no); 43 将所有to_date为9999-01-01的全部更新为NULL,且 from_date更新为2001-01-01 1update titles_test set to_date = null, from_date = '2001-01-01' where to_date ='9999-01-01'; 44 将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005,其他数据保持不变，使用replace实现。 123-- 考察replace函数: 其中包含三个参数，第一个参数为该字段的名称，第二参数为该字段的需要被修改值，第三个参数为该字段修改后的值update titles_test set emp_no = replace(emp_no, 10001, 10005) where id = 5; 45 将titles_test表名修改为titles_2017 12-- 因为在 MySQL里面修改表名和表里的字段都是用的 ALTER TABLE + table_name + 后面的修改部分alter table titles_test rename to titles_2017; 结合[40 在last_update后面新增加一列名字为create_date](#40 在last_update后面新增加一列名字为create_date)一起看 ALTER TABLE 表名 ADD 列名/索引/主键/外键等； ALTER TABLE 表名 DROP 列名/索引/主键/外键等； ALTER TABLE 表名 ALTER 仅用来改变某列的默认值； ALTER TABLE 表名 RENAME 列名/索引名 TO 新的列名/新索引名； ALTER TABLE 表名 RENAME TO/AS 新表名; ALTER TABLE 表名 MODIFY 列的定义但不改变列名； ALTER TABLE 表名 CHANGE 列名和定义都可以改变。 46 在audit表上创建外键约束，其emp_no对应employees_test表的主键id 123456DROP TABLE audit; CREATE TABLE audit( emp_no INT NOT NULL, create_date datetime NOT NULL, FOREIGN KEY(emp_no) REFERENCES employees_test(id) ) 48 将所有获取奖金的员工当前的薪水增加10% 123456update salaries set salary = 1.1*salary where salaries.to_date = '9999-01-01'and emp_no in ( select emp_no from emp_bonus) 50 将employees表中的所有员工的last_name和first_name通过(’)连接起来。 1select (last_name || \"'\" || first_name ) as name from employees; 51 查找字符串’10,A,B’ 把串 “10,A,B” 中的 逗号用空串替代， 变成了 “10AB”, 然后原来串的长度 - 替换之后的串的长度 就是 被替换的 逗号的个数 1select ( length('10,A,B') - length(replace('10,A,B', ',', '')) ) as cnt; 52 获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列 用mysql的话有函数right函数。就是取右边第几位的意思，同样还有一个 left 函数。select * from salaries order by right(emp_no,2)但是本题数据库是SQlite 只能用substr(emp_no,-2) 1234select e.first_namefrom employees as eorder by substr(e.first_name, -2) asc;-- substr(e.first_name, -2, 2) 从最后第二位开始取2位 53 按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employees 聚合函数group_concat（X，Y），其中X是要连接的字段，Y是连接时用的符号，默认为逗号，可省略。此函数必须与GROUP BY配合使用。 此题以dept_no作为分组，将每个分组中不同的emp_no用逗号连接起来（即可省略Y）。 123select dept_no, group_concat(emp_no) as employeesfrom dept_empgroup by dept_no 54 查找排除当前最大、最小salary之后的员工的平均工资avg_salary 12345select avg(s.salary) as avg_salaryfrom salaries as swhere to_date= '9999-01-01'and s.salary not in ( select min(salary) from salaries where to_date= '9999-01-01' )and s.salary not in ( select max(salary) from salaries where to_date= '9999-01-01' ); 55 分页查询employees表，每5行一页，返回第2页的数据 limit offset, size size是每页几条数据pageCnt，分页时offset输出页数（pageNum-1）*pageCnt 123select *from employeeslimit (2-1)*5, 5; 56 获取所有员工的emp_no 57 使用含有关键字exists查找未分配具体部门的员工的所有信息。 59 获取有奖金的员工相关信息。 60 统计salary的累计和running_total 66 牛客每个人最近的登录日期(一) 123select max(date)from logingroup by user_id 67 牛客每个人最近的登录日期(二) 123456select user.name,client.name,max(login.date)from loginleft join user on login.user_id = user.idleft join client on login.client_id = client.idgroup by user_idorder by user.name; 用group by需要注意的: 在select指定的字段 要么就要包含在Group By语句的后面，作为分组的依据； 要么就要被包含在聚合函数中。","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"SQL","slug":"SQL","permalink":"https://nymrli.top/tags/SQL/"}]},{"title":"IDEA插件开发","slug":"IDEA插件开发","date":"2020-07-11T07:50:42.000Z","updated":"2021-09-22T09:26:39.633Z","comments":true,"path":"2020/07/11/IDEA插件开发/","link":"","permalink":"https://nymrli.top/2020/07/11/IDEA插件开发/","excerpt":"","text":"目的是想将类方法和成员方法区分开来， 想设计这么一个插件 新建IDEA 插件工程 File -&gt; new -&gt; Project -&gt; Plugin即可 初始会生成一个项目xml配置文件, 以下是我进行修改后的 12345678910111213141516171819202122232425262728293031323334353637&lt;idea-plugin&gt; &lt;id&gt;top.nymrli.privatesee&lt;/id&gt; &lt;name&gt;privateSee&lt;/name&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;vendor email=\"nymrli99@163.com\" url=\"http://nymrli.top\"&gt;Mrli&lt;/vendor&gt; &lt;description&gt;&lt;![CDATA[ Highlight when private methods are called. ]]&gt;&lt;/description&gt; &lt;change-notes&gt;&lt;![CDATA[ &lt;br&gt; &lt;em&gt;First created. This time will be tried&lt;/em&gt; &lt;br&gt; ]]&gt; &lt;/change-notes&gt; &lt;!-- please see https://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/build_number_ranges.html for description --&gt; &lt;idea-version since-build=\"173.0\"/&gt; &lt;!-- please see https://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/plugin_compatibility.html on how to target different products --&gt; &lt;depends&gt;com.intellij.modules.platform&lt;/depends&gt; &lt;extensions defaultExtensionNs=\"com.intellij\"&gt; &lt;!-- Add your extensions here --&gt; &lt;/extensions&gt; &lt;actions&gt; &lt;!-- Add your actions here --&gt; &lt;action id=\"FirstPluginActionId\" class=\"top.nymrli.privatesee.FirstPluginAction\" text=\"测试\" description=\"测试描述\"&gt; &lt;add-to-group group-id=\"ToolsMenu\" anchor=\"first\"/&gt; &lt;keyboard-shortcut keymap=\"$default\" first-keystroke=\"ctrl I\"/&gt; &lt;/action&gt; &lt;/actions&gt;&lt;/idea-plugin&gt; 新建action 123456789101112public class FirstPluginAction extends AnAction &#123; @Override public void actionPerformed(AnActionEvent e) &#123; // TODO: insert action logic here NotificationGroup notificationgroup = new NotificationGroup(\"flugin_id\", NotificationDisplayType.BALLOON, true); Notification notification = notificationgroup.createNotification(\"点击测试\", MessageType.INFO); Notifications.Bus.notify(notification); &#125;&#125; 运行测试: edit configuration选择plugin, 然后选择运行 启动初始化 新建一个类 123456789public class MyApplicationComponent implements ApplicationComponent &#123; @Override public void initComponent() &#123; System.out.println(\"插件初始化\"); TanChuanDialog dialog = new TanChuanDialog(); dialog.show(); &#125;&#125; 在xml配置指定 1234567&lt;application-components&gt; &lt;component&gt; &lt;implementation-class&gt; top.nymrli.privatesee.MyApplicationComponent &lt;/implementation-class&gt; &lt;/component&gt;&lt;/application-components&gt; 弹窗效果 1234567891011121314151617181920212223242526272829303132333435public class TanChuanDialog extends DialogWrapper &#123; JPanel jPanel; JLabel label; JButton btn; public TanChuanDialog() &#123; super(true); // 设置弹窗的标题 setTitle(\"启动弹窗\"); init(); &#125; // 设置弹窗中间展示内容 @Nullable @Override protected JComponent createCenterPanel() &#123; jPanel = new JPanel(); label = new JLabel(\"显示内容\"); jPanel.add(label); return jPanel; &#125; // 自定义设置底部的按钮 @Override protected JComponent createSouthPanel() &#123; jPanel = new JPanel(); btn = new JButton(\"再干一杯\"); btn.addActionListener(e-&gt;&#123; label.setText(\"被点击了哦\"); &#125;); jPanel.add(btn); return jPanel; &#125;&#125; 教程： idea 插件开发跳坑指南——赞 插件推荐 插件名 功能 Codegalance 提供侧栏的代码缩览图 translation IDE内提供划线翻译功能 grep-console 显示多颜色调试日志 restfultoolkit 一套 RESTful 服务开发辅助工具集，1. 可根据URL查找对应controller2. 提供一个service tree窗口3. 一个简单的http请求工具4. 提供将类生成json数据 gsonformaterPlus json对象生成器 jsonparser 内置json美化工具 mybatis log plugin (现收费) 根据log4j的打印的sql日志一键生成执行的sql语句 free mybatis plugin 1.提供xml和dao层的互相跳转功能，箭头形状。2，mapper生成xml文件: alt+enter快捷键3.mybatis自动补全及语法错误提示4.集成mybatis generator gui界面 Alibaba Java Coding Guidelines 阿里巴巴JAVA开发规范检测插件 codata 人工智能代码检测补全插件 easycode 自动生成mybatis mapper相关 lombok lombok识别插件，2020IDEA已内置 JUnitGenerate 单元测试生成器 MyBatisCodeHelperPro 全能mybatis插件 alibaba cloud toolkit 快速部署到服务器 idea zookeeper 图形化zookeeper sequencediagram 时序图生成插件 https://www.zhihu.com/zvideo/1319971719340761088","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"}]},{"title":"getBargains的record和Solution","slug":"getBargains的record和Solution","date":"2020-05-24T08:44:25.000Z","updated":"2020-05-31T11:38:26.323Z","comments":true,"path":"2020/05/24/getBargains的record和Solution/","link":"","permalink":"https://nymrli.top/2020/05/24/getBargains的record和Solution/","excerpt":"","text":"该篇为**getBargains**仓库README.md直接搬运，记录一些appnium和andriod 10碰到的问题 自动拿券 通过别人发的口令, 打开淘宝APP进行抢券 1.itchat接收群消息 2.将口令复制到剪贴板 3.打开淘宝APP点击抢券 碰到的问题: 出现如下警告:Warning: Activity not started, its current task has been brought to the front or Warning: Activity not started, intent has been delivered to currently running top-most instance. A: 不用管他就行, 只是个警告, 提示你有应用切到了顶层 出现提示: /system/bin/sh: adb: inaccessible or not found A: 已经在adb shell中输入的命令不需要再加上adb shell前缀 e.g.umi:/ $ adb shell am start ca.zgrs.clipper/.Main (umi:/)提示已经在adb shell中了 查找app包名和Activity活动页面(Andriod 10) A: 原本的adb shell dumpsys activity | find &quot;mFocusedActivity&quot;在andriod 10上好像检测不出来 1234# 查看包名$ adb shell pm list packages# 查看Activity# $ adb shell dumpsys activity com.taobao.taobao | grep ACTIVITY adb打开应用的命令? A: adb shell am start -n package/launch activity appnium声明driver的时候是打开指定app程序, 但如果每次都是重新打开, 那么加载淘宝的速度会很慢。应该使用切换后台 A: 使用driver.start_activity('com.taobao.taobao', 'com.taobao.tao.TBMainActivity') appium：一个手机运行两个APP，APP之间相互切换 ADB滑动解锁问题: 在一个位置按住 A: 暂时还没解决, appnium可以, 但ADB好像没有找到解决方案 桌面的activity: A: .launcher.Launcher 报错selenium.common.exceptions.InvalidSessionIdException: Message: A session is either terminated or not started A: 原因是driver长时间没收到command自动关闭了, 与使用driver.quit()后再用driver执行操作报相同的错误。 -&gt;解决方案: 在desirable_caps中将newCommandTimeout设置大一点: 'newCommandTimeout': 1800 附录： python3使用appnium运行手机上的APP clipper - Broken on Android 10 (Android Q) #9 Appium Python API 中文版 By-HZJ Appium配置desired_capability详解 查看包名和activity 123456 # 在米6(Andriod 10)上尝试可行 $ adb shell dumpsys window windows | findstr mFocusedApp $ adb shell dumpsys window windows | findstr &quot;Current&quot; # 下失效 $ adb shell dumpsys activity | find mFocusedActivity 如果在有apk的情况下, aapt dump badging d:\\\\test.apk 打开APP-&gt;adb logcat &gt; D:/log.txt -&gt; 胡乱的对APP做一些操作-&gt;Ctrl+c 结束adb命令-&gt;打开log.txt文件，搜索：Displayed","categories":[],"tags":[]},{"title":"IDEA配置——自定义快捷键、生成注释","slug":"IDEA配置——自定义快捷键、生成注释","date":"2020-05-15T02:22:20.000Z","updated":"2022-02-06T03:20:34.681Z","comments":true,"path":"2020/05/15/IDEA配置——自定义快捷键、生成注释/","link":"","permalink":"https://nymrli.top/2020/05/15/IDEA配置——自定义快捷键、生成注释/","excerpt":"","text":"IDEA配置——自定义快捷键、生成注释 以前因为上JAVA课，还是不常用Java， 所以安装了个Eclipse， 但是现在要经常使用java的话， 感觉还是IDEA的支持做的可能更加到位一点 Maven换源: 因为有段时间写SpringBoot被依赖给坑过，所以把Maven换源写在最前面。 IDEA是会有默认的Maven工具的， 因此之前如果修改过Maven配置， 还需要在IDEA中指定具体使用的是哪一个MAVEN，使用哪一个配置文件。 ▲(Ctrl + Alt + S修改的是当前工程)， 如果需要对新工程进行修改， 则点击File-&gt;New Projects Settings-&gt;Settings for new Projects 其中User settings file选择之前配置过的Maven_settings就行了，换源在里面修改。注意， mirror标签要放在mirrors标签内才能生效, 跟dependencies一样， 我后来才发现我竟然没放进去。 123456789101112131415161718192021&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 补充: 还可以在pom.xml文件中指定改源, 填下下列字段: 1234567&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 自动补全提示: 菜单栏Settings(快捷键ctrl + alt + s)-&gt;Editr-&gt;General-&gt;Code Completion-&gt; 取消选中&quot;Match case&quot; IDEA自定义快捷键 功能 英文描述 快捷键 回退上一次光标位置 back Ctrl +alt + ← 前进到下一次光标位置 forward Ctrl +alt + → 选中当前部分 extend selection Ctrl + D 复制当前行↑ Duplicate Line or Selection shift + alt + ↑ 复制当前行↓ Duplicate Entire Lines shift + alt + ↓ 切换到上行 Move Line Up alt+↑ 切换到下行 Move Line Down alt+↓ 下一个方法 next Method ctrl + alt+ ↓ 上一个方法 Previous Method ctrl + alt+ ↑ 生成getter等方法 generate ctrl + L 在下生成空白一行 Start New Line Shift + Enter 在上生成空白一行 Start New Line Before Current Ctrl+ Shift + Ctrl 完成该行——添加末尾分号+换到下行 Complete Current Statement ctrl + shift + enter 剪切改行（可当成删除改行使用） Cut ctrl + X 工程中跳转指定class Navigate-class Ctrl + M 新建 Main Menu-File-New Ctrl + N 关闭当前标签页 Editor Tabs - Close Ctrl + W 切换到下一行 Split Line Ctrl + enter 代码生成 Code - generate alt + L 未改变的快捷键设置 功能 英文描述 快捷键 格式化代码 Reformat Code ctrl + alt + L 根据上下文完成动作（导包） Show Context Actions Alt + enter 优化import导入 Optimize lmports Shift + Ctrl + O 插入生成模板(psvm) Insert Live Template Ctrl + J 打开设置面板 open settings Ctrl + alt + s 统一修改变量名 Main Menu - Refactor- Rename Shift + F6 搜索指定Class Main Menu-Navigate-class Ctrl + M 重写方法 override Methods Ctrl + o 查看类继承关系 ctrl+H 查看类继承关系图 ctrl+alt+shift+U ▲、以上以windows设置为模板修改 由于File-&gt;Manage IDE Settings-&gt;Export settings的内容是不包含keyMap的，因此可以直接保存keyMap文件来备份，路径为C:\\Users\\mrli\\AppData\\Roaming\\JetBrains\\IntelliJIdea2020.3\\jba_config\\win.keymaps 生成类注释、文件注释 没弄图， 主要是按照idea生成类注释和方法注释的正确方法配置的 生成类注释 打开Preferences Editor -&gt; File and Code Templates -&gt; Files -&gt; Class 123456789101112#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != \"\")package $&#123;PACKAGE_NAME&#125;;#end#parse(\"File Header.java\")/*** @program: $&#123;PROJECT_NAME&#125;* @description: $&#123;description&#125;* @author: MrLi* @create: $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;HOUR&#125;:$&#123;MINUTE&#125;**/public class $&#123;NAME&#125; &#123;&#125; 生成方法注释 打开Preferences Editor -&gt; Live Templates -&gt; 点击右边加号为自己添加一个Templates Group -&gt; 然后选中自己的Group-&gt;再次点击加号添加Live Templates 记得要把最下面的提示▲.No applicable contexts yet.Define-&gt;设置为java 然后在Edit variables里面添加参数和返回值的自动取值 按上述步骤设置完后就可以使用了： 在方法上面直接输入/ + 你设置的Abbreviation快捷键 + tab键就直接生成了 （我设置的是Abbreviation是q，那么通过/ + q + tab就可以调用导出了） 神秘密码(Template text中填的): $params$和$returns$在Edit variables中分别选择methodParameters(), methodReturnType() 1234567** * @Description: $description$ * @Param: $params$ * @Return: $returns$ * @Author: MrLi* @Date: $date$ */ 不错的配置： 12345** * @author: Mrli * @description: * @date: $date$ $time$$param$ $return$ */ 需要注意的是，date 和 time 的 Expression 使用的是 IDEA 内置的函数，直接使用下拉框选择就可以了，而 param 这个参数 IDEA 默认的实现很差，因此我们需要手动实现，代码如下： groovyScript(&quot;def result = '';def params = \\&quot;${_1}\\&quot;.replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i &lt; params.size(); i++) {if(params[i] != '')result+='* @param: ' + params[i] + ((i &lt; params.size() - 1) ? '\\\\r\\\\n ' : '')}; return result == '' ? null : '\\\\r\\\\n ' + result&quot;, methodParameters()) 另外 return 这个参数需要修改，代码如下： groovyScript(&quot;return \\&quot;${_1}\\&quot; == 'void' ? null : '\\\\r\\\\n * @return: ' + \\&quot;${_1}\\&quot;&quot;, methodReturnType()) 删除没有用到的包 1.手动快捷键 1Ctrl + Alt + O1 2.配置自动清理 1Ctrl + Alt + S 打开设置-&gt;editor-&gt;auto import Optimize imports on the fly：自动去掉一些没有用到的包 Add unambiguous imports on the fly： 自动帮我们优化导入的包 Intellij idea 报错：Error : java 不支持发行版本5 在Intellij中点击“File” --&gt;“Project Structure”，看一下“Project”和“Module”栏目中Java版本是否与本地一致： 解决方案： https://blog.csdn.net/qq_22076345/article/details/82392236 Intellij IDEA 神器居然还有这些小技巧[转] Java开发好用的插件 Codeglance： 代码概览 translation： 翻译插件 grey console： 控制台美化 restfultoolkit： 接口工具箱 gsonformater： json格式化工具 mybatis log plugin： sql日志插件 free mybatis plugin Alibaba Java Coding Guidelines：阿里编程规范 codata: 人工智能代码补全 easycode 自动生成mybatis mapper相关 lombok： setter/getter生成 SequenceDiagram: 时序图分析 Maven Helper： maven依赖分析工具 Maven search： 依赖dependency查找工具 CamelCase： 单词格式转换 约定配置 设置编码规定 设置编译Java版本为8 开启注解编译 （可选）将iml，.idea文件不显示在工程中 ​ 更多快捷键 左侧的菜单栏上有除了我们常用的Project、Structure以外还有Bookmarks和Learn， 于是在好奇之下，就点击学习了Learn中的内容，其主要是关于Idea功能以及快捷键介绍的，对此记录一下。 Ctrl + Alt + V： 提取变量， replace all occurences， 将对应表达式全部抽取替换为一个变量， 比如我们很多地方用到了arr[i+1]， 结果为了易读性想把他直接写成这个变量就可以直接使用这个功能 Ctrl +Shift + Alt +N： 搜索函数名(Symbols) Shift + F6： 对某个字段全部重命名 删除没用的字段, Alt + Enter 打开上下文后选择 Safe Delete Ctrl + Alt + T： 添加环绕代码；Ctrl + Shift + delete删除环绕代码 Ctrl + -：折叠代码； Ctrl + +： 展开代码 Ctrl + Alt + Shift + T: 重构, 如introduce Parameter将选取的对象抽取为方法参数；inlince Vairable取消行内变量 在if(?)的括号中，选择某个选项（选项变蓝即为选中， aa.contains()），输入Shift+1即！，则直接会生成对应的!aa.contains()==&gt;if (!aa.contains()) Java短代码(快捷代码) https://www.cnblogs.com/asio/p/12582328.html psvm 或者 main :main()方法 sout :输出语句 12345变量.sout ==&gt; System.out.println(变量);soutv ==&gt; System.out.println(\"变量名 = \" + 第一个成员变量变量（没有的找方法参数，再没有找方法局部变量，再没有输出\"true\" + true）); 指定变量.soutv ==&gt; System.out.println(\"变量名 = \" + 指定变量); soutm ==&gt; System.out.println(\"当前类名.当前方法\");soutp ==&gt; soutp=System.out.println(\"方法形参名 = \" + 形参名); //如果方法参数列表为空，则效果相当于sout fori:for循环语句 12345678910111213141516171819202122232425262728类似的有// length.fori int length = 10; for (int i = 0; i &lt; length; i++) &#123; &#125;// length.forr for (int i = length; i &gt; 0; i--) &#123; &#125;// array.fori int array[] = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; &#125;// array.for int array[] = new int[10]; for (int i : arr) &#123; &#125;// list.for:集合list的for循环语句list.fori List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; &#125;list.forr //从尾到头遍历 iter:可生成增强 for 循环 123456789101112131415iter:可生成增强 for 循环 for (Object o : ) &#123; &#125;array.iter int array[] = new int[10]; for (int i : arr) &#123; &#125;itar:可生成普通 for 循环 for (int i = 0; i &lt; array.length; i++) &#123; = array[i]; &#125; ifn:可生成if(xxx = null),xxx为定义过的变量 prsf:可生成private static final mn: ==&gt;$VAR$ = Math.min($VAR$, $END$);生成取最值， 同样的有mx，取最大值 geti==&gt;生成getIntance方法 WL写锁、RL读锁，注操作对象为new ReentrantReadWriteLock() lst： 获得array最后一个元素 lazy：懒加载","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"华为春招4.29笔试题","slug":"华为春招4-29笔试题","date":"2020-04-29T14:43:54.000Z","updated":"2020-04-29T14:47:07.162Z","comments":true,"path":"2020/04/29/华为春招4-29笔试题/","link":"","permalink":"https://nymrli.top/2020/04/29/华为春招4-29笔试题/","excerpt":"","text":"4.29三道笔试题： 做了其他大厂的笔试题后，好像确实华为的稍微简单点。只不过其他的笔试题是有模拟题的，华为的这三道题基本上都是DFS A： 带有重复元素的全排列问题，求不重复的排列数。以下做法50%, TLE了。正确做法是直接用公式计算 123456789101112131415161718192021222324252627282930'''@Author: Mrli@Date: 2020-04-29 20:23:34@LastEditTime: 2020-04-29 21:24:40@Description: '''s = input().strip()ans = list(s)sz = len(s)res = []def dfs(depth): if depth &gt; sz-1: return if depth == sz-1: enter = ''.join(ans) if enter not in res: res.add(enter) for i in range(sz): swap(i, depth) dfs(depth+1) swap(i, depth) def swap(x, y): tmp = ans[x] ans[x] = ans[y] ans[y] = tmpdfs(0)print(len(res)) B 求去掉K个字母，留下字典序最小的字符串。当时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879'''@Author: Mrli@Date: 2020-04-29 19:01:55@LastEditTime: 2020-04-29 22:31:07@Description: '''\"\"\"# 看错题, 以为是从开头去掉k个。一分钟写的过了40%\"\"\"# s = input().strip()# n = int(input().strip())# print( s[n:])'''# 第一次尝试, ''-&gt;加n-k个-&gt; 过10%'''# 选择移除K个字母, 要使留下来的字符串字典序最小# s = input().strip()# n = int(input().strip())# fans = s# def dfs(ans, index, depth):# global fans# if index &gt;= len(s): return # if depth &gt; n: return# if depth == n:# if ans &lt;= fans:# fans = ans# print(ans + s[index])# dfs(ans + s[index], index+1, depth + 1)# dfs(ans, index+1, depth) # dfs('', 0, 0)# print(fans)'''当时dfs('', 0, 0)的写法报了点错, 以为不能这么写, 于是换成s中去k个'''# s = input().strip()# sz = len(s)# n = int(input().strip())# fans = ''.join('z' for i in range(sz))# def dfs(ans, index, depth):# global fans# if index &gt;= sz: return # if depth == n:# if ans &lt;= fans:# fans = ans# # print(ans[0:index] + ans[index+1:])# dfs(ans[0:index] + ans[index+1:], index+1, depth + 1)# dfs(ans, index+1, depth)# dfs(s, 0, 0)# print(fans)'''第三次尝试, 重新接回第一种到n-k个数时结束的写法. 考完以后写出来的. 但不知道能不能过全部样例'''s = input().strip()sz = len(s)n = int(input().strip())fans = ''.join('z' for i in range(sz)) # 初始化为最大def dfs(ans, index): global fans if index == sz: return if len(ans) == sz-n: # print(ans, fans, ans &lt;= fans) if ans &lt;= fans: fans = ans dfs(ans + s[index], index+1) dfs(ans, index+1)dfs('', 0)print(fans) C: k, n, r： 有k个硬币， n个城市， r条单向边 要求在硬币足够的情况下的最短距离 ▲一开始以为是dijistra+硬币数(第二指标)判断，但是实际情况并不是在求最短距离的情况下的硬币数，而是在硬币充足的情况下最短距离是多少===&gt;实际就变成了一个非常简单的DFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160/* * @Author: Mrli * @Date: 2020-04-29 19:05:27 * @LastEditTime: 2020-04-29 21:12:04 * @Description: */#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 105;const int INF = 0x3f3f3f3f;int dist[MAXN][MAXN];int T[MAXN][MAXN];bool visited[MAXN] = &#123;false&#125;;// int d[MAXN];// int cost[MAXN];int mans = INF;bool haveans = false;int k, n ,r; // 硬币数、城市数、道路数/* dijistra做法的尝试 */// void dijistra(int s)&#123;// d[s] = 0;// cost[s] = 0;// for (int i = 1; i &lt;= n; i++) &#123;// int u = -1, MIN = INF;// for (int j = 1; j &lt;= n; j++) &#123;// if (visited[j] == false &amp;&amp; d[j] &lt; MIN)&#123;// u = j;// MIN = d[j];// &#125;// &#125;// if ( u == -1) return;// visited[u] = true;// // 保证路径最短, 再确定硬币// // for (int v = 1; v &lt;= n; v++) &#123;// // if (visited[v] == false &amp;&amp; dist[u][v] != INF)&#123;// // if ( dist[u][v] + d[u] &lt; d[v] )&#123;// // d[v] = dist[u][v] + d[u];// // cost[v] = T[u][v] + cost[u]; // // &#125;else if (dist[u][v] + d[u] == d[v])&#123;// // if( cost[u] + T[u][v] &lt; cost[v] )&#123;// // cost[v] = cost[u] + T[u][v];// // &#125;// // &#125;// // &#125;// // &#125;// // 保证硬币足够的情况下// for (int v = 1; v &lt;= n; v++) &#123;// if (visited[v] == false &amp;&amp; dist[u][v] != INF)&#123;// if ( T[u][v] + cost[u] &lt; cost[v] )&#123; // if ( dist[u][v] + d[u] &lt; d[v] )&#123;// d[v] = dist[u][v] + d[u];// &#125;// cost[v] = T[u][v] + cost[u]; // &#125;else if ( T[u][v] + cost[u] == cost[v] )&#123;// if( dist[u][v] + d[u] &lt; d[v] )&#123;// d[v] = dist[u][v] + d[u];// // cost[v] = T[u][v] + cost[u]; // &#125;// &#125;// &#125;// &#125;// &#125;// &#125;/* 思考过用BFS */// void bfs(int s)&#123;// queue&lt;int&gt; q;// q.push(s);// visited[s] = true;// while (!q.empty())&#123;// int u = q.front();// q.pop();// for (int v = 0; v &lt; n; v++) &#123;// if ( visited[v] == false &amp;&amp; dist[u][v] != INF)&#123;// &#125;// &#125;// &#125;// &#125;void dfs(int u, int ans, int q)&#123; if ( u == n )&#123; if ( q &lt;= k)&#123; if (ans &lt;= mans)&#123; mans = ans; &#125; haveans = true; &#125; &#125; for (int v = 2; v &lt;= n; v++) &#123; if ( visited[v] == false &amp;&amp; dist[u][v] != INF)&#123; visited[v] = true; // cout &lt;&lt; \"next: \" &lt;&lt;v &lt;&lt;endl; dfs(v, ans + dist[u][v], q + T[u][v]); visited[v] = false; &#125; &#125;&#125;void init()&#123; fill(dist[0], dist[0] + MAXN* MAXN, INF); fill(T[0], T[0] + MAXN* MAXN, INF); // fill(d, d+MAXN, INF); // fill(cost, cost+MAXN, INF);&#125;int main()&#123; cin &gt;&gt; k &gt;&gt; n &gt;&gt; r; init(); for (int i = 0; i &lt; r; i++) &#123; int s, d, w, cost; cin &gt;&gt; s &gt;&gt; d &gt;&gt; w &gt;&gt; cost; dist[s][d] = w; T[s][d] = cost; &#125; dfs(1, 0, 0); if (haveans) cout &lt;&lt; mans &lt;&lt;endl; else cout &lt;&lt; -1 &lt;&lt;endl; // for (int i = 1; i &lt;= n; i++) &#123; // for (int j = 1; j &lt;= n; j++) &#123; // cout &lt;&lt; dist[i][j] &lt;&lt;\" \"; // &#125; // cout &lt;&lt; endl; // &#125; // visited[1] = true; // for (int i = 1; i &lt;= n; i++) &#123; // for (int j = 1; j &lt;= n; j++) &#123; // cout &lt;&lt; T[i][j] &lt;&lt;\" \"; // &#125; // cout &lt;&lt; endl; // &#125; // dijistra(1); // for (int i = 1; i &lt;= n; i++) &#123; // cout &lt;&lt; d[i] &lt;&lt; endl; // &#125; // cout &lt;&lt;\"---\" &lt;&lt;endl; // for (int i = 1; i &lt;= n; i++) &#123; // cout &lt;&lt; cost[i] &lt;&lt; endl; // &#125; // cout &lt;&lt; d[n] &lt;&lt; endl; // if ( cost[n] &lt;= k)&#123; // cout &lt;&lt; d[n] &lt;&lt;endl; // &#125;else&#123; // cout &lt;&lt; -1 &lt;&lt;endl; // &#125; return 0;&#125; 牛客网华为练习题 合并表记录 12345678odict = dict()n = int(input().strip())for i in range(n): ids, val = map(int, input().split()) odict[ids] = odict.setdefault(ids, 0) + valslist = sorted(odict.items(), key= lambda d: d[0], reverse=True)for k, v in odict.items(): print(k, v) Python 中字典的有序无序针对的是插入顺序而不是键值大小顺序,要想根据key或value排序可以直接用sort后再输出。而如果输出要保持输入的顺序，则使用 collections下的 OrderedDict(‘记住插入顺序的字典’) Python逆序输出 1234567891011# reversen = input().strip()# for i in range()rev = reversed(n)for i in rev: print(i)# range(-1)s = 'hello'for i in range(len(s)-1, -1, -1): print(s[i])","categories":[],"tags":[]},{"title":"剑指Offer_leetcode刷题记录","slug":"剑指Offer-leetcode刷题记录","date":"2020-04-20T05:10:13.000Z","updated":"2021-01-24T07:39:51.486Z","comments":true,"path":"2020/04/20/剑指Offer-leetcode刷题记录/","link":"","permalink":"https://nymrli.top/2020/04/20/剑指Offer-leetcode刷题记录/","excerpt":"","text":"由于临近春招末期，时间比较紧，就不记录思考过程了，直接贴AC代码。以后有空补上 代码大多用C++，仅是过而已，没有进行优化。 面试题03. 数组中重复的数字 12345678910111213141516class Solution &#123;public: int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; std::ios::sync_with_stdio(false); int size = nums.size(); if (size &lt;0 ) return 0; vector&lt;int&gt; arr(size); for(int i=0; i &lt; size; i++)&#123; arr[nums[i]] += 1; if (arr[nums[i]] &gt; 1)&#123; return nums[i]; &#125; &#125; return 0; &#125;&#125;; 面试题04. 二维数组中的查找 123456789101112131415161718192021222324class Solution &#123;public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty()) return false; int column = matrix[0].size(); int row = matrix.size(); if (column &lt;= 0 || row &lt;= 0) return false; int r = 0 ; int c = column - 1; while( r &lt; row &amp;&amp; c &gt;= 0 )&#123; if (matrix[r][c] == target)&#123; return true; &#125;else if(matrix[r][c] &gt; target)&#123; c --; &#125;else&#123; r ++; &#125; &#125; return false; &#125;&#125;; 面试题05. 替换空格 123class Solution: def replaceSpace(self, s: str) -&gt; str: return s.replace(' ', '%20') 面试题06. 从尾到头打印链表 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt; ans; ListNode *p = head; while( p != NULL)&#123; ans.insert(ans.begin(), p-&gt;val); // or : ans.push_back(); // then : return reverse(ans.begin(), ans.end()); p = p-&gt;next; &#125; return ans;; &#125;&#125;; 顺便重新再写遍链表吧: 12 面试题07. 重建二叉树 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; if (preorder.empty() &amp;&amp; inorder.empty()) return NULL; TreeNode *root = createTree(preorder, inorder, 0, preorder.size()-1, 0, inorder.size()-1); return root; &#125; TreeNode *createTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int preL, int preR, int inL, int inR)&#123; if (preL&gt; preR) return NULL; int k; for( k=inL; k&lt;=inR; k++)&#123; // ▲写的挺熟练了, 就是多了个int被恶心坏了 if (preorder[preL] == inorder[k]) break; &#125; TreeNode *root= new TreeNode(preorder[preL]); int numLeft = k - inL; root-&gt;left = createTree(preorder, inorder, preL+1, preL + numLeft, inL, k-1); root-&gt;right = createTree(preorder, inorder, preL +numLeft + 1, preR, k+1, inR); return root; &#125;&#125;; 面试题09. 用两个栈实现队列 123456789101112131415161718192021222324252627282930313233343536class CQueue &#123;private: stack&lt;int&gt; s1; stack&lt;int&gt; s2;public: CQueue() &#123; &#125; void appendTail(int value) &#123; s1.push(value); &#125; int deleteHead() &#123; int ans; if(s1.empty() &amp;&amp; s2.empty() )return -1; if (s2.empty())&#123; while(!s1.empty())&#123; s2.push(s1.top()); s1.pop(); &#125; &#125; ans = s2.top(); s2.pop(); return ans; &#125;&#125;;/** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj-&gt;appendTail(value); * int param_2 = obj-&gt;deleteHead(); */ 面试题10- I. 斐波那契数列 12345678910111213141516171819202122class Solution &#123;private: int arr[105]; const int MOD = 1000000007;public: int fib(int n) &#123; if (n == 0)&#123; arr[n] = 0; return arr[n]; &#125;else if (n == 1)&#123; arr[n] = 1; return arr[n]; &#125; if ( arr[n] )&#123; return arr[n]; &#125;else&#123; // 这边是递归而不是arr[n-1] + arr[n-2] arr[n] = (fib(n-1)%MOD + fib(n-2)%MOD)%MOD; return arr[n]; &#125; &#125;&#125;; 面试题10- II. 青蛙跳台阶问题 问题实质就是fib 12345678910111213141516171819202122232425class Solution &#123; private: int arr[105]; const int MOD = 1000000007;public: int numWays(int n) &#123; if (n == 1)&#123; arr[n] = 1; return arr[n]; &#125;else if (n == 2)&#123; arr[n] = 2; return arr[n]; &#125;else if (n==0)&#123;// 比上题多了个范围 arr[n] = 1; return arr[n]; &#125; if ( arr[n] )&#123; return arr[n]; &#125;else&#123; // 这边是递归而不是arr[n-1] + arr[n-2] arr[n] = (numWays(n-1)%MOD + numWays(n-2)%MOD)%MOD; return arr[n]; &#125; &#125;&#125;; 面试题15. 二进制中1的个数 n &amp; (n-1)结果为 n &lt;- 将n最右边的1改成0的数 123456789101112class Solution &#123;public: int hammingWeight(uint32_t n) &#123; uint32_t tmp = n; int ans = 0; while(tmp)&#123; ans ++; tmp = tmp &amp; (tmp-1); &#125; return ans; &#125;&#125;; 面试题16. 数值的整数次方 快速幂， 对负数判断一下 123456789101112131415double myPow(double base, int n) &#123; double res = 1; bool fu = false; if (n&lt;0) fu = true; int tmp = abs(n); while(tmp&gt;0)&#123; if(tmp&amp;1) res = res * base; // cout &lt;&lt; res &lt;&lt; \" \" ; base = base * base; tmp &gt;&gt;= 1; &#125; if (fu) return 1/res; else return res;&#125; 面试题17. 打印从1到最大的n位数 因为n的范围没给， 所以其实需要考虑大数的，只不过不考虑好像也能过。 12345678910111213141516171819202122232425class Solution &#123;public: int pow(int base, int n)&#123; int res =1; for(int i=0;i&lt;n;i++) res *= base;; return res; &#125; vector&lt;int&gt; printNumbers(int n) &#123; int ans = 0; for(int i=0 ; i &lt; n ; i++)&#123; ans += 9*pow(10, i); &#125; vector&lt;int&gt; v; for(int i=1; i &lt;= ans; i ++) v.push_back(i); return v; &#125;&#125;; 写了个奇怪的东西 1234567891011121314151617181920212223242526#include &lt;algorithm&gt;#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; printNumbers(int n) &#123; vector&lt;int&gt; res; int arr[10005]; for(int i=0;i &lt; n;i++) //cout &lt;&lt; a &lt;&lt; \" \"; arr[i] = i; do&#123; string ans; for(int i=0;i &lt; n;i++) ans += '0'+arr[i]; res.push_back(atoi(ans.c_str())); &#125;while(next_permutation(arr, arr+n)); return res;&#125;int main()&#123; vector&lt;int&gt; v = printNumbers(3); for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; return 0;&#125; 面试题18. 删除链表的节点 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteNode(ListNode* head, int val) &#123; if (head == NULL) return NULL; if (head-&gt;val == val &amp;&amp; head-&gt;next == NULL) return NULL; if (head-&gt;val == val) return head-&gt;next; ListNode *pre = head; ListNode *p = head-&gt;next; while(p != NULL)&#123; if (p-&gt;val == val)&#123; pre-&gt;next = p-&gt;next; delete(p); p = pre-&gt;next; &#125;else&#123; pre = p; p = p-&gt;next; &#125; &#125; return head; &#125; &#125;; 面试题22. 链表中倒数第k个节点 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; if( head == NULL) return NULL; // int (k == 0 ) ; return head; // 把0删了就可以了 ListNode *p = head; for(int i = 0; i &lt; k-1; i++)&#123; if (p-&gt;next == NULL) return NULL; p = p-&gt;next; &#125; ListNode *jnode = head; while(p-&gt;next != NULL)&#123; p = p-&gt;next; jnode = jnode-&gt;next; &#125; return jnode; &#125;&#125;; 面试题24. 反转链表 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL) return NULL; // pre这个NULL卡了很久，如果反转的话，第一个节点需要指向NULL ListNode *pre = NULL; ListNode *p = head; ListNode *ans = NULL; if (p-&gt;next==NULL) return head; while (p != NULL)&#123; ListNode *next = p-&gt;next; if (next == NULL) ans = p; p-&gt;next = pre; pre = p; p = next; &#125; return ans; &#125;&#125;; 面试题25. 合并两个排序的链表 大晚上感觉思路还行, 就是细节过不了. 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(l1 == NULL) return l2; if(l2 == NULL) return l1; if (l1 == NULL &amp;&amp; l2 == NULL) return NULL; ListNode *head =new ListNode(0); // 随便生成一个表头, 最后忽略这个就行了 ListNode *newlist = head; while( l1 &amp;&amp; l2)&#123; if ( l1-&gt;val &lt; l2-&gt;val )&#123; newlist-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; newlist-&gt;next = l2; l2 = l2-&gt;next; &#125; newlist = newlist-&gt;next; // 指针也要往后 &#125; newlist-&gt;next = l1 ? l1 : l2; // 最后只剩一个 return head-&gt;next; &#125;&#125;; 面试题26. 树的子结构 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSubStructure(TreeNode* A, TreeNode* B) &#123; bool notsub = false; // if(A == NULL || B == NULL) return false; if ( A &amp;&amp; B)&#123; if ( A-&gt;val == B-&gt;val ) // 找到根节点 // notsub = isSubStructure(A, B); notsub = same(A,B); if (!notsub)&#123; // notsub = same(A-&gt;left,B); notsub = isSubStructure(A-&gt;left,B); &#125; if (!notsub)&#123; // notsub = same(A-&gt;right, B); notsub = isSubStructure(A-&gt;right, B); &#125; &#125; return notsub; &#125; bool same(TreeNode* A, TreeNode* B)&#123; if (B == NULL) return true; if (A==NULL) return false; if( A-&gt;val != B-&gt;val) return false; return same(A-&gt;left,B-&gt;left) &amp;&amp; same(A-&gt;right, B-&gt;right); &#125;&#125;; 面试题30. 包含min函数的栈 同时维护一个存储最小值的栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MinStack &#123;private: stack&lt;int&gt; common; stack&lt;int&gt; assist;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; common.push(x); if (assist.empty()) assist.push(x); else&#123; int top = assist.top(); if ( x &lt; top ) assist.push(x); else assist.push(top); &#125; &#125; void pop() &#123; // int tmp = common.top(); common.pop(); assist.pop(); // return tmp; &#125; int top() &#123; int tmp = common.top(); return tmp; &#125; int min() &#123; int tmp = assist.top(); // assist.pop(); return tmp; &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;min(); */ 面试题31. 栈的压入、弹出序列 123456789101112131415161718class Solution &#123;public: bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123; stack&lt;int&gt; st; int n = popped.size(); int j = 0; for (int i = 0; i &lt; pushed.size(); ++i)&#123; st.push(pushed[i]); while(!st.empty() &amp;&amp; j &lt; n &amp;&amp; st.top() == popped[j])&#123; // 注意逻辑短路问题， 判断是否为空 必须在top之前 st.pop(); ++j; &#125; &#125; return st.empty(); // return (j == sz); &#125;&#125;; 面试题32 - I. 从上到下打印二叉树 BFS层次遍历 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; levelOrder(TreeNode* root) &#123; vector&lt;int&gt; ans; if (root == NULL) return ans; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty())&#123; TreeNode *now = q.front(); q.pop(); ans.push_back(now-&gt;val); if (now-&gt;left) q.push(now-&gt;left); if (now-&gt;right) q.push(now-&gt;right); &#125; return ans; &#125;&#125;; 面试题32 - II. 从上到下打印二叉树 II 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt; int&gt; &gt; ans; if (root == NULL) return ans; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty())&#123; int sz = q.size(); // 统计当层的节点数 vector&lt;int&gt; row; for(int i=0; i &lt; sz; i++)&#123; TreeNode *now = q.front(); q.pop(); row.push_back(now-&gt;val); if (now-&gt;left) q.push(now-&gt;left); if (now-&gt;right) q.push(now-&gt;right); &#125; ans.push_back(row); &#125; return ans; &#125;&#125;; 面试题32 - III. 从上到下打印二叉树 III 控制an.push_back的内容 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt; vector&lt;int&gt; &gt; ans ; if (root== NULL) return ans; queue&lt;TreeNode*&gt; q; int level = 1; // 基层从前往后， 偶层从后往前 q.push(root); // 第一层 while(!q.empty())&#123; int n = q.size(); vector&lt;int&gt; line; for(int i = 0; i &lt; n; i ++)&#123; TreeNode *now = q.front(); q.pop(); line.push_back(now-&gt;val); if ( now-&gt;left != NULL) q.push(now-&gt;left); if ( now-&gt;right != NULL ) q.push(now-&gt;right); &#125; if ( level % 2 == 1) ans.push_back(line); else &#123; reverse(line.begin(), line.end()); ans.push_back(line); &#125; level ++; &#125; return ans; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123; if (postorder.empty()) return false; int sz = postorder.size(); return helper(postorder, 0, sz-1); &#125; bool helper(vector&lt;int&gt;&amp; postorder, int l, int r)&#123; int sz = postorder.size(); int rootkey = postorder[sz-1]; int smallp = 0; while( postorder[smallp] &lt; rootkey) smallp++; // 之后smallp 为第一个 &gt;= rootkey的索引， 即右子树的第一个 int bigp = smallp; while( bigp &lt; sz-1 )&#123; // 检测右子树是不是符合全部大于key if(postorder[bigp] &lt; rootkey) return false; &#125; bool left = true; if ( smallp &gt; 0 ) left = helper(postorder, l, smallp-1); bool right = false; if ( bigp &gt; 0) right = helper(postorder, smallp, r-1); return (left &amp;&amp; right); &#125;&#125;; 剑指 Offer 41. 数据流中的中位数 Java中priorityQueue的使用——借用堆完成 add+offer（push）、element+peek（front-top）、remove+poll（pop） c++优先队列(priority_queue)用法详解 参数缺省的话，优先队列就是大顶堆，队头元素最大。最小堆可以用仿函数less指定 如果是自定义类型, 则需要自己重载operator&lt; 或者 自己写仿函数() 仿函数: （functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符 12// priority_queue&lt;Type, Container, Functional&gt;, 其中Functional为仿函数, 如greater, less 数组中数字出现的次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std; int findFirst1(int n)&#123; int i = 0; cout &lt;&lt; \"enter\" &lt;&lt; n; // &amp;&amp; (i &lt; sizeof(int) * 8) while( ( n &amp; 1) == 0) &#123; //▲最后排查出来时这边括号没加 n = n &gt;&gt; 1; i++; &#125; // cout &lt;&lt; \"findFirst1\" &lt;&lt; i &lt;&lt; endl; return i; &#125; bool isbit1(int n, int index)&#123; n = n &gt;&gt; index; return (n &amp; 1); &#125; void solve(vector&lt;int&gt; &amp;v, int &amp;one, int &amp;two)&#123; int sz = v.size(); cout &lt;&lt; sz &lt;&lt; endl; int firstXOR = 0; // cout &lt;&lt; \"begin\" ; for(int i = 0; i &lt;sz; i++) &#123; cout &lt;&lt; v[i]; firstXOR ^= v[i]; &#125; // cout &lt;&lt; endl; // cout &lt;&lt; \"firstXOR\" &lt;&lt; firstXOR &lt;&lt; endl; int index = findFirst1(firstXOR); // cout &lt;&lt; index &lt;&lt; endl; for(int i = 0; i &lt; sz;i++ )&#123; if ( isbit1(v[i], index) )&#123; one ^= v[i]; &#125;else&#123; two ^= v[i]; &#125; &#125; &#125; vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; v(2); if (nums.empty()) return v; solve(nums, v[0], v[1]); return v; &#125;int main()&#123; int arr[] = &#123;1,2,5,2&#125;; vector&lt;int&gt; v(arr, arr+ 4); vector&lt;int&gt; ans = singleNumbers(v);; cout &lt;&lt; ans[0] &lt;&lt; \" \" &lt;&lt; ans[1] &lt;&lt; endl;&#125; 面试题47. 礼物的最大价值-dp 12345678910111213141516class Solution: def maxValue(self, grid: List[List[int]]) -&gt; int: row, col = len(grid), len(grid[0]) # print(row, col ) # 初始化第一列 for r in range(1, row): grid[r][0] += grid[r-1][0] # 初始化第一行 for c in range(1, col): grid[0][c] += grid[0][c - 1] # dp状态更新 for i in range(1, row): for j in range(1, col): grid[i][j] += max(grid[i-1][j], grid[i][j - 1]) return grid[row - 1][col - 1] 面试题49. 丑数 12345678910class Solution: def nthUglyNumber(self, n: int) -&gt; int: dp, a, b, c = [1] * n, 0 , 0, 0 for i in range(1, n): n2, n3, n4 = dp[a] * 2, dp[b] * 3, dp[c] * 5 dp[i] = min(n2, n3, n4) if dp[i] == n2: a+=1 if dp[i] == n3: b+=1 if dp[i] == n4: c+=1 return dp[-1] 面试题50. 第一个只出现一次的字符 1234567891011from collections import OrderedDictclass Solution: def firstUniqChar(self, s: str) -&gt; str: hashtable = OrderedDict() for i in s: hashtable[i] = hashtable.setdefault(i, 0) + 1 for k, v in hashtable.items(): if v == 1: return k return ' ' 剑指 Offer 53 - I. 在排序数组中查找数字 I 看到&quot;在排序数组中查询&quot;==&gt; 二分查找 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; return getRight(nums, target) - getLeft(nums, target) + 1; &#125; // 找到和target相等的最边界(target 最小的下标) int getLeft(vector&lt;int&gt;&amp; v, int target)&#123; int len = v.size(); int l = 0, r = len-1; while( l &lt;= r)&#123; int m = l + r &gt;&gt; 1; if ( v[m] &lt; target)&#123; l = m + 1; &#125;else&#123; // 如果相等的话缩小右边边界 r = m - 1; &#125; &#125; return l; &#125; // 找到和target的最右界(比target大的最小下标) int getRight(vector&lt;int&gt;&amp; v, int target)&#123; int len = v.size(); int l = 0, r = len-1; while( l &lt;= r)&#123; int m = l + r &gt;&gt; 1; if ( v[m] &lt;= target)&#123; // 如果相等的话, 说明之前都是正确的, 那么就需要缩小左边界的范围 l = m + 1; &#125;else&#123; r = m - 1; &#125; &#125; return r; &#125;&#125;; [剑指 Offer 53 - II. 0～n-1中缺失的数字 一个长度为n-1的递增排序数组中的所有数字都是唯一的==&gt;二分 为什么最后return l解析 1234567891011121314151617class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int l = 0, r = len - 1; while( l &lt;= r) &#123; // 当 arr[r - l] 为空时跳出 int mid = (l + r) &gt;&gt; 1; if ( nums[mid] == mid)&#123; l = mid + 1; &#125;else if ( nums[mid] &gt; mid)&#123; r = mid - 1; &#125; &#125; // 当 r == l == mid时,还会再进行一轮, 此时有arr[mid] != mid 那么就是当前数字出了问题, return谁都可以, 但由于mid是在while里声明的, 因此只考虑return l or r, 由于不相等的情况下该轮while结束后r := mid - 1, 因此就偏离了。 最终就选取l了. return l; &#125;&#125;; 面试题52. 两个链表的第一个公共节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: node1, node2 = headA, headB while node1 != node2: node1 = node1.next if node1 else headB node2 = node2.next if node2 else headA return node1 # # Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = None# def getListLength(head):# if head == None:# return -1# ans = 0# while head != None:# ans += 1# head = head.next# return ans# def getIntersectionNode(headA: ListNode, headB: ListNode) -&gt; ListNode:# # print(headA, headB)# lena = getListLength(headA)# lenb = getListLength(headB)# print(lena, lenb)# diff = lena - lenb # if diff&gt;0:# flagalong = True# else:# flagalong = False# if flagalong:# listLong = headA# listShort = headB# else:# listLong = headB# listShort = headA# diff = -diff# # print(diff)# for i in range(diff):# listLong = listLong.next # # print(listLong.val, listShort.val)# while listLong != None and listShort != None and listLong.val != listShort.val:# listShort = listShort.next# listLong = listLong.next# return listLong # headA2 = ListNode(4)# headA1 = ListNode(3)# HeadA = ListNode(1)# headA1.next = headA2# HeadA.next = headA1# headB2 = ListNode(4)# headB1 = ListNode(3)# HeadB = ListNode(2)# headB1.next = headB2# HeadB.next = headB1 面试题54. 二叉搜索树的第k大节点 中序遍历, 从右往左的顺序就是从大往小 123456789101112131415161718192021class Solution &#123;public: int kthLargest(TreeNode* root, int k) &#123; help(root,k); return ans; &#125; void help(TreeNode* root,int k)&#123; if(root!=nullptr)&#123; help(root-&gt;right,k); visit(root,k); help(root-&gt;left,k); &#125; &#125; void visit(TreeNode* root,int k)&#123; th++; if(th==k) ans=root-&gt;val; &#125;private: int th=0; int ans=0;&#125;; 面试题57. 和为s的两个数字 12345678910111213class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: l = 0 r = len(nums) - 1 while l &lt; r: sums = nums[l] + nums[r] if sums &gt; target: r -= 1 elif sums &lt; target: l += 1 else:return nums[l], nums[r] return [] 面试题58 - I. 翻转单词顺序 12345678class Solution: def reverseWords(self, s: str) -&gt; str: res = s.split() return ' '.join(reversed(res)) def reverseWords(self, s: str) -&gt; str: res = s.split() return ' '.join(reversed(res)) 面试题58 - II. 左旋转字符串 123class Solution: def reverseLeftWords(self, s: str, n: int) -&gt; str: return s[n:] + s[:n] 面试题59 - I. 滑动窗口的最大值 12345678class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: ans = [] if not nums: return [] for i in range(len(nums) - k + 1): ans.append(max(nums[i: i + k])) return ans 面试题59 - II. 队列的最大值 1234567891011121314151617181920212223242526from queue import deque, Queueclass MaxQueue: def __init__(self): self.queue = Queue() self.deque = deque() def max_value(self) -&gt; int: return self.deque[0] if self.deque else -1 def push_back(self, value: int) -&gt; None: while self.deque and value &gt; self.deque[-1]: self.deque.pop() self.deque.append(value) self.queue.put(value) def pop_front(self) -&gt; int: if not self.deque: return -1 ans = self.queue.get() if ans == self.deque[0]: self.deque.popleft() return ans 面试题60. n个骰子的点数-dp 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;double&gt; twoSum(int n) &#123; int dp[15][70]; memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= 6; i ++) &#123; dp[1][i] = 1; &#125; for (int i = 2; i &lt;= n; i ++) &#123; for (int j = i; j &lt;= 6*i; j ++) &#123; for (int cur = 1; cur &lt;= 6; cur ++) &#123; if (j - cur &lt;= 0) &#123; break; &#125; dp[i][j] += dp[i-1][j-cur]; &#125; &#125; &#125; int all = pow(6, n); vector&lt;double&gt; ret; for (int i = n; i &lt;= 6 * n; i ++) &#123; ret.push_back(dp[n][i] * 1.0 / all); &#125; return ret; &#125;&#125;; 面试题61. 扑克牌中的顺子 123456789101112131415161718192021class Solution: def isStraight(self, nums: List[int]) -&gt; bool: if not nums: return False sort_list = sorted(nums) anything = 0 # if sort_list[-1] - sort_list[0] == 4: gap = 0 for index in range(len(sort_list) - 1): now_val = sort_list[index] next_val = sort_list[index+1] # print(now_val, next_val) if now_val == 0: anything += 1 elif now_val &gt; 0: # 出现对子 if now_val == next_val: return False else: gap += next_val - now_val -1 # print(gap, anything) if gap &gt; anything: return False else: return True 面试题62. 圆圈中最后剩下的数字 123456789def f(n, m): if n == 0: return 0 x = f(n - 1, m) return (m + x) % nclass Solution: def lastRemaining(self, n: int, m: int) -&gt; int: return f(n, m) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# # Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = None# def getListLength(head):# if head == None:# return -1# ans = 0# while head != None:# ans += 1# head = head.next# return ans# def getIntersectionNode(headA: ListNode, headB: ListNode) -&gt; ListNode:# # print(headA, headB)# lena = getListLength(headA)# lenb = getListLength(headB)# print(lena, lenb)# diff = lena - lenb # if diff&gt;0:# flagalong = True# else:# flagalong = False# if flagalong:# listLong = headA# listShort = headB# else:# listLong = headB# listShort = headA# diff = -diff# # print(diff)# for i in range(diff):# listLong = listLong.next # # print(listLong.val, listShort.val)# while listLong != None and listShort != None and listLong.val != listShort.val:# listShort = listShort.next# listLong = listLong.next # return listLong # headA2 = ListNode(4)# headA1 = ListNode(3)# HeadA = ListNode(1)# headA1.next = headA2# HeadA.next = headA1# headB2 = ListNode(4)# headB1 = ListNode(3)# HeadB = ListNode(2)# headB1.next = headB2# HeadB.next = headB1 最长公共前缀 12345678910111213141516171819class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if len(strs) == 0: return '' if len(strs) == 1: return strs[0] strs = sorted(strs) idx = 0 minlen = min(len(strs[0]), len(strs[-1])) print( strs[0], strs[-1]) while idx &lt; minlen: if strs[0][idx] != strs[-1][idx]: return strs[0][:idx] idx += 1 return len(strs[0]) if len(strs[0]) &lt; len(strs[-1]) else len(strs[-1]) # s = Solution()print(s.longestCommonPrefix(['abcd', 'abdd', 'aad'])) 模拟队列 腾讯笔试题第一题，第四题为“两个栈模拟队列” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * @Author: Mrli * @Date: 2020-04-26 19:58:20 * @LastEditTime: 2020-04-27 22:58:50 * @Description: */// #include &lt;bits/stdc++.h&gt; //万能头文件#include &lt;iostream&gt;using namespace std; //命名空间const int MAXN = 1005;int arr[MAXN];int main() &#123; ios::sync_with_stdio(false); //取消输入输出流等待同步 int T; cin &gt;&gt;T; while(T--)&#123; int n; // n个操作 cin &gt;&gt;n; fill(arr, arr+MAXN, 0); int di = 0; int start = di; int p = di; // 栈底为-1 尾指针 for(int i = 0; i &lt; n; i ++)&#123; string operate; cin &gt;&gt; operate; // cout &lt;&lt; \"p:\" &lt;&lt; p &lt;&lt; start &lt;&lt; endl; if (operate == \"PUSH\") &#123; int num; cin &gt;&gt; num; arr[p++] = num; &#125;else if (operate == \"TOP\")&#123; if ( p == start) cout &lt;&lt; -1 &lt;&lt;endl; else cout &lt;&lt; arr[start] &lt;&lt;endl; &#125;else if (operate == \"POP\")&#123; if (p == start) cout &lt;&lt; -1 &lt;&lt;endl; else start++; &#125;else if (operate == \"SIZE\")&#123; cout &lt;&lt; p - start &lt;&lt; endl; &#125;else if (operate == \"CLEAR\")&#123; p = di; start = di; &#125; &#125; &#125; return 0;&#125;// 2// 7// PUSH 1// PUSH 2// TOP// POP// TOP// POP// POP// 5// PUSH 1// PUSH 2// SIZE// POP// SIZE 记一下二维vector的初始化 1234567vector&lt; vector&lt;int&gt; &gt; v(3, vector&lt;int&gt;(5,4));for(int i = 0; i &lt; v.size() ; i ++)&#123; for(int j = 0 ; j &lt; v[0].size(); j++)&#123; cout &lt;&lt; v[i][j] ; &#125; cout &lt;&lt; endl; &#125; 和通过数组来初始化 12int arr[] = &#123;1,6,3,2,5&#125;;vector&lt;int&gt; ans(arr, arr + sizeof(arr)); 华为2016年秋招题： A: 123456789101112131415161718while True: try: # try一定要最后加， 不然不好debug n, m = map(int, input().split()) grades = list(map(int, input().split())) for i in range(m): opt, (ids), (val) = input().strip().split() ids = int(ids) val = int(val) if opt == 'U': grades[ids-1] = val elif opt == 'Q': start, end = sorted([ids, val]) print(max( grades[start-1: end])) except: break# print(\"a\" &lt; \"b\" , \"3\" &lt; \"4\")# print('a' &lt; 'b' , '3' &lt; '4')# print('A' &lt; 'b' , 'A' &lt; '2') B[编程题]简单错误记录 123456789101112131415161718192021222324252627282930313233343536'''@Author: Mrli@Date: 2020-04-28 21:47:46@LastEditTime: 2020-04-28 22:22:20@Description: '''import collections# import sysrec_dict = collections.OrderedDict()# 另一种输入方式# for line in sys.stdin:# ele = line.split('\\\\')[-1].strip('\\n')# if ele not in lst:# lst.append(ele)# if ele in dct:# dct[ele] = dct[ele] + 1# else:# dct[ele] = 1while True: try: ins = input().strip() path = ins.split('\\\\')[-1] if path not in rec_dict: rec_dict[path] = 1 else: rec_dict[path] += 1 except EOFError: break# print(rec_dict)sort_res = sorted(rec_dict.items(), key = lambda d: d[1], reverse=True)# print(rec_dict)for k, v in sort_res[:8]: path, linenum = k.split() print(path[-16:], linenum, v) Tips: 两种输入方式的推出都为：ctrl + z EOF是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。资料源通常称为档案或串流。 而在不同系统的EOF所代表的值是不一样的，在Visual Studio 2017下为ctrl+c，windows下为ctrl+z，linux/unix下为ctrl+c或ctrl+d； 运用这个小技巧可以在调试的时候手动结束，很方便。 两路合并算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980void merge(int *arr, int l, int mid, int r)&#123; int begin1, begin2; begin1 = l; begin2 = mid+1; int index; // 新数组添加元素的索引值 // int *newarr = (int *)malloc((r-l+1)*sizeof(int)); int *newarr = new int[r-l+1]; for(index = 0; begin1 &lt;= mid &amp;&amp; begin2 &lt;= r; )&#123; if ( arr[begin1] &lt; arr[begin2] )&#123; newarr[index++] = arr[begin1++]; &#125; else&#123; newarr[index++] = arr[begin2++]; &#125; &#125; cout &lt;&lt;\"lmr: \" &lt;&lt; l &lt;&lt;\" \" &lt;&lt;mid &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; // cout &lt;&lt; \"res:\" &lt;&lt; (begin1 &lt;= mid) &lt;&lt; (begin2 &lt;= r) &lt;&lt;endl; // while (begin1 &lt;= mid)&#123; // newarr[index++] = arr[begin1++]; // &#125; // while(begin2 &lt;= r)&#123; // newarr[index++] = arr[begin2++]; // &#125; if (begin1 &lt;= mid)&#123; newarr[index++] = arr[begin1++]; &#125; else&#123; newarr[index++] = arr[begin2++]; &#125; int start = l; // arr开始更新的地方 int k = 0; // 新数组 // while( start &lt;= r)&#123; // 将新数组全部拷贝进 arr[l] -&gt; arr[r] // arr[start++] = newarr[k++]; //copy排好序的数。 // &#125; for(int i = l; i &lt;= r; i++)&#123; cout &lt;&lt; newarr[k]; arr[i] = newarr[k++]; &#125;&#125;void mergesort(int *arr, int l, int r)&#123; if (l &lt; r)&#123; int mid = l + ((r-l) &gt;&gt;1); // ▲位运算一定要加括号 // int mid = (l+r)/2; mergesort(arr, l, mid); mergesort(arr, mid+1, r); merge(arr, l, mid, r); cout &lt;&lt;\"arr: \" &lt;&lt; l &lt;&lt;\" \" &lt;&lt;mid &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; &#125;&#125; void mergeSort(int* arr, int s, int t) &#123; if (s &lt; t) &#123; int m = (s + t) / 2; mergeSort(arr, s, m); mergeSort(arr, m + 1, t); merge(arr, s, m, t); &#125; &#125;int main()&#123; // srand( (unsigned)time( NULL ) ); // Random(N); int a[N] = &#123;3,2,5,4,1&#125;; for(int i = 0 ; i &lt; N; i++) cout &lt;&lt; a[i] &lt;&lt;\" \"; // // mergeSort(a, 0, N-1);// 改 mergesort(a, 0, N-1); cout &lt;&lt; \"after sort:\" &lt;&lt;endl; for(int i = 0 ; i &lt; N; i++) cout &lt;&lt; a[i] &lt;&lt;\" \"; // for(int i= 0; i &lt; 10 ;i ++)&#123; // for( int j = 0; j &lt; 5; j ++)&#123; // cout &lt;&lt; ( i + j)/ 2 &lt;&lt;\" \" &lt;&lt; (i + (j-2)) // &#125; // &#125; return 0;&#125; 快排 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;void quickSort(int a[], int m,int n);int partion(int a[], int m, int n);int main()&#123; int a[] = &#123; 6,1,2,7,9,3,4,5,10,8 &#125;; int m = 0; int n = (sizeof(a) / 4)-1; quickSort(a, m,n); for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125;&#125;void quickSort(int a[], int m, int n)&#123; if (m &lt; n) &#123; int q = partion(a, m, n); quickSort(a, m, q ); quickSort(a, q + 1, n); &#125;&#125;int partion(int a[], int m, int n)&#123; int key=m; int j= n,i=m; int temp1, temp2; while (i != j) &#123; while (a[j] &gt; a[key] &amp;&amp; i &lt; j) &#123; --j; &#125; while ((a[i] &lt; a[key]) &amp;&amp; (i &lt; j)) &#123; ++i; &#125;if (i &lt; j) &#123; temp1 = a[j]; a[j] = a[i]; a[i] = temp1; &#125; &#125; temp2 = a[key]; a[key] = a[i]; a[i] = temp2; return i;&#125; 123456789101112131415void quickSort(int arr[], int l, int r)&#123; if ( l &gt;= r) return; int i = l, j = r; int key = l + r &gt;&gt; 1; int x = arr[key]; while ( i &lt; j)&#123; while (arr[j] &gt; x ) j --; while (arr[i] &lt; x) i++; if (i &lt; j)&#123; swap(arr, i, j); &#125; quickSort(arr, l, j); quickSort(arr, j+1, r); &#125;&#125; 上述两种有重复元素就爬了 12345678910111213void quick_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) &#123; do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j), quick_sort(q, j + 1, r);&#125; 记录下C++的split写法： 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; getline(cin, s); // cout &lt;&lt; s &lt;&lt; endl; int dindex = s.find('-'); cout &lt;&lt; dindex&lt;&lt; endl; string a = s.substr(0, dindex); string b = s.substr(dindex+1); cout &lt;&lt; a &lt;&lt; \"*\" &lt;&lt; b; cout &lt;&lt; set return 0;&#125; C/C++中substr函数的应用(简单讲解) C++如何保留两位有效数字！！！！ 123456def removeElement(nums, val): # print(nums) nums = list(map(str, nums)) st = &apos;&apos;.join(nums) st = st.replace(str(val), &apos;&apos;) return list(map(int, st)) 1234567891011121314class Solution: @staticmethod def firstUniqChar( s: str) -&gt; str: hashtable = OrderedDict() ans = '' for i in s: hashtable[i] = hashtable.setdefault(i, 0) + 1 for k, v in hashtable.items(): if v == 1: return kres = Solution.firstUniqChar(\"abaccdeff\")print(res) Sum为m, 拆成n个数, 有哪些情况?(非连续) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; ans;int idx;void printRes()&#123; for(auto &amp;i: ans)&#123; cout &lt;&lt; i &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;// way1void func(int val, int n)&#123; if (n == 1)&#123; ans.push_back(val); idx ++; cout &lt;&lt; \"Case:\" &lt;&lt; idx &lt;&lt; endl; printRes(); cout &lt;&lt; \"==========\" &lt;&lt; endl; ans.pop_back(); return ; &#125; // 去重 int last; if ( ans.empty() ) last = 1; else last = ans.back(); for (int i = last; i &lt;= val/2 ; i++) &#123; ans.push_back(i); func(val-i, n-1); ans.pop_back(); &#125;&#125;// way2// void func(int val, int n, int start)&#123;// if (n == 1)&#123;// ans.push_back(val);// idx ++;// cout &lt;&lt; \"Case:\" &lt;&lt; idx &lt;&lt; endl;// printRes();// cout &lt;&lt; \"==========\" &lt;&lt; endl;// ans.pop_back();// return ;// &#125;// for (int i = start; i &lt;= val/2 ; i++) &#123;// ans.push_back(i);// func(val-i, n-1, i);// ans.pop_back();// &#125;// &#125;int main()&#123; // way1 func(20, 4); // way2 // func(20, 4, 1); return 0;&#125; Sum为m, 拆成n个数, 有哪些情况?(连续) 1234567891011121314151617181920212223public int subarraySum(int[] nums, int k) &#123; // hash // 记录合适的连续字符串数量 int count=0; // 记录前面数字相加之和 int pre=0; // map记录前几个数字之和为K出现相同和的次数为V HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); // 初始化 map.put(0,1); for (int i = 0; i &lt; nums.length; i++) &#123; pre+= nums[i]; // 如果前面数字之和加上这个数字正好等于K（存在一个数字加上nums[i]结果为K // 说明找到了 if (map.containsKey(pre-k))&#123; // 累计 count+=map.get(pre-k); &#125; // 计算新的和放入map map.put(pre,map.getOrDefault(pre,0)+1); &#125; return count; &#125;","categories":[],"tags":[]},{"title":"VsCode环境、配置Latex(texLive)","slug":"VsCode配置Latex(texLive)环境","date":"2020-03-23T07:04:53.000Z","updated":"2020-09-17T02:00:15.623Z","comments":true,"path":"2020/03/23/VsCode配置Latex(texLive)环境/","link":"","permalink":"https://nymrli.top/2020/03/23/VsCode配置Latex(texLive)环境/","excerpt":"","text":"写在前面: 除了配置VsCode以外， 我还配置了Sublime，一开始是不想用SumatraPDF，以为能省的。事实上，Vscode也确实提供了三种方法：在web browser、编辑器tab、外部PDF阅读器，共三种办法。个人感觉tab界面太小、浏览器查看毕竟还是没有PDF舒服，最后都体验下来还是选择了外部阅读器，而且SumatraPDF支持正向、反向搜索，挺香的。当然，还有种做法是把PDF编译出来以后，再用日常使用的阅读器打开PDF阅读也是可以的，我个人平时用福昕PDF阅读器会多一点 SumatraPDF阅读器是个非常轻量级的PDF阅读器，开源轻巧，免安装，共14.6MB。要想配套使用PDF阅读器，网上教程基本上推荐的都是SumatraPDF，应该是SumatraPDF在适配Latex上做的比较好。我试了试指定福昕失败了。 安装Texlive 上Texlive的官网， 有在线安装和DVD安装两种方式，我们选择后者。在http://mirrors.sjtug.sjtu.edu.cn/ctan/systems/texlive/Images/中下载texlive2019.iso的镜像，之后解压，选择install-tl-advanced.bat配置高级版(最好右键管理员身份运行)。 可以点击“Advanced”进入高级安装来修改安装位置、取消你不需要安装的宏包。其中TeXworks 前端就是它自带的编辑器，不需要的可以取消。语言我基本就只选了Chinese, Chinese/Janpanse/Korean, English 点击“Customize”来取消勾选不需要的宏包。 很多宏包和功能我个人并不需要，因此我在这里取消勾选，大家可以根据需要勾选自己需要的功能，如果嫌麻烦全部安装也可以，并不消耗多少空间。 设置完安装路径等选项之后点击“安装”，之后静坐 20 分钟等待安装完成。 安装VsCode 略, 基本安装就行了。用了很久的Sublime， 突然间想换个新的了， 而且VsCode确实也非常好看。 安装VsCode中Latex插件—— LaTeX Workshop 此时导入Latex工程，查看tex文件就可以看到关键字高亮了。 配置LaTeX Workshop 插件 菜单栏&quot;File-&gt;Preference-&gt;Settings&quot;然后选择右上角三个按钮中最左边的(Open settings(JSON)), 然后将括号里的内容填充到大括号里就行了，下面已经是我JSON配置的安装文件，可复制直接替换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&#123; \"latex-workshop.showContextMenu\":true, //右键菜单 \"latex-workshop.latex.tools\": [ &#123; \"name\": \"latexmk\", \"command\": \"latexmk\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"-pdf\", \"%DOC%\" ] &#125;, &#123; \"name\": \"xelatex\", \"command\": \"xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] &#125;, &#123; \"name\": \"pdflatex\", \"command\": \"pdflatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] &#125;, &#123; \"name\": \"bibtex\", \"command\": \"bibtex\", \"args\": [ \"%DOCFILE%\" ] &#125; ],\"latex-workshop.latex.recipes\": [ &#123; \"name\": \"xelatex\", \"tools\": [ \"xelatex\" ] &#125;, &#123; \"name\": \"latexmk\", \"tools\": [ \"latexmk\" ] &#125;, &#123; \"name\": \"pdflatex -&gt; bibtex -&gt; pdflatex*2\", \"tools\": [ \"pdflatex\", \"bibtex\", \"pdflatex\", \"pdflatex\" ] &#125; ],\"latex-workshop.view.pdf.viewer\": \"browser\", //\"latex-workshop.view.pdf.viewer\": \"external\",//\"latex-workshop.view.pdf.ref.viewer\":\"external\",//\"latex-workshop.view.pdf.external.viewer.command\": \"E:\\\\a常用工具\\\\SumatraPDF-3.2-64\\\\SumatraPDF-3.2-64.exe\", // 注意修改路径//\"latex-workshop.view.pdf.external.synctex\": &#123;// \"command\": \"E:\\\\a常用工具\\\\SumatraPDF-3.2-64\\\\SumatraPDF-3.2-64.exe\",// \"args\": [// \"-forward-search\", // \"%TEX%\",// \"%LINE%\",// \"%PDF%\"// ]//&#125;,\"latex-workshop.latex.clean.fileTypes\": [ \"*.aux\", \"*.bbl\", \"*.blg\", \"*.idx\", \"*.ind\", \"*.lof\", \"*.lot\", \"*.out\", \"*.toc\", \"*.acn\", \"*.acr\", \"*.alg\", \"*.glg\", \"*.glo\", \"*.gls\", \"*.ist\", \"*.fls\", \"*.log\", \"*.fdb_latexmk\" ]&#125; ▲保存后，一定要重启VsCode，不然无法生效。我当时就是直接去编译了，报了Recipe terminated with fatal error: spawn pdflatex ENOENT.的错误提示。 其中需要指出的是：&quot;latex-workshop.view.pdf.viewer&quot;: &quot;browser&quot;,设置的是默认阅览PDF的方式，一共有3种：web browser、编辑器tab、外部PDF阅读器。我注释掉的是设置SumatraPDF的方式。这个设置好后，再在Vscode中选择View Latex PDF时就会根据这个配置打开默认阅读PDF的方式，当然也可以点开View Latex PDF的下拉选项，进行指定方式的查阅。 正向搜索 查看code中选中的内容在PDF中什么位置。 选择外部阅读器后，可以通过加入下列实现正向搜索功能。 123456789\"latex-workshop.view.pdf.external.synctex\": &#123; \"command\": \"E:/Programs/SumatraPDF/SumatraPDF.exe\", // 修改SumatraPDF路径 \"args\": [ \"-forward-search\", \"%TEX%\", \"%LINE%\", \"%PDF%\" ]&#125;, 正向搜索的使用：将光标移动到TeX文件的正文。ctrl+alt+x，找到&quot;navigator,select and edit&quot;，点击第一项syncTeX from cursor(或右键选择，或快捷键ctrl+alt+j)，会切换到PDF文件的相应位置。——设置“Latex右键菜单”后也可以右键选择syncTeX from cursor 反向搜索 查看PDF中选中的内容在code中什么位置。 选择&quot;设置-&gt;选项&quot; 将下列内容填入箭头所指位置，路径修改下即可（为一行内容） 1&quot;C:\\Users\\Marvey\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe&quot; &quot;C:\\Users\\Marvey\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\out\\cli.js&quot; -g &quot;%f&quot;:&quot;%l&quot; 感谢 @Macrofuns指出，如果不加双引号，在文件路径有空格的情况下会导致无法反向搜索） 其他设置 LaTeX Workshop 默认保存的时候自动编译，如果不喜欢这个设置，可以添加以下代码进入设置区： 123\"latex-workshop.showContextMenu\":true, //右键菜单 \"latex-workshop.intellisense.package.enabled\": true, //根据加载的包，自动完成命令或包 \"latex-workshop.latex.autoBuild.run\": \"never\", //禁止保存文件时自动build 借鉴From： 使用VSCode编写LaTeX(latex+vscode+SumatraPDF) 最后推荐两个配置视频： 使用 Sublime Text +TexLive 搭建 LaTeX 编写环境——用sublime看这个视频基本就够了 为VSCode配置LaTex编译环境(TeXLive) VsCode其他配置 不准备单独再开一篇文章介绍我怎么配置的了， 就在此篇文章里略微提及下把。 插件 Code run 能够让你的IDE基本上运行大多数代码，只好安装编程语言时Path设置正确，默认配置就可以直接运行。 默认编译运行的快捷键是ctrl + Alt + N，由于之前用的都是Sublime， 里面编译是Ctrl+B， 因此用习惯后有点不想改就直接修改掉了。方法为：Ctrl + Shift + P打开输入框，输入Keyboard Shortcuts, 就会弹出目前所有的快捷键，然后再将原来的Ctrl +B的快捷键取消(直接输入Ctrl +B就能找到目前谁的快捷键是Ctrl +B)，然后再输入Code run，将其快捷键设置为Ctrl +B即可。 在运行Python代码的过程中，一直报错: The environment variable 'Path' seems to have some paths containing the '&quot;' character. The existence of such a character is known to have caused the Python extension to not load. If the extension fails to load please modify your paths to remove this '&quot;' character.后来在找到解决方案😗* 是因为你在添加其他环境变量时，加了; 分号—&gt;删掉就好了** open in browser 编写html页面调试时比较方便 koroFileHeader 自动生成头部注释和函数注释的，测试了一下，除了html以外基本上都能用，挺好使的。 如果不满意默认配置， 可以自己再稍微调一调，展示下我的设置： 12345678910111213141516171819202122232425262728&#123; /** * @description: Latex相关配置 */ \"latex-workshop.showContextMenu\":true, //右键菜单 // ...Latex的太多了, 就不一一展示了. /** * @description: koroFileHeader相关配置 * ctrl+alt+i,添加文件头注释, ctrl+alt+t,添加函数注释 * \"Do not edit\"的内容会自动添加 */ \"fileheader.customMade\": &#123; //文件头部注释 \"Author\": \"Mrli\", \"Date\": \"Do not edit\", // 文件创建事件 \"LastEditTime\": \"Do not edit\", // 文件最后编辑时间 \"Description\": \"\", &#125;, \"fileheader.cursorMode\": &#123; // 函数注释 \"Author\": \"Mrli\", \"Date\": \"Do not edit\", // 当前时间, 函数的开始编写、完成编写时间 \"Description\": \"\", \"param\": \"\", \"return\": \"\", &#125;, \"editor.fontFamily\": \"Monaco, 'Courier New', monospace\"&#125;// 好用插件推荐 https://blog.csdn.net/qq_41139830/article/details/85221330 用户对插件的自定义配置基本上都是写在这个settings.json下。当然，可以对某个项目单独设置配置，即会在项目文件夹下生成.vscode文件夹，里面会有个settings.json来进行配置. Bracket Pair Colorizer 编写JS代码时我是感觉真的好用，JS里大括号和括号有时真的很难记得匹配次序。 Anaconda Extension Pack 就图他的关键字提醒补全。 插件比较大， 安装了挺久的，好像还自带一个Python Extension插件。 Autopep8 测试自动规范代码(Alt + Shift + F)时，提示要安装Autopep8，那就安装咯。但这个应该只能算Python的插件，python.exe -m pip install -U autopep8 --user Path Autocomplete 有时候程序需要读取文件，自己手动去复制文件路径还是比较麻烦的，不过有了这个插件就方便多了，它能自动感知当前目录下所有的文件，只需要你自己选择就好了。 windows opacity 设置窗口透明度的，一开始以为挺好用， 用了后发现自己还想不太喜欢， 真的是太透明了，可以设置0-255， 240我用着差不多。（0的话会消失的） 还有些可以网上再找找，推个挺不错的博客： https://blog.csdn.net/hnshhshjq/article/details/80140401 ★ https://mp.weixin.qq.com/s?__biz=MzAxOTcxNTIwNQ==&amp;mid=2457918435&amp;idx=2&amp;sn=78a94468973f701e674246f1d520434b&amp;chksm=8cb6be09bbc1371fc6582cc7eda6791278165c6527e385f49ee56ceea94e9ca2e3f45efce368&amp;scene=21#wechat_redirect 用户自定义快捷代码段： File -&gt; Preferences -&gt; User snippets， 附一段我的C++设置 -&gt; cpp.sjon 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected. // Example: // \"Print to console\": &#123; // \"prefix\": \"log\", // \"body\": [ // \"console.log('$1');\", // \"$2\" // ], // \"description\": \"Log output to console\" // &#125; \"Print out fori\": &#123; \"prefix\": \"fori\", \"body\": [ \"for (int i = 0; i &lt; $1; i++) &#123;\", \" $0\", \"&#125;\" ], \"description\": \"Output Loop 'fori'\" &#125;, \"Print out forj\": &#123; \"prefix\": \"forj\", \"body\": [ \"for (int j = 0; j &lt; $1; j++) &#123;\", \" $0\", \"&#125;\" ], \"description\": \"Output Loop 'forj'\" &#125;, \"Common template\": &#123; \"prefix\": \"qqq\", \"body\": [ \"#include &lt;bits/stdc++.h&gt;\", \"using namespace std;\", \"const int INF = 0x3f3f3f3f;\", \"int n;\", \"\", \"\", \"int main()&#123;\", \" ios::sync_with_stdio(false);\", \" cin.tie(0);\", \" \", \" $0\", \" \", \" return 0;\", \"&#125;\" ] &#125;&#125; 快捷键: https://www.cnblogs.com/schut/p/10461840.html","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"算法笔记Codeup题解","slug":"算法笔记Codeup题解","date":"2020-03-04T06:21:49.000Z","updated":"2020-03-04T14:22:59.262Z","comments":true,"path":"2020/03/04/算法笔记Codeup题解/","link":"","permalink":"https://nymrli.top/2020/03/04/算法笔记Codeup题解/","excerpt":"","text":"100000612 - 《算法笔记》9.3小节——数据结构专题(2)-&gt;树的遍历 问题 A: 树查找 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e3 + 5;int arr[MAXN];typedef long long ll;ll fast_pow(int d, int base)&#123; int n = d; ll res = 1; while(n&gt;0)&#123; if( n &amp; 1) res = res*base; base = base * base; n &gt;&gt;= 1; &#125; return res;&#125;int main(int argc, char const *argv[])&#123; int n, d; while(cin &gt;&gt;n &amp;&amp; n)&#123; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; arr[i]; cin &gt;&gt;d; if ( n &lt; fast_pow(d, 2) )&#123; // d层没有节点 cout &lt;&lt; \"EMPTY\"&lt;&lt;endl; &#125;else&#123; int beginn = fast_pow(d-1, 2); int endn = fast_pow(d, 2); cout &lt;&lt; beginn; for (int i = beginn+ 1; i &lt; n &amp;&amp; i&lt; endn; ++i) cout&lt;&lt; \" \" &lt;&lt; i ; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 问题 B: 树的高度 题目要求我们练习树的静态写法。但其实这道题直接计算每个节点的高度就行了。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e3 + 5;int n;struct Node&#123; int height; std::vector&lt;int&gt; child;&#125;Nodearr[MAXN];int getHeight()&#123; int m = -1; for (int i = 1; i &lt;= n; ++i)&#123; if(Nodearr[i].height &gt; m) m = Nodearr[i].height; &#125; return m;&#125;int main(int argc, char const *argv[])&#123; scanf(\"%d\", &amp;n); int a, b; Nodearr[1].height = 1; while(scanf(\"%d %d\",&amp;a,&amp;b)!=EOF)&#123; // Nodearr[a].child.push_back(b); Nodearr[b].height = Nodearr[a].height +1; &#125; cout &lt;&lt; getHeight() &lt;&lt; endl; return 0;&#125; 正规写法：先构建树， 然后再层次遍历计算高度 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int m=10010;struct node&#123; int layer; vector&lt;int&gt; child;&#125;tree[m];int MaxHigh;// 树的静态写法的层次遍历void BFS(int root)&#123; MaxHigh=0; queue&lt;int&gt; q; tree[root].layer =1; q.push(root); if(tree[root].layer&gt;MaxHigh) MaxHigh=tree[root].layer; while(!q.empty())&#123; int front=q.front() ; q.pop(); for(int i=0;i&lt;tree[front].child.size();i++)&#123; int child=tree[front].child[i]; tree[child].layer =tree[front].layer +1; q.push(child); if(tree[child].layer&gt;MaxHigh) MaxHigh=tree[child].layer; &#125; &#125;&#125;int main()&#123; int n,a,b; while(scanf(\"%d\",&amp;n)!=EOF)&#123; while(scanf(\"%d %d\",&amp;a,&amp;b)!=EOF)&#123; tree[a].child.push_back(b); &#125; BFS(1); printf(\"%d\\n\",MaxHigh); &#125; return 0;&#125; 100000613 - 《算法笔记》9.4小节——数据结构专题(2)-&gt;二叉查找树（BST） 问题 A: 二叉排序树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e3 + 5;int n;int data[MAXN];struct Node&#123; int v; Node *lc, *rc;&#125;;Node* newNode(int x)&#123; Node *now = new Node; now-&gt;v = x; now-&gt;lc = now-&gt;rc = NULL; return now;&#125;void insert(Node* &amp;root, int x)&#123; if(root == NULL)&#123; root = newNode(x); &#125; if(root-&gt;v == x) return; // 已存在 else if (x &lt; root-&gt;v ) insert(root-&gt;lc, x); else if (x &gt; root-&gt;v ) insert(root-&gt;rc, x);&#125;Node *createTree()&#123; Node *root = NULL; // ▲注意此处是NULL， 而不是new Node for (int i = 0; i &lt; n; ++i) insert(root, data[i]); return root;&#125;void preOrder(Node *root)&#123; if(root == NULL ) return; cout &lt;&lt; root-&gt;v &lt;&lt; \" \"; preOrder(root-&gt;lc); preOrder(root-&gt;rc);&#125;void inOrder(Node *root)&#123; if(root == NULL ) return; inOrder(root-&gt;lc); cout &lt;&lt; root-&gt;v &lt;&lt; \" \"; inOrder(root-&gt;rc);&#125;void postOrder(Node *root)&#123; if(root == NULL ) return; postOrder(root-&gt;lc); postOrder(root-&gt;rc); cout &lt;&lt; root-&gt;v &lt;&lt; \" \";&#125;int main(int argc, char const *argv[])&#123; while(cin &gt;&gt; n)&#123; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; data[i]; Node* root = createTree(); preOrder(root); cout &lt;&lt; endl; inOrder(root); cout &lt;&lt; endl; postOrder(root); cout &lt;&lt; endl; &#125; return 0;&#125; 问题 B: 二叉搜索树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e3 + 5;int n;int data[MAXN];struct Node&#123; char v; Node *lc, *rc;&#125;;Node* newNode(char x)&#123; Node *now = new Node; now-&gt;v = x; now-&gt;lc = now-&gt;rc = NULL; return now;&#125;void insert(Node* &amp;root, char x)&#123; if (root == NULL)&#123; root = newNode(x); return ; &#125; if (x == root-&gt;v ) return; else if (x &lt; root-&gt;v ) insert(root-&gt;lc, x); else if (x &gt; root-&gt;v ) insert(root-&gt;rc, x);&#125;Node* createTree(string s)&#123; Node *root = NULL; for (int i = 0; i &lt; s.size(); ++i)&#123; insert(root, s[i]); &#125; return root;&#125;void preOrder(Node *root, string &amp;s)&#123; if(root == NULL ) return; s += root-&gt;v; preOrder(root-&gt;lc, s); preOrder(root-&gt;rc, s);&#125;void inOrder(Node *root, string &amp;s)&#123; if(root == NULL ) return; inOrder(root-&gt;lc, s); s += root-&gt;v; inOrder(root-&gt;rc, s);&#125;void postOrder(Node *root, string &amp;s)&#123; if(root == NULL ) return; postOrder(root-&gt;lc, s); postOrder(root-&gt;rc, s); s += root-&gt;v;&#125;int main(int argc, char const *argv[])&#123; int n; while( cin &gt;&gt; n &amp;&amp; n)&#123; string target; cin &gt;&gt; target; string preans, postans; Node *ans = createTree(target); preOrder(ans, preans); postOrder(ans, postans); // inOrder(root, in); // 由于中序遍历的结果就是排序的结果, 因此都一样 for (int i = 0; i &lt; n; ++i)&#123; string s; cin &gt;&gt; s; string in, pre, post; Node *root = createTree(s); preOrder(root, pre); if (pre == preans)&#123; postOrder(root, post); if (post == postans) cout &lt;&lt; \"YES\" &lt;&lt;endl; else cout &lt;&lt; \"NO\" &lt;&lt;endl; &#125;else cout &lt;&lt; \"NO\" &lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"}]},{"title":"PAT冲冲冲——乙级","slug":"PAT冲冲冲——乙级","date":"2020-02-02T08:26:41.000Z","updated":"2020-09-05T04:45:09.548Z","comments":true,"path":"2020/02/02/PAT冲冲冲——乙级/","link":"","permalink":"https://nymrli.top/2020/02/02/PAT冲冲冲——乙级/","excerpt":"","text":"PAT冲冲冲——乙级 PAT甲级练习题 ——PAT (Advanced Level) Practice PAT甲级(Advanced Level)真题 柳婼 の blog经验 saquarius’s blog PAT甲级题目及分类总结 pat甲级题解目录 ▲报名费256，可以刷牛客网的题来获得-50的优惠券，该练习场下的所有题目只要通过都算 乙级练习题 NowCoder数列 没想到第二题就是考了个数据范围，由于0≤n≤1000000，所以F(n)必然比long long大，而判断3的倍数可表示为===&gt; F(n) % 3 —&gt; (F(n-1)%3 + F(n-2)%3) % 3 求余运算性质：a = b+c --&gt; a%d = (b%d+c%d) % d 12345678910111213141516171819#include&lt;stdio.h&gt;long long f[1000000+5];int main()&#123; int n,i; f[0]=7; f[1]=11; for(i=2;i&lt;=1000000;i++)&#123; f[i]=(f[i-1]%3+f[i-2]%3)%3; &#125; while(scanf(\"%d\",&amp;n)!=EOF)&#123; if(f[n]!=0) printf(\"No\\n\"); else printf(\"Yes\\n\"); &#125; return 0;&#125; 养兔子 非常经典的斐波那契数列题 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 90+5ll arr[N]; int main()&#123; int n; arr[1] = 1; arr[2] = 2; for(int i = 3;i&lt;=N;i++)&#123; arr[i] = arr[i-1] + arr[i-2]; &#125; while( cin &gt;&gt; n)&#123; cout &lt;&lt; arr[n] &lt;&lt;endl; &#125; return 0;&#125; 客似云来 斐波那契数列的拓展题，将其中某个区间的值累加输出（需要特判是否为某个点） 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 80+5ll arr[N]; int main()&#123; int from, to; arr[1] = 1; arr[2] = 1; for(int i = 3;i&lt;=N;i++)&#123; arr[i] = arr[i-1] + arr[i-2]; &#125; while( cin &gt;&gt; from &gt;&gt; to)&#123; ll tmp = 0 ; // 注意需要特判是否相等 if (from == to) tmp = arr[from]; else&#123; for(int i=from; i&lt;= to;i++)&#123; tmp += arr[i] ; &#125; &#125; cout &lt;&lt; tmp &lt;&lt;endl; &#125; return 0;&#125; 斐波那契凤尾 一遍还挺难过的，有不少的坑点 1.虽然也是斐波那契数列，但是一定要注意前两项的取值 2.输出末尾的6位，那么就是%1e6，但是如果有前置0，需要补零，我是使用iomanip中的setw和setfill实现的 3.怎么判断超过6位：找出超过6位的n应该算比较简单的方法了吧 123456789101112131415161718192021222324252627282930313233#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100000 + 5ll arr[N]; int main()&#123; int n; arr[1] = 1; arr[2] = 2; for(int i = 3;i&lt;=N;i++)&#123; /* 用来找到超过1e6的n arr[i] = (arr[i-1] + arr[i-2]); if (arr[i] &gt; 1000000)&#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; */ arr[i] = (arr[i-1]%1000000 + arr[i-2]%1000000)%1000000; &#125; while( cin &gt;&gt; n)&#123; if (n&gt;= 30)&#123; cout &lt;&lt; setw(6)&lt;&lt;setfill('0') &lt;&lt; arr[n] &lt;&lt;endl; &#125;else&#123; cout &lt;&lt; arr[n] &lt;&lt; endl; &#125; &#125; return 0;&#125; Po个C的代码，使用printf的格式化输出的特性 123456789101112131415161718#include&lt;stdio.h&gt; int a[100005];int main()&#123; int n; a[1]=1; a[2]=2; for(int i=3;i&lt;=100000;i++) a[i]=(a[i-1]+a[i-2])%1000000; while(scanf(\"%d\",&amp;n)!=EOF) &#123; if(n&gt;=30) printf(\"%06d\\n\",a[n]); else printf(\"%d\\n\",a[n]); &#125; return 0; &#125; 星际密码 说实话，一开始没看懂题，因为输入的n跟题目里提到的n不是同一个东西：矩阵X为[[1 1],[0 1]]，题目中的n是指多少次幂；而输入里的n是指有多少个密码，真正的n其实是第二行的输入Xi 那么分析下思路，Xi=1时1，Xi=2时2，Xi=3时==3 123456789101112131415161718192021222324252627282930#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100000 + 5ll arr[N]; void initFib()&#123; arr[1] = 1; arr[2] = 2; for(int i = 3;i&lt;=N;i++)&#123; arr[i] = (arr[i-1]%10000 + arr[i-2]%10000)%10000; &#125;&#125;int main()&#123; int n; int input[100+5]; initFib(); while( cin &gt;&gt; n)&#123; for (int i = 0; i &lt; n; ++i)&#123; int tmp; cin &gt;&gt; tmp; cout &lt;&lt; setw(4)&lt;&lt;setfill('0') &lt;&lt; arr[tmp] ; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 母牛的故事 变形的Fib，公式更新为f(n)=f(n−1)+f(n−3)f(n) = f(n-1) + f(n-3)f(n)=f(n−1)+f(n−3) 最主要的就是确定前几项，比较好的是样例都给出了2==&gt;2,4==&gt;4,5==&gt;6，这样就比较好确定每头小母牛从第四个年头开始，每年年初也生一头小母牛到底是什么意思了 1234567891011121314151617181920212223#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100000 + 5ll arr[N]; void initFib()&#123; arr[1] = 1; arr[2] = 2;arr[3]=3;arr[4]=4; for(int i = 5;i&lt;=N;i++)&#123; arr[i] = arr[i-1] + arr[i-3]; &#125;&#125;int main()&#123; int n; initFib(); while( cin &gt;&gt; n)&#123; cout &lt;&lt; arr[n]&lt;&lt;endl; &#125; return 0;&#125; 童年生活二三事 Fib数列的板子题，只不过需要理解一下 123456789101112131415161718192021222324#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 90 + 5ll arr[N]; void initFib()&#123; arr[1] = 1; arr[2] = 2; for(int i = 3;i&lt;=N;i++)&#123; arr[i] = arr[i-1] + arr[i-2]; &#125;&#125;int main()&#123; int n; initFib(); while( cin &gt;&gt; n)&#123; cout &lt;&lt; arr[n] &lt;&lt; endl; &#125; return 0;&#125; 蜜蜂寻路 如果固定起点为1，计算到某个位置的走法数的话，跟走阶梯其实是一种思路，就是f(n) = f(n-1) + f(n-2)，即第n个位置的走法数=第n-1位置走法数 + 第n-2位置走法数 1-&gt;2 1 2-&gt;3 1 3-&gt;4 1 1-&gt;3 2 2-&gt;4 2 3-&gt;5 2 1-&gt;4 3 2-&gt;5 3 3-&gt;6 3 1-&gt;5 5 2-&gt;6 5 3-&gt;7 5 1-&gt;6 8 2-&gt;7 8 3-&gt;8 8 可以发现其中的规律：走法数一直是Fib数列，而值为fib(Nto−Nfrom)fib(N_{to} - N_{from})fib(Nto​−Nfrom​) ▲但这题还有一个难点在于用例的范围(0 &lt; a &lt; b &lt; 231)，即b-a~=232-1，为int最大范围，会导致的问题有两个 fib数列通常使用数组来存储，但是无法开个2^32大小的数组 ==&gt;滚动数组、递推（不用数组） 输出的Fib(n)就远远超过long long了，因此要么模拟大数相加，那么另寻他法。 ==&gt;△还需要注意到的一点是,输出数据结果范围是 [0, 2^63)，那么意思是题目要求的输出其实是在long long 范围内的，那么就可以考虑截取输出了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;// ll credit = 9.2e18;开的足够大能过样例就行ll credit;/** * 幂计算 * @author mrli 2019-10-27 * @param n [less than 63] * @return [long long type] */ll pow(int n)&#123; ll ans = 1; for (int i = 0; i &lt; n; ++i) ans *= 2; return ans;&#125;ll Fib(int del)&#123; if (del == 1) return 1; else if(del == 2) return 2; else&#123; ll f1 = 1; ll f2=2; ll ans; for(int i = 3;i&lt;=del;i++)&#123; // ans = f1 + f2 ;也过了 ans = ( f1%(credit) + f2%(credit) )%credit; f1 = f2; f2 = ans; &#125; return ans; &#125;&#125;int main()&#123; int n; credit = pow(63)-1; cin &gt;&gt; n; while( n-- )&#123; int from, to; cin &gt;&gt; from &gt;&gt; to; ll ans; cout &lt;&lt; Fib(to-from) &lt;&lt; endl; &#125; return 0;&#125; 看了别人的题解后,发现想多了。题目的意思是得分点的输出值都在long long 范围内，而不是需要你把输出值压缩在long long范围内，果然去掉 %运算也过了。 123456789101112131415161718192021222324252627282930313233343536373839//蜜蜂寻路#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;using namespace std;#define ms(x, n) memset(x,n,sizeof(x));typedef long long LL;const LL maxn = 2147483648+5; LL dp[3]; //滚动数组int n, a, b;LL solve()&#123; ms(dp, 0); dp[0] = 1, dp[1] = 1; for(int i = 2; i &lt; b-a+1; i++) dp[i%3] = dp[0]+dp[1]+dp[2]-dp[i%3]; //即dp[i]=dp[i-1]+dp][i-2] LL ans = 0; for(int i = 0; i &lt; 3; i++) ans = max(dp[i], ans); return ans;&#125; int main()&#123; cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; solve() &lt;&lt; endl; //从1到4和从2到5答案是一样的 &#125; return 0;&#125; 分数运算 牛客网周赛做到过一次，感觉当时写的比现在的简单。难点在使用GCD进行约分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std; typedef long long ll; /** * 辗转相除法,求最大公约数 * @author mrli 2019-10-28 * @param a [description] * @param b [description] * @return [description] */int gcd(int a, int b)&#123; if (b==0) return a; return gcd(b,a%b);&#125; int main()&#123; int a1,a2,b1,b2; char op3; while( scanf(\"%d/%d %d/%d %c\", &amp;a1, &amp;a2, &amp;b1, &amp;b2, &amp;op3) != EOF)&#123; int fenmu; int fenzi; if (op3 == '+')&#123; fenmu = a2*b2; fenzi = a1*b2+a2*b1; &#125; else if (op3 == '-')&#123; fenmu = a2*b2; fenzi = a1*b2-a2*b1; &#125; else if (op3 == '*')&#123; fenmu = a2*b2; fenzi = a1*b1; &#125; else&#123; //if (op3 == '*')&#123; fenmu = a2*b1; fenzi = a1*b2; &#125; // 找出最大公因子,约分 int common = gcd(fenmu,fenzi); int res_zi = fenzi/common; int res_mu = fenmu/common; if ( res_mu * res_zi &gt; 0) cout &lt;&lt; abs(fenzi/common) &lt;&lt; '/' &lt;&lt; abs(fenmu/common) &lt;&lt; endl; else cout &lt;&lt; '-' &lt;&lt;abs(fenzi/common) &lt;&lt; '/' &lt;&lt; abs(fenmu/common) &lt;&lt; endl; &#125; return 0;&#125; 分解因数 使用小学的短除法，我们很清楚的知道，要想求出它的每一个质因数，我们需要用质数去试除。90能被2整除，那就拿商继续除以2，除不尽就换3，一直到除到质数为止。基础代码框架类似判断质数，只是被判断的数字在过程中不断被除，最终循环结束的时候，那个被处理过的数字，就是最后一个质因数。 12345678910111213141516171819202122#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n; while( cin &gt;&gt; n)&#123; bool first = true; int tmpn = n; cout &lt;&lt; n &lt;&lt; \" = \" ; for (int i = 2; i &lt;= sqrt(n); ++i)&#123; while ( tmpn%i == 0 &amp;&amp; tmpn != i)&#123; tmpn /= i; cout &lt;&lt; i &lt;&lt; \" * \"; &#125; &#125; cout &lt;&lt; tmpn &lt;&lt; endl; &#125; return 0;&#125; 我的第一次做法： 一直TLE，估计这种的话，必须得线性筛，我搜了几个题解的结果也证明除了上述题解，其他的都是线性筛，上面的就比较巧妙 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; bool isPrime( int num )&#123; //两个较小数另外处理 if (num==1) return false; if(num ==2|| num==3 ) return true ; //不在6的倍数两侧的一定不是质数 if(num %6!= 1&amp;&amp;num %6!= 5) return false; //在6的倍数两侧的也可能不是质数 for(int i= 5;i &lt;= sqrt( num); i+=6 ) if(num %i== 0||num %(i+ 2)==0 ) return false ; //排除所有，剩余的是质数 return true;&#125;int main()&#123; int n; while( cin &gt;&gt; n)&#123; bool first = true; cout &lt;&lt; n &lt;&lt; \" = \" ; int tmpn = n; for(int i=2;i&lt;=tmpn;i++)&#123; while ( isPrime(i) &amp;&amp; n%i == 0)&#123; n /= i; if (first) &#123; first = false; cout &lt;&lt; i ; &#125; else cout &lt;&lt; \" * \" &lt;&lt; i ; if (n==0) break; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 因子个数 用到了上题的结论，一个正整数总可以分解成一个或多个素数的积，一开始理解错题目了，以为是所有因数的个数，其实是因数的种数，比如20-&gt;2是因为2，2，5；30-&gt;3是因为2，3，5。 因此这边还是需要素数判别，卡的点也在这，要用线性筛，其实就是上题的回答方式不同罢了 123456789101112131415161718192021222324#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n; while( cin &gt;&gt; n)&#123; int ans=0; int tmp = n; for (int i = 2; i &lt;= n; ++i)&#123; bool first = true; while (tmp%i==0)&#123; tmp/=i; if (first)&#123; first = !first; ans ++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 12345678910111213141516171819202122232425#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n; while( cin &gt;&gt; n)&#123; int ans=0; int tmp = n; for (int i = 2; i &lt;= sqrt(n); ++i)&#123; // bool first = true; if (tmp%i==0)&#123; while (tmp%i==0)&#123; tmp/=i; &#125; ans++; &#125; &#125; if (tmp!=1) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; skew数 模拟题、实现一个幂运算 12345678910111213141516171819202122232425262728293031#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int pow2(int n)&#123; int ans=1; for (int i = 0; i &lt; n; ++i) ans *= 2; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); string s; while( cin &gt;&gt; s )&#123; int size = s.size(); int ans=0; for (int i = 0; i &lt; size; ++i)&#123; /* code */ if (s[i] == '2')&#123; ans += 2*(pow2(size-i)-1); break; &#125; ans += (s[i]-'0')*(pow2(size-i)-1); &#125; cout &lt;&lt; ans &lt;&lt;endl; &#125; return 0;&#125; 一的个数 非常基础的一道题：r进制表示 12345678910111213141516171819#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n, r; while( cin &gt;&gt; n &gt;&gt; r)&#123; int ans=0; while(n)&#123; if (n%r==1) &#123; ans++; &#125; n /= r; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 外星人的语言 r进制的拓展，需要将各位输出出来，由于是逆序的，所以需要一1.个栈来反转一下、或是2.使用string的反转功能 123456789101112131415161718192021222324252627282930313233#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n, r; stack&lt;char&gt; s; while( cin &gt;&gt; n &gt;&gt; r)&#123; int ans=0; while(n)&#123; // 0-9 char c = n%r+48; if (n%r&gt;=10) &#123; // A-F c = n%r-10+65; &#125; n /= r; // 不直接cout，而是存栈 s.push(c); &#125; while(!s.empty())&#123; // 取出栈里的内容 char c = s.top(); s.pop(); cout &lt;&lt; c; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 数位和 代码为一的个数+外星人的语言的结合版。 题目要求，将数n，先表示成r进制的形式，然后再计算r进制下n的位数和，然后再用r进制来表示位数和的结果 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; // ACM比赛中cin,的使用比较耗时,因为默认的时候，cin与stdin总是保持同步的，使用这句可以使cin达到和scanf相差无几的输入效率。 ios::sync_with_stdio(false); int n, r; while( cin &gt;&gt; n &gt;&gt; r)&#123; int ans=0; while(n)&#123; ans += n%r; n /= r; &#125; stack &lt;char&gt; s; while(ans)&#123; // 0-9 char c = ans%r+48; if (ans%r&gt;=10) &#123; // A-F c = ans%r-10+65; &#125; ans /= r; // 不直接cout，而是存栈 s.push(c); &#125; while(!s.empty())&#123; // 取出栈里的内容 char c = s.top(); s.pop(); cout &lt;&lt; c; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 进制回文数 还是r进制的拓展， 1.r需要用个2-16的循环 2.判断字符串的镜像对称s[i] != s[ssize-i-1] 3.踩了个坑,n每次都会被除到很小,因此需要用个临时变量来处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int N; while( cin &gt;&gt; N)&#123; bool yes=false; for (int r = 2; r &lt;= 16; ++r)&#123; string s; int n = N; while(n)&#123; char c = n%r+48; if (n%r&gt;=10) &#123; c = n%r-10+65; &#125; n /= r; s += c; &#125; // 检测出r进制变换时,n已经被除的很小了,因此需要用个临时变量 // cout &lt;&lt; r &lt;&lt; \"进制：\" &lt;&lt; endl; // for (int i = 0; i &lt; s.size(); ++i) // &#123; // cout &lt;&lt; s[i] &lt;&lt; endl; // /* code */ // &#125; bool mirror = true; int ssize = s.size(); for (int i = 0; i &lt;= ssize/2; ++i)&#123; if (s[i] != s[ssize-i-1])&#123; mirror = false; break; &#125; &#125; if (mirror)&#123; yes=true; break; &#125; &#125; if (yes) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125; 发邮件 一道数学题，递推公式为f(n)=(n−1)∗[f(n−1)+f(n−2)]f(n) = (n-1)*[f(n-1)+f(n-2)]f(n)=(n−1)∗[f(n−1)+f(n−2)] 坑点:超出了int，需要用longlong 123456789101112131415161718192021#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll email(int n)&#123; if (n==2) return 1; else if(n==3) return 2; else&#123; return (n-1)*(email(n-1)+email(n-2)); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); int n; while( cin &gt;&gt; n )&#123; cout &lt;&lt; email(n) &lt;&lt; endl; &#125; return 0;&#125; 说反话 (20) 考查了：对行的读取、字符串的切割。 本来还以为考了个string的反转，结果比想象中的更简单一点 123456789101112131415161718192021222324252627282930#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ios::sync_with_stdio(false); string s; while( getline(cin, s) )&#123; stringstream strings; string tmps; strings &lt;&lt; s; while( getline(strings, tmps, ' ') )&#123; ss.push(tmps); &#125; while(!ss.empty())&#123; string couts = ss.top(); ss.pop(); if (!ss.empty()) cout &lt;&lt; couts &lt;&lt;' '; else cout &lt;&lt; couts ; &#125; cout &lt;&lt;endl; &#125; return 0;&#125; 补充——string的反转： 1234567891011121314151617181920212223/*法一:使用string::reverse_iterator迭代器,直接用iterator会报错*/for (string::reverse_iterator it=couts.rbegin(); it != couts.rend() ; ++it) cout &lt;&lt; *it;/*法二:使用algorithm算法中的reverse函数*/// 会修改str中的内容reverse(str.begin(),str.end());/*法三:使用使用string.h中的strrev函数△只能处理char[],不支持string类型*/char s[]=\"hello\";strrev(s);cout&lt;&lt;s&lt;&lt;endl;/*法四:自己编写*/void Reverse(char *s,int n)&#123; for(int i=0,j=n-1;i&lt;j;i++,j--)&#123; char c=s[i]; s[i]=s[j]; s[j]=c; &#125;&#125; 一元多项式求导 (25) 被读取方式卡了会 这边有个坑点: 忽略了常数项的问题 比如 输入 2 0 应该输出 0 0 1234567891011121314151617#include&lt;cstdio&gt; int main()&#123; int exp,coe; bool flag=false; while(scanf(\"%d %d\",&amp;coe,&amp;exp)!=EOF) &#123; if(exp!=0) &#123; if(flag) printf(\" \"); printf(\"%d %d\",coe*exp,exp-1); flag=true; &#125; &#125; if(flag==false) printf(\"0 0\\n\"); return 0;&#125; 别人的处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct poly&#123; int coef; int index;&#125;typedef poly;int main()&#123; ios::sync_with_stdio(false); int coef; int index; std::queue&lt;poly&gt; q; // scanf和getchar合用比较方便,cin再用getchar无效 while(scanf(\"%d%d\", &amp;coef, &amp;index) != EOF)&#123; if (index!=0)&#123; poly *p = new poly(); p-&gt;coef = coef*index; p-&gt;index = index-1 ; q.push(*p); &#125; // 放最后能过,放最初的时候有些过不了 if (getchar()=='\\n') break; &#125; if (q.size()==0) printf(\"0 0\\n\"); else&#123; while(!q.empty())&#123; poly p = q.front(); q.pop(); if (p.coef != 0)&#123; if (q.empty()) printf(\"%d %d\", p.coef, p.index ); else printf(\"%d %d \", p.coef, p.index ); &#125; &#125; &#125; return 0;&#125; 刷完了牛客网PAT乙级练习题的第一、第三页。大多都是些模拟题、简单题，相当于弱一点的蓝桥杯省赛。由于报名考的是甲级，所以就没继续做下去了…","categories":[],"tags":[]},{"title":"sshpass——shell脚本实现SSH连接其他主机并执行终端命令","slug":"sshpass——shell脚本实现SSH连接其他主机并执行终端命令","date":"2019-12-25T09:29:08.000Z","updated":"2019-12-25T10:16:16.390Z","comments":true,"path":"2019/12/25/sshpass——shell脚本实现SSH连接其他主机并执行终端命令/","link":"","permalink":"https://nymrli.top/2019/12/25/sshpass——shell脚本实现SSH连接其他主机并执行终端命令/","excerpt":"","text":"sshpass ssh登陆不能在命令行中指定密码。sshpass的出现，解决了这一问题。即sshpass可以用于非交互SSH的密码验证，一般用在sh脚本中，无须再次输入密码。 sshpass允许用-p参数指定明文密码，然后直接登录远程服务器。(支持密码从命令行、文件、环境变量中读取) 1.安装sudo apt install sshpass 2.使用说明 12345678910111213141516171819# -p 直接指定密码sshpass -p '123456' ssh user_name@host_ip# -f: -f filename #后跟保存密码的文件名，密码是文件内容的第一行。[root@zhu ~]# cat 1.txt123456[root@zhu ~]# sshpass -f 1.txt ssh root@192.168.56.102Last login: Fri Apr 18 13:48:20 2014 from 192.168.56.101[root@jiang ~]# exitlogoutConnection to 192.168.56.102 closed.# -e #将环境变量SSHPASS作为密码[root@zhu ~]# export SSHPASS=123456[root@zhu ~]# sshpass -e ssh root@192.168.56.102Last login: Fri Apr 18 13:51:45 2014 from 192.168.56.101[root@jiang ~]# exitlogoutConnection to 192.168.56.102 closed. shell脚本实现SSH连接其他主机并执行终端命令 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bash# command -v &lt;the_command&gt; 检测命令是否存在返回命令所在路径,等价于which# if [ -x file ] 如果文件存在且可执行if ! [ -x \"$(command -v sshpass)\" ]; then sudo apt-get install sshpassfiport=20005# echo -e 会进行转义echo -e \"\\n请输入用户名！\\n\"# read-将交互输入保存在变量中read name# 获得当前脚本的工作路径dir=$(cd $(dirname $0);pwd)# 分割-&gt;获得文件名file_name=\"$&#123;dir##*/&#125;\"# 传输文件echo -e \"\\n[开始传输文件]\\n\"sshpass -p \"$key\" scp -r -P $port $dir username@IP_address:/data/cluster/$nameif [ $pool -eq 1 ]||[ $pool -eq 2 ]||[ $pool -eq 3 ] then # remotessh为标记符,下面的内容全部重定向到ssh连接的终端中, 一定要保证下面的全是以字符串的形式 # 由于shell会进行预转换,所以shell特殊的量需要额外注意,否则结果将只会是当前主机的。因此需要加\\ # man sshpass中提示:多个-t选项强制分配tty，即使ssh没有本地tty,所以使用-tt参数来强制伪终端分配(表示为这个连接分配TTY)，即使标准输入不是终端，否则退出后会提示`Pseudo-terminal will not be allocated because stdin is not a terminal的错`。 即指明是来自脚本的调用 # 控制终端（/dev/tty）就是当前进程的控制终端的设备特殊文件，可以进行写入写出 sshpass -p \"$key\" ssh -tt -p $(($port+$pool)) username@IP_address &lt;&lt; remotessh Condor_number=\\`condor_q | grep jobs | awk '&#123;print \\$1&#125;'\\` if [ \\$Condor_number -le 1 ] then echo -e \"\\n创建任务失败！\\n\" else echo -e \"\\n创建任务成功！\\n\" fi exitremotesshelse echo -e \"没有该资源池\\n\" exitfi man sshpass中关于-t参数的说明 Force pseudo-terminal allocation. This can be used to execute arbitrary screen-based programs on a remote machine, which can be very useful, e.g. when implementing menu services. Multiple -t options force tty allocation, even if ssh has no local tty. 总结： 所以实现的方法主要是: SSHpass非交互式登录 SSH终端执行多条命令 附录 ssh@host:ssh切换到其他机器上执行多条命令 Shell表达式，${file##*/} 取后缀 shell-if表达式（-f,-d,-s,-r,-w,-x,-eq,-ne,-ge,-gt,-le,-lt ） Linux检测命令是否存在","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://nymrli.top/tags/运维/"},{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"树莓派初始化操作","slug":"树莓派初始化操作","date":"2019-12-12T10:59:06.000Z","updated":"2019-12-12T11:21:49.504Z","comments":true,"path":"2019/12/12/树莓派初始化操作/","link":"","permalink":"https://nymrli.top/2019/12/12/树莓派初始化操作/","excerpt":"","text":"安装系统镜像: 官网下载镜像，解压下载好的Zip文件会得到.img镜像文件。下载win32DiskImage 方式: SSH VNC Xrdp 系统设置: $ sudo raspi-reconfig 1.安装字体 默认安装的是英文字体，如果时区选择中文，将会乱码，因此需要安装中文字体进行汉化。 sudo apt-get install ttf-wqy-zenhei 2.安装中文输入发 3.修改键盘布局 键盘布局默认是英标的，需要将其改成美标 输入sudo dpkg-reconfigure keyboard-configuration后选择通用的104键PC键盘(Generic 104 Key PC),在Layout中选择Ohter,然后在选项中选择English(US)，然后不断选择OK退出即可","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://nymrli.top/tags/嵌入式/"}]},{"title":"ACM-网络流","slug":"ACM-网络流","date":"2019-12-08T11:03:34.000Z","updated":"2019-12-08T11:48:50.230Z","comments":true,"path":"2019/12/08/ACM-网络流/","link":"","permalink":"https://nymrli.top/2019/12/08/ACM-网络流/","excerpt":"","text":"最大流 FF算法 最基本找増广路的算法 dinic实现(基础的FF算法) 反边：我们知道，当我们在寻找增广路的时候，在前面找出的不一定是最优解，如果我们在减去残量网络中正向边的同时将相对应的反向边加上对应的值，我们就相当于可以反悔从这条边流过。 技巧：flow[u]正边，flow[u^1]反边 建边的时候是同时建的，比如1的反边为2，2的反边为1，▲边不能从0开始 主要思路： 求增广路 分层图 dinic的优化 当前弧优化(作用不明显) 12345678910111213141516171819202122232425262728// 最原始int dfs(int now,int fl)&#123; if(now==aim)return fl; int f=e; for(int u=fir[now];u &amp;&amp; fl;u=nxt[u])&#123; if(flow[uj&amp;&amp;deep[to[u]]==deep[now]+1)&#123; int x=dfs(to[u],min(fl,flow[u])); flow[u]-=x;flow[u^1]+=x;fl-=x;f+=x; &#125; &#125; if(lf)deep[now]=-2; return f;&#125;// 当前弧优化int dfs(int now,int fl)&#123; if(now==aim) return fl; int f=0; // 修改为curfir[now] for(int u=curfir[now];u&amp;&amp;fl;u=nxt[u])&#123; curfir=u; // 加了此处 if(flow[u]&amp;&amp;deep[to[u]]==deep[now]+1)&#123; int dfs(to[u],min(fl,flow[u])); flow[u]-=x;flow[u^1]+=x;fl-=x;f+=x; &#125; &#125; if(!f)deep[now]=-2; // 炸点优化 return f;&#125; 多路增广 炸点 最大流最小割定理：最小割总和的权值==最大流的值，对于每张图都是成立的。（网络流的对称形式） 具体代码: 12345678910111213141516171819202122232425262728293031323334353637int maxflow(int s, int t)&#123; // 外层循环 aim = T;int ret = 0; while(bfs(s, t))&#123; ret += dfs(s, 1&lt;&lt;30); &#125; return ret;&#125;bool bfs(int s, int t)&#123; // 建立分层图 memset(deep,0,(tot+2)&lt;&lt;2); deep[S]=1;d1[1]=S;int head=0,tail=1; while(head!=tail)&#123; int v=dl[++head]; for(int u=fir[v];u;u=nxt[u])&#123; if(flow[u]&amp;&amp;!deep[to[u]])&#123; deep[to[u]]=deep[v]+1; d1[++tail]=to[u]; &#125; &#125; &#125; return deep[T];&#125;int dfs(int now,int fl)&#123; // dfs找増广路 if(now==aim) return fl; int f=0; // // 当前弧优化,修改为curfir[now] for(int u=curfir[now];u&amp;&amp;fl;u=nxt[u])&#123; curfir=u; // 加了此处 if(flow[u]&amp;&amp;deep[to[u]]==deep[now]+1)&#123; int dfs(to[u],min(fl,flow[u])); flow[u]-=x;flow[u^1]+=x;fl-=x;f+=x; &#125; &#125; if(!f)deep[now]=-2; // 炸点优化 return f;&#125; EK算法 引入了反相边：在原有的有向图上引入了反向的边，且容量相等 执行过程： BFS找増广路 找到的话，更新最大流、残余网路 找不到则走完了 两者的思想都是：找増广路，找到找不到为止 参考: 最大流（最小割）的EK算法 最小费用最大流","categories":[],"tags":[]},{"title":"ACM-树状数组和线段树","slug":"ACM-树状数组和线段树","date":"2019-12-07T05:04:53.000Z","updated":"2020-09-12T06:48:46.827Z","comments":true,"path":"2019/12/07/ACM-树状数组和线段树/","link":"","permalink":"https://nymrli.top/2019/12/07/ACM-树状数组和线段树/","excerpt":"","text":"高性能问题： Q：需求：（老板给你分了台2GHz单核，内存500M的服务器然后让你写程序）程序每秒会收到一组数据，每组数据包含10万条命令，总共会有100万个仓库，每个仓库库存没有上限且可为负，库存初始为0。你需要在一秒内完成全部的命令，然后将查询结果按顺序得出后传回，命令如下： Add i j，i和j为正整数，表示第i个仓库增加j个库存（j不超过220） Sub i j，i和j为正整数，表示第i个仓库减少个库存（j不超过220） Query i j，i和j为正整数，i&lt;=j，表示询问第i到第个仓库的总库存；End 表示结束，这条命令在每组数据最后出现； 思路一：用array去存储每个仓库的容量，在查询时用循环取出(L,R)的总容量。此时Update为O(1)，Query为O(N) 思路二：前缀数组和：在array1储存每个仓库容量的同时维护array2来记录前n个仓库的总容量，当计算某个区间的容量(L,R)可以通过s[R]-s[L-1]求出。此时Query为O(1)，但Update为O(N) 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3;int arr[maxn];int main()&#123; int n; cin &gt;&gt; n; int tmp; cin &gt;&gt; tmp; arr[1] = tmp; for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; tmp; arr[i] = tmp + arr[i-1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt;endl; &#125; // 可以算出2-4的和 cout &lt;&lt; arr[4] - arr[2-1] &lt;&lt; endl; return 0;&#125; 思路三：树状数组：Update和Query的时间复杂度进行折中后都为O(logN) 树状数组 又叫二叉索引树，最早是为了解决数据压缩里的累积频率问题，现多用来解决数组区间查询问题的数据结构，即高效解决数列的前缀和、区间和问题。 low bit算法 核心：将一个数拆分成若干个二进制数相加，原理：每一个数都有二进制表示，即所有数都可以表示成x个不同的2的幂之和。 做法：找到二进制最后低一位1表示的数。 代码：通过计算n&amp;-n找到n最右边的1。 举个栗子： Q： 6可以怎么计算得到呢？ A： 6==0110，i=110，通过lowbit可以拆分成两个数100+010=110 因此树状数组的维护更新过程如下：已知i=6 ①S+= C[6] ②找到i最右边的1，即得到lowbit=(10)2=(2)10lowbit=(10)_{2}=(2)_{10}lowbit=(10)2​=(2)10​ ③更新i:i′=i−lowbit=(0110)2−(0010)2=(0100)2i&#x27;= i - lowbit = (0110)_{2}-(0010)_{2}=(0100)_{2}i′=i−lowbit=(0110)2​−(0010)2​=(0100)2​，即i′=6−2=(4)10i&#x27;=6-2=(4)_{10}i′=6−2=(4)10​； ④S+= C[4] ⑤再继续找i最右边的1，即得到了lowbit=(100)2=(4)10lowbit=(100)_{2}=(4)_{10}lowbit=(100)2​=(4)10​， ⑥更新i:i′=i−lowbit=(0100)2−(0100)2=(0000)2i&#x27;= i - lowbit =(0100)_{2}-(0100)_{2}=(0000)_{2}i′=i−lowbit=(0100)2​−(0100)2​=(0000)2​， ⑦此时i最右边无1(即全零为0)，算法结束，即最终C[6]=C[4] + C[2] 计算步骤： 找到(n)2(n)_2(n)2​最右边的1的数(n1)2(n1)_2(n1)2​ 更新n′=(n)2−(n1)2n&#x27;=(n)_2 - (n1)_2n′=(n)2​−(n1)2​ 如果(n′)2(n&#x27;)_2(n′)2​还能找到1，那么重复1-2 123456789101112131415161718192021222324252627282930313233343536N = 1e6 + 5arr = [0] * N# 自底向上建树def add(i, j): ''' 修改第i仓库Ci。但注意执行某个仓库的update操作，后面所有仓库都得更新 ''' while i &lt;= N: arr[i] += j # 加上low bit位 i += i&amp;-i def sub(i, j): add(i, -j) def sum(i): ''' 通过Ci求出1-i仓库的总库存 S[6] = C[6] + C[4], 推导如下: 如果i=6,那么 ans += c[6] , i &lt;- i-2 = 6-2 = 4, ans += c[4] , i &lt;- i-4 = 4-4 = 0 ∴ans = c[6] + c[4] = A[6]+A[5]+A[4]+A[3]+A[2]+A[1] ''' ans = 0 while i &gt; 0: ans += arr[i] i -= i&amp;(-i) return ansdef query(i, j); ''' 查询某个区间的总库存，sum(i, j) = S(R) - S(L-1) ''' return sum(j) - sum(i-1) 符号说明： Ai：第i个仓库的库存数 Ci：所构建的数的第i个节点的值，C[i] = A[i-lowbit(i)+1] + …+A[i] Si：第1个仓库到第i个仓库库存数之和 Ans（i，j）：显然就等于SR−SL−1S_{R}-S_{L-1}SR​−SL−1​ 形式 一.从原数组A[],维护树状数组C[] ▲lowbit又叫子叶数，表示了有多少个A[]相加，C[i]表示从C[i] = A[i-lowbit(i)+1] + …+A[i] (&lt;===&gt;C[i] = A[i-2^x+1] + … + A[i])， For Example： i=6 参考： 树状数组——黑板讲解,NICE 树状数组算法——初步了解，有些点讲的并不那么纤细 洛谷: P3374 【模板】树状数组 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define N 500000 + 5using namespace std;int c[N];void add(int i, int k)&#123; int index = i; while (index&lt;=N)&#123; c[index] += k; index += index&amp;(-index); &#125;&#125;int sum(int n)&#123; int index = n; int ans = 0; while (index)&#123; ans += c[index]; index -= index&amp;(-index); &#125; return ans;&#125;int query(int l, int r)&#123; return sum(r) - sum(l-1);&#125; int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i)&#123; int val; cin &gt;&gt; val; add(i, val); &#125; for (int i = 0; i &lt; m; ++i)&#123; int op; int x, k; cin &gt;&gt; op &gt;&gt; x &gt;&gt; k; if (op==1) add(x, k); else cout &lt;&lt; query(x, k) &lt;&lt; endl; &#125; return 0;&#125; 线段树 在求解前缀和、区间和问题上，两者是没有差别的，并且树状数组的空间复杂度更低。但是线段树还有更多的功能，比如求取区间最大值。 完满二叉树(Full Binary Tree) 根据元素的下标进行划分 一个节点代表一个区间的信息 特点： 每个节点维护一个闭区间1,r的信息。 根节点表示[1,n]的信息。如果1=r那就是叶子结点. 如果1&lt;r那就是内部节点,它有两个子节点[1,(1+r)/2]，[(1+r)/2+1,r]. 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 更新/*用1表示根节点。下标为x的点的左子节点下标为2x，右子节点2x+1。用sum[x]表示x代表的区间里所有数的和。对于叶子结点x，它代表[1，r]（1=r），sum[x]=a[1]*/void update(int x)&#123; // 更新某个节点X的值 sum[x]= sum[x*2] + sum[x*2+1];&#125;// 构建, 自顶向下/*对于存储在i号位置的节点，它的左孩子存在2i号位置，右孩子2i+1号位置。同时我们也不需要记录每个位置对应的区间，只要在递归的找这个点的时候边找边修改即可。*/void build(int 1,int r,int x)&#123; if(l==r)&#123; //叶子结点 sum[x]=a[1]; return; &#125; int mid=(1+r)&gt;〉1; build(1,mid,x*2); build(mid+1,r,x*2+1); update(x);//更新信息&#125;// 查询/*假设询问区间是[A,B],现在所在的节点表示的区间为[1,r]- 计算mid=(1+r)/2,左子节点的区间为[1,mid],右子节点的区间为[mid+1,r].如果A&lt;=mid,即询问区间与左子节点有重合,需要递归到左子节点。如果B&gt;=mid+1,即询问区间与右子节点有重合,需要递归到右子节点。递归完之后,需要把两个孩子询问的结果加起来作为返回值。*/int query(int A,int B,int 1,int r,int x)&#123; if(A&lt;=1&amp;&amp;r&lt;=B) return sum[x]; int mid=(1+r)&gt;&gt;1,ans=0; if(A&lt;=mid) ans+=query(A,B,1,mid,x*2); if(mid&lt;B) ans+=query(A,B,mid+1,r,x*2+1); return ans;&#125;// 修改/*由于修改是对单个元素进行修改。比如修改第i个元素。我们先找到[i，i]所在的节点，然后修改它的sum，然后一路向上更新每个祖先的sum即可。*/int change(int pos,int v,int 1,int r,int x)&#123; if( l==r)&#123; //找到了要修改的叶子结点 sum[x]=v; return; &#125; int mid=(1+r)&gt;&gt;1; if(pos&lt;=mid)//pos在左子节点 change(pos,v,1,mid,x*2); else change(pos,v,mid+1,r,x*2+1); update(x);//一定要加！因为这条路上的sum值发生了改变&#125; 性质 节点数：假设线段树处理的数列长度为n，即根节点的区间为[1，n].那么结点数不超过2n个.因此线段树的空间复杂度是0（n）。是完满二叉树(Full Binary Tree)，但一般申请4*n的空间大小 深度：可以看作满二叉树，深度不超过log2(n-1)+1 线段树能把区间上的任意一条长度为L的线段都分成不超过2*log(L)条线段。 注意： 由于链表表示的内存是不连续的，且申请指针比较费时间，所以采用数组矩阵的形式存储。 数组存储也有一点不好，因为线段树并不是真正的完全二叉树。 最后一层可能很空。且空节点的数量可以达到2n个。 因此维护长度为n的序列，用数组存线段树的话，最好要开到4*n的长度，才能保证数组不越界。 形式 例题： Q：对于第i个数，我们要统计前面有多少个数大于a[i]。 对每个数都统计一遍加起来即是答案。 假设我们可以对[0，109]建一个线段树（实际上太大了）每次先查询[a[i]+1，109]的区间和，加入答案。 e.g.如果一个值为1，一个值为108，那么要开108大小 Solve: 10^9范围太大了，因此我们先要对n个数进行离散化。离散化的过程，就是对n个数进行排序，最小的数赋值为1，第二小的赋值为2，以此类推，这样n个数的取值范围就在[1，n]中了。 e.g.上面的情况，将会把1–&gt;1,10^8–&gt;2,那么只要开长度为2的线段树就够了 12345678910// 离散化代码，假设对a[1,2...,n]进行离散化int cnt=0;for(int i=1;i&lt;=n;i ++) // 另外的数组存储 bin[++cnt]=a[i];sort(bin+1,bin+n+1);// 消重cnt=unique(bin+1,bin+cnt+1)-bin-1;for(inti=1;i&lt;=n;i ++) a[i]=lower_bound(bin+1,bin+cnt+1,a[i])-bin; 参考： 高中信息学竞赛线段树与树状数组——万门教育 SWPU-ACM每周算法讲堂-线段树入门（一）","categories":[],"tags":[]},{"title":"KM(Kuhn-Munkres)算法","slug":"KM-Kuhn-Munkres-算法","date":"2019-12-05T13:52:58.000Z","updated":"2019-12-10T14:15:29.634Z","comments":true,"path":"2019/12/05/KM-Kuhn-Munkres-算法/","link":"","permalink":"https://nymrli.top/2019/12/05/KM-Kuhn-Munkres-算法/","excerpt":"","text":"KM(Kuhn-Munkres)算法 带权二分图最佳完美匹配，O(n^3)，（运用匈牙利算法辅助求解），同时也是完备匹配 只适用于带权最大匹配一定是完备匹配的情况，实践中建议用费用流来解决。 完全二分图一定是偶数个点 可行顶标（Feasible Labeling）：结点函数（x），任意边（x，y）：1（x）+l（y）≥w（xiy）。 相等子图：G的生成子图，包含所有点以及满足l（x）+I（y）=w（x，y）的边（x，y） 如果EL有完美匹配为PM，则该M是原图的最大权匹配： PM的权和等于所有点的顶标之和SV。 G的任一个最大权匹配M，边满足w（xy）≤l（x）+（y）→M边权和≤SV=PM边权和 关键就是寻找好的可行顶标，使相等子图有完美匹配。 ==&gt;找到原图的完美匹配–只要–&gt;找到相等子图的完美匹配即可 ▲KM完成之后所有的l(x)之和最小 执行过程 一般对KM算法的描述，基本上可以概括成以下几个步骤： 1.用邻接矩阵（或其他方法也行啦）来储存图。 2.运用贪心算法初始化标杆。 3.运用匈牙利算法找到完备匹配。 4.如果找不到，则通过修改标杆，增加一些边。 5.重复3，4的步骤，直到完全匹配时可结束。 二分图匹配里面我们找最大边进行连边!但是遇到某个点被匹配了两次怎么办？ 那就用匈牙利算法进行更改匹配！ 这就是KM算法的思路了：尽量找最大的边进行连边，如果不能则换一条较大的。 找对象例子理解重点： 女生的每轮选择都是从第一个男生开始往后选择一个男生，使男女两人的期望和要等于两人之间的好感度。 注意：每一轮匹配，每个男生只会被尝试匹配一次！ 如果找对象失败，那么此时参与匹配过的女生期望值都降低d，本轮被选择的男生期望值都增加d：d为任意一个这轮参与过匹配的女生能换到***任意一个这轮没有被选择过的男生所需要降低的最小值*（遍历左边已配对的X，标杆值Lx，与右边这一轮没被选择过的男生Y，标杆值Ly，挑出需要降低的最小值，即 d=min(Lx+Ly-W, d) ） 复杂度 朴素的实现方法，时间复杂度为O(n4)——需要找O(n)次增广路，每次增广最多需要修改O(n)次顶标，每次修改顶标时由于要枚举边来求d值，复杂度为O(n2)。 实际上KM算法的复杂度是可以做到O(n3) 的。我们给每个Y顶点一个“松弛量”函数slack，每次开始找增广路时初始化为无穷大。在寻找增广路的过程中，检查边(i,j)时，如果它不在相等子图中，则让slack[j]变成原值与A[i]+B[j]-w[i,j]的较小值。这样，在修改顶标时，取所有不在交错树中的Y顶点的slack值中的最小值作为d值即可。但还要注意一点：修改顶标后，要把所有的slack值都减去d。（即用在执行匈牙利算法的时候，进行对slack的更新，从而减少一层找到最小d的循环） 举个栗子: 少林决胜(Golden Tiger Claw，UVa11383) 给定一个N*N矩阵，每个格子里都有一个正整数w(i,j)。你的任务是给每行确定一个整数row(i)，每列也确定一个整数col(i)，使得对于任意格子(i, j)，w(i, j)≤row(i)+colj)。所有row(i)和col(i)之和应尽量小。 【分析】 1.行看作二分图X点，列看作二分图Y点。 2.和最佳匹配没有任何关系，KM算法副产品。 3.KM中算法等式l（x）+l（y）≥w（x，y）。行X，列Y。 4.KM过程中，所有顶标不断减小，算法结束后，所有顶标之和是最小的。 蚂蚁（Ants，NEERC2008，LA4043） 给出n个白点和n个黑点的坐标，要求用n条不相交的线段把它们连接起来，其中每条线段恰好连接一个白点和一个黑点，每个点恰好连接到一条线段，如图所示。 【分析】 点有黑白两色，构造二分图，白X黑Y。每个黑点和每个白点相连，权值等于欧氏距离。 连接方案实际上是计算一个完美匹配，匹配中假设al-b1与a2-b2相交，那么dist(a1，b1)+dist(a2，b2)&gt;dist(al，b2)+dist(a2，b1)，这两条线段改成al-b2和a2-b1后总长度会变少。 所以最小匹配中不会出现线段相交。 套KM算法即可计算最小完美匹配即可。 附录 O(n^3)代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;using namespace std;const int MAXN = 305;const int INF = 0x3f3f3f3f;// X为女生节点， Y为男生节点int love[MAXN][MAXN]; // 记录每个妹子和每个男生的好感度int ex_girl[MAXN]; // 每个妹子的期望值int ex_boy[MAXN]; // 每个男生的期望值bool vis_girl[MAXN]; // 记录每一轮匹配匹配过的女生bool vis_boy[MAXN]; // 记录每一轮匹配匹配过的男生int match[MAXN]; // 记录每个男生匹配到的妹子 如果没有则为-1int slack[MAXN]; // 记录每个汉子如果能被妹子倾心最少还需要多少期望值int N;bool dfs(int girl)&#123; vis_girl[girl] = true; for (int boy = 0; boy &lt; N; ++boy) &#123; if (vis_boy[boy]) continue; // 每一轮匹配 每个男生只尝试一次 int gap = ex_girl[girl] + ex_boy[boy] - love[girl][boy]; if (gap == 0) &#123; // 如果符合要求 vis_boy[boy] = true; if (match[boy] == -1 || dfs( match[boy] )) &#123; // 找到一个没有匹配的男生 或者该男生的妹子可以找到其他人 match[boy] = girl; return true; &#125; &#125; else &#123; slack[boy] = min(slack[boy], gap); // slack 可以理解为该男生要得到女生的倾心 还需多少期望值 取最小值 备胎的样子【捂脸 &#125; &#125; return false;&#125;int KM()&#123; // ▲初始化有关被选择的男生的量1-2 [选择他的女生、男生方标杆] memset(match, -1, sizeof match); // 初始每个男生都没有匹配的女生 memset(ex_boy, 0, sizeof ex_boy); // 初始每个男生的期望值为0 // ▲初始化3 [女生方的标杆] // 每个女生的初始期望值是与她相连的男生最大的好感度 for (int i = 0; i &lt; N; ++i) &#123; ex_girl[i] = love[i][0]; for (int j = 1; j &lt; N; ++j) &#123; ex_girl[i] = max(ex_girl[i], love[i][j]); &#125; &#125; // 尝试为每一个女生解决归宿问题 for (int i = 0; i &lt; N; ++i) &#123; // ▲初始化4 [slack-找到最小的d] fill(slack, slack + N, INF); // 因为要取最小值 初始化为无穷大 while (1) &#123; // 为每个女生解决归宿问题的方法是 ：如果找不到就降低期望值，直到找到为止 // 初始化5-6 [该轮中那些女生已经尝试匹配过，该轮中那些男生被选择过] // 记录每轮匹配中男生女生是否被尝试匹配过 memset(vis_girl, false, sizeof vis_girl); memset(vis_boy, false, sizeof vis_boy); if (dfs(i)) break; // 找到归宿 退出 // 如果不能找到 就降低期望值 // 最小可降低的期望值 int d = INF; for (int j = 0; j &lt; N; ++j) if (!vis_boy[j]) d = min(d, slack[j]); for (int j = 0; j &lt; N; ++j) &#123; // 所有访问过的女生降低期望值 if (vis_girl[j]) ex_girl[j] -= d; // 所有访问过的男生增加期望值 if (vis_boy[j]) ex_boy[j] += d; // 没有访问过的boy 因为girl们的期望值降低，距离得到女生倾心又进了一步！ else slack[j] -= d; &#125; &#125; &#125; // 匹配完成 求出所有配对的好感度的和 int res = 0; for (int i = 0; i &lt; N; ++i) res += love[ match[i] ][i]; return res;&#125;int main()&#123; while (~scanf(\"%d\", &amp;N)) &#123; for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; N; ++j) scanf(\"%d\", &amp;love[i][j]); printf(\"%d\\n\", KM()); &#125; return 0;&#125; 裸题:HDU2255 奔小康赚大钱 输入数据包含多组测试用例，每组数据的第一行输入n,表示房子的数量(也是老百姓家的数量)，接下来有n行,每行n个数表示第i个村名对第j间房出的价格(n&lt;=300)。 123456Sample Input2 // 一共有两个房子100 10 // 村民1对第一间出价100, 第二间1015 23 // 村民1对第一间出价15, 第二间23Sample Output123 // 第一间给1,第二间给2 获得其他数据： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int main()&#123; N = 3; srand(time(0)); for (int i = 0; i &lt; N; ++i)&#123; for (int j = 0; j &lt; N; ++j)&#123; int tmp = rand() % 3*N + 1; love[i][j] = tmp; printf(\"%d \", love[i][j] ); &#125; printf(\"\\n\"); &#125; printf(\"%d\\n\", KM()); int sum = 0; for (int i = 0; i &lt; N; ++i)&#123; printf(\"%d-&gt;%d\\n\", match[i], i); sum += love[match[i]][i]; &#125; printf(\"和最大：%d\\n\", sum); for (int i = 0; i &lt; N; ++i)&#123; for (int j = 0; j &lt; N; ++j)&#123; love[i][j] = -love[i][j] ; printf(\"%d \", love[i][j] ); &#125; printf(\"\\n\"); &#125; printf(\"和最小：%d\\n\", -KM()); sum = 0; for (int i = 0; i &lt; N; ++i)&#123; printf(\"%d-&gt;%d\\n\", match[i], i); sum += love[match[i]][i]; &#125; printf(\"%d\\n\", sum); return 0;&#125;/**4 1 7 1 4 7 1 7 4 180-&gt;02-&gt;11-&gt;218-4 -1 -7 -1 -4 -7 -1 -7 -4 61-&gt;00-&gt;12-&gt;2-6*/ 参考资料： 二分图匹配之最佳匹配——KM算法 KM算法详解+模板——男女相亲匹配 带你入门多目标跟踪（三）匈牙利算法&amp;KM算法——以图像目标跟踪距离","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"}]},{"title":"ACM-二分图","slug":"ACM-二分图","date":"2019-12-05T09:45:57.000Z","updated":"2019-12-08T14:21:09.471Z","comments":true,"path":"2019/12/05/ACM-二分图/","link":"","permalink":"https://nymrli.top/2019/12/05/ACM-二分图/","excerpt":"","text":"二分图的判定： 染色法1：假设DFS初始点A涂黑色，与它相邻的点就涂白色。如果搜到某一个点u的相邻点v已经涂色并且与u同色，就不可能是二分图啦~ 染色法2：就是给每个点进行标号，标为-1，1如果存在一条边连接的两个点标号相同，那么就是存在一个奇数环… 热身题： 判断无向图是否有环 用DFS遍历图g，如果访问到已经访问过的顶点，那么有环 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;using namespace std;#define SIZE 100+5/** * 起点编号从0开始 */struct graph&#123; int en; // 边数 int vn; // 顶点数 int map[SIZE][SIZE]; // 邻接矩阵 int vis[SIZE]; // 记录矩阵 bool huan = false; // 是否有环&#125;;/**u: 当前节点节点prev: 记录上一个节点g: 图指针 */void dfs(int u, int prev, graph *g)&#123; // 遍历图 for (int v = 0; v &lt; g-&gt;vn; ++v)&#123; // v为下一个可达的节点 // 自己到自己为0, 是没有边的 if (v == prev) continue; if ( g-&gt;vis[v] != 2 &amp;&amp; g-&gt;map[u][v] )&#123; g-&gt;vis[v] = 1; dfs(v, u, g); &#125;else if(g-&gt;vis[v] == 2 &amp;&amp; g-&gt;map[u][v] )&#123; printf(\"now: %d %d\\n\",u ,v ); g-&gt;huan = true; return ; &#125; &#125;&#125;void showGraph(const graph *g)&#123; printf(\"\\t\"); for (int i = 0; i &lt; g-&gt;vn; ++i)&#123; printf(\"%d \", i); &#125; printf(\"\\n\"); for (int i = 0; i &lt; g-&gt;vn; ++i)&#123; printf(\"v:%d\\t\", i); for (int j = 0; j &lt; g-&gt;vn; ++j)&#123; printf(\"%d \", g-&gt;map[i][j]); &#125; printf(\"\\n\"); &#125;&#125;int main(int argc, char const *argv[])&#123; int n; graph *g = new graph(); scanf(\"%d%d\", &amp;g-&gt;vn, &amp;g-&gt;en); memset(g-&gt;map, 0, sizeof(int)*g-&gt;en*g-&gt;vn); for (int i = 0; i &lt; g-&gt;en; ++i)&#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); g-&gt;map[u][v] = g-&gt;map[v][u] = 1; &#125; showGraph(g); for (int i = 0; i &lt; g-&gt;vn; ++i)&#123; // 如果节点i没被访问过 if (g-&gt;vis[i] == 0 &amp;&amp; g-&gt;huan == false)&#123; g-&gt;vis[i] = 2; dfs(i, -1, g); g-&gt;vis[i] = 1; &#125;else if(g-&gt;huan == true) break; &#125; if (g-&gt;huan) printf(\"有环\\n\"); else printf(\"无环\\n\"); return 0;&#125; 判断一个环是否为奇数环 1356: Catch 题意：给出一个起始点，一些边，有人从这个起始点开始随意走，问在某一个时候，它是否可以处于任意位置。 思路：思考下，就可以明白，只要是一个联通图，并且存在奇数点形成的环，那么在某一个时候就可以处于任意位置。 12 最大匹配数——匈牙利算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 150;int line[maxn][maxn]; // 邻接矩阵,表示男生是否有好感(可达)int used[maxn]; // 在位男生i匹配的那轮中,女生i是否被尝试过匹配int nxt[maxn]; // 如果匹配到了的话,那么男生是谁,女生i的对象为nxt[i]int m, n, t;/** * 为男生x匹配到一个女生i,如果匹配到的女生有主,那么让已配对女生的对象(男)修改匹配对象 * @author mrli 2019-12-08 * @param x 男生 * @return 男生x是否能匹配到女生 */bool Find(int x)&#123; // 遍历所有妹子Y节点 for (int i = 1; i &lt;= m; ++i)&#123; // 如果男生对女生互有好感(即边可达) 且 妹子没有匹配过 if (line[x][i] &amp;&amp; !used[i])&#123; // 在男生该轮,将该女生i标记为已经被尝试匹配过 used[i] = 1; // 如果妹子没有对象 或者 已匹配到的男生是可以转移对象的 if ( nxt[i]==0 || Find( nxt[i]) )&#123; // 将女生的已配对对象改为x nxt[i] = x; return true; &#125; &#125; &#125; return false;&#125;/** * 为所有男生进行匹配 * @author mrli 2019-12-08 * @return 最大匹配数 */int match()&#123; // 最大匹配数 int sum = 0; // 遍历所有男生X节点 for (int i = 1; i &lt;= n; ++i)&#123; // 在男生i该轮,所有女生都没有被修改过匹配 memset(used, 0, sizeof(used)); // 如果当前男生能找到匹配女生,那么最大匹配数++ if (Find(i)) sum++; &#125; return sum;&#125;int main(int argc, char const *argv[])&#123; int u, v; cin &gt;&gt; t; // XY节点数 n = m = 4; memset(line, 0, sizeof(line)); memset(nxt, 0, sizeof(nxt)); while(t--)&#123; cin &gt;&gt; u &gt;&gt; v; line[u][v] = 1; &#125; cout &lt;&lt; match(); return 0;&#125;/**input:71 11 22 22 33 13 24 3output:3 */ 拓展题:无题II HDU2236 二分图：为什么会想到用二分图呢？不同行不同列，仔细想一下，如果某点（x,y），被选中，那么横坐标上x的值不能再选，纵坐标上的y值也不能再选，这相当于二维上有很多值，但是每个值都只能用一次，这就可以想到用二分图匹配求完美匹配了。 二分答案：求n个数的最大最小的差值最小，首先这个差值一定是**0-(maxv-minv)**区间的，然后我们二分差值为外循环，枚举下界为内循环，得到一个区间。做法：修改二分图匹配模板：如果这个二分图的匹配点是在这个区间里的前去匹配，hungry()函数中返回是否为完美匹配，对于每一个二分的差值，只要它能找到一个满足区间条件的完美匹配，就记录一下答案。 Q：首先明白在求什么 A： 首先需要明白：图中每个数值X + 最大差值 &lt;= 最大值 我对上面的理解： 1.最大的差值是个具体的数值δ，最初可以确定的范围在[0, maxv - minv] 之间，因此可以通过二分搜索的方式来找到这个值==&gt;二分搜索 2.那怎么进行二分来缩小这个区间范围呢?Ans：如果符合最大差值的条件(表中所有数都满足 ：数值x+差值 &lt;= 最大值)，即所有点都能完成匹配，那么证明最大差值在这个区间中----&gt;完美匹配==&gt;匈牙利算法 ▲所以算法变成了，不断缩小最大差值可以取值的区间，核心： 判断所有数是否在[p, p+差值]区间内 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 150;const int inf=0x3f3f3f3f;int line[maxn][maxn]; // 邻接矩阵,表示男生是否有好感(可达)int used[maxn]; // 在位男生i匹配的那轮中,女生i是否被尝试过匹配int nxt[maxn]; // 如果匹配到了的话,那么男生是谁,女生i的对象为nxt[i]int m, n, t, maxv, minv;int l, r, mid;int p;/***input:141 1 1 12 2 2 23 3 3 34 4 4 4*/bool Find(int x)&#123; for (int i = 1; i &lt;= m; ++i)&#123; // 修改模板：增加界定二分[p, p+mid]的区间 // 判断边x是否还在[minv, minv+差值]之间 /*if条件解释:执行过程分析 如题,l=0, r=4, 第一次mid=2,p=1, 此时并不是所有点都在[1, 1+2]之间,所以匹配失败 因为1+2&lt;=4(maxv),所以p++后再进入,此时mid=2,p=2,此时仍然不是所有点在这个范围[2,2+2]内,所以失败,第一次二分失败,区间不在[l,mid]即[0,2]之间 第二次更新l=mid+1=2+1=3,mid=(3+4)/2=3 p=1时,判断是否所有点都在[1,1+3]范围,==&gt;结果是的,hungarian返回true,二分确定在[mid, r]即[3,4]之间,更新r=mid-1=3,mid=(l+r)/2=3,此时有l=r=3所以找到了最大差值mid */ if(p &lt;= line[x][i] &amp;&amp; line[x][i]&lt;= p+mid &amp;&amp; !used[i])&#123; used[i] = 1; if ( nxt[i]==0 || Find( nxt[i]) )&#123; nxt[i] = x; return true; &#125; &#125; &#125; return false;&#125;int hungarian()&#123; int sum = 0; // 这边改了，每次都是新情况 memset(nxt, 0, sizeof(nxt)); for (int i = 1; i &lt;= n; ++i)&#123; memset(used, 0, sizeof(used)); if (Find(i)) sum++; &#125; // 修改模板 return sum==n?1:0;&#125;int main(int argc, char const *argv[])&#123; int size; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; size; m = n = size; maxv = -inf; minv = inf; for (int i = 1; i &lt;= size; ++i)&#123; for (int j = 1; j &lt;= size; ++j)&#123; cin &gt;&gt; line[i][j]; maxv = max(maxv, line[i][j]); minv = min(minv, line[i][j]); &#125; &#125; l = 0; r = maxv - minv; int ans = 0; // 二分搜索，不断缩小区间 while( l &lt;= r)&#123; bool flag = false; mid = (l+r) &gt;&gt; 1; // mid为差值 // 遍历下界的搜索,枚举最小值，检查当前差值是否可以匹配成功,条件是“最小值+差值&lt;=最大值” // 核心： 判断所有数是否在[p, p+差值]区间内 for (p = minv; p+mid &lt;= maxv; ++p)&#123; if (hungarian())&#123; // 这句类似二分搜索里的if一旦找到哪个区间，就直接在这个区间里继续二分， flag = true; break; &#125; &#125; // 因为是从[min,min+mid]~[max-mid, max]的搜索,区间大小为mid,如果true,意思是最大差值mid就在[l, mid]之间 if (flag) ans = mid,r = mid-1; // 如果全不符合,那么区间小了,mid得大点,所以mid范围变为[mid, r] else l = mid+1; &#125; // 二分搜索中如果l==r，那么搜索数x的索引就是最后的mid cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 最佳匹配——KM算法 解决有权的完美匹配问题，成为最佳匹配，又称为有权完美匹配。最佳匹配同时也是完备匹配 KM算法详解+模板——含图讲解","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"Hungarian algorithm匈牙利算法","slug":"Hungarian-algorithm匈牙利算法","date":"2019-12-05T05:08:11.000Z","updated":"2019-12-22T13:50:20.336Z","comments":true,"path":"2019/12/05/Hungarian-algorithm匈牙利算法/","link":"","permalink":"https://nymrli.top/2019/12/05/Hungarian-algorithm匈牙利算法/","excerpt":"","text":"Hungarian algorithm匈牙利算法 主要用来解决不带权的分配问题，O(V*E) 首先，需要明白二分图（又名二部图）的概念 二分图Bipartite Graph 二分图是图论中一种特殊模型。设G=(V,E)是一个无向图(当且仅当图中不存在长度为奇数的环。)，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。 注意：如果一图是二分图，那么它一定没有奇环。如果一图没有奇环的话，那么它可以是二分图。(没有奇环是二分图的必要条件) ▲通常被用来解决分配、匹配问题，如资源分配、工作安排、任务调度……任务的核心本质是求配对关系，或者给顶点和边赋权，求某种条件下的最优分配问题。 △匹配问题可以用网络流解决，或者KM算法（KM算法是一种计算机算法，功能是求完备匹配下的最大权匹配），但是增广路算法更加简洁。 二分图的判定： 染色法1：假设DFS初始点A涂黑色，与它相邻的点就涂白色。如果搜到某一个点u的相邻点v已经涂色并且与u同色，就不可能是二分图啦~ 染色法2：就是给每个点进行标号，标为-1，1如果存在一条边连接的两个点标号相同，那么就是存在一个奇数环… 二分图的匹配 匹配：将E的子集M称作一个匹配(子集M中的任意两条边都没有公共端点) 最大匹配：边数最多的匹配称作最大匹配——maximal matching X(Y)完全匹配：如果X（Y）中的所有的顶点都出现在匹配M中，则称M是X(Y)完全匹配——perfect matching M完全匹配：如果M既是X-完全匹配，又是Y-完全匹配，称M是完全匹配。此时∣X∣=∣Y∣|X| = |Y|∣X∣=∣Y∣，也就是说这个匹配里的所有边刚好经过所有点一次。 最大匹配和完全匹配的应用： Q：教师-课程安排，G=&lt;U,E,V&gt;，U为教师集合，V为课程集合，E中的边&lt;u,v&gt;表示某位教师u可以上课程v。需要求最大匹配，使得每门课程有人教，每人都有课上。 A:匈牙利算法 匈牙利算法 执行过程 ①任意取一个匹配M（可以是空集或只有一条边） ②令S是非饱和点（尚未匹配的点）的集合自如果S=0，则M已经是最大匹配 ④从S中取出一个非饱和点山作为起点，从此起点走交错路（交替属于M和非M的边构成的极大无重复点通路或回路）P ③如果P是一个增广路（P的终点也是非饱和点），则令M=MeP=（M-P）U（P-M） ⑥如果P都不是增广路，则从S中去掉uo，转到step3 ▲.顶点数不同，即∣X∣≠∣Y∣|X| \\neq |Y|∣X∣​=∣Y∣的二分图一定没有完全匹配 ▲正则的∣X∣≠∣Y∣|X| \\neq |Y|∣X∣​=∣Y∣的二分图一定有完全匹配(正则:每个顶点的度数都相同) 核心思想：不断挪 増广路定理： 任意一个非最大匹配的匹配一定存在增广路。 从一个未匹配点（未盖点）出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 两个端点都是未盖点→增广路（Augmenting Path，AP） 比如：8→4→7→1→5→2，图中红色是匹配边。 特殊的：3-6也是增广路。 把AP上的匹配边和非匹配边互换，得到的匹配比刚才多一条边。 匹配点只连一条匹配边（？），这样做不会破坏匹配的性质。 增广路定理：即一个匹配是最大匹配等价于不存在增广路。 匈牙利算法的核心原理：就是不断找増广路（依据性质3），直至无法找到新的増广路，即为最大匹配。——使用递归（一直找增广路，不断交换匹配） 增广路可以用来改进匹配，最大匹配可以通过反复找增广路来求解。 已经匹配的点永远不会退出匹配，只会更换匹配 注：（匹配点又叫做盖点，非匹配点叫做未盖点（所谓“盖”指的是被一条边盖住） 实现的细节： 每次选一个未盖点u进行DFS。如果找不到u开头的增广路，则换一个未盖点进行DFS，且以后再也不从u出发找增广路。 12345678910111213141516171819202122232425262728293031struct BPM&#123; //二分图最大基数匹配，邻接矩阵写法 int n，m，G[maxn][maxn];//左右顶点个数，G[x][y]=1，边x-y int left[maxn]; //1eft[i]为右边第i个点的匹配点编号，-1表示不存在 bool T[maxn]; //T[i]为右边第i个点是否已标记 void init(int n，int m)&#123; this-&gt;n=n，this-&gt;m=m;_zero(G);&#125; bool match(int u)&#123; // 递归进行挪 for(intv=e;v&lt;m;v++) if(G[u][v]&amp;&amp;！T[v])&#123; T[v]=true; if(left[v]==-1 || match(left[v]))&#123; //left[v]！=-1，1eft[v]-v是匹配边 left[v]=u; return true; &#125; &#125; return false;&#125; int solve（)&#123; //求最大匹配 memset(left，-1，sizeof(left)); int ans=0; for(int u=e;u&lt;n;u++)&#123;//从左边结点u开始增广 _zero(T); if(match(u)) ans++;//u是未盖点 &#125; return ans; &#125;&#125;; 具体实现代码见文章：《ACM-二分图》 其他相关概念： 最小顶点覆盖： 是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相连 &amp;二分图的最小顶点覆盖数=二分图的最大匹配数 DAG最小不相交路径覆盖 也称为最小边覆盖，是指用尽量少的顶点不相交（只经过一次）的简单路径覆盖二分图中的所有顶点 路径长度可以为0 &amp;二分图的最小路径覆盖数=|V|-二分图的最大匹配数 *最小可相交路径覆盖 最大独立集 最大独立集是指寻找一个点集，使得其中任意两点在图中无对应边。 对于一般图来说，最大独立集是一个NP完全问题，对于二分图来说最大独立集 =|V| - 二分图的最大匹配数 KM(Kuhn-Munkres)算法 带权二分图最佳完美匹配，O(n^3)，（运用匈牙利算法辅助求解） 只适用于带权最大匹配一定是完备匹配的情况，实践中建议用费用流来解决。 完全二分图一定是偶数个点 可行顶标（Feasible Labeling）：结点函数（x），任意边（x，y）：1（x）+l（y）≥w（xiy）。 相等子图：G的生成子图，包含所有点以及满足l（x）+I（y）=w（x，y）的边（x，y） 如果EL有完美匹配为PM，则该M是原图的最大权匹配： PM的权和等于所有点的顶标之和SV。 G的任一个最大权匹配M，边满足w（xy）≤l（x）+（y）→M边权和≤SV=PM边权和 关键就是寻找好的可行顶标，使相等子图有完美匹配。 ==&gt;找到原图的完美匹配–只要–&gt;找到相等子图的完美匹配即可 ▲KM完成之后所有的l(x)之和最小 举个栗子: 少林决胜(Golden Tiger Claw，UVa11383) 给定一个N*N矩阵，每个格子里都有一个正整数w(i,j)。你的任务是给每行确定一个整数row(i)，每列也确定一个整数col(i)，使得对于任意格子(i, j)，w(i, j)≤row(i)+colj)。所有row(i)和col(i)之和应尽量小。 【分析】 1.行看作二分图X点，列看作二分图Y点。 2.和最佳匹配没有任何关系，KM算法副产品。 3.KM中算法等式l（x）+l（y）≥w（x，y）。行X，列Y。 4.KM过程中，所有顶标不断减小，算法结束后，所有顶标之和是最小的。 蚂蚁（Ants，NEERC2008，LA4043） 给出n个白点和n个黑点的坐标，要求用n条不相交的线段把它们连接起来，其中每条线段恰好连接一个白点和一个黑点，每个点恰好连接到一条线段，如图所示。 【分析】 点有黑白两色，构造二分图，白X黑Y。每个黑点和每个白点相连，权值等于欧氏距离。 连接方案实际上是计算一个完美匹配，匹配中假设al-b1与a2-b2相交，那么dist(a1，b1)+dist(a2，b2)&gt;dist(al，b2)+dist(a2，b1)，这两条线段改成al-b2和a2-b1后总长度会变少。 所以最小匹配中不会出现线段相交。 套KM算法即可计算最小完美匹配即可。 参考资料： 离散数学：图论：二分图的匹配——陈斌 北京大学地球与空间科学学院 二分匹配——匈牙利算法和KM算法——里面推荐的文章更值得一看 带你入门多目标跟踪（三）匈牙利算法&amp;KM算法——以图像目标跟踪距离 二分图匹配问题与匈牙利算法——里面包含概念挺全的 二分图大合集——二分图最大匹配（最小覆盖数），完美匹配以及最优匹配（带权最大匹配）——对概念的介绍比上个更准确点，推荐 二分图最大匹配以及常见模型——ACM角度 任务分配问题—匈牙利算法——含Gungary算法执行过程伪代码","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"}]},{"title":"PIL的Image笔记","slug":"PIL的Image笔记","date":"2019-11-26T10:06:58.000Z","updated":"2019-11-26T10:07:16.139Z","comments":true,"path":"2019/11/26/PIL的Image笔记/","link":"","permalink":"https://nymrli.top/2019/11/26/PIL的Image笔记/","excerpt":"","text":"PIL的Image学习 transpose和rotate transpose 1234from PIL import Imageimg = getCaptcha()# 对称反转img.transpose(Image.FLIP_LEFT_RIGHT) rotate 123456from PIL import Imageimg = getCaptcha()# expand默认为False时,超出原有尺寸的部分将用黑色填充,不会拓展尺寸img = img.rotate(45)# expand为True时,会根据图片大小,拓展尺寸img = img.rotate(45,expand=True) Pillow官网介绍 【图像处理】Python-Image 基本的图像处理 convert函数 参数为mode(图像模式)。这是一个字符串，指定图像使用的像素格式。典型值为“1”，“L”，“RGB”或“CMYK”。 1img = img.convert(\"1\") 1 (1-bit pixels, black and white, stored with one pixel per byte) L (8-bit pixels, black and white) P (8-bit pixels, mapped to any other mode using a color palette) RGB (3x8-bit pixels, true color) RGBA (4x8-bit pixels, true color with transparency mask) CMYK (4x8-bit pixels, color separation) YCbCr (3x8-bit pixels, color video format) LAB (3x8-bit pixels, the Lab color space) HSV (3x8-bit pixels, Hue, Saturation, Value color space) I (32-bit signed integer pixels) F (32-bit floating point pixels) PIL image与np.array互转 1. PIL image转换成array img = np.asarray(image)或img=np.array(image) 需要注意的是，如果出现read-only错误，并不是转换的错误，一般是你读取的图片的时候，默认选择的是&quot;r&quot;,&quot;rb&quot;模式有关。 修正的办法: 手动修改图片的读取状态 img.flags.writeable = True # 将数组改为读写模式 2. array转换成image 方法1 12from PIL import ImageImage.fromarray(np.uint8(img)) 方法2 1234import cv2cv2.imwrite(\"output.png\", out)# out可以是uint16类型数据# 16位深度图像转8位灰度 方法3 matlab 123img=imread('output.png')img1=im2uint8(img)imwrite(img1,'result.jpg') Numpy将二维数组添加到空数组 12345678910111213a=np.empty(shape=[0,3], dtype=np.int32)b = np.array([[1,2,3],[4,5,6]])c=[[7,8,9]] print(a.shape)print(b.shape) a = np.append(a, b, axis=0)a = np.append(a, c, axis=0)# 当axis为0时，数组是加在下面（列数要相同）：# 当axis为1时，数组是加在右边（行数要相同）：print(a.shape)print(b.shape) reshape函数是numpy中一个很常用的函数，作用是在不改变矩阵的数值的前提下修改矩阵的形状。 1.简单使用 1234y = np.reshape([[1,2],[3,4]],(1,4))'''array([[1, 2, 3, 4]])''' 2.使用缺省值-1 缺省值-1代表我不知道要给行（或者列）设置为几，reshape函数会根据原矩阵的形状自动调整。 1234567y = np.reshape([[1,2],[3,4]],(4,-1))'''array([[1], [2], [3], [4]])''' 1234567891011121314151617181920212223242526272829import PIL.Image as Imageimport os IMAGES_PATH = 'E:\\picture\\新垣结衣\\\\' # 图片集地址IMAGES_FORMAT = ['.jpg', '.JPG'] # 图片格式IMAGE_SIZE = 256 # 每张小图片的大小IMAGE_ROW = 4 # 图片间隔，也就是合并成一张图后，一共有几行IMAGE_COLUMN = 4 # 图片间隔，也就是合并成一张图后，一共有几列IMAGE_SAVE_PATH = 'E:\\\\picture\\\\新垣结衣\\\\final.jpg' # 图片转换后的地址 # 获取图片集地址下的所有图片名称image_names = [name for name in os.listdir(IMAGES_PATH) for item in IMAGES_FORMAT if os.path.splitext(name)[1] == item] # 简单的对于参数的设定和实际图片集的大小进行数量判断if len(image_names) != IMAGE_ROW * IMAGE_COLUMN: raise ValueError(\"合成图片的参数和要求的数量不能匹配！\") # 定义图像拼接函数def image_compose(): to_image = Image.new('RGB', (IMAGE_COLUMN * IMAGE_SIZE, IMAGE_ROW * IMAGE_SIZE)) #创建一个新图 # 循环遍历，把每张图片按顺序粘贴到对应位置上 for y in range(1, IMAGE_ROW + 1): for x in range(1, IMAGE_COLUMN + 1): from_image = Image.open(IMAGES_PATH + image_names[IMAGE_COLUMN * (y - 1) + x - 1]).resize( (IMAGE_SIZE, IMAGE_SIZE),Image.ANTIALIAS) to_image.paste(from_image, ((x - 1) * IMAGE_SIZE, (y - 1) * IMAGE_SIZE)) return to_image.save(IMAGE_SAVE_PATH) # 保存新图image_compose() #调用函数","categories":[],"tags":[{"name":"编程笔记","slug":"编程笔记","permalink":"https://nymrli.top/tags/编程笔记/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"科学计算","slug":"科学计算","permalink":"https://nymrli.top/tags/科学计算/"}]},{"title":"2019年8月23号运维笔记","slug":"2019年8月23号运维笔记","date":"2019-11-26T07:50:55.000Z","updated":"2019-11-26T07:51:12.893Z","comments":true,"path":"2019/11/26/2019年8月23号运维笔记/","link":"","permalink":"https://nymrli.top/2019/11/26/2019年8月23号运维笔记/","excerpt":"","text":"2019年8月23号运维笔记 docker docker stop containerID，以后再重新启动时报错 1Error response from daemon: driver failed programming external connectivity on endpoint app (3c0c01ac6b42b7a420644fc2b4debfbbcc0e1d2e74e6294155c28aca82f794c4): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 12345 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name. A: 重启docker即可：systemctl restart docker 再开启你的容器： docker run xxxx或docker start xxx 查看docker容器的运行日志 docker logs containerID docker端口映射到宿主机后外网仍无法访问容器的web A： 1234567891011121314# 解决办法：$ sudo vi /etc/sysctl.conf或者$ sudo vi /usr/lib/sysctl.d/00-system.conf# 添加如下代码：net.ipv4.ip_forward=1重启network服务$ sudo systemctl restart network查看是否修改成功$ sudo sysctl net.ipv4.ip_forward#如果返回为“net.ipv4.ip_forward = 1”则表示成功了 nginx 查看nginx安装路径 ps -ef | grep nginx 查看nginx日志 systemctl status nginx.service journalctl -xe 指定运行配置文件 直接运行nginx可执行文件即可启动，nginx会自动读取配置文件目录下的“nginx.conf”配置文件，也可以在后面接“-c”参数来指定配置文件： /usr/sbin/nginx -c /etc/nginx/sites-enabled/nginx.conf 校验配置文件是否正确 由于nginx的配置文件比较复杂容易出错，修改配置后可以用“-t”参数来校验配置文件是否正确： 12nginx -t # 校验默认的配置文件nginx -t -c /path/to/configfile # 校验指定配置文件 了解日志管理 我们查看nginx安装目录下（/var/log/nginx）有个logs，包含了三个文件 “access.log 、error.log、nginx.pid”。 当然，日志配置肯定也是通过nginx.conf配置文件来进行配置的 ，那我先来看配置文件是怎么写的。 access_log logs/access.log main这个是指access.log日志用main格式来显示。 error_log logs/error.log error main格式是什么？mian格式是我们已经定义好了的一种各种，并取个名字便于引用。 默认的main格式中具体用了哪些选项来记录日志呢？ 12345678910111213141516$remote_addr, $http_x_forwarded_for 记录客户端IP地址$remote_user 记录客户端用户名称$request 记录请求的URL和HTTP协议$status 记录请求状态$body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。$bytes_sent 发送给客户端的总字节数。$connection 连接的序列号。$connection_requests 当前通过一个连接获得的请求数量。$msec 日志写入时间。单位为秒，精度是毫秒。$pipe 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。$http_referer 记录从哪个页面链接访问过来的$http_user_agent 记录客户端浏览器相关信息$request_length 请求的长度（包括请求行，请求头和请求正文）。$request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。$time_iso8601 ISO8601标准格式下的本地时间。$time_local 通用日志格式下的本地时间。 nginx.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445//该文件是存放到nginx安装目录下conf文件夹中 //全局区 //代表着当前有一个工作的子进程，可以自行修改，但是太多了无益因为会争夺cpu资源。一般最多设置成cpu数*核数worker_processes 1; //一般配置nginx的连接特性events &#123; //这里是指一个子进程最大允许连接1024个连接 worker_connections 1024;&#125; //这里是配置http服务器的主要段http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; //这里配置的是日志的显示格式 #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; //这里调用指定日志显示的格式 #access_log logs/access.log main; //这里是配置虚拟主机段 server &#123; listen 80;//监听的端口 server_name localhost;//监听访问地址 #charset koi8-r; #access_log logs/host.access.log main; //定位，把特殊的文件或者路径再次定位 location / &#123; root html;//定位的目录，默认是ngxin安装目录下的html文件夹中 index index.html index.htm;//定位的具体文件 &#125; nginx日志分析 分析截止目前为止访问量最高的IP排20名。 awk'{print $1}' /usr/local/nginx/logs/access.log |sort | uniq-c I|sort -nr 分析从早上9点至中午12点总的访问量。 sed-n&quot;/2016:09:00/,/2016:12:00/&quot; paccess_20161121.log 分析上一秒的访问请求数。 sed -n&quot;/2016：09：00：00/&quot; paccess_20161121.log https签名：https://www.jianshu.com/p/0d455c7a9326 Q：nginx和uwsgi区别 nginx的作用： 1.反向代理，可以拦截一些web攻击，保护后端的web服务器 2.负载均衡，根据轮询算法，分配请求到多节点web服务器 3.缓存静态资源，加快访问速度，释放web服务器的内存占用，专项专用 uWSGI的适用： 1.单节点服务器的简易部署 2.轻量级，好部署 Q：已知一个使用nginx配置的web服务器的域名为www.my.com监听80端口,假设在服务器的/var/www/html这个目录下面有静态文件index.html,那么在配置文件其它部分相同的情况下，分别使用下面两种配置： 12345678Location /abc &#123; root /var/www/html; index index.html; &#125;location/abc &#123; alias /var/ww/html/; index index.html;&#125; 访问http://www.my.com/abc分别会有什么结果？ A： root 的为/var/www/html/abc/index.html alias的为/var/www/html/index.html Q：所以使用浏览器访问的话这两种配置会有什么区别？ A：root的为404，alias的为200. 注：如果通过两个路径都能访问到的话，那无论哪个配置都是200","categories":[],"tags":[{"name":"编程笔记","slug":"编程笔记","permalink":"https://nymrli.top/tags/编程笔记/"},{"name":"运维","slug":"运维","permalink":"https://nymrli.top/tags/运维/"}]},{"title":"app测试","slug":"app测试","date":"2019-11-26T07:49:58.000Z","updated":"2019-11-26T07:50:10.506Z","comments":true,"path":"2019/11/26/app测试/","link":"","permalink":"https://nymrli.top/2019/11/26/app测试/","excerpt":"","text":"app测试 命令 adb shell monkey 500随机执行500次 adb shell pm list packages -3 查看第三方包 adb shell monkey -p tv.danmaku.bili指定在某个软件中随机压力测试 adb shell monkey -p tv.danmaku.bili -p com.umaman.laiyifen 500会先执行来伊份 ▲.在测试应用程序某些选项的同时，也会进行系统级功能的测试，如截图、调音量等 adb shell monkey [-options] times 参数说明 1234567-s seed种子值：种子相同时，就能产生一样的伪随机操作序列-p package指定包名：压力测试执行在某个软件内--pct-touch percentage：指定触摸的比例--throttle MILLSEC ：设置每个操作之间的间隔为xx毫秒-v [-v [-v]]：输出日志，v越多越详细--ignore-crashes ：不管程序有无崩溃，都执行完所有操作 各事件比例（Event percentages:） 0: 50.0% -pct-touch 触摸操作 1: 5.8823533% -pct-motion 移动操作 2: 1.1764706% -pct-pinchzoom 缩放操作 3: 8.82353% -pct-traceball 滚动操作 异常 event injected数量不对 crash闪退 ANR没有响应 出现异常后，需要提供给开发的东西 l.被测手机详细信息 2.monkey测试日志 3.手机运行截图 4.monkey运行射手机日志 测试用例 测试用例设计三部曲 要测试什么 -业务 怎么纠样测试 -测试环境搭建 如何判新正确与否 -需求 测试计划 不同的环境下（兼容性） 正常安装 空间不足-&gt;验证松勤安卓APP在HWX空间不足的条件下的安装行为 √正常行为：提示空间不够 x死机 提示错误代码，emor code201 安装过程没电-重新安装 断网-网络Fiddler 常用功能测试点 常用的功能测试方法有“界面测试方法”和“黑盒测试技术”，具体可参见测试组配置库中的相应文档。下面列举了一些常用的功能测试点： 1.页面链接检查每一个链接是否都有对应的页面，并且页面之间切换正确。 2.相关性检查：删除/增加一项会不会对其他项产生影响，如果产生影响，这些影响是否都正确。 3.检查按钮的功能是否正确：如新增、修改、取消、删除、保存等功能是否正确。 4.字符串长度检查：输入超出需求规定的字符串长度的内容，看系统是否检查字符串长度，会不会有提示窗口。 5.字符类型检查：在应该输入指定类型的内容的地方输入其他类型的内容（如在应该输入整型的地方输入其他字符类型），看系统是否检查字符类型，是否会有提示窗口。 6.标点符号检查：输入内容包括各种标点符号，特别是空格，各种引号，回车键，看系统是否会有异常错误。 7.信息重复：在一些需要命名，且名字应该唯一的地方输入重复的名字或ID，看系统怎么处理，是否报错；重名是否区分大小写，以及在输入内容的前后输入空格，系统是否作出正确处理。 8.检查删除功能：在一些可以一次删除多个信息的地方，不选择任何信息，进行删除，看系统如何处理，是否出错；选择一个和多个信息，进行删除，看是否正确处理。 9.检查添加和修改是否一致：检查添加和修改信息的要求是否一致，如添加要求必填的项，修改也应该必填；添加规定为整型的项，修改也必须为整型。 10.检查修改重名：修改时把不能重名的项改为已存在的内容，看系统是否处理，报重名的错。 11.重复提交表单：一条已经成功提交的纪录，退出后再提交，看看系统是否会做什么处理。 12.查询功能：在有查询功能的地方输入系统存在和不存在的内容，结果是否正确；如果可以输入多个查询条件，同时添加合理和不合理的条件，看系统处理是否正确。 13.输入信息位置：注意在光标停留的地方输入信息时，光标和所输入的信息是否跳到别的地方。 14.上传下载文件检查：上传下载文件的功能是否实现，上传文件是否能打开。对上传文件的格式有何规定，系统是否有提示信息。 15.必填项检查：应该填写的项没有填写时系统是否都做了处理，对必填项是否有提示信息，如在必填项放加*。 16.快捷键检查：是否支持常用快捷键，如Ctl+C Ctrl+V Backspace等，对一些不允许输入信息的字段，如选人，选日期是否也有快捷键。 17.回车键检查：在输入结束后直接按回车键，看系统处理如何，会否报错。","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://nymrli.top/tags/测试/"}]},{"title":"2019-9月7号C++编程笔记","slug":"2019-9月7号C-编程笔记","date":"2019-11-26T07:47:55.000Z","updated":"2019-11-26T07:48:23.861Z","comments":true,"path":"2019/11/26/2019-9月7号C-编程笔记/","link":"","permalink":"https://nymrli.top/2019/11/26/2019-9月7号C-编程笔记/","excerpt":"","text":"2019-9月7号C++编程笔记 auto 定义变量时放在变量前，无需知道具体变量类型，系统可自行推断类型，减少编程工作，特别是在模板使用时，使用更方便。 123456789101112131415161718auto a=1;auto b='a';auto s=\"abdc\";auto c;//这样使用时错误的，系统无法自动推断出变量类型//下面为迭代指针使用，很方便vector&lt;int&gt; vec;auto it=vec.begin();/**模板使用案例*/template&lt;typename InputIterator&gt; TreeNode *creatTree(InputIterator in_beg,InputIterator in_end...) &#123; ..... auto inRootPos=find(in_beg,in_end,val); ...... &#125; std::next 123// Defined in header &lt;iterator&gt;template&lt; class ForwardIt &gt;ForwardIt next( ForwardIt it, typename std::iterator_traits&lt;ForwardIt&gt;::difference_type n = 1 ); Parameters: it – 迭代指针 n – 向前进的元素个数，缺省默认为1 Return value The nth successor of iterator it.（返回it的第n个后继迭代指针） 1234for (int i = 0; i &lt; vals.size(); ++i) &#123; // *std::next(vals.cbegin(), i)遍历set的所有值，每次取出一个val // count为计算values中包含val的个数 int count = std::count(values.cbegin(), values.cend(), *std::next(vals.cbegin(), i)); std::prev 123// 使用方法与next相似，不同的是prev返回的是it的第n个前驱迭代指针,即返回指针是begin()和rbegin()区别template&lt; class BidirIt &gt;BidirIt prev( BidirIt it, typename std::iterator_traits&lt;BidirIt&gt;::difference_type n = 1 ); std::advance 方法与prev和next相似，只是无返回指针 12345template&lt;class ForwardIt&gt;ForwardIt next(ForwardIt it, typename std::iterator_traits&lt;ForwardIt&gt;::difference_type n = 1)&#123; std::advance(it, n); return it;&#125; const_cast 去掉const属性：const_cast&lt;int*&gt; (&amp;num)，常用，因为不能把一个const变量直接赋给一个非const变量，必须要转换。 加上const属性：const int* k = const_cast&lt;const int*&gt;(j)，一般很少用，因为可以把一个非const变量直接赋给一个const变量，比如：const int* k = j; 1binary_tree* tmp = const_cast&lt;binary_tree*&gt;(node); C++11对vector成员函数的扩展 emplace_back std::vector::cbegin和std::vector::cend 这两个方法是与std::vector::begin和std::vector::end相对应的，从字面就能看出来，多了一个’c’，顾名思义就是const的意思。同理，std::vector::crbegin和std::vector::crend std::vector::emplace 之前已经对emplace_back进行了讨论，其实还有一个方法叫emplace。 我想说的就是，emplace之于emplace_back就像insert之于push_back。如下使用 12345678910111213141516171819202122&lt;code class=\"hljs cpp\"&gt;#include &lt;iostream&gt;#include &lt;vector&gt; int main ()&#123; std::vector&lt;int&gt; myvector = &#123;10,20,30&#125;; auto it = myvector.emplace ( myvector.begin()+1, 100 ); myvector.emplace ( it, 200 ); myvector.emplace ( myvector.end(), 300 ); std::cout &lt;&lt; \"myvector contains:\"; for (auto&amp; x: myvector) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output:myvector contains: 10 200 100 20 30 300&lt;/int&gt;&lt;/vector&gt;&lt;/iostream&gt;&lt;/code&gt; std::vector::data Returns a direct pointer to the memory array used internally by the vector to store its owned elements. 1234567891011121314151617&lt;code class=\"hljs cpp\"&gt;#include &lt;iostream&gt;#include &lt;vector&gt; int main ()&#123; std::vector&lt;int&gt; myvector (5); int* p = myvector.data(); *p = 10; ++p; *p = 20; p[2] = 100; std::cout &lt;&lt; \"myvector contains:\"; for (unsigned i=0; i&lt;myvector.size(); ++i) std::cout &lt;&lt; myvector[i] &lt;&lt; '\\n'; return 0;&#125; =\"\" output:=\"\" myvector=\"\" contains:=\"\" 10=\"\" 20=\"\" 0=\"\" 100=\"\" 0&lt;/int&gt;&lt;/vector&gt;&lt;/iostream&gt;&lt;/code&gt;","categories":[],"tags":[{"name":"编程笔记","slug":"编程笔记","permalink":"https://nymrli.top/tags/编程笔记/"}]},{"title":"MinMax-极小极大算法——2048","slug":"MinMax-极小极大算法——2048","date":"2019-11-26T07:46:41.000Z","updated":"2020-02-04T03:45:53.681Z","comments":true,"path":"2019/11/26/MinMax-极小极大算法——2048/","link":"","permalink":"https://nymrli.top/2019/11/26/MinMax-极小极大算法——2048/","excerpt":"","text":"MinMax-极小极大算法——2048 算法介绍 MinMax 大家在编程的时候应该或多或少都接触到过这样的写法:min(max(xxx,yyy))，MinMax算法的表达形式就是如此，不过其中的Min和Max都是具有对应含义的。 一般解决博弈类问题的自然想法是将格局组织成一棵），树的每一个节点表示一种格局，而父子关系表示由父格局经过一步可以到达子格局。Minimax也不例外，它通过对以当前格局为根的格局树搜索来确定下一步的选择。而一切格局树搜索算法的核心都是对每个格局价值的评价。Minimax算法基于以下朴素思想确定格局价值： Minimax是一种悲观算法，即假设对手每一步都会将我方引入从当前看理论上价值最小的格局方向，即对手具有完美决策能力。因此我方的策略应该是选择那些对方所能达到的让我方最差情况中最好的，也就是让对方在完美决策下所对我造成的损失最小。 Minimax不找理论最优解，因为理论最优解往往依赖于对手是否足够愚蠢，Minimax中我方完全掌握主动，如果对方每一步决策都是完美的，则我方可以达到预计的最小损失格局，如果对方没有走出完美决策，则我方可能达到比预计的最悲观情况更好的结局。总之我方就是要在最坏情况中选择最好的。 举例For Example： 现在考虑这样一个游戏：有三个盘子A、B和C，每个盘子分别放有三张纸币。A放的是1、20、50；B放的是5、10、100；C放的是1、5、20。单位均为“元”。有甲、乙两人，两人均对三个盘子和上面放置的纸币有可以任意查看。游戏分三步： 甲从三个盘子中选取一个。 乙从甲选取的盘子中拿出两张纸币交给甲。 甲从乙所给的两张纸币中选取一张，拿走。 其中甲的目标是最后拿到的纸币面值尽量大，乙的目标是让甲最后拿到的纸币面值尽量小。 分析过程可看 MinMax和Alpha-beta剪枝分析[转] Alpha-beta剪枝 是在Minmax的基础上通过对每个结点下界alpha和上界beta值的维护进行了剪枝 偶数层为Max层（己方），奇数层为Min层（对手），其中root为当前形势。 执行过程 在root层，α′=max(N1.β,N2.β,...,Ni.β)==(self.β,Ni.β)\\alpha&#x27; = max(N_1.\\beta, N_2.\\beta,...,N_i.\\beta)==(self.\\beta,N_i.\\beta)α′=max(N1​.β,N2​.β,...,Ni​.β)==(self.β,Ni​.β) 在Max层 初始，α′=max(−∞,N.β)\\alpha&#x27;=max(-\\infty, N.\\beta)α′=max(−∞,N.β) 非叶子节点更新(包括根节点), α′=max(α,N1.β,...,Ni.β)\\alpha&#x27;=max(\\alpha,N_1.\\beta,...,N_i.\\beta)α′=max(α,N1​.β,...,Ni​.β) 叶子节点更新, α′=max(self.α,N1.v,...,Ni.v)\\alpha&#x27;=max(self.\\alpha, N_1.v,...,N_i.v)α′=max(self.α,N1​.v,...,Ni​.v) 根节点更新，α′=max(α,N1.β,...,Ni.β)\\alpha&#x27;=max(\\alpha,N_1.\\beta,...,N_i.\\beta)α′=max(α,N1​.β,...,Ni​.β) ▲更新后发现self.α′&gt;self.βself.\\alpha&#x27;&gt;self.\\betaself.α′&gt;self.β则剪枝，不再搜索 在Min层, 初始，β′=min(∞,N.v)\\beta&#x27;=min(\\infty, N.v)β′=min(∞,N.v) 叶子节点更新，β′=min(N1.v,...,Ni.v)\\beta&#x27;=min(N_1.v,...,N_i.v)β′=min(N1​.v,...,Ni​.v) 非叶子节点更新, β′=min(self.β,N1.α,...,Ni.α)\\beta&#x27;=min(self.\\beta,N_1.\\alpha,...,N_i.\\alpha)β′=min(self.β,N1​.α,...,Ni​.α) ▲更新后发现self.β′&lt;self.αself.\\beta&#x27;&lt;self.\\alphaself.β′&lt;self.α则剪枝，不再搜索 △其中N为子节点; self.α表示当前节点已更新的α值 伪代码 1234567891011121314151617function alphabeta(node, depth, α, β, Player) //达到最深搜索深度或胜负已分 if depth = 0 or node is a terminal node return the heuristic value of node if Player = MaxPlayer // 极大节点 for each child of node // 子节点是极小节点 α := max(α, alphabeta(child, depth-1, α, β, not(Player) )) if β ≤ α // 该极大节点的值&gt;=α&gt;=β，该极大节点后面的搜索到的值肯定会大于β，因此不会被其上层的极小节点所选用了。对于根节点，β为正无穷 break //beta剪枝 return α else // 极小节点 for each child of node //子节点是极大节点 β := min(β, alphabeta(child, depth-1, α, β, not(Player) )) // 极小节点 if β ≤ α // 该极大节点的值&lt;=β&lt;=α，该极小节点后面的搜索到的值肯定会小于α，因此不会被其上层的极大节点所选用了。对于根节点，α为负无穷 break //alpha剪枝 return β 2048AI介绍 游戏规则: 2048游戏共有16个格子，初始时初始数字由2或者4构成，之后每次移动生成2的概率为0.9，生成4的概率为0.1，见2048随机生成新数字源码。 1、手指向一个方向滑动，所有格子会向那个方向运动。 2、相同数字的两个格子，相撞时数字会相加。 3、每次滑动时，空白处会随机刷新出一个数字的格子。 4、当界面不可运动时（当界面全部被数字填满时），游戏结束；当界面中最大数字是2048时，游戏胜利。 建模: 之前的对弈类游戏, 博弈双方的地位都是对等的. 但这边只有游戏者一人, 对手在哪里? 让人脑洞大开的是, 2048游戏AI的设计者, 创造性把棋局环境本身做为了博弈的另一方. 当然双方追求的胜利目标不一样: • 我方：游戏者(AI)， 追求2048及2048以上的方块出现 • 对方：计算机(棋局环境)， 填满棋局格子, 使得4个方向皆不能移动 • 胜利条件：出现某个方块的数值为“2048”。 •失败条件：格子全满，且无法向四个方向中任何一个方向移动（均不能触发合并）。 ▲.游戏模型就被建模成了信息完备的双人对弈问题. 而传统博弈树和技巧就自然有了用武之地. 评估函数: 评估函数是算法的核心，如何评价当前格局的价值是重中之重。依据游戏经验, 作者选用了如下评估因素: (1) 单调性: 指方块从左到右、从上到下均遵从递增或递减. (2) 平滑性: 指每个方块与其直接相邻方块数值的差，其中差越小越平滑. (3) 空格数: 局面的空格总数. (4) 最大数: 当前局面的最大数字, 该特征为积极因子. 采用线性函数, 并添加权重系数: 123456789101112131415161718// static evaluation functionAI.prototype.eval = function() &#123; var emptyCells = this.grid.availableCells().length; var smoothWeight = 0.1, //monoWeight = 0.0, //islandWeight = 0.0, mono2Weight = 1.0, emptyWeight = 2.7, maxWeight = 1.0; return this.grid.smoothness() * smoothWeight //+ this.grid.monotonicity() * monoWeight //- this.grid.islands() * islandWeight + this.grid.monotonicity2() * mono2Weight + Math.log(emptyCells) * emptyWeight + this.grid.maxValue() * maxWeight;&#125;; 分析：前3项能衡量一个局面的好坏, 而最大数该项, 则让游戏AI多了一点积极和&quot;冒险&quot; 执行过程 游戏AI的决策过程, 是标准的maxmin search和alpha+beta pruning的实现. 所有的方向(上下左右)都会去尝试. Alpha+beta pruning + worst consideration pruning 然而在游戏本身做决策时, 在Min节点还采用了另一种剪枝，即只考虑对方走出让格局最差的那一步（而实际2048中计算机的选择是随机的），做为搜索分支的剪枝条件，即不是每个空格都去尝试填{2, 4}。 这种假定环境生成了最坏的局面的剪枝做法，可以很好地提高搜索效率，并且获得更强的生存能力。如果全部搜索的话，对方所有可能的选择就为变成了“空格数×2”种，使得搜索效率很低，严重限制搜索深度。而这种选择性地丢掉了很多搜索分支，能够大大地提高搜索效率。 12345678910111213141516171819202122232425// try a 2 and 4 in each cell and measure how annoying it is// with metrics from evalvar candidates = [];var cells = this.grid.availableCells();var scores = &#123; 2: [], 4: [] &#125;;for (var value in scores) &#123; for (var i in cells) &#123; scores[value].push(null); var cell = cells[i]; var tile = new Tile(cell, parseInt(value, 10)); this.grid.insertTile(tile); scores[value][i] = -this.grid.smoothness() + this.grid.islands(); this.grid.removeTile(cell); &#125;&#125; // now just pick out the most annoying movesvar maxScore = Math.max(Math.max.apply(null, scores[2]), Math.max.apply(null, scores[4]));for (var value in scores) &#123; // 2 and 4 for (var i=0; i&lt;scores[value].length; i++) &#123; if (scores[value][i] == maxScore) &#123; candidates.push( &#123; position: cells[i], value: parseInt(value, 10) &#125; ); &#125; &#125;&#125; 分析：对于选择性忽略搜索节点, 其实很有争议. 在某些情况下, 会失去获取最优解的机会. 不过砍掉了很多分支后, 其搜索深度大大加强. 生存能力更强大. 限时的迭代深搜 12345678910111213141516// performs iterative deepening over the alpha-beta searchAI.prototype.iterativeDeep = function() &#123; var start = (new Date()).getTime(); var depth = 0; var best; do &#123; var newBest = this.search(depth, -10000, 10000, 0 ,0); if (newBest.move == -1) &#123; break; &#125; else &#123; best = newBest; &#125; depth++; &#125; while ( (new Date()).getTime() - start &lt; minSearchTime); return best&#125; 该代码没有限制搜索的深度，但是限制了每次“思考”的时间：超时判断在每个深度探索结束后进行, 这未必会精确, 甚至误差很大. 我还是推崇前文谈到过的实现方式.但不管怎样, 作者基本达到了其每100ms决策一步的要求. Python实现核心代码: 12 附录 极大极小算法有些不明白 ? 极小极大算法主要应用于什么样的游戏： 零和游戏（Zero-sum Game） 完全信息（Perfect Information）——Max代表你自己，Min代表你的对手 对弈类游戏的人工智能(5)–2048游戏AI的解读 把环境拟人化的对弈模型, 也是面对反馈类场景的一种很好的评估决策思路. 2048-AI程序算法分析——Java实现 一图流解释 Alpha-Beta 剪枝(Alpha-Beta Pruning) 2048高分技巧 1、最大数尽可能放在角落。 2、数字按顺序紧邻排列。 3、首先满足最大数和次大数在的那一列/行是满的。 4、时刻注意活动较大数（32以上）旁边要有相近的数。 5、以大数所在的一行为主要移动方向 6、不要急于“清理桌面”。 2048随机生成新数字源码 12345678910// Adds a tile in a random positionGrid.prototype.addRandomTile = function () &#123; if (this.cellsAvailable()) &#123; var value = Math.random() &lt; 0.9 ? 2 : 4; //var value = Math.random() &lt; 0.9 ? 256 : 512; var tile = new Tile(this.randomAvailableCell(), value); this.insertTile(tile); &#125;&#125;; ▲需要注意的是，2的几率是0.9，4的几率是0.1，但是除了开局会随机出现1或者2个方块，而在正常游戏中每次移动后只出现一个随机方块。——我当时自己写的是随机1-2个，导致我的分数挺低的。","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"},{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"MinMax和Alpha-beta剪枝分析[转]","slug":"MinMax和Alpha-beta剪枝分析-转","date":"2019-11-26T07:45:45.000Z","updated":"2019-11-26T07:46:23.931Z","comments":true,"path":"2019/11/26/MinMax和Alpha-beta剪枝分析-转/","link":"","permalink":"https://nymrli.top/2019/11/26/MinMax和Alpha-beta剪枝分析-转/","excerpt":"","text":"MinMax和Alpha-beta剪枝分析[转] 一般解决博弈类问题的自然想法是将格局组织成一棵），树的每一个节点表示一种格局，而父子关系表示由父格局经过一步可以到达子格局。Minimax也不例外，它通过对以当前格局为根的格局树搜索来确定下一步的选择。而一切格局树搜索算法的核心都是对每个格局价值的评价。Minimax算法基于以下朴素思想确定格局价值： Minimax是一种悲观算法，即假设对手每一步都会将我方引入从当前看理论上价值最小的格局方向，即对手具有完美决策能力。因此我方的策略应该是选择那些对方所能达到的让我方最差情况中最好的，也就是让对方在完美决策下所对我造成的损失最小。 Minimax不找理论最优解，因为理论最优解往往依赖于对手是否足够愚蠢，Minimax中我方完全掌握主动，如果对方每一步决策都是完美的，则我方可以达到预计的最小损失格局，如果对方没有走出完美决策，则我方可能达到比预计的最悲观情况更好的结局。总之我方就是要在最坏情况中选择最好的。 实际举例: 现在考虑这样一个游戏：有三个盘子A、B和C，每个盘子分别放有三张纸币。A放的是1、20、50；B放的是5、10、100；C放的是1、5、20。单位均为“元”。有甲、乙两人，两人均对三个盘子和上面放置的纸币有可以任意查看。游戏分三步： 甲从三个盘子中选取一个。 乙从甲选取的盘子中拿出两张纸币交给甲。 甲从乙所给的两张纸币中选取一张，拿走。 其中甲的目标是最后拿到的纸币面值尽量大，乙的目标是让甲最后拿到的纸币面值尽量小。 下面用Minimax算法解决这个问题。 解题： 建树 下图是上述示例问题的格局树： 注意，由于示例问题格局数非常少，我们可以给出完整的格局树。这种情况下我可以找到Minimax算法的全局最优解。而真实情况中，格局树非常庞大，即使是计算机也不可能给出完整的树，因此我们往往只搜索一定深度，这时只能找到局部最优解。 我们从甲的角度考虑。其中正方形节点表示轮到我方（甲），而三角形表示轮到对方（乙）。经过三轮对弈后（我方-对方-我方），将进入终局。黄色叶结点表示所有可能的结局。从甲方看，由于最终的收益可以通过纸币的面值评价，我们自然可以用结局中甲方拿到的纸币面值表示终格局的价值。 下面考虑倒数第二层节点，在这些节点上，轮到我方选择，所以我们应该引入可选择的最大价值格局，因此每个节点的价值为其子节点的最大值： 这些轮到我方的节点叫做max节点，max节点的值是其子节点最大值。 倒数第三层轮到对方选择，假设对方会尽力将局势引入让我方价值最小的格局，因此这些节点的价值取决于子节点的最小值。这些轮到对方的节点叫做min节点。 最后，根节点是max节点，因此价值取决于叶子节点的最大值。最终完整赋值的格局树如下： 总结一下Minimax算法的步骤： 首先确定最大搜索深度D，D可能达到终局，也可能是一个中间格局。 在最大深度为D的格局树叶子节点上，使用预定义的价值评价函数对叶子节点价值进行评价。 自底向上为非叶子节点赋值。其中max节点取子节点最大值，min节点取子节点最小值。 每次轮到我方时（此时必处在格局树的某个max节点），选择价值等于此max节点价值的那个子节点路径。 在上面的例子中，根节点的价值为20，表示如果对方每一步都完美决策，则我方按照上述算法可最终拿到20元，这是我方在Minimax算法下最好的决策。格局转换路径如下图红色路径所示： 对于真实问题中的Minimax，再次强调几点： 真实问题一般无法构造出完整的格局树，所以需要确定一个最大深度D，每次最多从当前格局向下计算D层。 因为上述原因，Minimax一般是寻找一个局部最优解而不是全局最优解，搜索深度越大越可能找到更好的解，但计算耗时会呈指数级膨胀。 也是因为无法一次构造出完整的格局树，所以真实问题中Minimax一般是边对弈边计算局部格局树，而不是只计算一次，但已计算的中间结果可以缓存。 Alpha-beta剪枝 简单的Minimax算法有一个很大的问题就是计算复杂性。由于所需搜索的节点数随最大深度呈指数膨胀，而算法的效果往往和深度相关，因此这极大限制了算法的效果。 Alpha-beta剪枝是对Minimax的补充和改进。采用Alpha-beta剪枝后，我们可不必构造和搜索最大深度D内的所有节点，在构造过程中，如果发现当前格局再往下不能找到更好的解，我们就停止在这个格局及以下的搜索，也就是剪枝。 Alpha-beta基于这样一种朴素的思想：时时刻刻记得当前已经知道的最好选择，如果从当前格局搜索下去，不可能找到比已知最优解更好的解，则停止这个格局分支的搜索（剪枝），回溯到父节点继续搜索。 Alpha-beta算法可以看成变种的Minimax，基本方法是从根节点开始采用深度优先的方式构造格局树，在构造每个节点时，都会读取此节点的alpha和beta两个值，其中alpha表示搜索到当前节点时已知的最好选择的下界，而beta表示从这个节点往下搜索最坏结局的上界。由于我们假设对手会将局势引入最坏结局之一，因此当beta小于alpha时，表示从此处开始不论最终结局是哪一个，其上限价值也要低于已知的最优解，也就是说已经不可能此处向下找到更好的解，所以就会剪枝。 下面同样以上述示例介绍Alpha-beta剪枝算法的工作原理。我们从根节点开始，详述使用Alpha-beta的每一个步骤： 根节点的alpha和beta分别被初始化为−∞−∞，和+∞+∞。 深度优先搜索第一个孩子，不是叶子节点，所以alpha和beta继承自父节点，分别为−∞−∞，和+∞+∞ 搜索第三层的第一个孩子，同上。 搜索第四层，到达叶子节点，采用评价函数得到此节点的评价值为1。 此叶节点的父节点为max节点，因此更新其alpha值为1，表示此节点取值的下界为1。 再看另外一个子节点，值为20，大于当前alpha值，因此将alpha值更新为20。 此时第三层最左节点所有子树搜索完毕，作为max节点，更新其真实值为当前alpha值：20。 由于其父节点（第二层最左节点）为min节点，因此更新其父节点beta值为20，表示这个节点取值最多为20。 搜索第二层最左节点的第二个孩子及其子树，按上述逻辑，得到值为50（注意第二层最左节点的beta值要传递给孩子）。由于50大于20，不更新min节点的beta值。 搜索第二层最左节点的第三个孩子。当看完第一个叶子节点后，发现第三个孩子的alpha=beta，此时表示这个节点下不会再有更好解，于是剪枝。 继续搜索B分支，当搜索完B分支的第一个孩子后，发现此时B分支的alpha为20，beta为10。这表示B分支节点的最大取值不会超过10，而我们已经在A分支取到20，此时满足alpha大于等于beta的剪枝条件，因此将B剪枝。并将B分支的节点值设为10，注意，这个10不一定是这个节点的真实值，而只是上线，B节点的真实值可能是5，可能是1，可能是任何小于10的值。但是已经无所谓了，反正我们知道这个分支不会好过A分支，因此可以放弃了。 在C分支搜索时遇到了与B分支相同的情况。因此讲C分支剪枝。 此时搜索全部完毕，而我们也得到了这一步的策略：应该走A分支。 可以看到相比普通Minimax要搜索18个叶子节点相比，这里只搜索了9个。采用Alpha-beta剪枝，可以在相同时间内加大Minimax的搜索深度，因此可以获得更好的效果。并且Alpha-beta的解和普通Minimax的解是一致的。 文章摘自2048-AI程序算法分析","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"},{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"Python网络编程Websocket","slug":"Python网络编程Websocket","date":"2019-11-24T02:17:11.000Z","updated":"2019-11-28T12:00:00.222Z","comments":true,"path":"2019/11/24/Python网络编程Websocket/","link":"","permalink":"https://nymrli.top/2019/11/24/Python网络编程Websocket/","excerpt":"","text":"网络知识——Websocket TCP ：面向连接—&gt; 打电话(相互回复,一来一回)，客户端向服务器端 拨号 , 三次握手 , UDP : 面向无连接 --&gt; 寄快递(寄出去就不管了) e.g.直播 UDP四层结构 网络访问层(链路层): 物理连接设备(网线)、MAC地址（物理地址） 互联网层： IP地址（定位设备） 传输层： port (端口号) : 表示通信进程,将数据交给哪个应用处理 应用层： 自己定义的协议（处理字符串消息的方法） 套接字(socket) ： 特殊的设备文件 ， 写网络应用程序的接口，写入后就是发送，接收就是读取。 类似于 esp8266吧… 基本的socket操作 1234567891011121314import sockets = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) '''参数说明:AF_INET IPv4----STREAM TCPSOCK_DGRAM UDP,无listen、accpet'''server_addr = ('127.0.0.1',8888) # 本地回环地址 , 端口s.bind(server_addr) # 绑定、传入信息data, cilent_addr = s.recvfrom(1024) # BUF_SIZE指定接收数据长度 , (数据内容,客户端地址)s.sendto(data,cilent_addr) # 给客户端发送数据 12345678910import socketbuf = 1024ADDR = (\"127.0.0.1\", 8999)tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)tcpSock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)tcpSock.bind(ADDR)tcpSock.listen(5)conn, addr = tcpSock.accept() 什么是webscoket？ WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。HTML5 WebSocket 设计出来的目的就是要取代轮询和 Comet 技术，使客户端浏览器具备像 C/S 架构下桌面系统的实时通讯能力。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，其本质是保持TCP连接。 客户端 : 发送数据、接收返回数据端 服务端: 处理数据端 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import socket,base64,hashlibdef get_headers(data): '''提取请求头,将请求头转换为字典''' header_dict = &#123;&#125; data = str(data,encoding=\"utf-8\") header,body = data.split(\"\\r\\n\\r\\n\",1) header_list = header.split(\"\\r\\n\") for i in range(0,len(header_list)): if i == 0: if len(header_list[0].split(\" \")) == 3: header_dict['method'],header_dict['url'],header_dict['protocol'] = header_list[0].split(\" \") else: k,v=header_list[i].split(\":\",1) header_dict[k]=v.strip() return header_dictsock = socket.socket()sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)# 指定IP和侦听端口Portsock.bind((\"127.0.0.1\",8888))sock.listen(5)#等待用户连接conn,addr = sock.accept()print(\"conn from \",conn,addr)#获取握手消息，magic string ,sha1加密#发送给客户端#握手消息data = conn.recv(8096)headers = get_headers(data)# 对请求头中的sec-websocket-key进行加密,需要返回的头response_tpl = \"HTTP/1.1 101 Switching Protocols\\r\\n\" \\ \"Upgrade:websocket\\r\\n\" \\ \"Connection: Upgrade\\r\\n\" \\ \"Sec-WebSocket-Accept: %s\\r\\n\" \\ \"WebSocket-Location: ws://%s%s\\r\\n\\r\\n\"# magic_string为一个固定的字符串magic_string = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'# 加密value = headers['Sec-WebSocket-Key'] + magic_stringac = base64.b64encode(hashlib.sha1(value.encode('utf-8')).digest())# 返回的信息response_str = response_tpl % (ac.decode('utf-8'), headers['Host'], headers['url'])# 响应【握手】信息conn.send(bytes(response_str, encoding='utf-8'))#复制代码 客户端 Python 1234567891011121314151617try: import threadexcept ImportError: import _thread as threadimport time# import websocketimport websocket# ws = websocket.WebSocket()ws = websocket.create_connection(\"ws://127.0.0.1:8999/\")# ws.connect(\"ws://127.0.0.1:8999/\")data = &#123;\"body\":&#123;\"address\":\"陕西省\"&#125;&#125;ws.send(json.dumps(data)) #json转化为字符串，必须转化while True: data = ws.recv() print(data) Java Script 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; &lt;script&gt; ws =new WebSocket(\"ws://127.0.0.1:8888\"); ws.onopen = function (ev) &#123; //若是连接成功，onopen函数会执行 console.log(ev) &#125; ws.onmessage = function (ev) &#123; //若是连接成功，onopen函数会执行 console.log(ev) &#125; &lt;/script&gt;&lt;/html&gt; 大端和小端模式 网络通信时 通常使用大端 解析websocket协议 使用、创建demo： 长连接 12345678910111213141516171819202122232425262728293031import websockettry: import threadexcept ImportError: import _thread as threadimport timedef on_message(ws, message): print(message)def on_error(ws, error): print(error)def on_close(ws): print(\"### closed ###\")def on_open(ws): def run(*args): ws.send(\"hello1\") time.sleep(1) ws.close() thread.start_new_thread(run,())if __name__ == \"__main__\": websocket.enableTrace(True) ws = websocket.WebSocketApp(\"ws://echo.websocket.org/\", on_message = on_message, on_error = on_error, on_close = on_close) ws.on_open = on_open ws.run_forever(ping_interval=60,ping_timeout=5) ▲ Python的websocket代码是仿js websocket写法的，重新写了一遍脚本，流畅接受消息，自动重连发送指令，连接时间明显减少，基本做到无遗漏数据，与网站js的ws连接实现一样。 短链接： 12345678910from websocket import create_connectionws = create_connection(\"ws://echo.websocket.org/\")print(\"Sending 'Hello, World'...\")ws.send(json.dumps(&#123;\"op\":\"unconfirmed_sub\"&#125;)) # 不能使用str()，要以json格式输出ws.send(\"Hello, World\")print(\"Sent\")print(\"Receiving...\")result = ws.recv()print(\"Received '%s'\" % result)ws.close() 一步一步分析请求过程！！ 服务端（socket服务端） *1.服务端开启socket服务监听IP和端口 *3.允许连接 *5.服务端接收到特殊值【加密sha1，特殊值，migic string=“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”】 *6.加密后的值发送给客户端 客户端（浏览器） *2.客户端发起连接请求（IP和端口） *4.客户端生成一个xxx，【加密sha1，特殊值，migic string=“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”】，向服务端发送一段特殊值 *7.客户端接收到加密的值 1. 启动服务端 1234567import socketsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8002))sock.listen(5)# 等待用户连接conn, address = sock.accept() 2. 客户端连接 1234&lt;script type=\"text/javascript\"&gt; var socket = new WebSocket(\"ws://127.0.0.1:8002/xxoo\"); ...&lt;/script&gt; 3. 建立连接【握手】 获取请求信息 123456789101112131415161718192021222324import socket sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8002))sock.listen(5)# 获取客户端socket对象conn, address = sock.accept()# 获取客户端的【握手】信息data = conn.recv(1024)b'''GET /chatsocket HTTP/1.1Host: 127.0.0.1:8002Connection: UpgradePragma: no-cacheCache-Control: no-cacheUpgrade: websocketOrigin: http://localhost:63342Sec-WebSocket-Version: 13Sec-WebSocket-Key: mnwFxiOlctXFN/DeMt1Amg==Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits''' 请求和响应的【握手】信息需要遵循规则： 从请求【握手】信息中提取 Sec-WebSocket-Key 利用magic_string 和 Sec-WebSocket-Key 进行hmac1加密，再进行base64加密 将加密结果响应给客户端 注：magic string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11 提取Sec-WebSocket-Key值并加密： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import socketimport base64import hashlib def get_headers(data): \"\"\" 将请求头格式化成字典 :param data: :return: \"\"\" header_dict = &#123;&#125; data = str(data, encoding='utf-8') for i in data.split('\\r\\n'): print(i) header, body = data.split('\\r\\n\\r\\n', 1) header_list = header.split('\\r\\n') for i in range(0, len(header_list)): if i == 0: if len(header_list[i].split(' ')) == 3: header_dict['method'], header_dict['url'], header_dict['protocol'] = header_list[i].split(' ') else: k, v = header_list[i].split(':', 1) header_dict[k] = v.strip() return header_dict sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8002))sock.listen(5) conn, address = sock.accept()data = conn.recv(1024)headers = get_headers(data) # 提取请求头信息# 对请求头中的sec-websocket-key进行加密response_tpl = \"HTTP/1.1 101 Switching Protocols\\r\\n\" \\ \"Upgrade:websocket\\r\\n\" \\ \"Connection: Upgrade\\r\\n\" \\ \"Sec-WebSocket-Accept: %s\\r\\n\" \\ \"WebSocket-Location: ws://%s%s\\r\\n\\r\\n\"magic_string = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'value = headers['Sec-WebSocket-Key'] + magic_stringac = base64.b64encode(hashlib.sha1(value.encode('utf-8')).digest())response_str = response_tpl % (ac.decode('utf-8'), headers['Host'], headers['url'])# 响应【握手】信息conn.send(bytes(response_str, encoding='utf-8')) 只有在服务端又发回&quot;响应&quot;的握手信息后，才算建立了链接。握手的作用是保证通信双方使用的协议相同 4.客户端和服务端收发数据 12345678910111213141516171819数据报内容，第一行为字节，第二行为相应的每一位。0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len | Extended payload length ||I|S|S|S| (4) |A| (7) | (16/64) ||N|V|V|V| |S| | (if payload len==126/127) || |1|2|3| |K| | |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +| Extended payload length continued, if payload len == 127 |+ - - - - - - - - - - - - - - - +-------------------------------+| |Masking-key, if MASK set to 1 |+-------------------------------+-------------------------------+| Masking-key (continued) | Payload Data |+-------------------------------- - - - - - - - - - - - - - - - +: Payload Data continued ... :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +| Payload Data continued ... |+---------------------------------------------------------------+ 官网给出的解析规则 The MASK bit simply tells whether the message is encoded. Messages from the client must be masked, so your server should expect this to be 1. (In fact, section 5.1 of the spec says that your server must disconnect from a client if that client sends an unmasked message.) When sending a frame back to the client, do not mask it and do not set the mask bit. We’ll explain masking later. *Note: You have to mask messages even when using a secure socket.*RSV1-3 can be ignored, they are for extensions. The opcode field defines how to interpret the payload data: 0x0 for continuation, 0x1 for text (which is always encoded in UTF-8), 0x2 for binary, and other so-called “control codes” that will be discussed later. In this version of WebSockets, 0x3 to 0x7 and 0xB to 0xF have no meaning. The FIN bit tells whether this is the last message in a series. If it’s 0, then the server will keep listening for more parts of the message; otherwise, the server should consider the message delivered. More on this later. Decoding Payload Length To read the payload data, you must know when to stop reading. That’s why the payload length is important to know. Unfortunately, this is somewhat complicated. To read it, follow these steps: Read bits 9-15 (inclusive) and interpret that as an unsigned integer. If it’s 125 or less, then that’s the length; you’re done. If it’s 126, go to step 2. If it’s 127, go to step 3. Read the next 16 bits and interpret those as an unsigned integer. You’re done. Read the next 64 bits and interpret those as an unsigned integer (The most significant bit MUST be 0). You’re done. Reading and Unmasking the Data If the MASK bit was set (and it should be, for client-to-server messages), read the next 4 octets (32 bits); this is the masking key. Once the payload length and masking key is decoded, you can go ahead and read that number of bytes from the socket. Let’s call the data ENCODED, and the key MASK. To get DECODED, loop through the octets (bytes a.k.a. characters for text data) of ENCODED and XOR the octet with the (i modulo 4)th octet of MASK. In pseudo-code (that happens to be valid JavaScript): var DECODED = “”; for (var i = 0; i &lt; ENCODED.length; i++) { DECODED[i] = ENCODED[i] ^ MASK[i % 4]; } Now you can figure out what DECODED means depending on your application. 获取客户端发送的数据【解包】 123456789101112131415161718192021222324252627282930313233def analyze_info(info): # 处理数据头 # mask占4个字节，在确定数据头的首部需要占多少字节后，再向后推4个字节 # mask之后的就是数据的真正内容，但需要根据规则进行解析 payload_len = info[1] &amp; 127 if payload_len == 126: # payload_len==126首部信息还要拓展2个字节(16 bits) # 见上文的 Decoding Payload Length-2 extend_payload_len = info[2:4] mask = info[4:8] decoded = info[8:] elif payload_len == 127: # payload_len==127那么需要再拓展8个字节(64 bits) # 见上文的 Decoding Payload Length-3 extend_payload_len = info[2:10] mask = info[10:14] decoded = info[14:] else: extend_payload_len = None mask = info[2:6] decoded = info[6:] ''' var DECODED = \"\"; for (var i = 0; i &lt; ENCODED.length; i++) &#123; DECODED[i] = ENCODED[i] ^ MASK[i % 4]; &#125; ''' bytes_list = bytearray() for i in range(len(decoded)): chunk = decoded[i] ^ mask[i % 4] bytes_list.append(chunk) content = str(bytes_list, encoding='utf-8') return content 向客户端发送数据【封包】 123456789101112131415161718192021def send_msg(conn, msg_bytes): \"\"\" WebSocket服务端向客户端发送消息 :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept() :param msg_bytes: 向客户端发送的字节 :return: \"\"\" import struct token = b\"\\x81\" length = len(msg_bytes) if length &lt; 126: token += struct.pack(\"B\", length) elif length &lt;= 0xFFFF: token += struct.pack(\"!BH\", 126, length) else: token += struct.pack(\"!BQ\", 127, length) msg = token + msg_bytes conn.send(msg) return True 转自武沛齐的你真的了解WebSocket吗？ 完整DEMO： Python服务端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/usr/bin/env python# -*- coding:utf-8 -*-import socketimport base64import hashlibdef get_headers(data): \"\"\" 将请求头格式化成字典 :param data: :return: \"\"\" header_dict = &#123;&#125; data = str(data, encoding='utf-8') header, body = data.split('\\r\\n\\r\\n', 1) header_list = header.split('\\r\\n') for i in range(0, len(header_list)): if i == 0: if len(header_list[i].split(' ')) == 3: header_dict['method'], header_dict['url'], header_dict['protocol'] = header_list[i].split(' ') else: k, v = header_list[i].split(':', 1) header_dict[k] = v.strip() return header_dictdef send_msg(conn, msg_bytes): \"\"\" WebSocket服务端向客户端发送消息 :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept() :param msg_bytes: 向客户端发送的字节 :return: \"\"\" import struct token = b\"\\x81\" length = len(msg_bytes) if length &lt; 126: token += struct.pack(\"B\", length) elif length &lt;= 0xFFFF: token += struct.pack(\"!BH\", 126, length) else: token += struct.pack(\"!BQ\", 127, length) msg = token + msg_bytes conn.send(msg) return Truedef init_socket(): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sock.bind(('127.0.0.1', 8003)) sock.listen(5) conn, address = sock.accept() data = conn.recv(1024) headers = get_headers(data) response_tpl = \"HTTP/1.1 101 Switching Protocols\\r\\n\" \\ \"Upgrade:websocket\\r\\n\" \\ \"Connection:Upgrade\\r\\n\" \\ \"Sec-WebSocket-Accept:%s\\r\\n\" \\ \"WebSocket-Location:ws://%s%s\\r\\n\\r\\n\" value = headers['Sec-WebSocket-Key'] + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11' ac = base64.b64encode(hashlib.sha1(value.encode('utf-8')).digest()) response_str = response_tpl % (ac.decode('utf-8'), headers['Host'], headers['url']) conn.send(bytes(response_str, encoding='utf-8')) return conn, sockdef analyze_info(info): payload_len = info[1] &amp; 127 if payload_len == 126: extend_payload_len = info[2:4] mask = info[4:8] decoded = info[8:] elif payload_len == 127: extend_payload_len = info[2:10] mask = info[10:14] decoded = info[14:] else: extend_payload_len = None mask = info[2:6] decoded = info[6:] bytes_list = bytearray() for i in range(len(decoded)): chunk = decoded[i] ^ mask[i % 4] bytes_list.append(chunk) content = str(bytes_list, encoding='utf-8') return contentdef run(): conn, sock = init_socket() while True: try: info = conn.recv(8096) except Exception as e: info = None if not info: break content = analyze_info(info) send_msg(conn, content.encode('utf-8')) sock.close()if __name__ == '__main__': run() html的客户端代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;input type=\"text\" id=\"txt\"/&gt; &lt;input type=\"button\" id=\"btn\" value=\"提交\" onclick=\"sendMsg();\"/&gt; &lt;input type=\"button\" id=\"close\" value=\"关闭连接\" onclick=\"closeConn();\"/&gt; &lt;/div&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var socket = new WebSocket(\"ws://127.0.0.1:8003/chatsocket\"); socket.onopen = function () &#123; /* 与服务器端连接成功后，自动执行 */ var newTag = document.createElement('div'); newTag.innerHTML = \"【连接成功】\"; document.getElementById('content').appendChild(newTag); &#125;; socket.onmessage = function (event) &#123; /* 服务器端向客户端发送数据时，自动执行 */ var response = event.data; var newTag = document.createElement('div'); newTag.innerHTML = response; document.getElementById('content').appendChild(newTag); &#125;; socket.onclose = function (event) &#123; /* 服务器端主动断开连接时，自动执行 */ var newTag = document.createElement('div'); newTag.innerHTML = \"【关闭连接】\"; document.getElementById('content').appendChild(newTag); &#125;; function sendMsg() &#123; var txt = document.getElementById('txt'); socket.send(txt.value); txt.value = \"\"; &#125; function closeConn() &#123; socket.close(); var newTag = document.createElement('div'); newTag.innerHTML = \"【关闭连接】\"; document.getElementById('content').appendChild(newTag); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; tornado初探 123456ws = websocket.WebSocketApp(\"ws://echo.websocket.org/\", on_message = on_message, on_error = on_error, on_close = on_close)ws.on_open = on_openws.run_forever() 长连接，参数介绍： （1）url: websocket的地址。 （2）header: 客户发送websocket握手请求的请求头，{‘head1:value1’,‘head2:value2’}。 （3）on_open：在建立Websocket握手时调用的可调用对象，这个方法只有一个参数，就是该类本身。 （4）on_message：这个对象在接收到服务器返回的消息时调用。有两个参数，一个是该类本身，一个是我们从服务器获取的字符串（utf-8格式）。 （5）on_error：这个对象在遇到错误时调用，有两个参数，第一个是该类本身，第二个是异常对象。 （6）on_close：在遇到连接关闭的情况时调用，参数只有一个，就是该类本身。 （7）on_cont_message：这个对象在接收到连续帧数据时被调用，有三个参数，分别是：类本身，从服务器接受的字符串（utf-8），连续标志。 （8）on_data：当从服务器接收到消息时被调用，有四个参数，分别是：该类本身，接收到的字符串（utf-8），数据类型，连续标志。 （9）keep_running：一个二进制的标志位，如果为True，这个app的主循环将持续运行，默认值为True。 （10）get_mask_key：用于产生一个掩码。 （11）subprotocols：一组可用的子协议，默认为空。 tornado.hello_world Http 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import tornado.ioloopimport tornado.webclass IndexHandler(RequestHandler): # 正常1，抛错1、5 def set_default_headers(self): print \"调用了set_default_headers()\" # 正常2，抛错2 def initialize(self): print \"调用了initialize()\" # 正常3，抛错3 def prepare(self): print \"调用了prepare()\" # 正常4，抛错4 def get(self): print \"调用了get()\" # 正常4，抛错4 def post(self): print \"调用了post()\" self.send_error(200) # 注意此出抛出了错误 # 正常无、抛错6 def write_error(self, status_code, **kwargs): print \"调用了write_error()\" # 正常5、抛错7 def on_finish(self): print \"调用了on_finish()\" # 定义Http处理类型class MainHandler(tornado.web.RequestHandler): # 处理路由参数 def initialize(self, subject): self.subject = subject # 添加一个处理get请求方式的方法 def get(self): # write方法是写到缓冲区的 self.write(\"Hello, world\") # write会自动检测json类型，进行包装，并设Content-Type设置为application/json; charset=UTF-8。def make_app(): settings = &#123; 'template_path': 'templates', 'static_path': 'static', &#125; return tornado.web.Application([ (r\"/main\", MainHandler, &#123;\"subject\":\"c++\"&#125;), # 指定路由信息,路由参数会传入initialize()中 (r\"/\", IndexHandler), ], debug=True, **settings) # debug=True时，有自动重启、提供追踪信息等功能if __name__ == \"__main__\": app = make_app() # 创建一个应用对象,得返回Application对象 app.listen(8888) # 设置端口 tornado.ioloop.IOLoop.current().start() # 启动web程序，开始监听端口的连接 Websocket 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# ▲继承的类为WebSocketHandlerclass ChatHandler(tornado.websocket.WebSocketHandler): # 用户存储当前聊天室用户 waiters = set() # 用于存储历时消息 messages = [] def open(self): \"\"\" 客户端连接成功时，自动执行 :return: \"\"\" ChatHandler.waiters.add(self) uid = str(uuid.uuid4()) self.write_message(uid) for msg in ChatHandler.messages: content = self.render_string('message.html', **msg) self.write_message(content) def on_message(self, message): \"\"\" 客户端连发送消息时，自动执行 :param message: :return: \"\"\" msg = json.loads(message) ChatHandler.messages.append(message) for client in ChatHandler.waiters: content = client.render_string('message.html', **msg) client.write_message(content) def on_close(self): \"\"\" 客户端关闭连接时，，自动执行 :return: \"\"\" ChatHandler.waiters.remove(self) def run(): settings = &#123; 'template_path': 'templates', 'static_path': 'static', &#125; application = tornado.web.Application([ (r\"/\", IndexHandler), (r\"/chat\", ChatHandler), ], **settings) application.listen(8888) tornado.ioloop.IOLoop.instance().start()if __name__ == \"__main__\": run() 基于Tornado——聊天室 项目结构 12345678│ app.py│├───static│ jquery-2.1.4.min.js│└───templates index.html message.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#!/usr/bin/env python# -*- coding:utf-8 -*-# app.pyimport uuidimport jsonimport tornado.ioloopimport tornado.webimport tornado.websocketclass IndexHandler(tornado.web.RequestHandler): def get(self): self.render('index.html')class ChatHandler(tornado.websocket.WebSocketHandler): # 用户存储当前聊天室用户 waiters = set() # 用于存储历时消息 messages = [] def open(self): \"\"\" 客户端连接成功时，自动执行 :return: \"\"\" ChatHandler.waiters.add(self) uid = str(uuid.uuid4()) self.write_message(uid) for msg in ChatHandler.messages: content = self.render_string('message.html', **msg) self.write_message(content) def on_message(self, message): \"\"\" 客户端连发送消息时，自动执行 :param message: :return: \"\"\" msg = json.loads(message) ChatHandler.messages.append(message) # 向当前在线的每个用户发送最新的消息界面 for client in ChatHandler.waiters: content = client.render_string('message.html', **msg) client.write_message(content) def on_close(self): \"\"\" 客户端关闭连接时，，自动执行 :return: \"\"\" ChatHandler.waiters.remove(self)def run(): settings = &#123; 'template_path': 'templates', 'static_path': 'static', &#125; application = tornado.web.Application([ (r\"/\", IndexHandler), (r\"/chat\", ChatHandler), ], **settings) application.listen(8888) tornado.ioloop.IOLoop.instance().start()if __name__ == \"__main__\": run() index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Python聊天室&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;input type=\"text\" id=\"txt\"/&gt; &lt;input type=\"button\" id=\"btn\" value=\"提交\" onclick=\"sendMsg();\"/&gt; &lt;input type=\"button\" id=\"close\" value=\"关闭连接\" onclick=\"closeConn();\"/&gt; &lt;/div&gt; &lt;div id=\"container\" style=\"border: 1px solid #dddddd;margin: 20px;min-height: 500px;\"&gt; &lt;/div&gt; &lt;script src=\"/static/jquery-2.1.4.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function () &#123; wsUpdater.start(); &#125;); var wsUpdater = &#123; socket: null, uid: null, start: function() &#123; var url = \"ws://127.0.0.1:8888/chat\"; wsUpdater.socket = new WebSocket(url); wsUpdater.socket.onmessage = function(event) &#123; console.log(event); if(wsUpdater.uid)&#123; wsUpdater.showMessage(event.data); &#125;else&#123; wsUpdater.uid = event.data; &#125; &#125; &#125;, showMessage: function(content) &#123; $('#container').append(content); &#125; &#125;; // 按下提交按钮后，客户端向服务端发送信息，服务端再将数据给message.html渲染 function sendMsg() &#123; var msg = &#123; uid: wsUpdater.uid, message: $(\"#txt\").val() &#125;; console.log(JSON.stringify(msg)); wsUpdater.socket.send(JSON.stringify(msg)); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; message.html 1234&lt;div style=\"border: 1px solid #dddddd;margin: 10px;\"&gt; &lt;div&gt;游客&#123;&#123;uid&#125;&#125;&lt;/div&gt; &lt;div style=\"margin-left: 20px;\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/div&gt; ▲ 整个执行流程： 按下提交后调用html.sendMsg–&gt; 数据message–&gt;在后自动调用on_message，会将message传给massage.html渲染，将渲染结果(字符串)返回给用户(write_message)–&gt; 客户端收到消息后自动执行html.on_message会调用html.showMessage，把content即字符串(event.data)用jquery追加显示index.html页面上$('#container').append(content); 附录文献: websocket获取实时数据的几种常见链接方式 python使用websocket的几种方式 Python Web 框架：Tornado初探 ▲Python学习笔记——Tornado深入 完整的websocket使用——聊天室 坑点记录： 1.create_connection导入失败 Q:ImportError: cannot import name 'create_connection' from 'websocket' (unknown location) A:在使用create_connection之前要安装websocket_client ,即 pip install websocket-client 个人的HTML客户端代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;2048客户端&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div align=\"center\"&gt; &lt;input type=\"button\" value=\"↑\" name=\"↑\" onclick=\"up()\" style=\"height:50px; width:50px;\"&gt; &lt;input type=\"button\" value=\"↓\" name=\"↓\" onclick=\"down()\" style=\"height:50px; width:50px;\"&gt; &lt;input type=\"button\" value=\"←\" name=\"←\" onclick=\"left()\" style=\"height:50px; width:50px;\"&gt; &lt;input type=\"button\" value=\"→\" name=\"→\" onclick=\"right()\" style=\"height:50px; width:50px;\"&gt; &lt;/div&gt;&lt;/body&gt; &lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function () &#123; wsUpdater.start(); &#125;); var wsUpdater = &#123; socket: null, uid: null, start: function () &#123; var url = \"ws://127.0.0.1:8888/game\"; wsUpdater.socket = new WebSocket(url); wsUpdater.socket.onmessage = function (event) &#123; &#125;; wsUpdater.socket.onopen = function (ev) &#123; //若是连接成功，onopen函数会执行 console.log(ev); msg = 'success'; wsUpdater.socket.send(JSON.stringify(msg)); &#125;; wsUpdater.socket.onclose = function () &#123; console.log(\"Client断开连接!\"); &#125;; &#125; &#125;; function up() &#123; wsUpdater.socket.send(0); &#125; function down() &#123; wsUpdater.socket.send(1); &#125; function left() &#123; wsUpdater.socket.send(2); &#125; function right() &#123; wsUpdater.socket.send(3); &#125; &lt;/script&gt;&lt;/html&gt; js客户端 先用npm install ws，再输入node doit.js运行代码 doit.js 12345678910111213141516171819202122232425262728var WebSocket = require('ws');console.log('hello');var wsUpdater = &#123; socket: null, uid: null, start: function () &#123; var url = \"ws://127.0.0.1:8888/game\"; wsUpdater.socket = new WebSocket(url); wsUpdater.socket.onmessage = function (ev) &#123; console.log(ev); game = JSON.parse(ev.data); console.log(game); &#125;; wsUpdater.socket.onopen = function (ev) &#123; //若是连接成功，onopen函数会执行 console.log(ev); msg = 'success'; wsUpdater.socket.send(JSON.stringify(msg)); &#125;; wsUpdater.socket.onclose = function () &#123; console.log(\"Client断开连接!\"); &#125;; &#125;&#125;;wsUpdater.start(); Python代码 123456789101112131415161718192021222324252627282930import jsonfrom ws4py.client.threadedclient import WebSocketClientimport multiprocessingfrom core import Gameclass GamePlayer(WebSocketClient): def opened(self): # req = '&#123;\"event\":\"subscribe\", \"channel\":\"eth_usdt.deep\"&#125;' # self.send(req) print(\"连接成功\") def closed(self, code, reason=None): # print(\"Closed down:\", code, reason) print(\"连接中断\") def received_message(self, resp): resp = json.loads(str(resp)) print(resp)if __name__ == '__main__': # in_pipe, out_pipe = multiprocessing.Pipe(True) ws = None try: ws = GamePlayer('ws://127.0.0.1:23456/game') ws.connect() ws.run_forever() except KeyboardInterrupt: ws.close()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"网络知识","slug":"网络知识","permalink":"https://nymrli.top/tags/网络知识/"}]},{"title":"第二十八届“和巨耀通杯”南京邮电大学在线测评系统程序设计邀请赛--","slug":"第二十八届“和巨耀通杯”NOJ邀请赛","date":"2019-11-17T09:43:56.000Z","updated":"2019-11-17T09:58:12.998Z","comments":true,"path":"2019/11/17/第二十八届“和巨耀通杯”NOJ邀请赛/","link":"","permalink":"https://nymrli.top/2019/11/17/第二十八届“和巨耀通杯”NOJ邀请赛/","excerpt":"","text":"第二十八届“和巨耀通杯”NOJ邀请赛 三人团队赛， 正好最近在刷PTA， 于是一个人报名尝试了一下。 一共AC了三题， Rank28 C. Battle game 签到题 Description: You are playing a game which you will battle with an enemy. As you don’t want to lose, your total power can’t be lower than your enemy’s. Your power is simply added by the power of your soldiers, and all of your soldiers’ power is exactly aa. Now you have known that your enemy’s total power is bb. You want to know how many soldiers you need in order not to lose the battle. Input: A line with two integers a,ba,b, (1≤a,b≤109)(1≤a,b≤109). Output: A line with one integer, denotes the minimum number of soldiers you need. Sample Input: 1123 456 Sample Output: 14 AC代码 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b; while(cin &gt;&gt; a&gt;&gt; b)&#123; int ans=1; if ( b%a != 0) ans= b/a+1;// cout &lt;&lt; b/a+1&lt;&lt; endl; else ans = b/a;// cout &lt;&lt; b/a &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D. Gomoku Description: Alice and Bob are playing a game called Gomoku (a.k.a. Five in a Row). Alice is sente(black, moves first) and Bob is gote(white, moves second). Alice wants to know whether she can win(have five or more consecutive stones of the same color in a diagonal, vertical, or horizontal row) in one step, and now is Alice’s turn. It is guranteed that neither Alice or Bob wins currently. Prohibitions are not considered in this problem. Input: The first line contains one integer nn, which denotes the size of the board is n×nn×n. Next nn lines each has a string of length nn, use @ to represent black, O to represent white, + to represent there’s no stone at that position. Output: If Alice can win in one step, output YES, otherwise output NO. Sample Input: 123456787+++O++++@+@++++O@@@+++++@++++++O@++++OOOO++++++++ Sample Output: 1YES AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;stdlib.h&gt;const int maxn = 1e3 + 5;/*7+++O++++@+@++++O@@@+++++@++++++O@++++OOOO++++++++*/using namespace std;char maze[maxn][maxn];bool can=false;const int dirnum = 8;// -&gt; , 2, &lt;- , 8,int xdir[dirnum] = &#123;1, 0, -1, 0, 1, -1, -1, 1&#125;;int ydir[dirnum] = &#123;0, 1, 0, -1, 1, 1, -1, -1&#125;;void dfs(int x, int y, int depth, int dir, int plustime)&#123; if (depth == 5)&#123; can = true;// cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl; return; &#125; if (plustime == 2) return; if (maze[x][y] == 'O') return; if (!maze[x][y]) return; if (can == false)&#123; int xt = xdir[dir] + x; int yt = ydir[dir] + y;// cout &lt;&lt; \" x:\" &lt;&lt; xt &lt;&lt; \" y:\"&lt;&lt; yt &lt;&lt; \" \" &lt;&lt; maze[xt][yt] &lt;&lt; \"plustime:\"&lt;&lt; plustime&lt;&lt; endl; if (maze[xt][yt] == '+' &amp;&amp; plustime==0)&#123; maze[xt][yt] = '@'; dfs(xt, yt, depth+1, dir, plustime+1); maze[xt][yt] = '+'; &#125;else if(maze[xt][yt] == '@' )&#123; dfs(xt, yt, depth+1, dir, plustime); &#125;else return; &#125;else return;&#125;int main()&#123; // 5- 1e3 ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++) cin &gt;&gt;maze[i][j]; &#125;// for(int i=1;i&lt;=n;i++)&#123;// for(int j=1;j&lt;=n;j++)// cout &lt;&lt; maze[i][j];// cout &lt;&lt; endl;// &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if (maze[i][j]== '@')&#123;// cout &lt;&lt; \"test\" &lt;&lt; \"x:\" &lt;&lt; i &lt;&lt; \" y:\"&lt;&lt; j &lt;&lt; \" \"&lt;&lt; maze[i][j]&lt;&lt; endl; for(int k=0; k&lt;dirnum; k++)&#123; int xt = xdir[k] + i; int yt = ydir[k] + j; if (maze[xt][yt]=='@')// cout &lt;&lt; \" in \" &lt;&lt; \"x:\" &lt;&lt; xt &lt;&lt; \" y:\"&lt;&lt; yt &lt;&lt; \" \"&lt;&lt; maze[xt][yt]&lt;&lt; endl; dfs(xt, yt, 2, k, 0); else if (maze[xt][yt] == '+') dfs(xt, yt, 2, k, 1); &#125; &#125;// else cout &lt;&lt; \"new\" &lt;&lt; \"x:\" &lt;&lt; i &lt;&lt; \" y:\"&lt;&lt; j &lt;&lt; \" \"&lt;&lt; maze[i][j]&lt;&lt; endl; &#125; &#125; if (can) printf(\"YES\\n\"); else printf(\"NO\\n\"); return 0;&#125; G. Number 规律题 Description: 0xfaner just learned the factorial today, and the factorial is defined as follows:x!=1×2×⋯×xx!=1×2×⋯×xx!=1×2×⋯×xx!=1×2×⋯×xx!=1×2×⋯×xx!=1×2×⋯×x He found that $10!=362880010!=3628800 $， 20!=243290200817664000020!=243290200817664000020!=2432902008176640000 , the number of trailing zeros is increasing. Now 0xfaner wants to know the the number of trailing zeros of n!n!to each given nn . Input: The only line contains one integer nn ( 1≤n≤1091≤n≤109 ). Output: Print the number of trailing zeros of n!n! . Sample Input: 125 Sample Output: 16 AC 规律题 12345678910111213141516171819202122232425262728293031import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static int solve(int n)&#123; BigInteger res = new BigInteger(\"1\"); for(int i=1;i&lt;=n;i++)&#123; BigInteger tmp = new BigInteger(String.valueOf(i)); res = res.multiply(tmp); &#125;// System.out.printf(\"%s\\n\",res.bitCount());// System.out.printf(\"%s\\n\",res.bitLength());// System.out.printf(\"%d\\n\",res.byteValue()); String s = res.toString(); int ans = 0; for(int j=s.length()-1;j&gt;=0;j--)&#123; if (s.charAt(j)=='0') ans ++; else break; &#125; return ans; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); System.out.printf(\"%d\",solve(n)); &#125; &#125; 执行后一直TLE，于是猜测是否有规律 AC代码 1234567891011121314151617#include &lt;iostream&gt;typedef long long ll;using namespace std;int main()&#123; ios::sync_with_stdio(false); ll n; while(cin &gt;&gt; n)&#123; ll ans = 0; while(n)&#123; ans += n/5; n /= 5; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"}]},{"title":"软件测试笔记","slug":"软件测试笔记","date":"2019-10-18T13:03:29.000Z","updated":"2019-11-02T02:05:36.942Z","comments":true,"path":"2019/10/18/软件测试笔记/","link":"","permalink":"https://nymrli.top/2019/10/18/软件测试笔记/","excerpt":"","text":"软件测试笔记 移动应用测试 appnium使用 安装的是appnium-desktop,没有教程中所说的Appium/node_modules/.bin/路径，使用命令行输入appnium和appium-doctor也都没啥反应，后来索性没管，直接跑代码 真机测试 使用的时候报错Build info: version: 'unknown', revision: 'unknown', time: 'unknown'，以为是appnium版本的问题，第一次安装的是1.13，后来换成了1.9，其实没多大区别，只不过据说要保证版本在1.6以上。 更换版本后，发现还是Build info: version: 'unknown', revision: 'unknown', time: 'unknown'问题，于是试了多次，才终于解决。 步骤一： 这边是设置appnium连接参数的 由于群里的高分脚本也是这么设置的，我就以为没多大问题，其实这边还是要修改不少东西的 1234567891011//设置自动化相关参数DesiredCapabilities capabilities = new DesiredCapabilities();capabilities.setCapability(\"browserName\", \"\");// 确定自己的手机系统是Android、ios的话需要需改capabilities.setCapability(\"platformName\", \"Android\");// 这边要设置成自己的设备uuid，通过adb devices查看capabilities.setCapability(\"deviceName\", \"Android Emulator\");// 这个demo代码会提供好，就不需要自己去找了capabilities.setCapability(\"appPackage\", \"cn.etouch.ecalendar\");capabilities.setCapability(\"appActivity\", \".ECalendar\");capabilities.setCapability(\"noSign\", \"true\"); appPackage查看包名(可以找到唯一的应用)：adb shell dumpsys activity | find &quot;mFocusedActivity&quot;，需要的结果即cn.etouch.ecalendar 12adb shell dumpsys activity | find \"mFocusedActivity\"&gt;&gt;&gt; mFocusedActivity: ActivityRecord&#123;1510a73 u0 cn.etouch.ecalendar/.MainActivity t2&#125; activityName查询类名(找到应用上的某个界面)：aapt dump badging &lt;apkPath&gt;然后找到launchable-activity 123# e.g.E:\\android-sdk-windows\\build-tools\\28.0.3\\aapt dump badging C:\\mooctest\\projects\\3399\\52660\\Zhwnl\\apk\\Zhwnl.apk | grep launchable-activity&gt;&gt;&gt; launchable-activity: name='cn.etouch.ecalendar.ECalendar' label='中华万年历' icon='' 步骤二： 除了代码上设置好连接手机的参数，手机也需要设置电脑能操作手机 需要打开三个选项：“USB调试”、“USB安装”、“USB调试（安全设置）” 以小米6手机为例:“更多设置”-&gt;“开发者选项”-&gt;“USB调试”、“USB安装”、“USB调试（安全设置）” 由于之前使用python玩过ADB，所以**“USB调试”、&quot;USB调试（安全设置）&quot;是开启的，而没打开USB安装**，所以导致了一直失败。实际上打开USB安装后，会安装几个程序比如Unlock、appnium settings等。其实报错一开始也提示了，没检测到手机，啥啥安装不上，只不过当时没留意 123Exception in thread &quot;main&quot; org.openqa.selenium.WebDriverException: An unknown server-side error occurred while processing the command. Original error: Unable to find an active device or emulator with OS 4.1.1. The following are available: cf46749d (8.0.0) (WARNING: The server did not provide any stacktrace information)Command duration or timeout: 469 millisecondsBuild info: version: &apos;unknown&apos;, revision: &apos;unknown&apos;, time: &apos;unknown&apos; ▲后来又发现，不设置platformVersion、deviceName直接设置成Android Emulator也行，看来最主要的原因还是手机第一次使用Appnium之前需要安装写appnium的软件 这个应该就是这两行所安装的东西 1234//设置使用unicode键盘，支持输入中文和特殊字符capabilities.setCapability(\"unicodeKeyboard\",\"true\");//设置用例执行完成后重置键盘capabilities.setCapability(\"resetKeyboard\",\"true\"); 夜深模拟器测试 1 开启USB调试 设置-&gt;关于平板电脑-&gt;多次点击&quot;版本号&quot;进入开发者模式-&gt;开发者选项-&gt;打开**“USB调试”和&quot;允许模拟位置&quot;** 2 查看deviceName 命令行中输入adb devices，如果一直没检测到，解决方案如下（我是需要这么做的）： 12345678910111213如果在设备连接过程中，确定设备已经开启USB调试且正确连接到PC，但是仍旧使用adb devices指令查到设备列表为空，则有可能是已安装的安卓SDK中的adb程序版本和模拟器自带的adb程序版本不一致导致的。解决办法可能有很多种，这里暂介绍楼主亲测实用的方案：第一步：关闭正在运行的的模拟器第二步：替换adb.exe程序。逍遥模拟器：进入安装目录（默认为..\\Microvirt\\MEmu），找到adb.exe文件，执行删除。然后进入SDK的安装目录（默认为..\\android-sdk-windows\\platform-tools），拷贝系统adb.exe到逍遥的原目录即可。夜神模拟器：进入安装目录，找到nox_adb.exe文件，执行删除。然后进入SDK的安装目录（默认为..\\android-sdk-windows\\platform-tools），拷贝系统adb.exe到逍遥的原目录，重命名为“nox_adb.exe”即可。第三步：启动模拟器。启动完毕后，打开cmd命令窗口输入 adb devices 再次检查设备连接情况，一般就能正常看到已连接的虚拟设备信息了。 运行代码main.java 123456789//设置自动化相关参数DesiredCapabilities capabilities = new DesiredCapabilities();capabilities.setCapability(\"browserName\", \"\");capabilities.setCapability(\"platformName\", \"Android\");// capabilities.setCapability(\"platformVersion\", \"8.0.0\");capabilities.setCapability(\"deviceName\", \"127.0.0.1:62001\");capabilities.setCapability(\"appPackage\", \"cn.etouch.ecalendar\");capabilities.setCapability(\"appActivity\", \".ECalendar\");capabilities.setCapability(\"noSign\", \"true\"); 然后运行测试代码就能看到这样的画面了 进入元素审查 安装教程，我是安装软件测试大赛提供的教程安装下来的，只不过感觉这篇可能将的更好一点。（ appium-doctor 是需要额外用npm安装的，而不是像比赛教程中写的那样） 踩坑记录： 出现报错UiAutomator exited unexpectedly with code 0, signal null 123456$ adb shell$ cd /data/local/tmp （如果一次性进不去，可以分层一层层进入）# 3、进入data/local/tmp 后ls查看全部目录，应该有一个 AppiumBootstrap.jar，可能你的名字是 AppiumBoots 或者 AppiumBootstrap.jar。# 4、将andriod sdk下的AppiumBootstrap.jar发送上去$ adb push C:\\Users\\10630\\AppData\\Local\\Programs\\Appium\\resources\\app\\node_modules\\appium\\node_modules\\appium-android-driver\\bootstrap\\bin\\AppiumBootstrap.jar /data/local/tmp# 5、ok，大功告成 adb unauthorized 1.使用adb连接手机时，即使打开了usb调试，手机添加了信任，仍然出现unauthorized的提示 2.C:\\Users\\(Username)\\.android里面删掉adbkey和adbkey.pub两个文件(没添加过信任的话是没有的)，然后重新插拔手机 执行： 12adb kill-serveradb start-server △如果上述方式还是无效的话，选择“开发者测试”-&gt;&quot;调试&quot;中的撤销USB调试授权，然后重新上述操作 特殊元素定位之获取toast java-client版本必须满足5.0+ desiredCapabilities中指定automationName为：UIAutomator2 UIAutomator2只支持安卓版本5.0+ getElement(By.xpath(&quot;//*[contains(@text,'tips')]&quot;)); Monkey使用 脚本优势：简单、快捷、不需要借助任何工具，可以做简单的性能测试 脚本缺点：只能简单实现坐标、按键等基本操作（根据像素点来进行操作） 123456789101112131415161718192021222324#头文件、控制monkey发送消息的参数type=raw eventscount=10speed=1.0#以下monkey命令start data&gt;&gt; # 开启柠檬杯appLaunchActivity（com.lemon.lemonban，com.lemon.lemonban.activity.WelcomeActivity）#让脚本暂停运行4S UserWait（4000）#点击我的柠檬元素Tap（600，1220）#点击我的头像登录#让脚本暂停运行1S UserWait（1000）Tap（300，200）#让脚本暂停运行1s UserWait（2000）#输入手机号码DispatchString（18588220110）#点击密码输入框Tap（200，650）#输入密码DispatchString（123456）#点击登录按钮Tap（320，800）UserWait（3000） 1234# 上传monkey脚本adb push monkeyScript.txt /sdcard/# 运行monkey脚本adb shell monkey -f /sdcard/monkeyScript.txt uiautomatorviewer使用 位置E:\\android-sdk-windows\\tools 1234567@echo onadb shell uiautomator dump /sdcard/app.uixadb pull /sdcard/app.uix .adb shell screencap -p /sdcard/app.pngadb pull /sdcard/app.png . 采坑记录: 小米手机有点坑啊，进行Android开发时需要设置挺多东西的。 关闭MIUI优化不然没法调试 如果进行uiautomatorviewer调试的话，必须还要把悬浮球给关了，不然没法获取界面。 TouchAction 点击操作 123456789101112// pressTouchAction ta=new TouchAction(driver);//创建一个TouchAction对象ta.press(element).release().perform();//按一个元素ta.press(500, 450).release().perform();//按一个坐标点//按一个元素上的某个点，从左上角偏移100ta.press(element,100,100).release().perform();// tapta.tap(element).release().perform();//点一个元素ta.tap(300, 500).release().perform();//点一个坐标点//按一个元素的某个点，从左上角偏移100ta.tap(element, 100, 100).release().perform(); 长按操作 12345678910// longPressTouchAction ta=new TouchAction(driver);//创建一个TouchAction对象ta.longPress(element).release().perform();//长按某个元素ta.longPress(element, 5000).release().perform();//长按某个元素，时间是5秒ta.longPress(300, 500).release().perform();//长按某个坐标点ta.longPress(300, 500, 3000).release().perform();//长按某个坐标点，时间是5秒//长按某元素上的某个点，从左上角偏移100ta.longPress(element, 100, 100).release().perform();//长按某元素上的某个点，从左上角偏移100，时间是3秒ta.longPress(element, 100, 100, 3000).release().perform(); 组合操作–拖拽 12345// press + moveToTouchAction ta=new TouchAction(driver);//创建一个TouchAction对象ta.press(element1).moveTo(element2).release().perform();//两个元素互换位置//将元素拖拽到另外一个位置，moveTo中的是相对偏移量ta.press(element1).waitAction(500).moveTo(0,200).waitAction(500).release().perform(); 连续滑动手势（可用于手势解锁） 12345678// press + moveToTouchAction ta=new TouchAction(driver);//创建一个TouchAction对象//从第一个点一直滑动到第四个点ta.press(200, 200).moveTo(0, 100).moveTo(100, 0).moveTo(100, 100).release().perform();//从第一个元素一直滑动到第四元素ta.press(element1).moveTo(element2).moveTo(element3).moveTo(element4).release().perform()// swipedriver.swipe(width * 3 / 4, height / 2, width / 4, height / 2, during); 其他 1234//在 0% 到 100% 内双指缩放屏幕 driver.pinch(element=el)//放大屏幕 在 100% 以上放大屏幕 driver.zoom(element=el) appnium定位+操作方式(python)——老版本 ▲Appium java-client库更新到6.x后，滑动 swipe() 已弃用，且TouchAction类中很多方法也有改变。 （ 总的来看，弃用的是 press() longPress() moveTo() tap() 参数使用 x、y轴和webElement 的这种类型，和用到Duration类型的方法 ） 取而代之的是参数类型变了，涉及到XY轴定位的方法，参数使用了PointOption.point(X坐标, Y坐标)；涉及到Duration的方法waitAction()，参数使用了WaitOptions.waitOptions(Duration.ofNanos(时间间隔)) 123456//java-client 4.x 滑动 swipe() 案例：driver.swipe(width * 3 / 4, height / 2, width / 4, height / 2, during); //java-client 6.x 滑动案例：int nanos=(int) (second*1000); TouchAction action = new TouchAction(driver).press(PointOption.point(width* 3/4,height/2)).waitAction(WaitOptions.waitOptions(Duration.ofNanos(nanos))).moveTo(PointOption.point(width/4, height/2)).release().perform(); java-client 5.0.4后被移除的函数 众测的思路： 常见输入框的输入范围、限制 手机号11位、验证码6位、敏感信息、特殊字符 toast提示框是否正确 控件是否有错别字 附录： 众包测试报告评分规则 1、众包测试得分=bug报告得分（包括单一状bug报告、fork的bug报告） +评审得分（点赞，点踩） 2、每个Bug报告满分10分，Bug报告基础分1-5分，选手提交的Bug等级仅供参考，以评审人员判定为准； 3、Bug描述简洁清晰、复现步骤连贯、按序号排序，评审人员可根据其描述顺利的进行操作并复现Bug，附加3分。 4、Bug截图相关则附加1分，截图上使用红框标注Bug位置则附加1分； 5、点赞点踩得分规则：即为正确的bug报告点赞，错误的bug报告点踩可得分；反之扣分。 6、若两人提交bug报告相同，依据时间优先原则，后提交的报告计低分，所以若发现的bug已被他人提交，建议Fork（复制并补充修改）或对bug报告进行评审（点赞，点踩）。 开发者测试 语句覆盖： 保证程序中的每一个语句至少被执行一次。 被认为是“最弱的覆盖” 语句覆盖率：被执行语句的比例 判定覆盖(分支覆盖)：CFG (control Flow Graph控制流图 )所有的边都被访问/所有的分支都被访问 ▲针对判断语句，在设定案例的时候，要设定True和False的两种案例；与语句覆盖不同的是增加了False的情况 分支覆盖率：被访问的分支的比例 条件覆盖 针对判断语句里面案例的取值都要去一次，不考虑条件的取值。 每个小判断分别为真，其他为假的情况 判定/条件覆盖 判定覆盖各条件覆盖交叉，针对于判定中的条件取值 、 每个判定真假各一次(判定覆盖) 每个判定中的条件各取一次(条件覆盖) 组合覆盖 判定-条件覆盖的加强版 判定中所有可能的条件组合 路径覆盖 走完所有可能的路径 语句覆盖、条件覆盖（分支覆盖）、判定覆盖、条件-判定覆盖、组合覆盖、路径覆盖 输入域上的测试 –随机测试 –等价类划分 –边界值分析 最小值(min) 略大于最小值(min+) 输入值域内的任意值(nom) 略小于最大值(max-) 最大值(max) Input Domain-Based Techniques(continue) •Random Testing •Combinatorial Testing","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"},{"name":"软件测试","slug":"软件测试","permalink":"https://nymrli.top/tags/软件测试/"}]},{"title":"玩玩Stm32","slug":"玩玩Stm32","date":"2019-10-15T08:33:09.000Z","updated":"2019-10-18T08:56:46.703Z","comments":true,"path":"2019/10/15/玩玩Stm32/","link":"","permalink":"https://nymrli.top/2019/10/15/玩玩Stm32/","excerpt":"","text":"玩玩Stm32 文件结构 12345678910111213141516G:.├───CORE # startup_stm32f10x_hd.s汇编编写的启动文件| # core_cm3.c底层函数├───HARDWARE # 相关外设的初始化代码├───OBJ├───STM32F10x_FWLib # 固件库包: GPIO/i2c/...│ ├───inc│ └───src├───SYSTEM # 正点原子提供的常用、通用模块│ ├───delay│ ├───sys│ └───usart└───USER # stm32f10x_it.c 中断管理文件 | # stm32f10x.h ├───Listings └───Objects 编写规范： 用户编写的执行代码写在main.c中,其中#include &quot;stm32f10x.h&quot;作用相当于C51的#include &lt;reg51.h&gt;，是操作寄存器的主要固件库文件,在任何地方引用到固件库函数时都需要导入这个文件。 stm32f10x_it.c、stm32f10x_it.h, 专门存放中断服务函数的C文件 ,大多中断函数都 写在此文件中,方便 管理中断函数,但并不是一定要写在这里面。 GPIO ◆端口复用功能 STM32的大部分端口都具有复用功能。 所谓复用,就是一些端口不仅仅可以做为通用lO口,还可以复用为一些外设引脚,比如PA9,PA10可以复用为STM32的串口1引脚。 ▲作用：最大限度的利用端口资源 ◆端口重映射功能 就是可以把某些功能引脚映射到其他引脚。 比如串口1默认引脚是PA9,PA10可以通过配置重映射映射到PB6,PB7 作用：为了方便布线 ▲所有I0口都可以作为中断输入 工作模式： 推挽输出：可以输出强高低电平 上拉输入: 一端是接地低电平,所以默认情况下另一端需要检测到高电平(按键扫描中,三个引脚需要设置为IPU,按下时&lt;==&gt;输入口检测到低电平) 下拉输入：(按下时&lt;==&gt;输入口检测到低电平) GPIO重要函数 12345678910111213//1个初始化函数：void GPIO_Init(GPIO_TypeDef* GPIOx,GPIO_InitTypeDef* GPIO_InitStruct)；//2个读取输入电平函数：uint8t GPIO_ReadlinputDataBit(GPIO TypeDef* GPIOx,uint16_t GPIO_Pin)；uint16_t GPIO_ReadinputData(GPIO_TypeDef* GPIOx)；//2个读取输出电平函数：uint8t GPIO_ReadOutputDataBit(GPiO_TypeDef* GPiOx,uint16_t GPIO_Pin)；uint16t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)；//4个设置输出电平函数：前两个常用,后两个不常用void GPIO_SetBits(GPIOTypeDef* GPIOx, uint16_t GPIOPin)；void GP1O_ResetBits(GPIOTypeDef GPIOx,uint16_t GPIOPin)；void GPIO_WriteBit(GPIOTypeDef* GPIOx,uint16_t GPIO_Pin,BitAction BitVal)；void GPIO_Write(GPIOTypeDef* GPIOx, uint16_t PortVal) 具体说明 1234567891011121314151617181920212223void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)/*GPIO_TypeDef为GPIO寄存器组合的类型typedef struct&#123; __IO uint32_t CRL; __IO uint32_t CRH; __IO uint32_t IDR; __IO uint32_t ODR; __IO uint32_t BSRR; __IO uint32_t BRR; __IO uint32_t LCKR;&#125; GPIO_TypeDef;GPIOx的选择可以为GPIOA-&gt;GPIOG*/ /*typedef struct&#123; uint16_t GPIO_Pin; GPIOSpeed_TypeDef GPIO_Speed; GPIOMode_TypeDef GPIO_Mode; &#125;GPIO_InitTypeDef;*/ 初始化示例 12345678910// 声明结构体变量GPIO_InitTypeDef GPIO_InitStructure；//LEDO--&gt;PB.5端口配置GPIO InitStructure.GPIO Pin =GPIO_Pin_5；//推挽输出GPIO InitStructure.GPIO Mode=GPIO_Mode_Out_PP；//IO口速度为50MHzGPIO InitStructure.GPIO Speed=GPIO_Speed_50MHz；//根据设定参数初始化GPIOB.5GPIO_Init(GPIOB,&amp;GPIO_InitStructure); ▲在使用GPIO前,需要使能IO口时钟,调用函数RCC_APB2PeriphColckCmd(); 1234567891011121314151617181920212223242526void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)/*RCC_APB2Periph 可以为RCC_APB2Periph_AFIO RCC_APB2Periph_GPIOA RCC_APB2Periph_GPIOB RCC_APB2Periph_GPIOC RCC_APB2Periph_GPIOD RCC_APB2Periph_GPIOE RCC_APB2Periph_GPIOF RCC_APB2Periph_GPIOG RCC_APB2Periph_ADC1 RCC_APB2Periph_ADC2 RCC_APB2Periph_TIM1 RCC_APB2Periph_SPI1 RCC_APB2Periph_TIM8 RCC_APB2Periph_USART1 RCC_APB2Periph_ADC3 RCC_APB2Periph_TIM15 RCC_APB2Periph_TIM16 RCC_APB2Periph_TIM17 RCC_APB2Periph_TIM9 RCC_APB2Periph_TIM10 RCC_APB2Periph_TIM11 NewState 为ENABLE / DISABLE*/ 提示：不能通过IO口直接驱动大功率器件。 △复位之后，IO口默认为浮空状态，如果不接下拉电阻，那么电平不确定为高还是低电平。(到是小电流的时候，电流会直接通过下拉电阻到地，不会经过三极管；只有电流足够大，才会经过三极管) demo : 跑马灯实验 当将PE5设置为低电平时,通过上拉电阻连到VCC后,LED就能点亮。PE5被设置为高电平时与上拉高电平之间没有压差,此时LED熄灭。 完整代码: led.c文件内容 12345678910111213141516171819202122#include \"led.h\"#include \"stm32f10x.h\" // 在任何地方引用到固件库时都需要导入这个文件void LED_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOE,ENABLE); GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOB,&amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOE,&amp;GPIO_InitStruct); // 设置为高电平,熄灭 GPIO_SetBits(GPIOB, GPIO_Pin_5);&#125; main.c文件内容 12345678910111213141516#include \"stm32f10x.h\"#include \"led.h\"#include \"delay.h\" int main(void)&#123; delay_init(); LED_Init(); while(1)&#123; GPIO_SetBits(GPIOB,GPIO_Pin_5); GPIO_SetBits(GPIOE,GPIO_Pin_5); delay_ms(500); GPIO_ResetBits(GPIOB,GPIO_Pin_5); GPIO_ResetBits(GPIOE,GPIO_Pin_5); delay_ms(500); &#125; &#125; 操作IO口的三种方式： 位操作：#define BEEP PBout(8);后BEEP = 1 库函数：GPIO_SetBits(GPIOB, GPIO_Pin_8); 寄存器： 中断管理 对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。IP bit决定了对每个中断共有2^4(位) = 16级的中断优先级设置 高优先级的抢占优先级是可以打断正在进行的低抢占优先级中断的。 抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。 抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行。 如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行； 总结：中断嵌套执行看抢占优先级；占优先级相同时,响应优先级高的先响应；两者都一样的话，执行顺序看发生的时间 △.优先级0最高，4最低。 ▲.系统代码执行过程中，只设置一次中断优先，一般不会再改变分组。 1234567891011121314// 中断优先级分组函数void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)// demo: NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2) // 对某个中断设置优先级void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)/*typedef struct&#123; uint8_t NVIC_IRQChannel; uint8_t NVIC_IRQChannelPreemptionPriority; uint8_t NVIC_IRQChannelSubPriority; FunctionalState NVIC_IRQChannelCmd; &#125; NVIC_InitTypeDef;*/ 中断优先级控制的寄存器组：IP[240]对每个中断进行管理,STM32F10x系列一共有60个可屏蔽中断。全称是：Interrupt Priority Registers 中断优先级设置步骤 123456789101112131415//①统运行后先设置中断优先级分组。调用函数：//整个系统执行过程中，只设置一次中断分组。void NVIC_Priority_GroupConfig(uint32_t NVIC_PriorityGroup)；//②针对每个中断，设置对应的抢占优先级和响应优先级：void NVIC Init(NVIC_InitTypeDef* NVIC_Initstructy；/* demo:NVIC_InitStructure.NVIC_IRQChannel=EXTI3_IRQn://使能按键KEY1所在的外部中断通道NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0x02：//抢占优先级2NVIC_InitStructure.NVIC_IRQChannelSubPriority =0x01：∥字优先级1NVIC_InitStructure.NVIC_IRQChannelCmd =ENABLE://使能外部中断通道NWIC_Init(&amp;WIC_Init Structure)：/根据NIC_InitStruct中指定的参数初始化外设NVIC寄存器*/ //③如果需要挂起/解挂，查看中断当前激活状态，分别调用相关函数即可。 串口通信 异步: 跟系统时钟无关 同步: 跟系统时钟有关 波特率计算方法:Tx/RxBaudrate=fPCLKx(16∗USARTDIV)\\mathrm{Tx} / \\mathrm{Rx} \\quad Baud rate=\\frac{f_{P C L K x}}{(16 * U S A R T D I V)}Tx/RxBaudrate=(16∗USARTDIV)fPCLKx​​ 配置的一般步骤: 串口作为外设，需要使能:RCC_APB2PeriphClockCmdO;、以及使能GPIO的时钟 GPIO端口模式设置GPIOInit0;，模式设置为GPIO_Mode_AFPP复用推挽(PA.9/10复用为串口1) 串口参数初始化 使能串口USART Cma); 串口数据收发 ▲ UART串口通信只需连接TX，RX，GND ， 一般不需要连接VCC A：TX、RX是正负压的，所以有个地做参考就行了 A： 通信两端一般都有各自的供电电压，所以不需要VCC，只有一端没有电源的情况下才会用VCC向对方输送电源 A：就像像耳机只要联地、音频左、音频右，而不联vcc一个道理 正点原子提供的USART库： 以回车换行结束的协议 usart.h 1234567#define USART_REC_LEN 200 //定义最大接收字节数 200#define EN_USART1_RX 1 //使能（1）/禁止（0）串口1接收 extern u8 USART_RX_BUF[USART_REC_LEN]; //接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 extern u16 USART_RX_STA; //接收状态标记 //如果想串口中断接收，请不要注释以下宏定义void uart_init(u32 bound); 数据全保存在USART_RX_BUF中。根据STA的有效数据个数比如50个，将USART_RX_BUF中前50个数据拿出处理。处理完所有标志位将被清零 ▲程序要求，发送的字符是以回车换行结束(Ox0D,0x0A)。 △串口调试助手里勾选&quot;发送新行&quot;选项 usart.c 程序理解 12345678910111213141516171819202122232425262728293031323334353637void USART1_IRQHandler(void) //串口1中断服务程序 &#123; u8 Res;#if SYSTEM_SUPPORT_OS //如果SYSTEM_SUPPORT_OS为真，则需要支持OS. OSIntEnter(); #endif if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) //接收中断(接收到的数据必须是0x0d 0x0a结尾) &#123; Res =USART_ReceiveData(USART1); //读取接收到的数据(单个字符) if((USART_RX_STA&amp;0x8000)==0)//没收到\\n,即接收未完成 &#123; if(USART_RX_STA&amp;0x4000)//接收到了0x0d(\\r) &#123; if(Res!=0x0a)USART_RX_STA=0;//如果下一个不是\\n,那么接收错误,重新开始 else USART_RX_STA|=0x8000; //如果接受到\\n,则接收完成,将USART_RX_STA bit15置1 &#125; else //还没收到0X0D,即处理真正数据 &#123; // 如果当前接收到\\r,那么将Bit14置1 if(Res==0x0d)USART_RX_STA|=0x4000; else &#123; // 将当前收到的字符Res存到数组USART_RX_BUF保存 USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=Res ; // 索引+1 USART_RX_STA++; // 如果数据超额,那么判断为接收错误 if(USART_RX_STA&gt;(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收 &#125; &#125; &#125; &#125; #if SYSTEM_SUPPORT_OS //如果SYSTEM_SUPPORT_OS为真，则需要支持OS. OSIntExit(); #endif&#125; Res =USART_ReceiveData(USART1);获得的是当前接收的字符，如果使用中断，那么调用USART_SendData(USART1, Res)就能接收一个字符，发送一个字符。 USART_RX_BUF的作用是，保存一次字符串发送过来的所有数据 USART_RX_STA是个寄存器，通过Bit14，Bit15来判断接收是否有效 main.c 12345678910111213141516171819202122232425262728293031int main(void)&#123; u16 t; u16 len; u16 times=0; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 KEY_Init(); //初始化与按键连接的硬件接口 while(1)&#123; if(USART_RX_STA&amp;0x8000)&#123; len=USART_RX_STA&amp;0x3fff;//得到此次接收到的数据长度 printf(\"\\r\\n您发送的消息为:\\r\\n\\r\\n\"); for(t=0;t&lt;len;t++)&#123; USART_SendData(USART1, USART_RX_BUF[t]);//向串口1发送数据 while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);//等待发送结束 &#125; printf(\"\\r\\n\\r\\n\");//插入换行 USART_RX_STA=0; &#125;else&#123; times++; if(times%5000==0)&#123; printf(\"\\r\\n战舰STM32开发板 串口实验\\r\\n\"); printf(\"正点原子@ALIENTEK\\r\\n\\r\\n\"); &#125; if(times%200==0)printf(\"请输入数据,以回车键结束\\n\"); if(times%30==0)LED0=!LED0;//闪烁LED,提示系统正在运行. delay_ms(10); &#125; &#125; &#125; ▲printf可以将发送到串口，默认是USART1，如果需要修改，在usart.c的fputc函数中,将USART1修改即可 外部中断 每个IO口都可以作为外部中断输入 IO与中断线的映射,16* 7 = 112, 一共有16个中断线 Q:什么是中断线,能干什么? A:中断线能发出中断请求 △.同一时刻只有一个引脚能映射到某根中断线 原理: GPIOX.0映射到EXT10 GPIOX.1映射到EXT11 GPIOX.15映射到EXTI15 e.g.PA.0~PG.0可以映射到EXIT0 I0口外部中断在中断向量表中只分配了7个中断向量，也就是只能使用7个中断服务函数 常用库函数 123456789void GPIO_EXTILineConig(uint8_t GPIO,uint8_t PortSource,uint8_t GPIO_PinSource)//设置IO口与中断线的映射关系：exp:GPIO_EXTILineContig(GPIO_PortSourceGPIOE, GPIO_PinSource2)void EXTIInit(EXTI_InitTypeDef* EXTI_InitStruct);//初始化中断线：触发方式等ITStatus EXTI_GetlTStatus(uint32_t EXTI_hLine);//判断中断线中断状态，是否发生void EXTI_ClearlTPendingBit(uint32_t EXTI_Line)//清除中断线上的中断标志位 12345EXTI_InitStructure.EXTI_Line=EXTI_Line2;// 指定要配置的中断线EXTI_InitStructure.EXTI_Mode =EXTI_Mode_Interrupt;// 模式:事件or中断EXTI_InitStructure.EXTI_Trigger =EXTI_Trigger_Faling;//上升沿、下降沿、双触发沿EXTI_InitStructure.EXTI_LineCmd =ENABLE;// 使能、失能EXTI_Init(&amp; EXTI_InitStructure); 配置的一般步骤 demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384void EXTIX_Init(void)&#123; // 声明初始化结构体变量 EXTI_InitTypeDef EXTI_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; KEY_Init(); // 按键端口初始化 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //使能复用功能时钟 //GPIOE.2 中断线以及中断初始化配置 下降沿触发 GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2); EXTI_InitStructure.EXTI_Line=EXTI_Line2; //KEY2 EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 // ▲由于参数一致，所以不需要修改EXTI_InitStructure的功能参数 //GPIOE.3 中断线以及中断初始化配置 下降沿触发 //KEY1 GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource3); EXTI_InitStructure.EXTI_Line=EXTI_Line3; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 //GPIOA.0 中断线以及中断初始化配置 上升沿触发 PA0 WK_UP GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0); EXTI_InitStructure.EXTI_Line=EXTI_Line0; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; //使能按键WK_UP所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2， NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn; //使能按键KEY2所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2， NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级2 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn; //使能按键KEY1所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01; //子优先级1 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器&#125;//外部中断2服务程序void EXTI2_IRQHandler(void)&#123; delay_ms(10);//消抖 if(KEY2==0) //按键KEY2 &#123; LED0=!LED0; &#125; EXTI_ClearITPendingBit(EXTI_Line2); //清除LINE2上的中断标志位 &#125;//外部中断3服务程序void EXTI3_IRQHandler(void)&#123; delay_ms(10);//消抖 if(KEY1==0) //按键KEY1 &#123; LED1=!LED1; &#125; EXTI_ClearITPendingBit(EXTI_Line3); //清除LINE3上的中断标志位 &#125;void EXTI4_IRQHandler(void)&#123; delay_ms(10);//消抖 if(KEY0==0) //按键KEY0 &#123; LED0=!LED0; LED1=!LED1; &#125; EXTI_ClearITPendingBit(EXTI_Line4); //清除LINE4上的中断标志位 &#125; main.c 1234567891011121314int main(void) &#123; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //初始化与LED连接的硬件接口 BEEP_Init(); //初始化蜂鸣器端口 KEY_Init(); //初始化与按键连接的硬件接口 EXTIX_Init(); //外部中断初始化 LED0=0; //点亮LED0 while(1)&#123; printf(\"OK\\r\\n\"); delay_ms(1000); &#125; &#125; 附录: u8、u16、Size_t是什么类型? u8、u16 123456789/*!&lt; Signed integer types */typedef signed char int8_t; //有符号8位数typedef signed short int16_t; //有符号16位数typedef signed long int32_t; //有符号32位数 /*!&lt; Unsigned integer types */typedef unsigned char uint8_t; //无符号8位数typedef unsigned short uint16_t; //无符号16位数typedef unsigned long uint32_t; //无符号32位数 size_t size_t是C++标准在stddef.h中定义的。这个类型足以用来表示对象的大小。size_t的真实类型与操作系统有关。size_t在32位架构上是4字节，在64位架构上是8字节，在不同架构上进行编译时需要注意这个问题。而int在不同架构下都是4字节，与size_t不同；且int为带符号数，size_t为无符号数。 电平相关知识 单片机是一种数字集成芯片，数字电路中只有两种电平高电平和低电平。为了让大家在刚起步的时候对电平特性有一个清晰的认识，我们暂且定义单片机输出与输入为TTL电平，其中高电平为+5V,低电平为0V。计算机的串口为RS-232C电平。这里要强调的是，RS-232C电平为负逻辑电平。因此当计算机与单片机之间要通信时，需要加电平转换芯片，我们在TX-1C单片机实验板上所加的电平转换芯片是MAX232 。 常用的逻辑电平有TTL、CMOS、LVTTL、ECL、PECL、 GTL 、RS-232. RS-422. RS-485、LVDS等.其中TTL和CMOS的逻辑电平按典型电压可分为四类：5V系列(5V TL和5V CMOS)、3.3V 系列，2.5V 系列和1.8V系列， T电平信号用的最多，这是因为，数据表示通常采用二进制，+5V等价于逻辑1，0V等价于逻辑0）.这被称为TTL（晶体管一晶体管逻辑电平）信号系统，这是计算机处理器控制的设备内部各部分之间通信的标准技术。TTL电平信号对于计算机处理器控制的设备内部的数据传输是很理想的，首先计算机处理器控制的设备内部的数据传输对于电源的要求不高，热损耗也较低，另外TTL电平信号直接与集成电路连接而不需要价格昂贵的线路驱动器 功能函数 判断u8数组开头 123456789101112131415161718#include &lt;string.h&gt;/////////////////////////// 判断u8 arr开头是否为str //////////////////////////int u8cmp(u8 *arr, const char *str)&#123; int i; int len = strlen(str); for ( i = 0; i &lt; len; i++)&#123; if( arr[i] != str[i])&#123; // arr shorter than str if (arr[i] == '\\0') return -1; // not start with return 0; &#125; &#125; // arr start with str return 1;&#125;","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://nymrli.top/tags/嵌入式/"}]},{"title":"蒙特卡洛树搜索MCTS","slug":"蒙特卡洛树搜索MCTS","date":"2019-10-07T09:18:02.000Z","updated":"2020-12-06T01:59:09.017Z","comments":true,"path":"2019/10/07/蒙特卡洛树搜索MCTS/","link":"","permalink":"https://nymrli.top/2019/10/07/蒙特卡洛树搜索MCTS/","excerpt":"","text":".mjpage .MJX-monospace { font-family: monospace } .mjpage .MJX-sans-serif { font-family: sans-serif } .mjpage { display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0 } .mjpage * { transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none } .mjx-svg-href { fill: blue; stroke: blue } .MathJax_SVG_LineBox { display: table!important } .MathJax_SVG_LineBox span { display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none; padding: 0; border: 0; margin: 0 } .mjpage__block { text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100% } 蒙特卡洛树搜索MCTS 跟围棋的关联 AlphaGo Zero 蒙特卡洛树搜索——内含用于树遍历的 PUCT 函数的某些变体 残差卷积神经网络——其中的策略和价值网络被用于评估棋局，以进行下一步落子位置的先验概率估算。 强化学习——通过自我对弈进行神经网络训练 AlphaGo Zero跟AlphaGo的最大区别是抛弃人类棋谱的，完全通过自我对弈来学会下棋的，并且仅用40小时就到达了AlphaGo的棋力。 过程是这样，首先生成棋谱，然后将棋谱作为输入训练神经网络，训练好的神经网络用来预测落子和胜率。如下图： 在AlphaGo Zero中蒙特卡洛树搜索主要是用来生成棋谱的 蒙特卡洛树搜索 Q:MCTS干了什么? A:给出一个「游戏状态」并选择「胜率最高的下一步」 适用于有限两人零和回合制游戏 MCTS算法是一种决策算法，每次模拟（simulation）分为4步： Tree traversal(树的遍历): UCB1(Si)=Vi‾+clog⁡Nni,c=2UCB1(S_{i})=\\overline{V_{i}}+c \\sqrt{\\frac{\\log N}{n_{i}}}, c=2UCB1(Si​)=Vi​​+cni​logN​​,c=2 其中，表Vi‾\\overline{V_{i}}Vi​​示SiS_iSi​状态的平均value(下面会进一步解释） Node expansion(拓展节点) Rollout (random simulation)(模拟) Backpropagation(反向传播) 蒙特卡洛计算过程 UCB(Upper Confidence Bounds置信上限)其实就是UCT(UCB for Tree)中需要计算的值，而UCT是根据UCB值来迭代的算法 第一、二步的流程（遍历、拓展节点）： 1.从状态S0开始，要在下面两个动作中进行选择（假设只有两个动作可选），选择的标准就是UCB1(Si)UCB1(S_{i})UCB1(Si​)值，选择最大化 UCT 的节点作为下一个节点。初始情况两个UCB1(S1)=UCB1(S2)=∞UCB1(S_{1})=UCB1(S_{2})=\\inftyUCB1(S1​)=UCB1(S2​)=∞,按顺序选择S1 2.判断目前的结点S1(current node)是不是叶节点，这里叶节点是指其没有被展开（expansion）过。 3.接下来，按照流程图，需要判断结点S1被访问的系数是否为0。是0，则要进行Rollout。(Rollout其实就是在接下来的步骤中每一步都随机采取动作，直到停止点（围棋中的对局结束），得到一个最终的value。)==&gt;假设Rollout最终值为20. 4.Backpropagation，即利用Rollout最终得到的value来更新路径上每个结点的T,N值。(之后把Rollout的结果删除：MCTS的想法就是要从出S0发不断的进行迭代，不断更新结点值，直到达到一定的迭代次数或者时间。) 5.如果没有达到一定的迭代次数或者时间，继续从根节点进行1-4 第三步rollout模拟: 1234567891011/*这个函数接受一个表示博弈状态的参数，然后返回下一步行动。实际上，它被设计得非常快，从而可以让很多模拟快速进行——默认的 rollout policy 函数是一个均衡分布的随机数生成函数。*/Rollout(S_i): loop forever: /* 如果当前状态结点是个终止结点 */ if S_i is a terminal state: /* 那么直接返回它的value值*/ return value(S_i) /* 找到下一个动作 */ A_i = random(available-actions(S_i)) /* 选择下一个状态进行拓展 */ S_i = simulate(A_i,S_i) 4.反向传播：从子节点的结果传到根节点 例子说明见:蒙特卡洛树搜索（MCTS）算法-计算过程，视频讲解见B站:【MCTS】Youtube上迄今为止最好的蒙特卡罗树搜索讲解 还有个搜索算法：极大极小法（minimax）。这个策略假定你的对手发挥了最好的博弈水平，然后以此调整策略来最大化你的收益。简单地说，给定状态，你想要找到一个能产生最大收益的 move ，假定你的对手想要最小化你的收益（最大化他自己的收益）。因此，名字叫作极小化极大。 极小化极大算法的最大劣势是，需要扩展整个博弈树。对于分支因子较高的博弈（例如围棋或者国际象棋），这会导致庞大的博弈树从而失败，所以一般MinMax算法外还要加上alpha-beta剪枝。 UCT算法——树的置信上限(UCB for Trees) Upper Confidence Bounds(置信上限) UCB1是一个让我们从已访问的节点中选择下一个节点来进行遍历的函数，也是MCTS的核心函数。 UCB1(vi,v)=Q(vi)N(vi)+clog⁡(N(v))N(vi)UCB1(v_{i}, v)=\\frac{Q(v_{i})}{N(v_{i})}+c \\sqrt{\\frac{\\log (N(v))}{N(v_{i})}} UCB1(vi​,v)=N(vi​)Q(vi​)​+cN(vi​)log(N(v))​​ 其中v为当前节点，Vi为其子节点。 exploitation component(利用) 第一部分是 \\frac{Q(v_{i})}{N(v_{i})} ​ ，也称作exploitation component。 Q(Vi)为子节点获胜次数，N(Vi)为子节点参与模拟的次数 可以看做是子节点Vi的胜率估计（总收益/总次数=平均每次的收益）。但是不能只选择胜率高的下一步，因为这种贪婪方式的搜索会很快导致游戏结束，这往往会导致搜索不充分，错过最优解。 举个简单的例子。现在假设MCTS的UCT函数只用了探索成分，从根节点开始，我们对所有子节点进行了一次模拟，然后在下一步中只访问至少赢了一次的子节点。那么在第一次模拟中那些不幸未被选中的节点（实际中rollout策略函数通常是随机的）将会被立刻抛弃 exploration component(探索) c \\sqrt{\\frac{\\log(N(v))}{N(v_{i})}}$$，这个成分更倾向于那些想对较少被探索的节点N(Vi)小。 参数c是exploitation和exploration之间的折中系数。 ### MCTS的终止 终止条件(or)： - 达到一定的迭代次数 - 达到规定的搜索时间 当MSCT程序结束时，最佳的移动通常是访问次数最多的那个节点，也是UCT最大的点。 ## 参考: [深度学习入门：AlphaGo Zero蒙特卡洛树搜索](https://blog.csdn.net/mergerly/article/details/83788862) [蒙特卡洛树搜索（MCTS）算法-计算过程](https://blog.csdn.net/ljyt2/article/details/78332802) [【MCTS】Youtube上迄今为止最好的蒙特卡罗树搜索讲解](https://www.bilibili.com/video/av67847675?from=search&amp;seid=7487786042631726209) [AI如何下棋？直观了解蒙特卡洛树搜索MCTS！！！](https://www.bilibili.com/video/BV1JD4y1Q7mV?from=search&amp;seid=6045698802301050730)——整体讲的很好，汇总了百度能搜到的大部分知识点 ## 代码实现文档: [python实现的基于蒙特卡洛树搜索(MCTS)与UCB的五子棋游戏](https://blog.csdn.net/white_gl/article/details/56521880) [mctspy：井字棋-蒙特卡洛树搜索算法的python实现](https://github.com/int8/monte-carlo-tree-search) --- 蒙特卡洛树搜索（MCTS）仅展开根据 UCB 公式所计算过的节点，并且会采用一种自动的方式对性能指标好的节点进行更多的搜索。具体步骤概括如下： 1.由当前局面建立根节点，生成根节点的全部子节点，分别进行模拟对局； 2.从根节点开始，进行最佳优先搜索； 3.利用 UCB 公式计算每个子节点的 UCB 值，选择最大值的子节点； 4.若此节点不是叶节点，则以此节点作为根节点，重复 2； 5.直到遇到叶节点，如果叶节点未曾经被模拟对局过，对这个叶节点模拟对局；否则为这个叶节点随机生成子节点，并进行模拟对局； 6.将模拟对局的收益（一般胜为 1 负为 0）按对应颜色更新该节点及各级祖先节点，同时增加该节点以上所有节点的访问次数； 7.回到 2，除非此轮搜索时间结束或者达到预设循环次数； 8.从当前局面的子节点中挑选平均收益最高的给出最佳着法。 由此可见 UCT 算法就是在设定的时间内不断完成从根节点按照 UCB 的指引最终走到某一个叶节点的过程。而算法的基本流程包括了选择好的分支（Selection）、在叶子节点上扩展一层（Expansion）、模拟对局（Simulation）和结果回馈（Backpropagation）这样四个部分。 UCT 树搜索还有一个显著优点就是可以**随时**结束搜索并返回结果，在&lt;u&gt;每一时刻，对 UCT 树来说都有一个相对最优的结果&lt;/u&gt;。 https://blog.csdn.net/white_gl/article/details/56521880","categories":[],"tags":[{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"Python多进程","slug":"Python多进程","date":"2019-10-06T12:17:44.000Z","updated":"2019-10-07T04:15:31.316Z","comments":true,"path":"2019/10/06/Python多进程/","link":"","permalink":"https://nymrli.top/2019/10/06/Python多进程/","excerpt":"","text":"Python多进程 守护进程 守护进程其实就是**“子进程“是否伴随主进程一起结束**:守护==&gt;伴随，即守护进程会伴随主进程的代码运行完毕后而死掉 进程：当父进程需要将一个任务并发出去执行，需要将该任务放到以个子进程里 守护：当该子进程内的代码在父进程代码运行完毕后就没有存在的意义了，就应该 将该子进程设置为守护进程，会在父进程代码结束后死掉 1234567891011121314151617181920212223from multiprocessing import Processimport timedef foo(): print(123) time.sleep(1) print(\"end123\")def bar(): print(456) time.sleep(3) print(\"end456\")if __name__ == '__main__': p1=Process(target=foo) p2=Process(target=bar) # 将子进程p1设置为守护进程，守护进程要放在进程start之前 # 所以p1会在print(\"main-------\")打印完成后死掉，所以p1进程不会打印 p1.daemon=True p1.start() p2.start() # time.sleep(1) print(\"main-------\") 进程锁 主要使用multiprocessing下的Lock对象 就是将要执行任务的部门代码（只涉及到修改共享数据的代码）变成串行，作用是让进程不乱掉，下面代码就是可以避免 i 乱打印 12345678910111213from multiprocessing import Process, Lock def f(l, i): l.acquire() #锁住进程 try: print('hello world', i) finally: l.release() #释放锁 if __name__ == '__main__': lock = Lock() for num in range(10): Process(target=f, args=(lock, num)).start() （理解为用锁来限制，同一时间只能让一个人拿着锁去改数据，先抢到锁的人 就有优先购买的权限） 1234# 主要就是用的这三个lock = lock()lock.acquire() # 拿钥匙，开门lock.release() #还钥匙，关门 抢票demo 写法一 1234567891011121314151617181920212223242526272829303132333435363738394041#模拟抢票软件的原理：from multiprocessing import Lock,Processimport json,os,time,randomdef check(): #查票功能实现并行访问 time.sleep(1) with open('db.txt','rt',encoding='utf-8') as f: dic=json.load(f) print('%s 查看余票数为 %s'%(os.getpid(),dic['count']))def get(): #购票因为牵涉到对后台数据的修改，所以加互斥锁目的是逐一进行访问修改，以免数据错乱 with open('db.txt', 'rt',encoding='utf-8') as f: dic = json.load(f) time.sleep(2) if dic['count'] &gt;0: #有票 dic['count']-=1 time.sleep(random.randint(1, 3)) #在购票时，模拟网络延迟... with open('db.txt', 'wt',encoding='utf-8') as f: json.dump(dic,f) print('%s 购票成功'%os.getpid()) else: print('%s 没有余票'%os.getpid())def task(mutex): #查看（并行访问） check() #抢票（加入互斥锁，实现串行访问，先到先得原则） mutex.acquire() get() mutex.release() #第一个购买完成后，解锁，后续进入继续购买if __name__ == '__main__': mutex=Lock() #调用Lock类拿到一个对象 for i in range(10): p=Process(target=task,args=(mutex,)) p.start() 写法二: 123456789101112131415161718192021222324252627282930313233343536# 锁# 火车票import jsonimport timefrom multiprocessing import Processfrom multiprocessing import Lockdef show(i): with open('ticket') as f: dic = json.load(f) print('余票: %s'%dic['ticket'])def buy_ticket(i,lock): lock.acquire() #拿钥匙进门 with open('ticket') as f: dic = json.load(f) time.sleep(0.1) if dic['ticket'] &gt; 0 : dic['ticket'] -= 1 print('\\033[32m%s买到票了\\033[0m'%i) else: print('\\033[31m%s没买到票\\033[0m'%i) time.sleep(0.1) with open('ticket','w') as f: json.dump(dic,f) lock.release() # 还钥匙if __name__ == '__main__': for i in range(10): p = Process(target=show,args=(i,)) p.start() lock = Lock() for i in range(10): p = Process(target=buy_ticket, args=(i,lock)) p.start() 进程间的通信** 用一块儿共享的内存==&gt;实现进程间的共享 特点: 一定是内存空间 能够自动帮忙处理锁的问题 实现进程间的通讯（IPC）的方式有很多种，如：管道(Pipe)，消息队列(Queue: == PIPE+锁（队列）)，共享内存，信号，信号量，套接字 管道 消息队列 共享内存 开辟空间 内存 内存 内存 读写方式 两端读写[双向/单向] 先进先出 覆盖之前的内容 效率 一般 一般 较高 应用 多用于父子进程 广泛灵活 需要注意互斥 注意： 1.队列占用的是内存空间 2.不应该往队列中放大数据，应该只存放数据量较小的精简的内容 生产者消费者模型 生产者：比喻的是程序中负责产生数据的任务 消费者：比喻的是程序中负责处理数据的任务 生产者———&gt;共享的介质(队列)&lt;————消费者 Q:作用是什么? A: 实现生产者与消费者的解耦和，生产者可以不停的生产，消费者也可以不停的消费从而平衡了生产者的生产能力与消费者消费能力，提升了而整体运行的效率 Q:什么时候用? A:当我们程序中存在明显的两类任务，一类是负责产生数据，一类是负责处理数据，此时就应该考虑使用生产者消费者模型来提升程序的效率 多进程中的join() 在进程中可以阻塞主进程的执行, 直到等待子线程全部完成之后, 才继续运行主线程后面的代码 12345678910111213141516171819202122232425import threadingimport timedef test(num): time.sleep(1) print(num)#定义一个用来装子线程的列表threads = []for i in range(5): #target 指定子线程要执行的funtion, args 指定该funtion需要传入的参数 thread = threading.Thread(target = test, args = [i]) #上面的 thread 是一个个参数i都不同的线程, 现在把它一个个装进列表 threads 里面 threads.append(thread)for i in threads: #for 循环执行 threads 列表里面的全部线程, 没有用 join()线程是无序执行的, # 就连最后一句print('end')可能比所有子线程都要先执行 i.start()print('end')'''end41230''' 将其修改为 123456789101112for i in tsreads: i.start() i.join()'''01234end[Finished in 5.2s]''' 每个都会隔一秒的进行输出,因为for循环也是主进程操作,也会被阻塞直到子进程完成。 12345678910111213for i in tsreads: i.start()for i in threads: i.join()'''23104end[Finished in 1.2s]''' 在这里看一看出来, join()还是阻挡了主线程的执行, 让所有的子线程执行完毕之后再执行, 而且前面的子线程的执行都是无序地执行完毕了 △.一般来说，join函数应该在所有的start函数之后(即一般情况下，让所有进程都执行，然后等待子进程结束，再进行下面的主进程)。 Python多进程之Manager 可以用来进程间共享对象、资源、变量===&gt;使用公共内存 12345678910111213141516171819202122232425from multiprocessing import Process,Managerimport os# 这里实现的就是多个进程之间共享内存，并修改数据# 这里不需要加锁，因为manager已经默认给你加锁了def f(d,l): d[1] = '1' d['2'] = 2 d[0.25] = None l.append(os.getpid()) print(l)if __name__ == '__main__': with Manager() as manager: d = manager.dict() #生成一个字典 l = manager.list(range(5)) #生成一个列表 p_list = [] for i in range(10): p = Process(target=f,args=(d,l)) p.start() p_list.append(p) for res in p_list: res.join() print(d) print(l) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from multiprocessing import Process, Lock, Valuefrom multiprocessing.managers import BaseManagerclass Employee(object): def __init__(self, name, salary): self.name = name self.salary = Value('i', salary) self.data = [] def increase(self): self.salary.value += 100 self.data.append(self.salary.value) print(self.data) def getPay(self): return self.name + ':' + str(self.salary.value)class MyManager(BaseManager): ''' 继承即可 ''' passdef Manager(): m = MyManager() m.start() return mMyManager.register('Employee', Employee)def func(em, lock): with lock: em.increase()if __name__ == '__main__': manager = Manager() em = manager.Employee('zhangsan', 1000) lock = Lock() proces = [Process(target=func, args=(em, lock)) for i in range(10)] for p in proces: p.start() for p in proces: p.join() print(em.getPay())'''&gt;&gt;&gt;[1100][1100, 1200][1100, 1200, 1300][1100, 1200, 1300, 1400][1100, 1200, 1300, 1400, 1500][1100, 1200, 1300, 1400, 1500, 1600][1100, 1200, 1300, 1400, 1500, 1600, 1700][1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800][1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900][1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000]zhangsan:2000''' Queue 其实就是一个队列（FIFO），两个进程可以通过传入的参数q，来获得里面的内容，从而数据共享、通信。 123456789101112131415161718192021222324252627282930313233#导入Queue,Processfrom multiprocessing import Queue,Processimport os #写入进程def wp(q): print(\"%s开始写入：\"%os.getpid) for i in \"WANG\": #将信息写入队列 q.put(i) print(i) #读取进程def rd(q): print(\"%s开始读取\"%os.getpid()) while True: if not q.empty(): #从队列读取信息 print(\"read to %s\"%q.get()) if __name__==\"__main__\": #创建队列 q = Queue() #创建写入进程 w = Process(target=wp,args=(q,)) #启动写入进程 w.start() #创建读取进程 r = Process(target=rd,args=(q,)) #启动读取进程 r.start() Pipe管道 和队列的功能差不多，实现两个进程之间数据的传递，只不过是FILO的: 123456789101112131415'''管道pipe'''from multiprocessing import Process, Pipe def f(conn): conn.send('hello') #发送hello print(conn.recv()) #收到牛逼 conn.close() #关闭 if __name__ == '__main__': parent_conn, child_conn = Pipe() #管道会产生两个返回值 p = Process(target=f, args=(child_conn,)) #创建一个子进程 p.start() print(parent_conn.recv()) #收到'hello'\" parent_conn.send('牛逼') #发送牛逼 p.join() 借鉴: Python守护进程、进程互斥锁、进程间通信ICP（Queue队列）、生产者消费者模型 多进程 之 join() Java 多线程中两个线程交替执行 Python多进程消息队列实现进程间通讯 Queue详细内容","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Openmv使用","slug":"Openmv使用","date":"2019-10-06T01:45:28.000Z","updated":"2019-11-07T12:36:38.416Z","comments":true,"path":"2019/10/06/Openmv使用/","link":"","permalink":"https://nymrli.top/2019/10/06/Openmv使用/","excerpt":"","text":"Openmv使用 下载Openmv IDE Openmv官网 中国代理——星瞳 Github_release 推荐下载星瞳的，这个是中文版的，并且其他两个下载非常慢。 捕捉图片设置： 设置彩色／黑白 sensor.set_pixformat() 设置像素模式。 sensor.GRAYSCALE: 灰度，每个像素8bit。 sensor.RGB565: 彩色，每个像素16bit。 设置图像大小 sensor.set_framesize() 设置图像的大小 sensor.QQVGA: 160x120 sensor.QQVGA2: 128x160 (用于 lcd 扩展板) sensor.HQVGA: 240x160 sensor.QVGA: 320x240 sensor.VGA: 640x480 (只用于OpenMV Cam M7 的灰度图处理图像，或者彩图采集图像) sensor.QQCIF: 88x72 sensor.QCIF: 176x144 sensor.CIF: 352x288 设置窗口ROI sensor.set_windowing(roi) 设置翻转 sensor.set_hmirror(True) 水平方向翻转 sensor.set_vflip(True) 垂直方向翻转 Demo例程： openmv虽然比较贵,但是它的功能非常强大,已经提供了相当多的例程了。具体例程可以去星瞳的官网上查看，说明非常详细。 在此，我只介绍点我们这次需要用到的功能。 我使用的是OPENMV-H7 R1，芯片是STM32H743，镜头为IR 1080P 2.8mm Hello World 1234567891011121314151617# Hello World Example## Welcome to the OpenMV IDE! Click on the green run arrow button below to run the script!import sensor, image, timesensor.reset() # Reset and initialize the sensor.sensor.set_pixformat(sensor.RGB565) # Set pixel format to RGB565 (or GRAYSCALE)sensor.set_framesize(sensor.QVGA) # Set frame size to QVGA (320x240)sensor.skip_frames(time = 2000) # Wait for settings take effect.clock = time.clock() # Create a clock object to track the FPS.while(True): clock.tick() # Update the FPS clock. img = sensor.snapshot() # Take a picture and return the image. print(clock.fps()) # Note: OpenMV Cam runs about half as fast when connected # to the IDE. The FPS should increase once disconnected. 二维码识别 12345678910111213141516171819202122# QRCode Example## This example shows the power of the OpenMV Cam to detect QR Codes# using lens correction (see the qrcodes_with_lens_corr.py script for higher performance).import sensor, image, timesensor.reset()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QVGA)sensor.skip_frames(time = 2000)sensor.set_auto_gain(False) # must turn this off to prevent image washout...clock = time.clock()while(True): clock.tick() img = sensor.snapshot() img.lens_corr(1.8) # strength of 1.8 is good for the 2.8mm lens. for code in img.find_qrcodes(): img.draw_rectangle(code.rect(), color = (255, 0, 0)) print(code) print(clock.fps()) 代码是用python编写的，文件系统为microPython，具有Cpython解释器翻译成机器码。需要脱机运行的文件命名为main.py即可(具体详情见microPython规范)。可放于flash或者32GB以下的SD卡中，SD卡读取优先级高于Flash，且flash内容容易丢失，且擦写次数有限，建议使用SD卡。 主要需要用的库： sersor:通过这个对象可以控制摄像头及相关配置； image：处理图像的功能函数都在这个库里 sensor.snapshot()会返回一个&lt;class ‘Image’&gt; time：跟Python自带的time模块不同，这个是专门用来记录摄像头用时的 颜色追踪 颜色阈值需要使用LAB色彩空间 LAB的范围选择，个人比较快截的方法是通过IDE右边的帧缓冲区来获取，即框出ROI区域后，再打开“工具-&gt;机器视觉-&gt;阈值编辑器-&gt;帧缓冲区”,然后根据直方图中的数据就可以筛选出想要的对象辣(白色是选出，黑色是过滤，好像跟PS的蒙版是反的?) ▲颜色识别时，一定要关闭自动增益、白平衡 sensor.set_auto_gain() 自动增益开启（True）或者关闭（False）。在使用颜色追踪时，需要关闭自动增益。 sensor.set_auto_whitebal() 自动白平衡开启（True）或者关闭（False）。在使用颜色追踪时，需要关闭自动白平衡。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Measure the distance## This example shows off how to measure the distance through the size in imgage# This example in particular looks for yellow pingpong ball.import sensor, image, time, lcd# For color tracking to work really well you should ideally be in a very, very,# very, controlled enviroment where the lighting is constant...#yellow_threshold = (22, 74, -12, 31, 23, 62)box_threshold = (40, 80, -4, 21, 14, 51)red_threshold = (40, 59, 61, 84, 30, 79)# You may need to tweak the above settings for tracking green things...# Select an area in the Framebuffer to copy the color settings.sensor.reset() # Initialize the camera sensor.sensor.set_pixformat(sensor.RGB565) # use RGB565.sensor.set_framesize(sensor.QVGA) # use QQVGA for speed.sensor.skip_frames(10) # Let new settings take affect.sensor.set_auto_whitebal(False) # turn this off.clock = time.clock() # Tracks FPS.#lcd.init() # Initialize the lcd screen.K=5000#the value should be measuredwhile(True): clock.tick() # Track elapsed milliseconds between snapshots(). img = sensor.snapshot() # Take a picture and return the image. blobs = img.find_blobs([red_threshold]) if len(blobs) == 1: # Draw a rect around the blob. #b = blobs[0] #img.draw_rectangle(b[0:4]) # rect #img.draw_cross(b[5], b[6]) # cx, cy #Lm = (b[2]+b[3])/2 #length = K/Lm #print(length) b = blobs[0] img.draw_rectangle(b[0:4]) img.draw_cross(b[5], b[6]) #lcd.display(sensor.snapshot()) # Take a picture and display the image. #print(clock.fps()) # Note: Your OpenMV Cam runs about half as fast while # connected to your computer. The FPS should increase once disconnected. 识别圆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 圆形检测例程## 这个例子展示了如何用Hough变换在图像中找到圆。# https://en.wikipedia.org/wiki/Circle_Hough_Transform## 请注意，find_circles（）方法将只能找到完全在图像内部的圆。圈子之外的# 图像/ roi被忽略...import sensor, image, timesensor.reset()sensor.set_pixformat(sensor.RGB565) # grayscale is fastersensor.set_framesize(sensor.QQVGA)sensor.skip_frames(time = 2000)clock = time.clock()while(True): clock.tick() #lens_corr(1.8)畸变矫正 img = sensor.snapshot().lens_corr(1.8) # Circle对象有四个值: x, y, r (半径), 和 magnitude。 # magnitude是检测圆的强度。越高越好 # roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， # ROI 即图像矩形。操作范围仅限于roi区域内的像素。 # x_stride 是霍夫变换时需要跳过的x像素的数量。若已知圆较大，可增加 # x_stride 。 # y_stride 是霍夫变换时需要跳过的y像素的数量。若已知直线较大，可增加 # y_stride 。 # threshold 控制从霍夫变换中监测到的圆。只返回大于或等于阈值的圆。 # 应用程序的阈值正确值取决于图像。注意：一条圆的大小是组成圆所有 # 索贝尔滤波像素大小的总和。 # x_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 # r_margin的部分合并。 # y_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 # r_margin 的部分合并。 # r_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 # r_margin 的部分合并。 # r_min，r_max和r_step控制测试圆的半径。 # 缩小测试圆半径的数量可以大大提升性能。 # threshold = 3500比较合适。如果视野中检测到的圆过多，请增大阈值； # 相反，如果视野中检测到的圆过少，请减少阈值。 for c in img.find_circles(threshold = 3500, x_margin = 10, y_margin = 10, r_margin = 10,r_min = 2, r_max = 100, r_step = 2):# (80,60,80,60) img.draw_circle(c.x(), c.y(), c.r(), color = (255, 0, 0)) print(c) for r in img.find_rects(threshold = 3500): img.draw_rectangle(r.rect(), color=(255,0,0)) for p in r.corners(): img.draw_circle(p[0], p[1], 5, color=(0,255,0)) print(r) print(\"FPS %f\" % clock.fps()) 测距和测量物块大小 由于 OpenMV采用的是单目摄像头，想要实现测距，就需要选参照物，利用参照物的大小比例来计算距离。 Len∝1pixelconutLen ∝ \\frac{1}{pixelconut}Len∝pixelconut1​&gt;dist=Cpixeldist = \\frac{C}{pixel}dist=pixelC​实际长度和摄像头里的像素成反比 **&gt;** 距离 = 一个常数/直径的像素 先测出这个常数的值，怎么测不用说了吧，就是先让球距离摄像头10cm，打印出摄像头里直径的像素值，然后相乘，就得到了k的值！ 就可以算出距离了(=这个常数/摄像头里像素点数) 12345678910111213141516171819202122232425262728293031323334353637383940414243# Measure the distance## This example shows off how to measure the distance through the size in imgage# This example in particular looks for yellow pingpong ball.import sensor, image, time# For color tracking to work really well you should ideally be in a very, very,# very, controlled enviroment where the lighting is constant...yellow_threshold = ( 56, 83, 5, 57, 63, 80)# box_threshold = (40, 80, -4, 21, 14, 51)# red_threshold = (40, 59, 61, 84, 30, 79)# You may need to tweak the above settings for tracking green things...# Select an area in the Framebuffer to copy the color settings.sensor.reset() # Initialize the camera sensor.sensor.set_pixformat(sensor.RGB565) # use RGB565.sensor.set_framesize(sensor.QQVGA) # use QQVGA for speed.sensor.skip_frames(10) # Let new settings take affect.sensor.set_auto_whitebal(False) # turn this off.clock = time.clock() # Tracks FPS.K=5000#the value should be measured# K = 36*10while(True): clock.tick() # Track elapsed milliseconds between snapshots(). img = sensor.snapshot() # Take a picture and return the image. blobs = img.find_blobs([yellow_threshold]) if len(blobs) == 1: # Draw a rect around the blob. b = blobs[0] img.draw_rectangle(b[0:4]) # rect img.draw_cross(b[5], b[6]) # cx, cy Lm = (b[2]+b[3])/2 # 像素点数 # index 2 is length, 3 is width length = K/Lm # 距离 print(length) #print(clock.fps()) # Note: Your OpenMV Cam runs about half as fast while # connected to your computer. The FPS should increase once disconnected. LCD显示 由于正好有个LCD显示屏，那就也记录下LCD的代码把 123456789101112131415# LCD Example## Note: To run this example you will need a LCD Shield for your OpenMV Cam.## The LCD Shield allows you to view your OpenMV Cam's frame buffer on the go.import sensor, image, lcdsensor.reset() # Initialize the camera sensor.sensor.set_pixformat(sensor.RGB565) # or sensor.GRAYSCALEsensor.set_framesize(sensor.QQVGA2) # Special 128x160 framesize for LCD Shield.lcd.init() # Initialize the lcd screen.while(True): lcd.display(sensor.snapshot()) # Take a picture and display the image. 串口通信 12345678910111213141516171819202122# UART Control## This example shows how to use the serial port on your OpenMV Cam. Attach pin# P4 to the serial input of a serial LCD screen to see \"Hello World!\" printed# on the serial LCD display.import timefrom pyb import UART# Always pass UART 3 for the UART number for your OpenMV Cam.# The second argument is the UART baud rate. For a more advanced UART control# example see the BLE-Shield driver.uart = UART(3, 19200)while(True): # 发送数据 uart.write(\"Hello World!\\r\") time.sleep(1000) # 接收数据 if uart.any(): a=uart.readline() print(a) 与STM32通信 openmv 1234567891011121314import time,sensor, imagefrom pyb import UARTuart = UART(3, 115200)uart.init(115200, bits=8, parity=None, stop=1)while(True): # 由于正点原子提供的串口通信协议需要以\\r\\n结尾,所以,这边必须也要写\\r\\n uart.write(\"Hello World!\\r\\n\") # 中文好像解析不了 if uart.any(): a=uart.readline() print(a) main.c 123456789101112131415161718192021222324252627282930313233#include \"led.h\"#include \"delay.h\"#include \"key.h\"#include \"sys.h\"#include \"usart.h\"int main(void)&#123; u16 t; u16 len; u16 times=0; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 KEY_Init(); //初始化与按键连接的硬件接口 while(1)&#123; if(USART_RX_STA&amp;0x8000)&#123; len=USART_RX_STA&amp;0x3fff;//得到此次接收到的数据长度 printf(\"Your message is:\\r\\n\\r\\n\"); for(t=0;t&lt;len;t++)&#123; USART_SendData(USART1, USART_RX_BUF[t]);//向串口1发送数据 while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);//等待发送结束 &#125; //printf(\"\\r\\n\\r\\n\");//插入换行 USART_RX_STA=0; &#125;else&#123; times++; if(times%200==0) printf(\"Waiting for input.2333\\r\\n\"); if(times%30==0)LED0=!LED0;//闪烁LED,提示系统正在运行. delay_ms(10); &#125; &#125; &#125; 测试结果（暂时还没理解）： 补充: openmv 发送16进制数 附录: OpenMV中文入门教程 视频教程: B站OpenMV视频教程 星瞳官网 B站的清晰度和加载速度比较快，星瞳官网的还有额外的教程（他家的拓展版） 画图： 12image.draw_line((10,10,20,30), color=(255,0,0))image.draw_rectangle(rect_tuple, color=(255,0,0)) 画线 image.draw_line(line_tuple, color=White) 在图像中画一条直线。 line_tuple的格式是(x0, y0, x1, y1)，意思是(x0, y0)到(x1, y1)的直线。 颜色可以是灰度值(0-255)，或者是彩色值(r, g, b)的tupple。默认是白色 画框 image.draw_rectangle(rect_tuple, color=White) 在图像中画一个矩形框。 rect_tuple 的格式是 (x, y, w, h)。 画圆 image.draw_circle(x, y, radius, color=White) 在图像中画一个圆。 x,y是圆心坐标 radius是圆的半径 画十字 image.draw_cross(x, y, size=5, color=White) 在图像中画一个十字 x,y是坐标 size是两侧的尺寸 写字 image.draw_string(x, y, text, color=White) 在图像中写字 8x10的像素 x,y是坐标。使用\\n, \\r, and \\r\\n会使光标移动到下一行。 text是要写的字符串。 需要调参的地方： 测大小的常数k 形状检测的阈值 颜色识别的阈值","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://nymrli.top/tags/嵌入式/"}]},{"title":"TD-afterstate","slug":"TD-afterstate","date":"2019-10-03T11:28:36.000Z","updated":"2019-10-03T11:30:03.963Z","comments":true,"path":"2019/10/03/TD-afterstate/","link":"","permalink":"https://nymrli.top/2019/10/03/TD-afterstate/","excerpt":"","text":"TD-afterstate afterstae: 当前执行一个动作后的状态，可以理解为中间态 是处理问题的一个改动,一种思想 以俄罗斯方块为例: 状态是由当前的局面和一个随机方块组成，执行一个下落动作之后会产生一个局面就称为afterstate，即动作结束后不能进行新的动作（没有新方块）的状态。 中间态和下一个随机方块构成了下一个状态 对于没有这种随机性的问题，afterstate就是next state td做预测，afterstate做控制 更多: 强化学习经典入门书的读书笔记系列–第六篇Temporal-Difference","categories":[],"tags":[{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"git命令详解","slug":"git命令详解","date":"2019-09-29T09:39:07.000Z","updated":"2019-12-12T10:59:20.655Z","comments":true,"path":"2019/09/29/git命令详解/","link":"","permalink":"https://nymrli.top/2019/09/29/git命令详解/","excerpt":"","text":"git命令详解 自己的仓库管理： git add &lt;filename&gt; 将文件添加到暂存区中 (其中git add.可以将当前目录的子目录文件都添加到暂存区中) git commit -m &quot;...&quot;: 保存仓库的历史记录,其中 -m &quot;…&quot;提交信息(概述) git config --global user.name &quot;...&quot;、git config --global user.email &quot;...&quot;: 配置提交作者信息 git log: 查看提交日志(当前状态为终点) 会产生版本库里一系列单独提交的历史 git diff ID1/ID2: 查看版本差异 git mv 新名字,旧名字 重命名: git branch -a [-v] 分支一展表, -r 查看远程git服务器上的分支 git checkout 分支名: 切换分支 -b创建,且切换到新建分支 等价于git branch 分支名 + git checkout 分支名 git branch -d [分支名称] 删除一个分支, -d选项只能删除已经参与过合并的分支，对于未参与合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项、 git rest --head ID : 退回之前提交版本 git status : 查看仓库当前状态； git reflog : 查看当前仓库的操作日志 git rebase -i: 压缩历史(如果出现拼写错误时需要): git rebase -i HEAD~2 git merge --no-f 分支名 : 合并分支 git remote set-url origin https://github.com/Freedomisgood/NjuptGo.git 修改仓库指定新的远程仓库 git commit --amend: 修改上次commit备注信息 远程仓库 如果本地没有仓库，则clone: git clone http://github.com/xxx/yyy.git 在本地增加远程仓库信息：git remote add apollo3d http://github.com/xxx/yyy.git,此时远程库名为origin、apollo3d 删除远程分支git push origin --delete kickof git push代码到远程新分支 git push origin master:my_remote_new_branch git pull 如果本地有仓库，则拉取更新命令为: git pull &lt;远程库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 比如，取回远程库中的online分支，与本地的online分支进行merge，要写成： git pull origin online:online 如果是要与本地当前分支merge，则冒号后面的&lt;本地分支名&gt;可以不写 git pull origin online 通常，git会将本地库分支与远程分支之间建立一种追踪关系。比如，在git clone的时候，所有本地分支默认与远程库的同名分支建立追踪关系。也就是说，本地的master分支自动追踪origin/master分支。因此，如果当前处于本地online分支上，并且本地online分支与远程的online分支有追踪关系，那么远程的分支名可以省略： 比如，取回远程库中的online分支，与本地的online分支进行merge，要写成： git pull origin 其实，git pull 命令等同于先做了git fetch ，再做了git merge。即： 123git fetch origin onlinegit checkout onlinegit merge origin/online git push 二.推送本地分支到远程仓库 （一）.创建本地分支git checkout -b 新分支名 （二）.推送本地分支到远程仓库git push --set-upstream origin 分支名 三、将远程git仓库里的指定分支拉取到本地（本地不存在的分支） git checkout -b 本地分支名 origin/远程分支名 修改了.gitignore生效指令 123git rm -r --cached . // 删除本地缓存git add . // 添加要提交的文件git commit -m &apos;update .gitignore&apos; // 更新本地的缓存 参考 Git远程操作详解:http://www.ruanyifeng.com/blog/2014/06/git_remote.html 使用git将项目上传到github（最简单方法）:https://www.cnblogs.com/cxk1995/p/5800196.html &lt;&lt;Git入门与实践&gt;&gt;:日本 Git恢复之前版本的两种方法reset、revert（图文详解） 采坑记录 Q: 不小心git reset --hard HEAD^导致工作区文件全没了 A:解决方案: Undo git reset --hard with uncommitted files in the staging area 恢复git reset --hard删除的文件 根据这篇博客操作的结果git cat-file -p ID &gt; a.md是个对比文件 1234567891011100644 blob cdca566953e3b7b56897b2fa6995129170403212 Q-learning.ipynb100644 blob 47735fcc505315aa61583dad9dc4facb7c00fbdc Q-learning.py100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 __init__.py040000 tree db76babbe2f2df4566b607e732c0c835418f9a83 __pycache__100644 blob debb716313cfbf28c055e89ce4a625a1d7801f5b agents.py100644 blob 30ec43da68efe5eb5e8e31cb431fea981e256b6a approximator.py100644 blob 1e8ac820d62943d16fa56fa981d72e27239527d9 core.py100644 blob a0cfa7ac7f9f15a658ace5c5c7c5bbe73f680502 myringworld.py100644 blob 69cb25ba30f4350454a0e731a70890cbf2530217 ringworld.py100644 blob 5638e012cb1b68783e6cdf45d2e769cca96e591f utils.py100644 blob 96aa662c03d991487e6da8120884b6f647be7202 viewer.py △.关于git reset --hard导致文件丢失的血的教训——亲测有效 解决add了但没有commit的文件，可以用上述方法找回 12341. 执行 git fsck --lost-found；2. 在.git/lost-found目录下找找看有没有你丢失的文件；3.有的话复制出来，如果是文本，直接改成正确扩展名，你就笑了；4. 没有的话，就再去Google吧； 分支git branch参数区别","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"numpy使用记录","slug":"numpy使用记录","date":"2019-09-28T03:13:29.000Z","updated":"2019-11-27T03:36:08.072Z","comments":true,"path":"2019/09/28/numpy使用记录/","link":"","permalink":"https://nymrli.top/2019/09/28/numpy使用记录/","excerpt":"","text":"Numpy使用记录 numpy中的random numpy.random.choice(a, size=None, replace=True, p=None) a : 如果是一维数组，就表示从这个一维数组中随机采样；如果是int型，就表示从0到a-1这个序列中随机采样。 size : 采样结果的数量，默认为1.可以是整数，表示要采样的数量；也可以为tuple，如(m, n, k)，则要采样的数量为m * n * k，size为(m, n, k) replace : boolean型，采样的样本是否要更换？这个地方我不太理解，测了一下发现replace指定为True时，采样的元素会有重复；当replace指定为False时，采样不会重复。 p : 一个一维数组，制定了a中每个元素采样的概率，若为默认的None，则a中每个元素被采样的概率相同。 12345678choice(a[, size, replace, p])&gt;&gt;&gt; np.random.choice(5, 3, replace=False)array([3,1,0])&gt;&gt;&gt; #This is equivalent to np.random.permutation(np.arange(5))[:3]# Generate a non-uniform random sample from np.arange(5) of size 3 without replacement:&gt;&gt;&gt; np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])array([2, 3, 0]) np.random.randint 123np.random.randint(2,5,size=(2,3))# 函数原型randint(low[, high, size])# - 返回随机的整数，位于半开区间 [low, high)。 np.random.rand 12345&gt;&gt;&gt; np.random.rand(3,2)array([[ 0.14022471, 0.96360618], #random [ 0.37601032, 0.25528411], #random [ 0.49313049, 0.94909878]]) #random# 跟random_sample([size])、random([size])和ranf([size])一样 array操作 广播啥的就不介绍了，主要是介绍一点函数方法的使用 array、asarray、asanyarray 1234567891011121314151617a = np.array([1,2,3])print(a)&gt;&gt;&gt;[1 2 3]c = np.array(a)c[1]=3print(a,c)&gt;&gt;&gt;[1 2 3] [1 3 3]b = np.asarray(a)b[1]=3print(a,b)&gt;&gt;&gt;[1 3 3] [1 3 3]# array和asarray的不同在于array对目标做一个拷贝，而asarray不会 np.asanyarray 会返回 ndarray 或者ndarray的子类，而np.asarray 只返回 ndarray. np.where(cond,x,y)：满足条件（cond）输出x，不满足输出y 这个函数非常有用，非常香，但是他的参数需要narray 降维 1234567891011a = np.array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]])# 法一：ravelprint(a.ravel())# 法二：flattenprint(a.flatten())# 法三：reshape([1,-1])print(a.reshape([1,-1])) ▲参数-1讲解：一个参数为-1时，那么reshape函数会根据另一个参数的维度计算出数组的另外一个shape属性值 […]语法简单使用 在切片中...跟:的效果是一样的，都是缺省默认取所有的意思 123# 两者等价print(a[:,2])print(a[...,2])","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"}]},{"title":"Python random","slug":"Python-random","date":"2019-09-27T14:11:59.000Z","updated":"2019-09-29T09:01:11.576Z","comments":true,"path":"2019/09/27/Python-random/","link":"","permalink":"https://nymrli.top/2019/09/27/Python-random/","excerpt":"","text":"Python random 老是忘记random中每个函数之间的区别，而且常常跟numpy里的random也经常搞混，因此还是写篇文章记一下吧。 random模块 choice和sample python中random.choice()可以从给定的可迭代对象中随机挑选出一个。 而python中random.sample()方法则可以随机地从给定的可迭代对象中提取出N个不同的元素，列表的维数没有限制。（即第二参数给出个数N） 1234567891011import randomprint(random.sample([chr(97 + x) for x in range(int(9))],2))# 函数原型sample(self, population, k)&gt;&gt;&gt; ['e', 'c']# ---print( random.randint(1,10) ) # 产生 1 到 10 的一个整数型随机数 print( random.random() ) # 产生 0 到 1 之间的随机浮点数print( random.uniform(1.1,5.4) ) # 产生 1.1 到 5.4 之间的随机浮点数，区间可以不是整数print( random.choice('tomorrow') ) # 从序列中随机选取一个元素# 函数原型def choice(self, seq)print( random.randrange(1,100,2) ) # 生成从1到100的间隔为2的随机整数 shuffle 正如字面所示，也就是打乱的意思 1234a=[1,3,5,6,7] # 将序列a中的元素顺序打乱random.shuffle(a)print(a)&gt;&gt;&gt; [1, 6, 7, 3, 5] numpy中的random numpy.random.choice(a, size=None, replace=True, p=None) a : 如果是一维数组，就表示从这个一维数组中随机采样；如果是int型，就表示从0到a-1这个序列中随机采样。 size : 采样结果的数量，默认为1.可以是整数，表示要采样的数量；也可以为tuple，如(m, n, k)，则要采样的数量为m * n * k，size为(m, n, k) replace : boolean型，采样的样本是否要更换？这个地方我不太理解，测了一下发现replace指定为True时，采样的元素会有重复；当replace指定为False时，采样不会重复。 p : 一个一维数组，制定了a中每个元素采样的概率，若为默认的None，则a中每个元素被采样的概率相同。 12345678choice(a[, size, replace, p])&gt;&gt;&gt; np.random.choice(5, 3, replace=False)array([3,1,0])&gt;&gt;&gt; #This is equivalent to np.random.permutation(np.arange(5))[:3]# Generate a non-uniform random sample from np.arange(5) of size 3 without replacement:&gt;&gt;&gt; np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])array([2, 3, 0]) np.random.randint 123np.random.randint(2,5,size=(2,3))# 函数原型randint(low[, high, size])# - 返回随机的整数，位于半开区间 [low, high)。 np.random.rand 12345&gt;&gt;&gt; np.random.rand(3,2)array([[ 0.14022471, 0.96360618], #random [ 0.37601032, 0.25528411], #random [ 0.49313049, 0.94909878]]) #random# 跟random_sample([size])、random([size])和ranf([size])一样 ▲需要注意的是np.random.randint和random.randint的区间不同，前者左闭右开()，后者左右都是闭区间[]▲","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"OpenAI Gym使用、rendering画图","slug":"OpenAI-Gym使用","date":"2019-09-26T09:53:27.000Z","updated":"2019-10-07T10:01:00.137Z","comments":true,"path":"2019/09/26/OpenAI-Gym使用/","link":"","permalink":"https://nymrli.top/2019/09/26/OpenAI-Gym使用/","excerpt":"","text":"OpenAI Gym使用、rendering画图 gym开源库：包含一个测试问题集，每个问题成为环境（environment），可以用于自己的RL算法开发。这些环境有共享的接口，允许用户设计通用的算法。其包含了deep mind 使用的Atari游戏测试床。 在强化学习中有2个基本概念，一个是环境（environment），称为外部世界，另一个为智能体agent（写的算法）。agent发送action至environment，environment返回观察和回报。 Gym官方文档 Hello gym 123456789import gym# 创建一个小车倒立摆模型env = gym.make(‘CartPole-v0’)# 初始化环境env.reset()# 刷新当前环境，并显示for _ in range(1000): env.render() env.step(env.action_space.sample()) # take a random action 设计理念图,一个环境的step函数返回需要的信息，有4种返回值 observation reward done :判断是否到了重新设定(reset)环境 info :用于调试的诊断信息，有时也用于学习，但智能体（agent ）在正式的评价中不允许使用该信息进行学习。 该进程通过调用reset()来启动，它返回一个初始observation。 所以之前代码的更恰当的方法是遵守done的标志： 空间（Spaces） 在上面的例子中，已经从环境的动作空间中抽取随机动作。但这些行动究竟是什么呢？ 每个环境都带有action_space 和observation_space对象。这些属性是Space类型，它们描述格式化的有效的行动和观察。 1234567import gymenv = gym.make('CartPole-v0')# 离散空间允许固定范围的非负数，因此在这种情况下，有效的动作是0或1. print(env.action_space)#&gt; Discrete(2)print(env.observation_space)#&gt; Box(4,) Box空间表示一个n维box，所以有效的观察将是4个数字的数组。 也可以检查Box的范围： 1234print(env.observation_space.high)#&gt; array([ 2.4 , inf, 0.20943951, inf])print(env.observation_space.low)#&gt; array([-2.4 , -inf, -0.20943951, -inf]) 这种内省可以帮助编写适用于许多不同环境的通用代码。box和discrete是最常见的空间。你可以从一个空间中取样，或者检查某物是否属于它： 12345from gym import spacesspace = spaces.Discrete(8) # Set with 8 elements &#123;0, 1, 2, ..., 7&#125;x = space.sample()assert space.contains(x)assert space.n == 8 Env.render画图 参考Gym 简单画图 123456789101112131415161718192021222324252627282930313233# 首先，导入库文件（包括gym模块和gym中的渲染模块）import gymfrom gym.envs.classic_control import rendering# 我们生成一个类，该类继承 gym.Env. 同时，可以添加元数据，改变渲染环境时的参数class Test(gym.Env): # 如果你不想改参数，下面可以不用写 metadata = &#123; 'render.modes': ['human', 'rgb_array'], 'video.frames_per_second': 2 &#125;# 我们在初始函数中定义一个 viewer ，即画板 def __init__(self): self.viewer = rendering.Viewer(600, 400) # 600x400 是画板的长和框 # 继承Env render函数 def render(self, mode='human', close=False): # 下面就可以定义你要绘画的元素了 line1 = rendering.Line((100, 300), (500, 300)) line2 = rendering.Line((100, 200), (500, 200)) # 给元素添加颜色 line1.set_color(0, 0, 0) line2.set_color(0, 0, 0) # 把图形元素添加到画板中 self.viewer.add_geom(line1) self.viewer.add_geom(line2) return self.viewer.render(return_rgb_array=mode == 'rgb_array') # 最后运行if __name__ == '__main__': t = Test() while True: t.render() △.值得注意的是，画板的水平方向是 x 轴， 垂直方向是 y 轴， 且原点在左下角 画个圆 1234567891011def render(self, mode='human', close=False): # 画一个直径为 30 的园 circle = rendering.make_circle(30) # 添加一个平移操作 circle_transform = rendering.Transform(translation=(100, 200)) # 让圆添加平移这个属性, circle.add_attr(circle_transform) self.viewer.add_geom(circle) return self.viewer.render(return_rgb_array=mode == 'rgb_array') △注意.是圆心在平移 RingViewr 研究rings时写的render 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import gymfrom gym.envs.classic_control import renderingimport timeimport numpy as npimport randomclass ringViewer(rendering.Viewer): ''' 画板,直接继承自rendering.Viewer ''' def __init__(self,width, height, display=None): super(ringViewer, self).__init__(width, height, display=None) @staticmethod def pos2loc(pos=0): ''' 根据位置索引确定画图坐标 :param pos: 位置索引0-9 :return: loc ''' pass @staticmethod def getSize(size): ''' 设置画圆的半径 :param size:[0-2] :return: radius ''' pass @staticmethod def getColor(c=0): ''' 根据颜色索引选择圆圈颜色 :param c: :return: list ''' pass def drawNewring(self, newring:list=None): ''' 画新生成的圆 :param newring: :return: ''' for i in range(len(newring)): if newring[i] != 0: ring = rendering.make_circle(radius=self.getSize(i), res=50, filled=False) r, g, b = self.getColor(newring[i]) ring.set_color(r, g, b) ring_transform = rendering.Transform(translation=(150,30)) ring.add_attr(ring_transform) self.add_geom(ring) def _drawQG(self, qgs: list=None): ''' 画棋盘上各个棋格的圆圈 :param qgs: :return: None ''' for num,qg in enumerate(qgs): for i in range(len(qg)): if qg[i] != 0: ring = rendering.make_circle(radius=self.getSize(i), res = 50, filled=False) r, g, b = self.getColor(qg[i]) ring.set_color(r, g, b) ring_transform = rendering.Transform(translation=self.pos2loc(num)) ring.add_attr(ring_transform) self.add_geom(ring) def getQG(self, qg: list=None): ''' 将len=27的list转换为[[],[],...] :param qg: (27,1)的list :return: (9,1)的list ''' qgs = [] for x in range(3): for y in range(3): tmp = [] for z in range(3): tmp.append(qg[9*x+3*y+z]) qgs.append(tmp) self._drawQG(qgs)class Testenv(gym.Env): # 如果你不想改参数，下面可以不用写 metadata = &#123; 'render.modes': ['human', 'rgb_array'], 'video.frames_per_second': 2 &#125; def __init__(self): self.viewer = ringViewer(300, 400) # 600x400 是画板的长和框 self.state:list = [] self.state:list = [] def setState(self, state): self.state = state def setNewring(self, newring=None): self.newring = newring def render(self, mode='human', close=False): # 由于没有找到viewer源码中删除组件的代码,于是每次在渲染前 清空上一次geoms和onetime_geoms列表 来达到消除的目的 if self.state.any(): self.viewer.geoms.clear() self.viewer.onetime_geoms.clear() self.viewer.getQG(self.state) if self.newring: self.viewer.drawNewring(self.newring) return self.viewer.render(return_rgb_array=mode == 'rgb_array')if __name__ == '__main__': v = Testenv() while True: v.setState(np.random.randint(0,6,(27))) v.setNewring([random.randint(0,5) for x in range(3)]) print(v.state) print(v.newring) v.render() time.sleep(2) △.由于没有找到viewer源码中删除组件的代码,于是每次在渲染前 清空上一次geoms和onetime_geoms列表 来达到消除的目的 效果图如下 深入剖析gym环境构建[转] 由于该博客的代码展示实在太乱,于是重新帮他排版了一下 我们继续讲，从第1小节的尾巴开始。有三个重要的函数： env = gym.make(‘CartPole-v0’) env.reset() env.render() 第一个函数是创建环境，我们会在第3小节具体讲如何创建自己的环境，所以这个函数暂时不讲。第二个函数env.reset()和第三个函数env.render()是每个环境文件都包含的函数。我们以cartpole为例，对这两个函数进行讲解。 Cartpole的环境文件在~你的gym目录/gym/envs/classic_control/cartpole.py. 该文件定义了一个CartPoleEnv的环境类，该类的成员函数有：seed(), step(),reset()和render(). 第1小节调用的就是CartPoleEnv的两个成员函数reset()和render()。下面，我们先讲讲这两个函数，再介绍step()函数 2.1 reset()函数详解 reset()为重新初始化函数。那么这个函数有什么用呢？ 在强化学习算法中，智能体需要一次次地尝试，累积经验，然后从经验中学到好的动作。一次尝试我们称之为一条轨迹或一个episode. 每次尝试都要到达终止状态. 一次尝试结束后，智能体需要从头开始，这就需要智能体具有重新初始化的功能。函数reset()就是这个作用。 reset()的源代码为： 1234567def _reset() # 利用均匀随机分布初试化环境的状态 self.state = self.np_random.uniform(low=-0.05, high=0.05, size=(4,)) # 设置当前步数为None self.steps_beyond_done = None # 返回环境的初始化状态 return np.array(self.state) 2.2 render()函数详解 render()函数在这里扮演图像引擎的角色。一个仿真环境必不可少的两部分是物理引擎和图像引擎。物理引擎模拟环境中物体的运动规律；图像引擎用来显示环境中的物体图像。其实，对于强化学习算法，该函数可以没有。但是，为了便于直观显示当前环境中物体的状态，图像引擎还是有必要的。另外，加入图像引擎可以方便我们调试代码。下面具体介绍gym如何利用图像引擎来创建图像。 我们直接看源代码： 123456789101112131415from gym.envs.classic_control import rendering# 这一句导入rendering模块，利用rendering模块中的画图函数进行图形的绘制class myenv(gym.Env) def _render(self, mode=’human’, close=False): if close: pass #省略，直接看关键代码部分 if self.viewer is None: # 如绘制600*400的窗口函数为： self.viewer = rendering.Viewer(screen_width, screen_height) # 其中screen_width=600， screen_height=400 # 创建小车的代码为： l,r,t,b = -cartwidth/2, cartwidth/2, cartheight/2, -cartheight/2 axleoffset =cartheight/4.0 cart = rendering.FilledPolygon([(l,b), (l,t), (r,t), (r,b)]) # 其中rendering.FilledPolygon为填充一个矩形。 创建完cart的形状，接下来给cart添加平移属性和旋转属性。将车的位移设置到cart的平移属性中，cart就会根据系统的状态变化左右运动。具体代码解释，我已上传到github上面了，gxnk/reinforcement-learning-code 。想深入了解的同学可去下载学习。 2.3 step()函数详解 该函数在仿真器中扮演物理引擎的角色。其输入是动作a，输出是：下一步状态，立即回报，是否终止，调试项。 该函数描述了智能体与环境交互的所有信息，是环境文件中最重要的函数。在该函数中，一般利用智能体的运动学模型和动力学模型计算下一步的状态和立即回报，并判断是否达到终止状态。 我们直接看源代码： 12345678910111213141516def _step(self, action): assert self.action_space.contains(action), \"%r (%s) invalid\"%(action, type(action)) state = self.state x, x_dot, theta, theta_dot = state #系统的当前状态 force = self.force_mag if action==1 else -self.force_mag #输入动作，即作用到车上的力 costheta = math.cos(theta) #余弦函数 sintheta = math.sin(theta) #正弦函数 #底下是车摆的动力学方程式，即加速度与动作之间的关系。 temp = (force + self.polemass_length * theta_dot * theta_dot * sintheta) / self.total_mass thetaacc = (self.gravity * sintheta - costheta* temp) / (self.length * (4.0/3.0 - self.masspole * costheta * costheta / self.total_mass)) #摆的角加速度 xacc = temp - self.polemass_length * thetaacc * costheta / self.total_mass #小车的平移加速 x = x + self.tau * x_dot x_dot = x_dot + self.tau * xacc theta = theta + self.tau * theta_dot theta_dot = theta_dot + self.tau * thetaacc #积分求下一步的状态 self.state = (x,x_dot,theta,theta_dot) 2.4 一个简单的demo 下面，我给出一个最简单的demo，让大家体会一下上面三个函数如何使用。 1234567891011121314151617181920import gymimport timeenv = gym.make('CartPole-v0') #创造环境observation = env.reset() #初始化环境，observation为环境状态count = 0for t in range(100): action = env.action_space.sample() #随机采样动作 observation, reward, done, info = env.step(action) #与环境交互，获得下一步的时刻 if done: break env.render() #绘制场景 count+=1 time.sleep(0.2) #每次等待0.2s print(count) #打印该次尝试的步数 第3小节：创建自己的gym环境并利示例qlearning的方法 在上一小节中以cartpole为例子深入剖析了gym环境文件的重要组成。我们知道，一个gym环境最少的组成需要包括reset()函数和step()函数。当然，图像显示函数render()一般也是需要的。这一节，我会以机器人找金币为例给大家演示如何构建一个全新的gym环境，并以此环境为例，示例最经典的强化学习算法qlearning算法。在3.1节中，给出机器人找金币的问题陈述；第3.2节中，给出构建gym环境的过程；第3.3节中，利用qlearning方法实现机器人找金币的智能决策。全部代码已传到github上。 3.1 机器人找金币的问题陈述 图1.1 机器人找金币 如图1.1 为机器人在网格世界找金币的示意图。该网格世界一共有８个状态，其中状态６和状态8为死亡区域，状态７为金币区域。机器人的初始位置为网格世界中任意一个状态。机器人从初始状态出发寻找金币。机器人进行一次探索，进入死亡区域或找到金币，本次探测结束。机器人找到金币的回报为１，进入死亡区域回报为－１，机器人在区域１－５之间转换时，回报为０。我们的目标是找到一个策略使得机器人不管处在什么状态（１－５）都能找到金币。对于这个机器人找金币的游戏，我们可以利用强化学习的方法来实现。 构建网格世界的gym环境 该例子的代码,除了本篇博客有以外,OpenAI Gym构建自定义强化学习环境有更仔细和规范的代码贴出 一个gym的环境文件，其主体是个类，在这里我们定义类名为：GridEnv, 其初始化为环境的基本参数，因为机器人找金币的过程是一个马尔科夫过程，我们在强化学习入门课程的第一讲已经介绍过了一个马尔科夫过程应该包括状态空间，动作空间，回报函数，状态转移概率。因此，我们在类GridEnv的初始化时便给出了相应的定义。网格世界的全部代码在gxnk/reinforcement-learning-code,文件名为 grid_mdp.py. 我们看源代码： 12345678910111213141516171819202122# 状态空间为：self.states = [1,2,3,4,5,6,7,8]# 动作空间为： self.actions = ['n','e','s','w']# 回报函数为： self.rewards = dict(); #回报的数据结构为字典 self.rewards['1_s'] = -1.0 self.rewards['3_s'] = 1.0 self.rewards['5_s'] = -1.0# 状态转移概率为： self.t = dict(); #状态转移的数据格式为字典 self.t['1_s'] = 6 self.t['1_e'] = 2 self.t['2_w'] = 1 self.t['2_e'] = 3 self.t['3_s'] = 7 self.t['3_w'] = 2 self.t['3_e'] = 4 self.t['4_w'] = 3 self.t['4_e'] = 5 self.t['5_s'] = 8 self.t['5_w'] = 4 有了状态空间，动作空间和状态转移概率，我们便可以写step(a)函数了。这里特别注意的是，step()函数的输入是动作，输出为：下一个时刻的动作，回报，是否终止，调试信息。尤其需要注意的是输出的顺序不要弄错了。对于调试信息，可以为空，但不能缺少，否则会报错，常用{}来代替。我们看源代码： step函数的建立: 123456789101112131415161718192021def _step(self, action): #系统当前状态 state = self.state ＃判断系统当前状态是否为终止状态 if state in self.terminate_states: return state, 0, True, &#123;&#125; key = \"%d_%s\"%(state, action) #将状态和动作组成字典的键值 #状态转移 if key in self.t: next_state = self.t[key] else: next_state = state self.state = next_state is_terminal = False if next_state in self.terminate_states: is_terminal = True if key not in self.rewards: r = 0.0 else: r = self.rewards[key] return next_state, r,is_terminal,&#123;&#125; step()函数就是这么简单。下面我们重点介绍下如何写render()函数。从图1.1机器人找金币的示意图我们可以看到，网格世界是由一些线和圆组成的。因此，我们可以调用rendering中的画图函数来绘制这些图像。 render函数的建立: 整个图像是一个600*400的窗口，可用如下代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from gym.envs.classic_control import renderingself.viewer = rendering.Viewer(screen_width, screen_height)# 创建网格世界，一共包括11条直线，事先算好每条直线的起点和终点坐标，然后绘制这些直线，代码如下：#创建网格世界def render(self): self.line1 = rendering.Line((100,300),(500,300)) self.line2 = rendering.Line((100, 200), (500, 200)) self.line3 = rendering.Line((100, 300), (100, 100)) self.line4 = rendering.Line((180, 300), (180, 100)) self.line5 = rendering.Line((260, 300), (260, 100)) self.line6 = rendering.Line((340, 300), (340, 100)) self.line7 = rendering.Line((420, 300), (420, 100)) self.line8 = rendering.Line((500, 300), (500, 100)) self.line9 = rendering.Line((100, 100), (180, 100)) self.line10 = rendering.Line((260, 100), (340, 100)) self.line11 = rendering.Line((420, 100), (500, 100)) # 接下来，创建死亡区域，我们用黑色的圆圈代表死亡区域，源代码如下： # 创建第一个骷髅 self.kulo1 = rendering.make_circle(40) self.circletrans = rendering.Transform(translation=(140,150)) self.kulo1.add_attr(self.circletrans) self.kulo1.set_color(0,0,0) # 创建第二个骷髅 self.kulo2 = rendering.make_circle(40) self.circletrans = rendering.Transform(translation=(460, 150)) self.kulo2.add_attr(self.circletrans) self.kulo2.set_color(0, 0, 0) # 创建金币区域，用金色的圆来表示： # 创建金条 self.gold = rendering.make_circle(40) self.circletrans = rendering.Transform(translation=(300, 150)) self.gold.add_attr(self.circletrans) self.gold.set_color(1, 0.9, 0) # 创建机器人，我们依然用圆来表示机器人，为了跟死亡区域和金币区域不同，我们可以设置不同的颜色： # 创建机器人 self.robot= rendering.make_circle(30) self.robotrans = rendering.Transform() self.robot.add_attr(self.robotrans) self.robot.set_color(0.8, 0.6, 0.4) # 创建完之后，给11条直线设置颜色，并将这些创建的对象添加到几何中代码如下： self.line1.set_color(0, 0, 0) self.line2.set_color(0, 0, 0) self.line3.set_color(0, 0, 0) self.line4.set_color(0, 0, 0) self.line5.set_color(0, 0, 0) self.line6.set_color(0, 0, 0) self.line7.set_color(0, 0, 0) self.line8.set_color(0, 0, 0) self.line9.set_color(0, 0, 0) self.line10.set_color(0, 0, 0) self.line11.set_color(0, 0, 0) # 添加组件到Viewer中 self.viewer.add_geom(self.line1) self.viewer.add_geom(self.line2) self.viewer.add_geom(self.line3) self.viewer.add_geom(self.line4) self.viewer.add_geom(self.line5) self.viewer.add_geom(self.line6) self.viewer.add_geom(self.line7) self.viewer.add_geom(self.line8) self.viewer.add_geom(self.line9) self.viewer.add_geom(self.line10) self.viewer.add_geom(self.line11) self.viewer.add_geom(self.kulo1) self.viewer.add_geom(self.kulo2) self.viewer.add_geom(self.gold) self.viewer.add_geom(self.robot) # 接下来，开始设置机器人的位置。机器人的位置根据其当前所处的状态不同，所在的位置不同。我们事先计算出每个状态处机器人位置的中心坐标，并存储到两个向量中，并在类初始化中给出： self.x=[140,220,300,380,460,140,300,460] self.y=[250,250,250,250,250,150,150,150] # 根据这两个向量和机器人当前的状态，我们就可以设置机器人当前的圆心坐标了即： if self.state is None: return None self.robotrans.set_translation(self.x[self.state-1], self.y[self.state- 1]) # 最后还需要一个返回语句： return self.viewer.render(return_rgb_array=mode == 'rgb_array') 以上便完成了render()函数的建立 reset()函数的建立： reset()函数常常用随机的方法初始化机器人的状态，即： 123def _reset(self): self.state = self.states[int(random.random() * len(self.states))] return self.state 环境的注册 全部的代码请去github上下载学习。下面重点讲一讲如何将建好的环境进行注册，以便通过gym的标准形式进行调用。其实环境的注册很简单，只需要３步： 第一步：将我们自己的环境文件（我创建的文件名为grid_mdp.py)拷贝到你的gym安装目录/gym/gym/envs/classic_control文件夹中。（拷贝在这个文件夹中因为要使用rendering模块。当然，也有其他办法。该方法不唯一） 第二步：打开该文件夹（第一步中的文件夹）下的__init__.py文件，在文件末尾加入语句：from gym.envs.classic_control.grid_mdp import GridEnv 第三步：进入文件夹你的gym安装目录/gym/gym/envs，打开该文件夹下的__init__.py文件，添加代码： 12345678register( # gym.make(‘id’)时的id id='GridWorld-v0', # 函数路口 entry_point='gym.envs.classic_control:GridEnv', max_episode_steps=200, reward_threshold=100.0,) 第一个参数id就是你调用gym.make(‘id’)时的id, 这个id你可以随便选取，我取的，名字是GridWorld-v0 第二个参数就是函数路口了。 后面的参数原则上来说可以不必要写。 经过以上三步，就完成了注册。 下面，我们给个简单的demo来测试下我们的环境的效果吧： 我们依然写个终端程序： 12345import gymenv = gym.make('GridWorld-v0')env.reset()env.render()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"Linux安装selenium执行Python程序","slug":"Linux安装selenium执行Python程序","date":"2019-09-24T14:13:20.000Z","updated":"2022-02-13T06:14:20.178Z","comments":true,"path":"2019/09/24/Linux安装selenium执行Python程序/","link":"","permalink":"https://nymrli.top/2019/09/24/Linux安装selenium执行Python程序/","excerpt":"","text":"Linux安装selenium执行Python程序 配置python运行环境 安装selenium,pip install selenium 安装chrome 提供下载网站chromedownloads,下载google-chrome-stable_current_amd64-75.0.3770.80.deb 123456789101112$ sudo apt-get install libxss1 libappindicator1 libindicator7# 注意需要先把google-chrome-stable_current_amd64-75.0.3770.80.deb 下载下来$ sudo dpkg -i google-chrome-stable_current_amd64-75.0.3770.80.deb # 执行sudo dpkg -i google-chrome*.deb后报错的话，那就执行一下sudo apt-get install -f# 安装后在/usr/bin目录下查看是否有google-chrome文件# 检查chrome版本：$ google-chrome-stable --version# 当时无法查到版本,并报错error while loading shared libraries: libasound.so.2,# 输入sudo apt-get install -f后解决$ google-chrome-stable --version 安装chromedriver 直接按照浏览器版本去找对应的driver就行了。（如果不能完全一一对应，就找大版本号(主版本号)对应、次版本号比浏览器版本号稍大的都行）， 此外，对于windows的用户来说，win64的操作系统用win32的就行。 123456789101112$ wget -N http://chromedriver.storage.googleapis.com/75.0.3770.8/chromedriver_linux64.zip$ unzip chromedriver_linux64.zip$ sudo chmod +x chromedriver$ sudo mv -f chromedriver /usr/local/share/chromedriver$ sudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriver$ sudo ln -s /usr/local/share/chromedriver /usr/bin/chromedrive$ chromedriver -v# 如果发现版本不对，chrome可以使用这样卸载：$ yum remove google-chrome# chromedriver可以直接删除目录：$ sudo rm -f /usr/bin/chromedriver 编写python测试代码 12345678from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument('--no-sandbox')chrome_options.add_argument('--disable-dev-shm-usage')chrome_options.add_argument('--headless')browser = webdriver.Chrome(chrome_options=chrome_options)browser.get('https://www.baidu.com/') 我使用的xshell会提示我转发, 因此需要在会话中关闭该属性: 属性-&gt;连接-&gt;SSH-&gt;隧道-&gt;取消&quot;转发X11连接到&quot;的勾选 报错记录: Message: unknown error: Chrome failed to start: exited abnormally (unknown error: DevToolsActivePort file doesn't exist) (The process started from chrome location /usr/bin/google-chrome is no longer running, so ChromeDriver is assuming that Chrome has crashed.) 解决方法：添加参数chrome_options.add_argument(’–no-sandbox’) 1234567chrome_options = Options()chrome_options.add_argument('--headless')chrome_options.add_argument('--no-sandbox')chrome_options.add_argument('user-agent=%s' % random.choice(MY_USER_AGENT_PC))driver = webdriver.Chrome(executable_path='/usr/local/bin/chromedriver', chrome_options=chrome_options)driver.set_window_size(1366, 1000) # 调整页面尺寸driver.implicitly_wait(3) 更新 更新chrome ubuntu,还有其他linux下的chrome不会自动更新,因为是通过包进行管理的,想要获取最新版本的chrome可以使用下面的方法: wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 然后将安装包解压,会自动覆盖当前的chrome版本,插件什么的都不会变: 输入sudo dpkg -i ./google-chrome-stable_current_amd64.deb后会提升：Unpacking google-chrome-stable (92.0.4515.159-1) over (75.0.3770.80-1) … 更新chromedriver 在镜像网站下载合适的版本： http://npm.taobao.org/mirrors/chromedriver/ 再解压更新： 12345$ unzip chromedriver_linux64.zip$ sudo chmod +x chromedriver$ sudo mv -f chromedriver /usr/local/share/chromedriver$ sudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriver -f$ sudo ln -s /usr/local/share/chromedriver /usr/bin/chromedrive -f 附录 pyenv：Linux下多Python版本管理工具 在开发Python程序的时候，有时候可能需要在不同版本的Python上进行测试、运行。pyenv就是这么一个管理多版本Python的工具。由于在Windows中我们可以同时安装多个版本的Python，并且通过Pycharm手动选择想要版本的解释器，但是在Linux下就没那么方便了，所以这里是在Linux下介绍该工具。 安装 $ curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash Github链接：https://github.com/pyenv/pyenv-installer， 这个bash脚本中主要是得将pyenv克隆到用户目录下去，由于网络链接的问题，这个非常容易失败。我的建议是直接吧内容复制下来后写成pyenv_installer.sh文件，然后命令行运行bash pyenv_installer.sh，而不是curl -L xx |bash。 123456Cloning into &apos;/home/mrli/.pyenv&apos;...Cloning into &apos;/home/mrli/.pyenv/plugins/pyenv-doctor&apos;...Cloning into &apos;/home/mrli/.pyenv/plugins/pyenv-installer&apos;...Cloning into &apos;/home/mrli/.pyenv/plugins/pyenv-update&apos;...Cloning into &apos;/home/mrli/.pyenv/plugins/pyenv-virtualenv&apos;...Cloning into &apos;/home/mrli/.pyenv/plugins/pyenv-which-ext&apos;... 很容易失败，在调好网络链接后，能做的只有多次尝试（我花了两个半小时才下下来） 增加环境变量 123456789sudo vim ~/.bachrc# 添加以下内容export PATH=\"$HOME/.pyenv/bin:$PATH\"eval \"$(pyenv init -)\"eval \"$(pyenv virtualenv-init -)\"# 最后刷新shell: `source ~/.bashrc` or `exec $SHELL`source ~/.bashrc# 测试pyenv --help ​","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"Ubuntu16.04+CUDA toolkit10.1+cudNN7.6+bazel0.26.1","slug":"Ubuntu16-04-CUDA-toolkit10-1-cudNN7-6-bazel0-26-1","date":"2019-09-23T08:38:55.000Z","updated":"2020-12-02T11:19:32.945Z","comments":true,"path":"2019/09/23/Ubuntu16-04-CUDA-toolkit10-1-cudNN7-6-bazel0-26-1/","link":"","permalink":"https://nymrli.top/2019/09/23/Ubuntu16-04-CUDA-toolkit10-1-cudNN7-6-bazel0-26-1/","excerpt":"","text":"Ubuntu 16.04 + CUDA toolkit 10.1 + cudNN7.6 + bazel 0.26.1 保证cuDNN跟CUDA SDK的版本一致即可. 从源码编译的话需要查看显卡的计算能力,可在查看GPU计算能力，在配置的时候填入即可，跟CUDA SDK的版本无关 ▲必须注册账号后，才能选择下载 ▲记住上述几个要点， 以及最好先看下文章最后我的踩坑记录，确保自己知道可能会有这些坑 ▲.全程保持能连接外网（翻墙） 安装NVIDIA驱动 123$ ubuntu-drivers devices # 查看# 查看NVIDIA驱动版本$ sudo dpkg --list | grep nvidia-* 显卡驱动与CUDA版本对应关系 最新的根据官网查看 下载NVIDIA驱动 ▲注意:得对应匹配!!! 安装完成后，可以通过nvidia-smi查看GPU使用情况 CUDA toolkit 10.1 安装之前先看显卡的驱动版本 1234# 安装过程$ sudo dpkg -i cuda-repo-ubuntu1604-10-1-local-10.1.243-418.87.00_1.0-1_amd64.deb$ sudo apt update$ sudo apt install cuda 设置环境变量 123456$ sudo vim ~/.bashrc# 设置环境变量$ export PATH=/usr/local/cuda-8.0/bin:$PATH$ export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64:$LD_LIBRARY_PATH# 生效$ source ~/.bashrc 验证安装完成 1234$ nvcc -V$ cd /usr/local/cuda/samples/1_Utilities/deviceQuery$ sudo make$ ./deviceQuery △.如果显示Result:PASS才是安装成功。这一步一定要保证错误，不然之后bazel编译时报错就很难分析问题！！！！！(只有在驱动安装好的情况下才能运行成功,不然会报no CUDA-capable device is detected，或者GPU is lost) 如果失败,卸载重装 12$ cd /usr/local/cuda/bin$ sudo ./uninstall_cuda_9.2.pl 安装 Python 和 TensorFlow 软件包依赖项 1sudo apt install python-dev python-pip # or python3-dev python3-pip 安装 TensorFlow pip 软件包依赖项（如果使用虚拟环境，请省略 --user 参数）： 123pip install -U --user pip six numpy wheel setuptools mock future&gt;=0.17.1pip install -U --user keras_applications==1.0.6 --no-depspip install -U --user keras_preprocessing==1.0.5 --no-deps cudNN 7.6.3 选择cuDNN Library for Linux 12345678# 解压cudNN$ cp cudnn-8.0-linux-x64-v5.1.solitairetheme8 /usr/local/cuda/cudnn-8.0-linux-x64-v5.1.tgz$ cd /usr/local/cuda/$ tar -xvf cudnn-8.0-linux-x64-v5.1.tgzsudo cp cuda/include/cudnn.h /usr/local/cuda/includesudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn* Bazel 构建Tensorflow需要用bazel,而wget下载很慢,需要代理,可以试着去github上下载后再传到服务器 后来./configure配置TensorFlow时,提示Bazel版本太高…(这个问题出现在我下载的不是github下载下来的tensorflow，网盘下载的可能版本太低了) 123WARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the command \"bazel shutdown\".You have bazel 0.29.1 installed.Please downgrade your bazel installation to version 0.26.1 or lower to build TensorFlow! To downgrade: download the installer for the old version (from https://github.com/bazelbuild/bazel/releases) then run the installer. 从源码构建和安装Tensorflow 第一次安装的是2.0的版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566git clone https://github.com/tensorflow/tensorflow.gitcd tensorflow(tf) apollo3d@apollo1:~/Downloads/tensorflow-master$ ./configure WARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the command \"bazel shutdown\".You have bazel 0.26.0 installed.Please specify the location of python. [Default is /home/apollo3d/tf/bin/python]: /usr/bin/python3Found possible Python library paths: /usr/local/lib/python3.5/dist-packages /usr/lib/python3/dist-packagesPlease input the desired Python library path to use. Default is [/usr/local/lib/python3.5/dist-packages]Do you wish to build TensorFlow with XLA JIT support? [Y/n]: XLA JIT support will be enabled for TensorFlow.Do you wish to build TensorFlow with OpenCL SYCL support? [y/N]: No OpenCL SYCL support will be enabled for TensorFlow.Do you wish to build TensorFlow with ROCm support? [y/N]: No ROCm support will be enabled for TensorFlow.Do you wish to build TensorFlow with CUDA support? [y/N]: yCUDA support will be enabled for TensorFlow.Do you wish to build TensorFlow with TensorRT support? [y/N]: No TensorRT support will be enabled for TensorFlow.Found CUDA 10.1 in: /usr/local/cuda/lib64 /usr/local/cuda/includeFound cuDNN 7 in: /usr/local/cuda/lib64 /usr/local/cuda/includePlease specify a list of comma-separated CUDA compute capabilities you want to build with.You can find the compute capability of your device at: https://developer.nvidia.com/cuda-gpus.Please note that each additional compute capability significantly increases your build time and binary size, and that TensorFlow only supports compute capabilities &gt;= 3.5 [Default is: 3.5,7.0]: 5.0Do you want to use clang as CUDA compiler? [y/N]: NClang will be used as CUDA compiler.Do you wish to download a fresh release of clang? (Experimental) [y/N]: NClang will be downloaded and used to compile tensorflow.Please specify optimization flags to use during compilation when bazel option \"--config=opt\" is specified [Default is -march=native -Wno-sign-compare]: --config=v2Would you like to interactively configure ./WORKSPACE for Android builds? [y/N]: Not configuring the WORKSPACE for Android builds.Preconfigured Bazel build configs. You can use any of the below by adding \"--config=&lt;&gt;\" to your build command. See .bazelrc for more details. --config=mkl # Build with MKL support. --config=monolithic # Config for mostly static monolithic build. --config=ngraph # Build with Intel nGraph support. --config=numa # Build with NUMA support. --config=dynamic_kernels # (Experimental) Build kernels into separate shared objects. --config=v2 # Build TensorFlow 2.x instead of 1.x.Preconfigured Bazel build configs to DISABLE default on features: --config=noaws # Disable AWS S3 filesystem support. --config=nogcp # Disable GCP support. --config=nohdfs # Disable HDFS support. --config=nonccl # Disable NVIDIA NCCL support. Configuration finished 第二次1.14 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980(pythonEnv) apollo3d@apollo1:~/Downloads/tensorflow$ ./configure WARNING: Running Bazel server needs to be killed, because the startup options are different.WARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the command \"bazel shutdown\".You have bazel 0.26.0 installed.Please specify the location of python. [Default is /home/apollo3d/pythonEnv/bin/python]: Traceback (most recent call last): File \"&lt;string&gt;\", line 1, in &lt;module&gt;AttributeError: module 'site' has no attribute 'getsitepackages'Found possible Python library paths: /home/apollo3d/pythonEnv/lib/python3.5/site-packagesPlease input the desired Python library path to use. Default is [/home/apollo3d/pythonEnv/lib/python3.5/site-packages]Do you wish to build TensorFlow with XLA JIT support? [Y/n]: XLA JIT support will be enabled for TensorFlow.Do you wish to build TensorFlow with OpenCL SYCL support? [y/N]: nNo OpenCL SYCL support will be enabled for TensorFlow.Do you wish to build TensorFlow with ROCm support? [y/N]: No ROCm support will be enabled for TensorFlow.Do you wish to build TensorFlow with CUDA support? [y/N]: yCUDA support will be enabled for TensorFlow.Do you wish to build TensorFlow with TensorRT support? [y/N]: No TensorRT support will be enabled for TensorFlow.Found CUDA 10.1 in: /usr/local/cuda/lib64 /usr/local/cuda/includeFound cuDNN 7 in: /usr/local/cuda/lib64 /usr/local/cuda/includePlease specify a list of comma-separated CUDA compute capabilities you want to build with.You can find the compute capability of your device at: https://developer.nvidia.com/cuda-gpus.Please note that each additional compute capability significantly increases your build time and binary size, and that TensorFlow only supports compute capabilities &gt;= 3.5 [Default is: 5.2]: 5.0Do you want to use clang as CUDA compiler? [y/N]: nnvcc will be used as CUDA compiler.Please specify which gcc should be used by nvcc as the host compiler. [Default is /usr/bin/gcc]: Do you wish to build TensorFlow with MPI support? [y/N]: No MPI support will be enabled for TensorFlow.Please specify optimization flags to use during compilation when bazel option \"--config=opt\" is specified [Default is -march=native -Wno-sign-compare]: Would you like to interactively configure ./WORKSPACE for Android builds? [y/N]: Not configuring the WORKSPACE for Android builds.Preconfigured Bazel build configs. You can use any of the below by adding \"--config=&lt;&gt;\" to your build command. See .bazelrc for more details. --config=mkl # Build with MKL support. --config=monolithic # Config for mostly static monolithic build. --config=gdr # Build with GDR support. --config=verbs # Build with libverbs support. --config=ngraph # Build with Intel nGraph support. --config=numa # Build with NUMA support. --config=dynamic_kernels # (Experimental) Build kernels into separate shared objects.Preconfigured Bazel build configs to DISABLE default on features: --config=noaws # Disable AWS S3 filesystem support. --config=nogcp # Disable GCP support. --config=nohdfs # Disable HDFS support. --config=noignite # Disable Apache Ignite support. --config=nokafka # Disable Apache Kafka support. --config=nonccl # Disable NVIDIA NCCL support.Configuration finished...INFO: Elapsed time: 4826.834s, Critical Path: 298.31sINFO: 24978 processes: 24978 local.INFO: Build completed successfully, 26636 total actions# 大概用了一个半小时 △.期间可能多次出现ERROR:[GET returned 404 Not Found, connect timed out],继续重试即可 编译 pip 软件包 12345678910$ (tf) apollo3d@apollo1:~/Downloads/tensorflow-master$ bazel build -c --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package# -c 不链接直接编译Starting local Bazel server and connecting to it...WARNING: The following configs were expanded more than once: [cuda_clang, using_cuda, download_clang_use_lld]. For repeatable flags, repeats are counted twice and may lead to unexpected behavior.WARNING: option '--crosstool_top' was expanded to from both option '--config=cuda_clang' (source /home/apollo3d/Downloads/tensorflow-master/.tf_configure.bazelrc) and option '--config=download_clang' (source /home/apollo3d/Downloads/tensorflow-master/.tf_configure.bazelrc)$ bazel-bin/tensorfLow/tools/pip_package/build_pip_package ~/tensorflow/bin # 传入一个表示Python whell文件存储路径的参数# 在虚拟环境打开的情况下安装 附录： windows上安装cuda时一直显示不能安装，就是系统默认安装的版本太低了，或者根本就没有安装。只有到显卡驱动下载安装了驱动后，才能正常安装CUDA ▲正确安装驱动真的很重要！！！ windows安装建议 安装完linux后,我在自己笔记本上又安装了个Windows10的，两个是相通的，windows的很快我就安装好了。主要卡壳的时间全都是浪费在了驱动版本安装错误，只要把驱动的版本弄对了。然后依次安装NVIDIA驱动、CUDA、Cudnn就可以了。 采坑记录 ▲下载tensorflow，一定要从官网下载最新的。千万不要去网盘上下载，我就是被这个坑了很久。最后从github下了后才逐渐正常。（github下载会很慢，可以见我的另外一篇文章，如何提速） ▲./configure的配置也很重要，除了CUDA选项其他都选默认 Linux系统下安装TensorFlow的GPU版本 CUDA、显卡驱动和Tensorflow版本之间的对应关系 Linux x86_64 Driver Version与CUDA Toolkit的对应，一定要对应好，CUDA超出了Driver Version的话，是无法使用的^提示 ==&gt;CUDA 10.1的需要Linux x86_64 Driver Version&gt;=410.48。同时，tensorflow-gpu默认安装的是1.14版本，要求的cudNN为7，CUDA为9 ▲google.xxxx.xxxx==&gt;unknown hosts 报了这个错以后才发现，服务器的DNS没配置（云服务器一般不会出现这样的问题） 12345$ sudo vim /etc/resolv.conf# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTENnameserver 8.8.8.8nameserver 8.8.4.4 ▲An error occurred during the fetch of repository ‘llvm’:Error 404 ， cant connect 多次重试即可 1$ (tf) apollo3d@apollo1:~/Downloads/tensorflow-master$ bazel build -c --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package ▲报错 AttributeError: ‘_NamespacePath’ object has no attribute 'sort’ 重新安装setuptools 123(pythonEnv) $ pip uninstall setuptools(pythonEnv) $ pip install setuptools(pythonEnv) $ pip install googleapis-common-protos 执行上述命令需要相当长的一段时间，具体时长取决于你的计算机性能。 12345Target //tensorflow/tools/pip_package:build_pip_package up-to-date: bazel-bin/tensorflow/tools/pip_package/build_pip_packageINFO: Elapsed time: 77.892s, Critical Path: 77.18sINFO: 45 processes: 45 local.INFO: Build completed successfully, 46 total actions 待Bazel成功完成上述任务后会输出，运行输出的可执行程序，并传入一个表示Python whee文件存储路径的参数： bazel-bin/tensorflow/tools/pip_package/build_pip_package ~/ 12345678910111213141516(pythonEnv) apollo3d@apollo1:~/Downloads/tensorflow$ bazel-bin/tensorflow/tools/pip_package/build_pip_package ~/2019年 09月 24日 星期二 14:34:05 CST : === Preparing sources in dir: /tmp/tmp.pguTqrHuLA~/Downloads/tensorflow ~/Downloads/tensorflow~/Downloads/tensorflow/tmp/tmp.pguTqrHuLA/tensorflow/include ~/Downloads/tensorflow~/Downloads/tensorflow2019年 09月 24日 星期二 14:34:11 CST : === Building wheelwarning: no files found matching &apos;*.pyd&apos; under directory &apos;*&apos;warning: no files found matching &apos;*.pd&apos; under directory &apos;*&apos;warning: no files found matching &apos;*.dylib&apos; under directory &apos;*&apos;warning: no files found matching &apos;*.dll&apos; under directory &apos;*&apos;warning: no files found matching &apos;*.lib&apos; under directory &apos;*&apos;warning: no files found matching &apos;*.csv&apos; under directory &apos;*&apos;warning: no files found matching &apos;*.h&apos; under directory &apos;tensorflow_core/include/tensorflow&apos;warning: no files found matching &apos;*&apos; under directory &apos;tensorflow_core/include/third_party&apos;2019年 09月 24日 星期二 14:34:33 CST : === Output wheel file is in: /home/apollo3d/ pip安装 上述命令将在~/tensorlowbn下创建一个Python.wh文件。请确保你的“tensor-fow Virtualenv不境处于活动状态，然后用pip安装该whee文件（请注意该二进制文件的具体名称会依所安装的TensorFlow版本、所使用的操作系统和Python版本而不同）： (pythonEnv) apollo3d@apollo1:~$ pip install tensorflow-2.0.0rc2-cp35-cp35m-linux_x86_64.whl ▲安装成功后，使用时报错 使用TensorFlow时报错FutureWarning: Passing (type, 1) or ‘1type’ as a synonym of type is deprecated; in a future version of numpy… 报错原因：numpy1-17-0版本过高，使用numpy-1.16-0版本即可 解决方法：重新安装numpy-1.16-0 12$ pip uninstall numpy$ pip install numpy==1.16.0 anaconda使用 最近用了老师给的服务器，用户是隔离的，因此还是决定使用anaconda省事点 安装anaconda：进入官网https://www.anaconda.com/products/individual， 然后根据os选择相应的package下载 conda常用命令 123conda list 查看安装了哪些包。conda env list 或 conda info -e 查看当前存在哪些虚拟环境conda update conda 检查更新当前conda 创建虚拟环境 1conda create -n 虚拟环境名 python=3.6 激活虚拟环境 1234linux: source activate your_env_name(虚拟环境名称)windows: activate your_env_name(虚拟环境名称) 虚拟环境中安装额外的包 1conda install -n your_env_name [package] 关闭虚拟环境 123Linux: source deactivateWindows: deactivate 配置国内镜像 1234conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/freeconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/mainconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda conda config --set show_channel_urls true 按照网上的教程会让添加：conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge，但我加了创建环境报错conda.core.subdir_data.Response304ContentUnchanged，按网上教程conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge 1234567# http://Anaconda.org的服务器在国外，安装多个packages时，conda下载的速度经常很慢。清华TUNA镜像源有Anaconda仓库的镜像，将其加入conda的配置即可：# 添加Anaconda的TUNA镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/# TUNA的help中镜像地址加有引号，需要去掉# 设置搜索时显示通道地址conda config --set show_channel_urls yes","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"Github下载、访问慢解决方法[转]","slug":"Github下载、访问慢解决方法-转","date":"2019-09-23T08:36:21.000Z","updated":"2019-09-29T09:38:38.048Z","comments":true,"path":"2019/09/23/Github下载、访问慢解决方法-转/","link":"","permalink":"https://nymrli.top/2019/09/23/Github下载、访问慢解决方法-转/","excerpt":"","text":"Github下载、访问慢解决方法[转] 下载tensorflow就16KiB/s,改完后能有900+KiB/s 修改hosts 1234567891011121314151617151.101.44.249 github.global.ssl.fastly.net192.30.253.113 github.com103.245.222.133 assets-cdn.github.com23.235.47.133 assets-cdn.github.com203.208.39.104 assets-cdn.github.com204.232.175.78 documentcloud.github.com204.232.175.94 gist.github.com107.21.116.220 help.github.com207.97.227.252 nodeload.github.com199.27.76.130 raw.github.com107.22.3.110 status.github.com204.232.175.78 training.github.com207.97.227.243 www.github.com185.31.16.184 github.global.ssl.fastly.net185.31.18.133 avatars0.githubusercontent.com185.31.19.133 avatars1.githubusercontent.com192.30.253.120 codeload.github.com windows更新:ipconfig /flushdns linux重启网络服务:service network restart&lt;===&gt;/etc/init.d/networking restart(两个都没尝试) 我重新打开终端就行了","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"},{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"同性交友网站Github的骚操作","slug":"同性交友网站Github的骚操作","date":"2019-09-21T03:56:19.000Z","updated":"2020-09-15T02:57:33.475Z","comments":true,"path":"2019/09/21/同性交友网站Github的骚操作/","link":"","permalink":"https://nymrli.top/2019/09/21/同性交友网站Github的骚操作/","excerpt":"","text":"做好看的REAMDE 123456789101112131415161718&lt;p align=\"center\"&gt; &lt;a href=\"https://travis-ci.com/xkcoding/spring-boot-demo\"&gt;&lt;img alt=\"Travis-CI\" src=\"https://travis-ci.com/xkcoding/spring-boot-demo.svg?branch=master\"/&gt;&lt;/a&gt; &lt;a href=\"https://www.codacy.com/app/xkcoding/spring-boot-demo?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=xkcoding/spring-boot-demo&amp;amp;utm_campaign=Badge_Grade\"&gt;&lt;img alt=\"Codacy\" src=\"https://api.codacy.com/project/badge/Grade/1f2e3d437b174bfc943dae1600332ec1\"/&gt;&lt;/a&gt; &lt;a href=\"https://xkcoding.com\"&gt;&lt;img alt=\"author\" src=\"https://img.shields.io/badge/author-Yangkai.Shen-blue.svg\"/&gt;&lt;/a&gt; &lt;a href=\"https://www.oracle.com/technetwork/java/javase/downloads/index.html\"&gt;&lt;img alt=\"JDK\" src=\"https://img.shields.io/badge/JDK-1.8.0_162-orange.svg\"/&gt;&lt;/a&gt; &lt;a href=\"https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/html/\"&gt;&lt;img alt=\"Spring Boot\" src=\"https://img.shields.io/badge/Spring Boot-2.1.0.RELEASE-brightgreen.svg\"/&gt;&lt;/a&gt; &lt;a href=\"https://github.com/xkcoding/spring-boot-demo/blob/master/LICENSE\"&gt;&lt;img alt=\"LICENSE\" src=\"https://img.shields.io/github/license/xkcoding/spring-boot-demo.svg\"/&gt;&lt;/a&gt; &lt;/p&gt;&lt;p align=\"center\"&gt; &lt;a href=\"https://github.com/xkcoding/spring-boot-demo/stargazers\"&gt;&lt;img alt=\"star\" src=\"https://img.shields.io/github/stars/xkcoding/spring-boot-demo.svg?label=Stars&amp;style=social\"/&gt;&lt;/a&gt; &lt;a href=\"https://github.com/xkcoding/spring-boot-demo/network/members\"&gt;&lt;img alt=\"star\" src=\"https://img.shields.io/github/forks/xkcoding/spring-boot-demo.svg?label=Fork&amp;style=social\"/&gt;&lt;/a&gt; &lt;a href=\"https://github.com/xkcoding/spring-boot-demo/watchers\"&gt;&lt;img alt=\"star\" src=\"https://img.shields.io/github/watchers/xkcoding/spring-boot-demo.svg?label=Watch&amp;style=social\"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p align=\"center\"&gt; &lt;span&gt;中文 | &lt;a href=\"./README.en.md\"&gt;English&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 项目条幅 Q: Github 上各式各样的小徽章从何而来? A: Substats 和 Shields.io Shields.io语法规则 : ![{左半部分标签}](https://img.shields.io/badge/{左半部分标签}-{右半部分标签}-{右半部分颜色}), 效果如下 Substats 对动态徽章支持的更好! 1234[![Stargazers](https://img.shields.io/github/stars/NJUPTFreeExams/NJUPT-CS-Free-Exams.svg?style=for-the-badge)](https://github.com/NJUPTFreeExams/NJUPT-CS-Free-Exams/stargazers)[![Forks](https://img.shields.io/github/forks/NJUPTFreeExams/NJUPT-CS-Free-Exams.svg?style=for-the-badge)](https://github.com/NJUPTFreeExams/NJUPT-CS-Free-Exams/network/members)[![cloed prs](https://img.shields.io/github/issues-pr-closed-raw/NJUPTFreeExams/NJUPT-CS-Free-Exams.svg?style=for-the-badge)](https://github.com/NJUPTFreeExams/NJUPT-CS-Free-Exams/pulls)! sponsors资助者: opencollective——https://opencollective.com/ 贡献者名单 123456789101112131415161718192021## 贡献者名单&lt;a href=\"https://github.com/imguozr\"&gt; &lt;img src=\"https://avatars1.githubusercontent.com/u/30227124?v=4\" width=\"50px\"&gt;&lt;/a&gt;&lt;a href=\"https://github.com/Wonz5130\"&gt; &lt;img src=\"https://avatars1.githubusercontent.com/u/35889526?v=4\" width=\"50px\"&gt;&lt;/a&gt;&lt;a href=\"https://github.com/Wen-He\"&gt; &lt;img src=\"https://avatars0.githubusercontent.com/u/18651139?v=4\" width=\"50px\"&gt;&lt;/a&gt;&lt;a href=\"https://github.com/chenkangyang\"&gt; &lt;img src=\"https://avatars2.githubusercontent.com/u/28588778?v=4\" width=\"50px\"&gt;&lt;/a&gt;&lt;a href=\"https://github.com/Davont\"&gt; &lt;img src=\"https://avatars0.githubusercontent.com/u/28757633?v=4\" width=\"50px\"&gt;&lt;/a&gt; 中英文Readme 由于Github会默认展示当前目录下的README.md，因此README.md中的内容为默认语言即可。 而需要提供其他语言版本的README，需要额外创建markdown文件， 然后通过超链接切换。e.g.默认英文，则REAMDE.md中用英文做介绍，同时再创一个中文的README-zh_CN.md即可。 Copy README 授人鱼不如授人以渔 Q：别人的REAMDE都那么炫酷，怎么办呢？ A:点击他人的README.md文件，然后显示Raw就能看到html辣，由于markdown语法是支持嵌入html，因此只要把结构复制、改下内容就成了。 收藏的好看的REAMDE ant-design-vue shield教程： 附录 单击列表 当提Issue的时候，总会贴很长的代码，有没有什么办法美观一点呢，方法如下 12345&lt;details&gt;&lt;summary&gt;Content of debug log&lt;/summary&gt;&lt;pre&gt;Paste content here ...&lt;/pre&gt;&lt;/details&gt; 效果如下","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"搭建Jupyter、JupyterLab服务器","slug":"搭建Jupyter服务器","date":"2019-09-21T01:53:01.000Z","updated":"2020-12-05T06:22:02.798Z","comments":true,"path":"2019/09/21/搭建Jupyter服务器/","link":"","permalink":"https://nymrli.top/2019/09/21/搭建Jupyter服务器/","excerpt":"","text":"搭建Jupyter服务器 1.配置好Python环境及安装pip 2.安装jupyter: pip3 install jupyter (此处使用的是python3) 3.生成配置文件 jupyter notebook --generate-config 4.生成密钥: 终端输入$ ipython 123456In [1]: from notebook.auth import passwdIn [2]: passwd()Enter password: Verify password: #此时会让你两次输入密码，然后就会生成秘钥#＊＊＊＊＊＊＊＊＊＊＊＊ 5.修改配置文件vim ~/.jupyter/jupyter_notebook_config.py 1234567c=get_config()c.IPKernelApp.pylab =\"inline\"c.NotebookApp.ip='*' # 设置所有ip皆可访问c.NotebookApp.password = 'sha1:x' # 刚生成的密文c.NotebookApp.open_browser = False # 禁止自动打开浏览器c.NotebookApp.port = 9999 # 指定运行端口c.NotebookApp.notebook_dir = '/home/apollo3d/tf/jupyter_home' # 指定Jupyter的工作目录 拓展:云服务器搭建神器JupyterLab(转) JupyterLab是一个交互式的开发环境，其用于应对包含着notebook、代码以及数据的工作场景。 1、前言 如果说vim是编辑器之神，那么JupyterLab就是笔记本之神。 从2017年开始我注意到这一神奇的IDE笔记本，第一眼见到它，就觉得它真的太强大了，作为一个交互式的Python开发工具，其实也不算开发工具，准确的来说，它是一个演示代码的科学数据工具，支持markdown预览，支持Draw扩展，支持丰富的文件格式和多种开发语言，拥有众多插件诸于GitHub， Google-Dirve， Git和TOC，更重要的是，它是把浏览器当作开发工具，十分有创意。JupyterLab的开发者众多，GitHub上面的isuue也十分活跃，众多的大牛开发者也纷纷加入到JupyterLab的阵营，为JupyterLab的发展作贡献，JupyterLab得到迅速发展。 好的工具当然是要好好利用了，回归正题，怎样通过云服务器搭建一个可远程使用的JupyterLab? 2、添加ppa源 1234root@iZwz9huxtbd86xp91s3j16Z:~# sudo add-apt-repository ppa:chronitis/jupyter$ sudo: add-apt-repository: command not found# 出现这种情况,可以如下解决# $ sudo apt-get install software-properties-common 3、配置python 123456$ sudo apt-get install python-pip python-dev build-essential $ sudo pip install --upgrade pip # $ sudo pip install --upgrade virtualenv #安装虚拟环境# 升级pip$ sudo pip3 install --upgrade pip$ sudo pip2 install --upgrade pip 如果没有换源,先进行换源,下载速度会快很多 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 123cat &gt; ~/.pip/pip.conf[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple npm和yarn也可以换源，更简单，自行google。 pip国内的一些镜像包,换源之后出现python2版本过低的情况导致以前的包下载不了，那就直接将文件夹~/.pip/pip.conf删除就可以恢复原来的源。 pip指向问题 有时候会出现pip,pip2,pip3都TM指向python2，这个之后就需要改一下这这三个文件。 编辑这三个文件，将第一行注释分别改为python\\python2\\python3 12345678~ $which pip/usr/local/bin/pip21:36 alien@alien-Inspiron-3443:~ $which pip2/usr/local/bin/pip221:36 alien@alien-Inspiron-3443:~ $which pip3/usr/local/bin/pip3 安装yarn和nodejs 配置仓库 12curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -echo \"deb https://dl.yarnpkg.com/debian/ stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list 安装yarn 123sudo apt-get updatesudo apt-get install yarn# 如果这边安装后,报错NameError: name 'CoreConfig' is not defined,那么需要更新nodejs版本 注意这里yarn自动安装了nodejs，不过版本太低，安装jupyterlab的时候会出问题，而且使用n或者nvm安装的nodejs也有问题，总之nodejs要按照下面这种方式就没事，这个是官方的bug，官方issue也提到过，但是目前还未解决。 如果版本过低,安装插件、或是jupyter lab build发生NameError: name 'CoreConfig' is not defined错误,则可能是nodejs版本过低导致.我出现这个Bug后找了提了issue也没解决,后来突然想起了这边提到的nodejs版本问题,于是更新后解决…nodejs更新方式见附录 安装nodejs 创建一个新文件，输入两行deb，结束之后Ctrl+C: 123cat &gt; /etc/apt/sources.list.d/nodesource.listdeb https://deb.nodesource.com/node_6.x xenial maindeb-src https://deb.nodesource.com/node_6.x xenial main 导入公匙并安装nodejs，这个版本的nodejs对jupyterlab支持比较友好。 123456789101112131415161718192021curl -s https://deb.nodesource.com/gpgkey/nodesource.gpg.key | sudo apt-key add -sudo apt-get updateapt-cache policy nodejssudo apt-get install nodejsnodejs --version​```shell#### 安装`ipython,matplotlib,scipy,pandas,numpy`最好`python2`和`python3`都安装。## 安装`JupyterLab`及其配置&gt; 配置同上文Jupyter配置​```shell# 安装sudo pip3 install jupyterlab# 生成密码jupyter-notebook password 创建哈希密码 12345from notebook.auth import passwdpasswd()# 输入你自己设置登录JupyterLab界面的密码，# 然后就会生产下面这样的密码，将它记下来，待会儿用'sha1:b92f3fb7d848:a5d40ab2e26aa3b296ae1faa17aa34d3df351704' 修改JupyterLab配置文件 先生成一个配置文件，记下输出的配置文件地址 jupyter lab --generate-config-&gt; 123456c.NotebookApp.allow_root = True #允许以root方式运行jupyterlabc.NotebookApp.ip = '0.0.0.0' #允许任意ip段访问c.NotebookApp.notebook_dir = u'/root/JupyterLab' # 设置jupyterlab页面的根目录c.NotebookApp.open_browser = False#默认运行时不启动浏览器，因为服务器默认只有终端c.NotebookApp.password = u'sha1:b92f3fb7d848:a5d40ab2e26aa3b296ae1faa17aa34d3df351704'#设置之前生产的哈希密码c.NotebookApp.port = 8080#设置访问端口 到此，JupyterLab已经安装成功了。 12345678$ jupyter-lab --version&gt;&gt;&gt; 0.33.12$ jupyter lab build# build没成功，可以看看是不是内存限制，试试下面的命令# cross-env NODE_OPTIONS=--max_old_space_size=4096 webpack --config webpack.prod.minimize.config.jserror Command failed with exit code 1.\"\"\"# jupyter lab build --minimize=False jupyter lab build时间有点久，如果没报错就成功了 4、运行JupyterLab 1$ jupyter lab &amp; JupyterLab运行虚拟环境 在jupyter lab中使用虚拟环境 进入虚拟环境后输入以下代码，则在jupyter中创建出虚拟环境(env_name)下的kernel 12pip install ipykernelpython -m ipykernel install --user --name env_name 删除创建的kernel CMD窗口下打开jupyter lab后若要关闭，Ctrl+C；也可在jupyter lab中打开终端输入命令，但此时输入退出/打开虚拟环境命令(deactivate/workon等)是无效的，即始终处在虚拟环境中 12jupyter kernelspec list #查看所有kerneljupyter kernelspec remove kernel_name #卸载kernel_name JupyterLab扩展安装 1234567jupyter labextension list # 查看已经安装的扩展及其状态：jupyter labextension install @mflevine/jupyterlab_html # 比如安装一个扩展jupyterlab_html，支持html预览:jupyter labextension uninstall @mflevine/jupyterlab_html #卸载扩展:jupyter labextension update --all #更新所有扩展:# 安装一个生成目录的插件jupyter labextension install @jupyterlab/toc 还有功能 支持做图 markdown 多标签 内部打开网页 latex 快捷键 编辑模式命令 执行当前cell，执行后不自动调转到下一个cell：Ctrl-Enter 使当前的cell进入编辑模式：Enter 退出当前cell的编辑模式：Esc 命令模式: 删除当前的cell：双D 为当前的cell加入line number：单L 将当前的cell转化为具有一级标题的maskdown：单1 将当前的cell转化为具有二级标题的maskdown：单2 将当前的cell转化为具有三级标题的maskdown：单3 撤销对某个cell的删除：z 浏览器的各个Tab之间切换：Up和Dn 附录 jupyter notebook设置一个执行单元多个输出 12from IPython.core.interactiveshell import InteractiveShellInteractiveShell.ast_node_interactivity = \"all\" nodejs更新 1234567891011# 查看更新前的版本$ node -vv4.2.1$ sudo npm cache clean -f$ sudo npm install -g n$ sudo n stable # 软链接,VERSION改成新的版本(删了后按TAB键)$ sudo ln -sf /usr/local/n/versions/node/&lt;VERSION&gt;/bin/node /usr/bin/nodejs# 查看是否更新成功$ node -vv10.16.3 安装内核 安装Python内核 如果需要python2和python3同时存在的话 12345678$ sudo pip2 install ipykernel$ sudo pip3 install ipykernel# 查看已经安装的内核jupyter kernelspec list# 删除你不需要的内核$ jupyter kernelspec remove &lt;kernel_name&gt;/root/JupyterLab 安装ijavascript 12345sudo add-apt-repository ppa:chronitis/jupytersudo apt-get updatesudo apt-get install ijavascript# ihaskell、ijulia、irkernel、iruby# https://github.com/jupyter/jupyter/wiki/Jupyter-kernels 插件安装 jupyterlab-toc(目录功能) Installation 1jupyter labextension install @jupyterlab/toc Jupyterlab-Tensorboard Installation 1$ jupyter labextension install jupyterlab_tensorboard ](http://image.rexking6.top/img/clip1545289922.png) JupyterLab drawio(processon图) Installation 1jupyter labextension install jupyterlab-drawio 注,图片来自RexKing6’s Note variableinspector 像matlab一样查看工作区变量 jupyter labextension install @lckr/jupyterlab_variableinspector go_to_definition插件 在lab中按alt+ 点击变量名 or 函数名，可以跳转到其对应的最初定义的地方(注意看闪烁光标的位置变化)。 快捷键 Up : 选中上方单元 K : 选中上方单元 Down : 选中下方单元 J : 选中下方单元 Shift-K : 扩大选中上方单元 Shift-J : 扩大选中下方单元 A : 在上方插入新单元 B : 在下方插入新单元 X : 剪切选中的单元 C : 复制选中的单元 Shift-V : 粘贴到上方单元 V : 粘贴到下方单元 Z : 恢复删除的最后一个单元 D,D : 删除选中的单元 Shift-M : 合并选中的单元 I,I : 中断Notebook内核0,0 0,0 :重启Notebook内核 Tab : 代码补全或缩进 Shift-Tab : 提示 Ctrl-] : 缩进 Ctrl-[ : 解除缩进 Ctrl-A : 全选 Ctrl-Z : 复原 Ctrl-Shift-Z : 再做 Ctrl-Y : 再做 Ctrl-Home : 跳到单元开头 Ctrl-Up : 跳到单元开头 Ctrl-End : 跳到单元末尾 Ctrl-Down : 跳到单元末尾 Ctrl-Left : 跳到左边一个字首 Ctrl-Right : 跳到右边一个字首 Ctrl-Backspace : 删除前面一个字 Ctrl-Delete : 删除后面一个字 Esc : 进入命令模式 Ctrl-M : 进入命令模式 Shift-Enter : 运行本单元，选中下一单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在下面插入一单元 Ctrl-Shift-- : 分割单元 Ctrl-Shift-Subtract : 分割单元 Ctrl-S : 文件存盘 Shift : 忽略 Up : 光标上移或转入上一单元 Down :光标下移或转入下一单元","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"深度学习","slug":"深度学习","date":"2019-09-19T12:32:44.000Z","updated":"2021-11-26T12:31:04.502Z","comments":true,"path":"2019/09/19/深度学习/","link":"","permalink":"https://nymrli.top/2019/09/19/深度学习/","excerpt":"","text":"深度学习——神经网络 构建网络的总原则 一、增大网络容量，直到过拟命 二、采取措施抑制过拟合 三、继续增大网络容量，直到过拟合 线性回归 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-# Commented out IPython magic to ensure Python compatibility.import kerasimport numpy as npimport matplotlib.pyplot as plt# %matplotlib inlinex = np.linspace(0,80,50)y = 3*x + np.random.randn(50)*15# print(x,y,sep='\\n')plt.scatter(x,y)from keras import layers# 初始化模型model = keras.Sequential()# 增加一层：全连接层model.add(layers.Dense(1,input_dim=1))model.summary()# 编译模型model.compile(optimizer='adam', loss='mse')# 训练模型# 方法一model.fit(x,y,epochs=2000)# 方法二#for setp in range(3001):# cost = model.train_on_batch(x_data,y_data)# if step % 500 == 0:# print('cost:',cost)#w,b = model.layers[0].get_weights()predict_y = model.predict(x)plt.scatter(x,y,s=10,c='r')plt.plot(x,predict_y) 非线性回归 激活函数 softmax Si=ei∑jejS_{i}=\\frac{e^{i}}{\\sum_{j} e^{j}}Si​=∑j​ejei​ sigmod: logistic: 范围是[0,1] f(t)=etet+1=11+e−tf(t)=\\frac{\\mathrm{e}^{t}}{\\mathrm{e}^{t}+1}=\\frac{1}{1+\\mathrm{e}^{-t}}f(t)=et+1et​=1+e−t1​ reLU f(x)=max(0,x)f(x)=max(0,x)f(x)=max(0,x) tanh 跟sigmoid函数很像,但是范围是[-1,1],而不是[0,1],实质是sigmoid函数平移 tanh⁡(x)=sinh⁡xcosh⁡x=ex−e−xex+e−x\\tanh(x)=\\frac{\\sinh x}{\\cosh x}=\\frac{e^{x}-e^{-x}}{e^{x}+e^{-x}}tanh(x)=coshxsinhx​=ex+e−xex−e−x​ TensorFlow中其他的函数： ●tf.nn.elu(x)： 指数线性单元； 如果输入小于0， 返回exp(x)-1； 否 则， 返回x； ●tf.softsign(x)： 返回x/(abs(x)+1)； ●tf.nn.bias_add(value,bias)： 增加一个bias到value。 Tensorflow: 张量——数据 : 多维数组,阶:张量的维数 计算图——神经网络 搭建神经网络的计算过程,只搭建,不运算 会话——执行计算图===&gt;优化线上的权重====&gt;权重 神经网络实现过程 1.准备数据集,提取特征,作为输入 2.搭建NN结构,从输入到输出==&gt;(NN前向传播) 3.大量特征数据喂给NN,迭代优化NN参数==&gt;(NN反向传播) 4.使用训练好的模型预测和分类 &gt;八股:准备,前传,后传,迭代&lt; 12x = tf.placehold(tf.float32,shape=(1,2)) #占位符sess.run(要计算的节点,feed_dict=&#123;x:[[1.3,2.0]]&#125;) 12Init_op = tf.global_variables_initializer()sess.run(Init_op) y = matmul(x,w1)`相乘 《TensorFlow机器学习项目实战》笔记 张量 TensorFlow基于张量数据管理。 张量是数学领域的概念， 并且被开 发为向量和矩阵的线性代数项的泛化。 一个张量就是一个张量类的实例， 是绑定了相关运算的一个特定类型的多维数组。 张量的属性 有一个静态的类型和动态的维数 只有张量类型的对象才能在计算图的节点中 传递。 秩rank 数据类型type 形状shape numpy数组到TensorFlow张量 TensorFlow与numpy是可互操作的， 通常调用eval()函数会返回 numpy对象。因为张量对象只是一个操作结果的符号化句柄， 所以它并不持有该操作的结果 ,必须使用eval()方法来获得实际的 值 12345678import tensorflow as tf #we import tensorflowimport numpy as np #we import numpysess = tf.Session() #start a new Session Objectx_data = np.array([[1.,2.,3.],[3.,2.,6.]]) # 2x3 matrixx = tf.convert_to_tensor(x_data,dtype=tf.float32) #Finally, we create the#tensor, starting from the fload 3x matrix tf.convert_to_tensor``： 该方法将Python对象转化为tensor对象。 它的 输入可以是tensor对象、 numpy数组、 Python列表和Python标量。 数据流图(data flow graph) 数据流图是完整的TensorFlow计算 节点(node) 表示操作(operation) ,实现数学运算， 同时也表示数据或变量的供给(feed) ， 或输出结果 。一旦其输入边缘上的所有张量都到位， 则开始异步地并行执行 边(edge) 表示各操作之间流通的数据 ,描述节点之间的输入/输出关系。 这些数据边缘专门传输张量 计算图(computation graph) 由用户在创建张量(tensor) 和操作(op 有用的操作对象方法如下： ●tf.Operation.type： 返回操作的类型(例如， MatMul) ； ●tf.Operation.inputs： 返回表示操作的输入张量对象列表； ●tf.Graph.get_operations()： 返回计算图中的操作列表； ●tf.Graph.version： 返回计算图的版本信息。 变量 正如字面意思所示,是个变化的量。在TensorFlow具体表现为需要更新的参数 在大多数计算中， 会多次执行计算图。 大多数张量的生存周期不会 超过单次执行周期。 然而， 变量是一种特殊的操作， 它返回一个持久 的、 可变的张量的句柄， 存活于多次计算图执行之中。 对于TensorFlow 的机器学习应用， 模型的参数通常存储在变量中， 并且在运行模型的训 练阶段被更新。 placehold 给之后喂给的数据占位 会话 客户端程序通过创建会话(Session)与TensorFlow系统交互。 Session对象是运行环境的表示。Session对象开始为空，当程序员创建不同的操作和张量时，它们将被自动添加到Session，直到Run方法被调用，才开始运算。 Run方法输入是需要计算的操作，以及一组可选的张量，用来代替图中某些节点的输出。 如果我们调用这个方法，并且有命名操作所依赖的操作，Session对象将执行所有这些操作，然后继续执行命名操作。 用以下简单的代码可以创建一个会话： s=tf.Session() 矩阵运算 转置、 乘法、 获取行列式和逆 1234tf. transpose(x). eval()# Transposetf. matmul(x,y). eval()# Matrixtf. matrix determinant(floatx). eval()# 行列式tf.matrix_inverse(floatx).eval() # 求逆 约简(reduction) 是一种跨维度张量操作， 计算结果比原张量缩减 一个维度。 12345678910111213141516171819202122In [1]: import tensorflow as tf In[2]: sess=tf. InteractiveSession()In[3]:x=tf. constant([[1,2,3], [3,2,1], [-1,2,-3]])In[5]: tf.reduce_prod(x, reduction_indices=1). eval() # reduce prod,行操作,0为列操作 0ut[5]: array([6,6,-6], dtype=int32)In [6]: tf. reduce_min(x, reduction_indices=1). eval()# reduce min 0ut[6]: array([1,1,-3], dtype=int32)In [7]: tf. reduce_max(x, reduction_indices=1). eval()# reduce max 0ut[7]: array([3,3,-1], dtype=int32)In [8]: tf. reduce_mean(x, reduction indices=1). eval()# reduce mean 0ut[8]: array([ 2,2,-2], dtype=int32) In[9]: tf. reduce_all(boolean_tensor, reduction_indices=1). eval()# reduce all Out[9]: array([ False, False, False], dtype=bool)In [10]: tf. reduce_any(boolean_tensor, 序列实用程序包括诸如argmin和argmax(显示维度的最小和最大 值) ， listdiff(显示列表之间的交集的补码) ， where(显示张量上的真 实值的索引) 和unique(在列表上去除重复的元素) 。 1234567891011121314151617181920212223import tensorflow as tf sess=tf. InteractiveSession()x=tf. constant([[2,5,3,-5],…:[0,3,-2,5],……:[4,3,5,3],…:[6,1,4,0jj)listx=tf. constant([1,2,3,4,5,6,7,8])listy=tf. constant([4,5,8,9])boolx=tf. constant([[ True, False],[ False, True]]) tf. argmin(x,1). eval()# Position of the maximum value of columns&gt;&gt;&gt; array([3,2,1,3]) tf. argmax(x,1). eval()# Position of the minimum value of rows&gt;&gt;&gt; array([1,3,2,0]) tf. listdiff(listx, listy)[0]. eval()#List differences&gt;&gt;&gt; array([1,2,3,6,7], dtype=int32) tf.where(boolx). eval()# Show true values&gt;&gt;&gt; array([[o,0],[1,1]]) tf. unique(listx)[0]. eval()# Unique values in list&gt;&gt;&gt; array([1,2,3,4,5,6,7,8], dtype=int32) 形状变换 : 例如squeeze和expand_dims。 1234567891011121314151617181920212223242526272829303132333435In [1]: import tensorflow as tf In [2]: sess=tf. InteractiveSession()In [3]:x=tf. constant([[2,5,3,-5], ……:[0,3,-2,5], …:[4,3153, …:[6,1,4,0]])tf. shape(x). eval()# Shape of the tensor&gt;&gt;&gt; array([4,4], dtype=int32)tf. size(x). eval()# size of the tensor&gt;&gt;&gt;16tf. rank(x). eval()# rank of the tensor&gt;&gt;&gt;2tf. reshape(x,[8,2]). eval()#converting to a 10×2 matrix&gt;&gt;&gt;array([[ 2,5],[3,-5],[0,3],[-2,5],[1,4],[3,1],[5,3],[6,1],[4,0]], dtype=int32)tf. squeeze(x). eval()# squeezing&gt;&gt;&gt; array([[ 2,5,3,-5],[0,3,-2,5],4,3,5,3],[6,1,4,0]], dtype=int32)tf. expand_dims(x,1). eval()# Expanding dims&gt;&gt;&gt;array([[[ 2,5,3,-5]],[[ 0,3,-2,5]],[[4,3,5,3]],[i 6,1,4,0jji, dtype=int32) 切片(slicing) 和连接(joining) :提取矩阵切片、 拆分、 添加填充(add padding) ， 以及打包(pack) 和解包(unpack) 行。 123456789101112131415161718192021222324252627282930313233343536373839404142import tensorflow as tf sess=tf. InteractiveSession()t_matrix=tf. constant([[1,2,3], ……:[4,5,6], …:[7,8,9]])t_array=tf. constant([1,2,3,4,9,8,6,5])t array2=tf. constant([2,3,4,5,6,7,8,9]) tf. slice(t _matrix,[1,1],[2,2]). eval()# cutting an slice&gt;&gt;&gt;array([[5,6],[8,9]], dtype=int32)tf. split(0,2,t_array)# splitting the array in two&gt;&gt;&gt;[&lt;tf. Tensor ' split:0' shape=(4,) dtype=int32&gt;,&lt;tf. Tensor ' split:1' shape=(4,) dtype=int32&gt;]tf. tile([1,2],[3]). eval()# tiling this little tensor 3 times重复&gt;&gt;&gt; array([1,2,1,2,1,2], dtype=int32)tf. pad(t_matrix,[[0,1],[2,1]]). evai()#padding&gt;&gt;&gt; array(i[o,o,1,2,3,0],[0,0,4,5,6,0],[o.0.7.8.9.01.[o,o,o,0,0,0]], dtype=int32)tf. concat(0,[t_array, t_array2]). eval()# concatenating list&gt;&gt;&gt; array([1,2,3,4,9,8,6,5,2,3,4,5,6,7,8,9], dtype=int32)tf. pack([t_array,t_array2]). eval()# packing 拼接0ut[11]:array([[1,2,3,4,9,8,6,5],[2,3,4,5,6,7,8,9]], dtype=int32) sess.run(tf. unpack(t_matrix))#Unpacking, we need the run method to view the tensors&gt;&gt;&gt;[array([1,2,3],dtype=int32),array([4,5,6],dtype=int32),array([7,8,9];dtype=int32) In [13]: tf. reverse(t_matrix,[ False, True]). eval()# Reverse matrix,行不变,列反转0ut[13]: array([[3,2,1],[6,5,41;9,8,7]], dtype=int32) 从磁盘读取信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 列表格式——CSV import tensorflow as tfsess=tf.Session()filename_queue= tf.train.string_input_producer(tf.train.match_filenames_once(\"./*.csv\"),shuffle=True)reader=tf.TextLineReader(skip_header_lines=1)key, value=reader.read(filename_queue)record_defaults=[[0.],[0.],[0],[0.],[\"\"]]col1, col2, col3, col4, col5=tf.decode_csv(value,record_defaults=record_defaults)# Convert CSVrecords to tensors.Each# column maps to one tensor.features=tf.pack([ col1, col2, col3, col4])tf.initialize_all_variables().run(session=sess)coord=tf.train.Coordinator()threads=tf.train.start_queue_runners(coord=coord, sess=sess)for iteration in range(0,5):example=sess.run([ features])print(example)coord.request_stop()coord.join(threads)# 加载和处理图像import tensorflow as tf sess=tf.Session()filename_queue=tf.train.string_input_producer(tf.train.match_filenames_once('./blue_jay.jpg'))reader=tf.WholeFileReader()key, value= reader.read(filename_queue)image=tf.image.decode_jpeg(value)fliplmageUpDown=tf.image.encode _jpeg(tf.image.fli p_up_down(image))# 获得上下翻转的图片 fliplmageleftRight=tf.image.encode_jpeg(tf.image.flip_left_right(image))# 获得左右翻转的图片 tf.initialize_all_variables().run(session=sess)coord=tf.train.Coordinator()threads=tf.train.start_queue_runners(coord=coord, sess=sess)example=sess.run(fliplmageLeftRight)print example file=open (\"flippedUpDown.jpg\",\"wb+\")file.write (fliplmageUpDown.eval(session=sess))# 写入上下翻转图file.close()file=open (\"flippedLeftRight.jpg\",\"wb+\")# 写入左右翻转图file.write(fliplmageLeftRight.eval(session=sess))file.close() 流程: 创建一个文件队列对象:tf.train.string_input_producer(tf.train.match_filenames_once('xxx')) 创建一个reader对象 读取,并解码 提取特征 initialize_all_variables-&gt;Coordinator-&gt;start_queue_runners-&gt;run logit函数 logit⁡(p)=log⁡(p1−p)\\operatorname{logit}(\\mathrm{p})=\\log \\left(\\frac{\\mathrm{p}}{1-\\mathrm{p}}\\right)logit(p)=log(1−pp​) 该函数实现了从区间[0,1]到区间(-∞,+∞)之间的映射。 那么我们只要将y用一个输入的线性函数替换， 那么就实现了输入的线性变化和区间[0,1]之间的映射。 logistic函数 对数几率函数的逆函数 logit⁡−1(α)=logistic⁡(α)=11+exp⁡(−α)=ep⁡(α)exp⁡(α)+1\\operatorname{logit}^{-1}(\\alpha)=\\operatorname{logistic}(\\alpha)=\\frac{1}{1+\\exp (-\\alpha)}=\\frac{\\operatorname{ep}(\\alpha)}{\\exp (\\alpha)+1}logit−1(α)=logistic(α)=1+exp(−α)1​=exp(α)+1ep(α)​ 这是一个Sigmoid函数。 Logistic函数将使得我们能够在我们的回归任务表示为二项选择。 σ(t)=etet+1=11+e−t\\sigma(t)=\\frac{\\mathrm{e}^{t}}{\\mathrm{e}^{t}+1}=\\frac{1}{1+\\mathrm{e}^{-t}}σ(t)=et+1et​=1+e−t1​ 一般的解释就是t为一个独立变量， 该函数将t映射到区间[0,1]之 间。 但是我们提升了这个模型， 将t转变为变量x的一个线性映射(当x 是一个多变量的向量时， t就是该向量中各个元素的线性组合) 。 我们可以将t表示如下： t=wx+b 我们就能够得到以下方程 logit⁡(p)=In⁡(p1−p)=wx+b\\operatorname{logit}(\\mathrm{p})=\\operatorname{In}\\left(\\frac{p}{1-p}\\right)=w x+blogit(p)=In(1−pp​)=wx+b 对于所有的元素， 我们计算了回归方程， 得出如下概率。 p^=eβ0+β1x1+eβ0+β1x\\hat{p}=\\frac{\\mathrm{e}^{\\beta_{0}+\\beta_{1} x}}{1+\\mathrm{e}^{\\beta_{0}+\\beta_{1} x}}p^​=1+eβ0​+β1​xeβ0​+β1​x​ 线性函数的参数起什么作用呢？ 它们可以改变直线的斜率和 Sigmoid函数零的位置。 通过调整线性方程中的参数， 来缩小预测值与 真实值之间的差距。 Logistic函数的属性 函数空间中每个曲线都可以被描述成它所应用的可能目标。 具体到Logistic函数： ●事件的可能性p依赖于一个或者多个变量。 比如， 根据之前的资 历,预测获奖的可能性。 ●对于特定的观察， 估算事件发生的可能性。 ●预测改变独立变量对二项响应的影响。 ●通过计算可能性， 将观测分配到某个确定的类。 损失函数 loss =−∑iyi∙log⁡(ypredi)+(1−yi)∙log⁡(1−ypredi)=-\\sum_{i} y_{i} \\bullet \\log \\left(y p r e d_{i}\\right)+\\left(1-y_{i}\\right) \\bullet \\log \\left(1-y p r e d_{i}\\right)=−∑i​yi​∙log(ypredi​)+(1−yi​)∙log(1−ypredi​) 该损失函数的主要性质就是偏爱相似行为， 而当误差超过0.5的时 候， 惩罚会急剧增加。 多类分类应用——Softmax回归 当我们面对多于二类的情况， 通常有两种方法： 一对多和一对所 有。 ●第一类技术计算多个模型。 针对每个类都计算一个“一vs所有 (one against all) ”的概率。 ●第二类技术只计算出一个概率集合， 每个概率表示属于其中某一 类的可能性。 ●第二种技术的输出是Softmax回归格式， 这是Logistic回归对于n类 的泛化。 损失函数 loss=∑i∑cyc∙log⁡(ypredc)=∑i∑cyc∙e−xc∑j=0c−1log⁡(e−xj)loss=\\sum_{i} \\sum_{c} y_{c} \\bullet \\log \\left(y p r e d_{c}\\right)=\\sum_{i} \\sum_{c} y_{c} \\bullet \\frac{e^{-x_{c}}}{\\sum_{j=0}^{c-1} \\log \\left(e^{-x_{j}}\\right)}loss=∑i​∑c​yc​∙log(ypredc​)=∑i​∑c​yc​∙∑j=0c−1​log(e−xj​)e−xc​​ 感知器算法 简单来说就是一个二元分类函数 简化版的感知器算法如下： ① 以一个随机分布初始化权值和偏差(通常比较小) ； ② 选择一个输入向量， 并将其放入神经网络中； ③ 将输入与权重相乘， 并加上偏差， 计算网络的输出y’； ④ 感知器的函数如下： f(x)={1if w⋅x+b&gt;00otherwisef(x)=\\left\\{\\begin{array}{ll}{1} &amp; {if \\; w \\cdot x+b&gt;0} \\\\ {0} &amp; otherwise \\end{array}\\right.f(x)={10​ifw⋅x+b&gt;0otherwise​ ⑤ 如果y′≠y， 将权重wi加上Δw=yxi； ⑥ 返回第②步。 TensorFlow中损失优化方法 ●tf.train.GradientDescentOptimizer(learning_rate, use_locking, name)： 原始梯度下降方法， 唯一参数就是学习率。 ●tf.train.AdagradOptimizer： 自适应调整学习率， 累加历史梯度的平 方， 作为分母， 防止有些方向的梯度值过大， 提高优化效率， 善于处理 稀疏梯度。 ●tf.train.AdadeltaOptimizer： 扩展AdaGrad优化方法， 只累加最近的 梯度值， 而不对整个历史上的梯度值进行累加。 ●tf.train.AdamOptimizertf.train.AdamOptimizer． (learningrate, beta1, beta2, epsilon, use locking, name)： 梯度的一阶矩估计和二阶矩估计动态 调整每个参数的学习率。 Adam是自适应矩估计(Adaptive Moment Estimation) 的首字母缩写。 Sklearn预处理函数 我们看一些下面的Sklearn数据预处理函数： ●preprocessing.StandardScaler()： 数据正规化(Normalization) 是机 器学习估计的一个常见要求， 为了模型能更好地收敛， 我们通常会将数 据集预处理到一个零均值单位方差的高斯状分布。 通常， 我们会将数据 的各个维度都减去它的均值， 然后乘上一个非零的数。 这个非零的数就 是数据集的标准差。 对于该任务， 我们直接使用StandardScaler， 它已经 实现了我们上面提到的操作。 它也保留了变换操作， 让我们可以直接用 在测试集上。 ●StandardScaler .fit_transform()： 将数据调整到所需要的形式。 StandardScaler对象会存储数据变化的变量， 这样我们可以把数据解正规 化到原先的格式。 ●cross_validation.train_test_split： 该方法能够将数据集分割成训练 集和测试集。 我们只需要提供两者的比例， 该方法能够自动帮我们处 理 书籍推荐 了解tensorflow基础对象——《面向机器智能的tensorflow实践》 进阶操作tensor对象——《Tensorflow机器学习项目实战》 Hello TensorFlow import tensorflow as tf如果报错dtype…可以降低numpy的版本(从1.16-&gt;1.17) 123456789101112131415161718192021import tensorflow as tfimport numpy as npimport matplotlib.pyplot as plt% matplotlib inline a=tf.random_normal([2,20])sess=tf.Session()out=sess.run(a)x,y=outplt.scatter(x,y)plt. show()'''%matplotlib inline这是一条专门的命令，用于通知笔记本将matplotib图表直接显示在浏览器中。下面逐行分析其余代码，如果你不理解某些术语，请不必担心，后面章节还会一一进行讲解：1)用TensorFlow定义一个由随机数构成的2×20的矩阵，并将其赋给变量a。2)启动TensorFlow Session，并将其赋予一个ses对象。3)用sess.run()方法执行对象a，并将输出(NumPy数组)赋给ot。4)将这个2×20的矩阵划分为两个1×10的向量x和y。5)利用pyplot模块绘制散点图，x对应横轴，y对应纵轴。''' sess=tf.Session() Session对象在运行时负责对数据流图进行监督，并且是运行数据流图的主要接口。在本练习之后，我们还将对Session对象进行更为深入的探讨，但现在只需了解在TensorFow中，如果希望运行自己的代码，必须定义一个Session对象。上述代码将Session对象赋给了变量sess，以便后期能够对其进行访问。 target指定了所要使用的执行引擎。对于大多数应用，该参数取为默认的空字符串。在分布式设置中使用Session对象时，该参数用于连接不同的tftrain Server实例(本书后续章节将对此进行介绍)。 graph参数指定了将要在Session对象中加载的Graph对象，其默认值为None，表示将使用当前默认数据流图。当使用多个数据流图时，最好的方式是显式传入你希望运行的Graph对象(而非在一个with语句块内创建Session对象)。 config参数允许用户指定配置Session对象所需的选项，如限制CPU或GPU的使用数目，为数据流图设置优化参数及日志选项等。 Sesionnn()方法接收一个参数fetches，以及其他三个可选参数：feed_dict、options和rnn_metadata。本书不打算对options和run_metadata进行介绍，因为它们尚处在实验阶段(因此以后很可能会有变动)，且目前用途非常有限，但理解ed_dict非常重要，下文将对其进行讲解。 1.fetches参数 fetches参数接收任意的数据流图元素(Op或Tensor对象)，后者指定了用户希望执行的对象。如果请求对象为Tensor对象，则rnun()的输出将为一NumPy数组：如果请求对象为一个Op，则输出将为None。 除了利用fetches获取Tensor对象输出外，还将看到这样的例子：有时也会赋予ftches一个指向某个Op的句柄，这是在运行中的一种有价值的用法。 tf.initialize_all_variables()使是一个这样的例子，它会准备将要使用的所有TensorFow Variable对象(本章稍后将介绍Variable对象)。我们仍然将该Op传给etches参数，但Session.run()的结果将为None： 1执行初始化Variable对象所需的计算，但返回值为None sess.run(tf.initialize_all_variables()) 2.feed_dict参数 参数feed_dict用于覆盖数据流图中的Tensor对象值，它需要Python字典对象作为输入。字典中的“键”为指向应当被覆盖的Tensor对象的句柄，而字典的“值”可以是数字、字符串、列表或NumPy数组(之前介绍过)。这些“值”的类型必须与Tensor的“键”相同，或能够转换为相同的类型。下面通过一些代码来展示如何利用feed_dict重写之前的数据流图中a的值： 12345678910111213inport tensorflow as tf#创建Op、Tensor对象等(使用默认的数据流图)a=tf.add(2，5)b=tf.mul(a，3)#利用默认的数据流图启动一个Session对象sess=tf.Session()#定义一个字典，比如将a的值替换为15replace_dict=&#123;a：15&#125;#运行Session对象，将replace_dict赋给feed_dictsess.run(b，feed_dict=replace_dict)#返回45'''请注意，即便a的计算结果通常为7，我们传给eeddict的字典也会将它替换为15。在相当多的场合中，fed_dict都极为有用。由于张量的值是预先提供的，数据流图不再需要对该张量的任何普通依赖节点进行计算。这意味着如果有一个规模较大的数据流图，并希望用一些虚构的值对某些部分进行测试，TensorFlow将不会在不必要的计算上浪费时间。对于指定输入值，eed_dict也十分有用，在稍后的占位符一节中我们将对此进行介绍。''' tf.placehold 之前定义的数据流图并未使用真正的“输入”，它总是使用相同的数值5和3。我们真正希望做的是从客户那里接收输入值，这样便可对数据流图中所描述的变换 以各种不同类型的数值进行复用，借助“占位符”可达到这个目的。正如其名称所预示的那样，占位符的行为与Tesor对象一致，但在创建时无须为它们指定具体的数值。它们的作用是为运行时即将到来的某个Tensor对象预留位置，因此实际上变成了“输入”节点。利用tfplaceholderOp可创建占位符： 123456789import tensorflow as tfinport numpy as np#创建一个长度为2、数据类型为int32的占位向量a=tf.placeholder(tf.int32，shape=[2]，name=\"my_input\")#将该占位向量视为其他任意Tensor对象，加以使用b=tf.reduce_prod(a，name=\"prod_b\")c=tf.reduce_sum(a，name=\"sum_c\")#完成数据流图的定义d=tf.add(b，c，name=\"add_d\") 调用tf.placehoder()时，dtype参数是必须指定的，而shape参数可选： dtype指定了将传给该占位符的值的数据类型。该参数是必须指定的，因为需要确保不出现类型不匹配的错误。 shape指定了所要传入的Tensor对象的形状。请参考前文中对Tensor形状的讨论。shape参数的默认值为None，表示可接收任意形状的Tensor对象。 与任何Op一样，也可在fpaceholer中指定一个name标识符。 为了给占位符传入一个实际的值，需要使用Sesionnm()中的eed_dict参数。我们将指向占位符输出的句柄作为字典(在上述代码中，对应变量a)的“键”，而 将希望传入的Tensor对象作为字典的“值”： 12345678#定义一个TensorFlow Session对象sess=tf.Session()#创建一个将传给feed_dict参数的字典#键：a’，指向占位符输出Tensor对象的句柄#值：一个值为[5，3]、类型为int32的向量input_dict=&#123;a:np.array([5，3]，dtype=np.int32)&#125;#计算d的值，将input_dict的“值”传给asess.run(d，feed_dict=input_dict) 必须在eed dixt中为待计算的节点的每个依赖占位符包含一个键值对。在上面的代码中，需要计算d的输出，而它依赖于a的输出。如果还定义了一些d不依赖的其他占位符，则无需将它们包含在eed_dict中。 placeholder的值是无法计算的—如果试图将其传入Session.nn()，将引发一个异常。 Variable对象 1.创建Variable对象 Tensor对象和Op对象都是不可变的(immmtable)，但机器学习任务的本质决定了需要一种机制保存随时间变化的值。借助TensorFbw中的Varable对象，便可达到这个目的。Variabe对象包含了在对Session.un()多次调用中可持久化的可变张量值。Variabk对象的创建可通过Variabe类的构造方法tVariable()完成： 123456789101112131415inport tensorflow as tf#为Variable对象传入一个初始值3my_var=tf.Variable(3，name=\"my_variable\")#Variable对象可用于任何可能会使用Tensor对象的TensorFlbw函数或Op中，其当前值将传给使用它的Op：add=tf.add(5，my_var)mul=tf.mul(8，my_var)#Variables对象的初值通常是全0、全1或用随机数填充的阶数较高的张量。为使创建具有这些常见类型初值的张量更加容易，TensorFlow提供了大量辅助Op，如tferos()、tfones()、tfrandom normal()和tfrandomuiform()，每个Op都接收一个sape参数，以指定所创建的Tensor对象的形状：#2×2的零矩阵zeros=tf.zeros([2，2])#长度为6的全1向量ones=tf.ones([6])#3×3×3的张量，其元素服从0~10的均匀分布uniform=tf.random_uniform([3，3，3]，minval=0，maxval=10)#3×3×3的张量，其元素服从0均值、标准差为2的正态分布normal=tf.random_normal([3，3，3]，mean=0.0，stddev=2.0) 除了tfrandom normal()外，经常还会看到人们使用ttrmncated nomal()，因为它不会创建任何偏离均值超过2倍标准差的值，从而可以防止有一个或两个元素与该张量中的其他元素显著不同的情况出现： 12345#该Tensor对象不会返回任何小于3.0或大于7.0的值trunc=tf.truncated_normal([2，2]，mean=5.0，stddev=1.0)可像手工初始化张量那样将这些Op作为Variable对象的初值传入：#默认均值为0，默认标准差为1.0randon_var=tf.Variable(tf.truncated_normal([2，2])) 2.Variable对象的初始化 Variable对象与大多数其他TensorFlow对象在Graph中存在的方式都比较类似，但它们的状态实际上是由Session对象管理的。因此，为使用Varinbe对象，需要采取一些额外的步骤—必须在一个Session对象内对Variable对象进行初始化。这样会使Session对象开始追踪这个Variable对象的值的变化。Varabe对象的初始化通常是通过将tinitialize_all_variabkes()Op传给Sessionrun()完成的： 123456789init=tf.initialize_all_variables()sess=tf.Session()sess.run(init)#如果只需要对数据流图中定义的一个Variable对象子集初始化，可使用tfinitialie variables()。该函数可接收一个要进行初始化的Variable对象列表：var1=tf.Variable(0，name=\"initialize_me\")var2=tf.Variable(1，name=\"no_initialization\")init=tf.initialize_variables([var1]，name=\"init_var1\")sess=tf.Session()sess.run(init) 3.Variable对象的修改 要修改Variablk对象的值，可使用Variable.assign()方法。该方法的作用是为Variable对象赋予新值。请注意，Variable.assign()是一个Op，要使其生效必须在一个Session对象中运行： 1234567891011121314151617181920212223#创建一个初值为1的Variable对象my_var=tf.Variable(1)#创建一个Op，使其在每次运行时都将该Variable对象乘以2my_var_times_two=my_var.assign(my_var*2)#初始化Op init=tf.initialize_all_variables()#启动一个会话sess=tf.Session()#初始化Variable对象sess.run(init)#将Variable对象乘以2，并将其返回sess.run(my_var_times_two)##输出：2#再次相乘sess.run(my_var_times_two)##输出：4#再次相乘sess.run(my_var_times_two)##输出：8对于Variablk对象的简单自增和自减，TensorFlow提供了Variable.asign add()方法和Variable.assignsub()方法：#自增1sess.run(my_var.assign_add(1))#自减1sess.run(my_var.assign_sub(1)) △由于不同Session对象会各自独立地维护Varablk对象的值，因此每个Session对象都拥有自己的、在Graph对象中定义的Variabe对象的当前值： 4.trainable参数 在本书的后续章节将介绍各种能够自动训练机器学习模型的Optinmizer类，这意味着这些类将自动修改Variable对象的值，而无须显式做出请求。在大多数情况下，这与读者的期望一致，但如果要求Graph对象中的一些Variabk对象只可手工修改，而不允许使用Optimizer类时，可在创建这些Variable对象时将其raimbe参数设为False：not_trainable=tf.Variable(0，trainable=False)","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"}]},{"title":"常用域名记录解释","slug":"常用域名记录解释","date":"2019-09-17T09:47:35.000Z","updated":"2019-09-17T09:47:50.806Z","comments":true,"path":"2019/09/17/常用域名记录解释/","link":"","permalink":"https://nymrli.top/2019/09/17/常用域名记录解释/","excerpt":"","text":"常用域名记录解释 A记录 A记录是用来创建到IP地址的记录。 A记录设置技巧 1、如果想创建不带www的记录，即ezloo.com，在主机记录中填写@或者留空，不同的注册商可能不一样。 2、创建多个域名到同一个IP，比如给博客建了二级域名，可以使用*.blog.ezloo.com来指向一个IP，这样的话，不管是访问a.blog.ezloo.com还是b.blog.ezloo.com都能到同一个IP。 3、如果你给同一个二级域名设置了多个A记录，比如你建了两个blog的A记录，其中一个指向了111.111.111.111，另一个指向了111.111.111.112，那么在查询的时候，每次返回的数据包含了两个IP地址，但是在返回的过程中数据排列的顺序每次都不相同。由于大 部分的客户端只选择第一条记录所以通过这种方式可以实现一定程度的负载均衡。 在命令行下可以通过nslookup -qt=a www.ezloo.com来查看A记录。 MX记录 在命令行下可以通过 nslookup -qt=mx ezloo.com 来查看MX记录。 mx 记录的权重对 Mail 服务是很重要的，当发送邮件时，Mail 服务器先对域名进行解析，查找 mx 记录。先找权重数最小的服务器（比如说是 10），如果能连通，那么就将服务器发送过去；如果无法连通 mx 记录为 10 的服务器，那么才将邮件发送到权重为 20 的 mail 服务器上。 这里有一个重要的概念，权重 20 的服务器在配置上只是暂时缓存 mail ，当权重 20 的服务器能连通权重为 10 的服务器时，仍会将邮件发送的权重为 10 的 Mail 服务器上。当然，这个机制需要在 Mail 服务器上配置。（http://blog.ixpub.net/viewthread-1308142） CNAME记录 CNAME记录也成别名记录，它允许你将多个记录映射到同一台计算机上。比如你建了如下几条记录： a1 CNAME a.ezloo.com a2 CNAME a.ezloo.com a3 CNAME a.ezloo.com a A 111.222.111.222 我们访问a1（a2，a3）.ezloo.com的时候，域名解析服务器会返回一个CNAME记录，并且指向a.ezloo.com，然后我们的本地电脑会再发送一个请求，请求a.ezloo.com的解析，返回IP地址。 当我们要指向很多的域名到一台电脑上的时候，用CNAME比较方便，就如上面的例子，我们如果服务器更换IP了，我们只要更换a.ezloo.com的A记录即可。 在命令行下可以使用nslookup -qt=cname a.ezloo.com来查看CNAME记录。 TXT记录 TXT记录一般是为某条记录设置说明，比如你新建了一条a.ezloo.com的TXT记录，TXT记录内容&quot;this is a test TXT record.&quot;，然后你用 nslookup -qt=txt a.ezloo.com ，你就能看到&quot;this is a test TXT record&quot;的字样。 除外，TXT还可以用来验证域名的所有，比如你的域名使用了Google的某项服务，Google会要求你建一个TXT记录，然后Google验证你对此域名是否具备管理权限。 在命令行下可以使用nslookup -qt=txt a.ezloo.com来查看TXT记录。 AAAA记录 AAAA记录是一个指向IPv6地址的记录。 可以使用nslookup -qt=aaaa a.ezloo.com来查看AAAA记录。 NS记录 NS记录是域名服务器记录，用来指定域名由哪台服务器来进行解析。可以使用nslookup -qt=ns ezloo.com来查看。 TTL值 TTL=time to live，表示解析记录在DNS服务器中的缓存时间。比如当我们请求解析www.ezloo.com的时候，DNS服务器发现没有该记录，就会下个NS服务器发出请求，获得记录之后，该记录在DNS服务器上保存TTL的时间长度。当我们再次发出请求解析www.ezloo.com 的时候，DNS服务器直接返回刚才的记录，不去请求NS服务器。TTL的时间长度单位是秒，一般为3600秒。","categories":[],"tags":[{"name":"网络知识","slug":"网络知识","permalink":"https://nymrli.top/tags/网络知识/"}]},{"title":"SpringBoot学习笔记","slug":"SpringBoot学习笔记","date":"2019-09-17T09:01:40.000Z","updated":"2021-11-27T07:48:46.056Z","comments":true,"path":"2019/09/17/SpringBoot学习笔记/","link":"","permalink":"https://nymrli.top/2019/09/17/SpringBoot学习笔记/","excerpt":"","text":"Spring Boot SpringMVC流程图 hello word 第一个controller 12345678910111213141516171819202122232425262728/** * Project Name:demo * File Name:HelloController.java * Package Name:com.example.demo * Date:2019年9月15日下午8:27:56 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.example.demo;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @Value(\"$&#123;cupsize&#125;\") private String cupsize; @RequestMapping(value=\"hello\",method= RequestMethod.GET)// @GetMapping(\"/hello\") public String say() &#123; return cupsize; &#125;&#125; application.yml 12345678server: port: 5000# servlet:# context-path: /girlcupsize: Bspring.datasource.url: jdbc:mysql://127.0.0.1:3306/spring.datasource.username: root spring.datasource.password: 123456spring.datasource.driver-class-name: com.mysql.jdbc Controller的使用 @Controller处理http请求Spring4之后新加的注解，原来返回json 需要返回模板,即return “index”; 需要在POM.XML中添加spring-boot-starter-thymeleaf的依赖 1234&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; @RestController等价于&lt;==&gt;@Controller+@ResponseBody 可以返回JSON格式 @RequestMapping 配置url映射 ▲如果没有指定Method那么所有方式都可以 给某个方法指定url路由 @RequestMapping(value={&quot;/hello&quot;,&quot;/hil&quot;},method=RequestMethod.GET) 给整个class指定路由 123456789101112131415161718192021222324252627/** * Project Name:demo * File Name:HelloController.java * Package Name:com.example.demo * Date:2019年9月15日下午8:27:56 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.example.demo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(value=\"/hello\")public class HelloController &#123; @Autowired private GirlProperties girlProperties; @RequestMapping(value = \"/say\", method= RequestMethod.GET) public String say() &#123; return girlProperties.getCupSize(); &#125;&#125; @RequestMapping(value=xxx,method=RequestMethod.GET)等价于XxxMapping GetMapping PostMapping @PathVariable 1234@RequestMapping(value = \"/say/&#123;id&#125;\", method= RequestMethod.GET)public String say(@PathVariable(\"id\") Integer id) &#123;return \"id:\" + id;&#125; @RequestParam 12345678910@RequestMapping(value = \"/say\", method= RequestMethod.GET)public String say(@RequestParam(\"id\") Integer mid) &#123; return \"id:\" + mid;&#125;@RequestMapping(value = \"/say\", method= RequestMethod.GET) // defaultValue值必须为String public String say(@RequestParam(value=\"id\", required=false, defaultValue=\"0\") Integer mid) &#123; return \"id:\" + mid; &#125; 数据库管理 JPA（Java Persistence APl）定义了一系列对象持久化的标准，目前实现这一规范的产品有Hibernate、TopLink等。 启用JPA application.yml 123456789101112spring: profiles: active: dev datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/dbgirl?characterEncoding=utf-8&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC username: root password: cl123123 jpa: hibernate: ddl-auto: create show-sql: true 增删改查CURD 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Project Name:demo * File Name:Girl.java * Package Name:com.example.demo * Date:2019年9月16日下午6:34:14 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.example.demo;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entitypublic class Girl &#123; @Id @GeneratedValue private Integer id; private String cupSize; private Integer age; public Girl() &#123; // TODO Auto-generated constructor stub &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getCupSize() &#123; return cupSize; &#125; public void setCupSize(String cupSize) &#123; this.cupSize = cupSize; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"&#123;\\\"id\\\":\\\"\" + id + \"\\\",\\\"cupSize\\\":\\\"\" + cupSize + \"\\\",\\\"age\\\":\\\"\" + age + \"\\\"&#125; \"; &#125;&#125; GirlControllr.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Project Name:demo * File Name:GirlController.java * Package Name:com.example.demo * Date:2019年9月17日下午3:44:06 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.example.demo;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GirlController &#123; @Autowired private GirlRepository girlRepository; @GetMapping(value= \"/girls\") public List&lt;Girl&gt; girlList()&#123; return girlRepository.findAll(); &#125; @PostMapping(value = \"/girls\") public Girl addGirl(@RequestParam(\"cupSize\") String cupSize, @RequestParam(\"age\") Integer age) &#123; System.out.println(\"cupsize\"+cupSize); Girl girl= new Girl(); girl.setCupSize(cupSize); girl.setAge(age); return girlRepository.save(girl); &#125; @GetMapping(value=\"/girls/&#123;id&#125;\") public Girl girlFindOne(@PathVariable(\"id\") Integer id) &#123; return girlRepository.findById(id).get();// return girlRepository.getOne(id); 无效，需要实例json &#125; @PutMapping(value=\"/girls/&#123;id&#125;\") public Girl girlUpdate(@PathVariable(\"id\") Integer id, @RequestParam(\"cupSize\") String cupSize, @RequestParam(\"age\") Integer age) &#123; Girl girl = new Girl(); girl.setId(id); girl.setAge(age); girl.setCupSize(cupSize); return girlRepository.save(girl); &#125; @DeleteMapping(value=\"/girls/&#123;id&#125;\") public void girlDelete(@PathVariable(\"id\") Integer id) &#123; girlRepository.deleteById(id); &#125; @GetMapping(value=\"/girls/age/&#123;age&#125;\") public List&lt;Girl&gt; girlListByAge(@PathVariable(\"age\") Integer age)&#123; return girlRepository.findByAge(age); &#125;&#125; ▲注意.视频中的findOne已经被淘汰，因为springboot版本问题，新的版本不再支持findone(id)方法。 可用findById(id).get()或getOne(id)来替换，区别是前者当参数id为空时返回null，后者直接报异常，因为getOne返回的是对象的引用。 我试了下getOne会报错，据说是要设置json的返回格式？ 自定义搜索方式findByAge 12345678910111213141516171819/** * Project Name:demo * File Name:GirlRepository.java * Package Name:com.example.demo * Date:2019年9月17日下午3:44:33 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.example.demo;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;public interface GirlRepository extends JpaRepository&lt;Girl, Integer&gt;&#123; public List&lt;Girl&gt; findByAge(Integer age);&#125; 数据库事务管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Project Name:demo * File Name:GirlController.java * Package Name:com.example.demo * Date:2019年9月17日下午3:44:06 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ @PostMapping(value = \"/girls/two\") public void girlTwo() &#123; girlService.insertTwo(); &#125;/** * Project Name:demo * File Name:GirlService.java * Package Name:com.example.demo * Date:2019年9月17日下午4:39:00 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.example.demo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class GirlService &#123; @Autowired private GirlRepository girlRepository; @Transactional public void insertTwo() &#123; Girl girlA = new Girl(); girlA.setCupSize(\"A\"); girlA.setAge(18); girlRepository.save(girlA); Girl girlB = new Girl(); girlB.setCupSize(\"BBBB\"); girlB.setAge(19); girlRepository.save(girlB); &#125;&#125; 在项目开发过程中，使用了Spring data jpa自动创建表。但是默认情况下，创建出来的表类型为MyISAM。 （MySQL数据库默认的存储引擎类型是MyISAM，这种存储引擎类型不支持事务处理。）改成InnoDB存储引擎会就可以了。 123456jpa: database: MYSQL hibernate: ddl-auto: update show-sql: true database-platform: org.hibernate.dialect.MySQL5InnoDBDialect 在navicat中数据库—&gt;表—&gt;单击表名，在右边可以出现表的所有信息 Spring Boot 2.0深度实践-初遇Spring Boot 多模块：web、persistence、mdel 项目打包——多模块重构后 运行模式 IDEA: 有图形界面的开发环境 JAR/WAR: 线上、服务器上的生产环境 123$ mvn install $ cd target$ java -jar MAVEN插件: 无图形界面的开发环境 mvn spring-boot:run 热加载： pom.xml中加上依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 热部署: 就是容器状态在运行的情况下重新部署整个项目.在这种情况下一般整个内存会清空,重新加载.简单来说就是Tomcat或者其他的web服务器会帮我们重新加载项目.这种方式可能会造成sessin丢失等情况. 热加载: 就是容器状态在运行的情况下重新加载改变编译后的类.在这种情况下内存不会清空,sessin不会丢失,但容易造成内存溢出,或者找不到方法。因为内存无法转变成对像.一般改变类的结构和模型就会有异常，在已经有的变量和方法中改变是不会出问题的 2020.5.29 春招上岸了, 准备下后端的相关开发知识 注解含义 @SpringBootApplication内容-&gt;configuration配置相关 1234567891011121314151617@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited// 上述四个为元注解, 不需要看@SpringBootConfiguration // 表示这是一个配置类, 由原来spring中的configuration封装而成(代替xml)@EnableAutoConfiguration // 允许自动配置@ComponentScan( // 扫描设置: 指定IOC容器扫描的包 excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;) @EnableAutoConfiguration 1234567891011121314@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage // 指定自动配置的包@Import(&#123;AutoConfigurationImportSelector.class&#125;) // Import指定导入某个类 // AutoConfigurationImportSelector 为导入选择器public @interface EnableAutoConfiguration &#123; // 自动导入配置 String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; @AutoConfigurationPackage 12345678910@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;Registrar.class&#125;) // 通过Registrar将主启动类所在包和它的子包中所有的组件扫描到IOC容器中public @interface AutoConfigurationPackage &#123; // 指定自动配置的包 String[] basePackages() default &#123;&#125;; Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;&#125; 1234567891011121314151617public abstract class AutoConfigurationPackages &#123; // ... static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; Registrar() &#123; &#125; // 静态内部类 public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; AutoConfigurationPackages.register(registry, (String[])(new AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(new String[0])); // 第二个参数: 找到主启动类的包及其子包 &#125; public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.singleton(new AutoConfigurationPackages.PackageImports(metadata)); &#125; &#125; &#125; 主动导入的配置在:External Library-&gt; META-INF/spring.factories-&gt;Maven: org.springframework.boot:spring-boot-autoconfigure:2.3.0.RELEASE 1234# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ 随便点一个进去可以看到, 比如redis 123456789101112131415161718@Configuration( proxyBeanMethods = false)@ConditionalOnClass(&#123;EnableRedisRepositories.class&#125;)@ConditionalOnBean(&#123;RedisConnectionFactory.class&#125;)@ConditionalOnProperty( // 会去读properties文件， 如果读取到了相关参数参会加载 prefix = \"spring.data.redis.repositories\", name = &#123;\"enabled\"&#125;, havingValue = \"true\", matchIfMissing = true // 如果不存在也行)@ConditionalOnMissingBean(&#123;RedisRepositoryFactoryBean.class&#125;)@Import(&#123;RedisRepositoriesRegistrar.class&#125;)@AutoConfigureAfter(&#123;RedisAutoConfiguration.class&#125;)public class RedisRepositoriesAutoConfiguration &#123; public RedisRepositoriesAutoConfiguration() &#123; &#125;&#125; 12345678910111213141516171819202122232425262728@Configuration( proxyBeanMethods = false)@ConditionalOnWebApplication( type = Type.SERVLET)@ConditionalOnClass(&#123;WebServlet.class&#125;)@ConditionalOnProperty( // 会去读properties文件， 如果读取到了相关参数参会加载 prefix = \"spring.h2.console\", name = &#123;\"enabled\"&#125;, havingValue = \"true\", matchIfMissing = false // 如果不存在就不会加载)@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class&#125;)@EnableConfigurationProperties(&#123;H2ConsoleProperties.class&#125;) // 允许通过properties文件加载public class H2ConsoleAutoConfiguration &#123; // ...&#125;// 。。。@ConfigurationProperties( prefix = \"spring.h2.console\" // 通过properties文件配置， 读取前缀为\"spring.h2.console\"的设置)public class H2ConsoleProperties &#123; // ...&#125; @ComponentScan： 表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service、@Repository等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。 如果没有配置的话，Spring Boot中@SpringBootApplication会扫描启动类所在包下以及子包下的组件。 @bean注解: 相当于xml中的bean标签, 标注在方法上，用于把一个类对象加入IOC容器(返回某个实例的方法)，交给spring管理（官网解释：bean是一个由Spring IoC容器实例化、组装和管理的对象。）。并且注意，Spring上加@Bean注解的都是默认单例模式 参考： https://www.awaimai.com/2596.html ioC：在 Spring 中，类的实例化、依赖的实例化、依赖的传入都交由 Spring Bean 容器控制，而不是用new方式实例化对象、通过非构造函数方法传入依赖等常规方式。在Spring中，我们基本不需要 new 一个类，这些都是让 Spring 去做的。Spring 启动时会把所需的类实例化成对象，如果需要依赖，则先实例化依赖，然后实例化当前类。 依赖注入:因为依赖必须通过构建函数传入，所以实例化时，当前类就会接收并保存所有依赖的对象。 @Import注解: 相对于@bean注解, 可以更便捷地将一个类加入IOC容器 @condition*注解: 一个类满足特定的条件时才加入IOC容器（实例化对象） @RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。 @RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。 @ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@Responsebody后返回结果不会被解析为跳转路径(直接return 'index'表示跳转到index.html)，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。 @RequestBody将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。 SpringBoot提供的获取参数注解包括：@PathVariable，@RequestParam，@RequestBody,三者的区别如下 接收json数据一定需要使用@RequestBody @RequestParam: 表示从请求参数中获取的, 比如表单参数username @RequestVariable: 表示从url中提取的, 比如&quot;/user/{id}&quot;, 则写成@RequestVariable(&quot;id&quot;) Integer id @Propertysource: 可以指定读取的配置文件，跟@Value一起使用 @Value：注入Spring boot application.properties配置的属性的值 @Autowired：自动导入依赖的bean, bean都是独立的, 但实际工作中，很多对象会依赖其他对象完成任务。这时候就需要能够将组件扫描得到的bean和他们依赖装配在一起 annotation之@Autowired、@Inject、@Resource三者区别 @ImportResource：用来加载xml配置文件。 @Configuration和@Bean @Configuration 和@Bean Spring的Java配置方式是通过@Configuration和@Bean 这两个注解实现的： 1、@Configuration作用于类上，相当于一个xml配置文件； 2、@Bean作用于方法上，相当于xml配置中的&lt;bean&gt;；启动过程中会IOC容器找到Bean注解后会执行。要获得@Bean标注的对象时通过@Autowired从IOC容器中得到 SpringBoot工作原理 读取spring.factories文件 SpringBoot启动时会读取spring-boot-autoconfigure-2.1.6.RELEASE.jar包下的META-INF/spring.factories文件。读取org.springframework.boot.autoconfigure.EnableAutoConfiguration属性的值加载自动配置类。 加载XxxProperties类 根据自动配置类中指定的XxxProperties类设置自动配置的属性值，开发者也可以根据XxxProperties类中指定的属性在yml配置文件中修改自动配置。 根据@ConditionalXxx注解决定加载哪些组件 SpringBoot通过@ConditionalXxx注解指定特定组件加入IOC容器时所需要具备的特定条件。这个组件会在满足条件时加入IOC容器。 https://www.bilibili.com/video/BV1KE411K7PH?p=17 spring boot自动配置原理 spring boot中的@EnableAutoConfiguration注解的作用就是开启自动配置，正是因为开启了自动配置，开发者在使用spring boot的时候就不用再填写繁琐的的配置项了，那么spring boot是如何实现这个自动配置的呢? spring boot会根据开发者添加的依赖判断是否使用了某个技术，比如在依赖中有DispatcherServlet，那就说明使用了spring mvc技术。 spring boot判断出开发者所使用的技术之后（导入相关依赖），会从自动配置（AutoConfigure）相关的包下找到该技术相关的配置类。 spring boot会加载这些配置类，如果配置文件有写相关的配置信息的话会将该信息读取到配置类的对象中，然后加载到spring容器中，这样就完成了自动配置了。 在spring boot中自动配置类和配置类命名都是符合下面格式的: 自动配置类——*AutoConfiguration; 配置类——*Properties ▲如果不需要自动配置，可以@SpringBootApplication(exclude={RedisAutoConfiguration.class}) Springboot启动类 参考: https://www.bilibili.com/video/BV1sc411h7pN?p=8 配置文件 存放位置 当前项目根目录（工程根目录）中 当前项目根目录下的一个/config子目录中 项目的resources即classpath根路径中 项目的resources即classpath根路径下的/config目录中 注： Q:为什么项目的resources是classpath根路径？A: 因为编译之后配置文件会被放在target/classes目录下 使用classpath*:这种前缀，则可以代表多个匹配的文件；**/mapper/mapping/*Mapper.xml，双星号**表示在任意目录下，更多详情见：java项目中的classpath到底是什么 配置文件加载顺序 不同格式的加载顺序: 如果同一个目录下，有application.yml也有application.properties，默认先读取application.properties。 如果同一个配置属性，在多个配置文件都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的。 12345&lt;includes&gt; &lt;include&gt;**/application*.yml&lt;/include&gt; &lt;include&gt;**/application*.yaml&lt;/include&gt; &lt;include&gt;**/application*.properties&lt;/include&gt;&lt;/includes&gt; 不同位置的加载顺序: 当前项目根目录下的一个/config子目录中(1最高) 当前项目根目录中（2其次） 项目的resources即classpath根路径下的/config目录中(3一般) 项目的resources即classpath根路径中(4最后) 通过profile指定加载app配置文件 对于应用程序而言， 不同的环境需要不同的配置。springboot框架提供了多profile管理功能，从而来区分不同环境的配置。 规定语法规则： application-{profile}.properties(.yml, .yaml) 激活制定profile： java-jar configuration_file-0.0.1-SNAPSHOT.jar--spring.profiles.active=dev;、java-jar configuration_file-e.e.1-SNAPSHOT.jar--spring.config.location=D:\\config/ 外部配置文件 使用@PropertySource来加载其他配置文件（功能特殊列出or其他目录下） 123@Component@PropertySource(\"classpath:mqtt.properties\") // 一般会设置成Componentpublic class IotMqttClient &#123; @PropertySource 中的属性解释 value：指明加载配置文件的路径。 ignoreResourceNotFound：指定的配置文件不存在是否报错，默认是false。当设置为 true 时，若该文件不存在，程序不会报错。实际项目开发中，最好设置 ignoreResourceNotFound 为 false。 encoding：指定读取属性文件所使用的编码，我们通常使用的是UTF-8。 属性注入 通过@Value + SPEL表达式 直接绑定springboot配置文件中的值 在注入类前加上@ConfiguartionProperties(prefix=&quot;user&quot;)注解后会从application.properties(.yml)中读取指定前缀的配置，（如果结合`@PropertySource(&quot;classpath:address-book.properties&quot;则可以指定properties问题），从而节省了在每个成员字段前加@value 注：@ConfiguartionProperties和@Value两者会有冲突不能同时使用，出现时以单个的@Value为主（此时ConfiguartionProperties设置的prefix对于这个字段就是失效的，所以@Value=&quot;{xxx}&quot;，xxx要写全即跟配置文件中完全一致） 变量命名跟配置文件会进行匹配， 规则如下 不区分大小写 松散绑定： var_name和var-name和varName视为一种（@value不支持，@ConfiguartionProperties支持） 如果时复杂属性：List、set 在application.properties中以数组形式书写 在application.yml本身支持list，按yml书写即可 字符串，java代码中写工具类解析成数组 自动配置 @SpringBootConfiguration:Spring Boot的配置类；标注在某个类上，表示这是一个Spring Boot的配置类； @Coniguration：配置类上来标注这个注解；配置类——配置文件；配置类也是容器中的一个组件；Component @EnableAutoConfiguration：开启自动配置功能；以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效；. SpringBoot2.x整合redis 我是先尝试的thymeleaf,弄了我一下午;接着是mybatis也弄了很久;最后才是redis, 虽然是因为解决了IDEA的Maven问题, 但确实也是redis连接最简单 1.[官网下载Redis](https://redis.io/download， 因为windows支持的不好， 因此还是直接在服务器上使用 1234567$ wget http://download.redis.io/releases/redis-6.0.4.tar.gz$ tar xzf redis-6.0.4.tar.gz$ cd redis-6.0.4$ make$ cd src$ ./redis-server # 启动server服务$ ./redis-cli # 使用redis, 类似shell 外网连接设置 sudo vim /home/mrli/redis-6.0.4/redis.conf 将bind 127.0.0.1注释掉（含义为绑定可访问IP， 也就是说只能通过127.0.0.1访问） 将protected-mode yes设置为protected-mode no 解释: 默认情况bind=127.0.0.1只能接受本机的访问请求 不写的情况下，无限制接受任何ip地址的访问 如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的相应 fromB站视频: https://www.bilibili.com/video/BV1J4411x7U1?p=45 3.使用Springboot整合 设置依赖 yml配置IP 编写连接Test Springboot整合代码[代码重工]: http://39.108.113.88/content/country-spring-boot/detail/spring-boot-08 SpringBoot2.x整合Thymeleaf 问题: 我默认从创建工程的SpringBoot版本是2.3.0， 然后直接导入maven依赖， 在IDEA中是显示红色，无法使用的。==&gt;按照thymeleaf官方提供的2.3.0的导入方法仍然无效 A： 降低Springboot版本为2.1.14, 问题解决 问题罗列 浏览器显示: -&gt;没有配置路由 123456Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Fri May 29 15:30:09 CST 2020There was an unexpected error (type=Not Found, status=404).No message available 浏览器显示: -&gt;找不到模板 controller中返回的模板名与html文件名不一致 yml配置中prefix: classpath:/templates/设置错误，缺少末尾的/ 123456Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Fri May 29 15:30:49 CST 2020There was an unexpected error (type=Internal Server Error, status=500).Error resolving template [hello], template might not exist or might not be accessible by any of the configured Template Resolvers 成功案例 yml配置文件内容 123456789spring: thymeleaf: # 配置模板路径，默认是templates，可以不用配置 prefix: classpath:/templates/ # 要注意/的数量与位置 suffix: .html # 编码 可不用配置 encoding: UTF-8 # 开发配置为false,避免修改模板还要重启服务器 cache: false controller内容 123456789@Controllerpublic class ThymeLeafGo &#123; @RequestMapping(\"/test/thymeleaf\") public String testThymeleaf() &#123; System.out.println(\"yes\"); return \"hello\"; &#125;&#125; hello.html内容 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p th:text=\"经过服务器处理后可以看到的内容\"&gt;直接打开HMTL查看到的内容&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 文档教程: SpringBoot整合Thymeleaf-基于SpringBoot2.X版本 Thymeleaf语法: th:text：文本替换； th:value：属性赋值 th:each：遍历循环元素 th:if：判断条件，类似的还有th:unless，th:switch，th:case ${...} 变量表达式，Variable Expressions @{...} 链接表达式，Link URL Expressions #{...} 消息表达式，Message Expressions ~{...} 代码块表达式，Fragment Expressions *{...} 选择变量表达式，Selection Variable Expressions 常用的内置对象(用${#xxx}提取) ctx ：上下文对象。 vars ：上下文变量。 locale：上下文的语言环境。 request：（仅在web上下文）的 HttpServletRequest 对象。 response：（仅在web上下文）的 HttpServletResponse 对象。 session：（仅在web上下文）的 HttpSession 对象。 servletContext：（仅在web上下文）的 ServletContext 对象 常用的内置方法(用${#xxx}提取) strings：字符串格式化方法，常用的Java方法它都有。比如：equals，equalsIgnoreCase，length，trim，toUpperCase，toLowerCase，indexOf，substring，replace，startsWith，endsWith，contains，containsIgnoreCase等 numbers：数值格式化方法，常用的方法有：formatDecimal等 bools：布尔方法，常用的方法有：isTrue，isFalse等 arrays：数组方法，常用的方法有：toArray，length，isEmpty，contains，containsAll等 lists，sets：集合方法，常用的方法有：toList，size，isEmpty，contains，containsAll，sort等 maps：对象方法，常用的方法有：size，isEmpty，containsKey，containsValue等 dates：日期方法，常用的方法有：format，year，month，hour，createNow等 SpringBoot2.x整合Mybatis 最大的问题还是依赖问题， 在pom.xml写入了但是没生效。重建一个新项目， 更换了IDEA的Maven后问题解决 先放个成功的结果 12345678910111213141516171819202122232425 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.1.14.RELEASE)2020-05-29 20:21:38.066 INFO 9096 --- [ main] c.e.demo.test.DemoApplicationTests : Starting DemoApplicationTests on Mrli-computer with PID 9096 (started by Mr.li in G:\\SpringBootProject\\batis)2020-05-29 20:21:38.066 DEBUG 9096 --- [ main] c.e.demo.test.DemoApplicationTests : Running with Spring Boot v2.1.14.RELEASE, Spring v5.1.15.RELEASE2020-05-29 20:21:38.067 INFO 9096 --- [ main] c.e.demo.test.DemoApplicationTests : No active profile set, falling back to default profiles: default2020-05-29 20:21:40.807 INFO 9096 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService &apos;applicationTaskExecutor&apos;2020-05-29 20:21:41.700 INFO 9096 --- [ main] c.e.demo.test.DemoApplicationTests : Started DemoApplicationTests in 4.224 seconds (JVM running for 5.81)2020-05-29 20:21:42.163 ERROR 9096 --- [ main] com.alibaba.druid.pool.DruidDataSource : testWhileIdle is true, validationQuery not set2020-05-29 20:21:42.179 INFO 9096 --- [ main] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; inited2020-05-29 20:21:42.451 DEBUG 9096 --- [ main] c.e.demo.mapper.EmpMapper.selectAll : ==&gt; Preparing: select emp_id empId, emp_name empName, emp_age empAge from emp 2020-05-29 20:21:42.490 DEBUG 9096 --- [ main] c.e.demo.mapper.EmpMapper.selectAll : ==&gt; Parameters: 2020-05-29 20:21:42.530 DEBUG 9096 --- [ main] c.e.demo.mapper.EmpMapper.selectAll : &lt;== Total: 22020-05-29 20:21:42.533 DEBUG 9096 --- [ main] c.e.demo.test.DemoApplicationTests : Emp&#123;empId=12, empName=&apos;cl&apos;, empAge=18&#125;2020-05-29 20:21:42.533 DEBUG 9096 --- [ main] c.e.demo.test.DemoApplicationTests : Emp&#123;empId=14, empName=&apos;qsy&apos;, empAge=19&#125;2020-05-29 20:21:42.560 INFO 9096 --- [ Thread-1] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; closed2020-05-29 20:21:42.562 INFO 9096 --- [ Thread-1] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService &apos;applicationTaskExecutor&apos; 项目目录树 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.14.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; src-main-resources-application.yml 12345678910111213141516171819202122232425262728293031323334server: port: 8888spring: thymeleaf: suffix: .html #模板的模式，支持 HTML, XML TEXT JAVASCRIPT # mode: HTML5 #编码 可不用配置 encoding: UTF-8 #开发配置为false,避免修改模板还要重启服务器 cache: false #配置模板路径，默认是templates，可以不用配置 prefix: classpath:/templates/ datasource: name: mydb type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://127.0.0.1:3306/smybatis?serverTimezone=UTC username: root password: * driver-class-name: com.mysql.cj.jdbc.Drivermybatis: mapper-locations: classpath*:/mybatis/mapper/*Mapper.xmllogging: level: com: example: demo: mapper: debug test: debug src-main-resources-EmpMapper.yml 123456789&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.example.demo.mapper.EmpMapper\"&gt; &lt;select id=\"selectAll\" resultType=\"com.example.demo.entity.Emp\"&gt; select emp_id empId, emp_name empName, emp_age empAge from emp &lt;/select&gt;&lt;/mapper&gt; 注： 由于在Mybatis的mapper.xml文件中，如果resultType的type或者paramterType会返回自定义entity的话，那么需要用全类名名来指定这些实体。而一种好的便捷方法是，application.yml中可以添加mybatis-type-aliases-package: com.example.demo.mapper，其可以使用type-aliases-package中指定entity扫描包类从而让mybatis自己扫描到自定义的entity，直接写非限定名（短名）即可，如下所示。 12345&lt;mapper namespace=\"com.itheima.dao.ItemsDao\"&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"items\"&gt; select * from items where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; src-main-java-DemoApplication.java 123456789101112package com.example.demo;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@MapperScan(\"com.example.demo.mapper\") //在上面的dao接口中，我们添加了@mapper注解，这样spring boot就可以扫描到该接口从而使用// mybatis动态代理了。除了这种方式之外，可以在spring boot的启动类上添加@MapperScan注解，这样就无需再dao接口上添加@mapper注解了。@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123;SpringApplication.run(DemoApplication.class, args);&#125;&#125; src-main-java-com.example.demo.mapper 123456789101112131415161718package com.example.demo.mapper;import com.example.demo.entity.Emp;import java.util.List;/** * @Program: demo * @Description: * @Author: MrLi * @Create: 2020-05-29 19:51 **/public interface EmpMapper &#123; List&lt;Emp&gt; selectAll();&#125; src-main-java-com.example.demo.entity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.example.demo.entity;/** * @Program: demo * @Description: * @Author: MrLi * @Create: 2020-05-29 19:50 **/public class Emp &#123; private Integer empId; private String empName; private Integer empAge; public Emp(Integer empId, String empName, Integer empAge) &#123; this.empId = empId; this.empName = empName; this.empAge = empAge; &#125; public Emp() &#123; &#125; public Integer getEmpId() &#123; return empId; &#125; public void setEmpId(Integer empId) &#123; this.empId = empId; &#125; public String getEmpName() &#123; return empName; &#125; public void setEmpName(String empName) &#123; this.empName = empName; &#125; public Integer getEmpAge() &#123; return empAge; &#125; public void setEmpAge(Integer empAge) &#123; this.empAge = empAge; &#125; @Override public String toString() &#123; return \"Emp&#123;\" + \"empId=\" + empId + \", empName='\" + empName + '\\'' + \", empAge=\" + empAge + '&#125;'; &#125;&#125; com.example.demo.test 1234567891011121314151617181920212223242526272829303132package com.example.demo.test;import com.example.demo.entity.Emp;import com.example.demo.mapper.EmpMapper;import org.junit.jupiter.api.Test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTestclass DemoApplicationTests &#123; @Autowired private EmpMapper empMapper; // IDEA上有波浪线, 提示Could not autowire. No beans of 'EmpMapper' type found. 但可运行 private Logger logger = LoggerFactory.getLogger(DemoApplicationTests.class); @Test public void testSelectAll() &#123; List&lt;Emp&gt; emps = empMapper.selectAll(); for (Emp emp : emps) &#123;// System.out.println(emp); logger.debug(emp.toString()); &#125; &#125;&#125; 视频提供的代码配置链接: http://39.108.113.88/content/country-spring-boot/detail/spring-boot-07 上述几个整合教程来自B站: https://www.bilibili.com/video/BV1KE411K7PH/?p=20&amp;t=790 [SpringBoot2.x整合SpringDataJPA 文档链接: https://www.cnblogs.com/wadmwz/p/10313495.html ★B站视频链接:https://www.bilibili.com/video/BV1v4411G72q?p=8 包括之前几个内容的整合都可以观看这个视频, 这个质量高一点 代码组成: 12345678910111213141516171819202122// PersonController.java@RestControllerpublic class PersonController &#123; @Autowired PersonRepository personRepository; @GetMapping(\"/findall\") public List&lt;Person&gt; findAll() &#123; List&lt;Person&gt; personRepositoryAll = personRepository.findAll(); return personRepositoryAll; &#125; @GetMapping(\"/findById/&#123;id&#125;\") public Person findById(@PathVariable(\"id\") Integer id) &#123; return personRepository.findById(id).get(); &#125; @PostMapping(\"/save\") public Person save(@RequestBody Person person)&#123; return personRepository.save(person); &#125;&#125; 123456789101112// Person.java@Data@Entity // ▲记得加public class Person &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column private String username; @Column private String password;&#125; 12345678910111213// PersonRepository.java//CREATE DATABASE if not exists person;// use person;// CREATE table if not EXISTS person (// id int(11) auto_increment,// username varchar(24) ,// `password` varchar(24),// PRIMARY key(id)// );// TODO: 需要将库和表生成好, 如果需要自动建库建表, 按照文档说明的增加jpa的properties配置public interface PersonRepository extends JpaRepository&lt;Person, Integer&gt; &#123;&#125; 123456789101112# application.yml datasource: name: mydb url: jdbc:mysql://127.0.0.1:3306/person?serverTimezone=UTC username: root password: cl123123 driver-class-name: com.mysql.cj.jdbc.Driver jpa: show-sql: true properties: hibernate: format_sql: true 2021-8-2 自定义MVC配置： 实现WebMvcConfigurer接口可以扩展MVC的功能实现，又既保留SpringBoot的自动配置（原因是：在WebMvcAutoConfiguration 也有一个实现了WebMvcConfigurer的配置类） 1234567891011121314151617@Configurationpublic class DafMVCConfiguartion implements WebMvcConfigurer&#123; @Bean public WebMvcConfigurer corsConfigurer()&#123; return new WebMvcConfigurer() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"api/**\"); &#125; &#125;; &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; &#125;&#125; 为什么通过实现WebMvcConfigurer能进行配置的原理： 如果没有，由于WebMvcAutoConfiguration 也有一个内部类WebMvcAutoConfigurationAdapter 实现了WebMvcConfigurer的配置类，因此可以帮我们进行自动的配置 WebMvcAutoConfigurationAdapter 它也是利用这种方式实现WebMvcConfigurer去进行扩展的，所以我们通过查看这个类我们发现它帮我们实现了其他不常用的方法，帮助我们进行自动配置，我们只需定制（拦截器、视图控制器CORS在开发中需要额外定制的定制的功能） 注： 一个方法上添加了autowired注解后，它的参数将从容器中自动注入进来。 为什么实现WebMvcConfigurer后能work？ A:原因是①MVC应用会自动开启WebMvcAutoConfiguration ，因此会加载WebMvcAutoConfigurationAdapter ，②而WebMvcAutoConfigurationAdapter 上有着@EnableWebMvcConfiguration注解@Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class}. ③EnableWebMvcConfiguration这个类继承了DelegatingWebMvcConfiguration类（它会加载配置），④而在DelegatingWebMvcConfiguration中的setConfigurers(List&lt;WebMvcConfigurer&gt; configurers)方法上是有@Autowired注解，⑤因此会将所有实现了WebMvcConfigurer的Bean给注入到这个List参数中，并且全部进行设置this.configurers.addWebMvcConfigurers(configurers);即设置到委派类WebMvcConfigurerComposite的delegates中去。 1234567891011public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); public DelegatingWebMvcConfiguration() &#123; &#125; @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); &#125; &#125; ⑥而每次调用WebMvcConfigurerComposite的addXxxx功能时都会将被委派的类的方法，从而调用了MyMVCConfiguartion我们自定义的MVC配置类下的各种addXxxx方法 1234567891011class WebMvcConfigurerComposite implements WebMvcConfigurer &#123; private final List&lt;WebMvcConfigurer&gt; delegates = new ArrayList(); public void addInterceptors(InterceptorRegistry registry) &#123; Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) &#123; WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addInterceptors(registry); &#125; &#125;&#125; from：通过实现WebMvcConfigurer进行拓展MVC功能的原理 全局异常处理 系统内部有抛出异常的需求，但根据不要在页面上给用户显示错误，因此要进行异常捕捉 @ExceptionHandter的含义是当前的方法是用于处理什么异常类型的 12345678910111213141516171819202122232425262728293031323334353637// ErrorController.java@RestControllerpublic class ErrorController &#123; @ResponseBody @GetMapping(\"/xxx\") public String throwError()&#123; int i = 1/0; return \"yes\"; &#125;&#125;// ExceptionController.java@ControllerAdvicepublic class ExceptionController &#123; @ResponseBody @ExceptionHandler(Exception.class) public MyError processException()&#123; MyError myError = new MyError(); myError.setCode(400); myError.setMsg(\"被捕捉到了\"); return myError; &#125;&#125;// DafGlobalExceptionHandler.kt/** * @description: 全局异常拦截器 * @author: MrLi * @create: 2021-08-17 17:03 **/@ControllerAdviceclass DafGlobalExceptionHandler &#123; @ResponseBody @ExceptionHandler(BizException::class) fun processException(e: BizException): ResResult &#123; return ResResult.err(e.msg) &#125;&#125; 自定义异常页面 1234567891011public class MyErrorPageController implements ErrorController &#123; @Override public String getErrorPath() &#123; return \"/error\"; &#125; @GetMapping(\"/error\") public String errorView()&#123; return \"/error\"; &#125;&#125; 过滤器、监听器、拦截器 spring mvc的拦截器是只拦截controller而不拦截jsp,html 页面文件的。这就用到过滤器filter了，filter是在servlet前执行的，你也可以理解成过滤器中包含拦截器，一个请求过来 ，先进行过滤器处理，看程序是否受理该请求 。 过滤器放过后 ， 程序中的拦截器进行处理 。 拦截器不依赖servlet容器，过滤器依赖； 拦截器是基于java反射机制来实现的，过滤器基于回调 过滤器 的创建 创建自己的过滤器类实现javax.servlet.Filter接口 重写doFilter 的方法，在此方法里写过滤操作 在类上使用注解@WebFilter(filterName=”myFilter”,urlPatterns={“/*”}) 123456789101112131415161718192021222324252627/** * * 使用注解标注过滤器 * @WebFilter将一个实现了javax.servlet.Filter接口的类定义为过滤器 * 属性filterName 声明过滤器的名称,可选 * 属性urlPatterns指定要过滤 的URL模式,这是一个数组参数，可以指定多个。也可使用属性value来声明.(指定要过滤的URL模式是必选属性) */@WebFilter(filterName=\"myFilter\",urlPatterns=&#123;\"/*\"&#125;)public class MyFilter implements Filter&#123; @Override public void destroy() &#123; System.out.println(\"myfilter 的 销毁方法\"); &#125; @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"myfilter 的 过滤方法。这里可以执行过滤操作\"); //继续下一个拦截器 chain.doFilter(arg0, arg1); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; System.out.println(\"myfilter 的 初始化方法\"); &#125;&#125; 监听器 的创建 创建自己的监听类实现 ServletContextListener 接口，这个是监听servlet的 创建自己的监听类实现 HttpSessionListener 接口，这个是监听session 的 记得在自定义的监听类上添加注解@WebListener 1234567891011121314@WebListenerpublic class SessionListener implements HttpSessionListener&#123; @Override public void sessionCreated(HttpSessionEvent arg0) &#123; System.out.println(\"监听 创建session\"); &#125; @Override public void sessionDestroyed(HttpSessionEvent arg0) &#123; System.out.println(\"监听 销毁session\"); &#125; &#125; 拦截器 的创建 创建自己的拦截器类，实现HandlerInterceptor 接口 实现一个HandlerInterceptor拦截器可以直接实现HandlerInterceptor接口，也可以继承HandlerInterceptorAdapter类。 创建一个配置类，继承自WebMvcConfigurerAdapter ，并在类上添加注解@Configuration 重写addInterceptors方法，把自定义的拦截类注册进去。 自定义拦截器： 1234567891011121314151617181920public class MyInterceptor implements HandlerInterceptor&#123; @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; System.out.println(\"MyInterceptor 在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行\"); &#125; @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; System.out.println(\"MyInterceptor 请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）\"); &#125; @Override public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123; System.out.println(\"MyInterceptor 在请求处理之前进行调用（Controller方法调用之前）这里是拦截的操作\"); return true; &#125;&#125; 注册拦截器 继承 WebMvcConfigurerAdapter 1234567891011@Configurationpublic class WebConfigurer extends WebMvcConfigurerAdapter &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // addPathPatterns 用于添加拦截规则 // excludePathPatterns 排除拦截 registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/login\"); super.addInterceptors(registry); &#125;&#125; 执行过程： preHandle：Controller方法处理之前；链式Intercepter情况下，Intercepter按照声明的顺序一个接一个执行 postHandle：Controller方法处理完之后，DispatcherServlet进行视图的渲染之前，也就是说在这个方法中你可以对ModelAndView进行操作； afterCompletion：在整个请求完成之后即，DispatcherServlet进行视图的渲染之后 事件监听 事件监听的流程 自定义事件，一般是继承ApplicationEvent抽象类 定义事件监听器，一般是实现ApplicationListener接口 需要把监听器加入到spring容器中: 可以通过启动的时候添加 增加Component注解 通过context.listener.classes配置项导入进去 使用@EventListener注解：在方法上加@EventListener注解，并将该类注入到spring容器中 发布事件，使用ApplicationContext.publishEvent发布事件 spring提供的钩子，你知道哪些——可注入调整的位置有哪些 Spring笔记(7) - Spring的事件和监听机制——原理 https://www.bilibili.com/video/BV18E411F7GN?from=search&amp;seid=1165566942334976817——使用定义 由Kafka事件监听回顾Java回调——回调的概念 定时任务 Quartz Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，完全由Java开发，可以用来执行定时任务，类似于java.util.Timer。但是相较于Timer， Quartz增加了很多功能： 组成： 调度器：Scheduler，用来调度管理Trigger去执行指定的Job呢 任务：JobDetail 触发器：Trigger，包括SimpleTrigger和CronTrigger Schedule 在springboot中可以有很多方案去帮我们完成定时器的工作，有Java自带的java.util.Timer类，也有强大的调度器Quartz，还有SpringBoot自带的Schedule ==&gt; 相对于Quartz是适用于普通Java工程，Scheduled 针对于springboot设计 框架名称 Cron表达式 固定间隔执行 固定频率执行 任务持久化 难易度 TimerTask 不支持 支持 支持 不支持 一般 schedule 支持 支持 支持 不支持 简单 Quartz 支持 支持 支持 支持 难 在实际应用中，如果没有分布式场景(quartz 支持分布式, schedule 不支持(需要自己实现,用分布式锁)，schedule跟spring结合的更好，还是很适用的。 SpringBoot内置了Sping Schedule定时框架，通过注解驱动方式添加所注解方法到定时任务，根据配置定时信息定时执行。 无序导入依赖: Spring的Schedule包含在spring-boot-starter模块中，无需引入其他依赖。 在application上加上@EnableScheduling注解打开定时功能 在定时任务上增加注解@Scheduled(cron = &quot;0/3 * * * * *&quot;) 固定频率：@Scheduled(fixedRate = 3000)： 如果方法执行时间超过定时器时间, 方法执行完成后直接执行任务——补偿机制，如执行了5000ms，之后会立马把阻塞未执行的给执行了 固定间隔： @Scheduled(fixedDelay = 3000)： 方法执行完成后, 停留间隔时间, 再次执行该方法——如执行了5000ms后还会在等3000ms执行，不因为方法执行时间长度影响定时器 Cron表达式: @Scheduled(cron = “0/3 * * * * *”)：*固定按照间隔时间执行, 方法执行完成后, 按照间隔时间点再次执行该方法——比如方法执行5s, 定时间隔为3s, 则中间有一次执行不上, 不理会，而是当第二个3s间隔，即第6s开始下一次执行 12345678910@SpringBootApplication@EnableAsync// 开启定时任务@EnableScheduling@MapperScan(basePackages = &#123;\"com.gupao.springboot.*.mapper\"&#125;)public class GupaoSpringbootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GupaoSpringbootApplication.class, args); &#125;&#125; Spring的Schecule默认是单线程执行的，如果你定义了多个任务，那么他们将会被串行执行，会严重不满足你的预期。所以为了解决该问题，需要自定义线程池，具体如下： 123456789101112@Componentpublic class ScheduleConfig implements SchedulingConfigurer &#123; @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; taskRegistrar.setScheduler(customScheduler()); &#125; @Bean(destroyMethod = \"shutdown\") public ExecutorService customScheduler() &#123; return Executors.newScheduledThreadPool(20); &#125;&#125; from： SpringBoot：@Schedule定时任务 附录 实体类定义规则 PO，entity:persistent object 持久对象 有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。 Vo: view object 表现层对象 主要对应页面显示（web页面/swt、swing界面）的数据对象。 可以和表对应，也可以不，这根据业务的需要。 DTO（TO）：Data Transfer Object 数据传输对象 比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。 POJO:plain ordinary java object 无规则简单java对象 一个中间对象，可以转化为PO、DTO、VO。 POJO持久化之后==&gt;PO POJO用作表示层==&gt;VOI POJO传输过程中==&gt;DTO application.yml常用配置 12345spring.mvc.static-path-pattern=classpath:/# 更多可查看ResourceProperties类中# private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]&#123;&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;&#125;;server.port=8889 12345678910111213141516171819202122232425262728# tomcat相关server: port: 8889# sping相关spring: datasource: name: mydb url: jdbc:mysql://127.0.0.1:3306/person?serverTimezone=UTC username: root password: cl123123 driver-class-name: com.mysql.cj.jdbc.Driver # jpa相关 jpa: show-sql: true properties: hibernate: format_sql: true # 关闭默认图标 mvc: favicon: enabled: false# mybatis mybatis: mapper-locations: classpath*:/mybatis/mapper/*Mapper.xml# 日志logging: level: com.atguigu.spring.boot.mapper: debug 40 个 SpringBoot 常用注解 properties文件能够设定哪些配置 总共列出了全部1237个配置项，以及他们的含义和默认值！ 优秀的项目结构 1234567891011121314151617181920212223242526272829303132333435src|─main| |─java| | |─xyz.guqing.creek ------ 根包名| | | |─aspect ------ aop切面| | | |─config ------ springboot自动配置| | | |─controller ------ controller接口| | | |─mapper ------ mybatis mapper接口| | | |─exception ------ 自定义异常| | | |─service ------ service层| | | |─model ------ 模型类| | | | |─entity ------ 数据库对应的实体| | | | |─enums ------ 枚举| | | | |─params ------ controller中入参数修改类型的入参数命名为xxxParam查询的为xxxQuery——————should be: DTO| | | | |─dto ------ controller出参实体——————should be: VO| | | | |─annotation ------ 自定义注解| | | | |─dos ------ 数据库组合实体例如关联查询需要多表字段组合| | | | |─bo ------ 业务逻辑实体，例如支付service方法调用支付方法传递组合参数| | | | |─properties ------ 自动配置properties实体| | | |─factory ------ 自定义工厂类| | | |─event ------ 自定义事件| | | |─listener ------ 事件监听器| | | |─convert ------ 自定义类型转换器| | | |─handler ------ 处理器类| | | |─security ------ spring security安全控制| | | |─utils ------ 自定义工具类| |─resources| | |─db ------ 数据库sql| | |─mapper ------ mybatis自定义mapper xml| | |─templates ------ 模板文件例如邮件模板|─test| |─java| | |─com.happyland.ums| | | |─service ------ service层单元测试类| | | |─utils ------ 自定义工具单元测试类 @PostConstruct 实操 @PostConstruct 是个类初始化后执行的钩子注解，用来执行类初始化之后、类正式投入之前需要执行的方法 在非拦截器类上定义的方法必须具有以下签名：void &lt;METHOD&gt;（）应用PostConstruct的方法可以是public，protected，package private或private。 关于类初始化@PostConstruct 、@Autowired和Construct构造函数 顺序为：1.构造函数 &gt; 2.@Autowired &gt; 3.@PostConstruct 。 如果一个类BeanA中上述三者都有，且@Autowired注入的类BeanB中也都有上述三者，则调用顺序为： 123456&gt; 这是 Bean A 的构造方法&gt; 这是 Bean B 的构造方法&gt; 这是 Bean B 的 init 方法&gt; 这是 Bean A 的 init 方法&gt; 这是 Bean B 的 testB 方法&gt; 1234567891011121314151617/** * @description: MQTT配置类 * @author: MrLi * @create: 2021-10-11 18:23 **/@PropertySource(\"classpath:mqtt.properties\")@Componentpublic class MqttConfiguration &#123; @Value(\"$&#123;url&#125;\") public String host; @Value(\"$&#123;consumer.defaultTopic&#125;\") public String topic; @Value(\"$&#123;username&#125;\") public String name; @Value(\"$&#123;password&#125;\") public String passWord;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// MQTT客户端实例，其中配置是通过MqttConfiguration拿到的。先执行IotMqttClient的构造函数（无），然后执行@Autowired的mqttConfiguration，然后拿到mqttConfiguration实例对象后执行IotMqttClient自身@PostConstruct的init函数，完成连接@Slf4j@Componentpublic class IotMqttClient &#123; @Autowired private MqttConfiguration mqttConfiguration; private MqttClient client; private static List&lt;String&gt; subedTopics = new ArrayList&lt;&gt;(); @PostConstruct public void init() &#123; // clientId不能重复所以这里我设置为系统时间 String clientId = String.valueOf(System.currentTimeMillis()); int qos = 0; try &#123; // host为主机名，clientid即连接MQTT的客户端ID，一般以唯一标识符表示，MemoryPersistence设置clientid的保存形式，默认为以内存保存 client = new MqttClient(mqttConfiguration.host, clientId, new MemoryPersistence()); // 设置回调 client.setCallback(new ReportMqtt(this)); client.connect(makeUpMqttOption()); subscribe(mqttConfiguration.topic, qos); &#125; catch (Exception e) &#123; log.info(\"ReportMqtt客户端连接异常，异常信息：\" + e); &#125; &#125; private MqttConnectOptions makeUpMqttOption() &#123; // MQTT的连接设置 MqttConnectOptions options = new MqttConnectOptions(); // 设置是否清空session,这里如果设置为false表示服务器会保留客户端的连接记录，这里设置为true表示每次连接到服务器都以新的身份连接 options.setCleanSession(true); // 设置连接的用户名 options.setUserName(mqttConfiguration.name); // 设置连接的密码 options.setPassword(mqttConfiguration.passWord.toCharArray()); // 设置超时时间 单位为秒 options.setConnectionTimeout(10); // 设置会话心跳时间 单位为秒 服务器会每隔1.5*20秒的时间向客户端发送个消息判断客户端是否在线，但这个方法并没有重连的机制 options.setKeepAliveInterval(3600); return options; &#125; /** * 发布，默认qos为0，非持久化 */ public void publish(String topic, String pushMessage) &#123; publish(0, false, topic, pushMessage); &#125; /** * 发布 */ public void publish(int qos, boolean retained, String topic, String pushMessage) &#123; MqttMessage message = new MqttMessage(); message.setQos(qos); message.setRetained(retained); message.setPayload(pushMessage.getBytes()); MqttTopic mTopic = client.getTopic(topic); if (null == mTopic) &#123; log.error(\"topic not exist\"); &#125; try &#123; MqttDeliveryToken token = mTopic.publish(message);// token.waitForCompletion(); &#125; catch (MqttPersistenceException e) &#123; e.printStackTrace(); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; /** * 订阅某个主题，qos默认为0 */ public void subscribe(String topic) &#123; subscribe(topic, 0); subedTopics.add(topic); &#125; /** * 订阅某个主题 */ public void subscribe(String topic, int qos) &#123; try &#123; client.subscribe(topic, qos); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Web","slug":"Web","permalink":"https://nymrli.top/tags/Web/"}]},{"title":"如何成为一位老司机——考驾照经历","slug":"如何成为一位老司机——考驾照经历","date":"2019-09-14T04:32:33.000Z","updated":"2019-09-15T08:07:31.044Z","comments":true,"path":"2019/09/14/如何成为一位老司机——考驾照经历/","link":"","permalink":"https://nymrli.top/2019/09/14/如何成为一位老司机——考驾照经历/","excerpt":"","text":"如何成为一位老司机——考驾照经历 大一下报的名，几经转折，终于在2019-9-12，中秋放假前一天拿到了本本。 科一理论考试 太久远了，已经忘记了… 科二 训练 倒车入库： 左边小镜子底座盖过黄线，向左打死。 正手倒车时，靠近左边直角距离3个手指回正，然后看左边镜子出现直角，然后。 左手是一到二指头。 ▲入库重在自己调整，记住准则：左右镜子，哪边空隙大，方向盘往哪边打 小四项： 直角转弯: 人在路中间，直角重合于车窗黑线后向左打死。 S弯道： 确保人在路中间，可以略微偏左。左边小镜子底座压住右边黄线。方向盘一圈右手放在2点方向。如果黄线偏下，那么往1点方向调整，否则往3点方向调整。然后保持到车头中间碰到左边黄线回正；然后向前一小段距离，使得右边镜子与黄线只差一条线的距离，然后向右一圈，左手11点，保持小镜子与黄线夹角是钝角，然后一直保持到项目结束。 坡道停车： 对准坡道上的黄线大约在车头的右边三分之一处。上去之后，保持黄线在小镜子的左边三分之一处，大约与车身成三角形，接近接触。 侧方停车： 车头盖过蓝线后看右边后视镜，到第二根白线在后视镜中央开始倒车，直至消失时，向右一圈到11点，然后保持直至右边的黄线跑到两个把手的中间时回正，接着看左边，头伸出一点，看后车轮压倒虚线时立马向左打死，然后直至车身完全进入。 出去时，左方向灯和换1档，缓速出来，等到车头中央碰到黄线时回正，然后稍微开个0.5s向后一圈左右，车身回正。 视频资源——SXH科二教练,提取码：gvqa 考试 我考的是6号线，也就是S弯结束后立马是直角的那条线。考试的直角给我的感觉是比谷峰训练的时候多很多，所以其实不用担心。至于这个S弯结束后立马是直角，根据模拟的时候开就行了，即出来就向右打死，然后开到路中间 科三 灯光+上路行驶 训练 灯光 起步和靠边停车 图片来自于科三教练——杨作栋 考试 科三比科二简单很多。科二10节课，科三只有8节也能说明一二。但感觉科三与科二最不同的地方是，科三记的点比科二自然很多。在转头看左右后视镜，我在临近考试的最后两天最后一节课上才练的，一开始觉得右边的后视镜为什么离得那么远，跑了两圈后就发现，看后视镜是件很自然的事，因为你就需要右边的信息。 而在考试过程中，虽然有安全员在旁边，可能会比科二紧张一些，但是整体上来讲，科三还是很容易的，只要记得，每次完成一个东西后，左右看后视镜基本上就行了。 ▲.我考试的时候，前面有个挂了的人倒是补上了我一个盲点，原来提示前方路口后，如果你打了右方向灯，那么接着往后看。之前我还以为只有真过路口、点刹的时候才需要。只不过面对这种现象，还是之前说的，不管做了什么，左右摇头就是了。 挂到五档也不用担心，我当时考试时有两条路的路况绝对算不上好，但是我一共还是3次挂到了五档，所以其实升挡的机会还是很多的。 最后，需要注意的是灯光一定不能错。我是第三个考的，第一个女生灯光挂了一次；第二个男生，起步没打左方向灯，也挂了。 科四理论考试 刷了1280道题，由于有10道多选题的存在，所以真正考试的时候还是比较慌的，一上来就错了两题，最终考了94.","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"软件测试大赛","slug":"软件测试大赛","date":"2019-09-14T04:07:12.000Z","updated":"2019-11-02T02:05:41.344Z","comments":true,"path":"2019/09/14/软件测试大赛/","link":"","permalink":"https://nymrli.top/2019/09/14/软件测试大赛/","excerpt":"","text":"软件测试大赛 初学流程 首先了解比赛,查看帮助文档平台帮助 然后在工具下载中下载工具、eclipse插件 最后根据教程中将插件安装好即可 移动应用测试开发 环境配置 配置Java环境 略,见Java 开发环境配置_菜鸟教程 安装ADB 1.菜单——&gt;Tools——&gt;Settings，将Server地址为 mirrors.neusoft.edu.cn， 端口 80 ，并且在Others里勾选 Force https://…,最后一定要选择菜单——&gt;Packages菜单——&gt;Reload 注:其他可用的镜像 2.把 Android SDK 路径下的tools 和 platform-tools 两个目录路径加入到系统环境变量 Path 3.在终端(cmd)输入命令 adb ，回车，输出 adb 版本和帮助信息说明环境配置成功 安装Node.js 略 安装Appium 1)下载安装文件： http://pan.baidu.com/s/1jGvAISu Windows 下载zip文件，MAC请下载dmg 2)直接双击appium-installer.exe文件安装就好(务必记住安装路径)，桌面会生成一个Appium的图标 此时已经可以通过Appium在桌面快捷方式启动Appium桌面应用程序，并点击应用程序右上侧启动状按钮启动Appium，若成功启动会输出数行[info]级别的日志，打印出Appium server启动成功后占用的端口。 如果无法显示appium-doctor,可以npm install -g appium安装 UIautomatorviewer使用 Android 4.1发布的，uiautomator是用来做UI测试的。也就是普通的手工测试，点击每个控件元素 看看输出的结果是否符合预期。比如 登陆界面 分别输入正确和错误的用户名密码然后点击登陆按钮看看是否能否登陆以及是否有错误提示等。 找到Andriod sdk安装目录下的uiautomatorviewer.bat,E:\\android-sdk-windows\\tools\\uiautomatorviewer.bat,双击打开 由于自动获得手机信息失败,因此我只能通过手工进行获取 123Error obtaining UI hierarchyReason:Error while creating temporary file to save snapshot:null 自动导入成功的结果： 手工获取手机信息 据说Andriod8.0以上就无法使用uiautomator直接连接了，因此需要截图一步步操作 123456# dump资源文件 再导出到本地$ adb shell uiautomator dump$ adb pull /sdcard/window_dump.xml# 获取截图 导出$ adb shell screencap -p /data/local/tmp/app.png$ adb pull /data/local/tmp/app.png . 或者编写bat脚本 1234567@echo onadb shell uiautomator dump /sdcard/app.uixadb pull /sdcard/app.uix .adb shell screencap -p /sdcard/app.pngadb pull /sdcard/app.png . 传到Window里，有了截图文件和资源文件，点击UI Automator Viewer菜单栏第一个图标手工导入后即可解析，分析UI 获取快照 当你要分析一个页面时，首先将手机的页面停留在你要分析的页面，然后用数据线连接电脑。 页面层级 右上方的整个区域，就是当前页面布局的层级关系 不可用区域 右上方的整个区域中的第二个按钮Toggle NAF Nodes，按下后出现的黄色区域代表，这些控件是不被Uiautomator工具识别，无法获取到这些控件的实例 属性详情： 右下方的整个区域，是当前选中的页面或者是控件的属性信息。写代码的时候就是需要通过查看属性中的控件的id或者是text等来获取控件的实例，然后点击操作它。 编写脚本 创建项目：创建新的Java项目(注意不是Android项目)。在该项目中来创建测试代码。 导入库和包：在Project Explorer视图中，右键点击测试项目，选择“ Properties &gt; Java Build Path”，然后选择“Libraries” tab界面。在“Libraries”界面选择“ Add Library &gt; JUnit”来添加JUnit3 库；然后点击“Add External JARs… ”并导航到Android SDK目录。选择platforms目录下面的 uiautomator.jar 和 android.jar文件。 uiautomatorviewer uiautomatorviewer详解、脚本介绍 踩坑记录 报错adb devices: list of devices attached unauthorized 设置-&gt;更多设置-&gt;开发者选项-&gt;撤销USB调试授权-&gt;重新授权即可 offline 12$ adb kill server$ adb start server ▲. AC-&gt;Activity coverage、WC-&gt;Widget coverage 开发者测试 同样需要配置Java sdk和Andriod SDK环境,除此之外还需要配置maven 配置maven 1.在maven官网下载 apache-maven-3.6.2-bin.zip后解压,根据视频配置好maven 2.发现最初安装eclipse时没有安装maven,于是安装maven.菜单–&gt;windwos–&gt;install new software–&gt;输入 http://download.eclipse.org/technology/m2e/milestones/1.4后回车 环境配置好后,测试一下 branchscore是主要评分规则 变异得分无法实时查看，使用选手最后一次的提交脚本统一运行 Junit使用 DEMO坑点记录: 1.JUnit4和JRE1.7配套使用,Junit5需要8以上。而JUnit4和JUnit5都不支持JRE11，所以当时我的报错是The import org.apache cannot be resolved. 2.右键项目-&gt;build path -&gt; Config build path -&gt; Libraries后还是报错,java.lang.NoClassDefFoundError: org/junit/runner/manipulation/Filter…解决方法是:①菜单栏-&gt;projects-&gt;clean②build path -&gt; Config build path -&gt; Libraries-&gt;remove重新导入Junit③运行OK 编写规范 1.测试方法上必须使用@Test进行修饰 2.测试方法必须使用public void 进行修饰，不能带任何的参数 3.新建一个源代码目录来存放我们的测试代码 4.测试类的包应该和被测试类保持一致 5.测试单元中的每个方法必须可以独立测试，测试方法间不能有任何的依赖 6.测试类使用Test作为类名的后缀（不是必须） 7.测试方法使用test作为方法名的前缀（不星必须）| 运行流程 1.@BeforeClass修饰的方法会在所有方法被调用前被执行，而且该方法是静态的，所以当测试类被加载后接着就会运行它，而且在内存中它只会存在一份实例，它比较适合加载配置文件。 2.@AfterClass所修饰的方法通常用来对资源的清理，如关闭数据库的连接 3.@Before和@After会在每个测试方法即(@Test修饰的方法函数)的前后各执行一次。 @Test：将一个普通的方法修饰成为一个测试方法 @Test（expected=XX.class） 12345@Test(expected=ArithmeticException.class)private void divided() &#123; // TODO Auto-generated method stub assertEquals(0, new calculate().divide(6, 0));&#125; @Test（timeout=毫秒） @BeforeClass：它会在所有的方法运行前被执行，static修饰 @AfterClass：它会在所有的方法运行结束后被执行，static修饰 @Before：会在每一个测试方法被运行前执行一次 @After：会在每一个测试方法运行后被执行一次 @lgnore：所修饰的测试方法会被测试运行器忽略 @RunWith：可以更改测试运行器org.junit.runner.Runner 测试套件 1.测试套件就是组织测试类一起运行的 写一个作为测试套件的入口类，这个类里不包含其他的方法 更改测试运行器Suite.class 将要测试的类作为数组传入到Suite.SuiteClasses（0） 12345678910111213141516171819202122/** * Project Name:softTest * File Name:SuiteTest.java * Package Name:com.test.demo * Date:2019年9月15日下午1:57:13 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.test.demo;import static org.junit.Assert.*;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Suite;import org.junit.runners.Suite.SuiteClasses;@RunWith(Suite.class)@Suite.SuiteClasses(&#123;calculateTest.class&#125;)public class SuiteTest &#123;&#125; 参数化设置 1.更改默认的测试运行器为RunWith（Parameterized.class） 2.声明变量来存放预期值和结果值 3.声明一个返回值为Collection的公共静态方法，并使用@Parameters进行修饰 4.为测试类声明一个带有参数的公共构造函数，并在其中为之声明变量赋值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Project Name:softTest * File Name:parameterTest.java * Package Name:com.test.demo * Date:2019年9月15日下午2:06:38 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.test.demo;import static org.junit.Assert.assertEquals;import java.util.Arrays;import java.util.Collection;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters;@RunWith(Parameterized.class)public class parameterTest &#123; private int expected = 0; private int input1 = 0; private int input2 = 0; @Parameters // 给构造函数赋值的时候被调用的 public static Collection&lt;Object[]&gt; t() &#123; return Arrays.asList(new Object[][] &#123; &#123;3,1,2&#125;, &#123;4,2,2&#125;, &#125;); &#125; public parameterTest(int expected, int input1, int input2) &#123; this.expected = expected; this.input1 = input1; this.input2 = input2; &#125; @Test public void testAdd() &#123; assertEquals(expected, new calculate().add(input1, input2)); &#125;&#125; 注意点： 定位控件的参数选择要求： 对脚本控件定位参数的选择要追求在要求范围内的唯一性： 参数选择优先级：控件 Resource-id (driver.findElementById())&gt; 控件 XPath(driver.findElementByXPath()) id举例：com.floral.life:id/tv_title Xpath举例：//android.widget.TextView[@text='鲜切花 ']，▲.(此处’鲜切花 '的花字后面还有一个空格，所以不要自己输入属性值，应该直接把在 UI Automator Viewer 中的值直接拷贝到代码中去)。 Xpath选择时，首要选择 text、content-desc 这种特殊性较强的属性值，不要选择 index、bounds 这种多个控件极易相同(即未满足全局唯一)的属性值。 脚本中使用 XPath 进行定位时，务必与脚本编写要求中的 XPath 格式完全一致，即//控件类名[@控件属性名='控件属性值']不要使用//*[@控件属性名='控件属性值']等一系列其他格式 脚本中不要使用 driver.findElementsByxxx()一类的方法，不要用该方法 定位多个控件得到一个 list 再循环来操作 list 中控件(除非该控件的 XPath都不能满足在测试范围内的全局唯一)。 脚本中允许自定义函数，但对于 driver.findElementById()这类原生方法，不要进行封装。 逻辑上是一句话的代码务必写在一行内，不要在函数的参数处换行。 编程建议: 必须使用断言 确认最后提交的测试用例全部正确， Webide或者客户端能运行得分 使用setup()和teardown()方法进行环境初始化 使用timeout限制测试用例运行时间，避免测试用例出现无响应情况 Evosuite生成的捕获异常的自动测试用例，可能导致变异无法跑通， 学生自己注意 测试点注意事项: 对double类型进行判断 123456@Testpublic void test()&#123; double a = 1.0; assertEquals(1.0,a,0.00001) // bingo //assertEquals(1.0,a,0.00001) wrong&#125; 对控制台输出进行测试 12345678910111213141516171819202122232425262728293031323334import static org.junit.Assert.*;public class BinPackageTest&#123; String sep； BinPackage bp； PrintStream console=null； ByteArray InputStream in=null； ByteArrayOutputStream out=null； InputStream input=null；@Beforepublic void setUp()throws Exception &#123; bp=new BinPackage()； out=new ByteArrayoutputstream()； input=System.in； console=System.out； System.setout(new PrintStream(out))； sep=System.getProperty(\"line.separator\")；&#125; @Afterpublic void tearDown()throws Exception &#123; System.setIn(input)； out.close()； System.setout(console)；&#125;@Test(timeout=4000) public void test1()&#123; in=new ByteArrayInputStream((\"2\"+sep+\"12\"tsep +\"3\"+sep+\"211\"+sep+\"222\"+sep+\"232\").getBytes())； System.setIn(in)； bp.entrance()； string ans=out.tostring()； assertEquals(\"false\"+ sep+\"true\"+sep+\"22\"+sep+\"false\"+sep，ans)；&#125; 对异常报错进行测试 1234567891011121314151617181920212223import static org.junit.Assert.*;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;public class AccountTest&#123; private static final double DOUBLE_DELTA=1e-15; @Rule public ExpectedException thrown=ExpectedException.none(); @Test(timeout=4000) public void test1()&#123; Bank bank=new Bank(); Account checkingAccount=new Account(Account.CHECKING); Customer bill=new Customer(\"Bi11\").openAccount(checkingAccount); bank.addCustomer(bil1); thrown.expect(I1legalArgumentException.class); thrown.expectMessage(\"amount must be greater than zero\"); checkingAccount.withdraw(-100.e); &#125;&#125; Nextday 参数化单元测试(测试用例)设计 附录 更新mooctest插件：mooctest.net_plugin 在官网下载最新的插件mooctest.net_plugin.zip后解压，然后打开eclipse中的Help-&gt;Install new software-&gt;add-&gt;local-&gt;选择解压文件夹，安装即可 adb unauthorized 1.使用adb连接手机时，即使打开了usb调试，手机添加了信任，仍然出现unauthorized的提示 2.C:\\Users\\(Username)\\.android里面删掉adbkey和adbkey.pub两个文件(没添加过信任的话是没有的)，然后重新插拔手机 执行： 12adb kill-serveradb start-server △如果上述方式还是无效的话，选择“开发者测试”-&gt;&quot;调试&quot;中的撤销USB调试授权，然后重新上述操作","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"软件测试","slug":"软件测试","permalink":"https://nymrli.top/tags/软件测试/"}]},{"title":"Java自动化构建工具——Maven","slug":"Java自动化构建工具——Maven","date":"2019-09-13T03:45:50.000Z","updated":"2021-12-30T08:29:58.077Z","comments":true,"path":"2019/09/13/Java自动化构建工具——Maven/","link":"","permalink":"https://nymrli.top/2019/09/13/Java自动化构建工具——Maven/","excerpt":"","text":"Java自动化构建工具——Maven 目前的技术在开发中存在的问题、Maven作用 ①一个项目就是一个工程 如果项目非常庞大，就不适合继续使用package来划分模块。最好是每一个模块对应一个工程，利于分工协作。 △借助于Maven就可以将一个项目拆分成多个工程。 ②项目中需要的jar包必须手动“复制”、“粘贴”到WEB-INF/lib目录下 带来的问题是：同样的jar包文件重复出现在不同的项目工程中，一方面浪费存储空间，另外也让工程比较臃肿。 △借助Maven，可以将jar包仅仅保存在“仓库”中，有需要使用的工程“引用”这个文件接口，并不需要真的把jar包复制过来。 ③jar包需要别人替我们准备好，或到官网下载 不同技术的官网提供jar包下载的形式是五花八门的。 有些技术的官网就是通过Maven或SVN等专门的工具来提供下载的。 如果是以不规范的方式下载的jar包，那么其中的内容很可能也是不规范的。 △借助于Maven可以以一种规范的方式下载jar包。因为所有知名框架或第三方工具的jar包以及按照统一的规范存放在了Maven的中央仓库中。 以规范的方式下载的jar包，内容也是可靠的。 ④一个jar包依赖的其他jar包需要自己手动加入到项目中 FileUpload组件→IO组件。commons-fileupload-1.3.jar依赖于commons-io-2.0.1.jar。如果所有jar包之间的依赖关系都需要程序员自己非常清楚的了解，那么就会极大的增加学习成本。 △Maven会自动将被依赖的jar包导入进来。 Maven是什么[What] ①Maven是一款服务于Java平台的自动化构建工具。 Make→Ant→Maven→Gradle妹文、麦文 ②构建 [1]概念：以&quot;ava源文件”、“框架配置文件”、&quot;JSP”、“HTML”、“图片”等资源为“原材料”，去“生产”一个可以运行的项目的过程。 编译 部署 搭建 [2]编译：Java源文件[User.java]→编译→Class字节码文件[User.class]→交给JVM去执行 [3]部署：一个BS项目最终运行的并不是动态Web工程本身，而是这个动态Web工程“编译的结果&quot; 生的鸡→处理一熟的鸡 动态Web工程→编译、部署→编译结果 构建过程中的各个环节 [1]清理：将以前编译得到的旧的class字节码文件删除，为下一次编译做准备 [2]编译：将Java源程序编程成class字节码文件 [3]测试：自动测试，自动调用junit程序 [4]报告：测试程序执行的结果 [5]打包：动态Web工程打war包，Java工程打jar包 [6]安装：Maven特定的概念——将打包得到的文件复制到“仓库”中的指定位置 [7]部署：将动态Web工程生成的war包复制到Servlet容器的指定目录下，使其可以运行 常用Maven命令 ①注意：执行与构建过程相关的Maven命令，必须进入pom.xml所在的目录。 与构建过程相关：编译、测试、打包、…… ②常用命令 [1]mvn clean：清理 [2]mvn compile：编译主程序 [3]mvn test-compile：编译测试程序 [4]mvn test：执行测试 [5]mvn package：打包 联网问题 ①Maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含在Maven的核心程序中。 ②当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。 ③本地仓库的默认位置：[系统中当前用户的家目录]/.m2/repository 如C:/Users/[登录当前系统的用户名]/.m2/repository ④Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载。 ⑤如果此时无法连接外网，则构建失败。 ⑥修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找插件 [1]找到Maven解压目录/conf/settings.xml [2]在settings.xml文件中找到localRepository标签 [3]将&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;从注释中取出E:/apache-maven-3.6.2/MavenRepo [4]将标签体内容修改为已经准备好的Maven仓库目录 补充: 换镜像,可以在settings.xml的第153行左右,设置阿里云镜像 123456&lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 介绍Maven的视频 宏变量 工程版本号 12345&lt;dependency&gt; &lt;groupId&gt;top.nymrli.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;&lt;/dependency&gt; 属性_版本号 123456789101112131415161718192021222324 &lt;!--统一管理jar包和版本--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;mysql.version&gt;8.0.18&lt;/mysql.version&gt; &lt;druid.verison&gt;1.1.16&lt;/druid.verison&gt; &lt;mybatis.spring.boot.verison&gt;1.3.0&lt;/mybatis.spring.boot.verison&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;!-- 需要注意的是 $&#123;xxxx&#125;大括号中不支持空格--!&gt; maven的传递、冲突、聚合 依赖传递 有三个项目：ABC 12345A| B|C B是依赖A的，C又是依赖B的，所以依赖传递，C也是依赖A的 A B 项目打成jar包到本地仓库中： clean package(打成jar包) =&gt; install（jar包安装到本地仓库） clean compile(编译) pom.xml文件中的依赖配置 12345678910111213B是依赖A的，在B的pom.xml文件中写入A的坐标 &lt;dependency&gt; &lt;groupId&gt;com.A&lt;/groupId&gt; &lt;artifactId&gt;A-model&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSNOTL&lt;/version&gt; &lt;/dependency&gt; ------------------------------------ C是依赖B的,在C的pom.xml文件中写入B的坐标 &lt;dependency&gt; &lt;groupId&gt;com.B&lt;/groupId&gt; &lt;artifactId&gt;B-model&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSNOTL&lt;/version&gt; &lt;/dependency&gt; A、B、C项目各自打包、编译，在C的项目的Maven dependencies引入中不仅会引入B，而且还会引入A项目，这就是依赖的传递。 如果项目C只想依赖B，不想依赖A怎么办？ 排除依赖：exclusions 12345678&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.A&lt;/groupId&gt; &lt;artifactId&gt;A-model&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSNOTL&lt;/version&gt; &lt;exclusion&gt;&lt;exclusions&gt; 这样在C项目编译后compile，就排出对A的依赖 Maven依赖冲突 原则1：短路优先，如果A需要导入一个依赖X，在路径中选择最短的。 原则2：在路径相同时，先声明先优先。如果A需要导入一个依赖X，1、2路线相同，在A中的pom.xml先声明B（C），就引入B（C）的X(jar)。 1234567在传递依赖的原则下，A-&gt;B-&gt;C-&gt;X(jar) 路线1 A-&gt;D-&gt;X(jar) 路线2 --原则1：短路优先，如果A需要导入一个依赖X，在路径中选择最短的。 在传递依赖的原则下，A-&gt;B-&gt;X(jar) 路线1 A-&gt;C-&gt;X(jar) 路线2 --原则2：在路径相同时，先声明先优先。如果A需要导入一个依赖X，1、2路线相同，在A中的pom.xml先声明B（C），就引入B（C）的X(jar)。 Maven项目的聚合 在D项目中聚合 ABC三个项目，D的pom.xml文件如下所示 12345678910 1. 指定package格式&lt;package&gt;pom&lt;/package&gt; ...2. 设定子模块名 &lt;modules&gt; &lt;module&gt;../模块名&lt;/module&gt; &lt;module&gt;../模块名&lt;/module&gt; &lt;module&gt;../模块名&lt;/module&gt; &lt;/moules&gt;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"}]},{"title":"打jar包和使用jar包","slug":"打jar包和使用jar包","date":"2019-09-13T03:45:11.000Z","updated":"2019-09-15T08:07:31.064Z","comments":true,"path":"2019/09/13/打jar包和使用jar包/","link":"","permalink":"https://nymrli.top/2019/09/13/打jar包和使用jar包/","excerpt":"","text":"打jar包和使用jar包 一、为什么要打jar包 给别人用的时候一般给别人的是class文件。如果有很多类这么办？把类变成一个压缩包！windows下的压缩包是.zip格式等，而eclipse压缩包是.jar格式。 二、如何查看jar包 用解压缩软件解压即可。可以看到里面有哪些class文件。 三、如何开发jar包 开发jar包的人员开发流程： 步骤1:编写类 12345678//GetSum.javapackage cn.itcast.sum;public class GetSum&#123; public static getSum(int a,int b)&#123; return a+b; &#125;&#125; 步骤2:打包成jar包 在要导出的类上,右键-&gt;Export-&gt;java -&gt; JAR file,然后选择路径,如D:/sum.jar -&gt;导出。 打开jar包可以看到jar包中含有class文件。 四、如何使用jar包 当别人发过来一个jar包(jar包里面有很多class文件)后，比如上面的sum.jar包，如何使用呢？ 有两种方法。第一种方法一般不用，太low了。 使用方法一：这个方法太low了，不用 步骤1:编写Test.java文件 123456789//Test.javaimport cn.itcast.sum.*;//光设置classpath的环境变量还是不够，还要导入包 public class Test&#123; public static void main(String[] args)&#123; int a = GetSum.getSum(1,2); System.out.println(); &#125;&#125; 步骤2:在cmd窗口中使用 123&gt;set classpath = D:/sum.jar; //设置环境变量，知道在哪里找jar包。只在当前的窗口有效。&gt;javac Test.java&gt;java Test 使用方法二：一般使用这个方法 步骤1:在工程目录下新建文件夹lib：File-&gt;New-&gt;Folder,文件名lib，将需要使用的jar包复制进去（ctrl c、ctrl v）。在工程上右键刷新就可以看到jar包了 步骤2:在需要使用的jar包上，右键-&gt;build path -&gt;Add to build Path，发现多了一个小奶瓶～ 步骤3:编写测试类Test.java 123456789//Test.javaimport cn.itcast.GetSum;//不用自己导入。当下面输入GetSum.getSum()时候，按Ctrl+Shift+o自动输入包名。public class Test&#123; public static void main(String[] args)&#123; int a = GetSum.getSum(1,2); //直接使用jar包下面的class类 System.out.println(); &#125;&#125; 注意： 鼠标点到getSum()上，然后按F3，是看不到源码的。出现下面这种界面。这是因为源码不在jdk里面。 可以点击Attach Source按钮，然后点击&quot;External File…&quot;或者&quot;External Folder&quot;找到jar包对应的源码。（jar包中有class文件，并不是源码。）","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"}]},{"title":"验证码识别程序设计流程","slug":"验证码识别程序设计流程","date":"2019-09-09T13:31:35.000Z","updated":"2019-10-07T10:17:04.838Z","comments":true,"path":"2019/09/09/验证码识别程序设计流程/","link":"","permalink":"https://nymrli.top/2019/09/09/验证码识别程序设计流程/","excerpt":"","text":"验证码识别程序设计流程 以南邮正方教务系统为例 找到验证码图片的链接 “http://jwxt.njupt.edu.cnCheckCode.aspx” 1234567def getCaptcha(): CAPTCHA_URL = \"http://jwxt.njupt.edu.cn/CheckCode.aspx\" r = requests.get(CAPTCHA_URL) img = r.content img = Image.open(BytesIO(img)) return img 对图片去噪 12345678910111213141516171819202122232425def image_pre_process(self): # 去除杂色点 for x in range(self.image.width): for y in range(self.image.height): pix = self.image.getpixel((x, y)) if pix == 43: self.image.putpixel((x, y), WHITE) else: self.image.putpixel((x, y), BLACK) # 去除单像素噪点并进行二值化(八值法) for x in range(self.image.width): for y in range(self.image.height): count = 0 if x != 0 and y != 0 and x != self.image.width - 1 and y != self.image.height - 1: for i in range(-1, 2): for j in range(-1, 2): tx = x + i ty = y + j if self.image.getpixel((tx, ty)) == BLACK: count += 1 if self.image.getpixel((x, y)) == WHITE and count == 8: # 如果一个白色区域的附近八连通区域都是黑色,那么该点也认为是黑色 self.image.putpixel((x, y), BLACK) self.image = self.image.convert('1') △二值化:将需要识别的蓝色字符(43)转为白色(WHITE),其他的全部变为黑色(BLACK) 二值化的过程需要灵性一点,不能直接用convert函数,那样的效果并不理想。 直接convert的效果: 先对蓝色43进行二值化，然后去单点噪声、最后二值化的效果： 设计打码程序设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566\"\"\"方便收集验证码的简单打码工具\"\"\"import tkinterfrom io import BytesIOimport requestsfrom PIL import Image, ImageTkfrom bs4 import BeautifulSoupclass CaptchaGUI: captcha_url = \"http://jwxt.njupt.edu.cn/CheckCode.aspx\" login_url = \"http://jwxt.njupt.edu.cn/default2.aspx\" def __init__(self): self.s = requests.session() self.get_viewstate() self.r = self.s.get(self.captcha_url) self.im = Image.open(BytesIO(self.r.content)) self.root = tkinter.Tk() self.tkimg = ImageTk.PhotoImage(self.im) self.imgLabel = tkinter.Label(self.root, image=self.tkimg) self.imgLabel.pack() self.message = tkinter.Entry(self.root) self.message.pack() self.root.bind('&lt;Return&gt;', self.judge_and_save) self.root.mainloop() def get_viewstate(self): r = self.s.get(self.login_url) soup = BeautifulSoup(r.content, \"lxml\") self.viewstate = soup.find('input', attrs=&#123;\"name\": \"__VIEWSTATE\"&#125;).get(\"value\") def judge_and_save(self, event): captcha_value = self.message.get() print(captcha_value) data = &#123; \"__VIEWSTATE\": self.viewstate, 'txtUserName': \"\", # 账号 'TextBox2': \"\", # 密码 'RadioButtonList1': \"%D1%A7%C9%FA\", \"Button1\": \"\", \"txtSecretCode\": captcha_value, \"hidPdrs\": \"\", \"hidsc\": \"\" &#125; r = self.s.post(self.login_url, data=data) if \"请到信息维护中完善个人联系方式\" in r.text: print(\"成功！\") with open(\"captchas/&#123;&#125;.gif\".format(captcha_value), 'wb+') as f: f.write(self.r.content) else: print(\"验证码输错了\") self.get_viewstate() self.r = self.s.get(self.captcha_url) self.im = Image.open(BytesIO(self.r.content)) self.tkimg = ImageTk.PhotoImage(self.im) self.imgLabel.config(image=self.tkimg) self.message.delete(0, 'end')if __name__ == \"__main__\": captcha_gui = CaptchaGUI() 将结果分割到每个字符 123456def handle_split_image(self): # 切割验证码，返回包含四个字符图像的列表 y_min, y_max = 0, 22 split_lines = [5, 17, 29, 41, 53] ims = [rotate_img(self.image.crop([u, y_min, v, y_max])) for u, v in zip(split_lines[:-1], split_lines[1:])] return ims 123456789101112131415161718192021222324def spilt2chars(): \"\"\" 分割已有的数据为字符并保存 \"\"\" try: shutil.rmtree('captcha_chars') except: pass os.mkdir(\"captcha_chars\") values = \"abcdefghijklmnopqrstuvwxyz1234567890\" for value in values: os.mkdir('captcha_chars/&#123;&#125;'.format(value)) file_names = os.listdir('captchas') for file_name in file_names: # if not os.path.isdir(file_name) and file_name != '.DS_Store': values = file_name[:4] im = Image.open('captchas/&#123;&#125;'.format(file_name)) captcha = ZhengfangCaptcha(im) # 用的是去噪、二值化的图片 for im_part, value in zip(captcha.handle_split_image(), values): m = hashlib.md5() m.update(\"&#123;&#125;&#123;&#125;\".format(time.time(), value).encode('utf8')) im_part.save(\"captcha_chars/&#123;&#125;/&#123;&#125;.png\".format(value, m.hexdigest())) 保存模型数据 12345678910111213141516if __name__ == \"__main__\": # spilt2chars() letters = list('qwertyuiopasdfghjklzcxvbnm1234567890') # 将图像数据转为向量数据并保存 imageset = [] for letter in letters: try: for img in os.listdir('captcha_chars/&#123;&#125;/'.format(letter)): if img != \"Thumbs.db\" and img != \".DS_Store\": vector = ZhengfangCaptcha.buildvector(Image.open(\"captcha_chars/&#123;&#125;/&#123;&#125;\".format(letter, img))) imageset.append(&#123;letter: vector&#125;) except FileNotFoundError as e: pass with open('image_data.json', 'w') as f: json.dump(imageset, f) 识别 辅助函数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import mathimport operatorfrom functools import reduceBLACK = 0WHITE = 255def magnitude(concordance): total = reduce(operator.add, map(lambda x: x ** 2, concordance)) return math.sqrt(total)# 计算矢量之间的余弦距离def distance_cos(vector1, vector2): sum_value = 0 for value1, value2 in zip(vector1, vector2): sum_value += value1 * value2 return 1 - sum_value / (magnitude(vector1) * magnitude(vector2))def distance_hanmming(vector1, vector2): \"\"\" 计算两向量的汉明距，（向量只包含0，1时） \"\"\" count = 0 for value1, value2 in zip(vector1, vector2): if value1 != value2: count += 1 return countdef build_vector(image, binary=True): \"\"\" 图像转一维特征向量 :param image: pillow Image object with mode 1 or mode L :param binary: 黑白图是否生成为0，1向量 :return: list of int \"\"\" vector = [] for pixel in image.getdata(): if binary: vector.append(1 if pixel == 255 else 0) else: vector.append(pixel) return vectordef rotate_img(image): \"\"\" 根据图像在x轴方向投影大小确定字符的摆放方向 :param image: PIL.Image object :return: rotated Image object \"\"\" min_count = 1000 final_angle = 0 for angle in range(-45, 45): x_count = 0 ti = image.rotate(angle, expand=True) for x in range(ti.width): for y in range(ti.height): if ti.getpixel((x, y)) == WHITE: x_count += 1 break if x_count &lt; min_count: min_count = x_count final_angle = angle image = image.rotate(final_angle, expand=False) return image 识别部分: 1234567891011121314151617181920212223242526272829class xxx(object): \"\"\" knn 识别正方验证码 \"\"\" def __init__(self, image): self.image = image self.image_pre_process() # 初始化时就对图片进行去噪和二值化 def crack(self): result = [] # 加载数据 with open(os.path.join(current_dir, 'image_data.json'), 'rb') as f: image_data = json.load(f) for letter in self.handle_split_image(): letter_vector = build_vector(letter) guess = [] for image in image_data: for x, y in image.items(): guess.append((distance_hanmming(y, letter_vector), x)) guess.sort() neighbors = guess[:15] # 距离最近的十五个向量 class_votes = &#123;&#125; # 投票 for neighbor in neighbors: class_votes.setdefault(neighbor[-1], 0) class_votes[neighbor[-1]] += 1 sorted_votes = sorted(class_votes.items(), key=lambda x: x[1], reverse=True) result.append(sorted_votes[0][0]) return ''.join(result) △.在对象的识别上,一定要保证两者的统一性。而因为进行预处理的图片识别率更高。即模型需要保存去噪、二值化的数据，识别的图片在识别前也要做相应的处理。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"新加坡游玩经验","slug":"新加坡游玩经验","date":"2019-09-09T11:35:49.000Z","updated":"2019-10-18T08:46:58.629Z","comments":true,"path":"2019/09/09/新加坡游玩经验/","link":"","permalink":"https://nymrli.top/2019/09/09/新加坡游玩经验/","excerpt":"","text":"新加坡南洋理工大学访学 此次访学长达14天，不少安排都是学校安排，在此仅列出个人安排、经验心得。 门票购买： 番薯游：这是老师推荐我们的，但下载以后感觉界面还是比较丑的，而且价格也不是非常便宜。这家是唯一一家促进扫码买门票的公司。 KLOOK客路：界面比番薯游好多了，还是非常精致的。最大的优势在于可以找到经典的位置及景点介绍、门票时间等信息。 淘宝：跟好几个平台对比之后，价格应该是最低的，并且时间限制比较小，其他的可能要预约，而TB当天购买就行（强调：动物园门票） ▲特别说明下，动物园的门票水很深。当面购买$50,我当时去时没有预约，结果在KLOOK上看当天的票已经没有库存了，于是问了下换票机旁边的黄牛，他看我一个人，给我的报价也是50，不知道他咋想的。最后这个预约问题是通过淘宝解决的，￥156一张夜间动物园门票，5分钟就出票了。购买后会有一张带有二维码的PDF发到邮箱中，用机子扫出后即可。 地铁卡购买： 网上的说法都推荐购买EZ-LINK，但我们在NTU里的711便利店买时最后一张正好卖掉了，于是我们买的是这样的卡，后来发现这卡比EZ-LINK强多了。 由于它支持多家银行支付（由于种种原因，扫码支付在新加坡很难推行），因此其实这张卡十分的方便。既能在学校食堂消费，又能在外消费，同时地铁公交也都支持。 地铁公交价格明细： 如果有卡和没卡，价格区别是很大的，因此如果出行需要坐公交、地铁的话，强烈建议直接办地铁卡。 虽然每次充钱最低10/，但几乎每次坐车都在0.83/，但几乎每次坐车都在0.83/，但几乎每次坐车都在0.83/以上，所以开销还是非常大的。2.坐地铁低于2/就无法进站，公交低于1就无法进站，公交低于1就无法进站，公交低于1（不知道是不是所有） 行为规范： 新加坡的治安、素质是相当高的。其中比较明显的现象有：不乱丢垃圾；在地铁上不能饮食；地铁、公交先下后上； ▲1.如果有残疾人士，会有人帮忙放下挡板，帮残疾人士下车。我看到的那次是车上只有司机，坐轮椅的老奶奶要下公交，司机特地跑来放挡板，帮老人下车。 2.问司机路，他甚至会下车下来给你指往哪个方向怎么走 3.公交车到站需要按BUS STOPPING按钮，不然司机是真的不会停的！地铁的话几乎每站都会停。还有个非常重要的是，BUS每一站是不会报的，因此在新加坡坐公交很容易坐过头，这就需要看清楚地图定位和留意每一站名字。 地图推荐 高德不支持国外，因此我主要使用的是两个：Google Maps、百度地图。 其实百度地图挺好用的，我同学都用的百度，没必要特地去下载Google Maps。而在此我说一下我用Google Maps碰到的问题。1.坐地铁、公交时不会提醒花费。2.没有Google Player服务，周围推荐功能无法使用。3.我用的是MI6，但总感觉有时定位效果特别差，不知道是我手机GPS功能问题，还是Google Maps的问题 总结 新加坡是非常适合国人旅游的，首先是新加坡双语教学，很多人都会说中文，遇上麻烦，看看周围的人总能碰到说中文的；其次是商城里也大多有中文介绍，买东西时几乎每个店都会有说中文的店员来做国人生意，也几乎不太会碰上麻烦。 新加坡有70%的人是中国人或是华裔，10%是印度人，10%是马来人，还有10%是来自欧洲和日本、韩国等地。总的来说中国人比例还是非常大的，而且85%左右的旅客都来自中国，所以其实路上看到很多说中文的说不定也是跟你一样的游客。我交流比较多的都是中国人，特别是彭年纪大的老奶奶或是老爷爷，你如果向他问路，他们都会非常热心地帮助，恨不得亲自带你去了。 外文缩写 新加坡，几乎都有双语标注，因此英语不好的问题也不大。这边就列出几个常见的缩写 st --&gt; street rd --&gt; road sch --&gt; school 景点推荐： 乌节路 Orchard road 购物一条街，ION商城，义乌城……里面全是品牌。 圣淘沙 Sentosa 环球影城就在这岛上，门票350+，我没去，同学去了，感觉很不错，类似迪士尼的游乐园，有多种的主题 滨海湾 Marina Bay superTree Grove是免费的，晚上有表演，大约在8：45左右开始，非常的好看。此处景点有两个收费的地方，我也没去。 靠近湖边，有两个博物馆，一个是红点设计博物馆（这个我去了，门票大约￥70，地方很小，出来的商店卖的东西很贵）；另一个是金沙艺术科学博物馆（主题是“超越未来”，看介绍有点像是失恋博物馆里的光影效果） 鱼尾狮公园 Merlion Park 其实没啥好看的，有鱼尾狮，打个卡、拍个照差不多了。 植物园 Botanic garden 免费，徒步走还挺大的，大约半小时。里面植物很多，一般都是国内看不到的，喜欢看植物的人可以去看一下。同时那也有不少动物，都可以当个小型动物园了。 小印度 Little Indian 印度人很多，印度氛围很重。其他的话个人感觉没什么意思，在那边比较有名的印度餐馆里吃了咖喱鱼头，味道还不错，只不过两个人吃点中份的有点太多了。 Mustafa百货商城，真的很大，有两栋楼互相连通，深不见底，一共有四层。那边的东西也是比较便宜的，比如在NTU超市里买的饮料/$2.5，这边只要/$1.8左右；还有oldTown咖啡，在fairprice超市卖/$7.2，在Mustafa只要$5.4。这边非常值得去，可以在这捎点带给朋友的东西 夜间动物园 比较偏，去和回都很麻烦，坐地铁转公交啥的回NTU要1个半钟头，打车回只要15分钟。门票现场买时/$50，淘宝上￥150。买了门票进去后现有游览车观光，但是如果不加钱是英文讲解的（几乎听不懂w_w）。由于夜色较暗（灯光考虑到对动物的效果也不是很亮），且大多动物都已睡眠，所以游览车观光没什么意思。比较有意思的是动物表演，去的人几乎都会推荐，但需要注意的是，要提前等，因为先来先得位置，位置满后就不能进了，超时10分钟也不会让进了（表演一共15-20分钟左右）。游览车观光后的自由行也是比较有意思的，氛围就像是在丛林中，隔一段距离就是一个品种的动物。有很多平时没见过的大动物与小动物，小动物一般都有玻璃格挡，大动物的站台与马路就一道坎的隔离，管理员似乎很放心他们不会跑出来（老虎除外） 城市规划馆URA 很有意思，由60岁的Steven给我们讲解了新加坡建设的历史以及未雨绸缪地规划，其中3D立体模型图非常精致地还原了各地地细节，在游玩之前看一下这个对出游有极大的帮助 国家博物馆 真的很有意思，比国内的博物馆真实多了。在里面能看到新加坡的发展史、侵略史，能看到英军的身影，也能看到中国和日本的身影。当然其中比较有意思的是有真的坦克在里面展览。 比较遗憾的是我们是上午10点开门的时候去的，而讲解在11：30才开始，因此我们全参观完后讲解正刚开始，侥幸还听到了一点，真的很有意思，建议要去的话凑着这个时间点去，因为虽然有手册介绍，但是自己看真的可能看不明白 国家美术馆 由于8月上旬新加坡国庆在美术馆附近举行，因此8月9日之前都关闭着，因此没几乎进去看看。 美食推荐 叻沙 沙爹 福建炒面 印度飞饼 辣椒螃蟹(Big Eater seafood) 肉骨茶 附录：2019年8月9日新加坡国庆节节目安排 （万事通根据预演推测独家整理） 下午6点3分-6点10分 红狮跳伞队表演（随天气变化时间） 下午6点27分-下午6点30分 特遣队入场 下午6:35-6:38 国家色彩和荣誉护卫队入场 下午6:39 总理抵达 下午6:44 总统抵达 下午6:45-6:46 国旗飞扬 下午6:47 新加坡空军空中表演（F15战斗机） 下午6:49-6:52 鸣礼炮21响致敬 下午6:56-6:57 欢乐之火（大型篝火） 下午6:57 飞行表演 晚上7:00-7:01 新加坡空军多架F15战斗机飞行表演 晚上7:01-7:12 阅兵仪式 晚上7:14-7:39 机动部队出动 晚上8:00-8:05 新加坡河烟花表演（亚洲文明博物馆附近） 晚上8:10-8:18 烟花表演 办理签证 新加坡签证材料 1 两张 白底彩色近照 3.5*4.5cm 2身份证复印件 3户口本复印件 4护照原件 5 在读证明原件","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"CDN加速个人博客——又拍云","slug":"CDN加速个人博客——又拍云","date":"2019-09-09T11:34:27.000Z","updated":"2019-09-15T08:07:30.925Z","comments":true,"path":"2019/09/09/CDN加速个人博客——又拍云/","link":"","permalink":"https://nymrli.top/2019/09/09/CDN加速个人博客——又拍云/","excerpt":"","text":"CDN加速个人博客——又拍云 CDN(Content Delivery Network)内容发布网络，基本思路就是将你网站放置在各地节点服务器，用户访问时找最近的节点服务器获取数据，达到加速的目的。 几大厂商的CDN方案 资费介绍页面 免费额度 是否支持HTTPS 额外限制 注册邀请链接 七牛云 10GB/月 按量付费支持 / &gt;&gt;&gt; 点击注册 腾讯云 10GB/月 免费支持 加了腾讯云CDN没有感觉多大加速 / 百度云 10GB/天 年费付费支持 巨贵… / 又拍云 15GB/月 免费支持 加入又拍云联盟，并在网站底部放置logo &gt;&gt;&gt; 点击注册 因此，选择尝试了下“又拍云”。 一.创建CDN服务 1.服务名称为唯一的ID 2.加速域名就是自己的网站域名 3.选择一个应用场景，在这，我选的是“网页图片” 4.回源管理-&gt;源站设置，网站原本是什么协议就选择什么协议。 回源: 当缓存服务器(CDN提供的服务器)上找不到资源的时候,将会去回源服务器(自己的服务器)上找相应的资源 当然最省事的是选择“协议跟随” 5.选择“创建”，则服务创建完成 6.需要完成“实名认证”，否则服务将处于“关闭”状态 有“支付宝认证”和“身份认证”，“支付宝认证”是直接拍照采取你的个人照片，拍完即认证完毕比较迅速，但可能会泄露更多的个人信息， 毕竟支付宝上已经收集了很多个人信息了。&quot;身份认证&quot;通过提交手持身份证正反面的照片来认证，提交后会有一天的审核期，相对于“支付宝认证”来说可能慢一点。 二.配置SSL证书（非必须） 7.如果博客没有配置HTTPS，可以在这申请免费的SSL证书配置 又拍云提供了两款证书的免费申请方案，用户可通过 SSL 证书申购平台，免费申请 Symantec-TrustAsia、Let’s Encrypt 的 DV（域名型） SSL 证书，帮助用户零成本实现全站部署 HTTPS。并且还实现了 Let’s Encrypt 证书到期自动续签，用户无需担心证书过期时间，降低维护成本。 服务中的&quot;HTTPS&quot;-&gt;“HTTPS配置”–&gt;“无证书，可前往 SSL 证书管理 添加自有证书或申购新证书” 短信验证，付款完成后，需要“请前往证书申购界面补全后续信息&quot;，在”SSL证书服务“中能看到证书，但还需要执行”补全“步骤。 之后，如果当前域名为第一次配置证书，那么需要”域名所有权验证“。可以查看又拍云提供的帮助文档，分为OV 或 EV SSL 证书和DV SSL证书验证，其中DV SSL证书验证又分为”文件检验“和&quot;DNS 验证&quot;. DNS验证，需要修改域名的 DNS，添加 TXT 记录，然后 CA 机构通过解析域名的 TXT 记录来验证域名所有权。其中如果是阿里云解析，在设置过CNAME记录的同时再添加新的TXT记录会报错，说有冲突。此时可查看解决方案 只不过此时状态仍为“审核中”，即CA 机构信息审核验证状态，一般需要 1 个工作日。 ▲我测试了两个免费的证书，发现“Let’s Encrypt DV SSL 单域名证书”审核比&quot;TrustAsia DV SSL 单域名证书&quot;快多了，几乎5分钟就自动审核通过了。 e.g.由于我的博客是搭建在Github pages的，所以配置了HTTPS，因此，这个我就不需要再弄了。 附录 阿里云绑定加速域名解析时，提示TXT与@记录冲突解决办法 方法一： 实际上，TXT记录的作用只是做域名所有权验证。也就是说，一旦域名被验证，就可以删除它。 知道了这个原理，我们可以在解析时先删除其他@主机记录的解析，然后添加百度云加速TXT记录。 通过百度云加速后台显示验证后，我们删除TXT并解析其他@主机记录就可以了。 方法二： 如果你是使用免费智能 DNS 解析服务——CloudXNS 来解析域名应该是不会遇到这些问题，但是如果使用阿里云解析的话，应该或多或少都会遇到解析记录冲突的问题。所以可以采取更换解析商，即把阿里云解析更换为 CloudXNS 解析 方法三： **解析到不同的线路来解决。**默认情况下，我们 CNAME 解析时，只填写主机记录和记录值，其他都是默认，这个时候“解析线路”就是默认线路。如果后续你添加 TXT 记录或 MX 记录时，解析线路也是默认线路，那么就会出现解析记录冲突从而无法成功解析。此时，需要做的就是在解析 TXT 或 MX 记录时，把“解析线路”选择到其他线路，如选择“中国电信”或其他线路，然后保存就不会与 CNANE 的默认线路冲突了。","categories":[],"tags":[]},{"title":"RL强化学习概念","slug":"RL强化学习概念","date":"2019-09-09T11:33:12.000Z","updated":"2019-09-15T08:07:30.999Z","comments":true,"path":"2019/09/09/RL强化学习概念/","link":"","permalink":"https://nymrli.top/2019/09/09/RL强化学习概念/","excerpt":"","text":"RL强化学习概念 方法汇总 价值-直接-想象 通过价值选择行为： Q Learning Sarsa Deep Q Network 直接选择行为： Policy Gradients 想象环境并从中学习 Model Based RL 基于模型 Model-Free RL（无模型）不需要去理解环境的含义 Q Learning Sarsa Policy Gradients Model-Based RL（有环境）需要去理解环境的含义，在&quot;脑子&quot;中模拟虚拟环境 Q Learning Sarsa Policy Gradient 前者需要一步一步得到环境的反馈后才能进行下一步；而后者通过想象来预判断接下来会发生的情况。 基于概率-价值 基于概率（Policy Based RL）： Policy Gradients 即使是概率最高的也不一定能被选择到，因此基于价值的结果更为铁定 基于价值（Value Based RL）： Q Learning Sarsa 不能用于连续动作，但基于概率能使用概率分布在连续动作中选择一个动作 两者的统一体：Actor-Critic 回合-单步 回合更新（Monte-Carlo update） 基础版Policy Gradients Monte-Carlo Learning 在整个回合结束后再学习转折点 单步更新（Temporal-Difference update） Q Learning Sarsa 升级版Policy Gradients 不需要等待回合结束，边玩边学习 更多的情况下单步更新效率更高，但围棋游戏一般采用的都是回合更新 在线-离线 在线学习（online ） 本人在场，本人边玩边学习。 Sarsa Sarsa(/lambda/lambda/lambda) 离散学习（offline） 可以选择自己玩或者看别人玩。可以从保存的结果中学习 Q Learning Deep Q Network onPolicy-offPolicy on-policy Agent必然执行使Q函数最大的动作MAX_ACTION Sarsa off-plicy Agent实际不一定执行使Q函数最大的动作MAX_ACTION Q Learning","categories":[],"tags":[{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"强化学习——QLearning","slug":"强化学习——QLearning","date":"2019-09-09T11:32:08.000Z","updated":"2019-09-15T08:07:31.061Z","comments":true,"path":"2019/09/09/强化学习——QLearning/","link":"","permalink":"https://nymrli.top/2019/09/09/强化学习——QLearning/","excerpt":"","text":"强化学习——QLearning 价值转移公式只有一条Q(s,a)&lt;=Q(s,a)+/alpha∗(reward−Q(s,a)+/gamma∗maxaQ(s′,a))=(1−/alpha)∗Q(s,a)+/alpha∗(reward+/gamma∗maxaQ(s′,a))Q(s,a) &lt;= Q(s,a) + /alpha*(reward - Q(s,a) + /gamma*max_aQ(s&#x27;,a)) = (1-/alpha)*Q(s,a) + /alpha*(reward + /gamma*max_aQ(s&#x27;,a))Q(s,a)&lt;=Q(s,a)+/alpha∗(reward−Q(s,a)+/gamma∗maxa​Q(s′,a))=(1−/alpha)∗Q(s,a)+/alpha∗(reward+/gamma∗maxa​Q(s′,a))，即新Q(s1,a2)=老Q(s1,a2)+/alpha∗差距(现实−估计)新Q(s1,a2) = 老Q(s1,a2) + /alpha * 差距(现实-估计)新Q(s1,a2)=老Q(s1,a2)+/alpha∗差距(现实−估计) ALPHA为学习率，设置估计与现实的差距有多少被学习。能够使得更新比较平缓，防止模型过早收敛到局部解 如果有两种途径都能得到Reward宝藏，如果直接设置1，那么很大程度上，算法都会沿着已尝试出有Reward的路走，虽然有E-Greedy的探索，但是那样的得分可能不至于让第二条路成为更优的选择。所以设置学习率有助于找到第二条路。 GAMMA为衰减系数，maxaQ(s′,a)max_aQ(s&#x27;,a)maxa​Q(s′,a)是下一个时间点的最大期望奖励，因此需要用衰减系数来权衡下。即Q(s1)=r2+/gammaQ(s2)=r2+/gamma(r3+/gammaQ(S3))=...=r2+/gamma∗r3+/gamma2∗r4+/gamma3r5+...Q(s1) = r2 + /gamma Q(s2) = r2 + /gamma(r3+/gamma Q(S3)) = ...= r2 + /gamma *r3+/gamma^{2} *r4+ /gamma^{3} r5 + ...Q(s1)=r2+/gammaQ(s2)=r2+/gamma(r3+/gammaQ(S3))=...=r2+/gamma∗r3+/gamma2∗r4+/gamma3r5+...，约后面的影响越小 GAMMA == 1时，Agent能看到之后所有步的奖励。 只不过真正的理解应该时反序的，即最后一步是得到最终的reward，然后之前的状态的动作选择回报是在这个最终的reward上不断乘以GAMMA进行衰减，使得S1的选择不至于被最后的选择而过多影响 GAMMA == 0时，Agent只能看到眼前的奖励 ▲需要注意的是，这个公式是更新公式，而不是等式，因此两边不能化简，用代码来表示就是Q[state, action] = (1-ALPHA)*Q[state, action] + ALPHA*(reward + GAMMA*Q[newstate, action].max()) QLearning-Maze夺宝藏： demo代码： 环境代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# env.pyfrom __future__ import print_functionimport copyMAP = / '''.......... .. o .. ..........'''# MAP = /# '''# .........# . x .# . x o .# . .# .........# '''MAP = MAP.strip().split('/n')MAP = [[c for c in line] for line in MAP]DX = [-1, 1, 0, 0]DY = [0, 0, -1, 1]class Env(object): def __init__(self): self.map = copy.deepcopy(MAP) self.x = 1 self.y = 1 self.step = 0 self.total_reward = 0 self.is_end = False def interact(self, action): assert self.is_end is False new_x = self.x + DX[action] new_y = self.y + DY[action] new_pos_char = self.map[new_x][new_y] self.step += 1 if new_pos_char == '.': reward = 0 # do not change position elif new_pos_char == ' ': self.x = new_x self.y = new_y reward = 0 elif new_pos_char == 'o': self.x = new_x self.y = new_y self.map[new_x][new_y] = ' ' # update map self.is_end = True # end reward = 100 elif new_pos_char == 'x': self.x = new_x self.y = new_y self.map[new_x][new_y] = ' ' # update map reward = -5 self.total_reward += reward return reward @property def state_num(self): rows = len(self.map) cols = len(self.map[0]) return rows * cols @property def present_state(self): cols = len(self.map[0]) return self.x * cols + self.y def print_map(self): printed_map = copy.deepcopy(self.map) printed_map[self.x][self.y] = 'A' print('/n'.join([''.join([c for c in line]) for line in printed_map])) def print_map_with_reprint(self, output_list): printed_map = copy.deepcopy(self.map) printed_map[self.x][self.y] = 'A' printed_list = [''.join([c for c in line]) for line in printed_map] for i, line in enumerate(printed_list): output_list[i] = line Agent代码 1234567891011121314151617181920212223242526272829303132333435363738# qlearning.pyfrom __future__ import print_functionimport numpy as npimport timefrom env import EnvEPSILON = 0.1ALPHA = 0.1GAMMA = 0.9MAX_STEP = 30np.random.seed(0)def epsilon_greedy(Q, state): if (np.random.uniform() &gt; 1 - EPSILON) or ((Q[state, :] == 0).all()): action = np.random.randint(0, 4) # 0~3 else: action = Q[state, :].argmax() return actione = Env()Q = np.zeros((e.state_num, 4))for i in range(200): e = Env() while (e.is_end is False) and (e.step &lt; MAX_STEP): action = epsilon_greedy(Q, e.present_state) state = e.present_state reward = e.interact(action) new_state = e.present_state Q[state, action] = (1 - ALPHA) * Q[state, action] + / ALPHA * (reward + GAMMA * Q[new_state, :].max()) e.print_map() time.sleep(0.1) print('Episode:', i, 'Total Step:', e.step, 'Total Reward:', e.total_reward) time.sleep(2) 第一次魔改代码： 环境代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from __future__ import print_functionimport copymaze = /'''........... .. o .. ...........'''# print(maze)maze = maze.strip().split('/n')# print(maze)MAP = [[col for col in line] for line in maze]# print(MAP)DX = [-1, 0, 1, 0]DY = [0, 1, 0, -1]class Env(object): ''' 交互环境 ''' def __init__(self): self.map = copy.deepcopy(MAP) self.x = 1 self.y = 1 self.step = 0 self.isEnd = False self._score = 0 def interact(self, action): # state = self.state # assert self.isEnd is True newx = self.x + DX[action] newy = self.y + DY[action] newPos = self.map[newx][newy] self.step += 1 if newPos == '.': reward = -10 elif newPos == ' ': self.x = newx self.y = newy reward = 2 elif newPos == 'o': self.x = newx self.y = newy reward = 100 # self.map[newx][newy] = ' '如果不update会怎么样？ self.isEnd = True self._score += reward return reward @property def state_num(self): rows = len(self.map) cols = len(self.map[0]) return rows * cols @property def score(self): return self._score @property def present_state(self): return len(self.map[0])*self.x + self.y def printMap(self): printed_map = copy.deepcopy(self.map) printed_map[self.x][self.y] = 'A' print('/n'.join([''.join([c for c in line]) for line in printed_map]))if __name__ == '__main__': e = Env() e.printMap() print(e.score) 进行了如下的修改： 碰到边界'.'时，将会扣分 如果没有任何事发生的话，那么奖励2分 修改后结果如下 Agent代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from __future__ import print_functionimport numpy as npfrom pprint import pprintfrom env import Envimport timeEPSILON = 0.2ALPHA = 0.1GAMMA = 0.9MAX_STEP = 30TIMES = 30def epsilonGreedy(Q, state): if np.random.uniform() &gt; 1-EPSILON or ((Q[state, :] == 0).all()): action = np.random.randint(0,4) # 0-3，随机选择一个方向探索 else: action = Q[state, :].argmax() # 找到当前价值最大的决策 return actione = Env()np.random.seed(0)Q = np.zeros((e.state_num, 4))success = 0for i in range(TIMES): ne = Env() while (ne.isEnd == False) and (ne.step &lt; MAX_STEP): state = ne.present_state action = epsilonGreedy(Q, state) print(action) # print(Q[ne.x*10+ne.y,:]) reward = ne.interact(action) newstate = ne.present_state if ne.map[newstate//10][newstate%10] == 'o': success += 1 print('success=',success) print(\"结果为：\") ne.printMap() print(\"再下一步的得分：\",Q[newstate,:]) Q[state, action] = (1-ALPHA)*Q[state, action] + / ALPHA*(reward + GAMMA*Q[newstate, action].max()) time.sleep(.05) print('Episode:', i, 'Total Step:', ne.step, 'Total Reward:', ne.score) # Qp = np.reshape(Q, (5,10,4)) # print(Qp) # [第一行,[10列,4个方向]] # [第二行,[10列,4个方向]] # ... time.sleep(2)print(Q)print(success) 修改后结果 走&quot; &quot;得奖励值设为+2得情况下，当EPSILON=0.1时，30次训练，几乎都在起点左右摇摆。 原因是没碰到宝藏前，他们这样漫无目的的走是得分最高的。 处理的方法：1.修改Epsilon值，让他们有更多的机会去探索；2.增大训练的次数，一旦他们曾经到过宝藏，那么他们会往这个好的方向优化 注意，如果设置&quot; &quot;的奖励的话，需要慎重考虑，因为左右摇摆最高的奖励值在MAX_STEP=30的情况下是能达到60的。所以宝藏的奖励值一定要略大于MAX_SETP*EMPTY_REWARD才能达到训练的目的；同时，可能导致找不到最快寻到宝藏的可能,比如在宝藏门前来回晃悠来获得&quot; &quot;奖励-&gt;解决方案：可以根据当前步数来设置宝藏的分数 碰到'.'扣分，使得Agent不倾向于撞墙，这个是个不错的修改，从Q表中也能看到明显的效果。但是一旦之后出现有陷阱的情况&quot;X&quot;，那么这边的惩罚值得设定需要慎重考虑 第二次魔改代码 环境代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from __future__ import print_functionimport copyTREASURE = 'o'TRAP = 'X'maze = /'''........... &#123;trap&#125; .. &#123;treasure&#125; .. ...........'''.format(treasure=TREASURE,trap=TRAP)# print(maze)maze = maze.strip().split('/n')# print(maze)MAP = [[col for col in line] for line in maze]# print(MAP)DX = [-1, 0, 1, 0]DY = [0, 1, 0, -1]class Env(object): ''' 交互环境 ''' def __init__(self): self.map = copy.deepcopy(MAP) self.x = 1 self.y = 1 self.step = 0 self.isEnd = False self._score = 0 def interact(self, action): # state = self.state # assert self.isEnd is True newx = self.x + DX[action] newy = self.y + DY[action] newPos = self.map[newx][newy] self.step += 1 if newPos == '.': reward = -10 elif newPos == ' ': self.x = newx self.y = newy reward = 2 elif newPos == 'o': self.x = newx self.y = newy reward = 100 # self.map[newx][newy] = ' '如果不update会怎么样？ self.isEnd = True elif newPos == 'X': self.x = newx self.y = newy reward = -50 self.isEnd = True self._score += reward return reward @property def state_num(self): rows = len(self.map) cols = len(self.map[0]) return rows * cols @property def score(self): return self._score @property def present_state(self): return len(self.map[0])*self.x + self.y def printMap(self): printed_map = copy.deepcopy(self.map) printed_map[self.x][self.y] = 'A' print('/n'.join([''.join([c for c in line]) for line in printed_map]))if __name__ == '__main__': e = Env() e.printMap() print(e.score) 进行了如下修改 碰到陷阱'X'时，将会扣较多的分 Agent代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from __future__ import print_functionimport numpy as npfrom pprint import pprintfrom env import Envimport timeEPSILON = 0.2ALPHA = 0.1GAMMA = 0.9MAX_STEP = 30TIMES = 40TEST_TIMES = 5def epsilonGreedy(Q, state): if np.random.uniform() &gt; 1-EPSILON or ((Q[state, :] == 0).all()): action = np.random.randint(0,4) # 0-3，随机选择一个方向探索 else: action = Q[state, :].argmax() # 找到当前价值最大的决策 return actione = Env()np.random.seed(0)Q = np.zeros((e.state_num, 4))# 用Epsilon_Greedy策略获得Q表def Qtrain(): success = 0 for i in range(TIMES): ne = Env() while (ne.isEnd == False) and (ne.step &lt; MAX_STEP): state = ne.present_state action = epsilonGreedy(Q, state) print(\"当前的选择为：\",action) # print(Q[ne.x*10+ne.y,:]) reward = ne.interact(action) newstate = ne.present_state if ne.map[newstate//10][newstate%10] == 'o': success += 1 print('success=',success) print(\"结果为：\") ne.printMap() print(\"再下一步的得分：\",Q[newstate,:],'/n') Q[state, action] = (1-ALPHA)*Q[state, action] + / ALPHA*(reward + GAMMA*Q[newstate, action].max()) time.sleep(.05) print('Episode:', i, 'Total Step:', ne.step, 'Total Reward:', ne.score) print('-'*20, '/n/n') # Qp = np.reshape(Q, (5,10,4)) # print(Qp) time.sleep(2) print(Q) print(success)# 使用Q表走棋测试,由于Q表确定，所以其实每次的结果都是一样的def Qtest(): print('*'*10,\"开始测试\",'*'*10) for i in range(TEST_TIMES): ne = Env() while (ne.isEnd == False) and (ne.step &lt; MAX_STEP): state = ne.present_state action = Q[state,:].argmax() print(\"当前的选择为：\",action) # print(Q[ne.x*10+ne.y,:]) reward = ne.interact(action) newstate = ne.present_state print(\"结果为：\") ne.printMap() print(\"再下一步的得分：\",Q[newstate,:],'/n') time.sleep(.05) print('Episode:', i, 'Total Step:', ne.step, 'Total Reward:', ne.score) print('-'*20,'/n/n') time.sleep(2)if __name__ == '__main__': Qtrain() Qtest() 修改后结果： 由于走空&quot; &quot;现象仍然存在，感觉奖励给2仍是太多 EPSILON=0.2，随机乱走的几率很高，导致开局踩到陷阱X的概率很大 暴毙结果(训练中没碰到过宝藏) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748********** 开始测试 **********当前的选择为： 2结果为：........... X ..A o .. ...........再下一步的得分： [ 0.12753822 0. 1.0434062 -2.9701 ] 当前的选择为： 2结果为：........... X .. o ..A ...........再下一步的得分： [ 0.21147844 2.30159071 0. -1.99 ] 当前的选择为： 1结果为：........... X .. o .. A ...........再下一步的得分： [-0.313 0.398 -1. 1.04984339] 当前的选择为： 3结果为：........... X .. o ..A ...........再下一步的得分： [ 0.21147844 2.30159071 0. -1.99 ] 当前的选择为： 1结果为：........... X .. o .. A ...........再下一步的得分： [-0.313 0.398 -1. 1.04984339] ...之后都是1和3的循环选择 可以看到，这边上下变成了死循环。这是当所有训练中都没有踩到过宝藏的情况。 ▲.使训练中更有可能碰到宝藏的方法 训练的次数T足够多 如果训练次数少的话，需要合理设置EPSILON，使得Agent有更多的机会探索 MAX_STEP设置合理 特殊情况考虑（发生概率很小） ▲.还有一点要说明的是：Q:有种情况是，同样都是走空得2分，为什么向上得得分是18，而向右得得分是2呢？ A：因为Dx，Dy的循序（上右下左）决定了。当四个得分都一样时如[2,2,2,2]，那么将会优先选择上，因为如果走空有奖励，所以上比右的得分会高很多。 1234567891011# env.pyDX = [-1, 0, 1, 0]DY = [0, 1, 0, -1]# ...def epsilonGreedy(Q, state): if np.random.uniform() &gt; 1-EPSILON or ((Q[state, :] == 0).all()): action = np.random.randint(0,4) # 0-3，随机选择一个方向探索 else: action = Q[state, :].argmax() # 找到当前价值最大的决策 # ▲argmax()当最大值相同时，取索引最小的 return action 即 12345678910111213# Test1a = np.array([ [1,0,1,1], [2,1,3,1]])print(a[0,:].argmax())# 0# Test2a = np.array([ [1,0,3,3], [2,1,3,1]])print(a[0,:].argmax())# 2 测试走空–奖励值 走空无奖励值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647当前的选择为： 2结果为：........... X ..A o .. ...........再下一步的得分： [-0.501399 23.9585123 0. -3.940399 ] 当前的选择为： 1结果为：........... X .. A o .. ...........再下一步的得分： [-20.4755 41.20097133 0. -0.267309 ] 当前的选择为： 1结果为：........... X .. A o .. ...........再下一步的得分： [-0.457659 66.18493075 -0.2439 0. ] 当前的选择为： 1结果为：........... X .. Ao .. ...........再下一步的得分： [ 0. 94.1850263 0. 0. ] 当前的选择为： 1结果为：........... X .. A .. ...........再下一步的得分： [0. 0. 0. 0.] Episode: 4 Total Step: 5 Total Reward: 100-------------------- 走空有+2奖励的结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647当前的选择为： 2结果为：........... X ..A o .. ...........再下一步的得分： [-0.41254159 6.24693379 -0.03645728 -3.940399 ] 当前的选择为： 1结果为：........... X .. A o .. ...........再下一步的得分： [-9.5 21.14440154 0.2981 0. ] 当前的选择为： 1结果为：........... X .. A o .. ...........再下一步的得分： [ 5.16800000e-01 5.26069497e+01 -3.14898100e-02 3.80000000e-01] 当前的选择为： 1结果为：........... X .. Ao .. ...........再下一步的得分： [ 0.45506025 83.3228183 1.0434062 2.28281481] 当前的选择为： 1结果为：........... X .. A .. ...........再下一步的得分： [0. 0. 0. 0.] Episode: 4 Total Step: 5 Total Reward: 108-------------------- 多次测试经验总结：","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"机器学习——决策树","slug":"机器学习——决策树","date":"2019-08-30T13:44:35.000Z","updated":"2021-05-30T05:06:12.207Z","comments":true,"path":"2019/08/30/机器学习——决策树/","link":"","permalink":"https://nymrli.top/2019/08/30/机器学习——决策树/","excerpt":"","text":"机器学习——决策树 决策树基础概念 决策树分为分类树和回归树两种，分类树对离散变量做决策树，回归树对连续变量做决策树。 每个内部节点（非叶子节点）表示一个属性上的测试条件，每个分支代表一个测试输出结果，每个叶节点代表一种类别 决策树分为分类树和回归树两种，分类树对离散变量做决策树，回归树对连续变量做决策树。 决策树的构造过程就是找到这些具有决定性作用的特征，根据其决定性程度来构造一个倒立的树–决定性作用最大的那个特征作为根节点，然后递归找到各分支下子数据集中次大的决定性特征，直至子数据集中所有数据都属于同一类。 特征： 有监督的学习 非参数学习算法 自顶向下递归方式构造决策树 在每一步选择中都采取在当前状态下最好\\优的选择 决策树生成过程 一棵决策树的生成过程主要分为以下3个部分: 特征选择：特征选择是指从训练数据中众多的特征中选择一个特征作为当前节点的分裂标准，如何选择特征有着很多不同量化评估标准标准，从而衍生出不同的决策树算法。 决策树生成： 根据选择的特征评估标准，从上至下递归地生成子节点，直到数据集不可分则停止决策树停止生长。 树结构来说，递归结构是最容易理解的方式。 剪枝：决策树容易过拟合，一般来需要剪枝，缩小树结构规模、缓解过拟合。剪枝技术有预剪枝和后剪枝两种。 基于信息论的三种决策树算法 划分数据集的最大原则是：使无序的数据变的有序。 熵降低的速度越快越好==&gt;树的高度最矮 基于信息论的决策树算法有ID3、CART和C4.5等算法，其中C4.5和CART两种算法从ID3算法中衍生而来。 ID3算法 信息增益作为评估标准，分支节点选择特征X信息增益最大的 可用于划分标称型数据集，没有剪枝的过程，为了去除过度数据匹配的问题，可通过裁剪合并相邻的无法产生大量信息增益的叶子节点（例如设置信息增益阀值）。使用信息增益的话，其实是有一个缺点，那就是它偏向于具有大量值的属性–就是说在训练集中，某个属性所取的不同值的个数越多，那么越有可能拿它来作为分裂属性 C4.5算法 C4.5是ID3的一个改进算法，继承了ID3算法的优点。 C4.5算法用信息增益率来选择属性， 克服了用信息增益选择属性时偏向选择取值多的属性的不足在树构造过程中进行剪枝； 能够完成对连续属性的离散化处理；能够对不完整数据进行处理。 CART算法（Classification And Regression Tree） **采用的是Gini指数（选Gini指数最小的特征s）**作为分裂标准 同时它也是包含后剪枝操作 ID3和C4.5虽可尽可能挖掘数据信息，但生成的决策树分支较大。CART可以简化决策树的规模，提高生成决策树的效率 决策树优缺点 决策树适用于数值型和标称型（离散型数据，变量的结果只在有限目标集中取值），能够读取数据集合，提取一些列数据中蕴含的规则。在分类问题中使用决策树模型有很多的优点，1.决策树计算复杂度不高、便于使用、而且高效，2.决策树可处理具有不相关特征的数据、3.可很容易地构造出易于理解的规则，而规则通常易于解释和理解。 决策树模型也有一些缺点，比如1.处理缺失数据时的困难、2.过度拟合以及3.忽略数据集中属性之间的相关性等。 ID3数学原理 信息熵(香农熵)： 一种度量不确定性的方式，是用来衡量随机变量不确定性的，熵就是信息的期望值 如果待分类的事物可能划分在多个分类之中，则符号xi的信息定义为I(xi)=−log⁡2p(xi)\\mathrm{I}\\left(x_{i}\\right)=-\\log _{2} p\\left(x_{i}\\right)I(xi​)=−log2​p(xi​)，其中p(xi)是选择该分类的概率。 有人可能会问，信息为啥这样定义啊？答曰：前辈得出的结论。这就跟1+1等于2一样，记住并且会用即可。上述式中的对数以2为底，也可以e为底(自然对数)。 若随机事件发生的结果记为X，且待分类的事物可能划分在N类中，分别是x1，x2，……，xn，每一种取到的概率分别是P1，P2，……，Pn，那么X的熵就定义为： H=−∑i=1np(xi)log⁡2p(xi)\\mathrm{H}=-\\sum_{\\mathrm{i}=1}^{n} \\mathrm{p}\\left(x_{i}\\right) \\log _{2} p\\left(x_{i}\\right)H=−∑i=1n​p(xi​)log2​p(xi​) 反映了每一个元素在该类别下的不纯度，如{1,2,3,4}跟{1,1,1,2}相比,每个元素1-4的logPi都很大,因此sum的熵就要大很多。 注：有&quot;某个类别的结果&quot;的熵（某个特征有多个值），也有&quot;某事件结果&quot;的熵（该事件有多个特征）。直观来讲，结果种类越多，熵值越大。 当熵中的概率由数据估计(特别是最大似然估计)得到时，所对应的熵称为经验熵(empirical entropy)。什么叫由数据估计？比如有10个数据，一共有两个类别，A类和B类。其中有7个数据属于A类，则该A类的概率即为十分之七。其中有3个数据属于B类，则该B类的概率即为十分之三。浅显的解释就是，这概率是我们根据数据数出来的。 经验熵举例： 我们定义贷款申请样本数据表中的数据为训练数据集D，则训练数据集D的经验熵为H(D)。|D|表示其样本容量，即样本个数。设有K个类Ck, = 1,2,3,…,K,|Ck|为属于类Ck的样本个数，因此经验熵公式就可以写为 ： H(D)=−∑k=1K∣ck∣∣D∣log⁡2∣Ck∣∣D∣\\mathrm{H}(\\mathrm{D})=-\\sum_{k=1}^{K} \\frac{\\left|c_{k}\\right|}{|D|} \\log _{2} \\frac{\\left|C_{k}\\right|}{|D|}H(D)=−∑k=1K​∣D∣∣ck​∣​log2​∣D∣∣Ck​∣​ ，即p(Ck)=∣Ck∣∣D∣p(C_k)=\\frac{\\left|C_{k}\\right|}{|D|}p(Ck​)=∣D∣∣Ck​∣​由样本数据出来的结果。 根据此公式计算经验熵H(D)，分析贷款申请样本数据表中的数据。最终分类结果只有两类，即放贷和不放贷。根据表中的数据统计可知，在15个数据中，9个数据的结果为放贷，6个数据的结果为不放贷。所以数据集D的经验熵H(D)为： H(D)=−915log⁡2915−615log⁡2615=0.971\\mathrm{H}(\\mathrm{D})=-\\frac{9}{15} \\log _{2} \\frac{9}{15}-\\frac{6}{15} \\log _{2} \\frac{6}{15}=0.971H(D)=−159​log2​159​−156​log2​156​=0.971 经过计算可知，数据集D的经验熵H(D)的值为0.971。 ▲熵值越高，则数据混合的种类越高，其蕴含的含义是一个变量可能的变化越多（反而跟变量具体的取值没有任何关系，只和值的种类多少以及发生概率有关） 条件熵 表示在已知随机变量X的条件下随机变量Y的不确定性，其定义为X在给定条件下Y的条件概率分布的熵对X的数学期望: H(Y∣X)=∑i=1npiH(Y∣X=xi)H(Y | X)=\\sum_{i=1}^{n} p_{i} H\\left(Y | X=x_{i}\\right)H(Y∣X)=∑i=1n​pi​H(Y∣X=xi​),其中pi=P(X=xi),i=1,2,⋯ ,np_{i}=P\\left(X=x_{i}\\right), i=1,2, \\cdots, \\mathrm{n}pi​=P(X=xi​),i=1,2,⋯,n 经验条件熵举例： 设特征A有n个不同的取值{a1,a2,···,an}，根据特征A的取值将D划分为n个子集{D1,D2，···,Dn}，|Di|为Di的样本个数。记子集Di中属于Ck的样本的集合为Dik，即Dik = Di ∩ Ck，|Dik|为Dik的样本个数 \\begin{align*}\\mathrm{H}(\\mathrm{D} | \\mathrm{A}) &amp; =\\sum_{i=1}^{\\mathrm{n}} \\frac{\\left|D_{i}\\right|}{|D|} \\mathrm{H}\\left(D_{i}\\right) \\\\ &amp; =-\\sum_{i=1}^{n} \\frac{\\left|D_{i}\\right|}{|D|} \\sum_{k=1}^{K} \\frac{\\left|D_{i k}\\right|}{\\left|D_{i}\\right|} \\log _{2} \\frac{\\left|D_{i k}\\right|}{\\left|D_{i}\\right|}\\end{align*} 信息增益 信息增益(information gain)表示得知特征X的信息后，而使得Y的不确定性减少的程度。定义为集合D的经验熵H(D)与给定特征A条件下D的经验条件熵H(D|A)之差: g(D,A)=H(D)−H(D∣A)g(D, A)=H(D)-H(D| A)g(D,A)=H(D)−H(D∣A) 一般地，熵H(D)与条件熵H(D|A)之差称为互信息(mutual information)。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。 举例：以贷款申请样本数据表为例进行说明。看下年龄这一列的数据，也就是特征A1，一共有三个类别，分别是：青年、中年和老年。我们只看年龄是青年的数据，年龄是青年的数据一共有5个，所以年龄是青年的数据在训练数据集出现的概率是5\\15，也就是1\\3。同理，年龄是中年和老年的数据在训练数据集出现的概率也都是1\\3。现在我们只看年龄是青年的数据的最终得到贷款的概率为2\\5，因为在五个数据中，只有两个数据显示拿到了最终的贷款，同理，年龄是中年和老年的数据最终得到贷款的概率分别为3\\5、4\\5。所以计算年龄的信息增益，过程如下： g(D,A1)=H(D)−H(D∣A1)=H(D)−∑i=1n∣Di∣∣D∣H(Di)=H(D)−[∣D1∣∣D∣H(D1)+∣D2∣∣D∣H(D2)+∣D3∣∣D∣H(D3)]=H(D)−∣Di∣∣D∣∑i=13pi∗log⁡2pi=0.971−[515(−25log⁡225−35log⁡235)+515(−35log⁡235−25log⁡225)+515(−45log⁡245−15log⁡215)]=0.971−0.888=0.083\\begin{aligned} \\mathrm{g}\\left(\\mathrm{D}, A_{1}\\right) &amp;=H(D)-H\\left(D | A_{1}\\right) \\\\ &amp;=H(D)-\\sum_{i=1}^{\\mathrm{n}} \\frac{\\left|D_{i}\\right|}{|D|} \\mathrm{H}\\left(D_{i}\\right) \\\\ &amp;=H(D)-\\left[\\frac{\\left|D_{1}\\right|}{|D|}H\\left(\\mathrm{D}_{1}\\right)+\\frac{\\left|D_{2}\\right|}{|D|} H\\left(D_{2}\\right)+\\frac{\\left|D_{3}\\right|}{|D|} H\\left(D_{3}\\right)\\right] \\\\ &amp;=H(D)- \\frac{\\left|D_{i}\\right|}{|D|} \\sum_{i=1}^{3} p_{i} * \\log _{2} p_{i} \\\\ &amp;=0.971-\\left[\\frac{5}{15}\\left(-\\frac{2}{5} \\log _{2} \\frac{2}{5}-\\frac{3}{5} \\log _{2} \\frac{3}{5}\\right)+\\frac{5}{15}\\left(-\\frac{3}{5} \\log _{2} \\frac{3}{5}-\\frac{2}{5} \\log _{2} \\frac{2}{5}\\right)\\right.\\\\ &amp;\\left.+\\frac{5}{15}\\left(-\\frac{4}{5} \\log _{2} \\frac{4}{5}-\\frac{1}{5} \\log _{2} \\frac{1}{5}\\right)\\right] \\\\ &amp;=0.971-0.888=0.083 \\end{aligned}g(D,A1​)​=H(D)−H(D∣A1​)=H(D)−i=1∑n​∣D∣∣Di​∣​H(Di​)=H(D)−[∣D∣∣D1​∣​H(D1​)+∣D∣∣D2​∣​H(D2​)+∣D∣∣D3​∣​H(D3​)]=H(D)−∣D∣∣Di​∣​i=1∑3​pi​∗log2​pi​=0.971−[155​(−52​log2​52​−53​log2​53​)+155​(−53​log2​53​−52​log2​52​)+155​(−54​log2​54​−51​log2​51​)]=0.971−0.888=0.083​ 其中|Di|为特征该类别的数量，Pi为该类别下为true（事件发生）的概率 C4.5数学原理 以信息增益进行分类决策时，存在偏向于取值较多的特征的问题。于是有了基于信息增益比的分类决策方法C4.5。C4.5与ID3都是利用贪心算法进行求解，不同的是分类决策的依据不同。 信息增益比率度量:信息增益比率度量Gain(D，X) \\ 分裂信息度量SplitInformation(D，X) SplitInformation(D，X）=−∑i=1nPxi∗log2PxiSplitInformation(D，X） = -\\sum_{i=1}^{n}{P_{x_i} }*log_2{P_{x_i} }SplitInformation(D，X）=−∑i=1n​Pxi​​∗log2​Pxi​​ GainRatio(D,X)=Gain(D,X)÷SplitInformation(D,X)GainRatio(D,X) = Gain(D,X) \\div SplitInformation(D,X)GainRatio(D,X)=Gain(D,X)÷SplitInformation(D,X) CART数学原理 基尼指数GINI 1、是一种不等性度量，表示一个随机选中的样本在子集中被分错的可能性； 2、通常用来度量收入不平衡，可以用来度量任何不均匀分布； 3、是介于0~1之间的数，0-完全相等，1-完全不相等； 4、总体内包含的类别越杂乱，GINI指数就越大（跟熵的概念很相似） Gini系数的计算方式如下 Gini(p)=∑k=1Kpk(1−pk)=1−∑k=1Kpk2Gini(p)=\\sum_{k=1}^{K} p_{k}\\left(1-p_{k}\\right)=1-\\sum_{k=1}^{K} p_{k}^{2}Gini(p)=∑k=1K​pk​(1−pk​)=1−∑k=1K​pk2​ 上面式子表述的意思就是，加入特征X以后，数据不纯度减小的程度. 如果D为样本数据集，Gini(D)=1−∑k=1K(∣Ck∣∣D∣)2Gini(D)=1-\\sum_{k=1}^{K}\\left(\\frac{\\left|C_{k}\\right|}{|D|}\\right)^{2}Gini(D)=1−∑k=1K​(∣D∣∣Ck​∣​)2其中Ck是D中属于第k类的样本子集，K是类的个数。 如果D被特征A划分为D1、D2两部分，这个时候就是统计均值，样本数据集D的基尼系数： Gini(D,A)=∣D1∣∣D∣Gini(D1)+∣D2∣∣D∣Gini(D2)Gini(D, A)=\\frac{\\left|D_{1}\\right|}{|D|} Gini\\left(D_{1}\\right)+\\frac{\\left|D_{2}\\right|}{|D|} Gini\\left(D_{2}\\right)Gini(D,A)=∣D∣∣D1​∣​Gini(D1​)+∣D∣∣D2​∣​Gini(D2​) [统计学习方法：CART算法](https:\\www.cnblogs.com\\xingshansi\\p\\6847334.html) 最小二乘回归树 一个回归树对应着输入空间（即特征空间）的一个划分以及在划分的单元上的输出值。假设已将输入空间划分为M个单元R1,R2,…Rm，并且在每个单元Rm上有一个固定的输出值Cm，于是回归树模型可表示为： f(x)=∑m=1McmI(x∈Rm)f(x)=\\sum_{m=1}^{M} c_{m} I\\left(x \\in R_{m}\\right)f(x)=∑m=1M​cm​I(x∈Rm​) 模型输出值与实际值的误差：∑xi∈Rm(yi−f(xi))2\\sum_{x_{i} \\in R_{m}}\\left(y_{i}-f\\left(x_{i}\\right)\\right)^{2}∑xi​∈Rm​​(yi​−f(xi​))2 我们希望每个单元上的Cm，可以是的这个平方误差最小化。易知，当Cm为相应单元的所有实际值的均值时，可以到最优： c^m=ave(yi∣xi∈Rm)\\hat{c}_{m}=ave\\left(y_{i} | x_{i} \\in R_{m}\\right)c^m​=ave(yi​∣xi​∈Rm​) 假设，我们选择变量 xj 为切分变量，它的取值 s 为切分点，那么就会得到两个区域： R1(j,s)={x∣x(j)≤s},R2(j,s)={x∣x(j)&gt;s}\\mathrm{R}_{1}(j, s)=\\left\\{x | x^{(j)} \\leq s\\right\\}, \\mathrm{R}_{2}(j, s)=\\left\\{x | x^{(j)}&gt;s\\right\\}R1​(j,s)={x∣x(j)≤s},R2​(j,s)={x∣x(j)&gt;s} 当j和s固定时，我们要找到两个区域的代表值c1，c2使各自区间上的平方差最小： min⁡j,s[min⁡c1∑xi∈R1(j,s)(yi−c1)2+min⁡c2∑xi∈R2(j,s)(yi−c2)2]\\min _{j, s}\\left[\\min _{c_{1}} \\sum_{x_{i} \\in R_{1}(j, s)}\\left(y_{i}-c_{1}\\right)^{2}+\\min _{c_{2}} \\sum_{x_{i} \\in R_{2}(j, s)}\\left(y_{i}-c_{2}\\right)^{2}\\right]minj,s​[minc1​​∑xi​∈R1​(j,s)​(yi​−c1​)2+minc2​​∑xi​∈R2​(j,s)​(yi​−c2​)2] 前面已经知道c1，c2为区间上的平均： c^1=ave(yi∣xiϵR1(j,s)),c^2=ave(yi∣xiϵR1(j,s))\\hat{c}_{1}=ave\\left(y_{i} | x_{i} \\epsilon R_{1}(j, s)\\right), \\hat{c}_{2}=ave\\left(y_{i} | x_{i} \\epsilon R_{1}(j, s)\\right)c^1​=ave(yi​∣xi​ϵR1​(j,s)),c^2​=ave(yi​∣xi​ϵR1​(j,s)) 那么对固定的 j 只需要找到最优的s，然后通过遍历所有的变量，我们可以找到最优的j，这样我们就可以得到最优对（j，s）,（特征j，特征分类值s），并s得到两个区间。 这样的回归树通常称为最小二乘回归树（least squares regression tree）。 上述过程表示的算法步骤为: 处理连续数值型特征 C4.5和CART既可以处理离散型属性，也可以处理连续性属性。对于离散型描述属性，处理方法与ID3相同。对于连续分布的特征，其处理方法是： 以C4.5为例子，在C4.5中，对连续属性的处理如下： 1、对特征的取值进行升序排序 2、两个特征取值之间的中点作为可能的分裂点，从分裂点将数据集分成两部分，计算每个可能的分裂点的信息增益（InforGain）。优化算法就是只计算分类属性发生改变的那些特征取值。 3、选择修正后信息增益(InforGain)最大的分裂点作为该特征的最佳分裂点 4、计算最佳分裂点的信息增益率（Gain Ratio）作为特征的Gain Ratio。注意，此处需对最佳分裂点的信息增益进行修正：减去log2(N-1)|D|（N是连续特征的取值个数，D是训练数据数目，此修正的原因在于：当离散属性和连续属性并存时，C4.5算法倾向于选择连续特征做最佳树分裂点） Q：为什么这边是使用的信息增益率？ A：经证明，在决定连续特征的分界点时采用增益这个指标（因为若采用增益率，splittedinfo影响分裂点信息度量准确性，若某分界点恰好将连续特征分成数目相等的两部分时其抑制作用最大），而选择属性的时候才使用增益率这个指标能选择出最佳分类特征。 剪枝 预剪枝(Pre-pruning) 在构建决策树的过程时，提前停止。 根据一些原则及早的停止树增长，如树的深度达到用户所要的深度、节点中样本个数少于用户指定个数、不纯度指标下降的最大幅度小于用户指定的幅度等 采用检验技术对当前结点对应的样本集合进行检验，如果该样本集合的样本数量已小于事先指定的最小允许值，那么停止该结点的继续生长，并将该结点变为叶子结点，否则可以继续扩展该结点。 ▲核心问题是如何事先指定树的最大深度，如果设置的最大深度不恰当，那么将会导致过于限制树的生长，使决策树的表达式规则趋于一般，不能更好地对新数据集进行分类和预测 后剪枝(Post-pruning) 决策树构建好后，然后才开始裁剪。 代价复杂性剪枝、最小误差剪枝、悲观误差剪枝等等 是一个边修剪边检验的过程。 在决策树的不断剪枝操作过程中，将原样本集合或新数据集合作为测试数据，检验决策树对测试数据的预测精度，并计算出相应的错误率，如果剪掉某个子树后的决策树对测试数据的预测精度或其他测度不降低，那么剪掉该子树。 ▲关键就是用独立的验证数据集对训练集生长的树进行剪枝 CART剪枝 先来看看剪枝用到的准则函数：Cα(T)=C(T)+α∣Tleaf∣C_{\\alpha}(T)=C(T)+\\alpha|T_{leaf}|Cα​(T)=C(T)+α∣Tleaf​∣ C（T）是叶节点特性的度量，C4.3里它是熵的均值，CART决策树里它是基尼系数的概率均值，原理类似。多一个正则项，就是稀疏性约束。TleafT_{leaf}Tleaf​为叶子节点个数，越多，损失越大 ID3、C4.5算法中的剪枝原理是给定α，事实上很难一次给出理想的α。CART剪枝不再给定一个α，然后选择最优决策树，而是通过设定不同的α，通过交叉验证选择最优CART树，也就是： 训练集：得到不同的子树; 测试集：交叉验证选择最优树. 从有限个子树{T0,T1,…,Tn}\\left\\{T_{0}, T_{1}, \\ldots, T_{n}\\right\\}{T0​,T1​,…,Tn​}中计算最优子树，最优子树由验证集得出的测试误差决定，哪个最小就是哪个。 这里就引出了一个问题，每次剪哪一个节点呢？如何让TleafT_{leaf}Tleaf​到达一个合适的点呢？先看分析剪枝的两个极端情况： 1）完全没剪： Cα(Tt)=C(Tt)+α∣Tt∣C_{\\alpha}\\left(T_{t}\\right)=C\\left(T_{t}\\right)+\\alpha\\left|T_{t}\\right|Cα​(Tt​)=C(Tt​)+α∣Tt​∣ 2）只剩根节点： Cα(t)=C(t)+αC_{\\alpha}(t)=C(t)+\\alphaCα​(t)=C(t)+α 在α较小或者为0时，有： Cα(Tt)&lt;Cα(t)C_{\\alpha}\\left(T_{t}\\right)&lt;C_{\\alpha}(t)Cα​(Tt​)&lt;Cα​(t) 在α取+∞大时，有： Cα(Tt)&gt;Cα(t)C_{\\alpha}\\left(T_{t}\\right)&gt;C_{\\alpha}(t)Cα​(Tt​)&gt;Cα​(t) α是连续变量，因此总有临界点： Cα(Tt)=Cα(t)C_{\\alpha}\\left(T_{t}\\right)=C_{\\alpha}(t)Cα​(Tt​)=Cα​(t) 为了不混淆变量，重新定义： g(t)=C(t)−C(Tt)∣Tt∣−1g(t)=\\frac{C(t)-C\\left(T_{t}\\right)}{\\left|T_{t}\\right|-1}g(t)=∣Tt​∣−1C(t)−C(Tt​)​ α大于g(t)就是该剪。简而言之： 对于同一棵树的结点，α都是一样的，当α从0开始缓慢增大（或者从+∞慢慢减小），总会有某棵子树该剪，其他子树不该剪的情况，即α超过了某个结点的g(t)，但还没有超过其他结点的g(t)。这样随着alpha不断增大，不断地剪枝，就得到了n+1棵子树，接下来只要用独立数据集测试这n+1棵子树，试试哪棵子树的误差最小 就知道那棵是最好的方案了。 CART剪枝的算法过程 代码编写注意点 递归的结束条件： 一.到达叶节点 1.当某集合的值全是同一类时，那么该子集直接可作为叶子节点，为一个类别，此时不再下探。 2.在决策树构造过程中可能会出现这种情况：所有特征都作为分裂特征用光了，但子集还不是纯净集（集合内的元素不属于同一类别）。在这种情况下，由于没有更多信息可以使用了，一般对这些子集进行“多数表决”，即使用此子集中出现次数最多的类别作为此节点类别，然后将此节点作为叶子节点，此时不再下探 二.预剪枝条件 1.树的深度达到用户所要的深度 2.节点中样本个数少于用户指定个数 附录 借鉴： 机器学习实战教程（三）：决策树实战篇之为自己配个隐形眼镜 决策树算法原理及实现","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"}]},{"title":"Sklearn——决策树","slug":"Sklearn——决策树","date":"2019-08-30T13:43:27.000Z","updated":"2021-05-30T05:06:09.849Z","comments":true,"path":"2019/08/30/Sklearn——决策树/","link":"","permalink":"https://nymrli.top/2019/08/30/Sklearn——决策树/","excerpt":"","text":"Sklearn——决策树 注明：转载自Jack Gui的博客 1、实战背景 进入本文的正题：眼科医生是如何判断患者需要佩戴隐形眼镜的类型的？一旦理解了决策树的工作原理，我们甚至也可以帮助人们判断需要佩戴的镜片类型。 隐形眼镜数据集是非常著名的数据集，它包含很多换着眼部状态的观察条件以及医生推荐的隐形眼镜类型。隐形眼镜类型包括硬材质(hard)、软材质(soft)以及不适合佩戴隐形眼镜(no lenses)。数据来源与UCI数据库，数据集下载地址：[lenses.txt)]([https://github.com/Jack-Cherish/Machine-Learning/blob/master/Decision Tree/lenses.txt](https://github.com/Jack-Cherish/Machine-Learning/blob/master/Decision Tree/lenses.txt)) young myope no reduced no lenses young myope no normal soft young myope yes reduced no lenses young myope yes normal hard young hyper no reduced no lenses young hyper no normal soft young hyper yes reduced no lenses young hyper yes normal hard pre myope no reduced no lenses pre myope no normal soft pre myope yes reduced no lenses pre myope yes normal hard pre hyper no reduced no lenses pre hyper no normal soft pre hyper yes reduced no lenses pre hyper yes normal no lenses presbyopic myope no reduced no lenses presbyopic myope no normal no lenses presbyopic myope yes reduced no lenses presbyopic myope yes normal hard presbyopic hyper no reduced no lenses presbyopic hyper no normal soft presbyopic hyper yes reduced no lenses presbyopic hyper yes normal no lenses 一共有24组数据，数据的Labels依次是age、prescript、astigmatic、tearRate、class，也就是第一列是年龄，第二列是症状，第三列是是否散光，第四列是眼泪数量，第五列是最终的分类标签。数据如下图所示： 2、使用Sklearn构建决策树 官方英文文档地址：http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html sklearn.tree模块提供了决策树模型，用于解决分类问题和回归问题： 本次实战内容使用的是DecisionTreeClassifier和export_graphviz，前者用于决策树构建，后者用于决策树可视化。 DecisionTreeClassifier构建决策树： 让我们先看下DecisionTreeClassifier这个函数，一共有12个参数： 参数说明如下： **criterion：**特征选择标准，可选参数，默认是gini，可以设置为entropy。gini是基尼不纯度，是将来自集合的某种结果随机应用于某一数据项的预期误差率，是一种基于统计的思想。entropy是香农熵，也就是上篇文章讲过的内容，是一种基于信息论的思想。Sklearn把gini设为默认参数，应该也是做了相应的斟酌的，精度也许更高些？ID3算法使用的是entropy，CART算法使用的则是gini。 **splitter：**特征划分点选择标准，可选参数，默认是best，可以设置为random。每个结点的选择策略。best参数是根据算法选择最佳的切分特征，例如gini、entropy。random随机的在部分划分点中找局部最优的划分点。默认的&quot;best&quot;适合样本量不大的时候，而如果样本数据量非常大，此时决策树构建推荐&quot;random&quot;。 max_features： 划分时考虑的最大特征数，可选参数，默认是None。寻找最佳切分时考虑的最大特征数(n_features为总共的特征数)，有如下6种情况： 如果max_features是整型的数，则考虑max_features个特征； 如果max_features是浮点型的数，则考虑int(max_features * n_features)个特征； 如果max_features设为auto，那么max_features = sqrt(n_features)； 如果max_features设为sqrt，那么max_featrues = sqrt(n_features)，跟auto一样； 如果max_features设为log2，那么max_features = log2(n_features)； 如果max_features设为None，那么max_features = n_features，也就是所有特征都用。 一般来说，如果样本特征数不多，比如小于50，我们用默认的&quot;None&quot;就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。 **max_depth：**决策树最大深，可选参数，默认是None。这个参数是这是树的层数的。层数的概念就是，比如在贷款的例子中，决策树的层数是2层。如果这个参数设置为None，那么决策树在建立子树的时候不会限制子树的深度。一般来说，数据少或者特征少的时候可以不管这个值。或者如果设置了min_samples_slipt参数，那么直到少于min_smaples_split个样本为止。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。 **min_samples_split：**内部节点再划分所需最小样本数，可选参数，默认是2。这个值限制了子树继续划分的条件。如果min_samples_split为整数，那么在切分内部结点的时候，min_samples_split作为最小的样本数，也就是说，如果样本已经少于min_samples_split个样本，则停止继续切分。如果min_samples_split为浮点数，那么min_samples_split就是一个百分比，ceil(min_samples_split * n_samples)，数是向上取整的。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 **min_samples_leaf：**叶子节点最少样本数，可选参数，默认是1。这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。叶结点需要最少的样本数，也就是最后到叶结点，需要多少个样本才能算一个叶结点。如果设置为1，哪怕这个类别只有1个样本，决策树也会构建出来。如果min_samples_leaf是整数，那么min_samples_leaf作为最小的样本数。如果是浮点数，那么min_samples_leaf就是一个百分比，同上，celi(min_samples_leaf * n_samples)，数是向上取整的。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 **min_weight_fraction_leaf：**叶子节点最小的样本权重和，可选参数，默认是0。这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。 **max_leaf_nodes：**最大叶子节点数，可选参数，默认是None。通过限制最大叶子节点数，可以防止过拟合。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。 **class_weight：**类别权重，可选参数，默认是None，也可以字典、字典列表、balanced。指定样本各类别的的权重，主要是为了防止训练集某些类别的样本过多，导致训练的决策树过于偏向这些类别。类别的权重可以通过{class_label：weight}这样的格式给出，这里可以自己指定各个样本的权重，或者用balanced，如果使用balanced，则算法会自己计算权重，样本量少的类别所对应的样本权重会高。当然，如果你的样本类别分布没有明显的偏倚，则可以不管这个参数，选择默认的None。 **random_state：**可选参数，默认是None。随机数种子。如果是证书，那么random_state会作为随机数生成器的随机数种子。随机数种子，如果没有设置随机数，随机出来的数与当前系统时间有关，每个时刻都是不同的。如果设置了随机数种子，那么相同随机数种子，不同时刻产生的随机数也是相同的。如果是RandomState instance，那么random_state是随机数生成器。如果为None，则随机数生成器使用np.random。 **min_impurity_split：**节点划分最小不纯度,可选参数，默认是1e-7。这是个阈值，这个值限制了决策树的增长，如果某节点的不纯度(基尼系数，信息增益，均方差，绝对差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。 **presort：**数据是否预排序，可选参数，默认为False，这个值是布尔值，默认是False不排序。一般来说，如果样本量少或者限制了一个深度很小的决策树，设置为true可以让划分点选择更加快，决策树建立的更加快。如果样本量太大的话，反而没有什么好处。问题是样本量少的时候，我速度本来就不慢。所以这个值一般懒得理它就可以了。 除了这些参数要注意以外，其他在调参时的注意点有： 当样本数量少但是样本特征非常多的时候，决策树很容易过拟合，一般来说，样本数比特征数多一些会比较容易建立健壮的模型 如果样本数量少但是样本特征非常多，在拟合决策树模型前，推荐先做维度规约，比如主成分分析（PCA），特征选择（Losso）或者独立成分分析（ICA）。这样特征的维度会大大减小。再来拟合决策树模型效果会好。 推荐多用决策树的可视化，同时先限制决策树的深度，这样可以先观察下生成的决策树里数据的初步拟合情况，然后再决定是否要增加深度。 在训练模型时，注意观察样本的类别情况（主要指分类树），如果类别分布非常不均匀，就要考虑用class_weight来限制模型过于偏向样本多的类别。 决策树的数组使用的是numpy的float32类型，如果训练数据不是这样的格式，算法会先做copy再运行。 如果输入的样本矩阵是稀疏的，推荐在拟合前调用csc_matrix稀疏化，在预测前调用csr_matrix稀疏化。 sklearn.tree.DecisionTreeClassifier()提供了一些方法供我们使用，如下图所示： Code1 12345678910# -*- coding: UTF-8 -*-from sklearn import treeif __name__ == '__main__': fr = open('lenses.txt') lenses = [inst.strip().split('/t') for inst in fr.readlines()] print(lenses) lensesLabels = ['age', 'prescript', 'astigmatic', 'tearRate'] clf = tree.DecisionTreeClassifier() lenses = clf.fit(lenses, lensesLabels) ▲ 我们可以看到程序报错了，这是为什么？因为在fit()函数不能接收string类型的数据，通过打印的信息可以看到，数据都是string类型的。在使用fit()函数之前，我们需要对数据集进行编码，这里可以使用两种方法： LabelEncoder ：将字符串转换为增量值 OneHotEncoder：使用One-of-K算法将字符串转换为整数 为了对string类型的数据序列化，需要先生成pandas数据，这样方便我们的序列化工作。这里我使用的方法是，原始数据-&gt;字典-&gt;pandas数据，编写代码如下： 12345678910111213141516171819202122# -*- coding: UTF-8 -*-import pandas as pdif __name__ == '__main__': with open('lenses.txt', 'r') as fr: #加载文件 lenses = [inst.strip().split('/t') for inst in fr.readlines()] #处理文件 lenses_target = [] #提取每组数据的类别，保存在列表里 for each in lenses: lenses_target.append(each[-1]) lensesLabels = ['age', 'prescript', 'astigmatic', 'tearRate'] #特征标签 lenses_list = [] #保存lenses数据的临时列表 lenses_dict = &#123;&#125; #保存lenses数据的字典，用于生成pandas for each_label in lensesLabels: #提取信息，生成字典 for each in lenses: lenses_list.append(each[lensesLabels.index(each_label)]) lenses_dict[each_label] = lenses_list lenses_list = [] print(lenses_dict) #打印字典信息 lenses_pd = pd.DataFrame(lenses_dict) #生成pandas.DataFrame print(lenses_pd) # 顺利生成pandas数据。 接下来，将数据序列化，编写代码如下： 1234567891011121314151617181920212223242526272829# -*- coding: UTF-8 -*-import pandas as pdfrom sklearn.preprocessing import LabelEncoderimport pydotplusfrom sklearn.externals.six import StringIOif __name__ == '__main__': with open('lenses.txt', 'r') as fr: #加载文件 lenses = [inst.strip().split('/t') for inst in fr.readlines()] #处理文件 lenses_target = [] #提取每组数据的类别，保存在列表里 for each in lenses: lenses_target.append(each[-1]) lensesLabels = ['age', 'prescript', 'astigmatic', 'tearRate'] #特征标签 lenses_list = [] #保存lenses数据的临时列表 lenses_dict = &#123;&#125; #保存lenses数据的字典，用于生成pandas for each_label in lensesLabels: #提取信息，生成字典 for each in lenses: lenses_list.append(each[lensesLabels.index(each_label)]) lenses_dict[each_label] = lenses_list lenses_list = [] # print(lenses_dict) #打印字典信息 lenses_pd = pd.DataFrame(lenses_dict) # 生成pandas.DataFrame print(lenses_pd) #打印pandas.DataFrame le = LabelEncoder() #创建LabelEncoder()对象，用于序列化 for col in lenses_pd.columns: #为每一列序列化 lenses_pd[col] = le.fit_transform(lenses_pd[col]) print(lenses_pd) 从打印结果可以看到，我们已经将数据顺利序列化，接下来。我们就可以fit()数据，构建决策树了。 3、使用Graphviz可视化决策树 Graphviz的是AT&amp;T Labs Research开发的图形绘制工具，他可以很方便的用来绘制结构化的图形网络，支持多种格式输出，生成图片的质量和速度都不错。它的输入是一个用dot语言编写的绘图脚本，通过对输入脚本的解析，分析出其中的点，边以及子图，然后根据属性进行绘制。是使用Sklearn生成的决策树就是dot格式的，因此我们可以直接利用Graphviz将决策树可视化。 在讲解编写代码之前，我们需要安装两样东西，即pydotplus和Grphviz。 （1）安装Pydotplus pydotplus可以在CMD窗口中，直接使用指令安装：pip3 install pydotplus （2）安装Graphviz Graphviz不能使用pip进行安装，我们需要手动安装，下载地址：https://www.graphviz.org，可能下载比较慢。 安装以后，需要设置环境变量，如将D:/graphviz-2.38/release/bin加入到Path中，然后运行下之后的代码看是否能正常使用。 （3）编写代码 Talk is Cheap, show me the code.(废话少说，放码过来)。可视化部分的代码不难，都是有套路的，直接填参数就好，详细内容可以查看官方教程：http://scikit-learn.org/stable/modules/tree.html#tree 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: UTF-8 -*-from sklearn.preprocessing import LabelEncoder, OneHotEncoderfrom sklearn.externals.six import StringIOfrom sklearn import treeimport pandas as pdimport numpy as npimport pydotplusif __name__ == '__main__': with open('lenses.txt', 'r') as fr: #加载文件 lenses = [inst.strip().split('/t') for inst in fr.readlines()] #处理文件 lenses_target = [] #提取每组数据的类别，保存在列表里 for each in lenses: lenses_target.append(each[-1]) print(lenses_target) lensesLabels = ['age', 'prescript', 'astigmatic', 'tearRate'] #特征标签 lenses_list = [] #保存lenses数据的临时列表 lenses_dict = &#123;&#125; #保存lenses数据的字典，用于生成pandas for each_label in lensesLabels: #提取信息，生成字典 for each in lenses: lenses_list.append(each[lensesLabels.index(each_label)]) lenses_dict[each_label] = lenses_list lenses_list = [] # print(lenses_dict) #打印字典信息 lenses_pd = pd.DataFrame(lenses_dict) #生成pandas.DataFrame # print(lenses_pd) #打印pandas.DataFrame le = LabelEncoder() #创建LabelEncoder()对象，用于序列化 for col in lenses_pd.columns: #序列化 lenses_pd[col] = le.fit_transform(lenses_pd[col]) # print(lenses_pd) #打印编码信息 clf = tree.DecisionTreeClassifier(max_depth = 4) #创建DecisionTreeClassifier()类 clf = clf.fit(lenses_pd.values.tolist(), lenses_target) #使用数据，构建决策树 dot_data = StringIO() tree.export_graphviz(clf, out_file = dot_data, #绘制决策树 feature_names = lenses_pd.keys(), class_names = clf.classes_, filled=True, rounded=True, special_characters=True) graph = pydotplus.graph_from_dot_data(dot_data.getvalue()) graph.write_pdf(\"tree.pdf\") #保存绘制好的决策树，以PDF的形式存储。 运行代码，在该python文件保存的相同目录下，会生成一个名为tree的PDF文件，打开文件，我们就可以看到决策树的可视化效果图了。 确定好决策树之后，我们就可以做预测了。可以根据自己的眼睛情况和年龄等特征，看一看自己适合何种材质的隐形眼镜。使用如下代码就可以看到预测结果：print(clf.predict([[1,1,1,0]])) #预测 总结 决策树的一些优点： 易于理解和解释。决策树可以可视化。 几乎不需要数据预处理。其他方法经常需要数据标准化，创建虚拟变量和删除缺失值。决策树还不支持缺失值。 使用树的花费（例如预测数据）是训练数据点(data points)数量的对数。 可以同时处理数值变量和分类变量。其他方法大都适用于分析一种变量的集合。 可以处理多值输出变量问题。 使用白盒模型。如果一个情况被观察到，使用逻辑判断容易表示这种规则。相反，如果是黑盒模型（例如人工神经网络），结果会非常难解释。 即使对真实模型来说，假设无效的情况下，也可以较好的适用。 决策树的一些缺点： 决策树学习可能创建一个过于复杂的树，并不能很好的预测数据。也就是过拟合。修剪机制（现在不支持），设置一个叶子节点需要的最小样本数量，或者数的最大深度，可以避免过拟合。 决策树可能是不稳定的，因为即使非常小的变异，可能会产生一颗完全不同的树。这个问题通过decision trees with an ensemble来缓解。 概念难以学习，因为决策树没有很好的解释他们，例如，XOR, parity or multiplexer problems。 如果某些分类占优势，决策树将会创建一棵有偏差的树。因此，建议在训练之前，先抽样使样本均衡。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Pythton","slug":"Pythton","permalink":"https://nymrli.top/tags/Pythton/"}]},{"title":"ACM-博弈论","slug":"ACM-博弈论","date":"2019-08-30T13:41:28.000Z","updated":"2019-09-15T08:07:30.912Z","comments":true,"path":"2019/08/30/ACM-博弈论/","link":"","permalink":"https://nymrli.top/2019/08/30/ACM-博弈论/","excerpt":"","text":"ACM-博弈论（gambling） 博弈论：是二人或多人在平等的对局中各自利用对方的策略变换自己的对抗策略，达到取胜目标的理论。假设，双方每步都是最优决策 博弈论是研究互动决策的理论。博弈可以分析自己与对手的利弊关系，从而确立自己在博弈中的优势，因此有不少博弈理论，可以帮助对弈者分析局势，从而采取相应策略，最终达到取胜的目的。 巴什博弈 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 显然，如果n=m+1，1那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了先手如何取胜的法则：除了先手取以外，之后每个双方回合时保证取走m+1个物品则能保证先手胜。 ▲即如果n=(m+1)*r+s，（r为任意自然数，0&lt;s&lt;=m），那么先取者要拿走s个物品，如果后取者拿走k（&lt;=m）个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。 结论 编程解题的方法就是判断n是否能表示为(m+1)*r+s，找到这个m，和存在r，s s不为0，所以当n=(m+1)*r时，后手必胜 这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。 例题HDU1846——Brave Game，裸题 n为总价、总和，m为每次能取的大小 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, m; int t; cin &gt;&gt; t; while(t--)&#123; cin&gt;&gt;n &gt;&gt;m; int mod = n%(m+1); if (mod != 0) cout &lt;&lt; \"first\" &lt;&lt;endl; else cout &lt;&lt; \"second\" &lt;&lt; endl; &#125; return 0;&#125; Public Sale 区别在于还存在n&lt;m的情况，由于题目要求每次加价的幅度要在1～N之间，当价格大于或等于田地的成本价 M 时，主办方就把这块田地卖给这次叫价的人。，所以此时，第一次出价n+1~m都可以直接将物品买下，需要单独考虑 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, m; while (cin &gt;&gt; n&gt;&gt;m)&#123; if (n&lt;m) &#123; for(int i=n+1;i&lt;=m;i++) cout &lt;&lt; i &lt;&lt; \" \"; cout &lt;&lt; endl; &#125;else&#123; int mod = n%(m+1); if (mod == 0) cout &lt;&lt; \"none\"&lt;&lt;endl; //s=0，后手必胜 else cout &lt;&lt; mod &lt;&lt; endl; //存在s，即先手的Lele能买到 &#125; &#125; return 0;&#125; 斐波那契博弈 有一堆个数为n的石子，游戏双方轮流取石子，满足： 1）先手不能在第一次把所有的石子取完； 2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。 ▲ 游戏规则动态化 这个游戏叫做Fibonacci Nim，肯定和Fibonacci数列：f[n]：1，2，3，5，8，13，21，34，55，89…有密切的关系。如果试验一番之后，可以猜测：先手胜当且仅当n不是Fibonacci数。换句话说，必败态构成Fibonacci数列。 就像“Wythof博弈”需要“Beatty定理”来帮忙一样，这里需要借助**“Zeckendof定理”（齐肯多夫定理）**：任何正整数可以表示为若干个不连续的Fibonacci数之和。定理的证明可以在这里看到，不过我觉得更重要的是自己动手分解一下。 e.g.比如，我们要分解83，注意到83被夹在55和89之间，于是把83可以写成83=55+28；然后再想办法分解28，28被夹在21和34之间，于是28=21+7；依此类推7=5+2，故； 如果n=83，我们看看这个分解有什么指导意义：假如先手取2颗，那么后手无法取5颗或更多，而5是一个Fibonacci数，如果猜测正确的话，（面临这5颗的先手实际上是整个游戏的后手）归纳得如果需要取走斐波那契数n，那么后手必胜，即那么一定是游戏的先手（此时为取5个的后手）取走这5颗石子中的最后一颗，而这个我们可以通过第二类归纳法来绕过，同样的道理，接下去先手取走接下来的后21颗中的最后一颗，再取走后55颗中的最后一颗，那么先手赢。需要注意到的是分解后不连续的若干个数单个的两倍都小于分解的最大数，即2n&lt;m ▲如果n是斐波那契数，后手一定赢，如果不是，先手一定赢（先手胜当且仅当n不是斐波那契数列）。因为如果n是斐波那契数，那么先手取走数之后剩下的一定不是斐波那契数，后手必胜 例题hdoj 2516 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int arr[50];// feiboint main()&#123; int n; arr[0] = 2,arr[1] = 3; for(int i=2;i&lt;=50;i++) arr[i]=arr[i-1]+arr[i-2]; while (cin &gt;&gt; n &amp;&amp; n)&#123; int flag = 1; for(int i=0;i&lt;=50;i++)&#123; if (arr[i]==n) flag=0,cout&lt;&lt;\"Second win\"&lt;&lt;endl; if (arr[i]&gt;n) break; &#125; if (flag) cout &lt;&lt; \"First win\" &lt;&lt;endl; &#125; return 0;&#125; 总结： 不需要深究博弈论数学原理，只需要知道结论，就可以写出代码。如， 巴什博弈：判断mod=n%(m+1)的结果s 斐波那契博弈：判断n是否为斐波那契数 威佐夫博弈 有两维各若干个物品(ak, bk)，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况下是颇为复杂的。我们用（ak，bk）（ak&lt;=bk，k=0，1，2，.……n）表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出，a0=b0=0，ak是未在前面出现过的最小自然数，而bk=ak+k，奇异局势有如下三条性质： 1.任何自然数都包含在一个且仅有一个奇异局势中。 由于ak是未在前面出现过的最小自然数，所以有ak&gt;ak-1，而bk=ak+k&gt;ak-1+k-1=bk-1&gt;ak-1。所以性质1。成立。 2.任意操作都可将奇异局势变为非奇异局势。 事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。 3.采用适当的方法，可以将非奇异局势变为奇异局势。 从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，面对奇异局势，则后拿者取胜。 Betty定理:… ▲那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： ak =[k（1+V5）/2]，bk=ak+k（k=0，1，2，.……n方括号表示取整函数）奇妙的是其中出现了黄金分割数（1+V5）/2=1.618…，因此，由ak，bk组成的矩形近似为黄金矩形，由于2/（1+V5）=（V5-1）/2，可以先求出j=[a（V5-1）/2]，若a=[（1+V5）/2]，那么a=aj，bj=aj+j，若不等于，那么a=aj+1，bj+1=aj+1+j+1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。===&gt; 如果(b-a)*(sqrt(5.0)+1)/2 == a的话就是奇异局势 例题poj 1067，裸题 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a, b, c; while(cin &gt;&gt; a &gt;&gt; b)&#123; if (a&gt;b) swap(a,b); int c = floor((b-a)*(sqrt(5.0)+1)/2); if (a==c) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; 1 &lt;&lt; endl; &#125; return 0;&#125; 尼姆博弈（Nim） 有n堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 以n=3为例子，这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情形。 然而这并不是博弈的重点，博弈之王道乃是SG值，当sg值为0的时候，就是输，不为0就是赢； SG值：一个点的SG值就是一个不等于它的后继点SG值的且大于等于零的最小整数。 不属于它后继点SG值集的值 大概的意思就是：在步骤允许的情况下，与前面一个必败点的差（也就是说这个差是规定的、能走的、其中一个步数）！ 后继点：也就是按照题目要求的走法（比如取石子可以取的数量，方法）能够走一步达到的那个点。（sg值的理解很抽象。需要多画画） 举个栗子：比如一堆石子，我们可以取任意个，那么x个石子的石子的sg值是多少呢？可以知道，0个石子sg为0，1的时候我们可以取一个，剩下0，0的sg是0(SG(0)=0)，那么mex(0)就是1，所以1的sg为1(SG(1)=1)。即SG(1) = mex{SG(0)}=mex{0}=1 例题hdoj 1847 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int arr[15],sg[1005];int mex(int x)&#123; if(sg[x] != -1) return sg[x]; // 记忆化搜索,如果存在直接返回 bool vis[1005]; for(int i=0; i&lt;1005;i++) vis[i] = false; for (int i =0;i&lt;=10;i++) &#123; int temp = x - arr[i]; if (temp&lt;0) break; // SG值为非负整数 sg[temp] = mex(temp); // 需要递归调用，分治求出小的部分的结果 vis[sg[temp]] = true; &#125; for (int i =0;;i++) if(!vis[i]) &#123; // 找到最小的数，mex&#123;0,1,2&#125;=3，mex&#123;1,2,3&#125;=0，mex&#123;0,1,3&#125;=2； sg[x]=i; break; &#125; return sg[x];&#125;int main()&#123; int n; arr[0] = 1; for (int i = 1; i&lt;=10; i++) arr[i] = arr[i-1]*2; while(cin &gt;&gt; n)&#123; memset(sg,-1,sizeof(sg)); if (mex(n)) cout &lt;&lt; \"Kiki\" &lt;&lt;endl; else cout &lt;&lt; \"Cici\" &lt;&lt; endl; &#125; return 0;&#125; 组合博弈：（博弈的精华） 组合博弈无疑是对sg值的熟练操作例如：有n堆石子，每次可以从第1堆石子里取1颗、2颗或3颗，可以从第2堆石子里取奇数颗，可以从第3堆及以后石子里取任意颗.……我们可以把它看作3个子游戏，第1个子游戏只有一堆石子，每次可以取1、2、3颗，很容易看出x颗石子的局面的SG值是×%4。第2个子游戏也是只有一堆石子，每次可以取奇数颗，经过简单的画图可以知道这个游戏有x颗石子时的SG值是×%2。第3个游戏有n-2堆石子，就是一个Nim游戏。对于原游戏的每个局面，把三个子游戏的SG值异或一下就得到了整个游戏的SG值，然后就可以根据这个SG值判断是否有必胜策略以及做出决策了。其实看作3个子游戏还是保守了些，干脆看作n个子游戏，其中第1、2个子游戏如上所述，第3个及以后的子游戏都是“1堆石子，每次取几颗都可以”，称为“任取石子游戏”，这个超简单的游戏有x颗石子的SG值显然就是x。 SWPU-ACM每周算法讲堂-博弈论入门 计算机博弈大赛 蒙特卡洛方法 由冯·诺依曼、乌拉姆等人发明，因蒙特卡洛赌场而闻名，一种基于概率的方法的统称。 一种让人感觉“我去，这也行”的方法——根据大概率逼近真实结果的方法 拉斯维加斯（Las Vegas）方法——找老婆（必须要精确找到那一个答案，其他都不行。采样越多，越有机会找到最优解） 找1W人才能准确确定 蒙特卡罗（Monte Carlo）方法——民意调查（一直在找，找的是逐渐贴近于最优解的结果。当样越多，越近似最优解） 找了2K人大致能确定了 相关方法： 蒙特卡罗算法、蒙特卡罗模拟、蒙特卡罗过程 蒙特卡罗搜索树一—AlphaGo 工作原理： 不断抽样（中心极限定理，n-&gt;∞） 逐渐逼近（依概率逼近） 蒙特卡洛树搜索 （MCTS，Monte Carlo tree search） 一种用于某些决策过程的启发式搜索算法，最引人注目的是在游戏中的使用 双人有限零和顺序游戏 MCTS运行所在的框架/环境是一个游戏，它本身是一个非常抽象和宽泛的概念，因此这里我们只关注一种游戏类型：双人有限零和顺序游戏。这个名词一开始听起来会有些复杂，但是实际上非常简单，现在来让我们将它分解一下： 游戏：意味着我们在一种需要交互的情境中，交互通常会涉及一个或多个角色 有限：表明在任意时间点，角色之间存在的交互方式都是有限的 双人：游戏中只有两个角色 顺序：玩家依次交替进行他们的动作 零和：参与游戏的两方有完全相反的目标，换句话说就是，游戏的任意结束状态双方的收益之和等于零 我们可以很轻松的验证，围棋、国际象棋和井字棋都是双人有限零和顺序游戏：有两位玩家参与，玩家能进行的动作总是有限的，双方的游戏目标是完全相反的（所有游戏的结果之和等于0）。 如何表示一个游戏 从程序员的角度来看，可以用一种常见的数据结构以来表示游戏——游戏树。 游戏树是一个数，其中每一个节点代表游戏的一个确定状态。从一个节点到该节点的一个子节点（如果存在）是一个移动。节点的子节点数目称为分支因子。游戏树的根节点代表游戏的初始状态。游戏树的终端节点是没有子节点的节点，至此游戏结束，无法再进行移动。终端节点的状态也就是游戏的结果（输/赢/平局）。 游戏树是一种递归的数据结构，每次选择完最佳的下一步时，会移动到下一个子节点，而这个子节点又是它子树的根节点。因此我们可以把一局游戏视为“最佳下一步”的一个问题序列，每一次都可以由一个不同根节点的游戏树表示。通常在实际应用中，我们不需要记住到当前状态的路径，因为这不是当前游戏状态的关注点。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"Linux三剑客","slug":"Linux三剑客","date":"2019-08-30T13:37:36.000Z","updated":"2021-10-19T08:50:01.739Z","comments":true,"path":"2019/08/30/Linux三剑客/","link":"","permalink":"https://nymrli.top/2019/08/30/Linux三剑客/","excerpt":"","text":"Linux三剑客 bash命令执行顺序 把命令行分成单个命令词 展开别名 展开大括号的声明（{}） 展开波浪符声明（~） 命令替换$0和&quot;) 再次把命令行分成命令词 展开文件通配（*、？、[abc]等等） 准备I/0重导向（&lt;、&gt;） 运行命令 文件查找 非实时搜索locate 速度快 更新updatabase 实时搜索工具find 搜索速度略慢 精确查找 只能搜索用户具备读取和执行权限的目录 sed(Stream EDitor): sed后字符使用单引号 语法：sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件] demo: sed -n '22,$p' test 指令解释:常用选项[-n]，‘地址定界[22,$],编辑命令[p]’ 地址定界: 不给地址: 全文处理 单地址 #: 指定行 $: 最后一行 /pattern: 正则匹配 地址范围 #,#,如1,20即1-20行 e.g.sed -n '22,$p' test #,+#,如2,+20即2-2+20 行 #;#如3;5即第3和第5行 /pat1/,/pat2/ #,/pat1/ 步进~ 1~2 奇数行 sed -n &quot;1~2p&quot; f1 2~2 偶数行 正则 sed ‘/regex expression/[option] text’ filename ^匹配每一行的开头 $匹配行的结尾 匹配包含2、3、或者4的行 sed -n '/[234]/p' employee.txt 删除所有以#开头的行 **sed -e 's/^#./*// ; /^$/d' employee.txt** 删除所有注释和空行 sed -e 's/#.*//;/^$/ d' /etc/profile 只删除注释行不删除空行 sed '/^#.*/d' /etc/profile 常用选项 -n不自动打印 -f 指定文件中读取编辑脚本 script.txt 12~2p sed -n -f script.txt f1 -r支持使用拓展正则表达式 sed -r 's/(GRUB_CMDLINE_LINUX.*)&quot;$//1 xyz&quot;/'/etc/default/grub echo&quot;/etc/sysconfig/network/&quot; | sed -r 's/(.*//)([^/]//?$)//1/' -i.bak生成备份文件bak并原处编辑 如果没有-i表示只是预览,不会真正执行 -e多点编辑,即多次处理文件 -e &lt;script&gt;或--expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。 -E是与BSD sed兼容的未记录的选项，在BSD中sed用于支持扩展的正则表达式。 编辑动作命令 d删除末世空间匹配的行,并启用下一轮循环 sed -n 'd' test全删 sed -n '1d' test只删第一行 p打印当前模式空间内容,追加到默认输出后 a[/]test 指定行追加 i[/]test 行前插入 c[/]test 替换行为单行或多行 = 为模式空间中的行打印行号 sed -n ‘3,5{=;p}’ test ! 模式空间中匹配行取反 w/path/somefile：保存模式匹配的行至指定文件 r/path/somefile：读取指定文件的文本至模式空间中匹配到的行后 sed'/User/r sed.txt' .bashrc 搜索代替 123sed &apos;s/xxx/xxx/&apos; filename# sed &apos;s@xxx@xxx&apos; filename# sed &apos;s#xxx#xxx&apos; filename 替换标记： g：行内全局替换 p：显示替换成功的行 W/PATH/TO/SOMEFILE：将替换成功的行保存至文件中 以下命令如果需要在文本中更改 需要加 -i 或者 -ri参数 用sed在aaa前加#注释 1sed 's/^aaa/#&amp;/' zimu.txt # &amp;的意思是匹配任意字符（就是说未知数，啥都行） 这条命令是 替换以aaa开头的 用sed取消bbb前面的注释 12sed 's/^#(bbb)//1/' zimu.txt #/1的意思 就类似于 前面的 (bbb/） /1就是复制这个位置的内容 如果有 第二个 那么久/2就是复制第二个位置的内容sed 's/^#bbb/bbb/' zimu.txt 附录： &lt;&lt;&lt;: sed 's/g/dddd/' &lt;&lt;&lt; &quot;ghhhg&quot;-&gt;ddddhhhg var=hello, sed 's/e/dddd/' &lt;&lt;&lt; &quot;$var&quot; -&gt; hddddllo awk 优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一 ifconfig获得ip_addr的命令 1.ifconfig | grep inet | awk '{print $2}' | awk -F 'addr:' '{print $2}' 2.ifconfig | grep addr:192.168.* | awk '{print$2}' | awk '{split($0,a,/&quot;:/&quot;);print(a[2])}' ▲.尽量使用单引号'',而不是&quot;&quot; -F分隔符 e.g.echo &quot;A|B|C|D&quot; | awk -F &quot;|&quot; '{print($1)}' NF列的个数 awk -F: '$3&lt;10{print $1 &lt;====&gt; $NF}' /etc/passwd {}中的内容为要要执行的内容 NR当前行号 linux单双引号区别 双引号：把双引号的内容输出出来；如果内容中有命令，变量等，会先把命令，变量解析出结果，然后再输出最终内容来。双引号内命令或变量的写法为命令或变量或$（命令或变量） 单引号：所见即所得，将单引号内的内容原样输出，阻止所有字符的转义 不加引号：不会将含有空格的字符串视为一个整体输出，如果内容中有命令，变量等，会先把命令，变量解析出结果，然后再输出最终内容来，如果字符串含有空格等特殊字符，则不能完整输出，则需改加双引号。 倒引号（反引号Esc键下方）：进行命令的替换，在倒引号内部的shell命令将会被执行，其结果输出代替用倒引号括起来的文本。 echo &quot;1111/n222&quot;不会转移/n echo -e &quot;11111/n222&quot;会转义/n xargs -n1每行1个元素;xargs -n2 每行2个元素; grep(Globally search a Regular Expression and Print) 一种强大的文本搜索工具，它能使用特定模式匹配（包括正则表达式）搜索文本，并默认输出匹配行 常见命令ps -aux | grep xxxx 选项与参数： -a ：将 binary 文件以 text 文件的方式搜寻数据 -c ：计算找到 ‘搜寻字符串’ 的次数 -i ：忽略大小写的不同，所以大小写视为相同 -n ：顺便输出行号 -v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！ -x --line-regexp : 只显示全列符合的列。","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://nymrli.top/tags/运维/"},{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"2019_6月编程笔记","slug":"2019-6月编程笔记","date":"2019-08-30T13:26:03.000Z","updated":"2019-11-26T07:42:09.614Z","comments":true,"path":"2019/08/30/2019-6月编程笔记/","link":"","permalink":"https://nymrli.top/2019/08/30/2019-6月编程笔记/","excerpt":"","text":"2019_6月编程笔记 注，不少内容比较多，已单独分出去成为独立的文章，更详细的介绍可见这些文章 硬盘格式 fat32 单文件4G， 做引导分区 系统引导程序能读fat32 只能主引导记录，选择能找到efi程序 exfat 支持更大空间，引导识别不了，做不了系统盘 Python all __all__是一个字符串list； 约束作用：用来定义模块中对于from XXX import *时要对外导出的符号，即要暴露的借口，但它只对import *起作用，对from XXX import XXX不起作用。 from njupt.zhengfang import Zhengfang是在__init__.py里用all标出后在该目录下的其他模块能直接通过from njupt import Zhengfang来调用。修改了导入的方式 eval 和 exec 1.exec能执行多段Python代码，eval只能执行当行 123456exec(\"\"\"print('hello')print('world')\"\"\")eval(\"print('hello')\") 2.而Python中的eval函数可以计算Python表达式，并返回结果；（exec不返回结果，print(eval(&quot;…&quot;))打印None）； os.environ 12345678910111213# 使用os.environ来读取和修改环境变量：import osprint (os.environ[\"TEMP\"])mydir = \"c://mydir\"os.environ[\"MYDIR\"] = mydirprint (os.environ[\"MYDIR\"])pathV = os.environ[\"PATH\"]print (pathV)os.environ[\"PATH\"]= mydir + \";\" + os.environ[\"PATH\"]print (os.environ[\"PATH\"]) sys.path的insert和append python程序中使用 import XXX 时，python解析器会在当前目录、已安装和第三方模块中搜索 xxx，如果都搜索不到就会报错。 使用sys.path.append()方法可以临时添加搜索路径，方便更简洁的import其他包和模块。这种方法导入的路径会在python程序退出后失效。 1.对于模块和自己写的脚本不在同一个目录下，在脚本开头加 12import sys sys.path.append(’引用模块的地址') 2.把路径添加到系统的环境变量，或把该路径的文件夹放进已经添加到系统环境变量的路径内。环境变量的内容会自动添加到模块搜索路径中。 insert：定义搜索优先顺序 12import syssys.path.insert(1, \"./model\") sys.path.insert(1, &quot;./crnn&quot;)定义搜索路径的优先顺序，序号从0开始，表示最大优先级，sys.path.insert()加入的也是临时搜索路径，程序退出后失效。 sphinx使用 pip install sphinx 1.新建docs文件夹 2.sphinx-quickstart 3.配置 教程说明： 12345678910111213141516171819202122&gt; Root path for the documentation [.]: doc # 在当前目录下新建doc文件夹存放sphinx相关信息&gt; Separate source and build directories (y/n) [n]: # 默认，直接回车&gt; Name prefix for templates and static dir [_]:&gt; Project name: python123 # 输入项目名称&gt; Author name(s): 123 # 作者&gt; Project version: 1.0 # 项目版本&gt; Project release [1.0]:&gt; Project language [en]: # 默认，回车&gt; Source file suffix [.rst]:&gt; Name of your master document (without suffix) [index]:&gt; Do you want to use the epub builder (y/n) [n]:&gt; autodoc: automatically insert docstrings from modules (y/n) [n]: y # 这个很重要，输入y&gt; doctest: automatically test code snippets in doctest blocks (y/n) [n]:&gt; intersphinx: link between Sphinx documentation of different projects (y/n) [n]:&gt; todo: write \"todo\" entries that can be shown or hidden on build (y/n) [n]:&gt; coverage: checks for documentation coverage (y/n) [n]:&gt; pngmath: include math, rendered as PNG images (y/n) [n]:&gt; mathjax: include math, rendered in the browser by MathJax (y/n) [n]:&gt; ifconfig: conditional inclusion of content based on config values (y/n) [n]:&gt; viewcode: include links to the source code of documented Python objects (y/n) [n]: y # 很重要，输入y，表示将源码也放到文档中，你看很多python的模块的文档，其实都是包含代码的。&gt; Create Makefile? (y/n) [y]:&gt; Create Windows command file? (y/n) [y]: windows实测： 1234567891011121314151617181920212223242526272829303132333435363738(Python_web) E:/Python_web/Code/Quan&gt;sphinx-quickstartWelcome to the Sphinx 2.1.0 quickstart utility.Please enter values for the following settings (just press Enter toaccept a default value, if one is given in brackets).Selected root path: .You have two options for placing the build directory for Sphinx output.Either, you use a directory \"_build\" within the root path, or you separate\"source\" and \"build\" directories within the root path.&gt; Separate source and build directories (y/n) [n]: nThe project name will occur in several places in the built documentation.&gt; Project name: TaobaoQuan&gt; Author name(s): Mrli&gt; Project release []: 1.0If the documents are to be written in a language other than English,you can select a language here by its language code. Sphinx will thentranslate text that it generates into that language.For a list of supported codes, seehttp://sphinx-doc.org/config.html#confval-language.&gt; Project language [en]: enCreating file ./conf.py.Creating file ./index.rst.Creating file ./Makefile.Creating file ./make.bat.Finished: An initial directory structure has been created.You should now populate your master file ./index.rst and create other documentationsource files. Use the Makefile to build the docs, like so: make builderwhere \"builder\" is one of the supported builders, e.g. html, latex or linkcheck. 编写好目录下的所有.rst（默认生成了模板index.rst）文件后./make.bat html可以生成网页目录 conf.py默认模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# Configuration file for the Sphinx documentation builder.## This file only contains a selection of the most common options. For a full# list see the documentation:# http://www.sphinx-doc.org/en/master/config# -- Path setup --------------------------------------------------------------# If extensions (or modules to document with autodoc) are in another directory,# add these directories to sys.path here. If the directory is relative to the# documentation root, use os.path.abspath to make it absolute, like shown here.## import os# import sys# sys.path.insert(0, os.path.abspath('.'))# -- Project information -----------------------------------------------------project = 'TaobaoQuan'copyright = '2019, Mrli'author = 'Mrli'# The full version, including alpha/beta/rc tagsrelease = '1.0'# -- General configuration ---------------------------------------------------# Add any Sphinx extension module names here, as strings. They can be# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom# ones.extensions = []# Add any paths that contain templates here, relative to this directory.templates_path = ['_templates']# List of patterns, relative to source directory, that match files and# directories to ignore when looking for source files.# This pattern also affects html_static_path and html_extra_path.exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']# -- Options for HTML output -------------------------------------------------# The theme to use for HTML and HTML Help pages. See the documentation for# a list of builtin themes.#html_theme = 'alabaster'# Add any paths that contain custom static files (such as style sheets) here,# relative to this directory. They are copied after the builtin static files,# so a file named \"default.css\" will overwrite the builtin \"default.css\".html_static_path = ['_static'] Gaoliang模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161# -*- coding: utf-8 -*-## Configuration file for the Sphinx documentation builder.## This file does only contain a selection of the most common options. For a# full list see the documentation:# http://www.sphinx-doc.org/en/master/config# -- Path setup --------------------------------------------------------------# If extensions (or modules to document with autodoc) are in another directory,# add these directories to sys.path here. If the directory is relative to the# documentation root, use os.path.abspath to make it absolute, like shown here.#import osimport sys# sys.path.insert(0, os.path.abspath('.'))# Insert NJUPT-API' path into the system.sys.path.insert(0, os.path.abspath('..'))# -- Project information -----------------------------------------------------project = '...'copyright = '...'author = '...'# The short X.Y versionversion = ''# The full version, including alpha/beta/rc tagsrelease = ''# -- General configuration ---------------------------------------------------# If your documentation needs a minimal Sphinx version, state it here.## needs_sphinx = '1.0'# Add any Sphinx extension module names here, as strings. They can be# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom# ones.extensions = [ 'sphinx.ext.autodoc',]html_logo = \"_static/logo_tiny.png\"# Add any paths that contain templates here, relative to this directory.templates_path = ['_templates']# The suffix(es) of source filenames.# You can specify multiple suffix as a list of string:## source_suffix = ['.rst', '.md']source_suffix = '.rst'# The master toctree document.master_doc = 'index'# The language for content autogenerated by Sphinx. Refer to documentation# for a list of supported languages.## This is also used if you do content translation via gettext catalogs.# Usually you set \"language\" from the command line for these cases.language = 'zh_CN'# List of patterns, relative to source directory, that match files and# directories to ignore when looking for source files.# This pattern also affects html_static_path and html_extra_path .exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']# The name of the Pygments (syntax highlighting) style to use.pygments_style = 'sphinx'# -- Options for HTML output -------------------------------------------------# The theme to use for HTML and HTML Help pages. See the documentation for# a list of builtin themes.## html_theme = 'sphinx_rtd_theme'# html_theme = 'alabaster'# html_theme = 'flask'# Theme options are theme-specific and customize the look and feel of a theme# further. For a list of options available for each theme, see the# documentation.#html_theme_options = &#123; # 'show_powered_by': False,&#125;# Add any paths that contain custom static files (such as style sheets) here,# relative to this directory. They are copied after the builtin static files,# so a file named \"default.css\" will overwrite the builtin \"default.css\".html_static_path = ['_static']# Custom sidebar templates, must be a dictionary that maps document names# to template names.## The default sidebars (for documents that don't match any pattern) are# defined by theme itself. Builtin themes are using these templates by# default: ``['localtoc.html', 'relations.html', 'sourcelink.html',# 'searchbox.html']``.#html_show_sourcelink = False# -- Options for HTMLHelp output ---------------------------------------------# Output file base name for HTML help builder.htmlhelp_basename = 'NJUPT-APIdoc'# -- Options for LaTeX output ------------------------------------------------latex_elements = &#123; # The paper size ('letterpaper' or 'a4paper'). # # 'papersize': 'letterpaper', # The font size ('10pt', '11pt' or '12pt'). # # 'pointsize': '10pt', # Additional stuff for the LaTeX preamble. # # 'preamble': '', # Latex figure (float) alignment # # 'figure_align': 'htbp',&#125;# Grouping the document tree into LaTeX files. List of tuples# (source start file, target name, title,# author, documentclass [howto, manual, or own class]).latex_documents = [ (master_doc, 'NJUPT-API.tex', 'NJUPT-API Documentation', 'gaoliang', 'manual'),]# -- Options for manual page output ------------------------------------------# One entry per manual page. List of tuples# (source start file, name, description, authors, manual section).man_pages = [ (master_doc, 'njupt-api', 'NJUPT-API Documentation', [author], 1)]# -- Options for Texinfo output ----------------------------------------------# Grouping the document tree into Texinfo files. List of tuples# (source start file, target name, title, author,# dir menu entry, description, category)texinfo_documents = [ (master_doc, 'NJUPT-API', 'NJUPT-API Documentation', author, 'NJUPT-API', 'One line description of project.', 'Miscellaneous'),]# -- Extension configuration ------------------------------------------------- python代码docstring生成文档之sphinx Python 验证码识别 通过pytesseracthttps://blog.csdn.net/weixin_42812527/article/details/81264189 windows10安装使用pytesseract坑：https://blog.csdn.net/weixin_42812527/article/details/81908674 123456789101112131415161718192021222324# coding=utf-8import requestsimport pytesseractfrom PIL import Imagefrom io import BytesIOcaptcha_url = 'http://182.92.169.64:8088/808gps/rand.action'captcha_content = requests.get(url=captcha_url)# 获得图片的二进制内容captcha_content = captcha_content.content# 用BytesIO读取图片image = Image.open(BytesIO(captcha_content))# 转化为灰度图imgry = image.convert('L')# 二值化处理table = [0 if i &lt; 140 else 1 for i in range(256)]# 使字体更加突出的显示out = imgry.point(table,'1')# out.show()captcha = pytesseract.image_to_string(out)captcha = captcha.strip()captcha = captcha.upper()print (captcha) Python异常 Python所有的错误都是从BaseException类派生的，常见的错误类型和继承关系 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StandardError | +-- BufferError | +-- ArithmeticError | | +-- FloatingPointError | | +-- OverflowError | | +-- ZeroDivisionError | +-- AssertionError | +-- AttributeError | +-- EnvironmentError | | +-- IOError | | +-- OSError | | +-- WindowsError (Windows) | | +-- VMSError (VMS) | +-- EOFError | +-- ImportError | +-- LookupError | | +-- IndexError | | +-- KeyError | +-- MemoryError | +-- NameError | | +-- UnboundLocalError | +-- ReferenceError | +-- RuntimeError | | +-- NotImplementedError | +-- SyntaxError | | +-- IndentationError | | +-- TabError | +-- SystemError | +-- TypeError | +-- ValueError | +-- UnicodeError | +-- UnicodeDecodeError | +-- UnicodeEncodeError | +-- UnicodeTranslateError +-- Warning +-- DeprecationWarning +-- PendingDeprecationWarning +-- RuntimeWarning +-- SyntaxWarning +-- UserWarning +-- FutureWarning +-- ImportWarning +-- UnicodeWarning +-- BytesWarning java异常 继承、Super super() 函数是用于调用父类(超类)的一个方法，只有在新式类中可以使用 super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO，Method Resolution Order，采用广度优先（区别于深度优先）的规则定义）、重复调用（钻石继承）等种种问题。 MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。 语法 以下是 super() 方法的语法: 1234# 菜鸟教程super(type [, object-or-type])# 个人理解super( ThisClass [, object(self)]) 参数 type – 类（type），通常是当前子类。 object-or-type – 类实例，一般是 self 含义 用self这个实例对象去查找ThisClass类的父类拥有的属性（成员方法、数据成员） ▲. Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx : 即平时写的 1234567class TestClass(object): def __init__(self, *arg, **kwarg): super(TestClass, self).__init__() # 此时init里不用self # 等价于 super().__init__() , 含义是用父类的构造函数初始化某些变量 # 相当于旧式类的 object.__init__(self) # 需要传参self self.arg = arg self.kwarg = kwarg 完整代码 12345678910111213141516class clsSuper(object): age = 18 def __init__(self, name): print(name)class clsSub(clsSuper): def __init__(self): print(super().age) # 当只是单继承的时候可以直接使用 print(clsSuper.age)，if __name__ == '__main__': a = clsSuper('cl') b = clsSub() 特点 super().func()是不用传参self的 super(type, obj).func()函数调用的是obj实例在MRO中下一个父类的可调用func()，而不是type的父类中的func()。即调用最近的可用func() 使用super()不用指定父类的名称，便于修改维护；同时当继承多个类A、B的时候，用super().__init__()相当于调用多个类的A.__ini__(self)、B.__ini__(self) 与java对比 Python中子类不会默认调用父类的构造函数，即下面代码。并不会要要求给传name。当然也可以理解为跟java一样调用了一个全空、没有任何内容的构造函数，但是在python中不需要显性写出来，原因部分是特点2（java中存在有参数的构造函数时，必须将空参数的构造函数显式写出，不然子类默认隐式调用空参数的构造函数时会报错说不存在）。 Python中的构造函数只有一个。但由于存在*arg,**kwarg的存在，所以只要执行类型检查执行不同的代码；即实现了多个构造函数 Python的类可以多继承，java只能单继承。 123456789101112131415class clsSuper(object): age = 18 def __init__(self, name): self.name = name print(self.name)class clsSub(clsSuper): def __init__(self, age): print(age)if __name__ == '__main__': b = clsSub(18) Cmder Windows 下的终端神器 视频字幕制作 arctime国人自制的免费软件。自动打轴和语音识别功能积分使用注册绑定任务、签到白嫖能鸽很久。 制作完成后保存工程文件，ass，软件-&gt;导出，可以导出一份srt字母文件，可以直接上传到B站当CC字幕使用 Pr自带工具一句一句打===&gt;ps批量制作字幕图层===&gt;arctime mitmProxy手机抓包软件 Q:为什么好多加密算法都要用到异或？ A:位操作 cpu运行非常快 加密的源是形形色色的，其加密结果也要求是尽量差异化。在二元的位运算符中，也就只有&quot;位与&quot;、“位或”、&quot;异或&quot;三种。一个加密过程往往需要经过若干次运算，若采用&quot;位与&quot;运算，竟多次计算的话，其结果值将趋向于比特位全部是0；同样，采用&quot;位或&quot;的话，其结果值将趋向于比特位全部是1。剩下的只有采用&quot;异或&quot;运算了 测试注解的正确性 注解仅仅起到了注释的作用，不会影响代码的执行，所以即使你类型注解写错了，程序运行的时候还是会按照正确的类型去运行。 Python提供了一个工具方便我们测试代码里的类型注解正确性mypy 首先安装：pip install mypy 使用测试：mypy filename.py Python3.7新特性dataclass 写法对比 1234567891011121314class student(object): \"\"\"docstring for student\"\"\" def __init__(self, name, age): super(student, self).__init__() self.name = name self.age = agefrom dataclasses import dataclass@dataclassclass student(object): \"\"\"docstring for ClassName\"\"\" name: str age: int 功能对比 传统的class写法的__eq__并不认为两个实例相同，即存储数据不同 12345678910111213141516171819202122232425262728293031class student(object): \"\"\"docstring for student\"\"\" def __init__(self, name, age): super(student, self).__init__() self.name = name self.age = age s1 = student('cl', 18)s2 = student('cl', 18)print(s1 == s2)# &gt;&gt;&gt; False#数据的角度来讲，这两个实例代表的是同一个Student，理应相等。所以我们可以重写内置的__eq__方法如下class student(object): \"\"\"docstring for student\"\"\" def __init__(self, name, age): super(student, self).__init__() self.name = name self.age = age def __eq__(self, other): if self.__class__ is not other.__class__: return False return (self.name, self.age) == (other.name, other.age)s1 = student('cl', 18)s2 = student('cl', 18)print(s1 == s2)# &gt;&gt;&gt; True 注意: name和age并不是Class Attribute，也就是不能通过NewStudent.name和NewStudent.age直接访问，大家可以通过dir(NewStudent)验证一下。 name和age后面的类型指定并没有实际的效果，也就是如果我们实例化传入错误的数据类型，不会报错，比如 s3 = NewStudent(‘Mark’, ‘20’) 更多功能 通过使用装饰器的选项，可以为用例进一步定制 data class，默认选项是： 1@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False) init决定是否生成__init__ dunder 方法 repr决定是否生成__repr__ dunder方法 eq对__eq__ dunder 方法也是如此，它决定相等性检查的行为（your_class_instance == another_instance） order 实际上创建了四种 dunder 方法，它们确定所有检查小于，and/or，大于的行为，如果将其设置为 true，则可以对对象列表进行排序。 最后两个选项确定对象是否可以被哈希化，如果你想使用你的 class 的对象作为字典键的话，这是必要的。 链接：https://www.jianshu.com/p/bea5c202cf85 协程 不是进程，也不是线程，是用户空间调度的完成并发处理的方式。是在用户空间内部完成的。线程和进程是操作系统内完成的。 Github感谢贡献者 1&lt;a href=\"https://github.com/spencerwooo/dowww/graphs/contributors\"&gt;&lt;img src=\"https://opencollective.com/dowww/contributors.svg?button=false\" /&gt;&lt;/a&gt; java equals 和 == == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型比较的是值，引用数据类型比较的是内存地址)。 equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。 即通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。 一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 说明： String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址(即==)，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 hashCode（）介绍 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode 我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 通过我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。**hashCode()在散列表中才有用，在其它情况下没用。**在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。 hashCode（）与equals（）的相关规定 如果两个对象相等，则hashcode一定也是相同的 两个对象相等,对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）==&gt;通过统一哈希值，使两个对象equals时结果返回哈希值一致便输出true static{}静态代码块与{}非静态代码块、构造方法 类的执行顺序: static{}静态代码块–&gt;{}静态代码块–&gt;构造方法 static{}静态代码块与{}非静态代码块不同点： 静态代码块只在第一次new执行一次，之后不再执行 一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。 而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法 两者的区别是 静态代码块是自动执行的而静态方法是被调用才执行的. 非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 1234567891011121314151617181920212223242526272829303132package classtest;public class testClass &#123; public testClass() &#123; System.out.print(\"默认构造方法！--\"); &#125; //非静态代码块 &#123; System.out.print(\"非静态代码块！--\"); &#125; // 静态代码块,指挥执行一次 static &#123; System.out.print(\"静态代码块！--\"); &#125; public static void test() &#123; System.out.print(\"静态方法中的内容! --\"); &#123; System.out.print(\"静态方法中的代码块！--\"); &#125; &#125; public static void main(String[] args) &#123; testClass test = new testClass(); testClass.test();//静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！-- System.out.println(); testClass test2 = new testClass(); &#125;&#125;/**静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！--非静态代码块！--默认构造方法！--*/ Ansible 运维自动化 ( 配置管理工具 )","categories":[],"tags":[{"name":"编程日记","slug":"编程日记","permalink":"https://nymrli.top/tags/编程日记/"}]},{"title":"Python爬虫常规流程","slug":"Python爬虫常规流程","date":"2019-08-30T13:07:05.000Z","updated":"2019-09-15T08:07:30.988Z","comments":true,"path":"2019/08/30/Python爬虫常规流程/","link":"","permalink":"https://nymrli.top/2019/08/30/Python爬虫常规流程/","excerpt":"","text":"Python爬虫常规流程 以爬取有道翻译为例子。 挖取可自用的API web 端的有道翻译，在之前是直接可以爬的。也就是说只要获取到了他的接口，你就可以肆无忌惮的使用他的接口进行翻译而不需要支付任何费用。那么自从有道翻译推出他的API服务的时候，就对这个接口做一个反爬虫机制（如果大家都能免费使用到他的翻译接口，那他的APl服务怎么赚钱）。这个反爬虫机制在爬虫领域算是一个非常经典的技术手段。 1.查看要爬取的内容是否是静态加载的。 比如在翻译输入框中输入apple，翻译输出框中会出现苹果，然后在``页面中右键-&gt;查看网页源代码，直接Ctrl+F搜索是否存在apple或者苹果`，如果没有的话，证明不是静态加载的。 2.查看内容如何加载的 页面初始化get、post请求 局部刷新发送ajax请求 如果存在局部更新内容产生变化的（Url没有发生变化，或者没有页面发生跳转、刷新的感觉），一般都是采用的AJAX更新技术，发送了POST、GET请求获得局部需要更新的数据，可以直接在Network项的XHR里面找到动态加载的文件 (可以看下Ajax技术实现了解下为什么可以在XHR中找到) 这边的话，可以看到输入一个要翻译的内容后，页面没有产生多大的变化，因此猜想是AJAX加载的。在XHR里也找到了相应的Response文件。 使用Chrome自带的抓包工具（页面中右键-&gt;检查或者按F12都可以打开，然后选择-&gt;Network项（网络监听窗口）就可以看到抓包的数据了） 然后同样在翻译输入框中输入apple，然后可以观察到抓包工具中出现了很多内容。为了确定apple的翻译苹果是在哪个文件中返回的，可以直接Ctrl+F打开搜索框后直接搜索，如图所示。 JS加密破解 1.使用Python进行模仿JS加密计算 2.运行JS代码获得加密结果 使用python-js2py模块 如一个参数生成的结果是这样的{&quot;LoginKey&quot;:&quot;46fd82c2-3108-b2a4-3056-0eaa426f975b&quot;,&quot;data&quot;:&quot;{/&quot;User_Oid/&quot;:/&quot;账号/&quot;,/&quot;User_Password/&quot;:/&quot;密码/&quot;}&quot;} 找到生成LoginKey值的JS文件加密算法是这样的： 123456function s4() &#123;return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);&#125;;function guid() &#123;return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();&#125; 然后安装pip install js2py后 123456789101112#coding=utf-8import js2pyLoginKey = js2py.eval_js('''function s4() &#123;return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);&#125;;function guid() &#123;return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();&#125;var a = guid() // 在这里是需要调用的''')print LoginKey 就能获得结果了。 使用pyexe、PyV8、js2py模块 12345678910111213141516171819import execjsdef get_des_psswd(data, key): jsstr = get_js() ctx = execjs.compile(jsstr) #加载JS文件 return (ctx.call('strEnc', data, key)) #调用js方法 第一个参数是JS的方法名，后面的data和key是js方法的参数def get_js(): f = open(\"./../lib/des.js\", 'r', encoding='utf-8') # 打开JS文件 line = f.readline() htmlstr = '' while line: htmlstr = htmlstr+line line = f.readline() return htmlstrif __name__ == '__main__': print(get_des_psswd('123456', 'RUY2OTdCRUFFRTg0OUQ0Q0E0ODNDRDMxN0YzOEEzREQudG9tY2F0OTQ=')) js2py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import js2pycontext = js2py.EvalJs()# - 拷贝使用到js文件的内容到本项目中# - 读取js文件的内容,使用context来执行它们with open(\"BigInt.js\", 'r', encoding='utf8') as f: context.execute(f.read()) with open(\"RSA.js\", 'r', encoding='utf8') as f: context.execute(f.read())with open(\"Barrett.js\", 'r', encoding='utf8') as f: context.execute(f.read())# - 向context环境中添加需要数据context.t = &#123;'password': password&#125;context.n = n# - 执行加密密码的js字符js = ''' t.password = t.password.split(\"\").reverse().join(\"\"), setMaxDigits(130); var o = new RSAKeyPair(n.e,\"\",n.n) , r = encryptedString(o, t.password); '''context.execute(js)# - 通过context获取加密后密码信息# print(context.r)password = context.r# - 使用session发送登录请求# - URL: http://activity.renren.com/livecell/ajax/clog# - 请求方法: POST# - 数据:# - phoneNum: 15565280933# - password: (加密后生产的)# - c1: 0# - rKey: rkey请求获取的data = &#123; 'phoneNum': '131....', 'password': password, 'c1':0, 'rKey':n['rkey']&#125; # print(session.headers)response = session.post(\"http://activity.renren.com/livecell/ajax/clog\", data=data)print(response.content.decode()) # 访问登录的资源response = session.get(\"http://activity.renren.com/home#profile\")print(response.content.decode())# https://blog.csdn.net/guodejie/article/details/81436556 逐步确定JS对密码的加密逻辑 ==&gt; 定位到加密函数 两种思路 全局搜索password字段 全局搜加密算法的名字 加密一般都是JS加密，加密算法一般比较出名的就那么几个，比如MD5，base64,aes（对称密码），rsa（非对称加密算法）都是可以用来加密的，你可以全局搜这些加密算法的名字 https://www.jianshu.com/p/055e1ddf7bb2 rsa加密 对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破==&gt;为什么密码要大于6位。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Word2016配置使用MathType","slug":"Word2016配置使用MathType","date":"2019-08-30T12:58:53.000Z","updated":"2021-01-03T06:02:31.302Z","comments":true,"path":"2019/08/30/Word2016配置使用MathType/","link":"","permalink":"https://nymrli.top/2019/08/30/Word2016配置使用MathType/","excerpt":"","text":"Word 2016 使用MathType 据说MathType 6.9b后就能与Word 2016兼容了，所以不用特地去找7.0以上的版本，据说更新的功能差别也不是很大。只不过本人还是使用的7+版本，新一点功能会更全点嘛。 闲谈 这边的方法是我个人的操作过程，但是感觉应该不是这么搞得。 安装好MathType后，打开word查看工具栏中是否有MathType工具，如果没有的话，则手动选择“插入-&gt;获得加载项-&gt;应用商店”搜索Mathtype。如果还是没有的话，然后在“选项-&gt;加载项-&gt;模板”然后指定MathType Commands 6 For Word2016.dotm的路径，之后是能在应用商城搜到Mathtype了，但是每次打开word都会弹出找不到MathPage.wll，而且最麻烦的是还删不掉这个路径，于是找了很多资料后，发现了“信任中心”，比较像能解决问题。只不过试了后还是不行，最后发现，自己拷贝的是64位的文件，找到了一个解决方案提醒到：如果你复制的是64的MathPage.wll还出错换成32的就好了。然后按照提示改了后就行了，同时需要注意的是根据路径显示需要将Mathtype安装目录中的和MathPage.wll 安装过程 需要将安装好的mathtype目录下提取两个文件MathPage.wll和MathType Commands 6 For Word 2016.dotm复制到指定目录 如果使用的Office是32位的话。在Mathtype安装后，安装路径（假设装在C盘的话）C:\\Program Files (x86)\\MathType\\MathPage\\32中有文件MathPage.wll； 安装路径C:\\Program Files (x86)\\MathType\\Office Support\\32中有文件 MathType Commands 6 For Word.dotm；将这两个文件复制到桌面。 （当然，这里都是针对Windows 64位系统而言的，注windows10是64位操作系统。如果是Windows 32位系统，路径中就不会包含有（x86）了，请注意。） 如果使用的Office是64位的话。在Mathtype安装后，安装路径（假设装在C盘的话）C:\\Program Files (x86)\\MathType\\MathPage\\64中有文件MathPage.wll； 安装路径C:\\Program Files (x86)\\MathType\\Office Support\\64中有文件 MathType Commands 6 For Word 2016.dotm；将这两个文件复制到桌面。 **如果不清楚自己的Office是32位还是64位，就按照32位的来，一般来说，向下兼容，实在不行就都试一试。▲.===&gt;我就是以为自己的是64位结果是32位被坑了很久都用不成。 或者像如下查看自己的word版本，打开word点击“账号” 选择“关于word” 对于自己安装Office 2016的用户，需要找到Office 2016的安装文件夹（假设装在C盘的话）C:\\Program Files\\Microsoft Office\\Office16\\STARTUP（对于****64位的Office用户）；或C:\\Program Files (x86)\\Microsoft Office\\Office16\\STARTUP（对于****32位的Office用户）。然后，直接将桌面上的那两个文件剪切放进去即可，重新启动Word后就会出现Mathtype插件栏。 对于Office预装的用户，想找到Office的安装路径就不那么容易了，这个时候就只能发挥一下Windows自身的搜索功能（安利Everythisng搜索）了，从前面提到的可以看出Mathtype安装文件中有两个文件需要手动移植到Office安装路劲下的一个STARTUP文件夹中，因此需要找到这个STARTUP文件夹。 在搜索框中输入STARTUP。 找到最后为**~Microsoft\\Word\\STARTUP**的文件夹子目录，可能会有多个。逐次添加桌面上的两个文件【如下图】到这些文件夹中，并重新启动Word进行查证。 需要复制的文件 复制到的位置 1.STARTUP目录，如果没有的话自己新建C:\\Users\\10630\\AppData\\Local\\Packages\\Microsoft.LanguageExperiencePackzh-cn_8wekyb3d8bbwe\\LocalCache\\Roaming\\Microsoft\\Word\\STARTUP 2.这个路径我忘记了，但是搜索的时候发现自己复制了C:\\Users\\10630\\AppData\\Roaming\\Microsoft\\AddIns 注意事项：如果在C:\\Program Files\\Microsoft Office\\Office16\\STARTUP中，含有MathType Commands 6 For Word.dot，那么就会出现无法粘贴的现象。（复制的话，word会关闭） 😄总算安好了把，配合Mathpix，感觉应该挺香的. 兼容模式问题 当拿到低版本打开后出现一些格式或者兼容性不对的提示，其实很简单，我们可以在保存时候，就可以设置为兼容性模式。 如何关闭&quot;兼容模式&quot; 当自己使用的Word版本较高，打开doc的版本较低时(.doc)，就会进入**“兼容模式”**，这样能保证大致上的排版格式是正确的，但是图片、公式什么的信息很有可能就会丢失（公式变成了图片、图片显示不全），解决的方案是关闭兼容模式。 兼容模式，如图 解决步骤1： 解决步骤2： 如何保存为&quot;兼容模式&quot;？ 实质上就是保存为.doc–&gt;.docx的变化","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"算法设计与分析C_概念点区分","slug":"算法设计与分析C-概念点区分","date":"2019-08-22T12:39:29.000Z","updated":"2019-09-15T08:07:31.090Z","comments":true,"path":"2019/08/22/算法设计与分析C-概念点区分/","link":"","permalink":"https://nymrli.top/2019/08/22/算法设计与分析C-概念点区分/","excerpt":"","text":"算法设计与分析C 算法5_分治法 分治法——将一个复杂的问题分解成若干个规模较小、相互独立，但类型相同的子问题求解；然后再将各子问题的解组合成原始问题的一个完整答案，这样的问题求解策略就叫分治法。 分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定的程度就可以容易地解决； 该问题可以分解为若干个规模较小的相同问题； 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。 由分治法产生的子问题往往是原问题的较小模式。 直接或间接地调用自身的算法称为：递归算法。用函数自身给出定义的函数称为：递归函数。 分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。 算法6_贪心法 可行解 ——问题给定某些约束条件，满足约束条件的问题解，即称为可行解。 最优解 ——问题给出目标函数衡量可行解的好坏，使目标函数取最大（或最小）值的可行解称为最优解。 1.最优子结构性质： 一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。 问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。 2.贪心选择性质 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。 这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。 算法7_动态规划法 （1）子问题重叠性质 （递归算法求解问题时）每次产生的子问题并不总是新问题，有些子问题被反复计算多次，这种性质称为子问题重叠性质。 动态规划算法对每一个子问题只解一次，而后将其解保存在一个表格（通常用二维数组）中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。 通常不同的子问题个数随问题的大小呈多项式增长。因此用动态规划算法只需要多项式级时间，从而获得较高的解题效率。 （2）最优子结构性质——用动态规划法求解的前提。 当一个问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。 一个问题的活动过程可以分为若干个阶段，每个阶段可包含一个或多个状态，从初始阶段的初始状态出发做出每个阶段的决策，形成一个决策序列。 利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。 用动态规划算法求解问题的步骤： 1、找出最优解的性质，并刻划其结构特征； 2、递归地定义最优解值； 3、自底向上求最优解值； 4、根据计算最优解值时得到的信息构造一个最优解（此步只在要求得到最优解时才需要做） 。 动态规划法是一种求解最优化问题的重要算法策略。 利用最优子结构性质及所获得的递推关系式（较小子问题最优解与较大子问题最优解之间存在的数值关系）去求取最优解，可以使计算量较之穷举法急剧减少。 共同点： 将待求解的问题分解成若干子问题，先求解子问题，然后再从这些子问题的解得到原问题的解。 不同点： 1、适合于用动态规划法求解的问题，分解得到的各子问题往往不是相互独立的；而分治法中子问题相互独立。 2、动态规划法用表保存已求解过的子问题的解，再次碰到同样的子问题时不必重新求解，而只需查询答案，故可获得多项式级时间复杂度，效率较高；而分治法中对于每次出现的子问题均求解，导致同样的子问题被反复求解，故产生指数增长的时间复杂度，效率较低。 备忘录方法与动态规划法比较 1、与动态规划法的共同点：用一个表格来保存已求解的子问题的答案，使下次需要解此子问题时，只简单地查看答案，不重新计算。 2、与动态规划法的区别：备忘录的递归方式是自顶向下，而动态规划法的递归方式是自底向上。 如何选择使用动态规划法或备忘录法？ ★当一个问题的所有子问题都至少要解一次时，选用动态规划法较好，此时没有任何多余的计算，还可利用规则的表格存取方式，减少时间和空间需求。 ★当一个问题只有部分子问题需要求解时，选用备忘录法较好，它只解那些确实需要求解的子问题。 备忘录方法与递归方法比较 1、与递归方法的共同点：递归方式均为自顶向下 2、与递归方法的区别：备忘录方法用一个表格来保存已求解的子问题的答案，使下次需要解此子问题时，只简单地查看答案，不重新计算；而递归方法在每次遇到子问题都要重新计算。 共同点： 都是求解最优化问题；都具有最优子结构性质。 不同点： 1、求解方式不同： 动态规划法：自底向上； 贪心法：自顶向下。以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为一个规模更小的子问题。 2、对子问题的依赖不同： 动态规划法：依赖于各子问题的解。只有在解出相关子问题后,才能作出选择；应使各子问题最优，才能保证整体最优； 贪心法：不依赖于子问题的解。仅在当前状态下作出最好选择，即局部最优选择。 算法8_回溯法 回溯法是比贪心法和动态规划法更一般的方法。 解为n-元组(x0,x1,…,xn-1)形式。 通过搜索状态空间树来求问题的可行解（满足约束条件）或最优解（使目标函数取最大或最小值）。 使用约束函数和限界函数来压缩需要实际生成的状态空间树的结点数。 通常情况下，回溯法是为了找出满足约束条件的所有可行解。 显式约束：规定每个xi取值的约束条件。 （显式约束规定了问题的候选解集——解空间） 隐式约束：给出了判定一个候选解是否为可行解的条件。为满足问题的解而对不同分量之间施加的约束。 目标函数（代价函数）：衡量每个可行解的优劣，使目标函数取最大（或最小）值的可行解为问题的最优解。 状态空间树：描述问题解空间的树形结构。 树中每个结点称为一个问题状态； 若从根到树中某个状态的路径代表一个候选解元组，则该状态为解状态； 若从根到某个解状态的路径代表一个可行解元组，则该解状态为答案状态； 如果求解的是最优化问题，还要用目标函数衡量每个答案结点，找出其中目标函数取最优值的最优答案结点。 回溯法与穷举搜索不同：回溯法使用约束函数，剪去那些可以断定不含答案状态的子树，从而提高算法效率。回溯法适用于解一些组合数相当大的问题。 事实上，状态空间树并不需要事先生成，而只需在求解的过程中，随着搜索算法的进展，逐个生成状态空间树的问题状态结点。 常用的剪枝函数： 用约束函数剪去已知不含答案状态（可行解）的子树； 用限界函数剪去得不到最优答案结点（最优解）的子树。 蒙特卡洛估计 用蒙特卡罗（Monte Carlo）方法估计回溯法处理实例时，实际生成的结点数： 在状态空间树中,从根开始随机选择一条路径(x0,x1,…,xn-1); 假定搜索树中这条随机选出的路径上，代表部分向量(x0,x1,…,xk-1)的结点X处不受限制的孩子数目,和其他路径上与X同层的的结点不受限制的孩子数目一样，都是mk; 则可以估计整个状态空间树上实际生成的结点数为: m=1+m0+m0m1+m0m1m2+...... 算法9_分枝限界法 采用广度优先产生状态空间树的结点，并使用剪枝函数的方法称为——分枝限界法。 分枝限界法的基本做法是： 以广度优先的方式搜索问题的状态空间树。每一个活结点只有一次机会成为扩展结点。 按照广度优先的原则，活结点一旦成为扩展结点（E结点）R后，就依次生成它的所有孩子结点。在这些孩子结点中，导致不可行解或导致非最优解的孩子结点被舍弃，其余孩子结点被一一加入活结点表中。 此后，R自身成为死结点，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。 这个过程一直持续到找到所需的解或活结点表为空时为止。 一、分枝限界法与回溯法的共同点 都是在问题的状态空间树上搜索问题解的算法,都通过活结点表实现。都用约束函数剪去不含答案结点的分枝,用限界函数剪去不含最优解的分枝. 二、分枝限界法与回溯法的区别 （1）求解目标不同：回溯法的求解目标是找出解空间树中满足约束条件的所有可行解；而分枝限界法的求解目标则是找出满足约束条件的一个可行解，或某种意义下的最优解。 （2）搜索方式不同：回溯法以深度优先的方式搜索解空间树，而分枝限界法则以广度优先的方式搜索解空间树。 （3）对当前扩展结点的扩展方式不同：回溯法中的每个活结点可能多次成为当前扩展结点，纵深方向扩展其一个儿子，然后再回溯后扩展其他儿子；而分枝限界法中每一个活结点只有一次机会成为扩展结点，一次产生所有孩子结点，自身成为死结点，之后无需再返回该结点处。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"},{"name":"学业","slug":"学业","permalink":"https://nymrli.top/tags/学业/"}]},{"title":"通信企业管理_线上考试","slug":"通信企业管理-线上考试","date":"2019-08-22T12:37:49.000Z","updated":"2019-09-15T08:07:31.097Z","comments":true,"path":"2019/08/22/通信企业管理-线上考试/","link":"","permalink":"https://nymrli.top/2019/08/22/通信企业管理-线上考试/","excerpt":"","text":"通信企业管理 看清题目和选项 单选题 1单选(2分) 在总公司领导下设立多个分支，各分支有各自独立的产品和市场，实行独立核算，经营管理上拥有自主性和独立性。这是（ A ）组织结构。 A.事业部型 B.矩阵型 C.职能型 D.直线型 2单选(2分) 按照最新版《中华人民共和国公司法》规定，股份有限公司的发起人最多不超过（ C ）。 A.100人 B.50人 C.200人 D.150人 3单选(2分) 工作或行动之前预先拟定具体的工作内容和步骤是管理的（ D ）职能。 A.组织职能 B.控制职能 C.领导职能 D.计划职能 4单选(2分) 提出“14项管理原则”的是（C ）。 A.巴纳德 B.梅奥 C.法约尔 D.泰勒 5单选(2分) 企业战略是关于企业在激烈的竞争中如何与竞争对手相抗衡、同时也是针对来自多方面的冲击、压力、威胁和困难迎击这些挑战的行动方案。这体现了企业战略的（ D ）。 A.长远性 B.协同性 C.全局性 D.抗争性 6单选(2分) 在对企业总体环境分析中，人们生活方式的变化属于（ B ）。 A.经济环境 B.社会环境 C.政治环境 D.技术环境 7单选(2分) 为了增强企业实力而与同行业企业进行联合的一种战略称为（ C ）。 A.复合多样化 B.纵向一体化 C.横向一体化 D.同心多样化 8单选(2分) 在流程型生产过程中，物料是均匀、连续地按一定工艺顺序运动的。它的特点是工艺过程的（ A ）。 A.连续性 B.稳定性 C.离散性 D.流动性 9单选(2分) 服务是一种活动，在消费之前通常无法为顾客感觉、体验和评价，这体现了服务的（ B ）。 A.劳动力密集性 B.无形性 C.异质性 D.易逝性 10单选(2分) 尽管不同产品具有不同的外部质量特征，但可以用（ B ）来概括产品质量。 A.安全性 B.适用性 C.经济性 D.可靠性 11单选(2分) 质量管理经历的第四阶段是（ C ）。 A.统计质量控制阶段 B.质量检验阶段 C. ISO9000质量管理体系认证阶段 D.全面质量管理阶段 12单选(2分) 下面（ A ）不是朱兰三部曲中所要求的内容。 A.质量检验 B.质量计划 C.质量提高 D.质量控制 13单选(2分) 职业生涯规划属于 人力资源管理的（ C ）方面的内容。 A.用人 B.进人 C.育人 D.留人 14单选(2分) 一般来说，我们可以从工作业绩、工作能力和工作态度3个方面来评价员工的绩效体现了绩效的（ C ）特征。 A.动态性 B.多因性 C.多维性 D.稳定性 15单选(2分) 薪酬中属于间接经济性报酬的是（ D ）。 A.津贴 B.基本工资 C.奖金 D.基本社会保险 16单选(2分) 企业财务管理的基本内容包括：①资金筹集管理；②成本费用管理；③投资管理；④利润（收支差额）及其分配管理；⑤物资管理；中的（ A ）。 A.①②③④ B.①③④⑤ C.①②④⑤ D.①②③④⑤ 17单选(2分) 以下不属于企业的筹资方式的是（ D ）。 A.买方信贷 B.发行股票 C.银行贷款 D.来自个人的闲散资金 18单选(2分) 某大学生在4年学习期间，每年年初从银行贷款3000元用于支付学费，若按年利率5%计复利，第4年末需要一次性归还全部本息（ D ）元。 A.12000 B.12930.4 C.16576.9 D.13576.9 19单选(2分) 为了保证产品达到规定的功能和技术要求所必需的材料消耗是（A ）。 A.有效性消耗 B.工艺性消耗 C.非工艺性消耗 D.材料消耗 20单选(2分) 设备在使用或闲置过程中，由于新技术出现而引起的设备价值损失，称为（ A ）。 A.无形磨损 B.价值磨损 C.技术磨损 D.使用磨损 21单选(2分) 企业在相邻两批物资进厂间隔期内，为保证生产正常进行所必需的、经济合理的储备数量是（ D ）。 A.保险储备定额 B.物资储备定额 C.季节性储备定额 D.经常储备定额 22单选(2分) 快速渗透策略是推广处于生命周期（C ）产品的企业，可以采用的市场营销策略。 A.衰退期 B.成长期 C.引入期 D.成熟期 23单选(2分) 以下不属于促销组合中的促销工具的是（ D ）。 A.销售促进 B.公关宣传 C.广告 D.尾数定价 24单选(2分) 营销人员可以通过接近和影响消费者群体中的意见领袖的方式来开展营销活动，这体现了影响消费者购买的主要因素中的（ D ）的作用。 A.经济因素 B.个人因素 C.社会文化因素 D.心理因素 25单选(2分) 品种繁多，每种仅生产一件，生产重复程度低是以下哪种生产方式的特点（ B ）。 A.批量生产 B.单件生产 C.大量生产 D.备货型生产 判断题 26判断(2分) 个体企业是个人出资兴办的企业，具有法人资格。 错 27判断(2分) 在管理过程中，只有把人的要素作为根本，才能协调好其他要素，实现高水平的管理。 对 28判断(2分) 企业不仅是经济性组织，也是社会性组织。 对 29判断(2分) 梅奥认为，影响人们积极性的因素除了物质方面外，还有社会与心理方面。 对 30判断(2分) 企业提供的产品服务标新立异，满足顾客特殊的需求，形成竞争优势的战略是差异化战略。 对 31判断(2分) 高质量的社会物流系统属于战略制定中企业的外部资源。 对 32判断(2分) 企业价值活动中，技术开发属于基本活动。 错 33判断(2分) 企业生产系统是由输入、转化、输出、反馈四部分构成，其核心是输出。 错 34判断(2分) 辅助生产部门主要是为基本生产和辅助生产服务的单位（如仓储、后勤）。 错 35判断(2分) 对于顾客来说，服务是发生在服务设施环境中的经历，如果服务设施的设计符合消费者的需要，就可以提高服务质量。 对 36判断(2分) ISO9000族标准是进行国际贸易时强制要求必须进行的标准认证。 错 37判断(2分) 质量体系认证中使用的基本标准是产品技术标准。 错 38判断(2分) 质量管理的目标就是提高产品质量，产品质量越高越好。 错 39判断(2分) 广义的人力资源概念是指能够推动国民经济和社会发展的具有智力劳动和体力劳动能力的人的总和，包括数量和质量两个方面。 错 40判断(2分) 工作说明书具体说明了工作的目的与任务、工作内容与特征、工作责任与权力、工作标准与要求、工作时间与地点等问题。 错 41判断(2分) 设定绩效目标时，管理者一般根据组织总体目标或上级部门的目标，围绕本部门业务重点或职责，制定本部门的工作目标计划，保证部门工作目标与组织的总体目标相一致。 对 42判断(2分) 企业的运营能力反映了企业资金周转状况，可以用成本费用净利率来衡量。 错 43判断(2分) 资本公积、盈余公积都属于企业权益资本的范畴。 对 44判断(2分) 盈亏平衡点是指技术方案的盈利和亏损在产量、单价、成本等方面的临界值。 对 45判断(2分) 在设备的自然寿命周期中，设备故障率随着使用的时间的延伸而越来越高。 对 46判断(2分) 设备更新改造时，不仅要考虑设备的自然寿命，还要考察技术寿命和经济寿命。 对 47判断(2分) 从价值形态上看，无论是有形磨损还是无形磨损都会引起设备价值的降低，因此我们要采取措施尽量减少各种类型的设备磨损。 错 48判断(2分) 关系营销就是利用亲属关系以及朋友关系来开展营销活动。 错 49判断(2分) 在目标市场中采用无差异的市场营销策略历来都不是一种明智的选择。 错 50判断(2分) 招徕定价是一种利用顾客心理因素来进行定价的策略。 对 附： 记个正则替换，本是强哥每题copy到word里的，后来通过正则规范了下格式 复制结果： /1. int[][] a=new int[2][3]，则该数组包含（ ）个数组元素。 A.2 B.3 C.6 D.不确定 正确答案是: C /2. 已知类person是类student的父类，以下数组定义和赋值正确的是( )。 A.person p[]=new person[3]; p[1]=new student(); B.student s[]=new person[3]; s[1]=new person(); C.person p[]= new student[3];p[1]= new person(); D.student s[]=new student[3];s[1]=new person; 正确答案是: A 查找(/d.)替换为/n - /1 效果如下: int[][] a=new int[2][3]，则该数组包含（ ）个数组元素。 A.2 B.3 C.6 D.不确定 正确答案是: C 已知类person是类student的父类，以下数组定义和赋值正确的是( )。 A.person p[]=new person[3]; p[1]=new student(); B.student s[]=new person[3]; s[1]=new person(); C.person p[]= new student[3];p[1]= new person(); D.student s[]=new student[3];s[1]=new person; 正确答案是: A","categories":[],"tags":[{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"},{"name":"学业","slug":"学业","permalink":"https://nymrli.top/tags/学业/"}]},{"title":"Let's Encrypt安装配置nginx的SSL证书教程","slug":"Let-s-Encrypt安装配置SSL证书教程","date":"2019-08-22T12:34:04.000Z","updated":"2019-09-15T08:07:30.956Z","comments":true,"path":"2019/08/22/Let-s-Encrypt安装配置SSL证书教程/","link":"","permalink":"https://nymrli.top/2019/08/22/Let-s-Encrypt安装配置SSL证书教程/","excerpt":"","text":"Let’s Encrypt 安装配置nginx的SSL证书教程 使用cerbot生成证书 安装Let’s Encrypt 安装非常简单直接克隆就可以了 1git clone https://github.com/letsencrypt/letsencrypt 如果网速较慢（国外服务器应该快点） 1.可以登录https://github.com/letsencrypt/letsencrypt，下载后通过lrzsz传到云服务器上，再解压 2.修改hosts 查找域名对应的ip地址，并修改hosts文件 123456789101112131415linuxidc@linuxidc:~/linuxidc.com$ nslookup github.global.ssl.fastly.NetServer: 127.0.0.53Address: 127.0.0.53#53Non-authoritative answer:Name: github.global.ssl.fastly.NetAddress: 151.101.229.194linuxidc@linuxidc:~/linuxidc.com$ nslookup github.comServer: 127.0.0.53Address: 127.0.0.53#53Non-authoritative answer:Name: github.comAddress: 13.229.188.59 然后修改hosts文件 sudo vim /etc/hosts 在hosts文件末尾添加两行 12github.com 13.229.188.59github.global.ssl.fastly.Net 151.101.229.194 刷新DNS缓存 sudo /etc/init.d/networking restart 使用cerbot: 123cd letsencrypt# 根据自己的需求调整代码./certbot-auto certonly --standalone --email admin@example.com -d example.c 成功提示 12345678910IMPORTANT NOTES:Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/sast.nymrli.top/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/sast.nymrli.top/privkey.pem Your cert will expire on 2019-02-08. To obtain a new or tweaked version of this certificate in the future, simply run certbot-auto again. To non-interactively renew *all* of your certificates, run &quot;certbot-auto renew&quot; - If you like Certbot, please consider supporting our work by: 配置Nginx: server 不再监听80端口，因为TLS要使用的是443端口，然后引入证书和key 123456789101112131415161718server &#123; listen 443 ssl; server_name 127.0.0.1; charset utf-8; client_max_body_size 75M; location /static&#123; alias /home/mrli/Python_project/QQoauth_remote/static; &#125; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:81; uwsgi_param UWSGI_SCRIPT app:app; # 启动flask的文件:Flask的实例 &#125; ssl_certificate /etc/letsencrypt/live/test.nymrli.top/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/test.nymrli.top/privkey.pem; #前面生成的证书，改一下里面的域名就行，不建议更换路径&#125; 重启Nginx： 1sudo service nginx restart 使用acme.sh 下载acme 123git clone https://github.com/Neilpang/acme.sh.gitcd acme.sh./acme.sh --install 提示信息 1234567891011[Thu Aug 22 19:58:00 CST 2019] It is recommended to install socat first.[Thu Aug 22 19:58:00 CST 2019] We use socat for standalone server if you use standalone mode.[Thu Aug 22 19:58:00 CST 2019] If you don&apos;t use standalone mode, just ignore this warning.[Thu Aug 22 19:58:00 CST 2019] Installing to /home/mrli/.acme.sh[Thu Aug 22 19:58:00 CST 2019] Installed to /home/mrli/.acme.sh/acme.sh[Thu Aug 22 19:58:00 CST 2019] Installing alias to &apos;/home/mrli/.bashrc&apos;[Thu Aug 22 19:58:00 CST 2019] OK, Close and reopen your terminal to start using acme.sh[Thu Aug 22 19:58:00 CST 2019] Installing cron job1 0 * * * &quot;/home/mrli/.acme.sh&quot;/acme.sh --cron --home &quot;/home/mrli/.acme.sh&quot; &gt; /dev/null[Thu Aug 22 19:58:00 CST 2019] Good, bash is found, so change the shebang to use bash as preferred.[Thu Aug 22 19:58:01 CST 2019] OK 生成证书 123export Ali_Key=\"xxxx\"export Ali_Secret=\"yyyy\"acme.sh --issue --dns dns_ali -d nymrli.top -d *.nymrli.top 注：这边的Key和secret需要找到你的阿里云API密钥，Acesskey ![accesskeys](C:/Users/10630/Documents/Let’s Encrypt 安装配置 SSL 证书教程/accesskeys.png) 输出信息** 12345678910111213141516171819202122232425262728293031323334353637383940[Thu Aug 22 20:01:53 CST 2019] Create account key ok.[Thu Aug 22 20:01:53 CST 2019] Registering account[Thu Aug 22 20:01:55 CST 2019] Registered[Thu Aug 22 20:01:55 CST 2019] ACCOUNT_THUMBPRINT='YljrV0ThIsQxXtfdxksrd91g1fWvM9Btn9Dazt8OWyo'[Thu Aug 22 20:01:55 CST 2019] Creating domain key[Thu Aug 22 20:01:55 CST 2019] The domain key is here: /home/mrli/.acme.sh/nymrli.top/nymrli.top.key[Thu Aug 22 20:01:55 CST 2019] Multi domain='DNS:nymrli.top,DNS:*.nymrli.top'[Thu Aug 22 20:01:55 CST 2019] Getting domain auth token for each domain[Thu Aug 22 20:01:56 CST 2019] Getting webroot for domain='nymrli.top'[Thu Aug 22 20:01:56 CST 2019] Getting webroot for domain='*.nymrli.top'[Thu Aug 22 20:01:57 CST 2019] Adding txt value: NyNt2AxJ3OmW8s_wVn2C3CNN9_yT1o_v2o0MhmdUoTs for domain: _acme-challenge.nymrli.top[Thu Aug 22 20:01:59 CST 2019] The txt record is added: Success.[Thu Aug 22 20:01:59 CST 2019] Adding txt value: ADqtxSTlQ0DH7jHZzlP9UZB0dT9U2oVYSk_zTabYN3w for domain: _acme-challenge.nymrli.top[Thu Aug 22 20:02:01 CST 2019] The txt record is added: Success.[Thu Aug 22 20:02:01 CST 2019] Let's check each dns records now. Sleep 20 seconds first.[Thu Aug 22 20:02:22 CST 2019] Checking nymrli.top for _acme-challenge.nymrli.top[Thu Aug 22 20:02:24 CST 2019] Domain nymrli.top '_acme-challenge.nymrli.top' success.[Thu Aug 22 20:02:24 CST 2019] Checking nymrli.top for _acme-challenge.nymrli.top[Thu Aug 22 20:02:25 CST 2019] Domain nymrli.top '_acme-challenge.nymrli.top' success.[Thu Aug 22 20:02:25 CST 2019] All success, let's return[Thu Aug 22 20:02:25 CST 2019] Verifying: nymrli.top[Thu Aug 22 20:02:28 CST 2019] Success[Thu Aug 22 20:02:28 CST 2019] Verifying: *.nymrli.top[Thu Aug 22 20:02:31 CST 2019] Success[Thu Aug 22 20:02:31 CST 2019] Removing DNS records.[Thu Aug 22 20:02:31 CST 2019] Removing txt: NyNt2AxJ3OmW8s_wVn2C3CNN9_yT1o_v2o0MhmdUoTs for domain: _acme-challenge.nymrli.top[Thu Aug 22 20:02:34 CST 2019] Removed: Success[Thu Aug 22 20:02:34 CST 2019] Removing txt: ADqtxSTlQ0DH7jHZzlP9UZB0dT9U2oVYSk_zTabYN3w for domain: _acme-challenge.nymrli.top[Thu Aug 22 20:02:38 CST 2019] Removed: Success[Thu Aug 22 20:02:38 CST 2019] Verify finished, start to sign.[Thu Aug 22 20:02:38 CST 2019] Lets finalize the order, Le_OrderFinalize: https://acme-v02.api.letsencrypt.org/acme/finalize/64001779/941369076[Thu Aug 22 20:02:40 CST 2019] Download cert, Le_LinkCert: https://acme-v02.api.letsencrypt.org/acme/cert/034f6880d75703381da6f5efedb159772580[Thu Aug 22 20:02:40 CST 2019] Cert success.-----BEGIN CERTIFICATE-----xxxxx-----END CERTIFICATE-----[Thu Aug 22 20:02:40 CST 2019] Your cert is in /home/mrli/.acme.sh/nymrli.top/nymrli.top.cer [Thu Aug 22 20:02:40 CST 2019] Your cert key is in /home/mrli/.acme.sh/nymrli.top/nymrli.top.key [Thu Aug 22 20:02:40 CST 2019] The intermediate CA cert is in /home/mrli/.acme.sh/nymrli.top/ca.cer [Thu Aug 22 20:02:40 CST 2019] And the full chain certs is there: /home/mrli/.acme.sh/nymrli.top/fullchain.cer nginx配置文件内容 123456789101112131415161718server &#123; listen 443 ssl; server_name 127.0.0.1; charset utf-8; client_max_body_size 75M; location /static&#123; alias /home/mrli/Python_project/QQoauth_remote/static; &#125; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:81; uwsgi_param UWSGI_SCRIPT app:app; # 启动flask的文件:Flask的实例 &#125; ssl_certificate /home/mrli/.acme.sh/nymrli.top/fullchain.cer; ssl_certificate_key /home/mrli/.acme.sh/nymrli.top/nymrli.top.key; #前面生成的证书，改一下里面的域名就行，不建议更换路径&#125; 阿里云免费SSL证书symantec 从云盾证书服务(包年)中选择免费的symantec生成后，按下载，选择nginx证书 文件内容如下 我们需要把这两个文件放到我们的服务器中，如果是linux系统，推荐放到/etc/ssl/目录下 示例：nginx节点配置 1234567891011121314151617181920212223242526272829http&#123; #http节点中可以添加多个server节点 server&#123; #监听443端口 listen 443; #对应的域名，把test.nymrli.top改成你们自己的域名就可以了 server_name test.nymrli.top; ssl on; #从腾讯云获取到的第一个文件的全路径 ssl_certificate /etc/ssl/1474527_www.nymrli.top.pem; #从腾讯云获取到的第二个文件的全路径 ssl_certificate_key /etc/ssl/1474527_www.nymrli.top.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; #这是我的主页访问地址，因为使用的是静态的html网页，所以直接使用location就可以完成了。 location / &#123; #文件夹 root /usr/local/service/ROOT; #主页文件 index index.html; &#125; &#125;&#125; ▲.crt、pem、key都是证书文件 问题解决: 1Problem binding to port 80: Could not bind to IPv4 or IPv6. 原因是 nginx 占用了80端口，输入service nginx stop。然后再次执行证书安装命令，即可顺利安装。安装完毕后，输入service nginx start，重启 nginx 服务。 2.重启nginx失败=&gt;conf配置有问题 12See &quot;systemctl status nginx.service&quot; and &quot;journalctl -xe&quot; for details. failed! A:.conf文件的注释是#而不是//","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"}]},{"title":"时间序列概念及主要模型","slug":"时间序列概念及主要模型","date":"2019-07-29T11:05:18.000Z","updated":"2019-09-15T08:07:31.076Z","comments":true,"path":"2019/07/29/时间序列概念及主要模型/","link":"","permalink":"https://nymrli.top/2019/07/29/时间序列概念及主要模型/","excerpt":"","text":"时间序列概念及主要模型 Q:什么是时间序列分析? A:时间序列是按照时间顺序，按照一定时间间隔取得的一系列观测值 Q:怎样做时间序列分析? A:时间序列分析尝试找出序列值在过去呈现的特征模式，假定这种模式在未来能够持续，进而对未来进行预测 时间序列三大特征 序列相关性：当期的序列值和前期某个或某些序列值线性相关 √ 自相关系数（全相关系数）（ACF）：用来度量同一事件在不同时期之间的相关程度。ρh=r(h)r(0)\\rho_{h}=\\frac{r(h)}{r(0)}ρh​=r(0)r(h)​，其中r（h）为h期协方差函数，r（0）为方差 √ 偏自相关系数（PACF）：度量去除中间变量影响后的相关程度。XtX_{t}Xt​和Xt−2X_{t-2}Xt−2​通过Xt−1X_{t-1}Xt−1​产生关联，PACF即为去除Xt−1X_{t- 1}Xt−1​的关联后两者的相关程度 趋势性：序列整体上呈现单调性，如平稳，上涨或下跌 ARMA模型是平稳的时间序列模型，在建模前必须去除趋势性 随机性：序列在一定程度上呈现不确定性 模型并不能够捕捉到现实世界中的所有特征，总有一些噪声的存在，这些噪声叫做白噪声 时间序列模型预测方法： 算术平均法，移动平均法，加权移动平均法，指数平滑法，自回归法和移动平均法（ARIMA） 算数平均法：对时间序列的过去数据进行简单平均来进行预测 移动平均法(ARIMA)：不考虑远期的数据，仅考虑近期数据产生的影响。 加权移动平均法：给予近期数据较大的权重，远期数据较小的权重 指数平滑法：给予近期数据较大的权重，远期数据较小的权重，但是权重以指 数的形式适减 自回归法和移动平均法（ARIMA）:先对数据做了差分，之后再使用自回归滑动平均模型[^ARMA]模型。优点信息浪费最少，集趋势性，相关性和随机性于一身 基本概念 T时刻的时间序列值表示为XtX_tXt​,T-1时刻的序列值表述为Xt−1X_{t-1}Xt−1​或者X[t−1]X[t-1]X[t−1] 一个时间序列可以表述为：{Xt∣t=1,2,3…n}\\left\\{X_{t} | t=1,2,3 \\dots n\\right\\}{Xt​∣t=1,2,3…n} 滞后算子BX,=Xt−1B X,=X_{t-1}BX,=Xt−1​ 时间序列的差分:Xt−Xt−1X_{t}-X_{t-1}Xt​−Xt−1​或者X[t]−X[t−1]X[t]-X[t-1]X[t]−X[t−1] 一阶差分：Xt−Xt−1=Xt−BXt=(1−B)XtX_{t}-X_{t-1}=X_{t}-B X_{t}=(1-B) X_{t}Xt​−Xt−1​=Xt​−BXt​=(1−B)Xt​ 二阶差分：∇(∇Xt)=∇Xt−∇Xr−1=(Xt−Xt−1)−(Xt−1−Xt−2)=Xt−2Xt−1+Xt−2=(1−B)2Xt\\nabla\\left(\\nabla X_{t}\\right)=\\nabla X_{t}-\\nabla X_{r-1}=\\left(X_{t}-X_{t-1}\\right)-\\left(X_{t-1}-X_{t-2}\\right)=X_{t}-2 X_{t-1}+X_{t-2}=(1-B)^{2} X_{t}∇(∇Xt​)=∇Xt​−∇Xr−1​=(Xt​−Xt−1​)−(Xt−1​−Xt−2​)=Xt​−2Xt−1​+Xt−2​=(1−B)2Xt​ k步差分：Xt−Xt−k=Xt−BkXt=(1−Bk)XtX_{t}-X_{t-k}=X_{t}-B^{k} X_{t}=\\left(1-B^{k}\\right) X_{t}Xt​−Xt−k​=Xt​−BkXt​=(1−Bk)Xt​ 思考： 1.三阶差分如何表达？3步差分如何表达？ 2.为什么要进行一阶差分？二阶差分？ 3.为什么要进行k步差分？ 4.阶次差分与步长差分的区别？ 时间序列分类 Q:什么是序列平稳？ A: 1.E(Xt)=μE\\left(X_{t}\\right)=\\muE(Xt​)=μ，对于所有t而言，序列的期望为一常数，见图一 2.Var⁡(Xt)=σ\\operatorname{Var}\\left(X_{t}\\right)=\\sigmaVar(Xt​)=σ，对于所有t，序列方差为一常数，见图二 3.r(h)=Cov⁡(Xt,Xt−l)r(h)=\\operatorname{Cov}\\left(X_{t}, X_{t-l}\\right)r(h)=Cov(Xt​,Xt−l​)对于所有t以及h〉0，序列的协方差为是由h唯一决定的函数，即h阶的相关性只与h有关，与时刻t无关，如：{Xn,Xn+1,Xn+2,…,Xn},{X1,X2,X3,…,Xn+1−n]\\left\\{X_{n}, X_{n+1}, X_{n+2}, \\ldots, X_{n}\\right\\},\\left\\{X_{1}, X_{2}, X_{3}, \\ldots, X_{n+1}-n\\right]{Xn​,Xn+1​,Xn+2​,…,Xn​},{X1​,X2​,X3​,…,Xn+1​−n]与{Xh+5,Xh+6,Xh+7,…,Xn+5},{X6,X7,X8,…,Xn+6−h}\\left\\{X_{h+5}, X_{h+6}, X_{h+7}, \\ldots, X_{n+5}\\right\\},\\left\\{X_{6}, X_{7}, X_{8}, \\ldots, X_{n+6-h}\\right\\}{Xh+5​,Xh+6​,Xh+7​,…,Xn+5​},{X6​,X7​,X8​,…,Xn+6−h​}的相关性一致 根据序列是否平稳，时间序列可以分为： 平稳序列：白噪声序列、AR（p）序列，MA（a）序列，ARWA（p.g）序列 非平稳序列：ARlMA（P.d.g）序列 平稳条件: 1.E(xt)=μE\\left(x_{t}\\right)=\\muE(xt​)=μ序列的均值应该是一个常数，而不是随时间变化的函数。下图中左图满足要求，而右图的均值是随时间而变化的。 2.Var⁡(Xt)=σ\\operatorname{Var}\\left(X_{t}\\right)=\\sigmaVar(Xt​)=σ,序列的方差为一个常数，而不随时间的变化 3.Cov⁡(yt,yt+k)=y0\\operatorname{Cov}(y t, y t+k)=y 0Cov(yt,yt+k)=y0,k,序列协方差的值只与时间间隔k有关，与时间t无关 白噪声序列 (高斯)白噪声模型:Xt=et∣et∼WN(0,σ2)X_{t}=\\mathrm{e}_{\\mathrm{t}} | \\mathrm{e}_{\\mathrm{t}} \\sim \\mathrm{WN}\\left(0, \\sigma^{2}\\right)Xt​=et​∣et​∼WN(0,σ2) (高斯)白噪声就是一系列独立分布的正态序列： 序列相关性：无 趋势性：无 随机性：是 白噪声的每一个时序点都是服从正态分布的 序列无规律可循，在均值处反复震荡 1234567891011clear,clc;N=0:1000;fs=1024;t=N./fs;y=3*sin(2*pi*t);x=wgn(1,1001,2); % wgn产生高斯白噪声i=y+x; % 给原有信号y叠加高斯白噪声%i=awgn(y,2); % awgn在信号y中加入高斯白噪声。subplot(3,1,1),plot(x);subplot(3,1,2),plot(y);subplot(3,1,3),plot(i); 自回归模型AR ▲AR§: Xt=β1Xt−1+β2Xt−2+…+βpXt−p+etet∼WN(0,σ2)X_{t} = \\beta_{1}X_{t-1}+\\beta_{2} X_{t-2}+\\ldots+\\beta_{p} X_{t-p}+\\mathrm{e}_{t} \\quad \\mathrm{e}_{t} \\sim \\mathrm{WN}\\left(0, \\sigma^{2}\\right)Xt​=β1​Xt−1​+β2​Xt−2​+…+βp​Xt−p​+et​et​∼WN(0,σ2) 当前时刻的时序值可由其过去值的线性组合加上一个白噪声 建模的目的就是要搞清过去几期的历史值会影响当前值 模型特征： 趋势性：无 相关性：有 随机性：有 ▲AR（1）模型: Xt=β1Xt−1+etX_{t}=\\beta_{1} X_{t-1}+e_{t}Xt​=β1​Xt−1​+et​ 一阶自回归模型是最简单的自回归模型 该模型在t+1时的情形:Xt+1=β⊥Xt+et+1X_{t+1}=\\beta_{\\perp} X_{t}+e_{t+1}Xt+1​=β⊥​Xt​+et+1​ 自相关系数：ρ1=β1,ρ2=β12,…,ρk=β1k,k≥3\\rho_{1}=\\beta_{1}, \\rho_{2}=\\beta_{1}^{2}, \\ldots, \\rho_{k}=\\beta_{1}^{k}, \\mathrm{k} \\geq 3ρ1​=β1​,ρ2​=β12​,…,ρk​=β1k​,k≥3 偏自相关系数：φ11=ρ1,φkk=0,k⩾2\\varphi_{11}=\\rho_{1}, \\varphi_{k k}=0, k \\geqslant 2φ11​=ρ1​,φkk​=0,k⩾2 AR（1）的序列相关性： ACF星现指数下降趋势 PACF在一阶处出现峰值，之后截断 Q:如何识别自回归阶数 A: PACF显示出剧烈地下降，并截断在P阶，而ACF呈指数下降趋势 PACF截尾的阶数即为AR模型的阶数 移动平均模型MA ▲MA(a): Xt=et+β˙1et−1+β2et−2+…+βqet−qX_{t}=e_{t}+\\dot{\\beta}_{1} e_{t-1}+\\beta_{2} e_{t-2}+\\ldots+\\beta_{q} e_{t-q}Xt​=et​+β˙​1​et−1​+β2​et−2​+…+βq​et−q​ , et∼WN(0,σ2)e_{t} \\sim W N\\left(0, \\sigma^{2}\\right)et​∼WN(0,σ2) 序列当前时刻的时序值是过去q阶白噪声的线性组合 建模的目的在于： 找出过去几期的白噪声影响了当前值 找出过去a期冲击效应对当前值的影响 模型特征： 趋势性：无 相关性：有 随机性：有 ▲MA（1）模型: Xt=et+β1et−1X_{t}=e_{t}+\\beta_{1} e_{t-1}Xt​=et​+β1​et−1​ 一阶移动平均模型是最简单的移动平均模型 该模型在t+1时的情形？Xt+1=et+1+β1etX_{t+1}=e_{t+1}+\\beta_{1} e_{t}Xt+1​=et+1​+β1​et​ ​ MA（1）模型是利用t时刻的冲击变量值来预测将来 自相关系数：ρk=γkγ0={β11+β12,k=10k≥2\\rho_{k}=\\frac{\\gamma_{k}}{\\gamma_{0}}=\\left\\{\\begin{array}{cc}{\\frac{\\beta_{1}}{1+\\beta_{1}^{2}},} &amp; {k=1} \\\\ {0} &amp; {k \\geq 2}\\end{array}\\right.ρk​=γ0​γk​​={1+β12​β1​​,0​k=1k≥2​ 偏自相关系数：φkk={ρ1,k=1−ρ121−ρ12k=2−φk−1,k−1ρ11−φk−1,1ρ1k≥3\\varphi_{k k}=\\left\\{\\begin{array}{cc}{\\rho_{1},} &amp; {k=1} \\\\ {\\frac{-\\rho_{1}^{2}}{1-\\rho_{1}^{2}}} &amp; {k=2} \\\\ {\\frac{-\\varphi_{k-1, k-1} \\rho_{1}}{1-\\varphi_{k-1,1} \\rho_{1}}} &amp; {k \\geq 3}\\end{array}\\right.φkk​=⎩⎪⎨⎪⎧​ρ1​,1−ρ12​−ρ12​​1−φk−1,1​ρ1​−φk−1,k−1​ρ1​​​k=1k=2k≥3​ 自回归滑动平均模型ARMA ▲ARMA（p,q）:Xt=β1Xt−1+…+βpXt−p+et+α1et−1+α2et−2+…+αqet−qX_{t}=\\beta_{1} X_{t-1}+\\ldots+\\beta_{p} X_{t-p}+e_{t}+\\alpha_{1} e_{t-1}+\\alpha_{2} e_{t-2}+\\ldots+\\alpha_{q} e_{t-q}Xt​=β1​Xt−1​+…+βp​Xt−p​+et​+α1​et−1​+α2​et−2​+…+αq​et−q​ ARMA（p,q）模型就是AR（p）和MA（q）模型的组合 ARMA模型是更普遍的一类模型 模型特征： 趋势性：无 相关性：有 随机性：有 ▲ARMA(1,1)： 通过查看自相关函数ACF和偏自相关函数PACF识别相关性 ACF呈指数下降趋势 PACF呈现指数下降趋势 Q:如何识别一个ARMA的阶数p和q? A: 1.由于ACF与PACF均呈现指数下降，判断阶数需要靠不断尝试 2.在模型的不同尝试中，通过选择AIC较小的为最优模型 AIC=2k+n∗ln⁡(RSSn)A I C=2 k+n * \\ln (\\frac{R S S}{n})AIC=2k+n∗ln(nRSS​)k为参教数量，RSS为残差平方和 AR，MA，ARMA模型识别 ARIMA模型 ARIMA是在ARMA基础上发展而来的更加综合性的模型，体现为： ■ 趋势性 ■ 序列相关性 ■ 随机性 ARIMA是不平稳的时间序列，不能直接用ARMA建模。ARIMA模型是在ARMA模型演变出来的，它实际上是先对数据做了差分，之后再使用ARMA模型；换句话说，ARIMA模型是先将非平稳数据变得平稳（用差分），之后再用ARMA模型处理平稳数据 ARIMA（1，1，0）的时间序列： 序列有很强的趋势性 ARIMA（1，1，0）的序列相关性： ACF下降极其缓慢 ARIMA（1，1，0）的序列图和ACF： ARIMA(p,d,q) ∇dXt=(1−B)dXt=Yt\\nabla_{d} X_{t}=(1-B)^{d} X_{t}=Y_{t}∇d​Xt​=(1−B)dXt​=Yt​ Yt=β1Yt−1+...+βpYt−p+et+α1et−1+α2et−2+…+αqet−qY_{t}=\\beta_{1} Y_{t-1}+...+\\beta_{p} Y_{t-p}+e_{t}+\\alpha_{1} e_{t-1}+\\alpha_{2} e_{t-2}+\\ldots+\\alpha_{q} e_{t-q}Yt​=β1​Yt−1​+...+βp​Yt−p​+et​+α1​et−1​+α2​et−2​+…+αq​et−q​ 差分后的序列符合ARMA（p，g） 符号△为差分算子，∇dXt\\nabla_{d} X_{t}∇d​Xt​代表d阶差分序列 一阶差分序列ΔXt=(1−B)∗Xt=Xt−Xt−1\\Delta X_{t}=(1-B)^{*} X_{t}=X_{t}-X_{t-1}ΔXt​=(1−B)∗Xt​=Xt​−Xt−1​ 预测的评价指标 ME（误差）：Mean（Actual-Predict） MAE（绝对误差）：Mean（abs（Actual-Predict）） MAPE（百分比误差）：Mean（abs（Actual-Predict/Actual） MSE（均方误差平方和）：Mean（（Actual-Predict）2） RMSE（标准差）：Sqrt（Mean（（Actual-Predict）A2）） 在模型选择方法上，通常会结合客户的建议以及其他的时间序列模型方法，选择某个评价指标，进而选择使该评价指标最小的模型方法 参考:https://blog.csdn.net/weixin_41636030/article/details/89115370","categories":[],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"https://nymrli.top/tags/数学建模/"}]},{"title":"基础知识补充——白噪声、高斯白噪声","slug":"基础知识补充——白噪声、高斯白噪声","date":"2019-07-29T10:47:04.000Z","updated":"2019-09-15T08:07:31.041Z","comments":true,"path":"2019/07/29/基础知识补充——白噪声、高斯白噪声/","link":"","permalink":"https://nymrli.top/2019/07/29/基础知识补充——白噪声、高斯白噪声/","excerpt":"","text":"白噪声、高斯白噪声 白噪声过程: 对于一个随机变量X(t)（t=1，2，3……），如果是由一个不相关的随机变量的序列构成的，即对于所有s不等于t，随机变量X(t)和X(s)的协方差为零，则称其为纯随机过程。对于一个纯随机过程来说，若其期望为0，方差为常数，则称之为白噪声过程。 白噪声: 白噪声序列，是指白噪声过程的样本实称，简称白噪声[1]。白噪声是**在较宽的频率范围内，各等带宽的频带所含的噪声能量相等的噪声**[2]，是一种功率频谱密度为常数的随机信号或随机过程，也就是说，此信号在各个频段上的功率是一样的。 理想的白噪声具有无限的带宽，因而其能量无限大，但这是不可能实际存在的，所以，我们把有限带宽内的平整讯号视为白噪声[^3]，以便我们实际应用当中的分析。 近似计算:一般情况下，若一个噪声过程所具有的频谱宽度远远大于它所作用系统的带宽，并且在该带宽中其功率谱密度基本为一常数，那么就能够把其作为白噪声来对待。 白噪声的功率密度函数恒定，为Pn(t)=n02(−∞&lt;f&lt;+∞)(W/HZ)P_{n}(t)=\\frac{n_{0}}{2}(-\\infty&lt;f&lt;+\\infty)(\\mathrm{W} / \\mathrm{HZ})Pn​(t)=2n0​​(−∞&lt;f&lt;+∞)(W/HZ) Pn(t)=n0(0&lt;f&lt;+∞)(W/Hz)P_{n}(t)=n_{0}(0&lt;f&lt;+\\infty)(\\mathrm{W} / \\mathrm{Hz})Pn​(t)=n0​(0&lt;f&lt;+∞)(W/Hz)，其中n0n_0n0​是常数。 高斯白噪声 高斯噪声指的是它的概率密度函数服从正态分布的噪声。 高斯分布，记为N (μ,σ2)，其中μ为高斯分布的均值（数学期望），σ2为高斯分布的方差，当μ=0，σ2=1时，该分布称为标准正态分布。高斯分布的一维概率密度可表示为式：P(x)=12πσexp⁡(−(x−μ)22σ2)P(x)=\\frac{1}{\\sqrt{2 \\pi} \\sigma} \\exp \\left(-\\frac{(x-\\mu)^{2}}{2 \\sigma^{2}}\\right)P(x)=2π​σ1​exp(−2σ2(x−μ)2​) 在通信信道中，一般噪声的均值μ=0。，那么可以得知当噪声的均值是零的时候，噪声的平均功率等于其方差。 高斯白噪声的高斯指的是概率分布为正态分布，白噪声指的是其二阶矩不相关，一阶矩为常数的噪声。故把瞬时值概率分布服从高斯分布，功率谱密度服从均匀分布的噪声称为高斯白噪声[^1]。这两个条件是判断高斯白噪声性能的标准。 由于高斯白噪声能够反映实际通信信道中的噪声情况，能够比较真实的反映信道噪声的一些特性，并且可以用具体的数学表达式表示，适合分析、计算系统的抗噪声性能，所以广泛应用于通信系统的理论分析。 高斯白噪声模型:Xt=et∣et∼WN(0,σ2)X_{t}=\\mathrm{e}_{\\mathrm{t}} | \\mathrm{e}_{\\mathrm{t}} \\sim \\mathrm{WN}\\left(0, \\sigma^{2}\\right)Xt​=et​∣et​∼WN(0,σ2)","categories":[],"tags":[{"name":"信号处理","slug":"信号处理","permalink":"https://nymrli.top/tags/信号处理/"}]},{"title":"傅里叶变换->小波变化","slug":"傅里叶变换-小波变化","date":"2019-07-29T01:51:32.000Z","updated":"2021-10-25T08:37:52.168Z","comments":true,"path":"2019/07/29/傅里叶变换-小波变化/","link":"","permalink":"https://nymrli.top/2019/07/29/傅里叶变换-小波变化/","excerpt":"","text":"傅里叶变换-&gt;小波变化 声明:文中大多数内容来自(知乎1335)[https://www.zhihu.com/people/zhi-yuan-ya-77],matlab源代码:1368069096/From_FT_to_WT_examples-,部分为个人理解阐明 一.傅里叶变换FT 基础知识 （FOURIER TRANSFORM，简称FT） 为什么傅里叶变换可以把一个信号从时域变换到频域? 先给出公式，傅里叶变换的形式为：X(w)=∫−∞+∞x(t)e−jwtdtX(w)=\\int_{-\\infty}^{+\\infty} x(t) e^{-j w t} d tX(w)=∫−∞+∞​x(t)e−jwtdt PS：傅里叶变换还存在系数，有的文章写的是 12π\\frac{1}{2 \\pi}2π1​ ，有的文章写的是12π\\sqrt\\frac{1}{2 \\pi}2π1​​ ，两个系数只要满足正变换系数乘上逆变换系数等于12π\\frac{1}{2 \\pi}2π1​ 即可。这是为了保证经过一次正变换和反变换之后，得到的信号与原信号幅值相同，与我们接下来的讨论关系不大。 1.理解变换公式 我们知道，根据欧拉公式，e−jwt=cos⁡(wt)−jsin⁡(wt)e^{-j w t}=\\cos (w t)-j \\sin (w t)e−jwt=cos(wt)−jsin(wt)。也就是说，傅里叶变换的本质就是：将原始信号乘上一组三角函数（正余弦），之后在整个时间域上积分。就这么简单！ y=sin(3t)图 我们来看一个信号：y = sin(3t)，如下图： 很好的周期性质，且每个周期的积分值都是0。如果对这个函数在(−∞,+∞)(-\\infty,+\\infty)(−∞,+∞)积分，那就是基本是0，因为 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞)包含了无数个周期。 PS：虽然这个积分在高数上不可积，但是你应该明白这里我要表达的意思：因为良好的周期性，且每个周期积分值是0，那么最后在很长的一段时间区间上积分，得到的还是一个很小的数，近似为0。 我们来用一段较长的时间区间计算一下，∫050sin⁡(3t)dt=0.1002\\int_{0}^{50} \\sin (3 t) d t=0.1002∫050​sin(3t)dt=0.1002，结果符合我们的预计。 y=sin(4t)sin(3t)图 现在，我们来将这个信号乘上一个sin(4t) ，则信号变为y1 = sin(3t)*sin(4t)，如下图： 具有一个较短的小幅震动的周期和一个较长的主体周期，对吧？且每个主体周期的积分值都是0。同以上讨论，如果对这个函数在(−∞,+∞)(-\\infty,+\\infty)(−∞,+∞)积分，基本还接近于0，因为 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞)包含了无数个主体周期。 y=sin(3.1t)sin(3t)图 之后呢，我们来将这个信号乘上一个sin(3.1t) ，则信号变为y2 = sin(3t)*sin(3.1t)，如下图： 同样是有一个较短的小幅震动的周期和一个较长的主体周期，对吧？可以判断，每个主体周期的积分值都是0（虽然（0，50）这个区间没有完整地展示主题周期）。那么，依然同以上讨论，如果对这个函数在(−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 积分，基本还接近于0，因为(−∞,+∞)(-\\infty,+\\infty)(−∞,+∞)包含了无数个主体周期。 我们来用之前的时间区间计算一下， ∫050sin⁡(3t)∗sin⁡(3.1t)dt=−4.7731\\int_{0}^{50} \\sin (3 t) * \\sin (3.1 t) d t=-4.7731∫050​sin(3t)∗sin(3.1t)dt=−4.7731 。 咦？这一次怎么距离0这么远了呢？ 原因就是：对于sin(3t)*sin(4t)，它的主体周期较短，（0，50）是包含了好几个主体周期的，也就是说（0，50）在某种程度上是类似于 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 的。但是，对于sin(3t)*sin(3.1t)，它的主体周期很长，（0，50）连它的一个完整的主体周期都没有包含，那么（0，50）是不能类似于 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 的，积分值自然就比较大。 我们此时可以这样小小总结一下，对于信号y = sin(3t)，它的频率是3rad/s，（如果你喜欢用HZ，那就除以2π2\\pi2π ，就是 32π\\frac{3}{2\\pi}2π3​HZ，这里使用rad/s，是为了与前面的傅里叶变换的公式中的w一致），而sin(4t)的频率是4rad/s，sin(3.1t)的频率是3.1rad/s。 如果在 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 积分，那么y1 = sin(3t)*sin(4t)，y2 = sin(3t)*sin(3.1t)的积分值都是0，也就是说，sin(4t)和sin(3.1t)在这里是没差别的。 但是！！！如果在一个有限区间内积分，由于sin(3.1t)的频率3.1rad/s，距离原信号y = sin(3t)的频率3rad/s更近，那么sin(3.1t)和sin(3t)的乘积，也就是y2 = sin(3t)*sin(3.1t)的积分的绝对值会更大，也就是会离0更远。这里已经显示出一定的频率选择性了。 最后，让我们请出我们今天的主角，将这个信号乘上一个自己同频率的sin(3t) ，则信号变为y3 = sin(3t)*sin(3t)，如图： Amazing！！！发现了什么？良好的周期性？还有呢？**由于乘上了自己，任何时间的幅值都大于等于0了！不再满足周期内积分值为0这个条件了！**那么，此时，我们对这个信号在 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 积分，就会得到一个非常非常大的数字。这个很大很大的数字就告诉你，这个信号和你乘的信号是同频率的！这就是可以知道信号中具有哪些频率部分了，不是吗？ 我们还是来用之前的时间区间计算一下， ∫050sin⁡(3t)∗sin⁡(3t)dt=25.0833\\int_{0}^{50} \\sin (3 t) * \\sin (3 t) d t=25.0833∫050​sin(3t)∗sin(3t)dt=25.0833。是不是比其他的积分值都大了好多？ 好了，我们已经知道，▲.将一个信号乘上一个特定频率的sin函数，在 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 上积分，可以将信号中与sin函数同频率的部分筛选出来。那么，原则上讲，只要乘上所有频率的sin函数，并积分，不就知道原始信号中的所有频率部分了吗？ **但是这样做需要把所有频率乘进去，做无数次计算哈！**算不出来的。所以，我们将所乘的sin函数的频率作为符号变量w，来进行积分，即： X(w)=∫−∞+∞x(t)sin⁡(wt)dtX(w)=\\int_{-\\infty}^{+\\infty} x(t) \\sin (w t) d tX(w)=∫−∞+∞​x(t)sin(wt)dt 注意：这里的w只是一个符号变量，这样的话，就只需要做一次积分，可以计算了。 计算出来X(w)之后，想知道特定的频率w0对应的积分值，直接将w0带入X(w)就立马得到积分值。，如想知道是否含有w0=3rad/s分量,那么久计算X(3)看结果是否为0，这样就能知道原信号中是否含有这一频率的部分了。 好了，我们推导的这个式子，是不是与傅里叶变换的式子： X(w)=∫−∞+∞x(t)e−jwtdt=∫−∞+∞x(t)(cos⁡(wt)−jsin⁡(wt))dtX(w)=\\int_{-\\infty}^{+\\infty} x(t) e^{-j w t} d t=\\int_{-\\infty}^{+\\infty} x(t)(\\cos (w t)-j \\sin (w t)) d tX(w)=∫−∞+∞​x(t)e−jwtdt=∫−∞+∞​x(t)(cos(wt)−jsin(wt))dt 很像了呢？ 这就是傅里叶变换的原理！乘上带有符号变量的sin、cos函数，并积分，就知道原始信号中的所有频率部分啦！ 2、傅里叶变换（FT）的正交性 傅里叶变换是一种变换。在变换中，我们将原始信号乘上的变化信号称为基函数。 在傅里叶变换中，一系列不同频率的sin、cos等函数称为这个变换的基函数。至于为什么需要既使用sin，又使用cos，这涉及到一点点正交函数的概念。傅里叶变换中的不同频率的sin、cos等函数是正交函数，使用正交函数组成的基函数会带给变换一些方便。 什么是正交性? 向量正交: 我们都知道，向量a,ba,ba,b的内积为a⋅ba · ba⋅b。正交的定义为内积为0，即a⋅b=0a · b=0a⋅b=0。如a=(1,0)a=(1,0)a=(1,0) 表示x轴，$b=(0,1) $表示y轴，则 a⋅b=0a · b=0a⋅b=0即意味着x轴与y轴正交。 假设有一个向量 v=(x0,y0)v=\\left(x_{0}, y_{0}\\right)v=(x0​,y0​)， x0x_0x0​ 在x轴上定位v，y0y_0y0​ 在y轴上定位v。当x轴与y轴正交时，意味着x坐标和y坐标表示的信息是彼此独立的，两坐标可以完全定位v。 那么，当我们已知向量v，已知x轴a与y轴b，如果知道v的坐标呢？答案就是，投影/内积。 将v向x轴a做投影/内积： x0=v⋅ax_0=v·ax0​=v⋅a，可以得到x0x_0x0​；将v向y轴b做投影/内积：y0=v⋅by_0=v·by0​=v⋅b，可以得到y0y_0y0​。 正交基 类似的，函数$ f_{1}(x), f_{2}(x) 的内积定义如下：的内积定义如下：的内积定义如下：\\int_{-\\infty}^{+\\infty} f_{1}(x) f_{2}(x) d x$。函数正交的定义同样为内积为0，即 ∫−∞+∞f1(x)f2(x)dx=0\\int_{-\\infty}^{+\\infty} f_{1}(x) f_{2}(x) d x=0∫−∞+∞​f1​(x)f2​(x)dx=0 。PS：对于周期函数，定义中的积分区间为一个周期T。 我们来看， ∫0Tsin⁡(w1x)cos⁡(w2x)dx=0(1)\\int_{0}^{T} \\sin \\left(w_{1} x\\right) \\cos \\left(w_{2} x\\right) d x=0 (1)∫0T​sin(w1​x)cos(w2​x)dx=0(1) ∫0Tsin⁡(w1x)sin⁡(w2x)dx=0,w1≠w2(2)\\int_{0}^{T} \\sin \\left(w_{1} x\\right) \\sin \\left(w_{2} x\\right) d x=0, w_{1} \\neq w_{2}(2)∫0T​sin(w1​x)sin(w2​x)dx=0,w1​​=w2​(2) ∫0Tcos⁡(w1x)cos⁡(w2x)dx=0,w1≠w2(3)\\int_{0}^{T} \\cos \\left(w_{1} x\\right) \\cos \\left(w_{2} x\\right) d x=0, w_{1} \\neq w_{2}(3)∫0T​cos(w1​x)cos(w2​x)dx=0,w1​​=w2​(3) ▲.因此，傅里叶变换中的不同频率的sin、cos等函数都是正交函数。我们将cos想象为一个轴，将sin想象为一个轴 ，这两个轴，就张了一个函数空间。 我们已经知道，x(t)的傅里叶变换为： X(w)=∫−∞+∞x(t)(cos⁡(wt)−jsin⁡(wt))dt=∫−∞+∞x(t)cos⁡(wt)dt−j∫−∞+∞x(t)sin⁡(wt)dtX(w)=\\int_{-\\infty}^{+\\infty} x(t)(\\cos (w t)-j \\sin (w t)) d t=\\int_{-\\infty}^{+\\infty} x(t) \\cos (w t) d t-j \\int_{-\\infty}^{+\\infty} x(t) \\sin (w t) d tX(w)=∫−∞+∞​x(t)(cos(wt)−jsin(wt))dt=∫−∞+∞​x(t)cos(wt)dt−j∫−∞+∞​x(t)sin(wt)dt 我们来看，实部 ∫−∞+∞x(t)cos⁡(wt)dt\\int_{-\\infty}^{+\\infty} x(t) \\cos (w t) d t∫−∞+∞​x(t)cos(wt)dt 即相当于将x(t)与cos做内积，即向cos轴投影，得到的是在这个函数空间内的cos坐标，也就是与cos的相似度；虚部∫−∞+∞x(t)sin⁡(wt)dt\\int_{-\\infty}^{+\\infty} x(t) \\sin (w t) d t∫−∞+∞​x(t)sin(wt)dt 即相当于将x(t)与sin做内积，即向sin轴投影，得到的是在这个函数空间内的sin坐标，也就是与sin的相似度。cos坐标和sin坐标都确定后，该信号就确定了。 因此，傅里叶变换之后，实部是与cos的相似度，虚部是与sin的相似度，傅里叶变换也就是与cos的相似度和与sin的相似度的总和，也就表示了相应的频率信息。 相似度的理解：通过相似度，可以将跟本身频率相似的频率挑选出来 3、小例子 最后，我们对于y=sin(3t)做傅里叶变换（这里画图用的matlab的FFT，是FT的离散快速算法，不是积分出来的，但是原理是相同的，仅做展示使用），变换后的图像如下： 可以看到，与我们的预期相同，变换之后，在 ω=3rad/s\\omega=3 rad/ sω=3rad/s 处，出现了峰值，即表示该信号中包含了 的 ω=3rad/s\\omega=3 rad/ sω=3rad/s 频率成分。 这里需要说明三点： 1、这边的作图结果不是理想FT，如果是理想的FT，即在 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 上积分，那么除了 ω=3rad/s\\omega=3 rad/ sω=3rad/s 的积分值将是 +∞+\\infty+∞ 之外，其他任意频率处的值都应该是0，得到的将是一个冲激函数。但是，这里我用的是离散傅里叶变换（详见我的下一篇文章），可以暂时理解为类似于我们讨论过的有限区间，当频率靠近3rad/s时（如之前提到的3.1rad/s的例子），也会积分出来一个较大的数值，所以这里不是一个冲击函数，而是一个山峰状的函数； 2、傅里叶变换之后是具有实部和虚部的，实部是与cos的相似度，虚部是与sin的相似度。我们要频率信息的时候，不管是与某一频率w的cos的相似还是与某一频率w的sin的相似，都是这一频率w嘛，不需要区分。因此，这里画图取了模，就不存在实部和虚部了。 3、在ω=3rad/s\\omega=3 r a d / sω=3rad/s处之所以没有出现我们讨论的很大很大很大的值，是因为画图之前对于变换之后的幅值统一除以了信号取样点的个数，统一压缩了一定的倍数。 总结 1.由于sin和cos是一对正交基，所以所有的信号都可以分解成正弦信号与余弦信号的线性叠加。 2.除了与乘以本身频率w的正余弦相同信号再在(−∞,+∞)(-\\infty,+\\infty)(−∞,+∞)范围上积分的结果会是非0以外，乘以其他频率信号的结果都是0.通过这个特性可以将是否含有w频率信号鉴别出 2.傅里叶变化的基函数ejwte^{jwt}ejwt由欧拉公式可分解为e−jwt=cos⁡(wt)−jsin⁡(wt)e^{-j w t}=\\cos (w t)-j \\sin (w t)e−jwt=cos(wt)−jsin(wt),所以根据公式:X(w)=∫−∞+∞x(t)cos⁡(wt)dt−j∫−∞+∞x(t)sin⁡(wt)dtX(w)=\\int_{-\\infty}^{+\\infty} x(t) \\cos (w t) d t-j \\int_{-\\infty}^{+\\infty} x(t) \\sin (w t) d tX(w)=∫−∞+∞​x(t)cos(wt)dt−j∫−∞+∞​x(t)sin(wt)dt，前部分乘以cos(wt)能挑出cos成分中的信号频率，后部分乘以的sin(wt)能挑出sin成分中的信号频率。再将挑出的各信号频率线性叠加的结果就是分解信号总的含有各谐波分量的频率 二.傅里叶变换（FT）的缺点与短时傅里叶变换（STFT） 离散傅里叶变换（DFT） 在本文正式开始之前，我们需要明确一下实际信号进行的FT的一些特殊之处。实际采集的信号往往是这样的： 实际的信号往往具有两个特点： 1、离散性，就是采集数据不连续，很容易理解，采集信号肯定是一个一个数据采集的； 2、有限性，虽然理想的傅里叶变换是从 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 进行积分，但是实际信号往往实在一个区间内(a,b)的。 所以，我们要用到离散傅里叶变换（DISCRETE FOURIER TRANSFORM，简称DFT），DFT与FT相比，就是多了两个特征：1、离散型，2、有限性。 我们来一起试一试如何推导DFT公式。首先设采集了N个信号点，其时刻为 t0,t1,…tN−1t_{0}, t_{1}, \\ldots t_{N-1}t0​,t1​,…tN−1​，对应时刻采集到的信号值为x(t0),x(t1),…x(tN−1)x\\left(t_{0}\\right), x\\left(t_{1}\\right), \\ldots x\\left(t_{N-1}\\right)x(t0​),x(t1​),…x(tN−1​) 。很自然的，原来信号连续，是积分，现在数据离散了，那就是把积分变成累加。于是我们得到： X(w)=∑i=0N−1x(ti)e−jwtiX(w)=\\sum_{i=0}^{N-1} x\\left(t_{i}\\right) e^{-j w t_{i}}X(w)=∑i=0N−1​x(ti​)e−jwti​ 这么一来，我们发现，原信号有N个数据点，DFT变换后的信号却变成连续的了，我们将之称为离散时间傅里叶变换（DISCRETE TIME FOURIER TRANSFORM，简称DTFT）。 DTFT有两个缺点，第一， 且连续，需要进行无数次计算，计算机无法计算；第二，在进行计算的时候，我们需要已知：t0,t1,/ldotstN−1t_{0}, t_{1}, /ldots t_{N-1}t0​,t1​,/ldotstN−1​和 x/left(t0/right),x/left(t1/right),/ldotsx/left(tN−1/right)x/left(t_{0}/right), x/left(t_{1}/right), /ldots x/left(t_{N-1}/right)x/left(t0​/right),x/left(t1​/right),/ldotsx/left(tN−1​/right) ，但是调用过FFT函数的同学都知道，FFT只需要已知x/left(t0/right),x/left(t1/right),/ldotsx/left(tN−1/right)x/left(t_{0}/right), x/left(t_{1}/right), /ldots x/left(t_{N-1}/right)x/left(t0​/right),x/left(t1​/right),/ldotsx/left(tN−1​/right)就可以进行。 这是怎么回事呢？ 首先，我们**使用相对采样时间 代替真实采样时间 ，**可以得到： 。 此时我们发现， X(w)X(w)X(w) 变成了以 2/pi2/pi2/pi为周期的函数，即 那么，我们只需要计算 w/in(0,2/pi)w /in(0,2 /pi)w/in(0,2/pi) 区间的 X(w)X(w)X(w) ，就可以得到 w/in(−/infty,+/infty)w /in(-/infty,+/infty)w/in(−/infty,+/infty) 区间的X(w)X(w)X(w)了。也就是说，通过使用相对采样时间 代替真实采样时间t0,t1,/ldotstN−1t_{0}, t_{1}, /ldots t_{N-1}t0​,t1​,/ldotstN−1​，我们将 的范围从 (−/infty,+/infty)(-/infty,+/infty)(−/infty,+/infty) 缩小到了(0,2/pi2/pi2/pi). 自然地，我们希望将(0,2π2\\pi2π)离散化称为N个点，这样计算机就可以计算了！则取w=2πkN,k=0,1,…N−1w=\\frac{2 \\pi k}{N}, k=0,1, \\ldots N-1w=N2πk​,k=0,1,…N−1，则有： X(k)=∑n=0N−1x(n)e−j2πkNn,k=0,1…N−1X(k)=\\sum_{n=0}^{N-1} x(n) e^{-j \\frac{2 \\pi k}{N} n}, k=0,1 \\ldots N-1X(k)=∑n=0N−1​x(n)e−jN2πk​n,k=0,1…N−1 好了，这就是离散傅里叶变换DFT了！ 接下来，来看DFT的两个性质： 第一， ，即 是所有元素的和，通常会比其他的元素大几个数量级。 第二， ， ， ，即第二个元素和最后一个元素共轭，同理有 等等。 如下图所示，DFT之后的N 个元素中，第一个为均值；之后的 N-1个元素，只有一半元素是独立的。 需要说明，这里 是一种相对频率，独立元素中，最小相对频域为1，最大相对频率为 /fracN2/frac{N}{2}/fracN2 。要想把 还原到真实的频率 ，只需要 ，将 映射到 即可， 为采样频率。 PS：简单说一下，根据香农采样定理，当采样频率为 时，能采到的最大信号频率为。因此，将相对频率 通过公式 ，得到的 就在区间内，也就是真实频率的区间了。 所以DFT公式为： PS：DFT公式的形式很多，有的是从时域到频域，有的是从空间域到频域，但是本质都是一样的，抓住离散性和有限性两个特点即可。离散性是指积分变成了累加，有限性是指积分/累加区间不是 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 了，而是一个有限区间了。 傅里叶变换（FT）的缺点 应该说明，虽然本小节的题目是FT的缺点，但是FT和DFT的本质是相同的。由于信号都是有限长度的、离散的，所以接下来进行的都是DFT，不过在某些部分为了方便理解，还是写了FT的公式。在看本文的时候，你不需要刻意区分这两个概念。 我们现在来看两个信号，如下图： y1=sin⁡(5t)∗(0&lt;t&lt;25)+sin⁡(t)∗(25&lt;t&lt;50)y 1=\\sin (5 t) *(0&lt;t&lt;25)+\\sin (t) *(25&lt;t&lt;50)y1=sin(5t)∗(0&lt;t&lt;25)+sin(t)∗(25&lt;t&lt;50) y2=sin⁡(t)∗(0&lt;t&lt;25)+sin⁡(5t)∗(25&lt;t&lt;50)y 2=\\sin (t) *(0&lt;t&lt;25)+\\sin (5 t) *(25&lt;t&lt;50)y2=sin(t)∗(0&lt;t&lt;25)+sin(5t)∗(25&lt;t&lt;50) 这两个信号都是由sin(t)和sin(5t)组成的，y1是先出现了sin(5t)，再出现了sin(t)，y2是先出现了sin(t)，再出现了sin(5t)。 我们对它们进行FT，看看他们包含怎么样的频率，如下图： y1,FT y2,FT Amazing！发现了什么？变换后的结果是一模一样的，都在w=1rad/s和w=5rad/s出现了峰值！这就可以说明FT的缺点了——FT只能提供频域信息，而完全丢失了时域信息！！！ 不管某一频率的信号出现的时间是早还是晚，FT都是将它一视同仁地乘上sin和cos(FT的变换基函数)，然后在整个时间区间加和。因此，它不能提供某一频率信号出现的时间。 比如，对于上面两个信号，FT只能告诉我们，它们都有1rad/s和5rad/s的频率，而不能告诉我们1rad/s和5rad/s分别出现在哪个时间段。 所以，怎么办呢？？？ 那就是把信号分成左右两半啊！左边进行一次FT，右边进行一次FT，很简单吧！好了，这就是短时傅里叶变换（STFT）的基本原理。 所以，接下来我们要正式开始步入——短时傅里叶变换（STFT），看看它是如何解决这个问题的。 短时傅里叶变换（STFT） 如上所述，我们将信号从中间截断，左边进行一次FT，右边进行一次FT，分别来看看。 y1左 y1右 y2左 y2右 可以看出，y1的左半部分是5rad/s，右半部分是1rad/s，y2恰好相反。这就说明，在y1中，(0, 25)的信号是5rad/s的频率，(25, 50)的信号是5rad/s的频率，y2恰好相反。这就是短时傅里叶变换的基本原理。 但是数学嘛，能用一个公式表达的，就别用一段话表达，截断、切开这些语句太不专业了。截断、切开的操作，更专业的讲叫作分窗，其实是可以通过数学上的处理变成DFT变换的基函数的一部分的。接下来我们来看一看。 首先，你可以想象一下，有一个窗子在这个信号上从左向右滑动，每次你都只能看到这个信号的一部分，所以我们把这个长度叫作窗长width。 现在我们来定义一个方窗函数ywindow=1∗(−width/2&lt;t&lt;width/2)y_{\\text {window}}=1 *(-\\text {width} / 2&lt;t&lt;\\text {width} / 2)ywindow​=1∗(−width/2&lt;t&lt;width/2) ，如下图，即是width = 10 的一个方窗函数： 定义了方窗函数之后，我们只需要对方窗函数进行平移，再与原信号作乘，就相当于原来的截断、切开的操作，因此这种操作更专业地叫作分窗。 那么，将方窗函数向右平移了 （s可能是sliding的意思吧），再与原信号相乘，由于方窗函数除了中心的width部分是1外，其他部分都是0，这就相当于提取出了原信号在处，宽度为width的部分，这个信号分窗这个操作就可以写成： 。 如下两图所示，将 与 相乘，就相当于取出来了 中的(20,30)中的一段。 那么，我们对原信号中被提取出来的这一部分进行FT，就可以写成： X(w,ts)=∫−∞+∞ywindow(t−ts)y(t)e−jw(t−ts)dtX\\left(w, t_{s}\\right)=\\int_{-\\infty}^{+\\infty} y_{w i n d o w}\\left(t-t_{s}\\right) y(t) e^{-j w\\left(t-t_{s}\\right)} d tX(w,ts​)=∫−∞+∞​ywindow​(t−ts​)y(t)e−jw(t−ts​)dt PS：这里之所以 要变成 ，是为了保证做FT的时候相乘的基函数具有统一性。 如此，变换后的代表原信号在处、宽度为width的部分的傅里叶变换，也就可以提取出来原信号在处、宽度为width的部分，包含各个频率部分的多少！带入不同的 ，也就是随着窗子的滑动，就可以知道不同的时间段内频率的成分。 我们采用width为10的方窗函数对y3=sin⁡(20t)∗(0&lt;t&lt;25)+sin⁡(t)∗(25&lt;t&lt;50)y 3=\\sin (20 t) *(0&lt;t&lt;25)+\\sin (t) *(25&lt;t&lt;50)y3=sin(20t)∗(0&lt;t&lt;25)+sin(t)∗(25&lt;t&lt;50)进行STFT，如下： 首先，方窗函数位于 处，与原始信号相乘，选择出(0,10)的信号。 对选择出来的信号进行FT。可以看到，当t=5s时，选择的时间区间为(0,10)，这一部分只包含了 的频率成分。 之后，方窗函数向右移动，与原始信号相乘，选择出不同时间区间的信号，进行FT。这里选择t=25s进行展示。 可以看到，当t=25s时，选择的时间区间为(20,30)，这一部分即包含了 的频率成分，也包含了 的频率成分。 重复以上过程，我们可以将方窗函数选择的不同时间区间的信号的FT的结果拼合起来，形成一张三维图。由此，我们即可知道，在 的时间区间内，信号具有怎么样的频率成分。 通过width = 10的方窗的STFT结果，我们可以知道，对于信号： ，在(0,10)、(10,20)时间区间内，具有20rad/s的频率成分；在(20,30)时间区间内，具有1rad/s和20rad/s的频率成分；在(30,40)、(40,50)时间区间内，具有1rad/s的频率成分。 最后，进行三点重要的讨论。 第一点，变换之后的 是一个三维函数，它有两个自变量， 和w。 指的是原信号在**处，**w上一篇文章我们已经讨论过了，就是频率。所以，STFT提取出来的信息就是：原信号在处、宽度为width的部分，包含的频率信息。 原则上讲，可以得到任一对应的频率成分，如下图。 但是 是连续的，并不意味着你知道了每个时刻的频率成分，你知道的还只是 这一段区间内的频率信息。所以一般不需要计算所有的 ，每隔width计算一次即可。 你或许会想，我**把width缩小一些，不就可以知道更精确的时间范围内的频率了吗？**是的，你的猜想很对！但是，**如此做也会带来一些频域分辨率的问题。**这一点涉及到一些时域分辨率和频域分辨率的知识，我们下一篇文章会着重讲。 本质变化: 第二点，方窗函数是可以包含入变换基函数内部的，这组成了新的基函数，同时反映了STFT的本质。 我们来看， 如果定义 ，那么 那么，STFT的公式： 就可以写成： 我们在上一篇文章里说过，变换就是将原信号乘上一个基函数，再积分的过程，那么，SDFT的基函数就是 ！ Amazing！所以，STFT的本质是什么呢？ **STFT的本质就是将FT的基函数 乘上一个方窗函数，形成了一个新的基函数 ！**前面说的分窗、截断之类的都是表象，STFT的本质是基函数的改变！ 那么，为什么STFT的基函数可以用于分窗，而FT的基函数不行呢？我们来看，我用正弦函数sin(5t)表示原来的基函数 ，那么FT基函数和STFT基函数如下： 原因就是：FT的基函数是在时域无限延伸的，因此，无论怎么平移，都是任分布在整个时域的，起不到分窗的作用。而STFT的基函数只在时域一段不为0，在剩下的时域都是0，因此，STFT的基函数的平移，就相当于自动加了窗子啦！ 紧支撑性: 这种只在时域一段不为0，在剩下的时域都是0的性质被称为“紧支撑性”（compactly supported），具有这种性质的函数，平移之后与一个信号相乘，就相当于分窗操作。这一点很重要，我们之后讲小波变换的基函数的时候还会讲。 第三点，我们前面对于分窗操作使用的函数一直称为“方窗函数”，这是一种最理想的窗函数。还有一些其他的窗函数，比如，汉宁窗、海明窗、高斯窗等。窗函数本质都是一个窗子而已，原理是一模一样的，上面所有的讨论也都成立，只是这些窗子会让信号稍稍变形一丢丢而已。你就想像方窗函数就是一面平面镜，其他的窗函数就是哈哈镜就行了。 总结: Q:为什么要用相对采样时间代替真实采样时间? A:原来做傅立叶变换，既需要知道真实采样时间，也需要知道采样数据，用相对采样时间替代真实采样时间之后，只需要知道采样数据。这极大地拓展了傅立叶变换的使用范围。比如，并不是所有傅立叶变换的对象都可以具有真实采样时间。一副图像也是可以傅立叶变换的，但是在图像里，并没有采样时间这个概念，只有0123456这些像素索引值，对图像做傅立叶变换，就是把索引值作为相对采样时间。 三.短时傅里叶变换（STFT）的缺点与连续小波变换（CWT） 三、短时傅里叶变换（STFT）的缺点与连续小波变换（CWT） 1、分辨率问题 首先，我们需要了解一下海德堡测不准原理： ， 为信号的时间不确定度， 为信号的频率不确定度。即，我们永远无法同时确定一个信号的确切时间和确切频率。 原因比较简单，频率其实就是时域周期性。如果我只给你一个数据点，问你这个数据点的频率是多少，这肯定是做不到的。要确定频率，就需要一个时域区间（包含几个时域周期）的信号。 时域区间越宽，信号的时间定位越不准，时间不确定度 越大，但是得到的频率越准，频率不确定度 越小；我们称之为：低的时域分辨率，高的频域分辨率。 时域区间越窄，信号的时间定位越准，时间不确定度 越小，但是得到的频率越不准，频率不确定度 越大；我们称之为：高的时域分辨率，低的频域分辨率。 如上两图，对于第一个图中 的信号，要确定频率，即使把 都拿来，还是不太准，因为只包含了一个周期；对于第二个图中 的信号，要确定频率，取个 就差不多了，因为已经包含了好几个周期了。 我们来总结一下。 对于低频信号，为了更好地确定频率，我们希望，时域区间宽一些，即时间不确定度 大一些，根据海德堡测不准原理，频率不确定度 自然小一些；即低频信号，我们希望：宽窗子，低的时域分辨率，高的频域分辨率。 对于高频信号，为了更好地在时域定位，我们希望，时域区间窄一些，即时间不确定度 小一些，根据海德堡测不准原理，频率不确定度 自然大一些；即高频信号，我们希望：窄窗子，高的时域分辨率，低的频域分辨率。 上图所示是我们希望的动态分辨率。图中每个小矩形的 轴方向的宽度是时间区间大小， 轴方向的宽度是频率区间大小。注意，每个小矩形的面积是相等的，这保证了时域分辨率乘上频域分辨率是定值，最大程度满足海德堡测不准原理。通过图可以看出，我们希望，对于低频信号：低的时域分辨率，高的频域分辨率；对于高频信号：高的时域分辨率，低的频域分辨率。 对于整体低频、局部高频的信号，这种动态调整分辨率的规则特别有用。在实际信号中，频率非常高的高频信号往往是一种噪声，只在局部出现，基本都满足整体低频、局部高频这一条件。 最后，我们再来看两张分辨率图来强化一下对于分辨率的理解。 上图是一张采集信号的分辨率图。每个小矩形的 轴方向的宽度是很小， 轴方向的宽度很大。也就是说，其时域分辨率很好，可以确切地确定每个信号采样点的时间，但是其频域分辨率很差，或者说完全不具有频域分辨率。 上图是一张傅里叶变换（FT）的分辨率图。每个小矩形的 轴方向的宽度是很大， 轴方向的宽度很小。也就是说，其频域分辨率很好，可以比较精确地确定信号中的频率成分，但是其时域分辨率很差，或者说完全丢失了时域分辨率。 傅里叶变换的这一特性，这一点我在上一篇文章里讲过，这也是我们转而使用短时傅里叶变换（STFT）的原因。 2、短时傅里叶变换（STFT）的缺点 我们来回忆一下STFT（详见：1335：从傅里叶变换进阶到小波变换（二）），STFT的窗长是固定的，即时域分辨率是固定的，根据海德堡测不准原理，其频域分辨率也是固定的。其分辨率图如下： 每个小矩形的 轴方向的宽度和 轴方向的宽度是恒定的！也就是说，不论高频低频，其时域和频域分辨率都不可调，这与我们之前讨论的“对于低频信号：低的时域分辨率，高的频域分辨率；对于高频信号：高的时域分辨率，低的频域分辨率”这一原则不符合。 这种不符合会带来什么后果呢？ 如图所示正弦信号，0250ms：300HZ，250500ms：200HZ ，500~750ms：100HZ ， 750~1000ms：50HZ。 ) 选择一个较窄的窗子 做STFT，结果如下： 当窗子较窄的时候，STFT的时域分辨率还行，但是频域分辨率不佳。 我们选择一个宽一些的窗子 做STFT，结果如下： 当窗子较宽的时候，STFT的频域分辨率很好，基本可以确定频率，但是时间轴上开始出现交叠了，也就是时域分辨率下降了。 我们选择一个更宽的窗子 做STFT，结果如下： 当窗子更宽的时候，STFT的频域分辨率非常好了，但是时域分辨率已经很差了，时间轴上出现了大规模的交叠现象。 我们来总结一下，对于STFT，如果窗子的宽度选择合适，是可以得到时域和频域分辨率都“还可以”的结果的（由于STFT的分辨率固定，只能说“还可以”，不能说“满意”，因为我们最想要的是动态分辨率）。但是，在变换之前，我们也不知道选择多宽的窗子是合适的。 这就是STFT的缺点：1、时间和频率分辨率都固定，不能随着频率的高低实现动态可调；2、选择一个合适的窗宽十分困难。 3、连续小波变换（CWT） 为了实现动态分辨率，我们引入了小波母函数。 需要说明，小波母函数并不是一个特定的函数，而是一种函数的集合，满足了一定条件的函数均可以作为小波母函数。小波母函数 需要满足的有： 条件1，紧支撑性： ，即仅在一小部分定义域里不为0，剩下部分均为0。这个性质带来的便利我们在前一篇文章讲过了，就是具有紧支撑性的基函数，在原信号的时间轴上平移，就相当于对于原信号就行了加窗操作。 条件2，波动性： ，即在所有定义域内积分值为0，这说明小波母函数是一个波。 条件3，容许条件： ，这个条件使变换可逆。其中， 是小波函数傅里叶变换的共轭。由3可知 ，也就是条件2。 条件4，正交性：这个条件也是为了使变换可逆。 PS：条件3、4的数学证明比较复杂，所以仅仅提了一下他们的作用，就是使得变换可逆。 上图就是一个小波母函数的例子，我们看到了： 1、紧支撑性：仅在一小部分定义域里不为0，剩下部分均为0；2、波动性： 在所有定义域内积分值为0。这两个条件是满足的。 小波母函数既然是一个波，那么就具有频率。根据我们第一篇文章讲的内容（1335：从傅里叶变换进阶到小波变换（一）），将小波母函数作为基函数，与采集到的信号相乘并积分，可以筛选出：信号在小波母函数非0部分，频率与小波母函数相近的成分。 需要说明，不同于FT的基函数 sin,cossin, cossin,cos，小波母函数不具有特定的某一频率，而是具有一个范围内的频率，因此筛选的是一定范围的频率，类似于一个带通滤波器。 接下来我们讲一讲，小波母函数的变换，变换公式如下： 一是平移，用上式中的 控制，改变，就相当于 在时间轴上不断的平移。 二是缩放，用上式中的 sss 控制。 变换后的函数 称为小波函数。 如下图，中间的图，sss 较小，相当于挤压；右侧的图， sss **较大，相当于拉伸。**变换公式前的是为了能量守恒，没有特别目的。 ![img](data:image/svg+xml;utf8,) 我们再来仔细观察一下上图。中间的图，sss 较小，相当于挤压，是不是频率提高了？右侧的图，sss **较大，相当于拉伸，是不是频率降低了？**咦？有点意思了吧？缩放就是改变频率！另外，一定记住，sss 越大，频率 fff越低， 是倒数关系。 我们再来更仔细地观察一下上图。回忆一下上一篇文章，具有紧支撑性的基函数，滑动相当于分窗。那么，这个窗长有多大呢？是不是就是基函数不为零的长度呢？那么，中间的图，sss 较小，相当于挤压，频率提高了，窗长是不是变小了？右侧的图，sss 较大，相当于拉伸，频率降低了，窗长是不是变大了？ 这不正是我们需要的**“低频，宽窗，差的时间分辨率，好的频域分辨率；高频，窄窗，好的时间分辨率，差的频域分辨率”吗？** ![img](data:image/svg+xml;utf8,) 和上图对一下，是不是一模一样了呢？这就是动态调分辨率，得来全不费工夫啊！ 接下来我们对一个信号就行一次连续小波变换（CWT）。下图中蓝色部分为小波函数（但原图没画成波的形式，只是表示小波函数的时间轴位置和不为0的部分的宽度），黄色部分为信号。 ![img](data:image/svg+xml;utf8,)图源：THE WAVELET TUTORIAL 如上图，选择较小的 对小波母函数进行缩放，此时小波函数频率较高，窗子较窄（小波函数不为0的部分窄），用来筛选高频部分。小波函数在时间轴上平移，每一次平移就先相乘，再积分，筛选出信号中与自己频率相近的部分。 此时，窗子较窄（小波函数不为0的部分窄），时间分辨率好，频率分辨率差。 ![img](data:image/svg+xml;utf8,)图源：THE WAVELET TUTORIAL 如上图，将sss 增大，对小波母函数进行缩放，此时小波函数频率降低，窗子变宽（小波函数不为0的部分变宽），用来筛选中频部分。小波函数在时间轴上平移，每一次平移就先相乘，再积分，筛选出信号中与自己频率相近的部分。 此时，窗子变宽了（小波函数不为0的部分变宽），时间分辨率变差，频率分辨率变好。 ![img](data:image/svg+xml;utf8,)图源：THE WAVELET TUTORIAL 如上图，将sss 进一步增大，对小波母函数进行缩放，此时小波函数频率再次降低，窗子更宽（小波函数不为0的部分更宽），用来筛选低频部分。小波函数在时间轴上平移，每一次平移就先相乘，再积分，筛选出信号中与自己频率相近的部分。 此时，窗子很宽（小波函数不为0的部分很宽），时间分辨率差，频率分辨率很好。 这就是连续小波变换CWT啦！ 将上述CWT的过程写成公式就是： 注意：上图中我们只列举了三种 sss （即三次缩放）和4种 （每种缩放对应四个时间位置，但是事实上， 是连续的，无穷多个的。 还是这个正弦信号，0250ms：300HZ，250500ms：200HZ ，500~750ms：100HZ ， 750~1000ms：50HZ。 ![img](data:image/svg+xml;utf8,) 其小波变换如下图所示（忽略图中坐标，原图如此，坐标不太对，还得映射一下，有空了我自己再画一张改一改）： ![img](data:image/svg+xml;utf8,)图源：THE WAVELET TUTORIAL 我们来看，绿色的小峰，对应小的 ，也就是高的频率。他们的时间分辨率很好， sss 的区间很小，根据 的倒数关系，对应的 的区间就很大，因此频率分辨率不好。 粉色的高峰，对应高的 ，也就是低的频率， sss 的区间很大，根据 的倒数关系，对应的 的区间就很小，因此频率分辨率很好，时间分辨率不好（有混叠)。 这也就再一次说明了CWT是动态分辨率的，这也是CWT相对于STFT的优势所在。 4、FT、STFT、CWT基函数对比 最后，再来看看，FT、STFT、CWT的基函数之间的不同，以便加深理解。 ![img](data:image/svg+xml;utf8,)图源：百度图片 FT的基函数，是分布在 的 sin,cossin, cossin,cos，不具有紧支撑性，只能筛选频率，使得FT完全丧失了时间信息，不具有时间分辨率。 STFT的基函数，是用窗函数截断的sin,cossin, cossin,cos （图中是被高斯窗截断的），具有了紧支撑性，时域平移等同于分窗，使得STFT既能筛选频率，也能筛选时间。但是STFT基函数是：先确定频率，再与窗函数相乘构成的。因此不同的频率，具有同样的时间和频率分辨率。另外，窗函数的长短也比较难以确定。 CWT的基函数，是小波函数，具有紧支撑性，时域平移等同于分窗，使得CWT既能筛选频率，也能筛选时间。小波函数在改变频率的时候，是通过**“缩放”**实现的，**这使得小波函数在改变频率的同时，改变了窗长。**因此不同的频率，具有不同的时间和频率分辨率，实现了分辨率动态可调。 最后，再说一下，有很多类型的小波母函数，比如haar小波，db系列小波，sym系列小波，coif系列小波等等等等。具体哪一个小波适应哪种情况，估计都能写一本书了，我也没深入钻研过。我在利用小波变换做肌电信号识别的时候就是读一读有关肌电信号识别的论文，看看别人试过哪些小波，是一种上手比较快的方法。 连续小波变换（CWT）的缺点与离散小波变换（DWT） 四、连续小波变换（CWT）的缺点与离散小波变换（DWT） 1、连续小波变换（CWT）的缺点 在上一篇文章（https://zhuanlan.zhihu.com/p/68323379）中我们讲解了 CWT可以实现动态分辨率的时频分析。CWT公式为：， 表示原始信号。你可能已经注意到了，这里的 是一个连续函数。 但是在第二篇文章（https://zhuanlan.zhihu.com/p/66246381）中我们讲过，实际采样信号往往具有两个特点：1、离散性，就是采集数据不连续，很容易理解，采集信号肯定是一个一个数据采集的；2、有限性，虽然理想的CWT是从 进行积分的，但是实际信号往往实在一个区间内 的。如下图所示。 所以，由于CWT需要一个连续信号，但是实际采样信号往往是离散的，我们无法直接对实际信号进行CWT。 或许你想，我们对实际采样信号进行插值连续化不就可以使得其连续了吗？ 是的。将实际采样信号插值连续化之后，我们——人，是可对它进行CWT的。 但是，我们也都知道，我们的帮手——计算机，是无法处理连续问题的。计算机只能处理离散问题。如果计算机要进行CWT，就意味着需要计算机做无穷次运算，计算机计算能力再强也是做不到的。 因此，为了使得计算机可以进行小波变换，我们需要引入离散小波变换（DWT）。 2、离散小波变换（DWT）的Wallet算法 DWT有很多种实现方式，我们在这里介绍Wallet算法，它是DWT的以一种经典的快速算法，也比较易懂。 我们首先来回顾一下上一篇文章讲过的动态分辨率图：高频部分，窄窗，高的时域分辨率，低的频域分辨率；低频部分，宽窗，低的时域分辨率，高的频域分辨率。 我们是利用小波母函数的挤压和拉伸来实现动态分辨率的： 当小波母函数被挤压的时候，频率就高，此时窗子窄，时域分辨率就好，根据海森堡测不准原理，频域分辨率就差； 当小波母函数被拉伸的时候，频率就低，此时窗子宽，时域分辨率就差，根据海森堡测不准原理，频域分辨率就好。 也就是说，我们控制的是不同频率对应的窗长（即时域分辨率），频率分辨率是通过海森堡测不准原理得到的，从而达到了动态分辨率。 那么，如果我们这次不控制窗长（即时域分辨率），转而控制频域分辨率，能否达到动态分辨率呢？ 答案是可以，这就是Wallet算法要解决的问题。 半子带滤波 我们知道，小波母函数本质上是一种带通滤波器。那么，假设可以通过小波母函数构造得到两个滤波器（至于怎么得到后续会介绍一下），包括一个高通滤波器和一个低通滤波器。 假设信号中的最高频率为 。那么，高通滤波器的作用就是得到 的部分，低通滤波器的作用就是得到 的部分。如下图所示： 我们将这个过程称为一次半子带滤波。 下采样与上采样 我们定义一个N倍下采样过程：将采样点N倍稀释。如下，就是一个2倍下采样过程，将采样点稀释2倍，即：每2个点采样数据点，就去除一个点。 N倍上采样过程：将采样点数量增加N倍。一般通过补0，或者插值的方法实现上采样。 离散小波分解 我们将一次半子带滤波+一次2倍下采样称为一层小波分解。如下图所示，图中的“箭头+2”表示一次2倍下采样。 假设原采样信号有 N 个点，信号最高频率为 （根据采样定律， 为采样频率的一半）。 经过一次高通滤波后，得到了 的部分，也是 N 个点，再经过一次2倍下采样，变成了 /fracN2/frac{N}{2}/fracN2 个点，我们将这/fracN2/frac{N}{2}/fracN2个点称为小波分解的高频系数（为什么叫作系数会在后面解释）。 经过一次低通滤波后，得到了 的部分，也是 N 个点，再经过一次2倍下采样，变成了 /fracN2/frac{N}{2}/fracN2 个点，我们将这/fracN2/frac{N}{2}/fracN2个点称为小波分解的低频系数。 也就是说，经过一层小波分解的信号，它的总长度加起来，还是 N ，是不变的。 现在，我们已经对 个点的原信号进行了第一层小波分解，得到了个点的高频系数和 个点的低频系数。 那么，我们保持 个点的高频系数不变，把 个点的低频系数作为信号，再进行一次小波分解。于是可以得到 个点的高频系数和 个点的低频系数。 这个过程被称为**第2层小波分解。**我们验证一下，经过2层小波分解的信号，它的总长度加起来，还是N ，是不变的。 依此类推，我们可以进行第三层，第四层小波分解，如图所示，直到第 层小波分解。在第 层小波分解，由于不断的下采样，低频系数和高频系数都只剩1个数了，小波分解无法进行下去了。 因此，小波分解的原始信号个数一般也需要是2的幂次。不过，在各种数学计算软件里，如果输入不是2的幂次，它会自动帮你补零到2的幂次。 我们取4层小波分解的结果来看一下。 在频域上，我们得到的是 ，，，，频域区间的系数。 在时域上，由于不断的2倍下采样，不断地丢弃数据，所以最后一层分解得到的，的时域分辨率最差，第一层分解保留的 时域分辨率最好。 那么，我们得到的分辨率就是这样子的： 这，不就是上一篇文章我们讲过的小波变换得到的动态分辨率吗？ 是的！这就是离散小波变换的快速算法之一——Wallet算法，通过不断的半子带滤波和下采样，控制不同频率成分的频域分辨率，进而达到动态分辨率。 最后，用一张比较经典的图，再来演示一下小波分解的过程。 为采样信号的最高频率。 代表高通滤波器， 代表低通滤波器，“箭头+2”表示2倍下采样。 图源：THE WAVELET TUTORIAL 再来举个例子形象地说明一下DWT的使用吧。 希望对于一个采样率为1000HZ的非稳态信号进行小波分解，下图为包含了256个采样点（即256ms）的原始采样信号。 1、首先，选择小波分解的层次。 可以根据对最低频率区间的要求来选择小波分解的层数。比如，我之前做项目的时候，采样率为1000HZ，那么信号的最高频率为 。我认为对于频率低于20HZ的成分，不需要再进一步区分了。因此，我选择５层小波分解，得到的最低一层的频率区间为 ，即为 ，这就够用了。 2、接下来，进行5层小波分解，得到小波分解系数。 如下图中，图1依然是原始采样信号 ，图2到图6为第1层到第5层小波分解的高频系数，图7为第5层小波分解的低频系数。如图所示，这些小波分解系数对应着不同的频率区间。 这就是DWT了，又称为小波分解。 这里提一下，小波分解是可逆的，即可以通过不同频率区间的小波分解系数进行重构，得到不同频率区间的重构信号。 3、所以，最后，进行小波重构，得到重构信号。 如下图中，图1依然是原始采样信号，图2到图7为通过不同频率区间的小波系数进行重构，得到的重构信号。将图2到图7加起来就可以得到重构原始信号，其和原始采样信号的误差称为重构误差。 3、Wallet算法背后的数学原理简介 这一部分主要是为了解答上一部分中的两个问题。 1、在上一部分，我们“假设可以通过小波母函数构造得到两个滤波器”，那么，怎么得到刚好可以具有以上特性的滤波器呢？ 2、在上一部分，我们将小波分解之后的结果称为“系数”，那么，为什么称为系数呢？ 先说一下，这部分我不是弄得非常懂，毕竟我只是个做工程的本科生，不是做数学的大佬。我凭自己的理解写一写大概，并推荐了两篇个人觉得讲得很好的回答。 我们用Haar小波做例子。 首先，介绍一个Haar尺度函数（又称为父小波），记为 ， ，如下图。 通过Haar尺度函数 ，可以得到Haar母小波 ， ，如下图。 现在，对于一个 N 点的原始采样信号，如果我们可以用 N 个做了时域平移的Haar尺度函数和 N 个做了时域平移的Haar母小波，来逼近原信号，就可以得到用 N 个Haar尺度函数的系数和 N 个Haar母小波的系数。 从直观上看，Haar尺度函数只是一条线，而Haar母小波则是一个波。所以，Haar母小波所能表示出来的信息应该更加细致。因此，N 个Haar母小波组合起来，应该代表的是原始信号的细节部分，也就是高频部分；N 个Haar尺度函数组合起来，代表的是原始信号的粗略部分，也就是低频部分。 我们将N 个Haar母小波的系数称为高频系数，将N 个Haar尺度函数的系数称为低频系数。 所以，DWT的滤波功能，是通过利用尺度函数和母小波重构信号，获取重构系数来获得的，这已经定性地解决了本部分提出的问题。 关于DWT背后的数学原理，推荐两篇回答： https://zhuanlan.zhihu.com/p/28575472 https://zhuanlan.zhihu.com/p/44217268 最后，由于DWT分解得到的是高频系数和低频系数，也就是用尺度函数以及母小波表示原信号的时候的一些重构系数，所以通过重构系数可以重构该信号，这被称为**小波分解的重构。**这也说明了小波分解是可逆的。 小波变换 小波变换的主旨：傅里叶变换将信号分解成为正弦波的叠加，傅里叶变换将信号分解成为正弦波的叠加。因此，如果要准确分析带突变的信号或图像，必须采用在时域和频域都含有定位信息的新方法 小波是一种快速衰减的、零均值的波形震荡,不像永远震荡的正弦波，小波持续的时间是有限的 中心频率: 尺度系数和频率之间是常系数倒数关系 较大的尺度系数会拉伸小波，对应的可表示低频 较小的尺度系数会压缩小波，对应的可表示高频 拉伸的小波可以捕捉信号中慢变的成分 而压缩的小波可以有效捕捉突变 连续小波、离散小波 他们的区别就是尺度缩放或者位移的方式不同","categories":[],"tags":[{"name":"信号处理","slug":"信号处理","permalink":"https://nymrli.top/tags/信号处理/"}]},{"title":"Vim记忆","slug":"Vim记忆","date":"2019-07-26T02:34:34.000Z","updated":"2019-09-15T08:07:31.012Z","comments":true,"path":"2019/07/26/Vim记忆/","link":"","permalink":"https://nymrli.top/2019/07/26/Vim记忆/","excerpt":"","text":"VIM记忆技巧 增 i(insert) I最前面insert a(append) A最后面append o(open a line)往下开启一行 O往上开启一行 删 d（delete） dw（delet word） dd（删除一行） x（删除一个字符） 拓展 diw(delete inner word) daw(delete around word) 改 c（change） ciw（change inner word） ci&quot;(change inner &quot;) ct）修改到右括号 查 fs(find s) 跳到本行第一个s字符 /往后查找,如/xxx 全文搜索xxx ;查找下一个 ?往前查找 移动 h← j↓ k↑ l→ w(word)往后跳一个单词 b(back word)往前返回一个单词 以空格为界区分单词 行间跳转 :18 跳转到第18行 18G 跳转到第18行 行内跳转: 0行首 $行尾 ctrl+o返回上一个位置 G文件结尾 gg文件开头 ctrl+f(forward)往后翻页 ctrl+u(upward)往前翻页 vim安装插件 修改配置 123456789101112131415161718set numberset history=1000set background=darksyntax onset autoindentset smartindentset tabstop=4set shiftwidth=4set showmatchset guioptions-=Tset vb t_vb=set rulerset nohlsset incsearchcall plug#begin() Plug &apos;flazz/vim-colorschemes&apos;call plug#end() 最后进入vim执行 输入:PluginInstall 便可自动安装 要卸载插件，先在.vimrc中注释或删除对应插件配置信息，然后在vim中执行 :PluginClean便可卸载对应插件 批量更新，只需执行:PluginUpdate","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"Docker使用","slug":"Docker使用","date":"2019-07-25T02:58:19.000Z","updated":"2022-03-29T06:19:27.377Z","comments":true,"path":"2019/07/25/Docker使用/","link":"","permalink":"https://nymrli.top/2019/07/25/Docker使用/","excerpt":"","text":"Docker学习 轻部署,省成本,易迁移 docker和虚拟机VM的区别 一、本质上的区别： VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用； Container(Docker容器)，在宿主机器、宿主机器操作系统上创建Docker引擎，在引擎的基础上再安装应用。 那么问题来了，没有操作系统，怎么运行程序？ 可以在Docker中创建一个ubuntu的镜像文件，这样就能将ubuntu系统集成到Docker中，运行的应用就都是ubuntu的应用。 二、使用上的区别： Size: 虚拟机ubuntu大小为:24.1GB Docker中镜像文件占用内存: 81.2MB Startup： Docker在宿主机器的操作系统上创建Docker引擎，直接在宿主主机的操作系统上调用硬件资源，而不是虚拟化操作系统和硬件资源，所以操作速度快。 这个其实安装一个ubuntu的虚拟机和拉取一个Docker的ubuntu镜像文件，运行一下就知道了，区别很明显，虚拟机开一下大概得2分多钟，而Docker只需要2秒钟。 宿主机、镜像与容器 宿主机器: 运行docker的机器 镜像:不可以修改内容 容器:可以修改能内容,相当于虚拟机,默认情况下彼此相互独立（容器之间可以通信） △.可以依据镜像来创建容器,也可以封装容器为一个镜像,即容器&lt;===&gt;镜像 Docker命令 搜索镜像: docker search python 下载镜像: docker pull NAME ▲注：latest是默认的标签，字面上理解为最新版本的镜像，实质上latest只是镜像的标签名称，跟具体某个版本号地位一样，有latest标签的镜像不一定是最新版本，镜像作者可以任意指定标签。 一般来说，我们会使用latest作为最新镜像的标识，这是约定。但，一旦该镜像被拉取到本地，版本号就已经确定，不会自动更新。（2021年10月10日 webapp链接mysql时镜像一直用的是latest版本的镜像，导致浪费了很长时间捣鼓）===&gt;所以在每次都要以最新镜像构建容器时都应该把原有的latest镜像删除后，再拉取标签为latest的最新镜像。 发布者如果docker build -t &lt;username&gt;/&lt;repositoryName&gt; .中不带tag标签，则默认为latest，但是需要注意的是，这样意味着latest其实也是发布者指定的，如果发布v5时将latest绑定为v5，但发布了新的v6后发布者并没有同步对当前的镜像发布latest，那么latest标签绑定的还是v5。这就于我们所理解的latest有偏差了，实际上也反应了latest其实也就是一个标签名字而已，他并没特殊的含义 通过Dockerfile构建新镜像： docker build . --build-arg FRP_VERSION=v0.37.0 -t frp -t, --tag=[]: 指定镜像tag标签 根据镜像创新容器: docker run -tid (--name xxx) IMAGE ID ti表示以交互的形式创建容器，d表示不进入 -d, --detach=false， 指定容器运行于前台还是后台，默认为false -i, --interactive=false， 打开STDIN，用于控制台交互 -t, --tty=false， 分配tty设备，该可以支持终端登录，默认为false -v, --volume=[host-src:]container-dest[:&lt;options&gt;] -p, --port=&lt;host_port&gt;:&lt;container_port&gt; 指定端口映射，格式为：主机(宿主)端口:容器端口 Flag参数查询： https://appapi.w3cschool.cn/doc_docker_1_11/docker_1_11-engine-reference-commandline-run-index.html?lang=en 启动容器: docker start CONTAINER_ID 进入容器： docker attach CONTAINER_ID （已被弃用） ==&gt; docker exec -ti CONTAINER_id /bin/bash 进入容器前得前运行容器 退出容器： ctrl + p + q , 以ctrl + z 、exit将会终止容器运行 在一个已运行的容器中执行命令: •docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 封装容器为镜像: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] 1234-a :提交的镜像作者；-c :使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停。 容器通信-创建子节点链接中心节点: docker run -tid (--name xxx) (--link CONTAINER_NAMES) IMAGE ID 查看容器ip: cat /ect/hosts 123456789root@b68943564e76:/# cat /etc/hosts 127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.2 test 4e02c004539e172.17.0.3 b68943564e76 ▲初次使用, ifconfig使用无效,ping也无效,原因如下 我创建的容器是拉取的Base镜像，而因为用Docker拉取的Base镜像如Centos和Ubuntu的话都是最简版本，不包含Ping工具，而对Docker进行Docker network和Docker链接操作时往往要用到Ping工具测试两个容器间的网络，此时就要用到Ping工具了，下面是Ubuntu下安装Ping工具的命令：apt-get update &amp;&amp; apt-get install iputils-ping、安装ifconfig工具:apt install net-tools 从容器里面拷文件到宿主机 docker cp 容器名：要拷贝的文件在容器里面的路径 要拷贝到宿主机的相应路径 宿主机上执行:$ docker cp testtomcat：/usr/local/tomcat/webapps/test/js/test.js /opt 从宿主机拷文件到docker容器里面 docker cp 要拷贝的文件路径 容器名：要拷贝到容器里面对应的路径 宿主机上执行$ docker cp requirements.txt apptest:/app ▲注:容器NAME可以通过docker ps命令查看 Dockerfile指令 Dockerfile文件D一定要大写 $ docker build -t=&quot;dormanctpress/df_test2&quot; . .为Dockerfile的路径 1.FROM &lt;image&gt;:&lt;tag&gt;: 指定拉取base镜像 2.MAINTAINER： 作者信息 3.RUN 镜像构建中运行的命令，主要用于安装库 4.EXPOSE 如果是端口的话，只是声明会使用xx端口,但是实际使用时还是需要run -p xx $ docker build -t=&quot;dormanctpress/df_test2&quot; . 设置环境变量 CMD 在容器运行时运行的默认命令(命令行中添加的命令可以代替掉Dokcerfile中写的CMD指令) 每个Dockerfile只能够包含一个CMD，多个CMD 只有最后一个能有效 定义的三种方式 CMD &lt;cmd&gt;这个会当做/bin/sh-c“cmd”来执行 CMD[“executable&quot;，“arg1”，“arg2”] 一定要双引号 CMD[“arg1&quot;，“arg2”]，这个时候CMD作为ENTRYPOINT的参数 ENTRYPOINT 每个Dockerfile只能够包含一个ENTRYPOINI，多个ENTRYPOINT只有最后一个能有效 不会像CMD命令一样被覆盖,除非使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 - 当定义了ENTRYPOINT后,CMD将被作为参数使用。如果定义了CMD，那么`docker run -t test/osf2 xxxx`后面即xxxx的内容全会被当做参数传递ENTRYPOINT组合使用ENTRYPOINT和CMD: ENTRYPOINT指定命令,CMD指定默认参数7. ADD&amp;COPY共同点- ADD&amp;COPY的源必须在context路径下- 当在源代码构建的方式下，可以通过ADD和COPY的方式，把Host上的文件或者目录复制到Image不同点：ADD- 包含类似tar**解压**的功能- 当遇到`&lt;scr&gt;`参数为URL时候，可以通过URL**下载**文件并且复制到`&lt;dest&gt;`，这个在任何build的方式下都可以WorkCOPY- COPY是ADD的一种简化版本，目的在于满足大多数人“复制文件到容器”的需求。- Docker 团队的建议是在大多数情况下使用COPY。拷贝文件的原则：使用COPY（除非你明确你需要ADD）9. VOLUME[&apos;/data&apos;] - 设置数据卷，暴露给外部使用者映射10. WORKDIR /path/to/workdir - 一般使用绝对路径11. EXPOSE - 暴露端口给外部使用者映射12. `ENV &lt;key&gt; &lt;value&gt;` - 用来设置环境变量，后续的RUN可以使用它所创建的环境变量。 - 当创建基于该镜像的Container的时候，会自动拥有设置的环境变量13. USER daemon- 指定UID或者username，来决定运行RUN指令的用户- 如果不指定,则默认root13. ONBUILD - 触发器14. ARG - `ARG` 指令定义了一个变量，用户可以在构建时使用 `docker build` 命令使用`--build-arg &lt;varname&gt;=&lt;value&gt;` 标志将其传递给构建器。如果用户指定了未在 Dockerfile 中定义的构建参数，则构建会输出警告。### dockerfile构建过程1. 从基础镜像运行一个容器2. 执行一条指令，对容器做出修改3. 执行类似docker commit的操作，提交一个新的镜像层4. 再基于刚提交的镜像运行一个新容器5. 执行Dockerfile中的下一条指令，直至所有指令执行完毕### 使用中间层镜像进行调试查找错误### Dockerfile 镜像缓存构建缓存：将之前的镜像缓存不使用缓存`docker build --no-cache`### 查看镜像构建的过程查看构建过程:`docker history xxx/yyy`## 数据卷`sudo docker run -v ~/container_data:/data -it ubuntu /bin/bash`参数说明:使用-v选项,第一个参数为宿主机目录,:后的目录为在容器中使用的目录(挂载);ubuntu为镜像### 查看容器是否挂载了数据卷`docker inspect CONTAINER_ID`可以查看容器是否挂载了数据卷### 给数据卷增加权限`sudo docker run -v ~/datavolume:/data:ro -it ubuntu/bin/bash`ro是read-only## 数据卷容器&gt; 命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器挂载数据卷容器的方法`docker run--volumes-from [CONTAINER NAME]`## MySQL通信```shell&gt;&gt;&gt; can&apos;t connect to MySQL server on &apos;172.17.0.8&apos;(111)$ vim /etc/mvsal/my.cnf # 将bind-address=127.0.0.1注释掉&gt;&gt;&gt; Host &apos;2eaf92ef2ff6&apos;is not allowed to connect to this MySQL server$ create user &quot;weiwei&quot;@&quot;%&quot;identified by&quot;weijc7789&quot;# 创建用户$ grant create, select, update, delete, insert on *.* to weiwei;# 增添权限$ mysq1-h 172.17.0.8-u weiwei-p# 链接 redis通信 1234567$ redis-cli -h 172.17.0.8&gt;&gt;&gt; Could not connect to Redis at 172.17.0.8:6379:Connection refused$ vim /etc/redis /redis.conf# 将bind-address=127.0.0.1注释掉# 如果修改后/ect/init.d/redis-server restart后还是链接不了,重启进入容器$ redis-cli-h 172.17.0.8-p 6379 一条命令实现停用并删除容器： 1docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq) 一条命令删除所有镜像： 1docker rmi `docker images -q` 一条命令删除创建失败的镜像: docker images | sed -n '2p' | awk '{print$3}' | xargs docker rmi https://www.jianshu.com/p/658911a8cff3) 坑点记录 docker容器启动后马上退出解决方案 dokcerfile中的最后一个命令不能在后台执行,不然会启动后马上退出 原因 Docker容器同时只能管理一个进程，如果这个进程退出那么容器也就退出了，但这不表示容器只能运行一个进程(其他进程可在后台运行)，但是要使容器不退出必须有一个前台执行的进程。 解决方法： 脚本中最后一个进程一定要用前台运行方式即在进程最后不加&amp;(&amp;表示后台运行)，否则容器会退出。 如何正确的使用docker attach Q:由于执行着uwsgi --ini uwsig.ini命令,用户就无法直接进入到容器中去，docker attach CONTAINER_id 就会一直卡着。 A: attach早已过时了，可用: docker exec -it containerID /bin/bash，一开始使用的是/bin/sh然后还是一直卡住.但是/bin/bash是可以的 附Uuntu版本代号: 版本号 代号 发布时间 18.04 Bionic Beaver（仿生海狸） 即将发布2018年4月(LTS) 17.10 Artful Aardvark(机灵的土豚) 2017年10月 16.04 LTS Xenial Xerus 好客的非洲地松鼠 即将发布 2016/4 15.10 Wily Werewolf 狡诈的狼人 2015/10/22 15.04 Vivid Vervet 活泼的小猴 2015/04/23 14.10 Utopic Unicorn 乌托邦独角兽 2014/10/23 14.04 LTS Trusty Tahr 值得信赖的塔尔羊 2014/04/18 13.10 Saucy Salamander 活泼的蝾螈 2013/10/17 13.04 Raring Ringtail 铆劲浣熊 2013/04/25 12.10 Quantal Quetzal 缤纷的绿咬鹃 2012/10/18 12.04 LTS Precise Pangolin 精准的穿山甲 2012/04/26 11.10 Oneiric Ocelot 有梦的虎猫 2011/10/13 11.04 Unity成为默认桌面环境 Natty Narwhal 敏捷的独角鲸 2011/04/28 10.10 Maverick Meerkat 标新立异的的狐獴 2010/10/10 10.04 LTS Lucid Lynx 清醒的猞猁 2010/04/29 9.10 Karmic Koala 幸运的无尾熊 2009/10/29 9.04 Jaunty Jackalope 活泼的兔子 2009/04/23 8.10 Intrepid Ibex 无畏的高地山羊 2008/10/30 8.06 官方查不到此版本发布信息 Haughty Husky 骄傲的哈士奇 2008/06/07 8.04 LTS Hardy Heron 坚强的苍鹭 2008/04/24 7.10 Gutsy Gibbon 勇敢的长臂猿 2007/10/18 7.04 Feisty Fawn 烦躁不安的小鹿 2007/04/19 6.10 Edgy Eft 尖利的小蜥蜴 2006/10/26 6.06 LTS Dapper Drake 整洁的公鸭 2006/06/01 5.10 Breezy Badger 活泼的獾 2005/10/13 5.04 Hoary Hedgehog 白发得刺猬 2005/04/08 **4.10 **初始发布版本 Warty Warthog 多疣的疣猪 2004/10/20 docker stop containerID，以后再重新启动时报错 1Error response from daemon: driver failed programming external connectivity on endpoint app (3c0c01ac6b42b7a420644fc2b4debfbbcc0e1d2e74e6294155c28aca82f794c4): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 12345 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name. A: 重启docker即可：systemctl restart docker 再开启你的容器： docker run xxxx或docker start xxx 查看docker容器的运行日志 docker logs containerID docker端口映射到宿主机后外网仍无法访问容器的web A： 1234567891011121314# 解决办法：$ sudo vi /etc/sysctl.conf或者$ sudo vi /usr/lib/sysctl.d/00-system.conf# 添加如下代码：net.ipv4.ip_forward=1重启network服务$ sudo systemctl restart network查看是否修改成功$ sudo sysctl net.ipv4.ip_forward#如果返回为“net.ipv4.ip_forward = 1”则表示成功了 附录 安装docker 由于ubuntu维护的docker版本比较老，所以建议使用docker自己维护的版本 法一： 较为麻烦 123456789sudo apt-get updatesudo apt-get install -y apt-transport-httpsecho deb https://get.docker.com/ubuntu docker main&gt;/etc/apt/sources.list.d/docker.list# 添加仓库的keysudo apt-key adv--keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9#安装sudo apt-get updatesudo apt-get install -y lxc-docker 法二： docker简易安装方法-&gt;脚本 123456# 如果没有安装curl，先安装curl$ sudo apt-get install -y curl# 淘汰!$ curl -sSL https://get.docker.com/ubuntu/ | sudo sh# 推荐用wget ==&gt; 2021年10月25日 淘汰!$ wget -qO- https://get.docker.com/ | sh 法三：https://docs.docker.com/engine/install/ubuntu/ 推荐：2021年10月25日 Docker容器互访——创建bridge网络尝试 创建容器 123docker run -itd --name network_test_mysql -p 11111:3306 --network testnet --network-alias mysqlhost -e MYSQL_ROOT_PASSWORD=\"aaa123123\" daocloud.io/library/mysql:5.7.5-m15docker run -it --name network_test_app6 --network testnet --network-alias mysql1 -e MYSQL_ROOT_PASSWORD=\"123456\" daocloud.io/library/mysql:5.7.5-m15 在第二个容器中测试是否能连接到第一个容器的mysql服务 12345678910111213141516mysql -uroot -p123456# ✌: 会默认进入localhost:3306 mysql -hmysql -uroot -p123456# ERROR 2005 (HY000): Unknown MySQL server host 'mysql' (110)mysql -hmysqlhost -uroot -p123456# ERROR 1045 (28000): Access denied for user 'root'@'network_test_app6.testnet' (using password: YES)# ▲通过网络别名进入mysql -hmysqlhost -uroot -paaa123123# ✌: 会进入第一个容器的mysql服务, 且访问的直接是容器中的3306端口, 所以可以直接进入(区分宿主机暴露的11111端口)# 通过容器名进入mysql -hnetwork_test_mysql -uroot -p123456# 注: 暴露的11111是非容器间访问时暴露的端口，如我的PC上想要连接这个容器的话，需要如下连接mysql -h49.235.118.244 -uroot -paaa123123 -P11111# ✌ docker网络官方文档：https://docs.docker.com/network/network-tutorial-standalone/——在用户定义的网络上，如alpine-net，容器不仅可以通过 IP 地址进行通信，还可以将容器名称解析为 IP 地址。此功能称为自动服务发现。让我们连接alpine1并测试一下。alpine1应该能够解析 alpine2和alpine4（和alpine1，本身）到 IP 地址。 上传自己的镜像 先编写自己的镜像文件：Dockerfile，可以如下 1234567FROM python:3.7.4-alpine# MAINTAINER Mrli 1063052964@qq.comLABEL maintainer=\"Mrli 1063052964@qq.com\"ADD ./app /appWORKDIR /appRUN pip install -r requirements.txtENTRYPOINT [ \"python\", \"test.py\" ] 然后运行docker build -t userName/repositoryName:tagName构建镜像，userName/repositoryName指定镜像名，tagName指定版本 登陆docker镜像仓库：dockerhub或者ali的， dockerhub:docker login ali:docker login --username=南邮果粒橙 registry.cn-hangzhou.aliyuncs.com 推送镜像到镜像仓库 dockerhub: docker push nymrli/python:v1，由于dockerhub我的用户名是nymrli，加上创建的仓库名叫python，所以dockerhub给我的链接nymrli/python（仓库名可能重名，但加上用户名的选项后只要用户名不重名，那么这个镜像名就不会重名），push的参数为也为这个 Ali: 1234$ docker login --username=南邮果粒橙 registry.cn-hangzhou.aliyuncs.com$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/mrli_docker_images/backend:[镜像版本号]# mrli_docker_images/backend为&lt;命名空间&gt;/&lt;仓库名&gt;$ docker push registry.cn-hangzhou.aliyuncs.com/mrli_docker_images/backend:[镜像版本号] 注： FROM的镜像名是python:&lt;版本号&gt;-&lt;镜像特性名&gt; 镜像最初的工作路径为/根目录，根目录下任何东西都没有，需要自己拷贝过去 Travis+Docker[+阿里云容器镜像、dockerhub] travis主要是关注在CI持续集成上，同时能完成持续交付(持续集成的基础上，增加打包构建形成产物)的工作。因此本次就以travis+docker来完成这么一个持续集成与持续交付的步骤： 步骤如下： 去travis官网绑定travis和github Dockerhub创建镜像仓库 or 阿里云开通容器镜像服务 项目中添加.travis.yml和Dockerfile文件 1234567FROM python:3.9.1-alpineMAINTAINER Mrli 1063052964qq.comRUN tar -zcf app.tar.gz .ADD app.tar.gz /appWORKDIR /appRUN pip install -r local_requiements.txtENTRYPOINT python app/main.py 123456789101112131415161718192021222324252627language: python# sudo: enabled or requiredpython: - \"3.9.1\"branches: only: - masterinstall: - pip install -r local_requirements.txtbefore_script: - flake8 app tests - docker login -u $DOCKERHUB_USERNAME -p $DOCKERHUB_PASSWORD # dockerfile中需要拉取 python-3.9.1:alipine的镜像, 所以需要先docker loginscript: - python app/main.py - docker build -t nymrli/python:v2 .after_success: - docker login -u $username -p $password # 这里我们使用环境变量来控制，避免写死。环境变量，在travis的后台settings里面添加 - docker push - echo \"success\"services: # 需要提供docker才能在里面使用docker命令 - docker git push提交代码，travis会侦听github仓库变化触发githook从而执行任务 登录要运行app的服务器，docker-compose up将镜像启动 1234567891011121314151617181920212223242526272829303132333435version: '2'services: mysql: container_name: mysql1 image: mysql:5.7 environment: MYSQL_ROOT_PASSWORD: 数据库密码 ports: - \"3306:3306\" volumes: - /usr/local/docker/mysql/data:/var/lib/mysql - /usr/local/docker/mysql/conf:/etc/mysql - /usr/local/docker/mysql/logs:/var/log/mysql web: container_name: jafir_nginx1 image: registry.cn-hangzhou.aliyuncs.com/jafir_docker_images/web:latest ports: - 8080:80 restart: always depends_on: - java volumes: - /mydockerdata/nginx/etc/nginx.conf:/etc/nginx/nginx.conf - /mydockerdata/nginx/log/:/var/log/nginx java: container_name: jafir_gps1 image: registry.cn-hangzhou.aliyuncs.com/jafir_docker_images/jafir-images:latest restart: always depends_on: - mysql ports: - 9090:9090 volumes: - /mydockerdata/java/gps/upload:/Users/jafir/Downloads/upload - /mydockerdata/arme/out/*.nofoo.cn/*.nofoo.cn.pfx:/Users/jafir/Downloads/upload/cert/*.nofoo.cn.pfx 注：如果需要travis的构建过程中在服务器执行一些命令（如将代码部署发到自己的服务器上），还需要配置生成公钥和私匙，参看： https://juejin.cn/post/6931980888267816974 https://www.jianshu.com/p/ce648e120727 docker-compose使用[转] docker-compose常见命令 ps：列出所有运行容器 1docker-compose ps logs：查看服务日志输出 1docker-compose logs port：打印绑定的公共端口，下面命令可以输出 eureka 服务 8761 端口所绑定的公共端口 1docker-compose port eureka 8761 build：构建或者重新构建服务 1docker-compose build start：启动指定服务已存在的容器 1docker-compose start eureka stop：停止已运行的服务的容器 1docker-compose stop eureka rm：删除指定服务的容器 1docker-compose rm eureka up：构建、启动容器 1docker-compose up kill：通过发送 SIGKILL 信号来停止指定服务的容器 1docker-compose kill eureka pull：下载服务镜像 scale：设置指定服务运气容器的个数，以 service=num 形式指定 1docker-compose scale user=3 movie=3 run：在一个服务上执行一个命令 1docker-compose run web bash docker-compose.yml 字段含义 version：指定 docker-compose.yml 文件的写法格式 services：多个容器集合 build：配置构建时，Compose 会利用它自动构建镜像，该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数 1234567build: ./dir---------------build: context: ./dir dockerfile: Dockerfile args: buildno: 1 command：覆盖容器启动后默认执行的命令 123command: bundle exec thin -p 3000----------------------------------command: [bundle,exec,thin,-p,3000] dns：配置 dns 服务器，可以是一个值或列表 12345dns: 8.8.8.8------------dns: - 8.8.8.8 - 9.9.9.9 dns_search：配置 DNS 搜索域，可以是一个值或列表 12345dns_search: example.com------------------------dns_search: - dc1.example.com - dc2.example.com environment：环境变量配置，可以用数组或字典两种方式 1234567environment: RACK_ENV: development SHOW: &apos;ture&apos;-------------------------environment: - RACK_ENV=development - SHOW=ture env_file：从文件中获取环境变量，可以指定一个文件路径或路径列表，其优先级低于 environment 指定的环境变量 1234env_file: .env---------------env_file: - ./common.env expose：暴露端口，只将端口暴露给连接的服务，而不暴露给主机 123expose: - &quot;3000&quot; - &quot;8000&quot; image：指定服务所使用的镜像 1image: java network_mode：设置网络模式 12345network_mode: &quot;bridge&quot;network_mode: &quot;host&quot;network_mode: &quot;none&quot;network_mode: &quot;service:[service name]&quot;network_mode: &quot;container:[container name/id]&quot; ports：对外暴露的端口定义，和 expose 对应 123ports: # 暴露端口信息 - &quot;宿主机端口:容器暴露端口&quot;- &quot;8763:8763&quot;- &quot;8763:8763&quot; links：将指定容器连接到当前连接，可以设置别名，避免ip方式导致的容器重启动态改变的无法连接情况 12links: # 指定服务名称:别名 - docker-compose-eureka-server:compose-eureka volumes：卷挂载路径 123volumes: - /lib - /var logs：日志输出信息 1234--no-color 单色输出，不显示其他颜.-f, --follow 跟踪日志输出，就是可以实时查看日志-t, --timestamps 显示时间戳--tail 从日志的结尾显示，--tail=200 更新容器 当服务的配置发生更改时，可使用 docker-compose up 命令更新配置 此时，Compose 会删除旧容器并创建新容器，新容器会以不同的 IP 地址加入网络，名称保持不变，任何指向旧容起的连接都会被关闭，重新找到新容器并连接上去 links 服务之间可以使用服务名称相互访问，links 允许定义一个别名，从而使用该别名访问其它服务 12345678version: &apos;2&apos;services: web: build: . links: - &quot;db:database&quot; db: image: postgres 这样 Web 服务就可以使用 db 或 database 作为 hostname 访问 db 服务了 Dockerfile RUN，CMD，ENTRYPOINT命令区别 RUN命令执行命令并创建新的镜像层，通常用于安装软件包 CMD命令设置容器启动后默认执行的命令及其参数，但CMD设置的命令能够被docker run命令后面的命令行参数替换 ENTRYPOINT配置容器启动时的执行命令（不会被忽略，一定会被执行，即使运行 docker run时指定了其他命令） Shell格式和Exec格式运行命令 我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式： Shell格式：&lt;instruction&gt; &lt;command&gt;。例如：apt-get install python3 多条命令用&amp;&amp;链接 Exec格式：&lt;instruction&gt; [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;, ...]。例如： [&quot;apt-get&quot;, &quot;install&quot;, &quot;python3&quot;] CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。 总结 使用 RUN 指令安装应用和软件包，构建镜像。 如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。 如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。 Docker 运行python flask的web程序 1创建镜像 1.1 ubuntu16.04+python3.6 18.04卡在了PPA环节,并且git安装也没安装上,后来使用了dockerHub上搜素到的github仓库中的16.04 Xenial就解决了。 注：镜像TAG版本需要到dockerHub上才能查看，最初下载成18.04就是因为这个原因被坑了 18.04PPA问题: aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Ubuntu/bionic意思是18.04该PPA没有资源.bionic是版本代号,如16.04的 Xenial ⑴使用下载好的Xenial的Dockerfile进行创建镜像docker run 1604ubuntu . 为了使用国内源用阿里云，先编辑一个sources.list，放在dokcerfile同目录下，作为docker创建镜像时的上下文。 1234567891011121314151617deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse ⑵根据官方的镜像来编写自己的Dockerfile创建具有工具的Ubuntu1604 涉及交互式选择项（如下），docker build的时候会报错。设置 DEBIAN_FRONTEND=noninteractive 1234567891011121314151617181920212223242526272829303132333435FROM 1604ubuntuMAINTAINER mrli#用ubuntu国内源替换默认源RUN rm /etc/apt/sources.listCOPY sources.list /etc/apt/sources.list#安装python3.6必要的包。源镜像太精简了，ip ifconfig之类的都没有。后续安装python pip也需要一些。但是build_essential似乎不必须，先去了。如果后面安装numpy之类需要gcc了，再加上RUN apt update#RUN apt upgradeRUN apt install -y apt-utils apt-transport-https vim iproute2 net-tools ca-certificates curl build-essential wget python-software-properties software-properties-common psmisc#安装python3.6 来自第三方RUN add-apt-repository ppa:jonathonf/python-3.6RUN apt updateRUN apt install -y python3.6RUN apt install -y python3.6-devRUN apt install -y python3.6-venv#为3.6安装pipRUN wget https://bootstrap.pypa.io/get-pip.pyRUN python3.6 get-pip.py#设置默认python为python3RUN update-alternatives --install /usr/bin/python python /usr/bin/python2 100RUN update-alternatives --install /usr/bin/python python /usr/bin/python3 150#和自带的3.5共存,设置python3默认为3.6#RUN update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.5 1RUN update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.6 2# 更新配置RUN update-alternatives --config python3#print()时在控制台正常显示中文ENV PYTHONIOENCODING=utf-8 在dockerfile所在路径下执行，建立image 1docker build -t uos:1604 . 因为开头几步用了国内源，所以非常快。 123# 设置apk源RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories# 设置时区 1.2 开发环境 再建一个dockerfile，开头使用刚才建立的镜像uos1604 123456789101112131415161718192021222324252627FROM uos:1604MAINTAINER mrli#代码复制过来后的路径RUN mkdir /app# 指定容器启动时执行的命令都在app目录下执行WORKDIR /app# 将本地app目录下的内容拷贝到容器的app目录下COPY ./app/ /app/# 安装nginxRUN apt -y install nginx mysql-server RUN /etc/init.d/nginx start# 替换nginx的配置RUN rm /etc/nginx/sites-enabled/defaultRUN cp nginx.conf /etc/nginx/sites-enabled/nginx.confRUN pip3 install uwsgi#安装需要的python库# 启动nginx和uwsgi#ENTRYPOINT pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple some-package --no-cache-dir &amp;&amp; service nginx restart &amp;&amp; uwsgi --ini uwsgi.ini# 为了保证能之后进入所以最后一个命令为/bin/shENTRYPOINT pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple some-package --no-cache-dir &amp;&amp; service nginx restart &amp;&amp; uwsgi --ini uwsgi.ini &amp; &amp;&amp; /bin/sh 创建uflask镜像:docker build -t uflask . 根据镜像创建运行容器:docker run -tid -p 12345:80 flaskdemo IMAGE_ID 此时就可以通过VPS的IP地址:宿主机端口访问这个应用程序 查看日志:docker logs 应用名(NAMES)如docker logs flaskdemo 关于mysql的建议 mysql建议作为单独容器来跑数据库,然后远程连接数据库.或是使用数据卷 123456# 搜索# docker search mysql# 拉取# docker pull mysql:5.7#运行# docker run --name mysql5.7 -e MYSQL_ROOT_PASSWORD=123456 -p 3307:3306 -d mysql:5.7 2启动容器(转) Docker 一种开源容器应用，供开发者打包自己的开发环境，可以任意移植 docker-compose 一种管理多个Docker容器的工具，可以简化我们启动容器的各种命令 2.1手动敲docker命令 先试试用docker命令行启动容器： 1docker run --name quotation_api -itd -p 5000:5000 -v /home/quotation:/code quotation_dev:latest 用到的参数分别是 –name为容器命名； -itd 输入输出终端，后台运行 -p host端口:容器端口 将宿主机5000端口的请求转发到容器5000端口,用5000是flask默认 -v host路径:容器内路径(挂载数据卷) quotation_dev:latest 最后是使用的镜像名（前面刚用dockerfile build出来的） 然后进入容器 1docker attach quotation_api 用python3 main.py启动flask，OK。 这样flask运行在docker里了。 在host改代码，可以看见docker的控制台在更新，和在host一样了。(使用数据卷) 2.2使用dock-compose 如果没有安装先进行安装apt install docker-compose dock-compose用来管理多个container的运行，特别适合1个host上跑多个container的情况。 得天独厚，docker官网上dock-compose的gettingstarted文档就是flask的(说明flask+docker代表了先进生产力的前进方向O Yeah！),看完了基本就能用了。 dock-compose采用yaml作为配置文件。查了一下，yaml参考了xml和json，以及python的语法，采用了python之缩进，无XML之标记，无json之括号，无字符串之引号。特别适合作为配置文件用。 建立docker-compose.yaml文件(无镜像,但有dockerfile)： 123456version: '2' # 表示该 Docker-Compose 文件使用的是 Version 2 fileservices: docker-demo: # 指定服务名称 build: . # 指定 Dockerfile 所在路径 ports: # 指定端口映射 - \"9000:8761\" 建立docker-compose.yaml文件(已有镜像)： 12345678910version: \"3\"services: quotation_api: # 指定服务名称 image: quotation_dev:latest # 指定镜像 volumes: # 选择数据卷 - /home/quotation:/code ports: # 端口映射 - \"5000:5000\" command: python3 main.py # 执行命令 基本对应手动敲的docker命令，最后还省了敲python3 main.py。 当然如果是部署，这句可以用CMD 写进Dockfile。但是开发过程，文件名之类的会改变，比如最终部署运行用可能是gunicorn+wsgi.py，所以还是写在dockerfile外面比较方便 运行，在控制台执行：docker-compose up、docker-compose up -d // 后台启动并运行容器 docker-compose更多介绍 关于Dockerfile中docker-entrypoint.sh 文件的用处 很多著名库的 Dockerfile 文件中，通常都是 ENTRYPOINT 字段会是这样：ENTRYPOINT [&quot;docker-entrypoint.sh] https://blog.csdn.net/u013272009/article/details/84073136: 在启动容器时，可以通过docker-entrypoint.sh的 shell 脚本执行些预处理逻辑(如运行多个脚本)， 然后再exec $@把启动容器入口正式交给使用者，即，需要容器启动预处理的，都可以使用 docker-entrypoint.sh 机制 ★===&gt; 采坑记录：原因是dockerfile中虽然RUN命令可以有多个，但那个主要是在构建过程中的，因此如果构建完成后容器运行时需要执行脚本，RUN命令是不行，只能用ENTRYPOINT，但ENTRYPOINT命令为了简洁命令看来，就只执行docker-entrypoint.sh ，然后将要运行脚本的命令写在docker-entrypoint.sh 里就行了 shell脚本变量宏： $@所有参数列表。如$@用「&quot;」括起来的情况、以&quot;$1&quot;&quot;$2&quot;….&quot;$n&quot;的形式输出所有参数。 $ $#: 添加到shell的参数个数 $0: shell本身的文件名 用户权限 在执行mvn package docker:build出现com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: java.io.IOException: Permission denied需要查看下docker是否安装正常，docker是否打开，当前用户是否具有执行docker命令的权限（我的个人账号mrli就没有权限，需要将其加入docker用户组，否则得加sudo） 123sudo groupadd docker #添加docker用户组sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中newgrp docker #更新用户组 参考：http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html 踩坑记录 Alpine镜像 Alpine Linux: 当你想为你的Python开发环境选择一个基础镜像时，大多数人都会选择Alpine，为什么？因为它太小了，仅仅只有 5 MB 左右（对比 Ubuntu 系列镜像接近 100 MB） 然而问题是，假设我们的python应用需要做一些科学计算，无法直接pip安装，因为大多数Linux发行版都使用GNU版本的标准C库（glibc），而Alpine Linux使用的是musl，那些二进制安装包是针对glibc编译的，因此Alpine禁用了Linux安装包支持。从而导致了Alpine的致命问题：标准的Linux安装包在Alpine Linux上根本无法使用。这也就意味着你需要自己弄清楚每一个系统库的依赖性。事先编译好需要的依赖，重新改写Dockerfile.alpine: 123# alpine 中 pip 安装Scipy 等科学相关的包时报错, 需要预先安装的库RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositoriesRUN apk --update-cache --no-cache add tzdata gcc make freetype-dev gfortran musl-dev g++ libgcc libquadmath musl libgfortran lapack-dev 然而经过测试，这样安装会耗时非常久，并且安装过后体积也并不小了，因此，这种情况下不太适合使用alpine做为镜像。因为alpine系统对很多库支持都不够友好 注：python-alpine是一个极简的镜像，只有6.5M左右，但在选择使用时会产生比较多的问题，所以如果系统存储够用或者公司对镜像大小没有限制的话，还是建议使用比较完整的镜像来跑程序，这样会省事很多。 RUN命令 RUN命令只会在构建时候执行，踩坑记录RUN sh repeat.sh 1234567891011#!/bin/bashecho \"Start Record\"ENV_DIR=$(cd $(dirname $0);pwd)# source $ENV_DIR/env/bin/activate# pyenv activate py38nohup python -u checkRepeatSituation.py 1&gt; r1.log 2&gt;err.log &amp;nohup python -u checkRepeatSituation1.py 1&gt; r2.log 2&gt;err.log &amp;nohup python -u checkRepeatSituation3.py 1&gt; r3.log 2&gt;err.log &amp;nohup python -u checkRepeatSituation4.py 1&gt; r4.log 2&gt;err.log &amp;nohup python -m visdom.server &amp; docker exec -it xxx bash进入时ps aux并没有这些python进程，是因为RUN后面的repeat.sh脚本只在构建过程中执行 VOLUMN特性 Volume, on the other hand, just lets a container run from your image have access to some path on whatever local machine the container is being run on. You cannot use files from your VOLUME directory in your Dockerfile. Anything in your volume directory will not be accessible at build-time but will be accessible at run-time. 翻译：另一方面，&quot;卷 &quot;只是让从你的镜像中运行的容器能够访问该容器所运行的任何本地机器上的一些路径。你不能在你的Docker文件中使用VOLUME目录中的文件。在你的volume目录中的任何东西在构建时不能访问，但在运行时可以访问。 ★===&gt;在构建时只要指明了 VOLUMN /app/logs，就不能再往里面放数据COPY draw.sh /app/logs，如果还是要放入，则可以在entrypoint.sh中使用mv在运行时移动文件到/app/logs目录中 作用： 存放运行时生成的持久化数据 存放配置文件==&gt;容器关闭后仍然存在，继续运行时能够读取 跨容器共享文件 注：与VOLUMN的区别是，ADD的内容作为镜像一部分，是构建时的内容；而VOLUMN的更多是运行时的数据 From：https://stackoverflow.com/questions/27735706/docker-add-vs-volume ADD使用说明： 如果源路径是个文件，且目标路径是以 / 结尾， 则docker会把目标路径当作一个目录，会把源文件拷贝到该目录下。 如果目标路径不存在，则会自动创建目标路径。 如果源路径是个文件，且目标路径是不是以 / 结尾，则docker会把目标路径当作一个文件。 如果目标路径不存在，会以目标路径为名创建一个文件，内容同源文件； 如果目标文件是个存在的文件，会用源文件覆盖它，当然只是内容覆盖，文件名还是目标文件名。 如果目标文件实际是个存在的目录，则会源文件拷贝到该目录下。 注意，这种情况下，最好显示的以 / 结尾，以避免混淆。 如果源路径是个目录，且目标路径没有/结尾 如果目标路径不存在，则docker会自动以目标路径创建一个目录，把源路径目录下的文件拷贝进来。 如果目标路径是个已经存在的目录，则docker会把源路径目录下的文件拷贝到该目录下。如ADD log_utils/ /app就没有/app/log_utils文件夹，但log_utils中的内容全在/app目录下 如果源路径是个目录，且目标路径以/结尾，那么将会把原路径目录整个文件夹放在目标路径下来，如ADD log_utils/ /app/就会有/app/log_utils文件夹 如果源文件是个归档文件（压缩文件），则docker会自动帮解压。 除了最后的归档解压一点以外，在其他拷贝特性上，add和copy一致 测试 1234567891011FROM python:3.9MAINTAINER Mrli 1063052964@qq.comWORKDIR /app # 会生成/app 目录VOLUME /cl_logs # 会生成/cl_logs目录COPY test.txt /abc # 当src为文件时，abc会当做是根目录下的文件COPY test.txt /abcd/ # 当dest指明为文件夹时， 会创建/abcd目录，并复制拷贝到dest目录ADD test.txt /ddd # 当src为文件时，abc会当做是根目录下的文件ADD log_utils/ /app # 到src为文件夹时， 会把log_utils中的内容拷贝到app中ADD log_utils/ /app/ # 到src为文件夹时， 会把log_utils文件夹拷贝到app中 Dockfile构建过程中路径问题 路径如下： 1234projectPath/|-requirements.txt|-log_utils |-requirements.txt 其中，因为报过requirements.txt找不到的错误，因此对文件存在的时机和路径进行了思考。得出结论：dockerfile文件在构建过程中，不能够访问到至少同级目录的文件。宿主机里项目中的sourceFile只有ADD命令能接触到。dockfile构建的过程中是访问不到dockerfile目录下的文件的，要用的话，只能add、copy复制进来后再在容器中正常使用。 因此对于整个工程文件都要导入的话，比较主流的做法是，在build构建过程种git clone或者entry-poind.sh里进行clone entrypoint.sh 由于脚本都是在Linux下运行的，因此entrypoint.sh脚本最好是在Linux下编写，否则\\r\\n问题属实让人头疼 至于bash和sh的使用，更推荐bash，用户更友好 Dockerfiles记录 docker-publish： https://github.com/npo5tech/TechXueXi/blob/dev/.github/workflows/docker-publish.yml 不同的操作系统-pyinstaller编译不同平台可执行文件：https://github.com/yqchilde/JDMemberCloseAccount/blob/main/.github/workflows/build.yml 批量删除shell脚本 删除所有None镜像：docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk '{print $3}') 删除所有app容器：docker rm $(docker ps -a | grep &quot;app&quot; | awk '{print $1}' ) 删除6-8行的容器：docker rm $(docker ps -a | grep &quot;Exited&quot; | awk '{print $1}' | sed -n '6, 8p')","categories":[],"tags":[{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"Python中的正则匹配","slug":"Python中的正则匹配","date":"2019-07-25T01:50:19.000Z","updated":"2022-03-18T13:39:13.041Z","comments":true,"path":"2019/07/25/Python中的正则匹配/","link":"","permalink":"https://nymrli.top/2019/07/25/Python中的正则匹配/","excerpt":"","text":"Python中的正则匹配 虽然正则早就会用了,但是有些使用方法老是忘记,因此还是写篇记录一下 特殊字符 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\’ 匹配 “”，而 ‘(’ 则匹配 “(”。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 特殊字符 所谓特殊字符，就是一些有特殊含义的字符，如上面说的 runoo*b 中的 *****，简单的说就是表示任何字符串的意思。如果要查找字符串中的 ***** 符号，则需要对 ***** 进行转义，即在其前加一个 ***: runo*ob 匹配 runoob。 许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符&quot;转义&quot;，即，将反斜杠字符**** 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\’ 匹配 “”，而 ‘(’ 则匹配 “(”。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 限定符 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。‘o{1,}’ 等价于 ‘o+’。‘o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}” 将匹配 “fooooood” 中的前三个 o。‘o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 定位符 定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 正则表达式的定位符有： 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 捕获与非捕获 用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。 其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 选择 (?(id/name)yes|no)的说明：“Matches yes pattern if the group with id/name matched,the (optional) no pattern otherwise.”，即如果前面的捕获组成功匹配，则执行yes的匹配，否则执行no的匹配 1234567891011abcabc&gt;&gt;&gt;print(re.search(r&apos;(\\d)?abc(?(1)\\d|abc)&apos;,&apos;abcabc&apos;))&lt;_sre.SRE_Match object; span=(0, 6), match=&apos;abcabc&apos;&gt; #匹配成功&gt;&gt;&gt;print(re.search(r&apos;(\\d)+abc(?(1)\\d|abc)&apos;,&apos;abcabc&apos;))None #匹配失败&gt;&gt;&gt;print(re.search(r&apos;(\\d)*abc(?(1)\\d|abc)&apos;,&apos;abcabc&apos;))&lt;_sre.SRE_Match object; span=(0, 6), match=&apos;abcabc&apos;&gt; #匹配成功 (?(R)yes|no) 12If recursion of the whole pattern is successful, match the pattern before the | otherwise match the pattern after the |. (?(?=...)yes|no) If the lookahead succeeds, matches the pattern before the vertical bar. Otherwise, matches the pattern after the vertical bar. The lookaround can be negative also. Global flag breaks conditionals. 123/(?(?=is)(is delicious)|(disgusting))/Candy is delicious or disgusting.// 成功匹配is delicious (?(?&lt;=...)yes|no) If the lookbehind succeeds, match the pattern before the vertical bar. Otherwise, matches the pattern after the vertical bar. The lookaround can be negative. Global flag, ‘g’, breaks conditionals. 123/(?(?&lt;=\\s)(delish)|(ew))/Is candy delish or ew?// 匹配delish 反向引用 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。 正则 ?&lt;= 和 ?= 用法](https://www.cnblogs.com/whaozl/p/5462865.html) 方法1： 匹配，捕获(存储) 正则表达式：(?&lt;=(href=&quot;)).{1,200}(?=(&quot;&gt;)) 解释： (?&lt;=(href=&quot;)) 表示 匹配以(href=&quot;)开头的字符串，并且**捕获(存储)**到分组中 (?=(&quot;&gt;)) 表示 匹配以(&quot;&gt;)结尾的字符串，并且**捕获(存储)**到分组中 方法2： 匹配，不捕获(不存储) 正则表达式：(?&lt;=(**?:**href=&quot;)).{1,200}(?=(**?:**&quot;&gt;)) ​ 解释：(?&lt;=(**?:href=&quot;)) 表示 匹配以(href=&quot;)开头的字符串，并且不捕获(不存储)**到分组中 ​ (?=(?:&quot;&gt;)) 表示 匹配以(&quot;&gt;)结尾的字符串，并且**不捕获(不存储)**到分组中 (?:pattern) 非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 (?=pattern) 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。 (?&lt;=pattern) 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题 分组语法 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?&lt;name&gt;exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name’exp) (?:exp) 匹配exp,不捕获匹配的文本 位置指定 (?=exp) —— 前向肯定界定符： 匹配exp前面的位置 123/foo(?=bar)/foobar foobaz成功匹配foo (?&lt;=exp) —— 后向肯定界定符：匹配exp后面的位置 123/(?&lt;=foo)bar/foobar fuubar成功匹配bar (?!exp) —— 前向否定界定符：匹配后面跟的不是exp的位置 123/foo(?!bar)/foobar foobaz成功匹配后面的foo (?&lt;!exp) —— 后向否定界定符：匹配前面不是exp的位置 123/(?&lt;!not )foo/not foo but foo成功匹配后面的foo 注释 (?#comment) 这种类型的组不对正则表达式的处理产生任何影响，只是为了提供让人阅读注释 我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面。 位置指定 接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们用于指定一个位置，就像\\b,^,$那样，因此它们也被称为零宽断言。最好还是拿例子来说明吧： (?=exp)也叫零宽先行断言，它匹配文本中的某些位置，这些位置的后面能匹配给定的后缀exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如果在查找I’m singing while you’re dancing.时，它会匹配sing和danc。 (?&lt;=exp)也叫零宽后行断言，它匹配文本中的某些位置，这些位置的前面能给定的前缀匹配exp。比如(?&lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。 假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\\d)\\d{3})*\\b。请仔细分析这个表达式，它可能不像你第一眼看出来的那么简单。 下面这个例子同时使用了前缀和后缀：(?&lt;=\\s)\\d+(?=\\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。 附录: 常见正则表达式 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、“XXXX-XXXXXXXX”、“XXX-XXXXXXX”、“XXX-XXXXXXXX”、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：[1][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：[2]\\w{5,17}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 匹配{}之内的内容: \\{([^}]+)\\} （匹配两个括号中没有}的地方）and \\{(?:.|\\s)+\\}（匹配括号中所有字符） 问题： 匹配换行符以外的元素： var def = \\{([^\\n]+)\\}; 大括号以内的元素：new_info_tmp = re.findall(r'def = (\\{.*?\\});', html, re.S)[0]，通过re.S \\s:默认情况下的圆点 . 是 匹配除换行符 \\n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \\n。 想使用正则表达式来获取一段文本中的任意字符,写出如下匹配规则：(.*)，因此会在换行符处断开。如果想要满足之前的需求可以写成([\\s\\S]*)，这个会包含\\n Python中的re.S 如果不使用re.S参数，则只在每一行内进行匹配，如果一行没有，就换下一行重新开始。 而使用re.S参数以后，正则表达式会将这个字符串作为一个整体，在整体中进行匹配。 sub介绍 Python 的 re 模块提供了re.sub用于替换字符串中的匹配项，sub是substitute表示替换。 pattern：该参数表示正则中的模式字符串； repl：repl可以是字符串，也可以是可调用的函数对象；如果是字符串，则处理其中的反斜杠转义。如果它是可调用的函数对象，则传递match对象，并且必须返回要使用的替换字符串 string：该参数表示要被处理（查找替换）的原始字符串； count：可选参数，表示是要替换的最大次数，而且必须是非负整数，该参数默认为0，即所有的匹配都会被替换； flags：可选参数，表示编译时用的匹配模式（如忽略大小写、多行模式等），数字形式，默认为0。 repl传函数对象 匹配字符串中的数字加2 123456789101112131415import re'''匹配字符串中的数字加2'''def addAge(match) -&gt;str: '''返回匹配的值加2''' age = match.group() return str(int(age)+2)s = 'my age is 20'# repl 如果它是可调用的函数对象，则传递match对象，并且必须返回要使用的替换字符串x = re.sub(r'[\\d]+', addAge, s)print(x)# my age is 22 a-zA-Z ↩︎ a-zA-Z ↩︎","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"利用wireshark抓取TCP的整个过程分析[转]","slug":"利用wireshark抓取TCP的整个过程分析","date":"2019-07-24T07:51:29.000Z","updated":"2019-09-15T08:07:31.030Z","comments":true,"path":"2019/07/24/利用wireshark抓取TCP的整个过程分析/","link":"","permalink":"https://nymrli.top/2019/07/24/利用wireshark抓取TCP的整个过程分析/","excerpt":"","text":"原文地址：https://www.cnblogs.com/NickQ/p/9226579.html 最近，已经很久都没有更新博客了。看看时间，想想自己做了哪些事情，突然发现自己真的是太贪心，到头来却一个都没搞好。手头的嵌入式都还没学出名堂，竟然还想着学FPGA,物联网，机器学习。然而，遇到新奇的事物，就会控制不住的去想，去找资料，实际上只是逃避遇到的问题，不想去解决而已。。最后的结果就是手头的活堆起来了，然后花大把整块的时间解决。真的是讨厌现在的自己。 以后还是慢慢记录吧，不管做了什么，都慢慢尝试积累。。其他的东西，像FPGA，机器学习什么的，让他随风去吧，用到啥学啥。其他的当看客，了解了解就好。 这是计算机网络的一次作业，学习抓取TCP/IP建立连接和断开连接的过程，以下是正文： 步骤： 首先尝试抓百度，腾讯等网络连接，发现会有许多问题需要考虑，断开连接操作不好操作，且数据冗杂不利于学习。 所以借助手机和电脑完成此次过程，操作如下： 1、在手机端，安装TCP测试工具，开启TCP监听，端口8088； 2、打开wireshark监听WIFI网卡。 3、打开电脑端TCP测试客户端，连接TCP服务器。 此处，我的手机IP为192.168.255.5，端口8088；电脑的IP地址为192.168.255.6。 4、通过电脑客户端，发送两次信息到手机。 5、通过手机客户端，发送两次信息到电脑。 6、断开连接。 7、通过ip.addr eq 192.168.255.5 and ip.addr eq 192.168.255.6 and tcp过滤掉其他报文。 至于wireshark过滤的语法，可以参考其他的一些博文：https://blog.csdn.net/wojiaopanpan/article/details/69944970 协议及过程分析： TCP三次握手：如下图中蓝色方框所示。 TCP握手协议在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；如下图中报文No.7 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；如下图中报文No.8 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据。如下图中报文No.9 TCP四次挥手：如上图中红色方框所示。 注：此处，由于先断开的服务器，所以手机服务器是客户端A。 第一次挥手：客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 如图中报文No.255 第二次挥手：服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。如图中报文No.256 第三次挥手：服务器B关闭与客户端A的连接，发送一个FIN给客户端A。如图中报文No.257 第四次挥手：客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。如图中报文No.258 其他: 下图是其中一帧数据解析，可以看到数据是由192.168.255.6:62643(电脑客户端)发送给192.168.255.5:8088(手机服务端）。 消息内容为：201521111083","categories":[],"tags":[{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"C++学习笔记","slug":"C-学习笔记","date":"2019-07-13T01:00:50.000Z","updated":"2019-09-15T08:07:30.924Z","comments":true,"path":"2019/07/13/C-学习笔记/","link":"","permalink":"https://nymrli.top/2019/07/13/C-学习笔记/","excerpt":"","text":"C++学习笔记 system（）就是调用（DOS）系统命令（和shell命令）。 pause ，即DOS命令集合中的暂停命令； sprintf 123456789101112#include &lt;stdio.h&gt;int main( void )&#123; char buffer[200], s[] = &quot;computer&quot;, c = &apos;l&apos;; int i = 35, j; float fp = 1.7320534f; // 格式化并打印各种数据到buffer j = sprintf( buffer, &quot; String: %s\\n&quot;, s ); // C4996 j += sprintf( buffer + j,&quot; Character: %c\\n&quot;, c ); j += sprintf( buffer + j,&quot; Integer: %d\\n&quot;, i ); j += sprintf( buffer + j,&quot; Real: %f\\n&quot;, fp ); printf( &quot;Output:\\n%s\\ncharacter count = %d\\n&quot;, buffer, j );&#125; 返回写入buffer 的字符数，出错则返回-1. 如果 buffer 或 format 是空指针，且不出错而继续，函数将返回-1 sprintf 返回以format为格式argument为内容组成的结果被写入buffer 的字节数，结束字符‘\\0’不计入内。即，如果“Hello”被写入空间足够大的buffer后，函数sprintf 返回5。 引用 声明引用： 12int a = 1;int &amp;c=a; //int &amp; c=a; △.声明引用时必须初始化 传引用参数 12void func(int&amp; a)&#123;&#125; //函数名(xxx)xxx其实是创建形参变量的过程func(b); 传指针 1void func2(int *a)&#123;&#125; 返回引用 返回值不能是局部变量（局部变量在生命期结束后会被销毁） ​ （c中生命周期结束后，立马销毁，而在python中垃圾回收机制会在判断之后不使用的情况下再销毁） func2(&amp;b); 增强的for循环: 在vc6.0中 for(int i=4;i&gt;0;i–) i的作用域为 整个外部作用域如 void main() { ​ for(int i=4;i&gt;0;i–) //作用域为整个main函数 } 而在vs中 for(int i=4;i&gt;0;i–) i的作用域为 该个for循环内 void main() { ​ for(int i=4;i&gt;0;i–) //作用域为该个for循环 } 默认参数 从右往左连续 返回值不是函数重载的条件 malloc和free 不会触发构造函数或是析构函数 new和delete 可以 类 不做特别说明，类的数据成员和成员函数都被认为是private this指针 this 是类成员函数的隐含参数，不是类的数据成员 静态成员无this指针 常函数 常函数不能修改类中的数据成员的值 析构函数和构造函数不能是常函数 常变量只能调用常函数，不能调用普通函数 常对象只能调用常函数，不能调用普通函数 静态成员 是类本身的属性，无对象时也可以直接调用Cstu::sta 静态成员函数只能调用静态数据成员 类外初始化 不需要static关键字 如： int Cstu::sta = 12; 创建数组 12a = new int[2];delete[] a; 浅拷贝和深拷贝 系统默认的为浅拷贝 有指针承运啊时得内存拷贝，所以使用深拷贝， 为了避免拷贝构造，运算符重载应该传引用 拷贝构造 何时会调用 1.新建一个对象，并将其初始化为同类现有对象 123456Cstu a;- Cstu a1(a);- Cstu a2 = a;- Cstu a3 = Cstu(a); //创建了临时对象- Cstu a4 = new Cstu(a);- △.赋值并不会发生拷贝构造 2.当程序生成对象副本时 12345678910111213141516171819202122232425262728293031- 参数是本类的常引用Cstu(const Cstu&amp;)- 普通构造函数如果空的话是不执行内容的，拷贝构造空的话是执行内容的- 默认的复制构造函数，逐个复制非静态成员的值，## 内联函数inline- 函数代码少，流程直接，调用频繁，如循环- 类内定义的都是内联函数（隐式），写inline为显性- 内联函数的定义一般写在头文件内- 只在声明位置写inline不管用，定义与声明都要有inline关键字- 空间换时间，使用频率低时速度快，频率高时，比较占用内存，主要看性价比- 递归不能是内联函数## 操作符重载------- 为了避免拷贝构造，运算符重载应该传引用或是传地址- 操作符重载必须有一个类类型的参数- =、[]、()、-&gt;必须是诚邀- 复合赋值运算符通常是成员- 改变对象状态的运算符，递增、解引用，通常是成员### 输出运算符重载:- 参数1是ostream引用，参数2是对象的常引用- 必须是类外重载，原因为1- 输出私有成员时，要用友元 void operator &lt;&lt; (ostream&amp; os,const &amp;Csty)，os &lt;&lt;st.nAge; ostream&amp; operator &lt;&lt; (ostream&amp; os,const &amp;Csty)，os &lt;&lt;st.nAge; 12345### 输入运算符重载:- 参数不匹配用ist.fail()检测- 输出=&gt; ist&gt;&gt;st.nAge &gt;&gt; st.dbHeight; istream&amp; operator &gt;&gt;(istream&amp; ist,CStu&amp; st) 1234------### 前置+ +与后置+ +重载 int operator++(Cstu* st){} =&gt;前置++ int operator++(Cstu* st,int n) =&gt;后置++ { int a =st.nage; st.nage +=1; return a; } 1234------类型转换重载 operator int()const{} //无返回值，但有return 1234△.必须在类内。▲.const## 模板 template void func(Y a) cout &lt;&lt; a &lt;&lt; endl; 12模板的具体化: temlpate &lt;&gt; void func(Node&amp; a){} 1234567891011121314151617181920212223242526&gt; 模板具体化的执行优先级高于通用的优先级，◇.注意，STL头文件没有扩展名.h------# CPP```该类接受2个参数初始化列表class CStu&#123; int a; int arr[4]; float b;//构造函数： CStu(*float c,int d*):a(2),b(2.2f),arr() #成员初始化顺序只与声明顺序有关，与此处书写顺序无关 &#123; #新增语法，arr数组全初始化为0 &#125;&#125; ▲.类必须先初始化成员变量。 ​ 。float c和int d 两个变量的作用域仅限于构造函数内.所以要想在整个类中使用该变量，就得将传入的参数初始化赋值给类中的变量。 ​ 若有多个构造函数，会执行初始化列表绑定所在的构造函数（构造函数的重载） 数组的赋值： 初始化列表arr() 构造函数中for循环赋值 memset(&amp;arr[0],0,16) △.析构函数没有重载，且不接受参数。对象声明调用周期结束时自动调用。 ▲构造函数和析构函数都必须写在public访问控制符下 malloc和new、free和delete区别 malloc不会触发构造函数，new可以 free不会触发析构函数，delete可以 This指针 指针类型为类的类型。 this不是类的成员。 this指针为成员函数的隐含参数，相当于python类中的self…(所以this指针的作用域为类内部) 常函数 CStu&#123;&#125;123456class CStu&#123; public: void show() const #在括号之后 &#123;&#125;&#125; ◆.析构函数、构造函数不能是常函数 ◆.常函数不能修改数据成员（是类的），但可以修改常函数内的变量。 ▲常函数的this指针的类型为const CStu* ★常对象(const CStu st)只能调用常函数，不能调用普通函数 静态成员 1234567class CStu&#123; static int b; public: void show() const #在括号之后 &#123;&#125;&#125; ∷不能在构造函数的初始化列表中初始化，但可以类外初始化 ∷类外初始化不用加static，而是int CStu::b = 12; ▲static受访问控制符约束。 调用方法： 12类名作用域：cout&lt;&lt; CStu::b &lt;&lt; endl;对象： ○只有静态常量整型数据才能直接在类中初始化，其他得在初始化列表或者构造函数中赋值（静态数据成员可以类外赋值），普通数据成员不能类外初始化。 ●静态成员是跟类一一对应的，跟对象无关。 静态成员函数 他是属于类的属性，不是对象的，即同一个类的所有对象共有一个（可以作为指挥类所有对象的方法） 无this指针 不能调用普通成员，只能调用静态成员 拷贝构造 public: ​ Cstu(const Cstu &amp;a){} 形式。参数是本类的常引用 何时调用： 1234567891.新建一个对象，并将其初始化为同类时：- Cstu a1(a); #a为一个Cstu对象- Cstu a2 = a; 将不会再触发构造函数。- Cstu a3 = Cstu(a); 用a来拷贝构造一个临时对象，再用这个临时对象给a3- Cstu* a4 = new Cstu(a);2.当程序生成对象副本时： 函数参数传递对象的值void fun(Cstu a)&#123;&#125; （∵当调用这个函数的时候会为这个形参生成空间） ▲有时为了效率要避免这种拷贝构造的产生，解决：传引用 函数返回值 Cstu fun()&#123; Cstu a; return a;&#125; 返回值为创建了临时对象承接，然后再把临时变量返回。 赋值不会调用： Cstu s1; Cstu s2; s2 = s1; 默认拷贝构造（浅拷贝） 逐个赋值非静态成员，（即默认拷贝构造中是有内容的，默认的构造函数是没有内容的） 内存排布一样，地址不同 深拷贝(涉及类中有指针) 如果是浅拷贝，则两个对象的指针都会指向同一个空间，如果第一个对象被消除后，这个空间就会被delete（free掉），所以第二个对象被删除时再操作（free）这个被释放掉的空间（已经还给系统），就相当于控制野指针，所以会报错。 解决方法1深拷贝： 123this-&gt;a = new int[2];memcpy(this-&gt;a,b.a,8);strcpy(...) 解决方法2传引用（不经过拷贝构造）： 123Cstu&amp; fun(CStu&amp; a)&#123; return a; &#125;fun(a); 解决方法3传地址： 123Cstu* fun(CStu* a)&#123; return a; &#125;fun(&amp;a); inline内联函数 常规函数的调用过程：调用时，根据函数地址，跳到函数代码空间，执行指令，执行完再跳转到调用的位置。 内联函数：将函数代码直接复制到执行部分，不跳转。 比常规函数稍快 占用更多内存（增加代码长度） ▲声明和定义都要加inline 关键字 ▲递归不能是内联函数 △.函数代码少时、调用频繁（for循环里）大多用内联函数（常规函数的话，跳转所耗时间占比就大） ▲.类内定义的函数都是内联函数，但如果定义在类外的话加inline为内联函数，不加就不是内联函数。 △.内联函数通常定义在头文件里。 操作符重载 operator为关键字 “operator+”必须有一个类类型的形参； 继承： 继承控制符： public 父类：父类为什么访问控制符，子类就继承什么样的。 protected 父类:继承之后，父类的public降级为protected，低级或者同级的访问控制符不变（即protectedh和private) private 父类：继承之后，父类全变为私有。 多态和虚函数 多态：同样的调用有多种结果 通过虚函数调用子类的成员函数，形式为virtual void Show(){} (函数名与子类相同) 具体执行那个子类的函数由父类所指向的子类所决定. CFather* fa = new CSon1; C++中声明结构体变量不需要‘struct’，struct默认为public,class 默认为private c静态变量在预处理时声明。 cpp静态成员在类声明时声明。 STL初始化 (1): vector v; 默认初始化，vector为空， size为0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。 (2): vector v2(v); vector v2= v; 两种方式等价 ，ilist2 初始化为ilist 的拷贝，ilist必须与ilist2 类型相同，也就是同为int的vector类型，ilist2将具有和ilist相同的容量和元素 (3): vector ilist = {1,2,3.0,4,5,6,7}; vector ilist {1,2,3.0,4,5,6,7}; 初始化为列表中元素的拷贝，列表中元素必须与ilist的元素类型相容 (4): vector ilist3(ilist.begin()+2,ilist.end()-1); 初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与ilist3 的元素类型相容 (5): vector ilist4(7); 默认值初始化，ilist4中将包含7个元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0， (6):vector ilist5(7,3); 指定值初始化，ilist5被初始化为包含7个值为3的int 12std::vector&lt;int&gt; idxs中for(int i : idxs) ====&gt; for i in indx ..... i 为idxs中元素","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"通过XDRP实现Windows远程访问ubuntu桌面","slug":"通过XDRP实现Windows远程访问ubuntu桌面","date":"2019-07-13T00:57:05.000Z","updated":"2019-09-15T08:07:31.098Z","comments":true,"path":"2019/07/13/通过XDRP实现Windows远程访问ubuntu桌面/","link":"","permalink":"https://nymrli.top/2019/07/13/通过XDRP实现Windows远程访问ubuntu桌面/","excerpt":"","text":"通过XDRP实现Windows远程访问 1234567891011121314#安装xrdp $ sudo apt-get install xrdp #安装vnc4server $ sudo apt-get install vnc4server tightvncserver#安装xubuntu-desktop $ sudo apt-get install xubuntu-desktop #向xsession中写入xfce4-session $ echo “xfce4-session” &gt;~/.xsession #开启xrdp服务 $ sudo service xrdp restart 上面是网上大多数示例所展示的，都是依靠第三方桌面系统实现远程访问，下面讲解的是如何直接访问原生系统。 步骤一、下载TigerVNC Server软件包 下载地址：Tigervnc Deb软件包（适用于Ubuntu 16.04.1 - 64位） 步骤二、 安装TigerVNC Server软件包 1、打开终端，进入到刚刚你你下载TigerVNC Server的存放目录，我是直接下载到默认的DownLoads下的，因为下载的是zip文件，记得解压出来，得到deb安装文件。 2、再输入一下安装命令进行安装（需要su密码） 12$ sudo apt-get install -f$ sudo dpkg -i tigervncserver_1.6.80-4_amd64.deb 步骤三、安装xrdp 打开终端，输入一下命令（需要su密码） 1sudo apt-get install xrdp -y 步骤四、配置xrdp设置 需要通过xrdp连接到桌面，需要正确配置相关信息并填充到.xsession文件（针对每个用户）或/etc/startwm.sh（针对所有用户），输入如下命令 123$ echo unity&gt;~/.xsession# 或者$ sudo sed -i.bak '/fi/a #xrdp multi-users \\n unity \\n' /etc/xrdp/startwm.sh 步骤五、重启xrdp 1sudo service xrdp restart 步骤六、开启桌面共享功能 进入系统-》首选项-》桌面共享，或者直接搜索桌面共享，如图所示 将【允许其他人查看您的桌面】这一项勾上，如图所示： 到这一步基本上已经完成了，接下来就是来测试是否能正常连接到Ubuntu了 三、xrdp测试连接到Ubuntu 1、查看Ubuntu服务器的IP地址，如图所示： 2、启动Windows远程桌面工具(mstc)，输入Ubuntu的IP地址（192.168.226.131），如图所示： 3、点击连接之后，正常情况会自动跳出xrdp的登录界面，需要我们输入用户名和密码即可，模式选择默认就行，如图所示： 4、我们可以看到xrdp的实时日志，如图所示： 5、最终我们连接到上了Ubuntu，是不是很熟悉的界面~~（ヾ(๑╹◡╹)ﾉ&quot;） 至此，xrdp连接Ubuntu 16.04的所有步骤已完成","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://nymrli.top/tags/Ubuntu/"}]},{"title":"自动化运维工具Ansible","slug":"自动化运维工具Ansible","date":"2019-07-08T06:45:45.000Z","updated":"2019-12-16T13:16:40.946Z","comments":true,"path":"2019/07/08/自动化运维工具Ansible/","link":"","permalink":"https://nymrli.top/2019/07/08/自动化运维工具Ansible/","excerpt":"","text":"简介 ​ ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。 ansible是基于 paramiko 开发的,并且基于模块化工作，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。ansible不需要在远程主机上安装client/agents，因为它们是基于ssh来和远程主机通讯的。ansible目前已经已经被红帽官方收购，是自动化运维工具中大家认可度最高的，并且上手容易，学习简单。是每位运维工程师必须掌握的技能之一。 ansible 特点 部署简单，只需在主控端部署Ansible环境，被控端无需做任何操作； 默认使用SSH协议对设备进行管理； 有大量常规运维操作模块，可实现日常绝大部分操作； 配置简单、功能强大、扩展性强； 支持API及自定义模块，可通过Python轻松扩展； 通过Playbooks来定制强大的配置、状态管理； 轻量级，无需在客户端安装agent(代理)，更新时，只需在操作机上进行一次更新即可； 提供一个功能强大、操作性强的Web管理界面和REST API接口——AWX平台。 Ansible适用于中小型应用环境；SaltStack适合大型（Ansible由于不需要代理,只是通过ssh,因此只能性能不如Saltstack高） Ansible安装 法1.在已有python-pip的情况下 1$ pip install ansible 法2: 1234sudo apt-get install software-properties-commonsudo apt-add-repository ppa:ansible/ansiblesudo apt-get updatesudo apt-get install ansible 如果安装失败请换源sudo sed -i -re 's/\\w+\\.archive\\.ubuntu\\.com/archive.ubuntu.com/g' /etc/apt/sources.list,更新安装库sudo apt-get update ansible 架构图 上图中我们看到的主要模块如下： Ansible：Ansible核心程序。 HostInventory：主机清单 , 记录由Ansible管理的主机信息，包括端口、密码、ip等。 Playbooks：“剧本”YAML格式文件，多个任务定义在一个文件中，定义主机需要调用哪些模块来完成的功能。 CoreModules：核心模块，主要操作是通过调用核心模块来完成管理任务。 CustomModules：自定义模块，完成核心模块无法完成的功能，支持多种语言。 ConnectionPlugins：连接插件，Ansible和Host通信使用 ansible配置文件查找顺序 检查环境变量ANSIBLE_CONFIG指向的路径文件(export ANSIBLE_CONFIG=/etc/ansible.cfg)； HOME目录下的配置文件~/.ansible.cfg 检查当前目录下的ansible.cfg配置文件； /etc/ansible.cfg检查etc目录的配置文件。 使用特性 模块化：调用特定的模块，完成特定任务 有Paramiko，PyYAML，Jinja2（模板语言）三个关键模块支持自定义模块 基于Python语言实现 部署简单，基于python和SSH（默认已安装），agentless安全，基于OpenSSH支持playbook编排任务 幂等性：一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况 无需代理不依赖PKI（无需ssl）可使用任何编程语言写模块 YAML格式，编排任务，支持丰富的数据结构 较强大的多层解决方案 管理方式: Ad-Hoc，及Ansible命令，主要用于临时命令使用场景 Ansible-Playbook，脚本，用于长期规划好，大型项目的场景，需要有提前的规划 Ansible-playbook（剧本）执行过程： 将已有编排好的任务集写入Ansible-Playbook 通过ansible-playbook命令分拆任务集至逐条ansible命令，按预定规则逐条执行 相关文件 配置文件 /etc/ansible/ansible.cfg 主配置文件，配置ansible工作特性 /etc/ansible/hosts 主机清单 /etc/ansible/roles/存放角色的目录 程序 /usr/bin/ansible 主程序，临时命令执行工具 /usr/bin/ansible-doc 查看配置文档，模块功能查看工具 /usr/bin/ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台 /usr/bin/ansible-playbook定制自动化任务，编排剧本工具/usr/bin/ansible-pull远程执行命令的工具 /usr/bin/ansible-vault 文件加密工具 /usr/bin/ansible-console 基于console界面与用户交互的执行工具 1.设置被管理的主机清单vim /etc/ansible/hosts 2.1口令验证方式.ansible 192.168.30.101 -m ping -k用账号密码去确认受控端的身份 ▲如果出现了这样的情况,需要先安装sshpass , sudo apt install sshpass 1234192.168.100.180 | FAILED! =&gt; &#123; \"failed\": true, \"msg\": \"ERROR! to use the 'ssh' connection type with passwords, you must install the sshpass program\"&#125; 2.2基于key验证 123456789101112$ ssh-keygen$ ssh-copy-id 192.168.30.101Generating public/private rsa key pair.Enter file in which to save the key (/xxxxxx/): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in xxxxxxxxx.Your public key has been saved in xxxxx.The key fingerprint is:SHA256:xxxxxxxxxxxxxxThe key's randomart image is: 如果设置了passphrase,那么链接时需要输入passphrase,如果是ad-hoc就相当麻烦,而playbooks中有解决方法 ad-hoc使用 将host_key_checking取消注释,否则链接对象必须在known_hosts中 123$ sudo vim /etc/ansible/ansible.cfg uncomment this to disable SSH key host checking#host_key_checking = False 显示日志,取消注释log_path = /var/log/ansible.log △.ansible不是长期执行的服务,不长期执行,因此修改配置后不需要重启服务 12345ansible &lt;host-pattern&gt;[-m module_name][-a args]ansible dbsrvs -m command -a 'ls /root'-u wang-k -b-K -u 以wang的身份登录,-b将wang切换成root,-K 输入root密码. -m 指定模块名,-a指定模块参数 ansible的Host-pattern即匹配主机的列表 123456789All：表示所有Inventory中的所有主机ansible all-m ping：通配符ansible&quot;&quot;-m pingansible 192.168.1.-m pingansible&quot;srvs&quot;-m ping或关系ansible&quot;websrvsiappsrvs&quot;-m pingansible&quot;192.168.1.10：192.168.1.20&quot;-m ping 逻辑与 ansible &quot;websrvs:&amp;dbsrvs&quot; -m ping在websrvs组并且在dbsrvs组中的主机,单引号、双引号都行 逻辑非 ansible 'websrvs:ldbsrvs'-m ping在websrvs组，但不在dbsrvs组中的主机 注意：此处为单引号 综合逻辑 ansible 'websrvs:dbsrvs:&amp;appsrvs:lftpsrvs'-m ping 正则表达式 ansible &quot;websrvs:&amp;dbsrvs&quot; -m ping ansible &quot;~（webldb）.*\\.magedu\\.com&quot; -m ping ansible command creates= 存在,不执行 removes= 不存在,不执行 chdir= 切换目录后执行 命令返回颜色说明 绿色： 表示查看信息，对远程主机未做改动的命令 红色： 批量管理产生错误信息 黄色： 对远程主机做了相应改动 紫色： 对操作提出建议或忠告 常用模块 command shell : 远程节点执行模块 ansible all -m shel1 -a 'getenforce' script: 在远程执行本地的脚本 ansible test -m script -a &quot;/sh/test.sh&quot; copy : 复制模块 ansible all -m copy -a 'src=/root/ansible/selinux dest=/etc/selinux/config backup=yes' ansible all -m copy-a 'src=/etc/shadow dest=/data/mode=000 owner=wang' fetch : 远程获取 ansible srv-m fetch -a 'src=/root/a. sh dest=/data/scripts' file : 文件操作,删除、创建 ansible test -m file -a &quot;dest=/tmp/hello state=touch&quot; unarchieve、achieve : 压缩解压 ansible test -m unarchive -a 'src=/srv/tomcat8/apache-tomcat-8.0.29.tar.gz dest=/usr/local copy=no mode=0755' cron 开启ansible all-m cron -a 'minute=* weekday=1,3,5 jcb=&quot;/usr/bin/wall FBI warning&quot; name=warningcron' 禁用ansible all -m cron -a 'disabled=true job=&quot;/usr/bin/wall FBI warning&quot;name=warningcron'、启用ansible all -m cron -a 'disabled=falsejob=&quot;/usr/bin/wall FBI warning&quot;name=warningcron' 删除ansible all -m cron -a 'job=&quot;/usr/bin/wall FBI warning&quot;name=warningcron state=absent' apt、yum ansible all -m apt 'name=vim update_cache=yes' user group service service:name=httpd state=started enabled=yes setup ansible websrvs -m setup -a 'filter=*address*' template(不能放在ad-hoc)中,只能在playbook中使用 command模块在针对管道、*重定向有…**有问题==&gt;使用shell模块 常用模块介绍 ▲一般 present 表示生成、下载, absent 表示删除或卸载。 系列命令 galaxy ansible-galaxy install geerlingguy.nginx 其中geerlingguy为角色在./ansible/roles/ playbooks Yaml YAML Ain’t Markup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是：“Yet Another Markup Language”（仍是一种标记语言） 核心元素 Hosts 执行的远程主机列表 Tasks 任务集 Varniables 内置变量或自定义变量在playbook中调用Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件Handlers 和notity结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行 tags 标签指定某条任务执行，用于选择运行playbook中的部分代码。 ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断 ansible-playbook-t tagsname useradd.yml 加密 加密ansible-vault encrypt hello.yml 解密查看ansible-vault view hello.yml 重新制定口令ansible-vault rekey hello.yml 基础组件 如果命令或脚本的退出码不为零，可以使用如下方式替代 123tasks: - name:run this command and ignore the result shell: /usr/bin/somecommand || /bin/true 或者使用ignore_errors来忽略错误信息： 1234tasks： - name:run this command and ignore the result shell:/usr/bin/somecommandignore_errors:True 运行playbook的方式 ansible-playbook &lt;filename.yml&gt;..[options] 常见选项 -check(-C)只检测可能会发生的改变，但不真正执行操作 --list-hosts列出运行任务的主机 --limit主机列表只针对主机列表中的主机执行 -V显示过程-vw-vwv更详细 handlers和notify 12345678910tasks: - name: install httpd package yum: name=httpd - name: copy conf file copy:src=files/httpd.conf dest=/etc/httpd/conf/backup=yes notify: restart service - name: start service service: name=httpd state=started enabled=yes handlers: - name:restart service service:name=httpd state=restarted 标签 指定标签来执行指定任务 ansible-playbook -t rshttp,xxxx httpd.yml 变量使用 jinjia2语法 1&#123;&#123; var &#125;&#125; 法一：ansible setup facts 远程主机的所有变量都可直接调用 法二：在/etc/ansible/hosts中定义普通变量：主机组中主机单独定义，优先级高于公共变量公共（组）变量：针对主机组中所有主机定义统一变量 123456[websrvs]192.168.30.101 http_port=81192.168.30.102 http_port=82[websrvs:vars]nodename=www domainname=magedu.com 法三：ansible-playbook -e 'var=xxx' app.html，优先级比法二高 法四: 1234567- hosts: remote_user: root vars: - var: xxx tasks: - name: yum: ... 迭代机制 1234567tasks: - name: file: name=/data/&#123;&#123; item &#125;&#125; with_items: - file1 - file2 - file3 迭代嵌套自变量 123456789101112131415- hosts: websrvs remote_user: root tasks: - name: add some groups group: name=&#123;&#123; item ]&#125; state=present with_items: - group1 - group2 - group3 - name: add some users user: name=&#123;&#123; item. name ]&#125; group=&#123;&#123; item. group )&#125; state=present with items: - &#123; name: user1, group:' group1'&#125; - &#123; name: 'user2, group:' group2'&#125; - &#123; name: 'user3', group:' group3'&#125; 1234&#123;% for vhost in nginx_vhosts%&#125;server&#123;listen&#123;&#123; vhost &#125;&#125;&#123;% endfor %&#125; 12345678910- hosts: websrvs remote_user: root vars: ports: - listen_port: 81 - listen_port: 82 - listen_port: 83 tasks: - name: copy conf template: src=forl.conf.j2 dest=/data/for1.conf 条件判断 1234567891011121314151617- hosts: all remote_user: root tasks:#如果系统中存在主机名为nfs或者backup的主机，则创建文件 - name: Create File file: path=/tmp/this_is_&#123;&#123; ansible_hostname &#125;&#125;_file state=touch when: (ansible_hostname == \"nfs\") or (ansible_hostname == \"backup\") #系统为centos的主机才会执行 - name: Centos Install httpd yum: name=httpd state=present when: (ansible_distribution == \"CentOS\") #系统为ubuntu的主机才会执行 - name: Ubuntu Install httpd yum: name=httpd2 state=present when: (ansible_distribution == \"Ubuntu\") 12345tasks: - name: run df -h sudo_user: test sudo: yes shell: name=df -h ansible sudo 即将变更为become 1234567[s21]#代替原来192.168.1.21 ansible_ssh_user=i ansible_ssh_pass=i的写法192.168.1.21 ansible_ssh_user=i ansible_ssh_private_key_file=/home/i/.ssh/id_rsa ansible_become=true ansible_become_user=root ansible_become_pass=&apos;i&apos; 获取执行命令的输出 –Register[转] 1234567- name: echo date command: date register: date_output - name: echo date_output command: echo \"30\" when: date_output.stdout.split(' ')[2] == \"30\" 判断文件是否存在[转] 12345678910- name: judge a file or dir is exits shell: ls /home/sfy ignore_errors: True register: result- shell: echo \"file exit\" when: result|succeeded- shell: echo \"file not exit\" when: result|failed 权限问题 关于权限问题，可以通过ansible -h查看 123456789101112131415161718192021222324Privilege Escalation Options: control how and which user you become as on target hosts -s, --sudo run operations with sudo (nopasswd) (deprecated, use become) -U SUDO_USER, --sudo-user=SUDO_USER desired sudo user (default=root) (deprecated, use become) -S, --su run operations with su (deprecated, use become) -R SU_USER, --su-user=SU_USER run operations with su as this user (default=None) (deprecated, use become) -b, --become run operations with become (does not imply password prompting) --become-method=BECOME_METHOD privilege escalation method to use (default=sudo), valid choices: [ sudo | su | pbrun | pfexec | doas | dzdo | ksu | runas | pmrun ] --become-user=BECOME_USER run operations as this user (default=root) --ask-sudo-pass ask for sudo password (deprecated, use become) --ask-su-pass ask for su password (deprecated, use become) -K, --ask-become-pass ask for privilege escalation password ▲其中deprecated表示是将被弃用的，将全部被become代替，（即参数-b） 关于-b和-K的作用，可以通过如下命令进行测试 12345$ ansible test -m shell -a \"whoami\" -K mrli身份使用sudo权限$ ansible test -m shell -a \"whoami\" -b 切换到root身份$ ansible test -m shell -a \"whoami\" -b -K ▲这个权限问题在ansible执行shell脚本的时候需要特别注意 个人写过的Playbook-demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071- hosts: 192.168.100.190 remote_user: apollo3d become: yes vars: spark: /home/apollo3d/SimSpark/spark/build rcssserver3d: /home/apollo3d/SimSpark/rcssserver3d/build tasks: - name: judge former platform directory Exsit shell: 'ls /home/apollo3d/simspark-0.3.0/build' ignore_errors: True register: formerDirExsit - name: uninstall command: 'chdir=&#123;&#123; item &#125;&#125; make uninstall' with_items: - /home/apollo3d/simspark-0.3.0/build - /home/apollo3d/rcssserver3d-0.7.1/build when: formerDirExsit|succeeded - name: remove file: dest: '&#123;&#123; item &#125;&#125;' state: absent with_items: - /home/apollo3d/simspark-0.3.0/ - /home/apollo3d/rcssserver3d-0.7.1/ when: formerDirExsit|succeeded - name: judge new zip shell: ls /home/apollo3d/SimSpark.tar.gz ignore_errors: True register: zipExsit - name: jieya unarchive: src: /home/apollo3d/SimSpark.tar.gz dest: /home/apollo3d/ copy: no mode: 0755 when: zipExsit|succeeded - name: mk dirs file: \"dest=&#123;&#123; item &#125;&#125; state=directory\" with_items: - /home/apollo3d/SimSpark/spark/build - /home/apollo3d/SimSpark/rcssserver3d/build when: zipExsit|succeeded - name: install1 command: 'chdir=&#123;&#123; spark &#125;&#125; &#123;&#123; item &#125;&#125;' with_items: - cmake .. - make -j4 - make install when: zipExsit|succeeded - name: install2 command: 'chdir=&#123;&#123; rcssserver3d &#125;&#125; &#123;&#123; item &#125;&#125;' with_items: - cmake .. - make -j4 - make install when: zipExsit|succeeded - name: config shell: '&#123;&#123; item &#125;&#125;' with_items: - echo '/usr/local/lib/simspark\\n/usr/local/lib/rcssserver3d' | sudo tee /etc/ld.so.conf.d/spark.conf - ldconfig when: zipExsit|succeeded roles ansilbe自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中 复杂场景：建议使用roles，代码复用度高 变更指定主机或主机组 如命名不规范维护和传承成本大 某些功能需多个Playbook，通过Includes即可实现 roles目录结构： playbook.yml roles/ project/ tasks/ files/ vars/不常用 default/不常用 templates/ handlers/ meta/不常用 附录 Ansible 配置SSH公钥认证 安装好Ansible之后，要开始工作，还需要创建一个被控制主机列表清单.默认读取/etc/ansible/hosts,如果该文件不存在，则要收到进行创建. 也可以通过环境变量 ANSIBLE_INVENTORY 来设置默认清单文件,1.9版本之前用 ANSIBLE_HOSTSexport ANSIBLE_INVENTORY=~/ansible_hosts 创建SSH认证文件 该操作是在控制主机中进行。 SSH认证文件创建成功之后，将控制主机的公钥文件 id_rsa.pub 添加到被控制主机的~/.ssh/authorized_keys。 \\ ~指的是控制主机和被控制主机通信的用户家目录。 \\ id_rsa 是控制主机的私钥文件，要严格保管。 \\ id_rsa.pub是控制主机的公钥文件，可随意分发。 法一:ansible all -m shell -a &quot;cat /tmp/authorized_keys &gt;&gt; /root/.ssh/authorized_keys&quot; -k ▲注意 如果被控制主机中用户家目录中不存在.ssh目录，就创建。 然后将上传的公钥文件追加到用户的authorized_keys文件中 法二: (亲测) 通过authorized_key模块来进行添加 1ansible para -i /tmp/inventory.txt -m authorized_key -a \"user=root key='&#123;&#123; lookup('file','/root/.ssh/id_rsa.pub') &#125;&#125;'\" -k lookup('file','/root/.ssh/id_rsa.pub') 是读取/root/.ssh/id_rsa.pub的内容 使用公钥密钥对验证的方法登录 1. 在本地也创建一个 apple 用户,并创建 /home/apple/.ssh/ 目录 $ useradd apple -s /bin/bash -d /home/apple/ 创建 .ssh 目录mkdir /home/apple/.ssh 修改 .ssh 目录的权限chmod 700 /home/apple/.ssh 创建 /home/apple/.ssh/known_hosts 文件 2.收集所有远程主机的公钥，保存在上 /home/apple/.ssh/known_hosts 文件。这一步的作用，是为了在后面第一次ssh 连接时，不需要再输密码。 收集所有远程主机的 公钥，主要是利用 ssh-keyscan 命令：ssh-keyscan -f ip.txt &gt;&gt; /home/apple/.ssh/known_hosts 说明： ip.txt 文件存放所有的远程主机 ip 地址，一行代表一台主机。 3.创建公钥私钥对： 一般在对应用户的 /home/apple/.ssh/ 目录下创建。这也不是强制的，因为在ssh 发起连接时，可以指定使用的私钥文件。 ssk-keygen -t rsa 一直按回车键就可以了。但要注意生成的 id_rsa 和 id_rsa.pub 存放的路径。 4.将公钥推送到所有的远程主机 我们编写playbook 文件，利用authorized_key 模块就可以快速完成： 12345678[root@centos_7 roles]$ cat ssh-addkey.yml ---- hosts: apps 对apps 组里的所有远程主机 gather_facts: False tasks: - name: install sshkey authorized_key: user: apple key: \"&#123;&#123; lookup('file', '/home/apple/.ssh/id_rsa.pub') &#125;&#125;\" state: present 说明： 在前面1,2,3步中，我们已经准备好了公私钥对了。推送到远程主机，可以手动推送，或者使用scp 复制到远程主机。但是利用scp 复制之后，还需要修改远程主机上的 /home/apple/.ssh/authorize_keys 文件的权限等等。 ansible 的 authorized_key 模块就自动帮我们做了这些工作。 执行， ansible-playbook ssh-addkye.yml 在多台远程主机中创建用户 不用ansible，单个操作 1234567891011121314151617 在 root 用户下运行这条命令创建一个新用户，yangxg 是用户名 因为我叫杨学光，所以我取的用户名是 yangxg 选择一个你喜欢的用户名，不一定非得和我的相同root@localhost:~ useradd -m -s /bin/bash yangxg 把新创建的用户加入超级权限组root@localhost:~ usermod -a -G sudo yangxg 为新用户设置密码 注意在输密码的时候不会有字符显示，不要以为键盘坏了，正常输入即可root@localhost:~ passwd yangxg 切换到创建的新用户root@localhost:~ su - yangxg 切换成功，@符号前面已经是新用户名而不是 root 了yangxg@localhost:~$ ansible 1234567891011121314---- hosts: all vars: user: test password: \"$6$rounds=100000$O2BHfT2XIF6oDb9w$8Hhv4vOrLN6JF/nRVYDd8zZdnn9TNkQutyYYywIcPF2kRiHgkwAjqHIN7sDUkd1DcjLRABWT9ULHZPBOF2bZS/\" remote_user: root tasks: - name: Add user &#123;&#123; user &#125;&#125; user: name=&#123;&#123;user&#125;&#125; comment=\"ceph user\" password=&#123;&#123; password &#125;&#125; - name: Config /etc/sudoers lineinfile: dest=/etc/sudoers state=present line='&#123;&#123;item&#125;&#125;' validate='visudo -cf %s' with_items: - \"&#123;&#123; user&#125;&#125; ALL=(ALL) NOPASSWD: ALL\" - \"Defaults: &#123;&#123;user&#125;&#125; !requiretty\" 12345678$ python -c 'import crypt; print crypt.crypt(\"rescue\", \"hadoop\")' hadoop为salt，可以改成其他的。rescue是需要加密的内容$ ansible rescue -m user -a \"name=rescue shell=/bin/bash home=/home/rescue password= state=present\" -b -K$ ansible rescue -m shell -a \"usermod -a -G sudo rescue\" -b -K user模块增加 update_password=always时，可以更新密码 一键挂载NFS: ansible full -m mount -a &quot;name=/data src=192.168.100.179:/data fstype=nfs state=mounted&quot; -b -K 挂载需要用SUDO权限,所以-K必不可少.同时,在这之前已经使用过ssh进行了配对因此不需要输入登录用户密码. 其他命令记录 ss -ntl | grep 80 vim /etc/sysconfig/network-scripts/ifcfg-eth0建议可以使用Alias service network restart重启网络服务","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://nymrli.top/tags/运维/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"staticmethod和classmethod区别","slug":"staticmethod和classmethod区别","date":"2019-07-07T02:06:00.000Z","updated":"2019-09-15T08:07:31.006Z","comments":true,"path":"2019/07/07/staticmethod和classmethod区别/","link":"","permalink":"https://nymrli.top/2019/07/07/staticmethod和classmethod区别/","excerpt":"","text":"staticmethod和classmethod 类的实例化基本遵循创建实例对象、初始化实例对象、最后返回(产生)实例对象这么一个过程 123456789101112131415161718class Test(object): data = 'world' # 类对象的数据成员 def __init__(self, arg): self.arg = arg @staticmethod # 静态方法，不能访问类数据成员 def func(): print(\"hello\") @classmethod # 类方法,能访问类数据成员 def getData(cls): print(cls.data)if __name__ == '__main__': t = Test('A') Test.func() Test.getData() 共同: 两个都是装饰器，装饰的成员函数可以通过类名.方法名(...)来调用 区别: ▲最显著的特点是classmethod需要传递一个参数cls，而staticmethod不需要。因此可以访问、修改类的属性，类的方法，实例化对象等，避免硬编码；而staticmethod不行 classmethod可以判断出自己是通过基类被调用，还是通过某个子类被调用 用途： classmethod多用于设计模式之工厂模式，将解析逻辑封装在方法本身内部。（也可认为构造前交互，即在进行实例化类对象之前先进行某些逻辑操作，即可看作进行不同的构造函数，然后返回一个类实例，见具体代码）,更多拓展见附录__new__和__init__ staticmethod用法就跟其他的语言中的静态static用法相同（可看作是属于该类的一个工具、辅助函数） 具体代码 12345678910111213141516171819202122232425# Python program to demonstrate # use of class method and static method. class time(object): def __init__(self, year): super(time, self).__init__() self.year = year print(self.year) # a class method to create a time that one day following the data 'year' @classmethod def tomorrow(cls,year): print(type(cls)) # &gt;&gt;&gt; ▲ Python所有类都继承自`&lt;class 'type'&gt;`，包括新式类`object` return cls(year+1) # a static method to check whether the given data 'year' is after 2000. @staticmethod def twoThoundYear(year): return year&gt;2000if __name__ == '__main__': t1 = time(1999) t2 = time.tomorrow(1999) print( time.twoThoundYear(2001) ) 可看下这篇class method vs static method in Python 附录__new__和__init__ 知识点 ▲1. 首先要弄懂调用顺序__new__–&gt;__init__： 所以__init__其实不是实例化一个类的时候第一个被调用 的方法。当使用 Persion(name, age) 这样的表达式来实例化一个类时，最先被调用的方法 其实是__new__方法。 __new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供（实例化时加的参数，也会被认为时cls的属性，见①）。即系统知道__new__() 方法始终都是类的类方法，即使没有被加上类方法装饰器。 __new__方法接受的参数虽然也是和__init__一样，但__init__是在类实例创建之后调用，而 __new__方法正是创建这个类实例的方法。 ▲2. __init__有一个参数self，就是这个__new__中return的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值。而__new__必须有（可以return父类__new__出来的实例，或者直接是object的__new__出来的实例）。__new__方法决定了创建哪个类的实例（可以是父类，也可以是子类），因此不一定调用当前类的__init__。即（若__new__没有正确返回当前类cls的实例，那__init__是不会被调用的，即使是父类的实例也不行） 3.继承自object的新式类才有__new__，同时，在任何新式类的__new__()方法，不能调用自身的__new__()来制造实例，因为这会造成死循环，即class Foo(object)的__new__中不能Foo.__new__(cls, *args, **kwargs)。 区别 1.__init__ 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。 2.__new__ 通常用于控制生成一个新实例的过程。它是类级别的方法。 依照Python官方文档的说法，__new__方法主要是当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的metaclass。 12345678910111213141516171819202122class A(object): # 新式类:继承自object def __init__(self,something): print('init') print(something) # def __new__(cls): 不行，因为A(\"...\")参数不匹配 # pass def __new__(cls, *args, **kwargs): print('new') self = object.__new__(cls) # ①cls中包含了*args, **kwargs信息 self.x = '1' return self # 调用父类的`__new__`方法会返回一个A对象，init里的参数self调用的就是这个self实例 # `__new__`必须具有返回值，否则无法创建对象，因为`__init__`函数需要这个返回值 # 自己在定义`__new__`的时候，参数要与`__init__`函数的参数匹配，我可以不用到这些参数，但一定要匹配。或者可以使用*arg和**args的形式。if __name__ == '__main__': # a = A.__new__(A) #&gt;&gt;&gt; new a = A('do it') # &gt;&gt;&gt; new init print(a.__dict__) # &#123;'x': '1'&#125; # 2、new定义在type元类中，必须具有返回值， # 3、new的作用就是创建实例，然后将创建的实例传递给init进行初始化 总结： a = A() --&gt; __new__方法，return调用父类__new__生成一个类实例对象 --&gt;__init__(self,...)中的self实例就是这个父类__new__出来的实例 __new__() 是在新式类中新出现的方法，它作用在构造方法建造实例之前，可以这么理解，在 Python 中存在于类里面的构造方法 __init__() 负责将类的实例化，而在 __init__() 启动之前，__new__() 决定是否要使用该 __init__() 方法，因为__new__() 可以调用其他类的构造方法或者直接返回别的对象来作为本类的实例。 用__new__来实现设计模式中的–单例模式 只能实例化一个类对象 12345class Singleton(object): def __new__(cls, *args, **kwargs): if not hasattr(cls, 'instance'): cls.instance = super(Singleton, cls).__new__(cls, *args, **kwargs) return cls.instance ▲ Python所有类都继承自&lt;class 'type'&gt;，包括新式类object","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"yaml基础语法_spring_boot","slug":"yaml基础语法-spring-boot","date":"2019-07-07T02:04:35.000Z","updated":"2019-09-15T08:07:31.018Z","comments":true,"path":"2019/07/07/yaml基础语法-spring-boot/","link":"","permalink":"https://nymrli.top/2019/07/07/yaml基础语法-spring-boot/","excerpt":"","text":"yaml基础语法_spring_boot yaml aren’t markup language 即yaml不是标语语言： xml（标记语言）: 1234&gt; &lt;server&gt;&gt; &lt;port&gt;8888&lt;/port&gt;&gt; &lt;/server&gt;&gt; java spring boot默认全局配置文件: application.properties 使用的时 key=value application.yaml: k:v 通过缩进，垂直对齐指定层次关系 字符串可以默认不写引号，写引号中的转义符会被翻译：e.g.&quot;天\\n津&quot; 12345678910111213141516171819202122server: port: 8888student: name: 张三 age: 18 birthday: 2019/07/19 location: # &lt;==&gt; &#123;province: 陕西, city: 西安&#125; 行内写法 province: 陕西 city: 西安 # 对应java里的字典map hobbies: # &lt;==&gt; [足球,篮球] - 足球 - 篮球 # 对应java里的列表List skills: # &lt;==&gt;[编程,金融] - 编程 - 金融 # 对应java里的集合set pet: # &lt;==&gt;&#123;name: wc, type: hsq&#125; name: wc type: hsq # entity的另一个类pet.java [Set,List,数组\\Array]、{Map、对象类型的属性StudentPet}，[]可以省略，{}不可以省略","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"Python类的继承-super()使用","slug":"Python类的继承-super-使用","date":"2019-07-07T02:03:49.000Z","updated":"2019-09-15T08:07:30.997Z","comments":true,"path":"2019/07/07/Python类的继承-super-使用/","link":"","permalink":"https://nymrli.top/2019/07/07/Python类的继承-super-使用/","excerpt":"","text":"Python类的继承即super()使用 Super super() 函数是用于调用父类(超类)的一个方法，只有在新式类中可以使用 super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO，Method Resolution Order，采用广度优先（区别于深度优先）的规则定义）、重复调用（钻石继承）等种种问题。 MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。 语法 以下是 super() 方法的语法: 1234# 菜鸟教程super(type [, object-or-type])# 个人理解super( ThisClass [, object(self)]) 参数 type – 类（type），通常是当前子类。 object-or-type – 类实例，一般是 self 含义 用self这个实例对象去查找ThisClass类的父类拥有的属性（成员方法、数据成员） ▲. Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx : 即平时写的 1234567class TestClass(object): def __init__(self, *arg, **kwarg): super(TestClass, self).__init__() # 此时init里不用self # 等价于 super().__init__() , 含义是用父类的构造函数初始化某些变量 # 相当于旧式类的 object.__init__(self) # 需要传参self self.arg = arg self.kwarg = kwarg 完整代码 12345678910111213141516class clsSuper(object): age = 18 def __init__(self, name): print(name)class clsSub(clsSuper): def __init__(self): print(super().age) # 当只是单继承的时候可以直接使用 print(clsSuper.age)，if __name__ == '__main__': a = clsSuper('cl') b = clsSub() 特点 super().func()是不用传参self的 super(type, obj).func()函数调用的是obj实例在MRO中下一个父类的可调用func()，而不是type的父类中的func()。即调用最近的可用func() 使用super()不用指定父类的名称，便于修改维护；同时当继承多个类A、B的时候，用super().__init__()相当于调用多个类的A.__ini__(self)、B.__ini__(self) 与java对比 Python中子类不会默认调用父类的构造函数，即下面代码。并不会要要求给传name。当然也可以理解为跟java一样调用了一个全空、没有任何内容的构造函数，但是在python中不需要显性写出来，原因部分是特点2（java中存在有参数的构造函数时，必须将空参数的构造函数显式写出，不然子类默认隐式调用空参数的构造函数时会报错说不存在）。 Python中的构造函数只有一个。但由于存在*arg,**kwarg的存在，所以只要执行类型检查执行不同的代码；即实现了多个构造函数 Python的类可以多继承，java只能单继承。 123456789101112131415161718192021class clsSuper(object): age = 18 def __init__(self, name): self.name = name print(self.name)class clsSub(clsSuper): def __init__(self, age): print(age)'''class clsSub(clsSuper): def __init__(self, age): super().__init__() #调用父类的构造函数 print(age)''' if __name__ == '__main__': b = clsSub(18)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Base64编码原理与应用[转]","slug":"Base64编码原理与应用[转]","date":"2019-06-15T04:08:53.000Z","updated":"2019-09-15T08:07:30.921Z","comments":true,"path":"2019/06/15/Base64编码原理与应用[转]/","link":"","permalink":"https://nymrli.top/2019/06/15/Base64编码原理与应用[转]/","excerpt":"","text":"Base64编码原理与应用[转] 2015年，我们在青云平台上实现了“百度云观测”应用。青云应用本质上是一个iframe，在向iframe服务方发送的请求中会携带一些数据，青云平台会使用Base64 URL对这些数据进行编码，其提供的编码解码算法示例如下： 12345678// php版本function base64_URL_encode($data) &#123; return rtrim(strtr(base64_encode($data), '+/', '-_'), '=');&#125;function base64_URL_decode($data) &#123; return base64_decode(str_pad(strtr($data, '-_', '+/'), strlen($data) % 4, '=', STR_PAD_RIGHT));&#125; 可以看出，Base64 URL 是标准Base64编码的一个变种，分别用 -、_ 替换标准Base64编码结果中的 + 、 / ，并删除结果最后的 = 。 在实现 “百度云观测” 青云应用时，我在想： 为什么要使用Base64编码？ Base64编码算法是什么样的？ 本文是围绕这两个问题思考和实践的结果。 我认为，理解Base64或其他类似编码的关键有两点： 计算机最终存储和执行的是01二进制序列，这个二进制序列的含义则由解码程序/解释程序决定 很多场景下的数据传输要求数据只能由简单通用的字符组成，比如HTTP协议要求请求的首行和请求头都必须是ASCII编码 以青云应用为例，简单解释这两点。青云平台通过POST一个表单来获取iframe，表单有 payload 和 signature 两项， payload 原本是一个JSON对象，其中的键值可能包含一些特殊字符，比如 &amp;、/ 等，由于青云设计的一种通用的请求交互方案，需要考虑iframe服务方服务器端的各种可能实现，有些服务器端实现没有考虑表单值有这些特殊字符，或者POST请求被中间服务器转换成GET请求再次发出，对于URL来说，&amp;、/都是具有特殊含义的字符，所以需要对请求数据进行特殊编码避免这些字符出现 - 数据发送方对数据按规则进行编码，接收方对应地按规则解码数据。 Base64编码原理 Base64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码。标准Base64编码使用的64个字符为： 这64个字符是各种字符编码（比如ASCII编码）所使用字符的子集，基本，并且可打印。唯一有点特殊的是最后两个字符，因对最后两个字符的选择不同，Base64编码又有很多变种，比如Base64 URL编码。 Base64编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续6比特（2的6次方=64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。 假设我们要对 Hello! 进行Base64编码，按照ASCII表，其转换过程如下图所示： 可知 Hello! 的Base64编码结果为 SGVsbG8h ，原始字符串长度为6个字符，编码后长度为8个字符，每3个原始字符经Base64编码成4个字符，编码前后长度比4/3，这个长度比很重要 - 比原始字符串长度短，则需要使用更大的编码字符集，这并不我们想要的；长度比越大，则需要传输越多的字符，传输时间越长。Base64应用广泛的原因是在字符集大小与长度比之间取得一个较好的平衡，适用于各种场景。 是不是觉得Base64编码原理很简单？ 但这里需要注意一个点：Base64编码是每3个原始字符编码成4个字符(如Hel被编成了SGVs)，如果原始字符串长度不能被3整除，那怎么办？使用0值来补充原始字符串。===&gt;Base64的编码长度为4的倍数。 以 Hello!! 为例，其转换过程为： 注：图表中蓝色背景的二进制0值是额外补充的。 Hello!! Base64编码的结果为 SGVsbG8hIQAA 。最后2个零值只是为了Base64编码而补充的，在原始字符中并没有对应的字符，那么Base64编码结果中的最后两个字符 AA 实际不带有效信息，所以需要特殊处理，以免解码错误。 标准Base64编码通常用 = 字符来替换最后的 A（完全由补充的0组成的A，跟b'H'的结果SA==区别一下），即编码结果为 SGVsbG8hIQ==。因为 = 字符并不在Base64编码索引表中，其意义在于结束符号，在Base64解码时遇到 = 时即可知道一个Base64编码字符串结束。 如果Base64编码字符串不会相互拼接再传输，那么最后的 = 也可以省略，解码时如果发现Base64编码字符串长度不能被4整除，则先补充 = 字符，再解码即可。 解码是对编码的逆向操作，但注意一点：对于最后的两个 = 字符，转换成两个 A 字符，再转成对应的两个6比特二进制0值，接着转成原始字符之前，需要将最后的两个6比特二进制0值丢弃，因为它们实际上不携带有效信息。 为了理解Base64编码解码过程，个人实现了一个非常简陋的Base64编码解码程序，见：youngsterxyf/xiaBase64。 由于Base64应用广泛，所以很多编程语言的标准库都内置Base64编码解码包，如： PHP：base64_encode、base64_decode Python：base64包 Go：encoding/base64 … Base64编码应用 本文开始提到的青云应用例子只是Base64编码的应用场景之一。由于Base64编码在字符集大小与编码后数据长度之间做了较好的平衡，以及Base64编码变种形式的多样，使得Base64编码的应用场景非常广泛。下面举2个常用常见的例子。 HTML内嵌Base64编码图片 前端在实现页面时，对于一些简单图片，通常会选择将图片内容直接内嵌在页面中，避免不必要的外部资源加载，增大页面加载时间，但是图片数据是二进制数据，该怎么嵌入呢？[绝大多数现代浏览器](http://caniuse.com/#search=Data URI)都支持一种名为 Data URLs 的特性，允许使用Base64对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。以百度搜索首页为例，其中语音搜索的图标是个背景图片，其内容以 Data URLs 形式直接写在css中，这个css内容又直接嵌在HTML页面中，如下图所示： Data URLs 格式为：url(data:文件类型;编码方式,编码后的文件内容)。 当然，也可以直接基于image标签嵌入图片，如下所示： 1&lt;img alt=&quot;Embedded Image&quot; src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIA...&quot; /&gt; 但请注意：如果图片较大，图片的色彩层次比较丰富，则不适合使用这种方式，因为其Base64编码后的字符串非常大，会明显增大HTML页面，影响加载速度。 MIME（多用途互联网邮件扩展） 我们的电子邮件系统，一般是使用SMTP（简单邮件传输协议）将邮件从客户端发往服务器端，邮件客户端使用POP3（邮局协议，第3版本）或IMAP（交互邮件访问协议）从服务器端获取邮件。 SMTP协议一开始是基于纯ASCII文本的，对于二进制文件（比如邮件附件中的图像、声音等）的处理并不好，所以后来新增MIME标准来编码二进制文件，使其能够通过SMTP协议传输。 举例来说，我给自己发封邮件，正文为空，带一个名为hello.txt的附件，内容为 您好！世界！。导出邮件源码，其关键部分如下图所示： MIME-Version: 1.0：表示当前使用MIME标准1.0版本。 Content-Type: text/plain; name=&quot;hello.txt&quot;：表示附件文件名为 hello.txt ，格式为纯文本。 Content-Transfer-Encoding: base64：表示附件文件内容使用base64编码后传输。 5oKo5aW977yM5LiW55WM77yB：则是文件内容 您好，世界！ Base64编码后的结果。 不过，MIME使用的不是标准Base64编码。 切忌误用 可能会有人在不理解Base64编码的情况下，将其误用于数据加密或数据校验。 Base64是一种数据编码方式，目的是让数据符合传输协议的要求。标准Base64编码解码无需额外信息即完全可逆，即使你自己自定义字符集设计一种类Base64的编码方式用于数据加密，在多数场景下也较容易破解。 对于数据加密应该使用专门的目前还没有有效方式快速破解的加密算法。比如：对称加密算法AES-128-CBC，对称加密需要密钥，只要密钥没有泄露，通常难以破解；也可以使用非对称加密算法，如 RSA，利用极大整数因数分解的计算量极大这一特点，使得使用公钥加密的数据，只有使用私钥才能快速解密。 对于数据校验，也应该使用专门的消息认证码生成算法，如 HMAC - 一种使用单向散列函数构造消息认证码的方法，其过程是不可逆的、唯一确定的，并且使用密钥来生成认证码，其目的是防止数据在传输过程中被篡改或伪造。将原始数据与认证码一起传输，数据接收端将原始数据使用相同密钥和相同算法再次生成认证码，与原有认证码进行比对，校验数据的合法性。 那么针对各大网站被脱库的问题，请问应该怎么存储用户的登录密码？ 答案是：在注册时，根据用户设置的登录密码，生成其消息认证码，然后存储用户名和消息认证码，不存储原始密码。每次用户登录时，根据登录密码，生成消息认证码，与数据库中存储的消息认证码进行比对，以确认是否为有效用户，这样即使网站被脱库，用户的原始密码也不会泄露，不会为用户使用的其他网站带来账号风险。 当然，使用的消息认证码算法其哈希碰撞的概率应该极低才行，目前一般在HMAC算法中使用SHA256。对于这种方式需要注意一点：防止用户使用弱密码，否则也可能会被暴力破解。现在的网站一般要求用户密码6个字符以上，并且同时有数字和大小写字母，甚至要求有特殊字符。 另外，也可以使用加入随机salt的哈希算法来存储校验用户密码。这里暂不细述。 总结 Base64兼顾字符集大小和编码后数据长度，并且可以灵活替换字符集的最后两个字符，以应对多样的需求，使其适用场景非常广泛。 当然，很多场景下有多种编码方式可选择，并非Base64编码不可，视需求，权衡利弊而定。 补充 Base64、Base32、Base16区别 标准Base64： 包含大写字母（A-Z）,小写字母（a-z），数字（0-9）以及+/; Base32: 而Base32中只有大写字母（A-Z）和数字234567； Base16: 而Base16就是16进制，他的范围是数字(0-9)，字母（ABCDEF）； 顺便说一句，当ASCll用Base加密达不到所对应的位数的时候用=号补齐； 在这里附带由三种Base加密的:I love you！ Base64:SSBsb3ZlIHlvde+8gQ== Base32:JEQGY33WMUQHS33V566IC=== Base16:49206c6f766520796f75efbc81 1.由上可知，Base64编码后字符串长度为4的倍数 2.标准Base64编码通常用 = 字符来替换最后的 A（完全由补充的0组成的A，跟b'H'的结果SA==区别一下，SA==的A并不是全部由补充的0组成）","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"}]},{"title":"Python的构建工具setup.py","slug":"Python的构建工具setup-py","date":"2019-06-15T04:08:44.000Z","updated":"2019-09-15T08:07:30.996Z","comments":true,"path":"2019/06/15/Python的构建工具setup-py/","link":"","permalink":"https://nymrli.top/2019/06/15/Python的构建工具setup-py/","excerpt":"","text":"Python的构建工具setup.py setup.py各参数介绍： 12345678910111213141516171819202122232425--name 库名称，▲需要注意的是不要大写，不然会有坑--version (-V) 包版本--author 程序的作者--author_email 程序的作者的邮箱地址--maintainer 维护者--maintainer_email 维护者的邮箱地址--url 程序的官网地址--license 程序的授权信息--description 程序的简单描述--long_description 程序的详细描述--platforms 程序适用的软件平台列表--classifiers 程序的所属分类列表--keywords 程序的关键字列表--packages 需要处理的包目录（包含__init__.py的文件夹） --py_modules 需要打包的python文件列表--download_url 程序的下载地址--cmdclass --data_files 打包时需要打包的数据文件，如图片，配置文件等--scripts 安装时需要执行的脚步列表--package_dir 告诉setuptools哪些目录下的文件被映射到哪个源码包。一个例子：package_dir = &#123;&apos;&apos;: &apos;lib&apos;&#125;，表示“root package”中的模块都在lib 目录中。--requires 定义依赖哪些模块 --provides定义可以为哪些模块提供依赖 --find_packages() 对于简单工程来说，手动增加packages参数很容易，刚刚我们用到了这个函数，它默认在和setup.py同一目录下搜索各个含有 __init__.py的包。--install_requires = [&quot;requests&quot;] 需要安装的依赖包--entry_points 动态发现服务和插件，下面详细讲 find_packages()还可以将包统一放在一个src目录中，另外，这个包内可能还有aaa.txt文件和data数据文件夹。另外，也可以排除一些特定的包 find_packages(exclude=[&quot;*.tests&quot;, &quot;*.tests.*&quot;, &quot;tests.*&quot;, &quot;tests&quot;]) 实测操作 需要事前交代的内容 模板setup.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#!/usr/bin/env python# -*- coding: utf-8 -*-# Note: To use the 'upload' functionality of this file, you must:# $ pip install twineimport ioimport osimport sysfrom shutil import rmtreefrom setuptools import find_packages, setup, Command# Package meta-data.NAME = 'cltest'DESCRIPTION = 'know how to'URL = ''EMAIL = '10630529664@qq.com'AUTHOR = 'Gao Liang'REQUIRES_PYTHON = '&gt;=3.0.0'VERSION = '0.3.0'# What packages are required for this module to be executed?REQUIRED = [ 'requests &gt;= 2.20.0',]# The rest you shouldn't have to touch too much :)# ------------------------------------------------# Except, perhaps the License and Trove Classifiers!# If you do change the License, remember to change the Trove Classifier for that!here = os.path.abspath(os.path.dirname(__file__))# Import the README and use it as the long-description.# Note: this will only work if 'README.md' is present in your MANIFEST.in file!try: with io.open(os.path.join(here, 'README.md'), encoding='utf-8') as f: long_description = '\\n' + f.read()except FileNotFoundError: long_description = DESCRIPTION# Load the package's __version__.py module as a dictionary.about = &#123;&#125;if not VERSION: with open(os.path.join(here, NAME, '__version__.py')) as f: exec(f.read(), about)else: about['__version__'] = VERSIONclass UploadCommand(Command): \"\"\"Support setup.py upload.\"\"\" description = 'Build and publish the package.' user_options = [] @staticmethod def status(s): \"\"\"Prints things in bold.\"\"\" print('\\033[1m&#123;0&#125;\\033[0m'.format(s)) def initialize_options(self): pass def finalize_options(self): pass def run(self): try: self.status('Removing previous builds…') rmtree(os.path.join(here, 'dist')) except OSError: pass self.status('Building Source and Wheel (universal) distribution…') os.system('&#123;0&#125; setup.py sdist bdist_wheel --universal'.format(sys.executable)) self.status('Uploading the package to PyPI via Twine…') os.system('twine upload dist/*') self.status('Pushing git tags…') os.system('git tag v&#123;0&#125;'.format(about['__version__'])) os.system('git push --tags') sys.exit()# Where the magic happens:setup( name=NAME, version=about['__version__'], description=DESCRIPTION, long_description=long_description, long_description_content_type='text/markdown', author=AUTHOR, author_email=EMAIL, python_requires=REQUIRES_PYTHON, url=URL, packages=find_packages(exclude=('tests',)), # If your package is a single module, use this instead of 'packages': # py_modules=['mypackage'], # entry_points=&#123; # 'console_scripts': ['mycli=mymodule:cli'], # &#125;, install_requires=REQUIRED, include_package_data=True, license='MIT', classifiers=[ # Trove classifiers # Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers 'License :: OSI Approved :: MIT License', 'Programming Language :: Python', 'Programming Language :: Python :: 3', 'Programming Language :: Python :: 3.6', 'Programming Language :: Python :: Implementation :: CPython', 'Programming Language :: Python :: Implementation :: PyPy' ], # $ setup.py publish support. cmdclass=&#123; 'upload': UploadCommand, &#125;,) 待打包的目录树： E:. │ MANIFEST.in │ out.json │ README.md │ setup.py │ └─files in.json txt.txt world.py __init__.py 12345678910ACCOUNT = 'mrli'def printHello(): print(\"hello &#123;&#125;\".format(ACCOUNT))def readTXT(): with open('txt.txt', 'r') as f: print(f.read()) # print( os.listdir() ) MANIFEST.in内容 MANIFEST.in决定了除了Py文件外的什么说明、配置文件会被打包进去(如.txt、.json) 12345678# Include the READMEinclude *.md# Include the txt fileinclude */*.txt# Include the data files# recursive-include xxxx/utils */*.json 注意我操作这边时并没有include json文件，所以生成的项目树中也没有任何的json文件（无论是in.json还是out.json），而txt.txt是包含的，并且之后甚至能用readTXT()函数，直接读取打包的txt.txt的内容。 关于MANIFEST.in 项目里会有一些非py文件，比如html和js等，这时候就要靠include_package_data 和 package_data及packages来指定了。package_data一般写成 {'your_package_name': [&quot;files&quot;]}。keywords便于pypi索引。 ▲.然而只设置了include_package_data还没完，还需要一个MANIFEST.in文件来明确指定哪些文件需要打到包中。===&gt;如果include_package_data=True的话，那么还需要写个MANIFEST.in来明确。 python setup.py install安装 安装后的目录树 │ MANIFEST.in │ out.json(这是原来就在的) │ README.md │ setup.py │ ├─build（生成的文件夹） │ ├─bdist.win-amd64 │ └─lib │ └─files │ txt.txt │ world.py │ init.py │ ├─cltest.egg-info（生成的文件夹） │ dependency_links.txt │ PKG-INFO │ requires.txt │ SOURCES.txt │ top_level.txt │ ├─dist（生成的文件夹） │ cltest-0.3.0-py3.7.egg │ └─files in.json txt.txt world.py __init__.py 一共生成了3个文件夹为build、dist、cltest.egg-info， build\\lib下的就是自己想要打包的库的内容，即files里的模块。 dist是加入到虚拟环境库下的文件venv\\Lib\\site-packages中可以找到cltest-0.3.0-py3.7.egg cltest.egg-info中有生成很多文件 dependency_links.txt空的 PKG-INFO内容是setup.py中设置的，关于库的描述 1234567891011121314151617181920212223Metadata-Version: 2.1Name: cltestVersion: 0.3.0Summary: know how toHome-page: UNKNOWNAuthor: Gao LiangAuthor-email: 10630529664@qq.comLicense: MITDescription: # 测试Setup工具 hhhh Platform: UNKNOWNClassifier: License :: OSI Approved :: MIT LicenseClassifier: Programming Language :: PythonClassifier: Programming Language :: Python :: 3Classifier: Programming Language :: Python :: 3.6Classifier: Programming Language :: Python :: Implementation :: CPythonClassifier: Programming Language :: Python :: Implementation :: PyPyRequires-Python: &gt;=3.0.0Description-Content-Type: text/markdown requires.txt：内容是setup.py中install_requires=REQUIRED里设置的依赖内容，写法参看requirements.txt SOURCES.txt：列出了所有被打包的文件 1234567891011MANIFEST.inREADME.mdsetup.pycltest.egg-info/PKG-INFOcltest.egg-info/SOURCES.txtcltest.egg-info/dependency_links.txtcltest.egg-info/requires.txtcltest.egg-info/top_level.txtfiles/__init__.pyfiles/txt.txtfiles/world.py top_level.txt：列出了可用的模块，应该是由packages=find_packages(exclude=('tests',)),决定的，由于我只写了一个包files，所以内容也只有 1files 如何使用？ 这边需要注意的是在setup.py中设置name='cltest'是指的整个库的名字，但真正使用的是要看这个库下有哪些可用的包，包下有哪些模块。 在我的这个例子下面，可以通过库名cltest来找到、下载我这个库。在安装完以后，导入就得知道包名了，这边是files，所以使用得代码应该是 12from files import worldworld.readTXT() 这个现象其实还挺常见的，比如beautifulSoup4库，使用的时候是from bs4 import ..；以及python-opencv2库，需要import cv2 as cv。其实就是这边库名与包名的区别。 坑点记录: 1234567from files import world'''def readTXT(): with open('txt.txt', 'r') as f: print(f.read())'''world.readTXT() 由于’txt.txt’是相对路径，所以只有在运行脚本位置有txt.txt文件时才不会报错，一开始from files import world时报错txt.txt以为时txt.txt没有被打包进去（其实可以通过Sources.txt文件查看到底有没有被打包进去），后来才明白是使用readTXT()的当前目录下不存在而已。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Oauth2原理、使用","slug":"Oauth2原理、使用","date":"2019-06-03T13:22:30.000Z","updated":"2019-09-15T08:07:30.966Z","comments":true,"path":"2019/06/03/Oauth2原理、使用/","link":"","permalink":"https://nymrli.top/2019/06/03/Oauth2原理、使用/","excerpt":"","text":"Oauth2原理、使用 原理 快递员–&gt;门禁–&gt;小区–&gt;我家 &lt;=====&gt; 第三方应用 --&gt; 微信墙 —&gt;账号–&gt;个人数据 简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。 OAuth 的核心就是向第三方应用颁发令牌 令牌特点： （1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。 （2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。 （3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。 OAuth是什么？ 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。…资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。 四种获得令牌的流程: 授权码（authorization-code） 1.发送请求A-&gt;B 12345https://b.com/oauth/authorize? response_type=code&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read A（客户端）-&gt;B（）response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。 第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像https://a.com/callback?code=AUTHORIZATION_CODE 第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。 123456https://b.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL 上面 URL 中，client_id参数和client_secret参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uri参数是令牌颁发后的回调网址。 第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。 123456789&#123; \"access_token\":\"ACCESS_TOKEN\", \"token_type\":\"bearer\", \"expires_in\":2592000, \"refresh_token\":\"REFRESH_TOKEN\", \"scope\":\"read\", \"uid\":100101, \"info\":&#123;...&#125;&#125; 上面 JSON 数据中，access_token字段就是令牌，A 网站在后端拿到了。 隐藏式（implicit） 有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。 12345https://b.com/oauth/authorize? response_type=token&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read response_type参数为token，表示要求直接返回令牌。 https://a.com/callback#token=ACCESS_TOKEN``token参数就是令牌，A 网站因此直接在前端拿到令牌。 ▲注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在&quot;中间人攻击&quot;的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。 密码式（password）： 如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为&quot;密码式&quot;（password）。 客户端凭证（client credentials） 适用于没有前端的命令行应用，即在命令行下请求令牌。 clientID和ClientSecret均是App需要申请的API密钥 使用 Github Oauth QQ Oauth 本地测试QQ的写法 12345678910111213141516171819202122232425262728293031323334353637383940414243# 方法一：在hosts中将nymrli.top修改到127.0.0.1@app.route('/login')def login(): params = &#123; 'response_type' : 'code', 'client_id' : '101568872', 'redirect_uri' : 'http://beta.nymrli.top/oauth/qq', 'state' : '1', &#125; url = 'https://graph.qq.com/oauth2.0/authorize?' urlParams = urlencode(params) # ▲需要url编码 comleteUrl = url + urlParams # return url_for( ) ''' ▲应该用redirect，而不是requests.get的text内容或者是url_for ''' return redirect( comleteUrl) @app.route('/oauth/qq')def getCode(): return request.args.get('code') # 方法二：随便申请一个应用@app.route('/login')def login(): params = &#123; 'response_type' : 'code', 'client_id' : '101584056', # 'redirect_uri' : 'http://beta.nymrli.top/oauth/qq', 'redirect_uri' : 'http://127.0.0.1:8000/oauth/redirect', 'state' : 'test' &#125; url = 'https://graph.qq.com/oauth2.0/authorize?' urlParams = urlencode(params) comleteUrl = url + urlParams return redirect( comleteUrl)@app.route('/oauth/redirect')def getCode(): print(request.args) return 'hello' 坑点记录：部署 经过调试发现部署上去后，在http://beta.nymrli.top/info页面下获得不到 access_token = session.get('access_token')于是猜想session设置有问题。果然linux下os.urandom(24)有问题， 结果是无法获得到信息。经修改后能正常获得结果 1SECRET_KEY= os.urandom(24) # 设置为24位的字符,每次运行服务器都是不同的，所以服务器启动一次上次的session就清除。 改成随便的SECRET_KEY的就行了，比如SECRET_KEY='asdzxcqwe'","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Web","slug":"Web","permalink":"https://nymrli.top/tags/Web/"}]},{"title":"lua学习","slug":"lua学习","date":"2019-06-03T13:22:03.000Z","updated":"2019-09-15T08:07:30.962Z","comments":true,"path":"2019/06/03/lua学习/","link":"","permalink":"https://nymrli.top/2019/06/03/lua学习/","excerpt":"","text":"lua学习 动态脚本语言，可嵌入C和C++，Lua负责逻辑，C、C++负责功能 C编译，跨平台性良好 12345678910111213141516-- 循环结构 [1,10]for i=1,10 do print(i)end-- 函数function function_name( ... ) -- bodyend-- 选择结构if elseend 表{} &lt;==&gt;字典 12345678910Conftg=&#123; hello=\"Hello Lua\", world=\"World\"&#125;Config.words=\"Hello\"Config.num=180Config[\"name\"]=\"ZhangSan\"print(Config[\"words\"])print(Config. name)print(Config, hello)for key, var in pairs(Config) do print(key, var)end 数组{} 12345678910arr = &#123;1,2,3,'hello'&#125;for k,v in pairs(arr) do print(k,v)end&gt;&gt;&gt; 1 12 2 3 3 4 hello ▲索引从1开始 使用APItable 1234567891011-- 数组插入for i=1,10 do table.insert( arr , 1, i) -- 经sxh发现结果是逆序的,19-&gt;2,20-&gt;1 ， 原因是每次都从头部插入，相当于LIFO , 此时感觉像是数组（带索引key）...并且table.insert( arr , 2, i)结果只有2--&gt;20 ，此时像字典（只有键2） -- 正序的顺出 table.insert( arr , i) -- 默认在尾部开始插入 -- 或者arr[i] = iend-- 获得数组长度table.maxn(arr) 面向对象 没有class类关键字，但可以自己实现类的功能： 复制表table 函数闭包 复制表table 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364people = &#123;&#125;-- 法一function people.sayHi() print('Hi')end-- 法二people.sayHi = function () print('Hi') end-- 拷贝function clone( tab ) local arr = &#123;&#125; for k,v in pairs(tab) do arr[k] = tab[v] end return arrend-- 相当于是构造方法People.new = function (name) local self = clone(People) self.name = name return self end-- 成员函数People.sayHi = function(self) -- self是类示例变量 -- ..是字符串连接 print(\"People say hi:\".. self. name)end -- 测试可以实现类的功能--local p = clone(People)--p.sayHi()-- 测试构造函数local p = People.new(\"ZhangSan\")-- 需要传类示例p.sayHi(p)-- 使用：可以不用传类示例p:sayHi()Man=&#123;&#125;-- 实现类的继承的功能Man.new = function (name) local self =People.new(name) copy(self, Man) return self end-- 增添成员函数Man.sayHello=function() print(\"Man say hello\")end -- 重写成员函数Man.sayHi = function (self) print(\"Man sayHi\".. self.name)end 函数闭包 123456789101112131415161718192021222324function People() local self = &#123;&#125; function init( name ) self.name = name end function sayHello() print(\"Hello \"..self.name) end init() return selfend-- 继承function Man(name) local self= People(name) -- local function init() -- end self.sayHello=function () print(\"hello\"..self.name) end return selfend 学习自 https://www.bilibili.com/video/av46428956/?p=8 通过表的特性实现switch关键字功能 1234567891011121314local key = 1 local switch = &#123; [1] = function() print(\"switch:\"..1) end, [2] = function() print(\"switch:\"..2) end, [\"test\"] = function() print(\"switch:test\") end, &#125; switch[2]()-- &gt;&gt;&gt; 2 伪随机数的生成 123456-- 因此“短时间内多次运行程序” 这样的需求下 os.time 还真不大好。可是又没有比 time 函数更方便的种子生成器， 怎么办呢？math.randomseed(tostring(os.time()):reverse():sub(1, 6))for i=1, 5 do print(math.random(4))end-- 就是把 time返回的数值字串倒过来（低位变高位）， 再取高位6位。 这样， 即使 time变化很小， 但是因为低位变了高位， 种子数值变化却很大，就可以使伪随机序列生成的更好一些","categories":[],"tags":[{"name":"lua","slug":"lua","permalink":"https://nymrli.top/tags/lua/"}]},{"title":"Java课程第三次实验报告","slug":"Java课程第三次实验报告","date":"2019-06-03T13:21:19.000Z","updated":"2019-09-15T08:07:30.947Z","comments":true,"path":"2019/06/03/Java课程第三次实验报告/","link":"","permalink":"https://nymrli.top/2019/06/03/Java课程第三次实验报告/","excerpt":"","text":"Java课程第三次实验报告 \\1. 在前面实验二已定义的学生类Student的基础上，以Student类为父类，为学生类派生出一个子类为大学生类（CollegeStudent）。 CollegeStudent 类在学生类上增加一个专业（profession）数据属性；方法上增加获得专业和设置专业两个方法。并对超类中的toString( )方法进行重写，使得CollegeStudent类中的toString( )方法除了显示学生类的信息外，还要显示它的专业属性。 编写测试程序的主类。在主类中创建一个Student对象和CollegeStudent对象，并显示或修改这两个对象的属性值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//package homework; package student ; public class Student &#123; private int UID; private String name; private Boolean gender; // G- B- private int age; static int cnt ; public Student() &#123;&#125; public Student(int UID,String name,Boolean gender,int age) &#123; cnt ++ ; this.UID = UID; this.name = name; this.gender = gender; this.age = age; &#125; /** * @target 获得私有参数 */ public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public Boolean getGender() &#123; return gender; &#125; public int getUID() &#123; return UID; &#125; /** * @target 修改私有参数 */ public void setAge(int age) &#123; this.age = age; &#125; public void setUID(int uID) &#123; UID = uID; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setGender(Boolean gender) &#123; this.gender = gender; &#125; @Override protected void finalize() throws Throwable &#123; // TODO Auto-generated method stub System.out.println(\"对象已被销毁\");; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub if (gender) return \"该同学的学号为：\" + UID +\"，姓名叫：\" + name + \"，性别：男\" + \"，年龄：\" + age; return \"该同学的学号为：\" + UID +\"，姓名叫：\" + name + \"，性别：女\" + \"，年龄：\" + age; &#125; public static int getCnt() &#123; return cnt; &#125; &#125; //新建立的CoolegeStudent对象 class CollegeStudent extends Student&#123; private String profession; CollegeStudent(int studentID, String name, Boolean sex, int age, String profession) &#123; super( studentID, name, sex, age ); this.profession = profession; &#125; public String getProfession() &#123; return profession; &#125; public void setProfession(String profession) &#123; this.profession = profession; &#125; @Override public String toString() &#123; return \"CollegeStudent&#123;\" + \"profession='\" + profession + '\\'' + \"studentID='\" + super.getUID() + '\\'' + \", name='\" + super.getName() + '\\'' + \", sex='\" + super.getGender() + '\\'' + \", age=\" + super.getAge() + '&#125;'; &#125; &#125; 设计一个人员类（Person），其中包含一个方法pay，代表人员的工资支出。再从Person类派生出助教类（Assistant）、讲师类（Instructor）、副教授类（Assistant Professor）和教授类（Professor）。其中：工资支出=基本工资+授课时数*每课时兼课金。 但助教基本工资为800，每课时兼课金25，讲师基本工资为1000，每课时兼课金35， 副教授基本工资为1200，每课时兼课金40，教授基本工资为1400，每课时兼课金50。 1.将Person定义为抽象类，pay为抽象方法，设计程序实现多态性。 2.将Person定义为接口，设计程序实现多态性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//Person写成类： class Person &#123; public int basic; public int hour; public int charge; public Person() &#123; &#125; public Person(int basic, int charge) &#123; this.basic = basic; this.charge = charge; &#125; public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (basic + hour * charge) ); &#125; &#125; class Assistant extends Person &#123; public Assistant() &#123; super( 800, 25 ); &#125; &#125; class Instructor extends Person &#123; public Instructor() &#123; super( 1000, 35 ); &#125; &#125; class AssistantProfessor extends Person &#123; public AssistantProfessor() &#123; super( 1200, 40 ); &#125; &#125; class Professor extends Person &#123; public Professor() &#123; super( 1400, 50 ); &#125; &#125; //Person写成抽象类 abstract class Person &#123; public int hour; public abstract void pay(int hour); class Assistant extends Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (800 + hour * 25) ); &#125; &#125; class Instructor extends Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1000 + hour * 35) ); &#125; &#125; class AssistantProfessor extends Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1200 + hour * 40) ); &#125; &#125; class Professor extends Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1400 + hour * 50) ); &#125; &#125; /** * @author mrli * 接口写法 */ interface Person &#123; void pay(int hour); &#125; class Assistant implements Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (800 + hour * 25) ); &#125; &#125; class Instructor implements Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1000 + hour * 35) ); &#125; &#125; class AssistantProfessor implements Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1200 + hour * 40) ); &#125; &#125; class Professor implements Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1400 + hour * 50) ); &#125; &#125; 从键盘输入两个数，进行相除，显示商。当输入串中含有非数字时或除数为0时，通过异常处理机制，使程序能正确运行。 1234567891011121314151617181920212223242526import java.util.InputMismatchException; import java.util.Scanner; public class yichang &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; Scanner scanner = new Scanner(System.in); System.out.print( \"请输入除数:\" ); int dividedNum = scanner.nextInt(); System.out.print( \"请输入被除数:\" ); int divNum = scanner.nextInt(); System.out.println( \"计算结果：\" + dividedNum / divNum ); &#125; catch (InputMismatchException e1) &#123; // TODO: handle exception System.out.println(\"输入不为数字!\"); &#125;catch (ArithmeticException e2) &#123; // TODO: handle exception System.out.println(\"不能除0!\"); &#125; &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"南京邮电大学java程序设计作业在线编程第八次作业","slug":"南京邮电大学java程序设计作业在线编程第八次作业","date":"2019-06-03T13:20:12.000Z","updated":"2019-09-15T08:07:31.037Z","comments":true,"path":"2019/06/03/南京邮电大学java程序设计作业在线编程第八次作业/","link":"","permalink":"https://nymrli.top/2019/06/03/南京邮电大学java程序设计作业在线编程第八次作业/","excerpt":"","text":"总分：100 选择题得分：70 int[][] a=new int[2][3]，则该数组包含（ ）个数组元素。 A.2 B.3 C.6 D.不确定 正确答案是: C 已知类person是类student的父类，以下数组定义和赋值正确的是( )。 A.person p[]=new person[3]; p[1]=new student(); B.student s[]=new person[3]; s[1]=new person(); C.person p[]= new student[3];p[1]= new person(); D.student s[]=new student[3];s[1]=new person; 正确答案是: A 下面关于java中类的说法不正确的是( )。 A.类体中包含了变量定义和成员方法的定义 B.构造函数是类中的特殊方法 C.类一定要声明为public的，才可以执行 D.一个java文件中可以有多个class定义 正确答案是: C 关于接口下列说法正确的( )。 A.实现一个接口必须实现接口的所有方法 B.接口间不能有继承关系 C.一个类只能实现一个接口 D.接口和抽象类是同一回事 正确答案是: A 以下有关构造方法的说法，正确的是( )。 A.一个类的构造方法可以有多个 B.构造方法不可以重载 C.构造方法可以有返回值 D.构造方法可以和类同名，也可以和类名不同 正确答案是: A 下列论述中，错误的是（ ）。 A.Java源代码的后缀名是.java。 B.Java源代码中的每个类经过编译后都会生成一个.class文件。 C.在一个名为A.java的文件中只能定义一个类。 D.Java源代码中可以定义类和接口。 正确答案是: C 下列论述中，正确的是（ ）。 A.抽象方法是没有方法体的方法。 B.抽象方法一定存在于抽象类中。 C.抽象类中一定要包含抽象方法。 D.抽象类可以创建对象。 正确答案是: A MyClass类定义如下： class MyClass{ public MyClass(int x){ } } 如下方式创建对象，（ ）是正确的 A.MyClass myobj=new Myclass; B.MyClass myobj=new Myclass(); C.MyClass myobj=new Myclass(1); D.MyClass myobj=new Myclass(1,2); 正确答案是: C 关于方法void fjv(int x,int y){}，下面（ ）不能成为它的重载。 A.void fjv(int x,float y){} B.void fjv(int x){} C.void fjv(float x,int y){} D.int fjv(int y,int x){} 正确答案是: D 下述（ ）说法是不正确的 A.实例变量是用static关键字声明的； B.实例变量是类的成员变量； C.方法变量可在方法执行时创建； D.方法变量在使用之前必须初始化； 正确答案是: A 如果一个方法被修饰为________方法，则这个方法不能被重写。 A.final B.static C.void D.protected 正确答案是: A 在Java中，下面说法正确的是（ ）。 A.一个子类可以有多个父类，一个父类也可以有多个子类 B.一个子类可以有多个父类，但一个父类只可以有一个子类 C.一个子类可以有一个父类，但一个父类可以有多个子类 D.上述说法都不对 正确答案是: C ___________变量在内存中只有一个拷贝，被该类的所有对象共享。 A.成员 B.局部 C.全局 D.类 正确答案是: D MAX_LENGTH是int型public成员变量, 变量值保持为常量100，下面哪句定义语句是正确的。 A.public int MAX_LENGTH=100; B.final int MAX_LENGTH=100; C.final public int MAX_LENGTH=100; D.public final int MAX_LENGTH=100; 正确答案是: D 1234567891011121314151617181920212223242526272829303132333435363738394041// 编写Main类，生成若干实例并验证程序的功能，请勿改动Main类的定义内容。public class Main&#123; public static void main(String[] args) &#123; Pet pet=new Dog(\"WangCai\"); System.out.println(pet.getName()+\":\"+pet.shout()); pet=new Cat(\"XiaoHua\"); System.out.println(pet.getName()+\":\"+pet.shout()); &#125;&#125;// 请在本行之后添加你的代码内容abstract class Pet&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; abstract String shout();&#125;class Dog extends Pet&#123; Dog(String name) &#123; setName( name ); &#125; @Override String shout() &#123; return \"Wang Wang Wang\"; &#125;&#125;class Cat extends Pet&#123; Cat(String name) &#123; setName( name ); &#125; @Override String shout() &#123; return \"Miao Miao Miao\"; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Windows下命令行神器cmder","slug":"Windows下命令行神奇cmder","date":"2019-06-03T13:17:28.000Z","updated":"2019-09-15T08:07:31.014Z","comments":true,"path":"2019/06/03/Windows下命令行神奇cmder/","link":"","permalink":"https://nymrli.top/2019/06/03/Windows下命令行神奇cmder/","excerpt":"","text":"Cmder 安装 http://cmder.net/ 有两个版本，分别是mini与full版 mini 没有内建msysgit工具，这是Git for Windows的标准配备； 全安装版 cmder 自带了 msysgit, 压缩包 108M 除了 git 本身这个命令之外, 里面可以使用大量的 linux 命令；比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl 可以交叉使用 cygwin 的部分增强命令 把 cmder 加到环境变量 将解压后的文件夹路径加入到系统环境变量的Path中 添加 cmder 到右键菜单 配置环境变量后，在管理员权限的终端输入以下语句 Win 8 或者 Win10 可以直接 win+x 再按 a 键进入 或者在开始中输入命令，然后在弹出的最佳匹配中，选择命令行工具右键-&gt;以管理员身份打开 1Cmder.exe /REGISTER ALL 修改命令提示符号 1.3 之后版本 修改文件 ${CMDER_HOME}\\vendor\\clink.lua 12345if env == nil then lambda = &quot;λ&quot;else lambda = &quot;(&quot;..env..&quot;) λ&quot;end 改成 12345if env == nil then lambda = &quot;$&quot;else lambda = &quot;(&quot;..env..&quot;) $&quot;end 其他符号也行，看你自己的喜好 1.3 以前版本 编辑Cmder安装目录下的 vendor\\init.bat 批处理文件 1@prompt $E[1;32;40m$P$S&#123;git&#125;&#123;hg&#125;$S$_$E[1;30;40m &#123;lamb&#125; $S$E[0m 修改为 1@prompt $E[1;32;40m$P$S&#123;git&#125;&#123;hg&#125;$S$_$E[1;30;40m $$ $S$E[0m PowerShell.exe 需要另外设置 打开文件 config/cmder.lua（prompt.lua 也有版本是这个），将第二行中的λ修改为**$** 新标签打开个管理员权限终端 快捷键 Ctrl + t 后勾选Run as administrator 设置默认终端 如果你有其它的command希望通过 Cmder 打开，可以在 Startup 下的 Tasks 中添加。里面已经默认帮你配置了 Cmder、PowerShell、MinTTY、Git Bash。 默认启动的是 Cmder ，如果你想默认启动其它的command，你可以在 Startup 设置为其它的command 同时还可以快速的切换当前使用的终端，假设你正在使用的 cmd ，这时输入 bash 回车一下，便可以将当前标签页的终端切换成 Git Bash 中文和命令ll支持 Cmder 是不支持中文，这需要你在 Startup 下的 Environment 中设置一下。将 set LANG=zh_CN.UTF-8 cmder原生没有 ll 命令，但可以通过设置别名来实现：打开cmder安装目录下的\\config\\user-aliases.cmd文件，添加以下别名设置： Chocolatey软件包管理系统 chocolatey 是windows 下面的 yum brew 这种包管理器 运行如下命令(需要管理员权限) 1@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin 安装软件命令 choco install softwareName, 短写是 cinst softwareName 查询安装包是否存在 clist softwareName 可安装包列表 window下常用的开发环境应用 123456789101112choco install autohotkey.portable #安装 AutoHotkey (Portable)choco install nodejs.install #安装 nodechoco install git.install #安装 gitchoco install python #安装 pythonchoco install ruby #安装 rubychoco install jdk8 #安装 JDK8choco install googlechrome #安装 Chromechoco install google-chrome-x64 #Google Chrome (64-bit only)choco install firefox #安装 firefoxchoco install notepadplusplus.install #安装 notepad++choco install Atom #安装 Atomchoco install SublimeText3 #安装 SublimeText3","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"安利","slug":"安利","permalink":"https://nymrli.top/tags/安利/"}]},{"title":"微信公众号Pyhton","slug":"微信公众号Pyhton","date":"2019-05-27T14:01:10.000Z","updated":"2019-09-15T08:07:31.063Z","comments":true,"path":"2019/05/27/微信公众号Pyhton/","link":"","permalink":"https://nymrli.top/2019/05/27/微信公众号Pyhton/","excerpt":"","text":"微信公众号Pyhton开发 编写上传代码到SAE 1.申请SAE（sina application enginer），创建应用，SAE使用文档 2.编写上传代码 weixin.py 12345678910111213141516171819202122232425262728#-*-coding:utf-8-*-import web import os import hashlib import time class WeixinInterface: def __init__(self): self.app_root=os.path.dirname(__file__) self.templates_root=os.path.join(self.app_root,'templates') self.render=web.template.render(self.templates_root) def GET(self): data=web.input() signature=data.signature timestamp=data.timestamp nonce=data.nonce echostr=data.echostr token=\"wxpython\" l=[token,timestamp,nonce] l.sort() sha1=hashlib.sha1() map(sha1.update,l) hashcode=sha1.hexdigest() if hashcode == signature: return echostr index.wsgi 12345678910111213141516171819#-*-coding:utf-8-*-import os import saeimport web from weixin import WeixinInterface urls=(&apos;/weixin&apos;,&apos;WeixinInterface&apos;)app_root=os.path.dirname(__file__)templates_root=os.path.join(app_root,&apos;templates&apos;)render=web.template.render(templates_root)app=web.application(urls,globals()).wsgifunc()application=sae.create_wsgi_app(app) config.yaml 123456789101112name: wxpytest version: 1libraries:- name: webpy version: \"0.36\"- name: lxml version: \"2.3.4\"... ​ 3.微信公众号修改服务器配置 Token与代码中编写的保持一致，URL也要与指定的一致(即...\\weixin)。 注意直接访问&lt;http://vxquan.applinzi.com/weixin&gt;是会报错的，但是可以通过微信公众平台的认证（因为直接访问是没有参数的，data=web.input没有异常处理） 处理普通文本信息 12345678&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt; &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt; ▲.注意这边的OpenID不是真正的用户ID，不同公众号对相同用户获得的OpenID是不同的，换言之，这个只是该公众号能获得该用户的一个ID。 12345678910def POST(self): str_xml=web. data() xml=etree.fromstring(str_xml) msgType=xml.find(\"MsgType\").text fromuser=xml.find(\"FromUserName\").text touser=xml.find(\"ToUserName\").text if msgType==\"text\": content=xml. find(\"Content\").text return self.render.reply_text(fromuser,touser,int(time.time()),content) # 注意这边To和from的改变，服务器(发送)--&gt;wx后台--&gt;用户(接收) 记遇到的坑： 1.POST好像必须要有处理，返回信息 python2.7下字符串加u","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"Web","slug":"Web","permalink":"https://nymrli.top/tags/Web/"}]},{"title":"DigitalOcean VPS注册","slug":"DigitalOcean-VPS注册","date":"2019-05-27T13:57:56.000Z","updated":"2020-02-15T11:57:13.124Z","comments":true,"path":"2019/05/27/DigitalOcean-VPS注册/","link":"","permalink":"https://nymrli.top/2019/05/27/DigitalOcean-VPS注册/","excerpt":"","text":"DigitalOcean VPS搭梯子 DigitalOcean VPS注册 首先通过 邀请链接(https://m.do.co/c/e89da76f57f2)点进去注册，双方都会获得$10奖励（注意是注册，我当时就没注意到，少了10$ 然后在Github Education申请学生优惠，注意这边的学生优惠邮箱是校园邮箱(xxxx@njupt.edu.cn)那个。我当时是将github账号与校园邮箱进行链接的。 学生优惠申请到后，pack界面会变成这样 进入DO的页面后，用学校邮箱注册后，选用Paypal支付（先注册好Paypal），然后支付即可。 ▲由于一开始我并没有使用学校邮箱注册，而是QQ邮箱，后来又注册了以后，发现这个账号被锁了，付的$5也退了回来。按网上的说法，DO会直接锁了我的账号，原因是一个人注册了多个账号。于是找解决方案。 网上说要发邮件，其中比较关键的是Ticket，一开始一直没找到，后来才发现这个是在support中选出来的. 等了一天最终收到的答复却是： 我们检查了该帐户，发现它符合与违反我们的服务条款和可接受使用策略相关的异常模式。虽然我们无法提供所观察到的特定标志的详细信息，但我们已经确定，恢复对该帐户的访问是不可能的。不便之处，敬请原谅。 最终无奈之下，想起了使用的话跟学校邮箱没关系，那个只是提供优惠券的。于是重新尝试了下第一个注册的账号pay了$5以后就成功了。 创建主机 SSR: [搭建SSR科学上网（利用DigitalOcean服务器）](https://blog.ooolg.com/index.php/20181125/131=131.html) V2Ray 从零开始：史上最详尽V2Ray搭建图文教程 使用优惠券 DigitalOcean 的学生包代金券使用教程 输入Github Education上获得的优惠券Code，就能拿到$50的优惠券了 附录 ubuntu一键更换内核 安装锐速 - 16.04 14.04可用 PAC和全局模式 1.在全局模式下，所有的网站都默认走代理（使你的所有http/socks数据经过代理服务器的转发送出。） 2.在PAC模式是只有被墙了的网站才会走代理（连接网站的时候读取PAC文件里的规则，来确定你访问的网站有没有被墙，如果符合，那就会使用代理服务器连接网站） 优惠网站 https://xianhuo.org/2016digitalocean-youhuima.html 未测试","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"PyWinAuto使用","slug":"PyWinAuto使用","date":"2019-05-27T13:54:45.000Z","updated":"2020-11-07T03:45:50.734Z","comments":true,"path":"2019/05/27/PyWinAuto使用/","link":"","permalink":"https://nymrli.top/2019/05/27/PyWinAuto使用/","excerpt":"","text":"PyWinAuto使用 简单操作示例： 12app = application.Application().start(r'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe')# app = application.Application().start('notepad.exe') (一) 判断程序的backend 注意，首先需要判断你要进行的程序是用什么语言写的，在实例化的时候会有区别，主要是判断backend是什么。 (二)确定自动化入口点 这里主要是限制自动化控制进程的范围。如一个程序有多个实例，自动化控制一个实例，而保证其他实例(进程)不受影响。 主要有两种对象可以建立这种入口点——Application() , Desktop(). Application的作用范围是一个进程，如一般的桌面应用程序都为此类。 Desktop的作用范围可以跨进程。主要用于像win10的计算器这样包含多个进程的程序。这种目前比较少见。使用方法见entry-points-for-automation (三)连接到进程 建立好入口后，我们需要连接到进程中。这里有两种方法: 使用Application对象的start()方法 app = Application().start(r&quot;D:\\Program Files (x86)\\tlxsoft\\屏幕录像专家 共享版 V2017\\屏录专家.exe&quot;) 连接到已有的进程。使用Application对象的connect()方法。这个方法对已有进程的绑定非常灵活。 app = Application().connect(process=19188) 使用窗口句柄绑定 app = Application().connect(handle=0x00230DB6) 使用程序路径绑定★ app = Application().connect(path=r&quot;D:\\Program Files (x86)\\tlxsoft\\屏幕录像专家 共享版 V2017\\屏录专家.exe&quot;) 使用标题、类型等匹配★★（灵活性比较高） app = Application().connect(title_re=&quot;屏幕录像专家.*&quot;, class_name=&quot;TMainForm&quot;) 菜单操作 12dlg_spec = app.window(title='屏幕录像专家 V2017')dlg_spec.menu_select(r\"转换工具-&gt;EXE/LXE转成MP4\") 快捷键操作 12dlg_spec = app.window(title='屏幕录像专家 V2017')dlg_spec.type_keys('%TP') 1234567891011121314151617181920212223242526272829303132333435SHIFT + CTRL ^ ALT %空格键 &#123;SPACE&#125; BACKSPACE &#123;BACKSPACE&#125;、&#123;BS&#125; or &#123;BKSP&#125; BREAK &#123;BREAK&#125; CAPS LOCK &#123;CAPSLOCK&#125; DEL or DELETE &#123;DELETE&#125; or &#123;DEL&#125; DOWN ARROW &#123;DOWN&#125; END &#123;END&#125; ENTER &#123;ENTER&#125; or ~ ESC &#123;ESC&#125; HELP &#123;HELP&#125; HOME &#123;HOME&#125; INS or INSERT &#123;INSERT&#125; or &#123;INS&#125; LEFT ARROW &#123;LEFT&#125; NUM LOCK &#123;NUMLOCK&#125; PAGE DOWN &#123;PGDN&#125; PAGE UP &#123;PGUP&#125; PRINT SCREEN &#123;PRTSC&#125; RIGHT ARROW &#123;RIGHT&#125; SCROLL LOCK &#123;SCROLLLOCK&#125; TAB &#123;TAB&#125; UP ARROW &#123;UP&#125; + &#123;ADD&#125; - &#123;SUBTRACT&#125; * &#123;MULTIPLY&#125; / &#123;DIVIDE&#125;F1 &#123;F1&#125; F2 &#123;F2&#125; F3 &#123;F3&#125; .....F15 &#123;F15&#125; F16 &#123;F16&#125; 参考 pywinauto 使用 [python自动化工具之pywinauto](https://www.cnblogs.com/mapu/p/9235587.html)","categories":[],"tags":[{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Google Colab使用","slug":"Google-Colab使用","date":"2019-05-27T13:53:31.000Z","updated":"2019-09-15T14:02:20.372Z","comments":true,"path":"2019/05/27/Google-Colab使用/","link":"","permalink":"https://nymrli.top/2019/05/27/Google-Colab使用/","excerpt":"","text":"Google Colab使用 Google colab(Colaboratory)在编辑时候和jupyter notebook类似，并且提供免费的GPU以供使用，这对于需要处理大量数据运算的机器项目来说再合适不过了。挺香的 新建一个笔记本（.ipynb）后，选择&quot;修改-&gt;笔记本设置-&gt;硬件加速器-&gt;GPU&quot;就可以想要用英伟达Tesla K80 GPU啦(2599美元一块) colab中文件交互 文档里提供了四种方式，分别是： 从本地直接上传 连接Google Drive 连接Google Sheet 连接Google Cloud Storage 与本地文件交互 本地文件上传 files.upload() 返回一个由我们上传的所有文件构成的一个字典。 这个字典的key是文件名, 这个字典的value是我们上传的文件的data。 123456from google.colab import filesuploaded = files.upload()for fn in uploaded.keys(): print(&apos;User uploaded file &quot;&#123;name&#125;&quot; with length &#123;length&#125; bytes&apos;.format(name=fn, length=len(uploaded[fn]))) 从colab下载文件到本地 1234from google.colab import fileswith open(&apos;example.txt&apos;, &apos;w&apos;) as f: f.write(&apos;some content&apos;)files.download(&apos;example.txt&apos;) 连接Google Drive PyDrive 这里官方有提供了许多种方法。这里我就挑一种介绍了，有兴趣的可以点进这个Colab官方文档进去看。 这里只介绍使用PyDrive的方法。PyDrive是google-api-python-client的包装库，简化了许多常见的Google Drive API任务。 12345678910111213141516171819202122232425!pip install -U -q PyDrivefrom pydrive.auth import GoogleAuthfrom pydrive.drive import GoogleDrivefrom google.colab import authfrom oauth2client.client import GoogleCredentials# 1. 验证身份并创建pydrive客户端.auth.authenticate_user()gauth = GoogleAuth()gauth.credentials = GoogleCredentials.get_application_default()drive = GoogleDrive(gauth)# PyDrive 参考:# https://gsuitedevs.github.io/PyDrive/docs/build/html/index.html# 2. 创建并上传一个文本文档.uploaded = drive.CreateFile(&#123;'title': 'Sample upload.txt'&#125;)uploaded.SetContentString('Sample upload file content')uploaded.Upload()print('Uploaded file with ID &#123;&#125;'.format(uploaded.get('id')))# 3. 通过id访问文件并输出它的内容.downloaded = drive.CreateFile(&#123;'id': uploaded.get('id')&#125;)print('Downloaded content \"&#123;&#125;\"'.format(downloaded.GetContentString())) Mounting Google Drive locally 首先把整个项目工程上传到 Google Drive 中，然后在该项目文件夹下（执行的主函数文件同一目录）新建一个 run.ipynb。新建方法与之前一样，在项目文件夹中 右键-更多-Colaboratory。 然后，在新建的笔记本中挂载 Google Drive： 12from google.colab import drivedrive.mount(&apos;/content/drive/&apos;) 执行以上语句后，会出现一个链接。点击链接，获取并键入 authorization code，回车，等待圈圈转完就能在左侧刷新，看到挂载的Drive 挂载 Drive 网上还有另一种方法，语句很多很复杂，但这个好像没啥区别。。 对于这个服务器而言，整体目录结构是这样的： 顶级目录为 content，我们进入笔记本后无论笔记本在哪，当前工作目录都是 /content。/content下默认有 sample_data 目录，其中包括运行示例程序的一些必要数据文件。我们的 Google Drive 作为一个 My Drive 文件夹挂载在 /content/drive 文件夹下。我的项目是“我的云端硬盘”里的一个tiny-yolo文件夹，因此我的项目的路径应该为 /content/drive/My Drive/tiny-yolo。这里大家试一试就明白了，比我说啥都快。 注意事项 为了保证资源的合理分配，google 会按照一定机制将服务器回收：它会一定时间后自动回收已连接但闲置的服务器，和有运行代码但未连接的服务器。所以想挂机跑代码，要保证与服务器保持连接（不掉线），否则一早起来可能就会发现它被悄悄的回收了。稍微掉线个几分钟就连回去是没什么问题的。 在回收服务器后，写到 My Drive 以外其他文件夹下的文件都将被删除，下次再连接就是一台崭新的服务器了。 挂载 Drive 后再向 Google Drive上传文件，同步到 notebook 那边会有一定的延迟，大概等个几秒钟到半分钟不等，多刷新几下就会出现了。删除文件也是。然而在删除 a.py 后，如果没等 notebook 那边反应过来就重新再传一个 a.py，notebook 那边很可能就出现一个被重命名的文件 a(1).py。。难道是我姿势不对？？ 有一次我上传近 3000 张图片作为训练集到 Drive，上传成功，但是 notebook 没读全，!ls “/content/drive/My Drive/tiny-yolo/data” | wc -l 看一眼花式少文件，我也不知道为啥。。总是迷之过会 (hen) 儿 (jiu) 就好了。。搞得我也是很醉。 如何使用google drive的免费GPU进行深度学习 连接Google Sheet 连接Google Cloud Storage 参考：colab读写外部文件的四种方式","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"图像处理","slug":"图像处理","permalink":"https://nymrli.top/tags/图像处理/"}]},{"title":"Keras使用——图像增强","slug":"Keras使用——图像增强","date":"2019-05-27T13:52:14.000Z","updated":"2019-09-15T08:07:30.952Z","comments":true,"path":"2019/05/27/Keras使用——图像增强/","link":"","permalink":"https://nymrli.top/2019/05/27/Keras使用——图像增强/","excerpt":"","text":"Keras使用——图像增强 使用Keras进行深度学习的图像增强（Image Augmentation） Keras是一个高层神经网络API，Keras由纯Python编写而成并基Tensorflow、Theano以及CNTK后端。 Keras为支持快速实验而生，能够把你的idea迅速转换为结果，如果你有如下需求，请选择Keras： 简易和快速的原型设计（keras具有高度模块化，极简，和可扩充特性） 支持CNN和RNN，或二者的结合 无缝CPU和GPU切换 ImageDataGenerator Keras提供了ImageDataGenerator类，定义关于图片准备和增强的配置。包括以下功能：样本级的标准化特征级的标准化ZCA白化.随机旋转、转换、剪切、翻转维度重排.将增强的图片保存在本地. 1234567891011121314151617181920212223from keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_imgimport osDatagen = ImageDataGenerator(rotation_range=20, shear_range=0.2, zoom_range=0.2, horizontal_flip=True, vertical_flip = True, fill_mode='nearest')for file_name in os.listdir('.'): if file_name =='.config' or file_name == 'sample_data': continue img = load_img(file_name) x_img = img_to_array(img) x_img = x_img.reshape((1,)+ x_img.shape) i = 0 for img_batch in Datagen.flow(x_img, batch_size=32, save_to_dir='.', save_prefix='candy', save_format='jpg'): i +=1 if i &gt; 10: break ImageDataGenerator参数详解及用法实例 12345678910111213141516171819keras.preprocessing.image.ImageDataGenerator(featurewise_center=False, samplewise_center=False, featurewise_std_normalization=False, samplewise_std_normalization=False, zca_whitening=False, zca_epsilon=1e-6, rotation_range=0., width_shift_range=0., height_shift_range=0., shear_range=0., zoom_range=0., channel_shift_range=0., fill_mode='nearest', cval=0., horizontal_flip=False, vertical_flip=False, rescale=None, preprocessing_function=None, data_format=K.image_data_format()) ▲用以生成一个batch的图像数据，支持实时数据提升。训练时该函数会无限生成数据，直到达到规定的epoch次数为止。 featurewise_center：布尔值，使输入数据集去中心化（均值为0）, 按feature执行 samplewise_center：布尔值，使输入数据的每个样本均值为0 featurewise_std_normalization：布尔值，将输入除以数据集的标准差以完成标准化, 按feature执行 samplewise_std_normalization：布尔值，将输入的每个样本除以其自身的标准差 zca_whitening：布尔值，对输入数据施加ZCA白化 zca_epsilon: ZCA使用的eposilon，默认1e-6 rotation_range：整数，数据提升时图片随机转动的角度 width_shift_range：浮点数，图片宽度的某个比例，数据提升时图片水平偏移的幅度 height_shift_range：浮点数，图片高度的某个比例，数据提升时图片竖直偏移的幅度 shear_range：浮点数，剪切强度（逆时针方向的剪切变换角度） zoom_range：浮点数或形如[lower,upper]的列表，随机缩放的幅度，若为浮点数，则相当于[lower,upper] = [1 - zoom_range, 1+zoom_range] channel_shift_range：浮点数，随机通道偏移的幅度 fill_mode：；‘constant’，‘nearest’，‘reflect’或‘wrap’之一，当进行变换时超出边界的点将根据本参数给定的方法进行处理 cval：浮点数或整数，当fill_mode=constant时，指定要向超出边界的点填充的值 horizontal_flip：布尔值，进行随机水平翻转 vertical_flip：布尔值，进行随机竖直翻转 rescale: 重放缩因子,默认为None. 如果为None或0则不进行放缩,否则会将该数值乘到数据上(在应用其他变换之前) preprocessing_function: 将被应用于每个输入的函数。该函数将在图片缩放和数据提升之后运行。该函数接受一个参数，为一张图片（秩为3的numpy array），并且输出一个具有相同shape的numpy array data_format：字符串，“channel_first”或“channel_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channel_last”对应原本的“tf”，“channel_first”对应原本的“th”。以128x128的RGB图像为例，“channel_first”应将数据组织为（3,128,128），而“channel_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channel_last” 12345678910111213141516171819202122232425262728293031323334353637from keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_imgimport osDatagen = ImageDataGenerator( rotation_range=5,#图片随机翻转的角度 width_shift_range=[0,0.15], height_shift_range=[0,0.2], zoom_range=[0.8,1.5], #随机放大 zca_whitening=True, brightness_range=[0.1, 1.5] , fill_mode='nearest')IMG_PATH = './images'OUT_PATH = './add'# for i in os.listdir(OUT_PATH):# if i.startswith('N'):# os.remove(os.path.join(OUT_PATH,i) )for file_name in os.listdir(IMG_PATH): img = load_img( os.path.join(IMG_PATH,file_name) ) x_img = img_to_array(img) x_img = x_img.reshape( (1,)+ x_img.shape ) i = 0 if( not os.path.exists( os.path.join( OUT_PATH,file_name ) ) ): os.mkdir( os.path.join( OUT_PATH,file_name )) for img_batch in Datagen.flow(x_img, batch_size=2, #batch_size一次增强的图片个数 save_to_dir= os.path.join(OUT_PATH,file_name), save_prefix='N', save_format='jpg'): i +=1 if i == 80: breakprint('done') 参考资料： 参数说明 keras中文手册 https://www.cnblogs.com/hutao722/p/10075150.html https://www.cnblogs.com/hutao722/p/10075150.html flow_from_directory实现从文件夹中提取图片和进行简单归一化处理 12345678flow_from_directory(self, directory, target_size=(256, 256), color_mode='rgb', classes=None, class_mode='categorical', batch_size=32, shuffle=True, seed=None, save_to_dir=None, save_prefix='', save_format='jpeg', follow_links=False) 最值得注意的是directory这个参数： directory: path to the target directory. It should contain one subdirectory per class. Any PNG, JPG, BMP, PPM or TIF images inside each of the subdirectories directory tree will be included in the generator. 这是官方文档的定义，它的目录格式一定要注意是包含一个子目录下的所有图片这种格式，driectoty路径只要写到标签路径上面的那个路径即可。 target_size：可是实现对图片的尺寸转换，是预处理中比较常用的方法 save_to_dir: 可以设置保存处理后图片的路径。 save_prefix: 可以对处理后图片设置前缀。 123456789101112131415161718192021222324252627282930313233343536373839import matplotlib.pyplot as pltimport globfrom PIL import Imagefrom keras.preprocessing import image path = 'train/'gen_path = 'result/' def print_result(path): name_list = glob.glob(path) fig = plt.figure() for i in range(9): img = Image.open(name_list[i]) # add_subplot(331) 参数一：子图总行数，参数二：子图总列数，参数三：子图位置 sub_img = fig.add_subplot(331 + i) sub_img.imshow(img) plt.show() return fig # 打印图片列表name_list = glob.glob(path + '*/*')print(name_list)# ['train\\\\00a366d4b4a9bbb6c8a63126697b7656.jpg', 'train\\\\00f34ac0a16ef43e6fd1de49a26081ce.jpg', 'train\\\\0a5f744c5077ad8f8d580081ba599ff5.jpg', 'train\\\\0a70f64352edfef4c82c22015f0e3a20.jpg', 'train\\\\0a783538d5f3aaf017b435ddf14cc5c2.jpg', 'train\\\\0a896d2b3af617df543787b571e439d8.jpg', 'train\\\\0abdda879bb143b19e3c480279541915.jpg', 'train\\\\0ac12f840df2b15d46622e244501a88c.jpg', 'train\\\\0b6c5bc46b7a0e29cddfa45b0b786d09.jpg'] # 打印图片fig = print_result(path + '*/*') # 保存图片fig.savefig(gen_path + '/original_0.png', dpi=200, papertype='a5') # 原图datagen = image.ImageDataGenerator()gen_data = datagen.flow_from_directory(path, batch_size=1, shuffle=False, save_to_dir=gen_path , save_prefix='dog_gen', target_size=(224, 224))for i in range(9): gen_data.next() fig = print_result(gen_path + '/*')fig.savefig(gen_path + '/original_1.png', dpi=200, papertype='a5')","categories":[],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"https://nymrli.top/tags/图像处理/"},{"name":"深度学习","slug":"深度学习","permalink":"https://nymrli.top/tags/深度学习/"}]},{"title":"Python机器学习及实践——从零开始通往Kaggle竞赛之路","slug":"Python机器学习及实践——从零开始通往Kaggle竞赛之路","date":"2019-05-27T13:50:34.000Z","updated":"2019-09-15T08:07:30.987Z","comments":true,"path":"2019/05/27/Python机器学习及实践——从零开始通往Kaggle竞赛之路/","link":"","permalink":"https://nymrli.top/2019/05/27/Python机器学习及实践——从零开始通往Kaggle竞赛之路/","excerpt":"","text":"Python机器学习及实践——从零开始通往Kaggle竞赛之路 监督学习模型 分类 线性模型 Logistic 逻辑回归函数 ： $g(z)=\\frac {1}{1+_e^{-z}} $ 逻辑回归模型hw,b(x)=g(f(w,x,b))=11+e−z=11+e−(wTx+b)h_{w,b}(x)=g(f(w,x,b)) = \\frac{1}{1+e^{-z}} = \\frac {1}{1+e^{-(w^{T}x+b)}}hw,b​(x)=g(f(w,x,b))=1+e−z1​=1+e−(wTx+b)1​ 处理缺省值的方法： 1.缺省值较少时直接删除数据 12data = data.replace(to_replace='? ' ,value = np.nan)data = data.dropna(how='any') 分割数据 123from sklearn.cross_validation import train_test_splitX_train , Y_train , X_test , Y_test = train_test_split(data[names[1:10]],data[names[10]],test_size = 0.25,random_state = 33)# 参数说明 ： $1X，$2Y，$3分割规模，$4分割种子 标准化数据 保证每个维度的特征数据方差为1，均值为0，使得预测结果不回被某些维度过大的特征值主导 1234from sklearn.preprocessing import StandardScalers = StandardScaler()X_train = s.fit_transform(X_train)X_test = s.transform(X_test) 混淆矩阵 … 🎯逻辑回归对参数的计算采用精确解析的方式，时间长性能高；SGD（随机梯度上升）分类估计模型参数，时间短性能低。数据规模在10W量级时考虑对时间的消耗，更推荐使用随机梯度方法对模型参数进行估计。 📝说明用例：良恶性肿瘤 支持向量机（​​分类） 决定直线位置的并不是所有数据，而是其中 两个空间间隔最小 的 两个不同类别 的数据点，把着中国真正帮助决策最有线性分类模型的数据点叫做“支持向量” 。同时要指出的是，logistic模型考虑了所有数据样本对参数的影响，所以不一定能获得最佳的分类器。 多分类的SVM 将其中一类看作是阳性（正）样本，其余的全看成负样本。如有10个类别，则创造10个二分类任务。 🎯SVM具有精妙的模型假设，可以在高维度的数据中筛选对预测任务有效的少数训练样本，不仅节省模型学习需要的数据内存，还提高了模型的预测性能，但是同时是以CPU资源和计算时间为代价的。 📝手写体数据​： 需要知道的是，经典模型没有对结构性信息学习的能力，所以这边对图片的处理其实是将2D图片像素矩阵（scikit-learn数据集里的是8*8）逐行首尾拼接为1D的像素特征向量。 非线性模型 朴素贝叶斯 单独考量每一个维度特征被分类的条件概论，进而综合这些概率并对其所在的特征向量做出分类预测。 数学假设：各个维度上的特征被分类的条件概率之间是相互独立的。 🎯具有较强的特征条件独立假设，使得模型预测所需要估计的参数规模从幂指数量级向线性量级减少，极大​节约了内存消耗和计算时间。但也受限与这种强假设的限制，训练时无法将各个特征之间的联系考量在内，使得该模型再其他数据特征关联性较强的分类任务上的性能表现不佳。 📝文本分类：互联网新闻分类、垃圾邮件筛选 K近邻（KNN） 设有一个测试样本点，以及已经分好类（带有标签）的训练样本。那么该样本点的类别判定会根据在特征空间中最近的K个已标记样本作为参考。因此模型的性能很大程度上取决于K值的设定，但是K值不属于训练数据后学习的参数，而是模型初始化时需要提前确定的。 🎯是无参数模型中最简单的一种，由于需要对预先加载在内存的训练样本进行遍历，逐一计算相似度、排序且选择K个最近邻训练样本的标记。所以是O(N2)的算法复杂度，一旦数据量大，可能会花费更多的时间（另一种理解为空间换时间，可探讨） 📝 iris鸢尾花数据集​ : ▲在对数据进行分割时请保证随机取样！ 由于scikit-learn获得的Iris数据集是根据类别依次排列的，所以如果只采样前25%那么所有采样的样本都是同一个类别，同时由于训练样本是不平衡的(Unbalanced)，这样取得的结果存在偏差，且可信度低。因此随机采样train_test_split(data[names[1:10]],data[names[10]],test_size = 0.25,random_state = 33)设置随机种子是必要的。 决策树 每个节点可以看作是二分类任务，根据不同特征组合搭建多层决策树，在学习时需要考虑特征节点的选择顺序。（度量方式：信息熵、基尼不纯性） 数据处理 缺省值： 1234X = titannic[['pclass','age','sex']]...# 补充age里的数据，使用平均数或者中位数都是对模型偏离成都造成最小影响的策略X['age'].fillna(X['age'].mean(),inplace = True) 特征值转换 类别性特征值转换为数值特征，用0/1代替 12345from sklearn.feature_extraction import DictVectorizervec = DictVectorizer(sparse = False)X_train = vec.fit_transform(X_train.to_dict(orient='record'))print(vec.feature_names)&gt;&gt;&gt; ['age','plcass=1st','pclass=2nd', 'sex=female','sex=male'] 🎯决策树在模型描述上有巨大的优势，推断逻辑非常直观，有清晰的可解释性，也方便模型的可视化。同时这些特性也保证了使用决策树时，无需考虑对数据量化甚至标准化。决策树属于有参数模型，需要花费更多时间在训练数据上面 📝泰坦尼克号沉船事故 回归 线性回归器 🎯美国波士顿地区房价 KNN 支持向量机 回归树 集成模型 无监督学习模型 数据聚类 K均值（K-means） 特征降维 主成分分析（PCA）","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"ACM-强连通分量","slug":"ACM-强连通分量","date":"2019-04-25T01:27:03.000Z","updated":"2019-09-15T08:07:30.915Z","comments":true,"path":"2019/04/25/ACM-强连通分量/","link":"","permalink":"https://nymrli.top/2019/04/25/ACM-强连通分量/","excerpt":"","text":"Tarjan 算法&amp;模板 Tarjan 算法一种由Robert Tarjan提出的求解有向图强连通分量的算法，它能做到线性时间的复杂度。 如果两个顶点可以相互通达，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。 1234567891011121314151617181920212223void Tarjan ( int x ) &#123; dfn[ x ] = ++dfs_num ; low[ x ] = dfs_num ; vis [ x ] = true ;//是否在栈中 stack [ ++top ] = x ; for ( int i=head[ x ] ; i!=0 ; i=e[i].next )&#123; int temp = e[ i ].to ; if ( !dfn[ temp ] )&#123; Tarjan ( temp ) ; low[ x ] = gmin ( low[ x ] , low[ temp ] ) ; &#125; else if ( vis[ temp ])low[ x ] = gmin ( low[ x ] , dfn[ temp ] ) ; &#125; if ( dfn[ x ]==low[ x ] ) &#123;//构成强连通分量 vis[ x ] = false ; color[ x ] = ++col_num ;//染色 while ( stack[ top ] != x ) &#123;//清空 color [stack[ top ]] = col_num ; vis [ stack[ top-- ] ] = false ; &#125; top -- ; &#125;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"ACM-并查集","slug":"ACM-并查集","date":"2019-04-25T01:21:30.000Z","updated":"2020-06-03T07:57:58.505Z","comments":true,"path":"2019/04/25/ACM-并查集/","link":"","permalink":"https://nymrli.top/2019/04/25/ACM-并查集/","excerpt":"","text":"并查集 ACM竞赛中，并查集（DisjointSets）这个数据结构经常使用。顾名思义，并查集即表示集合，并且支持快速查找、合并操作。 用于高效的查找某两个元素是否属于同一个集合； 并查集如何表示一个集合？它借助树的思想，将一个集合看成一棵有根树。那又如何表示一棵树？初始状态下，一个元素即一棵树，根即是元素本身。 合并 并查集如何支持合并操作？不难发现，按照树的思想，在同一棵树中的所有元素，根都是相同的。也就是说，合并两个不同的集合，只需要将其中一个集合的根设置为另一个集合的根即可，而需要改变根的那个集合，其实只需要改变根节点的父节点即可。 如何支持快速查找操作 如果完全按照上面的合并方法进行合并操作，最后生成的树，可能是完全线性的，那么查询的时间复杂度就退化成了O(n)，因为在这种情况下，程序不得不遍历完所有节点才能查询到当前元素所属的根节点。 路径压缩算法优化并查集查询操作。按照集合原来的定义，集合中的元素是满足无序性的，因此可以在查询操作进行的过程中，当程序遍历到根节点然后返回的时候，将所有属于当前根节点的元素的父节点直接设置为当前根节点。如此一来，原来的一条链就变成了一般的树了。当下一次查询的时候，就可以很快的遍历到根节点了，复杂度下降为O(1)。 还有一种优化查询速度的方法，那就是合并两个集合的时候，按秩进行合并，这里的秩代表的以当前元素为根节点的元素个数。很明显，将秩较小的树合并到秩较大的树上更优。 最后，就是具体如何用代码实现并查集？其实，并查集中只涉及到了保存当前元素的父节点这一信息，所以利用一个数组set[i]代表节点i的父节点即可，如果set[i]=i那么代表当前集合的根即为i元素本身。 以一道例题为例，HDOJ：1212，时空转移（点击打开链接）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt; const int NumSets = 1005;typedef int DisjSet[NumSets + 1];typedef int Rank[NumSets + 1];DisjSet S;Rank R; // Initialize the set and rankvoid Initialize()&#123; for(int i=0; i&lt;NumSets; ++i) &#123; S[i] = i; R[i] = 1; &#125;&#125; // Find father of the value, with the function of path compressionint Find(int value)&#123; if(S[value] != value) S[value] = Find(S[value]); return S[value];&#125; // Union the value1 and value2 by the rank of the set which them local invoid SetUnion(int value1, int value2)&#123; int fa1 = Find(value1); int fa2 = Find(value2); if(fa1 == fa2) return ; if(R[fa1] &gt;= R[fa2]) &#123; S[fa2] = fa1; R[fa1] += R[fa2]; &#125; else &#123; S[fa1] = fa2; R[fa2] += R[fa1]; &#125;&#125; int main()&#123;//freopen(\"sample.txt\", \"r\", stdin); int cas; scanf(\"%d\", &amp;cas); while(cas--) &#123; int n, m; Initialize(); scanf(\"%d%d\", &amp;n, &amp;m); for(int i=0; i&lt;m; ++i) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); if(Find(a) != Find(b)) &#123; SetUnion(a, b); --n; &#125; &#125; printf(\"%d\\n\", n); &#125; return 0;&#125;！ 摘自(https://blog.csdn.net/u011787119/article/details/46834903) 例题 解密犯罪团伙 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;int f[1001]=&#123;0&#125;,n,m,sum=0;//这里是初始化，非常地重要，数组里面存的是自己数组下标的编号就好了。void init()&#123; int i; for(i=1;i&lt;=n;i++) f[i]=i; return; &#125;//这是找爹的递归函数，不停地去找爹，直到找到祖宗为止，其实就是去找犯罪团伙的最高领导人，//“擒贼先擒王”原则。int getf(int v) &#123; if(f[v]==v) return v; else&#123; //这里是路径压缩，每次在函数返回的时候，顺带把路上遇到的人的“BOSS”改为最后找 //到的祖宗编号，也就是犯罪团伙的最高领导人编号。这样可以提高今后找到犯罪团伙的 //最高领导人（其实就是树的祖先）的速度。 f[v]=getf(f[v]);//这里进行了路径压缩 return f[v]; &#125;&#125;// 迭代写法// node为某次具体操作节点, tmp_node为其能找到group头// 关系类似链表中的p、q, 一个当前, 一个记录下一个或上一个节点int findFather(int v)&#123; int node = v; while ( arr[v] != v ) &#123; v = arr[v]; &#125; // v此时指向的是该group的头 // 路径压缩, 把该group中所有成员都指向一个头v while ( node != arr[node] )&#123; int tmp_node = node; node = arr[node]; arr[tmp_node] = v; &#125; return v;&#125;//这里是合并两子集合的函数void merge(int v,int u) &#123; int t1,t2;//t1、t2分别为v和u的大BOSS（首领），每次双方的会谈都必须是各自最高领导人才行 t1=getf(v); t2=getf(u); if( t1!=t2 ) //判断两个结点是否在同一个集合中，即是否为同一个祖先。 f[t2]=t1; //“靠左”原则，左边变成右边的BOSS。即把右边的集合，作为左边集合的子集合。 return;&#125;//请从此处开始阅读程序，从主函数开始阅读程序是一个好习惯。int main()&#123; int i,x,y; scanf(\"%d %d\",&amp;n,&amp;m); init(); //初始化是必须的 for(i=1;i&lt;=m;i++)&#123; //开始合并犯罪团伙 scanf(\"%d %d\",&amp;x,&amp;y); merge(x,y); &#125; //最后扫描有多少个独立的犯罪团伙 for(i=1;i&lt;=n;i++)&#123; if(f[i]==i) sum++; &#125; printf(\"%d\\n\",sum); getchar();getchar(); return 0;&#125; 用并查集判断无向图的连通性(或求连通分支个数)~ 给定一个无向图和其中的所有边，判断这个图是否所有顶点都是连通的。 输入：每组数据的第一行是两个整数n 和m（0&lt; n &lt;=1000）。n 表示图的顶点 数目，m 表示图中边的数目。如果n 为0 表示输入结束。随后有m 行数据，每 行有两个值x 和y（0&lt;x, y &lt;=n），表示顶点x 和y 相连，顶点的编号从1 开始计 算。输入不保证这些边是否重复。 输出：对于每组输入数据，如果所有顶点都是连通的，输出 ’YES’ ，否则输 出 ’NO’。 123456789101112===样例输入===4 31 22 33 23 21 22 30 0===样例输出===NOYES 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;int map[1005];int n,m;int find(int i)&#123; return map[i]==i?i:find(map[i]);&#125;void init()&#123; for(int i=0;i&lt;n;i++) map[i]=i;&#125;int main()&#123; while(scanf(\"%d%d\",&amp;n,&amp;m)==2) &#123; if(n==0) break; init(); int a,b; for(int i=0;i&lt;m;i++) &#123; scanf(\"%d%d\",&amp;a,&amp;b); a--;b--; map[find(a)]=map[find(b)]; &#125; int cnt=0; for(int i=0;i&lt;n;i++) &#123; if(map[i]==i) cnt++; &#125; if(cnt==1) printf(\"YES\\n\"); else printf(\"NO\\n\"); &#125; return 0;&#125; 例子 题目链接：http://poj.org/problem?id=1611 题目大意： 中文就不解释了； 做法：把同一个集合的所有元素都放到同一个集合里， 当放完之后， 检查一下0号同学在哪个集合， 再判断一下剩下的同学是否和它在同一个集合里面； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// Created by fkjs on 2015-09-17// Copyright (c) 2015 fkjs. All rights reserved.////#pragma comment(linker, \"/STACK:1024000000,1024000000\")#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#define clr(x) memset(x, 0, sizeof(x))using namespace std;const int INF = 0x3f3f3f3f;const int maxm = 505;const int maxn = 30000 + 10;typedef long long int ll;int n, m;int pa[maxn];int find(int x)&#123;//并查集的基础-&gt;find函数， 它的特点就是pa[x] = find(pa[x]), 这一语句可以把该路径上的所有点的父亲都改成根节点； return x == pa[x] ? x : pa[x] = find(pa[x]);&#125;void connect(int x, int y)&#123;//链接两个并查集 int fa = find(x);//找到根节点， 当然找的过程中会更新路上的点； int fb = find(y);//同上； pa[fa] = fb;//链接两个集合；&#125;int main(void) &#123;#ifdef LOCAL //freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\in.txt\", \"r\", stdin); //freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\out.txt\", \"w\", stdout);#endif //ios_base::sync_with_stdio(0); while(scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; (n || m))&#123; for(int i = 0; i &lt; n; i++) pa[i] = i; for(int i = 0; i &lt; m; i++)&#123; int len; scanf(\"%d\", &amp;len); int x; scanf(\"%d\", &amp;x); int tp = x; for(int i = 1; i &lt; len; i++)&#123; scanf(\"%d\", &amp;x); connect(x, tp); tp = x; &#125; &#125; int ans = 0; int p = find(0);//找到最初感染者所在的集合， 它的根是p； for(int i = 0; i &lt; n; i++)//凡是根是p的人都被感染了； if(find(i) == p) ans++; printf(\"%d\\n\", ans); &#125; return 0;&#125; ​","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"Java课程第二次实验报告","slug":"Java课程第二次实验报告","date":"2019-04-25T00:58:21.000Z","updated":"2019-09-15T08:07:30.948Z","comments":true,"path":"2019/04/25/Java课程第二次实验报告/","link":"","permalink":"https://nymrli.top/2019/04/25/Java课程第二次实验报告/","excerpt":"","text":"Java课程第二次实验报告 1.寻找并输出11~999之间的数m，它满足m、m2、m3均为回文数。回文数是各位数字左右对称的整数。判断是否为回文要求通过编写方法来完成。 123456789101112131415161718public class HelloWorld &#123; public static boolean isPalindrome(int s) &#123; String str = Integer.toString(s); if( str.charAt(0) == str.charAt(str.length() - 1) ) return true; else return false; &#125; public static void main(String []args) &#123; for (int s = 11; s &lt; 1000; s++) &#123; if (isPalindrome(s) &amp;&amp; isPalindrome(s*s) &amp;&amp; isPalindrome(s*s*s) ) System.out.println(s); &#125; &#125; &#125; 2.由键盘输入10个整数，比较并输出其中的最大值和最小值。 12345678910111213141516import java.util.Scanner;public class HelloWorld &#123; public static void main(String []args) &#123; Scanner s = new Scanner(System.in); int []arr = new int[10]; int maxn = -1000000000; int minn = 1000000000; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = s.nextInt(); if ( arr[i] &lt; minn ) minn = arr[i]; if ( arr[i] &gt; maxn) maxn = arr[i]; &#125; System.out.printf(\"最大值:%d ，最小值:%d \\n\",maxn,minn); &#125;&#125; 3.随机产生50个1-100之间的整数，存放于一个10´5的二维数组中，要求按照10´5的格式打印这个数组（即共显示10行，每行5个数，数与数之间间隔一个空格），并求出该数组所有元素之和。 1234567891011121314151617181920public class HelloWorld &#123; final static int row = 10; final static int col = 5; static int [][]arr = new int[row][col]; public static void main(String []args) &#123; int sum = 0; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; arr[i][j] = (int)(Math.random()*100 + 1); sum += arr[i][j]; System.out.printf(\"%d \",arr[i][j]); &#125; System.out.println(); &#125; System.out.println(\"SUM:\"+sum+\"\"); &#125;&#125; 4.学生类的创建和使用 ①创建一个学Student类，成员变量包括：学号、班号、姓名、性别、年龄等，且都是private类型。 ②声明一个构造方法，初始化所有成员变量。 ③分别声明获得各属性的public类型的成员方法，方法名要求以get开头。 ④分别声明修改各属性的public类型的成员方法，方法名要求以set开头。 ⑤声明一个public类型的toString（）方法，把该类中的所有域信息组合成一个字符串。 ⑥声明统计创建Student对象的个数的私有域count和得到Student对象的个数的public方法。 ⑦将类Student放在子包student中。 ⑧在子包student外，创建测试类Student的主类。 在主类中：创建2个Student对象，输出对象的所有域信息；修改对象的姓名和年龄，输出修改后的姓名和年龄；比较两个Student对象的年龄的大小，输出年龄较大的Student对象。 Student.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package student;public class Student &#123; private int uid; private int classNum; private String name; private String gender; private int age; private static int cnt = 0; public Student(int uid , int classNum , String name , String gender , int age) &#123; this.uid = uid; this.classNum =classNum; this.name = name; this.gender = gender; this.age = age; cnt += 1; // TODO Auto-generated constructor stub &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; public int getUid() &#123; return uid; &#125; public void setClassNum(int classNum) &#123; this.classNum = classNum; &#125; public int getClassNum() &#123; return classNum; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getGender() &#123; return gender; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public static int getCnt() &#123; return cnt; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return String.format(\"学号为%d的同学，在%d班，姓名为%s，性别为%s，年龄为%d，\", uid,classNum,name,gender,age); &#125; &#125; HelloWorld.java 12345678910111213import student.*;public class HelloWorld &#123; public static void main(String []args) &#123; Student stu1 = new Student(1,1,\"cl\", \"male\", 20); Student stu2 = new Student(3,2,\"cjl\", \"female\", 20); System.out.println(stu1); System.out.println(stu2); stu1.setName(\"cl2\"); stu1.setAge(21); System.out.printf(\"修改之后的姓名:%s,修改后的年龄:%d\\n\",stu1.getName(),stu1.getAge()); System.out.println( stu1.getAge() &gt; stu2.getAge() ?stu1 : stu2); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"ACM-大数定理（高精度）","slug":"ACM-大数定理（高精度）","date":"2019-04-25T00:53:27.000Z","updated":"2020-05-28T10:40:42.046Z","comments":true,"path":"2019/04/25/ACM-大数定理（高精度）/","link":"","permalink":"https://nymrli.top/2019/04/25/ACM-大数定理（高精度）/","excerpt":"","text":"ACM-大数定理（高精度） 由于c/c++中数据类型的范围比较固定，因此有些题目的数据范围正好卡在这些正常范围之外，此时就需要自己实现大数加减乘除的运算。 c/c++需要自己手写 java中有BigInteger类 C++ 加法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;string add(string a , string b)&#123; a = a.substr(a.find_first_not_of(\"0\")); // 去前导0 b = b.substr(b.find_first_not_of(\"0\")); ll lenA = a.length(); ll lenB = b.length(); ll len = max(lenA,lenB) + 10; reverse(a.begin(),a.end()); // 翻转,方便相加 reverse(b.begin(),b.end());// cout &lt;&lt; \"a\" &lt;&lt; a &lt;&lt; endl;// cout &lt;&lt; \"b\" &lt;&lt; b &lt;&lt; endl; string ans(len,'0'); // ans全赋值为0 for(int i =0 ; i &lt; lenA ; i ++) ans[i] = a[i]; int tmp = 0; for(int i = 0 ; i &lt; len;i++)&#123; if ( i &lt; b.length() ) tmp += (ans[i] - '0') + (b[i] - '0'); else tmp += (ans[i] - '0') ; ans[i] = (tmp % 10) + '0'; tmp /= 10; &#125; reverse(ans.begin(),ans.end()); // 再将运算结果反转回来 return ans.substr(ans.find_first_not_of(\"0\")); // 仍然需要去前导0&#125;int main()&#123; string a = \"3\"; string b = \"2\"; cout &lt;&lt; add(a,b) &lt;&lt;endl; return 0 ;&#125; 1234567891011121314151617/**A/B/C都是倒序的数字, 比如123, 那么vector&lt;int&gt; A = &#123;3, 2, 1&#125;*/vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size() || i &lt; B.size() || t; i++) &#123; if (i &lt; A.size() ) t += A[i]; if (i &lt; B.size() ) t += B[i]; C.push_back(t % 10); t /= 10; &#125; // 去末尾0（前置） while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125; Java 加减乘除 1234567891011121314151617public class HelloWorld &#123; public static void main(String []args) &#123; BigInteger a = new BigInteger(\"100\"); BigInteger b = new BigInteger(\"2\"); System.out.println(a.add(b)); // 102 System.out.println(a.subtract(b)); // 98 System.out.println(a.multiply(b)); // 200 System.out.println(a.divide(b)); // 50 BigInteger []c = a.divideAndRemainder(b); System.out.printf(\"除数为:%d,余数为:%d\\n\", c[0],c[1] ); // 除数为:50,余数为:0 &#125;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"}]},{"title":"使用git将项目上传到github（最简单方法）","slug":"使用git将项目上传到github（最简单方法）","date":"2019-03-28T11:39:36.000Z","updated":"2019-09-15T08:07:31.024Z","comments":true,"path":"2019/03/28/使用git将项目上传到github（最简单方法）/","link":"","permalink":"https://nymrli.top/2019/03/28/使用git将项目上传到github（最简单方法）/","excerpt":"","text":"使用git将项目上传到github（最简单方法） 首先你需要一个github账号，所有还没有的话先去注册吧！ Github **我们使用git需要先安装git工具，这里给出下载地址，下载后一路直接安装即可：**https://git-for-windows.github.io/ 1.进入Github首页，点击New repository新建一个项目 2.填写相应信息后点击create即可 Repository name: 仓库名称 Description(可选): 仓库描述介绍 Public, Private : 仓库权限（公开共享，私有或指定合作者） Initialize this repository with a README: 添加一个README.md gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore license: 证书类型，对应生成文件LICENSE 创建完成后会变成（添加了README.md或者有license) 3.点击Clone or dowload会出现一个地址，copy这个地址备用。 4.接下来就到本地操作了 首先右键你的项目，如果你之前安装git成功的话，右键会出现两个新选项，分别为Git Gui Here,Git Bash Here,这里我们选择Git Bash Here，进入如下界面，Test_Bluetooth即为我的项目名。 5.接下来输入如下代码（关键步骤），把github上面的仓库克隆到本地 git clone https://github.com/CKTim/BlueTooth.git（https://github.com/CKTim/BlueTooth.git替换成你之前复制的地址） 6.复制文件到刚出来的文件夹中 这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名，如图我多出了个Test文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹不用），其余都复制到那个新多出的文件夹下， 7.接着继续输入命令 cd Test，进入Test文件夹 8.接下来依次输入以下代码即可完成其他剩余操作： 123git add . （注：别忘记后面的.，此操作是把Test文件夹下面的文件都添加进来）git commit -m \"提交信息\" （注：“提交信息”里面换成你需要，如“first commit”）git push -u origin master （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码）","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"学会Pull request","slug":"学会Pull-request","date":"2019-03-28T11:18:14.000Z","updated":"2019-09-15T08:07:31.046Z","comments":true,"path":"2019/03/28/学会Pull-request/","link":"","permalink":"https://nymrli.top/2019/03/28/学会Pull-request/","excerpt":"","text":"GitHub中发起PR(pull Request) PR是为了贡献代码: ​ 贡献代码，通俗的说，就是自己修改了代码，希望合并到别人的Repository(仓库)中。将自己的智慧贡献给开源社区。 一.贡献代码: 1.第一步:Fork 在GitHub社区闲逛时，看中了某个项目代码，如：spring-projects/spring-framework，点击页面Fork按钮，会生成一个自己的Repository(仓库：thinkingfioa/spring-framework),如下图： 2.第二步：修改 Fork成功后，通过git clone、修改、commit、push等操作后，将修改的内容，提交到自己仓库(thinkingfioa/spring-framework)中。如果对git clone、commit和push不知道的，自行百度。如下图: 3 第三步：请求合并代码(Pull Request) 在2步骤时，我们修改了自己的仓库(thinkingfioa/spring-framework)代码。我们希望贡献自己的一份力量，将修改的Commit也提交到别人的仓库(spring-projects/spring-framework)中。则要进行Pull Request。 3.1 创建PR 3.2 Create pull request 请特别注意下图中标红的部分，不能搞反了。点击: Create pull request 绿色按钮，完成提交PR。 3.3 等待 提交PR完成后，等待对方仓库(spring-projects/spring-framework)的管理员审核，如果他同意，则贡献代码完成了。 二.同步最新代码 PR除了贡献代码外，还可以同步对方最新代码。通俗的说，fork某个仓库(如: spring-projects/spring-framework)代码一段时间后，为了同步自己仓库(thinkingfioa/spring-framework)和对方仓库(spring-projects/spring-framework)代码，保证自己仓库代码是最新版本。 2.1.1 Create pull request 这一步和上面3.2一样的，只是要注意箭头，哪个仓库合并哪个仓库。请自习注意下图标红部分 2.1.2 点击绿色按钮，完成代码同步 摘自:https://blog.csdn.net/thinking_fioa/article/details/79516352?tdsourcetag=s_pctim_aiomsg GitHub之接收、处理Pull Request 1.创建一个仓库来演示下。 假设创建仓库的人称为:“老大” 2.成员Fork后修改 成员x695 在自己的网页上fork这个仓库，然后git clone到本地，然后创建特性分支，基于特性分支修改完成提交，push到origin 远程仓库git push origin (master(本地):master(远程) ) 3.成员发PR到老大 4.老大登陆自己的账号，到PR页签 5.老大在本地的检查 为了防止这个成员乱改，如果不检查可以直接进行步骤6老大还要检查下假如还要用于演示的话，老大就要把代码拉到本地了，看看修改后有啥区别 git clone 自己创建的项目 git remote add stream 项目成员的仓库/获取项目成员仓库设置为本地仓库的远程仓库 git fetch 获取项目成员的仓库数据 将成员的仓库和分支数据全部拉到自己本地后，创建一个用户检查的分支 pr1，并进入这个分支 将项目成员的number1 分支和自己的分支pr1进行合并 git merge stream/number1 这样一来分支pr1就和项目成员的分支number1一样了，检查完毕，进行删除 git branch -D pr1 6.老大合并或评论PR 点击 add number1 可以回复评论，然后也可以直接点击 merge pull request 通过 老大如果不愿意登陆网页，也可以在本地进行如下操作 在步骤5中已经完成了，前2步的前提下进行下一步 git checkout master,切换到主分支 git merge stream/number1 将成员的分支合并到主分支 push前进行检查，git diff oragin/master 看看本地合并后的仓库和远端的有啥区别 如果确认无误直接进行git push 就可以了 完成上面的5步之后，仓库的Pull Request 会自动成Open状态变成Close 状态。 摘自:https://blog.csdn.net/x6_9x/article/details/50902777 Github官方文档 About pull requests Merging a pull request Closing a pull request Checking out pull requests locally","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"蓝桥杯突击训练","slug":"蓝桥杯突击训练","date":"2019-03-28T02:35:12.000Z","updated":"2020-09-17T02:09:36.481Z","comments":true,"path":"2019/03/28/蓝桥杯突击训练/","link":"","permalink":"https://nymrli.top/2019/03/28/蓝桥杯突击训练/","excerpt":"","text":"ACM 3-20笔记 3部排序 左指针，右指针， 探路指针–&gt;链表的pq 马虎的算式 枚举（五重循环，注意条件） 内存1000ms大约运行10^8的指令 大数除法 减法 除法 39级阶梯 斐波那契 简化模型后再加上考虑条件 错误票据 获得一行内容：getline()前要用getchar()吃掉换行符 分割一行以空格分隔的元素 12345string s;getline(cin,s);stringstream ss(s);string tmp;while( getline(ss,tmp,\" \") ) ▲翻硬币 ACM 3-21笔记 （2014年） 奇怪的分式 gcd辗转相除法 枚举 蚂蚁感冒 日本白书的蚂蚁模型：穿过身体 ▲地宫取宝 深搜 递归 取模 面对&amp;41004^{100}4100优化思考方向： 贪心 ： 知道有一条最好的路 —X---&gt; 这题要求每种情况都遍历 重复子问题 ： 记忆化搜索 dfs(int x, int y , int max,int cnt)，虽然x,y都是不同的，但max,cnt可能会有相同的值，这些情况是重复的 动态规划 （递推方式）： ACM 3-22笔记 (2015) T5-全排列 DFS框架 递归 回溯 T7-牌型种数 排列组合 一般都是用递归解决 回溯（恢复初始状态）：袋子理论 --&gt; 每次都得把自己的袋子清空再返回 两种思路： 13次选牌(O(1313)O(13^{13})O(1313)) 每张牌选几次（更简单O(513)O(5^{13})O(513)) T9-垒骰子 递归 分治法 逐步生成 ACM 3-23 (2016) 凑数字 多个不同的数字----&gt;全排列问题 附录：通用的代码工具 void i2s(string &amp;s, int &amp;num) 12345void i2s(string &amp;s, int &amp;num)&#123; stringstream ss; ss &lt;&lt; num; ss &gt; s;&#125; string去前置0 123void removePre0(string &amp;s)&#123; s = s.substr(s.find_first_not_of(\"0\"))&#125; string回溯去最后一个元素 123path += pai[i];f(k-1,path);path.erase(path.end()-1) 求最大公因数(辗转相除法)： 123456int gcd(int a,int b)&#123; if( a%b == 0) return b; //极端情况最大的公约数为两个中最小的一个 return gcd(b,a%b); // 被除数为其中小的那个&#125; 漫画图解 全排列 next_premutation 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; while(scanf(\"%d\",&amp;n)&amp;&amp;n)&#123; int a[1000]; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; sort(a,a+n);//可以自行测试一下删除后的结果 do&#123; for(int i=0;i&lt;n;i++) printf(\"%d \",a[i]); printf(\"\\n\"); &#125;while(next_permutation(a,a+n)); &#125; return 0;&#125; 如果有sort()，输出为 0 1 2 0 2 1 1 0 2 1 2 0 2 0 1 2 1 0 若无，则输出为 1 0 2 1 2 0 2 0 1 2 1 0 可以发现少了许多种组合方法。 不过，仔细比较各种组合方法和有无sort()的输出，可以发现函数next_permutation()是按照字典序产生排列的，并且是从数组中当前的字典序开始依次增大直至到最大字典序。 △.sort()默认排序从小到大 DFS+回溯法 123456789101112131415161718192021222324252627282930#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100+5;#define NUM 5int arr[] = &#123;1,2,3,4,5&#125;;void f(int k)&#123; if( k == NUM)&#123; for(int i = 0 ; i&lt; NUM; i++) cout &lt;&lt; arr[i]; cout &lt;&lt;endl; return ; &#125; for(int i=k ; i &lt;NUM ; i++)&#123; &#123; int t = arr[i]; arr[i] = arr[k]; arr[k] = t; &#125; f(k+1); // 回溯复原 &#123; int t = arr[i]; arr[i] = arr[k]; arr[k] = t; &#125; &#125;&#125; C++输入输出流设置 1234567#include &lt;bits/stdc++.h&gt; //万能头文件using namespace std; //命名空间int main() &#123; ios::sync_with_stdio(false); //取消输入输出流等待同步 ... if (i != n) cout &lt;&lt; endl; //每个输出样例间有换行,(可理解每个CASE后加个换行,最后一行没有)&#125; C语言里的输入输出问题 1234int d,float f,char str[20],scanf(\"%d%f%s\",d,f,str); scanf: 使用 scanf 输入 42 scanf()中使用%c说明符，该函数将只读取字符4 并将其存储在一个char类型的变量中 如果使用%s说明符，该函数会读取两个字符，即字符4和字符2，并将它们存储在一个字符串中。 如果使用%d说明符，则scanf 读取同样的两个字符，但是随后它会继续计算与它们的相应的整数值为4*10+2 得到 42；然后将该整数的二进制表示保存在一个int变量中， 如果使用%f说明符 则scanf（）读取这两个字符 计算它们对应的数值 42，然后以内部的浮点表述该值，并将结果保存在一个float变量中 123456789101112/**0234500067103456050020456006710000000089通过控制读入的位数,读入矩阵*/for(c=1;c&lt;=m;c++)&#123; //循环变量稍微有点奇怪 for(d=1;d&lt;=n;d++) scanf(\"%1d\",&amp;mapp[c][d]); &#125; getchar(): getchar()只能输入字符型,输入时遇到回车键才从缓冲区依次提取字符. 说明：当程序调用getchar()函数时，程序就等着用户按键，用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止（回车字符也放在缓冲区中）。当用户键入回车之后，getchar()函数才开始从键盘缓冲区中每次读入一个字符。也就是说，后续的getchar()函数调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才重新等待用户按键。 分割输入 123456789101112131415161718192021222324252627282930313233/* 迷宫题目010010001000000101110000*/for(int i=1 ; i &lt;= row ; i++)&#123; for(int j= 1; j &lt;= col ; j++) scanf(\"%c\",&amp;maze[i][j]); getchar();&#125;// ---错误票据--int n ;cin &gt;&gt; n ;getchar();vector&lt;int&gt; v;while(n--)&#123; string s; getline(cin,s); stringstream ss(s); string tmp; while( getline(ss,tmp,' ') )&#123; v.push_back( s2i(tmp) ); &#125;&#125;// ****C++输入流不同步设置****int main()&#123; ios::sync_with_stdio(false); ...&#125; 循环移位运算 12345678910111213141516171819202122232425262728/*** 递推得到幂运算* @param base基底，n幂次*/int selfpow(int base,int n)&#123; int res = 1; while( n-- )&#123; res *= base; &#125; return res;&#125;/*** 自己实现x位二进制循环左移* e.g. 8=1000 ， 左移=&gt; 0001* @param n为len位中只有一位为1的十进制数*/int ROL(int n,int len,int dir = 1)&#123; if ( dir == 1) &#123; n &lt;&lt;= 1; if ( n % selfpow(2,len) == 0 ) n = 1; &#125;else&#123; n &gt;&gt;= 1; if( n == 0 ) n = selfpow(2,len-1); &#125; return n;&#125; 宏定义循环 123456789101112#define rep(i,n) for (int i = 0; i &lt; (n); ++i)#define Forneq(i,s,n) for (int i = (s); i &lt; (n); ++i)#define Foreq(i,s,n) for (int i = (s); i &lt;= (n); ++i)int main()&#123; rep(i,3)&#123; cout &lt;&lt; 1 &lt;&lt; endl; &#125; For(i,1,2)&#123; cout &lt;&lt; 2 &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"C++机器学习库MLPack","slug":"C++机器学习库MLPack","date":"2019-03-25T09:44:11.000Z","updated":"2019-09-15T08:07:30.922Z","comments":true,"path":"2019/03/25/C++机器学习库MLPack/","link":"","permalink":"https://nymrli.top/2019/03/25/C++机器学习库MLPack/","excerpt":"","text":"C++机器学习库MLPack mlpack: a scalable C++ machine learning library 由于在网上查了一下发现安装这个库碰到了不少问题，所以还是记录一下安装过程。 安装 列出两种安装教程吧，第一种实测可以。第二种在测试Armadillo的时候没通过，还是缺库，有兴趣的人可以通过给的Armadillo官网链接下载安装Armadillo再试试 安装方法一： Mlpack 官网 提供了下载的方法 ： sudo apt-get install libmlpack-dev ， 但貌似有博客指出目前国内源里是没有这个镜像的，所以采取的办法是直接从观望上下载mlpack-3.0.0.tar.gz（没敢使用最新的，怕出错） 来编译安装 12345678$ tar -xvf mlpack-3.0.0.tar.gz $ cd mlpack-1.0.12 $ mkdir build $ sudo apt-get install libboost-math-dev libboost-program-options-dev libboost-random-dev libboost-test-dev libxml2-dev libarmadillo-dev $ cd build $ cmake ..$ make -j4$ sudo make install 注意根据报错信息：Maybe need administrative privileges.，所以 make install 前面要加上sudo权限 1234567[ 51%] Built target mlpack_sparse_coding[100%] Built target mlpack_testInstall the project...-- Install configuration: \"\"CMake Error at cmake_install.cmake:36 (file): file cannot create directory: /usr/local/lib/pkgconfig. Maybe need administrative privileges. 然后就是可选的编译条件，就是你只想安装其中一些包，也是可以的： $ make pca allknn allkfn ,只安装pca allknn allkfn这几个算法包。 摘自：http://www.linuxdiyf.com/linux/27052.html 安装方式二：（不推荐） 安装依赖库 1234Armadillo &gt;= 6.500.0Boost (program_options, math_c99, unit_test_framework, serialization, spirit)CMake &gt;= 2.8.5 Aramdillo 安装 （Ubuntu为例子） 首先安装Armadillo依赖的库：lapack, blas, boost 123$ sudo apt-get install liblapack-dev$ sudo apt-get install libblas-dev$ sudo apt-get install libboost-dev 接下来 安装Armadillo：sudo apt-get libarmadillo-dev 之后，安装完成，测试是否完成！以上步骤，都是应该可以直接完成的，需要Cmake和g++提前安装。 g++ test.cpp -o test -larmadillo 1234567891011#include &lt;iostream&gt;#include &lt;armadillo&gt;using namespace std;using namespace arma;//test.cppint main(int argc,char** argv) &#123; mat A=randu&lt;mat&gt;(4,5); mat B=randu&lt;mat&gt;(4,5); cout&lt;&lt;A*trans(B)&lt;&lt;endl; return 0;&#125; 网上还有说Armadillo也无法找不到镜像， 于是还是到官网下载下来编译安装，[Armadillo C++ matrix library]( Boost库的安装 apt-get install libboost-math-dev libboost-program-options-dev libboost-random-dev libboost-test-dev libxml2-dev mlpack安装 也是去官网下载编译安装 12345678910$ tar -xzf mlpack-2.0.1.tar.gz # tar解压$ cd mlpack-2.0.1 # 进入解压后的目录$ unzip mlpack-2.0.1.zip # zip解压$ cd mlpack-2.0.1 # 进入解压后的目录# 之后，建立build目录，cmake，make即可$ mkdir build$ cd build$ cmake ../$ make $ sudo make install 使用mlpack 源文件中有各种算法的例子，可以学习其使用方法，这里需要注意一点，在编译和链接时，都要加上-lmlpack -larmadillo，来包含所需库。 如编写下列代码: 123456#include &lt;mlpack/core.hpp&gt;using namespace std;int main()&#123; cout &lt;&lt; mlpack::util::GetVersion() &lt;&lt; endl; return 0;&#125; ▲.注意.编译的命令为g++ -std=c++11 testmlpack.cpp -o testlars -l mlpack -l armadillo，其中要加上**-std=c++11**，不然无法编译通过。 [Armadillo C++ ML library]http://arma.sourceforge.net/download.html) 如果Armadillo出错，可以去官网[Armadillo C++ ML library]http://arma.sourceforge.net/download.html)下载编译安装","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"南京邮电大学java程序设计作业在线编程第六次作业","slug":"南京邮电大学java程序设计作业在线编程第六次作业","date":"2019-03-17T05:29:36.000Z","updated":"2019-09-15T08:07:31.038Z","comments":true,"path":"2019/03/17/南京邮电大学java程序设计作业在线编程第六次作业/","link":"","permalink":"https://nymrli.top/2019/03/17/南京邮电大学java程序设计作业在线编程第六次作业/","excerpt":"","text":"总分：100 选择题得分：40 1.下列方法定义中，正确的是（） A.double me（int a，int b）{int r; r = ab} B.double me（a，b）{return b;} C.int me（int a，int b）{return（a-b）;} D.int me（inta，b）{return（a-b）;} 正确答案是：C 2.下列方法定义中，不正确的是（） A.float x（int a，int b）{return（ab）;} B.int x（int a，int b）{return ab;} C.int x（int a，int b）{return a * b;} D.int x（int a，int b）{return 1.2 *（a + b）;} 正确答案是：D 3.下面哪个数据类型占用的内存最大？（） A.int B.float C.double D.byte 正确答案是：C 4.下面哪个不属于Java的关键字？（） A.static B.final C.super D.sub 正确答案是：D 5.下面的标识符中哪个是合法的标识符？（） A.–a B.Test C.class D.＃ABC 正确答案是：B 6.下列语句序列执行后，c的值是（）int a = 3，b = 4，c = 0; （（a ）&lt;（ - b）） c; A.0 B.1 C.2 D.3 正确答案是：A 7.下面关于数组定义语句不正确的是（） A.float f [] = new {2.4f，3.5f，5.7f，7.9f}; B.int a [] = {1,2,3,4,5} C.double [] d = new double [10]; D.int [] a2; 正确答案是：A 8.下面（）是Java数据类型中的int类型的取值范围。 A.$-2^ 7 $〜27−12^ 7 -127−1 B.0 〜 216−12 ^ {16} -1216−1 C.$-2 ^ {15} $^ 〜 215−12 ^{ 15} -1215−1 D.−231​-2 ^ {31}​−231​ 〜231−1​2 ^ {31} -1​231−1​ 正确答案是：D 9.在Java语言中，下面（）类型可以表示整数基本数据类型。 A.single B.byte C.double D.char 正确答案是：B 10.假设int a = -3; 则表达式a&gt; 0？a：-a的结果是（） A.true B.false C.-3 D.3 正确答案是：D 编程题得分：60 输出所有的3位数字的质数得分：10/10 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.IOException;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args) throws IOException&#123; int size = 1000; int prime[] = new int[1000]; int pos=0; boolean flag; for (int i = 100; i &lt; size; i++) &#123; flag = false; for(int j=2; j &lt;= Math.sqrt(i) ; j++) &#123; if (i%j == 0)&#123; flag = true; break; &#125; &#125; if ( !flag ) prime[pos++] = i; &#125; int pf=0; for (int i = 0; i &lt; prime.length; i++) &#123; if (prime[i] != 0) &#123; System.out.printf(\"%6d\",prime[i]); pf ++; if (pf == 5) &#123; pf = 0; System.out.println(); &#125; &#125; &#125; &#125;&#125; 数列求和得分：10/10 12345678910111213141516171819202122232425262728293031323334353637import java.io.IOException;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args) throws IOException&#123; Scanner s = new Scanner(System.in); double x = s.nextDouble(); int cnt = 1; double sum = 0; double single ; do &#123; single = Math.pow(x, cnt)/fac(cnt); sum += Math.pow(-1, (cnt+1) % 2)*single; cnt ++; &#125; while ( Math.abs(single) &gt; 1e-4 ); System.out.printf(\"%.2f\\n\",sum); &#125; /** * @Target: 递归求阶乘 * @param a * @return a! */ public static int fac (int a) &#123; if (a == 0 || a == 1) return 1; return a*fac(a-1); &#125; &#125; 最大公约数得分：10/10 12345678910111213141516171819202122import java.io.IOException;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args) throws IOException&#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); int b = s.nextInt(); System.out.printf(\"%d\",gcd(a,b)); &#125; public static int gcd(int a,int b) &#123; if ( b==0 ) return a; return gcd(b,a%b); &#125;&#125; 输出斐波那契数列的前10得分：10/10 1234567891011121314151617181920212223import java.io.IOException;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args) throws IOException&#123; int arr[] = new int[20]; int len = 10; arr[0] = 1; arr[1] = 1; for (int i = 2; i &lt;len; i++) arr[i] = arr[i-2] + arr[i-1]; for (int i = 0; i &lt;len; i++) &#123; System.out.printf(\"%d\",arr[i]); if( i != len - 1) System.out.print(\" \"); else System.out.println(); &#125; &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"南京邮电大学java程序设计作业在线编程第五次作业","slug":"南京邮电大学java程序设计作业在线编程第五次作业","date":"2019-03-17T03:44:36.000Z","updated":"2019-09-15T08:07:31.036Z","comments":true,"path":"2019/03/17/南京邮电大学java程序设计作业在线编程第五次作业/","link":"","permalink":"https://nymrli.top/2019/03/17/南京邮电大学java程序设计作业在线编程第五次作业/","excerpt":"","text":"总分：100 选择题得分：50 以下哪一个工具是Java的编译器？( ) A.javac.exe B.java.exe C.javap.exe D.javadoc.exe 正确答案是: A 以下哪一个数据类型不属于Java的基本数据类型？( ) A.boolean B.char C.int D.String 正确答案是: D 假设有如下类的定义： public class test{ public static void main(String[] args){ int a= 3, b = 4; swap(a,b); System.out.println(“a=”+a + &quot; b=&quot; + b); } public static void swap(int a,int b){ int tmp = a; a = b; b = tmp; } } 程序运行后结果为( ) A.a=4 b=3 B.a=3 b=4 C.a=a b=b D.无结果输出 正确答案是: B 执行如下代码后，b的值是( ) int a=0, b=0; do{ --b; a = a-1; }while(a&gt;0); A.0 B.1 C.-1 D.死循环 正确答案是: C 下列关于Java中的数组的说法，错误的是( )。 A.数组中的元素的类型必须相同 B.数组中的元素是有顺序的 C.数组对象，属于引用类型 D.数组的大小可以任意改变 正确答案是: D 在循环体中，如果想结束本次循环，可以使用哪个语句？（ ）。 A.break B.continue C.final D.finally 正确答案是: B 下列标识符中，哪一个是非法标识符？（ ） A.statics B.static_10 C.10static D.$statics10 正确答案是: C 设有数组的定义int[] a = new int[3]，则下面对数组元素的引用错误的是（ ）。 A.a[0] B.a[a.length-1] C.int i=0;a[i] D.a[a.length]-1 正确答案是: D int a=new int[2][3]，则该数组包含（ ）个数组元素。 A.2 B.3 C.6 D.不确定 正确答案是: C 下面的代码段执行之后count的值是什么（ ） int count = 1; for (int i = 1; i &lt;= 5; i++) { count += i; } System.out.println(count); A.5 B.1 C.15 D.16 正确答案是: D 编程题得分：50 数字加密 得分：10 / 10 1234567891011121314151617181920212223import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123;public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int n = s.nextInt(); int arr[] = new int[4]; int cnt = 3; while(n!=0) &#123; arr[cnt--] = (n%10 + 9)%10; n /= 10; &#125; System.out.printf(\"The encrypted number is %d%d%d%d\\n\",arr[2],arr[3],arr[0],arr[1]); &#125; &#125; 数列排序 得分：10 / 10 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int arr[] = new int[20]; int len = arr.length; for(int i=0; i &lt; len; i++) arr[i] = s.nextInt(); bubble(arr); for(int i=0; i &lt; len; i++) &#123; System.out.printf(\"%4d\",arr[i]); if ( i == len-1) System.out.println(); //else System.out.print(\" \"); &#125; &#125; /** * @Target: 冒泡排序 * @param arr待排数组 */ public static void bubble(int arr[]) &#123; int start = 5; // 第6个元素的下标是5 int len = 14; // 第15个元素的下标是14 int tmp ; // 交换的临时变量 for (int i = start; i &lt; len; i++) &#123; for (int j = start; j &lt; len-(i-start); j++) &#123; // 类比从0 开始的冒泡,这边需要改成len-(i-start),因为j的范围只能是(start,len) if ( arr[j] &lt; arr[j+1]) &#123; tmp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = tmp; &#125; &#125; &#125; &#125; &#125; 打印杨辉三角形 得分：10 / 10 12345678910111213141516171819202122232425262728293031import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int hang = s.nextInt(); int arr[][] = new int[hang][hang]; arr[0][0] = 1; for (int i = 1; i &lt; hang ; i++) &#123; arr[i][0] = 1; arr[i][i] = 1; for (int j = 1; j &lt; hang; j++) &#123; arr[i][j] = arr[i-1][j] + arr[i-1][j-1]; &#125; &#125; for (int i = 0; i &lt; hang ; i++) &#123; for (int j = 0; j &lt; hang; j++) &#123; if (arr[i][j] != 0 ) System.out.printf(\"%5d\",arr[i][j]); &#125; System.out.println(); &#125; &#125;&#125; 构造指定的数列 得分：10 / 10 12345678910111213141516171819202122232425import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); int b = s.nextInt(); int cnt = 0 ; int arr[] = new int[1000]; for (int i = a; i &lt;= b; i++) &#123; if ( i % 7 == 0 || i % 11 == 0) &#123; if ( !(i % 7 == 0 &amp;&amp; i % 11 == 0) ) arr[cnt++] = i; &#125; &#125; for(int x : arr) if ( x!= 0) System.out.printf(\"%d \",x); &#125;&#125; 求平均值 得分：10 / 10 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.IOException;import java.util.Arrays;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int num = s.nextInt(); int sum = 0; //去除最大最小值的总和 int cnt = 0; //要去掉的个数 int arr[] = new int[num]; for (int i = 0; i &lt; num; i++) arr[i]= s.nextInt(); Arrays.sort(arr); // 排序,默认从大到小 System.out.printf(\"max element:%d\\n\", arr[num-1]); // 第一个是最大的 System.out.printf(\"min element:%d\\n\", arr[0]); // 最后一个是最小的 // 去掉最大和最小项 for (int i = 1; i &lt; num-1; i++) &#123; if ( arr[i] == arr[0] || arr[i] == arr[num-1] ) &#123; arr[i] = 0 ; cnt ++ ; &#125; &#125; // 是否全是最小最大值 boolean flag = false; for (int i = 1; i &lt; num-1; i++) &#123; if (arr[i] != 0) &#123; flag = true; sum += arr[i]; &#125; &#125; if (flag == true) System.out.printf(\"average is %5.2f\\n\", (double)sum/(num-(cnt+2))); else System.out.printf(\"no solution\\n\"); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Linux命令手册","slug":"Linux命令手册","date":"2019-03-15T14:33:26.000Z","updated":"2021-11-08T02:37:55.977Z","comments":true,"path":"2019/03/15/Linux命令手册/","link":"","permalink":"https://nymrli.top/2019/03/15/Linux命令手册/","excerpt":"","text":"scp 1、从服务器上下载文件 1scp username@servername:/path/filename /var/www/local_dir（本地目录） 例如scp root@192.168.0.101:/var/www/test.txt 把192.168.0.101上的/var/www/test.txt 的文件下载到/var/www/local_dir（本地目录） 2、上传本地文件到服务器 1scp /path/filename username@servername:/path 例如scp /var/www/test.php root@192.168.0.101:/var/www/ 把本机/var/www/目录下的test.php文件上传到192.168.0.101这台服务器上的/var/www/目录中 3、从服务器下载整个目录 1scp -r username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录） 例如:scp -r root@192.168.0.101:/var/www/test /var/www/ 4、上传目录到服务器 1scp -r local_dir username@servername:remote_dir例如：scp -r test root@192.168.0.101:/var/www/ 把当前目录下的test目录上传到服务器的/var/www/ 目录 12345678910111213141516$ ssh root@47.98.233.15@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:8hgJ8jpcBr1tm6HS72FpXwMrjba8MQqlqYJQLPB/Qf4.Please contact your system administrator.Add correct host key in /Users/wangdong/.ssh/known_hosts to get rid of this message.Offending ECDSA key in /Users/wangdong/.ssh/known_hosts:26ECDSA host key for 47.98.233.15 has changed and you have requested strict checking.Host key verification failed.# 从网上截的,自己电脑报错没报错按报错的提示,需要将C:\\Users\\10630\\.ssh中的known_hosts中的内容删掉,因为他默认先从这里边找相同IP的,删掉后就行了 ssh SSH分客户端openssh-client和服务器端openssh-server，如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudo apt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server 下面讲解openssh-server 首先更新源 1sudo apt-get update 安装ssh服务 1sudo apt-get install openssh-server 检测是否已启动 1ps -e | grep ssh 看到有ssh字样，说明已启动，如果没有就手动启动 1/etc/init.d/ssh start 配置ssh-server，配置文件位于/etc/ssh/sshd_config，默认端口为22，为了安全，一般自定义为其他端口，然后重启 1sudo /etc/init.d/ssh resart 增加桌面快捷方式 Launcher : ​ 在/usr/share/applications/中写入Roboviz.desktop文件(sudo vim Roboviz.desktop) 123456789[Desktop Entry]Name=RobovizComment=RobovizExec=/home/apollo3d/RoboViz-dev/bin/linux-amd64/roboviz.shIcon=/home/apollo3d/RoboViz-dev/bin/linux-amd64/resources/images/icon.pngTerminal=trueStartupNotify=trueType=ApplicationCategories=Development;IDE; ps aux | grep进程名 ps -A 显示所有程序。 ps e 列出程序时，显示每个程序所使用的环境变量。 kill －9 324 killall -9 NAME Linux下还提供了一个killall命令，可以直接使用进程的名字而不是进程标识号 chmod {u|g|o|a}{+|-|=}{r|w|x} filename 修改权限 find pathname [option] expression 寻找文件 grep [option] pattern filenames 搜索文件中匹配符 ​ grep -r 二进制 /home/apollo3d/Documents ./文件名 进入到进程的执行文件所在的路径下，执行文件 https://www.cnblogs.com/lcword/p/6046261.html 端口操作 端口监听信息 netstat -plant 一、查看哪些端口被打开 netstat -anp 二、关闭端口号:iptables -A OUTPUT -p tcp --dport 端口号 -j DROP 三、打开端口号：iptables -A INPUT -p tcp --dport 端口号 -j ACCEPT 四、以下是linux打开端口命令的使用方法。 nc -lp 23 &amp;(打开23端口，即telnet) netstat -an | grep 23 (查看是否打开23端口) 或者 lsof -i:80 五、linux打开端口命令每一个打开的端口，都需要有相应的监听程序才可以 创建新用户 在 root 用户下运行这条命令创建一个新用户，yangxg 是用户名 因为我叫杨学光，所以我取的用户名是 yangxg 选择一个你喜欢的用户名，不一定非得和我的相同 root@localhost:~# useradd -m -s /bin/bash yangxg 把新创建的用户加入超级权限组 root@localhost:~# usermod -a -G sudo yangxg 为新用户设置密码 注意在输密码的时候不会有字符显示，不要以为键盘坏了，正常输入即可 root@localhost:~# passwd yangxg 切换到创建的新用户 root@localhost:~# su - yangxg 切换成功，@符号前面已经是新用户名而不是 root 了 yangxg@localhost:~$ 为root用户提供初始密码 sudo passwd root 修改为阿里云 DNS 您必须是管理员root或者具有管理员权限 sudo vim /etc/resolv.conf 加入: 12nameserver 223.5.5.5nameserver 223.6.6.6 保存退出，然后使用dig 验证: dig www.taobao.com +short若出现结果则表示正常。 换源(更换数据源) 12345rootdubuntu:/home/lusifer# curl -sSL https://get. daocloud. io/docker | shExecuting docker install script, commit:1d31602+sh-c apt-get update-qq&gt;/dev/null E: Could not get Lock /var/lib/apt/lists/lock-open (11: Resource temporarily unavailable)E: Unable to lock directory /var/lib/apt/lists/ 原因可能是没有更新数据源 1.备份默认的源sudo cp /etc/apt/sources.list /etc/apt/sources_init.list 2.用你熟悉的编辑器打开：如vim /etc/apt/sources.list替换默认的http://archive.ubuntu.com/为mirrors.aliyun.com 123456789101112131415deb http://mirrors.aliyun.com/ubuntu/ xenial maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial maindeb http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe 最后输入sudo apt-get update Ubuntu无法找到add-apt-repository问题的解决方法 网上查了一下资料，原来是需要python-software-propertiduanjkes 于是apt-get install python-software-properties 除此之外还要安装software-properties-common 于是apt-get install software-properties-common 然后就能用add-apt-repository了 代理 搜索代理 env | grep proxy、sudo grep -r -i http_proxy=代理地址 配置代理 临时:export http_proxy=http://10.3.0.1:80 (1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。) Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;; 保存apt.conf文件。 (2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件) 建立文件 vim proxyfile Acquire::http::proxy &quot;http://10.3.0.1:80&quot;; Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;; Acquire::https::proxy &quot;http://10.3.0.1:80&quot;; 使用时sudo apt-get install xxx -c proxyfile (2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 ) 在您的.bashrc文件末尾添加如下内容 export http_proxy=http://用户名:密码@地址:端口/ export https_proxy=http://用户名:密码@地址:端口/ export ftp_proxy=http://用户名:密码@地址:端口/ ubuntu 代理配置 PPA 1.vim /usr/lib/python3/dist-packages/softwareproperties/ppa.py 在函数def _get_https_content_py3（lp_url）的catch案例中添加了一个print（e）显示了错误的真正原因。 2.系统时间是否正确 3.除了配置代理之外，请告诉sudo使用-E该标志来考虑环境 123export http_proxy=http://&lt;proxy&gt;:&lt;port&gt;export https_proxy=http://&lt;proxy&gt;:&lt;port&gt;sudo -E apt-add-repository ppa:canonical-qt5-edgers/qt5-proper with username and password: 1export https_proxy=&lt;username&gt;:&lt;password&gt;@&lt;proxy&gt;:&lt;port&gt; Ubuntu下让终端走SS代理的方法 Ubuntu下让终端走SS代理需要第三方软件的帮助，即privoxy。 privoxy 是非快取式 (non-caching) 的网页代理伺服器，具有进阶的过滤能力，可强化隐私权，还可以修改网页资料、管理 HTTP cookies、去除广告等。 安装 privoxy sudo apt-get install privoxy 安装完成后在 /etc/privoxy 目录下可以找到配置文件 config。 配置 privoxy 一般地，改配置前应该备份配置。 mv /etc/privoxy/config /etc/privoxy/config.back 然后打开 config 文件，找到listen-address那一行，修改值为 privoxy 监听的地址，一般使用默认。 然后再找到forward-socks5那一行，去掉注释，值为SS代理监听的地址。 让终端走SS代理,修改配置后，重启 privoxy。 sudo /etc/init.d/privoxy restart 然后在终端下添加 http 代理。 export http_proxy=”127.0.0.1:8118” export https_proxy=”127.0.0.1:8118” 然后就可以愉快的用终端翻墙了。 原文：https://blog.csdn.net/tailgo/article/details/52075643 Lets Encrypt 配置SSL错误 DNS problem: NXDOMAIN looking up A for xxx 刚刚解析了A记录，解析服务器还没有生效 服务器本地 DNS缓存未更新 1. 首先确定A记录是否成效 确定的方式很简单，在浏览器输入自己的域名，查看能否访问成功。 2. 确定DNS是否有问题 1) ping主机 12# ping主机，如果无法发现host，则确定是dns问题$ ping demo.ptbird.cn 2) 更新DNS缓存 不建议直接 network restart 使用nscd 如果系统没装可以装一下，nscd做DNS缓存加速很有用。 centos : yum install nscd、ubuntu ：apt-get install nscd 如果已经装了直接更新 1234# 主要是hosts$ nscd -i passwd$ nscd -i group$ nscd -i hosts grep指令参数说明 https://www.cnblogs.com/forestwolf/p/6413916.html 查看文件最后修改日期,返回值为时间戳stat -c %Y filename 查看系统(软件)时间date、硬件时间clock -s,用硬件时间覆盖软件时间 -w,用软件时间覆盖硬件时间 与远程主机同步时间ntpdate ip 内部、外部命令 enable查看内部命令 外部命令的搜索目录在$PATH中指定 搜索时的优秀顺序根据hash缓存来决定,hash -d name清空name的缓存,hash -r清空所有缓存 使用内部命令而不使用别名 e.g. ls 12345678ls &lt;==&gt; /bin/ls --color=auto# 如何不调用别名呢1. /bin/ls2. \\ls3. 'ls'4. \"ls\"5. command ls 别名alias: 优先级: alias &gt; 内部命令 &gt; 外部命令 设置别名alias xxx=yyy 取消所有别名unalias -a 设置语言 1.先修改配置文件vim /etc/sysconfig/i18n中将en_US.UTF-8改成zh_CN.UTF-8, 2.然后. /etc/sysconfig/i18n立即生效 3.测试wall &quot;Hello&quot;给登录该服务器的用户发送信息 查看历史命令 history,查看到id后,可以!id进行再调用…!!执行前一个命令 123456!string 重复前一个以“string\"开头的命令!?string 重复前一个包含string的命令!string:p仅打印命令历史，而不执行!$：p打印输出！$（上一条命令的最后一个参数）的内容!*：p打印输出！*（上一条命令的所有参数）的内容Astring 删除上一条命令中的第一个string Astring1Astring2将上一条命令中的第一个string1替换为string2!:gs/string1/string2将上一条命令中所有的string1都替换为string2 $HISTSIZE记录了最大记录数 命令行历史保存在历史中,直到正常退出后会写入~/.bash_history里 VIM插件管理 1.安装 1234# 如果没安装curl的话,先安装curl$ sudo apt install curl$ curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 2.修改~/.vimrc文件 123call plug#begin() Plug 'flazz/vim-colorschemes'call plug#end() 3.执行更新 这步要确保安装了git 12:PlugStatus # 查看插件类型:PlugInstall # 安装插件 4.使用插件 删除插件:PlugClean 查询帮助 which: 查找文件： 会在环境变量$PATH设置的目录里查找符合条件的文件 type: 返回命令的类型 whatis: 查看命令功能 查询一个命令执行什么功能,可以查询到man需要的章节号 whereis：查找文件 会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件 只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令 内部命令: help command ，如help type 外部命令: command --help man(manual),帮助手册放在/usr/share/man 123date -d \"yesterday\" +%Fdate -d \"-2 day\" +%Ftouch `date -d \"yesterday\" +%F`.log Linux登陆欢迎提示信息的设置 Linux可以设置登录前后的欢迎信息，虽然没啥技术含量，但却是非常实用的一个小技巧。 实现登录消息的功能，可以修改3个文件。 1、/etc/issue 本地登陆显示的信息，本地登录前 2、/etc/issue.net 网络登陆显示的信息，登录后显示，需要由sshd配置 3、/etc/motd 常用于通告信息，如计划关机时间的警告等，登陆后的提示信息 Linux下如何卸载软件（apt系） 此方法适用于Debian、Ubuntu等带apt工具的操作系统。 首先我们需要知道将要卸载的软件名称，比如我现在打算卸载tightvncserver，但是如果你不确定名称，没关系，可以用Tab键自动补全来确定。 12345$ sudo apt-get autoremove --purge tigh[TAB]# sudo——获取 root 权限 # apt-get——执行安装卸载功能的软件 # autoremove——告诉 apt-get 我们所要做的操作是移除软件 # –purge——注意这前面是两个短划线，这个参数是告诉他们要完整的干净的彻底的移除 1lsblk查看硬盘挂载 恢复rm删除的文件: 注意：查看一下当前系统版本号，及文件系统格式 df -T 12345678910111213# 查看当前硬盘分区$ df .# 使用debugfs$ debugfs -w /dev/mapper/ubuntu--vg-root# 列出当前目录下删除过的文件$ ls -d /home/apollo3d# 找到删除文件前的&lt;&gt;中的数据,即节点号$ logdum -i &lt;num&gt;# 退出debugfs模式$ quit# 进行恢复$ sudo dd if=/dev/mapper/ubuntu--vg-root of=/home/apollo3d/xxx.py bs=2944 count=1 skip=9438337# bs为offset量, skip为block量 apt-get update出现NO_PUBKEY错误的解决方法 在使用apt-get update命令时，出现了如下的错误，形式如“W: GPG error: http://security.ubuntu.com trusty-security Release: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY XXXXX” 1234# 执行更新,查看他缺少什么key $ sudo apt-get update# 复制他提示缺少的key:xxx,输入即可$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key xxxx","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"搭建Gitlab服务器","slug":"搭建Gitlab服务器","date":"2019-03-14T10:32:26.000Z","updated":"2019-12-12T12:29:24.682Z","comments":true,"path":"2019/03/14/搭建Gitlab服务器/","link":"","permalink":"https://nymrli.top/2019/03/14/搭建Gitlab服务器/","excerpt":"","text":"搭建Gitlab服务器 下载安装Gitlab 由于直接下载Gitlab会很慢(被墙的缘故) ， 于是选择清华的镜像安装，清华源 Ubuntu 16.04 用户 Linux其他版本或者不是Ubuntu 16.04 见官网修改方式 首先信任 GitLab 的 GPG 公钥: 1curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null ▲如果这步不行，先进行下一步 文本框中内容写进 /etc/apt/sources.list.d/gitlab-ce.list 1deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu xenial main 安装 gitlab-ce: 12sudo apt-get updatesudo apt-get install gitlab-ce 安装成功后，会显示“狐狸头”。 初次配置服务 1sudo gitlab-ctl reconfigure 启动服务 1sudo gitlab-ctl start 初始化管理员root账号 汉化(用不了–&gt;建议另找) 1.下载社区提供的汉化包，在 https://gitlab.com/xhang/gitlab/ 中找到相应的汉化分支。 1sudo wget wget -cO gitlab-9.0_zh.tar.gz https://gitlab.com/xhang/gitlab/repository/archive.tar.gz?ref=9-0-stable-zh 2.解压包 1sudo tar zxvf gitlab-9.0_zh.tar.gz 3.停止 GitLab 服务 1sudo gitlab-ctl stop 4.备份 gitlab-rails 目录，该目录下主要是web应用部分，也是当前项目仓库的起始版本，也是汉化包要覆盖的目录。 1sudo tar zcvf /opt/gitlab/embedded/service/gitlab-rails-bak.tar.gz gitlab-rails 5.将解压后的汉化补丁覆盖原来的 1sudo cp -rf gitlab-9-0-stable-zh/* gitlab-rails/ 6.启动服务 1sudo gitlab-ctl start 7.重新执行配置命令 1sudo gitlab-ctl reconfigure 注意gitlab的配置文件在/etc/gitlab/gitlab.rb中,我个人操作是要经过一次reconfigure后，gitlab.rb才有内容的。（但/opt/gitlab/etcgitlab.rb.template 中一直有，应该就是因为是模板的原因吧） gitlab修改默认端口 gitlab.rb修改 123456789101112131415161718## Advanced settingsunicorn['listen'] = '127.0.0.1'unicorn['port'] = 8082...################################################################################## GitLab Web server# web_server['shell'] = '/bin/false'# web_server['home'] = '/var/opt/gitlab/nginx'################################################################################## GitLab NGINX##! Docs: https://docs.gitlab.com/omnibus/settings/nginx.html################################################################################nginx['listen_addresses'] = ['*']nginx['listen_port'] = 82 # override only if you use a reverse proxy: https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#setting-the-nginx-listen-port gitlab-rails修改 1234# What ports/sockets to listen on, and what options for them.#listen \"127.0.0.1:8080\", :tcp_nopush =&gt; truelisten \"127.0.0.1:8082\", :tcp_nopush =&gt; truelisten \"/var/opt/gitlab/gitlab-rails/sockets/gitlab.socket\", :backlog =&gt; 1024 gitlab nginx 修改 1234567server &#123; listen *:82; server_name gitlab.123.123.cn; server_tokens off; ## Don&apos;t show the nginx version number, a security best practice&#125; 修改完成后，重启下sudo gitlab-ctl reconfigure,sudo gitlab-ctl restart，就可以放82端口的gitlab了。 附录: 参考链接: https://www.linuxidc.com/Linux/2018-01/150319.htm https://blog.csdn.net/hnmpf/article/details/80518460 (未看，但觉得应该还行) 之前记录的,先放着 配置Gitlab 1.安装 1）查看电脑配置 github对内核有限制 64位,内核3.0 uname -a 、 uname --m 2）安装 https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/ 3） 配置开启GitLab 1sudo gitlab-ctl reconfigure 2.配置 1.查看主机名然后登陆 你第一次访问, 你会被自动导向到密码重置界面，重置完成密码后 会重新返回登陆界面 默认账户的 username 是 root. 提供给你的密码容易创建和登录. 登录后你可以将 username 改成你希望的. 2. 配置服务器及访问路径 123$ vim /etc/gitlab~ external_url = \"http://gitlab.aaa.com\"$ Gitlab-ctl reconfigure 3.配置nginx及DNS域名解析 docker 下 Gitlab搭建 1.配置vim docker-compose.yml 1234567891011121314151617181920212223version:3services: gitlab: image: twang2218/g1tlab-ce-zh:9.4 restart: always hostname:192,16875.129 # environment里才是gitlab的设置,包含nginx和gitlab # gitlab的网页访问是通过nginx的方向代理访问的 environment: TZ: Asia/Shanghei GITLAB_OMNIBUS_CONFIG: | external _url 'http://192 168.75.129:8080' gitlab_rails[' gitlab_shell_ssh_port']=2222 unicorn[' port']=8888 nginx[' listen_port']=8080 ports: # 左边是宿主机的端口, 右边是容器的端口 - '8080:8080' - '8443:443' - '2222:22' volumes: - /usr/local/docker/gitlab/config:/etc/gitlab - /usr/local/docker/gitlab/data:/var/opt/gitlab - /usr/local/docker/gitlab/logs:/var/log/gitlab 配置好后通过http://192 168.75.129:8080进行访问 2.配置root用户初始密码","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"},{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"程序设计周cpp学习笔记","slug":"程序设计周cpp学习笔记","date":"2019-03-07T11:56:14.000Z","updated":"2019-09-15T08:07:31.088Z","comments":true,"path":"2019/03/07/程序设计周cpp学习笔记/","link":"","permalink":"https://nymrli.top/2019/03/07/程序设计周cpp学习笔记/","excerpt":"","text":"文件名传参 123456789101112131415using namespace std;#define FILENAME \"data.csv\"void readfile(string file)&#123; ifstream inFile; inFile.open(file.c_str(), ios::out); // 打开模式可省略 string lineStr; while (getline(inFile, lineStr) ) // 打印整行字符串 cout &lt;&lt; lineStr &lt;&lt; '-'&lt;&lt; endl; &#125; int main()&#123; readfile(FILENAME); return 0; &#125; 输入Q退出 123456789101112131415161718void studentMenu()&#123; string UID; string PWD; int confirmed = false; //判断是否认证成功 do&#123; cout &lt;&lt;\"请输入普通账号ID:\" &lt;&lt;endl; cin &gt;&gt; UID; cout &lt;&lt;\"请输入密码:\" &lt;&lt;endl; cin &gt;&gt; PWD; confirmed = confirmStatus(UID,PWD); if( !confirmed ) cout &lt;&lt; \"账号或密码错误,请尝试.账号ID输入'Q'退出\"; &#125;while( !confirmed &amp;&amp; UID != \"Q\"); if(confirmed) &#123; cout &lt;&lt; \"成功认证\"; //进入学生界面 &#125;&#125; !!! 标准库文件是在.h还是.cpp中include? 现有两个文件Test.h 和Test.cpp#include &lt;iostream&gt;在Test.h中包含 和在Test.cpp中包含有什么区别? 1、在cpp文件中包含.h文件，要么你要用到这个头文件中的函数或者类，要么就是实现这个头文件； 2、.h —就是为了放一堆声明所产生的东西。 如果是定义放在.h中。 如果.h被重复包含多次，那么则会被报重定义。所以在.h 中都要—如果函数就要是inline ,如果是变量就要 selectany (windows)才不会被报错。 3、#include尽量写到cpp文件里。两个文件在.h文件里相互include,就会产生编译错误，而两个文件在.c文件互相include，就不会有该问题，因此在.h文件include就要避免互相包含的问题，而.cpp文件就不需要考虑 4、1）在 .h 里面 include 的好处是：如果很多.c,.cpp文件，都包含一批头文件,如果复制很容易遗漏，如果输入，很容易出错 如果全部在一个.h, include 那么每个.c,.cpp文件只需要一个#include 语句这样不仅输入量减少，而且代码也美观多了代码也主次分明了毕竟，.c.cpp, 里面要实现的函数，才是主要代码 2）主要缺陷， 可能会包含完全不需要的头文件， 增加编译工作量 5、如果你在a.h头文件中include了“stdio.h”，“iostream”，……一大堆 那么你的a.cpp源文件只要include你的a.h，就相当于include了“stdio.h”，“iostream”，……一大堆 但是当其他文件include你的a.h的同时也就包含了“stdio.h”，“iostream”，……一大堆这个要看你个人需要，如果你需要让其他文件也include一大堆，那么写在a.h中就可以，其他文件包含a.cpp简单整洁无脑如果只有a.cpp需要include一大堆，那么还是建议在a.cpp中include一大堆 6、如果a.c包含了头文件a.h，a.h包含了头文件b.h，b.c也包含了b.h，那么当b.h发生改变时，a.c和b.c都会重新编译也就是所有包含了b.h的都会重新编译，无论是直接包含，还是间接包含 7、2点原则： 第一个原则：如果可以不包含头文件，那就不要包含了，这时候前置声明可以解决问题。如果使用的仅仅是一个类的指针，没有使用这个类的具体对象（非指针），也没有访问到类的具体成员，那么前置声明就可以了。因为指针这一数据类型的大小是特定的，编译器可以获知（C++编译器自上而下编译源文件的时候，对每一个数据的定义，总是需要知道定义的数据的类型的大小） 第二个原则：尽量在CPP文件中包含头文件，而非在头文件中。假设类A的一个成员是是一个指向类B的指针，在类A的头文件中使用了类 B的前置声明并编译成功，那么在A的实现中我们需要访问B的具体成员，因此需要包含头文件，那么我们应该在类A的实现部分（CPP文件）包含类B的头文件而非声明部分(H文件) 摘自:https://www.cnblogs.com/fengzhengfly/p/8884581.html C++ 构造函数的使用 1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class CUser&#123; public: string UID; int status; void login(); CUser():UID(\"0\"),status(0)&#123;&#125; CUser(string id,int sts):UID(id),status(sts)&#123;&#125;&#125;;int main()&#123; CUser user(\"hello\",12); cout &lt;&lt; user.UID &lt;&lt; user.status; getchar(); return 0;&#125; string转int 1234567891011atoi(rstatus.c_str()) //atoi(&quot;04&quot;); ===&gt; 4 可以忽略0---使用stringstream:string s = &quot;17&quot;;stringstream ss;ss&lt;&lt;s;int i;ss&gt;&gt;i;cout&lt;&lt;i&lt;&lt;endl; // 17//stringstream可以吞下任何类型，根据实际需要吐出不同的类型 int转string 123456int n = 0;std::stringstream ss;std::string str;ss&lt;&lt;n;ss&gt;&gt;str;//或者cout &lt;&lt; ss.str(); 1itoa(num, str, 10); string转int 12std::string str = &quot;123&quot;;int n = atoi(str.c_str()); int 转string 12345678910这是C++11新增的，使用非常方便，简单查了下：C++11标准增加了全局函数std::to_string，string to_string (int val);string to_string (long val);string to_string (long long val);string to_string (unsigned val);string to_string (unsigned long val);string to_string (unsigned long long val);string to_string (float val);string to_string (double val);string to_string (long double val) 一.string转char * data() c_str() copy(); 1、string转char*。 1234561 string str = &quot;hello&quot;;2 const char* p = str.data();//加const 或者用char * p=(char*)str.data();的形式/* 同时有一点需要说明，这里在devc++中编译需要添加const，否则会报错invalid conversion from const char* to char *，这里可以再前面加上const或者在等号后面给强制转化成char*的类型。 下面解释下该问题，const char*是不能直接赋值到char*的,这样编译都不能通过,理由:假如可以的话,那么通过char*就可以修改const char指向的内容了,这是不允许的。所以char*要另外开辟新的空间，即上面的形式。 */ 2.c_str()方法，如： 121 string str=“world”;2 const char *p = str.c_str();//同上，要加const或者等号右边用char* 3.copy()方法，如： 12341 string str=&quot;hmmm&quot;;2 char p[50];3 str.copy(p, 5, 0);//这里5代表复制几个字符，0代表复制的位置，4 *(p+5)=‘\\0’;//注意手动加结束符！！！ 二、char * 转string。 1231 string s;2 char *p = &quot;hello&quot;;//直接赋值3 s = p; 这里有一点要说明，当声明了string类型变量s后，用printf(&quot;%s&quot;,s);是会出错的，因为“%s”要求后面的对象的首地址。但是string不是这样的一个类型。所以肯定出错。 1234567891011121314151617181920class A&#123;public: void co(); void bo();&#125;;void A::co()&#123; cout &lt;&lt; \"hello\"; A::bo();&#125;void A::bo()&#123; cout &lt;&lt; \"world\";&#125;#include &lt;cstdio&gt;int main()&#123; A a; a.co(); getchar();&#125; 1234567891011121314151617181920int main()&#123; ifstream inFile(&quot;data1.csv&quot;, ios::in); if (inFile.fail())&#123; cout &lt;&lt; &quot;Cannot open file&quot; &lt;&lt; endl; return -1; &#125; vector&lt;string&gt; line; string lineStr; while (getline(inFile, lineStr) )&#123; line.push_back(lineStr); &#125; for(vector&lt;string&gt;::iterator i=line.begin();i!=line.end();i++)&#123; // cout &lt;&lt; strArray.at(i)&lt;&lt;endl; cout &lt;&lt; (*i) &lt;&lt; endl; &#125; getchar(); return 0;&#125; 1234cout &lt;&lt; &quot;请输入书的数量：&quot; &lt;&lt; endl; do&#123; cin &gt;&gt; tmp.TotalNumber;&#125;while( atoi( tmp.TotalNumber.c_str()) == 0 ) ; //非数字情况 操作二维Vector 123456789101112131415string lineStr;vector&lt;vector&lt;string&gt;&gt; strArray;while (getline(inFile, lineStr) )&#123; stringstream ss(lineStr); string str; vector&lt;string&gt; lineArray;while (getline(ss, str, &apos;,&apos;)) lineArray.push_back(str); strArray.push_back(lineArray);for(vector&lt;vector&lt;string&gt;&gt;::iterator i=strArray.begin();i!=strArray.end();i++)&#123; for(vector&lt;string&gt;::iterator j=(*i).begin();j!=(*i).end();j++)&#123; cout &lt;&lt; &quot;*j &quot; ; &#125; cout &lt;&lt; endl; &#125;&#125; 改好的 12345678910111213141516171819202122232425262728293031323334int main()&#123; ifstream inFile(\"data1.csv\", ios::in); vector&lt;vector&lt;string&gt;&gt; lineVec; if (inFile.fail())&#123; cout &lt;&lt; \"Cannot open file\" &lt;&lt; endl; return -1; &#125; string lineStr; vector&lt;vector&lt;string&gt;&gt; vecArray; vector&lt;string&gt; newvec; while (getline(inFile, lineStr) )&#123; stringstream ss(lineStr); string str; vector&lt;string&gt; lineVec; while (getline(ss, str, ',')) lineVec.push_back(str); vecArray.push_back(lineVec); for(vector&lt;vector&lt;string&gt;&gt;::iterator i=vecArray.begin();i!=vecArray.end();i++)&#123; vector&lt;string&gt;::iterator j=(*i).begin(); if( *j != \"100009/1\" ) &#123;newvec.push_back(lineStr); break; &#125; &#125; &#125; for (std::vector&lt;string&gt;::iterator i = newvec.begin(); i != newvec.end(); ++i) cout &lt;&lt; *i &lt;&lt; endl; system(\"pause\"); return 0;&#125; 二维Vector 1234567891011121314151617int main(int argc, char const *argv[])&#123; vector&lt;vector&lt;string&gt;&gt; row; vector&lt;string&gt; col1; vector&lt;string&gt; col2; col1.push_back(&quot;Q&quot;); col1.push_back(&quot;W&quot;); col2.push_back(&quot;A&quot;); col2.push_back(&quot;S&quot;); row.push_back(col1); row.push_back(col2); cout &lt;&lt; row.at(0).at(1); getchar(); return 0;&#125; 查看vector中是否含指定的string 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(int argc, char const *argv[])&#123; std::vector&lt;string&gt; v; v.push_back(&quot;hello&quot;); v.push_back(&quot;1ord&quot;); v.push_back(&quot;asd&quot;); if (std::find(v.begin(), v.end(), &quot;he&quot;) != v.end()) &#123; cout &lt;&lt; &quot;yes&quot;; &#125; getchar(); return 0;&#125; 循环时删除某个元素,不影响循环==&gt;每个元素仍能被遍历 1234567891011121314int main()&#123; vector&lt;string&gt; v; v.push_back(\"1\"); v.push_back(\"2\"); v.push_back(\"3\"); v.push_back(\"4\"); for (int i = 0; i &lt; v.size(); ++i)&#123; if (v.at(i) == \"2\") v.erase(v.begin()+i); &#125; for (int i = 0; i &lt; v.size(); ++i) cout &lt;&lt; v.at(i) &lt;&lt; endl; system(\"pause\"); return 0;&#125; 跳过索引值,只输出id 123456789101112131415161718192021int main(int argc, char const *argv[])&#123; ifstream inFile; inFile.open(&quot;data1.csv&quot;); string lineStr; vector&lt;vector&lt;string&gt; &gt; row; vector&lt;string&gt; newvec; while (getline(inFile, lineStr) )&#123; stringstream ss(lineStr); string str; vector&lt;string&gt; col; while (getline(ss, str, &apos;,&apos;)) col.push_back(str); row.push_back(col); &#125; for (int i = 1; i &lt; row.size(); ++i) cout &lt;&lt; row.at(i).at(0) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 避免错误输入 1while(getchar()!=&apos;\\n&apos;) ; 分割时间 12345678910111213141516171819202122232425void CData(string &amp;timestr)&#123; stringstream ss(timestr); int year; int mon; int day; string str; getline(ss, str, &apos;/&apos;); year = atoi(str.c_str()); getline(ss, str, &apos;/&apos;); mon = atoi(str.c_str()); getline(ss, str, &apos;/&apos;); day = atoi(str.c_str()); cout &lt;&lt; year &lt;&lt; &quot;,&quot; &lt;&lt; mon &lt;&lt; &quot;,&quot; &lt;&lt; day &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123; // string a =&quot;2017/04/02&quot;; // CData(a); stringstream ss; ss &lt;&lt; 1 &lt;&lt; &quot;/&quot; &lt;&lt; 2 &lt;&lt; &quot;/&quot; &lt;&lt; 3; cout &lt;&lt; ss.str(); getchar(); return 0;&#125; 12stringstream ss;ss &lt;&lt; 1 &lt;&lt; &quot;/&quot; &lt;&lt; 2 &lt;&lt; &quot;/&quot; &lt;&lt; 3; vector最大值 1int maxn = *max_element(v.begin(),v.end()); 找到最大ID 123456789101112vector&lt;string&gt; idcol;string lineStr; while (getline(infile, lineStr) )&#123; //获取行 stringstream ss(lineStr); string bookid; //记录列数据,必须写在这个循环里 getline(ss, bookid, &apos;,&apos;); idcol.push_back(bookid);&#125; int addid = vecMAX(idcol)+1; stringstream inttostring; inttostring &lt;&lt; addid; tmp.BookID = inttostring.str(); 二维VEC排序 12345678910111213141516171819int main()&#123; std::vector&lt;std::vector&lt;int&gt; &gt; s; vector&lt;int&gt; v1; vector&lt;int&gt; v2; v1.push_back(5); v1.push_back(13); s.push_back(v1); v2.push_back(7); v2.push_back(4); s.push_back(v2); sort(s.begin(), s.end()); for (int i = 0; i &lt; s.size(); ++i)&#123; for (int j = 0; j &lt; v1.size(); ++j) cout &lt;&lt; s.at(i).at(j); cout &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 123out.open(USERTMPFILE) 可以打开宏定义ios::in + ios::out 从开头加ios::app 从结尾加 获得值最大的键 12345678910111213141516bool cmp(const pair&lt;string, int&gt;&amp; lhs, const pair&lt;string, int&gt;&amp; rhs) &#123; return lhs.second &gt; rhs.second; &#125; int main(int argc, char const *argv[])&#123; map&lt;string,int&gt; a ; a.insert(pair&lt;string, int&gt;(&quot;ssd&quot;, 3)); a[&quot;hello&quot;]=3; a[&quot;world&quot;]=9; a[&quot;cl&quot;]=6; std::vector&lt; pair&lt;string, int&gt; &gt; v(a.begin(), a.end()); sort(v.begin(), v.end(),cmp); cout &lt;&lt; &quot;max&quot; &lt;&lt; v.at(0).first &lt;&lt; endl; getchar(); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"程序设计","slug":"程序设计","permalink":"https://nymrli.top/tags/程序设计/"}]},{"title":"ACM-DFS、BFS","slug":"ACM-DFS、BFS","date":"2019-03-07T11:55:03.000Z","updated":"2020-11-05T13:01:51.466Z","comments":true,"path":"2019/03/07/ACM-DFS、BFS/","link":"","permalink":"https://nymrli.top/2019/03/07/ACM-DFS、BFS/","excerpt":"","text":"深度优先搜索(DFS) 从某个状态,不断转移状态直到无法转移,然后回退到前一步的状态,继续转移到其他状态,如此不断重复,直到找到最终解. ====&gt; 递归函数 隐式的用到了栈(stack) 123456789101112131415161718192021222324252627//[部分和问题]#include &lt;iostream&gt;#define MAXN 10000int n,k;int s[MAXN];using namespace std;bool dfs(int i,int sum)&#123; if( i == n ) return sum == k;//如果前n项计算过了，返回sum=k是否相等 if ( dfs(i+1 , sum) ) return true; //不加上s[i]的情况； if ( dfs(i+1, sum + s[i] )) return true; //加上s[i]的情况 return false; //无论加不加上s[i]&#125;void input()&#123; cin &gt;&gt; n; for(int i=0;i&lt;n;i++) cin &gt;&gt; s[i]; cin &gt;&gt; k;&#125;int main()&#123; input(); if (dfs(0,0)) cout &lt;&lt; \"YES\"; else cout &lt;&lt;\"NO\"; return 0;&#125; laking countiing 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//[laking countiing]#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 10000using namespace std;int N,M;char field[MAXN][MAXN]=&#123;&#123;\"W........WW.\"&#125;,&#123;\".WWW.....WWW\"&#125;,&#123;\"....WW...WW.\"&#125;,&#123;\".........WW.\"&#125;,&#123;\".........W..\"&#125;,&#123;\"..W.......W.\"&#125;,&#123;\".W.W.....WW.\"&#125;,&#123;\"W.W.W.....W.\"&#125;,&#123;\".W.W......W.\"&#125;,&#123;\"..W.......W.\"&#125;&#125;;void dfs(int x,int y)&#123; field[x][y] = '.'; //循环遍历移动的8个方向,检测八连通位置 for(int dx=-1;dx&lt;=1;dx++) for(int dy=-1;dy&lt;=1;dy++)&#123; int nx=x+dx; //移动后的结果为(nx,ny) int ny=y+dy; if( (0 &lt;= nx &amp;&amp; nx&lt; N) &amp;&amp; (0 &lt;= ny &amp;&amp; ny &lt; M) &amp;&amp; field[nx][ny]=='W') dfs(nx,ny); //此处为做题的关键 : 不断 &#125; return ;&#125;void solve()&#123; int res = 0; //水坑数量 for(int i=0;i&lt;N;i++) for(int j=0;j&lt;M;j++)&#123; if(field[i][j] == 'W')&#123; dfs(i,j); res++; &#125; &#125; printf(\"%d\\n\",res);&#125;void printLake()&#123; N=10;M=12; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++) cout &lt;&lt; field[i][j] ; cout &lt;&lt; endl; &#125;&#125;int main()&#123; N=10; M=12; solve(); return 0;&#125; 宽度优先搜索(BFS) 总是优先搜索距离初始状态最近的状态,复杂度 = O(状态书 * 转移的方式) 显式利用队列(queue),搜索时首先将初始状态添加到队列里,此后从队列的最前端不断取出状态,吧从该状态可以转移到的状态中尚未访问过的部分加入队列,如此往返,直至队列被取空或是找到了问题的解 广度优先搜索思想 设图G的初态是所有顶点均未访问，在G 中任选一顶点i作为初始点，则广度优先搜索的基本思想是： （1）从图中的某个顶点V出发，访问之；并将其访问标志置为已被访问，即visited[i]=1； （2）依次访问顶点V的各个未被访问过的邻接 点，将V的全部邻接点都访问到； （3）分别从这些邻接点出发，依次访问它们的未被访问过的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接 点”被访问，直到图中所有已被访问过的顶点的邻接点都被访问到。依此类推，直到图中所有顶点都被访问完为止 。 广度优先搜索在搜索访问一层时，需要记住已被访问的顶点，以便在访问下层顶点时，从已被访问的顶点出发搜索访问其邻接点。所以在广度优先搜索中需要设置一个队列Queue，使已被访问的顶点顺序由队尾进入队列。在搜索访问下层顶点时，先从队首取出一个已被访问的上层顶点，再从该顶点出发搜索访问它的各个邻接点。 1234567891011W........WW..WWW.....WWW....WW...WW..........WW..........W...........WW...W.......W..W.W.....WW.W.W.W.....W..W.W......W...W.......W. 1234567891011&#123;W........WW.&#125;&#123;.WWW.....WWW&#125;&#123;....WW...WW.&#125;&#123;.........WW.&#125;&#123;.........W..&#125;&#123;.........WW.&#125;&#123;..W.......W.&#125;&#123;.W.W.....WW.&#125;&#123;W.W.W.....W.&#125;&#123;.W.W......W.&#125;&#123;..W.......W.&#125; 2019蓝桥杯省赛–maze 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#include &lt;string&gt;#include &lt;queue&gt;/*010010001000000101110000访问次数:9访问次序:DRDRDRRR*/using namespace std;typedef pair&lt;int ,int&gt; State;const int maxn = 1000;const int row = 4;const int col = 6;//const int INF = 10000000;char maze[row+1][col+1];int visited[row+1][col+1]; //是否访问过，记录次数string trace[row+1][col+1]; //记录每次移动的方向int X[] = &#123;-1,0,1,0&#125;; // 这边可能定义错了，这个对应的是行int Y[] = &#123;0,1,0,-1&#125;; // 这个对应的是列，而不是X,Ystring sarr[] = &#123;\"U\",\"R\",\"D\",\"L\"&#125;;int x=1;int y=1;void bfs()&#123; queue&lt;State&gt; q; // 起点 q.push(State(x,y)); while( !q.empty() )&#123; // 取状态 State s = q.front(); q.pop(); if( x == row &amp;&amp; y == col ) break; // 到达终点 // 一个数组记录四个方向 for( int i = 0 ; i &lt; 4; i++)&#123; int nx = s.first + X[i]; int ny = s.second + Y[i]; if( nx &gt;= 1 &amp;&amp; nx &lt;= row &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= col &amp;&amp; maze[nx][ny] != '1'&amp;&amp; visited[nx][ny] == 0 ) &#123; //cout &lt;&lt; nx &lt;&lt; ny &lt;&lt; endl; visited[nx][ny] = 1; //cout &lt;&lt; maze[nx][ny] &lt;&lt; sarr[i] &lt;&lt; endl; //cout &lt;&lt; endl; visited[nx][ny] = visited[s.first][s.second] +1; trace[nx][ny] = trace[s.first][s.second] + sarr[i]; q.push(State(nx,ny)); &#125; &#125; &#125; cout &lt;&lt;\"times:\"&lt;&lt; visited[row][col] &lt;&lt;endl; cout &lt;&lt;\"order:\"&lt;&lt; trace[row][col] &lt;&lt;endl;&#125;int main()&#123; // 初始化 for(int i=1 ; i &lt;= row ; i++) for(int j= 1; j &lt;= col ; j++) visited[i][j] = 0; // 起点为(1,1) visited[1][1] = 1; //处理输入 for(int i=1 ; i &lt;= row ; i++)&#123; for(int j= 1; j &lt;= col ; j++) scanf(\"%c\",&amp;maze[i][j]); getchar(); &#125; bfs(); return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"ACM-快速幂","slug":"ACM-快速幂","date":"2019-03-07T11:54:05.000Z","updated":"2019-09-15T08:07:30.915Z","comments":true,"path":"2019/03/07/ACM-快速幂/","link":"","permalink":"https://nymrli.top/2019/03/07/ACM-快速幂/","excerpt":"","text":"简单位运算快速幂 假设我们要求ab，那么其实b是可以拆成二进制的，该二进制数第i位的权为2(i-1)，例如当b==11时，a11=a(20+21+2^3) 123456789int poww(int a,int b)&#123; int ans=1,base=a; while(b!)&#123; if(b&amp;1) ans*=base; base*=base; b&gt;&gt;=1; &#125; return ans;&#125; 11的二进制是``1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算a^(2^0)*a^(2^1)*a^(2^3) 其中比较重要的一步:base*=base,即基底不断增加,如果二进制是1则*上基底否则不,ans为所有基底相乘 1234567base*base==base^2下一步再乘，就是base^2*base^2==base^4然后同理 base^4 * base4 = base^8 see?是不是做到了base--&gt;base^2--&gt;base^4--&gt;base^8--&gt;base^16--&gt;base^32.......指数正是 2^i ，再看上面的例子，a¹¹ = a^(2^0) * a^(2^1) * a^(2^3)，这三项是不是完美解决了，，嗯，快速幂就是这样。 ▲.由于指数函数是爆炸增长的函数，所以很有可能会爆掉int的范围，根据题意决定是用 long long啊还是unsigned int啊还是mod某个数啊自己看着办。 12345678910typedef long long ll;ll mod_pow(ll base,ll n,ll mod)&#123; ll res=1; while(n&gt;0)&#123; if( n &amp; 1 ) res = res*base%mod; base = base*base%mod; n&gt;&gt;= 1; &#125; return res;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"南京邮电大学java程序设计作业在线编程第三次作业","slug":"南京邮电大学java程序设计作业在线编程第三次作业","date":"2019-03-07T11:12:47.000Z","updated":"2019-09-15T08:07:31.033Z","comments":true,"path":"2019/03/07/南京邮电大学java程序设计作业在线编程第三次作业/","link":"","permalink":"https://nymrli.top/2019/03/07/南京邮电大学java程序设计作业在线编程第三次作业/","excerpt":"","text":"选择题得分：60 \\1. 设有如下定义语句： String s1=”My cat”; int m=s1.compareTo(“My a cat”); 语句被执行后m的值为（ ） A.2 B.1 C.0 D.-2 正确答案是: A \\2. 语句 String s1=new String(“Hello”); String s2=new String(“Hello”); System.out.println(s1==s2); System.out.printlv(s1.equals(s2)); 执行后的输出结果是（ ） A.Hello false B.Hello true C.Hello Hello D.false true 正确答案是: D \\3. 执行下列语句 int[] lx={2,3,4,5}; lx[3]=lx[3]==–lx[0]?++lx[1]:lx[2]–; 后，数组lx的元素值分别为（ ） A.1,2,3,4 B.1,3,3,3 C.1,2,3,3 D.1,3,3,4 正确答案是: D \\4. 在一个应用程序中定义了数组a：int[] a={1,2,3,4,5,6,7,8,9,10}，为了打印输出数组a的最后一个数组元素，下面正确的代码是（ ） A.System.out.println(a[10]); B.System.out.println(a[9]); C.System.out.println(a[8]); D.System.out.println(a[a.length]); 正确答案是: B \\5. 设有定义语句int a[]={36,72,99};则以下对此语句叙述错误的是（ ） A.该语句定义了一个名为a的一维数组； B.a数组有3个元素； C.数组中的每个元素是整型； D.a数组的元素的下标为1~3； 正确答案是: D \\6. 下面关于数组定义语句不正确的是（ ） A.float f[]=new{2.4f,3.5f,5.7f,7.9f}; B.int a[]={1,2,3,4,5} C.double[]d=new double[10]; D.int[]a2; 正确答案是: A \\7. 下列语句序列执行后，c的值是（ ） int a=3,b=4,c=0; while ((a++)&lt;(–b))++c; A.0 B.1 C.2 D.3 正确答案是: A \\8. 下列语句序列执行后，a的值是（ ） int a=1; for(int i=5;i&gt;0;i-=2) a*=i; A.0 B.1 C.15 D.60 正确答案是: C \\9. 下列语句序列执行后，c的值是（ ） int a=10,b=18,c=30; switch(b-a){ case 8 : c++; case 9 : c+=2; case 10 : c+=3; default :c/=b; } A.31 B.32 C.2 D.33 正确答案是: C \\10. 设a、b为int型变量，c、d为fload类型变量，ch为char类型变量，且所有变量均已赋值，则下列正确的switch语句是（ ） A.switch(a+b);{…} B.switch(ch+1){…} C.switch ch {…} D.switch(c+d){…} 正确答案是: B \\11. 下列语句序列执行后，c的值是（ ） int a=4,b=5,c=9,d=6; if (a&gt;b||c&lt;d) c–; else c++; A.6 B.10 C.8 D.9 正确答案是: B \\12. 下列语句序列执行后，c的值是（ ） int a=6,b=3,c=5; if (a==b) c+=a;else c=++a*c; A.15 B.25 C.35 D.45 正确答案是: C \\13. 下列语句序列执行后，c变量的值为（ ） int a=2,b=4,c=5; if (a&lt;–b) c*=a; A.5 B.20 C.15 D.10 正确答案是: D \\14. 下列语句序列执行后，ch1变量中的值为（ ） char ch1=’A’,ch2=’B’; if (ch1+2&lt;ch2)++ch1; A.‘A’ B.‘B’ C.A D.B 正确答案是: A \\15. 以下选项中，合法的赋值语句是（ ） A.++m!=n–; B.++m; C.m=m+1=5; D.m==1; 正确答案是: B \\16. 设有定义“int a=22;long b=56;”，下面赋值不正确的语句是（ ） A.a=b; B.b=(long)a; C.a=(int)b; D.b=a; 正确答案是: A \\17. 下面选项中，（ ）是正确的输出结果 int m=2,n=1; m+=m-=n; System.out.println(“m=”+m); A.m=1 B.m=2 C.m=3 D.m=4 正确答案是: C \\18. 下列语句序列执行后的结果为（ ） int a=10,b=4,c=20,d=6; System.out.println(a++b+c–d); A.144 B.140 C.28 D.不能执行 正确答案是: B \\19. 假设以下选项中的变量都已经正确定义，则不合法的表达式是（ ） A.a&gt;4==6&lt;1; B.’n’-3; C.’a’=8; D.’A’%6 正确答案是: C \\20. 假设a为已经声明并以赋初值的int类型变量，则对于a的赋值语句正确的是（ ） A.int a=6; B.a==3; C.a=3.2f; D.a+=a*3; 正确答案是: D 编程题得分：40 1.打印每月有几天 得分：10 / 10 1234567891011121314151617181920212223242526272829import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123; public static boolean isYeap(int year) &#123; if ( year%4==0 &amp;&amp; year%100 != 0 ) return true; if (year%400 == 0) return true; return false; &#125; public static void main(String []args) &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); int b = s.nextInt(); int yeap[] = &#123;31,29,31,30,31,30,31,31,30,31,30,31&#125;; int noyeap[] = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; if ( isYeap(a) ) System.out.println(\"\"+a+\"-\"+b+\"-\"+yeap[b-1]+\"\"); else System.out.println(\"\"+a+\"-\"+b+\"-\"+noyeap[b-1]+\"\"); &#125;&#125; 4-3-2 百分制成绩转换等级制成绩 得分：10 / 10 1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123;public static void main(String []args) &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); if ( a&lt;0 || a &gt; 100) System.out.printf(\"Error input\\n\"); else &#123; int REa = a/10; switch (REa) &#123; case 6: System.out.printf(\"%d -- %c\\n\",a,'D'); break; case 7: System.out.printf(\"%d -- %c\\n\",a,'C'); break; case 8: System.out.printf(\"%d -- %c\\n\",a,'B'); break; case 9: case 10: System.out.printf(\"%d -- %c\\n\",a,'A'); break; default: System.out.printf(\"%d -- %c\\n\",a,'E'); &#125; &#125; &#125; &#125; 用if语句求解分段函数 得分：10 / 10 1234567891011121314151617181920import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123;public static void main(String []args) &#123; Scanner s = new Scanner(System.in); double a = s.nextDouble(); double b=0; if (a&lt;20) b=a+100; else if ( a&gt;100 ) b=a-100; else b=a; System.out.printf(\"x=%.2f,y=%.2f\\n\",a,b); &#125; &#125; 2-2 混合类型数据格式化输入 得分：10 / 10 12345678910111213141516171819import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123;public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); double d1 = s.nextDouble(); int i = s.nextInt(); String ss = s.next(); char ch = ss.charAt( 0 ); double d2 = s.nextDouble(); System.out.printf(\"%c %d %.2f %.2f\",ch,i,d1,d2); &#125; &#125; 3-4-1a 计算三位数的位数和 得分：10 / 10 12345678910111213141516171819202122import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123;public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int n = s.nextInt(); int sum = 0; if ( n &lt; 0) n = -n; // 保证绝对值 while(n!=0) &#123; int left = n%10; sum += left; n/= 10; &#125; System.out.printf(\"%d\\n\",sum); &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Linux下开机启动Python脚本","slug":"Linux下开机启动Python脚本","date":"2019-03-03T11:48:46.000Z","updated":"2021-10-22T07:04:58.682Z","comments":true,"path":"2019/03/03/Linux下开机启动Python脚本/","link":"","permalink":"https://nymrli.top/2019/03/03/Linux下开机启动Python脚本/","excerpt":"","text":"/etc/rc.local 将脚本写在/etc/rc.local文件 输入命令：sudo vi /etc/rc.local 在exit 0上一行输入：python /usr/bin/python /home/pi/test.py 重启就可以看效果sudo reboot 当然，rc.local 文件需要有执行权限（默认没有） $ sudo chmod +x /etc/rc.local 对于命令，最好是先which python查出命令路径，写命令时写绝对路径 /etc/init.d 写一个服务放到linux的/etc/init.d目录中 并且授权bash脚本chmod 755 /etc/init.d/mypython 1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin/bash# chkconfig: 2345 66 36# /etc/rc.d/init.d/opt/python# description: spython#case \"$1\" in start) echo -n \"Starting python: \" echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python date +\"! %T %a %D : Starting python .\" &gt;&gt;/var/log/python echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python echo start cd /root/finmonAgent/bin ./finmonAgent.py &amp; #sh /root/finmonAgent/startpy echo \"Done.\" echo \"\" echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python date +\"! %T %a %D : Finished.\" &gt;&gt;/var/log/python echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python touch /var/lock/subsys/python ;; stop) echo -n \"Shutting Down python Listeners: \" echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python date +\"! %T %a %D : Shutting Down python.\" &gt;&gt;/var/log/python echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python echo \"python\" killall -9 finmonAgent.py echo \"Done.\" rm -f /var/lock/subsys/python echo \"Done.\" echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python date +\"! %T %a %D : Finished.\" &gt;&gt;/var/log/python echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python ;; *) echo \"Usage: python &#123; start | stop | restart &#125;\" exit 1esacexit 0 /ect/profile /ect/profile 文件是系统默认的主启动文件，系统上每个用户登录时都会执行； linux 配置文件（启动文件、环境文件）启动顺序 1、登录shell 登录shell时，linux会按一定规则读取启动几个配置文件： /ect/profile $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile 其中 /ect/profile 文件是系统默认的主启动文件，系统上每个用户登录时都会执行； a、命令行登录和ssh登录，shell会按照以下顺序，运行第一个被找到的文件，余下的会被忽略： $HOME/.bash_profile $HOME/.bash_login $HOME/.profile 上面没有 $HOME/.bashrc ，因为该文件一般通过其他文件运行。 b、图形界面登录，只加载 /ect/profile和$HOME/.profile，其他的会被忽略。 对于 no-login shell，即图形界面打开的shell，只会读入 $HOME/.bashrc 文件，不会检查 /etc/.profile 等其他登录shell文件。 2、交互式shell 不是登录系统时启动，提供命令行提示符来输入命令。（不会访问 /etc/profile 文件，会检查 $HOME/.bashrc 文件） 3、非交互式shell 系统执行脚本时所用，没有命令行提示符。 1. linux将指令加入环境变量 在profile中添加PATH，这种方法对所有用户都是永久生效。 打开profile文件 1vim /etc/profile 在profile文件的PATH中添加mongo指令。在PATH后面添加“:/usr/local/webserver/mongo/bin”，＝ 等号两边不能有任何空格。 1PATH=``$PATH``:/usr/local/webserver/mongo/bin 执行指令，使profile修改立即生效。 1source profile 在当前profile中添加PATH，这种方法对当前用户永久生效。与第二步类似，将profile替换为bash_profile。 1$ vim ~/.bash_profile 1PATH=``$PATH``:/usr/local/webserver/mongo/bin 1$ source ~/.bash_profile 2. linux将指令加入开机启动 在/etc/rc.local中添加指令即可，在开机执行顺序中/etc/rc.local优先于/etc/profile，rc.local开机就会运行，/etc/profile被称为登录脚本，内含许多的全局变量，为用户登录所使用 1/usr/local/webserver/mongodb/bin/mongod --dbpath=/data0/mongodb/data --logpath=/data0/mongodb/logs --logappend --port=27017","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"codeblocks中boost库安装","slug":"codeblocks中boost库安装","date":"2019-03-03T11:04:59.000Z","updated":"2019-09-15T08:07:30.928Z","comments":true,"path":"2019/03/03/codeblocks中boost库安装/","link":"","permalink":"https://nymrli.top/2019/03/03/codeblocks中boost库安装/","excerpt":"","text":"首先要提出的是，boost在VS中是可以直接导入的，但是在CB中是不行的，所以写了下这篇文章。 安装boost 1.首先先去boost官网下载boost的源码 ， 选择你要下载的版本。 2.解压（可能会耗费一段时间，小文件比较多） 3.双击运行脚本文件bootstrap.bat（引导程序），之后就生成这两个可执行文件 我们为了能直观的看到编译boost的细节信息，进入dos (win +ｒ快捷键 输入cmd ) 4.cd 到解压boost库的目录下 5.命令执行bjam.exe 4-5是没必要的，要是不想看输出的东西的话，其实双击bjam.exe即可 ▲.编译的时间略久（你可以干一会其他事，喝个茶） 注: 安装boost貌似需要VS的某个模块，一开始在活动室电脑上装由于没有VS，所以没装成，最后在自己的电脑上装好的。 codeblocks设置 点击settings，选择下拉菜单中的 compiler选项 注意这里选择Search directories第三项 最下面有一个add按钮，点击将boost解压路径添加即可。 之后你可以随便写一点程序进行测试 12345678910#include &lt;boost/lambda/lambda.hpp&gt;#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;int main()&#123; using namespace boost::lambda; typedef std::istream_iterator&lt;int&gt; in; std::for_each( in(std::cin), in(), std::cout &lt;&lt; (_1 * 3) &lt;&lt; \" \" );&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"ACM_线性筛","slug":"ACM-线性筛","date":"2019-03-03T08:57:36.000Z","updated":"2019-10-29T12:31:18.223Z","comments":true,"path":"2019/03/03/ACM-线性筛/","link":"","permalink":"https://nymrli.top/2019/03/03/ACM-线性筛/","excerpt":"","text":"什么是线性筛? 筛素数是为了求得一个区间内的所有素数，而把不是素数的筛去。 最普通的办法——判断一个数是不是素数 123456789101112131415161718#define SIZE 1000000int main()&#123; int check[SIZE]; int prime[SIZE] = &#123;0&#125;; int pos; int flag; for (int i = 2 ; i &lt; SIZE ; i++)&#123; flag = 1; for (int j = 2 ; j &lt; sqrt(i) ; j++)&#123; if (i % j == 0) flag = 0; &#125; if (flag == 1) prime[pos++] = i; &#125; printf(\"%.2f\", (double)clock()/CLOCKS_PER_SEC); return 0;&#125; 普通筛素数——将不是素数的筛掉 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;#define SIZE 1000int main()&#123; int checked[SIZE] = &#123;0&#125;; // 如果是1的话就是合数 int prime[SIZE] = &#123;0&#125;; int pos = 0; int i,j; for( i = 2;i &lt; SIZE ; i++)&#123; if ( ! checked[i] )&#123; prime[pos++] = i; &#125; for( j = 2*i; j &lt; SIZE ; j += i ) checked[j] = 1; &#125; for( i = 0;i&lt; SIZE ; i++) if (prime[i] == 0)&#123; cout &lt;&lt; i-1 &lt;&lt; endl; // 素数的个数 break; &#125; return 0;&#125;// output : 168 普通筛素数 基本思想 一次循环筛掉当前素数的倍数 缺点 存在重复筛选，比如6既可以被2筛掉，又可以被3筛掉。 原因：任意一个整数可以写成一些素数的乘积 n=p1a∗p2b∗p3cn=p_{1}^{a} * p_{2}^{b} * p_{3}^{c}n=p1a​∗p2b​∗p3c​，其中p1&lt;p2&lt;p3p1&lt;p2&lt;p3p1&lt;p2&lt;p3，这样这个数n就能被p1,p2和p3筛掉 解决方法：按照一个数的最小素因子筛去(也就是这里的p1)就可以啦，这也就有了线性筛素数 线性筛素数 1234567891011121314151617181920212223242526272829303132#define SIZE 1000int main()&#123; int check[SIZE] = &#123;0&#125;;//元素值为0代表是素数 int prime[SIZE] = &#123;0&#125;; int pos=0; for (int i = 2 ; i &lt; SIZE ; i++)&#123; if (!check[i])//如果是素数 prime[pos++] = i; // ★.区别在于此 for (int j = 0 ; j &lt; pos &amp;&amp; i*prime[j] &lt; SIZE ; j++)&#123;/* cl觉得可以写成for (int j = 0 ; i*prime[j] &lt; SIZE ; j++)j &lt; pos 是多余的,如果i是个素数,比如7,那么prime[x]=7,当j=x的时候必然有if (i % prime[j] == 0), 此时x=pos - 1如果是个合数,比如15,那么肯定有最小素因子使得(i % prime[j] == 0),此时j &lt; pos 如果i是个偶数,比如8,那么if (i % prime[j] == 0) 此时在2的时候就退出了。j=0 &lt; pos2019-4-26 j&lt;pos不能删,这个是主要控制j取值的大小的因素,控制取出的都是已知的素数*/ check[i*prime[j]] = 1;//筛掉 //标注一 // 通过这步可以找到最小素数因子, // 比如12,那么 prime[j] 最先== prime[0] == 2 , 即找到了最小的因子2, // 那12就不是个素数,就不用再判断它是不是能被3合成 if (i % prime[j] == 0) break; &#125; &#125; printf(\"%.2f\", (double)clock()/CLOCKS_PER_SEC); return 0;&#125; 基本思想 当前数字是n=p1a∗p2b∗p3cn=p_{1}^{a} * p_{2}^{b} * p_{3}^{c}n=p1a​∗p2b​∗p3c​(p1&lt;p2&lt;p3且均为素数)，一次循环筛除小于等于p1的素数乘以n得到的数。比如p1之前有pi,pj和pk三个素数，则此次循环筛掉pi*n,pj*n,pk*n和p1*n ，实现见代码的标注一，prime 里的素数都是升序排列的，break时的prime[j] 就是这里的p1。 优点：没有重复筛同一个数 原因：按照一个数的最小素因子筛选，比如6只按2筛去 从图上我们看到，第一列筛掉的是最小素因子是2的数，第二列筛掉的是最小素因子为3的数，第三列最小素因子是prime[2]==5 ，依次类推，可以把所有的合数都筛掉。 由于每列筛掉的合数都是 它自身的平方 ， 即 一个素数最小的因子除了1就是它本身， 所以 素数的平方的最小素因子就是 它本身 ， 而通过i % prime[j] == 0就可以控制不多筛。 因为是按照最小素因子筛选，所以可以保证每个数都只会被筛一遍 ==&gt; 18--9x2 摘自：这只菜鸟总算搞懂了线性筛素数 素数的判别挺有意思的，剪枝的方法可以见我的另一篇博客 : 素数判别","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"线性筛","slug":"线性筛","permalink":"https://nymrli.top/tags/线性筛/"}]},{"title":"flask+nginx如何获得真实IP","slug":"flask-nginx如何获得真实IP","date":"2019-03-02T12:53:58.000Z","updated":"2019-09-15T08:07:30.933Z","comments":true,"path":"2019/03/02/flask-nginx如何获得真实IP/","link":"","permalink":"https://nymrli.top/2019/03/02/flask-nginx如何获得真实IP/","excerpt":"","text":"如果是通过 flask 的 request.remote_addr获取的 ip 都是 127.0.0.1 解决方案: nginx.conf中添加 123# proxy_set_header Host $host:80; # proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 全文 12345678910111213141516server &#123; listen 8888; server_name 0.0.0.0; charset utf-8; client_max_body_size 75M; location /static&#123; alias /home/apollo3d/Documents/Cl/webenv/.../static; &#125;location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8889; uwsgi_param UWSGI_SCRIPT app:app; # 启动flask的文件:Flask的实例 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; Python代码 1234if request.headers.getlist(&quot;X-Forwarded-For&quot;): ip = request.headers.getlist(&quot;X-Forwarded-For&quot;)[0]else: ip = request.remote_addr 查自:V2EX 拓展: X-Forwarded-For 可能会有多个 IP ，如果浏览器使用了代理的话 正确的做法应该是抓 X-Real-IP，或者分隔 X-Forwarded-For取第 1 个值","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"nginx","slug":"nginx","permalink":"https://nymrli.top/tags/nginx/"}]},{"title":"frp结合nginx实现内网web服务和tcp的转发","slug":"frp结合nginx实现内网web服务和tcp的转发","date":"2019-03-02T10:48:23.000Z","updated":"2021-03-20T06:25:18.849Z","comments":true,"path":"2019/03/02/frp结合nginx实现内网web服务和tcp的转发/","link":"","permalink":"https://nymrli.top/2019/03/02/frp结合nginx实现内网web服务和tcp的转发/","excerpt":"","text":"服务端 - 阿里云服务器: Ubuntu 16.04 客户端 - 活动室电脑 : Ubuntu 16.04 配置server端 1$ sudo vim frps.ini 1234[common] #必须有的配置段，在frpc.ini和frps.ini中都必须要有bind_port = 7000 #服务端服务的监听端口vhost_http_port = 16666 #自己设定的http访问端口vhost_https_port = 17777 #自己设定的https访问端口 保存并且退出，使用如下服务命令启动frps服务 1$ nohup ./frps -c ./frps.ini &amp; client端: 1$ sudo vim frpc.ini 1234567891011121314[common] #必须有的配置段，在frpc.ini和frps.ini中都必须要有server_addr = x.x.x.x #服务端的公网IP（外网IP）server_port = 7000 #服务端服务的监听端口[web] #自己定义的服务转发标签（自定义，非严格）type = http #定义转发类型为http（严格）local_port = 8800 #定义所需要转发的本地web服务的端口为8800,跟nginx设置的一致custom_domains = node1.xxx.com #定义访问转发服务的域名（确保使用该域名访问可以解析到有公网IP的服务端）[ssh] #自己定义的服务转发标签（自定义，严格）type = tcp #定义转发类型为tcp（严格）local_ip = 127.0.0.1 #由于转发代理的ssh服务在本地，因此填写本地地址local_port = 22 #ssh服务本地的监听端口remote_port = 6000 #实际开启ssh时连接时访问的端口 1$ nohup ./frpc -c ./frpc.ini &amp; 解释说明 123456789#server[common] #必须有的配置段，在frpc.ini和frps.ini中都必须要有bind_port = 7000 #服务端服务的监听端口vhost_http_port = 16666 #自己设定的http访问端口# client[web] #自己定义的服务转发标签（自定义，非严格）type = http #定义转发类型为http（严格）local_port = 8800 #定义所需要转发的本地web服务的端口为8800,跟nginx设置的一致 △.将16666端口的http请求转发到内网设备的8800端口应用上，真正做处理的其实是内网中的8800端口的web应用 1234[common]中的server_addr填frp服务端的ip（也就是外网主机的IP），server_port填frp服务端的bind_prot(s和c必须一致)。[web]中，type转发类型为http，local_port填转发的web端口，custom_domains 填 能够使用的域名.说到这里，域名解析，服务端建议使用阿里云，直接填写A记录，三级子域名专门申请几个，备用.类似：node1.xxx.com、node2.xxx.com、node3.xxx.com 阿里云设置A记录: 一开始以为一个IP不能写多个A记录，后来发现是可以的。如下 这里还要注意几点： 1234[web]上下文中，凡是type类型为http或者同一个类型，custom_domains中填写的域名必须为不同的域名，相同域名会报错不同类型的type，例如[test]中的type类型为tcp，则可以使用相同域名简单来说type类型相同，不能使用同一个域名type类型不同，可以使用相同的域名。 测试和访问 web服务访问格式为：域名+端口,具体如下: 123http://node1.xxx.com:16666 页面转到内网客户端使用nginx反向代理的web服务8800http://node2.xxx.com:16666 页面转到内网客户端使用nginx反向代理的web服务8801http://node3.xxx.com:16666 页面转到内网客户端本地的web服务端口8088 ▲当然要记得去阿里云的防火墙将16666端口打开才行， 然后我测试了一下，通过IP访问好像是不行的，域名:port是可以的 ssh服务远程和连接 12ssh -Port=6000 username@x.x.x.x注：x.x.x.x为服务端的公网IP 摘自：https://www.jianshu.com/p/0c49556e8e15 附录 一个Server,多个Client配置 服务器端的配置都是一样的，只需要在新添加的客户端上修改frpc.ini 1234567891011121314[common] #必须有的配置段，在frpc.ini和frps.ini中都必须要有server_addr = x.x.x.x #服务端的公网IP（外网IP）server_port = 7000 #服务端服务的监听端口[web_3] #▲自己定义的服务转发标签（自定义，非严格）type = http #定义转发类型为http（严格）local_port = 8800 #定义所需要转发的本地web服务的端口为8800,跟nginx设置的一致custom_domains = node2.xxx.com #▲定义访问转发服务的域名（确保使用该域名访问可以解析到有公网IP的服务端）[ssh_3] #▲自己定义的服务转发标签（自定义，严格）type = tcp #定义转发类型为tcp（严格）local_ip = 127.0.0.1 #由于转发代理的ssh服务在本地，因此填写本地地址local_port = 22 #ssh服务本地的监听端口remote_port = 8000 #▲实际开启ssh时连接时访问的端口 ▲1.注意上述有▲的地方，就是修改的地方，这个配置信息的头每个客户端必须不一样。即[web_3]与[web]不一样。 ▲2.SSH的话：每个客户端要配置进入ssh的端口 , 比如x.x.x.x:6000进入1号,x.x.x.x:8000进入二号 ▲3.WEB服务的话：每个客户端要配置进入web的域名 , 比如a.nymrli.top:8888进入1号,b.nymrli.top:8888进入二号","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"构造一个能发数据的POST请求头","slug":"构造一个能发数据的POST请求头","date":"2019-03-01T14:23:52.000Z","updated":"2019-09-15T08:07:31.081Z","comments":true,"path":"2019/03/01/构造一个能发数据的POST请求头/","link":"","permalink":"https://nymrli.top/2019/03/01/构造一个能发数据的POST请求头/","excerpt":"","text":"之前学请求、响应的时候只是过了一边，大致知道有这些东西。但这次真正要用的时候却又忘了到底该如何写，错误的请求头、请求体的格式导致esp8266一直发送不了数据到服务器上，又重新看了遍请求request的知识，才终于搞明白 请求 最初的写法: 由于在esp8266上已经选择、连接好了了httpbin.org的穿透，就以为Host可以不用加了，于是产生了 最初的写法： 1POST /post?= HTTP/1.1 ▲根据玩单片机的小伙伴说必须多出一行\\r\\n，所以这边是有一行空行的 结果： 400 BAD_REQUEST 搜索过后得知 : 如果使用http 1.1协议的话主机名HOST字段是必须的 第二次写法: 12POST /post?= HTTP/1.1 Host:httpbin.org 可以注意到的是Host是顶层域名，/post只是其中的一个路由 结果: 成功，这样就算可以正常发送post请求了 于是下一步就是研究如何上传数据 第三次写法： 123POST /post?= HTTP/1.1Host: httpbin.orgtempt=57 于是这次都没有返回值了. 想起了表单是有形式的，于是添加了 Content-Type: application/x-www-form-urlencoded 这个形式的参数应该写成a=1&amp;b=..&amp;.. 注.如果请求网页的表单中没设置 enctype 属性，那么最终就会默认以 application/x-www-form-urlencoded 方式提交数据。 如果是Content-Type: application/json 则改写成{'a':1 , 'b'=.. , ...} multipart/form-data，我们使用表单上传文件时，必须让 form 的 enctyped等于这个值，请求示例 12345678910111213POST http://www.example.com HTTP/1.1 Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=&quot;text&quot; title ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot; Content-Type: image/png PNG ... content of chrome.png ... ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 说明: 首先生成了一个boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以mutipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。关于 mutipart/form-data的详细定义，请前往 rfc1867 查看。 text/xml，XML-RPC 是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的： 123456789101112POST http://www.example.com HTTP/1.1 Content-Type: text/xml &lt;!--?xml version=&quot;1.0&quot;?--&gt; &lt;methodcall&gt; &lt;methodname&gt;examples.getStateName&lt;/methodname&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/params&gt; &lt;/methodcall&gt; 但是虽然能接受到返回的结果，但是响应数据中发现form一直是空的，那就是参数没传过去，于是想到是不是格式的错误 第四次写法 后来上网找寻了一下结果发现我遗漏了模板中的\\r\\n\\r\\n这行，即请求头 和 请求体 之间至少有一行换行！！！ 12345POST /get HTTP/1.1Content-Type: application/x-www-form-urlencodedConnection:closea=23&amp;b=34 中间的空行不能省略 ， 这样httpbin.org那边才不返回 ERROR或是BAD_REQUEST 但是数据还是发送不出 于是咨询了qk大佬以后，才发现原来请求头也必须要加上Content-Length:8… 最终完成版 123456POST /get HTTP/1.1Content-Type: application/x-www-form-urlencodedConnection:closeContent-Length:8a=23&amp;b=34 哎…本来很简单的事，竟然弄了一个多小时才搞定，真只能怪自己学艺不精了。幸好的是，还是调出来了。 附录: HTTP请求报文解剖 : 组成 HTTP请求报文由3部分组成（请求行+请求头+请求体）： 内容 格式 HttpWatch HttpWatch是强大的网页数据分析工具，安装后将集成到Internet Explorer工具栏中。它不用代理服务器或一些复杂的网络监控工具，就能抓取请求及响应的完整信息，包括Cookies、消息头、查询参数、响应报文等，是Web应用开发人员的必备工具。 摘自HTTP请求行、请求头、请求体详解","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"为了不跑操而Excel——Orz","slug":"为了不跑操而Excel——Orz","date":"2019-03-01T07:45:07.000Z","updated":"2019-09-15T08:07:31.021Z","comments":true,"path":"2019/03/01/为了不跑操而Excel——Orz/","link":"","permalink":"https://nymrli.top/2019/03/01/为了不跑操而Excel——Orz/","excerpt":"","text":"为了不跑操而Excel——Orz 3月1日 Excel 15、16、17、18级分类——筛选、开头是（?15通配符）、制不同表 获得50m、800-1000m、身高、肺活量……各年级数据和总的平均值 有的单元框内容虽然看上去像数字(数值靠右)，但其实是文本(文本靠左)，需要做处理后才能进行公示计算——分列 复杂的重复公示最好还是指明地址 翻到下一个非空单元格——Ctrl + ↓ 或 ↑ 3月4日 文字排版不支持竖版，所以弄成图片后发布的 4月28日 图片排版,体育部的网站支持源代码修改,因此可以修改html代码. 123456789101112131415161718192021&lt;table cellspacing=\"100\" cellpadding=\"20\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; &lt;img data-layer=\"photo\" src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/20a324aa-c891-4be2-9174-590277bff71d.jpg\" original-src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/20a324aa-c891-4be2-9174-590277bff71d_d.jpg\" sudyfile-attr=\"&#123;'title':'webwxgetmsgimg (1).jpg'&#125;\" width=\"600\" height=\"400\" border=\"0\" hspace=\"0\" vspace=\"0\" style=\"width:600px;height:400px;\" /&gt; &lt;/td&gt; &lt;td&gt; &lt;img data-layer=\"photo\" src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/c9fdcc12-a3e5-422e-b4cb-ac6c5ecd9e64.jpg\" original-src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/c9fdcc12-a3e5-422e-b4cb-ac6c5ecd9e64_d.jpg\" sudyfile-attr=\"&#123;'title':'webwxgetmsgimg (2).jpg'&#125;\" style=\"font-size:14px;width:600px;height:400px;\" width=\"600\" height=\"400\" border=\"0\" hspace=\"0\" vspace=\"0\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img data-layer=\"photo\" src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/67108b99-b0f6-42bf-aac4-a6e012e7e66d.jpg\" original-src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/67108b99-b0f6-42bf-aac4-a6e012e7e66d_d.jpg\" style=\"width:600px;height:400px;\" sudyfile-attr=\"&#123;'title':'webwxgetmsgimg (3).jpg'&#125;\" width=\"600\" height=\"400\" border=\"0\" hspace=\"0\" vspace=\"0\" /&gt; &lt;/td&gt; &lt;td&gt; &lt;img data-layer=\"photo\" src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/69659dd8-a9a2-424f-bdb7-324c1807af18.jpg\" original-src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/69659dd8-a9a2-424f-bdb7-324c1807af18_d.jpg\" sudyfile-attr=\"&#123;'title':'webwxgetmsgimg (4).jpg'&#125;\" width=\"600\" height=\"400\" border=\"0\" hspace=\"0\" vspace=\"0\" style=\"width:600px;height:400px;\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;","categories":[],"tags":[{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Flask 本地局域网连接","slug":"Flask-本地局域网连接","date":"2019-02-28T10:43:55.000Z","updated":"2019-09-15T08:07:30.934Z","comments":true,"path":"2019/02/28/Flask-本地局域网连接/","link":"","permalink":"https://nymrli.top/2019/02/28/Flask-本地局域网连接/","excerpt":"","text":"Flask 本地局域网连接 之前都是在活动室的电脑上配好web环境，但其实发现很多比赛只要截图就够了。所以这次看了下能不能用局域网访问。一查果然flask可以通过局域网进行访问 使用pycharm的朋友要这样设定 1.run-&gt;Edit Configurations 2.Additional options 3.运行run（Ctrl+shift+F10）即可 注:如果没有这样设定 pycharm启动 是不会有作用的（就像这样）地址依旧会是127.0.0.1 查看自己的IP地址 1.命令行方式 cmd-&gt;ipconfig-&gt;IPv4 2.查网络与共享中心 打开端口 如果还不行的话就可能是 端口没有打开 解决方案: 开始中搜索 windows防火墙 ， 这样就大功告成了！ 然后通过 局域网IP：PORT就可以访问到网页啦","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"eclipse使用","slug":"eclipse使用","date":"2019-02-26T05:18:25.000Z","updated":"2019-11-27T02:25:01.964Z","comments":true,"path":"2019/02/26/eclipse使用/","link":"","permalink":"https://nymrli.top/2019/02/26/eclipse使用/","excerpt":"","text":"Eclipse 选择工作路径 新建工程 一.选择File-&gt;New-&gt;Project 二.Java-&gt;Java Project 三.工程配置 这步可以选择创建或者不创建，目前都没有什么影响。（Java 9最大的特性——模块化） 四.是否打开导航视图窗口 此类项目与Java透视图相关联。 此透视图旨在支持Java开发。它提供了包资源管理器、类型层次结构和特定于java的导航操作。 您现在想打开这个透视图吗? 如果按了create的话，就会产生该文件 ▲注意 一个工作空间中只能有一个工程有main 五.新建class 编写第一个程序 123456// package java;public class hello &#123; public static void main(String []args) &#123; System.out.println(\"Hello World\"); &#125;&#125; 如果编写完成后，选择工具栏的运行。如果运行按钮无法按下、或按下无效，请检查代码。 类名是否和文件名一致（在IDE下应该不会产生这样的问题） main是否写对 String []args要写上,不能缺省 注意 . 如果发生错误 ， 会产生如下弹窗 ， 此时应该再次检查语法 navigation导航栏说明 附录 自动添加注释 一、新建class时自动添加注释 windows–&gt;preference进入选项卡。 然后选择Java–&gt;Code Style–&gt;Code Templates，如图： 按下Edit，然后添加一行@(随意) ${date}即可，${date}为固定的宏，大小写写错无效 保存配置后，选中类，使用快捷键alt＋shift+j可以快速添加注释。 新建类自动添加注释 选择Code Templates选项卡内的Code—&gt;New Java files，编辑它。 123456789$&#123;filecomment&#125;$&#123;package_declaration&#125;/*** @author 作者* @version 创建时间：$&#123;date&#125; $&#123;time&#125;* 类说明*/$&#123;typecomment&#125;$&#123;type_declaration&#125; 注释内容摘自eclipse自动添加作者、日期等注释 设置补全代码 打开eclipse依次点击Window --&gt; Perferences --&gt; Java --&gt; Editor --&gt; Content Assist-&gt;在【Auto activation triggers for Java：】选项后的文本框中会看到一个**&quot;.&quot;**，将其改成qwertyuiopasdfghjklzxcvbnm即可 ▲初始安装完eclipse后，默认情况下只有在你输入&quot;.&quot;之后才会有代码提示和自动补全。 修改补全提示时间 Window --&gt; Perferences --&gt; Java --&gt; Editor --&gt; Content Assist-&gt;在【Auto activation delay(ms)：】 快捷键介绍 Alt+ Shift + j , 快速注释 Alt + ↑ 向上切换 ctrl +D 删除该行 Alt+↔ 切回上一处编辑位置 Shift+Alt+↔ 选中单词 Ctrl + Enter 切换到行尾 Shift + Enter 直接切换下一行 Ctrl+Alt+↑，即可以在上面快速复制一行。 Ctrl+Shift+f: 格式化代码 快速添加get和set方法： 首先创建好该类的field; 选中需要生成的变量，然后shift+alt+s，选择generate getters and getters,","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"IDE","slug":"IDE","permalink":"https://nymrli.top/tags/IDE/"}]},{"title":"南京邮电大学java程序设计作业在线编程第二次作业","slug":"南京邮电大学java程序设计作业在线编程第二次作业","date":"2019-02-26T04:52:41.000Z","updated":"2019-09-15T08:07:31.035Z","comments":true,"path":"2019/02/26/南京邮电大学java程序设计作业在线编程第二次作业/","link":"","permalink":"https://nymrli.top/2019/02/26/南京邮电大学java程序设计作业在线编程第二次作业/","excerpt":"","text":"总分：100 选择题得分：60 \\1. 表达式9==8&amp;&amp;3&lt;7的运算结果是（ ） A.1 B.0 C.true D.false 正确答案是: D \\2. 表达式(3&gt;2)?8:9的运算结果是（ ） A.3 B.2 C.8 D.9 正确答案是: C \\3. 表达式9-7&lt;0||11&gt;8的运算结果（ ） A.true B.false C.1 D.0 正确答案是: A \\4. 表达式48%9+5*5-4的运算结果（ ） A.24 B.26 C.-30 D.46 正确答案是: A \\5. 表达式2&gt;=5的运算结果是（ ） A.2 B.5 C.true D.false 正确答案是: D \\6. 表达式15+4*5-12的运算结果是（ ） A.15 B.23 C.12 D.-133 正确答案是: B \\7. 以下（ ）不属于复合类型的数据类型 A.类 B.字符型 C.数组 D.接口 正确答案是: B \\8. 在Java中，不属于整数类型的是（ ） A.double B.long C.int D.byte 正确答案是: A \\9. 下列变量定义中，（ ）是错误的 A.float x;y; B.float x,y=3.14f; C.public int i=100,j=2,k; D.int i=100;int j=200; 正确答案是: A \\10. 以下选项中，（ ）能正确表示Java语言中的一个整型常量。 A.-8.0 B.1,000,000 C.-30 D.“456” 正确答案是: C \\11. 下面程序段执行后的结论是（ ）int m=2,n=2; m+=m-=m*m; n-=n*n; n=n+n; A.m=n B.m&gt;n C.m&lt;n D.m与n类型不同，不能比较 正确答案是: B \\12. 执行下列程序段： int no; int a=19,b=8; no=(a%b&gt;5)?a+b:a-b; System.out.println(no);输出结果是： A.2 B.9 C.11 D.27 正确答案是: C \\13. 下列语句执行后的输出结果是：( ) int e=Integer.parseInt(&quot;&quot;+3+3); System.out.println(e-2.5); A.30.5 B.3.5 C.332.5 D.8.5 正确答案是: A \\14. 定义a为int类型的变量并且已被赋初值，则合法的赋值语句是（ ） A.a+1==4; B.a+=a*8; C.a=6.6f; D.int a=18; 正确答案是: B \\15. 设m、n、x、y为已赋值的int变量，下列（ ）的运算结果属于非逻辑值。 A.m!=n&amp;x%y&lt;m B.m++==m+n+x+y C.++m*b–+y D.m+n&gt;=x+y 正确答案是: C \\16. 以下选项中的变量都已经正确定义并且赋初值，不合法的表达式是（ ） A.m &gt;= 6 == n &gt; 1 B.‘m’ + 6 C.‘m’ = 8 D.‘M’ % 8 正确答案是: C \\17. 以下标识符中，（ ）是不合法的 A.inter_net B.i_nong C.Helo D.*member 正确答案是: D \\18. 以下字符常量中不合法的是（ ） A.’#’ B.’&amp;’ C.“P” D.‘囧’ 正确答案是: C \\19. 下面（ ）是Java数据类型中int类型的取值范围。 A.-27~27-1 B.0~216-1 C.-215-215-1 D.-231~231-1 正确答案是: D \\20. 在Java语言中，下面（ ）类型可以表示整数基本数据类型。 A.single B.byte C.double D.char 正确答案是: B 编程题得分：40 2-1 是不是太胖了 得分：10 / 10 12345678910import java.util.Scanner;public class Main &#123; public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int height = scanner.nextInt(); double result = (height-100)*0.9*2; System.out.printf(\"%.1f\\n\" , result); &#125; &#125; 2-2 Say hello to integers 得分：10 / 10 1234567891011import java.util.Scanner;public class Main &#123; public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int one = scanner.nextInt(); int two = scanner.nextInt(); System.out.printf(\"Hello, %d and %d!\\n\" ,one,two); //System.out.println( \"Hello, \"+one+\" and \"+two+\"!\"); &#125; &#125; 2-3 求整数的平均值 得分：10 / 10 12345678910111213import java.util.Scanner;public class Main &#123; public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int one = scanner.nextInt(); int two = scanner.nextInt(); int thr = scanner.nextInt(); int four = scanner.nextInt(); int sum = one+two+thr+four; System.out.printf(\"Sum=%d;Average=%.1f\\n\" ,sum,sum/4.0); &#125; &#125; 2-4 整数四则运算 得分：10 / 10 123456789101112131415161718import java.util.Scanner;public class Main &#123; /** * @author Mr.li * @param args */ public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(); int b = scanner.nextInt(); System.out.printf(\"%d+%d=%d\\n\" , a,b,a + b); System.out.printf(\"%d-%d=%d\\n\" , a,b,a - b); System.out.printf(\"%d*%d=%d\\n\" , a,b,a * b); System.out.printf(\"%d/%d=%d\\n\" , a,b,a / b); // System.out.println(a+\"+\"+b+\"=\"+(a+b)); &#125; &#125; 2-3 华氏温度转换摄氏温度 得分：10 / 10 123456789import java.util.Scanner;public class Main &#123; public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int Ftem = scanner.nextInt(); int Ctem = 5*(Ftem-32)/9; System.out.printf(\"Celsius=\"+Ctem+\"\" ); &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"南京邮电大学java程序设计作业在线编程第一次作业","slug":"南京邮电大学java程序设计作业在线编程第一次作业","date":"2019-02-26T04:50:14.000Z","updated":"2019-09-15T08:07:31.032Z","comments":true,"path":"2019/02/26/南京邮电大学java程序设计作业在线编程第一次作业/","link":"","permalink":"https://nymrli.top/2019/02/26/南京邮电大学java程序设计作业在线编程第一次作业/","excerpt":"","text":"总分：100 选择题得分：40 \\1. Java语言中，基本数据类型一共有（ ）种。 A.16 B.2 C.4 D.8 正确答案是: D \\2. Java虚拟机的英文缩写是（ ） A.JRE B.ECLIPSE C.JVM D.JDK 正确答案是: C \\3. Java程序中，最常见的对主方法的定义是（ ）。 A.private static int main(String args[ ]){ } B.public static void main(String args[ ]){ } C.public static int main(char args[ ]){ } D.private static void main(char args[ ]){ } 正确答案是: B \\4. Java源程序的文件名必须和程序中（ ）的名字相同。 A.公共类 B.主函数 C.主程序 D.主方法 正确答案是: A \\5. Java语言字节码文件的后缀名为（ ）。 A…byte B…bit C…class D…java 正确答案是: C \\6. Java语言源程序的文件后缀是（ ）。 A…j B…ja C…jav D…java 正确答案是: D \\7. Java语言中实现将源代码转换成字节码文件的过程，被称为（ ）。 A.翻译 B.编译 C.解释 D.汇编 正确答案是: B \\8. 下列哪一种语言不支持面向对象的编程思想？ A.C B.C++ C.Java D.Python 正确答案是: A 编程题得分：60 1-3 输出What is a computer?得分：10 / 10 12345public class Main &#123; public static void main(String[] args) &#123; System.out.println(\"What is a computer?\"); &#125;&#125; 1-2 输出I Love Programming! 得分：10 / 10 12345public class Main &#123; public static void main(String[] args) &#123; System.out.println(\"I Love Programming!\"); &#125;&#125; 1-1 输出Hello World! 得分：10 / 10 123456import java.io.*;public class Main &#123; public static void main(String[] args) throws IOException&#123; System.out.println(\"Hello World!\"); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Python任务调度模块APScheduler","slug":"Python任务调度模块APScheduler","date":"2019-02-24T11:30:06.000Z","updated":"2019-09-15T08:07:30.985Z","comments":true,"path":"2019/02/24/Python任务调度模块APScheduler/","link":"","permalink":"https://nymrli.top/2019/02/24/Python任务调度模块APScheduler/","excerpt":"","text":"Python任务调度模块APScheduler APScheduler是一个python的第三方库，用来提供python的后台程序。包含四个组件，分别是： triggers： 任务触发器组件，提供任务触发方式 triggers（触发器）中包含调度逻辑，每个作业都由自己的触发器来决定下次运行时间。除了他们自己初始配置意外，触发器完全是无状态的。 job stores： 任务商店组件，提供任务保存方式 job stores（作业存储器）存储被调度的作业，默认的作业存储器只是简单地把作业保存在内存中，其他的作业存储器则是将作业保存在数据库中。当作业被保存到一个持久化的作业存储器中的时候，该作业的数据会被序列化，并在加载时被反序列化。作业存储器不能共享调度器。 executors： 任务调度组件，提供任务调度方式 executors（执行器）处理作业的运行，他们通常通过在作业中提交指定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。 schedulers： 任务调度组件，提供任务工作方式 schedulers（调度器）配置作业存储器和执行器可以在调度器中完成，例如添加、修改和移除作业。根据不同的应用场景可以选用不同的调度器，可选的有BlockingScheduler,BackgroundScheduler,AsyncIOScheduler,GeventScheduler,TornadoScheduler,TwistedScheduler,QtScheduler 7种。 其中BlockingScheduler与BackgroundScheduler是其中最常用的两种调度器。那他们之间有什么区别呢？ BlockingScheduler: 调用start函数后会阻塞当前线程。当调度器是你应用中唯一要运行的东西时 BackgroundScheduler: 调用start后主线程不会阻塞。当你不运行任何其他框架时使用，并希望调度器在你应用的后台执行。 使用的一个简单实例 1234567891011121314from apscheduler.schedulers.blocking import BlockingScheduler # 阻塞import time# 实例化一个调度器scheduler = BlockingScheduler() def job1(): print \"%s: 执行任务\" % time.asctime()# 添加任务并设置触发方式为3s一次scheduler.add_job(job1, 'interval', seconds=3)# 开始运行调度器scheduler.start() 触发器 date 一次性指定日期 interval 在某个时间范围内间隔多长时间执行一次 cron 和Linux crontab格式兼容，最为强大 date 最基本的一种调度，作业只会执行一次。它的参数如下： run_date (datetime|str) – 作业的运行日期或时间 timezone (datetime.tzinfo|str) – 指定时区 1234# 2016-12-12运行一次job_functionsched.add_job(job_function, 'date', run_date=date(2016, 12, 12), args=['text'])# 2016-12-12 12:00:00运行一次job_functionsched.add_job(job_function, 'date', run_date=datetime(2016, 12, 12, 12, 0, 0), args=['text']) interval 间隔调度，参数如下： weeks (int) – 间隔几周 days (int) – 间隔几天 hours (int) – 间隔几小时 minutes (int) – 间隔几分钟 seconds (int) – 间隔多少秒 start_date (datetime|str) – 开始日期 end_date (datetime|str) – 结束日期 12# 每两个小时调一下job_functionsched.add_job(job_function, 'interval', hours=2) cron参数如下： year (int|str) – 年，4位数字 month (int|str) – 月 (范围1-12) day (int|str) – 日 (范围1-31) week (int|str) – 周 (范围1-53) day_of_week (int|str) – 周内第几天或者星期几 (范围0-6 或者 mon,tue,wed,thu,fri,sat,sun) hour (int|str) – 时 (范围0-23) minute (int|str) – 分 (范围0-59) second (int|str) – 秒 (范围0-59) start_date (datetime|str) – 最早开始日期(包含) end_date (datetime|str) – 最晚结束时间(包含) timezone (datetime.tzinfo|str) – 指定时区 1234# job_function将会在6,7,8,11,12月的第3个周五的1,2,3点运行sched.add_job(job_function, 'cron', month='6-8,11-12', day='3rd fri', hour='0-3')# 截止到2016-12-30 00:00:00，每周一到周五早上五点半运行job_functionsched.add_job(job_function, 'cron', day_of_week='mon-fri', hour=5, minute=30, end_date='2016-12-31') 添加任务 有两种方法，一种是使用add_job()函数，还有一种方式是通过scheduled_job()装饰器。 add_job()函数方式 123456789101112131415from apscheduler.schedulers.blocking import BlockingSchedulerimport datetime def my_job1(): print 'my_job1 is running, Now is %s' % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") def my_job2(): print 'my_job2 is running, Now is %s' % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") sched = BlockingScheduler()# 每隔5秒运行一次my_job1sched.add_job(my_job1, 'interval', seconds=5,id='my_job1')# 每隔5秒运行一次my_job2sched.add_job(my_job2,'cron',second='*/5',id='my_job2')sched.start() scheduled_job()装饰器方式 1234567891011121314from apscheduler.schedulers.blocking import BlockingSchedulerimport datetime sched = BlockingScheduler()#每隔5秒运行一次my_job1@sched.scheduled_job('interval',seconds=5,id='my_job1')def my_job1(): print 'my_job1 is running, Now is %s' % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") #每隔5秒运行一次my_job2@sched.scheduled_job('cron',second='*/5',id='my_job2')def my_job2(): print 'my_job2 is running, Now is %s' % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")sched.start() 使用SQLAlchemy作业存储器存放作业 12345678910111213141516171819202122from apscheduler.schedulers.blocking import BlockingSchedulerfrom datetime import datetime,timedeltaimport logging sched = BlockingScheduler()def my_job(): print 'my_job is running, Now is %s' % datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")#使用sqlalchemy作业存储器url='mysql+mysqldb://root:123456@localhost:3306/scrapy?charset=utf8'sched.add_jobstore('sqlalchemy',url=url)#添加作业sched.add_job(my_job,'interval',id='myjob',seconds=5) log = logging.getLogger('apscheduler.executors.default')log.setLevel(logging.INFO) # DEBUG#设定日志格式fmt = logging.Formatter('%(levelname)s:%(name)s:%(message)s')h = logging.StreamHandler()h.setFormatter(fmt)log.addHandler(h) sched.start() 部分摘自:APScheduler浅析 Flask-APScheduler 大致用法跟APScheduler一致，只不过需要 1.在配置中设置SCHEDULER_API_ENABLED = True 2.app配置 12345from flask_apscheduler import APScheduler;scheduler = APScheduler();scheduler.init_app(app)scheduler.start() 3.添加任务 exts.py 12from flask_apscheduler import APSchedulersche = APScheduler() aap.py 123456789101112from exts import db,mail,schesche.init_app(app)...def refreshinfo(): passsche.add_job(func=refreshinfo, id='whetherInfo', trigger='interval', seconds=150)sche.start()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"搭建frp服务--阿里云服务器","slug":"搭建frp服务-阿里云服务器","date":"2019-02-24T06:56:27.000Z","updated":"2021-11-24T15:11:04.152Z","comments":true,"path":"2019/02/24/搭建frp服务-阿里云服务器/","link":"","permalink":"https://nymrli.top/2019/02/24/搭建frp服务-阿里云服务器/","excerpt":"","text":"搭建frp服务–阿里云服务器 为了可以远程访问活动室的电脑，需要进行内网穿透。之前9块钱买了花生壳的服务，勉强用用还行，带宽很有限。听说了frp后,打算在阿里云上安个frp服务，充当中转服务器。 什么是frp frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。 开始搭建 外网主机 SSH连接上外网主机后，使用wget指令下载frp。 wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gz 使用tar指令解压tar.gz文件 tar -zxvf frp_0.20.0_linux_amd64.tar.gz 使用cd指令进入解压出来的文件夹 1cd frp_0.20.0_linux_amd64/ 外网主机作为服务端，可以删掉不必要的客户端文件，使用rm指令删除文件。 12rm -f frpcrm -f frpc.ini 接下来要修改服务器配置文件，即frps.ini文件。使用vi指令对目标文件进行编辑。 1vi frps.ini 打开frps.ini后可以看到默认已经有很多详细的配置和示范样例，该文章仅以达到内网穿透为目的，所以这里选择删掉或注释掉里面的所有内容，然后根据群晖的情况，按照官方的中文文档添加以下配置。（这里的操作都使用vi命令，关于vi命令的使用方式这里不作详细介绍，可以自行搜索相关使用方法。） 123[common]bind_port = 7000vhost_http_port = 8080 [common]部分是必须有的配置，其中bind_port是自己设定的frp服务端端口，vhost_http_port是自己设定的http访问端口。 保存上面的配置后，使用以下指令启动frp服务端。（如果需要在后台运行，请往下翻阅关于后台运行的部分。） 1./frps -c ./frps.ini 服务端的工作就到此结束了。 客户端 客户端前面的操作和服务端是一模一样的，这里不一一解释。 123456wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gztar -zxvf frp_0.20.0_linux_amd64.tar.gzcd frp_0.20.0_linux_amd64rm -f frpsrm -f frps.inivi frpc.ini 客户端的配置如下 12345678910111213141516171819[common]server_addr = x.x.x.xserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000[nas]type = httplocal_port = 5000custom_domains = no1.sunnyrx.com[web]type = httplocal_port = 80custom_domains = no2.sunnyrx.com 上面的配置和服务端是对应的。 [common]中的server_addr填frp服务端的ip（也就是外网主机的IP），server_port填frp服务端的bind_prot。 [ssh]中的local_port填群晖的ssh端口。 [nas]中的type对应服务端配置。local_port填群晖的DSM端口。custom_domains为要映射的域名，记得域名的A记录要解析到外网主机的IP。 [web]同上，local_port填群晖的web端口。这里创建了两个http反向代理是为了分别映射群晖两个重要的端口，5000和80，前者用于登录群晖管理，后者用于群晖的Web Station和DS Photo。 保存配置，输入以下指令运行frp客户端。（同样如果需要在后台运行，请往下翻阅关于后台运行的部分。） 1./frpc -c ./frpc.ini 此时在服务端会看到&quot;start proxy sucess&quot;字样，即连接成功。 现在可以用SSH通过外网主机IP:6000和群晖建立SSH连接。通过浏览器访问no1.sunnyrx.com:8080打开群晖nas的管理页面，访问no2.sunnyrx.com:8080打开群晖Web Station的网站，DS Photo app可以连接no2.sunnyrx.com:8080进入DS Photo管理。 让frp在后台运行 虽然现在frp运作起来了，内网穿透也实现了，但这还是不够的。此时如果断开与服务端或者客户端的SSH连接（比如关掉了Xshell）也就中止了frp的运行。 保持frp运行是关键是让服务端的frp和客户端的frp在后台运行，这里提两个方法供参考，一个是使用screen指令，另一个是使用nohup指令。由于群晖的系统默认是没有screen指令的，这里也不提供安装screen的方法，所以推荐群晖直接使用nohup。 其实服务端也直接用’nohup’就好了。 使用screen让frp在后台运行 下面的示范是运行服务端的frp，客户端就不示范了，前面提过群晖的系统没有screen指令。 首先使用screen指令创建一个会话。 1screen -dmS frp 然后进入这个会话。 1screen -r frp 最后使用运行frp的指令，在后面加上&quot; &amp;&quot;。（如果之前断开了SSH连接，记得用cd指令进入frp的目录先。） 1./frps -c ./frps.ini &amp; 这样就让frp在后台运行了。 使用nohup指令 nohup指令的使用方法相对简单，只需要在nohup后面加上frp的运行指令即可。下面示范的指令是运行frp客户端。（同样，如果之前断开了SSH连接，记得用cd指令进入frp的目录先。） 1nohup ./frpc -c ./frpc.ini &amp; 这样就成功让frp在后台运行了。 ▲ 注意nohup千万不要达成nohub，不然是没有效果的，有的时候会报错告诉你 没有nohub这个命令，有的时候终端（terminal）直接会消失而没有反应 摘自链接：https://www.jianshu.com/p/e8e26bcc6fe6 经过教程操作后，发现客户端电脑能够连接到学长家里已经搭好的frp服务器，但是就是连接不上阿里云。于是猜测是阿里云某些端口没有打开，一查果然如此，解决方案如下 为阿里云的安全服务限制，只有几个端口是默认打开的，所以要自己登陆阿里云服务器后台更改端口限制。 ECS服务器修改网络和安全组中的安全组配置 轻量级服务器修改安全-防火墙,如图 添加好以后,发现客户端仍然连不上去。担心是需要重启，于是重启后还是不行。到最后才发现原来是客户端的frpc.ini中server_addr写错了一位IP字段，QAQ… 最后还要记得在防火墙中打开6000端口，协议还是TCP，最后即可以通过IP:6000就可以访问到内网主机了 12345[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000 服务暴露 ①.tcp 服务端的vhost_http_port配合客户端的type=http使用 frps.ini 1234567[common]bind_port = 7000vhost_http_port = 34444dashboard_port = 31356dashboard_user = apollo3ddashboard_pwd = apollo3d frpc.ini 1234567891011121314151617181920212223242526272829303132333435363738394041[common]server_addr = 49.235.118.244server_port = 7000tls_enable = true####################此处为common的默认配置区域无需修改#################### 日志记录路径log_file = /home/apollo3d/frp_0.37.1_linux_amd64/common.log# 日志记录级别(trace, debug, info, warn, error)log_level = info# 日志记录滚动天数# log_max_days = 3# frpc客户端管理界面admin_addr = 127.0.0.1admin_port = 7400admin_user = apollo3dadmin_passwd = apollo3d# 连接池pool_count = 5# tcp数据流多路复用，默认开启，服务端客户端需要保持一致tcp_mux = true# 失败重连login_fail_exit = false# 服务端与客户端通信协议，支持tcp\\updprotocol = tcp# dns服务选用dns_server = 8.8.8.8#客户端向服务端心跳检查间隔与超时时间heartbeat_interval = 10heartbeat_timeout = 90##############以上为客户端服务的公共信息配置区域############[ssh_193]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 20009[visdom]type = httplocal_ip = 127.0.0.1local_port = 23333custom_domains = cplm.nymrli.top ②.http 服务端不做配置， 客户端frpc中采用type=tcp，并通过remote_port指定远程端口 frps.ini 123456[common]bind_port = 7000dashboard_port = 31356dashboard_user = apollo3ddashboard_pwd = apollo3d frpc.ini 1234567891011121314151617181920212223242526[common]server_addr = 159.75.90.252server_port = 7000tls_enable = true# 日志记录路径log_file = /home/apollo3d/frp_0.37.1_linux_amd64/common.log# 日志记录级别(trace, debug, info, warn, error)log_level = info# 日志记录滚动天数log_max_days = 3[ssh_condor0]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 10179[jupyter]type = tcplocal_ip = 127.0.0.1local_port = 9998custom_domains = tc.hanckh.topremote_port= 9999 附录 开机自动启动frp服务 由于自行搭建的服务器可能会出故障，如果重启后需要自行启动很多应用的话就会很麻烦，所以这边推荐一个自动启动frp服务的方法 1.frpx.sh 如果是服务器端可以编写frpServer.sh 123#!/bin/bashbasepath=$(cd `dirname $0`; pwd)nohup $basepath/frps -c $basepath/frps.ini &gt;/dev/null 2&gt;&amp;1 &amp; 如果是客户端，则可以编写frpClient.sh 123#!/bin/bashbasepath=$(cd `dirname $0`; pwd)nohup $basepath/frps -c $basepath/frps.ini &gt;/dev/null 2&gt;&amp;1 &amp; rc.local自启动 123$ sudo vim /etc/rc.local# 将下述内容写在exit 0之上, 注意路径自行确认，这只是给了个demo/home/apollo3d/frp_0.21.0_linux_amd64/frpx.sh","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"},{"name":"网络知识","slug":"网络知识","permalink":"https://nymrli.top/tags/网络知识/"}]},{"title":"Cmake 入门","slug":"Cmake-入门","date":"2019-02-18T08:42:36.000Z","updated":"2019-09-15T08:07:30.927Z","comments":true,"path":"2019/02/18/Cmake-入门/","link":"","permalink":"https://nymrli.top/2019/02/18/Cmake-入门/","excerpt":"","text":"Cmake 入门 入门案例：单个源文件 例如，假设现在我们的项目中只有一个源文件 main.cc ，该程序的用途是计算一个数的指数幂。 1.首先编写 CMakeLists.txt 文件，并保存在与 main.cc 源文件同个目录下 123456# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo1)# 指定生成目标add_executable(Demo main.cc) 语法: 由命令、注释和空格组成，其中命令是不区分大小写的。 符号 # 后面的内容被认为是注释 命令由命令名称、小括号和参数组成 参数之间使用空格进行间隔 2.编译项目 之后，在当前目录执行 cmake . ，得到 Makefile 后再使用 make 命令编译得到 Demo1 可执行文件。 同一目录，多个源文件 如果多文件，结构变成 1234567./Demo2 | +--- main.cc | +--- MathFunctions.cc | +--- MathFunctions.h cmakelist.txt需要改成 123456# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo2)# 指定生成目标add_executable(Demo main.cc MathFunctions.cc) 区别: 即在 add_executable 命令中增加了一个 MathFunctions.cc 源文件 省事的方法是使用 aux_source_directory 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。语法为aux_source_directory(&lt;dir&gt; &lt;variable&gt;) 123456789# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo2)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(Demo $&#123;DIR_SRCS&#125;) 多个目录，多个源文件 文件结构: 123456789./Demo3 | +--- main.cc | +--- math/ | +--- MathFunctions.cc | +--- MathFunctions.h 对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。 根目录中的 CMakeLists.txt ： 123456789101112131415# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo3)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# ▲添加 math 子目录add_subdirectory(math)# 指定生成目标 add_executable(Demo main.cc)# 添加链接库target_link_libraries(Demo MathFunctions) 使用命令 add_subdirectory 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理. 使用命令 target_link_libraries 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 子目录中的 CMakeLists.txt： 12345# 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 生成链接库add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;) 在该文件中使用命令 add_library 将 src 目录中的源文件编译为静态链接库 摘自CMake 入门实战 set指令详解 语法： SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) 指令功能: 用来显式的定义变量 例子: SET (SRC_LST main.c other.c) 说明: 用变量代替值，例子中定义SRC_LST代替后面的字符串。 例子: 一. CMAKE_SOURCE_DIR --&gt;CMakeLists.txt所在的目录 set(libs &quot;${CMAKE_SOURCE_DIR}/src/main/jnilibs&quot;)定义了一个变量libs，并且变量的值为${CMAKE_SOURCE_DIR}/src/main/jnilibs，其中CMAKE_SOURCE_DIR 是一个cmake内置变量，指定了CMakeLists.txt所在的目录 二.CMAKE_LIBRARY_OUTPUT_DIRECTORY–&gt;cmake编译输出的东西应该放在什么地方 set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/src/main/jnilibs/${ANDROID_ABI})这个命令用于给CMAKE_LIBRARY_OUTPUT_DIRECTORY宏赋值，该宏指定了cmake编译输出的东西应该放在什么地方。 这个例子中的地方是${PROJECT_SOURCE_DIR}/src/main/jnilibs/${ANDROID_ABI}其中PROJECT_SOURCE_DIR 是cmake内置宏，指向构建工程的全路径。 include包含库、头文件 添加头文件路径，对应的函数叫include_directories 添加库路径，对应的函数叫LINK_DIRECTORIES 添加库，对应的函数叫LINK_LIBRARIES，把所有的库加进去即可 环境变量 使用$ENV{NAME}指令就可以调用系统的环境变量了。比如MESSAGE(STATUS “HOME dir: $ENV{HOME}”) 设置环境变量的方式是:SET(ENV{变量名} 值) dl、rt 1234567target_link_libraries(agentspark$&#123;RCSSNET3D_LIBRARY&#125;$&#123;Boost_SYSTEM_LIBRARY&#125;dl$&#123;CMAKE_THREAD_LIBS_INIT&#125;rt ) dl是libdl.so,rt是librt.so的缩写···其实是静态加载了这两个动态链接库！！！","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"Python+adb操作手机","slug":"Python-adb操作手机","date":"2019-02-06T05:00:09.000Z","updated":"2019-09-15T08:07:30.977Z","comments":true,"path":"2019/02/06/Python-adb操作手机/","link":"","permalink":"https://nymrli.top/2019/02/06/Python-adb操作手机/","excerpt":"","text":"Adb wifi连接调试 adb connect {ip} 如果你不想用usb连接调试，可以选择使用adb 连接调试，命令是 adb connect {ip} ，需要在同一个局域网内。这个功能也比较实用，但首次连接时，需要另外一些配置，建议可以网上搜索下adb wifi连接手机等关键字看看。 屏幕截屏 screencap -p {图片存储地址} 这个其实直接通过手机截屏再发送到电脑就可以了，但我开发的是TV应用，在盒子上没法截屏，所以这个命令对我来说还是较实用的。 获取或推送文件 adb pull/push 这个也挺实用的，获取手机指定位置的文件到电脑上，或者从电脑发送文件到手机上 模拟按键事件 //这条命令相当于按了设备的Back key键 adb shell input keyevent 4 //可以解锁屏幕 adb shell input keyevent 82 //在屏幕上做划屏操作，前四个数为坐标点，后面是滑动的时间（单位毫秒） adb shell input swipe 50 250 250 250 500 手机分辨率一般为1080*1920，其中左上角为（0,0），右下角为（1080*1920）,还可以增加一个参数为持续时间 //在屏幕上点击坐标点x=50 y=250的位置。 adb shell input tap 50 250 //输入字符abc adb shell input text abc 跳一跳游戏adb教程 事件介绍 代码演示都是在进入 adb shell模式下 input swipe模拟的是滑动事件 , 如左滑:input swipe 600 800 300 800 可以输入文本的文本框之类的控件上输入出 OuyangPeng 字符串: input text OuyangPeng input tap命令模拟触摸屏幕input tap 600 800 input keyevent用法: 12345678910input keyevent 3 // Homeinput keyevent 4 // Backinput keyevent 19 //Upinput keyevent 20 //Downinput keyevent 21 //Leftinput keyevent 22 //Rightinput keyevent 23 //Select/Okinput keyevent 24 //Volume+input keyevent 25 // Volume-input keyevent 82 // Menu 菜单 功能 adb 启动应用: adb shell am start -n packgage名 /.activity如 adb shell am start -n com.android.calculator2/.Calculator 提醒点：一定要找到、找对activity和package 长时间按某个元素：adb input shell … adb -s 4d0041be98b01f shell input touchscreen swipe 540 716 545 718 1000 语义：-s 后跟设备号，swipe 先传移动坐标范围‘540 716 545 718’，然后1000是长按时间，单位毫秒。 Python语句调用: os.system(只有执行命令是否成功的结果) 123456import osCMD = r'.\\adb.exe version'res = os.system(CMD)print(res) # 0&gt;&gt; Android Debug Bridge version 1.0.32&gt;&gt; 0 os.popen(可读取执行语句的结果) 12345import osCMD = r'.\\adb.exe version'version = os.popen().read()print(version)&gt;&gt; Android Debug Bridge version 1.0.32 subprocess.call 123456import subprocessCMD = r'.\\adb.exe version'version = subprocess.call(CMD)print(version) # 0&gt;&gt; Android Debug Bridge version 1.0.32&gt;&gt; 0 subprocess.Popen(也是一个执行系统命令的工具,但这边效果不太好) 12345import subprocessCMD = r'.\\adb.exe version'version = subprocess.Popen(CMD)print(version) # 这边是个Popen对象,&gt;&gt; &lt;subprocess.Popen object at 0x00000219392981D0&gt; 附录 event值记录 https://blog.csdn.net/jlminghui/article/details/39268419","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"模拟操作","slug":"模拟操作","permalink":"https://nymrli.top/tags/模拟操作/"}]},{"title":"ACM_动态规划","slug":"ACM-动态规划","date":"2019-02-03T07:49:10.000Z","updated":"2019-09-15T08:07:30.911Z","comments":true,"path":"2019/02/03/ACM-动态规划/","link":"","permalink":"https://nymrli.top/2019/02/03/ACM-动态规划/","excerpt":"","text":"图解动态规划 : http://www.sohu.com/a/153858619_466939 动态规划 : 最优子结构 边界 状态转移方程式 题目二： 国王和金矿 有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？ 解法一: 排列组合 时间复杂度 : O(2^N) 解法二 : DP 1.找到最优子结构 10人4金矿(有一个金矿没挖) 10-3人4金矿(挖了一个金矿) 2.最优选择 5个金矿的最优选择，就是*（前4座金矿10工人的挖金数量）和（前4座金矿7工人的挖金数量+第5座金矿的挖金数量）*的最大值！ 3.边界 经过整理可得 状态转移方程式: 边界: F(n,w) = 0 (n&lt;=1, w&lt;p[0]); F(n,w) = g[0] (n==1, w&gt;=p[0]); 推导式 F(n,w) = F(n-1,w) (n&gt;1, w&lt;p[n-1]) F(n,w) = max(F(n-1,w), F(n-1,w-p[n-1])+g[n-1]) (n&gt;1, w&gt;=p[n-1]) 实现方法: 简单递归 记忆搜索法 动态规划(递推式) 01背包问题 简单递归 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* 01背包问题 */pair&lt;int,int&gt; wv[maxn];int N; // 物品数量int W; // 背包重量int rec(int i,int j)&#123; int res = 0; if( i == N) res= 0; else if( j &lt; wv[i].first ) res = rec(i+1,j); else res = max(rec(i+1,j) , rec(i+1,j-wv[i].first) + wv[i].second); return res;&#125;void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; cout &lt;&lt; rec(0,W) &lt;&lt; endl;&#125;int main()&#123; solve(); return 0;&#125; 记忆搜索 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* 01背包问题 */pair&lt;int,int&gt; wv[maxn];int N; // 物品数量int W; // 背包重量int dp[maxn][maxn]; //2.多了个记忆数组(称为DP数组)int rec(int i,int j)&#123; if ( dp[i][j] &gt; 0 ) return dp[i][j]; // 如果已经计算过,就直接使用之前的结果 int res = 0; if( i == N) res= 0; else if( j &lt; wv[i].first ) res = rec(i+1,j); else res = max(rec(i+1,j) , rec(i+1,j-wv[i].first) + wv[i].second); dp[i][j] =res; // 2.将结果记录 return res;&#125;void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; cout &lt;&lt; rec(0,W) &lt;&lt; endl;&#125;int main()&#123; solve(); return 0;&#125; 动态规划解法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* 01背包问题 */pair&lt;int,int&gt; wv[maxn];int N; // 物品数量int W; // 背包重量int dp[maxn][maxn]; //2.多了个记忆数组(称为DP数组)// 逆序推导void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; for( int i= N-1 ; i &gt;= 0 ; i--)&#123; for( int j=0;j&lt;= W ; j++)&#123; if( j &lt; wv[i].first ) dp[i][j] = dp[i+1][j]; else dp[i][j] = max( dp[i+1][j] , dp[i+1][j - wv[i].first] + wv[i].second); &#125; &#125; cout &lt;&lt; dp[0][W] &lt;&lt;endl;&#125;// 顺序推导void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; for( int i= 0 ; i &lt; N ; i++)&#123; for( int j=0;j&lt;= W ; j++)&#123; if( j &lt; wv[i].first ) dp[i+1][j] = dp[i][j]; else dp[i+1][j] = max( dp[i][j] , dp[i][j - wv[i].first] + wv[i].second); // 推导式也变了,下一行的依据上一行写成dp[i+1][j] = ... &#125; &#125; cout &lt;&lt; dp[N][W] &lt;&lt;endl; // 输出的结果变了&#125;int main()&#123; solve(); return 0;&#125; ▲注意，边界一定要注意处理。 这题由于边界全为0，而全局数组初始化默认是0，所以不需要处理，否则得像 国王和金矿提供的题解一样书写。 最长公共子序列问题 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* LCS */int dp[maxn+1][maxn+1];void solve()&#123; int m,n; cin &gt;&gt; n &gt;&gt; m; string sn,sm; cin &gt;&gt; sn &gt;&gt; sm; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if( sn[i] == sm[j] ) dp[i+1][j+1] = dp[i][j] + 1; // p[i+1][j+1] = max(dp[i][j] + 1 , max(dp[i+1][j] , dp[i][j+1]));化简而来 else dp[i+1][j+1] = max(dp[i][j+1] , dp[i+1][j] ); &#125; &#125; cout &lt;&lt; dp[n][m] &lt;&lt; endl;&#125;int main()&#123; solve(); return 0;&#125; 完全背包问题 多重部分和","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"DP","slug":"DP","permalink":"https://nymrli.top/tags/DP/"}]},{"title":"ACM_贪心专题","slug":"ACM-贪心专题","date":"2019-02-01T12:17:50.000Z","updated":"2019-09-15T08:07:30.917Z","comments":true,"path":"2019/02/01/ACM-贪心专题/","link":"","permalink":"https://nymrli.top/2019/02/01/ACM-贪心专题/","excerpt":"","text":"贪心专题 1.活动安排 有若干个活动，第i个开始时间和结束时间是[Si,fi)，只有一个教室，活动之间不能交叠，求最多安排多少个活动？ Input 123第一行一个正整数n (n &lt;= 10000)代表活动的个数。第二行到第(n + 1)行包含n个开始时间和结束时间。开始时间严格小于结束时间，并且时间都是非负整数，小于1000000000 Output 1一行包含一个整数表示活动个数。 Input示例 123431 23 42 9 Output示例 12 博主提供: 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e4+5;struct node&#123; int s,e; //start , end &#125; a[maxn];//由于使用结构体,所以需要自定义cmp函数bool cmp(node x,node y)&#123; if(x.e&lt;y.e) return true; else if(x.e==y.e&amp;&amp;x.s&gt;y.s) return true; return false;&#125;int main()&#123; int n,i,j,ans,end; cin&gt;&gt;n; for(i = 0;i&lt;n;i++) cin&gt;&gt;a[i].s&gt;&gt;a[i].e; sort(a,a+n,cmp); ans = 0; end = -1e9-100; for(i =0;i&lt;n;i++)&#123; if(a[i].s&gt;=end)&#123; // 结束最早的 ans++; end=a[i].e; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 不使用结构体,使用map: 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1e4 +5;int main()&#123; int N; while(scanf(\"%d\",&amp;N) == 1)&#123; pair&lt;int,int&gt; itv[maxn]; for(int i = 0 ; i&lt;N; i++) scanf(\"%d%d\",&amp;itv[i].second , &amp;itv[i].first); sort( itv , itv + N); int ans = 0 ; int t = 0; for( int i =0 ; i&lt; N ; i++)&#123; if ( t &lt; itv[i].second )&#123; ans ++; t = itv[i].first; &#125; &#125; printf(\"%d\",ans); &#125; return 0;&#125; HUD OJ 2037今年暑假不AC 感觉像是板子题，都是时间规划类，需要最多目标的题目。但是在第15行时，必须写&lt;=,否则WA. &lt;= 的结果是 5 ; &lt; 的结果是 3 经过与上题的对比发现，主要的区别在于这句话 ：上题规定 开始时间严格小于结束时间，并且时间都是非负整数，小于1000000000 ，而这题 开始时间是可以等于结束时间的 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1e4+ 5;pair&lt;int,int&gt; node[maxn];int main()&#123; int N; while( cin &gt;&gt; N)&#123; if ( !N ) break; for(int i=0;i&lt;N;i++) cin &gt;&gt; node[i].second &gt;&gt; node[i].first ; sort(node,node+N); int ans =0 , endt =0 ; for( int i=0 ;i&lt;N;i ++)&#123; if( endt &lt;= node[i].second )&#123; ans ++ ; endt = node[i].first; &#125; &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125; 字典序比较 123456789101112131415161718192021222324252627282930313233include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;char s[maxn];void solve(int n)&#123; int a = 0 , b = n-1; while( a &lt;= b)&#123; bool left = false; for(int i = 0 ; a+i &lt;=b ; i++)&#123; if( s[a+i] &lt; s[b-i] )&#123; left = true; break; &#125;else if (s[a+i] &gt; s[b-i])&#123; left = false; break; &#125;else continue; &#125; if( left ) putchar(s[a++]); else putchar(s[b--]); &#125; putchar('\\n');&#125;int main()&#123; int N; scanf(\"%d\",&amp;N); scanf(\"%s\",s); solve(N); return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"贪心","slug":"贪心","permalink":"https://nymrli.top/tags/贪心/"}]},{"title":"学习nginx配置","slug":"学习nginx配置","date":"2019-01-24T08:45:40.000Z","updated":"2022-02-27T06:40:03.538Z","comments":true,"path":"2019/01/24/学习nginx配置/","link":"","permalink":"https://nymrli.top/2019/01/24/学习nginx配置/","excerpt":"","text":"nginx配置 多台虚拟主机: 1.分配IP地址 2.新建、编写usr/local/nginx的conf配置文件 12345678910111213http&#123; sever&#123; listen 192.168.1.17:80; //监听 (IP地址:) 端口 server_name 192.168.1.17; // 域名或者ip access_log logs/server1.access.log conbined;//指定位置+使用日志文件默认格式 location / &#123; index index.html index.htm; //index表示意义(关键字),左边优先级高.指定的首页 root html/ss2; //虚拟主机目录(网站目录)==&gt;ss2下的所以html文件都可以通过192.168.1.17/xxx访问 &#125; &#125;&#125; 3.编写目录下的首页index.html文件 4.运行nginx usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/xnzj.conf ▲在根目录下可以直接通过路径访问,如根目录下只有index文件,而配置中设置的是index index.html此时没有找到index.html后就会显示403错误,但是可以通过192.168.1.17==&gt;192.168.1.17/index添加路径的方法来加载index界面 其他配置 缓存 12345678910server&#123; listen xxx; server_name yyy; location ~ .*\\.(jpg|png|)$&#123; expires 30d; &#125; location ~ .*\\.(css|js|)$&#123; expires 1h; &#125;&#125; 自动列目录 12345678910[/ect/nginx/nginx.conf]server&#123; .. location / &#123; root html; index index.html index.hml; autoindex on; #▲ &#125; &#125; 命令解释 server_name server_name 为虚拟服务器的识别路径。因此不同的域名会通过将请求头中的HOST字段与虚拟主机设置的URI进行匹配，从而匹配到特定的server块，将请求转发到对应的应用服务器中去。 from : https://blog.csdn.net/Cheng_Kohui/article/details/82930464 server_name与host匹配优先级如下： 完全匹配 通配符在前的，如*.test.com 通配符*在后的，如www.test.* 正则匹配，如~^.www.test.com$ location location是Nginx中的块级指令(block directive),，location指令的功能是用来匹配不同的url请求，进而对请求做 开始之前先明确一些约定，我们输入的网址叫做请求URI，nginx用请求URI与location中配置的URI做匹配。不同的处理和响应。 匹配顺序 = 表示精确匹配。只有请求的url路径与后面的字符串完全相等时，才会命中。 ^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找。 ~ 表示该规则是使用正则定义的，区分大小写。 ~* 表示该规则是使用正则定义的，不区分大小写。 注意的是，nginx的匹配优先顺序按照上面的顺序进行优先匹配，而且注意的是一旦某一个匹配命中直接退出，不再进行往下的匹配 剩下的普通匹配会按照最长匹配长度优先级来匹配，就是谁匹配的越多就用谁。 try_files详解 nginx中http_core核心模块所带的指令，主要是能替代一些rewrite的指令，提高解析效率 格式1：try_files file ... uri; 格式2: try_files file ... file = ReturnCode; 关键点1：按指定的file顺序查找存在的文件，并使用第一个找到的文件进行请求处理 关键点2：查找路径是按照给定的root或alias为根路径来查找的 关键点3：如果给出的file都没有匹配到，则重新请求最后一个参数给定的uri，就是新的location匹配 关键点4：如果是格式2，如果最后一个参数是 = 404，若给出的file都没有匹配到，则最后返回ReturnCode(如404)的响应码 举例说明 12345678location /images/ &#123; root /opt/html/; try_files $uri $uri/ /images/default.gif; &#125;# 比如 请求 127.0.0.1/images/test.gif 会依次查找 1.文件/opt/html/images/test.gif 2.文件夹 /opt/html/images/test.gif/下的index文件 3. 请求127.0.0.1/images/default.gif# 4.其他注意事项#1.try-files 如果不写上 $uri/，当直接访问一个目录路径时，并不会去匹配目录下的索引页 即 访问127.0.0.1/images/ 不会去访问 127.0.0.1/images/index.html from： https://www.cnblogs.com/jedi1995/p/10900224.html 例子2： 因为不可能每一个项目开启一个域名，仅仅指向通过增加路径来划分多个网站，比如： www.taobao.com/tmall/login访问天猫的登录页面 www.taobao.com/alipay/login访问支付宝的登录页面 123456789server &#123; listen 80; server_name taobao.com; index index.html index.htm; # 通过正则来匹配捕获 [tmall|alipay]中间的这个路径 location ~ ^/([^\\/]+)/(.*)$ &#123; try_files $uri $uri/ /$1/dist/index.html =404; &#125;&#125; rewrite 用法 用rewrite去除URL中的特定参数。 日常服务中经常会用Nginx做一层代理转发，把Nginx当做前置机，这里的rewrite 就是为了去除URL中的/apis,因为实际的后端api中是没有这个参数的，但是为了做到在Nginx转发请求，前端需要加上这个参数，以便于区别开请求前端页面还是后端接口 123456789101112131415161718192021server &#123; # 对外暴露 80 端口 listen 80; server_name 192.168.10.231; # 后端API地址暴露为：http://192.168.10.231/apis # 后端服务实际运行的地址和端口为: http://127.0.0.1:8000 location /apis &#123; proxy_pass http://127.0.0.1:8000/; proxy_pass_request_headers on; # 重写URL 去除apis rewrite \"^/apis/(.*)$\" /$1 break; # \"^/api/(.)$\": 匹配路径的正则表达式，用了分组语法就是*(.)**，把/api/以后的所有部分当做1组； # /$1：重写的目标路径，这里用$1引用前面正则表达式匹配到的分组（组编号从1开始，也就是api），即/api/后面的所有。这样新的路径就是除去/api/以外的所有，就达到了去除/api前缀的目的 # break：指令。常用的有2个，分别是：last、break； # last: 重写路径结束后，将得到的路径重新进行一次路径匹配； # break: 重写路径结束后，不再重新匹配路径。 &#125;&#125; 比如前端的请求地址是 1http://192.168.10.231/apis/user 那么实际上经过Nginx转发后请求的地址是 1http://127.0.0.1:8000/user index配置 在前后端分离的基础上，通过Nginx配置，指定网站初始页。 格式: index index.htm ... file3 /index.html 如果包括多个文件，Nginx会根据文件的枚举顺序来检查，直到查找的文件存在； 文件可以是相对路径也可以是绝对路径，绝对路径需要放在最后； 文件可以使用变量$来命名；index index.$geo.html index.0.html /index.html; 如果文件存在，则使用文件作为路径，发起内部重定向。直观上看上去就像再一次从客户端发起请求，Nginx再一次搜索location一样。 既然是内部重定向，域名+端口不发生变化，所以只会在同一个server下搜索。 同样，如果内部重定向发生在proxy_pass反向代理后，那么重定向只会发生在代理配置中的同一个server。 实例 12345678910111213server &#123; listen 80; server_name example.org www.example.org; location / &#123; root /data/www; index index.html index.php; &#125; location ~ \\.php$ &#123; root /data/www/test; &#125;&#125; 上面的例子中，如果你使用example.org或www.example.org直接发起请求，那么首先会访问到“/”的location，结合root与index指令，会先判断/data/www/index.html是否存在，如果不，则接着查看 /data/www/index.php ，如果存在，则使用/index.php发起内部重定向，就像从客户端再一次发起请求一样，Nginx会再一次搜索location，毫无疑问匹配到第二个~ .php$，从而访问到/data/www/test/index.php。 More: 前端到底用nginx来做啥 uwsgi模块使用 安装 source activate# 开启虚拟开发环境模式 pip install uwsgi # 安装uwsgi 配置 uwsgi配置文件支持很多格式，我采用.ini格式，命名为uconfig.ini具体内容如下： 启动uwsgi , 命令输入uwsgi uconfig.ini 外部访问测试 此时在外部访问 公网IP：5000就可以访问了 123456789101112131415[uwsgi]# 外部访问地址，可以指定多种协议，现在用http便于调试，之后用sockethttp = 0.0.0.0:5000# 指向项目目录chdir = /home/pythonproject/my_flask/py3env/myblog/# flask启动程序文件wsgi-file = manage.py# flask在manage.py文件中的app名callable = app #很多人习惯将Flask应用对象取名为”app”，但是WSGI标准是”application”。uWSGI提供了一个功能，可以指定应用对象，方法就是在配置文件中加上”callable”项：# 处理器数processes = 4# 线程数threads = 2#状态检测地址stats = 127.0.0.1:9191 1234location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:3031;&#125; 这段配置表明Nginx会将收到的所有请求都转发到”127.0.0.1:3031″端口上，即uWSGI服务器上。现在让我们重启Nginx， 附：使用记录 单server基本配置 123456789server&#123; listen 80; # 侦听端口 weight=1; server_name localhost; # 服务器名称 weight=10; location / &#123; # 侦听URL路径 root /usr/share/nginx/html; # 工程根目录 index index-test.html index.htm; # 入口文件 &#125;&#125; 反向代理： 1234567891011121314151617upstream group1&#123; server 49.235.118.244:7070; # 这边的IP地址不能写127.0.0.1实测 server 49.235.118.244:7069; # 且云服务器需要在防火墙将这个端口开放，否则无法反向代理&#125;server &#123; listen 80; server_name localhost; location /demo1 &#123; # 在该位置配置反向代理，将ip/demo1请求拦截，发送给8080端口，如果不是本机请使用公网ip proxy_pass http://group1/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; index index.html index.htm; &#125;&#125;","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"nginx","slug":"nginx","permalink":"https://nymrli.top/tags/nginx/"}]},{"title":"C++日期操作","slug":"C++日期操作","date":"2019-01-24T07:00:56.000Z","updated":"2019-09-15T08:07:30.922Z","comments":true,"path":"2019/01/24/C++日期操作/","link":"","permalink":"https://nymrli.top/2019/01/24/C++日期操作/","excerpt":"","text":"C++日期操作 12345678910111213int main( )&#123; time_t now = time(0); // 基于当前系统的当前日期/时间 的时间戳 cout &lt;&lt; \"1970 到目前经过秒数:\" &lt;&lt; now &lt;&lt; endl; tm *ltm = localtime(&amp;now);// 将时间戳转换为结构体,再输出 tm 结构的各个组成部分 cout &lt;&lt; \"年: \"&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl; cout &lt;&lt; \"月: \"&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl; cout &lt;&lt; \"日: \"&lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl; cout &lt;&lt; \"时间: \"&lt;&lt; ltm-&gt;tm_hour &lt;&lt; \":\"; cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; \":\"; cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl; getchar();&#125; time_t结构体 12345678910111213141516171819202122232425262728#include &lt;time.h&gt; #include &lt;stdio.h&gt; int main( void ) &#123; time_t t = time(0); char tmp[64]; strftime( tmp, sizeof(tmp), \"%Y/%m/%d %X %A 本年第%j天 %z\",localtime(&amp;t) ); puts( tmp ); return 0; &#125; // ---第二种#include &lt;string&gt;#include &lt;time.h&gt;using namespace std;string getTime()&#123; time_t timep; time (&amp;timep); char tmp[64]; strftime(tmp, sizeof(tmp), \"%Y-%m-%d %H:%M:%S\",localtime(&amp;timep) ); return tmp;&#125;int main()&#123; string time = getTime(); cout &lt;&lt; time &lt;&lt; endl; return 0;&#125; size_t strftime(char *strDest, size_t maxsize, const char *format, const struct tm *timeptr); 根据格式字符串生成字符串。 struct tm *localtime(const time_t *timer); 取得当地时间，localtime获取的结果由结构tm返回 返回的字符串可以依下列的格式而定： %a 星期几的缩写。Eg:Tue %A 星期几的全名。 Eg: Tuesday %b 月份名称的缩写。 %B 月份名称的全名。 %c 本地端日期时间较佳表示字符串。 %d 用数字表示本月的第几天 (范围为 00 至 31)。日期 %H 用 24 小时制数字表示小时数 (范围为 00 至 23)。 %I 用 12 小时制数字表示小时数 (范围为 01 至 12)。 %j 以数字表示当年度的第几天 (范围为 001 至 366)。 %m 月份的数字 (范围由 1 至 12)。 %M 分钟。 %p 以 ‘‘AM’’ 或 ‘‘PM’’ 表示本地端时间。 %S 秒数。 %U 数字表示为本年度的第几周，第一个星期由第一个周日开始。 %W 数字表示为本年度的第几周，第一个星期由第一个周一开始。 %w 用数字表示本周的第几天 ( 0 为周日)。 %x 不含时间的日期表示法。 %X 不含日期的时间表示法。 Eg: 15:26:30 %y 二位数字表示年份 (范围由 00 至 99)。 %Y 完整的年份数字表示，即四位数。 Eg:2008 %Z(%z) 时区或名称缩写。Eg:中国标准时间 %% % 字符。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"程序开发经验","slug":"程序开发经验","permalink":"https://nymrli.top/tags/程序开发经验/"}]},{"title":"Shell代码编写记录","slug":"Shell代码编写记录","date":"2019-01-23T05:48:59.000Z","updated":"2021-11-03T13:05:56.898Z","comments":true,"path":"2019/01/23/Shell代码编写记录/","link":"","permalink":"https://nymrli.top/2019/01/23/Shell代码编写记录/","excerpt":"","text":"随机选取端口 12345# 随机设置代理和监控端口，允许每台机器有多个代理# 注意:$RANDOM返回一个从0到32767的值，端口&lt;= 1024保留给root用户# TODO:不是随机选择端口，而是绑定到可用端口export SPARK_SERVERPORT=$[$RANDOM + 1025]export SPARK_AGENTPORT=$[$RANDOM + 1025] 后台执行,获取其PID 12345678rcssserver3d --agent-port $SPARK_AGENTPORT --server-port $SPARK_SERVERPORT &amp;# 将rcssserver3d后台运行在随机获得的端口上PID=$! # 获得进程号,最后用进程PID关闭rcssserver3d# ---类比学习---python ./test1.py &amp;PID=$!echo $PID 组合命令 12345678910sleep 5 #延迟时间DIR_SCRIPT=\"$( cd \"$( dirname \"$0\" )\" &amp;&amp; pwd )\" # 先运行 cd切换目录,再将当前工作目录赋值给 DIR_SCRIPTTYPE=$1 #TYPE为读取第二个参数DIR_PARAMS=\"$( cd \"$( dirname \"$2\" )\" &amp;&amp; pwd )\"DIR_OUTPUT=\"$( cd \"$( dirname \"$3\" )\" &amp;&amp; pwd )\"PARAMS_FILE=$DIR_PARAMS/$(basename $2)# basename返回文件名OUTPUT_FILE=$DIR_OUTPUT/$(basename $3) 输出判断 1234567891011121314while [ ! -f $OUTPUT_FILE ] &amp;&amp; [ $total_wait_time -lt $maxWaitTimeSecs ]do sleep 1 total_wait_time=`expr $total_wait_time + 1` # expr 表示后面是运算表达式done # -f 是正常文件 # Shell 中 ()用[]代替if [ ! -f $OUTPUT_FILE ]then echo \"Timed out while waiting for script to complete, current wait time is $total_wait_time seconds.\"else echo \"Completed with a wait time of $total_wait_time seconds.\"fi 关闭进程 12345echo \"Killing Simulator\"kill -s 2 $PID# kill -s 信号名 进程号echo \"Killing Agent\"kill -s 2 $AGENTPID 格式：kill &lt;pid&gt; 格式：kill -TERM &lt;pid&gt; 发送SIGTERM旌旗灯号到指定过程，若是过程没有捕获该旌旗灯号，则过程终止（If no signal is specified， the TERM signal is sent. The TERM signal will kill processes which do not catch this signal.） 格式：kill -l 列出所有旌旗灯号名称（Print a list of signal names. These are found in /usr/include/linux/signal.h）。只有第9种旌旗灯号（SIGKILL）才可以无前提终止过程，其他旌旗灯号过程都有权力忽视。下面是常用的旌旗灯号： 旌旗灯号名称 HUP 1 终端断线 INT 2 中断（同 Ctrl + C） QUIT 3 退出（同 Ctrl + ） TERM 15 终止 KILL 9 强迫终止 CONT 18 持续（与STOP相反， fg/bg号令） STOP 19 暂停（同 Ctrl + Z） Bash Shell 脚本获取进程 pid 第一种方法: ps -ef | grep &quot;Processname&quot; | grep -v grep | awk '{print $2}' 第二种 最简单的方法是使用 pgrep： pgrep -f name 根据PID关闭进程 kill -9 PID 根据进程名关闭进程 法一: 1kill -f name1 法二: 如果是可执行程序的话，可以直接使用 pidof 1pidof name 关闭Roboviz.sh里java进程的方法: grep -v ：显示不包含匹配文本的所有行(反向查找)。比如 grep -v grep 就是查找不含有 grep 字段的行 写法一:kill -9 $(ps x | grep Roboviz.jar | grep -v grep | awk '{print $1}') 写法二: ps -ef | grep Roboviz.jar | grep -v grep | awk '{print $2}' | xargs kill -9 shell脚本中的冒号作用 作用一: 占位符&lt;==&gt;pass 12345if egrep '.*vmlinuz-2.6.32-220.23.1.lvs.el6.*nohz=off' /boot/grub/grub.conf ;then :else sed -i -r 's/(.*vmlinuz-2.6.32-220.23.1.lvs.el6.*)/\\1 nohz=off/' /boot/grub/grub.conffi 作用二: 分隔符 冒号(:)常用来做路径的分隔符（PATH），数据字段的分隔符（/etc/passwd） 宏 特殊变量: 当前脚本PID 当前脚本PID 当前脚本PID $? 上句执行结果 command -v用法 在Linux中，command -v 可以判断一个命令是否支持，如果一个脚本需要，或者还要家if判断，则示例如下： 123456789101112# 判断是否存在dockerif command -v docker &gt;/dev/null 2&gt;&amp;1;then echo \"yes\"else echo \"no\"fi# 实际运用：如果不存在unzip则报错if ! command -v unzip &gt;/dev/null; then echo \"Error: unzip is required to install ipgw.\" 1&gt;&amp;2 exit 1fi","categories":[],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://nymrli.top/tags/Shell/"}]},{"title":"Matlab基础教程","slug":"Matlab基础教程","date":"2019-01-23T05:43:34.000Z","updated":"2019-09-15T08:07:30.963Z","comments":true,"path":"2019/01/23/Matlab基础教程/","link":"","permalink":"https://nymrli.top/2019/01/23/Matlab基础教程/","excerpt":"","text":"Matlab学习 1234A = [1 3 5];max(A)ans = 5 如果存在多个输入参数，请使用逗号加以分隔： 12345B = [10 6 4];max(A,B)ans = 10 6 5%A中列元素与B中列元素一一比较. clc 函数清除命令行窗口。 函数 123disp(&apos;hello world&apos;)hello world要调用不需要任何输入且不会返回任何输出的函数，请只键入函数名称： 二维绘图 r--' 字符串为线条设定。每个设定可包含表示线条颜色、样式和标记的字符。标记是在绘制的每个数据点上显示的符号，例如，+、o 或 *。例如，'g:*' 请求绘制使用 * 标记的绿色点线。 请注意，为第一幅绘图定义的标题和标签不再被用于当前的图窗口中。默认情况下，每次调用绘图函数、重置坐标轴及其他元素以准备新绘图时，MATLAB® 都会清除图形。 要将绘图添加到现有图形中，请使用 hold。 1234567x = 0:pi/100:2*pi;y = sin(x);plot(x,y)hold ony2 = cos(x);plot(x,y2,&apos;:&apos;)legend(&apos;sin&apos;,&apos;cos&apos;) 三维绘图 123[X,Y] = meshgrid(-2:.2:2);Z = X .* exp(-X.^2 - Y.^2);surf(X,Y,Z) surf 函数及其伴随函数 mesh 以三维形式显示曲面图。surf 使用颜色显示曲面图的连接线和面。mesh 生成仅以颜色标记连接定义点的线条的线框曲面图。（surf填充-sruface） M文件 脚本文件 函数文件 1234567891011脚本文件 1.多条命令的综合体 2.没有输入、输出变量 3.使用MATLAB基本工作空间 4.没有函数声明行 函数文件1.常用于扩充MATLAB函数库2.可以包含输入、输出变量3.运算中生成的所有变量都存放在函数工作空间4.包含函数声明行 函数名为mymax，文件名为mymax.m（必须相同）。它需要五个数字作为参数并返回最大的数字。 1234567891011121314151617创建函数文件，名为mymax.m 并输入下面的代码： function max = mymax(n1, n2, n3, n4, n5) %This function calculates the maximum of the % five numbers given as input max = n1; if(n2 &gt; max) max = n2; end if(n3 &gt; max) max = n3; end if(n4 &gt; max) max = n4; end if(n5 &gt; max) max = n5; end 符号变量与符号表达式 x y; %定义x,y为符号变量>>z123456需要用syms或sym定义，例如&gt;&gt;syms x y; %定义x,y为符号变量&gt;&gt;z=x^2+y^2 ％定义z为含有x与y的符号表达式也可以这样定义z， &gt;&gt;z=sym(‘x^2+y^2’) %与上面等价 关于符号表达式的基本命令 命令 含义 pretty(s) 将s显示为数学书写形式 symsum(s,x,a,b) 对s中的x从a到b求和 findsym(s) 给出s中所有的符号变量 findsym(s,n) 给出s中离x最近的n个符号变量，n大于s中符号变量个数时则按字母表顺序返回符号变量 subs(s,a,b) 将s中的a置换成b double(s) 将s转换成数值形式 str2num(s) 字符变量转换为数值变量 num2str(s) 数值变量转换为字符变量 sym(a) 将a转换为符号变量 digits(d) 给出有效数字个数为d的近似值 vpa(s,d) 计算s在精度为d位有效数字的解 eval(s) 执行符号表达式s 命 令 含 义 collect(s) 合并s中的同类项 compose(f,g,x,y) 计算复合函数f(g(y)),x,y分别为f,g的自变量 g＝finverse(f) 计算f(x)的反函数，g的自变量仍为x expand(s) 展开表达式s factor(s) 因式分解s [N,D]=numden(s) 通分s中各式，其和的分子为N，分母为D simplify(s) 对s进行综合化简 simple(s) 给出s的所有最简式 微积分 命 令 含 义 limit(f,x,a) 计算函数f(x)当x-&gt;a时的极限 limit(f,x,a,’right’) 计算函数f(x)当x-&gt;a+时的右极限 limit(f,x,a,’left’) 计算函数f(x)当x-&gt;a-时的左极限 x=fminbnd(f,a,b) 计算函数f(x)在区间[a,b]上的最小值点 [x,fmin]=fminbnd(f,a,b) 计算函数f(x)在区间[a,b]上的最小值点及最小值fmin diff(f,’x’,n) 计算函数f(x)对变量x的n阶导数，’x’可省 int(f,x) 计算函数f(x)的不定积分，积分变量为x int(f,x,a,b) 计算函数f(x)在[a,b]上的定积分(符号) quad(f,a,b) 计算函数f(x)在[a,b]上的定积分值 taylor(f) 计算函数f(x)在x=0处的5阶泰勒展开式 taylor(f,n,x,a) 计算函数f(x)在x=a处的n-1阶泰勒展开式 ▲需要注意的是，在进行这些计算前必须申明是符号计算，即要加上syms x y;等语句 基本的绘图步骤 步 骤 典 型 代 码 1. 准备绘图数据 x = 0:0.2:12; y1 = bessel(1,x); 2. 选择一个窗口并在窗口中给图形定位 figure(1) ，subplot(2,2,1) 3. 调用基本的绘图函数 h = plot(x,y1,x,y2,x,y3); 4. 选择线型和标记特性 set(h,‘LineWidth’,2,{‘LineStyle’},{’–’;’:’;’-.’}) 5. 设置坐标轴的极限值、标记符号和网格线 axis([0 12 -0.5 1]) 6. 使用坐标轴标签、图例和文本对图形进行注释 xlabel(‘Time’)ylabel(‘Amplitude’) 7. 输出图形 print -depsc -tiff -r200 myplot # 二维曲线图 1234例：&gt;&gt; x= 0:0.01:10;&gt;&gt; y=sin(x);&gt;&gt; plot(x,y) # 函数绘图 1234fplot(‘function’,范围)，例如 fplot(&apos;sin(x)&apos;,[0,2*pi],&apos;r&apos;)后面选项与plot一致。再如 fplot(‘[sin(x),cos(x)]’,[0,2*pi])同时画出两个函数图形 #符号函数绘图 1格式ezplot(f,[a,b]) 画出符号函数f在[a,b]上的图形 # 极坐标图形 1234MATLAB提供了polar函数来在极坐标下绘制图形 ：&gt;&gt; x= 0:0.01:10;&gt;&gt; y=1+cos(x);&gt;&gt; polar(x,y,&apos;rs&apos;) 图形控制与修饰 命令 含义 axis auto 坐标轴缺省设置 axis equal 纵、横轴采用相等单位长度 axis image 纵、横轴采用相等单位长度，且坐标框紧贴数据范围 axis([x1 x2 y1 y2]) 设定坐标范围 grid on 画出网格线 grid off 不画网格线 hold on 使以后图形画在当前图形上 hold off 使以后图形不画在当前图形上 命令 含义 title(x,y,‘name’) 在(x,y)处标示图名 xlabel(‘xtext’) 横坐标轴名 ylabel(‘ytext’) 纵坐标轴名 legend(‘first’,’second’,n) 对一个坐标系中的两幅图作出图例注解 figure 另开图形窗口 subplot(m,n,k) m×n幅子图的第k幅称为当前图 多个图形的绘制方法 1234subplot函数 可以实现多个图形的绘制：&gt;&gt; x = 0:.1:20;&gt;&gt; subplot(2,2,1)&gt;&gt; plot(x,sin(x)); # 三维网线图 12345671.mesh(X,Y,Z) ，例 x=-5:0.2:5;y=x; [X Y]=meshgrid(x,y); %生成格点矩阵 Z=sin(sqrt(X.^2+Y.^2)); mesh(X,Y,Z) 2. ezmesh(‘f’,‘g’,‘h’,[u1,u2,v1,v2] )，例 ezmesh(&apos;cos(u)*cos(v)&apos;,&apos;sin(u)*cos(v)&apos;,&apos;sin(v)&apos;,[0,2*pi,-pi,pi]); axis equal 数值变量与符号变量 数值变量的常用函数，一般都可以直接用在符号变量上，比如三角函数，这些都是可以通用的，而且函数的含义也完全一样。 但偏偏有些函数非常蛋疼，对符号变量与数值变量都可以进行操作，但操作的含义完全不同，比如diff，diff对于一个数值变量的运算结果是差分，而对于一个符号变量的运算结果则是求导 。 另外也存在很多函数只能对数值变量操作，比如离散傅里叶变换fft。还有很多函数只能对符号变量操作，比如泰勒展开taylor。因此在matlab使用中，一定要区分变量的类型，其实真的用起来也好区分，因为完成特定的计算任务，要么全部用数值，要么全部用符号，这也符合一般处理问题的原则。 4.字符串的常用函数 matlab中字符串的常用算符就更少了，但都非常有用，这里介绍几个： 1）num2str和str2num：可以实现数值变量和字符串变量的转换，比如 a=1 b=num2str(1)复制代码运算结果显示a是一个数值变量，b是一个字符串变量，函数名中的2就是英文中to的意思，也就是把num数值类型转化成str字符类型。str2num就是这个函数的反函数，这两个命令结合，可以实现特定的功能，比如提取一个数字的最高位： a=123456 b=num2str(a) c=b(1) d=str2num© 2.3for循环 ​ for循环的语法是： 12345678910for 数值变量=向量 执行语句end---其含义是，数值变量会取向量中的每一个值，然后执行语句，在执行语句中，数值变量是一个1*1的矩阵。比如for a=[0 1 3]---则会让a=0，执行语句，然后a=1，执行语句，最后a=3，执行语句。这里容易和赋值语句混淆，因为a=[0 1 3]是一个数值变量赋值，赋值后a是个向量，但加上了for后，a是1*1矩阵。另外，在数值变量赋值那段，我们说过有一种常用的赋值方法是&quot;a=初始值:步长:终值&quot;，其结果是把a赋值成一个向量，因此这也广泛用于for语句中 for a=初始值:步长:终值 ---则在执行语句中，a是一个遍历初值到终值的1*1矩阵。","categories":[],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://nymrli.top/tags/Matlab/"}]},{"title":"中文Bois模式界面","slug":"中文Bois模式界面","date":"2019-01-23T05:40:19.000Z","updated":"2019-09-15T08:07:31.020Z","comments":true,"path":"2019/01/23/中文Bois模式界面/","link":"","permalink":"https://nymrli.top/2019/01/23/中文Bois模式界面/","excerpt":"","text":"暗夜精灵的Bois界面。觉得还挺友好的。","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"Chrome开发者工具Network","slug":"Chrome开发者工具Network","date":"2019-01-23T05:38:12.000Z","updated":"2019-09-15T08:07:30.926Z","comments":true,"path":"2019/01/23/Chrome开发者工具Network/","link":"","permalink":"https://nymrli.top/2019/01/23/Chrome开发者工具Network/","excerpt":"","text":"Chrome开发者工具中Network功能介绍 第一列Name:请求的名称，一般会将URL的最后一 部分内容当作名称。 第二列Status: 响应的状态码，这里显示为200，代表响应是正常的。通过状态码，我们可 以判断发送了请求之后是否得到了正常的响应。 第三列Type: 请求的文档类型。这里为document, 代表我们这次请求的是一个HTML文档,内容就是一些HTML代码。 第四列initiator: 请求源。用来标记请求是由哪个对象或进程发起的。 第五列Size: 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示from cache。 第六列Time:发起请求到获取响应所用的总时间。 第七列Waterfall:网络请求的可视化瀑布流。 响应中分General部分，请求头、响应头： 其中General含： Request URL为请求的URL， Request Method为请求的方法 Status Code为响应状态码， Remote Address为远程服务器的地址和端口 Referrer Policy为Referrer判别策略。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"Charles配置","slug":"Charles配置","date":"2019-01-23T05:32:21.000Z","updated":"2021-10-30T07:51:49.530Z","comments":true,"path":"2019/01/23/Charles配置/","link":"","permalink":"https://nymrli.top/2019/01/23/Charles配置/","excerpt":"","text":"Charles配置 电脑安装 下载SSL证书 设置SSL端口 *为通配IP网址，一般SSL的端口都是443 手机抓包 打开Charles代理 具体配置，电脑端不用做任何配置，但是需要把防火墙关掉（这点很重要）！ charles需要设置下代理端口：进入Proxy，点击Proxy Setting, 端口设置为8888（一般默认为这个） 配置手机SSL证书 然后手机打开浏览器输入chls.pro/ssl下载证书 小米手机安装charles证书 1.使用第三方浏览器下载.pem 格式的文件 （我使用的是QQ浏览器） 2.将这个文件放入小米的 DownLoad 文件夹下 (这步也可以不做，只要在4中的从存储设备安装能找到这个文件就行) 3.将.pem 文件修改为.crt 格式 4.设置—更多设置—系统安全—加密与凭据----从存储设备安装–选择文件，选定该文件 注：本人用的是小米6。 手机设置代理 其中PAC地址打开Cmd，输入ipconfig查看 参考博客: Charles配置 https://blog.csdn.net/liulanghk/article/details/46342205 https://www.jianshu.com/p/7a88617ce80b Charles使用 http://www.bubuko.com/infodetail-2252870.html Fiddler抓包 打开 Fiddler，点击工具栏中的Tools—&gt;Options，点击Actions,选择最后一项，Reset All certificates,然后关闭 继续点击工具栏中的Tools—&gt;Options，把Conections和https菜单页中的多选框都勾上 点击 Actions , 点击第二项：Export Root Certificate to Desktop，这时候 桌面 上会出现证书 FiddlerRoot.cer 文件，点击OK设置成功，关闭 Fiddler。 到桌面上去找到 FiddlerRoot.cer 文件，双击文件，点 下一步----&gt;下一步 …不用管其他设置 ，直到安装好。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"Python中对时间戳、时间的处理","slug":"Python中对时间戳、时间的处理","date":"2019-01-23T02:17:34.000Z","updated":"2019-09-15T08:07:30.981Z","comments":true,"path":"2019/01/23/Python中对时间戳、时间的处理/","link":"","permalink":"https://nymrli.top/2019/01/23/Python中对时间戳、时间的处理/","excerpt":"","text":"Python中对时间戳、时间的处理 time模块 获得时间戳 123timestmamp = time.time()&gt;&gt;&gt; # 1548208280.4581678 将时间戳转换成时间 12345678import timetimestamp = 1462451334timeArr = time.localtime(timestamp) # 转换成时间数组print(timeArr)# &gt;&gt;&gt;time.struct_time(tm_year=2016, tm_mon=5, tm_mday=5, tm_hour=20, tm_min=28, tm_sec=54, tm_wday=3, tm_yday=126, tm_isdst=0)dt = time.strftime(\"%Y-%m-%d %H:%M:%S\",timeArr) # 指定转换成时间格式print(dt) 将时间转换成时间戳 利用strptime()函数将时间转换成时间数组 利用mktime()函数将时间数组转换成时间戳 123456import timedt = \"2016-05-05 20:28:54\"timeArray = time.strptime(dt, \"%Y-%m-%d %H:%M:%S\") #转换成时间数组timestamp = time.mktime(timeArray) #转换成时间戳print (timestamp)# &gt;&gt;&gt; 1462451334.0 重新格式化时间 利用strptime()函数将时间转换成时间数组 利用strftime()函数重新格式化时间 1234567import timedt = \"2016-05-05 20:28:54\"timeArray = time.strptime(dt, \"%Y-%m-%d %H:%M:%S\") #转换成时间数组dt_new = time.strftime(\"%Y%m%d-%H:%M:%S\",timeArray) #转换成新的时间格式(20160505-20:28:54)print (dt_new) 按指定的格式获取当前时间 12345678import time#获取当前时间time_now = int(time.time()) time_local = time.localtime(time_now)# 转换成localtimedt = time.strftime(\"%Y-%m-%d %H:%M:%S\",time_local)# 转换成新的时间格式(2016-05-09 18:59:20)print(dt)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"基础网络知识","slug":"基础网络知识","date":"2019-01-22T11:31:47.000Z","updated":"2019-09-15T08:07:31.042Z","comments":true,"path":"2019/01/22/基础网络知识/","link":"","permalink":"https://nymrli.top/2019/01/22/基础网络知识/","excerpt":"","text":"什么是客户端、服务器端? 客户端 : ​ 发送数据、接收返回数据端 服务器: ​ 处理数据端 TCP : 面向连接—&gt; 打电话(相互回复,一来一回) 客户端向服务器端 拨号 , 三次握手 , UDP : 面向无连接 --&gt; 寄快递(寄出去就不管了). 比如 : 直播 UDP四层结构 网络访问层(链路层): 物理连接设备(网线)、MAC地址（物理地址） 互联网层： IP地址（定位设备） 传输层： port (端口号) : 表示通信进程,将数据交给哪个应用处理 应用层： 自己定义的协议（处理字符串消息的方法） port : 知名端口 : 0 - 1023，有指定的应用程序 可自由使用的端口 : 1024 - 65535 ▲广播只能使用UDP，TCP没有广播功能。一般广播只用在局域网内（路由器不转发广播）。 套接字(socket) ： 特殊的设备文件 ， 写网络应用程序的接口，写入后就是发送，接收就是读取。 应该类似于 esp8266吧… Python演示程序 服务器端程序 123456789101112import sockets = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) '''参数说明:AF_INET IPv4STREAM TCPSOCK_DGRAM UDP'''server_addr = ('127.0.0.1',8888) # 本地回环地址 , 端口s.bind(server_addr) # 绑定、传入信息data,cilent_addr = s.recvfrom(1024) # BUF_SIZE指定接收数据长度 , (数据内容,客户端地址)s.sendto(data,cilent_addr) # 给客户端发送数据 客户端程序 1234import sockets = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) server_addr = ('192.168.43.3',8888)s.sendto(b'hello',server_addr) 广播程序 255.255.255.255为广播地址 广播端接收程序 123456789101112import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)PORT = 9999s.bind( ('', PORT) ) # 这边必须是'',不能为自己的IP(否则只接受自己IP的,不接受255.255.255.2555的广播)print('Listening for broadcast at ', s.getsockname())while True: data, address = s.recvfrom(65535) print('Server received from &#123;&#125;:&#123;&#125;'.format(address, data.decode('utf-8'))) 广播发送程序 12345678import socket s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)s.setsockopt(socket.SOL_SOCKET,socket.SO_BROADCAST,1)# 创建套接字,UDP默认没有广播权限PORT = 9999network = '&lt;broadcast&gt;'# &lt;==&gt; network = '255.255.255.255's.sendto(b'hel',(network,PORT)) 拓展 : 大端和小端模式的概念 网络通信时 通常使用大端 Linxu下ifconfig命令: eth0 网卡 wlan0 无线网卡 偶然发现安卓开热点的局域网地址是192.18.x.x，而苹果的热点局域网IP地址是172.20.x.x，于是搜了了解下 192.168网段是一种私有IP地址网段，任何人在私有网络中都可以任意使用这些IP地址，但是如果要连接外网就要使用网络地址转换NAT技术进行转换后才能连接外网； 在宽带路由器上一般默认的内网IP地址为192.168.0或192.168.1网段，它是经过路由器的NAT技术转换为WAN接口的公用IP地址而连接外网的； 这样的私有IP地址除了这个网段外，还有B类网络的172.16-172.31及A类网络的10网段都是私有IP地址。","categories":[],"tags":[{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Jupyter使用","slug":"Jupyter使用","date":"2019-01-21T02:46:56.000Z","updated":"2019-09-15T08:07:30.950Z","comments":true,"path":"2019/01/21/Jupyter使用/","link":"","permalink":"https://nymrli.top/2019/01/21/Jupyter使用/","excerpt":"","text":"Jupyter使用 准备 安装pip install jupyter 运行jupyter notebook 基础概念与操作 Jupyter有三种类型的cells： code cells markdown cells raw cells 常用的是code cells和 markdown cells类型。 Cells状态分为命令模式和编辑模式，Enter进入编辑模式，ESC进入命令模式，命令模式和编辑模式下支持很多操作快捷键，非常好用。 常用命令模式快捷键： y: 单元进入代码状态 m: 转入markdown状态 r：转入raw状态 a: 上方插入新单元 b：下方插入新单元 x：剪切选中单元 c: 复制选中单元 shift-v：粘贴到上方单元 v：粘贴到下方单元 d,d（连续按两次d）:删除选中单元 z：恢复最后删除单元 ctrl+Enter:运行本单元，两种模式都适用 shift+Enter：运行本单元，并跳到下个单元，两种模式都适用 alt+Enter：运行本单元，并在下方插入新单元，两种模式都适用 常用编辑模式快捷键： Tab：代码补齐或缩进 Shift+Tab：调用方法提示，非常有用，在调用包中函数时，对于函数中的使用说明和相关参数配置，按两次shift+Tab可获取详细的方法提示。 Ctrl+]：缩进 Ctrl+[ : 解除缩进 Ctrl+A: 全选 Ctrl+Backspace：删除光标前面本行所有的内容 Ctrl+Delete:删除光标后本行所有的内容 Shift+Home：往前选取本行所有内容 Shift+End：往后选取本行所有内容； 执行当前cell，并自动跳到下一个cell：Shift Enter 执行当前cell，执行后不自动调转到下一个cell：Ctrl-Enter 载入代码 %load /Users/chenqionghe/test.py 插件 jupyter notebook 写代码自动补全 进入命令行环境，有两种方式进入命令行。 方法1：通过anconda navigator界面，选择environments，选择对应环境名，选择open terminal 方法2：直接使用cmd或者terminal等终端进入命令行。激活你想要配置代码补全的环境（如果是默认环境不用激活） 1.安装nbextensions 12$ pip install jupyter_contrib_nbextensions -i https://pypi.mirrors.ustc.edu.cn/simple$ jupyter contrib nbextension install --user 2.安装nbextensions_configurator 12$ pip install --user jupyter_nbextensions_configurator $ jupyter nbextensions_configurator enable --user 效果如图 Jupyter Notebooks：一份全面的初学者实用指南 Tableof Contents(目录索引) 这个功能可以自动找到所有的标题，生成目录。 并且这个目录还是移动的呦，你可以放在侧边栏，也可以拖动到任何你喜欢的地方悬浮起来。 Hinterland(代码补全) Hinterland功能可以让你每敲完一个键，就出现下拉菜单，可以直接选中你需要的词汇。 Snippets Snippets在工具栏里加了一个下拉菜单，可以非常方便的直接插入代码段，完全不用手动敲。 Autopep8 一键美化代码，强迫症的福音。 Qgrid Qgrid也是一个Jupyter的小部件，不过它主要用于数据帧，装上之后，就可以像操作Excel里的筛选功能一样，方便的处理数据。 1234$ pip install qgrid$ jupyter nbextension enable --py --sys-prefix qgrid# only required if you have not enabled the ipywidgets nbextension yet$ jupyter nbextension enable --py --sys-prefix widgetsnbextension 主题设置 安装主题包:pip install --upgrade jupyterthemes 查看可用主题：jt -l Available Themes: chesterish grade3 gruvboxd gruvboxl monokai oceans16 onedork solarizedd solarizedl 比如Chesterish主题： solarizedl主题： 上述图片来自量子位[1] consolamono主题: 命令参数: 修改主题命令$ jt --lineh 140 -f consolamono -tf ptmono -t grade3 -ofs 14 -nfs 14 -tfs 14 -fs 14 -T -N 附录 代码补全,不使用额外插件: 使用jedi 1.打开Anaconda Prompt或者jupyter安装的虚拟环境 输出下行代码生成 .ipython 配置文件 1ipython profile create 在当前用户 ~/.ipython/profile_default/下打开生成的文件,如我的是 C:/Users/mrli/.ipython/profile_default 2.修改ipython_config.py中的配置 123c.Completer.jedi_compute_type_timeout = 400c.Completer.greedy = Truec.Completer.use_jedi = True 3.重启jupyter http://www.eeworld.com.cn/mp/QbitAI/a58625.jspx ↩︎","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"河海大学AI+机器人冬令营(12-26)","slug":"河海大学AI-机器人冬令营","date":"2019-01-19T14:31:19.000Z","updated":"2019-09-15T08:07:31.086Z","comments":true,"path":"2019/01/19/河海大学AI-机器人冬令营/","link":"","permalink":"https://nymrli.top/2019/01/19/河海大学AI-机器人冬令营/","excerpt":"","text":"河海大学AI+机器人冬令营(19-26) The First Day~19 11:50和CXY从学校出发，坐地铁的途中感觉比想象中舒服多了，没有很多挤着急着回家的学生党。 宾馆打卡 13:30到尚客优宾馆，环境挺好。还有个办公桌,很舒服。 在房间里待到了大概3点，人都差不多到齐了以后，河海的负责人张老师带领我们去了河海大学。 校门口打卡 计软院的副院长、该活动的负责人幽默、诙谐地给我讲了讲活动背景、及要求和合作的机器人公司优必选。 下面是机器人表演舞蹈串烧的照片。关节自由多真的很多啊…很多很难的动作~ 介绍环节大约在4点就结束了。之后是在图书馆门口的签名墙上花费了巨大的时间，每个人都单独拍了两次照，说是要给我们留在纪念册上，很期待呢。 100号人拍完照已经是5：30左右了，拿到饭票后，院长就带我们前往了食堂。平常的学生食堂似乎已经关门了，接待我们的是一个据说连河海本校学生也不知道的xx食堂。 食堂打卡 大家围在圆桌上等饭吃，_ 饭终于上来了O(∩_∩)O，两荤一小荤+两素，水果+酸奶的组合已经非常不错了，下午3点才吃午饭的我，表示强行吃完这些后撑得不行。 吃完后，负责人告诉我们可以回去了。找到了南邮的其他人，我们就浩浩荡荡地回宾馆了，河海的新校区很大，给我的感觉跟南理工一样，但南理工由于居民区的存在可能显得更热闹点，放假的河海闲的挺冷清的。天黑的很快，我们开着导航，最终成功回到了宾馆。 19号的活动大致就结束了。 The Second Day~20 冬令营今天算正式开营，7:30要求在宾馆集合。床挺软的，睡得还行，早上却被一个不太好的梦在大约6:50做哟与惊醒，但还是在床上黏到了7：15的闹钟响。起了后以为应该算早的了，但最后在7：31的时候才弄好，到了一楼大厅，发现很多人都已经到了，看来大家的热情还很高涨。老师也很干脆利落，7:33就直接出发去学校了。 7:33出发，到河海的校门口大约在7:40左右。冬青食堂在学校的西北角，要走进去很多，到的时候约为7:50。比规定的时间8:10早到了15分钟，结果我们100号人就在食堂门口等了大约15分钟QAQ。 事实证明应该不需要这么早集合！ 早上是包子+稀饭，配上少许的拌饭菜–咸菜，早餐就算勉强吃完了。 教学楼打卡 早上9:00上课，非常准时。 上午的任务是组装好机器人，是个挺有逼格的机器人。从开箱到拼装，都交给我们完成了。据说这个是卖2W+的教育类机器人，顺丰快递单上表明的价格似乎是20W，运费都要110+。 开箱 组成 终于拼好了 与机器人交互需要连接WIFI和蓝牙，又折腾了好久才终于连上，期间我的同伴还错连了一个女生的机器人，瞎几把按了几个好玩的东西，引得女生大吼：“谁连了我的机器人啊”。 玩了玩几个高难度动作：单手俯卧撑、舞蹈串烧……就11:30了，上午的授课就算结束了。 仍是食堂打卡 水果换成了小橘子，肯定没有香蕉好吃啦，期望明天是苹果_ 档案袋资料,在上午结束后发的。但开营式还要等河海的领导到齐后才能开，大约定在了明天21号的下午。 档案袋 学员卡 下午讲了很久的Linux的基础知识。=.=很无聊啊，我连《机器学习Python实践》一本书都快读完了。 下午5:30挺准时下课的，6:30就要上课了，所以只好直接去食堂就餐了。 晚上6:30开始教授的是vim的基本操作，小测是让我们用VIM写个C程序编译，然后在最后结束的时候让我们10个人组个组，一起学习。队名、口号想了很久，最后很鸡贼的选了yeah当口号，不如跳舞是我们的队名。 表上说是7:30结束的，到最后，我们组是最后一个完成的，时间已经是8:30了。到宾馆几乎9点。 解决了Markdown的渲染问题TypeError: Cannot set property 'lastIndex' of undefined 再码码代码也就休息了，希望今天能睡个好觉~ The Third Day~21 早上还是很早就醒了，不知道为什么睡不深。 走的时候看了一下档案袋，想到了下午有开幕式，结果还是忘记了带营员证，结果只好中午吃饭后跑回来拿。 早上吃的是还是豆浆、粥，肉包，与昨天不同的是，菜包已经没了，很有可能是大家都不爱吃，最后剩下了很多。虽然肉包的皮也很厚，但毕竟是个肉吧2333。还多了油条，辣榨菜，这两个是我比较喜欢吃的，配粥很下饭。 上午，在调呼吸灯，感觉记忆力退化的很厉害，当初的PWM现在已经都不太会了。调了挺久，到中午吃饭的时候，才调出来。 下午，主要在看MMDR_N4的算法，总算厘清了思路，可以直接用了。授课方面的话介绍的是舵机的使用，只不过由于机器人用的是数字舵机，操作比较方便，再加上API封装的比较好，完成的就很轻松，不需要自己手写PWM。 在两点的时候，凑齐了各方的领导，终于在图书馆举办了开幕式。 结束的还挺迅速的，稍微玩了下手机就结束了。 晚上的任务是完成布置的作业: 金鸡独立： 保存机器人初始的舵机状态 控制舵机的方式实现金鸡独立（腿抬高，手臂动作） 站稳 恢复舵机状态 使用APP上的回读编程，完成一个动作序列（可以加音乐） 保存到机器人上，通过ubtRobotStartAction接口调用自己编排的动作 由于脚掌体积较大,所以将原来向后的动作加了个往前抬腿，转动脚踝的动作，使得平衡出了很大的问题，最终弄到9点都还没弄完，只好留到第二天完成了。 回到宾馆后，跟活动室的学长们视频了一波，汇报了一下进度和了解了下他们的情况，最后将看的MMDR_N4抽出，写了个文档，睡觉的时候都快11:30了。今天睡得比较晚了。 The Fourth Day~22 早上7:15的闹钟,黏了7分钟才起。隔天没Debug出来，睡的也比较晚，导致起的时候非常的疲倦。所幸的是，我们到楼下时发现老师还没来，大部队也还没走。等了好几分钟，看老师还没来，就带头直接去食堂了。早餐不同的是桃酥饼，和萝卜丝馅饼，吃完之后才收到老师的消息，得知老师也没爬起来。 上午介绍的是机器人的五个传感器的使用，主要是使用它提供的Api。传感器有： 压力、触摸、超声波、红外、气温气压。这些都比较基础，就一直在看optimization里的优化细节。WDD问了下Andriod方面的需求，就花了时间整理了下思路，安排了人员。 下午据说有电视台采访，于是没怎么看Apollo的资料，认真调了下机器人的代码。就在准备展示我们的作品，上电视的时候，机器人的动作错了，导致没站稳直接摔到了。摄影小哥等我们调试了几分钟还没调好后，就放弃我们了😭 晚上跟前几天比结束的很早，讲了点TCP/UDP及网络的基础知识，让我们写了个UDP接收信息的程序就结束了。这方面感觉老师讲的还挺好的，经验、涉及面很丰富。 The Fifth Day~23 图像处理，介绍了人脸检测、人脸识别、表情检测的接口。 具体的我也忘记做了啥了…我应该都在敲机器学习. The Fifth Day~24 下午1点还是2点，公布了项目的要求。大家就都热火朝天的开始干起来了，我们进度算很快了，吃饭前就完成了所有基础功能，我把图灵机器人和天气的Api都已经写好了。 晚上处理了人脸跟踪的功能，但碰到了python2中字符串不可变的问题，确实很棘手处理了很久才搞定。 主要发现的问题是: 当字符串&lt;4时,如’123’，那么输出的话是’’. 当赋值为a='notfound'时,,怀疑是zhx后面还是多余的空格而没有被输出出来 当写成a='notfounda'的时候，if判断得写成 if a == 'notfound\\x00' The Sixth Day~25 完成项目的拓展功能和答辩。我们昨天就完成了所有的基础功能，第二天的任务就是添加拓展功能。我们选择了三个：随机播放或中途暂停音乐、语音识别 、 人脸识别跟踪行走。 除了语音识别功能，其实有不少在昨天晚上都已经搞定了，但是当天演示时却bug了。真的是很悲催，再加上抽签的运气不是很好，第二个就上场了，导致最后的演示效果很差。 计划2点开始演示，但真正的开始时间却是2:30，我们大约是3：10分演示的，由于机器人金鸡独立时摔倒的缘故，存储人脸的机器人重启了，导致人脸数据丢失而无法演示人脸跟踪。 后面几组演示的就比较幸运，第7组都已经是吃完晚饭6:30以后演示的了…真的抽签太看运气了。 虽然演示后结果不太令人满意吧，但好在大家也没有太沮丧。说实话，演示完后就已经没什么心思看别人的演示了。于是我和张志兴学长以及南大计软的一个女生交流了一会。向张志兴学长讨教了不少单片机方面的知识，张志兴学长很棒… 说实话我一直以为他是大二的… The Seventh Day~26 忍了很久想吃面的欲望，最后一天，决定不吃食堂，找了河海外面的一家早餐店吃了面。 最后一天是闭营典礼，主要是副院长讲话，然后颁奖，昨天的答辩环节效果很差，注定了今天我们只能当观众。大家的心情都不是很好吧，毕竟都花了挺多心思，但没有获奖，真的挺可惜的。 颁完奖，拍完照，就解散了。我和我的小组成员留了一会，总结了一下这次很多地方的问题，以及交流了一下，主要是感觉对不起大家，我们完全是有能力获奖的，但由于种种原因而失败了，非常的遗憾。总结的过程被副院长听到了，很尴尬，他要我写篇感想23333，不慎惶恐。 总结结束后，我并不是很急着回学校，于是找张老师聊了聊天。得知张洪涛老师是内蒙古人，大学就读于杭州，现在工作于深圳，真的是横跨了整个中国。他也是自动化专业的，很大程度上也是因为家庭原因，直接选择了工作，据他所说大学是玩了4年，91年生的，目前也工作了6-7年了，但我感觉他的知识面还是挺广的，他讲解的网络方面的一点东西对我还是有不少启发的，所以也不知他说的是不是真的。 跟他交流了大概两个小时吧，主要是自动化的学科方向，以及之后的工作方向。感觉找前辈聊天真的是个很愉快的过程，不管他的经验是否能够借鉴，但每个人的经历都耐人寻味，想了解更多人的生活。 10点半结束的，大约12点半才离开河海，上地铁回南邮。 下面是我提交的感想，院长说会帮我润色一下的，也不知道他刊在哪里了。 大学入学以来，一直都在为了竞赛和学业而疲于奔命。经常为生活圈子日益狭窄，压力日益繁重而恐慌。于是经过一系列思考后，最终在数模美赛、电赛培训…多种寒假活动中选择参加了由江苏省教育部发起，河海大学组织的“AI+机器人”冬令营活动。选择这个冬令营原因，一是因为机器人是个交叉的学科，在接触的过程中，即可以了解硬件，又会涉及软件开发，对个人能力都会有比较高的提高；二是，想找点真正感兴趣的东西做做放松下身心，而不是像在学校那样再为了能力分和绩点终日劳神费心。 冬令营聚集了江苏省各所高校里有能力和想法的学生，在这里我们能碰到很多志同道合的朋友，刚来初到的前几天，我认识了我们学校同批参加冬令营的同学。后来几天经过交流认识了各个学校参加各种项目的同学，有做机甲大师的、有参加飞思卡尔的，有弄Robocup的……在不上课的时间里，就听他们讲说了各地的轶事、各个方面的细节…… 为时一共七天的冬令营，前五天，张洪涛老师都非常耐心地带着大家一个一个模块完成任务，每一阶段的成功，都极大地调动了我们的积极性和成就感。也为我们能够从容接受最后的项目实战做了很大的铺垫。 最后两天是完成项目，要求十个人组成一只队伍，分布式地操作机器人。在提出五个基本要求的基础上，张老师也给了我们一点启发性的意见作为评比的加分项。24号下午项目要求一公布出来，我们就在组内分配好了任务。由于基础工作比较明确，我们很快的就分配好了各自的工作，经过大家的全身心投入，我们很顺利的在吃晚饭之前就几乎把所有基础功能都做完了，但是却没有进行即时阶段性的汇总，导致第二天展示前调试比较匆忙，这也是比较可惜的地方。 吃完晚饭后，大家都很快的回到了机房，继续为更好的功能而调试。晚上规定在6:30-7:30的交流时间之后就能回去了，但为了调试代码，我们全组都选择留了下来，直到9点左右才走。当时我们在攻克的是跟踪人脸行走功能，困扰我们的是Python2上的编码问题，无论是否检测得到人脸都会向前行走。所以虽然效果能算达到，但并不是为了单纯演示就行，我们还是决定从原理上彻底查明这个的原因。由于负责的同学没怎么接触过这个问题，于是我们花了很大的功夫，在调试了N遍以后终于找了原因和解决方案。事实上也证明了我们的付出没有白费，第二天有其他小组也碰到了这样的问题，我们为他们讲明了原因，他们也很快的实现了这个功能。 我们的拓展功能还有随机播放或中途暂停音乐及语音识别，我们第二天的时间全都在测试这些。但由于语音识别的效果比较差，最后我们还是只能选择放弃演示。而播放音乐的功能全在演示前的一段时间被调错而无法使用。所有最终我们的演示效果很差，成绩也不是很理想。 作为我们队长，以及在接触Python比较多的情况下，没有带领团队获得比较好的成绩我还是比较自责的。但回想整个完成的过程，其实感慨、收获还是颇多的。首先是学长学姐对我的支持，大三学长张志兴个人能力很强，但有时我的错误指挥，他都给了很大的宽容。其次是大家团队合作的热情和态度，碰到BUG大家甚至会不吃饭选择一起解决；还有由于人数原因而后来被分配到我们小组的周轶凡，虽然跟组离得很远，逐渐边缘化，有时我甚至都没有想起他来，但是他都会非常积极地要求任务和积极参加讨论，让我感受到了团队合作的感觉，感受到了we are a team!再者是徐弘毅的热情，他跟我同是大二的，由于没怎么接触过python，还特地带了Python的书，碰到了那个编码问题，也是钻研了很久；还有的是一个比较好玩的事，当初刚开始合作完成项目的时候，大家连人名都不知道，偶然听到一个张志兴的名字，就一直把徐弘毅叫做张志兴，因为每次这么叫他队友时，徐弘毅总是第一个回头的…… 但同时我们确实也存在很多的问题：答辩展示的重点并不是很明确，有些基础功能觉得大家都展示过，自己就太轻视而可能没有展示；拓展功能完成的太顺利而没有介绍到……都是一些答辩上完成的不够好的地方，以及临场应变还不熟练。还有的是缺少团队合作经验，导致很多程序架构方面的事都没有说清楚，比如Python在缩进上要求很严格，而我在我的笔记本上汇总总程序都是4个空格一层缩进，他们在机器人上的代码都是8个空格一层的。但队友都比较好心，没有提出问题，而是默默的每次都帮我改好，直到最后演示前又发了一遍代码后才发现这个由于没有沟通而导致严重的架构问题。同时还有，分工上也太牵强了，虽然基础功能分工的比较明确，都挺好的实现了，但是拓展功能，由于我做该方面做的比较多，我没有分配下去而是选择了一人承担，导致汇总以及拓展功能的调试都落在我身上，在展示前一段调试的时间里，哪边出了问题都得我去处理，最后确实有点无暇分身、弄得很乱…… 这次的项目有很多好好坏坏，但这次的合作，让我们从全都不认识，到现在能相互开玩笑；不能写Python代码到能写Python项目，真的成长了太多。虽然成绩比较可惜，但是我为认识他们而高兴。在此，我要再次感谢我的队友：张志兴、徐弘毅、王青雅、侍亚东、林丹丹、陈晓谦、陈怀新。大家在各自的领域内都是大手子，而这次我能荣幸的担任他们的队长，真的是很不容易，从心里感谢他们的包容和理解、配合与支持。 因为你们，不虚此行~ 附: 安排表 三角包子(实心,没馅的!!! 两大荤、一小荤、两素的套餐，多图警告","categories":[],"tags":[{"name":"生活小记","slug":"生活小记","permalink":"https://nymrli.top/tags/生活小记/"}]},{"title":"DFS专项练习","slug":"DFS专项练习","date":"2019-01-19T12:53:03.000Z","updated":"2019-09-15T08:07:30.929Z","comments":true,"path":"2019/01/19/DFS专项练习/","link":"","permalink":"https://nymrli.top/2019/01/19/DFS专项练习/","excerpt":"","text":"DFS专题 leetcode 104. 二叉树的最大深度 123456789101112131415161718/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */#include&lt;algorithm&gt;class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(root==NULL)return 0; int l1=maxDepth(root-&gt;left); int l2=maxDepth(root-&gt;right); return max(l1,l2)+1; &#125; DFS模板总结 1234567891011121314151617181920212223void dfs()//参数用来表示状态 &#123; if(到达终点状态) &#123; ...//根据题意添加 return; &#125; if(越界或者是不合法状态) return; if(特殊状态)//剪枝 return ; for(扩展方式) &#123; if(扩展方式所达到状态合法) &#123; 修改操作;//根据题意来添加 标记； dfs（）； (还原标记)； // visited[i] = 1; //是否还原标记根据题意 //如果加上（还原标记）就是 回溯法 // visited[i] = 0 &#125; &#125; &#125; 全排列问题 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std; int p[10]=&#123;0&#125;;bool vis[10]=&#123;0&#125;;int n;void dfs(int x)&#123; if (x==n+1)&#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;p[i]&lt;&lt;\" \"; cout&lt;&lt;endl; return ; &#125; for (int i=1;i&lt;=n;i++)&#123; if (vis[i]==false ) &#123; p[x] = i; vis[i] = true; dfs(x+1); vis[i] = false; &#125; &#125;&#125; int main()&#123; n=4; dfs(1); return 0;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"}]},{"title":"Typora可选选项","slug":"Typora可选选项","date":"2019-01-19T12:51:11.000Z","updated":"2019-09-15T08:07:31.008Z","comments":true,"path":"2019/01/19/Typora可选选项/","link":"","permalink":"https://nymrli.top/2019/01/19/Typora可选选项/","excerpt":"","text":"用了这么久markdown才发现原来支持Latex的符号公式，但是在Typera中需要自行设置出来，文件--&gt;偏好设置--&gt;markdown拓展语法（内联公式）、代码块（显示行号） Latex 公式：32​\\frac{3}{2}​23​​ 带有行号的代码块 12345#include &lt;stdio.h&gt;int main()&#123; printf(\"hello world\"); return 0;&#125; 其他功能自行发现吧！_","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"Latex学习","slug":"Latex学习","date":"2019-01-19T12:49:31.000Z","updated":"2019-09-15T08:07:30.953Z","comments":true,"path":"2019/01/19/Latex学习/","link":"","permalink":"https://nymrli.top/2019/01/19/Latex学习/","excerpt":"","text":"基本概念和使用 Hello, world! 12345\\documentclass&#123;article&#125;%这里是导言区\\begin&#123;document&#125;Hello, world!\\end&#123;document&#125; 请注意，TeX 对控制序列的大小写是敏感的 部分控制序列还有被方括号[]包括的可选参数。 出现了控制序列 begin，这个控制序列总是与 end 成对出现。这两个控制序列以及他们中间的内容被称为「环境」；他们之后的第一个必要参数总是一致的，被称为环境名。 只有在 “document” 环境中的内容，才会被正常输出到文档中去或是作为控制序列对文档产生影响。也就是说，在 \\end{document} 之后插入任何内容都是无效的。 \\begin{document} 与 \\documentclass{article} 之间的部分被称为导言区。导言区中的控制序列，通常会影响到整个输出文档。 输出中文 使用命令行输入texworks打开tex编辑器 1234\\documentclass[UTF8]&#123;ctexart&#125;\\begin&#123;document&#125;你好，world!\\end&#123;document&#125; 文档类从 article 变为 ctexart； 增加了文档类选项 UTF8。 12345678\\documentclass[UTF8]&#123;ctexart&#125;\\title&#123;你好，world!&#125;\\author&#123;Liam&#125;\\date&#123;\\today&#125;\\begin&#123;document&#125;\\maketitle你好，world!\\end&#123;document&#125; 笔记 中文问题 面对中文编码问题，CJK被淘汰，使用ctexart编译中文 ▲注意，编译方式必须改为xeLaTex，只有部分环境下 pdfLaTex 也可以编译成功 1234\\documentclass[UTF8]&#123;ctexart&#125;\\begin&#123;document&#125;您可以看到，说明你编译成功了！\\end&#123;document&#125; 标准文类 article：短文，评论，学术论文；无左右页区分，无章设置。对应中文类ctexart。 book：著作，学位论文；默认有左右页区分，章起右页。对应中文类ctexbook。 report：商业，科技，试验报告，默认无左右页区分，章起新页。对应中文类：ctexrep。 beamer：论文陈述幻灯片；提供多种主题式样，可方便更改幻灯片的整体风格。 常用宏包 不是必须记住，需要用哪个现查即可，列出这些是为了浏览别人的源文件时知道人家调用了哪个宏包。 amsmath 公式环境和数学命令 amssymb 数学符号生成命令 array 数组和表格制作 calc 四则运算 caption 插图和表格标题格式设置 fancyhdr 页眉页脚设置 fancyvrb 抄录格式设置 fontspec 字体选择 geometry 版面尺寸设置 graphicx 插图处理 hyperref 创建超文本链接和PDF书签 longtable 制作跨页表格 multicol 多栏排版 ntheorem 定理设置 paralist 多种列表环境 tabularx 自动设置表格列宽 titlesec 章节标题格式设置 titletoc 目录格式设置 xcolor 颜色处理 xeCJK 中日朝文字处理和字体选择","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"Latex","slug":"Latex","permalink":"https://nymrli.top/tags/Latex/"}]},{"title":"每日codewars","slug":"每日codewars","date":"2019-01-19T12:47:50.000Z","updated":"2019-09-15T08:07:31.084Z","comments":true,"path":"2019/01/19/每日codewars/","link":"","permalink":"https://nymrli.top/2019/01/19/每日codewars/","excerpt":"","text":"Codewars 12.17 Sum without highest and lowest number 1234567891011121314151617181920212223242526272829#include&lt;vector&gt;#include&lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int sum(vector&lt;int&gt; numbers)&#123; /* Sum without highest and lowest number &#123; 6, 2, 1, 8, 10 &#125; =&gt; 16 &#123; 1, 1, 11, 2, 3 &#125; =&gt; 6 */ if(numbers.empty()) return 0; if(numbers.size()==1) return 0; sort(numbers.begin(),numbers.end()); int sum=0; for( vector&lt;int&gt;::iterator it = numbers.begin()+1;it != numbers.end()-1;it++) sum += *it; return sum;&#125;int main()&#123; vector&lt;int&gt; n; n.push_back(1); n.push_back(3); n.push_back(5); cout &lt;&lt; sum(n); return 0;&#125; C++11支持的新特性 12345vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5,7&#125;;// 支持了vector &#123;&#125;的初始化方式for(int i : a) cout &lt;&lt; i;//支持了for(:) 12.19 reverse Sum of positive 1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;algorithm&gt;/**Hex to Decimal**/int hexToDec(std::string hexString)&#123; reverse(hexString.begin(),hexString.end()); int base = 1; int sum =0 ; bool fu = 0; for(string::iterator it = hexString.begin() ; it != hexString.end() ; it++ )&#123; if( *it == '-') &#123;fu = 1; continue;&#125; int num = 0; if( *it &gt;= 'A' &amp;&amp; *it &lt;= 'F' ) num = *it - 'A' + 10; else if( *it &gt;= 'a' &amp;&amp; *it &lt;= 'f' ) num = *it - 'a' + 10; else num = *it - '1' + 1; sum += num * base; base *= 16; &#125; return fu?-sum:sum;&#125;//base来控制相应位数，Aa都要考虑，负数 12for(string::iterator it = hexString.begin() ; it != hexString.end() ; it++ )// *it 是 char类型的 12.20 stoi、istringstream、sscanf Hex to Decimal 12345#include &lt;string&gt;int hexToDec(const std::string&amp; hexString)&#123; return std::stoi(hexString, nullptr, 16); //return std::stoi(hexString, 0, 16);&#125; 123456#include &lt;ios&gt;int hexToDec(std::string hexString)&#123; int n; std::istringstream(hexString) &gt;&gt; std::hex &gt;&gt; n; return n;&#125; 123int hexToDec(std::string hexString)&#123; return (int)strtol(hexString.c_str(), 0, 16);&#125; 12345int hexToDec(std::string hex) &#123; int decValue; sscanf(hex.c_str(), \"%x\", &amp;decValue); return decValue;&#125; 12.21 增强的for(ch : vowels ) Vowel Count 123456789101112#include &lt;string&gt;using namespace std;int getCount(const string&amp; inputStr)&#123; int num_vowels = 0; vector&lt;char&gt; vowels = &#123;'a', 'e', 'i', 'o', 'u' &#125;; for(int it = 0; it != inputStr.size() ; it++ ) for(char ch : vowels ) if( ch == inputStr[it] ) num_vowels++; return num_vowels;&#125;/**const string&amp; inputStr**/for(string::const_iterator it = inputStr.begin() ; it != inputStr.end() ; it++) // 迭代器为const_iterator，而不是iterator 优秀解答： count_if 12345678910111213141516171819202122232425int getCount(const string&amp; inputStr)&#123; return count_if(inputStr.begin(), inputStr.end(), [](const char ch) &#123; switch(ch) &#123; case 'a': case'e': case'i': case'o': case'u': return true; default: return false;&#125; &#125;);&#125;// &lt;=====&gt;#include &lt;string&gt;using namespace std;bool is_vowel(char c) &#123; return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');&#125;int getCount(const string&amp; inputStr) &#123; return count_if(inputStr.begin(), inputStr.end(), is_vowel);&#125; 12.22 for_each和C11的匿名函数 Invert values 123456789/**Invert values**/#include &lt;vector&gt;std::vector&lt;int&gt; invert(std::vector&lt;int&gt; values)&#123; std::vector&lt;int&gt; v2; for_each(values.begin(),values.end(),[ &amp;v2](int c)&#123; v2.push_back(-c); &#125;); return v2;&#125;// 学会使用了 for_each和C11的匿名函数 匿名函数 参数 1234[](int x, int y) &#123; return x + y; &#125; // 隐式返回类型[](int&amp; x) &#123; ++x; &#125; // 没有return语句 -&gt; lambda 函数的返回类型是'void'[]() &#123; ++global_x; &#125; // 没有参数,仅访问某个全局变量[]&#123; ++global_x; &#125; // 与上一个相同,省略了() 技巧: 没有return ， 则 lambda的返回类型是void 如果没有参数，则可以省略参数 捕获 值捕获 引用捕获 123456[] //未定义变量.试图在Lambda内使用任何外部变量都是错误的.[x, &amp;y] //x 按值捕获, y 按引用捕获.[&amp;] //用到的任何外部变量都隐式按引用捕获[=] //用到的任何外部变量都隐式按值捕获[&amp;, x] //x显式地按值捕获. 其它变量按引用捕获[=, &amp;z] //z按引用捕获. 其它变量按值捕获 12.23 ▲transform 算法transform()提供以下两种能力： 1.第一形式有4个参数，把源区间的元素转换到目标区间。也就是说，复制和修改元素一气呵成； transform(sourceBeg,sourceEnd,destBeg,op) (1)针对源区间[sourceBeg,sourceEnd)中的每一个元素调用：op(elem) 并将结果写到以destBeg起始的目标区间内； (2)返回目标区间内“最后一个被转换元素”的下一个位置，也就是第一个未被覆盖的元素位置； (3)调用者必须确保目标区间有足够的空间，要不就得使用插入型迭代器； (4)sourceBeg于destBeg可以相同，所以，和for_each()算法一样，你可以使用这个算法来变动某一序列内的元素； (5)如果想以某值替换符合某一准则的元素，应使用replace()算法； (6)复杂度：线性； 12345678910#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int test()&#123; vector&lt;int&gt; coll1; for (int i=1;i&lt;9;i++) coll1.push_back(i); transform(coll1.begin(),coll1.end(),coll1.begin(),negate&lt;int&gt;()); for (int i=0;i&lt;8;i++) cout &lt;&lt; coll1.at(i) &lt;&lt;endl; //-1 -2 -3 -4 -5 .. -8&#125; 2.第二形式有5个参数，将前两个源序列中的元素合并，并将结果写入目标区间。 transform(source1Beg,source1End,source2Beg,destBeg,op) (1)针对第一源区间[source1Beg,source1End)以及“从source2Beg开始的第二源区间”的对应元素，调用:op(source1Elem,source2Elem) 并将结果写入以destBeg起始的目标区间内； (2)返回区间内的“最后一个被转换元素”的下一位置，就是第一个未被覆盖的元素的位置； (3)调用者必须保证第二源区间有足够空间（至少拥有和第一区间相同的空间大小）； (4)调用者必须确保目标区间有足够空间，要不就得使用插入型迭代器； (5)source1Beg，source2Beg，destBeg可以相同。所以，可以让元素自己和自己结合，然后将结果覆盖至某个序列； (6)复杂度:线性； 12345678910#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int test()&#123; vector&lt;int&gt; coll1; for (int i=1;i&lt;9;i++) coll1.push_back(i); transform(coll1.begin(),coll1.end(),coll1.begin(),coll1.begin(),multiplies&lt;int&gt;()); for (int i=0;i&lt;8;i++) cout &lt;&lt; coll1.at(i) &lt;&lt;endl; // 1,4,16,25...81&#125; http://lib.csdn.net/article/cplusplus/32641 Remove exclamation marks 123456789101112131415161718#include &lt;queue&gt;#include &lt;string&gt;using namespace std;std::string removeExclamationMarks(std::string str)&#123; //your code here queue&lt;char&gt; st; for(string::iterator it = str.begin() ; it != str.end() ; it++) if( *it != '!') st.push(*it); string s; for(int i = st.size() ; i &gt;0 ; i--)&#123; s += st.front(); st.pop(); &#125; return s;&#125;// &gt;&gt;&gt; 2323!!asd ===&gt; 2323asd 12.24 Maximum Multiple 12345int maxMultiple(int divisor, int bound) &#123; // Your Code is Here ... Enjoy !!! if ( bound % divisor == 0) return bound; return divisor * ( bound / divisor);&#125; 12.25 nth_element()函数 部分排序 头文件：#include&lt;algorithm&gt; 作用：nth_element(a+l,a+k,a+r) 它会使a这个数组中区间[l,r)内的第k大的元素处在第k个位置上(相对位置)，**但是它并不保证其他元素有序！**且第 n 个元素之前的元素都小于它，但不必是有序的。同样，第 n 个元素后的元素都大于它，但也不必是有序的。 排序后a[n]就是数列中第n+1大的数 12nth_element(intVect.begin(),intVect.begin()+3,intVect.end());cout &lt;&lt; intVect[2]&lt;&lt; endl; https://zhidao.baidu.com/question/1447317576049306340.html 12.26 Mumbling 1234567891011121314151617181920212223242526using namespace std;class Accumul&#123;public: static std::string accum(const std::string &amp;s) &#123; stringstream result; for (int i = 0; i &lt; s.length(); i++) result &lt;&lt; \"-\" &lt;&lt; string(1, toupper(s[i])) &lt;&lt; string(i, tolower(s[i])); return result.str().substr(1); &#125;&#125;;class Accumul&#123;public: static std::string accum(const std::string &amp;s) &#123; std::string result; for (int i = 0; i &lt; s.length(); i++) &#123; result.append(\"-\"); result.append(std::string(1,toupper(s[i]))); result.append(std::string(i,tolower(s[i]))); &#125; return result.substr(1,result.length()); &#125;&#125;; 12.27 Highest and Lowest 12345678910111213141516171819//[mySolution]#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;string highAndLow(const string&amp; numbers)&#123; string single; //每个字符 stringstream ss(numbers); //字符流 vector&lt;int&gt; s; //存储每个数字的vec while( getline(ss,single,' ') ) //根据空格分割 //while(ss &gt;&gt; s) s.push_back(stoi(single)); sort(s.begin(),s.end(),greater&lt;int&gt;()); //从大到小排序 //将整数拼合起来 stringstream sss; sss &lt;&lt; s.at(0) &lt;&lt; \" \" &lt;&lt; s.at(s.size() - 1) ; return sss.str();&#125; boost库 1234567891011#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;boost&gt;using namespace std;using namespace boost;int main() &#123; string s = \" hello boost!! \"; trim(s); cout &lt;&lt; s &lt;&lt; endl;&#125; 返回 编译器允许的 int 型数 最大值std::numeric_limits&lt;int&gt;::max () 1.1 Minimize Sum Of Array (Array Series #1) 12345678910111213141516171819#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int minSum (vector&lt;int&gt;passed)&#123; sort(passed.begin(),passed.end()); int sum = 0 ; int n = passed.size(); for(int i=0;i&lt; n/2; i++)&#123; sum += passed.at(i) * passed.at(n-1-i); &#125; return sum ;&#125;int main()&#123; cout &lt;&lt; minSum(&#123;5,4,2,3&#125;); //最远的两个数相乘，内积 return 0;&#125; 函数形参为vec时，可以直接将{x1,x2,x3}当参数传入。 inner_product 定义在 numeric 头文件中的 inner_product() 算法可以计算两个 vector 的内积。这个函数模板有 4 个参数：前两个参数是定义第 1 个 vector 的输入迭代器，第 3 个参数是确定第 2 个 vector 的开始输入迭代器，第 4 个参数是和的初值。算法会返回 vector 的内积。例如： cout &lt;&lt; inner_product(begin(passed),begin(passed)+n,passed.rbegin(),0) &lt;&lt; endl; 1.2 关于删除可迭代对象中元素 123456789101112131415161718//正确写法std::list&lt; int&gt; List;std::list&lt; int&gt;::iterator itList;for( itList = List.begin(); itList != List.end(); )&#123; if( WillDelete( *itList) ) itList = List.erase( itList); //或者 List.erase( itList ); //反正就是不能让下标一下进两个，如果将++写在for里面，会导致删除后漏了一个元素判断 else itList++;&#125;//错误写法std::list&lt; int&gt; List;std::list&lt; int&gt;::iterator itList;for( itList = List.begin(); itList != List.end(); itList++)&#123; if( WillDelete( *itList) ) List.erase( itList);&#125; 错误原因：在调用erase方法之后使用“++”来获取下一个元素的位置，由于在调用erase方法以后，该元素的位置已经被删除，如果在根据这个旧的位置来获取下一个位置，则会出现异常。 在Python里面遍历删除元素时，下标问题，会使略过元素==&gt; 解决方法： if，else Disemvowel Trolls 12345678910111213# include &lt;string&gt;std::string disemvowel(std::string str)&#123; for(std::string::iterator it = str.begin() ; it != str.end() ;)&#123; if ( *it == 'A' || *it == 'I' || *it == 'U' || *it == 'E' || *it == 'O' || *it == 'a' || *it == 'o' || *it == 'i' || *it == 'u' || *it == 'e' ) str.erase(it); else it++; &#125; return str;&#125; c++正则 123456# include &lt;string&gt;# include &lt;regex&gt;std::string disemvowel(std::string str)&#123; std::regex vowels(&quot;[aeiouAEIOU]&quot;); return std::regex_replace(str, vowels, &quot;&quot;);&#125; 1.3 在string中查找子串 string:: string::find(string &amp;); 123456789101112131415161718int main()&#123; string a=\"abcdefghigklmn\"; string b=\"def\"; string c=\"123\"; string::size_type idx; idx=a.find(b);//在a中查找b. if(idx == string::npos )//不存在。 cout &lt;&lt; \"not found\\n\"; else//存在。 cout &lt;&lt;\"found\\n\"; idx=a.find(c);//在a中查找c。 if(idx == string::npos )//不存在。 cout &lt;&lt; \"not found\\n\"; else//存在。 cout &lt;&lt;\"found\\n\"; return 0;&#125; 当没有找到时返回string::npos 1.4 12345678910111213141516171819202122232425262728293031class CountDig&#123;public: static int nbDig(int n, int d);&#125;;using namespace std;//计算num中出现数字d的次数int contain(int num,int d)&#123; int n =0 ; while( num &gt;= 1)&#123; int ge = num % 10; num = num / 10; if( ge == d) n++; &#125; return n;&#125;//要求的成员函数int CountDig::nbDig(int n, int d)&#123; vector&lt;int&gt; v; for(int i=0 ; i &lt;= n ; i++) v.push_back( i*i ); int cnt =0; for_each(v.begin(),v.end(),[d,&amp;cnt](int x)&#123; int appn = contain(x,d); cnt += appn ; &#125;); return d==0?++cnt:cnt ; //由于contain函数会舍去0的情况，所以这边补上&#125; topow(int ,int) 丢精度 问题尚未解决 1.5 Compare Strings by Sum of Chars isalpha的使用，sum为int类型，当sum+= char类型的c时，实际加的就是c的ASCII码值 12345678910111213// Calculate the char-value of the stringint charvalue(std::string s)&#123; int sum = 0; for(char &amp;c : s)&#123; if(!std::isalpha(c)) return 0; sum += std::toupper(c); &#125; return sum;&#125;bool compare(std::string s1, std::string s2)&#123; return charvalue(s1) == charvalue(s2);&#125; 1.6号后开始认真复习 考试周忙，空了好多练习 1.24 缺少main函数报错 1.28 PTA 求自定类型元素的平均 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Average( ElementType S[], int N );int main ()&#123; ElementType S[MAXN]; int N, i; scanf(\"%d\", &amp;N); for ( i=0; i&lt;N; i++ ) scanf(\"%f\", &amp;S[i]); printf(\"%.2f\\n\", Average(S, N)); return 0;&#125;ElementType Average( ElementType S[], int N )&#123; int i; ElementType sum; for(i=0;i&lt;N;i++) sum += S[i]; return sum/(ElementType)(N);&#125; 求单链表结点的阶乘和 链表 + 阶乘 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node *PtrToNode;struct Node &#123; int Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */&#125;;typedef PtrToNode List; /* 定义单链表类型 */int FactorialSum( List L );int main()&#123; int N, i; List L, p; scanf(\"%d\", &amp;N); L = NULL; for ( i=0; i&lt;N; i++ ) &#123; p = (List)malloc(sizeof(struct Node)); scanf(\"%d\", &amp;p-&gt;Data); p-&gt;Next = L; L = p; &#125; printf(\"%d\\n\", FactorialSum(L)); return 0;&#125;// ----完成部分----int FactorialSum( List L )&#123; struct Node* p = L; int sum = 0; while( p )&#123; int fac=1; for(int i=1;i&lt;=p-&gt;Data ;i++) fac *= i; //计算N的阶乘 sum += fac; p = p-&gt;Next; &#125; return sum;&#125; 统计某类完全平方数 平方数,取出各位 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;math.h&gt;int IsTheNumber ( const int N );int main()&#123; int n1, n2, i, cnt; scanf(\"%d %d\", &amp;n1, &amp;n2); cnt = 0; for ( i=n1; i&lt;=n2; i++ ) &#123; if ( IsTheNumber(i) ) cnt++; &#125; printf(\"cnt = %d\\n\", cnt); return 0;&#125;int IsTheNumber ( const int N )&#123; int n = (int )sqrt(N); if( N == n*n ) &#123; int arr[10] = &#123;0&#125;; int m = N; while( m &gt; 0)&#123; int tmp = m%10; arr[tmp] += 1; for( int i = 0 ;i&lt;10;i++)&#123; if( arr[i] == 2)return 1; &#125; m /= 10; &#125; return 0; // 注意这边得考虑 &#125;else return 0;&#125; 1.29 统计个位数字 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int Count_Digit ( const int N, const int D );int main()&#123; int N, D; scanf(\"%d %d\", &amp;N, &amp;D); printf(\"%d\\n\", Count_Digit(N, D)); return 0;&#125; Count_Digit ( const int N, const int D )&#123; int cnt =0 ; if ( N == 0 ) return 1; //需要考虑 N = 0的情况 int m =N&gt;0?N:-N; //以及负数情况, 这边取绝对值 while(m &gt; 0 )&#123; int tmp = m%10; if( tmp == D) cnt++; m /= 10; &#125; return cnt;&#125; 6-10 阶乘计算升级版 ----高精度 题解 123456789101112131415161718192021222324252627282930void Print_Factorial ( const int N )&#123; long i,s=1; if(N&gt;=0&amp;&amp;N&lt;=12)&#123; //剪枝.减少时间复杂度 for(i=2 ;i&lt;=N ;i++)s *= i; printf(\"%ld\\n\",s); &#125;else if(N&gt;12&amp;&amp;N&lt;=1000)&#123; int num[3000] = &#123;0&#125;; num[0] = 1; int k=1; //位数 int n=0; //进位 int temp; for(int i=2 ;i&lt;=N ;i++)&#123; for(int j=0;j&lt;k;j++)&#123; temp = num[j]*i+n; //每一位相乘 再+进位 num[j] = temp%10; //更新每一位的数字 n = temp/10; //判断能否进位 &#125; while(n!=0)&#123; //如果可以进位 num[k] = n%10; //新增一位 n /=10; //继续判断能否进位 k++; &#125; &#125; for(int x=k-1;x&gt;=0;x--)printf(\"%d\",num[x]); //逆序输出数字 &#125; else&#123; printf(\"%s\\n\",\"Invalid input\"); &#125;&#125; 我的做法(错误): 123456789101112131415161718192021222324252627282930int mutliply(int a[],int n,int b)&#123; for(int i = n - 1 ;i &gt;= 0 ; i--)&#123; //计算机计算时, 4*6 , 先将十位确定,再确定个位 int tmp = a[i] * b; while( tmp &gt;= 10 ) &#123; /*▲. 这样的写法,存在124,无法在百位进位的缺陷 还是最好 tmp %= 10; n /= 10; */ tmp -=10; a[i+1] += 1; &#125; a[i] = tmp; &#125;&#125;void Print_Factorial ( const int N )&#123; if( N &lt; 0 ) &#123; printf(\"Invalid input\"); return ; &#125; int a[10000]=&#123;0&#125;; a[0] = 1; int n =10000; for(int i=1;i&lt;=N;i++)&#123; mutliply(a,n,i); &#125; for(int i=n-1;i &gt;= 0; i--) printf(\"%d \",a[i]); &#125; 总结 : 如果arr[0] = 1, 则得逆序输出。 由于要考虑前缀0的原因，必须考虑位数问题，这也是为什么我的方法一开始没有考虑位数问题，最后就算不下去的原因、 修改后重版 123456789101112131415161718192021222324252627282930313233void mutliply(int a[],int *n,int b)&#123; int w = 0; //进位 for(int j = 0 ;j &lt; *n; j++)&#123; // 对目前存在每一位相乘 int tmp = a[j] * b + w; //这样写不用担心,个位多了后十位先进了x,然后十位原有y,结果为(x+y)*b的情况 //因为这样写,十位是同时处理的,而不是像a[j++]先在十位加上w后,再在加上w的基础上*b a[j] = tmp %10; w = tmp / 10; &#125; while( w != 0)&#123; //比原来n位,进位的情况 a[ *n ] = w %10; w /= 10; (*n) ++; //这边出现了个运算优先级的问题 &#125;&#125;void Print_Factorial ( const int N )&#123; if( N &lt; 0 ) &#123; printf(\"Invalid input\"); return ; &#125; int a[10000]=&#123;0&#125;; a[0] = 1; int n = 1; //位数 for(int i=2; i &lt;= N;i++)&#123; //阶乘的数目 , 从2开始,可以少算1个1 , 结果一样 mutliply(a,&amp;n,i); &#125; for(int i= n-1 ;i &gt;= 0; i--) printf(\"%d\",a[i]); // 逆序输出数字 &#125; 关于++ 和取地址符*的优先级顺序 1.30 蛇皮卡排序题 6-11 求自定类型元素序列的中位数 开始用冒泡算法，最后一个测试点过不去 用快速排序，最后一个测试点过不去，数据太多数相同；数据特殊导致时间复杂度退化。 用希尔排序，ac 我的代码: 选择排序 12345678910111213141516ElementType Median( ElementType A[], int N )&#123; for(int i= 0; i&lt; N-1 ; i++)&#123; int nmax = i; for( int j = i+1;j&lt;N;j++)&#123; if( A[nmax] &lt; A[j] ) nmax = j; &#125; if( nmax != i )&#123; int tmp = A[i]; A[i] = A[nmax]; A[nmax] = tmp; &#125; &#125; return A[ N /2 ];&#125; 运行后PE… 搜了题解,发现全部用的是 希尔排序(shell_sort) 希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序 同时该算法是冲破O(n2）的第一批算法之一 关于希尔排序increment（增量）的取法 增量increment的取法有各种方案。最初shell提出取increment=n/2向下取整，increment=increment/2向下取整，直到increment=1。但由于直到最后一步，在奇数位置的元素才会与偶数位置的元素进行比较，这样使用这个序列的效率会很低。后来Knuth提出取increment=n/3向下取整+1.还有人提出都取奇数为好，也有人提出increment互质为好。应用不同的序列会使希尔排序算法的性能有很大的差异。 原文：https://blog.csdn.net/weixin_37818081/article/details/79202115 题解: 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 题解一ElementType Median( ElementType A[], int N)&#123; int i, j, Increment; ElementType Tmp; //将数组排序 for ( Increment = N / 2; Increment &gt; 0; Increment /= 2)&#123; for ( i = Increment; i &lt; N; i++)&#123; Tmp = A[ i ]; for (j = i;j &gt;= Increment ; j -= Increment )&#123; if ( Tmp &lt; A[ j - Increment ]) A[ j ] = A[ j - Increment ]; else break; &#125; A[ j ] = Tmp; &#125; &#125; return A[ N / 2 ];&#125;// 题解二:void shell_sort(ElementType A[],int N);ElementType Median(ElementType A[],int N)&#123; if(N==1) return A[0]; shell_sort(A,N); return A[N/2];&#125;void shell_sort(ElementType A[],int N)&#123; int i,j,gap; // 三层循环 for(gap=N/2;gap&gt;0;gap/=2) for(i=gap;i&lt;N;i++) for(j=i-gap; j&gt;=0 &amp;&amp; A[j]&gt;A[j+gap] ; j-=gap)&#123; // 交换位置 ElementType temp=A[j]; A[j]=A[j+gap]; A[j+gap]=temp; &#125;&#125; 判断奇偶性 1234int even( int n )&#123; return n%2==0; // 由于优先级原因, 不能写成 return !n%2;&#125; 6-13 折半查找 题目要求 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;#define MAXSIZE 50typedef int KeyType;typedef struct&#123; KeyType key;&#125; ElemType;typedef struct&#123; ElemType *R; int length;&#125; SSTable;void Create(SSTable &amp;T)&#123; int i; T.R=new ElemType[MAXSIZE+1]; cin&gt;&gt;T.length; for(i=1;i&lt;=T.length;i++) // 注意这边构造的时候,下标是从1开始的, // 所以下面写二分搜索的LOW,HIGH也需要相应的改 cin&gt;&gt;T.R[i].key;&#125;int Search_Bin(SSTable T, KeyType k);int main ()&#123; SSTable T; KeyType k; Create(T); cin&gt;&gt;k; int pos=Search_Bin(T,k); if(pos==0) cout&lt;&lt;\"NOT FOUND\"&lt;&lt;endl; else cout&lt;&lt;pos&lt;&lt;endl; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// 题解int Search_Bin(SSTable T, KeyType k)&#123; int low = 1 , high = T.length ; // 下标是 1, N int m; while( low &lt;= high)&#123; m = (low+high) / 2; if ( T.R[m].key == k ) return m ; else if (k&lt; T.R[m].key ) high = m-1; else low = m+1; &#125; return 0;&#125;// 数据结构书上#include &lt;cstdio&gt;int binsearch(int a[],int N,int k)&#123; int low=0 ,high = N -1; // 下标是 0 , N-1 int m; while( low&lt;=high)&#123; m = (low +high ) /2 ; if( a[m] &lt; k) low = m+1; else if( a[m] &gt; k) high = m -1; else return m; &#125; return -1;&#125;int main()&#123; int a[10]; int N; scanf(\"%d\",&amp;N); for(int i= 0 ;i&lt;N ;i++) scanf(\"%d\",&amp;a[i]); int k; scanf(\"%d\",&amp;k); int pos = binsearch(a,N,k); if( pos == -1) printf(\"NOT FOUND\"); else printf(\" index is : %d\",pos); return 0;&#125; 1.31 编程题 厘米换算英尺英寸 1234567891011#include&lt;cstdio&gt;int main()&#123; int N; while( scanf(\"%d\",&amp;N) == 1)&#123; int foot = N / 30.48; int inch = 12 * ( N / 30.48 - foot); // 这边的 N / 30.48 结果并不是整数 , 而是double类型的 printf(\"%d %d\\n\",foot, inch); &#125; return 0;&#125; 7-2 然后是几点 题目考察了对提取不同位数,再组合的能力 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;int main()&#123; int x,y; while( scanf(\"%d%d\",&amp;x,&amp;y) == 2)&#123; int hour_split = x/100; int reminderm = y % 60 + x%100; int moreh = reminderm / 60 ; int h = hour_split+ y / 60 + moreh; int leftm = reminderm % 60; printf(\"%d\\n\", h * 100 + leftm); &#125; return 0;&#125;// 由于第一种没有考虑到负数的情况,所以改进就额外加了个if#include &lt;cstdio&gt;int main()&#123; int x,y; int minush = 0; int h ; int moreh ; while( scanf(\"%d%d\",&amp;x,&amp;y) == 2)&#123; int hour_split = x/100; // 根据x切割出原来的小时 int reminderm = y % 60 + x%100; // 根据提供的流逝分钟数,找到结合x,y分钟数的结果 int leftm = reminderm % 60; // 区别主要是负数时要限制 , 题解也是如此思路 //分钟在0-60之内,小时减去相应的值, 但是得考虑-20, y/60==0的情况 if( leftm &lt; 0 )&#123; moreh = reminderm / 60 - 1; int minusm = 60 + leftm ; // 由于leftm &lt; 0 且 在0-60之内,所以minusm在0-60之内 h = hour_split+ y / 60 + moreh ; printf(\"%d\\n\", h * 100 + minusm ); &#125;else&#123; moreh = reminderm / 60 ; h = hour_split+ y / 60 + moreh; printf(\"%d\\n\", h * 100 + leftm ); &#125; &#125; return 0;&#125; 题解 1234567891011121314151617181920212223#include&lt;stdio.h&gt; int main()&#123; int basis, add; scanf(\"%d %d\", &amp;basis, &amp;add); if (add &gt;= 0)//注意题干指明add可能为负的情况 &#123; int up = (basis % 100 + add) / 60; int min = (basis % 100 + add) % 60; int end = (basis / 100) * 100 + 100 * up + min; printf(\"%d\", end); &#125; else&#123; int down = (basis % 100 + add) / 60; int dmin = (basis % 100 + add) % 60; int end = (basis / 100) * 100 + 100 * down - 100 + 60 + dmin; // 对小时的操作 (basis / 100) * 100 + 100 * down - 100 , 多了个减100,即-20/60==0的情况 // 对分钟的操作 60 + dmin 限制在 0-60之内 printf(\"%d\", end); &#125; return 0;&#125;// 直接分两个情况讨论,更加直观 2.1 贪心专题 2.2 7-3 逆序的三位数 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main()&#123; int N; while( cin &gt;&gt; N )&#123; int a = N/100; int b= N/10%10; int c= N%10; if( c == 0)&#123; if( b==0)&#123; cout &lt;&lt; a; &#125;else&#123; cout &lt;&lt; a + b*10; &#125; &#125;else&#123; cout &lt;&lt; 100 * c +10*b + a; &#125; &#125; return 0;&#125; 2.3 DP训练 2.4 除夕过节 2.5 过年休息 2.6 字典序比较–&gt;贪心 快速幂 123456789101112long long Mode(long long a, long long b, long long mode)&#123; long long sum = 1; a = a % mode; while (b &gt; 0) &#123; if (b % 2 == 1) sum = (sum * a) % mode; // 判断是否是奇数，是奇数的话将多出来的数事先乘如sum b /= 2; a = (a * a) % mode;// 不断的两两合并再取模，减小a和b的规模 &#125; return sum;&#125; 当然有时候你可能会碰到用&amp;的运算符的代码实现，其实和这个大致相同，只不过是用&amp;操作符对b的奇偶性进行判断而已 补充:a=2 ,b=0 ,c=1 这种很简单的情况却会WA 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,c; int ans=1; while(scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c)!=EOF)&#123; //int ans = 1; if(b&gt;0)&#123; a=a%c; int h; h=b; while(h&gt;0) &#123; if(h%2==1) ans=(ans*a)%c; h=h/2; a=(a*a)%c; &#125;// if(b==0 &amp;&amp; c==1)// cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl; &#125; else if(b==0 &amp;&amp; c==1) cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; else if(b==0 &amp;&amp; c!=1) cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; &#125; return 0; &#125; &amp;的操作符： 二进制位中，1 &amp; 1 = 1，其余组合均为0 123456789101112long long Mode(long long a, long long b, long long mode)&#123; long long sum = 1; while (b) &#123; if (b &amp; 1) &#123; sum = (sum * a) % mode; b--; &#125; b /= 2; a = a * a % mode; &#125; return sum;&#125; 2.7 数据记录: 65536 2162^{16}216 4 294 967 296 2322^{32}232 unsigned int 0～4294967295 int -2147483648～2147483647 （10位） unsigned long 0～4294967295 long -2147483648～2147483647 long long的最大值 9223372036854775807 （19位） long long的最小值： -9223372036854775808 unsigned long long的最大值 1844674407370955161 __int64的最大值 9223372036854775807 __int64的最小值： -9223372036854775808 unsigned __int64的最大值 18446744073709551615 一个由C/C++编译的程序占用的内存分为以下几个部分 1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另 一块区域。 程序结束后由系统释放。 4、文字常量区 —常量字符串就 是放在这里的。 程序结束后由系统释放 5、程序代码区—存放函数体的二进制代码。 12345678910111213141516#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int c[20000][20000]; //在本人环境中全局数组能开到20000*20000int main()&#123; int b[1024*505]; int b2[700*700]; char a[4*518028]; int b1[500000]; //5*10^5 函数中的char数组最大能开4*518028，int最大能开到518028。 static int c[20000][20000]; //static能开到10^7*10^7。 注意 static和 全局开的是同一块空间 printf(\"1\");&#125;; 四舍五入,小数点位数 修改C++的输出流， 对小数会进行四舍五入 c++默认的流输出数值有效位是6，包括整数和小数，若数值超出6位，则第七位四舍五入到6位数 fixed ：浮点值显示为定点十进制。 默认是小数6位数，不包含整数，若小数位超出6位，则四舍五入到6位数 123456789101112131415161718192021222324252627282930#include &lt;iomanip&gt;// 需要引入这个头文件#include &lt;iostream&gt;using namespace std;int main()&#123; double PI = -3.14125001; cout &lt;&lt; setprecision(5); cout &lt;&lt; PI; return 0;&#125;// &gt;&gt;&gt; -3.1413int main()&#123; double PI = -3.14125001; cout&lt;&lt; setiosflags(ios::fixed); // ▲ cout &lt;&lt; setprecision(5); cout &lt;&lt; PI; return 0;&#125;// &gt;&gt;&gt; -3.14125/*拓展：如果与setiosnags(ios::scientific)合用， 可以控制指数表示法的小数位数。setiosflags(ios::scientific)是用指数方式表示实数。cout &lt;&lt; setiosflags(ios::scientific) &lt;&lt; setprecision(3);&gt;&gt;&gt; -3.141e+000*/ 1.setprecision(n)指定一个浮点数的精度默认设置输出的数字的总位数为n，包含整数和小数部分；其中setprecision（0）效果是跟c++默认的流输出数值一样，有效位是6位，包括整数和小数 2.fixed：必须与setprecision(n)配合使用，用来控制小数位数，不够补0，只要写一次fixed，后面的setprecision（n）就都是指小数了。 fixed与setprecision谁先谁后没有关系，但通常是fixed在前先固定6位小数（若此时小数已经超出6位，则先四舍五入到6位）再precision(n)取n位小数（n&lt;6） 3.如果与setiosnags(ios::scientific)合用， 可以控制指数表示法的小数位数。setiosflags(ios::scientific)是用指数方式表示实数。 4.resetiosflags(ios::fixed)取消精度的设置。 四舍五入进整 1234567#include &lt;iomanip&gt;int main()&#123; double PI = 3.51; cout &lt;&lt; setprecision(1); cout &lt;&lt; \"PI:\" &lt;&lt; PI; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"},{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"12-27 Team Leader","slug":"12-27-Team-Leader","date":"2019-01-19T12:40:37.000Z","updated":"2019-09-15T08:07:30.906Z","comments":true,"path":"2019/01/19/12-27-Team-Leader/","link":"","permalink":"https://nymrli.top/2019/01/19/12-27-Team-Leader/","excerpt":"","text":"How Is An Excellent Team Leader A couple of days ago, my friend and I took part in a science and technology competition which was completed by a team of four. Usually, The person who can come up with the best idea is the caption, leading or so-called principal. For the reason, I was the principal of the team which consists of the same teammates last time. And this time, someone came up with a better idea, so the principal changed and not me. I’m not saying that changing is bad, or that I’m unsatisfied with it that I didn’t continue to play such an important role. At the beginning, everything is ok and everyone is full of fighting spirit. We have more than 30 days to finish this work, but actually the workload is only about 6 days at most. As a team that has completed several works together, we still keep the excellent habit of meeting and discussing regularly. Maybe it isn’t as important as the last one, or maybe the division is so clear that nothing has to be discussed always. Everyone has his work, and takes responsibility to his own job, so it seems very easy to solve the project. In fact, we spent lots of time laughing and talking together and fussing around trifles, instead of really discussing the problem. There was nothing wrong at that time. The problem occurred three days before the start of the evaluation. Everyone had finished his own work and waited to consolidate the modules and summarize all the work. This is a good proposal, but if fact, two people are debugging the code, while the other two people are working at their own job, can this be called discussion or teamwork? It’s natural to do with their own things if they have finished what they should do. However, what makes me angry is that we are both up to my ears in work while the others who are free feel nothing to do with himself. We hoped they could come to our aid, but they even didn’t understand what was wrong and not to mention what to do. To sum up, there was a communication problem which reflected in the form of failing to cope with work’s distribution. I have said just now that the division is very clear and easy. There were four people in the competition team, but the work was divided into three modules: SCM, machine learning, and Web services. So it’s enough for three people to do this and we felt easy and relaxed also. Nobody complained about there was somebody doing nothing. But maybe when it comes to the principal, the condition is different. First of all, as a team leader, he may be criticized if he doesn’t do anything. This is still a small matter. The most important thing is efficiency. What really pissed me off that night was that the summary didn’t end from 8:30 p.m. to 11:00 p.m., and the biggest reason was that no one knew exactly how to tackle it. And that lies about the principal. Although, he did a good job in the report which needs the structural diagram of the whole work and even designed the flow chart. The project needed supervision and urging, and he had completed it well. Every weekend, he tries to organize the gather everyone. Also, he gets on well with teammates and so on. It can be said he is basically qualified. However, I must pointed out that he is not a good leader by no means. First of all, he only did the things required by the competition, such as the system block diagram, but he did not manage the division of labor and summary of each of us in length. What’s more, he only organized and attended each discussion symbolically. He neither discussed the project with any purpose nor proposed any better suggestion. He organized the discussion formally for several times and seemed quite responsible. But that’s a waste of time, in my view, the biggest difference between a responsible person and no responsible person is reflected in the organization. A good organization can improve the efficiency, while a poor organization is just dispensable or even wasteful. It wasn’t as easy as I thought it would be that day. Eventually, it took us three more meetings before we actually assembled the work. During this period, I couldn’t bear to give suggestions to principal that You can do nothing, but you have to know our progress and what we are doing. ‘Of course,’ he replied. ‘that’s why I come to every discussion, just to get a sense of where you’re going,or I don’t have to come.’ I was speechless, for there seemed to be nothing wrong with it. The biggest conflict occurred the night before the game, when a module that had been available suddenly broke down. After several previous quarrels, it was difficult for me and principal to discuss together. But this is a very serious question, how to make decisions now. Do it the same as before? Or abandon all the previous modules to implement the worst solution? After I put forward the proposal of starting again as soon as possible, he finally led the people to carry out the worst plan. And this is without my knowledge. They followed worked on worst plan all afternoon, and all looked very frustrated. I realized that they didn’t follow my plan until they said they had a problem that was a little difficult to solve. I was so angry that I called them and asked them why they didn’t do what I said. They were vague, and I called them names because I thought they could do it if they did what I told them. So, I immediately met with them, it was raining, the atmosphere was very depressed, the leader did not speak, the other two players looked very depressed. At that time, I tried not to shout at the wrong leader. and first I stressed that we could definitely make it if we continued to do it. After inspiring for a while, everyone seemed quite motivated, so I immediately lead them to try in this direction. Fortunately, we solved the problem again in less than two hours. What I want to say is that all teams will confront with difficulties, and then there must be a strong and confident person to lead the team to a good direction, rather than thinking about how not to lose his face and take a not smart solution. Later, the principal reflected it was tight at that time, and we had some conflicts before, so he did not want to prove that he could not solve the problem. That’s the whole story, a very verbose story. I’m not talking about how good I am at what I do. I want to emphasize that as a good leader, one must think for the team and improve the efficiency of the team fundamentally, instead of wasting everyone’s time by being formalistic. And As a leader of a team it’s important that the first thing that comes to mind is how to solve the problem better, instead of escaping from the trouble. I just want to save my face and make a bad but not wrong decision. Last but not least, full of confidence and fighting spirit, can actively lead the team to success. If you do not believe in yourself, how can you let others believe in yourself. Further, the ideal leader, in addition to giving a good direction of effort, but also can help members solve the actual problems encountered, of course, this is difficult and just the ideal situation. Because it is difficult for anyone to understand all aspects, I dare to make such a decision this time, and I am confident that I can succeed in doing so, largely because I known about the modules which everyone should be responsible for. This is what I learned from this competition, what I understand the responsible leader should behave like.Thanks.","categories":[],"tags":[{"name":"English Speaking","slug":"English-Speaking","permalink":"https://nymrli.top/tags/English-Speaking/"},{"name":"生活小记","slug":"生活小记","permalink":"https://nymrli.top/tags/生活小记/"}]},{"title":"阿里云nginx+wsgi部署flask","slug":"阿里云nginx-wsgi部署flask","date":"2019-01-17T13:33:14.000Z","updated":"2019-10-23T11:46:35.930Z","comments":true,"path":"2019/01/17/阿里云nginx-wsgi部署flask/","link":"","permalink":"https://nymrli.top/2019/01/17/阿里云nginx-wsgi部署flask/","excerpt":"","text":"云服务器nginx+wsgi部署flask 更新源 12sudo apt-get update -ysudo apt-get upgrade -y 安装nginx 123sudo apt-get install nginx -ysudo /etc/init.d/nginx start #(start可以改成restart/stop)#或是sudo service nginx start 然后浏览器输入服务器IP或是127.0.0.1,观察是否有welcom to nginx! 安装py3和virtualenv 12sudo apt-get install git python3 python3-pip -ysudo pip3 install virtualenv 修改python版本: 法一:(不建议) 123456789$ gedit ~/.bashrc #gedit .bash_aliases在顶部加入一行alias python=python3$ source ~/.bashrc #或是source ~/.bash_aliases o$ python --version就会发现是Python 3.5.2啦/*orOpen your .bashrc file nano ~/.bashrc. Type alias python=python3 on to a new line at the top of the file then save the file with ctrl+o and close the file with ctrl+x. Then, back at your command line type source ~/.bashrc. Now your alias should be permanent.*/ Ubuntu16.04切换python3和python2 ▲.切换Python3为默认版本：(建议) 12sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 切换Python2为默认版本： 1$ sudo update-alternatives --config python 安装虚拟环境 virtualenv 123$ cd /var/www# 最好指定下python解释器$ sudo virtualenv -p /usr/bin/python3 env35 pipenv 1$ pipenv install MySQL 123456789$ sudo apt install mysql-server mysql-client -y$ cd /etc/mysql/mysql.conf.d$ mysql -p -u root&gt; password for root:&gt; use mysql;&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;&gt; flush privileges; 最后按Ctrl + z 退出 安装、测试uwsgi 1$ sudo pip3 install uwsgi 编辑/var/www下的uwsgi.ini 123456789101112[uwsgi]chdir=/home/apollo3d/Documents/Beidou wsgi-file=wsgi.pyhome=/home/apollo3d/Documents/envcallable=app; master=Trueprocesses=10socket= :81chmod socket=666vacuum=Truemax-requests=5000#pythonpath=/var/www/env 编辑/var/www下的nginx.conf 1234567891011121314server &#123; listen 80; server_name 127.0.0.1; charset utf-8; client_max_body_size 75M; location /static&#123; alias /home/apollo3d/Documents/Beidou/static; &#125;location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:81;# uwsgi_param UWSGI_PYHOME /home/apollo3d/Documents/Beidou/env; uwsgi_param UWSGI_SCRIPT app:app; # 启动flask的文件:Flask的实例&#125; 2004/10/20 | 编辑/var/www下的uwsgi_params 12345678910111213141516uwsgi_param QUERY_STRING $query_string;uwsgi_param REQUEST_METHOD $request_method;uwsgi_param CONTENT_TYPE $content_type;uwsgi_param CONTENT_LENGTH $content_length; uwsgi_param REQUEST_URI $request_uri; uwsgi_param PATH_INFO $document_uri; uwsgi_param DOCUMENT_ROOT $document_root; uwsgi_param SERVER_PROTOCOL $server_protocol; uwsgi_param REQUEST_SCHEME $scheme; uwsgi_param HTTPS $https if_not_empty; uwsgi_param REMOTE_ADDR $remote_addr; uwsgi_param REMOTE_PORT $remote_port; uwsgi_param SERVER_PORT $server_port; uwsgi_param SERVER_NAME $server_name; 软连接 1234$ rm /etc/nginx/sites-enabled/default$ cd /etc/nginx/sites-enabled$ sudo ln -s /var/www/nginx.conf Beidou$ ls 重启nginx sudo /etc/init.d/nginx restart 运行uwsgi 12cd /var/wwwuwsgi --ini uwsgi.ini 让uwsgi自启动 vim /etc/rc.local(注意非虚拟环境也得安装uwsgi模块) 123添加下面代码:/usr/local/bin/uwsgi --ini /var/www/uwsgi.iniexit 0 uwsgi的热启动 在uwsgi.ini中加入 py-autoreload=1 重启一下:killall -9 uwsgi、/usr/local/bin/uwsgi --ini /var/www/uwsgi.ini 总结 关于etc/ linit. d 如果你使用过inux系统,那么你一定听说过 init. d目录,这个目录到底是干嘛的呢?它归根结底只做了一件事情,但这件事情非同小可,是为整个系统做的,因此它非常重要。init.d目录包含许多系统各种服务的启动和停止脚本 关于 /etc/rc.local rc.local也是我经常使用的一个脚本,该脚本是在系统初始化级别脚本运行之后再执行的,因此可以安’, '地在里面添加你想在系统启动之后执行的脚本. 总结 Linux是灵活的,正因为它的灵活性,我们总是可以找到许多不同的办法来解决同一个问题，服务的例子就是一个很好的佐证,有了 /etc/init.d目录下的脚本,再加上 /etc/rc. local这个利器，你可以放心的确保你的服务可以完美的启动和运行 /etc/nginx/sites-available/default 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586### You should look at the following URL&apos;s in order to grasp a solid understanding# of Nginx configuration files in order to fully unleash the power of Nginx.# http://wiki.nginx.org/Pitfalls# http://wiki.nginx.org/QuickStart# http://wiki.nginx.org/Configuration## Generally, you will want to move this file somewhere, and start with a clean# file but keep this around for reference. Or just disable in sites-enabled.## Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.### Default server configuration#server &#123; listen 80 default_server; listen [::]:80 default_server; # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; # # Note: You should disable gzip for SSL traffic. # See: https://bugs.debian.org/773332 # # Read up on ssl_ciphers to ensure a secure configuration. # See: https://bugs.debian.org/765782 # # Self signed certs generated by the ssl-cert package # Don&apos;t use them in a production server! # # include snippets/snakeoil.conf; root /var/www/html; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html; server_name _; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; &#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # include snippets/fastcgi-php.conf; # # # With php7.0-cgi alone: # fastcgi_pass 127.0.0.1:9000; # # With php7.0-fpm: # fastcgi_pass unix:/run/php/php7.0-fpm.sock; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125;# Virtual Host configuration for example.com## You can move that to a different file under sites-available/ and symlink that# to sites-enabled/ to enable it.##server &#123;# listen 80;# listen [::]:80;## server_name example.com;## root /var/www/example.com;# index index.html;## location / &#123;# try_files $uri $uri/ =404;# &#125;#&#125;","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"前端Vue框架学习","slug":"前端Vue框架学习","date":"2019-01-17T12:47:22.000Z","updated":"2022-02-24T12:33:14.145Z","comments":true,"path":"2019/01/17/前端Vue框架学习/","link":"","permalink":"https://nymrli.top/2019/01/17/前端Vue框架学习/","excerpt":"","text":"前端Vue框架学习(未完) MVVM模型 vueify介绍 所谓vueify，就是使用.vue格式的文件定义组件，一个.vue文件就是一个组件。 在.vue文件定义的组件内容包括3部分： &lt;style&gt;&lt;/style&gt;标签：定义组件样式 &lt;template&gt;&lt;/template&gt;标签：定义组件模板 &lt;script&gt;&lt;/script&gt;标签：定义组件的各种选项，比如data, methods等。 Vue生命周期 使用Vue的初次操作 创建一个Vue实例 123456var c = new Vue(&#123; //初始化一个Vue对象 el: '#box', //对象,后面跟的是选择器 el(是element缩写, 指定挂载vue示例的元素 data : &#123; //数据成员,必须用关键字data msg:'welcome' &#125;&#125;) 完整的html页面 1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; window.onload=function (ev) &#123; new Vue(&#123; el: '#box', data:&#123; msg:'hello' &#125; &#125;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\"&gt; &#123;&#123;msg&#125;&#125; &lt;!--&lt;li&gt;&lt;/li&gt;--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注：template必须有且只能有一个div 常用指令 v-model一般是放在表单中,实现了双向绑定 123456//如上初始化一个Vue实例&lt;div id='box'&gt; &lt;input type='text' v-model=\"msg\" &gt; //\"双向绑定\",修改输入框内容,msg内容也会改变 &lt;br&gt; &#123;&#123;msg&#125;&#125;&lt;/div&gt; v-model 被称为 Vue 的指令，指令可以用来做很多事，比如用于 if 条件判断的 v-if，用于绑定值的 v-bind、用于绑定监听事件的 v-on 等等，这在以后会接触到。而这个 v-model 指令的作用是将 input 元素 value 属性的值和我们创建的 Vue 对象中 value 的值进行绑定，我们知道 input 有一个 value 属性，它的值会在浏览器显示（例如后面那个 button 按钮的发送），Vue 将这个值绑定后，在 input 中引起的 value 值变化就会实时反映到关联的 Vue 对象，所以会看到下方引用的 也会跟着变化。 v-repeat===&gt;v-for=&quot;变量名 in 数组&quot; 使用变量的话,使用索引 1234567/* data:&#123;msg:'hello',array:['he','bo','ce']&#125;*/&lt;li v-for=\"value in array\"&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt; v-text 设置标签的文本 1234567891011&lt;div id=&quot;app&quot;&gt; &lt;h2 v-text=&quot;message&quot;&gt;&lt;/h2&gt; // 缺点是会将元素内的所有内容都替换成message &lt;h2&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt; // 插值表达式优点是可以拼接加表达式，更灵活&lt;/div&gt;var app = new Vue(&#123; el: &quot;#app&quot;, data:&#123; message: &quot;Hello&quot; &#125;&#125;) v-html 设置标签的innerHTML， 如果设置的是普通文本则效果跟v-text相同，如果是html语法则会被正确解析 1234567891011121314151617// vue3&lt;div id=&quot;example1&quot; class=&quot;demo&quot;&gt; &lt;p&gt;使用双大括号的文本插值: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt; &lt;p&gt;使用 v-html 指令: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; &lt;script&gt;const RenderHtmlApp = &#123; data() &#123; return &#123; rawHtml: &apos;&lt;span style=&quot;color: red&quot;&gt;这里会显示红色！&lt;/span&gt;&apos; &#125; &#125;&#125; Vue.createApp(RenderHtmlApp).mount(&apos;#example1&apos;)&lt;/script&gt; v-on侦听Dom事件 因为 Vue 并不知道我们点击了按钮，为了让 Vue 监听到我们点击按钮的事件，需要在被点击的元素上绑定一个 click 事件，前面说过绑定事件用 v-on。代码如下 123456789101112131415161718window.onload=function () &#123; new Vue(&#123; el: &apos;#box&apos;, data:&#123; msg:&apos;hello&apos;, array:[&apos;he&apos;,&apos;bo&apos;,&apos;ce&apos;] &#125;, methods :&#123; //注意是methods , 而不是method show:function () &#123; alert(1); &#125; &#125; &#125;) &#125; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-on:click=&quot;show()&quot;&gt; &lt;/body&gt; 除了能绑定click以外，v-on还能绑定如下事件： click @click.stop： 阻止冒泡事件 @click.prevent: 阻止默认事件 mousedown dblclick mouseover mouseout 注：v-on:click=func()可以直接省略写成@click=&quot;func()&quot; v-bind 用于绑定属性（值、类……），跟v-on一样有省略写法， v-bind:class–&gt;:class= 123456&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-bind:class=&apos;&#123;empty: !count&#125;&apos; v-model=&quot;value&quot;&gt; ...&lt;/div&gt; Vue 会根据 empty 后的表达式 !count 的真假来判断 class 的值是否为 empty，如果为真（即 count = 0 的情况），则 class 的值为 empty，否则为空。 v-for 一般运用在&lt;ul&gt;, &lt;ol&gt;上， 如&lt;ul v-for=&quot;(item, index) in todoList&quot; :key=&quot;index&quot; &gt; 123&lt;li v-for=&quot;item in arr&quot;&gt; &#123;&#123; item &#125;&#125;&lt;/li&gt; 123 &lt;li v-for=&quot;(item, index) in arr&quot;&gt; &#123;&#123; index, item &#125;&#125;&lt;/li&gt; 注：在v-for中必须要有:key，这个是li的标识符以区别， 一般是设置为索引。 v-if 可以运用在v-for的单个item下， 如&lt;li v-if=&quot;item.done === true&quot;&gt; 1234567&lt;ol class=&quot;demo-box&quot; v-for=&quot;(item, index) in todoList&quot; :key=&quot;index&quot;&gt; &lt;li v-if=&quot;item.done === false&quot;&gt; &lt;input type=&quot;checkbox&quot; @change=&quot;changeTodo(index, true)&quot;&gt; &lt;p&gt;&#123;&#123;item.todo&#125;&#125;&lt;/p&gt; &lt;a @click=&quot;deleteTodo(index, true)&quot;&gt;-&lt;/a&gt; &lt;/li&gt;&lt;/ol&gt; 注： v-if是直接的切换结构，所以通过变量来显示显示和隐藏 ==&gt;v-show是个更好的选择（只能控制一个元素的显示） v-slot slot的作用是指定占位符，留下插槽让其他的内容填充进来 1234567891011&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 在向具名插槽提供内容的时候，有个等价的写法： 我们可以在一个 &lt;template&gt; 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称： Vue3（其实从2.6开始）中引入了一个新的指令v-slot，用来表示具名插槽和默认插槽 123456789101112131415161718&lt;!-- default slot --&gt;// slot占位, modal.vue&lt;slot&gt;&lt;/slot&gt;// slot模板, used.vue&lt;foo v-slot=\"&#123; msg &#125;\"&gt; &#123;&#123; msg &#125;&#125;&lt;/foo&gt;&lt;!-- named slot --&gt;// slot占位, modal.vue&lt;slot name=\"one\"&gt;&lt;/slot&gt;// slot模板, used.vue&lt;foo&gt; &lt;template v-slot:one=\"&#123;msg&#125;\"&gt; &#123;&#123; msg &#125;&#125; &lt;/template&gt; &lt;/foo&gt; 插槽指令的缩写： 和 v-bind(:attr)和v-on(@func)相似，缩写只有在存在参数时才生效，这就意味着v-slot没有参数时不能使用#xx=yy。对于默认插槽，可以使用#default来代替v-slot, 如#header=&quot;{ msg }&quot;=&gt;v-slot:header=&quot;{ msg }&quot; 注：注意 v-slot 只能添加在 &lt;template&gt; 上 (只有一种例外情况)，这一点和已经废弃的 slot attribute 不同。 template标签 template的作用是模板占位符，可帮助我们包裹元素，但在循环过程当中，template不会被渲染到页面上 1234&lt;template v-for=\"(item, index) in list\" :key=\"item.id\"&gt; &lt;div&gt;&#123;&#123;item.text&#125;&#125;--&#123;&#123;index&#125;&#125;&lt;/div&gt; &lt;span&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;&lt;/template&gt; 常见用途是： 将for内容提供给包含的div 为子组件占位 父子组件间通信数据 1、 父向子传递: Props 父组件有数据，需要通过子组件来展示 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt; &lt;Test :list=&quot;list&quot;/&gt; &lt;Board/&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; name: &apos;App&apos;, components: &#123; HelloWorld, Test &#125;, data()&#123; return &#123; list : [&quot;he&quot;,&quot;we&quot;,&quot;en&quot;] &#125; &#125;&#125;&lt;template&gt; &lt;ul v-for=&quot;l in list&quot; :key=&quot;l&quot;&gt; &lt;li&gt;&#123;&#123; l &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;export default (&#123; name: &quot;Test&quot;, data()&#123; return &#123; a: 1 &#125; &#125;, props:&#123; list: Array &#125;, ...&#125;) 2、子向父传递： $emit 在子组件上增添了数据，需要回传给父组件 Vue实例属性 data ▲注意区别， new App{}中的data是属性， 但component中的是函数，``dataproperty in component must be a function methods:{} computed:{} 需要通过计算得到新的变量 12345678910111213141516computed: &#123; newName: function()&#123; // 默认的设置是get方法 return this.firstName + this.lastName &#125; // 等价于 newName: &#123; get: function()&#123; // 通过原有数据产生新数据 return this.firstName + this.lastName &#125; set: function(value)&#123; // 通过新数据修改原有数据 let arr = value.split(&quot; &quot;) this.firstName = arr[0] this.lastName = arr[1] &#125; &#125;&#125; watch 12345678910111213141516data()&#123; x: 15, y: &quot;T-shirt&quot;&#125;,watch: &#123; // 被监听的对象发生变化后执行函数 x: function()&#123; if (this.x &gt;26 ) &#123; this.y = &quot;半袖&quot; &#125;else if (this.x &lt;= 26 &amp;&amp; this.x &gt; 0)&#123; this.y = &quot;T-shirt&quot; &#125;else&#123; this.y = &quot;None&quot; &#125; &#125;&#125; computed 相 watch 区别 computed是计算属性，依赖其他属性计算值，并且computed的值有缓存，只有当计算值变化才会返回内容。 watch，监听的值发生变化就会执行回调，在回调中可以进行一些逻辑操作。所以一般来说需要依赖别的属性来动态获得值的时候可以使用computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 –&gt;v-show切换上性能更好， v-if初次加载性能更好 一个较为完整的栗子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;template&gt; &lt;div&gt; &lt;header&gt; &lt;section&gt; &lt;label for=&quot;title&quot;&gt;ToDoList&lt;/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;todo&quot; @keyup.enter=&quot;addTodo&quot; placeholder=&quot;添加ToDo&quot; /&gt; &lt;/section&gt; &lt;/header&gt; &lt;section&gt; &lt;h2&gt;正在进行 &lt;span&gt;1&lt;/span&gt; &lt;/h2&gt; &lt;ol class=&quot;demo-box&quot; v-for=&quot;(item, index) in todoList&quot; :key=&quot;index&quot;&gt; &lt;li v-if=&quot;item.done === false&quot;&gt; &lt;input type=&quot;checkbox&quot; @change=&quot;changeTodo(index, true)&quot;&gt; &lt;p&gt;&#123;&#123;item.todo&#125;&#125;&lt;/p&gt; &lt;a @click=&quot;deleteTodo(index, true)&quot;&gt;-&lt;/a&gt; &lt;/li&gt; &lt;/ol&gt; &lt;h2&gt;已经完成 &lt;span&gt;&#123;&#123;todoList.length - todoLen&#125;&#125;&lt;/span&gt; &lt;/h2&gt; &lt;ul v-for=&quot;(item, index) in todoList&quot; :key=&quot;index&quot; &gt; &lt;li v-if=&quot;item.done === true&quot;&gt; &lt;input type=&quot;checkbox&quot; @change=&quot;changeTodo(index,false)&quot; checked=&apos;checked&apos;&gt; &lt;p&gt;&#123;&#123;item.todo&#125;&#125;&lt;/p&gt; &lt;a @click=&quot;deleteTodo(index,false)&quot;&gt;-&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;footer&gt;Copyright &amp;copy; 2014 todolist.cn&lt;a @click=&quot;clearData()&quot;&gt;clear&lt;/a&gt;&lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as Utils from &apos;@/utils/utils&apos;export default &#123; name: &apos;HelloWorld&apos;, props: &#123; msg: String &#125;, data () &#123; return &#123; todo: &apos;&apos;, todoList: [], todoLen: 0 &#125; &#125;, methods: &#123; addTodo () &#123; // 等价于 addTodo: function ()&#123; let todoObj = &#123; todo: this.todo, done: false &#125; var tempList = Utils.getItem(&apos;todoList&apos;) if (tempList) &#123; tempList.push(todoObj) Utils.setItem(&apos;todoList&apos;, tempList) &#125; else &#123; var tempData = [] tempData.push(todoObj) Utils.setItem(&apos;todoList&apos;, tempData) &#125; this.todoList.push(todoObj) this.todoLen++ this.todo = &apos;&apos; &#125;,deleteTodo (index, done) &#123; if(done)&#123; this.todoLen-- &#125; this.todoList.splice(index, 1) Utils.setItem(&apos;todoList&apos;, this.todoList) &#125;,changeTodo (index, done) &#123; if (done) &#123; this.todoLen-- this.todoList[index].done = true Utils.setItem(&apos;todoList&apos;, this.todoList) &#125; else &#123; this.todoLen++ this.todoList[index].done = false Utils.setItem(&apos;todoList&apos;, this.todoList) &#125;&#125;, initTodo () &#123; var todoArr = Utils.getItem(&apos;todoList&apos;) if (todoArr) &#123; for (let i = 0, len = todoArr.length; i &lt; len; i++) &#123; if (todoArr[i].done === false) &#123; this.todoLen++ &#125; &#125; this.todoList = todoArr &#125; &#125;, clearData () &#123; localStorage.clear() this.todoList = [] this.todoLen = 0 &#125; &#125;, mounted () &#123; this.initTodo() &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h3 &#123; margin: 40px 0 0;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; B教程： https://www.bilibili.com/video/BV1b54y1J77i?p=10&amp;spm_id_from=pageDriver——基础指令 https://www.bilibili.com/video/BV1EK4y1u7vk?p=31——进阶：axios、router、vuex 网络通信axios axios：官方推荐使用 教程：https://zhuanlan.zhihu.com/p/266977438 1234567891011121314 ppp()&#123; axios(&#123; url:&apos;http://123.207.32.32:8000/home/multidata&apos;, // params是针对get请求的参数拼接 params:&#123; type:&apos;pop&apos;, page：1 &#125; &#125;).then(res =&gt; &#123; console.log(res) &#125;)// 注：axios方法默认返回一个Promise对象，所以在后面可以直接用then处理请求回来的数据// method:&apos;get&apos; 设置请求的类型，默认为get&#125; GET方法: 1234567891011axios.get( &apos;http://123.207.32.32:8000/home/multidata&apos;, // params是针对get请求的参数拼接 &#123; params:&#123; type:&apos;pop&apos;, page:1&#125; &#125; ).then(res =&gt; &#123; console.log(res)&#125;) POST方法： 12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, // 参数 firstName lastName: &apos;Flintstone&apos; // 参数 lastName &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 并发请求 1234567891011function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); vue中的h函数总结 大家都知道render函数在vue中非常重要，但其实本质上执行渲染工作的是h函数，本质上也就是createElement函数！ 1234567891011121314 const app = new Vue(&#123; ··· ··· render: h =&gt; h(App) &#125;) // 等价写法 const app = new Vue(&#123; ··· ··· render:function(createElement)&#123; return createElment(App) &#125; &#125;) //参数1：要传递的组件名字//参数2：要传递组件的props，且props是什么格式，这里就尽量什么格式，如对象格式，就应该对象格式 h函数就是vue中的createElement方法，这个函数作用就是创建虚拟dom，追踪dom变化的。。。 虚拟dom简单来说就是一个普通的JavaScript对象，包含tag，props，children三个属性。。。 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;p className=\"text\"&gt;lxc&lt;/p&gt;&lt;/div&gt;// 上边的HTML代码转为虚拟DOM如下：&#123; tag:\"div\", props:&#123; id:\"app\" &#125;, children:[ &#123; tag:\"p\", props:&#123; className:\"text\" &#125;, children:[ \"lxc\" ] &#125; ]&#125;// 该对象就是所谓的虚拟dom，因为dom对象是属性结构，所以使用JavaScript对象就可以简单表示。而原生dom有许多属性、事件，即使创建一个空div也要付出昂贵的代价。// 而虚拟dom提升性能的点在于DOM发生变化的时候，通过diff算法对比，计算出需要更改的DOM，只对变化的DOM进行操作，而不是更新整个视图。。。 Good: vue 中的h函数 Vue-router 安装vue-cli和vue-router: 第一个vue程序（html集成vue）只需要script导入vue的js即可，如果是vue工程则通过vue-cli来建立 1.新建vue工程 @vue/cli-init vue init 是vue-cli2.x的初始化方式 vue init ： 需要npm i -g @vue/cli-init vue init webpack [project-name], webpack为模板&lt;generate a project from a remote template&gt;，然后按照交互信息提示输入即可完成工程创建 init创建工程时，交互信息中有一个比较有意思的是选择包管理工具： npm、yarn，两者见 @vue/cli 会让选择Vue2还是Vue3 vue create router_project: 需要npm install -g @vue/cli vue ui通过UI创建： 需要npm install -g @vue/cli vue create [project-name] 注：经测试，Vue CLI v4.5.15会提示选择yarn还是npm；@vue/cli 4.5.13没提示==&gt;后来发现貌似是平台的区别，linux上会提示选择，win上默认是yarn Vue CLI 的包名称由vue-cli已经改成了@vue/cli，如果通过vue-cli来构建Vue3项目则需要通过 npm uninstall vue-cli -g 或 yarn global remove vue-cli 卸载它，然后安装@vue/cli，并且@vue/cli安装好后，如果不安装yarn，那么在vue create创建的时候报错ERROR Error: spawn yarn ENOENT npm init vite-app hello-vue Vue3刚发布不久，官方文档中推荐的创建方法之一就是通过脚手架Vite来创建一个vue3项目 需要安装create-vite-app 123456$ npm init vite-app vue3-vite Scaffolding project in F:\\Documents\\HBuilderProjects\\vue3-vite...Done. Now run:$ cd vue3-vite$ npm install (or `yarn`)$ npm run dev (or `yarn dev`) 可以看到，这个时需要进入项目目录后，里面没有package-lock或者yarn.loca，而是需要自己主动选择包管理工具进行安装依赖的；vue create和vue init的不需要可以直接运行 @vitejs/app npm init @vitejs/app然后选择project的框架 注：2既可以创建Vue2，也可以创建vue3；3只能创建vue3；在创建速度上，法3比法2快上很多 2.编写vue组件 1234567891011121314151617181920212223242526&lt;-- HelloWord.vue --&gt;&lt;template&gt; &lt;div&gt; 你好 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default (&#123; name: &quot;Content&quot;&#125;)&lt;/script&gt; &lt;-- Content.vue --&gt;&lt;template&gt; &lt;div&gt; 你好 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default (&#123; name: &quot;Content&quot;&#125;)&lt;/script&gt; 3. 编写router 在根目录下创建router文件夹，并创建index.js文件，需要路由的组件全在这里面规定好。 123456789101112131415161718192021222324252627282930313233343536373839/* * @Author: Mrli * @Date: 2021-07-29 16:19:37 * @LastEditTime: 2021-07-29 16:45:56 * @Description: */import Vue from \"vue\"import VueRouter from \"vue-router\"import Content from \"../components/Content.vue\"import HelloWorld from \"../components/HelloWorld.vue\"Vue.use(VueRouter)export default new VueRouter(&#123; mode: \"history\", routes:[ &#123; path: \"/hello\", name: \"Hello\", component: HelloWorld &#125;, &#123; path: \"/content\", name: \"Content\", component: Content, // 路由嵌套 children: [ &#123; path:'/user/profile', component: Profile &#125;, &#123; path:'/user/userlist', component: Userlist &#125; ] &#125; ]&#125;) 4. 挂载router-view app.vue中使用路由 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;router-link to=&quot;/hello&quot;&gt;hello&lt;/router-link&gt; &lt;router-link to=&quot;/content&quot;&gt;content&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;app&apos;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 5.挂载router 将路由信息暴露给Vue实例使用, main.js 123456789101112import Vue from 'vue';import App from './App.vue';// 导入定义好的router模块import router from './router';Vue.config.productionTip = falsenew Vue(&#123; el: \"#app\", router, render: h =&gt; h(App),&#125;).$mount('#app') 注：按钮点击后跳转，在method的function中可以通过this.$router.push(&quot;/hello&quot;)跳转到指定路由。 路由嵌套 在父组件A.vue中进行路由跳转 A.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;div&gt; &lt;el-container&gt; &lt;el-aside width=&quot;200px&quot;&gt; &lt;el-menu :default-openeds=&quot;[&apos;1&apos;, &apos;3&apos;]&quot;&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;会员管理&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt; &lt;!-- 路径匹配传参：两种方式 --&gt; &lt;!-- &lt;router-link to=&quot;/member/level/2&quot;&gt;会员等级&lt;/router-link&gt; --&gt; &lt;router-link :to=&quot;&#123;name: &apos;MemberLevel&apos;, params: &#123;id:3&#125;&#125;&quot;&gt;会员等级&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt;会员积分&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-3&quot;&gt; &lt;router-link to=&quot;/member/list&quot;&gt;会员列表&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;2&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;商品管理&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;2-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-2&quot;&gt;选项2&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header style=&quot;text-align: right; font-size: 12px&quot;&gt; &lt;el-dropdown&gt; &lt;i class=&quot;el-icon-setting&quot; style=&quot;margin-right: 15px&quot;&gt;&lt;/i&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item&gt;用户中心&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;span&gt;王小虎&lt;/span&gt; &lt;/el-header&gt; &lt;!-- 重点是这行， 展示子组件 --&gt; &lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default (&#123; name: &quot;Main&quot;&#125;)&lt;/script&gt; index.js 123456789101112131415161718192021222324252627282930import Vue from \"vue\"import VueRouter from \"vue-router\"import Main from \"../views/Main\"import MemberLevel from \"../views/Member/MemberLevel\"import MemberList from \"../views/Member/MemberList\"Vue.use(VueRouter)export default new VueRouter(&#123; mode: \"history\", routes: [ &#123; name: \"main\", path: \"/main\", component: Main, children: [ &#123; name: \"MemberList\", path: \"/member/list\", component: MemberList &#125;, &#123; name: \"MemberLevel\", path: \"/member/level/:id\", component: MemberLevel &#125;, ] &#125; ] &#125;) MemberLevel.vue 12345&lt;template&gt; &lt;div&gt; 会员等级 ID: &#123;&#123; $route.params.id &#125;&#125; &lt;/div&gt;&lt;/template&gt; 如果index.js和MemberLevel.vue采用props， 则可以直接写 注： 两种方式跳转: &lt;route-link to=&quot;/member/level/3&quot;&gt;&lt;/route-link&gt; &lt;route-link :to=&quot;{name: 'MemberLevel', params: {id: 'xxx'}}&quot;&gt;&lt;/route-link&gt; --&gt;to加了冒号后，后面可以跟对象 组件重定向 重定向的意思大家都明白，但Vue中的重定向是作用在路径不同但组件相同的情况下 1234567891011//index.js &#123; name: \"Main\", path: \"/main/:name\", component: Main, ...&#125;,&#123; path: \"/goMain/:name\", redirect: \"/main/:name\"&#125; 说明：这里定义了两个路径，一个是/main，一个是/goMain，其中/goMain重定向到了/main路径，由此可以看出重定向不需要定义组件； Main.vue 12345&lt;el-menu-item index=&quot;1-3&quot;&gt; &lt;router-link to=&quot;/goMain/admin123&quot;&gt;回到首页&lt;/router-link&gt;&lt;/el-menu-item&gt;&lt;span&gt;&#123;&#123; $route.params.name &#125;&#125;&lt;/span&gt; 整合ElementUI Vue只关注视图层，但没有UI界面， 类似Bootstrap： Bootstrap 是个 css框架，类似jqueryMoblie一样,只需要给标签加class就行了。Bootstrap 需要 .css + .js ，由于依赖jqery,所以需要将jquery.js也导入 ElementUI教程 安装： 1234567891011121314# 创建好工程vue create &lt;projectName&gt;# 安装elementUInpm i element-ui -S# npm install vue-router --save-dev# 以下的在上述无法渲染的情况下添加# 安装Sass加载器（webpack加载器）和node-sass(scss--&gt;css)npm install sass-loader node-sass --save-dev# 注windows下安装sass如果失败，则因为原因缺少缺少编译环境python2，需要做以下设置npm install -g node-gypnpm install --global --production windows-build-toolsnpm install node-sass --registry=http://registry.npm.taobao.org main.js 1234567891011121314import ElementUI from \"element-ui\";import 'element-ui/lib/theme-chalk/index.css'; // 这行import很重要， 不然渲染不出来import Vue from 'vue';import App from './App.vue';import router from \"./router\";Vue.use(ElementUI)Vue.config.productionTip = falsenew Vue(&#123; el: \"#app\", router, render: h =&gt; h(App),&#125;).$mount('#app') App.vue 1234567891011121314&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;router-link to=&quot;hello&quot;&gt;hello&lt;/router-link&gt; &lt;router-link to=&quot;login&quot;&gt;login&lt;/router-link&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;App&apos;,&#125;&lt;/script&gt; Login.vue 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;80px&quot;&gt; &lt;el-form-item label=&quot;活动名称&quot;&gt; &lt;el-input v-model=&quot;form.name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;活动区域&quot;&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Login&quot;, data()&#123; return &#123; form: &#123; name: &quot;&quot; &#125; &#125; &#125;&#125;&lt;/script&gt; router.js 123456789101112131415161718192021import Vue from \"vue\"import VueRouter from \"vue-router\"import HelloWorld from \"../components/HelloWorld\"import Login from \"../views/Login\"Vue.use(VueRouter)export default new VueRouter(&#123; mode: \"history\", routes: [ &#123; name: \"login\", path: \"/login\", component: Login &#125;, &#123; name: \"Hello\", path: \"/hello\", component: HelloWorld &#125; ] &#125;) Vuex 状态管理库， 可看作是管理会话的数据库 通过在根实例App中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到（如果在函数中自带this指针，则可以直接写成store.state.xxx）。 1.创建store文件夹， 定义js文件 在根目录创建store文件夹， 然后创建index.js 关于js定义有两种： 普通： 123456789101112131415161718192021222324252627282930313233343536// index.jsimport Vue from \"vue\"import Vuex from \"vuex\"Vue.use(Vuex)// 全局state对象， 用于保存所有组件的公共数据const state = &#123; user : &#123; name: \"\" &#125;&#125;// 监听state对象的值的最新状态（计算属性）const getters = &#123; getUser(state)&#123; return state.user &#125;&#125;// 唯一可以修改state对象的值的最新状态(同步阻塞方法)const mutations = &#123; updateUser(state, user)&#123; state.user = user &#125;&#125;// 异步执行mutations方法const actions = &#123; asyncUpdateUser(context, user)&#123; context.commit(\"updateUser\", user) &#125;&#125;export default new Vuex.Store(&#123; state, getters, mutations, actions&#125;) 模块化 将对某个对象数据的管理视为一个模块，因此在store文件夹下还需要创建modules文件夹，并创建相应的模块js 12345678910111213141516171819202122232425262728293031323334353637383940// index.jsimport Vue from \"vue\"import Vuex from \"vuex\"import user from \"./modules/user\"Vue.use(Vuex)export default new Vuex.Store(&#123; modules:&#123; user &#125;&#125;)// modules/user.jsconst user = &#123; // 全局state对象， 用于保存所有组件的公共数据 state :&#123; user : &#123; name: \"\" &#125; &#125;, // 监听state对象的值的最新状态（计算属性） getters :&#123; getUser(state)&#123; return state.user &#125; &#125;, // 唯一可以修改state对象的值的最新状态(同步阻塞方法) mutations :&#123; updateUser(state, user)&#123; state.user = user &#125; &#125;, // 异步执行mutations方法 actions :&#123; asyncUpdateUser(context, user)&#123; context.commit(\"updateUser\", user) &#125; &#125;,&#125;export default user; 2. 导入main.js中 3. 使用vuex 工具 调试工具：chrome应用商城搜索vue-devtools 开发工具：HBuilderX：工具篇之HBuilderX使用教程 附录： 什么是Vue.use()? Vue实例通过Vue.use() 来装载插件，从而用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种： 添加全局方法或者 property。如：vue-custom-element 添加全局资源：指令/过滤器/过渡等。如 vue-touch 通过全局混入来添加一些组件选项。如 vue-router 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router 注：通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue() 启动应用之前完成： 开发插件 Vue.js 的插件应该暴露一个 install 方法，即XxxxPlugin.install = function (Vue, options) {}。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： 123456789101112131415161718192021222324252627MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或 property Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive(&apos;my-directive&apos;, &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125; Q: 为什么axios不用？ Q:相信很多人在用Vue使用别人的组件时，会用到 Vue.use() 。例如：Vue.use(VueRouter)、Vue.use(MintUI)。但是用 axios时，就不需要用 Vue.use(axios)，就能直接使用。那这是为什么呐？ A:因为 axios 没有 实现install方法，即axios并不是Vue插件，他并不是特地为Vue服务的网络通信库，而是通用的库。 所以为了Vue实例能够全局使用axios，采取的方法是将axios加到Vue实例的原型中，只不过这样在组件中使用时需要通过this.$axios.func来调用(最合理的调用)，Q: this.$axios和this.axios和axios有什么区别？ 参考：https://www.jianshu.com/p/89a05706917a——如何定义一个自己的Vue插件 vue中以this.$xx的属性详解 Vue实例里this的使用 这是vue文档里的原话：All lifecycle hooks are called with their ‘this’ context pointing to the Vue instance invoking it. 意思是：在Vue所有的生命周期钩子方法（如created，mounted， updated以及destroyed）里使用this，this指向调用它的Vue实例。 在Vue所有的生命周期钩子方法 methods（普通方法）中使用的this指向为创建的vue组件实例。 vue组件生命周期钩子方法里面还有方法使用this： 在函数内部使用this时，this会指向window，而非vue实例 vue箭头方法中使用this： 箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 示例：vue中的this指向问题 data中的this指向为windows。 参考：vue中this的指向——比较全 template的组件中ref作用 可以获得相应的html元素，效果跟document.getElementById相同，获得以后就可以调用其元素的一些功能，如focus啥的 好应用案例 用Vue构建一个github“可视化大数据平台”-GitDataV，设计开发分享, https://github.com/HongqingCao/GitDataV https://juejin.cn/post/6888604279679451143) JS函数 普通函数 12345var x = myFunction(7, 8); // 调用函数，返回值被赋值给 xfunction myFunction(a, b) &#123; return a * b; // 函数返回 a 和 b 的乘积&#125; 箭头函数 123456789101112131415161718// 单参数x =&gt; x * xfunction (x) &#123; return x * x;&#125;// 多参数, 需要用括号括起来(x, y) =&gt; x * x + y * y// 无参数， 需要用括号声明() =&gt; 3.14// 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错// SyntaxError:x =&gt; &#123; foo: x &#125;// 因为和函数体的&#123; ... &#125;有语法冲突，所以要改为// ok:x =&gt; (&#123; foo: x &#125;) 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 123456789101112131415161718192021var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window或undefined &#125;; return fn(); &#125;&#125;;// ---// 现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); &#125;&#125;;obj.getAge(); // 25 匿名函数 匿名函数的使用场景比较多，是简化了代码编写的一种手段。 12345678910111213141516171819202122232425// 对象方法var obj=&#123; name:\"张培跃\", age:18, fn:function()&#123; return \"我叫\"+this.name+\"今年\"+this.age+\"岁了！\"; &#125;&#125;;// 函数表达式var fn=function()&#123; return \"我是一只小小小小留下，怎么飞也飞不高！\"&#125;// 回调函数setInterval(function()&#123; console.log(\"我其实是一个回调函数，每次1秒钟会被执行一次\");&#125;,1000);// 返回值function fn()&#123; //返回匿名函数 return function()&#123; return \"张培跃\"; &#125;&#125; 匿名函数的作用： 1、通过匿名函数可以实现闭包，关于闭包在后面的文章中会重点讲解。在这里简单介绍一下：闭包是可以访问在函数作用域内定义的变量的函数。若要创建一个闭包，往往都需要用到匿名函数。 2、模拟块级作用域，减少全局变量。执行完匿名函数，存储在内存中相对应的变量会被销毁，从而节省内存。再者，在大型多人开发的项目中，使用块级作用域，会大大降低命名冲突的问题，从而避免产生灾难性的后果。自此开发者再也不必担心搞乱全局作用域了。 JS成员方法 写Vue的时候总是不知道什么时候用xxx: {}， 什么时候用xxx(){}。本身这个问题并不难，问题就在于一知半解，所以本小节就是专门进行说明的 12345678910// say和data都是v对象的成员方法, 而name是v的成员属性const v = &#123; name: \"cl\", data()&#123; console.log(\"data\") &#125;, say: function()&#123; console.log(\"say\") &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041 /* 方式一、Object形式的自定义对象 var 对象名 = new Object(); //new一个空的对象 对象名.属性名 = 值; // 给对象实例添加一个属性 对象名.函数名 = function()&#123;&#125; //给对象实例添加一个方法 js对象的属性访问： 对象.属性名 */ var Student1=new Object(); Student1.name=\"方式一 爱尔得华\"; Student1.age=23; //创建对象方法 如果是toString 则调用对象相对于调用此方法 Student1.toString1=function()&#123; alert(\"方式一 hello my name is toString1()\"); &#125; Student1.toString=function()&#123; var result=\"方式一 在toString方法内输出信息：年龄：\" + this.age + \",姓名：\" + this.name; alert(result); return result=\"方式一 谁调用toString方法就返回给谁输出这句话 重写方法内容\"; &#125; alert(Student1); Student1.toString1();/* 方式二、&#123;&#125;花括号形式的自定义对象 花括号中，多组属性，我们必须使用，逗号进行分隔。 var 对象名 = &#123; 属性名: 值， // 给对象添加属性 属性名（函数名）: function()&#123;&#125; // 给对象添加方法 &#125; 对象的访问： 对象.属性名*/var Student2=&#123; name: \"方式二 爱尔得华2\", age: 29, toString1: function()&#123; alert(\"方式二 my name is Student2 toString1()\"); &#125;&#125;, 编写注意点： 如果是在函数体内写的语句是不需要分号分隔的，如 12345678910setup()&#123; onMounted(()=&gt;&#123; &#125;) functipon xxx()&#123; &#125; return &#123;&#125;&#125; 与之对应的是在对象体内，如 1234567891011121314var app = &#123; data() &#123; // 等价于 data: ()=&gt;&#123;&#125; &#125;, methods:&#123; &#125;, props:&#123; &#125;, mounted()&#123; console.log(\"xxx\") &#125;&#125; 里面会出现键值对和必须要逗号分隔开 【Vue】详解 SFC 与 vue-loader vue-loader 是一个Webpack的 loader，使用 vue-loader 就可以用 Vue Single-File Component (SFC) 即单文件组件的形式编写一个组件，vue-loader 会将.vue文件转换为 JS模块。 .vue 单文件组件 (SFC) 规范 &lt;template&gt;模板块 一个SFC中最多一个&lt; template &gt;块； 其内容将被提取为字符串传递给 vue-template-compiler ，然后webpack将其编译为js渲染函数，并最终注入到从 &lt;script&gt;导出的组件中； &lt;script&gt;脚本块 一个SFC最多一个&lt;script&gt;块； 它的默认导出应该是一个 Vue.js 的组件选项对象，也可以导出由 Vue.extend() 创建的扩展对象。 思考：Vue.extend() 中 data 必须是函数，所以在.vue SFC的script中，export中的data是函数 &lt;style&gt;样式块 一个 .vue 文件可以包含多个 &lt;style&gt; 标签； 可以使用scope和module进行封装； 具有不同封装模式的多个&lt;style&gt; 标签可以在同一个组件中混合使用； .env配置文件 Vue-cli创建的 使用vue-cli3构建的项目就简单多了，因为vue-cli3使用上述的DefinePlugin方式帮你把process.env.NODE_ENV配置好了，我们不需要再自己去配置。它自带了三种模式： development：在vue-cli-service serve下，即开发环境使用 production：在vue-cli-service build和vue-cli-service test:e2e下，即正式环境使用 test： 在vue-cli-service test:unit下使用 1234567891011&#123; \"name\": \"\", \"version\": \"0.1.0\", \"private\": true, \"scripts\": &#123; \"dev\": \"vue-cli-service serve\", //本地开发运行，会把process.env.NODE_ENV设置为'development' \"build\": \"vue-cli-service build\", //默认打包模式，会把process.env.NODE_ENV设置为'production' &#125;, \"dependencies\": &#123; &#125;&#125; 对应的.env如下： .env.development .env.test .env.production 如果自己写package.json中的scripts命令的话应该如下写 1234567\"scripts\": &#123; // --mode 后面不能是dev必须为development才能识别成生产模式 \"dev\": \"vue-cli-service serve --mode development\", \"test\": \"vue-cli-service build --mode test\", // --mode 后面不能是prod必须为production才能识别成生产模式 \"prod\": \"vue-cli-service build --mode production\",&#125;, 程序中通过process.env来获取 1234567// 如console.log(process.env)const option = &#123; // baseURL: \"http://devops4.sucsoft.com:30383/api/v1\", // api的base_url baseURL: process.env.NODE_ENV == \"development\" ? \"http://192.168.31.172:5501/api/v1\" : \"http://devops4.sucsoft.com:30383/api/v1\", timeout: 5000 // 请求超时时间&#125; 注： .env中的文件需要以VUE_APP_为前缀才能被检测到， 如.env.production中填写VUE_APP_BASE_URL=&quot;hhh&quot;，之后可以在项目中通过process.env.VUE_APP_BASE_URL来获取 此外，还可以通过添加--mode参数自定义指定要加载的.env文件 123\"scripts\": &#123;\"vvv\": \"vue-cli-service serve --mode vvv\"&#125;, 搭配.env.vvv的配置文件 Vite .env文件 1234.env # 所有情况下都会加载.env.local # 所有情况下都会加载，但会被 git 忽略.env.[mode] # 只在指定模式下加载，mode可为production，development或其他自定义值。.env.[mode].local # 只在指定模式下加载，但会被 git 忽略 在.env.prod中定义 1VITE_APP_WEB_URL=http://baidu.com 注：前缀必须为VITE_APP_，并且通过console.log(import.meta.env)来获得 在页面中使用console.log(import.meta.env.VITE_APP_WEB_URL) 在 package.json中定义 12345\"scripts\": &#123; \"dev\": \"vite\", \"build\": \"vite build\", \"prod\": \"vite --mode prod\"&#125;, 说明：执行npm run prod时, 既先会加载.env的内容，然后加载.env.prod的内容 src/views和src/components`区别 两者的区分更多的是一种惯例，实际上两者定义的都是视图组件；如果要说区别的话，最大的区别在于用途和重用程度上： 可重用的组件内容可以保存在src / components文件夹中（诸如广告，网格或任何自定义控件之类的示例，如样式化的文本框或按钮。再比如页眉，页脚等页面结构性质的可重用组件，还可以创建src/layouts/文件夹） 与路由器绑定的内容，可以保存在src / views中（作页面的组件，路由到类似页面进行导航） 即views的组件多一层充当路由组件的功能： 在Vue中（通常是Vue Router）处理路由时，将定义路由以切换组件中使用的当前视图&lt;router-view&gt;。这些路线通常位于src/router/routes.js，我们可以看到以下内容： 12345678910111213141516import Home from '@/views/Home.vue'import About from '@/views/About.vue'// 可以看到router.js中导入的组件全部都是views下的export default [ &#123; path: '/', name: 'home', component: Home, &#125;, &#123; path: '/about', name: 'about', component: About, &#125;,] 位于src/components下里的组件不太可能在一条路线中使用，而位于src/views将被至少一条router路线使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const routes = [&#123; path: '/', name: 'Index', key: 'Index', redirect: '/dashboard/index', hidden: true, label: \"首页\", icon: renderIcon(BookIcon), &#125;, // 首页, 这种形式可能不太一样, 因为这边是采用了一个可重用的组件充当首页, 之后的路由展示只是将其下面的&lt;router-view&gt;进行切换 &#123; path: '/dashboard', name: 'Dashboard', key: 'Dashboard', redirect: '/dashboard/index', component: Home, label: \"首页\", icon: renderIcon(BookIcon), meta: &#123; label: \"首页\", &#125;, children: [&#123; path: \"/dashboard/index\", name: 'DashboardIndex', key: 'DashboardIndex', component: () =&gt; import('../views/HelloWorld.vue'), label: \"Hello\", icon: renderIcon(BookIcon), meta: &#123; label: \"Hello\", &#125; &#125;, &#123; path: \"/dashboard/page1\", name: 'DashboardPage1', key: 'DashboardPage1', component: () =&gt; import('../views/Page1.vue'), label: \"第一页\", icon: renderIcon(PersonIcon), meta: &#123; label: \"第一页\", &#125; &#125;] &#125;, // 第二页 &#123; path: \"/users\", name: 'Users', key: 'Users', redirect: '/users/index', component: Home, label: \"账户\", icon: renderIcon(WineIcon), meta: &#123; label: \"账户\", &#125;, children: [&#123; path: '/users/index', name: 'UsersIndex', key: 'UsersIndex', component: () =&gt; import('../views/Page2.vue'), label: \"第二页\", icon: renderIcon(WineIcon), meta: &#123; label: \"第二页\", &#125;, &#125;], &#125;,] Vue部署 12345678910111213FROM node:10 AS build-envWORKDIR /appCOPY ./package.json . RUN npm install --registry=http://registry.npm.taobao.orgCOPY . .RUN npm run buildFROM nginxWORKDIR /usr/share/nginx/htmlENV TZ=Asia/ShanghaiRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezoneCOPY --from=build-env /app/dist /usr/share/nginx/html/EXPOSE 80 from : https://github.com/liguobao/58HouseSearch/blob/master/House-Map.UI/Dockerfile","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"https://nymrli.top/tags/Vue/"}]},{"title":"git基础知识","slug":"git使用","date":"2019-01-17T12:43:43.000Z","updated":"2019-12-23T13:59:44.740Z","comments":true,"path":"2019/01/17/git使用/","link":"","permalink":"https://nymrli.top/2019/01/17/git使用/","excerpt":"","text":"概念 工作区: 工作空间分为三个状态区: 工作区 暂存区 历史记录区 三个区域关系：工作区是我们能看到的区域，我们在工作区修改增加代码；完成编辑后，我们用git add 将工作区文件添加到暂存区；然后利用git commit 提交文件到我们自己的分支。 HEAD头指针: Head指向的是当前版本(最新的提交) 基础命令 123456$ git add 文件名# 将文件添加到暂存区中 (其中git add.可以将当前目录的子目录文件都添加到暂存区中)$ git status # 显示工作目录和暂存区的状态$ git diff ID1/ID2# 查看版本差异: 分支操作 1234567891011121314$ git branch # 分支一展表&gt;&gt;&gt; *(branch)显示当前分支$ git checkout -b 分支名 # 创建,且切换到新建分支 &lt;==等价于==&gt; git branch 分支名,git checkout 分支名$ git branch -d [分支名称] # 删除一个分支, -d选项只能删除已经参与过合并的分支，对于未参与合并的分支是无法删除的。# 如果想强制删除一个分支，可以使用-D选项$ git checkout 文件名 :切换分支 (git checkout - 为切换到上一个分支)$ git merge --no-f 分支名 : 合并分支$ git rebase -i # 压缩历史(如果出现拼写错误时需要): git rebase -i HEAD~2pick xxxx...pick xxxx... 只要将这个(出现拼写错误的那个提交ID前的pick改成fixup就行了) 远程仓库 123456789101112131415161718192021222324$ git remote add 远程仓库名 # 添加远程仓库$ git@github.com:用户名/git-tutorial.git $ git push -u 远程仓库名 本地分支名# 将本地分支推送到远程仓库中:$ git checkout -b 新仓库名 远仓库名/远程分支名$ git pull [远程仓库名] [本地分支名称] # 更新:拉取远程仓库代码,如果你远程只有一个分支,本地只有一个分支,后面中括号内容都可以省略$ git push [远程仓库名] [本地分支名称]# 推送代码到远程仓库$ git remote -v# 查看远程仓库$ git remote rm [远程仓库名]# 清除远程代码仓库:$ git push origin 本地分支名:master # 提交本地分支提交到远程的master分支$ git push origin :heads/[分支名称] 或 $ git push origin :[分支名称] # 删除远程分支$ git branch -r# 查看远程git服务器上的分支: $ git fetch origin# 获取远端库最新信息$ git diff master origin/master# 查看本地与远程服务端的不同 删除远程分支git push origin --delete kickof git status 命令 表示 查看仓库当前状态； git diff 命令 表示 查看修改内容； git push代码到远程新分支 git push origin master:my_remote_new_branch remote: You are not allowed to push code to this project. fatal: unable to access ‘http://lyl233.f3322.net:11111/apollo/Apollo_Open_Resources.git/’: The requested URL returned error: 403 git remote set-url origin http://lyl233.f3322.net:11111/Chenli/Apollo_Open_Resources.git 日志 1234$ git log# 提交日志(当前状态为终点) 会产生版本库里一系列单独提交的历史$ git log -p README.md$ git log -graph 撤销操作 撤销文件提交到暂存区 1$ git rm 文件名 撤销上一次提交(commit),并重新提交 修改提交信息 12$ git commit --amend# 可以重新修改提交信息,也可以不修改 ▲.将暂存区内的文件代替工作区的(工作区内的文件复原) 1git checkout -- . ▲.将将最近一次版本库文件代替暂存区的(暂存区内的文件复原) 1234git reset HEAD .# 将暂存区拉回工作区git checkout -- .# 将工作区复原 从云服务器更新文件到仓库 1.查看git 版本(是否安装,一般都是默认安装好了的) 2.设置github账号密码: 12$ git config --global user.email \"you@example.com\"$ git config --global user.name \"Your Name\" 3.设置上传方式 1git config --global push.default simple matching（匹配所有分支） matching 参数是 Git 1.x 的默认参数，也就是老的执行方式。其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。 simple（匹配单个分支) simple参数是 Git 2.x 默认参数，意思是执行 git push 没有指定分支时，只有当前分支会被 push 到远程仓库。 4.上传需要上传的文件 1234#git init 如果没有初始化仓库的话....(更新的话就不需要git add . git commit -m \"xxx\"git push 修改.gitignore生效指令 123git rm -r --cached . // 删除本地缓存git add . // 添加要提交的文件git commit -m &apos;update .gitignore&apos; // 更新本地的缓存 附录: Git远程操作详解 使用git将项目上传到github（最简单方法）","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"数据结构实验1——线性表及多项式的运算","slug":"数据结构实验1——线性表及多项式的运算","date":"2018-12-28T11:42:11.000Z","updated":"2019-09-15T08:07:31.069Z","comments":true,"path":"2018/12/28/数据结构实验1——线性表及多项式的运算/","link":"","permalink":"https://nymrli.top/2018/12/28/数据结构实验1——线性表及多项式的运算/","excerpt":"","text":"链表操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int Status;typedef int ElemType;typedef struct Node&#123; ElemType elem; struct Node *link;&#125;Node;typedef struct &#123; struct Node* first; int n;&#125;SingleList;SingleList list; //声明全局的Status Init(SingleList *L)&#123; L-&gt;first = NULL; L-&gt;n = 0; return OK;&#125;Status Find(SingleList L,int i,ElemType *x)&#123; Node *p; int j; if (i&lt;0 || i&gt; L.n-1) return ERROR; p = L.first; for (j = 0; j &lt; i; ++i) p=p-&gt;link; *x = p-&gt;elem; return OK;&#125;Status Insert(SingleList *L,int j,ElemType x)&#123; Node *p,*q; int i; if(j&lt;-1 || j&gt; L-&gt;n) return ERROR; p = L-&gt;first; for(i=0;i&lt;j;i++) p=p-&gt;link; //p==&gt;a(i-1) q = (Node *)malloc(sizeof(Node)); q-&gt;elem = x; if (j&gt;-1) &#123; q-&gt;link = p-&gt;link; // a(i-1)==&gt;??? ===&gt; a(i)-&gt;??? p-&gt;link = q ; // a(i-1)-&gt;a(i) &#125;else &#123; q-&gt;link = L-&gt;first; L-&gt;first = q; &#125; L-&gt;n++; return OK;&#125;Status Delete(SingleList *L,int j)&#123; int i; Node *p,*q; if(!L-&gt;n) return ERROR; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; q = L-&gt;first; p = L-&gt;first; for(i=0;i&lt;j-1;i++) q = q-&gt;link; //q指向 a(i-1) if (i==0) L-&gt;first = L-&gt;first-&gt;link; else&#123; p = q-&gt;link; //此时p指向a(i) q-&gt;link = p-&gt;link; //将q指向a(a+1) &#125; free(p); L-&gt;n -- ; return OK;&#125;Status Output(SingleList L)&#123; Node *p; if(!L.n) return ERROR; p = L.first; while(p)&#123; printf(\"%d \",p-&gt;elem ); p = p-&gt;link; &#125; return OK;&#125;void Destory(SingleList *L)&#123; Node *p; while(L-&gt;first)&#123; p = L-&gt;first-&gt;link; //保存后继节点地址,防止断链 free(L-&gt;first); //释放first节点所指节点的存储空间 从前往后释放 L-&gt;first = p; &#125; &#125;int main()&#123; int i,x; Init(&amp;list); for (i = 0; i &lt; 9; ++i) Insert(&amp;list,i-1,i); printf(\"the linked list is :\"); Output(list); Delete(&amp;list,1); printf(\"\\nafter deleting the list is:\"); Output(list); Find(list,0,&amp;x); printf(\"\\nthe value is %d\\n\",x ); Destory(&amp;list); system(\"pause\"); return 0;&#125; 带表头节点的单链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct Node&#123; ElemType elem; struct Node *link;&#125;Node;typedef struct &#123; struct Node* head; int n;&#125;Headlist;Status Init(Headlist *L)&#123; L-&gt;head = (Node*)malloc(sizeof(Node)); if(!L-&gt;head) return ERROR; L-&gt;head-&gt;link = NULL; //注意到这边没有对L-&gt;head-&gt;element作设置,因为不会用到 L-&gt;n = 0; return OK;&#125;Status Sort(Headlist *L)&#123; Node *p=L-&gt;head,*pre=NULL; Node *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;elem &lt; p-&gt;elem) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125; return OK;&#125;Status deleleab(Headlist *L, int a,int b)&#123; Node *q = L-&gt;head,*p=L-&gt;head-&gt;link; // q为上一个,p为当前的 while( p ) if(p-&gt;elem &gt;= a &amp;&amp; p-&gt;elem &lt;= b) &#123; q-&gt;link = p-&gt;link; // 1 - 2 - 3 1==&gt;3,1的指针域指向3 free(p); //释放2 p = q-&gt;link; // 当前的指针变成3 &#125;else&#123; p = p-&gt;link; q = p-&gt;link; &#125; return OK; &#125;/*****思路为: 将顺序遍历的结点不断插入为L-&gt;head-&gt;link******/Status Converse(Headlist *L)&#123; Node *p = NULL,*cur= NULL; Node *q = L-&gt;head-&gt;link; if(L-&gt;head &amp;&amp; L-&gt;head-&gt;link)&#123; //如果表不存在或是为空,则return ERROR while( q != NULL ) //q按照原来的顺序依次遍历各结点 &#123; cur = q; //cur为当前结点 q = q-&gt;link; //q保存下一个结点 L-&gt;head-&gt;link = cur; //为了不动头结点,所以头结点link始终指向当前要加的结点 cur-&gt;link = p; //当前的link指向上一个结点 p = cur; //保存上一个结点 &#125; &#125;else return ERROR; return OK;&#125;Status Insert(Headlist *L,int j,ElemType x)&#123; int i; Node *p=NULL,*q=NULL; if(j&lt;-1 || j&gt; L-&gt; n-1) return ERROR; p = L-&gt;head; for(i=0;i&lt;=j;i++) p=p-&gt;link; // 与普通链表不同,这边是 &lt;= , 因为要多一个表头Node q = (Node *)malloc(sizeof(Node)); q-&gt;elem = x; q-&gt;link = p-&gt;link; p-&gt;link = q; L-&gt;n++; return OK;&#125;Status Output(Headlist L)&#123; Node *p = L.head-&gt;link; if(!L.n) return ERROR; while(p)&#123; printf(\"%d \",p-&gt;elem ); p = p-&gt;link; &#125; return OK;&#125;Status Destory(Headlist *L)&#123; Node *p=NULL; while(L-&gt;head)&#123; p = L-&gt;head-&gt;link; free(L-&gt;head); L-&gt;head = p; &#125; return OK; &#125;Status Delete(Headlist *L,int j)&#123; //下标j Node *p = L-&gt;head,*q = L-&gt;head; // q = tmp int i; if(!L-&gt;n) return ERROR; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j-1;i++) p = p-&gt;link; q = p; p = p-&gt;link; q-&gt;link = p-&gt;link; free(p); return OK;&#125;Status Find(Headlist *L,int j,ElemType *x)&#123; Node *p= L-&gt;head; int i; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j;i++) p = p-&gt;link; *x = p-&gt;elem; return OK;&#125;int main()&#123; int x; Headlist list; Init(&amp;list); Insert(&amp;list,-1,3); Insert(&amp;list,0,2); Insert(&amp;list,-1,5); Insert(&amp;list,2,7); Insert(&amp;list,-1,1); printf(\"the linked list is :\"); Output(list); printf(\"\\nAfter sorted:\"); Sort(&amp;list); Output(list); printf(\"\\nAfter Conversed:\"); Converse(&amp;list); Output(list); printf(\"\\nAfter delete index of 0,the list is:\"); Delete(&amp;list,0); Output(list); Find(&amp;list,2,&amp;x); printf(\"\\nthe index of 2:%d\\n\",x); Destory(&amp;list); system(\"pause\"); return 0;&#125; 带表头的链表和普通链表的区别在于: 带表头链表的头结点的数据域是不设置的,真正有用的结点是L-&gt;head-&gt;link指向的结点.而普通链表L-&gt;first指向的结点 这样的好处是不用特殊考虑是不是头结点. 代码实现细节: 1.插入的i,是aia_{i}ai​后面再添加一项,所以for条件为j=0;j&lt;i 进行j次link 2.删除时,删除的是aia_{i}ai​,for(j=0;j &lt; i - 1;j++),为什么是 i-1跟代码实现有关,先把q指向要删除的前一个结点,p=q-&gt;link,q-&gt;link = p-&gt;link从而将p即aia_{i}ai​孤立出来 ▲带表头的话,将&lt;变为&lt;=,因为要多推个link,跳过head结点 设计上最大的区别在于 ▲多了个表头以后,就不用再考虑,删除和插入的时候去动List-&gt;first指针，带表头后，修改的都是L-&gt;head-&gt;link之后的结点Node 单链表实现多项式加减、相乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct PNode&#123; ElemType ceof; ElemType exp; struct PNode *link;&#125;PNode;typedef struct &#123; struct PNode *head;&#125;polynominal;Status Init(polynominal *p)&#123; p-&gt;head = (PNode *)malloc(sizeof(PNode)); p-&gt;head-&gt;exp = -1; p-&gt;head-&gt;link = NULL; return OK;&#125;Status Create(polynominal *p)&#123; PNode *pn = NULL,*q=NULL,*pre=NULL; p-&gt;head = (PNode *)malloc(sizeof(PNode)); p-&gt;head-&gt;exp = -1; p-&gt;head-&gt;link = NULL; for (;;) &#123; pn = (PNode *)malloc(sizeof(PNode)); printf(\"ceof:\\n\"); scanf(\"%d\",&amp;pn-&gt;ceof); printf(\"exp:\\n\"); scanf(\"%d\",&amp;pn-&gt;exp); if (pn-&gt;exp &lt; 0) &#123;printf(\"End the input\\n\"); break;&#125; pre = p-&gt;head; //pre从链表头开始 q=p-&gt;head-&gt;link; while(q &amp;&amp; q-&gt;exp &gt; pn-&gt;exp)&#123; //pn为当前结点,q为链表中结点 pre = q; // q = q-&gt;link; &#125; pn-&gt;link = q; // 在pre和q之间插入pn,(q为null时,相当于末尾插入pn) pre-&gt;link = pn; // pre =&gt; pn =&gt; q &#125; return OK;&#125;Status Sort(polynominal *L)&#123; //从大到小 PNode *p=L-&gt;head,*pre=NULL; PNode *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;exp &lt; p-&gt;exp) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125; return OK;&#125;Status Add(polynominal *px,polynominal *qx)&#123; //目的:将q改成p+q PNode *q1=qx-&gt;head, *p=px-&gt;head-&gt;link; //q1指向qx表头结点 PNode *q=q1-&gt;link; //p指向多项式px第一个结点,q指向qx第一个 PNode *temp = NULL; //q1是q前驱 while( q &amp;&amp; p)&#123; while( p-&gt;exp &lt; q-&gt;exp )&#123; //找到qx中 大于等于q指数项的项,q不断右移 q1 = q; q = q-&gt;link; &#125; if (p-&gt;exp == q-&gt;exp )&#123; q-&gt;ceof = q-&gt;ceof + p-&gt;ceof; if (q-&gt;ceof == 0)&#123; q1-&gt;link = q-&gt;link; //释放当前q的内存 free(q); q = q1-&gt;link; p = p-&gt;link; &#125;else&#123; //p\\q都右移 q1 = q; //q1 q = q-&gt;link; p = p-&gt;link; &#125; &#125;else&#123; //p-&gt;exp &gt; q-&gt;exp temp = (PNode * )malloc(sizeof(PNode)); temp-&gt;ceof = p-&gt;ceof; temp-&gt;exp = p-&gt;exp; temp-&gt;link = q1-&gt;link; q1-&gt;link = temp; p = p-&gt;link; &#125; &#125; return OK;&#125;void Output(polynominal *p)&#123; PNode *q = p-&gt;head-&gt;link; int last = 0; while( q!=NULL )&#123; if(q-&gt;link == NULL) last =1; printf(\"%dx^%d\", q-&gt;ceof,q-&gt;exp); if(!last) printf(\"+\"); q = q-&gt;link; &#125; printf(\"\\n\");&#125;void Destory(polynominal *p)&#123; PNode *q = NULL; while(p-&gt;head)&#123; q = p-&gt;head-&gt;link; free(p-&gt;head); p-&gt;head = q; &#125;&#125;/***********合并同类项*****************//***********合并即free*****************/Status unify(polynominal *t)&#123; PNode *p=NULL; PNode *q=NULL; PNode *last=NULL; PNode *tmp; //while(p-&gt;link != NULL)&#123; for(p=t-&gt;head-&gt;link;p!=NULL;p=p-&gt;link)&#123; //选择 last = p; for(q=last-&gt;link; q!=NULL ; )&#123; //q指针向后推移指向下一结点 if(q-&gt;exp == p-&gt;exp)&#123; //相等计算 p-&gt;ceof += q-&gt;ceof; //q为 滑动项 tmp = q-&gt;link; last-&gt;link = q-&gt;link; //last保存上一个q free(q); // 吧q的空间释放掉 q= tmp; &#125;else&#123; last= q; q=q-&gt;link;&#125; //如果不相等就判断下一个 &#125; &#125; return OK;&#125;polynominal Multiply(polynominal *px,polynominal *qx)&#123; PNode *p = px-&gt;head; PNode *q = qx-&gt;head; PNode *x = NULL; PNode *tmp = NULL; polynominal newpoly; Init(&amp;newpoly); x = newpoly.head; for (p=px-&gt;head-&gt;link; p!=NULL; p=p-&gt;link)&#123; for (q=qx-&gt;head-&gt;link; q!=NULL; q=q-&gt;link)&#123; tmp = (PNode*)malloc(sizeof(PNode)); tmp-&gt;ceof = p-&gt;ceof * q-&gt;ceof; tmp-&gt;exp = p-&gt;exp + q-&gt;exp; tmp-&gt;link = x-&gt;link; //新生成的结点指向上一个生成的结点的地址 x-&gt;link = tmp; //使链表记录当前tmp结点 x = x-&gt;link; //取下一个结点 &#125; &#125; unify(&amp;newpoly); Sort(&amp;newpoly); return newpoly;&#125;int main()&#123; polynominal p,q; polynominal mul; Create(&amp;p); Output(&amp;p); // printf(\"After unify:\\n\"); Unify // unify(&amp;p); // Output(p); Create(&amp;q); Output(&amp;q); printf(\"After Multiplied:\\n\"); //Mul mul = Multiply(&amp;p,&amp;q); Output(&amp;mul); Add(&amp;p,&amp;q); //ADD printf(\"After added:\"); Output(&amp;q); printf(\"\\n\"); system(\"pause\"); return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"数据结构实验2——二叉树的基本操作及哈夫曼编码译码系统的实现","slug":"数据结构实验2——二叉树的基本操作及哈夫曼编码译码系统的实现","date":"2018-12-28T11:35:38.000Z","updated":"2019-09-15T08:07:31.070Z","comments":true,"path":"2018/12/28/数据结构实验2——二叉树的基本操作及哈夫曼编码译码系统的实现/","link":"","permalink":"https://nymrli.top/2018/12/28/数据结构实验2——二叉树的基本操作及哈夫曼编码译码系统的实现/","excerpt":"","text":"二叉树的遍历及计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int T;typedef struct BTNode&#123; T Data; struct BTNode *LChild,*RChild;&#125;BTNode;typedef struct BTTree&#123; BTNode *root;&#125;BTTree;/*先序建树*/BTNode* PreCreateBt(BTNode *t)&#123; char ch; ch = getchar(); if( ch == '#' ) t = NULL; else&#123; t = (BTNode *)malloc(sizeof(BTNode)); t-&gt;Data = ch; t-&gt;LChild = PreCreateBt(t-&gt;LChild); t-&gt;RChild = PreCreateBt(t-&gt;RChild); &#125; return t;&#125;void PrebuildTree(BTTree *tree)&#123; tree-&gt;root = PreCreateBt(tree-&gt;root);&#125;/*先序遍历*/void PreOrderTransverse(BTNode *t)&#123; if(t == NULL) return ; printf(\"%c\", t-&gt;Data); PreOrderTransverse(t-&gt;LChild); PreOrderTransverse(t-&gt;RChild);&#125;void TreePreOrder(BTTree *tree)&#123; if(tree) PreOrderTransverse(tree-&gt;root);&#125;/*中序遍历*/void InOrderTransverse(BTNode *t)&#123; if(t == NULL) return ; InOrderTransverse(t-&gt;LChild); printf(\"%c\", t-&gt;Data); InOrderTransverse(t-&gt;RChild);&#125;void TreeInOrder(BTTree *tree)&#123; if(tree) InOrderTransverse(tree-&gt;root);&#125;/*后序遍历*/void AfterOrderTransverse(BTNode *t)&#123; if(t == NULL) return ; AfterOrderTransverse(t-&gt;LChild); AfterOrderTransverse(t-&gt;RChild); printf(\"%c\", t-&gt;Data);&#125;void TreeAfterOrder(BTTree *tree)&#123; if(tree) AfterOrderTransverse(tree-&gt;root);&#125;/*结点数目*/int countNode(BTNode *t)&#123; if( t != NULL) return countNode(t-&gt;LChild)+countNode(t-&gt;RChild)+1; else return 0; //如果t为空,则该t的父亲结点是子结点,该t结点不需要计数&#125;int Nodenum(BTTree *tree)&#123; if(tree) return countNode(tree-&gt;root); else return -1;&#125;/*叶子结点数目*/int countLeafNode(BTNode *t)&#123; if( t != NULL)&#123; if( t-&gt;LChild == NULL &amp;&amp; t-&gt;RChild == NULL) return 1; else return countLeafNode(t-&gt;LChild)+countLeafNode(t-&gt;RChild); &#125; else return 0; //如果t为空,则该t的父亲结点是子结点,该t结点不需要计数&#125;int leafNodenum(BTTree *tree)&#123; if(tree) return countLeafNode(tree-&gt;root); else return -1;&#125;/*计算树的高度*/int coutTreeHeight(BTNode *t)&#123; if(t == NULL) return 0; else &#123; int l = coutTreeHeight(t-&gt;LChild); int r = coutTreeHeight(t-&gt;RChild); if ( l &gt; r) return l+1; else return r+1; // return max(r,l)+1; &#125;&#125;int TreeHeight(BTTree *tree)&#123; if(tree) return coutTreeHeight(tree-&gt;root); else return -1;&#125;/*翻转整个二叉树(左右子树交换)*/BTNode* ReverseLeftRightChild(BTNode *t)&#123; //先序遍历 if(t!=NULL)&#123; if( t-&gt;LChild!=NULL || t-&gt;RChild!=NULL)&#123; BTNode *p,*q; p = ReverseLeftRightChild(t-&gt;LChild); q = ReverseLeftRightChild(t-&gt;RChild); t-&gt;LChild = q; t-&gt;RChild = p; &#125;&#125;return t;&#125;void ReverseBtree(BTTree *tree)&#123; if(tree) ReverseLeftRightChild(tree-&gt;root);&#125;int main(int argc, char const *argv[])&#123; BTTree tree; printf(\"先序建树:\"); PrebuildTree(&amp;tree); printf(\"\\n先序遍历:\"); TreePreOrder(&amp;tree); printf(\"\\n中序遍历:\"); TreeInOrder(&amp;tree); printf(\"\\n后序遍历:\"); TreeAfterOrder(&amp;tree); printf(\"\\n结点数目:%d\\n\",Nodenum(&amp;tree)); printf(\"\\n叶子结点数目:%d\\n\",leafNodenum(&amp;tree)); printf(\"\\n树的高度:%d\\n\",TreeHeight(&amp;tree)); printf(\"翻转二叉树:\\n\"); ReverseBtree(&amp;tree); printf(\"\\n后序遍历:\"); TreeAfterOrder(&amp;tree); printf(\"\\n\"); return 0;&#125; 哈夫曼树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;stdio.h&gt;#define n 5 //叶子数目#define m (2*n-1) //结点总数#define maxval 10000.0#define maxsize 100 //哈夫曼编码的最大位数typedef struct&#123; char ch; float weight; int lchild,rchild,parent;&#125;hufmtree;typedef struct&#123; char bits[n]; //位串 int start; //编码在位串中的起始位置 char ch; //字符&#125;codetype;//建立哈夫曼树void huffman(hufmtree tree[])&#123; int i,j,p1,p2;//p1,p2分别记住每次合并时 权值最小 和 次小 的两个根结点的下标 float small1,small2,f; char c; for(i=0;i&lt;m;i++)&#123; //初始化 tree[i].parent=0; tree[i].lchild=-1; tree[i].rchild=-1; tree[i].weight=0.0; &#125; for(i=0;i&lt;n;i++)&#123; //读入前n个叶子结点的字符及权值 printf(\"输入第%d个字符为和权值:\",i+1); scanf(\"%c %f\",&amp;c,&amp;f); getchar(); tree[i].ch=c; tree[i].weight=f; &#125; for(i=n;i&lt;m;i++)&#123; //进行n-1次合并，产生n-1个新结点 p1=0;p2=0; small1=maxval;small2=maxval; //maxval是float类型的最大值 for(j=0;j&lt;i;j++) //选出两个权值最小的根结点 if(tree[j].parent==0) if(tree[j].weight&lt;small1)&#123; small2=small1; //改变最小权、次小权及对应的位置 small1=tree[j].weight; p2=p1; p1=j; &#125;else if(tree[j].weight&lt;small2)&#123; small2=tree[j].weight; //改变次小权及位置 p2=j; &#125; tree[p1].parent=i; tree[p2].parent=i; tree[i].lchild=p1; //最小权根结点是新结点的左孩子 tree[i].rchild=p2; //次小权根结点是新结点的右孩子 tree[i].weight=tree[p1].weight+tree[p2].weight; &#125;&#125;//huffman//根据哈夫曼树求出哈夫曼编码//codetype code[]为求出的哈夫曼编码//hufmtree tree[]为已知的哈夫曼树void huffmancode(codetype code[],hufmtree tree[])&#123; int i,c,p; codetype cd; //缓冲变量 for(i=0;i&lt;n;i++)&#123; cd.start=n; cd.ch=tree[i].ch; c=i; //从叶结点出发向上回溯 p=tree[i].parent; //tree[p]是tree[i]的双亲 while(p!=0)&#123; cd.start--; if(tree[p].lchild==c) cd.bits[cd.start]='0'; //tree[i]是左子树，生成代码'0' else cd.bits[cd.start]='1'; //tree[i]是右子树，生成代码'1' c=p; p=tree[p].parent; &#125; code[i]=cd; //第i+1个字符的编码存入code[i] &#125;&#125;//huffmancode//哈夫曼树译码void decode(hufmtree tree[])&#123; int i,j; char b[maxsize]; i=m-1; //从根结点开始往下搜索 printf(\"输入发送的编码(以'#'为结束标志)：\"); gets(b); printf(\"译码后的字符为\"); for(j=0;b[j]!='#';j++)&#123; if(b[j]=='0') i=tree[i].lchild; //走向左孩子 else i=tree[i].rchild; //走向右孩子 if(tree[i].lchild==-1) &#123; //tree[i]是叶结点 printf(\"%c\",tree[i].ch); i=m-1; //回到根结点 &#125; &#125; if(tree[i].lchild!=-1 &amp;&amp; b[j]!= '#') //电文读完，但尚未到叶子结点 printf(\"\\nERROR\\n\"); //输入电文有错&#125;void input(hufmtree tree[],codetype code[])&#123; int i,j;//循环变量 printf(\"【哈夫曼编码】\\n\"); printf(\"总共有%d个字符\\n\",n); huffman(tree);//建立哈夫曼树 huffmancode(code,tree);//根据哈夫曼树求出哈夫曼编码 printf(\"【输出每个字符的哈夫曼编码】\\n\"); for(i=0;i&lt;n;i++)&#123; printf(\"%c: \",code[i].ch); for(j=code[i].start;j&lt;n;j++) printf(\"%c\",code[i].bits[j]); printf(\"\\n\"); &#125;&#125;int main()&#123; hufmtree tree[m]; codetype code[n]; input(tree,code); printf(\"【哈夫曼译码】\\n\"); decode(tree);//依次读入电文，根据哈夫曼树译码 return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"数据结构实验4——各种内排序算法的实现及性能比较","slug":"数据结构实验4——各种内排序算法的实现及性能比较","date":"2018-12-28T11:20:19.000Z","updated":"2021-02-20T04:53:51.928Z","comments":true,"path":"2018/12/28/数据结构实验4——各种内排序算法的实现及性能比较/","link":"","permalink":"https://nymrli.top/2018/12/28/数据结构实验4——各种内排序算法的实现及性能比较/","excerpt":"","text":"部分代码 辅助函数 1234567891011121314/**生成随机数**/void RandCreate(int *a)&#123; int i; for ( i = 0; i &lt; N; ++i) a[i] = 1 + (rand()%1000);&#125;/***交换数组中,两个下标的值***/void Swap(int *a,int i,int j)&#123; int tmp; tmp = a[i]; a[i] = a[j]; a[j] = tmp;&#125; 简单选择排序 123456789/**简单选择排序**/void SelectSort(int *l)&#123; int minx,i,j; for (i= 0; i &lt; N-1; ++i)&#123; minx = i; //默认标记为每次第一位元素下标 for (j = i+1; j &lt; N; ++j) if( l[minx] &gt; l[j] ) minx = j; if( minx != i) Swap(l,minx,i); //判断起始位置是否为最小值 &#125;&#125; 直接插入排序 12345678910111213/**直接插入排序**/void InsertSort(int *l)&#123; int i,j; //i标识待插入元素下标 for(i = 1;i &lt; N;i ++)&#123; int insertItem = l[i]; //标记每次第一位元素 for(j = i-1;j &gt;= 0;j --)&#123; //不断将有序序列中元素向后移动,为待插入元素空出一个位置 if(insertItem &lt; l[j]) l[j+1] = l[j]; else break; &#125; l[j+1] = insertItem; //待插入元素有序存放至有序序列中 &#125;&#125; 冒泡排序 12345678910111213141516//冒泡排序void BubbleSort(int *l)&#123; int i,j; //i标识每趟排序范围最后一个元素下标,每趟排序元素下标范围是0~i for(i = N-1;i &gt; 0;i --)&#123; int isSwap = 0; //教材错误,应该放到第二层循环前 for(j = 0; j&lt;i;j ++)&#123; if(l[j] &gt; l[j+1])&#123; Swap(l,j,j+1); isSwap = 1; &#125; &#125; if(!isSwap) break; //如果本趟排序没有发生元素交换,则直接可以认为排序已完成 &#125;&#125; 快速排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;void quickSort(int a[], int m,int n);int partion(int a[], int m, int n);int main()&#123; int a[] = &#123; 6,1,2,7,9,3,3,4,5,10,8 &#125;; int m = 0; int n = (sizeof(a) / 4)-1; quickSort(a, m,n); for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125;&#125;void quickSort(int a[], int m, int n)&#123; if (m &lt; n) &#123; int q = partion(a, m, n); quickSort(a, m, q-1); quickSort(a, q + 1, n); &#125;&#125;int partion(int a[], int m, int n)&#123; int key=m; // m为左, n为右边界 int j= n,i=m; int temp1, temp2; while (i != j) &#123; while (a[j] &gt;= a[key] &amp;&amp; i &lt; j) &#123; --j; &#125; while ((a[i] &lt;= a[key]) &amp;&amp; (i &lt; j)) &#123; ++i; &#125; if (i &lt; j) &#123; temp1 = a[j]; a[j] = a[i]; a[i] = temp1; &#125; &#125; temp2 = a[key]; a[key] = a[i]; a[i] = temp2; return i;&#125; 两路合并排序 123456789101112131415161718192021222324252627282930313233343536373839//Merge函数,参考了陈慧南老师的《数据结构——C语言描述》教材void Merge(int *l,int Temp[],int i1,int j1,int i2,int j2,int *k)&#123; int i = i1,j = i2; while((i &lt;= j1)&amp;&amp;(j&lt;=j2))&#123; //若两个子序列都不空,则循环 if(l[i] &lt;= l[j])&#123; Temp[(*k)++] = l[i++]; //将较小元素存入Temp[*k] &#125; else Temp[(*k)++] = l[j++]; &#125; while(i &lt;= j1) Temp[(*k)++] = l[i++]; //将子序列1中剩余元素存入Temp while(j &lt;= j2) Temp[(*k)++] = l[j++]; //将子序列2中剩余元素存入Temp&#125;//MergeSort函数void MergeSort(int *l)&#123; int Temp[N]; int i1,j1,i2,j2,i,k,size = 1; //i1,j1和i2,j2分别是两个子序列的上,下界 while(size &lt; N)&#123; i1 = 0; k = 0; while(i1+size &lt; N)&#123; //若i1+size &lt; n,则说明存在两个子序列,需要再两两合并 i2 = i1+size; //确定子序列2的下界和子序列1的上界 j1 = i2-1; if(i2+size-1 &gt; N-1)&#123; //设置子序列2的上界 j2 = N-1; &#125; else j2 = i2+size-1; Merge(l,Temp,i1,j1,i2,j2,&amp;k); //合并相邻两个子序列 i1 = j2+1; //确定下一次合并第一个子序列的下界 &#125; for(i = 0;i &lt; k;i ++)&#123; l[i] = Temp[i]; &#125; size *= 2; //子序列长度扩大一倍 &#125;&#125; 堆排序 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct heap&#123; int n; int *data;&#125;heap;/**向下调整为最大堆**/void AdjustHeap(int Heap[],int s,int m)&#123; int temp = Heap[s]; for(int j = 2*s+1;j &lt;= m; j *= 2)&#123; if(j &lt; m &amp;&amp;Heap[j] &lt; Heap[j+1]) j++; if(temp &gt; Heap[j]) break; Heap[s] = Heap[j]; s = j; &#125; Heap[s] = temp;&#125;/**建堆**/void CreateHeap(int *heap,int n)&#123; int i; for(i = (n-2)/2;i &gt;= 0;i --) AdjustHeap(heap,i,n);&#125;/**堆初始化**/void heapInit(heap *hp,int *a,int n)&#123; hp-&gt;n = n; hp-&gt;data = (int *)malloc( sizeof(int) *n); int i; for( i = 0;i &lt; n;i ++) hp-&gt;data[i] = a[i]; CreateHeap(hp-&gt;data ,N-1);&#125;/**堆排序**/void HeapSort(heap *hp)&#123; int i; for( i=hp-&gt;n/2 ; i&gt;0 ;i--) AdjustHeap(hp-&gt;data,i,hp-&gt;n); for( i = hp-&gt; n-1 ;i&gt;0;i--)&#123; Swap( hp-&gt;data,0,i); AdjustHeap(hp-&gt;data,0,i-1); &#125;&#125; ▲向下调整法====&gt; 建堆 … 给一堆数据,一次性建堆 ▲向上调整法====&gt; 在已经是最小或最大堆的基础上,增加一个节点,仍保持为最大或最小堆 总体代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define N 100000void RandCreate(int *a)&#123; int i; for ( i = 0; i &lt; N; ++i) a[i] = 1 + (rand()%1000);&#125;/***交换数组中,两个下标的值***/void Swap(int *a,int i,int j)&#123; int tmp; tmp = a[i]; a[i] = a[j]; a[j] = tmp;&#125;/**简单选择排序**/void SelectSort(int *l)&#123; int minx,i,j; for (i= 0; i &lt; N-1; ++i)&#123; minx = i; //默认标记为每次第一位元素下标 for (j = i+1; j &lt; N; ++j) if( l[minx] &gt; l[j] ) minx = j; if( minx != i) Swap(l,minx,i); //判断起始位置是否为最小值 &#125;&#125;/**直接插入排序**/void InsertSort(int *l)&#123; int i,j; //i标识待插入元素下标 for(i = 1;i &lt; N;i ++)&#123; int insertItem = l[i]; //标记每次第一位元素 for(j = i-1;j &gt;= 0;j --)&#123; //不断将有序序列中元素向后移动,为待插入元素空出一个位置 if(insertItem &lt; l[j]) l[j+1] = l[j]; else break; &#125; l[j+1] = insertItem; //待插入元素有序存放至有序序列中 &#125;&#125;/**冒泡排序**/void BubbleSort(int *l)&#123; int i,j; //i标识每趟排序范围最后一个元素下标,每趟排序元素下标范围是0~i for(i = N-1;i &gt; 0;i --)&#123; int isSwap = 0; //教材错误,应该放到第二层循环前 for(j = 0; j&lt;i;j ++)&#123; if(l[j] &gt; l[j+1])&#123; Swap(l,j,j+1); isSwap = 1; &#125; &#125; if(!isSwap) break; //如果本趟排序没有发生元素交换,则直接可以认为排序已完成 &#125;&#125;/**快速排序**///序列划分方法int Partition(int *l,int low,int high)&#123; int i = low,j = high + 1; int pivot = l[low]; //pivot是分割元素 do&#123; do i++; while(l[i] &lt; pivot); //i前进 do j--; while(l[j] &gt; pivot); //j前进 if(i &lt; j) Swap(l,i,j); &#125;while(i &lt; j); Swap(l,low,j); return j; //此时j是分割元素下标&#125;//快速排序void QuickSort(int *l,int low,int high)&#123; //快速排序的递归函数 int k; if(low &lt; high)&#123; //当前待排序序列至少包含2个元素 k = Partition(l,low,high); QuickSort(l,low,k-1); QuickSort(l,k+1,high); &#125;&#125;void QSort(int *l)&#123; //快速排序算法的主调用函数 QuickSort(l,0,N-1);&#125;/**快速排序**//**两路合并排序**///Merge函数void Merge(int *l,int Temp[],int i1,int j1,int i2,int j2,int *k)&#123; int i = i1,j = i2; while((i &lt;= j1)&amp;&amp;(j&lt;=j2))&#123; //若两个子序列都不空,则循环 if(l[i] &lt;= l[j])&#123; Temp[(*k)++] = l[i++]; //将较小元素存入Temp[*k] &#125; else Temp[(*k)++] = l[j++]; &#125; while(i &lt;= j1) Temp[(*k)++] = l[i++]; //将子序列1中剩余元素存入Temp while(j &lt;= j2) Temp[(*k)++] = l[j++]; //将子序列2中剩余元素存入Temp&#125;//MergeSort函数void MergeSort(int *l)&#123; int Temp[N]; int i1,j1,i2,j2,i,k,size = 1; //i1,j1和i2,j2分别是两个子序列的上,下界 while(size &lt; N)&#123; i1 = 0; k = 0; while(i1+size &lt; N)&#123; //若i1+size &lt; n,则说明存在两个子序列,需要再两两合并 i2 = i1+size; //确定子序列2的下界和子序列1的上界 j1 = i2-1; if(i2+size-1 &gt; N-1)&#123; //设置子序列2的上界 j2 = N-1; &#125; else j2 = i2+size-1; Merge(l,Temp,i1,j1,i2,j2,&amp;k); //合并相邻两个子序列 i1 = j2+1; //确定下一次合并第一个子序列的下界 &#125; for(i = 0;i &lt; k;i ++)&#123; l[i] = Temp[i]; &#125; size *= 2; //子序列长度扩大一倍 &#125;&#125;/**两路合并排序**//*****堆排序*****/typedef struct heap&#123; int n; int *data;&#125;heap;/**向下调整为最大堆**/void AdjustHeap(int Heap[],int s,int m)&#123; int temp = Heap[s]; for(int j = 2*s+1;j &lt;= m; j *= 2)&#123; if(j &lt; m &amp;&amp;Heap[j] &lt; Heap[j+1]) j++; if(temp &gt; Heap[j]) break; Heap[s] = Heap[j]; s = j; &#125; Heap[s] = temp;&#125;/**建堆**/void CreateHeap(int *heap,int n)&#123; int i; for(i = (n-2)/2;i &gt;= 0;i --) AdjustHeap(heap,i,n);&#125;/**堆初始化**/void heapInit(heap *hp,int *a,int n)&#123; hp-&gt;n = n; hp-&gt;data = (int *)malloc( sizeof(int) *n); int i; for( i = 0;i &lt; n;i ++) hp-&gt;data[i] = a[i]; CreateHeap(hp-&gt;data ,N-1);&#125;/**堆排序**/void HeapSort(heap *hp)&#123; int i; for( i=hp-&gt;n/2 ; i&gt;0 ;i--) AdjustHeap(hp-&gt;data,i,hp-&gt;n); for( i = hp-&gt; n-1 ;i&gt;0;i--)&#123; Swap( hp-&gt;data,0,i); AdjustHeap(hp-&gt;data,0,i-1); &#125;&#125;/*****堆排序*****/int main()&#123; srand(time( NULL )); int a[6][N]; int i,j; RandCreate(a[0]); for (int i = 1; i &lt; 6; ++i) for (int j = 0; j &lt; N; ++j) a[i][j] = a[0][j]; double start1 = (double) clock(); SelectSort(a[0]); double end1 = (double) clock(); double diff1 = difftime(end1,start1); printf(\"%18s%10lf\\n\",\"简单选择排序时间:\",diff1); double start2 = (double) clock(); InsertSort(a[1]); double end2 = (double) clock(); double diff2 = difftime(end2,start2); printf(\"%18s%10lf\\n\",\"直接插入排序时间:\",diff2); double start3 = (double) clock(); BubbleSort(a[2]); double end3 = (double) clock(); double diff3 = difftime(end3,start3); printf(\"%18s%10lf\\n\",\"冒泡排序时间:\",diff3); double start5 = (double) clock(); MergeSort(a[4]); double end5 = (double) clock(); double diff5 = difftime(end5,start5); printf(\"%18s%10lf\\n\",\"两路排序时间:\",diff5); double start4 = (double) clock(); QSort(a[3]); double end4 = (double) clock(); double diff4 = difftime(end4,start4); printf(\"%18s%10lf\\n\",\"快速排序时间:\",diff4); heap hp; heapInit(&amp;hp,a[5],N); double start6 = (double) clock(); HeapSort(&amp;hp); double end6 = (double) clock(); double diff6 = difftime(end6,start6); printf(\"%18s%10lf\\n\",\"堆排序时间:\",diff6); system(\"pause\"); return 0;&#125; 关于堆排序的理解 限选课对堆排的没有要求,但是在实验中涉及了。平时也没怎么看过堆排序，所以这次写的时候出现了理解上的错误，在此记下： 向上和向下调整法的区别: 区别在于用途不一样，而不是 生成最小堆和最大堆的区别 向下调整法====&gt; 建堆 … 给一堆数据,一次性建堆 向上调整法====&gt; 在已经是最小或最大堆的基础上,增加一个节点,仍保持为最大或最小堆 具体而言： 给定一个乱序的数组，要构建最小或最大堆==&gt; 向下调整 已经是个最大或最小堆的数组,插入或删除一个元素，仍要保持最小堆 ;优先权队列===&gt; 向上调整 123456789101112131415//最大堆void AdjustHeap(int Heap[],int s,int m)&#123; int temp = Heap[s]; for(int j = 2*s+1;j &lt;= m; j *= 2)&#123; if(j &lt; m &amp;&amp;Heap[j] &lt; Heap[j+1])&#123; j++; &#125; if(temp &gt; Heap[j])&#123; break; &#125; Heap[s] = Heap[j]; s = j; &#125; Heap[s] = temp;&#125; 区别在于第5行和第8行 123456789101112131415//最小堆void AdjustHeap(int Heap[],int s,int m)&#123; int temp = Heap[s]; for(int j = 2*s+1;j &lt;= m; j = j*2+1)&#123; if(j &lt; m &amp;&amp;Heap[j] &gt; Heap[j+1])&#123; j++; &#125; if(temp &lt; Heap[j])&#123; break; &#125; Heap[s] = Heap[j]; s = j; &#125; Heap[s] = temp;&#125; 建堆的执行过程大致是: CreateHeap函数从下往上建，即从[s,m]==&gt;[s-1,m],在保证从s到m是最小堆后,再用向下调整法使[s-1,m]也成为堆。 向下调整的过程： 从s–&gt;m,依次调整 总的逻辑是，由于要使左子树和右子树满足要求，所以需要从下往上调整。","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"南邮《信号与系统B》复习知识点大纲","slug":"南邮《信号与系统B》复习知识点大纲","date":"2018-12-26T14:15:36.000Z","updated":"2019-09-15T08:07:31.039Z","comments":true,"path":"2018/12/26/南邮《信号与系统B》复习知识点大纲/","link":"","permalink":"https://nymrli.top/2018/12/26/南邮《信号与系统B》复习知识点大纲/","excerpt":"","text":"友情提示 请将图片右键另存为，保存到本地放大查看。 第一章 第二章","categories":[],"tags":[{"name":"学业","slug":"学业","permalink":"https://nymrli.top/tags/学业/"}]},{"title":"不蒜子统计阅读次数失效——Cxo主题","slug":"不蒜子统计阅读次数失效","date":"2018-12-26T00:57:37.000Z","updated":"2019-09-15T08:07:31.020Z","comments":true,"path":"2018/12/26/不蒜子统计阅读次数失效/","link":"","permalink":"https://nymrli.top/2018/12/26/不蒜子统计阅读次数失效/","excerpt":"","text":"官方通知 12&gt; ！！！！2018年9月 - 重要提示 ！！！！大家好，因七牛强制过期原有的『dn-lbstatics.qbox.me』域名（预计2018年10月初），与客服沟通数次无果，即使我提出为此付费也不行，只能更换域名到『busuanzi.ibruce.info』！因我是最早的一批七牛用户，为七牛至少带来了数百个邀请用户，很痛心，很无奈！各位继续使用不蒜子提供的服务，只需把原有的：&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;域名改一下即可：&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;只需要修改该js域名，其他均未改变。若有疑问，可以加入不蒜子交流QQ群：`419260983`，对您带来的不便，非常抱歉！！！还是那句话，不蒜子不会中断服务！！！！&gt; 不蒜子 原因分析 由于定位到是不蒜子统计功能突然有问题了，所以前往不蒜子官网进行查看，发现官网有一段很重要的提示： “因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！” 所以定位到问题，原来是不蒜子使用的七牛的域名被强制过期。 需要把 dn-lbstatics.qbox.me 域名更换为 busuanzi.ibruce.info 实际操作 找到含busuanzi插件设置的文件 修改指向的网址 修改完后","categories":[],"tags":[]},{"title":"Ubuntu下Sublime配置python编译环境及新手使用指导","slug":"Ubuntu下Sublime配置python编译环境及新手使用指导","date":"2018-12-26T00:41:18.000Z","updated":"2021-12-27T13:49:48.697Z","comments":true,"path":"2018/12/26/Ubuntu下Sublime配置python编译环境及新手使用指导/","link":"","permalink":"https://nymrli.top/2018/12/26/Ubuntu下Sublime配置python编译环境及新手使用指导/","excerpt":"","text":"Sublime下配置python编译环境及搭建虚拟环境:(windows下大致相同) 1.编译环境配置 2019-3-6更新教程，发现好像 官方网址打不开了，要改一下源才行。 解决办法： 点击 Preferences -&gt; Settings -&gt; Preferences.sublime-Settings—— User(一个新窗口) 添加配置**(在原有大括号{}里面添加**)：&quot;channels&quot;: [&quot;https://raw.githubusercontent.com/HBLong/channel_v3_daily/master/channel_v3.json&quot;], 代码不变，仍然是下面的代码 感谢HBLong提供的解决方案和源: 原有链接 : 解决：Sublime Text3 packagecontrol.io 无法访问的问题 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 1.点击 官方网址 从 Sublime Text 3 官方获取用于安装的代码。从菜单栏View --&gt;Show Console或者使用Ctrl+`(esc键下面的按键)，调出sublime的控制台，将官网中的python代码粘贴进去并按Enter执行，最终可以安装完成。在控制台中粘贴刚才的代码，然后点击回车。最后重启ST3。 2.现在你可以通过快捷键 cmd+shift+P 打开 Package Control 来安装其他的插件了。输入 install 然后你就能看见屏幕上出现了 Package Control: Install Package，点击回车,然后搜索sublimeREPL 安装成功后，可以在菜单栏的’TOOL’中找到SublimeREPL，如图所示 注： 安装SublimeREPL后大多数的编译工具都会能够执行，比如Python，g++，在Tools-&gt;Build System中都会有，如果还是无法编译，出现[WinError 2] 系统找不到指定的文件的问题，则需要自己指定编译语句： 打开Sublime Text 3，依次进入Tools–&gt;Build System–&gt;New Build System； 文档内容填写为 12345&#123; &quot;cmd&quot;: [&quot;D:\\\\Python39\\\\python.exe&quot;,&quot;-u&quot;,&quot;$file&quot;], # 注意这边的python得根据自己的路径来填写 &quot;file_regex&quot;: &quot;^[ ]*File \\&quot;(...*?)\\&quot;, line ([0-9]*)&quot;, &quot;selector&quot;: &quot;source.python&quot;,&#125; 文件保存在C:\\Users\\mrli\\AppData\\Roaming\\Sublime Text 3\\Packages\\User注意将这边的mrli改成你自己的username 2.将菜单栏改为中文 若需要将菜单栏改成中文可如上操作下载插件“ConvertToUTF8”或是安装插件“ChineseLocalizations”(本人使用的是这个，没试ConvertToUTF8的效果) (参考博客:http://blog.51cto.com/11970781/2087971) 3.安装Anaconda插件 1.点击刚刚生成的Package Control -&gt;输入install 2.进入安装界面，安装好后再在新窗口命令行中输入Anaconda并点击第一个备选项进行安装。 安装完成后会显示messages文档。 安装Anaconda插件完成之后，会看到如下选项栏，说明Anaconda安装成功。 Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数或者类的定义。 Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下) Anaconda会自动补全代码，之前用惯了pycharm发现突然没了代码补全后很不习惯，Anaconda的补全功能虽然没有pycharm那么好用，但还是不错的 还有需要注意的是，安装Anaconda插件后，如果python代码没有遵循PEP8规范，会出现白色的框框，或是可以使用快捷键Ctrl+Alt+R进行规范代码(这个可以去除，步骤如下) 在Settings-User选项中添加配置:{&quot;anaconda_linting&quot;:false} 4.安装虚拟环境 1.首先使用终端安装virtualenv，pip3 install virtualenv 2.在需要创建的地方进行虚拟环境的搭建，代码如下： 123mkdir pytest(文件夹名)cd pytestvirtualenv venv 1.在终端进入虚拟环境的话是在pytest文件夹下输入命令source /bin/activate 而要在sublime中进入虚拟环境的话就得按照如下操作： 首先在sublime中安装virtualenv插件，Ctrl + Shift + P，然后输入install,回车，然后搜索virtualenv。 可能出现的问题: 🎯由于 官方网址打不开的缘故，需要换源，但是根据#1.编译环境配置设置的channel貌似还是会出错,如果出错按如下方法解决 2.安装完成virtualenv插件后，直接按Ctrl + Shift + P，再输入Activate，若没有该选项则virtualenv安装中出现问题，需要重新安装。如果有的会选择Activate就能发现刚刚创建的虚拟环境，选中后回车即可进入虚拟环境 3.如果Activate选中后没有出现我们刚刚创建的虚拟环境，则需要我们手动添加路径.Ctrl + Shift + P，然后输入Add directory，回车，屏幕下面会出现输入行（Directory path）:再将刚创建的虚拟环境路径填入即可 另外，我曾碰到过Add directory后仍然没用的情况。那时，可选择“”Project”=&gt;&quot;Add folder to project&quot;选择文件后=&gt;“Save Project as”==&gt;保存好即可 工程配置文件为： .sublime-workspace、.sublime-project 其中sublime-project为: 123456789101112131415161718&#123; \"build_systems\": [ &#123; \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\", \"name\": \"Anaconda Python Builder\", \"selector\": \"source.python\", \"shell_cmd\": \"\\\"python\\\" -u \\\"$file\\\"\" &#125; ], \"folders\": [ &#123; \"path\": \"爬虫\" &#125; ], \"virtualenv\": \"G:\\\\pachong\\\\venv\"&#125; 这样环境就配置好了。按Ctrl+B编译时，观察&quot;Tools&quot;-&gt;“Build System”-&gt;是否为&quot;Python+ Virtualenv&quot;，如果不是，则选用这个再Ctrl+B就是在虚拟环境中编译了! ubuntu下sublime默认情况下好像不能输入中文，需要用下面命令就可以完美支持中文输入： 1234$ sudo apt-get update &amp;&amp; sudo apt-get upgrade$ git clone https://github.com/lyfeyaj/sublime-text-imfix.git$ cd sublime-text-imfix$ ./sublime-imfix 转自博客 截图好像有点问题，菜单栏都没有截到，用到的三个分别为“项目(Project)”，“首选项(Preferences)”，“帮助(Help)” 附录 无论是Python或者C/C++程序按Ctrl+b后运行没有输出。发现是编译选项出了问题。 解决方法如下：按下Ctrl +Shift + b选择编译方法，光标移到有Run的选项,再按Ctrl+b编译 成功如图~ 为Sublime Text添加命令行cmd并设置为底部面板[转] 依赖于Terminus、Origami两个插件。第一个是主要的命令行插件，第二个是设置窗口位置的 ctrl+P然后输入install，再分别输入Terminus、Origami进行安装 Preference -&gt; Key Binding，添加： 1234567891011&#123; &quot;keys&quot;: [&quot;ctrl+alt+t&quot;], &quot;command&quot;: &quot;terminus_open&quot;, &quot;args&quot;: &#123; &quot;config_name&quot;: &quot;Default&quot;, &quot;cwd&quot;: &quot;$&#123;file_path:$&#123;folder&#125;&#125;&quot;, &quot;post_window_hooks&quot;: [ [&quot;carry_file_to_pane&quot;, &#123;&quot;direction&quot;: &quot;down&quot;&#125;] ] &#125;&#125; 快捷键ctrl+alt+t，随后直接在下面板打开命令行窗口（我打开的时候有点延迟，大概数秒后使用）。 控制台中文乱码 用python执行了系统命令ipconfig，运行会发现中文显示乱码。 解决办法是： 在sublime text3的菜单栏选择 Tools-&gt;Build System-&gt;New Build System…，然后在打开的文件中输入下面的代码，把原有内容替换。e.g.我保存后的文件为Python39.sublime-build 1234567&#123; \"cmd\": [\"D:\\\\Python39\\\\python.exe\",\"-u\",\"$file\"], \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\", \"selector\": \"source.python\", // 需要加上encoding, 否则输出控制台会中文乱码 \"encoding\": \"cp936\"&#125; 这样就可以通过build with Python39来运行了，可以看到输出就正常显示中文了 from : https://www.jianshu.com/p/a0c8e8f22467","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"}]},{"title":"PythonWeb--flask部署内网电脑","slug":"PythonWeb-flask部署内网电脑","date":"2018-12-21T14:08:04.000Z","updated":"2020-05-15T03:12:43.618Z","comments":true,"path":"2018/12/21/PythonWeb-flask部署内网电脑/","link":"","permalink":"https://nymrli.top/2018/12/21/PythonWeb-flask部署内网电脑/","excerpt":"","text":"PythonWeb–flask部署问题 以前在云服务器上都是用root权限部署的,很流畅…这次用了活动室电脑是管理员权限apollo3d…于是出现了很大的问题… 内网穿透 活动室电脑的IP是通过路由器分配的IP,如192.168.1.145,这是一个局域网,别人是不可能通过这个IP访问到你的服务器的.（访问都是通过公网的。除非两台电脑在同一个局域网内）。 于是想到直接连活动室的网不就行了吗（如果活动室的是公网IP，只要对路由器设置个端口映射就行了），但发现，活动室的IP也是校园网分配的，已经经过了多次的NAT，于是这个方法也没用。 搜了下网上关于“内网中的电脑当做服务器”，找到了方案就是“内网穿透”，而能实现这个功能的软件不少如花生壳、frp…在此,我用花生壳达成了目的,花了6元… 花生壳 注册账号后会送给你一个域名，而“内网穿透”的功能是需要买的。他实现的原理大致是将动态变化的IP绑定在了这个域名上，每次IP变换的时候就重新DNS解析，所以达成了“IP跟随” 设置好后，就可以直接通过域名访问到内网下的电脑了！ frp 见另外一篇博客的配置方法《frp结合nginx实现内网web服务和tcp的转发》 非root权限——管理员权限 之前都是部署在/var/www目录下的,这次也没多想,也照样…结果踩了坑,弄了几小时. 先是pip install virtualenv安装了virtualenv库,然后用virtualenv env新建了个虚拟环境 但问题来了，windows下的目录结构跟linux下的有些小小的不同,导致运行uwsgi报错No module flask时一直没找到原因 linux下结构: 1234567891011--|env-----|lib-------|python---------|site-packagess---------|.....-----|includes--------|python3.5m-----|bin-------|python3.5-------|pip-------|activate 正常情况下只要激活了虚拟环境,那么pip安装的库应该都是在该虚拟环境下的,这次出了什么问题呢? 1.猜测没有site-packages 当时因为linux终端显示的原因没看到site-packages,于是就以为没有linux下建立的虚拟环境没有site-packages,但事实证明这个是没有关系的… 2.uwsgi.ini没有指定虚拟环境 网上给出的都是因为没有进入虚拟环境执行或者是配置中没有指定虚拟环境路径 3.加了sudo 根据报错显示知道，sudo pip install -r requirements.txt的库都安装到了默认python目录下了…原因是因为加了sudo. ▲一定不要使用sudo pip … ,这里是在虚拟环境中安装python包，如果使用了sudo权限，python包会被安装在主机非虚拟环境下，在虚拟环境中找不到这个包。 永远不要使用sudo pip install; 你可以在不知情的情况下覆盖重要的东西。使用pip install --user代替 于是那就不加吧,命令改为pip install -r requirements.txt,此时有报错Could not install packages due to anEnvironmentError: [Error 13] Permission denied:...,consider using '--user' options,既然提示用--user参数那就试试吧. 结果返回的是Can not perform a '--user' install. User site-packages are not visible in this virtualenv,这是为什么还是不行呢? 官方解释 pip install --user 遵循四条规则： 当全局安装的软件包位于python路径上，并且它们 与安装要求冲突时，它们将被忽略，而不会被 卸载。 当全局安装的软件包位于python路径上并且它们满足 安装要求时，pip什么都不做，并报告满足要求（类似于在--system-site-packages virtualenv中安装软件包时全局软件包如何满足要求）。 由于用户站点不在python路径上，因此pip不会--user在--no-site-packages的virtualenv（即默认类型的virtualenv）中执行安装。安装没有意义。 123import sysprint(sys.path)&gt;&gt;&gt; ['C:\\\\Users\\\\10630\\\\Desktop', 'D:\\\\python\\\\python36.zip', 'D:\\\\python\\\\DLLs', 'D:\\\\python\\\\lib', 'D:\\\\python', 'C:\\\\Users\\\\10630\\\\AppData\\\\Roaming\\\\Python\\\\Python36\\\\site-packages', 'D:\\\\python\\\\lib\\\\site-packages', 'D:\\\\python\\\\lib\\\\site-packages\\\\win32', 'D:\\\\python\\\\lib\\\\site-packages\\\\win32\\\\lib', 'D:\\\\python\\\\lib\\\\site-packages\\\\Pythonwin'] 在--system-site-packagesvirtualenv中，pip不会安装与virtualenv site-packages中的包冲突的包。-user安装缺少sys.path优先级并且毫无意义。 那应该就是3的原因了…需要在当前的env虚拟环境中将权限开放,我的做法是sudo chmod 777 -R * 最终解决方式: 于是我并没有再纠结这个,而是选择了不在/var/www这个目录下,因为这个目录下的权限关系非常严格,于是我在~/Documents/env新建了个虚拟环境,一切又如以前一样解决了. Ubuntu下使用matplotlib库,需要安装python3-tk `&quot;raise ImportError(str(msg) + ‘, please install the python3-tk package’) ImportError: No module named ‘_tkinter’, please install the python3-tk package&quot;的错误 解决方案:sudo apt-get install python3-tk(如果没更新源,最好更新下源) 附录: sudo-pip-install-vs-pip-install-user: 回答1: sudo pip install可能意味着您要在系统范围内安装软件包。对于某些软件包，例如virtualenvwrapper，这可能是有用的，但除此之外，我将避免安装系统范围的软件包并为每个应用程序创建virtualenv并将pip安装到该virtualenv（可以在没有sudo的情况下完成）。 回答2: 1$ sudo pip install 在python安装中全局安装包，即对所有用户安装。 1$ pip install --user 安装到本地用户目录，即〜/ .local / lib / python - 只是你。 例： 12$ sudo pip install jupyter$ jupyter notebook 将运行jupyter，打开Web浏览器，允许您使用笔记本。 12$ pip install --user jupyter$ jupyter notebook 在将本地目录添加到PATH之前，将不执行任何操作。 最近pypi中包含了恶意代码。切勿使用sudo来安装pip。这与以root身份运行病毒相同。将本地文件夹添加到PATH或使用virtualenv。","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"}]},{"title":"Pandas速成","slug":"Pandas速成","date":"2018-12-21T13:57:29.000Z","updated":"2020-12-02T06:57:00.819Z","comments":true,"path":"2018/12/21/Pandas速成/","link":"","permalink":"https://nymrli.top/2018/12/21/Pandas速成/","excerpt":"","text":"Pandas速成 Series : 一位数组, 只允许存储相同的数据类型 Time-Series : 以时间为索引的Series DataFrame : 二维的表格型数据结构 , 可以理解为是Series 的容器 Panel : 三维数组,可以理解为DataFrame 的容器 Series 1234567891011121314151617import matplotlib.pyplot as pltimport pandas as pdimport numpy as nparr = np.array([1,2,3])index = ['a','b','c']myseries = pd.Series(arr,index)print(myseries)print('Series中第一个元素&#123;&#125;'.format(myseries[0]))print('Series中索引为C的元素'.format(myseries['c']))&gt;&gt;&gt;a 1b 2c 3dtype: int32Series中第一个元素1Series中索引为C的元素 DataFrame 1234567891011121314arr= np.array([ [1,2,3], [2,3,4], [3,4,5]])rowindex = ['row1','row2','row3']colindex = ['col1','col2','col3']dataframe= pd.DataFrame(data=arr,index= rowindex,columns=colindex)print(dataframe)&gt;&gt;&gt; col1 col2 col3row1 1 2 3row2 2 3 4row3 3 4 5 1234567891011121314arr= np.array([ [1,2,3], [2,3,4], [3,4,5]])rowindex = ['row1','row2','row3']colindex = ['col1','col2','col3']dataframe= pd.DataFrame(data=arr,index = rowindex,columns=colindex)print(dataframe._ixs(0))&gt;&gt;&gt;col1 1col2 2col3 3Name: row1, dtype: int32 获取行列 1.ix[ ] 先行后列 12345print(dataframe.ix[[0]]) #获得第一行内容# print(dataframe.ix['row1']) #以索引名称获得print(dataframe.ix[[0]]) #获得第一列内容print(dataframe.ix[:,'col1']) 2.loc[ ] loc,是基于索引的名称选取数据集，这里的索引名称可以是数字,先行后列。注意，[0:2]是选取名称为0， 1， 2行的数据，一共三，只能写行和列的名称，不能写序号。 123456789print(dataframe.loc['row1'])&gt;&gt;&gt; col1 1col2 2col3 3Name: row1, dtype: int32print(dataframe.loc[:,'col1']) #获得'col1'列的值print(dataframe.loc['row1','col1']) #获得某行某列的值 3.iloc[] iloc，它是基于索引位来选取数据集，也就是数字序号来选取，0:2就是选取 0，1这两行，需要注意的是这里是前闭后开集合。只能写行和列的序号，不能写名称( i可以看着int,因此iloc就是用数字(int)来取数据的)，否则会报错。 12345678910111213print(dataframe.iloc[2])&gt;&gt;&gt; col1 3col2 4col3 5Name: row3, dtype: int32# 切片# 下面两种方法有同样的效果; 表示取出df中1：5行(不包括5)和3：6列df.iloc[1:5,3:6] df.iloc[[1,2,3,4],[3,4,5]] # 另外 df.iloc[0]、df.iloc[1]、df.iloc[-1] 分别表示第一行、第二行、最后一行# 同理df.iloc[:,0]、df.iloc[:,1]、df.iloc[:,-1] 分别表示第一列、第二列、最后一列 总结： loc使用范围比iloc更广更实用，loc可以使用切片、名称(index,columns)、也可以切片和名称混合使用；但是loc不能使用不存在的索引来充当切片取值,像-1 iloc只能用整数来取数 ▲.推荐使用loc","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"BaiduMap_API","slug":"BaiduMap-API","date":"2018-12-21T13:55:50.000Z","updated":"2019-09-15T08:07:30.920Z","comments":true,"path":"2018/12/21/BaiduMap-API/","link":"","permalink":"https://nymrli.top/2018/12/21/BaiduMap-API/","excerpt":"","text":"Baidu Map API 核心类Map 构造函数 描述 Map(container: String | HTMLElement, opts: MapOptions) 在指定的容器内创建地图实例，之后需要调用Map.centerAndZoom()方法对地图进行初始化。未进行初始化的地图将不能进行任何操作 12var map = new BMap.Map(\"MAP\");map.centerAndZoom(points[0], 15); 方法 返回值 描述 enableDragging() none 启用地图拖拽，默认启用 enableScrollWheelZoom() none 启用滚轮放大缩小，默认禁用 enableDoubleClickZoom() none 启用双击放大，默认启用 enableKeyboard() none 启用键盘操作，默认禁用。 enablePinchToZoom() none 启用双指操作缩放，默认启用 enableAutoResize() none 启用自动适应容器尺寸变化，默认启用 setMinZoom(zoom: Number) none 设置地图允许的最小级别。取值不得小于地图类型所允许的最小级别 getCenter() Point 返回地图当前中心点 getDistance(start: Point, end: Point) Number 返回两点之间的距离，单位是米 centerAndZoom(center: Point, zoom: Number) none 设初始化地图。 如果center类型为Point时，zoom必须赋值，范围3-19级，若调用高清底图（针对移动端开发）时，zoom可赋值范围为3-18级。如果center类型为字符串时，比如“北京”，zoom可以忽略，地图将自动根据center适配最佳zoom级别 panTo(center: Point, opts: PanOptions) none 将地图的中心点更改为给定的点。如果该点在当前的地图视图中已经可见，则会以平滑动画的方式移动到中心点位置。可以通过配置强制移动过程不使用动画效果 setCenter(center: Point | String) none 设置地图中心点。center除了可以为坐标点以外，还支持城市名 getZoom() Number 返回地图当前缩放级别 setZoom(zoom: Number) none 将视图切换到指定的缩放等级，中心点坐标不变。注意：当有信息窗口在地图上打开时，地图缩放将保证信息窗口所在的坐标位置不动 addOverlay(overlay: Overlay) none 将覆盖物添加到地图中，一个覆盖物实例只能向地图中添加一次 clearOverlays() none 清除地图上所有覆盖物 控件类 Control基类 initialize(map: Map) HTMLElement 抽象方法。调用Map.addControl()方法添加控件时将调用此方法，从而实现该控件的初始化。自定义控件时需要实现此方法，并将元素的DOM元素在该方法中返回。DOM元素需要添加到地图的容器中，使用map.getContainer()方法可获得地图容器元素 setAnchor(anchor: ControlAnchor) none 设置控件停靠的位置 getAnchor() ControlAnchor 返回控件停靠的位置 setOffset(offset: Size) none 设置控件停靠的偏移量 getOffset() Size 返回控件停靠的偏移量 show() none 显示控件 hide() none 隐藏控件 isVisible() Boolean 判断控件的可见性 ControlAnchor: 此常量表示控件的定位。 常量 描述 BMAP_ANCHOR_TOP_LEFT 控件将定位到地图的左上角 BMAP_ANCHOR_TOP_RIGHT 控件将定位到地图的右上角 BMAP_ANCHOR_BOTTOM_LEFT 控件将定位到地图的左下角 BMAP_ANCHOR_BOTTOM_RIGHT 控件将定位到地图的右下角 NavigationControl 此类表示地图的平移缩放控件，可以对地图进行上下左右四个方向的平移和缩放操作。 GeolocationControl 此类是负责进行地图定位的控件，使用html5浏览器定位功能，此类继承Control所有功能。 OverviewMapControl 此类表示缩略地图控件。 ScaleControl 此类表示比例尺控件。 CopyrightControl 此类表示版权控件，您可以在地图上添加自己的版权信息。每一个版权信息需要包含如下内容：版权的唯一标识、版权内容和其适用的区域范围。 覆盖物类 Marker:此类表示地图上一个图像标注。 构造函数 描述 Marker(point: Point, opts: MarkerOptions) 创建一个图像标注实例。point参数指定了图像标注所在的地理位置 1234markers = new BMap.Marker(new BMap.Point(118.93015,32.1091),&#123;\"title\":'Point'&#125;);label = new BMap.Label('label');markers.setLabel(l);map.addOverlay(markers); Icon此类表示标注覆盖物所使用的图标。 构造函数 描述 Icon(url: String, size: Size, opts: IconOptions) 以给定的图像地址和大小创建图标对象实例 Label此类表示地图上的文本标注。 构造函数 描述 Label(content: String, opts: LabelOptions) 创建一个文本标注实例。point参数指定了文本标注所在的地理位置 1234label = new BMap.Label(\"\", &#123;offset: new BMap.Size(-20, -20)&#125;); car = new BMap.Marker(points[0]); car.setLabel(label); map.addOverlay(car);","categories":[],"tags":[{"name":"API","slug":"API","permalink":"https://nymrli.top/tags/API/"}]},{"title":"Postman模拟上传文件","slug":"Postman模拟上传文件","date":"2018-12-20T10:57:35.000Z","updated":"2019-09-15T08:07:30.970Z","comments":true,"path":"2018/12/20/Postman模拟上传文件/","link":"","permalink":"https://nymrli.top/2018/12/20/Postman模拟上传文件/","excerpt":"","text":"Postman模拟 1.首先得知道前端的样子: 2.针对前端字段进行模拟POST ▲这边key为&lt;input&gt;中的name属性 ▲▲URL最后的’/’: POST请求URL要对应 12345@app.route(&apos;/photo/&apos;,methods = [&apos;GET&apos;,&apos;POST&apos;] )http://127.0.0.1:5000/photo/@app.route(&apos;/photo&apos;,methods = [&apos;GET&apos;,&apos;POST&apos;] )http://127.0.0.1:5000/photo ​ 当Web服务器接收到对某个末尾不含斜杠的url请求时，例如“http://www.abc.com/abc”，这时服务器会搜索网站根目录下有没有名为“abc”的文件，如果没有就把abc当做目录处理，然后返回abc目录下的默认首页。当Web服务器接收到的是末尾带斜杠的请求时就会直接当做目录处理。，当浏览器解析 /ie 这样的url时，服务器会执行301转向到/ie/，两个链接都有效，但是第二种更快。 ​ 对于静态资源服务器来说，请求https://imgss.github.io/demo/这样的路径能访问到页面，是因为服务器会自动在demo路径下尝试找index.html之类的文件并发给浏览器，所以html的当前路径一定是demo下的，也是因为这样，浏览器才会通过重定向自动加上/，防止相对路径解析出错，保证浏览器能正确的请求到资源。 requests模拟 1234567url = 'http://127.0.0.1:5000/photo/'filename = &#123; 'src' : open(\"C:\\\\Users\\\\10630\\\\Desktop\\\\为什么电流被一分为2.jpg\",'rb')&#125;html = requests.post(url,files=filename)print(html.text)# &#123;\"msg\":\"success\",\"status\":200&#125;","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Postman","slug":"Postman","permalink":"https://nymrli.top/tags/Postman/"}]},{"title":"flask-sqlalchemy踩坑——外键","slug":"flask-sqlalchemy踩坑","date":"2018-12-19T11:47:54.000Z","updated":"2019-09-15T08:07:30.933Z","comments":true,"path":"2018/12/19/flask-sqlalchemy踩坑/","link":"","permalink":"https://nymrli.top/2018/12/19/flask-sqlalchemy踩坑/","excerpt":"","text":"12.19：外键使用 今天要设计一个如图关系的表关系时,踩了好几个坑…记录下 代码: 123456789101112131415161718192021222324from exts import dbclass Account(db.Model): __tablename__ = 'account' id = db.Column(db.Integer,primary_key=True,autoincrement=True) Username = db.Column(db.String(30),nullable=True,unique=True) PWD = db.Column(db.String(20),nullable=True) email = db.Column(db.String(20),nullable=True,unique=True)class Info(db.Model): __tablename__ = 'info' id = db.Column(db.Integer,primary_key=True,autoincrement=True) email = db.Column(db.String(20),db.ForeignKey('account.email')) timestamp = db.Column(db.Float,nullable=True,unique=True)class Tmp(db.Model): __tablename__ = 'tmp' id = db.Column(db.Integer,primary_key=True,autoincrement=True) tmp = db.Column(db.Float,db.ForeignKey('info.timestamp')) # 一组的开始时间 nowtime = db.Column(db.FLOAT,nullable=True) # 当前记录的时间 longitude = db.Column(db.FLOAT,nullable=True) latitude = db.Column(db.FLOAT,nullable=True) id的类型是int,没有id这种类型 ▲.外键必须是主表的唯一键(unique)（如上，学生表 sid 是主键，而主键是唯一的，所以能够作为分数表 stu 的外键） 外键不一定须要作为从表的主键。外键也不一定是主表的主键。主表的唯一键就能够作为从表的外键。 外键的类型必须与父表的主键类型完全一致(类型和长度) 总结下来：","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"数据库","slug":"数据库","permalink":"https://nymrli.top/tags/数据库/"}]},{"title":"数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题","slug":"数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题","date":"2018-12-16T09:50:05.000Z","updated":"2019-09-15T08:07:31.073Z","comments":true,"path":"2018/12/16/数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题/","link":"","permalink":"https://nymrli.top/2018/12/16/数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题/","excerpt":"","text":"实验3.图的基本运算及职能交通中的最佳路径选择问题 3.2-邻接矩阵的DFS和BFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define ERROR 0#define OK 1#define Overflow 2 //表示上溢#define Underflow 3 //表示下溢#define NotPresent 4 //表示元素不存在#define Duplicate 5 //表示有重复元素#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status;typedef int BOOL;/************队列操作**************///循环队列的结构体定义typedef struct&#123; int front; int rear; int maxSize; //最大容量 ElemType *element;&#125;Queue;//创建一个能容纳mSize个单元的空队列void Create(Queue *Q,int mSize)&#123; Q-&gt;maxSize=mSize; Q-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize); Q-&gt;front=Q-&gt;rear=0;&#125; //判断队列是否为空,若是,则返回TRUE;否则返回FALSEBOOL IsEmpty(Queue *Q)&#123; return Q-&gt;front==Q-&gt;rear;&#125; //判断队列是否已满,若是,则返回TRUE,否则返回FALSEBOOL IsFULL(Queue *Q)&#123; return (Q-&gt;rear+1)%Q-&gt;maxSize==Q-&gt;front;&#125; //获取队头元素,并通过x返回.若操作成功,则返回TRUE,否则返回FALSEBOOL Front(Queue *Q,ElemType *x)&#123; if(IsEmpty(Q)) //空队列处理 return FALSE; *x=Q-&gt;element[(Q-&gt;front+1)%Q-&gt;maxSize]; return TRUE;&#125; //入队.在队列Q的队尾插入元素x(入队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL EnQueue(Queue *Q,ElemType x)&#123; if(IsFULL(Q)) //溢出处理 return FALSE; Q-&gt;rear=(Q-&gt;rear+1)%Q-&gt;maxSize; Q-&gt;element[Q-&gt;rear]=x; return TRUE;&#125; //出队.从队列Q中删除队头元素(出队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL DeQueue(Queue *Q)&#123; if(IsEmpty(Q))&#123; //空队列处理 return FALSE; &#125; Q-&gt;front=(Q-&gt;front+1)%Q-&gt;maxSize; return TRUE;&#125; /************队列操作**************///邻接矩阵的结构体定义typedef struct&#123; ElemType **a; //邻接矩阵 int n; //图的当前顶点数 int e; //图的当前边数 ElemType noEdge; //两顶点间无边时的值&#125;mGraph; //邻接矩阵的初始化Status Init(mGraph *mg,int nSize,ElemType noEdgeValue)&#123; int i,j; mg-&gt;n = nSize; //初始化顶点数 mg-&gt;e = 0; //初始化时没有边 mg-&gt;noEdge = noEdgeValue; //初始化没有边时的取值 mg-&gt;a = (ElemType**)malloc(nSize*sizeof(ElemType *)); //生成长度为n的一维指针数组 if(!mg-&gt;a) return ERROR; for(i = 0;i &lt; mg-&gt;n;i ++)&#123; //动态生成二维数组 mg-&gt;a[i] = (ElemType*)malloc(nSize*sizeof(ElemType)); for(j = 0;j &lt; mg-&gt;n;j ++)&#123; mg-&gt;a[i][j] = mg-&gt;noEdge; &#125; mg-&gt;a[i][i] = 0; //自回路设置为0 &#125; return OK;&#125; //邻接矩阵的撤销(改成了int型，有返回值),先释放一维数组,再释放指针数组int Destory(mGraph *mg)&#123; int i; for(i = 0;i &lt; mg-&gt;n;i ++)&#123; free(mg-&gt;a[i]); //释放n个一维数组的存储空间 &#125; free(mg-&gt;a); //释放一维数组的存储空间 return 1;&#125; //邻接矩阵的边的搜索Status Exist(mGraph *mg,int u,int v)&#123; if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v||mg-&gt;a[u][v] == mg-&gt;noEdge) return ERROR; return OK;&#125; //邻接矩阵的边的插入Status Insert(mGraph *mg,int u,int v,ElemType w)&#123; if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v) return ERROR; if(mg-&gt;a[u][v] != mg-&gt;noEdge) return Duplicate; //若待插入边已存在,则返回出错信息 mg-&gt;a[u][v] = w; //插入新边 mg-&gt;e ++; //增加一条边 return OK;&#125; //邻接矩阵的边的删除Status Remove(mGraph *mg,int u,int v)&#123; if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v) return ERROR; if(mg-&gt;a[u][v] == mg-&gt;noEdge) return NotPresent; //若待删除边不存在,则返回出错信息 mg-&gt;a[u][v] = mg-&gt;noEdge; //删除边 mg-&gt;e --; return OK;&#125; void DFS(mGraph mg,int v,int visited[])&#123; int j; printf(\"%d\",v ); visited[v] = 1; for( j = 0; j &lt; mg.n; j++)&#123; //遍历v的邻接点 if(!visited[j] &amp;&amp; mg.a[v][j] &gt; 0)&#123; //当未被访问且有权值 DFS(mg,j,visited); &#125; &#125;&#125;//DFS搜索全图void DFSGraph(mGraph mg)&#123; int i; int *visited = (int *)malloc(mg.n * sizeof(int)); //访问为1,未访问为0 for(i=0; i&lt; mg.n;i++) visited[i] = 0; //visted数组初始化 for(i=0;i&lt; mg.n; i++) if( !visited[i] ) DFS(mg,i,visited); free(visited); //整个图的DFS遍历后,释放visted数组&#125; void BFS(mGraph mg,int v,int visited[])&#123; Queue q; Create(&amp;q,mg.n); visited[v] = 1; printf(\"%d\",v); EnQueue(&amp;q,v); //将当前顶点v放入队列 while( !IsEmpty(&amp;q) )&#123; Front(&amp;q,&amp;v); DeQueue(&amp;q); //队首顶点出队列 for(int i = 0;i &lt; mg.n;i ++)&#123; //遍历图的每一项 if( !visited[i] &amp;&amp; mg.a[v][i] &gt; 0)&#123; //若未被访问且有权值,则将其访问并放入队列 visited[i] = 1; printf(\"%d\",i); EnQueue(&amp;q,i); &#125; &#125; &#125;&#125;//BFS搜索全图void BFSGraph(mGraph mg)&#123; int i; int *visited = (int *)malloc(mg.n * sizeof(int)); //访问为1,未访问为0 for(i=0; i&lt; mg.n;i++) visited[i] = 0; //visted数组初始化 for(i=0;i&lt; mg.n; i++) if( !visited[i] ) BFS(mg,i,visited); free(visited); //整个图的BFS遍历后,释放visted数组&#125; int main()&#123; mGraph g; int nSize,edge,u,v,i; ElemType w; printf(\"Enter the mgraph's Size:\"); scanf(\"%d\",&amp;nSize); Init(&amp;g,nSize,-1); printf(\"Enter the mgraph's Edge num:\"); scanf(\"%d\",&amp;edge); for(i = 0;i &lt; edge;i ++)&#123; printf(\"Please enter the edge(Pu,Pv,Weight):\"); scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); Insert(&amp;g,u,v,w); &#125; printf(\"DFS:\"); DFSGraph(g); printf(\"\\nBFS:\"); BFSGraph(g); printf(\"\\n\"); system(\"pause\"); return 0;&#125; 3.4-邻接表的BFS和DFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define ERROR 0#define OK 1#define Overflow 2 //表示上溢#define Underflow 3 //表示下溢#define NotPresent 4 //表示元素不存在#define Duplicate 5 //表示有重复元素#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status;typedef int BOOL;/************队列操作**************///循环队列的结构体定义typedef struct&#123; int front; int rear; int maxSize; //最大容量 ElemType *element;&#125;Queue;//创建一个能容纳mSize个单元的空队列void Create(Queue *Q,int mSize)&#123; Q-&gt;maxSize=mSize; Q-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize); Q-&gt;front=Q-&gt;rear=0;&#125; //判断队列是否为空,若是,则返回TRUE;否则返回FALSEBOOL IsEmpty(Queue *Q)&#123; return Q-&gt;front==Q-&gt;rear;&#125; //判断队列是否已满,若是,则返回TRUE,否则返回FALSEBOOL IsFULL(Queue *Q)&#123; return (Q-&gt;rear+1)%Q-&gt;maxSize==Q-&gt;front;&#125; //获取队头元素,并通过x返回.若操作成功,则返回TRUE,否则返回FALSEBOOL Front(Queue *Q,ElemType *x)&#123; if(IsEmpty(Q)) //空队列处理 return FALSE; *x=Q-&gt;element[(Q-&gt;front+1)%Q-&gt;maxSize]; return TRUE;&#125; //入队.在队列Q的队尾插入元素x(入队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL EnQueue(Queue *Q,ElemType x)&#123; if(IsFULL(Q)) //溢出处理 return FALSE; Q-&gt;rear=(Q-&gt;rear+1)%Q-&gt;maxSize; Q-&gt;element[Q-&gt;rear]=x; return TRUE;&#125; //出队.从队列Q中删除队头元素(出队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL DeQueue(Queue *Q)&#123; if(IsEmpty(Q))&#123; //空队列处理 return FALSE; &#125; Q-&gt;front=(Q-&gt;front+1)%Q-&gt;maxSize; return TRUE;&#125; /************队列操作**************///邻接表的结构体定义typedef struct ENode&#123; int adjVex; //任意顶点u相邻的顶点 ElemType w; //边的权值 struct ENode *nextArc; //指向下一个边结点&#125;ENode; typedef struct&#123; int n; //图的当前顶点数 int e; //图的当前边数 ENode **a; //指向一维指针数组&#125;LGraph; //邻接表的初始化Status Init(LGraph *lg,int nSize)&#123; int i; lg-&gt;n = nSize; lg-&gt;e = 0; lg-&gt;a = (ENode**)malloc(nSize*sizeof(ENode*)); //动态生成长度为n的一维指针数组 if(!lg-&gt;a) return ERROR; for(i = 0;i &lt; lg-&gt;n;i ++) lg-&gt;a[i] = NULL; //将指针数组a置空 return OK;&#125; //邻接表的撤销int Destory(LGraph *lg)&#123; int i; ENode *p,*q; for(i = 0;i &lt; lg-&gt;n;i ++)&#123; //链表的撤销操作 p = lg-&gt;a[i]; //指针p指向顶点i的单链表的第一个边结点 q = p; while(p)&#123; //释放顶点i的单链表中所有边结点 p = p-&gt;nextArc; free(q); q = p; &#125; &#125; free(lg-&gt;a); //释放一维指针数组a的存储空间 return OK; //改为int型函数,有返回值&#125; //邻接表的搜索边Status Exist(LGraph *lg,int u,int v)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1 ||v &gt; lg-&gt;n-1 ||u == v) return ERROR; p = lg-&gt;a[u]; //指针p指向顶点u的单链表的第一个边结点 while(p!=NULL &amp;&amp; p-&gt;adjVex != v)&#123; p = p-&gt;nextArc; &#125; if(!p) return ERROR; else return OK;&#125; //邻接表的插入边Status Insert(LGraph *lg,int u,int v,ElemType w)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1||v &gt; lg-&gt;n-1 ||u == v) return ERROR; if(Exist(lg,u,v)) return Duplicate; //此边已存在,返回错误 p = (ENode*)malloc(sizeof(ENode)); //为新的边结点分配存储空间 p-&gt;adjVex = v; p-&gt;w = w; p -&gt; nextArc = lg-&gt;a[u]; //将新的边结点插入单链表的最前面 lg-&gt;a[u] = p; lg-&gt;e ++; return OK;&#125; //邻接表的删除边Status Remove(LGraph *lg,int u,int v)&#123; ENode *p,*q; if(u &lt; 0 || v &lt; 0 || u &gt; lg-&gt;n-1 || v &gt; lg-&gt;n-1 || u == v) return ERROR; p = lg-&gt;a[u]; q = NULL; while(p &amp;&amp; p-&gt;adjVex != v)&#123; //查找待删除边是否存在 q = p; p = p-&gt;nextArc; &#125; if(!p) return NotPresent; if(q) q-&gt;nextArc = p-&gt;nextArc; //从单链表删除此边 else lg-&gt;a[u] = p-&gt;nextArc; free(p); lg-&gt;e --; return OK;&#125; void BFS(LGraph lg,int v,int visited[])&#123; ENode *j; Queue q; Create(&amp;q,lg.n); visited[v] = 1; printf(\"%d\", v); EnQueue(&amp;q,v); //访问的节点入队 while( !IsEmpty(&amp;q) )&#123; //一直到该层没有节点为止 Front(&amp;q,&amp;v); // 取出父节点 DeQueue(&amp;q); for (j=lg.a[v]; j!= NULL;j=j-&gt;nextArc )&#123; if ( !visited[j-&gt;adjVex])&#123; visited[j-&gt;adjVex] = 1; printf(\"%d\", j-&gt;adjVex); EnQueue(&amp;q,j-&gt;adjVex); &#125; &#125; &#125;&#125;void BFSGraph(LGraph lg)&#123; int i; int *visited = (int *)malloc(sizeof(int)* lg.n); //记录n个节点的访问情况 for(i=0; i&lt; lg.n;i++) visited[i] = 0; //visted数组初始化 for (int i = 0; i &lt; lg.n; ++i) if( !visited[i] ) BFS(lg,i,visited); free(visited);&#125;void DFS(LGraph lg,int v,int visited[])&#123; ENode *j; printf(\"%d\",v ); visited[v] = 1; for (j = lg.a[v];j!=NULL;j= j-&gt;nextArc) //lg.a链表的循环 if( !visited[j-&gt;adjVex] ) DFS(lg,j-&gt;adjVex,visited);&#125;void DFSGraph(LGraph lg)&#123; int i; int *visited = (int *)malloc(sizeof(int)* lg.n); //记录n个节点的访问情况 for(i=0; i&lt; lg.n ; i++) visited[i] = 0; //visted数组初始化 for (int i = 0; i &lt; lg.n; ++i) if( !visited[i] ) DFS(lg,i,visited); free(visited);&#125; int main()&#123; LGraph g; int i,u,v,enode,edge; ElemType w; printf(\"Enter the number of mgraph's Nodes:\"); scanf(\"%d\",&amp;enode); Init(&amp;g,enode); printf(\"Enter the mgraph's Edge num:\"); scanf(\"%d\",&amp;edge); for(i = 0;i &lt; edge;i ++)&#123; printf(\"Please enter the edge(Pu,Pv,Weight):\"); scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); Insert(&amp;g,u,v,w); &#125; printf(\"DFS:\"); DFSGraph(g); printf(\"\\nBFS:\"); BFSGraph(g); printf(\"\\n\"); system(\"pause\"); return 0;&#125; 以上大多直接从学长的博客搬运过来. 3.5- 飞机换乘最短距离(Dijkstra单源最短路径) 编写程序，实现智能交通中的最佳路径选择问题：设有n个地点，编号为0~n-1，m条路径的起点、终点和代价由用户输入提供，采用实验3.1所示邻接矩阵为存储结构，寻找最佳路径方案(如花费时间最少、路径长度最短、交通费用最小等，任选其一即可)。 借了学长的整体框架,将邻接矩阵改成了邻接表,并完成了题目要求的给定起点、终点，算最短路径。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define ERROR 0#define OK 1#define Overflow 2 //表示上溢#define Underflow 3 //表示下溢#define NotPresent 4 //表示元素不存在#define Duplicate 5 //表示有重复元素#define INFTY 32657 //表示正无穷#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status;typedef int BOOL;//邻接表的结构体定义typedef struct ENode&#123; int adjVex; //任意顶点u相邻的顶点 ElemType w; //边的权值 struct ENode *nextArc; //指向下一个边结点&#125;ENode; typedef struct&#123; int n; //图的当前顶点数 int e; //图的当前边数 ENode **a; //指向一维指针数组&#125;LGraph; //邻接表的初始化Status Init(LGraph *lg,int nSize)&#123; int i; lg-&gt;n = nSize; lg-&gt;e = 0; lg-&gt;a = (ENode**)malloc(nSize*sizeof(ENode*)); //动态生成长度为n的一维指针数组 if(!lg-&gt;a) return ERROR; for(i = 0;i &lt; lg-&gt;n;i ++) lg-&gt;a[i] = NULL; //将指针数组a置空 return OK;&#125; //邻接表的撤销int Destory(LGraph *lg)&#123; int i; ENode *p,*q; for(i = 0;i &lt; lg-&gt;n;i ++)&#123; //链表的撤销操作 p = lg-&gt;a[i]; //指针p指向顶点i的单链表的第一个边结点 q = p; while(p)&#123; //释放顶点i的单链表中所有边结点 p = p-&gt;nextArc; free(q); q = p; &#125; &#125; free(lg-&gt;a); //释放一维指针数组a的存储空间 return OK; //改为int型函数,有返回值&#125; //邻接表的搜索边Status Exist(LGraph *lg,int u,int v)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1 ||v &gt; lg-&gt;n-1 ||u == v) return ERROR; p = lg-&gt;a[u]; //指针p指向顶点u的单链表的第一个边结点 while(p!=NULL &amp;&amp; p-&gt;adjVex != v)&#123; p = p-&gt;nextArc; &#125; if(!p) return ERROR; else return OK;&#125; //邻接表的插入边Status Insert(LGraph *lg,int u,int v,ElemType w)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1||v &gt; lg-&gt;n-1 ||u == v) return ERROR; if(Exist(lg,u,v)) return Duplicate; //此边已存在,返回错误 p = (ENode*)malloc(sizeof(ENode)); //为新的边结点分配存储空间 p-&gt;adjVex = v; p-&gt;w = w; p -&gt; nextArc = lg-&gt;a[u]; //将新的边结点插入单链表的最前面 lg-&gt;a[u] = p; lg-&gt;e ++; return OK;&#125; //邻接表的删除边Status Remove(LGraph *lg,int u,int v)&#123; ENode *p,*q; if(u &lt; 0 || v &lt; 0 || u &gt; lg-&gt;n-1 || v &gt; lg-&gt;n-1 || u == v) return ERROR; p = lg-&gt;a[u]; q = NULL; while(p &amp;&amp; p-&gt;adjVex != v)&#123; //查找待删除边是否存在 q = p; p = p-&gt;nextArc; &#125; if(!p) return NotPresent; if(q) q-&gt;nextArc = p-&gt;nextArc; //从单链表删除此边 else lg-&gt;a[u] = p-&gt;nextArc; free(p); lg-&gt;e --; return OK;&#125; //选出最小的d[i],i ∈ V-Sint Choose(int d[],int n,int s[])&#123; int minpos; int i; ElemType min; min = INFTY; minpos = -1; for(i = 0;i &lt; n;i ++)&#123; //这里i初值改为0 if( d[i] &lt;= min &amp;&amp; !s[i])&#123; //&lt;改为&lt;= // printf(\"Choose: d[%d]:%d \",i, d[i]); //可以将这段注释打开理解 min = d[i]; minpos = i; &#125; &#125; return minpos; //返回下标位置&#125; //Dijkstra算法Status Dijkstra(LGraph g,int v,int d[],int path[])&#123; int i,k,w,distance = 0; //增加了一个distance记录最短距离之和 int *s; if(v &lt; 0 || v &gt; g.n-1) return ERROR; ENode *j; /*对辅助数据结构的初始化*/ s = (int*)malloc(g.n*sizeof(int)); /*非源点结点初始化*/ for(i = 0;i &lt; g.n;i ++)&#123; s[i] = 0; //表示顶点i是否在s中 for( j=g.a[v];j!=NULL; j=j-&gt;nextArc) if(j-&gt;adjVex == i ) d[i] = j-&gt;w; //v到i的距离 if(i != v &amp;&amp; d[i] &lt; INFTY) path[i] = v; //如果与源点有边相通,标识指向i的源点v else path[i] = -1; &#125; /*源点初始化*/ s[v] = 1; //顶点v为源点,将原点v加入集合S printf(\"The order:%d \",v); //输出源点0 d[v] = 0; /*对辅助数据结构的初始化*/ for(i = 1;i &lt;= g.n-1;i ++)&#123; //最多产生n-1条最短路径,&lt;改为&lt;= k = Choose(d, g.n ,s); //求当前路径最短者k s[k] = 1; //将k加入集合S中 printf(\"%d \",k); for( j = g.a[k]; j!=NULL; j= j-&gt;nextArc)&#123; //更新d和path if( !s[j-&gt;adjVex] &amp;&amp; d[k] + j-&gt;w &lt; d[ j-&gt;adjVex ])&#123; //未被访问过,且 当前边+到前个结点的权值 &lt; 现在的路径长度 //j-&gt;adjVex为所有与v相邻接的顶点 d[j-&gt;adjVex ] = d[k] + j-&gt;w; distance = d[j-&gt;adjVex ]; //计算所有路径中的min距离 path[j-&gt;adjVex ] = k; &#125; &#125; &#125; return OK;&#125; int main()&#123; LGraph g; int nSize,edge,u,v,i; int s,t; //起点,终点 int d[100]; for(int i=0;i&lt;100;i++) d[i] = INFTY; int path[100]; ElemType w; printf(\"Enter the number of mgraph's Nodes:\"); scanf(\"%d\",&amp;nSize); Init(&amp;g,nSize); printf(\"Enter the mgraph's Edge num:\"); scanf(\"%d\",&amp;edge); for(i = 0;i &lt; edge;i ++)&#123; printf(\"Please enter the edge(Pu,Pv,Weight):\"); scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); Insert(&amp;g,u,v,w); &#125; printf(\"Enter the Start Point :\"); scanf(\"%d\",&amp;s); printf(\"Enter the Destination Point :\"); scanf(\"%d\",&amp;t); Dijkstra(g,0,d,path); printf(\"\\nThe shortest distance from %d to Point %d:%d\\n\",s,t, d[t]); system(\"pause\"); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"},{"name":"图论","slug":"图论","permalink":"https://nymrli.top/tags/图论/"},{"name":"实验作业","slug":"实验作业","permalink":"https://nymrli.top/tags/实验作业/"}]},{"title":"数据结构——图","slug":"数据结构——图","date":"2018-12-16T03:41:46.000Z","updated":"2019-09-15T08:07:31.067Z","comments":true,"path":"2018/12/16/数据结构——图/","link":"","permalink":"https://nymrli.top/2018/12/16/数据结构——图/","excerpt":"","text":"数据结构——图 连通图 无向图 连通图 : 图中任意两点都连通 连通:如果从v到w存在一条(无向)路径,则称v和w是连通的 **路径:**V到w的路径是一系列顶点{V,v1,V2，vn,w}的集合,其中任一对相邻的顶点间都有图中的边。路径的长度是路径中的边数(如果带权,则是所有边的权重和)。如果v到w之间的所有顶点都不同,则称简单路径 ▲路径是边的超集,一条路径中可以有多条边 回路:起点等于终点的路径 ==&gt; 有回路的路径为非简单路径 有向图: 强连通 : 有向图中顶点v和W之间存在双向路径,则称v和w是强连通的强连通图 强连通图 : 有向图中任意两顶点均强连通强连通分量:有向图的极大强连通子图 弱连通图 : 将有向图中边的方向擦去,能变成连通图的图叫 弱连通图 图不连通咋办? 非连通图 无向图 连通分量: 无向图的极大连通子图 极大顶点数 : 再加1个顶点就不连通了 极大边数 : 包含子图中所有顶点相连的所有边 图的边可以是具有某种属性的对象: 007案例中的岸边 最小代价生成树 基础概念 最小生成树问题 : 村村通—&gt; 使图连通的( 最少的边 \\ 花销最小的 ) 树 连通的 无回路 V个顶点 , v-1条边 生成 包含所有的顶点 V-1条边都在图里 任意加一条边都会构成回路 最小 边的权重和最小 ▲ 最小代价生成树不存在 &lt;----&gt; 图不连通 贪心算法: 贪: 每一步是最好的 好: 权重是最小的 约束: 只能用图里有的边 正好用掉 v-1条边 不能有回路 算法实现: Prim算法——让小树成长： kruskal——将森林合并成树: 更贪心,直接将权重最小的边收进来 拓补排序 AOV 以顶点来表示活动。 一个活动是另一个活动的先决条件 不断抹去 没有前驱顶点(入度为0) 的顶点 提倡的做法: 将入度为0的顶点放到容器中 ▲.这种方法还可以用来检测是不是有向无环图(DAG) 关键路径 AOE: 一般用于安排项目的工序 由绝不允许延误的活动组成的路径 关键路径长度: earliest(n) 没有机动时间的路径为关键路径","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"},{"name":"图论","slug":"图论","permalink":"https://nymrli.top/tags/图论/"}]},{"title":"win自带邮件使用","slug":"win自带邮件使用","date":"2018-12-16T02:48:27.000Z","updated":"2019-09-15T08:07:31.015Z","comments":true,"path":"2018/12/16/win自带邮件使用/","link":"","permalink":"https://nymrli.top/2018/12/16/win自带邮件使用/","excerpt":"","text":"Windows10 自带邮箱 创意大赛忘记提交附件的经历，让我决定这几天把邮箱的问题彻底解决了。 一.打开Windows自带的邮件 1.附件栏里 2.直接搜索&quot;邮件&quot; 二.添加账号 打开后界面是这样的,左边是我已经添加好的账号 1.点击下面的&quot;齿轮&quot; 2.点击&quot;管理账号&quot; 3.点击&quot;添加账户&quot; 将信息按规则填好后.需要注意的是▲.在按登录之前需要翻墙,否则会出现如图&quot;我们无法找到你的设置&quot;. 其次要注意的是,密码为IMAP或者POP、SMTP的密码，授权码查询如下 网易： 图一 图二： 图三： 此步他会要求你设置自己的授权码 QQ邮箱： 图一： 图二： 此步他会要求你发送“配置邮箱客户端”到某个号码上，然后会生成授权码。这个不是自己设置的 翻墙成功，在确保密码也正确的情况下就可以按“登录”了。 附录： 添加账号： 从“开始“中打开 附件自动下载: 下载的附件一般在C:\\Users\\账户名\\AppData\\Local\\Packages\\microsoft.windowscommunicationsapps_邮箱代码\\LocalState\\Files\\S0\\1055（我的在1055里）","categories":[],"tags":[{"name":"邮件","slug":"邮件","permalink":"https://nymrli.top/tags/邮件/"},{"name":"Window10","slug":"Window10","permalink":"https://nymrli.top/tags/Window10/"}]},{"title":"2018-12-15小记","slug":"2018-12-15小记","date":"2018-12-15T14:22:25.000Z","updated":"2019-09-15T08:07:30.907Z","comments":true,"path":"2018/12/15/2018-12-15小记/","link":"","permalink":"https://nymrli.top/2018/12/15/2018-12-15小记/","excerpt":"","text":"数据结构上机,由于最近烦心事也比较多,没有任何准备,在机房想要自己把代码敲出来也是不现实的。于是，就搜吧。无意中搜到了学长的博客,大二转计科，看了他努力的点滴，也颇有感触，于是下笔，略述己见。 之前一直在博客里都是发的技术性的文章，有时想说点话，也找不到合适的人。发条说说，不懂的人不知所措，懂的人也无从安慰，于是也只好作罢。也曾想过在博客里写，太又感觉未免太过矫情，今日所感，还是决定记录些情感、回忆。 大一上报了院科协与校科协，入大学前已经略有琢磨过C语言学习的我自然没有再接着学C，于是趁着Python的大热，也正是听说了Python的简洁、可以做爬虫、网站、人工智能等有趣的时就决定学了这门语言。于是加入了Python组，碰到了李林伟与王宇学长，李林伟学长很负责，大一的课几乎都是由他授的，当初还有事嫌他讲的不够好，现在自己当了讲师后才发现根本无暇准备。大一的时光很多都泡在了图书馆，一个学期下来已经借了20+本书了，整个学年下来一共借了40+本书，虽然没有全部看完，都明显的感觉到自己的努力。大二一般都是在看视频，图书馆很少去了，书也借的少了。 大一还学了单片机，说来也可惜，第一次院级比赛优之杰做了个所有授课内容如 蜂鸣器、LCD1602、跑马灯、矩阵按键 的作品已经很了不起了，就没有再深入学些什么，不知那些更优秀的人已经开始准备电赛、飞思卡尔了。很遗憾吧，最终在下学期的4月份“海善达杯”结束后就再也没碰过单片机，所有学过的单片机代码也逐渐忘却。 大二，一直呆在学科楼220，但没有怎么忙Apollo的项目，说来也比较惭愧。这半个学期也已经过了，感觉自己一直在忙些奇奇怪怪的事，学了前端HTML、CSS、JS；还学了微信小程序，为的就是想参加一些比赛，但到如今却都凉了。为了天翼杯做了个物联网的猫粮，但是天翼杯初赛就被刷；参加创意大赛，结果自己忘记提交附件了；同时，学长的不看好，让我也对完成点子的作品产生了怀疑：这种没技术含量的作品真的能获奖吗？无论如何，最近也得不到答案了。这让我对开发产生了一种厌恶与疲倦，下学期想好好弄弄算法或是机器学习了，静下心来弄点真技术。 有的时候真的会比较迷茫吧？考研还是工作的问题，每隔一段时间都会思考。昨天的分光计无疑让我又一次受挫。准备了3天的物理实验，结果最后誊错数据，同时也是最后几个离开实验室的。确实，分光计真的很简单，但有模糊的地方、以及平时没解决放过的地方在你最薄弱的时候就可能一下子要了你的命。无法确定是否要修正、无法确定是否要算θ0……导致没有一开始就画表，导致了最后的誊错，感觉像是命中注定，就如同创意大赛的没有提交。最近过的很背，期望能够有个水逆退散、柳暗花明。","categories":[],"tags":[{"name":"生活小记","slug":"生活小记","permalink":"https://nymrli.top/tags/生活小记/"}]},{"title":"Python中邮件的发送","slug":"Python中邮件的发送","date":"2018-12-12T14:17:38.000Z","updated":"2020-11-12T08:15:50.837Z","comments":true,"path":"2018/12/12/Python中邮件的发送/","link":"","permalink":"https://nymrli.top/2018/12/12/Python中邮件的发送/","excerpt":"","text":"Python普通的邮件发送 需要一个安全的连接，例如SSL，因此接下来我们会使用SSL的方式去登录，但是在那之前，我们需要做一些准备，打开qq邮箱，点击设置-&gt;账户，找到POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务，开启IMAP/SMTP服务，然后根据要求使用手机发送到指定号码，获取授权码，这个授权码就是你接下来登录要使用的密码. 123456789101112131415161718from email.mime.text import MIMETextimport smtplib_user = '1063052964@qq.com'_pwd = 'pykhotuhghdjbeci'_to = '2035420834@qq.com'msg = MIMEText(mail_body) //MIMEText中_subtype默认为plain,html格式,只需改这个参数msg[\"Subject\"] = '来自[不吐不快]网站的网友意见'msg[\"From\"] = _usermsg[\"To\"] = _totry: s = smtplib.SMTP_SSL(\"smtp.qq.com\", 465) # 或是使用s = smtplib.SMTP(\"smtp.qq.com\",25) s.login(_user, _pwd) s.sendmail(_user, _to, msg.as_string()) s.quit() message = '感谢你的来信'except: message = '发送失败' ▲smtplib.SMTP_SSL([host[, port[, local_hostname[, keyfile[, certfile[, timeout]]]]]]) 这是一个派生自SMTP的子类，通过SSL加密的套接字连接（使用此类，您需要使用SSL支持编译的套接字模块）。如果未指定主机，则使用“（本地主机）”。如果省略端口，则使用标准的SMTP-over-SSL端口（465） 本机已安装了支持 SMTP 的服务，如：sendmail: 12345import smtplibfrom email.mime.text import MIMETextfrom email.header import Headermessage[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;) 第三方SMTP发送邮件: 1234567import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddrmsg[&apos;From&apos;]=formataddr([&quot;FromRunoob&quot;,my_sender]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号msg[&apos;To&apos;]=formataddr([&quot;FK&quot;,my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号*没有formataddr的昵称默认为账号* Python 发送带附件的邮件: 发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/python# -*- coding: UTF-8 -*- import smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.header import Header sender = 'from@runoob.com'receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 #创建一个带附件的实例message = MIMEMultipart()message['From'] = Header(\"菜鸟教程\", 'utf-8')message['To'] = Header(\"测试\", 'utf-8')subject = 'Python SMTP 邮件测试'message['Subject'] = Header(subject, 'utf-8') #邮件正文内容message.attach(MIMEText('这是菜鸟教程Python 邮件发送测试……', 'plain', 'utf-8')) # 构造附件1，传送当前目录下的 test.txt 文件att1 = MIMEText(open('test.txt', 'rb').read(), 'base64', 'utf-8')att1[\"Content-Type\"] = 'application/octet-stream'# 这里的filename可以任意写，写什么名字，邮件中显示什么名字att1[\"Content-Disposition\"] = 'attachment; filename=\"test.txt\"'message.attach(att1) # 构造附件2，传送当前目录下的 runoob.txt 文件att2 = MIMEText(open('runoob.txt', 'rb').read(), 'base64', 'utf-8')att2[\"Content-Type\"] = 'application/octet-stream'att2[\"Content-Disposition\"] = 'attachment; filename=\"runoob.txt\"'message.attach(att2) try: smtpObj = smtplib.SMTP('localhost') smtpObj.sendmail(sender, receivers, message.as_string()) print \"邮件发送成功\"except smtplib.SMTPException: print \"Error: 无法发送邮件\" 在 HTML 文本中添加图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python# -*- coding: UTF-8 -*- import smtplibfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.header import Header sender = 'from@runoob.com'receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 msgRoot = MIMEMultipart('related') //创建MIMEMultipart()实例msgRoot['From'] = Header(\"菜鸟教程\", 'utf-8')msgRoot['To'] = Header(\"测试\", 'utf-8')subject = 'Python SMTP 邮件测试'msgRoot['Subject'] = Header(subject, 'utf-8') msgAlternative = MIMEMultipart('alternative')msgRoot.attach(msgAlternative) mail_msg = \"\"\"&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;&lt;p&gt;&lt;a href=\"http://www.runoob.com\"&gt;菜鸟教程链接&lt;/a&gt;&lt;/p&gt;&lt;p&gt;图片演示：&lt;/p&gt;&lt;p&gt;&lt;img src=\"cid:image1\"&gt;&lt;/p&gt;\"\"\"msgAlternative.attach(MIMEText(mail_msg, 'html', 'utf-8')) //内容 # 指定图片为当前目录fp = open('test.png', 'rb')msgImage = MIMEImage(fp.read())fp.close() # 定义图片 ID，在 HTML 文本中引用msgImage.add_header('Content-ID', '&lt;image1&gt;')msgRoot.attach(msgImage) //附件 try: smtpObj = smtplib.SMTP('localhost') smtpObj.sendmail(sender, receivers, msgRoot.as_string()) print \"邮件发送成功\"except smtplib.SMTPException: print \"Error: 无法发送邮件\" Python SMTP发送邮件 flask-email 官方文档 阻塞发送 最简单的调用 123456789101112131415161718from flask import Flaskfrom flask_mail import Mail,Messageapp = Flask(__name__)app.config['MAIL_SERVER'] = 'smtp.qq.com'app.config['MAIL_PORT'] = 587app.config['MAIL_USE_TLS'] = Trueapp.config['MAIL_USERNAME'] = '1063052964@qq.com'app.config['MAIL_PASSWORD'] = '#'mail = Mail(app)msg = Message('邮件主题', sender='1063052964@qq.com', recipients=['2035420834@qq.com'])msg.body = '邮件内容'msg.html = \"&lt;h1&gt;邮件的html模板&lt;h1&gt; body\"with app.app_context(): mail.send(msg) 读取配置+视图函数中调用 [config.py] 123456789# 配置邮箱信息MAIL_SERVER = 'smtp.qq.com'MAIL_PORT = 465MAIL_USE_TLS = FalseMAIL_USE_SSL = True# 注意此处，很多人配置发不出去和这个是有关系的MAIL_PASSWORD = '**********'MAIL_USERNAME = '********@qq.com'# qq郵箱默認走ssl，所以創建的smtp對象必須要支持加密傳輸，且需要指定port=465 app.py 123456789101112131415161718192021222324252627from flask import Flaskfrom flask_mail import Message,Mailfrom threading import Threadimport configapp = Flask(__name__)app.config.from_object(config)mail = Mail(app)def sendMail(): msg = Message('test', sender = '1063052964@qq.com', recipients=[\"2035420834@qq.com\"]) # recipients是个列表，包含所有收件人 # 此处的test是邮箱的主题，sender和config中的MAIL_USERNAME要一致哦 msg.body = '123' msg.html = '&lt;b&gt;test&lt;/b&gt;body' mail.send(msg)@app.route('/')def hello_world(): sendMail() return 'Hello World!'if __name__ == '__main__': app.run(debug=True) tips:tip：具体工程中，配置可以写在单独一个文件如”.env”，然后利用python-envcfg来读取配置，如： app.config.from_object(‘envcfg.raw’) 异步发送 12345678910111213141516171819202122232425262728293031323334353637from flask import Flaskfrom flask_mail import Message,Mailfrom threading import Threadimport configapp = Flask(__name__)app.config.from_object(config)mail = Mail(app)def send_async_email(app,msg): with app.app_context(): mail.send(message=msg)def SendMail(): msg = Message('test',sender='106305964@qq.com',\\ recipients=[\"870545361@qq.com\"]) # recipients是个列表，包含所有收件人 # 此处的test是邮箱的主题，sender和config中的MAIL_USERNAME要一致哦 msg.body = 'testbody' msg.html = '&lt;b&gt;test&lt;/b&gt;body' # 邮件发送给目标，可以有文本，两种方式呈现，你能看见怎样的取决于你的客户端 thr = Thread(target=send_async_email,args=[app,msg]) # 使用多线程，在实际开发中，若是不使用异步、多线程等方式，网页会卡住 thr.start() return 'ok'@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run(debug=True) ▲. 许多Flask的扩展都是假定自己运行在一个活动的应用和请求上下文中，Flask-Mail的send函数使用到current_app 这个上下文了，所以当 mail.send()函数在一个线程中执行的时候需要人为的创建一个上下文。在示例 send_async_email 中使用了 app.app_context() 来创建一个上下文。 既然异步的邮件发送功能已经实现了，如果将来我们需要实现其它异步的函数，还有什么需要改进的吗？我们需要为每一个实现异步功能的函数拷贝多线程的代码吗？这并不好。 我们可以通过实现一个 装饰器 来解决这个问题。有了装饰器，上面的代码可以修改为: 123456789101112from .decorators import async@asyncdef send_async_email(app, msg): with app.app_context(): mail.send(msg)def send_email(subject, sender, recipients, text_body, html_body): msg = Message(subject, sender=sender, recipients=recipients) msg.body = text_body msg.html = html_body send_async_email(app, msg) 好的多了吧，对不对？ 这个神奇的代码其实很简单。我们把它放入一个新文件(文件 app/decorators.py): 1234567from threading import Threaddef async(f): def wrapper(*args, **kwargs): thr = Thread(target = f, args = args, kwargs = kwargs) thr.start() return wrapper 作为一个练习，大家可以考虑考虑如何用 *multiprocessing* 模块来实现上面的功能。 摘自flask文档 django.core.mail邮件 EmailMessage: 标题. 内容.发件人.收件人 1234from django.core.mail import send_mailsend_mail(u&apos;邮件标题&apos;, u&apos;邮件内容&apos;, &apos;from@example.com&apos;, [&apos;to@example.com&apos;], fail_silently=False) send_mail() subject, message, from_email and recipient_list 这四个参数是必须的。 subject: 字符串，表示邮件标题。 message: 字符串，表示邮件内容。 from_email: 字符串，表示发件邮箱。 recipient_list: 字符串列表，列表中每个成员都是一个邮箱地址，而且每个收件人都会在 “收件人/To:” 栏看到出现在 recipient_list 中的其他收件人。 fail_silently: （可选）布尔值。为 False 时， send_mail 会抛出 smtplib.SMTPException 异常。 smtplib 文档列出了所有可能的异常。 这些异常都是 SMTPException 的子类。 auth_user: （可选）SMTP服务器的认证用户名。没提供该参数的情况下，Django会使用 EMAIL_HOST_USER 配置项的设置。 auth_password: （可选）SMTP服务器的认证密码，没提供该参数的情况下，Django会使用 EMAIL_HOST_PASSWORD配置项的设置。 connection: （可选）发送邮件的后端。没提供该参数的情况下，Django会使用默认后端的实例。可查看 Email backends 了解更多细节。 send_mass_mail() 和 send_mail() 的区别在于： send_mail() 每发送一封邮件就会打开一次邮件服务器链接，而send_mass_mail() 则是打开一次链接，发送所有的邮件。 send_mass_mail() 明显更高效。 main_admins() mail_admins(subject, message, fail_silently=False, connection=None, html_message=None) django.core.mail.mail_admins() 是一个给网站后台管理员(admin)发邮件的快捷方法，管理员设置放在 ADMINS 配置项。 mail_admins() 使用 EMAIL_SUBJECT_PREFIX 配置项的值做为邮件标题的前缀，默认情况下是 &quot;[Django] &quot; 。 mail_managers() mail_managers`(subject, message, fail_silently=False, connection=None, html_message=None) mail_managers(*subject*, *message*, *fail_silently=False*, *connection=None*, *html_message=None*)django.core.mail.mail_managers()is just likemail_admins()，不同之处在于该方法的邮件接收人是网站负责人(manager)， 可以在 [MANAGERS`]配置项设置网站负责人 EmailMessage 对象 *class *EmailMessage EmailMessage 类使用下列参数初始化（除非使用位置参数，否则默认顺序如下）。所有参数均可选，均可在调用 send()方法之前的任何时间对其赋值。 加入了 cc 参数（cc是抄送） subject: 邮件的标题行 body: 邮件的主体内容文本，须是纯文本信息。 from_email: 发送者的地址。 fred@example.com 或 Fred &lt;fred@example.com&gt; 格式都是合法的。如果忽略该参数，Django就会使用 DEFAULT_FROM_EMAIL 配置项。 to: 收件人地址列表或元组。 bcc: 发送邮件时用于”Bcc”头信息的一组列表或元组，也就是暗送的收件人。 connection: 一个邮件后端实例。用同一个链接发送多封邮件就要用到该参数。忽略该参数时，会在调用 send() 时自动创建一个新链接。 attachments: 置于邮件报文内的附件列表。列表元素可以是 email.MIMEBase.MIMEBase 实例，也可以是 (filename, content, mimetype) 三部分构成的元组。 headers: 置于邮件报文内的其他头信息(header)的字典。字典的key是头信息的名称，字典的value是头信息的值。 这样做能确保头信息的名称和对应值会以正确的格式保存于邮件报文中。 cc: 发送邮件时放于”Cc”头信息的一系列列表或元组。 例如: 123email = EmailMessage(&apos;Hello&apos;, &apos;Body goes here&apos;, &apos;from@example.com&apos;, [&apos;to1@example.com&apos;, &apos;to2@example.com&apos;], [&apos;bcc@example.com&apos;], headers = &#123;&apos;Reply-To&apos;: &apos;another@example.com&apos;&#125;) 该类方法如下: send(fail_silently=False) 发送邮件报文。如果在构造邮件时如果指定了某个链接(connection)，就会使用该链接发邮件。 否则，就会使用默认后端的实例发邮件。如果关键字参数 fail_silently 为 True ，就会忽略邮件发送时抛出的异常。 message() 构造了一个 django.core.mail.SafeMIMEText 对象 (Python的 email.MIMEText.MIMEText 类的子类) 或是 django.core.mail.SafeMIMEMultipart 对象（该对象保存即将发送出去邮件报文）。如需扩展 EmailMessage类，一般情况下要覆写该方法，将你所需的内容添加到MIME对象中。 recipients() 返回邮件中所有收件人的列表，不管收件人是在 to 还是 bcc 属性中。这是另一个经常被继承覆写的方法， 因为SMTP服务器在发送邮件报文时，要接收完整的收件人列表。即使你自己的类使用其他方式来指定收件人，也仍然需要使用该方法返回收件人列表。 attach() 创建一个新的文件附件，并把它添加到邮件报文中。 有两种方法调用 attach(): 传递一个单独的 email.MIMEBase.MIMEBase 实例做为参数。该实例会直接添加到最终的邮件报文中。 或者，给 attach() 传递三个参数: filename, content 和 mimetype. filename 是出现在邮件中的附件文件的名称， content 是附件的内容，而 mimetype 是附件所使用的MIME类型。 如果忽略 mimetype, Django会自动根据附件文件名来推测MIME内容类型。 例如: 1message.attach(&apos;design.png&apos;, img_data, &apos;image/png&apos;) attach_file() 使用当前文件系统下的某个文件做为附件。调用时，传入某个文件的完整路径，以及该附件的MIME类型(可选的)。 忽略MIME类型的话，Django会自动根据附件文件名来推测MIME类型。最简单的用法如下: 1message.attach_file(&apos;/images/weather_map.png&apos;) 发送多用途邮件 在同一封邮件中包含多种版本的内容是非常有用的；典型的例子就是发送既有纯文本版本内容又有HTML版本内容的邮件。 在Django的邮件库中，可以使用 EmailMultiAlternatives 类来达到该目的。 EmailMessage 的子类有一个attach_alternative() 方法用来包含其他版本的邮件主体内容。所有其他方法(包括类的初始化方法)都直接继承自 EmailMessage 。 发送一封文本/HTML混合邮件，代码如下: 12345678from django.core.mail import EmailMultiAlternativessubject, from_email, to = &apos;hello&apos;, &apos;from@example.com&apos;, &apos;to@example.com&apos;text_content = &apos;This is an important message.&apos;html_content = &apos;&lt;p&gt;This is an &lt;strong&gt;important&lt;/strong&gt; message.&lt;/p&gt;&apos;msg = EmailMultiAlternatives(subject, text_content, from_email, [to])msg.attach_alternative(html_content, &quot;text/html&quot;)msg.send() 默认情况下，EmailMessage 类中的 body 参数的MIME类型是 &quot;text/plain&quot; 。 大多数情况下，没必要更改该MIME，因为这样能保证每个收件人能够阅读该邮件，而不论他们使用的是什么邮件客户端。 不过，在能确保收件人能处理多用途邮件的情况下，可以使用:class:~django.core.mail.EmailMessage 类的 content_subtype 属性 来更改邮件内容类型。主类型总是 &quot;text&quot; ，子类型可以设置为别的版本(比如html)，例如: 123msg = EmailMessage(subject, html_content, from_email, [to])msg.content_subtype = &quot;html&quot; # 主内体现在变成 text/htmlmsg.send() 获取邮件发送后端的实例 123django.core.mail 的 get_connection() 函式返回你当前使用的邮件后端的实例。get_connection(backend=None, fail_silently=False, *args, **kwargs) SMTP backend --默认的后端 Console backend File backend --该后端并不建议在生产环境下使用–它仅仅是为开发提供方便 In-memory backend(内存后端) Dummy backend(空后端) 需要在 settings.py中设置的东西: 123456EMAIL_BACKEND = &apos;django.core.mail.backends.smtp.EmailBackend&apos;EMAIL_USE_SSL = TrueEMAIL_HOST = &apos;smtp.gmail.com&apos;EMAIL_PORT = 587EMAIL_HOST_USER = &apos;urusername@gmail.com&apos;EMAIL_HOST_PASSWORD = &apos;password&apos;","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"使用Cerbot申请免费证书升级 http到https","slug":"使用Cerbot申请免费证书升级-http到https","date":"2018-12-08T08:10:03.000Z","updated":"2019-10-07T10:15:12.177Z","comments":true,"path":"2018/12/08/使用Cerbot申请免费证书升级-http到https/","link":"","permalink":"https://nymrli.top/2018/12/08/使用Cerbot申请免费证书升级-http到https/","excerpt":"","text":"使用 Cerbot 免费证书 简单 升级 http 到 https 1、安装 cerbot: 12git clone https://github.com/letsencrypt/letsencryptcd letsencrypt 要求： Python 2.7 Git环境 连接外网 2、运行: 12// 根据自己的需求调整代码./certbot-auto certonly --standalone --email admin@example.com -d example.com -d www.example.com -d other.example.net 成功提示: 12345678910IMPORTANT NOTES:Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/sast.nymrli.top/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/sast.nymrli.top/privkey.pem Your cert will expire on 2019-02-08. To obtain a new or tweaked version of this certificate in the future, simply run certbot-auto again. To non-interactively renew *all* of your certificates, run &quot;certbot-auto renew&quot; - If you like Certbot, please consider supporting our work by: 3、配置Nginx: server 不再监听80端口，因为TLS要使用的是443端口，然后引入证书和key 123456789server&#123; listen 443 ssl; server_name sast.nymrli.top; //这里是你的域名 index index_page.html; root /var/www/homework_submission-master/; //网站目录 ssl_certificate /etc/letsencrypt/live/sast.nymrli.top/fullchain.pem; //前面生成的证书，改一下里面的域名就行，不建议更换路径 ssl_certificate_key /etc/letsencrypt/live/sast.nymrli.top/privkey.pem; //前面生成的密钥，改一下里面的域名就行，不建议更换路径&#125; 重启Nginx： 1sudo service nginx restart OK! 问题解决: 1Problem binding to port 80: Could not bind to IPv4 or IPv6. 原因是 nginx 占用了80端口，输入service nginx stop。然后再次执行证书安装命令，即可顺利安装。安装完毕后，输入service nginx start，重启 nginx 服务。","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"}]},{"title":"pipenv 新款Python虚拟环境工具详解[转]","slug":"pipenv-新款Python虚拟环境工具详解-转","date":"2018-12-08T08:08:23.000Z","updated":"2019-09-15T08:07:30.969Z","comments":true,"path":"2018/12/08/pipenv-新款Python虚拟环境工具详解-转/","link":"","permalink":"https://nymrli.top/2018/12/08/pipenv-新款Python虚拟环境工具详解-转/","excerpt":"","text":"pipenv 新款Python虚拟环境工具详解[转] pipenv是requests库作者Kenneth Reitz编写的一个用于创建和管理Python虚拟环境的工具。 Pipenv是Python官方机构推荐的Python包工具。 我们知道，为了管理Python虚拟环境，通常用得比较多的是virtualenv和pyenv。但是有人觉得它们还不够好用，不够偷懒。这个人是谁，就是上面的那位。于是他开发了一个pipenv，结合了pip及virtualenv的功能和优点，集成出了pipenv这个工具。其目的是替代virtualenv和pyenv，将pip及virtualenv的功能集于一身。 一、安装pipenv windows下很简单： 1pip install pipenv Linux下： 1sudo pip install pipenv 在苹果操作系统下： 1$ brew install pipenv 也就是说，无法用pip管理的包，pipenv同样无法使用。 pipenv依赖：psutil, virtualenv-clone, pew, certifi, urllib3, chardet, requests, mccabe, pyflakes, pycodestyle, flake8等第三方模块。 pipenv有很漂亮的彩色终端界面。 二、简单使用 进入你的Python项目文件夹： 12cd your_projectpipenv install windows操作系统中，虚拟环境创建过程如下： 1234567891011121314151617D:\\test\\test_pipenv&gt;pipenv installCreating a virtualenv for this project…Using base prefix &apos;c:\\\\python36&apos;New python executable in C:\\Users\\Administrator\\.virtualenvs\\test_pipenv-XHxuOsjn\\Scripts\\python.exeInstalling setuptools, pip, wheel...done.Virtualenv location: C:\\Users\\Administrator\\.virtualenvs\\test_pipenv-XHxuOsjnCreating a Pipfile for this project…Pipfile.lock not found, creating…Locking [dev-packages] dependencies…Locking [packages] dependencies…Updated Pipfile.lock (c23e27)!Installing dependencies from Pipfile.lock (c23e27)… ================================ 0/0 - 00:00:00To activate this project&apos;s virtualenv, run the following: $ pipenv shell 如果你给命令添加–two或–three参数，它将分别使用Python2或3来初始化你的虚拟环境，否则将使用默认的Python版本。 注意：pipenv默认把虚拟环境的真实文件全都放在了C:\\Users\\Administrator\\.virtualenvs\\test_pipenv-XHxuOsjn\\Scripts\\python.exe中，而在实际的项目文件夹内只创建了两个新文件Pipfile和Pipfile.lock。这可能造成C盘存有大量的文件，不是个好的做法。（但好像无法修改这一路径…） 看一下Pipfile中的内容： 1234567891011[[source]]url = &quot;https://pypi.python.org/simple&quot;verify_ssl = truename = &quot;pypi&quot;[packages][dev-packages] 最关键的是定义了安装第三方库使用的源，默认为官方的pypi。 而Pipfile.lock文件内容呢？ 12345678910111213141516171819202122232425262728293031&#123; &quot;_meta&quot;: &#123; &quot;hash&quot;: &#123; &quot;sha256&quot;: &quot;5f0257fe8c7a73db1c8de519faa92c658282a01087eb2bfafba7962704c23e27&quot; &#125;, &quot;host-environment-markers&quot;: &#123; &quot;implementation_name&quot;: &quot;cpython&quot;, &quot;implementation_version&quot;: &quot;3.6.4&quot;, &quot;os_name&quot;: &quot;nt&quot;, &quot;platform_machine&quot;: &quot;AMD64&quot;, &quot;platform_python_implementation&quot;: &quot;CPython&quot;, &quot;platform_release&quot;: &quot;7&quot;, &quot;platform_system&quot;: &quot;Windows&quot;, &quot;platform_version&quot;: &quot;6.1.7601&quot;, &quot;python_full_version&quot;: &quot;3.6.4&quot;, &quot;python_version&quot;: &quot;3.6&quot;, &quot;sys_platform&quot;: &quot;win32&quot; &#125;, &quot;pipfile-spec&quot;: 6, &quot;requires&quot;: &#123;&#125;, &quot;sources&quot;: [ &#123; &quot;name&quot;: &quot;pypi&quot;, &quot;url&quot;: &quot;https://pypi.python.org/simple&quot;, &quot;verify_ssl&quot;: true &#125; ] &#125;, &quot;default&quot;: &#123;&#125;, &quot;develop&quot;: &#123;&#125;&#125; 初始情况下，文件里只包含一些操作系统的基本信息。 Pipfile和Pipfile.lock两个文件互相配合，完成虚拟环境的管理工作。 三、安装第三方模块 Pipfile包含关于项目的依赖包的信息，并取代通常在Python项目中使用的requirements.txt文件。 如果你在具有requirements.txt文件的项目中启动了Pipenv，则在把它从项目中删除之前，应该使用Pipenv安装该requirements中列出的所有依赖包。 使用pipenv创建虚拟环境后，进入pipfile所在目录，使用install命令安装第三方库。 例如： 1pipenv install django 这个时候，你其实把pipenv当作pip来使用。无需像virtualenv那样需要额外的先启动虚拟环境。pipenv区分你是在给哪个虚拟环境工作，依赖的是Pipfile文件的位置。 要卸载某个第三方库： 1pipenv uninstall beautifulsoup4 四、冻结Pipfile 冻结就相当于将项目所使用的第三方库列表进行打包输出，类似于virtualenv中生成requirements.txt文件。 通过更新Pipfile.lock来冻结库名称及其版本，以及其依赖关系的列表。需要使用lock参数： 1pipenv lock 如果另一个用户拷贝了你的项目，他们只需要安装Pipenv，然后： 1pipenv install Pipenv会在项目文件夹下自动寻找Pipfile和Pipfile.lock文件，创建一个新的虚拟环境并安装必要的软件包。 也就是说pipenv install的时候有三种逻辑： 如果目录下没有Pipfile和Pipfile.lock文件，表示创建一个新的虚拟环境； 如果有，表示使用已有的Pipfile和Pipfile.lock文件中的配置创建一个虚拟环境； 如果后面带诸如django这一类库名，表示为当前虚拟环境安装第三方库。 五、管理开发环境 通常有一些Python包只在你的开发环境中需要，而不是在生产环境中，例如单元测试包。 Pipenv使用–dev标志区分两个环境。 1pipenv install --dev django django库现在将只在开发虚拟环境中使用。如果你要在你的生产环境中安装你的项目： 1pipenv install 这不会安装django包。 但是，如果有一个开发人员将你的项目克隆到自己的开发环境中，他们可以使用–dev标志，将django也安装： 1pipenv install --dev 也就是说一个–dev参数，帮你在同一个虚拟环境中又区分出了开发和非开发环境。 六、在虚拟环境中运行命令 使用run参数，提供要运行的命令： 1pipenv run python manage.py runserver 这将使用当前虚拟环境关联的Python解释器，执行命令。 或者简单的执行脚本： 1pipenv run python your_script.py 如果你不想每次运行Python时都输入这么多字符，可以在shell中设置一个别名，例如， 1alias prp=&quot;pipenv run python&quot; 七、pipenv选项解释 pipenv 具有下列的选项： 12345678910111213141516171819$ pipenvUsage: pipenv [OPTIONS] COMMAND [ARGS]...Options: --update 更新Pipenv &amp; pip --where 显示项目文件所在路径 --venv 显示虚拟环境实际文件所在路径 --py 显示虚拟环境Python解释器所在路径 --envs 显示虚拟环境的选项变量 --rm 删除虚拟环境 --bare 最小化输出 --completion 完整输出 --man 显示帮助页面 --three / --two 使用Python 3/2创建虚拟环境（注意本机已安装的Python版本） --python TEXT 指定某个Python版本作为虚拟环境的安装源 --site-packages 附带安装原Python解释器中的第三方库 --jumbotron 不知道啥玩意.... --version 版本信息 -h, --help 帮助信息 pipenv 可使用的命令参数： 12345678910Commands: check 检查安全漏洞 graph 显示当前依赖关系图信息 install 安装虚拟环境或者第三方库 lock 锁定并生成Pipfile.lock文件 open 在编辑器中查看一个库 run 在虚拟环境中运行命令 shell 进入虚拟环境 uninstall 卸载一个库 update 卸载当前所有的包，并安装它们的最新版本 一些使用例子： 123456789101112Usage Examples: 使用Python 3.6创建虚拟环境: $ pipenv --python 3.6 安装包括开发环境中的第三方库: $ pipenv install --dev 锁定pipfile: $ pipenv lock --pre Install a local setup.py into your virtual environment/Pipfile: $ pipenv install -e . 八、一些使用过程展示 定位项目路径: 12$ pipenv --where/Users/kennethreitz/Library/Mobile Documents/com~apple~CloudDocs/repos/kr/pipenv/test 定位虚拟环境 12$ pipenv --venv/Users/kennethreitz/.local/share/virtualenvs/test-Skyy4vre 定位Python解释器： 12$ pipenv --py/Users/kennethreitz/.local/share/virtualenvs/test-Skyy4vre/bin/python 安装包： 12345678910$ pipenv installCreating a virtualenv for this project......No package provided, installing all dependencies.Virtualenv location: /Users/kennethreitz/.local/share/virtualenvs/test-EJkjoYtsInstalling dependencies from Pipfile.lock......To activate this project&apos;s virtualenv, run the following:$ pipenv shell 安装一个开发环境中才使用的包： 1234$ pipenv install pytest --devInstalling pytest......Adding pytest to Pipfile&apos;s [dev-packages]... 显示依赖关系： 123456$ pipenv graphrequests==2.18.4 - certifi [required: &gt;=2017.4.17, installed: 2017.7.27.1] - chardet [required: &gt;=3.0.2,&lt;3.1.0, installed: 3.0.4] - idna [required: &gt;=2.5,&lt;2.7, installed: 2.6] - urllib3 [required: &lt;1.23,&gt;=1.21.1, installed: 1.22] 生成lock文件: 123456$ pipenv lockAssuring all dependencies from Pipfile are installed...Locking [dev-packages] dependencies...Locking [packages] dependencies...Note: your project now has only default [packages] installed.To install [dev-packages], run: $ pipenv install --dev 安装开发环境依赖： 123456$ pipenv install --devPipfile found at /Users/kennethreitz/repos/kr/pip2/test/Pipfile. Considering this to be the project home.Pipfile.lock out of date, updating...Assuring all dependencies from Pipfile are installed...Locking [dev-packages] dependencies...Locking [packages] dependencies... 卸载所有的包： 12345$ pipenv uninstall --allNo package provided, un-installing all dependencies.Found 25 installed package(s), purging......Environment now purged and fresh! 使用虚拟环境的shell。exit退出： 123$ pipenv shellLoading .env environment variables…Launching subshell in virtual environment. Type &apos;exit&apos; or &apos;Ctrl+D&apos; to return. 本文来自刘江的博客和教程网站http://www.liujiangblog.com/blog/","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"#ifdef、#ifndef、#endif","slug":"ifdef、-ifndef、-endif","date":"2018-12-08T08:07:37.000Z","updated":"2019-09-15T08:07:30.944Z","comments":true,"path":"2018/12/08/ifdef、-ifndef、-endif/","link":"","permalink":"https://nymrli.top/2018/12/08/ifdef、-ifndef、-endif/","excerpt":"","text":"#ifdef、#ifndef、#endif使用说明 目的:防止头文件重复include 示例说明: a.h 12#include &lt;stdio.h&gt;#include &quot;b.h&quot; b.h 1#include &quot;a.h&quot; c.c 12345#include &quot;a.h&quot;#include &quot;b.h&quot;int main()&#123; printf(&quot;Hello!&quot;);&#125; 如果你程序是这样写的话，编译器就会出现Error #include nested too deeply的错误。 因为这里 b.h 和 a.h 都互相include，c.c文件在include的时候重复include了a.h，我们希望c.c文件中执行#include &quot;b.h&quot;的时候 b.h 能进行判断，如果没有#include &quot;a.h&quot;则include，如果已经include了，则不再重复定义。 可以将b.h修改为： 1234#ifndef _A_H#define _A_H #include &quot;a.h&quot;#endif 原因是: &gt; c.c中先include了a.h文件，其中a.h中又包括了b.h，所以会定义宏_A_H，当c,c中又includeb,h时判断_A_H是否已经被定义了,如果被定义了,则不再includea.h","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"小程序——高德地图API调用","slug":"小程序——高德地图API调用","date":"2018-12-06T09:11:14.000Z","updated":"2019-09-15T08:07:31.048Z","comments":true,"path":"2018/12/06/小程序——高德地图API调用/","link":"","permalink":"https://nymrli.top/2018/12/06/小程序——高德地图API调用/","excerpt":"","text":"小程序——高德地图API调用 配置 将压缩包解压至使用的小程序目录下，创建libs文件夹，包含amap-wx.js 导入使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var amapFile = require('..­/../../../libs/amap-wx.js');Page(&#123; data: &#123; src: '' &#125;, onLoad: function () &#123; var that = this; var myAmapFun = new amapFile.AMapWX(&#123; key: \" dbb8be907441c2650218bdfd78848cf6\" &#125;); wx.getSystemInfo(&#123; success: function (data) &#123; //获得手机屏幕的高度宽度 var height = data.windowHeight; var width = data.windowWidth; var size = width + \"*\" + height; myAmapFun.getStaticmap(&#123; location: \"118.9301,32.109\", //地图中心 zoom: 15, //缩放比例 size: size, //尺寸大小 scale: 2, //像素,普通图、高清图 markers: //标记 \"large,0xFF0000,A:118.9301,32.109|mid,0xFF0000,B:118.9301,32.110\", success: function (data) &#123; that.setData(&#123; src: data.url &#125;) &#125;, fail: function (info) &#123; wx.showModal(&#123; title: info.errMsg &#125;) &#125; &#125;) &#125; &#125;) &#125;, onReady: function () &#123; &#125;, onShow: function () &#123; &#125;, onHide: function () &#123; &#125;, onUnload: function () &#123; &#125;, onPullDownRefresh: function () &#123; &#125;, onReachBottom: function () &#123; &#125;, onShareAppMessage: function () &#123; &#125;&#125;) API使用说明 参数名称 含义 规则说明 是否必填 默认值 key 用户唯一标识 用户在高德地图官网申请 必填 无 location 地图中心点 中心点坐标。规则：经度和纬度用&quot;,&quot;分隔 经纬度小数点后不得超过6位。 部分条件必填 无 zoom 地图级别 地图缩放级别:[1,17] 可选 无 size 地图大小 图片宽度图片高度。最大值为10241024 可选 400*400 scale 普通/高清 1:返回普通图；2:调用高清图，图片高度和宽度都增加一倍，zoom也增加一倍（当zoom为最大值时，zoom不再改变）。 可选 1 markers 标注 使用规则见markers详细说明，标注最大数10个 可选 无 labels 标签 使用规则见labels详细说明，标签最大数10个 可选 无 paths 折线 使用规则见paths详细说明，折线和多边形最大数4个 可选 无 traffic 交通路况标识 底图是否展现实时路况。 可选值： 0，不展现；1，展现。 可选 0 sig 数字签名 数字签名认证用户必填 可选 无 markers: 123markers:\"large,0xFF0000,A:118.9301,32.109|mid,0xFF0000,B:118.9301,32.110\",//ormarkers:\"large,0xFF0000,A:118.9301,32.109;B:118.9301,32.110\", 参数名称 说明 默认值 size 可选值： small,mid,large small color 选值范围：[0x000000, 0xffffff]例如：0x000000 black,0x008000 green,0x800080 purple,0xFFFF00 yellow,0x0000FF blue,0x808080 gray,0xffa500 orange,0xFF0000 red,0xFFFFFF white 0xFC6054 label [0-9]、[A-Z]、[单个中文字] 当size为small时，图片不展现标注名。 无 label，font ,bold, fontSize，fontColor，background 自定义markersStyle: -1，url，0。 -1表示为自定义图片，URL为图片的网址。自定义图片只支持PNG格式。 https://restapi.amap.com/v3/staticmap?markers=-1,http://ico.ooopic.com/ajax/iconpng/?id=158688.png,0:116.37359,39.92437&amp;key=您的key labels labels=labelsStyle1:location1;location2|labelsStyle2:location3;location4..|labelsStyleN:locationN;locationM labelsStyle：label, font, bold, fontSize, fontColor, background。 各参数使用&quot;,&quot;分隔，如有默认值则可为空。 参数名称 说明 默认值 content 标签内容，字符最大数目为15 无 font 0：微软雅黑；1：宋体；2：Times New Roman;3：Helvetica 0 bold 0：非粗体；1：粗体 0 fontSize 字体大小，可选值[1,72] 10 fontColor 字体颜色，取值范围：[0x000000, 0xffffff] 0xFFFFFF background 背景色，取值范围：[0x000000, 0xffffff] 0x5288d8 paths paths=pathsStyle1:location1;location2..|pathsStyle2:location3;location4..|pathsStyleN:locationN;locationM.. ▲.LocationN : 118.9301,32.109先经度后维度 pathsStyle：weight, color, transparency, fillcolor, fillTransparency 参数名称 说明 默认值 weight 线条粗细。可选值： [2,15] 5 color 折线颜色。 选值范围：[0x000000, 0xffffff]例如：0x000000 black,0x008000 green,0x800080 purple,0xFFFF00 yellow,0x0000FF blue,0x808080 gray,0xffa500 orange,0xFF0000 red,0xFFFFFF white 0x0000FF transparency 透明度。可选值[0,1]，小数后最多2位，0表示完全透明，1表示完全不透明。 1 fillcolor 多边形的填充颜色，此值不为空时折线封闭成多边形。取值规则同color 无 fillTransparency 填充面透明度。可选值[0,1]，小数后最多2位，0表示完全透明，1表示完全不透明。 0.5 折线示例: 1paths: &apos;10,0x0000ff,1,,:116.31604,39.96491;116.320816,39.966606;116.321785,39.966827;116.32361,39.966957&apos;, 区域示例: 1paths: &quot;10,0x0000ff,0.1,0x0000ff,0.7:116.31604,39.96491;116.320816,39.966606;116.321785,39.966827;116.32361,39.966957;116.39361,39.966957;116.39361,39.936957&quot;,","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"HTML和CSS学习","slug":"HTML和CSS学习","date":"2018-12-06T02:57:32.000Z","updated":"2021-12-03T03:07:59.277Z","comments":true,"path":"2018/12/06/HTML和CSS学习/","link":"","permalink":"https://nymrli.top/2018/12/06/HTML和CSS学习/","excerpt":"","text":"HTML学习 &lt;head&gt;中的&lt;meta&gt;标签 属性 值 描述 http-equiv content-typeexpiresrefreshset-cookie 把 content 属性关联到 HTTP 头部。 name authordescriptionkeywordsgeneratorrevisedothers 把 content 属性关联到一个名称。 scheme some_text 定义用于翻译 content 属性值的格式。 name 属性 name 属性提供了名称/值对中的名称。 “keywords” 是一个经常被用到的名称。它为文档定义了一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。 1&lt;meta name=&quot;keywords&quot; content=&quot;HTML,ASP,PHP,SQL&quot;&gt; ▲如果没有提供 name 属性，那么名称/值对中的名称会采用 http-equiv 属性的值。 http-equiv 属性 http-equiv 属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。 使用带有 http-equiv 属性的 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。例如，添加： 12&lt;meta http-equiv=&quot;charset&quot; content=&quot;iso-8859-1&quot;&gt;&lt;meta http-equiv=&quot;expires&quot; content=&quot;31 Dec 2008&quot;&gt; 这样发送到浏览器的头部就应该包含： 123content-type: text/htmlcharset:iso-8859-1expires:31 Dec 2008 content 属性 content 属性提供了名称/值对中的值。该值可以是任何有效的字符串。 content 属性始终要和 name 属性或 http-equiv 属性一起使用。 标签 &lt;em&gt;和&lt;strong&gt;标签是为了强调一段话中的关键字时使用，它们的语义是强调。 &lt;span&gt;标签是没有语义的，它的作用就是为了设置单独的样式用的。 &lt;q&gt;引用文本&lt;/q&gt;,注意要引用的文本不用加双引号，浏览器会对q标签自动添加双引号。 &lt;blockquote&gt;引用长文本&lt;/blockquote&gt; 使用&lt;br&gt;标签分行显示文本 空格&amp;nbsp; 认识&lt;hr /&gt;标签，添加水平横线 &lt;address&gt;标签，为网页加入地址信息 &lt;code&gt;var i=i+300;&lt;/code&gt;一行代码 &lt;pre&gt;语言代码段&lt;/pre&gt;大段代码 使用&lt;ul&gt;，添加新闻信息列表 创建表格table的四个元素： tbody：如果不加&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt; , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。 tr表格的一行，所以有几对tr 表格就有几行。 th表格表头。 td一行中数据单元格的个数。 &lt;caption&gt;标题文本&lt;/caption&gt; &lt;table summary=&quot;表格简介文本&quot;&gt;摘要 CSS学习 Q:CSS样式可以写在哪些地方呢？ A: 内联式 : 把css代码直接写在现有的HTML标签中 &lt;p style=&quot;color:red&quot;&gt;这里文字是红色。&lt;/p&gt; 嵌入式 : 把css样式代码写在&lt;style type=&quot;text/css&quot;&gt;&lt;/style标签之间，一般情况下嵌入式css样式写在&lt;head&gt;&lt;/head&gt;之间 12345&lt;style type=&quot;text/css&quot;&gt;span&#123;color:red;&#125;&lt;/style&gt; 外部式 : 把css代码写一个单独的外部文件中,这个css样式文件以“.css”为扩展名 &lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; ▲.三种方法的优先级 内联式 &gt; 嵌入式 &gt; 外部式 嵌入式&gt;外部式有一个前提：嵌入式css样式的位置一定在外部式的后面 ==&gt;其实总结来说，就是--就近原则（离被设置元素越近优先级别越高）。 权值: 标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100 12345p&#123;color:red;&#125; /*权值为1*/p span&#123;color:green;&#125; /*权值为1+1=2*/.warning&#123;color:white;&#125; /*权值为10*/p span.warning&#123;color:purple;&#125; /*权值为1+1+10=12*/#footer .note p&#123;color:yellow;&#125; /*权值为100+10+1=111*/ 还有一个权值比较特殊–继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。 ==&gt;根据权值和层叠的想法: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 提高权值的方法:重要性 12p&#123;color:red!important;&#125;p.first&#123;color:green;&#125; CSS格式化排版 字体 font-family: 字体 body{font-family:&quot;宋体&quot;;} font-size:字号 body{font-size:12px;color:#666} 1234p span&#123;font-weight:bold;&#125; //粗体p a&#123;font-style:italic;&#125; //斜体p a&#123;text-decoration:underline;&#125; //下划线.oldPrice&#123;text-decoration:line-through;&#125; //删除线 段落排版 text-indent:段落缩进 p{ text-indent:2em;} 行间距（行高） p{ line-height:1.5em;} 中文字间距、字母间距 h1{ word-spacing:50px;} 为块状元素中的文本、图片设置居中样式 h1{ text-align:center;} 元素分类 块状元素(block) 1&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行） 2、元素的高度、宽度、行高以及顶和底边距都可设置。 3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 内联元素(又叫行内元素):inline 1&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 1、和其他元素都在一行上； 2、元素的高度、宽度及顶部和底部边距不可设置； 3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 内联块状元素(inline-block） 1&lt;img&gt;、&lt;input&gt; 1、和其他元素都在一行上； 2、元素的高度、宽度、行高以及顶和底边距都可设置。 盒子模型 块级元素都具有盒子模型的特征 外边距 : marigin 内边距 : padding 边框 : border 盒模型–宽度和高度 元素的实际高度为 : 自身height+ padding-top +padding-bottom 元素的实际宽度为 : 自身width+ padding-left +padding-right ▲ 一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 总宽度计算: 开发工具查看: 边框: border-style（边框样式）常见样式有： dashed（虚线）| dotted（点线）| solid（实线） border-color（边框颜色）中的颜色可设置为十六进制颜色，如: border-color:#888;//前面的井号不要忘掉。 border-width（边框宽度）中的宽度也可以设置为： thin | medium | thick（但不是很常用），最常还是用像素（px）。 css布局模型 1、流动模型（Flow） 2、浮动模型 (Float) 3、层模型（Layer） 流动模型（Flow） 流动（Flow）是默认的网页布局模式. 2个比较典型的特征： 第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。 第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行） 浮动模型 (Float) 想让两个块状元素并排显示…任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动， 1234567/*实现两个 div 元素一行显示。*/div&#123; width:200px; height:200px; border:2px red solid; float:left;&#125; 层模型（Layer） 如何让html元素在网页中精确定位，就像图像软件PhotoShop中的图层一样可以对每个图层能够精确定位操作 1、绝对定位(position: absolute) 将元素从文档流中拖出来，然后使用left(距离左)、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口 2、相对定位(position: relative) 相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于**以前的位置移动，**移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 Q:什么叫做“偏移前的位置保留不动” A: 虽然div元素相对于以前的位置产生了偏移，但是div元素以前的位置还是保留着，所以后面的span元素是显示在了div元素以前位置的后面。 ===&gt; 所占的位置不变,但是显示的位置发生了变化. 3、固定定位(position: fixed) 与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身. 由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响， 用途 : 可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。 水平居中设置 行内元素 如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的 块状元素 定宽~ : 宽度width为固定值 通过设置“左右margin”值为“auto”来实现居中的 不定宽~ 加入 table 标签 table长度自适应性,其长度根据其内文本长度决定 12345678910111213&lt;div&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt; &lt;ul&gt; &lt;li&gt;我是第一行文本&lt;/li&gt; &lt;li&gt;我是第二行文本&lt;/li&gt; &lt;li&gt;我是第三行文本&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; css代码： 123456&lt;style&gt;table&#123; border:1px solid; margin:0 auto;&#125;&lt;/style&gt; ▲补充代码实现右侧中的 class 为 wrap 的 div 水平居中显示（要注意是这个 div元素 居中，而不是里面的文本居中啊）。 设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置 改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。如下例子： html代码： 123456789&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; css代码： 1234567891011121314151617&lt;style&gt;.container&#123; text-align:center;&#125;/* margin:0;padding:0（消除文本与div边框之间的间隙）*/.container ul&#123; list-style:none; margin:0; padding:0; display:inline;&#125;/* margin-right:8px（设置li文本之间的间隔）*/.container li&#123; margin-right:8px; display:inline;&#125;&lt;/style&gt; ▲ 改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。如下例子： 父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的 代码如下： 123456789&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; css代码： 1234567891011121314151617&lt;style&gt;.container&#123; float:left; position:relative; left:50%&#125;.container ul&#123; list-style:none; margin:0; padding:0; position:relative; left:-50%;&#125;.container li&#123;float:left;display:inline;margin-right:8px;&#125;&lt;/style&gt; 垂直居中 父元素高度确定的单行文本 通过设置父元素的 height 和 line-height 高度一致来实现的。 1234567&lt;style&gt;.container&#123; height:100px; line-height:100px; background:#999;&#125;&lt;/style&gt; 父元素高度确定的多行文本、图片 使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。 html代码： 12345678910111213&lt;body&gt;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=\"wrap\"&gt; &lt;div&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt; css代码： 12345table td&#123; height:500px; background:#ccc&#125;/*因为 td 标签默认情况下就默认设置了 vertical-align 为 middle，所以我们不需要显式地设置了。*/ 在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的display为 table-cell（设置为表格单元显示），激活 vertical-align 属性 html代码： 1234567&lt;div class=\"container\"&gt; &lt;div&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; css代码： 12345678&lt;style&gt;.container&#123; height:300px; background:#ccc; display:table-cell;/*IE8以上及Chrome、Firefox*/ vertical-align:middle;/*IE8以上及Chrome、Firefox*/&#125;&lt;/style&gt; 媒体查询 什么是媒体查询：媒体查询是向不同设备提供不同样式的一种方式，它为每种类型的用户提供了最佳的体验。 css2: media type media type(媒体类型)是css 2中的一个非常有用的属性，通过media type我们可以对不同的设备指定特定的样式，从而实现更丰富的界面。 css3: media query media query是CSS3对media type的增强，事实上我们可以将media query看成是media type+css属性(媒体特性Media features)判断。 CSS 语法 12345678910111213141516@media *mediatype* and|not|only *(media feature)* &#123;* CSS-Code;*&#125;// 如, 当屏幕的最大宽度超过300px时, 将body的颜色改成lightblue@media screen and (max-width: 300px) &#123; body &#123; background-color:lightblue; &#125;&#125;@media (min-width: 100px)&#123; span &#123; display: none &#125; // https://www.bilibili.com/video/BV1qQ4y1i7mZ, 响应式导航菜单【CSS小技巧】&#125; 隐性改变display类型 position : absolute float : left 或 float:right 只要html代码中出现以上两句之一，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"HTML","slug":"HTML","permalink":"https://nymrli.top/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://nymrli.top/tags/CSS/"}]},{"title":"Pyinstaller使用","slug":"Pyinstaller使用","date":"2018-12-03T03:54:22.000Z","updated":"2021-10-18T10:21:16.331Z","comments":true,"path":"2018/12/03/Pyinstaller使用/","link":"","permalink":"https://nymrli.top/2018/12/03/Pyinstaller使用/","excerpt":"","text":"pyinstaller使用 PyInstaller是一个跨平台的Python应用打包工具，支持 Windows/Linux/MacOS三大主流平台，能够把 Python 脚本及其所在的 Python 解释器打包成可执行文件，从而允许最终用户在无需安装 Python 的情况下执行应用程序。 PyInstaller 制作出来的执行文件并不是跨平台的，如果需要为不同平台打包，就要在相应平台上运行PyInstaller进行打包。 PyInstaller打包的流程：读取编写好的Python项目–&gt;分析其中条用的模块和库，并收集其文件副本（包括Python的解释器）–&gt;将副本和Python项目文件（放在一个文件夹//封装在一个可执行文件）中。 安装 1、安装pywin32==&gt;pyinstaller依赖于 下载安装文件：查找到跟自己适用的python版本及window系统版本匹配的pywin32，下载后安装 使用pip命令安装：pip install pywin32 2、安装Pyinstaller 下载安装文件安装：官网 使用pip命令安装：pip install PyInstaller 使用Pycharm直接搜索pyinstaller会自动安装依赖库pywin32 使用 1、使用下载安装的方式安装的Pyinstaller打包方式 将需要打包的文件放在解压得到的Pyinstaller文件夹中，打开cmd窗口，把路径切换到当前路径打开命令提示行，输入以下内容（最后的是文件名）==&gt;调用pyinstaller.py文件打包： python pyinstaller.py -F myfile.py 2、使用pip方式安装的Pyinstaller打包方式 打开cmd窗口，把路径切换到文件所在路径(文件随便放在哪里都行)打开命令提示行，输入以下内容（最后的是文件名）： pyinstaller -F myfile.py 使用实例 pyinstaller -F test.py -i src\\logo.ico -F 表示生成单个可执行文件 -w 表示去掉控制台窗口，这在GUI界面时非常有用。不过如果是命令行程序的话那就把这个选项删除吧！ -p 表示你自己自定义需要加载的库路径，一般情况下用不到 -i 表示可执行文件的图标 ▲. -i的参数为.ico格式,其他格式的图片会报错 文件中使用了第三方库的打包方式 在打包之前务必找到第三方库的包，把包复制到到跟myfile.py同目录下，然后再使用以上2种方式打包，否则会打包失败或者即使打包成功，程序也会闪退。 pyqt5打包出现错误 一 、当写这篇文章的时候，pyinstaller官网版本对pyqt5打包可能会遇到Could not find QtWebEngineProcess.exe.的错误。解决方法为：安装最新的pyinstaller 1.在github下载新版本的开发包。 2.打开解压后的文件夹，shift+鼠标右键，点击“在此处打开命令窗口”。之后依次运行如下命令: 123pip uninstall pyinstallerpython setup.py buildpython setup.py install 二 、如果有报错：“could not find or load the Qt platform plugin &quot;windows&quot; ”。原因之一可能是你把打包后的文件放在了中文目录下。只需要将打包后的文件放在英文目录下，就可以解决。 多文件打包 1234pyinstaller [主文件] -p [其他文件1] -p [其他文件2] --hidden-import [自建模块1] --hidden-import [自建模块2]# 以上为一整条命令 1pyinstaller main.py -p mysql.py -p other.py --hidden-import mysql --hidden-import other","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"pyqt5与QT5","slug":"pyqt与QT5","date":"2018-11-26T04:11:52.000Z","updated":"2019-09-17T09:44:06.126Z","comments":true,"path":"2018/11/26/pyqt与QT5/","link":"","permalink":"https://nymrli.top/2018/11/26/pyqt与QT5/","excerpt":"","text":"Pyqt5和QT5 拖拽式布局 添加QT Designer、PyUIc、Pyrcc 1.添加外部工具(Extenal Tools) QT Designer File–&gt;Settings–&gt;Tools–&gt;Extenal Tools --&gt; ‘’+’’ &gt; 添加具体细节,如图一图二 ​ 图一 ​ 图二 修改Name为QT Designer,Program为QT目录下designer.exe文件,不需要参数,Work directory为D:\\QT\\{QT version}\\msvc2015_64\\bin 添加后就可以在菜单栏的Tools中找到…点击后,就可以直接打开QT Designer设计窗口 QT Designer QT UIC 1.Program设置为当前虚拟环境的python解释器python.exe,(一旦设置好后,每次新建虚拟环境,pycharm会自动帮你修改选择的解释器) 2.▲.Arguments参数设置为: 12345-mPyQt5.uic.pyuic$FileName$-o$FileNameWithoutExtension$.py 这个参数主要是用uic这个工具需要指定的参数 3.working directory设置为$FileDir$(当前文件目录)===&gt;含义是:根据.UI生成的py窗口文件的位置 完成后,效果如图…一开始是没有window.py 将光标选择window.ui文件,然后选择Tools里面的PyUIC就可以自动生成一个window.py文件直接使用了. 控制台输出内容: 123G:\\PyGui\\venv\\Scripts\\python.exe -m PyQt5.uic.pyuic window.ui -o window.py#点击PyUIC就相当于输出了在setting里面写好的代码,$FileName$为我们光标选择的文件名,输出的名字为$FileNameWithoutExtension$.py,输出的路径为当前文件目录$FileDir$Process finished with exit code 0 QT Rcc 1.将program设置为QT目录下的rcc.exe文件 2.设置Arguments为 123$FileName$-o$FileNameWithoutExtension$.py 道理同上-o 是输出的意思 3.work directory设置为$FileDir$ 4.新建.qrc资源文件 打开QT Designer选择下面的资源管理器,单击铅笔,如图操作 单击左边蓝色的存储后,意思是指定.qrc文件存储位置 选择好以后,再操作右边的选择卡,填好前缀,然后点击蓝色的按键,选择要添加的资源文件(如图片什么的) 此时打开.qrc文件就可以看到他指定了哪些资源文件 上述步骤完成后就可以使用rcc工具将.qrc文件转换成.py的资源文件使用了 光标选择.qrc资源后,选择Pyrcc后就会生成相应的py文件 需要用到图片时,直接导入图片的.py文件即可 12[mainwindow.py]import picture 12345678910111213[main.py]#显示加载界面if __name__ == '__main__': app = QApplication(sys.argv) splash = QSplashScreen(QPixmap(':/load/loading.jpg')) splash.show() splash.showMessage('正在加载请稍等..') time.sleep(0.5) app.processEvents() ui = caofunction.MyWindow() ui.show() splash.finish(ui) sys.exit(app.exec_()) Main.py 123456789import sysimport caofunctionfrom PyQt5.QtWidgets import QApplication, QMainWindowif __name__ == &apos;__main__&apos;: app = QApplication(sys.argv) ui = caofunction.MyWindow() ui.show() sys.exit(app.exec_()) 12345678启动窗口的run()函数# if __name__ == &quot;__main__&quot;:# app = QtWidgets.QApplication(sys.argv)# Dialog = QtWidgets.QDialog()# ui = Ui_Dialog()# ui.setupUi(Dialog)# Dialog.show()# sys.exit(app.exec_()) 槽函数.py 12345678910111213from PyQt5 import QtWidgetsfrom PyQt5.QtWidgets import QMessageBoximport helloclass MyWindow(QtWidgets.QMainWindow,hello.Ui_MainWindow): def __init__(self,parent=None): QtWidgets.QMainWindow.__init__(self,parent) # super(MyWindow,self).__init__() self.setupUi(self) self.pushButton_2.clicked.connect(self.pint) def pint(self): my_choice = QMessageBox.information(self,&apos;提示框&apos;,&apos;Maybe wrong&apos;) 一个bottom最好只对应一个槽函数。 信号与槽连接函数： 123456self.pushButton_2.clicked.connect(Ui_MainWindow.pint)*connect()括号中可以选为/Ui_MainWindow/（父类类名）,/MainWindow/（父类中实例窗口名），/继承父类Ui_MainWindow的子类类名/，还有一种/self.pint/*★/*Qt5中的槽函数不在限定必须是slot，可以是普通的函数、类的普通成员函数、lambda函数等*/▲注意是pint，而不是pint(),传入的是函数的名称（函数地址）△如果在子类和父类中重复了connect，则会被执行多遍 QMessageBox: information question warning critial about aboutQT 用户输入对话框： 12345678my_choice = QInputDialog.getText(self,&apos;字符串&apos;,&apos;请在此处输入&apos;,QLineEdit.Normal,&apos;...&apos;)返回的是一个元祖(str,bool)my_choice = QInputDialog.getText(self,&apos;字符串&apos;,&apos;请在此处输入&apos;,2，0,30)//最后2：最小和最大返回的是一个元祖(int,bool)---my = [&apos;apple&apos;,&apos;orange&apos;]my_choice = QtWidgets.QInputDialog.getItem(self,&apos;输入框&apos;,&apos;请在此输入&apos;,my)■.pyqt5中没有Qstring类型，所以没有QString() 加载界面设计： 1234567891011if __name__ == &apos;__main__&apos;: app = QApplication(sys.argv) splash = QSplashScreen(QPixmap(&apos;:/test/3.jpg&apos;)) splash.show() splash.showMessage(&apos;正在加载请稍等&apos;) time.sleep(0.5) app.processEvents() ui = caofunction.MyWindow() ui.show() splash.finish(ui) sys.exit(app.exec_()) 转化.qrc资源文件为py文件： -o ui_form.py form.ui1CMD: pyrcc5 -o picture.py picture.qrc 菜单栏 1234567class MyWindow(QtWidgets.QMainWindow,hello.Ui_MainWindow): def __init__(self,parent=None): QtWidgets.QMainWindow.__init__(self,parent) self.action_4.triggered.connect(self.exit) def exit(self): self.close() 类中再定义函数时，定义和调用应为: 123456789101112self.mostphoto(file_path)#调用def mostphoto(self,filename): import re with open(filename, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f: data = f.read() times = re.findall(re.compile(r&quot;(\\d\\d):\\d\\d:\\d\\d&quot;), data) phototimes = re.findall(re.compile(r&quot;[图片]&quot;), data) if (len(phototimes) &gt; (len(times) - len(phototimes))): QMessageBox.information(self,&apos;提示框&apos;,&apos;两位斗图鬼才用表情包征服了彼此&apos;) else: QMessageBox.information(self,&apos;提示框&apos;,&apos;情话绵绵，爱情已融入生活中的点滴&apos;) 弹出对话框： 12my_info = Dialog()my_info.exec_() QApplication类代表应用程序，在每个程序中只能有一个它的实例。在有图形界面的程序中必须有一个QApplication类的实例，并且必须在所有窗口类的实例生成之前生成。它最主要的功能是实现主事件循环。在主事件循环内，窗口才可以相应消息，并对事件做出处理。QApplication类的exec方法代表启动主事件循环.在主事件循环内，窗口才可以响应消息，并对事件做出处理。QApplication类的exec方法代表启动主事件循环，这个函数在正常运行时不会返回，只有当主事件循环退出时才返回，通常这也就意味着整个程序要退出。 ​ QApplication类的构造函数接受与main函数相同的参数，它也能够处理执行程序时的命令行参数。这里的参数传递是必需的，因为在执行程序时要用到QApplication类才能识别的-qws参数。 本文来自 Tyrion-Lannister 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/HMSIWTV/article/details/7533524?utm_source=copy pyQT使用教程","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"机器学习——数学概念","slug":"机器学习——数学概念","date":"2018-11-24T05:00:34.000Z","updated":"2019-09-15T08:07:31.080Z","comments":true,"path":"2018/11/24/机器学习——数学概念/","link":"","permalink":"https://nymrli.top/2018/11/24/机器学习——数学概念/","excerpt":"","text":"箱线图 箱线图（Box plot）也称箱须图（Box-whisker Plot）、箱线图、盒图，可以用来反映一组或多组连续型定量数据分布的中心位置和散布范围，因形状如箱子而得名。 - 连续型数据：在一定区间内可以任意取值的变量叫连续变量，其数值是连续不断的。例如，生产零件的规格尺寸，人体测量的身高、体重等，其数值只能用测量或计量的方法取得。可视化这类数据的图表主要有箱形图和直方图。 - 离散型数据：数值只能用自然数或整数单位计算的则为离散变量。例如，企业个数，职工人数，设备台数等，只能按计量单位数计数，数值一般用计数方法取得。大多数图表可视化的都是这类数据，比如柱状图、折线图等。 优点: 箱形图最大的优点就是不受异常值的影响，能够准确稳定地描绘出数据的离散分布情况，同时也利于数据的清洗。 箱子上的线 四分位数 Q1:第一四分位数(下四分位数) Q2:中位数 Q3:第三四分位数(上四分位数) 一组数据按照从小到大顺序排列后，把该组数据四等分的数，称为四分位数。第一四分位数 (Q1)、第二四分位数 (Q2，也叫“中位数”)和第三四分位数 (Q3)分别等于该样本中所有数值由小到大排列后第25%、第50%和第75%的数字。第三四分位数与第一四分位数的差距又称四分位距（interquartile range, IQR）。 **箱子的高度在一定程度上反映了数据的波动程度 上下线 上下边缘则代表了该组数据的最大值和最小值 上限 :上限是非异常范围内的最大值。 下限:下限是非异常范围内的最小值。 有时候箱子外部会有一些点，可以理解为数据中的“异常值”。 偏态 与正态分布相对，指的是非对称分布的偏斜状态。在统计学上，众数和平均数之差可作为分配偏态的指标之一：如平均数大于众数，称为正偏态（或右偏态）；相反，则称为负偏态（或左偏态）。 偏态表示偏离程度，异常值集中在较小值一侧，则分布呈左偏态；异常值集中在较大值一侧，则分布呈右偏态。 Confusion_martrix(混淆矩阵) 混淆矩阵: 一种特定的矩阵用来呈现算法性能的可视化效果，通常是监督学习（非监督学习，通常用匹配矩阵：matching matrix） 其每一列代表预测值，每一行代表的是实际的类别。这个名字来源于它可以非常容易的表明多个类别是否有混淆（也就是一个class被预测成另一个class）。 Example样例说明: 假设有一个用来对猫（cats）、狗（dogs）、兔子（rabbits）进行分类的系统，混淆矩阵就是为了进一步分析性能而对该算法测试结果做出的总结。假设总共有 27 只动物：8只猫， 6条狗， 13只兔子。结果的混淆矩阵如下图： 在这个混淆矩阵中，实际有 8只猫，但是系统将其中3只预测成了狗；对于 6条狗，其中有 1条被预测成了兔子，2条被预测成了猫。从混淆矩阵中我们可以看出系统对于区分猫和狗存在一些问题，但是区分兔子和其他动物的效果还是不错的。所有正确的预测结果都在对角线上，所以从混淆矩阵中可以很方便直观的看出哪里有错误，因为他们呈现在对角线外面。 Table of confusion(混淆表格) 有时也称混淆矩阵. 由false positives，false negatives，true positives和true negatives组成的两行两列的表格。它允许我们做出更多的分析，而不仅仅是局限在正确率.。 它允许我们做出更多的分析，而不仅仅是局限在正确率。准确率对于分类器的性能分析来说，并不是一个很好地衡量指标，因为如果数据集不平衡（每一类的数据样本数量相差太大），很可能会出现误导性的结果。例如，如果在一个数据集中有95只猫，但是只有5条狗，那么某些分类器很可能偏向于将所有的样本预测成猫。整体准确率为95%，但是实际上该分类器对猫的识别率是100%，而对狗的识别率是0%。 对于上面的说明样例，其对应的对猫这个类别的混淆表格如下： 假定一个实验有 P个positive实例，在某些条件下有 N 个negative实例。那么上面这四个输出可以用下面的偶然性表格（或混淆矩阵）来表示： 更多详情见博客 摘自博客 : https://blog.csdn.net/vesper305/article/details/44927047","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"数学知识","slug":"数学知识","permalink":"https://nymrli.top/tags/数学知识/"}]},{"title":"机器学习——python实践.笔记","slug":"机器学习——Python实践-笔记","date":"2018-11-23T13:20:18.000Z","updated":"2019-09-15T08:07:31.078Z","comments":true,"path":"2018/11/23/机器学习——Python实践-笔记/","link":"","permalink":"https://nymrli.top/2018/11/23/机器学习——Python实践-笔记/","excerpt":"","text":"机器学习——Python实践 Numpy: python开源数值计算拓展,用来存储和处理大型矩阵,提供了许多高级的数值编程工具,如 矩阵数据类型、矢量处理、精密的运算库 利用Numpy数组来准备机器学习算法的数据 matplotlib: python中最著名的2D绘图库,适合交互式的进行制图;也可作为绘图空间,嵌入GUI应用程序中 创建图表,展示数据 Pandas: 基于Numpy的工具,为了解决数据分析任务而创建的.~纳入了大量库和标准的数据模型,提供了操作大型数据集的工具,和快速便捷处理数据的函数和方法 导入、展示数据，以便挣钱对数据的理解和数据清洗、转换等工作 预测模型所需的六个步骤: 第一章： 鸢尾花(Iris Flower) 所有特征数据都是数字,不需要考虑如何导入和处理数据—&gt;有的图表有标题等的,需要处理- 分类问题===&gt;监督学习算法 多分类问题,可能需要一些特殊处理 所有特征的数值采用相同单位,不需要进行尺度转换 步骤: 1.导入数据集 123456789from pandas import read_csvfrom matplotlib import pyplotfrom sklearn.svm import SVCfilename = 'iris.data.csv'names = ['separ-length','separ-width','petal-length','petal-width','class']# 花萼长度+宽度 , 花瓣长度+宽度dataset = read_csv(filename,names = names)print(dataset) # 150 * 5 2.概述数据 从下列角度审查数据: 数据的维度 查看数据的自身 统计描述所有的数据特征 数据分类的分布情况 1.数据的维度 了解数据集中有多少行数据,数据有几个属性 12print('数据的维度: 行 %s , 列 %s' % (dataset.shape))#&gt;&gt;&gt;数据的维度: 行 150 , 列 5 2.参看数据本身 直观的看到数据的特征,数据的类型,以及大概的数据分布范围 12345678print(dataset.head(5))&gt;&gt;&gt; separ-length separ-width ... petal-width class0 5.1 3.5 ... 0.2 Iris-setosa1 4.9 3.0 ... 0.2 Iris-setosa2 4.7 3.2 ... 0.2 Iris-setosa3 4.6 3.1 ... 0.2 Iris-setosa4 5.0 3.6 ... 0.2 Iris-setosa 3.统计描述数据 数据特征的统计描述信息包括数据的行数、中位值、最大值、最小值、均值、四分位值等统计数据信息 1234567891011print(dataset.describe())&gt;&gt;&gt; separ-length separ-width petal-length petal-widthcount 150.000000 150.000000 150.000000 150.000000mean 5.843333 3.054000 3.758667 1.198667std 0.828066 0.433594 1.764420 0.763161min 4.300000 2.000000 1.000000 0.10000025% 5.100000 2.800000 1.600000 0.30000050% 5.800000 3.000000 4.350000 1.30000075% 6.400000 3.300000 5.100000 1.800000max 7.900000 4.400000 6.900000 2.500000 4.数据分类分布 了解数据在不同分类的分布情况…==&gt;每个分类数据量的绝对数值 1234567print(dataset.groupby('class').size())&gt;&gt;&gt;classIris-setosa 50Iris-versicolor 50Iris-virginica 50dtype: int64 ▲ 如果数据分布不平衡,可能会影响到模型的准确性,…==&gt;不平衡时,需要对数据进行调整,方法有: 扩大数据样本 通常容易被忽略的选择…但往往找到更大的数据集就有可能挖掘出更平衡的方面提高算法准确度 数据的重新抽样 过抽样(复制少数类样本)…数据少时考虑 欠抽样(删除多数类样本)…数据多时考虑 尝试生成人工样本 从少数类的实例中随机抽样特征属性,生成更多数据 异常检测和变化检测 尝试从不同观点思考,异常检测是对罕见事件的检测,将小类作为异常值类 3.数据可视化 单变量图表: 理解每一个特征属性 多变量图表: 理解不同特征属性之间的关系 单变量图: 箱线图: 一种用作显示一组数据分散情况资料的统计图。因形状如箱子而得名。 主要用于反映原始数据分布的特征，还可以进行多组数据分布特征的比 较。箱线图的绘制方法是：先找出一组数据的最大值、最小值、中位数和两个四分位数；然后， 连接两个四分位数画出箱子；再将最大值和最小值与箱子相连接，中位数在箱子中间。 12345678#箱线图 , 因为每个特征属性都是数字 , 所以 用箱线图展示 属性与中位值的离散程度dataset.plot(kind='box',subplots = True,layout = (2,2) , sharex = False , sharey = False)# 参数说明 : box箱线 , subplots 允许多个子图, layout 布局为2*2 , sharex.sharey 不共享x,ypyplot.show()#---#直方图 , x轴为值 , y轴为数量dataset.hist()pyplot.show() 多变量图: 12345from pandas.plotting import scatter_matrix#散点矩阵图scatter_matrix(dataset)pyplot.show()#pyplot.savefig(\"scatter_matrix.png\") 4.评估算法 分离出评估数据集 采用10折交叉验证来评估算法模型 生成6个不同的模型来预测新数据 选择最优模型 1.分离出评估数据集 ❤️要想知道算法模型对真是数据的准确度,所以保留一部分数据来评估算法模型. 12345678from sklearn.model_selection import train_test_splitarray = dataset.valuesX = array[:,0:4] #除了最后的class类别Y = array[:,4] #类别,目标validation_size = 0.2 #验证比例seed = 7 #随机种子X_train , X_validation , Y_train , Y_validation = \\ train_test_split(X,Y,test_size=validation_size,random_state=seed) 2.评估模式 采用10折交叉验证来分离训练数据集 : 随机将数据分成10份,9份用来训练模型,1份用来评估算法 3.创建模型 线性 线性回归(LR) 线性判别分析(LDA) 非线性 K近邻(KNN) 分类与回归树(CART) 贝叶斯分类器(NB) 支持向量机(SVM) ▲ 在每次对算法进行评估前都会重新设置随机数种子,以保证每次对算法的评估都是用相同的数据集 12345678910111213141516171819202122from sklearn.linear_model import LogisticRegression,LinearRegression #LRfrom sklearn.tree import DecisionTreeClassifier #CARTfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis #LDAfrom sklearn.naive_bayes import GaussianNB #NBfrom sklearn.neighbors import KNeighborsClassifier #KNNfrom sklearn.svm import SVC #SVMfrom sklearn.model_selection import KFold,cross_val_scoremodels = &#123;&#125;models['LR'] = LogisticRegression()models['LDA'] = LinearDiscriminantAnalysis()models['CART'] = DecisionTreeClassifier()models['NB'] = GaussianNB()models['KNN'] = KNeighborsClassifier()models['SVM'] = SVC()#评估算法resutls = []for key in models: kfold = KFold(n_splits=10,random_state=seed) cv_result = cross_val_score(models[key],X_train,Y_train,cv = kfold , scoring = 'accuracy') #cross_val_score将交叉验证的整个过程连接起来，不用再进行手动的分割数据, cv参数用于规定将原始数据分成多少份 resutls.append(cv_result) print(\"%s: %f (%f)\" % (key,cv_result.mean(),cv_result.std())) #均值,标准差 4.选择最优模型 1234567&gt;&gt;&gt;LR: 0.966667 (0.040825)LDA: 0.975000 (0.038188)CART: 0.966667 (0.040825)NB: 0.975000 (0.053359)KNN: 0.983333 (0.033333)SVM: 0.991667 (0.025000) 为什么使用 10折交叉验证? 进行模型验证的一个重要目的是要选出一个最合适的模型，对于监督学习而言，我们希望模型对于未知数据的泛化能力强，所以就需要模型验证这一过程来体现不同的模型对于未知数据的表现效果。 训练准确度==&gt;测试准确度 最先我们用训练准确度（用全部数据进行训练和测试）来衡量模型的表现，这种方法会导致模型过拟合(方差大)；===&gt;&gt;为了解决这一问题，我们将所有数据分成训练集和测试集两部分，我们用训练集进行模型训练，得到的模型再用测试集来衡量模型的预测表现能力，这种度量方式叫测试准确度，这种方式可以有效避免过拟合。 测试准确度==&gt;10折交叉验证 测试准确度的一个缺点是其样本准确度是一个高方差估计（high variance estimate）, 所以该样本准确度会依赖不同的测试集，其表现效果不尽相同。 12345678910111213for i in xrange(1,5): print \"random_state is \", i,\", and accuracy score is:\" X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=i) knn = KNeighborsClassifier(n_neighbors=5) knn.fit(X_train, y_train) y_pred = knn.predict(X_test) print metrics.accuracy_score(y_test, y_pred)&gt;&gt;&gt;random_state is 1 , and accuracy score is:1.0random_state is 2 , and accuracy score is:1.0random_state is 3 , and accuracy score is:0.947368421053random_state is 4 , and accuracy score is:0.973684210526 上面的测试准确率可以看出，不同的训练集、测试集分割的方法导致其准确率不同，而交叉验证的基本思想是：1.将数据集进行一系列分割，生成一组不同的训练测试集，2.然后分别训练模型并计算测试准确率，3.最后对结果进行平均处理。这样来有效降低测试准确率的差异。 K折交叉验证: 将数据集平均分割成K个等份子集 使用1份数据(子集)作为测试数据，其余(K-1)份作为训练数据 计算测试准确率 使用不同的测试集，重复2、3步骤 对测试准确率做平均，作为对未知数据预测准确率的估计 ==&gt; cross_val_score.mean() 不同的训练集、测试集分割的方法导致其准确率不同，而交叉验证的基本思想是：将数据集进行一系列分割，生成一组不同的训练测试集，然后分别训练模型并计算测试准确率，最后对结果进行平均处理。这样来有效降低测试准确率的差异。 来自周志华&lt;&lt;机器学习&gt;&gt;: 分割方法 1234# 下面代码演示了K-fold交叉验证是如何进行数据分割的# simulate splitting a dataset of 25 observations into 5 foldsfrom sklearn.cross_validation import KFoldkf = KFold(25, n_folds=5, shuffle=False) 12cv_result = cross_val_score(models[key],X_train,Y_train,cv = 10 , scoring = 'accuracy')#cross_val_score将交叉验证的整个过程连接起来，不用再进行手动的分割数据, cv参数用于规定将原始数据分成多少份 5.实施预测 12345678910111213141516171819#使用评估数据集评估算法svm = SVC()svm.fit(X = X_train ,y = Y_train) #参数为 X , ypredictions = svm.predict(X_validation)print(accuracy_score(Y_validation,predictions)) #测试集结果 与 预测结果 相比print(confusion_matrix(Y_validation,predictions))print(classification_report(Y_validation,predictions))&gt;&gt;&gt;0.9333333333333333[[ 7 0 0] [ 0 10 2] #混淆矩阵只出现了两个错误,2 [ 0 0 11]] precision(精确度) recall(召回率) f1-score(F1值) support(总和) Iris-setosa 1.00 1.00 1.00 7Iris-versicolor 1.00 0.83 0.91 12 Iris-virginica 0.85 1.00 0.92 11 avg / total 0.94 0.93 0.93 30 召回率(Recall Rate,也叫查全率) 是检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率； 精度(Precise) 是检索出的相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率。 TP: 预测为正，实际为正 (第一个是实际T或F,第二个是预测P或N) FP: 预测为正，实际为负 TN:预测为负，实际为负 FN: 预测为负，实际为正 精确率、准确率：Accuracy=(TP+TN)/(TP+TN+FN+FP) //精准率、查准率：P = TP/ (TP+FP) 召回率、查全率：R = TP/ (TP+FN) F1-score: 2*TP/(2*TP + FP + FN) ◆. 精确度是“搜索结果有多大用处”，而召回是“结果如何完整”。 F1分数: 概述 : 统计学中用来衡量二分类模型精确度的一种指标。它同时兼顾了分类模型的准确率和召回率。F1分数可以看作是模型准确率和召回率的一种加权平均，它的最大值是1，最小值是0。 人们通常使用准确率和召回率这两个指标，来评价二分类模型的分析效果。 但是当这两个指标发生冲突时，我们很难在模型之间进行比较。比如，我们有如下两个模型A、B，A模型的召回率高于B模型，但是B模型的准确率高于A模型，A和B这两个模型的综合性能，哪一个更优呢？ 准确率 召回率 A 80% 90% B 90% 80% 为了解决这个问题，人们提出了FβF_{\\beta}Fβ​ 分数。FβF_{\\beta}Fβ​的物理意义就是将准确率和召回率这两个分值合并为一个分值，在合并的过程中，召回率的权重是准确率的 β\\betaβ倍。F1F_{1}F1​分数认为召回率和准确率同等重要， F2F_{2}F2​ 分数认为召回率的重要程度是准确率的2倍，而分F0.5F_{0.5}F0.5​数认为召回率的重要程度是准确率的一半。 Fβ=(1+β2)⋅ precision recall(β2⋅ precision )+recallF _ { \\beta } = \\left( 1 + \\beta ^ { 2 } \\right) \\cdot \\frac { \\text { precision recall} } { \\left( \\beta ^ { 2 } \\cdot \\text { precision } \\right) + \\text {recall} }Fβ​=(1+β2)⋅(β2⋅ precision )+recall precision recall​ β=recall rateaccuracy rate\\beta = \\frac { \\text {recall rate} } { \\text {accuracy rate} }β=accuracy raterecall rate​ ▲ 如何计算Precise、Recall、F1-score见博客https://blog.csdn.net/akadiao/article/details/78788864 Confusion_martrix(混淆矩阵) 混淆矩阵: 一种特定的矩阵用来呈现算法性能的可视化效果，通常是监督学习（非监督学习，通常用匹配矩阵：matching matrix） 其每一列代表预测值，每一行代表的是实际的类别。这个名字来源于它可以非常容易的表明多个类别是否有混淆（也就是一个class被预测成另一个class）。 Example样例说明: 假设有一个用来对猫（cats）、狗（dogs）、兔子（rabbits）进行分类的系统，混淆矩阵就是为了进一步分析性能而对该算法测试结果做出的总结。假设总共有 27 只动物：8只猫， 6条狗， 13只兔子。结果的混淆矩阵如下图： 在这个混淆矩阵中，实际有 8只猫，但是系统将其中3只预测成了狗；对于 6条狗，其中有 1条被预测成了兔子，2条被预测成了猫。从混淆矩阵中我们可以看出系统对于区分猫和狗存在一些问题，但是区分兔子和其他动物的效果还是不错的。所有正确的预测结果都在对角线上，所以从混淆矩阵中可以很方便直观的看出哪里有错误，因为他们呈现在对角线外面。****","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Pycharm里无法查看Sqlite数据表","slug":"Pycharm里无法查看Sqlite数据表","date":"2018-11-23T07:27:38.000Z","updated":"2019-09-15T08:07:30.971Z","comments":true,"path":"2018/11/23/Pycharm里无法查看Sqlite数据表/","link":"","permalink":"https://nymrli.top/2018/11/23/Pycharm里无法查看Sqlite数据表/","excerpt":"","text":"Pycharm里无法查看Sqlite数据表 听说Pycharm可以直接看数据库,于是试了试,发现无法读取sqlite数据库的内容…于是发现下载相应的驱动.如图 解决方法: 一.打开右侧的Database选项卡,选择Data Source的Sqlite 二.点击黄色三角Download下载相应的驱动软件 三.安装完成,正常使用","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://nymrli.top/tags/数据库/"}]},{"title":"flask-sqlalchemy使用与sqlalchemy对比","slug":"flask-sqlalchemy使用与sqlalchemy对比","date":"2018-11-23T07:22:48.000Z","updated":"2022-03-19T02:49:15.508Z","comments":true,"path":"2018/11/23/flask-sqlalchemy使用与sqlalchemy对比/","link":"","permalink":"https://nymrli.top/2018/11/23/flask-sqlalchemy使用与sqlalchemy对比/","excerpt":"","text":"flask-sqlalchemy使用与sqlalchemy对比 flask-sqlalchemy 12345678910111213141516171819202122232425from exts import dbclass MGroup(db.Model): __tablename__ = 'Group' id = db.Column(db.Integer, primary_key=True, autoincrement=True) name = db.Column(db.String(50),nullable=False,unique = True)class MUserinfo(db.Model): __tablename__ = 'Userinfo' id = db.Column(db.Integer,primary_key=True,autoincrement=True) stuid = db.Column(db.String(15),unique = True ,nullable=False) subject = db.Column(db.String(50), nullable=False) name = db.Column(db.String(10), nullable=False) qq = db.Column(db.Integer,nullable = False) dirction = db.Column(db.String(20),db.ForeignKey('Group.name'),default='3D仿真组')class Mmessage(db.Model): __tablename__ = 'Contact' id = db.Column(db.Integer,primary_key=True,autoincrement=True) name = db.Column(db.String(10), nullable=False) email = db.Column(db.String(20), nullable=False) subject = db.Column(db.String(20), nullable=False) message = db.Column(db.Text, nullable=False) sqlalchemy 123456789101112131415161718192021import sqlalchemyfrom sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmakerprint(sqlalchemy.__version__)engine = create_engine('sqlite:///test.db',echo = True) #将数据库执行的语句打印出来Base = declarative_base() #声明一个基类实例class User(Base): __tablename__ = 'User' #表的名称 #类的属性,而不是在析构函数中定义的原因是,Base类中有构造函数 Uid = sqlalchemy.Column(sqlalchemy.Integer,autoincrement=True,primary_key=True) name = sqlalchemy.Column(sqlalchemy.String(20),nullable=False) def __str__(self): return \"&lt;Uid&gt;:&#123;&#125;,&lt;name&gt;:&#123;&#125;\".format(self.Uid,self.name)Base.metadata.create_all(engine) #创建数据库表,sqlalchemy会自动覆盖已存在的表 flask-sqlalchemy sqlalchemy 表继承的类 db = SQLAlchemy(app),db.Model Base = declarative_base() 都是从工厂函数中声明的一个实例类,作为声明性类基类 链接数据库函数 create_engine() 创建表函数 db.create_all() Base.metadata.create_all(engine) 表单字段 db.Column() sqlalchemy.Column() 字段类型 db.Integer sqlalchemy.Integer 插入数据 msg = Mmessage(name=data.get(‘name’),email=data.get(‘email’), subject=data.get(‘subject’),message=data.get(‘message’)) db.session.add(msg) db.session.commit() user = User(name=‘mrli’) Session = sessionmaker(bind=engine) session = Session() session.add(user) session.commit() 查询 Item.query.filter(Item.table == json_data.get('table')).first() user = session.query(User).filter_by(name='mrli').first() backref 文本输出 def __repr__(self): （与django的__str__不同） sqlalchemy: 查: 1234567891011121314151617181920212223242526272829user = session.query(User).all()user = session.query(User).filter_by(name='mrli').first()# 排序for row in user = session.query(User).order_by(User.id): pass# in_for row in session.query(User).filter(User.name.in_(['nymrli','cl'])): pass&gt;&gt;&gt; &lt;Uid&gt;:1,&lt;name&gt;:mrli&gt;&gt;&gt;&gt; &lt;Uid&gt;:3,&lt;name&gt;:qsy for row in session.query(~User.name.in_(['nymrli','cl'])): print(row) &gt;&gt;&gt;(True,)&gt;&gt;&gt;(False,)&gt;&gt;&gt;(True,)# ~ in for row in session.query(User).filter(~User.name.in_(['nymrli','cl'])): pass#计数user = session.query(User).filter(User.name=='mrli').count()#▲.注意filter()的==与filter_by()的=的使用区别# and_ or_ sqlalchemy core (核心层,更接近SQL语句) 代码很接近、形似SQL原生语句,可以写sqlalchemy的SQL方言(dialect) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import sqlalchemyfrom sqlalchemy import create_enginefrom sqlalchemy import Table,MetaDataprint(sqlalchemy.__version__)engine = create_engine('sqlite:///test.db',echo = True) #将数据库执行的语句打印出来metadata = MetaData()users = Table( 'users',metadata, sqlalchemy.Column('id',sqlalchemy.Integer,primary_key=True), sqlalchemy.Column('name',sqlalchemy.String))addresses = Table( 'addresses' , metadata, sqlalchemy.Column('id', sqlalchemy.Integer, primary_key=True), sqlalchemy.Column('user_id', None,primary_key('users.isd')), sqlalchemy.Column('email_address', sqlalchemy.String, nullable=False))metadata.create_all(engine)users = Table( 'users',metadata, sqlalchemy.Column('id',sqlalchemy.Integer,primary_key=True), sqlalchemy.Column('name',sqlalchemy.String))addresses = Table( 'addresses' , metadata, sqlalchemy.Column('id', sqlalchemy.Integer, primary_key=True), sqlalchemy.Column('user_id', None,primary_key('users.id')), sqlalchemy.Column('email_address', sqlalchemy.String, nullable=False))metadata.create_all(engine)conn = engine.connect()conn.execute(users.insert(),[ dict(name='nymrli'), dict(name='cl')])conn.execute(users.insert(),[ dict(user_id=1,email_address='1063052964@qq.com'), dict(user_id=1,email_address='2042423232@qq.com'), dict(user_id=2, email_address='1063052923@qq.com'), dict(user_id=2, email_address='2042423232@qq.com'),])from sqlalchemy.sql import selects = select([users])result = conn.execute(s)for x in result: print(x)# s = select([users.addresses]).where(users.c.id == addresses.c.user_id)from sqlalchemy.sql import texts = text( \"SELECT user.name || ',' || addresses.email_address AS title \" \"FROM users.addresses \" \"WHERE users.id == addresses.user_id \" \"AND users.name BETWEEN :x AND :y \" \"AND (addresses.email_address LIKE :e1 \" \"OR addresses.email_address LIKE :e2)\")print(conn.execute(s,x='m',y='z',e1=\"%@aoq.com\",e2='@qwe.com').fetchall()) 注意下最后text()里面写的内容&quot;&quot;引号最后要有空格,与下面的语句分割开 无空格的样子: 有空格的样子 SQLalchemy实战 创建库表： 建议通过SQL语法来新建， 而不是用下面的init_db、drop_db， 因为创建表需要设定utf8mb4，而用init_db的字符编码是latin-1，当然这个跟mysql设定也有关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# engine = create_engine(\"mysql+pymysql://root:@127.0.0.1:3306/huaneng?charset=utf8mb4\", max_overflow=5, echo=True)engine = create_engine(\"mysql+pymysql://root:@127.0.0.1:3306/huaneng?charset=utf8mb4\", max_overflow=5)Base = declarative_base()# 创建单表class QuotationInTime(Base): __tablename__ = 'quotation_intime' id = Column(Integer, primary_key=True) # 主键 autoincrement=True 自增 title = Column(String(128)) date = Column(String(16)) content = Column(Text) proclamation_url = Column(String(2083)) def __repr__(self): return \"QuotationInTime&#123;&#125;: &#123;&#125;-&#123;&#125;\".format(self.id, self.title, self.date)# 创建单表class QuotationNotInTime(Base): __tablename__ = 'quotation_notintime' id = Column(Integer, primary_key=True) # 主键 autoincrement=True 自增 title = Column(String(128)) date = Column(String(16)) content = Column(Integer) proclamation_url = Column(String(2083)) def __repr__(self): return \"QuotationInTime&#123;&#125;: &#123;&#125;-&#123;&#125;\".format(self.id, self.title, self.date)# 定义初始化数据库函数def init_db(): Base.metadata.create_all(engine)# 顶固删除数据库函数def drop_db(): Base.metadata.drop_all(engine)# drop_db()# init_db()Session = sessionmaker(bind=engine) # 创建sessionsession = Session() 建库建表对应SQL 123456789101112131415161718192021222324252627282930313233343536373839404142434445SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;CREATE DATABASE if not EXISTS `huaneng` ;use `huaneng`;-- ------------------------------ Table structure for quotation_intime-- ----------------------------DROP TABLE IF EXISTS `quotation_intime`;CREATE TABLE `quotation_intime` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, `date` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, `content` LONGTEXT NULL DEFAULT NULL, `proclamation_url` VARCHAR(1024) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of quotation_intime-- ------------------------------ ------------------------------ Table structure for quotation_notintime-- ----------------------------DROP TABLE IF EXISTS `quotation_notintime`;CREATE TABLE `quotation_notintime` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, `date` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, `content` LONGTEXT NULL DEFAULT NULL, `proclamation_url` VARCHAR(1024) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;SET FOREIGN_KEY_CHECKS = 1; 使用 1234567891011121314151617181920212223242526272829class SqlUtil: @staticmethod def add(table_name, url, **kwargs): \"\"\" TODO: 目前只用了一个sql connection， 可以创建多个连接pool :param table_name: 表明 :param url: 文章链接 :param kwargs: 表参数 :return: \"\"\" table_name = table_name.lower() obj = None if table_name == \"in\": obj = QuotationInTime elif table_name == \"notin\": obj = QuotationNotInTime lock.acquire() is_exist = sql_sess.query(obj).filter_by(proclamation_url=url).count() &gt; 0 if not is_exist: insert_obj = obj(**kwargs) sql_sess.add(insert_obj) sql_sess.commit() log.get_log().info(\"&#123;&#125;插入成功~\".format(insert_obj)) else: log.get_log().info(\"&#123;&#125;已持久化过\".format(url)) lock.release()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://nymrli.top/tags/数据库/"}]},{"title":"Flask系列–将应用部署在Heroku上","slug":"Flask系列–将应用部署在Heroku上","date":"2018-11-21T07:54:01.000Z","updated":"2019-09-15T08:07:30.936Z","comments":true,"path":"2018/11/21/Flask系列–将应用部署在Heroku上/","link":"","permalink":"https://nymrli.top/2018/11/21/Flask系列–将应用部署在Heroku上/","excerpt":"","text":"Flask补充系列–将应用部署在Heroku上 之前曾经介绍过如何将Flask应用部署在自己的服务器上，对于手头并不宽裕的程序员来说，购置一台托管服务器还是一笔不小的开销。即便现在有公有云服务器可以买，不过如果你只是以学习为目的，这笔开销还是能省则省了。另外，如果你的应用中需要访问国外被河蟹掉的资源，在服务器上翻墙也是件麻烦事，所以这里我们补充一篇如何将Flask应用部署在Heroku上。 环境准备 Heroku是一个PaaS服务提供商，使用前，你需要先注册一个Heroku帐号，注册帐号是免费的。 此外你本地必须要有Python 2.7的开发环境，并且装好了Pip, Setuptools, Virtualenv等工具。对于Python开发者来说，这些都是必备的吧。此外Git客户端也是必须的，因为Heroku的代码管理用的是Git。 Heroku提供了一个非常方便的Getting Start教程，每种开发环境都有，我们可以打开Python的Getting Start，然后参照其说明创建一个Python Web应用。懒得看英文的朋友们，可以看我下面写的步骤。 在开始创建应用之前，你还需要安装Heroku的客户端工具，你可以根据你本地的操作系统选择安装包下载。这是一个命令行工具，基于Ruby实现，所以使用起来每个操作系统都一样。安装完成后，你可以打开命令行，输入下面的命令来验证安装是否成功： 1$ heroku --version 如果安装成功，就在本地命令行里登录Heroku，执行命令： 1$ heroku login 并输入你注册号的Heroku帐号及密码即可。 创建应用 网页创建应用 环境准备就绪了，我们开始创建一个应用。浏览器打开Heroku应用控制台，点击右上角的”+”号，并选择”Create new app”。 在创建页面中，输入你的应用名称，比如”flask-bjhee”，如果名称没有被占用，则会跳出绿色提示”flask-bjhee is available”。运行环境默认在美国，也可以选择欧洲。信息填完后，点击下方的”Create App”按钮，应用就创建完成了。 接下来打开命令行，我们要初始化本地及远程代码库： 1234$ mkdir /home/bjhee/flask-bjhee # 创建本地代码工作目录$ cd /home/bjhee/flask-bjhee # 切换到本地代码工作目录$ git init # 创建本地代码库$ heroku git:remote -a flask-bjhee # 连接远程Heroku的flask-bjhee代码库 现在，我们就可以编写应用代码，并提交到Heroku上去了。 命令行创建应用 1234$ heroku create (xxx) #省略会自动默认$ git add .$ git commit -m &quot;yyy&quot;$ heroku git:remote -a flask-bjhee 部署应用 既然主要是在讲部署，那代码逻辑就简单些，Hello World吧。我们写一个Flask Web程序”run.py”，内容如下： 123456789from flask import Flaskapp = Flask(__name__) @app.route(&apos;/&apos;)def index(): return &apos;Hello World!&apos; if __name__ == &apos;__main__&apos;: app.run(host=&apos;0.0.0.0&apos;, debug=True) 然后，我们就写个”requirements.txt”文件，应用部署时Heroku远程环境会自动执行： 1$ pip install -r requirements.txt 来安装应用依赖的库。我们的”requirements.txt”文件如下： 12Flask==0.10.1gunicorn==19.4.5 项目依赖Flask很好理解，为什么还要依赖gunicorn呢？因为我们不能靠Flask自带的Web服务器来运行Flask程序，所以gunicorn是个很好的选择。还记得如何通过Gunicorn运行Flask应用吗？对于上面的代码，我们只需执行”gunicorn run:app”即可。现在我们要告诉Heroku，应该使用这个命令来运行我们的应用。怎么做呢，就是在项目根目录里创建一个”Procfile”文件，然后写上： 1web: gunicorn run:app --log-file - 这就告诉Heroku，启动Web时，要执行”gunicorn run:app –log-file -“。后面的”–log-file -“参数，是为了让日志只打印到标准输出stdout上，因为Heroku不提供我们写本地磁盘的功能。 再接下来，我们要写一个app.json来描述项目信息，”app.json”内容大致如下： 1234567&#123; &quot;name&quot;: &quot;Flask sample on Heroku&quot;, &quot;description&quot;: &quot;An example of deploying Flask web app to Heroku.&quot;, &quot;image&quot;: &quot;heroku/python&quot;, &quot;repository&quot;: &quot;https://git.heroku.com/flask-bjhee&quot;, &quot;keywords&quot;: [&quot;python&quot;, &quot;flask&quot; ]&#125; 另外根据习惯，我们应该写一个”README.md”来给用户看，”.gitignore”描述哪些文件类型不需要提交到代码库中去。好了，现在我们的目录结构如下： 1234567flask-bjhee/ ├ .gitignore ├ app.json ├ Procfile ├ README.md ├ requirements.txt └ run.py 让我们执行git提交命令，来部署到远程Heroku上去吧： 123$ git add .$ git commit -m &quot;Initialize Project&quot;$ git push heroku master # 提交到远程master分支 想看看效果，命令行里输入： 1$ heroku open 就会启动浏览器，并打开地址”https://flask-bjhee.herokuapp.com/”，当然你也可以直接浏览器访问这个地址。有没有看到”Hello World!”？ 本篇的示例代码可以在这里下载。 部分转自: 思诚之道 ▲ 注意部署的时候有两个文件不能少,分别是Procfile和requestments.txt(名字必须完全一样,我就是拼错了一次和少了个s),失败的报错情况如图 完成后是这样的.heorku会自动根据你提供的requestments.txt安装相应的依赖库 配置数据库环境、迁移文件、表 heroku提供了自己的控制台,打开的命令为heroku run bash,之后就可以像在linux的终端下一样操作了 除了这种方法还可以指明使用heroku命令,需要做的是加上前缀heroku run,如heroku run python manage.py db init 官方介绍为:(如图 自定义域名 1$ heroku domains:add apollo.nymrli.top ▲.注意需要认证账户,否则会出现下图结果 待认证好后,还需要用DNS解析,我用的是阿里云的万网解析,将heroku domains:add apollo.nymrli.top后heroku的值用CHAME记录解析.等个几秒后就可以用apollo.nymrli.top访问heroku上面的应用程序了 还有一个做法呢,是直接在heroku相应app的设置里面设置自定义域名,但是由于显示问题,容易复制错,导致无法被解析的问题…如果设置好CHAME解析30秒后还是无法用自定义域名打开的话,看看是不是值复制错了. 所以还是比较建议用命令heroku domains:add xxx来绑定","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"}]},{"title":"二分搜索降低时间复杂度","slug":"二分搜索降低时间复杂度","date":"2018-11-10T13:36:01.000Z","updated":"2019-09-15T08:07:31.022Z","comments":true,"path":"2018/11/10/二分搜索降低时间复杂度/","link":"","permalink":"https://nymrli.top/2018/11/10/二分搜索降低时间复杂度/","excerpt":"","text":"二分搜索降低时间复杂度 123456int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;n;i++) cin &gt;&gt; s[i]; canFit(); return 0;&#125; 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 150using namespace std;int n,m,s[MAXN];int ss[MAXN];bool canFit()&#123; int flag = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) for(int l=0;l&lt;n;l++) if( s[i] + s[j] + s[l] + s[k] == m) flag = true; if(flag) cout &lt;&lt; \"YES\"; else cout &lt;&lt; \"NO\" ;&#125; 时间复杂度为O(n^4),只能在n较小的情况下,若n较大,则TLE… 时间复杂度为O(n^3log2(n))的做法:一层二分搜索 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 150using namespace std;int n,m,s[MAXN];int ss[MAXN];bool binSearch(int k)&#123; int r=n,l=0; while(l &lt;= r)&#123; int i = (r+l)/2; if ( s[i] == k) return true; else if( s[i] &lt; k) l = i+1; else r= i-1; &#125; return false;&#125;bool canFit()&#123; int flag = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if( binSearch(m-s[i] - s[j] - s[k]) flag = true; if(flag) cout &lt;&lt; \"YES\"; else cout &lt;&lt; \"NO\" ;&#125; O(n^2log2(n))做法: 排序O(n^2log2(n)),循环O(n^2log2(n)),总共也是O(n^2log2(n)) 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 150using namespace std;int n,m,s[MAXN];int ss[MAXN];bool binSearch(int k)&#123; int l=0,r=n*n; while(l &lt;= r)&#123; int i = (r+l)/2; if ( s[i] == k) return true; else if( s[i] &lt; k) l = i+1; else r= i-1; &#125; return false;&#125;void enumeration()&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) ss[i*n+j] = s[i] + s[j];&#125;bool canFit()&#123; enumeration(); sort(ss,ss+n*n); //二分搜索的前提是有序 int flag = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if( binSearch(m- s[i] - s[j] )) flag = true; if(flag) cout &lt;&lt; \"YES\"; else cout &lt;&lt; \"NO\" ;&#125; ▲需要注意的是,ss[n*n]的数组需要先排序才能使用二分搜索 ----出自:&lt;&lt;挑战程序设计竞赛&gt;&gt;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"matplotlib.pyplot使用","slug":"matplotlib-pyplot使用","date":"2018-11-10T04:58:51.000Z","updated":"2019-12-11T14:11:12.354Z","comments":true,"path":"2018/11/10/matplotlib-pyplot使用/","link":"","permalink":"https://nymrli.top/2018/11/10/matplotlib-pyplot使用/","excerpt":"","text":"matplotlib.pyplot使用 注释 1234567891011121314151617181920212223242526272829303132333435## 方法一####################for x_value,y_value in zip(x,y): plt.text(x_value,y_value,y_value,fontsize= 15) #文字标注(x,y,值)###################### 方法二####################for xy in zip(x, y): plt.annotate(\"(%s,%s)\" % xy, xy=xy, xytext=(-20, 10), textcoords='offset points') x0 = 1y0 = 2* x0plt.annotate(r'$&#123;&#125;+&#123;&#125;=&#123;&#125;$'.format(x0,x0,y0),xy=(x0,y0),xycoords='data',xytext=(+30,-30),textcoords = 'offset points', fontsize=16,arrowprops=dict( arrowstyle='-&gt;', connectionstyle='arc3,rad=.2' ))##################### 添加注释(annotate),参数说明plt.annotate(r'$2x+1=&#123;&#125;$'.format(y),xy=(x,y),xycoords='data',xytext=(+30,-30),textcoords = 'offset points',fontsize=16, arrowprops=dict( arrowstyle='-&gt;', connectionstyle='arc3,rad=.2') )# 第一个参数是注释的内容# xy设置箭头尖的坐标# xytext设置注释内容显示的起始位置# arrowprops 用来设置箭头# facecolor 设置箭头的颜色# headlength 箭头的头的长度# headwidth 箭头的宽度# width 箭身的宽度 坐标轴转移 1234567ax = plt.gca()ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)ax.xaxis.set_ticks_position(&apos;bottom&apos;)ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;,0))ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;left&apos;].set_position((&apos;data&apos;,0)) 图形类型 散列图 ax1.scatter(x,y,c = 'r',marker = 'o') 折线图plt.plot() 直方图plt.hist() 条形图plt.bar(left=index,height=y,color='green',width=0.5) 饼状图:plt.pie(x=fracs,labels=labels,autopct='%.0f%%',explode=explode)#autopct显示百分比 箱形图plt.boxplot(data,labels=labels) 等高线 plt.contourf(X,Y,f(X,Y),8,alpha = .75,cmap = plt.cm.hot) scatter基本的用法 条形图 123456789fig = plt.figure(dpi=256, figsize=(10, 8))plt.plot(U,I,&apos;r*&apos;)plt.xlabel(&apos;U(V)&apos;,fontsize=10)plt.ylabel(&apos;I(10e-9A)&apos;,fontsize=10)plt.title(&apos;The line chart of the relation between U and I&apos;,fontsize=15)plt.ylim(0,max(I)+0.5)x = np.linspace(0,max(I)+0.5,40)plt.yticks(x,fontsize=6) 线条选项 12plt.plot(x,y,&apos;r*&apos;) # 默认为蓝色# 等价于plt.plot(x,y,color= &apos;r&apos;, marker =&apos;*&apos;) 散点图 12345678n =100X = np.random.normal(0,10,n)Y = np.random.normal(0,10,n)T = np.arctan2(Y,X)plt.scatter(X,Y,c= T,s=6)plt.xticks(())plt.yticks(())plt.show() 柱状图 1234567891011121314n=12X=np.arange(n)Y1=(1-X/float(n))*np.random.uniform(0.5,1.0,n)Y2=(1-X/float(n))*np.random.uniform(0.5,1.0,n)plt.bar(X,+Y1,facecolor='#9999ff',edgecolor='white')plt.bar(X,-Y2,facecolor='#ff9999',edgecolor='white')for x,y in zip(X,Y1): plt.text(x+0,y+0.05,\"%.2f\" %y,ha='center',va='bottom') # horizontal alignment , vertical alignmentplt.xlim(-.5,n)plt.xticks(())plt.ylim(-1.25,1.25)plt.yticks(())plt.show() 等高线 123456789101112def f(x,y): # return 1 + 1/x**3 + y**5 return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)n = 256x = np.linspace(-3,3,n)y = np.linspace(-3,3,n)X,Y = np.meshgrid(x,y)plt.contourf(X,Y,f(X,Y),8,alpha = .75 , cmap = plt.cm.hot)C = plt.contour(X,Y,f(X,Y),8,colors = &apos;black&apos;)plt.clabel(C,inline = True,fontsize = 10) 图例 123l1 , = plt.plot(x,y,linestyle= '--',color = 'red',linewidth=2.0)# 返回值为一个元组plt.legend(handles=[l1],labels = ['les'],loc='best') 3D图形 1234567891011121314from matplotlib import pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)x = np.linspace(-4,4,50)y = np.linspace(-4,4,50)X,Y = np.meshgrid(x,y)R = np.sqrt(X**2 + Y**2)Z = np.sin(R)ax.plot_surface(X,Y,Z,rstride=1,cstride=1,cmap = plt.get_cmap('rainbow'))ax.contour(X,Y,Z,zdir='x',offset = -5)#画等高线图,往哪个(x)轴压缩,到x=-5位置plt.show() 分格画子图 123456789101112131415161718192021# method 1: subplot2grid##########################plt.figure()axl=plt. subplot2grid((3,3),(0,0), colspan=3, rowspan=1)# 三行三列, 从源点(0,0)开始画,第一张图占一行三列axl.plot([1,2],[1,2])ax1.set_title('xxx')# 原来plt.title()设置的方法,现在都变成了ax?.set_xxx,多了前缀set_ax2=plt. subplot2grid((3,3),(1,0), colspan=2,)ax3=plt. subplot2grid((3,3),(1,2), rowspan=2)ax4=plt. subplot2grid((3,3),(2,0) #method 2 :gridspec import matplotlib.gridspec as gridspeccplt.figure()gs=gridspec.GridSpec(3,3)ax1=plt.subplot(gs[0, :])ax2=plt.subplot(gs[1, :2])ax3=plt.subplot(gs[1: ,2])ax4=plt.subplot(gs[-1,0])ax5=plt.subplot(gs[-1,-2]) 附录: 温习源自WeiboSpider 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Cgraph(object): def __init__(self): self.db = db self.create_dir() self.Start_timestmp = time.mktime(time.strptime('2018-7-5 00:00','%Y-%m-%d %H:%M')) def judge_over(self, _time): # start_time is timestamp ''' 判断时间是否已经超过预设时间 :param Start_timestmp: :param _time: :return: ''' timestamp = time.mktime(time.strptime(_time, '%Y-%m-%d %H:%M')) # Start_timestamp = time.mktime(time.strptime(Start_time,'%Y-%m-%d %H:%M')) if timestamp - self.Start_timestmp &lt; 0: return True else: return False def create_dir(self): if not os.path.isdir('.\\\\graph'): os.makedirs('.\\\\graph') def count(self,lists): exist_dict = OrderedDict() for x in lists: if x not in exist_dict: exist_dict[x] = 1 else: exist_dict[x] += 1 return dict(sorted(exist_dict.items(),key=lambda x:x[0])) def unify_time(self,_time): c = _time.split('-') _time = '-'.join(['0' + x if len(x.strip()) == 1 else x for x in c]) if _time[:4] == '2018': _time = _time[5:10] return _time[:10] def Draw(self): timelist = [] for alls in self.db.find(): if alls.get('time'): print(alls.get('time')) timelist.append(self.unify_time(alls.get('time'))) infodict = self.count(timelist[::-1]) plt.figure(figsize=(40, 18)) #设置图片大小 # plt.rcParams['figure.figsize'] = (40.0, 12.0) 设置图片大小的另外一种方法 # plt.rcParams['figure.dpi'] = 400 x = list(infodict.keys()) y = list(infodict.values()) plt.plot(x,y,linewidth=2,color='r',marker='o',markersize=8) for x_value,y_value in zip(x,y): plt.text(x_value,y_value,y_value,fontsize= 15) #文字标注(x,y,值) plt.ylim((0, max(y))) #纵坐标y的上下限 plt.yticks([x for x in range(0,max(y)+10,10)]) #y的比例尺 plt.xlabel('Time') plt.ylabel('Keyword times') #y轴的标签 plt.title('Weibo Keyword\\'s Trendency') #图的标题 plt.savefig('.\\\\graph\\\\&#123;&#125;.jpg'.format(TABLE)) #保存图片 plt.clf()if __name__ == '__main__': graph = Cgraph() graph.Draw() print('完成') 使用:大物实验画折线图 12345678910111213141516171819202122232425262728293031323334import csvfrom matplotlib import pyplot as pltimport osimport numpy as npI = []U = []def extractFromCsv(filename): with open(filename,'r') as f: reader = csv.reader(f) for row in reader: if reader.line_num == 1: #跳过表头 continue U.append(float(row[0])) I.append((float(row[1])))def drawPic(filename): fig = plt.figure(dpi=256, figsize=(10, 8)) plt.plot(U,I,'r*') plt.xlabel('U(V)',fontsize=10) plt.ylabel('I(10e-9A)',fontsize=10) plt.title('The line chart of the relation between U and I',fontsize=15) plt.ylim(0,max(I)+0.5) x = np.linspace(0,max(I)+0.5,40) plt.yticks(x,fontsize=6) if not os.path.exists(\".\\\\graph\"): os.mkdir('.\\\\graph') plt.savefig('.\\\\graph\\\\&#123;&#125;.jpg'.format(filename))if __name__ == \"__main__\": filename='phy.csv' extractFromCsv(filename) drawPic(filename) 参考: matplotlib 画图颜色参数值及对应色卡 matplotlib绘图总结——对画图句柄的操作 matplotlib中plt.scatter()参数详解——很详细","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"apt代理的设置","slug":"apt代理的设置","date":"2018-11-10T04:56:53.000Z","updated":"2019-09-15T08:07:30.919Z","comments":true,"path":"2018/11/10/apt代理的设置/","link":"","permalink":"https://nymrli.top/2018/11/10/apt代理的设置/","excerpt":"","text":"原因是在apt-get update时遇到了Unable to connect to 代理，（由于apt-get update一直显示无法连接172.17.18.141百度后发现并不是个特殊的IP,）于是想到是否使用了代理。 apt代理的设置： 临时方法 export http_proxy=http://10.3.0.1:80 长久方法 (1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。) Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;; 保存apt.conf文件。 (2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件) 建立文件 vim proxyfile Acquire::http::proxy &quot;http://10.3.0.1:80&quot;; Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;; Acquire::https::proxy &quot;http://10.3.0.1:80&quot;; 使用时sudo apt-get install xxx -c proxyfile (2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 ) 在您的.bashrc文件末尾添加如下内容 export http_proxy=http://用户名:密码@地址:端口/ export https_proxy=http://用户名:密码@地址:端口/ export ftp_proxy=http://用户名:密码@地址:端口/ https://blog.csdn.net/qq3399013670/article/details/81300497","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://nymrli.top/tags/Ubuntu/"}]},{"title":"Ubuntu更改nginx默认端口","slug":"Ubuntu更改nginx默认端口","date":"2018-11-10T04:55:13.000Z","updated":"2019-09-15T08:07:31.011Z","comments":true,"path":"2018/11/10/Ubuntu更改nginx默认端口/","link":"","permalink":"https://nymrli.top/2018/11/10/Ubuntu更改nginx默认端口/","excerpt":"","text":"Ubuntu更改nginx默认端口 nginx 默认使用80端口，有时候我们希望nginx运行在其他端口，就需要更改nginx配置 nginx配置文件在/etc/nginx目录下的nginx.conf。(可以修改处理器数量、日志路径、pid文件路径等，默认的日志。) 错误日志 /var/log/nginx/error.log 访问日志 /var/log/nginx/access.log 在nginx.conf-&gt;http选项末尾有引入两个目录下的文件分别为： 123456[/etc/nginx/nginx.conf]http &#123; # 省略部分内容 include /etc/nginx/conf.d/*.conf; #意思是把用户自己的配置放到conf.d/* include /etc/nginx/sites-enabled/*;&#125; 查看/etc/nginx/sites-enabled/目录，会找到一个default文件，在server选项下前两行就可以找到使用的80端口号： 1234[/etc/nginx/sites-enabled/default]server &#123; listen 80 default_server; listen [::]:80 default_server; 将80端口号改为想使用的端口号，保存文件，如果没有启动nginx，启动即可。如果nginx已经在运行，重新加载即可。 12sudo nginx start #运行nginxsudo nginx -s reload #重启nginx **如果遇到nginx报以下错误：nginx: [error] open() &quot;/run/nginx.pid&quot; failed (2: No such file or directory)则sudo nginx -c path/*.conf #指定nginx配置*.conf的位置** **查看nginx运行的端口sudo netstat -anp | grep nginx** ▲如果启用防火墙，则需开启对应端口，使用AWS服务器需要更改服务器安全组，添加响应入站规则，开启对应端口。","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://nymrli.top/tags/Ubuntu/"}]},{"title":"Pythonanywhere解决链接Mysql问题(部署flask)","slug":"Pythonanywhere解决链接Mysql问题-部署flask","date":"2018-11-10T04:54:14.000Z","updated":"2019-09-15T08:07:30.978Z","comments":true,"path":"2018/11/10/Pythonanywhere解决链接Mysql问题-部署flask/","link":"","permalink":"https://nymrli.top/2018/11/10/Pythonanywhere解决链接Mysql问题-部署flask/","excerpt":"","text":"Pythonanywhere解决链接Mysql问题(部署flask) 由于在bash控制台里通过命令mysql -p(这其实是因为错误的连接方式,由于不是默认的端口3306,自然连接不到,官方文档中有正确的连接方式)链接不到Mysql时,再加上进虚拟环境用python manage db migrate也失败后,我是异常慌张的…然后立马发现关于pythonanywhere链接Mysql的解决不是很多,要么就是说免费账号是无法用的…心顿时拔凉,但最后还是找到了pythonanywhere官方的文档,解决了这个问题,发现都是配置的问题 一开始的我本地及阿里云链接mysql数据库配置文件是这样写的: 1234567891011121314#[config.py]DIALECT = 'mysql'DRIVER = 'pymysql'USERNAME = 'root'PASSWORD = 'zxcqwe' #瞎写的HOST = '127.0.0.1'PORT = '3306'DATABASE = 'restaurant'DEBUG = TrueSQLALCHEMY_DATABASE_URI = \"&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8\".format( DIALECT,DRIVER,USERNAME,PASSWORD,HOST,PORT,DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False 后来根据说明改成了如下: 123456789101112#[config.py]DIALECT = 'mysql'DRIVER = 'pymysql'USERNAME = 'nymrli'PASSWORD = 'zxcqwe' #瞎写的HOST = 'nymrli.mysql.pythonanywhere-services.com'PORT = '3306'DATABASE = 'nymrli$restaurant'DEBUG = TrueSQLALCHEMY_DATABASE_URI = \"&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8\".format( DIALECT, DRIVER, USERNAME, PASSWORD, HOST, PORT, DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False 其中修改的地方为 USERNAME为pythonanywhere账号 PASSWORD为Database详情页设置的数据库密码 HOST为Database详情页上的Database host address DATABASE为Database详情页上 create a database的数据库名,但pythonanywhere会自动给你加上前缀&lt;username&gt;$&lt;database_name&gt;,所以我这边就是nymrli$restaurant PORT默认还是3306 附上官方文档: 配置说明: 开始使用MySQL,您需要去在仪表板的MySQL选项卡,并设置一个密码。你也会找到连接设置选项卡(主机名、用户名),以及创建新的数据库的能力。 你可以开始一个新的MySQL控制台访问数据库从这个选项卡,或者您可以打开一个MySQL从bash shell使用以下命令控制台或ssh会话: mysql -u USERNAME -h HOSTNAME -p 'USERNAME$DATABASENAME' [Using MySQL](https://help.pythonanywhere.com/pages/UsingMySQL/) 通过SSH链接,据说免费账户不支持: 12345678910Setting ValueSSH Hostname: ssh.pythonanywhere.comSSH Username: your PythonAnywhere usernameSSH Password: the password you use to log in to the PythonAnywhere websiteSSH Key file: should not be necessary when you specify the passwordMySQL Hostname: your PythonAnywhere database hostname, eg. yourusername.mysql.pythonanywhere-services.comMySQL Server Port: 3306Username: your PythonAnywhere usernamePassword: your PythonAnywhere database passwordDefault Schema: your database name, eg yourusername$mydatabase Accessing your MySQL database from outside PythonAnywhere","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"MySQL","slug":"MySQL","permalink":"https://nymrli.top/tags/MySQL/"}]},{"title":"写爬虫过程中碰到的编码问题","slug":"写爬虫过程中碰到的编码问题","date":"2018-11-08T04:23:19.000Z","updated":"2019-09-15T08:07:31.030Z","comments":true,"path":"2018/11/08/写爬虫过程中碰到的编码问题/","link":"","permalink":"https://nymrli.top/2018/11/08/写爬虫过程中碰到的编码问题/","excerpt":"","text":"写爬虫过程中碰到的编码问题 遇到 ’ \\uxxxx ’ 的16进制字符串编解码问题，使用unicode-escape解决之。 实际上，在将unicode存储到文本的过程中，还有一种存储方式，不需要将unicode转换为实际的文本存储字符集，而是将unicode的内存编码值进行存储，读取文件的时候再反向转换回来，是采用：unicode-escape的转换方式。 将unicode的内存编码值进行存储，读取文件时在反向转换回来。这里就采用了unicode-escape的方式 12345678print(u&apos;中文测试&apos;.encode(&apos;utf-8&apos;))print(&apos;中文测试&apos;.encode(&apos;utf-8&apos;))print(u&apos;中文测试&apos;.encode(&apos;unicode-escape&apos;))print(&apos;中文测试&apos;.encode(&apos;unicode-escape&apos;))==&gt; b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe6\\xb5\\x8b\\xe8\\xaf\\x95&apos;==&gt; b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe6\\xb5\\x8b\\xe8\\xaf\\x95&apos;==&gt; b&apos;\\\\u4e2d\\\\u6587\\\\u6d4b\\\\u8bd5&apos;==&gt; b&apos;\\\\u4e2d\\\\u6587\\\\u6d4b\\\\u8bd5&apos; ASCII码只有128个字符，符合英文，一个英文字符只用1个字节(最高位恒为0) ANSI：面向中文编码的GBK、GB2312是ANSI码的一种，ANSI码是对ASCII的拓展，所以一个英文只用一个字节，而中文需要拓展ASCII，所以用到两个字节。 0x80~0xFFFF =&gt;2**16 Unicode编码:为了解决不同国家ANSI编码的冲突问题，最常用的是用两个字节表示一个字符 。但是这样的话，原本可以用一个字节存储的英文字母在Unicode里面必须存两个字节，这就产生了浪费。那么有没有一种既能消除乱码，又能避免浪费的编码方式呢？===&gt;答案就是UTF-8 。000000 -10FFFF 12&gt; UNICODE 的范围是 0x0000 - 0xFFFF 共6万多个字符，其中光汉字就占用了4万多个&gt; UTF-8编码：当字符在ASCII码的范围时，就用一个字节表示 ，所以英文字符也只用一个字节，▲值得注意的是unicode编码中一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。utf-8长度是1-6个字节 （可变的） Unicode编码(十六进制) UTF-8 字节流(二进制) 000000-00007F 0xxxxxxx 000080-0007FF 110xxxxx 10xxxxxx 000800-00FFFF 1110xxxx 10xxxxxx 10xxxxxx 010000-10FFFF 11110xxx 10xxxxxx 10xxxxxx10xxxxxx 超出10FFFF后，UTF-8与Unicode不再对应 总结： UTF-8 vs GBK： UTF-8版本虽然具有良好的国际兼容性，但中文需要比GBK/BIG5版本多占用50%的数据库存储空间，因此并非推荐使用，仅供对国际兼容性有特殊要求的用户使用。简单地说：对于中文较多的网站，适宜用GBK编码节省数据库空间。对于英文较多的网站，适宜用UTF-8节省数据库空间。 字符编码ANSI和ASCII区别、Unicode和UTF-8区别 Python中编码问题 在python中，unicode是内存编码集，一般我们将数据存储到文件时，需要将数据先编码为其他编码集，比如utf-8、gbk等。 读取数据的时候再通过同样的编码集进行解码即可。 但是其实还有一种unicode-escape编码集，他是将unicode内存编码值直接存储： 在使用python3的requests模块时，发现获取响应有两种方式 其一，为文本响应内容, r.text是Unicode的响应内容 其二，为二进制响应内容，r.content是二进制的响应内容 Python2 的编码问题一直非常让人恼火，不过你的问题稍微简单一些。 在交互式命令模式(Interactive shell)下，可以这样来明白你遇到的问题的根源： 1234567import sys sys.stdout.encoding 在 Windows 下，如果你的系统是简体中文，一般输出会是 cp936 import codecs codecs.lookup(&apos;cp936&apos;).name &apos;gbk&apos; 这就是在 Windows 终端里面使用的编码。在 print 的时候，无论字符串源采取什么样的编码，最终输出的字符串的编码必须跟 shell 的编码一致，也就是说: print some_string Python 会做这样一个动作： codecs.encode(some_string, coding, errors=‘strict’) 在你遇到的情况下，some_string 是一个 unicode 字符串，coding 是 gbk。由于你的 unicode 字符串里面包含 gbk 字符集里面没有的字符，Python 就会抛出一个 UnicodeEncodeError. 对于输出到文件中情况是类似的，Python2 的 open() 函数不会传入 encoding，以 ‘w’ 方式打开文件，如果写入 unicode 字符串，Python 会获取当前默认的编码，然后以此种编码把字符串写入文件。可惜的是，“默认编码”只是 Python 自己默认的，在 Objects/unicodeobject.c 中，用一个全局变量 unicode_default_encoding 来表示默认的编码： /* Default encoding to use and assume when NULL is passed as encoding parameter; it is initialized by _PyUnicode_Init(). ​ Always use the PyUnicode_SetDefaultEncoding() and ​ PyUnicode_GetDefaultEncoding() APIs to access this global. static char unicode_default_encoding[100 + 1] = &quot;ascii&quot;; 这个值在 Python 中有C接口（PyUnicode_SetDefaultEncoding）去改变，但可惜的是没有 Python 层的接口。 所以在调用到类似 file.write(some_string) 的时候，首先会有这样的编码过程: codecs.encode(some_string, coding, errors=‘restrict’) 当你的 some_string 是一个 unicode 字符串，并且包含 ascii 字符串不存在的字符时，就会抛出一个 UnicodeEncodeError。 所以，为了解决这个问题，可以这么处理： (1) 在 Windows shell 下面: &gt;&gt;&gt; print some_string.encode(‘gbk’, errors=‘ignore’) # replace 也可，只要不是 restrict (2) 在写入文件时，两种方法： a. 忽略不存在的字符，同(1) &gt;&gt;&gt; f = open(filename, ‘w’) &gt;&gt;&gt; f.write(some_string.encode(‘gbk’, errors=‘ignore’) b. byte 方式写入： &gt;&gt;&gt; f = open(filename, ‘wb’) &gt;&gt;&gt; f.write(some_string.encode(‘utf-8’)) ​ a 会损失字符，b 不会。 来自http://www.newsmth.net/nForum/#!article/Python/124657 如果CMD命令行是gbk编码的，则输出的utf-8字符有些也显示不了 Win10 临时修改cmd命令行窗口UTF-8编码 只作用于当前打开的窗口 进入cmd窗口后，直接执行“chcp 65001”，执行完后，cmd的编码格式就是UTF-8 永远修改 Windows 控制台使用注册表永久修改编码问题 方法一： 1.在cmd中输入regedit进入注册表 2.找到HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe 3.新建一个 DWORD（32位值）,命名为CodePage，值设为65001 4.已有CodePage的话，修改它，改为十进制，65001 方法二：(亲测有效) 1.新建一个cmd.reg注册表文件: 2.内容输入如下： 123456789Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe]&quot;CodePage&quot;=dword:0000fde9&quot;FontFamily&quot;=dword:00000036&quot;FontWeight&quot;=dword:00000190&quot;FaceName&quot;=&quot;Consolas&quot;&quot;ScreenBufferSize&quot;=dword:232900d2&quot;WindowSize&quot;=dword:002b00d2 3.双击运行","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Shell脚本基础","slug":"Shell脚本基础","date":"2018-11-08T04:19:49.000Z","updated":"2020-09-04T07:48:47.590Z","comments":true,"path":"2018/11/08/Shell脚本基础/","link":"","permalink":"https://nymrli.top/2018/11/08/Shell脚本基础/","excerpt":"","text":"Shell 编写 打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。 12#!/bin/bash#!/usr/bin/php “#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。 作为可执行程序 12chmod +x test.sh./test.sh 注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。 变量 定义变量 12your_name=&quot;qinjx&quot;▲.变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。 使用变量 使用一个定义过的变量，只要在变量名前面加美元符号即可，如： 123your_name=&quot;qinjx&quot;echo $your_nameecho $&#123;your_name&#125; 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： 123for skill in Ada Coffe Action Java; do echo &quot;I am good at $&#123;skill&#125;Script&quot;done 字符串 字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了，哈哈），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。 单引号 1str=&apos;this is a string&apos; 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行） 双引号 12your_name=&apos;qinjx&apos;str=&quot;Hello, I know your are \\&quot;$your_name\\&quot;! \\n&quot; 双引号里可以有变量 双引号里可以出现转义字符 字符串操作 拼接字符串 12345your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;echo $greeting $greeting_1 获取字符串长度： 12string=\"abcd\"echo $&#123;#string&#125; #输出：4 提取子字符串 12string=&quot;alibaba is a great company&quot;echo $&#123;string:1:4&#125; #输出：liba 查找子字符串 12string=&quot;alibaba is a great company&quot;echo `expr index &quot;$string&quot; is`#输出：3，这个语句的意思是：找出字母i在这名话中的位置，要在linux下运行，mac下会报错 流程控制 和Java、PHP等语言不一样，sh的流程控制不可为空，如： 1234567&lt;?phpif (isset($_GET[&quot;q&quot;])) &#123; search(q);&#125;else &#123; //do nothing&#125; 在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。 还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下： 12ll /usr/bin/[-rwxr-xr-x. 1 root root 33408 6月 22 2012 /usr/bin/[ 正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0] if else if 1234567if conditionthen command1 command2 ... commandN fi 写成一行（适用于终端命令提示符）： 1if `ps -ef | grep ssh`; then echo hello; fi 末尾的fi就是if倒过来拼写，后面还会遇到类似的 if else 123456789if conditionthen command1 command2 ... commandNelse commandfi if else-if else 12345678if condition1then command1elif condition2 command2else commandNfi for while for 在开篇的示例里演示过了： 1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 写成一行： 1for var in item1 item2 ... itemN; do command1; command2… done; C风格的for 123456for (( EXP1; EXP2; EXP3 ))do command1 command2 command3done while 1234while conditiondo commanddone 无限循环 1234while :do commanddone 或者 1234while truedo commanddone 或者 1for (( ; ; )) until 1234until conditiondo commanddone case 123456789101112131415161718192021222324252627case &quot;$&#123;opt&#125;&quot; in &quot;Install-Puppet-Server&quot; ) install_master $1 exit ;; &quot;Install-Puppet-Client&quot; ) install_client $1 exit ;; &quot;Config-Puppet-Server&quot; ) config_puppet_master exit ;; &quot;Config-Puppet-Client&quot; ) config_puppet_client exit ;; &quot;Exit&quot; ) exit ;; * ) echo &quot;Bad option, please choose again&quot;esac case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break 学习自：Shell脚本编程30分钟入门","categories":[],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://nymrli.top/tags/Shell/"},{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"多媒体Au使用","slug":"多媒体Au使用","date":"2018-11-08T04:18:47.000Z","updated":"2019-09-15T08:07:31.044Z","comments":true,"path":"2018/11/08/多媒体Au使用/","link":"","permalink":"https://nymrli.top/2018/11/08/多媒体Au使用/","excerpt":"","text":"AU使用。 留人声、去伴奏 First. ▲侧边声道电平控制微弱，中置声道电平控制效果强。 ▲交叉渗透，越大伴奏声音越不明显 Second. 前面几排调低到满意。（童声高音频率范围为260-880Hz,低音频率范围为196-700Hz,女声高音频率范围为220-1.1KHz,低音频率范围为200-700KHz,男声高音频率范围为160-523KHz低音频率范围为80-358Hz. 国际通信标准制定为300Hz-3400Hz! ） 留伴奏、去人声 ···选中所有，菜单栏-收藏夹-移除人声","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"Au","slug":"Au","permalink":"https://nymrli.top/tags/Au/"},{"name":"多媒体","slug":"多媒体","permalink":"https://nymrli.top/tags/多媒体/"}]},{"title":"定时执行Python脚本","slug":"定时执行Python脚本","date":"2018-11-07T09:51:16.000Z","updated":"2020-03-29T14:22:33.660Z","comments":true,"path":"2018/11/07/定时执行Python脚本/","link":"","permalink":"https://nymrli.top/2018/11/07/定时执行Python脚本/","excerpt":"","text":"定时任务执行python脚本 使用linux的crontab 1.开启crontab日志。 crontab默认不开启日志，所以先开启定时任务的日志来查看 修改rsyslog服务，将/etc/rsyslog.d/50-default.conf 文件中的#cron.*前的 #删掉；用service rsyslog restart重启rsyslog服务： 2.写定时任务 开启本用户的定时任务,即创建以本用户名为文件名的定时任务文件，位置在/var/spool/cron/crontabs/。crontab -e 定时任务语句格式为：执行周期+命令，周期有5个域，分别是 M: 分（0-59） H：时（0-23） D：天（1-31） m: 月（1-12） d: 周（0-6） //0为星期日 ▲每个域不加限制任意的话用* 所以命令语句就是 12*/5 * * * * cd /home/iris/; python aa.py#时间# #command ; commond 写完后需要重启cron服务:service cron restart 如果定时运行的脚本需要root权限，那么可以直接把任务写在root用户的cron中 1sudo crontab -u root -e 或者切换到root用户下再进行设置cron 12345678# 可以以root身份执行crontab，sudo默认是需要输入密码。下面是运用这个方法的具体操作方法，命令执行顺序如下：# 切换到root用户下su - # 执行如下命令进入到root用户crontab配置中crontab -e# 最后，加入你的任务0 * * * * clear_img.sh &gt;&gt;clear_img.log ▲最后写完后需要重启cron服务:service cron restart 附录 常用周期格式: 每五分钟执行 */5 * * * * 每小时执行 0 * * * * 每天执行 0 0 * * * 每周执行 0 0 * * 0 每月执行 0 0 1 * * 每年执行 0 0 1 1 * 5 * * * * ls 指定每小时的第5分钟执行一次ls命令 30 5 * * * ls 指定每天的 5:30 执行ls命令 30 7 8 * * ls 指定每月8号的7：30分执行ls命令 30 5 8 6 * ls 指定每年的6月8日5：30执行ls命令 30 5 8 6 * ls 指定每年的6月8日5：30执行ls命令 30 6 * * 0 ls 指定每星期日的6:30执行ls命令 30 3 10,20 * * ls 每月10号及20号的3：30执行ls命令 25 8-11 * * * ls 每天8-11点的第25分钟执行ls命令 */15 * * * * ls 每15分钟执行一次ls命令 30 6 */10 * * ls 每个月中，每隔10天6:30执行一次ls命令 22 4 * * * root run-parts /etc/cron.daily每天4：22以root身份执行/etc/cron.daily目录中的所有可执行文件，run-parts参数表示，执行后面目录中的所有可执行文件。 ~/Python_project/SeverChan_Nyedu 使用python crontab设置linux定时任务 通过python 来写 crontab配置 123456789101112131415161718192021222324252627282930313233from crontab import CronTab# 创建当前用户的crontab，当然也可以创建其他用户的，但得有足够权限my_user_cron = CronTab(user=True)# 创建任务job = my_user_cron.new(command='echo date &gt;&gt; ~/time.log')# 设置任务执行周期，每两分钟执行一次job.setall('*/2 * * * *')# 当然还支持其他更人性化的设置方式，简单列举一些job.minute.during(5,50).every(5)job.hour.every(4)job.day.on(4, 5, 6)job.dow.on('SUN')job.dow.on('SUN', 'FRI')job.month.during('APR', 'NOV')job.setall(time(10, 2))job.setall(date(2000, 4, 2))job.setall(datetime(2000, 4, 2, 10, 2))# 同时可以给任务设置comment，这样就可以根据comment查询，很方便job.set_comment(\"time log job\")# 根据comment查询，当时返回值是一个生成器对象，不能直接根据返回值判断任务是否#存在，如果只是判断任务是否存在，可直接遍历my_user_cron.cronsiter = my_user_cron.find_comment('time log job')# 同时还支持根据command和执行周期查找，基本类似，不再列举# 任务的disable和enable， 默认enablejob.enable(False)job.enable()# 最后将crontab写入配置文件my_user_cron.write() python中的轻量级定时任务调度库：schedule 提供博客python中的轻量级定时任务调度库：schedule","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"ServerChan+南邮教务处","slug":"ServerChan-南邮教务处","date":"2018-11-07T09:32:10.000Z","updated":"2019-09-15T08:07:31.000Z","comments":true,"path":"2018/11/07/ServerChan-南邮教务处/","link":"","permalink":"https://nymrli.top/2018/11/07/ServerChan-南邮教务处/","excerpt":"","text":"SeverChan_Nyedu Crawl the infomation about competitons, when new infos comes, remind people on Wechat by ServerChan: 😍该程序通过爬取南邮教务处,将当前时间与最新时间进行匹配,如果是当日则通过ServerChan发送到本人的微信,提醒有新的竞赛. 完成笔记: 1.关于lxml中etree.xpath()对于tbody的处理 该网页通过table对页面进行分布设置,其中table标签会自动生成tbody标签,如图…此时用xpath进行匹配的时候就不需要将tbody加上,否则匹配不到 布局&lt;Table&gt; 表格&lt;table&gt; 可以看到的是在Chrome调试助手里面,&lt;table&gt;下面都是会自动生成&lt;tbody&gt;标签的(一般tbody是浏览器自动产生的，一般情况要去掉),而我们再通过网页源码看看…==&gt;可以发现的是: &lt;table&gt;布局是没有&lt;tbody&gt;的,只有表格才有,所以这也是为什么用xpath()表格里必须加上tbody才能匹配,而table布局中不能加tbody的原因 123456789101112#布局获得内容for content in contentList: title = content.xpath('td/table/tr/td[1]/a/text()')[0] href = content.xpath('td/table/tr/td[1]/a/@href')[0] submittime = content.xpath('td/table/tr/td[2]/div/text()')[0]#表格if content.tag == 'table': tabletitle = content.xpath('tbody/tr[1]/td') # 表格头 tabletitleList = map(lambda x: x.xpath('string(.)'), tabletitle) tablehead = '|' + '|'.join(tabletitleList) + '|' tableover = '|' + ':---:|' * len(tabletitle) # 居中显示 2.requests.get()获得的response的编码问题 123html = requests.get('http://jwc.njupt.edu.cn/1594/list.htm',headers = headers)html.encoding = 'utf-8'#Requests库的自身编码为: r.encoding = ‘ISO-8859-1’ Github地址:Freedomisgood/SeverChan_Nyedu","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"高科GSWIFI江苏破解教程","slug":"高科GSWIFI江苏破解教程","date":"2018-11-04T02:06:34.000Z","updated":"2019-09-15T08:07:31.102Z","comments":true,"path":"2018/11/04/高科GSWIFI江苏破解教程/","link":"","permalink":"https://nymrli.top/2018/11/04/高科GSWIFI江苏破解教程/","excerpt":"","text":"1.重置路由器设置 为了以防之前其他人已经设置过某些东西,可能会影响到之后的使用，所以干脆直接重置。 2.连接路由器电源,不用插任何的wan口或者lan口 P.S.如果第二步,手机和电脑无法直接通过IP地址进入管理界面的话,可以考虑将 网线一头插入2号口,一头插入电脑的插口 , 然后再通过IP地址进入管理界面 3.登录路由器管理界面 ▲注意： 大多数路由器的管理界面IP地址为 192.168.1.1或者192.168.100.1,虽然高科路由器后面贴纸上说明的IP地址是192.168.8.1,但是那个不是初始的IP,需要自己设置到192.168.8.1. 如下是我已经修改好的IP为192.168.8.1的登录界面,默认密码为admin,登录后选择不保存密码 4.进入管理界面后先观察 首先是要观察软件版本与 GSWIFI 公众号中的最新能用的版本进行匹配,如果是一样的话就不需要升级系统固件,如果当前软件版本比较低就可能无法使用. 其次,由于没接网线,所以网线状态是WAN口未连接 5.修改配置 修改WAN口设置 如何查看手机MAC地址说明: 由于我使用的是英文系统…可能手机界面有点不同 1**.进入WLAN** 2.进入更多设置 最下面的MAC address就是 6.WIFI设置2.4G 7.LAN口设置 该步之后,等30s配置完成后,你会无法进入192.168.1.1,页面也会无响应,此时访问192.168.8.1重进管理界面 8.开始连接网线(查看网线状态) ▲▲.由于该路由器的WAN口被商家调到了3号LAN口,我也被这步坑了挺久…所以上述步骤都完成以后,将网线插入路由器的3号LAN口,再登录管理界面,此时应该就能看到这样的界面了… (p.s.或许你的路由器就是WAN口没改也说不定,反正如果没有效果的话,每个端口都试一下就是了) 能够正常显示这几个,则路由器已设置完成. 9.使用GSWIFI小助手对路由器再次设置 ▲注意,使用客服提供的APP,网盘链接在附录中 按照我们的教程来,IP地址填为192.168.8.1,然后按下&quot;开始联网&quot;,之后会有4步,这个过程中WIFI会不断的掉线,需要自己不断重连自己的WIFI(“Hello”),等到4步完成后就可以开始用掌上大学连上WIFI后一键上网了 完成图如下 10.使用掌上大学一键上网 教程到此就结束了,按照上述步骤应该就能完成高科GSWIFI路由器的破解上网了… 附录: GSWIFI小助手江苏版: 网盘:https://pan.baidu.com/share/init?surl=vwza9BJd9kjjMKH6f3ek3g 提取码:svdg 更新系统固件 找到GSWIFI公众号: 选择系统升级 然后查看升级教程 和 1082正式版系统(目前最新的系统固件)，然后根据里面提供的网盘将文件下载下来 下载后===&gt;解压===&gt;进入管理界面===&gt;系统升级===&gt;选择文件===&gt;刷写固件===&gt;执行（其中过程千万不能关闭电源或是乱动，就算按错了，等2-3分钟好了以后再重新刷写也无妨，但是千万不能断电源）","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"WSGI uWSGI uwsgi及nginx说明","slug":"WSGI-uWSGI-uwsgi及nginx说明","date":"2018-11-02T07:50:12.000Z","updated":"2019-09-15T08:07:31.016Z","comments":true,"path":"2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/","link":"","permalink":"https://nymrli.top/2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/","excerpt":"","text":"客户端发出请求==&gt;服务器接受、处理请求与响应 的过程示意图 1. WSGI： 全称是Web Server Gateway Interface(服务器网关接口)。WSGI不是服务器，python模块，框架，API或者任何软件，只是一种规范( 是一个**Web服务器（如nginx）与应用服务器（如uWSGI）**通信的一种规范（协议）==&gt; 可以理解为服务器与应用程序通信的接口规范要求)，描述web server如何与web application通信的规范。server和application的规范在PEP 3333中有具体描述。因为WSGI没有官方的实现, 所以WSGI更像一个协议，只要遵照这些协议，都可以在任何服务器(Server)上运行 2.uwsgi： 与WSGI一样是一种通信协议，是uWSGI服务器的独占协议，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种不同的协议。该协议据说性能非常高，是fcgi协议的10倍快;而且内存占用率低，为mod_wsgi的一半左右，同时它还支持多应用的管理及应用的性能监控 3.uWSGI： 是一个web服务器，而且也可以当做中间件。它实现了WSGI协议、uwsgi协议、http协议等。在生产环境中使用uWSGI作为python web的服务器,可以用来托管 Python WSGI应用。它具有应用服务器，代理，进程管理及应用监控等功能(但可以把看作是一个应用程序，帮助我们实现WSGI协议)，这样我们可以不再关注网络通信的底层实现，将精力更多放在处理HTTP请求数据，返回HTML。 4.uWSGI+nginx 综上所述可以看出uWSGI可以直接当做服务器，而为了进一步的并发提升就需要加上nginx(提高负载均衡) ▲.当uWSGI+nginx使用时，nginx作为web服务器，而uWSGI作为中间件(这边不一定正确,个人理解) uWSGI不足的地方: uWIGS也可以返回静态文件(css,js,img…)，但是很笨拙，所以更好的做法是用反向代理服务器（比如Nginx）来处理此类请求，减轻应用服务器的负载，获得更好的性能。 利用uWIGS可以是我们的web应用得到更强的并发能力，uWIGS也可以返回静态文件(css,js,img…)，但是很笨拙，一般静态文件都交由Nginx进行传输，所以配置中一般不配置static-map,如果直接由uWIGS接受HTTP请求则需要设置http:xxxx，如果只需要与反向代理服务器进行交互则只需要接受socket，uWIGS与Nginx交互相当于两个进程间交互，一般使用的是.sock文件或者指定端口接受socket。指定端口时再使用浏览器访问相应端口，uWIGS会提示skip，跳过该HTTP请求。 同时还有的是uWSGI本身的负载均衡没有nginx牛逼。所以阉割掉不用。 5.Nginx是一个Http和反向代理服务器 什么是反向代理服务器呢？ ▲正向的就是由浏览器主动的想代理服务器发出请求，经代理服务器做出处理后再转给目标服务器 ▲反向的就是不管浏览器同不同意，请求都会经过代理服务器处理再发给目标服务器 这其中的区别就是必须经过Nginx反向代理服务器，这就有了使用Nginx的几个好处： 安全：不管什么请求都要经过代理服务器，这样就避免了外部程序直接攻击web服务器 负载均衡：根据请求情况和服务器负载情况，将请求分配给不同的web服务器，保证服务器性能 提高web服务器的IO性能：这个我也没看懂，总结来说就是请求从客户端传到web服务器是需要时间的，传递多长时间就会让这个进程阻塞多长时间，而通过反向代理，就可以在反向代理这完整接受请求，然后再传给web服务器，从而保证服务器性能，而且有的一些简单的事情（比如静态文件）可以直接由反向代理处理，不经过web服务器 总结","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"apt-get update无法连接","slug":"apt-get-update无法连接","date":"2018-11-02T05:21:45.000Z","updated":"2019-09-15T08:07:30.919Z","comments":true,"path":"2018/11/02/apt-get-update无法连接/","link":"","permalink":"https://nymrli.top/2018/11/02/apt-get-update无法连接/","excerpt":"","text":"出现的问题 原因是在apt-get update时遇到了Unable to connect to 代理，（由于apt-get update一直显示无法连接172.17.18.141百度后发现这并不是个特殊的IP,而且也可以ping到百度）于是想到是否使用了代理。 apt代理的设置： 临时方法 export http_proxy=http://10.3.0.1:80 长久方法 (1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。) Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;; 保存apt.conf文件。 (2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件) 建立文件 vim proxyfile Acquire::http::proxy &quot;http://10.3.0.1:80&quot;; Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;; Acquire::https::proxy &quot;http://10.3.0.1:80&quot;; 使用时sudo apt-get install xxx -c proxyfile (2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 ) 在您的.bashrc文件末尾添加如下内容 export http_proxy=http://用户名:密码@地址:端口/ export https_proxy=http://用户名:密码@地址:端口/ export ftp_proxy=http://用户名:密码@地址:端口/ 附上一篇ubuntu设置代理的文章:ubuntu设置代理 Ubuntu下让终端走SS代理的方法 Ubuntu下让终端走SS代理需要第三方软件的帮助，即privoxy。 privoxy 是非快取式 (non-caching) 的网页代理伺服器，具有进阶的过滤能力，可强化隐私权，还可以修改网页资料、管理 HTTP cookies、去除广告等。 安装 privoxy sudo apt-get install privoxy 安装完成后在 /etc/privoxy 目录下可以找到配置文件 config。 配置 privoxy 一般地，改配置前应该备份配置。 mv /etc/privoxy/config /etc/privoxy/config.back 然后打开 config 文件，找到listen-address那一行，修改值为 privoxy 监听的地址，一般使用默认。 然后再找到forward-socks5那一行，去掉注释，值为SS代理监听的地址。 让终端走SS代理,修改配置后，重启 privoxy。 sudo /etc/init.d/privoxy restart 然后在终端下添加 http 代理。 export http_proxy=”127.0.0.1:8118” export https_proxy=”127.0.0.1:8118” 然后就可以愉快的用终端翻墙了。 原文：https://blog.csdn.net/tailgo/article/details/52075643","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"Windows控制台Cmd乱码（及永久修改编码）解决方法","slug":"Windows-控制台Cmd乱码（及永久修改编码）解决方法","date":"2018-10-28T08:42:20.000Z","updated":"2019-09-15T08:07:31.013Z","comments":true,"path":"2018/10/28/Windows-控制台Cmd乱码（及永久修改编码）解决方法/","link":"","permalink":"https://nymrli.top/2018/10/28/Windows-控制台Cmd乱码（及永久修改编码）解决方法/","excerpt":"","text":"我本机的系统环境：`OS Name: Microsoft Windows 10 家庭中文版 Windows 控制台Cmd乱码的解决办法(一次性) 在cmd中输入 CHCP 65001 注：CHCP是一个计算机指令，能够显示或设置活动代码页编号。 代码页 描述 65001 UTF-8代码页 950 繁体中文 936 简体中文默认的GBK 437 MS-DOS 美国英语 但是通过CHCP设置编码是治标不治本的,想永久的更改cmd编码值需要修改注册表 Windows 控制台Cmd乱码的解决办法(永久性) 方法一： 1.在cmd中输入regedit进入注册表 2.找到HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe 3.新建一个 DWORD（32位值）,命名为CodePage，值设为65001 4.已有CodePage的话，修改它，改为十进制，65001 方法二：(亲测有效) 1.新建一个cmd.reg注册表文件: 2.内容输入如下： 123456789Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe]&quot;CodePage&quot;=dword:0000fde9&quot;FontFamily&quot;=dword:00000036&quot;FontWeight&quot;=dword:00000190&quot;FaceName&quot;=&quot;Consolas&quot;&quot;ScreenBufferSize&quot;=dword:232900d2&quot;WindowSize&quot;=dword:002b00d2 3.双击运行","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"JS正则及常用方法函数总结","slug":"JS正则及常用方法函数总结","date":"2018-10-25T03:55:20.000Z","updated":"2019-09-15T08:07:30.949Z","comments":true,"path":"2018/10/25/JS正则及常用方法函数总结/","link":"","permalink":"https://nymrli.top/2018/10/25/JS正则及常用方法函数总结/","excerpt":"","text":"JS正则及常用方法函数总结 正则表达式作为一种匹配处理字符串的利器在很多语言中都得到了广泛实现和应用，web开发本质上是处理字符串（服务端接受请求处理后拼接字符串作为响应，这在早期的CGI编程中最明显，然后客户端解析字符串进行渲染和执行），所以说，JS作为一门常用于web开发的语言，必然要具备正则这种强大的特性，本文将对JS中的正则用法及常用函数进行一番总结。 1.正则对象及其属性 首先正则对象是JS中内置的一个对象，好比Array以及Math一样，不需要第三方库的支持，通常我们采取两种方式来定义一个正则对象. 1）构造函数方式 12345var reg=new RegExp('abc','gi');/*这里，第一个参数是正则的内容，第二个参数是修饰符，修饰符通常有三种，i,g,m，i表示的含义是忽略大小写进行匹配，g表示全局匹配即匹配到第一个之后不停止继续匹配，m表示多行匹配即遇到换行后不停止匹配继续直到被匹配字符串结束。*/ /i (忽略大小写) /g (全文查找出现的所有匹配字符,否则只匹配第一个出现的) /m (多行查找) /gi(全文查找、忽略大小写) /ig(全文查找、忽略大小写) 2）字面量方式 123456var reg=/abc/gi;consolo.dir(reg);/**▲.两个斜杠之间的是定义的正则内容*，最后一个斜杠之后的是修饰符，这种方式比第一种简单高效，所以通常使用第二种方式来定义正则。*/ 2.属性 在控制台中打印一个正则对象如下： global属性，该属性为布尔类型，用来表示该正则是否是全局匹配， ignoreCase属性，布尔类型，用来指示是否忽略大小写， lastIndex为number类型，用来表示上次匹配成功的位置， multiline，布尔类型，用来表示是否是多行匹配，source，string类型，用来表示正则的内容。 lastIndex 属性表示的索引处为目标字符串匹配（并且不会尝试从后续索引匹配）,你不能直接更改这个属性，它是只读的。可以通过^ unicode标志开启了多种 Unicode 相关的特性。使用 “u” 标志，任何 Unicode 代码点的转义都会被解释。 3.方法 通常对于一个正则对象来讲，我们能够使用的方法基本上有三个，即regObj.test,regObj.exec及regObj.compile 1）test方法 该方法用来测试某个字符串是否与正则匹配，匹配就返回true，否则返回false。该方法接受一个字符串作为参数 123 var reg=/boy(s)?\\s+and\\s+girl(s)?/gi; console.log(reg.test('boy and girl'));//==&gt;true 2)compile方法 该方法的作用是能够对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，适合于对一个正则对象(模式)多次调用的情况下，如果对一个正则只使用一两次，那么该方法没有特别显著的效应。 接受的参数也是一个正则。 1234567var reg=/[abc]/gi; console.log(reg.test('a')); //==&gt;true reg=/[cde]/gi; console.log(reg.test('a')); //==&gt;false reg.compile(reg); console.log(reg.test('a')); //==&gt;false//被编译的正则和没有编译的正则在测试结果上没有任何区别，只是多次调用的效率上会更高一些。 3）exec方法 该方法属于一个比较复杂的方法，它接受一个字符串，返回的是一个数组，数组中第0个元素是匹配的子字符串，第二个元素是正则中的第一个子分组匹配的结果（如果有子分组，即正则中存在用圆括号括起来的分组），第三个是正则中第二个子分组匹配的结果（如果有第二个子分组）…以此类推，如果没有正则子分组，那么该数组长度仅仅为1，就是匹配到的那个子字符串。同时，返回的这个数组同时还是一个对象，它拥有两个属性，分别为index表示当前匹配到的子字符串所处的位置，input属性表示被匹配的原始字符串。最后，该方法中的正则对象如果不是全局匹配，即没有g修饰符，则每次调用只会从字符串开头处匹配第一个结果，且每次调用结果都是一样的。只有指定为全局匹配，才能够按照从左往右依次去匹配，每次调用匹配一个结果，正则对象的lastIndex属性前进到本次匹配的末尾位置，下回再调用的时候，会从lastIndex处开始匹配而不是从头匹配。 12345678var reg=/(\\w)l(\\w)/g;var str=\"hello world hello 123 hello programmer hello test\";var arr=reg.exec(str); while(arr)&#123; console.dir(arr); console.log(\"lastIndex:\"+reg.lastIndex); arr=reg.exec(str); &#125; 结果如下： 12345678910111213141516//非全局匹配代码：var reg=/(\\w)l(\\w)/; var str=\"hello world hello 123 hello programmer hello test\"; var arr=reg.exec(str); var i=0; while(arr)&#123; i++; if(i&lt;=4)&#123; console.dir(arr); console.log(\"lastIndex:\"+reg.lastIndex); arr=reg.exec(str); &#125; else&#123; break; &#125; &#125; 这个时候每次调用的结果都一样，lastIndex根本没有发生变化。 以上就是正则对象及其方法，其实在使用的过程中，JS中的String类型的对象也拥有一些和正则相关的方法，如下： String类型的对象的正则方法 1）search方法 该方法是string对象的一个方法，用来查找第一次匹配的子字符串的位置，如果找到就返回一个number类型的index值，否则返回-1,它返回的只是第一次匹配的位置。 它接受一个正则或者子字符串为参数，这里我们只讨论正则的情况。 123var str=\"hello world\";console.log(str.search(/o/g));//输出结果为4，可以看到尽管具有多个匹配结果而且也声明为全局匹配，但是还是返回的是第一个匹配到的子串的位置； 2）replace方法 该方法用来将字符串中的某些子串替换为需要的内容，接受两个参数，第一个参数可以为正则或者子字符串，表示匹配需要被替换的内容，第二个参数为被替换的新的子字符串。如果声明为全局匹配则会替换所有结果，否则只替换第一个匹配到的结果。 1234var str=&quot;hello world,hello test&quot;;console.log(str.replace(/hello/g,&apos;hi&apos;));//结果为hi world,hi test//如果将上面代码中的g修饰符去掉，则返回的结果是hi world,hello test 3）split方法 该方法主要用来将一个字符串拆分成一个数组，它接受一个正则或者子字符（串）作为参数，返回一个数组，简单情况下，我们不需要使用正则，只有在字符串拆分规则不统一的情况下才需要使用正则，如下： 12345var str=\"how|old*are you\";var arr=str.split(/\\||\\*|\\s+/);// 以|、*、多项空格为分隔符// \\s 匹配任何空白字符,包括空格、制表符、换页符等等console.log(arr); 这里需要将str拆分为单词数组，由于每个单词之间存在不一样的分隔符，我们采取正则来匹配，结果如下： 4）match方法 该方法接受一个正则作为参数，用来匹配一个字符串，它的输出结果在不是全局匹配的情况下和exec方法的结果一致即一个数组并带有额外的属性，如果采用全局匹配，则不返回任何和其被匹配字符串相关的信息，只返回匹配的结果。 12345678910111213141516//非全局匹配代码：var reg2=/(\\w)s(\\w)/;var str2=\"ws1esr\";var result=str2.match(reg2);var i=0; while(result)&#123; i++; if(i&lt;=4)&#123; console.dir(result); console.log(\"lastIndex:\"+reg2.lastIndex); &#125; else&#123; break; &#125; &#125;//非全局匹配下，结果和exec非全局匹配方法返回的完全一致， 12345//全局匹配代码：var reg3=/(\\w)s(\\w)/g;var str4=\"ws1estqsa\";console.dir(str4.match(reg3));//可以看到，在全局匹配下的时候，它不同于exec方法，它会一次性将所有匹配结果以数组形式返回，且这个数组没有其他属性用来指向被匹配字符串的信息，而exec方法在全局匹配下每次返回的依然是本次匹配的结果数组，且这个数组中只包含本次匹配信息，同时又拥有指向被匹配字符串的信息，即match方法在全局匹配下一次性返回了所有匹配结果，而exec在全局匹配下返回的依然是当次匹配结果。","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://nymrli.top/tags/JavaScript/"}]},{"title":"Sublime Text3 Python虚拟环境（补充）——解决控制台中文乱码情况","slug":"Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况","date":"2018-10-24T10:52:35.000Z","updated":"2021-12-27T13:47:30.257Z","comments":true,"path":"2018/10/24/Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况/","link":"","permalink":"https://nymrli.top/2018/10/24/Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况/","excerpt":"","text":"转自：edwardgui的博客 正常的用python编译控制台是不会出现乱码的，但是在使用虚拟环境的情况下中文总是乱码，一开始以为是windows控制台编码的问题。找了挺久后发现是python+virtualenv编译系统的问题，现在我就带领大家解决这个问题。 ▲注：Windows环境下 首先看下是否已经安装了Virtualenv package插件，如果没有，则Ctrl+Shift+P，install Package,输入Virtualenv安装。 找到插件安装的地方：C:\\Users{Username}\\AppData\\Roaming\\Sublime Text 3\\Installed Packages ==&gt;注意改变一下Username 解压Virtualenv.sublime-package文件，可以通过先添加后缀.zip变为Virtualenv.sublime-package.zip再解压 包含文件如下： 修改Python + Virtualenv.sublime-build文件， 增加一行：&quot;env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf8&quot;}, 使其变成 123456789&#123;\"env\": &#123;\"PYTHONIOENCODING\": \"utf8\"&#125;,\"target\": \"virtualenv_exec\",\"shell_cmd\": \"python -u \\\"$file\\\"\",\"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\"selector\": \"source.python\"// 需要加上encoding, 否则输出控制台会中文乱码\"encoding\": \"cp936\"&#125; 然后保存，再把该文件打包为Virtualenv.sublime-package.zip再去掉后缀，就大功告成了。 最后打开Sublime Text3使用Python + Virtualenv 编译，就能看到中文正常输出啦！","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"}]},{"title":"Python爬虫知识点——将Cookie保存到本地的多种方法介绍","slug":"Python爬虫知识点——将Cookie保存到本地的多种方法介绍","date":"2018-10-24T10:43:34.000Z","updated":"2019-09-15T08:07:30.994Z","comments":true,"path":"2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/","excerpt":"","text":"方法一：urllib2 结合cookielib及urllib2，Python2时期比较常用的方法，年代比较久远了。个人觉得太麻烦，改用requests. ▲需要注意的是cookielib在python3中已经改成了http.cookiejar 1234567891011121314151617181920212223242526272829303132333435#该方法本人未测试import urllib2import cookielib#将cookie保存在文件中def saveCookie(): #设置保存cookie的文件 filename = &apos;cookie.txt&apos; #声明一个MozillaCookieJar对象来保存cookie，之后写入文件 cookie = cookielib.MozillaCookieJar(filename) #创建cookie处理器 handler = urllib2.HTTPCookieProcessor(cookie) #构建opener opener = urllib2.build_opener(handler) #创建请求 res = opener.open(&apos;http://www.baidu.com&apos;) #保存cookie到文件 #ignore_discard的意思是即使cookies将被丢弃也将它保存下来 #ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入 cookie.save(ignore_discard=True,ignore_expires=True)#从文件中获取cookie并且访问(我们通过这个方法就可以打开保存在本地的cookie来模拟登录)def getCookie(): #创建一个MozillaCookieJar对象 cookie = cookielib.MozillaCookieJar() #从文件中的读取cookie内容到变量 cookie.load(&apos;cookie.txt&apos;,ignore_discard=True,ignore_expires=True) #打印cookie内容,证明获取cookie成功 for item in cookie: print &apos;name:&apos; + item.name + &apos;-value:&apos; + item.value #利用获取到的cookie创建一个opener handler = urllib2.HTTPCookieProcessor(cookie) opener = urllib2.build_opener(handler) res = opener.open(&apos;http://www.baidu.com&apos;) print res.read() 方法二: 使用requests.cookie 读取cookies 在这里我用的是LWPCookieJar保存在txt文件中，还有个是MozillaCookieJar，都是由FileCookieJar 派生而来，实现了save()方法，而FileCookieJar 没有实现save() MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。 LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。 123456789#实例化一个LWPCookieJar对象load_cookiejar = cookielib.LWPCookieJar()#从文件中加载cookies(LWP格式)load_cookiejar.load(&apos;cookies.txt&apos;, ignore_discard=True, ignore_expires=True)#工具方法转换成字典load_cookies = requests.utils.dict_from_cookiejar(load_cookiejar)#工具方法将字典转换成RequestsCookieJar，赋值给session的cookies.self.session.cookies = requests.utils.cookiejar_from_dict(load_cookies) 存储cookies 将cookies转换成LWP格式然后保存为文本格式 123456789#实例化一个LWPcookiejar对象new_cookie_jar = cookielib.LWPCookieJar(&apos;cookie.txt&apos;)#将转换成字典格式的RequestsCookieJar（这里我用字典推导手动转的）保存到LWPcookiejar中===&gt;RequestsCookieJar没有实现save()方法requests.utils.cookiejar_from_dict(&#123;c.name: c.value for c in self.session.cookies&#125;, new_cookie_jar)#保存到本地文件new_cookie_jar.save(&apos;cookies.txt&apos;, ignore_discard=True, ignore_expires=True) 方法三: 将cookie字典弄成字典形式然后pickle或者json写入文件中 存储cookie 12345678import requests,json,pprints = requests.session()s.headers = &#123;...&#125;a = s.get(&quot;https://www.baidu.com&quot;)cookies = requests.utils.dict_from_cookiejar(s.cookies)with open(&quot;.\\\\cook.txt&quot;, &quot;w&quot;) as fp: json.dump(cookies, fp)pprint.pprint(cookies,width=5) 读取cookie 123with open(&quot;.\\cook.txt&quot;, &quot;w&quot;) as fp: load_cookies=son.load(fp)session.cookie = requests.utils.cookiejar_from_dict(load_cookies) 方法四: 将requests.cookie设置为LWPCookieJar、或MozillaCookieJar保存 123456session = requests.Session()#创建个 LWPCookieJar对象session.cookies = LWPCookieJar(filename=&apos;cook.txt&apos;)s.get(&apos;https://www.baidu.com/&apos;,headers=headers)session.cookies.save(ignore_discard=True, ignore_expires=True)#如果save()时没有写filename参数，则默认为实例化LWPCookieJar时给的文件名 save()方法的两个重要参数 ignore_discard: save even cookies set to be discarded. ignore_expires: save even cookies that have expired.The file is overwritten if it already exists ignore_discard的意思是即使cookies将被丢弃也将它保存下来，ignore_expires的意思是如果cookies已经过期也将它保存并且文件已存在时将覆盖 总结方法二和方法三可以看出，就是要将cookie转换成然后save() 简单介绍下cookielib模块作用，科普下实现cookie知识 python3中将cookielib模块改为了http.cookiejar 12345678910&gt; cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。例如可以利用本模块 的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送。coiokielib模块用到的对象主要有下面几个：CookieJar、 FileCookieJar、MozillaCookieJar、LWPCookieJar。其中他们的关系如下：&gt; &gt; CookieJar &gt; &gt; | &gt; &gt; FileCookieJar &gt; &gt; / \\ &gt; MozillaCookieJar LWPCookieJar","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Python爬虫知识点——Session与Cookie","slug":"Python爬虫知识点——Session与Cookie","date":"2018-10-24T10:36:56.000Z","updated":"2019-09-15T08:07:30.990Z","comments":true,"path":"2018/10/24/Python爬虫知识点——Session与Cookie/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——Session与Cookie/","excerpt":"","text":"Session和Cookie： Cookie：保持登录后的认证状态而保存在本地的数据 session:用cookie来标记用户，cookie携带了会话ID消息，通过检查cookie就能找到会话(session) cookie与session相互配合，一个处于客户端，一个处于服务端，两者相互协作。 会话cookie和持久cookie 会话Cookie：把cookie放在浏览器内存里，浏览器关闭后失效。 持久Cookie：保存cookie到客户端的硬盘中，下次继续使用。 由Cookie的Max Age和Expires决定了过期的时间。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——代理","slug":"Python爬虫知识点——代理","date":"2018-10-24T10:36:28.000Z","updated":"2019-09-15T08:07:30.992Z","comments":true,"path":"2018/10/24/Python爬虫知识点——代理/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——代理/","excerpt":"","text":"代理 基本原理 代理实际上指代理服务器。功能是代理 网络用户去取得网络信息，是网络信息的中转站。 正常的请求过程为：发送请求给服务器===&gt;web服务器吧响应传回 设置代理服务器后：&gt;向代理服务器发送请求&gt;请求发送给代理服务器==&gt;再由代理服务器发送web服务器==&gt;由代理服务器把web服务器返回的响应转发给本机 作用 突破自身IP访问限制，访问些平时不能访问的站点。 访问一些单位或团体内部资源:比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。 提高访问速度:通常代理服务器都设置-一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息传给用户，以提高访问速度。 隐藏真实IP:上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP,防止自身的IP被封锁。 代理分类 根据代理的协议，代理可以分为如下类别。 FTP代理服务器: 主要用于访问FTP服务器，一般有上传、 下载以及缓存功能，端口一般为 21、2121等。 HTTP代理服务器:主要用于访问网页，一般有内容过滤和缓存功能，端口一般为808080、3128 等。 SSL/TLS代理:主要用于访同加密网站，般有 SsL 或TLS 加密功能(最高支持128位加密强度)，端口一般为443。 RTSP代理:主要用于访问Real流媒体服务器，一般有缓存功能， 端口般为554。 Telnet代理: 主要用于tenei远程控制黑客人侵计算机时常用于隐藏身份)，端口一般为23 POP3/SMTP代理:主要用于POP3/SMTP方式收发邮件，一般有缓存功能，端口-般为1025.口SOCKS代理:只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般 有 存功能，端口一般为1080。SOCKS代理协议又分为SOCKS4和SOCKS5,前者只支持TCP而后者支持TCP和UDP，还支持各种身份验证机制、服务器端域名解析等。简单来说SOCKS4能做到的SOCKS5都可以做到，但SOCKSS能做到的SOCKS4不一定能做到。 2.根据匿名程度区分 根据代理的匿名程度，代理可以分为如下类别。 高度匿名代理：会将数据包原封不动地转发，在服务端看来就好像真的是一 个普通客户端访问，而记录的IP是代理服务器的IP。 普通匿名代理：会在数据包上做一些改动， 服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实IP。代理服务器通常会加人的HTTP头有HTTP_VIA和HTTP_X_FORWARDED_FOR. 透明代理：不但改动了数据包，还会告诉服务器客户端的真实IP。这种代理除了能用缓存技术调高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。 间谍代理：指组织或个人创建的用于记录用户传输的数据， 然后进行研究、监控等目的代理服务器。 常用代理设置 网上的免费代理 付费的代理服务 ADSL拨号","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——请求","slug":"Python爬虫知识点——请求","date":"2018-10-24T10:36:21.000Z","updated":"2019-09-15T08:07:30.995Z","comments":true,"path":"2018/10/24/Python爬虫知识点——请求/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——请求/","excerpt":"","text":"请求 :请求方法、请求网址、请求头、请求体 请求方法： 常见的为:GET、POST GET与POST主要区别： GET请求参数包含在URL，可从URL中看出。POST请求的URL不包含参数，都是通过表单的形式传输的，包含在请求体中 GET请求提交的数据最多只有1024字节，POST无限制 其他还有HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE 请求的网址： 即URL，我们想要请求的资源 请求头： 用来说明服务器要使用的附加信息，比较总要的有Cookie、Referer、User-Agent等。 Accept:请求报头域，用于指定客户端可接受哪些类型的信息。 Accept-Language:指定客户端可接受的语言类型。 Accept-Encoding:指定客户端可接受的内容编码。 Host:用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位 置。从HTTP1.1版本开始，请求必须包含此内容。 Cookie:也常用复数形式Cookies, 是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输人用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies 并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。 Referer:此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。 User-Agent: 简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等消息。在做爬虫时加上此信息，可以伪装成浏览器；如果不加，很可能被识别出为爬虫 Content-Type:也叫互联网媒体类型( Intermet Media Type)或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。更多对应关系可以查看此对表:http://tool.oschina.net/commons 文件扩展名 Content-Type(Mime-Type) .html、 .htx 、 .htm text/html .gif image/gif .json application/json ​ Content-Type与POST提交数据方式的关系 Content-Type 提交数据的方式 appication/x-www-urlencodeed 表单数据 multipart/form-data 表单文件上传 applicatiobn/json 序列化json数据 text/html XML数据 如果构造POST请求，需要使用正确的Content-Type，不然可能导致POST提交后无法正常响应 ==&gt;因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。 请求体： 请求体一般承载的内容是POST请求中的表单数据，而对GET请求，请求体则为空。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——响应","slug":"Python爬虫知识点——响应","date":"2018-10-24T10:36:17.000Z","updated":"2019-09-15T08:07:30.993Z","comments":true,"path":"2018/10/24/Python爬虫知识点——响应/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——响应/","excerpt":"","text":"响应： 响应状态码、响应头、响应体 响应状态码： 表2-3常见的错误代码及错误原因 状态码 说明 详情 100 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换。 200 成功 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 201 已创建 请求成功并且服务器创建了新的资源。 202 已接受 服务器已接受请求，但尚未处理。 203 非授权信息 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 无内容 服务器成功处理了请求，但没有返回任何内容。 205 重置内容 服务器成功处理了请求，但没有返回任何内容。 206 部分内容 服务器成功处理了部分 GET 请求。 300 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 查看其他位置 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 未修改 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 305 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307 临时重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 400 错误请求 服务器不理解请求的语法。 401 未授权 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 禁止 服务器拒绝请求。 404 未找到 服务器找不到请求的网页。 405 方法禁用 禁用请求中指定的方法。 406 不接受 无法使用请求的内容特性响应请求的网页。 407 需要代理授权 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 请求超时 服务器等候请求时发生超时。 409 冲突 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。 410 已删除 如果请求的资源已永久删除，服务器就会返回此响应。 411 需要有效长度 服务器不接受不含有效内容长度标头字段的请求。 412 未满足前提条件 服务器未满足请求者在请求中设置的其中一个前提条件。 413 请求实体过大 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 请求的 URI 过长 请求的 URI（通常为网址）过长，服务器无法处理。 415 不支持的媒体类型 请求的格式不受请求页面的支持。 416 请求范围不符合要求 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 未满足期望值 服务器未满足&quot;期望&quot;请求标头字段的要求。 500 服务器内部错误 服务器遇到错误，无法完成请求。 501 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502 错误网关 服务器作为网关或代理，从上游服务器收到无效响应。 503 服务不可用 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504 网关超时 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 HTTP 版本不受支持 服务器不支持请求中所用的 HTTP 协议版本。 响应头 响应头包含了服务器对请求的应答信息，如Cmene-Type. Serve. Set-cookie等。 下面简要说有 一些常用的头信息。 Date:标识响应产生的时间。 Last-Modifed:指定资源的最后修改时间。 公有地会 Content-Encoding:指定响应内容的编码。 Server:包含服务器的信息，比如名称、版本号等。 Content-Type:文档类型，指定返回的数据类型是什么，如texthtmI代表返回HTML文档， application/x-javascript则代表返回JavaScript文件，imagefjpeg 则代表返回图片。 Set-Cookie:设置Cookies。 响应头中的Set-Cookie 告诉浏览器需要将此内容放在Cooke 中，下次请求携带Cookies请求。 Expires:指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。立 果再次访问时，就可以直接从缓存中加载，降低服务器负载，编短加载时间。 响应体 最重要的当属响应体的内容了。 响应的正文数据都在响应体中，比如请求网页时，它的响应体就 是网页的HTML代码:请求一张图片时， 它的响应体就是图片的二进制数据。我们做爬虫请求后主 要解析的内容就是响应体。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——爬虫的基本原理","slug":"Python爬虫知识点——爬虫的基本原理","date":"2018-10-24T10:36:10.000Z","updated":"2019-09-15T08:07:30.994Z","comments":true,"path":"2018/10/24/Python爬虫知识点——爬虫的基本原理/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——爬虫的基本原理/","excerpt":"","text":"爬虫的基本原理 爬虫就是获取网页并提取和保存信息的自动化程序 获取网页： 获取网页就是获取网页的源码，只要把源码获取下来，就可以从中提取想要的消息 爬虫的流程：想网站的服务器发送一个请求，返回的响应体就是网页的源代码。 ​ &gt;1,构造请求发送给服务器=&gt;2.接受响应并解析 提取信息： 通过分析网页结构，提取网页信息。通常使用的解析库有:BeautifulSoup、lxml、pyquery，也可以使用正则，但是构造正则表达式比较复杂且易错 保存数据： 将提取的数据保存到某处以便后续利用。保存形式有：TXT、Json、数据库：MySQL、MongoDB、或远程服务器SFTP… 自动化程序 替人完成完成爬取工作的自动化程序，可以在抓取过程中进行异常处理……保证爬取的高效运行","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——URL与URI","slug":"Python爬虫知识点——URL与URI","date":"2018-10-24T10:35:53.000Z","updated":"2019-09-15T08:07:30.991Z","comments":true,"path":"2018/10/24/Python爬虫知识点——URL与URI/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——URL与URI/","excerpt":"","text":"URL与URI URL全称：Uniform Resource Locator(统一资源定位符) URI全称：Uniform Resource Identifier(统一资源标识符) 如https://github.com/favicon.ico为例，它既是一个URL又是一个URI。我们通过URL/URI唯一指定了它的访问方式。其中包括访问协议https、访问路径、资源名称favicon.ico。通过这个链接提供的消息，我们就可以直接访问到此资源所在的位置。这便是URL、URI的作用。 URL是URI的子集。===&gt;每个URL都是URI，但不是每个URI都是URL。 URI包括两个子类:URN和URL。其中URN只命名资源但不指定如何定位资源(如urn:isbn:0451450523)指定了一本书的ISBN，可以唯一标识，但未定位。 ▲.目前互联网中URN用得很少，几乎所有的URI都是URL。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——Chrome开发者工具Network","slug":"Python爬虫知识点——Chrome开发者工具Network","date":"2018-10-24T10:35:31.000Z","updated":"2019-09-15T08:07:30.989Z","comments":true,"path":"2018/10/24/Python爬虫知识点——Chrome开发者工具Network/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——Chrome开发者工具Network/","excerpt":"","text":"Chrome开发者工具中Network功能介绍 第一列Name:请求的名称，一般会将URL的最后一 部分内容当作名称。 第二列Status: 响应的状态码，这里显示为200，代表响应是正常的。通过状态码，我们可 以判断发送了请求之后是否得到了正常的响应。 第三列Type: 请求的文档类型。这里为document, 代表我们这次请求的是一个HTML文档,内容就是一些HTML代码。 第四列initiator: 请求源。用来标记请求是由哪个对象或进程发起的。 第五列Size: 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示from cache。 第六列Time:发起请求到获取响应所用的总时间。 第七列Waterfall:网络请求的可视化瀑布流。 响应中分General部分，请求头、响应头： 其中General含： Request URL为请求的URL， Request Method为请求的方法 Status Code为响应状态码， Remote Address为远程服务器的地址和端口 Referrer Policy为Referrer判别策略。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"XShell通过SSH远程连接云服务器通过SSH远程连接云服务器","slug":"XShell通过SSH远程连接云服务器","date":"2018-10-24T10:32:05.000Z","updated":"2019-09-15T08:07:31.017Z","comments":true,"path":"2018/10/24/XShell通过SSH远程连接云服务器/","link":"","permalink":"https://nymrli.top/2018/10/24/XShell通过SSH远程连接云服务器/","excerpt":"","text":"1.账号密码登录 法一: 法二:","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"复制Django项目时需要注意、修改的地方","slug":"复制Django项目时需要注意、修改的地方","date":"2018-10-24T10:25:37.000Z","updated":"2019-09-15T08:07:31.043Z","comments":true,"path":"2018/10/24/复制Django项目时需要注意、修改的地方/","link":"","permalink":"https://nymrli.top/2018/10/24/复制Django项目时需要注意、修改的地方/","excerpt":"","text":"复制Django项目: manage.py中需要修改的地方 1os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;window.settings&quot;) settings.py中需要修改的地方 12345&quot;&quot;&quot;Django settings for window project.&quot;&quot;&quot;ROOT_URLCONF = &apos;window.urls&apos;WSGI_APPLICATION = &apos;window.wsgi.application&apos; urls.py中需要改动的地方 1&quot;&quot;&quot;window URL Configuration wsgi.py中需要修改的地方 123&quot;&quot;&quot;WSGI config for window project.os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;window.settings&quot;) django可复用模板 在project_name文件下的*.py 再在终端键入django-admin startproject xx --template=* (*为文件夹中py文件名) 12345678910111213141516171819202122232425262728293031323334import osimport sysfrom django.conf import settingsDEBUG = os.environ.get(&apos;DEBUG&apos;,&apos;on&apos;)== &apos;on&apos;ALLOW_HOSTS = [&apos;*&apos;]SECRET_KEY = os.environ.get(&apos;SECRET&apos;,&apos;&#123;&#123; secret_key &#125;&#125;&apos;)settings.configure( DEBUG = DEBUG, ALLOW_HOSTS = ALLOW_HOSTS, SECRET_KEY = SECRET_KEY, ROOT_URLCONF = __name__, MIDDLEWARE_CLASSES = ( &apos;django.middleware.common.CommonMiddleware&apos;, &apos;django.middleware.csrf.CsrfViewMiddleware&apos;, &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;, ))from django.conf.urls import urlfrom django.core.wsgi import get_wsgi_applicationfrom django.http import HttpResponsedef index(request): return HttpResponse(&apos;Hello Word&apos;)urlpatterns = ( url(r&apos;$&apos;,index),)application = get_wsgi_application()if __name__ == &apos;__main__&apos;: from django.core.management import execute_from_command_line execute_from_command_line(sys.argv)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Django","slug":"Django","permalink":"https://nymrli.top/tags/Django/"}]},{"title":"Python Web——Django笔记(一)","slug":"Python Web——Django笔记(一)","date":"2018-10-24T10:23:40.000Z","updated":"2019-09-15T08:07:30.975Z","comments":true,"path":"2018/10/24/Python Web——Django笔记(一)/","link":"","permalink":"https://nymrli.top/2018/10/24/Python Web——Django笔记(一)/","excerpt":"","text":"Python Web——Django笔记 新建项目: django-admin startproject blog . 创建应用程序(APP):python manage.py startapp fsite 添加app:INSTALLED_APPS=['...'] 新建的 app 如果不加到 INSTALL_APPS 中的话, django 就不能自动找到app中的模板文件(app-name/templates/下的文件)和静态文件(app-name/static/中的文件) .小提示，DEBUG=True 的时候，Django 还可以自动找到 各 app 下 static 文件夹中的静态文件（js，css，图片等资源） 创建SQLite数据库:python manage.py migrate #创建数据表 使模型生效:python manage.py makemigrations # Django 在 blog 应用的 migrations\\ 目录下生成了一个 0001_initial.py 文件，这个文件是 Django 用来记录我们对模型做了哪些修改的文件 创建管理员:python manage.py createsuperuser 添加template: 'DIRS':[os.path.join(BASE_DIR,'templates')], 清空数据库:python manage.py flush BASE_DIR 是 settings.py 在配置开头前面定义的变量 添加静态文件: 123STATIC_URL = &apos;/static/&apos;STATICFILES_DIRS = [os.path.join(BASE_DIR,&apos;static&apos;)]STATIC_ROOT = &quot;/home/nymrli/mvote/staticfiles/&quot; urls.py头文件 1234&gt; from django.contrib import admin&gt; from django.conf.urls import include,url&gt; from fsite.views import homepage,showpost&gt; views.py头文件 12345&gt; from django.shortcuts import render,redirect&gt; from django.http import HttpResponse,request&gt; from .models import Post&gt; from django.template.loader import get_template&gt; 使显示标题: 12def __str__(self): return self.title 书上的__unicode__和__repr__都没有用 增加显示其他时 12class PostAdmin(admin.ModelAdmin): list_display = (&apos;title&apos;,&apos;slug&apos;,&apos;pub_date&apos;) 要记得在admin.site.register(Post,PostAdmin)中增加PostAdmin 在urls.py中的url()的库文件要修改 12from django.contrib import adminfrom django.conf.urls import include,url 同时记得这点: 1234urlpatterns = [ url(&apos;^admin/&apos;, admin.site.urls), ## &apos;^admin/&apos;在/后面不能加$ url(r&apos;^$&apos;,homepage), ] views.py视图函数: 12def homepage(request): ##首先记得是*def* posts = Post.objects.all() ##虽然pycharm没提示Post有objects但仍有效果 count,post in enumerate(posts):1234for count,post in enumerate(posts): post_lists.append(&quot;NO.&#123;&#125;&quot;.format(str(count)) + str(post) + &quot;&lt;hr&gt;&quot;) post_lists.append(&quot;&lt;small&gt;&quot; + str(post.body.encode(&apos;utf-8&apos;)) + &quot;&lt;/small&gt;&lt;br&gt;&quot;) ### 这边的encode没必要加 template 步骤1: 在settings.py 中设置模板文件夹的位置. 步骤2:在urls.py中创建网址和views.py中函数的对应关系 步骤3:创建.html文件(例如index.html)做好排版数据要放的位置 步骤4:运行程序,以objects.all()在views.py中取得数据或资料 步骤5:以render函数把数据(posts)送到指定的模板文件(例如index.html)中. 网页对应urls.py 步骤1: 在urls.py中设置,只要是/post/开头的网址,就把后面接着的文字当做参数传送slug给post_detail显示单篇文章的函数 步骤2:在views.py中新增一个post_detail函数.除了接受request参数外,也接受slug参数. 步骤3:在templates文件夹中创建一个用来显示单篇文章的post.html 步骤4:在post_detail函数中,以slug为关键字搜索数据集,找出是否有符合的项目 步骤5:如果有符合的,就把找到的数据项传送给render函数,找出post.html模板页进行渲染(即进行页面显示),再把结果交给HttpResponse回传给浏览器 步骤6:如果没有符合的项目,就把网页转回首页 共享模板的使用: 文件名 用途说明 base.html 网站的基础模板，提供网站的主要设计、外观风格 header.html 网站中每一个网页共享的标题元素，通常是放置网站 Log 的地方 footer.html 网站中每一个网页的共享页尾，用来放置版权声明或其他参考信息 index.html 此范例网站的首页 post.html 此范例网站用来显示单篇文章的网页 显示图片 要用过滤器,不然就是串html代码. Wampserver初始: 12账号:root密码:空 bootstrap的CDN: HTML.CSS放在之前,JS的放在之前 12345678910111213&lt;head&gt;&lt;!-- Latest compiled and minified CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; integrity= &quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- Optional theme --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css&quot; integrity=&quot;sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- Latest compiled and minified JavaScript --&gt;&lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js&quot; integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/head&gt; 12345&lt;body&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.1.0.min.js&quot; integrity=&quot;sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/body&gt; 后台管理的自定义admin.py 显示更多的小标题 12345class ProductAdmin(admin.ModelAdmin): list_display = (&apos;pmodel&apos;,&apos;nickname&apos;,&apos;price&apos;,&apos;year&apos;) search_fields = (&apos;nickname&apos;,) ordering = (&apos;price&apos;,)admin.site.register(Product,ProductAdmin) 要显示中文的小标题 12345678class Product(models.Model): pmodel = models.ForeignKey(PModel,on_delete=models.CASCADE,verbose_name=&apos;型号&apos;) nickname = models.CharField(max_length=15,default=&apos;超值二手机&apos;,verbose_name=&apos;摘要&apos;) description = models.TextField(default=&apos;暂无说明&apos;) year = models.PositiveIntegerField(default=2018,verbose_name=&apos;出厂年份&apos;) price = models.PositiveIntegerField(default=0,verbose_name=&apos;价格&apos;) def __str__(self): //python3.*中都用__str__,不用__unicode__ return self.nickname 注意:admin.py 中的class ProductAdmin 仍需要 12345try: product = models.Product.objects.get(id=id) images = models.PPhoto.objects.filter(product=product)except: pass django中的ORM中如果用get找不到,就会产生一个DoseNotExist的异常中断程序 filter作用:我们很少会一次性从数据库中取出所有的数据；通常都只针对一部分数据进行操作 所以要将product中的成员单独 ***python 中没有null *** 与C不同的是，在python中是没有NULL的，取而代之的是None，它的含义是为空 python是把0，空字符串‘ ’和None都看作False，把其他数值和非空字符串都看作True 表示该值是一个空对象，空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 123456&lt;label for=&quot;byear&quot;&gt;你的年份:&lt;/label&gt;&lt;select name=&apos;byear&apos;&gt; &#123;% for year in years %&#125; &lt;option value=&quot;&#123;&#123; year &#125;&#125;&quot;&gt;&#123;&#123; year &#125;&#125;&lt;/option&gt; &#123;% endfor %&#125;&lt;/select&gt;&lt;br&gt; 这个也要放到中 对数据的提取: 12345try: urid = request.GET[&apos;user_id&apos;] urpass = request.GET[&apos;user_pass&apos;] urfcolor = request.GET.getlist(&apos;fcolor&apos;) #注意区别()与[] uryear = request.GET[&apos;byear&apos;]","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Django","slug":"Django","permalink":"https://nymrli.top/tags/Django/"}]},{"title":"Python Web——Django笔记(二)","slug":"Python Web——Django笔记(二)","date":"2018-10-24T10:23:40.000Z","updated":"2019-09-15T08:07:30.976Z","comments":true,"path":"2018/10/24/Python Web——Django笔记(二)/","link":"","permalink":"https://nymrli.top/2018/10/24/Python Web——Django笔记(二)/","excerpt":"","text":"Method= POST的操作 在posting.html中的&lt;form&gt;中加入标识符 1234&gt; &#123;% csrf_token %&#125;&gt; &lt;form name=&apos;my form&apos; action=&apos;.&apos; method=&apos;POST&apos;&gt; &gt; &#123;% csrf_token %&#125;&gt; ▲注意action='???' 12345678910在views.posting处理函数中改用RequestContext作为网页显示的内容: from django.template import RequestContext def posting(request): template = get_template('posting.html') moods = models.Mood.objects.all() message = '如果....' request_context = RequestContext(request) request_context.push(locals()) html = template.render(context=locals(), request=request) return HttpResponse(html) 窗体Form与ModelForm区别 Form 的所有选项都是自己在forms.py 中class定义的一个类,而ModelForm则是直接引用写好的models.py中的模型. 123456789101112131415from django import formsclass ContactForm(forms.Form): CITY = [ ['TP', 'Taipei'], ['TY', 'Taoyuang'], ['TC', 'Taichung'], ['TN', 'Tainan'], ['KS', 'Kaohsiung'], ['NA', 'Others'], ] user_name = forms.CharField(label='你的姓名',max_length=50,initial='李大仁') user_city = forms.ChoiceField(label='居住的城市',choices=CITY) user_school = forms.BooleanField(label='是否在学',required=False) user_email = forms.EmailField(label='电子邮件') user_message = forms.CharField(label='你的意见',widget=forms.Textarea) 1234567891011121314151617181920212223242526-----------------------------------------------------------------------------------------&lt;!--posting.html--&gt;&#123;% extends &quot;base.html&quot; %&#125;&#123;% block title %&#125;我有话要说&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=&apos;container&apos;&gt;&#123;% if message %&#125; &lt;div class=&apos;alert alert-warning&apos;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#123;% endif %&#125;&lt;form name=&apos;my form&apos; action=&apos;/&apos; method=&apos;POST&apos;&gt; &#123;% csrf_token %&#125; 现在的心情：&lt;br/&gt; &#123;% for m in moods %&#125; &lt;input type=&apos;radio&apos; name=&apos;mood&apos; value=&apos;&#123;&#123; m.status &#125;&#125;&apos;&gt;&#123;&#123; m.status &#125;&#125; &#123;% endfor %&#125; &lt;br/&gt; 心情留言板：&lt;br/&gt; &lt;textarea name=&apos;user_post&apos; rows=3 cols=70&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;label for=&apos;user_id&apos;&gt;你的昵称：&lt;/label&gt; &lt;input id=&apos;user_id&apos; type=&apos;text&apos; name=&apos;user_id&apos;&gt; &lt;label for=&apos;user_pass&apos;&gt;张贴/删除密码：&lt;/label&gt; &lt;input id=&apos;user_pass&apos; type=&apos;password&apos; name=&apos;user_pass&apos;&gt;&lt;br/&gt; &lt;input type=&apos;submit&apos; value=&apos;张贴&apos;&gt; &lt;input type=&apos;reset&apos; value=&apos;清除重填&apos;&gt;&lt;/form&gt;&lt;/div&gt;&#123;% endblock %&#125; 1234567891011121314151617181920212223242526&lt;!-- index.html (ch08www project) --&gt; &#123;% extends &quot;base.html&quot; %&#125; &#123;% block title %&#125;我有话要说&#123;% endblock %&#125; &#123;% block content %&#125; &lt;div class=&apos;container&apos;&gt; &#123;% if message %&#125; &lt;div class=&apos;alert alert-warning&apos;&gt;&#123;&#123; message &#125;&#125; &lt;/div&gt; &#123;% endif %&#125; &lt;form name=&apos;my form&apos; action=&apos;/&apos; method=&apos;POST&apos;&gt; &#123;% csrf_token %&#125; 现在的心情：&lt;br/&gt; &#123;% for m in moods %&#125; &lt;input type=&apos;radio&apos; name=&apos;mood&apos; value=&apos;&#123;&#123; m.status &#125;&#125;&apos;&gt;&#123;&#123; m.status &#125;&#125; &#123;% endfor %&#125; &lt;br/&gt; 心情留言板：&lt;br/&gt; &lt;textarea name=&apos;user_post&apos; rows=3 cols=70&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;label for=&apos;user_id&apos;&gt;你的昵称：&lt;/label&gt; &lt;input id=&apos;user_id&apos; type=&apos;text&apos; name=&apos;user_id&apos;&gt; &lt;label for=&apos;user_pass&apos;&gt;张贴/删除密码：&lt;/label&gt; &lt;input id=&apos;user_pass&apos; type=&apos;password&apos; name=&apos;user_pass&apos;&gt;&lt;br/&gt; &lt;input type=&apos;submit&apos; value=&apos;张贴&apos;&gt; &lt;input type=&apos;reset&apos; value=&apos;清除重填&apos;&gt; &lt;/form&gt; &lt;/div&gt; &#123;% endblock %&#125; 12345678910111213from django import formsfrom . import modelsclass PostForm(forms.ModelForm): class Meta: model = models.Post //告诉model 与那个模型耦合 fields = ['mood','nickname','message','del_pass'] //需要显示的data def __init__(self,*args,**kwargs): super().__init__(self,*args,**kwargs) self.fields['mood'].label = '现在的心情' self.fields['nickname'].label = '您的昵称' self.fields['message'].label = '心情留言' self.fields['del_pass'].label = '设置密码' 12345678910111213141516171819-----------------------------------------------------------------------------------------&lt;!--post2db.html--&gt;&#123;% extends &quot;base.html&quot; %&#125;&#123;% block title %&#125;我有话要说&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=&apos;container&apos;&gt;&#123;% if message %&#125; &lt;div class=&apos;alert alert-warning&apos;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#123;% endif %&#125; &lt;form name=&apos;my form&apos; action=&apos;/&apos; method=&apos;POST&apos;&gt; &#123;% csrf_token %&#125; &lt;table&gt; &#123;&#123; post_form.as_table&#125;&#125; //省去了前端对表格的代码 &lt;/table&gt; &lt;input type=&quot;submit&quot; value=&quot;张贴&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重填&quot;&gt;&lt;/form&gt;&lt;/div&gt;&#123;% endblock %&#125; △同时用ModelForm 的还有一好处为:并没有特别处理’‘现在的心情’'那部分,但ModelForm自动帮我们处理好了,外键的字段自动获得数据,并自动成为下拉式菜单 提交的数据接收: 12345678910111213141516基本窗体: &lt;form method=&quot;GET&quot;&gt; # 所以获取数据为: user_id = request.GET[&apos;user_id&apos;] &lt;form method=&quot;POST&quot;&gt; # user_id = request.POST[&apos;user_id&apos;]自定义窗体:(Form类) &lt;form method= &apos;POST&apos;&gt; # form(实例).cleaned_data[&apos;user_id&apos;] ModelForm : post_form.save() 数据的保存: 基本窗体: 123mood = models.Mood.objects.get(status=user_mood)post = models.Post.objects.create(mood=mood, nickname=user_id, message=user_post, del_pass=user_pass)post.save() ModelForm: 1post_form.save() 验证码功能(Django-simple-captcha): 安装Django-simple-captcha INSTALL_APPS中添加 python manage.py migrate url(r'^captcha/',include('captcha.urls')), 安装Pillow 1234class PostForm(forms.ModelForm): captcha = CaptchaField() def __init__(self,*args,**kwargs): self.fields[&apos;captcha&apos;].label = &apos;验证码&apos; 123456&gt; COLORS = [&gt; [&apos;黄&apos;,&apos;黄&apos;],&gt; [&apos;白&apos;,&apos;白&apos;],&gt; [&apos;红&apos;,&apos;红&apos;], //前面的是值,后面的是显示的选项&gt; ]&gt; 1234*render 与 render_to_response的区别* return render(request, &apos;blog_add.html&apos;, &#123;&apos;blog&apos;: blog, &apos;form&apos;: form, &apos;id&apos;: id, &apos;tag&apos;: tag&#125;)-----------------------------------------------------------------------------------------return render_to_response(&apos;blog_add.html&apos;, &#123;&apos;blog&apos;: blog, &apos;form&apos;: form, &apos;id&apos;: id, &apos;tag&apos;: tag&#125;) render比render_to_response少填一个request参数 12345request.session[&apos;username&apos;] = user.name //设置sessionif &apos;username&apos; in request.session: username = request.session[&apos;username&apos;] //取出session del request.session[&apos;username&apos;] //删除session 12345678if username: response.set_cookie(&apos;username&apos;,username) //设置Cookie //django1.11需要加encoding(&apos;utf-8&apos;),2.0不需要if &apos;username&apos; in request.COOKIES and &apos;usercolor&apos; in request.COOKIES: username = request.COOKIES[&apos;username&apos;] //取出COOKIEdef logout(request): response = HttpResponseRedirect(&apos;/&apos;) response.delete_cookie(&apos;username&apos;) //删除cookie Django的信息显示框架:messages framework 123from django.contrib import messages主要提供两个函数: messages.add_message(request,messages.SUCCESS,&apos;成功登陆了!&apos;) messages.get_messages(request) ▲注意message后面有没有s add_message()信息的内容类型默认分成以下几个等级: DEBUG 调试信息字符串 INFO 信息字符串 SUCCESS 成功信息字符串 WARNING 警告信息字符串 ERROR 错误信息字符串 Django auth用户验证 from django.contrib.auth.models import User 主要提供三个函数: authenticate(yz = input ,[]) //验证 login(request,user) //将数据存入Session,user为authenticate的返回值 logout(request) if user.is_active //检查账号是否有效,也没有括号 1234from django.contrib.auth.models import Userfrom django.contrib.auth import authenticatefrom django.contrib import auth //为了避免和自定义的 login.logout重名from django.contrib.auth.decorators import login_required 验证session是否存在: 12if request.user.is_authenticated: #▲1.11不加(),2.0可加可不加 需要登录才能浏览 1@login_required(login_url=&apos;/login/&apos;) 增加auth的User字段 123456789101112models.py中from django.contrib.auth.models import Userclass Profile(models.Model): user = models.OneToOneField(User,on_delete=models.CASCADE) height = models.PositiveIntegerField(default=60) male = models.BooleanField(default=False) website = models.URLField(null=True) admin.py中admin.site.register(models.Profile)terminal: python mange.py migrate\\makemigrations 显示增加的User字段 123456789101112@login_required(login_url=&apos;/login/&apos;)def userinfo(request): if request.user.is_authenticated: username = request.user.username try: user = User.objects.get(username = username) userinfo = models.Profile.objects.get(user = user) except: pass template = get_template(&apos;userinfo.html&apos;) html = template.render(locals()) return HttpResponse(html) 点击的方式输入日期: 1234567891011121314151617class DateInput(forms.DateInput): //不是forms.DateField input_type = &apos;date&apos;class DiaryForm(forms.ModelForm): class Meta: model = models.Diary fields = [&apos;budget&apos;,&apos;weight&apos;,&apos;note&apos;,&apos;ddate&apos;] #没有指出user字段...通过ORM取出 widgets = &#123; &apos;ddate&apos;:DateInput(), &#125; def __init__(self,*args,**kwargs): super(DiaryForm,self).__init__(*args,**kwargs) self.fields[&apos;budget&apos;].label = &apos;今日话费(元)&apos; self.fields[&apos;weight&apos;].label = &apos;今日体重(KG)&apos; self.fields[&apos;note&apos;].label = &apos;心情留言&apos; self.fields[&apos;ddate&apos;].label = &apos;日期&apos; 123456789class Diary(models.Model): user = models.ForeignKey(User,on_delete=models.CASCADE) budget = models.FloatField(default=0) weight = models.FloatField(default=0) note = models.TextField() ddate = models.DateField() def __str__(self): return &apos;&#123;&#125;&#123;&#125;&apos;.format(self.ddate,self.user) 123user = User.objects.get(username = username) //DiaryFrom中没有user,通过Django的ORM取出diary= models.Diary(user=user)post_form = forms.DiaryForm(request.POST,instance=diary) //把所有信息合并 建立django-registration所需的模板: 模板或文件名 用途说明 registration_form.html 显示注册窗体的页面,默认使用form变量作为窗体各字段的内容 registration_complete.html 填写完注册窗体,单击’提交’按钮后显示的信息页面 activation_complete.html 当账号顺利完成启用时会显示的页面 activate.html 当账号顺利启用失败时会显示的页面 activation_email.txt 在发送启用邮件时使用的邮件内容 activation_email_subject.txt 在发送启用邮件时使用的邮件主题 Markdown 使用命令 pip install markdown 安装 将 Markdown 格式的文本渲染成 HTML 文本: 12345678910111213blog/views.pyimport markdownfrom django.shortcuts import render, get_object_or_404from .models import Postdef detail(request, pk): post = get_object_or_404(Post, pk=pk) # 记得在顶部引入 markdown 模块 post.body = markdown.markdown(post.body, extensions=[ &apos;markdown.extensions.extra&apos;, &apos;markdown.extensions.codehilite&apos;,#语法高亮拓展 &apos;markdown.extensions.toc&apos;, #自动生成目录 ]) return render(request, &apos;blog/detail.html&apos;, context=&#123;&apos;post&apos;: post&#125;) ​ Django 出于安全方面的考虑，任何的 HTML 代码在 Django 的模板中都会被转义（即显示原始的 HTML 代码，而不是经浏览器渲染后的格式）。为了解除转义，只需在模板标签使用 safe 过滤器即可，告诉 Django，这段文本是安全的，你什么也不用做。 代码高亮 pip install Pygments 安装 Pygments 的工作原理是把代码切分成一个个单词，然后为这些单词添加 css 样式，不同的词应用不同的样式，这样就实现了代码颜色的区分，即高亮了语法。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Django","slug":"Django","permalink":"https://nymrli.top/tags/Django/"}]},{"title":"网络宽带和网络延迟","slug":"网络宽带和网络延迟","date":"2018-10-24T08:42:27.000Z","updated":"2020-11-28T13:41:22.813Z","comments":true,"path":"2018/10/24/网络宽带和网络延迟/","link":"","permalink":"https://nymrli.top/2018/10/24/网络宽带和网络延迟/","excerpt":"","text":"网络宽带和网络延迟 网络带宽，网络延迟是2个概念（网络延迟往往更容易被忽略！） 国内大陆 建立在互联网基础上 很多对延迟性要求比较高的应用，体验效果都不如人意。比如高清晰度网络电视、在线视频语音实时业务（qq、skype） 某些在线游戏 等等。 最简单的例子：如果ping某个网站，高于50ms的网站，打开就慢。10-30ms的网站，打开就比较快。 如果都是同一个宽带服务商，即使升级到10M 20M 100M的宽带，这种网络延迟情况，短时间内应该也不会有改善 1、“下载电影这种活儿就看带宽，不在乎服务器发出数据后晚几秒钟收到，传输层有“窗口协议”，不必等到上一段数据的应答再传下一段数据，可以看做是一种“异步应用”。一般说，交互性的应用比较讲究低延迟，我用“同步应用”来描述之。同步应用别说晚几秒钟，就是晚0.1秒收到数据，影响也很大,如 a、比如fps游戏会觉得很不爽，明明瞄准了怎么打不到。 b、至于视频语音等，对带宽、延迟都有一定要求，带宽太小无法传输清晰的图像和声音，延迟太大你一句话“我爱你”，对方的mm没有任何反应…… 另外还有一个指标是抖动，通俗说是数据能不能平稳传输，还是一会儿快一会儿慢一会儿堵塞。” 2、理论上说，带宽越大，在网络拓扑中的优先级就越高，所对应的响应速度就越快，对于用户和ISP之间来说带宽越高，每秒传输的数据越多，延迟就越小。但是延迟高低是由很多个因素决定的，网络上的每一个服务器（路由器）都是一个节点，所有的节点加在一起的响应速度，才是你的网络延迟，如果某一中间节点出现出题，无法提供服务，其它节点就会重新计算路由，但是重新计算路由之前会有一个超时记时器，只有目的节点的响应时间超出记时器时才会重新进行路由计算。还有DNS服务器的影响等等， 所以把网络带宽和网络延迟扯在一起谈是没用的，ISP只能保证你的接入网络带宽和网络延迟无问题，与其它节点的服务就没法保证了。（世界上最远的距离不是天涯和海角，而是电信和网通）” 3、“任何FPS游戏，网络条件是最关键的——到服务器的ping稳定性和延迟时间，对战绩的影响最大。 比如ping服务器5分钟，延迟ms数一直不变，或者误差不超过5%，随便什么FPS，哪怕你从没玩过没有经验不熟悉地图和武器，你的成绩也差不了。 如果这ms数比多数人还少，那你更屌了。 ADSL线路分交织模式interleave和快速模式fast,区别在于交织模式在本地会对数据包进行纠错加密，因此可保证线路的稳定，当然相应的延迟就会上升，电信提供的线路默认也都是交织模式，于是有种减低延迟的方法就是让电信帮你线路改成FAST,当然随之而来的问题是可能导致线路的不稳定，尤其是家里离接入网机房比较远的情况。 延迟这个问题只要是网络都会存在,差别在于大小,标志着整个架构的合理性和完善性。可以简单的认为带宽相当于马路上的车道数量，延迟就相当于堵塞的程度。因此，营运商即使是相同带宽的情况下对延迟不同的线路收费也是不同的。当然一般家庭用户是不会享受这个的。 ADSL ADSL（Asymmetric Digital Subscriber Loop）技术是一种不对称数字用户线实现宽带接入互连网的技术。 实际传输速度也要分上行和下行，上行速率就是发送出去数据的速度(上传速度)，下行就是收到数据的速度(下载速度). 总结 带宽代表一定时间内能运多少货。 延迟代表货物运输时间。 比如万吨轮就是属于大带宽，高延迟。 私人飞机属于低延迟，小带宽。 比如都给一个月的时间，万吨轮拉的东西肯定比私人飞机多,如果土豪做生意，血汗工厂t恤运去去美国，肯定用轮船，对带宽敏感，对延迟不敏感的业务。 但是如果土豪要移植肾了，这玩意路上放久会臭，就属于对延迟比较敏感的应用，还是用私人飞机运比较好。","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"linux下apt-get介绍","slug":"linux下apt-get介绍","date":"2018-10-24T08:42:20.000Z","updated":"2019-09-15T08:07:30.958Z","comments":true,"path":"2018/10/24/linux下apt-get介绍/","link":"","permalink":"https://nymrli.top/2018/10/24/linux下apt-get介绍/","excerpt":"","text":"apt-get Advanced Package Tool又名apt-get，是一条linux命令，适用于deb包管理式的操作系统如Unix和Linux系统的应用程序管理器，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。 rpm包和deb包是两种Linux系统下最常见的安装包格式，在安装一些软件或服务的时候免不了要和它们打交道。rpm包主要应用在RedHat系列包括 Fedora等发行版的Linux系统上，deb包主要应用于Debian系列包括现在比较流行的Ubuntu等发行版上。 我们知道如果要安装现成的这两种包的话，安装rpm包的命令是“rpm -参数”，安装deb包的命令是“dpkg -参数”。而Linux系统很方便和人性化的一点就是很多软件或服务根本就不用我们去下载，直接使用相应的命令就可以管理了，可能这就是传说中的 “云”的概念。 yum可以用于运作rpm包，例如在Fedora系统上对某个软件的管理： 安装：yum install &lt;package_name&gt; 卸载：yum remove &lt;package_name&gt; 更新：yum update &lt;package_name&gt; apt-get可以用于运作deb包，例如在Ubuntu系统上对某个软件的管理： 安装：apt-get install &lt;package_name&gt; 卸载：apt-get remove &lt;package_name&gt; 更新：apt-get update &lt;package_name&gt; ▲.apt-get命令一般需要root权限执行，所以一般跟着sudo命令。 12345678910111213apt-get update#1、apt-get update是同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。#2、apt-get update只是更新了apt的资源列表，没有真正的对系统执行更新。如果需要，要使用apt-get upgrade来更新。apt-get upgrade#可以使用这条命令更新软件包，apt-get upgrade不仅可以从相同版本号的发布版中更新软件包，也可以从新版本号的发布版中更新软件包，尽管实现后一种更新的推荐命令为apt-get dist-upgrade(将系统升级到新版本)。#总结:▲ apt-get update 是更新本地软件列表，在线安装的时候可以在软件列表找到软件； apt-get upgrade 是更新本地已安装的软件，要谨慎执行。 #dpkg -l#列出所有已安装的软件包。 在Ubuntu中，有时候运用sudo apt-get install 安装软件时，会出现一下的情况 E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 主要是因为apt还在运行,解决方案是 1.找到并且杀掉所有的apt-get 和apt进程 123456ps -A | grep apt找出所有的 apt 以及 apt-get 进程$ sudo kill -9 processnumber 或者$ sudo kill -SIGKILL processnumber比如，下面命令中的9是 SIGKILL 的信号数，它会杀掉第一个 apt 进程$ sudo kill -9 进程ID 或者$ sudo kill -SIGKILL 进程ID 2、删除锁定文件 锁定的文件会阻止 Linux 系统中某些文件或者数据的访问，这个概念也存在于 Windows 或者其他的操作系统中。 一旦你运行了 apt-get 或者 apt 命令，锁定文件将会创建于 /var/lib/apt/lists/、/var/lib/dpkg/、/var/cache/apt/archives/ 中。 这有助于运行中的 apt-get或者 apt 进程能够避免被其它需要使用相同文件的用户或者系统进程所打断。当该进程执行完毕后，锁定文件将会删除。 当你没有看到 apt-get或者 apt 进程的情况下在上面两个不同的文件夹中看到了锁定文件，这是因为进程由于某个原因被杀掉了，因此你需要删除锁定文件来避免该错误。 123456789101112#首先运行下面的命令来移除 /var/lib/dpkg/ 文件夹下的锁定文件：$ sudo rm /var/lib/dpkg/lock#之后像下面这样强制重新配置软件包：$ sudo dpkg --configure -a#也可以删除 /var/lib/apt/lists/ 以及缓存文件夹下的锁定文件：$ sudo rm /var/lib/apt/lists/lock$ sudo rm /var/cache/apt/archives/lock#接下来，更新你的软件包源列表：$ sudo apt update 或者 $ sudo apt-get update","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"python中关于round函数的注意事项","slug":"python中关于round函数的注意事项","date":"2018-10-18T03:37:00.000Z","updated":"2019-09-15T08:07:30.980Z","comments":true,"path":"2018/10/18/python中关于round函数的注意事项/","link":"","permalink":"https://nymrli.top/2018/10/18/python中关于round函数的注意事项/","excerpt":"","text":"python中关于round函数的注意事项 round函数很简单，对浮点数进行近似取值，保留几位小数。 比如: 12345&gt;&gt;&gt; round(10.0/3, 2)3.33&gt;&gt;&gt; round(20/7)3#第一个参数是一个浮点数，第二个参数是保留的小数位数，可选，如果不写的话默认保留到整数。 12345678910#[round]函数文档-py3def round(number, ndigits=None): # real signature unknown; restored from __doc__ \"\"\" round(number[, ndigits]) -&gt; number Round a number to a given precision in decimal digits (default 0 digits). This returns an int when called with one argument, otherwise the same type as the number. ndigits may be negative. \"\"\" return 0 翻译一下什么意思呢?: 将数字四舍五入到给定精度,如果不给第二个精度参数的话就默认保留到0位(即整数) 这么简单的函数，能有什么坑呢？ 1、round的结果跟python版本有关 1234567#-------python2---------&gt;&gt;&gt; round(0.5)1.0#======python3==========&gt;&gt;&gt; round(0.5)0 原因在于: 在python2.7的doc中，round()的最后写着，“Values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done away from 0.” 保留值将保留到离上一位更近的一端（四舍六入），如果距离两端一样远，则保留到离0远的一边。所以round(0.5)会近似到1，而round(-0.5)会近似到-1。 但是到了python3.5的doc中，文档变成了“values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice.” 如果距离两边一样远，会保留到偶数的一边。比如round(0.5)和round(-0.5)都会保留到0，而round(1.5)会保留到2。 然而需要注意的是 2、特殊数字round出来的结果可能未必是想要的。 12&gt;&gt;&gt; round(2.675, 2)2.67 官方举例:python2和python3的doc 123NoteThe behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more information. 简单的说就是，round(2.675, 2) 的结果，不论我们从python2还是3来看，结果都应该是2.68的，结果它偏偏是2.67，为什么？这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串1和0后可能是无限位数的，机器已经做出了截断处理)。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离2.67要更近一点点，所以保留两位小数时就近似到了2.67。 例子2: 12&gt;&gt;&gt; round(123.45, 1)123.5 意思就是说计算机需要先将十进制123.45转换为二进制,这个过程会导致二进制的值比123.45略大(比如123.45000001之类的),那么自然就得到123.5这个值了. 以上。除非对精确度没什么要求，否则尽量避开用round()函数。近似计算我们还有其他的选择： 使用math模块中的一些函数，比如math.ceiling（天花板除法）。 python自带整除，python2中是/，3中是//，还有div函数。 字符串格式化可以做截断使用，例如 “%.2f” % value（保留两位小数并变成字符串……如果还想用浮点数请披上float()的外衣）。 当然，对浮点数精度要求如果很高的话，请用嘚瑟馍，不对不对，请用decimal模块。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"HDOJ Problem 1002 - A + B Problem II","slug":"HDOJ-Problem-1002-A-B-Problem-II","date":"2018-10-18T03:36:23.000Z","updated":"2019-09-15T08:07:30.941Z","comments":true,"path":"2018/10/18/HDOJ-Problem-1002-A-B-Problem-II/","link":"","permalink":"https://nymrli.top/2018/10/18/HDOJ-Problem-1002-A-B-Problem-II/","excerpt":"","text":"HDOJ Problem 1002 - A + B Problem II: 大数定理 Problem Description I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000. Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line is the an equation “A + B = Sum”, Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases. Sample Input 12321 2112233445566778899 998877665544332211 Sample Output 12345Case 1:1 + 2 = 3Case 2:112233445566778899 + 998877665544332211 = 1111111111111111110 解法一: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;char a[1000],b[1000];int aar[1001],bar[1001];int main()&#123; int alen,blen,maxlen; int time; cin &gt;&gt; time; for (int i=1;i&lt;=time;i++) &#123; cin &gt;&gt; a &gt;&gt; b; alen = strlen(a); blen = strlen(b); int tmp = 0; for (int j=alen-1;j&gt;=0;j--) aar[tmp++] = a[j]-'0'; tmp = 0; for (int j=blen-1;j&gt;=0;j--) bar[tmp++] = b[j]-'0'; //123 ==&gt; 321 为了保证之后便于计算 if ( alen &gt; blen)&#123; maxlen = alen; for(int j=blen;j&lt;alen;j++)&#123; //长度不同时,短的那个需要补零 bar[j] = 0; &#125; aar[alen] = 0; &#125; else if ( alen &lt; blen)&#123; maxlen = blen; for(int j=alen;j&lt;blen;j++) &#123; aar[j] = 0; &#125; bar[blen] = 0; &#125; else&#123; maxlen = alen; aar[maxlen]=0; bar[maxlen]=0; &#125; for (int j=0;j&lt;maxlen;j++)&#123; cout &lt;&lt; aar[j] &lt;&lt; '\\t'; cout &lt;&lt; bar[j] &lt;&lt;endl; aar[j] += bar[j]; if(aar[j] &gt;= 10)&#123;//如果当前位大于10则进一位 aar[j] -=10; aar[j+1] += 1; &#125; &#125;//将a+b的和保存在aar数组里 cout &lt;&lt; \"Case:\" &lt;&lt; i&lt;&lt; endl; cout &lt;&lt; a &lt;&lt; \" + \" &lt;&lt; b &lt;&lt; \" = \" ; if (aar[maxlen] == 0 ) //判断第一位是否为0,如果是的话就从第二位开始读,这个是逆序 for (int j=maxlen-1;j&gt;=0;j--) cout &lt;&lt; aar[j]; else for (int j=maxlen;j&gt;=0;j--) cout &lt;&lt; aar[j]; if(i != time) //注意要求的输出格式 cout &lt;&lt; endl&lt;&lt; endl; else cout &lt;&lt; endl; &#125; return 0;&#125; 解法二: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;using namespace std;int i,j,y,n,k,h,p,lena,lenb;int a[1000],b[1000],sum[1000],f[1000];int main()&#123; string a1,b1; cin&gt;&gt;n; for(y=1;y&lt;=n;y++) &#123; cin&gt;&gt;a1&gt;&gt;b1; lena=a1.length(); lenb=b1.length(); for(i=0;i&lt;1000;i++)&#123; a[i]=0;b[i]=0;f[i]=0;//f数组是记录a+b和 //这个补零是先全都设为0,再把不为0的填入 &#125; for(i=lena-1;i&gt;=0;i--) /*1234 ==&gt; 4321*/ a[lena-1-i]=a1[i]-'0'; //字符'9' - '0' 才是数字9 for(i=lenb-1;i&gt;=0;i--) b[lenb-1-i]=b1[i]-'0'; k=0; for(i=0;i&lt;lenb || i&lt;lena;i++)&#123; //i--&gt; max( lena , lenb ) h=a[i]+b[i]+k; //k是下一位是否进一 f[i]=h%10; //f[i]必然是0-9 k=h/10; //如果h大于10,则k=1,如果h小于10,则k=0 &#125; if(k!=0) //如果k=1,则最高位加一 f[i++]=k; cout&lt;&lt;\"Case \"&lt;&lt;y&lt;&lt;\":\"&lt;&lt;endl&lt;&lt; a1 &lt;&lt;\" + \"&lt;&lt; b1 &lt;&lt;\" = \"; p=0; for(j=i-1;j&gt;=0;j--)&#123; //将之前为了计算时的倒序,再反正过来 if(p==0 &amp;&amp; f[j]==0)&#123; //目的是去前导0,实则这步多余了 continue; //如果最高位是0的话i就不会++,如果是1的话,那么f[j]就不会是0,所以这步必然是进入else &#125; else&#123; p=1; cout&lt;&lt;f[j]; &#125; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; ▲总结: 1.为什么用字符数组==&gt;因为数字太大,long long也存储不下 2.用int数组记录每一位的数字,然后模拟手算 3.为什么倒置==&gt;因为为了让末尾对齐,方便计算&quot;个位对个位,十位对十位……&quot;","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"}]},{"title":"LeetCode 26. 删除排序数组中的重复项","slug":"LeetCode-26-删除排序数组中的重复项","date":"2018-10-18T03:35:36.000Z","updated":"2019-09-15T08:07:30.954Z","comments":true,"path":"2018/10/18/LeetCode-26-删除排序数组中的重复项/","link":"","permalink":"https://nymrli.top/2018/10/18/LeetCode-26-删除排序数组中的重复项/","excerpt":"","text":"LeetCode 26. 删除排序数组中的重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 方法：双指针法 算法 数组完成排序后，我们可以放置两个指针 i和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。 当我们遇到 nums[j] != nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。 1234567891011public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; 复杂度分析 时间复杂度：O(n)， 假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。 空间复杂度：O(1)。 Python实现: 1234567891011121314class Solution: def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) &lt;= 1: return len(nums) s = 0 for f in range(1, len(nums)): if nums[s] != nums[f]: s += 1 nums[s] = nums[f] return s + 1","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"}]},{"title":"素数判别","slug":"素数判别","date":"2018-10-15T14:30:55.000Z","updated":"2019-12-04T13:13:27.198Z","comments":true,"path":"2018/10/15/素数判别/","link":"","permalink":"https://nymrli.top/2018/10/15/素数判别/","excerpt":"","text":"素数判别 由于1既不是素数也不是合数，所以下面暂未判断。如果需要则需特判如if (num == 1) return false; 方法一 123456789bool isPrime_2( int num )&#123; int tmp =sqrt( num); for(int i= 2;i &lt;=tmp; i++) if(num %i== 0) return 0 ; return 1 ;&#125;//一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n)。若sqrt(n)左侧找不到约数，那么右侧也一定找不到约数 方法二(筛选法) 123456789101112131415161718192021222324252627282930#include\"cstdio\"#include\"cstring\"using namespace std;#define MAX 100000//求MAX范围内的素数long long su[MAX],cnt;bool isprime[MAX];void prime()&#123; cnt=1; memset(isprime,1,sizeof(isprime));//初始化认为所有数都为素数 isprime[0]=isprime[1]=0;//0和1不是素数 for(long long i=2;i&lt;=MAX;i++) &#123; if(isprime[i])//保存素数 &#123; su[cnt++]=i; &#125; for(long long j=i*2;j&lt;=MAX;j+=i)//素数的倍数都为合数 &#123; isprime[j]=0; &#125; &#125;&#125;int main()&#123; prime(); for(long long i=1;i&lt;cnt;i++) printf(\"%d \",su[i]); return 0;&#125; 方法三(剪枝) 证明：令x≥1，将大于等于5的自然数表示如下： ······ 6x-1，6x，6x+1，6x+2，6x+3，6x+4 | 6x+5，6(x+1），6(x+1)+1 ······ 可以看到，不在6的倍数两侧，即6x两侧的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。这里有个题外话，关于孪生素数，有兴趣的道友可以再另行了解一下，由于与我们主题无关，暂且跳过。这里要注意的一点是，在6的倍数相邻两侧并不是一定就是质数。===&gt;只需判断6两侧的是不是质数(6x-1、6x+1) 此时判断质数可以6个为单元快进，即将方法（2）循环中i++步长加大为6，加快判断速度，原因是，假如要判定的数为n，则n必定是6x-1或6x+1的形式，对于循环中6i-1，6i，6i+1,6i+2，6i+3，6i+4，其中如果n能被6i，6i+2，6i+4整除，则n至少得是一个偶数，但是6x-1或6x+1的形式明显是一个奇数，故不成立；另外，如果n能被6i+3整除，则n至少能被3整除，但是6x能被3整除，故6x-1或6x+1（即n）不可能被3整除，故不成立。===&gt;综上，循环中只需要考虑6i-1和6i+1的情况(被本身更小的因数所除如22/11)，即循环的步长可以定为6，每次判断循环变量k和k+2的情况即可，理论上讲整体速度应该会是方法（2）的3倍。代码如下： 12345678910111213141516bool isPrime_3( int num )&#123; //两个较小数另外处理 if(num ==2|| num==3 ) return 1 ; //不在6的倍数两侧的一定不是质数 if(num %6!= 1&amp;&amp;num %6!= 5) return 0 ; int tmp =sqrt( num); //在6的倍数两侧的也可能不是质数 for(int i= 5;i &lt;=tmp; i+=6 ) if(num %i== 0||num %(i+ 2)==0 ) return 0 ; //排除所有，剩余的是质数 return 1 ;&#125; for循环i从5开始而不是从7开始的原因: 从5、7开始的区别在于i &lt;= sqrt(num)…如果是5的话，判断条件为25；如果是7的话，判断的条件就为49。 而仔细观察49内的所有质数，发现25之前的质数都是6k左右的数(6k-1,6k+1)，而25以后，就不定都有了。如26则不为质数。 所以如果从5开始的话，那么25以内的数 都不会进入for循环，经过if(num %6!= 1&amp;&amp;num %6!= 5)的筛选后，就都是素数了。 而如果是从7开始，那么25-49之内的数不符合条件却不会进入for循环，所以26缺少这个for的循环判断后就被误判为素数了。 ==&gt;以我浅薄的数学见识理解，25以内素数规律的巧合性使得 这些数不需要进入for循环判断，所以相比于从7开始的错误，5开始是正确的 给出Py代码 12345678910import mathdef prime_num(num): if num == 2 or num == 3: return 1 if num%6 != 1 and num%6!=5: return 0 for i in range(5,math.ceil(math.sqrt(num))+1,6): #就剩6k-1 和 6k+1 if num%i == 0 or num%(i-2)==0: return 0 return 1 参考:https://blog.csdn.net/huang_miao_xin/article/details/51331710","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"}]},{"title":"\\r - \\n - \\r\\n的区别","slug":"回车和换行区别","date":"2018-10-13T12:33:33.000Z","updated":"2019-09-15T08:07:31.041Z","comments":true,"path":"2018/10/13/回车和换行区别/","link":"","permalink":"https://nymrli.top/2018/10/13/回车和换行区别/","excerpt":"","text":"\\r - \\n - \\r\\n 的区别 代码演示: 123456781: string s1 = \"已经习惯了回车和换行一次搞定\\n，敲一个回车键，即是回\";2: 3: Console.WriteLine(s1);4: s1 = \"已经习惯了回车和换行一次搞定\\r，敲一个回车键，即是回\";5: Console.WriteLine(s1);6: s1 = \"已经习惯了回车和换行一次搞定\\r\\n，敲一个回车键，即是回\";7: Console.WriteLine(s1);8: Console.ReadLine(); Result:==&gt; 回车、换行的区别: \\r , \\n, \\r\\n的区别其实是回车与换行的区别 符号 ASCII码 意义 \\n 10 换行 \\r 13 回车CR 先来段历史 回车”（Carriage Return）和“换行”（Line Feed）这两个概念的来历和区别。 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33，Linux/Unix下的tty概念也来自于此）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 在Windows中： ‘\\r’ 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖； ‘\\n’ 换行，换到当前位置的下一行，而不会回到行首； Unix系统里，每行结尾只有“&lt;换行&gt;”，即&quot;\\n&quot;；Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“\\r\\n”；Mac系统里，每行结尾是“&lt;回车&gt;”，即&quot;\\r&quot;；。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 例 $ echo -en '12\\n34\\r56\\n\\r78\\r\\n' &gt; tmp.txt ==&gt;Linux中遇到换行符(&quot;\\n&quot;)会进行回车+换行的操作，回车符反而只会作为控制字符(&quot;^M&quot;)显示，不发生回车的操作。而windows中要回车符+换行符(&quot;\\r\\n&quot;)才会回车+换行，缺少一个控制符或者顺序不对都不能正确的另起一行。 ▲注意点： 在解析文本或其他格式的文件内容时，常常要碰到判定回车换行的地方，这个时候就要注意既要判定&quot;*r*\\n&quot;又要判定&quot;\\n&quot;。 写程序时可能得到一行,将其进行trim掉’*r*’,这样能得到你所需要的string了。 拓展程序测试 123456789101112131415161718192021222324252627282930/*==========================程序二===============================*/#include &lt;stdio.h&gt;int main(void)&#123; int i; FILE *fp; if((fp=fopen(\"test.txt\",\"w\")) == NULL) &#123; fprintf(stderr,\"open file error\\n\"); return 1; &#125; for(i=0;i&lt;100;i++) fprintf(fp,\"test\\n\"); fclose(fp); return 0;&#125;/*==========================程序二===============================*/#include &lt;stdio.h&gt;int main(void)&#123; int i; FILE *fp; if((fp=fopen(\"test.bin\",\"wb\")) == NULL) &#123; fprintf(stderr,\"open file error\\n\"); return 1; &#125; for(i=0;i&lt;100;i++) fprintf(fp,\"test\\n\"); fclose(fp); return 0;&#125; ​ 程序一输出文件大小是600字节，程序二输出文件大小是500字节，用记事本打开程序一的输出没有什么问题，每行一个test，打开程序二的输出发现所有的test连成一行，test之间是一个黑色方框符号分隔。用UltraEdit-32以16进制编辑模式打开test.bin可以查看到黑色方框符号就是0A也就是\\n，打开test.txt则会发现换行是\\r\\n，这就是两个文件大小相差100字节的原因。Unix类系统用户打开windows中的文件就会遇到这种苦恼。 为什么会有这种区别呢？ ​ 毕竟是源自Unix系统，C语言中使用\\n表示换行，而在实际的文件中换行符号需要同操作系统一致，所以当我们在C中使用fopen打开一个文本文件时流实现了实际换行符与C中\\n之间的转换。在windows中当我们用fopen打开文本文件，然后从中读到\\r\\n时流会转换为\\n，而当我们往文件中写入\\n时流会转换为\\r\\n。程序一是打开文本文件，程序二打开的是二进制文件，因为流只对文本文件进行换行表示的转换，以二进制模式打开流不会做任何处理。所以当你以二进制模式打开一个文本文件时将产生错乱，你必须亲自将\\r\\n解释为\\n,同样的问题也会出现在以文本模式打开二进制文件的情况.这也解释了为什么Unix类系统中的文件不区分文本文件和二进制文件的原因。 当我们使用标准输入输出函数时有这种情况吗？ 再回到我们熟悉的标准输入输出stdin,stdout ​ C的控制台程序在加载进内存成为进程运行前C运行时库自动打开三个设备并关联到三个流：标准输入流stdin，标准输出流stdout，标准出错流stderr ​ 通常在通用计算机中，没有重定向前这三个流对应的设备是：键盘，显示器，显示器。这三个都是字符设备，所以是以文本文件的模式打开的，在windows下当我们在键盘上敲入回车键时产生字符\\r\\n，但是在OS内核把键盘驱动中读到的字符发送给流的缓冲区时流会将之转换为\\n，当我们向控制台输出\\n时流将之转换为\\r\\n再传递至内核，当我们绕过标准输入输出直接调用windows中coredll.lib进行控制台输入输出时就必须面对这一现实，程序员负责实现这一转换。 摘自:https://www.cnblogs.com/xiaotiannet/p/3510586.html","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"云服务器Ubuntu更改默认python版本","slug":"云服务器Ubuntu更改默认python版本","date":"2018-10-12T05:07:48.000Z","updated":"2019-09-15T08:07:31.023Z","comments":true,"path":"2018/10/12/云服务器Ubuntu更改默认python版本/","link":"","permalink":"https://nymrli.top/2018/10/12/云服务器Ubuntu更改默认python版本/","excerpt":"","text":"云服务器Ubuntu更改默认python版本 1、基于用户修改 Python 版本： 想要为某个特定用户修改 Python 版本，只需要在其 home 目录下创建一个 alias(别名) 即可。打开该用户的 ~/.bashrc文件，添加新的别名信息来修改默认使用的 Python 版本。 vim ~/.bashrc 增加一行alias python=python3和修改pip版本alias pip=pip3 source ~/.bashrc 再输入python --version,就能发现显示的是Python 3.x啦 2、 在系统级修改 Python 版本(建议) 12# update-alternatives --list pythonupdate-alternatives: error: no alternatives for python 如果出现以上所示的错误信息，则表示 Python 的替代版本尚未被 update-alternatives 命令识别。想解决这个问题，我们需要更新一下替代列表，将 python2.7 和 python3.4 放入其中。 12345$ update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1# update-alternatives: using /usr/bin/python2.7 to provide /usr/bin/python (python) in auto mode$ update-alternatives --install /usr/bin/python python /usr/bin/python3.4 2# update-alternatives: using /usr/bin/python3.4 to provide /usr/bin/python (python) in auto mode –install 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。这个例子中，我们为 /usr/bin/python3.4 设置的优先级为2，所以update-alternatives 命令会自动将它设置为默认 Python 版本。 1234# 接下来，我们再次列出可用的 Python 替代版本。# update-alternatives --list python/usr/bin/python2.7/usr/bin/python3.4","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"nginx+uwsi搭建django环境服务器","slug":"nginx+uwsi搭建django环境服务器","date":"2018-10-12T04:44:09.000Z","updated":"2021-11-25T15:30:50.707Z","comments":true,"path":"2018/10/12/nginx+uwsi搭建django环境服务器/","link":"","permalink":"https://nymrli.top/2018/10/12/nginx+uwsi搭建django环境服务器/","excerpt":"","text":"阿里云搭建服务器 更新源 12sudo apt-get updatesudo apt-get upgrade 安装nginx 1234sudo apt-get install nginxsudo /etc/init.d/nginx start # (start可以改成restart/stop)# 或是sudo service nginx start# 然后浏览器输入服务器IP,观察是否有welcom to nginx! 安装py3和virtualenv 12sudo apt-get install git python3 python3-pipsudo pip3 install virtualenv 修改python版本: 法一:(不建议) 123456789$ gedit ~/.bashrc #gedit .bash_aliases在顶部加入一行alias python=python3$ source ~/.bashrc #或是source ~/.bash_aliases o$ python --version就会发现是Python 3.5.2啦/*orOpen your .bashrc file nano ~/.bashrc. Type alias python=python3 on to a new line at the top of the file then save the file with ctrl+o and close the file with ctrl+x. Then, back at your command line type source ~/.bashrc. Now your alias should be permanent.*/ Ubuntu16.04切换python3和python2 ▲.切换Python3为默认版本：(建议) 12sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 切换Python2为默认版本： 1sudo update-alternatives --config python 安装虚拟环境 12$ cd /var/www$ sudo virtualenv env35 下载和配置网站 1234$ sudo git clone https://github.com/KyrieWang233/homework_submission-master.git$ source env35/bin/activate$ cd home...$ sudo pip3 install -r requirements.txt 123456$ sudo python manage.py collectstatic$ sudo python manage.py migrate$ python manage.py createsuperuser$ sudo vim settings.py将其中的ALLOWED_HOST=[*]改为自己的IP然后输入 python manage.py runserver 0.0.0.0:8000 安装、测试uwsgi 12$ sudo pip3 install uwsgi$ uwsgi --http :8000 --module homework_submission.wsgi 编辑/var/www下的uwsgi.ini 12345678910[uwsgi]chdir=/var/www/homework_submission-mastermodule=homework_submission.wsgihome=/var/www/env35master=Trueprocesses=10socket= :8001chmod socket=666vacuum=Truemax-requests=5000 编辑/var/www下的nginx.conf 12345678910111213141516upstream django&#123;server 127.0.0.1:8001;&#125;server &#123;listen 80;server_name sast.nymrli.top;charset utf-8;client_max_body_size 75M;location /static&#123;alias /var/www/homework_submission-master/static; &#125;location /&#123;uwsgi_pass django;include /var/www/uwsgi_params;&#125;&#125; 编辑/var/www下的uwsgi_params 12345678910111213141516uwsgi_param QUERY_STRING $query_string;uwsgi_param REQUEST_METHOD $request_method;uwsgi_param CONTENT_TYPE $content_type;uwsgi_param CONTENT_LENGTH $content_length; uwsgi_param REQUEST_URI $request_uri; uwsgi_param PATH_INFO $document_uri; uwsgi_param DOCUMENT_ROOT $document_root; uwsgi_param SERVER_PROTOCOL $server_protocol; uwsgi_param REQUEST_SCHEME $scheme; uwsgi_param HTTPS $https if_not_empty; uwsgi_param REMOTE_ADDR $remote_addr; uwsgi_param REMOTE_PORT $remote_port; uwsgi_param SERVER_PORT $server_port; uwsgi_param SERVER_NAME $server_name; 软连接 12345cd /etc/nginxcd sites-enabledrm defaultln -s /var/www/nginx.conf homework_submissionls 重启nginx /etc/init.d/nginx restart 运行uwsgi 12cd /var/wwwuwsgi --ini uwsgi.ini 让uwsgi自启动 vim /etc/rc.local(注意非虚拟环境也得安装uwsgi模块) 1234添加下面代码:/usr/local/bin/uwsgi --ini /var/www/uwsgi.iniexit 0 uwsgi的热启动 在uwsgi.ini中加入 py-autoreload=1 重启一下:killall -9 uwsgi、/usr/local/bin/uwsgi --ini /var/www/uwsgi.ini 总结 关于etc/ linit. d 如果你使用过inux系统,那么你一定听说过 init. d目录,这个目录到底是干嘛的呢?它归根结底只做了一件事情,但这件事情非同小可,是为整个系统做的,因此它非常重要。init.d目录包含许多系统各种服务的启动和停止脚本 关于 /etc/rc.local rc.local也是我经常使用的一个脚本,该脚本是在系统初始化级别脚本运行之后再执行的,因此可以安’, '地在里面添加你想在系统启动之后执行的脚本. 总结 Linux是灵活的,正因为它的灵活性,我们总是可以找到许多不同的办法来解决同一个问题，服务的例子就是一个很好的佐证,有了 /etc/init.d目录下的脚本,再加上 /etc/rc. local这个利器，你可以放心的确保你的服务可以完美的启动和运行","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"小程序开发遇到的坑","slug":"小程序开发遇到的坑","date":"2018-10-04T12:26:58.000Z","updated":"2019-09-15T08:07:31.050Z","comments":true,"path":"2018/10/04/小程序开发遇到的坑/","link":"","permalink":"https://nymrli.top/2018/10/04/小程序开发遇到的坑/","excerpt":"","text":"小程序开发遇到的坑 function 与 =&gt; 的区别 在JS中，箭头函数并不是简单的function(){}匿名函数的简写语法糖，实际上，箭头函数和匿名函数有个明显的区别：**箭头函数内部的this是词法作用域，在编写函数时就已经确定了。**而匿名函数的this指向运行时实际调用该方法的对象，无法在编写函数时确定。 箭头函数和普通函数的区别 不可以当做构造函数，也就是说，不可以使用 new 命令，否则会抛出错误。 this、arguments、caller等对象在函数体内都不存在。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 ==&gt;箭头函数除了传入的参数之外，其它的对象都没有！在箭头函数引用了this、arguments或者参数之外的变量，那它们一定不是箭头函数本身包含的，而是从父级作用域继承的。 代码实例: 123456789101112function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 setTimeout(function()&#123; console.log(this.num); // undefined &#125;, 500); &#125;;&#125;var obj = new Test();obj.func();//这里的方法里调用了setTimeout函数，该函数500毫秒后调用我们定义的函数时，实际上是window对象调用的，所以这时匿名函数的this是指向window而不是指向obj了。 在箭头函数出现之前一般都是这么写的： 12345678910111213141516171819202122232425function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 var that = this; //保存一份当前的this对象 setTimeout(function()&#123; console.log(that.num); // 100 &#125;, 500); &#125;;&#125;var obj = new Test();obj.func();//这是利用了闭包的概念。箭头函数可以看做这种方式的语法糖。//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 setTimeout(() =&gt; &#123; console.log(this.num); // 100 //箭头函数没有this,所以从上层父级继承 &#125;, 500); &#125;;&#125;var obj = new Test();obj.func(); ▲同时需要注意的是:this是指向当前的对象，随着上下文作用域的切换this的执行this的指向会发生改变，我们可以先保存一份this的值然后再使用：var that = this 生成带参数的二维码 123456789101112131415161718192021222324 onShow:function()&#123; var that = this; function get_code() &#123; wx.request(&#123; url: 'https://api.weixin.qq.com/cgi- bin/token?grant_type=client_credential&amp;appid=' + that.data.APP_ID + '&amp;secret=' + that.data.APP_SECRET, method: 'GET', success: function (res) &#123; // console.log(res.data.access_token); wx.request(&#123; data: &#123; 'path': \"pages/index\" &#125;, url: 'https://api.weixin.qq.com/wxa/getwxacode?access_token=' + res.data.access_token, method: 'POST', success: function (res) &#123; console.log(res.data);//2jin zhi &#125; &#125;) &#125; &#125;) &#125; get_code();&#125;//官方接口得到的是图片的二进制流 通过草料微信小程序生成二维码: 12345678910111213141516171819202122232425262728293031const app = getApp()Page(&#123; data: &#123; APP_ID: 'wx05818046869e4078', APP_SECRET: '5d4429375e84d6ab9476b643f8733af9', path: 'pages/index', photo:null, &#125;, onShow:function()&#123; var that = this; console.log(that.data.APP_ID + ' ' + that.data.APP_SECRET + ' ' + that.data.path) wx.request(&#123; url: 'https://cli.im/home/weapp/create', method:'POST', data:&#123; 'weapp_id': that.data.APP_ID,'weapp_secret': that.data.APP_SECRET,'weapp_url': that.data.path &#125;, header:&#123; 'content- type': 'application/x- www- form- urlencoded' &#125;, success:(res)=&gt;&#123; console.log(res.data.data) that.setData(&#123; photo: res.data.data &#125;) &#125; &#125;) &#125;&#125;) 组件的自定义数据属性: 123&lt;view bindtap=&quot;f0&quot; data- xxx- yyy=&apos;blabla&apos;&gt;&lt;/view&gt;//在点击触发事件f0的参数event中,dataset为自定义参数的字典,其中,键值为驼峰命名法.xxxYyy ▲.bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡 wx.requests是异步调用的 wx.requests这个api是不会阻塞的,什么时候收到response就什么时候调用回调函数(success…),如果在wx.requests方法调用后还有运行代码(1),则(1)比回调函数早执行 组件: 以某种方式对 业务逻辑和* *功能**的封装 特点:高内聚,可复用 视图组件 表单组件 媒体组件 画布组件 基础内容组件 导航组件 地图组件 开放能力组件 自定义组件: ​ 内容略 ES6新特性: js中let和var定义变量的区别 声明后未赋值，表现相同: 如果未在 let 、var 语句中初始化您的变量，则将自动为其分配 JavaScript 值 undefined 使用未声明的变量，表现不同: var有变量提升，let无变量提升 重复声明同一个变量时，表现不同： var重复声明时覆盖，let重复声明时报错 变量作用范围，表现不同： 使用 let 语句声明一个变量，该变量的范围限于声明它的块中。 ==&gt;代码演示: 123456789101112(function() &#123; var varTest = 'test var OK.'; let letTest = 'test let OK.'; &#123; var varTest = 'varTest changed.'; let letTest = 'letTest changed.'; &#125; console.log(varTest); //输出\"varTest changed.\"，内部\"&#123;&#125;\"中声明的varTest变量覆盖外部的letTest声明 console.log(letTest); //输出\"test let OK.\"，内部\"&#123;&#125;\"中声明的letTest和外部的letTest不是同一个变量&#125;());","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"带表头的单链表的基本操作","slug":"带表头的单链表的基本操作","date":"2018-09-27T14:12:17.000Z","updated":"2019-09-15T08:07:31.057Z","comments":true,"path":"2018/09/27/带表头的单链表的基本操作/","link":"","permalink":"https://nymrli.top/2018/09/27/带表头的单链表的基本操作/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct Node&#123; ElemType elem; struct Node *link;&#125;Node;typedef struct &#123; struct Node* head; int n;&#125;Headlist;Status Init(Headlist *L)&#123; L-&gt;head = (Node*)malloc(sizeof(Node)); if(!L-&gt;head) return ERROR; L-&gt;head-&gt;link = NULL; L-&gt;n = 0; return OK;&#125;void Sort(Headlist *L)&#123; Node *p=L-&gt;head,*pre=NULL; Node *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;elem &lt; p-&gt;elem) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125;&#125;void deleleab(Headlist *L, int a,int b)&#123; Node *q = L-&gt;head,*p=L-&gt;head-&gt;link; // q为上一个,p为当前的 while( p ) if(p-&gt;elem &gt;= a &amp;&amp; p-&gt;elem &lt;= b) &#123; q-&gt;link = p-&gt;link; // 1 - 2 - 3 1==&gt;3,1的指针域指向3 free(p); //释放2 p = q-&gt;link; // 当前的指针变成3 &#125;else&#123; p = p-&gt;link; q = p-&gt;link; &#125; &#125;Status Converse(Headlist *L)&#123; Node *p = NULL,*cur= NULL; Node *q = L-&gt;head-&gt;link; if(L-&gt;head &amp;&amp; L-&gt;head-&gt;link)&#123; //如果表不存在或是为空,则return ERROR while( q != NULL ) //q按照原来的顺序依次遍历各结点 &#123; cur = q; //cur为当前结点 q = q-&gt;link; //q保存下一个结点 L-&gt;head-&gt;link = cur; //为了不动头结点,所以头结点link始终指向当前要加的结点 cur-&gt;link = p; //当前的link指向上一个结点 p = cur; //保存上一个结点 &#125; &#125;else return ERROR; return OK;&#125;Status Insert(Headlist *L,int j,ElemType x)&#123; Node *p=NULL,*q=NULL; int i; if(j&lt;-1 || j&gt; L-&gt; n-1) return ERROR; p = L-&gt;head; for(i=0;i&lt;=j;i++) p=p-&gt;link; q = (Node *)malloc(sizeof(Node)); q-&gt;elem = x; q-&gt;link = p-&gt;link; p-&gt;link = q; L-&gt;n++; return OK;&#125;Status Output(Headlist L)&#123; Node *p = L.head-&gt;link; if(!L.n) return ERROR; while(p)&#123; printf(\"%d \",p-&gt;elem ); p = p-&gt;link; &#125; return OK;&#125;Status Destory(Headlist *L)&#123; Node *p=NULL; while(L-&gt;head)&#123; //不断删除head所指向的内存,直到head被释放 p = L-&gt;head-&gt;link; free(L-&gt;head); L-&gt;head = p; &#125; return OK; &#125;Status Delete(Headlist *L,int j)&#123; //下标j Node *p = L-&gt;head,*q = L-&gt;head; // q = tmp int i; if(!L-&gt;n) return ERROR; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j-1;i++) p = p-&gt;link; q = p; p = p-&gt;link; q-&gt;link = p-&gt;link; free(p); return OK;&#125;Status Find(Headlist *L,int j,ElemType *x)&#123; Node *p= L-&gt;head; int i; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j;i++) p = p-&gt;link; *x = p-&gt;elem; return OK;&#125;int main()&#123; int x; Headlist list; Init(&amp;list); Insert(&amp;list,-1,3); Insert(&amp;list,0,2); Insert(&amp;list,-1,5); Insert(&amp;list,2,7); Insert(&amp;list,-1,1); printf(\"the linked list is :\"); Output(list); printf(\"\\nAfter sorted:\"); Sort(&amp;list); Output(list); printf(\"\\nAfter Conversed:\"); Converse(&amp;list); Output(list); printf(\"\\nAfter delete index of 0,the list is:\"); Delete(&amp;list,0); Output(list); Find(&amp;list,2,&amp;x); printf(\"\\nthe index of 2:%d\\n\",x); Destory(&amp;list); system(\"pause\"); return 0;&#125;//无论是什么都要略过head表头结点,表头结点的elem是任意的. (一)实验中遇到的主要问题及解决方法 1.题目二，带表头的单链表在插入时出现了点问题，书上给出的方法是错的，且是C++代码。于是在尝试理解他的想法及每步Debug中终于写出了正确的代码。（L-&gt;head-&gt;link = NULL,其中L-&gt;head-&gt;data 不填） 2.题目二中带表头节点的单链表中插入时for( j=0;j&lt;=i; j++) 和之前j&lt;i以及删除时for( j=0;j&lt;=i-1; j++) 和之前j&lt;i-1有很大不同,通过debug知道了是为了略过第一个表头节点。 3.逆置过程中,为了不动表头,略过第一个表头结点时出现了点麻烦.并且在第一个元素逆置后指向NULL,第二个结点指向第一个结点时没有想明白,后来才想到了先让P=NULL,然后记录上一个结点就能达到效果了.同时还有个问题是一直没有保存原来链表的顺序,再因为P=NULL导致会访问到非法内存而程序崩溃 （二）实验心得 2.题目二中,带表头单链表和不带表头单链表,在删除和插入时的循环条件不同要注意.及初始化时带表头的L-&gt;head-&gt;link= NULL; 与 无表头的 L-&gt;first = NULL;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"带表头的单链表应用——多项式","slug":"带表头的单链表应用——多项式","date":"2018-09-27T14:04:31.000Z","updated":"2019-09-15T08:07:31.054Z","comments":true,"path":"2018/09/27/带表头的单链表应用——多项式/","link":"","permalink":"https://nymrli.top/2018/09/27/带表头的单链表应用——多项式/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct PNode&#123; ElemType ceof; ElemType exp; struct PNode *link;&#125;PNode;typedef struct &#123; struct PNode *head;&#125;polynominal;Status Init(polynominal *p)&#123; p-&gt;head = (PNode *)malloc(sizeof(PNode)); p-&gt;head-&gt;exp = -1; p-&gt;head-&gt;link = NULL; return OK;&#125;Status Create(polynominal *p)&#123; PNode *pn = NULL,*q=NULL,*pre=NULL; Init(p); //p-&gt;head = (PNode *)malloc(sizeof(PNode)); //p-&gt;head-&gt;exp = -1; //p-&gt;head-&gt;link = NULL; for (;;) // &lt;==&gt;while(1) &#123; pn = (PNode *)malloc(sizeof(PNode)); printf(\"ceof:\\n\"); scanf(\"%d\",&amp;pn-&gt;ceof); printf(\"exp:\\n\"); scanf(\"%d\",&amp;pn-&gt;exp); if (pn-&gt;exp &lt; 0) &#123;printf(\"End the input\\n\"); break;&#125; pre = p-&gt;head; //pre从链表头开始 q=p-&gt;head-&gt;link; while(q &amp;&amp; q-&gt;exp &gt; pn-&gt;exp)&#123; //pn为当前结点,q为链表中结点 pre = q; // q = q-&gt;link; &#125; pn-&gt;link = q; // 在pre和q之间插入pn,(q为null时,相当于末尾插入pn) pre-&gt;link = pn; // pre =&gt; pn =&gt; q &#125; return OK;&#125;Status Sort(polynominal *L)&#123; //从大到小 PNode *p=L-&gt;head,*pre=NULL; PNode *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;exp &lt; p-&gt;exp) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125; return OK;&#125;Status Add(polynominal *px,polynominal *qx)&#123; //目的:将q改成p+q PNode *q1=qx-&gt;head, *p=px-&gt;head-&gt;link; //q1指向qx表头结点 PNode *q=q1-&gt;link; //p指向多项式px第一个结点,q指向qx第一个 PNode *temp = NULL; //q1是q前驱 while( q &amp;&amp; p)&#123; while( p-&gt;exp &lt; q-&gt;exp )&#123; //找到qx中 大于等于q指数项的项,q不断右移 q1 = q; q = q-&gt;link; &#125; if (p-&gt;exp == q-&gt;exp )&#123; q-&gt;ceof = q-&gt;ceof + p-&gt;ceof; if (q-&gt;ceof == 0)&#123; q1-&gt;link = q-&gt;link; //释放当前q的内存 free(q); q = q1-&gt;link; p = p-&gt;link; &#125;else&#123; //p\\q都右移 q1 = q; //q1 q = q-&gt;link; p = p-&gt;link; &#125; &#125;else&#123; //p-&gt;exp &gt; q-&gt;exp temp = (PNode * )malloc(sizeof(PNode)); temp-&gt;ceof = p-&gt;ceof; temp-&gt;exp = p-&gt;exp; temp-&gt;link = q1-&gt;link; q1-&gt;link = temp; p = p-&gt;link; &#125; &#125; return OK;&#125;void Output(polynominal *p)&#123; PNode *q = p-&gt;head-&gt;link; int last = 0; while( q!=NULL )&#123; if(q-&gt;link == NULL) last =1; printf(\"%dx^%d\", q-&gt;ceof,q-&gt;exp); if(!last) printf(\"+\"); //此处注意个+的小细节 q = q-&gt;link; &#125; printf(\"\\n\");&#125;void Destory(polynominal *p)&#123; PNode *q = NULL; while(p-&gt;head)&#123; //不断删除head所指向的内存,直到head被释放 q = p-&gt;head-&gt;link; free(p-&gt;head); p-&gt;head = q; &#125;&#125;/***********合并同类项*****************//***********合并即free*****************/Status unify(polynominal *t)&#123; PNode *p=NULL; PNode *q=NULL; PNode *last=NULL; PNode *tmp; //while(p-&gt;link != NULL)&#123; for(p=t-&gt;head-&gt;link;p!=NULL;p=p-&gt;link)&#123; //选择 last = p; for(q=last-&gt;link; q!=NULL ; )&#123; //q指针向后推移指向下一结点 if(q-&gt;exp == p-&gt;exp)&#123; //相等计算 p-&gt;ceof += q-&gt;ceof; //q为 滑动项 tmp = q-&gt;link; last-&gt;link = q-&gt;link; //last保存上一个q free(q); // 吧q的空间释放掉 q= tmp; &#125;else&#123; last= q; q=q-&gt;link;&#125; //如果不相等就判断下一个 &#125; &#125; return OK;&#125;polynominal Multiply(polynominal *px,polynominal *qx)&#123; PNode *p = px-&gt;head; PNode *q = qx-&gt;head; PNode *x = NULL; PNode *tmp = NULL; polynominal newpoly; Init(&amp;newpoly); x = newpoly.head; for (p=px-&gt;head-&gt;link; p!=NULL; p=p-&gt;link)&#123; for (q=qx-&gt;head-&gt;link; q!=NULL; q=q-&gt;link)&#123; tmp = (PNode*)malloc(sizeof(PNode)); tmp-&gt;ceof = p-&gt;ceof * q-&gt;ceof; tmp-&gt;exp = p-&gt;exp + q-&gt;exp; tmp-&gt;link = x-&gt;link; //新生成的结点指向上一个生成的结点的地址 x-&gt;link = tmp; //使链表记录当前tmp结点 x = x-&gt;link; //取下一个结点 &#125; &#125; unify(&amp;newpoly); Sort(&amp;newpoly); return newpoly;&#125;int main()&#123; polynominal p,q; polynominal mul; Create(&amp;p); Output(&amp;p); // printf(\"After unify:\\n\"); Unify // unify(&amp;p); // Output(p); Create(&amp;q); Output(&amp;q); // Add(&amp;p,&amp;q); ADD // printf(\"q:\"); // Output(q); printf(\"After Multiplied:\\n\"); mul = Multiply(&amp;p,&amp;q); Output(&amp;mul); system(\"pause\"); return 0;&#125;//其中Sort,unify,add,multiply,需要捉摸一下 (一)实验中遇到的主要问题及解决方法 1.题目二，带表头的单链表在插入时出现了点问题，书上给出的方法是错的，且是C++代码。于是在尝试理解他的想法及每步Debug中终于写出了正确的代码。（L-&gt;head-&gt;link = NULL,其中L-&gt;head-&gt;data 不填） 2.题目二中带表头节点的单链表中插入时for( j=0;j&lt;=i; j++) 和之前j&lt;i以及删除时for( j=0;j&lt;=i-1; j++) 和之前j&lt;i-1有很大不同,通过debug知道了是为了略过第一个表头节点。 3.逆置过程中,为了不动表头,略过第一个表头结点时出现了点麻烦.并且在第一个元素逆置后指向NULL,第二个结点指向第一个结点时没有想明白,后来才想到了先让P=NULL,然后记录上一个结点就能达到效果了.同时还有个问题是一直没有保存原来链表的顺序,再因为P=NULL导致会访问到非法内存而程序崩溃 4.合并同类项的过程中,使用了选择排序类似的思想,但是在里层for(q=last-&gt;link; q!=NULL ; )出了问题,一开始写成 for(q=last-&gt;link; q!=NULL ; q=q-&gt;link)但是如果指数相等,q就会被free掉,此时q=q-&gt;link就会出问题 （二）实验心得 1.题目一中，顺序表是malloc动态申请的空间，是连续的，可以直接通过下标访问。 2.题目二中,带表头单链表和不带表头单链表,在删除和插入时的循环条件不同要注意.及初始化时带表头的L-&gt;head-&gt;link = NULL; 与 无表头的 L-&gt;first = NULL; 3.Debug过程中F10和F11的区别,在malloc和free处按F11会进入malloc函数、free函数的汇编的运行过程 4.排序和逆置时都要有个指针记住原来链表的顺序,然后才能再依次按顺序进行. 5.理清要做的事,再下手写代码,画图有时很重要.","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"小程序蓝牙","slug":"小程序蓝牙API","date":"2018-09-20T02:57:01.000Z","updated":"2019-09-15T08:07:31.053Z","comments":true,"path":"2018/09/20/小程序蓝牙API/","link":"","permalink":"https://nymrli.top/2018/09/20/小程序蓝牙API/","excerpt":"","text":"提供蓝牙模块API wx.openBluetoothAdapter(OBJECT) ​ 初始化小程序蓝牙模块 wx.closeBluetoothAdapter(OBJECT) ​ 关闭蓝牙模块，使其进入未初始化状态。 wx.getBluetoothAdapterState(OBJECT) ​ 获取本机蓝牙适配器状态 wx.onBluetoothAdapterStateChange(CALLBACK) ​ 监听蓝牙适配器状态变化事件 wx.startBluetoothDevicesDiscovery(OBJECT) ​ 开始搜寻附近的蓝牙外围设备。注意，该操作比较耗费系统资源，请在搜索并连接到设备后调用 stop 方法停止搜索。 wx.stopBluetoothDevicesDiscovery(OBJECT) ​ 停止搜寻附近的蓝牙外围设备。若已经找到需要的蓝牙设备并不需要继续搜索时，建议调用该接口停止蓝牙搜索。 wx.getBluetoothDevices(OBJECT) ​ 获取在小程序蓝牙模块生效期间所有已发现的蓝牙设备，包括已经和本机处于连接状态的设备。 wx.onBluetoothDeviceFound(CALLBACK) ​ 监听寻找到新设备的事件 wx.createBLEConnection(OBJECT) ​ 连接低功耗蓝牙设备。 wx.closeBLEConnection(OBJECT) ​ 断开与低功耗蓝牙设备的连接 wx.getBLEDeviceServices(OBJECT) ​ 获取蓝牙设备所有 service（服务） wx.getBLEDeviceCharacteristics(OBJECT) ​ 获取蓝牙设备某个服务中的所有 characteristic（特征值） wx.readBLECharacteristicValue(OBJECT) ​ 读取低功耗蓝牙设备的特征值的二进制数据值。注意：必须设备的特征值支持read才可以成功调用，具体参照 characteristic 的 properties 属性 wx.writeBLECharacteristicValue(OBJECT) ​ 向低功耗蓝牙设备特征值中写入二进制数据。注意：必须设备的特征值支持write才可以成功调用，具体参照 characteristic 的 properties 属性 tips: 并行调用多次读写接口存在读写失败的可能性* wx.notifyBLECharacteristicValueChange(OBJECT) ​ 启用低功耗蓝牙设备特征值变化时的 notify 功能，订阅特征值。注意：必须设备的特征值支持notify或者indicate才可以成功调用，具体参照 characteristic 的 properties 属性 ​ 另外，必须先启用notify才能监听到设备 characteristicValueChange 事件 wx.onBLEConnectionStateChange(CALLBACK) ​ 监听低功耗蓝牙连接状态的改变事件，包括开发者主动连接或断开连接，设备丢失，连接异常断开等等 wx.onBLECharacteristicValueChange(CALLBACK) ​ 监听低功耗蓝牙设备的特征值变化。必须先启用notify接口才能接收到设备推送的notification。 示例代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// pages/bluetooth/bluetooth.jsPage(&#123; data:&#123;&#125;, onLoad:function(options)&#123; // 页面初始化 options为页面跳转所带来的参数 &#125;, //初始化蓝牙适配器 openBluetooth:function()&#123; wx.openBluetoothAdapter(&#123; success: function(res)&#123; console.log(res.errMsg) // success wx.showToast(&#123; title:\"初始化蓝牙适配器成功\", duration:2000 &#125;) &#125;, &#125;) &#125;,//关闭蓝牙模块closeBluetooth:function()&#123; wx.openBluetoothAdapter() wx.closeBluetoothAdapter(&#123; success: function(res)&#123; // success console.log(\"success\"+res) &#125; &#125;)&#125;,//获取本机蓝牙适配器状态getBluetoothAdapterState:function()&#123;wx.getBluetoothAdapterState(&#123; success: function(res)&#123; // success console.log(\"res:\"+res) console.log(\"errMsg:\"+res.errMsg) &#125;&#125;)&#125;,//监听蓝牙适配器状态变化事件 onBluetoothAdapterStateChange:function()&#123; wx.onBluetoothAdapterStateChange(function(res) &#123; console.log(`adapterState changed, now is`, res) &#125;)&#125;, // 开始搜寻附近的蓝牙外围设备 startBluetoothDevicesDiscovery:function()&#123; wx.startBluetoothDevicesDiscovery(&#123; success: function (res) &#123; console.log(res) &#125; &#125;)&#125;, // 停止搜寻附近的蓝牙外围设备 stopBluetoothDevicesDiscovery:function()&#123; wx.stopBluetoothDevicesDiscovery(&#123; success: function (res) &#123; console.log(res) &#125; &#125;)&#125;, //获取所有已发现的蓝牙设备 getBluetoothDevices:function()&#123; wx.getBluetoothDevices(&#123; success: function(res)&#123; // success console.log(res) &#125;, &#125;) &#125;, //监听寻找到新设备的事件 onBluetoothDeviceFound:function()&#123; wx.onBluetoothDeviceFound(function(res) &#123; // callback console.log(res) &#125;) &#125;, //根据 uuid 获取处于已连接状态的设备 getConnectedBluetoothDevices:function()&#123; wx.getConnectedBluetoothDevices(&#123; success: function (res) &#123; console.log(res) &#125;&#125;)&#125;,//连接低功耗蓝牙设备createBLEConnection:function()&#123; wx.createBLEConnection(&#123; deviceId: 'AC:BC:32:C1:47:80', success: function(res)&#123; // success console.log(res) &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;,//断开与低功耗蓝牙设备的连接closeBLEConnection:function()&#123; wx.closeBLEConnection(&#123; deviceId: 'AC:BC:32:C1:47:80', success: function (res) &#123; console.log(res) &#125;&#125;)&#125;,//监听低功耗蓝牙连接的错误事件，包括设备丢失，连接异常断开等等onBLEConnectionStateChanged:function()&#123; wx.onBLEConnectionStateChanged(function(res) &#123; console.log(`device $&#123;res.deviceId&#125; state has changed, connected: $&#123;res.connected&#125;`)&#125;)&#125;,//获取蓝牙设备所有 service（服务）getBLEDeviceServices:function()&#123; wx.getBLEDeviceServices(&#123; deviceId: '48:3B:38:88:E3:83', success: function(res)&#123; // success console.log('device services:', res.services.serviceId) &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;,//获取蓝牙设备所有 characteristic（特征值）getBLEDeviceCharacteristics:function()&#123; wx.getBLEDeviceCharacteristics(&#123; deviceId: '48:3B:38:88:E3:83', serviceId: 'serviceId', success: function(res)&#123; // success &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;&#125;)","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"电信路由器上网","slug":"电信路由器上网","date":"2018-09-20T02:01:16.000Z","updated":"2019-09-15T08:07:31.086Z","comments":true,"path":"2018/09/20/电信路由器上网/","link":"","permalink":"https://nymrli.top/2018/09/20/电信路由器上网/","excerpt":"","text":"链接: https://pan.baidu.com/s/1QaW7DMhjb2YHd0ZVWterSw 密码：联系QQ1063052964,或是在下方评论处留言QQ","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"小程序入门学习","slug":"小程序入门学习","date":"2018-09-20T01:57:01.000Z","updated":"2019-09-15T08:07:31.049Z","comments":true,"path":"2018/09/20/小程序入门学习/","link":"","permalink":"https://nymrli.top/2018/09/20/小程序入门学习/","excerpt":"","text":"IDE搭建: 下载:微信公众平台官网 预备知识: 个人认为入门小程序相对比较简单,需要了解HTML+CSS 大概知道是干啥的就行,JavaScrip还是要看看的，推荐教程 廖雪峰的博客以及W3Cschool的JS教程 项目目录结构介绍: 小程序中一共有四种类型的文件: js ---------- JavaScrip文件 json -------- 项目配置文件，负责窗口颜色等等 wxml ------- 类似HTML文件 wxss ------- 类似CSS文件 重要文件-APP讲解: app.json(必需) :监听并处理小程序的生命周期函数、声明全局变量。 app.js(建议保存) : *作为配置整个APP的入口,可以什么都不写只输入{}.对整个小程序的全局配置。记录了页面组成(定义了每个页面)，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。* ​ ==&gt;没有最简单的小程序也能运行. app.wxml app.wxss ===&gt; 所以只有app.js和app.json的项目是最简单的小程序 具体页面下的 js文件配置页面入口 wxml配置布局 一起完成对页面的渲染 wxss样式文件 json配置文件 会覆盖app.json和app.wxss全局设置的内容,实现单个网页的个性化 app.js 12345678910111213141516171819202122232425262728293031323334353637Page(&#123; //* 页面的初始数据 data: &#123; &#125;, // * 生命周期函数--监听页面加载 onLoad: function (options) &#123; &#125;, //* 生命周期函数--监听页面初次渲染完成 onReady: function () &#123; &#125;, //* 生命周期函数--监听页面显示 onShow: function () &#123; &#125;, //* 生命周期函数--监听页面隐藏 onHide: function () &#123; &#125;, //* 生命周期函数--监听页面卸载 onUnload: function () &#123; &#125;, //* 页面相关事件处理函数--监听用户下拉动作 onPullDownRefresh: function () &#123; &#125;, //* 页面上拉触底事件的处理函数 onReachBottom: function () &#123; &#125;, //* 用户点击右上角分享 onShareAppMessage: function () &#123; &#125;&#125;) app.json 1234&quot;pages&quot;:[ &quot;pages/index/index&quot; //pages 里面的路径其实是指向js文件的,其中第一个就是登陆首页] 实现路由配置,及全局的某些设置 app.js** 定义了每个页面,每个页面的.js又调用了Page()方法实现该页面的配置信息 小程序事件 事件 == 事件类型+具体事件 具体事件 tap longtap toustart、touchend、touchmove、touchcancel(电话中断) submint、input…… 事件类型 bind 冒泡事件 catch 非冒泡事件 currentTarget 被绑定的组件 dataset 控件相应的属性 target 发生事件的组件 页面跳转 navigateTo({ url :'xxx' }) &lt;navigator url=&quot;../logs/logs?id=1&amp;title='as'&quot; &gt; &lt;/navigator&gt; Flex容器和元素 容器属性 flex-direction : 决定主轴方向 flex-wrap : 处理如何换行 flex-flow : flex-dirction和flex-wrap合并简写 justify-content: 元素在主轴的对齐方式 space-bewteen 两端对齐 center 居中对齐 flex-start 左侧对齐 flex-end 右侧对齐 align-items : 元素在交叉轴的对齐方式 stretch 拉伸,当没设置item高度时,占满整个容器 baseline :以文字为底线对齐 元素属性 flex-grow (默认0): 当有多余空间时,元素的放大比例 flex-shrink(默认1) : 当空间不足时,元素的放大比例 flex-basis: 元素在主轴上占据的空间 flex : flex-grow、flex-shrink、flex-basis的合并简写 order : 定义元素的排列顺序 align-self : 定义元素自身的对齐方式 定位 相对定位: 相对定位的元素是相对自身进行定位,参照物是自己 绝对定位 : 绝对定位的元素是相对离它最近的一个已定位的父级元素进行定位,如果没有,则以整个页面进行定位 margin和padding的区别 margin是指从 自身边框 到 另一个容器边框 之间的距离，就是容器外距离。（外边距） padding是指 自身边框 到 自身内部另一个容器边框 之间的距离，就是容器内距离。（内边距） rpx 动态单位 css布局实例 123456789101112wxml: &lt;view class='list-item' wx:for=\"&#123;&#123;listItem&#125;&#125;\"&gt; &lt;view class='list-item-images'&gt; &lt;image src='../../images/img2.png' class='list-item-images-img' /&gt; &lt;!-- &lt;image class='avatar' src='../../images/avatar.png'/&gt; --&gt; &lt;/view&gt; &lt;view class=\"list-item-text\"&gt; &lt;text&gt;这是一个标题&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415wxss:.list-item&#123; height:500rpx; //整个 图片+文字 一共高为500rpx width: 100%;&#125; .list-item-images&#123; height: 300rpx; // 其中图片的高度为300rpx width: 100%;&#125;.list-item-images image&#123; //图片高、宽全部伸展 height: 100%; width: 100%;&#125;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"Spy++使用介绍","slug":"Spy-使用介绍","date":"2018-09-02T11:39:45.000Z","updated":"2019-09-15T08:07:31.005Z","comments":true,"path":"2018/09/02/Spy-使用介绍/","link":"","permalink":"https://nymrli.top/2018/09/02/Spy-使用介绍/","excerpt":"","text":"Spy++ (SPYXX.EXE) 是一个基于 Win32 的实用工具，它提供系统的进程、线程、窗口和窗口消息的图形视图。使用 Spy++ 可以执行下列操作： 显示系统对象（包括进程、线程和窗口）之间关系的图形树。 搜索指定的窗口、线程、进程或消息。 查看选定的窗口、线程、进程或消息的属性。 我们可以使用微软的Spy++来查看窗口类名等信息，然后再结合pywin32实现。 加载初始界面: 然后点击工具栏的望远镜。如图所示: 出现搜索窗口，然后通过移动靶心到想要查找句柄的窗口后单击就行了。==&gt;它的句柄、标题、类都会显示 再点击确定。 此时会有两种情况。 成功搜索到 搜索不到 原因是你查找的窗口是在打开spy++后打开的，解决的办法就是按F5进行刷新，然后就行了 成功后都会出现如下： 右键，点击“属性”能看到更多详细内容。","categories":[],"tags":[{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"解决安装PyUserInput、pyHook遇到的问题——AttributeError: 'HookManager' object has no attribute 'keyboard_hook","slug":"解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook","date":"2018-09-02T11:33:32.000Z","updated":"2019-09-15T08:07:31.096Z","comments":true,"path":"2018/09/02/解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook/","link":"","permalink":"https://nymrli.top/2018/09/02/解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook/","excerpt":"","text":"安装PyUserInput失败。 经查看发现是pyHook（pyHook是一个用来进行键盘、鼠标等层面事件监控的库。这个库的正常工作需要pythoncom等操作系统的API的支持。）无法安装，不知道是不是因为这个库可以被用于一些比较邪恶的目的。经搜索发现直接pip install pyHook是找不到相关包的，但可以下源码编译安装，可以在 https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyhook 这里可以直接下载到.whl文件，这个文件可以作为pip install 的参数来进行安装。 直接输入pip install pyHook-1.5.1-cp36-cp36m-win_amd64.whl好像还是不行，经提示使用G:\\Py_opencv\\venv\\Scripts\\python.exe -m pip install pyHook-1.5.1-cp36-cp36m-win_amd64.whl第一个参数是python解释器，-m选项可以让python以脚本的方式运行一个模块，pip install后面就是要安装的包名。 pyHook-1.5.1-cp36-cp36m-win_amd64.whl pyHook:库名 1.5.1：版本号 cp3.6m：Cpython3.6版本,编码是ucs2,UCS2认为每个字符占用2个字节，UCS4认为每个字节占用4个字符，都是UNICODE的编码形式。 win_amd64:windows64位环境 whl:压缩包，在其中包含了py文件，以及经过编译的pyd文件。可以使用pip安装 电脑系统环境查看，可以右键“我的电脑”-&gt;“属性”查看 然后再直接在命令行里输入pip install pyuserinput或是在pycharm下载安装都可以了。（需要先安装pywin32） 上述下载的pyHook是基于Python2的,在python3下会报错: TypeError: MouseSwitch() missing 8 required positional arguments: 'msg', 'x', 'y', 'data', 'flags', 'time', 'hwnd', and 'window_name' 或者AttributeError: 'HookManager' object has no attribute 'keyboard_hook' 感谢:python3.5安装pyHook,解决【TypeError: MouseSwitch() missing 8 required positional arguments: ‘msg’, ‘x’, ‘y’, ‘data’, ‘time’, ‘hwnd’, and ‘window_name’】这个错误！、[使用Python 3.5/3.6监听本机任意窗口中的按键操作](使用Python 3.5/3.6监听本机任意窗口中的按键操作)提供的解决方法 需要的模块：扩展库pyhook_py3k（注意，不要使用pyhook），pywin32。 第一步，安装pywin32，地址：http://www.lfd.uci.edu/~gohlke/pythonlibs/#pywin32 第二步，下载pyhook_py3k，地址：https://github.com/Answeror/pyhook_py3k 第三步，下载swig.exe，地址：http://www.swig.org/download.html ==&gt;.zip格式解压 第四步，解压缩pyhook_py3k，并进行编译，命令：python setup.py build_ext --swig=…\\swigwin-3.0.12\\swig.exe，可以根据实际情况修改swig.exe的路径，另外本机最好已安装VC2008 第五步，安装编译好的pyhook_py3k，命令：pip install . 然后就可以正常操作了!!~","categories":[],"tags":[{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"开学小蓝车180天免费卡","slug":"开学小蓝车180天免费卡","date":"2018-09-02T08:44:54.000Z","updated":"2019-09-15T08:07:31.058Z","comments":true,"path":"2018/09/02/开学小蓝车180天免费卡/","link":"","permalink":"https://nymrli.top/2018/09/02/开学小蓝车180天免费卡/","excerpt":"各位看客老爷,可以加下我的公众号哦!虽然没啥东东…微信搜索公众号&quot;我只要瓶果粒橙就好&quot; 原来是180天的,现在好像只有30还是60天了…","text":"各位看客老爷,可以加下我的公众号哦!虽然没啥东东…微信搜索公众号&quot;我只要瓶果粒橙就好&quot; 原来是180天的,现在好像只有30还是60天了…","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"例题4:1-3 古老的密码、刽子手的游戏，救济金发放","slug":"例题4-1-3-古老的密码、刽子手的游戏，救济金发放","date":"2018-09-01T10:46:59.000Z","updated":"2019-09-15T08:07:31.026Z","comments":true,"path":"2018/09/01/例题4-1-3-古老的密码、刽子手的游戏，救济金发放/","link":"","permalink":"https://nymrli.top/2018/09/01/例题4-1-3-古老的密码、刽子手的游戏，救济金发放/","excerpt":"","text":"例题4-1 古老的密码 因为字母可以重排,所以顺序不重要,而又同时因为可以映射,所以字母具体是什么不重要==&gt;只要统计排序后的结果相同就行了 RE(Runtime error)错法加一: 题号提交错误 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;void Bubblesort(int *cnt)//冒泡排序,从大到小顺序&#123; int i,j; int min=cnt[0]; for (i = 0; i &lt;26; ++i) &#123; for ( j = i+1; j &lt; 26; ++j) &#123; if (cnt[i] &lt; cnt[j]) &#123; min = cnt[i]; cnt[i]=cnt[j]; cnt[j] = min; &#125; &#125; &#125;&#125;int main()&#123; char s[2][105]; //存放猜测字符串的 int cnt[2][27]; //存放字母出现次数 int nlen[2]; //字符串的长度 while(scanf(\"%s%s\",s[0],s[1])!= EOF) &#123; memset(cnt,0,sizeof(cnt)); int i; for ( i = 0; i &lt; 2; ++i) &#123; nlen[i]= strlen(s[i]); int j; for ( j = 0; j &lt; nlen[i]; ++j) cnt[i][s[i][j]-'A'] ++; Bubblesort(cnt[i]); &#125; int k; for ( k = 0; k &lt; 26; ++k) &#123; if (cnt[0][k] != cnt[1][k]) &#123; printf(\"NO\\n\"); break; &#125; &#125; if (k==26) printf(\"YES\\n\" ); //如果26个字母出现次数比完全相等,则可以说相同. &#125; return 0;&#125; 例题4-2 刽子手的游戏 注意全局变量是否使用的问题,全局变量尽量少用…但维护内容较多的情况下,可以考虑 采用&quot;自顶向下&quot;的顺序 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 100char ans[maxn],gue[maxn];int left,chance;int win,lose;void guess(char ch)&#123; int bad=1; int i; for ( i = 0; i &lt; strlen(ans); ++i) //判断ch字母是否在字符串中 &#123; if (ans[i]==ch) &#123; ans[i] = ' '; bad =0; left--; //如果在的话,还剩未猜中字母数-1,机会不变 &#125; &#125; if (bad) chance--; //如果不在的话机会-1 if(!chance) lose=1; if(!left) win=1;&#125;int main()&#123; int rnd; while(scanf(\"%d%s%s\",&amp;rnd,ans,gue)==3 &amp;&amp; rnd !=-1) &#123; printf(\"Round %d\\n\",rnd); win = lose =0; left= strlen(ans); chance = 7; int i; int anslen=strlen(gue); for( i=0;i&lt; anslen;i++) &#123; guess(gue[i]); if(win || lose) break;&#125; if(win) printf(\"You win.\\n\"); else if(lose) printf(\"You lose.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;char a[1000],g[1000];//储存字符串 int abook[26],gbook[26];//标记26个字母出现频率 int main()&#123; int k; int alen,glen; int i; int j; int suc,fau; int acount; while(scanf(\"%d\",&amp;k)==1&amp;&amp;k!=-1)&#123; scanf(\"%s%s\",a,g); memset(abook,0,sizeof(abook)); memset(gbook,0,sizeof(gbook)); alen=strlen(a); glen=strlen(g); for(i=0;i&lt;alen;i++)//统计答案字母频率 abook[a[i]-'a']++; acount=0; for(i=0;i&lt;26;i++) if(abook[i])//统计答案的字母组成个数（扣除雷同字母） acount++; suc=0;//猜对次数 fau=0;//猜错次数 for(i=0;i&lt;glen;i++)&#123;//以猜测字母为基准进行扫描 j=g[i]-'a'; if(abook[j]==0)&#123;//答案无此字母，猜测错误 fau++; if(fau==7)//彻底失败 break; &#125;else if(abook[j]!=0)&#123;//猜中字母 suc++; abook[j]=0;//将此字母从答案中剔除出去，此句比较关键!(再猜无效) if(suc==acount)//成功 break; &#125; &#125; printf(\"Round %d\\n\",k); if(fau&gt;=7)//猜错7次及以上 printf(\"You lose.\\n\"); else if(suc==acount)//全部猜对 printf(\"You win.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 例题4-3 救济金发放 圆圈如何轮回==&gt;本质上是要求,大于n变成1,小于1变成n…实现1.越界后归正。2.(xxx)%n, 领过设为1,没领过(初始)设为1 较为简洁、清晰的做法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;string.h&gt;int book[100];//领过的标记1，没领过的标记0 int main()&#123; int n,k,m; int kcount,mcount; int ki,mi; int kout,mout; int first; int ncount; while(scanf(\"%d%d%d\",&amp;n,&amp;k,&amp;m)==3&amp;&amp;n&amp;&amp;k&amp;&amp;m)&#123; memset(book,0,sizeof(book)); ncount=0; ki=0; mi=n+1; first=1; while(ncount!=n)&#123;//n个人全被处理完毕//处理手法有些类似快速排序 kcount=0; mcount=0; //每数一个人,都要判断是不是该越过他.只有0(未领过,才计数) while(kcount!=k)&#123;//k系列处理 ki++; if(ki&gt;n)//ki越界处理 ki=1; if(book[ki]==0)//未被选中计数 ki为当前值 kcount++; &#125; while(mcount!=m)&#123;//m系列处理 mi--; if(mi&lt;1)//mi越界处理 mi=n; if(book[mi]==0)//未被选中计数 mi为当前值 mcount++; &#125; book[ki]=1;//不用担心ki==mi(重复设置为1不影响) book[mi]=1; if(first)&#123;//打印处理 first=0; if(ki!=mi)&#123; printf(\"%3d%3d\",ki,mi); ncount+=2; &#125; else&#123; printf(\"%3d\",ki); ncount++; &#125; &#125;else&#123; if(ki!=mi)&#123; printf(\",%3d%3d\",ki,mi); ncount+=2; &#125; else&#123; printf(\",%3d\",ki); ncount++; &#125; &#125; &#125; printf(\"\\n\"); &#125; return 0;&#125; 书上做法 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 25int n,k,m,a[maxn];int go(int p,int d,int t)&#123; while(t--) //每数一个人都要判断他是否已经领过 do&#123; p = (n+p+d)%n; &#125;while(!a[p]); //==0,领过 return p;&#125;int main()&#123; while(scanf(\"%d,%d,%d\",&amp;n,&amp;k,&amp;m)==3 &amp;&amp; n) &#123; for (int i = 0; i &lt; n; ++i) a[i]=i; int left =n; int p1 =n,p2=1; while(left) &#123; p1= go(p1,-1,k); p2= go(p2,1,m); printf(\"%d\",p1);left--; if(p1!=p2) printf(\" %d\",p2); a[p1]=a[p2]=0; //领了设置为0 if(left) printf(\",\"); //注意输出格式 &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"},{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"WampSever配置本地环境，解决打开打开本地网站问题","slug":"WampSever配置本地环境，解决打开打开本地网站问题","date":"2018-09-01T06:19:39.000Z","updated":"2019-09-15T08:07:31.013Z","comments":true,"path":"2018/09/01/WampSever配置本地环境，解决打开打开本地网站问题/","link":"","permalink":"https://nymrli.top/2018/09/01/WampSever配置本地环境，解决打开打开本地网站问题/","excerpt":"","text":"WampServer是一款由法国人开发的Apache Web服务器、PHP解释器以及MySQL数据库的整合软件包。免去了开发人员将时间花费在繁琐的配置环境过程，从而腾出更多精力去做开发。 直接点击本地的.html是静态加载的，需要动态加载的文件是无法被加载的。会出现如下情况。 于是选用了Wamp搭本地服务器浏览网站，这样就能成功加载动态文件了。 在此分享下配置WampSever时碰到的问题和解决的方法： 服务器是否已正常运行 如果能登上则表示服务器能够正常运行。(在地址栏中输入localhost:端口(或是127.0.0.1:端口) 或是左键图标选择’localhost’) localhost 指你所在的计算机本身。 在windows系统它成了127.0.0.1的别名 ，在Unix系统下，查看网卡配置会发现作为本地回环的方式，一定程度上使用localhost比127.0.0.1要快一些。 在Hosts文件中，localhost指向的IP是127.0.0.1这个关系是可以修改的。 查看、修改端口 配置本地环境、添加项目、打开本地网站 1项目中是空的,需要手动将要打开的网站放到&apos;www&apos;目录中 1可以选择输入路径，也可以直接左键选择&apos;www目录&apos;打开 1将要打开网站的文件夹复制到&apos;www目录下&apos;，会发现刚添加的文件夹出现在了项目中。 勾选’Add localhost in url’ 1看似到此已经大功告成，然而再点击进去这些文件夹时会出现如下情况： 1可以看到的是URL并不对，我们是想要实现通过web服务器的方式访问这些网站，然而这个明显没达到我们想要的效果，根据提示，我找到了原因。 1右键选择&apos;Wamp Settings&apos;中将&apos;Add localhost in url&apos;选项勾上后再次如上打开项目即可。（记得重新打开一次localhost页面或是刷新一下） 1可以看到网站成功地通过web服务器打开了，那些之前提示需要动态加载的文件也成功加载了。 撒花完结！~200成功！ ▲.看到这，我相信你也明白了为什么必须要有’Add localhost in url’这步了。同时也猜到了，其实直接在网址里面输入正确的网址也是可以的，如http://localhost:8080/data-visualize-chain-master/,结果也是能打开的。 希望能对你们有所帮助。","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"WAMP","slug":"WAMP","permalink":"https://nymrli.top/tags/WAMP/"}]},{"title":"Ubuntu下Sublime配置Python环境使用指导:","slug":"Ubuntu下Sublime配置Python环境使用指导","date":"2018-09-01T06:04:47.000Z","updated":"2019-09-15T08:07:31.009Z","comments":true,"path":"2018/09/01/Ubuntu下Sublime配置Python环境使用指导/","link":"","permalink":"https://nymrli.top/2018/09/01/Ubuntu下Sublime配置Python环境使用指导/","excerpt":"","text":"Sublime配置python编译环境及搭建虚拟环境:(windows下大致相同) 1.编译环境配置 2019-3-6更新教程，发现好像 官方网址打不开了，要改一下源才行。 解决办法： 点击 Preferences -&gt; Settings -&gt; Preferences.sublime-Settings—— User(一个新窗口) 添加配置**(在原有大括号{}里面添加**)：&quot;channels&quot;: [&quot;https://raw.githubusercontent.com/HBLong/channel_v3_daily/master/channel_v3.json&quot;], 代码不变，仍然是下面的代码 感谢HBLong提供的解决方案和源: 原有链接 : 解决：Sublime Text3 packagecontrol.io 无法访问的问题 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 1.点击 官方网址 从 Sublime Text 3 官方获取用于安装的代码(即上面的代码)。从菜单栏View --&gt;Show Console或者使用Ctrl+`(esc键下面的按键)，调出sublime的控制台，将官网中的python代码粘贴进去并按Enter执行，最终可以安装完成。在控制台中粘贴刚才的代码，然后点击回车。最后重启ST3。 2.现在你可以通过快捷键 cmd+shift+P 打开 Package Control 来安装其他的插件了。输入 install 然后你就能看见屏幕上出现了 Package Control: Install Package，点击回车,然后搜索sublimeREPL 安装成功后，可以在菜单栏的’TOOL’中找到SublimeREPL，如图所示 2.将菜单栏改为中文 若需要将菜单栏改成中文可如上操作下载插件“ConvertToUTF8”或是安装插件“ChineseLocalizations”(本人使用的是这个，没试ConvertToUTF8的效果) (参考博客:http://blog.51cto.com/11970781/2087971) 3.安装Anaconda插件 1.点击刚刚生成的Package Control -&gt;输入install 2.进入安装界面，安装好后再在新窗口命令行中输入Anaconda并点击第一个备选项进行安装。 安装完成后会显示messages文档。 安装Anaconda插件完成之后，会看到如下选项栏，说明Anaconda安装成功。 - Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数或者类的定义。 - Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 - Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下) Anaconda会自动补全代码，之前用惯了pycharm发现突然没了代码补全后很不习惯，Anaconda的补全功能虽然没有pycharm那么好用，但还是不错的 还有需要注意的是，安装Anaconda插件后，如果python代码没有遵循PEP8规范，会出现白色的框框，或是可以使用快捷键Ctrl+Alt+R进行规范代码(这个可以去除，步骤如下) 在Settings-User选项中添加配置:{“anaconda_linting”:false} 4.安装虚拟环境 1.首先使用终端安装virtualenv，pip3 install virtualenv2.在需要创建的地方进行虚拟环境的搭建，代码如下： 123mkdir pytest(文件夹名)cd pytestvirtualenv venv 在终端进入虚拟环境的话是在pytest文件夹下输入命令source /bin/activate而要在sublime中进入虚拟环境的话就得按照如下操作： １．首先在sublime中安装virtualenv插件，Ctrl + Shift + P，然后输入install,回车，然后搜索virtualenv。 2. 安装完成后，直接按Ctrl + Shift + P，再输入Activate，若没有该选项则virtualenv安装中出现问题，需要重新安装。如果有的会选择Activate就能发现刚刚创建的虚拟环境，选中后回车即可进入虚拟环境 3. 如果Activate选中后没有出现我们刚刚创建的虚拟环境，则需要我们手动添加路径.Ctrl + Shift + P，然后输入Add directory，回车，屏幕下面会出现输入行（Directory path）:再将刚创建的虚拟环境路径填入即可 另外，我曾碰到过Add directory后仍然没用的情况。那时，可选择“”Project”=&gt;&quot;Add folder to project&quot;选择文件后=&gt;“Save Project as”==&gt;保存好即可 工程配置文件为： .sublime-workspace、.sublime-project 其中sublime-project为: 123456789101112131415161718&#123; &quot;build_systems&quot;: [ &#123; &quot;file_regex&quot;: &quot;^[ ]File &quot;(...?)&quot;, line ([0-9]*)&quot;, &quot;name&quot;: &quot;Anaconda Python Builder&quot;, &quot;selector&quot;: &quot;source.python&quot;, &quot;shell_cmd&quot;: &quot;&quot;python&quot; -u &quot;$file&quot;&quot; &#125; ], &quot;folders&quot;: [ &#123; &quot;path&quot;: &quot;爬虫&quot; &#125; ], &quot;virtualenv&quot;: &quot;G:\\pachong\\venv&quot;&#125; 这样环境就配置好了。按Ctrl+B编译时，观察&quot;Tools&quot;-&gt;“Build System”-&gt;是否为&quot;Python+ Virtualenv&quot;，如果不是，则选用这个再Ctrl+B就是在虚拟环境中编译了! ubuntu下sublime默认情况下好像不能输入中文，需要用下面命令就可以完美支持中文输入： 1234sudo apt-get update &amp;&amp; sudo apt-get upgradegit clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix./sublime-imfix 转自CV_YOU的博客 完美解决Sublime无法输入中文问题 截图好像有点问题，菜单栏都没有截到，用到的三个分别为“项目(Project)”，“首选项(Preferences)”，“帮助(Help)”","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"}]},{"title":"python pywin32 PyUserInput实现自动化脚本","slug":"python-win32api-win32gui-win32con-PyUserInput实现自动化脚本","date":"2018-08-31T11:43:00.000Z","updated":"2020-11-07T03:39:42.948Z","comments":true,"path":"2018/08/31/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本/","link":"","permalink":"https://nymrli.top/2018/08/31/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本/","excerpt":"","text":"python pywin32 PyUserInput实现自动化脚本 pywin32用spy++工具查找到句柄，再结合PyUserInput就能很好地实现自动化脚本。 句柄是一个32位整数，在windows中标记对象用，类似一个dict中的key，详情参看这篇文章。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import win32guiimport win32conimport win32api# 从顶层窗口向下搜索主窗口，无法搜索子窗口# FindWindow(lpClassName=None, lpWindowName=None) 窗口类名 窗口标题名handle = win32gui.FindWindow(\"Notepad\", None) # 获取窗口位置left, top, right, bottom = win32gui.GetWindowRect(handle)#获取某个句柄的类名和标题title = win32gui.GetWindowText(handle) clsname = win32gui.GetClassName(handle)# 打印句柄# 十进制print(handle)# 十六进制print(\"%x\" %(handle) )# 搜索子窗口# 枚举子窗口hwndChildList = [] win32gui.EnumChildWindows(handle, lambda hwnd, param: param.append(hwnd), hwndChildList)# FindWindowEx(hwndParent=0, hwndChildAfter=0, lpszClass=None, lpszWindow=None) # 父窗口句柄 若不为0，则按照z-index的顺序从hwndChildAfter向后开始搜索子窗体，否则从第一个子窗体开始搜索。 子窗口类名 子窗口标题subHandle = win32gui.FindWindowEx(handle, 0, \"EDIT\", None)# 获得窗口的菜单句柄menuHandle = win32gui.GetMenu(subHandle)# 获得子菜单或下拉菜单句柄 # 参数：菜单句柄 子菜单索引号subMenuHandle = win32gui.GetSubMenu(menuHandle, 0)# 获得菜单项中的的标志符，注意，分隔符是被编入索引的 # 参数：子菜单句柄 项目索引号 menuItemHandle = win32gui.GetMenuItemID(subMenuHandle, 0)# 发送消息，加入消息队列，无返回 # 参数：句柄 消息类型 WParam IParamwin32gui.postMessage(subHandle, win32con.WM_COMMAND, menuItemHandle, 0)# wParam的定义是32位整型，high word就是他的31至16位，low word是它的15至0位。# 当参数超过两个，wParam和lParam不够用时，可以将wParam就给拆成两个int16来使用。# 这种时候在python里记得用把HIWORD的常数向左移16位，再加LOWORD，即wParam = HIWORD&lt;&lt;16+LOWORD。# 下选框内容更改# 参数：下选框句柄； 消息内容； #参数下选框的哪一个item，以0起始的待选选项的索引；如果该值为-1，将从组合框列表中删除当前选项，并使当前选项为空；# 参数CB_Handle为下选框句柄，PCB_handle下选框父窗口句柄if win32api.SendMessage(CB_handle, win32con.CB_SETCURSEL, 1, 0) == 1:# 下选框的父窗口命令# 参数：父窗口句柄； 命令； # 参数：WParam：高位表示类型，低位表示内容；参数IParam，下选框句柄# CBN_SELENDOK当用户选择了有效的列表项时发送，提示父窗体处理用户的选择。 LOWORD为组合框的ID. HIWORD为CBN_SELENDOK的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x90000, CB_handle) # CBN_SELCHANGE当用户更改了列表项的选择时发送，不论用户是通过鼠标选择或是通过方向键选择都会发送此通知。LOWORD为组合框的ID. HIWORD为CBN_SELCHANGE的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x10000, CB_handle) # 设置文本框内容，等窗口处理完毕后返回true。中文需编码成gbk # 参数：句柄；消息类型；# 参数WParam，无需使用； # 参数IParam，要设置的内容，字符串win32api.SendMessage(handle, win32con.WM_SETTEXT, 0, os.path.abspath(fgFilePath).encode('gbk'))# 控件点击确定,处理消息后返回0# 参数:窗口句柄; 消息类型; 参数WParam HIWORD为0（未使用），LOWORD为控件的ID; 参数IParam 0（未使用）,确定控件的句柄win32api.SendMessage(Mhandle, win32con.WM_COMMAND, 1, confirmBTN_handle)# 获取窗口文本不含截尾空字符的长度# 参数：窗口句柄； 消息类型； 参数WParam； 参数IParambufSize = win32api.SendMessage(subHandle, win32con.WM_GETTEXTLENGTH, 0, 0) +1# 利用api生成BufferstrBuf = win32gui.PyMakeBuffer(bufSize)print(strBuf)# 发送消息获取文本内容# 参数：窗口句柄； 消息类型；文本大小； 存储位置length = win32gui.SendMessage(subHandle, win32con.WM_GETTEXT, bufSize, strBuf)# 反向内容，转为字符串# text = str(strBuf[:-1])address, length = win32gui.PyGetBufferAddressAndLen(strBuf) text = win32gui.PyGetString(address, length) # print('text: ', text)# 鼠标单击事件#鼠标定位到(30,50)win32api.SetCursorPos([30,150])#执行左单键击，若需要双击则延时几毫秒再点击一次即可win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP | win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)#右键单击win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP | win32con.MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0)def click1(x,y): #第一种 win32api.SetCursorPos((x,y)) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,0,0) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,0,0)def click2(x,y): #第二种 ctypes.windll.user32.SetCursorPos(x,y) ctypes.windll.user32.mouse_event(2,0,0,0,0) ctypes.windll.user32.mouse_event(4,0,0,0,0)def click_it(pos): #第三种 handle= win32gui.WindowFromPoint(pos) client_pos =win32gui.ScreenToClient(handle,pos) tmp=win32api.MAKELONG(client_pos[0],client_pos[1]) win32gui.SendMessage(handle, win32con.WM_ACTIVATE,win32con.WA_ACTIVE,0) win32gui.SendMessage(handle, win32con.WM_LBUTTONDOWN,win32con.MK_LBUTTON,tmp) win32gui.SendMessage(handle, win32con.WM_LBUTTONUP,win32con.MK_LBUTTON,tmp)# 发送回车win32api.keybd_event(13,0,0,0)win32api.keybd_event(13,0,win32con.KEYEVENTF_KEYUP,0)# 关闭窗口win32gui.PostMessage(win32lib.findWindow(classname, titlename), win32con.WM_CLOSE, 0, 0)# 检查窗口是否最小化，如果是最大化if(win32gui.IsIconic(hwnd)):# win32gui.ShowWindow(hwnd, win32con.SW_SHOWNORMAL) win32gui.ShowWindow(hwnd, 8) sleep(0.5)# SW_HIDE：隐藏窗口并激活其他窗口。nCmdShow=0。# SW_MAXIMIZE：最大化指定的窗口。nCmdShow=3。# SW_MINIMIZE：最小化指定的窗口并且激活在Z序中的下一个顶层窗口。nCmdShow=6。# SW_RESTORE：激活并显示窗口。如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置。在恢复最小化窗口时，应用程序应该指定这个标志。nCmdShow=9。# SW_SHOW：在窗口原来的位置以原来的尺寸激活和显示窗口。nCmdShow=5。# SW_SHOWDEFAULT：依据在STARTUPINFO结构中指定的SW_FLAG标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递给CreateProcess函数的。nCmdShow=10。# SW_SHOWMAXIMIZED：激活窗口并将其最大化。nCmdShow=3。# SW_SHOWMINIMIZED：激活窗口并将其最小化。nCmdShow=2。# SW_SHOWMINNOACTIVE：窗口最小化，激活窗口仍然维持激活状态。nCmdShow=7。# SW_SHOWNA：以窗口原来的状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=8。# SW_SHOWNOACTIVATE：以窗口最近一次的大小和状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=4。# SW_SHOWNORMAL：激活并显示一个窗口。如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小。应用程序在第一次显示窗口的时候应该指定此标志。nCmdShow=1。 感谢python win32api win32gui win32con 窗口句柄 发送消息 常用方法 键盘输入，代码主要来自于他 ▲.需要注意在windows和mac下接口参数可能有所不同。 win32虽然也可控制键盘，但不如使用PyUserInput的方便。安装PyUserInput教程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pymouse import PyMousefrom pykeyboard import PyKeyboard#实例化m = PyMouse() k = PyKeyboard()x_dim, y_dim = m.screen_size()# 鼠标点击 参数:x,y,button=1(左键)、2(右键)、3(中间),次数m.click(x_dim, y_dim, button=1,n=1) # 键盘输入 参数:str,间隔k.type_string('Hello, World!',interval=0)# 按住一个键k.press_key('H')# 松开一个键k.release_key('H')# 相当于===&gt;按住并松开，tap一个键k.tap_key('e')# tap支持重复的间歇点击键,参数:str,次数,间隔k.tap_key('l',n=2,interval=5) #创建组合键===&gt;press_key和release_key结合使用k.press_key(k.alt_key)k.tap_key(k.tab_key)k.release_key(k.alt_key)# 特殊功能键k.tap_key(k.function_keys[5]) # Tap F5k.tap_key(k.numpad_keys['Home']) # Tap 'Home' on the numpadk.tap_key(k.numpad_keys[5], n=3) # Tap 5 on the numpad, thrice# Mac系统按键k.press_keys(['Command','shift','3'])# Windows系统按键k.press_keys([k.windows_l_key,'d'])其中pymouse的PyMouseEvent和pykeyboard的PyKeyboardEvent还可用于监听鼠标和键盘事件的输入class Clickonacci(PyMouseEvent): def __init__(self): PyMouseEvent.__init__(self) self.fibo = fibo() def click(self, x, y, button, press): '''Print Fibonacci numbers when the left click is pressed.''' if button == 1: if press: print('Press times:%d'.format(press)) else: # Exit if any other mouse button used self.stop()C = Clickonacci()C.run()class TapRecord(PyKeyboardEvent): def __init__(self): PyKeyboardEvent.__init__(self) def tap(self, keycode, character, press): print(time.time(), keycode, character, press)t = TapRecord()t.run()#这些对象是一个架构用于监听鼠标和键盘的输入；他们除了监听之外不会做任何事，需要继承重构他们#PyKeyboardEvent为编写完成，所以这里是一个继承PyMouseEvent的例子： 附录 查找窗体句柄 貌似在win32编程的世界里，包括窗口到文本框的所有控件就是窗体，所有的窗体都有独立的句柄。要操作任意一个窗体，你都需要找到这个窗体的句柄 123456FindWindow(lpClassName=None, lpWindowName=None):自顶层窗口（也就是桌面）开始搜索条件匹配的窗体，并返回这个窗体的句柄。不搜索子窗口、不区分大小写。找不到就返回0参数：lpClassName：字符型，是窗体的类名，这个可以在Spy++里找到。lpWindowName：字符型，是窗口名，也就是标题栏上你能看见的那个标题。说明：这个函数我们仅能用来找主窗口。 12345678FindWindowEx(hwndParent=0, hwndChildAfter=0, lpszClass=None, lpszWindow=None);描述：搜索类名和窗体名匹配的窗体，并返回这个窗体的句柄。不区分大小写，找不到就返回0。参数：hwndParent：若不为0，则搜索句柄为hwndParent窗体的子窗体。hwndChildAfter：若不为0，则按照z-index的顺序从hwndChildAfter向后开始搜索子窗体，否则从第一个子窗体开始搜索。lpClassName：字符型，是窗体的类名，这个可以在Spy++里找到。lpWindowName：字符型，是窗口名，也就是标题栏上你能看见的那个标题。说明：找到了主窗口以后就靠它来定位子窗体啦 另外，python中找回来的句柄都是十进制整型，Spy++里显示的都是十六进制整型，这个要注意下，调试的时候用十六进制输出句柄，如下：print &quot;%x&quot; % (handle) 1234567891011121314151617GetMenu(hwnd) 描述：获取窗口的菜单句柄。 参数： hwnd：整型，需要获取菜单的窗口的句柄。 说明：获取的是插图中黄色的部分。GetSubMenu(hMenu, nPos) 描述：获取菜单的下拉菜单或者子菜单。 参数： hMenu：整型，菜单的句柄，从GetMenu获得。 nPos：整型，下拉菜单或子菜单的的索引，从0算起。 说明：这个可以获取插图中蓝色的部分；如描述所述，这个不仅可以获取本例中的下拉菜单，还可以获取子菜单。GetMenuItemID(hMenu, nPos) 描述：获取菜单中特定项目的标识符。 参数： hMenu：整型，包含所需菜单项的菜单句柄，从GetSubMenu获得。 nPos：整型，菜单项的索引，从0算起。 说明：这个获取的就是红色区域中的项目啦，注意，分隔符是被编入索引的，所以Open的索引是2而非1，而Exit的索引是9而非6。 12345678PostMessage(hWnd, Msg, wParam, lParam) 描述：在消息队列中加入为指定的窗体加入一条消息，并马上返回，不等待线程对消息的处理。 参数： hWnd：整型，接收消息的窗体句柄 Msg：整型，要发送的消息，这些消息都是windows预先定义好的，可以参见系统定义消息（System-Defined Messages） wParam：整型，消息的wParam参数 lParam：整型，消息的lParam参数 说明：简单说，就是给指定程序发一个消息，这些消息都用整型编好号，作为windows的常量可以查询的。在这里，我们用的就是win32con这个库里定义的WM_COMMAND这个消息，具体的wParam和lParam是根据消息的不同而不同的。具体请根据MSDN查阅。 查阅MSDN的消息时，会发现有的wParam定义了low word和high word，这是什么呢？wParam的定义是32位整型，high word就是他的31至16位，low word是它的15至0位，如图。有时，一个消息只需要不超过两个参数，那wParam就可以当一个参数用。万一参数多了，wParam就给拆成了两个int16来使用。这种时候在python里记得用16进制把整形表示出来就比较清爽啦。 用了SendMessage而不是PostMessage，其区别就在于我们可以通过SendMessage取得消息的返回信息。因为对于我们要设置文本框信息的WM_SETTEXT信息来说，设置成功将返回True。 123456789101112131415161718SendMessage(hWnd, Msg, wParam, lParam) 描述：在消息队列中加入为指定的窗体加入一条消息，直到窗体处理完信息才返回。 参数： hWnd：整型，接收消息的窗体句柄 Msg：整型，要发送的消息，这些消息都是windows预先定义好的，可以参见系统定义消息（System-Defined Messages） wParam：整型，消息的wParam参数 lParam：整型，消息的lParam参数 说明：wParam和IParam根据具体的消息不同而有不同的定义，详情参阅Part 2. WM_SETTEXT 消息 描述：设置窗体的文本 参数： wParam：未使用 lParam：一个指针，指向以null结尾的字符串。窗体文本将被设置为该字符串。 返回值： 如果成功设置，则返回1（MSDN原文是返回True） 说明： 上面的定义是直接从MSDN上翻译过来的，在Python的语境里面没有指针，你只需要把变量名作为lParam传入就好了。 另外，请注意编码，包含中文请用gbk编码，否则乱码。 123456WM_COMMAND 消息描述：当用户选择了菜单（或按钮等控件的）命令，或控件发送通知到父窗口，或加速键击（accelerator keystroke is translated）时发送。参数：根据情景不同而不同，在这里属于用户命令，参数配置如下wParam：HIWORD为0（未使用），LOWORD为控件的IDlParam：0（未使用）返回值：如果窗体处理了消息，应返回0 1234567891011121314顺便，如果要获取目标文本框的内容呢，可以使用WM_GETTEXT，如下：WM_GETTEXT消息：描述：将窗体的文本内容复制到指定的buffer对象中参数：wParam：要复制字符的最大长度，包括截尾的空字节lParam：用来保存字符串的buffer的指针返回值：返回复制字符的数量，不包括截尾的空字节利用win32gui.PyMakeBuffer(len, addr)可以造一个buffer对象，类似python3中的bytearray，lParam的返回值。而利用WM_GETTEXTLENGTH可以获取不含截尾空字节的文本长度的长度，可以用来设置Buffer的长度。完整的示例如下：buf_size = win32gui.SendMessage(hwnd, win32con.WM_GETTEXTLENGTH, 0, 0) + 1 # 要加上截尾的字节str_buffer = win32gui.PyMakeBuffer(buf_size) # 生成buffer对象win32api.SendMessage(hwnd, win32con.WM_GETTEXT, buf_size, str_buffer) # 获取bufferstr = str(str_buffer[:-1]) # 转为字符串 1234567891011121314151617181920212223242526272829303132333435363738Part 4：控件操作B——下拉至于另存为图片，情况要稍微复杂一点，因为另存为图片的默认选项是BMP，特别不巧，我使用的FaceGen版本保存为BMP有BUG，不能成功保存，所以我们除了定位保存文件的路径以外，还需要对文件类型的下拉组合框(ComboBox进)行操作：我们假设我们找到了组合框的句柄为CB_handle，我们可以用CB_SETCURSEL消息来更改当前的选项：CB_SETCURSEL 消息描述：参数：wParam：以0起始的待选选项的索引；如果该值为-1，将从组合框列表中删除当前选项，并使当前选项为空lParam：未使用。返回值：更改选择成功将返回所设置选项的索引号。只要给组合框发一个CB_SETCURSEL消息，你就会发现下拉列表的选项已经改变了。这时点保存，你就会发现，这保存的跟之前的一样啊！根本没有变！问题在哪里？我们用鼠标或者键盘操作一下，是没有问题的，一旦更保存类型，保存窗口里的预览也会随之变化。所以，除了CB_SETCURSEL以外，一定还缺了点儿什么。调用Spy++的消息机制查看手动操作，我们的下拉组合框除了渲染和点击，好像没有什么特别值得注意的。那再看看父窗体呢？好像有点儿不太一样的东西：CBN_SELENDOK 通知（notification code）描述：当用户选择了有效的列表项时发送，提示父窗体处理用户的选择。父窗体通过WM_COMMAND消息接收这个通知。参数：（作为WM_COMMAND的参数）wParam：LOWORD为组合框的ID. HIWORD为CBN_SELENDOK的值。lParam：组合框的句柄。CBN_SELCHANGE 通知（notification code）描述：当用户更改了列表项的选择时发送，不论用户是通过鼠标选择或是通过方向键选择都会发送此通知。父窗体通过WM_COMMAND消息接收这个通知。参数：（作为WM_COMMAND的参数）wParam：LOWORD为组合框的ID. HIWORD为CBN_SELCHANGE的值。lParam：组合框的句柄。说明：他们是WM_COMMAND消息wParam的high word（wParam的16-31位，详情参见Part 2）的常数之一，在Python中可以用位移操作将其移动到高位上（a&lt;&lt;16），再用加法加上低位的内容。继续查MSDN的资料，我们发现，对于一个有效的选择，一定会发送这两个通知，发送完CBN_SELENDOK以后马上发送CBN_SELCHANGE。而且，使用CB_SETCURSEL消息时，CBN_SELCHANGE通知是不会被送达的！问题就在这里，加上这两个消息之后，就能正常操作下拉菜单了。 12345if win32api.SendMessage(CB_handle, win32con.CB_SETCURSEL, format_dict[format], 0) == format_dict[format]:win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, win32con.CBN_SELENDOK&lt;&lt;16+0, CB_handle) # 控件的ID是0，所以低位直接加0win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, win32con.CBN_SELCHANGE&lt;&lt;16+0, CB_handle)else:raise Exception(\"Change saving type failed\")","categories":[],"tags":[{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Python字典基本操作介绍","slug":"Python字典基本操作介绍","date":"2018-08-30T13:14:27.000Z","updated":"2019-09-15T08:07:30.986Z","comments":true,"path":"2018/08/30/Python字典基本操作介绍/","link":"","permalink":"https://nymrli.top/2018/08/30/Python字典基本操作介绍/","excerpt":"","text":"创建字典 info={} info=dict() 初始化字典 法一 123key = &apos;name&apos;info = &#123; key :&apos;cold&apos;&#125;==&#123;&apos;name&apos;:&apos;cold&apos;&#125; 法二 12info = dict(key = &apos;cold&apos;)==&#123;&apos;key&apos;:&apos;cold&apos;&#125; 法三 1#还有可以使用dict(zip(a,b))其中a,b都是列表,会生成以A中元素为键,B中元素为值的字典 插入新的键值对(更新) info.update(name=‘cold’, blog=‘www.linuxzen.com’) 在字典有没有k这个键时可以使用dict.setdefault(key,value) 还可以使用dict(var = value)其中var可以是变量,也可以不是,注意不用加 或是_dict[‘xxx’]=‘yyy’ 获得键值 确定存在的情况下- info.get(‘xxx’) info[‘xxx’] 不确定是否存在 info.get(‘xxx’) 遍历字典 获得key,再通过key来获得valuefor key in dicprint(%d,%d%(key,_dict[key])) 使用dict.items()for key,value in dic.items()print ‘key is %s,value is %s’%(key,value) 字典删除 del(info['xxx']) or del info['xxx']","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Hello 搭建Hexo博客","slug":"hello-hexo","date":"2018-08-30T13:14:27.000Z","updated":"2019-09-15T08:07:30.942Z","comments":true,"path":"2018/08/30/hello-hexo/","link":"","permalink":"https://nymrli.top/2018/08/30/hello-hexo/","excerpt":"","text":"电脑环境是Windows，安装好git后，所有搭建操作均在git bash内完成 1.需要安装git, node.js, npm 注:第一次安装Git会让配置user信息 123&gt; $git config --global user.name &quot;yourname&quot; #（yourname是git的用户名）&gt; $git config --global user.email &quot;youremail&quot;）&gt; 2.使用npm安装hexo： npm install -g hexo 3.创建hexo文件夹，并单击鼠标右键选择 Git bash：(我的创建路径是：E:\\hexo） 4.在刚刚打开的git bash命令框中操作： 1234$hexo init #hexo 会自动创建网站所需要的文件$npm install #安装依赖包$hexo generate # 等价于hexo g$hexo server #现在可以用127.0.0.1:4000访问hexo默认的hello world界面,等价于hexo s 5.部署到github (https://github.com/)， 首先注册登录,然后创建页面仓库，Repository name 命名必须是 youname.github.io ，（youname 就是你注册时候用的name） ssh-keygen -t rsa -C &quot;email&quot; #生成ssh密钥，按三次回车键，密码为空,这边会生成id_rsa和_rsa.pub文件，打开id_rsa.pub，复制全文添加到GitHub 的Add SSH key中。 最后可以验证一下ssh -T git@github.com,看出现的是不是Hi &quot;Yourname&quot;如果出现了你的github用户名,则成功了 6.下载Hexo主题 $git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载hexo的yilia 模板到自己的文件目录下 打开项目目录下的**_config.yml**文件，更改theme：yilia ▲注意: _config.yml文件中配置时:后面都要加空格,与:隔开 7.开启评论功能：使用gitment $npm install gitment --save #安装gitment 然后在 https://github.com/settings/applications/new 进行注册，获取Client ID和Client Secret ▲注意:其中Authorization callback URL是个坑: 这一项不能乱填,不让就不能&quot;初始化评论&quot;… 应该怎么填呢? 如果你绑定了自己的域名就直接写自己的域名: https://nymrli.top/ 如果没有的话才填写http://Freedomisgood.github.io,否则会一直弹回博客首页,而不能&quot;初始化评论&quot;或者&quot;发表评论&quot; 其中的原因就在于,既可以通过www.nymrli.top解析，也可通过nymrli.top解析,还可以通http://Freedomisgood.github.io解析,而Authorization callback URL只能写一个.(最终解析到的网站)…===&gt;就是nymrli.top △.感谢IsResultXaL提供的思路 打开themes/yilia目录下的_config.yml文件进行修改并保存： 再次生成网站,提交网站:hexo d -g就可以输入网址:https://yourname.github.io打开你的博客了 8.显示文章摘要图片 1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在hexo目录下打开git Bsh或者power Shell,npm install hexo-asset-image --save安装插件 再运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 1![你想输入的替代文字](xxxx/图片名.jpg) ▲ .之前一直失败,原因在于,我写图片链接的时候是直接拖动图片到编辑器中的,路径为![v2-代替文字](E:/hexo/source/_posts/xxxx/图片名.jpg),后来一直错误,无法正常显示后，发现只需要写成![代替文字](xxxx/图片名.jpg)即可… 文章总体框架: 12345678910---layout: phototitle: Hello Hexodate: 2018-08-30 21:14:27tags: - hexo---![代替文字](xxxx/图片名.jpg)&lt;!--more--&gt;正文 →推一个不错的文章Hexo+Coding+Github部署个人博客Error全集,如果出现未能解决的问题,希望能从这篇文章略微得到启发.","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"hexo","slug":"hexo","permalink":"https://nymrli.top/tags/hexo/"}]}]}