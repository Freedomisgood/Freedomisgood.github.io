<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mrli&#39;s Blog</title>
  
  <subtitle>别装作很努力，结局不会陪你演戏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nymrli.top/"/>
  <updated>2020-02-04T10:54:19.602Z</updated>
  <id>https://nymrli.top/</id>
  
  <author>
    <name>Mrli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学会投资——做一个小小的股民</title>
    <link href="https://nymrli.top/2020/02/03/%E5%AD%A6%E4%BC%9A%E6%8A%95%E8%B5%84%E2%80%94%E2%80%94%E5%81%9A%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E7%9A%84%E8%82%A1%E6%B0%91/"/>
    <id>https://nymrli.top/2020/02/03/学会投资——做一个小小的股民/</id>
    <published>2020-02-03T09:03:38.000Z</published>
    <updated>2020-02-04T10:54:19.602Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这一学期任选课选的是投资理财，本也有意接触投资这一方面，因此在开学后不断接触股票相关知识，不断在模拟盘尝试。在2019年11月6日正式关注股票，开始实盘炒股。</p><p>由于很多概念点掌握的不是很清晰，所以决定把所有相关概念全都搜查确认一遍，同时记录下来，有益他人入门。</p></blockquote><h1 id="入门概念"><a class="markdownIt-Anchor" href="#入门概念"></a> 入门概念</h1><h2 id="k线"><a class="markdownIt-Anchor" href="#k线"></a> K线</h2><p><img src="https://bkimg.cdn.bcebos.com/pic/d4628535e5dde7117f5feca7a7efce1b9c1661d6?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5" alt="K线"></p><h3 id="阻力位和支撑位"><a class="markdownIt-Anchor" href="#阻力位和支撑位"></a> 阻力位和支撑位</h3><p>我们把“向上反弹的底点”称为支撑位。用某个价格水平或图表上某个区域来表示。在这个点位下方,买方兴趣强大,足以抗拒卖方形成的强大压力。结果价格在这里停止下跌,回头向上反弹。通常,当前一个向上反弹的底点形成后,就可以确定一个支撑位了。反之则为阻力位.——支撑位表明了，这只股票合理的价格区间，一般在股价上升之后都会有回调过程（即主力验证某一个价位的支撑确实有效，而主动下跌到某个价位）</p><p><img src="http://www.net767.com/book/UploadFiles_8829/200903/2009030719351531.bmp" alt=""></p><h4 id="箱体支撑"><a class="markdownIt-Anchor" href="#箱体支撑"></a> 箱体支撑</h4><p><img src="http://www.net767.com/book/UploadFiles_8829/201004/2010041414000675.gif" alt=""></p><h3 id="辨别阻力位"><a class="markdownIt-Anchor" href="#辨别阻力位"></a> 辨别阻力位</h3><p>当股价在一个价格区域波动时刻越久，表明在这个区域买进的出资人越多，股价跌破这一区域，买进的出资人被套，跟着时刻的推移，侥幸心理削减。当股价从头回到该区域，大多数出资者会选择卖出解套，削减丢失。在这个区域也就形成了阻力位。</p><p>从心理的视点来讲，当股价上涨至一个高点回落之后，若股价再次上涨，许多出资人就会开端猜想这波行情的拐点。当价格挨近前期高点时，为了求稳，便会抛出所持股票，前高也就成为了阻力位。</p><p>我们经过历史来判别的所谓支撑与阻力是不可靠的。如果在一些讲座听到专家只能跟着行情的屁股来定所谓阻力与支撑，而底子不知道这个阻位是否真的能阻住，这个支撑是否能真的撑住。这些观念就是过错的，我们不要轻信，我们最好能够依据自己的经历来辨认阻力位，它对各位的出资实业还是很有含义的。</p><h2 id="股票成交原因"><a class="markdownIt-Anchor" href="#股票成交原因"></a> 股票成交原因</h2><p>股票价格能够成交的原因是因为分歧，A觉得当前价格高估了所以愿意卖出，B觉得当前价格低估了所以愿意买入，互相都认为自己判断正确，对方判断错误，所以都接收对方的出价，当前价格才能够成交。</p><h2 id="成交量"><a class="markdownIt-Anchor" href="#成交量"></a> 成交量</h2><h3 id="放量-放大成交量"><a class="markdownIt-Anchor" href="#放量-放大成交量"></a> 放量-放大成交量</h3><p>放量，就是——放大成交量的意思。成交放量的现象，表示在这个位置分歧更大，更多人卖出，也有更多人买入，最终买入的大于卖出的，还有在当前价格没买到股票的人，只有提高价格去买入了，于是价格就冲过阻力位了。——成交即为换手，因此跟换手率相关。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">换</mi><mi mathvariant="normal">手</mi><mi mathvariant="normal">率</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">成</mi><mi mathvariant="normal">交</mi><mi mathvariant="normal">量</mi></mrow><mrow><mi mathvariant="normal">发</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">总</mi><mi mathvariant="normal">股</mi><mi mathvariant="normal">数</mi><mo stretchy="false">(</mo><mi mathvariant="normal">手</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">换手率 = \frac{成交量}{发行总股数 (手)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">换</span><span class="mord cjk_fallback">手</span><span class="mord cjk_fallback">率</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.613em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">股</span><span class="mord cjk_fallback">数</span><span class="mopen">(</span><span class="mord cjk_fallback">手</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">交</span><span class="mord cjk_fallback">量</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="股市放量的原因"><a class="markdownIt-Anchor" href="#股市放量的原因"></a> 股市放量的原因：</h3><p>有时属于主力出货,有时属于主力换庄</p><p><strong>主力出货：</strong></p><p>个股在低位运行中，突然开始急速拉升，伴随成交量大幅放量，说明主力在趁机<strong>吸筹</strong>，拉高的目地是给散户一点<strong>利润，使他们出局</strong>，主力趁机吸收筹码。<br>个股有可能会从此开始逐步拉升，使散户不敢再追高，眼睁睁看着个股绝尘而去，以至于到最后被迫追高，主力趁机出货。也可能个股还要盘整一段时间，继续折磨散户的耐性，使他们误认为前次的拉高是主力在出货，迫使散户丧失信心，交出筹码。</p><h3 id="成交量数值的意义"><a class="markdownIt-Anchor" href="#成交量数值的意义"></a> 成交量数值的意义:</h3><p>股票价格向上突破阻力位置，比如突破量子沙盘提示的空头防线D或E，<strong>突破向上</strong>，就<strong>需要有比平时多的成交量</strong>，才能冲过D或E继续向上。</p><p>而向下跌破多头防线C不需要过多成交量，多头只要放弃防守，<strong>没有买入的动作和力量，价格就会跌落</strong>，这时候成交量可以不放大。</p><h3 id="放量拉高-打压洗盘"><a class="markdownIt-Anchor" href="#放量拉高-打压洗盘"></a> 放量拉高、打压洗盘</h3><p>放量：将筹码扔出撒向市场，促进股票交易还手，为了能抛出这么多，因此股价会上升；</p><p>缩量：回购入筹码，由于需要买入大量，所以会使股价下降</p><p>ref: <a href="https://zhuanlan.zhihu.com/p/103226043" target="_blank" rel="noopener">主力操盘手法解释</a></p><h2 id="回踩和回落"><a class="markdownIt-Anchor" href="#回踩和回落"></a> 回踩和回落</h2><p><strong>股票回踩</strong>就是股票要上涨之前，主力为了验证某一个价位的支撑确实有效，主动下跌到那个地方重新验证是否支撑有效。回踩的目的就是为了以后上涨可以放心，即使碰到大盘大幅回调，而那个位置的支撑也不会再回到。回踩时是缩量，且阴线很小但很集中。</p><p>回落和回踩都是指的股票下跌这一动作，但回落往往用于<strong>股价的单纯下跌</strong>，即股价达到一个价格后，开始逐步下降；回踩则是指股价达到一个价位后，开始逐步下降，降到一个价格区间后，又开始继续上涨。回踩也可以看作是对上涨趋势的确认。</p><p>ref：<a href="https://zhuanlan.zhihu.com/p/103212473" target="_blank" rel="noopener">回踩有效支撑买入法，做短线的朋友可以收藏！</a></p><h2 id="游资"><a class="markdownIt-Anchor" href="#游资"></a> 游资</h2><p>热钱（Hot Money），是指<a href="https://baike.baidu.com/item/%E6%B8%B8%E8%B5%84/2950921" target="_blank" rel="noopener">游资</a>，或叫投机性短期资金，在商业词典中热钱的定义为：“迅速移向能提供更好回报的任何国家的流动性极高的短期资本 [1] 。而上海证券研发中心认为，传统意义上的热钱主要指国际短期资本，但是根据中国国情热钱既包括国际短期资本，也包括中长期资本。 [1]</p><p>热钱的目的在于用尽量少的时间以钱生钱，是只为追求高回报而在市场上迅速流动的短期投机性资金，纯粹以投机盈利，而不是制造就业、商品或服务。2011年10月新增外汇占款近四年来首度出现<a href="https://baike.baidu.com/item/%E8%B4%9F%E5%A2%9E%E9%95%BF/7106652" target="_blank" rel="noopener">负增长</a>，海外热钱撤离中国。对中国经济造成不同程度的影响。</p><p>▲热钱与正当投资的最大分别是热钱的根本目的在于投机盈利，而不是制造就业、商品或服务。</p><h1 id="实盘操作"><a class="markdownIt-Anchor" href="#实盘操作"></a> 实盘操作</h1><h2 id="t0操作注意事项"><a class="markdownIt-Anchor" href="#t0操作注意事项"></a> <a href="http://www.360doc.com/content/19/0910/07/56121542_860144046.shtml" target="_blank" rel="noopener">T+0操作注意事项</a></h2><p><strong>从做T方式分类：</strong></p><p>半仓滚动做T：每次半仓低位买入相同仓位，然后高点T出，或高点T出后再低位买回相同仓位（最常用和最简单操作方式）</p><p>三成底仓滚动做T：三成底仓，低位买三成仓位，逢高T出三成仓，再逢低买回三成仓，第二天逢高T出三成仓，低位视情况买回三成仓，冲高再T出三成仓，然后视情况逢低买回三成仓，循环滚动，视分时上升或下降趋势正T或倒T操作（熊市更适用，较复杂，需结合1和5分钟MACD等辅助判断）</p><p>7成底仓滚动做T：7成底仓，逢高T出三成仓位，逢低买回三成仓，如果尾盘再跌，再卖出四成底仓，第二天逢低买回四成仓，逢高T出三成仓，逢低买回三成仓，循环滚动，视分时上升或下降趋势正T或倒T操作（牛市更适用，较复杂，需结束1和5分钟MACD等辅助判断）</p><p><strong>做T的注意事项：</strong></p><p>1、立即到证券公司找你的理财经理调低你的交易佣金，越低越好，目前万三是多数人可以调到的；操作成本的降低意味着每次进出操作的利润留下就变多了，这是做T的前提条件—降成本。<br>2、高价股更适合做T，因为短线买卖点非常短暂，要求立即成交，多数是挂委二-委五立即成交的，这样，势必会挂低几个价位。5元股卖低5分钱就是1%，50元股卖低5分钱才0.1%—一降成本。<br>3、深市的股票更适合做T，因为没有加收的过户费——降成本。<br>4、绩优股及中盘以上股更适合做T，绩优股可以确保股价不会快速坐电梯，中盘以上股不容易在暴跌时丧失流动性，从而失去做T机会——提升成功率。<br>5、大盘震荡市、盘整市时更容易做T，大盘或个股单边上扬时做T要迅速，一般在10~15分钟完成一个买入卖出的完整T操作，防止T飞——提升成功率。<br>6、要关注大盘走势，特别是在大盘连续下跌阶段——提升成功率。<br>7、要计算个股上涨和调整的幅度（统计平均的震幅区间）——提升成功率。<br>8、做T不应刻意追求2%以上的价差，越贪心越容易丢票；——提升成功率。<br>9、最好做自己非常熟悉的股票，反复看个股每天的分时图，复盘每日的买入卖出做T点位，看完1000个分时图，自然熟能生巧——提升成功率。</p><p><strong>T+0操作“秘笈”</strong><br>T+0操作“秘笈”一：正向、追涨T+0&quot;<br>T+0操作“秘笈”二：“正向、抄底T+0”<br>T+0操作“秘笈”三：“逆向、追杀T+0&quot;</p><p><strong>【注意事项】：</strong><br>1、T+0最好盘中必须完成，千万别做成加仓动作，尤其是大盘震荡、方向不明的时候；<br>2、T+O是多出来的套利，不做什么都没有，所以别贪，结合大盘和个股，个人经验以盈利2%<br>为目标，不行1%也走；<br>3、只有多研究分时走势，多多试验，才能不断提高成功功率。<br>4、谨慎假突破</p><p>止损是交易中保护自己的重要手段，犹如汽车中的刹车装置，遇到突发情况善于“刹车”，才能确保安全。止损的最终目的是保存实力，提高资金利用率和效率，避免小错铸成大错、甚至导致全军覆没。止损不能规避风险，但可以避免遭到更大的意外风险。</p><h2 id="短线操作"><a class="markdownIt-Anchor" href="#短线操作"></a> 短线操作</h2><p><a href="https://www.55188.com/thread-9067174-1-1.html" target="_blank" rel="noopener"><strong>游资“乔帮主”是谁？曾经11万亏到3万的小散，偶遇高手他转变了</strong></a></p><p>短线操作有两种主流模式，一种是追涨，另外一种是低吸。而在这个股市圈内，或者说游资圈内，低吸模式操作最有名的自然就是“乔帮主”了。他师承独股一箭，其实就是无意中发现了独股一箭的实盘帖，开始研究其交易特点，最终自己悟出来的。</p><h2 id="回踩抄底操作"><a class="markdownIt-Anchor" href="#回踩抄底操作"></a> 回踩抄底操作</h2><p><a href="https://baijiahao.baidu.com/s?id=1652406936105237978&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">一旦股价回踩，掌握“阴线”策略，股价反弹在即，庄家瑟瑟发抖！</a></p><ul><li>支撑线上阴线</li><li>底部巨量短线机会</li><li>金屋藏娇</li></ul><h2 id="尾盘操作"><a class="markdownIt-Anchor" href="#尾盘操作"></a> 尾盘操作</h2><blockquote><p>有经验的老股民，可能会在下午尾盘2点半之后才选股操作，因为接近收盘，风险比较低，尾盘买入的股票在次日上午冲高出货就可以获取利润，安全、刺激、没有后顾之忧。</p></blockquote><p>▲目前个人的操作模式为：早上找高出货， 尾盘找合适价位切入。</p><p><strong>砸尾盘</strong></p><p>尾盘下跌，也可以分为两点半开始下跌和临收盘下跌。一般情况下，尾盘下跌有可能是主力利用尾市的突出去打压出货，也有可能是主力打压洗盘，不管哪种情况，投资者都不要给予参与，因为基本都是主力在打压洗盘，<u>第二个交易日往往还是低开</u>。</p><p><strong>尾盘跳空突破选股法</strong></p><p>选股方法：每天9.25-9.30<strong>开盘价出现时候找股票</strong>!<br>打开60排行榜，把上升2-6个点的股票都添加到板块股中，从里面挨个进行筛选!<br>首先筛选要突破下降趋势线，并且是第一个调控缺口的股票!<br>每天基本有1-3个符合，开盘后看开盘的量能，筛选出来的<strong>股票量</strong>能如何?上涨放量，下跌缩量!<br>股票的<strong>买点一般在尾盘买入</strong>!</p><p>★：<strong>尾盘打板</strong></p><p>看看分时图，入股此时分时白线是回踩黄线不破并处于上升趋势，而且持续有大单买入，这就是我们要在尾盘买进的强势个股，次日冲高获利高抛即可。此方法不但安全，而且收益稳健，是上班族和短线操作者的最佳利器，如果大家都能学懂并理解，那么接下来你的收益将会出现一倍的增长以上。</p><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="决战牛市之经典趋势操盘术"><a class="markdownIt-Anchor" href="#决战牛市之经典趋势操盘术"></a> <a href="http://www.wbfou.com/qtkc/557.html" target="_blank" rel="noopener">决战牛市之《经典趋势操盘术》</a></h2><p>第一个指标：这只个股在趋势上必须摆脱熊市的压力进入了技术牛市。我们要配上的技术指标就是10周与30周长期均线。如果说一只股票还处于技术性熊市中，说明个股还不具备走牛的趋势，只能有反弹。</p><p>第二个指标：一只股票好不好，至少它的走势一定要强于大盘，如果连大盘都不如，哪有强势可言。要配上的第二个指标是RS，用于对比个股与指数走势的强度。</p><p>第三个指标，个股的图形一定要漂亮，要观察个股位置处于什么阶段，是否突破了重要压力位，是否创造了新高，如果个股不能突破下跌通道或历史平台位，就不能说已经具有走在上涨趋势的势头，上涨空间不可能打开。要加入的第三个指标就是趋势通道平台技术和长短期图形识别技术。</p><p>第四个指标，一只股票摆脱了对熊市的技术压力，也强于大盘，从历史重要平台开始突围。买点是否出现，只有内部筹码的博弈已经稳定并处于强势中，才能决定个股多方是否在反攻，才能产生买卖点。要匹配的也是最重要的交易信号指标是RSI，再结合20日均线与成交量进行判断。</p><p>第五个指标，前四个指标已经满足，说明个股已经蓄势启动，这个启动够不够强，有没有持续性，就要看量价关系。</p><p>第六个指标，个股分析的最后一步才是基本面的研究，详细掌握这只股的基本面情况。理解在基本面方面驱动个股上涨的因素是那一种。</p><h2 id="股票小白入门篇_知乎"><a class="markdownIt-Anchor" href="#股票小白入门篇_知乎"></a> <a href="https://zhuanlan.zhihu.com/p/90930638" target="_blank" rel="noopener">股票小白入门篇_知乎</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这一学期任选课选的是投资理财，本也有意接触投资这一方面，因此在开学后不断接触股票相关知识，不断在模拟盘尝试。在2019年11月6日正式关注股票，开始实盘炒股。&lt;/p&gt;
&lt;p&gt;由于很多概念点掌握的不是很清晰，所以决定把所有相关概念全都搜查确认一遍，同
      
    
    </summary>
    
    
      <category term="福利" scheme="https://nymrli.top/tags/%E7%A6%8F%E5%88%A9/"/>
    
  </entry>
  
  <entry>
    <title>PAT冲冲冲——乙级</title>
    <link href="https://nymrli.top/2020/02/02/PAT%E5%86%B2%E5%86%B2%E5%86%B2%E2%80%94%E2%80%94%E4%B9%99%E7%BA%A7/"/>
    <id>https://nymrli.top/2020/02/02/PAT冲冲冲——乙级/</id>
    <published>2020-02-02T08:26:41.000Z</published>
    <updated>2020-02-21T12:24:17.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pat冲冲冲乙级"><a class="markdownIt-Anchor" href="#pat冲冲冲乙级"></a> PAT冲冲冲——乙级</h1><blockquote><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/type/7?page=1" target="_blank" rel="noopener">PAT甲级练习题 ——PAT (Advanced Level) Practice </a><br><a href="https://www.nowcoder.com/pat/5/problems?page=1" target="_blank" rel="noopener">PAT甲级(Advanced Level)真题</a><br><a href="https://www.liuchuo.net/archives/8091" target="_blank" rel="noopener">柳婼 の blog经验</a><br><a href="https://saquarius.com/2019/08/pat%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">saquarius’s blog</a></p><p><a href="https://blog.csdn.net/a617976080/article/details/89676670" target="_blank" rel="noopener">PAT甲级题目及分类总结</a><br><a href="https://blog.csdn.net/richenyunqi/article/details/79958195" target="_blank" rel="noopener">pat甲级题解目录</a></p></blockquote><p>▲报名费256，可以刷<a href="https://www.nowcoder.com/pat" target="_blank" rel="noopener">牛客网</a>的题来获得-50的优惠券，该练习场下的所有题目只要通过都算</p><h2 id="乙级练习题"><a class="markdownIt-Anchor" href="#乙级练习题"></a> 乙级练习题</h2><h3 id="nowcoder数列"><a class="markdownIt-Anchor" href="#nowcoder数列"></a> <a href="https://www.nowcoder.com/pat/2/problem/250" target="_blank" rel="noopener">NowCoder数列</a></h3><blockquote><p>没想到第二题就是考了个数据范围，由于0≤n≤1000000，所以F(n)必然比long long大，而判断3的倍数可表示为===&gt; F(n) % 3 —&gt; (F(n-1)%3 + F(n-2)%3) % 3</p><p>求余运算性质：a = b+c --&gt;  a%d = (b%d+c%d) % d</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">1000000</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">7</span>;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">        f[i]=(f[i<span class="number">-1</span>]%<span class="number">3</span>+f[i<span class="number">-2</span>]%<span class="number">3</span>)%<span class="number">3</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[n]!=<span class="number">0</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="养兔子"><a class="markdownIt-Anchor" href="#养兔子"></a> <a href="https://www.nowcoder.com/pat/2/problem/251" target="_blank" rel="noopener">养兔子</a></h3><blockquote><p>非常经典的斐波那契数列题</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 90+5</span></span><br><span class="line">ll arr[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[n] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客似云来"><a class="markdownIt-Anchor" href="#客似云来"></a> <a href="https://www.nowcoder.com/pat/2/problem/252" target="_blank" rel="noopener">客似云来</a></h3><blockquote><p>斐波那契数列的拓展题，将其中某个区间的值累加输出（需要特判是否为某个点）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 80+5</span></span><br><span class="line">ll arr[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line"></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; arr[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to)&#123;</span><br><span class="line">        ll tmp = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 注意需要特判是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (from == to) tmp = arr[from];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=from; i&lt;= to;i++)&#123;</span><br><span class="line">                tmp += arr[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契凤尾"><a class="markdownIt-Anchor" href="#斐波那契凤尾"></a> <a href="https://www.nowcoder.com/pat/2/problem/253" target="_blank" rel="noopener">斐波那契凤尾</a></h3><blockquote><p>一遍还挺难过的，有不少的坑点</p><p>1.虽然也是斐波那契数列，但是一定要注意前两项的取值<br>2.输出末尾的6位，那么就是%1e6，但是如果有前置0，需要补零，我是使用iomanip中的setw和setfill实现的<br>3.怎么判断超过6位：找出超过6位的n应该算比较简单的方法了吧</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000 + 5</span></span><br><span class="line">ll arr[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        用来找到超过1e6的n</span></span><br><span class="line"><span class="comment">        arr[i] = (arr[i-1] + arr[i-2]);</span></span><br><span class="line"><span class="comment">        if (arr[i] &gt; 1000000)&#123;</span></span><br><span class="line"><span class="comment">             cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">             break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        arr[i] = (arr[i<span class="number">-1</span>]%<span class="number">1000000</span> + arr[i<span class="number">-2</span>]%<span class="number">1000000</span>)%<span class="number">1000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;= <span class="number">30</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">6</span>)&lt;&lt;setfill(<span class="string">'0'</span>) &lt;&lt; arr[n] &lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Po个C的代码，使用printf的格式化输出的特性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    a[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">100000</span>;i++)</span><br><span class="line">      a[i]=(a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>])%<span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=<span class="number">30</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%06d\n"</span>,a[n]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="星际密码"><a class="markdownIt-Anchor" href="#星际密码"></a> <a href="https://www.nowcoder.com/pat/2/problem/254" target="_blank" rel="noopener"> 星际密码</a></h3><blockquote><p>说实话，一开始没看懂题，因为输入的n跟题目里提到的n不是同一个东西：矩阵X为[[1 1],[0 1]]，题目中的n是指多少次幂；而输入里的n是指有多少个密码，真正的n其实是第二行的输入Xi</p><p>那么分析下思路，Xi=1时<mark>1，Xi=2时</mark>2，Xi=3时==3</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000 + 5</span></span><br><span class="line">ll arr[N];</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initFib</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        arr[i] = (arr[i<span class="number">-1</span>]%<span class="number">10000</span> + arr[i<span class="number">-2</span>]%<span class="number">10000</span>)%<span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> input[<span class="number">100</span>+<span class="number">5</span>];</span><br><span class="line">    initFib();</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>)&lt;&lt;setfill(<span class="string">'0'</span>) &lt;&lt; arr[tmp] ;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/PAT冲冲冲——乙级/E:%5Chexo%5Csource_posts%5CPAT%E5%86%B2%E5%86%B2%E5%86%B2%5CFib.jpg" alt="Fib"></p><h3 id="母牛的故事"><a class="markdownIt-Anchor" href="#母牛的故事"></a> <a href="https://www.nowcoder.com/pat/2/problem/255" target="_blank" rel="noopener"> 母牛的故事</a></h3><blockquote><p>变形的Fib，公式更新为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = f(n-1) + f(n-3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></p><p>最主要的就是确定前几项，比较好的是样例都给出了2==&gt;2,4==&gt;4,5==&gt;6，这样就比较好确定<strong>每头小母牛从第四个年头开始，每年年初也生一头小母牛</strong>到底是什么意思了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000 + 5</span></span><br><span class="line">ll arr[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initFib</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; arr[<span class="number">2</span>] = <span class="number">2</span>;arr[<span class="number">3</span>]=<span class="number">3</span>;arr[<span class="number">4</span>]=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    initFib();</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="童年生活二三事"><a class="markdownIt-Anchor" href="#童年生活二三事"></a> <a href="https://www.nowcoder.com/pat/2/problem/256" target="_blank" rel="noopener">童年生活二三事</a></h3><blockquote><p>Fib数列的板子题，只不过需要理解一下</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 90 + 5</span></span><br><span class="line">ll arr[N];</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initFib</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    initFib();</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[n]  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蜜蜂寻路"><a class="markdownIt-Anchor" href="#蜜蜂寻路"></a> <a href="https://www.nowcoder.com/pat/2/problem/257" target="_blank" rel="noopener">蜜蜂寻路</a></h3><blockquote><p>如果固定起点为1，计算到某个位置的走法数的话，跟走阶梯其实是一种思路，就是f(n) = f(n-1) + f(n-2)，即第n个位置的走法数=第n-1位置走法数 + 第n-2位置走法数</p></blockquote><table><thead><tr><th>1-&gt;2</th><th>1</th><th>2-&gt;3</th><th>1</th><th>3-&gt;4</th><th>1</th></tr></thead><tbody><tr><td>1-&gt;3</td><td>2</td><td>2-&gt;4</td><td>2</td><td>3-&gt;5</td><td>2</td></tr><tr><td>1-&gt;4</td><td>3</td><td>2-&gt;5</td><td>3</td><td>3-&gt;6</td><td>3</td></tr><tr><td>1-&gt;5</td><td>5</td><td>2-&gt;6</td><td>5</td><td>3-&gt;7</td><td>5</td></tr><tr><td>1-&gt;6</td><td>8</td><td>2-&gt;7</td><td>8</td><td>3-&gt;8</td><td>8</td></tr></tbody></table><p>可以发现其中的规律：走法数一直是Fib数列，而值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mrow><mi>t</mi><mi>o</mi></mrow></msub><mo>−</mo><msub><mi>N</mi><mrow><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">fib(N_{to} - N_{from})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>▲但这题还有一个难点在于用例的范围(0 &lt; a &lt; b &lt; 2<sup>31)，即b-a~=2</sup>32-1，为int最大范围，会导致的问题有两个</p><ol><li><p>fib数列通常使用数组来存储，但是无法开个2^32大小的数组</p><p>==&gt;滚动数组、递推（不用数组）</p></li><li><p>输出的Fib(n)就远远超过long long了，因此要么模拟大数相加，那么另寻他法。</p><p>==&gt;△还需要注意到的一点是,<strong>输出数据结果范围是 [0, 2^63)</strong>，那么意思是题目要求的输出其实是在long long 范围内的，那么就可以考虑截取输出了</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">// ll credit = 9.2e18;开的足够大能过样例就行</span></span><br><span class="line">ll credit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 幂计算</span></span><br><span class="line"><span class="comment"> * @author mrli 2019-10-27</span></span><br><span class="line"><span class="comment"> * @param  n [less than 63]</span></span><br><span class="line"><span class="comment"> * @return   [long long type]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        ans *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> del)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (del == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(del == <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll f1 = <span class="number">1</span>; ll f2=<span class="number">2</span>;</span><br><span class="line">        ll ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=del;i++)&#123;</span><br><span class="line"><span class="comment">// ans = f1 + f2 ;也过了</span></span><br><span class="line">            ans = ( f1%(credit) + f2%(credit) )%credit;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    credit = <span class="built_in">pow</span>(<span class="number">63</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>( n-- )&#123;</span><br><span class="line">        <span class="keyword">int</span> from, to;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to;</span><br><span class="line">        ll ans;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Fib(to-from) &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了别人的题解后,发现想多了。题目的意思是<strong>得分点的输出值都在long long 范围内，而不是需要你把输出值压缩在long long范围内</strong>，果然去掉 %运算也过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//蜜蜂寻路</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(x, n) memset(x,n,sizeof(x));</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">2147483648</span>+<span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line">LL dp[<span class="number">3</span>]; <span class="comment">//滚动数组</span></span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(dp, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; b-a+<span class="number">1</span>; i++)</span><br><span class="line">        dp[i%<span class="number">3</span>] = dp[<span class="number">0</span>]+dp[<span class="number">1</span>]+dp[<span class="number">2</span>]-dp[i%<span class="number">3</span>]; <span class="comment">//即dp[i]=dp[i-1]+dp][i-2]</span></span><br><span class="line"> </span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        ans = max(dp[i], ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//从1到4和从2到5答案是一样的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分数运算"><a class="markdownIt-Anchor" href="#分数运算"></a> <a href="https://www.nowcoder.com/pat/2/problem/261" target="_blank" rel="noopener"> 分数运算</a></h3><blockquote><p>牛客网周赛做到过一次，感觉当时写的比现在的简单。难点在<strong>使用GCD进行约分</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辗转相除法,求最大公约数</span></span><br><span class="line"><span class="comment"> * @author mrli 2019-10-28</span></span><br><span class="line"><span class="comment"> * @param  a [description]</span></span><br><span class="line"><span class="comment"> * @param  b [description]</span></span><br><span class="line"><span class="comment"> * @return   [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1,a2,b1,b2;</span><br><span class="line">    <span class="keyword">char</span> op3;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">scanf</span>(<span class="string">"%d/%d %d/%d %c"</span>, &amp;a1, &amp;a2, &amp;b1, &amp;b2, &amp;op3) != EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> fenmu;</span><br><span class="line">        <span class="keyword">int</span> fenzi;</span><br><span class="line">        <span class="keyword">if</span> (op3 == <span class="string">'+'</span>)&#123;</span><br><span class="line">            fenmu = a2*b2;</span><br><span class="line">            fenzi = a1*b2+a2*b1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op3 == <span class="string">'-'</span>)&#123;</span><br><span class="line">            fenmu = a2*b2;</span><br><span class="line">            fenzi = a1*b2-a2*b1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op3 == <span class="string">'*'</span>)&#123;</span><br><span class="line">            fenmu = a2*b2;</span><br><span class="line">            fenzi = a1*b1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//if (op3 == '*')&#123;</span></span><br><span class="line">            fenmu = a2*b1;</span><br><span class="line">            fenzi = a1*b2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出最大公因子,约分</span></span><br><span class="line">        <span class="keyword">int</span> common = gcd(fenmu,fenzi);</span><br><span class="line">        <span class="keyword">int</span> res_zi = fenzi/common;</span><br><span class="line">        <span class="keyword">int</span> res_mu = fenmu/common;</span><br><span class="line">        <span class="keyword">if</span> ( res_mu * res_zi &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(fenzi/common) &lt;&lt; <span class="string">'/'</span> &lt;&lt; <span class="built_in">abs</span>(fenmu/common) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt;<span class="built_in">abs</span>(fenzi/common) &lt;&lt; <span class="string">'/'</span> &lt;&lt; <span class="built_in">abs</span>(fenmu/common) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解因数"><a class="markdownIt-Anchor" href="#分解因数"></a> <a href="https://www.nowcoder.com/pat/2/problem/262" target="_blank" rel="noopener"> 分解因数</a></h3><blockquote><p>使用小学的短除法，我们很清楚的知道，要想求出它的每一个质因数，我们需要用质数去试除。<code>90</code>能被<code>2</code>整除，那就拿商继续除以<code>2</code>，除不尽就换<code>3</code>，一直到除到质数为止。基础代码框架类似判断质数，只是被判断的数字在过程中不断被除，最终循环结束的时候，那个被处理过的数字，就是最后一个质因数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpn = n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span> ( tmpn%i == <span class="number">0</span> &amp;&amp; tmpn != i)&#123;</span><br><span class="line">                tmpn /= i;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" * "</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmpn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的第一次做法：</p><blockquote><p>一直TLE，估计这种的话，必须得线性筛，我搜了几个题解的结果也证明除了上述题解，其他的都是线性筛，上面的就比较巧妙</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> num )</span></span>&#123;</span><br><span class="line">     <span class="comment">//两个较小数另外处理</span></span><br><span class="line">     <span class="keyword">if</span> (num==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">if</span>(num ==<span class="number">2</span>|| num==<span class="number">3</span> )</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">     <span class="comment">//不在6的倍数两侧的一定不是质数</span></span><br><span class="line">     <span class="keyword">if</span>(num %<span class="number">6</span>!= <span class="number">1</span>&amp;&amp;num %<span class="number">6</span>!= <span class="number">5</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">//在6的倍数两侧的也可能不是质数</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">5</span>;i &lt;= <span class="built_in">sqrt</span>( num); i+=<span class="number">6</span> )</span><br><span class="line">         <span class="keyword">if</span>(num %i== <span class="number">0</span>||num %(i+ <span class="number">2</span>)==<span class="number">0</span> )</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">     <span class="comment">//排除所有，剩余的是质数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> ;</span><br><span class="line">        <span class="keyword">int</span> tmpn = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tmpn;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> ( isPrime(i) &amp;&amp; n%i == <span class="number">0</span>)&#123;</span><br><span class="line">                n /= i;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    first = <span class="literal">false</span>;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; i ; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt;  <span class="string">" * "</span> &lt;&lt; i ; </span><br><span class="line">                <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="因子个数"><a class="markdownIt-Anchor" href="#因子个数"></a> <a href="https://www.nowcoder.com/pat/2/problem/264" target="_blank" rel="noopener">因子个数</a></h3><blockquote><p>用到了上题的结论，<strong>一个正整数总可以分解成一个或多个素数的积</strong>，一开始理解错题目了，以为是所有因数的个数，其实是<strong>因数的种数</strong>，比如20-&gt;2是因为2，2，5；30-&gt;3是因为2，3，5。</p><p>因此这边还是需要素数判别，卡的点也在这，要用线性筛，其实就是上题的回答方式不同罢了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (tmp%i==<span class="number">0</span>)&#123;</span><br><span class="line">                tmp/=i;</span><br><span class="line">                <span class="keyword">if</span> (first)&#123;</span><br><span class="line">                    first = !first;</span><br><span class="line">                    ans ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while( cin &gt;&gt; n)&#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        int tmp = n;</span><br><span class="line"></span><br><span class="line">        for (int i = 2; i &lt;= sqrt(n); ++i)&#123;</span><br><span class="line">            // bool first = true;</span><br><span class="line">            if (tmp%i==0)&#123;</span><br><span class="line">                while (tmp%i==0)&#123;</span><br><span class="line">                   tmp/=i;</span><br><span class="line">                &#125;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (tmp!=1) ans++;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="skew数"><a class="markdownIt-Anchor" href="#skew数"></a> <a href="https://www.nowcoder.com/pat/2/problem/266" target="_blank" rel="noopener"> skew数</a></h3><blockquote><p>模拟题、实现一个幂运算</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        ans *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; s )&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'2'</span>)&#123;</span><br><span class="line">                ans += <span class="number">2</span>*(pow2(size-i)<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (s[i]-<span class="string">'0'</span>)*(pow2(size-i)<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一的个数"><a class="markdownIt-Anchor" href="#一的个数"></a> <a href="https://www.nowcoder.com/pat/2/problem/267" target="_blank" rel="noopener"> 一的个数</a></h3><blockquote><p>非常基础的一道题：r进制表示</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, r;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n%r==<span class="number">1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            n /= r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外星人的语言"><a class="markdownIt-Anchor" href="#外星人的语言"></a> <a href="https://www.nowcoder.com/pat/2/problem/268" target="_blank" rel="noopener"> 外星人的语言</a></h3><blockquote><p>r进制的拓展，需要将各位输出出来，由于是逆序的，所以需要一1.个栈来反转一下、或是2.使用string的反转功能</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, r;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="comment">// 0-9</span></span><br><span class="line">            <span class="keyword">char</span> c = n%r+<span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span> (n%r&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// A-F</span></span><br><span class="line">                c = n%r<span class="number">-10</span>+<span class="number">65</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n /= r;</span><br><span class="line">            <span class="comment">// 不直接cout，而是存栈</span></span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="comment">// 取出栈里的内容</span></span><br><span class="line">            <span class="keyword">char</span> c = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数位和"><a class="markdownIt-Anchor" href="#数位和"></a> <a href="https://www.nowcoder.com/pat/2/problem/270" target="_blank" rel="noopener"> 数位和</a></h3><blockquote><p>代码为<a href="#%E4%B8%80%E7%9A%84%E4%B8%AA%E6%95%B0">一的个数</a>+<a href="#%E5%A4%96%E6%98%9F%E4%BA%BA%E7%9A%84%E8%AF%AD%E8%A8%80">外星人的语言</a>的结合版。</p><p>题目要求，将数n，先表示成r进制的形式，然后再计算r进制下n的位数和，然后再用r进制来表示位数和的结果</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ACM比赛中cin,的使用比较耗时,因为默认的时候，cin与stdin总是保持同步的，使用这句可以使cin达到和scanf相差无几的输入效率。</span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, r;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            ans += n%r;</span><br><span class="line">            n /= r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(ans)&#123;</span><br><span class="line">            <span class="comment">// 0-9</span></span><br><span class="line">            <span class="keyword">char</span> c = ans%r+<span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans%r&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// A-F</span></span><br><span class="line">                c = ans%r<span class="number">-10</span>+<span class="number">65</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans /= r;</span><br><span class="line">            <span class="comment">// 不直接cout，而是存栈</span></span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="comment">// 取出栈里的内容</span></span><br><span class="line">            <span class="keyword">char</span> c = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进制回文数"><a class="markdownIt-Anchor" href="#进制回文数"></a> <a href="https://www.nowcoder.com/pat/2/problem/272" target="_blank" rel="noopener">进制回文数</a></h3><blockquote><p>还是r进制的拓展，</p><p>1.r需要用个2-16的循环<br>2.判断字符串的镜像对称s[i] != s[ssize-i-1]<br>3.踩了个坑,n每次都会被除到很小,因此需要用个临时变量来处理</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; N)&#123;</span><br><span class="line">        <span class="keyword">bool</span> yes=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">2</span>; r &lt;= <span class="number">16</span>; ++r)&#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">int</span> n = N;</span><br><span class="line">            <span class="keyword">while</span>(n)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = n%r+<span class="number">48</span>;</span><br><span class="line">                <span class="keyword">if</span> (n%r&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">                    c = n%r<span class="number">-10</span>+<span class="number">65</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                n /= r;</span><br><span class="line">                s += c;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测出r进制变换时,n已经被除的很小了,因此需要用个临时变量</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; r &lt;&lt; "进制：" &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// for (int i = 0; i &lt; s.size(); ++i)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; s[i] &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//     /* code */</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">bool</span> mirror = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> ssize = s.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ssize/<span class="number">2</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[ssize-i<span class="number">-1</span>])&#123;</span><br><span class="line">                    mirror = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mirror)&#123;</span><br><span class="line">                 yes=<span class="literal">true</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (yes) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发邮件"><a class="markdownIt-Anchor" href="#发邮件"></a> <a href="https://www.nowcoder.com/pat/2/problem/274" target="_blank" rel="noopener"> 发邮件</a></h3><blockquote><p>一道数学题，递推公式为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f(n) = (n-1)*[f(n-1)+f(n-2)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></p><p>坑点:超出了int，需要用longlong</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">email</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n<span class="number">-1</span>)*(email(n<span class="number">-1</span>)+email(n<span class="number">-2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n )&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; email(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说反话-20"><a class="markdownIt-Anchor" href="#说反话-20"></a> <a href="https://www.nowcoder.com/pat/2/problem/4075" target="_blank" rel="noopener"> 说反话 (20)</a></h3><blockquote><p>考查了：对行的读取、字符串的切割。</p><p>本来还以为考了个string的反转，结果比想象中的更简单一点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( getline(<span class="built_in">cin</span>, s) )&#123;</span><br><span class="line">        <span class="built_in">stringstream</span> strings;</span><br><span class="line">        <span class="built_in">string</span> tmps;</span><br><span class="line">        strings &lt;&lt; s;</span><br><span class="line">        <span class="keyword">while</span>( getline(strings, tmps, <span class="string">' '</span>) )&#123;</span><br><span class="line">            ss.push(tmps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!ss.empty())&#123;</span><br><span class="line">            <span class="built_in">string</span> couts = ss.top();</span><br><span class="line">            ss.pop();</span><br><span class="line">            <span class="keyword">if</span> (!ss.empty())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; couts &lt;&lt;<span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; couts ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充string的反转"><a class="markdownIt-Anchor" href="#补充string的反转"></a> 补充——string的反转：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*法一:使用string::reverse_iterator迭代器,直接用iterator会报错*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span>::reverse_iterator it=couts.rbegin(); it != couts.rend() ; ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*法二:使用algorithm算法中的reverse函数*/</span></span><br><span class="line"><span class="comment">// 会修改str中的内容</span></span><br><span class="line">reverse(str.begin(),str.end());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*法三:使用使用string.h中的strrev函数</span></span><br><span class="line"><span class="comment">△只能处理char[],不支持string类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span> s[]=<span class="string">"hello"</span>;</span><br><span class="line">strrev(s);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*法四:自己编写*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;i&lt;j;i++,j--)&#123;</span><br><span class="line">        <span class="keyword">char</span> c=s[i];</span><br><span class="line">        s[i]=s[j];</span><br><span class="line">        s[j]=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一元多项式求导-25"><a class="markdownIt-Anchor" href="#一元多项式求导-25"></a> <a href="https://www.nowcoder.com/pat/2/problem/4076" target="_blank" rel="noopener">一元多项式求导 (25)</a></h3><blockquote><p>被读取方式卡了会</p><p>这边有个坑点: 忽略了常数项的问题<br>比如 输入 2 0<br>应该输出 0 0</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span>,coe;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;coe,&amp;<span class="built_in">exp</span>)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,coe*<span class="built_in">exp</span>,<span class="built_in">exp</span><span class="number">-1</span>);</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="literal">false</span>) <span class="built_in">printf</span>(<span class="string">"0 0\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别人的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poly</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> coef;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125;<span class="keyword">typedef</span> poly;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> coef;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;poly&gt; q;</span><br><span class="line">    <span class="comment">// scanf和getchar合用比较方便,cin再用getchar无效</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;coef, &amp;index) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span> (index!=<span class="number">0</span>)&#123;</span><br><span class="line">            poly *p = <span class="keyword">new</span> poly();</span><br><span class="line">            p-&gt;coef = coef*index;</span><br><span class="line">            p-&gt;index = index<span class="number">-1</span> ;</span><br><span class="line">            q.push(*p);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放最后能过,放最初的时候有些过不了</span></span><br><span class="line">        <span class="keyword">if</span> (getchar()==<span class="string">'\n'</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q.size()==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"0 0\n"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            poly p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (p.coef != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (q.empty())</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, p.coef, p.index );</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d "</span>, p.coef, p.index );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷完了牛客网PAT乙级练习题的第一、第三页。大多都是些模拟题、简单题，相当于弱一点的蓝桥杯省赛。由于报名考的是甲级，所以就没继续做下去了…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pat冲冲冲乙级&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pat冲冲冲乙级&quot;&gt;&lt;/a&gt; PAT冲冲冲——乙级&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sshpass——shell脚本实现SSH连接其他主机并执行终端命令</title>
    <link href="https://nymrli.top/2019/12/25/sshpass%E2%80%94%E2%80%94shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0SSH%E8%BF%9E%E6%8E%A5%E5%85%B6%E4%BB%96%E4%B8%BB%E6%9C%BA%E5%B9%B6%E6%89%A7%E8%A1%8C%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/"/>
    <id>https://nymrli.top/2019/12/25/sshpass——shell脚本实现SSH连接其他主机并执行终端命令/</id>
    <published>2019-12-25T09:29:08.000Z</published>
    <updated>2019-12-25T10:16:16.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sshpass"><a class="markdownIt-Anchor" href="#sshpass"></a> sshpass</h1><blockquote><p>ssh登陆不能在命令行中指定密码。sshpass的出现，解决了这一问题。即sshpass可以用于非交互SSH的密码验证，<strong>一般用在sh脚本中，无须再次输入密码</strong>。</p></blockquote><p>sshpass允许用<code>-p</code>参数指定明文密码，然后直接登录远程服务器。(支持密码从命令行、文件、环境变量中读取)</p><p>1.安装<code>sudo apt install sshpass</code></p><p>2.使用说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -p 直接指定密码</span></span><br><span class="line">sshpass -p '123456' ssh user_name@host_ip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f: -f filename <span class="comment">#后跟保存密码的文件名，密码是文件内容的第一行。</span></span></span><br><span class="line">[root@zhu ~]# cat 1.txt</span><br><span class="line">123456</span><br><span class="line">[root@zhu ~]# sshpass -f 1.txt  ssh root@192.168.56.102</span><br><span class="line">Last login: Fri Apr 18 13:48:20 2014 from 192.168.56.101</span><br><span class="line">[root@jiang ~]# exit</span><br><span class="line">logout</span><br><span class="line">Connection to 192.168.56.102 closed.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -e <span class="comment">#将环境变量SSHPASS作为密码</span></span></span><br><span class="line">[root@zhu ~]# export SSHPASS=123456</span><br><span class="line">[root@zhu ~]# sshpass -e  ssh root@192.168.56.102</span><br><span class="line">Last login: Fri Apr 18 13:51:45 2014 from 192.168.56.101</span><br><span class="line">[root@jiang ~]# exit</span><br><span class="line">logout</span><br><span class="line">Connection to 192.168.56.102 closed.</span><br></pre></td></tr></table></figure><h1 id="shell脚本实现ssh连接其他主机并执行终端命令"><a class="markdownIt-Anchor" href="#shell脚本实现ssh连接其他主机并执行终端命令"></a> shell脚本实现SSH连接其他主机并执行终端命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">command</span> -v &lt;the_command&gt; 检测命令是否存在返回命令所在路径,等价于<span class="built_in">which</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> [ -x file ] 如果文件存在且可执行</span></span><br><span class="line">if ! [ -x "$(command -v sshpass)" ]; then</span><br><span class="line">  sudo apt-get install sshpass</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">port=20005</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> -e 会进行转义</span></span><br><span class="line">echo -e "\n请输入用户名！\n"</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">read</span>-将交互输入保存在变量中</span></span><br><span class="line">read name</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获得当前脚本的工作路径</span></span><br><span class="line">dir=$(cd $(dirname $0);pwd)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 分割-&gt;获得文件名</span></span><br><span class="line">file_name="$&#123;dir##*/&#125;"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 传输文件</span></span><br><span class="line">echo -e "\n[开始传输文件]\n"</span><br><span class="line">sshpass -p "$key" scp -r -P  $port $dir username@IP_address:/data/cluster/$name</span><br><span class="line">if [ $pool -eq 1 ]||[ $pool -eq 2 ]||[ $pool -eq 3 ]</span><br><span class="line">then </span><br><span class="line">    # remotessh为标记符,下面的内容全部重定向到ssh连接的终端中, 一定要保证下面的全是以字符串的形式</span><br><span class="line">    # 由于shell会进行预转换,所以shell特殊的量需要额外注意,否则结果将只会是当前主机的。因此需要加\</span><br><span class="line">    # man sshpass中提示:多个-t选项强制分配tty，即使ssh没有本地tty,所以使用-tt参数来强制伪终端分配(表示为这个连接分配TTY)，即使标准输入不是终端，否则退出后会提示`Pseudo-terminal will not be allocated because stdin is not a terminal的错`。 即指明是来自脚本的调用</span><br><span class="line">    # 控制终端（/dev/tty）就是当前进程的控制终端的设备特殊文件，可以进行写入写出</span><br><span class="line">    sshpass -p "$key" ssh -tt -p $(($port+$pool)) username@IP_address &lt;&lt; remotessh</span><br><span class="line">Condor_number=\`condor_q | grep jobs | awk '&#123;print \$1&#125;'\`</span><br><span class="line">if [ \$Condor_number -le 1 ]</span><br><span class="line">then echo -e "\n创建任务失败！\n"</span><br><span class="line">else echo -e "\n创建任务成功！\n"</span><br><span class="line">fi</span><br><span class="line">exit</span><br><span class="line">remotessh</span><br><span class="line">else</span><br><span class="line">echo -e "没有该资源池\n"</span><br><span class="line">exit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><code>man sshpass</code>中关于-t参数的说明</p><blockquote><p>Force pseudo-terminal allocation.  This can be used to execute arbitrary screen-based programs on a remote machine, which can be very useful, e.g. when implementing menu services.  Multiple -t options force tty allocation, even if ssh has no local tty.</p></blockquote><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h1><p>所以实现的方法主要是:</p><ul><li>SSHpass非交互式登录</li><li>SSH终端执行多条命令</li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><p><a href="https://blog.csdn.net/wyl9527/article/details/72770455" target="_blank" rel="noopener">ssh@host:ssh切换到其他机器上执行多条命令</a><br><a href="https://blog.csdn.net/qq_39584315/article/details/87189114" target="_blank" rel="noopener">Shell表达式，${file##*/} 取后缀</a><br><a href="https://blog.csdn.net/liyyzz33/article/details/84836255" target="_blank" rel="noopener">shell-if表达式（-f,-d,-s,-r,-w,-x,-eq,-ne,-ge,-gt,-le,-lt ）</a><br><a href="https://majing.io/posts/10000009411212" target="_blank" rel="noopener">Linux检测命令是否存在</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sshpass&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sshpass&quot;&gt;&lt;/a&gt; sshpass&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;ssh登陆不能在命令行中指定密码。sshpass的出现，解决了这一问题。即sshpass
      
    
    </summary>
    
    
      <category term="运维" scheme="https://nymrli.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Linux" scheme="https://nymrli.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>树莓派初始化操作</title>
    <link href="https://nymrli.top/2019/12/12/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C/"/>
    <id>https://nymrli.top/2019/12/12/树莓派初始化操作/</id>
    <published>2019-12-12T10:59:06.000Z</published>
    <updated>2019-12-12T11:21:49.504Z</updated>
    
    <content type="html"><![CDATA[<p>安装系统镜像:</p><p><a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">官网下载镜像</a>，解压下载好的Zip文件会得到.img镜像文件。下载win32DiskImage</p><p>方式:</p><ul><li>SSH</li><li>VNC</li><li>Xrdp</li></ul><p>系统设置:</p><p>$ sudo raspi-reconfig</p><p>1.安装字体</p><blockquote><p>默认安装的是英文字体，如果时区选择中文，将会乱码，因此需要安装中文字体进行汉化。</p></blockquote><p><code>sudo apt-get install ttf-wqy-zenhei</code></p><p>2.安装中文输入发</p><p>3.修改键盘布局</p><blockquote><p>键盘布局默认是英标的，需要将其改成美标</p></blockquote><p>输入<code>sudo dpkg-reconfigure keyboard-configuration</code>后选择通用的104键PC键盘(Generic 104 Key PC),在Layout中选择Ohter,然后在选项中选择English(US)，然后不断选择OK退出即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装系统镜像:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.raspberrypi.org/downloads/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网下载镜像&lt;/a&gt;，解压下载好的Zip文件会得到.img镜像文件。下载win32D
      
    
    </summary>
    
    
      <category term="嵌入式" scheme="https://nymrli.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ACM-网络流</title>
    <link href="https://nymrli.top/2019/12/08/ACM-%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>https://nymrli.top/2019/12/08/ACM-网络流/</id>
    <published>2019-12-08T11:03:34.000Z</published>
    <updated>2019-12-08T11:48:50.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大流"><a class="markdownIt-Anchor" href="#最大流"></a> 最大流</h1><h2 id="ff算法"><a class="markdownIt-Anchor" href="#ff算法"></a> FF算法</h2><blockquote><p>最基本找増广路的算法</p></blockquote><h3 id="dinic实现基础的ff算法"><a class="markdownIt-Anchor" href="#dinic实现基础的ff算法"></a> dinic实现(基础的FF算法)</h3><blockquote><p><strong>反边</strong>：我们知道，当我们在寻找增广路的时候，在前面找出的不一定是最优解，如果我们在减去残量网络中正向边的同时将相对应的反向边加上对应的值，我们就相当于可以反悔从这条边流过。</p></blockquote><p>技巧：flow[u]正边，flow[u^1]反边<br>建边的时候是同时建的，比如1的反边为2，2的反边为1，▲边不能从0开始</p><p>主要思路：</p><ul><li>求增广路</li><li>分层图</li></ul><h4 id="dinic的优化"><a class="markdownIt-Anchor" href="#dinic的优化"></a> dinic的优化</h4><ul><li><p>当前弧优化(作用不明显)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最原始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now==aim)<span class="keyword">return</span> fl;</span><br><span class="line">    <span class="keyword">int</span> f=e;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=fir[now];u &amp;&amp; fl;u=nxt[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(flow[uj&amp;&amp;deep[to[u]]==deep[now]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=dfs(to[u],min(fl,flow[u]));</span><br><span class="line">            flow[u]-=x;flow[u^<span class="number">1</span>]+=x;fl-=x;f+=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lf)deep[now]=<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前弧优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now==aim) <span class="keyword">return</span> fl;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 修改为curfir[now]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=curfir[now];u&amp;&amp;fl;u=nxt[u])&#123;</span><br><span class="line">        curfir=u;<span class="comment">// 加了此处</span></span><br><span class="line">        <span class="keyword">if</span>(flow[u]&amp;&amp;deep[to[u]]==deep[now]+<span class="number">1</span>)&#123;</span><br><span class="line">            int dfs(to[u],min(fl,flow[u]));</span><br><span class="line">            flow[u]-=x;flow[u^<span class="number">1</span>]+=x;fl-=x;f+=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)deep[now]=<span class="number">-2</span>;<span class="comment">// 炸点优化</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多路增广</p></li><li><p>炸点</p></li></ul><p><strong>最大流最小割定理</strong>：最小割总和的权值==最大流的值，对于每张图都是成立的。（网络流的对称形式）</p><p>具体代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;<span class="comment">// 外层循环</span></span><br><span class="line">aim = T;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs(s, t))&#123;</span><br><span class="line">ret += dfs(s, <span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;<span class="comment">// 建立分层图</span></span><br><span class="line"><span class="built_in">memset</span>(deep,<span class="number">0</span>,(tot+<span class="number">2</span>)&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    deep[S]=<span class="number">1</span>;d1[<span class="number">1</span>]=S;<span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head!=tail)&#123;</span><br><span class="line">    <span class="keyword">int</span> v=dl[++head];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=fir[v];u;u=nxt[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(flow[u]&amp;&amp;!deep[to[u]])&#123;</span><br><span class="line">            deep[to[u]]=deep[v]+<span class="number">1</span>;</span><br><span class="line">            d1[++tail]=to[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fl)</span></span>&#123;<span class="comment">// dfs找増广路</span></span><br><span class="line">    <span class="keyword">if</span>(now==aim) <span class="keyword">return</span> fl;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// // 当前弧优化,修改为curfir[now]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=curfir[now];u&amp;&amp;fl;u=nxt[u])&#123;</span><br><span class="line">        curfir=u;<span class="comment">// 加了此处</span></span><br><span class="line">        <span class="keyword">if</span>(flow[u]&amp;&amp;deep[to[u]]==deep[now]+<span class="number">1</span>)&#123;</span><br><span class="line">            int dfs(to[u],min(fl,flow[u]));</span><br><span class="line">            flow[u]-=x;flow[u^<span class="number">1</span>]+=x;fl-=x;f+=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)deep[now]=<span class="number">-2</span>;<span class="comment">// 炸点优化</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ek算法"><a class="markdownIt-Anchor" href="#ek算法"></a> EK算法</h2><blockquote><p>引入了反相边：在原有的有向图上引入了反向的边，且容量相等</p></blockquote><p><strong>执行过程：</strong><br>BFS找増广路</p><ul><li>找到的话，更新最大流、残余网路</li><li>找不到则走完了</li></ul><p>两者的思想都是：找増广路，找到找不到为止</p><p>参考:</p><p><a href="https://www.bilibili.com/video/av18567992?p=1" target="_blank" rel="noopener">最大流（最小割）的EK算法</a></p><h1 id="最小费用最大流"><a class="markdownIt-Anchor" href="#最小费用最大流"></a> 最小费用最大流</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最大流&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#最大流&quot;&gt;&lt;/a&gt; 最大流&lt;/h1&gt;
&lt;h2 id=&quot;ff算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ff算法&quot;&gt;&lt;/a&gt; FF算法&lt;/h2&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ACM-树状数组和线段树</title>
    <link href="https://nymrli.top/2019/12/07/ACM-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://nymrli.top/2019/12/07/ACM-树状数组和线段树/</id>
    <published>2019-12-07T05:04:53.000Z</published>
    <updated>2019-12-08T11:44:32.293Z</updated>
    
    <content type="html"><![CDATA[<p><strong>高性能问题：</strong><br>Q：需求：（老板给你分了台2GHz单核，内存500M的服务器然后让你写程序）程序每秒会收到一组数据，每组数据包含10万条命令，总共会有100万个仓库，每个仓库库存没有上限且可为负，库存初始为0。<strong>你需要在一秒内完成全部的命令</strong>，然后将查询结果按顺序得出后传回，命令如下：</p><ul><li><code>Add i j</code>，i和j为正整数，表示第i个仓库增加j个库存（j不超过220）</li><li><code>Sub i j</code>，i和j为正整数，表示第i个仓库减少个库存（j不超过220）</li><li><code>Query i j</code>，i和j为正整数，i&lt;=j，表示询问第i到第个仓库的总库存；End 表示结束，这条命令在每组数据最后出现；</li></ul><p>思路一：用array去存储每个仓库的容量，在查询时用循环取出(L,R)的总容量。此时Update为O(1)，Query为O(N)</p><p>思路二：<strong>前缀数组和</strong>：在array1储存每个仓库容量的同时维护array2来记录前n个仓库的总容量，当计算某个区间的容量(L,R)可以通过s[R]-s[L-1]求出。此时Query为O(1)，但Update为O(N)</p><p>思路三：树状数组：Update和Query的时间复杂度进行折中后都为O(logN)</p><h1 id="树状数组"><a class="markdownIt-Anchor" href="#树状数组"></a> 树状数组</h1><blockquote><p>又叫二叉索引树，最早是为了解决数据压缩里的累积频率问题，现多用来解决数组区间查询问题的数据结构，即高效解决数列的<strong>前缀和</strong>、<strong>区间和</strong>问题。</p></blockquote><h2 id="low-bit算法"><a class="markdownIt-Anchor" href="#low-bit算法"></a> low bit算法</h2><blockquote><p>核心：将一个数拆分成若干个二进制数相加，原理：每一个数都有二进制表示，即所有数都可以表示成x个不同的2的幂之和。</p><p>做法：找到二进制最后低一位1表示的数。<br>代码：通过计算<code>n&amp;-n</code>找到n最右边的1。</p></blockquote><p>举个栗子：<br>Q： 6可以怎么计算得到呢？<br>A： 6==0110，i=110，通过lowbit可以拆分成两个数100+010=110</p><p>因此树状数组的维护更新过程如下：已知i=6<br>①S+= C[6]<br>②找到<strong>i</strong>最右边的1，即得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mn>10</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><msub><mo stretchy="false">)</mo><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">lowbit=(10)_{2}=(2)_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>③更新i:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>i</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0110</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>−</mo><mo stretchy="false">(</mo><mn>0010</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>0100</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">i&#x27;= i - lowbit = (0110)_{2}-(0010)_{2}=(0100)_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mn>6</mn><mo>−</mo><mn>2</mn><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><msub><mo stretchy="false">)</mo><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">i&#x27;=6-2=(4)_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；<br>④S+= C[4]<br>⑤再继续找<strong>i</strong>最右边的1，即得到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mn>100</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><msub><mo stretchy="false">)</mo><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">lowbit=(100)_{2}=(4)_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<br>⑥更新i:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>i</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0100</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>−</mo><mo stretchy="false">(</mo><mn>0100</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>0000</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">i&#x27;= i - lowbit =(0100)_{2}-(0100)_{2}=(0000)_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<br>⑦此时i最右边无1(即全零为0)，算法结束，即最终C[6]=C[4] + C[2]</p><h2 id="计算步骤"><a class="markdownIt-Anchor" href="#计算步骤"></a> 计算步骤：</h2><ol><li>找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(n)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>最右边的1的数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mn>1</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(n1)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>更新<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mn>1</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n&#x27;=(n)_2 - (n1)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mi>n</mi><mo mathvariant="normal">′</mo></msup><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(n&#x27;)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>还能找到1，那么重复1-2</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">1e6</span> + <span class="number">5</span></span><br><span class="line">arr = [<span class="number">0</span>] * N</span><br><span class="line"><span class="comment"># 自底向上建树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(i, j)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    修改第i仓库Ci。但注意执行某个仓库的update操作，后面所有仓库都得更新</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= N:</span><br><span class="line">        arr[i] += j </span><br><span class="line">        <span class="comment"># 加上low bit位</span></span><br><span class="line">        i += i&amp;-i</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(i, j)</span>:</span></span><br><span class="line">    add(i, -j)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    通过Ci求出1-i仓库的总库存</span></span><br><span class="line"><span class="string">    S[6] = C[6] + C[4], 推导如下:</span></span><br><span class="line"><span class="string">    如果i=6,那么</span></span><br><span class="line"><span class="string">    ans += c[6] , i &lt;- i-2 = 6-2 = 4,</span></span><br><span class="line"><span class="string">    ans += c[4] , i &lt;- i-4 = 4-4 = 0</span></span><br><span class="line"><span class="string">    ∴ans = c[6] + c[4] = A[6]+A[5]+A[4]+A[3]+A[2]+A[1]</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        ans += arr[i]</span><br><span class="line">        i -= i&amp;(-i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def query(i, j);</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">查询某个区间的总库存，sum(i, j) = S(R) - S(L-1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">return</span> sum(j) - sum(i<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>符号说明：</p><ol><li><p>Ai：第i个仓库的库存数</p></li><li><p>Ci：所构建的数的第i个节点的值，C[i] = A[i-lowbit(i)+1] + …+A[i]</p></li><li><p>Si：第1个仓库到第i个仓库库存数之和</p></li><li><p>Ans（i，j）：显然就等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>R</mi></msub><mo>−</mo><msub><mi>S</mi><mrow><mi>L</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{R}-S_{L-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p></li></ol><h2 id="形式"><a class="markdownIt-Anchor" href="#形式"></a> 形式</h2><p>一.从原数组A[],维护树状数组C[]</p><p>▲lowbit又叫子叶数，表示了有多少个A[]相加，C[i]表示从C[i] = A[i-lowbit(i)+1] + …+A[i] (&lt;===&gt;C[i] = A[i-2^x+1] + … + A[i])，</p><p>For Example： i=6</p><p><img src="/2019/12/07/ACM-树状数组和线段树/t2.jpg" alt="t2"></p><p><img src="/2019/12/07/ACM-树状数组和线段树/t.jpg" alt="t"></p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h2><p><a href="https://www.bilibili.com/video/av26371798/?spm_id_from=333.788.videocard.1" target="_blank" rel="noopener">树状数组</a>——黑板讲解,NICE</p><p><a href="https://www.bilibili.com/video/av54027849/?spm_id_from=333.788.videocard.9" target="_blank" rel="noopener">树状数组算法</a>——初步了解，有些点讲的并不那么纤细</p><p><img src="/2019/12/07/ACM-树状数组和线段树/t3.jpg" alt="t3"></p><p>洛谷:<a href="https://www.luogu.com.cn/problem/P3374" target="_blank" rel="noopener"> P3374 【模板】树状数组 1</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500000 + 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = i;</span><br><span class="line">    <span class="keyword">while</span> (index&lt;=N)&#123;</span><br><span class="line">        c[index] += k;</span><br><span class="line">        index += index&amp;(-index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index)&#123;</span><br><span class="line">        ans += c[index];</span><br><span class="line">        index -= index&amp;(-index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(r) - sum(l<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">        add(i, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="keyword">int</span> x, k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op &gt;&gt; x &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (op==<span class="number">1</span>) add(x, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; query(x, k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h1><p>在求解前缀和、区间和问题上，两者是没有差别的，并且树状数组的空间复杂度更低。但是线段树还有更多的功能，比如求取区间最大值。</p><blockquote><p>完满二叉树(Full Binary Tree)<br>根据元素的下标进行划分<br>一个节点代表一个区间的信息</p></blockquote><h2 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点：</h2><ul><li>每个节点维护一个闭区间<a href="1%3C=r">1,r</a>的信息。</li><li>根节点表示[1,n]的信息。如果1=r那就是叶子结点.</li><li>如果1&lt;r那就是内部节点,它有两个子节点[1,(1+r)/2]，[(1+r)/2+1,r].</li></ul><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用1表示根节点。</span></span><br><span class="line"><span class="comment">下标为x的点的左子节点下标为2x，右子节点2x+1。</span></span><br><span class="line"><span class="comment">用sum[x]表示x代表的区间里所有数的和。</span></span><br><span class="line"><span class="comment">对于叶子结点x，它代表[1，r]（1=r），sum[x]=a[1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 更新某个节点X的值</span></span><br><span class="line">sum[x]= sum[x*<span class="number">2</span>] + sum[x*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建, 自顶向下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于存储在i号位置的节点，它的左孩子存在2i号位置，右孩子2i+1号位置。</span></span><br><span class="line"><span class="comment">同时我们也不需要记录每个位置对应的区间，只要在递归的找这个点的时候边找边修改即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> <span class="number">1</span>,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;<span class="comment">//叶子结点</span></span><br><span class="line">        sum[x]=a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(<span class="number">1</span>+r)&gt;〉<span class="number">1</span>;</span><br><span class="line">    build(<span class="number">1</span>,mid,x*<span class="number">2</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    update(x);<span class="comment">//更新信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设询问区间是[A,B],现在所在的节点表示的区间为[1,r]- 计算mid=(1+r)/2,左子节点的区间为[1,mid],右子节点的区间为[mid+1,r].</span></span><br><span class="line"><span class="comment">如果A&lt;=mid,即询问区间与左子节点有重合,需要递归到左子节点。</span></span><br><span class="line"><span class="comment">如果B&gt;=mid+1,即询问区间与右子节点有重合,需要递归到右子节点。</span></span><br><span class="line"><span class="comment">递归完之后,需要把两个孩子询问的结果加起来作为返回值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> A,<span class="keyword">int</span> B,<span class="keyword">int</span> <span class="number">1</span>,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A&lt;=<span class="number">1</span>&amp;&amp;r&lt;=B)</span><br><span class="line">    <span class="keyword">return</span> sum[x];</span><br><span class="line">    <span class="keyword">int</span> mid=(<span class="number">1</span>+r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A&lt;=mid)</span><br><span class="line">    ans+=query(A,B,<span class="number">1</span>,mid,x*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;B)</span><br><span class="line">    ans+=query(A,B,mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由于修改是对单个元素进行修改。</span></span><br><span class="line"><span class="comment">比如修改第i个元素。</span></span><br><span class="line"><span class="comment">我们先找到[i，i]所在的节点，然后修改它的sum，然后一路向上更新每个祖先的sum即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> v,<span class="keyword">int</span> <span class="number">1</span>,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( l==r)&#123; <span class="comment">//找到了要修改的叶子结点</span></span><br><span class="line">            sum[x]=v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=(<span class="number">1</span>+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)<span class="comment">//pos在左子节点</span></span><br><span class="line">        change(pos,v,<span class="number">1</span>,mid,x*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        change(pos,v,mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        update(x);<span class="comment">//一定要加！因为这条路上的sum值发生了改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性质"><a class="markdownIt-Anchor" href="#性质"></a> 性质</h2><ul><li>节点数：假设线段树处理的数列长度为n，即根节点的区间为[1，n].那么结点数不超过2n个.因此线段树的空间复杂度是0（n）。是完满二叉树(Full Binary Tree)，但一般申请4*n的空间大小</li><li>深度：可以看作满二叉树，深度不超过log2(n-1)+1</li><li>线段树能把区间上的任意一条长度为L的线段都分成不超过2*log(L)条线段。</li></ul><p>注意：</p><ul><li>由于链表表示的内存是不连续的，且申请指针比较费时间，所以采用数组矩阵的形式存储。</li><li>数组存储也有一点不好，因为线段树并不是真正的完全二叉树。<br>最后一层可能很空。且空节点的数量可以达到2n个。<br>因此维护长度为n的序列，用数组存线段树的话，最好要开到4*n的长度，才能保证数组不越界。</li></ul><h2 id="形式-2"><a class="markdownIt-Anchor" href="#形式-2"></a> 形式</h2><p><img src="/2019/12/07/ACM-树状数组和线段树/%E7%BA%BF%E6%AE%B5%E6%A0%91.jpg" alt="线段树"></p><p>例题：</p><p>Q：对于第i个数，我们要统计前面有多少个数大于a[i]。<br>对每个数都统计一遍加起来即是答案。<br>假设我们可以对[0，109]建一个线段树（实际上太大了）每次先查询[a[i]+1，109]的区间和，加入答案。</p><p>e.g.如果一个值为1，一个值为10<sup>8，那么要开10</sup>8大小</p><p>Solve: 10^9范围太大了，因此我们先要对n个数进行<strong>离散化</strong>。离散化的过程，就是对n个数进行排序，<strong>最小的数赋值为1</strong>，<strong>第二小的赋值为2</strong>，以此类推，这样n个数的取值范围就在[1，n]中了。</p><p>e.g.上面的情况，将会把1–&gt;1,10^8–&gt;2,那么只要开长度为2的线段树就够了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 离散化代码，假设对a[1,2...,n]进行离散化</span></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i ++)</span><br><span class="line">    <span class="comment">// 另外的数组存储</span></span><br><span class="line">bin[++cnt]=a[i];</span><br><span class="line">sort(bin+<span class="number">1</span>,bin+n+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 消重</span></span><br><span class="line">cnt=unique(bin+<span class="number">1</span>,bin+cnt+<span class="number">1</span>)-bin<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(inti=<span class="number">1</span>;i&lt;=n;i ++)</span><br><span class="line">a[i]=lower_bound(bin+<span class="number">1</span>,bin+cnt+<span class="number">1</span>,a[i])-bin;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.bilibili.com/video/av37087480?p=2" target="_blank" rel="noopener">高中信息学竞赛线段树与树状数组</a>——万门教育</p><p><a href="https://www.bilibili.com/video/av9350697?from=search&amp;seid=15345495634828896152" target="_blank" rel="noopener">SWPU-ACM每周算法讲堂-线段树入门（一）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;高性能问题：&lt;/strong&gt;&lt;br&gt;
Q：需求：（老板给你分了台2GHz单核，内存500M的服务器然后让你写程序）程序每秒会收到一组数据，每组数据包含10万条命令，总共会有100万个仓库，每个仓库库存没有上限且可为负，库存初始为0。&lt;strong&gt;你需要在
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KM(Kuhn-Munkres)算法</title>
    <link href="https://nymrli.top/2019/12/05/KM-Kuhn-Munkres-%E7%AE%97%E6%B3%95/"/>
    <id>https://nymrli.top/2019/12/05/KM-Kuhn-Munkres-算法/</id>
    <published>2019-12-05T13:52:58.000Z</published>
    <updated>2019-12-10T14:15:29.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kmkuhn-munkres算法"><a class="markdownIt-Anchor" href="#kmkuhn-munkres算法"></a> KM(Kuhn-Munkres)算法</h1><blockquote><p>带权二分图最佳完美匹配，O(n^3)，（运用匈牙利算法辅助求解），同时也是完备匹配</p></blockquote><ol><li>只适用于带权最大匹配一定是完备匹配的情况，实践中建议用费用流来解决。</li><li>完全二分图一定是偶数个点</li><li><strong>可行顶标</strong>（Feasible Labeling）：结点函数（x），任意边（x，y）：1（x）+l（y）≥w（xiy）。</li><li><strong>相等子图</strong>：G的生成子图，包含所有点以及满足l（x）+I（y）=w（x，y）的边（x，y）</li><li>如果EL有完美匹配为PM，则该M是原图的最大权匹配：<ul><li>PM的权和等于所有点的顶标之和SV。</li><li>G的任一个最大权匹配M，边满足w（xy）≤l（x）+（y）→M边权和≤SV=PM边权和</li><li>关键就是寻找好的可行顶标，使相等子图有完美匹配。</li></ul></li></ol><p>==&gt;找到原图的完美匹配–只要–&gt;找到相等子图的完美匹配即可</p><p>▲KM完成之后所有的l(x)之和最小</p><h2 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h2><p>一般对KM算法的描述，基本上可以概括成以下几个步骤：<br><strong>1.用邻接矩阵（或其他方法也行啦）来储存图。</strong><br><strong>2.运用贪心算法初始化标杆。</strong><br><strong>3.运用匈牙利算法找到完备匹配。</strong><br><strong>4.如果找不到，则通过修改标杆，增加一些边。</strong><br><strong>5.重复3，4的步骤，直到完全匹配时可结束。</strong></p><p>二分图匹配里面我们找最大边进行连边!但是遇到某个点被匹配了两次怎么办？<br>那就用匈牙利算法进行<strong>更改匹配</strong>！</p><p>这就是KM算法的思路了：<strong>尽量找最大的边进行连边，如果不能则换一条较大的</strong>。</p><h2 id="找对象例子理解重点"><a class="markdownIt-Anchor" href="#找对象例子理解重点"></a> 找对象例子理解重点：</h2><ol><li>女生的每轮选择都是从第一个男生开始往后选择一个男生，使男女两人的<strong>期望和要等于两人之间的好感度</strong>。</li><li>注意：每一轮匹配，<strong>每个男生只会被尝试匹配一次！</strong></li><li>如果找对象失败，那么此时参与匹配过的女生期望值都降低d，本轮被选择的男生期望值都增加d：d为<u>任意一个</u><strong>这轮参与过匹配的女生</strong>能<em><strong>换到***<u>任意一个</u><strong>这轮没有被选择过的男生</strong>所需要</strong>降低的最小值</em>*（遍历左边已配对的X，标杆值Lx，与右边<strong>这一轮</strong>没被选择过的男生Y，标杆值Ly，挑出需要降低的最小值，即 d=min(Lx+Ly-W, d) ）</li></ol><h2 id="复杂度"><a class="markdownIt-Anchor" href="#复杂度"></a> 复杂度</h2><p>朴素的实现方法，时间复杂度为O(n4)——需要找O(n)次增广路，每次增广最多需要修改O(n)次顶标，每次修改顶标时由于要枚举边来求d值，复杂度为O(n2)。</p><p>实际上KM算法的复杂度是可以做到O(n3) 的。我们给每个Y顶点一个“松弛量”函数slack，每次开始找增广路时初始化为无穷大。在寻找增广路的过程中，检查边(i,j)时，如果它不在相等子图中，则让slack[j]变成原值与A[i]+B[j]-w[i,j]的较小值。这样，在修改顶标时，取所有不在交错树中的Y顶点的slack值中的最小值作为d值即可。但还要注意一点：修改顶标后，要把所有的slack值都减去d。（即用在执行匈牙利算法的时候，进行对slack的更新，从而减少一层找到最小d的循环）</p><h2 id="举个栗子"><a class="markdownIt-Anchor" href="#举个栗子"></a> 举个栗子:</h2><h3 id="少林决胜golden-tiger-clawuva11383"><a class="markdownIt-Anchor" href="#少林决胜golden-tiger-clawuva11383"></a> <strong>少林决胜(Golden Tiger Claw，UVa11383)</strong></h3><p>给定一个N*N矩阵，每个格子里都有一个正整数w(i,j)。你的任务是给每行确定一个整数row(i)，每列也确定一个整数col(i)，使得对于任意格子(i, j)，w(i, j)≤row(i)+colj)。所有row(i)和col(i)之和应尽量小。</p><p>【分析】<br>1.行看作二分图X点，列看作二分图Y点。<br>2.和最佳匹配没有任何关系，KM算法副产品。<br>3.KM中算法等式l（x）+l（y）≥w（x，y）。行X，列Y。<br>4.KM过程中，所有顶标不断减小，算法结束后，所有顶标之和是最小的。</p><h3 id="蚂蚁antsneerc2008la4043"><a class="markdownIt-Anchor" href="#蚂蚁antsneerc2008la4043"></a> <strong>蚂蚁（Ants，NEERC2008，LA4043）</strong></h3><p>给出n个白点和n个黑点的坐标，要求用n条不相交的线段把它们连接起来，其中每条线段恰好连接一个白点和一个黑点，每个点恰好连接到一条线段，如图所示。</p><p>【分析】</p><ol><li>点有黑白两色，构造二分图，白X黑Y。每个黑点和每个白点相连，权值等于欧氏距离。</li><li>连接方案实际上是计算一个完美匹配，匹配中假设al-b1与a2-b2相交，那么<code>dist(a1，b1)+dist(a2，b2)&gt;dist(al，b2)+dist(a2，b1)</code>，这两条线段改成al-b2和a2-b1后总长度会变少。</li><li>所以最小匹配中不会出现线段相交。</li><li>套KM算法即可计算最小完美匹配即可。</li></ol><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2><h3 id="on3代码"><a class="markdownIt-Anchor" href="#on3代码"></a> O(n^3)代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// X为女生节点， Y为男生节点</span></span><br><span class="line"><span class="keyword">int</span> love[MAXN][MAXN];   <span class="comment">// 记录每个妹子和每个男生的好感度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ex_girl[MAXN];      <span class="comment">// 每个妹子的期望值</span></span><br><span class="line"><span class="keyword">int</span> ex_boy[MAXN];       <span class="comment">// 每个男生的期望值</span></span><br><span class="line"><span class="keyword">bool</span> vis_girl[MAXN];    <span class="comment">// 记录每一轮匹配匹配过的女生</span></span><br><span class="line"><span class="keyword">bool</span> vis_boy[MAXN];     <span class="comment">// 记录每一轮匹配匹配过的男生</span></span><br><span class="line"><span class="keyword">int</span> match[MAXN];        <span class="comment">// 记录每个男生匹配到的妹子 如果没有则为-1</span></span><br><span class="line"><span class="keyword">int</span> slack[MAXN];        <span class="comment">// 记录每个汉子如果能被妹子倾心最少还需要多少期望值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> girl)</span></span>&#123;</span><br><span class="line">    vis_girl[girl] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> boy = <span class="number">0</span>; boy &lt; N; ++boy) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vis_boy[boy]) <span class="keyword">continue</span>; <span class="comment">// 每一轮匹配 每个男生只尝试一次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> gap = ex_girl[girl] + ex_boy[boy] - love[girl][boy];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gap == <span class="number">0</span>) &#123;  <span class="comment">// 如果符合要求</span></span><br><span class="line">            vis_boy[boy] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[boy] == <span class="number">-1</span> || dfs( match[boy] )) &#123;    <span class="comment">// 找到一个没有匹配的男生 或者该男生的妹子可以找到其他人</span></span><br><span class="line">                match[boy] = girl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slack[boy] = min(slack[boy], gap);  <span class="comment">// slack 可以理解为该男生要得到女生的倾心 还需多少期望值 取最小值 备胎的样子【捂脸</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ▲初始化有关被选择的男生的量1-2 [选择他的女生、男生方标杆]</span></span><br><span class="line">    <span class="built_in">memset</span>(match, <span class="number">-1</span>, <span class="keyword">sizeof</span> match);    <span class="comment">// 初始每个男生都没有匹配的女生</span></span><br><span class="line">    <span class="built_in">memset</span>(ex_boy, <span class="number">0</span>, <span class="keyword">sizeof</span> ex_boy);   <span class="comment">// 初始每个男生的期望值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ▲初始化3 [女生方的标杆]</span></span><br><span class="line">    <span class="comment">// 每个女生的初始期望值是与她相连的男生最大的好感度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        ex_girl[i] = love[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            ex_girl[i] = max(ex_girl[i], love[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试为每一个女生解决归宿问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ▲初始化4 [slack-找到最小的d]</span></span><br><span class="line">        fill(slack, slack + N, INF);    <span class="comment">// 因为要取最小值 初始化为无穷大</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 为每个女生解决归宿问题的方法是 ：如果找不到就降低期望值，直到找到为止</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化5-6 [该轮中那些女生已经尝试匹配过，该轮中那些男生被选择过]</span></span><br><span class="line">            <span class="comment">// 记录每轮匹配中男生女生是否被尝试匹配过</span></span><br><span class="line">            <span class="built_in">memset</span>(vis_girl, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis_girl);</span><br><span class="line">            <span class="built_in">memset</span>(vis_boy, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis_boy);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dfs(i)) <span class="keyword">break</span>;  <span class="comment">// 找到归宿 退出</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不能找到 就降低期望值</span></span><br><span class="line">            <span class="comment">// 最小可降低的期望值</span></span><br><span class="line">            <span class="keyword">int</span> d = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">                <span class="keyword">if</span> (!vis_boy[j]) d = min(d, slack[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">// 所有访问过的女生降低期望值</span></span><br><span class="line">                <span class="keyword">if</span> (vis_girl[j]) ex_girl[j] -= d;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 所有访问过的男生增加期望值</span></span><br><span class="line">                <span class="keyword">if</span> (vis_boy[j]) ex_boy[j] += d;</span><br><span class="line">                <span class="comment">// 没有访问过的boy 因为girl们的期望值降低，距离得到女生倾心又进了一步！</span></span><br><span class="line">                <span class="keyword">else</span> slack[j] -= d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配完成 求出所有配对的好感度的和</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        res += love[ match[i] ][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;love[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, KM());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>裸题:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2255" target="_blank" rel="noopener">HDU2255 奔小康赚大钱</a><br>输入数据包含多组测试用例，每组数据的第一行输入n,表示房子的数量(也是老百姓家的数量)，接下来有n行,每行n个数表示第i个村名对第j间房出的价格(n&lt;=300)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2// 一共有两个房子</span><br><span class="line">100 10// 村民1对第一间出价100, 第二间10</span><br><span class="line">15 23   // 村民1对第一间出价15, 第二间23</span><br><span class="line">Sample Output</span><br><span class="line">123// 第一间给1,第二间给2</span><br></pre></td></tr></table></figure><p>获得其他数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    N = <span class="number">3</span>;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = rand() % <span class="number">3</span>*N + <span class="number">1</span>;</span><br><span class="line">            love[i][j] = tmp;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, love[i][j] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, KM());</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, match[i], i);</span><br><span class="line">        sum += love[match[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"和最大：%d\n"</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            love[i][j] = -love[i][j] ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, love[i][j] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"和最小：%d\n"</span>, -KM());</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, match[i], i);</span><br><span class="line">        sum += love[match[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">4 1 7 </span></span><br><span class="line"><span class="comment">1 4 7 </span></span><br><span class="line"><span class="comment">1 7 4 </span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">0-&gt;0</span></span><br><span class="line"><span class="comment">2-&gt;1</span></span><br><span class="line"><span class="comment">1-&gt;2</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">-4 -1 -7 </span></span><br><span class="line"><span class="comment">-1 -4 -7 </span></span><br><span class="line"><span class="comment">-1 -7 -4 </span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">1-&gt;0</span></span><br><span class="line"><span class="comment">0-&gt;1</span></span><br><span class="line"><span class="comment">2-&gt;2</span></span><br><span class="line"><span class="comment">-6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料：</h2><p><a href="https://www.cnblogs.com/Lanly/p/6291214.html" target="_blank" rel="noopener">二分图匹配之最佳匹配——KM算法</a></p><p><a href="https://blog.csdn.net/chenshibo17/article/details/79933191" target="_blank" rel="noopener">KM算法详解+模板</a>——男女相亲匹配</p><p><a href="https://blog.csdn.net/NIeson2012/article/details/94472313" target="_blank" rel="noopener">带你入门多目标跟踪（三）匈牙利算法&amp;KM算法</a>——以图像目标跟踪距离</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kmkuhn-munkres算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#kmkuhn-munkres算法&quot;&gt;&lt;/a&gt; KM(Kuhn-Munkres)算法&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;带权二分图最佳完美匹配，O(n
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://nymrli.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>ACM-二分图</title>
    <link href="https://nymrli.top/2019/12/05/ACM-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>https://nymrli.top/2019/12/05/ACM-二分图/</id>
    <published>2019-12-05T09:45:57.000Z</published>
    <updated>2019-12-08T14:21:09.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分图的判定"><a class="markdownIt-Anchor" href="#二分图的判定"></a> 二分图的判定：</h1><p>染色法1：假设DFS初始点A涂黑色，与它相邻的点就涂白色。如果搜到某一个点u的相邻点v已经涂色并且与u同色，就不可能是二分图啦~</p><p>染色法2：就是给每个点进行标号，标为-1，1如果存在一条边连接的两个点标号相同，那么就是存在一个奇数环…</p><p>热身题：</p><h2 id="判断无向图是否有环"><a class="markdownIt-Anchor" href="#判断无向图是否有环"></a> 判断无向图是否有环</h2><blockquote><p>用DFS遍历图g，如果访问到已经访问过的顶点，那么有环</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100+5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 起点编号从0开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> en;                 <span class="comment">// 边数</span></span><br><span class="line">    <span class="keyword">int</span> vn;                 <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">map</span>[SIZE][SIZE];    <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> vis[SIZE];          <span class="comment">// 记录矩阵</span></span><br><span class="line">    <span class="keyword">bool</span> huan = <span class="literal">false</span>;      <span class="comment">// 是否有环</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">u: 当前节点节点</span></span><br><span class="line"><span class="comment">prev: 记录上一个节点</span></span><br><span class="line"><span class="comment">g: 图指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> prev, graph *g)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vn; ++v)&#123;    <span class="comment">// v为下一个可达的节点</span></span><br><span class="line">        <span class="comment">// 自己到自己为0, 是没有边的</span></span><br><span class="line">        <span class="keyword">if</span> (v == prev) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ( g-&gt;vis[v] != <span class="number">2</span> &amp;&amp; g-&gt;<span class="built_in">map</span>[u][v] )&#123;</span><br><span class="line">            g-&gt;vis[v] = <span class="number">1</span>;</span><br><span class="line">            dfs(v, u, g);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(g-&gt;vis[v] == <span class="number">2</span> &amp;&amp; g-&gt;<span class="built_in">map</span>[u][v] )&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"now: %d %d\n"</span>,u ,v );</span><br><span class="line">             g-&gt;huan = <span class="literal">true</span>;</span><br><span class="line">             <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(<span class="keyword">const</span> graph *g)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vn; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vn; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"v:%d\t"</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g-&gt;vn; ++j)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, g-&gt;<span class="built_in">map</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    graph *g = <span class="keyword">new</span> graph();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;g-&gt;vn, &amp;g-&gt;en);</span><br><span class="line">    <span class="built_in">memset</span>(g-&gt;<span class="built_in">map</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*g-&gt;en*g-&gt;vn);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g-&gt;en; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g-&gt;<span class="built_in">map</span>[u][v] = g-&gt;<span class="built_in">map</span>[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    showGraph(g);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vn; ++i)&#123;</span><br><span class="line">        <span class="comment">// 如果节点i没被访问过</span></span><br><span class="line">        <span class="keyword">if</span> (g-&gt;vis[i] == <span class="number">0</span> &amp;&amp; g-&gt;huan == <span class="literal">false</span>)&#123;</span><br><span class="line">            g-&gt;vis[i] = <span class="number">2</span>;</span><br><span class="line">            dfs(i, <span class="number">-1</span>, g);</span><br><span class="line">            g-&gt;vis[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(g-&gt;huan == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;huan) <span class="built_in">printf</span>(<span class="string">"有环\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"无环\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断一个环是否为奇数环"><a class="markdownIt-Anchor" href="#判断一个环是否为奇数环"></a> <a href="https://www.cnblogs.com/ziyi--caolu/p/3632644.html" target="_blank" rel="noopener">判断一个环是否为奇数环</a></h2><p><a href="http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1356" target="_blank" rel="noopener">1356: Catch</a></p><p>题意：给出一个起始点，一些边，有人从这个起始点开始随意走，问在某一个时候，它是否可以处于任意位置。</p><p>思路：思考下，就可以明白，只要是一个联通图，并且存在奇数点形成的环，那么在某一个时候就可以处于任意位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最大匹配数匈牙利算法"><a class="markdownIt-Anchor" href="#最大匹配数匈牙利算法"></a> 最大匹配数——匈牙利算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line[maxn][maxn]; <span class="comment">// 邻接矩阵,表示男生是否有好感(可达)</span></span><br><span class="line"><span class="keyword">int</span> used[maxn];       <span class="comment">// 在位男生i匹配的那轮中,女生i是否被尝试过匹配</span></span><br><span class="line"><span class="keyword">int</span> nxt[maxn];        <span class="comment">// 如果匹配到了的话,那么男生是谁,女生i的对象为nxt[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为男生x匹配到一个女生i,如果匹配到的女生有主,那么让已配对女生的对象(男)修改匹配对象</span></span><br><span class="line"><span class="comment"> * @author mrli 2019-12-08</span></span><br><span class="line"><span class="comment"> * @param  x 男生</span></span><br><span class="line"><span class="comment"> * @return   男生x是否能匹配到女生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有妹子Y节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="comment">// 如果男生对女生互有好感(即边可达) 且 妹子没有匹配过</span></span><br><span class="line">        <span class="keyword">if</span> (line[x][i] &amp;&amp; !used[i])&#123;</span><br><span class="line">            <span class="comment">// 在男生该轮,将该女生i标记为已经被尝试匹配过</span></span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//  如果妹子没有对象  或者  已匹配到的男生是可以转移对象的</span></span><br><span class="line">            <span class="keyword">if</span> ( nxt[i]==<span class="number">0</span> || Find( nxt[i]) )&#123;</span><br><span class="line">                <span class="comment">// 将女生的已配对对象改为x</span></span><br><span class="line">                nxt[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为所有男生进行匹配</span></span><br><span class="line"><span class="comment"> * @author mrli 2019-12-08</span></span><br><span class="line"><span class="comment"> * @return 最大匹配数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 最大匹配数</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历所有男生X节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="comment">// 在男生i该轮,所有女生都没有被修改过匹配</span></span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">        <span class="comment">// 如果当前男生能找到匹配女生,那么最大匹配数++</span></span><br><span class="line">        <span class="keyword">if</span> (Find(i)) sum++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="comment">// XY节点数</span></span><br><span class="line">    n = m = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">memset</span>(line, <span class="number">0</span>, <span class="keyword">sizeof</span>(line));</span><br><span class="line">    <span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="keyword">sizeof</span>(nxt));</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        line[u][v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; match();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">4 3</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>拓展题:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2236" target="_blank" rel="noopener">无题II HDU2236</a></p><blockquote><p><strong>二分图</strong>：为什么会想到用二分图呢？<strong>不同行不同列</strong>，仔细想一下，如果某点（x,y），被选中，那么横坐标上x的值不能再选，纵坐标上的y值也不能再选，这相当于二维上有很多值，但是每个值都只能用一次，这就可以想到用二分图匹配求完美匹配了。</p><p><strong>二分答案</strong>：求n个数的最大最小的差值最小，首先这个差值一定是**0-(maxv-minv)**区间的，然后我们二分差值为外循环，枚举下界为内循环，得到一个区间。做法：修改二分图匹配模板：如果这个二分图的匹配点是在这个区间里的前去匹配，hungry()函数中返回是否为完美匹配，<u>对于每一个二分的差值，只要它能找到一个满足区间条件的完美匹配，就记录一下答案。</u></p></blockquote><p>Q：首先明白在求什么</p><p>A： 首先需要明白：图中每个数值X + 最大差值 &lt;= 最大值</p><p>我对上面的理解：</p><p>1.最大的差值是个具体的数值δ，最初可以确定的范围在[0, maxv - minv] 之间，因此可以通过二分搜索的方式来找到这个值==&gt;二分搜索</p><p>2.那怎么进行二分来缩小这个区间范围呢?Ans：如果符合<strong>最大差值</strong>的条件(表中所有数都满足 ：数值x+差值 &lt;= 最大值)，即所有点都能完成匹配，那么证明最大差值在这个区间中----&gt;完美匹配==&gt;匈牙利算法</p><p>▲所以算法变成了，不断缩小<u>最大差值</u>可以取值的区间，核心： 判断所有数是否在[p, p+差值]区间内</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line[maxn][maxn]; <span class="comment">// 邻接矩阵,表示男生是否有好感(可达)</span></span><br><span class="line"><span class="keyword">int</span> used[maxn];       <span class="comment">// 在位男生i匹配的那轮中,女生i是否被尝试过匹配</span></span><br><span class="line"><span class="keyword">int</span> nxt[maxn];        <span class="comment">// 如果匹配到了的话,那么男生是谁,女生i的对象为nxt[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, t, maxv, minv;</span><br><span class="line"><span class="keyword">int</span> l, r, mid;</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1 1 1 1</span></span><br><span class="line"><span class="comment">2 2 2 2</span></span><br><span class="line"><span class="comment">3 3 3 3</span></span><br><span class="line"><span class="comment">4 4 4 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="comment">// 修改模板：增加界定二分[p, p+mid]的区间</span></span><br><span class="line">        <span class="comment">// 判断边x是否还在[minv, minv+差值]之间</span></span><br><span class="line">        <span class="comment">/*if条件解释:执行过程分析</span></span><br><span class="line"><span class="comment">        如题,l=0, r=4,</span></span><br><span class="line"><span class="comment">        第一次mid=2,p=1, 此时并不是所有点都在[1, 1+2]之间,所以匹配失败</span></span><br><span class="line"><span class="comment">        因为1+2&lt;=4(maxv),所以p++后再进入,此时mid=2,p=2,此时仍然不是所有点在这个范围[2,2+2]内,所以失败,第一次二分失败,区间不在[l,mid]即[0,2]之间</span></span><br><span class="line"><span class="comment">  第二次更新l=mid+1=2+1=3,mid=(3+4)/2=3</span></span><br><span class="line"><span class="comment">  p=1时,判断是否所有点都在[1,1+3]范围,==&gt;结果是的,hungarian返回true,二分确定在[mid, r]即[3,4]之间,更新r=mid-1=3,mid=(l+r)/2=3,此时有l=r=3所以找到了最大差值mid</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(p &lt;= line[x][i] &amp;&amp; line[x][i]&lt;= p+mid &amp;&amp; !used[i])&#123;</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( nxt[i]==<span class="number">0</span> || Find( nxt[i]) )&#123;</span><br><span class="line">                nxt[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungarian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这边改了，每次都是新情况</span></span><br><span class="line">    <span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="keyword">sizeof</span>(nxt));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">        <span class="keyword">if</span> (Find(i)) sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改模板</span></span><br><span class="line">    <span class="keyword">return</span> sum==n?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line">    m = n = size;</span><br><span class="line">        maxv = -inf;</span><br><span class="line">        minv = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= size; ++j)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; line[i][j];</span><br><span class="line">                maxv = max(maxv, line[i][j]);</span><br><span class="line">                minv = min(minv, line[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = maxv - minv;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 二分搜索，不断缩小区间</span></span><br><span class="line">        <span class="keyword">while</span>( l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            mid = (l+r) &gt;&gt; <span class="number">1</span>;<span class="comment">// mid为差值</span></span><br><span class="line">            <span class="comment">// 遍历下界的搜索,枚举最小值，检查当前差值是否可以匹配成功,条件是“最小值+差值&lt;=最大值”</span></span><br><span class="line">            <span class="comment">// 核心： 判断所有数是否在[p, p+差值]区间内</span></span><br><span class="line">            <span class="keyword">for</span> (p = minv; p+mid &lt;= maxv; ++p)&#123;</span><br><span class="line">                <span class="keyword">if</span> (hungarian())&#123;</span><br><span class="line">                <span class="comment">// 这句类似二分搜索里的if一旦找到哪个区间，就直接在这个区间里继续二分，</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 因为是从[min,min+mid]~[max-mid, max]的搜索,区间大小为mid,如果true,意思是最大差值mid就在[l, mid]之间</span></span><br><span class="line">            <span class="keyword">if</span> (flag) ans = mid,r = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 如果全不符合,那么区间小了,mid得大点,所以mid范围变为[mid, r]</span></span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 二分搜索中如果l==r，那么搜索数x的索引就是最后的mid</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最佳匹配km算法"><a class="markdownIt-Anchor" href="#最佳匹配km算法"></a> 最佳匹配——KM算法</h1><blockquote><p>解决有权的完美匹配问题，成为最佳匹配，又称为有权完美匹配。最佳匹配同时也是完备匹配</p></blockquote><p><a href="https://www.cnblogs.com/wenruo/p/5264235.html" target="_blank" rel="noopener">KM算法详解+模板</a>——含图讲解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二分图的判定&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#二分图的判定&quot;&gt;&lt;/a&gt; 二分图的判定：&lt;/h1&gt;
&lt;p&gt;染色法1：假设DFS初始点A涂黑色，与它相邻的点就涂白色。如果搜到某一个点u的相邻点v已经涂色并且与u同色，就不可能是
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://nymrli.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Hungarian algorithm匈牙利算法</title>
    <link href="https://nymrli.top/2019/12/05/Hungarian-algorithm%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    <id>https://nymrli.top/2019/12/05/Hungarian-algorithm匈牙利算法/</id>
    <published>2019-12-05T05:08:11.000Z</published>
    <updated>2019-12-22T13:50:20.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hungarian-algorithm匈牙利算法"><a class="markdownIt-Anchor" href="#hungarian-algorithm匈牙利算法"></a> Hungarian algorithm匈牙利算法</h1><blockquote><p>主要用来解决不带权的分配问题，O(V*E)</p></blockquote><p>首先，需要明白二分图（又名二部图）的概念</p><h2 id="二分图bipartite-graph"><a class="markdownIt-Anchor" href="#二分图bipartite-graph"></a> 二分图Bipartite Graph</h2><p>二分图是图论中一种特殊模型。设G=(V,E)是一个<strong>无向图</strong>(当且仅当图中不存在长度为奇数的环。)，如果顶点V可分割为<strong>两个互不相交</strong>的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j<strong>分别属于这两个不同的顶点集</strong>(i in A,j in B)，则称图G为一个二分图。</p><p>注意：如果一图是二分图，那么它<strong>一定没有奇环</strong>。如果一图没有奇环的话，那么它可以是二分图。(没有奇环是二分图的必要条件)</p><p>▲通常被用来解决分配、匹配问题，如资源分配、工作安排、任务调度……任务的核心本质是求配对关系，或者给顶点和边赋权，求某种条件下的最优分配问题。</p><p>△匹配问题可以用网络流解决，或者KM算法（KM算法是一种计算机算法，功能是求完备匹配下的最大权匹配），但是增广路算法更加简洁。</p><h3 id="二分图的判定"><a class="markdownIt-Anchor" href="#二分图的判定"></a> 二分图的判定：</h3><p>染色法1：假设DFS初始点A涂黑色，与它相邻的点就涂白色。如果搜到某一个点u的相邻点v已经涂色并且与u同色，就不可能是二分图啦~</p><p>染色法2：就是给每个点进行标号，标为-1，1如果存在一条边连接的两个点标号相同，那么就是存在一个奇数环…</p><h3 id="二分图的匹配"><a class="markdownIt-Anchor" href="#二分图的匹配"></a> 二分图的匹配</h3><ul><li><strong>匹配</strong>：将E的子集M称作一个<strong>匹配</strong>(子集M中的任意两条边都没有公共端点)</li><li><strong>最大匹配</strong>：边数最多的匹配称作最大匹配——maximal matching</li><li><strong>X(Y)完全匹配</strong>：如果X（Y）中的所有的顶点都出现在匹配M中，则称M是X(Y)完全匹配——perfect matching</li><li><strong>M完全匹配</strong>：如果M既是X-完全匹配，又是Y-完全匹配，称M是完全匹配。此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>Y</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|X| = |Y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span></span></span></span>，也就是说这个匹配里的所有边刚好经过所有点一次。</li></ul><h3 id="最大匹配和完全匹配的应用"><a class="markdownIt-Anchor" href="#最大匹配和完全匹配的应用"></a> 最大匹配和完全匹配的应用：</h3><p>Q：教师-课程安排，G=&lt;U,E,V&gt;，U为教师集合，V为课程集合，E中的边&lt;u,v&gt;表示某位教师u可以上课程v。需要求<strong>最大匹配</strong>，使得每门课程有人教，每人都有课上。</p><p>A:匈牙利算法</p><h2 id="匈牙利算法"><a class="markdownIt-Anchor" href="#匈牙利算法"></a> 匈牙利算法</h2><h3 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h3><p>①任意取一个匹配M（可以是空集或只有一条边）<br>②令S是非饱和点（尚未匹配的点）的集合自如果S=0，则M已经是最大匹配<br>④从S中取出一个非饱和点山作为起点，从此起点走交错路（交替属于M和非M的边构成的极大无重复点通路或回路）P<br>③如果P是一个增广路（P的终点也是非饱和点），则令M=MeP=（M-P）U（P-M）<br>⑥如果P都不是增广路，则从S中去掉uo，转到step3</p><p>▲.顶点数不同，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">≠</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|X| \neq |Y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span></span></span></span>的二分图一定没有完全匹配</p><p>▲正则的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">≠</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|X| \neq |Y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span></span></span></span>的二分图一定有完全匹配(正则:每个顶点的度数都相同)</p><p>核心思想：不断挪</p><h4 id="増广路定理"><a class="markdownIt-Anchor" href="#増广路定理"></a> 増广路定理：</h4><blockquote><p>任意一个非最大匹配的匹配一定存在增广路。</p></blockquote><ol><li>从一个未匹配点（未盖点）出发，<strong>依次</strong>经过<u>非匹配边</u>、<u>匹配边</u>、<u>非匹配边</u>…形成的路径叫<strong>交替路</strong>。</li><li>两个端点都是未盖点→增广路（Augmenting Path，AP）<ul><li>比如：8→4→7→1→5→2，图中红色是匹配边。</li><li>特殊的：3-6也是增广路。</li></ul></li><li>把AP上的匹配边和非匹配边互换，得到的匹配比刚才多一条边。</li><li>匹配点只连一条匹配边（？），这样做不会破坏匹配的性质。</li><li>增广路定理：即一个匹配是最大匹配等价于不存在增广路。<ul><li>匈牙利算法的核心原理：就是不断找増广路（依据性质3），直至无法找到新的増广路，即为最大匹配。——使用递归（<strong>一直找增广路，不断交换匹配</strong>）</li></ul></li><li>增广路可以用来改进匹配，最大匹配可以通过反复找增广路来求解。</li><li><strong>已经匹配的点永远不会退出匹配，只会更换匹配</strong></li></ol><p>注：（匹配点又叫做盖点，非匹配点叫做未盖点（所谓“盖”指的是被一条边盖住）</p><p><img src="/2019/12/05/Hungarian-algorithm匈牙利算法/E:%5Chexo%5Csource_posts%5CHungarian-algorithm%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%5C%E5%A2%97%E5%B9%BF%E8%B7%AF.jpg" alt="増广路"></p><h3 id="实现的细节"><a class="markdownIt-Anchor" href="#实现的细节"></a> 实现的细节：</h3><p><img src="/2019/12/05/Hungarian-algorithm匈牙利算法/E:%5Chexo%5Csource_posts%5CHungarian-algorithm%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%5Czgl2.jpg" alt="zgl2"></p><p>每次选一个未盖点u进行DFS。如果找不到<strong>u开头</strong>的增广路，则换一个未盖点进行DFS，且以后<strong>再也不从u出发找增广路</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BPM</span>&#123;</span><span class="comment">//二分图最大基数匹配，邻接矩阵写法</span></span><br><span class="line">    <span class="keyword">int</span> n，m，G[maxn][maxn];<span class="comment">//左右顶点个数，G[x][y]=1，边x-y</span></span><br><span class="line">    <span class="keyword">int</span> left[maxn];<span class="comment">//1eft[i]为右边第i个点的匹配点编号，-1表示不存在</span></span><br><span class="line">    <span class="keyword">bool</span> T[maxn];<span class="comment">//T[i]为右边第i个点是否已标记</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n，<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n=n，<span class="keyword">this</span>-&gt;m=m;_zero(G);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">// 递归进行挪</span></span><br><span class="line"><span class="keyword">for</span>(intv=e;v&lt;m;v++)</span><br><span class="line">        <span class="keyword">if</span>(G[u][v]&amp;&amp;！T[v])&#123;</span><br><span class="line">            T[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(left[v]==<span class="number">-1</span> || match(left[v]))&#123;</span><br><span class="line">            <span class="comment">//left[v]！=-1，1eft[v]-v是匹配边</span></span><br><span class="line">            left[v]=u;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> solve（)&#123; <span class="comment">//求最大匹配</span></span><br><span class="line">    <span class="built_in">memset</span>(left，<span class="number">-1</span>，<span class="keyword">sizeof</span>(left));</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=e;u&lt;n;u++)&#123;<span class="comment">//从左边结点u开始增广</span></span><br><span class="line">        _zero(T); </span><br><span class="line">        <span class="keyword">if</span>(match(u)) ans++;<span class="comment">//u是未盖点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体实现代码见文章：《ACM-二分图》</p><h3 id="其他相关概念"><a class="markdownIt-Anchor" href="#其他相关概念"></a> 其他相关概念：</h3><h4 id="最小顶点覆盖"><a class="markdownIt-Anchor" href="#最小顶点覆盖"></a> 最小顶点覆盖：</h4><p>是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相连<br>&amp;二分图的最小顶点覆盖数=二分图的最大匹配数</p><h4 id="dag最小不相交路径覆盖"><a class="markdownIt-Anchor" href="#dag最小不相交路径覆盖"></a> DAG最小不相交路径覆盖</h4><p>也称为最小边覆盖，是指用尽量少的顶点<strong>不相交</strong>（只经过一次）的简单路径覆盖二分图中的所有顶点<br>路径长度可以为0<br>&amp;二分图的最小路径覆盖数=|V|-二分图的最大匹配数<br>*最小可相交路径覆盖</p><h4 id="最大独立集"><a class="markdownIt-Anchor" href="#最大独立集"></a> 最大独立集</h4><p>最大独立集是指寻找一个点集，使得其中任意两点在图中无对应边。<br>对于一般图来说，最大独立集是一个NP完全问题，对于二分图来说最大独立集<br>=|V| - 二分图的最大匹配数</p><h2 id="kmkuhn-munkres算法"><a class="markdownIt-Anchor" href="#kmkuhn-munkres算法"></a> KM(Kuhn-Munkres)算法</h2><blockquote><p>带权二分图最佳完美匹配，O(n^3)，（运用匈牙利算法辅助求解）</p></blockquote><ol><li>只适用于带权最大匹配一定是完备匹配的情况，实践中建议用费用流来解决。</li><li>完全二分图一定是偶数个点</li><li><strong>可行顶标</strong>（Feasible Labeling）：结点函数（x），任意边（x，y）：1（x）+l（y）≥w（xiy）。</li><li><strong>相等子图</strong>：G的生成子图，包含所有点以及满足l（x）+I（y）=w（x，y）的边（x，y）</li><li>如果EL有完美匹配为PM，则该M是原图的最大权匹配：<ul><li>PM的权和等于所有点的顶标之和SV。</li><li>G的任一个最大权匹配M，边满足w（xy）≤l（x）+（y）→M边权和≤SV=PM边权和</li><li>关键就是寻找好的可行顶标，使相等子图有完美匹配。</li></ul></li></ol><p>==&gt;找到原图的完美匹配–只要–&gt;找到相等子图的完美匹配即可</p><p>▲KM完成之后所有的l(x)之和最小</p><h3 id="举个栗子"><a class="markdownIt-Anchor" href="#举个栗子"></a> 举个栗子:</h3><h4 id="少林决胜golden-tiger-clawuva11383"><a class="markdownIt-Anchor" href="#少林决胜golden-tiger-clawuva11383"></a> <strong>少林决胜(Golden Tiger Claw，UVa11383)</strong></h4><p>给定一个N*N矩阵，每个格子里都有一个正整数w(i,j)。你的任务是给每行确定一个整数row(i)，每列也确定一个整数col(i)，使得对于任意格子(i, j)，w(i, j)≤row(i)+colj)。所有row(i)和col(i)之和应尽量小。</p><p>【分析】<br>1.行看作二分图X点，列看作二分图Y点。<br>2.和最佳匹配没有任何关系，KM算法副产品。<br>3.KM中算法等式l（x）+l（y）≥w（x，y）。行X，列Y。<br>4.KM过程中，所有顶标不断减小，算法结束后，所有顶标之和是最小的。</p><h4 id="蚂蚁antsneerc2008la4043"><a class="markdownIt-Anchor" href="#蚂蚁antsneerc2008la4043"></a> <strong>蚂蚁（Ants，NEERC2008，LA4043）</strong></h4><p>给出n个白点和n个黑点的坐标，要求用n条不相交的线段把它们连接起来，其中每条线段恰好连接一个白点和一个黑点，每个点恰好连接到一条线段，如图所示。</p><p>【分析】</p><ol><li>点有黑白两色，构造二分图，白X黑Y。每个黑点和每个白点相连，权值等于欧氏距离。</li><li>连接方案实际上是计算一个完美匹配，匹配中假设al-b1与a2-b2相交，那么dist(a1，b1)+dist(a2，b2)&gt;dist(al，b2)+dist(a2，b1)，这两条线段改成al-b2和a2-b1后总长度会变少。</li><li>所以最小匹配中不会出现线段相交。</li><li>套KM算法即可计算最小完美匹配即可。</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料：</h2><p><a href="https://www.bilibili.com/video/av14223723?from=search&amp;seid=7889448616401707001" target="_blank" rel="noopener">离散数学：图论：二分图的匹配</a>——陈斌 北京大学地球与空间科学学院</p><p><a href="https://blog.csdn.net/D5__J9/article/details/80754657" target="_blank" rel="noopener">二分匹配——匈牙利算法和KM算法</a>——里面推荐的文章更值得一看</p><p><a href="https://blog.csdn.net/NIeson2012/article/details/94472313" target="_blank" rel="noopener">带你入门多目标跟踪（三）匈牙利算法&amp;KM算法</a>——以图像目标跟踪距离</p><p><a href="https://skywt.cn/posts/bipartite-matching" target="_blank" rel="noopener">二分图匹配问题与匈牙利算法</a>——里面包含概念挺全的</p><p><a href="https://blog.csdn.net/ling_wang/article/details/79830980?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">二分图大合集——二分图最大匹配（最小覆盖数），完美匹配以及最优匹配（带权最大匹配）</a>——对概念的介绍比上个更准确点，推荐</p><p><a href="https://www.bilibili.com/video/av70803534/?spm_id_from=333.788.videocard.1" target="_blank" rel="noopener">二分图最大匹配以及常见模型——ACM角度</a></p><p><a href="https://www.cnblogs.com/dwdxdy/p/3261742.html" target="_blank" rel="noopener">任务分配问题—匈牙利算法</a>——含Gungary算法执行过程伪代码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hungarian-algorithm匈牙利算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hungarian-algorithm匈牙利算法&quot;&gt;&lt;/a&gt; Hungarian algorithm匈牙利算法&lt;/h1&gt;
&lt;blockquo
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://nymrli.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>PIL的Image笔记</title>
    <link href="https://nymrli.top/2019/11/26/PIL%E7%9A%84Image%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2019/11/26/PIL的Image笔记/</id>
    <published>2019-11-26T10:06:58.000Z</published>
    <updated>2019-11-26T10:07:16.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pil的image学习"><a class="markdownIt-Anchor" href="#pil的image学习"></a> PIL的Image学习</h1><h2 id="transpose和rotate"><a class="markdownIt-Anchor" href="#transpose和rotate"></a> transpose和rotate</h2><ul><li>transpose</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = getCaptcha()</span><br><span class="line"><span class="comment"># 对称反转</span></span><br><span class="line">img.transpose(Image.FLIP_LEFT_RIGHT)</span><br></pre></td></tr></table></figure><ul><li>rotate</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = getCaptcha()</span><br><span class="line"><span class="comment"># expand默认为False时,超出原有尺寸的部分将用黑色填充,不会拓展尺寸</span></span><br><span class="line">img = img.rotate(<span class="number">45</span>)</span><br><span class="line"><span class="comment"># expand为True时,会根据图片大小,拓展尺寸</span></span><br><span class="line">img = img.rotate(<span class="number">45</span>,expand=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p><a href="https://pillow.readthedocs.io/en/3.1.x/reference/Image.html#PIL.Image.Image.transpose" target="_blank" rel="noopener">Pillow官网介绍</a></p><p><a href="https://blog.csdn.net/chenriwei2/article/details/42071517" target="_blank" rel="noopener">【图像处理】Python-Image 基本的图像处理</a></p><h2 id="convert函数"><a class="markdownIt-Anchor" href="#convert函数"></a> convert函数</h2><p>参数为mode(图像模式)。这是一个字符串，指定图像使用的像素格式。典型值为“1”，“L”，“RGB”或“CMYK”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = img.convert(<span class="string">"1"</span>)</span><br></pre></td></tr></table></figure><ul><li><code>1</code> (1-bit pixels, black and white, stored with one pixel per byte)</li><li><code>L</code> (8-bit pixels, black and white)</li><li><code>P</code> (8-bit pixels, mapped to any other mode using a color palette)</li><li><code>RGB</code> (3x8-bit pixels, true color)</li><li><code>RGBA</code> (4x8-bit pixels, true color with transparency mask)</li><li><code>CMYK</code> (4x8-bit pixels, color separation)</li><li><code>YCbCr</code> (3x8-bit pixels, color video format)</li><li><code>LAB</code> (3x8-bit pixels, the L<em>a</em>b color space)</li><li><code>HSV</code> (3x8-bit pixels, Hue, Saturation, Value color space)</li><li><code>I</code> (32-bit signed integer pixels)</li><li><code>F</code> (32-bit floating point pixels)</li></ul><h2 id="pil-image与nparray互转"><a class="markdownIt-Anchor" href="#pil-image与nparray互转"></a> PIL image与np.array互转</h2><h3 id="1-pil-image转换成array"><a class="markdownIt-Anchor" href="#1-pil-image转换成array"></a> 1. PIL image转换成array</h3><p><code>img = np.asarray(image)</code>或<code>img=np.array(image)</code></p><p>需要注意的是，如果出现read-only错误，并不是转换的错误，一般是你读取的图片的时候，默认选择的是&quot;r&quot;,&quot;rb&quot;模式有关。</p><p>修正的办法:　手动修改图片的读取状态<br>img.flags.writeable = True # 将数组改为读写模式</p><h3 id="2-array转换成image"><a class="markdownIt-Anchor" href="#2-array转换成image"></a> 2. array转换成image</h3><p><strong>方法1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">Image.fromarray(np.uint8(img))</span><br></pre></td></tr></table></figure><p><strong>方法2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">cv2.imwrite(<span class="string">"output.png"</span>, out)</span><br><span class="line"><span class="comment"># out可以是uint16类型数据</span></span><br><span class="line"><span class="comment"># 16位深度图像转8位灰度</span></span><br></pre></td></tr></table></figure><p><strong>方法3</strong></p><p>matlab</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img=imread(<span class="string">'output.png'</span>)</span><br><span class="line">img1=im2uint8(img)</span><br><span class="line">imwrite(img1,<span class="string">'result.jpg'</span>)</span><br></pre></td></tr></table></figure><p><strong>Numpy将二维数组添加到空数组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=np.empty(shape=[<span class="number">0</span>,<span class="number">3</span>], dtype=np.int32)</span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">c=[[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line"> </span><br><span class="line">print(a.shape)</span><br><span class="line">print(b.shape)</span><br><span class="line"> </span><br><span class="line">a = np.append(a, b, axis=<span class="number">0</span>)</span><br><span class="line">a = np.append(a, c, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 当axis为0时，数组是加在下面（列数要相同）：</span></span><br><span class="line"><span class="comment"># 当axis为1时，数组是加在右边（行数要相同）：</span></span><br><span class="line">print(a.shape)</span><br><span class="line">print(b.shape)</span><br></pre></td></tr></table></figure><p>reshape函数是numpy中一个很常用的函数，作用是在不改变矩阵的数值的前提下修改矩阵的形状。</p><p>1.简单使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y = np.reshape([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1, 2, 3, 4]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>2.使用缺省值-1</p><p>缺省值-1代表我不知道要给行（或者列）设置为几，reshape函数会根据原矩阵的形状自动调整。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">y = np.reshape([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],(<span class="number">4</span>,<span class="number">-1</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [3],</span></span><br><span class="line"><span class="string">       [4]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PIL.Image <span class="keyword">as</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line">IMAGES_PATH = <span class="string">'E:\picture\新垣结衣\\'</span>  <span class="comment"># 图片集地址</span></span><br><span class="line">IMAGES_FORMAT = [<span class="string">'.jpg'</span>, <span class="string">'.JPG'</span>]  <span class="comment"># 图片格式</span></span><br><span class="line">IMAGE_SIZE = <span class="number">256</span>  <span class="comment"># 每张小图片的大小</span></span><br><span class="line">IMAGE_ROW = <span class="number">4</span>  <span class="comment"># 图片间隔，也就是合并成一张图后，一共有几行</span></span><br><span class="line">IMAGE_COLUMN = <span class="number">4</span>  <span class="comment"># 图片间隔，也就是合并成一张图后，一共有几列</span></span><br><span class="line">IMAGE_SAVE_PATH = <span class="string">'E:\\picture\\新垣结衣\\final.jpg'</span>  <span class="comment"># 图片转换后的地址</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取图片集地址下的所有图片名称</span></span><br><span class="line">image_names = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(IMAGES_PATH) <span class="keyword">for</span> item <span class="keyword">in</span> IMAGES_FORMAT <span class="keyword">if</span></span><br><span class="line">               os.path.splitext(name)[<span class="number">1</span>] == item]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 简单的对于参数的设定和实际图片集的大小进行数量判断</span></span><br><span class="line"><span class="keyword">if</span> len(image_names) != IMAGE_ROW * IMAGE_COLUMN:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"合成图片的参数和要求的数量不能匹配！"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义图像拼接函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_compose</span><span class="params">()</span>:</span></span><br><span class="line">    to_image = Image.new(<span class="string">'RGB'</span>, (IMAGE_COLUMN * IMAGE_SIZE, IMAGE_ROW * IMAGE_SIZE)) <span class="comment">#创建一个新图</span></span><br><span class="line">    <span class="comment"># 循环遍历，把每张图片按顺序粘贴到对应位置上</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, IMAGE_ROW + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, IMAGE_COLUMN + <span class="number">1</span>):</span><br><span class="line">            from_image = Image.open(IMAGES_PATH + image_names[IMAGE_COLUMN * (y - <span class="number">1</span>) + x - <span class="number">1</span>]).resize(</span><br><span class="line">                (IMAGE_SIZE, IMAGE_SIZE),Image.ANTIALIAS)</span><br><span class="line">            to_image.paste(from_image, ((x - <span class="number">1</span>) * IMAGE_SIZE, (y - <span class="number">1</span>) * IMAGE_SIZE))</span><br><span class="line">    <span class="keyword">return</span> to_image.save(IMAGE_SAVE_PATH) <span class="comment"># 保存新图</span></span><br><span class="line">image_compose() <span class="comment">#调用函数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pil的image学习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pil的image学习&quot;&gt;&lt;/a&gt; PIL的Image学习&lt;/h1&gt;
&lt;h2 id=&quot;transpose和rotate&quot;&gt;&lt;a class=&quot;markdownIt-A
      
    
    </summary>
    
    
      <category term="编程笔记" scheme="https://nymrli.top/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="科学计算" scheme="https://nymrli.top/tags/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>2019年8月23号运维笔记</title>
    <link href="https://nymrli.top/2019/11/26/2019%E5%B9%B48%E6%9C%8823%E5%8F%B7%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2019/11/26/2019年8月23号运维笔记/</id>
    <published>2019-11-26T07:50:55.000Z</published>
    <updated>2019-11-26T07:51:12.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019年8月23号运维笔记"><a class="markdownIt-Anchor" href="#2019年8月23号运维笔记"></a> 2019年8月23号运维笔记</h1><h2 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> docker</h2><h3 id="docker-stop-containerid以后再重新启动时报错"><a class="markdownIt-Anchor" href="#docker-stop-containerid以后再重新启动时报错"></a> docker stop containerID，以后再重新启动时报错</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: driver failed programming external connectivity on endpoint app (3c0c01ac6b42b7a420644fc2b4debfbbcc0e1d2e74e6294155c28aca82f794c4):  (iptables failed: iptables --<span class="built_in">wait</span> -t nat -A DOCKER -p tcp -d 0/0 --dport 12345 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name.</span><br></pre></td></tr></table></figure><p>A: 重启docker即可：<code>systemctl restart docker</code></p><p>再开启你的容器： <code>docker run xxxx</code>或<code>docker start xxx</code></p><p>查看docker容器的运行日志</p><p><code>docker logs containerID</code></p><h3 id="docker端口映射到宿主机后外网仍无法访问容器的web"><a class="markdownIt-Anchor" href="#docker端口映射到宿主机后外网仍无法访问容器的web"></a> docker端口映射到宿主机后外网仍无法访问容器的web</h3><p>A：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决办法：</span></span><br><span class="line">$ sudo vi /etc/sysctl.conf</span><br><span class="line">或者</span><br><span class="line">$ sudo  vi /usr/lib/sysctl.d/00-system.conf</span><br><span class="line"><span class="comment"># 添加如下代码：</span></span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line">重启network服务</span><br><span class="line">$ sudo systemctl restart network</span><br><span class="line"></span><br><span class="line">查看是否修改成功</span><br><span class="line">$ sudo sysctl net.ipv4.ip_forward</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果返回为“net.ipv4.ip_forward = 1”则表示成功了</span></span><br></pre></td></tr></table></figure><h2 id="nginx"><a class="markdownIt-Anchor" href="#nginx"></a> nginx</h2><h3 id="查看nginx安装路径"><a class="markdownIt-Anchor" href="#查看nginx安装路径"></a> 查看nginx安装路径</h3><p><code>ps -ef | grep nginx</code></p><h2 id="查看nginx日志"><a class="markdownIt-Anchor" href="#查看nginx日志"></a> 查看nginx日志</h2><p><code>systemctl status nginx.service</code></p><p><code>journalctl -xe</code></p><h3 id="指定运行配置文件"><a class="markdownIt-Anchor" href="#指定运行配置文件"></a> 指定运行配置文件</h3><p>直接运行nginx可执行文件即可启动，nginx会自动读取配置文件目录下的“nginx.conf”配置文件，也可以在后面接“-c”参数来指定配置文件：</p><p><code>/usr/sbin/nginx -c /etc/nginx/sites-enabled/nginx.conf</code></p><h2 id="校验配置文件是否正确"><a class="markdownIt-Anchor" href="#校验配置文件是否正确"></a> 校验配置文件是否正确</h2><p>由于nginx的配置文件比较复杂容易出错，修改配置后可以用“-t”参数来校验配置文件是否正确：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -t    # 校验默认的配置文件</span><br><span class="line">nginx -t -c /path/to/configfile    # 校验指定配置文件</span><br></pre></td></tr></table></figure><h2 id="了解日志管理"><a class="markdownIt-Anchor" href="#了解日志管理"></a> 了解日志管理</h2><p>我们查看nginx安装目录下（<code>/var/log/nginx</code>）有个logs，包含了三个文件 “<strong>access.log</strong> 、<strong>error.log</strong>、<strong>nginx.pid</strong>”。</p><p>当然，日志配置肯定也是通过nginx.conf配置文件来进行配置的 ，那我先来看配置文件是怎么写的。</p><ul><li><code>access_log logs/access.log main</code>这个是指access.log日志用main格式来显示。</li><li><code>error_log logs/error.log error</code></li></ul><p>main格式是什么？mian格式是我们已经定义好了的一种各种，并取个名字便于引用。</p><p>默认的main格式中具体用了哪些选项来记录日志呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$remote_addr, $http_x_forwarded_for 记录客户端IP地址</span><br><span class="line">$remote_user 记录客户端用户名称</span><br><span class="line">$request 记录请求的URL和HTTP协议</span><br><span class="line">$status 记录请求状态</span><br><span class="line">$body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。</span><br><span class="line">$bytes_sent 发送给客户端的总字节数。</span><br><span class="line">$connection 连接的序列号。</span><br><span class="line">$connection_requests 当前通过一个连接获得的请求数量。</span><br><span class="line">$msec 日志写入时间。单位为秒，精度是毫秒。</span><br><span class="line">$pipe 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。</span><br><span class="line">$http_referer 记录从哪个页面链接访问过来的</span><br><span class="line">$http_user_agent 记录客户端浏览器相关信息</span><br><span class="line">$request_length 请求的长度（包括请求行，请求头和请求正文）。</span><br><span class="line">$request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。</span><br><span class="line">$time_iso8601 ISO8601标准格式下的本地时间。</span><br><span class="line">$time_local 通用日志格式下的本地时间。</span><br></pre></td></tr></table></figure><p>nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//该文件是存放到nginx安装目录下conf文件夹中</span><br><span class="line"> </span><br><span class="line">//全局区</span><br><span class="line"> </span><br><span class="line">//代表着当前有一个工作的子进程，可以自行修改，但是太多了无益因为会争夺cpu资源。一般最多设置成cpu数*核数</span><br><span class="line">worker_processes  1;</span><br><span class="line"> </span><br><span class="line">//一般配置nginx的连接特性</span><br><span class="line">events &#123;</span><br><span class="line">    //这里是指一个子进程最大允许连接1024个连接</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//这里是配置http服务器的主要段</span><br><span class="line">http &#123;</span><br><span class="line">    </span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    //这里配置的是日志的显示格式</span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                 &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                 &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    </span><br><span class="line">    //这里调用指定日志显示的格式</span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    //这里是配置虚拟主机段</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;//监听的端口</span><br><span class="line">        server_name  localhost;//监听访问地址</span><br><span class="line"> </span><br><span class="line">        #charset koi8-r;</span><br><span class="line"> </span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"> </span><br><span class="line">        //定位，把特殊的文件或者路径再次定位</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;//定位的目录，默认是ngxin安装目录下的html文件夹中</span><br><span class="line">            index  index.html index.htm;//定位的具体文件</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="nginx日志分析"><a class="markdownIt-Anchor" href="#nginx日志分析"></a> nginx日志分析</h2><p>分析截止目前为止访问量最高的IP排20名。</p><p><code>awk'{print $1}' /usr/local/nginx/logs/access.log |sort | uniq-c I|sort -nr</code></p><p>分析从早上9点至中午12点总的访问量。</p><p><code>sed-n&quot;/2016:09:00/,/2016:12:00/&quot; paccess_20161121.log</code></p><p>分析上一秒的访问请求数。</p><p><code>sed -n&quot;/2016：09：00：00/&quot; paccess_20161121.log</code></p><p>https签名：<a href="https://www.jianshu.com/p/0d455c7a9326" target="_blank" rel="noopener">https://www.jianshu.com/p/0d455c7a9326</a></p><h2 id="qnginx和uwsgi区别"><a class="markdownIt-Anchor" href="#qnginx和uwsgi区别"></a> Q：nginx和uwsgi区别</h2><p>nginx的作用：<br>1.反向代理，可以拦截一些web攻击，保护后端的web服务器<br>2.负载均衡，根据轮询算法，分配请求到多节点web服务器<br>3.缓存静态资源，加快访问速度，释放web服务器的内存占用，专项专用</p><p>uWSGI的适用：<br>1.单节点服务器的简易部署<br>2.轻量级，好部署</p><p>Q：已知一个使用nginx配置的web服务器的域名为www.my.com监听80端口,假设在服务器的/var/www/html这个目录下面有静态文件index.html,那么在配置文件其它部分相同的情况下，分别使用下面两种配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Location /abc &#123;</span><br><span class="line">    root /var/www/html; </span><br><span class="line">    index index.html; </span><br><span class="line">&#125;</span><br><span class="line">location/abc &#123; </span><br><span class="line">    alias /var/ww/html/; </span><br><span class="line">    index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问http://www.my.com/abc分别会有什么结果？</p><p>A：</p><ul><li>root 的为<code>/var/www/html/abc/index.html</code></li><li>alias的为<code>/var/www/html/index.html</code></li></ul><p>Q：所以使用浏览器访问的话这两种配置会有什么区别？</p><p>A：root的为404，alias的为200.</p><p>注：如果通过两个路径都能访问到的话，那无论哪个配置都是200</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019年8月23号运维笔记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2019年8月23号运维笔记&quot;&gt;&lt;/a&gt; 2019年8月23号运维笔记&lt;/h1&gt;
&lt;h2 id=&quot;docker&quot;&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="编程笔记" scheme="https://nymrli.top/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="运维" scheme="https://nymrli.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>app测试</title>
    <link href="https://nymrli.top/2019/11/26/app%E6%B5%8B%E8%AF%95/"/>
    <id>https://nymrli.top/2019/11/26/app测试/</id>
    <published>2019-11-26T07:49:58.000Z</published>
    <updated>2019-11-26T07:50:10.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="app测试"><a class="markdownIt-Anchor" href="#app测试"></a> app测试</h1><h2 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h2><p><code>adb shell monkey 500</code>随机执行500次</p><p><code>adb shell pm list packages -3</code> 查看第三方包</p><p><code>adb shell monkey -p tv.danmaku.bili</code>指定在某个软件中随机压力测试</p><p><code>adb shell monkey -p tv.danmaku.bili -p com.umaman.laiyifen 500</code>会先执行来伊份</p><p>▲.在测试应用程序某些选项的同时，也会进行系统级功能的测试，如截图、调音量等</p><p><code>adb shell monkey [-options] times</code></p><h3 id="参数说明"><a class="markdownIt-Anchor" href="#参数说明"></a> 参数说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-s seed种子值：种子相同时，就能产生一样的伪随机操作序列</span><br><span class="line">-p package指定包名：压力测试执行在某个软件内</span><br><span class="line">--pct-touch percentage：指定触摸的比例</span><br><span class="line">--throttle MILLSEC ：设置每个操作之间的间隔为xx毫秒</span><br><span class="line"></span><br><span class="line">-v [-v [-v]]：输出日志，v越多越详细</span><br><span class="line">--ignore-crashes ：不管程序有无崩溃，都执行完所有操作</span><br></pre></td></tr></table></figure><h2 id="各事件比例event-percentages"><a class="markdownIt-Anchor" href="#各事件比例event-percentages"></a> 各事件比例（Event percentages:）</h2><ul><li>0: 50.0%      -pct-touch  触摸操作</li><li>1: 5.8823533%-pct-motion 移动操作</li><li>2: 1.1764706%-pct-pinchzoom 缩放操作</li><li>3: 8.82353%-pct-traceball 滚动操作</li></ul><h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2><p>event injected数量不对</p><p>crash闪退</p><p>ANR没有响应</p><h2 id="出现异常后需要提供给开发的东西"><a class="markdownIt-Anchor" href="#出现异常后需要提供给开发的东西"></a> 出现异常后，需要提供给开发的东西</h2><p>l.被测手机详细信息<br>2.monkey测试日志<br>3.手机运行截图<br>4.monkey运行射手机日志</p><h1 id="测试用例"><a class="markdownIt-Anchor" href="#测试用例"></a> 测试用例</h1><h2 id="测试用例设计三部曲"><a class="markdownIt-Anchor" href="#测试用例设计三部曲"></a> 测试用例设计三部曲</h2><ul><li>要测试什么  -业务</li><li>怎么纠样测试           -测试环境搭建</li><li>如何判新正确与否    -需求</li></ul><h2 id="测试计划"><a class="markdownIt-Anchor" href="#测试计划"></a> 测试计划</h2><p>不同的环境下（兼容性）<br>正常安装</p><p>空间不足-&gt;验证松勤安卓APP在HWX空间不足的条件下的安装行为</p><ul><li>√正常行为：提示空间不够</li><li>x死机</li><li>提示错误代码，emor code201</li></ul><p>安装过程没电-重新安装</p><p>断网-网络Fiddler</p><h2 id="常用功能测试点"><a class="markdownIt-Anchor" href="#常用功能测试点"></a> 常用功能测试点</h2><p>常用的功能测试方法有“界面测试方法”和“黑盒测试技术”，具体可参见测试组配置库中的相应文档。下面列举了一些常用的功能测试点：<br>1.页面链接检查每一个链接是否都有对应的页面，并且页面之间切换正确。<br>2.相关性检查：删除/增加一项会不会对其他项产生影响，如果产生影响，这些影响是否都正确。<br>3.检查按钮的功能是否正确：如新增、修改、取消、删除、保存等功能是否正确。<br>4.字符串长度检查：输入超出需求规定的字符串长度的内容，看系统是否检查字符串长度，会不会有提示窗口。<br>5.字符类型检查：在应该输入指定类型的内容的地方输入其他类型的内容（如在应该输入整型的地方输入其他字符类型），看系统是否检查字符类型，是否会有提示窗口。<br>6.标点符号检查：输入内容包括各种标点符号，特别是空格，各种引号，回车键，看系统是否会有异常错误。<br>7.信息重复：在一些需要命名，且名字应该唯一的地方输入重复的名字或ID，看系统怎么处理，是否报错；重名是否区分大小写，以及在输入内容的前后输入空格，系统是否作出正确处理。<br>8.检查删除功能：在一些可以一次删除多个信息的地方，不选择任何信息，进行删除，看系统如何处理，是否出错；选择一个和多个信息，进行删除，看是否正确处理。<br>9.检查添加和修改是否一致：检查添加和修改信息的要求是否一致，如添加要求必填的项，修改也应该必填；添加规定为整型的项，修改也必须为整型。<br>10.检查修改重名：修改时把不能重名的项改为已存在的内容，看系统是否处理，报重名的错。<br>11.重复提交表单：一条已经成功提交的纪录，退出后再提交，看看系统是否会做什么处理。<br>12.查询功能：在有查询功能的地方输入系统存在和不存在的内容，结果是否正确；如果可以输入多个查询条件，同时添加合理和不合理的条件，看系统处理是否正确。<br>13.输入信息位置：注意在光标停留的地方输入信息时，光标和所输入的信息是否跳到别的地方。<br>14.上传下载文件检查：上传下载文件的功能是否实现，上传文件是否能打开。对上传文件的格式有何规定，系统是否有提示信息。<br>15.必填项检查：应该填写的项没有填写时系统是否都做了处理，对必填项是否有提示信息，如在必填项放加*。<br>16.快捷键检查：是否支持常用快捷键，如Ctl+C Ctrl+V Backspace等，对一些不允许输入信息的字段，如选人，选日期是否也有快捷键。<br>17.回车键检查：在输入结束后直接按回车键，看系统处理如何，会否报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;app测试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#app测试&quot;&gt;&lt;/a&gt; app测试&lt;/h1&gt;
&lt;h2 id=&quot;命令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#命令&quot;&gt;&lt;/a&gt; 命令&lt;/h2&gt;
&lt;
      
    
    </summary>
    
    
      <category term="测试" scheme="https://nymrli.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>2019-9月7号C++编程笔记</title>
    <link href="https://nymrli.top/2019/11/26/2019-9%E6%9C%887%E5%8F%B7C-%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2019/11/26/2019-9月7号C-编程笔记/</id>
    <published>2019-11-26T07:47:55.000Z</published>
    <updated>2019-11-26T07:48:23.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019-9月7号c编程笔记"><a class="markdownIt-Anchor" href="#2019-9月7号c编程笔记"></a> 2019-9月7号C++编程笔记</h1><h2 id="auto"><a class="markdownIt-Anchor" href="#auto"></a> auto</h2><p>定义变量时放在变量前，无需知道具体变量类型，系统可自行<strong>推断类型</strong>，减少编程工作，特别是在<strong>模板使用时，使用更方便</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> b=<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">auto</span> s=<span class="string">"abdc"</span>;</span><br><span class="line"><span class="keyword">auto</span> c;<span class="comment">//这样使用时错误的，系统无法自动推断出变量类型</span></span><br><span class="line"><span class="comment">//下面为迭代指针使用，很方便</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> it=vec.begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">模板使用案例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">creatTree</span><span class="params">(InputIterator in_beg,InputIterator in_end...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       .....</span><br><span class="line">        <span class="keyword">auto</span> inRootPos=find(in_beg,in_end,val);</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="stdnext"><a class="markdownIt-Anchor" href="#stdnext"></a> <strong>std::next</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Defined in header &lt;iterator&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">next</span>( <span class="title">ForwardIt</span> <span class="title">it</span>, <span class="title">typename</span> <span class="title">std</span>:</span>:iterator_traits&lt;ForwardIt&gt;::difference_type n = <span class="number">1</span> );</span><br></pre></td></tr></table></figure><ul><li><h3 id="parameters"><a class="markdownIt-Anchor" href="#parameters"></a> Parameters:</h3><ul><li>it  – 迭代指针</li><li>n  – 向前进的元素个数，缺省默认为1</li></ul></li><li><p><strong>Return value</strong></p><p>The nth successor of iterator it.（返回it的第n个后继迭代指针）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vals.size(); ++i) &#123;</span><br><span class="line"><span class="comment">// *std::next(vals.cbegin(), i)遍历set的所有值，每次取出一个val</span></span><br><span class="line"><span class="comment">// count为计算values中包含val的个数</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="built_in">std</span>::count(values.cbegin(), values.cend(), *<span class="built_in">std</span>::next(vals.cbegin(), i));</span><br></pre></td></tr></table></figure><h2 id="stdprev"><a class="markdownIt-Anchor" href="#stdprev"></a> <strong>std::prev</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法与next相似，不同的是prev返回的是it的第n个前驱迭代指针,即返回指针是begin()和rbegin()区别</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">BidirIt</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">BidirIt</span> <span class="title">prev</span>( <span class="title">BidirIt</span> <span class="title">it</span>, <span class="title">typename</span> <span class="title">std</span>:</span>:iterator_traits&lt;BidirIt&gt;::difference_type n = <span class="number">1</span> );</span><br></pre></td></tr></table></figure><h2 id="stdadvance"><a class="markdownIt-Anchor" href="#stdadvance"></a> std::advance</h2><blockquote><p><strong>方法与prev和next相似，只是无返回指针</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">next</span>(<span class="title">ForwardIt</span> <span class="title">it</span>, <span class="title">typename</span> <span class="title">std</span>:</span>:iterator_traits&lt;ForwardIt&gt;::difference_type n = <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::advance(it, n);</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const_cast"><a class="markdownIt-Anchor" href="#const_cast"></a> const_cast</h2><ul><li><p><strong>去掉const属性</strong>：<code>const_cast&lt;int*&gt; (&amp;num)</code>，常用，因为不能把一个const变量直接赋给一个非const变量，必须要转换。</p></li><li><p><strong>加上const属性</strong>：<code>const int* k = const_cast&lt;const int*&gt;(j)</code>，一般很少用，因为可以把一个非const变量直接赋给一个const变量，比如：const int* k = j;</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary_tree* tmp = <span class="keyword">const_cast</span>&lt;binary_tree*&gt;(node);</span><br></pre></td></tr></table></figure><h2 id="c11对vector成员函数的扩展"><a class="markdownIt-Anchor" href="#c11对vector成员函数的扩展"></a> C++11对vector成员函数的扩展</h2><h3 id="emplace_back"><a class="markdownIt-Anchor" href="#emplace_back"></a> emplace_back</h3><h3 id="stdvectorcbegin和stdvectorcend"><a class="markdownIt-Anchor" href="#stdvectorcbegin和stdvectorcend"></a> <strong>std::vector::cbegin和std::vector::cend</strong></h3><p>这两个方法是与std::vector::begin和std::vector::end相对应的，从字面就能看出来，多了一个’c’，顾名思义就是const的意思。同理，<strong>std::vector::crbegin和std::vector::crend</strong></p><h3 id="stdvectoremplace"><a class="markdownIt-Anchor" href="#stdvectoremplace"></a> <strong>std::vector::emplace</strong></h3><p>之前已经对emplace_back进行了讨论，其实还有一个方法叫emplace。<br>我想说的就是，emplace之于emplace_back就像insert之于push_back。如下使用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;code <span class="class"><span class="keyword">class</span>="<span class="title">hljs</span> <span class="title">cpp</span>"&gt;</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">main</span> ()</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> it = myvector.emplace ( myvector.begin()+<span class="number">1</span>, <span class="number">100</span> );</span><br><span class="line">  myvector.emplace ( it, <span class="number">200</span> );</span><br><span class="line">  myvector.emplace ( myvector.end(), <span class="number">300</span> );</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: myvector)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">myvector contains: 10 200 100 20 30 300&lt;/int&gt;&lt;/vector&gt;&lt;/iostream&gt;&lt;/code&gt;</span><br></pre></td></tr></table></figure><h3 id="stdvectordata"><a class="markdownIt-Anchor" href="#stdvectordata"></a> <strong>std::vector::data</strong></h3><p>Returns a direct pointer to the memory array used internally by the vector to store its owned elements.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;code <span class="class"><span class="keyword">class</span>="<span class="title">hljs</span> <span class="title">cpp</span>"&gt;#<span class="title">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">main</span> ()</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">int</span>* p = myvector.data();</span><br><span class="line">  *p = <span class="number">10</span>;</span><br><span class="line">  ++p;</span><br><span class="line">  *p = <span class="number">20</span>;</span><br><span class="line">  p[<span class="number">2</span>] = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;myvector.size(); ++i)</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myvector[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">      =<span class="string">""</span> output:=<span class="string">""</span> myvector=<span class="string">""</span> contains:=<span class="string">""</span> <span class="number">10</span>=<span class="string">""</span> <span class="number">20</span>=<span class="string">""</span> <span class="number">0</span>=<span class="string">""</span> <span class="number">100</span>=<span class="string">""</span> <span class="number">0</span>&lt;/<span class="keyword">int</span>&gt;&lt;/<span class="built_in">vector</span>&gt;&lt;/iostream&gt;&lt;/code&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019-9月7号c编程笔记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2019-9月7号c编程笔记&quot;&gt;&lt;/a&gt; 2019-9月7号C++编程笔记&lt;/h1&gt;
&lt;h2 id=&quot;auto&quot;&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="编程笔记" scheme="https://nymrli.top/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MinMax-极小极大算法——2048</title>
    <link href="https://nymrli.top/2019/11/26/MinMax-%E6%9E%81%E5%B0%8F%E6%9E%81%E5%A4%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%942048/"/>
    <id>https://nymrli.top/2019/11/26/MinMax-极小极大算法——2048/</id>
    <published>2019-11-26T07:46:41.000Z</published>
    <updated>2020-02-04T03:45:53.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="minmax-极小极大算法2048"><a class="markdownIt-Anchor" href="#minmax-极小极大算法2048"></a> MinMax-极小极大算法——2048</h1><h2 id="算法介绍"><a class="markdownIt-Anchor" href="#算法介绍"></a> 算法介绍</h2><h3 id="minmax"><a class="markdownIt-Anchor" href="#minmax"></a> MinMax</h3><blockquote><p>大家在编程的时候应该或多或少都接触到过这样的写法:<code>min(max(xxx,yyy))</code>，MinMax算法的表达形式就是如此，不过其中的Min和Max都是具有对应含义的。</p></blockquote><p>一般解决<strong>博弈类问题</strong>的自然想法是将格局组织成一棵），树的每一个节点表示一种格局，而父子关系表示由父格局经过一步可以到达子格局。Minimax也不例外，它通过对以当前格局为根的格局树搜索来确定下一步的选择。而一切格局树搜索算法的核心都是<strong>对每个格局价值的评价</strong>。Minimax算法基于以下朴素思想确定格局价值：</p><ul><li>Minimax是一种<strong>悲观算法</strong>，即假设对手每一步都会将我方引入从当前看理论上价值最小的格局方向，即<strong>对手具有完美决策能力</strong>。因此我方的策略应该是选择那些对方所能达到的让我方最差情况中最好的，也就是让<u>对方在完美决策</u>下所<u>对我造成的损失最小</u>。</li><li>Minimax<strong>不</strong>找<strong>理论最优解</strong>，因为理论最优解往往依赖于对手是否足够愚蠢，Minimax中我方完全掌握主动，如果对方每一步决策都是完美的，则我方可以达到预计的最小损失格局，如果对方没有走出完美决策，则我方可能达到比预计的最悲观情况更好的结局。总之我方就是要在<u>最坏情况中选择最好的</u>。</li></ul><p>举例For Example：</p><p>现在考虑这样一个游戏：有三个盘子A、B和C，每个盘子分别放有三张纸币。A放的是1、20、50；B放的是5、10、100；C放的是1、5、20。单位均为“元”。有甲、乙两人，两人均对三个盘子和上面放置的纸币有可以任意查看。游戏分三步：</p><ol><li>甲从三个盘子中选取一个。</li><li>乙从甲选取的盘子中拿出两张纸币交给甲。</li><li>甲从乙所给的两张纸币中选取一张，拿走。</li></ol><p>其中甲的目标是最后拿到的纸币面值尽量大，乙的目标是让甲最后拿到的纸币面值尽量小。</p><p>分析过程可看 <a href="https://nymrli.top/2019/11/26/MinMax%E5%92%8CAlpha-beta%E5%89%AA%E6%9E%9D%E5%88%86%E6%9E%90-%E8%BD%AC/">MinMax和Alpha-beta剪枝分析[转]</a></p><h3 id="alpha-beta剪枝"><a class="markdownIt-Anchor" href="#alpha-beta剪枝"></a> Alpha-beta剪枝</h3><blockquote><p>是在Minmax的基础上通过对<strong>每个结点下界alpha和上界beta值的维护</strong>进行了剪枝</p></blockquote><p>偶数层为Max层（己方），奇数层为Min层（对手），其中root为当前形势。</p><h4 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h4><p>在root层，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>α</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi>β</mi><mo separator="true">,</mo><msub><mi>N</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi>β</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>N</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi><mi>β</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mi>e</mi><mi>l</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi>β</mi><mo separator="true">,</mo><msub><mi>N</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha&#x27; = max(N_1.\beta, N_2.\beta,...,N_i.\beta)==(self.\beta,N_i.\beta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span></p><p>在Max层</p><ul><li><p>初始，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>α</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo>−</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mi>N</mi><mi mathvariant="normal">.</mi><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha&#x27;=max(-\infty, N.\beta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">−</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span></p></li><li><p>非叶子节点更新(包括根节点), <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>α</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>α</mi><mo separator="true">,</mo><msub><mi>N</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi>β</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>N</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha&#x27;=max(\alpha,N_1.\beta,...,N_i.\beta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span></p></li><li><p>叶子节点更新, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>α</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>s</mi><mi>e</mi><mi>l</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi>α</mi><mo separator="true">,</mo><msub><mi>N</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi>v</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>N</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha&#x27;=max(self.\alpha, N_1.v,...,N_i.v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></p></li><li><p>根节点更新，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>α</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>α</mi><mo separator="true">,</mo><msub><mi>N</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi>β</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>N</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha&#x27;=max(\alpha,N_1.\beta,...,N_i.\beta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span></p><p>▲更新后发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>f</mi><mi mathvariant="normal">.</mi><msup><mi>α</mi><mo mathvariant="normal">′</mo></msup><mo>&gt;</mo><mi>s</mi><mi>e</mi><mi>l</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">self.\alpha&#x27;&gt;self.\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>则剪枝，不再搜索</p></li></ul><p>在Min层,</p><ul><li><p>初始，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>β</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mi>N</mi><mi mathvariant="normal">.</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta&#x27;=min(\infty, N.v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></p></li><li><p>叶子节点更新，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>β</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi>v</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>N</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta&#x27;=min(N_1.v,...,N_i.v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></p></li><li><p>非叶子节点更新, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>β</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>s</mi><mi>e</mi><mi>l</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi>β</mi><mo separator="true">,</mo><msub><mi>N</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi>α</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>N</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta&#x27;=min(self.\beta,N_1.\alpha,...,N_i.\alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span></p><p>▲更新后发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>f</mi><mi mathvariant="normal">.</mi><msup><mi>β</mi><mo mathvariant="normal">′</mo></msup><mo>&lt;</mo><mi>s</mi><mi>e</mi><mi>l</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi>α</mi></mrow><annotation encoding="application/x-tex">self.\beta&#x27;&lt;self.\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>则剪枝，不再搜索</p></li></ul><p>△其中N为子节点; self.α表示当前节点已更新的α值</p><h4 id="伪代码"><a class="markdownIt-Anchor" href="#伪代码"></a> 伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function alphabeta(node, depth, α, β, Player)</span><br><span class="line">    //达到最深搜索深度或胜负已分         </span><br><span class="line">    if  depth = 0 or node is a terminal node</span><br><span class="line">        return the heuristic value of node</span><br><span class="line">    if  Player = MaxPlayer // 极大节点</span><br><span class="line">        for each child of node // 子节点是极小节点</span><br><span class="line">            α := max(α, alphabeta(child, depth-1, α, β, not(Player) ))   </span><br><span class="line">            if β ≤ α </span><br><span class="line">            // 该极大节点的值&gt;=α&gt;=β，该极大节点后面的搜索到的值肯定会大于β，因此不会被其上层的极小节点所选用了。对于根节点，β为正无穷</span><br><span class="line">                 break //beta剪枝                        </span><br><span class="line">        return α</span><br><span class="line">    else // 极小节点</span><br><span class="line">        for each child of node //子节点是极大节点</span><br><span class="line">            β := min(β, alphabeta(child, depth-1, α, β, not(Player) )) // 极小节点</span><br><span class="line">            if β ≤ α // 该极大节点的值&lt;=β&lt;=α，该极小节点后面的搜索到的值肯定会小于α，因此不会被其上层的极大节点所选用了。对于根节点，α为负无穷</span><br><span class="line">                break //alpha剪枝</span><br><span class="line">        return β</span><br></pre></td></tr></table></figure><h2 id="2048ai介绍"><a class="markdownIt-Anchor" href="#2048ai介绍"></a> 2048AI介绍</h2><p>游戏规则:</p><p>2048游戏共有16个格子，初始时初始数字由2或者4构成，之后每次移动生成2的概率为0.9，生成4的概率为0.1，见<a href="#2048%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E6%96%B0%E6%95%B0%E5%AD%97%E6%BA%90%E7%A0%81">2048随机生成新数字源码</a>。</p><blockquote><p>1、手指向一个方向滑动，所有格子会向那个方向运动。<br>2、相同数字的两个格子，相撞时数字会相加。<br>3、每次滑动时，空白处会随机刷新出一个数字的格子。<br>4、当界面不可运动时（当界面全部被数字填满时），游戏结束；当界面中最大数字是2048时，游戏胜利。</p></blockquote><h3 id="建模"><a class="markdownIt-Anchor" href="#建模"></a> <em><strong>建模:</strong></em></h3><p>之前的对弈类游戏, 博弈双方的地位都是对等的. 但这边只有游戏者一人, 对手在哪里?<br>　　让人脑洞大开的是, 2048游戏AI的设计者, 创造性把<strong>棋局环境本身做为了博弈的另一方</strong>.<br>　　当然双方追求的胜利目标不一样:<br>　　• 我方：<strong>游戏者(AI)， 追求2048及2048以上的方块出现</strong><br>　　• 对方：<strong>计算机(棋局环境)， 填满棋局格子, 使得4个方向皆不能移动</strong><br>• 胜利条件：出现某个方块的数值为“2048”。<br>•失败条件：格子全满，且无法向四个方向中任何一个方向移动（均不能触发合并）。<br>　　▲.游戏模型就被建模成了信息完备的双人对弈问题. 而传统博弈树和技巧就自然有了用武之地.</p><h3 id="评估函数"><a class="markdownIt-Anchor" href="#评估函数"></a> <em><strong>评估函数:</strong></em></h3><blockquote><p><strong>评估函数</strong>是算法的核心，如何评价当前格局的价值是重中之重。依据游戏经验, 作者选用了如下评估因素:<br>　　(1) <strong>单调性</strong>: 指方块从左到右、从上到下均遵从递增或递减.<br>　　(2) <strong>平滑性</strong>: 指每个方块与其直接相邻方块数值的差，其中差越小越平滑.<br>　　(3) <strong>空格数</strong>: 局面的空格总数.<br>　　(4) <strong>最大数</strong>: 当前局面的最大数字, 该特征为积极因子.</p></blockquote><p>采用线性函数, 并添加权重系数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static evaluation function</span></span><br><span class="line">AI.prototype.eval = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> emptyCells = <span class="keyword">this</span>.grid.availableCells().length;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> smoothWeight = <span class="number">0.1</span>,</span><br><span class="line">      <span class="comment">//monoWeight   = 0.0,</span></span><br><span class="line">      <span class="comment">//islandWeight = 0.0,</span></span><br><span class="line">      mono2Weight  = <span class="number">1.0</span>,</span><br><span class="line">      emptyWeight  = <span class="number">2.7</span>,</span><br><span class="line">      maxWeight    = <span class="number">1.0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.grid.smoothness() * smoothWeight</span><br><span class="line">       <span class="comment">//+ this.grid.monotonicity() * monoWeight</span></span><br><span class="line">       <span class="comment">//- this.grid.islands() * islandWeight</span></span><br><span class="line">       + <span class="keyword">this</span>.grid.monotonicity2() * mono2Weight</span><br><span class="line">       + <span class="built_in">Math</span>.log(emptyCells) * emptyWeight</span><br><span class="line">       + <span class="keyword">this</span>.grid.maxValue() * maxWeight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分析：<strong>前3项能衡量一个局面的好坏</strong>, 而<strong>最大数该项, 则让游戏AI多了一点积极和&quot;冒险&quot;</strong></p><h3 id="执行过程-2"><a class="markdownIt-Anchor" href="#执行过程-2"></a> 执行过程</h3><p>游戏AI的决策过程, 是标准的maxmin search和alpha+beta pruning的实现. 所有的方向(上下左右)都会去尝试.</p><h4 id="alphabeta-pruning-worst-consideration-pruning"><a class="markdownIt-Anchor" href="#alphabeta-pruning-worst-consideration-pruning"></a> Alpha+beta pruning + worst consideration pruning</h4><p>然而在游戏本身做决策时, 在Min节点还采用了另一种剪枝，即只考虑对方走出让格局最差的那一步（而实际2048中计算机的选择是随机的），做为搜索分支的剪枝条件，即不是每个空格都去尝试填{2, 4}。</p><p>这种假定<strong>环境生成了最坏的局面</strong>的剪枝做法，可以很好地提高搜索效率，并且获得更强的生存能力。如果全部搜索的话，对方所有可能的选择就为变成了“空格数×2”种，使得搜索效率很低，严重限制搜索深度。而这种选择性地丢掉了很多搜索分支，能够大大地提高搜索效率。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try a 2 and 4 in each cell and measure how annoying it is</span></span><br><span class="line"><span class="comment">// with metrics from eval</span></span><br><span class="line"><span class="keyword">var</span> candidates = [];</span><br><span class="line"><span class="keyword">var</span> cells = <span class="keyword">this</span>.grid.availableCells();</span><br><span class="line"><span class="keyword">var</span> scores = &#123; <span class="number">2</span>: [], <span class="number">4</span>: [] &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">in</span> scores) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> cells) &#123;</span><br><span class="line">    scores[value].push(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">var</span> cell = cells[i];</span><br><span class="line">    <span class="keyword">var</span> tile = <span class="keyword">new</span> Tile(cell, <span class="built_in">parseInt</span>(value, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">this</span>.grid.insertTile(tile);</span><br><span class="line">    scores[value][i] = -<span class="keyword">this</span>.grid.smoothness() + <span class="keyword">this</span>.grid.islands();</span><br><span class="line">    <span class="keyword">this</span>.grid.removeTile(cell);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// now just pick out the most annoying moves</span></span><br><span class="line"><span class="keyword">var</span> maxScore = <span class="built_in">Math</span>.max(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, scores[<span class="number">2</span>]), <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, scores[<span class="number">4</span>]));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">in</span> scores) &#123; <span class="comment">// 2 and 4</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;scores[value].length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (scores[value][i] == maxScore) &#123;</span><br><span class="line">      candidates.push( &#123; <span class="attr">position</span>: cells[i], <span class="attr">value</span>: <span class="built_in">parseInt</span>(value, <span class="number">10</span>) &#125; );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：对于<strong>选择性忽略搜索节点</strong>, 其实很有争议. 在某些情况下, 会失去获取最优解的机会. 不过砍掉了很多分支后, 其搜索深度大大加强. <strong>生存能力更强大</strong>.</p><h3 id="限时的迭代深搜"><a class="markdownIt-Anchor" href="#限时的迭代深搜"></a> 限时的迭代深搜</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// performs iterative deepening over the alpha-beta search</span></span><br><span class="line">AI.prototype.iterativeDeep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">  <span class="keyword">var</span> depth = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> best;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newBest = <span class="keyword">this</span>.search(depth, <span class="number">-10000</span>, <span class="number">10000</span>, <span class="number">0</span> ,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (newBest.move == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      best = newBest;</span><br><span class="line">    &#125;</span><br><span class="line">    depth++;</span><br><span class="line">  &#125; <span class="keyword">while</span> ( (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - start &lt; minSearchTime);</span><br><span class="line">  <span class="keyword">return</span> best</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码没有限制搜索的深度，但是限制了每次“思考”的时间：<strong>超时判断在每个深度探索结束后进行</strong>, 这<strong>未必会精确, 甚至误差很大</strong>. 我还是<strong>推崇前文谈到过的实现方式</strong>.但不管怎样, 作者基本达到了其每100ms决策一步的要求.</p><h3 id="python实现核心代码"><a class="markdownIt-Anchor" href="#python实现核心代码"></a> Python实现核心代码:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2><h3 id="极大极小算法有些不明白"><a class="markdownIt-Anchor" href="#极大极小算法有些不明白"></a> 极大极小算法有些不明白 ?</h3><p>极小极大算法主要应用于什么样的游戏：</p><ul><li>零和游戏（Zero-sum Game）</li><li>完全信息（Perfect Information）——Max代表你自己，Min代表你的对手</li></ul><h3 id="对弈类游戏的人工智能52048游戏ai的解读"><a class="markdownIt-Anchor" href="#对弈类游戏的人工智能52048游戏ai的解读"></a> <a href="https://www.cnblogs.com/mumuxinfei/p/4415352.html" target="_blank" rel="noopener">对弈类游戏的人工智能(5)–2048游戏AI的解读</a></h3><ul><li><strong>把环境拟人化的对弈模型, 也是面对反馈类场景的一种很好的评估决策思路.</strong></li></ul><h3 id="2048-ai程序算法分析"><a class="markdownIt-Anchor" href="#2048-ai程序算法分析"></a> <a href="http://blog.codinglabs.org/articles/2048-ai-analysis.html" target="_blank" rel="noopener">2048-AI程序算法分析</a>——Java实现</h3><h3 id="一图流解释-alpha-beta-剪枝alpha-beta-pruning"><a class="markdownIt-Anchor" href="#一图流解释-alpha-beta-剪枝alpha-beta-pruning"></a> <a href="https://www.7forz.com/3211/" target="_blank" rel="noopener">一图流解释 Alpha-Beta 剪枝(Alpha-Beta Pruning)</a></h3><h3 id="2048高分技巧"><a class="markdownIt-Anchor" href="#2048高分技巧"></a> <strong>2048高分技巧</strong></h3><p>1、最大数尽可能放在角落。<br>2、数字按顺序紧邻排列。<br>3、首先满足最大数和次大数在的那一列/行是满的。<br>4、时刻注意活动较大数（32以上）旁边要有相近的数。<br>5、以大数所在的一行为主要移动方向<br>6、不要急于“清理桌面”。</p><h3 id="2048随机生成新数字源码"><a class="markdownIt-Anchor" href="#2048随机生成新数字源码"></a> 2048随机生成新数字源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adds a tile in a random position</span></span><br><span class="line">Grid.prototype.addRandomTile = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.cellsAvailable()) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="built_in">Math</span>.random() &lt; <span class="number">0.9</span> ? <span class="number">2</span> : <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//var value = Math.random() &lt; 0.9 ? 256 : 512;</span></span><br><span class="line">    <span class="keyword">var</span> tile = <span class="keyword">new</span> Tile(<span class="keyword">this</span>.randomAvailableCell(), value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.insertTile(tile);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>▲需要注意的是，2的几率是0.9，4的几率是0.1，但是除了开局会随机出现1或者2个方块，而在正常游戏中每次移动后只出现一个随机方块。——我当时自己写的是随机1-2个，导致我的分数挺低的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;minmax-极小极大算法2048&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#minmax-极小极大算法2048&quot;&gt;&lt;/a&gt; MinMax-极小极大算法——2048&lt;/h1&gt;
&lt;h2 id=&quot;算法介绍&quot;&gt;&lt;a class=&quot;mark
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://nymrli.top/tags/Algorithm/"/>
    
      <category term="RL" scheme="https://nymrli.top/tags/RL/"/>
    
  </entry>
  
  <entry>
    <title>MinMax和Alpha-beta剪枝分析[转]</title>
    <link href="https://nymrli.top/2019/11/26/MinMax%E5%92%8CAlpha-beta%E5%89%AA%E6%9E%9D%E5%88%86%E6%9E%90-%E8%BD%AC/"/>
    <id>https://nymrli.top/2019/11/26/MinMax和Alpha-beta剪枝分析-转/</id>
    <published>2019-11-26T07:45:45.000Z</published>
    <updated>2019-11-26T07:46:23.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="minmax和alpha-beta剪枝分析转"><a class="markdownIt-Anchor" href="#minmax和alpha-beta剪枝分析转"></a> MinMax和Alpha-beta剪枝分析<a href="http://blog.codinglabs.org/articles/2048-ai-analysis.html" target="_blank" rel="noopener">[转]</a></h1><ul><li>一般解决<strong>博弈类问题</strong>的自然想法是将格局组织成一棵），树的每一个节点表示一种格局，而父子关系表示由父格局经过一步可以到达子格局。Minimax也不例外，它通过对以当前格局为根的格局树搜索来确定下一步的选择。而一切格局树搜索算法的核心都是<strong>对每个格局价值的评价</strong>。Minimax算法基于以下朴素思想确定格局价值：<ul><li>Minimax是一种<strong>悲观算法</strong>，即假设对手每一步都会将我方引入从当前看理论上价值最小的格局方向，即<strong>对手具有完美决策能力</strong>。因此我方的策略应该是选择那些对方所能达到的让我方最差情况中最好的，也就是让<u>对方在完美决策</u>下所<u>对我造成的损失最小</u>。</li><li>Minimax<strong>不</strong>找<strong>理论最优解</strong>，因为理论最优解往往依赖于对手是否足够愚蠢，Minimax中我方完全掌握主动，如果对方每一步决策都是完美的，则我方可以达到预计的最小损失格局，如果对方没有走出完美决策，则我方可能达到比预计的最悲观情况更好的结局。总之我方就是要在<u>最坏情况中选择最好的</u>。</li></ul></li></ul><h2 id="实际举例"><a class="markdownIt-Anchor" href="#实际举例"></a> 实际举例:</h2><p>现在考虑这样一个游戏：有三个盘子A、B和C，每个盘子分别放有三张纸币。A放的是1、20、50；B放的是5、10、100；C放的是1、5、20。单位均为“元”。有甲、乙两人，两人均对三个盘子和上面放置的纸币有可以任意查看。游戏分三步：</p><ol><li>甲从三个盘子中选取一个。</li><li>乙从甲选取的盘子中拿出两张纸币交给甲。</li><li>甲从乙所给的两张纸币中选取一张，拿走。</li></ol><p>其中甲的目标是最后拿到的纸币面值尽量大，乙的目标是让甲最后拿到的纸币面值尽量小。</p><p>下面用Minimax算法解决这个问题。</p><h2 id="解题"><a class="markdownIt-Anchor" href="#解题"></a> 解题：</h2><h3 id="建树"><a class="markdownIt-Anchor" href="#建树"></a> 建树</h3><p>下图是上述示例问题的格局树：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/2048-ai-analysis/01.png" alt="img"></p><p>注意，由于示例问题格局数非常少，我们可以给出完整的格局树。这种情况下我可以找到Minimax算法的全局最优解。而<u>真实情况中，格局树非常庞大，即使是计算机也不可能给出完整的树</u>，因此我们往往<u>只搜索一定深度</u>，这时只能找到<u>局部最优解</u>。</p><p>我们从甲的角度考虑。其中正方形节点表示轮到我方（甲），而三角形表示轮到对方（乙）。经过三轮对弈后（我方-对方-我方），将进入终局。黄色叶结点表示所有可能的结局。从甲方看，由于最终的收益可以通过纸币的面值评价，我们自然可以用结局中甲方拿到的纸币面值表示终格局的价值。</p><p>下面考虑倒数第二层节点，在这些节点上，轮到我方选择，所以我们应该引入可选择的最大价值格局，因此每个节点的价值为其子节点的最大值：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/2048-ai-analysis/02.png" alt="img"></p><p>这些轮到我方的节点叫做max节点，max节点的值是其子节点最大值。</p><p>倒数第三层轮到对方选择，假设对方会尽力将局势引入让我方价值最小的格局，因此这些节点的价值取决于子节点的最小值。这些轮到对方的节点叫做min节点。</p><p>最后，根节点是max节点，因此价值取决于叶子节点的最大值。最终完整赋值的格局树如下：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/2048-ai-analysis/03.png" alt="img"></p><p>总结一下Minimax算法的步骤：</p><ol><li>首先确定最大搜索深度D，D可能达到终局，也可能是一个中间格局。</li><li>在最大深度为D的格局树叶子节点上，使用预定义的价值评价函数对叶子节点价值进行评价。</li><li>自底向上为非叶子节点赋值。其中max节点取子节点最大值，min节点取子节点最小值。</li><li>每次轮到我方时（此时必处在格局树的某个max节点），选择价值等于此max节点价值的那个子节点路径。</li></ol><p>在上面的例子中，根节点的价值为20，表示如果对方每一步都完美决策，则我方按照上述算法可最终拿到20元，这是我方在Minimax算法下最好的决策。格局转换路径如下图红色路径所示：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/2048-ai-analysis/04.png" alt="img"></p><p>对于真实问题中的Minimax，再次强调几点：</p><ul><li>真实问题一般无法构造出完整的格局树，所以需要确定一个最大深度D，每次最多从当前格局向下计算D层。</li><li>因为上述原因，Minimax一般是寻找一个局部最优解而不是全局最优解，搜索深度越大越可能找到更好的解，但计算耗时会呈指数级膨胀。</li><li>也是因为无法一次构造出完整的格局树，所以真实问题中Minimax一般是边对弈边计算局部格局树，而不是只计算一次，但已计算的中间结果可以缓存。</li></ul><h3 id="alpha-beta剪枝"><a class="markdownIt-Anchor" href="#alpha-beta剪枝"></a> Alpha-beta剪枝</h3><p>简单的Minimax算法有一个很大的问题就是计算复杂性。由于所需搜索的节点数随最大深度呈指数膨胀，而算法的效果往往和深度相关，因此这极大限制了算法的效果。</p><p>Alpha-beta剪枝是对Minimax的补充和改进。采用Alpha-beta剪枝后，我们可不必构造和搜索最大深度D内的所有节点，在构造过程中，如果发现当前格局再往下不能找到更好的解，我们就停止在这个格局及以下的搜索，也就是剪枝。</p><p>Alpha-beta基于这样一种朴素的思想：时时刻刻记得当前已经知道的最好选择，如果从当前格局搜索下去，不可能找到比已知最优解更好的解，则停止这个格局分支的搜索（剪枝），回溯到父节点继续搜索。</p><p>Alpha-beta算法可以看成变种的Minimax，基本方法是从根节点开始采用深度优先的方式构造格局树，在构造每个节点时，都会读取此节点的alpha和beta两个值，其中alpha表示搜索到当前节点时已知的最好选择的下界，而beta表示从这个节点往下搜索最坏结局的上界。由于我们假设对手会将局势引入最坏结局之一，因此当beta小于alpha时，表示从此处开始不论最终结局是哪一个，其上限价值也要低于已知的最优解，也就是说已经不可能此处向下找到更好的解，所以就会剪枝。</p><p>下面同样以上述示例介绍Alpha-beta剪枝算法的工作原理。我们从根节点开始，详述使用Alpha-beta的每一个步骤：</p><ol><li><p>根节点的alpha和beta分别被初始化为−∞−∞，和+∞+∞。</p></li><li><p>深度优先搜索第一个孩子，不是叶子节点，所以alpha和beta继承自父节点，分别为−∞−∞，和+∞+∞</p></li><li><p>搜索第三层的第一个孩子，同上。</p></li><li><p>搜索第四层，到达叶子节点，采用评价函数得到此节点的评价值为1。</p><p><img src="http://blog.codinglabs.org/uploads/pictures/2048-ai-analysis/05.png" alt="img"></p></li><li><p>此叶节点的父节点为max节点，因此更新其alpha值为1，表示此节点取值的下界为1。</p></li><li><p>再看另外一个子节点，值为20，大于当前alpha值，因此将alpha值更新为20。</p></li><li><p>此时第三层最左节点所有子树搜索完毕，作为max节点，更新其真实值为当前alpha值：20。</p></li><li><p>由于其父节点（第二层最左节点）为min节点，因此更新其父节点beta值为20，表示这个节点取值最多为20。</p><p><img src="http://blog.codinglabs.org/uploads/pictures/2048-ai-analysis/06.png" alt="img"></p></li><li><p>搜索第二层最左节点的第二个孩子及其子树，按上述逻辑，得到值为50（注意第二层最左节点的beta值要传递给孩子）。由于50大于20，不更新min节点的beta值。</p><p><img src="http://blog.codinglabs.org/uploads/pictures/2048-ai-analysis/07.png" alt="img"></p></li><li><p>搜索第二层最左节点的第三个孩子。当看完第一个叶子节点后，发现第三个孩子的alpha=beta，此时表示这个节点下不会再有更好解，于是剪枝。</p><p><img src="http://blog.codinglabs.org/uploads/pictures/2048-ai-analysis/08.png" alt="img"></p></li><li><p>继续搜索B分支，当搜索完B分支的第一个孩子后，发现此时B分支的alpha为20，beta为10。这表示B分支节点的最大取值不会超过10，而我们已经在A分支取到20，此时满足alpha大于等于beta的剪枝条件，因此将B剪枝。并将B分支的节点值设为10，注意，这个10不一定是这个节点的真实值，而只是上线，B节点的真实值可能是5，可能是1，可能是任何小于10的值。但是已经无所谓了，反正我们知道这个分支不会好过A分支，因此可以放弃了。</p><p><img src="http://blog.codinglabs.org/uploads/pictures/2048-ai-analysis/09.png" alt="img"></p></li><li><p>在C分支搜索时遇到了与B分支相同的情况。因此讲C分支剪枝。</p><p><img src="http://blog.codinglabs.org/uploads/pictures/2048-ai-analysis/10.png" alt="img"></p></li></ol><p>此时搜索全部完毕，而我们也得到了这一步的策略：应该走A分支。</p><p>可以看到相比普通Minimax要搜索18个叶子节点相比，这里只搜索了9个。采用Alpha-beta剪枝，可以在相同时间内加大Minimax的搜索深度，因此可以获得更好的效果。并且Alpha-beta的解和普通Minimax的解是一致的。</p><p>文章摘自<a href="http://blog.codinglabs.org/articles/2048-ai-analysis.html" target="_blank" rel="noopener">2048-AI程序算法分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;minmax和alpha-beta剪枝分析转&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#minmax和alpha-beta剪枝分析转&quot;&gt;&lt;/a&gt; MinMax和Alpha-beta剪枝分析&lt;a href=&quot;http://blog.c
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://nymrli.top/tags/Algorithm/"/>
    
      <category term="RL" scheme="https://nymrli.top/tags/RL/"/>
    
  </entry>
  
  <entry>
    <title>Python网络编程Websocket</title>
    <link href="https://nymrli.top/2019/11/24/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BWebsocket/"/>
    <id>https://nymrli.top/2019/11/24/Python网络编程Websocket/</id>
    <published>2019-11-24T02:17:11.000Z</published>
    <updated>2019-11-28T12:00:00.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络知识websocket"><a class="markdownIt-Anchor" href="#网络知识websocket"></a> 网络知识——Websocket</h1><ul><li><p>TCP ：面向连接—&gt; 打电话(相互回复,一来一回)，客户端向服务器端 拨号 , 三次握手 ,</p></li><li><p>UDP : 面向无连接 --&gt; 寄快递(寄出去就不管了) e.g.直播</p></li></ul><p><strong>UDP四层结构</strong></p><ul><li>网络访问层(链路层):  物理连接设备(网线)、MAC地址（物理地址）</li><li>互联网层： IP地址（定位设备）</li><li>传输层： port (端口号) : 表示通信进程,将数据交给哪个应用处理</li><li>应用层： 自己定义的协议（处理字符串消息的方法）</li></ul><p>套接字(socket) ： 特殊的设备文件 ， 写网络应用程序的接口，写入后就是发送，接收就是读取。 类似于 esp8266吧…</p><p><strong>基本的socket操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">参数说明:</span></span><br><span class="line"><span class="string">AF_INET IPv4</span></span><br><span class="line"><span class="string">----</span></span><br><span class="line"><span class="string">STREAM TCP</span></span><br><span class="line"><span class="string">SOCK_DGRAM UDP,无listen、accpet</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">server_addr = (<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>)    <span class="comment"># 本地回环地址 , 端口</span></span><br><span class="line">s.bind(server_addr)                                    <span class="comment"># 绑定、传入信息</span></span><br><span class="line">data, cilent_addr = s.recvfrom(<span class="number">1024</span>)        <span class="comment"># BUF_SIZE指定接收数据长度 , (数据内容,客户端地址)</span></span><br><span class="line">s.sendto(data,cilent_addr)                        <span class="comment"># 给客户端发送数据</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buf = <span class="number">1024</span></span><br><span class="line">ADDR = (<span class="string">"127.0.0.1"</span>, <span class="number">8999</span>)</span><br><span class="line">tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">tcpSock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">tcpSock.bind(ADDR)</span><br><span class="line">tcpSock.listen(<span class="number">5</span>)</span><br><span class="line">conn, addr = tcpSock.accept()</span><br></pre></td></tr></table></figure><h3 id="什么是webscoket"><a class="markdownIt-Anchor" href="#什么是webscoket"></a> 什么是webscoket？</h3><p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行<strong>全双工通讯</strong>的协议。HTML5 WebSocket 设计出来的目的就是要<strong>取代轮询</strong>和 Comet 技术，使客户端浏览器具备像 C/S 架构下桌面系统的实时通讯能力。</p><p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端<strong>主动</strong>向客户端推送数据。在WebSocket API 中，浏览器和服务器只需要完成<strong>一次握手</strong>，两者之间就直接可以创建持久性的连接，并进行双向数据传输，其本质是保持TCP连接。</p><ul><li>客户端 : 发送数据、接收返回数据端</li><li>服务端: 处理数据端</li></ul><p><strong>服务端</strong></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,base64,hashlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_headers</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">'''提取请求头,将请求头转换为字典'''</span></span><br><span class="line">    header_dict = &#123;&#125;</span><br><span class="line">    data = str(data,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">    header,body = data.split(<span class="string">"\r\n\r\n"</span>,<span class="number">1</span>)</span><br><span class="line">    header_list = header.split(<span class="string">"\r\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(header_list)):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> len(header_list[<span class="number">0</span>].split(<span class="string">" "</span>)) == <span class="number">3</span>:</span><br><span class="line">                header_dict[<span class="string">'method'</span>],header_dict[<span class="string">'url'</span>],header_dict[<span class="string">'protocol'</span>] = header_list[<span class="number">0</span>].split(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k,v=header_list[i].split(<span class="string">":"</span>,<span class="number">1</span>)</span><br><span class="line">            header_dict[k]=v.strip()</span><br><span class="line">    <span class="keyword">return</span> header_dict</span><br><span class="line"></span><br><span class="line">sock = socket.socket()</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 指定IP和侦听端口Port</span></span><br><span class="line">sock.bind((<span class="string">"127.0.0.1"</span>,<span class="number">8888</span>))</span><br><span class="line">sock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#等待用户连接</span></span><br><span class="line">conn,addr = sock.accept()</span><br><span class="line">print(<span class="string">"conn from "</span>,conn,addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取握手消息，magic string ,sha1加密</span></span><br><span class="line"><span class="comment">#发送给客户端</span></span><br><span class="line"><span class="comment">#握手消息</span></span><br><span class="line">data = conn.recv(<span class="number">8096</span>)</span><br><span class="line">headers = get_headers(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对请求头中的sec-websocket-key进行加密,需要返回的头</span></span><br><span class="line">response_tpl = <span class="string">"HTTP/1.1 101 Switching Protocols\r\n"</span> \</span><br><span class="line">      <span class="string">"Upgrade:websocket\r\n"</span> \</span><br><span class="line">      <span class="string">"Connection: Upgrade\r\n"</span> \</span><br><span class="line">      <span class="string">"Sec-WebSocket-Accept: %s\r\n"</span> \</span><br><span class="line">      <span class="string">"WebSocket-Location: ws://%s%s\r\n\r\n"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># magic_string为一个固定的字符串</span></span><br><span class="line">magic_string = <span class="string">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line">value = headers[<span class="string">'Sec-WebSocket-Key'</span>] + magic_string</span><br><span class="line">ac = base64.b64encode(hashlib.sha1(value.encode(<span class="string">'utf-8'</span>)).digest())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回的信息</span></span><br><span class="line">response_str = response_tpl % (ac.decode(<span class="string">'utf-8'</span>), headers[<span class="string">'Host'</span>], headers[<span class="string">'url'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应【握手】信息</span></span><br><span class="line">conn.send(bytes(response_str, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment">#复制代码</span></span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><p><em>Python</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> thread</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> _thread <span class="keyword">as</span> thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># import websocket</span></span><br><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ws = websocket.WebSocket()</span></span><br><span class="line">ws = websocket.create_connection(<span class="string">"ws://127.0.0.1:8999/"</span>)</span><br><span class="line"><span class="comment"># ws.connect("ws://127.0.0.1:8999/")</span></span><br><span class="line">data = &#123;<span class="string">"body"</span>:&#123;<span class="string">"address"</span>:<span class="string">"陕西省"</span>&#125;&#125;</span><br><span class="line">ws.send(json.dumps(data))   <span class="comment">#json转化为字符串，必须转化</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    data = ws.recv()</span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure><p><strong>Java Script</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        ws =<span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8888"</span>);</span></span><br><span class="line"><span class="actionscript">        ws.onopen = <span class="function"><span class="keyword">function</span> <span class="params">(ev)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//若是连接成功，onopen函数会执行</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(ev)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="actionscript">        ws.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(ev)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//若是连接成功，onopen函数会执行</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(ev)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>大端和小端模式</strong></p><p>网络通信时 通常使用大端</p><h3 id="解析websocket协议"><a class="markdownIt-Anchor" href="#解析websocket协议"></a> 解析websocket协议</h3><p><strong>使用、创建demo：</strong></p><p>长连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> thread</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> _thread <span class="keyword">as</span> thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(ws, message)</span>:</span></span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_error</span><span class="params">(ws, error)</span>:</span></span><br><span class="line">    print(error)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(ws)</span>:</span></span><br><span class="line">    print(<span class="string">"### closed ###"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_open</span><span class="params">(ws)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(*args)</span>:</span></span><br><span class="line">        ws.send(<span class="string">"hello1"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        ws.close()</span><br><span class="line">    thread.start_new_thread(run,())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    websocket.enableTrace(<span class="keyword">True</span>)</span><br><span class="line">    ws = websocket.WebSocketApp(<span class="string">"ws://echo.websocket.org/"</span>,</span><br><span class="line">                              on_message = on_message,</span><br><span class="line">                              on_error = on_error,</span><br><span class="line">                              on_close = on_close)</span><br><span class="line">    ws.on_open = on_open</span><br><span class="line">    ws.run_forever(ping_interval=<span class="number">60</span>,ping_timeout=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>▲ Python的websocket代码是仿js websocket写法的，重新写了一遍脚本，流畅接受消息，自动重连发送指令，连接时间明显减少，基本做到无遗漏数据，与网站js的ws连接实现一样。</p><p>短链接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> websocket <span class="keyword">import</span> create_connection</span><br><span class="line">ws = create_connection(<span class="string">"ws://echo.websocket.org/"</span>)</span><br><span class="line">print(<span class="string">"Sending 'Hello, World'..."</span>)</span><br><span class="line">ws.send(json.dumps(&#123;<span class="string">"op"</span>:<span class="string">"unconfirmed_sub"</span>&#125;)) <span class="comment"># 不能使用str()，要以json格式输出</span></span><br><span class="line">ws.send(<span class="string">"Hello, World"</span>)</span><br><span class="line">print(<span class="string">"Sent"</span>)</span><br><span class="line">print(<span class="string">"Receiving..."</span>)</span><br><span class="line">result =  ws.recv()</span><br><span class="line">print(<span class="string">"Received '%s'"</span> % result)</span><br><span class="line">ws.close()</span><br></pre></td></tr></table></figure><h4 id="一步一步分析请求过程"><a class="markdownIt-Anchor" href="#一步一步分析请求过程"></a> 一步一步分析请求过程！！</h4><blockquote><ul><li><p>服务端（socket服务端）<br>*1.服务端开启socket服务监听IP和端口<br>*3.允许连接<br>*5.服务端接收到特殊值【加密sha1，特殊值，migic string=“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”】<br>*6.加密后的值发送给客户端</p></li><li><p>客户端（浏览器）</p></li></ul><p>*2.客户端发起连接请求（IP和端口）<br>*4.客户端生成一个xxx，【加密sha1，特殊值，migic string=“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”】，向服务端发送一段特殊值<br>*7.客户端接收到加密的值</p></blockquote><h5 id="1-启动服务端"><a class="markdownIt-Anchor" href="#1-启动服务端"></a> 1. 启动服务端</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8002</span>))</span><br><span class="line">sock.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 等待用户连接</span></span><br><span class="line">conn, address = sock.accept()</span><br></pre></td></tr></table></figure><h5 id="2-客户端连接"><a class="markdownIt-Anchor" href="#2-客户端连接"></a> 2. 客户端连接</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8002/xxoo"</span>);</span></span><br><span class="line"><span class="undefined">    ...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3-建立连接握手"><a class="markdownIt-Anchor" href="#3-建立连接握手"></a> 3. 建立连接【握手】</h5><h6 id="获取请求信息"><a class="markdownIt-Anchor" href="#获取请求信息"></a> 获取请求信息</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"> </span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8002</span>))</span><br><span class="line">sock.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 获取客户端socket对象</span></span><br><span class="line">conn, address = sock.accept()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取客户端的【握手】信息</span></span><br><span class="line">data = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">b'''</span></span><br><span class="line"><span class="string">GET /chatsocket HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 127.0.0.1:8002</span></span><br><span class="line"><span class="string">Connection: Upgrade</span></span><br><span class="line"><span class="string">Pragma: no-cache</span></span><br><span class="line"><span class="string">Cache-Control: no-cache</span></span><br><span class="line"><span class="string">Upgrade: websocket</span></span><br><span class="line"><span class="string">Origin: http://localhost:63342</span></span><br><span class="line"><span class="string">Sec-WebSocket-Version: 13</span></span><br><span class="line"><span class="string">Sec-WebSocket-Key: mnwFxiOlctXFN/DeMt1Amg==</span></span><br><span class="line"><span class="string">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>请求和响应的【握手】信息需要遵循规则：</p><ul><li>从请求【握手】信息中提取 Sec-WebSocket-Key</li><li>利用magic_string 和 Sec-WebSocket-Key 进行hmac1加密，再进行base64加密</li><li>将加密结果响应给客户端</li></ul><p><em>注：magic string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11</em></p><h6 id="提取sec-websocket-key值并加密"><a class="markdownIt-Anchor" href="#提取sec-websocket-key值并加密"></a> 提取Sec-WebSocket-Key值并加密：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_headers</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将请求头格式化成字典</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    header_dict = &#123;&#125;</span><br><span class="line">    data = str(data, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data.split(<span class="string">'\r\n'</span>):</span><br><span class="line">        print(i)</span><br><span class="line">    header, body = data.split(<span class="string">'\r\n\r\n'</span>, <span class="number">1</span>)</span><br><span class="line">    header_list = header.split(<span class="string">'\r\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(header_list)):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> len(header_list[i].split(<span class="string">' '</span>)) == <span class="number">3</span>:</span><br><span class="line">                header_dict[<span class="string">'method'</span>], header_dict[<span class="string">'url'</span>], header_dict[<span class="string">'protocol'</span>] = header_list[i].split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k, v = header_list[i].split(<span class="string">':'</span>, <span class="number">1</span>)</span><br><span class="line">            header_dict[k] = v.strip()</span><br><span class="line">    <span class="keyword">return</span> header_dict</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8002</span>))</span><br><span class="line">sock.listen(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">conn, address = sock.accept()</span><br><span class="line">data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">headers = get_headers(data) <span class="comment"># 提取请求头信息</span></span><br><span class="line"><span class="comment"># 对请求头中的sec-websocket-key进行加密</span></span><br><span class="line">response_tpl = <span class="string">"HTTP/1.1 101 Switching Protocols\r\n"</span> \</span><br><span class="line">      <span class="string">"Upgrade:websocket\r\n"</span> \</span><br><span class="line">      <span class="string">"Connection: Upgrade\r\n"</span> \</span><br><span class="line">      <span class="string">"Sec-WebSocket-Accept: %s\r\n"</span> \</span><br><span class="line">      <span class="string">"WebSocket-Location: ws://%s%s\r\n\r\n"</span></span><br><span class="line">magic_string = <span class="string">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span></span><br><span class="line">value = headers[<span class="string">'Sec-WebSocket-Key'</span>] + magic_string</span><br><span class="line">ac = base64.b64encode(hashlib.sha1(value.encode(<span class="string">'utf-8'</span>)).digest())</span><br><span class="line">response_str = response_tpl % (ac.decode(<span class="string">'utf-8'</span>), headers[<span class="string">'Host'</span>], headers[<span class="string">'url'</span>])</span><br><span class="line"><span class="comment"># 响应【握手】信息</span></span><br><span class="line">conn.send(bytes(response_str, encoding=<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>只有在服务端又发回&quot;响应&quot;的握手信息后，才算建立了链接。握手的作用是<strong>保证通信双方使用的协议相同</strong></p><h5 id="4客户端和服务端收发数据"><a class="markdownIt-Anchor" href="#4客户端和服务端收发数据"></a> 4.客户端和服务端收发数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">数据报内容，第一行为字节，第二行为相应的每一位。</span><br><span class="line">0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>官网给出的解析规则</p><blockquote><p>The MASK bit simply tells whether the message is encoded. Messages from the client must be masked, so your server should expect this to be 1. (In fact, <a href="http://tools.ietf.org/html/rfc6455#section-5.1" target="_blank" rel="noopener">section 5.1 of the spec</a> says that your server must disconnect from a client if that client sends an unmasked message.) When sending a frame back to the client, do not mask it and do not set the mask bit. We’ll explain masking later. *Note: You have to mask messages even when using a secure socket.*RSV1-3 can be ignored, they are for extensions.</p><p>The opcode field defines how to interpret the payload data: 0x0 for continuation, <code>0x1</code> for text (which is always encoded in UTF-8), <code>0x2</code> for binary, and other so-called “control codes” that will be discussed later. In this version of WebSockets, <code>0x3</code> to <code>0x7</code> and <code>0xB</code> to <code>0xF</code> have no meaning.</p><p>The FIN bit tells whether this is the last message in a series. If it’s 0, then the server will keep listening for more parts of the message; otherwise, the server should consider the message delivered. More on this later.</p><p><strong>Decoding Payload Length</strong></p><p>To read the payload data, you must know when to stop reading. That’s why the payload length is important to know. Unfortunately, this is somewhat complicated. To read it, follow these steps:</p><ol><li>Read bits 9-15 (inclusive) and interpret that as an unsigned integer. If it’s 125 or less, then that’s the length; you’re <strong>done</strong>. If it’s 126, go to step 2. If it’s 127, go to step 3.</li><li>Read the next 16 bits and interpret those as an unsigned integer. You’re <strong>done</strong>.</li><li>Read the next 64 bits and interpret those as an unsigned integer (The most significant bit MUST be 0). You’re <strong>done</strong>.</li></ol><p><strong>Reading and Unmasking the Data</strong></p><p>If the MASK bit was set (and it should be, for client-to-server messages), read the next 4 octets (32 bits); this is the masking key. Once the payload length and masking key is decoded, you can go ahead and read that number of bytes from the socket. Let’s call the data <strong>ENCODED</strong>, and the key <strong>MASK</strong>. To get <strong>DECODED</strong>, loop through the octets (bytes a.k.a. characters for text data) of <strong>ENCODED</strong> and XOR the octet with the (i modulo 4)th octet of MASK. In pseudo-code (that happens to be valid JavaScript):</p><p>var DECODED = “”;<br>for (var i = 0; i &lt; ENCODED.length; i++) {<br>DECODED[i] = ENCODED[i] ^ MASK[i % 4];<br>}</p><p>Now you can figure out what <strong>DECODED</strong> means depending on your application.</p></blockquote><h6 id="获取客户端发送的数据解包"><a class="markdownIt-Anchor" href="#获取客户端发送的数据解包"></a> 获取客户端发送的数据【解包】</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_info</span><span class="params">(info)</span>:</span></span><br><span class="line">    <span class="comment"># 处理数据头</span></span><br><span class="line">    <span class="comment"># mask占4个字节，在确定数据头的首部需要占多少字节后，再向后推4个字节</span></span><br><span class="line">    <span class="comment"># mask之后的就是数据的真正内容，但需要根据规则进行解析</span></span><br><span class="line">    payload_len = info[<span class="number">1</span>] &amp; <span class="number">127</span></span><br><span class="line">    <span class="keyword">if</span> payload_len == <span class="number">126</span>:</span><br><span class="line">        <span class="comment"># payload_len==126首部信息还要拓展2个字节(16 bits)</span></span><br><span class="line">        <span class="comment"># 见上文的 Decoding Payload Length-2</span></span><br><span class="line">        extend_payload_len = info[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">        mask = info[<span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line">        decoded = info[<span class="number">8</span>:]</span><br><span class="line">    <span class="keyword">elif</span> payload_len == <span class="number">127</span>:</span><br><span class="line">        <span class="comment"># payload_len==127那么需要再拓展8个字节(64 bits)</span></span><br><span class="line">        <span class="comment"># 见上文的 Decoding Payload Length-3</span></span><br><span class="line">        extend_payload_len = info[<span class="number">2</span>:<span class="number">10</span>]</span><br><span class="line">        mask = info[<span class="number">10</span>:<span class="number">14</span>]</span><br><span class="line">        decoded = info[<span class="number">14</span>:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        extend_payload_len = <span class="keyword">None</span></span><br><span class="line">        mask = info[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">        decoded = info[<span class="number">6</span>:]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">var DECODED = "";</span></span><br><span class="line"><span class="string">    for (var i = 0; i &lt; ENCODED.length; i++) &#123;</span></span><br><span class="line"><span class="string">        DECODED[i] = ENCODED[i] ^ MASK[i % 4];</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">    bytes_list = bytearray()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(decoded)):</span><br><span class="line">        chunk = decoded[i] ^ mask[i % <span class="number">4</span>]</span><br><span class="line">        bytes_list.append(chunk)</span><br><span class="line">    content = str(bytes_list, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br></pre></td></tr></table></figure><h6 id="向客户端发送数据封包"><a class="markdownIt-Anchor" href="#向客户端发送数据封包"></a> 向客户端发送数据【封包】</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(conn, msg_bytes)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    WebSocket服务端向客户端发送消息</span></span><br><span class="line"><span class="string">    :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept()</span></span><br><span class="line"><span class="string">    :param msg_bytes: 向客户端发送的字节</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">import</span> struct</span><br><span class="line"> </span><br><span class="line">    token = <span class="string">b"\x81"</span></span><br><span class="line">    length = len(msg_bytes)</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">126</span>:</span><br><span class="line">        token += struct.pack(<span class="string">"B"</span>, length)</span><br><span class="line">    <span class="keyword">elif</span> length &lt;= <span class="number">0xFFFF</span>:</span><br><span class="line">        token += struct.pack(<span class="string">"!BH"</span>, <span class="number">126</span>, length)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        token += struct.pack(<span class="string">"!BQ"</span>, <span class="number">127</span>, length)</span><br><span class="line"> </span><br><span class="line">    msg = token + msg_bytes</span><br><span class="line">    conn.send(msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>转自<a href="https://home.cnblogs.com/u/wupeiqi/" target="_blank" rel="noopener">武沛齐</a>的<a href="https://www.cnblogs.com/wupeiqi/p/6558766.html" target="_blank" rel="noopener">你真的了解WebSocket吗？</a></p><h4 id="完整demo"><a class="markdownIt-Anchor" href="#完整demo"></a> 完整DEMO：</h4><h5 id="python服务端代码"><a class="markdownIt-Anchor" href="#python服务端代码"></a> Python服务端代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_headers</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将请求头格式化成字典</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    header_dict = &#123;&#125;</span><br><span class="line">    data = str(data, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"> </span><br><span class="line">    header, body = data.split(<span class="string">'\r\n\r\n'</span>, <span class="number">1</span>)</span><br><span class="line">    header_list = header.split(<span class="string">'\r\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(header_list)):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> len(header_list[i].split(<span class="string">' '</span>)) == <span class="number">3</span>:</span><br><span class="line">                header_dict[<span class="string">'method'</span>], header_dict[<span class="string">'url'</span>], header_dict[<span class="string">'protocol'</span>] = header_list[i].split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k, v = header_list[i].split(<span class="string">':'</span>, <span class="number">1</span>)</span><br><span class="line">            header_dict[k] = v.strip()</span><br><span class="line">    <span class="keyword">return</span> header_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(conn, msg_bytes)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    WebSocket服务端向客户端发送消息</span></span><br><span class="line"><span class="string">    :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept()</span></span><br><span class="line"><span class="string">    :param msg_bytes: 向客户端发送的字节</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">import</span> struct</span><br><span class="line"> </span><br><span class="line">    token = <span class="string">b"\x81"</span></span><br><span class="line">    length = len(msg_bytes)</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">126</span>:</span><br><span class="line">        token += struct.pack(<span class="string">"B"</span>, length)</span><br><span class="line">    <span class="keyword">elif</span> length &lt;= <span class="number">0xFFFF</span>:</span><br><span class="line">        token += struct.pack(<span class="string">"!BH"</span>, <span class="number">126</span>, length)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        token += struct.pack(<span class="string">"!BQ"</span>, <span class="number">127</span>, length)</span><br><span class="line"> </span><br><span class="line">    msg = token + msg_bytes</span><br><span class="line">    conn.send(msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_socket</span><span class="params">()</span>:</span></span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8003</span>))</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">    conn, address = sock.accept()</span><br><span class="line">    data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    headers = get_headers(data)</span><br><span class="line">    response_tpl = <span class="string">"HTTP/1.1 101 Switching Protocols\r\n"</span> \</span><br><span class="line">                   <span class="string">"Upgrade:websocket\r\n"</span> \</span><br><span class="line">                   <span class="string">"Connection:Upgrade\r\n"</span> \</span><br><span class="line">                   <span class="string">"Sec-WebSocket-Accept:%s\r\n"</span> \</span><br><span class="line">                   <span class="string">"WebSocket-Location:ws://%s%s\r\n\r\n"</span></span><br><span class="line"> </span><br><span class="line">    value = headers[<span class="string">'Sec-WebSocket-Key'</span>] + <span class="string">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span></span><br><span class="line">    ac = base64.b64encode(hashlib.sha1(value.encode(<span class="string">'utf-8'</span>)).digest())</span><br><span class="line">    response_str = response_tpl % (ac.decode(<span class="string">'utf-8'</span>), headers[<span class="string">'Host'</span>], headers[<span class="string">'url'</span>])</span><br><span class="line">    conn.send(bytes(response_str, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">return</span> conn, sock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_info</span><span class="params">(info)</span>:</span></span><br><span class="line">    payload_len = info[<span class="number">1</span>] &amp; <span class="number">127</span></span><br><span class="line">    <span class="keyword">if</span> payload_len == <span class="number">126</span>:</span><br><span class="line">        extend_payload_len = info[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">        mask = info[<span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line">        decoded = info[<span class="number">8</span>:]</span><br><span class="line">    <span class="keyword">elif</span> payload_len == <span class="number">127</span>:</span><br><span class="line">        extend_payload_len = info[<span class="number">2</span>:<span class="number">10</span>]</span><br><span class="line">        mask = info[<span class="number">10</span>:<span class="number">14</span>]</span><br><span class="line">        decoded = info[<span class="number">14</span>:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        extend_payload_len = <span class="keyword">None</span></span><br><span class="line">        mask = info[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">        decoded = info[<span class="number">6</span>:]</span><br><span class="line"></span><br><span class="line">    bytes_list = bytearray()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(decoded)):</span><br><span class="line">        chunk = decoded[i] ^ mask[i % <span class="number">4</span>]</span><br><span class="line">        bytes_list.append(chunk)</span><br><span class="line">    content = str(bytes_list, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    conn, sock = init_socket()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            info = conn.recv(<span class="number">8096</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            info = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> info:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        content = analyze_info(info)</span><br><span class="line">        send_msg(conn, content.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><h5 id="html的客户端代码"><a class="markdownIt-Anchor" href="#html的客户端代码"></a> html的客户端代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"txt"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">value</span>=<span class="string">"提交"</span> <span class="attr">onclick</span>=<span class="string">"sendMsg();"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"close"</span> <span class="attr">value</span>=<span class="string">"关闭连接"</span> <span class="attr">onclick</span>=<span class="string">"closeConn();"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8003/chatsocket"</span>);</span></span><br><span class="line"><span class="undefined">         </span></span><br><span class="line"><span class="actionscript">            socket.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">/* 与服务器端连接成功后，自动执行 */</span></span></span><br><span class="line"><span class="undefined">         </span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> newTag = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span></span><br><span class="line"><span class="actionscript">                newTag.innerHTML = <span class="string">"【连接成功】"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).appendChild(newTag);</span></span><br><span class="line"><span class="undefined">            &#125;;</span></span><br><span class="line"><span class="undefined">         </span></span><br><span class="line"><span class="actionscript">            socket.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">/* 服务器端向客户端发送数据时，自动执行 */</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> response = event.data;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> newTag = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span></span><br><span class="line"><span class="undefined">                newTag.innerHTML = response;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).appendChild(newTag);</span></span><br><span class="line"><span class="undefined">            &#125;;</span></span><br><span class="line"><span class="undefined">         </span></span><br><span class="line"><span class="actionscript">            socket.onclose = <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">/* 服务器端主动断开连接时，自动执行 */</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> newTag = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span></span><br><span class="line"><span class="actionscript">                newTag.innerHTML = <span class="string">"【关闭连接】"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).appendChild(newTag);</span></span><br><span class="line"><span class="undefined">            &#125;;</span></span><br><span class="line"><span class="undefined">         </span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> txt = <span class="built_in">document</span>.getElementById(<span class="string">'txt'</span>);</span></span><br><span class="line"><span class="undefined">                socket.send(txt.value);</span></span><br><span class="line"><span class="actionscript">                txt.value = <span class="string">""</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">closeConn</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">                socket.close();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> newTag = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span></span><br><span class="line"><span class="actionscript">                newTag.innerHTML = <span class="string">"【关闭连接】"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).appendChild(newTag);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">         </span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="tornado初探"><a class="markdownIt-Anchor" href="#tornado初探"></a> tornado初探</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ws = websocket.WebSocketApp(<span class="string">"ws://echo.websocket.org/"</span>,</span><br><span class="line">    on_message = on_message,</span><br><span class="line">    on_error = on_error,</span><br><span class="line">    on_close = on_close)</span><br><span class="line">ws.on_open = on_open</span><br><span class="line">ws.run_forever()</span><br></pre></td></tr></table></figure><p><strong>长连接，参数介绍：</strong></p><p>（1）url: websocket的地址。</p><p>（2）header: 客户发送websocket握手请求的请求头，{‘head1:value1’,‘head2:value2’}。</p><p>（3）on_open：在建立Websocket握手时调用的可调用对象，这个方法只有一个参数，就是该类本身。</p><p>（4）on_message：这个对象在接收到服务器返回的消息时调用。有两个参数，一个是该类本身，一个是我们从服务器获取的字符串（utf-8格式）。</p><p>（5）on_error：这个对象在遇到错误时调用，有两个参数，第一个是该类本身，第二个是异常对象。</p><p>（6）on_close：在遇到连接关闭的情况时调用，参数只有一个，就是该类本身。</p><p>（7）on_cont_message：这个对象在接收到连续帧数据时被调用，有三个参数，分别是：类本身，从服务器接受的字符串（utf-8），连续标志。</p><p>（8）on_data：当从服务器接收到消息时被调用，有四个参数，分别是：该类本身，接收到的字符串（utf-8），数据类型，连续标志。</p><p>（9）keep_running：一个二进制的标志位，如果为True，这个app的主循环将持续运行，默认值为True。</p><p>（10）get_mask_key：用于产生一个掩码。</p><p>（11）subprotocols：一组可用的子协议，默认为空。</p><h4 id="tornadohello_world"><a class="markdownIt-Anchor" href="#tornadohello_world"></a> tornado.hello_world</h4><ul><li><strong>Http</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line">    <span class="comment"># 正常1，抛错1、5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_default_headers</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"调用了set_default_headers()"</span> </span><br><span class="line"><span class="comment"># 正常2，抛错2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"调用了initialize()"</span></span><br><span class="line"> <span class="comment"># 正常3，抛错3</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prepare</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"调用了prepare()"</span></span><br><span class="line"> <span class="comment"># 正常4，抛错4</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"调用了get()"</span></span><br><span class="line"> <span class="comment"># 正常4，抛错4</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"调用了post()"</span></span><br><span class="line">        self.send_error(<span class="number">200</span>)  <span class="comment"># 注意此出抛出了错误</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 正常无、抛错6</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_error</span><span class="params">(self, status_code, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"调用了write_error()"</span>    </span><br><span class="line">        </span><br><span class="line"> <span class="comment"># 正常5、抛错7</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_finish</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"调用了on_finish()"</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 定义Http处理类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="comment"># 处理路由参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self, subject)</span>:</span></span><br><span class="line">        self.subject = subject</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加一个处理get请求方式的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write方法是写到缓冲区的</span></span><br><span class="line">        self.write(<span class="string">"Hello, world"</span>)</span><br><span class="line">        <span class="comment"># write会自动检测json类型，进行包装，并设Content-Type设置为application/json; charset=UTF-8。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_app</span><span class="params">()</span>:</span></span><br><span class="line">    settings = &#123;</span><br><span class="line">        <span class="string">'template_path'</span>: <span class="string">'templates'</span>,</span><br><span class="line">        <span class="string">'static_path'</span>: <span class="string">'static'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tornado.web.Application([</span><br><span class="line">        (<span class="string">r"/main"</span>, MainHandler, &#123;<span class="string">"subject"</span>:<span class="string">"c++"</span>&#125;),<span class="comment"># 指定路由信息,路由参数会传入initialize()中</span></span><br><span class="line">        (<span class="string">r"/"</span>, IndexHandler),</span><br><span class="line">    ], debug=<span class="keyword">True</span>, **settings)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># debug=True时，有自动重启、提供追踪信息等功能</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = make_app()  <span class="comment"># 创建一个应用对象,得返回Application对象</span></span><br><span class="line">    app.listen(<span class="number">8888</span>)  <span class="comment"># 设置端口</span></span><br><span class="line">    tornado.ioloop.IOLoop.current().start()  <span class="comment"># 启动web程序，开始监听端口的连接</span></span><br></pre></td></tr></table></figure><ul><li><strong>Websocket</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ▲继承的类为WebSocketHandler</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatHandler</span><span class="params">(tornado.websocket.WebSocketHandler)</span>:</span></span><br><span class="line">    <span class="comment"># 用户存储当前聊天室用户</span></span><br><span class="line">    waiters = set()</span><br><span class="line">    <span class="comment"># 用于存储历时消息</span></span><br><span class="line">    messages = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        客户端连接成功时，自动执行</span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ChatHandler.waiters.add(self)</span><br><span class="line">        uid = str(uuid.uuid4())</span><br><span class="line">        self.write_message(uid)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> msg <span class="keyword">in</span> ChatHandler.messages:</span><br><span class="line">            content = self.render_string(<span class="string">'message.html'</span>, **msg)</span><br><span class="line">            self.write_message(content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(self, message)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        客户端连发送消息时，自动执行</span></span><br><span class="line"><span class="string">        :param message: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        msg = json.loads(message)</span><br><span class="line">        ChatHandler.messages.append(message)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> client <span class="keyword">in</span> ChatHandler.waiters:</span><br><span class="line">            content = client.render_string(<span class="string">'message.html'</span>, **msg)</span><br><span class="line">            client.write_message(content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        客户端关闭连接时，，自动执行</span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ChatHandler.waiters.remove(self)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    settings = &#123;</span><br><span class="line">        <span class="string">'template_path'</span>: <span class="string">'templates'</span>,</span><br><span class="line">        <span class="string">'static_path'</span>: <span class="string">'static'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    application = tornado.web.Application([</span><br><span class="line">        (<span class="string">r"/"</span>, IndexHandler),</span><br><span class="line">        (<span class="string">r"/chat"</span>, ChatHandler),</span><br><span class="line">    ], **settings)</span><br><span class="line">    application.listen(<span class="number">8888</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><h4 id="基于tornado聊天室"><a class="markdownIt-Anchor" href="#基于tornado聊天室"></a> <a href="https://www.cnblogs.com/ssyfj/p/9245150.html" target="_blank" rel="noopener">基于Tornado——聊天室</a></h4><p>项目结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">│   app.py</span><br><span class="line">│</span><br><span class="line">├───static</span><br><span class="line">│       jquery-2.1.4.min.js</span><br><span class="line">│</span><br><span class="line">└───templates</span><br><span class="line">        index.html</span><br><span class="line">        message.html</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.websocket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.render(<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatHandler</span><span class="params">(tornado.websocket.WebSocketHandler)</span>:</span></span><br><span class="line">    <span class="comment"># 用户存储当前聊天室用户</span></span><br><span class="line">    waiters = set()</span><br><span class="line">    <span class="comment"># 用于存储历时消息</span></span><br><span class="line">    messages = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        客户端连接成功时，自动执行</span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ChatHandler.waiters.add(self)</span><br><span class="line">        uid = str(uuid.uuid4())</span><br><span class="line">        self.write_message(uid)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> msg <span class="keyword">in</span> ChatHandler.messages:</span><br><span class="line">            content = self.render_string(<span class="string">'message.html'</span>, **msg)</span><br><span class="line">            self.write_message(content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(self, message)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        客户端连发送消息时，自动执行</span></span><br><span class="line"><span class="string">        :param message: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        msg = json.loads(message)</span><br><span class="line">        ChatHandler.messages.append(message)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向当前在线的每个用户发送最新的消息界面</span></span><br><span class="line">        <span class="keyword">for</span> client <span class="keyword">in</span> ChatHandler.waiters:</span><br><span class="line">            content = client.render_string(<span class="string">'message.html'</span>, **msg)</span><br><span class="line">            client.write_message(content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        客户端关闭连接时，，自动执行</span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ChatHandler.waiters.remove(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    settings = &#123;</span><br><span class="line">        <span class="string">'template_path'</span>: <span class="string">'templates'</span>,</span><br><span class="line">        <span class="string">'static_path'</span>: <span class="string">'static'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    application = tornado.web.Application([</span><br><span class="line">        (<span class="string">r"/"</span>, IndexHandler),</span><br><span class="line">        (<span class="string">r"/chat"</span>, ChatHandler),</span><br><span class="line">    ], **settings)</span><br><span class="line">    application.listen(<span class="number">8888</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Python聊天室<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"txt"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">value</span>=<span class="string">"提交"</span> <span class="attr">onclick</span>=<span class="string">"sendMsg();"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"close"</span> <span class="attr">value</span>=<span class="string">"关闭连接"</span> <span class="attr">onclick</span>=<span class="string">"closeConn();"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid #dddddd;margin: 20px;min-height: 500px;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/jquery-2.1.4.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            wsUpdater.start();</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> wsUpdater = &#123;</span></span><br><span class="line"><span class="actionscript">            socket: <span class="literal">null</span>,</span></span><br><span class="line"><span class="actionscript">            uid: <span class="literal">null</span>,</span></span><br><span class="line"><span class="actionscript">            start: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> url = <span class="string">"ws://127.0.0.1:8888/chat"</span>;</span></span><br><span class="line"><span class="actionscript">                wsUpdater.socket = <span class="keyword">new</span> WebSocket(url);</span></span><br><span class="line"><span class="actionscript">                wsUpdater.socket.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(event);</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">if</span>(wsUpdater.uid)&#123;</span></span><br><span class="line"><span class="undefined">                        wsUpdater.showMessage(event.data);</span></span><br><span class="line"><span class="actionscript">                    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="undefined">                        wsUpdater.uid = event.data;</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="actionscript">            showMessage: <span class="function"><span class="keyword">function</span><span class="params">(content)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                $(<span class="string">'#container'</span>).append(content);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 按下提交按钮后，客户端向服务端发送信息，服务端再将数据给message.html渲染</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> msg = &#123;</span></span><br><span class="line"><span class="undefined">                uid: wsUpdater.uid,</span></span><br><span class="line"><span class="javascript">                message: $(<span class="string">"#txt"</span>).val()</span></span><br><span class="line"><span class="undefined">            &#125;;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(msg));</span></span><br><span class="line"><span class="javascript">            wsUpdater.socket.send(<span class="built_in">JSON</span>.stringify(msg));</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>message.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"border: 1px solid #dddddd;margin: 10px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>游客&#123;&#123;uid&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-left: 20px;"</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>▲  整个执行流程：</p><ol><li>按下提交后调用html.sendMsg–&gt;</li><li>数据message–&gt;在后自动调用on_message，会将message传给massage.html渲染，将渲染结果(<strong>字符串</strong>)返回给用户(write_message)–&gt;</li><li>客户端收到消息后自动执行html.on_message会调用html.showMessage，把content即<strong>字符串</strong>(event.data)用jquery追加显示index.html页面上<code>$('#container').append(content);</code></li></ol><h2 id="附录文献"><a class="markdownIt-Anchor" href="#附录文献"></a> 附录文献:</h2><h3 id="websocket获取实时数据的几种常见链接方式"><a class="markdownIt-Anchor" href="#websocket获取实时数据的几种常见链接方式"></a> <a href="https://blog.csdn.net/Darkman_EX/article/details/82592118?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">websocket获取实时数据的几种常见链接方式</a></h3><h3 id="python使用websocket的几种方式"><a class="markdownIt-Anchor" href="#python使用websocket的几种方式"></a> <a href="https://jingniao.github.io/2016/04/10/python-websocket/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">python使用websocket的几种方式</a></h3><h3 id="python-web-框架tornado初探"><a class="markdownIt-Anchor" href="#python-web-框架tornado初探"></a> <a href="https://blog.csdn.net/xc_zhou/article/details/80637714" target="_blank" rel="noopener">Python Web 框架：Tornado初探</a></h3><h3 id="python学习笔记tornado深入"><a class="markdownIt-Anchor" href="#python学习笔记tornado深入"></a> <a href="https://blog.csdn.net/tichimi3375/article/details/82109679" target="_blank" rel="noopener">▲Python学习笔记——Tornado深入</a></h3><h3 id="完整的websocket使用聊天室"><a class="markdownIt-Anchor" href="#完整的websocket使用聊天室"></a> <a href="https://www.cnblogs.com/ssyfj/p/9245150.html" target="_blank" rel="noopener">完整的websocket使用——聊天室</a></h3><h2 id="坑点记录"><a class="markdownIt-Anchor" href="#坑点记录"></a> 坑点记录：</h2><h3 id="1create_connection导入失败"><a class="markdownIt-Anchor" href="#1create_connection导入失败"></a> 1.create_connection导入失败</h3><p>Q:<code>ImportError: cannot import name 'create_connection' from 'websocket' (unknown location)</code></p><ul><li>A:在使用create_connection之前要安装<code>websocket_client</code> ,即 <code>pip install websocket-client</code></li></ul><h3 id="个人的html客户端代码"><a class="markdownIt-Anchor" href="#个人的html客户端代码"></a> 个人的HTML客户端代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>2048客户端<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"↑"</span> <span class="attr">name</span>=<span class="string">"↑"</span> <span class="attr">onclick</span>=<span class="string">"up()"</span> <span class="attr">style</span>=<span class="string">"height:50px; width:50px;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"↓"</span> <span class="attr">name</span>=<span class="string">"↓"</span> <span class="attr">onclick</span>=<span class="string">"down()"</span> <span class="attr">style</span>=<span class="string">"height:50px; width:50px;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"←"</span> <span class="attr">name</span>=<span class="string">"←"</span> <span class="attr">onclick</span>=<span class="string">"left()"</span> <span class="attr">style</span>=<span class="string">"height:50px; width:50px;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"→"</span> <span class="attr">name</span>=<span class="string">"→"</span> <span class="attr">onclick</span>=<span class="string">"right()"</span> <span class="attr">style</span>=<span class="string">"height:50px; width:50px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.1.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            wsUpdater.start();</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> wsUpdater = &#123;</span></span><br><span class="line"><span class="actionscript">            socket: <span class="literal">null</span>,</span></span><br><span class="line"><span class="actionscript">            uid: <span class="literal">null</span>,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">            start: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> url = <span class="string">"ws://127.0.0.1:8888/game"</span>;</span></span><br><span class="line"><span class="actionscript">                wsUpdater.socket = <span class="keyword">new</span> WebSocket(url);</span></span><br><span class="line"><span class="actionscript">                wsUpdater.socket.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                &#125;;</span></span><br><span class="line"><span class="actionscript">                wsUpdater.socket.onopen = <span class="function"><span class="keyword">function</span> <span class="params">(ev)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//若是连接成功，onopen函数会执行</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(ev);</span></span><br><span class="line"><span class="actionscript">                    msg = <span class="string">'success'</span>;</span></span><br><span class="line"><span class="javascript">                    wsUpdater.socket.send(<span class="built_in">JSON</span>.stringify(msg));</span></span><br><span class="line"><span class="undefined">                &#125;;</span></span><br><span class="line"><span class="actionscript">                wsUpdater.socket.onclose = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"Client断开连接!"</span>);</span></span><br><span class="line"><span class="undefined">                &#125;;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">            wsUpdater.socket.send(0);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">down</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">            wsUpdater.socket.send(1);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">left</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">            wsUpdater.socket.send(2);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">right</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">            wsUpdater.socket.send(3);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="js客户端"><a class="markdownIt-Anchor" href="#js客户端"></a> js客户端</h3><p>先用<code>npm install ws</code>，再输入<code>node doit.js</code>运行代码</p><p>doit.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">var</span> wsUpdater = &#123;</span><br><span class="line">    socket: <span class="literal">null</span>,</span><br><span class="line">    uid: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    start: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> url = <span class="string">"ws://127.0.0.1:8888/game"</span>;</span><br><span class="line">        wsUpdater.socket = <span class="keyword">new</span> WebSocket(url);</span><br><span class="line">        wsUpdater.socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(ev);</span><br><span class="line">            game = <span class="built_in">JSON</span>.parse(ev.data);</span><br><span class="line">            <span class="built_in">console</span>.log(game);</span><br><span class="line">        &#125;;</span><br><span class="line">        wsUpdater.socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//若是连接成功，onopen函数会执行</span></span><br><span class="line">            <span class="built_in">console</span>.log(ev);</span><br><span class="line">            msg = <span class="string">'success'</span>;</span><br><span class="line">            wsUpdater.socket.send(<span class="built_in">JSON</span>.stringify(msg));</span><br><span class="line">        &#125;;</span><br><span class="line">        wsUpdater.socket.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Client断开连接!"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">wsUpdater.start();</span><br></pre></td></tr></table></figure><p>Python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> ws4py.client.threadedclient <span class="keyword">import</span> WebSocketClient</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> core <span class="keyword">import</span> Game</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span><span class="params">(WebSocketClient)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">opened</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># req = '&#123;"event":"subscribe", "channel":"eth_usdt.deep"&#125;'</span></span><br><span class="line">        <span class="comment"># self.send(req)</span></span><br><span class="line">        print(<span class="string">"连接成功"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closed</span><span class="params">(self, code, reason=None)</span>:</span></span><br><span class="line">        <span class="comment"># print("Closed down:", code, reason)</span></span><br><span class="line">        print(<span class="string">"连接中断"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">received_message</span><span class="params">(self, resp)</span>:</span></span><br><span class="line">        resp = json.loads(str(resp))</span><br><span class="line">        print(resp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># in_pipe, out_pipe = multiprocessing.Pipe(True)</span></span><br><span class="line">    ws = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ws = GamePlayer(<span class="string">'ws://127.0.0.1:23456/game'</span>)</span><br><span class="line">        ws.connect()</span><br><span class="line">        ws.run_forever()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        ws.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络知识websocket&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#网络知识websocket&quot;&gt;&lt;/a&gt; 网络知识——Websocket&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP ：面向连接—&amp;gt; 打电话(相互回复,一来一
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="网络知识" scheme="https://nymrli.top/tags/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>第二十八届“和巨耀通杯”南京邮电大学在线测评系统程序设计邀请赛--</title>
    <link href="https://nymrli.top/2019/11/17/%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E5%B1%8A%E2%80%9C%E5%92%8C%E5%B7%A8%E8%80%80%E9%80%9A%E6%9D%AF%E2%80%9DNOJ%E9%82%80%E8%AF%B7%E8%B5%9B/"/>
    <id>https://nymrli.top/2019/11/17/第二十八届“和巨耀通杯”NOJ邀请赛/</id>
    <published>2019-11-17T09:43:56.000Z</published>
    <updated>2019-11-17T09:58:12.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二十八届和巨耀通杯noj邀请赛"><a class="markdownIt-Anchor" href="#第二十八届和巨耀通杯noj邀请赛"></a> 第二十八届“和巨耀通杯”NOJ邀请赛</h1><blockquote><p>三人团队赛， 正好最近在刷PTA， 于是一个人报名尝试了一下。</p><p>一共AC了三题， Rank28</p></blockquote><h2 id="c-battle-game"><a class="markdownIt-Anchor" href="#c-battle-game"></a> <a href="https://acm.njupt.edu.cn/contest/109/board/challenge/C" target="_blank" rel="noopener">C. Battle game</a></h2><blockquote><p>签到题</p></blockquote><p><strong>Description:</strong></p><p>You are playing a game which you will battle with an enemy. As you don’t want to lose, your total power can’t be lower than your enemy’s. Your power is simply added by the power of your soldiers, and all of your soldiers’ power is exactly aa. Now you have known that your enemy’s total power is bb. You want to know how many soldiers you need in order not to lose the battle.</p><p><strong>Input:</strong></p><p>A line with two integers a,ba,b, (1≤a,b≤109)(1≤a,b≤109).</p><p><strong>Output:</strong></p><p>A line with one integer, denotes the minimum number of soldiers you need.</p><p><strong>Sample Input:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123 456</span><br></pre></td></tr></table></figure><p><strong>Sample Output:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a&gt;&gt; b)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( b%a != <span class="number">0</span>)</span><br><span class="line">            ans= b/a+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; b/a+1&lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans = b/a;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; b/a &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d-gomoku"><a class="markdownIt-Anchor" href="#d-gomoku"></a> <a href="https://acm.njupt.edu.cn/contest/109/board/challenge/D" target="_blank" rel="noopener">D. Gomoku</a></h2><p><strong>Description:</strong></p><p>Alice and Bob are playing a game called <em>Gomoku</em> (a.k.a. <em>Five in a Row</em>). Alice is sente(black, moves first) and Bob is gote(white, moves second). Alice wants to know whether she can win(have five or more consecutive stones of the same color in a diagonal, vertical, or horizontal row) in one step, and now is Alice’s turn. It is guranteed that neither Alice or Bob wins currently. Prohibitions are not considered in this problem.</p><p><strong>Input:</strong></p><p>The first line contains one integer nn, which denotes the size of the board is n×nn×n.</p><p>Next nn lines each has a string of length nn, use <code>@</code> to represent black, <code>O</code> to represent white, <code>+</code> to represent there’s no stone at that position.</p><p><strong>Output:</strong></p><p>If Alice can win in one step, output <code>YES</code>, otherwise output <code>NO</code>.</p><p><strong>Sample Input:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">+++O+++</span><br><span class="line">+@+@+++</span><br><span class="line">+O@@@++</span><br><span class="line">+++@+++</span><br><span class="line">+++O@++</span><br><span class="line">++OOOO+</span><br><span class="line">+++++++</span><br></pre></td></tr></table></figure><p><strong>Sample Output:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h3 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">+++O+++</span></span><br><span class="line"><span class="comment">+@+@+++</span></span><br><span class="line"><span class="comment">+O@@@++</span></span><br><span class="line"><span class="comment">+++@+++</span></span><br><span class="line"><span class="comment">+++O@++</span></span><br><span class="line"><span class="comment">++OOOO+</span></span><br><span class="line"><span class="comment">+++++++</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> maze[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> can=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dirnum = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// -&gt; , 2, &lt;- , 8,</span></span><br><span class="line"><span class="keyword">int</span> xdir[dirnum] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ydir[dirnum] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> depth, <span class="keyword">int</span> dir, <span class="keyword">int</span> plustime)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">5</span>)&#123;</span><br><span class="line">        can = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (plustime == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (maze[x][y] == <span class="string">'O'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!maze[x][y]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (can == <span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> xt = xdir[dir] + x;</span><br><span class="line">        <span class="keyword">int</span> yt = ydir[dir] + y;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; "      x:" &lt;&lt; xt &lt;&lt; " y:"&lt;&lt; yt &lt;&lt;  " " &lt;&lt;  maze[xt][yt] &lt;&lt; "plustime:"&lt;&lt; plustime&lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (maze[xt][yt] == <span class="string">'+'</span> &amp;&amp; plustime==<span class="number">0</span>)&#123;</span><br><span class="line">            maze[xt][yt] = <span class="string">'@'</span>;</span><br><span class="line">            dfs(xt, yt, depth+<span class="number">1</span>, dir, plustime+<span class="number">1</span>);</span><br><span class="line">            maze[xt][yt] = <span class="string">'+'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maze[xt][yt] == <span class="string">'@'</span> )&#123;</span><br><span class="line">            dfs(xt, yt, depth+<span class="number">1</span>, dir, plustime);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 5- 1e3</span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt;maze[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//        for(int j=1;j&lt;=n;j++)</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; maze[i][j];</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (maze[i][j]== <span class="string">'@'</span>)&#123;</span><br><span class="line"><span class="comment">//                cout &lt;&lt; "test" &lt;&lt; "x:" &lt;&lt; i &lt;&lt; " y:"&lt;&lt; j &lt;&lt; " "&lt;&lt;  maze[i][j]&lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;dirnum; k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> xt = xdir[k] + i;</span><br><span class="line">                    <span class="keyword">int</span> yt = ydir[k] + j;</span><br><span class="line">                    <span class="keyword">if</span> (maze[xt][yt]==<span class="string">'@'</span>)</span><br><span class="line"><span class="comment">//                    cout &lt;&lt; "  in " &lt;&lt; "x:" &lt;&lt; xt &lt;&lt; " y:"&lt;&lt; yt &lt;&lt; " "&lt;&lt;  maze[xt][yt]&lt;&lt; endl;</span></span><br><span class="line">                        dfs(xt, yt, <span class="number">2</span>, k, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (maze[xt][yt] == <span class="string">'+'</span>)</span><br><span class="line">                        dfs(xt, yt, <span class="number">2</span>, k, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            else cout &lt;&lt; "new" &lt;&lt; "x:" &lt;&lt; i &lt;&lt; " y:"&lt;&lt; j &lt;&lt; " "&lt;&lt;  maze[i][j]&lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (can) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="g-number"><a class="markdownIt-Anchor" href="#g-number"></a> <a href="https://acm.njupt.edu.cn/contest/109/board/challenge/G" target="_blank" rel="noopener">G. Number</a></h2><blockquote><p>规律题</p></blockquote><p><strong>Description:</strong></p><p>0xfaner just learned the factorial today, and the factorial is defined as follows:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo stretchy="false">!</mo><mo>=</mo><mn>1</mn><mo>×</mo><mn>2</mn><mo>×</mo><mo>⋯</mo><mo>×</mo><mi>x</mi><mi>x</mi><mo stretchy="false">!</mo><mo>=</mo><mn>1</mn><mo>×</mo><mn>2</mn><mo>×</mo><mo>⋯</mo><mo>×</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x!=1×2×⋯×xx!=1×2×⋯×x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">x</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></p><p>He found that $10!=362880010!=3628800 $， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn><mo stretchy="false">!</mo><mo>=</mo><mn>2432902008176640000</mn></mrow><annotation encoding="application/x-tex">20!=2432902008176640000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">3</span><span class="mord">2</span><span class="mord">9</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">8</span><span class="mord">1</span><span class="mord">7</span><span class="mord">6</span><span class="mord">6</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> , the number of trailing zeros is increasing.</p><p>Now 0xfaner wants to know the the number of trailing zeros of n!n!to each given nn .</p><p><strong>Input:</strong></p><p>The only line contains one integer nn ( 1≤n≤1091≤n≤109 ).</p><p><strong>Output:</strong></p><p>Print the number of trailing zeros of n!n! .</p><p><strong>Sample Input:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><p><strong>Sample Output:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>AC</p><blockquote><p>规律题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">BigInteger res =  <span class="keyword">new</span> BigInteger(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">BigInteger tmp =  <span class="keyword">new</span> BigInteger(String.valueOf(i));</span><br><span class="line">res = res.multiply(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//System.out.printf("%s\n",res.bitCount());</span></span><br><span class="line"><span class="comment">//System.out.printf("%s\n",res.bitLength());</span></span><br><span class="line"><span class="comment">//System.out.printf("%d\n",res.byteValue());</span></span><br><span class="line">String s = res.toString();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=s.length()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(j)==<span class="string">'0'</span>) ans ++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">System.out.printf(<span class="string">"%d"</span>,solve(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后一直TLE，于是猜测是否有规律</p><h3 id="ac代码-3"><a class="markdownIt-Anchor" href="#ac代码-3"></a> AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            ans += n/<span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第二十八届和巨耀通杯noj邀请赛&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第二十八届和巨耀通杯noj邀请赛&quot;&gt;&lt;/a&gt; 第二十八届“和巨耀通杯”NOJ邀请赛&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;三人团队赛， 正好最近在刷PT
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://nymrli.top/tags/ACM/"/>
    
      <category term="C++" scheme="https://nymrli.top/tags/C/"/>
    
      <category term="Algorithm" scheme="https://nymrli.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>PAT冲冲冲——甲级</title>
    <link href="https://nymrli.top/2019/10/24/PAT%E5%86%B2%E5%86%B2%E5%86%B2%E2%80%94%E2%80%94%E7%94%B2%E7%BA%A7/"/>
    <id>https://nymrli.top/2019/10/24/PAT冲冲冲——甲级/</id>
    <published>2019-10-24T10:30:45.000Z</published>
    <updated>2020-02-19T13:28:08.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pat冲冲冲甲级"><a class="markdownIt-Anchor" href="#pat冲冲冲甲级"></a> PAT冲冲冲——甲级</h1><blockquote><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/type/7?page=1" target="_blank" rel="noopener">PAT甲级练习题 ——PAT (Advanced Level) Practice </a><br><a href="https://www.nowcoder.com/pat/5/problems?page=1" target="_blank" rel="noopener">PAT甲级(Advanced Level)真题</a><br><a href="https://www.liuchuo.net/archives/8091" target="_blank" rel="noopener">柳婼 の blog经验</a><br><a href="https://saquarius.com/2019/08/pat%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">saquarius’s blog</a></p><p><a href="https://blog.csdn.net/a617976080/article/details/89676670" target="_blank" rel="noopener">PAT甲级题目及分类总结</a><br><a href="https://blog.csdn.net/richenyunqi/article/details/84981078" target="_blank" rel="noopener">pat甲级题解目录</a></p></blockquote><p>▲报名费256，可以刷<a href="https://www.nowcoder.com/pat" target="_blank" rel="noopener">牛客网</a>的题来获得-50的优惠券，该练习场下的所有题目只要通过都算</p><h2 id="甲级练习题"><a class="markdownIt-Anchor" href="#甲级练习题"></a> 甲级练习题</h2><blockquote><p>由于甲级题目较多，也较难，因此决定还是将两者分开写两篇文章了。</p></blockquote><h3 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805528788582400" target="_blank" rel="noopener">  <strong>1001</strong> <strong>A+B Format</strong> <strong>(20</strong> <strong>分</strong>**)** </a></h3><blockquote><p>看似很简单的一道题，但坑点确实不少，一遍过挺难的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll m, n;</span><br><span class="line">    <span class="comment">// 考虑到每次都是取后三位，所以需要用栈来逆序输出</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;ll&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;m,&amp;n) != EOF)&#123;</span><br><span class="line">        ll res_ans = m + n;</span><br><span class="line">        <span class="comment">// 这边0得特判</span></span><br><span class="line">        <span class="keyword">if</span> (res_ans==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res_ans&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> ;</span><br><span class="line">        ll ans = <span class="built_in">abs</span>(res_ans);</span><br><span class="line">        <span class="keyword">while</span>( ans )&#123;</span><br><span class="line">            ll three = ans%<span class="number">1000</span>;</span><br><span class="line">            s.push(three);</span><br><span class="line">            ans /= <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 逆序输出</span></span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            ll n = s.top();</span><br><span class="line">            s.pop();  </span><br><span class="line">            <span class="comment">// 首个三位不需要补零，其他的都需要补零</span></span><br><span class="line">            <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld"</span>, n);</span><br><span class="line">                first = !first;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%03lld"</span>, n);</span><br><span class="line">            <span class="keyword">if</span> (!s.empty()) <span class="built_in">printf</span>(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1002-ab-for-polynomials"><a class="markdownIt-Anchor" href="#1002-ab-for-polynomials"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000" target="_blank" rel="noopener">1002  A+B for Polynomials</a></h3><blockquote><p>模拟题，对我来说，又重新温习了遍Map的使用。</p><p>该题就一个坑点：系数为0的项不需要显示。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; mp;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">float</span> coef;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">exp</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %f"</span>, &amp;<span class="built_in">exp</span>, &amp;coef);</span><br><span class="line">        mp[<span class="built_in">exp</span>] = coef;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">        <span class="comment">// 两个临时变量</span></span><br><span class="line">        <span class="keyword">float</span> coef;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">exp</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %f"</span>, &amp;<span class="built_in">exp</span>, &amp;coef);</span><br><span class="line">        i = mp.find(<span class="built_in">exp</span>);</span><br><span class="line">        <span class="keyword">if</span> ( i != mp.end() )&#123;</span><br><span class="line">            <span class="keyword">float</span> sum = i-&gt;second + coef;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">abs</span>( sum - <span class="number">0</span>) &lt; <span class="number">1e-6</span> )&#123;</span><br><span class="line">                <span class="comment">// △坑点:如果系数为0,不显示</span></span><br><span class="line">                mp.erase(<span class="built_in">exp</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> mp[<span class="built_in">exp</span>] = sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           mp[<span class="built_in">exp</span>] = coef; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从小到大输出</span></span><br><span class="line">    <span class="comment">// for ( i = mp.begin(); i != mp.end(); ++i)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, mp.size());</span><br><span class="line">    <span class="comment">// 使用反向迭代器-&gt;从大到小输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt;::reverse_iterator i = mp.rbegin(); i != mp.rend(); ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d %.1f"</span>, i-&gt;first, i-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1003-emergency"><a class="markdownIt-Anchor" href="#1003-emergency"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener"> 1003  Emergency</a></h3><p>作为一个城市紧急援救队的指挥者，你得到了一个国家的特殊地图。地图上分散着几座城市，城市间用道路连接着。每个城市援救队的数量以及两座城市之间每条道路的长度已经在地图上标出。当某些城市发生了突发事件，需要你的帮助时，你的工作是带领你的队伍尽快的赶到事发现场，与此同时，召集尽可能多的在路上的队伍。</p><p><strong>输入</strong></p><p>每个输入文件包含一个测试实例。每个实例的第一行有四个正整数：N(&lt;= 500)是城市的个数（城市的编号从0到N-1），M是道路的个数，C1和C2分别是你现在所在的城市以及你必须去救援的城市。下一行有N个整数，第i个整数是第i个城市中救援队的数量。然后下面有M行，每行表示一条道路。每一行有三个整数c1,c2和L，分别表示道路连接的两个城市以及道路的长度。保证C1到C2之间存在至少一条路径。</p><p><strong>输出</strong></p><p>对于每个测试实例，在一行中输出两个数字：C1和C2之间不同的最短路径的个数，你能聚集起来的最多的救援队数量。</p><p>一行中的所有数字必须被一个空格分隔开，在每行的结尾不允许出现空格。</p><blockquote><p>思路：本题是求起点到目标点的最短路径的数目，以及所有最短路径中点权的最大值，可用dijkstra算法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, d;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*关于起点为s的路径的变量(记录的都是以 起点s 为中心的量)：</span></span><br><span class="line"><span class="comment">pathl(path_length缩写)存储从起点到所有点的最短路径的边权(本例为起点城市到所有城市的最短路径的距离) ————最短路</span></span><br><span class="line"><span class="comment">maxv(max_hands缩写)存储从起点到其他点的全部最短路径中的点权最大值(本例为起点城市到其他城市的所有最短路径中 </span></span><br><span class="line"><span class="comment">    即人手最多的那条路径的人手数)  ———— 最短路中能获得最大权值的节点权值e.g.maxv[3]即s-&gt;3能获得的最大权值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">▲核心思想是根据路径最短来更新的,所以即使v' &lt; v, 但只要l' &lt; l,那么也会更新。即@77代码处</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pathc(path_count缩写)存储从起点到其他点的最短路径的数目； </span></span><br><span class="line"><span class="comment">△根据题意,额外需要维护的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> pathc[maxn];</span><br><span class="line"><span class="keyword">int</span> pathl[maxn];</span><br><span class="line"><span class="keyword">int</span> maxv[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图信息的变量 */</span></span><br><span class="line"><span class="comment">// e(edges):点间的边关系, 初始化默认为0</span></span><br><span class="line"><span class="comment">// visited:判断v是否被访问过</span></span><br><span class="line"><span class="comment">// 存放节点v权值的量, node_value</span></span><br><span class="line"><span class="keyword">int</span> e[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> visited[maxn];</span><br><span class="line"><span class="keyword">int</span> value[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [dijkstra description]</span></span><br><span class="line"><span class="comment"> * dijkstra求最短路径的特点是探索当前节点-&gt;下个节点,边权值最小的将被当做下个节点</span></span><br><span class="line"><span class="comment"> * 最终可以找出节点s到所有节点的最短路径</span></span><br><span class="line"><span class="comment"> * 原理:根据初始点，挨个的把离初始点最近的点一个一个找到并加入集合,集合中所有的点的d[i]都是该点到初始点最短路径长度</span></span><br><span class="line"><span class="comment"> * @author mrli 2019-11-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这份dijkstra的思路为:</span></span><br><span class="line"><span class="comment">        第一次, for1先遍历选中一个节点v, 然后使用for2找到遍历, 找到与v路径最短的下一个节点v', then更新</span></span><br><span class="line"><span class="comment">        第二次, for1那么根据与下个节点路径最短的规则,还是会找到v', 因此minI=v', 然后再找v''</span></span><br><span class="line"><span class="comment">    第二种:</span></span><br><span class="line"><span class="comment">        先安排节点s, 设个while(1) 以外的节点, 保存当前节点v编号, 然后遍历,tmpv为需要更新的节点的编号</span></span><br><span class="line"><span class="comment">        区别在于 </span></span><br><span class="line"><span class="comment">        法一:当前的v未访问过,所以设置visited[v]=1,然后找下一个tmpv,在下次的while循环的时候再设置visited</span></span><br><span class="line"><span class="comment">        法二:当前的v已经是visited==1, 在找到tmpv后直接设置visited[tmpv]=1,</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    fill(pathl, pathl+ maxn, INF);</span><br><span class="line">    pathc[s] = <span class="number">1</span>;</span><br><span class="line">    pathl[s] = <span class="number">0</span>;</span><br><span class="line">    maxv[s] = value[s];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/*找出本轮尚未确定最短路径的城市中，起点到剩余城市中，距离最小minl的那个城市minI。</span></span><br><span class="line"><span class="comment">        如果minl是无穷大，证明起点城市与剩余城市均不可达，即不连通；</span></span><br><span class="line"><span class="comment">        如果minI就是目标城市d，则表明已经确定起点城市到目标城市的最短路径，提前结束寻找。</span></span><br><span class="line"><span class="comment">        否则，将本轮能确定最短路径的城市minI设为已经处理好,v[minI]=1；</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> minl = INF, minI = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 以s节点为例, 先遍历边其他未访问过的节点,找到其中边权值最小的作为下一个访问节点</span></span><br><span class="line">        <span class="comment">// 首先第一个访问的肯定是s节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (pathl[i] &lt; minl)&#123;</span><br><span class="line">                minl = pathl[i];</span><br><span class="line">                minI = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终止条件:</span></span><br><span class="line">        <span class="comment">// 1.在 dijkstra 算法里, 如果节点已经判断到终点了, 那么到终点的最短路径就已经被计算出来了,此时可以结束</span></span><br><span class="line">        <span class="comment">// 2.当前循环全是Visited == 1的节点,所有节点都被遍历过了, 循环结束</span></span><br><span class="line">        <span class="keyword">if</span> (minI == d || minl== INF) <span class="keyword">break</span>;</span><br><span class="line">        visited[minI] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// minI节点-&gt;下个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 在未达、且可达的节点中考虑，否则continue</span></span><br><span class="line">            <span class="keyword">if</span>( visited[i] == <span class="number">1</span> || e[minI][i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 当节点minI的最短路径 + 当前minI-&gt;下一个节点的边权值</span></span><br><span class="line">            <span class="keyword">int</span> tmpl = pathl[minI] + e[minI][i];</span><br><span class="line">            <span class="keyword">int</span> tmpv = value[i] + maxv[minI];</span><br><span class="line">            <span class="comment">// 判断是否要更新, 如果当前路径l小于之前的话,那么更新</span></span><br><span class="line">            <span class="keyword">if</span>(tmpl &lt; pathl[i])&#123;</span><br><span class="line">                pathl[i] = tmpl;</span><br><span class="line">                maxv[i] = tmpv;</span><br><span class="line">                pathc[i] = pathc[minI];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果长度是相等的,那么最大化Value</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmpl == pathl[i])&#123;</span><br><span class="line">                pathc[i] += pathc[minI];</span><br><span class="line">                <span class="keyword">if</span> (tmpv &gt; maxv[i]) maxv[i] = tmpv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;s, &amp;d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v1, v2, l;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;v1, &amp;v2, &amp;l);</span><br><span class="line">        e[v1][v2] = l;</span><br><span class="line">        e[v2][v1] = l;</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="comment">// 最短的路径, 最大的权值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, pathc[d], maxv[d]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/yeziand01/article/details/80716688" target="_blank" rel="noopener">大佬的代码(带注释)</a></p><h3 id="1004-counting-leaves"><a class="markdownIt-Anchor" href="#1004-counting-leaves"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184" target="_blank" rel="noopener"> 1004 Counting Leaves</a></h3><p>一个家庭的层级结构经常被表现为一个家谱树。你的任务是统计这些家庭成员中谁没有孩子。</p><p><strong>输入</strong></p><p>每个输入文件包含一个测试实例。每个实例开始的一行包含N和M，N指树中的结点个数（0&lt;N&lt;100），M指非叶结点的个数。然后下面有M行，每行的格式如下：</p><p>ID K ID[1] ID[2] …ID[K]</p><p>ID是一个两位数的数字，表示一个非叶结点。K表示其孩子的数量。随后是一个序列，序列中是该结点的孩子结点的两位数ID。为了简单起见，我们把根结点的ID固定为01。</p><p><strong>输出</strong></p><p>对于每个测试实例，你应该计算从根结点开始的每一层中没有孩子的家庭成员的个数。数字必须在一行内输出，用空格分隔，在每行结尾不能有多余的空格。</p><p>测试样例表示了一个只有两个结点的树，01是根结点，02是它仅有的孩子。因此在根结点01层级，没有叶节点。再下一层级，有一个叶结点。然后我们应该在一行内输出“0 1”。</p><blockquote><p>节点带有孩子的信息用vector来模拟图中的邻接表写法，然后用BFS来实现遍历</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似邻接表的写法记录节点</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[MAXN];</span><br><span class="line"><span class="comment">// 用来记录每一层的叶子节点数</span></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="comment">// 来计算层数</span></span><br><span class="line"><span class="comment">// level记录当前节点p的所在层数</span></span><br><span class="line"><span class="keyword">int</span> level[MAXN];</span><br><span class="line"><span class="comment">// maxlevel记录深度0-N</span></span><br><span class="line"><span class="keyword">int</span> maxlevel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 设置起点，root==01节点</span></span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> p = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 自己是个叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(v[p].size() == <span class="number">0</span>)&#123;</span><br><span class="line">            cnt[level[p]] ++;</span><br><span class="line">            maxlevel = max(level[p], maxlevel);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果当前节点p不是叶子节点， 则继续向其叶子节点扩展</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[p].size() ; ++i)&#123;</span><br><span class="line">                q.push(v[p][i]);</span><br><span class="line">                <span class="comment">// p节点的叶子节点的层数为p节点层数+1</span></span><br><span class="line">                level[v[p][i]] = level[p] + <span class="number">1</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="keyword">int</span> parent, num;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; parent &gt;&gt; num;</span><br><span class="line">        <span class="comment">// 类似邻接表， parent记录了其孩子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">            v[parent].emplace_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="comment">// 0为第一层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxlevel; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; cnt[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; cnt[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1005-spell-it-right"><a class="markdownIt-Anchor" href="#1005-spell-it-right"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805519074574336" target="_blank" rel="noopener">1005 Spell It Right</a></h3><blockquote><p>感觉突然来了一道放水题，就纯模拟</p><p>坑点：全0的时候特判为zero</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100 + 5</span></span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="built_in">string</span> num[<span class="number">10</span>] = &#123;<span class="string">"zero"</span> ,<span class="string">"one"</span> ,<span class="string">"two"</span> ,<span class="string">"three"</span>, <span class="string">"four"</span> ,<span class="string">"five"</span>, <span class="string">"six"</span>, <span class="string">"seven"</span>, <span class="string">"eight"</span>, <span class="string">"nine"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( ch != <span class="string">'\n'</span> )&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = ch - <span class="string">'0'</span>;</span><br><span class="line">        sum += tmp;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 坑点,需要特判0</span></span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"zero\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(sum)&#123;</span><br><span class="line">            <span class="keyword">int</span> ge = sum %<span class="number">10</span>;</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            s.push(ge);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span> (first)  &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, num[ans].c_str());</span><br><span class="line">                first = !first;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %s"</span>, num[ans].c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>▲小结一下: 每次用while来取位的时候，必须先判断while(xxx)中的xxx是否初始就为0</p><h3 id="1006-sign-in-and-sign-out-25-分"><a class="markdownIt-Anchor" href="#1006-sign-in-and-sign-out-25-分"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805516654460928" target="_blank" rel="noopener">1006 Sign In and Sign Out (25 分)</a></h3><blockquote><p>更加简单的模拟题，由于string的比较特性可以直接用来比较时间，所以处理很方便</p><p>△学会使用algorithm里的sort能省很多时间</p><p>▲比较运算符&lt;重载、或是编写外部比较函数，都会按照return里为true的逻辑排序,<a href="http://xn--first-gv5i.xxx" target="_blank" rel="noopener">如first.xxx</a> &lt; second.xxx那么就是从小到大</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">record</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> id;</span><br><span class="line">    <span class="built_in">string</span> intime;</span><br><span class="line">    <span class="built_in">string</span> outtime;</span><br><span class="line">&#125;<span class="keyword">typedef</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照进入的时间排序, 从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpin</span><span class="params">(<span class="keyword">const</span> rc&amp; f, <span class="keyword">const</span> rc&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.intime &lt; s.intime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照出去的时间排序, 从大到小</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpout</span><span class="params">(<span class="keyword">const</span> rc&amp; f, <span class="keyword">const</span> rc&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.outtime &gt; s.outtime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;rc&gt; v;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;rc&gt;::iterator it;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        rc* p = <span class="keyword">new</span> rc();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p-&gt;id &gt;&gt; p-&gt;intime &gt;&gt; p-&gt;outtime;</span><br><span class="line">        v.emplace_back(*p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(v.begin(), v.end(), cmpin);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.begin()-&gt;id &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    sort(v.begin(), v.end(), cmpout);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.begin()-&gt;id &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// for(it = v.begin(); it!= v.end(); it++)&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; it-&gt;id &lt;&lt; " "&lt;&lt;  it-&gt;intime &lt;&lt;" "&lt;&lt; it-&gt;outtime &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/erd8888/article/details/88795843" target="_blank" rel="noopener">C++中sort的比较函数写法</a></p><p>注意：比较函数必须写在类外部（全局区域）或声明为静态函数</p><h3 id="1007-maximum-subsequence-sum"><a class="markdownIt-Anchor" href="#1007-maximum-subsequence-sum"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168" target="_blank" rel="noopener"> 1007  Maximum Subsequence Sum</a></h3><blockquote><p>Dp, 最大公共子串</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1008-elevator"><a class="markdownIt-Anchor" href="#1008-elevator"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805511923286016" target="_blank" rel="noopener"> 1008  Elevator</a></h3><blockquote><p>模拟</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> order[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="comment">// 所有用时</span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 上一个位置</span></span><br><span class="line">    <span class="keyword">int</span> ptr=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; order[i];        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> res = order[i] - ptr;</span><br><span class="line">        ptr = order[i];</span><br><span class="line">        <span class="keyword">if</span>(res&gt;<span class="number">0</span>) t+= <span class="number">6</span>*res + <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span> t += <span class="number">4</span>*<span class="built_in">abs</span>(res) + <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1009-product-of-polynomials"><a class="markdownIt-Anchor" href="#1009-product-of-polynomials"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805509540921344" target="_blank" rel="noopener"> 1009  Product of Polynomials</a></h3><blockquote><p>模拟题</p></blockquote><h3 id="1010-radix"><a class="markdownIt-Anchor" href="#1010-radix"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536" target="_blank" rel="noopener"> 1010 Radix</a></h3><blockquote><p>模拟题</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> order[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N1, N2, tag, radix;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"Impossible"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1011-world-cup-betting"><a class="markdownIt-Anchor" href="#1011-world-cup-betting"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805504927186944" target="_blank" rel="noopener"> 1011  World Cup Betting</a></h3><blockquote><p>模拟题</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">games</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> one, two, three;</span><br><span class="line">&#125;<span class="keyword">typedef</span> Gm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">double</span> win=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">double</span> arr[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> maxi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>,&amp;arr[<span class="number">0</span>], &amp;arr[<span class="number">1</span>], &amp;arr[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[maxi])&#123;</span><br><span class="line">                maxi = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v.emplace_back(maxi);</span><br><span class="line">        win *= arr[maxi];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it= v.begin(); it!= v.end(); it++)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(*it)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"W "</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"T "</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"L "</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, (win*<span class="number">0.65</span> - <span class="number">1</span>)*<span class="number">2</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1012-the-best-rank"><a class="markdownIt-Anchor" href="#1012-the-best-rank"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480" target="_blank" rel="noopener"> 1012  The Best Rank</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">// c m e a</span></span><br><span class="line">    <span class="keyword">int</span> g[<span class="number">4</span>], r[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">4</span>] = &#123;<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>&#125;;</span><br><span class="line">&#125;<span class="keyword">typedef</span> stu;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;stu&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(stu &amp;f1 , stu &amp;f2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f1.g[num] &gt; f2.g[num];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRank</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">        sort(v.begin(), v.end(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            v.at(i).r[num] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxRank</span><span class="params">(<span class="keyword">const</span> stu *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> best_rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;r[i] &lt; s-&gt;r[best_rank]) best_rank = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s-&gt;r[best_rank] &lt;&lt; <span class="string">" "</span> &lt;&lt; s-&gt;c[best_rank] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt;M;</span><br><span class="line">    <span class="comment">// scanf("%d%d", &amp;N, &amp;M);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        stu *s = <span class="keyword">new</span> stu();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s-&gt;id &gt;&gt; s-&gt;g[<span class="number">1</span>] &gt;&gt; s-&gt;g[<span class="number">2</span>] &gt;&gt; s-&gt;g[<span class="number">3</span>]; </span><br><span class="line">        s-&gt;g[<span class="number">0</span>] = (s-&gt;g[<span class="number">1</span>] + s-&gt;g[<span class="number">2</span>]+ s-&gt;g[<span class="number">3</span>])/<span class="number">3</span>; </span><br><span class="line">        v.emplace_back(*s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getRank();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpid;</span><br><span class="line">        <span class="keyword">bool</span> find=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmpid;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> ( v.at(i).id == tmpid) &#123;</span><br><span class="line">                maxRank(&amp;v.at(i));</span><br><span class="line">                find=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!find) <span class="built_in">cout</span> &lt;&lt; <span class="string">"N/A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1013-battle-over-cities"><a class="markdownIt-Anchor" href="#1013-battle-over-cities"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840" target="_blank" rel="noopener"> 1013  Battle Over Cities</a></h3><p>In:给出n个城市，城市间有m条路，k个要检查的城市</p><p>Out:假如被检查的城市ki被攻占，则所有与Ki相关的路线全部瘫痪，要使其他城市保持连通，至少需要修缮多少条路?即 <strong>删除图的一个节点，是其他节点成为连通图，至少需要添加多少条线</strong></p><p>解法一:<a href="https://blog.csdn.net/whl_program/article/details/77627856" target="_blank" rel="noopener">图的遍历:DFS计算连通分量数目</a>==&gt; 计算出连通分量数N。如果想要构成连通图，那么需要添加<strong>res=N-1</strong>条线，即最少需要N-1条线。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[SIZE][SIZE];</span><br><span class="line"><span class="keyword">bool</span> visit[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">// 顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到node下的所有连通节点,把其标记为true</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    visit[node] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( visit[i] == <span class="literal">false</span> &amp;&amp; p[node][i] == <span class="number">1</span>)&#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 边数和case数</span></span><br><span class="line">    <span class="keyword">int</span> m ,k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        p[u][v] = p[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case K</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="comment">// 每次都得重置visit 即所有城市未被遍历</span></span><br><span class="line">        fill(visit, visit+SIZE, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        visit[tmp] = <span class="literal">true</span>;<span class="comment">// 不让tmp进入考虑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (visit[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                dfs(j); </span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt<span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二:无向图的连通性，可以考虑<a href="https://blog.csdn.net/titi2018815/article/details/90313319" target="_blank" rel="noopener">并查集</a>==&gt; 但是需要注意最后结果的处理，并查集后可以知道现在的图分成了几块，但是有一块肯定是被占领的那一个城市，所以结果记得减去这一块，还有，两块地图联通只需要修建一条道路。综上所述，<strong>res=图的块数-2</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> f[N];   <span class="comment">//存储boss；用来计算有几个连通分量的</span></span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;a;<span class="comment">//存储城市之间的连接(边)；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> v)</span><span class="comment">//递归查找boss；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[v]==v)</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> f[v]=getf(f[v]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span><span class="comment">//合并；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1=getf(u);</span><br><span class="line">    <span class="keyword">int</span> t2=getf(v);</span><br><span class="line">    <span class="keyword">if</span>(t1!=t2)<span class="comment">//boss节点不同就合并；</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[t2]=t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=i;<span class="comment">//自己的boss是自己；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 图被分成了2部分:</span></span><br><span class="line"><span class="comment">// 1.与城市X相连的点(不会进行merge)、 X城市本身 (sum的两个组成部分)</span></span><br><span class="line"><span class="comment">// 2.与X不相连的(会进行merge)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// x为被占领的城市</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((a[i].first!=x) &amp;&amp; (a[i].second!=x))<span class="comment">//和城市x相连的路全部断掉；</span></span><br><span class="line">            merge(a[i].first,a[i].second);<span class="comment">//不是和城市x相连的就合并；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看整个图分成了几块；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]==i)</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  结果记得处理； </span></span><br><span class="line"><span class="comment">     *  n个节点,需要n-1条边才能构成连通分量;</span></span><br><span class="line"><span class="comment">     *  △还有节点x自己得去掉,这也是跟1的区别(会多数个本身);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> sum<span class="number">-2</span>;</span><br><span class="line">&#125;<span class="comment">//除去被占领的城市，两个城市之间只需要一条路连接；</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    a.resize(m);<span class="comment">//设置容器的大小；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> aa,bb;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;aa,&amp;bb);</span><br><span class="line">        <span class="comment">// a[i]=make_pair(aa,bb);</span></span><br><span class="line">        a.push_back(make_pair(aa,bb));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++)&#123;</span><br><span class="line">        <span class="comment">// c为被占领的城市</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> res= pan(c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1014-waiting-in-line"><a class="markdownIt-Anchor" href="#1014-waiting-in-line"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936" target="_blank" rel="noopener"> 1014  Waiting in Line</a></h3><blockquote><p>队列queue的模拟操作，分两部分解决，一部分是在黄线中的M*N个人，直接进行操作，另一部分黄线外的人需要一个个判断，哪个窗口目前是最少的，然后对该窗口进行更新</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">windows</span>&#123;</span></span><br><span class="line">    <span class="comment">// 前者为队首顾客出队时间：为了计算让黄线外的人可以计算出哪一个队列先空出人来</span></span><br><span class="line">    <span class="comment">// 后者为队尾顾客出队时间：为了计算入队后加上自己本身的taketime可以计算出自己何时才能被服务完毕</span></span><br><span class="line">    <span class="comment">//     以及得知自己是不是需要被Sorry(如果前一个人服务结束时间超过17:00，自己当前入队的人就是sorry)</span></span><br><span class="line">    <span class="keyword">int</span> start_pop_time, end_pop_time;</span><br><span class="line">    <span class="comment">// 该窗口排队的人</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;<span class="keyword">typedef</span> win;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// n个窗口， m个黄线内顾客， 总共k个顾客， 求解q个询问</span></span><br><span class="line">    <span class="keyword">int</span> n, m, k, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;k, &amp;q);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; taketime(k+<span class="number">1</span>);           <span class="comment">// 每个cos需要的处理时间</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; quiz(k+<span class="number">1</span>);               <span class="comment">// 测验</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; sorry(k+<span class="number">1</span>, <span class="literal">false</span>);      <span class="comment">// 是否能被服务</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;win&gt; window(n+<span class="number">1</span>);             <span class="comment">// 窗口</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;taketime[i]);</span><br><span class="line">    <span class="comment">// 解答</span></span><br><span class="line">    <span class="comment">// 指针，当前新被处理的人， 从1号顾客开始</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果总人数正好在m*n范围内</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt;= k)&#123;</span><br><span class="line">                window[j].q.push(taketime[index]);</span><br><span class="line">                <span class="comment">// 如果该窗口处理当前黄线内排队的人已经有大于540的了，那么新加入的必sorry</span></span><br><span class="line">                <span class="keyword">if</span> (window[j].end_pop_time&gt;=(<span class="number">17</span><span class="number">-8</span>)*<span class="number">60</span>) sorry[index] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 当前窗口的结束时间更新规则为： 已有的结束时间 + 当前顾客index的服务时间</span></span><br><span class="line">                window[j].end_pop_time += taketime[index];</span><br><span class="line">                <span class="comment">// 第一个pop的时间需要特殊处理一下</span></span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">1</span>) window[j].start_pop_time = window[j].end_pop_time;</span><br><span class="line">                <span class="comment">// 在这种情况下， 顾客的结束时间就是该窗口的end_time</span></span><br><span class="line">                quiz[index] = window[j].end_pop_time;</span><br><span class="line">                <span class="comment">// 处理下一个顾客</span></span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果k&gt;m*n，那么在这边处理 剩下的index~k位顾客，此时需要不断更新window安排顾客进栈</span></span><br><span class="line">    <span class="keyword">while</span>( index &lt;= k)&#123;</span><br><span class="line">        <span class="keyword">int</span> min_time = window[<span class="number">1</span>].start_pop_time, min_win = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 黄线外顾客要找到一个对他来说最短的窗口， 编号小的优先</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> ( window[i].start_pop_time &lt;= min_time)&#123;</span><br><span class="line">                min_time = window[i].start_pop_time;</span><br><span class="line">                min_win = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最短窗口的队首顾客出队</span></span><br><span class="line">        window[min_win].q.pop();</span><br><span class="line">        <span class="comment">// 黄线外第一个顾客入队</span></span><br><span class="line">        window[min_win].q.push(taketime[index]);</span><br><span class="line">        <span class="comment">// 更新队首的顾客结束时间</span></span><br><span class="line">        window[min_win].start_pop_time += window[min_win].q.front();</span><br><span class="line">        <span class="comment">// 如果该窗口处理当前黄线内排队的人已经有大于540的了，那么新加入的必sorry</span></span><br><span class="line">        <span class="keyword">if</span> (window[min_win].end_pop_time&gt;=(<span class="number">17</span><span class="number">-8</span>)*<span class="number">60</span>) sorry[index] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 当前窗口的结束时间更新为： 已有的时间 + 新进入的顾客的处理时间</span></span><br><span class="line">        window[min_win].end_pop_time += taketime[index];</span><br><span class="line">        <span class="comment">// 在这种情况下， 顾客的结束时间就是该窗口的end_pop_time</span></span><br><span class="line">        quiz[index] = window[min_win].end_pop_time;</span><br><span class="line">        <span class="comment">// 处理下一个顾客</span></span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回答问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> query, ans;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;query);</span><br><span class="line">        ans = quiz[query];</span><br><span class="line">        <span class="comment">// 先判断是否sorry， 如果非sorry， 那么就有服务结束时间</span></span><br><span class="line">        <span class="keyword">if</span>(sorry[query] == <span class="literal">true</span>) <span class="built_in">printf</span>(<span class="string">"Sorry\n"</span>);</span><br><span class="line">        <span class="comment">// 规范输出结果</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%02d:%02d\n"</span>,(ans + <span class="number">8</span>*<span class="number">60</span>) / <span class="number">60</span>, (ans + <span class="number">8</span>*<span class="number">60</span>) % <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1016-phone-bills"><a class="markdownIt-Anchor" href="#1016-phone-bills"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805493648703488" target="_blank" rel="noopener">1016 Phone Bills</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 写法一</span></span><br><span class="line">    <span class="built_in">string</span> date;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; date;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s = date.data();</span><br><span class="line">    <span class="keyword">int</span> month, day, hour, minute;</span><br><span class="line">    <span class="built_in">sscanf</span>(s, <span class="string">"%d:%d:%d:%d"</span>, &amp;month, &amp;day, &amp;hour, &amp;minute);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; month &lt;&lt; <span class="string">"\t"</span>&lt;&lt;day&lt;&lt;<span class="string">"\t"</span>&lt;&lt;hour&lt;&lt;<span class="string">"\t"</span>&lt;&lt;minute&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 写法二</span></span><br><span class="line">    <span class="built_in">string</span> date;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; date;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(date)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> month, day, hour, minute;</span><br><span class="line">    getline(ss, month, <span class="string">':'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; month&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    getline(ss, day, <span class="string">':'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; day&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    getline(ss, hour, <span class="string">':'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hour&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    getline(ss, minute, <span class="string">':'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; minute&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1017-queueing-at-bank"><a class="markdownIt-Anchor" href="#1017-queueing-at-bank"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805491530579968" target="_blank" rel="noopener">1017 Queueing at Bank</a></h3><blockquote><ol><li>将达到时间换算成秒（这样可以避免小数），我这里将到达时间以开门时间（8点）为0值，来早的即为负数（绝对值为等待时间），然后进行排序。</li><li>判断有效人数是否大于0，不是则提前输出0.0（保留一位小数！！）</li><li>设置windows[k]为窗口可以处理下一个客户的时间，默认值为0</li></ol></blockquote><h3 id="1018-public-bike-management"><a class="markdownIt-Anchor" href="#1018-public-bike-management"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024" target="_blank" rel="noopener"> 1018  Public Bike Management</a></h3><h3 id="1019-general-palindromic-number"><a class="markdownIt-Anchor" href="#1019-general-palindromic-number"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805487143337984" target="_blank" rel="noopener"> 1019  General Palindromic Number</a></h3><h3 id="1020-tree-traversals"><a class="markdownIt-Anchor" href="#1020-tree-traversals"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072" target="_blank" rel="noopener"> 1020  Tree Traversals</a></h3><blockquote><p>考察树的遍历。二叉树的前序、中序、后序遍历需要用到栈（<strong>递归</strong>的过程也就是一个栈）(DFS)，层次遍历需要借助<strong>队列</strong>这个数据结构==&gt;(BFS)。</p><p>中序的结构的特点是：<strong>左子树+根结点+右子树</strong>。<br>而后序结构的特点是：<strong>左子树+右子树+根结点</strong>。</p><p>解题思路:后序(postOrder)和先序(preOrder)遍历提供<strong>根节点位置</strong>，然后再中序(inOrder)序列中区分出<strong>左子树和右子树</strong>，递归建树，然后BFS层序遍历。</p></blockquote><p><a href="https://blog.csdn.net/CV_Jason/article/details/81394447" target="_blank" rel="noopener">柳婼Code</a></p><blockquote><p>二叉树利用数组来完成, 未使用结构体</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post, in, level(<span class="number">100000</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"root = "</span>&lt;&lt;root&lt;&lt;<span class="string">" start"</span>&lt;&lt;start&lt;&lt;<span class="string">" end="</span>&lt;&lt;end&lt;&lt;<span class="string">" index="</span>&lt;&lt;index&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="comment">// 通过后序根节点找到中序根节点的索引 </span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; end &amp;&amp; in[i] != post[root]) i++;</span><br><span class="line">    <span class="comment">// 对于后序遍历，最后一个结点是根节点 </span></span><br><span class="line">    level[index] = post[root];</span><br><span class="line">    <span class="comment">// 【这段递归是本代码的亮点所在】</span></span><br><span class="line"><span class="comment">// (root -(end - i + 1)) 后序root地址 - (中序左子树长度)，得到下一次的左子树的后序root地址 </span></span><br><span class="line">    pre(root - (end - i + <span class="number">1</span>), start, i - <span class="number">1</span>, <span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// root - 1 后序root地址 左邻接点右子树的根 </span></span><br><span class="line">    pre(root - <span class="number">1</span>, i + <span class="number">1</span>, end, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="comment">// 预置n个结点 </span></span><br><span class="line">    post.resize(n);</span><br><span class="line">    in.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;post[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[i]);</span><br><span class="line">    pre(n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level.size(); i++) &#123;</span><br><span class="line">    <span class="comment">//  </span></span><br><span class="line">        <span class="keyword">if</span> (level[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, level[i]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>My</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> post[MAXN], in[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> num;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Node *lchild;</span><br><span class="line">    Node *rchild;</span><br><span class="line">&#125;<span class="keyword">typedef</span> Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [根据中序和先序遍历构建树, 参数全为索引]</span></span><br><span class="line"><span class="comment"> * @author mrli 2020-01-28</span></span><br><span class="line"><span class="comment"> * @param  postl [后序左边界]</span></span><br><span class="line"><span class="comment"> * @param  postr [后序右边界]</span></span><br><span class="line"><span class="comment"> * @param  inl   [中序左边界]</span></span><br><span class="line"><span class="comment"> * @param  inr   [中序右边界]</span></span><br><span class="line"><span class="comment"> * @return       [节点]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node *<span class="title">createTree</span><span class="params">(<span class="keyword">int</span> postl, <span class="keyword">int</span> postr, <span class="keyword">int</span> inl, <span class="keyword">int</span> inr)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先序左指针&gt;右指针</span></span><br><span class="line">    <span class="keyword">if</span> (postl&gt;postr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="comment">// 找到根节点后序的索引值</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= inr; ++k)</span><br><span class="line">        <span class="keyword">if</span> (in[k] == post[postr]) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 分界线</span></span><br><span class="line">    <span class="keyword">int</span> numLeft = k - inl;</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    root-&gt;v = post[postr];</span><br><span class="line">    root-&gt;lchild = createTree(postl, postl+numLeft<span class="number">-1</span>, inl, k<span class="number">-1</span>);</span><br><span class="line">    root-&gt;rchild = createTree(postl+numLeft, postr<span class="number">-1</span>, k+<span class="number">1</span>, inr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对numLeft定义进行了修改</span></span><br><span class="line"><span class="function">Node *<span class="title">createTree</span><span class="params">(<span class="keyword">int</span> postl, <span class="keyword">int</span> postr, <span class="keyword">int</span> inl, <span class="keyword">int</span> inr)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先序左指针&gt;右指针</span></span><br><span class="line">    <span class="keyword">if</span> (postl&gt;postr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="comment">// 找到根节点中序的索引值: 后序遍历的最后一个为根节点,由于都是不同的数,所以找到值相等的,</span></span><br><span class="line">    <span class="comment">// 此时k即为中序遍历中根的索引值</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= inr; ++k)</span><br><span class="line">        <span class="keyword">if</span> (in[k] == post[postr]) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 计算左子树节点个数X ==&gt; 找到分界线, postl+numLeft-1为后序的左子树, post+numLeft为后序右子树.</span></span><br><span class="line">    <span class="comment">// 真正意义上的左子树节点个数numLeft = k - inl - 1</span></span><br><span class="line">    <span class="keyword">int</span> numLeft = k - inl <span class="number">-1</span>;</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    root-&gt;v = post[postr];</span><br><span class="line">    <span class="comment">// 后序遍历访问左子树时,左边界不变认为postl, 右边界变为postr+numLeft-1,访问右子树时,左边界为postl+numLeft, 右边界为postr-1(去掉了此轮的根节点)</span></span><br><span class="line">    <span class="comment">// postl + numleft 也为第二个根节点索引值</span></span><br><span class="line">    <span class="comment">// k为中序遍历节点的根, 所以访问左子树时左边界改为k-1, 右边界为k+1;访问右子树时左边界为k+1,右边界为inr</span></span><br><span class="line">    root-&gt;lchild = createTree(postl, postl+numLeft, inl, k<span class="number">-1</span>);</span><br><span class="line">    root-&gt;rchild = createTree(postl+numLeft+<span class="number">1</span>, postr<span class="number">-1</span>, k+<span class="number">1</span>, inr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Node* tree)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    q.push(tree);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Node* now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; now-&gt;v;</span><br><span class="line">        num ++;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; n) <span class="built_in">cout</span> &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">if</span> (now-&gt;lchild != <span class="literal">NULL</span>) q.push(now-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (now-&gt;rchild != <span class="literal">NULL</span>) q.push(now-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; post[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; in[i];</span><br><span class="line">    Node* tree = createTree(<span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    BFS(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1021-deepest-root"><a class="markdownIt-Anchor" href="#1021-deepest-root"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856" target="_blank" rel="noopener"> 1021  Deepest Root</a></h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805474338127872" target="_blank" rel="noopener">1025 PAT Ranking</a></p><blockquote><p>通过率为0.27, 题意较简单, 但是处理起来会有坑，也算学习到了吧。</p><ol><li>vector的拼接： <code>v.insert(v.begin(), va.begin(), va.end())</code></li><li>sort自定义函数：在嵌套比较时注意if的条件，<code>return true</code>的将会被放在前面</li><li>排名的处理: 排名相同的一致，不同的在其排序索引上+1</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rc</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> ID;      <span class="comment">//记录ID</span></span><br><span class="line">    <span class="keyword">int</span> grade;      <span class="comment">//成绩</span></span><br><span class="line">    <span class="keyword">int</span> local_num;  <span class="comment">//场次</span></span><br><span class="line">    <span class="keyword">int</span> local_rank; <span class="comment">//该场次的排名</span></span><br><span class="line">&#125;<span class="keyword">typedef</span> rc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(rc &amp;a, rc &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.grade != b.grade)</span><br><span class="line">        <span class="keyword">return</span> a.grade&gt;b.grade;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (a.ID&lt;b.ID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**或者写成</span></span><br><span class="line"><span class="comment">bool cmp(const node &amp;a, const node &amp;b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return a.score==b.score ? a.id&lt;b.id : a.score&gt;b.score;</span></span><br><span class="line"><span class="comment">    // 如果得分相等,ID小的在前,如果得分不等,那么得分大的在前</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;rc&gt; vall;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)&#123;</span><br><span class="line">        <span class="keyword">int</span> K;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; K;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;rc&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i)&#123;</span><br><span class="line">            rc r;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; r.ID &gt;&gt; r.grade;</span><br><span class="line">            r.local_num = j;            </span><br><span class="line">            v.push_back(r);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.begin(), v.end(), cmp);  <span class="comment">// 先将当局排名算出</span></span><br><span class="line">        <span class="keyword">int</span> rank = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rankv = v[<span class="number">0</span>].grade;</span><br><span class="line"></span><br><span class="line">        v[<span class="number">0</span>].local_rank = rank;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 思路</span></span><br><span class="line">            <span class="comment">// if(rankv == v[i].grade)&#123;</span></span><br><span class="line">            <span class="comment">//     v[i].local_rank = rank;</span></span><br><span class="line">            <span class="comment">// &#125;else&#123;</span></span><br><span class="line">            <span class="comment">//     rank = i+1;</span></span><br><span class="line">            <span class="comment">//     v[i].local_rank = rank;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">/* 简洁写法 */</span></span><br><span class="line">            <span class="keyword">if</span>(rankv != v[i].grade)&#123;</span><br><span class="line">                rank = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v[i].local_rank = rank;</span><br><span class="line">            rankv = v[i].grade;         </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        vall.insert(vall.end(), v.begin(), v.end());    <span class="comment">// 将每个场次的结果拼起来</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(vall.begin(), vall.end(), cmp);                <span class="comment">// 对总结果进行排序算出finalRank</span></span><br><span class="line">    <span class="keyword">int</span> Ssize =  vall.size();</span><br><span class="line">    <span class="built_in">cout</span>  &lt;&lt; Ssize &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> finalRank = <span class="number">1</span>;          <span class="comment">// 用来处理排名相同的情况</span></span><br><span class="line">    <span class="keyword">int</span> rankv = vall[<span class="number">0</span>].grade;  <span class="comment">// 用来确定何时排名相同</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vall.at(<span class="number">0</span>).ID &lt;&lt; <span class="string">" "</span>&lt;&lt;finalRank &lt;&lt; <span class="string">" "</span>&lt;&lt;vall.at(<span class="number">0</span>).local_num &lt;&lt; <span class="string">" "</span>&lt;&lt;vall.at(<span class="number">0</span>).local_rank &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Ssize; ++i)&#123;</span><br><span class="line">        <span class="comment">// 这样看思路更清晰一点</span></span><br><span class="line">        <span class="comment">// if(rankv == vall[i].grade)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; vall.at(i).ID &lt;&lt;" "&lt;&lt; finalRank &lt;&lt;" "&lt;&lt; vall.at(i).local_num &lt;&lt;" "&lt;&lt; vall.at(i).local_rank &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//     finalRank = i+1;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; vall.at(i).ID &lt;&lt;" "&lt;&lt; finalRank &lt;&lt;" "&lt;&lt; vall.at(i).local_num &lt;&lt;" "&lt;&lt; vall.at(i).local_rank &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">/* 简洁写法 */</span></span><br><span class="line">        <span class="keyword">if</span>(rankv != vall[i].grade)&#123;</span><br><span class="line">            finalRank = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; vall.at(i).ID &lt;&lt;<span class="string">" "</span>&lt;&lt; finalRank &lt;&lt;<span class="string">" "</span>&lt;&lt; vall.at(i).local_num &lt;&lt;<span class="string">" "</span>&lt;&lt; vall.at(i).local_rank &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        rankv = vall[i].grade;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>▲我这边判断两个rc是否相同，是用rankv和finalrank来记录上一次的结果的，其实还能在for里面判断v.[i].grade == v[i-1].grade</p><h3 id="1027-colors-in-mars"><a class="markdownIt-Anchor" href="#1027-colors-in-mars"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805470349344768" target="_blank" rel="noopener"> 1027 Colors in Mars</a></h3><blockquote><p>考察点： 进制的转换</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">int2string</span><span class="params">(<span class="keyword">int</span> ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ans)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> to_string(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decimal2radix</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">13</span>) <span class="keyword">return</span> <span class="string">"0"</span>+int2string(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = n;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">while</span>(tmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        res.insert(<span class="number">0</span>, int2string(tmp%<span class="number">13</span>));</span><br><span class="line">        tmp /= <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r, g, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; g &gt;&gt; b ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"#"</span> &lt;&lt; decimal2radix(r) &lt;&lt; decimal2radix(g) &lt;&lt; decimal2radix(b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1036-boys-vs-girls"><a class="markdownIt-Anchor" href="#1036-boys-vs-girls"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805453203030016" target="_blank" rel="noopener">1036 Boys vs Girls</a></h3><blockquote><p>考点: 结构体； sort比较函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> sex;</span><br><span class="line">    <span class="built_in">string</span> subject;</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">&#125;<span class="keyword">typedef</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(rc &amp;r1, rc &amp;r2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r1.sex == <span class="string">"M"</span> &amp;&amp; r2.sex == <span class="string">"F"</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r1.sex == <span class="string">"F"</span> &amp;&amp; r2.sex == <span class="string">"M"</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> r1.grade &lt; r2.grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;rc&gt; v(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        rc r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; r.name &gt;&gt; r.sex &gt;&gt; r.subject &gt;&gt; r.grade;</span><br><span class="line">        v[i] = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(v.begin(), v.end(), cmp);</span><br><span class="line">    <span class="comment">// for (std::vector&lt;rc&gt;::iterator i = v.begin(); i != v.end(); ++i)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i-&gt;name &lt;&lt; " " &lt;&lt; i-&gt;sex &lt;&lt; " " &lt;&lt; i-&gt;subject &lt;&lt; " " &lt;&lt; i-&gt;grade &lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;rc&gt;::iterator boy = v.begin();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;rc&gt;::iterator girl = v.end()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> absent = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(girl-&gt;sex == <span class="string">"F"</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; girl-&gt;name &lt;&lt; <span class="string">" "</span> &lt;&lt; girl-&gt;subject &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Absent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        absent = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(boy-&gt;sex == <span class="string">"M"</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; boy-&gt;name &lt;&lt; <span class="string">" "</span> &lt;&lt; boy-&gt;subject &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Absent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        absent = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!absent)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; girl-&gt;grade - boy-&gt;grade &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NA"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1041-be-unique"><a class="markdownIt-Anchor" href="#1041-be-unique"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805444361437184" target="_blank" rel="noopener"> 1041 Be Unique</a></h3><blockquote><p>模拟题，难点在找到第一个。此处的<code>table</code>为int型数组的哈希表–&gt;可以使用STL中的map代替</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> table[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="comment">// a[i]来记录不同数字出现的顺序</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="comment">// table记录出现的次数</span></span><br><span class="line">        table[a[i]] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="comment">// 按照出现的顺序遍历, 查看是否有数出现的次数为1</span></span><br><span class="line">        <span class="keyword">if</span> ( table[a[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果找到出现次数为1的就输出</span></span><br><span class="line">            ans = a[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt;<span class="string">"None"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt;ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1050-string-subtraction"><a class="markdownIt-Anchor" href="#1050-string-subtraction"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805429018673152" target="_blank" rel="noopener">1050 String Subtraction</a></h3><blockquote><p>题意:将S1中出现的S2字符全部删除。</p><p>解题：删一个改一个，但是考虑到字符串可以理解为数组，所以修改必然要牵扯到移位。此时有个细节，到底是从头往后遍历还是从后往前遍历。从前往后修改存在的问题是，<strong>如果是判断相等后立马修改,则后面的索引值会错位(因为删除后后面的字符串往前调整,而指针却+1,所以会略过一个字符)</strong></p><p>突然发现这个移位的功能不需要自己写，string有提供erase函数！：<a href="http://c.biancheng.net/view/1449.html" target="_blank" rel="noopener">C++ string字符串修改和替换方法详解</a></p><p>（1）erase(pos,n); 删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符<br>（2）erase(position);删除position处的一个字符(position是个string类型的<strong>迭代器</strong>),如果是数字会截断索引值为position后字符串<br>（3）erase(first,last);删除从first到last之间的字符（first和last都是迭代器）</p><p>△因此，我使用的是从后往前用erase函数进行删除；读取行内容使用getline</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> origin;</span><br><span class="line">    <span class="built_in">string</span> out;</span><br><span class="line">    getline(<span class="built_in">cin</span>, origin);</span><br><span class="line">    getline(<span class="built_in">cin</span>, out);</span><br><span class="line">    <span class="keyword">int</span> Lorigin = origin.size();</span><br><span class="line">    <span class="keyword">int</span> Lout = out.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = Lorigin<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lout; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(origin[j] == out[i])&#123;</span><br><span class="line">                origin.erase(j,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; origin &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1056-mice-and-rice"><a class="markdownIt-Anchor" href="#1056-mice-and-rice"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805419468242944" target="_blank" rel="noopener">1056 Mice and Rice</a></h3><blockquote><p>题目有点长，看了题解的解释才懂。在此复述一遍：给你NP个老鼠以及他们的重量W，每NG个老鼠分为一组，不够NG个数的单独算一个组，比较他们每个组的最大值，将<strong>最大值</strong>进入下一轮的比较，同组其余老鼠皆为淘汰，并与其他组同时被淘汰的老鼠排名一致，最后求所有老鼠的<strong>排名</strong>。</p><p>输入解释：第一行分别为NP和NG，第二行是每个老鼠的体重，第三行是每个老鼠的编号。第三行的需要特表说明，如输入样例：6 0 8 7 10 5 9 1 4 2 3， 意思是标号6、0、8为一组，7、10、5为一组，一次往后，即这行说明的是分组顺序</p><p><strong>解题思路：</strong> 这道题的难点在于对数据进行分组，比较并进行排名，其中，<strong>老鼠的排名==该轮比赛分组个数+1</strong>——本轮比较分group个组，意味着有group个优胜者，也就是说，其余所有被淘汰的都在这group之后，即group+1.所以我们直接每轮的分组数即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mice</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> init;</span><br><span class="line">    <span class="keyword">int</span> rank;</span><br><span class="line">&#125;<span class="keyword">typedef</span> mice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> NP, NG;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; NP &gt;&gt; NG;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;mice&gt; v(NP);    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;   <span class="comment">// 存储下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NP; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v.at(i).weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NP; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        q.push(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> turnP;</span><br><span class="line">   <span class="keyword">while</span>(q.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">int</span> turnP = q.size();    <span class="comment">// 记录每轮的所有人数，q.size()为总人数，+1是结束值</span></span><br><span class="line">       <span class="keyword">int</span> turnG = (turnP%NG==<span class="number">0</span>) ? turnP/NG : turnP/NG + <span class="number">1</span>; <span class="comment">// 该轮分组个数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; turnG; ++j)&#123;      <span class="comment">// 循环结束为一轮</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cmp;                <span class="comment">// 找出该group中的最大数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NG; ++i)&#123;       <span class="comment">// 将元素加入cmp中</span></span><br><span class="line">            <span class="comment">// j:0-3, NG=3, i=0-2</span></span><br><span class="line">            <span class="keyword">if</span>( j * NG + i == turnP) <span class="keyword">break</span>;   <span class="comment">// 当超出含有数量时结束</span></span><br><span class="line">            <span class="comment">// 样例输入NP=11，0-10,到11时无效</span></span><br><span class="line">            cmp.push_back(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">          调试部分</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" cmp.size():"</span>&lt;&lt; cmp.size()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cmp.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cmp[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxV = v.at(cmp[<span class="number">0</span>]).weight;      <span class="comment">// 当前组中的体重最大值</span></span><br><span class="line">        <span class="keyword">int</span> maxI = <span class="number">0</span>;                        <span class="comment">// 当前组中最大值的索引</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"初始最大值:"</span> &lt;&lt; maxV &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cmp.size(); ++i)&#123;<span class="comment">// 如果正好能全部分完</span></span><br><span class="line">             <span class="keyword">int</span> w = v.at(cmp[i]).weight;</span><br><span class="line">             <span class="keyword">if</span> ( w &gt; maxV)&#123;</span><br><span class="line">                maxV = w;</span><br><span class="line">                maxI = i;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// &#125;else&#123; // 被淘汰的,排名为该轮分组数+1</span></span><br><span class="line">             <span class="comment">//    v.at(cmp[i]).rank = turnG + 1;</span></span><br><span class="line">             <span class="comment">// &#125;</span></span><br><span class="line">                v.at(cmp[i]).rank = turnG + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"更新rank："</span> &lt;&lt; cmp[i] &lt;&lt; <span class="string">"为"</span> &lt;&lt; turnG + <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"最大值："</span> &lt;&lt; maxV &lt;&lt; <span class="string">"索引值"</span> &lt;&lt; cmp[maxI] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">          <span class="comment">// 将胜出的重新加如</span></span><br><span class="line">          q.push(cmp[maxI]);</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"本gourp加入"</span> &lt;&lt; cmp[maxI] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"q.size()"</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        cmp.clear();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;<span class="comment">// end while when q.size == 1</span></span><br><span class="line">   <span class="keyword">int</span> campionIndex = q.front();</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"campionIndex"</span> &lt;&lt; campionIndex &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   v[campionIndex].rank = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"结果："</span> ; </span><br><span class="line">   <span class="comment">// 按格式输出结果</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; v[<span class="number">0</span>].rank;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; NP; ++i) <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; v[i].rank;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>▲真的挺难的一题，首先是题目比较难理解，其次需要找到如果确定每个player的排名规律，最后再是每轮中处理不满一组的情况。</p><p><img src="/2019/10/24/PAT冲冲冲——甲级/1056.jpg" alt="1056"></p><h3 id="1062-talent-and-virtue"><a class="markdownIt-Anchor" href="#1062-talent-and-virtue"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805410555346944" target="_blank" rel="noopener">1062 Talent and Virtue</a></h3><blockquote><p>题意理解: 将输入的人分为三类，圣人sage，君子nobleman，愚人foolman和小人small man。输出他们的排名，规则如下，列出N行数据，L最低线，H最高限。sage为virtue品德和talent才能分数都高于H，他们之间的排名通过两者总分来区分；nobleman为talent才能低于H，但是virtue高于H的，同样也通过总分来区分，但是他们排在sage之后；如果两项得分都低于H，并且virtue不低于talent的为foolman，他们排在nobleman之后；剩下过了L线的人都排在foolman之后。（必须两个分数都高于L才能被显示）</p></blockquote><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805389634158592" target="_blank" rel="noopener"> 1078 Hashing</a></p><blockquote><p>Hash题，一开始审题错误，是平方探测法。</p><p>不算难，转化大小很简单，主要在这个平方探测上面。 <strong>是(key + step * step) % size 而不是(key % size + step * step)</strong>， 知道了这个，就比较好办了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10e6</span>;</span><br><span class="line"><span class="keyword">int</span> M, N;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in;    <span class="comment">// 记录输入, 查询相应位置是否有数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;     <span class="comment">// 用来记录相应数的索引位置, 输出值: v[0]就是第一个数的hash值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( n== <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ( n == <span class="number">2</span> || n == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (n%<span class="number">6</span>!= <span class="number">1</span>) &amp;&amp; (n%<span class="number">6</span>!= <span class="number">5</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= tmp; i+=<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( n % i ==<span class="number">0</span> || n%(i+<span class="number">2</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N;</span><br><span class="line">    <span class="keyword">while</span>(!isprime(M)) M++;<span class="comment">// ▲将数扩大到最小质数</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; "最小的质数为:" &lt;&lt; M &lt;&lt; endl;</span></span><br><span class="line">    v.resize(N);</span><br><span class="line">    in.resize(M);   <span class="comment">// 这句很重要</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">bool</span> yes = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = (tmp+j*j)%M;</span><br><span class="line">            <span class="keyword">if</span> ( in[index] == <span class="number">0</span>)&#123;</span><br><span class="line">                v[i] = index;</span><br><span class="line">                in[index] = tmp;</span><br><span class="line">                yes = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span> (!yes) v[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/** 为二次再散列法*/</span></span><br><span class="line">        <span class="comment">// if(in[index] == 0)&#123; // 如果没有冲突, 则安放</span></span><br><span class="line">        <span class="comment">//     v[i] = index;</span></span><br><span class="line">        <span class="comment">//     in[index] = tmp;</span></span><br><span class="line">        <span class="comment">//     // cout &lt;&lt; "yes" &lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//     // cout &lt;&lt; "no" &lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//     // 二次</span></span><br><span class="line">        <span class="comment">//     int new_index = index%M;</span></span><br><span class="line">        <span class="comment">//     if (in[new_index] ==0)&#123;</span></span><br><span class="line">        <span class="comment">//         v[i] = new_index;</span></span><br><span class="line">        <span class="comment">//         in[new_index] = tmp;</span></span><br><span class="line">        <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//         v[i] = -1;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出处理</span></span><br><span class="line">    <span class="keyword">if</span>(v[<span class="number">0</span>] == <span class="number">-1</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i] == <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" -"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1081-rational-sum"><a class="markdownIt-Anchor" href="#1081-rational-sum"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805386161274880" target="_blank" rel="noopener">1081  Rational Sum</a></h3><blockquote><p>分数计算的加强版，多个分数相加。我采用了一次性计算，其实可以直接用乙级的做法，两个两个依次计算。</p><p>▲牛客网和PTA的样例点真的不一样，PTA上我有一个点过不了，但牛客的都能过</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fenshu</span>&#123;</span></span><br><span class="line">    ll fenmu;</span><br><span class="line">    ll fenzi;</span><br><span class="line">&#125;<span class="keyword">typedef</span> Fenshu;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到分子和分母的最大公因数</span></span><br><span class="line"><span class="function">ll <span class="title">biggestNum</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> biggestNum(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到分子和分母的最小公倍数</span></span><br><span class="line"><span class="function">ll <span class="title">smallestNum</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b/biggestNum(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Fenshu&gt; v;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            Fenshu *fs = <span class="keyword">new</span> Fenshu();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld/%lld"</span>,&amp;fs-&gt;fenzi,&amp;fs-&gt;fenmu);</span><br><span class="line">            v.emplace_back(*fs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到所有分母的最小公倍数</span></span><br><span class="line">        ll mul = v.begin()-&gt;fenmu;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Fenshu&gt;::iterator i = v.begin(); i != v.end(); ++i)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Fenshu&gt;::iterator nx = <span class="built_in">std</span>::next(i,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nx != v.end())&#123;</span><br><span class="line">                mul = smallestNum(mul, nx-&gt;fenmu);</span><br><span class="line">                <span class="comment">// printf("i-&gt;fenmu:%lld, nx-&gt;fenmu:%lld, tmp_mul:%lld\n", i-&gt;fenmu, nx-&gt;fenmu, tmp_mul);</span></span><br><span class="line"><span class="comment">// 错误尝试写法：思路错了:变成了找到两个分母最小公倍数中最大的</span></span><br><span class="line">                <span class="comment">// if (mul &lt; tmp_mul) &#123;</span></span><br><span class="line">                    <span class="comment">// printf("tmp_biggest:%lld\n", tmp_biggest);</span></span><br><span class="line">                    <span class="comment">// mul = tmp_mul;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相加再约分</span></span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Fenshu&gt;::iterator i = v.begin(); i != v.end(); ++i)&#123;</span><br><span class="line">            <span class="comment">// printf("%lld,%lld\n",i-&gt;fenzi, i-&gt;fenmu );</span></span><br><span class="line">            sum +=  i-&gt;fenzi*mul/(i-&gt;fenmu);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>)&#123;  <span class="comment">// 采坑1:除0问题</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 由于读取的设定,所以其实只有分子会是负数, yue也可能是负数</span></span><br><span class="line">            ll yue = <span class="built_in">abs</span>(biggestNum(sum, mul));</span><br><span class="line">            ll res_fenzi = sum/yue;</span><br><span class="line">            ll res_fenmu = mul/yue;</span><br><span class="line">            <span class="comment">// printf("sum:%lld\n", sum);</span></span><br><span class="line">            <span class="comment">// printf("%lld,%lld/%lld\n", yue, res_fenzi, res_fenmu);</span></span><br><span class="line">            <span class="comment">// printf("biggest:%lld\n", mul);</span></span><br><span class="line">            <span class="comment">// 需要化成真分数--&gt;采坑2:分子和为负数</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">abs</span>(res_fenzi) &gt; res_fenmu) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res_fenzi%res_fenmu == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res_fenzi/res_fenmu);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld %lld/%lld\n"</span>, res_fenzi/res_fenmu, res_fenzi%res_fenmu, res_fenmu);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>, res_fenzi, res_fenmu);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        v.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>▲判断迭代器是否为空:就是拿返回的迭代器与.end()作比较。</p><p>踩坑记录：</p><ul><li>负数求余仍是负数,0求余任何数为0</li><li>分子为负数、0、正数的时候都得分别考虑</li><li>找到所有分母的最小公倍数==&gt;写成了找到两个分母最小公倍数中最大的</li></ul><p><strong>浮点错误的意思-PAT 、OJ</strong></p><ul><li>是否可能出现了一个数除以0的情况</li><li>是否可能出现了一个数取余0的情况</li><li>是否发生了数据溢出而导致的除以0或者取余0的情况</li></ul><h3 id="1083-list-grades-25"><a class="markdownIt-Anchor" href="#1083-list-grades-25"></a> <a href="https://www.nowcoder.com/pat/1/problem/4313" target="_blank" rel="noopener">1083 List Grades (25)</a></h3><blockquote><p>模拟题</p><p>考了输入输出+排序： 切割数据、操作符重载</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> N</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> id;</span><br><span class="line">    <span class="keyword">int</span>  grade;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Record &amp;that) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grade &gt; that.grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">typedef</span> Record;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> row;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Record&gt; v;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">// 获得行信息</span></span><br><span class="line">        getline(<span class="built_in">cin</span>, row);</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(row)</span></span>;</span><br><span class="line"><span class="comment">// 分割出name</span></span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        getline(ss, name, <span class="string">' '</span>);</span><br><span class="line"><span class="comment">// 分割出id</span></span><br><span class="line">        <span class="built_in">string</span> id;</span><br><span class="line">        getline(ss, id, <span class="string">' '</span>);</span><br><span class="line"><span class="comment">// 通过stringstream分割出grade: int</span></span><br><span class="line">        <span class="keyword">int</span> grade;</span><br><span class="line">        ss &gt;&gt; grade;</span><br><span class="line"><span class="comment">// 存到vector中</span></span><br><span class="line">        Record* r = <span class="keyword">new</span> Record();</span><br><span class="line">        r-&gt;name = name;</span><br><span class="line">        r-&gt;id = id;</span><br><span class="line">        r-&gt;grade = grade;</span><br><span class="line">        v.emplace_back(*r);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 根据grade进行从大到小排序</span></span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">bool</span> none = <span class="literal">true</span>; <span class="comment">// 是否有在区间中人</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i].grade &gt;= a &amp;&amp; v[i].grade &lt;= b)&#123;</span><br><span class="line">            none = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; v[i].name &lt;&lt; <span class="string">" "</span> &lt;&lt; v[i].id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有符合条件的人</span></span><br><span class="line">    <span class="keyword">if</span> (none) <span class="built_in">cout</span> &lt;&lt; <span class="string">"NONE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此巩固复习一下&quot;操作符重载的知识&quot;:</p><blockquote><p>1.为了实现对自定义类型的加减操作。</p><ol start="2"><li>实现一个操作符重载的方式通常分为两种情况：</li></ol><ul><li><p>将操作符重载实现为类的成员函数；</p><ul><li>使用<code>O.operator#();</code></li></ul></li><li><p>操作符重载实现为非类的成员函数（即全局函数）。</p><ul><li>使用 <code>operator#(O);</code></li></ul><p>区别在于，成员函数默认有this指针；后者需要为每次操作传递两个参数</p></li></ul></blockquote><p>△大多数操作符都能重载，不能的为如下几个：<code>：</code>、<code>::</code>、<code>.*</code>、<code>?:</code>、<code>sizeof</code></p><p>▲重载运算符函数可以对运算符作出新的解释，但原有基本语义不变：</p><blockquote><p>不改变运算符的优先级<br>不改变运算符的结合性<br>不改变运算符所需要的操作数<br>不能创建新的运算符</p></blockquote><p>△一个运算符被重载后，原有意义没有失去，只是定义了相对一特定类的一个新运算符</p><p>++前缀、后缀</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 重载前缀递增运算符（ ++ ）： 不传参</span></span><br><span class="line">      Time <span class="keyword">operator</span>++ ()  </span><br><span class="line">      &#123;</span><br><span class="line">         ++minutes;          <span class="comment">// 对象加 1</span></span><br><span class="line">         <span class="keyword">if</span>(minutes &gt;= <span class="number">60</span>)  </span><br><span class="line">         &#123;</span><br><span class="line">            ++hours;</span><br><span class="line">            minutes -= <span class="number">60</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> Time(hours, minutes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重载后缀递增运算符（ ++ ）: 传参</span></span><br><span class="line">      Time <span class="keyword">operator</span>++( <span class="keyword">int</span> )         </span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// 保存原始值</span></span><br><span class="line">         <span class="function">Time <span class="title">T</span><span class="params">(hours, minutes)</span></span>;</span><br><span class="line">         <span class="comment">// 对象加 1</span></span><br><span class="line">         ++minutes;                    </span><br><span class="line">         <span class="keyword">if</span>(minutes &gt;= <span class="number">60</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            ++hours;</span><br><span class="line">            minutes -= <span class="number">60</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 返回旧的原始值</span></span><br><span class="line">         <span class="keyword">return</span> T; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>io操作符：</p><blockquote><p>▲<code>&lt;&lt;</code>操作符只能通过友元来实现</p><p>A： 如果要重载&lt;&lt;操作符输出结果，一般的写法是cout&lt;&lt;s;也即是说左侧不是<strong>成员函数</strong>或<strong>类可以通过this指针调用的量</strong>，这就造成必须使用两个参数的成员操作符重载，把第一个参数作为&lt;&lt;左侧参数，第二个参数做为&lt;&lt;右侧参数输入，然而会发现如： <code>ostream&amp; operator&lt;&lt;(ostream&amp; out, MyString&amp; s);*//报错，error:此运算符的参数太多*</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xxx</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Complax &amp;c1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Complax &amp;c1)&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">"c1.a = "</span> &lt;&lt; c1.a &lt;&lt; <span class="string">"\t c1.b = "</span> &lt;&lt; c1.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> </h3><h3 id="1084-broken-keyboard"><a class="markdownIt-Anchor" href="#1084-broken-keyboard"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805382902300672" target="_blank" rel="noopener">1084 Broken Keyboard</a></h3><blockquote><p>思路是遍历下面的短的字符串，然后用指针再遍历长的，用index指针来手动控制；边遍历边输出，就可以解决先后问题，否则用set会排序；用set记录是否已经输出过；</p><p>踩的坑点： <code>set.find() == set.end()</code>表示不存在，写IF条件的时候想反了，检查了半天；如果长的已经把短的所有都跑遍后，之后还有需要吧index继续跑完slen-inlen的长度</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; cS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">string</span> in;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; in;</span><br><span class="line">    <span class="keyword">int</span> slen = s.length();</span><br><span class="line">    <span class="keyword">int</span> inlen = in.length();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">// 记录当前遍历到的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inlen; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(  s[index] != in[i] )&#123;</span><br><span class="line">                <span class="keyword">char</span> now = <span class="built_in">toupper</span>( s[index] );</span><br><span class="line">                <span class="keyword">if</span>( cS.find(now) == cS.end())&#123;   </span><br><span class="line">                    cS.insert(now);</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; now;</span><br><span class="line">                &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(index != slen)&#123;</span><br><span class="line">            <span class="keyword">char</span> now = <span class="built_in">toupper</span>( s[index] );</span><br><span class="line">            <span class="keyword">if</span>( cS.find(now) == cS.end())&#123;   </span><br><span class="line">                cS.insert(now);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; now;</span><br><span class="line">            &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1091-speech-patterns"><a class="markdownIt-Anchor" href="#1091-speech-patterns"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805398257647616" target="_blank" rel="noopener">1091 Speech Patterns</a></h3><blockquote><p>题目不难， 主要是库函数的应用<code>isdigit()</code>、<code>isalpha</code>以及<code>isalnum</code>，还有map的应用</p><p>坑点比较多： 1.“”（即空会被记入map计算）；2.当已经是最后一个字母时要把最后一个单词记入（想了很久没过最后一个测试点）</p><p>本来以为要统计的是&quot;&quot;内的内容，结果好像不需要</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; smap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    getline(<span class="built_in">cin</span>, s);</span><br><span class="line">    <span class="keyword">int</span> slen = s.length();</span><br><span class="line">    <span class="built_in">string</span> nows;</span><br><span class="line">    <span class="comment">// bool start = false;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> now = s[i];</span><br><span class="line">        <span class="comment">// if (now == '"') start = !start;</span></span><br><span class="line">        <span class="comment">// if (start)&#123;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalnum</span>(now))&#123;</span><br><span class="line">                nows += <span class="built_in">tolower</span>(now);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( !<span class="built_in">isalnum</span>(now) || i == slen<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!nows.empty())&#123;<span class="comment">// nows.size()会更好</span></span><br><span class="line">                    smap[nows] += <span class="number">1</span>;</span><br><span class="line">                    nows.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxn = -MAXN;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator i = smap.begin(); i != smap.end(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (  i-&gt;second &gt; maxn)&#123;</span><br><span class="line">            maxn = i-&gt;second;</span><br><span class="line">            ans = i-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span> &lt;&lt;  maxn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1093-count-pats"><a class="markdownIt-Anchor" href="#1093-count-pats"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805373582557184" target="_blank" rel="noopener">1093 Count PAT’s</a></h3><blockquote><p>卡时限，普通思路会超时， 题解给的思路是找A然后计算前P的个数N，后T的个数M，然后得出M*N个，时间复杂度为O(n2)</p></blockquote><p>个人的思路(过2个点，还有3个超时)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    l = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i]==<span class="string">'P'</span>) P.push_back(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i]==<span class="string">'A'</span>) A.push_back(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i]==<span class="string">'T'</span>) T.push_back(i);</span><br><span class="line">        <span class="keyword">else</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pl = P.size();</span><br><span class="line">    <span class="keyword">int</span> al = A.size();</span><br><span class="line">    <span class="keyword">int</span> tl = T.size();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pl; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; al; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (P.at(i)&lt;A.at(j))&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; tl; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (A.at(j) &lt; T.at(k))&#123;</span><br><span class="line">                        ans = (ans+<span class="number">1</span>) %MOD;</span><br><span class="line">                        <span class="comment">// break;</span></span><br><span class="line">                    &#125;        </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;ans&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1099-build-a-binary-search-tree"><a class="markdownIt-Anchor" href="#1099-build-a-binary-search-tree"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805367987355648" target="_blank" rel="noopener"> 1099  Build A Binary Search Tree</a></h3><h3 id="1113-integer-set-partition"><a class="markdownIt-Anchor" href="#1113-integer-set-partition"></a> <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805357258326016" target="_blank" rel="noopener">1113 Integer Set Partition</a></h3><blockquote><p>大水题</p><p>将输入的数分成两个不相交的集合，在满足个数差最小的条件下，找两个集合所有元素和差最大值。<br>其实是道找规律题：将数进行从小到大排序，然后一分为二，根据奇偶数的不同，n之差直有1和0两种可能，差值最大的情况便是大数-小数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    sort(arr, arr+n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>( n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n<span class="number">-1</span>)/<span class="number">2</span>; ++i)</span><br><span class="line">            s1 += arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (n<span class="number">-1</span>)/<span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">            s2 += arr[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; s2 -s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; ++i)</span><br><span class="line">            s1 += arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">            s2 += arr[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; s2 -s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805352925609984" target="_blank" rel="noopener">1120 Friend Numbers</a></p><blockquote><p>我使用的是Map，但set效果更好</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[SIZE];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(tmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum += tmp%<span class="number">10</span>;</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>[sum] ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">map</span>.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator i = <span class="built_in">map</span>.begin(); i != <span class="built_in">map</span>.end(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// end()-1好像不行</span></span><br><span class="line">        <span class="comment">// std::map&lt;int, int&gt;::iterator e = map.end()-1;</span></span><br><span class="line">        <span class="comment">// if(i != e)</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; i-&gt;first &lt;&lt; ' ';</span></span><br><span class="line">        <span class="comment">// else</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; i-&gt;first &lt;&lt; endl;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二种写法</span></span><br><span class="line">        <span class="comment">// std::map&lt;int, int&gt;::iterator e = map.end()-1;</span></span><br><span class="line">        <span class="comment">// if(i != map.begin())</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; ' ';</span></span><br><span class="line">        <span class="comment">// else</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; i-&gt;first &lt;&lt; endl;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第三种办法</span></span><br><span class="line">        <span class="comment">// 使用flag记录</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*第四种</span></span><br><span class="line"><span class="comment">        if(it==out.begin())</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;*it;</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;" "&lt;&lt;*it;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 我的笨办法</span></span><br><span class="line">        v.push_back(i-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=v.size()<span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2><p><a href="https://blog.csdn.net/zxc1364787928/article/details/85757131" target="_blank" rel="noopener">刷PAT好用到哭的函数</a></p><p><strong>好用的函数</strong></p><p>string-&gt;int</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法一</span></span><br><span class="line"><span class="keyword">int</span> grade;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &gt;&gt; grade;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二</span></span><br><span class="line">stoi() <span class="comment">// 在cstring中</span></span><br></pre></td></tr></table></figure><p>int-&gt;string</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法一</span></span><br><span class="line">to_string()<span class="comment">// C++11之后才支持</span></span><br><span class="line"><span class="comment">// 法二</span></span><br><span class="line">itos()   <span class="comment">// cstring中</span></span><br></pre></td></tr></table></figure><p>sort中cmp函数编写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从大到小排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(rc &amp;a, rc &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.grade &gt; b.grade;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(rc &amp;a, rc &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.grade &lt; b.grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果为M则排前，F排后； 如果字符相同，就比成绩</span></span><br><span class="line"><span class="comment">// -&gt;排前的return true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(rc &amp;r1, rc &amp;r2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r1.sex == <span class="string">"M"</span> &amp;&amp; r2.sex == <span class="string">"F"</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r1.sex == <span class="string">"F"</span> &amp;&amp; r2.sex == <span class="string">"M"</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> r1.grade &lt; r2.grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般情况下,对相等的情况不需要特殊处理,因此&lt;/&gt;也可以处理相等的情况,</span></span><br><span class="line"><span class="comment">// 但是一旦题目要求处理相等情况, 那么就需要额外拎出判断, 见1025 PAT Ranking</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(rc &amp;a, rc &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.grade != b.grade)</span><br><span class="line">        <span class="keyword">return</span> a.grade&gt;b.grade;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (a.ID&lt;b.ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pat冲冲冲甲级&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pat冲冲冲甲级&quot;&gt;&lt;/a&gt; PAT冲冲冲——甲级&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://nymrli.top/tags/ACM/"/>
    
      <category term="C++" scheme="https://nymrli.top/tags/C/"/>
    
      <category term="Algorithm" scheme="https://nymrli.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记</title>
    <link href="https://nymrli.top/2019/10/18/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2019/10/18/软件测试笔记/</id>
    <published>2019-10-18T13:03:29.000Z</published>
    <updated>2019-11-02T02:05:36.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件测试笔记"><a class="markdownIt-Anchor" href="#软件测试笔记"></a> 软件测试笔记</h1><h2 id="移动应用测试"><a class="markdownIt-Anchor" href="#移动应用测试"></a> 移动应用测试</h2><h3 id="appnium使用"><a class="markdownIt-Anchor" href="#appnium使用"></a> appnium使用</h3><blockquote><p>安装的是appnium-desktop,没有教程中所说的<code>Appium/node_modules/.bin/</code>路径，使用命令行输入<code>appnium</code>和<code>appium-doctor</code>也都没啥反应，后来索性没管，直接跑代码</p></blockquote><h4 id="真机测试"><a class="markdownIt-Anchor" href="#真机测试"></a> 真机测试</h4><p>使用的时候报错<code>Build info: version: 'unknown', revision: 'unknown', time: 'unknown'</code>，以为是appnium版本的问题，第一次安装的是1.13，后来换成了1.9，其实没多大区别，只不过据说要保证版本在1.6以上。</p><p>更换版本后，发现还是<code>Build info: version: 'unknown', revision: 'unknown', time: 'unknown'</code>问题，于是试了多次，才终于解决。</p><p>步骤一：</p><blockquote><p>这边是设置appnium连接参数的</p></blockquote><p>由于群里的高分脚本也是这么设置的，我就以为没多大问题，其实这边还是要修改不少东西的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置自动化相关参数</span></span><br><span class="line">DesiredCapabilities capabilities = <span class="keyword">new</span> DesiredCapabilities();</span><br><span class="line">capabilities.setCapability(<span class="string">"browserName"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">// 确定自己的手机系统是Android、ios的话需要需改</span></span><br><span class="line">capabilities.setCapability(<span class="string">"platformName"</span>, <span class="string">"Android"</span>);</span><br><span class="line"><span class="comment">// 这边要设置成自己的设备uuid，通过adb devices查看</span></span><br><span class="line">capabilities.setCapability(<span class="string">"deviceName"</span>, <span class="string">"Android Emulator"</span>);</span><br><span class="line"><span class="comment">// 这个demo代码会提供好，就不需要自己去找了</span></span><br><span class="line">capabilities.setCapability(<span class="string">"appPackage"</span>, <span class="string">"cn.etouch.ecalendar"</span>);</span><br><span class="line">capabilities.setCapability(<span class="string">"appActivity"</span>, <span class="string">".ECalendar"</span>);</span><br><span class="line">capabilities.setCapability(<span class="string">"noSign"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>appPackage查看包名(可以找到唯一的应用)：<code>adb shell dumpsys activity | find &quot;mFocusedActivity&quot;</code>，需要的结果即<code>cn.etouch.ecalendar</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity | find  "mFocusedActivity"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; mFocusedActivity: ActivityRecord&#123;1510a73 u0 cn.etouch.ecalendar/.MainActivity t2&#125;</span></span><br></pre></td></tr></table></figure><p>activityName查询类名(找到应用上的某个界面)：<code>aapt dump badging &lt;apkPath&gt;</code>然后找到<strong>launchable-activity</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> e.g.</span></span><br><span class="line">E:\android-sdk-windows\build-tools\28.0.3\aapt dump badging C:\mooctest\projects\3399\52660\Zhwnl\apk\Zhwnl.apk | grep launchable-activity</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; launchable-activity: name=<span class="string">'cn.etouch.ecalendar.ECalendar'</span>  label=<span class="string">'中华万年历'</span> icon=<span class="string">''</span></span></span><br></pre></td></tr></table></figure><p>步骤二：</p><blockquote><p>除了代码上设置好连接手机的参数，手机也需要设置电脑能操作手机</p></blockquote><p>需要打开三个选项：“USB调试”、“USB安装”、“USB调试（安全设置）”</p><p>以小米6手机为例:“更多设置”-&gt;“开发者选项”-&gt;“USB调试”、“USB安装”、“USB调试（安全设置）”</p><p>由于之前使用python玩过ADB，所以**“USB调试”、&quot;USB调试（安全设置）&quot;<strong>是开启的，而没打开</strong>USB安装**，所以导致了一直失败。实际上打开USB安装后，会安装几个程序比如Unlock、appnium settings等。<strong>其实报错一开始也提示了，没检测到手机，啥啥安装不上</strong>，只不过当时没留意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; org.openqa.selenium.WebDriverException: An unknown server-side error occurred while processing the command. Original error: Unable to find an active device or emulator with OS 4.1.1. The following are available: cf46749d (8.0.0) (WARNING: The server did not provide any stacktrace information)</span><br><span class="line">Command duration or timeout: 469 milliseconds</span><br><span class="line">Build info: version: &apos;unknown&apos;, revision: &apos;unknown&apos;, time: &apos;unknown&apos;</span><br></pre></td></tr></table></figure><p>▲后来又发现，不设置<strong>platformVersion</strong>、<strong>deviceName</strong>直接设置成<strong>Android Emulator</strong>也行，看来最主要的原因还是<strong>手机第一次使用Appnium之前需要安装写appnium的软件</strong></p><p><img src="/2019/10/18/软件测试笔记/E:%5Chexo%5Csource_posts%5C%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%5Cunicode.png" alt="unicode"></p><p>这个应该就是这两行所安装的东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置使用unicode键盘，支持输入中文和特殊字符</span></span><br><span class="line">capabilities.setCapability(<span class="string">"unicodeKeyboard"</span>,<span class="string">"true"</span>);</span><br><span class="line"><span class="comment">//设置用例执行完成后重置键盘</span></span><br><span class="line">capabilities.setCapability(<span class="string">"resetKeyboard"</span>,<span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><h4 id="夜深模拟器测试"><a class="markdownIt-Anchor" href="#夜深模拟器测试"></a> 夜深模拟器测试</h4><p><strong>1 开启USB调试</strong></p><p>设置-&gt;关于平板电脑-&gt;多次点击&quot;版本号&quot;进入开发者模式-&gt;开发者选项-&gt;打开**“USB调试”<strong>和</strong>&quot;允许模拟位置&quot;**</p><p>2 查看deviceName</p><p>命令行中输入<code>adb devices</code>，如果一直没检测到，解决方案如下（我是需要这么做的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如果在设备连接过程中，确定设备已经开启USB调试且正确连接到PC，但是仍旧使用adb devices指令查到设备列表为空，则有可能是已安装的安卓SDK中的adb程序版本和模拟器自带的adb程序版本不一致导致的。</span><br><span class="line"></span><br><span class="line">解决办法可能有很多种，这里暂介绍楼主亲测实用的方案：</span><br><span class="line"></span><br><span class="line">第一步：关闭正在运行的的模拟器</span><br><span class="line"></span><br><span class="line">第二步：替换adb.exe程序。</span><br><span class="line"></span><br><span class="line">逍遥模拟器：进入安装目录（默认为..\Microvirt\MEmu），找到adb.exe文件，执行删除。然后进入SDK的安装目录（默认为..\android-sdk-windows\platform-tools），拷贝系统adb.exe到逍遥的原目录即可。</span><br><span class="line"></span><br><span class="line">夜神模拟器：进入安装目录，找到nox_adb.exe文件，执行删除。然后进入SDK的安装目录（默认为..\android-sdk-windows\platform-tools），拷贝系统adb.exe到逍遥的原目录，重命名为“nox_adb.exe”即可。</span><br><span class="line"></span><br><span class="line">第三步：启动模拟器。启动完毕后，打开cmd命令窗口输入 adb devices 再次检查设备连接情况，一般就能正常看到已连接的虚拟设备信息了。</span><br></pre></td></tr></table></figure><p>运行代码main.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置自动化相关参数</span></span><br><span class="line">DesiredCapabilities capabilities = <span class="keyword">new</span> DesiredCapabilities();</span><br><span class="line">capabilities.setCapability(<span class="string">"browserName"</span>, <span class="string">""</span>);</span><br><span class="line">capabilities.setCapability(<span class="string">"platformName"</span>, <span class="string">"Android"</span>);</span><br><span class="line"><span class="comment">//        capabilities.setCapability("platformVersion", "8.0.0");</span></span><br><span class="line">capabilities.setCapability(<span class="string">"deviceName"</span>, <span class="string">"127.0.0.1:62001"</span>);</span><br><span class="line">capabilities.setCapability(<span class="string">"appPackage"</span>, <span class="string">"cn.etouch.ecalendar"</span>);</span><br><span class="line">capabilities.setCapability(<span class="string">"appActivity"</span>, <span class="string">".ECalendar"</span>);</span><br><span class="line">capabilities.setCapability(<span class="string">"noSign"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>然后运行测试代码就能看到这样的画面了</p><p><img src="/2019/10/18/软件测试笔记/E:%5Chexo%5Csource_posts%5C%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%5C%E5%A4%9C%E7%A5%9E%E6%A8%A1%E6%8B%9F%E5%99%A8.jpg" alt="夜神模拟器"></p><h5 id="进入元素审查"><a class="markdownIt-Anchor" href="#进入元素审查"></a> 进入元素审查</h5><p><img src="/2019/10/18/软件测试笔记/E:%5Chexo%5Csource_posts%5C%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%5C%E5%85%83%E7%B4%A0%E5%AE%A1%E6%9F%A5.jpg" alt="元素审查"></p><p><a href="https://www.cnblogs.com/amoyshmily/p/10500687.html" target="_blank" rel="noopener">安装教程</a>，我是安装软件测试大赛提供的教程安装下来的，只不过感觉这篇可能将的更好一点。（ appium-doctor 是需要额外用npm安装的，而不是像比赛教程中写的那样）</p><h5 id="踩坑记录"><a class="markdownIt-Anchor" href="#踩坑记录"></a> 踩坑记录：</h5><p>出现报错<code>UiAutomator exited unexpectedly with code 0, signal null</code></p><p><img src="https://img-blog.csdnimg.cn/20181130102850624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzExNTY4,size_16,color_FFFFFF,t_70" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> adb shell</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /data/<span class="built_in">local</span>/tmp （如果一次性进不去，可以分层一层层进入）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、进入data/<span class="built_in">local</span>/tmp 后ls查看全部目录，应该有一个 AppiumBootstrap.jar，可能你的名字是 AppiumBoots 或者 AppiumBootstrap.jar。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、将andriod sdk下的AppiumBootstrap.jar发送上去</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adb push C:\Users\10630\AppData\Local\Programs\Appium\resources\app\node_modules\appium\node_modules\appium-android-driver\bootstrap\bin\AppiumBootstrap.jar /data/<span class="built_in">local</span>/tmp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、ok，大功告成</span></span><br></pre></td></tr></table></figure><h6 id="adb-unauthorized"><a class="markdownIt-Anchor" href="#adb-unauthorized"></a> adb unauthorized</h6><p>1.使用adb连接手机时，即使打开了usb调试，<strong>手机添加了信任</strong>，仍然出现unauthorized的提示</p><p>2.<code>C:\Users\(Username)\.android</code>里面删掉adbkey和adbkey.pub两个文件(没添加过信任的话是没有的)，然后重新插拔手机</p><p>执行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb kill-server</span><br><span class="line">adb <span class="built_in">start</span>-server</span><br></pre></td></tr></table></figure><p>△如果上述方式还是无效的话，选择“开发者测试”-&gt;&quot;调试&quot;中的撤销USB调试授权，然后重新上述操作</p><h3 id="特殊元素定位之获取toast"><a class="markdownIt-Anchor" href="#特殊元素定位之获取toast"></a> 特殊元素定位之获取toast</h3><ul><li>java-client版本必须满足5.0+</li><li>desiredCapabilities中指定automationName为：UIAutomator2</li><li>UIAutomator2只支持安卓版本5.0+</li><li><code>getElement(By.xpath(&quot;//*[contains(@text,'tips')]&quot;));</code></li></ul><h3 id="monkey使用"><a class="markdownIt-Anchor" href="#monkey使用"></a> Monkey使用</h3><blockquote><p>脚本优势：简单、快捷、不需要借助任何工具，可以做简单的性能测试<br>脚本缺点：只能简单实现坐标、按键等基本操作（根据像素点来进行操作）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#头文件、控制monkey发送消息的参数</span><br><span class="line">type=raw events</span><br><span class="line">count=10</span><br><span class="line">speed=1.0</span><br><span class="line">#以下monkey命令</span><br><span class="line">start data&gt;&gt; </span><br><span class="line"># 开启柠檬杯app</span><br><span class="line">LaunchActivity（com.lemon.lemonban，com.lemon.lemonban.activity.WelcomeActivity）</span><br><span class="line">#让脚本暂停运行4S UserWait（4000）</span><br><span class="line">#点击我的柠檬元素</span><br><span class="line">Tap（600，1220）</span><br><span class="line">#点击我的头像登录</span><br><span class="line">#让脚本暂停运行1S UserWait（1000）</span><br><span class="line">Tap（300，200）</span><br><span class="line">#让脚本暂停运行1s UserWait（2000）</span><br><span class="line">#输入手机号码</span><br><span class="line">DispatchString（18588220110）</span><br><span class="line">#点击密码输入框</span><br><span class="line">Tap（200，650）</span><br><span class="line">#输入密码</span><br><span class="line">DispatchString（123456）</span><br><span class="line">#点击登录按钮</span><br><span class="line">Tap（320，800）</span><br><span class="line">UserWait（3000）</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 上传monkey脚本</span><br><span class="line">adb push monkeyScript.txt /sdcard/</span><br><span class="line"># 运行monkey脚本</span><br><span class="line">adb shell monkey -f /sdcard/monkeyScript.txt</span><br></pre></td></tr></table></figure><h3 id="uiautomatorviewer使用"><a class="markdownIt-Anchor" href="#uiautomatorviewer使用"></a> uiautomatorviewer使用</h3><blockquote><p>位置E:\android-sdk-windows\tools</p></blockquote><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"></span><br><span class="line">adb shell uiautomator dump /sdcard/app.uix</span><br><span class="line">adb pull /sdcard/app.uix .</span><br><span class="line"></span><br><span class="line">adb shell screencap -p /sdcard/app.png</span><br><span class="line">adb pull /sdcard/app.png .</span><br></pre></td></tr></table></figure><p>采坑记录:</p><blockquote><p>小米手机有点坑啊，进行Android开发时需要设置挺多东西的。</p></blockquote><ol><li><strong>关闭MIUI优化</strong>不然没法调试</li><li>如果进行uiautomatorviewer调试的话，必须还要把悬浮球给关了，不然没法获取界面。</li></ol><p>TouchAction</p><ol><li><p>点击操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// press</span></span><br><span class="line">TouchAction ta=<span class="keyword">new</span> TouchAction(driver);<span class="comment">//创建一个TouchAction对象</span></span><br><span class="line">ta.press(element).release().perform();<span class="comment">//按一个元素</span></span><br><span class="line">ta.press(<span class="number">500</span>, <span class="number">450</span>).release().perform();<span class="comment">//按一个坐标点</span></span><br><span class="line"><span class="comment">//按一个元素上的某个点，从左上角偏移100</span></span><br><span class="line">ta.press(element,<span class="number">100</span>,<span class="number">100</span>).release().perform();</span><br><span class="line"></span><br><span class="line"><span class="comment">// tap</span></span><br><span class="line">ta.tap(element).release().perform();<span class="comment">//点一个元素</span></span><br><span class="line">ta.tap(<span class="number">300</span>, <span class="number">500</span>).release().perform();<span class="comment">//点一个坐标点</span></span><br><span class="line"><span class="comment">//按一个元素的某个点，从左上角偏移100</span></span><br><span class="line">ta.tap(element, <span class="number">100</span>, <span class="number">100</span>).release().perform();</span><br></pre></td></tr></table></figure></li><li><p>长按操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// longPress</span></span><br><span class="line">TouchAction ta=<span class="keyword">new</span> TouchAction(driver);<span class="comment">//创建一个TouchAction对象</span></span><br><span class="line">ta.longPress(element).release().perform();<span class="comment">//长按某个元素</span></span><br><span class="line">ta.longPress(element, <span class="number">5000</span>).release().perform();<span class="comment">//长按某个元素，时间是5秒</span></span><br><span class="line">ta.longPress(<span class="number">300</span>, <span class="number">500</span>).release().perform();<span class="comment">//长按某个坐标点</span></span><br><span class="line">ta.longPress(<span class="number">300</span>, <span class="number">500</span>, <span class="number">3000</span>).release().perform();<span class="comment">//长按某个坐标点，时间是5秒</span></span><br><span class="line"><span class="comment">//长按某元素上的某个点，从左上角偏移100</span></span><br><span class="line">ta.longPress(element, <span class="number">100</span>, <span class="number">100</span>).release().perform();</span><br><span class="line"><span class="comment">//长按某元素上的某个点，从左上角偏移100，时间是3秒</span></span><br><span class="line">ta.longPress(element, <span class="number">100</span>, <span class="number">100</span>, <span class="number">3000</span>).release().perform();</span><br></pre></td></tr></table></figure></li><li><p>组合操作–拖拽</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// press + moveTo</span></span><br><span class="line">TouchAction ta=<span class="keyword">new</span> TouchAction(driver);<span class="comment">//创建一个TouchAction对象</span></span><br><span class="line">ta.press(element1).moveTo(element2).release().perform();<span class="comment">//两个元素互换位置</span></span><br><span class="line"><span class="comment">//将元素拖拽到另外一个位置，moveTo中的是相对偏移量</span></span><br><span class="line">ta.press(element1).waitAction(<span class="number">500</span>).moveTo(<span class="number">0</span>,<span class="number">200</span>).waitAction(<span class="number">500</span>).release().perform();</span><br></pre></td></tr></table></figure></li><li><p>连续滑动手势（可用于手势解锁）</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// press + moveTo</span></span><br><span class="line">TouchAction ta=<span class="keyword">new</span> TouchAction(driver);<span class="comment">//创建一个TouchAction对象</span></span><br><span class="line"><span class="comment">//从第一个点一直滑动到第四个点</span></span><br><span class="line">ta.press(<span class="number">200</span>, <span class="number">200</span>).moveTo(<span class="number">0</span>, <span class="number">100</span>).moveTo(<span class="number">100</span>, <span class="number">0</span>).moveTo(<span class="number">100</span>, <span class="number">100</span>).release().perform();</span><br><span class="line"><span class="comment">//从第一个元素一直滑动到第四元素</span></span><br><span class="line">ta.press(element1).moveTo(element2).moveTo(element3).moveTo(element4).release().perform()</span><br><span class="line"><span class="comment">// swipe</span></span><br><span class="line">driver.swipe(width * <span class="number">3</span> / <span class="number">4</span>, height / <span class="number">2</span>, width / <span class="number">4</span>, height / <span class="number">2</span>, during);</span><br></pre></td></tr></table></figure><ol start="5"><li>其他 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 0% 到 100% 内双指缩放屏幕 </span></span><br><span class="line">driver.pinch(element=el)</span><br><span class="line"><span class="comment">//放大屏幕 在 100% 以上放大屏幕 </span></span><br><span class="line">driver.zoom(element=el)</span><br></pre></td></tr></table></figure></li></ol><p><a href="http://www.mamicode.com/info-detail-2390132.html" target="_blank" rel="noopener">appnium定位+操作方式(python)——老版本</a></p><p>▲Appium java-client库更新到6.x后，滑动 swipe() 已弃用，且TouchAction类中很多方法也有改变。</p><ul><li>（ 总的来看，弃用的是 press() longPress() moveTo() tap() 参数使用 x、y轴和webElement 的这种类型，和用到Duration类型的方法 ）</li><li>取而代之的是参数类型变了，涉及到XY轴定位的方法，参数使用了<strong>PointOption.point(X坐标, Y坐标)</strong>；涉及到Duration的方法waitAction()，参数使用了WaitOptions.waitOptions(Duration.ofNanos(时间间隔))</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java-client 4.x 滑动 swipe() 案例：</span></span><br><span class="line">driver.swipe(width * <span class="number">3</span> / <span class="number">4</span>, height / <span class="number">2</span>, width / <span class="number">4</span>, height / <span class="number">2</span>, during); </span><br><span class="line"></span><br><span class="line"><span class="comment">//java-client 6.x 滑动案例：</span></span><br><span class="line"><span class="keyword">int</span> nanos=(<span class="keyword">int</span>) (second*<span class="number">1000</span>); </span><br><span class="line">TouchAction action = <span class="keyword">new</span> TouchAction(driver).press(PointOption.point(width* <span class="number">3</span>/<span class="number">4</span>,height/<span class="number">2</span>)).waitAction(WaitOptions.waitOptions(Duration.ofNanos(nanos))).moveTo(PointOption.point(width/<span class="number">4</span>, height/<span class="number">2</span>)).release().perform();</span><br></pre></td></tr></table></figure><p><a href="https://discuss.appium.io/t/some-of-the-methods-from-mobileelement-and-appiumdriver-class-missing-in-5-0-4/19039" target="_blank" rel="noopener"> java-client  5.0.4后被移除的函数</a></p><h3 id="众测的思路"><a class="markdownIt-Anchor" href="#众测的思路"></a> 众测的思路：</h3><ul><li>常见输入框的输入范围、限制<ul><li>手机号11位、验证码6位、敏感信息、特殊字符</li></ul></li><li>toast提示框是否正确</li><li>控件是否有错别字</li></ul><h3 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录：</h3><h4 id="众包测试报告评分规则"><a class="markdownIt-Anchor" href="#众包测试报告评分规则"></a> 众包测试报告评分规则</h4><p>1、众包测试得分=bug报告得分（包括单一状bug报告、fork的bug报告）<br>+评审得分（点赞，点踩）<br>2、每个Bug报告满分10分，Bug报告基础分1-5分，选手提交的Bug等级仅供参考，以评审人员判定为准；<br>3、Bug描述简洁清晰、<strong>复现步骤连贯</strong>、<strong>按序号排序</strong>，评审人员可根据其描述顺利的进行操作并复现Bug，附加3分。<br>4、Bug截图相关则附加1分，截图上使用红框标注Bug位置则附加1分；<br>5、点赞点踩得分规则：即为<strong>正确的bug报告点赞</strong>，<strong>错误的bug报告点踩</strong>可得分；反之扣分。<br>6、若两人提交bug报告相同，依据时间优先原则，后提交的报告计低分，所以若发现的bug已被他人提交，建议Fork（复制并补充修改）或对bug报告进行评审（点赞，点踩）。</p><h2 id="开发者测试"><a class="markdownIt-Anchor" href="#开发者测试"></a> 开发者测试</h2><p><strong>语句覆盖</strong>： 保证程序中的每一个语句至少被执行一次。 被认为是“最弱的覆盖”</p><blockquote><p>语句覆盖率：被执行语句的比例</p></blockquote><p><strong>判定覆盖(分支覆盖)</strong>：CFG (control Flow Graph控制流图 )所有的边都被访问/所有的分支都被访问</p><p>▲针对判断语句，在设定案例的时候，要设定True和False的两种案例；与语句覆盖不同的是增加了False的情况</p><blockquote><p>分支覆盖率：被访问的分支的比例</p></blockquote><p><strong>条件覆盖</strong></p><p>针对判断语句里面案例的取值都要去一次，不考虑条件的取值。</p><blockquote><p>每个小判断分别为真，其他为假的情况</p></blockquote><p><strong>判定/条件覆盖</strong></p><p>判定覆盖各条件覆盖交叉，针对于判定中的条件取值  、</p><blockquote><p>每个判定真假各一次(判定覆盖)<br>每个判定中的条件各取一次(条件覆盖)</p></blockquote><p><strong>组合覆盖</strong></p><p>判定-条件覆盖的加强版</p><blockquote><p>判定中所有可能的条件组合</p></blockquote><p><strong>路径覆盖</strong></p><p>走完所有可能的路径</p><p><a href="https://blog.csdn.net/qq_38712932/article/details/83818589" target="_blank" rel="noopener">语句覆盖、条件覆盖（分支覆盖）、判定覆盖、条件-判定覆盖、组合覆盖、路径覆盖 </a></p><h2 id="输入域上的测试"><a class="markdownIt-Anchor" href="#输入域上的测试"></a> 输入域上的测试</h2><p>–随机测试</p><p>–等价类划分</p><p>–边界值分析</p><ul><li>最小值(min)</li><li>略大于最小值(min+)</li><li>输入值域内的任意值(nom)</li><li>略小于最大值(max-)</li><li>最大值(max)</li></ul><h2 id="input-domain-based-techniquescontinue"><a class="markdownIt-Anchor" href="#input-domain-based-techniquescontinue"></a> Input Domain-Based Techniques(continue)</h2><p>•Random Testing</p><p>•Combinatorial Testing</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件测试笔记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#软件测试笔记&quot;&gt;&lt;/a&gt; 软件测试笔记&lt;/h1&gt;
&lt;h2 id=&quot;移动应用测试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#移动应用测试&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Java" scheme="https://nymrli.top/tags/Java/"/>
    
      <category term="软件测试" scheme="https://nymrli.top/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>玩玩Stm32</title>
    <link href="https://nymrli.top/2019/10/15/%E7%8E%A9%E7%8E%A9Stm32/"/>
    <id>https://nymrli.top/2019/10/15/玩玩Stm32/</id>
    <published>2019-10-15T08:33:09.000Z</published>
    <updated>2019-10-18T08:56:46.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="玩玩stm32"><a class="markdownIt-Anchor" href="#玩玩stm32"></a> 玩玩Stm32</h1><h2 id="文件结构"><a class="markdownIt-Anchor" href="#文件结构"></a> 文件结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">G:.</span><br><span class="line">├───CORE<span class="comment"># startup_stm32f10x_hd.s汇编编写的启动文件</span></span><br><span class="line">|<span class="comment"># core_cm3.c底层函数</span></span><br><span class="line">├───HARDWARE<span class="comment"># 相关外设的初始化代码</span></span><br><span class="line">├───OBJ</span><br><span class="line">├───STM32F10x_FWLib<span class="comment"># 固件库包: GPIO/i2c/...</span></span><br><span class="line">│   ├───inc</span><br><span class="line">│   └───src</span><br><span class="line">├───SYSTEM<span class="comment"># 正点原子提供的常用、通用模块</span></span><br><span class="line">│   ├───delay</span><br><span class="line">│   ├───sys</span><br><span class="line">│   └───usart</span><br><span class="line">└───USER <span class="comment"># stm32f10x_it.c 中断管理文件</span></span><br><span class="line">    | <span class="comment"># stm32f10x.h </span></span><br><span class="line">    ├───Listings</span><br><span class="line">    └───Objects</span><br></pre></td></tr></table></figure><h3 id="编写规范"><a class="markdownIt-Anchor" href="#编写规范"></a> 编写规范：</h3><p>用户编写的执行代码写在main.c中,其中<code>#include &quot;stm32f10x.h&quot;</code>作用相当于C51的<code>#include &lt;reg51.h&gt;</code>，是操作寄存器的主要固件库文件,在任何地方引用到固件库函数时都需要导入这个文件。</p><p><code>stm32f10x_it.c、stm32f10x_it.h</code>, 专门存放中断服务函数的C文件 ,大多中断函数都 写在此文件中,方便 管理中断函数,但并不是一定要写在这里面。</p><h2 id="gpio"><a class="markdownIt-Anchor" href="#gpio"></a> GPIO</h2><p>◆端口复用功能<br>STM32的大部分端口都具有复用功能。<br>所谓复用,就是一些端口<em>不仅仅</em>可以做为通用lO口,还可以<em>复用</em>为一些外设引脚,比如PA9,PA10可以复用为STM32的<strong>串口</strong>1引脚。<br>▲作用：最大限度的利用端口资源</p><p>◆端口重映射功能<br>就是可以把某些功能引脚映射到其他引脚。<br>比如串口1默认引脚是PA9,PA10可以通过配置重映射映射到PB6,PB7<br>作用：为了方便布线</p><p>▲所有I0口都可以作为中断输入</p><h3 id="工作模式"><a class="markdownIt-Anchor" href="#工作模式"></a> 工作模式：</h3><ul><li>推挽输出：可以输出强高低电平</li><li>上拉输入: 一端是接地低电平,所以<strong>默认情况</strong>下另一端需要检测到<strong>高电平</strong>(按键扫描中,三个引脚需要设置为IPU,按下时&lt;==&gt;输入口检测到低电平)</li><li>下拉输入：(按下时&lt;==&gt;输入口检测到低电平)</li></ul><h3 id="gpio重要函数"><a class="markdownIt-Anchor" href="#gpio重要函数"></a> GPIO重要函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1个初始化函数：</span></span><br><span class="line">void GPIO_Init(GPIO_TypeDef* GPIOx,GPIO_InitTypeDef* GPIO_InitStruct)；</span><br><span class="line"><span class="comment">//2个读取输入电平函数：</span></span><br><span class="line">uint8t GPIO_ReadlinputDataBit(GPIO TypeDef* GPIOx,uint16_t GPIO_Pin)；</span><br><span class="line"><span class="keyword">uint16_t</span> GPIO_ReadinputData(GPIO_TypeDef* GPIOx)；</span><br><span class="line"><span class="comment">//2个读取输出电平函数：</span></span><br><span class="line">uint8t GPIO_ReadOutputDataBit(GPiO_TypeDef* GPiOx,uint16_t GPIO_Pin)；</span><br><span class="line">uint16t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)；</span><br><span class="line"><span class="comment">//4个设置输出电平函数：前两个常用,后两个不常用</span></span><br><span class="line">void GPIO_SetBits(GPIOTypeDef* GPIOx, uint16_t GPIOPin)；</span><br><span class="line">void GP1O_ResetBits(GPIOTypeDef GPIOx,uint16_t GPIOPin)；</span><br><span class="line">void GPIO_WriteBit(GPIOTypeDef* GPIOx,uint16_t GPIO_Pin,BitAction BitVal)；</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Write</span><span class="params">(GPIOTypeDef* GPIOx, <span class="keyword">uint16_t</span> PortVal)</span></span></span><br></pre></td></tr></table></figure><h4 id="具体说明"><a class="markdownIt-Anchor" href="#具体说明"></a> 具体说明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">GPIO_TypeDef为GPIO寄存器组合的类型</span></span></span><br><span class="line"><span class="function"><span class="comment">typedef struct&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t CRL;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t CRH;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t IDR;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t ODR;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t BSRR;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t BRR;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t LCKR;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125; GPIO_TypeDef;</span></span></span><br><span class="line"><span class="function"><span class="comment">GPIOx的选择可以为GPIOA-&gt;GPIOG</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">typedef struct&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  uint16_t GPIO_Pin;           </span></span></span><br><span class="line"><span class="function"><span class="comment">  GPIOSpeed_TypeDef GPIO_Speed; </span></span></span><br><span class="line"><span class="function"><span class="comment">  GPIOMode_TypeDef GPIO_Mode;    </span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;GPIO_InitTypeDef;</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure><p>初始化示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明结构体变量</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure；</span><br><span class="line"><span class="comment">//LEDO--&gt;PB.5端口配置</span></span><br><span class="line">GPIO InitStructure.GPIO Pin =GPIO_Pin_5；</span><br><span class="line"><span class="comment">//推挽输出</span></span><br><span class="line">GPIO InitStructure.GPIO Mode=GPIO_Mode_Out_PP；</span><br><span class="line"><span class="comment">//IO口速度为50MHz</span></span><br><span class="line">GPIO InitStructure.GPIO Speed=GPIO_Speed_50MHz；</span><br><span class="line"><span class="comment">//根据设定参数初始化GPIOB.5</span></span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure><p>▲在使用GPIO前,需要使能IO口时钟,调用函数<code>RCC_APB2PeriphColckCmd();</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="keyword">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*RCC_APB2Periph 可以为</span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_AFIO  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOA </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOB </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOC </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOD </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOE </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOF </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOG </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_ADC1  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_ADC2  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM1  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_SPI1  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM8  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_USART1 </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_ADC3  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM15 </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM16 </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM17 </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM9  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM10 </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM11 </span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">NewState 为ENABLE / DISABLE</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure><p>提示：不能通过IO口直接驱动大功率器件。</p><p>△复位之后，IO口默认为浮空状态，如果不接下拉电阻，那么电平不确定为高还是低电平。(到是小电流的时候，电流会直接通过下拉电阻到地，不会经过三极管；只有电流足够大，才会经过三极管)</p><h3 id="demo-跑马灯实验"><a class="markdownIt-Anchor" href="#demo-跑马灯实验"></a> demo : 跑马灯实验</h3><p><img src="/2019/10/15/玩玩Stm32/%E8%B7%91%E9%A9%AC%E7%81%AF.jpg" alt="跑马灯"></p><p>当将PE5设置为低电平时,通过上拉电阻连到VCC后,LED就能点亮。PE5被设置为高电平时与上拉高电平之间没有压差,此时LED熄灭。</p><h4 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码:</h4><p>led.c文件内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span> </span></span><br><span class="line"><span class="comment">// 在任何地方引用到固件库时都需要导入这个文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOE,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_Init(GPIOE,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为高电平,熄灭</span></span><br><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c文件内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> delay_init();</span><br><span class="line"> LED_Init();</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">         GPIO_SetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">         delay_ms(<span class="number">500</span>);</span><br><span class="line">      GPIO_ResetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">      GPIO_ResetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">         delay_ms(<span class="number">500</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="操作io口的三种方式"><a class="markdownIt-Anchor" href="#操作io口的三种方式"></a> 操作IO口的三种方式：</h3><ul><li>位操作：<code>#define BEEP PBout(8);</code>后<code>BEEP = 1</code></li><li>库函数：<code>GPIO_SetBits(GPIOB, GPIO_Pin_8);</code></li><li>寄存器：</li></ul><h2 id="中断管理"><a class="markdownIt-Anchor" href="#中断管理"></a> 中断管理</h2><blockquote><p>对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。IP bit决定了对每个中断共有2^4(位) = 16级的中断优先级设置</p></blockquote><p><img src="/2019/10/15/玩玩Stm32/%E4%B8%AD%E6%96%AD%E5%88%86%E7%BB%84.jpg" alt="中断分组"></p><ul><li>高优先级的抢占优先级是可以<strong>打断</strong>正在进行的低抢占优先级中断的。</li><li>抢占优先级相同的中断，高响应优先级<strong>不可以打断</strong>低响应优先级的中断。</li><li>抢占优先级相同的中断，当两个中断<strong>同时发生</strong>的情况下，哪个响应优先级高，哪个先执行。</li><li>如果两个中断的抢占优先级和响应优先级<strong>都是一样</strong>的话，则看哪个中断先发生就先执行；</li></ul><p>总结：中断嵌套执行看抢占优先级；占优先级相同时,响应优先级高的先响应；两者都一样的话，执行顺序看发生的时间</p><p>△.优先级0最高，4最低。</p><p>▲.系统代码执行过程中，只设置一次中断优先，一般不会再改变分组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断优先级分组函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_PriorityGroupConfig</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_PriorityGroup)</span></span></span><br><span class="line"><span class="function"><span class="comment">// demo: NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 对某个中断设置优先级</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_Init</span><span class="params">(NVIC_InitTypeDef* NVIC_InitStruct)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">typedef struct&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  uint8_t NVIC_IRQChannel;                    </span></span></span><br><span class="line"><span class="function"><span class="comment">  uint8_t NVIC_IRQChannelPreemptionPriority;  </span></span></span><br><span class="line"><span class="function"><span class="comment">  uint8_t NVIC_IRQChannelSubPriority;         </span></span></span><br><span class="line"><span class="function"><span class="comment">  FunctionalState NVIC_IRQChannelCmd;         </span></span></span><br><span class="line"><span class="function"><span class="comment">&#125; NVIC_InitTypeDef;</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure><blockquote><p>中断优先级控制的寄存器组：IP[240]对每个中断进行管理,STM32F10x系列一共有60个可屏蔽中断。全称是：Interrupt Priority Registers</p></blockquote><h3 id="中断优先级设置步骤"><a class="markdownIt-Anchor" href="#中断优先级设置步骤"></a> 中断优先级设置步骤</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①统运行后先设置中断优先级分组。调用函数：//整个系统执行过程中，只设置一次中断分组。</span></span><br><span class="line">void NVIC_Priority_GroupConfig(uint32_t NVIC_PriorityGroup)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//②针对每个中断，设置对应的抢占优先级和响应优先级：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> NVIC <span class="title">Init</span><span class="params">(NVIC_InitTypeDef* NVIC_Initstructy；</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* demo:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">NVIC_InitStructure.NVIC_IRQChannel=EXTI3_IRQn://使能按键KEY1所在的外部中断通道</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0x02：//抢占优先级2</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">NVIC_InitStructure.NVIC_IRQChannelSubPriority =0x01：</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">∥字优先级1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">NVIC_InitStructure.NVIC_IRQChannelCmd =ENABLE://使能外部中断通道</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">NWIC_Init(&amp;WIC_Init Structure)：/根据NIC_InitStruct中指定的参数初始化外设NVIC寄存器</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">*/</span></span></span></span><br><span class="line"><span class="function"><span class="params">               </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//③如果需要挂起/解挂，查看中断当前激活状态，分别调用相关函数即可。</span></span></span></span><br></pre></td></tr></table></figure><h2 id="串口通信"><a class="markdownIt-Anchor" href="#串口通信"></a> 串口通信</h2><blockquote><p>异步: 跟系统时钟无关</p><p>同步: 跟系统时钟有关</p></blockquote><p>波特率计算方法:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">x</mi></mrow><mi mathvariant="normal">/</mi><mrow><mi mathvariant="normal">R</mi><mi mathvariant="normal">x</mi></mrow><mspace width="1em"><mi>B</mi><mi>a</mi><mi>u</mi><mi>d</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>=</mo><mfrac><msub><mi>f</mi><mrow><mi>P</mi><mi>C</mi><mi>L</mi><mi>K</mi><mi>x</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mn>16</mn><mo>∗</mo><mi>U</mi><mi>S</mi><mi>A</mi><mi>R</mi><mi>T</mi><mi>D</mi><mi>I</mi><mi>V</mi><mo stretchy="false">)</mo></mrow></mfrac></mspace></mrow><annotation encoding="application/x-tex">\mathrm{Tx} / \mathrm{Rx} \quad Baud rate=\frac{f_{P C L K x}}{(16 * U S A R T D I V)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">x</span></span><span class="mord">/</span><span class="mord"><span class="mord mathrm">R</span><span class="mord mathrm">x</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">a</span><span class="mord mathdefault">u</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.452216em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mord mtight">6</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.10764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><h3 id="baud_rate配置的一般步骤"><a class="markdownIt-Anchor" href="#baud_rate配置的一般步骤"></a> <img src="/2019/10/15/玩玩Stm32/baud_rate.jpg" alt="baud_rate">配置的一般步骤:</h3><p><img src="/2019/10/15/玩玩Stm32/E:%5Chexo%5Csource_posts%5C%E7%8E%A9%E7%8E%A9Stm32%5C%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4.jpg" alt="串口配置的一般步骤"></p><ol><li>串口作为外设，需要使能:<code>RCC_APB2PeriphClockCmdO;</code>、以及使能GPIO的时钟</li><li>GPIO端口模式设置<code>GPIOInit0;</code>，模式设置为<code>GPIO_Mode_AFPP</code>复用推挽(PA.9/10复用为串口1)</li><li>串口参数初始化</li><li>使能串口USART Cma);</li><li>串口数据收发</li></ol><p>▲ <strong>UART串口<a href="http://bbs.elecfans.com/zhuti_wireless_1.html" target="_blank" rel="noopener">通信</a>只需连接TX，RX，GND</strong> ， <strong>一般不需要连接VCC</strong></p><blockquote><p>A：TX、RX是正负压的，所以有个地做参考就行了</p><p>A： 通信两端一般都有各自的供电电压，所以不需要VCC，只有一端没有电源的情况下才会用VCC向对方输送电源</p><p>A：就像像耳机只要联地、音频左、音频右，而不联vcc一个道理</p></blockquote><h3 id="正点原子提供的usart库"><a class="markdownIt-Anchor" href="#正点原子提供的usart库"></a> <strong>正点原子提供的USART库：</strong></h3><blockquote><p>以回车换行结束的协议</p></blockquote><p>usart.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART_REC_LEN  200  <span class="comment">//定义最大接收字节数 200</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EN_USART1_RX 1<span class="comment">//使能（1）/禁止（0）串口1接收</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">extern</span> u8  USART_RX_BUF[USART_REC_LEN]; <span class="comment">//接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 </span></span><br><span class="line"><span class="keyword">extern</span> u16 USART_RX_STA;         <span class="comment">//接收状态标记</span></span><br><span class="line"><span class="comment">//如果想串口中断接收，请不要注释以下宏定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(u32 bound)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/玩玩Stm32/E:%5Chexo%5Csource_posts%5C%E7%8E%A9%E7%8E%A9Stm32%5CUSART_RX_STA.jpg" alt="USART_RX_STA"></p><p>数据全保存在USART_RX_BUF中。根据STA的有效数据个数比如50个，将USART_RX_BUF中前50个数据拿出处理。处理完所有标志位将被清零</p><p>▲程序要求，发送的字符是以回车换行结束(Ox0D,0x0A)。</p><p>△串口调试助手里勾选&quot;发送新行&quot;选项</p><p>usart.c 程序理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span>                <span class="comment">//串口1中断服务程序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 Res;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYSTEM_SUPPORT_OS <span class="comment">//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.</span></span></span><br><span class="line">OSIntEnter();    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  <span class="comment">//接收中断(接收到的数据必须是0x0d 0x0a结尾)</span></span><br><span class="line">&#123;</span><br><span class="line">Res =USART_ReceiveData(USART1);<span class="comment">//读取接收到的数据(单个字符)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((USART_RX_STA&amp;<span class="number">0x8000</span>)==<span class="number">0</span>)<span class="comment">//没收到\n,即接收未完成</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x4000</span>)<span class="comment">//接收到了0x0d(\r)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Res!=<span class="number">0x0a</span>)USART_RX_STA=<span class="number">0</span>;<span class="comment">//如果下一个不是\n,那么接收错误,重新开始</span></span><br><span class="line"><span class="keyword">else</span> USART_RX_STA|=<span class="number">0x8000</span>;<span class="comment">//如果接受到\n,则接收完成,将USART_RX_STA bit15置1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//还没收到0X0D,即处理真正数据</span></span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">// 如果当前接收到\r,那么将Bit14置1</span></span><br><span class="line"><span class="keyword">if</span>(Res==<span class="number">0x0d</span>)USART_RX_STA|=<span class="number">0x4000</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">                    <span class="comment">// 将当前收到的字符Res存到数组USART_RX_BUF保存</span></span><br><span class="line">USART_RX_BUF[USART_RX_STA&amp;<span class="number">0X3FFF</span>]=Res ;</span><br><span class="line">                    <span class="comment">// 索引+1</span></span><br><span class="line">USART_RX_STA++;</span><br><span class="line">                    <span class="comment">// 如果数据超额,那么判断为接收错误</span></span><br><span class="line"><span class="keyword">if</span>(USART_RX_STA&gt;(USART_REC_LEN<span class="number">-1</span>))USART_RX_STA=<span class="number">0</span>;<span class="comment">//接收数据错误,重新开始接收  </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br><span class="line">     &#125; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYSTEM_SUPPORT_OS <span class="comment">//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.</span></span></span><br><span class="line">OSIntExit();   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Res =USART_ReceiveData(USART1);</code>获得的是当前接收的字符，如果使用中断，那么调用<code>USART_SendData(USART1, Res)</code>就能接收一个字符，发送一个字符。</li><li>USART_RX_BUF的作用是，保存一次字符串发送过来的所有数据</li><li>USART_RX_STA是个寄存器，通过Bit14，Bit15来判断接收是否有效</li></ul><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> u16 t;  </span><br><span class="line">u16 len;</span><br><span class="line">u16 times=<span class="number">0</span>;</span><br><span class="line">delay_init();     <span class="comment">//延时函数初始化  </span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="comment">//设置NVIC中断分组2:2位抢占优先级，2位响应优先级</span></span><br><span class="line">uart_init(<span class="number">115200</span>); <span class="comment">//串口初始化为115200</span></span><br><span class="line"> LED_Init();     <span class="comment">//LED端口初始化</span></span><br><span class="line">KEY_Init();          <span class="comment">//初始化与按键连接的硬件接口</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x8000</span>)&#123;   </span><br><span class="line">len=USART_RX_STA&amp;<span class="number">0x3fff</span>;<span class="comment">//得到此次接收到的数据长度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\r\n您发送的消息为:\r\n\r\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)&#123;</span><br><span class="line">USART_SendData(USART1, USART_RX_BUF[t]);<span class="comment">//向串口1发送数据</span></span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);<span class="comment">//等待发送结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\r\n\r\n"</span>);<span class="comment">//插入换行</span></span><br><span class="line">USART_RX_STA=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">times++;</span><br><span class="line"><span class="keyword">if</span>(times%<span class="number">5000</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\r\n战舰STM32开发板 串口实验\r\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"正点原子@ALIENTEK\r\n\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(times%<span class="number">200</span>==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"请输入数据,以回车键结束\n"</span>);  </span><br><span class="line"><span class="keyword">if</span>(times%<span class="number">30</span>==<span class="number">0</span>)LED0=!LED0;<span class="comment">//闪烁LED,提示系统正在运行.</span></span><br><span class="line">delay_ms(<span class="number">10</span>);   </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>▲printf可以将发送到串口，默认是USART1，如果需要修改，在usart.c的fputc函数中,将USART1修改即可</p><h2 id="外部中断"><a class="markdownIt-Anchor" href="#外部中断"></a> 外部中断</h2><p>每个IO口都可以作为外部中断输入</p><blockquote><p>IO与中断线的映射,16* 7 = 112, 一共有16个中断线</p><p>Q:什么是中断线,能干什么? A:中断线能发出中断请求</p></blockquote><p>△.同一时刻只有一个引脚能映射到某根中断线</p><p>原理:</p><p>GPIOX.0映射到EXT10<br>GPIOX.1映射到EXT11<br>GPIOX.15映射到EXTI15<br>e.g.PA.0~PG.0可以映射到EXIT0</p><p>I0口外部中断在中断向量表中只分配了7个<strong>中断向量</strong>，也就是只能使用7个中断服务函数</p><h3 id="常用库函数"><a class="markdownIt-Anchor" href="#常用库函数"></a> 常用库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_EXTILineConig</span><span class="params">(<span class="keyword">uint8_t</span> GPIO,<span class="keyword">uint8_t</span> PortSource,<span class="keyword">uint8_t</span> GPIO_PinSource)</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置IO口与中断线的映射关系：</span></span></span><br><span class="line">exp:GPIO_EXTILineContig(GPIO_PortSourceGPIOE, GPIO_PinSource2)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTIInit</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span></span>;</span><br><span class="line"><span class="comment">//初始化中断线：触发方式等</span></span><br><span class="line"><span class="function">ITStatus <span class="title">EXTI_GetlTStatus</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_hLine)</span></span>;</span><br><span class="line"><span class="comment">//判断中断线中断状态，是否发生</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_ClearlTPendingBit</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span></span><br><span class="line"><span class="function"><span class="comment">//清除中断线上的中断标志位</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitStructure.EXTI_Line=EXTI_Line2;<span class="comment">// 指定要配置的中断线</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode =EXTI_Mode_Interrupt;<span class="comment">// 模式:事件or中断</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger =EXTI_Trigger_Faling;<span class="comment">//上升沿、下降沿、双触发沿</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd =ENABLE;<span class="comment">// 使能、失能</span></span><br><span class="line">EXTI_Init(&amp; EXTI_InitStructure);</span><br></pre></td></tr></table></figure><h3 id="配置的一般步骤"><a class="markdownIt-Anchor" href="#配置的一般步骤"></a> 配置的一般步骤</h3><p><img src="/2019/10/15/玩玩Stm32/E:%5Chexo%5Csource_posts%5C%E7%8E%A9%E7%8E%A9Stm32%5C%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD.jpg" alt="外部中断"></p><p>demo：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTIX_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> <span class="comment">// 声明初始化结构体变量</span></span><br><span class="line"> EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line"> NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">    KEY_Init(); <span class="comment">//按键端口初始化</span></span><br><span class="line"></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//使能复用功能时钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GPIOE.2 中断线以及中断初始化配置   下降沿触发</span></span><br><span class="line">  GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2);</span><br><span class="line"></span><br><span class="line">  EXTI_InitStructure.EXTI_Line=EXTI_Line2;<span class="comment">//KEY2</span></span><br><span class="line">  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">  EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStructure); <span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// ▲由于参数一致，所以不需要修改EXTI_InitStructure的功能参数</span></span><br><span class="line">   <span class="comment">//GPIOE.3  中断线以及中断初始化配置 下降沿触发 //KEY1</span></span><br><span class="line">  GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource3);</span><br><span class="line">  EXTI_InitStructure.EXTI_Line=EXTI_Line3;</span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStructure);  <span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//GPIOA.0  中断线以及中断初始化配置 上升沿触发 PA0  WK_UP</span></span><br><span class="line"> GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0); </span><br><span class="line"></span><br><span class="line">  EXTI_InitStructure.EXTI_Line=EXTI_Line0;</span><br><span class="line">  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;</span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStructure);<span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;<span class="comment">//使能按键WK_UP所在的外部中断通道</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0x02</span>;<span class="comment">//抢占优先级2， </span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0x03</span>;<span class="comment">//子优先级3</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//使能外部中断通道</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure); </span><br><span class="line"></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;<span class="comment">//使能按键KEY2所在的外部中断通道</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0x02</span>;<span class="comment">//抢占优先级2， </span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0x02</span>;<span class="comment">//子优先级2</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//使能外部中断通道</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;<span class="comment">//使能按键KEY1所在的外部中断通道</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0x02</span>;<span class="comment">//抢占优先级2 </span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0x01</span>;<span class="comment">//子优先级1 </span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//使能外部中断通道</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure);    <span class="comment">//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//外部中断2服务程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI2_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">delay_ms(<span class="number">10</span>);<span class="comment">//消抖</span></span><br><span class="line"><span class="keyword">if</span>(KEY2==<span class="number">0</span>)  <span class="comment">//按键KEY2</span></span><br><span class="line">&#123;</span><br><span class="line">LED0=!LED0;</span><br><span class="line">&#125; </span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line2);  <span class="comment">//清除LINE2上的中断标志位  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部中断3服务程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI3_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">delay_ms(<span class="number">10</span>);<span class="comment">//消抖</span></span><br><span class="line"><span class="keyword">if</span>(KEY1==<span class="number">0</span>) <span class="comment">//按键KEY1</span></span><br><span class="line">&#123; </span><br><span class="line">LED1=!LED1;</span><br><span class="line">&#125; </span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line3);  <span class="comment">//清除LINE3上的中断标志位  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI4_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">delay_ms(<span class="number">10</span>);<span class="comment">//消抖</span></span><br><span class="line"><span class="keyword">if</span>(KEY0==<span class="number">0</span>) <span class="comment">//按键KEY0</span></span><br><span class="line">&#123;</span><br><span class="line">LED0=!LED0;</span><br><span class="line">LED1=!LED1; </span><br><span class="line">&#125; </span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line4);  <span class="comment">//清除LINE4上的中断标志位  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">delay_init();     <span class="comment">//延时函数初始化  </span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="comment">//设置NVIC中断分组2:2位抢占优先级，2位响应优先级</span></span><br><span class="line">uart_init(<span class="number">115200</span>); <span class="comment">//串口初始化为115200</span></span><br><span class="line"> LED_Init();  <span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">BEEP_Init();         <span class="comment">//初始化蜂鸣器端口</span></span><br><span class="line">KEY_Init();         <span class="comment">//初始化与按键连接的硬件接口</span></span><br><span class="line">EXTIX_Init(); <span class="comment">//外部中断初始化</span></span><br><span class="line">LED0=<span class="number">0</span>;<span class="comment">//点亮LED0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OK\r\n"</span>);</span><br><span class="line">delay_ms(<span class="number">1000</span>);  </span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录:</h2><h3 id="u8-u16-size_t是什么类型"><a class="markdownIt-Anchor" href="#u8-u16-size_t是什么类型"></a> u8、u16、Size_t是什么类型?</h3><h4 id="u8-u16"><a class="markdownIt-Anchor" href="#u8-u16"></a> u8、u16</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!&lt; Signed integer types  */</span></span><br><span class="line"><span class="keyword">typedef</span>   <span class="keyword">signed</span> <span class="keyword">char</span>     <span class="keyword">int8_t</span>;<span class="comment">//有符号8位数</span></span><br><span class="line"><span class="keyword">typedef</span>   <span class="keyword">signed</span> <span class="keyword">short</span>    <span class="keyword">int16_t</span>;<span class="comment">//有符号16位数</span></span><br><span class="line"><span class="keyword">typedef</span>   <span class="keyword">signed</span> <span class="keyword">long</span>     <span class="keyword">int32_t</span>;<span class="comment">//有符号32位数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*!&lt; Unsigned integer types  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>     <span class="keyword">uint8_t</span>;  <span class="comment">//无符号8位数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>    <span class="keyword">uint16_t</span>;<span class="comment">//无符号16位数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>     <span class="keyword">uint32_t</span>;<span class="comment">//无符号32位数</span></span><br></pre></td></tr></table></figure><h4 id="size_t"><a class="markdownIt-Anchor" href="#size_t"></a> size_t</h4><p>size_t是C++标准在stddef.h中定义的。这个类型足以用来表示对象的大小。size_t的真实类型与操作系统有关。size_t在32位架构上是4字节，在64位架构上是8字节，在不同架构上进行编译时需要注意这个问题。而int在不同架构下都是4字节，与size_t不同；且int为带符号数，size_t为无符号数。</p><h3 id="电平相关知识"><a class="markdownIt-Anchor" href="#电平相关知识"></a> 电平相关知识</h3><p>单片机是一种数字集成芯片，数字电路中只有两种电平高电平和低电平。为了让大家在刚起步的时候对电平特性有一个清晰的认识，我们暂且定义单片机输出与输入为<strong>TTL</strong>电平，其中高电平为+5V,低电平为0V。计算机的串口为<strong>RS-232C</strong>电平。这里要强调的是，RS-232C电平为负逻辑电平。因此当计算机与单片机之间要通信时，需要加电平转换芯片，我们在TX-1C单片机实验板上所加的电平转换芯片是MAX232 。</p><p>常用的逻辑电平有TTL、CMOS、LVTTL、ECL、PECL、 GTL 、RS-232. RS-422. RS-485、LVDS等.其中TTL和CMOS的逻辑电平按典型电压可分为四类：5V系列(5V TL和5V CMOS)、3.3V 系列，2.5V 系列和1.8V系列，</p><p>T电平信号用的最多，这是因为，数据表示通常采用二进制，+5V等价于逻辑1，0V等价于逻辑0）.这被称为TTL（晶体管一晶体管逻辑电平）信号系统，这是计算机处理器控制的设备内部各部分之间通信的标准技术。TTL电平信号对于计算机处理器控制的设备内部的数据传输是很理想的，首先计算机处理器控制的设备内部的数据传输对于电源的要求不高，热损耗也较低，另外TTL电平信号直接与集成电路连接而不需要价格昂贵的线路驱动器</p><h3 id="功能函数"><a class="markdownIt-Anchor" href="#功能函数"></a> 功能函数</h3><p>判断u8数组开头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/////////////////////////</span></span><br><span class="line"><span class="comment">// 判断u8 arr开头是否为str //</span></span><br><span class="line"><span class="comment">////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">u8cmp</span><span class="params">(u8 *arr, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( arr[i] != str[i])&#123;</span><br><span class="line">                <span class="comment">// arr shorter than str</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i] == <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">// not start with</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// arr start with str</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;玩玩stm32&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#玩玩stm32&quot;&gt;&lt;/a&gt; 玩玩Stm32&lt;/h1&gt;
&lt;h2 id=&quot;文件结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#文件结构&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="嵌入式" scheme="https://nymrli.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
</feed>
