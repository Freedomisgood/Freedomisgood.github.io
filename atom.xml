<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mrli&#39;s Blog</title>
  
  <subtitle>别装作很努力，结局不会陪你演戏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nymrli.top/"/>
  <updated>2021-10-25T08:31:26.588Z</updated>
  <id>https://nymrli.top/</id>
  
  <author>
    <name>Mrli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CICD-Jenkins与Travis</title>
    <link href="https://nymrli.top/2021/10/25/CICD-Jenkins%E4%B8%8ETravis/"/>
    <id>https://nymrli.top/2021/10/25/CICD-Jenkins与Travis/</id>
    <published>2021-10-25T05:39:46.000Z</published>
    <updated>2021-10-25T08:31:26.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jenkins与travis使用"><a class="markdownIt-Anchor" href="#jenkins与travis使用"></a> Jenkins与travis使用</h1><p>Jenkins与Travis为CI、CD工具，其为Devops模式下的平台组件，能够让我们更好地进行开发测试与交付。由于最近云原生的课上在介绍<strong>DevOps和云监控</strong>，所以正好趁这个机会体验下Devops的交付流程，之前也有使用过Github Action作为CICD工具，但除了开源项目以外，Github使用比较少。这次呢就可以再熟悉下业内常用的CICD组件了：Jenkins or Travis</p><h2 id="devops发展背景"><a class="markdownIt-Anchor" href="#devops发展背景"></a> DevOps发展背景</h2><blockquote><p>传统交付模式的串行及隔离化形成了部门壁垒，降低了工作效率</p><p>通过“在云上创建资源”-&gt;实现“云服务器自动化管理”-&gt;“应用无状态上云”后即可实现应用的持续部署、持续交付，完成一次构建、到处运行的效果</p></blockquote><p>作为一种新式的开发模式，DevOps模式是在互联网应用快速迭代的需要下，结合了开发与运维以及测试流程的一种模式，解决了测试资源匮乏、手工部署工作量大、周期长，环境不统一、资源难管理的问题。</p><h3 id="实现的功能"><a class="markdownIt-Anchor" href="#实现的功能"></a> 实现的功能</h3><p><img src="/2021/10/25/CICD-Jenkins与Travis/%E5%8A%9F%E8%83%BD%E6%9E%B6%E6%9E%84.png" alt="功能架构"></p><h3 id="devops平台典型流程"><a class="markdownIt-Anchor" href="#devops平台典型流程"></a> <strong>DevOps</strong>平台典型流程</h3><p><img src="/2021/10/25/CICD-Jenkins与Travis/%E7%BB%8F%E5%85%B8%E6%B5%81%E7%A8%8B.png" alt="经典流程"></p><p>基于镜像容器构筑具备完全一致性的开发测试环境</p><p><img src="/2021/10/25/CICD-Jenkins与Travis/%E6%B5%81%E7%A8%8B.png" alt="流程"></p><h3 id="企业中devops的解决方案"><a class="markdownIt-Anchor" href="#企业中devops的解决方案"></a> 企业中Devops的解决方案</h3><p><img src="/2021/10/25/CICD-Jenkins与Travis/devops%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="devops解决方案"></p><h3 id="建设成果"><a class="markdownIt-Anchor" href="#建设成果"></a> 建设成果</h3><p><img src="/2021/10/25/CICD-Jenkins与Travis/%E5%BB%BA%E8%AE%BE%E6%88%90%E6%9E%9C.png" alt="建设成果"></p><h2 id="jenkins使用"><a class="markdownIt-Anchor" href="#jenkins使用"></a> Jenkins使用</h2><p>Jenkins跟Gitlab一样，是发布了服务包的，为了更好的管理和使用，我这边是直接使用的Jenkins Docker镜像</p><ol><li>拉取Jenkins镜像并运行</li></ol><p><code>docker run -p 8080:8080 -p 50000:50000 --restart=always --name jenkins -v jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):$(which docker) jenkins/jenkins:lts</code></p><ul><li><code>--restart=always</code>:能够使我们在重启docker时，自动启动相关容器</li><li><code>--name jenkins</code>: 将启动的容器名取作jenkins</li><li><code>-v jenkins_home:/var/jenkins_home</code>： 挂载持久化卷</li><li><code>-v /var/run/docker.sock:/var/run/docker.sock</code>：为了实现pipeline在另一个容器中运行，侦听docker.sock套接字，并执行挂载</li><li><code>-v $(which docker):$(which docker)</code>：-v 之后使用<code>$()</code>表示执行命令，这里表示如果在容器上运行<code>which docker</code>， Docker也会在本地计算机上运行<code>“ which container&quot;</code>并将执行结果返回给容器，从而能在Jenkins容器中拿到另一个容器的containerID</li><li>最后的<code>jenkins/jenkins:lts</code>：表示要拉取的镜像以及镜像版本</li></ul><p>将容器跑起来后需要进入容器，给docker.sock授权:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it --user=root jenkins bash</span><br><span class="line">chmod 666 /var/run/docker.sock</span><br><span class="line">ls -ltr /var/run</span><br></pre></td></tr></table></figure><p>以上过后就可以在浏览器上登录Jenkins了，这边登录<code>localhost:50000</code>后会有一系列初始化步骤如下</p><ol><li>安装建议的插件</li><li>创建第一个管理员用户</li><li>Jenkins实例配置</li><li>开始使用 Jenkins</li></ol><h3 id="监听github仓库变化"><a class="markdownIt-Anchor" href="#监听github仓库变化"></a> 监听Github仓库变化</h3><p>选择“新建任务”-&gt;“流水线”-&gt;勾选Github项目并输入<code>https://github.com/Freedomisgood/iotrfid.git/</code>-&gt;构建触发器中选择“GitHub hook trigger for GITScm polling”-&gt;流水线选择“Pipeline script”输入：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123; </span><br><span class="line">        docker &#123;</span><br><span class="line">            image <span class="string">'alpine'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'pull project'</span>) &#123;</span><br><span class="line">            <span class="comment">// agent &#123; docker 'openjdk:8-jre' &#125; </span></span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// echo 'Hello, JDK'</span></span><br><span class="line">                git <span class="string">credentialsId:</span> <span class="string">'GithubAccount'</span>, <span class="string">url:</span> <span class="string">'https://github.com/Freedomisgood/iotrfid.git/'</span></span><br><span class="line">                sh <span class="string">'pwd'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后保存，之后运行就可以等待触发啦，或者点击左侧的“立即构建”</p><p>注：可以看到script中有使用到docker，这边需要额外安装Docker的插件<a href="https://plugins.jenkins.io/docker-workflow" target="_blank" rel="noopener">Docker Pipeline</a>、<a href="https://plugins.jenkins.io/docker-plugin" target="_blank" rel="noopener">Docker plugin</a>（建议安装的插件中没有），如果不安装会执行失败</p><p>注：如果要监听Github仓库的变化，则需要增加Github的凭据：选择“Dashboard”到首页-&gt;系统管理-&gt;Manage Credendials-&gt;Jenkins-&gt;全局凭据-&gt;左侧的添加凭据，输入Github用户和密码后，留一个之后要使用的Credendials ID</p><p><img src="/2021/10/25/CICD-Jenkins与Travis/jenkins%E5%87%AD%E6%8D%AE.png" alt="jenkins凭据"></p><p>参考：<a href="https://www.bilibili.com/video/BV1p741117T9?from=search&amp;seid=17143129357818825777&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">怎样用 Jenkins Docker 和 CICD 构建无服务器应用程序</a></p><h2 id="travis使用"><a class="markdownIt-Anchor" href="#travis使用"></a> Travis使用</h2><h3 id="travisdocker阿里云容器镜像-dockerhub"><a class="markdownIt-Anchor" href="#travisdocker阿里云容器镜像-dockerhub"></a> Travis+Docker[+阿里云容器镜像、dockerhub]</h3><p>travis主要是关注在CI持续集成上，同时与Github关联搭配做的比较号，也能完成持续交付(持续集成的基础上，增加打包构建形成产物)的工作。因此本次就以travis+docker来完成这么一个持续集成与持续交付的步骤：</p><p><strong>步骤如下：</strong></p><ol><li><p>去<a href="%5Bhttps://www.travis-ci.com%5D(https://links.jianshu.com/go?to=https%3A%2F%2Fwww.travis-ci.com)">travis官网</a>绑定travis和github</p></li><li><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">Dockerhub</a>创建镜像仓库 or <a href="https://cr.console.aliyun.com/cn-hangzhou/instances" target="_blank" rel="noopener">阿里云开通容器镜像服务</a></p></li><li><p>项目中添加.travis.yml和Dockerfile文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>.<span class="number">1</span>-alpine</span><br><span class="line"><span class="keyword">MAINTAINER</span> Mrli <span class="number">1063052964</span>qq.com</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -zcf app.tar.gz .</span></span><br><span class="line"><span class="bash">ADD app.tar.gz /app</span></span><br><span class="line"><span class="bash">WORKDIR /app</span></span><br><span class="line"><span class="bash">RUN pip install -r local_requiements.txt</span></span><br><span class="line"><span class="bash">ENTRYPOINT python app/main.py</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">python</span></span><br><span class="line"><span class="comment"># sudo: enabled or required</span></span><br><span class="line"><span class="attr">python:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"3.9.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">pip</span> <span class="string">install</span> <span class="bullet">-r</span> <span class="string">local_requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">flake8</span> <span class="string">app</span> <span class="string">tests</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">docker</span> <span class="string">login</span> <span class="bullet">-u</span> <span class="string">$DOCKERHUB_USERNAME</span> <span class="bullet">-p</span> <span class="string">$DOCKERHUB_PASSWORD</span><span class="comment"># dockerfile中需要拉取 python-3.9.1:alipine的镜像, 所以需要先docker login</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">python</span> <span class="string">app/main.py</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">docker</span> <span class="string">build</span> <span class="bullet">-t</span> <span class="string">nymrli/python:v2</span> <span class="string">.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">docker</span> <span class="string">login</span> <span class="bullet">-u</span> <span class="string">$username</span> <span class="bullet">-p</span> <span class="string">$password</span> <span class="comment"># 这里我们使用环境变量来控制，避免写死。环境变量，在travis的后台settings里面添加</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">docker</span> <span class="string">push</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">echo</span> <span class="string">"success"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span><span class="comment"># 需要提供docker才能在里面使用docker命令</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">docker</span></span><br></pre></td></tr></table></figure></li><li><p>git push提交代码，travis会侦听github仓库变化触发githook从而执行任务</p></li><li><p>登录要运行app的服务器，<code>docker-compose up</code>将镜像启动</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  mysql:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">mysql1</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="string">数据库密码</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3306:3306"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/usr/local/docker/mysql/data:/var/lib/mysql</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/usr/local/docker/mysql/conf:/etc/mysql</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/usr/local/docker/mysql/logs:/var/log/mysql</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">jafir_nginx1</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/jafir_docker_images/web:latest</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">java</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/mydockerdata/nginx/etc/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/mydockerdata/nginx/log/:/var/log/nginx</span></span><br><span class="line"><span class="attr">  java:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">jafir_gps1</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/jafir_docker_images/jafir-images:latest</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">9090</span><span class="string">:9090</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/mydockerdata/java/gps/upload:/Users/jafir/Downloads/upload</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/mydockerdata/arme/out/*.nofoo.cn/*.nofoo.cn.pfx:/Users/jafir/Downloads/upload/cert/*.nofoo.cn.pfx</span></span><br></pre></td></tr></table></figure></li></ol><p>注：如果需要travis的构建过程中在服务器执行一些命令（如将代码部署发到自己的服务器上），还需要配置生成公钥和私匙，参看：</p><ul><li><a href="https://juejin.cn/post/6931980888267816974" target="_blank" rel="noopener">https://juejin.cn/post/6931980888267816974</a></li><li><a href="https://www.jianshu.com/p/ce648e120727" target="_blank" rel="noopener">https://www.jianshu.com/p/ce648e120727</a></li></ul><p><a href="https://github.com/gopl/ci" target="_blank" rel="noopener">https://github.com/gopl/ci</a></p><h3 id="travis-cicoveralls"><a class="markdownIt-Anchor" href="#travis-cicoveralls"></a> Travis CI+Coveralls</h3><ol><li><p>配置Travis</p><ul><li>编写<code>.travis.yml</code></li><li>使用 GitHub 账号登陆 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>，Oauth登录授权，获得组织访问权限</li><li>设置 Build Status：打开指定仓库的监听状态选项</li></ul></li><li><p>配置 Coveralls</p><ul><li><p>在<code>.travis.yml</code>中添加coveralls内容，如go的库叫goveralls ，python的库叫</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GO</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">go</span> <span class="string">get</span> <span class="string">github.com/mattn/goveralls</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">goveralls</span> <span class="bullet">-service=travis-ci</span></span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">coveralls</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">nosetests</span> <span class="bullet">--with-coverage</span> <span class="bullet">--cover-package=fanpy</span></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">coveralls</span></span><br></pre></td></tr></table></figure></li><li><p>使用 GitHub 账号登陆 <a href="https://coveralls.io/" target="_blank" rel="noopener">Coveralls</a><a href="https://travis-ci.org/" target="_blank" rel="noopener">https://travis-ci.org/</a>)，Oauth登录授权，获得组织访问权限</p></li><li><p>设置Coverage Status: 打开指定仓库的监听状态选项</p></li></ul></li></ol><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录：</h1><h2 id="cicd概念"><a class="markdownIt-Anchor" href="#cicd概念"></a> CICD概念</h2><p><strong>持续集成</strong>：以前是多个开发测试完毕后，才把代码往主分支上合并，可能交叉、冲突，合并之后还可能产生新的问题。而持续集成，就是经常提交代码到主分支，一天可能好几次。并且，自动化地进行单元测试并提供测试报告等，这样的话就能拆分细度颗粒，保证产品能够一步一步地安全可靠地迭代。很多以测试驱动开发的公司就是这样做的。</p><p><strong>持续交付</strong>：持续集成的基础上，增加打包构建形成产物。</p><p><strong>持续部署</strong>：持续交付的基础上，增加部署到相应的线上环境。</p><p>总而言之，这些持续做的事情，就是为了经常提交代码自动化测试、运行、部署，反馈问题，解决问题，再测试、运行、部署依次循环。持续部署还有个好处，对我们个人网站来说，我们可以直接提交代码，后续一系列过程都是自动化的，就不用管了，它自己自动部署发布。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jenkins与travis使用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jenkins与travis使用&quot;&gt;&lt;/a&gt; Jenkins与travis使用&lt;/h1&gt;
&lt;p&gt;Jenkins与Travis为CI、CD工具，其为Devop
      
    
    </summary>
    
    
      <category term="环境部署" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Java Logger</title>
    <link href="https://nymrli.top/2021/10/20/Java-Logger/"/>
    <id>https://nymrli.top/2021/10/20/Java-Logger/</id>
    <published>2021-10-20T09:15:14.000Z</published>
    <updated>2021-10-25T08:32:07.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-loggerjava的日志体系"><a class="markdownIt-Anchor" href="#java-loggerjava的日志体系"></a> Java Logger——Java的日志体系</h1><p>在JDK 1.3及以前，Java打日志依赖System.out.println(), System.err.println()或者e.printStackTrace()，Debug日志被写到STDOUT流，错误日志被写到STDERR流。这样打日志有一个非常大的缺陷，即无法定制化，且日志粒度不够细。</p><p>于是， Gülcü 于2001年发布了Log4j，后来成为Apache 基金会的顶级项目。Log4j 在设计上非常优秀，对后续的 Java Log 框架有长久而深远的影响，它定义的Logger、Appender、Level等概念如今已经被广泛使用。Log4j 的短板在于性能，在Logback 和 Log4j2 出来之后，Log4j的使用也减少了。</p><p>整个分类和发展历程如下：</p><p>![Java Logging](./Java-Logger/Java Logging.png)</p><p>其中，目前比较主流的使用方法和性能较高的组合是，SLF4J + Logback</p><h2 id="slf4j-simple-logging-facade-for-java"><a class="markdownIt-Anchor" href="#slf4j-simple-logging-facade-for-java"></a> SLF4J-Simple Logging Facade for Java</h2><p>看英文全写可以知道，这个东东是Java中日志实现的一个简单<strong>接口</strong>，是对多种日志logging框架的一个抽象，如jul:java.util.logging、logback、log4j</p><blockquote><p>大家在自己写项目的时候都会用到日志记录的功能，而通常下来，我们只记得想用的时候在类内协商<code>var logger: Log = LogFactory.getLog(VerticalAlgorithm::class.java)--Koltin</code>or<code>private Log logger = LogFactory.getLog(VerticalAlgorithm.class)--Java</code>，而等到自己写依赖的时候却不知道是咋回事，只知道Java的日志系统貌似挺复杂的。实际上，上面的代码是使用了SLF4J的规范，如果不正确引入依赖的话运行时会报如下的错误：</p><p><strong><code>SLF4J: No SLF4J providers were found</code></strong></p></blockquote><p>然而检查依赖时，会发现已经引入slf4j-api了，然而还是报错了，这是为什么呢？其原因是，SLF4J本身不是一个日志库，而是一个日志库的抽象层，它必须依赖底层的日志库。</p><p>详情见<a href="http://link.zhihu.com/?target=https%3A//www.slf4j.org/" target="_blank" rel="noopener">SLF4J官网</a>提供的图：</p><p><img src="/2021/10/20/Java-Logger/log-api-implement.jpg" alt="log-api-implement"></p><h3 id="两层-抽象层实现层"><a class="markdownIt-Anchor" href="#两层-抽象层实现层"></a> 两层: 抽象层+实现层</h3><p>从图中可知，SLF4J必须和其他日志库配合才能正常运行。因此一般来说，需要将抽象层（例如slf4j-api-xx.jar）+中间层（例如slf4j-log4j12）+实现层（例如log4j）这三层都配置好才能保证SLF4J正常运行。</p><p>另外，有的日志库可以去掉中间层，例如slf4j-api和slf4j-simple就可以直接配合。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0-beta0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0-beta0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- --&gt;</span>注两个版本是一致的<span class="comment">&lt;!-- --&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式就是抽象层+实现层的组合。使用这种方式只需要两个jar包</p><h3 id="三层-抽象层实现层"><a class="markdownIt-Anchor" href="#三层-抽象层实现层"></a> 三层： 抽象层+实现层</h3><p>按照图片所展示的，也有抽象层+中间层+实现层三层的实现方式，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0-beta0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0-beta0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而，直接使用的话还是会出现一点问题：<code>No appenders could be found for logger(log4j)?</code></p><p>这其实是要添加一个配置文件log4j.properties声明appenders，内容如下（内容可以自定义）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Set root logger level to DEBUG and its only appender to A1.</span><br><span class="line">log4j.rootLogger=DEBUG, A1</span><br><span class="line"> </span><br><span class="line"># A1 is set to be a ConsoleAppender.</span><br><span class="line">log4j.appender.A1=org.apache.log4j.ConsoleAppender</span><br><span class="line"> </span><br><span class="line"># A1 uses PatternLayout.</span><br><span class="line">log4j.appender.A1.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n</span><br></pre></td></tr></table></figure><h3 id="最佳实践"><a class="markdownIt-Anchor" href="#最佳实践"></a> 最佳实践</h3><p>推荐使用 SLF4J + Logback。maven依赖如下，其中version字段用占位符代替，应该根据项目的实际情况选择合适的版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">        &lt;version&gt;1.6.4&lt;/version&gt;</span></span><br><span class="line"><span class="comment">    &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">        &lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">        &lt;version&gt;1.0.6&lt;/version&gt;</span></span><br><span class="line"><span class="comment">    &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 该依赖包括了上面两个依赖，所以只要引入该依赖即可 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="slf4j适配"><a class="markdownIt-Anchor" href="#slf4j适配"></a> SLF4J适配</h3><p>因为当时Java的日志组件比较混乱繁杂，Ceki Gülcü推出slf4j后，也相应为行业中各个主流日志组件推出了slf4j的适配。因此slf4j支持各种适配，无论你现在是用哪种日志组件，你都可以通过slf4j的适配器来使用上slf4j。只要你切换到了slf4j，那么再通过slf4j用上实现组件。给大家一个整体的依赖图（网上看到的）</p><p><img src="/2021/10/20/Java-Logger/slf4j%E9%80%82%E9%85%8D.png" alt="slf4j适配"></p><h2 id="logback"><a class="markdownIt-Anchor" href="#logback"></a> Logback</h2><p>在代码中使用方式主要参考SLF4J API如何使用即可，Logback相关的主要是其配置文件logback.xml。</p><p>首先，如果依赖了logback，但在resources中没有创建logback.xml的配置文件，则默认输出到控制台且输出级别为trace以上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">14:59:54,588 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback-test.xml]</span><br><span class="line">14:59:54,589 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback.groovy]</span><br><span class="line">14:59:54,589 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Found resource [logback.xml] at [file:/F:/JavaCode/plainJava/target/classes/logback.xml]</span><br></pre></td></tr></table></figure><p>如果要自定义配置，则可以像如下定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://ch.qos.logback/xml/ns/logback"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://ch.qos.logback/xml/ns/logback https://raw.githubusercontent.com/enricopulatzo/logback-XSD/master/src/main/xsd/logback.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span> <span class="attr">value</span>=<span class="string">"tp/log"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 输出到控制台 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 输出的格式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;:  %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>F:\JavaCode\plainJava\src\main\resources\\test1.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg %n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"RollAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置滚动的策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志名称的格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/logback.log.%d&#123;yyyy-MM-dd&#125;<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保存的最长时间：天数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>1<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;:  %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    注意：</span></span><br><span class="line"><span class="comment">    level属性也可以直接写在logger上，如：</span></span><br><span class="line"><span class="comment">    &lt;logger name="ws.log.logback.LogbackTest" additivity="false" level="INFO"&gt;</span></span><br><span class="line"><span class="comment">        &lt;appender-ref ref="STDOUT" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;/logger&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"ws.log.logback.LogbackTest"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"INFO"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 相当于logger元素，只是name值已经确定为root了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"warn"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>讲解下RollingFileAppender， 这个是我们在日常日志系统里经常能看到的模式。由于日志数量会越来越多，所以如果都放在一个文件内的话，会导致文件大小变得很大，因此通过时间间隔分割将能更好地分割日志文件，也有助于之后日常地查询。关于RollingFileAppender其中File属性的设定如下：</p><p><strong>设置File属性</strong></p><ol><li>系统会将日志内容全部写入<code>log/check.log</code>中。</li><li>在2019-06-05凌晨，<code>check.log</code>会被重命名为<code>log/check.2019-06-04.log</code>。</li><li>然后再生成新的check.log文件，按照上面的步骤生成<code>log/check.2019-06-05.log</code>、<code>log/check.2019-06-06.log</code>等日志。</li></ol><p><strong>忽略File属性</strong></p><ol><li>系统会将日志内容直接写入<code>log/check.2019-06-04.log</code>中。</li><li>在2019-06-05凌晨，系统会将日志内容直接写入<code>log/check.2019-06-04.log</code>。</li></ol><p>即以<code>2019-06-04为</code>例，如果你设置了<code>File</code>属性，当天你只能看到check.log日志文件，<code>2019-06-05</code>才会看到<code>check.201-06-04.log</code>文件。但是如果你忽略了，你当天就能看到<code>check.2019-06-04.log</code>文件，但你始终看不到check.log文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"emergencyLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 写入日志内容的文件名称（目录） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span>&gt;</span>log/check.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 活动文件的名字会根据fileNamePattern的值，每隔一段时间改变一次 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>log/check.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每产生一个日志文件，该日志文件的保存期限为30天 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- pattern节点，用来设置日志的输入格式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5level %logger [%msg]%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 记录日志的编码:此处设置字符集 - --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上述配置执行的话，会在工程根目录即src、<code>.idea</code>那层生成log文件夹，其中包含日志log。即相对路径是以根目录为起点的</p><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><ul><li><strong>(J)CL使用方式</strong></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> VerticalAlgorithm : RemappingAlgorithm &#123;</span><br><span class="line">    <span class="keyword">var</span> logger: Log = LogFactory.getLog(VerticalAlgorithm::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>slf4j使用方式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = LoggerFactory.getLogger(LogTest.class);</span><br><span class="line">        logger.info(<span class="string">"ues"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者使用lombok的@Slf4j标注类上功能时一样的</span></span><br></pre></td></tr></table></figure><p>再提几点最佳实践指导原则：</p><ul><li><p>总是使用 Log Facade，而不是具体的 Log Implementation</p></li><li><p>只添加一个 Log Implementation 依赖</p></li><li><p>具体的日志依赖应该设置为 optional，并使用 runtime scope</p><p>​设为optional，依赖不会传递，这样如果你是个lib项目，然后别的项目使用了你这个lib，不会被引入不想要的Log Implementation 依赖；<br>Scope设置为runtime，是为了防止开发人员在项目中直接使用Log Implementation中的类，而不使用Log Facade中的类。</p></li><li><p>如果有必要, 排除依赖的第三方库中的Log Impementation依赖</p><p>​这是很常见的一个问题，第三方库的开发者未必会把具体的日志实现或者桥接器的依赖设置为optional，然后你的项目继承了这些依赖——具体的日志实现未必是你想使用的，比如他依赖了Log4j，你想使用Logback，这时就很尴尬。另外，如果不同的第三方依赖使用了不同的桥接器和Log实现，也极容易形成环。<br>这种情况下，推荐的处理方法，是使用exclude来排除所有的这些Log实现和桥接器的依赖，只保留第三方库里面对Log Facade的依赖。</p></li></ul><h2 id="阿里日志规范"><a class="markdownIt-Anchor" href="#阿里日志规范"></a> 阿里日志规范</h2><p>阿里对此的代码规范：</p><p>【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。import org.slf4j.Logger; import org.slf4j.LoggerFactory; private static final Logger logger = LoggerFactory.getLogger(Abc.class);</p><h2 id="让spring统一输出"><a class="markdownIt-Anchor" href="#让spring统一输出"></a> 让Spring统一输出</h2><p>这就是为了对slf4j的适配做一个例子说明。Spring是用JCL作为日志门面的，那我们的应用是slf4j + logback，怎么让Spring也用到logback作为日志输出呢？这样的好处就是我们可以统一项目内的其他模块、框架的日志输出（日志格式，日志文件，存放路径等，以及其他slf4j支持的功能） 很简单，就是加入<code>jcl-over-slf4j.jar</code>就好了。</p><p><img src="/2021/10/20/Java-Logger/spring-log.png" alt="spring-log"></p><h2 id="日志配置启动过程"><a class="markdownIt-Anchor" href="#日志配置启动过程"></a> 日志配置启动过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">14:59:54,588 |-INFO <span class="keyword">in</span> ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback-test.xml]</span><br><span class="line">14:59:54,589 |-INFO <span class="keyword">in</span> ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback.groovy]</span><br><span class="line"></span><br><span class="line">★14:59:54,589 |-INFO <span class="keyword">in</span> ch.qos.logback.classic.LoggerContext[default] - Found resource [logback.xml] at [file:/F:/JavaCode/plainJava/target/classes/logback.xml]</span><br><span class="line"></span><br><span class="line">14:59:54,835 |-INFO <span class="keyword">in</span> ch.qos.logback.core.joran.action.ImplicitModelAction - Assuming default class name [ch.qos.logback.classic.encoder.PatternLayoutEncoder] <span class="keyword">for</span> tag [encoder]</span><br><span class="line">14:59:54,836 |-INFO <span class="keyword">in</span> ch.qos.logback.core.joran.action.ImplicitModelAction - Assuming default class name [ch.qos.logback.classic.encoder.PatternLayoutEncoder] <span class="keyword">for</span> tag [encoder]</span><br><span class="line">14:59:54,952 |-INFO <span class="keyword">in</span> ch.qos.logback.core.model.processor.AppenderModelHandler - Processing appender named [STDOUT]</span><br><span class="line">14:59:54,952 |-INFO <span class="keyword">in</span> ch.qos.logback.core.model.processor.AppenderModelHandler - About to instantiate appender of <span class="built_in">type</span> [ch.qos.logback.core.ConsoleAppender]</span><br><span class="line"></span><br><span class="line">★★14:59:55,111 |-ERROR <span class="keyword">in</span> ch.qos.logback.core.pattern.parser.Compiler@737996a0 - There is no conversion class registered <span class="keyword">for</span> conversion word [thead]</span><br><span class="line">★★14:59:55,111 |-ERROR <span class="keyword">in</span> ch.qos.logback.core.pattern.parser.Compiler@737996a0 - [thead] is not a valid conversion word</span><br><span class="line"></span><br><span class="line">14:59:55,220 |-INFO <span class="keyword">in</span> ch.qos.logback.core.model.processor.AppenderModelHandler - Processing appender named [FILE]</span><br><span class="line">14:59:55,220 |-INFO <span class="keyword">in</span> ch.qos.logback.core.model.processor.AppenderModelHandler - About to instantiate appender of <span class="built_in">type</span> [ch.qos.logback.core.FileAppender]</span><br><span class="line"></span><br><span class="line">★★14:59:55,224 |-ERROR <span class="keyword">in</span> ch.qos.logback.core.pattern.parser.Compiler@61dc03ce - There is no conversion class registered <span class="keyword">for</span> conversion word [thead]</span><br><span class="line">★★14:59:55,224 |-ERROR <span class="keyword">in</span> ch.qos.logback.core.pattern.parser.Compiler@61dc03ce - [thead] is not a valid conversion word</span><br><span class="line"></span><br><span class="line">14:59:55,224 |-INFO <span class="keyword">in</span> ch.qos.logback.core.FileAppender[FILE] - File property is <span class="built_in">set</span> to [./test.log]</span><br><span class="line"></span><br><span class="line">★14:59:55,226 |-INFO <span class="keyword">in</span> ch.qos.logback.classic.model.processor.RootLoggerModelHandler - Setting level of ROOT logger to WARN</span><br><span class="line">★14:59:55,228 |-INFO <span class="keyword">in</span> ch.qos.logback.core.model.processor.AppenderRefModelHandler - Attaching appender named [STDOUT] to Logger[ROOT]</span><br><span class="line">★14:59:55,228 |-INFO <span class="keyword">in</span> ch.qos.logback.core.model.processor.AppenderRefModelHandler - Attaching appender named [FILE] to Logger[ROOT]</span><br></pre></td></tr></table></figure><p>[]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-loggerjava的日志体系&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java-loggerjava的日志体系&quot;&gt;&lt;/a&gt; Java Logger——Java的日志体系&lt;/h1&gt;
&lt;p&gt;在JDK 1.3及以前，Java
      
    
    </summary>
    
    
      <category term="Java" scheme="https://nymrli.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>javadoc——让大家更好写java项目</title>
    <link href="https://nymrli.top/2021/10/17/javadoc%E2%80%94%E2%80%94%E8%AE%A9%E5%A4%A7%E5%AE%B6%E6%9B%B4%E5%A5%BD%E5%86%99java%E9%A1%B9%E7%9B%AE/"/>
    <id>https://nymrli.top/2021/10/17/javadoc——让大家更好写java项目/</id>
    <published>2021-10-17T13:57:14.000Z</published>
    <updated>2021-10-18T09:01:39.455Z</updated>
    
    <content type="html"><![CDATA[<p>近期在Github上看到一个有趣的项目，是各个技能树的挑战，并且起了个冒险岛的故事——<a href="https://bytelegend.com/" target="_blank" rel="noopener">字节传说</a>:勇士将无惧挑战。其中除了<a href="https://github.com/ByteLegendQuest/remember-brave-people" target="_blank" rel="noopener">提交Pr的教程</a>（挑战）外，还有个比较有意思的是Javadoc，想想之前没专门写过，于是本勇士本次就毅然接收了<a href="https://github.com/ByteLegendQuest/java-write-javadoc" target="_blank" rel="noopener">Javadoc的挑战</a>。</p><h2 id="javadoc"><a class="markdownIt-Anchor" href="#javadoc"></a> Javadoc</h2><blockquote><p>很多程序对Javadoc都不重视，认识不到Javadoc的作用，很多人都是这样认为的：“我只要写好功能就够了，写Javadoc太浪费时间，也没啥作用，还不如用写Javadoc的时间再多些个功能呢！”，我们知道注释是为了解释代码的作用的，是为了将来给自己或者别人快速了解代码的，在方法内一般用行注释//的比较多，是针对一小块代码做出解释的，而Javadoc的作用是针对整个方法或者整个类做一个简要的概述的，使得别人不通过看具体方法代码就能知道某个方法或者某个类的作用和功能。写了Javadoc的在别人使用到类时，<strong>将鼠标悬停到类上或者方法上，javadoc会以提示信息显示出来</strong>，这样开发者在跳进源代码中就能知道类或者方法的作用，使得可以编在码时看文档，效果最明显的就是Spingboot的Javadoc能在不知道一个接口的作用、参数时，直接看到说明。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;概要描述&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;详细描述&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;Javadoc文档标记 标记说明&gt;</span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure><p>注意点：①Javadoc以<code>/**</code>开头，<code>*/</code>收尾；②文档标记后不能跟冒号<code>:</code>，如<code>@param filePath</code>中间用空格分开即可，不能加<code>:</code></p><ul><li>第一段：概要描述，通常用一句或者一段话简要描述该类或者方法的作用</li><li>第二段：详细描述，通常用一段或者多段话来详细描述该类或者方法的作用</li><li>第三段：文档标注，用于标注作者、创建时间、参阅类、参数等信息</li></ul><h3 id="常见javadoc文档标记"><a class="markdownIt-Anchor" href="#常见javadoc文档标记"></a> 常见Javadoc文档标记</h3><p>JDK预定义好的文档标记有，@author、@version、@since、@see、@link、@code、@param、@return、@exception、@throws等。</p><h3 id="link"><a class="markdownIt-Anchor" href="#link"></a> @link：</h3><blockquote><p><code>{@link 包名.类名#方法名(参数类型)}</code>用于快速链接到相关代码</p></blockquote><p>@link的使用语法<code>{@link 包名.类名#方法名(参数类型)}</code>，其中当包名在当前类中已经导入了包名可以省略，可以只是一个类名，也可以是仅仅是一个方法名，也可以是类名.方法名，使用此文档标记的类或者方法，可用通过 <strong>按住Ctrl键+单击</strong> 可以快速跳到相应的类或者方法上，解析成html其实就是使用&lt; code&gt; 包名.类名#方法名(参数类型)&lt; /code&gt;</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全限定的类名</span></span><br><span class="line">&#123;<span class="meta">@link</span> java.lang.Character&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略包名</span></span><br><span class="line">&#123;<span class="meta">@link</span> String&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略类名，表示指向当前的某个方法</span></span><br><span class="line">&#123;@link #length()&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包名.类名.方法名(参数类型)</span></span><br><span class="line">&#123;@link java.lang.String#charAt(int)&#125;</span><br></pre></td></tr></table></figure><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> @code：</h3><blockquote><p>{@code text} 将文本标记为code</p></blockquote><p>{@code text} 会被解析成<code>&lt;code&gt; text &lt;/code&gt;</code>。将文本标记为代码样式的文本，在code内部可以使用 &lt; 、&gt; 等不会被解释成html标签, code标签有自己的样式，<u>一般在Javadoc中只要涉及到类名或者方法名，都需要使用@code进行标记</u>。</p><h3 id="see"><a class="markdownIt-Anchor" href="#see"></a> @see</h3><blockquote><p>另请参阅，一般用于标记该类<strong>相关联的类（方法）、相似的类（方法）</strong></p></blockquote><p>@see即可以用在类上，也可以用在方法上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> IntStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> LongStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DoubleStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> &lt;a href="package-summary.html"&gt;java.util.stream&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="throws"><a class="markdownIt-Anchor" href="#throws"></a> @throws</h3><blockquote><p>后面跟 异常类型 异常描述 , 用于描述<strong>方法内部可能抛出(产生)的异常</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> str the &#123;<span class="doctag">@code</span> CharSequence&#125; to check (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsWhitespace</span><span class="params">(@Nullable CharSequence str)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="exception"><a class="markdownIt-Anchor" href="#exception"></a> @exception</h3><blockquote><p>用于描述<strong>方法签名明确会throws的异常</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@exception</span> IllegalArgumentException if &lt;code&gt;key&lt;/code&gt; is null.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="value"><a class="markdownIt-Anchor" href="#value"></a> @value</h3><blockquote><p>用于标注在常量上，{@value} 用于表示常量的值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 默认数量 &#123;<span class="doctag">@value</span>&#125; */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer QUANTITY = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="inheritdoc"><a class="markdownIt-Anchor" href="#inheritdoc"></a> @inheritDoc</h3><blockquote><p>@inheritDoc用于注解在<strong>重写方法</strong>或者<strong>子类</strong>上，用于<strong>继承父类中的Javadoc</strong></p></blockquote><ul><li>基类的文档注释被继承到了子类</li><li>子类可以再加入自己的注释（特殊化扩展）</li><li>@return @param @throws 也会被继承</li></ul><h3 id="version"><a class="markdownIt-Anchor" href="#version"></a> @version</h3><blockquote><p>@version 用于标记当前版本，默认为1.0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.sun.org.apache.xml.internal.resolver;</span><br><span class="line"> /**</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class Resolver extends Catalog &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="since"><a class="markdownIt-Anchor" href="#since"></a> @since</h3><blockquote><p>@since 一般用于标记文件创建时项目当时对应的版本，一般后面跟版本号，也可以跟是一个时间，表示文件当前创建的时间</p></blockquote><h3 id="return"><a class="markdownIt-Anchor" href="#return"></a> @return</h3><blockquote><p>返回值的描述</p></blockquote><h3 id="param"><a class="markdownIt-Anchor" href="#param"></a> @param</h3><blockquote><p>后面跟参数名，再跟参数描述</p></blockquote><h2 id="完整示例"><a class="markdownIt-Anchor" href="#完整示例"></a> 完整示例</h2><p>spring-core中的StringUtils 示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Miscellaneous &#123;<span class="doctag">@link</span> String&#125; utility methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Mainly for internal use within the framework; consider</span></span><br><span class="line"><span class="comment"> * &lt;a href="http://commons.apache.org/proper/commons-lang/"&gt;Apache's Commons Lang&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * for a more comprehensive suite of &#123;<span class="doctag">@code</span> String&#125; utilities.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class delivers some simple functionality that should really be</span></span><br><span class="line"><span class="comment"> * provided by the core Java &#123;<span class="doctag">@link</span> String&#125; and &#123;<span class="doctag">@link</span> StringBuilder&#125;</span></span><br><span class="line"><span class="comment"> * classes. It also provides easy-to-use methods to convert between</span></span><br><span class="line"><span class="comment"> * delimited strings, such as CSV strings, and collections and arrays.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rob Harrop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rick Evans</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam Brannen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Brian Clozel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 16 April 2001</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decode the given encoded URI component value. Based on the following rules:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Alphanumeric characters &#123;<span class="doctag">@code</span> "a"&#125; through &#123;<span class="doctag">@code</span> "z"&#125;, &#123;<span class="doctag">@code</span> "A"&#125; through &#123;<span class="doctag">@code</span> "Z"&#125;,</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@code</span> "0"&#125; through &#123;<span class="doctag">@code</span> "9"&#125; stay the same.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Special characters &#123;<span class="doctag">@code</span> "-"&#125;, &#123;<span class="doctag">@code</span> "_"&#125;, &#123;<span class="doctag">@code</span> "."&#125;, and &#123;<span class="doctag">@code</span> "*"&#125; stay the same.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;A sequence "&#123;<span class="doctag">@code</span> %&lt;i&gt;xy&lt;/i&gt;&#125;" is interpreted as a hexadecimal representation of the character.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source the encoded String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset the character set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the decoded value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException when the given source contains invalid encoded sequences</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.net.URLDecoder#decode(String, String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">uriDecode</span><span class="params">(String source, Charset charset)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录：</h2><p>使用HTML标签写详细文档：</p><h3 id="第二段详细描述"><a class="markdownIt-Anchor" href="#第二段详细描述"></a> 第二段：详细描述</h3><p>详细描述一般用一段或者几个锻炼来详细描述类的作用，详细描述中可以使用html标签，如<code>&lt;p&gt;、&lt;pre&gt;、&lt;a&gt;、&lt;ul&gt;、&lt;i&gt;</code>等标签， 通常详细描述都以段落p标签开始。<br>详细描述和概要描述中间通常有一个空行来分割</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Miscellaneous &#123;<span class="doctag">@link</span> String&#125; utility methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Mainly for internal use within the framework; consider</span></span><br><span class="line"><span class="comment"> * &lt;a href="http://commons.apache.org/proper/commons-lang/"&gt;Apache's Commons Lang&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * for a more comprehensive suite of &#123;<span class="doctag">@code</span> String&#125; utilities.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class delivers some simple functionality that should really be</span></span><br><span class="line"><span class="comment"> * provided by the core Java &#123;<span class="doctag">@link</span> String&#125; and &#123;<span class="doctag">@link</span> StringBuilder&#125;</span></span><br><span class="line"><span class="comment"> * classes. It also provides easy-to-use methods to convert between</span></span><br><span class="line"><span class="comment"> * delimited strings, such as CSV strings, and collections and arrays.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>一般段落都用p标签来标记，凡涉及到类名和方法名都用@code标记，凡<u>涉及到组织的，一般用a标签提供出来链接地址</u>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近期在Github上看到一个有趣的项目，是各个技能树的挑战，并且起了个冒险岛的故事——&lt;a href=&quot;https://bytelegend.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字节传说&lt;/a&gt;:勇士将无惧挑战。其中除了&lt;a href=
      
    
    </summary>
    
    
      <category term="技能糖" scheme="https://nymrli.top/tags/%E6%8A%80%E8%83%BD%E7%B3%96/"/>
    
  </entry>
  
  <entry>
    <title>ZJU开学摸底考试——计算机网络复习</title>
    <link href="https://nymrli.top/2021/10/15/ZJU%E5%BC%80%E5%AD%A6%E6%91%B8%E5%BA%95%E8%80%83%E8%AF%95%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"/>
    <id>https://nymrli.top/2021/10/15/ZJU开学摸底考试——计算机网络复习/</id>
    <published>2021-10-15T12:06:53.000Z</published>
    <updated>2021-10-25T08:52:57.113Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络核心：</p><ul><li>主机</li><li>通信链路</li><li>交换网络</li><li>协议</li></ul><p>多路复用</p><ul><li>频分多路复用</li><li>时分多路复用</li><li>码分多路复用</li><li>波分多路复用</li></ul><p>数据交换</p><ul><li>电路交换（FDM,WDM,TDM,CDM）</li><li>报文交换（被废弃了）</li><li>分组交换（统计多路复用）<ul><li>分组：报文分拆出来的一系列相对较小的数据包</li><li>分组交换需要报文的拆分与重组</li><li>统计多路复用</li><li>工作方式：存储与转发：<ul><li>报文交换与分组交换均采用存储-转发交换方式</li><li>区别：<br>报文交换以完整报文进行“存储-转发”<br>分组交换以较小的分组进行“存储-转发”</li></ul></li><li>报文：M bts<br>链路带宽（数据传输<br>速率）：R bps<br>分组长度（大小）：Lbits<br>跳步数：h<br>路由器数：n</li><li>分组交换允许更多用户同时使用网络！——网络资源充分共享</li></ul></li></ul><p>网络性能：</p><ul><li>速率即数据率（ data rate）或称数据传输速率或比特率（ bit rate）<ul><li>单位时间（秒）传输信息（比特）量</li><li>计算机网络中最重要的一个性能指标</li><li>单位：b/s（或bps）、kb/s、Mb/s、Gb/s</li><li>k=103、M=106、G=109</li></ul></li><li>带宽”（ bandwidth）原本指信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）<ul><li>网络的“带宽”通常是数字信道所能传送的“最高数据率”，单位：b/s（bps）</li><li>常用的带宽单位<br>kb/s （103 b/s）<br>Mb/s （106 b/s）<br>Gb/s （109 b/s）<br>Tb/s（1012b/s）</li></ul></li><li>Q：分组交换为什么会发生丢包和时延？<br>A：分组在路由器缓存中排队<br>令分组到达速率超出输出链路容量时<ul><li>四种分组延迟<ul><li>结点处理延迟</li><li>排队延迟</li><li>传输延迟</li><li>传播延迟（光纤影响的是这个时间）</li><li>车队例子：<a href="https://www.icourse163.org/learn/HIT-154005?tid=1463162470#/learn/content?type=detail&amp;id=1240421270&amp;cid=1261896474" target="_blank" rel="noopener">https://www.icourse163.org/learn/HIT-154005?tid=1463162470#/learn/content?type=detail&amp;id=1240421270&amp;cid=1261896474</a></li></ul></li><li>时延带宽积：传播时延×带宽，链路的时延带宽积又称为以比特为单位的链路长度</li></ul></li><li>分组丢包：<ul><li>队列缓存容量有限</li><li>分组到达已满队列将被丢弃（即丢包）</li><li>丢弃分组可能由前序结点或源重发（也可能不重发）</li></ul></li><li>吞吐量表示在发送端与接收端之间传送数据速率（b/s）<ul><li>即时吞吐量：给定时刻的速率</li><li>平均吞吐量。一段时间的平均速率</li></ul></li></ul><p>计算机网络是一个非常复杂的系统，涉及许多组成部分</p><ul><li>主机（ hosts）</li><li>路由器（ routers）</li><li>各种链路（inks）</li><li>应用（ applications）</li><li>协议（ protocols）</li><li>硬件、软件</li></ul><p><strong>计算机网络结构</strong></p><p>Q:是否存在一种系统结构有效描述网络？<br>Q:利用什么样的结构？<br>Q:至少用于讨论网络？<br>A：分层结构， 每次每层完成一种（类）特定服务/功能：每层依赖底层提供的服务，通过层内动作完成相应功能</p><ul><li><p>网络体系结构是从功能上描述计算机网络结构</p></li><li><p>计算机网络体系结构简称网络体系结构（ network architecture）是<strong>分层结构</strong></p></li><li><p>每层遵循某个/些网络协议完成本层功能</p></li><li><p>计算机网络体系结构是计算机网络的各层及其协议的集合</p></li><li><p>体系结构是一个计算机网络的功能层次及其关系的定义</p></li><li><p>体系结构是抽象的</p></li><li><p>Q:为什么采用分层结构</p><ul><li>结构清晰，有利于识别复杂系统的部件及其关系</li><li>模块化的分层易于系统更新、维护<ul><li>任何一层服务实现的改变对于系统其它层都是透明的。例如，登机过程的改变并不影响航空系统的其它部分（层）</li></ul></li><li>有利于标准化</li></ul></li><li><p>基本概念：</p><p><img src="/2021/10/15/ZJU开学摸底考试——计算机网络复习/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt="基本概念"></p></li></ul><p>物理层：</p><p>比特编码<br>数据率<br>比特同步：时钟同步<br>传输模式</p><p>数据链路层功能</p><p>流量控制（ Flow control）<br>避免淹没接收端<br>差错控制（ Error control）<br>检测并重传损坏或丢失帧，并避免重复帧<br>访问（接入）控制（ Access control</p><p>网络层：</p><p>负责源主机到目的主机数据分组（ packet）交付<br>可能穿越多个网络<br>逻辑寻址（ Logical addressing）<br>全局唯一逻辑地址，确保数据分组被送达目的主机，如<br>P地址</p><p><strong>路由</strong>（ Routing）<br>路由器（或网关）互连网络，并路由分组至最终目的主机<br>路径选择<br><strong>分组转发</strong></p><p>传输层功能</p><p>分段与重组<br>SAP寻址<br>连接控制<br>流量控制<br>差错控制</p><p>会话层功能</p><p>对话控制</p><p>同步（ synchronization）</p><p>表示层</p><p>数据表示转化<br>加密/解密<br>压缩解压缩</p><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><p>采用分组转发的优缺点：</p><ol><li>加速了数据在网络中的传输。因为分组是逐个传输，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式传输方式减少了报文的传输时间。此外，传输一个分组所需的缓冲区比传输一份报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的机率及等待的时间也必然少得多。</li><li>简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。</li><li>减少了出错机率和重发数据量。因为分组较短，其出错机率必然减少，每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。</li><li>由于分组短小，更适用于采用优先级策略，便于及时传送一些紧急数据，因此对于计算机之间的突发式的数据通信，分组交换显然更为合适些。</li></ol><p>缺点：</p><ol><li>尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。</li><li>分组交换与报文交换一样，每个分组都要加上源、目的地址和分组编号等信息，使传送的信息量大约增大5%～10%，一定程度上降低了通信效率，增加了处理的时间，使控制复杂，时延增加。</li><li>当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</li></ol><p>Q:SMTP 是一种<strong>TCP协议支持的提供可靠且有效 电子邮件 传输的 应用层 协议</strong>。</p><p>Q:计算机网络拓扑结构取决<strong>通信子网</strong>。</p><p>Q：关于Ip首部最大长度（60）和最小长度（20）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机网络核心：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机&lt;/li&gt;
&lt;li&gt;通信链路&lt;/li&gt;
&lt;li&gt;交换网络&lt;/li&gt;
&lt;li&gt;协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多路复用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;频分多路复用&lt;/li&gt;
&lt;li&gt;时分多路复用&lt;/li&gt;
&lt;li&gt;码分多路复用&lt;/
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>ZJU开学摸底考试——数据库概论复习</title>
    <link href="https://nymrli.top/2021/10/12/ZJU%E5%BC%80%E5%AD%A6%E6%91%B8%E5%BA%95%E8%80%83%E8%AF%95%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/"/>
    <id>https://nymrli.top/2021/10/12/ZJU开学摸底考试——数据库概论复习/</id>
    <published>2021-10-12T08:16:24.000Z</published>
    <updated>2021-10-19T08:50:28.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库概论"><a class="markdownIt-Anchor" href="#数据库概论"></a> 数据库概论</h1><h2 id="数据库的4个基本概念"><a class="markdownIt-Anchor" href="#数据库的4个基本概念"></a> <strong>数据库的4个基本概念</strong></h2><ol><li><p>数据（Data）</p><ul><li>定义：描述事物的符号记录。</li><li>数据的含义称为数据的语义，数据的语义是指对具体数值进行的解释说明。数据与其语义是不可分的。</li><li>数据是数据库中存储的基本对象。</li></ul></li><li><p>数据库（Database，DB）</p><ul><li>定义：数据库是<strong>长期储存</strong>在计算机内、<strong>有组织的</strong>、<strong>可共享</strong>的大量数据的集合。</li></ul><p>数据厍的基本特征</p><ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享、冗余度较小、易扩展</li><li>数据独立性较高</li></ul></li><li><p>数据库管理系统（DataBase Management System，DBMS)</p><ul><li>位于用户应用与操作系统之间的一层数据管理软件；</li><li>跟操作系统一样是计算机的基础软件，是一个大型复杂的软件系统。</li></ul><p>主要功能：</p><ul><li><strong>数据定义功能</strong>：提供数据定义语言（DDL）；定义数据库中的数据对象；</li><li><strong>数据组织、存储和管理</strong>：分类组织、存储和管理各种数据；确定数据在存储级别上的结构和存储方式；实现数据之间的练习；提供多种存取方法提高存取效率；</li><li><strong>数据操纵功能</strong>：提供数据操纵语言（DML）；实现对数据库的基本操作（查询、插入、删除和修改）；</li><li><strong>数据库的事务管理和运行管理</strong>：数据的安全性、完整性、多种对用户数据的并发使用；发生故障后的系统恢复数据库；</li><li><strong>数据库的建立和维护功能</strong>：提供实用程序工具，完成数据库数据批量装载，数据库转储，介质故障恢复，数据库的重组织和性能监视等。</li></ul></li><li><p>数据库系统（DataBase System，DBS）</p><ul><li>是由<strong>数据库</strong>、<strong>数据库管理系统</strong>（及其应用开发工具）、<strong>应用程序</strong>和**数据库管理员（DBA）**组成的存储、管理、处理和维护数据的系统。</li><li>Q: 什么是数据库系统？<ul><li>是指在计算机系统中引入数据库后的系统构成；</li><li>在不引起混淆的情况下常常把数据库系统简称为数据库。</li></ul></li><li>数据库系统的特点？<ul><li>数据结构化；</li><li>数据的共享性高，冗余度小且易扩充；</li><li>数据独立性高；</li><li>数据由数据库管理系统统一管理和控制；</li></ul></li></ul></li></ol><p><strong>数据库的发展阶段</strong></p><ul><li>人工管理阶段：数据不保存、不共享，不具有独立性。</li><li>文件系统阶段：可保存，但共享性差，冗余度大，独立性差</li><li>数据库管理系统：数据库系统的出现使信息系统从以 加工数据的程序 为中心转向围绕 共享的数据库 为中心的新阶段<ul><li>数据的共享性高、冗余度低且易扩充：数据共享可以大大减少数据冗余，节约存储空间数据独立性高</li><li>物理独立性：是指用户的应用程序与数据库中数据的物理存储是相互独立的。<br>逻辑独立性：是指用户的应用程序与数据库的逻辑结构是相互独立的。</li></ul></li></ul><h2 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h2><blockquote><p>数据模型是对现实世界数据特征的抽象。</p></blockquote><p>数据模型分为两类（两个不同的层次）</p><ul><li><p>概念模型，也称信息模型；</p><blockquote><p>它是按用户的观点来对数据和信息建模，用于数据库设计</p></blockquote><ul><li>实体Entity：客观存在并相互区别的事物称为实体。</li><li>属性：实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。</li><li>码：唯一标识实体的属性集称为码。</li><li>实体型：用实体名及其属性名集合来抽象和刻画同类实体称为实体型。</li><li>实体集：同一类型实体的集合称为实体集</li><li>联系Relation：现实世界中事物内部以及事物之间的联系在信息世界中反映为<strong>实体（型）内部的联系</strong>和<strong>实体（型）之间的联系</strong>；<ul><li>实体内部的联系：是指组成实体的各属性之间的联系；</li><li>实体之间的联系：通常是指不同实体集之间的联系；实体之间的联系有一对一（1：1），一对多（1：n），多对多（m：n）。</li></ul></li></ul></li><li><p>逻辑模型和物理模型。</p><ul><li><p>逻辑模型∶它是按<strong>计算机系統</strong>的观点对数据建模，主要用于数据库管理系统的实现。主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等</p><blockquote><p>按计算机系统的观点对数据建模，用于DBMS实现。</p></blockquote></li><li><p>物理模型：是对数据最底层的抽象，它描述数据在系统內部的表示方法和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向<strong>计算机系统</strong>的。</p></li></ul></li></ul><p>数据模型由三部分组成:</p><ol><li><p>数据结构–描述系统的静态特征；</p></li><li><p>数据操作–描述系统的动态特征；</p></li><li><p>完整性约束。</p><p>完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则。</p></li></ol><h3 id="层次模型网状模型"><a class="markdownIt-Anchor" href="#层次模型网状模型"></a> 层次模型，网状模型</h3><p>常用的数据模型：</p><ul><li>格式化模型：层次模型，网状模型。</li><li>关系模型：最常用的模型。</li><li>对象模型：面向对象数据模型，对象关系数据模型。</li></ul><p><strong>层次模型</strong></p><blockquote><p>用树形结构来表示各类实体以及实体间的联系。</p></blockquote><p>表示方式：</p><ol><li>实体型：用记录类型描述每个结点表示一个记录类型（实体）；</li><li>属性：用字段描述每个记录类型可包含若干个字段；</li><li>联系：用结点之间的连线表示记录类型之间的一对多的父子联系</li></ol><p>层次模型的优缺点</p><p>1）优点</p><p>层次模型的数据结构比较简单清晰；<br>查询效率高，性能优于关系模型，不低于网状模型；<br>层次数据模型提供了良好的完整性支持；<br>2）缺点</p><p>结点之间的多对多联系表示不自然；<br>对插入和删除操作的限制多，应用程序的编写比较复杂；<br>查询子女结点必须通过双亲结点；<br>层次数据库的命令趋于程序化。</p><h3 id="关系模型"><a class="markdownIt-Anchor" href="#关系模型"></a> 关系模型</h3><ul><li>在<strong>用户的观点</strong>下，关系模型中数据的逻辑结构是一张二维表。</li><li>关系必须是规范化的，满足一定的规范条件。</li><li>最基本的规范条件是关系的每一个分量必须是一个不可再分的数据项，不允许表中还有表。</li></ul><p>注：关系数据模型是目前最重要的一种数据模型，它的三个要素分别是数据结构、关系操作、完整性约束</p><p><strong>数据结构</strong></p><p>关系：一个关系对应通常说的一张表。<br>元组：表中的一行。<br>属性：表中的一列。<br>码：也称码键，表中的某个属性组<br>域：是一组具有相同数据类型的<strong>值的集合</strong>：学生年龄属性的域（15-45岁）、性别的域（男、女）<br>分量：元组中的一个属性。<br>关系模式：对关系的描述</p><p><img src="/2021/10/12/ZJU开学摸底考试——数据库概论复习/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B.png" alt="关系模型"></p><p>注：**关系数据模型的基本数据结构是？**A:关系</p><p>关系必须是规范化的，满足一定的规范条件。最基本的规范条件：关系的每一个 分量必须是一个不可分的数据项，<strong>不允许表中还有表</strong>。</p><p><strong>关系模型的操纵与完整性约束</strong></p><p>（1）数据结构是集合操作集合操作，操作对象和操作结果都是关系。<br>（2）提高了数据的独立性，提高了用户生产率。<br>（3）关系的完整性约束条件？<br>实体完整性，参照完整性；（前两者为关系的两个不变性）用户定义的完整性。</p><p><strong>关系模型的优缺点</strong></p><p>（1）优点</p><ul><li>建立在严格的数学概念的基础上；</li><li>概念单一；<ul><li>实体和各类联系都用关系来表示</li><li>对数据的检索结果也是关系</li></ul></li><li>关系模型的存取路径对用户透明；<ul><li>具有更高的数据独立性，更好的安全保密性</li><li>简化了程序员的工作和数据库开发建立的工作</li></ul></li></ul><p>（2）缺点</p><ul><li>存取路径对用户透明，查询效率往往不如格式化数据模型；</li><li>为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的复杂性。</li></ul><h2 id="数据库系统的结构"><a class="markdownIt-Anchor" href="#数据库系统的结构"></a> 数据库系统的结构</h2><p>从数据库应用开发人员角度看：数据库系统采用<strong>三级模式</strong>结构，是数据库系统内部的系统结构<br>从数据库最终用户角度看：数据库系统的结构有：</p><ul><li>单用户结构</li><li>主从式结构</li><li>分布式结构</li><li>客户-服务器</li><li>浏览器-应用服务器/数据服务器</li></ul><p><strong>三级模式-二级映像</strong></p><p>模式(Schema):</p><ul><li>是对数据库逻辑结构和特征的描述</li><li>是型的描述，不涉及具体值</li><li>模式是相对稳定的</li></ul><p>实例（Instance）</p><ul><li>数据库某一时刻的状态——<strong>模式的一个具体值</strong></li><li>同一个模式可以有很多实例</li><li>实例随数据库中的数据的更新而变动</li></ul><p>三级模式：</p><ul><li>外模式（子模式or用户模式）<ul><li>数据库用户使用的<strong>局部数据的逻辑结构</strong>和特征的描述<br><strong>数据库用户</strong>的数据视图，是与某一应用有关的数据的逻辑表示</li><li><img src="/2021/10/12/ZJU开学摸底考试——数据库概论复习/%E5%A4%96%E6%A8%A1%E5%BC%8F.png" alt="外模式"></li></ul></li><li>模式（逻辑模式）<ul><li>数据库中<strong>全体数据的逻辑结构</strong>和特征的描述<br><strong>所有用户</strong>的公共数据视图</li><li><img src="/2021/10/12/ZJU开学摸底考试——数据库概论复习/%E6%A8%A1%E5%BC%8F.png" alt="模式"></li></ul></li><li>内模式（存储模式）<ul><li>是数据物理结构和存储方式的描述</li><li>是数据在数据库内部的表示方式</li></ul></li></ul><p>二级映射</p><ul><li><p>外模式/模式 映射：保证数据的逻辑独立性</p><ul><li>当模式改变时，数据库管理员对外模式/模式映像作相应改变，使外模式保持不变</li><li>应用程序是依据数据的外模式编写的，应用程序不必修，保证了数据与程序的逻辑独立性，简称<strong>数据的逻辑独立性</strong></li></ul></li><li><p>模式/内模式 映射：保证数据的物理独立性</p><ul><li><p>定义了数据全局逻辑结构与存储结构之间的对应关系。<br>如，说明某个逻辑记录对应何种存储结构。</p></li><li><p>数据库中模式/内模式映象是唯一的。</p></li><li><p>保证<strong>数据的物理独立性</strong><br>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式/内模式映象，使模式保持不变。</p><p>模式不变，则应用程序不变。保证了数据与程序的物理独立性，简称数据的物理独立性。</p></li></ul></li></ul><h2 id="码"><a class="markdownIt-Anchor" href="#码"></a> 码</h2><ul><li>候选码（超级码）就就是可以区别一个元组（即表中的一行数据）的属性或属性的集合。候选码是最小的超码<ul><li>如何选出候选码？<ol><li>只出现在左边的一定是候选码</li><li>只出现在右边的一定不是候选码</li><li>左右都出现的不一定</li><li>左右都不出现的一定是候选码</li><li>再求确定的候选码的闭包，如果可以推出全部，那么当前确定的就是候逐码，否则你要吧每一个可能的值放进当前确定的候选码里面进行求闭包</li></ol></li></ul></li><li>主码：从候选码里面任意跳出一个作为主码</li><li>主属性：包含在所有候选码的属性比如 ABCDE</li><li>非主属性：不包含在候选码中的属性，上题为G</li><li>全码：所有的属性都是主码</li></ul><h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2><p>Q:为什么要引入范式？</p><p>1数据冗余<br>2更新异常<br>3插入异常<br>4删除异常</p><p>A: 设计关系数据库时，遵从不同的规范要求，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式<strong>数据库冗余越小</strong>。</p><p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，又称完美范式）。<br>一般来说，数据库只需满足第三范式（3NF）就行了。</p><ul><li>1NF:所有字段值都是不可分解的原子值</li><li>2NF:不包含非主属性对码的部分函数依赖：一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中</li><li>3NF:不包含非主属性对码的传递函数依赖确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</li><li>BCNF:消除每一属性对候选键的传递依赖，BCNF是修正的第三范式</li></ul><p>函数依赖简单点说就是：某个属性集决定另一个属性集时，称另一属性集依赖于该属性集。</p><h2 id="公理系统"><a class="markdownIt-Anchor" href="#公理系统"></a> 公理系统</h2><p>Armstrong公理系统（ Armstrongs axiom）设U为属性集总体，F是U上的一组函数依赖，于是有关系模式R(U,F)，对R&lt;U,F&gt;来说有以下的推理规则</p><ul><li>A1自反律（ reflexivity rule）：若 Y∈X∈U，则X→Y为F所蕴涵。</li><li>A2增广律（ augmentation rule）：若X→y为F所蕴涵，且Z∈U，则XZ→Yz为F所蕴涵。</li><li>A3传递律（ transitivity rule）：若X→Y及P→z为F所蕴涵，则X→Z为F所蕴涵</li></ul><p>根据A1、A2、A3这三条推理规则可以得到下面三条很有用的推理规则。</p><ul><li>合并规则（ union rule）：由X→Y,X→Z，有X→YZ</li><li>伪传递规则（ pseudo transitivity rule）：由X→Y,WY→Z，有X→乙</li><li>分解规则（ decomposition rule）：由X→Y及Z∈Y，有X→Z。</li></ul><p><strong>依赖</strong></p><p>Q：什么是依赖？<br>A：依赖是指关系中一个或一组属性的值可以决定其它属性的值比如A→&gt;B这就是一个依赖<br>Q: 如何求最小依赖集？<br>1）拆右边为多个元素的比如A-&gt;BCH拆为A&gt;B和A-&gt;C<br>2）出去当前元素，求它的闭包，把集合里面所有元素都弄完<br>3）左边最小化（通过遮住元素来看能不能退岀其他元素）比如BCD，遮住B看能退出CD吗，遮住C能退出BD吗遮住D看能退出BC吗</p><h1 id="关系型数据库"><a class="markdownIt-Anchor" href="#关系型数据库"></a> 关系型数据库</h1><h2 id="关系模型-2"><a class="markdownIt-Anchor" href="#关系模型-2"></a> 关系模型</h2><p><strong>关系数据结构</strong></p><p><img src="/2021/10/12/ZJU开学摸底考试——数据库概论复习/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="关系数据结构"></p><p>关系模式（ Relation Schema）是型；关系是值</p><p>关系模式是对关系的描述</p><ul><li>元组集合的结构<br>●属性构成<br>●属性来自的域<br>●属性与域之间的映象关系</li><li>完整性约束条件</li></ul><p>关系模式可以形式化地表示为：R（U, D, DOM, F）</p><table><thead><tr><th>R</th><th>关系名</th></tr></thead><tbody><tr><td>U</td><td>组成该关系的属性名集合</td></tr><tr><td>D</td><td>U中属性所来自的域</td></tr><tr><td>DOM</td><td>属性向域的映象集合</td></tr><tr><td>F</td><td>属性间数据的依赖关系的集合</td></tr></tbody></table><p>关系模式<br>■对关系的描述<br>■静态的、稳定的<br>关系<br>■关系模式在某一时刻的状态或内容<br>■动态的、随时间不断变化的</p><p><strong>关系完整性约束</strong></p><ul><li>实体完整性和参照完整性<br>关系模型<strong>必须满足</strong>的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持<ul><li>实体完整性（ Entity Integrity）<ul><li>关系的主属性不能取空值</li></ul></li><li>参照完整性：<ul><li>若属性（或属性组）F是基本关系R的外码，他与基本关系S的主码K相对应（基本关系R和S也可以是同一个关系），则对于R中每个元组在F上的取值必须为：或取空值（F的每个属性值均为空值）；或者等于S中某个元组的主码值。</li><li>案例<ul><li>1:学生(学号，姓名，性别，年龄，系号)<br>2:系(系号，系名，系主任)<br>学生关系的属性“系号”与系关系的主码“系号”相对应，因此，“系号”属性是学生<br>关系的外码。这里系关系是被参照关系，学生关系为参照关系；学生关系中的每个元组的“系号”属性只能取下面两类值：<strong>空值</strong>或<strong>系关系中“系号”已经存在的值。</strong></li><li>1.学生(学号，姓名，性别，年龄，系号，班长学号)<br>学生关系的“班长学号”与其主码“学号”形成参照和被参照的<strong>自身参照</strong>关系，即“班<br>长学号”为学生关系的外码。学生关系中的每个组的“班长学号”属性只能取下面两类值：<br><strong>空值</strong>或<strong>学生关系中“学号”已经存在的值</strong>。</li></ul></li></ul></li></ul></li><li>用户定义的完整性<ul><li>应用领域需要遵循的约束条件，体现了具体领域中的语义约束</li><li>用户对数据自定义的域约束值，如“学分”属性只能取值{1,2,3,4}</li></ul></li></ul><p><strong>域–&gt;笛卡尔积</strong></p><p>所有域的所有取值的任意组合<br>笛卡尔积可以看着是关系的“域”。</p><p>笛卡尔积的表示方法</p><ul><li>笛卡尔积可表示为一张二维表</li><li>表中的每行对应一个元组，表中的每列对应一个域</li></ul><h2 id="关系代数"><a class="markdownIt-Anchor" href="#关系代数"></a> 关系代数</h2><p><strong>关系代数语言</strong>:用对关系的运算来表达查询要求</p><p><strong>关系演算语言</strong>：用谓词来表达查询要求</p><ul><li>元组关系演算语言<br>●谓词变元的基本对象是元组变量<br>●代表：APLHA,QUEL</li><li>域关系演算语言<br>●谓词变元的基本对象是域变量<br>●代表：QBE</li></ul><p><strong>具有关系代数和关系演算双重特点的语言</strong><br>■代表：SQL（ Structured Query Language）</p><blockquote><p>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询</p></blockquote><p>运算对象是关系<br>运算结果亦为关系<br>关系代数的运算符有两类：集合运算符和专门的关系<br>运算符</p><h3 id="关系操作关系代数运算"><a class="markdownIt-Anchor" href="#关系操作关系代数运算"></a> 关系操作(关系代数运算)</h3><blockquote><p>插入、查询、删除、修改<br>其中查询操作分为：选择、投影、连接、除法、并、差、交、笛卡尔积<br>五种基本关系代数运算：<strong>选择、投影、并、差、笛卡尔积</strong></p></blockquote><ul><li>∪</li><li>∩</li><li><ul><li></li></ul></li></ul><p>以上三个都需要具有相同的属性（相同目），结果的属性也是一样的</p><ul><li>笛卡尔积</li></ul><p>两个分别为n目和m目的关系R和S的笛卡尔积是一个（n + m）列的元组的集合。若R有k1个元组，S有k2个元组，则R和S的笛卡尔积有k1 * k2个元组。</p><p><strong>选择和投影的区别</strong></p><p>选择的是一行记录，投影是你所需的某个字段，两者相结合为最终结果.</p><p>选择是从行的角度进行的运算；投影操作是从列的角度进行的运算。选择是在关系R中选择满足给定条件的诸元组，投影是从R中选择出若干属性列组成新的关系。</p><p><strong>连接：</strong></p><ul><li>自然连接：把共同的属性进行等值连接。<ul><li>★先把所有属性去重列出来，将等值的共同属性填入后，补充其他属性值</li><li>悬浮元组（ Dangling tuple）：两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组。</li></ul></li><li>外连接（ Outer Join）：如果把悬浮元组也保存在结果关系中，而在其他属性上填空值（Nu1U），就叫做外连接</li><li>左外连接（ LEFT OUTER J0IN或 LEFT J0IN）：只保留左边关系R中的悬浮元组</li><li>右外连接（ RIGHT0 DUTER J0IN或 RIGHT J0IN）：只保留右边关系S中的悬浮元组</li></ul><p><strong>除</strong></p><p>保留R中满足S的，而且R中列要去掉S的列</p><p>注：</p><ul><li>关系中，属性个数称为「度」或「目」，3度表示这个表有3列。</li><li>关系中元组的个数称为「基数」。</li></ul><p><strong>关系完整性</strong></p><ol><li>实体完整性：主码唯一且非空</li><li>参照完整性：外码要么为空，要么对应另一表的主码</li><li>用户定义完整性：你自己写的要完整比如学号多少姓名班级专业之类</li></ol><p><strong>关系代数</strong></p><blockquote><p>是一种抽象的查询语言，它用对关系的运算来表达查询。<br>三大要素：运算对象（关系）、运算符（集合运算符和专门的关系运算符）和运算结果（关系）</p></blockquote><h2 id="sql语言"><a class="markdownIt-Anchor" href="#sql语言"></a> SQL语言</h2><blockquote><p>Structure Query Language，结构化查询语言，</p></blockquote><ul><li>数据定义语言DDL（ Data Ddefinition Language）sQL数据定义语言主要用来定义逻辑结构，包括定义基表，视图和索引。<br>删除表、定义表、修改表</li><li>数据查询语言DQL（ Data Query Language）：s0L的数据查询语言主要用来对数据库中的各种数据对象进行<strong>查询</strong>。</li><li>数据操纵语言DML（ Data Manipulation Language）：s0L的数据操纵语言，用于改变数据库中的数据，包括<strong>插入，删除，修改</strong></li><li>数据控制功能DCL（ Data Control Language）：s0L的数据控制语言，对表和视图的授权，完整性规则的描述以及<strong>事务</strong>开始和结束等控制语句。</li></ul><p><strong>SQL语言特点</strong></p><ul><li>综合统一（独立完成数据库生命周期中的全部活动，包括定义关系模式、录入数据、建立数据库、査询、更新、维护、数据库重构、数据库安全）</li><li>高度非过程化（用户只需提出“做什么”，而不必指明“怎么做”。）<ul><li>非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径。</li><li>SQL只要提出“做什么”，无须了解存取路径</li><li>存取路径的选择以及SQL的操作过程由系统自动完成</li></ul></li><li>面向集合的操作方式（SQL采用集合操作方式）<ul><li>非关系数据模型采用面向记录的操作方式，操作对象是一条记录</li><li>SQL采用集合操作方式</li><li>操作对象、查找结果可以是元组的集合</li><li>一次插入、删除、更新操作的对象可以是元组的集合</li></ul></li><li>以同一种语法结构提供两种使用方式（S0L既是自含式（独立的）语言，又是嵌入式语言。SQ语句能够嵌入到高级语言程序中，）</li><li>语言简洁，易学易用（s0L语言语法简单，接近英语口语，因此容易学习，也容易使用。）<ul><li>SQL功能性极强，完成核心功能只用了9个动词：SELECT（数据查询）；CREATE、ALERT、INSERT（数据定义）；DROP、UPDATE、DELETE（数据操纵）；GRANT、REVOKE(数据控制)</li></ul></li></ul><h2 id="sql的基本概念"><a class="markdownIt-Anchor" href="#sql的基本概念"></a> SQL的基本概念</h2><p><img src="/2021/10/12/ZJU开学摸底考试——数据库概论复习/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%BC%8F.png" alt="关系型数据库模式"></p><p><strong>基本表</strong></p><ul><li>本身独立存在的表</li><li>SQL中一个关系就对应一个基本表</li><li>一个（或多个）基木表对应一个存储文件</li><li>一个表可以带若干索引</li></ul><p><strong>视图</strong></p><p>概念</p><ul><li>从一个或几个基本表导出的表</li><li>数据库中只存放视图的定义而不存放视图对应的数据</li><li>视图是一个虚表</li><li>用户可以在视图上再定义视图</li></ul><h1 id="数据库安全性"><a class="markdownIt-Anchor" href="#数据库安全性"></a> 数据库安全性</h1><h2 id="数据库的不安全因素"><a class="markdownIt-Anchor" href="#数据库的不安全因素"></a> 数据库的不安全因素</h2><ul><li>非授权用户对数据库的恶意存取和破坏<ul><li>一些黑客（ Hacker）和犯罪分子在用户存取数据库时猎取用户名和用户口令，然后假冒合法用户偷取、修改甚至破坏用户数据。</li><li>数据库管理系统提供的安全措施主要包括用户身份鉴别、存取控制和视图等技术。</li></ul></li><li>数据库中重要或敏感的数据被泄露<ul><li>黑客和敌对分子千方百计盗窃数据库中的重要数据，些机密信息被暴露</li><li>数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等。</li><li>审计日志分析</li></ul></li><li>安全环境的脆弱性</li></ul><h2 id="安全性控制"><a class="markdownIt-Anchor" href="#安全性控制"></a> 安全性控制</h2><h3 id="用户身份鉴别"><a class="markdownIt-Anchor" href="#用户身份鉴别"></a> 用户身份鉴别</h3><ul><li>静态口令</li><li>动态口令</li><li>智能卡鉴别</li><li>生物特征鉴别</li></ul><h3 id="存取控制"><a class="markdownIt-Anchor" href="#存取控制"></a> 存取控制</h3><p>机制组成</p><ul><li>定义用户权限</li><li>合法权限检查</li></ul><h4 id="自主存取控制dac"><a class="markdownIt-Anchor" href="#自主存取控制dac"></a> 自主存取控制（DAC）：</h4><ul><li>用户对不同的数据对象有不同的存取权限</li><li>不同的用户对同一对象也有不同的权限</li><li>用户还可将其拥有的存取权限转授给其他用户</li></ul><p>通过SQL的 GRANT语句（权限授予）和 REVOKE语句（权限回收）实现</p><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>语句的一般格式</span><br><span class="line"><span class="keyword">GRANT</span>&lt;权限&gt;[&lt;权限&gt;]</span><br><span class="line"><span class="keyword">ON</span>&lt;对象类型&gt;&lt;对象名&gt;&lt;对象类型&gt;&lt;对象名</span><br><span class="line"><span class="keyword">To</span>&lt;用户&gt;,【&lt;用户&gt;】</span><br><span class="line">【<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>】；<span class="comment">/** 指定该语句表示可以再转授权限*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">PRIVILEGES</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student Course</span><br><span class="line"><span class="keyword">TO</span> U2. U3</span><br><span class="line"></span><br><span class="line"><span class="keyword">REVOKE</span>语句的一般格式为：</span><br><span class="line"><span class="keyword">REVOKE</span>&lt;权限&gt;[,&lt;权限&gt;]</span><br><span class="line"><span class="keyword">ON</span>&lt;对象类型&gt;&lt;对象名&gt;【&lt;对象类型&gt;&lt;对象名&gt;】</span><br><span class="line"><span class="keyword">FROM</span>&lt;用户&gt;【&lt;用户&gt;】. [<span class="keyword">CASCADE</span>| RESTRICT]；</span><br><span class="line"></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">UPDATE</span>（Sno）</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">FROM</span> U4</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/10/12/ZJU开学摸底考试——数据库概论复习/%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E5%AF%B9%E8%B1%A1.png" alt="存取控制对象"></p><p>数据库角色：被命名的一组与数据库操作相关的权限</p><ul><li>角色是权限的集合</li><li>可以为一组具有相同权限的用户创建一个角色</li><li>简化授权的过程</li></ul><p>使用角色管理数据库权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** S1.角色创建*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> &lt;角色名&gt;</span><br><span class="line"><span class="comment">/** S2.对角色授权*/</span></span><br><span class="line"><span class="keyword">GRANT</span>&lt;权限&gt;[&lt;权限&gt;]</span><br><span class="line"><span class="keyword">ON</span>&lt;对象类型&gt;对象名</span><br><span class="line"><span class="keyword">To</span>&lt;角色&gt;【&lt;角色&gt;】</span><br><span class="line"><span class="comment">/** 将一个角色授予其他的角色或用户*/</span></span><br><span class="line"><span class="keyword">GRANT</span>&lt;角色<span class="number">1</span>&gt;[&lt;角色<span class="number">2</span>&gt;]</span><br><span class="line"><span class="keyword">To</span>&lt;角色<span class="number">3</span>&gt;【&lt;用户<span class="number">1</span>&gt;]</span><br><span class="line">&lt;<span class="keyword">WITH</span> <span class="keyword">ADMIN</span> <span class="keyword">OPTION</span>]</span><br><span class="line"><span class="comment">/** 角色权限的收回*/</span></span><br><span class="line"><span class="keyword">REVOKE</span>&lt;权限&gt;&lt;权限习</span><br><span class="line"><span class="keyword">ON</span>≤对象类型&gt;&lt;对象名</span><br><span class="line"><span class="keyword">FROM</span>&lt;角色&lt;角色&gt;</span><br></pre></td></tr></table></figure><p>存在的缺点：可能存在数据的无意泄露：自主存取控制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记</p><h4 id="强制存取控制mac"><a class="markdownIt-Anchor" href="#强制存取控制mac"></a> 强制存取控制（MAC）：</h4><ul><li>保证更高程度的安全性</li><li>用户不能直接感知或进行控制</li><li>适用于对数据有严格而固定密级分类的部门<ul><li>军事部门</li><li>政府部门</li></ul></li></ul><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类</p><ul><li>主体是系统中的活动实体<br>■数据库管理系统所管理的实际用户<br>■代表用户的各进程</li><li>客体是系统中的被动实体，受主体操纵<br>■文件、基本表、索引、视图</li></ul><p>敏感度标记（ Label）<br>■对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记（Labe）<br>■敏感度标记分成若干级别<br>●绝密（ Top Secret,Ts）<br>●机密（ Secret,S）<br>●可信（ Confidential,C）<br>●公开（ Public,P）<br>●Ts&gt;=S&gt;=C&gt;=P</p><h3 id="数据库安全性机制视图机制"><a class="markdownIt-Anchor" href="#数据库安全性机制视图机制"></a> <strong>数据库安全性机制——视图机制</strong></h3><p>授予用户查询某些行的权限？</p><ul><li><p>需要用存取谓词来定义用户权限</p></li><li><p>无法直接用 GRANT语句实现</p></li><li><p><strong>可以用视图机制间接地实现</strong></p><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 授予用户查询整个表的权限 */</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">TO</span> U1</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 授予用户查询某些列的权限 */</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>（Sno, Sname）</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">TO</span> U2</span><br></pre></td></tr></table></figure></li><li><p>使用视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Step1. 从基本表上导出数据建立视图 */</span></span><br><span class="line">先建立计算机系学生的视图 Cs Student</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> CS_Student</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">ON</span> CS_STUDENT <span class="keyword">TO</span> U1</span><br><span class="line"><span class="comment">/** Step2. 在视图上进一步定义存取权限 */</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">oN</span> CS_Student</span><br><span class="line"><span class="keyword">To</span> 王平</span><br><span class="line"><span class="keyword">GRANT</span> ALL PRIVILIGES</span><br><span class="line"><span class="keyword">oN</span> CS Student</span><br><span class="line"><span class="keyword">To</span>张明；</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="审计"><a class="markdownIt-Anchor" href="#审计"></a> <strong>审计</strong></h3><ul><li>用一个专用的审计日志（ Audit Log）<br>将用户对数据库的所有操作记录在上面</li><li>审计员利用审计日志<br>监控数据库中的各种行为<br>发现非法存取，发现潜在威胁</li><li>C2以上安全级别的DBMS必须具有审计功能</li></ul><p>可以被审计的事件：</p><ul><li>服务器事件</li><li>系统权限<ul><li>对系统拥有的结构或模式对象进行操作的审计</li><li>要求该操作的权限是通过系统权限获得的</li></ul></li><li>语句事件<br>●对SQL语句，如DDL、DML、DQL及DCL语句的审计</li><li>模式对象事件<br>●对特定模式对象上进行的 SELECT或DML操作的审计</li></ul><p>审计功能的可选性</p><p>■审计很费时间和空间<br>■DBA可以根据应用对安全性的要求，灵活地打开或关<br>闭审计功能<br>■审计功能主要用于安全性要求较高的部门</p><p>demo</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 对修改SC表结构或修改SC表数据的操作进行审计</span><br><span class="line">AUDIT <span class="keyword">ALTER</span>, <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">ON</span> SC</span><br><span class="line">// 取消对SC表的一切审计</span><br><span class="line"><span class="keyword">NOAUDIT</span> <span class="keyword">ALTER</span>, <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">ON</span> SC：</span><br></pre></td></tr></table></figure><h3 id="数据加密"><a class="markdownIt-Anchor" href="#数据加密"></a> <strong>数据加密</strong></h3><p>加密方法</p><ul><li>存储加密<ul><li>透明存储加密： 内核级加密保护方式（性能好，安全完备性高），对用户完全透明</li><li>非透明存储加密：通过多个加密函数实现</li></ul></li><li>传输加密<ul><li>链路加密：报文、报头都加密</li><li>端到端加密：只加密报文</li></ul></li></ul><p>其他安全性保护</p><ul><li>推理控制、</li><li>隐蔽信道</li></ul><h2 id="数据定义"><a class="markdownIt-Anchor" href="#数据定义"></a> 数据定义</h2><blockquote><p>定义数据库的各种“对象”</p></blockquote><ul><li><p>模式定义</p><ul><li><p>定义模式实际上定义了一个命名空间（或者说目录）</p></li><li><p>在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。</p></li><li><p>在 CREATE SCHEMA中可以接受 CREATE TABLE，CREATE VIEW和 GRANT子句。</p></li><li><p>创建：<code>CREATE SCHEMA&lt;模式名&gt; AUTHORIZATION&lt;用户名&gt;【&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;</code></p></li><li><p>删除：<code>DROP SCHEMA&lt;模式名&gt;&lt; CASCADE | RESTRICT&gt;</code><br>■ CASCADE（级联）</p><ul><li>删除模式的同时把该模式中所有的数据库对象全部删除</li></ul><p>■ RESTRICT（限制）</p><ul><li>如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。</li><li>仅当该模式中没有任何下属的对象时才能执行。</li></ul></li></ul></li><li><p>表定义</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE&lt;表名&gt;/*基本表的名称*/</span><br><span class="line">(&lt;列名&gt;&lt;数据类型&gt;【&lt;列级完整性约束条件&gt;】/*组成该表的列*/</span><br><span class="line">【，&lt;列名&gt;&lt;数据类型【&lt;列级完整性约束条件】】</span><br><span class="line">...</span><br><span class="line">【，&lt;表级完整性约束条件&gt;】)</span><br></pre></td></tr></table></figure></li><li><p>&lt;列级完整性约束条件&gt;：涉及相应<strong>属性列</strong>的完整性约束条件<br>&lt;表级完整性约束条件&gt;：涉及<strong>一个或多个属性列</strong>的完整性约束条件<br>如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上。</p></li></ul></li><li><p>视图定义</p></li><li><p>索引定义</p><ul><li><p>建立索引的目的：加快查询速度</p></li><li><p>关系数据库管理系统中常见索引</p><ul><li><p>顺序文件上的索引</p></li><li><p>B+树索引（参见爱课程网3.2节动画《B+树的增删改》）</p></li><li><p>散列（hash）索引</p></li><li><p>位图索引</p></li></ul></li><li><p>特点</p><ul><li>B+树索引具有动态平衡的优点</li><li>HASH索引具有查找速度快的特点</li></ul></li><li><p>关系数据库管理系统自动选择合适的索引作为存取路径，用户不必也不能显式地选择索引</p></li><li><p><code>CREATE[UNIQUE] |[CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;（&lt;列名&gt;【&lt;次序&gt;】【列名&gt;【&lt;次序】】）</code></p><ul><li>&lt;表名&gt;：要建索引的基本表的名字</li><li>索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔</li><li>次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：AsC</li><li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录</li><li>CLUSTER：表示要建立的索引是聚簇索引</li></ul></li><li><p><code>ALTER INDEX&lt;旧索引名&gt; RENAME TO&lt;新索引名&gt;</code></p></li><li></li></ul></li></ul><p><strong>数据字典</strong></p><blockquote><p>数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有对象的定义信息以及一些统计信息</p><p>关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息。</p></blockquote><h1 id="数据库的完整性"><a class="markdownIt-Anchor" href="#数据库的完整性"></a> 数据库的完整性</h1><p><strong>实体完整性</strong></p><p><strong>参照完整性</strong></p><p><strong>用户定义的完整性</strong></p><h2 id="完整性约束命名字句"><a class="markdownIt-Anchor" href="#完整性约束命名字句"></a> 完整性约束命名字句</h2><ul><li><code>CONSTRAINT&lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;</code><ul><li>&lt;完整性约束条件&gt;包括 NOT NULL、 UNIQUE、PRIMARY KEY短语、 FOREIGN KEY短语、 CHECK短语等</li><li>删除：<code>ALTER TABLE Student DROP CONSTRAINT C1</code></li><li>增加:<code>ALTER TABLE Student ADD CONSTRAINT C1 CHECK（Sno BETWEEN 900000 AND 999999</code></li></ul></li></ul><p><strong>域中的完整性限制</strong></p><h2 id="断言"><a class="markdownIt-Anchor" href="#断言"></a> 断言</h2><ul><li>sQL中，可以使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。</li><li>可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。</li><li>断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行</li><li><code>CREATE ASSERTION&lt;断言名&gt;&lt; CHECK子句&gt;</code></li></ul><h2 id="触发器"><a class="markdownIt-Anchor" href="#触发器"></a> <strong>触发器</strong></h2><ul><li>是用户定义在<strong>关系表</strong>上的一类由事件驱动的特殊过程</li><li>任何用户对表的增、删、改操作均由服务器自动激活相应的触发器</li><li>触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力</li></ul><p>定义：</p><ul><li>当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通常是一段SQL存储过程。</li><li>触发器又叫做事件-条件-动作（ event-condition-action）规则</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span>&lt;触发器名&gt; &#123;<span class="keyword">BEFORE</span>| <span class="keyword">AFTER</span>&#125; &lt;触发事件&gt;<span class="keyword">ON</span>&lt;表名&gt;</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span>|<span class="keyword">OLD</span> <span class="keyword">ROW</span> <span class="keyword">AS</span>&lt;变量&gt;</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> &#123;<span class="keyword">ROW</span> | <span class="keyword">STATEMENT</span>&#125;<span class="comment">/** 触发器类型：行级、语句级 */</span></span><br><span class="line">[<span class="keyword">WHEN</span>&lt;触发条件&gt;] &lt;触发动作体&gt;</span><br></pre></td></tr></table></figure><ul><li>只有表的拥有者才能在表上创建触发器</li><li>触发事件：INSERT、UPDATE、DELETE； 或者以上操作的组合； UPDATE OF&lt;触发列&gt;</li><li>触发器类型<ul><li>行级触发器（ FOR EACH ROW）</li><li>语句级触发器（ FOR EACH STATEMENT）</li><li>例子：UPDATE TEACHER SET Deptno=5，假设表 TEACHER有1000行。如果是语句级触发器，那么执行完该语句后，触发动作只发生一次；如果是行级触发器，触发动作将执行1000次</li></ul></li><li>触发条件：<ul><li>触发器被激活时，只有当触发条件为真时触发动作体才执行；否则触发动作体不执行。</li><li>如果省略WHEN触发条件，则触发动作体在触发器激活后立即无条件执行】、</li></ul></li><li>触发动作体：<ul><li>触发动作体可以是一个匿名 PL/SQL过程块，也可以是对已创建存储过程的调用</li><li>如果是行级触发器，用户都可以在过程体中使用NEW和OLD引用事件之后的新值和事件之前的旧值如果是语句级触发器，则不能在触发动作体中使用NEW或OLD进行引用</li><li>如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化</li></ul></li></ul><p>Demo Code:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 当对表Sc的 Grade属性进行修改时，若分数增加了10%则将此次操作记录到下面表中：*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> SC T</span><br><span class="line"><span class="keyword">AFTER</span> <span class="keyword">UPDATE</span> <span class="keyword">OF</span> Grade <span class="keyword">ON</span> SC</span><br><span class="line"><span class="keyword">REFERENCING</span></span><br><span class="line"><span class="keyword">OLD</span> <span class="keyword">row</span> <span class="keyword">As</span> OldTuple</span><br><span class="line"><span class="keyword">NEW</span> <span class="keyword">row</span> <span class="keyword">As</span> NewTuple</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span>（NewTuple Grade &gt;=<span class="number">1.1</span>*<span class="keyword">Old</span> Tuple Grade)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTo</span> Sc_U（Sno, Cno, OldGrade, NewGrade） <span class="keyword">VALUES</span>（OIdTuple.Sno, OldTuple.Cno, oldTuple.Grade, NewTuple.Grade)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**【例522】将每次对表 Student的插入操作所增加的学生个数记录到表 StudentInsertLog中。*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Student <span class="keyword">Count</span></span><br><span class="line">AETER <span class="keyword">INSERT</span> <span class="keyword">ON</span> Student</span><br><span class="line"><span class="keyword">REFERENCING</span></span><br><span class="line"><span class="keyword">NEW</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> DELTA</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">STATEMENT</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> StudentinsertLog（Numbers） <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> DELTA</span><br></pre></td></tr></table></figure><h1 id="数据查询语句"><a class="markdownIt-Anchor" href="#数据查询语句"></a> 数据查询语句</h1><h2 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> <strong>连接</strong></h2><blockquote><p>自然连接的结果：是采用SELECT去掉重复字段的方式实施的</p></blockquote><ul><li>嵌套循环法：</li><li>排序合并法：</li><li>索引连接（嵌套循环的一个变种）</li></ul><p>外连接与普通连接的区别</p><ul><li>普通连接操作只输出满足连接条件的元组</li><li>外连接操作以指定表为连接主体，将主体表中<strong>不满足连接条件的元组一并输出</strong><ul><li>左外连接<br>●列出左边关系中所有的元组</li><li>右外连接<br>●列出右边关系中所有的元组</li></ul></li></ul><h2 id="嵌套查询"><a class="markdownIt-Anchor" href="#嵌套查询"></a> 嵌套查询</h2><blockquote><p>一个 SELECT-FROM-WHERE语句称为一个查询块</p><p>将一个查询块嵌套在另一个查询块的 WHERE子句或 HAVING短语的条件中的查询称为嵌套查询</p></blockquote><p>子查询的限制<br>●不能使用 ORDER BY子句</p><p>嵌套查询求解方法：</p><ul><li>不相关子查询：子查询的查询条件不依赖于父查询<ul><li>由里向外逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件</li></ul></li><li>相关子查询：子查询的查询条件依赖于父查询 （嵌套循环依次从外解决）：<a href="https://www.icourse163.org/learn/RUC-488001?tid=1463039460#/learn/content?type=detail&amp;id=1240163703&amp;sm=1" target="_blank" rel="noopener">demo讲解</a><ul><li><strong>首先取外层查询中表的第一个元组</strong>，根据它与内层查询相关的属性值处理内层査询，若 WHERE子句返回值为真，则取此元组放入结果表</li><li>然后再取外层表的下一个元组</li><li>重复这一过程，直至外层表全部检查完为止</li></ul></li></ul><ol><li>带有N谓词的子查询</li><li>带有比较运算符的子查询</li><li>带有ANY或ALL谓词的子查询</li><li>带有 EXISTS谓词的子查询</li></ol><p>数据更新语句</p><ul><li><p>插入 : INSERT INTO &lt;Table_name&gt;[&lt;属性名&gt;, &lt;属性名&gt;…] VALUES(&lt;常量1&gt;, …)</p><ul><li>指定要插入数据的<strong>表名</strong>及<strong>属性列</strong><ul><li>属性列的顺序可与表定义中的顺序不一致</li></ul></li><li>没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的<strong>顺序一致</strong></li><li>只指定部分属性列：插入的元组在其余属性列上取空值</li></ul></li><li><p>更新：UPDATE&lt;表名&gt;SET&lt;列名&gt;=&lt;表达式&gt;【&lt;列名&gt;=&lt;表达式&gt;】 【WHERE&lt;条件习】；</p><p>■修改指定表中满足 WHERE子句条件的元组<br>■SET子句给出&lt;表达式&gt;的值用于取代相应的属性列<br>■如果省略 WHERE子句，表示要修改表中的所有元组</p><p>关系数据库管理系统在执行修改语句时会检查修改操作是否破坏表上已定义的完整性规则<br>■实体完整性<br>■主码不允许修改<br>■用户定义的完整性</p><ul><li>NOT NULL约束</li><li>UNIQUE约束</li><li>值域约束</li></ul></li><li><p>删除: DELETE FROM &lt;表名&gt; [WHERE&lt;条件&gt;]；<br>■删除指定表中满足 WHERE子句条件的元组WHERE子句<br>■指定要删除的元组<br>■无该子句将会删除表中的全部元组</p></li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><p>HAVING短语与 WHERE子句的区别：</p><ul><li>作用对象不同</li><li>WHERE子句作用于基表或视图，从中选择满足条件的元组</li><li>HAVING短语作用于组，从中选择满足条件的组。、</li></ul><p>Q:怎么理解“自然连接”，它与等值连接有什么不同？</p><p>1、自然连接一定是等值连接，但等值连接不一定是自然连接。<br>2、等值连接要求相等的分量，不一定是公共属性；而自然连接要求相等的分量必须是公共属性。<br>3、等值连接不把重复的属性除去；而自然连接要把重复的属性除去。</p><p>Q:嵌套查询瑞和转换为连接查询？</p><p>不相关子查询，内查询不依赖于外层。执行过程中，首先执行内查询，内查询得到结果不被显示出来，而是传递给外层查询作为外层查询的条件来使用，然后执行外层查询，并显示查询结果。 转为连接查询就是把子查询内表和外部表连接。</p><p>Q:两个查询在什么情况下可以自行UNION操作？</p><p>UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 该命令连接的结果集中有重复的值不会被显示。想忽略重复值，可以使用 union all</p><p>Q:‏关系R中能唯一标识一个元组的是它的</p><ul><li>A.主码</li><li>B.候选码</li><li>D.全码</li></ul><p>Q‍:实体完整性规则检查的内容包括</p><ul><li>检查主码的各个属性值是否为空，只要有一个为空就拒绝插入或修改</li><li>检查主码值是否唯一，如果不唯一就拒绝插入或修改</li></ul><p>在关系数据库中，模式对应的是___C___。</p><p>A.视图和所有基本表 B.视图和部分基本表 C.基本表 D.索引 7 在数据</p><p>数据库常见的四种故障</p><p>(1) 事务内部的故障：事务内部故障可分为预期的和非预期的，其中大部分的故障都是非预期的。预期的事务内部故障是指可以通过事务程序本身发现的事务内部故障; 非预期的事务内部故障是不能由事务程序处理的，如运算溢出故障、并发事务死锁故障、违反了某些完整性限制而导致的故障等。</p><p>(2) 系统故障：系统故障也称为软故障，是指数据库在运行过程中，由于硬件故障、数据库软件及操作系统的漏洞、突然停电灯情况，导致系统停止运转，所有正在运行的事务以非正常方式终止，需要系统重新启动的一类故障。这类事务不破坏数据库，但是影响正在运行的所有事务。</p><p>(3) 介质故障：介质故障也称为硬故障，主要指数据库在运行过程中，由于磁头碰撞、磁盘损坏、强磁干扰、天灾人祸等情况，使得数据库中的数据部分或全部丢失的一类故障。</p><p>(4) 计算机病毒故障：计算机病毒故障是一种恶意的计算机程序，它可以像病毒一样繁殖和传播，在对计算机系统造成破坏的同时也可能对数据库系统造成破坏(破坏方式以数据库文件为主) 。</p><p>Q:要实现记录的物理顺序与索引项次序一致，应选择的索引类型是（）。<br>A.HASH 索引<br>B.聚簇索引<br>C.B+树索引<br>D.单一索引</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库概论&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据库概论&quot;&gt;&lt;/a&gt; 数据库概论&lt;/h1&gt;
&lt;h2 id=&quot;数据库的4个基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据库的4个基本概念
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>XML语法规则笔记</title>
    <link href="https://nymrli.top/2021/10/09/XML%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2021/10/09/XML语法规则笔记/</id>
    <published>2021-10-09T11:37:54.000Z</published>
    <updated>2021-10-09T13:04:17.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介：</h2><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）。</li><li>XML 是一种很像HTML的标记语言。</li><li>XML 的设计宗旨是传输数据，而不是显示数据。</li><li>XML 标签没有被预定义。您需要自行定义标签。</li><li>XML 被设计为具有自我描述性。</li><li>XML 是 W3C 的推荐标准。</li></ul><h2 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点：</h2><ul><li>所有 XML 元素都须有关闭标签</li><li>XML 标签对大小写敏感</li><li>XML 文档必须有根元素</li><li>XML 的属性值须加引号，双引号、单引号都可以</li><li>实体引用：<code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp</code>, <code>&amp;apos</code>, <code>&amp;quot</code></li><li>在 XML 中，空格会被保留， 但多余的空格会被合并成一个</li><li>XML 以 LF 存储换行</li></ul><h2 id="用途"><a class="markdownIt-Anchor" href="#用途"></a> 用途：</h2><ul><li>XML 把数据从 HTML 分离： 改变数据时不需要对HTML进行改变</li><li>XML 简化数据共享</li><li>XML 简化数据传输：通过 XML，可以在不兼容的系统之间轻松地交换数据。</li><li>XML 简化平台的变更</li><li>XML 使您的数据更有用</li></ul><h2 id="xml-元素"><a class="markdownIt-Anchor" href="#xml-元素"></a> XML 元素</h2><p>指的是从（且包括）开始标签直到（且包括）结束标签的部分。</p><p>元素可包含其他元素、文本或者两者的混合物。元素也可以拥有<u>属性</u>。</p><p><strong>XML 命名规则</strong></p><p>XML 元素必须遵循以下命名规则：</p><ul><li>名称可以含字母、数字以及其他的字符</li><li>名称不能以数字或者标点符号开始</li><li>名称不能以字符 “xml”（或者 XML、Xml）开始</li><li>名称不能包含空格</li></ul><p>可使用任何名称，没有保留的字词。</p><p><strong>最佳命名习惯</strong></p><p>使名称具有描述性。使用下划线的名称也很不错。</p><p>名称应当比较简短，比如：<code>&lt;book_title&gt;</code>，而不是：<code>&lt;the_title_of_the_book&gt;</code>。</p><ul><li>避免 “-” 字符。如果您按照这样的方式进行命名：“first-name”，一些软件会认为你需要提取第一个单词。</li><li>避免 “.” 字符。如果您按照这样的方式进行命名：“<a href="http://first.name" target="_blank" rel="noopener">first.name</a>”，一些软件会认为 “name” 是对象 “first” 的属性。</li><li>避免 “:” 字符。冒号会被转换为命名空间来使用。</li></ul><h2 id="xml-命名空间xml-namespaces"><a class="markdownIt-Anchor" href="#xml-命名空间xml-namespaces"></a> XML 命名空间（XML Namespaces）</h2><blockquote><p>在 XML 中，元素名称是由开发者定义的，当<strong>两个不同的文档</strong>使用<strong>相同的元素名</strong>时，就会发生命名冲突。</p></blockquote><p>使用命名空间案例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rtdBusConfig</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">"http://com.cgs/rtd-bus.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://com.cgs/rtd-bus.xsd rtd-bus.xsd"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"producer"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">persistentPath</span>=<span class="string">"./rtdcache/producer"</span> </span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">rtdBusConfig</span>&gt;</span></span><br></pre></td></tr></table></figure><p>w3c案例: <a href="https://www.w3school.com.cn/xml/xml_namespaces.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/xml/xml_namespaces.asp</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">f:table</span> <span class="attr">xmlns:f</span>=<span class="string">"http://www.w3school.com.cn/furniture"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">f:name</span>&gt;</span>African Coffee Table<span class="tag">&lt;/<span class="name">f:name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">f:width</span>&gt;</span>80<span class="tag">&lt;/<span class="name">f:width</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">f:length</span>&gt;</span>120<span class="tag">&lt;/<span class="name">f:length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">f:table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在根标签中添加了一个 xmlns:f 属性，xmlns 代表的是 xml namespace，f是我们声明的命名空间前缀，f本身并没有意义，可以将它理解为是 <a href="http://www.atguigu.com/xml/b" target="_blank" rel="noopener">http://www.atguigu.com/xml/b</a> 的一个别名，我们在标签中使用 f，就相当于使用这个 uri 地址。一旦使用了f 这个前缀，就代表这个标签是属于 <a href="http://www.atguigu.com/xml/b" target="_blank" rel="noopener">http://www.atguigu.com/xml/b</a> 这个唯一标识命名空间下的元素。</p><p>我们还可以在一个文档中定义多个命名空间，如下的语法也是没有问题的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b:book</span> <span class="attr">xmlns:b</span>=<span class="string">"http://www.atguigu.com/xml/b"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:a</span>=<span class="string">"http://www.atguigu.com/xml/a"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>more: <a href="https://www.cnblogs.com/xiaomaomao/p/13968976.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaomaomao/p/13968976.html</a></p><p><strong>XML Namespace (xmlns) 属性</strong></p><p>XML 命名空间属性被放置于元素的开始标签之中，并使用以下的语法：<code>xmlns&lt;:namespace-prefix&gt;=&quot;namespaceURI&quot;</code></p><p>当命名空间被定义在<strong>元素的开始标签</strong>中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。</p><p>如果没有<code>:namespace-prefix</code>，为<code>xmlns=&quot;namespaceURI&quot;</code>，则采用的是默认的命名空间（Default Namespaces）</p><p><strong>命名空间的实际应用</strong></p><p>当开始使用 XSL 时，您不久就会看到实际使用中的命名空间。XSL 样式表用于将 XML 文档转换为其他格式，比如 HTML。</p><p>如果您仔细观察下面的这个 XSL 文档，就会看到大多数的标签是HTML标签。非 HTML 的标签都有前缀 xsl，并由此命名空间标示：“<a href="http://www.w3.org/1999/XSL/Transform" target="_blank" rel="noopener">http://www.w3.org/1999/XSL/Transform</a>”：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"ISO-8859-1"</span><span class="meta">?&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:stylesheet</span> <span class="attr">version</span>=<span class="string">"1.0"</span> <span class="attr">xmlns:xsl</span>=<span class="string">"http://www.w3.org/1999/XSL/Transform"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>My CD Collection<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>Artist<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsl:for-each</span> <span class="attr">select</span>=<span class="string">"catalog/cd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">"title"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">"artist"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsl:for-each</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:stylesheet</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="xml语法-处理指令"><a class="markdownIt-Anchor" href="#xml语法-处理指令"></a> XML语法－处理指令</h2><blockquote><p><strong>处理指令，简称PI （processing instruction）。处理指令用来指挥解析引擎如何解析XML文档内容</strong>。例如，在XML文档中可以使用xml-stylesheet指令，通知XML解析引擎，应用css文件显示xml文档内容，标签名为中文时，css不起作用。</p></blockquote><p>如<code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;css文件名.css&quot;?&gt;*</code></p><p><strong>处理指令必须以&quot;<code>&lt;?&quot;作为开头，以&quot;?&gt;</code>&quot;作为结尾</strong>，XML声明语句(<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code>)就是最常见的一种处理指令。</p><h3 id="xml报文头"><a class="markdownIt-Anchor" href="#xml报文头"></a> XML报文头</h3><p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></p><ul><li>第一个是XML的声明，其中version属性是必须写的。</li><li>encoding属性的值表示用于读取文档的字符集，第二个是一个文档定义的描述。</li></ul><h2 id="xml-cdata"><a class="markdownIt-Anchor" href="#xml-cdata"></a> XML CDATA</h2><blockquote><p>由于<strong>所有 XML 文档中的文本均会被解析器解析</strong>，而**只有 CDATA 区段（CDATA section）中的文本会被解析器忽略。**因此对某些不希望被解析的文本时，需要用CDATA嵌套起来。<strong>对于CDATA区域内的内容，XML解析程序不会处理，而是直接原封不动的输出</strong></p></blockquote><blockquote><ul><li>术语 CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。</li><li>CDATA 部分中的所有内容都会被解析器忽略。</li><li>CDATA 部分由<code>&quot;&lt;![CDATA[&quot;</code> 开始，由<code>&quot;]]&gt;&quot;</code>结束：</li></ul></blockquote><p>在 XML 元素中，&quot;&lt;&quot; 和 “&amp;” 是非法的。</p><ul><li>“&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。</li><li>“&amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。</li></ul><p>某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&lt;![CDATA[</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">matchwo</span><span class="params">(a,b)</span></span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span> (a &lt; b &amp;&amp; a &lt; <span class="number">0</span>) then</span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">return</span> <span class="number">1</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">else</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">]]&gt;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="xml-dom"><a class="markdownIt-Anchor" href="#xml-dom"></a> XML DOM</h2><p>DOM 把 XML 文档视为一种树结构。通过这个 DOM 树，可以访问所有的元素。可以修改它们的内容（文本以及属性），而且可以创建新的元素。元素，以及它们的文本和属性，均被视为节点。</p><h2 id="xmlns-xmlnsxsi和xsischemalocation"><a class="markdownIt-Anchor" href="#xmlns-xmlnsxsi和xsischemalocation"></a> xmlns、xmlns:xsi和xsi:schemaLocation</h2><p>POM 文件头示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>初学者看到如上的内容应当有如下困惑点：</p><ul><li>xmlns:xsi , xmlns, xsi:schmeLocation 这些看上去相近的属性是什么含义， 为什么他们的值是不一样的 URL</li><li>这些 URL 是否对应一些可以访问的资源，对于该文件的解析是否会需要下载这些 URL 对应的资源</li></ul><h3 id="xmlnsxsi有什么作用"><a class="markdownIt-Anchor" href="#xmlnsxsi有什么作用"></a> <strong>xmlns:xsi有什么作用？</strong></h3><p>按命名空间的概念来说，<code>xmlns:xsi</code>就是定义了一个命名空间前缀 xsi ，其对应的唯一字符串为 <a href="http://www.w3.org/2001/XMLSchema-instance%E3%80%82" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance。</a> 但是读者会发现， 这个 xmlns:xsi 在不同的 xml 文档中似乎都会出现。 这是因为， xsi 已经成为了一个业界默认的用于 XSD(（XML Schema Definition) 文件的命名空间。 而 XSD 文件（也常常称为 Schema 文件）是用来定义 xml 文档结构的。</p><ul><li>注解： XML 解析器可以根据 一个 XSD 文件的内容来解析另一个 XML 文件， 判断该文件的结构是否和 XSD 文件中定义的一致。 XSD 文件 可以理解为 XML 文档可以自定义的语法或格式检查器。</li></ul><h3 id="xsischemalocation有何作用"><a class="markdownIt-Anchor" href="#xsischemalocation有何作用"></a> xsi:schemaLocation有何作用？</h3><p>xsi:schemaLocation其实是Namespace为http://www.w3.org/2001/XMLSchema-instance里的schemaLocation属性，因为我们一开始声明了<code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</code>，然后再看xsi:schemaLocation的使用：<code>xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</code>,上面这行的语法其实是<code>xsi:schemaLocation = &quot;键&quot; &quot;值&quot;</code><br>即 xsi 命名空间下 schemaLocation 元素的值为一个由空格分开的键值对。</p><p>这里的xsi:schemaLocation（当然一般都使用这个前缀）。它定义了<strong>XML Namespace</strong>和对应的<strong>XSD（Xml Schema Definition）文档的位置</strong>的关系，他们总是成对出现的，通常为两个URI引用对组成，<em>两个URI之间以空白符分隔（空格和换行均可）</em>。</p><ul><li>前一个“键” <a href="http://maven.apache.org/POM/4.0.0" target="_blank" rel="noopener">http://maven.apache.org/POM/4.0.0</a> 指代 【命名空间】， 只是一个全局唯一字符串而已</li><li>后一个值指代 【XSD location URI】 , 这个值指示了前一个命名空间所对应的 XSD 文件的位置， XML Schema Parser处理器可以利用这个信息获取到 XSD 文件， 从而通过 XSD 文件对所有属于 命名空间 <a href="http://maven.apache.org/POM/4.0.0" target="_blank" rel="noopener">http://maven.apache.org/POM/4.0.0</a> 的元素结构进行校验， 因此这个值<strong>必然是可以访问</strong>的， 且<strong>访问到的内容是一个 XSD 文件</strong>的内容</li></ul><p>现在概念懂了，来看个spring的xml例子把</p><p><img src="/2021/10/09/XML语法规则笔记/xsi_schemaLocation.png" alt="xsi_schemaLocation"></p><p>参考：</p><ul><li><a href="https://www.cnblogs.com/osttwz/p/6892999.html" target="_blank" rel="noopener">我来说说XML文件中的xmlns、xmlns:xsi和xsi:schemaLocation、dtd文件的具体含义</a></li><li><a href="https://blog.csdn.net/lengxiao1993/article/details/77914155" target="_blank" rel="noopener">详解 xml 文件头部的 xmlns:xsi</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;XML 指可扩展标记语言（EXtensible Markup Language）。&lt;/li&gt;
&lt;li&gt;XML 是一种很像HTML的
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://nymrli.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Makefile使用记录</title>
    <link href="https://nymrli.top/2021/09/30/makefile%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://nymrli.top/2021/09/30/makefile使用记录/</id>
    <published>2021-09-30T04:16:04.000Z</published>
    <updated>2021-10-09T07:09:23.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="makefile使用记录"><a class="markdownIt-Anchor" href="#makefile使用记录"></a> Makefile使用记录</h1><blockquote><p>Makefile 文件描述了 Linux 系统下 C/C++ 工程的<strong>编译规则</strong>，它用来自动化编译 C/C++ 项目。一旦写编写好 Makefile 文件，只需要一个 make 命令，整个工程就开始自动编译，不再需要手动执行 GCC 命令。===&gt;此外拓展功能不至于C++，其相当于组合一系列Linux命令，因此也可以用来编译其他工程。</p></blockquote><h2 id="什么是makefile"><a class="markdownIt-Anchor" href="#什么是makefile"></a> 什么是Makefile？</h2><p>Windows 下的集成开发环境（IDE）已经内置了 Makefile，或者说会自动生成 Makefile，因此windows下不用去手动编写makefile。但是在 Linux 下的C语言开发会碰到</p><ul><li>S：编译的时候需要链接库的的问题——编译的时候 gcc 只会默认链接一些基本的C语言标准库，很多源文件依赖的标准库都需要我们手动链接，因为有很多的文件，还要去链接很多的第三方库。所以在编译的时候命令会很长，并且在编译的时候我们可能会涉及到文件链接的顺序问题，所以手动编译会很麻烦。<ul><li>A:把要链接的库文件放在 Makefile 中，制定相应的规则和对应的链接顺序。这样只需要执行 make 命令，工程就会自动编译。每次想要编译工程的时候就执行 make ，省略掉手动编译中的参数选项和命令，非常的方便。</li></ul></li><li>S：编译大的工程会花费很长的时间<ul><li>Makefile 支持多线程并发操作，会极大的缩短我们的编译时间，并且当我们修改了源文件之后，编译整个工程的时候，make 命令只会编译我们修改过的文件，没有修改的文件不用重新编译，也极大的解决了我们耗费时间的问题。</li></ul></li></ul><p>使用 Makefile 的方式：首先需要编写好 Makefile 文件，然后在 shell 中执行 make 命令，程序就会自动执行，得到最终的目标文件。</p><h2 id="makefile规则是什么样的"><a class="markdownIt-Anchor" href="#makefile规则是什么样的"></a> makefile规则是什么样的？</h2><p>规则主要是两个部分组成，分别是依赖的关系和执行的命令，其结构如下所示：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">targets: prerequisites</span></span><br><span class="line">    command</span><br><span class="line"><span class="comment"># example:</span></span><br><span class="line"><span class="section">test: test.c</span></span><br><span class="line">&lt;tab&gt; gcc -o test test.c</span><br><span class="line"><span class="comment"># 编译 test.c 文件: test 是的目标文件，也是最终生成的可执行文件。依赖文件就是 test.c 源文件，重建目标文件需要执行的操作是gcc -o test test.c。这就是 Makefile 的基本的语法规则的使用。</span></span><br></pre></td></tr></table></figure><ul><li>targets：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；</li><li>prerequisites：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有；</li><li>command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。</li></ul><h2 id="makfile执行流程"><a class="markdownIt-Anchor" href="#makfile执行流程"></a> makfile执行流程</h2><p>在我们编译项目文件的时候，默认情况下，make 执行的是 Makefile 中的<strong>第一规则</strong>（Makefile 中出现的第一个依赖关系），此规则的第一目标称之为“最终目标”或者是“终极目标”。</p><p>案例分析：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main:main.o test1.o test2.o</span></span><br><span class="line">gcc main.o test1.o test2.o -o main</span><br><span class="line"><span class="section">main.o: main.c test.h</span></span><br><span class="line">gcc -c main.c -o main.o</span><br><span class="line"><span class="section">test1.o: test1.c test.h</span></span><br><span class="line">gcc -c test1.c -o test1.o</span><br><span class="line"><span class="section">test2.o: test2.c test.h</span></span><br><span class="line">gcc -c test2.c -o test2.o</span><br><span class="line"><span class="comment"># 通过 Makefile 我们可以发现，目标 main"在 Makefile 中是第一个目标，因此它就是 make 的终极目标</span></span><br></pre></td></tr></table></figure><p>它的具体工作顺序是：当在 shell 提示符下输入 make 命令以后。 make 读取当前目录下的 Makefile 文件，并将 Makefile 文件中的第一个目标作为其执行的“终极目标”，开始处理第一个规则（终极目标所在的规则）。在我们的例子中，第一个规则就是目标 “main” 所在的规则。规则描述了 “main” 的依赖关系，并定义了链接 “.o” 文件生成目标 “main” 的命令；make 在执行这个规则所定义的命令之前，首先处理目标 “main” 的所有的依赖文件（例子中的那些 “.o” 文件）的更新规则（以这些 “.o” 文件为目标的规则）。</p><p>对这些 “.o” 文件为目标的规则处理有下列三种情况：</p><ul><li>目标 “.o” 文件不存在，使用其描述规则创建它；</li><li>目标 “.o” 文件存在，<s>目标 “.o” 文件所依赖的 “.c” 源文件和 “.h” 文件中的任何一个比目标 “.o” 文件**“更新”**</s>（依赖的.h、.c在上一次 make 之后被修改）。则根据规<strong>则重新编译生成</strong>它；</li><li>目标 “.o” 文件存在，<s>目标 “.o” 文件比它的任何一个依赖文件（&quot;.c&quot; 源文件、&quot;.h&quot; 文件）“更新”</s>（它的依赖文件.h、.c在上一次 make 之后没有被修改），则什么也不做。</li></ul><p>通过上面的更新规则我们可以了解到<strong>中间文件</strong>的作用，也就是编译时生成的 “.o” 文件。作用是<strong>检查某个源文件是不是进行过修改</strong>，最终目标文件是不是需要重建。我们执行 make 命令时，只有修改过的源文件或者是不存在的目标文件会进行重建，而那些没有改变的文件不用重新编译，这样在很大程度上节省时间，提高编程效率。小的工程项目可能体会不到，项目工程文件越大，效果才越明显。</p><h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2><ul><li><strong>定义变量</strong>的基本语法如下：<code>变量的名称=值列表</code></li><li>调用变量的时候可以用 <code>&quot;$(VALUE_LIST)&quot;</code>或者是<code>&quot;${VALUE_LIST}&quot;</code>来替换，这就是变量的引用。</li></ul><p>知道了如何定义，下面我们来说一下 Makefile 的变量的四种基本赋值方式：</p><ul><li>简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。</li><li>递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。</li><li>条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。</li><li>追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。</li></ul><h2 id="条件判断"><a class="markdownIt-Anchor" href="#条件判断"></a> 条件判断</h2><p><strong>ifeq 和 ifneq</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifeq (ARG1, ARG2)</span><br><span class="line">ifeq &apos;ARG1&apos; &apos;ARG2&apos;</span><br><span class="line">ifeq &quot;ARG1&quot; &quot;ARG2&quot;</span><br><span class="line">ifeq &quot;ARG1&quot; &apos;ARG2&apos;</span><br><span class="line">ifeq &apos;ARG1&apos; &quot;ARG2&quot;</span><br></pre></td></tr></table></figure><p><strong>ifdef 和 ifndef</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifdef VARIABLE-NAME</span><br></pre></td></tr></table></figure><p><strong>伪目标</strong></p><blockquote><p>并不会创建目标文件，只是想去执行这个目标下面的命令。</p><p>伪目标的存在可以帮助我们找到命令并执行。</p></blockquote><p>使用伪目标有两点原因：</p><ul><li>避免我们的 Makefile 中定义的只执行的命令的目标和工作目录下的实际文件出现名字冲突。</li><li>提高执行 make 时的效率，特别是对于一个大型的工程来说，提高编译的效率也是我们所必需的。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:    </span></span><br><span class="line">rm -rf *.o test</span><br></pre></td></tr></table></figure><p>规则中 rm 命令不是创建文件 clean 的命令，而是执行删除任务，删除当前目录下的所有的 .o 结尾和文件名为 test 的文件。</p><ul><li><p>当工作目录下不存在以 clean 命令的文件时，在 shell 中输入 make clean 命令，命令 rm -rf *.o test 总会被执行 ，这也是我们期望的结果。</p></li><li><p>如果当前目录下存在文件名为 clean 的文件时情况就会不一样了，当我们在 shell 中执行命令 make clean，由于这个规则没有依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令。因此命令 rm 将不会被执行。为了解决这个问题，删除 clean 文件或者是在 Makefile 中将目标 clean 声明为伪目标。将一个目标声明称伪目标的方法是将它作为特殊的目标<code>.PHONY</code>的依赖，如下：</p><p>.PHONY:clean</p><p>这样 clean 就被声明成一个伪目标，无论当前目录下是否存在 clean 这个文件，当我们执行 make clean 后 rm 都会被执行。而且当一个目标被声明为伪目标之后，make 在执行此规则时不会去试图去查找隐含的关系去创建它。这样同样提高了 make 的执行效率，同时也不用担心目标和文件名重名而使我们的编译失败。</p></li></ul><h4 id="伪目标实现多文件编辑"><a class="markdownIt-Anchor" href="#伪目标实现多文件编辑"></a> 伪目标实现多文件编辑</h4><p>如果在一个文件里想要同时生成多个可执行文件，我们可以借助伪目标来实现。使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:allall:test1 test2 test3test1:test1.o    gcc -o $@ $^test2:test2.o    gcc -o $@ $^test3:test3.o    gcc -o $@ $^</span><br></pre></td></tr></table></figure><p>我们在当前目录下创建了三个源文件，目的是把这三个源文件编译成为三个可执行文件。将重建的规则放到 Makefile 中，约定使用 “all” 的伪目标来作为最终目标，它的依赖文件就是要生成的可执行文件。这样的话只需要一个 make 命令，就会同时生成三个可执行文件。</p><p>之所以这样写，是因为伪目标的特性，它总会被执行，所以它依赖的三个文件的目标就不如 “all” 这个目标新，所以，其他的三个目标的规则总是被执行，这也就达到了我们一口气生成多个目标的目的。我们也可以实现单独的编译这三个中的任意一个源文件（我们想去重建 test1，我们可以执行命令<code>make test1</code> 来实现 ）。</p><h2 id="-l参数和-l参数"><a class="markdownIt-Anchor" href="#-l参数和-l参数"></a> <a href="https://blog.csdn.net/dingzuoer/article/details/44650941" target="_blank" rel="noopener">-l参数和-L参数</a></h2><p>**<code>-l</code>**参数就是用来指定程序要链接的库，-l参数紧接着就是库名(<code>-l&lt;packageName&gt;</code>)，那么库名跟真正的库文 件名有什么关系呢？A: 就拿数学库来说，他的库名是m，<a href="http://xn--libm-435fsgv46az1vzjocrb5z6g.so" target="_blank" rel="noopener">他的库文件名是libm.so</a>，很容易看出，把库文件名的 头lib和尾.so去掉就是库名了。</p><p>好了现在我们知道怎么得到库名了，比如我们自已要用到一个第三方提供的库名字叫<strong><a href="http://libtest.so" target="_blank" rel="noopener">libtest.so</a></strong>，那么我们只要①把 libtest.so拷贝到/usr/lib 里，②编译时加上-ltest参数，我们就能用上libtest.so库了（当然要用libtest.so库里的函数，我们还需要与libtest.so配套的头文件）。</p><p>注：放在 /lib 和 /usr/lib 和 /usr/local/lib 里的库直接用-l参数就能链接了，但如果库文件如果没有放在这三个目录里，而是放在其他目录里，这时我们只用-l参数的话，链接还是会出错，出错信息大概是：“/usr/bin/ld: cannot find -lxxx”，也就是提醒开发人员：<a href="http://xn--ld3libxxx-nc6n4jh04bmwp6ny9uc31scxeh63iqmmj93ildf3nu.so" target="_blank" rel="noopener">链接程序ld在那3个目录里找不到libxxx.so</a>。</p><p>这时另外一个参数**<code>-L</code>**就派上用场了，比如常用的X11的库，它放在/usr/X11R 6/lib目录下，我们编译时就要用<code>-L/usr/X11R6/lib - lX11</code>参数，-L参数跟着的是库文件所在的目录名(<code>-L &lt;packagePath&gt;</code>)。比如我们把libtest.so在/aaa/bb b/ccc目录下，那链接参数就是<code>-L /aaa/bbb/ccc -ltest</code>， <strong>注意需要加上<code>-ltest</code></strong>（RFID工程代码中的makefile就是因为没有加上这个导致的）</p><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="通用范式"><a class="markdownIt-Anchor" href="#通用范式"></a> 通用范式</h2><h3 id="清除工作目录中的过程文件"><a class="markdownIt-Anchor" href="#清除工作目录中的过程文件"></a> 清除工作目录中的过程文件</h3><p>我们在使用的时候会产生中间文件会让整个文件看起来很乱，所以在编写 Makefile 文件的时候会在末尾加上这样的规则语句来<u>清除工作目录中的过程文件</u>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:    </span></span><br><span class="line">rm -rf *.o test</span><br><span class="line"><span class="comment"># 其中 "*.o" 是执行过程中产生的中间文件，"test" 是最终生成的执行文件。我们可以看到 clean 是独立的，它只是一个*伪目标*，不是具体的文件。不会与第一个目标文件相关联，所以我们在执行 make 的时候也不会执行下面的命令。在shell 中执行 "make clean" 命令，编译时的中间文件和生成的最终目标文件都会被清除，方便我们下次的使用。</span></span><br></pre></td></tr></table></figure><p>完整范式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">OBJS =  base64.o faceSearch.o camera.o CRC.o cQueue.o myQueue.o myUart.o info.o mcuio.o global.o print.o myMQTT.o rfid.o serialscreen.o sscreenupdate.o hmiFSM.o main.o</span><br><span class="line">INCLUDES = -I ./<span class="keyword">include</span>/ <span class="comment"># 指定头文件</span></span><br><span class="line">CC = arm-linux-gcc    <span class="comment"># 指定gcc编译期</span></span><br><span class="line">CXX = arm-linux-g++<span class="comment"># 指定g++编译期</span></span><br><span class="line">CFLAGS = -g -Wall -c <span class="variable">$(INCLUDES)</span> <span class="comment"># 指定C编译参数</span></span><br><span class="line">LIBS = -L ./lib -L./org.eclipse.mosquitto/lib -L /usr/local/arm/4.4.3/arm-none-linux-gnueabi/sys-root/lib/ </span><br><span class="line"></span><br><span class="line"><span class="comment">#arm-linux-gcc test.c -I./org.eclipse.mosquitto/lib/ -L./org.eclipse.mosquitto/lib -lmosquitto -lpthread -lrt</span></span><br><span class="line"><span class="section">mes:clean <span class="variable">$(OBJS)</span> </span></span><br><span class="line"><span class="variable">$(CXX)</span> -o mes <span class="variable">$(OBJS)</span> <span class="variable">$(LIBS)</span> -lpthread -lsqlite3 -lrt -lmosquitto -lcjson -lstdc++ -lcurl</span><br><span class="line">main.o : main.c  </span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> main.c  </span><br><span class="line">hmiFSM.o : hmiFSM.c</span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CFLAGS)</span> hmiFSM.c  </span><br><span class="line">serialscreen.o : serialscreen.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> serialscreen.c  </span><br><span class="line">sscreenupdate.o : </span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> sscreenupdate.c</span><br><span class="line">rfid.o : rfid.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> rfid.c  </span><br><span class="line">myMQTT.o : myMQTT.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> myMQTT.c  </span><br><span class="line">myQueue.o : myQueue.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> myQueue.c   </span><br><span class="line">cQueue.o : cQueue.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> cQueue.c   </span><br><span class="line">myUart.o : myUart.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> myUart.c</span><br><span class="line">myUart485.o : myUart485.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> myUart485.c</span><br><span class="line">CRC.o : CRC.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> CRC.c</span><br><span class="line">info.o : info.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> info.c</span><br><span class="line">mcuio.o : mcuio.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> mcuio.c</span><br><span class="line">global.o : global.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> global.c</span><br><span class="line">print.o : print.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> print.c</span><br><span class="line">faceSearch.o : faceSearch.cpp</span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CFLAGS)</span> -c faceSearch.cpp -o faceSearch.o</span><br><span class="line">base64.o : base64.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c base64.c -o base64.o</span><br><span class="line"><span class="section">monitor:</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> smartlibdaemon.c -o monitor1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">clean :</span><br><span class="line">rm <span class="variable">$(OBJS)</span>  mes monitor -rf</span><br><span class="line"><span class="section">update:</span></span><br><span class="line">scp ./smartlib root@10.82.80.234:/var/www/smartlibrary-update/</span><br></pre></td></tr></table></figure><h2 id="gcc-cflags"><a class="markdownIt-Anchor" href="#gcc-cflags"></a> Gcc CFLAGs</h2><ul><li>-I: (include)包含.h头文件</li><li>-o：(output) 指定输出文件名<ul><li><code>gcc -o app test.c</code>将生成可执行程序exe</li></ul></li><li>-c: (compile) 只编译不链接：产生.o文件，就是obj文件，不产生执行文件<ul><li><code>gcc -c test.c</code>将生成test.o的目标文件</li></ul></li></ul><p>▲.<code>gcc -c a.c -o a.o</code>表示把源文件a.c编译成指定文件名a.o的中间目标文件(其实在这里，把-o a.o省掉，效果是一样的，因为中间文件默认与源文件同名，只是后缀变化)。</p><ol><li>如果GCC不带-C参数，编译一个源代码文件（test.c)。那么会自动将编译和链接一步完成，并生成可执行文件。可执行文件可以有-o参数指定（test.o)</li><li>如果是多个文件，则需要先编译成中间目标文件(一般是.o文件），在链接成可执行文件，一般习惯目标文件都是以.o后缀，也没有硬性规定可执行文件不能用.o文件。</li></ol><h1 id="嵌入式编程"><a class="markdownIt-Anchor" href="#嵌入式编程"></a> 嵌入式编程：</h1><p><strong>全局变量</strong></p><ul><li><p>如果是main中声明的全局变量，工程中的其他文件都不需要引入&quot;main.c&quot; or &quot;main.h&quot;就可以直接使用</p></li><li><p>如果不是，则最好的方式还是用一个源文件里（如global.c）声明全局变量，其他cpp若使用某个全局变量，在相应的头文件中包含该头文件(global.h)即可。</p><ul><li>Q: 为什么不直接在global.h头文件里定义全局变量？</li><li>A: 由于全局变量的定义有且只能有一次，如果是在头文件中定义了，那么就会导致重复定义。===&gt;因此头文件只能用来声明，不能用来定义。</li></ul></li><li><p><strong>声明与定义</strong></p><ul><li><p>函数或变量在声明时，并没有给它实际的物理内存空间，它有时候可保证你的程序编译通过；</p></li><li><p>函数或变量在定义时，它就在内存中有了实际的物理空间。</p><p>如果你在编译单元中引用的外部变量<strong>没有</strong>在整个工程中任何一个地方<strong>定义</strong>的话，那么即使它在编译时可以通过，在连接时也会报错，因为<strong>程序在内存中找不到这个变量</strong>。</p><p>函数或变量可以声明多次，但定义有且只能有一次。</p></li></ul></li></ul><p><strong>sprintf</strong></p><blockquote><p>C函数：将格式化的数据写入字符串， 原型为：`int sprintf(char *dest_str, char * format [, argument, …]);</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sprintf()最常见的应用之一莫过于把整数打印到字符串中，如：</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">"%d"</span>, <span class="number">123</span>);  <span class="comment">//把整数123打印成一个字符串保存在s中</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">"%8x"</span>, <span class="number">4567</span>);  <span class="comment">//小写16进制，宽度占8个位置，右对齐</span></span><br><span class="line"><span class="comment">// 拓展demo</span></span><br><span class="line"><span class="built_in">sprintf</span>(mr-&gt;taskId, <span class="string">"%s"</span>, cJSON_GetObjectItem(root, <span class="string">"taskId"</span>)-&gt;valuestring);</span><br><span class="line"><span class="built_in">sprintf</span>(mr-&gt;printData, <span class="string">"%s"</span>, cJSON_GetObjectItem(root, <span class="string">"data"</span>)-&gt;valuestring);</span><br></pre></td></tr></table></figure><p><strong>sscanf</strong></p><p>C 库函数 : 从字符串读取格式化输入。原型为：<code>int sscanf(const char *str, const char *format, ...)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example: 1</span></span><br><span class="line"><span class="built_in">sscanf</span>(buf,<span class="string">"#####%d+%[a-zA-Z]+%d#####"</span>,&amp;sid,cmdid,&amp;id);</span><br><span class="line"><span class="comment">// example: 2</span></span><br><span class="line"><span class="keyword">if</span>(cJSON_GetObjectItem(root, <span class="string">"status"</span>) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">sscanf</span>( cJSON_GetObjectItem(root, <span class="string">"status"</span>)-&gt;valuestring,<span class="string">"%d"</span>,&amp;(mr-&gt;status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>((mr-&gt;sequence), <span class="string">"%s"</span>, cJSON_GetObjectItem(root, <span class="string">"sequence"</span>)-&gt;valuestring);</span><br></pre></td></tr></table></figure><p><strong>memcpy</strong></p><blockquote><p>C 库函数: 从存储区 <strong>str2</strong> 复制 <strong>n</strong> 个字节到存储区 <strong>str1</strong>。原型为：<code>void memcpy(void str1, const void str2, size_t n)</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUser</span><span class="params">(<span class="keyword">char</span> *cmd,<span class="keyword">char</span> *user)</span></span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(user,cmd+POS_USER,iv-POS_USER );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>memset()</strong></p><blockquote><p>C 库函数：复制字符 <strong>c</strong>（一个无符号字符）到参数 <strong>str</strong> 所指向的字符串的前 <strong>n</strong> 个字符。原型为：<code>void *memset(void *str, int c, size_t n)</code></p></blockquote><p><strong>strcpy()</strong></p><blockquote><p>C 库函数：把 <strong>src</strong> 所指向的字符串复制到 <strong>dest</strong>。原型:<code>char *strcpy(char *dest, const char *src)</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;makefile使用记录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#makefile使用记录&quot;&gt;&lt;/a&gt; Makefile使用记录&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Makefile 文件描述了 Linux 系统下 C/C+
      
    
    </summary>
    
    
      <category term="配置" scheme="https://nymrli.top/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>物联网基础与应用-课程笔记</title>
    <link href="https://nymrli.top/2021/09/27/%E7%89%A9%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2021/09/27/物联网基础与应用-课程笔记/</id>
    <published>2021-09-27T15:44:21.000Z</published>
    <updated>2021-10-11T13:04:37.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iot课上实验"><a class="markdownIt-Anchor" href="#iot课上实验"></a> IOT课上实验</h1><h2 id="交叉编译环境"><a class="markdownIt-Anchor" href="#交叉编译环境"></a> 交叉编译环境</h2><h3 id="什么是交叉编译环境"><a class="markdownIt-Anchor" href="#什么是交叉编译环境"></a> 什么是交叉编译环境？</h3><p>交叉编译其实是相对于本地编译(native build)来说的，大家最开始学习 C/C++ 这些语言的时候，都是在自己的笔记本上写程序，然后在直接在电脑上编译生成可执行文件，最后在电脑上运行。整个流程为：程序的编辑-&gt;编译-&gt;运行，整个过程都是在一台 X86 电脑上。</p><p>当我们开始接触嵌入式开发后，事情变的不一样了。你在<strong>电脑上写程序</strong>，在电脑上编译出可执行文件，最后这个可执行文件需要下载到你的<strong>开发板上运行</strong>。程序最后运行的环境变了，比如你的开发板是基于 Arm 的——程序在 X86 上编辑，编译，最终运行在另一个和 X86 完全不同的架构的 Arm 芯片上。</p><p>之所以整个流程变成了这个样子，这是由<strong>嵌入式系统的特性</strong>决定的：一般嵌入式系统里面使用的芯片性能都比较弱，而且绝大部分都不能像 X86 一样运行 Windows/Ubuntu 桌面系统，即使能运行，性能也很弱，<strong>在开发板上很难提供写代码、编译代码的环境</strong>。所以我们还是离不开 X86 电脑强大高效的桌面环境进行软件开发。</p><p>总结： 在性能强大的个人电脑上编写源码和编译程序，将可执行文件运行在开发板上。</p><p><img src="/2021/09/27/物联网基础与应用-课程笔记/emb.png" alt="emb"></p><h3 id="搭建交叉编译环境"><a class="markdownIt-Anchor" href="#搭建交叉编译环境"></a> 搭建交叉编译环境</h3><blockquote><p>操作系统强烈推荐使用 ubuntu-12.04 以上版本的 64 位发行版， windows上不行</p></blockquote><ol><li><p>预安装：在安装交叉编译工具之前需要先安装 32 位的兼容库和 libncurses5-dev 库，安装兼容库 需要从 ubuntu 的源库中下载。如果主机没有安装 32 位兼容库，在使用交叉编译工具的时候可能会出现错误：<code>-bash: ./arm-fsl-linux-gnueabi-gcc: 没有那个文件或目录</code>因此需要先<code>sudo apt-get install ia32-libs</code>安装32位兼容库，然后<code>sudo apt-get install libncurses5-dev</code>安装 libncurses5-dev，如果没有安装<code>libncurses5-dev</code>，在使用 make menucofig 时会如所示的错误<code>'make menuconfig' requires the ncurses libraries</code></p></li><li><p>安装交叉编译工具链：需要 root 权限。在终端执行命令：<code>$ sudo tar –zxvf gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12.tar.gz -C /opt/</code>， 交叉编译工具链将会被安装到<code>/opt/ gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12</code>目录下（注意解压时-C为改变解压目录，指定为 /opt/ 目录），交叉编译器的具体目录是 <code>/opt/gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12/fsl-linaro-toolchain/bin/bin</code>。</p></li><li><p>为了方便使用，还需将交叉编译器路径添加到<strong>系统路径</strong>中：修改~/.bashrc 文件，在 PATH 变量中增加交叉编译工具链的 安装路径，然后运行~/.bashrc 文件，使设置生效。在~/.bashrc 文件末尾增加一行： <code>export PATH=$PATH:/opt/gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12/fsl-linaro-toolchain/bin/</code></p></li><li><p>查看是否安装成功：在终端输入 <code>arm-fsl-linux-gnueabi-</code>并按 TAB 键，如果能够看到很多 arm-fsl-linux-gnueabi前缀的命令，则基本可以确定交叉编译器安装正确。</p></li></ol><p>注：从ubuntu 13.10已经废弃了ia32-libs，因此如果在Ubuntu16.04的机子上安装，会出现如下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mrli@welcome:~/iot$ sudo apt-get install ia32-libs</span><br><span class="line">sudo: unable to resolve host welcome</span><br><span class="line">[sudo] password <span class="keyword">for</span> mrli: </span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">Package ia32-libs is not available, but is referred to by another package.</span><br><span class="line">This may mean that the package is missing, has been obsoleted, or</span><br><span class="line">is only available from another <span class="built_in">source</span></span><br><span class="line">However the following packages replace it:</span><br><span class="line">  lib32ncurses5 lib32z1</span><br><span class="line">E: Package <span class="string">'ia32-libs'</span> has no installation candidate</span><br></pre></td></tr></table></figure><h2 id="编译代码"><a class="markdownIt-Anchor" href="#编译代码"></a> 编译代码</h2><p>由于一直报错：<code>/home /mrli/iot/gcc-46.2-glibc-213-linaro-multillb-201112/fsl-linaro-toolchain/bin/。/lib/gcc/arm-fsl-linux-gnueabi/4.6.2/。.//。/arm-fsl-linux-gnueabi/bin/ld:warning:libcrypto so 1.1， needed by ./lib/libcurl. so, not found（try using -rpath or -rpath-link）</code>， 原因是LIB后没有带编译链接选项<code>-lcurl, -lcrypto, -lssl</code></p><h2 id="mqtt"><a class="markdownIt-Anchor" href="#mqtt"></a> MQTT</h2><blockquote><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的&quot;轻量级&quot;通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p></blockquote><p><strong>MQTT协议实现方式</strong></p><p>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p><p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p><ul><li>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；</li><li>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</li></ul><p><a href="https://www.runoob.com/w3cnote/mqtt-intro.html" target="_blank" rel="noopener">MQTT入门介绍——菜鸟教程</a></p><h3 id="mosquitto使用"><a class="markdownIt-Anchor" href="#mosquitto使用"></a> mosquitto使用</h3><p>库函数API介绍：<a href="https://blog.csdn.net/weixin_53361650/article/details/116954595" target="_blank" rel="noopener">mosquitto库函数详解</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MQTT设计了一套保证消息稳定传输的机制，包括消息应答、存储和重传。在这套机制下，提供了三种不同层次QoS（Quality of Service）：</p><ul><li>QoS0，At most once，至多一次；</li><li>QoS1，At least once，至少一次；</li><li>QoS2，Exactly once，确保只有一次。</li></ul><p>客户端可以主动选择性地往某一主题推送信息，这个不需要提前设定；但在接收信息方面，需要客户端提前订阅主题，注：客户端同时可以订阅多个主题，且MQTT协议的主题解析有规则，规则如下：</p><p>Springboot_MQTT:</p><ul><li><a href="https://blog.csdn.net/yl_hahha/article/details/99246679" target="_blank" rel="noopener">https://blog.csdn.net/yl_hahha/article/details/99246679</a></li><li><a href="https://blog.csdn.net/qq_41018959/article/details/81076055?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link" target="_blank" rel="noopener">https://blog.csdn.net/qq_41018959/article/details/81076055?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link</a></li></ul><h2 id="pthread库使用"><a class="markdownIt-Anchor" href="#pthread库使用"></a> pthread库使用</h2><p>库函数API介绍：<a href="https://blog.csdn.net/weixin_38102771/article/details/91351126" target="_blank" rel="noopener">线程以及pthread库的使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iot课上实验&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#iot课上实验&quot;&gt;&lt;/a&gt; IOT课上实验&lt;/h1&gt;
&lt;h2 id=&quot;交叉编译环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#交叉编译环境&quot;&gt;
      
    
    </summary>
    
    
      <category term="ZJU" scheme="https://nymrli.top/tags/ZJU/"/>
    
      <category term="嵌入式开发" scheme="https://nymrli.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>学点Gradle</title>
    <link href="https://nymrli.top/2021/09/26/%E5%AD%A6%E7%82%B9Gradle/"/>
    <id>https://nymrli.top/2021/09/26/学点Gradle/</id>
    <published>2021-09-26T05:37:07.000Z</published>
    <updated>2021-09-27T00:37:42.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gradle学习"><a class="markdownIt-Anchor" href="#gradle学习"></a> Gradle学习</h1><p>在kotlin中使用mapstruct出现了些问题， 网上搜寻后得到结论：需要使用kapt(Kotlin annotation processing tool 即kotlin注解处理工具)， 但给出的大多都是通过Gradle来进行配置的。因此借此机会学习了下Gradle：</p><h2 id="plugins和apply-plugin"><a class="markdownIt-Anchor" href="#plugins和apply-plugin"></a> plugins和apply plugin:</h2><blockquote><p>由于文档写到了， 由于不清楚这些在哪些位置加入， 因此查看了plugins和<code>apply plugin:</code>的区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; 添加 kapt 插件</span><br><span class="line">&gt; apply plugin: &apos;kotlin-kapt&apos;</span><br><span class="line">&gt; </span><br><span class="line">&gt; 然后在项目中添加如下依赖：</span><br><span class="line">&gt; api(&quot;com.github.pozo:mapstruct-kotlin:1.3.1.2&quot;)</span><br><span class="line">&gt; kapt(&quot;com.github.pozo:mapstruct-kotlin-processor:1.3.1.2&quot;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; 另外，还需要添加如下依赖：</span><br><span class="line">&gt; api(&quot;org.mapstruct:mapstruct:1.4.0.Beta3&quot;)</span><br><span class="line">&gt; kapt(&quot;org.mapstruct:mapstruct-processor:1.4.0.Beta3&quot;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>“plugins {}”块导入的是<a href="https://link.zhihu.com/?target=https%3A//plugins.gradle.org/" target="_blank" rel="noopener">Gradle官方插件仓库</a>里的插件。如果使用“buildscript {}”块指定第三方库作为Gradle插件的话，指定插件就需要使用“apply plugin”了。</p><p>刚刚翻了翻文档，“apply plugin”本身似乎还有更多的用途，而“plugins {}”块似乎是一个新引入的还不足够稳定的特性。题主想要知道更多的话直接看看文档就行了。</p><p>最终的Plain项目的依赖如下所示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">    id <span class="string">'org.jetbrains.kotlin.jvm'</span> version <span class="string">'1.4.10'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> <span class="string">'org.example'</span></span><br><span class="line">version <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'kotlin-kapt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">"org.jetbrains.kotlin:kotlin-stdlib"</span></span><br><span class="line">    testImplementation <span class="string">'org.junit.jupiter:junit-jupiter-api:5.6.0'</span></span><br><span class="line">    testRuntimeOnly <span class="string">'org.junit.jupiter:junit-jupiter-engine'</span></span><br><span class="line"></span><br><span class="line">    api(<span class="string">"com.github.pozo:mapstruct-kotlin:1.3.1.2"</span>)</span><br><span class="line">    kapt(<span class="string">"com.github.pozo:mapstruct-kotlin-processor:1.3.1.2"</span>)</span><br><span class="line">    api(<span class="string">"org.mapstruct:mapstruct:1.4.0.Beta3"</span>)</span><br><span class="line">    kapt(<span class="string">"org.mapstruct:mapstruct-processor:1.4.0.Beta3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="maven使用kapt"><a class="markdownIt-Anchor" href="#maven使用kapt"></a> maven使用kapt</h2><p>在 kotlin-maven-plugin 中的在<code>compile</code> 之前添加 <code>kapt</code> 目标的执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;execution&gt;</span><br><span class="line">    &lt;id&gt;kapt&lt;/id&gt;</span><br><span class="line">    &lt;goals&gt;</span><br><span class="line">        &lt;goal&gt;kapt&lt;/goal&gt;</span><br><span class="line">    &lt;/goals&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;sourceDirs&gt;</span><br><span class="line">            &lt;sourceDir&gt;src/main/kotlin&lt;/sourceDir&gt;</span><br><span class="line">            &lt;sourceDir&gt;src/main/java&lt;/sourceDir&gt;</span><br><span class="line">        &lt;/sourceDirs&gt;</span><br><span class="line">        &lt;annotationProcessorPaths&gt;</span><br><span class="line">            &lt;!-- 在此处指定你的注解处理器。 --&gt;</span><br><span class="line">            &lt;annotationProcessorPath&gt;</span><br><span class="line">                &lt;groupId&gt;com.google.dagger&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;dagger-compiler&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.9&lt;/version&gt;</span><br><span class="line">            &lt;/annotationProcessorPath&gt;</span><br><span class="line">        &lt;/annotationProcessorPaths&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/execution&gt;</span><br></pre></td></tr></table></figure><p>请注意，IntelliJ IDEA 自身的构建系统目前还不支持 kapt。当你想要重新运行注解处理时，请从“Maven Projects”工具栏启动构建。</p><p>from: <a href="https://www.kancloud.cn/alex_wsc/android_kotlin/1318386#_Maven__110" target="_blank" rel="noopener">https://www.kancloud.cn/alex_wsc/android_kotlin/1318386#_Maven__110</a></p><p><strong>各种依赖方式说明</strong></p><ul><li><p>implementation<br>这个指令的特点就是，对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，也就是将该依赖隐藏在内部，而不对外部公开。</p></li><li><p>api<br>完全等同于compile指令。</p></li><li><p>compile<br>这种是我们最常用的方式，使用该方式依赖的库将会参与编译和打包。</p></li><li><p>testCompile<br>testCompile 只在单元测试代码的编译以及最终打包测试apk时有效。</p></li><li><p>debugCompile<br>debugCompile 只在debug模式的编译和最终的debug apk打包时有效。</p></li><li><p>releaseCompile<br>releaseCompile 仅仅针对Release模式的编译和最终的Release apk打包。这里比如</p></li></ul><h2 id="gradle中api-implementation和compile的区别"><a class="markdownIt-Anchor" href="#gradle中api-implementation和compile的区别"></a> gradle中api、implementation和compile的区别</h2><blockquote><p>我们在gradle中引用第三方maven库时，一般通过下面的语句去引用:<code>compile 'com.android.support:appcompat-v7:26.1.0'</code> , 然后sync project，就能成功引用对应的包到项目之中了，十分方便。除了使用compile关键字，使用implementation和api也能将包引用到项目中</p></blockquote><p>api和compile关键字作用效果是一样的，使用时可以互相替换。实际上，api关键字是用来替代compile关键字的，因为compile关键字将来会被弃用。在高版本的gradle，使用compile关键字会报错并提示使用api关键字代替。</p><p>Q：看起来这三个关键字的作用是一样的，那么，他们到底有什么区别呢？</p><p>A：在同一个module下，implementation和compile的使用效果相同，但是在不同module下，就会有所区别了。</p><p><strong>api或compile关键字引用的包对于其他module来说是可见的，而implementation关键字引用的包对于其他module来说是不可见的。</strong></p><h2 id="maven仓库列表"><a class="markdownIt-Anchor" href="#maven仓库列表"></a> Maven仓库列表</h2><table><thead><tr><th>仓库名</th><th>简介</th><th>实际地址</th><th>使用地址</th></tr></thead><tbody><tr><td>jcenter</td><td>JFrog公司提供的仓库</td><td><a href="http://jcenter.bintray.com" target="_blank" rel="noopener">http://jcenter.bintray.com</a></td><td><a href="https://maven.aliyun.com/repository/jcenter" target="_blank" rel="noopener">https://maven.aliyun.com/repository/jcenter</a> <a href="https://maven.aliyun.com/nexus/content/repositories/jcenter" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/repositories/jcenter</a></td></tr><tr><td>mavenLocal</td><td>本台电脑上的仓库</td><td>{USER_HOME}/.m2/repository</td><td>C:/Users/liyujiang/.m2/repository (Windows) /home/liyujiang/.m2/repository (Linux)</td></tr><tr><td>mavenCentral</td><td>Sonatype公司提供的中央库</td><td><a href="http://central.maven.org/maven2" target="_blank" rel="noopener">http://central.maven.org/maven2</a></td><td><a href="https://maven.aliyun.com/repository/central" target="_blank" rel="noopener">https://maven.aliyun.com/repository/central</a> <a href="https://maven.aliyun.com/nexus/content/repositories/central" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/repositories/central</a></td></tr><tr><td>google</td><td>Google公司提供的仓库</td><td><a href="https://maven.google.com" target="_blank" rel="noopener">https://maven.google.com</a></td><td><a href="https://maven.aliyun.com/repository/google" target="_blank" rel="noopener">https://maven.aliyun.com/repository/google</a> <a href="https://maven.aliyun.com/nexus/content/repositories/google" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/repositories/google</a> <a href="https://dl.google.com/dl/android/maven2" target="_blank" rel="noopener">https://dl.google.com/dl/android/maven2</a></td></tr><tr><td>jitpack</td><td>JitPack提供的仓库</td><td><a href="https://jitpack.io" target="_blank" rel="noopener">https://jitpack.io</a></td><td><a href="https://jitpack.io" target="_blank" rel="noopener">https://jitpack.io</a></td></tr><tr><td>public</td><td>jcenter和mavenCentral的聚合仓库</td><td><a href="https://maven.aliyun.com/repository/public" target="_blank" rel="noopener">https://maven.aliyun.com/repository/public</a> <a href="https://maven.aliyun.com/nexus/content/groups/public" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/groups/public</a></td><td></td></tr><tr><td>gradle-plugin</td><td>Gradle插件仓库</td><td><a href="https://plugins.gradle.org/m2" target="_blank" rel="noopener">https://plugins.gradle.org/m2</a></td><td><a href="https://maven.aliyun.com/repository/gradle-plugin" target="_blank" rel="noopener">https://maven.aliyun.com/repository/gradle-plugin</a> <a href="https://maven.aliyun.com/nexus/content/repositories/gradle-plugin" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/repositories/gradle-plugin</a></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven&#123; url &apos;https://maven.aliyun.com/nexus/content/groups/public/&apos;&#125;</span><br><span class="line">    maven&#123; url &apos;https://maven.aliyun.com/nexus/content/repositories/jcenter&apos;&#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gradle全局换源"><a class="markdownIt-Anchor" href="#gradle全局换源"></a> gradle全局换源</h3><p>在<code>C:\Users\mrli\.gradle</code>文件夹下修改init.gradle文件（如果没有则新建），写下如下内容:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">allprojects</span>&#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        <span class="keyword">def</span> ALIYUN_REPOSITORY_URL = <span class="string">'https://maven.aliyun.com/repository/public/'</span></span><br><span class="line">        <span class="keyword">def</span> ALIYUN_JCENTER_URL = <span class="string">'https://maven.aliyun.com/repository/jcenter/'</span></span><br><span class="line">        <span class="keyword">def</span> ALIYUN_GOOGLE_URL = <span class="string">'https://maven.aliyun.com/repository/google/'</span></span><br><span class="line">        <span class="keyword">def</span> ALIYUN_GRADLE_PLUGIN_URL = <span class="string">'https://maven.aliyun.com/repository/gradle-plugin/'</span></span><br><span class="line">        all &#123; ArtifactRepository repo -&gt;</span><br><span class="line">            <span class="keyword">if</span>(repo <span class="keyword">instanceof</span> MavenArtifactRepository)&#123;</span><br><span class="line">                <span class="keyword">def</span> url = repo.url.toString()</span><br><span class="line">                <span class="keyword">if</span> (url.startsWith(<span class="string">'https://repo1.maven.org/maven2/'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">project</span>.logger.lifecycle <span class="string">"Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL."</span></span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (url.startsWith(<span class="string">'https://jcenter.bintray.com/'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">project</span>.logger.lifecycle <span class="string">"Repository $&#123;repo.url&#125; replaced by $ALIYUN_JCENTER_URL."</span></span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (url.startsWith(<span class="string">'https://dl.google.com/dl/android/maven2/'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">project</span>.logger.lifecycle <span class="string">"Repository $&#123;repo.url&#125; replaced by $ALIYUN_GOOGLE_URL."</span></span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (url.startsWith(<span class="string">'https://plugins.gradle.org/m2/'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">project</span>.logger.lifecycle <span class="string">"Repository $&#123;repo.url&#125; replaced by $ALIYUN_GRADLE_PLUGIN_URL."</span></span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123; url ALIYUN_REPOSITORY_URL &#125;</span><br><span class="line">        maven &#123; url ALIYUN_JCENTER_URL &#125;</span><br><span class="line">        maven &#123; url ALIYUN_GOOGLE_URL &#125;</span><br><span class="line">        maven &#123; url ALIYUN_GRADLE_PLUGIN_URL &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：阿里源的URL使用https而不是http，否则会出现以下报错:<code>Gradle报错Could not resolve all dependencies for configuration ‘:detachedConfiguration7‘.</code></p><p>参考：</p><ul><li><a href="https://blog.csdn.net/qq_41053520/article/details/118244668" target="_blank" rel="noopener">https://blog.csdn.net/qq_41053520/article/details/118244668</a></li><li><a href="https://www.cnblogs.com/huiyi0521/p/10997152.html%E2%80%94%E2%80%94gradle%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">https://www.cnblogs.com/huiyi0521/p/10997152.html——gradle中执行函数</a></li><li><a href="https://blog.csdn.net/qq32933432/article/details/108906687%E2%80%94%E2%80%94work" target="_blank" rel="noopener">https://blog.csdn.net/qq32933432/article/details/108906687——work</a></li></ul><h2 id="buildscript"><a class="markdownIt-Anchor" href="#buildscript"></a> buildscript</h2><blockquote><p>buildscript中的声明是gradle脚本自身需要使用的资源</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;java&apos; // java项目</span><br><span class="line">apply plugin: &apos;eclipse&apos; // eclipse开发环境构建，生成所需要的.project,.classpath等文件</span><br><span class="line">apply plugin: &apos;org.springframework.boot&apos;</span><br><span class="line">jar &#123;</span><br><span class="line">    baseName = &apos;shop-supplier&apos;</span><br><span class="line">    version =  &apos;1.0.0-SNAPSHOT&apos;</span><br><span class="line">&#125;</span><br><span class="line">version = &apos;1.0.0-SNAPSHOT&apos;</span><br><span class="line">sourceCompatibility = 1.8</span><br><span class="line">targetCompatibility = 1.8</span><br><span class="line"></span><br><span class="line">repositories &#123; // maven仓库地址</span><br><span class="line">   maven&#123;url &apos;私服地址&apos;&#125;</span><br><span class="line">   mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123; // 依赖项</span><br><span class="line">   // web thymeleaf</span><br><span class="line">   compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)</span><br><span class="line">   compile(&apos;org.springframework.boot:spring-boot-starter-thymeleaf&apos;)</span><br><span class="line"></span><br><span class="line">   // test</span><br><span class="line">   testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;)</span><br><span class="line"></span><br><span class="line">   //添加 google二维码</span><br><span class="line">   compile &apos;com.google.zxing:core:3.2.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gradle-工程使用mybatis"><a class="markdownIt-Anchor" href="#gradle-工程使用mybatis"></a> <a href="https://my.oschina.net/u/3574106/blog/2222889" target="_blank" rel="noopener">gradle 工程使用mybatis</a></h2><p>正常情况下是在src/main/java/**/xxx.xml 文件是不会被打包的，需要我们队gradle做一些特别的配置</p><p>①，build.gradle</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sourceSets.main.resources.srcDirs = [<span class="string">"src/main/java"</span>,<span class="string">"src/main/resources"</span>]</span><br></pre></td></tr></table></figure><p>②，指定mapper.xml 文件所在路径，这里我用的是mp</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.mapper-locations=com/mp/test/mapper/xml<span class="comment">/*Mapper.xml</span></span><br></pre></td></tr></table></figure><p>③，指定mapper接口所在路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.mp.test.mapper"</span>)</span><br></pre></td></tr></table></figure><h2 id="gradle中使用docker"><a class="markdownIt-Anchor" href="#gradle中使用docker"></a> gradle中使用docker</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gradle学习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#gradle学习&quot;&gt;&lt;/a&gt; Gradle学习&lt;/h1&gt;
&lt;p&gt;在kotlin中使用mapstruct出现了些问题， 网上搜寻后得到结论：需要使用kapt(Kotlin a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ZJU云原生技术及应用-课程笔记</title>
    <link href="https://nymrli.top/2021/09/25/ZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2021/09/25/ZJU云原生技术及应用-课程笔记/</id>
    <published>2021-09-25T14:48:36.000Z</published>
    <updated>2021-10-09T09:54:49.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zju要求"><a class="markdownIt-Anchor" href="#zju要求"></a> ZJU要求</h1><h2 id="课程内容"><a class="markdownIt-Anchor" href="#课程内容"></a> 课程内容</h2><ul><li>云计算基本概念和Docker容器原理（4课时）</li><li>Kubernetes核心原理与关键组件 （8课时）</li><li>微服务技术原理与治理 （4课时）</li><li>容器监控与分析 （4课时）</li><li>云原生边缘计算技术（4课时）</li><li>IBM讲座-混合云架构（4课时）</li><li>云原生应用实践与案例分析（4课时）</li></ul><h2 id="考核方式"><a class="markdownIt-Anchor" href="#考核方式"></a> <strong>考核方式</strong></h2><blockquote><p>平时（20%）+ 课程设计（80%，含报告）</p></blockquote><p><strong>课程设计（三选一）</strong></p><ol><li><p>云原生技术研究报告或综述</p><p>围绕云原生关键技术点，如容器安全、多集群管理、云边协同和边缘智能等，综述当前技术现状并进行必要的分析</p></li><li><p>源代码分析报告</p><p>分析Kubernetes或者KubeEdge等云原生项目相关源代码，撰写代码分析报告（行级代码标注+工作流分析），不少于10页，原创。</p></li><li><p>开源贡献</p><p>修改Kubernetes/KubeEdge/Docker提交PR，根据代码行数折算（100行源代码或者5个commit）</p><p>未能通过社区审核，通过测试验证的代码可以作为参考评分</p></li></ol><h1 id="云原生"><a class="markdownIt-Anchor" href="#云原生"></a> 云原生</h1><h2 id="docker技术原理与实践"><a class="markdownIt-Anchor" href="#docker技术原理与实践"></a> Docker技术原理与实践</h2><blockquote><p>Docker是Docker公司开源的一个基于<strong>轻量级虚拟化技术</strong>的容器引擎项目,整个项目基于Go语言开发，并遵从Apache 2.0协议</p><p>目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术 (namespaces及cgroups等)来提供容器的资源隔离与安全保障等。</p><p>由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，不需要类 似虚拟机(VM)额外的操作系统开销，提高资源利用率，并且提升诸如IO等方面的性能。</p></blockquote><h3 id="docker本质就是进程"><a class="markdownIt-Anchor" href="#docker本质就是进程"></a> docker本质就是进程？</h3><p>A: 理解这句话得具备linux的基础知识，从基础知识角度来进行理解。首先docker的两大关键技术是Namespace和cgroup：Namespace技术改变了容器的视图，让容器以为自己在一个房间里，起到了隔离作用；cgroup(Linux Control Group)起到对容器资源的限制作用</p><p>namespace和cgroup共同为创造了一个容器沙盒。</p><p>==&gt;容器是个进程，通过namespace作为障眼法进行屏蔽，结合cgroup进行资源限制，并以容器镜像的方式打包的一个沙盒</p><p><strong>Docker应用场景</strong></p><ul><li>web应用的自动化打包和发布</li><li>自动化测试和持续集成、 发布</li><li>在服务型环境中部署和调整数据库或其他的后台应用</li><li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li></ul><p><strong>Docker优势</strong></p><ul><li>更低的资源损耗</li><li>更快的启动速度</li><li>更好的应用耦合</li><li>更强的弹性伸缩</li></ul><p><strong>Docker架构</strong></p><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cdocker%E6%9E%B6%E6%9E%84.png" alt="docker架构"></p><p><strong>基本要素</strong></p><ul><li>Docker Images是一个只读模板，用来运行Docker容器</li><li>Docker Containers负责应用程序的运行，包括操作系统、用户添加的文件以及元数据。</li><li>DockerFile是文件指令集，用来说明如何自动创建Docker镜像。</li></ul><p><strong>核心组件</strong></p><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cdocker%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" alt="docker核心组件"></p><p><strong>容器和镜像的关系</strong></p><blockquote><p>好比静态的源码和运行时的程序，使用执行源码即可得到想要功能的程序，同样的依据镜像从而能够构建通过镜像制定的容器。</p></blockquote><p><strong>镜像特点：</strong></p><ul><li>layer： 分层<ul><li>读写层</li><li>init层</li><li>只读层</li></ul></li><li>based on another image ： 基于其他镜像</li><li>a read-only template：是只读的模板</li><li>copy-on-write： 下层只读，上层可写</li><li>union filesystem：有独立的文件系统</li><li>DockerFile or docker commit：通过dockerfile或者docker commit生成</li></ul><p><strong>数据卷：</strong></p><blockquote><p>▲当一个容器被删除时，任何写入该容器的、没有存储在数据卷中的数据都会和该容器一起被删除。==&gt;因此需要个可以独立于容器存储的外存。</p></blockquote><ul><li>数据卷不受存储驱动器的控制。</li><li>你可以把任何数量的数据卷装入一个容器。</li><li>多个容器也可以共享一个或多个数据卷</li></ul><p><strong>docker CLI</strong></p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/hexo\source\_posts\ZJU云原生技术及应用-课程笔记\dockerCLI.png" alt="dockerCLI" style="zoom:50%;"><p><strong>docker pull过程</strong></p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/hexo\source\_posts\ZJU云原生技术及应用-课程笔记\dockerpull.jpg" alt="dockerpull" style="zoom:50%;"><p><strong>docker run过程</strong></p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/hexo\source\_posts\ZJU云原生技术及应用-课程笔记\dockerrun.jpg" alt="dockerrun" style="zoom:50%;"><p><strong>Dockerfile指令说明</strong></p><ul><li>FROM：初始化一个<strong>新的构建阶段</strong>，并为后续指令<strong>设置基础镜像</strong></li><li>ENV：为你的容器安装的软件更新PATH环境变量。</li><li>RUN： 在容器构建过程中运行的命令，如apt。为了使你的Docker文件更易读、易懂、易维护，请将长的或复杂的RUN语句分成多行，用反斜线分开</li><li><strong>COPY and ADD</strong>: 复制文件到指定路径，ADD相比之下多个类似tar<strong>解压</strong>的功能</li><li><strong>EXPOSE</strong>： 容器将监听连接的端口</li><li><strong>WORKDIR</strong>： 指定工作目录，并以绝对路径的形式给出</li><li><strong>CMD</strong>：容器构建完成后执行命令，主要目的是为执行中的容器提供默认值。这些默认值可以包括一个可执行文件，也可以省略可执行文件，在这种情况下，你必须同时指定一个ENTRYPOINT指令。一个Docker文件中只能有一条CMD指令。如果有多个CMD，那么只有最后一个CMD才会生效。</li><li>ENTRYPOINT：允许你配置一个将作为可执行文件运行的容器。<br><code>docker run &lt;image&gt;</code>的命令行参数将被附加在exec形式的ENTRYPOINT的所有元素之后，并将覆盖所有使用CMD指定的元素。这允许将参数传递给入口点，例如，docker run <image> -d将把-d参数传递给入口点。你可以使用docker run --entrypoint标志来覆盖ENTRYPOINT指令。<br>只有Docker文件中的最后一条ENTRYPOINT指令才会有效果。</image></li></ul><p>Q:如何使得镜像轻量？</p><p>A:从一个合适的基础镜像开始；使用多阶段构建；如果你有多个有很多共同点的镜像，考虑用<strong>共享的组件</strong>创建你自己的基础镜像，并在此基础上创建你的独特镜像；为了保持你的生产图像的精简，但允许调试，考虑使用生产图像作为调试图像的基础图像；当建立图像时，总是用有用的tags来标记它们</p><h2 id="云计算技术基本原理"><a class="markdownIt-Anchor" href="#云计算技术基本原理"></a> 云计算技术基本原理</h2><h2 id="kubernetes核心原理与关键组件"><a class="markdownIt-Anchor" href="#kubernetes核心原理与关键组件"></a> Kubernetes核心原理与关键组件</h2><p><strong>云计算</strong>定义：云计算是一种动态扩展的计算模式，通过网络将虚拟化的资源作为服务提供</p><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5C%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F.png" alt="云计算服务模式"></p><p><strong>云架构图</strong></p><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5C%E4%BA%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="云架构图"></p><h3 id="cloud-foundry云平台"><a class="markdownIt-Anchor" href="#cloud-foundry云平台"></a> Cloud Foundry云平台</h3><blockquote><p>Cloud Foundry是VMware于推出的业界第一个开源PaaS云平台，专为私有云计算环境、企业级数据中心和公有云服务提供商所打造，可以简化现代应用程序的开发、交付和运行过程，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题。</p></blockquote><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5CCloudFoundry.png" alt="CloudFoundry"></p><p><strong>Router</strong></p><p>Router是整个平台的流量入口，负责分发所有的请求到对应的组件，包括来自外部用户对app的请求和平台内部的管理请求。</p><p>Router是PaaS平台中至关重要的一个组件，它在内存中维护了一张路由表，记录了域名与实例的对应关系，所谓的实例自动迁移，靠得就是这张路由表，某实例宕掉了，就从路由表中剔除，新实例创建了，就加入路由表。</p><p><strong>状态服务</strong></p><ul><li><strong>无状态服务</strong>在容器化的世界里很受欢迎，因为它们是一次性的，而且很容易用容器镜像重新创建。<br>除了像Web服务器这样的无状态服务，用户越来越多地使用容器来部署有状态服务，以受益于 “<strong>一次构建，随地运行</strong>”，并提高裸机效率/利用率。<br>这些 &quot;宠物 &quot;（需要满足的需求）带来了新的要求，包括更长的生命周期、配置依赖性和有状态的故障转移。容器编排必须解决这些需求，以成功部署和扩展应用程序。</li></ul><h3 id="k8s命令"><a class="markdownIt-Anchor" href="#k8s命令"></a> K8s命令</h3><p><strong>K8s设计原则</strong></p><ul><li>声明式 状态驱动<br>用户通过声明式的配置文件（例如 YAML 文件）向 Kubernetes 告白自己希望达到的系统状态（例如：运行拥有 5 个副本的 nginx 服务）。</li><li>行动（React）<br>Kubernetes 的控制组件负责具体执行这些指令，使得用户声明的系统状态得以实现；在此过程中不需要任何人工的参与。</li><li>观测（Observe）：<br>Kubernetes会观测到新的用户声明，并自动分析出需要执行的操作以达到用户声明的系统状态（例如在集群中选取5个合适的节点，并在这 5 个节点上下载合适的 nginx 镜像并启动容器，以及配置相应的负载均衡策略等）。</li></ul><h3 id="k8s架构"><a class="markdownIt-Anchor" href="#k8s架构"></a> <strong>K8s架构</strong></h3><blockquote><p>Kubernetes主要组件有：API Server、Controller Manager、Scheduler、kubelet、kube-proxy，其中前三者运行于集群的Master节点，后两者运行于集群的Worker节点。</p></blockquote><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Ck8s%E6%9E%B6%E6%9E%84.png" alt="k8s架构"></p><p><strong>Master</strong></p><ul><li>集群控制节点，负责集群管理与控制，通常运行在独立物理节点或者虚拟机</li><li>运行各类关键进程<ul><li><p>API Server （kube-apiserver）：提供REST接口的关键服务进程</p><ul><li><p>集群管理的API入口</p><p>资源配额控制的入口</p><p>提供了完备的集群安全机制</p></li></ul></li><li><p>Controller Manager（kube-controller-manager)：所有资源的自动化控制中心</p><ul><li>ResourceQuota Controller</li><li>Namespace Controller</li><li>Endpoints Controller</li></ul></li><li><p>Scheduler（Kube-scheduler）：负责Pod资源调度</p></li><li><p>Etcd Server：所有资源对象的数据全部保存在etcd中</p></li></ul></li></ul><p><strong>Node</strong></p><blockquote><p>Kubernetes集群中除Master外的节点，又叫Minion，同样可以是物理主机或者虚拟机</p></blockquote><ul><li>作为集群中的工作负载节点，承担Master分配的工作负载<br>Node可以动态增减，新增node会自动到master节点注册</li><li>Node运行的进程：<ul><li>kubelet：pod启停及与master节点协作<ul><li>Ø节点管理</li><li>ØPod管理</li><li>Ø容器健康检查</li><li>Ø资源监控</li></ul></li><li>kube-proxy：实现Kubenetes Service通信与负载均衡机制</li><li>Docker Engine：负责本机容器的创建和管理工作</li></ul></li></ul><p><strong>Pod：</strong></p><ul><li>Pod是一组紧密关联的容器集合，是Kubernetes 调度的基本单位，不可分割。</li><li>一个Pod里的多个容器可以共享存储和网络，可以看作一个逻辑的主机。共享的如 namespace,cgroups或者其他的隔离资源。</li></ul><p>创建Pod时的大概流程：<br>1：<strong>kubectl</strong> 向K8s API发送一个REST HTTP请求<br>2：调度器将其调度到一个工作节点上<br>3：被调度的工作节点上的<strong>kubelet</strong>会告知Node节点上的Docker engine拉取镜像，下载后运行容器。</p><p><strong>创建pod</strong></p><blockquote><p>创建Pod可以使用两种方式，一种是通过命令行加各种命令行参数的方式，另一种是文件方式创建（推荐）</p></blockquote><ol><li><p>通过命令行直接创建: <code>kubectl run ${name} --image=${imageName} --port=${port}</code> (实际是运行了一个deployment，让deployment自动创建并维护pod)</p></li><li><p>通过yml文件创建， 文件可以为yml或者json: <code>kubectl apply -f ${fiileName}</code></p></li></ol><p><strong>删除Pods</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line">  # Delete a pod using the type and name specified in pod.json.</span><br><span class="line">  kubectl delete -f ./pod.json</span><br><span class="line">  </span><br><span class="line">  # Delete resources from a directory containing kustomization.yaml - e.g. dir/kustomization.yaml.</span><br><span class="line">  kubectl delete -k dir</span><br><span class="line">  </span><br><span class="line">  # Delete a pod based on the type and name in the JSON passed into stdin.</span><br><span class="line">  cat pod.json | kubectl delete -f -</span><br><span class="line">  </span><br><span class="line">  # Delete pods and services with same names &quot;baz&quot; and &quot;foo&quot;</span><br><span class="line">  kubectl delete pod,service baz foo</span><br><span class="line">  </span><br><span class="line">  # Delete pods and services with label name=myLabel.</span><br><span class="line">  kubectl delete pods,services -l name=myLabel</span><br><span class="line">  </span><br><span class="line">  # Delete a pod with minimal delay</span><br><span class="line">  kubectl delete pod foo --now</span><br><span class="line">  </span><br><span class="line">  # Force delete a pod on a dead node</span><br><span class="line">  kubectl delete pod foo --grace-period=0 --force</span><br><span class="line">  </span><br><span class="line">  # Delete all pods</span><br><span class="line">  kubectl delete pods --all</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --all=false: Delete all resources, including uninitialized ones, in the namespace of the specified resource types.</span><br><span class="line">  -A, --all-namespaces=false: If present, list the requested object(s) across all namespaces. Namespace in current context is ignored even if specified with --namespace.</span><br><span class="line">      --cascade=true: If true, cascade the deletion of the resources managed by this resource (e.g. Pods created by a ReplicationController).  Default true.</span><br><span class="line">      --field-selector=&apos;&apos;: Selector (field query) to filter on, supports &apos;=&apos;, &apos;==&apos;, and &apos;!=&apos;.(e.g. --field-selector key1=value1,key2=value2). The server only supports a limited number of field queries per type.</span><br><span class="line">  -f, --filename=[]: containing the resource to delete.</span><br><span class="line">      --force=false: Only used when grace-period=0. If true, immediately remove resources from API and bypass graceful deletion. Note that immediate deletion of some resources may result in inconsistency or data loss and requires confirmation.</span><br><span class="line">      --grace-period=-1: Period of time in seconds given to the resource to terminate gracefully. Ignored if negative. Set to 1 for immediate shutdown. Can only be set to 0 when --force is true (force deletion).</span><br><span class="line">      --ignore-not-found=false: Treat &quot;resource not found&quot; as a successful delete. Defaults to &quot;true&quot; when --all is specified.</span><br><span class="line">  -k, --kustomize=&apos;&apos;: Process a kustomization directory. This flag can&apos;t be used together with -f or -R.</span><br><span class="line">      --now=false: If true, resources are signaled for immediate shutdown (same as --grace-period=1).</span><br><span class="line">  -o, --output=&apos;&apos;: Output mode. Use &quot;-o name&quot; for shorter output (resource/name).</span><br><span class="line">  -R, --recursive=false: Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory.</span><br><span class="line">  -l, --selector=&apos;&apos;: Selector (label query) to filter on, not including uninitialized ones.</span><br><span class="line">      --timeout=0s: The length of time to wait before giving up on a delete, zero means determine a timeout from the size of the object</span><br><span class="line">      --wait=true: If true, wait for resources to be gone before returning. This waits for finalizers.</span><br></pre></td></tr></table></figure><p><strong>Pod API 对象的基本构成及书写格式</strong></p><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cpod_api.jpg" alt="pod_api"></p><p><strong>Pod各生命周期说明</strong></p><ul><li>Pending：挂起，Pod已被Kubernetes系统接受，但有一个或者多个容器镜像尚未创建。 等待时间包括Pod被调度的时间和通过网络下载镜像的时间</li><li>Running：运行中，该Pod已经绑定到了一个节点上，Pod中所有的容器都已被创建。至 少有一个容器正在运行，或者正处于启动或重启状态</li><li>Succeeded：Pod中的所有容器都被成功终止</li><li>Failed：失败，Pod中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也 就是说，容器以非0状态退出或者被系统终止</li><li>Unknown：因为某些原因无法取得Pod的状态，通常是因为与Pod所在主机通信失败</li><li>CrashLoopBackoff：Pod循环重启崩溃，通常是容器中的应用崩溃造成</li></ul><p><strong>pod配置</strong></p><ul><li><p>ImagePullPolicy</p><ul><li>Always：不管镜像是否存在都会进行一次拉取</li><li>Never：不管镜像是否存在都不会进行拉取</li><li>IfNotPresent：只有镜像不存在时，才会进行镜像拉取</li></ul></li><li><p>RestartPolicy</p><blockquote><p>在Pod中的容器可能会由于异常等原因导致其终止退出，Kubernetes提供了重 启策略以重启容器。重启策略对同一个Pod的所有容器起作用，容器的重启由 Node上的kubelet执行。</p></blockquote><ul><li>Always：只要退出就重启</li><li>OnFailure：失败退出（exit code不等于0）时重启</li><li>Never：只要退出就不再重启</li></ul><p>注意，这里的重启是指在Pod所在Node上面本地重启，并不会调度到其他Node上去。</p></li><li><p>resources</p><ul><li><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">tomcat:8.2.59</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"500Mi"</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">"500m"</span></span><br><span class="line"><span class="attr">      limits:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"1G"</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">"1"</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>健康检查</p><blockquote><p>为了确保容器在部署后确实处在正常运行状态，Kubernetes提供了两种探针（Probe）探测状态：</p><ul><li><strong>LivenessProbe</strong>：探测应用是否处于健康状态，如果不健康则删除并重启容器</li><li><strong>ReadinessProbe</strong>：探测应用是否启动完成并且处于正常服务状态，如果不正常则不会接收来自Kubernetes Service的流量</li></ul></blockquote><p>Kubernetes支持三种方式来执行探针：</p><ul><li><p>exec：在容器中执行一个命令，如果命令退出码返回0则表示探测成功，否则表示失败</p></li><li><p>tcpSocket：对指定的容器IP及端口执行一个TCP检查，如果端口是开放的则表示探测成功，否则表示失败</p></li><li><p>httpGet：对指定的容器IP、端口及路径执行一个HTTP Get请求，如果返回的状态码在[200,400)之间则表示探 测成功，否则表示失败</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line"><span class="attr">  httpGet:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    httpHeaders:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">X-Custom-Header</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">Awesome</span></span><br><span class="line"><span class="attr">  initialDelaySeconds:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  periodSeconds:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><p>Probe的精确配置:</p><ul><li>initialDelaySeconds：容器启动后第一次执行探测是需要等待多少秒</li><li>periodSeconds：执行探测的频率。默认是10秒，最小1秒</li><li>timeoutSeconds：探测超时时间。默认1秒，最小1秒</li><li>successThreshold：探测失败后，最少连续探测成功多少次才被认定为成功。默认是1 对于liveness必须是1，最小值是1</li><li>failureThreshold：探测成功后，最少连续探测失败多少次才被认定为失败。默认是3 最小值是1</li></ul></li></ul><p><strong>Label和Label Selector</strong></p><p>Label</p><ul><li>定义label： kubectl label ${sourceType} ${name} key=value</li><li>查看label： kubectl get ${type} --show-labels</li><li>删除label： kubectl label ${type} ${name} key-</li></ul><p>Labels Selector：</p><blockquote><p>通过标签选择器（Labels Selectors），进行查询和筛选拥有特定Label的资源对象</p></blockquote><p>目前支持两种选择器：equality-based（基于平等）和set-based（基于集合）的</p><ul><li>Equality-based：基于相等的或者不相等的条件允许用标签的keys和values进行过滤。匹配 的对象必须满足所有指定的标签约束，尽管他们可能也有额外的标签。有三种运算符是允 许的，“=”，“==”和“!=”。前两种代表相等性（他们是同义运算符），后一种代表 非相等性，多个可用逗号隔开如，非生产nginx：environment!=production,app=nginx</li><li>Set-based：用一组value来过滤key。支持三种操作符: In ，NotIn，Exists，DoesNotExists，  前两个value不能为空，后两个仅针对于key，没有value</li></ul><p><strong>labels，selector操作</strong></p><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Clabel.png" alt="label"></p><p><strong>Controller</strong></p><blockquote><p>controller manager 是各种controller的管理者,是集群内部的管理控制中心。</p><p>在K8S 拥有很多controller 他们的职责是保证集群中各种资源的状态和用户定义(yaml)的状态一致, 确保任何时候都在运行指定数量的Pod副本。 换句话说,Controller确保一个容器或一组相同的容器始终处于可用状态。</p></blockquote><ul><li>ReplicationController</li><li>ReplicaSet</li><li>Deployments</li><li>DaemonSet</li><li>StatefulSets</li></ul><h3 id="deployment"><a class="markdownIt-Anchor" href="#deployment"></a> <strong>Deployment</strong></h3><blockquote><p>Deployment面向的是部署无状态应用， statefulset  : 部署有状态应用</p></blockquote><p>Deployment的典型应用场景</p><ul><li><p><strong>定义Deployment来创建Pod和ReplicaSet</strong></p></li><li><p>滚动升级和回滚应用</p><ul><li><p>`•kubectl rollout undo deployment/nginx-deployment</p><p>•deployment “nginx-deployment” rolled back`</p></li></ul></li><li><p>扩容和缩容</p></li><li><p>暂停和继续</p></li></ul><p><strong>Kubernetes上有状态服务</strong></p><ul><li>Volume</li><li>Persistent Volume</li></ul><p>demo：创建包含3个nginx应用pod的deployment</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1 </span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">    name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">    replicas: 3</span><br><span class="line">    template:</span><br><span class="line">        metadata: </span><br><span class="line">            labels:</span><br><span class="line">                app: nginx</span><br><span class="line">        spec:</span><br><span class="line">            containers:</span><br><span class="line">            -  name: nginx</span><br><span class="line">                image:  nginx:1.7.9 </span><br><span class="line">                ports:</span><br><span class="line">                -  containerPort: 80</span><br></pre></td></tr></table></figure><h3 id="service详解"><a class="markdownIt-Anchor" href="#service详解"></a> <strong>Service详解：</strong></h3><ul><li><p>Kubernetes中最核心的资源对象之一，Pod、RC等其实都是Service</p></li><li><p>Service是对<strong>一组提供相同功能</strong>的<strong>Pods的抽象</strong>，并为它们提供一个统一的入口，简单来说，可以把service理解为一个负载均衡器。借助Service，应用可以方便的实现 <u>服务发现与负载均衡</u>，并实现应用的稳定升级。Service通过<strong>标签</strong>来选取服务后端，一般配合Replication  Controller或者Deployment来保证后端容器的正常运行。这些<u>匹配标签的Pod IP和端口列表</u>组成<strong>endpoints</strong>，由 kube-proxy负责将服务IP负载均衡到这些endpoints上。</p></li><li><p>它定义了一组Pod的逻辑集合和一个用于访问它们的策略，其实这个概念和微服务非常类似。一个Serivce下面包含的Pod集合一般是由Label Selector来决定的。</p></li><li><p>Service默认有自己的ip和端口的叫<strong>cluster-ip</strong>和<strong>port</strong>构成了endpoint，内部可以直接通过这个endpoint去访问应用。</p><ul><li>不过有一点需要注意，这个cluster-ip是个Virtual IP，它是ping不通的，底层转发是通过node节点上的kube-proxy调用iptables生成对应的转发规则。<ul><li>ClusterIP：默认类型，自动分配一个仅cluster内部可以访问的虚拟IP</li><li>NodePort：在ClusterIP基础上为Service在每台机器上绑定一个端口，这样就可以通过<code>&lt;NodeIP&gt;:NodePort</code>来 访问该服务</li><li>LoadBalancer：在NodePort的基础上，借助cloud provider创建一个外部的负载均衡器，并将请求转发到</li></ul></li></ul></li><li><p>Service有四种类型：</p><ul><li>ClusterIP</li><li>NodePort</li><li>LoadBalancer</li><li>ExternalName</li></ul></li><li><p><strong>Service定义</strong></p><ul><li><p>Service的定义也是通过yaml或json，比 如下面定义了一个名为nginx的服务， 将 服 务 的 80 端 口 转 发 到 default namespace中带有标签run=nginx的Pod 的80端口</p></li><li><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">nginx</span>  </span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span><span class="comment"># k8s 集群内部访问service端口， 通过cluster_ip:port 请求某个service</span></span><br><span class="line"><span class="attr">     protocol:</span> <span class="string">TCP</span>  </span><br><span class="line"><span class="attr">     targetPort:</span> <span class="number">80</span>  </span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">nginx</span>  </span><br><span class="line"><span class="attr">    sessionAffinity:</span> <span class="string">None</span>  </span><br><span class="line"><span class="attr">    type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>Q: 如何访问服务?</strong></p><blockquote><p>每个Pod都提供独立的EndPoint（Pod IP + Container Port），访问请求如何映射到具体的Pod？</p></blockquote><p>A: 开启负载均衡器kube-proxy，客户端通过负载均衡器调度到相应的pod，每个Service分配一个全局唯一的虚拟IP地址（Cluster IP），Pod的Endpoint地址会随着pod的销毁和创新创建而改变，但是cluster ip在Service生命周期内不会改变，因此用servcie name和cluster ip作为DNS域名，就可以解决服务访问问题</p><p><strong>外部系统访问Service:</strong></p><ul><li>Node IP： 节点IP地址，<u>真实网络网卡的IP</u></li><li>Pod IP：Pod的IP地址，<u>根据docker0网桥的IP段进行分配</u>，虚拟二层网络，实现Pod之间的通信</li><li>Cluster IP: Service IP地址<ul><li>仅服务Kubernetes Service对象</li><li>没有对应的实体网络，无法直接ping通</li><li>只能结合Service Port组成具体通信端口，集群之外无法访问</li><li>集群内可以使用内部路由规则进行通信，如何在外部访问？NodePort</li></ul></li></ul><p><strong>IP和Port</strong></p><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cip_port.jpg" alt="ip_port"></p><p>见： <a href="https://zhuanlan.zhihu.com/p/358916098" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/358916098</a></p><h3 id="如何将服务暴露给外部客户端"><a class="markdownIt-Anchor" href="#如何将服务暴露给外部客户端"></a> <strong>如何将服务暴露给外部客户端？</strong></h3><ul><li><p>将服务的类型设置成NodePort</p><ul><li><p>每个集群节点都会在节点上打开一个端口，对于NodePort服务，每个集群节点在节点本身上打开一个端口，并将在该端口上接收到的流量重定向到基础服务。所以该服务仅在内部集群IP 和端口上才可访问</p></li><li><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span>      <span class="comment">#为NodePort设置服务类型</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span>               <span class="comment"># k8s 集群内部访问service端口[服务集群IP (service cluster IP)的端口号]， 通过clusterip:port 请求某个service</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">8080</span>  <span class="comment"># 背后Pod的目标端口号</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30123</span>  <span class="comment"># 通过集群节点的30123端口可以访问该服务</span></span><br><span class="line"><span class="attr">   selector:</span> </span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>保存好yaml文件可用通过以下命令创建并且查看目标服务, <code>$ kubectl apply –f service.yaml</code>, <code>$ kubectl get svc my-service</code></p><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Csvc_nodeport.png" alt="svc_nodeport"></p><p>PORT(S)列显示集群IP (80) 的内部端口和节点端口(30123)</p><p>可以通过以下地址访问该服务：10.11.254.223:80</p></li><li><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cexpose_NodePort.png" alt="expose_NodePort"></p><ul><li>服务暴露在两个集群节点的端口30123上，它到达任何一个端口的传入连接将都被重定向到一个随机选择的pod, 该pod是否位于接收到连接的节点上是不确定的。</li><li>在第一个节点的端口30123收到的连接， 可以被重定向到第一节点个上运行的 pod, 也可能是第二个节点上运行的pod</li><li>所以在通过节点端口访间服务之前， 有时需要配置防火墙， 来允许外部连接到该端口上的节点。</li></ul></li></ul></li><li><p>将服务的类型设置成LoadBalance（负载均衡器）</p><ul><li><p>负载均衡器拥有自己独一无二的可公开访问的 IP 地址， 并将所有连接重定向到服务。用户可以通过负载均衡器的 IP 地址访问服务。</p></li><li><p>如果Kubernetes在不支持Load Balancer服务的环境中运行， 则不会调配负载平衡器， 但该服务仍将表现得像一个NodePort服务。 这是因为Load Balancer服务是NodePort服务的扩展。</p></li><li><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">loadbalancer-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">LoadBalancer</span>        <span class="comment"># 为LoadBalance设置服务类型</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span>              <span class="comment"># 服务集群IP的端口号</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">8080</span>  <span class="comment"># 背后Pod的目标端口号</span></span><br><span class="line"><span class="attr">   selector:</span> </span><br><span class="line"><span class="attr">      app:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Csvc_LoadBalancer.png" alt="svc_LoadBalancer"></p><p>PORT(S)列显示集群IP (80) 的内部端口和节点端口(31698)</p><p>可以通过以下地址访问该服务：10.99.34.164:80</p></li></ul></li><li><p>创建一个Ingress资源</p><ul><li><p>为什么需要 Ingress ？</p></li><li><p>一个重要的原因是每个 LoadBalancer 服务都需要自己的负载均衡器， 以及独有的公有IP 地址，而 Ingress 只需要一个公网 IP 就能为许多服务提供访问。 当客户端向 Ingress 发送 HTTP请求时，Ingress 会根据<strong>请求的主机名和路径</strong>决定请求转发到的服务。</p></li><li><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Csvc_ingress%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" alt="svc_ingress工作原理"></p></li><li><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单规则的 Ingress</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">test-ingress</span>  </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  backend:</span>        <span class="comment"># </span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">test</span>    <span class="comment"># 将所有的请求发送到test服务的80端口</span></span><br><span class="line"><span class="attr">  servicePort:</span> <span class="number">80</span>      <span class="comment"># </span></span><br><span class="line"><span class="comment"># 根据不同路径转发到不同服务器</span></span><br><span class="line"><span class="string">…</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">website.com</span> </span><br><span class="line"><span class="attr">     http:</span></span><br><span class="line"><span class="attr">        paths:</span> </span><br><span class="line"><span class="attr">        - path:</span> <span class="string">/web</span></span><br><span class="line"><span class="attr">           backend:</span></span><br><span class="line"><span class="attr">             serviceName:</span> <span class="string">s1</span>   </span><br><span class="line"><span class="attr">             servicePort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">       - path:</span> <span class="string">/api</span></span><br><span class="line"><span class="attr">           backend:</span></span><br><span class="line"><span class="attr">             serviceName:</span> <span class="string">s2</span></span><br><span class="line"><span class="attr">       servicePort:</span> <span class="number">8081</span></span><br><span class="line"><span class="comment"># 根据不同的主机（host) 暴露出多种服务</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">foo.bar.com</span> </span><br><span class="line"><span class="attr">     http:</span></span><br><span class="line"><span class="attr">        paths:</span> </span><br><span class="line"><span class="attr">        - backend:</span></span><br><span class="line"><span class="attr">           serviceName:</span> <span class="string">s1</span>   </span><br><span class="line"><span class="attr">           servicePort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">bar.foo.com</span> </span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">       paths:</span> </span><br><span class="line"><span class="attr">       - backend:</span>  </span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">s2</span></span><br><span class="line"><span class="attr">    servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>service与deployment区别</strong></p><ul><li>pod： pod 是 kubernetes 中最小的编排单位，通常由一个容器组成 (有时候会有多个容器组成)</li><li>service： 一个网络下的pod集合。service 使用labels标签来<strong>选择</strong>代理的pod。</li><li>Deployment：为了在 k8s 中编排应用可以更好地做弹性扩容，负载均衡，deployment 作用于一组pods的创建和运行</li></ul><p>▲所以service 和deployment的区别，就是一个是从<strong>网络角度</strong>的<strong>抽象概念</strong>service，类型nginx做负载均衡提供的统一网络入口。而pod是<strong>最终的应用部署实体</strong>。 deoplyment <strong>负责创建和保持</strong>pod运行状态</p><p>service 可以独立于deployment工作，但是需要一个个去创建pod，而不是像deployment那样一次性创建。deployment也可以独立于service工作。虽然service和deployment是有区别的，但不影响他们一同协同工作</p><p><strong>ConfigMap</strong></p><ul><li>ConfigMap用于保存配置数据的键值对，可以用来保存单个属性，也可以用来保存配置文件。</li><li>可以使用kubectl create configmap从文件、目录或者key-value字符串创建等创建 ConfigMap。也可以通过<code>kubectl create -f file</code>创建。</li></ul><p><strong>HPA(Horizontal Pod Autoscaler)</strong></p><ul><li>Kubernetes资源对象，支持Pod横向自动扩容</li><li>Pod负载度量指标：<ul><li>CPU utilizaiton — Pod CPU利用率均值</li><li>TPS or Qps</li></ul></li></ul><p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5CHPA.png" alt="HPA"></p><h3 id="容器化改造过程"><a class="markdownIt-Anchor" href="#容器化改造过程"></a> 容器化改造过程</h3><p>第一步：<strong>简单容器化，应用无改造</strong>—&gt;<strong>效果：自动化应用上线、升级、版本回滚、监控、报警</strong></p><p>第二步：<strong>应用去状态</strong>—&gt; <strong>效果：自动化故障恢复、高可用</strong></p><p>第三步：<strong>微服务，可重用</strong></p><p>传统单体架构缺点：</p><ul><li>加载、编译耗时长</li><li>代码管理复杂</li><li>横向扩展难</li><li>各模块之间耦合度高</li><li>模块问题排查困难</li></ul><p>微服务架构优点：</p><ul><li>允许不同语言编写，易于引入新技术</li><li>微服务商店模式，快速组合与重构</li><li>模块解耦，不同的SLA保障计划</li><li>更高的扩展性和可用性</li></ul><h3 id="kubernetes网络原理"><a class="markdownIt-Anchor" href="#kubernetes网络原理"></a> Kubernetes网络原理</h3><p>Kubernetes网络设计主要考虑了几种通信场景</p><ul><li>同一个Pod内容器间互通<ul><li><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cnet%E5%90%8C%E4%B8%80%E4%B8%AAPod%E5%86%85%E5%AE%B9%E5%99%A8%E9%97%B4%E4%BA%92%E9%80%9A.png" alt="net同一个Pod内容器间互通"></li></ul></li><li>同一个Node上Pod间互通<ul><li>Pod1与Pod2都是通过虚拟网络设备Veth，  连接到同一个docker0 bridge的，这两个 Pod的IP地址也是通过docker0网段动态分配 的，与docker0 bridge属于同一个网段。</li><li>Pod的默认路由都是docker0 bridge的地址，  所有非本地地址的网络数据，默认都会发送 到docker0网桥上，由docker0网桥中转</li><li>Pod与docker0之间是Veth设备对连接的，而 docker0 bridge与Node的eth0是路由转发的，  Docker0上默认网关就是Node的eth0</li><li><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cnet%E5%90%8C%E4%B8%80%E4%B8%AANode%E4%B8%8APod%E9%97%B4%E4%BA%92%E9%80%9A.png" alt="net同一个Node上Pod间互通"></li></ul></li><li>不同Node上Pod间的互通<ul><li><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cnet%E4%B8%8D%E5%90%8CNode%E4%B8%8APod%E9%97%B4%E7%9A%84%E4%BA%92%E9%80%9A%E3%80%90Overlay%E6%96%B9%E6%A1%88%E3%80%91.png" alt="net不同Node上Pod间的互通【Overlay方案】"></li></ul></li><li>Service与Pod之间的通信<ul><li><strong>实现方式为kube-proxy</strong>: 以暴露NodePort的Service为例，NodePort的工作原理与ClusterIP大致相同，发送到某个 NodeIP:NodePort的请求，通过iptables重定向到kube-proxy对应的端口(Node上的随机端口)上，然 后由kube-proxy再将请求发送到其中的一个Pod:TargetPort</li><li>三种proxyMode：<ul><li>Userspace Mode：v1.0及之前版本的默认模式</li><li>Iptables Mode：v1.1开始增加支持，v1.2正式成为默认模式</li><li>IPVS Mode：v1.8开始增加支持，v1.11正式成为默认模式</li></ul></li></ul></li><li>K8s集群内外组件间通信<ul><li><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5CnetK8s%E9%9B%86%E7%BE%A4%E5%86%85%E5%A4%96%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1.png" alt="netK8s集群内外组件间通信"></li></ul></li></ul><h3 id="调用k8s服务的过程"><a class="markdownIt-Anchor" href="#调用k8s服务的过程"></a> 调用K8S服务的过程</h3><p>当外部client访问服务器时，首先访问服务器一致对外提供的接口，通过这一接口再将请求<strong>workload</strong>到每台主机上（每台主机上都有相对应的NodePort端口即notePort的Service来接受这一请求），每个service服务上都有一个对应的ClusterIP,通过ClusterIP和每台主机上的IPTables表以及label筛选，service就可以将请求workload到具体的每个pod上（endpoint）。</p><p><img src="https://img-blog.csdn.net/2018080517460013?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODI4MTQ1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录：</h1><h2 id="vscode环境配置"><a class="markdownIt-Anchor" href="#vscode环境配置"></a> Vscode环境配置</h2><ul><li>docker插件下载：</li><li>k8s插件下载:<ul><li><a href="https://www.cnblogs.com/xuelong3/p/12873022.html" target="_blank" rel="noopener">icepanel</a></li><li><a href="https://blog.csdn.net/shenhonglei1234/article/details/95471305" target="_blank" rel="noopener">Kubernetes Tools</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zju要求&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#zju要求&quot;&gt;&lt;/a&gt; ZJU要求&lt;/h1&gt;
&lt;h2 id=&quot;课程内容&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#课程内容&quot;&gt;&lt;/a&gt; 课程内容&lt;
      
    
    </summary>
    
    
      <category term="ZJU课程" scheme="https://nymrli.top/tags/ZJU%E8%AF%BE%E7%A8%8B/"/>
    
      <category term="云原生" scheme="https://nymrli.top/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>docker部署springboot项目</title>
    <link href="https://nymrli.top/2021/09/21/docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"/>
    <id>https://nymrli.top/2021/09/21/docker部署springboot项目/</id>
    <published>2021-09-21T03:34:05.000Z</published>
    <updated>2021-10-25T08:32:49.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于最近在学云原生的课会接触到docker和k8s，因此试验了如何通过docker来部署springboot。</p><p>由于docker的实现依赖于linux内核提供的cgroups和namespace功能，而windows支持还没找到非常好的解决方案，因此在功能上windows docker还是有缺陷。我尝试过安装docker desktop for windows但是在WSL2的安装上失败了（2021年9月21日），试了二十分钟无果后放弃，决定还是在linux上构建。</p></blockquote><h1 id="服务器上搭建java环境和docker环境"><a class="markdownIt-Anchor" href="#服务器上搭建java环境和docker环境"></a> 服务器上搭建Java环境和docker环境</h1><blockquote><p>由于将docker的构建放到了服务器上，因此这部分可以理解为是<strong>构建打包环境</strong></p></blockquote><h2 id="构建打包环境"><a class="markdownIt-Anchor" href="#构建打包环境"></a> 构建打包环境</h2><ol><li><p>JDK安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 登录网址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html， 选择对应jdk版本下载</span></span><br><span class="line"><span class="comment"># 2. 解压, 注文件名跟下载的jdk版本有关</span></span><br><span class="line">tar -zxvf jdk-8u144-linux-x64.tar.gz</span><br><span class="line"><span class="comment">#、然后将文件夹jdk1.8.0_144移动到目录/opt下</span></span><br><span class="line">sudo mv jdk1.8.0_144 /usr/<span class="built_in">local</span></span><br><span class="line"><span class="comment"># 4、修改环境变量</span></span><br><span class="line">sudo vi ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在~/.bashrc中添加</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/jdk1.8.0_144</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 5、保存并退出，使用source命令使之生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 6、查看安装情况</span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure></li><li><p>mvn安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.登陆镜像源https://mirrors.bfsu.edu.cn/apache/maven/， 选择合适的mvn版本下载</span></span><br><span class="line">wget https:``//mirrors.bfsu.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxvf apache-maven-3.6.3-bin.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">sudo mv apache-maven-3.6.3 /usr/local/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line">export M2_HOME=/usr/local/apache-maven-3.6.3</span><br><span class="line">export PATH=$&#123;M2_HOME&#125;/bin:$PATH</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生效环境变量， 或者<span class="built_in">source</span> /etc/profile</span></span><br><span class="line">source !$</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试效果</span></span><br><span class="line">mvn -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 换mvn源</span></span><br><span class="line">sudo vim /usr/local/apache-maven-3.6.3/conf/settings.xml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在&lt;mirrors&gt;&lt;/mirrors&gt;中增加下列信息后保存退出</span></span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure></li><li><p>docker安装</p></li></ol><h2 id="镜像build"><a class="markdownIt-Anchor" href="#镜像build"></a> 镜像build</h2><ol><li><h3 id="创建springboot-web工程"><a class="markdownIt-Anchor" href="#创建springboot-web工程"></a> 创建springboot web工程</h3><p>然后创建个最基础的controller, 添加完毕后启动项目，启动成功后浏览器访问：<code>http://localhost:8080/</code>如果显示正常则说明springboot配置正常</p></li><li><h3 id="springboot项目增加docker支持"><a class="markdownIt-Anchor" href="#springboot项目增加docker支持"></a> springboot项目增加docker支持</h3><ul><li>pom.xml中添加</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">docker.image.prefix</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">docker.image.prefix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>src/main/docker<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在目录<code>src/main/docker</code>下创建 Dockerfile 文件，Dockerfile 文件用来说明如何来构建镜像。</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="bash"><span class="comment"># 注：spring-boot-docker-1.0.jar是需要根据自己项目mvn package生成的压缩包名来写的</span></span></span><br><span class="line"><span class="bash">ADD spring-boot-docker-1.0.jar app.jar</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span></span><br></pre></td></tr></table></figure><p>这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下:</p><ul><li>FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载</li><li>VOLUME ，VOLUME 指向了一个<code>/tmp</code>的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用<code>/tmp</code>作为工作目录。这个命令的效果是：在宿主机的<code>/var/lib/docker</code>目录下创建一个临时文件并把它链接到容器中的<code>/tmp</code>目录</li><li>ADD ，拷贝文件并且重命名</li><li>ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加<code>java.security.egd</code>的系统属性指向<code>/dev/urandom</code>作为 ENTRYPOINT</li></ul><blockquote><p>这样 Spring Boot 项目添加 Docker 依赖就完成了。</p></blockquote></li><li><h3 id="使用-docker-部署-spring-boot-项目"><a class="markdownIt-Anchor" href="#使用-docker-部署-spring-boot-项目"></a> 使用 Docker 部署 Spring Boot 项目</h3><p>将项目 <code>spring-boot-docker</code> 拷贝服务器中，进入项目路径下进行打包测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包</span></span><br><span class="line">mvn package</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">java -jar target/spring-boot-docker-1.0.jar</span><br><span class="line"><span class="comment"># 看到 Spring Boot 的启动日志后表明环境配置没有问题，接下来我们使用 DockerFile 构建镜像。</span></span><br><span class="line"><span class="comment"># 注： 在打包前先确保docker启动：systemctl start docker</span></span><br><span class="line">mvn package docker:build</span><br><span class="line"><span class="comment"># 第一次构建可能有点慢，当看到以下内容的时候表明构建成功：</span></span><br><span class="line">...</span><br><span class="line">Step 1 : FROM openjdk:8-jdk-alpine</span><br><span class="line"> ---&gt; 224765a6bdbe</span><br><span class="line">Step 2 : VOLUME /tmp</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; b4e86cc8654e</span><br><span class="line">Step 3 : ADD spring-boot-docker-1.0.jar app.jar</span><br><span class="line"> ---&gt; a20fe75963ab</span><br><span class="line"> ...</span><br><span class="line"> [INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 54.346 s</span><br><span class="line">[INFO] Finished at: 2018-03-13T16:20:15+08:00</span><br><span class="line">[INFO] Final Memory: 42M/182M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>使用<code>docker images</code>命令查看构建好的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">springboot/spring-boot-docker   latest              99ce9468da74        6 seconds ago       117.5 MB</span><br></pre></td></tr></table></figure><p><code>springboot/spring-boot-docker</code> 就是我们构建好的镜像，下一步就是运行该镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -t springboot/spring-boot-docker</span><br></pre></td></tr></table></figure><p>启动完成之后我们使用<code>docker ps</code>查看正在运行的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">049570da86a9        springboot/spring-boot-docker   &quot;java -Djava.security&quot;   30 seconds ago      Up 27 seconds       0.0.0.0:8080-&gt;8080/tcp   determined_mahavira</span><br></pre></td></tr></table></figure><p>可以看到我们构建的容器正在在运行，访问浏览器：<code>http://192.168.0.x:8080/</code>,返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Docker!</span><br></pre></td></tr></table></figure><p>说明使用 Docker 部署 Spring Boot 项目成功！</p></li></ol><h2 id="踩坑"><a class="markdownIt-Anchor" href="#踩坑"></a> 踩坑：</h2><h3 id="用户权限"><a class="markdownIt-Anchor" href="#用户权限"></a> 用户权限</h3><p>在执行<code>mvn package docker:build</code>出现<code>com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: java.io.IOException: Permission denied</code>需要查看下docker是否安装正常，docker是否打开，<strong>当前用户是否具有执行docker命令的权限</strong>（我的个人账号mrli就没有权限，需要将其加入docker用户组，否则得加sudo）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker #添加docker用户组</span><br><span class="line">sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中</span><br><span class="line">newgrp docker #更新用户组</span><br></pre></td></tr></table></figure><p>参考：<a href="http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html" target="_blank" rel="noopener">http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html</a></p><h1 id="进阶使用docker-nginxspringbootmysqldocker-compose"><a class="markdownIt-Anchor" href="#进阶使用docker-nginxspringbootmysqldocker-compose"></a> 进阶使用Docker： nginx+springBoot+mysql+docker-compose</h1><blockquote><p>Docker-Compose 是 Docker 的一种编排服务，是一个用于在 Docker 上定义并运行复杂应用的工具，可以让用户在集群中部署分布式应用。</p><p>前两篇文章我们介绍了 Dockerfile 的使用<a href="http://www.ityouknow.com/docker/2018/03/12/docker-use-dockerfile.html" target="_blank" rel="noopener">Docker(二)：Dockerfile 使用介绍</a>，我们知道使用一个 Dockerfile 模板文件可以定义一个单独的应用容器，如果<strong>需要定义多个容器就需要服务编排</strong>。服务编排有很多种技术方案，今天给大家介绍 Docker 官方产品 Docker Compose 。</p><p>Dockerfile 可以让用户管理一个单独的应用容器；而 Compose 则允许用户在一个模板（YAML 格式）中定义一组相关联的应用容器（被称为一个 project，即项目），例如一个 Web 服务容器再加上后端的数据库服务容器等。</p><p>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</p></blockquote><p>Q: Spring Boot + Nginx + Mysql 是实际工作中最常用的一个<strong>组合</strong>，最前端使用 Nginx 代理请求转发到后端 Spring Boot 内嵌的 Tomcat 服务，Mysql 负责业务中数据相关的交互，那么在没有 docker 之前，我们是如何来搞定这些环境的呢？</p><ul><li>1、安装 Nginx，配置 Nginx 相关信息，重启。</li><li>2、安装 Mysql ，配置字符集时区等信息，重启，最后初始化脚本。</li><li>3、启动 Spring Boot 项目，整体进行联调测试。</li></ul><p>大家看我只写了三行，但其实搭建这些环境的时候还挺费事的，但这还不是结局，在用了一段时间时候需要迁移到另外一个环境，怎么办又需要重新搞一次？正常情况下，测试环境、SIT 环境、UAT 环境、生产环境！我们需要重复搭建四次。有人说不就是搭建四次吗？也没什么大不了的，那么我想告诉你，Too yong ,Too Simple 。</p><p>让我们看看以下几个因素：</p><p>第一，这只是一个最简单的案例，如果项目涉及到 MongoDB、Redis、ES … 一些列的环境呢？ 第二，如果你经常搭建环境或者调试程序，你就会知道什么是环境问题？有的时候明明是一模一样的配置，但是到了另外一个环境就是跑不起来。于是你花费很多时间来查找，最后才发现是少了一个参数或者逗号的问题，或者是系统内核版本不一致、或者你最后也没搞懂是为什么！只能再换另外一台服务器，那么使用 Docker 呢就可以完美的避开这些坑。</p><p>优点总结如下：</p><ul><li>涉及多个环境的时候，一次定义到处使用</li><li>便于实现环境地快速迁移</li><li>保证多次配置的配置一次性，以及在不同机器上的配置统一性</li><li>一键化地实现多个服务的上线和下限</li></ul><p>A: 通过docker来提供虚拟化隔离的运行环境</p><h2 id="docker-compose-安装"><a class="markdownIt-Anchor" href="#docker-compose-安装"></a> Docker Compose 安装</h2><p>Docker Compose 是 Docker 的独立产品，因此需要安装 Docker 之后在单独安装 Docker Compose .</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname -s`-`uname -m` -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><p>同样，如果出现了直接<code>docker-compose version</code>无效而<code>sudo docker-compose version</code>有效的情况， 重启服务加上用户权限和刷新用户组后再次尝试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建docker组</span></span><br><span class="line">vagrant@ubuntu18:~$ sudo groupadd docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> &gt;&gt;&gt; groupadd: group ‘docker‘ already exists</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将当前用户加入docker组</span></span><br><span class="line">vagrant@ubuntu18:~$ sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> &gt;&gt;&gt; Adding user weiyj to group docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash">重启docker服务</span></span><br><span class="line">vagrant@ubuntu18:~$ sudo service docker restart</span><br><span class="line"><span class="meta">#</span><span class="bash">刷新docker组成员</span></span><br><span class="line">vagrant@ubuntu18:~$ newgrp docker</span><br><span class="line"><span class="meta">#</span><span class="bash">再试试命令^_^</span></span><br><span class="line">vagrant@ubuntu18:~$ docker-compose version</span><br></pre></td></tr></table></figure><p><strong>安装补全工具(可选)</strong></p><p>为了方便我们输入命令，也可以安装 Docker 的补全提示工具帮忙我们快速输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line">yum install bash-completion</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下载docker-compose脚本</span></span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><h2 id="工程搭建"><a class="markdownIt-Anchor" href="#工程搭建"></a> 工程搭建</h2><p>项目结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">│   ├── HELP.md</span><br><span class="line">│   ├── mvnw</span><br><span class="line">│   ├── mvnw.cmd</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   │   ├── main</span><br><span class="line">│   │   │   ├── docker</span><br><span class="line">│   │   │   │   └── Dockerfile</span><br><span class="line">│   │   │   ├── java</span><br><span class="line">│   │   │   │   └── top</span><br><span class="line">│   │   │   │       └── nymrli</span><br><span class="line">│   │   │   │           └── testdocker</span><br><span class="line">│   │   │   │               ├── controller</span><br><span class="line">│   │   │   │               │   ├── HelloController.java</span><br><span class="line">│   │   │   │               │   └── VisitorController.java</span><br><span class="line">│   │   │   │               ├── model</span><br><span class="line">│   │   │   │               │   └── Visitor.java</span><br><span class="line">│   │   │   │               ├── repository</span><br><span class="line">│   │   │   │               │   └── VisitorRepository.java</span><br><span class="line">│   │   │   │               └── TestdockerApplication.java</span><br><span class="line">│   │   │   └── resources</span><br><span class="line">│   │   │       ├── application-dev.properties</span><br><span class="line">│   │   │       ├── application-docker.properties</span><br><span class="line">│   │   │       ├── application.properties</span><br><span class="line">│   │   │       ├── application-test.properties</span><br><span class="line">│   │   │       ├── static</span><br><span class="line">│   │   │       ├── templates</span><br><span class="line">│   │   │       └── visiitor.sql</span><br><span class="line">│   │   └── test</span><br><span class="line">│   │       └── java</span><br><span class="line">│   │           └── top</span><br><span class="line">│   │               └── nymrli</span><br><span class="line">│   │                   └── testdocker</span><br><span class="line">│   │                       └── TestdockerApplicationTests.java</span><br><span class="line">│   └── testdocker.iml</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">└── nginx</span><br><span class="line">    └── conf.d</span><br><span class="line">        └── app.conf</span><br></pre></td></tr></table></figure><p>其中最核心的几个配置文件：</p><ul><li><code>docker-compose.yaml</code>：docker-compose 的核心文件，描述如何构建整个服务</li><li><code>nginx</code>：有关 nginx 的配置</li><li><code>app</code>：Spring Boot 项目地址<ul><li>Dockerfile：app中的dockerfile镜像构建文件</li></ul></li></ul><p>如果我们需要对 Mysql 有特殊的定制，也可以在最外层创建 mysql 文件夹，在此目录下进行配置。</p><h3 id="nginx-文件解读"><a class="markdownIt-Anchor" href="#nginx-文件解读"></a> Nginx 文件解读</h3><p>nginx 在目录下有一个文件 app.conf，主要配置了服务转发信息</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;<span class="comment"># 侦听80端口</span></span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://app:8080;<span class="comment"># 将80端口的http请求转发到服务 app 的8080端口处理</span></span><br><span class="line">        <span class="comment"># ▲注：这里使用是app而不是localhost，是因为他们没有在一个容器中，在一组 compose 的服务通讯需要使用 services 的名称进行访问。</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Host <span class="variable">$server_name</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态文件处理</span></span><br><span class="line">    <span class="attribute">location</span> /static &#123;</span><br><span class="line">        <span class="attribute">access_log</span>   <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">expires</span>      <span class="number">30d</span>;</span><br><span class="line">        <span class="attribute">alias</span> /app/static;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dockerfile配置"><a class="markdownIt-Anchor" href="#dockerfile配置"></a> Dockerfile配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM maven:3.5-jdk-8</span><br></pre></td></tr></table></figure><h3 id="application-dockerproperties"><a class="markdownIt-Anchor" href="#application-dockerproperties"></a> application-docker.properties</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://mysql:3306/test</span><br><span class="line"># 注：数据库的连接信息由jdbc:mysql://localhost:3306/test改为jdbc:mysql://mysql:3306/test, 原因跟nginx配置一样, URI在docker-compose中需要通过services通信</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><h3 id="docker-composeyml"><a class="markdownIt-Anchor" href="#docker-composeyml"></a> docker-compose.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span>    <span class="comment"># 表示使用第三代语法来构建 docker-compose.yaml 文件。</span></span><br><span class="line"><span class="attr">services:</span>       <span class="comment"># 用来表示 compose 需要启动的服务，我们可以看出此文件中有三个服务分别为：nginx、mysql、app。</span></span><br><span class="line"><span class="attr">  nginx:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">v-nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">nginx:1.13</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8088</span><span class="string">:80</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  mysql:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">v-mysql</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">mysql/mysql-server:5.7</span></span><br><span class="line"><span class="attr">    environment:</span>                <span class="comment"># 此节点下的信息会当作环境变量传入容器，此示例中 mysql 服务配置了数据库、密码和权限信息。</span></span><br><span class="line"><span class="attr">      MYSQL_DATABASE:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_HOST:</span> <span class="string">'%'</span></span><br><span class="line"><span class="attr">    ports:</span>                      <span class="comment"># 表示对外开放的端口</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3306:3306"</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span>           <span class="comment"># 表示如果服务启动不成功会一直尝试。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  app:</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">./app/src/main/docker</span>              <span class="comment"># 基于Dockerfile，指定Dockerfile所在路径,Compose会利用它自动构建镜像，然后启动服务容器</span></span><br><span class="line"><span class="attr">    working_dir:</span> <span class="string">/app</span></span><br><span class="line"><span class="attr">    volumes:</span>                  <span class="comment"># 加载本地目录下的配置文件到容器目标地址下</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./app:/app</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">~/.m2:/root/.m2</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8080"</span></span><br><span class="line"><span class="attr">    depends_on:</span>               <span class="comment"># 可以配置依赖服务，表示需要先启动 depends_on 下面的服务后，再启动本服务。</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">nginx</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">mvn</span> <span class="string">clean</span> <span class="attr">spring-boot:run</span> <span class="bullet">-Dspring-boot.run.profiles=docker</span></span><br><span class="line">    <span class="comment"># 表示以这个命令来启动项目，-Dspring-boot.run.profiles=docker表示使用 application-docker.properties文件配置信息进行启动。</span></span><br></pre></td></tr></table></figure><p>注： 由于服务器的80端口跑的是裸机运行的web程序，因此无法用nginx侦听80端口，因此在compose.yml中nginx的port映射写的是8088，这个是web应用真正想要输出的web端口（注意需要在阿里云上打开该端口的防火墙），而8088映射到容器的80端口后又会由nginx.conf转发到8080端口即真正的web app的运行端口上。</p><h3 id="visitorcontrollerjava"><a class="markdownIt-Anchor" href="#visitorcontrollerjava"></a> VisitorController.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.nymrli.testdocker.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> top.nymrli.testdocker.model.Visitor;</span><br><span class="line"><span class="keyword">import</span> top.nymrli.testdocker.repository.VisitorRepository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> VisitorRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Visitor visitor = repository.findByIp(<span class="string">"192.184.4.4"</span>);</span><br><span class="line">        <span class="keyword">return</span> visitor.getTimes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中数据库mysql镜像虽然创建连接好了，但是库和表都没有创建，<code>docker-compose ps</code>可以看见通过docker-compose创建的容器，但是compose本身除了提供服务编排的统一启动和停止外，并没有提供对单一容器的管理，因此需要通过docker进行单独管理，如<code>docker exec -it b07acb7f4e6d /bin/bash</code>进行容器，<code>mysql -u root -p root</code>进行创表</p><h3 id="visitorsql"><a class="markdownIt-Anchor" href="#visitorsql"></a> visitor.sql</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">DATABASE</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">EXISTS</span> <span class="string">`test`</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="string">`test`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">EXISTS</span> <span class="string">`visitor`</span> (</span><br><span class="line">     <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>  <span class="keyword">COMMENT</span> <span class="string">"主键"</span>,</span><br><span class="line">     <span class="string">`times`</span> <span class="built_in">bigint</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">"访问次数"</span>,</span><br><span class="line">     <span class="string">`ip`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">"ip地址"</span>,</span><br><span class="line">     PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=DYNAMIC; ;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`visitor`</span> <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"192.168.0.1"</span>);</span><br></pre></td></tr></table></figure><p>配置完成后， <code>docker-compose up</code>即可启动，登陆<code>服务器IP:nginx端口</code>即可访问web应用。</p><ul><li>参考：<a href="http://www.ityouknow.com/springboot/2018/03/28/dockercompose-springboot-mysql-nginx.html" target="_blank" rel="noopener">http://www.ityouknow.com/springboot/2018/03/28/dockercompose-springboot-mysql-nginx.html</a><ul><li>代码：<a href="https://github.com/ityouknow/spring-boot-examples/tree/master/dockercompose-springboot-mysql-nginx" target="_blank" rel="noopener">https://github.com/ityouknow/spring-boot-examples/tree/master/dockercompose-springboot-mysql-nginx</a></li></ul></li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录：</h1><h2 id="springboot打包"><a class="markdownIt-Anchor" href="#springboot打包"></a> SpringBoot打包</h2><p>转载： <a href="https://www.cnblogs.com/xuwujing/p/9471802.html" target="_blank" rel="noopener">SpringBoot简单打包部署(附工程)</a></p><blockquote><p>首先需要明确的是，该项目打包的形态是可执行的<strong>jar</strong>包，还是在<strong>tomcat</strong>下运行的<strong>war</strong>包。</p></blockquote><h3 id="maven打包"><a class="markdownIt-Anchor" href="#maven打包"></a> Maven打包</h3><p>如果是<strong>jar</strong>包<br>需在<code>pom.xml</code>指定打成的包为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br></pre></td></tr></table></figure><p>如果是<strong>war</strong>包。<br>需在<code>pom.xml</code>指定打成的包为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br></pre></td></tr></table></figure><p>并通过<code>&lt;scope&gt;</code>标签在打包的时候排除<strong>tomcat</strong>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="springboot自带的打包方式"><a class="markdownIt-Anchor" href="#springboot自带的打包方式"></a> <strong>SpringBoot</strong>自带的打包方式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultGoal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">defaultGoal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>springboot-package<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.pancm.App<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span></span></span><br></pre></td></tr></table></figure><h2 id="springboot部署"><a class="markdownIt-Anchor" href="#springboot部署"></a> SpringBoot部署</h2><p>如果是<strong>jar</strong>项目<br><strong>Windows</strong>系统在项目同级目录下输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar springboot-package</span><br></pre></td></tr></table></figure><p>也可以写一个<strong>bat</strong>文件进行运行。<br><strong>示例:</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">title</span> "springboot-package"</span><br><span class="line">java -jar springboot-package.jar</span><br></pre></td></tr></table></figure><p><strong>Linux</strong>系统在项目同级目录下输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar springboot-package &amp;</span><br></pre></td></tr></table></figure><p>即可启动。<br>关闭输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 pid（jar的进程id）</span><br></pre></td></tr></table></figure><p>也可以在<code>init.d</code>注册一个服务<br>示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /home/jars/app/springboot-package.jar /etc/init.d/springboot-package</span><br><span class="line">chmod +x /etc/init.d/springboot-package</span><br></pre></td></tr></table></figure><p>然后输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service springboot-package start|stop|restart</span><br></pre></td></tr></table></figure><p>进行启动或者停止。</p><h2 id="idea的docker插件实战dockerfile篇"><a class="markdownIt-Anchor" href="#idea的docker插件实战dockerfile篇"></a> <a href="https://cloud.tencent.com/developer/article/1494921" target="_blank" rel="noopener">IDEA的Docker插件实战(Dockerfile篇)</a></h2><h2 id="daocloud上部署"><a class="markdownIt-Anchor" href="#daocloud上部署"></a> DaoCloud上部署</h2><blockquote><p>daocloud是个<strong>云原生应用云平台</strong>，他能够侦听我们Github代码仓库的修改变动，如push后触发CICD，因此我们采用其来完成项目的CICD功能</p></blockquote><h3 id="设置步骤"><a class="markdownIt-Anchor" href="#设置步骤"></a> 设置步骤</h3><p><img src="/2021/09/21/docker部署springboot项目/daocloud.png" alt="daocloud"></p><ol><li>集群管理: 添加主机-&gt;选择主机系统-&gt;在主机上<strong>安装主机监控程序</strong>后等待连接成功</li><li>项目：创建新项目-&gt;设置代码源，如果是新push的项目点击右上角的同步代码-&gt;开始创建</li><li>应用：创建应用-&gt;选择刚刚运行完的项目<code>iot_experiment_rfid</code>点击右侧的&quot;部署最新版本&quot;，设置<strong>应用名</strong>和运行环境中的<strong>主机</strong>选择Step1配置的主机，点击下一步，配置容器暴露端口，由于tomcat应用默认8080端口，因此如果application.yml没做server.port修改的话，<strong>容器端口</strong>填8080即可，<strong>主机端口</strong>可以选择默认的动态端口，这个会从主机中找个闲置端口来做映射，如我这次分配的就是32768。接着是卷挂载，如果没有挂载卷Volume则直接立即部署即可，部署成功效果如下图所示：</li></ol><p><img src="/2021/09/21/docker部署springboot项目/%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%AE%8C%E6%88%90.png" alt="应用部署完成"></p><p>集群管理效果图：可以看到应用运行容器显示了3个链接，前两个是局域网链接，第3个是公网IP:主机端口，这个需要在阿里云服务器的防火墙打开了这个端口才能显示与访问。所以如果主机端口选择了<strong>动态端口</strong>的话一定要再去阿里云设置防火墙开放端口。</p><p><img src="/2021/09/21/docker部署springboot项目/%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86.png" alt="集群管理"></p><ol start="4"><li>项目: 流程定义-&gt; “发布阶段”-&gt;添加并行任务-&gt;发布标签下的&quot;发布到自由主机&quot;， 然后在&quot;应用&quot;的下拉框中选择刚刚配置好的应用RFID_app，点击&quot;创建任务&quot;按钮，完成配置</li><li>（可选）创建云隧道：<code>开发者的安全云隧道，跨网络的容器云地址，让您在本地也能部署公网服务器。</code>实际就是把可能处于内网的服务器通过内网穿透的方式将其绑定到了daocloud分配的域名上，最终通过DNS解析实现了域名访问应用的效果。提供的都是<a href="http://rfidapp.daocloudapp.com/" target="_blank" rel="noopener">http://rfidapp.daocloudapp.com</a>这种daocloudapp下的三级域名，2021年9月27日测试的时候貌似daocloudapp域名未备案，这个功能就暂时失效了。如果有公网IP的话，还是可以通过<code>公网IP:主机port</code>来访问Web应用的</li></ol><h3 id="dockerfile内容"><a class="markdownIt-Anchor" href="#dockerfile内容"></a> Dockerfile内容</h3><p>编写好springboot工程内容后，编写dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己手动在云服务器上通过mvn package docker:build命令来运行容器的Dockerfile内容</span></span><br><span class="line"><span class="comment"># FROM openjdk:8-jdk-alpine</span></span><br><span class="line"><span class="comment"># VOLUME /tmp</span></span><br><span class="line"><span class="comment">## 注：spring-boot-docker-1.0.jar是需要根据自己项目mvn package生成的压缩包名来写的</span></span><br><span class="line"><span class="comment"># ADD spring-boot-docker-1.0.jar app.jar</span></span><br><span class="line"><span class="comment"># ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Daocloud上的Dockerfile编写内容</span></span><br><span class="line"><span class="keyword">FROM</span> maven:<span class="number">3</span> as bd</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code<span class="comment"># 指定容器启动时执行命令所在目录</span></span></span><br><span class="line"><span class="bash">COPY ./ /code<span class="comment"># 将当前工程代码复制到/code目录下</span></span></span><br><span class="line"><span class="bash">COPY settings-docker.xml /usr/share/maven/conf/settings.xml  <span class="comment"># ★指定换源</span></span></span><br><span class="line"><span class="bash">RUN mvn package -Dmaven.test.skip=<span class="literal">true</span>  <span class="comment"># 打包工程</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">FROM java:8</span></span><br><span class="line"><span class="bash">COPY --from=bd /code/target/*.jar /app.jar  <span class="comment"># 复制mvn镜像中/code/target/*.jar的结果到该层镜像的工作目录下，取名为arr.jar</span></span></span><br><span class="line"><span class="bash">CMD java -jar /app.jar<span class="comment"># 运行java -jar命令</span></span></span><br></pre></td></tr></table></figure><p>两者的区别在于第一个是已经通过mvn package把项目应用的jar包给打出来了，而在Daocloud中由于全部的CICD都是在容器中进行的，因此需要拉取maven的镜像，然后打包，而之后为什么不用<code>mvn package docker:build</code>也是因为已经在容器中，再使用的话，相当于是容器中创建容器是不合适的。所以直接运行<code>java -jar xxx.jar</code>即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由于最近在学云原生的课会接触到docker和k8s，因此试验了如何通过docker来部署springboot。&lt;/p&gt;
&lt;p&gt;由于docker的实现依赖于linux内核提供的cgroups和namespace功能，而windows支持还没找到非常好
      
    
    </summary>
    
    
      <category term="环境部署" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>学点Kotlin</title>
    <link href="https://nymrli.top/2021/09/13/%E5%AD%A6%E7%82%B9Kotlin/"/>
    <id>https://nymrli.top/2021/09/13/学点Kotlin/</id>
    <published>2021-09-13T09:18:17.000Z</published>
    <updated>2021-09-13T09:18:45.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kotlin-基础语法"><a class="markdownIt-Anchor" href="#kotlin-基础语法"></a> Kotlin 基础语法</h2><p>Kotlin 文件以 .kt 为后缀。</p><h3 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h3><p>函数定义使用关键字 fun，参数格式为：参数 : 类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;   <span class="comment">// Int 参数，返回值 Int</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式作为函数体，返回类型自动推断：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a + b   <span class="comment">// public 方法则必须明确写出返回类型</span></span><br></pre></td></tr></table></figure><p>无返回值的函数(类似Java中的void)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Unit</span> &#123; </span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> &#123; </span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可变长参数函数"><a class="markdownIt-Anchor" href="#可变长参数函数"></a> 可变长参数函数</h4><p>函数的变长参数可以用 <strong>vararg</strong> 关键字进行标识：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">vars</span><span class="params">(<span class="keyword">vararg</span> v:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vt <span class="keyword">in</span> v)&#123;</span><br><span class="line">        print(vt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    vars(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)  <span class="comment">// 输出12345</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda匿名函数"><a class="markdownIt-Anchor" href="#lambda匿名函数"></a> lambda(匿名函数)</h4><p>lambda表达式使用实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sumLambda: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x,y -&gt; x+y&#125;</span><br><span class="line">    println(sumLambda(<span class="number">1</span>,<span class="number">2</span>))  <span class="comment">// 输出 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="null检查机制"><a class="markdownIt-Anchor" href="#null检查机制"></a> NULL检查机制</h3><p>Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型后面加?表示可为空</span></span><br><span class="line"><span class="keyword">var</span> age: String? = <span class="string">"23"</span> </span><br><span class="line"><span class="comment">// 不能为空，否则抛出空指针异常</span></span><br><span class="line"><span class="keyword">val</span> ages = age!!.toInt()</span><br><span class="line"><span class="comment">//不做处理返回 null</span></span><br><span class="line"><span class="keyword">val</span> ages1 = age?.toInt()</span><br><span class="line"><span class="comment">//age为空返回-1</span></span><br><span class="line"><span class="keyword">val</span> ages2 = age?.toInt() ?: <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。</p><p>当 str 中的字符串内容不是一个整数时, 返回 null:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kotlin-基本数据类型"><a class="markdownIt-Anchor" href="#kotlin-基本数据类型"></a> Kotlin 基本数据类型</h2><p>Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。</p><p><strong>Kotlin 中没有基础数据类型，只有封装的数字类型</strong>。你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所以在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。</p><p>在 Kotlin 中，<u>三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小</u>。</p><ul><li><code>var x = 1..16</code>:  [1,16]</li><li><code>var x = 1 until 16</code>: [1, 16)</li></ul><h3 id="变量和常量"><a class="markdownIt-Anchor" href="#变量和常量"></a> 变量和常量</h3><p>可变变量定义：var 关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span><br><span class="line"><span class="keyword">val</span> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span><br></pre></td></tr></table></figure><h3 id="字符串模板"><a class="markdownIt-Anchor" href="#字符串模板"></a> 字符串模板</h3><ul><li><code>$</code> 表示一个变量名或者变量值</li><li><code>$varName</code>表示变量值</li><li><code>${varName.fun()}</code>表示变量的方法返回值:</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span><span class="comment">// 模板中的简单名称：val s1 = "a is $a" a = 2// 模板中的任意表达式：val s2 = "$&#123;s1.replace("is", "was")&#125;, but now is $a"</span></span><br></pre></td></tr></table></figure><h2 id="kotlin-条件控制"><a class="markdownIt-Anchor" href="#kotlin-条件控制"></a> <a href="https://www.runoob.com/kotlin/kotlin-condition-control.html" target="_blank" rel="noopener">Kotlin 条件控制</a></h2><h2 id="kotlin-循环控制"><a class="markdownIt-Anchor" href="#kotlin-循环控制"></a> Kotlin 循环控制</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对任何提供迭代器（iterator）的**对象**进行遍历for (item in collection) print(item)// 通过**索引**遍历一个数组或者一个 listfor (i in array.indices) &#123;    print(array[i])&#125;// 索引+值，相当于Python中的enumeratefor ((index, value) in array.withIndex()) &#123;    println("the element at $index is $value")&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while循环while( 布尔表达式 ) &#123;  //循环内容&#125;// do循环do &#123;       //代码语句&#125;while(布尔表达式);</span></span><br></pre></td></tr></table></figure><h3 id="返回和跳转"><a class="markdownIt-Anchor" href="#返回和跳转"></a> 返回和跳转</h3><p>Kotlin 有三种结构化跳转表达式：</p><ul><li><em>return</em>。默认从最直接包围它的函数或者匿名函数返回。</li><li><em>break</em>。终止最直接包围它的循环。</li><li><em>continue</em>。继续下一次最直接包围它的循环。</li></ul><h3 id="break-和-continue-的跳转标签"><a class="markdownIt-Anchor" href="#break-和-continue-的跳转标签"></a> Break 和 Continue 的跳转标签</h3><p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为<code>标识符+跟 @</code>，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;        <span class="keyword">if</span> (……) <span class="keyword">break</span><span class="symbol">@loop</span>    &#125;&#125;</span><br></pre></td></tr></table></figure><p>标签限制使得 break 跳转到刚好位于该标签指定循环的后面执行点。 continue 继续标签指定的循环的下一次迭代。</p><h4 id="标签处返回"><a class="markdownIt-Anchor" href="#标签处返回"></a> 标签处返回</h4><p>Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 <strong>标签处返回的最重要的一个用途就是从 lambda 表达式中返回</strong>。回想一下我们这么写的时候：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    ints.forEach &#123;        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span>        print(it)    &#125;&#125;</span><br></pre></td></tr></table></figure><p>这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    ints.forEach <span class="symbol">lit@</span> &#123;        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@lit</span>        print(it)    &#125;&#125;</span><br></pre></td></tr></table></figure><p>现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    ints.forEach &#123;        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@forEach</span>        print(it)    &#125;&#125;</span><br></pre></td></tr></table></figure><p>或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    ints.forEach(<span class="function"><span class="title">fun</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;        <span class="keyword">if</span> (value == <span class="number">0</span>) <span class="keyword">return</span>        print(value)    &#125;)&#125;</span><br></pre></td></tr></table></figure><p>当要返一个回值的时候，解析器优先选用标签限制的 return，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return@a 1</span><br></pre></td></tr></table></figure><p>意为&quot;从标签 @a 返回 1&quot;，而不是&quot;返回一个标签标注的表达式 (@a 1)&quot;。</p><h2 id="kotlin-类和对象"><a class="markdownIt-Anchor" href="#kotlin-类和对象"></a> Kotlin 类和对象</h2><h3 id="类的定义"><a class="markdownIt-Anchor" href="#类的定义"></a> 类的定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> <span class="keyword">constructor</span></span>(name: String) &#123;    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"Foo"</span>) &#125; <span class="comment">// 成员函数    var url: String = ……            // 次构造函数    constructor (name: String, alexa: Int) : this(name) &#123;        println("Alexa 排名 $alexa")    &#125;    var lastName: String = "zhang"        get() = field.toUpperCase()   // 将变量赋值后转换为大写        set    var no: Int = 100        get() = field                // 后端变量        set(value) &#123;            if (value &lt; 10) &#123;       // 如果传入的值小于 10 返回该值                field = value            &#125; else &#123;                field = -1         // 如果传入的值大于等于 10 返回 -1            &#125;        &#125;    var heiht: Float = 145.4f        private set    &#125;</span></span><br></pre></td></tr></table></figure><h3 id="对象的声明"><a class="markdownIt-Anchor" href="#对象的声明"></a> 对象的声明</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> site = Runoob() <span class="comment">// Kotlin 中没有 new 关键字site.name           // 使用 . 号来引用site.url</span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3><p>Koltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123;    init &#123;        println(<span class="string">"FirstName is <span class="variable">$firstName</span>"</span>)    &#125;&#125;</span><br></pre></td></tr></table></figure><p>如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(firstName: String) &#123;&#125;</span><br></pre></td></tr></table></figure><p>次构造函数</p><p>类也可以有二级构造函数，需要加前缀 constructor:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;     constructor(parent: Person) &#123;        parent.children.add(this)     &#125;&#125;</span><br></pre></td></tr></table></figure><p>如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name: String) &#123;    constructor (name: String, age:Int) : this(name) &#123;        // 初始化...    &#125;&#125;</span><br></pre></td></tr></table></figure><p>如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class DontCreateMe private constructor () &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="getter-和-setter"><a class="markdownIt-Anchor" href="#getter-和-setter"></a> getter 和 setter</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]    [&lt;getter&gt;]    [&lt;setter&gt;]<span class="comment">// var变量可设置getter 和 setter, 都是可选// 如果属性类型可以从初始化语句或者类的成员函数中推断出来，那就可以省去类型，val不允许设置setter函数，因为它是只读的。var allByDefault: Int? // 错误: 需要一个初始化语句, 默认实现了 getter 和 setter 方法var initialized = 1    // 类型为 Int, 默认实现了 getter 和 setterval simple: Int?       // 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化val inferredType = 1   // 类型为 Int 类型,默认实现 getter</span></span><br></pre></td></tr></table></figure><h3 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h3><p>抽象是面向对象编程的特征之一，类本身，或类中的部分成员，都可以声明为abstract的。抽象成员在类中不存在具体的实现。</p><p>注意：无需对抽象类或抽象成员标注open注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class Base &#123;    open fun f() &#123;&#125;&#125;abstract class Derived : Base() &#123;    override abstract fun f()&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套类"><a class="markdownIt-Anchor" href="#嵌套类"></a> 嵌套类</h3><p>我们可以把类嵌套在其他类中，看以下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;                  // 外部类    private val bar: Int = 1    class Nested &#123;             // 嵌套类        fun foo() = 2    &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h4><p>内部类使用 inner 关键字来表示。</p><p>内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span>    <span class="keyword">var</span> v = <span class="string">"成员属性"</span>    <span class="comment">/**嵌套内部类**/</span>    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar  <span class="comment">// 访问外部类成员        fun innerTest() &#123;            var o = this@Outer //获取外部类的成员变量            println("内部类可以引用外部类的成员，例如：" + o.v)        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类</h4><p>使用对象表达式来创建匿名内部类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    <span class="keyword">var</span> v = <span class="string">"成员属性"</span>    <span class="function"><span class="keyword">fun</span> <span class="title">setInterFace</span><span class="params">(test: <span class="type">TestInterFace</span>)</span></span> &#123;        test.test()    &#125;&#125;<span class="comment">/** * 定义接口 */</span><span class="class"><span class="keyword">interface</span> <span class="title">TestInterFace</span> </span>&#123;    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#125;<span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;    <span class="keyword">var</span> test = Test()    <span class="comment">/**     * 采用对象表达式来创建接口对象，即匿名内部类的实例。     */</span>    test.setInterFace(<span class="keyword">object</span> : TestInterFace &#123;        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;            println(<span class="string">"对象表达式创建匿名内部类的实例"</span>)        &#125;    &#125;)&#125;</span><br></pre></td></tr></table></figure><h3 id="类的修饰符"><a class="markdownIt-Anchor" href="#类的修饰符"></a> 类的修饰符</h3><p>类的修饰符包括 classModifier 和_accessModifier_:</p><ul><li><p>classModifier: 类属性修饰符，标示类本身特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract    // 抽象类  final       // 类不可继承，默认属性enum        // 枚举类open        // 类可继承，类默认是final的annotation  // 注解类</span><br></pre></td></tr></table></figure></li><li><p>accessModifier: 访问权限修饰符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private    // 仅在同一个文件中可见protected  // 同一个文件中或子类可见public     // 所有调用的地方都可见internal   // 同一个模块中可见</span><br></pre></td></tr></table></figure></li></ul><h2 id="kotlin-继承"><a class="markdownIt-Anchor" href="#kotlin-继承"></a> Kotlin 继承</h2><p>Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：</p><p>Any 默认提供了三个函数：</p><ul><li>equals()</li><li>hashCode()</li><li>toString()</li></ul><p>注意：Any 不是 java.lang.Object。</p><p>如果一个类要被继承，可以使用 open 关键字进行修饰。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="built_in">Int</span>)           <span class="comment">// 定义基类class Derived(p: Int) : Base(p)</span></span><br></pre></td></tr></table></figure><h2 id="构造函数-2"><a class="markdownIt-Anchor" href="#构造函数-2"></a> 构造函数</h2><h3 id="子类有主构造函数"><a class="markdownIt-Anchor" href="#子类有主构造函数"></a> 子类有主构造函数</h3><p>如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class Person(var name : String, var age : Int)&#123;// 基类&#125;class Student(name : String, age : Int, var no : String, var score : Int) : Person(name, age) &#123;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123;    val s =  Student(&quot;Runoob&quot;, 18, &quot;S12346&quot;, 89)    println(&quot;学生名： $&#123;s.name&#125;&quot;)    println(&quot;年龄： $&#123;s.age&#125;&quot;)    println(&quot;学生号： $&#123;s.no&#125;&quot;)    println(&quot;成绩： $&#123;s.score&#125;&quot;)&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生名： Runoob年龄： 18学生号： S12346成绩： 89</span><br></pre></td></tr></table></figure><h3 id="子类没有主构造函数"><a class="markdownIt-Anchor" href="#子类没有主构造函数"></a> 子类没有主构造函数</h3><p>如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person &#123;    constructor</span></span>(ctx: Context) : <span class="keyword">super</span>(ctx) &#123;    &#125;     <span class="keyword">constructor</span>(ctx: Context, attrs: AttributeSet) : <span class="keyword">super</span>(ctx,attrs) &#123;    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h3><p>在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**用户基类**/</span><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">study</span><span class="params">()</span></span>&#123;       <span class="comment">// 允许子类重写        println("我毕业了")    &#125;&#125;/**子类继承 Person 类**/class Student : Person() &#123;    override fun study()&#123;    // 重写方法        println("我在读大学")    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val s =  Student()    s.study();&#125;</span></span><br></pre></td></tr></table></figure><p>如果有多个相同的方法（继承或者实现自其他类，如A、B类），则必须要重写该方法，使用super范型去选择性地调用父类的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class A &#123;    open fun f () &#123; print(&quot;A&quot;) &#125;    fun a() &#123; print(&quot;a&quot;) &#125;&#125;interface B &#123;    fun f() &#123; print(&quot;B&quot;) &#125; //接口的成员变量默认是 open 的    fun b() &#123; print(&quot;b&quot;) &#125;&#125;class C() : A() , B&#123;    override fun f() &#123;        super&lt;A&gt;.f()//调用 A.f()        super&lt;B&gt;.f()//调用 B.f()    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val c =  C()    c.f();&#125;</span><br></pre></td></tr></table></figure><p>C 继承自 a() 或 b(), C 不仅可以从 A 或则 B 中继承函数，而且 C 可以继承 A()、B() 中共有的函数。此时该函数在中只有一个实现，为了消除歧义，该函数必须调用A()和B()中该函数的实现，并提供自己的实现。</p><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AB</span><br></pre></td></tr></table></figure><h3 id="属性重写"><a class="markdownIt-Anchor" href="#属性重写"></a> 属性重写</h3><p>属性重写使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class Foo &#123;    open val x: Int get &#123; …… &#125;&#125;class Bar1 : Foo() &#123;    override val x: Int = ……&#125;</span><br></pre></td></tr></table></figure><p>注：可以用一个var属性重写一个val属性，但是反过来不行。</p><h2 id="kotlin-接口"><a class="markdownIt-Anchor" href="#kotlin-接口"></a> Kotlin 接口</h2><h3 id="接口定义"><a class="markdownIt-Anchor" href="#接口定义"></a> 接口定义</h3><p>Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>    <span class="comment">// 未实现    fun foo() &#123;  //已实现      // 可选的方法体      println("foo")    &#125;    // 接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性：    var name:String //name 属性, 抽象的&#125;</span></span><br></pre></td></tr></table></figure><h3 id="实现接口"><a class="markdownIt-Anchor" href="#实现接口"></a> 实现接口</h3><p>一个类或者对象可以实现一个或多个接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;    override fun bar</span></span>() &#123;        <span class="comment">// 方法体    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="kotlin-扩展"><a class="markdownIt-Anchor" href="#kotlin-扩展"></a> Kotlin 扩展</h2><blockquote><p>Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。</p><p>扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。</p></blockquote><h3 id="将函数扩展"><a class="markdownIt-Anchor" href="#将函数扩展"></a> 将函数扩展</h3><p>扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式：</p><ul><li>receiverType：表示函数的接收者，也就是函数扩展的对象</li><li>functionName：扩展函数的名称</li><li>params：扩展函数的参数，可以为NULL</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数扩展原型fun receiverType.functionName(params)&#123;    body&#125;class User(var name:String)/**扩展函数**/fun User.Print()&#123;    print("用户名 $name")&#125;</span></span><br></pre></td></tr></table></figure><h4 id="扩展函数是静态解析的"><a class="markdownIt-Anchor" href="#扩展函数是静态解析的"></a> 扩展函数是静态解析的</h4><p>扩展函数是<strong>静态解析</strong>的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由<strong>调用函数的的对象表达式来决定</strong>的，而不是动态的类型决定的:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Cclass</span> <span class="title">D</span>: <span class="type">C</span></span>()<span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span>   <span class="comment">// 扩展函数 foofun D.foo() = "d"   // 扩展函数 foofun printFoo(c: C) &#123;    println(c.foo())  // 类型是 C 类&#125;fun main(arg:Array&lt;String&gt;)&#123;    printFoo(D())&#125;// 输出c</span></span><br></pre></td></tr></table></figure><p>若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。</p><h3 id="扩展一个空对象"><a class="markdownIt-Anchor" href="#扩展一个空对象"></a> 扩展一个空对象</h3><p>在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun Any?.toString(): String &#123;    if (this == null) return &quot;null&quot;    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()    // 解析为 Any 类的成员函数    return toString()&#125;fun main(arg:Array&lt;String&gt;)&#123;    var t = null    println(t.toString())&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null</span><br></pre></td></tr></table></figure><p>扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val Foo.bar = 1 // 错误：扩展属性不能有初始化器</span><br></pre></td></tr></table></figure><p>扩展属性只能被声明为 val。</p><h3 id="伴生对象的扩展"><a class="markdownIt-Anchor" href="#伴生对象的扩展"></a> 伴生对象的扩展</h3><blockquote><p>伴生对象内的成员相当于 Java 中的静态成员，其生命周期伴随类始终，在伴生对象内部可以定义变量和函数，这些变量和函数可以直接用类名引用。</p></blockquote><p>如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性。</p><p>伴生对象通过&quot;类名.&quot;形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;    companion object &#123; &#125;  // 将被称为 &quot;Companion&quot;&#125;fun MyClass.Companion.foo() &#123;    println(&quot;伴随对象的扩展函数&quot;)&#125;val MyClass.Companion.no: Int    get() = 10fun main(args: Array&lt;String&gt;) &#123;    println(&quot;no:$&#123;MyClass.no&#125;&quot;)    MyClass.foo()&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no:10伴随对象的扩展函数</span><br></pre></td></tr></table></figure><p>注：对于伴生对象扩展函数，有两种形式，一种是在类内扩展，一种是在类外扩展，这两种形式扩展后的函数互不影响（甚至名称都可以相同），即使名称相同，它们也完全是两个不同的函数，并且有以下特点：</p><ul><li>（1）类内扩展的伴随对象函数和类外扩展的伴随对象可以同名，它们是两个独立的函数，互不影响；</li><li>（2）当类内扩展的伴随对象函数和类外扩展的伴随对象同名时，类内的其它函数优先引用类内扩展的伴随对象函数，即对于类内其它成员函数来说，类内扩展屏蔽类外扩展；</li><li>（3）类内扩展的伴随对象函数只能被类内的函数引用，不能被类外的函数和伴随对象内的函数引用；</li><li>（4）类外扩展的伴随对象函数可以被伴随对象内的函数引用，；</li></ul><h2 id="kotlin-对象表达式和对象声明"><a class="markdownIt-Anchor" href="#kotlin-对象表达式和对象声明"></a> Kotlin 对象表达式和对象声明</h2><h2 id="对象表达式"><a class="markdownIt-Anchor" href="#对象表达式"></a> 对象表达式</h2><p>通过对象表达式实现一个匿名内部类的对象用于方法的参数中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;        <span class="comment">// ...    &#125;    override fun mouseEntered(e: MouseEvent) &#123;        // ...    &#125;&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="对象声明"><a class="markdownIt-Anchor" href="#对象声明"></a> 对象声明</h3><blockquote><p>Kotlin 使用 object 关键字来声明一个对象。</p><p>Kotlin 中我们可以方便的通过<strong>对象object声明</strong>来获得一个单例。</p></blockquote><p>当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;    <span class="keyword">var</span> name = <span class="string">"菜鸟教程"</span>    <span class="keyword">object</span> DeskTop&#123;        <span class="keyword">var</span> url = <span class="string">"www.runoob.com"</span>        <span class="function"><span class="keyword">fun</span> <span class="title">showName</span><span class="params">()</span></span>&#123;            print&#123;<span class="string">"desk legs <span class="variable">$name</span>"</span>&#125; <span class="comment">// 错误，不能访问到外部类的方法和变量        &#125;    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    var site = Site()    site.DeskTop.url // 错误，不能通过外部类的实例访问到该对象    Site.DeskTop.url // 正确, 类似静态内部类，这个类是属于外部类的，而不是某个实例&#125;</span></span><br></pre></td></tr></table></figure><h3 id="伴生对象"><a class="markdownIt-Anchor" href="#伴生对象"></a> 伴生对象</h3><p>类内部的对象声明可以用 <code>companion</code> 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。</p><h3 id="对象表达式和对象声明之间的语义差异"><a class="markdownIt-Anchor" href="#对象表达式和对象声明之间的语义差异"></a> 对象表达式和对象声明之间的语义差异</h3><p>对象表达式和对象声明之间有一个重要的语义差别：</p><ul><li>对象表达式是在使用他们的地方立即执行的</li><li>对象声明是在第一次被访问到时延迟初始化的</li><li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配</li></ul><h2 id="kotlin-委托"><a class="markdownIt-Anchor" href="#kotlin-委托"></a> kotlin 委托</h2><blockquote><p><a href="https://www.runoob.com/w3cnote/delegate-mode.html" target="_blank" rel="noopener">委托模式</a>是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。</p><p>Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。</p></blockquote><h3 id="类委托"><a class="markdownIt-Anchor" href="#类委托"></a> 类委托</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建接口interface Base &#123;       fun print()&#125;// 实现此接口的被委托的类class BaseImpl(val x: Int) : Base &#123;    override fun print() &#123; print(x) &#125;&#125;// 通过关键字 by 建立委托类class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) &#123;    val b = BaseImpl(10)    Derived(b).print() // 输出 10&#125;</span></span><br></pre></td></tr></table></figure><p>在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。</p><h3 id="属性委托"><a class="markdownIt-Anchor" href="#属性委托"></a> 属性委托</h3><p>属性委托指的是一个<strong>类的某个属性值</strong>不是在类中直接进行定义，而是将<strong>其托付给一个代理类</strong>，从而实现对该类的属性统一管理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty<span class="comment">// 定义包含属性委托的类class Example &#123;    var p: String by Delegate()    // val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;&#125;// 委托的类class Delegate &#123;    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;        return "$thisRef, 这里委托了 $&#123;property.name&#125; 属性"    &#125;    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;        println("$thisRef 的 $&#123;property.name&#125; 属性赋值为 $value")    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val e = Example()    println(e.p)     // 访问该属性，调用 getValue() 函数    e.p = "Runoob"   // 调用 setValue() 函数    println(e.p)&#125;</span></span><br></pre></td></tr></table></figure><h3 id="标准委托"><a class="markdownIt-Anchor" href="#标准委托"></a> 标准委托</h3><p>Kotlin 的标准库中已经内置了很多工厂方法来实现属性的委托。</p><h4 id="延迟属性-lazy"><a class="markdownIt-Anchor" href="#延迟属性-lazy"></a> 延迟属性 Lazy</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lazyValue: String <span class="keyword">by</span> lazy &#123;    println(<span class="string">"computed!"</span>)     <span class="comment">// 第一次调用输出，第二次调用不执行    "Hello"&#125;fun main(args: Array&lt;String&gt;) &#123;    println(lazyValue)   // 第一次执行，执行两次输出表达式    println(lazyValue)   // 第二次执行，只输出返回值&#125;/*computed!HelloHello*/</span></span><br></pre></td></tr></table></figure><h4 id="可观察属性-observable"><a class="markdownIt-Anchor" href="#可观察属性-observable"></a> 可观察属性 Observable</h4><blockquote><p>observable 可以用于实现观察者模式。</p><p>Delegates.observable() 函数接受两个参数: 第一个是初始化值, 第二个是属性值变化事件的响应器(handler)。</p><p>在属性赋值后会执行事件的响应器(handler)，它有三个参数：被赋值的属性、旧值和新值：</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegatesclass User &#123;    <span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">"初始值"</span>) &#123;        prop, old, new -&gt;        println(<span class="string">"旧值：<span class="variable">$old</span> -&gt; 新值：<span class="variable">$new</span>"</span>)    &#125;&#125;<span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;    <span class="keyword">val</span> user = User()    user.name = <span class="string">"第一次赋值"</span>    user.name = <span class="string">"第二次赋值"</span>&#125;<span class="comment">/*旧值：初始值 -&gt; 新值：第一次赋值旧值：第一次赋值 -&gt; 新值：第二次赋值*/</span></span><br></pre></td></tr></table></figure><h4 id="把属性储存在映射中"><a class="markdownIt-Anchor" href="#把属性储存在映射中"></a> 把属性储存在映射中</h4><h4 id="not-null"><a class="markdownIt-Anchor" href="#not-null"></a> Not Null</h4><p>notNull 适用于那些无法在初始化阶段就确定属性值的场合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;    var notNullBar: String by Delegates.notNull&lt;String&gt;()&#125;foo.notNullBar = &quot;bar&quot;println(foo.notNullBar)</span><br></pre></td></tr></table></figure><p>需要注意，如果属性在赋值前就被访问的话则会抛出异常。</p><h4 id="局部委托属性"><a class="markdownIt-Anchor" href="#局部委托属性"></a> 局部委托属性</h4><p>你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun example(computeFoo: () -&gt; Foo) &#123;    val memoizedFoo by lazy(computeFoo)    if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123;        memoizedFoo.doSomething()    &#125;&#125;</span><br></pre></td></tr></table></figure><p>memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。</p><h3 id="属性委托要求"><a class="markdownIt-Anchor" href="#属性委托要求"></a> 属性委托要求</h3><p>对于只读属性(也就是说val属性), 它的委托必须提供一个名为getValue()的函数。该函数接受以下参数：</p><ul><li>thisRef —— 必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型</li><li>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型</li></ul><p>这个函数必须返回与属性相同的类型（或其子类型）。</p><p>对于一个值可变(mutable)属性(也就是说,var 属性),除 getValue()函数之外,它的委托还必须 另外再提供一个名为setValue()的函数, 这个函数接受以下参数:</p><p>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型new value —— 必须和属性同类型或者是它的超类型。</p><h3 id="提供委托"><a class="markdownIt-Anchor" href="#提供委托"></a> 提供委托</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;kotlin-基础语法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#kotlin-基础语法&quot;&gt;&lt;/a&gt; Kotlin 基础语法&lt;/h2&gt;
&lt;p&gt;Kotlin 文件以 .kt 为后缀。&lt;/p&gt;
&lt;h3 id=&quot;函数定义&quot;&gt;&lt;a clas
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://nymrli.top/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>ZJU开学摸底考试——操作系统复习</title>
    <link href="https://nymrli.top/2021/09/09/ZJU%E5%BC%80%E5%AD%A6%E6%91%B8%E5%BA%95%E8%80%83%E8%AF%95%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <id>https://nymrli.top/2021/09/09/ZJU开学摸底考试——操作系统复习/</id>
    <published>2021-09-09T06:21:21.000Z</published>
    <updated>2021-10-25T08:54:21.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h1><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性：</h2><ul><li>并发：<ul><li>▲理解并发和并行的区别</li></ul></li><li>共享<ul><li>互斥共享方式（摄像头设备的共享使用）</li><li>同时共享方式（硬盘访问）——宏观的同时，微观上进程还是交替访问的（分时共享）</li></ul></li><li>虚拟：<ul><li>虚拟存储器：<ul><li>空分复用</li></ul></li><li>虚拟处理器：<ul><li>时分复用</li></ul></li></ul></li><li>异步<ul><li>只有系统具有并发性，才可能导致异步性</li></ul></li></ul><p>注： 并发与共享互为存在条件</p><h2 id="操作系统发展"><a class="markdownIt-Anchor" href="#操作系统发展"></a> 操作系统发展</h2><p>单道批处理系统</p><ul><li>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</li><li>主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待/0完成。资源利用率依然很低。</li></ul><p>多道批处理系统：</p><ul><li>主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</li><li>主要缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</li></ul><p>分时操作系统：</p><blockquote><p>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。</p></blockquote><ul><li>主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</li><li>主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</li></ul><p>实时操作系统：</p><ul><li>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。<br>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是<strong>及时性</strong>和<strong>可靠性</strong></li></ul><h2 id="os的运行机制和体系结构"><a class="markdownIt-Anchor" href="#os的运行机制和体系结构"></a> OS的运行机制和体系结构</h2><p>运行机制：</p><blockquote><p>指令：“指令”就是处理器（CPU）能识别、执行的最基本命令。而OS运行过程就是CPU不断执行指令的过程</p><ul><li>特权指令： 内存清零指令</li><li>非特权指令：普通加减乘除指令</li></ul></blockquote><p>处理器状态：</p><ul><li>内核态（管态）：既可以执行特权指令也可执行非特权指令</li><li>用户态（目态）：此时CPU只能执行非特权指令</li></ul><p>▲：“用户态-&gt;核心态”是通过<strong>中断</strong>实现的并且中断是<strong>唯一途径</strong>。而“核心态-&gt;用户态”的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”</p><p>内核：</p><blockquote><p>内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。<br>实现操作系统内核功能的那些程序就是内核程序。</p></blockquote><p><img src="https://i.loli.net/2021/09/09/kavtqJc1nPNrls2.png" alt=""></p><p>体系结构</p><p><img src="/2021/09/09/ZJU开学摸底考试——操作系统复习/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="体系结构"></p><h2 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断：</h2><blockquote><p>为了解决最初各个程序只能串行执行，人们发明了操作系统（作为计算机的管理者），引入中断机制，从而实现了多道程序并发执行</p><p>本质：发生中断就意味着需要操作系统介入，开展管理工作</p></blockquote><p>▲：“用户态-&gt;核心态”是通过<strong>中断</strong>实现的并且中断是<strong>唯一途径</strong>。而“核心态-&gt;用户态”的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”</p><p>中断分类：</p><ul><li>内中断（与CPU当前执行指令有关）<ul><li>自愿中断——指令中断</li><li>强迫中断——硬件故障（缺页）、软件中断（除零）</li></ul></li><li>外中断（与CPU当前执行指令无关）<ul><li>外设请求（IO操作完成发出中断信号）</li><li>人工干涉（用户强行关闭进程）</li></ul></li></ul><h2 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h2><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括<u>命令接口</u>和程序接口。其中，程序接口由一组系统调用组成。</p><p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p><h2 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h2><p><strong>定义</strong></p><p><strong>程序段</strong>、<strong>数据段</strong>、<strong>PCB</strong>三部分组成了<strong>进程实体</strong>（进程映像）。一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。<br>注意：PCB是进程存在的唯一标志！</p><p>从不同的角度，进程可以有不同的定义，比较传统典型的定义有：<br>1.<strong>进程</strong>是<strong>程序</strong>的一次执行过程。<br>2.进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>3.进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</p><p>▲它是一个动态的过程。</p><p>引入进程实体的概念后，可把进程定义为：<strong>进程</strong>是进程实体的**运行过程，**是系统进行资源分配和调度的一个独立单位。</p><p>注：严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。不过，除非题目专门考察二者区别，否则可以认为避程实体就是进程。因此我们也可以说“进程由程序段、数据段、PCB三部分组成”</p><p><strong>组织形式</strong></p><p>链接方式：按照进程状态将PCB分成多个队列，操作系统持有指向各个队列的指针</p><p>索引方式：根据进程状态不同建立多张索引表，操作系统持有指向各个索引表的指针</p><p><strong>进程特性</strong></p><p><img src="/2021/09/09/ZJU开学摸底考试——操作系统复习/%E8%BF%9B%E7%A8%8B%E7%89%B9%E6%80%A7.png" alt="进程特性"></p><p><strong>进程状态：</strong></p><ul><li>创建态：进程正在被创建，操作系统为进程分配资源、初始化PCB</li><li>运行态</li><li>阻塞态</li><li>就绪态</li><li>终止态： 进程从系统中撤销，操作系统回收进程拥有的资源、撤销PCB</li></ul><p><img src="/2021/09/09/ZJU开学摸底考试——操作系统复习/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="进程状态转换"></p><p>进程控制：</p><p>用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。<br>这种不可被中断的操作即原子操作<br>原语采用“关中断指令”和“开中断指令”实现</p><p>注：显然，关/开中断指令的权限非常大，必然是只允许在<strong>核心态</strong>下执行的<strong>特权指令</strong></p><p>创建原语：无-&gt;创建态-&gt;就绪态</p><ul><li>申请空白PcB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PcB插入就绪队列</li></ul><p>撤销原语：就绪态/阻塞态/运行态→终止态→无</p><ul><li>从PcB集合中找到终止进程的PCB</li><li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程</li><li>将该进程拥有的所有资源归还给父进程或操作系统</li><li>删除PcB</li></ul><p>阻塞原语：</p><ul><li>找到要阻塞的进程对应的PcB</li><li>保护进程运行现场，将PcB状态信息设置为阻塞态&quot;，暂时停止进程运行</li><li>将PcB插入相应事件的等待队列</li></ul><p>唤醒原语：</p><ul><li>在事件等待队列中找到PcB</li><li>将PcB从等待队列移除，设置进程为就绪态</li><li>将pcB插入就绪队列，等待被调度</li></ul><p><strong>通信</strong></p><blockquote><p>各进程拥有的内存地址空间相互独立</p></blockquote><p>方式：</p><blockquote><p>都需要<strong>互斥</strong></p></blockquote><ul><li><p>共享存储</p><ul><li>基于数据结构：速度慢，是一种低级的通信方式</li><li>基于存储区:存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式</li></ul></li><li><p>管道通信</p><blockquote><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区</p><p>数据以字符流的形式写入管道，当管道写满时，写进程的write（）系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read（）系统调用将被阻塞。</p></blockquote><ul><li>半双工管道，如果全双工需要设置两个管道</li><li>需要互斥访问</li><li>读进程最多只能有一个——否则可能有读错数据的情况</li></ul></li><li><p>消息传递</p><blockquote><p>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</p></blockquote><ul><li>直接通信方式: 消息直接挂到接收进程的消息缓冲队列上</li><li>间接通信方式：消息先发送到中间实体（信箱）中，因此也成为信箱通信方式</li></ul></li></ul><p>进程互斥原则：</p><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><p>1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区<br>2.忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；<br>3.有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；<br>4.让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</p><p><strong>进程互斥软件实现：</strong></p><ul><li>单标志法：算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予<ul><li>单标志法存在的主要问题是：违背“空闲让进”原则。</li></ul></li><li>双标志先检查：算法思想：设置一个布尔型数组flag囗，数组中各个元素用来标记各进程想进入临界区的意愿，比如flag=ture”意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检査当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志fa】设为true，之后开始访问临界区。<ul><li>双标志先检查法的主要问题是：违反“忙则等待”原则。</li></ul></li><li>双标志后检查:算法思想：双标志先检査法的改版。前一个算法的问题是先“检査”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。<ul><li>双标志后检査法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。</li></ul></li><li>Peterson算法——三标志：算法思想：双标志后检査法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。 Gary L. Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。<ul><li>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。</li></ul></li></ul><p>进程互斥硬件实现：</p><ul><li>中断屏蔽方法</li><li>TestAndSet</li><li>Swap指令</li></ul><h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步</p><p>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><p>wait、 signal原语常简称为ρ、V操作（来自荷兰语 proberen和 verhogen）。因此，做题的时候常把Wait（S）、 sIgna|（S）两个操作分别写为P（S）、V（S）</p><ul><li>整形信号量：用一个整数型的变量作为信号量，用来表示系统中某种资源的数量<ul><li>存在的问题：不满足“让权等待”原则，会发生“忙等”</li></ul></li><li>整型信号量的缺陷是存在“忙等”问题，因此人们又提岀了“记录型信号量”，即用记录型数据结构表示的信号量。</li></ul><p>操作方式：</p><ul><li>S value的初值表示系统中某种资源的数目</li><li>对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此需要执行va|ue-，表示资源数减1，当S value&lt;0时表示该类资源已分配完毕，因此进程应调用 block原语进行自我阻塞（当前运行的进程从运行态→阻塞态），主动放弃处理机，并插入该类资源的等待队列SL中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。</li><li>对信号量S的一次∨操作意味着进程释放一个单位的该类资源，因此需要执行 S value++，表示资源数加1，若加1后仍是 S value&lt;=0，表示依然有进程在等待该类资源，因此应调用 wakeup原语唤醒等待队列中的第个进程（被唤醒进程从阻塞态→就绪态）。</li></ul><p><img src="/2021/09/09/ZJU开学摸底考试——操作系统复习/%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt="信号量"></p><p>技巧总结：</p><p>基础</p><ul><li>互斥问题，将信号量初值设置为1</li><li>同步问题，将信号量初值设置为0——一前一后问题，进程执行有先后顺序需要同步协调</li><li>除了互斥、同步问题外还会考察有多个资源的问题，有多少资源就把信号量初值设为多少。申请资源时进行P操作，释放资源时进行V操作即可<ul><li>设置一个信号量，初始值即为资源的数量（本质上也属于“同步问题”，若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续往下执行）</li></ul></li></ul><p>进阶</p><ul><li>实现互斥是在同一进程中进行一对PV操作</li><li>实现两进程的同步关系，是在其中个进程中执行P，另进程中执行V</li><li>**实现互斥的P操作一定要在实现同步的P操作之后。**V操作不会导致进程阻塞，因此两个V操作顺序可以交换。</li></ul><h3 id="生产消费者问题"><a class="markdownIt-Anchor" href="#生产消费者问题"></a> 生产消费者问题</h3><h3 id="读者和写者问题"><a class="markdownIt-Anchor" href="#读者和写者问题"></a> 读者和写者问题</h3><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p><ol><li>允许多个读者可以同时对文件执行读操作；</li><li>只允许一个写者往文件中写信息；</li><li>任一写者在完成写操作之前不允许其他读者或写者工作；</li><li>写者执行写操作前，应计口有的读者和写者全部退出</li></ol><p>管程：信号量机制存在的问题：编写程序困难、易出错，能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢？——管程，一种高级同步机制</p><p>管程是一种特殊的软件模块，有这些部分组成：<br>1.局部于管程的共享数据结构说明<br>2.对该数据结构进行操作的1组过程（函数）；<br>3.对局部于管程的共享数据设置初始值的语句；<br>4.管程有一个名字。</p><p>管程的基本特征：<br>1.局部于管程的数据只能被局部于管程的过程所访问；<br>2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据；<br>3.每次仅允许一个进程在管程内执行某个内部过程。</p><h2 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2><p>什么是死锁<br>进程死锁、饥饿、死循环的区别</p><ul><li>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li><li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（sPF）算法<br>中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是<br>程序员故意设计的。</li></ul><p>死锁产生的必要条件</p><ul><li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li><li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul><p>什么时候会发生死锁</p><ul><li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、<br>分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</li></ul><p>死锁的处理策略</p><ul><li>死锁忽略</li><li>预防死锁。破坏死锁产生的四令必要条件中的一个或几个。</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。<ul><li>检测<ul><li>资源分配图</li><li>死锁检测算法</li></ul></li><li>接触：<ul><li>资源剥夺法：</li><li>撤销（终止）进程法：</li><li>进程回退法：</li></ul></li></ul></li></ul><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><blockquote><p>在没有引入进程之前，程序都是串行执行的。引入进程后计算机可以同时执行多个程序，但进程是程序的一次执行，比如QQ拥有视频、发丧图片等功能，程序的多个功能是不可能顺序执行就实现的，因此引出了线程。为此，引入了线程来增加并发性</p></blockquote><p>▲传统的进程是程序执行流的最小单位 ===&gt; 引入线程后，线程成了程序执行流的最小单位  ==&gt; 可以吧线程理解为轻量级进程</p><p><strong>线程是一个基本的CPU执行单元也是程序执行流的最小单位。</strong></p><ul><li>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</li><li>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）==&gt; 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li></ul><p>理解类比：</p><blockquote><p>引人线程后，并及所带来的系统开销，比如去图书馆看书。</p><ul><li>切换进程运行环境=有一个不认识的人要用桌子，你需要你的书收走，他把自己的书放到桌上</li><li>同一进程内的线程切换=你的舍友要用这张书桌，可以不把桌子上的书收走</li></ul></blockquote><p><img src="/2021/09/09/ZJU开学摸底考试——操作系统复习/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7.jpg" alt="线程属性"></p><ul><li><p>用户级线程(ULT: User-Level Thread)</p><ul><li><p>用户级线程由应用程序通过<strong>线程库</strong>实现。<br>所有的线程管理工作都由应用程序负责（包括线程切换）<br>用户级线程中，线程切换可以在<strong>用户态</strong>下即可完成，无需操作系统干预。<br>在用户看来，是有多个线程。但是在<strong>操作系统内核看来，并意识不到线程的存在</strong>。（用户级线程对用户不透明，对操作系统透明）</p><p>==&gt; 用户线程就是从用户视角能看到的线程</p></li></ul></li><li><p>内核级线程(KLT: Kernel-Level Thread)</p><ul><li><p>内核级线程的管理工作由操作系统内核完成。<br>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在<strong>核心态</strong>下才能完成。</p><p>==&gt; 可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”</p></li></ul></li></ul><p>组合方式： KLT(m个)与ULT混合(n个)共同使用， n&gt;=m</p><p><img src="/2021/09/09/ZJU开学摸底考试——操作系统复习/%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.jpg" alt="线程实现方式"></p><p><strong>多线程模型：</strong></p><ul><li>多对一模型：多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。<ul><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，<strong>线程管理的系统开销小，效率高</strong></li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，<strong>并发度不高</strong>。多个线程不可在多核处理机上并行运行</li></ul></li><li>一对一模型：一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程<ul><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li></ul></li><li>★多对多模型：用户及线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。<ul><li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li></ul></li></ul><p><strong>处理机调度</strong></p><blockquote><p>调度：当有一堆仼务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序(按某种算法选择一个进程将处理机分配给它)，这就是“调度”研究的问题。</p></blockquote><p>三个层次：</p><ul><li><p>作业调度（高级调度）</p><ul><li>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。</li><li><strong>高级调度主要是指调入的问题</strong>，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</li></ul></li><li><p>内存调度（中级调度）——比作业调度多了挂起队列</p><ul><li>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。==&gt;从而提高了内存利用率和系统吞吐量</li><li><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</strong></li></ul><p><img src="/2021/09/09/ZJU开学摸底考试——操作系统复习/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.jpg" alt="七状态模型"></p></li><li><p>进程调度（低级调度）</p><ul><li>主要任务是按照<strong>某种方法和策略从<u><em>就绪队列</em></u>中选取一个进程，将处理机分配给它</strong>。</li><li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</li></ul></li></ul><p><img src="/2021/09/09/ZJU开学摸底考试——操作系统复习/%E8%B0%83%E5%BA%A6%E5%AF%B9%E6%AF%94.jpg" alt="调度对比"></p><p>不能进行进程切换的情况：</p><ul><li><p>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</p></li><li><p>进程在操作系统内核程序临界区中</p><ul><li>进程在<strong>操作系统内核程序临界区</strong>中不能进行调度与切换  √</li><li>（2012年联考真题）进程处于<strong>临界区</strong>时不能进行处理机调度（X</li></ul><p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p><p>临界区：访问临界资源的那段代码。<br>内核程序临界区一般是用来访问某种<strong>内核数据结构</strong>的，比如进程的就绪队列（由各就绪进程的PcB组成）</p></li><li><p>在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</p></li></ul><p><strong>调度算法评价指标</strong></p><ul><li>CPU利用率：指CPU“忙碌”的时间占总时间的比例。</li><li>系统吞吐量：单位时间内完成作业的数量</li><li>周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。<ul><li>它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等<br>待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待O操作完成的时间。后三项<br>在一个作业的整个处理过程中，可能发生多次。</li></ul></li><li>等待时间：进程作业等待被服务的时间之和</li><li>响应时间：指从用户提交请求到首次产生响应所用的时间。</li></ul><p>调度算法：</p><ul><li>先来先服务<ul><li>非抢占式</li></ul></li><li>短作业优先<ul><li>非抢占式、抢占式（最短剩余时间）</li></ul></li><li>高响应比优先<ul><li>非抢占式</li></ul></li><li>时间片轮转调度算法RR<ul><li>抢占式</li><li>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li><li>另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</li></ul></li><li>优先级调度算法<ul><li>抢占式+非抢占式</li></ul></li><li>多级反馈队列调度算法<ul><li>抢占式</li></ul></li></ul><h2 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h2><blockquote><p>内存是用于存放数据的<strong>硬件</strong>。<mark>程序执行前需要先放到内存中才能被CPU处理</mark>。</p><p>内存的每个存储单元都会进行编址：①按字节编址、②按字编址</p></blockquote><ul><li><p>我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址存/取数据。但实际在生成机器指令的时候并不知道该进程的数据会被放到什么位置。所以编译生成的指令中一般是使用<strong>逻辑地址</strong>（相对地址）</p></li><li><p>相对地址又称逻辑地址，绝对地址又称物理地址。</p></li><li><p>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）</p></li><li><p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个<strong>完整的装入模块</strong></p><ol><li>静态链接.a：<strong>在程序运行之前</strong>，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。</li><li><a href="http://xn--y5qq4a560asqdwsdt19e64r.so" target="_blank" rel="noopener">装入时动态链接.so</a>：将各目标模块装入内存时，<strong>边装入边链接</strong>的链接方式。</li><li>运行时动态链接.dll：<strong>在程序执行中需要该目标模块时</strong>，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li></ol></li><li><p>装入（装载）：由装入程序将<strong>装入模块</strong>装入<strong>内存</strong>运行</p><p>装入的三种方式（用三种不同的方法完成逻辑地址到物理地址的转换）：</p><ol><li><p>绝对装入</p><ul><li>绝对装入只适用于<strong>单道程序环境</strong>。程序中使用的绝对地址，可在<strong>编译或汇编</strong>时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</li></ul></li><li><p>静态重定位（可重定位装入）</p><ul><li><p>编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入时</strong>对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。</p></li><li><p>静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</p></li></ul></li><li><p>动态重定位（又称动态运行时装入，目前采用的方式）</p><ul><li>编译、链接后的装入模块的地址都是从0开始的。装入程序把裝入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到<strong>程序真正要执行时</strong>才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器</strong>（存放装入模块存放的起始位置）的支持。</li><li>采用动态重定位时允许程序在内存中发生移动。</li><li>★并且可将程序分配到<strong>不连续的存储区</strong>中；<strong>在程序运行前只需装入它的部分代码</strong>即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</li></ul></li></ol></li></ul><h3 id="操作系统需要做的事"><a class="markdownIt-Anchor" href="#操作系统需要做的事"></a> 操作系统需要做的事？</h3><p>1.操作系统负责内存空间的分配与回收<br>2.操作系统需要提供某种技术从逻辑上对内存空间进行扩充<br>3.操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</p><p>内存保护：</p><blockquote><p>保证各进程在自己的内存空间内运行，不会越界访问</p></blockquote><ul><li>方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界</li><li>方法二：采用<strong>重定位寄存器</strong>（又称基址寄存器）和<strong>界地址寄存器</strong>（又称<strong>限长寄存器</strong>）进行越界检査。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址</li></ul><p>内存空间扩充：</p><ul><li>覆盖技术（弃用）：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。<ul><li>内存中分为一个“固定区”和若干个“覆盖区”。</li><li>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</li><li>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</li><li>必须由程序员声明覆盖结构，操作索统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。</li></ul></li><li>交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）、<ul><li>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</li><li>暂时换出外存等待的进程状态为挂起状态（挂起态， suspend）</li><li>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</li><li>覆盖与交换的区别<ul><li>覆盖是在同一个程序或进程中的</li><li>交换是在不同进程（或作业）之间的</li></ul></li></ul></li><li>虚拟存储技术<ul><li>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。<br>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存</li><li>传统存储管理方式的特征、缺点：<ul><li><strong>一次性</strong>：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：①作业很大时，不能全部装入内存，导致大作业无法运行；②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降</li><li><strong>驻留性</strong>：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</li></ul></li><li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。<br><strong>对换性</strong>：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。<br><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li><li>请求分页存储管理<br>请求分段存储管理<br>请求段页式存储管理</li></ul></li></ul><h3 id="内存空间的分配与回收"><a class="markdownIt-Anchor" href="#内存空间的分配与回收"></a> 内存空间的分配与回收：</h3><ul><li><p>连续分配管理方式：为用户进程分配的必须是一个连续的内存空间</p><ul><li>单一连续分配：在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。<strong>内存中只能有一道用户程序</strong>，用户程序独占整个用户区空间。<ul><li>优点：实现简单；<strong>无外部碎片</strong>；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的PC操侬系统 MS-DOS）。</li><li>缺点：只能用于单用户、单任务的操作系统中；<strong>有内部碎片</strong>；存储器利用率极低。</li></ul></li><li>固定分区分配：将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。<ul><li>优点：实现简单，<strong>无外部碎片</strong>。</li><li>缺点：a.当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；b.会产生<strong>内部碎片</strong>，内存利用率低。</li></ul></li><li>动态分区分配：动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为64MB，系统区8MB，用户区共56MB.）<ul><li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</li><li>空闲分区表：每个空闲分区对应个表项。表项中包含分区号分区大小、分区起始地址等信息</li><li>动态分区分配<strong>没有内部碎片</strong>，但是<strong>有外部碎片</strong>。内部碎片，分配给某进程的内存区域中，如果有些部分没有用上外部碎片，是指内存中的某些空闲分区由于太小而难以利用。</li></ul></li></ul></li><li><p>非连续分配管理方式（离散分配方式）：为用户进程分配的可以是一些分散的内存空间。</p><ul><li><p>基本分页存储管理</p><ul><li>把“固定分区分配”改造为“非连续分配版本”，将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“<strong>页框</strong>”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“<strong>页框号</strong>”（或者“内存块号”、“页帧号”、“物理块号”）页框号从0开始。</li><li>将<strong>用户进程的地址空间</strong>也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号页号也是从0开始。（注：进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）</li><li>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，<strong>进程的页面与内存的页框有一一对应的关系</strong></li><li>为了方便计算页号、页内偏移量，页面大小一般设为2的整数幂</li><li>如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是2K个内存单元<br>如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2M个页面</li><li>个进程对应一张页表<br>▲进程的每一页对应一个页表项，每个页表项由“页号”和“块号”组成<br>页表记录进程页面和实际存放的内存块之间的对应关系</li><li>优点：内存空间利用率高，不会产生外部碎片，只会有少量的<strong>页内碎片</strong></li><li>缺点：不方便按照逻辑模块实现信息的共享和保护</li><li>单级列表：<ul><li>问题一：页表必须连续存放，因此当页表很大时，需要占用很多连续的页框。<ul><li>多级，顶级页表</li></ul></li><li>问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。<ul><li>可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</li><li>若想访问的页面不在内存中，则产生缺页中断（内中断），然后将目标页面从外存调入内存</li></ul></li></ul></li></ul></li><li><p>基本分段存储管理</p><ul><li>优点：很方便按照逻辑模块实现信息的共享和保护</li><li>缺点：如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生<strong>外部碎片</strong></li><li>段号的位数决定了每个进程最多可以分几个段<br>段内地址位数决定了每个段的最大长度是多少</li></ul><p>对比：</p><ul><li>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</li><li>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名</li><li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</li><li>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</li><li>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址</li><li>分段比分页更容易实现信息的共享和保护。</li></ul></li><li><p>段页式存储管理</p></li></ul></li></ul><p>局部性原理</p><p>时间局部性<br>空间局部性<br>高速缓存技术</p><p>页面置换算法：</p><ul><li>OPT</li><li>FIFO</li><li>LRU</li><li>CLOCK （NRU）</li><li>改进型 CLOCK（改进型NRU）</li></ul><h2 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h2><ul><li><p>无结构文件（流式文件）</p></li><li><p>有结构文件（记录式文件）</p><ul><li><p>每条<strong>记录</strong>由多个<strong>数据项</strong>组成，而每条记录的单个数据项都通过<strong>关键字</strong>表达具体含义，如名字。</p></li><li><p>逻辑结构：</p><ul><li>顺序文件： 链式存储（不可随机读取）、顺序存储（可变长记录不可随机读取、定长记录可以）</li><li>索引文件</li><li>索引顺序文件</li></ul></li></ul></li></ul><p>注：</p><ul><li>逻辑结构：就是指在用户看来，文件内部的数据应该是如何组织起来的。</li><li>物理结构：是在操作系统看来，文件的数据是如何存放在外存中的。</li></ul><p>注：一般来说，考试题目中所说的顺序文件”指的是物理上顺序存储的顺序文件。之后的讲解中提到的顺序文件也默认如此。</p><h3 id="文件目录"><a class="markdownIt-Anchor" href="#文件目录"></a> 文件目录</h3><ul><li><p>文件控制块(FCB)： <code>文件名、类型、读写权限、...、物理位置</code>，包含逻辑结构、物理结构，存取控制信息、使用信息</p></li><li><p>目录结构</p><ul><li><p>单级目录结构</p></li><li><p>两级目录结构：MFD主文件目录、用户文件目录UFD</p></li><li><p>多级目录结构（树形目录结构）：</p><ul><li>不同目录下的文件可以重名，可以对文件进行分关不方便文件共享</li><li>系统根据“文件路径&quot;找到目标文件</li><li>从根目录出发的路径是“绝对路径（“照片/201508/自拍jpg”）</li><li>从当前目录出发的路径是相对路径（照片12015-08/自拍jpg&quot;<ul><li>相对路径减少磁盘IO：是因为内存中存储了当前目录表，因此当用户想访问当前目录的某个文件的时候，就可以直接从内存中直接通过相对路径来找，自然搜索效率更高些</li></ul></li></ul><p>树形目录结构可以方便的对文件进行分类，层次结构清晰；但是不便于实现文件的共享==&gt;无环图目录结构，在树形目录的基础上，增加指向同一节点的有向边，使得整个目录成了有向无环图</p></li><li><p>无环图目录结构——方便文件共享</p></li></ul></li><li><p>索引结点（对文件控制块的优化）</p><ul><li>将FCB中除了文件名以外的信息放在索引节点上，而取而代之的将其内容换成2B的索引节点地址，从而大大减小了FCB大小，从而相同的记录项能够使用更少的磁盘块，从而加快了磁盘搜索的速度</li></ul></li></ul><p>目录文件中的一条记录就是一个FCB，FCB的有序集合称为“文件目录”，一个FCB就是一个文件目录项。</p><h3 id="文件物理结构管理非空闲磁盘块"><a class="markdownIt-Anchor" href="#文件物理结构管理非空闲磁盘块"></a> 文件物理结构——管理非空闲磁盘块</h3><blockquote><p>文件数据怎样存放在外存中？</p><ul><li>类似于内存分页，磁盘中的存储单元是“块or磁盘块or物理块”，内存与磁盘之间数据交互是以块为单位的。</li><li>文件的逻辑地址空间也被分成了一个个文件“块”==&gt; 文件的逻辑地址形式：(逻辑块号, 块内地址)</li><li>用户通过逻辑地址来操作自己的文件，操作系统负责从逻辑地址到物理地址的映射</li></ul></blockquote><ul><li><p>连续分配</p><ul><li>连续分配方式要求每个文件在磁盘上占有一组连续的块。</li><li><strong>优点</strong>：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快</li><li><strong>缺点</strong>：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</li></ul></li><li><p>链接分配</p><ul><li>隐式链接（题目默认指的是隐式链接）<ul><li>隐式链接——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</li><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高。</li><li>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</li></ul></li><li>显式链接<ul><li>显式链接——把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表（FAT，File Allocation Table）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存</li><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li><li>缺点：文件分配表的需要占用一定的存储空间。</li></ul></li></ul></li><li><p>索引分配</p><ul><li>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张<strong>索引表</strong>，索引表中文<br>件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表一一建立逻辑页面到物理页之间<br>的映射关系）。索引表存放的磁盘块称为<u>索引块</u>。文件数据存放的磁盘块称为<u>数据块</u>。</li><li>可见，索引分配方式可以支持随机访问文件拓展也很容易实现（只需要给文件分配个空闲块，并增加一个索引表项即可）<strong>但是索引表需要占用一定的存储空间</strong></li><li>Q:这种存储方式会带来一个问题，由于一个索引项占4B，一个磁盘块大小为1KB，那么最多存储256(1024/4)个索引项，也就是说存储文件最大为256*1KB=256KB。但是如果一个文件大小超过了256块，一个磁盘块装不下所有的索引表该怎么办呢？<ul><li>链接方案： 索引块的最后一个索引项存储下一个索引块的地址。<ul><li>需要顺序读取每个索引块，无法根据逻辑块号随机访问，磁盘IO次数多</li></ul></li><li>多层索引：建立多层索引（类似多级页表）。使第一层索引表指向第二层索引表，还可以根据文件大小建立第三层、第四层<ul><li>若采用多层索引，则各层的索引表大小不能超过一个磁盘块；</li><li>二层索引，文件最大大小：<code>256*256*1KB</code>=64MB</li><li>可根据逻辑块号算出应该查找索引表中的哪个表项。如：要访问1026号逻辑块，则<code>1026/256=4,1026%256=2</code></li><li>采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作</li></ul></li><li>混合索引：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<strong>直接地址索引</strong>（直接指向数据块），又包含<strong>一级间接索引</strong>（指向单层索引表）、还包含两<strong>级间接索引</strong>（指向两层索引表）。<ul><li>题型：根据顶级索引表的结构，计算能够存储文件的最大长度</li><li>对于小文件，只需较少的读磁盘次数就可以访问目标数据块。（一般计算机中小文件更多）</li></ul></li></ul></li></ul><p>超级超级超级重要考点：①要会根据多层索引、混合索引的结构计算出文件的最大长度（Key：各级索引表最大不能超过一个块）；②要能自己分析访问某个数据块所需要的读磁盘次数（Key:FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件一一顶级索引块是否已调入内存）</p></li></ul><h3 id="存储空间管理管理空闲磁盘块"><a class="markdownIt-Anchor" href="#存储空间管理管理空闲磁盘块"></a> 存储空间管理——管理空闲磁盘块</h3><p><strong>划分与初始化</strong></p><ul><li>将物理磁盘分成一个个文件卷（逻辑卷、逻辑盘）</li><li>初始化：将各个文件卷划分为目录区（文件目录信息FCB、磁盘储存空间管理的信息）、文件区（存放文件数据）</li><li>一个物理磁盘可以划分成多个逻辑磁盘；也可以将多个物理磁盘合并成一个逻辑磁盘</li></ul><p><strong>管理方法</strong></p><ul><li><p>空闲表法： 适用于连续分配方式</p><ul><li><table><thead><tr><th>第一个空闲盘块号</th><th>空闲磁盘数</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><p>与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况一一</p><ol><li>回收区的前后都没有相邻空闲区；</li><li>回收区的前后都是空闲区；</li><li>回收区前面是空闲区；</li><li>回收区后面是空闲区。</li></ol></li></ul><p>总之，回收时需要注意表项的合并问题。</p></li><li><p>空闲链表法：</p><ul><li>空闲盘块链：以盘块为单位组成一条空闲链<ul><li>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作</li><li>分配：如果申请K个盘块，则从链头开始依次摘下K个盘块进行分配，并修改空闲链的链头指针</li><li>回收：将回收的盘块依次挂到链尾，并修改空闲链的链尾指针</li></ul></li><li>空闲盘区链：以盘区为单位组成一条空闲链<ul><li>操作系统保存着链头、链尾指针。</li><li>如何分配：若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</li><li>如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</li></ul></li></ul></li><li><p>位示图法：</p><ul><li><p>每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中个字的字长是16位，字中的每一位对应一个盘块。因此可以用**（字号，位号）<strong>对应一个盘块号。当然有的题目中也描述为</strong>（行号，列号）**</p></li><li><p>重要重要重要：要能自己推出盘块号与（字号位号）相互转换的公式注意题目条件：盘块号、字号、位号到底是从0开始还是从1开始</p><p>如本例中盘块号、字号、位号从0开始，若n表示字长，则（字号，位号）=（i，j)的二进制位对应的盘块号<code>b=n*i+j</code>， b号盘块对应的字号i=b/n取整数部分，位号j=b%n</p></li><li><p>如何分配：若文件需要κ个块，①顺序扫描位示图，找到K个相邻或不相邻的“0”；②根据字号、位号算出对应的盘块号，将相应盘块分配给文件；<br>③将相应位设置为“1</p></li><li><p>如何回收：①根据回收的盘块号计算出对应的字号、位号；②将相应二进制位设为“0</p></li></ul></li><li><p>成组链接法：</p><blockquote><p>前两者不适用于大型文件系统，因为空闲表或者空闲链表可能会太大。Unix中采用了成组链接法对磁盘空闲块进行管理</p></blockquote><p>文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入內存。并且要保证<strong>内存</strong>与<strong>外存</strong>中的“超级块”<strong>数据一致</strong>。</p><p><img src="/2021/09/09/ZJU开学摸底考试——操作系统复习/%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95-%E8%B6%85%E7%BA%A7%E5%9D%97.png" alt="成组链接法-超级块"></p><ul><li>一个分组中的块号不需要连续</li><li>当前组的空闲盘块数有上限大小</li><li>超级块记录着当前组空闲块的信息： 空闲盘块数、空闲块号（地址）</li></ul><p>分配过程：</p><ul><li>Eg：需要1个空闲块<br>①检查第一个分组的块数是否足够。1&lt;10，因此是足够的。</li><li>Eg：需要100个空闲块<br>①检查第一个分组的块数是否足够。100=100，是足够的。<br>②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块（超级块相当于是个链头）中。</li></ul><p>回收过程：</p><ul><li>Eg：假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块</li><li>Eg：假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第个分组</li></ul></li></ul><h3 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h3><p><strong>创建文件</strong></p><p>参数：</p><ul><li>文件大小</li><li>存放路径</li><li>文件名</li></ul><p>操作系统的过程</p><p>在外存中找到文件所需的空间–&gt;根据文件存放信息找到该目录对应的目录信息（在目录中创建该文件对应的目录项）</p><p><strong>删除文件</strong></p><p>参数：</p><ul><li>文件存放路径</li><li>文件名</li></ul><p>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项–&gt;根据目录项记录的外存位置、文件大小等信息，回收文件占用的磁盘块–&gt;从目录表中删除文件对应的目录项</p><p><strong>打开文件</strong></p><p>参数：</p><ul><li>文件存放路径</li><li>文件名</li><li>对文件的操作类型</li></ul><p>操作系统：</p><p>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并<strong>检查</strong>该用户是否有指定的<strong>操作权限</strong>-----&gt;将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文表的编号来指明要操作的文件。</p><ul><li>系统的“打开文件表”<ul><li>编号（索引号也叫文件描述符）、文件名、外存地址、打开计数器</li></ul></li><li>用户进程A的“打开文件表”<ul><li>编号， 文件名， 读写指针， 访问权限， 系统表索引号</li></ul></li></ul><p><strong>关闭文件</strong></p><p>进程使用完文件后，要“关闭文件”操作系统在处理Cose系统调用时，主要做了几件事：</p><ol><li>将<strong>进程的打开文件表</strong>相应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li><strong>系统打开文件表</strong>的打开计数器 count减1，若 count=0，则删除对应表项</li></ol><h3 id="文件共享"><a class="markdownIt-Anchor" href="#文件共享"></a> 文件共享</h3><blockquote><p>多个用户共享同一个文件，意味着系统中**只有“一份”**文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。</p><p>与“复制”区分：如果是多个用户都“复制”了同一个文件，那么系统中会有“好几份文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。</p></blockquote><ul><li>基于索引结点的共享方式（硬链接）<ul><li>索引节点记录cnt：用于表示链接到本索引结点上的用户目录项数</li><li>不同用户对于该共享文件的命名可以是不同的</li><li>索引节点指向的是真实地文件</li></ul></li><li>基于符号链的共享方式（软链接）<ul><li>索引节点指向地是Link类型地文件，它记录了真实文件的存放路径（相当于windows的快捷方式）——比硬链接经历的磁盘IO更多</li><li>即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）</li></ul></li></ul><p><strong>文件保护</strong></p><ul><li>口令保护<ul><li>优点：保存口令的空间开销不多，验证口令的时间开销也很小。<br>缺点：正确的“口令”存放在系统内部，不够安全。</li></ul></li><li>加密保护<ul><li>优点：保密性强，不需要在系统中存储“密码”<br>缺点：编码/译码，或者说加密/解密要花费一定时间。</li></ul></li><li>访问控制：ACL访问控制列表<ul><li>读、写、执行、添加、删除、列表文件夹内容</li><li>精简的访问列表——组：完全控制：执行、修改、读、写（2^4=0-7）</li></ul></li></ul><h2 id="磁盘"><a class="markdownIt-Anchor" href="#磁盘"></a> 磁盘</h2><h3 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h3><ul><li>磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</li><li>磁道：磁盘的盘面被划分成一个个磁道这样的一个“圈”就是一个磁道</li><li>扇区：一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”。<strong>各个扇区存放的数据量相同</strong>（如1KB）<ul><li>最内侧的扇区面积最小，因此数据密度最大</li></ul></li><li>盘面：一个盘片会有多个盘面</li><li>柱面：所有盘面中相对位置相同的磁道组成柱面</li></ul><p>磁盘的物理地址：可用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块”。在“文件的物理结构”小节中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成**（柱面号，盘面号，扇区号）**的地址形式。</p><p>如何读取数据：磁盘转起来，让磁头从目标扇区上划过，才能完成对扇区的读写操作：</p><ul><li>可根据该地址读取一个“块”<br>①根据“柱面号”移动磁臂，让磁头指向指定柱面；<br>②激活指定盘面对应的磁头；<br>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。</li></ul><p>分类：</p><ul><li>固定头磁盘（每个磁道都有一个固定的磁头）</li><li>移动头磁盘（一个盘面就只有一个可移动的磁头）</li><li>固定盘磁盘</li><li>可换盘磁盘</li></ul><h3 id="磁盘调度"><a class="markdownIt-Anchor" href="#磁盘调度"></a> 磁盘调度</h3><p><strong>一次磁盘读/写操作需要的时间</strong></p><ul><li>寻找（磁道）时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">T_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：在读/写数据前，将磁头移动到指定磁道所花的时间：Ts=启动磁头臂s+n条磁道*跨越每个磁道耗时m</li><li>延迟时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：磁盘旋转，等磁头转到目标扇区所需要的时间。平均所需延迟时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∗</mo><mfrac><mn>1</mn><mi>r</mi></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>r</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_R=\frac{1}{2}*\frac{1}{r}=\frac{1}{2r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，r为转速（r/s,r/min），1/r是转一圈所需要的时间，1/2是找到目标扇区平均需要转半圈。</li><li>传输时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">T_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N，b个字节需要b/N个磁道储存则：传输时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>r</mi></mfrac><mo>∗</mo><mfrac><mi>b</mi><mi>N</mi></mfrac><mo>=</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_t=\frac{1}{r}*\frac{b}{N}=\frac{b}{rN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，</li></ul><p>总的平均存取时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub><mo>=</mo><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><msub><mi>T</mi><mi>R</mi></msub><mo>+</mo><msub><mi>T</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">T_a=T_s+T_R+T_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>注：延迟时间和传输时间都与<strong>磁盘转速</strong>相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间。而可以控制的时间为寻道时间Ts，这个与磁盘调度算法直接相关</p><p><strong>算法</strong></p><ul><li><p>先来先服务（FCFS）</p><ul><li>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去</li><li>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</li></ul></li><li><p>最短寻找时间优先（SSTF）</p><ul><li><p>优点：性能较好，平均寻道时间短</p></li><li><p>缺点：可能产生“饥饿”现象</p><p>Ｅg：本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。</p></li></ul></li><li><p>扫描算法（SCAN）</p><ul><li>SSTF算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法（SCAN）的思想。由于磁头移动的方式很像电梯，因此也叫<strong>电梯算法</strong>。</li><li>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</li><li>缺点：①只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。②SCAN算法对于<strong>各个位置磁道的响应频率不平均</strong>（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）</li></ul></li><li><p>循环扫描算法（C-SCAN）</p><ul><li>扫描算法（<strong>SCAN</strong>）中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。LoOK调度算法就是为了解决这个问题，如果<strong>在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</strong>。（边移动边观察，因此叫LOOK）<ul><li>优点：比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进步缩短</li></ul></li><li>SCAN算法对于各个位置磁道的响应频率不平均，而 <strong>C-SCAN</strong>算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求<ul><li>优点：比起SCAN来，对于各个位置磁道的响应频率很平均</li><li>缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。</li></ul></li><li>CLOOK算法:结合LOOK和C-SCAN</li></ul></li></ul><p>若题目中无特别说明，则sCAN就是LoOK, C-SCAN就是 C-LOOK</p><h3 id="磁盘管理"><a class="markdownIt-Anchor" href="#磁盘管理"></a> 磁盘管理</h3><p><strong>磁盘初始化：</strong></p><p>step1：进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误）<br>Step2：将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的C盘、D盘、E盘）<br>Step3：进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）</p><p><strong>引导块：</strong></p><blockquote><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的</p></blockquote><p>初始化程序可以放在ROM（只读存储器）中。ROM中的数据在出厂时就写入了，并且以后不能再修改注：ROM一般是出厂时就集成在主板上的===&gt; 现在的做法是：ROM只存放很小的“自举装入程序”，完整的自举程序放在磁盘的启动块（即引导块/启动分区上），启动块位于磁盘的固定位置。<strong>拥有启动分区的磁盘成为启动磁盘或系统磁盘</strong></p><p><strong>IO设备</strong></p><p><strong>使用特性进行分类</strong></p><ul><li>人机交互类外部设备</li><li>存储设备</li><li>网络通信设备</li></ul><p><strong>按信息交换的单位分类</strong></p><ul><li>块设备：传输速率较高，可寻址，即对它可随机地读/写任一块，如磁盘</li><li>字符设备：传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式，如键盘和鼠标、串口</li></ul><h2 id="io控制器"><a class="markdownIt-Anchor" href="#io控制器"></a> IO控制器</h2><p>功能</p><ul><li>接受和识别CPU发出的命令</li><li>向CPU报告设备的状态</li><li>数据交换</li><li>地址识别</li></ul><p>寄存器的地址</p><ul><li>内存映像I/O：控制器中的寄存器与内存地址统编址</li><li>寄存器独立编址：控制器中的寄存器使用单独的地址</li></ul><p>IO控制方式：</p><ul><li><p>程序直接控制方式：</p><ol><li>完成一次读/写操作的流程（见右图， Key word：轮询）</li><li>CPU干预的频率：很频繁，O操作开始之前、完成之后需要CPU介入，并且在等待/O完成的过程中CpU需要不断地轮询检查。</li><li>数据传送的单位：每次读/写一个<strong>字</strong></li><li>数据的流向<br>读操作（数据输入）：I/O设备→CPU→内存<br>写操作（数据输出）：内存→CPU→I/O设备<br>每个字的读/写都需要CPU的帮助读入下个字</li><li>主要缺点和主要优点<br>优点：实现简单。在读/写指令之后，加上实现循环检查的<br>系列指令即可（因此才称为“程序直接控制方式”）<br>缺点：CPU和i/o设备只能串行工作，CPU需要一直轮询检查，<br>长期处于“忙等”状态，CPU利用率低。</li></ol></li><li><p>中断驱动方式</p><ul><li>①CPU会在每个<strong>指令周期的末尾</strong>检查中断；<br>②中断处理过程中需要保存、恢复逑程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发的频率太高，也会降低系统性能。</li></ul><ol><li>完成一次读/写操作的流程（见右图， Key word：中断）</li><li>CPU干预的频率<br>每次o操作开始之前、完成之后需要CPU介入<br>等待0完成的过程中CPU可以切换到别的进程执行。</li><li>数据传送的单位<br>每次读/写一个字</li><li>数据的流向<br>读操作（数据输入）：V/O设备→CPU→内存<br>写操作（数据输出）：内存→CPU→1/O设备</li><li>主要缺点和主要优点<br>优点：与“程序直接控制方式”相比，在“中断驱动方式”中，Ⅵo控制器会通过中断信号主动报告O已完成，CPU不再需要不停地轮询<strong>CPU和i/o设备可并行工作</strong>，CPU利用率得到明显提升。<br>缺点：每个字在O设备与内存之间的传输，都需要经过cPU。而频繁的中断处理会消耗较多的CPU时间</li></ol></li><li><p>DMA方式：直接存储器存取</p><ul><li><p>①数据的传送单位是“块”，不再是一个字、一个字的传送（写入内存时是一块写入的，但从设备到DMA控制器读取数据时仍然是一个字一个字读取or写入的）；每次读写<br>②数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥”<br>③仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p></li><li><p><img src="/2021/09/09/ZJU开学摸底考试——操作系统复习/DMA.png" alt="DMA"></p></li><li><p>DR（ Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。</p></li><li><p>MAR（ Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应放到内存中的什么位置；输出时MAR表示要输出的数据放在内存中的什么位置。</p></li><li><p>DC（ Data Counter，数据计数器）：表示剩余要读/写的字节数。</p></li><li><p>CR（ Command Register，命令/态寄存器）：用于存放CPU发来的/O命令，或设备的状态信息。</p></li></ul><ol><li><p>CPU干预的频率:仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p></li><li><p>数据传送的单位:每次读/写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</p></li><li><p>数据的流向（不再需要经过cPU）<br>读操作（数据输入）：U/O设备→内存<br>写操作（数据输出）：内存→/O设备</p></li><li><p>主要缺点和主要优点优点：数据传输以“块”为单位，<strong>CPU介入频率</strong>进一步降低。数据的传输<strong>不再需要先经过Cpu再写入内存</strong>，数据传输效率进一步增加。CPU和/O设备的并行性得到提升。</p><p>缺点：cPU每发出一条IO指令，只能读/写一个或多个连续的数据块如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条IO指令，进行多次中断处理才能完成。</p></li></ol></li><li><p>通道控制方式</p><ul><li>通道：一种硬件，可以理解为是“弱鸡版的CpU”。通道可以识别并执行一系列通道指令</li><li>相比DMA，通道可以识别指令</li></ul><ol><li><strong>CPU干预的频极低</strong>，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。</li><li>数据传送的单位每次读/写<strong>一组数据块</strong></li><li>数据的流向（在通道的控制下进行）读操作（数据输入）：1/O设备→内存写操作（数据输出）：内存IO设备</li><li>主要缺点和主要优点缺点：实现复杂，需要专门的通道硬件支持</li><li>优点：CPU、通道、1/O设备可并行工作，资源利用率很高。</li></ol></li></ul><h2 id="缓冲区"><a class="markdownIt-Anchor" href="#缓冲区"></a> 缓冲区</h2><ul><li>缓和CPU与IO设备之间速度不匹配的矛盾</li><li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li><li>解决数据粒度不匹配的问题</li><li>提高CPU与IO设备之间的并行性</li></ul><p><strong>缓冲策略</strong></p><ul><li>单缓冲：假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）</li><li>双缓冲：</li><li>循环缓冲</li><li>缓冲池</li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><p>Q: 显示器和<strong>键盘</strong>是终端TTY设备</p><p>Q:解决临界区问题要满足三个条件：<strong>互斥（Mutual Exclusion）</strong>、<strong>空闲让进/前进（Progress）</strong>、<strong>有限等待（Bounded Waiting）</strong></p><p><a href="https://blog.csdn.net/tugouxp/article/details/116379389" target="_blank" rel="noopener">最短任务优先(SJF)调度策略平均周转时间最优性</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#操作系统&quot;&gt;&lt;/a&gt; 操作系统&lt;/h1&gt;
&lt;h2 id=&quot;特性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#特性&quot;&gt;&lt;/a&gt; 特性：&lt;/h2&gt;
&lt;ul
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>学习画好架构图</title>
    <link href="https://nymrli.top/2021/08/24/%E5%AD%A6%E4%B9%A0%E7%94%BB%E5%A5%BD%E6%9E%B6%E6%9E%84%E5%9B%BE/"/>
    <id>https://nymrli.top/2021/08/24/学习画好架构图/</id>
    <published>2021-08-24T06:57:11.000Z</published>
    <updated>2021-08-24T07:26:14.170Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一图胜万语，做好一张架构图能让别人一眼就清晰地弄懂程序的功能与依赖，大大降低大家的理解成本和提升沟通效率。但作为新人而言，如何画出要点，提炼出核心概念是个有难度的事。</p></blockquote><h2 id="什么是架构"><a class="markdownIt-Anchor" href="#什么是架构"></a> <strong>什么是架构？</strong></h2><p>架构是结构和愿景，是对系统中的实体以及实体之间的关系所进行的抽象描述，是一系列的决策。</p><p>系统架构是概念的体现，是对物/信息的功能与形式元素之间的对应情况所做的分配，是对元素之间的关系以及元素同周边环境之间的关系所做的定义。</p><h2 id="什么是架构图"><a class="markdownIt-Anchor" href="#什么是架构图"></a> <strong>什么是架构图？</strong></h2><p>系统架构图是为了抽象地表示<u>软件系统</u>的<strong>整体轮廓</strong>和<u>各个组件</u>之间的相互关系和<strong>约束边界</strong>，以及软件系统的物理部署和软件系统的演进方向的<strong>整体视图</strong>。</p><h2 id="架构图的作用"><a class="markdownIt-Anchor" href="#架构图的作用"></a> <strong>架构图的作用</strong></h2><p>要让干系人理解、遵循架构决策，就需要把架构信息传递出去。架构图就是一个很好的载体。那么，画架构图是为了：</p><ul><li>解决沟通障碍</li><li>达成共识</li><li>减少歧义</li></ul><h2 id="架构核心要素"><a class="markdownIt-Anchor" href="#架构核心要素"></a> 架构核心要素</h2><p><img src="/2021/08/24/学习画好架构图/C:%5CUsers%5Cmrli%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210824152422270.png" alt="image-20210824152422270"></p><p>综合上述各种权威定义，软件系统的架构通常需要包含如下四类核心要素：</p><ul><li><strong>元素（elements）</strong>：将系统拆分为一组元素 - 模块、组件、结构体、子系统；</li><li><strong>关系（relationships）</strong>：不同元素之间的关系 - 交互、依赖 、继承、组合、聚合；</li><li><strong>属性（properties）</strong>：每个元素具备的属性 - 名称、职责、接口、实现限制等；</li><li><strong>原理（principles）</strong>：为什么这么设计 - 拆分依据、设计原则、决策原因等。</li></ul><h2 id="架构图分类"><a class="markdownIt-Anchor" href="#架构图分类"></a> <strong>架构图分类</strong></h2><p>搜集了很多资料，分类有很多，有一种比较流行的是4+1视图，分别为场景视图、逻辑视图、物理视图、处理流程视图和开发视图。</p><p>from：<a href="https://blog.csdn.net/wwd0501/article/details/105688895" target="_blank" rel="noopener">如何画好软件项目架构图？</a>， <a href="https://zhuanlan.zhihu.com/p/260068315" target="_blank" rel="noopener">架构制图：工具与方法论</a></p><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="五种常见软件架构"><a class="markdownIt-Anchor" href="#五种常见软件架构"></a> <a href="https://www.cnblogs.com/doit8791/p/9343826.html" target="_blank" rel="noopener">五种常见软件架构</a></h2><ul><li>分层架构</li><li>事件驱动架构</li><li>微核架构</li><li>微服务架构</li><li>云架构</li></ul><h2 id="架构图example"><a class="markdownIt-Anchor" href="#架构图example"></a> 架构图example：</h2><p><img src="/2021/08/24/学习画好架构图/C:%5CUsers%5Cmrli%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210824150755684.png" alt="image-20210824150755684"></p><hr><p><img src="https://i.loli.net/2021/08/24/x3g8pz7heaDvTXd.png" alt=""></p><hr><p><img src="https://i.loli.net/2021/08/24/uEUok8KXzWPen4f.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一图胜万语，做好一张架构图能让别人一眼就清晰地弄懂程序的功能与依赖，大大降低大家的理解成本和提升沟通效率。但作为新人而言，如何画出要点，提炼出核心概念是个有难度的事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是架构&quot;&gt;&lt;a clas
      
    
    </summary>
    
    
      <category term="福利" scheme="https://nymrli.top/tags/%E7%A6%8F%E5%88%A9/"/>
    
  </entry>
  
  <entry>
    <title>AOP学习</title>
    <link href="https://nymrli.top/2021/08/19/AOP%E5%AD%A6%E4%B9%A0/"/>
    <id>https://nymrli.top/2021/08/19/AOP学习/</id>
    <published>2021-08-19T08:35:08.000Z</published>
    <updated>2021-09-09T05:12:21.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="aop学习"><a class="markdownIt-Anchor" href="#aop学习"></a> AOP学习</h1><h2 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h2><h3 id="要素"><a class="markdownIt-Anchor" href="#要素"></a> 要素</h3><p><img src="/2021/08/19/AOP学习/E:%5Chexo%5Csource_posts%5CAOP%E5%AD%A6%E4%B9%A0%5C%E8%A6%81%E7%B4%A0.png" alt="要素"></p><ul><li>Aspect切面：是切入点和通知的抽象——切面则是横切关注点的抽象，与类相似，类是对物体特征的抽象，切面则是横切关注点抽象。</li><li>切入点PointCut：定义要拦截哪些类的哪些方法<ul><li>切入点表达式<code>@Pointcut(&quot;execution(* com.service.*.*(..))&quot;)</code><br>执行exectution后的第一个参数代表的是方法的修饰范围（public、private、protected）,第二个表示拦截的方法，第一个<code>*</code>表示所有类，第二个<code>*</code>表示所有的方法，括号中的…表示任意参数</li><li>常用的切入点表达式有：<ul><li><code>execution(public *(..))</code>执行所有公有方法</li><li><code>execution(* set(..))</code>执行所有set方法</li><li><code>execution(* com.service.*.*(..))</code>执行包下任意类的任意方法</li><li><code>execution(* com.service..*.*(..))</code>设定指定包及其子包的任意类的任意方法</li></ul></li></ul></li><li>通知Advice：定义了拦截之后要做什么</li><li>Target（目标对象）:被代理的目标对象</li><li>Weave（织入）:将切面应用到目标对象并生成代理对象的这个过程即为织入</li></ul><p>from: <a href="https://www.bilibili.com/video/BV1Lx411a73q" target="_blank" rel="noopener">程序员大神修炼秘籍 Spring AOP HelloWorld</a></p><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3><p><img src="/2021/08/19/AOP学习/E:%5Chexo%5Csource_posts%5CAOP%E5%AD%A6%E4%B9%A0%5C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="应用场景"></p><h3 id="通知类型"><a class="markdownIt-Anchor" href="#通知类型"></a> 通知类型</h3><p><img src="/2021/08/19/AOP学习/E:%5Chexo%5Csource_posts%5CAOP%E5%AD%A6%E4%B9%A0%5C%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B.png" alt="通知类型"></p><h3 id="java中的aop"><a class="markdownIt-Anchor" href="#java中的aop"></a> JAVA中的AOP</h3><blockquote><p>应用最为广泛的主要包括AspectJ、Spring AOP和JBoss AOP等</p></blockquote><ul><li>AspectJ采用了源代码生成技术来实现AOP，静态织入的方式</li><li>Spring AOP和JBoss AOP在实现上属于动态织入的方式</li></ul><h3 id="demo-code"><a class="markdownIt-Anchor" href="#demo-code"></a> demo code:</h3><p><a href="https://www.bilibili.com/video/BV19f4y1i7ug?p=10" target="_blank" rel="noopener">B站最详细 Spring AOP+Spring 定时任务教程 【涨薪必备】带你一步一步搞定吃透Spring</a></p><h2 id="springaop"><a class="markdownIt-Anchor" href="#springaop"></a> SpringAOP</h2><ul><li><a href="https://www.bilibili.com/video/BV1aC4y1p7bF?p=8" target="_blank" rel="noopener">Spring技术自定义注解和Aop实现事务框架，阿里P7都要掌握的技术~</a>——结合Aop技术，实现注解分析</li><li><a href="https://www.bilibili.com/video/BV1me411s7KH?from=search&amp;seid=3776250925483313694" target="_blank" rel="noopener">一分钟学会自定义注解注入Spring IoC 容器</a>——将自定义注解修饰的类注入到Ioc容器中</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;aop学习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#aop学习&quot;&gt;&lt;/a&gt; AOP学习&lt;/h1&gt;
&lt;h2 id=&quot;aop&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#aop&quot;&gt;&lt;/a&gt; AOP&lt;/h2
      
    
    </summary>
    
    
      <category term="Java" scheme="https://nymrli.top/tags/Java/"/>
    
      <category term="Spring" scheme="https://nymrli.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JWT使用学习</title>
    <link href="https://nymrli.top/2021/08/11/JWT%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://nymrli.top/2021/08/11/JWT使用学习/</id>
    <published>2021-08-11T08:44:17.000Z</published>
    <updated>2021-08-18T07:28:18.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jwt-json-web-token"><a class="markdownIt-Anchor" href="#jwt-json-web-token"></a> JWT: Json Web Token</h1><blockquote><ul><li>与普通Token一样都是访问资源的令牌，都可以记录用户信息，都是只有验证成功后才可以获取信息。</li><li>不同的是普通Token，服务端验证token信息时要进行数据库查询操作；JWT验证token信息就不用，在服务端使用<strong>密钥校验</strong>就可以，不用经过数据库查询。==》它是一个数字签名</li></ul></blockquote><h2 id="jwt信息组成"><a class="markdownIt-Anchor" href="#jwt信息组成"></a> JWT信息组成</h2><p>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p><ul><li><p>Header</p><ul><li>Header header典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。</li></ul></li><li><p>Payload</p><ul><li><p>Payload JWT的第二部分是payload，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</p></li><li><ul><li><p>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">// 这部分是Registered claims</span><br><span class="line">  &quot;iss&quot;: &quot;Online JWT Builder&quot;,  // 该JWT的签发者</span><br><span class="line">  &quot;iat&quot;: 1416797419, // iat(issued at): 在什么时候签发的(UNIX时间)</span><br><span class="line">  &quot;exp&quot;: 1448333419,    // 什么时候过期，这里是一个Unix时间戳</span><br><span class="line">  &quot;aud&quot;: &quot;www.example.com&quot;,  // 接收该JWT的一方</span><br><span class="line">  &quot;sub&quot;: &quot;jrocket@example.com&quot;,  // 该JWT所面向的用户</span><br><span class="line">// 这部分是Public claims</span><br><span class="line">  &quot;GivenName&quot;: &quot;Johnny&quot;, </span><br><span class="line">  &quot;Surname&quot;: &quot;Rocket&quot;, </span><br><span class="line">  &quot;Email&quot;: &quot;jrocket@example.com&quot;, </span><br><span class="line">  &quot;Role&quot;: [ &quot;Manager&quot;, &quot;Project Administrator&quot; ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Public claims : 可以随意定义。</p></li><li><p>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。 下面是一个例子：</p></li></ul></li></ul></li><li><p>Signature</p><ul><li>签名秘钥。 为了得到签名部分，你必须有编码过的header、编码过的payload、<strong>一个秘钥</strong>，签名算法是header中指定的那个，然对它们签名即可。</li></ul></li></ul><p>注： 不要在JWT的payload或header中放置敏感信息，除非它们是加密的。</p><p>然后对每一部分进行base64加密，再通过<code>.</code>组合即可得到JWT。 因此，一个典型的JWT看起来是这个样子的：<code>xxxxx.yyyyy.zzzzz</code></p><p><img src="https://i.loli.net/2021/08/18/7r9GzsDtQqXZUV1.png" alt=""></p><h2 id="jwt网络工作流程"><a class="markdownIt-Anchor" href="#jwt网络工作流程"></a> JWT网络工作流程</h2><p><img src="https://i.loli.net/2021/08/18/JjZHgVbdhwGtiFN.png" alt=""></p><img src="https://pic1.zhimg.com/80/v2-7789057d5744891fdf3366d7887ab6e8_1440w.jpg" style="zoom:50%;"><h2 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景：</h2><ul><li><p>Authorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。<strong>单点登录</strong>是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</p></li><li><p>Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWT可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。</p><p><a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></p></li></ul><h2 id="json-web-tokens是如何工作的"><a class="markdownIt-Anchor" href="#json-web-tokens是如何工作的"></a> JSON Web Tokens是如何工作的</h2><p>在认证的时候，当用户用他们的凭证成功登录以后，一个JSON Web Token将会被返回。此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。一般而言，你保存令牌的时候不应该超过你所需要它的时间。</p><p>无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在**Authorization header(授权头)**中，用Bearer schema。</p><p>服务器上的受保护的路由将会检查Authorization header中的JWT是否有效，如果有效，则用户可以访问受保护的资源。如果JWT包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。</p><p>如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。</p><p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持<code>CORS(跨来源资源共享)</code>策略，一般我们在服务端这么做就可以了<code>Access-Control-Allow-Origin: *</code>。</p><h2 id="基于token的身份认证-与-基于服务器的身份认证-的区别"><a class="markdownIt-Anchor" href="#基于token的身份认证-与-基于服务器的身份认证-的区别"></a> 基于Token的身份认证 与 基于服务器的身份认证 的区别:</h2><p>基于服务器的身份认证方式存在一些问题：</p><ul><li>Sessions : 每次用户认证通过以后，服务器需要创建一条记录保存用户信息，通常是在内存中，随着认证通过的用户越来越多，服务器的在这里的开销就会越来越大。</li><li>Scalability : 由于Session是在内存中的，这就带来一些扩展性的问题。</li><li>CORS : 当我们想要扩展我们的应用，让我们的数据被多个移动设备使用时，我们必须考虑跨资源共享问题。当使用AJAX调用从另一个域名下获取资源时，我们可能会遇到禁止请求的问题。</li><li>CSRF : 用户很容易受到CSRF攻击。</li></ul><p><strong>JWT与Session的差异</strong></p><ul><li>它们都是存储用户信息；然而，Session是在服务器端的，客户端只有session id，而JWT是在客户端的。<ul><li>Session方式存储用户信息的最大问题在于要占用大量服务器内存，增加服务器的开销。而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。</li></ul></li><li>基于Token的身份认证是无状态的，服务器或者Session中不会存储任何用户信息，即没有会话的概念</li></ul><p><strong>用Token的好处</strong></p><ul><li>无状态和可扩展性：Tokens存储在客户端。完全无状态，可扩展。我们的负载均衡器可以将用户传递到任意服务器，因为在任何地方都没有状态或会话信息。</li><li>安全：Token不是Cookie。（The token, not a cookie.）每次请求的时候Token都会被发送。而且，由于没有Cookie被发送，还有助于防止CSRF攻击。即使在你的实现中将token存储到客户端的Cookie中，这个Cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话!</li><li>还有一点，token在一段时间以后会过期，这个时候用户需要重新登录。这有助于我们保持安全。还有一个概念叫token撤销，它允许我们根据相同的授权许可使特定的token甚至一组token无效。</li></ul><p><strong>JWT与OAuth的区别</strong></p><ul><li>OAuth2是一种授权框架 ，JWT是一种认证协议 -无论使用哪种方式切记用HTTPS来保证数据的安全性</li><li>OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)，而JWT是用在前后端分离, 需要简单的对后台API进行保护时使用。</li></ul><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><ul><li>因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。</li><li>因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。</li><li>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。</li><li>它不需要在服务端保存会话信息, 所以它易于应用的扩展</li></ul><hr><p>from：<a href="https://zhuanlan.zhihu.com/p/86937325" target="_blank" rel="noopener">五分钟带你了解啥是JWT</a></p><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="几种常用的认证机制"><a class="markdownIt-Anchor" href="#几种常用的认证机制"></a> 几种常用的认证机制</h2><h3 id="http-basic-auth"><a class="markdownIt-Anchor" href="#http-basic-auth"></a> HTTP Basic Auth</h3><p>HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth</p><h3 id="oauth"><a class="markdownIt-Anchor" href="#oauth"></a> OAuth</h3><p>OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</p><p>这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用；</p><h3 id="cookie-auth"><a class="markdownIt-Anchor" href="#cookie-auth"></a> Cookie Auth</h3><p>Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效；</p><h3 id="token-auth"><a class="markdownIt-Anchor" href="#token-auth"></a> Token Auth</h3><p>Token机制相对于Cookie机制又有什么好处呢？</p><ul><li><strong>支持跨域访问</strong>: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.</li><li><strong>无状态(也称：服务端可扩展行)</strong>:Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</li><li><strong>更适用CDN</strong>: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.</li><li><strong>去耦</strong>: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</li><li><strong>更适用于移动应用</strong>: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，<u>Cookie是不被支持的</u>（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</li><li><strong>CSRF</strong>:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。</li><li><strong>性能</strong>: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多.</li><li><strong>不需要为登录页面做特殊处理</strong>: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.</li><li><strong>基于标准化</strong>:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</li></ul><img src="https://i.loli.net/2021/08/18/m5zEhtXnRAp78yB.png" style="zoom:50%;"><h3 id="json-webtoken-auth"><a class="markdownIt-Anchor" href="#json-webtoken-auth"></a> JSON WebToken Auth</h3><h2 id="使用java库来生成jwt"><a class="markdownIt-Anchor" href="#使用java库来生成jwt"></a> 使用java库来生成JWT</h2><h2 id="jjwt"><a class="markdownIt-Anchor" href="#jjwt"></a> JJWT</h2><h3 id="加密生成jwt"><a class="markdownIt-Anchor" href="#加密生成jwt"></a> 加密生成JWT</h3><p><img src="https://i.loli.net/2021/08/18/4JOiPv38VnYtxle.png" alt=""></p><h3 id="解密jwt"><a class="markdownIt-Anchor" href="#解密jwt"></a> 解密JWT</h3><p><img src="https://i.loli.net/2021/08/18/YnHBPeQo7MFU6xI.png" alt=""></p><h2 id="java-jwt"><a class="markdownIt-Anchor" href="#java-jwt"></a> JAVA JWT</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过期时间5分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_TIME = <span class="number">5</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验token是否正确</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secret 用户的密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否正确</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String token, String username, String secret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(secret);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm)</span><br><span class="line">                    .withClaim(<span class="string">"username"</span>, username)</span><br><span class="line">                    .build();</span><br><span class="line">            DecodedJWT jwt = verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得token中的信息无需secret解密也能获得</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token中包含的用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUsername</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">            <span class="keyword">return</span> jwt.getClaim(<span class="string">"username"</span>).asString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTDecodeException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名,5min后过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secret 用户的密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sign</span><span class="params">(String username, String secret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Date date = <span class="keyword">new</span> Date(System.currentTimeMillis()+EXPIRE_TIME);</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(secret);</span><br><span class="line">            <span class="comment">// 附带username信息</span></span><br><span class="line">            <span class="keyword">return</span> JWT.create()</span><br><span class="line">                    .withClaim(<span class="string">"username"</span>, username)</span><br><span class="line">                    .withExpiresAt(date)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jwt-json-web-token&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jwt-json-web-token&quot;&gt;&lt;/a&gt; JWT: Json Web Token&lt;/h1&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;与普通T
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Shiro使用学习</title>
    <link href="https://nymrli.top/2021/08/11/Shiro%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://nymrli.top/2021/08/11/Shiro使用学习/</id>
    <published>2021-08-11T07:39:08.000Z</published>
    <updated>2021-09-07T10:18:38.073Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Shiro 是一个强大易用的 <a href="https://www.w3cschool.cn/java/" target="_blank" rel="noopener">Java</a> 安全框架，提供了<strong>认证</strong>、授权、<strong>加密</strong>和会话管理等功能（如下图），对于任何一个应用程序，Shiro 都可以提供全面的安全管理服务。并且相对于其他安全框架，Shiro 要简单的多。</p><p><img src="https://atts.w3cschool.cn/attachments/image/wk/shiro/1.png" alt=""></p><h2 id="shiro-的架构"><a class="markdownIt-Anchor" href="#shiro-的架构"></a> Shiro 的架构</h2><blockquote><p>从外部来看应该具有非常简单易于使用的 API，且 API 契约明确；从内部来看的话，其应该有一个可扩展的架构，即非常容易插入用户自定义实现，</p></blockquote><p>交互流程如下：</p><p><img src="https://atts.w3cschool.cn/attachments/image/wk/shiro/2.png" alt=""></p><p>应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject。</p><p><strong>Subject</strong>：主体，代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；</p><p><strong>SecurityManager</strong>：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</p><p><strong>Realm</strong>：域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</p><p>★也就是说对于我们而言，最简单的一个 Shiro 应用：</p><ol><li>应用代码通过 Subject 来进行认证和授权，而 Subject 又委托给 SecurityManager；</li><li><strong>我们需要</strong>给 Shiro 的 SecurityManager <strong>注入 Realm</strong>，从而让 SecurityManager 能得到合法的用户及其权限进行判断。</li></ol><p>具体的架构设计与组件：</p><p><img src="https://atts.w3cschool.cn/attachments/image/wk/shiro/3.png" alt=""></p><ul><li><strong>Subject</strong>：主体，可以看到主体可以是任何可以与应用交互的 “用户”；</li><li><strong>SecurityManager</strong>：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；<u>所有具体的交互都通过 SecurityManager 进行控制</u>；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。</li><li><strong>Authenticator</strong>：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</li><li><strong>Authorizer</strong>：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</li><li><strong>Realm</strong>：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm；</li></ul><h2 id="realm"><a class="markdownIt-Anchor" href="#realm"></a> Realm</h2><p>Realm：域，<code>Shiro</code> 从 <code>Realm</code>获取安全数据（如用户、角色、权限），就是说 <code>SecurityManager</code> 要验证用户身份，那么它需要从 <code>Realm</code> 获取相应的用户进行比较以确定用户身份是否合法；也需要从 <code>Realm</code> 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 <code>Realm</code> 看成 <code>DataSource</code>，即安全数据源。</p><h2 id="身份验证"><a class="markdownIt-Anchor" href="#身份验证"></a> 身份验证</h2><blockquote><p>身份验证和授权是Shiro两个主要的功能。</p></blockquote><p><strong>身份验证</strong>，即在应用中谁能证明他就是他本人。一般提供如他们的身份 ID 一些标识信息来表明他就是他本人，如提供身份证，用户名 / 密码来证明。</p><p>在 shiro 中，用户需要提供 <code>principals</code> （身份）和 <code>credentials</code>（证明）给 shiro，从而应用能验证用户身份：</p><p><strong>principals</strong>：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 <code>principals</code>，但只有一个 <code>Primary principals</code>，一般是用户名 / 密码 / 手机号。</p><p><strong>credentials</strong>：证明 / 凭证，即只有主体知道的安全值，如密码 / 数字证书等。</p><h3 id="身份认证流程"><a class="markdownIt-Anchor" href="#身份认证流程"></a> 身份认证流程</h3><p><img src="https://atts.w3cschool.cn/attachments/image/wk/shiro/4.png" alt=""></p><p>流程如下：</p><ol><li>首先调用 <code>Subject.login(token)</code> 进行登录，其会自动委托给 <code>Security Manager</code>，调用之前必须通过 <code>SecurityUtils.setSecurityManager()</code> 设置；</li><li><code>SecurityManager</code> 负责真正的身份验证逻辑；它会委托给 <code>Authenticator</code> 进行身份验证；</li><li><code>Authenticator</code> 才是真正的身份验证者，<code>Shiro API</code> 中核心的身份认证入口点，此处可以自定义插入自己的实现；</li><li><code>Authenticator</code> 可能会委托给相应的 <code>AuthenticationStrategy</code> 进行多 <code>Realm</code> 身份验证，默认 <code>ModularRealmAuthenticator</code> 会调用 <code>AuthenticationStrategy</code> 进行多 <code>Realm</code> 身份验证；</li><li><code>Authenticator</code>会把相应的 <code>token</code> 传入 <code>Realm</code>，从 <code>Realm</code> 获取身份验证信息，如果没有返回 / 抛出异常表示身份验证成功了。此处可以配置多个 <code>Realm</code>，将按照相应的顺序及策略进行访问。</li></ol><h2 id="授权"><a class="markdownIt-Anchor" href="#授权"></a> 授权</h2><p>from：</p><ul><li><a href="https://www.w3cschool.cn/shiro/co4m1if2.html" target="_blank" rel="noopener">w3cschool Shiro教程文档</a></li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="官方十分钟教程"><a class="markdownIt-Anchor" href="#官方十分钟教程"></a> <a href="http://shiro.apache.org/10-minute-tutorial.html" target="_blank" rel="noopener">官方十分钟教程</a>-独立程序篇</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.6.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quickstart.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quickstart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger log = LoggerFactory.getLogger(Quickstart.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The easiest way to create a Shiro SecurityManager with configured</span></span><br><span class="line">        <span class="comment">// realms, users, roles and permissions is to use the simple INI config.</span></span><br><span class="line">        <span class="comment">// We'll do that by using a factory that can ingest a .ini file and</span></span><br><span class="line">        <span class="comment">// return a SecurityManager instance:</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这是最简单的方法通过配置去创建一个Shiro SecurityManager。</span></span><br><span class="line"><span class="comment">         * realms， users， roles 和 permissions都是通过这个简单的ini文件配置的</span></span><br><span class="line"><span class="comment">         * 我们通过使用工厂方式读取配置文件并获取一个SecurityManager实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Use the shiro.ini file at the root of the classpath</span></span><br><span class="line">        <span class="comment">// 使用classpaht根目录的shiro.ini文件</span></span><br><span class="line">        <span class="comment">// (file: and url: prefixes load from files and urls respectively):</span></span><br><span class="line">        <span class="comment">// file: 和url: 这两个前缀分别从files和urls加载的</span></span><br><span class="line">        IniSecurityManagerFactory factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">"classpath:shiro.ini"</span>);</span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for this simple example quickstart, make the SecurityManager</span></span><br><span class="line">        <span class="comment">// accessible as a JVM singleton.  Most applications wouldn't do this</span></span><br><span class="line">        <span class="comment">// and instead rely on their container configuration or web.xml for</span></span><br><span class="line">        <span class="comment">// webapps.  That is outside the scope of this simple quickstart, so</span></span><br><span class="line">        <span class="comment">// we'll just do the bare minimum so you can continue to get a feel</span></span><br><span class="line">        <span class="comment">// for things.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * quickstart这个例子中，使用的SecurityManager是JVM单例的。许多应用程序不这样做。</span></span><br><span class="line"><span class="comment">         * 比如要配置web.xml等。但是不在quickstart范围内。</span></span><br><span class="line"><span class="comment">         * 我们只是最小限度的让你明白你在做什么。。。。。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now that a simple Shiro environment is set up, let's see what you can do:</span></span><br><span class="line">        <span class="comment">// 现在一个简单的Shiro环境就已经设置好了</span></span><br><span class="line">        <span class="comment">// get the currently executing user:</span></span><br><span class="line">        <span class="comment">// 获取当前执行的用户</span></span><br><span class="line">        Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do some stuff with a Session (no need for a web or EJB container!!!)</span></span><br><span class="line">        <span class="comment">// 用session做一些事，不需要web或者EJB容器就能使用session</span></span><br><span class="line">        Session session = currentUser.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">"someKey"</span>, <span class="string">"aValue"</span>);</span><br><span class="line">        String value = (String) session.getAttribute(<span class="string">"someKey"</span>);</span><br><span class="line">        <span class="keyword">if</span> (value.equals(<span class="string">"aValue"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"Retrieved the correct value! ["</span> + value + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// let's login the current user so we can check against roles and permissions:</span></span><br><span class="line">        <span class="comment">// 用当前用户登录，检查角色和权限</span></span><br><span class="line">        <span class="keyword">if</span> (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">            <span class="comment">// 设置当前用户的信息</span></span><br><span class="line"><span class="comment">//            UsernamePasswordToken token = new UsernamePasswordToken("presidentskroob", "vespa");</span></span><br><span class="line">            UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"presidentskroob"</span>, <span class="string">"12345"</span>);</span><br><span class="line">            <span class="comment">// rememberMe功能</span></span><br><span class="line">            token.setRememberMe(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 登录</span></span><br><span class="line">                currentUser.login(token);</span><br><span class="line">                <span class="comment">// 登录失败的一些异常捕获</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownAccountException uae) &#123;</span><br><span class="line">                log.info(<span class="string">"There is no user with username of "</span> + token.getPrincipal());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IncorrectCredentialsException ice) &#123;</span><br><span class="line">                log.info(<span class="string">"Password for account "</span> + token.getPrincipal() + <span class="string">" was incorrect!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LockedAccountException lae) &#123;</span><br><span class="line">                log.info(<span class="string">"The account for username "</span> + token.getPrincipal() + <span class="string">" is locked.  "</span> +</span><br><span class="line">                        <span class="string">"Please contact your administrator to unlock it."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... catch more exceptions here (maybe custom ones specific to your application?</span></span><br><span class="line">            <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">                <span class="comment">//unexpected condition?  error?</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//say who they are:</span></span><br><span class="line">        <span class="comment">//print their identifying principal (in this case, a username):</span></span><br><span class="line">        <span class="comment">// 获取当事人。。 这个例子就是username</span></span><br><span class="line">        log.info(<span class="string">"User ["</span> + currentUser.getPrincipal() + <span class="string">"] logged in successfully."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//test a role:</span></span><br><span class="line">        <span class="comment">// 测试角色</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.hasRole(<span class="string">"schwartz"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"May the Schwartz be with you!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"Hello, mere mortal."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//test a typed permission (not instance-level)</span></span><br><span class="line">        <span class="comment">// 测试权限，不是实例级别</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.isPermitted(<span class="string">"lightsaber:wield"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"You may use a lightsaber ring.  Use it wisely."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"Sorry, lightsaber rings are for schwartz masters only."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//a (very powerful) Instance Level permission:</span></span><br><span class="line">        <span class="comment">// 实例级别</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.isPermitted(<span class="string">"winnebago:drive:eagle5"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'.  "</span> +</span><br><span class="line">                    <span class="string">"Here are the keys - have fun!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"Sorry, you aren't allowed to drive the 'eagle5' winnebago!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//all done - log out!</span></span><br><span class="line">        <span class="comment">// 退出</span></span><br><span class="line">        currentUser.logout();</span><br><span class="line"></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件 <code>shiro.ini</code>编写</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Users and their (optional) assigned roles</span></span><br><span class="line"><span class="comment"># username = password, role1, role2, ..., roleN</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">root</span> = secret, admin</span><br><span class="line"><span class="attr">guest</span> = guest, guest</span><br><span class="line"><span class="attr">presidentskroob</span> = <span class="number">12345</span>, president</span><br><span class="line"><span class="attr">darkhelmet</span> = ludicrousspeed, darklord, schwartz</span><br><span class="line"><span class="attr">aihe</span> = aihe, goodguy, client</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Roles with assigned permissions</span></span><br><span class="line"><span class="comment"># roleName = perm1, perm2, ..., permN</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="attr">admin</span> = *</span><br><span class="line"><span class="attr">client</span> = look:*</span><br><span class="line"><span class="attr">goodguy</span> = winnebago:drive:eagle5</span><br></pre></td></tr></table></figure><h2 id="springboot集成shrio"><a class="markdownIt-Anchor" href="#springboot集成shrio"></a> springboot集成shrio</h2><ol><li>定义自定的Realm： 重写supports、doGetAuthorizationInfo(AuthenticationToken auth)-&gt;AuthenticatingRealm【默认使用此方法进行用户名正确与否验证】、doGetAuthorizationInfo(PrincipalCollection principals) -&gt;AuthorizingRealm 【检测用户权限的时候调用】 ： 返回值都为AuthorizationInfo</li><li>自定义Shrio过滤器集： <code>preHandle</code> -&gt; <code>isAccessAllowed</code> -&gt; <code>executeLogin</code> -&gt;</li><li>配置ShiroConfiguration： 创建DefaultWebSecurityManager、ShiroFilterFactoryBean这两个类型的Bean</li><li>（可选）：定义自己的AuthenticationToken， 如JWTToken</li><li>在相应的接口上控制权限：注解声明式：@RequiresAuthentication、@RequiresRoles(“admin”)、@RequiresPermissions(logical = Logical.AND, value = {“view”, “edit”})、或者代码编程式：<code>Subject subject = SecurityUtils.getSubject(); if (subject.isAuthenticated())</code></li></ol><p>认证执行过程如下：</p><p><code>executeLogin</code>函数中的<code>getSubject(request, response).login(token);</code>会调用<code>this.securityManager.login(this, token);</code>从而触发认证器管理器AuthenticatingSecurityManager找到认证器ModularRealmAuthenticator执行<code>this.authenticator.authenticate(token);</code>从而调度注册<code>this.doSingleRealmAuthentication((Realm)realms.iterator().next(), authenticationToken)</code>的Realm去完成认证工作：先判断当前realm是否支持解析当前出传入的AuthenticationToken，符合则调用<code>AuthenticationInfo info = realm.getAuthenticationInfo(token);</code>进行校验 -&gt;(AuthenticatingRealm：我们Realm继承的类) 从而调用了我们自定义重写的doGetAuthenticationInfo(AuthenticationToken auth)方法<code>info = this.doGetAuthenticationInfo(token);</code></p><p><img src="/2021/08/11/Shiro使用学习/C:%5CUsers%5Cmrli%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210818165636848.png" alt="image-20210818165636848"></p><h2 id="如何使用jwt做校验的流程"><a class="markdownIt-Anchor" href="#如何使用jwt做校验的流程"></a> 如何使用JWT做校验的流程：</h2><ul><li>在LoginController中如果用户登陆成功则返回JWT信息。</li><li>用户访问被Shrio过滤器注册的URL，则通过过滤器中执行的preHandler（设置请求头）-&gt;onHandler中会执行isAccessAllowed（规定如何通行）从而调用真正的认证判定函数<code>executeLogin</code>其中会调用Realm来进行login的判断（如果没有异常则表示通过）</li></ul><p>详细的代码实践教程： <a href="https://github.com/Smith-Cruise/Spring-Boot-Shiro" target="_blank" rel="noopener">https://github.com/Smith-Cruise/Spring-Boot-Shiro</a></p><ul><li><a href="https://github.com/echisan/springboot-jwt-demo" target="_blank" rel="noopener">https://github.com/echisan/springboot-jwt-demo</a> ——SpringSecurity demo</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Apache Shiro 是一个强大易用的 &lt;a href=&quot;https://www.w3cschool.cn/java/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java&lt;/a&gt; 安全框架，提供了&lt;strong&gt;认证&lt;/strong&gt;、授权、&lt;st
      
    
    </summary>
    
    
      <category term="Java" scheme="https://nymrli.top/tags/Java/"/>
    
      <category term="应用框架学习" scheme="https://nymrli.top/tags/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Go的配置和使用</title>
    <link href="https://nymrli.top/2021/07/27/Go%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://nymrli.top/2021/07/27/Go的配置和使用/</id>
    <published>2021-07-27T03:10:11.000Z</published>
    <updated>2021-10-22T13:53:41.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语法学习"><a href="#Go语法学习" class="headerlink" title="Go语法学习"></a>Go语法学习</h2><blockquote><p>Go 语言被设计成一门应用于搭载 <strong>Web 服务器</strong>，<strong>存储集群</strong>或类似用途的巨型中央服务器的系统编程语言。</p><p>对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量<strong>并行</strong>的支持，这对于游戏服务端的开发而言是再好不过了。</p></blockquote><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><blockquote><p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。</p></blockquote><p>声明变量的一般形式是使用 var 关键字：</p><ul><li>第一种，指定变量类型，如果没有初始化，则变量默认为零值: <code>var identifier1, identifier2 type</code>==&gt;bool零值为false，int为0</li><li>第二种，根据值自行判定变量类型: <code>var v_name = value</code>, <code>var flag = true</code></li><li>使用<code>:=</code>,  := 是一个声明语句 —&gt; <strong>intVal := 1</strong> 相等于：<code>var intVal int</code>和<code>intVal =1</code></li></ul><p>注：<strong>如果变量已经使用 var 声明过了，再使用 \</strong>:=*<em> 声明变量，就产生编译错误*</em></p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>func：函数由 func 开始声明</li><li>function_name：函数名称，参数列表和返回值类型构成了函数签名。</li><li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li><li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li><li>函数体：函数定义的代码集合。</li></ul><p>注：Go的函数跟python一样能够返回多个返回值</p><h3 id="Go-语言接口"><a href="#Go-语言接口" class="headerlink" title="Go 语言接口"></a>Go 语言接口</h3><blockquote><p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，<strong>任何其他类型只要实现了这些方法就是实现了这个接口</strong>(并不需要指定实现的是哪个接口的方法)。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_name1</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_namen</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li><p>Go语言中不允许有没有使用的变量（函数可以）</p></li><li><p>if和for后面必须有大括号，即使只有一句也得有大括号</p></li><li><p>slice即切片，也是一种<strong>数据结构</strong>，它是数组的抽象， 通过<code>var identifier []type</code>声明或者<code>slice1 := make([]type, len)</code>创建，如<strong><code>s :=[] int {1,2,3 }</code></strong></p><ul><li>区分于数组：<code>var balance [10] float32</code>、<code>var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}</code>、<code>balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}</code>、<strong><code>balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}</code></strong></li></ul></li><li><p>map使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">/*创建集合 */</span></span><br><span class="line">countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>go build</code>和<code>go install</code>区别</p><ul><li>go build 不能生成包文件, go install 可以生成包文件</li><li>go build 生成可执行文件在当前目录下； go install 生成可执行文件在bin目录下（<code>$GOPATH/bin</code>），如果环境变量指定了GOPATH，则可直接在cmd里输入文件，如<code>go install mycode.go</code>， 则编译好后可以直接在cmd里输入<code>mycode -fpath=..</code>, (fpath为flag要读取的参数)<ul><li>区别大致与<code>mvn package</code>和<code>mvn install</code>相同，都会把工程打包成jar文件，但package的位置在root/target下面,install会安装到mvn库下</li></ul></li></ul></li></ul><h2 id="切片与数组"><a href="#切片与数组" class="headerlink" title="切片与数组"></a>切片与数组</h2><p>定义</p><ul><li>数组是类型相同的元素的集合。例如，整数 5, 8, 9, 79, 76 的集合就构成了一个数组。Go不允许在数组中混合使用不同类型的元素（比如整数和字符串）。</li><li>切片（slice）是<u>建立在数组之上</u>的更方便，更灵活，更强大的数据结构。切片并不存储任何元素而只是<strong>对现有数组的引用</strong>。</li></ul><p>声明：</p><ul><li><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type<span class="comment">// 声明了一个长度为 3 的整型数组。数组中的所有元素都被自动赋值为元素类型的 0 值</span></span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">78</span>, <span class="number">50</span>&#125; <span class="comment">// shorthand declaration(速记声明) to create array</span></span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">12</span>&#125; <span class="comment">//声明了一个长度为 3 的数组，但是只提供了一个初值 12。剩下的两个元素被自动赋值为 0</span></span><br><span class="line"> a := [...]<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">78</span>, <span class="number">50</span>&#125; <span class="comment">// ... makes the compiler determine the length自动推导</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">int</span> = a[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//  创建了一个从 a[1] 到 a[3] 的切片</span></span><br><span class="line"></span><br><span class="line">c := []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125; <span class="comment">// 创建了一个长度为 3 的 int 数组，并返回一个切片给 c。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置函数 func make([]T, len, cap) []T 可以用来创建切片，该函数接受长度和容量作参数，返回切片。容量是可选的，默认与长度相同。使用 make 函数将会创建一个数组并返回它的切片。</span></span><br><span class="line">i := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)<span class="comment">// 用 make 创建的长度和容量为5的数组并返回其切片，元素值默认为 0 值</span></span><br></pre></td></tr></table></figure></li><li><p>元素类型为 <code>T</code> 的切片表示为： <code>[]T</code>。</p></li></ul><p>注：</p><ul><li><strong>数组是值类型</strong>：<ul><li>在 Go 中数组是值类型而不是引用类型。这意味着当数组变量被赋值时，将会获得原数组（<em>译者注：也就是等号右面的数组</em>）的拷贝。新数组中元素的改变不会影响原数组中元素的值。</li><li>如果将数组作为参数传递给函数，仍然是值传递，在函数中对（作为参数传入的）数组的修改不会造成原数组的改变</li></ul></li><li>切片本身不包含任何数据。它仅仅是底层数组的一个上层表示。对切片进行的任何修改都将反映在底层数组中。</li><li>想修改数组内容的时候，函数中传递数组的切片：当将一个切片作为参数传递给一个函数时，虽然是值传递，但是指针始终指向同一个数组。因此将切片作为参数传给函数时，函数对该切片的修改在函数外部也可以看到。</li></ul><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><blockquote><p>golang 分配内存主要有内置函数new和make，make只能为slice, map, channel分配内存，并返回一个初始化的值。</p></blockquote><p>首先来看下make有以下几种不同的用法：</p><ol><li><p>make(map[string]string)</p><p>缺少长度的参数，只传类型，这种用法只能用在类型为map或chan的场景，例如make([]int)是会报错的。这样返回的空间长度都是默认为0的。</p></li><li><p>make([]int, 2)</p><p>指定了长度，例如make([]int, 2)返回的是一个长度为2的slice</p></li><li><p>make([]int, 2, 4)</p><p>第二参数指定的是切片的长度，第三个参数是用来指定预留的空间长度，例如a := make([]int, 2, 4), 这里值得注意的是返回的切片a的总长度是4，预留的意思并不是另外多出来4的长度，其实是包含了前面2个已经切片的个数的。所以举个例子当你这样用的时候 a := make([]int, 4, 2)，就会报语法错误。(当我们为slice分配内存的时候，应当尽量预估到slice可能的最大长度，通过给make传第三个参数的方式来给slice预留好内存空间，这样可以避免二次分配内存带来的开销，大大提高程序的性能。)</p></li><li><p>通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)                 <span class="comment">// 创建一个整型类型的通道</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)         <span class="comment">// 创建一个空接口类型的通道, 可以存放任意格式</span></span><br><span class="line"><span class="keyword">type</span> Equip <span class="keyword">struct</span>&#123; <span class="comment">/* 一些字段 */</span> &#125;</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> *Equip)             <span class="comment">// 创建Equip指针类型的通道, 可以存放*Equip</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> &lt;- <span class="keyword">int</span>, <span class="number">2</span>)<span class="comment">// 创建一个只接收的通道，且缓冲大小为2</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Vscode中配置Go"><a href="#Vscode中配置Go" class="headerlink" title="Vscode中配置Go"></a>Vscode中配置Go</h2><h3 id="1-首先安装好Go"><a href="#1-首先安装好Go" class="headerlink" title="1.首先安装好Go"></a>1.首先<a href="https://gomirrors.org/" target="_blank" rel="noopener">安装好Go</a></h3><h3 id="2-vscode中下载Go环境插件"><a href="#2-vscode中下载Go环境插件" class="headerlink" title="2.vscode中下载Go环境插件"></a>2.vscode中下载Go环境插件</h3><p><img src="https://i.loli.net/2021/07/27/K8MeLk2fh7O5wAR.png" alt=""></p><h3 id="3-安装Go程序插件"><a href="#3-安装Go程序插件" class="headerlink" title="3.安装Go程序插件"></a>3.安装Go程序插件</h3><blockquote><p>Go语言开发的时候为我们提供诸如代码提示、代码自动补全等功能。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开输入框</span></span><br><span class="line">ctrl + shift + p </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入</span></span><br><span class="line">Go:Install/Update Tools</span><br></pre></td></tr></table></figure><p>▲由于网络问题会无法安装插件，网上老版的方法是在Go目录下从github手动下载好文件，但亲测无效，转而采用新方法如下。</p><h4 id="先设置GOPROXY"><a href="#先设置GOPROXY" class="headerlink" title="先设置GOPROXY"></a>先设置<code>GOPROXY</code></h4><ul><li>打开终端执行以下命令：<code>go env -w GOPROXY=https://goproxy.cn,direct</code></li><li>环境配置中按照<a href="https://goproxy.io/zh/中写的配置Goproxy" target="_blank" rel="noopener">https://goproxy.io/zh/中写的配置Goproxy</a></li></ul><h4 id="重试下载插件"><a href="#重试下载插件" class="headerlink" title="重试下载插件"></a>重试下载插件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开输入框</span></span><br><span class="line">ctrl + shift + p </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入</span></span><br><span class="line">Go:Install/Update Tools</span><br></pre></td></tr></table></figure><h4 id="设置插件配置"><a href="#设置插件配置" class="headerlink" title="设置插件配置"></a>设置插件配置</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"go.goroot": "",</span><br><span class="line">"go.gopath": "",</span><br><span class="line">"go.inferGopath": true,</span><br><span class="line">"go.autocompleteUnimportedPackages": true,</span><br><span class="line">"go.gocodePackageLookupMode": "go",</span><br><span class="line">"go.gotoSymbol.includeImports": true,</span><br><span class="line">"go.useCodeSnippetsOnFunctionSuggest": true,</span><br><span class="line">"go.useCodeSnippetsOnFunctionSuggestWithoutType": true,</span><br><span class="line">"go.docsTool": "gogetdoc",</span><br></pre></td></tr></table></figure><h3 id="配置Go代码片段快捷键"><a href="#配置Go代码片段快捷键" class="headerlink" title="配置Go代码片段快捷键"></a>配置Go代码片段快捷键</h3><p>还是按<code>Ctrl/Command+Shift+P</code>,按下图输入<code>&gt;snippets</code>，选择回车，然后在弹出的窗口点击选择<code>go</code>选项：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"println"</span>:&#123;</span><br><span class="line"><span class="attr">"prefix"</span>: <span class="string">"pln"</span>,</span><br><span class="line"><span class="attr">"body"</span>:<span class="string">"fmt.Println($0)"</span>,</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"println"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"printf"</span>:&#123;</span><br><span class="line"><span class="attr">"prefix"</span>: <span class="string">"plf"</span>,</span><br><span class="line"><span class="attr">"body"</span>: <span class="string">"fmt.Printf(\"$0\")"</span>,</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"printf"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"m"</span>:&#123;</span><br><span class="line"><span class="attr">"prefix"</span>: <span class="string">"main"</span>,</span><br><span class="line"><span class="attr">"body"</span>: [</span><br><span class="line"><span class="string">"package main"</span>,</span><br><span class="line"><span class="string">"import (\"fmt\")"</span>,</span><br><span class="line"><span class="string">"func main() &#123;"</span>,</span><br><span class="line"><span class="string">"$0"</span>,</span><br><span class="line"><span class="string">"&#125;"</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"main"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VScode配置终端"><a href="#VScode配置终端" class="headerlink" title="VScode配置终端"></a>VScode配置终端</h2><p>在settings.json中设置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 终端设置为cmder</span><br><span class="line">"terminal.integrated.shell.windows": "cmd.exe",</span><br><span class="line">"terminal.integrated.env.windows": &#123;"CMDER_ROOT": "E:\\cmder"&#125;,</span><br><span class="line">"terminal.integrated.shellArgs.windows": ["/k", "E:\\cmder\\vendor\\init.bat"],</span><br></pre></td></tr></table></figure><p>from : <a href="https://www.jianshu.com/p/c3b162df3b57" target="_blank" rel="noopener">https://www.jianshu.com/p/c3b162df3b57</a></p><h2 id="go-module模块管理"><a href="#go-module模块管理" class="headerlink" title="go module模块管理"></a>go module模块管理</h2><p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从<code>Go1.13</code>版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。到今天<code>Go1.14</code>版本推出之后<code>Go modules</code> 功能已经被正式推荐在生产环境下使用了。</p><p>一共两种情况</p><ul><li><p>在同一个模块下</p><ul><li>各个go文件根据go.mod下定义的模块名导入即可</li></ul></li><li><p>不在同一个模块下</p><ul><li>将无法找到的绝对引用路径在mod中进行require重定向</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── p1</span><br><span class="line">│   ├── <span class="keyword">go</span>.mod</span><br><span class="line">│   └── main.<span class="keyword">go</span></span><br><span class="line">└── p2</span><br><span class="line">    ├── <span class="keyword">go</span>.mod</span><br><span class="line">    └── p2.<span class="keyword">go</span></span><br><span class="line"><span class="comment">// p2/go.mod</span></span><br><span class="line">module liwenzhou.com/q1mi/p2</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p1/main.go按如下方式导入p2内容</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"liwenzhou.com/q1mi/p2"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p2.New()</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>p1/main.go</code>中想要导入<code>p2.go</code>中定义的函数。需要在<code>moduledemo/go.mod</code>中进行<code>replace</code>设置才能在moduledemo模块中使用mypackage的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p1/go.mod</span></span><br><span class="line">module github.com/q1mi/p1<span class="comment">// 当前模块名</span></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span><span class="comment">// go版本</span></span><br><span class="line">require <span class="string">"liwenzhou.com/q1mi/p2"</span> v0<span class="number">.0</span><span class="number">.0</span><span class="comment">// 指定版本</span></span><br><span class="line">replace <span class="string">"liwenzhou.com/q1mi/p2"</span> =&gt; <span class="string">"../p2"</span><span class="comment">// 重定向模块路径，右边为文件的相对路径</span></span><br></pre></td></tr></table></figure></li></ul><p><a href="https://www.liwenzhou.com/posts/Go/import_local_package_in_go_module/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/import_local_package_in_go_module/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语法学习&quot;&gt;&lt;a href=&quot;#Go语法学习&quot; class=&quot;headerlink&quot; title=&quot;Go语法学习&quot;&gt;&lt;/a&gt;Go语法学习&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Go 语言被设计成一门应用于搭载 &lt;strong&gt;Web 服务器&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Go" scheme="https://nymrli.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Chrome插件编写-天猫秒杀插件</title>
    <link href="https://nymrli.top/2021/03/03/%E5%A4%A9%E7%8C%AB%E7%A7%92%E6%9D%80%E6%8F%92%E4%BB%B6-Chrome%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/"/>
    <id>https://nymrli.top/2021/03/03/天猫秒杀插件-Chrome插件编写/</id>
    <published>2021-03-03T13:37:15.000Z</published>
    <updated>2021-09-18T12:21:25.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chrome插件开发"><a class="markdownIt-Anchor" href="#chrome插件开发"></a> chrome插件开发</h1><blockquote><p>借鉴TODO-List：<a href="https://www.w3cschool.cn/kesyi/kesyi-m5uo24rx.html" target="_blank" rel="noopener">Chrome插件开发简要指南</a></p></blockquote><h2 id="文件结构"><a class="markdownIt-Anchor" href="#文件结构"></a> 文件结构</h2><p>在应用商店中下载下来的插件基本上都是以<code>.crx</code>为文件后缀，该文件其实就是一个压缩包（文件夹压缩而来），包括插件所需要的<strong>html</strong>、css、<strong>javascript</strong>、图片资源等等文件。</p><p>其中，</p><ul><li><code>manifest.json</code>是整个插件的功能及文件配置清单，非常重要。</li><li><code>static</code>目录是放置整个插件的静态资源文件的，包括css、js、图片等等资源</li><li><code>template</code>目录是放置整个插件的功能页面模板的。</li><li><code>_locales</code>目录是放置整个插件的国际化语言脚本的。</li></ul><p>一般来说，<strong>清单文件<code>manifest.json</code>文件是必须的</strong>，且必须放在插件开发目录的根目录上。其他的目录都可以自定义。</p><h2 id="弹出窗口和后台页面"><a class="markdownIt-Anchor" href="#弹出窗口和后台页面"></a> 弹出窗口和后台页面</h2><p>弹出窗口一般用于插件和用户的交互，而后台页面一般用于插件本身做一些额外的事情。比如有时候，插件需要联网进行数据同步等操作，这种操作用户是无感知的，所有就要求插件需要有一个后台页面来运行这部分的逻辑。</p><p>其实后台页面还可以分为持久运行的后端页面和事件页面，这里对这两者就不多做说明了，更多的内容可以参阅具体的文档。</p><h2 id="弹出式插件教程todo-list"><a class="markdownIt-Anchor" href="#弹出式插件教程todo-list"></a> 弹出式插件教程TODO-LIST</h2><h3 id="manifestjson"><a class="markdownIt-Anchor" href="#manifestjson"></a> manifest.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"todo-plugin"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.9.0"</span>,</span><br><span class="line">    <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"chrome plugin demo"</span>,</span><br><span class="line">    <span class="attr">"browser_action"</span>: &#123;</span><br><span class="line">        <span class="attr">"default_icon"</span>: <span class="string">"icon.png"</span>,</span><br><span class="line">        <span class="attr">"default_title"</span>: <span class="string">"Todo List"</span>,</span><br><span class="line">        <span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="popuphtml"><a class="markdownIt-Anchor" href="#popuphtml"></a> popup.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        width: 150px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#add-new-item</span> &#123;</span></span><br><span class="line"><span class="undefined">        cursor: pointer;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#CCC</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.hide</span> &#123;</span></span><br><span class="line"><span class="undefined">        display: none;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.show</span> &#123;</span></span><br><span class="line"><span class="undefined">        display: block;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="undefined">        cursor: pointer;</span></span><br><span class="line"><span class="undefined">        margin: 5px 0;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> <span class="selector-tag">input</span> &#123;</span></span><br><span class="line"><span class="undefined">        display: inline-block;</span></span><br><span class="line"><span class="undefined">        width: 12px;</span></span><br><span class="line"><span class="undefined">        height: 12px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    input &#123;</span></span><br><span class="line"><span class="undefined">        width: 120px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"add-new-item"</span>&gt;</span>添加新项<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"add-new-item-input"</span> <span class="attr">class</span>=<span class="string">"hide"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"new-item-title"</span> <span class="attr">placeholder</span>=<span class="string">"添加新任务"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"item-list"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mainjs"><a class="markdownIt-Anchor" href="#mainjs"></a> main.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> Tasks = &#123;</span><br><span class="line">        show: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            obj.className = <span class="string">''</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        hide: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            obj.className = <span class="string">'hide'</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        $addNewItem: $(<span class="string">'add-new-item'</span>),</span><br><span class="line">        $addNewItemInput: $(<span class="string">'add-new-item-input'</span>),</span><br><span class="line">        $itemList: $(<span class="string">'item-list'</span>),</span><br><span class="line">        $newItemTitle: $(<span class="string">'new-item-title'</span>),</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//打开添加文本框</span></span><br><span class="line">            Tasks.$addNewItem.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                Tasks.show(Tasks.$addNewItemInput).hide(Tasks.$addNewItem);</span><br><span class="line">                Tasks.$newItemTitle.focus();</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//回车添加任务</span></span><br><span class="line">            Tasks.$newItemTitle.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span><br><span class="line">                <span class="keyword">if</span> (ev.keyCode == <span class="number">13</span>) &#123;</span><br><span class="line">                    <span class="comment">//<span class="doctag">TODO:</span>写入本地数据</span></span><br><span class="line">                    <span class="keyword">var</span> task = Tasks.$newItemTitle.value;</span><br><span class="line">                    Tasks.AppendHtml(task);</span><br><span class="line">                    Tasks.$newItemTitle.value = <span class="string">''</span>;</span><br><span class="line">                    Tasks.hide(Tasks.$addNewItemInput).show(Tasks.$addNewItem);</span><br><span class="line">                &#125;</span><br><span class="line">                ev.preventDefault();</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//取消添加</span></span><br><span class="line">            Tasks.$newItemTitle.addEventListener(<span class="string">'blur'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                Tasks.$newItemTitle.value = <span class="string">''</span>;</span><br><span class="line">                Tasks.hide(Tasks.$addNewItemInput).show(Tasks.$addNewItem);</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//TODO 初始化数据，加载本地数据，生成html</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//增加</span></span><br><span class="line">        Add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        Edit: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        Del: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;,</span><br><span class="line">        AppendHtml: <span class="function"><span class="keyword">function</span> (<span class="params">title</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">            oDiv.className = <span class="string">'item item-todo'</span>;</span><br><span class="line">            <span class="keyword">var</span> oInput = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">            oInput.type = <span class="string">'checkbox'</span>;</span><br><span class="line">            <span class="keyword">var</span> oTitle = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">            oTitle.innerHTML = title;</span><br><span class="line">            oDiv.appendChild(oInput);</span><br><span class="line">            oDiv.appendChild(oTitle);</span><br><span class="line">            Tasks.$itemList.appendChild(oDiv);</span><br><span class="line">            oDiv.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">//TODO</span></span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        RemoveHtml: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Tasks.init();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h1 id="天猫秒杀插件-tmall_kill"><a class="markdownIt-Anchor" href="#天猫秒杀插件-tmall_kill"></a> 天猫秒杀插件 Tmall_Kill</h1><p>Code Template： <a href="https://link.zhihu.com/?target=https%3A//github.com/cehui0303/Tmall_Tickets" target="_blank" rel="noopener">https://link.zhihu.com/?target=https%3A//github.com/cehui0303/Tmall_Tickets</a></p><p>代码比较简单，实现原理为，打开浏览器后执行插件，JS脚本将会在指定时间点击“结算”按钮，然后发起订单，从而锁定库存抢货。</p><h3 id="mainjs-2"><a class="markdownIt-Anchor" href="#mainjs-2"></a> main.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkElementState</span>(<span class="params">path,callback</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.querySelector(path);</span><br><span class="line"><span class="keyword">if</span>(ele)&#123;</span><br><span class="line">callback &amp;&amp; callback();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'异步加载元素中....'</span> + path );</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;checkElementState(path,callback);&#125;,<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkOut</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'结算开始....'</span>);</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'J_Go'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(btn)&#123;</span><br><span class="line">btn.click();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'结算按钮没找到'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// S1: 1. 点击结算按钮  =&gt;  2. checkElementState()检测结算按钮是否加载出来 --&gt; 3.checkOut()点击结算按钮</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkOutAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">checkElementState(<span class="string">'#J_Go'</span>,checkOut);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// S2: 提交订单</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitOrder</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'提交订单开始....'</span>);</span><br><span class="line">checkElementState(<span class="string">'.go-btn'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">".go-btn"</span>);</span><br><span class="line"><span class="keyword">if</span>(btn)&#123;</span><br><span class="line">btn.click();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'提交订单按钮没找到'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标时间</span></span><br><span class="line"> <span class="keyword">var</span> dDate = <span class="keyword">new</span> <span class="built_in">Date</span>();  <span class="comment">//10点和20点开抢</span></span><br><span class="line"> <span class="keyword">if</span>( dDate.getHours() &lt; <span class="number">10</span> )&#123;</span><br><span class="line">  dDate.setHours(<span class="number">9</span>,<span class="number">59</span>,<span class="number">59.2</span>);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  dDate.setHours(<span class="number">19</span>,<span class="number">59</span>,<span class="number">59.2</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入时间判断循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enterTimeCheckLoop</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> diff = <span class="built_in">Date</span>.parse(dDate) - <span class="built_in">Date</span>.parse(date) ;</span><br><span class="line"><span class="built_in">console</span>.log(diff);</span><br><span class="line"><span class="keyword">if</span>(diff &lt; <span class="number">-90</span> )&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'时间过了！'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(diff &lt; <span class="number">50</span> ) &#123;</span><br><span class="line">callback &amp;&amp; callback();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'时间到了！！！'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; enterTimeCheckLoop(callback);&#125;,<span class="number">400</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//主要函数</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'############################天猫枪杀脚本############################'</span>);</span><br><span class="line"><span class="keyword">var</span> href = <span class="built_in">window</span>.location.href;</span><br><span class="line"><span class="comment">//结算页面</span></span><br><span class="line"><span class="keyword">if</span>(href.indexOf(<span class="string">'cart.tmall.com'</span>) &gt; <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="comment">//进入时间判断</span></span><br><span class="line">enterTimeCheckLoop( checkOutAsync );</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(href.indexOf(<span class="string">'buy.tmall.com'</span>) &gt; <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="comment">//提交订单页面</span></span><br><span class="line">submitOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>这种理论上是可行的，只不过肯定会有刷新上的问题，效率不及网络请求，但思路依旧是值得学习的，因此借此机会也是学下Chrome插件的编写。</p><h3 id="manifestjson-2"><a class="markdownIt-Anchor" href="#manifestjson-2"></a> manifest.json</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "manifest_version": 2,// manifest文件版本号。Chrome18开始必须为2</span><br><span class="line">  "name": "Tmall-tickets", // crx扩展名称</span><br><span class="line">  "version": "1.0",// 插件版本</span><br><span class="line">  "description": "天猫超市枪杀脚本",</span><br><span class="line">  "browser_action": &#123;// 地址栏右侧图标管理。含图标及弹出页面的设置等</span><br><span class="line">    "default_icon": "icon.png"</span><br><span class="line">  &#125;,</span><br><span class="line">  "content_scripts": [// 指定要向Web页面内注入的脚本。可注入多个css与js。</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"matches"</span>: [<span class="string">"https://chaoshi.detail.tmall.com/*"</span>,<span class="string">"https://cart.tmall.com/*"</span>,<span class="string">"https://buy.tmall.com/*"</span>],</span><br><span class="line">      <span class="attr">"js"</span>: [<span class="string">"maotai.js"</span>],</span><br><span class="line">  <span class="attr">"run_at"</span>: <span class="string">"document_idle"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">    "permissions": [</span><br><span class="line">       "https://www.baidu.com/*",</span><br><span class="line">       "background",</span><br><span class="line">       <span class="string">"tabs"</span></span><br><span class="line">    ], //权限</span><br><span class="line">    "plugins": [&#123;</span><br><span class="line">       "path": "extension_plugin.dll",</span><br><span class="line">       "public": true</span><br><span class="line">    &#125;], // 扩展。可调用第三方扩展</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>content_scripts</strong>，其数组元素的字段有：</p><ol><li><p>matches：String数组，必须。定义content_scripts对哪些页面生效。其规则符合permissions的模式匹配。</p></li><li><p>css：String数组，可选。定义哪些css文件在web页面DOM创建前注入到web页面中。</p></li><li><p>js：String数组，可选。定义哪些js文件注入到web页面中。其js文件的注入顺序与数组中定义的顺序相同。至于这些js与web页面中所定义js的顺序关系，取决于run_at字段。</p></li><li><p>run_at：String，可选。定义content_scripts的注入时机，从而影响到js与web页面所定义js的顺序关系。取值有：</p><ul><li><p>document_start：所有css加载完毕，但DOM尚未创建时。</p></li><li><p>document_end：DOM创建完成，但图片及frame等子资源尚未加载时。</p></li><li><p>document_idle：document_end之后，window.onload之前。</p><p>默认是document_idle，也就是content_scripts的js都罗列在web页面的js之后。</p></li></ul></li><li><p>all_frames：boolean，可选。是否运行在页面所有的frame中。若为false，则只运行在最上层的frame中。默认为false。</p></li><li><p>include_globs：String数组，可选。用于规定页面匹配的白名单。一个URL，必须同时满足：匹配matches，匹配include_globs白名单，不匹配exclude_globs黑名单这三个条件才可以。注意include_globs和exclude_globs中的匹配语法与permissions和matches所用的匹配模式不同。</p></li><li><p>exclude_globs：String数组，可选。用于规定页面匹配的黑名单。同⑥。</p></li></ol><p><strong>permissions</strong>：扩展所需要的权限。permissions是一个String数组，每一个权限都使用String来表示。某些权限在安装前会告知用户。</p><ol><li>模式配匹：用于指定扩展会在哪些URL中生效。例如：</li><li>background：启用扩展后端环境。即在浏览器运行期始终运行，与单个页面无关。可以在这里调用浏览器的API，通常在这里进行扩展主要逻辑的开发。配合manifest.json的background字段使用。</li></ol><p><strong>background</strong>： 这是一个比较重要的属性，如果你需要运行一些后台脚本，比如监听用户在扩展信息栏按下你的插件图标，或者你要监听用户新建tab页，这个时候你就需要有一个background的页面。background你可以指定一个HTML页面（如我的插件），也可以指定一个JS文件，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"My extension"</span>,</span><br><span class="line">  ...</span><br><span class="line">  "background": &#123;</span><br><span class="line">    "scripts": ["background.js"]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">// 需要注意两点：</span><br><span class="line">// 1、是HTML不能写JS代码，JS代码需要写到JS文件中后引入；</span><br><span class="line">// 2、不能使用jquery（没有详细测试，可能是我没用正确）；</span><br></pre></td></tr></table></figure><p>background.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// background.js</span></span><br><span class="line"><span class="comment">// @describtion: 监听用户在扩展信息栏按下你的插件图标时，显示当前活动页的URL：</span></span><br><span class="line">chrome.browserAction.onClicked.addListener(<span class="function"><span class="keyword">function</span> (<span class="params">tab</span>) </span>&#123;</span><br><span class="line">alert(tab.url);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="改进tmall_kill"><a class="markdownIt-Anchor" href="#改进tmall_kill"></a> 改进Tmall_Kill</h2><p>需要修改的功能为：</p><ol><li>插件中设定时间=&gt;时间框选择时间</li><li>匹配网站自动运行-&gt;弹出页面手动点击运行</li><li>选中购物车商品后结算-&gt;到时间后自动勾选商品结算</li><li>弹出页+时间框 popup.html</li></ol><p><a href="https://blog.csdn.net/z_xiaocun/article/details/46934223" target="_blank" rel="noopener">HTML5日期输入框(date)</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> * @Author: Mrli</span></span><br><span class="line"><span class="comment"> * @Date: 2021-03-02 17:19:02</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-03-03 22:18:02</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        width: 250px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#add-new-item</span> &#123;</span></span><br><span class="line"><span class="undefined">        cursor: pointer;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#CCC</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.hide</span> &#123;</span></span><br><span class="line"><span class="undefined">        display: none;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.show</span> &#123;</span></span><br><span class="line"><span class="undefined">        display: block;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="undefined">        cursor: pointer;</span></span><br><span class="line"><span class="undefined">        margin: 5px 0;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> <span class="selector-tag">input</span> &#123;</span></span><br><span class="line"><span class="undefined">        display: inline-block;</span></span><br><span class="line"><span class="undefined">        width: 12px;</span></span><br><span class="line"><span class="undefined">        height: 12px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    input &#123;</span></span><br><span class="line"><span class="undefined">        width: 200px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"add-new-item"</span>&gt;</span>add new item<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"add-new-item-input"</span> <span class="attr">class</span>=<span class="string">"hide"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"new-item-title"</span> <span class="attr">placeholder</span>=<span class="string">"add new"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"meeting"</span>&gt;</span>killTime:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"meeting"</span> <span class="attr">type</span>=<span class="string">"datetime-local"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"item-list"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配套的manifest.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"todo-plugin"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.9.0"</span>,</span><br><span class="line">    <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"chrome plugin demo"</span>,</span><br><span class="line">    <span class="attr">"browser_action"</span>: &#123;</span><br><span class="line">        <span class="attr">"default_icon"</span>: <span class="string">"icon.png"</span>,</span><br><span class="line">        <span class="attr">"default_title"</span>: <span class="string">"Todo List"</span>,</span><br><span class="line">        <span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> Tasks = &#123;</span><br><span class="line">        show: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            obj.className = <span class="string">''</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        hide: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            obj.className = <span class="string">'hide'</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        $addNewItem: $(<span class="string">'add-new-item'</span>),</span><br><span class="line">        $addNewItemInput: $(<span class="string">'add-new-item-input'</span>),</span><br><span class="line">        $itemList: $(<span class="string">'item-list'</span>),</span><br><span class="line">        $newItemTitle: $(<span class="string">'new-item-title'</span>),</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//打开添加文本框</span></span><br><span class="line">            Tasks.$addNewItem.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                Tasks.show(Tasks.$addNewItemInput).hide(Tasks.$addNewItem);</span><br><span class="line">                Tasks.$newItemTitle.focus();</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//回车添加任务</span></span><br><span class="line">            Tasks.$newItemTitle.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span><br><span class="line">                <span class="keyword">if</span> (ev.keyCode == <span class="number">13</span>) &#123;</span><br><span class="line">                    <span class="comment">//<span class="doctag">TODO:</span>写入本地数据</span></span><br><span class="line">                    <span class="keyword">var</span> task = Tasks.$newItemTitle.value;</span><br><span class="line">                    Tasks.AppendHtml(task);</span><br><span class="line">                    Tasks.$newItemTitle.value = <span class="string">''</span>;</span><br><span class="line">                    Tasks.hide(Tasks.$addNewItemInput).show(Tasks.$addNewItem);</span><br><span class="line">                &#125;</span><br><span class="line">                ev.preventDefault();</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//取消添加</span></span><br><span class="line">            Tasks.$newItemTitle.addEventListener(<span class="string">'blur'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                Tasks.$newItemTitle.value = <span class="string">''</span>;</span><br><span class="line">                Tasks.hide(Tasks.$addNewItemInput).show(Tasks.$addNewItem);</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//TODO 初始化数据，加载本地数据，生成html</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//增加</span></span><br><span class="line">        Add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        Edit: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        Del: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;,</span><br><span class="line">        AppendHtml: <span class="function"><span class="keyword">function</span> (<span class="params">title</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">            oDiv.className = <span class="string">'item item-todo'</span>;</span><br><span class="line">            <span class="keyword">var</span> oInput = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">            oInput.type = <span class="string">'checkbox'</span>;</span><br><span class="line">            <span class="keyword">var</span> oTitle = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">            oTitle.innerHTML = title;</span><br><span class="line">            oDiv.appendChild(oInput);</span><br><span class="line">            oDiv.appendChild(oTitle);</span><br><span class="line">            Tasks.$itemList.appendChild(oDiv);</span><br><span class="line">            oDiv.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">//TODO</span></span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        RemoveHtml: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Tasks.init();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="学习案例"><a class="markdownIt-Anchor" href="#学习案例"></a> 学习案例：</h2><ul><li><a href="https://www.extfans.com/web-development/dmkhgkeoafabappeigncmifgkiecjcpp" target="_blank" rel="noopener">cookies-list</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;chrome插件开发&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#chrome插件开发&quot;&gt;&lt;/a&gt; chrome插件开发&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;借鉴TODO-List：&lt;a href=&quot;https://www.w3
      
    
    </summary>
    
    
      <category term="脚本" scheme="https://nymrli.top/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>认真学次DP——动态规划</title>
    <link href="https://nymrli.top/2021/01/24/%E8%AE%A4%E7%9C%9F%E5%AD%A6%E6%AC%A1DP%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://nymrli.top/2021/01/24/认真学次DP——动态规划/</id>
    <published>2021-01-24T05:27:08.000Z</published>
    <updated>2021-01-24T14:26:49.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划dp"><a class="markdownIt-Anchor" href="#动态规划dp"></a> 动态规划DP</h1><blockquote><p>一般算法面试题解决最优化问题，有两种解决途径：暴力枚举、或者DP，由于其灵活和高效，无数程序员为它着迷，大厂面试也是必考。</p><p>但是，动态规划形式上非常多变，本质上没有套路，问题不同，动态规划的迭代方程就不同。而有些问题，对于计算机科学家，都难以找到迭代方程。因此，对于平平常常的我们，刷算法题时想不出动态规划的解法，也大可不必气馁。</p></blockquote><h2 id="dp组成三个条件"><a class="markdownIt-Anchor" href="#dp组成三个条件"></a> DP组成——三个条件</h2><p>某个问题是否能应用动态规划，通常需要满足 3 个条件：</p><ol><li>具有最优子结构</li><li>具有无后续性</li><li>具有重复子问题</li></ol><p><strong>最优子结构性质</strong>：只需求得子问题的最优解后，原问题的最优解最能推导出来，这表明此问题具备最优子结构性质！</p><p>**后续状态无关性：**在具体的问题中就是，子数组的最大和，与后面的红块无关</p><p>**重复子问题：**使用暴力枚举会对很多子问题重复计算，也就是说这个问题具备重复子问题特性。而DP数组的存在可以很好的处理重复子问题计算。</p><h2 id="dp组成三个要素"><a class="markdownIt-Anchor" href="#dp组成三个要素"></a> DP组成——三个要素</h2><ul><li>最优子结构</li><li>边界</li><li>状态转移方程式</li></ul><p>**最优子结构：**只需求得子问题的最优解后，原问题的最优解最能推导出来，这表明此问题具备最优子结构性质！</p><p><strong>边界</strong>：确定起始和终止边界</p><p>**状态转移方程式：**在某个状态下找到下一步的最佳计算结果</p><p>▲.其中最重要的就是找到确定 <strong>状态表示f(v)</strong> 和 <strong>状态转移计算</strong>。目的是：讲究在一个有限集合的中找一个最值</p><p>状态表示f(v)：——化零为整</p><blockquote><ul><li>集合</li><li>属性： 最大、最小、count数量</li></ul></blockquote><p>状态转移计算：——化整为零</p><blockquote><p>划分依据：寻找最后一个不同点。 讲究不重复、不遗漏</p></blockquote><h2 id="问题剖析"><a class="markdownIt-Anchor" href="#问题剖析"></a> 问题剖析</h2><p>最常见的来讲解DP算法的是背包问题， 在此我们列出多个比较经典的题目： 国王和金矿、最大子数组的和、背包问题</p><h3 id="国王和金矿"><a class="markdownIt-Anchor" href="#国王和金矿"></a> 国王和金矿</h3><p><img src="/2021/01/24/认真学次DP——动态规划/DP%E5%86%99%E6%B3%95.png" alt="DP写法"></p><h3 id="最大子数组的和"><a class="markdownIt-Anchor" href="#最大子数组的和"></a> 最大子数组的和：</h3><p><img src="https://pic.leetcode-cn.com/8fec91e89a69d8695be2974de14b74905fcd60393921492bbe0338b0a628fd9a-Picture1.png" alt="Picture1.png"></p><p>题解：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/</a> ——为何在nums数组上直接做修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = nums.length;</span><br><span class="line">        <span class="keyword">if</span> ( sz == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pre = nums[i-<span class="number">1</span>] &gt; <span class="number">0</span> ? nums[i-<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">            nums[i] = nums[i] + pre;</span><br><span class="line">            <span class="keyword">if</span> (maxSum &lt; nums[i]) &#123;</span><br><span class="line">                maxSum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列问题"><a class="markdownIt-Anchor" href="#最长公共子序列问题"></a> 最长公共子序列问题</h3><blockquote><p>题目的要求是，从两个字符串中找到最长的公共子序列，出现先后顺序要求一致， 但是不要求连续。</p><p>所以下面解法定义的dp数组为，状态到text1的i字符、text2的j字符时最长的公共子序列的长度，如果当前的两个字符c1 == c2则需要在此基础上+1， 否则记为之前的两个的最大。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line">        <span class="keyword">int</span> [][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = text1.charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c2 = text2.charAt(j);</span><br><span class="line">                <span class="keyword">if</span> ( c1 == c2 )&#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="01背包问题"><a class="markdownIt-Anchor" href="#01背包问题"></a> 01背包问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>;</span><br><span class="line"><span class="comment">/* 01背包问题 */</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; wv[maxn];</span><br><span class="line"><span class="keyword">int</span> N; <span class="comment">// 物品数量</span></span><br><span class="line"><span class="keyword">int</span> W; <span class="comment">// 背包重量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn]; <span class="comment">//2.多了个记忆数组(称为DP数组)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆序推导</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt;N ; i++) <span class="built_in">cin</span> &gt;&gt; wv[i].first &gt;&gt; wv[i].second;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; W;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i= N<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;= W ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( j &lt; wv[i].first ) dp[i][j] = dp[i+<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = max( dp[i+<span class="number">1</span>][j] , dp[i+<span class="number">1</span>][j - wv[i].first] + wv[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">0</span>][W] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序推导</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt;N ; i++) <span class="built_in">cin</span> &gt;&gt; wv[i].first &gt;&gt; wv[i].second;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; W;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i= <span class="number">0</span> ; i &lt; N ; i++)&#123;<span class="comment">// i为遍历第i个物品</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;= W ; j++)&#123;<span class="comment">// j为背包可用重量</span></span><br><span class="line">            <span class="keyword">if</span>( j &lt; wv[i].first ) dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            dp[i+<span class="number">1</span>][j] = max( dp[i][j] , dp[i][j - wv[i].first] + wv[i].second);</span><br><span class="line">        <span class="comment">// 推导式也变了,下一行的依据上一行写成dp[i+1][j] = ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[N][W] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出的结果变了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安利一个视频：<a href="https://www.bilibili.com/video/BV1X741127ZM?from=search%E2%80%94%E2%80%94%E9%87%91%E7%89%8C%E7%88%B7%E7%9A%84%E4%BC%A0%E6%8E%88" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1X741127ZM?from=search——金牌爷的传授</a></p><p><img src="/2021/01/24/认真学次DP——动态规划/DP.jpg" alt="DP"></p><h2 id="反思总结"><a class="markdownIt-Anchor" href="#反思总结"></a> 反思总结</h2><p>最大子数组和，上面给出了动态规划的解法，还可以使用递归的解法，时间复杂度也是 O(n)O(n)，但是空间复杂度却为 O(n)O(n)，所以最大子数组的最好解法还是动态规划。</p><p>动态规划还常常使用表格，缓存之前各个状态的解，通过空间换取时间，这个也是动态规划常用的技巧之一，但这却不是动态规划最难构思出来的地方，最难的还是设计每个状态步的决策策略，这才是动规的精髓。</p><p>另外，不是所有的问题都有动规的解法，比如目前全世界最难求解的旅行商问题，更复杂的多线路配送问题，都属于NP问题，很难找到动态规划的解法，但是一旦找到动规解法，它会将 O(n!)O(n!) 问题降为 O(n多项式)O(n多项式) 问题，收益也是巨大的！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划dp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动态规划dp&quot;&gt;&lt;/a&gt; 动态规划DP&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一般算法面试题解决最优化问题，有两种解决途径：暴力枚举、或者DP，由于其灵活和高效，无数程序员
      
    
    </summary>
    
    
      <category term="算法" scheme="https://nymrli.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
