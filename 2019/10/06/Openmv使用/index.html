<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Openmv使用 · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">Openmv使用</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2019/11/07</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="嵌入式"> 嵌入式</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">3,107</span> | Reading time: <span class="post-count">15</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="Openmv使用"><a href="#Openmv使用" class="headerlink" title="Openmv使用"></a>Openmv使用</h1><h2 id="下载Openmv-IDE"><a href="#下载Openmv-IDE" class="headerlink" title="下载Openmv IDE"></a>下载Openmv IDE</h2><ul>
<li><a href="https://openmv.io/pages/download" target="_blank" rel="noopener">Openmv官网</a></li>
<li><a href="https://singtown.com/openmv-download/" target="_blank" rel="noopener">中国代理——星瞳</a></li>
<li><a href="https://github.com/openmv/openmv/releases" target="_blank" rel="noopener">Github_release</a></li>
</ul>
<p>推荐下载星瞳的，这个是中文版的，并且其他两个下载非常慢。</p>
<h2 id="捕捉图片设置："><a href="#捕捉图片设置：" class="headerlink" title="捕捉图片设置："></a>捕捉图片设置：</h2><p><strong>设置彩色／黑白</strong></p>
<ul>
<li>sensor.set_pixformat() 设置像素模式。<ul>
<li>sensor.GRAYSCALE: 灰度，每个像素8bit。</li>
<li>sensor.RGB565: 彩色，每个像素16bit。</li>
</ul>
</li>
</ul>
<p><strong>设置图像大小</strong></p>
<ul>
<li><p>sensor.set_framesize() 设置图像的大小</p>
<ul>
<li>sensor.QQVGA: 160x120</li>
<li>sensor.QQVGA2: 128x160 (用于 lcd 扩展板)</li>
<li>sensor.HQVGA: 240x160</li>
<li>sensor.QVGA: 320x240</li>
<li>sensor.VGA: 640x480 (只用于OpenMV Cam M7 的灰度图处理图像，或者彩图采集图像)</li>
<li>sensor.QQCIF: 88x72</li>
<li>sensor.QCIF: 176x144</li>
<li><p>sensor.CIF: 352x288</p>
<p><strong>设置窗口ROI</strong></p>
</li>
</ul>
<p><code>sensor.set_windowing(roi)</code></p>
<p><strong>设置翻转</strong></p>
<p>sensor.set_hmirror(True)<br>水平方向翻转</p>
<p>sensor.set_vflip(True)<br>垂直方向翻转</p>
</li>
</ul>
<h2 id="Demo例程："><a href="#Demo例程：" class="headerlink" title="Demo例程："></a>Demo例程：</h2><blockquote>
<p>openmv虽然比较贵,但是它的功能非常强大,已经提供了相当多的例程了。具体例程可以去星瞳的官网上查看，说明非常详细。</p>
</blockquote>
<p>在此，我只介绍点我们这次需要用到的功能。</p>
<p>我使用的是OPENMV-H7 R1，芯片是STM32H743，镜头为IR 1080P 2.8mm</p>
<p>Hello World</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hello World Example</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Welcome to the OpenMV IDE! Click on the green run arrow button below to run the script!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sensor, image, time</span><br><span class="line"></span><br><span class="line">sensor.reset()                      <span class="comment"># Reset and initialize the sensor.</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># Set pixel format to RGB565 (or GRAYSCALE)</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA)   <span class="comment"># Set frame size to QVGA (320x240)</span></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>)     <span class="comment"># Wait for settings take effect.</span></span><br><span class="line">clock = time.clock()                <span class="comment"># Create a clock object to track the FPS.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">    clock.tick()                    <span class="comment"># Update the FPS clock.</span></span><br><span class="line">    img = sensor.snapshot()         <span class="comment"># Take a picture and return the image.</span></span><br><span class="line">    print(clock.fps())              <span class="comment"># Note: OpenMV Cam runs about half as fast when connected</span></span><br><span class="line">                                    <span class="comment"># to the IDE. The FPS should increase once disconnected.</span></span><br></pre></td></tr></table></figure>
<h3 id="二维码识别"><a href="#二维码识别" class="headerlink" title="二维码识别"></a>二维码识别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QRCode Example</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This example shows the power of the OpenMV Cam to detect QR Codes</span></span><br><span class="line"><span class="comment"># using lens correction (see the qrcodes_with_lens_corr.py script for higher performance).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sensor, image, time</span><br><span class="line"></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>)</span><br><span class="line">sensor.set_auto_gain(<span class="keyword">False</span>) <span class="comment"># must turn this off to prevent image washout...</span></span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line">    img.lens_corr(<span class="number">1.8</span>) <span class="comment"># strength of 1.8 is good for the 2.8mm lens.</span></span><br><span class="line">    <span class="keyword">for</span> code <span class="keyword">in</span> img.find_qrcodes():</span><br><span class="line">        img.draw_rectangle(code.rect(), color = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        print(code)</span><br><span class="line">    print(clock.fps())</span><br></pre></td></tr></table></figure>
<p>代码是用python编写的，文件系统为microPython，具有Cpython解释器翻译成机器码。需要脱机运行的文件命名为main.py即可(具体详情见microPython规范)。可放于flash或者32GB以下的SD卡中，SD卡读取优先级高于Flash，且flash内容容易丢失，且擦写次数有限，建议使用SD卡。</p>
<p>主要需要用的库：</p>
<ul>
<li>sersor:通过这个对象可以控制摄像头及相关配置；</li>
<li>image：处理图像的功能函数都在这个库里<ul>
<li>sensor.snapshot()会返回一个<class 'image'=""></class></li>
</ul>
</li>
<li>time：跟Python自带的time模块不同，这个是专门用来记录摄像头用时的</li>
</ul>
<h3 id="颜色追踪"><a href="#颜色追踪" class="headerlink" title="颜色追踪"></a>颜色追踪</h3><blockquote>
<p> 颜色阈值需要使用LAB色彩空间</p>
</blockquote>
<p>LAB的范围选择，个人比较快截的方法是通过IDE右边的帧缓冲区来获取，即框出ROI区域后，再打开“工具-&gt;机器视觉-&gt;阈值编辑器-&gt;帧缓冲区”,然后根据直方图中的数据就可以筛选出想要的对象辣(白色是选出，黑色是过滤，好像跟PS的蒙版是反的?)</p>
<p>▲颜色识别时，一定要<strong>关闭</strong>自动增益、白平衡</p>
<ul>
<li>sensor.set_auto_gain() 自动增益开启（True）或者关闭（False）。在使用颜色追踪时，需要关闭自动增益。</li>
<li>sensor.set_auto_whitebal() 自动白平衡开启（True）或者关闭（False）。在使用颜色追踪时，需要关闭自动白平衡。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Measure the distance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This example shows off how to measure the distance through the size in imgage</span></span><br><span class="line"><span class="comment"># This example in particular looks for yellow pingpong ball.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sensor, image, time, lcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># For color tracking to work really well you should ideally be in a very, very,</span></span><br><span class="line"><span class="comment"># very, controlled enviroment where the lighting is constant...</span></span><br><span class="line"><span class="comment">#yellow_threshold   = (22, 74, -12, 31, 23, 62)</span></span><br><span class="line"></span><br><span class="line">box_threshold = (<span class="number">40</span>, <span class="number">80</span>, <span class="number">-4</span>, <span class="number">21</span>, <span class="number">14</span>, <span class="number">51</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">red_threshold = (<span class="number">40</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">84</span>, <span class="number">30</span>, <span class="number">79</span>)</span><br><span class="line"><span class="comment"># You may need to tweak the above settings for tracking green things...</span></span><br><span class="line"><span class="comment"># Select an area in the Framebuffer to copy the color settings.</span></span><br><span class="line"></span><br><span class="line">sensor.reset() <span class="comment"># Initialize the camera sensor.</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># use RGB565.</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA) <span class="comment"># use QQVGA for speed.</span></span><br><span class="line">sensor.skip_frames(<span class="number">10</span>) <span class="comment"># Let new settings take affect.</span></span><br><span class="line">sensor.set_auto_whitebal(<span class="keyword">False</span>) <span class="comment"># turn this off.</span></span><br><span class="line">clock = time.clock() <span class="comment"># Tracks FPS.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#lcd.init() # Initialize the lcd screen.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">K=<span class="number">5000</span><span class="comment">#the value should be measured</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">    clock.tick() <span class="comment"># Track elapsed milliseconds between snapshots().</span></span><br><span class="line">    img = sensor.snapshot() <span class="comment"># Take a picture and return the image.</span></span><br><span class="line"></span><br><span class="line">    blobs = img.find_blobs([red_threshold])</span><br><span class="line">    <span class="keyword">if</span> len(blobs) == <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># Draw a rect around the blob.</span></span><br><span class="line">        <span class="comment">#b = blobs[0]</span></span><br><span class="line">        <span class="comment">#img.draw_rectangle(b[0:4]) # rect</span></span><br><span class="line">        <span class="comment">#img.draw_cross(b[5], b[6]) # cx, cy</span></span><br><span class="line">        <span class="comment">#Lm = (b[2]+b[3])/2</span></span><br><span class="line">        <span class="comment">#length = K/Lm</span></span><br><span class="line">        <span class="comment">#print(length)</span></span><br><span class="line">        b = blobs[<span class="number">0</span>]</span><br><span class="line">        img.draw_rectangle(b[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">        img.draw_cross(b[<span class="number">5</span>], b[<span class="number">6</span>])</span><br><span class="line">    <span class="comment">#lcd.display(sensor.snapshot()) # Take a picture and display the image.</span></span><br><span class="line">    <span class="comment">#print(clock.fps()) # Note: Your OpenMV Cam runs about half as fast while</span></span><br><span class="line">    <span class="comment"># connected to your computer. The FPS should increase once disconnected.</span></span><br></pre></td></tr></table></figure>
<h3 id="识别圆"><a href="#识别圆" class="headerlink" title="识别圆"></a>识别圆</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 圆形检测例程</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 这个例子展示了如何用Hough变换在图像中找到圆。</span></span><br><span class="line"><span class="comment"># https://en.wikipedia.org/wiki/Circle_Hough_Transform</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 请注意，find_circles（）方法将只能找到完全在图像内部的圆。圈子之外的</span></span><br><span class="line"><span class="comment"># 图像/ roi被忽略...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sensor, image, time</span><br><span class="line"></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># grayscale is faster</span></span><br><span class="line">sensor.set_framesize(sensor.QQVGA)</span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>)</span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#lens_corr(1.8)畸变矫正</span></span><br><span class="line">    img = sensor.snapshot().lens_corr(<span class="number">1.8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Circle对象有四个值: x, y, r (半径), 和 magnitude。</span></span><br><span class="line">    <span class="comment"># magnitude是检测圆的强度。越高越好</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，</span></span><br><span class="line">    <span class="comment"># ROI 即图像矩形。操作范围仅限于roi区域内的像素。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># x_stride 是霍夫变换时需要跳过的x像素的数量。若已知圆较大，可增加</span></span><br><span class="line">    <span class="comment"># x_stride 。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># y_stride 是霍夫变换时需要跳过的y像素的数量。若已知直线较大，可增加</span></span><br><span class="line">    <span class="comment"># y_stride 。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># threshold 控制从霍夫变换中监测到的圆。只返回大于或等于阈值的圆。</span></span><br><span class="line">    <span class="comment"># 应用程序的阈值正确值取决于图像。注意：一条圆的大小是组成圆所有</span></span><br><span class="line">    <span class="comment"># 索贝尔滤波像素大小的总和。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># x_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和  </span></span><br><span class="line">    <span class="comment"># r_margin的部分合并。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># y_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和</span></span><br><span class="line">    <span class="comment"># r_margin 的部分合并。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># r_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和</span></span><br><span class="line">    <span class="comment"># r_margin 的部分合并。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># r_min，r_max和r_step控制测试圆的半径。</span></span><br><span class="line">    <span class="comment"># 缩小测试圆半径的数量可以大大提升性能。</span></span><br><span class="line">    <span class="comment"># threshold = 3500比较合适。如果视野中检测到的圆过多，请增大阈值；</span></span><br><span class="line">    <span class="comment"># 相反，如果视野中检测到的圆过少，请减少阈值。</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> img.find_circles(threshold = <span class="number">3500</span>, x_margin = <span class="number">10</span>, y_margin = <span class="number">10</span>, r_margin = <span class="number">10</span>,r_min = <span class="number">2</span>, r_max = <span class="number">100</span>, r_step = <span class="number">2</span>):<span class="comment"># (80,60,80,60)</span></span><br><span class="line">        img.draw_circle(c.x(), c.y(), c.r(), color = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        print(c)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> img.find_rects(threshold = <span class="number">3500</span>):</span><br><span class="line">        img.draw_rectangle(r.rect(), color=(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> r.corners():</span><br><span class="line">            img.draw_circle(p[<span class="number">0</span>], p[<span class="number">1</span>], <span class="number">5</span>, color=(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>))</span><br><span class="line">            print(r)</span><br><span class="line">        </span><br><span class="line">    print(<span class="string">"FPS %f"</span> % clock.fps())</span><br></pre></td></tr></table></figure>
<h3 id="测距和测量物块大小"><a href="#测距和测量物块大小" class="headerlink" title="测距和测量物块大小"></a>测距和测量物块大小</h3><blockquote>
<p>由于 OpenMV采用的是单目摄像头，想要实现测距，就需要选<strong>参照物</strong>，利用参照物的大小比例来计算距离。 </p>
</blockquote>
<p>$Len  ∝  \frac{1}{pixelconut}$==&gt;$dist = \frac{C}{pixel}$<em>实际长度和摄像头里的像素成反比</em>  <strong>==&gt;</strong> <em>距离 = 一个常数/直径的像素</em></p>
<ol>
<li>先测出这个常数的值，怎么测不用说了吧，就是先让球距离摄像头10cm，打印出摄像头里直径的像素值，然后相乘，就得到了k的值！ </li>
<li>就可以算出距离了(=这个常数/摄像头里像素点数)</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Measure the distance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This example shows off how to measure the distance through the size in imgage</span></span><br><span class="line"><span class="comment"># This example in particular looks for yellow pingpong ball.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sensor, image, time</span><br><span class="line"></span><br><span class="line"><span class="comment"># For color tracking to work really well you should ideally be in a very, very,</span></span><br><span class="line"><span class="comment"># very, controlled enviroment where the lighting is constant...</span></span><br><span class="line">yellow_threshold   = ( <span class="number">56</span>,   <span class="number">83</span>,    <span class="number">5</span>,   <span class="number">57</span>,   <span class="number">63</span>,   <span class="number">80</span>)</span><br><span class="line"><span class="comment"># box_threshold = (40, 80, -4, 21, 14, 51)</span></span><br><span class="line"><span class="comment"># red_threshold = (40, 59, 61, 84, 30, 79)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You may need to tweak the above settings for tracking green things...</span></span><br><span class="line"><span class="comment"># Select an area in the Framebuffer to copy the color settings.</span></span><br><span class="line"></span><br><span class="line">sensor.reset() <span class="comment"># Initialize the camera sensor.</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># use RGB565.</span></span><br><span class="line">sensor.set_framesize(sensor.QQVGA) <span class="comment"># use QQVGA for speed.</span></span><br><span class="line">sensor.skip_frames(<span class="number">10</span>) <span class="comment"># Let new settings take affect.</span></span><br><span class="line">sensor.set_auto_whitebal(<span class="keyword">False</span>) <span class="comment"># turn this off.</span></span><br><span class="line">clock = time.clock() <span class="comment"># Tracks FPS.</span></span><br><span class="line"></span><br><span class="line">K=<span class="number">5000</span><span class="comment">#the value should be measured</span></span><br><span class="line"><span class="comment"># K = 36*10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">    clock.tick() <span class="comment"># Track elapsed milliseconds between snapshots().</span></span><br><span class="line">    img = sensor.snapshot() <span class="comment"># Take a picture and return the image.</span></span><br><span class="line"></span><br><span class="line">    blobs = img.find_blobs([yellow_threshold])</span><br><span class="line">    <span class="keyword">if</span> len(blobs) == <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># Draw a rect around the blob.</span></span><br><span class="line">        b = blobs[<span class="number">0</span>]</span><br><span class="line">        img.draw_rectangle(b[<span class="number">0</span>:<span class="number">4</span>]) <span class="comment"># rect</span></span><br><span class="line">        img.draw_cross(b[<span class="number">5</span>], b[<span class="number">6</span>]) <span class="comment"># cx, cy</span></span><br><span class="line">        Lm = (b[<span class="number">2</span>]+b[<span class="number">3</span>])/<span class="number">2</span>	<span class="comment"># 像素点数</span></span><br><span class="line">        <span class="comment"># index 2 is length, 3 is width</span></span><br><span class="line">        length = K/Lm		<span class="comment"># 距离</span></span><br><span class="line">        print(length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#print(clock.fps()) # Note: Your OpenMV Cam runs about half as fast while</span></span><br><span class="line">    <span class="comment"># connected to your computer. The FPS should increase once disconnected.</span></span><br></pre></td></tr></table></figure>
<h3 id="LCD显示"><a href="#LCD显示" class="headerlink" title="LCD显示"></a>LCD显示</h3><blockquote>
<p>由于正好有个LCD显示屏，那就也记录下LCD的代码把</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LCD Example</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note: To run this example you will need a LCD Shield for your OpenMV Cam.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The LCD Shield allows you to view your OpenMV Cam's frame buffer on the go.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sensor, image, lcd</span><br><span class="line"></span><br><span class="line">sensor.reset() <span class="comment"># Initialize the camera sensor.</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># or sensor.GRAYSCALE</span></span><br><span class="line">sensor.set_framesize(sensor.QQVGA2) <span class="comment"># Special 128x160 framesize for LCD Shield.</span></span><br><span class="line">lcd.init() <span class="comment"># Initialize the lcd screen.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">    lcd.display(sensor.snapshot()) <span class="comment"># Take a picture and display the image.</span></span><br></pre></td></tr></table></figure>
<h3 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UART Control</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This example shows how to use the serial port on your OpenMV Cam. Attach pin</span></span><br><span class="line"><span class="comment"># P4 to the serial input of a serial LCD screen to see "Hello World!" printed</span></span><br><span class="line"><span class="comment"># on the serial LCD display.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pyb <span class="keyword">import</span> UART</span><br><span class="line"></span><br><span class="line"><span class="comment"># Always pass UART 3 for the UART number for your OpenMV Cam.</span></span><br><span class="line"><span class="comment"># The second argument is the UART baud rate. For a more advanced UART control</span></span><br><span class="line"><span class="comment"># example see the BLE-Shield driver.</span></span><br><span class="line">uart = UART(<span class="number">3</span>, <span class="number">19200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    uart.write(<span class="string">"Hello World!\r"</span>)</span><br><span class="line">    time.sleep(<span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># 接收数据</span></span><br><span class="line">    <span class="keyword">if</span> uart.any():</span><br><span class="line">        a=uart.readline()</span><br><span class="line">		print(a)</span><br></pre></td></tr></table></figure>
<h4 id="与STM32通信"><a href="#与STM32通信" class="headerlink" title="与STM32通信"></a>与STM32通信</h4><p>openmv</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time,sensor, image</span><br><span class="line"><span class="keyword">from</span> pyb <span class="keyword">import</span> UART</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uart = UART(<span class="number">3</span>, <span class="number">115200</span>)</span><br><span class="line">uart.init(<span class="number">115200</span>, bits=<span class="number">8</span>, parity=<span class="keyword">None</span>, stop=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">    <span class="comment"># 由于正点原子提供的串口通信协议需要以\r\n结尾,所以,这边必须也要写\r\n</span></span><br><span class="line">    uart.write(<span class="string">"Hello World!\r\n"</span>)</span><br><span class="line">    <span class="comment"># 中文好像解析不了</span></span><br><span class="line">    <span class="keyword">if</span> uart.any():</span><br><span class="line">        a=uart.readline()</span><br><span class="line">        print(a)</span><br></pre></td></tr></table></figure>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usart.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;		</span><br><span class="line"> 	u16 t;  </span><br><span class="line">	u16 len;	</span><br><span class="line">	u16 times=<span class="number">0</span>;</span><br><span class="line">	delay_init();	    	 <span class="comment">//延时函数初始化	  </span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="comment">//设置NVIC中断分组2:2位抢占优先级，2位响应优先级</span></span><br><span class="line">	uart_init(<span class="number">115200</span>);	 <span class="comment">//串口初始化为115200</span></span><br><span class="line"> 	LED_Init();			     <span class="comment">//LED端口初始化</span></span><br><span class="line">	KEY_Init();          <span class="comment">//初始化与按键连接的硬件接口</span></span><br><span class="line"> 	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x8000</span>)&#123;					   </span><br><span class="line">			len=USART_RX_STA&amp;<span class="number">0x3fff</span>;<span class="comment">//得到此次接收到的数据长度</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Your message is:\r\n\r\n"</span>);</span><br><span class="line">			<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)&#123;</span><br><span class="line">				USART_SendData(USART1, USART_RX_BUF[t]);<span class="comment">//向串口1发送数据</span></span><br><span class="line">				<span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);<span class="comment">//等待发送结束</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//printf("\r\n\r\n");//插入换行</span></span><br><span class="line">			USART_RX_STA=<span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			times++;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">200</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Waiting for input.2333\r\n"</span>);  </span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">30</span>==<span class="number">0</span>)LED0=!LED0;<span class="comment">//闪烁LED,提示系统正在运行.</span></span><br><span class="line">			delay_ms(<span class="number">10</span>);   </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	 </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>测试结果（暂时还没理解）：</p>
<p><img src="/2019/10/06/Openmv使用/uart.png" alt="uart"></p>
<p>补充:</p>
<p><a href="https://blog.csdn.net/zzzzjh/article/details/80725348" target="_blank" rel="noopener">openmv 发送16进制数</a></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><p><a href="https://book.openmv.cc/image/drawing.html" target="_blank" rel="noopener">OpenMV中文入门教程</a></p>
<p>视频教程:</p>
<ul>
<li><a href="https://www.bilibili.com/video/av56434844/?p=5" target="_blank" rel="noopener">B站OpenMV视频教程</a></li>
<li><a href="https://singtown.com/learn/" target="_blank" rel="noopener">星瞳官网</a></li>
</ul>
<p>B站的清晰度和加载速度比较快，星瞳官网的还有额外的教程（他家的拓展版）</p>
<h3 id="画图："><a href="#画图：" class="headerlink" title="画图："></a>画图：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">image.draw_line((10,10,20,30), color=(255,0,0))</span><br><span class="line">image.draw_rectangle(rect_tuple, color=(255,0,0))</span><br></pre></td></tr></table></figure>
<h4 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h4><ul>
<li>image.draw_line(line_tuple, color=White) 在图像中画一条直线。<ul>
<li>line_tuple的格式是(x0, y0, x1, y1)，意思是(x0, y0)到(x1, y1)的直线。</li>
<li>颜色可以是灰度值(0-255)，或者是彩色值(r, g, b)的tupple。默认是白色</li>
</ul>
</li>
</ul>
<h4 id="画框"><a href="#画框" class="headerlink" title="画框"></a>画框</h4><ul>
<li>image.draw_rectangle(rect_tuple, color=White) 在图像中画一个矩形框。<ul>
<li>rect_tuple 的格式是 (x, y, w, h)。</li>
</ul>
</li>
</ul>
<h4 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h4><ul>
<li>image.draw_circle(x, y, radius, color=White) 在图像中画一个圆。<ul>
<li>x,y是圆心坐标</li>
<li>radius是圆的半径</li>
</ul>
</li>
</ul>
<h4 id="画十字"><a href="#画十字" class="headerlink" title="画十字"></a>画十字</h4><ul>
<li>image.draw_cross(x, y, size=5, color=White) 在图像中画一个十字<ul>
<li>x,y是坐标</li>
<li>size是两侧的尺寸</li>
</ul>
</li>
</ul>
<h4 id="写字"><a href="#写字" class="headerlink" title="写字"></a>写字</h4><ul>
<li>image.draw_string(x, y, text, color=White) 在图像中写字 8x10的像素<ul>
<li>x,y是坐标。使用\n, \r, and \r\n会使光标移动到下一行。</li>
<li>text是要写的字符串。</li>
</ul>
</li>
</ul>
<h3 id="需要调参的地方："><a href="#需要调参的地方：" class="headerlink" title="需要调参的地方："></a>需要调参的地方：</h3><ol>
<li>测大小的常数k</li>
<li>形状检测的阈值</li>
<li>颜色识别的阈值</li>
</ol>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2019/10/06/Openmv使用/">https://nymrli.top/2019/10/06/Openmv使用/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2019/10/06/Python多进程/" title="Python多进程"><span>< PreviousPost</span><br><span class="prevTitle">Python多进程</span></a><a class="nextSlogan" href="/2019/10/03/TD-afterstate/" title="TD-afterstate"><span>NextPost ></span><br><span class="nextTitle">TD-afterstate</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: 'Openmv使用',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><span>备案号:苏ICP备18015439号</span></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Openmv使用"><span class="toc-number">1.</span> <span class="toc-text">Openmv使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#下载Openmv-IDE"><span class="toc-number">1.1.</span> <span class="toc-text">下载Openmv IDE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#捕捉图片设置："><span class="toc-number">1.2.</span> <span class="toc-text">捕捉图片设置：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Demo例程："><span class="toc-number">1.3.</span> <span class="toc-text">Demo例程：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二维码识别"><span class="toc-number">1.3.1.</span> <span class="toc-text">二维码识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#颜色追踪"><span class="toc-number">1.3.2.</span> <span class="toc-text">颜色追踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#识别圆"><span class="toc-number">1.3.3.</span> <span class="toc-text">识别圆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测距和测量物块大小"><span class="toc-number">1.3.4.</span> <span class="toc-text">测距和测量物块大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LCD显示"><span class="toc-number">1.3.5.</span> <span class="toc-text">LCD显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#串口通信"><span class="toc-number">1.3.6.</span> <span class="toc-text">串口通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#与STM32通信"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">与STM32通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录"><span class="toc-number">1.4.</span> <span class="toc-text">附录:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#画图："><span class="toc-number">1.4.1.</span> <span class="toc-text">画图：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#画线"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">画线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#画框"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">画框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#画圆"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">画圆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#画十字"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">画十字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写字"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">写字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#需要调参的地方："><span class="toc-number">1.4.2.</span> <span class="toc-text">需要调参的地方：</span></a></li></ol></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>