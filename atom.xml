<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>果粒橙的博客</title>
  
  <subtitle>别装作很努力，因为结局不会陪你演戏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nymrli.top/"/>
  <updated>2018-11-04T04:01:07.235Z</updated>
  <id>https://nymrli.top/</id>
  
  <author>
    <name>果粒橙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高科GSWIFI江苏破解教程</title>
    <link href="https://nymrli.top/2018/11/04/%E9%AB%98%E7%A7%91GSWIFI%E6%B1%9F%E8%8B%8F%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/"/>
    <id>https://nymrli.top/2018/11/04/高科GSWIFI江苏破解教程/</id>
    <published>2018-11-04T02:06:34.000Z</published>
    <updated>2018-11-04T04:01:07.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-重置路由器设置"><a href="#1-重置路由器设置" class="headerlink" title="1.重置路由器设置"></a>1.重置路由器设置</h4><blockquote><p>为了以防之前其他人已经设置过某些东西,可能会影响到之后的使用，所以干脆直接重置。</p></blockquote><h4 id="2-连接路由器电源-不用插任何的wan口或者lan口"><a href="#2-连接路由器电源-不用插任何的wan口或者lan口" class="headerlink" title="2.连接路由器电源,不用插任何的wan口或者lan口"></a>2.连接路由器电源,不用插任何的wan口或者lan口</h4><blockquote><p>P.S.如果第二步,手机和电脑无法直接通过IP地址进入管理界面的话,可以考虑将 网线一头插入2号口,一头插入电脑的插口 , 然后再通过IP地址进入管理界面</p></blockquote><h4 id="3-登录路由器管理界面"><a href="#3-登录路由器管理界面" class="headerlink" title="3.登录路由器管理界面"></a>3.登录路由器管理界面</h4><p>▲注意： 大多数路由器的管理界面IP地址为 <code>192.168.1.1</code>或者<code>192.168.100.1</code>,虽然高科路由器后面贴纸上说明的IP地址是<code>192.168.8.1</code>,但是那个不是初始的IP,需要自己设置到<code>192.168.8.1</code>.</p><p>如下是我已经修改好的IP为<code>192.168.8.1</code>的登录界面,默认密码为<code>admin</code>,登录后选择<strong>不保存密码</strong></p><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/1.jpg" alt="1"></p><h4 id="4-进入管理界面后先观察"><a href="#4-进入管理界面后先观察" class="headerlink" title="4.进入管理界面后先观察"></a>4.进入管理界面后先观察</h4><ul><li><p>首先是要观察软件版本与 GSWIFI 公众号中的最新能用的版本进行匹配,如果是一样的话就不需要升级<em>系统固件</em>,如果当前软件版本比较低就可能无法使用.</p></li><li><p>其次,由于没接网线,所以<strong>网线状态</strong>是<u>WAN口未连接</u></p></li></ul><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/2.jpg" alt="IMG_20181103_194258"></p><h4 id="5-修改配置"><a href="#5-修改配置" class="headerlink" title="5.修改配置"></a>5.修改配置</h4><h5 id="修改WAN口设置"><a href="#修改WAN口设置" class="headerlink" title="修改WAN口设置"></a>修改WAN口设置</h5><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/3.jpg" alt="3"></p><h5 id="如何查看手机MAC地址说明"><a href="#如何查看手机MAC地址说明" class="headerlink" title="如何查看手机MAC地址说明:"></a>如何查看手机MAC地址说明:</h5><p>由于我使用的是英文系统…可能手机界面有点不同</p><p>1<strong>.进入WLAN</strong></p><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/5.png" alt="5"></p><p>2.<strong>进入更多设置</strong></p><blockquote><p>最下面的<code>MAC address</code>就是</p></blockquote><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/4.png" alt="4"></p><h4 id="6-WIFI设置2-4G"><a href="#6-WIFI设置2-4G" class="headerlink" title="6.WIFI设置2.4G"></a>6.WIFI设置2.4G</h4><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/6.jpg" alt="6"></p><h4 id="7-LAN口设置"><a href="#7-LAN口设置" class="headerlink" title="7.LAN口设置"></a>7.LAN口设置</h4><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/7.jpg" alt="7"></p><p>该步之后,等30s配置完成后,你会无法进入<code>192.168.1.1</code>,页面也会无响应,此时访问<code>192.168.8.1</code>重进管理界面</p><h4 id="8-开始连接网线-查看网线状态"><a href="#8-开始连接网线-查看网线状态" class="headerlink" title="8.开始连接网线(查看网线状态)"></a>8.开始连接网线(查看网线状态)</h4><p>▲▲.由于该路由器的WAN口被商家调到了<code>3号LAN口</code>,我也被这步坑了挺久..所以上述步骤都完成以后,将网线插入路由器的<code>3号LAN口</code>,再登录管理界面,此时应该就能看到这样的界面了</p><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/8.jpg" alt="8"></p><p>能够正常显示这几个,则路由器已设置完成.</p><h4 id="9-使用GSWIFI小助手对路由器再次设置"><a href="#9-使用GSWIFI小助手对路由器再次设置" class="headerlink" title="9.使用GSWIFI小助手对路由器再次设置"></a>9.使用GSWIFI小助手对路由器再次设置</h4><blockquote><p>▲注意,使用客服提供的APP,网盘链接在附录中</p></blockquote><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/9.jpg" alt="9"></p><p><strong>按照我们的教程来,IP地址填为<code>192.168.8.1</code></strong>,然后按下”<strong>开始联网</strong>“,之后会有4步,这个过程中WIFI会不断的掉线,需要自己不断重连自己的WIFI(“<strong>Hello</strong>“),等到4步完成后就可以开始用<strong>掌上大学</strong>连上WIFI后<strong>一键上网</strong>了</p><h5 id="完成图如下"><a href="#完成图如下" class="headerlink" title="完成图如下"></a>完成图如下</h5><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/10.png" alt="10"></p><h4 id="10-使用掌上大学一键上网"><a href="#10-使用掌上大学一键上网" class="headerlink" title="10.使用掌上大学一键上网"></a>10.使用掌上大学<strong>一键上网</strong></h4><hr><p>教程到此就结束了,按照上述步骤应该就能完成高科GSWIFI路由器的破解上网了…</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h4><h5 id="GSWIFI小助手江苏版"><a href="#GSWIFI小助手江苏版" class="headerlink" title="GSWIFI小助手江苏版:"></a>GSWIFI小助手江苏版:</h5><p>网盘:<a href="https://pan.baidu.com/share/init?surl=vwza9BJd9kjjMKH6f3ek3g" target="_blank" rel="noopener">https://pan.baidu.com/share/init?surl=vwza9BJd9kjjMKH6f3ek3g</a> 提取码:svdg</p><h5 id="更新系统固件"><a href="#更新系统固件" class="headerlink" title="更新系统固件"></a>更新系统固件</h5><p>找到GSWIFI公众号:  选择<code>系统升级</code> 然后查看<code>升级教程</code> 和 <code>1082正式版系统</code>(目前最新的系统固件)，然后根据里面提供的网盘将文件下载下来</p><blockquote><p>下载后===&gt;解压===&gt;进入管理界面===&gt;系统升级===&gt;选择文件===&gt;刷写固件===&gt;执行（其中过程千万不能关闭电源或是乱动，就算按错了，等2-3分钟好了以后再重新刷写也无妨，但是千万不能断电源）</p></blockquote><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/11.jpg" alt="11"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-重置路由器设置&quot;&gt;&lt;a href=&quot;#1-重置路由器设置&quot; class=&quot;headerlink&quot; title=&quot;1.重置路由器设置&quot;&gt;&lt;/a&gt;1.重置路由器设置&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;为了以防之前其他人已经设置过某些东西,可能会影响到之后的使
      
    
    </summary>
    
    
      <category term="生活福利" scheme="https://nymrli.top/tags/%E7%94%9F%E6%B4%BB%E7%A6%8F%E5%88%A9/"/>
    
  </entry>
  
  <entry>
    <title>WSGI uWSGI uwsgi及nginx说明</title>
    <link href="https://nymrli.top/2018/11/02/WSGI-uWSGI-uwsgi%E5%8F%8Anginx%E8%AF%B4%E6%98%8E/"/>
    <id>https://nymrli.top/2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/</id>
    <published>2018-11-02T07:50:12.000Z</published>
    <updated>2018-11-02T08:16:15.520Z</updated>
    
    <content type="html"><![CDATA[<h4 id="客户端发出请求-gt-服务器接受、处理请求与响应-的过程示意图"><a href="#客户端发出请求-gt-服务器接受、处理请求与响应-的过程示意图" class="headerlink" title="客户端发出请求==&gt;服务器接受、处理请求与响应 的过程示意图"></a>客户端发出请求==&gt;服务器接受、处理请求与响应 的过程示意图</h4><p><img src="/2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/过程.png" alt="过程"></p><h4 id="1-WSGI："><a href="#1-WSGI：" class="headerlink" title="1. WSGI："></a>1. <strong>WSGI：</strong></h4><blockquote><p>全称是<code>Web Server Gateway Interface(服务器网关接口)</code>。<code>WSGI</code>不是服务器，<code>python</code>模块，框架，<code>API</code>或者任何软件，只是一种规范( 是一个<strong>Web服务器（如nginx）</strong>与<strong>应用服务器（如uWSGI）</strong>通信的一种规范（协议）==&gt; 可以理解为服务器与应用程序通信的接口规范要求)，描述<code>web server</code>如何与<code>web application</code>通信的规范。<code>server</code>和<code>application</code>的规范在<a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP 3333</a>中有具体描述。因为WSGI没有官方的实现, 所以WSGI更像一个协议，只要遵照这些协议，都可以在任何服务器(Server)上运行</p></blockquote><h4 id="2-uwsgi："><a href="#2-uwsgi：" class="headerlink" title="2.uwsgi："></a>2.<strong>uwsgi：</strong></h4><blockquote><p>与<code>WSGI</code>一样是一种通信协议，是<code>uWSGI</code>服务器的独占协议，用于定义传输信息的类型(<code>type of information</code>)，每一个<code>uwsgi packet</code>前<code>4byte</code>为传输信息类型的描述，与WSGI协议是两种不同的协议。该协议据说性能非常高，是<code>fcgi</code>协议的10倍快;而且内存占用率低，为<code>mod_wsgi</code>的一半左右，同时它还支持多应用的管理及应用的性能监控</p></blockquote><h4 id="3-uWSGI："><a href="#3-uWSGI：" class="headerlink" title="3.uWSGI："></a>3.<strong>uWSGI：</strong></h4><blockquote><p>是一个<code>web</code>服务器，而且也可以当做中间件。它实现了<code>WSGI</code>协议、<code>uwsgi</code>协议、<code>http</code>协议等。在生产环境中使用uWSGI作为python web的服务器,可以用来托管 Python WSGI应用。它具有应用服务器，代理，进程管理及应用监控等功能(但可以把看作是一个应用程序，帮助我们实现WSGI协议)，这样我们可以不再关注网络通信的底层实现，将精力更多放在处理HTTP请求数据，返回HTML。</p></blockquote><h4 id="4-uWSGI-nginx"><a href="#4-uWSGI-nginx" class="headerlink" title="4.uWSGI+nginx"></a>4.uWSGI+nginx</h4><blockquote><p>综上所述可以看出uWSGI可以直接当做服务器，而为了<strong>进一步的并发提升</strong>就需要加上nginx(<strong>提高负载均衡</strong>) </p><p>▲.当uWSGI+nginx使用时，nginx作为web服务器，而uWSGI作为中间件(这边不一定正确,个人理解)</p></blockquote><h5 id="uWSGI不足的地方"><a href="#uWSGI不足的地方" class="headerlink" title="uWSGI不足的地方:"></a>uWSGI不足的地方:</h5><ul><li><p>uWIGS也可以返回静态文件(css,js,img…)，但是很笨拙，所以更好的做法是用反向代理服务器（比如Nginx）来处理此类请求，减轻应用服务器的负载，获得更好的性能。</p><ul><li>利用uWIGS可以是我们的web应用得到更强的并发能力，uWIGS也可以返回静态文件(css,js,img…)，但是很笨拙，一般静态文件都交由Nginx进行传输，所以配置中一般不配置static-map,如果直接由uWIGS接受HTTP请求则需要设置http:xxxx，如果只需要与反向代理服务器进行交互则只需要接受socket，uWIGS与Nginx交互相当于两个进程间交互，一般使用的是.sock文件或者指定端口接受socket。指定端口时再使用浏览器访问相应端口，uWIGS会提示skip，跳过该HTTP请求。</li></ul></li><li><p>同时还有的是uWSGI本身的负载均衡没有nginx牛逼。所以阉割掉不用。</p></li></ul><h4 id="5-Nginx是一个Http和反向代理服务器"><a href="#5-Nginx是一个Http和反向代理服务器" class="headerlink" title="5.Nginx是一个Http和反向代理服务器"></a>5.Nginx是一个Http和反向代理服务器</h4><blockquote><p>什么是反向代理服务器呢？</p></blockquote><p>▲正向的就是由浏览器主动的想代理服务器发出请求，经代理服务器做出处理后再转给目标服务器<br>▲反向的就是不管浏览器同不同意，请求都会经过代理服务器处理再发给目标服务器</p><p>这其中的区别就是必须经过Nginx反向代理服务器，这就有了使用Nginx的几个好处：</p><ul><li>安全：不管什么请求都要经过代理服务器，这样就避免了外部程序直接攻击web服务器</li><li><p>负载均衡：根据请求情况和服务器负载情况，将请求分配给不同的web服务器，保证服务器性能</p></li><li><p>提高web服务器的IO性能：这个我也没看懂，总结来说就是请求从客户端传到web服务器是需要时间的，传递多长时间就会让这个进程阻塞多长时间，而通过反向代理，就可以在反向代理这完整接受请求，然后再传给web服务器，从而保证服务器性能，而且有的一些简单的事情（比如静态文件）可以直接由反向代理处理，不经过web服务器</p></li></ul><p><img src="/2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/nginx.png" alt="nginx"></p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/总结.jpg" alt="总结"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;客户端发出请求-gt-服务器接受、处理请求与响应-的过程示意图&quot;&gt;&lt;a href=&quot;#客户端发出请求-gt-服务器接受、处理请求与响应-的过程示意图&quot; class=&quot;headerlink&quot; title=&quot;客户端发出请求==&amp;gt;服务器接受、处理请求与响应 的过程
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
      <category term="后端" scheme="https://nymrli.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>apt-get update无法连接</title>
    <link href="https://nymrli.top/2018/11/02/apt-get-update%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5/"/>
    <id>https://nymrli.top/2018/11/02/apt-get-update无法连接/</id>
    <published>2018-11-02T05:21:45.000Z</published>
    <updated>2018-11-02T05:44:44.227Z</updated>
    
    <content type="html"><![CDATA[<h4 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h4><p>原因是在apt-get update时遇到了Unable to connect to 代理，（由于<code>apt-get update</code>一直显示无法连接<code>172.17.18.141</code>百度后发现这并不是个特殊的IP,而且也可以ping到百度）于是想到是否使用了代理。</p><p><img src="/2018/11/02/apt-get-update无法连接/hexo\source\_posts\apt-get-update无法连接\1.jpg" alt="1"></p><p><img src="/2018/11/02/apt-get-update无法连接/1.jpg" alt="1"></p><p><img src="/2018/11/02/apt-get-update无法连接/2.jpg" alt="2"></p><h3 id="apt代理的设置："><a href="#apt代理的设置：" class="headerlink" title="apt代理的设置："></a>apt代理的设置：</h3><h4 id="临时方法"><a href="#临时方法" class="headerlink" title="临时方法"></a>临时方法</h4><p><code>export http_proxy=http://10.3.0.1:80</code></p><h4 id="长久方法"><a href="#长久方法" class="headerlink" title="长久方法"></a>长久方法</h4><p>(1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。)</p><p><code>Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;;</code></p><p><code>Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;;</code></p><p><code>Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;;</code></p><p>保存apt.conf文件。</p><p>(2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件)</p><p>建立文件  <code>vim proxyfile</code></p><p><code>Acquire::http::proxy &quot;http://10.3.0.1:80&quot;;</code></p><p><code>Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;;</code></p><p><code>Acquire::https::proxy &quot;http://10.3.0.1:80&quot;;</code></p><p>使用时<code>sudo apt-get install  xxx -c proxyfile</code></p><p>(2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 )</p><p>在您的.bashrc文件末尾添加如下内容<br><code>export http_proxy=http://用户名:密码@地址:端口/</code><br><code>export https_proxy=http://用户名:密码@地址:端口/</code></p><p><code>export ftp_proxy=http://用户名:密码@地址:端口/</code></p><hr><p>附上一篇ubuntu设置代理的文章:<a href="https://blog.csdn.net/qq3399013670/article/details/81300497" target="_blank" rel="noopener">ubuntu设置代理</a></p><h3 id="Ubuntu下让终端走SS代理的方法"><a href="#Ubuntu下让终端走SS代理的方法" class="headerlink" title="Ubuntu下让终端走SS代理的方法"></a>Ubuntu下让终端走SS代理的方法</h3><p>Ubuntu下让终端走SS代理需要第三方软件的帮助，即privoxy。<br>privoxy 是非快取式 (non-caching) 的网页代理伺服器，具有进阶的过滤能力，可强化隐私权，还可以修改网页资料、管理 HTTP cookies、去除广告等。</p><h5 id="安装-privoxy"><a href="#安装-privoxy" class="headerlink" title="安装 privoxy"></a>安装 privoxy</h5><p><code>sudo apt-get install privoxy</code></p><p>安装完成后在 /etc/privoxy 目录下可以找到配置文件 config。</p><h5 id="配置-privoxy"><a href="#配置-privoxy" class="headerlink" title="配置 privoxy"></a>配置 privoxy</h5><p>一般地，改配置前应该备份配置。</p><p><code>mv /etc/privoxy/config /etc/privoxy/config.back</code></p><p>然后打开 config 文件，找到<code>listen-address</code>那一行，修改值为 privoxy 监听的地址，一般使用默认。</p><p>然后再找到<code>forward-socks5</code>那一行，去掉注释，值为SS代理监听的地址。</p><p>让终端走SS代理,修改配置后，重启 privoxy。</p><p><code>sudo /etc/init.d/privoxy restart</code></p><p>然后在终端下添加 http 代理。</p><p><code>export http_proxy=”127.0.0.1:8118”</code></p><p><code>export https_proxy=”127.0.0.1:8118”</code></p><p>然后就可以愉快的用终端翻墙了。</p><p>原文：<a href="https://blog.csdn.net/tailgo/article/details/52075643" target="_blank" rel="noopener">https://blog.csdn.net/tailgo/article/details/52075643</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;出现的问题&quot;&gt;&lt;a href=&quot;#出现的问题&quot; class=&quot;headerlink&quot; title=&quot;出现的问题&quot;&gt;&lt;/a&gt;出现的问题&lt;/h4&gt;&lt;p&gt;原因是在apt-get update时遇到了Unable to connect to 代理，（由于&lt;code&gt;apt
      
    
    </summary>
    
    
      <category term="linux" scheme="https://nymrli.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Windows控制台Cmd乱码（及永久修改编码）解决方法</title>
    <link href="https://nymrli.top/2018/10/28/Windows-%E6%8E%A7%E5%88%B6%E5%8F%B0Cmd%E4%B9%B1%E7%A0%81%EF%BC%88%E5%8F%8A%E6%B0%B8%E4%B9%85%E4%BF%AE%E6%94%B9%E7%BC%96%E7%A0%81%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://nymrli.top/2018/10/28/Windows-控制台Cmd乱码（及永久修改编码）解决方法/</id>
    <published>2018-10-28T08:42:20.000Z</published>
    <updated>2018-10-28T08:47:00.882Z</updated>
    
    <content type="html"><![CDATA[<p>我本机的系统环境：`OS Name: Microsoft Windows 10 家庭中文版</p><h4 id="Windows-控制台Cmd乱码的解决办法-一次性"><a href="#Windows-控制台Cmd乱码的解决办法-一次性" class="headerlink" title="Windows 控制台Cmd乱码的解决办法(一次性)"></a>Windows 控制台Cmd乱码的解决办法(一次性)</h4><p>在cmd中输入 <code>CHCP 65001</code></p><blockquote><p> 注：CHCP是一个计算机指令，能够显示或设置活动代码页编号。</p><p>代码页  描述</p><ul><li><p>65001   UTF-8代码页</p></li><li><p>950 繁体中文</p></li><li><p>936 简体中文默认的GBK</p></li><li><p>437 MS-DOS 美国英语</p></li></ul></blockquote><p><strong>但是通过CHCP设置编码是治标不治本的,想永久的更改cmd编码值需要修改注册表</strong></p><h4 id="Windows-控制台Cmd乱码的解决办法-永久性"><a href="#Windows-控制台Cmd乱码的解决办法-永久性" class="headerlink" title="Windows 控制台Cmd乱码的解决办法(永久性)"></a>Windows 控制台Cmd乱码的解决办法(永久性)</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>1.在cmd中输入<code>regedit</code>进入注册表</p><p>2.找到<code>HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe</code></p><p>3.新建一个 DWORD（32位值）,命名为CodePage，值设为65001 </p><p>4.已有CodePage的话，修改它，改为十进制，65001</p><h5 id="方法二：-亲测有效"><a href="#方法二：-亲测有效" class="headerlink" title="方法二：(亲测有效)"></a>方法二：(亲测有效)</h5><p>1.新建一个cmd.reg注册表文件:</p><p>2.内容输入如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version <span class="number">5.00</span></span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe]</span><br><span class="line"><span class="string">"CodePage"</span>=<span class="string">dword:</span><span class="number">0000</span>fde9</span><br><span class="line"><span class="string">"FontFamily"</span>=<span class="string">dword:</span><span class="number">00000036</span></span><br><span class="line"><span class="string">"FontWeight"</span>=<span class="string">dword:</span><span class="number">00000190</span></span><br><span class="line"><span class="string">"FaceName"</span>=<span class="string">"Consolas"</span></span><br><span class="line"><span class="string">"ScreenBufferSize"</span>=<span class="string">dword:</span><span class="number">232900</span>d2</span><br><span class="line"><span class="string">"WindowSize"</span>=<span class="string">dword:</span><span class="number">002</span>b00d2</span><br></pre></td></tr></table></figure><p>3.双击运行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我本机的系统环境：`OS Name: Microsoft Windows 10 家庭中文版&lt;/p&gt;
&lt;h4 id=&quot;Windows-控制台Cmd乱码的解决办法-一次性&quot;&gt;&lt;a href=&quot;#Windows-控制台Cmd乱码的解决办法-一次性&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JS正则及常用方法函数总结</title>
    <link href="https://nymrli.top/2018/10/25/JS%E6%AD%A3%E5%88%99%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>https://nymrli.top/2018/10/25/JS正则及常用方法函数总结/</id>
    <published>2018-10-25T03:55:20.000Z</published>
    <updated>2018-10-25T04:30:29.832Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS正则及常用方法函数总结"><a href="#JS正则及常用方法函数总结" class="headerlink" title="JS正则及常用方法函数总结"></a><a href="https://www.cnblogs.com/myzhibie/p/4365142.html" target="_blank" rel="noopener">JS正则及常用方法函数总结</a></h3><blockquote><p>正则表达式作为一种匹配处理字符串的利器在很多语言中都得到了广泛实现和应用，web开发本质上是处理字符串（服务端接受请求处理后拼接字符串作为响应，这在早期的CGI编程中最明显，然后客户端解析字符串进行渲染和执行），所以说，JS作为一门常用于web开发的语言，必然要具备正则这种强大的特性，本文将对JS中的正则用法及常用函数进行一番总结。</p></blockquote><h4 id="1-正则对象及其属性"><a href="#1-正则对象及其属性" class="headerlink" title="1.正则对象及其属性"></a><strong>1.正则对象及其属性</strong></h4><p>首先正则对象是JS中内置的一个对象，好比Array以及Math一样，不需要第三方库的支持，通常我们采取两种方式来定义一个正则对象.</p><h5 id="1）构造函数方式"><a href="#1）构造函数方式" class="headerlink" title="1）构造函数方式"></a>1）构造函数方式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'abc'</span>,<span class="string">'gi'</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里，第一个参数是正则的内容，第二个参数是修饰符，</span></span><br><span class="line"><span class="comment">修饰符通常有三种，i,g,m，i表示的含义是忽略大小写进行匹配，g表示全局匹配即匹配到第一个之后不停止继续匹配，m表示多行匹配即遇到换行后不停止匹配继续直到被匹配字符串结束。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>/i (忽略大小写)</li><li>/g (全文查找出现的所有匹配字符,否则只匹配第一个出现的)</li><li>/m (多行查找)</li><li>/gi(全文查找、忽略大小写)</li><li>/ig(全文查找、忽略大小写)</li></ul></blockquote><h5 id="2）字面量方式"><a href="#2）字面量方式" class="headerlink" title="2）字面量方式"></a>2）字面量方式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  reg=<span class="regexp">/abc/gi</span>;</span><br><span class="line">consolo.dir(reg);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*▲.两个斜杠之间的是定义的正则内容*，最后一个斜杠之后的是修饰符，</span></span><br><span class="line"><span class="comment">这种方式比第一种简单高效，所以通常使用第二种方式来定义正则。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a><strong>2.属性</strong></h4><p>在控制台中打印一个正则对象如下：</p><p><img src="/2018/10/25/JS正则及常用方法函数总结/1.png" alt="1"></p><ul><li><p><code>global</code>属性，该属性为布尔类型，用来表示该正则是否是全局匹配，</p></li><li><p><code>ignoreCase</code>属性，布尔类型，用来指示是否忽略大小写，</p></li><li><p><code>lastIndex</code>为number类型，用来表示上次匹配成功的位置，</p></li><li><p><code>multiline</code>，布尔类型，用来表示是否是多行匹配，source，string类型，用来表示正则的内容。</p></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex" target="_blank" rel="noopener"><code>lastIndex</code></a> 属性表示的索引处为目标字符串匹配（并且不会尝试从后续索引匹配）,你不能直接更改这个属性，它是只读的。可以通过<code>^</code></li><li><code>unicode</code>标志开启了多种 Unicode 相关的特性。使用 “u” 标志，任何 Unicode 代码点的转义都会被解释。</li></ul><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a><strong>3.方法</strong></h4><p>通常对于一个正则对象来讲，我们能够使用的方法基本上有三个，即<code>regObj.test</code>,<code>regObj.exec</code>及<code>regObj.compile</code></p><h5 id="1）test方法"><a href="#1）test方法" class="headerlink" title="1）test方法"></a>1）test方法</h5><p>该方法用来测试某个字符串是否与正则匹配，匹配就返回true，否则返回false。该方法接受一个字符串作为参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> reg=<span class="regexp">/boy(s)?\s+and\s+girl(s)?/gi</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(reg.test(<span class="string">'boy    and   girl'</span>));</span><br><span class="line"><span class="comment">//==&gt;true</span></span><br></pre></td></tr></table></figure><h5 id="2-compile方法"><a href="#2-compile方法" class="headerlink" title="2)compile方法"></a>2)compile方法</h5><p>该方法的作用是能够对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，<u>适合于对一个正则对象(模式)多次调用的情况下</u>，如果对一个正则只使用一两次，那么该方法没有特别显著的效应。</p><p>接受的参数也是一个正则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/[abc]/gi</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(reg.test(<span class="string">'a'</span>)); <span class="comment">//==&gt;true</span></span><br><span class="line">    reg=<span class="regexp">/[cde]/gi</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(reg.test(<span class="string">'a'</span>)); <span class="comment">//==&gt;false</span></span><br><span class="line">    reg.compile(reg);</span><br><span class="line">    <span class="built_in">console</span>.log(reg.test(<span class="string">'a'</span>)); <span class="comment">//==&gt;false</span></span><br><span class="line"><span class="comment">//被编译的正则和没有编译的正则在测试结果上没有任何区别，只是多次调用的效率上会更高一些。</span></span><br></pre></td></tr></table></figure><h5 id="3）exec方法"><a href="#3）exec方法" class="headerlink" title="3）exec方法"></a>3）exec方法</h5><p>该方法属于一个比较复杂的方法，它接受一个字符串，返回的是一个数组，数组中第0个元素是匹配的子字符串，第二个元素是正则中的第一个子分组匹配的结果（如果有子分组，即正则中存在用圆括号括起来的分组），第三个是正则中第二个子分组匹配的结果（如果有第二个子分组）…以此类推，如果没有正则子分组，那么该数组长度仅仅为1，就是匹配到的那个子字符串。同时，返回的这个数组同时还是一个对象，它拥有两个属性，分别为index表示当前匹配到的子字符串所处的位置，input属性表示被匹配的原始字符串。最后，该方法中的正则对象如果不是全局匹配，即没有g修饰符，则每次调用只会从字符串开头处匹配第一个结果，且每次调用结果都是一样的。只有指定为全局匹配，才能够按照从左往右依次去匹配，每次调用匹配一个结果，正则对象的lastIndex属性前进到本次匹配的末尾位置，下回再调用的时候，会从lastIndex处开始匹配而不是从头匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/(\w)l(\w)/g</span>;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world hello 123 hello programmer hello test"</span>;</span><br><span class="line"><span class="keyword">var</span> arr=reg.exec(str);</span><br><span class="line">    <span class="keyword">while</span>(arr)&#123;</span><br><span class="line">        <span class="built_in">console</span>.dir(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"lastIndex:"</span>+reg.lastIndex);</span><br><span class="line">        arr=reg.exec(str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2018/10/25/JS正则及常用方法函数总结/2.png" alt="3"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非全局匹配代码：</span></span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/(\w)l(\w)/</span>;</span><br><span class="line">   <span class="keyword">var</span> str=<span class="string">"hello world hello 123 hello programmer hello test"</span>;</span><br><span class="line">   <span class="keyword">var</span> arr=reg.exec(str);</span><br><span class="line">   <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(arr)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.dir(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"lastIndex:"</span>+reg.lastIndex);</span><br><span class="line">        arr=reg.exec(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/JS正则及常用方法函数总结/3.png" alt="3"></p><p>这个时候每次调用的结果都一样，lastIndex根本没有发生变化。</p><p>以上就是正则对象及其方法，其实在使用的过程中，JS中的String类型的对象也拥有一些和正则相关的方法，如下：</p><h4 id="String类型的对象的正则方法"><a href="#String类型的对象的正则方法" class="headerlink" title="String类型的对象的正则方法"></a>String类型的对象的正则方法</h4><h5 id="1）search方法"><a href="#1）search方法" class="headerlink" title="1）search方法"></a><strong>1）search方法</strong></h5><p>该方法是string对象的一个方法，用来<strong>查找第一次匹配的子字符串的位置</strong>，如果找到就返回一个number类型的index值，否则返回-1,它返回的只是第一次匹配的位置。</p><p>它接受一个正则或者子字符串为参数，这里我们只讨论正则的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/o/g</span>));</span><br><span class="line"><span class="comment">//输出结果为4，可以看到尽管具有多个匹配结果而且也声明为全局匹配，但是还是返回的是第一个匹配到的子串的位置；</span></span><br></pre></td></tr></table></figure><h5 id="2）replace方法"><a href="#2）replace方法" class="headerlink" title="2）replace方法"></a><strong>2）replace方法</strong></h5><p>该方法用来<strong>将字符串中的某些子串替换为需要的内容</strong>，接受两个参数，第一个参数可以为正则或者子字符串，表示匹配需要被替换的内容，第二个参数为被替换的新的子字符串。如果声明为全局匹配则会替换所有结果，否则只替换第一个匹配到的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world,hello test"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="regexp">/hello/g</span>,<span class="string">'hi'</span>));</span><br><span class="line"><span class="comment">//结果为hi world,hi test</span></span><br><span class="line"><span class="comment">//如果将上面代码中的g修饰符去掉，则返回的结果是hi world,hello test</span></span><br></pre></td></tr></table></figure><h5 id="3）split方法"><a href="#3）split方法" class="headerlink" title="3）split方法"></a><strong>3）split方法</strong></h5><p>该方法主要用来<strong>将一个字符串拆分成一个数组</strong>，它接受一个正则或者子字符（串）作为参数，返回一个数组，简单情况下，我们不需要使用正则，只有在字符串拆分规则不统一的情况下才需要使用正则，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"how|old*are    you"</span>;</span><br><span class="line"><span class="keyword">var</span> arr=str.split(<span class="regexp">/\||\*|\s+/</span>);</span><br><span class="line"><span class="comment">// 以|、*、多项空格为分隔符</span></span><br><span class="line"><span class="comment">// \s 匹配任何空白字符,包括空格、制表符、换页符等等</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><p>这里需要将str拆分为单词数组，由于每个单词之间存在不一样的分隔符，我们采取正则来匹配，结果如下：</p><p><img src="/2018/10/25/JS正则及常用方法函数总结/4.png" alt="4"></p><h5 id="4）match方法"><a href="#4）match方法" class="headerlink" title="4）match方法"></a><strong>4）match方法</strong></h5><p>该方法接受一个正则作为参数，用来匹配一个字符串，它的输出结果在不是全局匹配的情况下和exec方法的结果一致即一个数组并带有额外的属性，如果采用全局匹配，则不返回任何和其被匹配字符串相关的信息，只返回匹配的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非全局匹配代码：</span></span><br><span class="line"><span class="keyword">var</span> reg2=<span class="regexp">/(\w)s(\w)/</span>;</span><br><span class="line"><span class="keyword">var</span> str2=<span class="string">"ws1esr"</span>;</span><br><span class="line"><span class="keyword">var</span> result=str2.match(reg2);</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(result)&#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(result);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"lastIndex:"</span>+reg2.lastIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//非全局匹配下，结果和exec非全局匹配方法返回的完全一致，</span></span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/JS正则及常用方法函数总结/5.png" alt="5"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局匹配代码：</span></span><br><span class="line"><span class="keyword">var</span> reg3=<span class="regexp">/(\w)s(\w)/g</span>;</span><br><span class="line"><span class="keyword">var</span> str4=<span class="string">"ws1estqsa"</span>;</span><br><span class="line"><span class="built_in">console</span>.dir(str4.match(reg3));</span><br><span class="line"><span class="comment">//可以看到，在全局匹配下的时候，它不同于exec方法，它会一次性将所有匹配结果以数组形式返回，且这个数组没有其他属性用来指向被匹配字符串的信息，而exec方法在全局匹配下每次返回的依然是本次匹配的结果数组，且这个数组中只包含本次匹配信息，同时又拥有指向被匹配字符串的信息，即match方法在全局匹配下一次性返回了所有匹配结果，而exec在全局匹配下返回的依然是当次匹配结果。</span></span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/JS正则及常用方法函数总结/6.png" alt="6"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS正则及常用方法函数总结&quot;&gt;&lt;a href=&quot;#JS正则及常用方法函数总结&quot; class=&quot;headerlink&quot; title=&quot;JS正则及常用方法函数总结&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/myzhibie/p/436
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="前端" scheme="https://nymrli.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="小程序" scheme="https://nymrli.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="JavaScript" scheme="https://nymrli.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text3 Python虚拟环境（补充）——解决控制台中文乱码情况</title>
    <link href="https://nymrli.top/2018/10/24/Sublime-Text3-Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E6%83%85%E5%86%B5/"/>
    <id>https://nymrli.top/2018/10/24/Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况/</id>
    <published>2018-10-24T10:52:35.000Z</published>
    <updated>2018-10-24T10:53:11.813Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://www.cnblogs.com/guiyuhua/p/8627091.html" target="_blank" rel="noopener">edwardgui的博客</a></p><blockquote><p>正常的用python编译控制台是不会出现乱码的，但是在使用虚拟环境的情况下中文总是乱码，一开始以为是windows控制台编码的问题。找了挺久后发现是python+virtualenv编译系统的问题，现在我就带领大家解决这个问题。</p></blockquote><h5 id="▲注：Windows环境下"><a href="#▲注：Windows环境下" class="headerlink" title="▲注：Windows环境下"></a>▲注：Windows环境下</h5><ul><li>首先看下是否已经安装了Virtualenv package插件，如果没有，则Ctrl+Shift+P，install Package,输入Virtualenv安装。</li><li>找到插件安装的地方：C:\Users{Username}\AppData\Roaming\Sublime Text 3\Installed Packages ==&gt;注意改变一下Username</li><li>解压Virtualenv.sublime-package文件，可以通过先添加后缀.zip变为Virtualenv.sublime-package.zip再解压</li></ul><p>包含文件如下：<br><img src="https://images2018.cnblogs.com/blog/1350574/201808/1350574-20180827155724022-2032122286.jpg" alt=""><br>修改Python + Virtualenv.sublime-build文件， 增加一行：<code>&quot;env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf8&quot;},</code><br>使其变成<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"env"</span>: &#123;<span class="attr">"PYTHONIOENCODING"</span>: <span class="string">"utf8"</span>&#125;,</span><br><span class="line"><span class="attr">"target"</span>: <span class="string">"virtualenv_exec"</span>,</span><br><span class="line"><span class="attr">"shell_cmd"</span>: <span class="string">"python -u \"$file\""</span>,</span><br><span class="line"><span class="attr">"file_regex"</span>: <span class="string">"^[ ]*File \"(...*?)\", line ([0-9]*)"</span>,</span><br><span class="line"><span class="attr">"selector"</span>: <span class="string">"source.python"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后保存，再把该文件打包为Virtualenv.sublime-package.zip再去掉后缀，就大功告成了。</p><hr><p>最后打开Sublime Text3使用Python + Virtualenv 编译，就能看到中文正常输出啦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：&lt;a href=&quot;https://www.cnblogs.com/guiyuhua/p/8627091.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;edwardgui的博客&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正常的用pyth
      
    
    </summary>
    
    
      <category term="Sublime Text" scheme="https://nymrli.top/tags/Sublime-Text/"/>
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——将Cookie保存到本地的多种方法介绍</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E5%B0%86Cookie%E4%BF%9D%E5%AD%98%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/</id>
    <published>2018-10-24T10:43:34.000Z</published>
    <updated>2018-10-24T10:45:29.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法一：urllib2"><a href="#方法一：urllib2" class="headerlink" title="方法一：urllib2"></a>方法一：urllib2</h3><blockquote><p>结合cookielib及urllib2，Python2时期比较常用的方法，年代比较久远了。个人觉得太麻烦，改用requests.</p><p><strong>▲需要注意的是cookielib在python3中已经改成了http.cookiejar</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#该方法本人未测试</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> cookielib</span><br><span class="line"></span><br><span class="line"><span class="comment">#将cookie保存在文件中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveCookie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#设置保存cookie的文件</span></span><br><span class="line">    filename = <span class="string">'cookie.txt'</span></span><br><span class="line">    <span class="comment">#声明一个MozillaCookieJar对象来保存cookie，之后写入文件</span></span><br><span class="line">    cookie = cookielib.MozillaCookieJar(filename)</span><br><span class="line">    <span class="comment">#创建cookie处理器</span></span><br><span class="line">    handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class="line">    <span class="comment">#构建opener</span></span><br><span class="line">    opener = urllib2.build_opener(handler)</span><br><span class="line">    <span class="comment">#创建请求</span></span><br><span class="line">    res = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">    <span class="comment">#保存cookie到文件</span></span><br><span class="line">    <span class="comment">#ignore_discard的意思是即使cookies将被丢弃也将它保存下来</span></span><br><span class="line">    <span class="comment">#ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入</span></span><br><span class="line">    cookie.save(ignore_discard=<span class="keyword">True</span>,ignore_expires=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#从文件中获取cookie并且访问(我们通过这个方法就可以打开保存在本地的cookie来模拟登录)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCookie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#创建一个MozillaCookieJar对象</span></span><br><span class="line">    cookie = cookielib.MozillaCookieJar()</span><br><span class="line">    <span class="comment">#从文件中的读取cookie内容到变量</span></span><br><span class="line">    cookie.load(<span class="string">'cookie.txt'</span>,ignore_discard=<span class="keyword">True</span>,ignore_expires=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment">#打印cookie内容,证明获取cookie成功</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'name:'</span> + item.name + <span class="string">'-value:'</span> + item.value</span><br><span class="line">    <span class="comment">#利用获取到的cookie创建一个opener</span></span><br><span class="line">    handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class="line">    opener = urllib2.build_opener(handler)</span><br><span class="line">    res = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">    <span class="keyword">print</span> res.read()</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h3><blockquote><p>使用requests.cookie</p></blockquote><h5 id="读取cookies"><a href="#读取cookies" class="headerlink" title="读取cookies"></a>读取cookies</h5><p>在这里我用的是LWPCookieJar保存在txt文件中，还有个是MozillaCookieJar，都是由FileCookieJar 派生而来，实现了save()方法，而FileCookieJar 没有实现save()</p><blockquote><ul><li>MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。</li><li>LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。</li></ul></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#实例化一个LWPCookieJar对象</span><br><span class="line">load_cookiejar = cookielib.LWPCookieJar()</span><br><span class="line">#从文件中加载cookies(LWP格式)</span><br><span class="line"></span><br><span class="line">load_cookiejar.load(<span class="string">'cookies.txt'</span>, ignore_discard=True, ignore_expires=True)</span><br><span class="line">#工具方法转换成字典</span><br><span class="line">load_cookies = requests<span class="selector-class">.utils</span><span class="selector-class">.dict_from_cookiejar</span>(load_cookiejar)</span><br><span class="line">#工具方法将字典转换成RequestsCookieJar，赋值给session的cookies.</span><br><span class="line">self<span class="selector-class">.session</span><span class="selector-class">.cookies</span> = requests<span class="selector-class">.utils</span><span class="selector-class">.cookiejar_from_dict</span>(load_cookies)</span><br></pre></td></tr></table></figure><h5 id="存储cookies"><a href="#存储cookies" class="headerlink" title="存储cookies"></a>存储cookies</h5><p>将cookies转换成LWP格式然后保存为文本格式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#实例化一个LWPcookiejar对象</span><br><span class="line">new_cookie_jar = cookielib.LWPCookieJar(<span class="string">'cookie.txt'</span>)</span><br><span class="line"></span><br><span class="line">#将转换成字典格式的RequestsCookieJar（这里我用字典推导手动转的）保存到LWPcookiejar中</span><br><span class="line">===&gt;RequestsCookieJar没有实现save()方法</span><br><span class="line">requests<span class="selector-class">.utils</span><span class="selector-class">.cookiejar_from_dict</span>(&#123;c<span class="selector-class">.name</span>: c<span class="selector-class">.value</span> <span class="keyword">for</span> c <span class="keyword">in</span> self<span class="selector-class">.session</span><span class="selector-class">.cookies</span>&#125;, new_cookie_jar)</span><br><span class="line"></span><br><span class="line">#保存到本地文件</span><br><span class="line">new_cookie_jar.save(<span class="string">'cookies.txt'</span>, ignore_discard=True, ignore_expires=True)</span><br></pre></td></tr></table></figure><p><img src="/2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/Users\10630\Desktop\Txt\爬虫知识点\cookie3.jpg" alt="cookie3"></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h3><blockquote><p>将cookie字典弄成字典形式然后pickle或者json写入文件中</p></blockquote><h5 id="存储cookie"><a href="#存储cookie" class="headerlink" title="存储cookie"></a>存储cookie</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,json,pprint</span><br><span class="line">s = requests.session()</span><br><span class="line">s.headers = <span class="meta">&#123;...&#125;</span></span><br><span class="line">a = s.get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">cookies = requests.utils.dict_from_cookiejar(s.cookies)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">".\\cook.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    json.dump(cookies, fp)</span><br><span class="line">pprint.pprint(cookies,width=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h5 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(<span class="string">".\cook.txt"</span>, <span class="string">"w"</span>) as fp:</span><br><span class="line">    load_cookies=son.load(fp)</span><br><span class="line">session<span class="selector-class">.cookie</span> = requests<span class="selector-class">.utils</span><span class="selector-class">.cookiejar_from_dict</span>(load_cookies)</span><br></pre></td></tr></table></figure><p>方法四:</p><blockquote><p>将requests.cookie设置为LWPCookieJar、或MozillaCookieJar保存</p></blockquote><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session</span> = requests.Session()</span><br><span class="line"><span class="comment">#创建个 LWPCookieJar对象</span></span><br><span class="line">session.<span class="attr">cookies</span> = LWPCookieJar(<span class="attr">filename='cook.txt')</span></span><br><span class="line">s.get('https://www.baidu.com/',<span class="attr">headers=headers)</span></span><br><span class="line">session.cookies.save(<span class="attr">ignore_discard=True,</span> <span class="attr">ignore_expires=True)</span></span><br><span class="line"><span class="comment">#如果save()时没有写filename参数，则默认为实例化LWPCookieJar时给的文件名</span></span><br></pre></td></tr></table></figure><p><img src="/2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/Users\10630\Desktop\Txt\爬虫知识点\cookie4.jpg" alt="cookie4"></p><hr><h4 id="save-方法的两个重要参数"><a href="#save-方法的两个重要参数" class="headerlink" title="save()方法的两个重要参数"></a>save()方法的两个重要参数</h4><blockquote><ul><li>ignore_discard: save even cookies set to be discarded.</li><li>ignore_expires: save even cookies that have expired.The file is overwritten if it already exists</li></ul></blockquote><p><code>ignore_discard的意思是即使cookies将被丢弃也将它保存下来，ignore_expires的意思是如果cookies已经过期也将它保存并且文件已存在时将覆盖</code></p><p>总结方法二和方法三可以看出，就是要将cookie转换成然后save()</p><hr><p>简单介绍下<strong>cookielib模块</strong>作用，科普下实现cookie知识</p><blockquote><p>python3中将cookielib模块改为了http.cookiejar</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">   cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。例如可以利用本模块 的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送。coiokielib模块用到的对象主要有下面几个：CookieJar、 FileCookieJar、MozillaCookieJar、LWPCookieJar。其中他们的关系如下：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                     CookieJar                       </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                         | </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">      FileCookieJar      </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">          /                   \    </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p> MozillaCookieJar          LWPCookieJar            </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;方法一：urllib2&quot;&gt;&lt;a href=&quot;#方法一：urllib2&quot; class=&quot;headerlink&quot; title=&quot;方法一：urllib2&quot;&gt;&lt;/a&gt;方法一：urllib2&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;结合cookielib及urllib2，P
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——Session与Cookie</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94Session%E4%B8%8ECookie/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——Session与Cookie/</id>
    <published>2018-10-24T10:36:56.000Z</published>
    <updated>2018-10-24T10:41:34.630Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Session和Cookie："><a href="#Session和Cookie：" class="headerlink" title="Session和Cookie："></a>Session和Cookie：</h4><blockquote><p>Cookie：保持登录后的认证状态而保存在本地的数据</p><p>session:用cookie来标记用户，cookie携带了会话ID消息，通过检查cookie就能找到会话(session)</p></blockquote><p>cookie与session相互配合，一个处于客户端，一个处于服务端，两者相互协作。</p><h5 id="会话cookie和持久cookie"><a href="#会话cookie和持久cookie" class="headerlink" title="会话cookie和持久cookie"></a>会话cookie和持久cookie</h5><blockquote><p>会话Cookie：把cookie放在浏览器内存里，浏览器关闭后失效。</p><p>持久Cookie：保存cookie到客户端的硬盘中，下次继续使用。</p></blockquote><p>由Cookie的Max Age和Expires决定了过期的时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Session和Cookie：&quot;&gt;&lt;a href=&quot;#Session和Cookie：&quot; class=&quot;headerlink&quot; title=&quot;Session和Cookie：&quot;&gt;&lt;/a&gt;Session和Cookie：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Cooki
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——代理</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——代理/</id>
    <published>2018-10-24T10:36:28.000Z</published>
    <updated>2018-10-24T10:41:27.406Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h6 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h6><p>代理实际上指代理服务器。功能是代理 网络用户去取得网络信息，是网络信息的中转站。</p><p>正常的请求过程为：发送请求给服务器===&gt;web服务器吧响应传回</p><p>设置代理服务器后：==&gt;向代理服务器发送请求==&gt;请求发送给代理服务器==&gt;再由代理服务器发送web服务器==&gt;由代理服务器把web服务器返回的响应转发给本机</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>突破自身IP访问限制，访问些平时不能访问的站点。</p><p>访问一些单位或团体内部资源:比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</p><p>提高访问速度:通常代理服务器都设置-一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息传给用户，以提高访问速度。</p><p>隐藏真实IP:上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP,防止自身的IP被封锁。 </p><h3 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h3><h5 id="根据代理的协议，代理可以分为如下类别。"><a href="#根据代理的协议，代理可以分为如下类别。" class="headerlink" title="根据代理的协议，代理可以分为如下类别。"></a>根据代理的协议，代理可以分为如下类别。</h5><ul><li>FTP代理服务器:  主要用于访问FTP服务器，一般有上传、 下载以及缓存功能，端口一般为   21、2121等。   </li><li>HTTP代理服务器:主要用于访问网页，一般有内容过滤和缓存功能，端口一般为808080、3128 等。 </li><li>SSL/TLS代理:主要用于访同加密网站，般有 SsL 或TLS 加密功能(最高支持128位加密强度)，端口一般为443。</li><li>RTSP代理:主要用于访问Real流媒体服务器，一般有缓存功能， 端口般为554。   </li><li>Telnet代理: 主要用于tenei远程控制黑客人侵计算机时常用于隐藏身份)，端口一般为23</li><li>POP3/SMTP代理:主要用于POP3/SMTP方式收发邮件，一般有缓存功能，端口-般为1025.口SOCKS代理:只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般 有   存功能，端口一般为1080。SOCKS代理协议又分为SOCKS4和SOCKS5,前者只支持TCP而后者支持TCP和UDP，还支持各种身份验证机制、服务器端域名解析等。简单来说SOCKS4能做到的SOCKS5都可以做到，但SOCKSS能做到的SOCKS4不一定能做到。</li></ul><h5 id="2-根据匿名程度区分-根据代理的匿名程度，代理可以分为如下类别。"><a href="#2-根据匿名程度区分-根据代理的匿名程度，代理可以分为如下类别。" class="headerlink" title="2.根据匿名程度区分   根据代理的匿名程度，代理可以分为如下类别。"></a>2.根据匿名程度区分   根据代理的匿名程度，代理可以分为如下类别。</h5><ul><li><p>高度匿名代理：会将数据包原封不动地转发，在服务端看来就好像真的是一 个普通客户端访问，而记录的IP是代理服务器的IP。</p></li><li><p>普通匿名代理：会在数据包上做一些改动， 服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实IP。代理服务器通常会加人的HTTP头有HTTP_VIA和HTTP_X_FORWARDED_FOR.</p></li><li><p>透明代理：不但改动了数据包，还会告诉服务器客户端的真实IP。这种代理除了能用缓存技术调高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。</p></li><li><p>间谍代理：指组织或个人创建的用于记录用户传输的数据， 然后进行研究、监控等目的代理服务器。</p><p>常用代理设置</p></li><li><p>网上的免费代理</p></li><li><p>付费的代理服务</p></li><li><p>ADSL拨号</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;代理&quot;&gt;&lt;a href=&quot;#代理&quot; class=&quot;headerlink&quot; title=&quot;代理&quot;&gt;&lt;/a&gt;代理&lt;/h4&gt;&lt;h6 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——请求</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——请求/</id>
    <published>2018-10-24T10:36:21.000Z</published>
    <updated>2018-10-24T10:40:33.145Z</updated>
    
    <content type="html"><![CDATA[<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><blockquote><p>:请求方法、请求网址、请求头、请求体</p></blockquote><h5 id="请求方法："><a href="#请求方法：" class="headerlink" title="请求方法："></a>请求方法：</h5><blockquote><p>常见的为:GET、POST</p><p>GET与POST主要区别：</p><ul><li>GET请求参数包含在URL，可从URL中看出。POST请求的URL不包含参数，都是通过表单的形式传输的，包含在请求体中</li><li>GET请求提交的数据最多只有1024字节，POST无限制</li></ul></blockquote><p>其他还有HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE</p><h5 id="请求的网址："><a href="#请求的网址：" class="headerlink" title="请求的网址："></a>请求的网址：</h5><blockquote><p>即URL，我们想要请求的资源</p></blockquote><h5 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h5><p>用来说明服务器要使用的附加信息，比较总要的有Cookie、Referer、User-Agent等。</p><blockquote><p>Accept:请求报头域，用于指定客户端可接受哪些类型的信息。   </p><p>Accept-Language:指定客户端可接受的语言类型。</p><p>Accept-Encoding:指定客户端可接受的内容编码。   </p><p> Host:用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位   置。从HTTP1.1版本开始，请求必须包含此内容。  </p><p>Cookie:也常用复数形式Cookies, 是网站为了<u>辨别用户进行会话跟踪</u>而存储在用户<strong>本地</strong>的数据。它的主要功能是维持当前访问会话。例如，我们输人用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies 并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。   </p><p>Referer:此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、<u>防盗链处理</u>等。   </p><p>User-Agent: 简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等消息。在做爬虫时加上此信息，可以伪装成浏览器；如果不加，很可能被识别出为爬虫</p><p>Content-Type:也叫互联网媒体类型( Intermet Media Type)或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。更多对应关系可以查看此对表:<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a></p></blockquote><table><thead><tr><th>文件扩展名</th><th>Content-Type(Mime-Type)</th></tr></thead><tbody><tr><td>.html、 .htx 、 .htm</td><td>text/html</td></tr><tr><td>.gif</td><td>image/gif</td></tr><tr><td>.json</td><td>application/json</td></tr></tbody></table><p>​                    <strong>Content-Type与POST提交数据方式的关系</strong></p><table><thead><tr><th>Content-Type</th><th>提交数据的方式</th></tr></thead><tbody><tr><td>appication/x-www-urlencodeed</td><td>表单数据</td></tr><tr><td>multipart/form-data</td><td>表单文件上传</td></tr><tr><td>applicatiobn/json</td><td>序列化json数据</td></tr><tr><td>text/html</td><td>XML数据</td></tr></tbody></table><blockquote><p>如果构造POST请求，需要使用正确的Content-Type，不然可能导致POST提交后无法正常响应</p></blockquote><p>==&gt;因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p><h5 id="请求体："><a href="#请求体：" class="headerlink" title="请求体："></a>请求体：</h5><blockquote><p>请求体一般承载的内容是POST请求中的表单数据，而对GET请求，请求体则为空。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;请求&quot;&gt;&lt;a href=&quot;#请求&quot; class=&quot;headerlink&quot; title=&quot;请求&quot;&gt;&lt;/a&gt;请求&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;:请求方法、请求网址、请求头、请求体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;请求方法：&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——响应</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E5%93%8D%E5%BA%94/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——响应/</id>
    <published>2018-10-24T10:36:17.000Z</published>
    <updated>2018-10-24T10:42:19.208Z</updated>
    
    <content type="html"><![CDATA[<h4 id="响应："><a href="#响应：" class="headerlink" title="响应："></a>响应：</h4><p>响应状态码、响应头、响应体</p><h5 id="响应状态码："><a href="#响应状态码：" class="headerlink" title="响应状态码："></a>响应状态码：</h5><pre><code>表2-3常见的错误代码及错误原因</code></pre><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</td></tr><tr><td>101</td><td>切换协议</td><td>请求者已要求服务器切换协议，服务器已确认并准备切换。</td></tr><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</td></tr><tr><td>201</td><td>已创建</td><td>请求成功并且服务器创建了新的资源。</td></tr><tr><td>202</td><td>已接受</td><td>服务器已接受请求，但尚未处理。</td></tr><tr><td>203</td><td>非授权信息</td><td>服务器已成功处理了请求，但返回的信息可能来自另一来源。</td></tr><tr><td>204</td><td>无内容</td><td>服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td>205</td><td>重置内容</td><td>服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td>206</td><td>部分内容</td><td>服务器成功处理了部分 GET 请求。</td></tr><tr><td>300</td><td>多种选择</td><td>针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</td></tr><tr><td>301</td><td>永久移动</td><td>请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td></tr><tr><td>302</td><td>临时移动</td><td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td>303</td><td>查看其他位置</td><td>请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td></tr><tr><td>304</td><td>未修改</td><td>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</td></tr><tr><td>305</td><td>使用代理</td><td>请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</td></tr><tr><td>307</td><td>临时重定向</td><td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td>400</td><td>错误请求</td><td>服务器不理解请求的语法。</td></tr><tr><td>401</td><td>未授权</td><td>请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</td></tr><tr><td>403</td><td>禁止</td><td>服务器拒绝请求。</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的网页。</td></tr><tr><td>405</td><td>方法禁用</td><td>禁用请求中指定的方法。</td></tr><tr><td>406</td><td>不接受</td><td>无法使用请求的内容特性响应请求的网页。</td></tr><tr><td>407</td><td>需要代理授权</td><td>此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td></tr><tr><td>408</td><td>请求超时</td><td>服务器等候请求时发生超时。</td></tr><tr><td>409</td><td>冲突</td><td>服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。</td></tr><tr><td>410</td><td>已删除</td><td>如果请求的资源已永久删除，服务器就会返回此响应。</td></tr><tr><td>411</td><td>需要有效长度</td><td>服务器不接受不含有效内容长度标头字段的请求。</td></tr><tr><td>412</td><td>未满足前提条件</td><td>服务器未满足请求者在请求中设置的其中一个前提条件。</td></tr><tr><td>413</td><td>请求实体过大</td><td>服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</td></tr><tr><td>414</td><td>请求的 URI 过长</td><td>请求的 URI（通常为网址）过长，服务器无法处理。</td></tr><tr><td>415</td><td>不支持的媒体类型</td><td>请求的格式不受请求页面的支持。</td></tr><tr><td>416</td><td>请求范围不符合要求</td><td>如果页面无法提供请求的范围，则服务器会返回此状态代码。</td></tr><tr><td>417</td><td>未满足期望值</td><td>服务器未满足”期望”请求标头字段的要求。</td></tr><tr><td>500</td><td>服务器内部错误</td><td>服务器遇到错误，无法完成请求。</td></tr><tr><td>501</td><td>尚未实施</td><td>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理，从上游服务器收到无效响应。</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</td></tr><tr><td>504</td><td>网关超时</td><td>服务器作为网关或代理，但是没有及时从上游服务器收到请求。</td></tr><tr><td>505</td><td>HTTP 版本不受支持</td><td>服务器不支持请求中所用的 HTTP 协议版本。</td></tr></tbody></table><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><p> 响应头包含了服务器对请求的应答信息，如Cmene-Type. Serve. Set-cookie等。 下面简要说有 一些常用的头信息。 </p><ul><li>Date:标识响应产生的时间。 </li><li>Last-Modifed:指定资源的最后修改时间。 公有地会 </li><li>Content-Encoding:指定响应内容的编码。 </li><li>Server:包含服务器的信息，比如名称、版本号等。 </li><li>Content-Type:文档类型，指定返回的数据类型是什么，如texthtmI代表返回HTML文档， application/x-javascript则代表返回JavaScript文件，imagefjpeg 则代表返回图片。</li><li>Set-Cookie:设置Cookies。 响应头中的Set-Cookie 告诉浏览器需要将此内容放在Cooke 中，下次请求携带Cookies请求。</li><li>Expires:指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。立 果再次访问时，就可以直接从缓存中加载，降低服务器负载，编短加载时间。</li></ul><h5 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h5><p>最重要的当属响应体的内容了。 响应的正文数据都在响应体中，比如请求网页时，它的响应体就 是网页的HTML代码:请求一张图片时， 它的响应体就是图片的二进制数据。我们做爬虫请求后主 要解析的内容就是响应体。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;响应：&quot;&gt;&lt;a href=&quot;#响应：&quot; class=&quot;headerlink&quot; title=&quot;响应：&quot;&gt;&lt;/a&gt;响应：&lt;/h4&gt;&lt;p&gt;响应状态码、响应头、响应体&lt;/p&gt;
&lt;h5 id=&quot;响应状态码：&quot;&gt;&lt;a href=&quot;#响应状态码：&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——爬虫的基本原理</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——爬虫的基本原理/</id>
    <published>2018-10-24T10:36:10.000Z</published>
    <updated>2018-10-24T10:42:36.885Z</updated>
    
    <content type="html"><![CDATA[<h4 id="爬虫的基本原理"><a href="#爬虫的基本原理" class="headerlink" title="爬虫的基本原理"></a>爬虫的基本原理</h4><blockquote><p>爬虫就是<u>获取网页</u>并<u>提取</u>和<u>保存信息</u>的<u>自动化程序</u></p></blockquote><h5 id="获取网页："><a href="#获取网页：" class="headerlink" title="获取网页："></a>获取网页：</h5><p>获取网页就是获取网页的源码，只要把源码获取下来，就可以从中提取想要的消息</p><blockquote><p>爬虫的流程：想网站的服务器发送一个请求，返回的响应体就是网页的源代码。</p><p>​    ==&gt;1,构造请求发送给服务器===&gt;2.接受响应并解析</p></blockquote><h5 id="提取信息："><a href="#提取信息：" class="headerlink" title="提取信息："></a>提取信息：</h5><p>通过分析网页结构，提取网页信息。通常使用的解析库有:BeautifulSoup、lxml、pyquery，也可以使用正则，但是构造正则表达式比较复杂且易错</p><h5 id="保存数据："><a href="#保存数据：" class="headerlink" title="保存数据："></a>保存数据：</h5><p>将提取的数据保存到某处以便后续利用。保存形式有：TXT、Json、数据库：MySQL、MongoDB、或远程服务器SFTP…</p><h5 id="自动化程序"><a href="#自动化程序" class="headerlink" title="自动化程序"></a>自动化程序</h5><p>替人完成完成爬取工作的自动化程序，可以在抓取过程中进行异常处理……保证爬取的高效运行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;爬虫的基本原理&quot;&gt;&lt;a href=&quot;#爬虫的基本原理&quot; class=&quot;headerlink&quot; title=&quot;爬虫的基本原理&quot;&gt;&lt;/a&gt;爬虫的基本原理&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;爬虫就是&lt;u&gt;获取网页&lt;/u&gt;并&lt;u&gt;提取&lt;/u&gt;和&lt;u&gt;保存信息&lt;/u&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——URL与URI</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94URL%E4%B8%8EURI/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——URL与URI/</id>
    <published>2018-10-24T10:35:53.000Z</published>
    <updated>2018-10-24T10:41:12.634Z</updated>
    
    <content type="html"><![CDATA[<h4 id="URL与URI"><a href="#URL与URI" class="headerlink" title="URL与URI"></a>URL与URI</h4><ul><li><p>URL全称：Uniform Resource Locator(统一资源定位符)</p></li><li><p>URI全称：Uniform Resource Identifier(统一资源标识符)</p><p>如<a href="https://github.com/favicon.ico为例，它既是一个URL又是一个URI。我们通过URL/URI唯一指定了它的访问方式。其中包括访问协议https、访问路径、资源名称favicon.ico。通过这个链接提供的消息，我们就可以直接访问到此资源所在的位置。这便是URL、URI的作用。" target="_blank" rel="noopener">https://github.com/favicon.ico为例，它既是一个URL又是一个URI。我们通过URL/URI唯一指定了它的访问方式。其中包括访问协议https、访问路径、资源名称favicon.ico。通过这个链接提供的消息，我们就可以直接访问到此资源所在的位置。这便是URL、URI的作用。</a></p><blockquote><p>URL是URI的子集。===&gt;每个URL都是URI，但不是每个URI都是URL。</p><p>URI包括两个子类:URN和URL。其中URN只命名资源但不指定如何定位资源(如urn:isbn:0451450523)指定了一本书的ISBN，可以唯一标识，但未定位。</p><p>▲.目前互联网中URN用得很少，几乎所有的URI都是URL。</p></blockquote></li></ul><p><img src="/2018/10/24/Python爬虫知识点——URL与URI/URL_URI_URN.jpg" alt="URL_URI_URN"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;URL与URI&quot;&gt;&lt;a href=&quot;#URL与URI&quot; class=&quot;headerlink&quot; title=&quot;URL与URI&quot;&gt;&lt;/a&gt;URL与URI&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;URL全称：Uniform Resource Locator(统一资源定位符)&lt;/
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——Chrome开发者工具Network</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7Network/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——Chrome开发者工具Network/</id>
    <published>2018-10-24T10:35:31.000Z</published>
    <updated>2018-10-24T10:38:09.294Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Chrome开发者工具中Network功能介绍"><a href="#Chrome开发者工具中Network功能介绍" class="headerlink" title="Chrome开发者工具中Network功能介绍"></a>Chrome开发者工具中Network功能介绍</h4><ul><li>第一列Name:请求的名称，一般会将URL的最后一 部分内容当作名称。  </li><li>第二列Status: 响应的状态码，这里显示为200，代表响应是正常的。通过状态码，我们可   以判断发送了请求之后是否得到了正常的响应。   </li><li>第三列Type: 请求的文档类型。这里为document, 代表我们这次请求的是一个HTML文档,内容就是一些HTML代码。  </li><li>第四列initiator: 请求源。用来标记请求是由哪个对象或进程发起的。   </li><li>第五列Size: 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示from cache。</li><li>第六列Time:发起请求到获取响应所用的总时间。</li><li>第七列Waterfall:网络请求的可视化瀑布流。  </li></ul><p>响应中分General部分，请求头、响应头：</p><blockquote><p>其中General含：</p><ul><li>Request URL为请求的URL，</li><li>Request Method为请求的方法</li><li>Status Code为响应状态码，</li><li>Remote Address为远程服务器的地址和端口</li><li>Referrer Policy为Referrer判别策略。</li></ul></blockquote><p><img src="/2018/10/24/Python爬虫知识点——Chrome开发者工具Network/Chrome.jpg" alt="Chrome"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Chrome开发者工具中Network功能介绍&quot;&gt;&lt;a href=&quot;#Chrome开发者工具中Network功能介绍&quot; class=&quot;headerlink&quot; title=&quot;Chrome开发者工具中Network功能介绍&quot;&gt;&lt;/a&gt;Chrome开发者工具中Netwo
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>XShell通过SSH远程连接云服务器通过SSH远程连接云服务器</title>
    <link href="https://nymrli.top/2018/10/24/XShell%E9%80%9A%E8%BF%87SSH%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://nymrli.top/2018/10/24/XShell通过SSH远程连接云服务器/</id>
    <published>2018-10-24T10:32:05.000Z</published>
    <updated>2018-10-24T10:33:38.150Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-账号密码登录"><a href="#1-账号密码登录" class="headerlink" title="1.账号密码登录"></a>1.账号密码登录</h3><h5 id="法一"><a href="#法一" class="headerlink" title="法一:"></a>法一:</h5><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/1.jpg" alt="1"></p><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/2.jpg" alt="2"></p><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/3.jpg" alt="3"></p><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/4.jpg" alt="4"></p><hr><h5 id="法二"><a href="#法二" class="headerlink" title="法二:"></a>法二:</h5><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/11.jpg" alt="11"></p><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/22.jpg" alt="22"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-账号密码登录&quot;&gt;&lt;a href=&quot;#1-账号密码登录&quot; class=&quot;headerlink&quot; title=&quot;1.账号密码登录&quot;&gt;&lt;/a&gt;1.账号密码登录&lt;/h3&gt;&lt;h5 id=&quot;法一&quot;&gt;&lt;a href=&quot;#法一&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="服务器" scheme="https://nymrli.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Django邮箱</title>
    <link href="https://nymrli.top/2018/10/24/Django%E9%82%AE%E7%AE%B1/"/>
    <id>https://nymrli.top/2018/10/24/Django邮箱/</id>
    <published>2018-10-24T10:27:12.000Z</published>
    <updated>2018-10-24T10:27:52.316Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Django邮件"><a href="#Django邮件" class="headerlink" title="Django邮件"></a>Django邮件</h3><p>EmailMessage: 标题. 内容.发件人.收件人</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"></span><br><span class="line">send_mail(<span class="string">u'邮件标题'</span>, <span class="string">u'邮件内容'</span>, <span class="string">'from@example.com'</span>,</span><br><span class="line">    [<span class="string">'to@example.com'</span>], fail_silently=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><h4 id="send-mail"><a href="#send-mail" class="headerlink" title="send_mail()"></a>send_mail()</h4><blockquote><p><code>subject</code>, <code>message</code>, <code>from_email</code> and <code>recipient_list</code> 这四个参数是必须的。</p><ul><li><code>subject</code>: 字符串，表示邮件标题。</li><li><code>message</code>: 字符串，表示邮件内容。</li><li><code>from_email</code>: 字符串，表示发件邮箱。</li><li><code>recipient_list</code>: 字符串列表，列表中每个成员都是一个邮箱地址，而且每个收件人都会在 “收件人/To:” 栏看到出现在 <code>recipient_list</code> 中的其他收件人。</li><li><code>fail_silently</code>: （可选）布尔值。为 <code>False</code> 时， <code>send_mail</code> 会抛出 <a href="https://docs.python.org/2.7/library/smtplib.html#smtplib.SMTPException" target="_blank" rel="noopener"><code>smtplib.SMTPException</code></a> 异常。 <a href="https://docs.python.org/2.7/library/smtplib.html#module-smtplib" target="_blank" rel="noopener"><code>smtplib</code></a> 文档列出了所有可能的异常。 这些异常都是 <a href="https://docs.python.org/2.7/library/smtplib.html#smtplib.SMTPException" target="_blank" rel="noopener"><code>SMTPException</code></a> 的子类。</li><li><code>auth_user</code>: （可选）SMTP服务器的认证用户名。没提供该参数的情况下，Django会使用 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-EMAIL_HOST_USER" target="_blank" rel="noopener"><code>EMAIL_HOST_USER</code></a> 配置项的设置。</li><li><code>auth_password</code>: （可选）SMTP服务器的认证密码，没提供该参数的情况下，Django会使用 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-EMAIL_HOST_PASSWORD" target="_blank" rel="noopener"><code>EMAIL_HOST_PASSWORD</code></a>配置项的设置。</li><li><code>connection</code>: （可选）发送邮件的后端。没提供该参数的情况下，Django会使用默认后端的实例。可查看 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#topic-email-backends" target="_blank" rel="noopener">Email backends</a> 了解更多细节。</li></ul></blockquote><p><a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.send_mass_mail" target="_blank" rel="noopener"><code>send_mass_mail()</code></a> 和 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.send_mail" target="_blank" rel="noopener"><code>send_mail()</code></a> 的区别在于： <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.send_mail" target="_blank" rel="noopener"><code>send_mail()</code></a> 每发送一封邮件就会打开一次邮件服务器链接，而<a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.send_mass_mail" target="_blank" rel="noopener"><code>send_mass_mail()</code></a> 则是打开一次链接，发送所有的邮件。 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.send_mass_mail" target="_blank" rel="noopener"><code>send_mass_mail()</code></a> 明显更高效。</p><h3 id="main-admins"><a href="#main-admins" class="headerlink" title="main_admins()"></a>main_admins()</h3><p><code>mail_admins</code>(<em>subject</em>, <em>message</em>, <em>fail_silently=False</em>, <em>connection=None</em>, <em>html_message=None</em>)</p><p><code>django.core.mail.mail_admins()</code> 是一个给网站后台管理员(admin)发邮件的快捷方法，管理员设置放在 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-ADMINS" target="_blank" rel="noopener"><code>ADMINS</code></a> 配置项。</p><p><code>mail_admins()</code> 使用 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-EMAIL_SUBJECT_PREFIX" target="_blank" rel="noopener"><code>EMAIL_SUBJECT_PREFIX</code></a> 配置项的值做为邮件标题的前缀，默认情况下是 <code>&quot;[Django] &quot;</code> 。</p><h2 id="mail-managers"><a href="#mail-managers" class="headerlink" title="mail_managers()"></a>mail_managers()</h2><p>mail_managers`(<em>subject</em>, <em>message</em>, <em>fail_silently=False</em>, <em>connection=None</em>, <em>html_message=None</em>)</p><p>mail_managers<code>(*subject*, *message*, *fail_silently=False*, *connection=None*, *html_message=None*)</code>django.core.mail.mail_managers()<code>is just like</code>mail_admins()<code>，不同之处在于该方法的邮件接收人是网站负责人(manager)， 可以在 [</code>MANAGERS`]配置项设置网站负责人</p><h4 id="EmailMessage-对象"><a href="#EmailMessage-对象" class="headerlink" title="EmailMessage 对象"></a>EmailMessage 对象</h4><ul><li><em>class </em><code>EmailMessage</code></li></ul><p><a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.EmailMessage" target="_blank" rel="noopener"><code>EmailMessage</code></a> 类使用下列参数初始化（除非使用位置参数，否则默认顺序如下）。所有参数均可选，均可在调用 <code>send()</code>方法之前的任何时间对其赋值。</p><p>加入了 <code>cc</code> 参数（cc是抄送）</p><ul><li><p><code>subject</code>: 邮件的标题行</p></li><li><p><code>body</code>: 邮件的主体内容文本，须是纯文本信息。</p></li><li><p><code>from_email</code>: 发送者的地址。 <a href="mailto:`fred@example.com" target="_blank" rel="noopener">`fred@example.com</a><code>或</code>Fred <a href="mailto:&#102;&#x72;&#x65;&#100;&#64;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#102;&#x72;&#x65;&#100;&#64;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;</a><code>格式都是合法的。如果忽略该参数，Django就会使用 [</code>DEFAULT_FROM_EMAIL`](<a href="https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-DEFAULT_FROM_EMAIL" target="_blank" rel="noopener">https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-DEFAULT_FROM_EMAIL</a>) 配置项。</p></li><li><p><code>to</code>: 收件人地址列表或元组。</p></li><li><p><code>bcc</code>: 发送邮件时用于”Bcc”头信息的一组列表或元组，也就是暗送的收件人。</p></li><li><p><code>connection</code>: 一个邮件后端实例。用同一个链接发送多封邮件就要用到该参数。忽略该参数时，会在调用 <code>send()</code> 时自动创建一个新链接。</p></li><li><p><code>attachments</code>: 置于邮件报文内的附件列表。列表元素可以是　<code>email.MIMEBase.MIMEBase</code> 实例，也可以是 <code>(filename, content, mimetype)</code> 三部分构成的元组。</p></li><li><p><code>headers</code>: 置于邮件报文内的其他头信息(header)的字典。字典的key是头信息的名称，字典的value是头信息的值。 这样做能确保头信息的名称和对应值会以正确的格式保存于邮件报文中。</p></li><li><p><code>cc</code>: 发送邮件时放于”Cc”头信息的一系列列表或元组。</p><p>例如:</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">email = <span class="type">EmailMessage</span>(<span class="symbol">'Hello'</span>, <span class="symbol">'Body</span> goes here', <span class="symbol">'from</span>@example.com',</span><br><span class="line">            [<span class="symbol">'to1</span>@example.com', <span class="symbol">'to2</span>@example.com'], [<span class="symbol">'bcc</span>@example.com'],</span><br><span class="line">            headers = &#123;<span class="symbol">'Reply</span>-<span class="type">To'</span>: <span class="symbol">'another</span>@example.com'&#125;)</span><br></pre></td></tr></table></figure><p>该类方法如下:</p><ul><li><p><code>send(fail_silently=False)</code> 发送邮件报文。如果在构造邮件时如果指定了某个链接(connection)，就会使用该链接发邮件。 否则，就会使用默认后端的实例发邮件。如果关键字参数 <code>fail_silently</code> 为 <code>True</code> ，就会忽略邮件发送时抛出的异常。</p></li><li><p><code>message()</code> 构造了一个 <code>django.core.mail.SafeMIMEText</code> 对象 (Python的 <code>email.MIMEText.MIMEText</code> 类的子类) 或是 <code>django.core.mail.SafeMIMEMultipart</code> 对象（该对象保存即将发送出去邮件报文）。如需扩展 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.EmailMessage" target="_blank" rel="noopener"><code>EmailMessage</code></a>类，一般情况下要覆写该方法，将你所需的内容添加到MIME对象中。</p></li><li><p><code>recipients()</code> 返回邮件中所有收件人的列表，不管收件人是在 <code>to</code> 还是 <code>bcc</code> 属性中。这是另一个经常被继承覆写的方法， 因为SMTP服务器在发送邮件报文时，要接收完整的收件人列表。即使你自己的类使用其他方式来指定收件人，也仍然需要使用该方法返回收件人列表。</p></li><li><p><code>attach()</code> 创建一个新的文件附件，并把它添加到邮件报文中。 有两种方法调用 <code>attach()</code>:</p><ul><li><p>传递一个单独的 <code>email.MIMEBase.MIMEBase</code> 实例做为参数。该实例会直接添加到最终的邮件报文中。</p></li><li><p>或者，给 <code>attach()</code> 传递三个参数: <code>filename</code>, <code>content</code> 和 <code>mimetype</code>. <code>filename</code> 是出现在邮件中的附件文件的名称， <code>content</code> 是附件的内容，而 <code>mimetype</code> 是附件所使用的MIME类型。 如果忽略 <code>mimetype</code>, Django会自动根据附件文件名来推测MIME内容类型。</p><p>例如:</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.attach(<span class="symbol">'design</span>.png', img_data, <span class="symbol">'image</span>/png')</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>attach_file()</code> 使用当前文件系统下的某个文件做为附件。调用时，传入某个文件的完整路径，以及该附件的MIME类型(可选的)。 忽略MIME类型的话，Django会自动根据附件文件名来推测MIME类型。最简单的用法如下:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>.attach_file(<span class="string">'/images/weather_map.png'</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="发送多用途邮件"><a href="#发送多用途邮件" class="headerlink" title="发送多用途邮件"></a>发送多用途邮件</h4><p>在同一封邮件中包含多种版本的内容是非常有用的；典型的例子就是发送既有纯文本版本内容又有HTML版本内容的邮件。 在Django的邮件库中，可以使用 <code>EmailMultiAlternatives</code> 类来达到该目的。 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.EmailMessage" target="_blank" rel="noopener"><code>EmailMessage</code></a> 的子类有一个<code>attach_alternative()</code> 方法用来包含其他版本的邮件主体内容。所有其他方法(包括类的初始化方法)都直接继承自 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.EmailMessage" target="_blank" rel="noopener"><code>EmailMessage</code></a> 。</p><p>发送一封文本/HTML混合邮件，代码如下:</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail import EmailMultiAlternatives</span><br><span class="line"></span><br><span class="line">subject, from_email, <span class="keyword">to</span> = <span class="comment">'hello', 'from@example.com', 'to@example.com'</span></span><br><span class="line">text_content = <span class="comment">'This is an important message.'</span></span><br><span class="line">html_content = <span class="comment">'<span class="doctag">&lt;p&gt;</span>This is an <span class="doctag">&lt;strong&gt;</span>important<span class="doctag">&lt;/strong&gt;</span> message.<span class="doctag">&lt;/p&gt;</span>'</span></span><br><span class="line">msg = EmailMultiAlternatives(subject, text_content, from_email, [<span class="keyword">to</span>])</span><br><span class="line">msg.attach_alternative(html_content, <span class="string">"text/html"</span>)</span><br><span class="line">msg.send()</span><br></pre></td></tr></table></figure><p>默认情况下，<a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.EmailMessage" target="_blank" rel="noopener"><code>EmailMessage</code></a> 类中的 <code>body</code> 参数的MIME类型是 <code>&quot;text/plain&quot;</code> 。 大多数情况下，没必要更改该MIME，因为这样能保证每个收件人能够阅读该邮件，而不论他们使用的是什么邮件客户端。 不过，在能确保收件人能处理多用途邮件的情况下，可以使用:class:~django.core.mail.EmailMessage 类的 <code>content_subtype</code> 属性 来更改邮件内容类型。主类型总是 <code>&quot;text&quot;</code> ，子类型可以设置为别的版本(比如html)，例如:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = EmailMessage(subject, html_content, from_email, [<span class="keyword">to</span>])</span><br><span class="line">msg.content_subtype = <span class="string">"html"</span>  <span class="meta"># 主内体现在变成 text/html</span></span><br><span class="line">msg.<span class="built_in">send</span>()</span><br></pre></td></tr></table></figure><h4 id="获取邮件发送后端的实例"><a href="#获取邮件发送后端的实例" class="headerlink" title="获取邮件发送后端的实例"></a>获取邮件发送后端的实例</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">django.core.mail 的 get_connection() 函式返回你当前使用的邮件后端的实例。</span><br><span class="line"></span><br><span class="line">get_connection(<span class="attribute">backend</span>=None, <span class="attribute">fail_silently</span>=<span class="literal">False</span>, <span class="number">*a</span>rgs, **kwargs)</span><br></pre></td></tr></table></figure><ul><li><h4 id="SMTP-backend-–默认的后端"><a href="#SMTP-backend-–默认的后端" class="headerlink" title="SMTP backend    –默认的后端"></a>SMTP backend    –默认的后端</h4></li><li><h4 id="Console-backend"><a href="#Console-backend" class="headerlink" title="Console backend"></a>Console backend</h4></li><li><h4 id="File-backend-–该后端并不建议在生产环境下使用–它仅仅是为开发提供方便"><a href="#File-backend-–该后端并不建议在生产环境下使用–它仅仅是为开发提供方便" class="headerlink" title="File backend –该后端并不建议在生产环境下使用–它仅仅是为开发提供方便"></a>File backend –该后端并不建议在生产环境下使用–它仅仅是为开发提供方便</h4></li><li><h4 id="In-memory-backend-内存后端"><a href="#In-memory-backend-内存后端" class="headerlink" title="In-memory backend(内存后端)"></a>In-memory backend(内存后端)</h4></li><li><h4 id="Dummy-backend-空后端"><a href="#Dummy-backend-空后端" class="headerlink" title="Dummy backend(空后端)"></a>Dummy backend(空后端)</h4></li></ul><hr><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>需要一个安全的连接，例如SSL，因此接下来我们会使用SSL的方式去登录，但是在那之前，我们需要做一些准备，打开qq邮箱，点击设置-&gt;账户，找到<strong>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</strong>，开启IMAP/SMTP服务，然后根据要求使用手机发送到指定号码，获取授权码，这个<strong>授权码就是你接下来登录要使用的密码</strong>.</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">_user</span> = <span class="string">'1063052964@qq.com'</span></span><br><span class="line"><span class="variable">_pwd</span> = <span class="string">'pykhotuhghdjbeci'</span></span><br><span class="line"><span class="variable">_to</span> = <span class="string">'2035420834@qq.com'</span></span><br><span class="line">msg = MIMEText(mail_body)<span class="comment">//MIMEText中_subtype默认为plain,html格式,只需改这个参数</span></span><br><span class="line">msg[<span class="string">"Subject"</span>] = <span class="string">'来自[不吐不快]网站的网友意见'</span></span><br><span class="line">msg[<span class="string">"From"</span>] = <span class="variable">_user</span></span><br><span class="line">msg[<span class="string">"To"</span>] = <span class="variable">_to</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = smtplib.SMTP_SSL(<span class="string">"smtp.qq.com"</span>, <span class="number">465</span>)  <span class="comment">//或是使用s = smtplib.SMTP("smtp.qq.com",25)</span></span><br><span class="line">    s.login(<span class="variable">_user</span>, <span class="variable">_pwd</span>)</span><br><span class="line">    s.sendmail(<span class="variable">_user</span>, <span class="variable">_to</span>, msg.as_string())</span><br><span class="line">    s.quit()</span><br><span class="line">    message = <span class="string">'感谢你的来信'</span></span><br><span class="line">except:</span><br><span class="line">    message = <span class="string">'发送失败'</span></span><br></pre></td></tr></table></figure><p>▲smtplib.SMTP_SSL([host[, port[, local_hostname[, keyfile[, certfile[, timeout]]]]]])</p><p>这是一个派生自SMTP的子类，通过SSL加密的套接字连接（使用此类，您需要使用SSL支持编译的套接字模块）。如果未指定主机，则使用“（本地主机）”。如果省略端口，则使用标准的SMTP-over-SSL端口（465）</p><p>本机已安装了支持 SMTP 的服务，如：sendmail:</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line">from email.mime.<span class="keyword">text</span> <span class="keyword">import</span> MIMEText</span><br><span class="line">from email.header <span class="keyword">import</span> Header</span><br><span class="line">message[<span class="string">'From'</span>] = Header(<span class="string">"菜鸟教程"</span>, <span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><p>第三方SMTP发送邮件:</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr</span><br><span class="line">msg[<span class="string">'From'</span>]=formataddr([<span class="string">"FromRunoob"</span>,my_sender])  # 括号里的对应发件人邮箱昵称、发件人邮箱账号</span><br><span class="line">msg[<span class="string">'To'</span>]=formataddr([<span class="string">"FK"</span>,my_user])              # 括号里的对应收件人邮箱昵称、收件人邮箱账号</span><br><span class="line">*没有formataddr的昵称默认为账号*</span><br></pre></td></tr></table></figure><h4 id="Python-发送带附件的邮件"><a href="#Python-发送带附件的邮件" class="headerlink" title="Python 发送带附件的邮件:"></a>Python 发送带附件的邮件:</h4><blockquote><p>发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"> </span><br><span class="line">sender = <span class="string">'from@runoob.com'</span></span><br><span class="line">receivers = [<span class="string">'429240967@qq.com'</span>]  <span class="comment"># 接收邮件，可设置为你的QQ邮箱或者其他邮箱</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#创建一个带附件的实例</span></span><br><span class="line">message = MIMEMultipart()</span><br><span class="line">message[<span class="string">'From'</span>] = Header(<span class="string">"菜鸟教程"</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">message[<span class="string">'To'</span>] =  Header(<span class="string">"测试"</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">subject = <span class="string">'Python SMTP 邮件测试'</span></span><br><span class="line">message[<span class="string">'Subject'</span>] = Header(subject, <span class="string">'utf-8'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#邮件正文内容</span></span><br><span class="line">message.attach(MIMEText(<span class="string">'这是菜鸟教程Python 邮件发送测试……'</span>, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 构造附件1，传送当前目录下的 test.txt 文件</span></span><br><span class="line">att1 = MIMEText(open(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>).read(), <span class="string">'base64'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">att1[<span class="string">"Content-Type"</span>] = <span class="string">'application/octet-stream'</span></span><br><span class="line"><span class="comment"># 这里的filename可以任意写，写什么名字，邮件中显示什么名字</span></span><br><span class="line">att1[<span class="string">"Content-Disposition"</span>] = <span class="string">'attachment; filename="test.txt"'</span></span><br><span class="line">message.attach(att1)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 构造附件2，传送当前目录下的 runoob.txt 文件</span></span><br><span class="line">att2 = MIMEText(open(<span class="string">'runoob.txt'</span>, <span class="string">'rb'</span>).read(), <span class="string">'base64'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">att2[<span class="string">"Content-Type"</span>] = <span class="string">'application/octet-stream'</span></span><br><span class="line">att2[<span class="string">"Content-Disposition"</span>] = <span class="string">'attachment; filename="runoob.txt"'</span></span><br><span class="line">message.attach(att2)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    smtpObj = smtplib.SMTP(<span class="string">'localhost'</span>)</span><br><span class="line">    smtpObj.sendmail(sender, receivers, message.as_string())</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"邮件发送成功"</span></span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Error: 无法发送邮件"</span></span><br></pre></td></tr></table></figure><h4 id="在-HTML-文本中添加图片"><a href="#在-HTML-文本中添加图片" class="headerlink" title="在 HTML 文本中添加图片"></a>在 HTML 文本中添加图片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"> </span><br><span class="line">sender = <span class="string">'from@runoob.com'</span></span><br><span class="line">receivers = [<span class="string">'429240967@qq.com'</span>]  <span class="comment"># 接收邮件，可设置为你的QQ邮箱或者其他邮箱</span></span><br><span class="line"> </span><br><span class="line">msgRoot = MIMEMultipart(<span class="string">'related'</span>)//创建MIMEMultipart()实例</span><br><span class="line">msgRoot[<span class="string">'From'</span>] = Header(<span class="string">"菜鸟教程"</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">msgRoot[<span class="string">'To'</span>] =  Header(<span class="string">"测试"</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">subject = <span class="string">'Python SMTP 邮件测试'</span></span><br><span class="line">msgRoot[<span class="string">'Subject'</span>] = Header(subject, <span class="string">'utf-8'</span>)</span><br><span class="line"> </span><br><span class="line">msgAlternative = MIMEMultipart(<span class="string">'alternative'</span>)</span><br><span class="line">msgRoot.attach(msgAlternative)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">mail_msg = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;&lt;a href="http://www.runoob.com"&gt;菜鸟教程链接&lt;/a&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;图片演示：&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;&lt;img src="cid:image1"&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">msgAlternative.attach(MIMEText(mail_msg, <span class="string">'html'</span>, <span class="string">'utf-8'</span>))//内容</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定图片为当前目录</span></span><br><span class="line">fp = open(<span class="string">'test.png'</span>, <span class="string">'rb'</span>)</span><br><span class="line">msgImage = MIMEImage(fp.read())</span><br><span class="line">fp.close()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义图片 ID，在 HTML 文本中引用</span></span><br><span class="line">msgImage.add_header(<span class="string">'Content-ID'</span>, <span class="string">'&lt;image1&gt;'</span>)</span><br><span class="line">msgRoot.attach(msgImage)//附件</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    smtpObj = smtplib.SMTP(<span class="string">'localhost'</span>)</span><br><span class="line">    smtpObj.sendmail(sender, receivers, msgRoot.as_string())</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"邮件发送成功"</span></span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Error: 无法发送邮件"</span></span><br></pre></td></tr></table></figure><h5 id="Python-SMTP发送邮件"><a href="#Python-SMTP发送邮件" class="headerlink" title="Python SMTP发送邮件"></a><a href="http://www.runoob.com/python/python-email.html" target="_blank" rel="noopener">Python SMTP发送邮件</a></h5><h4 id="需要在-settings-py中设置的东西"><a href="#需要在-settings-py中设置的东西" class="headerlink" title="需要在 settings.py中设置的东西:"></a>需要在 settings.py中设置的东西:</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">EMAIL_BACKEND</span> = <span class="string">'django.core.mail.backends.smtp.EmailBackend'</span></span><br><span class="line"><span class="attr">EMAIL_USE_SSL</span> = <span class="literal">True</span></span><br><span class="line"><span class="attr">EMAIL_HOST</span> = <span class="string">'smtp.gmail.com'</span></span><br><span class="line"><span class="attr">EMAIL_PORT</span> = <span class="number">587</span></span><br><span class="line"><span class="attr">EMAIL_HOST_USER</span> = <span class="string">'urusername@gmail.com'</span></span><br><span class="line"><span class="attr">EMAIL_HOST_PASSWORD</span> = <span class="string">'password'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Django邮件&quot;&gt;&lt;a href=&quot;#Django邮件&quot; class=&quot;headerlink&quot; title=&quot;Django邮件&quot;&gt;&lt;/a&gt;Django邮件&lt;/h3&gt;&lt;p&gt;EmailMessage: 标题. 内容.发件人.收件人&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="后端" scheme="https://nymrli.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Django" scheme="https://nymrli.top/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>复制Django项目时需要注意、修改的地方</title>
    <link href="https://nymrli.top/2018/10/24/%E5%A4%8D%E5%88%B6Django%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E3%80%81%E4%BF%AE%E6%94%B9%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
    <id>https://nymrli.top/2018/10/24/复制Django项目时需要注意、修改的地方/</id>
    <published>2018-10-24T10:25:37.000Z</published>
    <updated>2018-10-24T10:26:19.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="复制Django项目"><a href="#复制Django项目" class="headerlink" title="复制Django项目:"></a>复制Django项目:</h3><blockquote><p>manage.py中需要修改的地方</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os<span class="selector-class">.environ</span><span class="selector-class">.setdefault</span>(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"window.settings"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>settings.py中需要修改的地方</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Django settings for window project.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">ROOT_URLCONF = <span class="string">'window.urls'</span></span><br><span class="line">WSGI_APPLICATION = <span class="string">'window.wsgi.application'</span></span><br></pre></td></tr></table></figure><blockquote><p>urls.py中需要改动的地方</p></blockquote><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""window URL Configuration</span></span><br></pre></td></tr></table></figure><blockquote><p>wsgi.py中需要修改的地方</p></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>"</span><br><span class="line">WSGI config <span class="keyword">for</span> <span class="keyword">window</span> project.</span><br><span class="line">os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"window.settings"</span>)</span><br></pre></td></tr></table></figure><h4 id="django可复用模板"><a href="#django可复用模板" class="headerlink" title="django可复用模板"></a>django可复用模板</h4><blockquote><p>在project_name文件下的*.py</p><p>再在终端键入django-admin startproject xx –template=<em>  (</em>为文件夹中py文件名)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line">DEBUG = os.environ.get(<span class="string">'DEBUG'</span>,<span class="string">'on'</span>)== <span class="string">'on'</span></span><br><span class="line">ALLOW_HOSTS = [<span class="string">'*'</span>]</span><br><span class="line">SECRET_KEY = os.environ.get(<span class="string">'SECRET'</span>,<span class="string">'&#123;&#123; secret_key &#125;&#125;'</span>)</span><br><span class="line">settings.configure(</span><br><span class="line">    DEBUG = DEBUG,</span><br><span class="line">    ALLOW_HOSTS = ALLOW_HOSTS,</span><br><span class="line">    SECRET_KEY = SECRET_KEY,</span><br><span class="line">    ROOT_URLCONF = __name__,</span><br><span class="line">    MIDDLEWARE_CLASSES = (</span><br><span class="line">        <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">        <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">        <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> django.core.wsgi <span class="keyword">import</span> get_wsgi_application</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Hello Word'</span>)</span><br><span class="line"></span><br><span class="line">urlpatterns = (</span><br><span class="line">   url(<span class="string">r'$'</span>,index),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">application = get_wsgi_application()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> django.core.management <span class="keyword">import</span> execute_from_command_line</span><br><span class="line"></span><br><span class="line">    execute_from_command_line(sys.argv)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;复制Django项目&quot;&gt;&lt;a href=&quot;#复制Django项目&quot; class=&quot;headerlink&quot; title=&quot;复制Django项目:&quot;&gt;&lt;/a&gt;复制Django项目:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;manage.py中需要修改的地方&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="后端" scheme="https://nymrli.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Django" scheme="https://nymrli.top/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>网络宽带和网络延迟</title>
    <link href="https://nymrli.top/2018/10/24/%E7%BD%91%E7%BB%9C%E5%AE%BD%E5%B8%A6%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F/"/>
    <id>https://nymrli.top/2018/10/24/网络宽带和网络延迟/</id>
    <published>2018-10-24T08:42:27.000Z</published>
    <updated>2018-10-24T08:44:50.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络宽带和网络延迟"><a href="#网络宽带和网络延迟" class="headerlink" title="网络宽带和网络延迟"></a>网络宽带和网络延迟</h3><p><strong>网络带宽，网络延迟是2个概念（网络延迟往往更容易被忽略！）</strong></p><p>国内大陆 建立在互联网基础上 很多对延迟性要求比较高的应用，体验效果都不如人意。比如高清晰度网络电视、在线视频语音实时业务（qq、skype） 某些在线游戏 等等。<br>最简单的例子：如果ping某个网站，高于50ms的网站，打开就慢。10-30ms的网站，打开就比较快。<br>如果都是同一个宽带服务商，即使升级到10M 20M 100M的宽带，这种网络延迟情况，短时间内应该也不会有改善</p><p>1、“下载电影这种活儿就看带宽，不在乎服务器发出数据后晚几秒钟收到，传输层有“窗口协议”，不必等到上一段数据的应答再传下一段数据，可以看做是一种“异步应用”。一般说，交互性的应用比较讲究低延迟，我用“同步应用”来描述之。同步应用别说晚几秒钟，就是晚0.1秒收到数据，影响也很大,如<br>a、比如fps游戏会觉得很不爽，明明瞄准了怎么打不到。<br>b、至于视频语音等，对带宽、延迟都有一定要求，带宽太小无法传输清晰的图像和声音，延迟太大你一句话“我爱你”，对方的mm没有任何反应……<br>另外还有一个指标是抖动，通俗说是数据能不能平稳传输，还是一会儿快一会儿慢一会儿堵塞。”    </p><p>  2、理论上说，带宽越大，在网络拓扑中的优先级就越高，所对应的响应速度就越快，对于用户和ISP之间来说带宽越高，每秒传输的数据越多，延迟就越小。但是延迟高低是由很多个因素决定的，网络上的每一个服务器（路由器）都是一个节点，所有的节点加在一起的响应速度，才是你的网络延迟，如果某一中间节点出现出题，无法提供服务，其它节点就会重新计算路由，但是重新计算路由之前会有一个超时记时器，只有目的节点的响应时间超出记时器时才会重新进行路由计算。还有DNS服务器的影响等等，</p><p>所以把网络带宽和网络延迟扯在一起谈是没用的，ISP只能保证你的接入网络带宽和网络延迟无问题，与其它节点的服务就没法保证了。（世界上最远的距离不是天涯和海角，而是电信和网通）”  </p><p>3、“任何FPS游戏，网络条件是最关键的——到服务器的ping稳定性和延迟时间，对战绩的影响最大。<br>比如ping服务器5分钟，延迟ms数一直不变，或者误差不超过5%，随便什么FPS，哪怕你从没玩过没有经验不熟悉地图和武器，你的成绩也差不了。<br>如果这ms数比多数人还少，那你更屌了。</p><p>  ADSL线路分交织模式interleave和快速模式fast,区别在于交织模式在本地会对数据包进行纠错加密，因此可保证线路的稳定，当然相应的延迟就会上升，电信提供的线路默认也都是交织模式，于是有种减低延迟的方法就是让电信帮你线路改成FAST,当然随之而来的问题是可能导致线路的不稳定，尤其是家里离接入网机房比较远的情况。</p><p>延迟这个问题只要是网络都会存在,差别在于大小,标志着整个架构的合理性和完善性。可以简单的认为带宽相当于马路上的车道数量，延迟就相当于堵塞的程度。因此，营运商即使是相同带宽的情况下对延迟不同的线路收费也是不同的。当然一般家庭用户是不会享受这个的。  </p><h4 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h4><p>ADSL（Asymmetric Digital Subscriber Loop）技术是一种不对称数字用户线实现宽带接入互连网的技术。</p><p>实际<a href="https://www.baidu.com/s?wd=%E4%BC%A0%E8%BE%93%E9%80%9F%E5%BA%A6&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">传输速度</a>也要分上行和下行，上行速率就是发送出去数据的速度(上传速度)，下行就是收到数据的速度(下载速度).</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>带宽代表一定时间内能运多少货。</li></ul><p>延迟代表货物运输时间。<br>比如万吨轮就是属于大带宽，高延迟。<br>私人飞机属于低延迟，小带宽。<br>比如都给一个月的时间，万吨轮拉的东西肯定比私人飞机多,如果土豪做生意，血汗工厂t恤运去去美国，肯定用轮船，对带宽敏感，对延迟不敏感的业务。<br>但是如果土豪要移植肾了，这玩意路上放久会臭，就属于对延迟比较敏感的应用，还是用私人飞机运比较好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网络宽带和网络延迟&quot;&gt;&lt;a href=&quot;#网络宽带和网络延迟&quot; class=&quot;headerlink&quot; title=&quot;网络宽带和网络延迟&quot;&gt;&lt;/a&gt;网络宽带和网络延迟&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;网络带宽，网络延迟是2个概念（网络延迟往往更容易被忽略！）&lt;/str
      
    
    </summary>
    
    
      <category term="计算机知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>linux下apt-get介绍</title>
    <link href="https://nymrli.top/2018/10/24/linux%E4%B8%8Bapt-get%E4%BB%8B%E7%BB%8D/"/>
    <id>https://nymrli.top/2018/10/24/linux下apt-get介绍/</id>
    <published>2018-10-24T08:42:20.000Z</published>
    <updated>2018-11-01T10:43:58.481Z</updated>
    
    <content type="html"><![CDATA[<h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h3><blockquote><p>Advanced Package Tool又名apt-get，是一条<a href="https://baike.baidu.com/item/linux%E5%91%BD%E4%BB%A4/1750369" target="_blank" rel="noopener">linux命令</a>，适用于deb包管理式的操作系统如<a href="https://baike.baidu.com/item/Unix" target="_blank" rel="noopener">Unix</a>和<a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>系统的应用程序管理器，主要用于自动从互联网的软件仓库中搜索、安装、升级、<a href="https://baike.baidu.com/item/%E5%8D%B8%E8%BD%BD" target="_blank" rel="noopener">卸载</a>软件或操作系统。</p></blockquote><p>rpm包和deb包是两种<a href="https://www.baidu.com/s?wd=Linux%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Linux系统</a>下最常见的安装包格式，在安装一些软件或服务的时候免不了要和它们打交道。rpm包主要应用在RedHat系列包括 Fedora等发行版的<a href="https://www.baidu.com/s?wd=Linux%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Linux系统</a>上，deb包主要应用于Debian系列包括现在比较流行的Ubuntu等发行版上。</p><p>我们知道如果要安装现成的这两种包的话，安装rpm包的命令是“rpm -参数”，安装deb包的命令是“dpkg -参数”。而<a href="https://www.baidu.com/s?wd=Linux%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Linux系统</a>很方便和人性化的一点就是很多软件或服务根本就不用我们去下载，直接使用相应的命令就可以管理了，可能这就是传说中的 “云”的概念。</p><ul><li>yum可以用于运作rpm包，例如在Fedora系统上对某个软件的管理：<br>安装：yum install &lt;package_name&gt;<br>卸载：yum remove &lt;package_name&gt;<br>更新：yum update &lt;package_name&gt;</li><li>apt-get可以用于运作deb包，例如在<a href="https://www.baidu.com/s?wd=Ubuntu%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Ubuntu系统</a>上对某个软件的管理：<br>安装：apt-get install &lt;package_name&gt;<br>卸载：apt-get remove &lt;package_name&gt;<br>更新：apt-get update &lt;package_name&gt;  </li></ul><p>▲.apt-get命令一般需要<a href="https://baike.baidu.com/item/root%E6%9D%83%E9%99%90" target="_blank" rel="noopener">root权限</a>执行，所以一般跟着sudo命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line"><span class="meta">#</span><span class="bash">1、apt-get update是同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2、apt-get update只是更新了apt的资源列表，没有真正的对系统执行更新。如果需要，要使用apt-get upgrade来更新。</span></span><br><span class="line"></span><br><span class="line">apt-get upgrade</span><br><span class="line"><span class="meta">#</span><span class="bash">可以使用这条命令更新软件包，apt-get upgrade不仅可以从相同版本号的发布版中更新软件包，也可以从新版本号的发布版中更新软件包，尽管实现后一种更新的推荐命令为apt-get dist-upgrade(将系统升级到新版本)。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">总结:</span></span><br><span class="line">▲ apt-get update 是更新本地软件列表，在线安装的时候可以在软件列表找到软件；</span><br><span class="line">  apt-get upgrade 是更新本地已安装的软件，要谨慎执行。</span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash">dpkg -l</span></span><br><span class="line"><span class="meta">#</span><span class="bash">列出所有已安装的软件包。</span></span><br></pre></td></tr></table></figure><h3 id="在Ubuntu中，有时候运用sudo-apt-get-install-安装软件时，会出现一下的情况"><a href="#在Ubuntu中，有时候运用sudo-apt-get-install-安装软件时，会出现一下的情况" class="headerlink" title="在Ubuntu中，有时候运用sudo  apt-get install 安装软件时，会出现一下的情况"></a>在Ubuntu中，有时候运用sudo  apt-get install 安装软件时，会出现一下的情况</h3><blockquote><p>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)<br>E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?</p></blockquote><p>主要是因为apt还在运行,解决方案是</p><h5 id="1-找到并且杀掉所有的apt-get-和apt进程"><a href="#1-找到并且杀掉所有的apt-get-和apt进程" class="headerlink" title="1.找到并且杀掉所有的apt-get 和apt进程"></a>1.找到并且杀掉所有的apt-get 和apt进程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps -A | grep apt</span><br><span class="line">找出所有的 apt 以及 apt-get 进程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">kill</span> -9 processnumber 或者$ sudo <span class="built_in">kill</span> -SIGKILL processnumber</span></span><br><span class="line">比如，下面命令中的9是 SIGKILL 的信号数，它会杀掉第一个 apt 进程$ sudo kill -9 进程ID 或者$ sudo kill -SIGKILL 进程ID</span><br></pre></td></tr></table></figure><h5 id="2、删除锁定文件"><a href="#2、删除锁定文件" class="headerlink" title="2、删除锁定文件"></a>2、删除锁定文件</h5><p>锁定的文件会阻止 Linux 系统中某些文件或者数据的访问，这个概念也存在于 Windows 或者其他的操作系统中。</p><blockquote><p>一旦你运行了 apt-get 或者 apt 命令，锁定文件将会创建于 /var/lib/apt/lists/、/var/lib/dpkg/、/var/cache/apt/archives/ 中。</p></blockquote><p>这有助于运行中的 apt-get 或者 apt 进程能够避免被其它需要使用相同文件的用户或者系统进程所打断。当该进程执行完毕后，锁定文件将会删除。</p><p>当你没有看到 apt-get 或者 apt 进程的情况下在上面两个不同的文件夹中看到了锁定文件，这是因为进程由于某个原因被杀掉了，因此你需要删除锁定文件来避免该错误。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">首先运行下面的命令来移除 /var/lib/dpkg/ 文件夹下的锁定文件：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm /var/lib/dpkg/lock</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">之后像下面这样强制重新配置软件包：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg --configure -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">也可以删除 /var/lib/apt/lists/ 以及缓存文件夹下的锁定文件：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm /var/lib/apt/lists/lock</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm /var/cache/apt/archives/lock</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">接下来，更新你的软件包源列表：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update或者$ sudo apt-get update</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;apt-get&quot;&gt;&lt;a href=&quot;#apt-get&quot; class=&quot;headerlink&quot; title=&quot;apt-get&quot;&gt;&lt;/a&gt;apt-get&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Advanced Package Tool又名apt-get，是一条&lt;a 
      
    
    </summary>
    
    
      <category term="linux" scheme="https://nymrli.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>python中关于round函数的注意事项</title>
    <link href="https://nymrli.top/2018/10/18/python%E4%B8%AD%E5%85%B3%E4%BA%8Eround%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://nymrli.top/2018/10/18/python中关于round函数的注意事项/</id>
    <published>2018-10-18T03:37:00.000Z</published>
    <updated>2018-10-18T03:37:23.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python中关于round函数的注意事项"><a href="#python中关于round函数的注意事项" class="headerlink" title="python中关于round函数的注意事项"></a>python中关于round函数的注意事项</h3><blockquote><p>round函数很简单，对浮点数进行近似取值，保留几位小数。</p></blockquote><p>比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">10.0</span>/<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">3.33</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">20</span>/<span class="number">7</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">#第一个参数是一个浮点数，第二个参数是保留的小数位数，可选，如果不写的话默认保留到整数。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[round]函数文档-py3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">round</span><span class="params">(number, ndigits=None)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    round(number[, ndigits]) -&gt; number</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Round a number to a given precision in decimal digits (default 0 digits).</span></span><br><span class="line"><span class="string">    This returns an int when called with one argument, otherwise the</span></span><br><span class="line"><span class="string">    same type as the number. ndigits may be negative.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>翻译一下什么意思呢?: 将数字四舍五入到给定精度,如果不给第二个精度参数的话就默认保留到0位(即整数)</p></blockquote><h4 id="这么简单的函数，能有什么坑呢？"><a href="#这么简单的函数，能有什么坑呢？" class="headerlink" title="这么简单的函数，能有什么坑呢？"></a>这么简单的函数，能有什么坑呢？</h4><p><strong>1、round的结果跟python版本有关</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-------python2---------</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.5</span>)</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#======python3==========</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.5</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>原因在于:</p><p>在python2.7的doc中，round()的最后写着，“Values are rounded to the closest multiple of 10 to the power minus <em>ndigits</em>; if two multiples are equally close, rounding is done away from 0.” 保留值将保留到离上一位更近的一端（四舍六入），<u>如果距离两端一样远，则保留到离0远的一边</u>。所以round(0.5)会近似到1，而round(-0.5)会近似到-1。</p><p>但是到了python3.5的doc中，文档变成了“values are rounded to the closest multiple of 10 to the power minus <em>ndigits</em>; if two multiples are equally close, rounding is done toward the even choice.” <u>如果距离两边一样远，会保留到偶数的一边</u>。比如round(0.5)和round(-0.5)都会保留到0，而round(1.5)会保留到2。</p></blockquote><p><strong>然而需要注意的是</strong></p><p><strong>2、特殊数字round出来的结果可能未必是想要的。</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; round(<span class="number">2.675</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">2.67</span></span><br></pre></td></tr></table></figure><p>官方举例:python2和python3的doc</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note</span><br><span class="line"></span><br><span class="line">The behavior <span class="keyword">of</span> <span class="built_in">round</span>() <span class="keyword">for</span> floats can be surprising: <span class="keyword">for</span> example, <span class="built_in">round</span>(<span class="number">2.675</span>, <span class="number">2</span>) gives <span class="number">2.67</span> instead <span class="keyword">of</span> <span class="keyword">the</span> expected <span class="number">2.68</span>. This is <span class="keyword">not</span> <span class="keyword">a</span> bug: <span class="keyword">it</span>’s <span class="keyword">a</span> <span class="built_in">result</span> <span class="keyword">of</span> <span class="keyword">the</span> fact that most decimal fractions can’t be represented exactly <span class="keyword">as</span> <span class="keyword">a</span> float. See Floating Point Arithmetic: Issues <span class="keyword">and</span> Limitations <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure><p>简单的说就是，round(2.675, 2) 的结果，不论我们从python2还是3来看，结果都应该是2.68的，结果它偏偏是2.67，为什么？这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串1和0后可能是无限位数的，机器已经做出了截断处理)。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离2.67要更近一点点，所以保留两位小数时就近似到了2.67。</p><p><strong>例子</strong>2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">123.45</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">123.5</span></span><br></pre></td></tr></table></figure><p>意思就是说计算机需要先将十进制123.45转换为二进制,这个过程会导致二进制的值比123.45略大(比如123.45000001之类的),那么自然就得到123.5这个值了.</p><hr><p>以上。除非对精确度没什么要求，否则尽量避开用round()函数。近似计算我们还有其他的选择：</p><ol><li><ul><li>使用math模块中的一些函数，比如math.ceiling（天花板除法）。</li></ul></li><li><ul><li>python自带整除，python2中是/，3中是//，还有div函数。</li></ul></li><li><ul><li>字符串格式化可以做截断使用，例如 “%.2f” % value（保留两位小数并变成字符串……如果还想用浮点数请披上float()的外衣）。</li></ul></li><li><ul><li>当然，对浮点数精度要求如果很高的话，请用嘚瑟馍，不对不对，请用decimal模块。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python中关于round函数的注意事项&quot;&gt;&lt;a href=&quot;#python中关于round函数的注意事项&quot; class=&quot;headerlink&quot; title=&quot;python中关于round函数的注意事项&quot;&gt;&lt;/a&gt;python中关于round函数的注意事项&lt;/
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
</feed>
