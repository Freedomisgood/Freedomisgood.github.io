<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>细品单例模式 · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">细品单例模式</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2020/12/11</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="计算机基础知识"> 计算机基础知识</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">4,399</span> | Reading time: <span class="post-count">17</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>虽然还没正式踏入开发就业浪潮中，但为了保证自己的代码质量，最近还是在学设计模式相关内容。以下为读《研磨设计模式》和《设计模式就该这样学：基于经典框架源码和真实业务场景》的读书笔记。</p>
<blockquote>
<p>GoF的《设计模式》就是设计模式的始祖、经典教科书。其描述严谨，举例恰当，分类组织，是应该反复细读的经典，两本书皆提及了GoF这本书，引用了GoF中的部分例子。</p>
</blockquote>
<h1 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h1>
<h2 id="虚拟场景"><a class="markdownIt-Anchor" href="#虚拟场景"></a> 虚拟场景：</h2>
<p>读取配置文件的内容（假设系统采用的是properties格式的配置文件）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.dp.singleton.example1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用来存放配置文件中参数A的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String parameterA;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用来存放配置文件中参数B的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String parameterB;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getParameterA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> parameterA;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getParameterB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> parameterB;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AppConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//调用读取配置文件的方法</span></span><br><span class="line">		readConfig();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 读取配置文件，把配置文件中的内容读出来设置到属性上</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Properties p = <span class="keyword">new</span> Properties(); </span><br><span class="line">		InputStream in = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			in = AppConfig.class.getResourceAsStream(<span class="string">"AppConfig.properties"</span>);</span><br><span class="line">			p.load(in);</span><br><span class="line">			<span class="comment">//把配置文件中的内容读出来设置到属性上</span></span><br><span class="line">			<span class="keyword">this</span>.parameterA = p.getProperty(<span class="string">"paramA"</span>);</span><br><span class="line">			<span class="keyword">this</span>.parameterB = p.getProperty(<span class="string">"paramB"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"装载配置文件出错了，具体堆栈信息如下："</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				in.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="存在的问题"><a class="markdownIt-Anchor" href="#存在的问题"></a> 存在的问题：</h2>
<p>系统运行期间，如果存在很多个AppConfig的实例对象即配置内容，会严重浪费内存资源。实际上，对于AppConfig这种类<strong>在运行期间只要一个实例对象就够了</strong>。===&gt;单例模式</p>
<blockquote>
<p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<h2 id="单例实现思路"><a class="markdownIt-Anchor" href="#单例实现思路"></a> 单例实现思路：</h2>
<p>一个类能够被创建多个实例的问题根源在于类的构造方法是公开的，也就是可以让类的外部通过构造方法来创建多个实例。换句话说，只要类的构造方法能让类的外部访问，就没有办法去控制外部来创建这个类的实例个数。要想控制一个类只被创建一个实例，那么首要的问题就是要把<strong>创建实例的权限收回来，让类自身来负责自己类实例的创建工作</strong>，然后由这个类来提供外部可以访问这个类实例的方法，这就是单例模式的实现方式。</p>
<h2 id="单例模式的结构和说明"><a class="markdownIt-Anchor" href="#单例模式的结构和说明"></a> 单例模式的结构和说明：</h2>
<p><img src="/2020/12/11/细品单例模式/%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="结构图"></p>
<p>Singleton：私有化构造函数来隐藏构造，从而自己负责创建Singleton类自己的唯一实例，并提供一个getlnstance的方法，让外部来访问这个类的唯一实例。</p>
<h2 id="基础级单例"><a class="markdownIt-Anchor" href="#基础级单例"></a> 基础级单例</h2>
<h3 id="饿汉式"><a class="markdownIt-Anchor" href="#饿汉式"></a> 饿汉式</h3>
<blockquote>
<p>所谓饿汉式，既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在<strong>装载类的时候就创建对象实例</strong>，写法如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现方式"><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式：</h4>
<ol>
<li>私有化构造方法</li>
<li>提供获取实例的方法getInstance</li>
<li>把获取实例的方法变成静态方法</li>
<li>定义存储实例的属性(成员变量)instance</li>
<li>将实例成员变量instance定义为静态的（由于要在静态方法中使用，被迫写成static，没用到static特性）</li>
<li>从而实现控制实例的创建</li>
</ol>
<h3 id="懒汉式"><a class="markdownIt-Anchor" href="#懒汉式"></a> 懒汉式</h3>
<blockquote>
<p>所谓懒汉式，既然是<strong>懒</strong>，那么在创建对象实例的时候就不着急，<strong>会一直等到马上要使用对象实例的时候才会创建</strong>，懒人嘛，总是推托不开的时候才去真正执行工作，因此在装载对象的时候不创建对象实例，写法如下：</p>
<p>懒汉式体现了延迟加载的思想，lazy load，这个lazy并不是懒惰的意思，而是延迟的意思，Lazy load在实际开发中是种很常见的思想，可以尽可能的节约资源。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义一个变量来存储创建好的类实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ▲私有化构造方法，将构造方法权限回收，好在内部控制创建实例的数目</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义一个方法来为客户端提供类实例， 提供访问方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 一个Singleton的实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现方式-2"><a class="markdownIt-Anchor" href="#实现方式-2"></a> 实现方式：</h4>
<ol>
<li>私有化构造方法</li>
<li>提供获取实例的方法getInstance</li>
<li>把获取实例的方法变成静态方法</li>
<li>定义存储实例的属性(成员变量)instance</li>
<li>将实例成员变量instance定义为静态的（利用static在类装载的时候执行的特性，从而实现初始化）</li>
<li>从而实现控制实例的创建</li>
</ol>
<p>🎯以上两种就是最基础的单例写法，在不考虑复杂的条件下仅是满足了定义所要求的功能：运行期间只会被创建一个实例，切提供了一个全局唯一访问点（即getInstance方法）</p>
<h3 id="优缺点分析"><a class="markdownIt-Anchor" href="#优缺点分析"></a> 优缺点分析：</h3>
<ul>
<li>时间和空间：
<ul>
<li>饿汉：空间换时间，类加载时就创建。因此当系统有大量单例对象存在时，系统初始化就会造成大量的内存浪费</li>
<li>懒汉：时间换空间，每次获取时都需要判断是否需要创建实例</li>
</ul>
</li>
<li>线程安全：
<ul>
<li>饿汉：线程安全，因为虚拟机保证智慧加载以此类推，并且加载类的时候不会并发发生。</li>
<li>懒汉：需要加上synchronized关键字才能确认线程安全，但synchronized加在方法上会比较影响性能，导致大批量线程阻塞，从而导致程序性能大幅下降</li>
</ul>
</li>
</ul>
<h2 id="双重检查锁"><a class="markdownIt-Anchor" href="#双重检查锁"></a> 双重检查锁</h2>
<blockquote>
<p>为了保证加载时的性能-&gt;即不能采用饿汉，而是得采用懒汉lazy load的模式</p>
<p>那么如何较好地保证线程安全呢？===&gt;在懒汉式的基础上，我们得到了双重检查锁</p>
</blockquote>
<p>懒汉式的做法好比地铁进站限流，在寒风刺骨的冬天，所有人都在站前广场转圈，用户体验会不好；而双重检查就是设置两重检查，好比在入站门处和入厅后再闸口检票处再检查一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对保存实例的变量添加volatile的修饰。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块</span></span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//同步块，线程安全的创建实例</span></span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">				<span class="comment">//再次检查实例是否存在，如果不存在才真的创建实例</span></span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检查加锁机制和懒汉不同的在于并不是进入getInstace方法需要同步(由方法加锁-&gt;方法内部加对象锁)，而是不存在实例的时候才会进入同步块。此处阻塞的不是基于整个LazyDoubleCheckSingleton类的阻塞，而是在getInstance方法内部的阻塞，只要逻辑不复杂，对于调用者是感觉不到的。</p>
<p>▲注：被volatile修饰的变量的值不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存的，从而使得多个线程能够正确的处理该变量。（由于Java1.4前对volatile关键字实现有问题，因此双重检查锁适用于Java1.5以后）。此外<u>volatile可能会屏蔽JVM一些必要的代码优化，所以会降低运行效率</u>，因此一般建议没有特别需要，不要使用volatile。因此，<strong>不建议系统中大量使用双重检查锁</strong>。</p>
<h2 id="静态内部类式类级内部类"><a class="markdownIt-Anchor" href="#静态内部类式类级内部类"></a> 静态内部类式（类级内部类）</h2>
<blockquote>
<p>虽然双重检查锁较之懒汉和饿汉有了不少优化，但双重检查锁仍存在1.volatile性能、2.synchronized性能，有没有什么办法不使用synchronized关键字，还能实现延迟加载和线程安全呢？==&gt;静态内部类式</p>
</blockquote>
<h3 id="什么是类级内部类"><a class="markdownIt-Anchor" href="#什么是类级内部类"></a> 什么是类级内部类？</h3>
<p>简单点说，<strong>类级内部类</strong>指的是，有<u>static修饰的成员式内部类</u>。如果没有static修饰的成员式内部类被称为<strong>对象级内部类</strong>。</p>
<ul>
<li>类级内部类相当于其外部类的static成分，<u>它的对象(类级内部类对象)与外部类对象间不存在依赖关系</u>，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。</li>
<li>类级内部类中，可以定义静态的方法。在<u>内部类的静态方法</u>中只能够引用外部类中的<strong>静态</strong>成员方法或者成员变量。</li>
<li><strong>类级内部类相当于其外部类的成员，只有在第一次被使用的时候才会被装载。</strong></li>
</ul>
<h4 id="jvm隐含执行同步的情况"><a class="markdownIt-Anchor" href="#jvm隐含执行同步的情况"></a> JVM隐含执行同步的情况：</h4>
<ul>
<li>由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时</li>
<li>访问final字段时</li>
<li>在创建线程之前创建对象时</li>
<li>线程可以看见它将要处理的对象时</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyStaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，</span></span><br><span class="line"><span class="comment">	 * 而且只有被调用到才会装载，从而实现了延迟加载</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 静态初始化器，由JVM来保证线程安全</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> LazyStaticInnerClassSingleton instance = <span class="keyword">new</span> LazyStaticInnerClassSingleton();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 私有化构造方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">LazyStaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyStaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解决反射破坏单例问题"><a class="markdownIt-Anchor" href="#解决反射破坏单例问题"></a> 解决反射破坏单例问题</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyStaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，</span></span><br><span class="line"><span class="comment">	 * 而且只有被调用到才会装载，从而实现了延迟加载</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 静态初始化器，由JVM来保证线程安全</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> LazyStaticInnerClassSingleton instance = <span class="keyword">new</span> LazyStaticInnerClassSingleton();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 私有化构造方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">LazyStaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LazyStaticInnerClassSingleton.instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不允许创建多个实例"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyStaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举式单例"><a class="markdownIt-Anchor" href="#枚举式单例"></a> 枚举式单例</h2>
<blockquote>
<p>虽然静态内部类式已经接近完美了，但还不够优雅，还有没有更优雅的写法呢？—&gt;枚举式单例</p>
</blockquote>
<p>对枚举的观点：</p>
<ul>
<li>Java的枚举类型实质上是功能齐全的类，因此可以有自己的属性和方法。</li>
<li>Java枚举类型的基本思想是通过公有的静态final域为每个<u>枚举常量</u>导出<u>实例的类</u>。</li>
<li>从某个角度讲，<u>枚举</u>是单例的泛型化，<u>本质上是<em>单元素</em>的枚举</u>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义一个枚举的元素,它就代表了Singleton的一个实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	uniqueInstance;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 示意方法，单例可以有自己的操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//功能处理</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用枚举来实现单实例控制会更加简洁，而且<strong>无偿地提供了防序列化（需要增加readResove方法）、反射破坏的机制</strong>，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。至于为什么可以这么玩，可以看《设计模式就该这样学：基于经典框架源码和真实业务场景》中的源码分析</p>
<h2 id="容器式单例"><a class="markdownIt-Anchor" href="#容器式单例"></a> 容器式单例</h2>
<blockquote>
<p>适用于需要大量创建单例对象的场景，便于管理，但它是非线程安全的。Spring中有用到容器式单例的写法。容器一般就是一个Map</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ContainerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ioc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ioc.containsKey(className)) &#123;</span><br><span class="line">                Object obj = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj = Class.forName(className).newInstance();</span><br><span class="line">                    ioc.put(className, obj);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ioc.get(className)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模式讲解"><a class="markdownIt-Anchor" href="#模式讲解"></a> 模式讲解：</h2>
<p>单例模式的范围为一个虚拟机的范围，因为加载类的载类的功能是虚拟机的，一个虚拟机在通过自己的ClassLoader 装载饿汉式实现单例类的时候就会创建一个类的实例。</p>
<p>▲所以需要注意的是，如果一个虚拟机里面有很多个ClassLoader，而且<u>这些ClassLoader都装载某个类的话(针对饿汉式)，就算这个类是单例，它也会产生很多个实例</u>。当然，如果一个机器上有多个虚拟机，那么每个虚拟机里面都应该至少有一个这个类的实例，也就是说整个机器。<strong>所以这边讨论的单例都不适用于集群环境。</strong></p>
<p>▲单例模式的本质：控制实例数目</p>
<h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2>
<blockquote>
<p>对于Java来说单例模式就是要保证在一个JVM中只存在单一实例</p>
</blockquote>
<ul>
<li>需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少GC</li>
<li>某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用</li>
<li>频繁访问数据库或文件的对象</li>
<li>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则无法保证逻辑的统一性。</li>
</ul>
<p>p.s. 抽象工厂模式中具体的工厂类就是一个单例</p>
<h2 id="单例模式的优点"><a class="markdownIt-Anchor" href="#单例模式的优点"></a> 单例模式的优点：</h2>
<ol>
<li>可以保证内存中只有一个实例，减少了内存的开销</li>
<li>可以避免对资源的多重占用</li>
<li>设置全局访问点，可以优化和共享资源的访问</li>
</ol>
<h2 id="单例模式的缺点"><a class="markdownIt-Anchor" href="#单例模式的缺点"></a> 单例模式的缺点：</h2>
<ol>
<li>没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径， 违背了开闭原则。好在的是，一般修改单例也比较简单</li>
<li>在并发测试中，单例不利于代码调试。在调试过程总，如果单例代码没有执行完，也不能模拟生成一个恶心的对象</li>
<li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，很容易违背单一职责原则</li>
</ol>
<h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1>
<h2 id="lazy-load-缓存思想"><a class="markdownIt-Anchor" href="#lazy-load-缓存思想"></a> Lazy load-&gt;缓存思想</h2>
<p>缓存使用场景：当某些资源或者数据被频繁地使用，而这些资源或数据存储在系统外部，比如数据库、硬盘文件等，那么每次操作这些数据的时候都得从数据库或者硬盘上去获取，速度会很慢，将造成性能问题。<br>
一个简单的解决方法就是：把这些数据<strong>缓存到内存</strong>里面，每次操作的时候，先到内存里面找，看有没有这些数据，如果有，就直接使用，如果没有就获取它，并设置到缓存中，<u>下一次访问的时候就可以直接从内存中获取了</u>，从而节省大量的时间。当然，缓存是一种<strong>典型的空间换时间</strong>的方案。</p>
<h3 id="缓存基本实现"><a class="markdownIt-Anchor" href="#缓存基本实现"></a> 缓存基本实现</h3>
<p>在Java开发中最常见的一种实现缓存的方式就是使用<em>Map</em>，基本步骤如下。<br>
（1）先到缓存里面查找，看看是否存在需要使用的数据。<br>
（2）如果没有找到，那么就创建一个满足要求的数据，然后把这个数据设置到缓存中，以备下次使用。如果找到了相应的数据，或者是创建了相应的数据，那就直接使用这个数据。</p>
<h2 id="多例控制模式"><a class="markdownIt-Anchor" href="#多例控制模式"></a> 多例控制模式</h2>
<p>▲单例模式的本质：控制实例数目，只要按照这种思想，我们除了控制单例以外，还可以限制实例具体数目为2、3、4…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.dp.singleton.example9;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单演示如何扩展单例模式，控制实例数目为3个 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneExtend</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义一个缺省的key值的前缀</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_PREKEY = <span class="string">"Cache"</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 缓存实例的容器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,OneExtend&gt; map = <span class="keyword">new</span> HashMap&lt;String,OneExtend&gt;();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用来记录当前正在使用第几个实例，到了控制的最大数目，就返回从1开始</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义控制实例的最大数目</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_MAX = <span class="number">3</span>; </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">OneExtend</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OneExtend <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String key = DEFAULT_PREKEY+num;</span><br><span class="line">		OneExtend oneExtend = map.get(key);</span><br><span class="line">		<span class="keyword">if</span>(oneExtend==<span class="keyword">null</span>)&#123;</span><br><span class="line">			oneExtend = <span class="keyword">new</span> OneExtend();</span><br><span class="line">			map.put(key, oneExtend);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//把当前实例的序号加1</span></span><br><span class="line">		num++;</span><br><span class="line">		<span class="keyword">if</span>(num &gt; NUM_MAX)&#123;</span><br><span class="line">			<span class="comment">//如果实例的序号已经达到最大数目了，那就重复从1开始获取</span></span><br><span class="line">			num = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> oneExtend;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		OneExtend t1 = getInstance();</span><br><span class="line">		OneExtend t2 = getInstance();</span><br><span class="line">		OneExtend t3 = getInstance();</span><br><span class="line">		OneExtend t4 = getInstance();</span><br><span class="line">		OneExtend t5 = getInstance();</span><br><span class="line">		OneExtend t6 = getInstance();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"t1=="</span>+t1);</span><br><span class="line">		System.out.println(<span class="string">"t2=="</span>+t2);</span><br><span class="line">		System.out.println(<span class="string">"t3=="</span>+t3);</span><br><span class="line">		System.out.println(<span class="string">"t4=="</span>+t4);</span><br><span class="line">		System.out.println(<span class="string">"t5=="</span>+t5);</span><br><span class="line">		System.out.println(<span class="string">"t6=="</span>+t6);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2020/12/11/细品单例模式/">https://nymrli.top/2020/12/11/细品单例模式/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2020/12/11/浙大2020春夏-人工智能习题2——垃圾分类/" title="浙大2020春夏-人工智能习题2——垃圾分类"><span>< PreviousPost</span><br><span class="prevTitle">浙大2020春夏-人工智能习题2——垃圾分类</span></a><a class="nextSlogan" href="/2020/12/09/浙大2020春夏-人工智能习题3——图像恢复/" title="浙大2020春夏-人工智能习题3——图像恢复"><span>NextPost ></span><br><span class="nextTitle">浙大2020春夏-人工智能习题3——图像恢复</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '细品单例模式',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><a href="https://beian.miit.gov.cn/"> <span>备案号:苏ICP备18015439号</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#单例模式"><span class="toc-number">1.</span> <span class="toc-text"> 单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟场景"><span class="toc-number">1.1.</span> <span class="toc-text"> 虚拟场景：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存在的问题"><span class="toc-number">1.2.</span> <span class="toc-text"> 存在的问题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例实现思路"><span class="toc-number">1.3.</span> <span class="toc-text"> 单例实现思路：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式的结构和说明"><span class="toc-number">1.4.</span> <span class="toc-text"> 单例模式的结构和说明：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础级单例"><span class="toc-number">1.5.</span> <span class="toc-text"> 基础级单例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#饿汉式"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 饿汉式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式"><span class="toc-number">1.5.1.1.</span> <span class="toc-text"> 实现方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#懒汉式"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 懒汉式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-2"><span class="toc-number">1.5.2.1.</span> <span class="toc-text"> 实现方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优缺点分析"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 优缺点分析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双重检查锁"><span class="toc-number">1.6.</span> <span class="toc-text"> 双重检查锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态内部类式类级内部类"><span class="toc-number">1.7.</span> <span class="toc-text"> 静态内部类式（类级内部类）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是类级内部类"><span class="toc-number">1.7.1.</span> <span class="toc-text"> 什么是类级内部类？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jvm隐含执行同步的情况"><span class="toc-number">1.7.1.1.</span> <span class="toc-text"> JVM隐含执行同步的情况：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决反射破坏单例问题"><span class="toc-number">1.7.2.</span> <span class="toc-text"> 解决反射破坏单例问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举式单例"><span class="toc-number">1.8.</span> <span class="toc-text"> 枚举式单例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器式单例"><span class="toc-number">1.9.</span> <span class="toc-text"> 容器式单例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模式讲解"><span class="toc-number">1.10.</span> <span class="toc-text"> 模式讲解：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用场景"><span class="toc-number">1.11.</span> <span class="toc-text"> 应用场景：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式的优点"><span class="toc-number">1.12.</span> <span class="toc-text"> 单例模式的优点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式的缺点"><span class="toc-number">1.13.</span> <span class="toc-text"> 单例模式的缺点：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附录"><span class="toc-number">2.</span> <span class="toc-text"> 附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lazy-load-缓存思想"><span class="toc-number">2.1.</span> <span class="toc-text"> Lazy load-&gt;缓存思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存基本实现"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 缓存基本实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多例控制模式"><span class="toc-number">2.2.</span> <span class="toc-text"> 多例控制模式</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>