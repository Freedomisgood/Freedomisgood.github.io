{"meta":{"title":"果粒橙的博客","subtitle":"别装作很努力，因为结局不会陪你演戏。","description":"想和你讲，说了会心动 ，缄默会心安。","author":"果粒橙","url":"https://nymrli.top"},"pages":[{"title":"","date":"2018-12-21T09:57:11.353Z","updated":"2018-12-21T09:57:11.353Z","comments":true,"path":"google6b632f121e4f7422.html","permalink":"https://nymrli.top/google6b632f121e4f7422.html","excerpt":"","text":"google-site-verification: google6b632f121e4f7422.html"},{"title":"css","date":"2018-08-31T11:13:48.000Z","updated":"2018-08-31T11:19:21.810Z","comments":false,"path":"tags/index.html","permalink":"https://nymrli.top/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-08-31T07:56:42.000Z","updated":"2018-09-04T04:36:10.718Z","comments":true,"path":"about/index.html","permalink":"https://nymrli.top/about/index.html","excerpt":"","text":"本人南邮自动化本科学生一枚.热爱捣鼓计算机,涉及Python、C、Java等语言.参加Robocup,ACM,未来打算弄机器学习、数据挖掘方面"}],"posts":[{"title":"Pandas速成","slug":"Pandas速成","date":"2018-12-21T13:57:29.000Z","updated":"2018-12-21T13:57:48.527Z","comments":true,"path":"Pandas速成.html","link":"","permalink":"https://nymrli.top/Pandas速成.html","excerpt":"","text":"Pandas速成 Series : 一位数组, 只允许存储相同的数据类型 Time-Series : 以时间为索引的Series DataFrame : 二维的表格型数据结构 , 可以理解为是Series 的容器 Panel : 三维数组,可以理解为DataFrame 的容器 Series1234567891011121314151617import matplotlib.pyplot as pltimport pandas as pdimport numpy as nparr = np.array([1,2,3])index = ['a','b','c']myseries = pd.Series(arr,index)print(myseries)print('Series中第一个元素&#123;&#125;'.format(myseries[0]))print('Series中索引为C的元素'.format(myseries['c']))&gt;&gt;&gt;a 1b 2c 3dtype: int32Series中第一个元素1Series中索引为C的元素 DataFrame1234567891011121314arr= np.array([ [1,2,3], [2,3,4], [3,4,5]])rowindex = ['row1','row2','row3']colindex = ['col1','col2','col3']dataframe= pd.DataFrame(data=arr,index= rowindex,columns=colindex)print(dataframe)&gt;&gt;&gt; col1 col2 col3row1 1 2 3row2 2 3 4row3 3 4 5 1234567891011121314arr= np.array([ [1,2,3], [2,3,4], [3,4,5]])rowindex = ['row1','row2','row3']colindex = ['col1','col2','col3']dataframe= pd.DataFrame(data=arr,index = rowindex,columns=colindex)print(dataframe._ixs(0))&gt;&gt;&gt;col1 1col2 2col3 3Name: row1, dtype: int32 获取行列 1.ix[ ] 先行后列 12345print(dataframe.ix[[0]]) #获得第一行内容# print(dataframe.ix['row1']) #以索引名称获得print(dataframe.ix[[0]])` #获得第一列内容print(dataframe.ix[:,'col1']) 2.loc[ ] loc,是基于索引的名称选取数据集，这里的索引名称可以是数字,先行后列。注意，[0:2]是选取名称为0， 1， 2行的数据，一共三，只能写行和列的名称，不能写序号。 123456789print(dataframe.loc['row1'])&gt;&gt;&gt; col1 1col2 2col3 3Name: row1, dtype: int32print(dataframe.loc[:,'col1']) #获得'col1'列的值print(dataframe.loc['row1','col1']) #获得某行某列的值 3.iloc[] iloc，它是基于索引位来选取数据集，也就是数字序号来选取，0:2就是选取 0，1这两行，需要注意的是这里是前闭后开集合。只能写行和列的序号，不能写名称，否则会报错。 12345678print(dataframe.iloc[2])&gt;&gt;&gt; col1 3col2 4col3 5Name: row3, dtype: int32print(dataframe.iloc[0,:])","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"BaiduMap_API","slug":"BaiduMap-API","date":"2018-12-21T13:55:50.000Z","updated":"2018-12-21T13:56:37.113Z","comments":true,"path":"BaiduMap-API.html","link":"","permalink":"https://nymrli.top/BaiduMap-API.html","excerpt":"","text":"Baidu Map API核心类Map 构造函数 描述 Map(container: String \\ HTMLElement, opts: MapOptions) 在指定的容器内创建地图实例，之后需要调用Map.centerAndZoom()方法对地图进行初始化。未进行初始化的地图将不能进行任何操作 12var map = new BMap.Map(\"MAP\");map.centerAndZoom(points[0], 15); 方法 返回值 描述 enableDragging() none 启用地图拖拽，默认启用 enableScrollWheelZoom() none 启用滚轮放大缩小，默认禁用 enableDoubleClickZoom() none 启用双击放大，默认启用 enableKeyboard() none 启用键盘操作，默认禁用。 enablePinchToZoom() none 启用双指操作缩放，默认启用 enableAutoResize() none 启用自动适应容器尺寸变化，默认启用 setMinZoom(zoom: Number) none 设置地图允许的最小级别。取值不得小于地图类型所允许的最小级别 getCenter() Point 返回地图当前中心点 getDistance(start: Point, end: Point) Number 返回两点之间的距离，单位是米 centerAndZoom(center: Point, zoom: Number) none 设初始化地图。 如果center类型为Point时，zoom必须赋值，范围3-19级，若调用高清底图（针对移动端开发）时，zoom可赋值范围为3-18级。如果center类型为字符串时，比如“北京”，zoom可以忽略，地图将自动根据center适配最佳zoom级别 panTo(center: Point, opts: PanOptions) none 将地图的中心点更改为给定的点。如果该点在当前的地图视图中已经可见，则会以平滑动画的方式移动到中心点位置。可以通过配置强制移动过程不使用动画效果 setCenter(center: Point \\ String) none 设置地图中心点。center除了可以为坐标点以外，还支持城市名 getZoom() Number 返回地图当前缩放级别 setZoom(zoom: Number) none 将视图切换到指定的缩放等级，中心点坐标不变。注意：当有信息窗口在地图上打开时，地图缩放将保证信息窗口所在的坐标位置不动 addOverlay(overlay: Overlay) none 将覆盖物添加到地图中，一个覆盖物实例只能向地图中添加一次 clearOverlays() none 清除地图上所有覆盖物 控件类Control基类 initialize(map: Map) HTMLElement 抽象方法。调用Map.addControl()方法添加控件时将调用此方法，从而实现该控件的初始化。自定义控件时需要实现此方法，并将元素的DOM元素在该方法中返回。DOM元素需要添加到地图的容器中，使用map.getContainer()方法可获得地图容器元素 setAnchor(anchor: ControlAnchor) none 设置控件停靠的位置 getAnchor() ControlAnchor 返回控件停靠的位置 setOffset(offset: Size) none 设置控件停靠的偏移量 getOffset() Size 返回控件停靠的偏移量 show() none 显示控件 hide() none 隐藏控件 isVisible() Boolean 判断控件的可见性 ControlAnchor: 此常量表示控件的定位。 常量 描述 BMAP_ANCHOR_TOP_LEFT 控件将定位到地图的左上角 BMAP_ANCHOR_TOP_RIGHT 控件将定位到地图的右上角 BMAP_ANCHOR_BOTTOM_LEFT 控件将定位到地图的左下角 BMAP_ANCHOR_BOTTOM_RIGHT 控件将定位到地图的右下角 NavigationControl 此类表示地图的平移缩放控件，可以对地图进行上下左右四个方向的平移和缩放操作。 GeolocationControl 此类是负责进行地图定位的控件，使用html5浏览器定位功能，此类继承Control所有功能。 OverviewMapControl 此类表示缩略地图控件。 ScaleControl 此类表示比例尺控件。 CopyrightControl 此类表示版权控件，您可以在地图上添加自己的版权信息。每一个版权信息需要包含如下内容：版权的唯一标识、版权内容和其适用的区域范围。 覆盖物类Marker:此类表示地图上一个图像标注。 构造函数 描述 Marker(point: Point, opts: MarkerOptions) 创建一个图像标注实例。point参数指定了图像标注所在的地理位置 1234markers = new BMap.Marker(new BMap.Point(118.93015,32.1091),&#123;\"title\":'Point'&#125;);label = new BMap.Label('label');markers.setLabel(l);map.addOverlay(markers); Icon此类表示标注覆盖物所使用的图标。 构造函数 描述 Icon(url: String, size: Size, opts: IconOptions) 以给定的图像地址和大小创建图标对象实例 Label此类表示地图上的文本标注。 构造函数 描述 Label(content: String, opts: LabelOptions) 创建一个文本标注实例。point参数指定了文本标注所在的地理位置 1234label = new BMap.Label(\"\", &#123;offset: new BMap.Size(-20, -20)&#125;); car = new BMap.Marker(points[0]); car.setLabel(label); map.addOverlay(car);","categories":[],"tags":[{"name":"API","slug":"API","permalink":"https://nymrli.top/tags/API/"}]},{"title":"Postman模拟上传文件","slug":"Postman模拟上传文件","date":"2018-12-20T10:57:35.000Z","updated":"2018-12-20T12:11:59.979Z","comments":true,"path":"Postman模拟上传文件.html","link":"","permalink":"https://nymrli.top/Postman模拟上传文件.html","excerpt":"","text":"Postman模拟1.首先得知道前端的样子: 2.针对前端字段进行模拟POST ▲这边key为&lt;input&gt;中的name属性 ▲▲URL最后的’/‘:POST请求URL要对应12345@app.route('/photo/',methods = ['GET','POST'] )http://127.0.0.1:5000/photo/@app.route('/photo',methods = ['GET','POST'] )http://127.0.0.1:5000/photo ​ 当Web服务器接收到对某个末尾不含斜杠的url请求时，例如“http://www.abc.com/abc”，这时服务器会搜索网站根目录下有没有名为“abc”的文件，**如果没有就把abc当做目录处理**，然后返回abc目录下的默认首页。当Web服务器接收到的是末尾带斜杠的请求时就会直接当做目录处理。，当浏览器解析 /ie 这样的url时，服务器会执行301转向到/ie/，两个链接都有效，但是第二种更快。 ​ 对于静态资源服务器来说，请求https://imgss.github.io/demo/这样的路径能访问到页面，是因为服务器会自动在demo路径下尝试找index.html之类的文件并发给浏览器，所以html的当前路径一定是demo下的，也是因为这样，浏览器才会通过重定向自动加上/，防止相对路径解析出错，保证浏览器能正确的请求到资源。 requests模拟1234567url = 'http://127.0.0.1:5000/photo/'filename = &#123; 'src' : open(\"C:\\\\Users\\\\10630\\\\Desktop\\\\为什么电流被一分为2.jpg\",'rb')&#125;html = requests.post(url,files=filename)print(html.text)# &#123;\"msg\":\"success\",\"status\":200&#125;","categories":[],"tags":[{"name":"Postman","slug":"Postman","permalink":"https://nymrli.top/tags/Postman/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"}]},{"title":"flask-sqlalchemy踩坑——外键","slug":"flask-sqlalchemy踩坑","date":"2018-12-19T11:47:54.000Z","updated":"2018-12-19T11:56:43.863Z","comments":true,"path":"flask-sqlalchemy踩坑.html","link":"","permalink":"https://nymrli.top/flask-sqlalchemy踩坑.html","excerpt":"","text":"12.19：外键使用今天要设计一个如图关系的表关系时,踩了好几个坑…记录下 代码: 123456789101112131415161718192021222324from exts import dbclass Account(db.Model): __tablename__ = 'account' id = db.Column(db.Integer,primary_key=True,autoincrement=True) Username = db.Column(db.String(30),nullable=True,unique=True) PWD = db.Column(db.String(20),nullable=True) email = db.Column(db.String(20),nullable=True,unique=True)class Info(db.Model): __tablename__ = 'info' id = db.Column(db.Integer,primary_key=True,autoincrement=True) email = db.Column(db.String(20),db.ForeignKey('account.email')) timestamp = db.Column(db.Float,nullable=True,unique=True)class Tmp(db.Model): __tablename__ = 'tmp' id = db.Column(db.Integer,primary_key=True,autoincrement=True) tmp = db.Column(db.Float,db.ForeignKey('info.timestamp')) # 一组的开始时间 nowtime = db.Column(db.FLOAT,nullable=True) # 当前记录的时间 longitude = db.Column(db.FLOAT,nullable=True) latitude = db.Column(db.FLOAT,nullable=True) id的类型是int,没有id这种类型 ▲.外键必须是主表的唯一键(unique)（如上，学生表 sid 是主键，而主键是唯一的，所以能够作为分数表 stu 的外键） 外键不一定须要作为从表的主键。外键也不一定是主表的主键。主表的唯一键就能够作为从表的外键。 外键的类型必须与父表的主键类型完全一致(类型和长度) 总结下来：","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"数据库","slug":"数据库","permalink":"https://nymrli.top/tags/数据库/"}]},{"title":"数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题","slug":"数据结构实验——图的基本运算及职能交通中的最佳路径选择问题","date":"2018-12-16T09:50:05.000Z","updated":"2018-12-16T10:30:17.535Z","comments":true,"path":"数据结构实验——图的基本运算及职能交通中的最佳路径选择问题.html","link":"","permalink":"https://nymrli.top/数据结构实验——图的基本运算及职能交通中的最佳路径选择问题.html","excerpt":"","text":"实验3.图的基本运算及职能交通中的最佳路径选择问题3.2-邻接矩阵的DFS和BFS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define ERROR 0#define OK 1#define Overflow 2 //表示上溢#define Underflow 3 //表示下溢#define NotPresent 4 //表示元素不存在#define Duplicate 5 //表示有重复元素#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status;typedef int BOOL;/************队列操作**************///循环队列的结构体定义typedef struct&#123; int front; int rear; int maxSize; //最大容量 ElemType *element;&#125;Queue;//创建一个能容纳mSize个单元的空队列void Create(Queue *Q,int mSize)&#123; Q-&gt;maxSize=mSize; Q-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize); Q-&gt;front=Q-&gt;rear=0;&#125; //判断队列是否为空,若是,则返回TRUE;否则返回FALSEBOOL IsEmpty(Queue *Q)&#123; return Q-&gt;front==Q-&gt;rear;&#125; //判断队列是否已满,若是,则返回TRUE,否则返回FALSEBOOL IsFULL(Queue *Q)&#123; return (Q-&gt;rear+1)%Q-&gt;maxSize==Q-&gt;front;&#125; //获取队头元素,并通过x返回.若操作成功,则返回TRUE,否则返回FALSEBOOL Front(Queue *Q,ElemType *x)&#123; if(IsEmpty(Q)) //空队列处理 return FALSE; *x=Q-&gt;element[(Q-&gt;front+1)%Q-&gt;maxSize]; return TRUE;&#125; //入队.在队列Q的队尾插入元素x(入队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL EnQueue(Queue *Q,ElemType x)&#123; if(IsFULL(Q)) //溢出处理 return FALSE; Q-&gt;rear=(Q-&gt;rear+1)%Q-&gt;maxSize; Q-&gt;element[Q-&gt;rear]=x; return TRUE;&#125; //出队.从队列Q中删除队头元素(出队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL DeQueue(Queue *Q)&#123; if(IsEmpty(Q))&#123; //空队列处理 return FALSE; &#125; Q-&gt;front=(Q-&gt;front+1)%Q-&gt;maxSize; return TRUE;&#125; /************队列操作**************///邻接矩阵的结构体定义typedef struct&#123; ElemType **a; //邻接矩阵 int n; //图的当前顶点数 int e; //图的当前边数 ElemType noEdge; //两顶点间无边时的值&#125;mGraph; //邻接矩阵的初始化Status Init(mGraph *mg,int nSize,ElemType noEdgeValue)&#123; int i,j; mg-&gt;n = nSize; //初始化顶点数 mg-&gt;e = 0; //初始化时没有边 mg-&gt;noEdge = noEdgeValue; //初始化没有边时的取值 mg-&gt;a = (ElemType**)malloc(nSize*sizeof(ElemType *)); //生成长度为n的一维指针数组 if(!mg-&gt;a) return ERROR; for(i = 0;i &lt; mg-&gt;n;i ++)&#123; //动态生成二维数组 mg-&gt;a[i] = (ElemType*)malloc(nSize*sizeof(ElemType)); for(j = 0;j &lt; mg-&gt;n;j ++)&#123; mg-&gt;a[i][j] = mg-&gt;noEdge; &#125; mg-&gt;a[i][i] = 0; //自回路设置为0 &#125; return OK;&#125; //邻接矩阵的撤销(改成了int型，有返回值),先释放一维数组,再释放指针数组int Destory(mGraph *mg)&#123; int i; for(i = 0;i &lt; mg-&gt;n;i ++)&#123; free(mg-&gt;a[i]); //释放n个一维数组的存储空间 &#125; free(mg-&gt;a); //释放一维数组的存储空间 return 1;&#125; //邻接矩阵的边的搜索Status Exist(mGraph *mg,int u,int v)&#123; if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v||mg-&gt;a[u][v] == mg-&gt;noEdge) return ERROR; return OK;&#125; //邻接矩阵的边的插入Status Insert(mGraph *mg,int u,int v,ElemType w)&#123; if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v) return ERROR; if(mg-&gt;a[u][v] != mg-&gt;noEdge) return Duplicate; //若待插入边已存在,则返回出错信息 mg-&gt;a[u][v] = w; //插入新边 mg-&gt;e ++; //增加一条边 return OK;&#125; //邻接矩阵的边的删除Status Remove(mGraph *mg,int u,int v)&#123; if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v) return ERROR; if(mg-&gt;a[u][v] == mg-&gt;noEdge) return NotPresent; //若待删除边不存在,则返回出错信息 mg-&gt;a[u][v] = mg-&gt;noEdge; //删除边 mg-&gt;e --; return OK;&#125; void DFS(mGraph mg,int v,int visited[])&#123; int j; printf(\"%d\",v ); visited[v] = 1; for( j = 0; j &lt; mg.n; j++)&#123; //遍历v的邻接点 if(!visited[j] &amp;&amp; mg.a[v][j] &gt; 0)&#123; //当未被访问且有权值 DFS(mg,j,visited); &#125; &#125;&#125;//DFS搜索全图void DFSGraph(mGraph mg)&#123; int i; int *visited = (int *)malloc(mg.n * sizeof(int)); //访问为1,未访问为0 for(i=0; i&lt; mg.n;i++) visited[i] = 0; //visted数组初始化 for(i=0;i&lt; mg.n; i++) if( !visited[i] ) DFS(mg,i,visited); free(visited); //整个图的DFS遍历后,释放visted数组&#125; void BFS(mGraph mg,int v,int visited[])&#123; Queue q; Create(&amp;q,mg.n); visited[v] = 1; printf(\"%d\",v); EnQueue(&amp;q,v); //将当前顶点v放入队列 while( !IsEmpty(&amp;q) )&#123; Front(&amp;q,&amp;v); DeQueue(&amp;q); //队首顶点出队列 for(int i = 0;i &lt; mg.n;i ++)&#123; //遍历图的每一项 if( !visited[i] &amp;&amp; mg.a[v][i] &gt; 0)&#123; //若未被访问且有权值,则将其访问并放入队列 visited[i] = 1; printf(\"%d\",i); EnQueue(&amp;q,i); &#125; &#125; &#125;&#125;//BFS搜索全图void BFSGraph(mGraph mg)&#123; int i; int *visited = (int *)malloc(mg.n * sizeof(int)); //访问为1,未访问为0 for(i=0; i&lt; mg.n;i++) visited[i] = 0; //visted数组初始化 for(i=0;i&lt; mg.n; i++) if( !visited[i] ) BFS(mg,i,visited); free(visited); //整个图的BFS遍历后,释放visted数组&#125; int main()&#123; mGraph g; int nSize,edge,u,v,i; ElemType w; printf(\"Enter the mgraph's Size:\"); scanf(\"%d\",&amp;nSize); Init(&amp;g,nSize,-1); printf(\"Enter the mgraph's Edge num:\"); scanf(\"%d\",&amp;edge); for(i = 0;i &lt; edge;i ++)&#123; printf(\"Please enter the edge(Pu,Pv,Weight):\"); scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); Insert(&amp;g,u,v,w); &#125; printf(\"DFS:\"); DFSGraph(g); printf(\"\\nBFS:\"); BFSGraph(g); printf(\"\\n\"); system(\"pause\"); return 0;&#125; 3.4-邻接表的BFS和DFS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define ERROR 0#define OK 1#define Overflow 2 //表示上溢#define Underflow 3 //表示下溢#define NotPresent 4 //表示元素不存在#define Duplicate 5 //表示有重复元素#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status;typedef int BOOL;/************队列操作**************///循环队列的结构体定义typedef struct&#123; int front; int rear; int maxSize; //最大容量 ElemType *element;&#125;Queue;//创建一个能容纳mSize个单元的空队列void Create(Queue *Q,int mSize)&#123; Q-&gt;maxSize=mSize; Q-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize); Q-&gt;front=Q-&gt;rear=0;&#125; //判断队列是否为空,若是,则返回TRUE;否则返回FALSEBOOL IsEmpty(Queue *Q)&#123; return Q-&gt;front==Q-&gt;rear;&#125; //判断队列是否已满,若是,则返回TRUE,否则返回FALSEBOOL IsFULL(Queue *Q)&#123; return (Q-&gt;rear+1)%Q-&gt;maxSize==Q-&gt;front;&#125; //获取队头元素,并通过x返回.若操作成功,则返回TRUE,否则返回FALSEBOOL Front(Queue *Q,ElemType *x)&#123; if(IsEmpty(Q)) //空队列处理 return FALSE; *x=Q-&gt;element[(Q-&gt;front+1)%Q-&gt;maxSize]; return TRUE;&#125; //入队.在队列Q的队尾插入元素x(入队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL EnQueue(Queue *Q,ElemType x)&#123; if(IsFULL(Q)) //溢出处理 return FALSE; Q-&gt;rear=(Q-&gt;rear+1)%Q-&gt;maxSize; Q-&gt;element[Q-&gt;rear]=x; return TRUE;&#125; //出队.从队列Q中删除队头元素(出队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL DeQueue(Queue *Q)&#123; if(IsEmpty(Q))&#123; //空队列处理 return FALSE; &#125; Q-&gt;front=(Q-&gt;front+1)%Q-&gt;maxSize; return TRUE;&#125; /************队列操作**************///邻接表的结构体定义typedef struct ENode&#123; int adjVex; //任意顶点u相邻的顶点 ElemType w; //边的权值 struct ENode *nextArc; //指向下一个边结点&#125;ENode; typedef struct&#123; int n; //图的当前顶点数 int e; //图的当前边数 ENode **a; //指向一维指针数组&#125;LGraph; //邻接表的初始化Status Init(LGraph *lg,int nSize)&#123; int i; lg-&gt;n = nSize; lg-&gt;e = 0; lg-&gt;a = (ENode**)malloc(nSize*sizeof(ENode*)); //动态生成长度为n的一维指针数组 if(!lg-&gt;a) return ERROR; for(i = 0;i &lt; lg-&gt;n;i ++) lg-&gt;a[i] = NULL; //将指针数组a置空 return OK;&#125; //邻接表的撤销int Destory(LGraph *lg)&#123; int i; ENode *p,*q; for(i = 0;i &lt; lg-&gt;n;i ++)&#123; //链表的撤销操作 p = lg-&gt;a[i]; //指针p指向顶点i的单链表的第一个边结点 q = p; while(p)&#123; //释放顶点i的单链表中所有边结点 p = p-&gt;nextArc; free(q); q = p; &#125; &#125; free(lg-&gt;a); //释放一维指针数组a的存储空间 return OK; //改为int型函数,有返回值&#125; //邻接表的搜索边Status Exist(LGraph *lg,int u,int v)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1 ||v &gt; lg-&gt;n-1 ||u == v) return ERROR; p = lg-&gt;a[u]; //指针p指向顶点u的单链表的第一个边结点 while(p!=NULL &amp;&amp; p-&gt;adjVex != v)&#123; p = p-&gt;nextArc; &#125; if(!p) return ERROR; else return OK;&#125; //邻接表的插入边Status Insert(LGraph *lg,int u,int v,ElemType w)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1||v &gt; lg-&gt;n-1 ||u == v) return ERROR; if(Exist(lg,u,v)) return Duplicate; //此边已存在,返回错误 p = (ENode*)malloc(sizeof(ENode)); //为新的边结点分配存储空间 p-&gt;adjVex = v; p-&gt;w = w; p -&gt; nextArc = lg-&gt;a[u]; //将新的边结点插入单链表的最前面 lg-&gt;a[u] = p; lg-&gt;e ++; return OK;&#125; //邻接表的删除边Status Remove(LGraph *lg,int u,int v)&#123; ENode *p,*q; if(u &lt; 0 || v &lt; 0 || u &gt; lg-&gt;n-1 || v &gt; lg-&gt;n-1 || u == v) return ERROR; p = lg-&gt;a[u]; q = NULL; while(p &amp;&amp; p-&gt;adjVex != v)&#123; //查找待删除边是否存在 q = p; p = p-&gt;nextArc; &#125; if(!p) return NotPresent; if(q) q-&gt;nextArc = p-&gt;nextArc; //从单链表删除此边 else lg-&gt;a[u] = p-&gt;nextArc; free(p); lg-&gt;e --; return OK;&#125; void BFS(LGraph lg,int v,int visited[])&#123; ENode *j; Queue q; Create(&amp;q,lg.n); visited[v] = 1; printf(\"%d\", v); EnQueue(&amp;q,v); //访问的节点入队 while( !IsEmpty(&amp;q) )&#123; //一直到该层没有节点为止 Front(&amp;q,&amp;v); // 取出父节点 DeQueue(&amp;q); for (j=lg.a[v]; j!= NULL;j=j-&gt;nextArc )&#123; if ( !visited[j-&gt;adjVex])&#123; visited[j-&gt;adjVex] = 1; printf(\"%d\", j-&gt;adjVex); EnQueue(&amp;q,j-&gt;adjVex); &#125; &#125; &#125;&#125;void BFSGraph(LGraph lg)&#123; int i; int *visited = (int *)malloc(sizeof(int)* lg.n); //记录n个节点的访问情况 for(i=0; i&lt; lg.n;i++) visited[i] = 0; //visted数组初始化 for (int i = 0; i &lt; lg.n; ++i) if( !visited[i] ) BFS(lg,i,visited); free(visited);&#125;void DFS(LGraph lg,int v,int visited[])&#123; ENode *j; printf(\"%d\",v ); visited[v] = 1; for (j = lg.a[v];j!=NULL;j= j-&gt;nextArc) //lg.a链表的循环 if( !visited[j-&gt;adjVex] ) DFS(lg,j-&gt;adjVex,visited);&#125;void DFSGraph(LGraph lg)&#123; int i; int *visited = (int *)malloc(sizeof(int)* lg.n); //记录n个节点的访问情况 for(i=0; i&lt; lg.n ; i++) visited[i] = 0; //visted数组初始化 for (int i = 0; i &lt; lg.n; ++i) if( !visited[i] ) DFS(lg,i,visited); free(visited);&#125; int main()&#123; LGraph g; int i,u,v,enode,edge; ElemType w; printf(\"Enter the number of mgraph's Nodes:\"); scanf(\"%d\",&amp;enode); Init(&amp;g,enode); printf(\"Enter the mgraph's Edge num:\"); scanf(\"%d\",&amp;edge); for(i = 0;i &lt; edge;i ++)&#123; printf(\"Please enter the edge(Pu,Pv,Weight):\"); scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); Insert(&amp;g,u,v,w); &#125; printf(\"DFS:\"); DFSGraph(g); printf(\"\\nBFS:\"); BFSGraph(g); printf(\"\\n\"); system(\"pause\"); return 0;&#125; 以上大多直接从学长的博客搬运过来. 3.5- 飞机换乘最短距离(Dijkstra单源最短路径)编写程序，实现智能交通中的最佳路径选择问题：设有n个地点，编号为0~n-1，m条路径的起点、终点和代价由用户输入提供，采用实验3.1所示邻接矩阵为存储结构，寻找最佳路径方案(如花费时间最少、路径长度最短、交通费用最小等，任选其一即可)。 借了学长的整体框架,将邻接矩阵改成了邻接表,并完成了题目要求的给定起点、终点，算最短路径。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define ERROR 0#define OK 1#define Overflow 2 //表示上溢#define Underflow 3 //表示下溢#define NotPresent 4 //表示元素不存在#define Duplicate 5 //表示有重复元素#define INFTY 32657 //表示正无穷#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status;typedef int BOOL;//邻接表的结构体定义typedef struct ENode&#123; int adjVex; //任意顶点u相邻的顶点 ElemType w; //边的权值 struct ENode *nextArc; //指向下一个边结点&#125;ENode; typedef struct&#123; int n; //图的当前顶点数 int e; //图的当前边数 ENode **a; //指向一维指针数组&#125;LGraph; //邻接表的初始化Status Init(LGraph *lg,int nSize)&#123; int i; lg-&gt;n = nSize; lg-&gt;e = 0; lg-&gt;a = (ENode**)malloc(nSize*sizeof(ENode*)); //动态生成长度为n的一维指针数组 if(!lg-&gt;a) return ERROR; for(i = 0;i &lt; lg-&gt;n;i ++) lg-&gt;a[i] = NULL; //将指针数组a置空 return OK;&#125; //邻接表的撤销int Destory(LGraph *lg)&#123; int i; ENode *p,*q; for(i = 0;i &lt; lg-&gt;n;i ++)&#123; //链表的撤销操作 p = lg-&gt;a[i]; //指针p指向顶点i的单链表的第一个边结点 q = p; while(p)&#123; //释放顶点i的单链表中所有边结点 p = p-&gt;nextArc; free(q); q = p; &#125; &#125; free(lg-&gt;a); //释放一维指针数组a的存储空间 return OK; //改为int型函数,有返回值&#125; //邻接表的搜索边Status Exist(LGraph *lg,int u,int v)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1 ||v &gt; lg-&gt;n-1 ||u == v) return ERROR; p = lg-&gt;a[u]; //指针p指向顶点u的单链表的第一个边结点 while(p!=NULL &amp;&amp; p-&gt;adjVex != v)&#123; p = p-&gt;nextArc; &#125; if(!p) return ERROR; else return OK;&#125; //邻接表的插入边Status Insert(LGraph *lg,int u,int v,ElemType w)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1||v &gt; lg-&gt;n-1 ||u == v) return ERROR; if(Exist(lg,u,v)) return Duplicate; //此边已存在,返回错误 p = (ENode*)malloc(sizeof(ENode)); //为新的边结点分配存储空间 p-&gt;adjVex = v; p-&gt;w = w; p -&gt; nextArc = lg-&gt;a[u]; //将新的边结点插入单链表的最前面 lg-&gt;a[u] = p; lg-&gt;e ++; return OK;&#125; //邻接表的删除边Status Remove(LGraph *lg,int u,int v)&#123; ENode *p,*q; if(u &lt; 0 || v &lt; 0 || u &gt; lg-&gt;n-1 || v &gt; lg-&gt;n-1 || u == v) return ERROR; p = lg-&gt;a[u]; q = NULL; while(p &amp;&amp; p-&gt;adjVex != v)&#123; //查找待删除边是否存在 q = p; p = p-&gt;nextArc; &#125; if(!p) return NotPresent; if(q) q-&gt;nextArc = p-&gt;nextArc; //从单链表删除此边 else lg-&gt;a[u] = p-&gt;nextArc; free(p); lg-&gt;e --; return OK;&#125; //选出最小的d[i],i ∈ V-Sint Choose(int d[],int n,int s[])&#123; int minpos; int i; ElemType min; min = INFTY; minpos = -1; for(i = 0;i &lt; n;i ++)&#123; //这里i初值改为0 if( d[i] &lt;= min &amp;&amp; !s[i])&#123; //&lt;改为&lt;= // printf(\"Choose: d[%d]:%d \",i, d[i]); //可以将这段注释打开理解 min = d[i]; minpos = i; &#125; &#125; return minpos; //返回下标位置&#125; //Dijkstra算法Status Dijkstra(LGraph g,int v,int d[],int path[])&#123; int i,k,w,distance = 0; //增加了一个distance记录最短距离之和 int *s; if(v &lt; 0 || v &gt; g.n-1) return ERROR; ENode *j; /*对辅助数据结构的初始化*/ s = (int*)malloc(g.n*sizeof(int)); /*非源点结点初始化*/ for(i = 0;i &lt; g.n;i ++)&#123; s[i] = 0; //表示顶点i是否在s中 for( j=g.a[v];j!=NULL; j=j-&gt;nextArc) if(j-&gt;adjVex == i ) d[i] = j-&gt;w; //v到i的距离 if(i != v &amp;&amp; d[i] &lt; INFTY) path[i] = v; //如果与源点有边相通,标识指向i的源点v else path[i] = -1; &#125; /*源点初始化*/ s[v] = 1; //顶点v为源点,将原点v加入集合S printf(\"The order:%d \",v); //输出源点0 d[v] = 0; /*对辅助数据结构的初始化*/ for(i = 1;i &lt;= g.n-1;i ++)&#123; //最多产生n-1条最短路径,&lt;改为&lt;= k = Choose(d, g.n ,s); //求当前路径最短者k s[k] = 1; //将k加入集合S中 printf(\"%d \",k); for( j = g.a[k]; j!=NULL; j= j-&gt;nextArc)&#123; //更新d和path if( !s[j-&gt;adjVex] &amp;&amp; d[k] + j-&gt;w &lt; d[ j-&gt;adjVex ])&#123; //未被访问过,且 当前边+到前个结点的权值 &lt; 现在的路径长度 //j-&gt;adjVex为所有与v相邻接的顶点 d[j-&gt;adjVex ] = d[k] + j-&gt;w; distance = d[j-&gt;adjVex ]; //计算所有路径中的min距离 path[j-&gt;adjVex ] = k; &#125; &#125; &#125; return OK;&#125; int main()&#123; LGraph g; int nSize,edge,u,v,i; int s,t; //起点,终点 int d[100]; for(int i=0;i&lt;100;i++) d[i] = INFTY; int path[100]; ElemType w; printf(\"Enter the number of mgraph's Nodes:\"); scanf(\"%d\",&amp;nSize); Init(&amp;g,nSize); printf(\"Enter the mgraph's Edge num:\"); scanf(\"%d\",&amp;edge); for(i = 0;i &lt; edge;i ++)&#123; printf(\"Please enter the edge(Pu,Pv,Weight):\"); scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); Insert(&amp;g,u,v,w); &#125; printf(\"Enter the Start Point :\"); scanf(\"%d\",&amp;s); printf(\"Enter the Destination Point :\"); scanf(\"%d\",&amp;t); Dijkstra(g,0,d,path); printf(\"\\nThe shortest distance from %d to Point %d:%d\\n\",s,t, d[t]); system(\"pause\"); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"},{"name":"图论","slug":"图论","permalink":"https://nymrli.top/tags/图论/"},{"name":"实验作业","slug":"实验作业","permalink":"https://nymrli.top/tags/实验作业/"}]},{"title":"数据结构——图","slug":"数据结构——图","date":"2018-12-16T03:41:46.000Z","updated":"2018-12-18T15:13:46.235Z","comments":true,"path":"数据结构——图.html","link":"","permalink":"https://nymrli.top/数据结构——图.html","excerpt":"","text":"数据结构——图连通图 无向图 连通图 : 图中任意两点都连通 连通:如果从v到w存在一条(无向)路径,则称v和w是连通的 路径:V到w的路径是一系列顶点{V,v1,V2，vn,w}的集合,其中任一对相邻的顶点间都有图中的边。路径的长度是路径中的边数(如果带权,则是所有边的权重和)。如果v到w之间的所有顶点都不同,则称简单路径 ▲路径是边的超集,一条路径中可以有多条边 回路:起点等于终点的路径 ==&gt; 有回路的路径为非简单路径 有向图: 强连通 : 有向图中顶点v和W之间存在双向路径,则称v和w是强连通的强连通图 强连通图 : 有向图中任意两顶点均强连通强连通分量:有向图的极大强连通子图 弱连通图 : 将有向图中边的方向擦去,能变成连通图的图叫 弱连通图 图不连通咋办? 非连通图 无向图 连通分量: 无向图的极大连通子图 极大顶点数 : 再加1个顶点就不连通了 极大边数 : 包含子图中所有顶点相连的所有边 图的边可以是具有某种属性的对象: 007案例中的岸边 最小代价生成树基础概念 最小生成树问题 : 村村通—&gt; 使图连通的( 最少的边 \\ 花销最小的 ) 树 连通的 无回路 V个顶点 , v-1条边 生成 包含所有的顶点 V-1条边都在图里 任意加一条边都会构成回路 最小 边的权重和最小 ▲ 最小代价生成树不存在 图不连通 贪心算法: 贪: 每一步是最好的 好: 权重是最小的 约束: 只能用图里有的边 正好用掉 v-1条边 不能有回路 算法实现:Prim算法——让小树成长： kruskal——将森林合并成树: 更贪心,直接将权重最小的边收进来 拓补排序AOV 以顶点来表示活动。 一个活动是另一个活动的先决条件 不断抹去 没有前驱顶点(入度为0) 的顶点 提倡的做法: 将入度为0的顶点放到容器中 ▲.这种方法还可以用来检测是不是有向无环图(DAG) 关键路径AOE: 一般用于安排项目的工序 由绝不允许延误的活动组成的路径 关键路径长度: earliest(n) 没有机动时间的路径为关键路径","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"},{"name":"图论","slug":"图论","permalink":"https://nymrli.top/tags/图论/"}]},{"title":"win自带邮件使用","slug":"win自带邮件使用","date":"2018-12-16T02:48:27.000Z","updated":"2018-12-16T03:07:15.385Z","comments":true,"path":"win自带邮件使用.html","link":"","permalink":"https://nymrli.top/win自带邮件使用.html","excerpt":"","text":"创意大赛忘记提交附件的经历，让我决定这几天把邮箱的问题彻底解决了。 一.打开Windows自带的邮件1.附件栏里 2.直接搜索”邮件” 二.添加账号打开后界面是这样的,左边是我已经添加好的账号 1.点击下面的”齿轮” 2.点击”管理账号” 3.点击”添加账户” 将信息按规则填好后.需要注意的是▲.在按登录之前需要翻墙,否则会出现如图”我们无法找到你的设置“.其次要注意的是,密码为IMAP或者POP、SMTP的密码，授权码查询如下网易：图一 图二： 图三： 此步他会要求你设置自己的授权码 QQ邮箱：图一： 图二： 此步他会要求你发送“配置邮箱客户端”到某个号码上，然后会生成授权码。这个不是自己设置的 翻墙成功，在确保密码也正确的情况下就可以按“登录”了。 附录：添加账号：从“开始“中打开","categories":[],"tags":[{"name":"邮件","slug":"邮件","permalink":"https://nymrli.top/tags/邮件/"},{"name":"Window10","slug":"Window10","permalink":"https://nymrli.top/tags/Window10/"}]},{"title":"2018-12-15小记","slug":"2018-12-15小记","date":"2018-12-15T14:22:25.000Z","updated":"2018-12-18T12:13:57.125Z","comments":true,"path":"2018-12-15小记.html","link":"","permalink":"https://nymrli.top/2018-12-15小记.html","excerpt":"","text":"数据结构上机,由于最近烦心事也比较多,没有任何准备,在机房想要自己把代码敲出来也是不现实的。于是，就搜吧。无意中搜到了[学长的博客](https://me.csdn.net/Wonz5130),大二转计科，看了他努力的点滴，也颇有感触，于是下笔，略述己见。 之前一直在博客里都是发的技术性的文章，有时想说点话，也找不到合适的人。发条说说，不懂的人不知所措，懂的人也无从安慰，于是也只好作罢。也曾想过在博客里写，太又感觉未免太过矫情，今日所感，还是决定记录些情感、回忆。 大一上报了院科协与校科协，入大学前已经略有琢磨过C语言学习的我自然没有再接着学C，于是趁着Python的大热，也正是听说了Python的简洁、可以做爬虫、网站、人工智能等有趣的时就决定学了这门语言。于是加入了Python组，碰到了李林伟与王宇学长，李林伟学长很负责，大一的课几乎都是由他授的，当初还有事嫌他讲的不够好，现在自己当了讲师后才发现根本无暇准备。大一的时光很多都泡在了图书馆，一个学期下来已经借了20+本书了，整个学年下来一共借了40+本书，虽然没有全部看完，都明显的感觉到自己的努力。大二一般都是在看视频，图书馆很少去了，书也借的少了。 大一还学了单片机，说来也可惜，第一次院级比赛优之杰做了个所有授课内容如 蜂鸣器、LCD1602、跑马灯、矩阵按键 的作品已经很了不起了，就没有再深入学些什么，不知那些更优秀的人已经开始准备电赛、飞思卡尔了。很遗憾吧，最终在下学期的4月份“海善达杯”结束后就再也没碰过单片机，所有学过的单片机代码也逐渐忘却。 大二，一直呆在学科楼220，但没有怎么忙Apollo的项目，说来也比较惭愧。这半个学期也已经过了，感觉自己一直在忙些奇奇怪怪的事，学了前端HTML、CSS、JS；还学了微信小程序，为的就是想参加一些比赛，但到如今却都凉了。为了天翼杯做了个物联网的猫粮，但是天翼杯初赛就被刷；参加创意大赛，结果自己忘记提交附件了；同时，学长的不看好，让我也对完成点子的作品产生了怀疑：这种没技术含量的作品真的能获奖吗？无论如何，最近也得不到答案了。这让我对开发产生了一种厌恶与疲倦，下学期想好好弄弄算法或是机器学习了，静下心来弄点真技术。 有的时候真的会比较迷茫吧？考研还是工作的问题，每隔一段时间都会思考。昨天的分光计无疑让我又一次受挫。准备了3天的物理实验，结果最后誊错数据，同时也是最后几个离开实验室的。确实，分光计真的很简单，但有模糊的地方、以及平时没解决放过的地方在你最薄弱的时候就可能一下子要了你的命。无法确定是否要修正、无法确定是否要算θ0……导致没有一开始就画表，导致了最后的誊错，感觉像是命中注定，就如同创意大赛的没有提交。最近过的很背，期望能够有个水逆退散、柳暗花明。","categories":[],"tags":[{"name":"生活小记","slug":"生活小记","permalink":"https://nymrli.top/tags/生活小记/"}]},{"title":"Python中邮件的发送","slug":"Python中邮件的发送","date":"2018-12-12T14:17:38.000Z","updated":"2018-12-12T14:25:42.949Z","comments":true,"path":"Python中邮件的发送.html","link":"","permalink":"https://nymrli.top/Python中邮件的发送.html","excerpt":"","text":"Python普通的邮件发送需要一个安全的连接，例如SSL，因此接下来我们会使用SSL的方式去登录，但是在那之前，我们需要做一些准备，打开qq邮箱，点击设置-&gt;账户，找到POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务，开启IMAP/SMTP服务，然后根据要求使用手机发送到指定号码，获取授权码，这个授权码就是你接下来登录要使用的密码. 123456789101112131415161718from email.mime.text import MIMETextimport smtplib_user = '1063052964@qq.com'_pwd = 'pykhotuhghdjbeci'_to = '2035420834@qq.com'msg = MIMEText(mail_body) //MIMEText中_subtype默认为plain,html格式,只需改这个参数msg[\"Subject\"] = '来自[不吐不快]网站的网友意见'msg[\"From\"] = _usermsg[\"To\"] = _totry: s = smtplib.SMTP_SSL(\"smtp.qq.com\", 465) //或是使用s = smtplib.SMTP(\"smtp.qq.com\",25) s.login(_user, _pwd) s.sendmail(_user, _to, msg.as_string()) s.quit() message = '感谢你的来信'except: message = '发送失败' ▲smtplib.SMTP_SSL([host[, port[, local_hostname[, keyfile[, certfile[, timeout]]]]]]) 这是一个派生自SMTP的子类，通过SSL加密的套接字连接（使用此类，您需要使用SSL支持编译的套接字模块）。如果未指定主机，则使用“（本地主机）”。如果省略端口，则使用标准的SMTP-over-SSL端口（465） 本机已安装了支持 SMTP 的服务，如：sendmail: 12345import smtplibfrom email.mime.text import MIMETextfrom email.header import Headermessage['From'] = Header(\"菜鸟教程\", 'utf-8') 第三方SMTP发送邮件: 1234567import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddrmsg['From']=formataddr([\"FromRunoob\",my_sender]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号msg['To']=formataddr([\"FK\",my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号*没有formataddr的昵称默认为账号* Python 发送带附件的邮件: 发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/python# -*- coding: UTF-8 -*- import smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.header import Header sender = 'from@runoob.com'receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 #创建一个带附件的实例message = MIMEMultipart()message['From'] = Header(\"菜鸟教程\", 'utf-8')message['To'] = Header(\"测试\", 'utf-8')subject = 'Python SMTP 邮件测试'message['Subject'] = Header(subject, 'utf-8') #邮件正文内容message.attach(MIMEText('这是菜鸟教程Python 邮件发送测试……', 'plain', 'utf-8')) # 构造附件1，传送当前目录下的 test.txt 文件att1 = MIMEText(open('test.txt', 'rb').read(), 'base64', 'utf-8')att1[\"Content-Type\"] = 'application/octet-stream'# 这里的filename可以任意写，写什么名字，邮件中显示什么名字att1[\"Content-Disposition\"] = 'attachment; filename=\"test.txt\"'message.attach(att1) # 构造附件2，传送当前目录下的 runoob.txt 文件att2 = MIMEText(open('runoob.txt', 'rb').read(), 'base64', 'utf-8')att2[\"Content-Type\"] = 'application/octet-stream'att2[\"Content-Disposition\"] = 'attachment; filename=\"runoob.txt\"'message.attach(att2) try: smtpObj = smtplib.SMTP('localhost') smtpObj.sendmail(sender, receivers, message.as_string()) print \"邮件发送成功\"except smtplib.SMTPException: print \"Error: 无法发送邮件\" 在 HTML 文本中添加图片123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python# -*- coding: UTF-8 -*- import smtplibfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.header import Header sender = 'from@runoob.com'receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 msgRoot = MIMEMultipart('related') //创建MIMEMultipart()实例msgRoot['From'] = Header(\"菜鸟教程\", 'utf-8')msgRoot['To'] = Header(\"测试\", 'utf-8')subject = 'Python SMTP 邮件测试'msgRoot['Subject'] = Header(subject, 'utf-8') msgAlternative = MIMEMultipart('alternative')msgRoot.attach(msgAlternative) mail_msg = \"\"\"&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;&lt;p&gt;&lt;a href=\"http://www.runoob.com\"&gt;菜鸟教程链接&lt;/a&gt;&lt;/p&gt;&lt;p&gt;图片演示：&lt;/p&gt;&lt;p&gt;&lt;img src=\"cid:image1\"&gt;&lt;/p&gt;\"\"\"msgAlternative.attach(MIMEText(mail_msg, 'html', 'utf-8')) //内容 # 指定图片为当前目录fp = open('test.png', 'rb')msgImage = MIMEImage(fp.read())fp.close() # 定义图片 ID，在 HTML 文本中引用msgImage.add_header('Content-ID', '&lt;image1&gt;')msgRoot.attach(msgImage) //附件 try: smtpObj = smtplib.SMTP('localhost') smtpObj.sendmail(sender, receivers, msgRoot.as_string()) print \"邮件发送成功\"except smtplib.SMTPException: print \"Error: 无法发送邮件\" Python SMTP发送邮件 flask-email官方文档 阻塞发送最简单的调用123456789101112131415161718from flask import Flaskfrom flask_mail import Mail,Messageapp = Flask(__name__)app.config['MAIL_SERVER'] = 'smtp.qq.com'app.config['MAIL_PORT'] = 587app.config['MAIL_USE_TLS'] = Trueapp.config['MAIL_USERNAME'] = '1063052964@qq.com'app.config['MAIL_PASSWORD'] = '#'mail = Mail(app)msg = Message('邮件主题', sender='1063052964@qq.com', recipients=['2035420834@qq.com'])msg.body = '邮件内容'msg.html = \"&lt;h1&gt;邮件的html模板&lt;h1&gt; body\"with app.app_context(): mail.send(msg) 读取配置+视图函数中调用[config.py] 123456789# 配置邮箱信息MAIL_SERVER = 'smtp.qq.com'MAIL_PORT = 465MAIL_USE_TLS = FalseMAIL_USE_SSL = True# 注意此处，很多人配置发不出去和这个是有关系的MAIL_PASSWORD = '**********'MAIL_USERNAME = '********@qq.com'# qq郵箱默認走ssl，所以創建的smtp對象必須要支持加密傳輸，且需要指定port=465 app.py 123456789101112131415161718192021222324252627from flask import Flaskfrom flask_mail import Message,Mailfrom threading import Threadimport configapp = Flask(__name__)app.config.from_object(config)mail = Mail(app)def sendMail(): msg = Message('test', sender = '1063052964@qq.com', recipients=[\"2035420834@qq.com\"]) # recipients是个列表，包含所有收件人 # 此处的test是邮箱的主题，sender和config中的MAIL_USERNAME要一致哦 msg.body = '123' msg.html = '&lt;b&gt;test&lt;/b&gt;body' mail.send(msg)@app.route('/')def hello_world(): sendMail() return 'Hello World!'if __name__ == '__main__': app.run(debug=True) tips:tip：具体工程中，配置可以写在单独一个文件如”.env”，然后利用python-envcfg来读取配置，如：app.config.from_object(‘envcfg.raw’) 异步发送12345678910111213141516171819202122232425262728293031323334353637from flask import Flaskfrom flask_mail import Message,Mailfrom threading import Threadimport configapp = Flask(__name__)app.config.from_object(config)mail = Mail(app)def send_async_email(app,msg): with app.app_context(): mail.send(message=msg)def SendMail(): msg = Message('test',sender='106305964@qq.com',\\ recipients=[\"870545361@qq.com\"]) # recipients是个列表，包含所有收件人 # 此处的test是邮箱的主题，sender和config中的MAIL_USERNAME要一致哦 msg.body = 'testbody' msg.html = '&lt;b&gt;test&lt;/b&gt;body' # 邮件发送给目标，可以有文本，两种方式呈现，你能看见怎样的取决于你的客户端 thr = Thread(target=send_async_email,args=[app,msg]) # 使用多线程，在实际开发中，若是不使用异步、多线程等方式，网页会卡住 thr.start() return 'ok'@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run(debug=True) ▲. 许多Flask的扩展都是假定自己运行在一个活动的应用和请求上下文中，Flask-Mail的send函数使用到current_app 这个上下文了，所以当 mail.send()函数在一个线程中执行的时候需要人为的创建一个上下文。在示例 send_async_email 中使用了 app.app_context() 来创建一个上下文。 既然异步的邮件发送功能已经实现了，如果将来我们需要实现其它异步的函数，还有什么需要改进的吗？我们需要为每一个实现异步功能的函数拷贝多线程的代码吗？这并不好。 我们可以通过实现一个 装饰器 来解决这个问题。有了装饰器，上面的代码可以修改为: 123456789101112from .decorators import async@asyncdef send_async_email(app, msg): with app.app_context(): mail.send(msg)def send_email(subject, sender, recipients, text_body, html_body): msg = Message(subject, sender=sender, recipients=recipients) msg.body = text_body msg.html = html_body send_async_email(app, msg) 好的多了吧，对不对？ 这个神奇的代码其实很简单。我们把它放入一个新文件(文件 app/decorators.py): 1234567from threading import Threaddef async(f): def wrapper(*args, **kwargs): thr = Thread(target = f, args = args, kwargs = kwargs) thr.start() return wrapper 作为一个练习，大家可以考虑考虑如何用 *multiprocessing* 模块来实现上面的功能。 摘自flask文档 django.core.mail邮件EmailMessage: 标题. 内容.发件人.收件人 1234from django.core.mail import send_mailsend_mail(u'邮件标题', u'邮件内容', 'from@example.com', ['to@example.com'], fail_silently=False) send_mail() subject, message, from_email and recipient_list 这四个参数是必须的。 subject: 字符串，表示邮件标题。 message: 字符串，表示邮件内容。 from_email: 字符串，表示发件邮箱。 recipient_list: 字符串列表，列表中每个成员都是一个邮箱地址，而且每个收件人都会在 “收件人/To:” 栏看到出现在 recipient_list 中的其他收件人。 fail_silently: （可选）布尔值。为 False 时， send_mail 会抛出 smtplib.SMTPException 异常。 smtplib 文档列出了所有可能的异常。 这些异常都是 SMTPException 的子类。 auth_user: （可选）SMTP服务器的认证用户名。没提供该参数的情况下，Django会使用 EMAIL_HOST_USER 配置项的设置。 auth_password: （可选）SMTP服务器的认证密码，没提供该参数的情况下，Django会使用 EMAIL_HOST_PASSWORD配置项的设置。 connection: （可选）发送邮件的后端。没提供该参数的情况下，Django会使用默认后端的实例。可查看 Email backends 了解更多细节。 send_mass_mail() 和 send_mail() 的区别在于： send_mail() 每发送一封邮件就会打开一次邮件服务器链接，而send_mass_mail() 则是打开一次链接，发送所有的邮件。 send_mass_mail() 明显更高效。 main_admins()mail_admins(subject, message, fail_silently=False, connection=None, html_message=None) django.core.mail.mail_admins() 是一个给网站后台管理员(admin)发邮件的快捷方法，管理员设置放在 ADMINS 配置项。 mail_admins() 使用 EMAIL_SUBJECT_PREFIX 配置项的值做为邮件标题的前缀，默认情况下是 &quot;[Django] &quot; 。 mail_managers()mail_managers`(subject, message, fail_silently=False, connection=None, html_message=None) mail_managers(*subject*, *message*, *fail_silently=False*, *connection=None*, *html_message=None*)django.core.mail.mail_managers()is just likemail_admins()，不同之处在于该方法的邮件接收人是网站负责人(manager)， 可以在 [MANAGERS`]配置项设置网站负责人 EmailMessage 对象 class EmailMessage EmailMessage 类使用下列参数初始化（除非使用位置参数，否则默认顺序如下）。所有参数均可选，均可在调用 send()方法之前的任何时间对其赋值。 加入了 cc 参数（cc是抄送） subject: 邮件的标题行 body: 邮件的主体内容文本，须是纯文本信息。 from_email: 发送者的地址。 `fred@example.com或Fred &#x66;&#114;&#x65;&#100;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;格式都是合法的。如果忽略该参数，Django就会使用 [DEFAULT_FROM_EMAIL`](https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-DEFAULT_FROM_EMAIL) 配置项。 to: 收件人地址列表或元组。 bcc: 发送邮件时用于”Bcc”头信息的一组列表或元组，也就是暗送的收件人。 connection: 一个邮件后端实例。用同一个链接发送多封邮件就要用到该参数。忽略该参数时，会在调用 send() 时自动创建一个新链接。 attachments: 置于邮件报文内的附件列表。列表元素可以是 email.MIMEBase.MIMEBase 实例，也可以是 (filename, content, mimetype) 三部分构成的元组。 headers: 置于邮件报文内的其他头信息(header)的字典。字典的key是头信息的名称，字典的value是头信息的值。 这样做能确保头信息的名称和对应值会以正确的格式保存于邮件报文中。 cc: 发送邮件时放于”Cc”头信息的一系列列表或元组。 例如: 123email = EmailMessage('Hello', 'Body goes here', 'from@example.com', ['to1@example.com', 'to2@example.com'], ['bcc@example.com'], headers = &#123;'Reply-To': 'another@example.com'&#125;) 该类方法如下: send(fail_silently=False) 发送邮件报文。如果在构造邮件时如果指定了某个链接(connection)，就会使用该链接发邮件。 否则，就会使用默认后端的实例发邮件。如果关键字参数 fail_silently 为 True ，就会忽略邮件发送时抛出的异常。 message() 构造了一个 django.core.mail.SafeMIMEText 对象 (Python的 email.MIMEText.MIMEText 类的子类) 或是 django.core.mail.SafeMIMEMultipart 对象（该对象保存即将发送出去邮件报文）。如需扩展 EmailMessage类，一般情况下要覆写该方法，将你所需的内容添加到MIME对象中。 recipients() 返回邮件中所有收件人的列表，不管收件人是在 to 还是 bcc 属性中。这是另一个经常被继承覆写的方法， 因为SMTP服务器在发送邮件报文时，要接收完整的收件人列表。即使你自己的类使用其他方式来指定收件人，也仍然需要使用该方法返回收件人列表。 attach() 创建一个新的文件附件，并把它添加到邮件报文中。 有两种方法调用 attach(): 传递一个单独的 email.MIMEBase.MIMEBase 实例做为参数。该实例会直接添加到最终的邮件报文中。 或者，给 attach() 传递三个参数: filename, content 和 mimetype. filename 是出现在邮件中的附件文件的名称， content 是附件的内容，而 mimetype 是附件所使用的MIME类型。 如果忽略 mimetype, Django会自动根据附件文件名来推测MIME内容类型。 例如: 1message.attach('design.png', img_data, 'image/png') attach_file() 使用当前文件系统下的某个文件做为附件。调用时，传入某个文件的完整路径，以及该附件的MIME类型(可选的)。 忽略MIME类型的话，Django会自动根据附件文件名来推测MIME类型。最简单的用法如下: 1message.attach_file('/images/weather_map.png') 发送多用途邮件在同一封邮件中包含多种版本的内容是非常有用的；典型的例子就是发送既有纯文本版本内容又有HTML版本内容的邮件。 在Django的邮件库中，可以使用 EmailMultiAlternatives 类来达到该目的。 EmailMessage 的子类有一个attach_alternative() 方法用来包含其他版本的邮件主体内容。所有其他方法(包括类的初始化方法)都直接继承自 EmailMessage 。 发送一封文本/HTML混合邮件，代码如下: 12345678from django.core.mail import EmailMultiAlternativessubject, from_email, to = 'hello', 'from@example.com', 'to@example.com'text_content = 'This is an important message.'html_content = '&lt;p&gt;This is an &lt;strong&gt;important&lt;/strong&gt; message.&lt;/p&gt;'msg = EmailMultiAlternatives(subject, text_content, from_email, [to])msg.attach_alternative(html_content, \"text/html\")msg.send() 默认情况下，EmailMessage 类中的 body 参数的MIME类型是 &quot;text/plain&quot; 。 大多数情况下，没必要更改该MIME，因为这样能保证每个收件人能够阅读该邮件，而不论他们使用的是什么邮件客户端。 不过，在能确保收件人能处理多用途邮件的情况下，可以使用:class:~django.core.mail.EmailMessage 类的 content_subtype 属性 来更改邮件内容类型。主类型总是 &quot;text&quot; ，子类型可以设置为别的版本(比如html)，例如: 123msg = EmailMessage(subject, html_content, from_email, [to])msg.content_subtype = \"html\" # 主内体现在变成 text/htmlmsg.send() 获取邮件发送后端的实例123django.core.mail 的 get_connection() 函式返回你当前使用的邮件后端的实例。get_connection(backend=None, fail_silently=False, *args, **kwargs) SMTP backend –默认的后端 Console backend File backend –该后端并不建议在生产环境下使用–它仅仅是为开发提供方便 In-memory backend(内存后端) Dummy backend(空后端) 需要在 settings.py中设置的东西:123456EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'EMAIL_USE_SSL = TrueEMAIL_HOST = 'smtp.gmail.com'EMAIL_PORT = 587EMAIL_HOST_USER = 'urusername@gmail.com'EMAIL_HOST_PASSWORD = 'password'","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"}]},{"title":"使用Cerbot申请免费证书升级 http到https","slug":"使用Cerbot申请免费证书升级-http到https","date":"2018-12-08T08:10:03.000Z","updated":"2018-12-08T08:10:18.673Z","comments":true,"path":"使用Cerbot申请免费证书升级-http到https.html","link":"","permalink":"https://nymrli.top/使用Cerbot申请免费证书升级-http到https.html","excerpt":"","text":"使用 Cerbot 免费证书 简单 升级 http 到 https1、安装 cerbot: 12git clone https://github.com/letsencrypt/letsencryptcd letsencrypt 要求： Python 2.7 Git环境 连接外网 2、运行: 12// 根据自己的需求调整代码./certbot-auto certonly --standalone --email admin@example.com -d example.com -d www.example.com -d other.example.net 成功提示: 12345678910IMPORTANT NOTES:Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/sast.nymrli.top/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/sast.nymrli.top/privkey.pem Your cert will expire on 2019-02-08. To obtain a new or tweaked version of this certificate in the future, simply run certbot-auto again. To non-interactively renew *all* of your certificates, run \"certbot-auto renew\" - If you like Certbot, please consider supporting our work by: 3、配置Nginx: server 不再监听80端口，因为TLS要使用的是443端口，然后引入证书和key 123456789server&#123; listen 443 ssl; server_name sast.nymrli.top; //这里是你的域名 index index_page.html; root /var/www/homework_submission-master/; //网站目录 ssl_certificate /etc/letsencrypt/live/sast.nymrli.top/fullchain.pem; //前面生成的证书，改一下里面的域名就行，不建议更换路径 ssl_certificate_key /etc/letsencrypt/live/sast.nymrli.top/privkey.pem; //前面生成的密钥，改一下里面的域名就行，不建议更换路径&#125; 重启Nginx： 1sudo service nginx restart OK! 问题解决:1Problem binding to port 80: Could not bind to IPv4 or IPv6. 原因是 nginx 占用了80端口，输入service nginx stop。然后再次执行证书安装命令，即可顺利安装。安装完毕后，输入service nginx start，重启 nginx 服务。","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"}]},{"title":"pipenv 新款Python虚拟环境工具详解[转]","slug":"pipenv-新款Python虚拟环境工具详解-转","date":"2018-12-08T08:08:23.000Z","updated":"2018-12-08T08:08:44.023Z","comments":true,"path":"pipenv-新款Python虚拟环境工具详解-转.html","link":"","permalink":"https://nymrli.top/pipenv-新款Python虚拟环境工具详解-转.html","excerpt":"","text":"pipenv 新款Python虚拟环境工具详解[转]pipenv是requests库作者Kenneth Reitz编写的一个用于创建和管理Python虚拟环境的工具。 Pipenv是Python官方机构推荐的Python包工具。 我们知道，为了管理Python虚拟环境，通常用得比较多的是virtualenv和pyenv。但是有人觉得它们还不够好用，不够偷懒。这个人是谁，就是上面的那位。于是他开发了一个pipenv，结合了pip及virtualenv的功能和优点，集成出了pipenv这个工具。其目的是替代virtualenv和pyenv，将pip及virtualenv的功能集于一身。 一、安装pipenvwindows下很简单： 1pip install pipenv Linux下： 1sudo pip install pipenv 在苹果操作系统下： 1$ brew install pipenv 也就是说，无法用pip管理的包，pipenv同样无法使用。 pipenv依赖：psutil, virtualenv-clone, pew, certifi, urllib3, chardet, requests, mccabe, pyflakes, pycodestyle, flake8等第三方模块。 pipenv有很漂亮的彩色终端界面。 二、简单使用进入你的Python项目文件夹： 12cd your_projectpipenv install windows操作系统中，虚拟环境创建过程如下： 1234567891011121314151617D:\\test\\test_pipenv&gt;pipenv installCreating a virtualenv for this project…Using base prefix 'c:\\\\python36'New python executable in C:\\Users\\Administrator\\.virtualenvs\\test_pipenv-XHxuOsjn\\Scripts\\python.exeInstalling setuptools, pip, wheel...done.Virtualenv location: C:\\Users\\Administrator\\.virtualenvs\\test_pipenv-XHxuOsjnCreating a Pipfile for this project…Pipfile.lock not found, creating…Locking [dev-packages] dependencies…Locking [packages] dependencies…Updated Pipfile.lock (c23e27)!Installing dependencies from Pipfile.lock (c23e27)… ================================ 0/0 - 00:00:00To activate this project's virtualenv, run the following: $ pipenv shell 如果你给命令添加–two或–three参数，它将分别使用Python2或3来初始化你的虚拟环境，否则将使用默认的Python版本。 注意：pipenv默认把虚拟环境的真实文件全都放在了C:\\Users\\Administrator\\.virtualenvs\\test_pipenv-XHxuOsjn\\Scripts\\python.exe中，而在实际的项目文件夹内只创建了两个新文件Pipfile和Pipfile.lock。这可能造成C盘存有大量的文件，不是个好的做法。（但好像无法修改这一路径….） 看一下Pipfile中的内容： 1234567891011[[source]]url = \"https://pypi.python.org/simple\"verify_ssl = truename = \"pypi\"[packages][dev-packages] 最关键的是定义了安装第三方库使用的源，默认为官方的pypi。 而Pipfile.lock文件内容呢？ 12345678910111213141516171819202122232425262728293031&#123; \"_meta\": &#123; \"hash\": &#123; \"sha256\": \"5f0257fe8c7a73db1c8de519faa92c658282a01087eb2bfafba7962704c23e27\" &#125;, \"host-environment-markers\": &#123; \"implementation_name\": \"cpython\", \"implementation_version\": \"3.6.4\", \"os_name\": \"nt\", \"platform_machine\": \"AMD64\", \"platform_python_implementation\": \"CPython\", \"platform_release\": \"7\", \"platform_system\": \"Windows\", \"platform_version\": \"6.1.7601\", \"python_full_version\": \"3.6.4\", \"python_version\": \"3.6\", \"sys_platform\": \"win32\" &#125;, \"pipfile-spec\": 6, \"requires\": &#123;&#125;, \"sources\": [ &#123; \"name\": \"pypi\", \"url\": \"https://pypi.python.org/simple\", \"verify_ssl\": true &#125; ] &#125;, \"default\": &#123;&#125;, \"develop\": &#123;&#125;&#125; 初始情况下，文件里只包含一些操作系统的基本信息。 Pipfile和Pipfile.lock两个文件互相配合，完成虚拟环境的管理工作。 三、安装第三方模块Pipfile包含关于项目的依赖包的信息，并取代通常在Python项目中使用的requirements.txt文件。 如果你在具有requirements.txt文件的项目中启动了Pipenv，则在把它从项目中删除之前，应该使用Pipenv安装该requirements中列出的所有依赖包。 使用pipenv创建虚拟环境后，进入pipfile所在目录，使用install命令安装第三方库。 例如： 1pipenv install django 这个时候，你其实把pipenv当作pip来使用。无需像virtualenv那样需要额外的先启动虚拟环境。pipenv区分你是在给哪个虚拟环境工作，依赖的是Pipfile文件的位置。 要卸载某个第三方库： 1pipenv uninstall beautifulsoup4 四、冻结Pipfile冻结就相当于将项目所使用的第三方库列表进行打包输出，类似于virtualenv中生成requirements.txt文件。 通过更新Pipfile.lock来冻结库名称及其版本，以及其依赖关系的列表。需要使用lock参数： 1pipenv lock 如果另一个用户拷贝了你的项目，他们只需要安装Pipenv，然后： 1pipenv install Pipenv会在项目文件夹下自动寻找Pipfile和Pipfile.lock文件，创建一个新的虚拟环境并安装必要的软件包。 也就是说pipenv install的时候有三种逻辑： 如果目录下没有Pipfile和Pipfile.lock文件，表示创建一个新的虚拟环境； 如果有，表示使用已有的Pipfile和Pipfile.lock文件中的配置创建一个虚拟环境； 如果后面带诸如django这一类库名，表示为当前虚拟环境安装第三方库。 五、管理开发环境通常有一些Python包只在你的开发环境中需要，而不是在生产环境中，例如单元测试包。 Pipenv使用–dev标志区分两个环境。 1pipenv install --dev django django库现在将只在开发虚拟环境中使用。如果你要在你的生产环境中安装你的项目： 1pipenv install 这不会安装django包。 但是，如果有一个开发人员将你的项目克隆到自己的开发环境中，他们可以使用–dev标志，将django也安装： 1pipenv install --dev 也就是说一个–dev参数，帮你在同一个虚拟环境中又区分出了开发和非开发环境。 六、在虚拟环境中运行命令使用run参数，提供要运行的命令： 1pipenv run python manage.py runserver 这将使用当前虚拟环境关联的Python解释器，执行命令。 或者简单的执行脚本： 1pipenv run python your_script.py 如果你不想每次运行Python时都输入这么多字符，可以在shell中设置一个别名，例如， 1alias prp=\"pipenv run python\" 七、pipenv选项解释pipenv 具有下列的选项： 12345678910111213141516171819$ pipenvUsage: pipenv [OPTIONS] COMMAND [ARGS]...Options: --update 更新Pipenv &amp; pip --where 显示项目文件所在路径 --venv 显示虚拟环境实际文件所在路径 --py 显示虚拟环境Python解释器所在路径 --envs 显示虚拟环境的选项变量 --rm 删除虚拟环境 --bare 最小化输出 --completion 完整输出 --man 显示帮助页面 --three / --two 使用Python 3/2创建虚拟环境（注意本机已安装的Python版本） --python TEXT 指定某个Python版本作为虚拟环境的安装源 --site-packages 附带安装原Python解释器中的第三方库 --jumbotron 不知道啥玩意.... --version 版本信息 -h, --help 帮助信息 pipenv 可使用的命令参数： 12345678910Commands: check 检查安全漏洞 graph 显示当前依赖关系图信息 install 安装虚拟环境或者第三方库 lock 锁定并生成Pipfile.lock文件 open 在编辑器中查看一个库 run 在虚拟环境中运行命令 shell 进入虚拟环境 uninstall 卸载一个库 update 卸载当前所有的包，并安装它们的最新版本 一些使用例子： 123456789101112Usage Examples: 使用Python 3.6创建虚拟环境: $ pipenv --python 3.6 安装包括开发环境中的第三方库: $ pipenv install --dev 锁定pipfile: $ pipenv lock --pre Install a local setup.py into your virtual environment/Pipfile: $ pipenv install -e . 八、一些使用过程展示定位项目路径: 12$ pipenv --where/Users/kennethreitz/Library/Mobile Documents/com~apple~CloudDocs/repos/kr/pipenv/test 定位虚拟环境 12$ pipenv --venv/Users/kennethreitz/.local/share/virtualenvs/test-Skyy4vre 定位Python解释器： 12$ pipenv --py/Users/kennethreitz/.local/share/virtualenvs/test-Skyy4vre/bin/python 安装包： 12345678910$ pipenv installCreating a virtualenv for this project......No package provided, installing all dependencies.Virtualenv location: /Users/kennethreitz/.local/share/virtualenvs/test-EJkjoYtsInstalling dependencies from Pipfile.lock......To activate this project's virtualenv, run the following:$ pipenv shell 安装一个开发环境中才使用的包： 1234$ pipenv install pytest --devInstalling pytest......Adding pytest to Pipfile's [dev-packages]... 显示依赖关系： 123456$ pipenv graphrequests==2.18.4 - certifi [required: &gt;=2017.4.17, installed: 2017.7.27.1] - chardet [required: &gt;=3.0.2,&lt;3.1.0, installed: 3.0.4] - idna [required: &gt;=2.5,&lt;2.7, installed: 2.6] - urllib3 [required: &lt;1.23,&gt;=1.21.1, installed: 1.22] 生成lock文件: 123456$ pipenv lockAssuring all dependencies from Pipfile are installed...Locking [dev-packages] dependencies...Locking [packages] dependencies...Note: your project now has only default [packages] installed.To install [dev-packages], run: $ pipenv install --dev 安装开发环境依赖： 123456$ pipenv install --devPipfile found at /Users/kennethreitz/repos/kr/pip2/test/Pipfile. Considering this to be the project home.Pipfile.lock out of date, updating...Assuring all dependencies from Pipfile are installed...Locking [dev-packages] dependencies...Locking [packages] dependencies... 卸载所有的包： 12345$ pipenv uninstall --allNo package provided, un-installing all dependencies.Found 25 installed package(s), purging......Environment now purged and fresh! 使用虚拟环境的shell。exit退出： 123$ pipenv shellLoading .env environment variables…Launching subshell in virtual environment. Type 'exit' or 'Ctrl+D' to return. 本文来自刘江的博客和教程网站http://www.liujiangblog.com/blog/","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"#ifdef、#ifndef、#endif","slug":"ifdef、-ifndef、-endif","date":"2018-12-08T08:07:37.000Z","updated":"2018-12-08T08:08:08.970Z","comments":true,"path":"ifdef、-ifndef、-endif.html","link":"","permalink":"https://nymrli.top/ifdef、-ifndef、-endif.html","excerpt":"","text":"#ifdef、#ifndef、#endif使用说明目的:防止头文件重复include示例说明:a.h12#include &lt;stdio.h&gt;#include \"b.h\" b.h1#include \"a.h\" c.c12345#include \"a.h\"#include \"b.h\"int main()&#123; printf(\"Hello!\");&#125; 如果你程序是这样写的话，编译器就会出现Error #include nested too deeply的错误。因为这里 b.h 和 a.h 都互相include，c.c文件在include的时候重复include了a.h，我们希望c.c文件中执行#include “b.h”的时候 b.h 能进行判断，如果没有#include “a.h”则include，如果已经include了，则不再重复定义。 可以将b.h修改为： 1234#ifndef _A_H#define _A_H #include \"a.h\"#endif 原因是: &gt; c.c中先include了a.h文件，其中a.h中又包括了b.h，所以会定义宏_A_H，当c,c中又includeb,h时判断_A_H是否已经被定义了,如果被定义了,则不再includea.h","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"小程序——高德地图API调用","slug":"小程序——高德地图API调用","date":"2018-12-06T09:11:14.000Z","updated":"2018-12-06T12:47:07.286Z","comments":true,"path":"小程序——高德地图API调用.html","link":"","permalink":"https://nymrli.top/小程序——高德地图API调用.html","excerpt":"","text":"小程序——高德地图API调用配置将压缩包解压至使用的小程序目录下，创建libs文件夹，包含amap-wx.js 导入使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var amapFile = require('..­/../../../libs/amap-wx.js');Page(&#123; data: &#123; src: '' &#125;, onLoad: function () &#123; var that = this; var myAmapFun = new amapFile.AMapWX(&#123; key: \" dbb8be907441c2650218bdfd78848cf6\" &#125;); wx.getSystemInfo(&#123; success: function (data) &#123; //获得手机屏幕的高度宽度 var height = data.windowHeight; var width = data.windowWidth; var size = width + \"*\" + height; myAmapFun.getStaticmap(&#123; location: \"118.9301,32.109\", //地图中心 zoom: 15, //缩放比例 size: size, //尺寸大小 scale: 2, //像素,普通图、高清图 markers: //标记 \"large,0xFF0000,A:118.9301,32.109|mid,0xFF0000,B:118.9301,32.110\", success: function (data) &#123; that.setData(&#123; src: data.url &#125;) &#125;, fail: function (info) &#123; wx.showModal(&#123; title: info.errMsg &#125;) &#125; &#125;) &#125; &#125;) &#125;, onReady: function () &#123; &#125;, onShow: function () &#123; &#125;, onHide: function () &#123; &#125;, onUnload: function () &#123; &#125;, onPullDownRefresh: function () &#123; &#125;, onReachBottom: function () &#123; &#125;, onShareAppMessage: function () &#123; &#125;&#125;) API使用说明 参数名称 含义 规则说明 是否必填 默认值 key 用户唯一标识 用户在高德地图官网申请 必填 无 location 地图中心点 中心点坐标。规则：经度和纬度用”,”分隔 经纬度小数点后不得超过6位。 部分条件必填 无 zoom 地图级别 地图缩放级别:[1,17] 可选 无 size 地图大小 图片宽度图片高度。最大值为10241024 可选 400*400 scale 普通/高清 1:返回普通图；2:调用高清图，图片高度和宽度都增加一倍，zoom也增加一倍（当zoom为最大值时，zoom不再改变）。 可选 1 markers 标注 使用规则见markers详细说明，标注最大数10个 可选 无 labels 标签 使用规则见labels详细说明，标签最大数10个 可选 无 paths 折线 使用规则见paths详细说明，折线和多边形最大数4个 可选 无 traffic 交通路况标识 底图是否展现实时路况。 可选值： 0，不展现；1，展现。 可选 0 sig 数字签名 数字签名认证用户必填 可选 无 markers:123markers:\"large,0xFF0000,A:118.9301,32.109|mid,0xFF0000,B:118.9301,32.110\",//ormarkers:\"large,0xFF0000,A:118.9301,32.109;B:118.9301,32.110\", 参数名称 说明 默认值 size 可选值： small,mid,large small color 选值范围：[0x000000, 0xffffff]例如：0x000000 black,0x008000 green,0x800080 purple,0xFFFF00 yellow,0x0000FF blue,0x808080 gray,0xffa500 orange,0xFF0000 red,0xFFFFFF white 0xFC6054 label [0-9]、[A-Z]、[单个中文字] 当size为small时，图片不展现标注名。 无 label，font ,bold, fontSize，fontColor，background 自定义markersStyle: -1，url，0。-1表示为自定义图片，URL为图片的网址。自定义图片只支持PNG格式。 https://restapi.amap.com/v3/staticmap?markers=-1,http://ico.ooopic.com/ajax/iconpng/?id=158688.png,0:116.37359,39.92437&amp;key=您的key labelslabels=labelsStyle1:location1;location2|labelsStyle2:location3;location4..|labelsStyleN:locationN;locationM labelsStyle：label, font, bold, fontSize, fontColor, background。 各参数使用”,”分隔，如有默认值则可为空。 参数名称 说明 默认值 content 标签内容，字符最大数目为15 无 font 0：微软雅黑；1：宋体；2：Times New Roman;3：Helvetica 0 bold 0：非粗体；1：粗体 0 fontSize 字体大小，可选值[1,72] 10 fontColor 字体颜色，取值范围：[0x000000, 0xffffff] 0xFFFFFF background 背景色，取值范围：[0x000000, 0xffffff] 0x5288d8 pathspaths=pathsStyle1:location1;location2..|pathsStyle2:location3;location4..|pathsStyleN:locationN;locationM.. ▲.LocationN : 118.9301,32.109先经度后维度 pathsStyle：weight, color, transparency, fillcolor, fillTransparency 参数名称 说明 默认值 weight 线条粗细。可选值： [2,15] 5 color 折线颜色。 选值范围：[0x000000, 0xffffff]例如：0x000000 black,0x008000 green,0x800080 purple,0xFFFF00 yellow,0x0000FF blue,0x808080 gray,0xffa500 orange,0xFF0000 red,0xFFFFFF white 0x0000FF transparency 透明度。可选值[0,1]，小数后最多2位，0表示完全透明，1表示完全不透明。 1 fillcolor 多边形的填充颜色，此值不为空时折线封闭成多边形。取值规则同color 无 fillTransparency 填充面透明度。可选值[0,1]，小数后最多2位，0表示完全透明，1表示完全不透明。 0.5 折线示例: 1paths: '10,0x0000ff,1,,:116.31604,39.96491;116.320816,39.966606;116.321785,39.966827;116.32361,39.966957', 区域示例: 1paths: \"10,0x0000ff,0.1,0x0000ff,0.7:116.31604,39.96491;116.320816,39.966606;116.321785,39.966827;116.32361,39.966957;116.39361,39.966957;116.39361,39.936957\",","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"小程序","slug":"小程序","permalink":"https://nymrli.top/tags/小程序/"}]},{"title":"HTML和CSS学习","slug":"HTML和CSS学习","date":"2018-12-06T02:57:32.000Z","updated":"2018-12-06T02:59:19.689Z","comments":true,"path":"HTML和CSS学习.html","link":"","permalink":"https://nymrli.top/HTML和CSS学习.html","excerpt":"","text":"HTML学习&lt;head&gt;中的&lt;meta&gt;标签 属性 值 描述 http-equiv content-typeexpiresrefreshset-cookie 把 content 属性关联到 HTTP 头部。 name authordescriptionkeywordsgeneratorrevisedothers 把 content 属性关联到一个名称。 scheme some_text 定义用于翻译 content 属性值的格式。 name 属性 name 属性提供了名称/值对中的名称。 “keywords” 是一个经常被用到的名称。它为文档定义了一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。 1&lt;meta name=\"keywords\" content=\"HTML,ASP,PHP,SQL\"&gt; ▲如果没有提供 name 属性，那么名称/值对中的名称会采用 http-equiv 属性的值。 http-equiv 属性http-equiv 属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。 使用带有 http-equiv 属性的 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。例如，添加： 12&lt;meta http-equiv=\"charset\" content=\"iso-8859-1\"&gt;&lt;meta http-equiv=\"expires\" content=\"31 Dec 2008\"&gt; 这样发送到浏览器的头部就应该包含： 123content-type: text/htmlcharset:iso-8859-1expires:31 Dec 2008 content 属性content 属性提供了名称/值对中的值。该值可以是任何有效的字符串。 content 属性始终要和 name 属性或 http-equiv 属性一起使用。 标签 &lt;em&gt;和&lt;strong&gt;标签是为了强调一段话中的关键字时使用，它们的语义是强调。 &lt;span&gt;标签是没有语义的，它的作用就是为了设置单独的样式用的。 &lt;q&gt;引用文本&lt;/q&gt;,注意要引用的文本不用加双引号，浏览器会对q标签自动添加双引号。 &lt;blockquote&gt;引用长文本&lt;/blockquote&gt; 使用&lt;br&gt;标签分行显示文本 空格&amp;nbsp; 认识&lt;hr /&gt;标签，添加水平横线 &lt;address&gt;标签，为网页加入地址信息 &lt;code&gt;var i=i+300;&lt;/code&gt;一行代码 &lt;pre&gt;语言代码段&lt;/pre&gt;大段代码 使用&lt;ul&gt;，添加新闻信息列表 创建表格table的四个元素： tbody：如果不加&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt; , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。 tr表格的一行，所以有几对tr 表格就有几行。 th表格表头。 td一行中数据单元格的个数。 &lt;caption&gt;标题文本&lt;/caption&gt; &lt;table summary=&quot;表格简介文本&quot;&gt;摘要 CSS学习Q:CSS样式可以写在哪些地方呢？A: 内联式 : 把css代码直接写在现有的HTML标签中 &lt;p style=&quot;color:red&quot;&gt;这里文字是红色。&lt;/p&gt; 嵌入式 : 把css样式代码写在&lt;style type=&quot;text/css&quot;&gt;&lt;/style标签之间，一般情况下嵌入式css样式写在&lt;head&gt;&lt;/head&gt;之间 12345&lt;style type=\"text/css\"&gt;span&#123;color:red;&#125;&lt;/style&gt; 外部式 : 把css代码写一个单独的外部文件中,这个css样式文件以“.css”为扩展名 &lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; ▲.三种方法的优先级 内联式 &gt; 嵌入式 &gt; 外部式 嵌入式&gt;外部式有一个前提：嵌入式css样式的位置一定在外部式的后面 ==&gt;其实总结来说，就是--就近原则（离被设置元素越近优先级别越高）。 权值:标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100 12345p&#123;color:red;&#125; /*权值为1*/p span&#123;color:green;&#125; /*权值为1+1=2*/.warning&#123;color:white;&#125; /*权值为10*/p span.warning&#123;color:purple;&#125; /*权值为1+1+10=12*/#footer .note p&#123;color:yellow;&#125; /*权值为100+10+1=111*/ 还有一个权值比较特殊–继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。 ==&gt;根据权值和层叠的想法:内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 提高权值的方法:重要性12p&#123;color:red!important;&#125;p.first&#123;color:green;&#125; CSS格式化排版字体 font-family: 字体 body{font-family:&quot;宋体&quot;;} font-size:字号 body{font-size:12px;color:#666} 1234p span&#123;font-weight:bold;&#125; //粗体p a&#123;font-style:italic;&#125; //斜体p a&#123;text-decoration:underline;&#125; //下划线.oldPrice&#123;text-decoration:line-through;&#125; //删除线 段落排版 text-indent:段落缩进 p{ text-indent:2em;} 行间距（行高） p{ line-height:1.5em;} 中文字间距、字母间距 h1{ word-spacing:50px;} 为块状元素中的文本、图片设置居中样式 h1{ text-align:center;} 元素分类块状元素(block) 1&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行） 2、元素的高度、宽度、行高以及顶和底边距都可设置。 3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 内联元素(又叫行内元素):inline 1&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 1、和其他元素都在一行上； 2、元素的高度、宽度及顶部和底部边距不可设置； 3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 内联块状元素(inline-block） 1&lt;img&gt;、&lt;input&gt; 1、和其他元素都在一行上； 2、元素的高度、宽度、行高以及顶和底边距都可设置。 盒子模型 块级元素都具有盒子模型的特征 外边距 : marigin 内边距 : padding 边框 : border 盒模型–宽度和高度元素的实际高度为 : 自身height+ padding-top +padding-bottom 元素的实际宽度为 : 自身width+ padding-left +padding-right ▲ 一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 总宽度计算: 开发工具查看: 边框: border-style（边框样式）常见样式有： dashed（虚线）| dotted（点线）| solid（实线） border-color（边框颜色）中的颜色可设置为十六进制颜色，如: border-color:#888;//前面的井号不要忘掉。 border-width（边框宽度）中的宽度也可以设置为： thin | medium | thick（但不是很常用），最常还是用像素（px）。 css布局模型1、流动模型（Flow）2、浮动模型 (Float)3、层模型（Layer） 流动模型（Flow）流动（Flow）是默认的网页布局模式. 2个比较典型的特征： 第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。 第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行） 浮动模型 (Float) 想让两个块状元素并排显示..任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动， 1234567/*实现两个 div 元素一行显示。*/div&#123; width:200px; height:200px; border:2px red solid; float:left;&#125; 层模型（Layer） 如何让html元素在网页中精确定位，就像图像软件PhotoShop中的图层一样可以对每个图层能够精确定位操作 1、绝对定位(position: absolute) 将元素从文档流中拖出来，然后使用left(距离左)、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口 2、相对定位(position: relative) 相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 Q:什么叫做“偏移前的位置保留不动” A: 虽然div元素相对于以前的位置产生了偏移，但是div元素以前的位置还是保留着，所以后面的span元素是显示在了div元素以前位置的后面。 ===&gt; 所占的位置不变,但是显示的位置发生了变化. 3、固定定位(position: fixed) 与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身. 由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响， 用途 : 可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。 水平居中设置行内元素 如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的 块状元素 定宽~ : 宽度width为固定值 通过设置“左右margin”值为“auto”来实现居中的 不定宽~ 加入 table 标签 table长度自适应性,其长度根据其内文本长度决定 12345678910111213&lt;div&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt; &lt;ul&gt; &lt;li&gt;我是第一行文本&lt;/li&gt; &lt;li&gt;我是第二行文本&lt;/li&gt; &lt;li&gt;我是第三行文本&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; css代码： 123456&lt;style&gt;table&#123; border:1px solid; margin:0 auto;&#125;&lt;/style&gt; ▲补充代码实现右侧中的 class 为 wrap 的 div 水平居中显示（要注意是这个 div元素 居中，而不是里面的文本居中啊）。 设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置 改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。如下例子： html代码： 123456789&lt;body&gt;&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; css代码： 1234567891011121314151617&lt;style&gt;.container&#123; text-align:center;&#125;/* margin:0;padding:0（消除文本与div边框之间的间隙）*/.container ul&#123; list-style:none; margin:0; padding:0; display:inline;&#125;/* margin-right:8px（设置li文本之间的间隔）*/.container li&#123; margin-right:8px; display:inline;&#125;&lt;/style&gt; ▲ 改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。如下例子： 父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的 代码如下： 123456789&lt;body&gt;&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; css代码： 1234567891011121314151617&lt;style&gt;.container&#123; float:left; position:relative; left:50%&#125;.container ul&#123; list-style:none; margin:0; padding:0; position:relative; left:-50%;&#125;.container li&#123;float:left;display:inline;margin-right:8px;&#125;&lt;/style&gt; 垂直居中父元素高度确定的单行文本 通过设置父元素的 height 和 line-height 高度一致来实现的。 1234567&lt;style&gt;.container&#123; height:100px; line-height:100px; background:#999;&#125;&lt;/style&gt; 父元素高度确定的多行文本、图片 使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。 html代码： 12345678910111213&lt;body&gt;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=\"wrap\"&gt; &lt;div&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt; css代码： 12345table td&#123; height:500px; background:#ccc&#125;/*因为 td 标签默认情况下就默认设置了 vertical-align 为 middle，所以我们不需要显式地设置了。*/ 在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的display为 table-cell（设置为表格单元显示），激活 vertical-align 属性 html代码： 1234567&lt;div class=\"container\"&gt; &lt;div&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; css代码： 12345678&lt;style&gt;.container&#123; height:300px; background:#ccc; display:table-cell;/*IE8以上及Chrome、Firefox*/ vertical-align:middle;/*IE8以上及Chrome、Firefox*/&#125;&lt;/style&gt; 隐性改变display类型 position : absolute float : left 或 float:right 只要html代码中出现以上两句之一，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"HTML","slug":"HTML","permalink":"https://nymrli.top/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://nymrli.top/tags/CSS/"}]},{"title":"Pyinstaller使用","slug":"Pyinstaller使用","date":"2018-12-03T03:54:22.000Z","updated":"2018-12-03T03:57:42.957Z","comments":true,"path":"Pyinstaller使用.html","link":"","permalink":"https://nymrli.top/Pyinstaller使用.html","excerpt":"","text":"pyinstaller使用安装1、安装pywin32==&gt;pyinstaller依赖于 下载安装文件：查找到跟自己适用的python版本及window系统版本匹配的pywin32，下载后安装 使用pip命令安装：pip install pywin32 2、安装Pyinstaller 下载安装文件安装：官网 使用pip命令安装：pip install PyInstaller 使用Pycharm直接搜索pyinstaller会自动安装依赖库pywin32 使用1、使用下载安装的方式安装的Pyinstaller打包方式将需要打包的文件放在解压得到的Pyinstaller文件夹中，打开cmd窗口，把路径切换到当前路径打开命令提示行，输入以下内容（最后的是文件名）==&gt;调用pyinstaller.py文件打包： python pyinstaller.py -F myfile.py 2、使用pip方式安装的Pyinstaller打包方式打开cmd窗口，把路径切换到文件所在路径(文件随便放在哪里都行)打开命令提示行，输入以下内容（最后的是文件名）： pyinstaller -F myfile.py 使用实例pyinstaller -F test.py -i src\\logo.ico -F 表示生成单个可执行文件 -w 表示去掉控制台窗口，这在GUI界面时非常有用。不过如果是命令行程序的话那就把这个选项删除吧！ -p 表示你自己自定义需要加载的库路径，一般情况下用不到 -i 表示可执行文件的图标 ▲. -i的参数为.ico格式,其他格式的图片会报错 文件中使用了第三方库的打包方式在打包之前务必找到第三方库的包，把包复制到到跟myfile.py同目录下，然后再使用以上2种方式打包，否则会打包失败或者即使打包成功，程序也会闪退。 pyqt5打包出现错误一 、当写这篇文章的时候，pyinstaller官网版本对pyqt5打包可能会遇到Could not find QtWebEngineProcess.exe.的错误。解决方法为：安装最新的pyinstaller 1.在github下载新版本的开发包。2.打开解压后的文件夹，shift+鼠标右键，点击“在此处打开命令窗口”。之后依次运行如下命令: 123pip uninstall pyinstallerpython setup.py buildpython setup.py install 二 、如果有报错：“could not find or load the Qt platform plugin &quot;windows&quot; ”。原因之一可能是你把打包后的文件放在了中文目录下。只需要将打包后的文件放在英文目录下，就可以解决。 多文件打包1234pyinstaller [主文件] -p [其他文件1] -p [其他文件2] --hidden-import [自建模块1] --hidden-import [自建模块2]# 以上为一整条命令 1pyinstaller main.py -p mysql.py -p other.py --hidden-import mysql --hidden-import other","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"pyqt5与QT5","slug":"pyqt与QT5","date":"2018-11-26T04:11:52.000Z","updated":"2018-11-26T05:17:39.620Z","comments":true,"path":"pyqt与QT5.html","link":"","permalink":"https://nymrli.top/pyqt与QT5.html","excerpt":"","text":"添加QT Designer、PyUIc、Pyrcc 1.添加外部工具(Extenal Tools)QT Designer File–&gt;Settings–&gt;Tools–&gt;Extenal Tools –&gt; ‘’+’’ &gt; 添加具体细节,如图一图二 ​ 图一 ​ 图二 修改Name为QT Designer,Program为QT目录下designer.exe文件,不需要参数,Work directory为D:\\QT\\{QT version}\\msvc2015_64\\bin 添加后就可以在菜单栏的Tools中找到..点击后,就可以直接打开QT Designer设计窗口 QT Designer QT UIC1.Program设置为当前虚拟环境的python解释器python.exe,(一旦设置好后,每次新建虚拟环境,pycharm会自动帮你修改选择的解释器) 2.▲.Arguments参数设置为: 12345-mPyQt5.uic.pyuic$FileName$-o$FileNameWithoutExtension$.py 这个参数主要是用uic这个工具需要指定的参数 3.working directory设置为$FileDir$(当前文件目录)===&gt;含义是:根据.UI生成的py窗口文件的位置完成后,效果如图..一开始是没有window.py 将光标选择window.ui文件,然后选择Tools里面的PyUIC就可以自动生成一个window.py文件直接使用了. 控制台输出内容: 123G:\\PyGui\\venv\\Scripts\\python.exe -m PyQt5.uic.pyuic window.ui -o window.py#点击PyUIC就相当于输出了在setting里面写好的代码,$FileName$为我们光标选择的文件名,输出的名字为$FileNameWithoutExtension$.py,输出的路径为当前文件目录$FileDir$Process finished with exit code 0 QT Rcc1.将program设置为QT目录下的rcc.exe文件 2.设置Arguments为123$FileName$-o$FileNameWithoutExtension$.py 道理同上-o 是输出的意思 3.work directory设置为$FileDir$4.新建.qrc资源文件打开QT Designer选择下面的资源管理器,单击铅笔,如图操作 单击左边蓝色的存储后,意思是指定.qrc文件存储位置 选择好以后,再操作右边的选择卡,填好前缀,然后点击蓝色的按键,选择要添加的资源文件(如图片什么的) 此时打开.qrc文件就可以看到他指定了哪些资源文件 上述步骤完成后就可以使用rcc工具将.qrc文件转换成.py的资源文件使用了 光标选择.qrc资源后,选择Pyrcc后就会生成相应的py文件 需要用到图片时,直接导入图片的.py文件即可 12[mainwindow.py]import picture 12345678910111213[main.py]#显示加载界面if __name__ == '__main__': app = QApplication(sys.argv) splash = QSplashScreen(QPixmap(':/load/loading.jpg')) splash.show() splash.showMessage('正在加载请稍等..') time.sleep(0.5) app.processEvents() ui = caofunction.MyWindow() ui.show() splash.finish(ui) sys.exit(app.exec_()) ####","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"机器学习——数学概念","slug":"机器学习——数学概念","date":"2018-11-24T05:00:34.000Z","updated":"2018-11-24T09:14:58.469Z","comments":true,"path":"机器学习——数学概念.html","link":"","permalink":"https://nymrli.top/机器学习——数学概念.html","excerpt":"","text":"箱线图Confusion_martrix(混淆矩阵)混淆矩阵: 一种特定的矩阵用来呈现算法性能的可视化效果，通常是监督学习（非监督学习，通常用匹配矩阵：matching matrix） 其每一列代表预测值，每一行代表的是实际的类别。这个名字来源于它可以非常容易的表明多个类别是否有混淆（也就是一个class被预测成另一个class）。 Example样例说明:假设有一个用来对猫（cats）、狗（dogs）、兔子（rabbits）进行分类的系统，混淆矩阵就是为了进一步分析性能而对该算法测试结果做出的总结。假设总共有 27 只动物：8只猫， 6条狗， 13只兔子。结果的混淆矩阵如下图： 在这个混淆矩阵中，实际有 8只猫，但是系统将其中3只预测成了狗；对于 6条狗，其中有 1条被预测成了兔子，2条被预测成了猫。从混淆矩阵中我们可以看出系统对于区分猫和狗存在一些问题，但是区分兔子和其他动物的效果还是不错的。所有正确的预测结果都在对角线上，所以从混淆矩阵中可以很方便直观的看出哪里有错误，因为他们呈现在对角线外面。 Table of confusion(混淆表格)有时也称混淆矩阵. 由false positives，false negatives，true positives和true negatives组成的两行两列的表格。它允许我们做出更多的分析，而不仅仅是局限在正确率.。 它允许我们做出更多的分析，而不仅仅是局限在正确率。准确率对于分类器的性能分析来说，并不是一个很好地衡量指标，因为如果数据集不平衡（每一类的数据样本数量相差太大），很可能会出现误导性的结果。例如，如果在一个数据集中有95只猫，但是只有5条狗，那么某些分类器很可能偏向于将所有的样本预测成猫。整体准确率为95%，但是实际上该分类器对猫的识别率是100%，而对狗的识别率是0%。 对于上面的说明样例，其对应的对猫这个类别的混淆表格如下： 假定一个实验有 P个positive实例，在某些条件下有 N 个negative实例。那么上面这四个输出可以用下面的偶然性表格（或混淆矩阵）来表示： 更多详情见博客 摘自博客 : https://blog.csdn.net/vesper305/article/details/44927047","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"数学知识","slug":"数学知识","permalink":"https://nymrli.top/tags/数学知识/"}]},{"title":"机器学习——python实践.笔记","slug":"机器学习——Python实践-笔记","date":"2018-11-23T13:20:18.000Z","updated":"2018-11-24T08:41:41.865Z","comments":true,"path":"机器学习——Python实践-笔记.html","link":"","permalink":"https://nymrli.top/机器学习——Python实践-笔记.html","excerpt":"","text":"机器学习——Python实践 Numpy: python开源数值计算拓展,用来存储和处理大型矩阵,提供了许多高级的数值编程工具,如 矩阵数据类型、矢量处理、精密的运算库 利用Numpy数组来准备机器学习算法的数据 matplotlib: python中最著名的2D绘图库,适合交互式的进行制图;也可作为绘图空间,嵌入GUI应用程序中 创建图表,展示数据 Pandas: 基于Numpy的工具,为了解决数据分析任务而创建的.~纳入了大量库和标准的数据模型,提供了操作大型数据集的工具,和快速便捷处理数据的函数和方法 导入、展示数据，以便挣钱对数据的理解和数据清洗、转换等工作 ##### 预测模型所需的六个步骤: 第一章：鸢尾花(Iris Flower) 所有特征数据都是数字,不需要考虑如何导入和处理数据—&gt;有的图表有标题等的,需要处理- 分类问题===&gt;监督学习算法 多分类问题,可能需要一些特殊处理 所有特征的数值采用相同单位,不需要进行尺度转换 步骤: 1.导入数据集123456789from pandas import read_csvfrom matplotlib import pyplotfrom sklearn.svm import SVCfilename = 'iris.data.csv'names = ['separ-length','separ-width','petal-length','petal-width','class']# 花萼长度+宽度 , 花瓣长度+宽度dataset = read_csv(filename,names = names)print(dataset) # 150 * 5 2.概述数据 从下列角度审查数据: 数据的维度 查看数据的自身 统计描述所有的数据特征 数据分类的分布情况 1.数据的维度了解数据集中有多少行数据,数据有几个属性 12print('数据的维度: 行 %s , 列 %s' % (dataset.shape))#&gt;&gt;&gt;数据的维度: 行 150 , 列 5 2.参看数据本身直观的看到数据的特征,数据的类型,以及大概的数据分布范围 12345678print(dataset.head(5))&gt;&gt;&gt; separ-length separ-width ... petal-width class0 5.1 3.5 ... 0.2 Iris-setosa1 4.9 3.0 ... 0.2 Iris-setosa2 4.7 3.2 ... 0.2 Iris-setosa3 4.6 3.1 ... 0.2 Iris-setosa4 5.0 3.6 ... 0.2 Iris-setosa 3.统计描述数据数据特征的统计描述信息包括数据的行数、中位值、最大值、最小值、均值、四分位值等统计数据信息 1234567891011print(dataset.describe())&gt;&gt;&gt; separ-length separ-width petal-length petal-widthcount 150.000000 150.000000 150.000000 150.000000mean 5.843333 3.054000 3.758667 1.198667std 0.828066 0.433594 1.764420 0.763161min 4.300000 2.000000 1.000000 0.10000025% 5.100000 2.800000 1.600000 0.30000050% 5.800000 3.000000 4.350000 1.30000075% 6.400000 3.300000 5.100000 1.800000max 7.900000 4.400000 6.900000 2.500000 4.数据分类分布了解数据在不同分类的分布情况..==&gt;每个分类数据量的绝对数值 1234567print(dataset.groupby('class').size())&gt;&gt;&gt;classIris-setosa 50Iris-versicolor 50Iris-virginica 50dtype: int64 ▲ 如果数据分布不平衡,可能会影响到模型的准确性,..==&gt;不平衡时,需要对数据进行调整,方法有: 扩大数据样本 通常容易被忽略的选择…但往往找到更大的数据集就有可能挖掘出更平衡的方面提高算法准确度 数据的重新抽样 过抽样(复制少数类样本)..数据少时考虑 欠抽样(删除多数类样本)..数据多时考虑 尝试生成人工样本 从少数类的实例中随机抽样特征属性,生成更多数据 异常检测和变化检测 尝试从不同观点思考,异常检测是对罕见事件的检测,将小类作为异常值类 3.数据可视化 单变量图表: 理解每一个特征属性 多变量图表: 理解不同特征属性之间的关系 单变量图: 箱线图: 一种用作显示一组数据分散情况资料的统计图。因形状如箱子而得名。 主要用于反映原始数据分布的特征，还可以进行多组数据分布特征的比 较。箱线图的绘制方法是：先找出一组数据的最大值、最小值、中位数和两个四分位数；然后， 连接两个四分位数画出箱子；再将最大值和最小值与箱子相连接，中位数在箱子中间。 12345678#箱线图 , 因为每个特征属性都是数字 , 所以 用箱线图展示 属性与中位值的离散程度dataset.plot(kind='box',subplots = True,layout = (2,2) , sharex = False , sharey = False)# 参数说明 : box箱线 , subplots 允许多个子图, layout 布局为2*2 , sharex.sharey 不共享x,ypyplot.show()#---#直方图 , x轴为值 , y轴为数量dataset.hist()pyplot.show() 多变量图:12345from pandas.plotting import scatter_matrix#散点矩阵图scatter_matrix(dataset)pyplot.show()#pyplot.savefig(\"scatter_matrix.png\") 4.评估算法 分离出评估数据集 采用10折交叉验证来评估算法模型 生成6个不同的模型来预测新数据 选择最优模型 1.分离出评估数据集:heart:要想知道算法模型对真是数据的准确度,所以保留一部分数据来评估算法模型. 12345678from sklearn.model_selection import train_test_splitarray = dataset.valuesX = array[:,0:4] #除了最后的class类别Y = array[:,4] #类别,目标validation_size = 0.2 #验证比例seed = 7 #随机种子X_train , X_validation , Y_train , Y_validation = \\ train_test_split(X,Y,test_size=validation_size,random_state=seed) 2.评估模式采用10折交叉验证来分离训练数据集 : 随机将数据分成10份,9份用来训练模型,1份用来评估算法 3.创建模型线性 线性回归(LR) 线性判别分析(LDA) 非线性 K近邻(KNN) 分类与回归树(CART) 贝叶斯分类器(NB) 支持向量机(SVM) ▲ 在每次对算法进行评估前都会重新设置随机数种子,以保证每次对算法的评估都是用相同的数据集 12345678910111213141516171819202122from sklearn.linear_model import LogisticRegression,LinearRegression #LRfrom sklearn.tree import DecisionTreeClassifier #CARTfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis #LDAfrom sklearn.naive_bayes import GaussianNB #NBfrom sklearn.neighbors import KNeighborsClassifier #KNNfrom sklearn.svm import SVC #SVMfrom sklearn.model_selection import KFold,cross_val_scoremodels = &#123;&#125;models['LR'] = LogisticRegression()models['LDA'] = LinearDiscriminantAnalysis()models['CART'] = DecisionTreeClassifier()models['NB'] = GaussianNB()models['KNN'] = KNeighborsClassifier()models['SVM'] = SVC()#评估算法resutls = []for key in models: kfold = KFold(n_splits=10,random_state=seed) cv_result = cross_val_score(models[key],X_train,Y_train,cv = kfold , scoring = 'accuracy') #cross_val_score将交叉验证的整个过程连接起来，不用再进行手动的分割数据, cv参数用于规定将原始数据分成多少份 resutls.append(cv_result) print(\"%s: %f (%f)\" % (key,cv_result.mean(),cv_result.std())) #均值,标准差 4.选择最优模型1234567&gt;&gt;&gt;LR: 0.966667 (0.040825)LDA: 0.975000 (0.038188)CART: 0.966667 (0.040825)NB: 0.975000 (0.053359)KNN: 0.983333 (0.033333)SVM: 0.991667 (0.025000) 为什么使用 10折交叉验证?进行模型验证的一个重要目的是要选出一个最合适的模型，对于监督学习而言，我们希望模型对于未知数据的泛化能力强，所以就需要模型验证这一过程来体现不同的模型对于未知数据的表现效果。 训练准确度==&gt;测试准确度最先我们用训练准确度（用全部数据进行训练和测试）来衡量模型的表现，这种方法会导致模型过拟合(方差大)；===&gt;&gt;为了解决这一问题，我们将所有数据分成训练集和测试集两部分，我们用训练集进行模型训练，得到的模型再用测试集来衡量模型的预测表现能力，这种度量方式叫测试准确度，这种方式可以有效避免过拟合。 测试准确度==&gt;10折交叉验证测试准确度的一个缺点是其样本准确度是一个高方差估计（high variance estimate）, 所以该样本准确度会依赖不同的测试集，其表现效果不尽相同。 12345678910111213for i in xrange(1,5): print \"random_state is \", i,\", and accuracy score is:\" X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=i) knn = KNeighborsClassifier(n_neighbors=5) knn.fit(X_train, y_train) y_pred = knn.predict(X_test) print metrics.accuracy_score(y_test, y_pred)&gt;&gt;&gt;random_state is 1 , and accuracy score is:1.0random_state is 2 , and accuracy score is:1.0random_state is 3 , and accuracy score is:0.947368421053random_state is 4 , and accuracy score is:0.973684210526 上面的测试准确率可以看出，不同的训练集、测试集分割的方法导致其准确率不同，而交叉验证的基本思想是：1.将数据集进行一系列分割，生成一组不同的训练测试集，2.然后分别训练模型并计算测试准确率，3.最后对结果进行平均处理。这样来有效降低测试准确率的差异。 K折交叉验证: 将数据集平均分割成K个等份子集 使用1份数据(子集)作为测试数据，其余(K-1)份作为训练数据 计算测试准确率 使用不同的测试集，重复2、3步骤 对测试准确率做平均，作为对未知数据预测准确率的估计 ==&gt; cross_val_score.mean() 不同的训练集、测试集分割的方法导致其准确率不同，而交叉验证的基本思想是：将数据集进行一系列分割，生成一组不同的训练测试集，然后分别训练模型并计算测试准确率，最后对结果进行平均处理。这样来有效降低测试准确率的差异。 来自周志华&lt;&lt;机器学习&gt;&gt;: 分割方法1234# 下面代码演示了K-fold交叉验证是如何进行数据分割的# simulate splitting a dataset of 25 observations into 5 foldsfrom sklearn.cross_validation import KFoldkf = KFold(25, n_folds=5, shuffle=False) 12cv_result = cross_val_score(models[key],X_train,Y_train,cv = 10 , scoring = 'accuracy')#cross_val_score将交叉验证的整个过程连接起来，不用再进行手动的分割数据, cv参数用于规定将原始数据分成多少份 5.实施预测12345678910111213141516171819#使用评估数据集评估算法svm = SVC()svm.fit(X = X_train ,y = Y_train) #参数为 X , ypredictions = svm.predict(X_validation)print(accuracy_score(Y_validation,predictions)) #测试集结果 与 预测结果 相比print(confusion_matrix(Y_validation,predictions))print(classification_report(Y_validation,predictions))&gt;&gt;&gt;0.9333333333333333[[ 7 0 0] [ 0 10 2] #混淆矩阵只出现了两个错误,2 [ 0 0 11]] precision(精确度) recall(召回率) f1-score(F1值) support(总和) Iris-setosa 1.00 1.00 1.00 7Iris-versicolor 1.00 0.83 0.91 12 Iris-virginica 0.85 1.00 0.92 11 avg / total 0.94 0.93 0.93 30 召回率(Recall Rate,也叫查全率) 是检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率； 精度(Precise) 是检索出的相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率。 TP: 预测为正，实际为正 (第一个是实际T或F,第二个是预测P或N) FP: 预测为正，实际为负 TN:预测为负，实际为负 FN: 预测为负，实际为正 精确率、准确率：Accuracy=(TP+TN)/(TP+TN+FN+FP) //精准率、查准率：P = TP/ (TP+FP) 召回率、查全率：R = TP/ (TP+FN) F1-score: 2*TP/(2*TP + FP + FN) ◆. 精确度是“搜索结果有多大用处”，而召回是“结果如何完整”。 F1分数: 概述 : 统计学中用来衡量二分类模型精确度的一种指标。它同时兼顾了分类模型的准确率和召回率。F1分数可以看作是模型准确率和召回率的一种加权平均，它的最大值是1，最小值是0。 人们通常使用准确率和召回率这两个指标，来评价二分类模型的分析效果。 但是当这两个指标发生冲突时，我们很难在模型之间进行比较。比如，我们有如下两个模型A、B，A模型的召回率高于B模型，但是B模型的准确率高于A模型，A和B这两个模型的综合性能，哪一个更优呢？ 准确率 召回率 A 80% 90% B 90% 80% 为了解决这个问题，人们提出了 分数。的物理意义就是将准确率和召回率这两个分值合并为一个分值，在合并的过程中，召回率的权重是准确率的 倍。 分数认为召回率和准确率同等重要， 分数认为召回率的重要程度是准确率的2倍，而 分数认为召回率的重要程度是准确率的一半。 ▲ 如何计算Precise、Recall、F1-score见博客https://blog.csdn.net/akadiao/article/details/78788864 Confusion_martrix(混淆矩阵)混淆矩阵: 一种特定的矩阵用来呈现算法性能的可视化效果，通常是监督学习（非监督学习，通常用匹配矩阵：matching matrix） 其每一列代表预测值，每一行代表的是实际的类别。这个名字来源于它可以非常容易的表明多个类别是否有混淆（也就是一个class被预测成另一个class）。 Example样例说明:假设有一个用来对猫（cats）、狗（dogs）、兔子（rabbits）进行分类的系统，混淆矩阵就是为了进一步分析性能而对该算法测试结果做出的总结。假设总共有 27 只动物：8只猫， 6条狗， 13只兔子。结果的混淆矩阵如下图： 在这个混淆矩阵中，实际有 8只猫，但是系统将其中3只预测成了狗；对于 6条狗，其中有 1条被预测成了兔子，2条被预测成了猫。从混淆矩阵中我们可以看出系统对于区分猫和狗存在一些问题，但是区分兔子和其他动物的效果还是不错的。所有正确的预测结果都在对角线上，所以从混淆矩阵中可以很方便直观的看出哪里有错误，因为他们呈现在对角线外面。**","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Pycharm里无法查看Sqlite数据表","slug":"Pycharm里无法查看Sqlite数据表","date":"2018-11-23T07:27:38.000Z","updated":"2018-11-23T07:32:06.720Z","comments":true,"path":"Pycharm里无法查看Sqlite数据表.html","link":"","permalink":"https://nymrli.top/Pycharm里无法查看Sqlite数据表.html","excerpt":"","text":"Pycharm里无法查看Sqlite数据表听说Pycharm可以直接看数据库,于是试了试,发现无法读取sqlite数据库的内容…于是发现下载相应的驱动.如图 解决方法:一.打开右侧的Database选项卡,选择Data Source的Sqlite 二.点击黄色三角Download下载相应的驱动软件 三.安装完成,正常使用","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://nymrli.top/tags/数据库/"}]},{"title":"flask-sqlalchemy使用与sqlalchemy对比","slug":"flask-sqlalchemy使用与sqlalchemy对比","date":"2018-11-23T07:22:48.000Z","updated":"2018-12-06T03:07:03.384Z","comments":true,"path":"flask-sqlalchemy使用与sqlalchemy对比.html","link":"","permalink":"https://nymrli.top/flask-sqlalchemy使用与sqlalchemy对比.html","excerpt":"","text":"flask-sqlalchemy使用与sqlalchemy对比flask-sqlalchemy12345678910111213141516171819202122232425from exts import dbclass MGroup(db.Model): __tablename__ = 'Group' id = db.Column(db.Integer, primary_key=True, autoincrement=True) name = db.Column(db.String(50),nullable=False,unique = True)class MUserinfo(db.Model): __tablename__ = 'Userinfo' id = db.Column(db.Integer,primary_key=True,autoincrement=True) stuid = db.Column(db.String(15),unique = True ,nullable=False) subject = db.Column(db.String(50), nullable=False) name = db.Column(db.String(10), nullable=False) qq = db.Column(db.Integer,nullable = False) dirction = db.Column(db.String(20),db.ForeignKey('Group.name'),default='3D仿真组')class Mmessage(db.Model): __tablename__ = 'Contact' id = db.Column(db.Integer,primary_key=True,autoincrement=True) name = db.Column(db.String(10), nullable=False) email = db.Column(db.String(20), nullable=False) subject = db.Column(db.String(20), nullable=False) message = db.Column(db.Text, nullable=False) sqlalchemy123456789101112131415161718192021import sqlalchemyfrom sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmakerprint(sqlalchemy.__version__)engine = create_engine('sqlite:///test.db',echo = True) #将数据库执行的语句打印出来Base = declarative_base() #声明一个基类实例class User(Base): __tablename__ = 'User' #表的名称 #类的属性,而不是在析构函数中定义的原因是,Base类中有构造函数 Uid = sqlalchemy.Column(sqlalchemy.Integer,autoincrement=True,primary_key=True) name = sqlalchemy.Column(sqlalchemy.String(20),nullable=False) def __str__(self): return \"&lt;Uid&gt;:&#123;&#125;,&lt;name&gt;:&#123;&#125;\".format(self.Uid,self.name)Base.metadata.create_all(engine) #创建数据库表,sqlalchemy会自动覆盖已存在的表 flask-sqlalchemy sqlalchemy 表继承的类 db = SQLAlchemy(app),db.Model Base = declarative_base() 都是从工厂函数中声明的一个实例类,作为声明性类基类 链接数据库函数 create_engine() 创建表函数 db.create_all() Base.metadata.create_all(engine) 表单字段 db.Column() sqlalchemy.Column() 字段类型 db.Integer sqlalchemy.Integer 插入数据 msg = Mmessage(name=data.get(‘name’),email=data.get(‘email’), subject=data.get(‘subject’),message=data.get(‘message’)) db.session.add(msg) db.session.commit() user = User(name=’mrli’) Session = sessionmaker(bind=engine) session = Session() session.add(user) session.commit() 查询 Item.query.filter(Item.table == json_data.get(&#39;table&#39;)).first() user = session.query(User).filter_by(name=&#39;mrli&#39;).first() backref 文本输出 def __repr__(self): （与django的__str__不同） sqlalchemy:查: 1234567891011121314151617181920212223242526272829user = session.query(User).all()user = session.query(User).filter_by(name='mrli').first()# 排序for row in user = session.query(User).order_by(User.id): pass# in_for row in session.query(User).filter(User.name.in_(['nymrli','cl'])): pass&gt;&gt;&gt; &lt;Uid&gt;:1,&lt;name&gt;:mrli&gt;&gt;&gt;&gt; &lt;Uid&gt;:3,&lt;name&gt;:qsy for row in session.query(~User.name.in_(['nymrli','cl'])): print(row) &gt;&gt;&gt;(True,)&gt;&gt;&gt;(False,)&gt;&gt;&gt;(True,)# ~ in for row in session.query(User).filter(~User.name.in_(['nymrli','cl'])): pass#计数user = session.query(User).filter(User.name=='mrli').count()#▲.注意filter()的==与filter_by()的=的使用区别# and_ or_ sqlalchemy core (核心层,更接近SQL语句) 代码很接近、形似SQL原生语句,可以写sqlalchemy的SQL方言(dialect) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import sqlalchemyfrom sqlalchemy import create_enginefrom sqlalchemy import Table,MetaDataprint(sqlalchemy.__version__)engine = create_engine('sqlite:///test.db',echo = True) #将数据库执行的语句打印出来metadata = MetaData()users = Table( 'users',metadata, sqlalchemy.Column('id',sqlalchemy.Integer,primary_key=True), sqlalchemy.Column('name',sqlalchemy.String))addresses = Table( 'addresses' , metadata, sqlalchemy.Column('id', sqlalchemy.Integer, primary_key=True), sqlalchemy.Column('user_id', None,primary_key('users.isd')), sqlalchemy.Column('email_address', sqlalchemy.String, nullable=False))metadata.create_all(engine)users = Table( 'users',metadata, sqlalchemy.Column('id',sqlalchemy.Integer,primary_key=True), sqlalchemy.Column('name',sqlalchemy.String))addresses = Table( 'addresses' , metadata, sqlalchemy.Column('id', sqlalchemy.Integer, primary_key=True), sqlalchemy.Column('user_id', None,primary_key('users.id')), sqlalchemy.Column('email_address', sqlalchemy.String, nullable=False))metadata.create_all(engine)conn = engine.connect()conn.execute(users.insert(),[ dict(name='nymrli'), dict(name='cl')])conn.execute(users.insert(),[ dict(user_id=1,email_address='1063052964@qq.com'), dict(user_id=1,email_address='2042423232@qq.com'), dict(user_id=2, email_address='1063052923@qq.com'), dict(user_id=2, email_address='2042423232@qq.com'),])from sqlalchemy.sql import selects = select([users])result = conn.execute(s)for x in result: print(x)# s = select([users.addresses]).where(users.c.id == addresses.c.user_id)from sqlalchemy.sql import texts = text( \"SELECT user.name || ',' || addresses.email_address AS title \" \"FROM users.addresses \" \"WHERE users.id == addresses.user_id \" \"AND users.name BETWEEN :x AND :y \" \"AND (addresses.email_address LIKE :e1 \" \"OR addresses.email_address LIKE :e2)\")print(conn.execute(s,x='m',y='z',e1=\"%@aoq.com\",e2='@qwe.com').fetchall()) 注意下最后text()里面写的内容””引号最后要有空格,与下面的语句分割开 无空格的样子: 有空格的样子","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://nymrli.top/tags/数据库/"}]},{"title":"Flask系列–将应用部署在Heroku上","slug":"Flask系列–将应用部署在Heroku上","date":"2018-11-21T07:54:01.000Z","updated":"2018-11-21T08:58:36.911Z","comments":true,"path":"Flask系列–将应用部署在Heroku上.html","link":"","permalink":"https://nymrli.top/Flask系列–将应用部署在Heroku上.html","excerpt":"","text":"Flask补充系列–将应用部署在Heroku上之前曾经介绍过如何将Flask应用部署在自己的服务器上，对于手头并不宽裕的程序员来说，购置一台托管服务器还是一笔不小的开销。即便现在有公有云服务器可以买，不过如果你只是以学习为目的，这笔开销还是能省则省了。另外，如果你的应用中需要访问国外被河蟹掉的资源，在服务器上翻墙也是件麻烦事，所以这里我们补充一篇如何将Flask应用部署在Heroku上。 环境准备Heroku是一个PaaS服务提供商，使用前，你需要先注册一个Heroku帐号，注册帐号是免费的。 此外你本地必须要有Python 2.7的开发环境，并且装好了Pip, Setuptools, Virtualenv等工具。对于Python开发者来说，这些都是必备的吧。此外Git客户端也是必须的，因为Heroku的代码管理用的是Git。 Heroku提供了一个非常方便的Getting Start教程，每种开发环境都有，我们可以打开Python的Getting Start，然后参照其说明创建一个Python Web应用。懒得看英文的朋友们，可以看我下面写的步骤。 在开始创建应用之前，你还需要安装Heroku的客户端工具，你可以根据你本地的操作系统选择安装包下载。这是一个命令行工具，基于Ruby实现，所以使用起来每个操作系统都一样。安装完成后，你可以打开命令行，输入下面的命令来验证安装是否成功： 1$ heroku --version 如果安装成功，就在本地命令行里登录Heroku，执行命令： 1$ heroku login 并输入你注册号的Heroku帐号及密码即可。 创建应用网页创建应用环境准备就绪了，我们开始创建一个应用。浏览器打开Heroku应用控制台，点击右上角的”+”号，并选择”Create new app”。 在创建页面中，输入你的应用名称，比如”flask-bjhee”，如果名称没有被占用，则会跳出绿色提示”flask-bjhee is available”。运行环境默认在美国，也可以选择欧洲。信息填完后，点击下方的”Create App”按钮，应用就创建完成了。 接下来打开命令行，我们要初始化本地及远程代码库： 1234$ mkdir /home/bjhee/flask-bjhee # 创建本地代码工作目录$ cd /home/bjhee/flask-bjhee # 切换到本地代码工作目录$ git init # 创建本地代码库$ heroku git:remote -a flask-bjhee # 连接远程Heroku的flask-bjhee代码库 现在，我们就可以编写应用代码，并提交到Heroku上去了。 命令行创建应用 1234$ heroku create (xxx) #省略会自动默认$ git add .$ git commit -m \"yyy\"$ heroku git:remote -a flask-bjhee 部署应用既然主要是在讲部署，那代码逻辑就简单些，Hello World吧。我们写一个Flask Web程序”run.py”，内容如下： 123456789from flask import Flaskapp = Flask(__name__) @app.route('/')def index(): return 'Hello World!' if __name__ == '__main__': app.run(host='0.0.0.0', debug=True) 然后，我们就写个”requirements.txt”文件，应用部署时Heroku远程环境会自动执行： 1$ pip install -r requirements.txt 来安装应用依赖的库。我们的”requirements.txt”文件如下： 12Flask==0.10.1gunicorn==19.4.5 项目依赖Flask很好理解，为什么还要依赖gunicorn呢？因为我们不能靠Flask自带的Web服务器来运行Flask程序，所以gunicorn是个很好的选择。还记得如何通过Gunicorn运行Flask应用吗？对于上面的代码，我们只需执行”gunicorn run:app”即可。现在我们要告诉Heroku，应该使用这个命令来运行我们的应用。怎么做呢，就是在项目根目录里创建一个”Procfile”文件，然后写上： 1web: gunicorn run:app --log-file - 这就告诉Heroku，启动Web时，要执行”gunicorn run:app –log-file -“。后面的”–log-file -“参数，是为了让日志只打印到标准输出stdout上，因为Heroku不提供我们写本地磁盘的功能。 再接下来，我们要写一个app.json来描述项目信息，”app.json”内容大致如下： 1234567&#123; \"name\": \"Flask sample on Heroku\", \"description\": \"An example of deploying Flask web app to Heroku.\", \"image\": \"heroku/python\", \"repository\": \"https://git.heroku.com/flask-bjhee\", \"keywords\": [\"python\", \"flask\" ]&#125; 另外根据习惯，我们应该写一个”README.md”来给用户看，”.gitignore”描述哪些文件类型不需要提交到代码库中去。好了，现在我们的目录结构如下： 1234567flask-bjhee/ ├ .gitignore ├ app.json ├ Procfile ├ README.md ├ requirements.txt └ run.py 让我们执行git提交命令，来部署到远程Heroku上去吧： 123$ git add .$ git commit -m \"Initialize Project\"$ git push heroku master # 提交到远程master分支 想看看效果，命令行里输入： 1$ heroku open 就会启动浏览器，并打开地址”https://flask-bjhee.herokuapp.com/”，当然你也可以直接浏览器访问这个地址。有没有看到”Hello World!”？ 本篇的示例代码可以在这里下载。 部分转自: 思诚之道 ▲ 注意部署的时候有两个文件不能少,分别是Procfile和requestments.txt(名字必须完全一样,我就是拼错了一次和少了个s),失败的报错情况如图 完成后是这样的.heorku会自动根据你提供的requestments.txt安装相应的依赖库 配置数据库环境、迁移文件、表heroku提供了自己的控制台,打开的命令为heroku run bash,之后就可以像在linux的终端下一样操作了 除了这种方法还可以指明使用heroku命令,需要做的是加上前缀heroku run,如heroku run python manage.py db init 官方介绍为:(如图 自定义域名1$ heroku domains:add apollo.nymrli.top ▲.注意需要认证账户,否则会出现下图结果 待认证好后,还需要用DNS解析,我用的是阿里云的万网解析,将heroku domains:add apollo.nymrli.top后heroku的值用CHAME记录解析.等个几秒后就可以用apollo.nymrli.top访问heroku上面的应用程序了 还有一个做法呢,是直接在heroku相应app的设置里面设置自定义域名,但是由于显示问题,容易复制错,导致无法被解析的问题…如果设置好CHAME解析30秒后还是无法用自定义域名打开的话,看看是不是值复制错了. 所以还是比较建议用命令heroku domains:add xxx来绑定","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"}]},{"title":"二分搜索降低时间复杂度","slug":"二分搜索降低时间复杂度","date":"2018-11-10T13:36:01.000Z","updated":"2018-11-10T13:38:14.609Z","comments":true,"path":"二分搜索降低时间复杂度.html","link":"","permalink":"https://nymrli.top/二分搜索降低时间复杂度.html","excerpt":"","text":"二分搜索降低时间复杂度123456int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;n;i++) cin &gt;&gt; s[i]; canFit(); return 0;&#125; 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 150using namespace std;int n,m,s[MAXN];int ss[MAXN];bool canFit()&#123; int flag = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) for(int l=0;l&lt;n;l++) if( s[i] + s[j] + s[l] + s[k] == m) flag = true; if(flag) cout &lt;&lt; \"YES\"; else cout &lt;&lt; \"NO\" ;&#125; 时间复杂度为O(n^4),只能在n较小的情况下,若n较大,则TLE.. 时间复杂度为O(n^3log2(n))的做法:一层二分搜索 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 150using namespace std;int n,m,s[MAXN];int ss[MAXN];bool binSearch(int k)&#123; int r=n,l=0; while(l &lt;= r)&#123; int i = (r+l)/2; if ( s[i] == k) return true; else if( s[i] &lt; k) l = i+1; else r= i-1; &#125; return false;&#125;bool canFit()&#123; int flag = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if( binSearch(m-s[i] - s[j] - s[k]) flag = true; if(flag) cout &lt;&lt; \"YES\"; else cout &lt;&lt; \"NO\" ;&#125; O(n^2log2(n))做法: 排序O(n^2log2(n)),循环O(n^2log2(n)),总共也是O(n^2log2(n)) 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 150using namespace std;int n,m,s[MAXN];int ss[MAXN];bool binSearch(int k)&#123; int l=0,r=n*n; while(l &lt;= r)&#123; int i = (r+l)/2; if ( s[i] == k) return true; else if( s[i] &lt; k) l = i+1; else r= i-1; &#125; return false;&#125;void enumeration()&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) ss[i*n+j] = s[i] + s[j];&#125;bool canFit()&#123; enumeration(); sort(ss,ss+n*n); //二分搜索的前提是有序 int flag = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if( binSearch(m- s[i] - s[j] )) flag = true; if(flag) cout &lt;&lt; \"YES\"; else cout &lt;&lt; \"NO\" ;&#125; ▲需要注意的是,ss[n*n]的数组需要先排序才能使用二分搜索 —-出自:&lt;&lt;挑战程序设计竞赛&gt;&gt;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"matplotlib.pyplot使用","slug":"matplotlib-pyplot使用","date":"2018-11-10T04:58:51.000Z","updated":"2018-11-10T05:02:47.069Z","comments":true,"path":"matplotlib-pyplot使用.html","link":"","permalink":"https://nymrli.top/matplotlib-pyplot使用.html","excerpt":"","text":"matplotlib.pyplot使用温习源自WeiboSpider12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Cgraph(object): def __init__(self): self.db = db self.create_dir() self.Start_timestmp = time.mktime(time.strptime('2018-7-5 00:00','%Y-%m-%d %H:%M')) def judge_over(self, _time): # start_time is timestamp ''' 判断时间是否已经超过预设时间 :param Start_timestmp: :param _time: :return: ''' timestamp = time.mktime(time.strptime(_time, '%Y-%m-%d %H:%M')) # Start_timestamp = time.mktime(time.strptime(Start_time,'%Y-%m-%d %H:%M')) if timestamp - self.Start_timestmp &lt; 0: return True else: return False def create_dir(self): if not os.path.isdir('.\\\\graph'): os.makedirs('.\\\\graph') def count(self,lists): exist_dict = OrderedDict() for x in lists: if x not in exist_dict: exist_dict[x] = 1 else: exist_dict[x] += 1 return dict(sorted(exist_dict.items(),key=lambda x:x[0])) def unify_time(self,_time): c = _time.split('-') _time = '-'.join(['0' + x if len(x.strip()) == 1 else x for x in c]) if _time[:4] == '2018': _time = _time[5:10] return _time[:10] def Draw(self): timelist = [] for alls in self.db.find(): if alls.get('time'): print(alls.get('time')) timelist.append(self.unify_time(alls.get('time'))) infodict = self.count(timelist[::-1]) plt.figure(figsize=(40, 18)) #设置图片大小 # plt.rcParams['figure.figsize'] = (40.0, 12.0) 设置图片大小的另外一种方法 # plt.rcParams['figure.dpi'] = 400 x = list(infodict.keys()) y = list(infodict.values()) plt.plot(x,y,linewidth=2,color='r',marker='o',markersize=8) for x_value,y_value in zip(x,y): plt.text(x_value,y_value,y_value,fontsize= 15) #文字标注(x,y,值) plt.ylim((0, max(y))) #纵坐标y的上下限 plt.yticks([x for x in range(0,max(y)+10,10)]) #y的比例尺 plt.xlabel('Time') plt.ylabel('Keyword times') #y轴的标签 plt.title('Weibo Keyword\\'s Trendency') #图的标题 plt.savefig('.\\\\graph\\\\&#123;&#125;.jpg'.format(TABLE)) #保存图片 plt.clf()if __name__ == '__main__': graph = Cgraph() graph.Draw() print('完成') 使用:大物实验画折线图12345678910111213141516171819202122232425262728293031323334import csvfrom matplotlib import pyplot as pltimport osimport numpy as npI = []U = []def extractFromCsv(filename): with open(filename,'r') as f: reader = csv.reader(f) for row in reader: if reader.line_num == 1: #跳过表头 continue U.append(float(row[0])) I.append((float(row[1])))def drawPic(filename): fig = plt.figure(dpi=256, figsize=(10, 8)) plt.plot(U,I,'r*') plt.xlabel('U(V)',fontsize=10) plt.ylabel('I(10e-9A)',fontsize=10) plt.title('The line chart of the relation between U and I',fontsize=15) plt.ylim(0,max(I)+0.5) x = np.linspace(0,max(I)+0.5,40) plt.yticks(x,fontsize=6) if not os.path.exists(\".\\\\graph\"): os.mkdir('.\\\\graph') plt.savefig('.\\\\graph\\\\&#123;&#125;.jpg'.format(filename))if __name__ == \"__main__\": filename='phy.csv' extractFromCsv(filename) drawPic(filename) 图形类型 散列图 ax1.scatter(x,y,c = &#39;r&#39;,marker = &#39;o&#39;) 折线图plt.plot() 直方图plt.hist() 条形图plt.bar(left=index,height=y,color=&#39;green&#39;,width=0.5) 饼状图:plt.pie(x=fracs,labels=labels,autopct=&#39;%.0f%%&#39;,explode=explode)#autopct显示百分比 箱形图plt.boxplot(data,labels=labels) scatter基本的用法","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"apt代理的设置","slug":"apt代理的设置","date":"2018-11-10T04:56:53.000Z","updated":"2018-11-10T04:57:21.033Z","comments":true,"path":"apt代理的设置.html","link":"","permalink":"https://nymrli.top/apt代理的设置.html","excerpt":"","text":"原因是在apt-get update时遇到了Unable to connect to 代理，（由于apt-get update一直显示无法连接172.17.18.141百度后发现并不是个特殊的IP,）于是想到是否使用了代理。 apt代理的设置：临时方法export http_proxy=http://10.3.0.1:80 长久方法(1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。) Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;; 保存apt.conf文件。 (2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件) 建立文件 vim proxyfile Acquire::http::proxy &quot;http://10.3.0.1:80&quot;; Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;; Acquire::https::proxy &quot;http://10.3.0.1:80&quot;; 使用时sudo apt-get install xxx -c proxyfile (2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 ) 在您的.bashrc文件末尾添加如下内容export http_proxy=http://用户名:密码@地址:端口/export https_proxy=http://用户名:密码@地址:端口/ export ftp_proxy=http://用户名:密码@地址:端口/ https://blog.csdn.net/qq3399013670/article/details/81300497","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://nymrli.top/tags/Ubuntu/"},{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"Ubuntu更改nginx默认端口","slug":"Ubuntu更改nginx默认端口","date":"2018-11-10T04:55:13.000Z","updated":"2018-11-10T04:56:15.277Z","comments":true,"path":"Ubuntu更改nginx默认端口.html","link":"","permalink":"https://nymrli.top/Ubuntu更改nginx默认端口.html","excerpt":"","text":"Ubuntu更改nginx默认端口 nginx 默认使用80端口，有时候我们希望nginx运行在其他端口，就需要更改nginx配置 nginx配置文件在/etc/nginx目录下的nginx.conf。(可以修改处理器数量、日志路径、pid文件路径等，默认的日志。) 错误日志 /var/log/nginx/error.log访问日志 /var/log/nginx/access.log 在nginx.conf-&gt;http选项末尾有引入两个目录下的文件分别为： 123456[/etc/nginx/nginx.conf]http &#123; # 省略部分内容 include /etc/nginx/conf.d/*.conf; #意思是把用户自己的配置放到conf.d/* include /etc/nginx/sites-enabled/*;&#125; 查看/etc/nginx/sites-enabled/目录，会找到一个default文件，在server选项下前两行就可以找到使用的80端口号： 1234[/etc/nginx/sites-enabled/default]server &#123; listen 80 default_server; listen [::]:80 default_server; 将80端口号改为想使用的端口号，保存文件，如果没有启动nginx，启动即可。如果nginx已经在运行，重新加载即可。 12sudo nginx start #运行nginxsudo nginx -s reload #重启nginx 如果遇到nginx报以下错误：nginx: [error] open() &quot;/run/nginx.pid&quot; failed (2: No such file or directory)则`sudo nginx -c path/.conf #指定nginx配置.conf的位置` 查看nginx运行的端口`sudo netstat -anp | grep nginx` ▲如果启用防火墙，则需开启对应端口，使用AWS服务器需要更改服务器安全组，添加响应入站规则，开启对应端口。","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://nymrli.top/tags/Ubuntu/"}]},{"title":"Pythonanywhere解决链接Mysql问题(部署flask)","slug":"Pythonanywhere解决链接Mysql问题-部署flask","date":"2018-11-10T04:54:14.000Z","updated":"2018-11-10T04:54:43.145Z","comments":true,"path":"Pythonanywhere解决链接Mysql问题-部署flask.html","link":"","permalink":"https://nymrli.top/Pythonanywhere解决链接Mysql问题-部署flask.html","excerpt":"","text":"Pythonanywhere解决链接Mysql问题(部署flask) 由于在bash控制台里通过命令mysql -p(这其实是因为错误的连接方式,由于不是默认的端口3306,自然连接不到,官方文档中有正确的连接方式)链接不到Mysql时,再加上进虚拟环境用python manage db migrate也失败后,我是异常慌张的..然后立马发现关于pythonanywhere链接Mysql的解决不是很多,要么就是说免费账号是无法用的…心顿时拔凉,但最后还是找到了pythonanywhere官方的文档,解决了这个问题,发现都是配置的问题 一开始的我本地及阿里云链接mysql数据库配置文件是这样写的: 1234567891011121314#[config.py]DIALECT = 'mysql'DRIVER = 'pymysql'USERNAME = 'root'PASSWORD = 'zxcqwe' #瞎写的HOST = '127.0.0.1'PORT = '3306'DATABASE = 'restaurant'DEBUG = TrueSQLALCHEMY_DATABASE_URI = \"&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8\".format( DIALECT,DRIVER,USERNAME,PASSWORD,HOST,PORT,DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False 后来根据说明改成了如下: 123456789101112#[config.py]DIALECT = 'mysql'DRIVER = 'pymysql'USERNAME = 'nymrli'PASSWORD = 'zxcqwe' #瞎写的HOST = 'nymrli.mysql.pythonanywhere-services.com'PORT = '3306'DATABASE = 'nymrli$restaurant'DEBUG = TrueSQLALCHEMY_DATABASE_URI = \"&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8\".format( DIALECT, DRIVER, USERNAME, PASSWORD, HOST, PORT, DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False 其中修改的地方为 USERNAME为pythonanywhere账号 PASSWORD为Database详情页设置的数据库密码 HOST为Database详情页上的Database host address DATABASE为Database详情页上 create a database的数据库名,但pythonanywhere会自动给你加上前缀&lt;username&gt;$&lt;database_name&gt;,所以我这边就是nymrli$restaurant PORT默认还是3306 附上官方文档:配置说明: 开始使用MySQL,您需要去在仪表板的MySQL选项卡,并设置一个密码。你也会找到连接设置选项卡(主机名、用户名),以及创建新的数据库的能力。 你可以开始一个新的MySQL控制台访问数据库从这个选项卡,或者您可以打开一个MySQL从bash shell使用以下命令控制台或ssh会话: mysql -u USERNAME -h HOSTNAME -p &#39;USERNAME$DATABASENAME&#39; Using MySQL 通过SSH链接,据说免费账户不支持:12345678910Setting ValueSSH Hostname: ssh.pythonanywhere.comSSH Username: your PythonAnywhere usernameSSH Password: the password you use to log in to the PythonAnywhere websiteSSH Key file: should not be necessary when you specify the passwordMySQL Hostname: your PythonAnywhere database hostname, eg. yourusername.mysql.pythonanywhere-services.comMySQL Server Port: 3306Username: your PythonAnywhere usernamePassword: your PythonAnywhere database passwordDefault Schema: your database name, eg yourusername$mydatabase Accessing your MySQL database from outside PythonAnywhere","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"MySQL","slug":"MySQL","permalink":"https://nymrli.top/tags/MySQL/"}]},{"title":"写爬虫过程中碰到的编码问题","slug":"写爬虫过程中碰到的编码问题","date":"2018-11-08T04:23:19.000Z","updated":"2018-12-03T15:02:19.224Z","comments":true,"path":"写爬虫过程中碰到的编码问题.html","link":"","permalink":"https://nymrli.top/写爬虫过程中碰到的编码问题.html","excerpt":"","text":"写爬虫过程中碰到的编码问题遇到 ‘ \\uxxxx ‘ 的16进制字符串编解码问题，使用unicode-escape解决之。实际上，在将unicode存储到文本的过程中，还有一种存储方式，不需要将unicode转换为实际的文本存储字符集，而是将unicode的内存编码值进行存储，读取文件的时候再反向转换回来，是采用：unicode-escape的转换方式。 将unicode的内存编码值进行存储，读取文件时在反向转换回来。这里就采用了unicode-escape的方式 12345678print(u'中文测试'.encode('utf-8'))print('中文测试'.encode('utf-8'))print(u'中文测试'.encode('unicode-escape'))print('中文测试'.encode('unicode-escape'))==&gt; b'\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe6\\xb5\\x8b\\xe8\\xaf\\x95'==&gt; b'\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe6\\xb5\\x8b\\xe8\\xaf\\x95'==&gt; b'\\\\u4e2d\\\\u6587\\\\u6d4b\\\\u8bd5'==&gt; b'\\\\u4e2d\\\\u6587\\\\u6d4b\\\\u8bd5' ASCII码只有128个字符，符合英文，一个英文字符只用1个字节(最高位恒为0) ANSI：面向中文编码的GBK、GB2312是ANSI码的一种，ANSI码是对ASCII的拓展，所以一个英文只用一个字节，而中文需要拓展ASCII，所以用到两个字节。 0x80~0xFFFF =&gt;2**16 Unicode编码:为了解决不同国家ANSI编码的冲突问题，最常用的是用两个字节表示一个字符 。但是这样的话，原本可以用一个字节存储的英文字母在Unicode里面必须存两个字节，这就产生了浪费。那么有没有一种既能消除乱码，又能避免浪费的编码方式呢？===&gt;答案就是UTF-8 。000000 -10FFFF 12&gt; UNICODE 的范围是 0x0000 - 0xFFFF 共6万多个字符，其中光汉字就占用了4万多个&gt; UTF-8编码：当字符在ASCII码的范围时，就用一个字节表示 ，所以英文字符也只用一个字节，▲值得注意的是unicode编码中一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。utf-8长度是1-6个字节 （可变的） Unicode编码(十六进制) UTF-8 字节流(二进制) 000000-00007F 0xxxxxxx 000080-0007FF 110xxxxx 10xxxxxx 000800-00FFFF 1110xxxx 10xxxxxx 10xxxxxx 010000-10FFFF 11110xxx 10xxxxxx 10xxxxxx10xxxxxx 超出10FFFF后，UTF-8与Unicode不再对应 总结： UTF-8 vs GBK： UTF-8版本虽然具有良好的国际兼容性，但中文需要比GBK/BIG5版本多占用50%的数据库存储空间，因此并非推荐使用，仅供对国际兼容性有特殊要求的用户使用。简单地说：对于中文较多的网站，适宜用GBK编码节省数据库空间。对于英文较多的网站，适宜用UTF-8节省数据库空间。 字符编码ANSI和ASCII区别、Unicode和UTF-8区别 Python中编码问题 在python中，unicode是内存编码集，一般我们将数据存储到文件时，需要将数据先编码为其他编码集，比如utf-8、gbk等。 读取数据的时候再通过同样的编码集进行解码即可。 但是其实还有一种unicode-escape编码集，他是将unicode内存编码值直接存储： 在使用python3的requests模块时，发现获取响应有两种方式 其一，为文本响应内容, r.text是Unicode的响应内容 其二，为二进制响应内容，r.content是二进制的响应内容 Python2 的编码问题一直非常让人恼火，不过你的问题稍微简单一些。在交互式命令模式(Interactive shell)下，可以这样来明白你遇到的问题的根源： 1234567import sys sys.stdout.encoding 在 Windows 下，如果你的系统是简体中文，一般输出会是 cp936 import codecs codecs.lookup('cp936').name 'gbk' 这就是在 Windows 终端里面使用的编码。在 print 的时候，无论字符串源采取什么样的编码，最终输出的字符串的编码必须跟 shell 的编码一致，也就是说:print some_stringPython 会做这样一个动作：codecs.encode(some_string, coding, errors=’strict’)在你遇到的情况下，some_string 是一个 unicode 字符串，coding 是 gbk。由于你的 unicode 字符串里面包含 gbk 字符集里面没有的字符，Python 就会抛出一个 UnicodeEncodeError. 对于输出到文件中情况是类似的，Python2 的 open() 函数不会传入 encoding，以 ‘w’ 方式打开文件，如果写入 unicode 字符串，Python 会获取当前默认的编码，然后以此种编码把字符串写入文件。可惜的是，“默认编码”只是 Python 自己默认的，在 Objects/unicodeobject.c 中，用一个全局变量 unicode_default_encoding 来表示默认的编码： /* Default encoding to use and assume when NULL is passed as encoding parameter; it is initialized by _PyUnicode_Init(). ​ Always use the PyUnicode_SetDefaultEncoding() and​ PyUnicode_GetDefaultEncoding() APIs to access this global. static char unicode_default_encoding[100 + 1] = &quot;ascii&quot;;这个值在 Python 中有C接口（PyUnicode_SetDefaultEncoding）去改变，但可惜的是没有 Python 层的接口。所以在调用到类似 file.write(some_string) 的时候，首先会有这样的编码过程:codecs.encode(some_string, coding, errors=’restrict’)当你的 some_string 是一个 unicode 字符串，并且包含 ascii 字符串不存在的字符时，就会抛出一个 UnicodeEncodeError。 所以，为了解决这个问题，可以这么处理： (1) 在 Windows shell 下面: &gt;&gt;&gt; print some_string.encode(‘gbk’, errors=’ignore’) # replace 也可，只要不是 restrict(2) 在写入文件时，两种方法： a. 忽略不存在的字符，同(1) &gt;&gt;&gt; f = open(filename, ‘w’) &gt;&gt;&gt; f.write(some_string.encode(‘gbk’, errors=’ignore’) b. byte 方式写入： &gt;&gt;&gt; f = open(filename, ‘wb’) &gt;&gt;&gt; f.write(some_string.encode(‘utf-8’))​ a 会损失字符，b 不会。 来自http://www.newsmth.net/nForum/#!article/Python/124657 如果CMD命令行是gbk编码的，则输出的utf-8字符有些也显示不了 Win10 临时修改cmd命令行窗口UTF-8编码 只作用于当前打开的窗口 进入cmd窗口后，直接执行“chcp 65001”，执行完后，cmd的编码格式就是UTF-8 永远修改 Windows 控制台使用注册表永久修改编码问题方法一：1.在cmd中输入regedit进入注册表 2.找到HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe 3.新建一个 DWORD（32位值）,命名为CodePage，值设为65001 4.已有CodePage的话，修改它，改为十进制，65001 方法二：(亲测有效)1.新建一个cmd.reg注册表文件: 2.内容输入如下： 123456789Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe]\"CodePage\"=dword:0000fde9\"FontFamily\"=dword:00000036\"FontWeight\"=dword:00000190\"FaceName\"=\"Consolas\"\"ScreenBufferSize\"=dword:232900d2\"WindowSize\"=dword:002b00d2 3.双击运行","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"}]},{"title":"Shell脚本基础","slug":"Shell脚本基础","date":"2018-11-08T04:19:49.000Z","updated":"2018-11-08T04:20:26.700Z","comments":true,"path":"Shell脚本基础.html","link":"","permalink":"https://nymrli.top/Shell脚本基础.html","excerpt":"","text":"Shell编写打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。 12#!/bin/bash#!/usr/bin/php “#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。 作为可执行程序12chmod +x test.sh./test.sh 注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。 变量定义变量12your_name=\"qinjx\"▲.变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。 使用变量使用一个定义过的变量，只要在变量名前面加美元符号即可，如： 123your_name=\"qinjx\"echo $your_nameecho $&#123;your_name&#125; 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： 123for skill in Ada Coffe Action Java; do echo \"I am good at $&#123;skill&#125;Script\"done 字符串字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了，哈哈），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。 单引号1str='this is a string' 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行） 双引号12your_name='qinjx'str=\"Hello, I know your are \\\"$your_name\\\"! \\n\" 双引号里可以有变量 双引号里可以出现转义字符 字符串操作拼接字符串12345your_name=\"qinjx\"greeting=\"hello, \"$your_name\" !\"greeting_1=\"hello, $&#123;your_name&#125; !\"echo $greeting $greeting_1 获取字符串长度：12string=\"abcd\"echo $&#123;#string&#125; #输出：4 提取子字符串12string=\"alibaba is a great company\"echo $&#123;string:1:4&#125; #输出：liba 查找子字符串12string=\"alibaba is a great company\"echo `expr index \"$string\" is`#输出：3，这个语句的意思是：找出字母i在这名话中的位置，要在linux下运行，mac下会报错 流程控制和Java、PHP等语言不一样，sh的流程控制不可为空，如： 1234567&lt;?phpif (isset($_GET[\"q\"])) &#123; search(q);&#125;else &#123; //do nothing&#125; 在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。 还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下： 12ll /usr/bin/[-rwxr-xr-x. 1 root root 33408 6月 22 2012 /usr/bin/[ 正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0] if elseif1234567if conditionthen command1 command2 ... commandN fi 写成一行（适用于终端命令提示符）： 1if `ps -ef | grep ssh`; then echo hello; fi 末尾的fi就是if倒过来拼写，后面还会遇到类似的 if else123456789if conditionthen command1 command2 ... commandNelse commandfi if else-if else12345678if condition1then command1elif condition2 command2else commandNfi for whilefor在开篇的示例里演示过了： 1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 写成一行： 1for var in item1 item2 ... itemN; do command1; command2… done; C风格的for123456for (( EXP1; EXP2; EXP3 ))do command1 command2 command3done while1234while conditiondo commanddone 无限循环1234while :do commanddone 或者 1234while truedo commanddone 或者 1for (( ; ; )) until1234until conditiondo commanddone case123456789101112131415161718192021222324252627case \"$&#123;opt&#125;\" in \"Install-Puppet-Server\" ) install_master $1 exit ;; \"Install-Puppet-Client\" ) install_client $1 exit ;; \"Config-Puppet-Server\" ) config_puppet_master exit ;; \"Config-Puppet-Client\" ) config_puppet_client exit ;; \"Exit\" ) exit ;; * ) echo \"Bad option, please choose again\"esac case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break 学习自：Shell脚本编程30分钟入门","categories":[],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://nymrli.top/tags/Shell/"},{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"多媒体Au使用","slug":"多媒体Au使用","date":"2018-11-08T04:18:47.000Z","updated":"2018-11-08T04:19:20.150Z","comments":true,"path":"多媒体Au使用.html","link":"","permalink":"https://nymrli.top/多媒体Au使用.html","excerpt":"","text":"AU使用。 留人声、去伴奏 First. ▲侧边声道电平控制微弱，中置声道电平控制效果强。 ▲交叉渗透，越大伴奏声音越不明显 Second. 前面几排调低到满意。（童声高音频率范围为260-880Hz,低音频率范围为196-700Hz,女声高音频率范围为220-1.1KHz,低音频率范围为200-700KHz,男声高音频率范围为160-523KHz低音频率范围为80-358Hz. 国际通信标准制定为300Hz-3400Hz! ） 留伴奏、去人声 ···选中所有，菜单栏-收藏夹-移除人声","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"Au","slug":"Au","permalink":"https://nymrli.top/tags/Au/"}]},{"title":"定时执行Python脚本","slug":"定时执行Python脚本","date":"2018-11-07T09:51:16.000Z","updated":"2018-11-10T02:44:35.736Z","comments":true,"path":"定时执行Python脚本.html","link":"","permalink":"https://nymrli.top/定时执行Python脚本.html","excerpt":"","text":"定时任务执行python脚本使用linux的crontab1.开启crontab日志。crontab默认不开启日志，所以先开启定时任务的日志来查看 修改rsyslog服务，将/etc/rsyslog.d/50-default.conf 文件中的#cron.*前的 #删掉；用service rsyslog restart重启rsyslog服务： 2.写定时任务开启本用户的定时任务,即创建以本用户名为文件名的定时任务文件，位置在/var/spool/cron/crontabs/。crontab -e 定时任务语句格式为：执行周期+命令，周期有5个域，分别是 M: 分（0-59） H：时（0-23） D：天（1-31） m: 月（1-12） d: 周（0-6） //0为星期日 ▲每个域不加限制任意的话用* 所以命令语句就是 12*/5 * * * * cd /home/iris/; python aa.py#时间# #command ; commond 写完后需要重启cron服务:service cron restart 附录 常用周期格式: 每五分钟执行 */5 * * * * 每小时执行 0 * * * * 每天执行 0 0 * * * 每周执行 0 0 * * 0 每月执行 0 0 1 * * 每年执行 0 0 1 1 * 5 * * * * ls 指定每小时的第5分钟执行一次ls命令30 5 * * * ls 指定每天的 5:30 执行ls命令30 7 8 * * ls 指定每月8号的7：30分执行ls命令30 5 8 6 * ls 指定每年的6月8日5：30执行ls命令30 5 8 6 * ls 指定每年的6月8日5：30执行ls命令30 6 * * 0 ls 指定每星期日的6:30执行ls命令30 3 10,20 * * ls 每月10号及20号的3：30执行ls命令25 8-11 * * * ls 每天8-11点的第25分钟执行ls命令*/15 * * * * ls 每15分钟执行一次ls命令30 6 */10 * * ls 每个月中，每隔10天6:30执行一次ls命令22 4 * * * root run-parts /etc/cron.daily每天4：22以root身份执行/etc/cron.daily目录中的所有可执行文件，run-parts参数表示，执行后面目录中的所有可执行文件。 ~/Python_project/SeverChan_Nyedu使用python crontab设置linux定时任务 通过python 来写 crontab配置 123456789101112131415161718192021222324252627282930313233from crontab import CronTab# 创建当前用户的crontab，当然也可以创建其他用户的，但得有足够权限my_user_cron = CronTab(user=True)# 创建任务job = my_user_cron.new(command='echo date &gt;&gt; ~/time.log')# 设置任务执行周期，每两分钟执行一次job.setall('*/2 * * * *')# 当然还支持其他更人性化的设置方式，简单列举一些job.minute.during(5,50).every(5)job.hour.every(4)job.day.on(4, 5, 6)job.dow.on('SUN')job.dow.on('SUN', 'FRI')job.month.during('APR', 'NOV')job.setall(time(10, 2))job.setall(date(2000, 4, 2))job.setall(datetime(2000, 4, 2, 10, 2))# 同时可以给任务设置comment，这样就可以根据comment查询，很方便job.set_comment(\"time log job\")# 根据comment查询，当时返回值是一个生成器对象，不能直接根据返回值判断任务是否#存在，如果只是判断任务是否存在，可直接遍历my_user_cron.cronsiter = my_user_cron.find_comment('time log job')# 同时还支持根据command和执行周期查找，基本类似，不再列举# 任务的disable和enable， 默认enablejob.enable(False)job.enable()# 最后将crontab写入配置文件my_user_cron.write() python中的轻量级定时任务调度库：schedule提供博客python中的轻量级定时任务调度库：schedule","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"ServerChan+南邮教务处","slug":"ServerChan-南邮教务处","date":"2018-11-07T09:32:10.000Z","updated":"2018-11-10T01:57:47.887Z","comments":true,"path":"ServerChan-南邮教务处.html","link":"","permalink":"https://nymrli.top/ServerChan-南邮教务处.html","excerpt":"","text":"SeverChan_NyeduCrawl the infomation about competitons, when new infos comes, remind people on Wechat by ServerChan: 😍该程序通过爬取南邮教务处,将当前时间与最新时间进行匹配,如果是当日则通过ServerChan发送到本人的微信,提醒有新的竞赛. 完成笔记:1.关于lxml中etree.xpath()对于tbody的处理 该网页通过table对页面进行分布设置,其中table标签会自动生成tbody标签,如图..此时用xpath进行匹配的时候就不需要将tbody加上,否则匹配不到 布局&lt;Table&gt; 表格&lt;table&gt; 可以看到的是在Chrome调试助手里面,&lt;table&gt;下面都是会自动生成&lt;tbody&gt;标签的(一般tbody是浏览器自动产生的，一般情况要去掉),而我们再通过网页源码看看..==&gt;可以发现的是: &lt;table&gt;布局是没有&lt;tbody&gt;的,只有表格才有,所以这也是为什么用xpath()表格里必须加上tbody才能匹配,而table布局中不能加tbody的原因 123456789101112#布局获得内容for content in contentList: title = content.xpath('td/table/tr/td[1]/a/text()')[0] href = content.xpath('td/table/tr/td[1]/a/@href')[0] submittime = content.xpath('td/table/tr/td[2]/div/text()')[0]#表格if content.tag == 'table': tabletitle = content.xpath('tbody/tr[1]/td') # 表格头 tabletitleList = map(lambda x: x.xpath('string(.)'), tabletitle) tablehead = '|' + '|'.join(tabletitleList) + '|' tableover = '|' + ':---:|' * len(tabletitle) # 居中显示 2.requests.get()获得的response的编码问题123html = requests.get('http://jwc.njupt.edu.cn/1594/list.htm',headers = headers)html.encoding = 'utf-8'#Requests库的自身编码为: r.encoding = ‘ISO-8859-1’ Github地址:Freedomisgood/SeverChan_Nyedu","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"}]},{"title":"高科GSWIFI江苏破解教程","slug":"高科GSWIFI江苏破解教程","date":"2018-11-04T02:06:34.000Z","updated":"2018-12-18T11:28:14.325Z","comments":true,"path":"高科GSWIFI江苏破解教程.html","link":"","permalink":"https://nymrli.top/高科GSWIFI江苏破解教程.html","excerpt":"","text":"1.重置路由器设置 为了以防之前其他人已经设置过某些东西,可能会影响到之后的使用，所以干脆直接重置。 2.连接路由器电源,不用插任何的wan口或者lan口 P.S.如果第二步,手机和电脑无法直接通过IP地址进入管理界面的话,可以考虑将 网线一头插入2号口,一头插入电脑的插口 , 然后再通过IP地址进入管理界面 3.登录路由器管理界面▲注意： 大多数路由器的管理界面IP地址为 192.168.1.1或者192.168.100.1,虽然高科路由器后面贴纸上说明的IP地址是192.168.8.1,但是那个不是初始的IP,需要自己设置到192.168.8.1. 如下是我已经修改好的IP为192.168.8.1的登录界面,默认密码为admin,登录后选择不保存密码 4.进入管理界面后先观察 首先是要观察软件版本与 GSWIFI 公众号中的最新能用的版本进行匹配,如果是一样的话就不需要升级系统固件,如果当前软件版本比较低就可能无法使用. 其次,由于没接网线,所以网线状态是WAN口未连接 5.修改配置修改WAN口设置 如何查看手机MAC地址说明:由于我使用的是英文系统…可能手机界面有点不同 1.进入WLAN 2.进入更多设置 最下面的MAC address就是 6.WIFI设置2.4G 7.LAN口设置 该步之后,等30s配置完成后,你会无法进入192.168.1.1,页面也会无响应,此时访问192.168.8.1重进管理界面 8.开始连接网线(查看网线状态)▲▲.由于该路由器的WAN口被商家调到了3号LAN口,我也被这步坑了挺久..所以上述步骤都完成以后,将网线插入路由器的3号LAN口,再登录管理界面,此时应该就能看到这样的界面了.. (p.s.或许你的路由器就是WAN口没改也说不定,反正如果没有效果的话,每个端口都试一下就是了) 能够正常显示这几个,则路由器已设置完成. 9.使用GSWIFI小助手对路由器再次设置 ▲注意,使用客服提供的APP,网盘链接在附录中 按照我们的教程来,IP地址填为192.168.8.1,然后按下”开始联网“,之后会有4步,这个过程中WIFI会不断的掉线,需要自己不断重连自己的WIFI(“Hello“),等到4步完成后就可以开始用掌上大学连上WIFI后一键上网了 完成图如下 10.使用掌上大学一键上网 教程到此就结束了,按照上述步骤应该就能完成高科GSWIFI路由器的破解上网了… 附录:GSWIFI小助手江苏版:网盘:https://pan.baidu.com/share/init?surl=vwza9BJd9kjjMKH6f3ek3g 提取码:svdg 更新系统固件找到GSWIFI公众号: 选择系统升级 然后查看升级教程 和 1082正式版系统(目前最新的系统固件)，然后根据里面提供的网盘将文件下载下来 下载后===&gt;解压===&gt;进入管理界面===&gt;系统升级===&gt;选择文件===&gt;刷写固件===&gt;执行（其中过程千万不能关闭电源或是乱动，就算按错了，等2-3分钟好了以后再重新刷写也无妨，但是千万不能断电源）","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"WSGI uWSGI uwsgi及nginx说明","slug":"WSGI-uWSGI-uwsgi及nginx说明","date":"2018-11-02T07:50:12.000Z","updated":"2018-11-02T08:16:15.520Z","comments":true,"path":"WSGI-uWSGI-uwsgi及nginx说明.html","link":"","permalink":"https://nymrli.top/WSGI-uWSGI-uwsgi及nginx说明.html","excerpt":"","text":"客户端发出请求==&gt;服务器接受、处理请求与响应 的过程示意图 1. WSGI： 全称是Web Server Gateway Interface(服务器网关接口)。WSGI不是服务器，python模块，框架，API或者任何软件，只是一种规范( 是一个Web服务器（如nginx）与应用服务器（如uWSGI）通信的一种规范（协议）==&gt; 可以理解为服务器与应用程序通信的接口规范要求)，描述web server如何与web application通信的规范。server和application的规范在PEP 3333中有具体描述。因为WSGI没有官方的实现, 所以WSGI更像一个协议，只要遵照这些协议，都可以在任何服务器(Server)上运行 2.uwsgi： 与WSGI一样是一种通信协议，是uWSGI服务器的独占协议，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种不同的协议。该协议据说性能非常高，是fcgi协议的10倍快;而且内存占用率低，为mod_wsgi的一半左右，同时它还支持多应用的管理及应用的性能监控 3.uWSGI： 是一个web服务器，而且也可以当做中间件。它实现了WSGI协议、uwsgi协议、http协议等。在生产环境中使用uWSGI作为python web的服务器,可以用来托管 Python WSGI应用。它具有应用服务器，代理，进程管理及应用监控等功能(但可以把看作是一个应用程序，帮助我们实现WSGI协议)，这样我们可以不再关注网络通信的底层实现，将精力更多放在处理HTTP请求数据，返回HTML。 4.uWSGI+nginx 综上所述可以看出uWSGI可以直接当做服务器，而为了进一步的并发提升就需要加上nginx(提高负载均衡) ▲.当uWSGI+nginx使用时，nginx作为web服务器，而uWSGI作为中间件(这边不一定正确,个人理解) uWSGI不足的地方: uWIGS也可以返回静态文件(css,js,img…)，但是很笨拙，所以更好的做法是用反向代理服务器（比如Nginx）来处理此类请求，减轻应用服务器的负载，获得更好的性能。 利用uWIGS可以是我们的web应用得到更强的并发能力，uWIGS也可以返回静态文件(css,js,img…)，但是很笨拙，一般静态文件都交由Nginx进行传输，所以配置中一般不配置static-map,如果直接由uWIGS接受HTTP请求则需要设置http:xxxx，如果只需要与反向代理服务器进行交互则只需要接受socket，uWIGS与Nginx交互相当于两个进程间交互，一般使用的是.sock文件或者指定端口接受socket。指定端口时再使用浏览器访问相应端口，uWIGS会提示skip，跳过该HTTP请求。 同时还有的是uWSGI本身的负载均衡没有nginx牛逼。所以阉割掉不用。 5.Nginx是一个Http和反向代理服务器 什么是反向代理服务器呢？ ▲正向的就是由浏览器主动的想代理服务器发出请求，经代理服务器做出处理后再转给目标服务器▲反向的就是不管浏览器同不同意，请求都会经过代理服务器处理再发给目标服务器 这其中的区别就是必须经过Nginx反向代理服务器，这就有了使用Nginx的几个好处： 安全：不管什么请求都要经过代理服务器，这样就避免了外部程序直接攻击web服务器 负载均衡：根据请求情况和服务器负载情况，将请求分配给不同的web服务器，保证服务器性能 提高web服务器的IO性能：这个我也没看懂，总结来说就是请求从客户端传到web服务器是需要时间的，传递多长时间就会让这个进程阻塞多长时间，而通过反向代理，就可以在反向代理这完整接受请求，然后再传给web服务器，从而保证服务器性能，而且有的一些简单的事情（比如静态文件）可以直接由反向代理处理，不经过web服务器 总结","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"apt-get update无法连接","slug":"apt-get-update无法连接","date":"2018-11-02T05:21:45.000Z","updated":"2018-11-02T05:44:44.227Z","comments":true,"path":"apt-get-update无法连接.html","link":"","permalink":"https://nymrli.top/apt-get-update无法连接.html","excerpt":"","text":"出现的问题原因是在apt-get update时遇到了Unable to connect to 代理，（由于apt-get update一直显示无法连接172.17.18.141百度后发现这并不是个特殊的IP,而且也可以ping到百度）于是想到是否使用了代理。 apt代理的设置：临时方法export http_proxy=http://10.3.0.1:80 长久方法(1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。) Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;; 保存apt.conf文件。 (2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件) 建立文件 vim proxyfile Acquire::http::proxy &quot;http://10.3.0.1:80&quot;; Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;; Acquire::https::proxy &quot;http://10.3.0.1:80&quot;; 使用时sudo apt-get install xxx -c proxyfile (2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 ) 在您的.bashrc文件末尾添加如下内容export http_proxy=http://用户名:密码@地址:端口/export https_proxy=http://用户名:密码@地址:端口/ export ftp_proxy=http://用户名:密码@地址:端口/ 附上一篇ubuntu设置代理的文章:ubuntu设置代理 Ubuntu下让终端走SS代理的方法Ubuntu下让终端走SS代理需要第三方软件的帮助，即privoxy。privoxy 是非快取式 (non-caching) 的网页代理伺服器，具有进阶的过滤能力，可强化隐私权，还可以修改网页资料、管理 HTTP cookies、去除广告等。 安装 privoxysudo apt-get install privoxy 安装完成后在 /etc/privoxy 目录下可以找到配置文件 config。 配置 privoxy一般地，改配置前应该备份配置。 mv /etc/privoxy/config /etc/privoxy/config.back 然后打开 config 文件，找到listen-address那一行，修改值为 privoxy 监听的地址，一般使用默认。 然后再找到forward-socks5那一行，去掉注释，值为SS代理监听的地址。 让终端走SS代理,修改配置后，重启 privoxy。 sudo /etc/init.d/privoxy restart 然后在终端下添加 http 代理。 export http_proxy=”127.0.0.1:8118” export https_proxy=”127.0.0.1:8118” 然后就可以愉快的用终端翻墙了。 原文：https://blog.csdn.net/tailgo/article/details/52075643","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"Windows控制台Cmd乱码（及永久修改编码）解决方法","slug":"Windows-控制台Cmd乱码（及永久修改编码）解决方法","date":"2018-10-28T08:42:20.000Z","updated":"2018-10-28T08:47:00.882Z","comments":true,"path":"Windows-控制台Cmd乱码（及永久修改编码）解决方法.html","link":"","permalink":"https://nymrli.top/Windows-控制台Cmd乱码（及永久修改编码）解决方法.html","excerpt":"","text":"我本机的系统环境：`OS Name: Microsoft Windows 10 家庭中文版 Windows 控制台Cmd乱码的解决办法(一次性)在cmd中输入 CHCP 65001 注：CHCP是一个计算机指令，能够显示或设置活动代码页编号。 代码页 描述 65001 UTF-8代码页 950 繁体中文 936 简体中文默认的GBK 437 MS-DOS 美国英语 但是通过CHCP设置编码是治标不治本的,想永久的更改cmd编码值需要修改注册表 Windows 控制台Cmd乱码的解决办法(永久性)方法一：1.在cmd中输入regedit进入注册表 2.找到HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe 3.新建一个 DWORD（32位值）,命名为CodePage，值设为65001 4.已有CodePage的话，修改它，改为十进制，65001 方法二：(亲测有效)1.新建一个cmd.reg注册表文件: 2.内容输入如下： 123456789Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe]\"CodePage\"=dword:0000fde9\"FontFamily\"=dword:00000036\"FontWeight\"=dword:00000190\"FaceName\"=\"Consolas\"\"ScreenBufferSize\"=dword:232900d2\"WindowSize\"=dword:002b00d2 3.双击运行","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"JS正则及常用方法函数总结","slug":"JS正则及常用方法函数总结","date":"2018-10-25T03:55:20.000Z","updated":"2018-11-13T15:03:03.619Z","comments":true,"path":"JS正则及常用方法函数总结.html","link":"","permalink":"https://nymrli.top/JS正则及常用方法函数总结.html","excerpt":"","text":"JS正则及常用方法函数总结 正则表达式作为一种匹配处理字符串的利器在很多语言中都得到了广泛实现和应用，web开发本质上是处理字符串（服务端接受请求处理后拼接字符串作为响应，这在早期的CGI编程中最明显，然后客户端解析字符串进行渲染和执行），所以说，JS作为一门常用于web开发的语言，必然要具备正则这种强大的特性，本文将对JS中的正则用法及常用函数进行一番总结。 1.正则对象及其属性首先正则对象是JS中内置的一个对象，好比Array以及Math一样，不需要第三方库的支持，通常我们采取两种方式来定义一个正则对象. 1）构造函数方式12345var reg=new RegExp('abc','gi');/*这里，第一个参数是正则的内容，第二个参数是修饰符，修饰符通常有三种，i,g,m，i表示的含义是忽略大小写进行匹配，g表示全局匹配即匹配到第一个之后不停止继续匹配，m表示多行匹配即遇到换行后不停止匹配继续直到被匹配字符串结束。*/ /i (忽略大小写) /g (全文查找出现的所有匹配字符,否则只匹配第一个出现的) /m (多行查找) /gi(全文查找、忽略大小写) /ig(全文查找、忽略大小写) 2）字面量方式123456var reg=/abc/gi;consolo.dir(reg);/**▲.两个斜杠之间的是定义的正则内容*，最后一个斜杠之后的是修饰符，这种方式比第一种简单高效，所以通常使用第二种方式来定义正则。*/ 2.属性在控制台中打印一个正则对象如下： global属性，该属性为布尔类型，用来表示该正则是否是全局匹配， ignoreCase属性，布尔类型，用来指示是否忽略大小写， lastIndex为number类型，用来表示上次匹配成功的位置， multiline，布尔类型，用来表示是否是多行匹配，source，string类型，用来表示正则的内容。 lastIndex 属性表示的索引处为目标字符串匹配（并且不会尝试从后续索引匹配）,你不能直接更改这个属性，它是只读的。可以通过^ unicode标志开启了多种 Unicode 相关的特性。使用 “u” 标志，任何 Unicode 代码点的转义都会被解释。 3.方法通常对于一个正则对象来讲，我们能够使用的方法基本上有三个，即regObj.test,regObj.exec及regObj.compile 1）test方法该方法用来测试某个字符串是否与正则匹配，匹配就返回true，否则返回false。该方法接受一个字符串作为参数 123 var reg=/boy(s)?\\s+and\\s+girl(s)?/gi; console.log(reg.test('boy and girl'));//==&gt;true 2)compile方法该方法的作用是能够对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，适合于对一个正则对象(模式)多次调用的情况下，如果对一个正则只使用一两次，那么该方法没有特别显著的效应。 接受的参数也是一个正则。 1234567var reg=/[abc]/gi; console.log(reg.test('a')); //==&gt;true reg=/[cde]/gi; console.log(reg.test('a')); //==&gt;false reg.compile(reg); console.log(reg.test('a')); //==&gt;false//被编译的正则和没有编译的正则在测试结果上没有任何区别，只是多次调用的效率上会更高一些。 3）exec方法该方法属于一个比较复杂的方法，它接受一个字符串，返回的是一个数组，数组中第0个元素是匹配的子字符串，第二个元素是正则中的第一个子分组匹配的结果（如果有子分组，即正则中存在用圆括号括起来的分组），第三个是正则中第二个子分组匹配的结果（如果有第二个子分组）…以此类推，如果没有正则子分组，那么该数组长度仅仅为1，就是匹配到的那个子字符串。同时，返回的这个数组同时还是一个对象，它拥有两个属性，分别为index表示当前匹配到的子字符串所处的位置，input属性表示被匹配的原始字符串。最后，该方法中的正则对象如果不是全局匹配，即没有g修饰符，则每次调用只会从字符串开头处匹配第一个结果，且每次调用结果都是一样的。只有指定为全局匹配，才能够按照从左往右依次去匹配，每次调用匹配一个结果，正则对象的lastIndex属性前进到本次匹配的末尾位置，下回再调用的时候，会从lastIndex处开始匹配而不是从头匹配。 12345678var reg=/(\\w)l(\\w)/g;var str=\"hello world hello 123 hello programmer hello test\";var arr=reg.exec(str); while(arr)&#123; console.dir(arr); console.log(\"lastIndex:\"+reg.lastIndex); arr=reg.exec(str); &#125; 结果如下： 12345678910111213141516//非全局匹配代码：var reg=/(\\w)l(\\w)/; var str=\"hello world hello 123 hello programmer hello test\"; var arr=reg.exec(str); var i=0; while(arr)&#123; i++; if(i&lt;=4)&#123; console.dir(arr); console.log(\"lastIndex:\"+reg.lastIndex); arr=reg.exec(str); &#125; else&#123; break; &#125; &#125; 这个时候每次调用的结果都一样，lastIndex根本没有发生变化。 以上就是正则对象及其方法，其实在使用的过程中，JS中的String类型的对象也拥有一些和正则相关的方法，如下： String类型的对象的正则方法1）search方法该方法是string对象的一个方法，用来查找第一次匹配的子字符串的位置，如果找到就返回一个number类型的index值，否则返回-1,它返回的只是第一次匹配的位置。 它接受一个正则或者子字符串为参数，这里我们只讨论正则的情况。 123var str=\"hello world\";console.log(str.search(/o/g));//输出结果为4，可以看到尽管具有多个匹配结果而且也声明为全局匹配，但是还是返回的是第一个匹配到的子串的位置； 2）replace方法该方法用来将字符串中的某些子串替换为需要的内容，接受两个参数，第一个参数可以为正则或者子字符串，表示匹配需要被替换的内容，第二个参数为被替换的新的子字符串。如果声明为全局匹配则会替换所有结果，否则只替换第一个匹配到的结果。 1234var str=\"hello world,hello test\";console.log(str.replace(/hello/g,'hi'));//结果为hi world,hi test//如果将上面代码中的g修饰符去掉，则返回的结果是hi world,hello test 3）split方法该方法主要用来将一个字符串拆分成一个数组，它接受一个正则或者子字符（串）作为参数，返回一个数组，简单情况下，我们不需要使用正则，只有在字符串拆分规则不统一的情况下才需要使用正则，如下： 12345var str=\"how|old*are you\";var arr=str.split(/\\||\\*|\\s+/);// 以|、*、多项空格为分隔符// \\s 匹配任何空白字符,包括空格、制表符、换页符等等console.log(arr); 这里需要将str拆分为单词数组，由于每个单词之间存在不一样的分隔符，我们采取正则来匹配，结果如下： 4）match方法该方法接受一个正则作为参数，用来匹配一个字符串，它的输出结果在不是全局匹配的情况下和exec方法的结果一致即一个数组并带有额外的属性，如果采用全局匹配，则不返回任何和其被匹配字符串相关的信息，只返回匹配的结果。 12345678910111213141516//非全局匹配代码：var reg2=/(\\w)s(\\w)/;var str2=\"ws1esr\";var result=str2.match(reg2);var i=0; while(result)&#123; i++; if(i&lt;=4)&#123; console.dir(result); console.log(\"lastIndex:\"+reg2.lastIndex); &#125; else&#123; break; &#125; &#125;//非全局匹配下，结果和exec非全局匹配方法返回的完全一致， 12345//全局匹配代码：var reg3=/(\\w)s(\\w)/g;var str4=\"ws1estqsa\";console.dir(str4.match(reg3));//可以看到，在全局匹配下的时候，它不同于exec方法，它会一次性将所有匹配结果以数组形式返回，且这个数组没有其他属性用来指向被匹配字符串的信息，而exec方法在全局匹配下每次返回的依然是本次匹配的结果数组，且这个数组中只包含本次匹配信息，同时又拥有指向被匹配字符串的信息，即match方法在全局匹配下一次性返回了所有匹配结果，而exec在全局匹配下返回的依然是当次匹配结果。","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://nymrli.top/tags/JavaScript/"}]},{"title":"Sublime Text3 Python虚拟环境（补充）——解决控制台中文乱码情况","slug":"Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况","date":"2018-10-24T10:52:35.000Z","updated":"2018-10-24T10:53:11.813Z","comments":true,"path":"Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况.html","link":"","permalink":"https://nymrli.top/Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况.html","excerpt":"","text":"转自：edwardgui的博客 正常的用python编译控制台是不会出现乱码的，但是在使用虚拟环境的情况下中文总是乱码，一开始以为是windows控制台编码的问题。找了挺久后发现是python+virtualenv编译系统的问题，现在我就带领大家解决这个问题。 ▲注：Windows环境下 首先看下是否已经安装了Virtualenv package插件，如果没有，则Ctrl+Shift+P，install Package,输入Virtualenv安装。 找到插件安装的地方：C:\\Users{Username}\\AppData\\Roaming\\Sublime Text 3\\Installed Packages ==&gt;注意改变一下Username 解压Virtualenv.sublime-package文件，可以通过先添加后缀.zip变为Virtualenv.sublime-package.zip再解压 包含文件如下：修改Python + Virtualenv.sublime-build文件， 增加一行：&quot;env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf8&quot;},使其变成1234567&#123;\"env\": &#123;\"PYTHONIOENCODING\": \"utf8\"&#125;,\"target\": \"virtualenv_exec\",\"shell_cmd\": \"python -u \\\"$file\\\"\",\"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\"selector\": \"source.python\"&#125; 然后保存，再把该文件打包为Virtualenv.sublime-package.zip再去掉后缀，就大功告成了。 最后打开Sublime Text3使用Python + Virtualenv 编译，就能看到中文正常输出啦！","categories":[],"tags":[{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"Python爬虫知识点——将Cookie保存到本地的多种方法介绍","slug":"Python爬虫知识点——将Cookie保存到本地的多种方法介绍","date":"2018-10-24T10:43:34.000Z","updated":"2018-10-24T10:45:29.249Z","comments":true,"path":"Python爬虫知识点——将Cookie保存到本地的多种方法介绍.html","link":"","permalink":"https://nymrli.top/Python爬虫知识点——将Cookie保存到本地的多种方法介绍.html","excerpt":"","text":"方法一：urllib2 结合cookielib及urllib2，Python2时期比较常用的方法，年代比较久远了。个人觉得太麻烦，改用requests. ▲需要注意的是cookielib在python3中已经改成了http.cookiejar 1234567891011121314151617181920212223242526272829303132333435#该方法本人未测试import urllib2import cookielib#将cookie保存在文件中def saveCookie(): #设置保存cookie的文件 filename = 'cookie.txt' #声明一个MozillaCookieJar对象来保存cookie，之后写入文件 cookie = cookielib.MozillaCookieJar(filename) #创建cookie处理器 handler = urllib2.HTTPCookieProcessor(cookie) #构建opener opener = urllib2.build_opener(handler) #创建请求 res = opener.open('http://www.baidu.com') #保存cookie到文件 #ignore_discard的意思是即使cookies将被丢弃也将它保存下来 #ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入 cookie.save(ignore_discard=True,ignore_expires=True)#从文件中获取cookie并且访问(我们通过这个方法就可以打开保存在本地的cookie来模拟登录)def getCookie(): #创建一个MozillaCookieJar对象 cookie = cookielib.MozillaCookieJar() #从文件中的读取cookie内容到变量 cookie.load('cookie.txt',ignore_discard=True,ignore_expires=True) #打印cookie内容,证明获取cookie成功 for item in cookie: print 'name:' + item.name + '-value:' + item.value #利用获取到的cookie创建一个opener handler = urllib2.HTTPCookieProcessor(cookie) opener = urllib2.build_opener(handler) res = opener.open('http://www.baidu.com') print res.read() 方法二: 使用requests.cookie 读取cookies在这里我用的是LWPCookieJar保存在txt文件中，还有个是MozillaCookieJar，都是由FileCookieJar 派生而来，实现了save()方法，而FileCookieJar 没有实现save() MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。 LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。 123456789#实例化一个LWPCookieJar对象load_cookiejar = cookielib.LWPCookieJar()#从文件中加载cookies(LWP格式)load_cookiejar.load('cookies.txt', ignore_discard=True, ignore_expires=True)#工具方法转换成字典load_cookies = requests.utils.dict_from_cookiejar(load_cookiejar)#工具方法将字典转换成RequestsCookieJar，赋值给session的cookies.self.session.cookies = requests.utils.cookiejar_from_dict(load_cookies) 存储cookies将cookies转换成LWP格式然后保存为文本格式 123456789#实例化一个LWPcookiejar对象new_cookie_jar = cookielib.LWPCookieJar('cookie.txt')#将转换成字典格式的RequestsCookieJar（这里我用字典推导手动转的）保存到LWPcookiejar中===&gt;RequestsCookieJar没有实现save()方法requests.utils.cookiejar_from_dict(&#123;c.name: c.value for c in self.session.cookies&#125;, new_cookie_jar)#保存到本地文件new_cookie_jar.save('cookies.txt', ignore_discard=True, ignore_expires=True) 方法三: 将cookie字典弄成字典形式然后pickle或者json写入文件中 存储cookie12345678import requests,json,pprints = requests.session()s.headers = &#123;...&#125;a = s.get(\"https://www.baidu.com\")cookies = requests.utils.dict_from_cookiejar(s.cookies)with open(\".\\\\cook.txt\", \"w\") as fp: json.dump(cookies, fp)pprint.pprint(cookies,width=5) 读取cookie123with open(\".\\cook.txt\", \"w\") as fp: load_cookies=son.load(fp)session.cookie = requests.utils.cookiejar_from_dict(load_cookies) 方法四: 将requests.cookie设置为LWPCookieJar、或MozillaCookieJar保存 123456session = requests.Session()#创建个 LWPCookieJar对象session.cookies = LWPCookieJar(filename='cook.txt')s.get('https://www.baidu.com/',headers=headers)session.cookies.save(ignore_discard=True, ignore_expires=True)#如果save()时没有写filename参数，则默认为实例化LWPCookieJar时给的文件名 save()方法的两个重要参数 ignore_discard: save even cookies set to be discarded. ignore_expires: save even cookies that have expired.The file is overwritten if it already exists ignore_discard的意思是即使cookies将被丢弃也将它保存下来，ignore_expires的意思是如果cookies已经过期也将它保存并且文件已存在时将覆盖 总结方法二和方法三可以看出，就是要将cookie转换成然后save() 简单介绍下cookielib模块作用，科普下实现cookie知识 python3中将cookielib模块改为了http.cookiejar 12345678910&gt; cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。例如可以利用本模块 的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送。coiokielib模块用到的对象主要有下面几个：CookieJar、 FileCookieJar、MozillaCookieJar、LWPCookieJar。其中他们的关系如下：&gt; &gt; CookieJar &gt; &gt; | &gt; &gt; FileCookieJar &gt; &gt; / \\ &gt; MozillaCookieJar LWPCookieJar","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"}]},{"title":"Python爬虫知识点——Session与Cookie","slug":"Python爬虫知识点——Session与Cookie","date":"2018-10-24T10:36:56.000Z","updated":"2018-10-24T10:41:34.630Z","comments":true,"path":"Python爬虫知识点——Session与Cookie.html","link":"","permalink":"https://nymrli.top/Python爬虫知识点——Session与Cookie.html","excerpt":"","text":"Session和Cookie： Cookie：保持登录后的认证状态而保存在本地的数据 session:用cookie来标记用户，cookie携带了会话ID消息，通过检查cookie就能找到会话(session) cookie与session相互配合，一个处于客户端，一个处于服务端，两者相互协作。 会话cookie和持久cookie 会话Cookie：把cookie放在浏览器内存里，浏览器关闭后失效。 持久Cookie：保存cookie到客户端的硬盘中，下次继续使用。 由Cookie的Max Age和Expires决定了过期的时间。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——代理","slug":"Python爬虫知识点——代理","date":"2018-10-24T10:36:28.000Z","updated":"2018-10-24T10:41:27.406Z","comments":true,"path":"Python爬虫知识点——代理.html","link":"","permalink":"https://nymrli.top/Python爬虫知识点——代理.html","excerpt":"","text":"代理基本原理代理实际上指代理服务器。功能是代理 网络用户去取得网络信息，是网络信息的中转站。 正常的请求过程为：发送请求给服务器===&gt;web服务器吧响应传回 设置代理服务器后：==&gt;向代理服务器发送请求==&gt;请求发送给代理服务器==&gt;再由代理服务器发送web服务器==&gt;由代理服务器把web服务器返回的响应转发给本机 作用突破自身IP访问限制，访问些平时不能访问的站点。 访问一些单位或团体内部资源:比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。 提高访问速度:通常代理服务器都设置-一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息传给用户，以提高访问速度。 隐藏真实IP:上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP,防止自身的IP被封锁。 代理分类根据代理的协议，代理可以分为如下类别。 FTP代理服务器: 主要用于访问FTP服务器，一般有上传、 下载以及缓存功能，端口一般为 21、2121等。 HTTP代理服务器:主要用于访问网页，一般有内容过滤和缓存功能，端口一般为808080、3128 等。 SSL/TLS代理:主要用于访同加密网站，般有 SsL 或TLS 加密功能(最高支持128位加密强度)，端口一般为443。 RTSP代理:主要用于访问Real流媒体服务器，一般有缓存功能， 端口般为554。 Telnet代理: 主要用于tenei远程控制黑客人侵计算机时常用于隐藏身份)，端口一般为23 POP3/SMTP代理:主要用于POP3/SMTP方式收发邮件，一般有缓存功能，端口-般为1025.口SOCKS代理:只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般 有 存功能，端口一般为1080。SOCKS代理协议又分为SOCKS4和SOCKS5,前者只支持TCP而后者支持TCP和UDP，还支持各种身份验证机制、服务器端域名解析等。简单来说SOCKS4能做到的SOCKS5都可以做到，但SOCKSS能做到的SOCKS4不一定能做到。 2.根据匿名程度区分 根据代理的匿名程度，代理可以分为如下类别。 高度匿名代理：会将数据包原封不动地转发，在服务端看来就好像真的是一 个普通客户端访问，而记录的IP是代理服务器的IP。 普通匿名代理：会在数据包上做一些改动， 服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实IP。代理服务器通常会加人的HTTP头有HTTP_VIA和HTTP_X_FORWARDED_FOR. 透明代理：不但改动了数据包，还会告诉服务器客户端的真实IP。这种代理除了能用缓存技术调高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。 间谍代理：指组织或个人创建的用于记录用户传输的数据， 然后进行研究、监控等目的代理服务器。 常用代理设置 网上的免费代理 付费的代理服务 ADSL拨号","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——请求","slug":"Python爬虫知识点——请求","date":"2018-10-24T10:36:21.000Z","updated":"2018-10-24T10:40:33.145Z","comments":true,"path":"Python爬虫知识点——请求.html","link":"","permalink":"https://nymrli.top/Python爬虫知识点——请求.html","excerpt":"","text":"请求 :请求方法、请求网址、请求头、请求体 请求方法： 常见的为:GET、POST GET与POST主要区别： GET请求参数包含在URL，可从URL中看出。POST请求的URL不包含参数，都是通过表单的形式传输的，包含在请求体中 GET请求提交的数据最多只有1024字节，POST无限制 其他还有HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE 请求的网址： 即URL，我们想要请求的资源 请求头：用来说明服务器要使用的附加信息，比较总要的有Cookie、Referer、User-Agent等。 Accept:请求报头域，用于指定客户端可接受哪些类型的信息。 Accept-Language:指定客户端可接受的语言类型。 Accept-Encoding:指定客户端可接受的内容编码。 Host:用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位 置。从HTTP1.1版本开始，请求必须包含此内容。 Cookie:也常用复数形式Cookies, 是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输人用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies 并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。 Referer:此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。 User-Agent: 简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等消息。在做爬虫时加上此信息，可以伪装成浏览器；如果不加，很可能被识别出为爬虫 Content-Type:也叫互联网媒体类型( Intermet Media Type)或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。更多对应关系可以查看此对表:http://tool.oschina.net/commons 文件扩展名 Content-Type(Mime-Type) .html、 .htx 、 .htm text/html .gif image/gif .json application/json ​ Content-Type与POST提交数据方式的关系 Content-Type 提交数据的方式 appication/x-www-urlencodeed 表单数据 multipart/form-data 表单文件上传 applicatiobn/json 序列化json数据 text/html XML数据 如果构造POST请求，需要使用正确的Content-Type，不然可能导致POST提交后无法正常响应 ==&gt;因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。 请求体： 请求体一般承载的内容是POST请求中的表单数据，而对GET请求，请求体则为空。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——响应","slug":"Python爬虫知识点——响应","date":"2018-10-24T10:36:17.000Z","updated":"2018-10-24T10:42:19.208Z","comments":true,"path":"Python爬虫知识点——响应.html","link":"","permalink":"https://nymrli.top/Python爬虫知识点——响应.html","excerpt":"","text":"响应：响应状态码、响应头、响应体 响应状态码：表2-3常见的错误代码及错误原因 状态码 说明 详情 100 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换。 200 成功 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 201 已创建 请求成功并且服务器创建了新的资源。 202 已接受 服务器已接受请求，但尚未处理。 203 非授权信息 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 无内容 服务器成功处理了请求，但没有返回任何内容。 205 重置内容 服务器成功处理了请求，但没有返回任何内容。 206 部分内容 服务器成功处理了部分 GET 请求。 300 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 查看其他位置 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 未修改 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 305 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307 临时重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 400 错误请求 服务器不理解请求的语法。 401 未授权 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 禁止 服务器拒绝请求。 404 未找到 服务器找不到请求的网页。 405 方法禁用 禁用请求中指定的方法。 406 不接受 无法使用请求的内容特性响应请求的网页。 407 需要代理授权 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 请求超时 服务器等候请求时发生超时。 409 冲突 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。 410 已删除 如果请求的资源已永久删除，服务器就会返回此响应。 411 需要有效长度 服务器不接受不含有效内容长度标头字段的请求。 412 未满足前提条件 服务器未满足请求者在请求中设置的其中一个前提条件。 413 请求实体过大 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 请求的 URI 过长 请求的 URI（通常为网址）过长，服务器无法处理。 415 不支持的媒体类型 请求的格式不受请求页面的支持。 416 请求范围不符合要求 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 未满足期望值 服务器未满足”期望”请求标头字段的要求。 500 服务器内部错误 服务器遇到错误，无法完成请求。 501 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502 错误网关 服务器作为网关或代理，从上游服务器收到无效响应。 503 服务不可用 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504 网关超时 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 HTTP 版本不受支持 服务器不支持请求中所用的 HTTP 协议版本。 响应头 响应头包含了服务器对请求的应答信息，如Cmene-Type. Serve. Set-cookie等。 下面简要说有 一些常用的头信息。 Date:标识响应产生的时间。 Last-Modifed:指定资源的最后修改时间。 公有地会 Content-Encoding:指定响应内容的编码。 Server:包含服务器的信息，比如名称、版本号等。 Content-Type:文档类型，指定返回的数据类型是什么，如texthtmI代表返回HTML文档， application/x-javascript则代表返回JavaScript文件，imagefjpeg 则代表返回图片。 Set-Cookie:设置Cookies。 响应头中的Set-Cookie 告诉浏览器需要将此内容放在Cooke 中，下次请求携带Cookies请求。 Expires:指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。立 果再次访问时，就可以直接从缓存中加载，降低服务器负载，编短加载时间。 响应体最重要的当属响应体的内容了。 响应的正文数据都在响应体中，比如请求网页时，它的响应体就 是网页的HTML代码:请求一张图片时， 它的响应体就是图片的二进制数据。我们做爬虫请求后主 要解析的内容就是响应体。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——爬虫的基本原理","slug":"Python爬虫知识点——爬虫的基本原理","date":"2018-10-24T10:36:10.000Z","updated":"2018-10-24T10:42:36.885Z","comments":true,"path":"Python爬虫知识点——爬虫的基本原理.html","link":"","permalink":"https://nymrli.top/Python爬虫知识点——爬虫的基本原理.html","excerpt":"","text":"爬虫的基本原理 爬虫就是获取网页并提取和保存信息的自动化程序 获取网页：获取网页就是获取网页的源码，只要把源码获取下来，就可以从中提取想要的消息 爬虫的流程：想网站的服务器发送一个请求，返回的响应体就是网页的源代码。 ​ ==&gt;1,构造请求发送给服务器===&gt;2.接受响应并解析 提取信息：通过分析网页结构，提取网页信息。通常使用的解析库有:BeautifulSoup、lxml、pyquery，也可以使用正则，但是构造正则表达式比较复杂且易错 保存数据：将提取的数据保存到某处以便后续利用。保存形式有：TXT、Json、数据库：MySQL、MongoDB、或远程服务器SFTP… 自动化程序替人完成完成爬取工作的自动化程序，可以在抓取过程中进行异常处理……保证爬取的高效运行","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——URL与URI","slug":"Python爬虫知识点——URL与URI","date":"2018-10-24T10:35:53.000Z","updated":"2018-10-24T10:41:12.634Z","comments":true,"path":"Python爬虫知识点——URL与URI.html","link":"","permalink":"https://nymrli.top/Python爬虫知识点——URL与URI.html","excerpt":"","text":"URL与URI URL全称：Uniform Resource Locator(统一资源定位符) URI全称：Uniform Resource Identifier(统一资源标识符) 如https://github.com/favicon.ico为例，它既是一个URL又是一个URI。我们通过URL/URI唯一指定了它的访问方式。其中包括访问协议https、访问路径、资源名称favicon.ico。通过这个链接提供的消息，我们就可以直接访问到此资源所在的位置。这便是URL、URI的作用。 URL是URI的子集。===&gt;每个URL都是URI，但不是每个URI都是URL。 URI包括两个子类:URN和URL。其中URN只命名资源但不指定如何定位资源(如urn:isbn:0451450523)指定了一本书的ISBN，可以唯一标识，但未定位。 ▲.目前互联网中URN用得很少，几乎所有的URI都是URL。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——Chrome开发者工具Network","slug":"Python爬虫知识点——Chrome开发者工具Network","date":"2018-10-24T10:35:31.000Z","updated":"2018-10-24T10:38:09.294Z","comments":true,"path":"Python爬虫知识点——Chrome开发者工具Network.html","link":"","permalink":"https://nymrli.top/Python爬虫知识点——Chrome开发者工具Network.html","excerpt":"","text":"Chrome开发者工具中Network功能介绍 第一列Name:请求的名称，一般会将URL的最后一 部分内容当作名称。 第二列Status: 响应的状态码，这里显示为200，代表响应是正常的。通过状态码，我们可 以判断发送了请求之后是否得到了正常的响应。 第三列Type: 请求的文档类型。这里为document, 代表我们这次请求的是一个HTML文档,内容就是一些HTML代码。 第四列initiator: 请求源。用来标记请求是由哪个对象或进程发起的。 第五列Size: 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示from cache。 第六列Time:发起请求到获取响应所用的总时间。 第七列Waterfall:网络请求的可视化瀑布流。 响应中分General部分，请求头、响应头： 其中General含： Request URL为请求的URL， Request Method为请求的方法 Status Code为响应状态码， Remote Address为远程服务器的地址和端口 Referrer Policy为Referrer判别策略。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"}]},{"title":"XShell通过SSH远程连接云服务器通过SSH远程连接云服务器","slug":"XShell通过SSH远程连接云服务器","date":"2018-10-24T10:32:05.000Z","updated":"2018-10-24T10:33:38.150Z","comments":true,"path":"XShell通过SSH远程连接云服务器.html","link":"","permalink":"https://nymrli.top/XShell通过SSH远程连接云服务器.html","excerpt":"","text":"1.账号密码登录法一: 法二:","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"复制Django项目时需要注意、修改的地方","slug":"复制Django项目时需要注意、修改的地方","date":"2018-10-24T10:25:37.000Z","updated":"2018-10-24T10:26:19.740Z","comments":true,"path":"复制Django项目时需要注意、修改的地方.html","link":"","permalink":"https://nymrli.top/复制Django项目时需要注意、修改的地方.html","excerpt":"","text":"复制Django项目: manage.py中需要修改的地方 1os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"window.settings\") settings.py中需要修改的地方 12345\"\"\"Django settings for window project.\"\"\"ROOT_URLCONF = 'window.urls'WSGI_APPLICATION = 'window.wsgi.application' urls.py中需要改动的地方 1\"\"\"window URL Configuration wsgi.py中需要修改的地方 123\"\"\"WSGI config for window project.os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"window.settings\") django可复用模板 在project_name文件下的*.py 再在终端键入django-admin startproject xx –template= (为文件夹中py文件名) 12345678910111213141516171819202122232425262728293031323334import osimport sysfrom django.conf import settingsDEBUG = os.environ.get('DEBUG','on')== 'on'ALLOW_HOSTS = ['*']SECRET_KEY = os.environ.get('SECRET','&#123;&#123; secret_key &#125;&#125;')settings.configure( DEBUG = DEBUG, ALLOW_HOSTS = ALLOW_HOSTS, SECRET_KEY = SECRET_KEY, ROOT_URLCONF = __name__, MIDDLEWARE_CLASSES = ( 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ))from django.conf.urls import urlfrom django.core.wsgi import get_wsgi_applicationfrom django.http import HttpResponsedef index(request): return HttpResponse('Hello Word')urlpatterns = ( url(r'$',index),)application = get_wsgi_application()if __name__ == '__main__': from django.core.management import execute_from_command_line execute_from_command_line(sys.argv)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Django","slug":"Django","permalink":"https://nymrli.top/tags/Django/"}]},{"title":"网络宽带和网络延迟","slug":"网络宽带和网络延迟","date":"2018-10-24T08:42:27.000Z","updated":"2018-10-24T08:44:50.602Z","comments":true,"path":"网络宽带和网络延迟.html","link":"","permalink":"https://nymrli.top/网络宽带和网络延迟.html","excerpt":"","text":"网络宽带和网络延迟网络带宽，网络延迟是2个概念（网络延迟往往更容易被忽略！） 国内大陆 建立在互联网基础上 很多对延迟性要求比较高的应用，体验效果都不如人意。比如高清晰度网络电视、在线视频语音实时业务（qq、skype） 某些在线游戏 等等。最简单的例子：如果ping某个网站，高于50ms的网站，打开就慢。10-30ms的网站，打开就比较快。如果都是同一个宽带服务商，即使升级到10M 20M 100M的宽带，这种网络延迟情况，短时间内应该也不会有改善 1、“下载电影这种活儿就看带宽，不在乎服务器发出数据后晚几秒钟收到，传输层有“窗口协议”，不必等到上一段数据的应答再传下一段数据，可以看做是一种“异步应用”。一般说，交互性的应用比较讲究低延迟，我用“同步应用”来描述之。同步应用别说晚几秒钟，就是晚0.1秒收到数据，影响也很大,如a、比如fps游戏会觉得很不爽，明明瞄准了怎么打不到。b、至于视频语音等，对带宽、延迟都有一定要求，带宽太小无法传输清晰的图像和声音，延迟太大你一句话“我爱你”，对方的mm没有任何反应……另外还有一个指标是抖动，通俗说是数据能不能平稳传输，还是一会儿快一会儿慢一会儿堵塞。” 2、理论上说，带宽越大，在网络拓扑中的优先级就越高，所对应的响应速度就越快，对于用户和ISP之间来说带宽越高，每秒传输的数据越多，延迟就越小。但是延迟高低是由很多个因素决定的，网络上的每一个服务器（路由器）都是一个节点，所有的节点加在一起的响应速度，才是你的网络延迟，如果某一中间节点出现出题，无法提供服务，其它节点就会重新计算路由，但是重新计算路由之前会有一个超时记时器，只有目的节点的响应时间超出记时器时才会重新进行路由计算。还有DNS服务器的影响等等， 所以把网络带宽和网络延迟扯在一起谈是没用的，ISP只能保证你的接入网络带宽和网络延迟无问题，与其它节点的服务就没法保证了。（世界上最远的距离不是天涯和海角，而是电信和网通）” 3、“任何FPS游戏，网络条件是最关键的——到服务器的ping稳定性和延迟时间，对战绩的影响最大。比如ping服务器5分钟，延迟ms数一直不变，或者误差不超过5%，随便什么FPS，哪怕你从没玩过没有经验不熟悉地图和武器，你的成绩也差不了。如果这ms数比多数人还少，那你更屌了。 ADSL线路分交织模式interleave和快速模式fast,区别在于交织模式在本地会对数据包进行纠错加密，因此可保证线路的稳定，当然相应的延迟就会上升，电信提供的线路默认也都是交织模式，于是有种减低延迟的方法就是让电信帮你线路改成FAST,当然随之而来的问题是可能导致线路的不稳定，尤其是家里离接入网机房比较远的情况。 延迟这个问题只要是网络都会存在,差别在于大小,标志着整个架构的合理性和完善性。可以简单的认为带宽相当于马路上的车道数量，延迟就相当于堵塞的程度。因此，营运商即使是相同带宽的情况下对延迟不同的线路收费也是不同的。当然一般家庭用户是不会享受这个的。 ADSLADSL（Asymmetric Digital Subscriber Loop）技术是一种不对称数字用户线实现宽带接入互连网的技术。 实际传输速度也要分上行和下行，上行速率就是发送出去数据的速度(上传速度)，下行就是收到数据的速度(下载速度). 总结 带宽代表一定时间内能运多少货。 延迟代表货物运输时间。比如万吨轮就是属于大带宽，高延迟。私人飞机属于低延迟，小带宽。比如都给一个月的时间，万吨轮拉的东西肯定比私人飞机多,如果土豪做生意，血汗工厂t恤运去去美国，肯定用轮船，对带宽敏感，对延迟不敏感的业务。但是如果土豪要移植肾了，这玩意路上放久会臭，就属于对延迟比较敏感的应用，还是用私人飞机运比较好。","categories":[],"tags":[{"name":"计算机知识","slug":"计算机知识","permalink":"https://nymrli.top/tags/计算机知识/"}]},{"title":"linux下apt-get介绍","slug":"linux下apt-get介绍","date":"2018-10-24T08:42:20.000Z","updated":"2018-11-21T14:33:22.237Z","comments":true,"path":"linux下apt-get介绍.html","link":"","permalink":"https://nymrli.top/linux下apt-get介绍.html","excerpt":"","text":"apt-get Advanced Package Tool又名apt-get，是一条linux命令，适用于deb包管理式的操作系统如Unix和Linux系统的应用程序管理器，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。 rpm包和deb包是两种Linux系统下最常见的安装包格式，在安装一些软件或服务的时候免不了要和它们打交道。rpm包主要应用在RedHat系列包括 Fedora等发行版的Linux系统上，deb包主要应用于Debian系列包括现在比较流行的Ubuntu等发行版上。 我们知道如果要安装现成的这两种包的话，安装rpm包的命令是“rpm -参数”，安装deb包的命令是“dpkg -参数”。而Linux系统很方便和人性化的一点就是很多软件或服务根本就不用我们去下载，直接使用相应的命令就可以管理了，可能这就是传说中的 “云”的概念。 yum可以用于运作rpm包，例如在Fedora系统上对某个软件的管理：安装：yum install &lt;package_name&gt;卸载：yum remove &lt;package_name&gt;更新：yum update &lt;package_name&gt; apt-get可以用于运作deb包，例如在Ubuntu系统上对某个软件的管理：安装：apt-get install &lt;package_name&gt;卸载：apt-get remove &lt;package_name&gt;更新：apt-get update &lt;package_name&gt; ▲.apt-get命令一般需要root权限执行，所以一般跟着sudo命令。 12345678910111213apt-get update#1、apt-get update是同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。#2、apt-get update只是更新了apt的资源列表，没有真正的对系统执行更新。如果需要，要使用apt-get upgrade来更新。apt-get upgrade#可以使用这条命令更新软件包，apt-get upgrade不仅可以从相同版本号的发布版中更新软件包，也可以从新版本号的发布版中更新软件包，尽管实现后一种更新的推荐命令为apt-get dist-upgrade(将系统升级到新版本)。#总结:▲ apt-get update 是更新本地软件列表，在线安装的时候可以在软件列表找到软件； apt-get upgrade 是更新本地已安装的软件，要谨慎执行。 #dpkg -l#列出所有已安装的软件包。 在Ubuntu中，有时候运用sudo apt-get install 安装软件时，会出现一下的情况 E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 主要是因为apt还在运行,解决方案是 1.找到并且杀掉所有的apt-get 和apt进程123456ps -A | grep apt找出所有的 apt 以及 apt-get 进程$ sudo kill -9 processnumber 或者$ sudo kill -SIGKILL processnumber比如，下面命令中的9是 SIGKILL 的信号数，它会杀掉第一个 apt 进程$ sudo kill -9 进程ID 或者$ sudo kill -SIGKILL 进程ID 2、删除锁定文件锁定的文件会阻止 Linux 系统中某些文件或者数据的访问，这个概念也存在于 Windows 或者其他的操作系统中。 一旦你运行了 apt-get 或者 apt 命令，锁定文件将会创建于 /var/lib/apt/lists/、/var/lib/dpkg/、/var/cache/apt/archives/ 中。 这有助于运行中的 apt-get或者 apt 进程能够避免被其它需要使用相同文件的用户或者系统进程所打断。当该进程执行完毕后，锁定文件将会删除。 当你没有看到 apt-get或者 apt 进程的情况下在上面两个不同的文件夹中看到了锁定文件，这是因为进程由于某个原因被杀掉了，因此你需要删除锁定文件来避免该错误。 123456789101112#首先运行下面的命令来移除 /var/lib/dpkg/ 文件夹下的锁定文件：$ sudo rm /var/lib/dpkg/lock#之后像下面这样强制重新配置软件包：$ sudo dpkg --configure -a#也可以删除 /var/lib/apt/lists/ 以及缓存文件夹下的锁定文件：$ sudo rm /var/lib/apt/lists/lock$ sudo rm /var/cache/apt/archives/lock#接下来，更新你的软件包源列表：$ sudo apt update 或者 $ sudo apt-get update","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"python中关于round函数的注意事项","slug":"python中关于round函数的注意事项","date":"2018-10-18T03:37:00.000Z","updated":"2018-10-18T03:37:23.461Z","comments":true,"path":"python中关于round函数的注意事项.html","link":"","permalink":"https://nymrli.top/python中关于round函数的注意事项.html","excerpt":"","text":"python中关于round函数的注意事项 round函数很简单，对浮点数进行近似取值，保留几位小数。 比如: 12345&gt;&gt;&gt; round(10.0/3, 2)3.33&gt;&gt;&gt; round(20/7)3#第一个参数是一个浮点数，第二个参数是保留的小数位数，可选，如果不写的话默认保留到整数。 12345678910#[round]函数文档-py3def round(number, ndigits=None): # real signature unknown; restored from __doc__ \"\"\" round(number[, ndigits]) -&gt; number Round a number to a given precision in decimal digits (default 0 digits). This returns an int when called with one argument, otherwise the same type as the number. ndigits may be negative. \"\"\" return 0 翻译一下什么意思呢?: 将数字四舍五入到给定精度,如果不给第二个精度参数的话就默认保留到0位(即整数) 这么简单的函数，能有什么坑呢？1、round的结果跟python版本有关 1234567#-------python2---------&gt;&gt;&gt; round(0.5)1.0#======python3==========&gt;&gt;&gt; round(0.5)0 原因在于: 在python2.7的doc中，round()的最后写着，“Values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done away from 0.” 保留值将保留到离上一位更近的一端（四舍六入），如果距离两端一样远，则保留到离0远的一边。所以round(0.5)会近似到1，而round(-0.5)会近似到-1。 但是到了python3.5的doc中，文档变成了“values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice.” 如果距离两边一样远，会保留到偶数的一边。比如round(0.5)和round(-0.5)都会保留到0，而round(1.5)会保留到2。 然而需要注意的是 2、特殊数字round出来的结果可能未必是想要的。 12&gt;&gt;&gt; round(2.675, 2)2.67 官方举例:python2和python3的doc 123NoteThe behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more information. 简单的说就是，round(2.675, 2) 的结果，不论我们从python2还是3来看，结果都应该是2.68的，结果它偏偏是2.67，为什么？这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串1和0后可能是无限位数的，机器已经做出了截断处理)。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离2.67要更近一点点，所以保留两位小数时就近似到了2.67。 例子2: 12&gt;&gt;&gt; round(123.45, 1)123.5 意思就是说计算机需要先将十进制123.45转换为二进制,这个过程会导致二进制的值比123.45略大(比如123.45000001之类的),那么自然就得到123.5这个值了. 以上。除非对精确度没什么要求，否则尽量避开用round()函数。近似计算我们还有其他的选择： 使用math模块中的一些函数，比如math.ceiling（天花板除法）。 python自带整除，python2中是/，3中是//，还有div函数。 字符串格式化可以做截断使用，例如 “%.2f” % value（保留两位小数并变成字符串……如果还想用浮点数请披上float()的外衣）。 当然，对浮点数精度要求如果很高的话，请用嘚瑟馍，不对不对，请用decimal模块。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"HDOJ Problem 1002 - A + B Problem II","slug":"HDOJ-Problem-1002-A-B-Problem-II","date":"2018-10-18T03:36:23.000Z","updated":"2018-10-18T03:36:44.900Z","comments":true,"path":"HDOJ-Problem-1002-A-B-Problem-II.html","link":"","permalink":"https://nymrli.top/HDOJ-Problem-1002-A-B-Problem-II.html","excerpt":"","text":"HDOJ Problem 1002 - A + B Problem II:大数定理 Problem Description I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000. Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line is the an equation “A + B = Sum”, Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases. Sample Input12321 2112233445566778899 998877665544332211 Sample Output12345Case 1:1 + 2 = 3Case 2:112233445566778899 + 998877665544332211 = 1111111111111111110 解法一: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;char a[1000],b[1000];int aar[1001],bar[1001];int main()&#123; int alen,blen,maxlen; int time; cin &gt;&gt; time; for (int i=1;i&lt;=time;i++) &#123; cin &gt;&gt; a &gt;&gt; b; alen = strlen(a); blen = strlen(b); int tmp = 0; for (int j=alen-1;j&gt;=0;j--) aar[tmp++] = a[j]-'0'; tmp = 0; for (int j=blen-1;j&gt;=0;j--) bar[tmp++] = b[j]-'0'; //123 ==&gt; 321 为了保证之后便于计算 if ( alen &gt; blen)&#123; maxlen = alen; for(int j=blen;j&lt;alen;j++)&#123; //长度不同时,短的那个需要补零 bar[j] = 0; &#125; aar[alen] = 0; &#125; else if ( alen &lt; blen)&#123; maxlen = blen; for(int j=alen;j&lt;blen;j++) &#123; aar[j] = 0; &#125; bar[blen] = 0; &#125; else&#123; maxlen = alen; aar[maxlen]=0; bar[maxlen]=0; &#125; for (int j=0;j&lt;maxlen;j++)&#123; cout &lt;&lt; aar[j] &lt;&lt; '\\t'; cout &lt;&lt; bar[j] &lt;&lt;endl; aar[j] += bar[j]; if(aar[j] &gt;= 10)&#123;//如果当前位大于10则进一位 aar[j] -=10; aar[j+1] += 1; &#125; &#125;//将a+b的和保存在aar数组里 cout &lt;&lt; \"Case:\" &lt;&lt; i&lt;&lt; endl; cout &lt;&lt; a &lt;&lt; \" + \" &lt;&lt; b &lt;&lt; \" = \" ; if (aar[maxlen] == 0 ) //判断第一位是否为0,如果是的话就从第二位开始读,这个是逆序 for (int j=maxlen-1;j&gt;=0;j--) cout &lt;&lt; aar[j]; else for (int j=maxlen;j&gt;=0;j--) cout &lt;&lt; aar[j]; if(i != time) //注意要求的输出格式 cout &lt;&lt; endl&lt;&lt; endl; else cout &lt;&lt; endl; &#125; return 0;&#125; 解法二:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;using namespace std;int i,j,y,n,k,h,p,lena,lenb;int a[1000],b[1000],sum[1000],f[1000];int main()&#123; string a1,b1; cin&gt;&gt;n; for(y=1;y&lt;=n;y++) &#123; cin&gt;&gt;a1&gt;&gt;b1; lena=a1.length(); lenb=b1.length(); for(i=0;i&lt;1000;i++)&#123; a[i]=0;b[i]=0;f[i]=0;//f数组是记录a+b和 //这个补零是先全都设为0,再把不为0的填入 &#125; for(i=lena-1;i&gt;=0;i--) /*1234 ==&gt; 4321*/ a[lena-1-i]=a1[i]-'0'; //字符'9' - '0' 才是数字9 for(i=lenb-1;i&gt;=0;i--) b[lenb-1-i]=b1[i]-'0'; k=0; for(i=0;i&lt;lenb || i&lt;lena;i++)&#123; //i--&gt; max( lena , lenb ) h=a[i]+b[i]+k; //k是下一位是否进一 f[i]=h%10; //f[i]必然是0-9 k=h/10; //如果h大于10,则k=1,如果h小于10,则k=0 &#125; if(k!=0) //如果k=1,则最高位加一 f[i++]=k; cout&lt;&lt;\"Case \"&lt;&lt;y&lt;&lt;\":\"&lt;&lt;endl&lt;&lt; a1 &lt;&lt;\" + \"&lt;&lt; b1 &lt;&lt;\" = \"; p=0; for(j=i-1;j&gt;=0;j--)&#123; //将之前为了计算时的倒序,再反正过来 if(p==0 &amp;&amp; f[j]==0)&#123; //目的是去前导0,实则这步多余了 continue; //如果最高位是0的话i就不会++,如果是1的话,那么f[j]就不会是0,所以这步必然是进入else &#125; else&#123; p=1; cout&lt;&lt;f[j]; &#125; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; ▲总结: 1.为什么用字符数组==&gt;因为数字太大,long long也存储不下 2.用int数组记录每一位的数字,然后模拟手算 3.为什么倒置==&gt;因为为了让末尾对齐,方便计算”个位对个位,十位对十位……”","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"}]},{"title":"LeetCode 26. 删除排序数组中的重复项","slug":"LeetCode-26-删除排序数组中的重复项","date":"2018-10-18T03:35:36.000Z","updated":"2018-10-18T03:35:50.502Z","comments":true,"path":"LeetCode-26-删除排序数组中的重复项.html","link":"","permalink":"https://nymrli.top/LeetCode-26-删除排序数组中的重复项.html","excerpt":"","text":"LeetCode 26. 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 方法：双指针法算法 数组完成排序后，我们可以放置两个指针 i和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。 当我们遇到 nums[j] != nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。 1234567891011public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; 复杂度分析 时间复杂度：O(n)， 假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。 空间复杂度：O(1)。 Python实现:1234567891011121314class Solution: def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) &lt;= 1: return len(nums) s = 0 for f in range(1, len(nums)): if nums[s] != nums[f]: s += 1 nums[s] = nums[f] return s + 1","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"}]},{"title":"素数判别","slug":"素数判别","date":"2018-10-15T14:30:55.000Z","updated":"2018-10-15T14:31:57.937Z","comments":true,"path":"素数判别.html","link":"","permalink":"https://nymrli.top/素数判别.html","excerpt":"","text":"素数判别方法一123456789bool isPrime_2( int num )&#123; int tmp =sqrt( num); for(int i= 2;i &lt;=tmp; i++) if(num %i== 0) return 0 ; return 1 ;&#125;一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n)。若sqrt(n)左侧找不到约数，那么右侧也一定找不到约数 方法二(筛选法)123456789101112131415161718192021222324252627282930#include\"cstdio\"#include\"cstring\"using namespace std;#define MAX 100000//求MAX范围内的素数long long su[MAX],cnt;bool isprime[MAX];void prime()&#123; cnt=1; memset(isprime,1,sizeof(isprime));//初始化认为所有数都为素数 isprime[0]=isprime[1]=0;//0和1不是素数 for(long long i=2;i&lt;=MAX;i++) &#123; if(isprime[i])//保存素数 &#123; su[cnt++]=i; &#125; for(long long j=i*2;j&lt;=MAX;j+=i)//素数的倍数都为合数 &#123; isprime[j]=0; &#125; &#125;&#125;int main()&#123; prime(); for(long long i=1;i&lt;cnt;i++) printf(\"%d \",su[i]); return 0;&#125; 方法三(剪枝) 证明：令x≥1，将大于等于5的自然数表示如下： ······ 6x-1，6x，6x+1，6x+2，6x+3，6x+4 | 6x+5，6(x+1），6(x+1)+1 ······ 可以看到，不在6的倍数两侧，即6x两侧的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。这里有个题外话，关于孪生素数，有兴趣的道友可以再另行了解一下，由于与我们主题无关，暂且跳过。这里要注意的一点是，在6的倍数相邻两侧并不是一定就是质数。===&gt;只需判断6两侧的是不是质数(6x-1、6x+1) 此时判断质数可以6个为单元快进，即将方法（2）循环中i++步长加大为6，加快判断速度，原因是，假如要判定的数为n，则n必定是6x-1或6x+1的形式，对于循环中6i-1，6i，6i+1,6i+2，6i+3，6i+4，其中如果n能被6i，6i+2，6i+4整除，则n至少得是一个偶数，但是6x-1或6x+1的形式明显是一个奇数，故不成立；另外，如果n能被6i+3整除，则n至少能被3整除，但是6x能被3整除，故6x-1或6x+1（即n）不可能被3整除，故不成立。===&gt;综上，循环中只需要考虑6i-1和6i+1的情况(被本身更小的因数所除如22/11)，即循环的步长可以定为6，每次判断循环变量k和k+2的情况即可，理论上讲整体速度应该会是方法（2）的3倍。代码如下： 12345678910111213141516bool isPrime_3( int num )&#123; //两个较小数另外处理 if(num ==2|| num==3 ) return 1 ; //不在6的倍数两侧的一定不是质数 if(num %6!= 1&amp;&amp;num %6!= 5) return 0 ; int tmp =sqrt( num); //在6的倍数两侧的也可能不是质数 for(int i= 5;i &lt;=tmp; i+=6 ) if(num %i== 0||num %(i+ 2)==0 ) return 0 ; //排除所有，剩余的是质数 return 1 ;&#125; for循环i从5开始而不是从7开始的原因: 从5、7开始的区别在于i &lt;= sqrt(num)..如果是5的话，判断条件为25；如果是7的话，判断的条件就为49。 而仔细观察49内的所有质数，发现25之前的质数都是6k左右的数(6k-1,6k+1)，而25以后，就不定都有了。如26则不为质数。 所以如果从5开始的话，那么25以内的数 都不会进入for循环，经过if(num %6!= 1&amp;&amp;num %6!= 5)的筛选后，就都是素数了。 而如果是从7开始，那么25-49之内的数不符合条件却不会进入for循环，所以26缺少这个for的循环判断后就被误判为素数了。 ==&gt;以我浅薄的数学见识理解，25以内素数规律的巧合性使得 这些数不需要进入for循环判断，所以相比于从7开始的错误，5开始是正确的 给出Py代码12345678910import mathdef prime_num(num): if num == 2 or num == 3: return 1 if num%6 != 1 and num%6!=5: return 0 for i in range(5,math.ceil(math.sqrt(num))+1,6): #就剩6k-1 和 6k+1 if num%i == 0 or num%(i-2)==0: return 0 return 1 参考:https://blog.csdn.net/huang_miao_xin/article/details/51331710","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"}]},{"title":"\\r - \\n - \\r\\n的区别","slug":"回车和换行区别","date":"2018-10-13T12:33:33.000Z","updated":"2018-10-13T12:34:31.882Z","comments":true,"path":"回车和换行区别.html","link":"","permalink":"https://nymrli.top/回车和换行区别.html","excerpt":"","text":"\\r - \\n - \\r\\n 的区别代码演示:123456781: string s1 = \"已经习惯了回车和换行一次搞定\\n，敲一个回车键，即是回\";2: 3: Console.WriteLine(s1);4: s1 = \"已经习惯了回车和换行一次搞定\\r，敲一个回车键，即是回\";5: Console.WriteLine(s1);6: s1 = \"已经习惯了回车和换行一次搞定\\r\\n，敲一个回车键，即是回\";7: Console.WriteLine(s1);8: Console.ReadLine(); Result:==&gt; 回车、换行的区别: \\r , \\n, \\r\\n的区别其实是回车与换行的区别 符号 ASCII码 意义 \\n 10 换行 \\r 13 回车CR 先来段历史 回车”（Carriage Return）和“换行”（Line Feed）这两个概念的来历和区别。 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33，Linux/Unix下的tty概念也来自于此）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 在Windows中： ‘\\r’ 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖； ‘\\n’ 换行，换到当前位置的下一行，而不会回到行首； Unix系统里，每行结尾只有“&lt;换行&gt;”，即”\\n”；Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“\\r\\n”；Mac系统里，每行结尾是“&lt;回车&gt;”，即”\\r”；。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 例 $ echo -en &#39;12\\n34\\r56\\n\\r78\\r\\n&#39; &gt; tmp.txt ==&gt;Linux中遇到换行符(“\\n”)会进行回车+换行的操作，回车符反而只会作为控制字符(“^M”)显示，不发生回车的操作。而windows中要回车符+换行符(“\\r\\n”)才会回车+换行，缺少一个控制符或者顺序不对都不能正确的另起一行。 ▲注意点： 在解析文本或其他格式的文件内容时，常常要碰到判定回车换行的地方，这个时候就要注意既要判定”**r**\\n”又要判定”\\n”。 写程序时可能得到一行,将其进行trim掉’**r**’,这样能得到你所需要的string了。 拓展程序测试 123456789101112131415161718192021222324252627282930/*==========================程序二===============================*/#include &lt;stdio.h&gt;int main(void)&#123; int i; FILE *fp; if((fp=fopen(\"test.txt\",\"w\")) == NULL) &#123; fprintf(stderr,\"open file error\\n\"); return 1; &#125; for(i=0;i&lt;100;i++) fprintf(fp,\"test\\n\"); fclose(fp); return 0;&#125;/*==========================程序二===============================*/#include &lt;stdio.h&gt;int main(void)&#123; int i; FILE *fp; if((fp=fopen(\"test.bin\",\"wb\")) == NULL) &#123; fprintf(stderr,\"open file error\\n\"); return 1; &#125; for(i=0;i&lt;100;i++) fprintf(fp,\"test\\n\"); fclose(fp); return 0;&#125; ​ 程序一输出文件大小是600字节，程序二输出文件大小是500字节，用记事本打开程序一的输出没有什么问题，每行一个test，打开程序二的输出发现所有的test连成一行，test之间是一个黑色方框符号分隔。用UltraEdit-32以16进制编辑模式打开test.bin可以查看到黑色方框符号就是0A也就是\\n，打开test.txt则会发现换行是\\r\\n，这就是两个文件大小相差100字节的原因。Unix类系统用户打开windows中的文件就会遇到这种苦恼。为什么会有这种区别呢？ 毕竟是源自Unix系统，C语言中使用\\n表示换行，而在实际的文件中换行符号需要同操作系统一致，所以当我们在C中使用fopen打开一个文本文件时流实现了实际换行符与C中\\n之间的转换。在windows中当我们用fopen打开文本文件，然后从中读到\\r\\n时流会转换为\\n，而当我们往文件中写入\\n时流会转换为\\r\\n。程序一是打开文本文件，程序二打开的是二进制文件，因为流只对文本文件进行换行表示的转换，以二进制模式打开流不会做任何处理。所以当你以二进制模式打开一个文本文件时将产生错乱，你必须亲自将\\r\\n解释为\\n,同样的问题也会出现在以文本模式打开二进制文件的情况.这也解释了为什么Unix类系统中的文件不区分文本文件和二进制文件的原因。 当我们使用标准输入输出函数时有这种情况吗？再回到我们熟悉的标准输入输出stdin,stdout​ C的控制台程序在加载进内存成为进程运行前C运行时库自动打开三个设备并关联到三个流：标准输入流stdin，标准输出流stdout，标准出错流stderr ​ 通常在通用计算机中，没有重定向前这三个流对应的设备是：键盘，显示器，显示器。这三个都是字符设备，所以是以文本文件的模式打开的，在windows下当我们在键盘上敲入回车键时产生字符\\r\\n，但是在OS内核把键盘驱动中读到的字符发送给流的缓冲区时流会将之转换为\\n，当我们向控制台输出\\n时流将之转换为\\r\\n再传递至内核，当我们绕过标准输入输出直接调用windows中coredll.lib进行控制台输入输出时就必须面对这一现实，程序员负责实现这一转换。 摘自:https://www.cnblogs.com/xiaotiannet/p/3510586.html","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"https://nymrli.top/tags/编程/"}]},{"title":"云服务器Ubuntu更改默认python版本","slug":"云服务器Ubuntu更改默认python版本","date":"2018-10-12T05:07:48.000Z","updated":"2018-12-18T15:12:06.142Z","comments":true,"path":"云服务器Ubuntu更改默认python版本.html","link":"","permalink":"https://nymrli.top/云服务器Ubuntu更改默认python版本.html","excerpt":"","text":"云服务器Ubuntu更改默认python版本1、基于用户修改 Python 版本：想要为某个特定用户修改 Python 版本，只需要在其 home 目录下创建一个 alias(别名) 即可。打开该用户的 ~/.bashrc文件，添加新的别名信息来修改默认使用的 Python 版本。 vim ~/.bashrc 增加一行alias python=python3和修改pip版本alias pip=pip3 source ~/.bashrc再输入python --version,就能发现显示的是Python 3.x啦 2、 在系统级修改 Python 版本(建议)12# update-alternatives --list pythonupdate-alternatives: error: no alternatives for python 如果出现以上所示的错误信息，则表示 Python 的替代版本尚未被 update-alternatives 命令识别。想解决这个问题，我们需要更新一下替代列表，将 python2.7 和 python3.4 放入其中。 12345$ update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1# update-alternatives: using /usr/bin/python2.7 to provide /usr/bin/python (python) in auto mode$ update-alternatives --install /usr/bin/python python /usr/bin/python3.4 2# update-alternatives: using /usr/bin/python3.4 to provide /usr/bin/python (python) in auto mode –install 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。这个例子中，我们为 /usr/bin/python3.4 设置的优先级为2，所以update-alternatives 命令会自动将它设置为默认 Python 版本。 1234# 接下来，我们再次列出可用的 Python 替代版本。# update-alternatives --list python/usr/bin/python2.7/usr/bin/python3.4","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"nginx+uwsi搭建django环境服务器","slug":"nginx+uwsi搭建django环境服务器","date":"2018-10-12T04:44:09.000Z","updated":"2018-10-12T04:45:38.227Z","comments":true,"path":"nginx+uwsi搭建django环境服务器.html","link":"","permalink":"https://nymrli.top/nginx+uwsi搭建django环境服务器.html","excerpt":"","text":"阿里云搭建服务器更新源12sudo apt-get updatesudo apt-get upgrade 安装nginx1234sudo apt-get install nginxsudo /etc/init.d/nginx start (start可以改成restart/stop)#或是sudo service nginx start然后浏览器输入服务器IP,观察是否有welcom to nginx! 安装py3和virtualenv12sudo apt-get install git python3 python3-pipsudo pip3 install virtualenv 修改python版本:法一:(不建议)123456789$ gedit ~/.bashrc #gedit .bash_aliases在顶部加入一行alias python=python3$ source ~/.bashrc #或是source ~/.bash_aliases o$ python --version就会发现是Python 3.5.2啦/*orOpen your .bashrc file nano ~/.bashrc. Type alias python=python3 on to a new line at the top of the file then save the file with ctrl+o and close the file with ctrl+x. Then, back at your command line type source ~/.bashrc. Now your alias should be permanent.*/ Ubuntu16.04切换python3和python2▲.切换Python3为默认版本：(建议)12sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 切换Python2为默认版本： 1sudo update-alternatives --config python 安装虚拟环境12cd /var/wwwsudo virtualenv env35 下载和配置网站1234sudo git clone https://github.com/KyrieWang233/homework_submission-master.gitsource env35/bin/activatecd home...sudo pip3 install -r requirements.txt 123456sudo python manage.py collectstaticsudo python manage.py migratepython manage.py createsuperusersudo vim settings.py将其中的ALLOWED_HOST=[*]改为自己的IP然后输入 python manage.py runserver 0.0.0.0:8000 安装、测试uwsgi12sudo pip3 install uwsgiuwsgi --http :8000 --module homework_submission.wsgi 编辑/var/www下的uwsgi.ini12345678910[uwsgi]chdir=/var/www/homework_submission-mastermodule=homework_submission.wsgihome=/var/www/env35master=Trueprocesses=10socket= :8001chmod socket=666vacuum=Truemax-requests=5000 编辑/var/www下的nginx.conf12345678910111213141516upstream django&#123;server 127.0.0.1:8001;&#125;server &#123;listen 80;server_name sast.nymrli.top;charset utf-8;client_max_body_size 75M;location /static&#123;alias /var/www/homework_submission-master/static; &#125;location /&#123;uwsgi_pass django;include /var/www/uwsgi_params;&#125;&#125; 编辑/var/www下的uwsgi_params12345678910111213141516uwsgi_param QUERY_STRING $query_string;uwsgi_param REQUEST_METHOD $request_method;uwsgi_param CONTENT_TYPE $content_type;uwsgi_param CONTENT_LENGTH $content_length; uwsgi_param REQUEST_URI $request_uri; uwsgi_param PATH_INFO $document_uri; uwsgi_param DOCUMENT_ROOT $document_root; uwsgi_param SERVER_PROTOCOL $server_protocol; uwsgi_param REQUEST_SCHEME $scheme; uwsgi_param HTTPS $https if_not_empty; uwsgi_param REMOTE_ADDR $remote_addr; uwsgi_param REMOTE_PORT $remote_port; uwsgi_param SERVER_PORT $server_port; uwsgi_param SERVER_NAME $server_name; 软连接12345cd /etc/nginxcd sites-enabledrm defaultln -s /var/www/nginx.conf homework_submissionls 重启nginx/etc/init.d/nginx restart 运行uwsgi12cd /var/wwwuwsgi --ini uwsgi.ini 让uwsgi自启动 vim /etc/rc.local(注意非虚拟环境也得安装uwsgi模块) 1234添加下面代码:/usr/local/bin/uwsgi --ini /var/www/uwsgi.iniexit 0 uwsgi的热启动 在uwsgi.ini中加入 py-autoreload=1 重启一下:killall -9 uwsgi、/usr/local/bin/uwsgi --ini /var/www/uwsgi.ini 总结关于etc/ linit. d 如果你使用过inux系统,那么你一定听说过 init. d目录,这个目录到底是干嘛的呢?它归根结底只做了一件事情,但这件事情非同小可,是为整个系统做的,因此它非常重要。init.d目录包含许多系统各种服务的启动和停止脚本 关于 /etc/rc.local rc.local也是我经常使用的一个脚本,该脚本是在系统初始化级别脚本运行之后再执行的,因此可以安’, ‘地在里面添加你想在系统启动之后执行的脚本. 总结 Linux是灵活的,正因为它的灵活性,我们总是可以找到许多不同的办法来解决同一个问题，服务的例子就是一个很好的佐证,有了 /etc/init.d目录下的脚本,再加上 /etc/rc. local这个利器，你可以放心的确保你的服务可以完美的启动和运行","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"小程序开发遇到的坑","slug":"小程序开发遇到的坑","date":"2018-10-04T12:26:58.000Z","updated":"2018-10-04T12:30:16.418Z","comments":true,"path":"小程序开发遇到的坑.html","link":"","permalink":"https://nymrli.top/小程序开发遇到的坑.html","excerpt":"","text":"小程序开发遇到的坑function 与 =&gt; 的区别 在JS中，箭头函数并不是简单的function(){}匿名函数的简写语法糖，实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，在编写函数时就已经确定了。而匿名函数的this指向运行时实际调用该方法的对象，无法在编写函数时确定。 箭头函数和普通函数的区别 不可以当做构造函数，也就是说，不可以使用 new 命令，否则会抛出错误。 this、arguments、caller等对象在函数体内都不存在。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 ==&gt;箭头函数除了传入的参数之外，其它的对象都没有！在箭头函数引用了this、arguments或者参数之外的变量，那它们一定不是箭头函数本身包含的，而是从父级作用域继承的。 代码实例:123456789101112function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 setTimeout(function()&#123; console.log(this.num); // undefined &#125;, 500); &#125;;&#125;var obj = new Test();obj.func();//这里的方法里调用了setTimeout函数，该函数500毫秒后调用我们定义的函数时，实际上是window对象调用的，所以这时匿名函数的this是指向window而不是指向obj了。 在箭头函数出现之前一般都是这么写的： 12345678910111213141516171819202122232425function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 var that = this; //保存一份当前的this对象 setTimeout(function()&#123; console.log(that.num); // 100 &#125;, 500); &#125;;&#125;var obj = new Test();obj.func();//这是利用了闭包的概念。箭头函数可以看做这种方式的语法糖。//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 setTimeout(() =&gt; &#123; console.log(this.num); // 100 //箭头函数没有this,所以从上层父级继承 &#125;, 500); &#125;;&#125;var obj = new Test();obj.func(); ▲同时需要注意的是:this是指向当前的对象，随着上下文作用域的切换this的执行this的指向会发生改变，我们可以先保存一份this的值然后再使用：var that = this 生成带参数的二维码123456789101112131415161718192021222324 onShow:function()&#123; var that = this; function get_code() &#123; wx.request(&#123; url: 'https://api.weixin.qq.com/cgi- bin/token?grant_type=client_credential&amp;appid=' + that.data.APP_ID + '&amp;secret=' + that.data.APP_SECRET, method: 'GET', success: function (res) &#123; // console.log(res.data.access_token); wx.request(&#123; data: &#123; 'path': \"pages/index\" &#125;, url: 'https://api.weixin.qq.com/wxa/getwxacode?access_token=' + res.data.access_token, method: 'POST', success: function (res) &#123; console.log(res.data);//2jin zhi &#125; &#125;) &#125; &#125;) &#125; get_code();&#125;//官方接口得到的是图片的二进制流 通过草料微信小程序生成二维码: 12345678910111213141516171819202122232425262728293031const app = getApp()Page(&#123; data: &#123; APP_ID: 'wx05818046869e4078', APP_SECRET: '5d4429375e84d6ab9476b643f8733af9', path: 'pages/index', photo:null, &#125;, onShow:function()&#123; var that = this; console.log(that.data.APP_ID + ' ' + that.data.APP_SECRET + ' ' + that.data.path) wx.request(&#123; url: 'https://cli.im/home/weapp/create', method:'POST', data:&#123; 'weapp_id': that.data.APP_ID,'weapp_secret': that.data.APP_SECRET,'weapp_url': that.data.path &#125;, header:&#123; 'content- type': 'application/x- www- form- urlencoded' &#125;, success:(res)=&gt;&#123; console.log(res.data.data) that.setData(&#123; photo: res.data.data &#125;) &#125; &#125;) &#125;&#125;) 组件的自定义数据属性:123&lt;view bindtap=\"f0\" data- xxx- yyy='blabla'&gt;&lt;/view&gt;//在点击触发事件f0的参数event中,dataset为自定义参数的字典,其中,键值为驼峰命名法.xxxYyy ▲.bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡 wx.requests是异步调用的 wx.requests这个api是不会阻塞的,什么时候收到response就什么时候调用回调函数(success…),如果在wx.requests方法调用后还有运行代码(1),则(1)比回调函数早执行 组件: 以某种方式对 业务逻辑和 功能**的封装 特点:高内聚,可复用 视图组件 表单组件 媒体组件 画布组件 基础内容组件 导航组件 地图组件 开放能力组件 自定义组件:​ 内容略 ES6新特性:js中let和var定义变量的区别 声明后未赋值，表现相同: 如果未在 let 、var 语句中初始化您的变量，则将自动为其分配 JavaScript 值 undefined 使用未声明的变量，表现不同: var有变量提升，let无变量提升 重复声明同一个变量时，表现不同： var重复声明时覆盖，let重复声明时报错 变量作用范围，表现不同： 使用 let 语句声明一个变量，该变量的范围限于声明它的块中。 ==&gt;代码演示: 123456789101112(function() &#123; var varTest = 'test var OK.'; let letTest = 'test let OK.'; &#123; var varTest = 'varTest changed.'; let letTest = 'letTest changed.'; &#125; console.log(varTest); //输出\"varTest changed.\"，内部\"&#123;&#125;\"中声明的varTest变量覆盖外部的letTest声明 console.log(letTest); //输出\"test let OK.\"，内部\"&#123;&#125;\"中声明的letTest和外部的letTest不是同一个变量&#125;());","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"带表头的单链表的基本操作","slug":"带表头的单链表的基本操作","date":"2018-09-27T14:12:17.000Z","updated":"2018-09-27T14:25:50.649Z","comments":true,"path":"带表头的单链表的基本操作.html","link":"","permalink":"https://nymrli.top/带表头的单链表的基本操作.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct Node&#123; ElemType elem; struct Node *link;&#125;Node;typedef struct &#123; struct Node* head; int n;&#125;Headlist;Status Init(Headlist *L)&#123; L-&gt;head = (Node*)malloc(sizeof(Node)); if(!L-&gt;head) return ERROR; L-&gt;head-&gt;link = NULL; L-&gt;n = 0; return OK;&#125;void Sort(Headlist *L)&#123; Node *p=L-&gt;head,*pre=NULL; Node *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;elem &lt; p-&gt;elem) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125;&#125;void deleleab(Headlist *L, int a,int b)&#123; Node *q = L-&gt;head,*p=L-&gt;head-&gt;link; // q为上一个,p为当前的 while( p ) if(p-&gt;elem &gt;= a &amp;&amp; p-&gt;elem &lt;= b) &#123; q-&gt;link = p-&gt;link; // 1 - 2 - 3 1==&gt;3,1的指针域指向3 free(p); //释放2 p = q-&gt;link; // 当前的指针变成3 &#125;else&#123; p = p-&gt;link; q = p-&gt;link; &#125; &#125;Status Converse(Headlist *L)&#123; Node *p = NULL,*cur= NULL; Node *q = L-&gt;head-&gt;link; if(L-&gt;head &amp;&amp; L-&gt;head-&gt;link)&#123; //如果表不存在或是为空,则return ERROR while( q != NULL ) //q按照原来的顺序依次遍历各结点 &#123; cur = q; //cur为当前结点 q = q-&gt;link; //q保存下一个结点 L-&gt;head-&gt;link = cur; //为了不动头结点,所以头结点link始终指向当前要加的结点 cur-&gt;link = p; //当前的link指向上一个结点 p = cur; //保存上一个结点 &#125; &#125;else return ERROR; return OK;&#125;Status Insert(Headlist *L,int j,ElemType x)&#123; Node *p=NULL,*q=NULL; int i; if(j&lt;-1 || j&gt; L-&gt; n-1) return ERROR; p = L-&gt;head; for(i=0;i&lt;=j;i++) p=p-&gt;link; q = (Node *)malloc(sizeof(Node)); q-&gt;elem = x; q-&gt;link = p-&gt;link; p-&gt;link = q; L-&gt;n++; return OK;&#125;Status Output(Headlist L)&#123; Node *p = L.head-&gt;link; if(!L.n) return ERROR; while(p)&#123; printf(\"%d \",p-&gt;elem ); p = p-&gt;link; &#125; return OK;&#125;Status Destory(Headlist *L)&#123; Node *p=NULL; while(L-&gt;head)&#123; //不断删除head所指向的内存,直到head被释放 p = L-&gt;head-&gt;link; free(L-&gt;head); L-&gt;head = p; &#125; return OK; &#125;Status Delete(Headlist *L,int j)&#123; //下标j Node *p = L-&gt;head,*q = L-&gt;head; // q = tmp int i; if(!L-&gt;n) return ERROR; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j-1;i++) p = p-&gt;link; q = p; p = p-&gt;link; q-&gt;link = p-&gt;link; free(p); return OK;&#125;Status Find(Headlist *L,int j,ElemType *x)&#123; Node *p= L-&gt;head; int i; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j;i++) p = p-&gt;link; *x = p-&gt;elem; return OK;&#125;int main()&#123; int x; Headlist list; Init(&amp;list); Insert(&amp;list,-1,3); Insert(&amp;list,0,2); Insert(&amp;list,-1,5); Insert(&amp;list,2,7); Insert(&amp;list,-1,1); printf(\"the linked list is :\"); Output(list); printf(\"\\nAfter sorted:\"); Sort(&amp;list); Output(list); printf(\"\\nAfter Conversed:\"); Converse(&amp;list); Output(list); printf(\"\\nAfter delete index of 0,the list is:\"); Delete(&amp;list,0); Output(list); Find(&amp;list,2,&amp;x); printf(\"\\nthe index of 2:%d\\n\",x); Destory(&amp;list); system(\"pause\"); return 0;&#125;//无论是什么都要略过head表头结点,表头结点的elem是任意的. (一)实验中遇到的主要问题及解决方法 1.题目二，带表头的单链表在插入时出现了点问题，书上给出的方法是错的，且是C++代码。于是在尝试理解他的想法及每步Debug中终于写出了正确的代码。（L-&gt;head-&gt;link = NULL,其中L-&gt;head-&gt;data 不填） 2.题目二中带表头节点的单链表中插入时for( j=0;j&lt;=i; j++) 和之前j&lt;i以及删除时for( j=0;j&lt;=i-1; j++) 和之前j&lt;i-1有很大不同,通过debug知道了是为了略过第一个表头节点。 3.逆置过程中,为了不动表头,略过第一个表头结点时出现了点麻烦.并且在第一个元素逆置后指向NULL,第二个结点指向第一个结点时没有想明白,后来才想到了先让P=NULL,然后记录上一个结点就能达到效果了.同时还有个问题是一直没有保存原来链表的顺序,再因为P=NULL导致会访问到非法内存而程序崩溃 （二）实验心得 2.题目二中,带表头单链表和不带表头单链表,在删除和插入时的循环条件不同要注意.及初始化时带表头的L-&gt;head-&gt;link= NULL; 与 无表头的 L-&gt;first = NULL;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"带表头的单链表应用——多项式","slug":"带表头的单链表应用——多项式","date":"2018-09-27T14:04:31.000Z","updated":"2018-09-27T14:26:11.753Z","comments":true,"path":"带表头的单链表应用——多项式.html","link":"","permalink":"https://nymrli.top/带表头的单链表应用——多项式.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct PNode&#123; ElemType ceof; ElemType exp; struct PNode *link;&#125;PNode;typedef struct &#123; struct PNode *head;&#125;polynominal;Status Init(polynominal *p)&#123; p-&gt;head = (PNode *)malloc(sizeof(PNode)); p-&gt;head-&gt;exp = -1; p-&gt;head-&gt;link = NULL; return OK;&#125;Status Create(polynominal *p)&#123; PNode *pn = NULL,*q=NULL,*pre=NULL; Init(p); //p-&gt;head = (PNode *)malloc(sizeof(PNode)); //p-&gt;head-&gt;exp = -1; //p-&gt;head-&gt;link = NULL; for (;;) // &lt;==&gt;while(1) &#123; pn = (PNode *)malloc(sizeof(PNode)); printf(\"ceof:\\n\"); scanf(\"%d\",&amp;pn-&gt;ceof); printf(\"exp:\\n\"); scanf(\"%d\",&amp;pn-&gt;exp); if (pn-&gt;exp &lt; 0) &#123;printf(\"End the input\\n\"); break;&#125; pre = p-&gt;head; //pre从链表头开始 q=p-&gt;head-&gt;link; while(q &amp;&amp; q-&gt;exp &gt; pn-&gt;exp)&#123; //pn为当前结点,q为链表中结点 pre = q; // q = q-&gt;link; &#125; pn-&gt;link = q; // 在pre和q之间插入pn,(q为null时,相当于末尾插入pn) pre-&gt;link = pn; // pre =&gt; pn =&gt; q &#125; return OK;&#125;Status Sort(polynominal *L)&#123; //从大到小 PNode *p=L-&gt;head,*pre=NULL; PNode *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;exp &lt; p-&gt;exp) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125; return OK;&#125;Status Add(polynominal *px,polynominal *qx)&#123; //目的:将q改成p+q PNode *q1=qx-&gt;head, *p=px-&gt;head-&gt;link; //q1指向qx表头结点 PNode *q=q1-&gt;link; //p指向多项式px第一个结点,q指向qx第一个 PNode *temp = NULL; //q1是q前驱 while( q &amp;&amp; p)&#123; while( p-&gt;exp &lt; q-&gt;exp )&#123; //找到qx中 大于等于q指数项的项,q不断右移 q1 = q; q = q-&gt;link; &#125; if (p-&gt;exp == q-&gt;exp )&#123; q-&gt;ceof = q-&gt;ceof + p-&gt;ceof; if (q-&gt;ceof == 0)&#123; q1-&gt;link = q-&gt;link; //释放当前q的内存 free(q); q = q1-&gt;link; p = p-&gt;link; &#125;else&#123; //p\\q都右移 q1 = q; //q1 q = q-&gt;link; p = p-&gt;link; &#125; &#125;else&#123; //p-&gt;exp &gt; q-&gt;exp temp = (PNode * )malloc(sizeof(PNode)); temp-&gt;ceof = p-&gt;ceof; temp-&gt;exp = p-&gt;exp; temp-&gt;link = q1-&gt;link; q1-&gt;link = temp; p = p-&gt;link; &#125; &#125; return OK;&#125;void Output(polynominal *p)&#123; PNode *q = p-&gt;head-&gt;link; int last = 0; while( q!=NULL )&#123; if(q-&gt;link == NULL) last =1; printf(\"%dx^%d\", q-&gt;ceof,q-&gt;exp); if(!last) printf(\"+\"); //此处注意个+的小细节 q = q-&gt;link; &#125; printf(\"\\n\");&#125;void Destory(polynominal *p)&#123; PNode *q = NULL; while(p-&gt;head)&#123; //不断删除head所指向的内存,直到head被释放 q = p-&gt;head-&gt;link; free(p-&gt;head); p-&gt;head = q; &#125;&#125;/***********合并同类项*****************//***********合并即free*****************/Status unify(polynominal *t)&#123; PNode *p=NULL; PNode *q=NULL; PNode *last=NULL; PNode *tmp; //while(p-&gt;link != NULL)&#123; for(p=t-&gt;head-&gt;link;p!=NULL;p=p-&gt;link)&#123; //选择 last = p; for(q=last-&gt;link; q!=NULL ; )&#123; //q指针向后推移指向下一结点 if(q-&gt;exp == p-&gt;exp)&#123; //相等计算 p-&gt;ceof += q-&gt;ceof; //q为 滑动项 tmp = q-&gt;link; last-&gt;link = q-&gt;link; //last保存上一个q free(q); // 吧q的空间释放掉 q= tmp; &#125;else&#123; last= q; q=q-&gt;link;&#125; //如果不相等就判断下一个 &#125; &#125; return OK;&#125;polynominal Multiply(polynominal *px,polynominal *qx)&#123; PNode *p = px-&gt;head; PNode *q = qx-&gt;head; PNode *x = NULL; PNode *tmp = NULL; polynominal newpoly; Init(&amp;newpoly); x = newpoly.head; for (p=px-&gt;head-&gt;link; p!=NULL; p=p-&gt;link)&#123; for (q=qx-&gt;head-&gt;link; q!=NULL; q=q-&gt;link)&#123; tmp = (PNode*)malloc(sizeof(PNode)); tmp-&gt;ceof = p-&gt;ceof * q-&gt;ceof; tmp-&gt;exp = p-&gt;exp + q-&gt;exp; tmp-&gt;link = x-&gt;link; //新生成的结点指向上一个生成的结点的地址 x-&gt;link = tmp; //使链表记录当前tmp结点 x = x-&gt;link; //取下一个结点 &#125; &#125; unify(&amp;newpoly); Sort(&amp;newpoly); return newpoly;&#125;int main()&#123; polynominal p,q; polynominal mul; Create(&amp;p); Output(&amp;p); // printf(\"After unify:\\n\"); Unify // unify(&amp;p); // Output(p); Create(&amp;q); Output(&amp;q); // Add(&amp;p,&amp;q); ADD // printf(\"q:\"); // Output(q); printf(\"After Multiplied:\\n\"); mul = Multiply(&amp;p,&amp;q); Output(&amp;mul); system(\"pause\"); return 0;&#125;//其中Sort,unify,add,multiply,需要捉摸一下 (一)实验中遇到的主要问题及解决方法 1.题目二，带表头的单链表在插入时出现了点问题，书上给出的方法是错的，且是C++代码。于是在尝试理解他的想法及每步Debug中终于写出了正确的代码。（L-&gt;head-&gt;link = NULL,其中L-&gt;head-&gt;data 不填） 2.题目二中带表头节点的单链表中插入时for( j=0;j&lt;=i; j++) 和之前j&lt;i以及删除时for( j=0;j&lt;=i-1; j++) 和之前j&lt;i-1有很大不同,通过debug知道了是为了略过第一个表头节点。 3.逆置过程中,为了不动表头,略过第一个表头结点时出现了点麻烦.并且在第一个元素逆置后指向NULL,第二个结点指向第一个结点时没有想明白,后来才想到了先让P=NULL,然后记录上一个结点就能达到效果了.同时还有个问题是一直没有保存原来链表的顺序,再因为P=NULL导致会访问到非法内存而程序崩溃 4.合并同类项的过程中,使用了选择排序类似的思想,但是在里层for(q=last-&gt;link; q!=NULL ; )出了问题,一开始写成 for(q=last-&gt;link; q!=NULL ; q=q-&gt;link)但是如果指数相等,q就会被free掉,此时q=q-&gt;link就会出问题 （二）实验心得 1.题目一中，顺序表是malloc动态申请的空间，是连续的，可以直接通过下标访问。 2.题目二中,带表头单链表和不带表头单链表,在删除和插入时的循环条件不同要注意.及初始化时带表头的L-&gt;head-&gt;link = NULL; 与 无表头的 L-&gt;first = NULL; 3.Debug过程中F10和F11的区别,在malloc和free处按F11会进入malloc函数、free函数的汇编的运行过程 4.排序和逆置时都要有个指针记住原来链表的顺序,然后才能再依次按顺序进行. 5.理清要做的事,再下手写代码,画图有时很重要.","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"小程序蓝牙","slug":"小程序蓝牙API","date":"2018-09-20T02:57:01.000Z","updated":"2018-10-04T12:30:02.067Z","comments":true,"path":"小程序蓝牙API.html","link":"","permalink":"https://nymrli.top/小程序蓝牙API.html","excerpt":"","text":"提供蓝牙模块APIwx.openBluetoothAdapter(OBJECT)​ 初始化小程序蓝牙模块 wx.closeBluetoothAdapter(OBJECT)​ 关闭蓝牙模块，使其进入未初始化状态。 wx.getBluetoothAdapterState(OBJECT)​ 获取本机蓝牙适配器状态 wx.onBluetoothAdapterStateChange(CALLBACK)​ 监听蓝牙适配器状态变化事件 wx.startBluetoothDevicesDiscovery(OBJECT)​ 开始搜寻附近的蓝牙外围设备。注意，该操作比较耗费系统资源，请在搜索并连接到设备后调用 stop 方法停止搜索。 wx.stopBluetoothDevicesDiscovery(OBJECT)​ 停止搜寻附近的蓝牙外围设备。若已经找到需要的蓝牙设备并不需要继续搜索时，建议调用该接口停止蓝牙搜索。 wx.getBluetoothDevices(OBJECT)​ 获取在小程序蓝牙模块生效期间所有已发现的蓝牙设备，包括已经和本机处于连接状态的设备。 wx.onBluetoothDeviceFound(CALLBACK)​ 监听寻找到新设备的事件 wx.createBLEConnection(OBJECT)​ 连接低功耗蓝牙设备。 wx.closeBLEConnection(OBJECT)​ 断开与低功耗蓝牙设备的连接 wx.getBLEDeviceServices(OBJECT)​ 获取蓝牙设备所有 service（服务） wx.getBLEDeviceCharacteristics(OBJECT)​ 获取蓝牙设备某个服务中的所有 characteristic（特征值） wx.readBLECharacteristicValue(OBJECT)​ 读取低功耗蓝牙设备的特征值的二进制数据值。注意：必须设备的特征值支持read才可以成功调用，具体参照 characteristic 的 properties 属性 wx.writeBLECharacteristicValue(OBJECT)​ 向低功耗蓝牙设备特征值中写入二进制数据。注意：必须设备的特征值支持write才可以成功调用，具体参照 characteristic 的 properties 属性 tips: 并行调用多次读写接口存在读写失败的可能性* wx.notifyBLECharacteristicValueChange(OBJECT)​ 启用低功耗蓝牙设备特征值变化时的 notify 功能，订阅特征值。注意：必须设备的特征值支持notify或者indicate才可以成功调用，具体参照 characteristic 的 properties 属性 ​ 另外，必须先启用notify才能监听到设备 characteristicValueChange 事件 wx.onBLEConnectionStateChange(CALLBACK)​ 监听低功耗蓝牙连接状态的改变事件，包括开发者主动连接或断开连接，设备丢失，连接异常断开等等 wx.onBLECharacteristicValueChange(CALLBACK)​ 监听低功耗蓝牙设备的特征值变化。必须先启用notify接口才能接收到设备推送的notification。 ### 示例代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// pages/bluetooth/bluetooth.jsPage(&#123; data:&#123;&#125;, onLoad:function(options)&#123; // 页面初始化 options为页面跳转所带来的参数 &#125;, //初始化蓝牙适配器 openBluetooth:function()&#123; wx.openBluetoothAdapter(&#123; success: function(res)&#123; console.log(res.errMsg) // success wx.showToast(&#123; title:\"初始化蓝牙适配器成功\", duration:2000 &#125;) &#125;, &#125;) &#125;,//关闭蓝牙模块closeBluetooth:function()&#123; wx.openBluetoothAdapter() wx.closeBluetoothAdapter(&#123; success: function(res)&#123; // success console.log(\"success\"+res) &#125; &#125;)&#125;,//获取本机蓝牙适配器状态getBluetoothAdapterState:function()&#123;wx.getBluetoothAdapterState(&#123; success: function(res)&#123; // success console.log(\"res:\"+res) console.log(\"errMsg:\"+res.errMsg) &#125;&#125;)&#125;,//监听蓝牙适配器状态变化事件 onBluetoothAdapterStateChange:function()&#123; wx.onBluetoothAdapterStateChange(function(res) &#123; console.log(`adapterState changed, now is`, res) &#125;)&#125;, // 开始搜寻附近的蓝牙外围设备 startBluetoothDevicesDiscovery:function()&#123; wx.startBluetoothDevicesDiscovery(&#123; success: function (res) &#123; console.log(res) &#125; &#125;)&#125;, // 停止搜寻附近的蓝牙外围设备 stopBluetoothDevicesDiscovery:function()&#123; wx.stopBluetoothDevicesDiscovery(&#123; success: function (res) &#123; console.log(res) &#125; &#125;)&#125;, //获取所有已发现的蓝牙设备 getBluetoothDevices:function()&#123; wx.getBluetoothDevices(&#123; success: function(res)&#123; // success console.log(res) &#125;, &#125;) &#125;, //监听寻找到新设备的事件 onBluetoothDeviceFound:function()&#123; wx.onBluetoothDeviceFound(function(res) &#123; // callback console.log(res) &#125;) &#125;, //根据 uuid 获取处于已连接状态的设备 getConnectedBluetoothDevices:function()&#123; wx.getConnectedBluetoothDevices(&#123; success: function (res) &#123; console.log(res) &#125;&#125;)&#125;,//连接低功耗蓝牙设备createBLEConnection:function()&#123; wx.createBLEConnection(&#123; deviceId: 'AC:BC:32:C1:47:80', success: function(res)&#123; // success console.log(res) &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;,//断开与低功耗蓝牙设备的连接closeBLEConnection:function()&#123; wx.closeBLEConnection(&#123; deviceId: 'AC:BC:32:C1:47:80', success: function (res) &#123; console.log(res) &#125;&#125;)&#125;,//监听低功耗蓝牙连接的错误事件，包括设备丢失，连接异常断开等等onBLEConnectionStateChanged:function()&#123; wx.onBLEConnectionStateChanged(function(res) &#123; console.log(`device $&#123;res.deviceId&#125; state has changed, connected: $&#123;res.connected&#125;`)&#125;)&#125;,//获取蓝牙设备所有 service（服务）getBLEDeviceServices:function()&#123; wx.getBLEDeviceServices(&#123; deviceId: '48:3B:38:88:E3:83', success: function(res)&#123; // success console.log('device services:', res.services.serviceId) &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;,//获取蓝牙设备所有 characteristic（特征值）getBLEDeviceCharacteristics:function()&#123; wx.getBLEDeviceCharacteristics(&#123; deviceId: '48:3B:38:88:E3:83', serviceId: 'serviceId', success: function(res)&#123; // success &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;&#125;)","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"电信路由器上网","slug":"电信路由器上网","date":"2018-09-20T02:01:16.000Z","updated":"2018-10-04T07:32:40.777Z","comments":true,"path":"电信路由器上网.html","link":"","permalink":"https://nymrli.top/电信路由器上网.html","excerpt":"","text":"链接: https://pan.baidu.com/s/1QaW7DMhjb2YHd0ZVWterSw 密码：联系QQ1063052964,或是在下方评论处留言QQ","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"小程序入门学习","slug":"小程序入门学习","date":"2018-09-20T01:57:01.000Z","updated":"2018-09-20T02:06:14.438Z","comments":true,"path":"小程序入门学习.html","link":"","permalink":"https://nymrli.top/小程序入门学习.html","excerpt":"","text":"IDE搭建:下载:微信公众平台官网 预备知识: 个人认为入门小程序相对比较简单,需要了解HTML+CSS 大概知道是干啥的就行,JavaScrip还是要看看的，推荐教程 廖雪峰的博客以及W3Cschool的JS教程 项目目录结构介绍: 小程序中一共有四种类型的文件: js ———- JavaScrip文件 json ——– 项目配置文件，负责窗口颜色等等 wxml ——- 类似HTML文件 wxss ——- 类似CSS文件 重要文件-APP讲解: app.json(必需) :监听并处理小程序的生命周期函数、声明全局变量。 app.js(建议保存) : *作为配置整个APP的入口,可以什么都不写只输入{}.对整个小程序的全局配置。记录了页面组成(定义了每个页面)，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。* ​ ==&gt;没有最简单的小程序也能运行. app.wxml app.wxss ===&gt; 所以只有app.js和app.json的项目是最简单的小程序 具体页面下的 js文件配置页面入口 wxml配置布局 一起完成对页面的渲染 wxss样式文件 json配置文件 会覆盖app.json和app.wxss全局设置的内容,实现单个网页的个性化 app.js 12345678910111213141516171819202122232425262728293031323334353637Page(&#123; //* 页面的初始数据 data: &#123; &#125;, // * 生命周期函数--监听页面加载 onLoad: function (options) &#123; &#125;, //* 生命周期函数--监听页面初次渲染完成 onReady: function () &#123; &#125;, //* 生命周期函数--监听页面显示 onShow: function () &#123; &#125;, //* 生命周期函数--监听页面隐藏 onHide: function () &#123; &#125;, //* 生命周期函数--监听页面卸载 onUnload: function () &#123; &#125;, //* 页面相关事件处理函数--监听用户下拉动作 onPullDownRefresh: function () &#123; &#125;, //* 页面上拉触底事件的处理函数 onReachBottom: function () &#123; &#125;, //* 用户点击右上角分享 onShareAppMessage: function () &#123; &#125;&#125;) app.json 1234\"pages\":[ \"pages/index/index\" //pages 里面的路径其实是指向js文件的,其中第一个就是登陆首页] 实现路由配置,及全局的某些设置 app.js** 定义了每个页面,每个页面的.js又调用了Page()方法实现该页面的配置信息 小程序事件 事件 == 事件类型+具体事件 具体事件 tap longtap toustart、touchend、touchmove、touchcancel(电话中断) submint、input…… 事件类型 bind 冒泡事件 catch 非冒泡事件 currentTarget 被绑定的组件 dataset 控件相应的属性 target 发生事件的组件 页面跳转 navigateTo({ url :&#39;xxx&#39; }) &lt;navigator url=&quot;../logs/logs?id=1&amp;title=&#39;as&#39;&quot; &gt; &lt;/navigator&gt; Flex容器和元素容器属性 flex-direction : 决定主轴方向 flex-wrap : 处理如何换行 flex-flow : flex-dirction和flex-wrap合并简写 justify-content: 元素在主轴的对齐方式 space-bewteen 两端对齐 center 居中对齐 flex-start 左侧对齐 flex-end 右侧对齐 align-items : 元素在交叉轴的对齐方式 stretch 拉伸,当没设置item高度时,占满整个容器 baseline :以文字为底线对齐 元素属性 flex-grow (默认0): 当有多余空间时,元素的放大比例 flex-shrink(默认1) : 当空间不足时,元素的放大比例 flex-basis: 元素在主轴上占据的空间 flex : flex-grow、flex-shrink、flex-basis的合并简写 order : 定义元素的排列顺序 align-self : 定义元素自身的对齐方式 定位 相对定位: 相对定位的元素是相对自身进行定位,参照物是自己 绝对定位 : 绝对定位的元素是相对离它最近的一个已定位的父级元素进行定位,如果没有,则以整个页面进行定位 margin和padding的区别 margin是指从 自身边框 到 另一个容器边框 之间的距离，就是容器外距离。（外边距） padding是指 自身边框 到 自身内部另一个容器边框 之间的距离，就是容器内距离。（内边距） rpx 动态单位 css布局实例123456789101112wxml: &lt;view class='list-item' wx:for=\"&#123;&#123;listItem&#125;&#125;\"&gt; &lt;view class='list-item-images'&gt; &lt;image src='../../images/img2.png' class='list-item-images-img' /&gt; &lt;!-- &lt;image class='avatar' src='../../images/avatar.png'/&gt; --&gt; &lt;/view&gt; &lt;view class=\"list-item-text\"&gt; &lt;text&gt;这是一个标题&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415wxss:.list-item&#123; height:500rpx; //整个 图片+文字 一共高为500rpx width: 100%;&#125; .list-item-images&#123; height: 300rpx; // 其中图片的高度为300rpx width: 100%;&#125;.list-item-images image&#123; //图片高、宽全部伸展 height: 100%; width: 100%;&#125;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"Spy++使用介绍","slug":"Spy-使用介绍","date":"2018-09-02T11:39:45.000Z","updated":"2018-09-02T11:40:26.032Z","comments":true,"path":"Spy-使用介绍.html","link":"","permalink":"https://nymrli.top/Spy-使用介绍.html","excerpt":"","text":"Spy++ (SPYXX.EXE) 是一个基于 Win32 的实用工具，它提供系统的进程、线程、窗口和窗口消息的图形视图。使用 Spy++ 可以执行下列操作： 显示系统对象（包括进程、线程和窗口）之间关系的图形树。 搜索指定的窗口、线程、进程或消息。 查看选定的窗口、线程、进程或消息的属性。 我们可以使用微软的Spy++来查看窗口类名等信息，然后再结合pywin32实现。 加载初始界面: 然后点击工具栏的望远镜。如图所示: 出现搜索窗口，然后通过移动靶心到想要查找句柄的窗口后单击就行了。==&gt;它的句柄、标题、类都会显示 再点击确定。 此时会有两种情况。 成功搜索到 搜索不到 原因是你查找的窗口是在打开spy++后打开的，解决的办法就是按F5进行刷新，然后就行了 成功后都会出现如下： 右键，点击“属性”能看到更多详细内容。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"解决安装PyUserInput、pyHook遇到的问题——AttributeError: 'HookManager' object has no attribute 'keyboard_hook","slug":"解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook","date":"2018-09-02T11:33:32.000Z","updated":"2018-09-02T11:33:55.065Z","comments":true,"path":"解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook.html","link":"","permalink":"https://nymrli.top/解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook.html","excerpt":"","text":"安装PyUserInput失败。 经查看发现是pyHook（pyHook是一个用来进行键盘、鼠标等层面事件监控的库。这个库的正常工作需要pythoncom等操作系统的API的支持。）无法安装，不知道是不是因为这个库可以被用于一些比较邪恶的目的。经搜索发现直接pip install pyHook是找不到相关包的，但可以下源码编译安装，可以在 https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyhook 这里可以直接下载到.whl文件，这个文件可以作为pip install 的参数来进行安装。 直接输入pip install pyHook-1.5.1-cp36-cp36m-win_amd64.whl好像还是不行，经提示使用G:\\Py_opencv\\venv\\Scripts\\python.exe -m pip install pyHook-1.5.1-cp36-cp36m-win_amd64.whl第一个参数是python解释器，-m选项可以让python以脚本的方式运行一个模块，pip install后面就是要安装的包名。 pyHook-1.5.1-cp36-cp36m-win_amd64.whl pyHook:库名1.5.1：版本号cp3.6m：Cpython3.6版本,编码是ucs2,UCS2认为每个字符占用2个字节，UCS4认为每个字节占用4个字符，都是UNICODE的编码形式。win_amd64:windows64位环境whl:压缩包，在其中包含了py文件，以及经过编译的pyd文件。可以使用pip安装 电脑系统环境查看，可以右键“我的电脑”-&gt;“属性”查看 然后再直接在命令行里输入pip install pyuserinput或是在pycharm下载安装都可以了。（需要先安装pywin32） 上述下载的pyHook是基于Python2的,在python3下会报错:TypeError: MouseSwitch() missing 8 required positional arguments: &#39;msg&#39;, &#39;x&#39;, &#39;y&#39;, &#39;data&#39;, &#39;flags&#39;, &#39;time&#39;, &#39;hwnd&#39;, and &#39;window_name&#39;或者AttributeError: &#39;HookManager&#39; object has no attribute &#39;keyboard_hook&#39; 感谢:python3.5安装pyHook,解决【TypeError: MouseSwitch() missing 8 required positional arguments: ‘msg’, ‘x’, ‘y’, ‘data’, ‘time’, ‘hwnd’, and ‘window_name’】这个错误！、使用Python 3.5/3.6监听本机任意窗口中的按键操作提供的解决方法 需要的模块：扩展库pyhook_py3k（注意，不要使用pyhook），pywin32。第一步，安装pywin32，地址：http://www.lfd.uci.edu/~gohlke/pythonlibs/#pywin32第二步，下载pyhook_py3k，地址：https://github.com/Answeror/pyhook_py3k第三步，下载swig.exe，地址：http://www.swig.org/download.html ==&gt;.zip格式解压第四步，解压缩pyhook_py3k，并进行编译，命令：python setup.py build_ext –swig=..\\swigwin-3.0.12\\swig.exe，可以根据实际情况修改swig.exe的路径，另外本机最好已安装VC2008第五步，安装编译好的pyhook_py3k，命令：pip install . 然后就可以正常操作了!!~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"开学小蓝车180天免费卡","slug":"开学小蓝车180天免费卡","date":"2018-09-02T08:44:54.000Z","updated":"2018-10-24T11:00:26.493Z","comments":true,"path":"开学小蓝车180天免费卡.html","link":"","permalink":"https://nymrli.top/开学小蓝车180天免费卡.html","excerpt":"各位看客老爷,可以加下我的公众号哦!虽然没啥东东….微信搜索公众号”我只要瓶果粒橙就好” 原来是180天的,现在好像只有30还是60天了..","text":"各位看客老爷,可以加下我的公众号哦!虽然没啥东东….微信搜索公众号”我只要瓶果粒橙就好” 原来是180天的,现在好像只有30还是60天了..","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"例题4:1-3 古老的密码、刽子手的游戏，救济金发放","slug":"例题4-1-3-古老的密码、刽子手的游戏，救济金发放","date":"2018-09-01T10:46:59.000Z","updated":"2018-09-01T12:38:41.000Z","comments":true,"path":"例题4-1-3-古老的密码、刽子手的游戏，救济金发放.html","link":"","permalink":"https://nymrli.top/例题4-1-3-古老的密码、刽子手的游戏，救济金发放.html","excerpt":"","text":"例题4-1 古老的密码 因为字母可以重排,所以顺序不重要,而又同时因为可以映射,所以字母具体是什么不重要==&gt;只要统计排序后的结果相同就行了 RE(Runtime error)错法加一: 题号提交错误 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;void Bubblesort(int *cnt)//冒泡排序,从大到小顺序&#123; int i,j; int min=cnt[0]; for (i = 0; i &lt;26; ++i) &#123; for ( j = i+1; j &lt; 26; ++j) &#123; if (cnt[i] &lt; cnt[j]) &#123; min = cnt[i]; cnt[i]=cnt[j]; cnt[j] = min; &#125; &#125; &#125;&#125;int main()&#123; char s[2][105]; //存放猜测字符串的 int cnt[2][27]; //存放字母出现次数 int nlen[2]; //字符串的长度 while(scanf(\"%s%s\",s[0],s[1])!= EOF) &#123; memset(cnt,0,sizeof(cnt)); int i; for ( i = 0; i &lt; 2; ++i) &#123; nlen[i]= strlen(s[i]); int j; for ( j = 0; j &lt; nlen[i]; ++j) cnt[i][s[i][j]-'A'] ++; Bubblesort(cnt[i]); &#125; int k; for ( k = 0; k &lt; 26; ++k) &#123; if (cnt[0][k] != cnt[1][k]) &#123; printf(\"NO\\n\"); break; &#125; &#125; if (k==26) printf(\"YES\\n\" ); //如果26个字母出现次数比完全相等,则可以说相同. &#125; return 0;&#125; 例题4-2 刽子手的游戏 注意全局变量是否使用的问题,全局变量尽量少用…但维护内容较多的情况下,可以考虑 采用”自顶向下”的顺序 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 100char ans[maxn],gue[maxn];int left,chance;int win,lose;void guess(char ch)&#123; int bad=1; int i; for ( i = 0; i &lt; strlen(ans); ++i) //判断ch字母是否在字符串中 &#123; if (ans[i]==ch) &#123; ans[i] = ' '; bad =0; left--; //如果在的话,还剩未猜中字母数-1,机会不变 &#125; &#125; if (bad) chance--; //如果不在的话机会-1 if(!chance) lose=1; if(!left) win=1;&#125;int main()&#123; int rnd; while(scanf(\"%d%s%s\",&amp;rnd,ans,gue)==3 &amp;&amp; rnd !=-1) &#123; printf(\"Round %d\\n\",rnd); win = lose =0; left= strlen(ans); chance = 7; int i; int anslen=strlen(gue); for( i=0;i&lt; anslen;i++) &#123; guess(gue[i]); if(win || lose) break;&#125; if(win) printf(\"You win.\\n\"); else if(lose) printf(\"You lose.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;char a[1000],g[1000];//储存字符串 int abook[26],gbook[26];//标记26个字母出现频率 int main()&#123; int k; int alen,glen; int i; int j; int suc,fau; int acount; while(scanf(\"%d\",&amp;k)==1&amp;&amp;k!=-1)&#123; scanf(\"%s%s\",a,g); memset(abook,0,sizeof(abook)); memset(gbook,0,sizeof(gbook)); alen=strlen(a); glen=strlen(g); for(i=0;i&lt;alen;i++)//统计答案字母频率 abook[a[i]-'a']++; acount=0; for(i=0;i&lt;26;i++) if(abook[i])//统计答案的字母组成个数（扣除雷同字母） acount++; suc=0;//猜对次数 fau=0;//猜错次数 for(i=0;i&lt;glen;i++)&#123;//以猜测字母为基准进行扫描 j=g[i]-'a'; if(abook[j]==0)&#123;//答案无此字母，猜测错误 fau++; if(fau==7)//彻底失败 break; &#125;else if(abook[j]!=0)&#123;//猜中字母 suc++; abook[j]=0;//将此字母从答案中剔除出去，此句比较关键!(再猜无效) if(suc==acount)//成功 break; &#125; &#125; printf(\"Round %d\\n\",k); if(fau&gt;=7)//猜错7次及以上 printf(\"You lose.\\n\"); else if(suc==acount)//全部猜对 printf(\"You win.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 例题4-3 救济金发放 圆圈如何轮回==&gt;本质上是要求,大于n变成1,小于1变成n…实现1.越界后归正。2.(xxx)%n, 领过设为1,没领过(初始)设为1 较为简洁、清晰的做法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;string.h&gt;int book[100];//领过的标记1，没领过的标记0 int main()&#123; int n,k,m; int kcount,mcount; int ki,mi; int kout,mout; int first; int ncount; while(scanf(\"%d%d%d\",&amp;n,&amp;k,&amp;m)==3&amp;&amp;n&amp;&amp;k&amp;&amp;m)&#123; memset(book,0,sizeof(book)); ncount=0; ki=0; mi=n+1; first=1; while(ncount!=n)&#123;//n个人全被处理完毕//处理手法有些类似快速排序 kcount=0; mcount=0; //每数一个人,都要判断是不是该越过他.只有0(未领过,才计数) while(kcount!=k)&#123;//k系列处理 ki++; if(ki&gt;n)//ki越界处理 ki=1; if(book[ki]==0)//未被选中计数 ki为当前值 kcount++; &#125; while(mcount!=m)&#123;//m系列处理 mi--; if(mi&lt;1)//mi越界处理 mi=n; if(book[mi]==0)//未被选中计数 mi为当前值 mcount++; &#125; book[ki]=1;//不用担心ki==mi(重复设置为1不影响) book[mi]=1; if(first)&#123;//打印处理 first=0; if(ki!=mi)&#123; printf(\"%3d%3d\",ki,mi); ncount+=2; &#125; else&#123; printf(\"%3d\",ki); ncount++; &#125; &#125;else&#123; if(ki!=mi)&#123; printf(\",%3d%3d\",ki,mi); ncount+=2; &#125; else&#123; printf(\",%3d\",ki); ncount++; &#125; &#125; &#125; printf(\"\\n\"); &#125; return 0;&#125; 书上做法123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 25int n,k,m,a[maxn];int go(int p,int d,int t)&#123; while(t--) //每数一个人都要判断他是否已经领过 do&#123; p = (n+p+d)%n; &#125;while(!a[p]); //==0,领过 return p;&#125;int main()&#123; while(scanf(\"%d,%d,%d\",&amp;n,&amp;k,&amp;m)==3 &amp;&amp; n) &#123; for (int i = 0; i &lt; n; ++i) a[i]=i; int left =n; int p1 =n,p2=1; while(left) &#123; p1= go(p1,-1,k); p2= go(p2,1,m); printf(\"%d\",p1);left--; if(p1!=p2) printf(\" %d\",p2); a[p1]=a[p2]=0; //领了设置为0 if(left) printf(\",\"); //注意输出格式 &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"},{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"WampSever配置本地环境，解决打开打开本地网站问题","slug":"WampSever配置本地环境，解决打开打开本地网站问题","date":"2018-09-01T06:19:39.000Z","updated":"2018-09-01T06:26:52.393Z","comments":true,"path":"WampSever配置本地环境，解决打开打开本地网站问题.html","link":"","permalink":"https://nymrli.top/WampSever配置本地环境，解决打开打开本地网站问题.html","excerpt":"","text":"WampServer是一款由法国人开发的Apache Web服务器、PHP解释器以及MySQL数据库的整合软件包。免去了开发人员将时间花费在繁琐的配置环境过程，从而腾出更多精力去做开发。 直接点击本地的.html是静态加载的，需要动态加载的文件是无法被加载的。会出现如下情况。 于是选用了Wamp搭本地服务器浏览网站，这样就能成功加载动态文件了。 在此分享下配置WampSever时碰到的问题和解决的方法： 服务器是否已正常运行如果能登上则表示服务器能够正常运行。(在地址栏中输入localhost:端口(或是127.0.0.1:端口) 或是左键图标选择’localhost’) localhost 指你所在的计算机本身。 在windows系统它成了127.0.0.1的别名 ，在Unix系统下，查看网卡配置会发现作为本地回环的方式，一定程度上使用localhost比127.0.0.1要快一些。 在Hosts文件中，localhost指向的IP是127.0.0.1这个关系是可以修改的。 查看、修改端口 配置本地环境、添加项目、打开本地网站 1项目中是空的,需要手动将要打开的网站放到'www'目录中 1可以选择输入路径，也可以直接左键选择'www目录'打开 1将要打开网站的文件夹复制到'www目录下'，会发现刚添加的文件夹出现在了项目中。 勾选’Add localhost in url’1看似到此已经大功告成，然而再点击进去这些文件夹时会出现如下情况： 1可以看到的是URL并不对，我们是想要实现通过web服务器的方式访问这些网站，然而这个明显没达到我们想要的效果，根据提示，我找到了原因。 1右键选择'Wamp Settings'中将'Add localhost in url'选项勾上后再次如上打开项目即可。（记得重新打开一次localhost页面或是刷新一下） 1可以看到网站成功地通过web服务器打开了，那些之前提示需要动态加载的文件也成功加载了。 撒花完结！~200成功！ ▲.看到这，我相信你也明白了为什么必须要有’Add localhost in url’这步了。同时也猜到了，其实直接在网址里面输入正确的网址也是可以的，如http://localhost:8080/data-visualize-chain-master/,结果也是能打开的。 希望能对你们有所帮助。","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"WAMP","slug":"WAMP","permalink":"https://nymrli.top/tags/WAMP/"}]},{"title":"Ubuntu下Sublime配置Python环境使用指导:","slug":"Ubuntu下Sublime配置Python环境使用指导","date":"2018-09-01T06:04:47.000Z","updated":"2018-10-23T14:20:00.900Z","comments":true,"path":"Ubuntu下Sublime配置Python环境使用指导.html","link":"","permalink":"https://nymrli.top/Ubuntu下Sublime配置Python环境使用指导.html","excerpt":"","text":"Sublime配置python编译环境及搭建虚拟环境:(windows下大致相同)1.编译环境配置1import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 1.点击 官方网址 从 Sublime Text 3 官方获取用于安装的代码。从菜单栏View –&gt;Show Console或者使用Ctrl+`(esc键下面的按键)，调出sublime的控制台，将官网中的python代码粘贴进去并按Enter执行，最终可以安装完成。在控制台中粘贴刚才的代码，然后点击回车。最后重启ST3。 2.现在你可以通过快捷键 cmd+shift+P 打开 Package Control 来安装其他的插件了。输入 install 然后你就能看见屏幕上出现了 Package Control: Install Package，点击回车,然后搜索sublimeREPL 安装成功后，可以在菜单栏的’TOOL’中找到SublimeREPL，如图所示 2.将菜单栏改为中文若需要将菜单栏改成中文可如上操作下载插件“ConvertToUTF8”或是安装插件“ChineseLocalizations”(本人使用的是这个，没试ConvertToUTF8的效果) (参考博客:http://blog.51cto.com/11970781/2087971) 3.安装Anaconda插件 1.点击刚刚生成的Package Control -&gt;输入install 2.进入安装界面，安装好后再在新窗口命令行中输入Anaconda并点击第一个备选项进行安装。 安装完成后会显示messages文档。 安装Anaconda插件完成之后，会看到如下选项栏，说明Anaconda安装成功。 - Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数或者类的定义。 - Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 - Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下) Anaconda会自动补全代码，之前用惯了pycharm发现突然没了代码补全后很不习惯，Anaconda的补全功能虽然没有pycharm那么好用，但还是不错的 还有需要注意的是，安装Anaconda插件后，如果python代码没有遵循PEP8规范，会出现白色的框框，或是可以使用快捷键Ctrl+Alt+R进行规范代码(这个可以去除，步骤如下) 在Settings-User选项中添加配置:{“anaconda_linting”:false} 4.安装虚拟环境 1.首先使用终端安装virtualenv，pip3 install virtualenv2.在需要创建的地方进行虚拟环境的搭建，代码如下： 123mkdir pytest(文件夹名)cd pytestvirtualenv venv 在终端进入虚拟环境的话是在pytest文件夹下输入命令source /bin/activate而要在sublime中进入虚拟环境的话就得按照如下操作： １．首先在sublime中安装virtualenv插件，Ctrl + Shift + P，然后输入install,回车，然后搜索virtualenv。 2. 安装完成后，直接按Ctrl + Shift + P，再输入Activate，若没有该选项则virtualenv安装中出现问题，需要重新安装。如果有的会选择Activate就能发现刚刚创建的虚拟环境，选中后回车即可进入虚拟环境 3. 如果Activate选中后没有出现我们刚刚创建的虚拟环境，则需要我们手动添加路径.Ctrl + Shift + P，然后输入Add directory，回车，屏幕下面会出现输入行（Directory path）:再将刚创建的虚拟环境路径填入即可 另外，我曾碰到过Add directory后仍然没用的情况。那时，可选择“”Project”=&gt;”Add folder to project”选择文件后=&gt;”Save Project as”==&gt;保存好即可 工程配置文件为： .sublime-workspace、.sublime-project 其中sublime-project为: 123456789101112131415161718&#123; \"build_systems\": [ &#123; \"file_regex\": \"^[ ]File \"(...?)\", line ([0-9]*)\", \"name\": \"Anaconda Python Builder\", \"selector\": \"source.python\", \"shell_cmd\": \"\"python\" -u \"$file\"\" &#125; ], \"folders\": [ &#123; \"path\": \"爬虫\" &#125; ], \"virtualenv\": \"G:\\pachong\\venv\"&#125; 这样环境就配置好了。按Ctrl+B编译时，观察”Tools”-&gt;”Build System”-&gt;是否为”Python+ Virtualenv”，如果不是，则选用这个再Ctrl+B就是在虚拟环境中编译了! ubuntu下sublime默认情况下好像不能输入中文，需要用下面命令就可以完美支持中文输入： 1234sudo apt-get update &amp;&amp; sudo apt-get upgradegit clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix./sublime-imfix 转自CV_YOU的博客 完美解决Sublime无法输入中文问题 截图好像有点问题，菜单栏都没有截到，用到的三个分别为“项目(Project)”，“首选项(Preferences)”，“帮助(Help)”","categories":[],"tags":[{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"python pywin32 PyUserInput实现自动化脚本","slug":"python-win32api-win32gui-win32con-PyUserInput实现自动化脚本","date":"2018-08-31T11:43:00.000Z","updated":"2018-08-31T11:56:56.677Z","comments":true,"path":"python-win32api-win32gui-win32con-PyUserInput实现自动化脚本.html","link":"","permalink":"https://nymrli.top/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本.html","excerpt":"","text":"pywin32用spy++工具查找到句柄，再结合PyUserInput就能很好地实现自动化脚本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import win32guiimport win32conimport win32api# 从顶层窗口向下搜索主窗口，无法搜索子窗口# FindWindow(lpClassName=None, lpWindowName=None) 窗口类名 窗口标题名handle = win32gui.FindWindow(\"Notepad\", None) # 获取窗口位置left, top, right, bottom = win32gui.GetWindowRect(handle)#获取某个句柄的类名和标题title = win32gui.GetWindowText(handle) clsname = win32gui.GetClassName(handle)# 打印句柄# 十进制print(handle)# 十六进制print(\"%x\" %(handle) )# 搜索子窗口# 枚举子窗口hwndChildList = [] win32gui.EnumChildWindows(handle, lambda hwnd, param: param.append(hwnd), hwndChildList)# FindWindowEx(hwndParent=0, hwndChildAfter=0, lpszClass=None, lpszWindow=None) # 父窗口句柄 若不为0，则按照z-index的顺序从hwndChildAfter向后开始搜索子窗体，否则从第一个子窗体开始搜索。 子窗口类名 子窗口标题subHandle = win32gui.FindWindowEx(handle, 0, \"EDIT\", None)# 获得窗口的菜单句柄menuHandle = win32gui.GetMenu(subHandle)# 获得子菜单或下拉菜单句柄 # 参数：菜单句柄 子菜单索引号subMenuHandle = win32gui.GetSubMenu(menuHandle, 0)# 获得菜单项中的的标志符，注意，分隔符是被编入索引的 # 参数：子菜单句柄 项目索引号 menuItemHandle = win32gui.GetMenuItemID(subMenuHandle, 0)# 发送消息，加入消息队列，无返回 # 参数：句柄 消息类型 WParam IParamwin32gui.postMessage(subHandle, win32con.WM_COMMAND, menuItemHandle, 0)# wParam的定义是32位整型，high word就是他的31至16位，low word是它的15至0位。# 当参数超过两个，wParam和lParam不够用时，可以将wParam就给拆成两个int16来使用。# 这种时候在python里记得用把HIWORD的常数向左移16位，再加LOWORD，即wParam = HIWORD&lt;&lt;16+LOWORD。# 下选框内容更改# 参数：下选框句柄； 消息内容； #参数下选框的哪一个item，以0起始的待选选项的索引；如果该值为-1，将从组合框列表中删除当前选项，并使当前选项为空；# 参数CB_Handle为下选框句柄，PCB_handle下选框父窗口句柄if win32api.SendMessage(CB_handle, win32con.CB_SETCURSEL, 1, 0) == 1:# 下选框的父窗口命令# 参数：父窗口句柄； 命令； # 参数：WParam：高位表示类型，低位表示内容；参数IParam，下选框句柄# CBN_SELENDOK当用户选择了有效的列表项时发送，提示父窗体处理用户的选择。 LOWORD为组合框的ID. HIWORD为CBN_SELENDOK的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x90000, CB_handle) # CBN_SELCHANGE当用户更改了列表项的选择时发送，不论用户是通过鼠标选择或是通过方向键选择都会发送此通知。LOWORD为组合框的ID. HIWORD为CBN_SELCHANGE的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x10000, CB_handle) # 设置文本框内容，等窗口处理完毕后返回true。中文需编码成gbk # 参数：句柄；消息类型；# 参数WParam，无需使用； # 参数IParam，要设置的内容，字符串win32api.SendMessage(handle, win32con.WM_SETTEXT, 0, os.path.abspath(fgFilePath).encode('gbk'))# 控件点击确定,处理消息后返回0# 参数:窗口句柄; 消息类型; 参数WParam HIWORD为0（未使用），LOWORD为控件的ID; 参数IParam 0（未使用）,确定控件的句柄win32api.SendMessage(Mhandle, win32con.WM_COMMAND, 1, confirmBTN_handle)# 获取窗口文本不含截尾空字符的长度# 参数：窗口句柄； 消息类型； 参数WParam； 参数IParambufSize = win32api.SendMessage(subHandle, win32con.WM_GETTEXTLENGTH, 0, 0) +1# 利用api生成BufferstrBuf = win32gui.PyMakeBuffer(bufSize)print(strBuf)# 发送消息获取文本内容# 参数：窗口句柄； 消息类型；文本大小； 存储位置length = win32gui.SendMessage(subHandle, win32con.WM_GETTEXT, bufSize, strBuf)# 反向内容，转为字符串# text = str(strBuf[:-1])address, length = win32gui.PyGetBufferAddressAndLen(strBuf) text = win32gui.PyGetString(address, length) # print('text: ', text)# 鼠标单击事件#鼠标定位到(30,50)win32api.SetCursorPos([30,150])#执行左单键击，若需要双击则延时几毫秒再点击一次即可win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP | win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)#右键单击win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP | win32con.MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0)def click1(x,y): #第一种 win32api.SetCursorPos((x,y)) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,0,0) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,0,0)def click2(x,y): #第二种 ctypes.windll.user32.SetCursorPos(x,y) ctypes.windll.user32.mouse_event(2,0,0,0,0) ctypes.windll.user32.mouse_event(4,0,0,0,0)def click_it(pos): #第三种 handle= win32gui.WindowFromPoint(pos) client_pos =win32gui.ScreenToClient(handle,pos) tmp=win32api.MAKELONG(client_pos[0],client_pos[1]) win32gui.SendMessage(handle, win32con.WM_ACTIVATE,win32con.WA_ACTIVE,0) win32gui.SendMessage(handle, win32con.WM_LBUTTONDOWN,win32con.MK_LBUTTON,tmp) win32gui.SendMessage(handle, win32con.WM_LBUTTONUP,win32con.MK_LBUTTON,tmp)# 发送回车win32api.keybd_event(13,0,0,0)win32api.keybd_event(13,0,win32con.KEYEVENTF_KEYUP,0)# 关闭窗口win32gui.PostMessage(win32lib.findWindow(classname, titlename), win32con.WM_CLOSE, 0, 0)# 检查窗口是否最小化，如果是最大化if(win32gui.IsIconic(hwnd)):# win32gui.ShowWindow(hwnd, win32con.SW_SHOWNORMAL) win32gui.ShowWindow(hwnd, 8) sleep(0.5)# SW_HIDE：隐藏窗口并激活其他窗口。nCmdShow=0。# SW_MAXIMIZE：最大化指定的窗口。nCmdShow=3。# SW_MINIMIZE：最小化指定的窗口并且激活在Z序中的下一个顶层窗口。nCmdShow=6。# SW_RESTORE：激活并显示窗口。如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置。在恢复最小化窗口时，应用程序应该指定这个标志。nCmdShow=9。# SW_SHOW：在窗口原来的位置以原来的尺寸激活和显示窗口。nCmdShow=5。# SW_SHOWDEFAULT：依据在STARTUPINFO结构中指定的SW_FLAG标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递给CreateProcess函数的。nCmdShow=10。# SW_SHOWMAXIMIZED：激活窗口并将其最大化。nCmdShow=3。# SW_SHOWMINIMIZED：激活窗口并将其最小化。nCmdShow=2。# SW_SHOWMINNOACTIVE：窗口最小化，激活窗口仍然维持激活状态。nCmdShow=7。# SW_SHOWNA：以窗口原来的状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=8。# SW_SHOWNOACTIVATE：以窗口最近一次的大小和状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=4。# SW_SHOWNORMAL：激活并显示一个窗口。如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小。应用程序在第一次显示窗口的时候应该指定此标志。nCmdShow=1。 感谢python win32api win32gui win32con 窗口句柄 发送消息 常用方法 键盘输入，代码主要来自于他 ▲.需要注意在windows和mac下接口参数可能有所不同。win32虽然也可控制键盘，但不如使用PyUserInput的方便。安装PyUserInput教程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pymouse import PyMousefrom pykeyboard import PyKeyboard#实例化m = PyMouse() k = PyKeyboard()x_dim, y_dim = m.screen_size()# 鼠标点击 参数:x,y,button=1(左键)、2(右键)、3(中间),次数m.click(x_dim, y_dim, button=1,n=1) # 键盘输入 参数:str,间隔k.type_string('Hello, World!',interval=0)# 按住一个键k.press_key('H')# 松开一个键k.release_key('H')# 相当于===&gt;按住并松开，tap一个键k.tap_key('e')# tap支持重复的间歇点击键,参数:str,次数,间隔k.tap_key('l',n=2,interval=5) #创建组合键===&gt;press_key和release_key结合使用k.press_key(k.alt_key)k.tap_key(k.tab_key)k.release_key(k.alt_key)# 特殊功能键k.tap_key(k.function_keys[5]) # Tap F5k.tap_key(k.numpad_keys['Home']) # Tap 'Home' on the numpadk.tap_key(k.numpad_keys[5], n=3) # Tap 5 on the numpad, thrice# Mac系统按键k.press_keys(['Command','shift','3'])# Windows系统按键k.press_keys([k.windows_l_key,'d'])其中pymouse的PyMouseEvent和pykeyboard的PyKeyboardEvent还可用于监听鼠标和键盘事件的输入class Clickonacci(PyMouseEvent): def __init__(self): PyMouseEvent.__init__(self) self.fibo = fibo() def click(self, x, y, button, press): '''Print Fibonacci numbers when the left click is pressed.''' if button == 1: if press: print('Press times:%d'.format(press)) else: # Exit if any other mouse button used self.stop()C = Clickonacci()C.run()class TapRecord(PyKeyboardEvent): def __init__(self): PyKeyboardEvent.__init__(self) def tap(self, keycode, character, press): print(time.time(), keycode, character, press)t = TapRecord()t.run()#这些对象是一个架构用于监听鼠标和键盘的输入；他们除了监听之外不会做任何事，需要继承重构他们#PyKeyboardEvent为编写完成，所以这里是一个继承PyMouseEvent的例子：","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"Hello 搭建Hexo博客","slug":"hello-hexo","date":"2018-08-30T13:14:27.000Z","updated":"2018-09-01T10:33:39.636Z","comments":true,"path":"hello-hexo.html","link":"","permalink":"https://nymrli.top/hello-hexo.html","excerpt":"","text":"电脑环境是Windows，安装好git后，所有搭建操作均在git bash内完成 1.需要安装git, node.js, npm 注:第一次安装Git会让配置user信息 123&gt; $git config --global user.name \"yourname\" #（yourname是git的用户名）&gt; $git config --global user.email \"youremail\"）&gt; 2.使用npm安装hexo： npm install -g hexo3.创建hexo文件夹，并单击鼠标右键选择 Git bash：(我的创建路径是：E:\\hexo）4.在刚刚打开的git bash命令框中操作：1234$hexo init #hexo 会自动创建网站所需要的文件$npm install #安装依赖包$hexo generate # 等价于hexo g$hexo server #现在可以用127.0.0.1:4000访问hexo默认的hello world界面,等价于hexo s 5.部署到github (https://github.com/)， 首先注册登录,然后创建页面仓库，Repository name 命名必须是 youname.github.io ，（youname 就是你注册时候用的name） ssh-keygen -t rsa -C &quot;email&quot; #生成ssh密钥，按三次回车键，密码为空,这边会生成id_rsa和_rsa.pub文件，打开id_rsa.pub，复制全文添加到GitHub 的Add SSH key中。 最后可以验证一下ssh -T git@github.com,看出现的是不是Hi &quot;Yourname&quot;如果出现了你的github用户名,则成功了 6.下载Hexo主题 $git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载hexo的yilia 模板到自己的文件目录下 打开项目目录下的_config.yml文件，更改theme：yilia ▲注意: _config.yml文件中配置时:后面都要加空格,与:隔开 7.开启评论功能：使用gitment$npm install gitment --save #安装gitment 然后在 https://github.com/settings/applications/new 进行注册，获取Client ID和Client Secret ▲注意:其中Authorization callback URL是个坑: 这一项不能乱填,不让就不能&quot;初始化评论&quot;.. 应该怎么填呢? 如果你绑定了自己的域名就直接写自己的域名: https://nymrli.top/ 如果没有的话才填写http://Freedomisgood.github.io,否则会一直弹回博客首页,而不能”初始化评论”或者”发表评论” 其中的原因就在于,既可以通过www.nymrli.top解析，也可通过nymrli.top解析,还可以通http://Freedomisgood.github.io解析,而Authorization callback URL只能写一个.(最终解析到的网站)…===&gt;就是nymrli.top △.感谢IsResultXaL提供的思路 打开themes/yilia目录下的_config.yml文件进行修改并保存： 再次生成网站,提交网站:hexo d -g就可以输入网址:https://yourname.github.io打开你的博客了 8.显示文章摘要图片 1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在hexo目录下打开git Bsh或者power Shell,npm install hexo-asset-image --save安装插件 再运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 1![你想输入的替代文字](xxxx/图片名.jpg) ▲ .之前一直失败,原因在于,我写图片链接的时候是直接拖动图片到编辑器中的,路径为![v2-代替文字](E:\\hexo\\source\\_posts\\xxxx\\图片名.jpg),后来一直错误,无法正常显示后，发现只需要写成![代替文字](xxxx\\图片名.jpg)即可.. 文章总体框架:12345678910---layout: phototitle: Hello Hexodate: 2018-08-30 21:14:27tags: - hexo---![代替文字](xxxx\\图片名.jpg)&lt;!--more--&gt;正文 →推一个不错的文章Hexo+Coding+Github部署个人博客Error全集,如果出现未能解决的问题,希望能从这篇文章略微得到启发.","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"hexo","slug":"hexo","permalink":"https://nymrli.top/tags/hexo/"}]},{"title":"Python字典基本操作介绍","slug":"Python字典基本操作介绍","date":"2018-08-30T13:14:27.000Z","updated":"2018-10-27T01:57:02.042Z","comments":true,"path":"Python字典基本操作介绍.html","link":"","permalink":"https://nymrli.top/Python字典基本操作介绍.html","excerpt":"","text":"创建字典 info={} info=dict() 初始化字典法一123key = 'name'info = &#123; key :'cold'&#125;==&#123;'name':'cold'&#125; 法二12info = dict(key = 'cold')==&#123;'key':'cold'&#125; 法三1#还有可以使用dict(zip(a,b))其中a,b都是列表,会生成以A中元素为键,B中元素为值的字典 插入新的键值对(更新) info.update(name=’cold’, blog=’www.linuxzen.com&#39;) 在字典有没有k这个键时可以使用dict.setdefault(key,value) 还可以使用dict(var = value)其中var可以是变量,也可以不是,注意不用加 或是_dict[‘xxx’]=’yyy’ 获得键值 确定存在的情况下- info.get(‘xxx’) info[‘xxx’] 不确定是否存在 info.get(‘xxx’) 遍历字典 获得key,再通过key来获得valuefor key in dicprint(%d,%d%(key,_dict[key])) 使用dict.items()for key,value in dic.items()print ‘key is %s,value is %s’%(key,value) 字典删除del(info[&#39;xxx&#39;]) or del info[&#39;xxx&#39;]","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]}]}