<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>果粒橙的博客</title>
  
  <subtitle>别装作很努力，结局不会陪你演戏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nymrli.top/"/>
  <updated>2019-08-22T12:40:14.238Z</updated>
  <id>https://nymrli.top/</id>
  
  <author>
    <name>果粒橙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法设计与分析C_概念点区分</title>
    <link href="https://nymrli.top/2019/08/22/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90C-%E6%A6%82%E5%BF%B5%E7%82%B9%E5%8C%BA%E5%88%86/"/>
    <id>https://nymrli.top/2019/08/22/算法设计与分析C-概念点区分/</id>
    <published>2019-08-22T12:39:29.000Z</published>
    <updated>2019-08-22T12:40:14.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法设计与分析C"><a href="#算法设计与分析C" class="headerlink" title="算法设计与分析C"></a>算法设计与分析C</h1><h2 id="算法5-分治法"><a href="#算法5-分治法" class="headerlink" title="算法5_分治法"></a>算法5_分治法</h2><p>分治法——将一个复杂的问题分解成若干个规模较小、相互独立，但类型相同的子问题求解；然后再将各子问题的解组合成原始问题的一个完整答案，这样的问题求解策略就叫分治法。</p><p> 分治法所能解决的问题一般具有以下几个特征：<br>该问题的规模缩小到一定的程度就可以容易地解决；<br>该问题可以分解为若干个规模较小的相同问题；<br>利用该问题分解出的子问题的解可以合并为该问题的解；<br>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p><p>反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。<br>由分治法产生的子问题往往是原问题的较小模式。<br>直接或间接地调用自身的算法称为：递归算法。用函数自身给出定义的函数称为：递归函数。<br>分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p><h2 id="算法6-贪心法"><a href="#算法6-贪心法" class="headerlink" title="算法6_贪心法"></a>算法6_贪心法</h2><ul><li>可行解<pre><code>——问题给定某些约束条件，满足约束条件的问题解，即称为可行解。</code></pre></li><li>最优解<pre><code>——问题给出目标函数衡量可行解的好坏，使目标函数取最大（或最小）值的可行解称为最优解。</code></pre></li></ul><p><strong>1.最优子结构性质：</strong></p><p>一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。<br>问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。 </p><p>2.<strong>贪心选择性质</strong></p><p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。<br>这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</p><h2 id="算法7-动态规划法"><a href="#算法7-动态规划法" class="headerlink" title="算法7_动态规划法"></a>算法7_动态规划法</h2><p>（1）<strong>子问题重叠性质</strong><br>    （递归算法求解问题时）每次产生的子问题并不总是新问题，有些子问题被反复计算多次，这种性质称为子问题重叠性质。</p><p>动态规划算法对每一个子问题只解一次，而后将其解保存在一个表格（通常用二维数组）中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。<br>通常不同的子问题个数随问题的大小呈多项式增长。因此用动态规划算法只需要多项式级时间，从而获得较高的解题效率。</p><p>（2）<strong>最优子结构性质</strong>——用动态规划法求解的前提。<br>    当一个问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</p><p>一个问题的活动过程可以分为若干个阶段，每个阶段可包含一个或多个状态，从初始阶段的初始状态出发做出每个阶段的决策，形成一个决策序列。<br>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。</p><h3 id="用动态规划算法求解问题的步骤："><a href="#用动态规划算法求解问题的步骤：" class="headerlink" title="用动态规划算法求解问题的步骤："></a>用动态规划算法求解问题的步骤：</h3><blockquote><p>1、找出最优解的性质，并刻划其结构特征；</p><p>2、递归地定义最优解值；</p><p>3、自底向上求最优解值；</p><p>4、根据计算最优解值时得到的信息构造一个最优解（此步只在要求得到最优解时才需要做） 。</p></blockquote><p>动态规划法是一种求解最优化问题的重要算法策略。</p><p>利用最优子结构性质及所获得的递推关系式（较小子问题最优解与较大子问题最优解之间存在的数值关系）去求取最优解，可以使计算量较之穷举法急剧减少。</p><blockquote><p>共同点：<br>将待求解的问题分解成若干子问题，先求解子问题，然后再从这些子问题的解得到原问题的解。<br>不同点：<br>1、适合于用动态规划法求解的问题，分解得到的各子问题往往不是相互独立的；而分治法中子问题相互独立。</p><p>2、动态规划法用表保存已求解过的子问题的解，再次碰到同样的子问题时不必重新求解，而只需查询答案，故可获得多项式级时间复杂度，效率较高；而分治法中对于每次出现的子问题均求解，导致同样的子问题被反复求解，故产生指数增长的时间复杂度，效率较低。</p></blockquote><h3 id="备忘录方法与动态规划法比较"><a href="#备忘录方法与动态规划法比较" class="headerlink" title="备忘录方法与动态规划法比较"></a>备忘录方法与动态规划法比较</h3><blockquote><p>1、与动态规划法的共同点：用一个表格来保存已求解的子问题的答案，使下次需要解此子问题时，只简单地查看答案，不重新计算。</p><p>2、与动态规划法的区别：备忘录的递归方式是自顶向下，而动态规划法的递归方式是自底向上。</p></blockquote><h3 id="如何选择使用动态规划法或备忘录法？"><a href="#如何选择使用动态规划法或备忘录法？" class="headerlink" title="如何选择使用动态规划法或备忘录法？"></a><strong>如何选择使用动态规划法或备忘录法？</strong></h3><blockquote><p>★当一个问题的所有子问题都至少要解一次时，选用动态规划法较好，此时没有任何多余的计算，还可利用规则的表格存取方式，减少时间和空间需求。</p><p>★当一个问题只有部分子问题需要求解时，选用备忘录法较好，它只解那些确实需要求解的子问题。</p></blockquote><h3 id="备忘录方法与递归方法比较"><a href="#备忘录方法与递归方法比较" class="headerlink" title="备忘录方法与递归方法比较"></a>备忘录方法与递归方法比较</h3><blockquote><p>1、与递归方法的共同点：递归方式均为自顶向下</p><p>2、与递归方法的区别：备忘录方法用一个表格来保存已求解的子问题的答案，使下次需要解此子问题时，只简单地查看答案，不重新计算；而递归方法在每次遇到子问题都要重新计算。</p></blockquote><blockquote><p><strong>共同点：</strong><br> 都是求解最优化问题；都具有最优子结构性质。<br><strong>不同点：</strong><br>1、求解方式不同：<br> 动态规划法：自底向上；<br> 贪心法：自顶向下。以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为一个规模更小的子问题。</p><p>2、对子问题的依赖不同：<br> 动态规划法：依赖于各子问题的解。只有在解出相关子问题后,才能作出选择；应使各子问题最优，才能保证整体最优；<br> 贪心法：不依赖于子问题的解。仅在当前状态下作出最好选择，即局部最优选择。        </p></blockquote><h2 id="算法8-回溯法"><a href="#算法8-回溯法" class="headerlink" title="算法8_回溯法"></a>算法8_回溯法</h2><p>回溯法是比贪心法和动态规划法更一般的方法。<br>解为n-元组(x0,x1,…,xn-1)形式。<br>通过搜索状态空间树来求问题的可行解（满足约束条件）或最优解（使目标函数取最大或最小值）。<br>使用约束函数和限界函数来压缩需要实际生成的状态空间树的结点数。<br>通常情况下，回溯法是为了找出满足约束条件的所有可行解。</p><ul><li>显式约束：规定每个xi取值的约束条件。<br>（显式约束规定了问题的候选解集——解空间）</li><li>隐式约束：给出了判定一个候选解是否为可行解的条件。为满足问题的解而对不同分量之间施加的约束。</li><li>目标函数（代价函数）：衡量每个可行解的优劣，使目标函数取最大（或最小）值的可行解为问题的最优解。<br>状态空间树：描述问题解空间的树形结构。</li></ul><p>树中每个结点称为一个问题状态；<br>若从根到树中某个状态的路径代表一个候选解元组，则该状态为解状态；<br>若从根到某个解状态的路径代表一个可行解元组，则该解状态为答案状态；<br>如果求解的是最优化问题，还要用目标函数衡量每个答案结点，找出其中目标函数取最优值的最优答案结点。</p><blockquote><p>回溯法与穷举搜索不同：回溯法使用约束函数，剪去那些可以断定不含答案状态的子树，从而提高算法效率。回溯法适用于解一些组合数相当大的问题。<br>事实上，状态空间树并不需要事先生成，而只需在求解的过程中，随着搜索算法的进展，逐个生成状态空间树的问题状态结点。</p></blockquote><p>常用的剪枝函数：<br>用约束函数剪去已知不含答案状态（可行解）的子树；<br>用限界函数剪去得不到最优答案结点（最优解）的子树。</p><h3 id="蒙特卡洛估计"><a href="#蒙特卡洛估计" class="headerlink" title="蒙特卡洛估计"></a>蒙特卡洛估计</h3><p>用蒙特卡罗（Monte Carlo）方法估计回溯法处理实例时，实际生成的结点数：</p><p>在状态空间树中,从根开始随机选择一条路径(x0,x1,…,xn-1);<br>假定搜索树中这条随机选出的路径上，代表部分向量(x0,x1,…,xk-1)的结点X处不受限制的孩子数目,和其他路径上与X同层的的结点不受限制的孩子数目一样，都是mk;<br>则可以估计整个状态空间树上实际生成的结点数为: <code>m=1+m0+m0m1+m0m1m2+......</code></p><h2 id="算法9-分枝限界法"><a href="#算法9-分枝限界法" class="headerlink" title="算法9_分枝限界法"></a>算法9_分枝限界法</h2><p>采用广度优先产生状态空间树的结点，并使用剪枝函数的方法称为——分枝限界法。<br>分枝限界法的基本做法是：<br>    以<strong>广度优先</strong>的方式搜索问题的状态空间树。每一个活结点只有一次机会成为扩展结点。<br>    按照广度优先的原则，活结点一旦成为扩展结点（E结点）R后，就依次生成它的所有孩子结点。在这些孩子结点中，导致不可行解或导致非最优解的孩子结点被舍弃，其余孩子结点被一一加入活结点表中。<br>    此后，R自身成为死结点，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。<br>    这个过程一直持续到找到所需的解或活结点表为空时为止。 </p><blockquote><p>一、<strong>分枝限界法与回溯法的共同点</strong><br> 都是在问题的状态空间树上搜索问题解的算法,都通过活结点表实现。都用约束函数剪去不含答案结点的分枝,用限界函数剪去不含最优解的分枝.<br>二、<strong>分枝限界法与回溯法的区别</strong><br>（1）求解目标不同：回溯法的求解目标是找出解空间树中满足约束条件的所有可行解；而分枝限界法的求解目标则是找出满足约束条件的一个可行解，或某种意义下的最优解。</p><p>（2）搜索方式不同：回溯法以深度优先的方式搜索解空间树，而分枝限界法则以广度优先的方式搜索解空间树。</p><p>（3）对当前扩展结点的扩展方式不同：回溯法中的每个活结点可能多次成为当前扩展结点，纵深方向扩展其一个儿子，然后再回溯后扩展其他儿子；而分枝限界法中每一个活结点只有一次机会成为扩展结点，一次产生所有孩子结点，自身成为死结点，之后无需再返回该结点处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法设计与分析C&quot;&gt;&lt;a href=&quot;#算法设计与分析C&quot; class=&quot;headerlink&quot; title=&quot;算法设计与分析C&quot;&gt;&lt;/a&gt;算法设计与分析C&lt;/h1&gt;&lt;h2 id=&quot;算法5-分治法&quot;&gt;&lt;a href=&quot;#算法5-分治法&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://nymrli.top/tags/ACM/"/>
    
      <category term="NJUPT" scheme="https://nymrli.top/tags/NJUPT/"/>
    
      <category term="学业" scheme="https://nymrli.top/tags/%E5%AD%A6%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>通信企业管理_线上考试</title>
    <link href="https://nymrli.top/2019/08/22/%E9%80%9A%E4%BF%A1%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86-%E7%BA%BF%E4%B8%8A%E8%80%83%E8%AF%95/"/>
    <id>https://nymrli.top/2019/08/22/通信企业管理-线上考试/</id>
    <published>2019-08-22T12:37:49.000Z</published>
    <updated>2019-08-22T12:38:32.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通信企业管理"><a href="#通信企业管理" class="headerlink" title="通信企业管理"></a>通信企业管理</h1><blockquote><p>看清题目和选项</p></blockquote><h3 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h3><p>1单选(2分)</p><p>在总公司领导下设立多个分支，各分支有各自独立的产品和市场，实行独立核算，经营管理上拥有自主性和独立性。这是（ A   ）组织结构。</p><ul><li>A.事业部型</li><li>B.矩阵型</li><li>C.职能型</li><li>D.直线型</li></ul><p>2单选(2分)</p><p>按照最新版《中华人民共和国公司法》规定，股份有限公司的发起人最多不超过（    C ）。</p><ul><li>A.100人</li><li>B.50人</li><li>C.200人</li><li>D.150人</li></ul><p>3单选(2分)</p><p>工作或行动之前预先拟定具体的工作内容和步骤是管理的（  D  ）职能。</p><ul><li>A.组织职能</li><li>B.控制职能</li><li>C.领导职能</li><li>D.计划职能</li></ul><p>4单选(2分)</p><p>提出“14项管理原则”的是（C  ）。</p><ul><li>A.巴纳德</li><li>B.梅奥</li><li>C.法约尔</li><li>D.泰勒</li></ul><p>5单选(2分)</p><p>企业战略是关于企业在激烈的竞争中如何与竞争对手相抗衡、同时也是针对来自多方面的冲击、压力、威胁和困难迎击这些挑战的行动方案。这体现了企业战略的（  D  ）。</p><ul><li>A.长远性</li><li>B.协同性</li><li>C.全局性</li><li>D.抗争性</li></ul><p>6单选(2分)</p><p>在对企业总体环境分析中，人们生活方式的变化属于（ B   ）。</p><ul><li>A.经济环境</li><li>B.社会环境</li><li>C.政治环境</li><li>D.技术环境</li></ul><p>7单选(2分)</p><p>为了增强企业实力而与同行业企业进行联合的一种战略称为（ C   ）。</p><ul><li>A.复合多样化</li><li>B.纵向一体化</li><li>C.横向一体化</li><li>D.同心多样化</li></ul><p>8单选(2分)</p><p>在流程型生产过程中，物料是均匀、连续地按一定工艺顺序运动的。它的特点是工艺过程的（ A   ）。</p><ul><li>A.连续性</li><li>B.稳定性</li><li>C.离散性</li><li>D.流动性</li></ul><p>9单选(2分)</p><p>服务是一种活动，在消费之前通常无法为顾客感觉、体验和评价，这体现了服务的（  B   ）。</p><ul><li>A.劳动力密集性</li><li>B.无形性</li><li>C.异质性</li><li>D.易逝性</li></ul><p>10单选(2分)</p><p>尽管不同产品具有不同的外部质量特征，但可以用（ B ）来概括产品质量。</p><ul><li>A.安全性</li><li>B.适用性</li><li>C.经济性</li><li>D.可靠性</li></ul><p>11单选(2分)</p><p>质量管理经历的第四阶段是（  C   ）。</p><ul><li>A.统计质量控制阶段</li><li>B.质量检验阶段 </li><li>C. ISO9000质量管理体系认证阶段</li><li>D.全面质量管理阶段</li></ul><p>12单选(2分)</p><p>下面（ A   ）不是朱兰三部曲中所要求的内容。</p><ul><li>A.质量检验</li><li>B.质量计划</li><li>C.质量提高</li><li>D.质量控制</li></ul><p>13单选(2分)</p><p>职业生涯规划属于 人力资源管理的（ C  ）方面的内容。</p><ul><li>A.用人</li><li>B.进人</li><li>C.育人</li><li>D.留人</li></ul><p>14单选(2分)</p><p>一般来说，我们可以从工作业绩、工作能力和工作态度3个方面来评价员工的绩效体现了绩效的（  C   ）特征。</p><ul><li>A.动态性</li><li>B.多因性</li><li>C.多维性</li><li>D.稳定性</li></ul><p>15单选(2分)</p><p>薪酬中属于间接经济性报酬的是（ D  ）。</p><ul><li>A.津贴</li><li>B.基本工资</li><li>C.奖金</li><li>D.基本社会保险</li></ul><p>16单选(2分)</p><p>企业财务管理的基本内容包括：①资金筹集管理；②成本费用管理；③投资管理；④利润（收支差额）及其分配管理；⑤物资管理；中的（ A   ）。</p><p>A.①②③④<br>B.①③④⑤<br>C.①②④⑤<br>D.①②③④⑤</p><p>17单选(2分)</p><p>以下不属于企业的筹资方式的是（ D   ）。</p><ul><li>A.买方信贷</li><li>B.发行股票</li><li>C.银行贷款</li><li>D.来自个人的闲散资金</li></ul><p>18单选(2分)</p><p>某大学生在4年学习期间，每年年初从银行贷款3000元用于支付学费，若按年利率5%计复利，第4年末需要一次性归还全部本息（  D  ）元。</p><ul><li>A.12000</li><li>B.12930.4</li><li>C.16576.9</li><li>D.13576.9</li></ul><p>19单选(2分)</p><p>为了保证产品达到规定的功能和技术要求所必需的材料消耗是（A   ）。</p><ul><li>A.有效性消耗</li><li>B.工艺性消耗</li><li>C.非工艺性消耗</li><li>D.材料消耗</li></ul><p>20单选(2分)</p><p>设备在使用或闲置过程中，由于新技术出现而引起的设备价值损失，称为（ A  ）。</p><ul><li>A.无形磨损</li><li>B.价值磨损</li><li>C.技术磨损</li><li>D.使用磨损</li></ul><p>21单选(2分)</p><p>企业在相邻两批物资进厂间隔期内，为保证生产正常进行所必需的、经济合理的储备数量是（ D  ）。</p><ul><li>A.保险储备定额</li><li>B.物资储备定额</li><li>C.季节性储备定额</li><li>D.经常储备定额</li></ul><p>22单选(2分)</p><p>快速渗透策略是推广处于生命周期（C   ）产品的企业，可以采用的市场营销策略。</p><ul><li>A.衰退期</li><li>B.成长期</li><li>C.引入期</li><li>D.成熟期</li></ul><p>23单选(2分)</p><p>以下不属于促销组合中的促销工具的是（ D ）。</p><ul><li>A.销售促进</li><li>B.公关宣传</li><li>C.广告</li><li>D.尾数定价</li></ul><p>24单选(2分)</p><p>营销人员可以通过接近和影响消费者群体中的意见领袖的方式来开展营销活动，这体现了影响消费者购买的主要因素中的（ D  ）的作用。</p><ul><li>A.经济因素</li><li>B.个人因素</li><li>C.社会文化因素</li><li>D.心理因素</li></ul><p>25单选(2分)</p><p>品种繁多，每种仅生产一件，生产重复程度低是以下哪种生产方式的特点（ B ）。</p><ul><li>A.批量生产</li><li>B.单件生产</li><li>C.大量生产</li><li>D.备货型生产</li></ul><h3 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h3><p>26判断(2分)<br>个体企业是个人出资兴办的企业，具有法人资格。</p><ul><li>错</li></ul><p>27判断(2分)<br>在管理过程中，只有把人的要素作为根本，才能协调好其他要素，实现高水平的管理。</p><ul><li>对</li></ul><p>28判断(2分)<br>企业不仅是经济性组织，也是社会性组织。</p><ul><li>对</li></ul><p>29判断(2分)<br>梅奥认为，影响人们积极性的因素除了物质方面外，还有社会与心理方面。</p><ul><li>对</li></ul><p>30判断(2分)<br>企业提供的产品服务标新立异，满足顾客特殊的需求，形成竞争优势的战略是差异化战略。</p><ul><li>对</li></ul><p>31判断(2分)<br>高质量的社会物流系统属于战略制定中企业的外部资源。</p><ul><li>对</li></ul><p>32判断(2分)<br>企业价值活动中，技术开发属于基本活动。</p><ul><li>错</li></ul><p>33判断(2分)<br>企业生产系统是由输入、转化、输出、反馈四部分构成，其核心是输出。</p><ul><li>错</li></ul><p>34判断(2分)<br>辅助生产部门主要是为基本生产和辅助生产服务的单位（如仓储、后勤）。</p><ul><li>错</li></ul><p>35判断(2分)<br>对于顾客来说，服务是发生在服务设施环境中的经历，如果服务设施的设计符合消费者的需要，就可以提高服务质量。</p><ul><li>对</li></ul><p>36判断(2分)<br>ISO9000族标准是进行国际贸易时强制要求必须进行的标准认证。</p><ul><li>错</li></ul><p>37判断(2分)<br>质量体系认证中使用的基本标准是产品技术标准。</p><ul><li>错</li></ul><p>38判断(2分)<br>质量管理的目标就是提高产品质量，产品质量越高越好。</p><ul><li>错</li></ul><p>39判断(2分)<br>广义的人力资源概念是指能够推动国民经济和社会发展的具有智力劳动和体力劳动能力的人的总和，包括数量和质量两个方面。</p><ul><li>错</li></ul><p>40判断(2分)<br>工作说明书具体说明了工作的目的与任务、工作内容与特征、工作责任与权力、工作标准与要求、工作时间与地点等问题。</p><ul><li>错</li></ul><p>41判断(2分)<br>设定绩效目标时，管理者一般根据组织总体目标或上级部门的目标，围绕本部门业务重点或职责，制定本部门的工作目标计划，保证部门工作目标与组织的总体目标相一致。</p><ul><li>对</li></ul><p>42判断(2分)<br>企业的运营能力反映了企业资金周转状况，可以用成本费用净利率来衡量。</p><ul><li>错</li></ul><p>43判断(2分)<br>资本公积、盈余公积都属于企业权益资本的范畴。</p><ul><li>对</li></ul><p>44判断(2分)<br>盈亏平衡点是指技术方案的盈利和亏损在产量、单价、成本等方面的临界值。</p><ul><li>对</li></ul><p>45判断(2分)<br>在设备的自然寿命周期中，设备故障率随着使用的时间的延伸而越来越高。</p><ul><li>对</li></ul><p>46判断(2分)<br>设备更新改造时，不仅要考虑设备的自然寿命，还要考察技术寿命和经济寿命。</p><ul><li>对</li></ul><p>47判断(2分)<br>从价值形态上看，无论是有形磨损还是无形磨损都会引起设备价值的降低，因此我们要采取措施尽量减少各种类型的设备磨损。</p><ul><li>错</li></ul><p>48判断(2分)<br>关系营销就是利用亲属关系以及朋友关系来开展营销活动。</p><ul><li>错</li></ul><p>49判断(2分)<br>在目标市场中采用无差异的市场营销策略历来都不是一种明智的选择。</p><ul><li>错</li></ul><p>50判断(2分)<br>招徕定价是一种利用顾客心理因素来进行定价的策略。</p><ul><li>对</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通信企业管理&quot;&gt;&lt;a href=&quot;#通信企业管理&quot; class=&quot;headerlink&quot; title=&quot;通信企业管理&quot;&gt;&lt;/a&gt;通信企业管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;看清题目和选项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单选题&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="NJUPT" scheme="https://nymrli.top/tags/NJUPT/"/>
    
      <category term="学业" scheme="https://nymrli.top/tags/%E5%AD%A6%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s Encrypt安装配置nginx的SSL证书教程</title>
    <link href="https://nymrli.top/2019/08/22/Let-s-Encrypt%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6%E6%95%99%E7%A8%8B/"/>
    <id>https://nymrli.top/2019/08/22/Let-s-Encrypt安装配置SSL证书教程/</id>
    <published>2019-08-22T12:34:04.000Z</published>
    <updated>2019-08-22T12:36:34.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Let’s-Encrypt-安装配置nginx的SSL证书教程"><a href="#Let’s-Encrypt-安装配置nginx的SSL证书教程" class="headerlink" title="Let’s Encrypt 安装配置nginx的SSL证书教程"></a>Let’s Encrypt 安装配置nginx的SSL证书教程</h1><h2 id="使用cerbot生成证书"><a href="#使用cerbot生成证书" class="headerlink" title="使用cerbot生成证书)"></a><a href="[https://nymrli.top/2018/12/08/%E4%BD%BF%E7%94%A8Cerbot%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6%E5%8D%87%E7%BA%A7-http%E5%88%B0https/](https://nymrli.top/2018/12/08/使用Cerbot申请免费证书升级-http到https/">使用cerbot生成证书</a>)</h2><h3 id="安装Let’s-Encrypt"><a href="#安装Let’s-Encrypt" class="headerlink" title="安装Let’s Encrypt"></a>安装<a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a></h3><p>安装非常简单直接克隆就可以了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/letsencrypt/letsencrypt</span><br></pre></td></tr></table></figure></p><p>如果网速较慢（国外服务器应该快点）</p><p>1.可以登录<a href="https://github.com/letsencrypt/letsencrypt，下载后通过lrzsz传到云服务器上，再解压" target="_blank" rel="noopener">https://github.com/letsencrypt/letsencrypt，下载后通过lrzsz传到云服务器上，再解压</a></p><p>2.修改hosts</p><p><strong>查找域名对应的ip地址，并修改hosts文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">linuxidc@linuxidc:~/linuxidc.com$ nslookup github.global.ssl.fastly.Net</span><br><span class="line">Server:  127.0.0.53</span><br><span class="line">Address: 127.0.0.53<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name: github.global.ssl.fastly.Net</span><br><span class="line">Address: 151.101.229.194</span><br><span class="line"></span><br><span class="line">linuxidc@linuxidc:~/linuxidc.com$ nslookup github.com</span><br><span class="line">Server:  127.0.0.53</span><br><span class="line">Address: 127.0.0.53<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name: github.com</span><br><span class="line">Address: 13.229.188.59</span><br></pre></td></tr></table></figure><p><strong>然后修改hosts文件</strong></p><p><code>sudo vim /etc/hosts</code></p><p><strong>在hosts文件末尾添加两行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github.com 13.229.188.59</span><br><span class="line">github.global.ssl.fastly.Net 151.101.229.194</span><br></pre></td></tr></table></figure><p><strong>刷新DNS缓存</strong></p><p><code>sudo /etc/init.d/networking restart</code></p><h3 id="使用cerbot"><a href="#使用cerbot" class="headerlink" title="使用cerbot:"></a>使用cerbot:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> letsencrypt</span><br><span class="line"><span class="comment"># 根据自己的需求调整代码</span></span><br><span class="line">./certbot-auto certonly --standalone --email admin@example.com -d example.c</span><br></pre></td></tr></table></figure><p><strong>成功提示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IMPORTANT NOTES:</span><br><span class="line">Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/sast.nymrli.top/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/sast.nymrli.top/privkey.pem</span><br><span class="line">   Your cert will expire on 2019-02-08. To obtain a new or tweaked</span><br><span class="line">   version of this certificate in the future, simply run certbot-auto</span><br><span class="line">   again. To non-interactively renew *all* of your certificates, run</span><br><span class="line">   &quot;certbot-auto renew&quot;</span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br></pre></td></tr></table></figure><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx:"></a>配置<em>Nginx</em>:</h3><p>server 不再监听80端口，因为TLS要使用的是443端口，然后引入证书和key</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line"><span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line"><span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">75M</span>;</span><br><span class="line">    <span class="attribute">location</span> /static&#123;</span><br><span class="line">    <span class="attribute">alias</span> /home/mrli/Python_project/QQoauth_remote/static;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"><span class="attribute">include</span> uwsgi_params;</span><br><span class="line"><span class="attribute">uwsgi_pass</span> <span class="number">127.0.0.1:81</span>;</span><br><span class="line"><span class="attribute">uwsgi_param</span> UWSGI_SCRIPT app:app;   <span class="comment"># 启动flask的文件:Flask的实例</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">ssl_certificate</span>   /etc/letsencrypt/live/test.nymrli.top/fullchain.pem; </span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/test.nymrli.top/privkey.pem;   </span><br><span class="line">    <span class="comment">#前面生成的证书，改一下里面的域名就行，不建议更换路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重启Nginx："><a href="#重启Nginx：" class="headerlink" title="重启Nginx："></a>重启<em>Nginx</em>：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure><h2 id="使用acme-sh"><a href="#使用acme-sh" class="headerlink" title="使用acme.sh"></a>使用acme.sh</h2><h3 id="下载acme"><a href="#下载acme" class="headerlink" title="下载acme"></a>下载<strong>acme</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Neilpang/acme.sh.git</span><br><span class="line"><span class="built_in">cd</span> acme.sh</span><br><span class="line">./acme.sh --install</span><br></pre></td></tr></table></figure><p><strong>提示信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Thu Aug 22 19:58:00 CST 2019] It is recommended to install socat first.</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] We use socat for standalone server if you use standalone mode.</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] If you don&apos;t use standalone mode, just ignore this warning.</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] Installing to /home/mrli/.acme.sh</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] Installed to /home/mrli/.acme.sh/acme.sh</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] Installing alias to &apos;/home/mrli/.bashrc&apos;</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] OK, Close and reopen your terminal to start using acme.sh</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] Installing cron job</span><br><span class="line">1 0 * * * &quot;/home/mrli/.acme.sh&quot;/acme.sh --cron --home &quot;/home/mrli/.acme.sh&quot; &gt; /dev/null</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] Good, bash is found, so change the shebang to use bash as preferred.</span><br><span class="line">[Thu Aug 22 19:58:01 CST 2019] OK</span><br></pre></td></tr></table></figure><h3 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a><strong>生成证书</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> Ali_Key=<span class="string">"xxxx"</span></span><br><span class="line"><span class="built_in">export</span> Ali_Secret=<span class="string">"yyyy"</span></span><br><span class="line">acme.sh --issue --dns dns_ali -d nymrli.top -d *.nymrli.top</span><br></pre></td></tr></table></figure><p>注：这边的Key和secret需要找到你的阿里云API密钥，<a href="https://usercenter.console.aliyun.com/#/manage/ak" target="_blank" rel="noopener">Acesskey</a></p><p><img src="/2019/08/22/Let-s-Encrypt安装配置SSL证书教程/Users\10630\Documents\Let&#39;s Encrypt 安装配置 SSL 证书教程\accesskeys.png" alt="accesskeys"></p><p><strong>输出信息**</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[Thu Aug 22 20:01:53 CST 2019] Create account key ok.</span><br><span class="line">[Thu Aug 22 20:01:53 CST 2019] Registering account</span><br><span class="line">[Thu Aug 22 20:01:55 CST 2019] Registered</span><br><span class="line">[Thu Aug 22 20:01:55 CST 2019] ACCOUNT_THUMBPRINT=<span class="string">'YljrV0ThIsQxXtfdxksrd91g1fWvM9Btn9Dazt8OWyo'</span></span><br><span class="line">[Thu Aug 22 20:01:55 CST 2019] Creating domain key</span><br><span class="line">[Thu Aug 22 20:01:55 CST 2019] The domain key is here: /home/mrli/.acme.sh/nymrli.top/nymrli.top.key</span><br><span class="line">[Thu Aug 22 20:01:55 CST 2019] Multi domain=<span class="string">'DNS:nymrli.top,DNS:*.nymrli.top'</span></span><br><span class="line">[Thu Aug 22 20:01:55 CST 2019] Getting domain auth token <span class="keyword">for</span> each domain</span><br><span class="line">[Thu Aug 22 20:01:56 CST 2019] Getting webroot <span class="keyword">for</span> domain=<span class="string">'nymrli.top'</span></span><br><span class="line">[Thu Aug 22 20:01:56 CST 2019] Getting webroot <span class="keyword">for</span> domain=<span class="string">'*.nymrli.top'</span></span><br><span class="line">[Thu Aug 22 20:01:57 CST 2019] Adding txt value: NyNt2AxJ3OmW8s_wVn2C3CNN9_yT1o_v2o0MhmdUoTs <span class="keyword">for</span> domain:  _acme-challenge.nymrli.top</span><br><span class="line">[Thu Aug 22 20:01:59 CST 2019] The txt record is added: Success.</span><br><span class="line">[Thu Aug 22 20:01:59 CST 2019] Adding txt value: ADqtxSTlQ0DH7jHZzlP9UZB0dT9U2oVYSk_zTabYN3w <span class="keyword">for</span> domain:  _acme-challenge.nymrli.top</span><br><span class="line">[Thu Aug 22 20:02:01 CST 2019] The txt record is added: Success.</span><br><span class="line">[Thu Aug 22 20:02:01 CST 2019] Let<span class="string">'s check each dns records now. Sleep 20 seconds first.</span></span><br><span class="line"><span class="string">[Thu Aug 22 20:02:22 CST 2019] Checking nymrli.top for _acme-challenge.nymrli.top</span></span><br><span class="line"><span class="string">[Thu Aug 22 20:02:24 CST 2019] Domain nymrli.top '</span>_acme-challenge.nymrli.top<span class="string">' success.</span></span><br><span class="line"><span class="string">[Thu Aug 22 20:02:24 CST 2019] Checking nymrli.top for _acme-challenge.nymrli.top</span></span><br><span class="line"><span class="string">[Thu Aug 22 20:02:25 CST 2019] Domain nymrli.top '</span>_acme-challenge.nymrli.top<span class="string">' success.</span></span><br><span class="line"><span class="string">[Thu Aug 22 20:02:25 CST 2019] All success, let'</span>s <span class="built_in">return</span></span><br><span class="line">[Thu Aug 22 20:02:25 CST 2019] Verifying: nymrli.top</span><br><span class="line">[Thu Aug 22 20:02:28 CST 2019] Success</span><br><span class="line">[Thu Aug 22 20:02:28 CST 2019] Verifying: *.nymrli.top</span><br><span class="line">[Thu Aug 22 20:02:31 CST 2019] Success</span><br><span class="line">[Thu Aug 22 20:02:31 CST 2019] Removing DNS records.</span><br><span class="line">[Thu Aug 22 20:02:31 CST 2019] Removing txt: NyNt2AxJ3OmW8s_wVn2C3CNN9_yT1o_v2o0MhmdUoTs <span class="keyword">for</span> domain: _acme-challenge.nymrli.top</span><br><span class="line">[Thu Aug 22 20:02:34 CST 2019] Removed: Success</span><br><span class="line">[Thu Aug 22 20:02:34 CST 2019] Removing txt: ADqtxSTlQ0DH7jHZzlP9UZB0dT9U2oVYSk_zTabYN3w <span class="keyword">for</span> domain: _acme-challenge.nymrli.top</span><br><span class="line">[Thu Aug 22 20:02:38 CST 2019] Removed: Success</span><br><span class="line">[Thu Aug 22 20:02:38 CST 2019] Verify finished, start to sign.</span><br><span class="line">[Thu Aug 22 20:02:38 CST 2019] Lets finalize the order, Le_OrderFinalize: https://acme-v02.api.letsencrypt.org/acme/finalize/64001779/941369076</span><br><span class="line">[Thu Aug 22 20:02:40 CST 2019] Download cert, Le_LinkCert: https://acme-v02.api.letsencrypt.org/acme/cert/034f6880d75703381da6f5efedb159772580</span><br><span class="line">[Thu Aug 22 20:02:40 CST 2019] Cert success.</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">xxxxx</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">[Thu Aug 22 20:02:40 CST 2019] Your cert is <span class="keyword">in</span>  /home/mrli/.acme.sh/nymrli.top/nymrli.top.cer </span><br><span class="line">[Thu Aug 22 20:02:40 CST 2019] Your cert key is <span class="keyword">in</span>  /home/mrli/.acme.sh/nymrli.top/nymrli.top.key </span><br><span class="line">[Thu Aug 22 20:02:40 CST 2019] The intermediate CA cert is <span class="keyword">in</span>  /home/mrli/.acme.sh/nymrli.top/ca.cer </span><br><span class="line">[Thu Aug 22 20:02:40 CST 2019] And the full chain certs is there:  /home/mrli/.acme.sh/nymrli.top/fullchain.cer</span><br></pre></td></tr></table></figure><h3 id="nginx配置文件内容"><a href="#nginx配置文件内容" class="headerlink" title="nginx配置文件内容"></a>nginx配置文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 443 ssl;</span><br><span class="line">server_name 127.0.0.1;</span><br><span class="line">charset utf-8;</span><br><span class="line">client_max_body_size 75M;</span><br><span class="line">    location /static&#123;</span><br><span class="line">    <span class="built_in">alias</span> /home/mrli/Python_project/QQoauth_remote/static;  </span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">include uwsgi_params;</span><br><span class="line">uwsgi_pass 127.0.0.1:81;</span><br><span class="line">uwsgi_param UWSGI_SCRIPT app:app;   <span class="comment"># 启动flask的文件:Flask的实例</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ssl_certificate   /home/mrli/.acme.sh/nymrli.top/fullchain.cer; </span><br><span class="line">    ssl_certificate_key /home/mrli/.acme.sh/nymrli.top/nymrli.top.key;   </span><br><span class="line">    <span class="comment">#前面生成的证书，改一下里面的域名就行，不建议更换路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阿里云免费SSL证书symantec"><a href="#阿里云免费SSL证书symantec" class="headerlink" title="阿里云免费SSL证书symantec"></a>阿里云免费SSL证书symantec</h2><p>从<a href="https://common-buy.aliyun.com/?spm=5176.2020520163.cas.3.4cce56a7AqzpRw&amp;commodityCode=cas#/buy" target="_blank" rel="noopener">云盾证书服务(包年)</a>中选择免费的symantec生成后，按下载，选择nginx证书</p><p><img src="/2019/08/22/Let-s-Encrypt安装配置SSL证书教程/1.png" alt="1"></p><p>文件内容如下</p><p><img src="/2019/08/22/Let-s-Encrypt安装配置SSL证书教程/cer.png" alt="cer"></p><p>我们需要把这两个文件放到我们的服务器中，如果是linux系统，推荐放到<code>/etc/ssl/</code>目录下</p><p>示例：nginx节点配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="comment">#http节点中可以添加多个server节点</span></span><br><span class="line">    server&#123;</span><br><span class="line">        <span class="comment">#监听443端口</span></span><br><span class="line">        listen 443;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">#对应的域名，把test.nymrli.top改成你们自己的域名就可以了</span></span><br><span class="line">        server_name test.nymrli.top;</span><br><span class="line">        ssl on;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">#从腾讯云获取到的第一个文件的全路径</span></span><br><span class="line">        ssl_certificate /etc/ssl/1474527_www.nymrli.top.pem;</span><br><span class="line">        <span class="comment">#从腾讯云获取到的第二个文件的全路径</span></span><br><span class="line">        ssl_certificate_key /etc/ssl/1474527_www.nymrli.top.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#这是我的主页访问地址，因为使用的是静态的html网页，所以直接使用location就可以完成了。</span></span><br><span class="line">        location / &#123;</span><br><span class="line">                <span class="comment">#文件夹</span></span><br><span class="line">                root /usr/<span class="built_in">local</span>/service/ROOT;</span><br><span class="line">                <span class="comment">#主页文件</span></span><br><span class="line">                index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>▲.<code>crt、pem、key</code>都是证书文件</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决:"></a>问题解决:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Problem binding to port 80: Could not bind to IPv4 or IPv6.</span><br></pre></td></tr></table></figure><p>原因是 nginx 占用了80端口，输入<code>service nginx stop</code>。然后再次执行证书安装命令，即可顺利安装。安装完毕后，输入<code>service nginx start</code>，重启 nginx 服务。</p><p>2.重启nginx失败=&gt;conf配置有问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">See &quot;systemctl status nginx.service&quot; and &quot;journalctl -xe&quot; for details.</span><br><span class="line"> failed!</span><br></pre></td></tr></table></figure><p>A:<code>.conf</code>文件的注释是#而不是//</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Let’s-Encrypt-安装配置nginx的SSL证书教程&quot;&gt;&lt;a href=&quot;#Let’s-Encrypt-安装配置nginx的SSL证书教程&quot; class=&quot;headerlink&quot; title=&quot;Let’s Encrypt 安装配置nginx的SSL证书教
      
    
    </summary>
    
    
      <category term="环境部署" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>时间序列概念及主要模型</title>
    <link href="https://nymrli.top/2019/07/29/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9E%8B/"/>
    <id>https://nymrli.top/2019/07/29/时间序列概念及主要模型/</id>
    <published>2019-07-29T11:05:18.000Z</published>
    <updated>2019-07-30T06:29:07.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间序列概念及主要模型"><a href="#时间序列概念及主要模型" class="headerlink" title="时间序列概念及主要模型"></a>时间序列概念及主要模型</h1><p>Q:什么是时间序列分析?<br>A:时间序列是按照时间顺序，按照一定时间间隔取得的一系列观测值<br>Q:怎样做时间序列分析?<br>A:时间序列分析尝试找出序列值在过去呈现的特征模式，假定这种模式在未来能够持续，进而对未来进行预测</p><h2 id="时间序列三大特征"><a href="#时间序列三大特征" class="headerlink" title="时间序列三大特征"></a>时间序列三大特征</h2><ul><li>序列相关性：当期的序列值和前期某个或某些序列值线性相关<br>√  自相关系数（全相关系数）（ACF）：用来度量同一事件在不同时期之间的相关程度。$\rho_{h}=\frac{r(h)}{r(0)}$，其中r（h）为h期协方差函数，r（0）为方差<br>√  偏自相关系数（PACF）：度量去除中间变量影响后的相关程度。$X_{t}$和$X_{t-2}$通过$X_{t-1}$产生关联，PACF即为去除$X_{t- 1}$的关联后两者的相关程度</li><li>趋势性：序列整体上呈现单调性，如平稳，上涨或下跌<ul><li>ARMA模型是平稳的时间序列模型，在建模前必须去除趋势性</li></ul></li><li>随机性：序列在一定程度上呈现不确定性<ul><li>模型并不能够捕捉到现实世界中的所有特征，总有一些噪声的存在，这些噪声叫做白噪声</li></ul></li></ul><h2 id="时间序列模型预测方法："><a href="#时间序列模型预测方法：" class="headerlink" title="时间序列模型预测方法："></a>时间序列模型预测方法：</h2><p>算术平均法，移动平均法，加权移动平均法，指数平滑法，自回归法和移动平均法（ARIMA）</p><p>算数平均法：对时间序列的过去数据进行简单平均来进行预测<br>移动平均法(ARIMA)：不考虑远期的数据，仅考虑近期数据产生的影响。<br>加权移动平均法：给予近期数据较大的权重，远期数据较小的权重<br>指数平滑法：给予近期数据较大的权重，远期数据较小的权重，但是权重以指<br>数的形式适减<br>自回归法和移动平均法（ARIMA）:先对数据做了差分，之后再使用自回归滑动平均模型[^ARMA]模型。优点信息浪费最少，集趋势性，相关性和随机性于一身</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>T时刻的时间序列值</strong>表示为$X_t$,T-1时刻的序列值表述为$X_{t-1}$或者$X[t-1]$</p><p><strong>一个时间序列</strong>可以表述为：$\left{X_{t} | t=1,2,3 \dots n\right}$</p><p>滞后算子$B X,=X_{t-1}$</p><p>时间序列的差分:$X_{t}-X_{t-1}$或者$X[t]-X[t-1]$<br>一阶差分：$X_{t}-X_{t-1}=X_{t}-B X_{t}=(1-B) X_{t}$<br>二阶差分：$\nabla\left(\nabla X_{t}\right)=\nabla X_{t}-\nabla X_{r-1}=\left(X_{t}-X_{t-1}\right)-\left(X_{t-1}-X_{t-2}\right)=X_{t}-2 X_{t-1}+X_{t-2}=(1-B)^{2} X_{t}$<br>k步差分：$X_{t}-X_{t-k}=X_{t}-B^{k} X_{t}=\left(1-B^{k}\right) X_{t}$</p><p>思考：<br>1.三阶差分如何表达？3步差分如何表达？<br>2.为什么要进行一阶差分？二阶差分？<br>3.为什么要进行k步差分？<br>4.阶次差分与步长差分的区别？</p><h2 id="时间序列分类"><a href="#时间序列分类" class="headerlink" title="时间序列分类"></a>时间序列分类</h2><blockquote><p>Q:什么是序列平稳？</p><p>A:</p><p>1.$E\left(X_{t}\right)=\mu$，对于所有t而言，序列的期望为一常数，见图一</p><p>2.$\operatorname{Var}\left(X_{t}\right)=\sigma$，对于所有t，序列方差为一常数，见图二</p><p>3.$r(h)=\operatorname{Cov}\left(X_{t}, X_{t-l}\right)$对于所有t以及h〉0，序列的协方差为是由h唯一决定的函数，即h阶的相关性只与h有关，与时刻t无关，如：$\left{X_{n}, X_{n+1}, X_{n+2}, \ldots, X_{n}\right},\left{X_{1}, X_{2}, X_{3}, \ldots, X_{n+1}-n\right]$与$\left{X_{h+5}, X_{h+6}, X_{h+7}, \ldots, X_{n+5}\right},\left{X_{6}, X_{7}, X_{8}, \ldots, X_{n+6-h}\right}$的相关性一致</p></blockquote><p>根据序列是否平稳，时间序列可以分为：</p><p>平稳序列：白噪声序列、AR（p）序列，MA（a）序列，ARWA（p.g）序列<br>非平稳序列：ARlMA（P.d.g）序列</p><p>平稳条件:</p><p>1.$E\left(x_{t}\right)=\mu$序列的均值应该是一个常数，而不是随时间变化的函数。下图中左图满足要求，而右图的均值是随时间而变化的。</p><p><img src="/2019/07/29/时间序列概念及主要模型/1.jpg" alt="1"></p><p>2.$\operatorname{Var}\left(X_{t}\right)=\sigma$,序列的方差为一个常数，而不随时间的变化</p><p><img src="/2019/07/29/时间序列概念及主要模型/2.jpg" alt="2"></p><p>3.$\operatorname{Cov}(y t, y t+k)=y 0$,k,序列协方差的值只与时间间隔k有关，与时间t无关</p><p><img src="/2019/07/29/时间序列概念及主要模型/3.jpg" alt="3"></p><h3 id="白噪声序列"><a href="#白噪声序列" class="headerlink" title="白噪声序列"></a>白噪声序列</h3><p>(高斯)白噪声模型:$X_{t}=\mathrm{e}<em>{\mathrm{t}} | \mathrm{e}</em>{\mathrm{t}} \sim \mathrm{WN}\left(0, \sigma^{2}\right)$<br>(高斯)白噪声就是一系列独立分布的正态序列：</p><ul><li>序列相关性：无</li><li>趋势性：无</li><li>随机性：是</li></ul><p>白噪声的每一个时序点都是服从正态分布的</p><p><img src="/2019/07/29/时间序列概念及主要模型/B.jpg" alt="B"></p><p><img src="/2019/07/29/时间序列概念及主要模型/高斯白噪声散点图.jpg" alt="高斯白噪声散点图"></p><p>序列无规律可循，在均值处反复震荡<img src="/2019/07/29/时间序列概念及主要模型/高斯白噪声.jpg" alt="高斯白噪声"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clear,clc;</span><br><span class="line">N=<span class="number">0</span>:<span class="number">1000</span>;</span><br><span class="line">fs=<span class="number">1024</span>;</span><br><span class="line">t=N./fs;</span><br><span class="line">y=<span class="number">3</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*t);</span><br><span class="line">x=wgn(<span class="number">1</span>,<span class="number">1001</span>,<span class="number">2</span>);<span class="comment">% wgn产生高斯白噪声</span></span><br><span class="line"><span class="built_in">i</span>=y+x;<span class="comment">% 给原有信号y叠加高斯白噪声</span></span><br><span class="line"><span class="comment">%i=awgn(y,2); % awgn在信号y中加入高斯白噪声。</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>),plot(x);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>),plot(y);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>),plot(<span class="built_in">i</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="自回归模型AR"><a href="#自回归模型AR" class="headerlink" title="自回归模型AR"></a>自回归模型AR</h3><h4 id="▲AR-p"><a href="#▲AR-p" class="headerlink" title="▲AR(p):"></a>▲AR(p):</h4><p> $X_{t} = \beta_{1}X_{t-1}+\beta_{2} X_{t-2}+\ldots+\beta_{p} X_{t-p}+\mathrm{e}<em>{t} \quad \mathrm{e}</em>{t} \sim \mathrm{WN}\left(0, \sigma^{2}\right)$</p><p>当前时刻的时序值可由其过去值的线性组合加上一个白噪声</p><p>建模的目的就是要搞清过去几期的历史值会影响当前值</p><p>模型特征：</p><ul><li>趋势性：无</li><li>相关性：有</li><li>随机性：有</li></ul><h4 id="▲AR（1）模型"><a href="#▲AR（1）模型" class="headerlink" title="▲AR（1）模型:"></a>▲AR（1）模型:</h4><p>$X_{t}=\beta_{1} X_{t-1}+e_{t}$</p><p>一阶自回归模型是最简单的自回归模型</p><p>该模型在t+1时的情形:$X_{t+1}=\beta_{\perp} X_{t}+e_{t+1}$</p><p>自相关系数：$\rho_{1}=\beta_{1}, \rho_{2}=\beta_{1}^{2}, \ldots, \rho_{k}=\beta_{1}^{k}, \mathrm{k} \geq 3$<br>偏自相关系数：$\varphi_{11}=\rho_{1}, \varphi_{k k}=0, k \geqslant 2$</p><p>AR（1）的序列相关性：</p><ul><li>ACF星现指数下降趋势</li><li>PACF在一阶处出现峰值，之后截断</li></ul><p><img src="/2019/07/29/时间序列概念及主要模型/B2.jpg" alt="B2"></p><p>Q:如何识别自回归阶数</p><p>A:</p><ul><li>PACF显示出剧烈地下降，并截断在P阶，而ACF呈指数下降趋势</li><li>PACF截尾的阶数即为AR模型的阶数</li></ul><hr><h3 id="移动平均模型MA"><a href="#移动平均模型MA" class="headerlink" title="移动平均模型MA"></a>移动平均模型MA</h3><h4 id="▲MA-a"><a href="#▲MA-a" class="headerlink" title="▲MA(a):"></a>▲MA(a):</h4><p>$X_{t}=e_{t}+\dot{\beta}<em>{1} e</em>{t-1}+\beta_{2} e_{t-2}+\ldots+\beta_{q} e_{t-q}$ , $e_{t} \sim W N\left(0, \sigma^{2}\right)$</p><p>序列当前时刻的时序值是过去q阶白噪声的线性组合</p><p>建模的目的在于：</p><ul><li>找出过去几期的白噪声影响了当前值</li><li>找出过去a期冲击效应对当前值的影响</li></ul><p>模型特征：</p><ul><li>趋势性：无</li><li>相关性：有</li><li>随机性：有</li></ul><h4 id="▲MA（1）模型"><a href="#▲MA（1）模型" class="headerlink" title="▲MA（1）模型:"></a>▲MA（1）模型:</h4><p>$X_{t}=e_{t}+\beta_{1} e_{t-1}$</p><p>一阶移动平均模型是最简单的移动平均模型</p><p>该模型在t+1时的情形？$X_{t+1}=e_{t+1}+\beta_{1} e_{t}$</p><p>​    MA（1）模型是利用t时刻的冲击变量值来预测将来</p><p>自相关系数：$\rho_{k}=\frac{\gamma_{k}}{\gamma_{0}}=\left{\begin{array}{cc}{\frac{\beta_{1}}{1+\beta_{1}^{2}},} &amp; {k=1} \ {0} &amp; {k \geq 2}\end{array}\right.$<br>偏自相关系数：$\varphi_{k k}=\left{\begin{array}{cc}{\rho_{1},} &amp; {k=1} \ {\frac{-\rho_{1}^{2}}{1-\rho_{1}^{2}}} &amp; {k=2} \ {\frac{-\varphi_{k-1, k-1} \rho_{1}}{1-\varphi_{k-1,1} \rho_{1}}} &amp; {k \geq 3}\end{array}\right.$</p><hr><h3 id="自回归滑动平均模型ARMA"><a href="#自回归滑动平均模型ARMA" class="headerlink" title="自回归滑动平均模型ARMA"></a>自回归滑动平均模型ARMA</h3><h4 id="▲ARMA（p-q）-X-t-beta-1-X-t-1-ldots-beta-p-X-t-p-e-t-alpha-1-e-t-1-alpha-2-e-t-2-ldots-alpha-q-e-t-q"><a href="#▲ARMA（p-q）-X-t-beta-1-X-t-1-ldots-beta-p-X-t-p-e-t-alpha-1-e-t-1-alpha-2-e-t-2-ldots-alpha-q-e-t-q" class="headerlink" title="▲ARMA（p,q）:$X_{t}=\beta_{1} X_{t-1}+\ldots+\beta_{p} X_{t-p}+e_{t}+\alpha_{1} e_{t-1}+\alpha_{2} e_{t-2}+\ldots+\alpha_{q} e_{t-q}$"></a>▲ARMA（p,q）:$X_{t}=\beta_{1} X_{t-1}+\ldots+\beta_{p} X_{t-p}+e_{t}+\alpha_{1} e_{t-1}+\alpha_{2} e_{t-2}+\ldots+\alpha_{q} e_{t-q}$</h4><p>ARMA（p,q）模型就是AR（p）和MA（q）模型的组合</p><p>ARMA模型是更普遍的一类模型</p><p>模型特征：</p><ul><li>趋势性：无</li><li>相关性：有</li><li>随机性：有</li></ul><h4 id="▲ARMA-1-1-："><a href="#▲ARMA-1-1-：" class="headerlink" title="▲ARMA(1,1)："></a>▲ARMA(1,1)：</h4><p>通过查看自相关函数ACF和偏自相关函数PACF识别相关性<br>ACF呈指数下降趋势<br>PACF呈现指数下降趋势</p><p><img src="/2019/07/29/时间序列概念及主要模型/B3.jpg" alt="B3"></p><p>Q:如何识别一个ARMA的阶数p和q?</p><p>A:<br>1.由于ACF与PACF均呈现指数下降，判断阶数需要靠不断尝试<br>2.在模型的不同尝试中，通过选择AIC较小的为最优模型<br>$A I C=2 k+n * \ln (\frac{R S S}{n})$k为参教数量，RSS为残差平方和</p><h3 id="AR，MA，ARMA模型识别"><a href="#AR，MA，ARMA模型识别" class="headerlink" title="AR，MA，ARMA模型识别"></a>AR，MA，ARMA模型识别</h3><p><img src="/2019/07/29/时间序列概念及主要模型/analyse.jpg" alt="analyse"></p><hr><h3 id="ARIMA模型"><a href="#ARIMA模型" class="headerlink" title="ARIMA模型"></a>ARIMA模型</h3><p>ARIMA是在ARMA基础上发展而来的更加综合性的模型，体现为：<br>■ 趋势性<br>■ 序列相关性<br>■  随机性<br>ARIMA是不平稳的时间序列，不能直接用ARMA建模。ARIMA模型是在ARMA模型演变出来的，它实际上是先对数据做了差分，之后再使用ARMA模型；换句话说，ARIMA模型是先将非平稳数据变得平稳（用差分），之后再用ARMA模型处理平稳数据</p><p>ARIMA（1，1，0）的时间序列：<br>序列有很强的趋势性</p><p><img src="/2019/07/29/时间序列概念及主要模型/arima1.jpg" alt="arima1"></p><ul><li>ARIMA（1，1，0）的序列相关性：<br>ACF下降极其缓慢</li></ul><p><img src="/2019/07/29/时间序列概念及主要模型/arima2.jpg" alt="arima2"></p><ul><li>ARIMA（1，1，0）的序列图和ACF：</li></ul><p><img src="/2019/07/29/时间序列概念及主要模型/arima3.jpg" alt="arima3"></p><p>ARIMA(p,d,q)</p><ul><li>$\nabla_{d} X_{t}=(1-B)^{d} X_{t}=Y_{t}$</li><li>$Y_{t}=\beta_{1} Y_{t-1}+…+\beta_{p} Y_{t-p}+e_{t}+\alpha_{1} e_{t-1}+\alpha_{2} e_{t-2}+\ldots+\alpha_{q} e_{t-q}$</li><li>差分后的序列符合ARMA（p，g）</li></ul><p>符号△为差分算子，$\nabla_{d} X_{t}$代表d阶差分序列</p><p>一阶差分序列$\Delta X_{t}=(1-B)^{*} X_{t}=X_{t}-X_{t-1}$</p><h2 id="预测的评价指标"><a href="#预测的评价指标" class="headerlink" title="预测的评价指标"></a>预测的评价指标</h2><p>ME（误差）：Mean（Actual-Predict）<br>MAE（绝对误差）：Mean（abs（Actual-Predict））<br>MAPE（百分比误差）：Mean（abs（Actual-Predict/Actual）<br>MSE（均方误差平方和）：Mean（（Actual-Predict）2）<br>RMSE（标准差）：Sqrt（Mean（（Actual-Predict）A2））</p><p>在模型选择方法上，通常会结合客户的建议以及其他的时间序列模型方法，选择某个评价指标，进而选择使该评价指标最小的模型方法</p><p>参考:<a href="https://blog.csdn.net/weixin_41636030/article/details/89115370" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41636030/article/details/89115370</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时间序列概念及主要模型&quot;&gt;&lt;a href=&quot;#时间序列概念及主要模型&quot; class=&quot;headerlink&quot; title=&quot;时间序列概念及主要模型&quot;&gt;&lt;/a&gt;时间序列概念及主要模型&lt;/h1&gt;&lt;p&gt;Q:什么是时间序列分析?&lt;br&gt;A:时间序列是按照时间顺序，按照一定
      
    
    </summary>
    
    
      <category term="数学建模" scheme="https://nymrli.top/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>基础知识补充——白噪声、高斯白噪声</title>
    <link href="https://nymrli.top/2019/07/29/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85%E2%80%94%E2%80%94%E7%99%BD%E5%99%AA%E5%A3%B0%E3%80%81%E9%AB%98%E6%96%AF%E7%99%BD%E5%99%AA%E5%A3%B0/"/>
    <id>https://nymrli.top/2019/07/29/基础知识补充——白噪声、高斯白噪声/</id>
    <published>2019-07-29T10:47:04.000Z</published>
    <updated>2019-07-30T06:29:00.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="白噪声、高斯白噪声"><a href="#白噪声、高斯白噪声" class="headerlink" title="白噪声、高斯白噪声"></a>白噪声、高斯白噪声</h1><h2 id="白噪声过程"><a href="#白噪声过程" class="headerlink" title="白噪声过程:"></a>白噪声过程:</h2><p>对于一个随机变量X(t)（t=1，2，3……），如果是由一个不相关的随机变量的序列构成的，即对于所有s不等于t，随机变量X(t)和X(s)的协方差为零，则称其为纯随机过程。对于一个纯随机过程来说，若其期望为0，方差为常数，则称之为白噪声过程。</p><h2 id="白噪声"><a href="#白噪声" class="headerlink" title="白噪声:"></a>白噪声:</h2><p>白噪声序列，是指<u>白噪声过程的样本</u>实称，简称白噪声[^1]。白噪声是<strong>在较宽的频率范围内，各等带宽的频带所含的噪声能量相等的噪声</strong>[^2]，是一种功率频谱密度为常数的随机信号或随机过程，也就是说，此<u>信号在各个频段上的功率是一样的</u>。</p><p>理想的白噪声具有无限的带宽，因而其能量无限大，但这是不可能实际存在的，所以，我们把有限带宽内的平整讯号视为白噪声[^3]，以便我们实际应用当中的分析。<br>近似计算:一般情况下，若一个噪声过程所具有的频谱宽度远远大于它所作用系统的带宽，并且在该带宽中其功率谱密度基本为一常数，那么就能够把其作为白噪声来对待。</p><p>白噪声的功率密度函数恒定，为$P_{n}(t)=\frac{n_{0}}{2}(-\infty&lt;f&lt;+\infty)(\mathrm{W} / \mathrm{HZ})$<br>$P_{n}(t)=n_{0}(0&lt;f&lt;+\infty)(\mathrm{W} / \mathrm{Hz})$，其中$n_0$是常数。</p><h2 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h2><p>高斯噪声指的是它的<strong>概率密度函数服从正态分布的噪声</strong>。</p><p>高斯分布，记为N (μ,σ2)，其中μ为高斯分布的均值（数学期望），σ2为高斯分布的方差，当μ=0，σ2=1时，该分布称为标准正态分布。高斯分布的一维概率密度可表示为式：$P(x)=\frac{1}{\sqrt{2 \pi} \sigma} \exp \left(-\frac{(x-\mu)^{2}}{2 \sigma^{2}}\right)$</p><p>在通信信道中，一般噪声的均值μ=0。，那么可以得知当噪声的均值是零的时候，噪声的平均功率等于其方差。</p><p>高斯白噪声的高斯指的是概率分布为正态分布，白噪声指的是其二阶矩不相关，一阶矩为常数的噪声。故把<strong>瞬时值概率分布服从高斯分布，功率谱密度服从均匀分布的噪声</strong>称为高斯白噪声[^1]。这两个条件是判断高斯白噪声性能的标准。</p><p>由于高斯白噪声能够反映实际通信信道中的噪声情况，能够比较真实的反映信道噪声的一些特性，并且可以用具体的数学表达式表示，适合分析、计算系统的抗噪声性能，所以广泛应用于通信系统的理论分析。</p><p>高斯白噪声模型:$X_{t}=\mathrm{e}<em>{\mathrm{t}} | \mathrm{e}</em>{\mathrm{t}} \sim \mathrm{WN}\left(0, \sigma^{2}\right)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;白噪声、高斯白噪声&quot;&gt;&lt;a href=&quot;#白噪声、高斯白噪声&quot; class=&quot;headerlink&quot; title=&quot;白噪声、高斯白噪声&quot;&gt;&lt;/a&gt;白噪声、高斯白噪声&lt;/h1&gt;&lt;h2 id=&quot;白噪声过程&quot;&gt;&lt;a href=&quot;#白噪声过程&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="信号处理" scheme="https://nymrli.top/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>傅里叶变换-&gt;小波变化</title>
    <link href="https://nymrli.top/2019/07/29/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-%E5%B0%8F%E6%B3%A2%E5%8F%98%E5%8C%96/"/>
    <id>https://nymrli.top/2019/07/29/傅里叶变换-小波变化/</id>
    <published>2019-07-29T01:51:32.000Z</published>
    <updated>2019-07-30T06:29:10.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="傅里叶变换-gt-小波变化"><a href="#傅里叶变换-gt-小波变化" class="headerlink" title="傅里叶变换-&gt;小波变化"></a>傅里叶变换-&gt;小波变化</h1><blockquote><p>声明:文中大多数内容来自(<a href="https://www.zhihu.com/people/zhi-yuan-ya-77" target="_blank" rel="noopener">知乎1335</a>)[<a href="https://www.zhihu.com/people/zhi-yuan-ya-77],matlab源代码:[1368069096/From_FT_to_WT_examples-](https://link.zhihu.com/?target=https%3A//github.com/1368069096/From_FT_to_WT_examples-),部分为个人理解阐明" target="_blank" rel="noopener">https://www.zhihu.com/people/zhi-yuan-ya-77],matlab源代码:[1368069096/From_FT_to_WT_examples-](https://link.zhihu.com/?target=https%3A//github.com/1368069096/From_FT_to_WT_examples-),部分为个人理解阐明</a></p></blockquote><h2 id="一-傅里叶变换FT"><a href="#一-傅里叶变换FT" class="headerlink" title="一.傅里叶变换FT"></a>一.傅里叶变换FT</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote><p>（FOURIER TRANSFORM，简称FT）</p></blockquote><h3 id="为什么傅里叶变换可以把一个信号从时域变换到频域"><a href="#为什么傅里叶变换可以把一个信号从时域变换到频域" class="headerlink" title="为什么傅里叶变换可以把一个信号从时域变换到频域?"></a>为什么傅里叶变换可以把一个信号从时域变换到频域?</h3><p>先给出公式，傅里叶变换的形式为：$X(w)=\int_{-\infty}^{+\infty} x(t) e^{-j w t} d t$</p><p>PS：傅里叶变换还存在系数，有的文章写的是 $\frac{1}{2 \pi}$ ，有的文章写的是$\sqrt\frac{1}{2 \pi}$ ，两个系数只要满足正变换系数乘上逆变换系数等于$\frac{1}{2 \pi}$ 即可。这是为了保证经过一次正变换和反变换之后，得到的信号与原信号幅值相同，与我们接下来的讨论关系不大。</p><h3 id="1-理解变换公式"><a href="#1-理解变换公式" class="headerlink" title="1.理解变换公式"></a>1.理解变换公式</h3><p>我们知道，根据欧拉公式，$e^{-j w t}=\cos (w t)-j \sin (w t)$。也就是说，傅里叶变换的本质就是：将原始信号乘上一组<strong>三角函数</strong>（正余弦），之后<strong>在整个时间域上积分</strong>。就这么简单！</p><h4 id="y-sin-3t-图"><a href="#y-sin-3t-图" class="headerlink" title="y=sin(3t)图"></a>y=sin(3t)图</h4><p>我们来看一个信号：y = sin(3t)，如下图：</p><p><img src="https://pic2.zhimg.com/80/v2-0cd28b5014a967f161a3327a44793ba5_hd.jpg" alt="img"></p><p>很好的周期性质，且每个周期的积分值都是0。如果对这个函数在$(-\infty,+\infty)$积分，那就是基本是0，因为 $(-\infty,+\infty)$包含了无数个周期。</p><p>PS：虽然这个积分在高数上不可积，但是你应该明白这里我要表达的意思：<strong>因为良好的周期性，且每个周期积分值是0，那么最后在很长的一段时间区间上积分，得到的还是一个很小的数，近似为0。</strong></p><p>我们来用一段较长的时间区间计算一下，$\int_{0}^{50} \sin (3 t) d t=0.1002$，结果符合我们的预计。</p><h4 id="y-sin-4t-sin-3t-图"><a href="#y-sin-4t-sin-3t-图" class="headerlink" title="y=sin(4t)sin(3t)图"></a>y=sin(4t)sin(3t)图</h4><p>现在，我们来将这个信号乘上一个sin(4t) ，则信号变为y1 = sin(3t)*sin(4t)，如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-5f0c8596fe05899d0cb5a1acaec70cfe_hd.jpg" alt="img"></p><p>具有一个较短的小幅震动的周期和一个较长的主体周期，对吧？且每个主体周期的积分值都是0。同以上讨论，如果对这个函数在$(-\infty,+\infty)$积分，<strong>基本还接近于0</strong>，因为  $(-\infty,+\infty)$包含了无数个主体周期。</p><h4 id="y-sin-3-1t-sin-3t-图"><a href="#y-sin-3-1t-sin-3t-图" class="headerlink" title="y=sin(3.1t)sin(3t)图"></a>y=sin(3.1t)sin(3t)图</h4><p>之后呢，我们来将这个信号乘上一个sin(3.1t) ，则信号变为y2 = sin(3t)*sin(3.1t)，如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-5af405c36d2d0ef48ab9f91ac7fb1672_hd.jpg" alt="img"></p><p>同样是有一个较短的小幅震动的周期和一个较长的主体周期，对吧？可以判断，每个主体周期的积分值都是0（虽然（0，50）这个区间没有完整地展示主题周期）。那么，依然同以上讨论，如果对这个函数在$(-\infty,+\infty)$ 积分，基本还接近于0，因为$(-\infty,+\infty)$包含了无数个主体周期。</p><p>我们来用之前的时间区间计算一下， $\int_{0}^{50} \sin (3 t) * \sin (3.1 t) d t=-4.7731$ 。</p><p>咦？这一次怎么距离0这么远了呢？</p><p>原因就是：<strong>对于sin(3t)*sin(4t)，它的主体周期较短</strong>，（0，50）是包含了好几个主体周期的，也就是说（0，50）在某种程度上是类似于 $(-\infty,+\infty)$ 的。但是，<strong>对于sin(3t)*sin(3.1t)，它的主体周期很长</strong>，（0，50）连它的一个完整的主体周期都没有包含，那么（0，50）是不能类似于 $(-\infty,+\infty)$ 的，积分值自然就比较大。</p><p>我们此时可以这样小小总结一下，对于信号y = sin(3t)，它的频率是3rad/s，（如果你喜欢用HZ，那就除以$2\pi$ ，就是 $\frac{3}{2\pi}$HZ，这里使用rad/s，是为了与前面的傅里叶变换的公式中的w一致），而sin(4t)的频率是4rad/s，sin(3.1t)的频率是3.1rad/s。</p><p>如果在 $(-\infty,+\infty)$ 积分，那么y1 = sin(3t)<em>sin(4t)，y2 = sin(3t)</em>sin(3.1t)的积分值都是0，也就是说，sin(4t)和sin(3.1t)在这里是没差别的。</p><p>但是！！！<strong>如果在一个<u>有限区间内</u>积分，由于sin(3.1t)的频率3.1rad/s，距离原信号y = sin(3t)的频率3rad/s更近，那么sin(3.1t)和sin(3t)的乘积，也就是y2 = sin(3t)*sin(3.1t)的积分的绝对值会更大，也就是会离0更远。这里已经显示出一定的频率选择性了。</strong></p><p>最后，让我们请出我们今天的主角，将这个信号乘上一个自己同频率的sin(3t) ，则信号变为y3 = sin(3t)*sin(3t)，如图：</p><p><img src="https://pic2.zhimg.com/80/v2-639fbf1ab8e20ee318da83b21c641da1_hd.jpg" alt="img"></p><p>Amazing！！！发现了什么？良好的周期性？还有呢？<strong>由于乘上了自己，任何时间的幅值都大于等于0了！不再满足周期内积分值为0这个条件了！</strong>那么，此时，我们对这个信号在 $(-\infty,+\infty)$ 积分，就会得到一个非常非常大的数字。<strong>这个很大很大的数字就告诉你，这个信号和你乘的信号是同频率的！这就是可以知道信号中具有哪些频率部分了，不是吗？</strong></p><p>我们还是来用之前的时间区间计算一下， $\int_{0}^{50} \sin (3 t) * \sin (3 t) d t=25.0833$。<strong>是不是比其他的积分值都大了好多？</strong></p><p>好了，我们已经知道，<strong>▲.将一个信号乘上一个特定频率的sin函数，在 $(-\infty,+\infty)$ 上积分，可以将信号中与sin函数同频率的部分筛选出来。那么，原则上讲，只要乘上所有频率的sin函数，并积分，不就知道原始信号中的所有频率部分了吗？</strong></p><p><strong>但是这样做需要把所有频率乘进去，做无数次计算哈！</strong>算不出来的。所以，<strong>我们将所乘的sin函数的频率作为符号变量w，来进行积分，即：</strong></p><p>$X(w)=\int_{-\infty}^{+\infty} x(t) \sin (w t) d t$</p><p>注意：这里的w只是一个符号变量，这样的话，<strong>就只需要做一次积分，可以计算了。</strong></p><p><strong>计算出来X(w)之后，想知道特定的频率w0对应的积分值，直接将w0带入X(w)就立马得到积分值。</strong>，如想知道是否含有w0=3rad/s分量,那么久计算X(3)看结果是否为0，这样就能知道原信号中是否含有这一频率的部分了。</p><p>好了，我们推导的这个式子，是不是与傅里叶变换的式子：</p><p>$X(w)=\int_{-\infty}^{+\infty} x(t) e^{-j w t} d t=\int_{-\infty}^{+\infty} x(t)(\cos (w t)-j \sin (w t)) d t$</p><p>很像了呢？</p><p><strong>这就是傅里叶变换的原理！乘上带有符号变量的sin、cos函数，并积分，就知道原始信号中的所有频率部分啦！</strong></p><h3 id="2、傅里叶变换（FT）的正交性"><a href="#2、傅里叶变换（FT）的正交性" class="headerlink" title="2、傅里叶变换（FT）的正交性"></a><strong>2、傅里叶变换（FT）的正交性</strong></h3><p>傅里叶变换是一种变换。在变换中，我们<strong>将原始信号乘上的变化信号称为基函数</strong>。</p><p>在傅里叶变换中，一系列不同频率的sin、cos等函数称为这个变换的基函数。至于为什么需要既使用sin，又使用cos，这涉及到一点点正交函数的概念。傅里叶变换中的不同频率的<strong>sin、cos等函数是正交函数</strong>，使用正交函数组成的基函数会带给变换一些方便。</p><h4 id="什么是正交性"><a href="#什么是正交性" class="headerlink" title="什么是正交性?"></a>什么是正交性?</h4><h5 id="向量正交"><a href="#向量正交" class="headerlink" title="向量正交:"></a>向量正交:</h5><p>我们都知道，向量 <img src="https://www.zhihu.com/equation?tex=a%2Cb" alt="[公式]"> 的内积为<img src="https://www.zhihu.com/equation?tex=a%5Ccdot+b" alt="[公式]"> 。<strong>正交的定义为内积为0</strong>，即$a \cdot b=0$。如$a=(1,0)$ 表示x轴，$b=(0,1) $表示y轴，则 $a \cdot b=0$即意味着x轴与y轴正交。</p><p>假设有一个向量 $v=\left(x_{0}, y_{0}\right)$， $x_0$ 在x轴上定位v，$y_0$ 在y轴上定位v。<strong>当x轴与y轴正交时，意味着x坐标和y坐标表示的信息是彼此独立的，两坐标可以完全定位v。</strong></p><p>那么，当我们已知向量v，已知x轴a与y轴b，如果知道v的坐标呢？答案就是，<strong>投影/内积</strong>。</p><p>将v向x轴a做投影/内积： <img src="https://www.zhihu.com/equation?tex=x_0+%3D+v%5Ccdot+a" alt="[公式]"> ，可以得到<img src="https://www.zhihu.com/equation?tex=x_0" alt="[公式]">；将v向y轴b做投影/内积： <img src="https://www.zhihu.com/equation?tex=y_0+%3D+v%5Ccdot+b" alt="[公式]">，可以得到<img src="https://www.zhihu.com/equation?tex=y_0" alt="[公式]">。</p><h5 id="正交基"><a href="#正交基" class="headerlink" title="正交基"></a>正交基</h5><p>类似的，函数$  f_{1}(x), f_{2}(x)  $的内积定义如下：$\int_{-\infty}^{+\infty} f_{1}(x) f_{2}(x) d x$。<strong>函数正交的定义同样为内积为0</strong>，即 $\int_{-\infty}^{+\infty} f_{1}(x) f_{2}(x) d x=0$ 。PS：对于周期函数，定义中的积分区间为一个周期T。</p><p>我们来看，</p><p>$\int_{0}^{T} \sin \left(w_{1} x\right) \cos \left(w_{2} x\right) d x=0   (1)$ </p><p>$\int_{0}^{T} \sin \left(w_{1} x\right) \sin \left(w_{2} x\right) d x=0, w_{1} \neq w_{2}(2)$</p><p>$\int_{0}^{T} \cos \left(w_{1} x\right) \cos \left(w_{2} x\right) d x=0, w_{1} \neq w_{2}(3)$</p><p>▲.因此，傅里叶变换中的不同频率的sin、cos等函数都是正交函数。我们<strong>将cos想象为一个轴，将sin想象为一个轴</strong> ，这两个轴，就张了一个<strong>函数空间</strong>。</p><p>我们已经知道，x(t)的傅里叶变换为：</p><p>$X(w)=\int_{-\infty}^{+\infty} x(t)(\cos (w t)-j \sin (w t)) d t=\int_{-\infty}^{+\infty} x(t) \cos (w t) d t-j \int_{-\infty}^{+\infty} x(t) \sin (w t) d t$</p><p>我们来看，实部 $\int_{-\infty}^{+\infty} x(t) \cos (w t) d t$ 即相当于将x(t)与cos做内积，即向cos轴投影，得到的是在这个<strong>函数空间</strong>内的cos坐标，也就是与cos的相似度；虚部$\int_{-\infty}^{+\infty} x(t) \sin (w t) d t$ 即相当于将x(t)与sin做内积，即向sin轴投影，得到的是在这个函数空间内的sin坐标，也就是与sin的相似度。cos坐标和sin坐标都确定后，该信号就确定了。</p><p>因此，傅里叶变换之后，<strong>实部是与cos的相似度，虚部是与sin的相似度</strong>，傅里叶变换也就是与cos的相似度和与sin的相似度的总和，也就表示了相应的频率信息。</p><p>相似度的理解：通过相似度，可以将跟本身频率相似的频率挑选出来</p><p><strong>3、小例子</strong></p><p>最后，我们对于y=sin(3t)做傅里叶变换（这里画图用的matlab的FFT，是FT的离散快速算法，不是积分出来的，但是原理是相同的，仅做展示使用），变换后的图像如下：</p><p><img src="https://pic4.zhimg.com/80/v2-ffb3a17723fa1ef528dfc2350a36bd6f_hd.jpg" alt="img"></p><p>可以看到，与我们的预期相同，变换之后，在  $\omega=3 rad/ s$  处，出现了峰值，即表示该信号中包含了 的  $\omega=3 rad/ s$ 频率成分。</p><h3 id="这里需要说明三点："><a href="#这里需要说明三点：" class="headerlink" title="这里需要说明三点："></a>这里需要说明三点：</h3><p>1、这边的作图结果不是理想FT，如果是理想的FT，即在 $(-\infty,+\infty)$ 上积分，那么除了   $\omega=3 rad/ s$ 的积分值将是 $+\infty$ 之外，其他任意频率处的值都应该是0，得到的将是一个冲激函数。但是，这里我用的是离散傅里叶变换（详见我的下一篇文章），可以暂时理解为<strong>类似于我们讨论过的有限区间</strong>，当频率靠近3rad/s时（如之前提到的3.1rad/s的例子），也会积分出来一个较大的数值，所以这里不是一个冲击函数，而是一个山峰状的函数；</p><p>2、傅里叶变换之后是具有<strong>实部和虚部的</strong>，实部是与cos的相似度，虚部是与sin的相似度。我们要频率信息的时候，不管是与某一频率w的cos的相似还是与某一频率w的sin的相似，都是这一频率w嘛，不需要区分。因此，这里画图取了模，就不存在实部和虚部了。</p><p>3、在$\omega=3 r a d / s$处之所以没有出现我们讨论的很大很大很大的值，是因为画图之前对于变换之后的幅值统一除以了信号取样点的个数，统一压缩了一定的倍数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.由于sin和cos是一对正交基，所以所有的信号都可以分解成正弦信号与余弦信号的线性叠加。</p><p>2.除了与乘以本身频率w的正余弦相同信号再在$(-\infty,+\infty)$范围上积分的结果会是非0以外，乘以其他频率信号的结果都是0.通过这个特性可以将是否含有w频率信号鉴别出</p><p>2.傅里叶变化的基函数$e^{jwt}$由欧拉公式可分解为$e^{-j w t}=\cos (w t)-j \sin (w t)$,所以根据公式:$X(w)=\int_{-\infty}^{+\infty} x(t) \cos (w t) d t-j \int_{-\infty}^{+\infty} x(t) \sin (w t) d t$，前部分乘以cos(wt)能挑出cos成分中的信号频率，后部分乘以的sin(wt)能挑出sin成分中的信号频率。再将挑出的各信号频率线性叠加的结果就是分解信号总的含有各谐波分量的频率</p><hr><h2 id="二-傅里叶变换（FT）的缺点与短时傅里叶变换（STFT）"><a href="#二-傅里叶变换（FT）的缺点与短时傅里叶变换（STFT）" class="headerlink" title="二.傅里叶变换（FT）的缺点与短时傅里叶变换（STFT）"></a>二.傅里叶变换（FT）的缺点与短时傅里叶变换（STFT）</h2><h3 id="离散傅里叶变换（DFT）"><a href="#离散傅里叶变换（DFT）" class="headerlink" title="离散傅里叶变换（DFT）"></a>离散傅里叶变换（DFT）</h3><p>在本文正式开始之前，我们需要明确一下实际信号进行的FT的一些特殊之处。实际采集的信号往往是这样的：</p><p><img src="https://pic4.zhimg.com/80/v2-fb5df4498e5bd43450ec0476c56129f3_hd.jpg" alt="img"></p><p>实际的信号往往具有两个特点：</p><p>1、<strong>离散性</strong>，就是采集数据不连续，很容易理解，采集信号肯定是一个一个数据采集的；</p><p>2、<strong>有限性</strong>，虽然理想的傅里叶变换是从 $(-\infty,+\infty)$ 进行积分，但是实际信号往往实在一个区间内(a,b)的。</p><p>所以，我们要用到离散傅里叶变换（DISCRETE FOURIER TRANSFORM，简称DFT），DFT与FT相比，就是多了两个特征：<strong>1、离散型，2、有限性</strong>。</p><p>我们来一起试一试如何推导DFT公式。首先设采集了N个信号点，其时刻为 $t_{0}, t_{1}, \ldots t_{N-1}$，对应时刻采集到的信号值为$x\left(t_{0}\right), x\left(t_{1}\right), \ldots x\left(t_{N-1}\right)$ 。很自然的，原来信号连续，是积分，现在数据离散了，那就是把积分变成累加。于是我们得到： $X(w)=\sum_{i=0}^{N-1} x\left(t_{i}\right) e^{-j w t_{i}}$</p><p>这么一来，我们发现，原信号有N个数据点，DFT变换后的信号却变成连续的了，我们将之称为<strong>离散时间傅里叶变换（</strong>DISCRETE TIME FOURIER TRANSFORM，简称<strong>DTFT）</strong>。</p><p>DTFT有两个缺点，第一， <img src="https://www.zhihu.com/equation?tex=w+%5Cin+%28-%5Cinfty%2C%2B%5Cinfty%29" alt="[公式]"> 且连续，需要进行无数次计算，计算机无法计算；第二，在进行计算的时候，我们需要已知：$t_{0}, t_{1}, \ldots t_{N-1}$和 $x\left(t_{0}\right), x\left(t_{1}\right), \ldots x\left(t_{N-1}\right)$ ，但是调用过FFT函数的同学都知道，FFT只需要已知$x\left(t_{0}\right), x\left(t_{1}\right), \ldots x\left(t_{N-1}\right)$就可以进行。</p><p>这是怎么回事呢？</p><p>首先，我们<strong>使用相对采样时间 <img src="https://www.zhihu.com/equation?tex=n+%3D+0%2C1%2C...N-1" alt="[公式]"> 代替真实采样时间 <img src="https://www.zhihu.com/equation?tex=t_0%2Ct_1%2C...t_%7BN-1%7D" alt="[公式]"> ，</strong>可以得到： <img src="https://www.zhihu.com/equation?tex=X%28w%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-jwn%7D" alt="[公式]"> 。</p><p>此时我们发现， $X(w)$ 变成了以 $2\pi$为周期的函数，即 <img src="https://www.zhihu.com/equation?tex=X%28w%2B2%5Cpi%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-j%28w%2B2%5Cpi%29n%7D+%3D++%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-jwn%7De%5E%7B-j2%5Cpi+n%7D+%3D++%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-jwn%7D+%3D+X%28w%29" alt="[公式]"></p><p>那么，我们只需要计算 $w \in(0,2 \pi)$ 区间的 $X(w)$ ，就可以得到 $w \in(-\infty,+\infty)$ 区间的$X(w)$了。也就是说，通过使用相对采样时间 <img src="https://www.zhihu.com/equation?tex=n+%3D+0%2C1%2C...N-1" alt="[公式]"> 代替真实采样时间$t_{0}, t_{1}, \ldots t_{N-1}$，我们将 <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> 的范围从 $(-\infty,+\infty)$ 缩小到了(0,$2\pi$).</p><p>自然地，我们希望将(0,$2\pi$)离散化称为N个点，这样计算机就可以计算了！则取$w=\frac{2 \pi k}{N}, k=0,1, \ldots N-1$，则有： $X(k)=\sum_{n=0}^{N-1} x(n) e^{-j \frac{2 \pi k}{N} n}, k=0,1 \ldots N-1$</p><p>好了，这就是<strong>离散傅里叶变换DFT</strong>了！</p><p>接下来，来看DFT的两个性质：</p><ul><li><p>第一， <img src="https://www.zhihu.com/equation?tex=X%280%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29" alt="[公式]"> ，即 <img src="https://www.zhihu.com/equation?tex=X%280%29" alt="[公式]"> 是所有元素的和，通常会比其他的元素大几个数量级。</p></li><li><p>第二， <img src="https://www.zhihu.com/equation?tex=X%281%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-j+2%5Cpi%5Cfrac%7B1%7D%7BN%7D+n%7D" alt="[公式]"> ，<img src="https://www.zhihu.com/equation?tex=X%28N-1%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-j+2%5Cpi%5Cfrac%7BN-1%7D%7BN%7D+n%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=X%281%29+%3D+%5Ctilde%7BX%28N-1%29%7D" alt="[公式]"> ，即第二个元素和最后一个元素共轭，同理有<img src="https://www.zhihu.com/equation?tex=X%282%29+%3D+%5Ctilde%7BX%28N-2%29%7D" alt="[公式]"> 等等。</p></li></ul><p>如下图所示，DFT之后的N 个元素中，第一个为均值；之后的 N-1个元素，只有一半元素是独立的。</p><p><img src="https://pic3.zhimg.com/80/v2-7779743b0ad81ce875fe42c0f69adbc2_hd.jpg" alt="img"></p><p>需要说明，这里 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 是一种相对频率，独立元素中，最小相对频域为1，最大相对频率为 $\frac{N}{2}$ 。<strong>要想把</strong> <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> <strong>还原到真实的频率</strong> <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> <strong>，只需要 <img src="https://www.zhihu.com/equation?tex=w+%3D+%5Cfrac%7Bk-1%7D%7BN%7DFs" alt="[公式]"> ，将</strong> <img src="https://www.zhihu.com/equation?tex=k%3D1%2C2...%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> <strong>映射到</strong> <img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29" alt="[公式]"> <strong>即可</strong>， <img src="https://www.zhihu.com/equation?tex=Fs" alt="[公式]"> <strong>为采样频率。</strong></p><p>PS：简单说一下，根据香农采样定理，当采样频率为 <img src="https://www.zhihu.com/equation?tex=Fs" alt="[公式]"> 时，能采到的最大信号频率为<img src="https://www.zhihu.com/equation?tex=%5Cfrac%7BFs%7D%7B2%7D" alt="[公式]">。因此，将相对频率 <img src="https://www.zhihu.com/equation?tex=k%3D1%2C2...%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> 通过公式 <img src="https://www.zhihu.com/equation?tex=w+%3D+%5Cfrac%7Bk-1%7D%7BN%7DFs" alt="[公式]"> ，得到的 <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> 就在区间<img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29" alt="[公式]">内，也就是真实频率的区间了。</p><p>所以DFT公式为： <img src="https://www.zhihu.com/equation?tex=X%28k%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-j%5Cfrac%7B2%5Cpi+k%7D%7BN%7Dn%7D%2C+k+%3D+0%2C1...N-1" alt="[公式]"></p><p>PS：DFT公式的形式很多，有的是从时域到频域，有的是从空间域到频域，但是本质都是一样的，抓住<strong>离散性</strong>和<strong>有限性</strong>两个特点即可。<strong>离散性是指积分变成了累加，有限性是指积分/累加区间不是 $(-\infty,+\infty)$ 了，而是一个有限区间了。</strong></p><h3 id="傅里叶变换（FT）的缺点"><a href="#傅里叶变换（FT）的缺点" class="headerlink" title="傅里叶变换（FT）的缺点"></a><strong>傅里叶变换（FT）的缺点</strong></h3><p>应该说明，虽然本小节的题目是FT的缺点，但是FT和DFT的本质是相同的。由于信号都是有限长度的、离散的，所以接下来进行的都是DFT，不过在某些部分为了方便理解，还是写了FT的公式。在看本文的时候，你不需要刻意区分这两个概念。</p><p>我们现在来看两个信号，如下图：</p><p>$y 1=\sin (5 t) <em>(0&lt;t&lt;25)+\sin (t) </em>(25&lt;t&lt;50)$<br>$y 2=\sin (t) <em>(0&lt;t&lt;25)+\sin (5 t) </em>(25&lt;t&lt;50)$</p><p><img src="https://pic3.zhimg.com/80/v2-023a9ca6d0985e9dc271a08a199269de_hd.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-4ea09915e3f6f18391df410eab709da4_hd.jpg" alt="img"></p><p>这两个信号都是由sin(t)和sin(5t)组成的，y1是先出现了sin(5t)，再出现了sin(t)，y2是先出现了sin(t)，再出现了sin(5t)。</p><p>我们对它们进行FT，看看他们包含怎么样的频率，如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-8a1cd705a0354cb0cbeb067e1f7ce992_hd.jpg" alt="img">                                                                    y1,FT</p><p><img src="https://pic1.zhimg.com/80/v2-c95d1c9d11a72b51447425f5fbd0e0c8_hd.jpg" alt="img">                                                                        y2,FT</p><p>Amazing！发现了什么？<strong>变换后的结果是一模一样的，都在w=1rad/s和w=5rad/s出现了峰值！这就可以说明FT的缺点了——FT只能提供频域信息，而完全丢失了时域信息！！！</strong></p><p><strong>不管某一频率的信号出现的时间是早还是晚，FT都是将它一视同仁地乘上sin和cos(FT的变换基函数)，然后在整个时间区间加和。因此，它不能提供某一频率信号出现的时间。</strong></p><p>比如，对于上面两个信号，FT只能告诉我们，它们都有1rad/s和5rad/s的频率，而不能告诉我们1rad/s和5rad/s分别出现在哪个时间段。</p><p>所以，怎么办呢？？？</p><p><strong>那就是把信号分成左右两半啊！左边进行一次FT，右边进行一次FT，很简单吧！好了，这就是短时傅里叶变换（STFT）的基本原理。</strong></p><p>所以，接下来我们要正式开始步入——短时傅里叶变换（STFT），看看它是如何解决这个问题的。</p><h3 id="短时傅里叶变换（STFT）"><a href="#短时傅里叶变换（STFT）" class="headerlink" title="短时傅里叶变换（STFT）"></a><strong>短时傅里叶变换（STFT）</strong></h3><p>如上所述，我们将信号从中间截断，左边进行一次FT，右边进行一次FT，分别来看看。</p><p><img src="https://pic4.zhimg.com/80/v2-43e0b0a1d3e8758f32fc784a35b00183_hd.jpg" alt="img">y1左</p><p><img src="https://pic3.zhimg.com/80/v2-6ccbe7a93f390033d4444a949bcd356e_hd.jpg" alt="img">y1右</p><p><img src="https://pic2.zhimg.com/80/v2-271124958efcef10cd9a370d3f5061b9_hd.jpg" alt="img">y2左</p><p><img src="https://pic4.zhimg.com/80/v2-417fda7319483f84086bc73b299c5b03_hd.jpg" alt="img">y2右</p><p>可以看出，y1的左半部分是5rad/s，右半部分是1rad/s，y2恰好相反。这就说明，在y1中，(0, 25)的信号是5rad/s的频率，(25, 50)的信号是5rad/s的频率，y2恰好相反。<strong>这就是短时傅里叶变换的基本原理。</strong></p><p>但是数学嘛，能用一个公式表达的，就别用一段话表达，截断、切开这些语句太不专业了。<strong>截断、切开的操作，更专业的讲叫作分窗，其实是可以通过数学上的处理变成DFT变换的基函数的一部分的。接下来我们来看一看。</strong></p><p>首先，你可以想象一下，有一个窗子在这个信号上从左向右滑动，每次你都只能看到这个信号的一部分，<strong>所以我们把这个长度叫作窗长width。</strong></p><p>现在我们来定义一个方窗函数$y_{\text {window}}=1 *(-\text {width} / 2&lt;t&lt;\text {width} / 2)$ ，如下图，即是width = 10 的一个方窗函数：</p><p><img src="https://pic2.zhimg.com/80/v2-bd998377f53a5dffc8546cf019d119a1_hd.jpg" alt="img"></p><p>定义了方窗函数之后，我们<strong>只需要对方窗函数进行平移，再与原信号作乘，就相当于原来的截断、切开的操作，因此这种操作更专业地叫作分窗。</strong></p><p>那么，<strong>将方窗函数向右平移了 <img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]">（s可能是sliding的意思吧），再与原信号相乘，由于方窗函数除了中心的width部分是1外，其他部分都是0，这就相当于提取出了原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处，宽度为width的部分</strong>，这个信号分窗这个操作就可以写成： <img src="https://www.zhihu.com/equation?tex=y_%7Bwindow%7D%28t+-+t_s%29++y%28t%29" alt="[公式]"> 。</p><p>如下两图所示，将 <img src="https://www.zhihu.com/equation?tex=y%28t%29%3Dsin%285t%29" alt="[公式]"> 与 <img src="https://www.zhihu.com/equation?tex=y_%7Bwindow%7D%28t+-+25%29" alt="[公式]"> 相乘，就相当于取出来了 <img src="https://www.zhihu.com/equation?tex=y%28t%29%3Dsin%285t%29" alt="[公式]"> 中的(20,30)中的一段。</p><p>那么，我们对原信号中被提取出来的这一部分进行FT，就可以写成： $X\left(w, t_{s}\right)=\int_{-\infty}^{+\infty} y_{w i n d o w}\left(t-t_{s}\right) y(t) e^{-j w\left(t-t_{s}\right)} d t$</p><p>PS：这里之所以 <img src="https://www.zhihu.com/equation?tex=e%5E%7B-jwt%7D" alt="[公式]"> 要变成 <img src="https://www.zhihu.com/equation?tex=e%5E%7B-jw%28t-t_s%29%7D" alt="[公式]"> ，是为了保证做FT的时候相乘的基函数具有统一性。</p><p>如此，变换后的<img src="https://www.zhihu.com/equation?tex=X%28w%2Ct_s%29" alt="[公式]">代表<strong>原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处、宽度为width的部分的傅里叶变换</strong>，也就可以提取出来<strong>原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处、宽度为width的部分，包含各个频率部分的多少！带入不同的</strong> <img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"> <strong>，也就是随着窗子的滑动，就可以知道不同的时间段内频率的成分。</strong></p><p>我们采用width为10的方窗函数对$y 3=\sin (20 t) <em>(0&lt;t&lt;25)+\sin (t) </em>(25&lt;t&lt;50)$进行STFT，如下：</p><p>首先，方窗函数位于 <img src="https://www.zhihu.com/equation?tex=t+%3D+5s" alt="[公式]"> 处，与原始信号相乘，选择出(0,10)的信号。</p><p><img src="https://pic4.zhimg.com/80/v2-9c184aa29068c665f5ead3439d42cd0b_hd.jpg" alt="img"></p><p>对选择出来的信号进行FT。可以看到，当t=5s时，选择的时间区间为(0,10)，这一部分只包含了 <img src="https://www.zhihu.com/equation?tex=w+%3D+20rad%2Fs" alt="[公式]"> 的频率成分。</p><p><img src="https://pic4.zhimg.com/80/v2-ec4cc9c93dc4d7b763ac5843fd02be8b_hd.jpg" alt="img"></p><p>之后，方窗函数向右移动，与原始信号相乘，选择出不同时间区间的信号，进行FT。这里选择t=25s进行展示。</p><p><img src="https://pic1.zhimg.com/80/v2-6df4bbf241bd086b20e7db05a31cf7d0_hd.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-3bd9b031d41ce1e3349d762e74b850fa_hd.jpg" alt="img"></p><p>可以看到，当t=25s时，选择的时间区间为(20,30)，这一部分即包含了 <img src="https://www.zhihu.com/equation?tex=w+%3D+20rad%2Fs" alt="[公式]"> 的频率成分，也包含了 <img src="https://www.zhihu.com/equation?tex=w+%3D+1rad%2Fs" alt="[公式]"> 的频率成分。</p><p>重复以上过程，我们可以<strong>将方窗函数选择的不同时间区间的信号的FT的结果拼合起来，形成一张三维图</strong>。由此，我们即可知道，<strong>在 <img src="https://www.zhihu.com/equation?tex=%28t_s-width%2F2%2C+t_s%2Bwidth%2F2%29" alt="[公式]"> 的时间区间内，信号具有怎么样的频率成分。</strong></p><p><img src="https://pic4.zhimg.com/80/v2-389958865460686e1d15a0b2f9ddb277_hd.jpg" alt="img"></p><p>通过width = 10的方窗的STFT结果，我们可以知道，对于信号：<img src="https://www.zhihu.com/equation?tex=y3%3Dsin%2820t%29%2A%280%3Ct%3C25%29%2Bsin%28t%29%2A%2825%3Ct%3C50%29" alt="[公式]"> ，在(0,10)、(10,20)时间区间内，具有20rad/s的频率成分；在(20,30)时间区间内，具有1rad/s和20rad/s的频率成分；在(30,40)、(40,50)时间区间内，具有1rad/s的频率成分。</p><p>最后，进行三点重要的讨论。</p><p>第一点，<strong>变换之后的</strong> <img src="https://www.zhihu.com/equation?tex=X%28w%2Ct_s%29" alt="[公式]"> <strong>是一个三维函数，它有两个自变量，</strong> <img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"> <strong>和w。</strong><img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"> 指的是<strong>原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处，</strong>w上一篇文章我们已经讨论过了，就是频率。所以，STFT提取出来的信息就是：<strong>原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处、宽度为width的部分，包含的频率信息。</strong></p><p><strong>原则上讲，可以得到任一<img src="https://www.zhihu.com/equation?tex=+t_s" alt="[公式]">对应的频率成分，如下图。</strong></p><p><img src="https://pic2.zhimg.com/80/v2-dccf7c6b239c4777b934a1c871f86aed_hd.jpg" alt="img"></p><p><strong>但是</strong> <strong><img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"> 是连续的，并不意味着你知道了每个时刻的频率成分，你知道的还只是 <img src="https://www.zhihu.com/equation?tex=%28t_s-width%2F2%2C+t_s%2Bwidth%2F2%29" alt="[公式]">这一段区间内的频率信息。所以一般不需要计算所有的</strong> <img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"><strong>，每隔width计算一次即可。</strong></p><p>你或许会想，我<strong>把width缩小一些，不就可以知道更精确的时间范围内的频率了吗？</strong>是的，你的猜想很对！但是，<strong>如此做也会带来一些频域分辨率的问题。</strong>这一点涉及到一些时域分辨率和频域分辨率的知识，我们下一篇文章会着重讲。</p><h4 id="本质变化"><a href="#本质变化" class="headerlink" title="本质变化:"></a>本质变化:</h4><p>第二点，<strong>方窗函数是可以包含入变换基函数内部的，这组成了新的基函数，同时反映了STFT的本质。</strong></p><p>我们来看， 如果定义 <img src="https://www.zhihu.com/equation?tex=%5Cphi+%28t%29+%3D+e%5E%7B-jwt%7D+y_%7Bwindow%7D%28t%29" alt="[公式]"> ，那么<img src="https://www.zhihu.com/equation?tex=%5Cphi+%28t+-+t_s%29+%3D+e%5E%7B-jw%28t-+t_s%29%7D+y_%7Bwindow%7D%28t-+t_s%29" alt="[公式]"></p><p>那么，STFT的公式： <img src="https://www.zhihu.com/equation?tex=X%28w%2Ct_s%29+%3D++%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7Dy_%7Bwindow%7D%28t+-+t_s%29++y%28t%29e%5E%7B-jw%28t-+t_s%29%7Ddt" alt="[公式]"> 就可以写成： <img src="https://www.zhihu.com/equation?tex=X%28w%2C+t_s%29++%3D++%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7Dy%28t%29%5Cphi%28t+-+t_s%29+dt" alt="[公式]"></p><p>我们在上一篇文章里说过，<strong>变换就是将原信号乘上一个基函数，再积分的过程，那么，SDFT的基函数就是 <img src="https://www.zhihu.com/equation?tex=%5Cphi%28t%29+%3D+e%5E%7B-jwt%7D+y_%7Bwindow%7D%28t%29" alt="[公式]"> ！</strong></p><p>Amazing！所以，STFT的本质是什么呢？</p><p><strong>STFT的本质就是将FT的基函数 <img src="https://www.zhihu.com/equation?tex=e%5E%7B-jwt%7D" alt="[公式]"> 乘上一个方窗函数，形成了一个新的基函数<img src="https://www.zhihu.com/equation?tex=%5Cphi%28t%29+%3D+e%5E%7B-jwt%7D+y_%7Bwindow%7D%28t%29" alt="[公式]"> ！</strong>前面说的分窗、截断之类的都是表象，<strong>STFT的本质是基函数的改变！</strong></p><p>那么，为什么STFT的基函数可以用于分窗，而FT的基函数不行呢？我们来看，我用正弦函数sin(5t)表示原来的基函数<img src="https://www.zhihu.com/equation?tex=e%5E%7B-jwt%7D" alt="[公式]"> ，那么FT基函数和STFT基函数如下：</p><p><img src="https://pic4.zhimg.com/80/v2-9fb003e0c1ca9b79cba81b58a6d06003_hd.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-02cb52f656bb597ba81ea90af534044b_hd.jpg" alt="img"></p><p>原因就是：FT的基函数是在时域无限延伸的，因此，无论怎么平移，都是任分布在整个时域的，起不到分窗的作用。<strong>而STFT的基函数只在时域一段不为0，在剩下的时域都是0，因此，STFT的基函数的平移，就相当于自动加了窗子啦！</strong></p><h4 id="紧支撑性"><a href="#紧支撑性" class="headerlink" title="紧支撑性:"></a>紧支撑性:</h4><p><strong>这种只在时域一段不为0，在剩下的时域都是0的性质被称为“紧支撑性”（compactly supported），具有这种性质的函数，平移之后与一个信号相乘，就相当于分窗操作。这一点很重要，我们之后讲小波变换的基函数的时候还会讲。</strong></p><p>第三点，<strong>我们前面对于分窗操作使用的函数一直称为“方窗函数”</strong>，这是一种最理想的窗函数。<strong>还有一些其他的窗函数，比如，汉宁窗、海明窗、高斯窗等</strong>。窗函数本质都是一个窗子而已，原理是一模一样的，上面所有的讨论也都成立，只是这些窗子会让信号稍稍变形一丢丢而已。你就想像方窗函数就是一面平面镜，其他的窗函数就是哈哈镜就行了。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h3><p>Q:为什么要用相对采样时间代替真实采样时间?</p><p>A:原来做傅立叶变换，既需要知道真实采样时间，也需要知道采样数据，用相对采样时间替代真实采样时间之后，只需要知道采样数据。这极大地拓展了傅立叶变换的使用范围。比如，并不是所有傅立叶变换的对象都可以具有真实采样时间。一副图像也是可以傅立叶变换的，但是在图像里，并没有采样时间这个概念，只有0123456这些像素索引值，对图像做傅立叶变换，就是把索引值作为相对采样时间。</p><hr><h2 id="三-短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）"><a href="#三-短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）" class="headerlink" title="三.短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）"></a>三.短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）</h2><p><strong>三、短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）</strong></p><p><strong>1、分辨率问题</strong></p><p>首先，我们需要了解一下海德堡测不准原理： <img src="https://www.zhihu.com/equation?tex=%5CDelta+t%5CDelta+f+%3E+C" alt="\Delta t\Delta f &gt; C"> ， <img src="https://www.zhihu.com/equation?tex=%5CDelta+t" alt="\Delta t"> 为信号的时间不确定度， <img src="https://www.zhihu.com/equation?tex=%5CDelta+f" alt="\Delta f"> 为信号的频率不确定度。即，我们永远<strong>无法同时确定一个信号的确切时间和确切频率。</strong></p><p>原因比较简单，频率其实就是时域周期性。如果我只给你一个数据点，问你这个数据点的频率是多少，这肯定是做不到的。<strong>要确定频率，就需要一个时域区间（包含几个时域周期）的信号。</strong></p><p>时域区间越宽，信号的时间定位越不准，时间不确定度 <img src="https://www.zhihu.com/equation?tex=%5CDelta+t" alt="\Delta t"> 越大，但是得到的频率越准，频率不确定度<img src="https://www.zhihu.com/equation?tex=%5CDelta+f+" alt="\Delta f "> 越小；我们称之为：<strong>低的时域分辨率，高的频域分辨率。</strong></p><p>时域区间越窄，信号的时间定位越准，时间不确定度 <img src="https://www.zhihu.com/equation?tex=%5CDelta+t" alt="\Delta t"> 越小，但是得到的频率越不准，频率不确定度 <img src="https://www.zhihu.com/equation?tex=%5CDelta+f+" alt="\Delta f "> 越大；我们称之为：<strong>高的时域分辨率，低的频域分辨率。</strong></p><p><img src="https://pic4.zhimg.com/80/v2-a6610ab6df91401343647ba4b27363db_hd.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-36716e2b22423bae8d2ff5bcbf796324_hd.jpg" alt="img"></p><p>如上两图，对于第一个图中 <img src="https://www.zhihu.com/equation?tex=sin%280.5t%29" alt="sin(0.5t)"> 的信号，要确定频率，即使把 <img src="https://www.zhihu.com/equation?tex=%280%2C20%29" alt="(0,20)"> 都拿来，还是不太准，因为只包含了一个周期；对于第二个图中 <img src="https://www.zhihu.com/equation?tex=sin%285t%29" alt="sin(5t)"> 的信号，要确定频率，取个 <img src="https://www.zhihu.com/equation?tex=%280%2C5%29" alt="(0,5)"> 就差不多了，因为已经包含了好几个周期了。</p><p>我们来总结一下。</p><p>对于低频信号，为了更好地确定频率，我们希望，时域区间宽一些，即时间不确定度 <img src="https://www.zhihu.com/equation?tex=%5CDelta+t" alt="\Delta t"> 大一些，根据海德堡测不准原理，频率不确定度<img src="https://www.zhihu.com/equation?tex=%5CDelta+f+" alt="\Delta f "> 自然小一些；即<strong>低频信号，我们希望：宽窗子，低的时域分辨率，高的频域分辨率。</strong></p><p>对于高频信号，为了更好地在时域定位，我们希望，时域区间窄一些，即时间不确定度 <img src="https://www.zhihu.com/equation?tex=%5CDelta+t" alt="\Delta t"> 小一些，根据海德堡测不准原理，频率不确定度<img src="https://www.zhihu.com/equation?tex=%5CDelta+f+" alt="\Delta f "> 自然大一些；即<strong>高频信号，我们希望：窄窗子，高的时域分辨率，低的频域分辨率。</strong></p><p><img src="https://pic2.zhimg.com/80/v2-21c6a20541f75b7789039730c3ba9691_hd.jpg" alt="img"></p><p>上图所示是我们希望的动态分辨率。图中每个小矩形的 <img src="https://www.zhihu.com/equation?tex=Time" alt="Time"> 轴方向的宽度是时间区间大小， <img src="https://www.zhihu.com/equation?tex=Frequency" alt="Frequency"> 轴方向的宽度是频率区间大小。注意，每个小矩形的面积是相等的，这保证了时域分辨率乘上频域分辨率是定值，最大程度满足海德堡测不准原理。通过图可以看出，我们希望，<strong>对于低频信号：低的时域分辨率，高的频域分辨率；对于高频信号：高的时域分辨率，低的频域分辨率。</strong></p><p>对于整体低频、局部高频的信号，这种动态调整分辨率的规则特别有用。在实际信号中，频率非常高的高频信号往往是一种噪声，只在局部出现，基本都满足整体低频、局部高频这一条件。</p><p>最后，我们再来看两张分辨率图来强化一下对于分辨率的理解。</p><p><img src="https://pic2.zhimg.com/80/v2-5fcb8ea67c4dd7d0cd8af79cb5cdc561_hd.jpg" alt="img"></p><p>上图是一张采集信号的分辨率图。每个小矩形的 <img src="https://www.zhihu.com/equation?tex=Time" alt="Time"> 轴方向的宽度是很小， <img src="https://www.zhihu.com/equation?tex=Frequency" alt="Frequency">轴方向的宽度很大。也就是说，<strong>其时域分辨率很好，可以确切地确定每个信号采样点的时间，但是其频域分辨率很差，或者说完全不具有频域分辨率。</strong></p><p><img src="https://pic3.zhimg.com/80/v2-dfa64287fea73b71b2fde5acf491b1be_hd.jpg" alt="img"></p><p>上图是一张傅里叶变换（FT）的分辨率图。每个小矩形的 <img src="https://www.zhihu.com/equation?tex=Time" alt="Time"> 轴方向的宽度是很大， <img src="https://www.zhihu.com/equation?tex=Frequency" alt="Frequency"> 轴方向的宽度很小。也就是说，<strong>其频域分辨率很好，可以比较精确地确定信号中的频率成分，但是其时域分辨率很差，或者说完全丢失了时域分辨率。</strong></p><p>傅里叶变换的这一特性，这一点我在上一篇文章里讲过，这也是我们转而使用短时傅里叶变换（STFT）的原因。</p><p><strong>2、短时傅里叶变换（STFT）的缺点</strong></p><p>我们来回忆一下STFT（详见：<a href="https://zhuanlan.zhihu.com/p/66246381" target="_blank" rel="noopener">1335：从傅里叶变换进阶到小波变换（二）</a>），STFT的窗长是固定的，即时域分辨率是固定的，根据海德堡测不准原理，其频域分辨率也是固定的。其分辨率图如下：</p><p><img src="https://pic3.zhimg.com/80/v2-65ff13878c7d01a12deb42e2f3fd0ce6_hd.jpg" alt="img"></p><p>每个小矩形的 <img src="https://www.zhihu.com/equation?tex=Time" alt="Time"> 轴方向的宽度和<img src="https://www.zhihu.com/equation?tex=Frequency" alt="Frequency"> 轴方向的宽度是恒定的！也就是说，不论高频低频，其时域和频域分辨率都不可调，这与我们之前讨论的“对于低频信号：低的时域分辨率，高的频域分辨率；对于高频信号：高的时域分辨率，低的频域分辨率”这一原则不符合。</p><p>这种不符合会带来什么后果呢？</p><p>如图所示正弦信号，0~250ms：300HZ，250~500ms：200HZ ，500~750ms：100HZ ， 750~1000ms：50HZ。</p><p><img src="https://pic4.zhimg.com/80/v2-318f8c13aaeb3d6a2cd468ab8501f99f_hd.jpg" alt="img">)</p><p>选择一个较窄的窗子<img src="https://www.zhihu.com/equation?tex=width+%3D+0.02" alt="width = 0.02"> 做STFT，结果如下：</p><p><img src="https://pic1.zhimg.com/80/v2-69b82763a3aee3f97d70b53c42737734_hd.jpg" alt="img"></p><p>当窗子较窄的时候，STFT的时域分辨率还行，但是频域分辨率不佳。</p><p>我们选择一个宽一些的窗子 <img src="https://www.zhihu.com/equation?tex=width+%3D+0.1" alt="width = 0.1"> 做STFT，结果如下：</p><p><img src="https://pic1.zhimg.com/80/v2-8c698423bfab908971ca6604643ff4f8_hd.jpg" alt="img"></p><p>当窗子较宽的时候，STFT的频域分辨率很好，基本可以确定频率，但是时间轴上开始出现交叠了，也就是时域分辨率下降了。</p><p>我们选择一个更宽的窗子 <img src="https://www.zhihu.com/equation?tex=width+%3D+0.3" alt="width = 0.3"> 做STFT，结果如下：</p><p><img src="https://pic4.zhimg.com/80/v2-acaf61759eb23c708094463a6060f667_hd.jpg" alt="img"></p><p>当窗子更宽的时候，STFT的频域分辨率非常好了，但是时域分辨率已经很差了，时间轴上出现了大规模的交叠现象。</p><p>我们来总结一下，对于STFT，如果窗子的宽度选择合适，是可以得到时域和频域分辨率都“还可以”的结果的（由于STFT的分辨率固定，只能说“还可以”，不能说“满意”，因为我们最想要的是动态分辨率）。但是，在变换之前，我们也不知道选择多宽的窗子是合适的。</p><p>这就是STFT的缺点：<strong>1、时间和频率分辨率都固定，不能随着频率的高低实现动态可调；2、选择一个合适的窗宽十分困难。</strong></p><p><strong>3、连续小波变换（CWT）</strong></p><p>为了实现动态分辨率，我们引入了小波母函数。</p><p>需要说明，小波母函数并不是一个特定的函数，而是一种函数的集合，满足了一定条件的函数均可以作为小波母函数。小波母函数 <img src="https://www.zhihu.com/equation?tex=%5Cpsi%28t%29" alt="\psi(t)"> 需要满足的有：</p><p>条件1，紧支撑性： <img src="https://www.zhihu.com/equation?tex=%5Cexists+a+%3E0+%2C+%5Cforall+%7Ct%7C%3Ea%2C+%5Cpsi%28t%29+%3D+0" alt="\exists a &gt;0 , \forall |t|&gt;a, \psi(t) = 0"> ，即<strong>仅在一小部分定义域里不为0</strong>，剩下部分均为0。这个性质带来的便利我们在前一篇文章讲过了，就是<strong>具有紧支撑性的基函数，在原信号的时间轴上平移，就相当于对于原信号就行了加窗操作。</strong></p><p>条件2，波动性： <img src="https://www.zhihu.com/equation?tex=%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7D%5Cpsi%28t%29+dt+%3D+0" alt="\int_{-\infty}^{+\infty}\psi(t) dt = 0"> ，即在所有定义域内积分值为0，这说明小波母函数是一个波。</p><p>条件3，容许条件： <img src="https://www.zhihu.com/equation?tex=c_%5Cpsi+%3D+2%5Cpi+%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D+%5Cfrac%7B%7C%5Ctilde%7B%5Cpsi%28f%29%7D%7C%5E2%7D%7B%7Cf%7C%7Ddf+%3C+%2B%5Cinfty" alt="c_\psi = 2\pi \int_{-\infty}^{\infty} \frac{|\tilde{\psi(f)}|^2}{|f|}df &lt; +\infty"> ，这个条件使变换可逆。其中， <img src="https://www.zhihu.com/equation?tex=%5Ctilde%7B%5Cpsi%28f%29+%7D" alt="\tilde{\psi(f) }"> 是小波函数傅里叶变换的共轭。由3可知 <img src="https://www.zhihu.com/equation?tex=%5Cpsi%28f%29%7C_%7Bf+%3D+0%7D+%3D+0" alt="\psi(f)|_{f = 0} = 0"> ，也就是条件2。</p><p>条件4，正交性：这个条件也是为了使变换可逆。</p><p>PS：条件3、4的数学证明比较复杂，所以仅仅提了一下他们的作用，就是使得变换可逆。</p><p><img src="https://pic1.zhimg.com/80/v2-6df078be94ca2129af2bba0298599c88_hd.jpg" alt="img"></p><p>上图就是一个小波母函数的例子，我们看到了：</p><p>1、紧支撑性：<strong>仅在一小部分定义域里不为0</strong>，剩下部分均为0；2、波动性： 在所有定义域内积分值为0。这两个条件是满足的。</p><p>小波母函数既然是一个波，那么就具有频率。根据我们第一篇文章讲的内容（<a href="https://zhuanlan.zhihu.com/p/66189212" target="_blank" rel="noopener">1335：从傅里叶变换进阶到小波变换（一）</a>），将小波母函数作为基函数，与采集到的信号相乘并积分，可以筛选出：<strong>信号在小波母函数非0部分，频率与小波母函数相近的成分。</strong></p><p>需要说明，不同于FT的基函数 <img src="https://www.zhihu.com/equation?tex=sin%2Ccos" alt="sin,cos"> ，小波母函数不具有特定的某一频率，而是具有一个范围内的频率，因此筛选的是一定范围的频率，类似于一个带通滤波器。</p><p>接下来我们讲一讲，小波母函数的变换，变换公式如下：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cpsi%5E%2A%28%5Ctau%2C%F0%9D%91%A0%29%3D++%5Cfrac%7B1%7D%7B%5Csqrt%7B%F0%9D%91%A0%7D%7D+%5Cpsi%28%5Cfrac%7B%F0%9D%91%A1%7D%7B%7B%F0%9D%91%A0%7D%7D%E2%88%92%5Ctau%29" alt="\psi^*(\tau,𝑠)=  \frac{1}{\sqrt{𝑠}} \psi(\frac{𝑡}−\tau)"></p><p>一是平移，用上式中的 <img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="\tau"> 控制，<img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="\tau">改变，就相当于 <img src="https://www.zhihu.com/equation?tex=%5Cpsi%28t%29" alt="\psi(t)"> 在时间轴上不断的平移。</p><p>二是缩放，用上式中的 <img src="https://www.zhihu.com/equation?tex=s" alt="s"> 控制。</p><p>变换后的函数 <img src="https://www.zhihu.com/equation?tex=%5Cpsi%5E%2A%28%5Ctau%2C%F0%9D%91%A0%29" alt="\psi^*(\tau,𝑠)"> 称为小波函数。</p><p>如下图，<strong>中间的图，<img src="https://www.zhihu.com/equation?tex=s" alt="s">较小，相当于挤压；右侧的图，</strong> <img src="https://www.zhihu.com/equation?tex=s" alt="s"> <strong>较大，相当于拉伸。</strong>变换公式前的<img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B%5Csqrt+s%7D" alt="\frac{1}{\sqrt s}">是为了能量守恒，没有特别目的。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;948&#39; height=&#39;234&#39;&gt;&lt;/svg" alt="img"></p><p>我们再来仔细观察一下上图。<strong>中间的图，</strong><img src="https://www.zhihu.com/equation?tex=s" alt="s"><strong>较小，相当于挤压，是不是频率提高了？右侧的图，</strong><img src="https://www.zhihu.com/equation?tex=s" alt="s"><strong>较大，相当于拉伸，是不是频率降低了？</strong>咦？有点意思了吧？缩放就是改变频率！另外，<strong>一定记住， <img src="https://www.zhihu.com/equation?tex=s" alt="s"> 越大，频率 <img src="https://www.zhihu.com/equation?tex=f" alt="f"> 越低， <img src="https://www.zhihu.com/equation?tex=s%2Cf" alt="s,f"> 是倒数关系。</strong></p><p>我们再来更仔细地观察一下上图。回忆一下上一篇文章，具有紧支撑性的基函数，滑动相当于分窗。那么，这个窗长有多大呢？是不是就是基函数不为零的长度呢？那么，<strong>中间的图，</strong><img src="https://www.zhihu.com/equation?tex=s" alt="s"><strong>较小，相当于挤压，频率提高了，窗长是不是变小了？右侧的图，</strong><img src="https://www.zhihu.com/equation?tex=s" alt="s"><strong>较大，相当于拉伸，频率降低了，窗长是不是变大了？</strong></p><p>这不正是我们需要的<strong>“低频，宽窗，差的时间分辨率，好的频域分辨率；高频，窄窗，好的时间分辨率，差的频域分辨率”吗？</strong></p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;474&#39; height=&#39;386&#39;&gt;&lt;/svg" alt="img"></p><p>和上图对一下，是不是一模一样了呢？这就是动态调分辨率，得来全不费工夫啊！</p><p>接下来我们对一个信号就行一次连续小波变换（CWT）。下图中蓝色部分为小波函数（但原图没画成波的形式，只是表示小波函数的时间轴位置和不为0的部分的宽度），黄色部分为信号。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;586&#39; height=&#39;496&#39;&gt;&lt;/svg" alt="img">图源：THE WAVELET TUTORIAL</p><p>如上图，选择较小的<img src="https://www.zhihu.com/equation?tex=s" alt="s"> 对小波母函数进行缩放，此时小波函数频率较高，窗子较窄（小波函数不为0的部分窄），用来筛选高频部分。小波函数在时间轴上平移，每一次平移就先相乘，再积分，筛选出信号中与自己频率相近的部分。</p><p>此时，窗子较窄（小波函数不为0的部分窄），时间分辨率好，频率分辨率差。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;587&#39; height=&#39;489&#39;&gt;&lt;/svg" alt="img">图源：THE WAVELET TUTORIAL</p><p>如上图，将<img src="https://www.zhihu.com/equation?tex=s" alt="s"> 增大，对小波母函数进行缩放，此时小波函数频率降低，窗子变宽（小波函数不为0的部分变宽），用来筛选中频部分。小波函数在时间轴上平移，每一次平移就先相乘，再积分，筛选出信号中与自己频率相近的部分。</p><p>此时，窗子变宽了（小波函数不为0的部分变宽），时间分辨率变差，频率分辨率变好。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;587&#39; height=&#39;486&#39;&gt;&lt;/svg" alt="img">图源：THE WAVELET TUTORIAL</p><p>如上图，将<img src="https://www.zhihu.com/equation?tex=s" alt="s"> 进一步增大，对小波母函数进行缩放，此时小波函数频率再次降低，窗子更宽（小波函数不为0的部分更宽），用来筛选低频部分。小波函数在时间轴上平移，每一次平移就先相乘，再积分，筛选出信号中与自己频率相近的部分。</p><p>此时，窗子很宽（小波函数不为0的部分很宽），时间分辨率差，频率分辨率很好。</p><p><strong>这就是连续小波变换CWT啦！</strong></p><p>将上述CWT的过程写成公式就是： <img src="https://www.zhihu.com/equation?tex=CWT_x%5E%5Cpsi+%28%5Ctau%2Cs%29+%3D+%5Cfrac%7B1%7D%7B%5Csqrt%7Bs%7D%7D+%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7Dx%28t%29%5Cpsi%28%5Cfrac%7Bt%7D%7Bs%7D-%5Ctau%29+dt" alt="CWT_x^\psi (\tau,s) = \frac{1}{\sqrt{s}} \int_{-\infty}^{+\infty}x(t)\psi(\frac{t}{s}-\tau) dt"></p><p>注意：上图中我们只列举了三种 <img src="https://www.zhihu.com/equation?tex=s" alt="s"> （即三次缩放）和4种 <img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="\tau"> （每种缩放对应四个时间位置，但是事实上， <img src="https://www.zhihu.com/equation?tex=s%2C%5Ctau" alt="s,\tau"> 是连续的，无穷多个的。</p><p>还是这个正弦信号，0~250ms：300HZ，250~500ms：200HZ ，500~750ms：100HZ ， 750~1000ms：50HZ。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;450&#39;&gt;&lt;/svg" alt="img"></p><p>其小波变换如下图所示（忽略图中坐标，原图如此，坐标不太对，还得映射一下，有空了我自己再画一张改一改）：</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;582&#39; height=&#39;448&#39;&gt;&lt;/svg" alt="img">图源：THE WAVELET TUTORIAL</p><p>我们来看，绿色的小峰，对应小的 <img src="https://www.zhihu.com/equation?tex=s%28scale%29" alt="s(scale)"> ，也就是高的频率。他们的<strong>时间分辨率很好</strong>， <img src="https://www.zhihu.com/equation?tex=s" alt="s"> 的区间很小，根据<img src="https://www.zhihu.com/equation?tex=s%2Cf" alt="s,f"> 的倒数关系，对应的 <img src="https://www.zhihu.com/equation?tex=f" alt="f"> 的区间就很大，因此<strong>频率分辨率不好</strong>。</p><p>粉色的高峰，对应高的<img src="https://www.zhihu.com/equation?tex=s%28scale%29" alt="s(scale)"> ，也就是低的频率， <img src="https://www.zhihu.com/equation?tex=s" alt="s"> 的区间很大，根据<img src="https://www.zhihu.com/equation?tex=s%2Cf" alt="s,f"> 的倒数关系，对应的 <img src="https://www.zhihu.com/equation?tex=f" alt="f"> 的区间就很小，因此<strong>频率分辨率很好，时间分辨率不好（有混叠）。</strong></p><p>这也就再一次说明了CWT是动态分辨率的，这也是CWT相对于STFT的优势所在。</p><p><strong>4、FT、STFT、CWT基函数对比</strong></p><p>最后，再来看看，FT、STFT、CWT的基函数之间的不同，以便加深理解。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;508&#39; height=&#39;529&#39;&gt;&lt;/svg" alt="img">图源：百度图片</p><p>FT的基函数，是分布在 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%2C%2B%5Cinfty%29" alt="(-\infty,+\infty)"> 的 <img src="https://www.zhihu.com/equation?tex=sin%2Ccos" alt="sin,cos">，不具有紧支撑性，只能筛选频率，使得FT完全丧失了时间信息，不具有时间分辨率。</p><p>STFT的基函数，是用窗函数截断的<img src="https://www.zhihu.com/equation?tex=sin%2Ccos" alt="sin,cos"> （图中是被高斯窗截断的），具有了紧支撑性，时域平移等同于分窗，使得STFT既能筛选频率，也能筛选时间。但是STFT基函数是：先确定频率，再与窗函数相乘构成的。因此不同的频率，具有同样的时间和频率分辨率。另外，窗函数的长短也比较难以确定。</p><p>CWT的基函数，是小波函数，具有紧支撑性，时域平移等同于分窗，使得CWT既能筛选频率，也能筛选时间。小波函数在改变频率的时候，是通过<strong>“缩放”</strong>实现的，<strong>这使得小波函数在改变频率的同时，改变了窗长。</strong>因此不同的频率，具有不同的时间和频率分辨率，实现了分辨率动态可调。</p><p>最后，再说一下，有很多类型的小波母函数，比如haar小波，db系列小波，sym系列小波，coif系列小波等等等等。具体哪一个小波适应哪种情况，估计都能写一本书了，我也没深入钻研过。我在利用小波变换做肌电信号识别的时候就是读一读有关肌电信号识别的论文，看看别人试过哪些小波，是一种上手比较快的方法。</p><hr><h2 id="连续小波变换（CWT）的缺点与离散小波变换（DWT）"><a href="#连续小波变换（CWT）的缺点与离散小波变换（DWT）" class="headerlink" title="连续小波变换（CWT）的缺点与离散小波变换（DWT）"></a>连续小波变换（CWT）的缺点与离散小波变换（DWT）</h2><p><strong>四、连续小波变换（CWT）的缺点与离散小波变换（DWT）</strong></p><p><strong>1、连续小波变换（CWT）的缺点</strong></p><p>在上一篇文章（<a href="https://zhuanlan.zhihu.com/p/68323379）中我们讲解了" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68323379）中我们讲解了</a> CWT可以实现动态分辨率的时频分析。CWT公式为：<img src="https://www.zhihu.com/equation?tex=CWT_x%5E%5Cpsi+%28%5Ctau%2Cs%29+%3D+%5Cfrac%7B1%7D%7B%5Csqrt%7Bs%7D%7D+%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7Dx%28t%29%5Cpsi%28%5Cfrac%7Bt-%5Ctau%7D%7Bs%7D%29+dt" alt="[公式]">， <img src="https://www.zhihu.com/equation?tex=x%28t%29" alt="[公式]"> 表示原始信号。你可能已经注意到了，这里的 <img src="https://www.zhihu.com/equation?tex=x%28t%29" alt="[公式]"> 是一个<strong>连续函数</strong>。</p><p>但是在第二篇文章（<a href="https://zhuanlan.zhihu.com/p/66246381）中我们讲过，实际采样信号往往具有两个特点：1、**离散性**，就是采集数据不连续，很容易理解，采集信号肯定是一个一个数据采集的；2、**有限性**，虽然理想的CWT是从" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66246381）中我们讲过，实际采样信号往往具有两个特点：1、**离散性**，就是采集数据不连续，很容易理解，采集信号肯定是一个一个数据采集的；2、**有限性**，虽然理想的CWT是从</a> <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%2C%2B%5Cinfty%29" alt="[公式]"> 进行积分的，但是实际信号往往实在一个区间内 <img src="https://www.zhihu.com/equation?tex=%28a%2Cb%29" alt="[公式]"> 的。如下图所示。</p><p>所以，由于CWT需要一个连续信号，但是实际采样信号往往是离散的，我们无法直接对实际信号进行CWT。</p><p>或许你想，我们对实际采样信号进行插值连续化不就可以使得其连续了吗？</p><p>是的。将实际采样信号插值连续化之后，我们——人，是可对它进行CWT的。</p><p>但是，我们也都知道，<strong>我们的帮手——计算机，是无法处理连续问题的</strong>。计算机只能处理离散问题。如果计算机要进行CWT，就意味着需要计算机做无穷次运算，计算机计算能力再强也是做不到的。</p><p>因此，为了使得计算机可以进行小波变换，我们需要引入离散小波变换（DWT）。</p><p><strong>2、离散小波变换（DWT）的Wallet算法</strong></p><p>DWT有很多种实现方式，我们在这里介绍Wallet算法，它是DWT的以一种经典的快速算法，也比较易懂。</p><p>我们首先来回顾一下上一篇文章讲过的动态分辨率图：<strong>高频部分，窄窗，高的时域分辨率，低的频域分辨率；低频部分，宽窗，低的时域分辨率，高的频域分辨率。</strong></p><p>我们是利用小波母函数的挤压和拉伸来实现动态分辨率的：</p><p><strong>当小波母函数被挤压的时候，频率就高，此时窗子窄，时域分辨率就好，根据海森堡测不准原理，频域分辨率就差；</strong></p><p><strong>当小波母函数被拉伸的时候，频率就低，此时窗子宽，时域分辨率就差，根据海森堡测不准原理，频域分辨率就好。</strong></p><p>也就是说，我们<strong>控制的是不同频率对应的窗长（即时域分辨率），频率分辨率是通过海森堡测不准原理得到的，从而达到了动态分辨率</strong>。</p><p>那么，如果我们这次不控制窗长（即时域分辨率），转而控制频域分辨率，能否达到动态分辨率呢？</p><p>答案是可以，这就是Wallet算法要解决的问题。</p><p><strong>半子带滤波</strong></p><p>我们知道，小波母函数本质上是一种带通滤波器。那么，假设可以通过小波母函数构造得到两个滤波器（至于怎么得到后续会介绍一下），包括<strong>一个高通滤波器和一个低通滤波器</strong>。</p><p>假设信号中的最高频率为 <img src="https://www.zhihu.com/equation?tex=Fs" alt="[公式]"> 。那么，高通滤波器的作用就是得到 <img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B2%7D%2CFs%29" alt="[公式]"> 的部分，低通滤波器的作用就是得到 <img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29" alt="[公式]"> 的部分。如下图所示：</p><p>我们将这个过程称为一次<strong>半子带滤波</strong>。</p><p><strong>下采样与上采样</strong></p><p>我们定义一个N倍下采样过程：<strong>将采样点N倍稀释</strong>。如下，就是一个2倍下采样过程，将采样点稀释2倍，即：每2个点采样数据点，就去除一个点。</p><p>N倍上采样过程：<strong>将采样点数量增加N倍</strong>。一般通过补0，或者插值的方法实现上采样。</p><p><strong>离散小波分解</strong></p><p>我们将一次半子带滤波+一次2倍下采样称为一层小波分解。如下图所示，图中的“箭头+2”表示一次2倍下采样。</p><p>假设原采样信号有 N 个点，信号最高频率为 <img src="https://www.zhihu.com/equation?tex=F_s" alt="[公式]"> （根据采样定律， <img src="https://www.zhihu.com/equation?tex=F_s" alt="[公式]"> 为采样频率的一半）。</p><p>经过一次高通滤波后，得到了 <img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B2%7D%2CFs%29" alt="[公式]"> 的部分，也是 N 个点，再经过一次2倍下采样，变成了 $\frac{N}{2}$ 个点，我们将这$\frac{N}{2}$个点称为<strong>小波分解的高频系数</strong>（为什么叫作系数会在后面解释）。</p><p>经过一次低通滤波后，得到了 <img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29" alt="[公式]"> 的部分，也是 N 个点，再经过一次2倍下采样，变成了 $\frac{N}{2}$ 个点，我们将这$\frac{N}{2}$个点称为<strong>小波分解的低频系数</strong>。</p><p>也就是说，<strong>经过一层小波分解的信号，它的总长度加起来，还是</strong> N ，<strong>是不变的</strong>。</p><p>现在，我们已经对 <img src="https://www.zhihu.com/equation?tex=%280%2CFs%29%2CN" alt="[公式]"> 个点的原信号进行了第一层小波分解，得到了<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B2%7D%2CFs%29%2C%5Cfrac%7BN%7D%7B2%7D" alt="[公式]">个点的高频系数和<img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29%2C%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> 个点的低频系数。</p><p>那么，我们<strong>保持 <img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B2%7D%2CFs%29%2C%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> 个点的高频系数不变</strong>，把<img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29%2C%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> 个点的低频系数作为信号，再进行一次小波分解。于是可以得到 <img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B4%7D%2C%5Cfrac%7BFs%7D%7B2%7D%29%2C%5Cfrac%7BN%7D%7B4%7D" alt="[公式]"> 个点的高频系数和 <img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B4%7D%29%2C%5Cfrac%7BN%7D%7B4%7D" alt="[公式]">个点的低频系数。</p><p>这个过程被称为<strong>第2层小波分解。</strong>我们验证一下，经过2层小波分解的信号，它的总长度加起来，还是N ，是不变的。</p><p>依此类推，我们可以进行第三层，第四层小波分解，如图所示，直到第 <img src="https://www.zhihu.com/equation?tex=log_2N" alt="[公式]"> 层小波分解。在第 <img src="https://www.zhihu.com/equation?tex=log_2N" alt="[公式]"> 层小波分解，由于不断的下采样，低频系数和高频系数都只剩1个数了，小波分解无法进行下去了。</p><p>因此，小波分解的原始信号个数一般也需要是<strong>2的幂次</strong>。不过，在各种数学计算软件里，如果输入不是2的幂次，它会自动帮你补零到2的幂次。</p><p>我们取4层小波分解的结果来看一下。</p><p>在频域上，我们得到的是 <img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B2%7D%2CFs%29" alt="[公式]"> ，<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B4%7D%2C%5Cfrac%7BFs%7D%7B2%7D%29" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B8%7D%2C%5Cfrac%7BFs%7D%7B4%7D%29" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B16%7D%2C%5Cfrac%7BFs%7D%7B8%7D%29" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B16%7D%29" alt="[公式]">频域区间的系数。</p><p>在时域上，由于不断的2倍下采样，不断地丢弃数据，所以最后一层分解得到的<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B16%7D%2C%5Cfrac%7BFs%7D%7B8%7D%29" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B16%7D%29" alt="[公式]">的时域分辨率最差，第一层分解保留的<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B2%7D%2CFs%29" alt="[公式]"> 时域分辨率最好。</p><p>那么，我们得到的分辨率就是这样子的：</p><p>这，不就是上一篇文章我们讲过的小波变换得到的动态分辨率吗？</p><p>是的！这就是离散小波变换的快速算法之一——Wallet算法，<strong>通过不断的半子带滤波和下采样，控制不同频率成分的频域分辨率，进而达到动态分辨率。</strong></p><p>最后，用一张比较经典的图，再来演示一下小波分解的过程。 <img src="https://www.zhihu.com/equation?tex=%5Cpi" alt="[公式]"> 为采样信号的最高频率。 <img src="https://www.zhihu.com/equation?tex=g%28n%29" alt="[公式]">代表高通滤波器， <img src="https://www.zhihu.com/equation?tex=h%28n%29" alt="[公式]"> 代表低通滤波器，“箭头+2”表示2倍下采样。</p><p>图源：THE WAVELET TUTORIAL</p><p>再来举个例子形象地说明一下DWT的使用吧。</p><p>希望对于一个采样率为1000HZ的非稳态信号进行小波分解，下图为包含了256个采样点（即256ms）的原始采样信号。</p><p>1、首先，选择小波分解的层次。</p><p>可以根据<strong>对最低频率区间的要求</strong>来选择小波分解的层数。比如，我之前做项目的时候，采样率为1000HZ，那么信号的最高频率为 <img src="https://www.zhihu.com/equation?tex=F_s+%3D+500HZ" alt="[公式]"> 。我认为对于频率低于20HZ的成分，不需要再进一步区分了。因此，我选择５层小波分解，得到的最低一层的频率区间为 <img src="https://www.zhihu.com/equation?tex=%280%2CF_S%2F2%5E5%29" alt="[公式]"> ，即为 <img src="https://www.zhihu.com/equation?tex=%280%2C16%29HZ" alt="[公式]"> ，这就够用了。</p><p>2、接下来，进行5层小波分解，得到小波分解系数。</p><p>如下图中，图1依然是原始采样信号 ，图2到图6为第1层到第5层小波分解的高频系数，图7为第5层小波分解的低频系数。如图所示，这些小波分解系数对应着不同的频率区间。</p><p>这就是DWT了，又称为小波分解。</p><p>这里提一下，小波分解是可逆的，即可以通过不同频率区间的小波分解系数进行重构，得到不同频率区间的<strong>重构信号</strong>。</p><p>3、所以，最后，进行小波重构，得到重构信号。</p><p>如下图中，图1依然是原始采样信号，图2到图7为通过不同频率区间的小波系数进行重构，得到的重构信号。将图2到图7加起来就可以得到重构原始信号，其和原始采样信号的误差称为重构误差。</p><p><strong>3、Wallet算法背后的数学原理简介</strong></p><p>这一部分主要是为了解答上一部分中的两个问题。</p><p>1、在上一部分，我们“假设可以通过小波母函数构造得到两个滤波器”，那么，怎么得到刚好可以具有以上特性的滤波器呢？</p><p>2、在上一部分，我们将小波分解之后的结果称为“系数”，那么，为什么称为系数呢？</p><p>先说一下，这部分我不是弄得非常懂，毕竟我只是个做工程的本科生，不是做数学的大佬。我凭自己的理解写一写大概，并推荐了两篇个人觉得讲得很好的回答。</p><p>我们用Haar小波做例子。</p><p>首先，介绍一个Haar尺度函数（又称为父小波），记为 <img src="https://www.zhihu.com/equation?tex=%5Cphi%28x%29" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=%5Cphi%28x%29+%3D+1%2A+%280+%5Cleq+x%3C1%29+" alt="[公式]">，如下图。</p><p>通过Haar尺度函数 <img src="https://www.zhihu.com/equation?tex=%5Cphi%28x%29" alt="[公式]"> ，可以得到Haar母小波 <img src="https://www.zhihu.com/equation?tex=%5Cpsi%28x%29" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=%5Cpsi%28x%29+%3D+%5Cphi%282x%29+-+%5Cphi%282x-1%29" alt="[公式]">，如下图。</p><p>现在，对于一个 N 点的原始采样信号，如果我们可以用 N 个<strong>做了时域平移</strong>的Haar尺度函数和 N 个<strong>做了时域平移</strong>的Haar母小波，来逼近原信号，就可以得到用 N 个Haar尺度函数的系数和 N 个Haar母小波的系数。</p><p>从直观上看，Haar尺度函数只是一条线，而Haar母小波则是一个波。所以，Haar母小波所能表示出来的信息应该更加细致。因此，N 个Haar母小波组合起来，应该代表的是原始信号的细节部分，也就是高频部分；N 个Haar尺度函数组合起来，代表的是原始信号的粗略部分，也就是低频部分。</p><p>我们将N 个Haar母小波的系数称为高频系数，将N 个Haar尺度函数的系数称为低频系数。</p><p>所以，<strong>DWT的滤波功能，是通过利用尺度函数和母小波重构信号，获取重构系数来获得的</strong>，这已经定性地解决了本部分提出的问题。</p><p>关于DWT背后的数学原理，推荐两篇回答：</p><p><a href="https://zhuanlan.zhihu.com/p/28575472" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28575472</a></p><p><a href="https://zhuanlan.zhihu.com/p/44217268" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44217268</a></p><p>最后，由于DWT分解得到的是高频系数和低频系数，也就是用尺度函数以及母小波表示原信号的时候的一些重构系数，所以通过重构系数可以重构该信号，这被称为<strong>小波分解的重构。</strong>这也说明了小波分解是可逆的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;傅里叶变换-gt-小波变化&quot;&gt;&lt;a href=&quot;#傅里叶变换-gt-小波变化&quot; class=&quot;headerlink&quot; title=&quot;傅里叶变换-&amp;gt;小波变化&quot;&gt;&lt;/a&gt;傅里叶变换-&amp;gt;小波变化&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;声明:文中大多数内容来
      
    
    </summary>
    
    
      <category term="信号处理" scheme="https://nymrli.top/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Vim记忆</title>
    <link href="https://nymrli.top/2019/07/26/Vim%E8%AE%B0%E5%BF%86/"/>
    <id>https://nymrli.top/2019/07/26/Vim记忆/</id>
    <published>2019-07-26T02:34:34.000Z</published>
    <updated>2019-07-26T02:44:56.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VIM记忆技巧"><a href="#VIM记忆技巧" class="headerlink" title="VIM记忆技巧"></a>VIM记忆技巧</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><ul><li>i(insert)</li><li>I最前面insert</li><li>a(append)</li><li>A最后面append</li><li>o(open a line)往下开启一行</li><li>O往上开启一行</li></ul><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><ul><li>d（delete）</li><li>dw（delet word）</li><li>dd（删除一行）</li><li>x（删除一个字符）</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li>diw(delete inner word)</li><li>daw(delete around word)</li></ul><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><ul><li>c（change）</li><li>ciw（change inner word）</li><li>ci”(change inner “)</li><li>ct）修改到右括号</li></ul><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><ul><li>fs(find s) 跳到本行第一个s字符</li><li><code>/</code>往后查找,如/xxx 全文搜索xxx<ul><li><code>;</code>查找下一个</li></ul></li><li><code>?</code>往前查找</li></ul><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><ul><li>h←</li><li>j↓</li><li>k↑</li><li><p>l→</p></li><li><p>w(word)往后跳一个单词</p></li><li><p>b(back word)往前返回一个单词</p><ul><li>以空格为界区分单词</li></ul></li><li>行间跳转<ul><li><code>:18</code> 跳转到第18行</li><li><code>18G</code> 跳转到第18行</li></ul></li><li>行内跳转:<ul><li><code>0</code>行首</li><li><code>$</code>行尾</li></ul></li><li><code>ctrl+o</code>返回上一个位置</li><li><code>G</code>文件结尾</li><li><code>gg</code>文件开头</li><li><code>ctrl+f</code>(forward)往后翻页</li><li><code>ctrl+u</code>(upward)往前翻页</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VIM记忆技巧&quot;&gt;&lt;a href=&quot;#VIM记忆技巧&quot; class=&quot;headerlink&quot; title=&quot;VIM记忆技巧&quot;&gt;&lt;/a&gt;VIM记忆技巧&lt;/h1&gt;&lt;h2 id=&quot;增&quot;&gt;&lt;a href=&quot;#增&quot; class=&quot;headerlink&quot; title=&quot;增&quot;&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://nymrli.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用</title>
    <link href="https://nymrli.top/2019/07/25/Docker%E4%BD%BF%E7%94%A8/"/>
    <id>https://nymrli.top/2019/07/25/Docker使用/</id>
    <published>2019-07-25T02:58:19.000Z</published>
    <updated>2019-08-22T12:32:55.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h1><blockquote><p>轻部署,省成本,易迁移</p></blockquote><h2 id="docker和虚拟机VM的区别"><a href="#docker和虚拟机VM的区别" class="headerlink" title="docker和虚拟机VM的区别"></a>docker和虚拟机VM的区别</h2><h3 id="一、本质上的区别："><a href="#一、本质上的区别：" class="headerlink" title="一、本质上的区别："></a>一、本质上的区别：</h3><p><img src="https://img-blog.csdn.net/20180711090727241?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmd6aHVuYmlhbmNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用；</p><p>Container(Docker容器)，在宿主机器、宿主机器操作系统上创建Docker引擎，在引擎的基础上再安装应用。</p><p>那么问题来了，没有操作系统，怎么运行程序？</p><p>可以在Docker中创建一个ubuntu的镜像文件，这样就能将ubuntu系统集成到Docker中，运行的应用就都是ubuntu的应用。</p><h3 id="二、使用上的区别："><a href="#二、使用上的区别：" class="headerlink" title="二、使用上的区别："></a>二、使用上的区别：</h3><p><img src="https://img-blog.csdn.net/20180711094611205?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmd6aHVuYmlhbmNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>Size:</p><ul><li>虚拟机ubuntu大小为:24.1GB</li><li>Docker中镜像文件占用内存: 81.2MB</li></ul><p>Startup：</p><ul><li>Docker在宿主机器的操作系统上创建Docker引擎，直接在宿主主机的操作系统上调用硬件资源，而不是虚拟化操作系统和硬件资源，所以操作速度快。</li><li>这个其实安装一个ubuntu的虚拟机和拉取一个Docker的ubuntu镜像文件，运行一下就知道了，区别很明显，虚拟机开一下大概得2分多钟，而Docker只需要2秒钟。</li></ul><h2 id="宿主机、镜像与容器"><a href="#宿主机、镜像与容器" class="headerlink" title="宿主机、镜像与容器"></a>宿主机、镜像与容器</h2><p>宿主机器: 运行docker的机器</p><p>镜像:不可以修改内容</p><p>容器:可以修改能内容,相当于虚拟机,默认情况下彼此相互独立（容器之间可以通信）</p><p>△.可以依据镜像来创建容器,也可以封装容器为一个镜像,即<strong>容器&lt;===&gt;镜像</strong></p><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><p>搜索镜像: <code>docker search python</code></p><p>下载镜像: <code>docker pull NAME</code></p><p>创新容器: <code>docker run -tid  (--name xxx)  IMAGE ID</code></p><ul><li><code>ti</code>表示以交互的形式创建容器，<code>d</code>表示不进入<ul><li><code>-d, --detach=false</code>， 指定容器运行于前台还是后台，默认为false</li><li><code>-i, --interactive=false</code>， 打开STDIN，用于控制台交互</li><li><code>-t, --tty=false</code>， 分配tty设备，该可以支持终端登录，默认为false</li></ul></li></ul><p>运行容器: <code>docker start CONTAINER_ID</code>  </p><p>进入容器： <code>docker attach CONTAINER_ID</code></p><ul><li>进入容器前得前运行容器</li></ul><p>退出容器： <code>ctrl + p + q</code> , 以<code>ctrl + z</code> 、<code>exit</code>将会终止容器运行</p><p>封装容器为镜像: <code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a :提交的镜像作者；</span><br><span class="line">-c :使用Dockerfile指令来创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line">-p :在commit时，将容器暂停。</span><br></pre></td></tr></table></figure><p>容器通信-创建子节点链接中心节点: <code>docker run -tid  (--name xxx)  (--link CONTAINER_NAMES) IMAGE ID</code></p><p>查看容器ip: <code>cat /ect/hosts</code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@b68943564e76:/# cat /etc/hosts </span><br><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">ff00::0ip6-mcastprefix</span><br><span class="line">ff02::1ip6-allnodes</span><br><span class="line">ff02::2ip6-allrouters</span><br><span class="line">172.17.0.2test 4e02c004539e</span><br><span class="line">172.17.0.3b68943564e76</span><br></pre></td></tr></table></figure><p>▲初次使用,  <code>ifconfig</code>使用无效,<code>ping</code>也无效,原因如下</p><blockquote><p>我创建的容器是拉取的Base镜像，而因为用Docker拉取的<strong>Base镜像</strong>如Centos和Ubuntu的话都是<strong>最简版本</strong>，不包含Ping工具，而对Docker进行Docker network和Docker链接操作时往往要用到Ping工具测试两个容器间的网络，此时就要用到Ping工具了，下面是Ubuntu下安装Ping工具的命令：<code>apt-get update &amp;&amp; apt-get install iputils-ping</code>、安装ifconfig工具:<code>apt install net-tools</code></p></blockquote><p><strong>从容器里面拷文件到宿主机</strong></p><p> docker cp 容器名：要拷贝的文件在容器里面的路径       要拷贝到宿主机的相应路径 </p><p>宿主机上执行:<code>$ docker cp testtomcat：/usr/local/tomcat/webapps/test/js/test.js /opt</code></p><p><strong>从宿主机拷文件到docker容器里面</strong></p><p> docker cp 要拷贝的文件路径 容器名：要拷贝到容器里面对应的路径</p><p>宿主机上执行<code>$ docker cp requirements.txt apptest:/app</code></p><p>▲注:容器NAME可以通过<code>docker ps</code>命令查看</p><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><blockquote><p>Dockerfile文件D一定要大写</p><p><code>$ docker build -t=&quot;dormanctpress/df_test2&quot; .</code></p><ul><li>.为Dockerfile的路径</li></ul></blockquote><p>1.<code>FROM &lt;image&gt;:&lt;tag&gt;</code></p><p>2.MAINTAINER</p><p>3.RUN</p><ul><li>镜像构建中运行的命令</li></ul><p>4.EXPOSE</p><ul><li>如果是端口的话，只是声明会使用xx端口,但是实际使用时还是需要run -p xx    <code>$ docker build -t=&quot;dormanctpress/df_test2&quot; .</code></li><li>设置环境变量</li></ul><p>CMD</p><ul><li>在容器运行时运行的默认命令(命令行中添加的命令可以代替掉Dokcerfile中写的CMD指令)</li><li>每个Dockerfile只能够包含一个CMD，多个CMD 只有最后一个能有效</li><li>定义的三种方式<ul><li>CMD<cmd>这个会当做/bin/sh-c“cmd”来执行</cmd></li><li>CMD[“executable”，”arg1”，”arg2”]<ul><li>一定要双引号</li></ul></li><li>CMD[“arg1”，”arg2”]，这个时候CMD作为ENTRYPOINT的参数</li></ul></li></ul><p>ENTRYPOINT</p><ul><li><p>每个Dockerfile只能够包含一个ENTRYPOINI，多个ENTRYPOINT只有最后一个能有效</p></li><li><p>不会像CMD命令一样被覆盖,除非使用<code></code></p></li><li>当定义了ENTRYPOINT后,CMD将被作为参数使用。如果定义了CMD，那么<code>docker run -t test/osf2 xxxx</code>后面即xxxx的内容全会被当做参数传递ENTRYPOINT</li></ul><p>组合使用ENTRYPOINT和CMD: ENTRYPOINT指定命令,CMD指定默认参数</p><p>ADD&amp;COPY</p><p>共同点</p><ul><li><p>ADD&amp;COPY的源必须在context路径下</p></li><li><p>当在源代码构建的方式下，可以通过ADD和COPY的方式，把Host上的文件或者目录复制到Image</p><p>ADD</p></li><li><p>包含类似tar解压的功能</p></li><li><p>当src为网络URL的情况下，ADD指令可以把它下载到Dest的指定位置，这个在任何build的方式下都可以Work</p></li></ul><p>COPY</p><ul><li>如果单纯复制文件,Docker推荐COPY</li><li>ADD&amp;COPY的源必须在context路径下</li><li>当在源代码构建的方式下，可以通过ADD和COPY的方式，把Host上的文件或者目录复制到Image</li></ul><p>VOLUME[‘/data’]</p><ul><li>设置数据卷</li></ul><p>WORKDIR /path/to/workdir</p><ul><li>一般使用绝对路径</li></ul><p>ENV <key> <value></value></key></p><ul><li>用来设置环境变量，后续的RUN可以使用它所创建的环境变量。</li><li>当创建基于该镜像的Container的时候，会自动拥有设置的环境变量</li></ul><p>USER daemon</p><ul><li><p>指定UID或者username，来决定运行RUN指令的用户</p></li><li><p>如果不指定,则默认root</p></li></ul><p>ONBUILD</p><ul><li>触发器</li></ul><h3 id="dockerfile构建过程"><a href="#dockerfile构建过程" class="headerlink" title="dockerfile构建过程"></a>dockerfile构建过程</h3><ol><li>从基础镜像运行一个容器</li><li>执行一条指令，对容器做出修改</li><li>执行类似docker commit的操作，提交一个新的镜像层</li><li>再基于刚提交的镜像运行一个新容器</li><li>执行Dockerfile中的下一条指令，直至所有指令执行完毕</li></ol><h3 id="使用中间层镜像进行调试"><a href="#使用中间层镜像进行调试" class="headerlink" title="使用中间层镜像进行调试"></a>使用中间层镜像进行调试</h3><p>查找错误</p><h3 id="Dockerfile-镜像缓存"><a href="#Dockerfile-镜像缓存" class="headerlink" title="Dockerfile 镜像缓存"></a>Dockerfile 镜像缓存</h3><p>构建缓存：将之前的镜像缓存</p><p>不使用缓存<code>docker build --no-cache</code></p><h3 id="查看镜像构建的过程"><a href="#查看镜像构建的过程" class="headerlink" title="查看镜像构建的过程"></a>查看镜像构建的过程</h3><p>查看构建过程:<code>docker history xxx/yyy</code></p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>sudo docker run -v ~/container_data:/data -it ubuntu /bin/bash</code></p><p>参数说明:使用-v选项,第一个参数为宿主机目录,:后的目录为在容器中使用的目录(挂载);ubuntu为镜像</p><h3 id="查看容器是否挂载了数据卷"><a href="#查看容器是否挂载了数据卷" class="headerlink" title="查看容器是否挂载了数据卷"></a>查看容器是否挂载了数据卷</h3><p><code>docker inspect CONTAINER_ID</code>可以查看容器是否挂载了数据卷</p><h3 id="给数据卷增加权限"><a href="#给数据卷增加权限" class="headerlink" title="给数据卷增加权限"></a>给数据卷增加权限</h3><p><code>sudo docker run -v ~/datavolume:/data:ro -it ubuntu/bin/bash</code></p><p>ro是read-only</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><blockquote><p>命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器</p></blockquote><p>挂载数据卷容器的方法</p><p><code>docker run--volumes-from [CONTAINER NAME]</code></p><h2 id="MySQL通信"><a href="#MySQL通信" class="headerlink" title="MySQL通信"></a>MySQL通信</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; can<span class="string">'t connect to MySQL server on '</span>172.17.0.8<span class="string">'(111)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/mvsal/my.cnf </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将<span class="built_in">bind</span>-address=127.0.0.1注释掉</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Host <span class="string">'2eaf92ef2ff6'</span>is not allowed to connect to this MySQL server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> create user <span class="string">"weiwei"</span>@<span class="string">"%"</span>identified by<span class="string">"weijc7789"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grant create, select, update, delete, insert on *.* to weiwei;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增添权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysq1-h 172.17.0.8-u weiwei-p</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 链接</span></span><br></pre></td></tr></table></figure><h2 id="redis通信"><a href="#redis通信" class="headerlink" title="redis通信"></a>redis通信</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 172.17.0.8</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Could not connect to Redis at 172.17.0.8:6379:Connection refused</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/redis /redis.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将<span class="built_in">bind</span>-address=127.0.0.1注释掉</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果修改后/ect/init.d/redis-server restart后还是链接不了,重启进入容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli-h 172.17.0.8-p 6379</span></span><br></pre></td></tr></table></figure><p>一条命令实现停用并删除容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>一条命令删除所有镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi `docker images -q`</span><br></pre></td></tr></table></figure><p>一条命令删除创建失败的镜像:</p><p><code>docker images | sed -n &#39;2p&#39; | awk &#39;{print$3}&#39; | xargs docker rmi</code></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Dockerfile-RUN，CMD，ENTRYPOINT命令区别"><a href="#Dockerfile-RUN，CMD，ENTRYPOINT命令区别" class="headerlink" title="Dockerfile RUN，CMD，ENTRYPOINT命令区别"></a>Dockerfile RUN，CMD，ENTRYPOINT命令区别</h3><blockquote><p>RUN命令执行命令并创建新的镜像层，通常用于安装软件包</p><p>CMD命令设置容器启动后默认执行的命令及其参数，但CMD设置的命令能够被<code>docker run</code>命令后面的命令行参数替换</p><p>ENTRYPOINT配置容器启动时的执行命令（不会被忽略，一定会被执行，即使运行 <code>docker run</code>时指定了其他命令）</p></blockquote><p>Shell格式和Exec格式运行命令</p><p>我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式：</p><ul><li>Shell格式：<instruction> <command>。例如：apt-get install python3<ul><li>多条命令用&amp;&amp;链接</li></ul></instruction></li><li>Exec格式：<instruction> [“executable”, “param1”, “param2”, …]。例如： [“apt-get”, “install”, “python3”]</instruction></li></ul><p><strong>CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。</strong></p><p>### </p><p><strong>总结</strong></p><ul><li>使用 RUN 指令安装应用和软件包，构建镜像。</li><li>如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。</li><li>如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。</li></ul><hr><h3 id="Docker-运行python-flask的web程序"><a href="#Docker-运行python-flask的web程序" class="headerlink" title="Docker 运行python flask的web程序"></a>Docker 运行python flask的web程序</h3><h4 id="1创建镜像"><a href="#1创建镜像" class="headerlink" title="1创建镜像"></a>1创建镜像</h4><h5 id="1-1-ubuntu16-04-python3-6"><a href="#1-1-ubuntu16-04-python3-6" class="headerlink" title="1.1 ubuntu16.04+python3.6"></a>1.1 ubuntu16.04+python3.6</h5><blockquote><p>18.04卡在了PPA环节,并且git安装也没安装上,后来使用了<a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">dockerHub</a>上搜素到的github仓库中的<a href="https://github.com/tianon/docker-brew-ubuntu-core/tree/105329f5da5f205e3d2bcb1f96ce32a472e56239/xenial" target="_blank" rel="noopener">16.04 Xenial</a>就解决了。</p><p>注：<strong>镜像TAG版本需要到dockerHub上才能查看，最初下载成18.04就是因为这个原因被坑了</strong></p><p>18.04PPA问题:</p><p><code>aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Ubuntu/bionic</code>意思是18.04该PPA没有资源.bionic是<a href="#附Uuntu版本代号:">版本代号</a>,如16.04的  Xenial</p></blockquote><p>⑴使用下载好的Xenial的Dockerfile进行创建镜像<code>docker run 1604ubuntu .</code></p><p>为了使用国内源用阿里云，先编辑一个sources.list，放在dokcerfile同目录下，作为docker创建镜像时的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><p>⑵根据官方的镜像来编写自己的Dockerfile创建具有工具的Ubuntu1604</p><blockquote><p>涉及交互式选择项（如下），docker build的时候会报错。设置 DEBIAN_FRONTEND=noninteractive</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">FROM 1604ubuntu</span><br><span class="line">MAINTAINER mrli</span><br><span class="line">#用ubuntu国内源替换默认源</span><br><span class="line">RUN rm /etc/apt/sources.list</span><br><span class="line">COPY sources.list /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">#安装python3.6必要的包。源镜像太精简了，ip ifconfig之类的都没有。后续安装python pip也需要一些。但是build_essential似乎不必须，先去了。如果后面安装numpy之类需要gcc了，再加上</span><br><span class="line">RUN apt update</span><br><span class="line">#RUN apt upgrade</span><br><span class="line"></span><br><span class="line">RUN apt install -y apt-utils apt-transport-https  vim iproute2 net-tools ca-certificates curl build-essential wget python-software-properties software-properties-common psmisc</span><br><span class="line"></span><br><span class="line">#安装python3.6 来自第三方</span><br><span class="line">RUN add-apt-repository ppa:jonathonf/python-3.6</span><br><span class="line">RUN apt update</span><br><span class="line">RUN apt install -y python3.6</span><br><span class="line">RUN apt install -y python3.6-dev</span><br><span class="line">RUN apt install -y python3.6-venv</span><br><span class="line"></span><br><span class="line">#为3.6安装pip</span><br><span class="line">RUN wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">RUN python3.6 get-pip.py</span><br><span class="line"></span><br><span class="line">#设置默认python为python3</span><br><span class="line">RUN update-alternatives --install /usr/bin/python python /usr/bin/python2 100</span><br><span class="line">RUN update-alternatives --install /usr/bin/python python /usr/bin/python3 150</span><br><span class="line"></span><br><span class="line">#和自带的3.5共存,设置python3默认为3.6</span><br><span class="line">#RUN update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.5 1</span><br><span class="line">RUN update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.6 2</span><br><span class="line"></span><br><span class="line"># 更新配置</span><br><span class="line">RUN update-alternatives --config python3</span><br><span class="line">#print()时在控制台正常显示中文</span><br><span class="line">ENV PYTHONIOENCODING=utf-8</span><br></pre></td></tr></table></figure><p>在dockerfile所在路径下执行，建立image</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t uos:1604 .</span><br></pre></td></tr></table></figure><p>因为开头几步用了国内源，所以非常快。</p><h5 id="1-2-开发环境"><a href="#1-2-开发环境" class="headerlink" title="1.2 开发环境"></a>1.2 开发环境</h5><p>再建一个dockerfile，开头使用刚才建立的镜像uos1604</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FROM uos:1604</span><br><span class="line">MAINTAINER mrli</span><br><span class="line"></span><br><span class="line">#代码复制过来后的路径</span><br><span class="line">RUN mkdir /app</span><br><span class="line"># 指定容器启动时执行的命令都在app目录下执行</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 将本地app目录下的内容拷贝到容器的app目录下</span><br><span class="line">COPY ./app/ /app/</span><br><span class="line"></span><br><span class="line"># 安装nginx</span><br><span class="line">RUN apt -y install nginx mysql-server </span><br><span class="line"></span><br><span class="line">RUN /etc/init.d/nginx start</span><br><span class="line"># 替换nginx的配置</span><br><span class="line">RUN rm  /etc/nginx/sites-enabled/default</span><br><span class="line">RUN cp nginx.conf /etc/nginx/sites-enabled/nginx.conf</span><br><span class="line"></span><br><span class="line">RUN pip3 install uwsgi</span><br><span class="line"></span><br><span class="line">#安装需要的python库</span><br><span class="line"># 启动nginx和uwsgi</span><br><span class="line">#ENTRYPOINT pip install -r requirements.txt  -i  https://pypi.tuna.tsinghua.edu.cn/simple some-package --no-cache-dir &amp;&amp; service nginx restart &amp;&amp; uwsgi --ini uwsgi.ini</span><br><span class="line"></span><br><span class="line"># 为了保证能之后进入所以最后一个命令为/bin/sh</span><br><span class="line">ENTRYPOINT pip install -r requirements.txt  -i  https://pypi.tuna.tsinghua.edu.cn/simple some-package --no-cache-dir &amp;&amp; service nginx restart &amp;&amp; uwsgi --ini uwsgi.ini &amp; &amp;&amp; /bin/sh</span><br></pre></td></tr></table></figure><p>创建uflask镜像:<code>docker build -t uflask .</code></p><p><a href="#2启动容器">根据镜像创建运行容器</a>:<code>docker run -tid -p 12345:80 flaskdemo IMAGE_ID</code></p><p>此时就可以通过<code>VPS的IP地址:宿主机端口</code>访问这个应用程序</p><p>查看日志:<code>docker logs 应用名(NAMES)</code>如<code>docker logs flaskdemo</code></p><h5 id="关于mysql的建议"><a href="#关于mysql的建议" class="headerlink" title="关于mysql的建议"></a>关于mysql的建议</h5><blockquote><p>mysql建议作为单独容器来跑数据库,然后远程连接数据库.或是使用数据卷</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line"># 搜索</span><br><span class="line"># docker search mysql</span><br><span class="line"># 拉取</span><br><span class="line"># docker pull mysql:5.7</span><br><span class="line">#运行</span><br><span class="line"># docker run --name mysql5.7 -e MYSQL_ROOT_PASSWORD=123456 -p 3307:3306 -d mysql:5.7</span><br></pre></td></tr></table></figure><h4 id="2启动容器-转"><a href="#2启动容器-转" class="headerlink" title="2启动容器(转)"></a>2启动容器(转)</h4><ul><li><p>Docker</p><p>一种开源容器应用，供开发者打包自己的开发环境，可以任意移植</p></li></ul><ul><li>docker-compose<br>一种管理多个Docker容器的工具，可以简化我们启动容器的各种命令</li></ul><h5 id="2-1手动敲docker命令"><a href="#2-1手动敲docker命令" class="headerlink" title="2.1手动敲docker命令"></a>2.1手动敲docker命令</h5><p>先试试用docker命令行启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name quotation_api -itd -p 5000:5000 -v /home/quotation:/code quotation_dev:latest</span><br></pre></td></tr></table></figure><p>用到的参数分别是</p><blockquote><p>–name为容器命名；</p><p>-itd  输入输出终端，后台运行</p><p>-p   host端口:容器端口</p><ul><li>将宿主机5000端口的请求转发到容器5000端口,用5000是flask默认</li></ul><p>-v  host路径:容器内路径(挂载数据卷)</p><p>quotation_dev:latest 最后是使用的镜像名（前面刚用dockerfile build出来的）</p></blockquote><p>然后进入容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach quotation_api</span><br></pre></td></tr></table></figure><p>用python3 main.py启动flask，OK。</p><p>这样flask运行在docker里了。</p><p>在host改代码，可以看见docker的控制台在更新，和在host一样了。(使用数据卷)</p><h5 id="2-2使用dock-compose"><a href="#2-2使用dock-compose" class="headerlink" title="2.2使用dock-compose"></a>2.2使用dock-compose</h5><blockquote><p>如果没有安装先进行安装<code>apt install docker-compose</code></p></blockquote><p>dock-compose用来管理多个container的运行，特别适合1个host上跑多个container的情况。</p><p>得天独厚，<a href="https://docs.docker.com/compose/gettingstarted/" target="_blank" rel="noopener">docker官网上dock-compose的gettingstarted文档</a>就是flask的(说明flask+docker代表了先进生产力的前进方向O Yeah！),看完了基本就能用了。</p><p>dock-compose采用yaml作为配置文件。查了一下，yaml参考了xml和json，以及python的语法，采用了python之缩进，无XML之标记，无json之括号，无字符串之引号。特别适合作为配置文件用。</p><p>建立docker-compose.yaml文件(无镜像,但有dockerfile)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos; # 表示该 Docker-Compose 文件使用的是 Version 2 file</span><br><span class="line">services:</span><br><span class="line">  docker-demo:  # 指定服务名称</span><br><span class="line">    build: .  # 指定 Dockerfile 所在路径</span><br><span class="line">    ports:    # 指定端口映射</span><br><span class="line">      - &quot;9000:8761&quot;</span><br></pre></td></tr></table></figure><p>建立docker-compose.yaml文件(已有镜像)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  quotation_api: # 指定服务名称</span><br><span class="line">    image: quotation_dev:latest  # 指定镜像</span><br><span class="line">    volumes:# 选择数据卷</span><br><span class="line">      - /home/quotation:/code</span><br><span class="line">    ports:# 端口映射</span><br><span class="line">      - &quot;5000:5000&quot;</span><br><span class="line">    command: python3 main.py# 执行命令</span><br></pre></td></tr></table></figure><p>基本对应手动敲的docker命令，最后还省了敲python3 main.py。</p><p>当然如果是部署，这句可以用CMD 写进Dockfile。但是开发过程，文件名之类的会改变，比如最终部署运行用可能是gunicorn+wsgi.py，所以还是写在dockerfile外面比较方便</p><p>运行，在控制台执行：<code>docker-compose up</code>、<code>docker-compose up -d  // 后台启动并运行容器</code></p><p><a href="https://www.jianshu.com/p/658911a8cff3" target="_blank" rel="noopener">docker-compose更多介绍</a></p><h3 id="坑点记录"><a href="#坑点记录" class="headerlink" title="坑点记录"></a>坑点记录</h3><h4 id="docker容器启动后马上退出解决方案"><a href="#docker容器启动后马上退出解决方案" class="headerlink" title="docker容器启动后马上退出解决方案"></a><strong>docker容器启动后马上退出解决方案</strong></h4><blockquote><p>dokcerfile中的最后一个命令不能在后台执行,不然会启动后马上退出</p></blockquote><p><strong>原因</strong></p><p>Docker容器同时只能管理一个进程，如果这个进程退出那么容器也就退出了，但这不表示容器只能运行一个进程(其他进程可在后台运行)，但是要使容器不退出必须有一个前台执行的进程。</p><p><strong>解决方法</strong>：</p><p>脚本中最后一个进程一定要用前台运行方式即在进程最后不加&amp;(&amp;表示后台运行)，否则容器会退出。</p><h4 id="如何正确的使用docker-attach"><a href="#如何正确的使用docker-attach" class="headerlink" title="如何正确的使用docker attach"></a><a href="http://dockone.io/question/399" target="_blank" rel="noopener">如何正确的使用docker attach</a></h4><p>Q:由于执行着<code>uwsgi --ini uwsig.ini</code>命令,用户就无法直接进入到容器中去，<code>docker attach CONTAINER_id</code> 就会一直卡着。</p><p>A: attach早已过时了，可用: <code>docker exec -it containerID /bin/bash</code>，一开始使用的是<code>/bin/sh</code>然后还是一直卡住.但是/bin/bash是可以的</p><h3 id="附Uuntu版本代号"><a href="#附Uuntu版本代号" class="headerlink" title="附Uuntu版本代号:"></a>附Uuntu版本代号:</h3><table><thead><tr><th>版本号</th><th>代号</th><th>发布时间</th></tr></thead><tbody><tr><td>18.04</td><td>Bionic Beaver（仿生海狸）</td><td>即将发布2018年4月(LTS)</td></tr><tr><td>17.10</td><td>Artful Aardvark(机灵的土豚)</td><td>2017年10月</td></tr><tr><td><strong>16.04 LTS</strong></td><td>Xenial Xerus <code>好客的非洲地松鼠</code></td><td>即将发布 2016/4</td></tr><tr><td>15.10</td><td>Wily Werewolf <code>狡诈的狼人</code></td><td>2015/10/22</td></tr><tr><td>15.04</td><td>Vivid Vervet <code>活泼的小猴</code></td><td>2015/04/23</td></tr><tr><td>14.10</td><td>Utopic Unicorn <code>乌托邦独角兽</code></td><td>2014/10/23</td></tr><tr><td><strong>14.04 LTS</strong></td><td>Trusty Tahr <code>值得信赖的塔尔羊</code></td><td>2014/04/18</td></tr><tr><td>13.10</td><td>Saucy Salamander <code>活泼的蝾螈</code></td><td>2013/10/17</td></tr><tr><td>13.04</td><td>Raring Ringtail <code>铆劲浣熊</code></td><td>2013/04/25</td></tr><tr><td>12.10</td><td>Quantal Quetzal <code>缤纷的绿咬鹃</code></td><td>2012/10/18</td></tr><tr><td><strong>12.04 LTS</strong></td><td>Precise Pangolin <code>精准的穿山甲</code></td><td>2012/04/26</td></tr><tr><td>11.10</td><td>Oneiric Ocelot <code>有梦的虎猫</code></td><td>2011/10/13</td></tr><tr><td>11.04 <code>Unity成为默认桌面环境</code></td><td>Natty Narwhal <code>敏捷的独角鲸</code></td><td>2011/04/28</td></tr><tr><td>10.10</td><td>Maverick Meerkat <code>标新立异的的狐獴</code></td><td>2010/10/10</td></tr><tr><td><strong>10.04 LTS</strong></td><td>Lucid Lynx <code>清醒的猞猁</code></td><td>2010/04/29</td></tr><tr><td>9.10</td><td>Karmic Koala <code>幸运的无尾熊</code></td><td>2009/10/29</td></tr><tr><td>9.04</td><td>Jaunty Jackalope <code>活泼的兔子</code></td><td>2009/04/23</td></tr><tr><td>8.10</td><td>Intrepid Ibex <code>无畏的高地山羊</code></td><td>2008/10/30</td></tr><tr><td>8.06 <code>官方查不到此版本发布信息</code></td><td>Haughty Husky <code>骄傲的哈士奇</code></td><td>2008/06/07</td></tr><tr><td><strong>8.04 LTS</strong></td><td>Hardy Heron <code>坚强的苍鹭</code></td><td>2008/04/24</td></tr><tr><td>7.10</td><td>Gutsy Gibbon <code>勇敢的长臂猿</code></td><td>2007/10/18</td></tr><tr><td>7.04</td><td>Feisty Fawn <code>烦躁不安的小鹿</code></td><td>2007/04/19</td></tr><tr><td>6.10</td><td>Edgy Eft <code>尖利的小蜥蜴</code></td><td>2006/10/26</td></tr><tr><td><strong>6.06 LTS</strong></td><td>Dapper Drake <code>整洁的公鸭</code></td><td>2006/06/01</td></tr><tr><td>5.10</td><td>Breezy Badger <code>活泼的獾</code></td><td>2005/10/13</td></tr><tr><td>5.04</td><td>Hoary Hedgehog <code>白发得刺猬</code></td><td>2005/04/08</td></tr><tr><td><strong>4.10 </strong><code>初始发布版本</code></td><td>Warty Warthog <code>多疣的疣猪</code></td><td>2004/10/20</td></tr></tbody></table><h3 id="docker-compose使用-转"><a href="#docker-compose使用-转" class="headerlink" title="docker-compose使用[转]"></a>docker-compose使用[转]</h3><h4 id="docker-compose常见命令"><a href="#docker-compose常见命令" class="headerlink" title="docker-compose常见命令"></a>docker-compose常见命令</h4><ul><li><strong>ps</strong>：列出所有运行容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><ul><li><strong>logs</strong>：查看服务日志输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs</span><br></pre></td></tr></table></figure><ul><li><strong>port</strong>：打印绑定的公共端口，下面命令可以输出 eureka 服务 8761 端口所绑定的公共端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose port eureka 8761</span><br></pre></td></tr></table></figure><ul><li><strong>build</strong>：构建或者重新构建服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br></pre></td></tr></table></figure><ul><li><strong>start</strong>：启动指定服务已存在的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose start eureka</span><br></pre></td></tr></table></figure><ul><li><strong>stop</strong>：停止已运行的服务的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop eureka</span><br></pre></td></tr></table></figure><ul><li><strong>rm</strong>：删除指定服务的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose rm eureka</span><br></pre></td></tr></table></figure><ul><li><strong>up</strong>：构建、启动容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><ul><li><strong>kill</strong>：通过发送 SIGKILL 信号来停止指定服务的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose kill eureka</span><br></pre></td></tr></table></figure><ul><li><strong>pull</strong>：下载服务镜像</li><li><strong>scale</strong>：设置指定服务运气容器的个数，以 service=num 形式指定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose scale user=3 movie=3</span><br></pre></td></tr></table></figure><ul><li><strong>run</strong>：在一个服务上执行一个命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run web bash</span><br></pre></td></tr></table></figure><p>### </p><h4 id="docker-compose-yml-字段含义"><a href="#docker-compose-yml-字段含义" class="headerlink" title="docker-compose.yml 字段含义"></a>docker-compose.yml 字段含义</h4><ul><li><strong>version</strong>：指定 docker-compose.yml 文件的写法格式</li><li><strong>services</strong>：多个容器集合</li><li><strong>build</strong>：配置构建时，Compose 会利用它自动构建镜像，该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">build: ./dir</span><br><span class="line">---------------</span><br><span class="line">build:</span><br><span class="line">    context: ./dir</span><br><span class="line">    dockerfile: Dockerfile</span><br><span class="line">    args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure><ul><li><strong>command</strong>：覆盖容器启动后默认执行的命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command: bundle exec thin -p 3000</span><br><span class="line">----------------------------------</span><br><span class="line">command: [bundle,exec,thin,-p,3000]</span><br></pre></td></tr></table></figure><ul><li><strong>dns</strong>：配置 dns 服务器，可以是一个值或列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line">------------</span><br><span class="line">dns:</span><br><span class="line">    - 8.8.8.8</span><br><span class="line">    - 9.9.9.9</span><br></pre></td></tr></table></figure><ul><li><strong>dns_search</strong>：配置 DNS 搜索域，可以是一个值或列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line">------------------------</span><br><span class="line">dns_search:</span><br><span class="line">    - dc1.example.com</span><br><span class="line">    - dc2.example.com</span><br></pre></td></tr></table></figure><ul><li><strong>environment</strong>：环境变量配置，可以用数组或字典两种方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">    RACK_ENV: development</span><br><span class="line">    SHOW: &apos;ture&apos;</span><br><span class="line">-------------------------</span><br><span class="line">environment:</span><br><span class="line">    - RACK_ENV=development</span><br><span class="line">    - SHOW=ture</span><br></pre></td></tr></table></figure><ul><li><strong>env_file</strong>：从文件中获取环境变量，可以指定一个文件路径或路径列表，其优先级低于 environment 指定的环境变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line">---------------</span><br><span class="line">env_file:</span><br><span class="line">    - ./common.env</span><br></pre></td></tr></table></figure><ul><li><strong>expose</strong>：暴露端口，只将端口暴露给连接的服务，而不暴露给主机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line">    - &quot;3000&quot;</span><br><span class="line">    - &quot;8000&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>image</strong>：指定服务所使用的镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: java</span><br></pre></td></tr></table></figure><ul><li><strong>network_mode</strong>：设置网络模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name/id]&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>ports</strong>：对外暴露的端口定义，和 expose 对应</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ports:   # 暴露端口信息  - &quot;宿主机端口:容器暴露端口&quot;</span><br><span class="line">- &quot;8763:8763&quot;</span><br><span class="line">- &quot;8763:8763&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>links</strong>：将指定容器连接到当前连接，可以设置别名，避免ip方式导致的容器重启动态改变的无法连接情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">links:    # 指定服务名称:别名 </span><br><span class="line">    - docker-compose-eureka-server:compose-eureka</span><br></pre></td></tr></table></figure><ul><li><strong>volumes</strong>：卷挂载路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - /lib</span><br><span class="line">  - /var</span><br></pre></td></tr></table></figure><ul><li><strong>logs</strong>：日志输出信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--no-color          单色输出，不显示其他颜.</span><br><span class="line">-f, --follow        跟踪日志输出，就是可以实时查看日志</span><br><span class="line">-t, --timestamps    显示时间戳</span><br><span class="line">--tail              从日志的结尾显示，--tail=200</span><br></pre></td></tr></table></figure><h4 id="更新容器"><a href="#更新容器" class="headerlink" title="更新容器"></a>更新容器</h4><ul><li>当服务的配置发生更改时，可使用 docker-compose up 命令更新配置</li><li>此时，Compose 会删除旧容器并创建新容器，新容器会以不同的 IP 地址加入网络，名称保持不变，任何指向旧容起的连接都会被关闭，重新找到新容器并连接上去</li></ul><h4 id="links"><a href="#links" class="headerlink" title="links"></a>links</h4><ul><li>服务之间可以使用服务名称相互访问，links 允许定义一个别名，从而使用该别名访问其它服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">    web:</span><br><span class="line">        build: .</span><br><span class="line">        links:</span><br><span class="line">            - &quot;db:database&quot;</span><br><span class="line">    db:</span><br><span class="line">        image: postgres</span><br></pre></td></tr></table></figure><ul><li>这样 Web 服务就可以使用 db 或 database 作为 hostname 访问 db 服务了</li></ul><h3 id="docker-stop-containerID，以后再重新启动时报错"><a href="#docker-stop-containerID，以后再重新启动时报错" class="headerlink" title="docker stop containerID，以后再重新启动时报错"></a>docker stop containerID，以后再重新启动时报错</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: driver failed programming external connectivity on endpoint app (3c0c01ac6b42b7a420644fc2b4debfbbcc0e1d2e74e6294155c28aca82f794c4):  (iptables failed: iptables --<span class="built_in">wait</span> -t nat -A DOCKER -p tcp -d 0/0 --dport 12345 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name.</span><br></pre></td></tr></table></figure><p>A: 重启docker即可：<code>systemctl restart docker</code></p><p>再开启你的容器： <code>docker run xxxx</code>或<code>docker start xxx</code></p><p>查看docker容器的运行日志</p><p><code>docker logs containerID</code></p><h3 id="docker端口映射到宿主机后外网仍无法访问容器的web"><a href="#docker端口映射到宿主机后外网仍无法访问容器的web" class="headerlink" title="docker端口映射到宿主机后外网仍无法访问容器的web"></a>docker端口映射到宿主机后外网仍无法访问容器的web</h3><p>A：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决办法：</span></span><br><span class="line">$ sudo vi /etc/sysctl.conf</span><br><span class="line">或者</span><br><span class="line">$ sudo  vi /usr/lib/sysctl.d/00-system.conf</span><br><span class="line"><span class="comment"># 添加如下代码：</span></span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line">重启network服务</span><br><span class="line">$ sudo systemctl restart network</span><br><span class="line"></span><br><span class="line">查看是否修改成功</span><br><span class="line">$ sudo sysctl net.ipv4.ip_forward</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果返回为“net.ipv4.ip_forward = 1”则表示成功了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker学习&quot;&gt;&lt;a href=&quot;#Docker学习&quot; class=&quot;headerlink&quot; title=&quot;Docker学习&quot;&gt;&lt;/a&gt;Docker学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;轻部署,省成本,易迁移&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="自动化运维" scheme="https://nymrli.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Python中的正则匹配</title>
    <link href="https://nymrli.top/2019/07/25/Python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"/>
    <id>https://nymrli.top/2019/07/25/Python中的正则匹配/</id>
    <published>2019-07-25T01:50:19.000Z</published>
    <updated>2019-07-25T01:59:58.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的正则匹配"><a href="#Python中的正则匹配" class="headerlink" title="Python中的正则匹配"></a>Python中的正则匹配</h1><blockquote><p>虽然正则早就会用了,但是有些使用方法老是忘记,因此还是写篇记录一下</p></blockquote><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table><thead><tr><th style="text-align:left">特别字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。</td></tr><tr><td style="text-align:left">( )</td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。要匹配 <em> 字符，请使用 \</em>。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td></tr><tr><td style="text-align:left">.</td><td style="text-align:left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。</td></tr><tr><td style="text-align:left">{</td><td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用 {。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left"></td><td>指明两项之间的一个选择。要匹配 \</td><td>，请使用 \</td><td>。</td></tr></tbody></table><hr><h2 id="特殊字符-1"><a href="#特殊字符-1" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <strong>runoo*b</strong> 中的 <strong>*</strong>，简单的说就是表示任何字符串的意思。如果要查找字符串中的 <strong>*</strong> 符号，则需要对 <strong>*</strong> 进行转义，即在其前加一个 <strong>\</strong>: <strong>runo*ob</strong> 匹配 runo*ob。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符<strong>\</strong> 放在它们前面。下表列出了正则表达式中的特殊字符：</p><table><thead><tr><th style="text-align:left">特别字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。</td></tr><tr><td style="text-align:left">( )</td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。要匹配 <em> 字符，请使用 \</em>。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td></tr><tr><td style="text-align:left">.</td><td style="text-align:left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。</td></tr><tr><td style="text-align:left">{</td><td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用 {。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left"></td><td>指明两项之间的一个选择。要匹配 \</td><td>，请使用 \</td><td>。</td></tr></tbody></table><hr><p><strong>*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。</strong></p><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 <strong>*</strong> 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td style="text-align:left">{n}</td><td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td style="text-align:left">{n,}</td><td style="text-align:left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td style="text-align:left">{n,m}</td><td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>定位符用来描述字符串或单词的边界，<strong>^</strong> 和 <strong>$</strong> 分别指字符串的开始与结束，<strong>\b</strong> 描述单词的前或后边界，<strong>\B</strong> 表示非单词边界。</p><p>正则表达式的定位符有：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td style="text-align:left">\B</td><td style="text-align:left">非单词边界匹配。</td></tr></tbody></table><h2 id="捕获与非捕获"><a href="#捕获与非捕获" class="headerlink" title="捕获与非捕获"></a>捕获与非捕获</h2><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。</p><p>其中 <strong>?:</strong> 是非捕获元之一，还有两个非捕获元是 <strong>?=</strong> 和 <strong>?!</strong>，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p><hr><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <strong>\n</strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p><p>可以使用非捕获元字符 <strong>?:</strong>、<strong>?=</strong> 或 <strong>?!</strong> 来重写捕获，忽略对相关匹配的保存。</p><p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：</p><h2 id="正则-lt-和-用法-https-www-cnblogs-com-whaozl-p-5462865-html"><a href="#正则-lt-和-用法-https-www-cnblogs-com-whaozl-p-5462865-html" class="headerlink" title="正则 ?&lt;= 和 ?= 用法](https://www.cnblogs.com/whaozl/p/5462865.html)"></a>正则 ?&lt;= 和 ?= 用法](<a href="https://www.cnblogs.com/whaozl/p/5462865.html" target="_blank" rel="noopener">https://www.cnblogs.com/whaozl/p/5462865.html</a>)</h2><p><strong>方法1： 匹配，捕获(存储)</strong></p><p>正则表达式：(?&lt;=(href=”)).{1,200}(?=(“&gt;))</p><p>解释：</p><p>(?&lt;=(href=”)) 表示 <strong>匹配</strong>以(href=”)<strong>开头</strong>的字符串，并且<strong>捕获(存储)</strong>到分组中</p><p>(?=(“&gt;)) 表示 <strong>匹配</strong>以(“&gt;)<strong>结尾</strong>的字符串，并且<strong>捕获(存储)</strong>到分组中</p><p><strong>方法2： 匹配，不捕获(不存储)</strong></p><p> 正则表达式：(?&lt;=(<strong>?:</strong>href=”)).{1,200}(?=(<strong>?:</strong>“&gt;))</p><p>​       解释：(?&lt;=(<strong>?:</strong>href=”)) 表示 <strong>匹配</strong>以(href=”)<strong>开头</strong>的字符串，并且<strong>不捕获(不存储)</strong>到分组中</p><p>​               (?=(<strong>?:</strong>“&gt;)) 表示 <strong>匹配</strong>以(“&gt;)<strong>结尾</strong>的字符串，并且<strong>不捕获(不存储)</strong>到分组中</p><table><thead><tr><th>(?:pattern)</th><th>非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(\</th><th>)”来组合一个模式的各个部分是很有用。例如“industr(?:y\</th><th>ies)”就是一个比“industry\</th><th>industries”更简略的表达式。</th></tr></thead><tbody><tr><td>(?=pattern)</td><td>非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95\</td><td>98\</td><td>NT\</td><td>2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95\</td><td>98\</td><td>NT\</td><td>2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。</td></tr><tr><td>(?&lt;=pattern)</td><td>非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95\</td><td>98\</td><td>NT\</td><td>2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td></tr><tr><td>(?&lt;!pattern)</td><td>非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95\</td><td>98\</td><td>NT\</td><td>2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题</td></tr></tbody></table><p> <strong>分组语法 捕获</strong><br><strong>(exp)</strong> 匹配exp,并捕获文本到自动命名的组里<br><strong>(?<name>exp)</name></strong> 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)<br><strong>(?:exp)</strong> 匹配exp,不捕获匹配的文本<br><strong>位置指定</strong><br><strong>(?=exp)</strong> 匹配exp前面的位置<br><strong>(?&lt;=exp)</strong> 匹配exp后面的位置<br><strong>(?!exp)</strong> 匹配后面跟的不是exp的位置<br><strong>(?&lt;!exp)</strong> 匹配前面不是exp的位置<br><strong>注释</strong><br><strong>(?#comment)</strong> 这种类型的组不对正则表达式的处理产生任何影响，只是为了提供让人阅读注释</p><p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面。</p><p><strong>位置指定</strong><br>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们用于指定一个位置，就像\b,^,$那样，因此它们也被称为零宽断言。最好还是拿例子来说明吧：</p><p>(?=exp)也叫零宽先行断言，它匹配文本中的某些位置，这些位置的后面能匹配给定的后缀exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如果在查找I’m singing while you’re dancing.时，它会匹配sing和danc。</p><p>(?&lt;=exp)也叫零宽后行断言，它匹配文本中的某些位置，这些位置的前面能给定的前缀匹配exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。</p><p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})*\b。请仔细分析这个表达式，它可能不像你第一眼看出来的那么简单。</p><p>下面这个例子同时使用了前缀和后缀：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><h3 id="常见正则表达式"><a href="#常见正则表达式" class="headerlink" title="常见正则表达式"></a>常见正则表达式</h3><ul><li><p>Email地址：^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$ </p></li><li><p>域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? </p></li><li><p>InternetURL：[a-zA-z]+://[^\s]<em> 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]</em>)?$ </p></li><li><p>手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ </p></li><li><p>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$  </p></li><li><p>身份证号(15位、18位数字)：^\d{15}|\d{18}$ </p></li><li><p>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</p></li><li><p>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$</p></li><li><p>日期格式：^\d{4}-\d{1,2}-\d{1,2}</p></li><li><p>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</p></li><li><p>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python中的正则匹配&quot;&gt;&lt;a href=&quot;#Python中的正则匹配&quot; class=&quot;headerlink&quot; title=&quot;Python中的正则匹配&quot;&gt;&lt;/a&gt;Python中的正则匹配&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;虽然正则早就会用了,但是有些使用方
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>利用wireshark抓取TCP的整个过程分析[转]</title>
    <link href="https://nymrli.top/2019/07/24/%E5%88%A9%E7%94%A8wireshark%E6%8A%93%E5%8F%96TCP%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://nymrli.top/2019/07/24/利用wireshark抓取TCP的整个过程分析/</id>
    <published>2019-07-24T07:51:29.000Z</published>
    <updated>2019-07-25T01:50:26.413Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://www.cnblogs.com/NickQ/p/9226579.html" target="_blank" rel="noopener">https://www.cnblogs.com/NickQ/p/9226579.html</a> </p><p>最近，已经很久都没有更新博客了。看看时间，想想自己做了哪些事情，突然发现自己真的是太贪心，到头来却一个都没搞好。手头的嵌入式都还没学出名堂，竟然还想着学FPGA,物联网，机器学习。然而，遇到新奇的事物，就会控制不住的去想，去找资料，实际上只是逃避遇到的问题，不想去解决而已。。最后的结果就是手头的活堆起来了，然后花大把整块的时间解决。真的是讨厌现在的自己。</p><p>以后还是慢慢记录吧，不管做了什么，都慢慢尝试积累。。其他的东西，像FPGA，机器学习什么的，让他随风去吧，用到啥学啥。其他的当看客，了解了解就好。</p><p>这是计算机网络的一次作业，学习抓取TCP/IP建立连接和断开连接的过程，以下是正文：</p><p><strong>步骤：</strong></p><p>首先尝试抓百度，腾讯等网络连接，发现会有许多问题需要考虑，断开连接操作不好操作，且数据冗杂不利于学习。</p><p><img src="https://images2018.cnblogs.com/blog/1249999/201806/1249999-20180625223300726-249267524.png" alt="img"></p><p>所以借助手机和电脑完成此次过程，操作如下：</p><p>1、在手机端，安装TCP测试工具，开启TCP监听，端口8088；</p><p><img src="https://images2018.cnblogs.com/blog/1249999/201806/1249999-20180625221400357-2132003606.jpg" alt="img"></p><p>2、打开wireshark监听WIFI网卡。</p><p>3、打开电脑端TCP测试客户端，连接TCP服务器。</p><p>此处，我的手机IP为192.168.255.5，端口8088；电脑的IP地址为192.168.255.6。</p><p>4、通过电脑客户端，发送两次信息到手机。</p><p>5、通过手机客户端，发送两次信息到电脑。</p><p>6、断开连接。</p><p>7、通过ip.addr eq 192.168.255.5 and ip.addr eq 192.168.255.6 and tcp过滤掉其他报文。</p><p>至于wireshark过滤的语法，可以参考其他的一些博文：<a href="https://blog.csdn.net/wojiaopanpan/article/details/69944970" target="_blank" rel="noopener">https://blog.csdn.net/wojiaopanpan/article/details/69944970</a></p><p><strong>协议及过程分析：</strong></p><p>TCP三次握手：如下图中蓝色方框所示。</p><p>TCP握手协议在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p><p>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；如下图中报文No.7</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；如下图中报文No.8</p><p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据。如下图中报文No.9</p><p><img src="https://images2018.cnblogs.com/blog/1249999/201806/1249999-20180625221206712-792100790.png" alt="img"></p><p>TCP四次挥手：如上图中红色方框所示。</p><p>注：此处，由于先断开的服务器，所以手机服务器是客户端A。</p><p>第一次挥手：客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</p><p>如图中报文No.255</p><p>第二次挥手：服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。如图中报文No.256</p><p>第三次挥手：服务器B关闭与客户端A的连接，发送一个FIN给客户端A。如图中报文No.257</p><p>第四次挥手：客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。如图中报文No.258</p><p><strong>其他:</strong></p><p>下图是其中一帧数据解析，可以看到数据是由192.168.255.6:62643(电脑客户端)发送给192.168.255.5:8088(手机服务端）。</p><p>消息内容为：201521111083</p><p><img src="https://images2018.cnblogs.com/blog/1249999/201806/1249999-20180625223511076-53478793.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/NickQ/p/9226579.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/NickQ/p/9226579.html&lt;/
      
    
    </summary>
    
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="https://nymrli.top/2019/07/13/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2019/07/13/C-学习笔记/</id>
    <published>2019-07-13T01:00:50.000Z</published>
    <updated>2019-07-13T01:01:29.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-学习笔记"><a href="#C-学习笔记" class="headerlink" title="C++学习笔记"></a>C++学习笔记</h1><blockquote><p>system（）就是调用（DOS）系统命令（和shell命令）。<br>pause ，即DOS命令集合中的暂停命令；</p></blockquote><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main( void )</span><br><span class="line">&#123;</span><br><span class="line">  char  buffer[200], s[] = &quot;computer&quot;, c = &apos;l&apos;;</span><br><span class="line">  int   i = 35, j;</span><br><span class="line">  float fp = 1.7320534f;  // 格式化并打印各种数据到buffer</span><br><span class="line">  j  = sprintf( buffer,    &quot;   String:    %s\n&quot;, s ); // C4996</span><br><span class="line">  j += sprintf( buffer + j,&quot;   Character: %c\n&quot;, c );</span><br><span class="line">  j += sprintf( buffer + j,&quot;   Integer:   %d\n&quot;, i );</span><br><span class="line">  j += sprintf( buffer + j,&quot;   Real:      %f\n&quot;, fp );</span><br><span class="line">  printf( &quot;Output:\n%s\ncharacter count = %d\n&quot;, buffer, j );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>返回写入buffer 的字符数，出错则返回-1. 如果 buffer 或 format 是空指针，且不出错而继续，函数将返回-1</li><li>sprintf 返回以format为格式argument为内容组成的结果被写入buffer 的字节数，结束字符‘\0’不计入内。即，如果“Hello”被写入空间足够大的buffer后，函数sprintf 返回5。</li></ul></blockquote><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>声明引用：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int &amp;c=a;  //int &amp; c=a;   △.声明引用时必须初始化</span><br></pre></td></tr></table></figure><p><strong>传引用参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func(int&amp; a)&#123;&#125; //函数名(xxx)xxx其实是创建形参变量的过程</span><br><span class="line">func(b);</span><br></pre></td></tr></table></figure><p><strong>传指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void func2(int *a)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>返回引用</strong></p><p>返回值不能是局部变量（局部变量在生命期结束后会被销毁）<br>​    （c中生命周期结束后，立马销毁，而在python中垃圾回收机制会在判断之后不使用的情况下再销毁）<br>func2(&amp;b);</p><h2 id="增强的for循环"><a href="#增强的for循环" class="headerlink" title="增强的for循环:"></a>增强的for循环:</h2><blockquote><p>在vc6.0中 for(int i=4;i&gt;0;i–)  i的作用域为　整个外部作用域如<br>void main()<br>{<br>​    for(int i=4;i&gt;0;i–) //作用域为整个main函数<br>}<br>   而在vs中 for(int i=4;i&gt;0;i–)  i的作用域为　该个for循环内<br>void main()<br>{<br>​    for(int i=4;i&gt;0;i–) //作用域为该个for循环<br>}</p></blockquote><hr><p>默认参数　从右往左连续</p><p>返回值不是函数重载的条件</p><hr><blockquote><p>malloc和free　不会触发构造函数或是析构函数<br>new和delete　可以</p></blockquote><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote><p>不做特别说明，类的数据成员和成员函数都被认为是private</p></blockquote><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><ul><li>this 是类成员函数的隐含参数，不是类的数据成员</li><li>静态成员无this指针</li></ul><h2 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h2><ul><li><p>常函数不能修改类中的数据成员的值</p></li><li><p>析构函数和构造函数不能是常函数</p></li><li>常变量只能调用常函数，不能调用普通函数</li><li>常对象只能调用常函数，不能调用普通函数</li></ul><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><ul><li>是类本身的属性，无对象时也可以直接调用Cstu::sta</li><li>静态成员函数只能调用静态数据成员<br>类外初始化　不需要static关键字 如： int Cstu::sta = 12;</li></ul><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = new int[2];</span><br><span class="line">delete[] a;</span><br></pre></td></tr></table></figure><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><ul><li>系统默认的为浅拷贝</li><li>有指针承运啊时得内存拷贝，所以使用深拷贝，</li><li>为了避免拷贝构造，运算符重载应该传引用</li></ul><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p><strong>何时会调用</strong></p><blockquote><p>1.新建一个对象，并将其初始化为同类现有对象</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cstu a;</span><br><span class="line">- Cstu a1(a);</span><br><span class="line">- Cstu a2 = a;</span><br><span class="line">- Cstu a3 = Cstu(a);　//创建了临时对象</span><br><span class="line">- Cstu a4 = new Cstu(a);</span><br><span class="line">- △.赋值并不会发生拷贝构造</span><br></pre></td></tr></table></figure><blockquote><p>2.当程序生成对象副本时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 参数是本类的常引用Cstu(const Cstu&amp;)</span><br><span class="line"></span><br><span class="line">- 普通构造函数如果空的话是不执行内容的，拷贝构造空的话是执行内容的</span><br><span class="line">- 默认的复制构造函数，逐个复制非静态成员的值，</span><br><span class="line"></span><br><span class="line">## 内联函数inline</span><br><span class="line"></span><br><span class="line">- 函数代码少，流程直接，调用频繁，如循环</span><br><span class="line">- 类内定义的都是内联函数（隐式），写inline为显性</span><br><span class="line">- 内联函数的定义一般写在头文件内</span><br><span class="line"></span><br><span class="line">- 只在声明位置写inline不管用，定义与声明都要有inline关键字</span><br><span class="line">- 空间换时间，使用频率低时速度快，频率高时，比较占用内存，主要看性价比</span><br><span class="line">- 递归不能是内联函数</span><br><span class="line"></span><br><span class="line">## 操作符重载</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 为了避免拷贝构造，运算符重载应该传引用或是传地址</span><br><span class="line">- 操作符重载必须有一个类类型的参数</span><br><span class="line">- =、[]、()、-&gt;必须是诚邀</span><br><span class="line">- 复合赋值运算符通常是成员</span><br><span class="line">- 改变对象状态的运算符，递增、解引用，通常是成员</span><br><span class="line"></span><br><span class="line">### 输出运算符重载:</span><br><span class="line"></span><br><span class="line">- 参数1是ostream引用，参数2是对象的常引用</span><br><span class="line">- 必须是类外重载，原因为1</span><br><span class="line">- 输出私有成员时，要用友元</span><br></pre></td></tr></table></figure></p></blockquote><p>void operator &lt;&lt; (ostream&amp; os,const &amp;Csty)，os &lt;&lt;st.nAge;<br>ostream&amp; operator &lt;&lt; (ostream&amp; os,const &amp;Csty)，os &lt;&lt;st.nAge;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 输入运算符重载:</span><br><span class="line"></span><br><span class="line">- 参数不匹配用ist.fail()检测</span><br><span class="line">- 输出=&gt;  ist&gt;&gt;st.nAge &gt;&gt; st.dbHeight;</span><br></pre></td></tr></table></figure></p><p>istream&amp; operator &gt;&gt;(istream&amp; ist,CStu&amp; st)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 前置+ +与后置+ +重载</span><br></pre></td></tr></table></figure></p><p>int operator++(Cstu* st){} =&gt;前置++</p><p>int operator++(Cstu* st,int n) =&gt;后置++<br>{<br>    int a =st.nage;<br>    st.nage +=1;<br>    return a;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">类型转换重载</span><br></pre></td></tr></table></figure></p><p>operator int()const{}            //无返回值，但有return </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">△.必须在类内。▲.const</span><br><span class="line"></span><br><span class="line">## 模板</span><br></pre></td></tr></table></figure><p>template <typename y=""><br>void func(Y a) cout &lt;&lt; a　&lt;&lt; endl;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">模板的具体化:</span><br></pre></td></tr></table></figure></typename></p><p>temlpate &lt;&gt; void func<node>(Node&amp; a){}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 模板具体化的执行优先级高于通用的优先级，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">◇.注意，STL头文件没有扩展名.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"># CPP</span><br><span class="line"></span><br><span class="line">```该类接受2个参数</span><br><span class="line">初始化列表</span><br><span class="line">class CStu</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int arr[4];</span><br><span class="line">    float b;</span><br><span class="line">//构造函数： </span><br><span class="line">CStu(*float c,int d*):a(2),b(2.2f),arr()    #成员初始化顺序只与声明顺序有关，与此处书写顺序无关</span><br><span class="line">    &#123;#新增语法，arr数组全初始化为0</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></node></p><p>▲.类必须先初始化成员变量。</p><p>​    。float c和int d 两个变量的作用域仅限于构造函数内.所以要想在整个类中使用该变量，就得将传入的参数初始化赋值给类中的变量。</p><p>​    若有多个构造函数，会执行初始化列表绑定所在的构造函数（构造函数的重载）</p><blockquote><p>数组的赋值：</p><blockquote><ul><li>初始化列表arr()</li><li>构造函数中for循环赋值</li><li>memset(&amp;arr[0],0,16)</li></ul></blockquote></blockquote><p>△.析构函数没有重载，且不接受参数。对象声明调用周期结束时自动调用。</p><p>▲构造函数和析构函数都必须写在public访问控制符下</p><hr><h2 id="malloc和new、free和delete区别"><a href="#malloc和new、free和delete区别" class="headerlink" title="malloc和new、free和delete区别"></a>malloc和new、free和delete区别</h2><ul><li>malloc不会触发构造函数，new可以</li><li>free不会触发析构函数，delete可以</li></ul><hr><h2 id="This指针"><a href="#This指针" class="headerlink" title="This指针"></a>This指针</h2><p>指针类型为类的类型。</p><p>this不是类的成员。</p><p>this指针为成员函数的隐含参数，相当于python类中的self…..(所以this指针的作用域为类内部)</p><hr><h2 id="常函数-1"><a href="#常函数-1" class="headerlink" title="常函数"></a>常函数</h2><figure class="highlight plain"><figcaption><span>CStu&#123;&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CStu</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    void show() const  #在括号之后</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>◆.析构函数、构造函数不能是常函数</p><p>◆.常函数不能修改数据成员（是类的），但可以修改常函数内的变量。</p><p>▲常函数的this指针的类型为const CStu*</p><p>★常对象(const CStu st)只能调用常函数，不能调用普通函数</p><hr><h2 id="静态成员-1"><a href="#静态成员-1" class="headerlink" title="静态成员"></a>静态成员</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CStu</span><br><span class="line">&#123;</span><br><span class="line">static int b;</span><br><span class="line">    public:</span><br><span class="line">    void show() const  #在括号之后</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>∷不能在构造函数的初始化列表中初始化，但可以类外初始化</p><p>∷类外初始化不用加static，而是int CStu::b = 12;</p><p>▲static受访问控制符约束。</p><p>调用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名作用域：cout&lt;&lt; CStu::b &lt;&lt; endl;</span><br><span class="line">对象：</span><br></pre></td></tr></table></figure><p>○只有静态常量整型数据才能直接在类中初始化，其他得在初始化列表或者构造函数中赋值（静态数据成员可以类外赋值），普通数据成员不能类外初始化。</p><p>●静态成员是跟类一一对应的，跟对象无关。</p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><blockquote><p>他是属于类的属性，不是对象的，即同一个类的所有对象共有一个（可以作为指挥类所有对象的方法）</p><p>无this指针</p><p>不能调用普通成员，只能调用静态成员</p></blockquote><hr><h2 id="拷贝构造-1"><a href="#拷贝构造-1" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><blockquote><p>public:</p><p>​    Cstu(const Cstu &amp;a){} 形式。参数是本类的常引用</p></blockquote><p>何时调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.新建一个对象，并将其初始化为同类时：</span><br><span class="line">- Cstu a1(a);#a为一个Cstu对象</span><br><span class="line">- Cstu a2 = a;  将不会再触发构造函数。</span><br><span class="line">- Cstu a3 = Cstu(a);   用a来拷贝构造一个临时对象，再用这个临时对象给a3</span><br><span class="line">- Cstu* a4 = new Cstu(a);</span><br><span class="line">2.当程序生成对象副本时：</span><br><span class="line">函数参数传递对象的值void fun(Cstu a)&#123;&#125;   （∵当调用这个函数的时候会为这个形参生成空间）</span><br><span class="line">▲有时为了效率要避免这种拷贝构造的产生，解决：传引用</span><br><span class="line">函数返回值 Cstu fun()&#123; Cstu a; return a;&#125; 返回值为创建了临时对象承接，然后再把临时变量返回。</span><br></pre></td></tr></table></figure><p>赋值不会调用：</p><blockquote><p>Cstu s1;</p><p>Cstu s2;</p><p>s2 = s1;</p></blockquote><h3 id="默认拷贝构造（浅拷贝）"><a href="#默认拷贝构造（浅拷贝）" class="headerlink" title="默认拷贝构造（浅拷贝）"></a>默认拷贝构造（浅拷贝）</h3><blockquote><p>逐个赋值非静态成员，（即默认拷贝构造中是有内容的，默认的构造函数是没有内容的）</p><p>内存排布一样，地址不同</p></blockquote><h3 id="深拷贝-涉及类中有指针"><a href="#深拷贝-涉及类中有指针" class="headerlink" title="深拷贝(涉及类中有指针)"></a>深拷贝(涉及类中有指针)</h3><p>如果是浅拷贝，则两个对象的指针都会指向同一个空间，如果第一个对象被消除后，这个空间就会被delete（free掉），所以第二个对象被删除时再操作（free）这个被释放掉的空间（已经还给系统），就相当于控制野指针，所以会报错。</p><p>解决方法1深拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this-&gt;a = new int[2];</span><br><span class="line">memcpy(this-&gt;a,b.a,8);</span><br><span class="line">strcpy(...)</span><br></pre></td></tr></table></figure><p>解决方法2传引用（不经过拷贝构造）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cstu&amp; fun(CStu&amp; a)</span><br><span class="line">&#123;return a;&#125;</span><br><span class="line">fun(a);</span><br></pre></td></tr></table></figure><p>解决方法3传地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cstu* fun(CStu* a)</span><br><span class="line">&#123;return a;&#125;</span><br><span class="line">fun(&amp;a);</span><br></pre></td></tr></table></figure><hr><h2 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h2><p>常规函数的调用过程：调用时，根据函数地址，跳到函数代码空间，执行指令，执行完再跳转到调用的位置。</p><p>内联函数：将函数代码直接复制到执行部分，不跳转。</p><blockquote><p>比常规函数稍快</p><p>占用更多内存（增加代码长度）</p></blockquote><p>▲声明和定义都要加inline 关键字</p><p>▲递归不能是内联函数</p><p>△.函数代码少时、调用频繁（for循环里）大多用内联函数（常规函数的话，跳转所耗时间占比就大）</p><p>▲.类内定义的函数都是内联函数，但如果定义在类外的话加inline为内联函数，不加就不是内联函数。</p><p>△.内联函数通常定义在头文件里。</p><hr><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>operator为关键字</p><p>“operator+”必须有一个类类型的形参；</p><hr><h2 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h2><blockquote><p>继承控制符：</p><p>public 父类：父类为什么访问控制符，子类就继承什么样的。</p><p>protected 父类:继承之后，父类的public降级为protected，低级或者同级的访问控制符不变（即protectedh和private)</p><p>private 父类：继承之后，父类全变为私有。</p></blockquote><h2 id="多态和虚函数"><a href="#多态和虚函数" class="headerlink" title="多态和虚函数"></a>多态和虚函数</h2><h3 id="多态：同样的调用有多种结果"><a href="#多态：同样的调用有多种结果" class="headerlink" title="多态：同样的调用有多种结果"></a>多态：同样的调用有多种结果</h3><p>通过虚函数调用子类的成员函数，形式为virtual void Show(){}  (函数名与子类相同)</p><blockquote><p>具体执行那个子类的函数由父类所指向的子类所决定. CFather* fa = new CSon1;</p></blockquote><hr><p>C++中声明结构体变量不需要‘struct’，struct默认为public,class 默认为private</p><p>c静态变量在预处理时声明。</p><p>cpp静态成员在类声明时声明。</p><h2 id="STL初始化"><a href="#STL初始化" class="headerlink" title="STL初始化"></a>STL初始化</h2><hr><ul><li><p>(1): vector<int> v;</int></p><blockquote><p>默认初始化，vector为空， size为0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。</p></blockquote></li><li><p>(2): vector<int> v2(v);</int></p><p>vector<int> v2= v; </int></p><blockquote><p>两种方式等价 ，ilist2 初始化为ilist 的拷贝，ilist必须与ilist2 类型相同，也就是同为int的vector类型，ilist2将具有和ilist相同的容量和元素</p></blockquote></li><li><p>(3): vector<int> ilist = {1,2,3.0,4,5,6,7};</int></p><p>vector<int> ilist {1,2,3.0,4,5,6,7};</int></p></li></ul><blockquote><p>初始化为列表中元素的拷贝，列表中元素必须与ilist的元素类型相容 </p></blockquote><ul><li><p>(4): vector<int> ilist3(ilist.begin()+2,ilist.end()-1); </int></p><blockquote><p>初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与ilist3 的元素类型相容 </p></blockquote></li><li><p>(5): vector<int> ilist4(7); </int></p><blockquote><p>默认值初始化，ilist4中将包含7个元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0， </p></blockquote></li><li><p>(6):vector<int> ilist5(7,3); </int></p><blockquote><p>指定值初始化，ilist5被初始化为包含7个值为3的int </p></blockquote></li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; idxs中</span><br><span class="line">for(int i : idxs)  ====&gt; for i in indx ..... i 为idxs中元素</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-学习笔记&quot;&gt;&lt;a href=&quot;#C-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;C++学习笔记&quot;&gt;&lt;/a&gt;C++学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;system（）就是调用（DOS）系统命令（和shell命令）。&lt;br&gt;pau
      
    
    </summary>
    
    
      <category term="C++" scheme="https://nymrli.top/tags/C/"/>
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>通过XDRP实现Windows远程访问ubuntu桌面</title>
    <link href="https://nymrli.top/2019/07/13/%E9%80%9A%E8%BF%87XDRP%E5%AE%9E%E7%8E%B0Windows%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEubuntu%E6%A1%8C%E9%9D%A2/"/>
    <id>https://nymrli.top/2019/07/13/通过XDRP实现Windows远程访问ubuntu桌面/</id>
    <published>2019-07-13T00:57:05.000Z</published>
    <updated>2019-07-13T00:57:31.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过XDRP实现Windows远程访问"><a href="#通过XDRP实现Windows远程访问" class="headerlink" title="通过XDRP实现Windows远程访问"></a>通过XDRP实现Windows远程访问</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装xrdp </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install xrdp </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装vnc4server </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install vnc4server tightvncserver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装xubuntu-desktop </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install xubuntu-desktop </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">向xsession中写入xfce4-session </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> “xfce4-session” &gt;~/.xsession </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">开启xrdp服务 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service xrdp restart</span></span><br></pre></td></tr></table></figure><p>上面是网上大多数示例所展示的，都是依靠第三方桌面系统实现远程访问，下面讲解的是如何直接访问原生系统。</p><h3 id="步骤一、下载TigerVNC-Server软件包"><a href="#步骤一、下载TigerVNC-Server软件包" class="headerlink" title="步骤一、下载TigerVNC Server软件包"></a>步骤一、下载TigerVNC Server软件包</h3><p>　　下载地址：<a href="http://www.c-nergy.be/downloads/tigervncserver_1.6.80-4_amd64.zip" target="_blank" rel="noopener">Tigervnc Deb软件包（适用于Ubuntu 16.04.1 - 64位）</a></p><h3 id="步骤二、-安装TigerVNC-Server软件包"><a href="#步骤二、-安装TigerVNC-Server软件包" class="headerlink" title="步骤二、 安装TigerVNC Server软件包"></a>步骤二、 安装TigerVNC Server软件包</h3><p>1、打开终端，进入到刚刚你你下载TigerVNC Server的存放目录，我是直接下载到默认的DownLoads下的，因为下载的是zip文件，记得解压出来，得到deb安装文件。</p><p>2、再输入一下安装命令进行安装（需要su密码）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install -f</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i tigervncserver_1.6.80-4_amd64.deb</span></span><br></pre></td></tr></table></figure><h3 id="步骤三、安装xrdp"><a href="#步骤三、安装xrdp" class="headerlink" title="步骤三、安装xrdp"></a>步骤三、安装xrdp</h3><p>　　打开终端，输入一下命令（需要su密码）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xrdp -y</span><br></pre></td></tr></table></figure><h3 id="步骤四、配置xrdp设置"><a href="#步骤四、配置xrdp设置" class="headerlink" title="步骤四、配置xrdp设置"></a>步骤四、配置xrdp设置</h3><p>　　需要通过xrdp连接到桌面，需要正确配置相关信息并填充到.xsession文件（针对每个用户）或/etc/startwm.sh（针对所有用户），输入如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> unity&gt;~/.xsession</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sed -i.bak <span class="string">'/fi/a #xrdp multi-users \n unity \n'</span> /etc/xrdp/startwm.sh</span></span><br></pre></td></tr></table></figure><h3 id="步骤五、重启xrdp"><a href="#步骤五、重启xrdp" class="headerlink" title="步骤五、重启xrdp"></a><strong>步骤五、重启xrdp</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service xrdp restart</span><br></pre></td></tr></table></figure><h3 id="步骤六、开启桌面共享功能"><a href="#步骤六、开启桌面共享功能" class="headerlink" title="步骤六、开启桌面共享功能"></a>步骤六、开启桌面共享功能</h3><p>　　进入系统-》首选项-》桌面共享，或者直接搜索桌面共享，如图所示</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192507153-638048489.png" alt="img"></p><p>　　将【允许其他人查看您的桌面】这一项勾上，如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192521575-517061538.png" alt="img"></p><p>到这一步基本上已经完成了，接下来就是来测试是否能正常连接到Ubuntu了</p><h1 id="三、xrdp测试连接到Ubuntu"><a href="#三、xrdp测试连接到Ubuntu" class="headerlink" title="三、xrdp测试连接到Ubuntu"></a>三、xrdp测试连接到Ubuntu</h1><p>　1、查看Ubuntu服务器的IP地址，如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192537450-1272034628.png" alt="img"></p><p>　　2、启动Windows远程桌面工具(mstc)，输入Ubuntu的IP地址（192.168.226.131），如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192554731-609673171.png" alt="img"></p><p>　　3、点击连接之后，正常情况会自动跳出xrdp的登录界面，需要我们输入用户名和密码即可，模式选择默认就行，如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192718465-137150594.png" alt="img"></p><p> 　　4、我们可以看到xrdp的实时日志，如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192751606-1594868562.png" alt="img"></p><p>　　5、最终我们连接到上了Ubuntu，是不是很熟悉的界面~~（ヾ(๑╹◡╹)ﾉ”）</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192821809-1569937933.png" alt="img"></p><p>　　至此，xrdp连接Ubuntu 16.04的所有步骤已完成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通过XDRP实现Windows远程访问&quot;&gt;&lt;a href=&quot;#通过XDRP实现Windows远程访问&quot; class=&quot;headerlink&quot; title=&quot;通过XDRP实现Windows远程访问&quot;&gt;&lt;/a&gt;通过XDRP实现Windows远程访问&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Ubuntu" scheme="https://nymrli.top/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>自动化运维工具Ansible</title>
    <link href="https://nymrli.top/2019/07/08/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7Ansible/"/>
    <id>https://nymrli.top/2019/07/08/自动化运维工具Ansible/</id>
    <published>2019-07-08T06:45:45.000Z</published>
    <updated>2019-08-22T12:42:57.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动化运维工具Ansible笔记"><a href="#自动化运维工具Ansible笔记" class="headerlink" title="自动化运维工具Ansible笔记"></a>自动化运维工具Ansible笔记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​        ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。<br>　　ansible是基于 paramiko 开发的,并且基于模块化工作，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。ansible不需要在远程主机上安装client/agents，因为它们是基于ssh来和远程主机通讯的。ansible目前已经已经被红帽官方收购，是自动化运维工具中大家认可度最高的，并且上手容易，学习简单。是每位运维工程师必须掌握的技能之一。</p><h2 id="ansible-特点"><a href="#ansible-特点" class="headerlink" title="ansible 特点"></a>ansible 特点</h2><ol><li>部署简单，只需在主控端部署Ansible环境，被控端无需做任何操作；</li><li>默认使用<strong>SSH协议</strong>对设备进行管理；</li><li>有大量常规运维操作模块，可实现日常绝大部分操作；</li><li>配置简单、功能强大、扩展性强；</li><li>支持API及自定义模块，<strong>可通过Python轻松扩展</strong>；</li><li>通过Playbooks来定制强大的配置、状态管理；</li><li>轻量级，<strong>无需在客户端安装agent(代理)</strong>，更新时，只需在操作机上进行一次更新即可；</li><li>提供一个功能强大、操作性强的<strong>Web管理界面和REST API接口</strong>——AWX平台。</li><li>Ansible适用于中小型应用环境；SaltStack适合大型（Ansible由于不需要代理,只是通过ssh,因此只能性能不如Saltstack高）</li></ol><h2 id="Ansible安装"><a href="#Ansible安装" class="headerlink" title="Ansible安装"></a>Ansible安装</h2><p>法1.在已有<code>python-pip</code>的情况下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pip install ansible</span><br></pre></td></tr></table></figure><p>法2:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo apt-add-repository ppa:ansible/ansible</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ansible</span><br></pre></td></tr></table></figure><p>如果安装失败请换源<code>sudo sed  -i  -re  &#39;s/\w+\.archive\.ubuntu\.com/archive.ubuntu.com/g&#39;  /etc/apt/sources.list</code>,更新安装库<code>sudo apt-get update</code></p><h2 id="ansible-架构图"><a href="#ansible-架构图" class="headerlink" title="ansible 架构图"></a>ansible 架构图</h2><p><img src="https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171205163000628-69838828.png" alt="img"><br>　　上图中我们看到的主要模块如下：</p><blockquote><p><code>Ansible</code>：Ansible核心程序。<br><code>HostInventory</code>：<strong>主机清单</strong> , 记录由Ansible管理的主机信息，包括端口、密码、ip等。<br><code>Playbooks</code>：“剧本”YAML格式文件，多个任务定义在一个文件中，定义主机需要调用哪些模块来完成的功能。<br><code>CoreModules</code>：<strong>核心模块</strong>，主要操作是通过调用核心模块来完成管理任务。<br><code>CustomModules</code>：自定义模块，完成核心模块无法完成的功能，支持多种语言。<br><code>ConnectionPlugins</code>：连接插件，Ansible和Host通信使用</p></blockquote><h2 id="ansible配置文件查找顺序"><a href="#ansible配置文件查找顺序" class="headerlink" title="ansible配置文件查找顺序"></a>ansible配置文件查找顺序</h2><ol><li>检查环境变量<code>ANSIBLE_CONFIG</code>指向的路径文件(export ANSIBLE_CONFIG=/etc/ansible.cfg)；</li><li>HOME目录下的配置文件<code>~/.ansible.cfg</code></li><li>检查当前目录下的ansible.cfg配置文件；</li><li><code>/etc/ansible.cfg</code>检查etc目录的配置文件。</li></ol><h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><ul><li>模块化：调用特定的模块，完成特定任务</li><li>有Paramiko，PyYAML，Jinja2（模板语言）三个关键模块支持自定义模块</li><li>基于Python语言实现</li><li>部署简单，基于python和SSH（默认已安装），agentless安全，基于OpenSSH支持playbook编排任务</li><li><strong>幂等性</strong>：一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况</li><li>无需代理不依赖PKI（无需ssl）可使用任何编程语言写模块</li><li>YAML格式，编排任务，支持丰富的数据结构</li><li>较强大的多层解决方案</li></ul><h2 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式:"></a>管理方式:</h2><ul><li>Ad-Hoc，及Ansible命令，主要用于临时命令使用场景</li><li>Ansible-Playbook，脚本，用于长期规划好，大型项目的场景，需要有提前的规划</li></ul><p>Ansible-playbook（剧本）执行过程：</p><ul><li>将已有编排好的任务集写入Ansible-Playbook</li><li>通过ansible-playbook命令分拆任务集至逐条ansible命令，按预定规则逐条执行</li></ul><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>/etc/ansible/ansible.cfg 主配置文件，配置ansible工作特性<br>/etc/ansible/hosts 主机清单<br>/etc/ansible/roles/存放角色的目录</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>/usr/bin/ansible 主程序，临时命令执行工具<br>/usr/bin/ansible-doc 查看配置文档，模块功能查看工具<br>/usr/bin/ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台<br>/usr/bin/ansible-playbook定制自动化任务，编排剧本工具/usr/bin/ansible-pull远程执行命令的工具<br>/usr/bin/ansible-vault 文件加密工具<br>/usr/bin/ansible-console 基于console界面与用户交互的执行工具</p><p>1.设置被管理的主机清单<code>vim /etc/ansible/hosts</code></p><p>2.1口令验证方式.<code>ansible 192.168.30.101 -m ping -k</code>用账号密码去确认受控端的身份</p><p>▲如果出现了这样的情况,需要先安装sshpass , <code>sudo apt install sshpass</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.100.180 | FAILED! =&gt; &#123;</span><br><span class="line">    "failed": true, </span><br><span class="line">    "msg": "ERROR! to use the 'ssh' connection type with passwords, you must install the sshpass program"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2基于key验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen</span><br><span class="line"><span class="meta">$</span> ssh-copy-id 192.168.30.101</span><br><span class="line"></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/xxxxxx/): </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in xxxxxxxxx.</span><br><span class="line">Your public key has been saved in xxxxx.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:xxxxxxxxxxxxxx</span><br><span class="line">The key's randomart image is:</span><br></pre></td></tr></table></figure><p>如果设置了passphrase,那么链接时需要输入passphrase,如果是ad-hoc就相当麻烦,而playbooks中有解决方法</p><h2 id="ad-hoc使用"><a href="#ad-hoc使用" class="headerlink" title="ad-hoc使用"></a>ad-hoc使用</h2><p>将<code>host_key_checking</code>取消注释,否则链接对象必须在known_hosts中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo vim /etc/ansible/ansible.cfg</span><br><span class="line"><span class="meta">#</span> uncomment this to disable SSH key host checking</span><br><span class="line"><span class="meta">#</span>host_key_checking = False</span><br></pre></td></tr></table></figure><p>显示日志,取消注释<code>log_path = /var/log/ansible.log</code></p><p>△.ansible不是长期执行的服务,不长期执行,因此修改配置后不需要重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ansible &lt;host-pattern&gt;[-m module_name][-a args]</span><br><span class="line"></span><br><span class="line">ansible dbsrvs -m command -a 'ls /root'-u wang-k -b-K</span><br><span class="line"><span class="meta">#</span> -u 以wang的身份登录,-b将wang切换成root,-K 输入root密码.</span><br><span class="line"><span class="meta">#</span> -m 指定模块名,-a指定模块参数</span><br></pre></td></tr></table></figure><h2 id="ansible的Host-pattern即匹配主机的列表"><a href="#ansible的Host-pattern即匹配主机的列表" class="headerlink" title="ansible的Host-pattern即匹配主机的列表"></a>ansible的Host-pattern即匹配主机的列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">All：表示所有Inventory中的所有主机</span><br><span class="line">ansible all-m ping</span><br><span class="line">：通配符</span><br><span class="line">ansible&quot;&quot;-m ping</span><br><span class="line">ansible 192.168.1.-m ping</span><br><span class="line">ansible&quot;srvs&quot;-m ping</span><br><span class="line">或关系</span><br><span class="line">ansible&quot;websrvsiappsrvs&quot;-m ping</span><br><span class="line">ansible&quot;192.168.1.10：192.168.1.20&quot;-m ping</span><br></pre></td></tr></table></figure><p>逻辑与<br><code>ansible&quot;websrvs:&amp;dbsrvs&quot;-m ping</code>在websrvs组并且在dbsrvs组中的主机,单引号、双引号都行</p><p>逻辑非<br><code>ansible websrvs:ldbsrvs&#39;-m ping</code>在websrvs组，但不在dbsrvs组中的主机<br>注意：<strong>此处为单引号</strong></p><p>综合逻辑<br><code>ansible‘websrvs:dbsrvs:&amp;appsrvs:lftpsrvs&#39;-m ping</code></p><p>正则表达式<br><code>ansible&quot;websrvs:&amp;dbsrvs&quot;-m ping</code></p><p><code>ansible&quot;~（webldb）.*\.magedu\.com&quot;-m ping</code></p><h2 id="ansible-command"><a href="#ansible-command" class="headerlink" title="ansible command"></a>ansible command</h2><ul><li>creates=<ul><li>存在,不执行</li></ul></li><li><p>removes=</p><ul><li>不存在,不执行</li></ul></li><li><p>chdir=</p><ul><li>切换目录后执行</li></ul></li></ul><h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><ul><li>command</li><li>shell<ul><li><code>ansible all -m shel1-a &#39;getenforce&#39;</code></li></ul></li><li>script</li><li>copy<ul><li><code>ansible all -m copy -a&#39;src=/root/ansible/selinux dest=/etc/selinux/config backup=yes&#39;</code></li><li><code>ansible all -m copy-a &#39;src=/etc/shadow dest=/data/mode=000 owner=wang&#39;</code></li></ul></li><li>fetch<ul><li><code>ansible srv-m fetch -a &#39;src=/root/a. sh dest=/data/scripts&#39;</code></li></ul></li><li>file<ul><li>文件操作,删除、创建</li></ul></li><li>unachieve、achieve<ul><li>压缩解压</li></ul></li><li>cron<ul><li>开启<code>ansible all-m cron -a &#39;minute=* weekday=1,3,5 jcb=&quot;/usr/bin/wall FBI warning&quot; name=warningcron&#39;</code></li><li>禁用<code>ansible all -m cron -a &#39;disabled=true job=&quot;/usr/bin/wall FBI warning&quot;name=warningcron&#39;</code>、启用<code>ansible all -m cron -a &#39;disabled=falsejob=&quot;/usr/bin/wall FBI warning&quot;name=warningcron&#39;</code></li><li>删除<code>ansible all -m cron -a &#39;job=&quot;/usr/bin/wall FBI warning&quot;name=warningcron state=absent&#39;</code></li></ul></li><li>apt、yum</li><li>user</li><li>group</li><li>service<ul><li><code>service:name=httpd state=started enabled=yes</code></li></ul></li><li>setup<ul><li><code>ansible websrvs -m setup -a &#39;filter=*address*&#39;</code></li></ul></li><li>template(不能放在ad-hoc)中,只能在playbook中使用</li></ul><p>command模块在针对<strong>管道</strong>、<strong>重定向有*…</strong>有问题==&gt;使用shell模块</p><p><a href="https://www.cnblogs.com/ExzaiTin/p/7918415.html" target="_blank" rel="noopener">常用模块介绍</a></p><h2 id="系列命令"><a href="#系列命令" class="headerlink" title="系列命令"></a>系列命令</h2><h3 id="galaxy"><a href="#galaxy" class="headerlink" title="galaxy"></a>galaxy</h3><p><code>ansible-galaxy install geerlingguy.nginx</code>    其中<code>geerlingguy</code>为角色在<code>./ansible/roles/</code></p><h3 id="playbooks"><a href="#playbooks" class="headerlink" title="playbooks"></a>playbooks</h3><blockquote><p>Yaml</p><p>YAML Ain’t Markup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</p></blockquote><h4 id="核心元素"><a href="#核心元素" class="headerlink" title="核心元素"></a>核心元素</h4><ul><li>Hosts 执行的远程主机列表</li><li>Tasks 任务集</li><li>Varniables 内置变量或自定义变量在playbook中调用Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件Handlers 和notity结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行</li><li>tags 标签指定某条任务执行，用于选择运行playbook中的部分代码。<ul><li>ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断<br>ansible-playbook-t tagsname useradd.yml</li></ul></li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>加密<code>ansible-vault encrypt hello.yml</code></p><p>解密查看<code>ansible-vault view hello.yml</code></p><p>重新制定口令<code>ansible-vault rekey hello.yml</code></p><h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p>如果命令或脚本的退出码不为零，可以使用如下方式替代</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span><span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line"><span class="attr">    shell:</span><span class="string">/usr/bin/somecommand</span> <span class="string">||/bin/true</span></span><br></pre></td></tr></table></figure><p>或者使用ignore_errors来忽略错误信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tasks：</span></span><br><span class="line"><span class="attr">  - name:</span><span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line"><span class="attr">    shell:</span><span class="string">/usr/bin/somecommand</span></span><br><span class="line"><span class="attr">ignore_errors:</span><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="运行playbook的方式"><a href="#运行playbook的方式" class="headerlink" title="运行playbook的方式"></a>运行playbook的方式</h2><p><code>ansible-playbook &lt;filename.yml&gt;..[options]</code><br>常见选项<br><code>-check(-C)</code>只检测可能会发生的改变，但不真正执行操作<br><code>--list-hosts</code>列出运行任务的主机<br><code>--limit</code>主机列表只针对主机列表中的主机执行<br><code>-V</code>显示过程-vw-vwv更详细</p><h2 id="handlers和notify"><a href="#handlers和notify" class="headerlink" title="handlers和notify"></a>handlers和notify</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span><span class="string">instal1</span> <span class="string">httpd</span> <span class="string">package</span> </span><br><span class="line"><span class="attr">    yum:</span><span class="string">name=httpd</span> </span><br><span class="line"><span class="attr">  - name:</span><span class="string">copy</span> <span class="string">conf</span> <span class="string">file</span> <span class="attr">copy:src=files/httpd.conf</span> <span class="string">dest=/etc/httpd/conf/backup=yes</span> </span><br><span class="line"><span class="attr">    notify:</span><span class="string">restart</span> <span class="string">service</span> </span><br><span class="line"><span class="attr">  - name:</span><span class="string">start</span> <span class="string">service</span></span><br><span class="line"><span class="attr">    service:</span><span class="string">name=httpd</span> <span class="string">state=started</span> <span class="string">enabled=yes</span> </span><br><span class="line"><span class="attr">  handlers:</span></span><br><span class="line"><span class="attr">    - name:</span><span class="string">restart</span> <span class="string">service</span> </span><br><span class="line"><span class="attr">      service:</span><span class="string">name=httpd</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure><p>标签</p><blockquote><p>指定标签来执行指定任务</p></blockquote><p><code>ansible-playbook -t  rshttp,xxxx httpd.yml</code></p><h2 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自动化运维工具Ansible笔记&quot;&gt;&lt;a href=&quot;#自动化运维工具Ansible笔记&quot; class=&quot;headerlink&quot; title=&quot;自动化运维工具Ansible笔记&quot;&gt;&lt;/a&gt;自动化运维工具Ansible笔记&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="运维" scheme="https://nymrli.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>staticmethod和classmethod区别</title>
    <link href="https://nymrli.top/2019/07/07/staticmethod%E5%92%8Cclassmethod%E5%8C%BA%E5%88%AB/"/>
    <id>https://nymrli.top/2019/07/07/staticmethod和classmethod区别/</id>
    <published>2019-07-07T02:06:00.000Z</published>
    <updated>2019-07-25T10:21:57.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="staticmethod和classmethod"><a href="#staticmethod和classmethod" class="headerlink" title="staticmethod和classmethod"></a>staticmethod和classmethod</h1><blockquote><p>类的实例化基本遵循创建实例对象、初始化实例对象、最后返回(产生)实例对象这么一个过程</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></span><br><span class="line">    data = <span class="string">'world'</span> <span class="comment"># 类对象的数据成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        self.arg = arg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod# 静态方法，不能访问类数据成员</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod# 类方法,能访问类数据成员</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = Test(<span class="string">'A'</span>)</span><br><span class="line">    Test.func()</span><br><span class="line">    Test.getData()</span><br></pre></td></tr></table></figure><h3 id="共同"><a href="#共同" class="headerlink" title="共同:"></a>共同:</h3><ul><li>两个都是装饰器，装饰的成员函数可以通过<code>类名.方法名(...)</code>来调用</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><ul><li>▲最显著的特点是<code>classmethod</code>需要传递一个参数<code>cls</code>，而<code>staticmethod</code>不需要。因此可以访问、修改类的属性，类的方法，实例化对象等，避免硬编码；而<code>staticmethod</code>不行</li><li><code>classmethod</code>可以判断出自己是通过基类被调用，还是通过某个子类被调用</li></ul><h3 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h3><ul><li><code>classmethod</code>多用于设计模式之<a href="https://stackoverflow.com/a/929273/2684304" target="_blank" rel="noopener">工厂模式</a>，将解析逻辑封装在方法本身内部。（也可认为构造前交互，即在进行<u>实例化类对象之前先进行某些逻辑操作</u>，即可看作进行不同的构造函数，然后返回一个类实例，见<a href="#具体代码">具体代码</a>）,更多拓展见附录<a href="#附录`__new__`和``__init__``"><code>__new__</code>和<code>__init__</code></a></li><li><code>staticmethod</code>用法就跟其他的语言中的静态static用法相同（可看作是属于该类的一个工具、辅助函数）</li></ul><h4 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python program to demonstrate  </span></span><br><span class="line"><span class="comment"># use of class method and static method. </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year)</span>:</span></span><br><span class="line">        super(time, self).__init__()</span><br><span class="line">        self.year = year</span><br><span class="line">        print(self.year)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># a class method to create a time that one day following the data 'year'</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tomorrow</span><span class="params">(cls,year)</span>:</span></span><br><span class="line">        print(type(cls)) <span class="comment"># &gt;&gt;&gt; ▲ Python所有类都继承自`&lt;class 'type'&gt;`，包括新式类`object`</span></span><br><span class="line">        <span class="keyword">return</span> cls(year+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># a static method to check whether the given data 'year' is after 2000.</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoThoundYear</span><span class="params">(year)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> year&gt;<span class="number">2000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = time(<span class="number">1999</span>)</span><br><span class="line">    t2 = time.tomorrow(<span class="number">1999</span>)</span><br><span class="line">    print( time.twoThoundYear(<span class="number">2001</span>) )</span><br></pre></td></tr></table></figure><p>可看下这篇<a href="https://www.geeksforgeeks.org/class-method-vs-static-method-python/" target="_blank" rel="noopener">class method vs static method in Python</a></p><h2 id="附录-new-和-init"><a href="#附录-new-和-init" class="headerlink" title="附录__new__和__init__"></a>附录<code>__new__</code>和<code>__init__</code></h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><blockquote><p>▲1. 首先要弄懂调用顺序<code>__new__</code>–&gt;<code>__init__</code>： 所以<code>__init__</code>其实不是实例化一个类的时候第一个被调用 的方法。当使用 Persion(name, age) 这样的表达式来实例化一个类时，最先被调用的方法 其实是<code>__new__</code>方法。</p><p><code>__new__</code>至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供（实例化时加的参数，也会被认为时cls的属性，见①）。即<strong>系统知道<code>__new__</code>() 方法始终都是类的类方法，即使没有被加上类方法装饰器。</strong></p><p><code>__new__</code>方法接受的参数虽然也是和<code>__init__</code>一样，但<code>__init__</code>是在类实例创建之后调用，而 <code>__new__</code>方法正是创建这个类实例的方法。</p><p>▲2. <code>__init__</code>有一个参数self，就是这个<code>__new__</code>中<strong>return的实例</strong>，<code>__init__</code>在<code>__new__</code>的基础上可以完成一些其它初始化的动作，<code>__init__</code>不需要返回值。而<code>__new__</code>必须有（可以return父类<code>__new__</code>出来的实例，或者直接是object的<code>__new__</code>出来的实例）。<code>__new__</code>方法决定了创建哪个类的实例（可以是父类，也可以是子类），因此不一定调用当前类的<code>__init__</code>。即（若<code>__new__</code>没有正确返回<strong>当前类cls</strong>的实例，那<code>__init__</code>是不会被调用的，即使是父类的实例也不行）</p><p>3.继承自object的<strong>新式类</strong>才有<code>__new__</code>，同时，在任何新式类的<code>__new__</code>()方法，<u>不能调用自身的<code>__new__</code>()来制造实例，因为这会造成死循环</u>，即<code>class Foo(object)</code>的<code>__new__</code>中不能<code>Foo.__new__(cls, *args, **kwargs)。</code></p></blockquote><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p>1.<code>__init__</code> 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。</p><p>2.<code>__new__</code> 通常用于控制生成一个新实例的过程。它是类级别的方法。</p><p>依照Python官方文档的说法，<code>__new__</code>方法主要是当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的metaclass。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span>    <span class="comment"># 新式类:继承自object</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,something)</span>:</span></span><br><span class="line">        print(<span class="string">'init'</span>)</span><br><span class="line">        print(something)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __new__(cls):  不行，因为A("...")参数不匹配</span></span><br><span class="line">    <span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'new'</span>)</span><br><span class="line">        self = object.__new__(cls) <span class="comment"># ①cls中包含了*args, **kwargs信息</span></span><br><span class="line">        self.x = <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># 调用父类的`__new__`方法会返回一个A对象，init里的参数self调用的就是这个self实例</span></span><br><span class="line">        <span class="comment"># `__new__`必须具有返回值，否则无法创建对象，因为`__init__`函数需要这个返回值</span></span><br><span class="line">        <span class="comment"># 自己在定义`__new__`的时候，参数要与`__init__`函数的参数匹配，我可以不用到这些参数，但一定要匹配。或者可以使用*arg和**args的形式。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># a = A.__new__(A) #&gt;&gt;&gt; new</span></span><br><span class="line">    a = A(<span class="string">'do it'</span>)  <span class="comment"># &gt;&gt;&gt; new init</span></span><br><span class="line">    print(a.__dict__)  <span class="comment"># &#123;'x': '1'&#125;</span></span><br><span class="line">    <span class="comment"># 2、new定义在type元类中，必须具有返回值，</span></span><br><span class="line">    <span class="comment"># 3、new的作用就是创建实例，然后将创建的实例传递给init进行初始化</span></span><br></pre></td></tr></table></figure><p>总结：  a = A() –&gt; <code>__new__</code>方法，return调用父类<code>__new__</code>生成一个类实例对象 –&gt;<code>__init__(self,...)</code>中的self实例就是这个父类<code>__new__</code>出来的实例</p><blockquote><p><code>__new__</code>() 是在新式类中新出现的方法，它作用在构造方法建造实例之前，可以这么理解，在 Python 中存在于类里面的构造方法 <code>__init__</code>() 负责将类的实例化，而在 <code>__init__</code>() 启动之前，<code>__new__</code>() 决定是否要使用该 <code>__init__</code>() 方法，因为<code>__new__</code>() 可以调用其他类的构造方法或者直接返回别的对象来作为本类的实例。</p></blockquote><h3 id="用-new-来实现设计模式中的–单例模式"><a href="#用-new-来实现设计模式中的–单例模式" class="headerlink" title="用__new__来实现设计模式中的–单例模式"></a><strong>用<code>__new__</code>来实现设计模式中的–单例模式</strong></h3><blockquote><p>只能实例化一个类对象</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'instance'</span>):</span><br><span class="line">            cls.instance = super(Singleton, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br></pre></td></tr></table></figure><p>▲ Python所有类都继承自<code>&lt;class &#39;type&#39;&gt;</code>，包括新式类<code>object</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;staticmethod和classmethod&quot;&gt;&lt;a href=&quot;#staticmethod和classmethod&quot; class=&quot;headerlink&quot; title=&quot;staticmethod和classmethod&quot;&gt;&lt;/a&gt;staticmethod和c
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>yaml基础语法_spring_boot</title>
    <link href="https://nymrli.top/2019/07/07/yaml%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-spring-boot/"/>
    <id>https://nymrli.top/2019/07/07/yaml基础语法-spring-boot/</id>
    <published>2019-07-07T02:04:35.000Z</published>
    <updated>2019-07-07T02:05:09.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yaml基础语法-spring-boot"><a href="#yaml基础语法-spring-boot" class="headerlink" title="yaml基础语法_spring_boot"></a>yaml基础语法_spring_boot</h1><blockquote><p>yaml aren’t markup language 即yaml不是标语语言：</p><p>xml（标记语言）:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">port</span>&gt;</span>8888<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>java spring boot默认全局配置文件:</p><ol><li><p><code>application.properties</code> 使用的时 <code>key=value</code></p></li><li><p><code>application.yaml</code>:</p><ul><li><p>k:<space>v</space></p></li><li><p>通过缩进，垂直对齐指定层次关系</p><ul><li>字符串可以默认不写引号，写引号中的转义符会被翻译：e.g.<code>&quot;天\n津&quot;</code></li></ul></li><li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">student:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">张三</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">  birthday:</span> <span class="number">2019</span><span class="string">/07/19</span></span><br><span class="line"><span class="attr">  location:</span> <span class="comment"># &lt;==&gt; &#123;province: 陕西, city: 西安&#125; 行内写法</span></span><br><span class="line">  <span class="attr">province:</span> <span class="string">陕西</span></span><br><span class="line">  <span class="attr">city:</span> <span class="string">西安</span></span><br><span class="line">  <span class="comment"># 对应java里的字典map</span></span><br><span class="line"><span class="attr">  hobbies:</span> <span class="comment"># &lt;==&gt; [足球,篮球]</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">足球</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">篮球</span></span><br><span class="line">  <span class="comment"># 对应java里的列表List</span></span><br><span class="line"><span class="attr">  skills:</span> <span class="comment"># &lt;==&gt;[编程,金融]</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">编程</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">金融</span></span><br><span class="line">  <span class="comment"># 对应java里的集合set</span></span><br><span class="line"><span class="attr">  pet:</span><span class="comment"># &lt;==&gt;&#123;name: wc, type: hsq&#125;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wc</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">hsq</span></span><br><span class="line"> <span class="comment"># entity的另一个类pet.java</span></span><br></pre></td></tr></table></figure></li><li><p>[Set,List,数组\Array]、{Map、对象类型的属性StudentPet}，[]可以省略，{}不可以省略 </p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;yaml基础语法-spring-boot&quot;&gt;&lt;a href=&quot;#yaml基础语法-spring-boot&quot; class=&quot;headerlink&quot; title=&quot;yaml基础语法_spring_boot&quot;&gt;&lt;/a&gt;yaml基础语法_spring_boot&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python类的继承-super()使用</title>
    <link href="https://nymrli.top/2019/07/07/Python%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF-super-%E4%BD%BF%E7%94%A8/"/>
    <id>https://nymrli.top/2019/07/07/Python类的继承-super-使用/</id>
    <published>2019-07-07T02:03:49.000Z</published>
    <updated>2019-07-07T02:05:43.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python类的继承即super-使用"><a href="#Python类的继承即super-使用" class="headerlink" title="Python类的继承即super()使用"></a>Python类的继承即super()使用</h1><h2 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h2><blockquote><p><code>super()</code> 函数是用于调用父类(超类)的一个方法，<em>只有在新式类中可以使用</em></p><p>super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO，Method Resolution Order，采用广度优先（区别于深度优先）的规则定义）、重复调用（钻石继承）等种种问题。</p><p>MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。</p></blockquote><p><strong>语法</strong></p><p>以下是 super() 方法的语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 菜鸟教程</span></span><br><span class="line">super(type [, object-<span class="keyword">or</span>-type])</span><br><span class="line"><span class="comment"># 个人理解</span></span><br><span class="line">super( ThisClass [, object(self)])</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li>type – 类（type），通常是当前子类。</li><li>object-or-type – 类实例，一般是 self</li></ul><p><strong>含义</strong></p><p>用<code>self</code>这个实例对象去查找<code>ThisClass</code>类的父类拥有的属性（成员方法、数据成员）</p><p>▲. Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 <strong>super().xxx</strong> 代替 <strong>super(Class, self).xxx</strong> :</p><p>即平时写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *arg, **kwarg)</span>:</span></span><br><span class="line">        super(TestClass, self).__init__() <span class="comment"># 此时init里不用self</span></span><br><span class="line">        <span class="comment"># 等价于 super().__init__() , 含义是用父类的构造函数初始化某些变量</span></span><br><span class="line">        <span class="comment"># 相当于旧式类的 object.__init__(self) # 需要传参self</span></span><br><span class="line">        self.arg = arg</span><br><span class="line">        self.kwarg = kwarg</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsSuper</span><span class="params">(object)</span>:</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsSub</span><span class="params">(clsSuper)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(super().age)</span><br><span class="line">        <span class="comment"># 当只是单继承的时候可以直接使用 print(clsSuper.age)，</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = clsSuper(<span class="string">'cl'</span>)</span><br><span class="line">    b = clsSub()</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><code>super().func()</code>是不用传参<code>self</code>的</li><li><code>super(type, obj).func()</code>函数调用的是obj实例在MRO中下一个父类的可调用func()，而不是type的父类中的func()。即调用最近的可用func()</li><li>使用<code>super()</code>不用指定父类的名称，便于修改维护；同时当继承多个类A、B的时候，用<code>super().__init__()</code>相当于调用多个类的<code>A.__ini__(self)</code>、<code>B.__ini__(self)</code></li></ul><h2 id="与java对比"><a href="#与java对比" class="headerlink" title="与java对比"></a>与java对比</h2><ol><li>Python中子类不会默认调用父类的构造函数，即下面代码。并不会要要求给传<code>name</code>。当然也可以理解为跟java一样调用了一个全空、没有任何内容的构造函数，但是在python中不需要显性写出来，原因部分是特点2（java中存在有参数的构造函数时，必须将空参数的构造函数显式写出，不然子类默认隐式调用空参数的构造函数时会报错说不存在）。</li><li>Python中的构造函数只有一个。但由于存在<code>*arg,**kwarg</code>的存在，所以只要执行类型检查执行不同的代码；即实现了多个构造函数</li><li>Python的类可以多继承，java只能单继承。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsSuper</span><span class="params">(object)</span>:</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        print(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsSub</span><span class="params">(clsSuper)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        print(age)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">class clsSub(clsSuper):</span></span><br><span class="line"><span class="string">    def __init__(self, age):</span></span><br><span class="line"><span class="string">        super().__init__() #调用父类的构造函数</span></span><br><span class="line"><span class="string">        print(age)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    b = clsSub(<span class="number">18</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python类的继承即super-使用&quot;&gt;&lt;a href=&quot;#Python类的继承即super-使用&quot; class=&quot;headerlink&quot; title=&quot;Python类的继承即super()使用&quot;&gt;&lt;/a&gt;Python类的继承即super()使用&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Base64编码原理与应用[转]</title>
    <link href="https://nymrli.top/2019/06/15/Base64%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8-%E8%BD%AC/"/>
    <id>https://nymrli.top/2019/06/15/Base64编码原理与应用-转/</id>
    <published>2019-06-15T04:08:53.000Z</published>
    <updated>2019-06-15T04:09:38.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Base64编码原理与应用-转"><a href="#Base64编码原理与应用-转" class="headerlink" title="Base64编码原理与应用[转]"></a><a href="http://blog.xiayf.cn/2016/01/24/base64-encoding/" target="_blank" rel="noopener">Base64编码原理与应用[转]</a></h1><p>2015年，我们在青云平台上实现了“百度云观测”应用。青云应用本质上是一个iframe，在向iframe服务方发送的请求中会携带一些数据，青云平台会使用<code>Base64 URL</code>对这些数据进行编码，其提供的编码解码算法示例如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// php版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64_URL_encode</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rtrim(strtr(base64_encode($data), <span class="string">'+/'</span>, <span class="string">'-_'</span>), <span class="string">'='</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64_URL_decode</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> base64_decode(str_pad(strtr($data, <span class="string">'-_'</span>, <span class="string">'+/'</span>), </span><br><span class="line">                            strlen($data) % <span class="number">4</span>, <span class="string">'='</span>, STR_PAD_RIGHT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>Base64 URL</code> 是标准Base64编码的一个变种，分别用 <code>-</code>、<code>_</code> 替换标准Base64编码结果中的 <code>+</code> 、 <code>/</code> ，并删除结果最后的 <code>=</code> 。</p><p>在实现 “百度云观测” 青云应用时，我在想：</p><ul><li>为什么要使用Base64编码？</li><li>Base64编码算法是什么样的？</li></ul><p>本文是围绕这两个问题思考和实践的结果。</p><p>我认为，理解Base64或其他类似编码的关键有两点：</p><ol><li>计算机最终存储和执行的是01二进制序列，这个二进制序列的含义则由解码程序/解释程序决定</li><li>很多场景下的数据传输要求数据只能由简单通用的字符组成，比如HTTP协议要求请求的首行和请求头都必须是ASCII编码</li></ol><p>以青云应用为例，简单解释这两点。青云平台通过POST一个表单来获取iframe，表单有 <code>payload</code> 和 <code>signature</code> 两项， <code>payload</code> 原本是一个JSON对象，其中的键值可能包含一些特殊字符，比如 <code>&amp;</code>、<code>/</code> 等，由于青云设计的一种通用的请求交互方案，需要考虑iframe服务方服务器端的各种可能实现，有些服务器端实现没有考虑表单值有这些特殊字符，或者POST请求被中间服务器转换成GET请求再次发出，对于URL来说，<code>&amp;</code>、<code>/</code>都是具有特殊含义的字符，所以需要对请求数据进行特殊编码避免这些字符出现 - 数据发送方对数据按规则进行编码，接收方对应地按规则解码数据。</p><h2 id="Base64编码原理"><a href="#Base64编码原理" class="headerlink" title="Base64编码原理"></a>Base64编码原理</h2><p>Base64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码。标准Base64编码使用的64个字符为：</p><p><img src="http://blog.xiayf.cn/2016/01/24/base64-encoding/media/14542616644295.jpg" alt="img"></p><p>这64个字符是各种字符编码（比如ASCII编码）所使用字符的子集，基本，并且可打印。唯一有点特殊的是最后两个字符，因对最后两个字符的选择不同，Base64编码又有很多变种，比如Base64 URL编码。</p><p>Base64编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续6比特（2的6次方=64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。</p><p>假设我们要对 <code>Hello!</code> 进行Base64编码，按照ASCII表，其转换过程如下图所示：</p><p><img src="http://blog.xiayf.cn/2016/01/24/base64-encoding/media/14542967158550.jpg" alt="img"></p><p>可知 <code>Hello!</code> 的Base64编码结果为 <code>SGVsbG8h</code> ，原始字符串长度为6个字符，编码后长度为8个字符，每3个原始字符经Base64编码成4个字符，编码前后长度比4/3，这个长度比很重要 - 比原始字符串长度短，则需要使用更大的编码字符集，这并不我们想要的；长度比越大，则需要传输越多的字符，传输时间越长。Base64应用广泛的原因是在字符集大小与长度比之间取得一个较好的平衡，适用于各种场景。</p><p>是不是觉得Base64编码原理很简单？</p><p>但这里需要注意一个点：Base64编码是<strong>每3个原始字符编码成4个字符</strong>(如<code>Hel</code>被编成了<code>SGVs</code>)，如果原始字符串长度不能被3整除，那怎么办？使用0值来补充原始字符串。===&gt;Base64的编码长度为4的倍数。</p><p>以 <code>Hello!!</code> 为例，其转换过程为：</p><p><img src="http://blog.xiayf.cn/2016/01/24/base64-encoding/media/14542966298000.jpg" alt="img"></p><p><em>注：图表中蓝色背景的二进制0值是额外补充的。</em></p><p><code>Hello!!</code> Base64编码的结果为 <code>SGVsbG8hIQAA</code> 。最后2个零值只是为了Base64编码而补充的，在原始字符中并没有对应的字符，那么Base64编码结果中的最后两个字符 <code>AA</code> 实际不带有效信息，所以需要特殊处理，以免解码错误。</p><p>标准Base64编码通常用 <code>=</code> 字符来替换最后的 <code>A</code>（完全由补充的0组成的A，跟<code>b&#39;H&#39;</code>的结果<code>SA==</code>区别一下），即编码结果为 <code>SGVsbG8hIQ==</code>。因为 <code>=</code> 字符并不在Base64编码索引表中，其意义在于结束符号，在Base64解码时遇到 <code>=</code> 时即可知道一个Base64编码字符串结束。</p><p>如果Base64编码字符串不会相互拼接再传输，那么最后的 <code>=</code> 也可以省略，解码时如果发现Base64编码字符串长度不能被4整除，则先补充 <code>=</code> 字符，再解码即可。</p><p>解码是对编码的逆向操作，但注意一点：<strong>对于最后的两个 = 字符，转换成两个 A 字符，再转成对应的两个6比特二进制0值，接着转成原始字符之前，需要将最后的两个6比特二进制0值丢弃，因为它们实际上不携带有效信息</strong>。</p><p>为了理解Base64编码解码过程，个人实现了一个非常简陋的Base64编码解码程序，见：<a href="https://github.com/youngsterxyf/xiaBase64" target="_blank" rel="noopener">youngsterxyf/xiaBase64</a>。</p><p>由于Base64应用广泛，所以很多编程语言的标准库都内置Base64编码解码包，如：</p><ul><li>PHP：<a href="http://php.net/manual/en/function.base64-encode.php" target="_blank" rel="noopener">base64_encode</a>、<a href="http://php.net/manual/en/function.base64-decode.php" target="_blank" rel="noopener">base64_decode</a></li><li>Python：<a href="https://docs.python.org/2/library/base64.html" target="_blank" rel="noopener">base64包</a></li><li>Go：<a href="https://golang.org/pkg/encoding/base64/" target="_blank" rel="noopener">encoding/base64</a></li><li>…</li></ul><h2 id="Base64编码应用"><a href="#Base64编码应用" class="headerlink" title="Base64编码应用"></a>Base64编码应用</h2><p>本文开始提到的青云应用例子只是Base64编码的应用场景之一。由于Base64编码在字符集大小与编码后数据长度之间做了较好的平衡，以及Base64编码变种形式的多样，使得Base64编码的应用场景非常广泛。下面举2个常用常见的例子。</p><h3 id="HTML内嵌Base64编码图片"><a href="#HTML内嵌Base64编码图片" class="headerlink" title="HTML内嵌Base64编码图片"></a>HTML内嵌Base64编码图片</h3><p>前端在实现页面时，对于一些简单图片，通常会选择将图片内容直接内嵌在页面中，避免不必要的外部资源加载，增大页面加载时间，但是图片数据是二进制数据，该怎么嵌入呢？<a href="http://caniuse.com/#search=Data URI" target="_blank" rel="noopener">绝大多数现代浏览器</a>都支持一种名为 <code>Data URLs</code> 的特性，允许使用Base64对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。以百度搜索首页为例，其中语音搜索的图标是个背景图片，其内容以 <code>Data URLs</code> 形式直接写在css中，这个css内容又直接嵌在HTML页面中，如下图所示：</p><p><img src="http://blog.xiayf.cn/2016/01/24/base64-encoding/media/14543011032759.jpg" alt="img"></p><p><code>Data URLs</code> 格式为：<code>url(data:文件类型;编码方式,编码后的文件内容)</code>。</p><p>当然，也可以直接基于image标签嵌入图片，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img alt=&quot;Embedded Image&quot; src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIA...&quot; /&gt;</span><br></pre></td></tr></table></figure><p>但请注意：如果图片较大，图片的色彩层次比较丰富，则不适合使用这种方式，因为其Base64编码后的字符串非常大，会明显增大HTML页面，影响加载速度。</p><h3 id="MIME（多用途互联网邮件扩展）"><a href="#MIME（多用途互联网邮件扩展）" class="headerlink" title="MIME（多用途互联网邮件扩展）"></a>MIME（多用途互联网邮件扩展）</h3><p>我们的电子邮件系统，一般是使用SMTP（简单邮件传输协议）将邮件从客户端发往服务器端，邮件客户端使用POP3（邮局协议，第3版本）或IMAP（交互邮件访问协议）从服务器端获取邮件。</p><p>SMTP协议一开始是基于纯ASCII文本的，对于二进制文件（比如邮件附件中的图像、声音等）的处理并不好，所以后来新增MIME标准来编码二进制文件，使其能够通过SMTP协议传输。</p><p>举例来说，我给自己发封邮件，正文为空，带一个名为hello.txt的附件，内容为 <code>您好！世界！</code>。导出邮件源码，其关键部分如下图所示：</p><p><img src="http://blog.xiayf.cn/2016/01/24/base64-encoding/media/14543057568109.jpg" alt="img"></p><p><code>MIME-Version: 1.0</code>：表示当前使用MIME标准1.0版本。</p><p><code>Content-Type: text/plain; name=&quot;hello.txt&quot;</code>：表示附件文件名为 <code>hello.txt</code> ，格式为纯文本。</p><p><code>Content-Transfer-Encoding: base64</code>：表示附件文件内容使用base64编码后传输。</p><p><code>5oKo5aW977yM5LiW55WM77yB</code>：则是文件内容 <code>您好，世界！</code> Base64编码后的结果。</p><p>不过，MIME使用的不是标准Base64编码。</p><h2 id="切忌误用"><a href="#切忌误用" class="headerlink" title="切忌误用"></a>切忌误用</h2><p>可能会有人在不理解Base64编码的情况下，将其误用于数据加密或数据校验。</p><p>Base64是一种数据编码方式，目的是让数据符合传输协议的要求。标准Base64编码解码无需额外信息即完全可逆，即使你自己自定义字符集设计一种类Base64的编码方式用于数据加密，在多数场景下也较容易破解。</p><p>对于数据加密应该使用专门的<strong>目前还没有有效方式快速破解的</strong>加密算法。比如：对称加密算法<code>AES-128-CBC</code>，对称加密需要密钥，只要密钥没有泄露，通常难以破解；也可以使用非对称加密算法，如 <code>RSA</code>，利用极大整数因数分解的计算量极大这一特点，使得使用公钥加密的数据，只有使用私钥才能快速解密。</p><p>对于数据校验，也应该使用专门的消息认证码生成算法，如 <code>HMAC</code> - 一种使用单向散列函数构造消息认证码的方法，其过程是不可逆的、唯一确定的，并且使用密钥来生成认证码，其目的是防止数据在传输过程中被篡改或伪造。将原始数据与认证码一起传输，数据接收端将原始数据使用相同密钥和相同算法再次生成认证码，与原有认证码进行比对，校验数据的合法性。</p><p>那么针对各大网站被脱库的问题，请问应该怎么存储用户的登录密码？</p><p>答案是：在注册时，根据用户设置的登录密码，生成其<strong>消息认证码</strong>，然后存储用户名和消息认证码，不存储原始密码。每次用户登录时，根据登录密码，生成消息认证码，与数据库中存储的消息认证码进行比对，以确认是否为有效用户，这样即使网站被脱库，用户的原始密码也不会泄露，不会为用户使用的其他网站带来账号风险。</p><p>当然，使用的消息认证码算法其哈希碰撞的概率应该极低才行，目前一般在HMAC算法中使用SHA256。对于这种方式需要注意一点：防止用户使用弱密码，否则也可能会被暴力破解。现在的网站一般要求用户密码6个字符以上，并且同时有数字和大小写字母，甚至要求有特殊字符。</p><p>另外，也可以使用加入随机salt的哈希算法来存储校验用户密码。这里暂不细述。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Base64兼顾字符集大小和编码后数据长度，并且可以灵活替换字符集的最后两个字符，以应对多样的需求，使其适用场景非常广泛。</p><p>当然，很多场景下有多种编码方式可选择，并非Base64编码不可，视需求，权衡利弊而定。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Base64、Base32、Base16区别"><a href="#Base64、Base32、Base16区别" class="headerlink" title="Base64、Base32、Base16区别"></a>Base64、Base32、Base16区别</h3><p>标准Base64：<br>包含大写字母（A-Z）,小写字母（a-z），数字（0-9）以及+/;<br>Base32:<br>而Base32中只有大写字母（A-Z）和数字234567；<br>Base16:<br>而Base16就是16进制，他的范围是数字(0-9)，字母（ABCDEF）；</p><p>顺便说一句，当ASCll用Base加密达不到所对应的位数的时候用=号补齐；<br>在这里附带由三种Base加密的:I love you！<br>Base64:SSBsb3ZlIHlvde+8gQ==<br>Base32:JEQGY33WMUQHS33V566IC===<br>Base16:49206c6f766520796f75efbc81</p><hr><p>1.由上可知，Base64编码后字符串长度为4的倍数</p><p>2.标准Base64编码通常用 <code>=</code> 字符来替换最后的 <code>A</code>（完全由补充的0组成的A，跟<code>b&#39;H&#39;</code>的结果<code>SA==</code>区别一下，<code>SA==</code>的A并不是全部由补充的0组成）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Base64编码原理与应用-转&quot;&gt;&lt;a href=&quot;#Base64编码原理与应用-转&quot; class=&quot;headerlink&quot; title=&quot;Base64编码原理与应用[转]&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://blog.xiayf.cn/2016/01/24
      
    
    </summary>
    
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python的构建工具setup.py</title>
    <link href="https://nymrli.top/2019/06/15/Python%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7setup-py/"/>
    <id>https://nymrli.top/2019/06/15/Python的构建工具setup-py/</id>
    <published>2019-06-15T04:08:44.000Z</published>
    <updated>2019-06-15T04:09:21.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python的构建工具setup-py"><a href="#Python的构建工具setup-py" class="headerlink" title="Python的构建工具setup.py"></a>Python的构建工具setup.py</h1><h2 id="setup-py各参数介绍："><a href="#setup-py各参数介绍：" class="headerlink" title="setup.py各参数介绍："></a>setup.py各参数介绍：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">--name 库名称，▲需要注意的是不要大写，不然会有坑</span><br><span class="line">--version (-V) 包版本</span><br><span class="line">--author 程序的作者</span><br><span class="line">--author_email 程序的作者的邮箱地址</span><br><span class="line">--maintainer 维护者</span><br><span class="line">--maintainer_email 维护者的邮箱地址</span><br><span class="line">--url 程序的官网地址</span><br><span class="line">--license 程序的授权信息</span><br><span class="line">--description 程序的简单描述</span><br><span class="line">--long_description 程序的详细描述</span><br><span class="line">--platforms 程序适用的软件平台列表</span><br><span class="line">--classifiers 程序的所属分类列表</span><br><span class="line">--keywords 程序的关键字列表</span><br><span class="line">--packages 需要处理的包目录（包含__init__.py的文件夹） </span><br><span class="line">--py_modules 需要打包的python文件列表</span><br><span class="line">--download_url 程序的下载地址</span><br><span class="line">--cmdclass </span><br><span class="line">--data_files 打包时需要打包的数据文件，如图片，配置文件等</span><br><span class="line">--scripts 安装时需要执行的脚步列表</span><br><span class="line">--package_dir 告诉setuptools哪些目录下的文件被映射到哪个源码包。一个例子：package_dir = &#123;&apos;&apos;: &apos;lib&apos;&#125;，表示“root package”中的模块都在lib 目录中。</span><br><span class="line">--requires 定义依赖哪些模块 </span><br><span class="line">--provides定义可以为哪些模块提供依赖 </span><br><span class="line">--find_packages() 对于简单工程来说，手动增加packages参数很容易，刚刚我们用到了这个函数，它默认在和setup.py同一目录下搜索各个含有 __init__.py的包。</span><br><span class="line">--install_requires = [&quot;requests&quot;] 需要安装的依赖包</span><br><span class="line">--entry_points 动态发现服务和插件，下面详细讲</span><br></pre></td></tr></table></figure><p>find_packages()还可以将包统一放在一个src目录中，另外，这个包内可能还有aaa.txt文件和data数据文件夹。另外，也可以排除一些特定的包 <code>find_packages(exclude=[&quot;*.tests&quot;, &quot;*.tests.*&quot;, &quot;tests.*&quot;, &quot;tests&quot;])</code></p><h2 id="实测操作"><a href="#实测操作" class="headerlink" title="实测操作"></a>实测操作</h2><h3 id="需要事前交代的内容"><a href="#需要事前交代的内容" class="headerlink" title="需要事前交代的内容"></a>需要事前交代的内容</h3><h4 id="模板setup-py"><a href="#模板setup-py" class="headerlink" title="模板setup.py"></a>模板setup.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note: To use the 'upload' functionality of this file, you must:</span></span><br><span class="line"><span class="comment">#   $ pip install twine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> rmtree</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> find_packages, setup, Command</span><br><span class="line"></span><br><span class="line"><span class="comment"># Package meta-data.</span></span><br><span class="line">NAME = <span class="string">'cltest'</span></span><br><span class="line">DESCRIPTION = <span class="string">'know how to'</span></span><br><span class="line">URL = <span class="string">''</span></span><br><span class="line">EMAIL = <span class="string">'10630529664@qq.com'</span></span><br><span class="line">AUTHOR = <span class="string">'Gao Liang'</span></span><br><span class="line">REQUIRES_PYTHON = <span class="string">'&gt;=3.0.0'</span></span><br><span class="line">VERSION = <span class="string">'0.3.0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># What packages are required for this module to be executed?</span></span><br><span class="line">REQUIRED = [</span><br><span class="line">    <span class="string">'requests &gt;= 2.20.0'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The rest you shouldn't have to touch too much :)</span></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"><span class="comment"># Except, perhaps the License and Trove Classifiers!</span></span><br><span class="line"><span class="comment"># If you do change the License, remember to change the Trove Classifier for that!</span></span><br><span class="line"></span><br><span class="line">here = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import the README and use it as the long-description.</span></span><br><span class="line"><span class="comment"># Note: this will only work if 'README.md' is present in your MANIFEST.in file!</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> io.open(os.path.join(here, <span class="string">'README.md'</span>), encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        long_description = <span class="string">'\n'</span> + f.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    long_description = DESCRIPTION</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the package's __version__.py module as a dictionary.</span></span><br><span class="line">about = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> VERSION:</span><br><span class="line">    <span class="keyword">with</span> open(os.path.join(here, NAME, <span class="string">'__version__.py'</span>)) <span class="keyword">as</span> f:</span><br><span class="line">        exec(f.read(), about)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    about[<span class="string">'__version__'</span>] = VERSION</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadCommand</span><span class="params">(Command)</span>:</span></span><br><span class="line">    <span class="string">"""Support setup.py upload."""</span></span><br><span class="line"></span><br><span class="line">    description = <span class="string">'Build and publish the package.'</span></span><br><span class="line">    user_options = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">status</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="string">"""Prints things in bold."""</span></span><br><span class="line">        print(<span class="string">'\033[1m&#123;0&#125;\033[0m'</span>.format(s))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize_options</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finalize_options</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.status(<span class="string">'Removing previous builds…'</span>)</span><br><span class="line">            rmtree(os.path.join(here, <span class="string">'dist'</span>))</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        self.status(<span class="string">'Building Source and Wheel (universal) distribution…'</span>)</span><br><span class="line">        os.system(<span class="string">'&#123;0&#125; setup.py sdist bdist_wheel --universal'</span>.format(sys.executable))</span><br><span class="line"></span><br><span class="line">        self.status(<span class="string">'Uploading the package to PyPI via Twine…'</span>)</span><br><span class="line">        os.system(<span class="string">'twine upload dist/*'</span>)</span><br><span class="line"></span><br><span class="line">        self.status(<span class="string">'Pushing git tags…'</span>)</span><br><span class="line">        os.system(<span class="string">'git tag v&#123;0&#125;'</span>.format(about[<span class="string">'__version__'</span>]))</span><br><span class="line">        os.system(<span class="string">'git push --tags'</span>)</span><br><span class="line"></span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Where the magic happens:</span></span><br><span class="line">setup(</span><br><span class="line">    name=NAME,</span><br><span class="line">    version=about[<span class="string">'__version__'</span>],</span><br><span class="line">    description=DESCRIPTION,</span><br><span class="line">    long_description=long_description,</span><br><span class="line">    long_description_content_type=<span class="string">'text/markdown'</span>,</span><br><span class="line">    author=AUTHOR,</span><br><span class="line">    author_email=EMAIL,</span><br><span class="line">    python_requires=REQUIRES_PYTHON,</span><br><span class="line">    url=URL,</span><br><span class="line">    packages=find_packages(exclude=(<span class="string">'tests'</span>,)),</span><br><span class="line">    <span class="comment"># If your package is a single module, use this instead of 'packages':</span></span><br><span class="line">    <span class="comment"># py_modules=['mypackage'],</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># entry_points=&#123;</span></span><br><span class="line">    <span class="comment">#     'console_scripts': ['mycli=mymodule:cli'],</span></span><br><span class="line">    <span class="comment"># &#125;,</span></span><br><span class="line">    install_requires=REQUIRED,</span><br><span class="line">    include_package_data=<span class="keyword">True</span>,</span><br><span class="line">    license=<span class="string">'MIT'</span>,</span><br><span class="line">    classifiers=[</span><br><span class="line">        <span class="comment"># Trove classifiers</span></span><br><span class="line">        <span class="comment"># Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers</span></span><br><span class="line">        <span class="string">'License :: OSI Approved :: MIT License'</span>,</span><br><span class="line">        <span class="string">'Programming Language :: Python'</span>,</span><br><span class="line">        <span class="string">'Programming Language :: Python :: 3'</span>,</span><br><span class="line">        <span class="string">'Programming Language :: Python :: 3.6'</span>,</span><br><span class="line">        <span class="string">'Programming Language :: Python :: Implementation :: CPython'</span>,</span><br><span class="line">        <span class="string">'Programming Language :: Python :: Implementation :: PyPy'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># $ setup.py publish support.</span></span><br><span class="line">    cmdclass=&#123;</span><br><span class="line">        <span class="string">'upload'</span>: UploadCommand,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="待打包的目录树："><a href="#待打包的目录树：" class="headerlink" title="待打包的目录树："></a>待打包的目录树：</h4><blockquote><p>E:.<br>│  MANIFEST.in<br>│  out.json<br>│  README.md<br>│  setup.py<br>│<br>└─files<br>     in.json<br>     txt.txt<br>     world.py<br>     <code>__init__.py</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ACCOUNT = <span class="string">'mrli'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printHello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello &#123;&#125;"</span>.format(ACCOUNT))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readTXT</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'txt.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        print(f.read())</span><br><span class="line">    <span class="comment"># print( os.listdir() )</span></span><br></pre></td></tr></table></figure><h4 id="MANIFEST-in内容"><a href="#MANIFEST-in内容" class="headerlink" title="MANIFEST.in内容"></a><code>MANIFEST.in</code>内容</h4><p><code>MANIFEST.in</code>决定了除了Py文件外的什么说明、配置文件会被打包进去(如<code>.txt、.json</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Include the README</span><br><span class="line">include *.md</span><br><span class="line"></span><br><span class="line"># Include the txt file</span><br><span class="line">include */*.txt</span><br><span class="line"></span><br><span class="line"># Include the data files</span><br><span class="line"># recursive-include xxxx/utils */*.json</span><br></pre></td></tr></table></figure><p>注意我操作这边时并没有include json文件，所以生成的项目树中也没有任何的json文件（无论是<code>in.json</code>还是<code>out.json</code>），而<code>txt.txt</code>是包含的，并且之后甚至能用readTXT()函数，直接读取打包的<code>txt.txt</code>的内容。</p><h5 id="关于MANIFEST-in"><a href="#关于MANIFEST-in" class="headerlink" title="关于MANIFEST.in"></a>关于<code>MANIFEST.in</code></h5><p>项目里会有一些非py文件，比如html和js等，这时候就要靠<code>include_package_data</code> 和 <code>package_data</code>及<code>packages</code>来指定了。<code>package_data</code>一般写成 <code>{&#39;your_package_name&#39;: [&quot;files&quot;]}</code>。keywords便于pypi索引。</p><p>▲.然而只设置了<code>include_package_data</code>还没完，还需要一个<code>MANIFEST.in</code>文件来明确指定哪些文件需要打到包中。===&gt;如果<code>include_package_data=True</code>的话，那么还需要写个<code>MANIFEST.in</code>来明确。</p><h3 id="python-setup-py-install安装"><a href="#python-setup-py-install安装" class="headerlink" title="python setup.py install安装"></a><code>python setup.py install</code>安装</h3><p>安装后的目录树</p><blockquote><p>│  MANIFEST.in<br>│  out.json(这是原来就在的)<br>│  README.md<br>│  setup.py<br>│<br>├─build（生成的文件夹）<br>│  ├─bdist.win-amd64<br>│  └─lib<br>│      └─files<br>│              txt.txt<br>│              world.py<br>│              <strong>init</strong>.py<br>│<br>├─cltest.egg-info（生成的文件夹）<br>│      dependency_links.txt<br>│      PKG-INFO<br>│      requires.txt<br>│      SOURCES.txt<br>│      top_level.txt<br>│<br>├─dist（生成的文件夹）<br>│      cltest-0.3.0-py3.7.egg<br>│<br>└─files<br>     in.json<br>     txt.txt<br>     world.py<br>     <code>__init__.py</code></p></blockquote><p>一共生成了<strong>3个文件夹</strong>为<code>build</code>、<code>dist</code>、<code>cltest.egg-info</code>，</p><ul><li><p><code>build\lib</code>下的就是自己想要打包的库的内容，即<code>files</code>里的模块。</p></li><li><p><code>dist</code>是加入到虚拟环境库下的文件<code>venv\Lib\site-packages</code>中可以找到<code>cltest-0.3.0-py3.7.egg</code></p></li><li><p><code>cltest.egg-info</code>中有生成很多文件</p><ul><li><p><code>dependency_links.txt</code>空的</p></li><li><p><code>PKG-INFO</code>内容是setup.py中设置的，关于库的描述</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Metadata-Version: 2.1</span><br><span class="line">Name: cltest</span><br><span class="line">Version: 0.3.0</span><br><span class="line">Summary: know how to</span><br><span class="line">Home-page: UNKNOWN</span><br><span class="line">Author: Gao Liang</span><br><span class="line">Author-email: 10630529664@qq.com</span><br><span class="line">License: MIT</span><br><span class="line">Description: </span><br><span class="line">        # 测试Setup工具</span><br><span class="line">        </span><br><span class="line">        hhhh</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">Platform: UNKNOWN</span><br><span class="line">Classifier: License :: OSI Approved :: MIT License</span><br><span class="line">Classifier: Programming Language :: Python</span><br><span class="line">Classifier: Programming Language :: Python :: 3</span><br><span class="line">Classifier: Programming Language :: Python :: 3.6</span><br><span class="line">Classifier: Programming Language :: Python :: Implementation :: CPython</span><br><span class="line">Classifier: Programming Language :: Python :: Implementation :: PyPy</span><br><span class="line">Requires-Python: &gt;=3.0.0</span><br><span class="line">Description-Content-Type: text/markdown</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>requires.txt</code>：内容是<code>setup.py</code>中<code>install_requires=REQUIRED</code>里设置的依赖内容，写法参看<code>requirements.txt</code></p></li><li><p><code>SOURCES.txt</code>：列出了所有被打包的文件</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MANIFEST.in</span><br><span class="line">README.md</span><br><span class="line">setup.py</span><br><span class="line">cltest.egg-info/PKG-INFO</span><br><span class="line">cltest.egg-info/SOURCES.txt</span><br><span class="line">cltest.egg-info/dependency_links.txt</span><br><span class="line">cltest.egg-info/requires.txt</span><br><span class="line">cltest.egg-info/top_level.txt</span><br><span class="line">files/__init__.py</span><br><span class="line">files/txt.txt</span><br><span class="line">files/world.py</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>top_level.txt</code>：列出了可用的模块，应该是由<code>packages=find_packages(exclude=(&#39;tests&#39;,)),</code>决定的，由于我只写了一个包<code>files</code>，所以内容也只有</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p>这边需要注意的是在<code>setup.py</code>中设置<code>name=&#39;cltest&#39;</code>是指的整个库的名字，但真正使用的是要看这个库下有哪些可用的包，包下有哪些模块。</p><p>在我的这个例子下面，可以通过库名<code>cltest</code>来找到、下载我这个库。在安装完以后，导入就得知道包名了，这边是<code>files</code>，所以使用得代码应该是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> files <span class="keyword">import</span> world</span><br><span class="line">world.readTXT()</span><br></pre></td></tr></table></figure><p>这个现象其实还挺常见的，比如<code>beautifulSoup4</code>库，使用的时候是<code>from bs4 import ..</code>；以及<code>python-opencv2</code>库，需要<code>import cv2 as cv</code>。其实就是这边<strong>库名与包名</strong>的区别。</p><h3 id="坑点记录"><a href="#坑点记录" class="headerlink" title="坑点记录:"></a>坑点记录:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> files <span class="keyword">import</span> world</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">def readTXT():</span></span><br><span class="line"><span class="string">    with open('txt.txt', 'r') as f:</span></span><br><span class="line"><span class="string">        print(f.read())</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">world.readTXT()</span><br></pre></td></tr></table></figure><p>由于’txt.txt’是相对路径，所以只有在运行脚本位置有<code>txt.txt</code>文件时才不会报错，一开始<code>from files import world</code>时报错<code>txt.txt</code>以为时<code>txt.txt</code>没有被打包进去（其实可以通过<code>Sources.txt</code>文件查看到底有没有被打包进去），后来才明白是使用<code>readTXT()</code>的当前目录下不存在而已。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python的构建工具setup-py&quot;&gt;&lt;a href=&quot;#Python的构建工具setup-py&quot; class=&quot;headerlink&quot; title=&quot;Python的构建工具setup.py&quot;&gt;&lt;/a&gt;Python的构建工具setup.py&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Oauth2原理、使用</title>
    <link href="https://nymrli.top/2019/06/03/Oauth2%E5%8E%9F%E7%90%86%E3%80%81%E4%BD%BF%E7%94%A8/"/>
    <id>https://nymrli.top/2019/06/03/Oauth2原理、使用/</id>
    <published>2019-06-03T13:22:30.000Z</published>
    <updated>2019-06-03T13:24:00.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oauth2原理、使用"><a href="#Oauth2原理、使用" class="headerlink" title="Oauth2原理、使用"></a>Oauth2原理、使用</h1><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>快递员–&gt;门禁–&gt;小区–&gt;我家    &lt;=====&gt; 第三方应用 –&gt; 微信墙 —&gt;账号–&gt;个人数据</p><blockquote><p>简单说，<em>OAuth</em> 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个<strong>短期的进入令牌</strong>（token），用来<u>代替密码</u>，供第三方应用使用。</p></blockquote><h2 id="OAuth-的核心就是向第三方应用颁发令牌"><a href="#OAuth-的核心就是向第三方应用颁发令牌" class="headerlink" title="OAuth 的核心就是向第三方应用颁发令牌"></a><strong>OAuth 的核心就是向第三方应用颁发令牌</strong></h2><h3 id="令牌特点："><a href="#令牌特点：" class="headerlink" title="令牌特点："></a>令牌特点：</h3><p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p><p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><h2 id="OAuth是什么？"><a href="#OAuth是什么？" class="headerlink" title="OAuth是什么？"></a>OAuth是什么？</h2><p> 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p><h2 id="四种获得令牌的流程"><a href="#四种获得令牌的流程" class="headerlink" title="四种获得令牌的流程:"></a><strong>四种获得令牌的流程</strong>:</h2><ul><li><p>授权码（authorization-code）</p><ul><li><p>1.发送请求A-&gt;B</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure></li><li><p>A（客户端）-&gt;B（）<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p></li></ul></li><li><p>第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像<code>https://a.com/callback?code=AUTHORIZATION_CODE</code></p></li><li><p>第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/token?</span><br><span class="line"> client_id=CLIENT_ID&amp;</span><br><span class="line"> client_secret=CLIENT_SECRET&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p></li></ul></li><li><p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p><ul><li><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="attr">"access_token"</span>:<span class="string">"ACCESS_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"token_type"</span>:<span class="string">"bearer"</span>,</span><br><span class="line">  <span class="attr">"expires_in"</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="attr">"refresh_token"</span>:<span class="string">"REFRESH_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"scope"</span>:<span class="string">"read"</span>,</span><br><span class="line">  <span class="attr">"uid"</span>:<span class="number">100101</span>,</span><br><span class="line">  "info":&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p></li></ul></li></ul></li><li><p>隐藏式（implicit）</p><ul><li><blockquote><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。</p></blockquote></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure><p><code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p></li><li><p><code>https://a.com/callback#token=ACCESS_TOKEN`</code>token`参数就是令牌，A 网站因此直接在前端拿到令牌。</p></li><li><p>▲注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p></li></ul></li><li><p>密码式（password）：</p><ul><li><blockquote><p>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</p></blockquote></li></ul></li><li><p>客户端凭证（client credentials）</p><ul><li><blockquote><p>适用于没有前端的命令行应用，即在命令行下请求令牌。</p></blockquote></li></ul></li></ul><p>clientID和ClientSecret均是App需要申请的API密钥</p><p><img src="/2019/06/03/Oauth2原理、使用/Oauth_ClientID.png" alt="Oauth_ClientID"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="Github-Oauth"><a href="#Github-Oauth" class="headerlink" title="Github Oauth"></a>Github Oauth</h2><h2 id="QQ-Oauth"><a href="#QQ-Oauth" class="headerlink" title="QQ Oauth"></a>QQ Oauth</h2><p>本地测试QQ的写法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 方法一：在hosts中将nymrli.top修改到<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">@app.route('/login')</span><br><span class="line">def login():</span><br><span class="line">params = &#123;</span><br><span class="line">'response_type' : 'code',</span><br><span class="line">'client_id' : '101568872',</span><br><span class="line">'redirect_uri' : 'http://beta.nymrli.top/oauth/qq',</span><br><span class="line">'state' : '1',</span><br><span class="line">&#125;</span><br><span class="line">url = 'https://graph.qq.com/oauth2.0/authorize?'</span><br><span class="line">urlParams = urlencode(params)</span><br><span class="line">    # ▲需要url编码</span><br><span class="line">comleteUrl = url + urlParams</span><br><span class="line"># <span class="keyword">return</span> url_for( )</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line">    ▲应该用redirect，而不是requests.get的text内容或者是url_for</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="keyword">return</span> redirect( comleteUrl)</span><br><span class="line">        </span><br><span class="line">@app.route('/oauth/qq')</span><br><span class="line">def getCode():</span><br><span class="line">return request.args.get('code')</span><br><span class="line">        </span><br><span class="line"># 方法二：随便申请一个应用</span><br><span class="line">@app.route('/login')</span><br><span class="line">def login():</span><br><span class="line">params = &#123;</span><br><span class="line">'response_type' : 'code',</span><br><span class="line">'client_id' : '101584056',</span><br><span class="line"># 'redirect_uri' : 'http://beta.nymrli.top/oauth/qq',</span><br><span class="line">'redirect_uri' : 'http://127.0.0.1:8000/oauth/redirect',</span><br><span class="line">'state' : 'test'</span><br><span class="line">&#125;</span><br><span class="line">url = 'https://graph.qq.com/oauth2.0/authorize?'</span><br><span class="line">urlParams = urlencode(params)</span><br><span class="line">comleteUrl = url + urlParams</span><br><span class="line"><span class="keyword">return</span> redirect( comleteUrl)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route('/oauth/redirect')</span><br><span class="line">def getCode():</span><br><span class="line">print(request.args)</span><br><span class="line">return 'hello'</span><br></pre></td></tr></table></figure><p><img src="/2019/06/03/Oauth2原理、使用/QQoauth_test.png" alt="QQoauth_test"></p><h3 id="坑点记录：部署"><a href="#坑点记录：部署" class="headerlink" title="坑点记录：部署"></a>坑点记录：部署</h3><blockquote><p>经过调试发现部署上去后，在<a href="http://beta.nymrli.top/info" target="_blank" rel="noopener">http://beta.nymrli.top/info</a>页面下获得不到    <code>access_token = session.get(&#39;access_token&#39;)</code>于是猜想session设置有问题。果然linux下<code>os.urandom(24)</code>有问题， 结果是无法获得到信息。经修改后能正常获得结果</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECRET_KEY= os.urandom(<span class="number">24</span>)  <span class="comment"># 设置为24位的字符,每次运行服务器都是不同的，所以服务器启动一次上次的session就清除。</span></span><br></pre></td></tr></table></figure><p><img src="/2019/06/03/Oauth2原理、使用/no.png" alt="no"></p><p>改成随便的SECRET_KEY的就行了，比如<code>SECRET_KEY=&#39;asdzxcqwe&#39;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Oauth2原理、使用&quot;&gt;&lt;a href=&quot;#Oauth2原理、使用&quot; class=&quot;headerlink&quot; title=&quot;Oauth2原理、使用&quot;&gt;&lt;/a&gt;Oauth2原理、使用&lt;/h1&gt;&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="flask" scheme="https://nymrli.top/tags/flask/"/>
    
      <category term="后端" scheme="https://nymrli.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Web" scheme="https://nymrli.top/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>lua学习</title>
    <link href="https://nymrli.top/2019/06/03/lua%E5%AD%A6%E4%B9%A0/"/>
    <id>https://nymrli.top/2019/06/03/lua学习/</id>
    <published>2019-06-03T13:22:03.000Z</published>
    <updated>2019-06-03T13:22:15.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lua学习"><a href="#lua学习" class="headerlink" title="lua学习"></a>lua学习</h1><blockquote><p>动态脚本语言，可嵌入C和C++，Lua负责逻辑，C、C++负责功能</p><p>C编译，跨平台性良好</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 循环结构 [1,10]</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">( ... )</span></span></span><br><span class="line"><span class="comment">-- body</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 选择结构</span></span><br><span class="line"><span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="表-lt-gt-字典"><a href="#表-lt-gt-字典" class="headerlink" title="表{} &lt;==&gt;字典"></a>表<code>{}</code> &lt;==&gt;字典</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Conftg=&#123; hello=<span class="string">"Hello Lua"</span>, world=<span class="string">"World"</span>&#125;</span><br><span class="line">Config.words=<span class="string">"Hello"</span></span><br><span class="line">Config.num=<span class="number">180</span></span><br><span class="line">Config[<span class="string">"name"</span>]=<span class="string">"ZhangSan"</span></span><br><span class="line"><span class="built_in">print</span>(Config[<span class="string">"words"</span>])</span><br><span class="line"><span class="built_in">print</span>(Config. name)</span><br><span class="line"><span class="built_in">print</span>(Config, hello)</span><br><span class="line"><span class="keyword">for</span> key, var <span class="keyword">in</span> <span class="built_in">pairs</span>(Config) <span class="keyword">do</span> </span><br><span class="line"><span class="built_in">print</span>(key, var)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组{}"></a>数组<code>{}</code></h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'hello'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(arr) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="number">3</span> </span><br><span class="line"><span class="number">4</span> hello</span><br></pre></td></tr></table></figure><p>▲索引从1开始</p><p>使用API<code>table</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数组插入</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>( arr , <span class="number">1</span>, i)</span><br><span class="line">    <span class="comment">-- 经sxh发现结果是逆序的,19-&gt;2,20-&gt;1 ， 原因是每次都从头部插入，相当于LIFO , 此时感觉像是数组（带索引key）...并且table.insert( arr , 2, i)结果只有2--&gt;20 ，此时像字典（只有键2）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 正序的顺出</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>( arr , i) <span class="comment">-- 默认在尾部开始插入</span></span><br><span class="line">    <span class="comment">-- 或者arr[i] = i</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 获得数组长度</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">maxn</span>(arr)</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote><p>没有class类关键字，但可以自己实现类的功能：</p><ul><li>复制表<code>table</code></li><li>函数闭包</li></ul></blockquote><h3 id="复制表table"><a href="#复制表table" class="headerlink" title="复制表table"></a>复制表<code>table</code></h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">people = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">people.sayHi</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Hi'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 法二</span></span><br><span class="line">people.sayHi = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Hi'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span><span class="params">( tab )</span></span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">arr[k] = tab[v]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 相当于是构造方法</span></span><br><span class="line">People.new = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span></span></span><br><span class="line"><span class="keyword">local</span> self = clone(People)</span><br><span class="line">self.name = name </span><br><span class="line"><span class="keyword">return</span> self </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 成员函数</span></span><br><span class="line">People.sayHi = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span> <span class="comment">-- self是类示例变量</span></span><br><span class="line"><span class="comment">-- ..是字符串连接 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"People say hi:"</span>.. self. name)</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试可以实现类的功能</span></span><br><span class="line"><span class="comment">--local p = clone(People)</span></span><br><span class="line"><span class="comment">--p.sayHi()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试构造函数</span></span><br><span class="line"><span class="keyword">local</span> p = People.new(<span class="string">"ZhangSan"</span>)</span><br><span class="line"><span class="comment">-- 需要传类示例</span></span><br><span class="line">p.sayHi(p)</span><br><span class="line"><span class="comment">-- 使用：可以不用传类示例</span></span><br><span class="line">p:sayHi()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Man=&#123;&#125;</span><br><span class="line"><span class="comment">-- 实现类的继承的功能</span></span><br><span class="line">Man.new = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span></span></span><br><span class="line"><span class="keyword">local</span> self =People.new(name)</span><br><span class="line">copy(self, Man)</span><br><span class="line"><span class="keyword">return</span> self </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增添成员函数</span></span><br><span class="line">Man.sayHello=<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Man say hello"</span>)</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重写成员函数</span></span><br><span class="line">Man.sayHi = <span class="function"><span class="keyword">function</span> <span class="params">(self)</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Man sayHi"</span>.. self.name)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">local</span> self = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">( name )</span></span></span><br><span class="line">self.name = name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello "</span>..self.name)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">init()</span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span><span class="params">(name)</span></span></span><br><span class="line"><span class="keyword">local</span> self= People(name)</span><br><span class="line"><span class="comment">-- local function init()</span></span><br><span class="line"><span class="comment">-- end </span></span><br><span class="line">self.sayHello=<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello"</span>..self.name)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>学习自 <a href="https://www.bilibili.com/video/av46428956/?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/av46428956/?p=8</a></p><hr><p>通过表的特性实现<code>switch</code>关键字功能</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = <span class="number">1</span>  </span><br><span class="line"><span class="keyword">local</span> switch = &#123;  </span><br><span class="line">    [<span class="number">1</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"switch:"</span>.<span class="number">.1</span>)  </span><br><span class="line">    <span class="keyword">end</span>,  </span><br><span class="line">    [<span class="number">2</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"switch:"</span>.<span class="number">.2</span>)  </span><br><span class="line">    <span class="keyword">end</span>,  </span><br><span class="line">    [<span class="string">"test"</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"switch:test"</span>)  </span><br><span class="line">    <span class="keyword">end</span>,  </span><br><span class="line">&#125;  </span><br><span class="line"> switch[<span class="number">2</span>]()</span><br><span class="line"><span class="comment">-- &gt;&gt;&gt; 2</span></span><br></pre></td></tr></table></figure><p>伪随机数的生成</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 因此“短时间内多次运行程序” 这样的需求下 os.time 还真不大好。可是又没有比 time 函数更方便的种子生成器， 怎么办呢？</span></span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="built_in">tostring</span>(<span class="built_in">os</span>.<span class="built_in">time</span>()):<span class="built_in">reverse</span>():<span class="built_in">sub</span>(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>, <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 就是把 time返回的数值字串倒过来（低位变高位）， 再取高位6位。 这样， 即使 time变化很小， 但是因为低位变了高位， 种子数值变化却很大，就可以使伪随机序列生成的更好一些</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lua学习&quot;&gt;&lt;a href=&quot;#lua学习&quot; class=&quot;headerlink&quot; title=&quot;lua学习&quot;&gt;&lt;/a&gt;lua学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;动态脚本语言，可嵌入C和C++，Lua负责逻辑，C、C++负责功能&lt;/p&gt;
&lt;p&gt;C编译，
      
    
    </summary>
    
    
      <category term="lua" scheme="https://nymrli.top/tags/lua/"/>
    
  </entry>
  
</feed>
