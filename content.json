{"meta":{"title":"果粒橙的博客","subtitle":"别装作很努力，结局不会陪你演戏。","description":"想和你讲，说了会心动 ，缄默会心安。","author":"果粒橙","url":"https://nymrli.top"},"pages":[{"title":"","date":"2019-06-03T13:09:14.994Z","updated":"2018-12-21T09:57:11.353Z","comments":true,"path":"google6b632f121e4f7422.html","permalink":"https://nymrli.top/google6b632f121e4f7422.html","excerpt":"","text":"google-site-verification: google6b632f121e4f7422.html"},{"title":"关于我","date":"2018-08-31T07:56:42.000Z","updated":"2018-09-04T04:36:10.718Z","comments":true,"path":"about/index.html","permalink":"https://nymrli.top/about/index.html","excerpt":"","text":"本人南邮自动化本科学生一枚.热爱捣鼓计算机,涉及Python、C、Java等语言.参加Robocup,ACM,未来打算弄机器学习、数据挖掘方面"},{"title":"css","date":"2018-08-31T11:13:48.000Z","updated":"2018-08-31T11:19:21.810Z","comments":false,"path":"tags/index.html","permalink":"https://nymrli.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Base64编码原理与应用[转]","slug":"Base64编码原理与应用-转","date":"2019-06-15T04:08:53.000Z","updated":"2019-06-15T04:09:38.494Z","comments":true,"path":"2019/06/15/Base64编码原理与应用-转/","link":"","permalink":"https://nymrli.top/2019/06/15/Base64编码原理与应用-转/","excerpt":"","text":"Base64编码原理与应用[转]2015年，我们在青云平台上实现了“百度云观测”应用。青云应用本质上是一个iframe，在向iframe服务方发送的请求中会携带一些数据，青云平台会使用Base64 URL对这些数据进行编码，其提供的编码解码算法示例如下： 12345678// php版本function base64_URL_encode($data) &#123; return rtrim(strtr(base64_encode($data), '+/', '-_'), '=');&#125;function base64_URL_decode($data) &#123; return base64_decode(str_pad(strtr($data, '-_', '+/'), strlen($data) % 4, '=', STR_PAD_RIGHT));&#125; 可以看出，Base64 URL 是标准Base64编码的一个变种，分别用 -、_ 替换标准Base64编码结果中的 + 、 / ，并删除结果最后的 = 。 在实现 “百度云观测” 青云应用时，我在想： 为什么要使用Base64编码？ Base64编码算法是什么样的？ 本文是围绕这两个问题思考和实践的结果。 我认为，理解Base64或其他类似编码的关键有两点： 计算机最终存储和执行的是01二进制序列，这个二进制序列的含义则由解码程序/解释程序决定 很多场景下的数据传输要求数据只能由简单通用的字符组成，比如HTTP协议要求请求的首行和请求头都必须是ASCII编码 以青云应用为例，简单解释这两点。青云平台通过POST一个表单来获取iframe，表单有 payload 和 signature 两项， payload 原本是一个JSON对象，其中的键值可能包含一些特殊字符，比如 &amp;、/ 等，由于青云设计的一种通用的请求交互方案，需要考虑iframe服务方服务器端的各种可能实现，有些服务器端实现没有考虑表单值有这些特殊字符，或者POST请求被中间服务器转换成GET请求再次发出，对于URL来说，&amp;、/都是具有特殊含义的字符，所以需要对请求数据进行特殊编码避免这些字符出现 - 数据发送方对数据按规则进行编码，接收方对应地按规则解码数据。 Base64编码原理Base64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码。标准Base64编码使用的64个字符为： 这64个字符是各种字符编码（比如ASCII编码）所使用字符的子集，基本，并且可打印。唯一有点特殊的是最后两个字符，因对最后两个字符的选择不同，Base64编码又有很多变种，比如Base64 URL编码。 Base64编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续6比特（2的6次方=64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。 假设我们要对 Hello! 进行Base64编码，按照ASCII表，其转换过程如下图所示： 可知 Hello! 的Base64编码结果为 SGVsbG8h ，原始字符串长度为6个字符，编码后长度为8个字符，每3个原始字符经Base64编码成4个字符，编码前后长度比4/3，这个长度比很重要 - 比原始字符串长度短，则需要使用更大的编码字符集，这并不我们想要的；长度比越大，则需要传输越多的字符，传输时间越长。Base64应用广泛的原因是在字符集大小与长度比之间取得一个较好的平衡，适用于各种场景。 是不是觉得Base64编码原理很简单？ 但这里需要注意一个点：Base64编码是每3个原始字符编码成4个字符(如Hel被编成了SGVs)，如果原始字符串长度不能被3整除，那怎么办？使用0值来补充原始字符串。===&gt;Base64的编码长度为4的倍数。 以 Hello!! 为例，其转换过程为： 注：图表中蓝色背景的二进制0值是额外补充的。 Hello!! Base64编码的结果为 SGVsbG8hIQAA 。最后2个零值只是为了Base64编码而补充的，在原始字符中并没有对应的字符，那么Base64编码结果中的最后两个字符 AA 实际不带有效信息，所以需要特殊处理，以免解码错误。 标准Base64编码通常用 = 字符来替换最后的 A（完全由补充的0组成的A，跟b&#39;H&#39;的结果SA==区别一下），即编码结果为 SGVsbG8hIQ==。因为 = 字符并不在Base64编码索引表中，其意义在于结束符号，在Base64解码时遇到 = 时即可知道一个Base64编码字符串结束。 如果Base64编码字符串不会相互拼接再传输，那么最后的 = 也可以省略，解码时如果发现Base64编码字符串长度不能被4整除，则先补充 = 字符，再解码即可。 解码是对编码的逆向操作，但注意一点：对于最后的两个 = 字符，转换成两个 A 字符，再转成对应的两个6比特二进制0值，接着转成原始字符之前，需要将最后的两个6比特二进制0值丢弃，因为它们实际上不携带有效信息。 为了理解Base64编码解码过程，个人实现了一个非常简陋的Base64编码解码程序，见：youngsterxyf/xiaBase64。 由于Base64应用广泛，所以很多编程语言的标准库都内置Base64编码解码包，如： PHP：base64_encode、base64_decode Python：base64包 Go：encoding/base64 … Base64编码应用本文开始提到的青云应用例子只是Base64编码的应用场景之一。由于Base64编码在字符集大小与编码后数据长度之间做了较好的平衡，以及Base64编码变种形式的多样，使得Base64编码的应用场景非常广泛。下面举2个常用常见的例子。 HTML内嵌Base64编码图片前端在实现页面时，对于一些简单图片，通常会选择将图片内容直接内嵌在页面中，避免不必要的外部资源加载，增大页面加载时间，但是图片数据是二进制数据，该怎么嵌入呢？绝大多数现代浏览器都支持一种名为 Data URLs 的特性，允许使用Base64对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。以百度搜索首页为例，其中语音搜索的图标是个背景图片，其内容以 Data URLs 形式直接写在css中，这个css内容又直接嵌在HTML页面中，如下图所示： Data URLs 格式为：url(data:文件类型;编码方式,编码后的文件内容)。 当然，也可以直接基于image标签嵌入图片，如下所示： 1&lt;img alt=&quot;Embedded Image&quot; src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIA...&quot; /&gt; 但请注意：如果图片较大，图片的色彩层次比较丰富，则不适合使用这种方式，因为其Base64编码后的字符串非常大，会明显增大HTML页面，影响加载速度。 MIME（多用途互联网邮件扩展）我们的电子邮件系统，一般是使用SMTP（简单邮件传输协议）将邮件从客户端发往服务器端，邮件客户端使用POP3（邮局协议，第3版本）或IMAP（交互邮件访问协议）从服务器端获取邮件。 SMTP协议一开始是基于纯ASCII文本的，对于二进制文件（比如邮件附件中的图像、声音等）的处理并不好，所以后来新增MIME标准来编码二进制文件，使其能够通过SMTP协议传输。 举例来说，我给自己发封邮件，正文为空，带一个名为hello.txt的附件，内容为 您好！世界！。导出邮件源码，其关键部分如下图所示： MIME-Version: 1.0：表示当前使用MIME标准1.0版本。 Content-Type: text/plain; name=&quot;hello.txt&quot;：表示附件文件名为 hello.txt ，格式为纯文本。 Content-Transfer-Encoding: base64：表示附件文件内容使用base64编码后传输。 5oKo5aW977yM5LiW55WM77yB：则是文件内容 您好，世界！ Base64编码后的结果。 不过，MIME使用的不是标准Base64编码。 切忌误用可能会有人在不理解Base64编码的情况下，将其误用于数据加密或数据校验。 Base64是一种数据编码方式，目的是让数据符合传输协议的要求。标准Base64编码解码无需额外信息即完全可逆，即使你自己自定义字符集设计一种类Base64的编码方式用于数据加密，在多数场景下也较容易破解。 对于数据加密应该使用专门的目前还没有有效方式快速破解的加密算法。比如：对称加密算法AES-128-CBC，对称加密需要密钥，只要密钥没有泄露，通常难以破解；也可以使用非对称加密算法，如 RSA，利用极大整数因数分解的计算量极大这一特点，使得使用公钥加密的数据，只有使用私钥才能快速解密。 对于数据校验，也应该使用专门的消息认证码生成算法，如 HMAC - 一种使用单向散列函数构造消息认证码的方法，其过程是不可逆的、唯一确定的，并且使用密钥来生成认证码，其目的是防止数据在传输过程中被篡改或伪造。将原始数据与认证码一起传输，数据接收端将原始数据使用相同密钥和相同算法再次生成认证码，与原有认证码进行比对，校验数据的合法性。 那么针对各大网站被脱库的问题，请问应该怎么存储用户的登录密码？ 答案是：在注册时，根据用户设置的登录密码，生成其消息认证码，然后存储用户名和消息认证码，不存储原始密码。每次用户登录时，根据登录密码，生成消息认证码，与数据库中存储的消息认证码进行比对，以确认是否为有效用户，这样即使网站被脱库，用户的原始密码也不会泄露，不会为用户使用的其他网站带来账号风险。 当然，使用的消息认证码算法其哈希碰撞的概率应该极低才行，目前一般在HMAC算法中使用SHA256。对于这种方式需要注意一点：防止用户使用弱密码，否则也可能会被暴力破解。现在的网站一般要求用户密码6个字符以上，并且同时有数字和大小写字母，甚至要求有特殊字符。 另外，也可以使用加入随机salt的哈希算法来存储校验用户密码。这里暂不细述。 总结Base64兼顾字符集大小和编码后数据长度，并且可以灵活替换字符集的最后两个字符，以应对多样的需求，使其适用场景非常广泛。 当然，很多场景下有多种编码方式可选择，并非Base64编码不可，视需求，权衡利弊而定。 补充Base64、Base32、Base16区别标准Base64：包含大写字母（A-Z）,小写字母（a-z），数字（0-9）以及+/;Base32:而Base32中只有大写字母（A-Z）和数字234567；Base16:而Base16就是16进制，他的范围是数字(0-9)，字母（ABCDEF）； 顺便说一句，当ASCll用Base加密达不到所对应的位数的时候用=号补齐；在这里附带由三种Base加密的:I love you！Base64:SSBsb3ZlIHlvde+8gQ==Base32:JEQGY33WMUQHS33V566IC===Base16:49206c6f766520796f75efbc81 1.由上可知，Base64编码后字符串长度为4的倍数 2.标准Base64编码通常用 = 字符来替换最后的 A（完全由补充的0组成的A，跟b&#39;H&#39;的结果SA==区别一下，SA==的A并不是全部由补充的0组成）","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"}]},{"title":"Python的构建工具setup.py","slug":"Python的构建工具setup-py","date":"2019-06-15T04:08:44.000Z","updated":"2019-06-15T04:09:21.657Z","comments":true,"path":"2019/06/15/Python的构建工具setup-py/","link":"","permalink":"https://nymrli.top/2019/06/15/Python的构建工具setup-py/","excerpt":"","text":"Python的构建工具setup.pysetup.py各参数介绍：12345678910111213141516171819202122232425--name 库名称，▲需要注意的是不要大写，不然会有坑--version (-V) 包版本--author 程序的作者--author_email 程序的作者的邮箱地址--maintainer 维护者--maintainer_email 维护者的邮箱地址--url 程序的官网地址--license 程序的授权信息--description 程序的简单描述--long_description 程序的详细描述--platforms 程序适用的软件平台列表--classifiers 程序的所属分类列表--keywords 程序的关键字列表--packages 需要处理的包目录（包含__init__.py的文件夹） --py_modules 需要打包的python文件列表--download_url 程序的下载地址--cmdclass --data_files 打包时需要打包的数据文件，如图片，配置文件等--scripts 安装时需要执行的脚步列表--package_dir 告诉setuptools哪些目录下的文件被映射到哪个源码包。一个例子：package_dir = &#123;&apos;&apos;: &apos;lib&apos;&#125;，表示“root package”中的模块都在lib 目录中。--requires 定义依赖哪些模块 --provides定义可以为哪些模块提供依赖 --find_packages() 对于简单工程来说，手动增加packages参数很容易，刚刚我们用到了这个函数，它默认在和setup.py同一目录下搜索各个含有 __init__.py的包。--install_requires = [&quot;requests&quot;] 需要安装的依赖包--entry_points 动态发现服务和插件，下面详细讲 find_packages()还可以将包统一放在一个src目录中，另外，这个包内可能还有aaa.txt文件和data数据文件夹。另外，也可以排除一些特定的包 find_packages(exclude=[&quot;*.tests&quot;, &quot;*.tests.*&quot;, &quot;tests.*&quot;, &quot;tests&quot;]) 实测操作需要事前交代的内容模板setup.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#!/usr/bin/env python# -*- coding: utf-8 -*-# Note: To use the 'upload' functionality of this file, you must:# $ pip install twineimport ioimport osimport sysfrom shutil import rmtreefrom setuptools import find_packages, setup, Command# Package meta-data.NAME = 'cltest'DESCRIPTION = 'know how to'URL = ''EMAIL = '10630529664@qq.com'AUTHOR = 'Gao Liang'REQUIRES_PYTHON = '&gt;=3.0.0'VERSION = '0.3.0'# What packages are required for this module to be executed?REQUIRED = [ 'requests &gt;= 2.20.0',]# The rest you shouldn't have to touch too much :)# ------------------------------------------------# Except, perhaps the License and Trove Classifiers!# If you do change the License, remember to change the Trove Classifier for that!here = os.path.abspath(os.path.dirname(__file__))# Import the README and use it as the long-description.# Note: this will only work if 'README.md' is present in your MANIFEST.in file!try: with io.open(os.path.join(here, 'README.md'), encoding='utf-8') as f: long_description = '\\n' + f.read()except FileNotFoundError: long_description = DESCRIPTION# Load the package's __version__.py module as a dictionary.about = &#123;&#125;if not VERSION: with open(os.path.join(here, NAME, '__version__.py')) as f: exec(f.read(), about)else: about['__version__'] = VERSIONclass UploadCommand(Command): \"\"\"Support setup.py upload.\"\"\" description = 'Build and publish the package.' user_options = [] @staticmethod def status(s): \"\"\"Prints things in bold.\"\"\" print('\\033[1m&#123;0&#125;\\033[0m'.format(s)) def initialize_options(self): pass def finalize_options(self): pass def run(self): try: self.status('Removing previous builds…') rmtree(os.path.join(here, 'dist')) except OSError: pass self.status('Building Source and Wheel (universal) distribution…') os.system('&#123;0&#125; setup.py sdist bdist_wheel --universal'.format(sys.executable)) self.status('Uploading the package to PyPI via Twine…') os.system('twine upload dist/*') self.status('Pushing git tags…') os.system('git tag v&#123;0&#125;'.format(about['__version__'])) os.system('git push --tags') sys.exit()# Where the magic happens:setup( name=NAME, version=about['__version__'], description=DESCRIPTION, long_description=long_description, long_description_content_type='text/markdown', author=AUTHOR, author_email=EMAIL, python_requires=REQUIRES_PYTHON, url=URL, packages=find_packages(exclude=('tests',)), # If your package is a single module, use this instead of 'packages': # py_modules=['mypackage'], # entry_points=&#123; # 'console_scripts': ['mycli=mymodule:cli'], # &#125;, install_requires=REQUIRED, include_package_data=True, license='MIT', classifiers=[ # Trove classifiers # Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers 'License :: OSI Approved :: MIT License', 'Programming Language :: Python', 'Programming Language :: Python :: 3', 'Programming Language :: Python :: 3.6', 'Programming Language :: Python :: Implementation :: CPython', 'Programming Language :: Python :: Implementation :: PyPy' ], # $ setup.py publish support. cmdclass=&#123; 'upload': UploadCommand, &#125;,) 待打包的目录树： E:.│ MANIFEST.in│ out.json│ README.md│ setup.py│└─files in.json txt.txt world.py __init__.py 12345678910ACCOUNT = 'mrli'def printHello(): print(\"hello &#123;&#125;\".format(ACCOUNT))def readTXT(): with open('txt.txt', 'r') as f: print(f.read()) # print( os.listdir() ) MANIFEST.in内容MANIFEST.in决定了除了Py文件外的什么说明、配置文件会被打包进去(如.txt、.json) 12345678# Include the READMEinclude *.md# Include the txt fileinclude */*.txt# Include the data files# recursive-include xxxx/utils */*.json 注意我操作这边时并没有include json文件，所以生成的项目树中也没有任何的json文件（无论是in.json还是out.json），而txt.txt是包含的，并且之后甚至能用readTXT()函数，直接读取打包的txt.txt的内容。 关于MANIFEST.in项目里会有一些非py文件，比如html和js等，这时候就要靠include_package_data 和 package_data及packages来指定了。package_data一般写成 {&#39;your_package_name&#39;: [&quot;files&quot;]}。keywords便于pypi索引。 ▲.然而只设置了include_package_data还没完，还需要一个MANIFEST.in文件来明确指定哪些文件需要打到包中。===&gt;如果include_package_data=True的话，那么还需要写个MANIFEST.in来明确。 python setup.py install安装安装后的目录树 │ MANIFEST.in│ out.json(这是原来就在的)│ README.md│ setup.py│├─build（生成的文件夹）│ ├─bdist.win-amd64│ └─lib│ └─files│ txt.txt│ world.py│ init.py│├─cltest.egg-info（生成的文件夹）│ dependency_links.txt│ PKG-INFO│ requires.txt│ SOURCES.txt│ top_level.txt│├─dist（生成的文件夹）│ cltest-0.3.0-py3.7.egg│└─files in.json txt.txt world.py __init__.py 一共生成了3个文件夹为build、dist、cltest.egg-info， build\\lib下的就是自己想要打包的库的内容，即files里的模块。 dist是加入到虚拟环境库下的文件venv\\Lib\\site-packages中可以找到cltest-0.3.0-py3.7.egg cltest.egg-info中有生成很多文件 dependency_links.txt空的 PKG-INFO内容是setup.py中设置的，关于库的描述 1234567891011121314151617181920212223Metadata-Version: 2.1Name: cltestVersion: 0.3.0Summary: know how toHome-page: UNKNOWNAuthor: Gao LiangAuthor-email: 10630529664@qq.comLicense: MITDescription: # 测试Setup工具 hhhh Platform: UNKNOWNClassifier: License :: OSI Approved :: MIT LicenseClassifier: Programming Language :: PythonClassifier: Programming Language :: Python :: 3Classifier: Programming Language :: Python :: 3.6Classifier: Programming Language :: Python :: Implementation :: CPythonClassifier: Programming Language :: Python :: Implementation :: PyPyRequires-Python: &gt;=3.0.0Description-Content-Type: text/markdown requires.txt：内容是setup.py中install_requires=REQUIRED里设置的依赖内容，写法参看requirements.txt SOURCES.txt：列出了所有被打包的文件 1234567891011MANIFEST.inREADME.mdsetup.pycltest.egg-info/PKG-INFOcltest.egg-info/SOURCES.txtcltest.egg-info/dependency_links.txtcltest.egg-info/requires.txtcltest.egg-info/top_level.txtfiles/__init__.pyfiles/txt.txtfiles/world.py top_level.txt：列出了可用的模块，应该是由packages=find_packages(exclude=(&#39;tests&#39;,)),决定的，由于我只写了一个包files，所以内容也只有 1files 如何使用？这边需要注意的是在setup.py中设置name=&#39;cltest&#39;是指的整个库的名字，但真正使用的是要看这个库下有哪些可用的包，包下有哪些模块。 在我的这个例子下面，可以通过库名cltest来找到、下载我这个库。在安装完以后，导入就得知道包名了，这边是files，所以使用得代码应该是 12from files import worldworld.readTXT() 这个现象其实还挺常见的，比如beautifulSoup4库，使用的时候是from bs4 import ..；以及python-opencv2库，需要import cv2 as cv。其实就是这边库名与包名的区别。 坑点记录:1234567from files import world'''def readTXT(): with open('txt.txt', 'r') as f: print(f.read())'''world.readTXT() 由于’txt.txt’是相对路径，所以只有在运行脚本位置有txt.txt文件时才不会报错，一开始from files import world时报错txt.txt以为时txt.txt没有被打包进去（其实可以通过Sources.txt文件查看到底有没有被打包进去），后来才明白是使用readTXT()的当前目录下不存在而已。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Oauth2原理、使用","slug":"Oauth2原理、使用","date":"2019-06-03T13:22:30.000Z","updated":"2019-06-03T13:24:00.063Z","comments":true,"path":"2019/06/03/Oauth2原理、使用/","link":"","permalink":"https://nymrli.top/2019/06/03/Oauth2原理、使用/","excerpt":"","text":"Oauth2原理、使用原理快递员–&gt;门禁–&gt;小区–&gt;我家 &lt;=====&gt; 第三方应用 –&gt; 微信墙 —&gt;账号–&gt;个人数据 简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。 OAuth 的核心就是向第三方应用颁发令牌令牌特点：（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。 （2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。 （3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。 OAuth是什么？ 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。 四种获得令牌的流程: 授权码（authorization-code） 1.发送请求A-&gt;B 12345https://b.com/oauth/authorize? response_type=code&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read A（客户端）-&gt;B（）response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。 第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像https://a.com/callback?code=AUTHORIZATION_CODE 第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。 123456https://b.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL 上面 URL 中，client_id参数和client_secret参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uri参数是令牌颁发后的回调网址。 第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。 123456789&#123; \"access_token\":\"ACCESS_TOKEN\", \"token_type\":\"bearer\", \"expires_in\":2592000, \"refresh_token\":\"REFRESH_TOKEN\", \"scope\":\"read\", \"uid\":100101, \"info\":&#123;...&#125;&#125; 上面 JSON 数据中，access_token字段就是令牌，A 网站在后端拿到了。 隐藏式（implicit） 有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。 12345https://b.com/oauth/authorize? response_type=token&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read response_type参数为token，表示要求直接返回令牌。 https://a.com/callback#token=ACCESS_TOKEN`token`参数就是令牌，A 网站因此直接在前端拿到令牌。 ▲注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。 密码式（password）： 如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。 客户端凭证（client credentials） 适用于没有前端的命令行应用，即在命令行下请求令牌。 clientID和ClientSecret均是App需要申请的API密钥 使用Github OauthQQ Oauth本地测试QQ的写法 12345678910111213141516171819202122232425262728293031323334353637383940414243# 方法一：在hosts中将nymrli.top修改到127.0.0.1@app.route('/login')def login(): params = &#123; 'response_type' : 'code', 'client_id' : '101568872', 'redirect_uri' : 'http://beta.nymrli.top/oauth/qq', 'state' : '1', &#125; url = 'https://graph.qq.com/oauth2.0/authorize?' urlParams = urlencode(params) # ▲需要url编码 comleteUrl = url + urlParams # return url_for( ) ''' ▲应该用redirect，而不是requests.get的text内容或者是url_for ''' return redirect( comleteUrl) @app.route('/oauth/qq')def getCode(): return request.args.get('code') # 方法二：随便申请一个应用@app.route('/login')def login(): params = &#123; 'response_type' : 'code', 'client_id' : '101584056', # 'redirect_uri' : 'http://beta.nymrli.top/oauth/qq', 'redirect_uri' : 'http://127.0.0.1:8000/oauth/redirect', 'state' : 'test' &#125; url = 'https://graph.qq.com/oauth2.0/authorize?' urlParams = urlencode(params) comleteUrl = url + urlParams return redirect( comleteUrl)@app.route('/oauth/redirect')def getCode(): print(request.args) return 'hello' 坑点记录：部署 经过调试发现部署上去后，在http://beta.nymrli.top/info页面下获得不到 access_token = session.get(&#39;access_token&#39;)于是猜想session设置有问题。果然linux下os.urandom(24)有问题， 结果是无法获得到信息。经修改后能正常获得结果 1SECRET_KEY= os.urandom(24) # 设置为24位的字符,每次运行服务器都是不同的，所以服务器启动一次上次的session就清除。 改成随便的SECRET_KEY的就行了，比如SECRET_KEY=&#39;asdzxcqwe&#39;","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Web","slug":"Web","permalink":"https://nymrli.top/tags/Web/"}]},{"title":"lua学习","slug":"lua学习","date":"2019-06-03T13:22:03.000Z","updated":"2019-06-03T13:22:15.930Z","comments":true,"path":"2019/06/03/lua学习/","link":"","permalink":"https://nymrli.top/2019/06/03/lua学习/","excerpt":"","text":"lua学习 动态脚本语言，可嵌入C和C++，Lua负责逻辑，C、C++负责功能 C编译，跨平台性良好 12345678910111213141516-- 循环结构 [1,10]for i=1,10 do print(i)end-- 函数function function_name( ... ) -- bodyend-- 选择结构if elseend 表{} &lt;==&gt;字典12345678910Conftg=&#123; hello=\"Hello Lua\", world=\"World\"&#125;Config.words=\"Hello\"Config.num=180Config[\"name\"]=\"ZhangSan\"print(Config[\"words\"])print(Config. name)print(Config, hello)for key, var in pairs(Config) do print(key, var)end 数组{}12345678910arr = &#123;1,2,3,'hello'&#125;for k,v in pairs(arr) do print(k,v)end&gt;&gt;&gt; 1 12 2 3 3 4 hello ▲索引从1开始 使用APItable 1234567891011-- 数组插入for i=1,10 do table.insert( arr , 1, i) -- 经sxh发现结果是逆序的,19-&gt;2,20-&gt;1 ， 原因是每次都从头部插入，相当于LIFO , 此时感觉像是数组（带索引key）...并且table.insert( arr , 2, i)结果只有2--&gt;20 ，此时像字典（只有键2） -- 正序的顺出 table.insert( arr , i) -- 默认在尾部开始插入 -- 或者arr[i] = iend-- 获得数组长度table.maxn(arr) 面向对象 没有class类关键字，但可以自己实现类的功能： 复制表table 函数闭包 复制表table12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364people = &#123;&#125;-- 法一function people.sayHi() print('Hi')end-- 法二people.sayHi = function () print('Hi') end-- 拷贝function clone( tab ) local arr = &#123;&#125; for k,v in pairs(tab) do arr[k] = tab[v] end return arrend-- 相当于是构造方法People.new = function (name) local self = clone(People) self.name = name return self end-- 成员函数People.sayHi = function(self) -- self是类示例变量 -- ..是字符串连接 print(\"People say hi:\".. self. name)end -- 测试可以实现类的功能--local p = clone(People)--p.sayHi()-- 测试构造函数local p = People.new(\"ZhangSan\")-- 需要传类示例p.sayHi(p)-- 使用：可以不用传类示例p:sayHi()Man=&#123;&#125;-- 实现类的继承的功能Man.new = function (name) local self =People.new(name) copy(self, Man) return self end-- 增添成员函数Man.sayHello=function() print(\"Man say hello\")end -- 重写成员函数Man.sayHi = function (self) print(\"Man sayHi\".. self.name)end 函数闭包123456789101112131415161718192021222324function People() local self = &#123;&#125; function init( name ) self.name = name end function sayHello() print(\"Hello \"..self.name) end init() return selfend-- 继承function Man(name) local self= People(name) -- local function init() -- end self.sayHello=function () print(\"hello\"..self.name) end return selfend 学习自 https://www.bilibili.com/video/av46428956/?p=8 通过表的特性实现switch关键字功能 1234567891011121314local key = 1 local switch = &#123; [1] = function() print(\"switch:\"..1) end, [2] = function() print(\"switch:\"..2) end, [\"test\"] = function() print(\"switch:test\") end, &#125; switch[2]()-- &gt;&gt;&gt; 2 伪随机数的生成 123456-- 因此“短时间内多次运行程序” 这样的需求下 os.time 还真不大好。可是又没有比 time 函数更方便的种子生成器， 怎么办呢？math.randomseed(tostring(os.time()):reverse():sub(1, 6))for i=1, 5 do print(math.random(4))end-- 就是把 time返回的数值字串倒过来（低位变高位）， 再取高位6位。 这样， 即使 time变化很小， 但是因为低位变了高位， 种子数值变化却很大，就可以使伪随机序列生成的更好一些","categories":[],"tags":[{"name":"lua","slug":"lua","permalink":"https://nymrli.top/tags/lua/"}]},{"title":"Java课程第三次实验报告","slug":"Java课程第三次实验报告","date":"2019-06-03T13:21:19.000Z","updated":"2019-06-03T13:21:43.038Z","comments":true,"path":"2019/06/03/Java课程第三次实验报告/","link":"","permalink":"https://nymrli.top/2019/06/03/Java课程第三次实验报告/","excerpt":"","text":"Java课程第三次实验报告\\1. 在前面实验二已定义的学生类Student的基础上，以Student类为父类，为学生类派生出一个子类为大学生类（CollegeStudent）。 CollegeStudent 类在学生类上增加一个专业（profession）数据属性；方法上增加获得专业和设置专业两个方法。并对超类中的toString( )方法进行重写，使得CollegeStudent类中的toString( )方法除了显示学生类的信息外，还要显示它的专业属性。 编写测试程序的主类。在主类中创建一个Student对象和CollegeStudent对象，并显示或修改这两个对象的属性值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//package homework; package student ; public class Student &#123; private int UID; private String name; private Boolean gender; // G- B- private int age; static int cnt ; public Student() &#123;&#125; public Student(int UID,String name,Boolean gender,int age) &#123; cnt ++ ; this.UID = UID; this.name = name; this.gender = gender; this.age = age; &#125; /** * @target 获得私有参数 */ public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public Boolean getGender() &#123; return gender; &#125; public int getUID() &#123; return UID; &#125; /** * @target 修改私有参数 */ public void setAge(int age) &#123; this.age = age; &#125; public void setUID(int uID) &#123; UID = uID; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setGender(Boolean gender) &#123; this.gender = gender; &#125; @Override protected void finalize() throws Throwable &#123; // TODO Auto-generated method stub System.out.println(\"对象已被销毁\");; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub if (gender) return \"该同学的学号为：\" + UID +\"，姓名叫：\" + name + \"，性别：男\" + \"，年龄：\" + age; return \"该同学的学号为：\" + UID +\"，姓名叫：\" + name + \"，性别：女\" + \"，年龄：\" + age; &#125; public static int getCnt() &#123; return cnt; &#125; &#125; //新建立的CoolegeStudent对象 class CollegeStudent extends Student&#123; private String profession; CollegeStudent(int studentID, String name, Boolean sex, int age, String profession) &#123; super( studentID, name, sex, age ); this.profession = profession; &#125; public String getProfession() &#123; return profession; &#125; public void setProfession(String profession) &#123; this.profession = profession; &#125; @Override public String toString() &#123; return \"CollegeStudent&#123;\" + \"profession='\" + profession + '\\'' + \"studentID='\" + super.getUID() + '\\'' + \", name='\" + super.getName() + '\\'' + \", sex='\" + super.getGender() + '\\'' + \", age=\" + super.getAge() + '&#125;'; &#125; &#125; 设计一个人员类（Person），其中包含一个方法pay，代表人员的工资支出。再从Person类派生出助教类（Assistant）、讲师类（Instructor）、副教授类（Assistant Professor）和教授类（Professor）。其中：工资支出=基本工资+授课时数*每课时兼课金。但助教基本工资为800，每课时兼课金25，讲师基本工资为1000，每课时兼课金35，副教授基本工资为1200，每课时兼课金40，教授基本工资为1400，每课时兼课金50。1.将Person定义为抽象类，pay为抽象方法，设计程序实现多态性。2.将Person定义为接口，设计程序实现多态性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//Person写成类： class Person &#123; public int basic; public int hour; public int charge; public Person() &#123; &#125; public Person(int basic, int charge) &#123; this.basic = basic; this.charge = charge; &#125; public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (basic + hour * charge) ); &#125; &#125; class Assistant extends Person &#123; public Assistant() &#123; super( 800, 25 ); &#125; &#125; class Instructor extends Person &#123; public Instructor() &#123; super( 1000, 35 ); &#125; &#125; class AssistantProfessor extends Person &#123; public AssistantProfessor() &#123; super( 1200, 40 ); &#125; &#125; class Professor extends Person &#123; public Professor() &#123; super( 1400, 50 ); &#125; &#125; //Person写成抽象类 abstract class Person &#123; public int hour; public abstract void pay(int hour); class Assistant extends Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (800 + hour * 25) ); &#125; &#125; class Instructor extends Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1000 + hour * 35) ); &#125; &#125; class AssistantProfessor extends Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1200 + hour * 40) ); &#125; &#125; class Professor extends Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1400 + hour * 50) ); &#125; &#125; /** * @author mrli * 接口写法 */ interface Person &#123; void pay(int hour); &#125; class Assistant implements Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (800 + hour * 25) ); &#125; &#125; class Instructor implements Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1000 + hour * 35) ); &#125; &#125; class AssistantProfessor implements Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1200 + hour * 40) ); &#125; &#125; class Professor implements Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1400 + hour * 50) ); &#125; &#125; 从键盘输入两个数，进行相除，显示商。当输入串中含有非数字时或除数为0时，通过异常处理机制，使程序能正确运行。 1234567891011121314151617181920212223242526import java.util.InputMismatchException; import java.util.Scanner; public class yichang &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; Scanner scanner = new Scanner(System.in); System.out.print( \"请输入除数:\" ); int dividedNum = scanner.nextInt(); System.out.print( \"请输入被除数:\" ); int divNum = scanner.nextInt(); System.out.println( \"计算结果：\" + dividedNum / divNum ); &#125; catch (InputMismatchException e1) &#123; // TODO: handle exception System.out.println(\"输入不为数字!\"); &#125;catch (ArithmeticException e2) &#123; // TODO: handle exception System.out.println(\"不能除0!\"); &#125; &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"南京邮电大学java程序设计作业在线编程第八次作业","slug":"南京邮电大学java程序设计作业在线编程第八次作业","date":"2019-06-03T13:20:12.000Z","updated":"2019-06-03T13:20:49.929Z","comments":true,"path":"2019/06/03/南京邮电大学java程序设计作业在线编程第八次作业/","link":"","permalink":"https://nymrli.top/2019/06/03/南京邮电大学java程序设计作业在线编程第八次作业/","excerpt":"","text":"总分：100选择题得分：70 int[][] a=new int[2][3]，则该数组包含（ ）个数组元素。A.2B.3C.6D.不确定正确答案是: C 已知类person是类student的父类，以下数组定义和赋值正确的是( )。A.person p[]=new person[3]; p[1]=new student();B.student s[]=new person[3]; s[1]=new person();C.person p[]= new student[3];p[1]= new person();D.student s[]=new student[3];s[1]=new person;正确答案是: A 下面关于java中类的说法不正确的是( )。A.类体中包含了变量定义和成员方法的定义B.构造函数是类中的特殊方法C.类一定要声明为public的，才可以执行D.一个java文件中可以有多个class定义正确答案是: C 关于接口下列说法正确的( )。A.实现一个接口必须实现接口的所有方法B.接口间不能有继承关系C.一个类只能实现一个接口D.接口和抽象类是同一回事正确答案是: A 以下有关构造方法的说法，正确的是( )。A.一个类的构造方法可以有多个B.构造方法不可以重载C.构造方法可以有返回值D.构造方法可以和类同名，也可以和类名不同正确答案是: A 下列论述中，错误的是（ ）。A.Java源代码的后缀名是.java。B.Java源代码中的每个类经过编译后都会生成一个.class文件。C.在一个名为A.java的文件中只能定义一个类。D.Java源代码中可以定义类和接口。正确答案是: C 下列论述中，正确的是（ ）。A.抽象方法是没有方法体的方法。B.抽象方法一定存在于抽象类中。C.抽象类中一定要包含抽象方法。D.抽象类可以创建对象。正确答案是: A MyClass类定义如下： class MyClass{ public MyClass(int x){ } } 如下方式创建对象，（ ）是正确的A.MyClass myobj=new Myclass;B.MyClass myobj=new Myclass();C.MyClass myobj=new Myclass(1);D.MyClass myobj=new Myclass(1,2);正确答案是: C 关于方法void fjv(int x,int y){}，下面（ ）不能成为它的重载。A.void fjv(int x,float y){}B.void fjv(int x){}C.void fjv(float x,int y){}D.int fjv(int y,int x){}正确答案是: D 下述（ ）说法是不正确的A.实例变量是用static关键字声明的；B.实例变量是类的成员变量；C.方法变量可在方法执行时创建；D.方法变量在使用之前必须初始化；正确答案是: A 如果一个方法被修饰为____方法，则这个方法不能被重写。A.finalB.staticC.voidD.protected正确答案是: A 在Java中，下面说法正确的是（ ）。A.一个子类可以有多个父类，一个父类也可以有多个子类B.一个子类可以有多个父类，但一个父类只可以有一个子类C.一个子类可以有一个父类，但一个父类可以有多个子类D.上述说法都不对正确答案是: C ___变量在内存中只有一个拷贝，被该类的所有对象共享。A.成员B.局部C.全局D.类正确答案是: D MAX_LENGTH是int型public成员变量, 变量值保持为常量100，下面哪句定义语句是正确的。A.public int MAX_LENGTH=100;B.final int MAX_LENGTH=100;C.final public int MAX_LENGTH=100;D.public final int MAX_LENGTH=100;正确答案是: D 1234567891011121314151617181920212223242526272829303132333435363738394041// 编写Main类，生成若干实例并验证程序的功能，请勿改动Main类的定义内容。public class Main&#123; public static void main(String[] args) &#123; Pet pet=new Dog(\"WangCai\"); System.out.println(pet.getName()+\":\"+pet.shout()); pet=new Cat(\"XiaoHua\"); System.out.println(pet.getName()+\":\"+pet.shout()); &#125;&#125;// 请在本行之后添加你的代码内容abstract class Pet&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; abstract String shout();&#125;class Dog extends Pet&#123; Dog(String name) &#123; setName( name ); &#125; @Override String shout() &#123; return \"Wang Wang Wang\"; &#125;&#125;class Cat extends Pet&#123; Cat(String name) &#123; setName( name ); &#125; @Override String shout() &#123; return \"Miao Miao Miao\"; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Windows下命令行神器cmder","slug":"Windows下命令行神奇cmder","date":"2019-06-03T13:17:28.000Z","updated":"2019-06-03T13:17:54.686Z","comments":true,"path":"2019/06/03/Windows下命令行神奇cmder/","link":"","permalink":"https://nymrli.top/2019/06/03/Windows下命令行神奇cmder/","excerpt":"","text":"Cmder安装http://cmder.net/ 有两个版本，分别是mini与full版 mini 没有内建msysgit工具，这是Git for Windows的标准配备； 全安装版 cmder 自带了 msysgit, 压缩包 108M 除了 git 本身这个命令之外, 里面可以使用大量的 linux 命令；比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl 可以交叉使用 cygwin 的部分增强命令 把 cmder 加到环境变量将解压后的文件夹路径加入到系统环境变量的Path中 添加 cmder 到右键菜单配置环境变量后，在管理员权限的终端输入以下语句 Win 8 或者 Win10 可以直接 win+x 再按 a 键进入 或者在开始中输入命令，然后在弹出的最佳匹配中，选择命令行工具右键-&gt;以管理员身份打开 1Cmder.exe /REGISTER ALL 修改命令提示符号1.3 之后版本修改文件 ${CMDER_HOME}\\vendor\\clink.lua 12345if env == nil then lambda = &quot;λ&quot;else lambda = &quot;(&quot;..env..&quot;) λ&quot;end 改成 12345if env == nil then lambda = &quot;$&quot;else lambda = &quot;(&quot;..env..&quot;) $&quot;end 其他符号也行，看你自己的喜好 1.3 以前版本编辑Cmder安装目录下的 vendor\\init.bat 批处理文件 1@prompt $E[1;32;40m$P$S&#123;git&#125;&#123;hg&#125;$S$_$E[1;30;40m &#123;lamb&#125; $S$E[0m 修改为 1@prompt $E[1;32;40m$P$S&#123;git&#125;&#123;hg&#125;$S$_$E[1;30;40m $$ $S$E[0m PowerShell.exe 需要另外设置 打开文件 config/cmder.lua（prompt.lua 也有版本是这个），将第二行中的λ修改为$ 新标签打开个管理员权限终端快捷键 Ctrl + t 后勾选Run as administrator 设置默认终端如果你有其它的command希望通过 Cmder 打开，可以在 Startup 下的 Tasks 中添加。里面已经默认帮你配置了 Cmder、PowerShell、MinTTY、Git Bash。 默认启动的是 Cmder ，如果你想默认启动其它的command，你可以在 Startup 设置为其它的command 同时还可以快速的切换当前使用的终端，假设你正在使用的 cmd ，这时输入 bash 回车一下，便可以将当前标签页的终端切换成 Git Bash 中文和命令ll支持 Cmder 是不支持中文，这需要你在 Startup 下的 Environment 中设置一下。将 set LANG=zh_CN.UTF-8 cmder原生没有 ll 命令，但可以通过设置别名来实现：打开cmder安装目录下的\\config\\user-aliases.cmd文件，添加以下别名设置： Chocolatey软件包管理系统chocolatey 是windows 下面的 yum brew 这种包管理器 运行如下命令(需要管理员权限) 1@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin 安装软件命令 choco install softwareName, 短写是 cinst softwareName 查询安装包是否存在 clist softwareName 可安装包列表 window下常用的开发环境应用123456789101112choco install autohotkey.portable #安装 AutoHotkey (Portable)choco install nodejs.install #安装 nodechoco install git.install #安装 gitchoco install python #安装 pythonchoco install ruby #安装 rubychoco install jdk8 #安装 JDK8choco install googlechrome #安装 Chromechoco install google-chrome-x64 #Google Chrome (64-bit only)choco install firefox #安装 firefoxchoco install notepadplusplus.install #安装 notepad++choco install Atom #安装 Atomchoco install SublimeText3 #安装 SublimeText3","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"安利","slug":"安利","permalink":"https://nymrli.top/tags/安利/"}]},{"title":"微信公众号Pyhton","slug":"微信公众号Pyhton","date":"2019-05-27T14:01:10.000Z","updated":"2019-05-27T14:02:21.379Z","comments":true,"path":"2019/05/27/微信公众号Pyhton/","link":"","permalink":"https://nymrli.top/2019/05/27/微信公众号Pyhton/","excerpt":"","text":"微信公众号Pyhton开发编写上传代码到SAE1.申请SAE（sina application enginer），创建应用，SAE使用文档 2.编写上传代码 weixin.py 12345678910111213141516171819202122232425262728#-*-coding:utf-8-*-import web import os import hashlib import time class WeixinInterface: def __init__(self): self.app_root=os.path.dirname(__file__) self.templates_root=os.path.join(self.app_root,'templates') self.render=web.template.render(self.templates_root) def GET(self): data=web.input() signature=data.signature timestamp=data.timestamp nonce=data.nonce echostr=data.echostr token=\"wxpython\" l=[token,timestamp,nonce] l.sort() sha1=hashlib.sha1() map(sha1.update,l) hashcode=sha1.hexdigest() if hashcode == signature: return echostr index.wsgi 12345678910111213141516171819#-*-coding:utf-8-*-import os import saeimport web from weixin import WeixinInterface urls=(&apos;/weixin&apos;,&apos;WeixinInterface&apos;)app_root=os.path.dirname(__file__)templates_root=os.path.join(app_root,&apos;templates&apos;)render=web.template.render(templates_root)app=web.application(urls,globals()).wsgifunc()application=sae.create_wsgi_app(app) config.yaml 123456789101112name: wxpytest version: 1libraries:- name: webpy version: \"0.36\"- name: lxml version: \"2.3.4\"... ​ 3.微信公众号修改服务器配置 Token与代码中编写的保持一致，URL也要与指定的一致(即...\\weixin)。 注意直接访问&lt;http://vxquan.applinzi.com/weixin&gt;是会报错的，但是可以通过微信公众平台的认证（因为直接访问是没有参数的，data=web.input没有异常处理） 处理普通文本信息12345678&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt; &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt; ▲.注意这边的OpenID不是真正的用户ID，不同公众号对相同用户获得的OpenID是不同的，换言之，这个只是该公众号能获得该用户的一个ID。 12345678910def POST(self): str_xml=web. data() xml=etree.fromstring(str_xml) msgType=xml.find(\"MsgType\").text fromuser=xml.find(\"FromUserName\").text touser=xml.find(\"ToUserName\").text if msgType==\"text\": content=xml. find(\"Content\").text return self.render.reply_text(fromuser,touser,int(time.time()),content) # 注意这边To和from的改变，服务器(发送)--&gt;wx后台--&gt;用户(接收) 记遇到的坑： 1.POST好像必须要有处理，返回信息 python2.7下字符串加u","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"Web","slug":"Web","permalink":"https://nymrli.top/tags/Web/"}]},{"title":"DigitalOcean VPS注册","slug":"DigitalOcean-VPS注册","date":"2019-05-27T13:57:56.000Z","updated":"2019-05-27T13:59:17.948Z","comments":true,"path":"2019/05/27/DigitalOcean-VPS注册/","link":"","permalink":"https://nymrli.top/2019/05/27/DigitalOcean-VPS注册/","excerpt":"","text":"DigitalOcean VPS搭梯子DigitalOcean VPS注册首先通过 邀请链接(https://m.do.co/c/e89da76f57f2)点进去注册，双方都会获得\\$10奖励（注意是注册，我当时就没注意到，少了10\\$ 然后在Github Education申请学生优惠，注意这边的学生优惠邮箱是校园邮箱(xxxx@njupt.edu.cn)那个。我当时是将github账号与校园邮箱进行链接的。 学生优惠申请到后，pack界面会变成这样 进入DO的页面后，用学校邮箱注册后，选用Paypal支付（先注册好Paypal），然后支付即可。 ▲由于一开始我并没有使用学校邮箱注册，而是QQ邮箱，后来又注册了以后，发现这个账号被锁了，付的$5也退了回来。按网上的说法，DO会直接锁了我的账号，原因是一个人注册了多个账号。于是找解决方案。 网上说要发邮件，其中比较关键的是Ticket，一开始一直没找到，后来才发现这个是在support中选出来的. 等了一天最终收到的答复却是： 我们检查了该帐户，发现它符合与违反我们的服务条款和可接受使用策略相关的异常模式。虽然我们无法提供所观察到的特定标志的详细信息，但我们已经确定，恢复对该帐户的访问是不可能的。不便之处，敬请原谅。 最终无奈之下，想起了使用的话跟学校邮箱没关系，那个只是提供优惠券的。于是重新尝试了下第一个注册的账号pay了$5以后就成功了。 创建主机搭建SSR科学上网（利用DigitalOcean服务器） 使用优惠券DigitalOcean 的学生包代金券使用教程 输入Github Education上获得的优惠券Code，就能拿到$50的优惠券了 附录ubuntu一键更换内核 安装锐速 - 16.04 14.04可用PAC和全局模式1.在全局模式下，所有的网站都默认走代理（使你的所有http/socks数据经过代理服务器的转发送出。） 2.在PAC模式是只有被墙了的网站才会走代理（连接网站的时候读取PAC文件里的规则，来确定你访问的网站有没有被墙，如果符合，那就会使用代理服务器连接网站） 优惠网站https://xianhuo.org/2016digitalocean-youhuima.html 未测试","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"PyWinAuto使用","slug":"PyWinAuto使用","date":"2019-05-27T13:54:45.000Z","updated":"2019-05-27T13:55:06.264Z","comments":true,"path":"2019/05/27/PyWinAuto使用/","link":"","permalink":"https://nymrli.top/2019/05/27/PyWinAuto使用/","excerpt":"","text":"PyWinAuto使用简单操作示例： 12app = application.Application().start(r'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe')# app = application.Application().start('notepad.exe') (一) 判断程序的backend注意，首先需要判断你要进行的程序是用什么语言写的，在实例化的时候会有区别，主要是判断backend是什么。 (二)确定自动化入口点这里主要是限制自动化控制进程的范围。如一个程序有多个实例，自动化控制一个实例，而保证其他实例(进程)不受影响。主要有两种对象可以建立这种入口点——Application() , Desktop(). Application的作用范围是一个进程，如一般的桌面应用程序都为此类。 Desktop的作用范围可以跨进程。主要用于像win10的计算器这样包含多个进程的程序。这种目前比较少见。使用方法见entry-points-for-automation (三)连接到进程建立好入口后，我们需要连接到进程中。这里有两种方法: 使用Application对象的start()方法 app = Application().start(r&quot;D:\\Program Files (x86)\\tlxsoft\\屏幕录像专家 共享版 V2017\\屏录专家.exe&quot;) 连接到已有的进程。使用Application对象的connect()方法。这个方法对已有进程的绑定非常灵活。 app = Application().connect(process=19188) 使用窗口句柄绑定 app = Application().connect(handle=0x00230DB6) 使用程序路径绑定★ app = Application().connect(path=r&quot;D:\\Program Files (x86)\\tlxsoft\\屏幕录像专家 共享版 V2017\\屏录专家.exe&quot;) 使用标题、类型等匹配★★（灵活性比较高） app = Application().connect(title_re=&quot;屏幕录像专家.*&quot;, class_name=&quot;TMainForm&quot;) 菜单操作12dlg_spec = app.window(title='屏幕录像专家 V2017')dlg_spec.menu_select(r\"转换工具-&gt;EXE/LXE转成MP4\") 快捷键操作12dlg_spec = app.window(title='屏幕录像专家 V2017')dlg_spec.type_keys('%TP') 1234567891011121314151617181920212223242526272829303132333435SHIFT + CTRL ^ ALT %空格键 &#123;SPACE&#125; BACKSPACE &#123;BACKSPACE&#125;、&#123;BS&#125; or &#123;BKSP&#125; BREAK &#123;BREAK&#125; CAPS LOCK &#123;CAPSLOCK&#125; DEL or DELETE &#123;DELETE&#125; or &#123;DEL&#125; DOWN ARROW &#123;DOWN&#125; END &#123;END&#125; ENTER &#123;ENTER&#125; or ~ ESC &#123;ESC&#125; HELP &#123;HELP&#125; HOME &#123;HOME&#125; INS or INSERT &#123;INSERT&#125; or &#123;INS&#125; LEFT ARROW &#123;LEFT&#125; NUM LOCK &#123;NUMLOCK&#125; PAGE DOWN &#123;PGDN&#125; PAGE UP &#123;PGUP&#125; PRINT SCREEN &#123;PRTSC&#125; RIGHT ARROW &#123;RIGHT&#125; SCROLL LOCK &#123;SCROLLLOCK&#125; TAB &#123;TAB&#125; UP ARROW &#123;UP&#125; + &#123;ADD&#125; - &#123;SUBTRACT&#125; * &#123;MULTIPLY&#125; / &#123;DIVIDE&#125;F1 &#123;F1&#125; F2 &#123;F2&#125; F3 &#123;F3&#125; .....F15 &#123;F15&#125; F16 &#123;F16&#125; 参考pywinauto 使用 python自动化工具之pywinauto","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"Google Colab使用","slug":"Google-Colab使用","date":"2019-05-27T13:53:31.000Z","updated":"2019-05-27T13:53:51.206Z","comments":true,"path":"2019/05/27/Google-Colab使用/","link":"","permalink":"https://nymrli.top/2019/05/27/Google-Colab使用/","excerpt":"","text":"Google Colab使用 Google colab(Colaboratory)在编辑时候和jupyter notebook类似，并且提供免费的GPU以供使用，这对于需要处理大量数据运算的机器项目来说再合适不过了。挺香的 新建一个笔记本（.ipynb）后，选择”修改-&gt;笔记本设置-&gt;硬件加速器-&gt;GPU”就可以想要用英伟达Tesla K80 GPU啦(2599美元一块) colab中文件交互文档里提供了四种方式，分别是： 从本地直接上传 连接Google Drive 连接Google Sheet 连接Google Cloud Storage 与本地文件交互本地文件上传files.upload() 返回一个由我们上传的所有文件构成的一个字典。 这个字典的key是文件名, 这个字典的value是我们上传的文件的data。 123456from google.colab import filesuploaded = files.upload()for fn in uploaded.keys(): print(&apos;User uploaded file &quot;&#123;name&#125;&quot; with length &#123;length&#125; bytes&apos;.format(name=fn, length=len(uploaded[fn]))) 从colab下载文件到本地1234from google.colab import fileswith open(&apos;example.txt&apos;, &apos;w&apos;) as f: f.write(&apos;some content&apos;)files.download(&apos;example.txt&apos;) 连接Google DrivePyDrive这里官方有提供了许多种方法。这里我就挑一种介绍了，有兴趣的可以点进这个Colab官方文档进去看。 这里只介绍使用PyDrive的方法。PyDrive是google-api-python-client的包装库，简化了许多常见的Google Drive API任务。 12345678910111213141516171819202122232425!pip install -U -q PyDrivefrom pydrive.auth import GoogleAuthfrom pydrive.drive import GoogleDrivefrom google.colab import authfrom oauth2client.client import GoogleCredentials# 1. 验证身份并创建pydrive客户端.auth.authenticate_user()gauth = GoogleAuth()gauth.credentials = GoogleCredentials.get_application_default()drive = GoogleDrive(gauth)# PyDrive 参考:# https://gsuitedevs.github.io/PyDrive/docs/build/html/index.html# 2. 创建并上传一个文本文档.uploaded = drive.CreateFile(&#123;'title': 'Sample upload.txt'&#125;)uploaded.SetContentString('Sample upload file content')uploaded.Upload()print('Uploaded file with ID &#123;&#125;'.format(uploaded.get('id')))# 3. 通过id访问文件并输出它的内容.downloaded = drive.CreateFile(&#123;'id': uploaded.get('id')&#125;)print('Downloaded content \"&#123;&#125;\"'.format(downloaded.GetContentString())) Mounting Google Drive locally首先把整个项目工程上传到 Google Drive 中，然后在该项目文件夹下（执行的主函数文件同一目录）新建一个 run.ipynb。新建方法与之前一样，在项目文件夹中 右键-更多-Colaboratory。 然后，在新建的笔记本中挂载 Google Drive： 12from google.colab import drivedrive.mount(&apos;/content/drive/&apos;) 执行以上语句后，会出现一个链接。点击链接，获取并键入 authorization code，回车，等待圈圈转完就能在左侧刷新，看到挂载的Drive 挂载 Drive 网上还有另一种方法，语句很多很复杂，但这个好像没啥区别。。 对于这个服务器而言，整体目录结构是这样的：顶级目录为 content，我们进入笔记本后无论笔记本在哪，当前工作目录都是 /content。/content下默认有 sample_data 目录，其中包括运行示例程序的一些必要数据文件。我们的 Google Drive 作为一个 My Drive 文件夹挂载在 /content/drive 文件夹下。我的项目是“我的云端硬盘”里的一个tiny-yolo文件夹，因此我的项目的路径应该为 /content/drive/My Drive/tiny-yolo。这里大家试一试就明白了，比我说啥都快。 注意事项 为了保证资源的合理分配，google 会按照一定机制将服务器回收：它会一定时间后自动回收已连接但闲置的服务器，和有运行代码但未连接的服务器。所以想挂机跑代码，要保证与服务器保持连接（不掉线），否则一早起来可能就会发现它被悄悄的回收了。稍微掉线个几分钟就连回去是没什么问题的。 在回收服务器后，写到 My Drive 以外其他文件夹下的文件都将被删除，下次再连接就是一台崭新的服务器了。 挂载 Drive 后再向 Google Drive上传文件，同步到 notebook 那边会有一定的延迟，大概等个几秒钟到半分钟不等，多刷新几下就会出现了。删除文件也是。然而在删除 a.py 后，如果没等 notebook 那边反应过来就重新再传一个 a.py，notebook 那边很可能就出现一个被重命名的文件 a(1).py。。难道是我姿势不对？？ 有一次我上传近 3000 张图片作为训练集到 Drive，上传成功，但是 notebook 没读全，!ls “/content/drive/My Drive/tiny-yolo/data” | wc -l 看一眼花式少文件，我也不知道为啥。。总是迷之过会 (hen) 儿 (jiu) 就好了。。搞得我也是很醉。 如何使用google drive的免费GPU进行深度学习 连接Google Sheet连接Google Cloud Storage参考：colab读写外部文件的四种方式","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"图像处理","slug":"图像处理","permalink":"https://nymrli.top/tags/图像处理/"}]},{"title":"Keras使用——图像增强","slug":"Keras使用——图像增强","date":"2019-05-27T13:52:14.000Z","updated":"2019-05-27T13:52:52.924Z","comments":true,"path":"2019/05/27/Keras使用——图像增强/","link":"","permalink":"https://nymrli.top/2019/05/27/Keras使用——图像增强/","excerpt":"","text":"Keras使用——图像增强使用Keras进行深度学习的图像增强（Image Augmentation） Keras是一个高层神经网络API，Keras由纯Python编写而成并基Tensorflow、Theano以及CNTK后端。Keras为支持快速实验而生，能够把你的idea迅速转换为结果，如果你有如下需求，请选择Keras： 简易和快速的原型设计（keras具有高度模块化，极简，和可扩充特性） 支持CNN和RNN，或二者的结合 无缝CPU和GPU切换 ImageDataGeneratorKeras提供了ImageDataGenerator类，定义关于图片准备和增强的配置。包括以下功能：样本级的标准化特征级的标准化ZCA白化.随机旋转、转换、剪切、翻转维度重排.将增强的图片保存在本地. 1234567891011121314151617181920212223from keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_imgimport osDatagen = ImageDataGenerator(rotation_range=20, shear_range=0.2, zoom_range=0.2, horizontal_flip=True, vertical_flip = True, fill_mode='nearest')for file_name in os.listdir('.'): if file_name =='.config' or file_name == 'sample_data': continue img = load_img(file_name) x_img = img_to_array(img) x_img = x_img.reshape((1,)+ x_img.shape) i = 0 for img_batch in Datagen.flow(x_img, batch_size=32, save_to_dir='.', save_prefix='candy', save_format='jpg'): i +=1 if i &gt; 10: break ImageDataGenerator参数详解及用法实例12345678910111213141516171819keras.preprocessing.image.ImageDataGenerator(featurewise_center=False, samplewise_center=False, featurewise_std_normalization=False, samplewise_std_normalization=False, zca_whitening=False, zca_epsilon=1e-6, rotation_range=0., width_shift_range=0., height_shift_range=0., shear_range=0., zoom_range=0., channel_shift_range=0., fill_mode='nearest', cval=0., horizontal_flip=False, vertical_flip=False, rescale=None, preprocessing_function=None, data_format=K.image_data_format()) ▲用以生成一个batch的图像数据，支持实时数据提升。训练时该函数会无限生成数据，直到达到规定的epoch次数为止。 featurewise_center：布尔值，使输入数据集去中心化（均值为0）, 按feature执行 samplewise_center：布尔值，使输入数据的每个样本均值为0 featurewise_std_normalization：布尔值，将输入除以数据集的标准差以完成标准化, 按feature执行 samplewise_std_normalization：布尔值，将输入的每个样本除以其自身的标准差 zca_whitening：布尔值，对输入数据施加ZCA白化 zca_epsilon: ZCA使用的eposilon，默认1e-6 rotation_range：整数，数据提升时图片随机转动的角度 width_shift_range：浮点数，图片宽度的某个比例，数据提升时图片水平偏移的幅度 height_shift_range：浮点数，图片高度的某个比例，数据提升时图片竖直偏移的幅度 shear_range：浮点数，剪切强度（逆时针方向的剪切变换角度） zoom_range：浮点数或形如[lower,upper]的列表，随机缩放的幅度，若为浮点数，则相当于[lower,upper] = [1 - zoom_range, 1+zoom_range] channel_shift_range：浮点数，随机通道偏移的幅度 fill_mode：；‘constant’，‘nearest’，‘reflect’或‘wrap’之一，当进行变换时超出边界的点将根据本参数给定的方法进行处理 cval：浮点数或整数，当fill_mode=constant时，指定要向超出边界的点填充的值 horizontal_flip：布尔值，进行随机水平翻转 vertical_flip：布尔值，进行随机竖直翻转 rescale: 重放缩因子,默认为None. 如果为None或0则不进行放缩,否则会将该数值乘到数据上(在应用其他变换之前) preprocessing_function: 将被应用于每个输入的函数。该函数将在图片缩放和数据提升之后运行。该函数接受一个参数，为一张图片（秩为3的numpy array），并且输出一个具有相同shape的numpy array data_format：字符串，“channel_first”或“channel_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channel_last”对应原本的“tf”，“channel_first”对应原本的“th”。以128x128的RGB图像为例，“channel_first”应将数据组织为（3,128,128），而“channel_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channel_last” 12345678910111213141516171819202122232425262728293031323334353637from keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_imgimport osDatagen = ImageDataGenerator( rotation_range=5,#图片随机翻转的角度 width_shift_range=[0,0.15], height_shift_range=[0,0.2], zoom_range=[0.8,1.5], #随机放大 zca_whitening=True, brightness_range=[0.1, 1.5] , fill_mode='nearest')IMG_PATH = './images'OUT_PATH = './add'# for i in os.listdir(OUT_PATH):# if i.startswith('N'):# os.remove(os.path.join(OUT_PATH,i) )for file_name in os.listdir(IMG_PATH): img = load_img( os.path.join(IMG_PATH,file_name) ) x_img = img_to_array(img) x_img = x_img.reshape( (1,)+ x_img.shape ) i = 0 if( not os.path.exists( os.path.join( OUT_PATH,file_name ) ) ): os.mkdir( os.path.join( OUT_PATH,file_name )) for img_batch in Datagen.flow(x_img, batch_size=2, #batch_size一次增强的图片个数 save_to_dir= os.path.join(OUT_PATH,file_name), save_prefix='N', save_format='jpg'): i +=1 if i == 80: breakprint('done') 参考资料： 参数说明 keras中文手册 https://www.cnblogs.com/hutao722/p/10075150.html https://www.cnblogs.com/hutao722/p/10075150.html flow_from_directory实现从文件夹中提取图片和进行简单归一化处理12345678flow_from_directory(self, directory, target_size=(256, 256), color_mode='rgb', classes=None, class_mode='categorical', batch_size=32, shuffle=True, seed=None, save_to_dir=None, save_prefix='', save_format='jpeg', follow_links=False) 最值得注意的是directory这个参数： directory: path to the target directory. It should contain one subdirectory per class. Any PNG, JPG, BMP, PPM or TIF images inside each of the subdirectories directory tree will be included in the generator. 这是官方文档的定义，它的目录格式一定要注意是包含一个子目录下的所有图片这种格式，driectoty路径只要写到标签路径上面的那个路径即可。 target_size：可是实现对图片的尺寸转换，是预处理中比较常用的方法 save_to_dir: 可以设置保存处理后图片的路径。 save_prefix: 可以对处理后图片设置前缀。 123456789101112131415161718192021222324252627282930313233343536373839import matplotlib.pyplot as pltimport globfrom PIL import Imagefrom keras.preprocessing import image path = 'train/'gen_path = 'result/' def print_result(path): name_list = glob.glob(path) fig = plt.figure() for i in range(9): img = Image.open(name_list[i]) # add_subplot(331) 参数一：子图总行数，参数二：子图总列数，参数三：子图位置 sub_img = fig.add_subplot(331 + i) sub_img.imshow(img) plt.show() return fig # 打印图片列表name_list = glob.glob(path + '*/*')print(name_list)# ['train\\\\00a366d4b4a9bbb6c8a63126697b7656.jpg', 'train\\\\00f34ac0a16ef43e6fd1de49a26081ce.jpg', 'train\\\\0a5f744c5077ad8f8d580081ba599ff5.jpg', 'train\\\\0a70f64352edfef4c82c22015f0e3a20.jpg', 'train\\\\0a783538d5f3aaf017b435ddf14cc5c2.jpg', 'train\\\\0a896d2b3af617df543787b571e439d8.jpg', 'train\\\\0abdda879bb143b19e3c480279541915.jpg', 'train\\\\0ac12f840df2b15d46622e244501a88c.jpg', 'train\\\\0b6c5bc46b7a0e29cddfa45b0b786d09.jpg'] # 打印图片fig = print_result(path + '*/*') # 保存图片fig.savefig(gen_path + '/original_0.png', dpi=200, papertype='a5') # 原图datagen = image.ImageDataGenerator()gen_data = datagen.flow_from_directory(path, batch_size=1, shuffle=False, save_to_dir=gen_path , save_prefix='dog_gen', target_size=(224, 224))for i in range(9): gen_data.next() fig = print_result(gen_path + '/*')fig.savefig(gen_path + '/original_1.png', dpi=200, papertype='a5')","categories":[],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"https://nymrli.top/tags/图像处理/"},{"name":"深度学习","slug":"深度学习","permalink":"https://nymrli.top/tags/深度学习/"}]},{"title":"Python机器学习及实践——从零开始通往Kaggle竞赛之路","slug":"Python机器学习及实践——从零开始通往Kaggle竞赛之路","date":"2019-05-27T13:50:34.000Z","updated":"2019-05-27T13:50:52.094Z","comments":true,"path":"2019/05/27/Python机器学习及实践——从零开始通往Kaggle竞赛之路/","link":"","permalink":"https://nymrli.top/2019/05/27/Python机器学习及实践——从零开始通往Kaggle竞赛之路/","excerpt":"","text":"Python机器学习及实践——从零开始通往Kaggle竞赛之路监督学习模型分类线性模型Logistic逻辑回归函数 ： $g(z)=\\frac {1}{1+_e^{-z}} $ 逻辑回归模型$h_{w,b}(x)=g(f(w,x,b)) = \\frac{1}{1+e^{-z}} = \\frac {1}{1+e^{-(w^{T}x+b)}}$ 处理缺省值的方法：1.缺省值较少时直接删除数据 12data = data.replace(to_replace='? ' ,value = np.nan)data = data.dropna(how='any') 分割数据123from sklearn.cross_validation import train_test_splitX_train , Y_train , X_test , Y_test = train_test_split(data[names[1:10]],data[names[10]],test_size = 0.25,random_state = 33)# 参数说明 ： $1X，$2Y，$3分割规模，$4分割种子 标准化数据 保证每个维度的特征数据方差为1，均值为0，使得预测结果不回被某些维度过大的特征值主导 1234from sklearn.preprocessing import StandardScalers = StandardScaler()X_train = s.fit_transform(X_train)X_test = s.transform(X_test) 混淆矩阵 …. :dart:逻辑回归对参数的计算采用精确解析的方式，时间长性能高；SGD（随机梯度上升）分类估计模型参数，时间短性能低。数据规模在10W量级时考虑对时间的消耗，更推荐使用随机梯度方法对模型参数进行估计。 :memo:说明用例：良恶性肿瘤 支持向量机（​​分类）决定直线位置的并不是所有数据，而是其中 两个空间间隔最小 的 两个不同类别 的数据点，把着中国真正帮助决策最有线性分类模型的数据点叫做“支持向量” 。同时要指出的是，logistic模型考虑了所有数据样本对参数的影响，所以不一定能获得最佳的分类器。 多分类的SVM将其中一类看作是阳性（正）样本，其余的全看成负样本。如有10个类别，则创造10个二分类任务。 :dart:SVM具有精妙的模型假设，可以在高维度的数据中筛选对预测任务有效的少数训练样本，不仅节省模型学习需要的数据内存，还提高了模型的预测性能，但是同时是以CPU资源和计算时间为代价的。 :memo:手写体数据​： 需要知道的是，经典模型没有对结构性信息学习的能力，所以这边对图片的处理其实是将2D图片像素矩阵（scikit-learn数据集里的是8*8）逐行首尾拼接为1D的像素特征向量。 非线性模型朴素贝叶斯 单独考量每一个维度特征被分类的条件概论，进而综合这些概率并对其所在的特征向量做出分类预测。 数学假设：各个维度上的特征被分类的条件概率之间是相互独立的。 :dart:具有较强的特征条件独立假设，使得模型预测所需要估计的参数规模从幂指数量级向线性量级减少，极大​节约了内存消耗和计算时间。但也受限与这种强假设的限制，训练时无法将各个特征之间的联系考量在内，使得该模型再其他数据特征关联性较强的分类任务上的性能表现不佳。 :memo:文本分类：互联网新闻分类、垃圾邮件筛选 K近邻（KNN）设有一个测试样本点，以及已经分好类（带有标签）的训练样本。那么该样本点的类别判定会根据在特征空间中最近的K个已标记样本作为参考。因此模型的性能很大程度上取决于K值的设定，但是K值不属于训练数据后学习的参数，而是模型初始化时需要提前确定的。 :dart:是无参数模型中最简单的一种，由于需要对预先加载在内存的训练样本进行遍历，逐一计算相似度、排序且选择K个最近邻训练样本的标记。所以是O(N2)的算法复杂度，一旦数据量大，可能会花费更多的时间（另一种理解为空间换时间，可探讨） :memo: iris鸢尾花数据集​ : ▲在对数据进行分割时请保证随机取样！由于scikit-learn获得的Iris数据集是根据类别依次排列的，所以如果只采样前25%那么所有采样的样本都是同一个类别，同时由于训练样本是不平衡的(Unbalanced)，这样取得的结果存在偏差，且可信度低。因此随机采样train_test_split(data[names[1:10]],data[names[10]],test_size = 0.25,random_state = 33)设置随机种子是必要的。 决策树 每个节点可以看作是二分类任务，根据不同特征组合搭建多层决策树，在学习时需要考虑特征节点的选择顺序。（度量方式：信息熵、基尼不纯性） 数据处理缺省值：1234X = titannic[['pclass','age','sex']]...# 补充age里的数据，使用平均数或者中位数都是对模型偏离成都造成最小影响的策略X['age'].fillna(X['age'].mean(),inplace = True) 特征值转换类别性特征值转换为数值特征，用0/1代替 12345from sklearn.feature_extraction import DictVectorizervec = DictVectorizer(sparse = False)X_train = vec.fit_transform(X_train.to_dict(orient='record'))print(vec.feature_names)&gt;&gt;&gt; ['age','plcass=1st','pclass=2nd', 'sex=female','sex=male'] :dart:决策树在模型描述上有巨大的优势，推断逻辑非常直观，有清晰的可解释性，也方便模型的可视化。同时这些特性也保证了使用决策树时，无需考虑对数据量化甚至标准化。决策树属于有参数模型，需要花费更多时间在训练数据上面 :memo:泰坦尼克号沉船事故 回归线性回归器:dart:美国波士顿地区房价 KNN支持向量机回归树集成模型无监督学习模型数据聚类K均值（K-means）特征降维主成分分析（PCA）","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"ACM-强连通分量","slug":"ACM-强连通分量","date":"2019-04-25T01:27:03.000Z","updated":"2019-04-25T01:28:12.459Z","comments":true,"path":"2019/04/25/ACM-强连通分量/","link":"","permalink":"https://nymrli.top/2019/04/25/ACM-强连通分量/","excerpt":"","text":"Tarjan 算法&amp;模板 Tarjan 算法一种由Robert Tarjan提出的求解有向图强连通分量的算法，它能做到线性时间的复杂度。 如果两个顶点可以相互通达，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。 1234567891011121314151617181920212223void Tarjan ( int x ) &#123; dfn[ x ] = ++dfs_num ; low[ x ] = dfs_num ; vis [ x ] = true ;//是否在栈中 stack [ ++top ] = x ; for ( int i=head[ x ] ; i!=0 ; i=e[i].next )&#123; int temp = e[ i ].to ; if ( !dfn[ temp ] )&#123; Tarjan ( temp ) ; low[ x ] = gmin ( low[ x ] , low[ temp ] ) ; &#125; else if ( vis[ temp ])low[ x ] = gmin ( low[ x ] , dfn[ temp ] ) ; &#125; if ( dfn[ x ]==low[ x ] ) &#123;//构成强连通分量 vis[ x ] = false ; color[ x ] = ++col_num ;//染色 while ( stack[ top ] != x ) &#123;//清空 color [stack[ top ]] = col_num ; vis [ stack[ top-- ] ] = false ; &#125; top -- ; &#125;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"ACM-并查集","slug":"ACM-并查集","date":"2019-04-25T01:21:30.000Z","updated":"2019-04-26T08:32:10.450Z","comments":true,"path":"2019/04/25/ACM-并查集/","link":"","permalink":"https://nymrli.top/2019/04/25/ACM-并查集/","excerpt":"","text":"并查集 ACM竞赛中，并查集（DisjointSets）这个数据结构经常使用。顾名思义，并查集即表示集合，并且支持快速查找、合并操作。 用于高效的查找某两个元素是否属于同一个集合； 并查集如何表示一个集合？它借助树的思想，将一个集合看成一棵有根树。那又如何表示一棵树？初始状态下，一个元素即一棵树，根即是元素本身。 合并并查集如何支持合并操作？不难发现，按照树的思想，在同一棵树中的所有元素，根都是相同的。也就是说，合并两个不同的集合，只需要将其中一个集合的根设置为另一个集合的根即可，而需要改变根的那个集合，其实只需要改变根节点的父节点即可。 如何支持快速查找操作如果完全按照上面的合并方法进行合并操作，最后生成的树，可能是完全线性的，那么查询的时间复杂度就退化成了O(n)，因为在这种情况下，程序不得不遍历完所有节点才能查询到当前元素所属的根节点。 路径压缩算法优化并查集查询操作。按照集合原来的定义，集合中的元素是满足无序性的，因此可以在查询操作进行的过程中，当程序遍历到根节点然后返回的时候，将所有属于当前根节点的元素的父节点直接设置为当前根节点。如此一来，原来的一条链就变成了一般的树了。当下一次查询的时候，就可以很快的遍历到根节点了，复杂度下降为O(1)。 还有一种优化查询速度的方法，那就是合并两个集合的时候，按秩进行合并，这里的秩代表的以当前元素为根节点的元素个数。很明显，将秩较小的树合并到秩较大的树上更优。 最后，就是具体如何用代码实现并查集？其实，并查集中只涉及到了保存当前元素的父节点这一信息，所以利用一个数组set[i]代表节点i的父节点即可，如果set[i]=i那么代表当前集合的根即为i元素本身。 以一道例题为例，HDOJ：1212，时空转移（点击打开链接）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt; const int NumSets = 1005;typedef int DisjSet[NumSets + 1];typedef int Rank[NumSets + 1];DisjSet S;Rank R; // Initialize the set and rankvoid Initialize()&#123; for(int i=0; i&lt;NumSets; ++i) &#123; S[i] = i; R[i] = 1; &#125;&#125; // Find father of the value, with the function of path compressionint Find(int value)&#123; if(S[value] != value) S[value] = Find(S[value]); return S[value];&#125; // Union the value1 and value2 by the rank of the set which them local invoid SetUnion(int value1, int value2)&#123; int fa1 = Find(value1); int fa2 = Find(value2); if(fa1 == fa2) return ; if(R[fa1] &gt;= R[fa2]) &#123; S[fa2] = fa1; R[fa1] += R[fa2]; &#125; else &#123; S[fa1] = fa2; R[fa2] += R[fa1]; &#125;&#125; int main()&#123;//freopen(\"sample.txt\", \"r\", stdin); int cas; scanf(\"%d\", &amp;cas); while(cas--) &#123; int n, m; Initialize(); scanf(\"%d%d\", &amp;n, &amp;m); for(int i=0; i&lt;m; ++i) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); if(Find(a) != Find(b)) &#123; SetUnion(a, b); --n; &#125; &#125; printf(\"%d\\n\", n); &#125; return 0;&#125;！ 摘自(https://blog.csdn.net/u011787119/article/details/46834903) 例题解密犯罪团伙1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;int f[1001]=&#123;0&#125;,n,m,sum=0;//这里是初始化，非常地重要，数组里面存的是自己数组下标的编号就好了。void init()&#123; int i; for(i=1;i&lt;=n;i++) f[i]=i; return; &#125;//这是找爹的递归函数，不停地去找爹，直到找到祖宗为止，其实就是去找犯罪团伙的最高领导人，//“擒贼先擒王”原则。int getf(int v) &#123; if(f[v]==v) return v; else&#123; //这里是路径压缩，每次在函数返回的时候，顺带把路上遇到的人的“BOSS”改为最后找 //到的祖宗编号，也就是犯罪团伙的最高领导人编号。这样可以提高今后找到犯罪团伙的 //最高领导人（其实就是树的祖先）的速度。 f[v]=getf(f[v]);//这里进行了路径压缩 return f[v]; &#125;&#125;//这里是合并两子集合的函数void merge(int v,int u) &#123; int t1,t2;//t1、t2分别为v和u的大BOSS（首领），每次双方的会谈都必须是各自最高领导人才行 t1=getf(v); t2=getf(u); if( t1!=t2 ) //判断两个结点是否在同一个集合中，即是否为同一个祖先。 f[t2]=t1; //“靠左”原则，左边变成右边的BOSS。即把右边的集合，作为左边集合的子集合。 return;&#125;//请从此处开始阅读程序，从主函数开始阅读程序是一个好习惯。int main()&#123; int i,x,y; scanf(\"%d %d\",&amp;n,&amp;m); init(); //初始化是必须的 for(i=1;i&lt;=m;i++)&#123; //开始合并犯罪团伙 scanf(\"%d %d\",&amp;x,&amp;y); merge(x,y); &#125; //最后扫描有多少个独立的犯罪团伙 for(i=1;i&lt;=n;i++)&#123; if(f[i]==i) sum++; &#125; printf(\"%d\\n\",sum); getchar();getchar(); return 0;&#125; 用并查集判断无向图的连通性(或求连通分支个数)~给定一个无向图和其中的所有边，判断这个图是否所有顶点都是连通的。输入：每组数据的第一行是两个整数n 和m（0&lt; n &lt;=1000）。n 表示图的顶点数目，m 表示图中边的数目。如果n 为0 表示输入结束。随后有m 行数据，每行有两个值x 和y（0&lt;x, y &lt;=n），表示顶点x 和y 相连，顶点的编号从1 开始计算。输入不保证这些边是否重复。输出：对于每组输入数据，如果所有顶点都是连通的，输出 ’YES’ ，否则输出 ’NO’。 123456789101112===样例输入===4 31 22 33 23 21 22 30 0===样例输出===NOYES 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;int map[1005];int n,m;int find(int i)&#123; return map[i]==i?i:find(map[i]);&#125;void init()&#123; for(int i=0;i&lt;n;i++) map[i]=i;&#125;int main()&#123; while(scanf(\"%d%d\",&amp;n,&amp;m)==2) &#123; if(n==0) break; init(); int a,b; for(int i=0;i&lt;m;i++) &#123; scanf(\"%d%d\",&amp;a,&amp;b); a--;b--; map[find(a)]=map[find(b)]; &#125; int cnt=0; for(int i=0;i&lt;n;i++) &#123; if(map[i]==i) cnt++; &#125; if(cnt==1) printf(\"YES\\n\"); else printf(\"NO\\n\"); &#125; return 0;&#125; 例子题目链接：http://poj.org/problem?id=1611题目大意： 中文就不解释了；做法：把同一个集合的所有元素都放到同一个集合里， 当放完之后， 检查一下0号同学在哪个集合， 再判断一下剩下的同学是否和它在同一个集合里面； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// Created by fkjs on 2015-09-17// Copyright (c) 2015 fkjs. All rights reserved.////#pragma comment(linker, \"/STACK:1024000000,1024000000\")#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#define clr(x) memset(x, 0, sizeof(x))using namespace std;const int INF = 0x3f3f3f3f;const int maxm = 505;const int maxn = 30000 + 10;typedef long long int ll;int n, m;int pa[maxn];int find(int x)&#123;//并查集的基础-&gt;find函数， 它的特点就是pa[x] = find(pa[x]), 这一语句可以把该路径上的所有点的父亲都改成根节点； return x == pa[x] ? x : pa[x] = find(pa[x]);&#125;void connect(int x, int y)&#123;//链接两个并查集 int fa = find(x);//找到根节点， 当然找的过程中会更新路上的点； int fb = find(y);//同上； pa[fa] = fb;//链接两个集合；&#125;int main(void) &#123;#ifdef LOCAL //freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\in.txt\", \"r\", stdin); //freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\out.txt\", \"w\", stdout);#endif //ios_base::sync_with_stdio(0); while(scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; (n || m))&#123; for(int i = 0; i &lt; n; i++) pa[i] = i; for(int i = 0; i &lt; m; i++)&#123; int len; scanf(\"%d\", &amp;len); int x; scanf(\"%d\", &amp;x); int tp = x; for(int i = 1; i &lt; len; i++)&#123; scanf(\"%d\", &amp;x); connect(x, tp); tp = x; &#125; &#125; int ans = 0; int p = find(0);//找到最初感染者所在的集合， 它的根是p； for(int i = 0; i &lt; n; i++)//凡是根是p的人都被感染了； if(find(i) == p) ans++; printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"Java课程第二次实验报告","slug":"Java课程第二次实验报告","date":"2019-04-25T00:58:21.000Z","updated":"2019-04-25T01:17:49.431Z","comments":true,"path":"2019/04/25/Java课程第二次实验报告/","link":"","permalink":"https://nymrli.top/2019/04/25/Java课程第二次实验报告/","excerpt":"","text":"Java课程第二次实验报告1.寻找并输出11~999之间的数m，它满足m、m2、m3均为回文数。回文数是各位数字左右对称的整数。判断是否为回文要求通过编写方法来完成。123456789101112131415161718public class HelloWorld &#123; public static boolean isPalindrome(int s) &#123; String str = Integer.toString(s); if( str.charAt(0) == str.charAt(str.length() - 1) ) return true; else return false; &#125; public static void main(String []args) &#123; for (int s = 11; s &lt; 1000; s++) &#123; if (isPalindrome(s) &amp;&amp; isPalindrome(s*s) &amp;&amp; isPalindrome(s*s*s) ) System.out.println(s); &#125; &#125; &#125; 2.由键盘输入10个整数，比较并输出其中的最大值和最小值。12345678910111213141516import java.util.Scanner;public class HelloWorld &#123; public static void main(String []args) &#123; Scanner s = new Scanner(System.in); int []arr = new int[10]; int maxn = -1000000000; int minn = 1000000000; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = s.nextInt(); if ( arr[i] &lt; minn ) minn = arr[i]; if ( arr[i] &gt; maxn) maxn = arr[i]; &#125; System.out.printf(\"最大值:%d ，最小值:%d \\n\",maxn,minn); &#125;&#125; 3.随机产生50个1-100之间的整数，存放于一个10´5的二维数组中，要求按照10´5的格式打印这个数组（即共显示10行，每行5个数，数与数之间间隔一个空格），并求出该数组所有元素之和。1234567891011121314151617181920public class HelloWorld &#123; final static int row = 10; final static int col = 5; static int [][]arr = new int[row][col]; public static void main(String []args) &#123; int sum = 0; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; arr[i][j] = (int)(Math.random()*100 + 1); sum += arr[i][j]; System.out.printf(\"%d \",arr[i][j]); &#125; System.out.println(); &#125; System.out.println(\"SUM:\"+sum+\"\"); &#125;&#125; 4.学生类的创建和使用①创建一个学Student类，成员变量包括：学号、班号、姓名、性别、年龄等，且都是private类型。 ②声明一个构造方法，初始化所有成员变量。 ③分别声明获得各属性的public类型的成员方法，方法名要求以get开头。 ④分别声明修改各属性的public类型的成员方法，方法名要求以set开头。 ⑤声明一个public类型的toString（）方法，把该类中的所有域信息组合成一个字符串。 ⑥声明统计创建Student对象的个数的私有域count和得到Student对象的个数的public方法。 ⑦将类Student放在子包student中。 ⑧在子包student外，创建测试类Student的主类。 在主类中：创建2个Student对象，输出对象的所有域信息；修改对象的姓名和年龄，输出修改后的姓名和年龄；比较两个Student对象的年龄的大小，输出年龄较大的Student对象。 Student.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package student;public class Student &#123; private int uid; private int classNum; private String name; private String gender; private int age; private static int cnt = 0; public Student(int uid , int classNum , String name , String gender , int age) &#123; this.uid = uid; this.classNum =classNum; this.name = name; this.gender = gender; this.age = age; cnt += 1; // TODO Auto-generated constructor stub &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; public int getUid() &#123; return uid; &#125; public void setClassNum(int classNum) &#123; this.classNum = classNum; &#125; public int getClassNum() &#123; return classNum; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getGender() &#123; return gender; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public static int getCnt() &#123; return cnt; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return String.format(\"学号为%d的同学，在%d班，姓名为%s，性别为%s，年龄为%d，\", uid,classNum,name,gender,age); &#125; &#125; HelloWorld.java12345678910111213import student.*;public class HelloWorld &#123; public static void main(String []args) &#123; Student stu1 = new Student(1,1,\"cl\", \"male\", 20); Student stu2 = new Student(3,2,\"cjl\", \"female\", 20); System.out.println(stu1); System.out.println(stu2); stu1.setName(\"cl2\"); stu1.setAge(21); System.out.printf(\"修改之后的姓名:%s,修改后的年龄:%d\\n\",stu1.getName(),stu1.getAge()); System.out.println( stu1.getAge() &gt; stu2.getAge() ?stu1 : stu2); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"ACM-大数定理（高精度）","slug":"ACM-大数定理（高精度）","date":"2019-04-25T00:53:27.000Z","updated":"2019-04-25T01:21:02.601Z","comments":true,"path":"2019/04/25/ACM-大数定理（高精度）/","link":"","permalink":"https://nymrli.top/2019/04/25/ACM-大数定理（高精度）/","excerpt":"","text":"ACM-大数定理（高精度） 由于c/c++中数据类型的范围比较固定，因此有些题目的数据范围正好卡在这些正常范围之外，此时就需要自己实现大数加减乘除的运算。 c/c++需要自己手写 java中有BigInteger类 C++ 加法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;string add(string a , string b)&#123; a = a.substr(a.find_first_not_of(\"0\")); // 去前导0 b = b.substr(b.find_first_not_of(\"0\")); ll lenA = a.length(); ll lenB = b.length(); ll len = max(lenA,lenB) + 10; reverse(a.begin(),a.end()); // 翻转,方便相加 reverse(b.begin(),b.end());// cout &lt;&lt; \"a\" &lt;&lt; a &lt;&lt; endl;// cout &lt;&lt; \"b\" &lt;&lt; b &lt;&lt; endl; string ans(len,'0'); // ans全赋值为0 for(int i =0 ; i &lt; lenA ; i ++) ans[i] = a[i]; int tmp = 0; for(int i = 0 ; i &lt; len;i++)&#123; if ( i &lt; b.length() ) tmp += (ans[i] - '0') + (b[i] - '0'); else tmp += (ans[i] - '0') ; ans[i] = (tmp % 10) + '0'; tmp /= 10; &#125; reverse(ans.begin(),ans.end()); // 再将运算结果反转回来 return ans.substr(ans.find_first_not_of(\"0\")); // 仍然需要去前导0&#125;int main()&#123; string a = \"3\"; string b = \"2\"; cout &lt;&lt; add(a,b) &lt;&lt;endl; return 0 ;&#125; Java 加减乘除1234567891011121314151617public class HelloWorld &#123; public static void main(String []args) &#123; BigInteger a = new BigInteger(\"100\"); BigInteger b = new BigInteger(\"2\"); System.out.println(a.add(b)); // 102 System.out.println(a.subtract(b)); // 98 System.out.println(a.multiply(b)); // 200 System.out.println(a.divide(b)); // 50 BigInteger []c = a.divideAndRemainder(b); System.out.printf(\"除数为:%d,余数为:%d\\n\", c[0],c[1] ); // 除数为:50,余数为:0 &#125;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"}]},{"title":"使用git将项目上传到github（最简单方法）","slug":"使用git将项目上传到github（最简单方法）","date":"2019-03-28T11:39:36.000Z","updated":"2019-03-28T11:45:09.997Z","comments":true,"path":"2019/03/28/使用git将项目上传到github（最简单方法）/","link":"","permalink":"https://nymrli.top/2019/03/28/使用git将项目上传到github（最简单方法）/","excerpt":"","text":"使用git将项目上传到github（最简单方法）首先你需要一个github账号，所有还没有的话先去注册吧！ Github 我们使用git需要先安装git工具，这里给出下载地址，下载后一路直接安装即可：**https://git-for-windows.github.io/** 1.进入Github首页，点击New repository新建一个项目 2.填写相应信息后点击create即可 Repository name: 仓库名称 Description(可选): 仓库描述介绍 Public, Private : 仓库权限（公开共享，私有或指定合作者） Initialize this repository with a README: 添加一个README.md gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore license: 证书类型，对应生成文件LICENSE 创建完成后会变成（添加了README.md或者有license) 3.点击Clone or dowload会出现一个地址，copy这个地址备用。 4.接下来就到本地操作了首先右键你的项目，如果你之前安装git成功的话，右键会出现两个新选项，分别为Git Gui Here,Git Bash Here,这里我们选择Git Bash Here，进入如下界面，Test_Bluetooth即为我的项目名。 5.接下来输入如下代码（关键步骤），把github上面的仓库克隆到本地git clone https://github.com/CKTim/BlueTooth.git（https://github.com/CKTim/BlueTooth.git替换成你之前复制的地址） 6.复制文件到刚出来的文件夹中这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名，如图我多出了个Test文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹不用），其余都复制到那个新多出的文件夹下， 7.接着继续输入命令 cd Test，进入Test文件夹 8.接下来依次输入以下代码即可完成其他剩余操作：123git add . （注：别忘记后面的.，此操作是把Test文件夹下面的文件都添加进来）git commit -m \"提交信息\" （注：“提交信息”里面换成你需要，如“first commit”）git push -u origin master （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码）","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"学会Pull request","slug":"学会Pull-request","date":"2019-03-28T11:18:14.000Z","updated":"2019-03-29T06:01:17.589Z","comments":true,"path":"2019/03/28/学会Pull-request/","link":"","permalink":"https://nymrli.top/2019/03/28/学会Pull-request/","excerpt":"","text":"GitHub中发起PR(pull Request) PR是为了贡献代码: ​ 贡献代码，通俗的说，就是自己修改了代码，希望合并到别人的Repository(仓库)中。将自己的智慧贡献给开源社区。 一.贡献代码:1.第一步:Fork在GitHub社区闲逛时，看中了某个项目代码，如：spring-projects/spring-framework，点击页面Fork按钮，会生成一个自己的Repository(仓库：thinkingfioa/spring-framework),如下图： 2.第二步：修改Fork成功后，通过git clone、修改、commit、push等操作后，将修改的内容，提交到自己仓库(thinkingfioa/spring-framework)中。如果对git clone、commit和push不知道的，自行百度。如下图: 3 第三步：请求合并代码(Pull Request)在2步骤时，我们修改了自己的仓库(thinkingfioa/spring-framework)代码。我们希望贡献自己的一份力量，将修改的Commit也提交到别人的仓库(spring-projects/spring-framework)中。则要进行Pull Request。 3.1 创建PR 3.2 Create pull request请特别注意下图中标红的部分，不能搞反了。点击: Create pull request 绿色按钮，完成提交PR。 3.3 等待提交PR完成后，等待对方仓库(spring-projects/spring-framework)的管理员审核，如果他同意，则贡献代码完成了。 二.同步最新代码 PR除了贡献代码外，还可以同步对方最新代码。通俗的说，fork某个仓库(如: spring-projects/spring-framework)代码一段时间后，为了同步自己仓库(thinkingfioa/spring-framework)和对方仓库(spring-projects/spring-framework)代码，保证自己仓库代码是最新版本。 2.1.1 Create pull request这一步和上面3.2一样的，只是要注意箭头，哪个仓库合并哪个仓库。请自习注意下图标红部分 2.1.2 点击绿色按钮，完成代码同步 摘自:https://blog.csdn.net/thinking_fioa/article/details/79516352?tdsourcetag=s_pctim_aiomsg GitHub之接收、处理Pull Request1.创建一个仓库来演示下。 假设创建仓库的人称为:”老大” 2.成员Fork后修改 成员x695 在自己的网页上fork这个仓库，然后git clone到本地，然后创建特性分支，基于特性分支修改完成提交，push到origin 远程仓库git push origin (master(本地):master(远程) ) 3.成员发PR到老大 4.老大登陆自己的账号，到PR页签 5.老大在本地的检查为了防止这个成员乱改，如果不检查可以直接进行步骤6老大还要检查下假如还要用于演示的话，老大就要把代码拉到本地了，看看修改后有啥区别 git clone 自己创建的项目 git remote add stream 项目成员的仓库/获取项目成员仓库设置为本地仓库的远程仓库git fetch 获取项目成员的仓库数据 将成员的仓库和分支数据全部拉到自己本地后，创建一个用户检查的分支 pr1，并进入这个分支将项目成员的number1 分支和自己的分支pr1进行合并 git merge stream/number1 这样一来分支pr1就和项目成员的分支number1一样了，检查完毕，进行删除 git branch -D pr1 6.老大合并或评论PR 点击 add number1 可以回复评论，然后也可以直接点击 merge pull request 通过 老大如果不愿意登陆网页，也可以在本地进行如下操作 在步骤5中已经完成了，前2步的前提下进行下一步 git checkout master,切换到主分支 git merge stream/number1 将成员的分支合并到主分支 push前进行检查，git diff oragin/master 看看本地合并后的仓库和远端的有啥区别 如果确认无误直接进行git push 就可以了 完成上面的5步之后，仓库的Pull Request 会自动成Open状态变成Close 状态。 摘自:https://blog.csdn.net/x6_9x/article/details/50902777 Github官方文档About pull requests Merging a pull request Closing a pull request Checking out pull requests locally","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"蓝桥杯突击训练","slug":"蓝桥杯突击训练","date":"2019-03-28T02:35:12.000Z","updated":"2019-04-26T12:18:04.491Z","comments":true,"path":"2019/03/28/蓝桥杯突击训练/","link":"","permalink":"https://nymrli.top/2019/03/28/蓝桥杯突击训练/","excerpt":"","text":"ACM 3-20笔记3部排序 左指针，右指针， 探路指针–&gt;链表的pq 马虎的算式 枚举（五重循环，注意条件） 内存1000ms大约运行10^8的指令 大数除法 减法 除法 39级阶梯 斐波那契 简化模型后再加上考虑条件 错误票据 获得一行内容：getline()前要用getchar()吃掉换行符 分割一行以空格分隔的元素 12345string s;getline(cin,s);stringstream ss(s);string(tmp);while( getline(ss,tmp,\" \") ) ▲翻硬币 ACM 3-21笔记 （2014年）奇怪的分式 gcd辗转相除法 枚举 蚂蚁感冒 日本白书的蚂蚁模型：穿过身体 ▲地宫取宝 深搜 递归 取模 面对&amp;$4^{100}$优化思考方向： 贪心 ： 知道有一条最好的路 —X—&gt; 这题要求每种情况都遍历 重复子问题 ： 记忆化搜索 dfs(int x, int y , int max,int cnt)，虽然x,y都是不同的，但max,cnt可能会有相同的值，这些情况是重复的 动态规划 （递推方式）： ACM 3-22笔记 (2015)T5-全排列 DFS框架 递归 回溯 T7-牌型种数 排列组合 一般都是用递归解决 回溯（恢复初始状态）：袋子理论 –&gt; 每次都得把自己的袋子清空再返回 两种思路： 13次选牌($O(13^{13})$) 每张牌选几次（更简单$O(5^{13})$) T9-垒骰子 递归 分治法 逐步生成 ACM 3-23 (2016) 凑数字 多个不同的数字—-&gt;全排列问题 附录：通用的代码工具void i2s(string &amp;s, int &amp;num)12345void i2s(string &amp;s, int &amp;num)&#123; stringstream ss; ss &lt;&lt; num; ss &gt; s;&#125; string去前置0123void removePre0(string &amp;s)&#123; s = s.substr(s.find_first_not_of(\"0\"))&#125; string回溯去最后一个元素123path += pai[i];f(k-1,path);path.erase(path.end()-1) 求最大公因数(辗转相除法)：123456int gcd(int a,int b)&#123; if( a%b == 0) return b; //极端情况最大的公约数为两个中最小的一个 return gcd(b,a%b); // 被除数为其中小的那个&#125; 漫画图解 全排列next_premutation12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; while(scanf(\"%d\",&amp;n)&amp;&amp;n)&#123; int a[1000]; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; sort(a,a+n);//可以自行测试一下删除后的结果 do&#123; for(int i=0;i&lt;n;i++) printf(\"%d \",a[i]); printf(\"\\n\"); &#125;while(next_permutation(a,a+n)); &#125; return 0;&#125; 如果有sort()，输出为 0 1 20 2 11 0 21 2 02 0 12 1 0 若无，则输出为 1 0 21 2 02 0 12 1 0 可以发现少了许多种组合方法。 不过，仔细比较各种组合方法和有无sort()的输出，可以发现函数next_permutation()是按照字典序产生排列的，并且是从数组中当前的字典序开始依次增大直至到最大字典序。 △.sort()默认排序从小到大 DFS+回溯法123456789101112131415161718192021222324252627282930#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100+5;#define NUM 5int arr[] = &#123;1,2,3,4,5&#125;;void f(int k)&#123; if( k == NUM)&#123; for(int i = 0 ; i&lt; NUM; i++) cout &lt;&lt; arr[i]; cout &lt;&lt;endl; return ; &#125; for(int i=k ; i &lt;NUM ; i++)&#123; &#123; int t = arr[i]; arr[i] = arr[k]; arr[k] = t; &#125; f(k+1); // 回溯复原 &#123; int t = arr[i]; arr[i] = arr[k]; arr[k] = t; &#125; &#125;&#125; C++输入输出流设置1234567#include &lt;bits/stdc++.h&gt; //万能头文件using namespace std; //命名空间int main() &#123; ios::sync_with_stdio(false); //取消输入输出流等待同步 ... if (i != n) cout &lt;&lt; endl; //每个输出样例间有换行,(可理解每个CASE后加个换行,最后一行没有)&#125; C语言里的输入输出问题 1234int d,float f,char str[20],scanf(\"%d%f%s\",d,f,str); scanf:使用 scanf 输入 42 scanf()中使用%c说明符，该函数将只读取字符4 并将其存储在一个char类型的变量中 如果使用%s说明符，该函数会读取两个字符，即字符4和字符2，并将它们存储在一个字符串中。 如果使用%d说明符，则scanf 读取同样的两个字符，但是随后它会继续计算与它们的相应的整数值为4*10+2 得到 42；然后将该整数的二进制表示保存在一个int变量中， 如果使用%f说明符 则scanf（）读取这两个字符 计算它们对应的数值 42，然后以内部的浮点表述该值，并将结果保存在一个float变量中 123456789101112/**0234500067103456050020456006710000000089通过控制读入的位数,读入矩阵*/for(c=1;c&lt;=m;c++)&#123; //循环变量稍微有点奇怪 for(d=1;d&lt;=n;d++) scanf(\"%1d\",&amp;mapp[c][d]); &#125; getchar():getchar()只能输入字符型,输入时遇到回车键才从缓冲区依次提取字符. 说明：当程序调用getchar()函数时，程序就等着用户按键，用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止（回车字符也放在缓冲区中）。当用户键入回车之后，getchar()函数才开始从键盘缓冲区中每次读入一个字符。也就是说，后续的getchar()函数调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才重新等待用户按键。 分割输入123456789101112131415161718192021222324252627282930313233/* 迷宫题目010010001000000101110000*/for(int i=1 ; i &lt;= row ; i++)&#123; for(int j= 1; j &lt;= col ; j++) scanf(\"%c\",&amp;maze[i][j]); getchar();&#125;// ---错误票据--int n ;cin &gt;&gt; n ;getchar();vector&lt;int&gt; v;while(n--)&#123; string s; getline(cin,s); stringstream ss(s); string tmp; while( getline(ss,tmp,' ') )&#123; v.push_back( s2i(tmp) ); &#125;&#125;// ****C++输入流不同步设置****int main()&#123; ios::sync_with_stdio(false); ...&#125; 循环移位运算12345678910111213141516171819202122232425262728/*** 递推得到幂运算* @param base基底，n幂次*/int selfpow(int base,int n)&#123; int res = 1; while( n-- )&#123; res *= base; &#125; return res;&#125;/*** 自己实现x位二进制循环左移* e.g. 8=1000 ， 左移=&gt; 0001* @param n为len位中只有一位为1的十进制数*/int ROL(int n,int len,int dir = 1)&#123; if ( dir == 1) &#123; n &lt;&lt;= 1; if ( n % selfpow(2,len) == 0 ) n = 1; &#125;else&#123; n &gt;&gt;= 1; if( n == 0 ) n = selfpow(2,len-1); &#125; return n;&#125; 宏定义循环123456789101112#define rep(i,n) for (int i = 0; i &lt; (n); ++i)#define Forneq(i,s,n) for (int i = (s); i &lt; (n); ++i)#define Foreq(i,s,n) for (int i = (s); i &lt;= (n); ++i)int main()&#123; rep(i,3)&#123; cout &lt;&lt; 1 &lt;&lt; endl; &#125; For(i,1,2)&#123; cout &lt;&lt; 2 &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"C++机器学习库MLPack","slug":"C++机器学习库MLPack","date":"2019-03-25T09:44:11.000Z","updated":"2019-05-30T03:21:42.018Z","comments":true,"path":"2019/03/25/C++机器学习库MLPack/","link":"","permalink":"https://nymrli.top/2019/03/25/C++机器学习库MLPack/","excerpt":"","text":"C++机器学习库MLPack mlpack: a scalable C++ machine learning library 由于在网上查了一下发现安装这个库碰到了不少问题，所以还是记录一下安装过程。 安装 列出两种安装教程吧，第一种实测可以。第二种在测试Armadillo的时候没通过，还是缺库，有兴趣的人可以通过给的Armadillo官网链接下载安装Armadillo再试试 安装方法一：Mlpack 官网 提供了下载的方法 ： sudo apt-get install libmlpack-dev ， 但貌似有博客指出目前国内源里是没有这个镜像的，所以采取的办法是直接从观望上下载mlpack-3.0.0.tar.gz（没敢使用最新的，怕出错） 来编译安装 12345678$ tar -xvf mlpack-3.0.0.tar.gz $ cd mlpack-1.0.12 $ mkdir build $ sudo apt-get install libboost-math-dev libboost-program-options-dev libboost-random-dev libboost-test-dev libxml2-dev libarmadillo-dev $ cd build $ cmake ..$ make -j4$ sudo make install 注意根据报错信息：Maybe need administrative privileges.，所以 make install 前面要加上sudo权限 1234567[ 51%] Built target mlpack_sparse_coding[100%] Built target mlpack_testInstall the project...-- Install configuration: \"\"CMake Error at cmake_install.cmake:36 (file): file cannot create directory: /usr/local/lib/pkgconfig. Maybe need administrative privileges. 然后就是可选的编译条件，就是你只想安装其中一些包，也是可以的： $ make pca allknn allkfn ,只安装pca allknn allkfn这几个算法包。 摘自：http://www.linuxdiyf.com/linux/27052.html 安装方式二：（不推荐）安装依赖库1234Armadillo &gt;= 6.500.0Boost (program_options, math_c99, unit_test_framework, serialization, spirit)CMake &gt;= 2.8.5 Aramdillo 安装 （Ubuntu为例子） 首先安装Armadillo依赖的库：lapack, blas, boost 123$ sudo apt-get install liblapack-dev$ sudo apt-get install libblas-dev$ sudo apt-get install libboost-dev 接下来 安装Armadillo：sudo apt-get libarmadillo-dev 之后，安装完成，测试是否完成！以上步骤，都是应该可以直接完成的，需要Cmake和g++提前安装。 g++ test.cpp -o test -larmadillo 1234567891011#include &lt;iostream&gt;#include &lt;armadillo&gt;using namespace std;using namespace arma;//test.cppint main(int argc,char** argv) &#123; mat A=randu&lt;mat&gt;(4,5); mat B=randu&lt;mat&gt;(4,5); cout&lt;&lt;A*trans(B)&lt;&lt;endl; return 0;&#125; 网上还有说Armadillo也无法找不到镜像， 于是还是到官网下载下来编译安装，[Armadillo C++ matrix library]( Boost库的安装apt-get install libboost-math-dev libboost-program-options-dev libboost-random-dev libboost-test-dev libxml2-dev mlpack安装也是去官网下载编译安装 12345678910$ tar -xzf mlpack-2.0.1.tar.gz # tar解压$ cd mlpack-2.0.1 # 进入解压后的目录$ unzip mlpack-2.0.1.zip # zip解压$ cd mlpack-2.0.1 # 进入解压后的目录# 之后，建立build目录，cmake，make即可$ mkdir build$ cd build$ cmake ../$ make $ sudo make install 使用mlpack源文件中有各种算法的例子，可以学习其使用方法，这里需要注意一点，在编译和链接时，都要加上-lmlpack -larmadillo，来包含所需库。 如编写下列代码: 123456#include &lt;mlpack/core.hpp&gt;using namespace std;int main()&#123; cout &lt;&lt; mlpack::util::GetVersion() &lt;&lt; endl; return 0;&#125; ▲.注意.编译的命令为g++ -std=c++11 testmlpack.cpp -o testlars -l mlpack -l armadillo，其中要加上-std=c++11，不然无法编译通过。 [Armadillo C++ ML library]http://arma.sourceforge.net/download.html) 如果Armadillo出错，可以去官网[Armadillo C++ ML library]http://arma.sourceforge.net/download.html)下载编译安装","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"南京邮电大学java程序设计作业在线编程第六次作业","slug":"南京邮电大学java程序设计作业在线编程第六次作业","date":"2019-03-17T05:29:36.000Z","updated":"2019-03-17T08:45:46.178Z","comments":true,"path":"2019/03/17/南京邮电大学java程序设计作业在线编程第六次作业/","link":"","permalink":"https://nymrli.top/2019/03/17/南京邮电大学java程序设计作业在线编程第六次作业/","excerpt":"","text":"总分：100选择题得分：40 1.下列方法定义中，正确的是（） A.double me（int a，int b）{int r; r = ab} B.double me（a，b）{return b;} C.int me（int a，int b）{return（a-b）;} D.int me（inta，b）{return（a-b）;} 正确答案是：C 2.下列方法定义中，不正确的是（） A.float x（int a，int b）{return（ab）;} B.int x（int a，int b）{return ab;} C.int x（int a，int b）{return a * b;} D.int x（int a，int b）{return 1.2 *（a + b）;} 正确答案是：D 3.下面哪个数据类型占用的内存最大？（） A.int B.float C.double D.byte 正确答案是：C 4.下面哪个不属于Java的关键字？（） A.static B.final C.super D.sub 正确答案是：D 5.下面的标识符中哪个是合法的标识符？（） A.–a B.Test C.class D.＃ABC 正确答案是：B 6.下列语句序列执行后，c的值是（）int a = 3，b = 4，c = 0; （（a ++）&lt;（ - b））++ c; A.0 B.1 C.2 D.3 正确答案是：A 7.下面关于数组定义语句不正确的是（） A.float f [] = new {2.4f，3.5f，5.7f，7.9f}; B.int a [] = {1,2,3,4,5} C.double [] d = new double [10]; D.int [] a2; 正确答案是：A 8.下面（）是Java数据类型中的int类型的取值范围。 A.$-2^ 7 $〜$2^ 7 -1$ B.0 〜 $2 ^ {16} -1$ C.$-2 ^ {15} $^ 〜 $2 ^{ 15} -1$ D.$-2 ^ {31}​$ 〜$2 ^ {31} -1​$ 正确答案是：D 9.在Java语言中，下面（）类型可以表示整数基本数据类型。 A.single B.byte C.double D.char 正确答案是：B 10.假设int a = -3; 则表达式a&gt; 0？a：-a的结果是（） A.true B.false C.-3 D.3 正确答案是：D 编程题得分：60输出所有的3位数字的质数得分：10/1012345678910111213141516171819202122232425262728293031323334353637383940import java.io.IOException;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args) throws IOException&#123; int size = 1000; int prime[] = new int[1000]; int pos=0; boolean flag; for (int i = 100; i &lt; size; i++) &#123; flag = false; for(int j=2; j &lt;= Math.sqrt(i) ; j++) &#123; if (i%j == 0)&#123; flag = true; break; &#125; &#125; if ( !flag ) prime[pos++] = i; &#125; int pf=0; for (int i = 0; i &lt; prime.length; i++) &#123; if (prime[i] != 0) &#123; System.out.printf(\"%6d\",prime[i]); pf ++; if (pf == 5) &#123; pf = 0; System.out.println(); &#125; &#125; &#125; &#125;&#125; 数列求和得分：10/1012345678910111213141516171819202122232425262728293031323334353637import java.io.IOException;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args) throws IOException&#123; Scanner s = new Scanner(System.in); double x = s.nextDouble(); int cnt = 1; double sum = 0; double single ; do &#123; single = Math.pow(x, cnt)/fac(cnt); sum += Math.pow(-1, (cnt+1) % 2)*single; cnt ++; &#125; while ( Math.abs(single) &gt; 1e-4 ); System.out.printf(\"%.2f\\n\",sum); &#125; /** * @Target: 递归求阶乘 * @param a * @return a! */ public static int fac (int a) &#123; if (a == 0 || a == 1) return 1; return a*fac(a-1); &#125; &#125; 最大公约数得分：10/1012345678910111213141516171819202122import java.io.IOException;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args) throws IOException&#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); int b = s.nextInt(); System.out.printf(\"%d\",gcd(a,b)); &#125; public static int gcd(int a,int b) &#123; if ( b==0 ) return a; return gcd(b,a%b); &#125;&#125; 输出斐波那契数列的前10得分：10/101234567891011121314151617181920212223import java.io.IOException;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args) throws IOException&#123; int arr[] = new int[20]; int len = 10; arr[0] = 1; arr[1] = 1; for (int i = 2; i &lt;len; i++) arr[i] = arr[i-2] + arr[i-1]; for (int i = 0; i &lt;len; i++) &#123; System.out.printf(\"%d\",arr[i]); if( i != len - 1) System.out.print(\" \"); else System.out.println(); &#125; &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"南京邮电大学java程序设计作业在线编程第五次作业","slug":"南京邮电大学java程序设计作业在线编程第五次作业","date":"2019-03-17T03:44:36.000Z","updated":"2019-03-17T05:32:17.020Z","comments":true,"path":"2019/03/17/南京邮电大学java程序设计作业在线编程第五次作业/","link":"","permalink":"https://nymrli.top/2019/03/17/南京邮电大学java程序设计作业在线编程第五次作业/","excerpt":"","text":"总分：100选择题得分：50 以下哪一个工具是Java的编译器？( ) A.javac.exe B.java.exe C.javap.exe D.javadoc.exe 正确答案是: A 以下哪一个数据类型不属于Java的基本数据类型？( ) A.boolean B.char C.int D.String 正确答案是: D 假设有如下类的定义： public class test{ public static void main(String[] args){ int a= 3, b = 4; swap(a,b); System.out.println(“a=”+a + “ b=” + b); } public static void swap(int a,int b){ int tmp = a; a = b; b = tmp; } } 程序运行后结果为( ) A.a=4 b=3 B.a=3 b=4 C.a=a b=b D.无结果输出 正确答案是: B 执行如下代码后，b的值是( ) int a=0, b=0; do{ –b; a = a-1; }while(a&gt;0); A.0 B.1 C.-1 D.死循环 正确答案是: C 下列关于Java中的数组的说法，错误的是( )。 A.数组中的元素的类型必须相同 B.数组中的元素是有顺序的 C.数组对象，属于引用类型 D.数组的大小可以任意改变 正确答案是: D 在循环体中，如果想结束本次循环，可以使用哪个语句？（ ）。 A.break B.continue C.final D.finally 正确答案是: B 下列标识符中，哪一个是非法标识符？（ ） A.statics B.static_10 C.10static D.$statics10 正确答案是: C 设有数组的定义int[] a = new int[3]，则下面对数组元素的引用错误的是（ ）。 A.a[0] B.a[a.length-1] C.int i=0;a[i] D.a[a.length]-1 正确答案是: D int a=new int[2][3]，则该数组包含（ ）个数组元素。 A.2 B.3 C.6 D.不确定 正确答案是: C 下面的代码段执行之后count的值是什么（ ） int count = 1; for (int i = 1; i &lt;= 5; i++) { count += i; } System.out.println(count); A.5 B.1 C.15 D.16 正确答案是: D 编程题得分：50数字加密 得分：10 / 101234567891011121314151617181920212223import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123;public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int n = s.nextInt(); int arr[] = new int[4]; int cnt = 3; while(n!=0) &#123; arr[cnt--] = (n%10 + 9)%10; n /= 10; &#125; System.out.printf(\"The encrypted number is %d%d%d%d\\n\",arr[2],arr[3],arr[0],arr[1]); &#125; &#125; 数列排序 得分：10 / 10123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int arr[] = new int[20]; int len = arr.length; for(int i=0; i &lt; len; i++) arr[i] = s.nextInt(); bubble(arr); for(int i=0; i &lt; len; i++) &#123; System.out.printf(\"%4d\",arr[i]); if ( i == len-1) System.out.println(); //else System.out.print(\" \"); &#125; &#125; /** * @Target: 冒泡排序 * @param arr待排数组 */ public static void bubble(int arr[]) &#123; int start = 5; // 第6个元素的下标是5 int len = 14; // 第15个元素的下标是14 int tmp ; // 交换的临时变量 for (int i = start; i &lt; len; i++) &#123; for (int j = start; j &lt; len-(i-start); j++) &#123; // 类比从0 开始的冒泡,这边需要改成len-(i-start),因为j的范围只能是(start,len) if ( arr[j] &lt; arr[j+1]) &#123; tmp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = tmp; &#125; &#125; &#125; &#125; &#125; 打印杨辉三角形 得分：10 / 1012345678910111213141516171819202122232425262728293031import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int hang = s.nextInt(); int arr[][] = new int[hang][hang]; arr[0][0] = 1; for (int i = 1; i &lt; hang ; i++) &#123; arr[i][0] = 1; arr[i][i] = 1; for (int j = 1; j &lt; hang; j++) &#123; arr[i][j] = arr[i-1][j] + arr[i-1][j-1]; &#125; &#125; for (int i = 0; i &lt; hang ; i++) &#123; for (int j = 0; j &lt; hang; j++) &#123; if (arr[i][j] != 0 ) System.out.printf(\"%5d\",arr[i][j]); &#125; System.out.println(); &#125; &#125;&#125; 构造指定的数列 得分：10 / 1012345678910111213141516171819202122232425import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); int b = s.nextInt(); int cnt = 0 ; int arr[] = new int[1000]; for (int i = a; i &lt;= b; i++) &#123; if ( i % 7 == 0 || i % 11 == 0) &#123; if ( !(i % 7 == 0 &amp;&amp; i % 11 == 0) ) arr[cnt++] = i; &#125; &#125; for(int x : arr) if ( x!= 0) System.out.printf(\"%d \",x); &#125;&#125; 求平均值 得分：10 / 10123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.IOException;import java.util.Arrays;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int num = s.nextInt(); int sum = 0; //去除最大最小值的总和 int cnt = 0; //要去掉的个数 int arr[] = new int[num]; for (int i = 0; i &lt; num; i++) arr[i]= s.nextInt(); Arrays.sort(arr); // 排序,默认从大到小 System.out.printf(\"max element:%d\\n\", arr[num-1]); // 第一个是最大的 System.out.printf(\"min element:%d\\n\", arr[0]); // 最后一个是最小的 // 去掉最大和最小项 for (int i = 1; i &lt; num-1; i++) &#123; if ( arr[i] == arr[0] || arr[i] == arr[num-1] ) &#123; arr[i] = 0 ; cnt ++ ; &#125; &#125; // 是否全是最小最大值 boolean flag = false; for (int i = 1; i &lt; num-1; i++) &#123; if (arr[i] != 0) &#123; flag = true; sum += arr[i]; &#125; &#125; if (flag == true) System.out.printf(\"average is %5.2f\\n\", (double)sum/(num-(cnt+2))); else System.out.printf(\"no solution\\n\"); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Linux命令手册","slug":"Linux命令手册","date":"2019-03-15T14:33:26.000Z","updated":"2019-03-26T08:17:47.169Z","comments":true,"path":"2019/03/15/Linux命令手册/","link":"","permalink":"https://nymrli.top/2019/03/15/Linux命令手册/","excerpt":"","text":"scp1、从服务器上下载文件 1scp username@servername:/path/filename /var/www/local_dir（本地目录） 例如scp root@192.168.0.101:/var/www/test.txt 把192.168.0.101上的/var/www/test.txt 的文件下载到/var/www/local_dir（本地目录） 2、上传本地文件到服务器 1scp /path/filename username@servername:/path 例如scp /var/www/test.php root@192.168.0.101:/var/www/ 把本机/var/www/目录下的test.php文件上传到192.168.0.101这台服务器上的/var/www/目录中 3、从服务器下载整个目录 1scp -r username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录） 例如:scp -r root@192.168.0.101:/var/www/test /var/www/ 4、上传目录到服务器 1scp -r local_dir username@servername:remote_dir例如：scp -r test root@192.168.0.101:/var/www/ 把当前目录下的test目录上传到服务器的/var/www/ 目录 12345678910111213141516$ ssh root@47.98.233.15@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:8hgJ8jpcBr1tm6HS72FpXwMrjba8MQqlqYJQLPB/Qf4.Please contact your system administrator.Add correct host key in /Users/wangdong/.ssh/known_hosts to get rid of this message.Offending ECDSA key in /Users/wangdong/.ssh/known_hosts:26ECDSA host key for 47.98.233.15 has changed and you have requested strict checking.Host key verification failed.# 从网上截的,自己电脑报错没报错按报错的提示,需要将C:\\Users\\10630\\.ssh中的known_hosts中的内容删掉,因为他默认先从这里边找相同IP的,删掉后就行了 sshSSH分客户端openssh-client和服务器端openssh-server，如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudo apt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server 下面讲解openssh-server 首先更新源 1sudo apt-get update 安装ssh服务 1sudo apt-get install openssh-server 检测是否已启动 1ps -e | grep ssh 看到有ssh字样，说明已启动，如果没有就手动启动 1/etc/init.d/ssh start 配置ssh-server，配置文件位于/etc/ssh/sshd_config，默认端口为22，为了安全，一般自定义为其他端口，然后重启 1sudo /etc/init.d/ssh resart 增加桌面快捷方式Launcher :​ 在/usr/share/applications/中写入Roboviz.desktop文件(sudo vim Roboviz.desktop) 123456789[Desktop Entry]Name=RobovizComment=RobovizExec=/home/apollo3d/RoboViz-dev/bin/linux-amd64/roboviz.shIcon=/home/apollo3d/RoboViz-dev/bin/linux-amd64/resources/images/icon.pngTerminal=trueStartupNotify=trueType=ApplicationCategories=Development;IDE; ps aux | grep进程名ps -A 显示所有程序。ps e 列出程序时，显示每个程序所使用的环境变量。kill －9 324killall -9 NAME Linux下还提供了一个killall命令，可以直接使用进程的名字而不是进程标识号chmod {u|g|o|a}{+|-|=}{r|w|x} filename 修改权限find pathname [option] expression 寻找文件grep [option] pattern filenames 搜索文件中匹配符​ grep -r 二进制 /home/apollo3d/Documents./文件名 进入到进程的执行文件所在的路径下，执行文件 https://www.cnblogs.com/lcword/p/6046261.html 端口操作 端口监听信息 netstat -plant一、查看哪些端口被打开 netstat -anp 二、关闭端口号:iptables -A OUTPUT -p tcp --dport 端口号 -j DROP 三、打开端口号：iptables -A INPUT -ptcp --dport 端口号 -j ACCEPT 四、以下是linux打开端口命令的使用方法。 nc -lp 23 &amp;(打开23端口，即telnet) netstat -an | grep 23 (查看是否打开23端口) 或者 lsof -i:80 五、linux打开端口命令每一个打开的端口，都需要有相应的监听程序才可以 创建新用户 在 root 用户下运行这条命令创建一个新用户，yangxg 是用户名 因为我叫杨学光，所以我取的用户名是 yangxg 选择一个你喜欢的用户名，不一定非得和我的相同 root@localhost:~# useradd -m -s /bin/bash yangxg 把新创建的用户加入超级权限组 root@localhost:~# usermod -a -G sudo yangxg 为新用户设置密码 注意在输密码的时候不会有字符显示，不要以为键盘坏了，正常输入即可 root@localhost:~# passwd yangxg 切换到创建的新用户 root@localhost:~# su - yangxg 切换成功，@符号前面已经是新用户名而不是 root 了 yangxg@localhost:~$ 为root用户提供初始密码sudo passwd root 修改为阿里云 DNS 您必须是管理员root或者具有管理员权限 sudo vim /etc/resolv.conf 加入: 12nameserver 223.5.5.5nameserver 223.6.6.6 保存退出，然后使用dig 验证: dig www.taobao.com +short若出现结果则表示正常。 换源(更换数据源)12345rootdubuntu:/home/lusifer# curl -sSL https://get. daocloud. io/docker | shExecuting docker install script, commit:1d31602+sh-c apt-get update-qq&gt;/dev/null E: Could not get Lock /var/lib/apt/lists/lock-open (11: Resource temporarily unavailable)E: Unable to lock directory /var/lib/apt/lists/ 原因可能是没有更新数据源 1.备份默认的源sudo cp /etc/apt/sources.list /etc/apt/sources_init.list 2.用你熟悉的编辑器打开：如vim /etc/apt/sources.list替换默认的http://archive.ubuntu.com/为mirrors.aliyun.com 123456789101112131415deb http://mirrors.aliyun.com/ubuntu/ xenial maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial maindeb http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe 最后输入sudo apt-get update Ubuntu无法找到add-apt-repository问题的解决方法 网上查了一下资料，原来是需要python-software-propertiduanjkes 于是apt-get install python-software-properties 除此之外还要安装software-properties-common 于是apt-get install software-properties-common 然后就能用add-apt-repository了 代理搜索代理env | grep proxy、sudo grep -r -i http_proxy=代理地址 配置代理 临时:export http_proxy=http://10.3.0.1:80 (1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。) Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;; 保存apt.conf文件。 (2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件) 建立文件 vim proxyfile Acquire::http::proxy &quot;http://10.3.0.1:80&quot;; Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;; Acquire::https::proxy &quot;http://10.3.0.1:80&quot;; 使用时sudo apt-get install xxx -c proxyfile (2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 ) 在您的.bashrc文件末尾添加如下内容export http_proxy=http://用户名:密码@地址:端口/export https_proxy=http://用户名:密码@地址:端口/ export ftp_proxy=http://用户名:密码@地址:端口/ ubuntu 代理配置 PPA1.vim /usr/lib/python3/dist-packages/softwareproperties/ppa.py 在函数def _get_https_content_py3（lp_url）的catch案例中添加了一个print（e）显示了错误的真正原因。 2.系统时间是否正确 3.除了配置代理之外，请告诉sudo使用-E该标志来考虑环境 123export http_proxy=http://&lt;proxy&gt;:&lt;port&gt;export https_proxy=http://&lt;proxy&gt;:&lt;port&gt;sudo -E apt-add-repository ppa:canonical-qt5-edgers/qt5-proper with username and password: 1export https_proxy=&lt;username&gt;:&lt;password&gt;@&lt;proxy&gt;:&lt;port&gt; Ubuntu下让终端走SS代理的方法Ubuntu下让终端走SS代理需要第三方软件的帮助，即privoxy。privoxy 是非快取式 (non-caching) 的网页代理伺服器，具有进阶的过滤能力，可强化隐私权，还可以修改网页资料、管理 HTTP cookies、去除广告等。 安装 privoxy sudo apt-get install privoxy 安装完成后在 /etc/privoxy 目录下可以找到配置文件 config。 配置 privoxy一般地，改配置前应该备份配置。 mv /etc/privoxy/config /etc/privoxy/config.back 然后打开 config 文件，找到listen-address那一行，修改值为 privoxy 监听的地址，一般使用默认。 然后再找到forward-socks5那一行，去掉注释，值为SS代理监听的地址。 让终端走SS代理,修改配置后，重启 privoxy。 sudo /etc/init.d/privoxy restart 然后在终端下添加 http 代理。 export http_proxy=”127.0.0.1:8118” export https_proxy=”127.0.0.1:8118” 然后就可以愉快的用终端翻墙了。 原文：https://blog.csdn.net/tailgo/article/details/52075643 Lets Encrypt 配置SSL错误 DNS problem: NXDOMAIN looking up A for xxx 刚刚解析了A记录，解析服务器还没有生效 服务器本地 DNS缓存未更新 1. 首先确定A记录是否成效确定的方式很简单，在浏览器输入自己的域名，查看能否访问成功。 2. 确定DNS是否有问题1) ping主机12# ping主机，如果无法发现host，则确定是dns问题$ ping demo.ptbird.cn 2) 更新DNS缓存不建议直接 network restart 使用nscd如果系统没装可以装一下，nscd做DNS缓存加速很有用。 centos : yum install nscd、ubuntu ：apt-get install nscd 如果已经装了直接更新 1234# 主要是hosts$ nscd -i passwd$ nscd -i group$ nscd -i hosts grep指令参数说明https://www.cnblogs.com/forestwolf/p/6413916.html","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"搭建Gitlab服务器","slug":"搭建Gitlab服务器","date":"2019-03-14T10:32:26.000Z","updated":"2019-03-16T12:07:39.171Z","comments":true,"path":"2019/03/14/搭建Gitlab服务器/","link":"","permalink":"https://nymrli.top/2019/03/14/搭建Gitlab服务器/","excerpt":"","text":"搭建Gitlab服务器下载安装Gitlab由于直接下载Gitlab会很慢(被墙的缘故) ， 于是选择清华的镜像安装，清华源 Ubuntu 16.04 用户 Linux其他版本或者不是Ubuntu 16.04 见官网修改方式 首先信任 GitLab 的 GPG 公钥: 1curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null ▲如果这步不行，先进行下一步 文本框中内容写进 /etc/apt/sources.list.d/gitlab-ce.list 1deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu xenial main 安装 gitlab-ce: 12sudo apt-get updatesudo apt-get install gitlab-ce 安装成功后，会显示“狐狸头”。 初次配置服务 1sudo gitlab-ctl reconfigure 启动服务 1sudo gitlab-ctl start 初始化管理员root账号 汉化(用不了–&gt;建议另找)1.下载社区提供的汉化包，在 https://gitlab.com/xhang/gitlab/ 中找到相应的汉化分支。 1sudo wget wget -cO gitlab-9.0_zh.tar.gz https://gitlab.com/xhang/gitlab/repository/archive.tar.gz?ref=9-0-stable-zh 2.解压包 1sudo tar zxvf gitlab-9.0_zh.tar.gz 3.停止 GitLab 服务 1sudo gitlab-ctl stop 4.备份 gitlab-rails 目录，该目录下主要是web应用部分，也是当前项目仓库的起始版本，也是汉化包要覆盖的目录。 1sudo tar zcvf /opt/gitlab/embedded/service/gitlab-rails-bak.tar.gz gitlab-rails 5.将解压后的汉化补丁覆盖原来的 1sudo cp -rf gitlab-9-0-stable-zh/* gitlab-rails/ 6.启动服务 1sudo gitlab-ctl start 7.重新执行配置命令 1sudo gitlab-ctl reconfigure 注意gitlab的配置文件在/etc/gitlab/gitlab.rb中,我个人操作是要经过一次reconfigure后，gitlab.rb才有内容的。（但/opt/gitlab/etcgitlab.rb.template 中一直有，应该就是因为是模板的原因吧） gitlab修改默认端口gitlab.rb修改123456789101112131415161718## Advanced settingsunicorn['listen'] = '127.0.0.1'unicorn['port'] = 8082...################################################################################## GitLab Web server# web_server['shell'] = '/bin/false'# web_server['home'] = '/var/opt/gitlab/nginx'################################################################################## GitLab NGINX##! Docs: https://docs.gitlab.com/omnibus/settings/nginx.html################################################################################nginx['listen_addresses'] = ['*']nginx['listen_port'] = 82 # override only if you use a reverse proxy: https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#setting-the-nginx-listen-port gitlab-rails修改1234# What ports/sockets to listen on, and what options for them.#listen \"127.0.0.1:8080\", :tcp_nopush =&gt; truelisten \"127.0.0.1:8082\", :tcp_nopush =&gt; truelisten \"/var/opt/gitlab/gitlab-rails/sockets/gitlab.socket\", :backlog =&gt; 1024 gitlab nginx 修改1234567server &#123; listen *:82; server_name gitlab.123.123.cn; server_tokens off; ## Don&apos;t show the nginx version number, a security best practice&#125; 修改完成后，重启下sudo gitlab-ctl reconfigure,sudo gitlab-ctl restart，就可以放82端口的gitlab了。 附录: 参考链接: https://www.linuxidc.com/Linux/2018-01/150319.htm https://blog.csdn.net/hnmpf/article/details/80518460 (未看，但觉得应该还行) 之前记录的,先放着 配置Gitlab1.安装1）查看电脑配置 github对内核有限制 64位,内核3.0 uname -a 、 uname --m 2）安装https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/ 3） 配置开启GitLab1sudo gitlab-ctl reconfigure 2.配置1.查看主机名然后登陆你第一次访问, 你会被自动导向到密码重置界面，重置完成密码后 会重新返回登陆界面 默认账户的 username 是 root. 提供给你的密码容易创建和登录. 登录后你可以将 username 改成你希望的. 2. 配置服务器及访问路径123$ vim /etc/gitlab~ external_url = \"http://gitlab.aaa.com\"$ Gitlab-ctl reconfigure 3.配置nginx及DNS域名解析docker 下 Gitlab搭建1.配置vim docker-compose.yml1234567891011121314151617181920212223version:3services: gitlab: image: twang2218/g1tlab-ce-zh:9.4 restart: always hostname:192,16875.129 # environment里才是gitlab的设置,包含nginx和gitlab # gitlab的网页访问是通过nginx的方向代理访问的 environment: TZ: Asia/Shanghei GITLAB_OMNIBUS_CONFIG: | external _url 'http://192 168.75.129:8080' gitlab_rails[' gitlab_shell_ssh_port']=2222 unicorn[' port']=8888 nginx[' listen_port']=8080 ports: # 左边是宿主机的端口, 右边是容器的端口 - '8080:8080' - '8443:443' - '2222:22' volumes: - /usr/local/docker/gitlab/config:/etc/gitlab - /usr/local/docker/gitlab/data:/var/opt/gitlab - /usr/local/docker/gitlab/logs:/var/log/gitlab 配置好后通过http://192 168.75.129:8080进行访问 2.配置root用户初始密码","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"程序设计周cpp学习笔记","slug":"程序设计周cpp学习笔记","date":"2019-03-07T11:56:14.000Z","updated":"2019-03-07T11:56:39.447Z","comments":true,"path":"2019/03/07/程序设计周cpp学习笔记/","link":"","permalink":"https://nymrli.top/2019/03/07/程序设计周cpp学习笔记/","excerpt":"","text":"文件名传参123456789101112131415using namespace std;#define FILENAME \"data.csv\"void readfile(string file)&#123; ifstream inFile; inFile.open(file.c_str(), ios::out); // 打开模式可省略 string lineStr; while (getline(inFile, lineStr) ) // 打印整行字符串 cout &lt;&lt; lineStr &lt;&lt; '-'&lt;&lt; endl; &#125; int main()&#123; readfile(FILENAME); return 0; &#125; 输入Q退出123456789101112131415161718void studentMenu()&#123; string UID; string PWD; int confirmed = false; //判断是否认证成功 do&#123; cout &lt;&lt;\"请输入普通账号ID:\" &lt;&lt;endl; cin &gt;&gt; UID; cout &lt;&lt;\"请输入密码:\" &lt;&lt;endl; cin &gt;&gt; PWD; confirmed = confirmStatus(UID,PWD); if( !confirmed ) cout &lt;&lt; \"账号或密码错误,请尝试.账号ID输入'Q'退出\"; &#125;while( !confirmed &amp;&amp; UID != \"Q\"); if(confirmed) &#123; cout &lt;&lt; \"成功认证\"; //进入学生界面 &#125;&#125; !!!! 标准库文件是在.h还是.cpp中include?现有两个文件Test.h 和Test.cpp#include &lt;iostream&gt;在Test.h中包含 和在Test.cpp中包含有什么区别? 1、在cpp文件中包含.h文件，要么你要用到这个头文件中的函数或者类，要么就是实现这个头文件； 2、.h —就是为了放一堆声明所产生的东西。如果是定义放在.h中。 如果.h被重复包含多次，那么则会被报重定义。所以在.h 中都要—如果函数就要是inline ,如果是变量就要 selectany (windows)才不会被报错。 3、#include尽量写到cpp文件里。两个文件在.h文件里相互include,就会产生编译错误，而两个文件在.c文件互相include，就不会有该问题，因此在.h文件include就要避免互相包含的问题，而.cpp文件就不需要考虑 4、1）在 .h 里面 include 的好处是：如果很多.c,.cpp文件，都包含一批头文件,如果复制很容易遗漏，如果输入，很容易出错 如果全部在一个.h, include 那么每个.c,.cpp文件只需要一个#include 语句这样不仅输入量减少，而且代码也美观多了代码也主次分明了毕竟，.c.cpp, 里面要实现的函数，才是主要代码 2）主要缺陷，可能会包含完全不需要的头文件，增加编译工作量 5、如果你在a.h头文件中include了“stdio.h”，“iostream”，……一大堆那么你的a.cpp源文件只要include你的a.h，就相当于include了“stdio.h”，“iostream”，……一大堆但是当其他文件include你的a.h的同时也就包含了“stdio.h”，“iostream”，……一大堆这个要看你个人需要，如果你需要让其他文件也include一大堆，那么写在a.h中就可以，其他文件包含a.cpp简单整洁无脑如果只有a.cpp需要include一大堆，那么还是建议在a.cpp中include一大堆 6、如果a.c包含了头文件a.h，a.h包含了头文件b.h，b.c也包含了b.h，那么当b.h发生改变时，a.c和b.c都会重新编译也就是所有包含了b.h的都会重新编译，无论是直接包含，还是间接包含 7、2点原则： 第一个原则：如果可以不包含头文件，那就不要包含了，这时候前置声明可以解决问题。如果使用的仅仅是一个类的指针，没有使用这个类的具体对象（非指针），也没有访问到类的具体成员，那么前置声明就可以了。因为指针这一数据类型的大小是特定的，编译器可以获知（C++编译器自上而下编译源文件的时候，对每一个数据的定义，总是需要知道定义的数据的类型的大小） 第二个原则：尽量在CPP文件中包含头文件，而非在头文件中。假设类A的一个成员是是一个指向类B的指针，在类A的头文件中使用了类 B的前置声明并编译成功，那么在A的实现中我们需要访问B的具体成员，因此需要包含头文件，那么我们应该在类A的实现部分（CPP文件）包含类B的头文件而非声明部分(H文件) 摘自:https://www.cnblogs.com/fengzhengfly/p/8884581.html C++ 构造函数的使用1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class CUser&#123; public: string UID; int status; void login(); CUser():UID(\"0\"),status(0)&#123;&#125; CUser(string id,int sts):UID(id),status(sts)&#123;&#125;&#125;;int main()&#123; CUser user(\"hello\",12); cout &lt;&lt; user.UID &lt;&lt; user.status; getchar(); return 0;&#125; string转int1234567891011atoi(rstatus.c_str()) //atoi(&quot;04&quot;); ===&gt; 4 可以忽略0---使用stringstream:string s = &quot;17&quot;;stringstream ss;ss&lt;&lt;s;int i;ss&gt;&gt;i;cout&lt;&lt;i&lt;&lt;endl; // 17//stringstream可以吞下任何类型，根据实际需要吐出不同的类型 int转string123456int n = 0;std::stringstream ss;std::string str;ss&lt;&lt;n;ss&gt;&gt;str;//或者cout &lt;&lt; ss.str(); 1itoa(num, str, 10); string转int 12std::string str = &quot;123&quot;;int n = atoi(str.c_str()); int 转string12345678910这是C++11新增的，使用非常方便，简单查了下：C++11标准增加了全局函数std::to_string，string to_string (int val);string to_string (long val);string to_string (long long val);string to_string (unsigned val);string to_string (unsigned long val);string to_string (unsigned long long val);string to_string (float val);string to_string (double val);string to_string (long double val) 一.string转char * data() c_str() copy(); 1、string转char*。1234561 string str = &quot;hello&quot;;2 const char* p = str.data();//加const 或者用char * p=(char*)str.data();的形式/* 同时有一点需要说明，这里在devc++中编译需要添加const，否则会报错invalid conversion from const char* to char *，这里可以再前面加上const或者在等号后面给强制转化成char*的类型。 下面解释下该问题，const char*是不能直接赋值到char*的,这样编译都不能通过,理由:假如可以的话,那么通过char*就可以修改const char指向的内容了,这是不允许的。所以char*要另外开辟新的空间，即上面的形式。 */ 2.c_str()方法，如：121 string str=“world”;2 const char *p = str.c_str();//同上，要加const或者等号右边用char* 3.copy()方法，如：12341 string str=&quot;hmmm&quot;;2 char p[50];3 str.copy(p, 5, 0);//这里5代表复制几个字符，0代表复制的位置，4 *(p+5)=‘\\0’;//注意手动加结束符！！！ 二、char * 转string。1231 string s;2 char *p = &quot;hello&quot;;//直接赋值3 s = p; 这里有一点要说明，当声明了string类型变量s后，用printf(“%s”,s);是会出错的，因为“%s”要求后面的对象的首地址。但是string不是这样的一个类型。所以肯定出错。 1234567891011121314151617181920class A&#123;public: void co(); void bo();&#125;;void A::co()&#123; cout &lt;&lt; \"hello\"; A::bo();&#125;void A::bo()&#123; cout &lt;&lt; \"world\";&#125;#include &lt;cstdio&gt;int main()&#123; A a; a.co(); getchar();&#125; 1234567891011121314151617181920int main()&#123; ifstream inFile(&quot;data1.csv&quot;, ios::in); if (inFile.fail())&#123; cout &lt;&lt; &quot;Cannot open file&quot; &lt;&lt; endl; return -1; &#125; vector&lt;string&gt; line; string lineStr; while (getline(inFile, lineStr) )&#123; line.push_back(lineStr); &#125; for(vector&lt;string&gt;::iterator i=line.begin();i!=line.end();i++)&#123; // cout &lt;&lt; strArray.at(i)&lt;&lt;endl; cout &lt;&lt; (*i) &lt;&lt; endl; &#125; getchar(); return 0;&#125; 1234cout &lt;&lt; &quot;请输入书的数量：&quot; &lt;&lt; endl; do&#123; cin &gt;&gt; tmp.TotalNumber;&#125;while( atoi( tmp.TotalNumber.c_str()) == 0 ) ; //非数字情况 操作二维Vector123456789101112131415string lineStr;vector&lt;vector&lt;string&gt;&gt; strArray;while (getline(inFile, lineStr) )&#123; stringstream ss(lineStr); string str; vector&lt;string&gt; lineArray;while (getline(ss, str, &apos;,&apos;)) lineArray.push_back(str); strArray.push_back(lineArray);for(vector&lt;vector&lt;string&gt;&gt;::iterator i=strArray.begin();i!=strArray.end();i++)&#123; for(vector&lt;string&gt;::iterator j=(*i).begin();j!=(*i).end();j++)&#123; cout &lt;&lt; &quot;*j &quot; ; &#125; cout &lt;&lt; endl; &#125;&#125; 改好的 12345678910111213141516171819202122232425262728293031323334int main()&#123; ifstream inFile(\"data1.csv\", ios::in); vector&lt;vector&lt;string&gt;&gt; lineVec; if (inFile.fail())&#123; cout &lt;&lt; \"Cannot open file\" &lt;&lt; endl; return -1; &#125; string lineStr; vector&lt;vector&lt;string&gt;&gt; vecArray; vector&lt;string&gt; newvec; while (getline(inFile, lineStr) )&#123; stringstream ss(lineStr); string str; vector&lt;string&gt; lineVec; while (getline(ss, str, ',')) lineVec.push_back(str); vecArray.push_back(lineVec); for(vector&lt;vector&lt;string&gt;&gt;::iterator i=vecArray.begin();i!=vecArray.end();i++)&#123; vector&lt;string&gt;::iterator j=(*i).begin(); if( *j != \"100009/1\" ) &#123;newvec.push_back(lineStr); break; &#125; &#125; &#125; for (std::vector&lt;string&gt;::iterator i = newvec.begin(); i != newvec.end(); ++i) cout &lt;&lt; *i &lt;&lt; endl; system(\"pause\"); return 0;&#125; 二维Vector 1234567891011121314151617int main(int argc, char const *argv[])&#123; vector&lt;vector&lt;string&gt;&gt; row; vector&lt;string&gt; col1; vector&lt;string&gt; col2; col1.push_back(&quot;Q&quot;); col1.push_back(&quot;W&quot;); col2.push_back(&quot;A&quot;); col2.push_back(&quot;S&quot;); row.push_back(col1); row.push_back(col2); cout &lt;&lt; row.at(0).at(1); getchar(); return 0;&#125; 查看vector中是否含指定的string123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(int argc, char const *argv[])&#123; std::vector&lt;string&gt; v; v.push_back(&quot;hello&quot;); v.push_back(&quot;1ord&quot;); v.push_back(&quot;asd&quot;); if (std::find(v.begin(), v.end(), &quot;he&quot;) != v.end()) &#123; cout &lt;&lt; &quot;yes&quot;; &#125; getchar(); return 0;&#125; 循环时删除某个元素,不影响循环==&gt;每个元素仍能被遍历 1234567891011121314int main()&#123; vector&lt;string&gt; v; v.push_back(\"1\"); v.push_back(\"2\"); v.push_back(\"3\"); v.push_back(\"4\"); for (int i = 0; i &lt; v.size(); ++i)&#123; if (v.at(i) == \"2\") v.erase(v.begin()+i); &#125; for (int i = 0; i &lt; v.size(); ++i) cout &lt;&lt; v.at(i) &lt;&lt; endl; system(\"pause\"); return 0;&#125; 跳过索引值,只输出id123456789101112131415161718192021int main(int argc, char const *argv[])&#123; ifstream inFile; inFile.open(&quot;data1.csv&quot;); string lineStr; vector&lt;vector&lt;string&gt; &gt; row; vector&lt;string&gt; newvec; while (getline(inFile, lineStr) )&#123; stringstream ss(lineStr); string str; vector&lt;string&gt; col; while (getline(ss, str, &apos;,&apos;)) col.push_back(str); row.push_back(col); &#125; for (int i = 1; i &lt; row.size(); ++i) cout &lt;&lt; row.at(i).at(0) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 避免错误输入1while(getchar()!=&apos;\\n&apos;) ; 分割时间12345678910111213141516171819202122232425void CData(string &amp;timestr)&#123; stringstream ss(timestr); int year; int mon; int day; string str; getline(ss, str, &apos;/&apos;); year = atoi(str.c_str()); getline(ss, str, &apos;/&apos;); mon = atoi(str.c_str()); getline(ss, str, &apos;/&apos;); day = atoi(str.c_str()); cout &lt;&lt; year &lt;&lt; &quot;,&quot; &lt;&lt; mon &lt;&lt; &quot;,&quot; &lt;&lt; day &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123; // string a =&quot;2017/04/02&quot;; // CData(a); stringstream ss; ss &lt;&lt; 1 &lt;&lt; &quot;/&quot; &lt;&lt; 2 &lt;&lt; &quot;/&quot; &lt;&lt; 3; cout &lt;&lt; ss.str(); getchar(); return 0;&#125; 12stringstream ss;ss &lt;&lt; 1 &lt;&lt; &quot;/&quot; &lt;&lt; 2 &lt;&lt; &quot;/&quot; &lt;&lt; 3; vector最大值 1int maxn = *max_element(v.begin(),v.end()); 找到最大ID123456789101112vector&lt;string&gt; idcol;string lineStr; while (getline(infile, lineStr) )&#123; //获取行 stringstream ss(lineStr); string bookid; //记录列数据,必须写在这个循环里 getline(ss, bookid, &apos;,&apos;); idcol.push_back(bookid);&#125; int addid = vecMAX(idcol)+1; stringstream inttostring; inttostring &lt;&lt; addid; tmp.BookID = inttostring.str(); 二维VEC排序12345678910111213141516171819int main()&#123; std::vector&lt;std::vector&lt;int&gt; &gt; s; vector&lt;int&gt; v1; vector&lt;int&gt; v2; v1.push_back(5); v1.push_back(13); s.push_back(v1); v2.push_back(7); v2.push_back(4); s.push_back(v2); sort(s.begin(), s.end()); for (int i = 0; i &lt; s.size(); ++i)&#123; for (int j = 0; j &lt; v1.size(); ++j) cout &lt;&lt; s.at(i).at(j); cout &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 123out.open(USERTMPFILE) 可以打开宏定义ios::in + ios::out 从开头加ios::app 从结尾加 获得值最大的键12345678910111213141516bool cmp(const pair&lt;string, int&gt;&amp; lhs, const pair&lt;string, int&gt;&amp; rhs) &#123; return lhs.second &gt; rhs.second; &#125; int main(int argc, char const *argv[])&#123; map&lt;string,int&gt; a ; a.insert(pair&lt;string, int&gt;(&quot;ssd&quot;, 3)); a[&quot;hello&quot;]=3; a[&quot;world&quot;]=9; a[&quot;cl&quot;]=6; std::vector&lt; pair&lt;string, int&gt; &gt; v(a.begin(), a.end()); sort(v.begin(), v.end(),cmp); cout &lt;&lt; &quot;max&quot; &lt;&lt; v.at(0).first &lt;&lt; endl; getchar(); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"程序设计","slug":"程序设计","permalink":"https://nymrli.top/tags/程序设计/"}]},{"title":"ACM-DFS、BFS","slug":"ACM-DFS、BFS","date":"2019-03-07T11:55:03.000Z","updated":"2019-04-26T12:08:15.737Z","comments":true,"path":"2019/03/07/ACM-DFS、BFS/","link":"","permalink":"https://nymrli.top/2019/03/07/ACM-DFS、BFS/","excerpt":"","text":"深度优先搜索(DFS) 从某个状态,不断转移状态直到无法转移,然后回退到前一步的状态,继续转移到其他状态,如此不断重复,直到找到最终解. ====&gt; 递归函数 隐式的用到了栈(stack) 123456789101112131415161718192021222324252627//[部分和问题]#include &lt;iostream&gt;#define MAXN 10000int n,k;int s[MAXN];using namespace std;bool dfs(int i,int sum)&#123; if( i == n ) return sum == k;//如果前n项计算过了，返回sum=k是否相等 if ( dfs(i+1 , sum) ) return true; //不加上s[i]的情况； if ( dfs(i+1, sum + s[i] )) return true; //加上s[i]的情况 return false; //无论加不加上s[i]&#125;void input()&#123; cin &gt;&gt; n; for(int i=0;i&lt;n;i++) cin &gt;&gt; s[i]; cin &gt;&gt; k;&#125;int main()&#123; input(); if (dfs(0,0)) cout &lt;&lt; \"YES\"; else cout &lt;&lt;\"NO\"; return 0;&#125; laking countiing12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//[laking countiing]#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 10000using namespace std;int N,M;char field[MAXN][MAXN]=&#123;&#123;\"W........WW.\"&#125;,&#123;\".WWW.....WWW\"&#125;,&#123;\"....WW...WW.\"&#125;,&#123;\".........WW.\"&#125;,&#123;\".........W..\"&#125;,&#123;\"..W.......W.\"&#125;,&#123;\".W.W.....WW.\"&#125;,&#123;\"W.W.W.....W.\"&#125;,&#123;\".W.W......W.\"&#125;,&#123;\"..W.......W.\"&#125;&#125;;void dfs(int x,int y)&#123; field[x][y] = '.'; //循环遍历移动的8个方向,检测八连通位置 for(int dx=-1;dx&lt;=1;dx++) for(int dy=-1;dy&lt;=1;dy++)&#123; int nx=x+dx; //移动后的结果为(nx,ny) int ny=y+dy; if( (0 &lt;= nx &amp;&amp; nx&lt; N) &amp;&amp; (0 &lt;= ny &amp;&amp; ny &lt; M) &amp;&amp; field[nx][ny]=='W') dfs(nx,ny); //此处为做题的关键 : 不断 &#125; return ;&#125;void solve()&#123; int res = 0; //水坑数量 for(int i=0;i&lt;N;i++) for(int j=0;j&lt;M;j++)&#123; if(field[i][j] == 'W')&#123; dfs(i,j); res++; &#125; &#125; printf(\"%d\\n\",res);&#125;void printLake()&#123; N=10;M=12; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++) cout &lt;&lt; field[i][j] ; cout &lt;&lt; endl; &#125;&#125;int main()&#123; N=10; M=12; solve(); return 0;&#125; 宽度优先搜索(BFS) 总是优先搜索距离初始状态最近的状态,复杂度 = O(状态书 * 转移的方式) 显式利用队列(queue),搜索时首先将初始状态添加到队列里,此后从队列的最前端不断取出状态,吧从该状态可以转移到的状态中尚未访问过的部分加入队列,如此往返,直至队列被取空或是找到了问题的解 广度优先搜索思想 设图G的初态是所有顶点均未访问，在G 中任选一顶点i作为初始点，则广度优先搜索的基本思想是： （1）从图中的某个顶点V出发，访问之；并将其访问标志置为已被访问，即visited[i]=1； （2）依次访问顶点V的各个未被访问过的邻接 点，将V的全部邻接点都访问到； （3）分别从这些邻接点出发，依次访问它们的未被访问过的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接 点”被访问，直到图中所有已被访问过的顶点的邻接点都被访问到。依此类推，直到图中所有顶点都被访问完为止 。 广度优先搜索在搜索访问一层时，需要记住已被访问的顶点，以便在访问下层顶点时，从已被访问的顶点出发搜索访问其邻接点。所以在广度优先搜索中需要设置一个队列Queue，使已被访问的顶点顺序由队尾进入队列。在搜索访问下层顶点时，先从队首取出一个已被访问的上层顶点，再从该顶点出发搜索访问它的各个邻接点。 1234567891011W........WW..WWW.....WWW....WW...WW..........WW..........W...........WW...W.......W..W.W.....WW.W.W.W.....W..W.W......W...W.......W. 1234567891011&#123;W........WW.&#125;&#123;.WWW.....WWW&#125;&#123;....WW...WW.&#125;&#123;.........WW.&#125;&#123;.........W..&#125;&#123;.........WW.&#125;&#123;..W.......W.&#125;&#123;.W.W.....WW.&#125;&#123;W.W.W.....W.&#125;&#123;.W.W......W.&#125;&#123;..W.......W.&#125; 2019蓝桥杯省赛–maze123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#include &lt;string&gt;#include &lt;queue&gt;/*010010001000000101110000访问次数:9访问次序:DRDRDRRR*/using namespace std;typedef pair&lt;int ,int&gt; State;const int maxn = 1000;const int row = 4;const int col = 6;//const int INF = 10000000;char maze[row+1][col+1];int visited[row+1][col+1]; //是否访问过，记录次数string trace[row+1][col+1]; //记录每次移动的方向int X[] = &#123;-1,0,1,0&#125;; // 这边可能定义错了，这个对应的是行int Y[] = &#123;0,1,0,-1&#125;; // 这个对应的是列，而不是X,Ystring sarr[] = &#123;\"U\",\"R\",\"D\",\"L\"&#125;;int x=1;int y=1;void bfs()&#123; queue&lt;State&gt; q; // 起点 q.push(State(x,y)); while( !q.empty() )&#123; // 取状态 State s = q.front(); q.pop(); if( x == row &amp;&amp; y == col ) break; // 到达终点 // 一个数组记录四个方向 for( int i = 0 ; i &lt; 4; i++)&#123; int nx = s.first + X[i]; int ny = s.second + Y[i]; if( nx &gt;= 1 &amp;&amp; nx &lt;= row &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= col &amp;&amp; maze[nx][ny] != '1'&amp;&amp; visited[nx][ny] == 0 ) &#123; //cout &lt;&lt; nx &lt;&lt; ny &lt;&lt; endl; visited[nx][ny] = 1; //cout &lt;&lt; maze[nx][ny] &lt;&lt; sarr[i] &lt;&lt; endl; //cout &lt;&lt; endl; visited[nx][ny] = visited[s.first][s.second] +1; trace[nx][ny] = trace[s.first][s.second] + sarr[i]; q.push(State(nx,ny)); &#125; &#125; &#125; cout &lt;&lt;\"times:\"&lt;&lt; visited[row][col] &lt;&lt;endl; cout &lt;&lt;\"order:\"&lt;&lt; trace[row][col] &lt;&lt;endl;&#125;int main()&#123; // 初始化 for(int i=1 ; i &lt;= row ; i++) for(int j= 1; j &lt;= col ; j++) visited[i][j] = 0; // 起点为(1,1) visited[1][1] = 1; //处理输入 for(int i=1 ; i &lt;= row ; i++)&#123; for(int j= 1; j &lt;= col ; j++) scanf(\"%c\",&amp;maze[i][j]); getchar(); &#125; bfs(); return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"ACM-快速幂","slug":"ACM-快速幂","date":"2019-03-07T11:54:05.000Z","updated":"2019-04-26T12:17:47.482Z","comments":true,"path":"2019/03/07/ACM-快速幂/","link":"","permalink":"https://nymrli.top/2019/03/07/ACM-快速幂/","excerpt":"","text":"简单位运算快速幂 假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b==11时，a^11=a^(2^0+2^1+2^3) 123456789int poww(int a,int b)&#123; int ans=1,base=a; while(b!)&#123; if(b&amp;1) ans*=base; base*=base; b&gt;&gt;=1; &#125; return ans;&#125; 11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算a^(2^0)*a^(2^1)*a^(2^3) 其中比较重要的一步:base*=base,即基底不断增加,如果二进制是1则*上基底否则不,ans为所有基底相乘 1234567base*base==base^2下一步再乘，就是base^2*base^2==base^4然后同理 base^4 * base4 = base^8 see?是不是做到了base--&gt;base^2--&gt;base^4--&gt;base^8--&gt;base^16--&gt;base^32.......指数正是 2^i ，再看上面的例子，a¹¹ = a^(2^0) * a^(2^1) * a^(2^3)，这三项是不是完美解决了，，嗯，快速幂就是这样。 ▲.由于指数函数是爆炸增长的函数，所以很有可能会爆掉int的范围，根据题意决定是用 long long啊还是unsigned int啊还是mod某个数啊自己看着办。 12345678910typedef long long ll;ll mod_pow(ll base,ll n,ll mod)&#123; ll res=1; while(n&gt;0)&#123; if( n &amp; 1 ) res = res*base%mod; base = base*base%mod; n&gt;&gt;= 1; &#125; return res;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"南京邮电大学java程序设计作业在线编程第三次作业","slug":"南京邮电大学java程序设计作业在线编程第三次作业","date":"2019-03-07T11:12:47.000Z","updated":"2019-03-17T05:31:56.614Z","comments":true,"path":"2019/03/07/南京邮电大学java程序设计作业在线编程第三次作业/","link":"","permalink":"https://nymrli.top/2019/03/07/南京邮电大学java程序设计作业在线编程第三次作业/","excerpt":"","text":"选择题得分：60 \\1. 设有如下定义语句： String s1=”My cat”; int m=s1.compareTo(“My a cat”); 语句被执行后m的值为（ ） A.2 B.1 C.0 D.-2 正确答案是: A \\2. 语句 String s1=new String(“Hello”); String s2=new String(“Hello”); System.out.println(s1==s2); System.out.printlv(s1.equals(s2)); 执行后的输出结果是（ ） A.Hello false B.Hello true C.Hello Hello D.false true 正确答案是: D \\3. 执行下列语句 int[] lx={2,3,4,5}; lx[3]=lx[3]==–lx[0]?++lx[1]:lx[2]–; 后，数组lx的元素值分别为（ ） A.1,2,3,4 B.1,3,3,3 C.1,2,3,3 D.1,3,3,4 正确答案是: D \\4. 在一个应用程序中定义了数组a：int[] a={1,2,3,4,5,6,7,8,9,10}，为了打印输出数组a的最后一个数组元素，下面正确的代码是（ ） A.System.out.println(a[10]); B.System.out.println(a[9]); C.System.out.println(a[8]); D.System.out.println(a[a.length]); 正确答案是: B \\5. 设有定义语句int a[]={36,72,99};则以下对此语句叙述错误的是（ ） A.该语句定义了一个名为a的一维数组； B.a数组有3个元素； C.数组中的每个元素是整型； D.a数组的元素的下标为1~3； 正确答案是: D \\6. 下面关于数组定义语句不正确的是（ ） A.float f[]=new{2.4f,3.5f,5.7f,7.9f}; B.int a[]={1,2,3,4,5} C.double[]d=new double[10]; D.int[]a2; 正确答案是: A \\7. 下列语句序列执行后，c的值是（ ） int a=3,b=4,c=0; while ((a++)&lt;(–b))++c; A.0 B.1 C.2 D.3 正确答案是: A \\8. 下列语句序列执行后，a的值是（ ） int a=1; for(int i=5;i&gt;0;i-=2) a*=i; A.0 B.1 C.15 D.60 正确答案是: C \\9. 下列语句序列执行后，c的值是（ ） int a=10,b=18,c=30; switch(b-a){ case 8 : c++; case 9 : c+=2; case 10 : c+=3; default :c/=b; } A.31 B.32 C.2 D.33 正确答案是: C \\10. 设a、b为int型变量，c、d为fload类型变量，ch为char类型变量，且所有变量均已赋值，则下列正确的switch语句是（ ） A.switch(a+b);{…} B.switch(ch+1){…} C.switch ch {…} D.switch(c+d){…} 正确答案是: B \\11. 下列语句序列执行后，c的值是（ ） int a=4,b=5,c=9,d=6; if (a&gt;b||c&lt;d) c–; else c++; A.6 B.10 C.8 D.9 正确答案是: B \\12. 下列语句序列执行后，c的值是（ ） int a=6,b=3,c=5; if (a==b) c+=a;else c=++a*c; A.15 B.25 C.35 D.45 正确答案是: C \\13. 下列语句序列执行后，c变量的值为（ ） int a=2,b=4,c=5; if (a&lt;–b) c*=a; A.5 B.20 C.15 D.10 正确答案是: D \\14. 下列语句序列执行后，ch1变量中的值为（ ） char ch1=’A’,ch2=’B’; if (ch1+2&lt;ch2)++ch1; A.’A’ B.’B’ C.A D.B 正确答案是: A \\15. 以下选项中，合法的赋值语句是（ ） A.++m!=n–; B.++m; C.m=m+1=5; D.m==1; 正确答案是: B \\16. 设有定义“int a=22;long b=56;”，下面赋值不正确的语句是（ ） A.a=b; B.b=(long)a; C.a=(int)b; D.b=a; 正确答案是: A \\17. 下面选项中，（ ）是正确的输出结果 int m=2,n=1; m+=m-=n; System.out.println(“m=”+m); A.m=1 B.m=2 C.m=3 D.m=4 正确答案是: C \\18. 下列语句序列执行后的结果为（ ） int a=10,b=4,c=20,d=6; System.out.println(a++b+c–d); A.144 B.140 C.28 D.不能执行 正确答案是: B \\19. 假设以下选项中的变量都已经正确定义，则不合法的表达式是（ ） A.a&gt;4==6&lt;1; B.’n’-3; C.’a’=8; D.’A’%6 正确答案是: C \\20. 假设a为已经声明并以赋初值的int类型变量，则对于a的赋值语句正确的是（ ） A.int a=6; B.a==3; C.a=3.2f; D.a+=a*3; 正确答案是: D 编程题得分：401.打印每月有几天 得分：10 / 101234567891011121314151617181920212223242526272829import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123; public static boolean isYeap(int year) &#123; if ( year%4==0 &amp;&amp; year%100 != 0 ) return true; if (year%400 == 0) return true; return false; &#125; public static void main(String []args) &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); int b = s.nextInt(); int yeap[] = &#123;31,29,31,30,31,30,31,31,30,31,30,31&#125;; int noyeap[] = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; if ( isYeap(a) ) System.out.println(\"\"+a+\"-\"+b+\"-\"+yeap[b-1]+\"\"); else System.out.println(\"\"+a+\"-\"+b+\"-\"+noyeap[b-1]+\"\"); &#125;&#125; 4-3-2 百分制成绩转换等级制成绩 得分：10 / 101234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123;public static void main(String []args) &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); if ( a&lt;0 || a &gt; 100) System.out.printf(\"Error input\\n\"); else &#123; int REa = a/10; switch (REa) &#123; case 6: System.out.printf(\"%d -- %c\\n\",a,'D'); break; case 7: System.out.printf(\"%d -- %c\\n\",a,'C'); break; case 8: System.out.printf(\"%d -- %c\\n\",a,'B'); break; case 9: case 10: System.out.printf(\"%d -- %c\\n\",a,'A'); break; default: System.out.printf(\"%d -- %c\\n\",a,'E'); &#125; &#125; &#125; &#125; 用if语句求解分段函数 得分：10 / 101234567891011121314151617181920import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123;public static void main(String []args) &#123; Scanner s = new Scanner(System.in); double a = s.nextDouble(); double b=0; if (a&lt;20) b=a+100; else if ( a&gt;100 ) b=a-100; else b=a; System.out.printf(\"x=%.2f,y=%.2f\\n\",a,b); &#125; &#125; 2-2 混合类型数据格式化输入 得分：10 / 1012345678910111213141516171819import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123;public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); double d1 = s.nextDouble(); int i = s.nextInt(); String ss = s.next(); char ch = ss.charAt( 0 ); double d2 = s.nextDouble(); System.out.printf(\"%c %d %.2f %.2f\",ch,i,d1,d2); &#125; &#125; 3-4-1a 计算三位数的位数和 得分：10 / 1012345678910111213141516171819202122import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123;public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int n = s.nextInt(); int sum = 0; if ( n &lt; 0) n = -n; // 保证绝对值 while(n!=0) &#123; int left = n%10; sum += left; n/= 10; &#125; System.out.printf(\"%d\\n\",sum); &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Linux下开机启动Python脚本","slug":"Linux下开机启动Python脚本","date":"2019-03-03T11:48:46.000Z","updated":"2019-06-01T11:17:57.397Z","comments":true,"path":"2019/03/03/Linux下开机启动Python脚本/","link":"","permalink":"https://nymrli.top/2019/03/03/Linux下开机启动Python脚本/","excerpt":"","text":"/etc/rc.local将脚本写在/etc/rc.local文件输入命令：sudo vi /etc/rc.local在exit 0上一行输入：python /usr/bin/python /home/pi/test.py重启就可以看效果sudo reboot 当然，rc.local 文件需要有执行权限（默认没有）$ sudo chmod +x /etc/rc.local对于命令，最好是先which python查出命令路径，写命令时写绝对路径 /etc/init.d写一个服务放到linux的/etc/init.d目录中 并且授权bash脚本chmod 755 /etc/init.d/mypython 1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin/bash# chkconfig: 2345 66 36# /etc/rc.d/init.d/opt/python# description: spython#case \"$1\" in start) echo -n \"Starting python: \" echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python date +\"! %T %a %D : Starting python .\" &gt;&gt;/var/log/python echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python echo start cd /root/finmonAgent/bin ./finmonAgent.py &amp; #sh /root/finmonAgent/startpy echo \"Done.\" echo \"\" echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python date +\"! %T %a %D : Finished.\" &gt;&gt;/var/log/python echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python touch /var/lock/subsys/python ;; stop) echo -n \"Shutting Down python Listeners: \" echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python date +\"! %T %a %D : Shutting Down python.\" &gt;&gt;/var/log/python echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python echo \"python\" killall -9 finmonAgent.py echo \"Done.\" rm -f /var/lock/subsys/python echo \"Done.\" echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python date +\"! %T %a %D : Finished.\" &gt;&gt;/var/log/python echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python ;; *) echo \"Usage: python &#123; start | stop | restart &#125;\" exit 1esacexit 0 /ect/profile /ect/profile 文件是系统默认的主启动文件，系统上每个用户登录时都会执行； linux 配置文件（启动文件、环境文件）启动顺序1、登录shell登录shell时，linux会按一定规则读取启动几个配置文件： /ect/profile $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile 其中 /ect/profile 文件是系统默认的主启动文件，系统上每个用户登录时都会执行； a、命令行登录和ssh登录，shell会按照以下顺序，运行第一个被找到的文件，余下的会被忽略： $HOME/.bash_profile $HOME/.bash_login $HOME/.profile 上面没有 $HOME/.bashrc ，因为该文件一般通过其他文件运行。 b、图形界面登录，只加载 /ect/profile和$HOME/.profile，其他的会被忽略。 对于 no-login shell，即图形界面打开的shell，只会读入 $HOME/.bashrc 文件，不会检查 /etc/.profile 等其他登录shell文件。 2、交互式shell不是登录系统时启动，提供命令行提示符来输入命令。（不会访问 /etc/profile 文件，会检查 $HOME/.bashrc 文件） 3、非交互式shell系统执行脚本时所用，没有命令行提示符。 linux将指令加入开机启动或加入环境变量（2）在profile中添加PATH，这种方法对所有用户都是永久生效。 a）打开profile文件 1`vim /etc/profile` b）在profile文件的PATH中添加mongo指令。在PATH后面添加“:/usr/local/webserver/mongo/bin”，＝ 等号两边不能有任何空格。 1`PATH=``$PATH``:/usr/local/webserver/mongo/bin` c）执行指令，使profile修改立即生效。 1`source profile` （3）在当前profile中添加PATH，这种方法对当前用户永久生效。与第二步类似，将profile替换为bash_profile。 1`vim ~/.bash_profile` 1`PATH=``$PATH``:/usr/local/webserver/mongo/bin` 1`source ~/.bash_profile` 2，linux将指令加入开机启动 在/etc/rc.local中添加指令即可 1`/usr/local/webserver/mongodb/bin/mongod --dbpath=/data0/mongodb/data --logpath=/data0/mongodb/logs --logappend --port=27017`","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"codeblocks中boost库安装","slug":"codeblocks中boost库安装","date":"2019-03-03T11:04:59.000Z","updated":"2019-03-03T11:41:42.704Z","comments":true,"path":"2019/03/03/codeblocks中boost库安装/","link":"","permalink":"https://nymrli.top/2019/03/03/codeblocks中boost库安装/","excerpt":"","text":"首先要提出的是，boost在VS中是可以直接导入的，但是在CB中是不行的，所以写了下这篇文章。 安装boost1.首先先去boost官网下载boost的源码 ， 选择你要下载的版本。 2.解压（可能会耗费一段时间，小文件比较多） 3.双击运行脚本文件bootstrap.bat（引导程序），之后就生成这两个可执行文件 我们为了能直观的看到编译boost的细节信息，进入dos (win +ｒ快捷键 输入cmd ) 4.cd 到解压boost库的目录下 5.命令执行bjam.exe 4-5是没必要的，要是不想看输出的东西的话，其实双击bjam.exe即可 ▲.编译的时间略久（你可以干一会其他事，喝个茶） 注: 安装boost貌似需要VS的某个模块，一开始在活动室电脑上装由于没有VS，所以没装成，最后在自己的电脑上装好的。 codeblocks设置点击settings，选择下拉菜单中的 compiler选项 注意这里选择Search directories第三项 最下面有一个add按钮，点击将boost解压路径添加即可。 之后你可以随便写一点程序进行测试 12345678910#include &lt;boost/lambda/lambda.hpp&gt;#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;int main()&#123; using namespace boost::lambda; typedef std::istream_iterator&lt;int&gt; in; std::for_each( in(std::cin), in(), std::cout &lt;&lt; (_1 * 3) &lt;&lt; \" \" );&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"ACM_线性筛","slug":"ACM-线性筛","date":"2019-03-03T08:57:36.000Z","updated":"2019-04-26T12:27:57.350Z","comments":true,"path":"2019/03/03/ACM-线性筛/","link":"","permalink":"https://nymrli.top/2019/03/03/ACM-线性筛/","excerpt":"","text":"什么是线性筛? 筛素数是为了求得一个区间内的所有素数，而把不是素数的筛去。 最普通的办法——判断一个数是不是素数 123456789101112131415161718#define SIZE 1000000int main()&#123; int check[SIZE]; int prime[SIZE] = &#123;0&#125;; int pos; int flag; for (int i = 2 ; i &lt; SIZE ; i++)&#123; flag = 1; for (int j = 2 ; j &lt; sqrt(i) ; j++)&#123; if (i % j == 0) flag = 0; &#125; if (flag == 1) prime[pos++] = i; &#125; printf(\"%.2f\", (double)clock()/CLOCKS_PER_SEC); return 0;&#125; 普通筛素数——将不是素数的筛掉123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;#define SIZE 1000int main()&#123; int checked[SIZE] = &#123;0&#125;; // 如果是1的话就是合数 int prime[SIZE] = &#123;0&#125;; int pos = 0; int i,j; for( i = 2;i &lt; SIZE ; i++)&#123; if ( ! checked[i] )&#123; prime[pos++] = i; &#125; for( j = 2*i; j &lt; SIZE ; j += i ) checked[j] = 1; &#125; for( i = 0;i&lt; SIZE ; i++) if (prime[i] == 0)&#123; cout &lt;&lt; i-1 &lt;&lt; endl; // 素数的个数 break; &#125; return 0;&#125;// output : 168 普通筛素数 基本思想 一次循环筛掉当前素数的倍数 缺点 存在重复筛选，比如6既可以被2筛掉，又可以被3筛掉。 原因：任意一个整数可以写成一些素数的乘积 $n=p_{1}^{a} p_{2}^{b} p_{3}^{c}​$，其中$p1&lt;p2&lt;p3​$，这样这个数n就能被p1,p2和p3筛掉 解决方法：按照一个数的最小素因子筛去(也就是这里的p1)就可以啦，这也就有了线性筛素数 线性筛素数123456789101112131415161718192021222324252627282930313233#define SIZE 1000int main()&#123; int check[SIZE] = &#123;0&#125;;//元素值为0代表是素数 int prime[SIZE] = &#123;0&#125;; int pos=0; int flag; for (int i = 2 ; i &lt; SIZE ; i++)&#123; if (!check[i])//如果是素数 prime[pos++] = i; // ★.区别在于此 for (int j = 0 ; j &lt; pos &amp;&amp; i*prime[j] &lt; SIZE ; j++)&#123;/* cl觉得可以写成for (int j = 0 ; i*prime[j] &lt; SIZE ; j++)j &lt; pos 是多余的,如果i是个素数,比如7,那么prime[x]=7,当j=x的时候必然有if (i % prime[j] == 0), 此时x=pos - 1如果是个合数,比如15,那么肯定有最小素因子使得(i % prime[j] == 0),此时j &lt; pos 如果i是个偶数,比如8,那么if (i % prime[j] == 0) 此时在2的时候就退出了。j=0 &lt; pos2019-4-26 j&lt;pos不能删,这个是主要控制j取值的大小的因素,控制取出的都是已知的素数*/ check[i*prime[j]] = 1;//筛掉 //标注一 // 通过这步可以找到最小素数因子, // 比如12,那么 prime[j] 最先== prime[0] == 2 , 即找到了最小的因子2, // 那12就不是个素数,就不用再判断它是不是能被3合成 if (i % prime[j] == 0) break; &#125; &#125; printf(\"%.2f\", (double)clock()/CLOCKS_PER_SEC); return 0;&#125; 基本思想 当前数字是$n=p_{1}^{a} p_{2}^{b} p_{3}^{c}​$(p1&lt;p2&lt;p3且均为素数)，一次循环筛除小于等于p1的素数乘以n得到的数。比如p1之前有pi,pj和pk三个素数，则此次循环筛掉pi*n,pj*n,pk*n和p1*n ，实现见代码的标注一，prime 里的素数都是升序排列的，break时的prime[j] 就是这里的p1。 优点：没有重复筛同一个数 原因：按照一个数的最小素因子筛选，比如6只按2筛去 从图上我们看到，第一列筛掉的是最小素因子是2的数，第二列筛掉的是最小素因子为3的数，第三列最小素因子是prime[2]==5 ，依次类推，可以把所有的合数都筛掉。 由于每列筛掉的合数都是 它自身的平方 ， 即 一个素数最小的因子除了1就是它本身， 所以 素数的平方的最小素因子就是 它本身 ， 而通过i % prime[j] == 0就可以控制不多筛。 因为是按照最小素因子筛选，所以可以保证每个数都只会被筛一遍 ==&gt; 18--9x2 摘自：这只菜鸟总算搞懂了线性筛素数 素数的判别挺有意思的，剪枝的方法可以见我的另一篇博客 : 素数判别","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"线性筛","slug":"线性筛","permalink":"https://nymrli.top/tags/线性筛/"}]},{"title":"flask+nginx如何获得真实IP","slug":"flask-nginx如何获得真实IP","date":"2019-03-02T12:53:58.000Z","updated":"2019-03-02T13:00:42.787Z","comments":true,"path":"2019/03/02/flask-nginx如何获得真实IP/","link":"","permalink":"https://nymrli.top/2019/03/02/flask-nginx如何获得真实IP/","excerpt":"","text":"如果是通过 flask 的 request.remote_addr获取的 ip 都是 127.0.0.1 解决方案:nginx.conf中添加123# proxy_set_header Host $host:80; # proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 全文 12345678910111213141516server &#123; listen 8888; server_name 0.0.0.0; charset utf-8; client_max_body_size 75M; location /static&#123; alias /home/apollo3d/Documents/Cl/webenv/.../static; &#125;location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8889; uwsgi_param UWSGI_SCRIPT app:app; # 启动flask的文件:Flask的实例 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; Python代码1234if request.headers.getlist(&quot;X-Forwarded-For&quot;): ip = request.headers.getlist(&quot;X-Forwarded-For&quot;)[0]else: ip = request.remote_addr 查自:V2EX 拓展:X-Forwarded-For 可能会有多个 IP ，如果浏览器使用了代理的话正确的做法应该是抓 X-Real-IP，或者分隔 X-Forwarded-For取第 1 个值","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"nginx","slug":"nginx","permalink":"https://nymrli.top/tags/nginx/"}]},{"title":"frp结合nginx实现内网web服务和tcp的转发","slug":"frp结合nginx实现内网web服务和tcp的转发","date":"2019-03-02T10:48:23.000Z","updated":"2019-03-18T04:56:10.636Z","comments":true,"path":"2019/03/02/frp结合nginx实现内网web服务和tcp的转发/","link":"","permalink":"https://nymrli.top/2019/03/02/frp结合nginx实现内网web服务和tcp的转发/","excerpt":"","text":"服务端 - 阿里云服务器: Ubuntu 16.04 客户端 - 活动室电脑 : Ubuntu 16.04 配置server端1$ sudo vim frps.ini 1234[common] #必须有的配置段，在frpc.ini和frps.ini中都必须要有bind_port = 7000 #服务端服务的监听端口vhost_http_port = 16666 #自己设定的http访问端口vhost_https_port = 17777 #自己设定的https访问端口 保存并且退出，使用如下服务命令启动frps服务 1$ nohup ./frps -c ./frps.ini &amp; client端:1$ sudo vim frpc.ini 1234567891011121314[common] #必须有的配置段，在frpc.ini和frps.ini中都必须要有server_addr = x.x.x.x #服务端的公网IP（外网IP）server_port = 7000 #服务端服务的监听端口[web] #自己定义的服务转发标签（自定义，非严格）type = http #定义转发类型为http（严格）local_port = 8800 #定义所需要转发的本地web服务的端口为8800,跟nginx设置的一致custom_domains = node1.xxx.com #定义访问转发服务的域名（确保使用该域名访问可以解析到有公网IP的服务端）[ssh] #自己定义的服务转发标签（自定义，严格）type = tcp #定义转发类型为tcp（严格）local_ip = 127.0.0.1 #由于转发代理的ssh服务在本地，因此填写本地地址local_port = 22 #ssh服务本地的监听端口remote_port = 6000 #实际开启ssh时连接时访问的端口 1$ nohup ./frps -c ./frps.ini &amp; 解释说明1234[common]中的server_addr填frp服务端的ip（也就是外网主机的IP），server_port填frp服务端的bind_prot(s和c必须一致)。[web]中，type转发类型为http，local_port填转发的web端口，custom_domains 填 能够使用的域名.说到这里，域名解析，服务端建议使用阿里云，直接填写A记录，三级子域名专门申请几个，备用.类似：node1.xxx.com、node2.xxx.com、node3.xxx.com 阿里云设置A记录: 一开始以为一个IP不能写多个A记录，后来发现是可以的。如下 这里还要注意几点： 1234[web]上下文中，凡是type类型为http或者同一个类型，custom_domains中填写的域名必须为不同的域名，相同域名会报错不同类型的type，例如[test]中的type类型为tcp，则可以使用相同域名简单来说type类型相同，不能使用同一个域名type类型不同，可以使用相同的域名。 测试和访问web服务访问格式为：域名+端口,具体如下:123http://node1.xxx.com:16666 页面转到内网客户端使用nginx反向代理的web服务8800http://node2.xxx.com:16666 页面转到内网客户端使用nginx反向代理的web服务8801http://node3.xxx.com:16666 页面转到内网客户端本地的web服务端口8088 ▲当然要记得去阿里云的防火墙将16666端口打开才行， 然后我测试了一下，通过IP访问好像是不行的，域名:port是可以的 ssh服务远程和连接12ssh -Port=6000 username@x.x.x.x注：x.x.x.x为服务端的公网IP 摘自：https://www.jianshu.com/p/0c49556e8e15 附录一个Server,多个Client配置服务器端的配置都是一样的，只需要在新添加的客户端上修改frpc.ini 1234567891011121314[common] #必须有的配置段，在frpc.ini和frps.ini中都必须要有server_addr = x.x.x.x #服务端的公网IP（外网IP）server_port = 7000 #服务端服务的监听端口[web_3] #▲自己定义的服务转发标签（自定义，非严格）type = http #定义转发类型为http（严格）local_port = 8800 #定义所需要转发的本地web服务的端口为8800,跟nginx设置的一致custom_domains = node2.xxx.com #▲定义访问转发服务的域名（确保使用该域名访问可以解析到有公网IP的服务端）[ssh_3] #▲自己定义的服务转发标签（自定义，严格）type = tcp #定义转发类型为tcp（严格）local_ip = 127.0.0.1 #由于转发代理的ssh服务在本地，因此填写本地地址local_port = 22 #ssh服务本地的监听端口remote_port = 8000 #▲实际开启ssh时连接时访问的端口 ▲1.注意上述有▲的地方，就是修改的地方，这个配置信息的头每个客户端必须不一样。即[web_3]与[web]不一样。 ▲2.SSH的话：每个客户端要配置进入ssh的端口 , 比如x.x.x.x:6000进入1号,x.x.x.x:8000进入二号 ▲3.WEB服务的话：每个客户端要配置进入web的域名 , 比如a.nymrli.top:8888进入1号,b.nymrli.top:8888进入二号","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"构造一个能发数据的POST请求头","slug":"构造一个能发数据的POST请求头","date":"2019-03-01T14:23:52.000Z","updated":"2019-03-02T03:38:31.153Z","comments":true,"path":"2019/03/01/构造一个能发数据的POST请求头/","link":"","permalink":"https://nymrli.top/2019/03/01/构造一个能发数据的POST请求头/","excerpt":"","text":"之前学请求、响应的时候只是过了一边，大致知道有这些东西。但这次真正要用的时候却又忘了到底该如何写，错误的请求头、请求体的格式导致esp8266一直发送不了数据到服务器上，又重新看了遍请求request的知识，才终于搞明白 请求最初的写法:由于在esp8266上已经选择、连接好了了httpbin.org的穿透，就以为Host可以不用加了，于是产生了 最初的写法： 1POST /post?= HTTP/1.1 ▲根据玩单片机的小伙伴说必须多出一行\\r\\n，所以这边是有一行空行的 结果： 400 BAD_REQUEST搜索过后得知 : 如果使用http 1.1协议的话主机名HOST字段是必须的 第二次写法:12POST /post?= HTTP/1.1 Host:httpbin.org 可以注意到的是Host是顶层域名，/post只是其中的一个路由 结果: 成功，这样就算可以正常发送post请求了于是下一步就是研究如何上传数据 第三次写法：123POST /post?= HTTP/1.1Host: httpbin.orgtempt=57 于是这次都没有返回值了. 想起了表单是有形式的，于是添加了 Content-Type: application/x-www-form-urlencoded 这个形式的参数应该写成a=1&amp;b=..&amp;.. 注.如果请求网页的表单中没设置 enctype 属性，那么最终就会默认以 application/x-www-form-urlencoded 方式提交数据。 如果是Content-Type: application/json 则改写成{&#39;a&#39;:1 , &#39;b&#39;=.. , ...} multipart/form-data，我们使用表单上传文件时，必须让 form 的 enctyped等于这个值，请求示例 12345678910111213POST http://www.example.com HTTP/1.1 Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=&quot;text&quot; title ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot; Content-Type: image/png PNG ... content of chrome.png ... ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 说明: 首先生成了一个boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以mutipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。关于 mutipart/form-data的详细定义，请前往 rfc1867 查看。 text/xml，XML-RPC 是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的： 123456789101112POST http://www.example.com HTTP/1.1 Content-Type: text/xml &lt;!--?xml version=&quot;1.0&quot;?--&gt; &lt;methodcall&gt; &lt;methodname&gt;examples.getStateName&lt;/methodname&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/params&gt; &lt;/methodcall&gt; 但是虽然能接受到返回的结果，但是响应数据中发现form一直是空的，那就是参数没传过去，于是想到是不是格式的错误 第四次写法后来上网找寻了一下结果发现我遗漏了模板中的\\r\\n\\r\\n这行，即请求头 和 请求体 之间至少有一行换行！！！ 12345POST /get HTTP/1.1Content-Type: application/x-www-form-urlencodedConnection:closea=23&amp;b=34 中间的空行不能省略 ， 这样httpbin.org那边才不返回 ERROR或是BAD_REQUEST 但是数据还是发送不出 于是咨询了qk大佬以后，才发现原来请求头也必须要加上Content-Length:8….. 最终完成版123456POST /get HTTP/1.1Content-Type: application/x-www-form-urlencodedConnection:closeContent-Length:8a=23&amp;b=34 哎….本来很简单的事，竟然弄了一个多小时才搞定，真只能怪自己学艺不精了。幸好的是，还是调出来了。 附录:HTTP请求报文解剖 :组成HTTP请求报文由3部分组成（请求行+请求头+请求体）： 内容 格式 HttpWatchHttpWatch是强大的网页数据分析工具，安装后将集成到Internet Explorer工具栏中。它不用代理服务器或一些复杂的网络监控工具，就能抓取请求及响应的完整信息，包括Cookies、消息头、查询参数、响应报文等，是Web应用开发人员的必备工具。 摘自HTTP请求行、请求头、请求体详解","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"为了不跑操而Excel——Orz","slug":"为了不跑操而Excel——Orz","date":"2019-03-01T07:45:07.000Z","updated":"2019-05-27T13:49:20.739Z","comments":true,"path":"2019/03/01/为了不跑操而Excel——Orz/","link":"","permalink":"https://nymrli.top/2019/03/01/为了不跑操而Excel——Orz/","excerpt":"","text":"为了不跑操而Excel——Orz3月1日Excel 15、16、17、18级分类——筛选、开头是（?15通配符）、制不同表 获得50m、800-1000m、身高、肺活量……各年级数据和总的平均值 有的单元框内容虽然看上去像数字(数值靠右)，但其实是文本(文本靠左)，需要做处理后才能进行公示计算——分列 复杂的重复公示最好还是指明地址 翻到下一个非空单元格——Ctrl + ↓ 或 ↑ 3月4日文字排版不支持竖版，所以弄成图片后发布的 4月28日图片排版,体育部的网站支持源代码修改,因此可以修改html代码. 123456789101112131415161718192021&lt;table cellspacing=\"100\" cellpadding=\"20\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; &lt;img data-layer=\"photo\" src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/20a324aa-c891-4be2-9174-590277bff71d.jpg\" original-src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/20a324aa-c891-4be2-9174-590277bff71d_d.jpg\" sudyfile-attr=\"&#123;'title':'webwxgetmsgimg (1).jpg'&#125;\" width=\"600\" height=\"400\" border=\"0\" hspace=\"0\" vspace=\"0\" style=\"width:600px;height:400px;\" /&gt; &lt;/td&gt; &lt;td&gt; &lt;img data-layer=\"photo\" src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/c9fdcc12-a3e5-422e-b4cb-ac6c5ecd9e64.jpg\" original-src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/c9fdcc12-a3e5-422e-b4cb-ac6c5ecd9e64_d.jpg\" sudyfile-attr=\"&#123;'title':'webwxgetmsgimg (2).jpg'&#125;\" style=\"font-size:14px;width:600px;height:400px;\" width=\"600\" height=\"400\" border=\"0\" hspace=\"0\" vspace=\"0\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img data-layer=\"photo\" src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/67108b99-b0f6-42bf-aac4-a6e012e7e66d.jpg\" original-src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/67108b99-b0f6-42bf-aac4-a6e012e7e66d_d.jpg\" style=\"width:600px;height:400px;\" sudyfile-attr=\"&#123;'title':'webwxgetmsgimg (3).jpg'&#125;\" width=\"600\" height=\"400\" border=\"0\" hspace=\"0\" vspace=\"0\" /&gt; &lt;/td&gt; &lt;td&gt; &lt;img data-layer=\"photo\" src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/69659dd8-a9a2-424f-bdb7-324c1807af18.jpg\" original-src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/69659dd8-a9a2-424f-bdb7-324c1807af18_d.jpg\" sudyfile-attr=\"&#123;'title':'webwxgetmsgimg (4).jpg'&#125;\" width=\"600\" height=\"400\" border=\"0\" hspace=\"0\" vspace=\"0\" style=\"width:600px;height:400px;\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;","categories":[],"tags":[{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Flask 本地局域网连接","slug":"Flask-本地局域网连接","date":"2019-02-28T10:43:55.000Z","updated":"2019-02-28T10:56:37.424Z","comments":true,"path":"2019/02/28/Flask-本地局域网连接/","link":"","permalink":"https://nymrli.top/2019/02/28/Flask-本地局域网连接/","excerpt":"","text":"之前都是在活动室的电脑上配好web环境，但其实发现很多比赛只要截图就够了。所以这次看了下能不能用局域网访问。一查果然flask可以通过局域网进行访问 - 使用pycharm的朋友要这样设定1.run-&gt;Edit Configurations 2.Additional options 3.运行run（Ctrl+shift+F10）即可注:如果没有这样设定 pycharm启动 是不会有作用的（就像这样）地址依旧会是127.0.0.1 - 查看自己的IP地址1.命令行方式cmd-&gt;ipconfig-&gt;IPv4 2.查网络与共享中心打开端口如果还不行的话就可能是 端口没有打开 解决方案: 开始中搜索 windows防火墙 ， 这样就大功告成了！ 然后通过 局域网IP：PORT就可以访问到网页啦","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"eclipse使用","slug":"eclipse使用","date":"2019-02-26T05:18:25.000Z","updated":"2019-02-26T06:11:23.464Z","comments":true,"path":"2019/02/26/eclipse使用/","link":"","permalink":"https://nymrli.top/2019/02/26/eclipse使用/","excerpt":"","text":"Eclipse选择工作路径 新建工程一.选择File-&gt;New-&gt;Project 二.Java-&gt;Java Project 三.工程配置 这步可以选择创建或者不创建，目前都没有什么影响 四.是否打开导航视图窗口 此类项目与Java透视图相关联。 此透视图旨在支持Java开发。它提供了包资源管理器、类型层次结构和特定于java的导航操作。 您现在想打开这个透视图吗? 如果按了create的话，就会产生该文件 ▲注意 一个工作空间中只能有一个工程有main 五.新建class 编写第一个程序123456// package java;public class hello &#123; public static void main(String []args) &#123; System.out.println(\"Hello World\"); &#125;&#125; 如果编写完成后，选择工具栏的运行。如果运行按钮无法按下、或按下无效，请检查代码。 类名是否和文件名一致（在IDE下应该不会产生这样的问题） main是否写对 String []args要写上,不能缺省 注意 . 如果发生错误 ， 会产生如下弹窗 ， 此时应该再次检查语法 附录自动添加注释一、新建class时自动添加注释windows–&gt;preference进入选项卡。然后选择Java–&gt;Code Style–&gt;Code Templates，如图： 按下Edit，然后添加一行@(随意) ${date}即可，${date}为固定的宏，大小写写错无效 保存配置后，选中类，使用快捷键alt＋shift+j可以快速添加注释。 新建类自动添加注释选择Code Templates选项卡内的Code—&gt;New Java files，编辑它。 123456789$&#123;filecomment&#125;$&#123;package_declaration&#125;/*** @author 作者* @version 创建时间：$&#123;date&#125; $&#123;time&#125;* 类说明*/$&#123;typecomment&#125;$&#123;type_declaration&#125; 注释内容摘自eclipse自动添加作者、日期等注释","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"IDE","slug":"IDE","permalink":"https://nymrli.top/tags/IDE/"}]},{"title":"南京邮电大学java程序设计作业在线编程第二次作业","slug":"南京邮电大学java程序设计作业在线编程第二次作业","date":"2019-02-26T04:52:41.000Z","updated":"2019-02-26T05:43:26.410Z","comments":true,"path":"2019/02/26/南京邮电大学java程序设计作业在线编程第二次作业/","link":"","permalink":"https://nymrli.top/2019/02/26/南京邮电大学java程序设计作业在线编程第二次作业/","excerpt":"","text":"总分：100选择题得分：60 \\1. 表达式9==8&amp;&amp;3&lt;7的运算结果是（ ） A.1 B.0 C.true D.false 正确答案是: D \\2. 表达式(3&gt;2)?8:9的运算结果是（ ） A.3 B.2 C.8 D.9 正确答案是: C \\3. 表达式9-7&lt;0||11&gt;8的运算结果（ ） A.true B.false C.1 D.0 正确答案是: A \\4. 表达式48%9+5*5-4的运算结果（ ） A.24 B.26 C.-30 D.46 正确答案是: A \\5. 表达式2&gt;=5的运算结果是（ ） A.2 B.5 C.true D.false 正确答案是: D \\6. 表达式15+4*5-12的运算结果是（ ） A.15 B.23 C.12 D.-133 正确答案是: B \\7. 以下（ ）不属于复合类型的数据类型 A.类 B.字符型 C.数组 D.接口 正确答案是: B \\8. 在Java中，不属于整数类型的是（ ） A.double B.long C.int D.byte 正确答案是: A \\9. 下列变量定义中，（ ）是错误的 A.float x;y; B.float x,y=3.14f; C.public int i=100,j=2,k; D.int i=100;int j=200; 正确答案是: A \\10. 以下选项中，（ ）能正确表示Java语言中的一个整型常量。 A.-8.0 B.1,000,000 C.-30 D.”456” 正确答案是: C \\11. 下面程序段执行后的结论是（ ）int m=2,n=2; m+=m-=m*m; n-=n*n; n=n+n; A.m=n B.m&gt;n C.m&lt;n D.m与n类型不同，不能比较 正确答案是: B \\12. 执行下列程序段： int no; int a=19,b=8; no=(a%b&gt;5)?a+b:a-b; System.out.println(no);输出结果是： A.2 B.9 C.11 D.27 正确答案是: C \\13. 下列语句执行后的输出结果是：( ) int e=Integer.parseInt(&quot;&quot;+3+3); System.out.println(e-2.5); A.30.5 B.3.5 C.332.5 D.8.5 正确答案是: A \\14. 定义a为int类型的变量并且已被赋初值，则合法的赋值语句是（ ） A.a+1==4; B.a+=a*8; C.a=6.6f; D.int a=18; 正确答案是: B \\15. 设m、n、x、y为已赋值的int变量，下列（ ）的运算结果属于非逻辑值。 A.m!=n&amp;x%y&lt;m B.m++==m+n+x+y C.++m*b–+y D.m+n&gt;=x+y 正确答案是: C \\16. 以下选项中的变量都已经正确定义并且赋初值，不合法的表达式是（ ） A.m &gt;= 6 == n &gt; 1 B.’m’ + 6 C.’m’ = 8 D.’M’ % 8 正确答案是: C \\17. 以下标识符中，（ ）是不合法的 A.inter_net B.i_nong C.Helo D.*member 正确答案是: D \\18. 以下字符常量中不合法的是（ ） A.’#’ B.’&amp;’ C.”P” D.’囧’ 正确答案是: C \\19. 下面（ ）是Java数据类型中int类型的取值范围。 A.-27~27-1 B.0~216-1 C.-215-215-1 D.-231~231-1 正确答案是: D \\20. 在Java语言中，下面（ ）类型可以表示整数基本数据类型。 A.single B.byte C.double D.char 正确答案是: B 编程题得分：402-1 是不是太胖了 得分：10 / 1012345678910import java.util.Scanner;public class Main &#123; public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int height = scanner.nextInt(); double result = (height-100)*0.9*2; System.out.printf(\"%.1f\\n\" , result); &#125; &#125; 2-2 Say hello to integers 得分：10 / 101234567891011import java.util.Scanner;public class Main &#123; public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int one = scanner.nextInt(); int two = scanner.nextInt(); System.out.printf(\"Hello, %d and %d!\\n\" ,one,two); //System.out.println( \"Hello, \"+one+\" and \"+two+\"!\"); &#125; &#125; 2-3 求整数的平均值 得分：10 / 1012345678910111213import java.util.Scanner;public class Main &#123; public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int one = scanner.nextInt(); int two = scanner.nextInt(); int thr = scanner.nextInt(); int four = scanner.nextInt(); int sum = one+two+thr+four; System.out.printf(\"Sum=%d;Average=%.1f\\n\" ,sum,sum/4.0); &#125; &#125; 2-4 整数四则运算 得分：10 / 10123456789101112131415161718import java.util.Scanner;public class Main &#123; /** * @author Mr.li * @param args */ public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(); int b = scanner.nextInt(); System.out.printf(\"%d+%d=%d\\n\" , a,b,a + b); System.out.printf(\"%d-%d=%d\\n\" , a,b,a - b); System.out.printf(\"%d*%d=%d\\n\" , a,b,a * b); System.out.printf(\"%d/%d=%d\\n\" , a,b,a / b); // System.out.println(a+\"+\"+b+\"=\"+(a+b)); &#125; &#125; 2-3 华氏温度转换摄氏温度 得分：10 / 10123456789import java.util.Scanner;public class Main &#123; public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int Ftem = scanner.nextInt(); int Ctem = 5*(Ftem-32)/9; System.out.printf(\"Celsius=\"+Ctem+\"\" ); &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"南京邮电大学java程序设计作业在线编程第一次作业","slug":"南京邮电大学java程序设计作业在线编程第一次作业","date":"2019-02-26T04:50:14.000Z","updated":"2019-02-26T04:52:29.933Z","comments":true,"path":"2019/02/26/南京邮电大学java程序设计作业在线编程第一次作业/","link":"","permalink":"https://nymrli.top/2019/02/26/南京邮电大学java程序设计作业在线编程第一次作业/","excerpt":"","text":"总分：100选择题得分：40 \\1. Java语言中，基本数据类型一共有（ ）种。 A.16 B.2 C.4 D.8 正确答案是: D \\2. Java虚拟机的英文缩写是（ ） A.JRE B.ECLIPSE C.JVM D.JDK 正确答案是: C \\3. Java程序中，最常见的对主方法的定义是（ ）。 A.private static int main(String args[ ]){ } B.public static void main(String args[ ]){ } C.public static int main(char args[ ]){ } D.private static void main(char args[ ]){ } 正确答案是: B \\4. Java源程序的文件名必须和程序中（ ）的名字相同。 A.公共类 B.主函数 C.主程序 D.主方法 正确答案是: A \\5. Java语言字节码文件的后缀名为（ ）。 A..byte B..bit C..class D..java 正确答案是: C \\6. Java语言源程序的文件后缀是（ ）。 A..j B..ja C..jav D..java 正确答案是: D \\7. Java语言中实现将源代码转换成字节码文件的过程，被称为（ ）。 A.翻译 B.编译 C.解释 D.汇编 正确答案是: B \\8. 下列哪一种语言不支持面向对象的编程思想？ A.C B.C++ C.Java D.Python 正确答案是: A 编程题得分：60 1-3 输出What is a computer?得分：10 / 10 12345public class Main &#123; public static void main(String[] args) &#123; System.out.println(\"What is a computer?\"); &#125;&#125; 1-2 输出I Love Programming! 得分：10 / 10 12345public class Main &#123; public static void main(String[] args) &#123; System.out.println(\"I Love Programming!\"); &#125;&#125; 1-1 输出Hello World! 得分：10 / 10 123456import java.io.*;public class Main &#123; public static void main(String[] args) throws IOException&#123; System.out.println(\"Hello World!\"); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Python任务调度模块APScheduler","slug":"Python任务调度模块APScheduler","date":"2019-02-24T11:30:06.000Z","updated":"2019-03-03T08:55:01.351Z","comments":true,"path":"2019/02/24/Python任务调度模块APScheduler/","link":"","permalink":"https://nymrli.top/2019/02/24/Python任务调度模块APScheduler/","excerpt":"","text":"Python任务调度模块APScheduler APScheduler是一个python的第三方库，用来提供python的后台程序。包含四个组件，分别是： triggers： 任务触发器组件，提供任务触发方式 triggers（触发器）中包含调度逻辑，每个作业都由自己的触发器来决定下次运行时间。除了他们自己初始配置意外，触发器完全是无状态的。 job stores： 任务商店组件，提供任务保存方式 job stores（作业存储器）存储被调度的作业，默认的作业存储器只是简单地把作业保存在内存中，其他的作业存储器则是将作业保存在数据库中。当作业被保存到一个持久化的作业存储器中的时候，该作业的数据会被序列化，并在加载时被反序列化。作业存储器不能共享调度器。 executors： 任务调度组件，提供任务调度方式 executors（执行器）处理作业的运行，他们通常通过在作业中提交指定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。 schedulers： 任务调度组件，提供任务工作方式 schedulers（调度器）配置作业存储器和执行器可以在调度器中完成，例如添加、修改和移除作业。根据不同的应用场景可以选用不同的调度器，可选的有BlockingScheduler,BackgroundScheduler,AsyncIOScheduler,GeventScheduler,TornadoScheduler,TwistedScheduler,QtScheduler 7种。 其中BlockingScheduler与BackgroundScheduler是其中最常用的两种调度器。那他们之间有什么区别呢？ BlockingScheduler: 调用start函数后会阻塞当前线程。当调度器是你应用中唯一要运行的东西时 BackgroundScheduler: 调用start后主线程不会阻塞。当你不运行任何其他框架时使用，并希望调度器在你应用的后台执行。 使用的一个简单实例1234567891011121314from apscheduler.schedulers.blocking import BlockingScheduler # 阻塞import time# 实例化一个调度器scheduler = BlockingScheduler() def job1(): print \"%s: 执行任务\" % time.asctime()# 添加任务并设置触发方式为3s一次scheduler.add_job(job1, 'interval', seconds=3)# 开始运行调度器scheduler.start() 触发器 date 一次性指定日期 interval 在某个时间范围内间隔多长时间执行一次 cron 和Linux crontab格式兼容，最为强大 date 最基本的一种调度，作业只会执行一次。它的参数如下： run_date (datetime|str) – 作业的运行日期或时间 timezone (datetime.tzinfo|str) – 指定时区 1234# 2016-12-12运行一次job_functionsched.add_job(job_function, 'date', run_date=date(2016, 12, 12), args=['text'])# 2016-12-12 12:00:00运行一次job_functionsched.add_job(job_function, 'date', run_date=datetime(2016, 12, 12, 12, 0, 0), args=['text']) interval 间隔调度，参数如下：weeks (int) – 间隔几周days (int) – 间隔几天hours (int) – 间隔几小时minutes (int) – 间隔几分钟seconds (int) – 间隔多少秒start_date (datetime|str) – 开始日期end_date (datetime|str) – 结束日期 12# 每两个小时调一下job_functionsched.add_job(job_function, 'interval', hours=2) cron参数如下：year (int|str) – 年，4位数字month (int|str) – 月 (范围1-12)day (int|str) – 日 (范围1-31)week (int|str) – 周 (范围1-53)day_of_week (int|str) – 周内第几天或者星期几 (范围0-6 或者 mon,tue,wed,thu,fri,sat,sun)hour (int|str) – 时 (范围0-23)minute (int|str) – 分 (范围0-59)second (int|str) – 秒 (范围0-59)start_date (datetime|str) – 最早开始日期(包含)end_date (datetime|str) – 最晚结束时间(包含)timezone (datetime.tzinfo|str) – 指定时区 1234# job_function将会在6,7,8,11,12月的第3个周五的1,2,3点运行sched.add_job(job_function, 'cron', month='6-8,11-12', day='3rd fri', hour='0-3')# 截止到2016-12-30 00:00:00，每周一到周五早上五点半运行job_functionsched.add_job(job_function, 'cron', day_of_week='mon-fri', hour=5, minute=30, end_date='2016-12-31') 添加任务 有两种方法，一种是使用add_job()函数，还有一种方式是通过scheduled_job()装饰器。 add_job()函数方式123456789101112131415from apscheduler.schedulers.blocking import BlockingSchedulerimport datetime def my_job1(): print 'my_job1 is running, Now is %s' % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") def my_job2(): print 'my_job2 is running, Now is %s' % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") sched = BlockingScheduler()# 每隔5秒运行一次my_job1sched.add_job(my_job1, 'interval', seconds=5,id='my_job1')# 每隔5秒运行一次my_job2sched.add_job(my_job2,'cron',second='*/5',id='my_job2')sched.start() scheduled_job()装饰器方式1234567891011121314from apscheduler.schedulers.blocking import BlockingSchedulerimport datetime sched = BlockingScheduler()#每隔5秒运行一次my_job1@sched.scheduled_job('interval',seconds=5,id='my_job1')def my_job1(): print 'my_job1 is running, Now is %s' % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") #每隔5秒运行一次my_job2@sched.scheduled_job('cron',second='*/5',id='my_job2')def my_job2(): print 'my_job2 is running, Now is %s' % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")sched.start() 使用SQLAlchemy作业存储器存放作业12345678910111213141516171819202122from apscheduler.schedulers.blocking import BlockingSchedulerfrom datetime import datetime,timedeltaimport logging sched = BlockingScheduler()def my_job(): print 'my_job is running, Now is %s' % datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")#使用sqlalchemy作业存储器url='mysql+mysqldb://root:123456@localhost:3306/scrapy?charset=utf8'sched.add_jobstore('sqlalchemy',url=url)#添加作业sched.add_job(my_job,'interval',id='myjob',seconds=5) log = logging.getLogger('apscheduler.executors.default')log.setLevel(logging.INFO) # DEBUG#设定日志格式fmt = logging.Formatter('%(levelname)s:%(name)s:%(message)s')h = logging.StreamHandler()h.setFormatter(fmt)log.addHandler(h) sched.start() 部分摘自:APScheduler浅析 Flask-APScheduler大致用法跟APScheduler一致，只不过需要 1.在配置中设置SCHEDULER_API_ENABLED = True2.app配置12345from flask_apscheduler import APScheduler;scheduler = APScheduler();scheduler.init_app(app)scheduler.start() 3.添加任务exts.py 12from flask_apscheduler import APSchedulersche = APScheduler() aap.py 123456789101112from exts import db,mail,schesche.init_app(app)...def refreshinfo(): passsche.add_job(func=refreshinfo, id='whetherInfo', trigger='interval', seconds=150)sche.start()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"搭建frp服务--阿里云服务器","slug":"搭建frp服务-阿里云服务器","date":"2019-02-24T06:56:27.000Z","updated":"2019-03-02T10:50:25.475Z","comments":true,"path":"2019/02/24/搭建frp服务-阿里云服务器/","link":"","permalink":"https://nymrli.top/2019/02/24/搭建frp服务-阿里云服务器/","excerpt":"","text":"搭建frp服务–阿里云服务器为了可以远程访问活动室的电脑，需要进行内网穿透。之前9块钱买了花生壳的服务，勉强用用还行，带宽很有限。听说了frp后,打算在阿里云上安个frp服务，充当中转服务器。 什么是frp frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。 开始搭建外网主机SSH连接上外网主机后，使用wget指令下载frp。 wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gz 使用tar指令解压tar.gz文件 tar -zxvf frp_0.20.0_linux_amd64.tar.gz 使用cd指令进入解压出来的文件夹 1cd frp_0.20.0_linux_amd64/ 外网主机作为服务端，可以删掉不必要的客户端文件，使用rm指令删除文件。 12rm -f frpcrm -f frpc.ini 接下来要修改服务器配置文件，即frps.ini文件。使用vi指令对目标文件进行编辑。 1vi frps.ini 打开frps.ini后可以看到默认已经有很多详细的配置和示范样例，该文章仅以达到内网穿透为目的，所以这里选择删掉或注释掉里面的所有内容，然后根据群晖的情况，按照官方的中文文档添加以下配置。（这里的操作都使用vi命令，关于vi命令的使用方式这里不作详细介绍，可以自行搜索相关使用方法。） 123[common]bind_port = 7000vhost_http_port = 8080 [common]部分是必须有的配置，其中bind_port是自己设定的frp服务端端口，vhost_http_port是自己设定的http访问端口。 保存上面的配置后，使用以下指令启动frp服务端。（如果需要在后台运行，请往下翻阅关于后台运行的部分。） 1./frps -c ./frps.ini 服务端的工作就到此结束了。 客户端客户端前面的操作和服务端是一模一样的，这里不一一解释。 123456wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gztar -zxvf frp_0.20.0_linux_amd64.tar.gzcd frp_0.20.0_linux_amd64rm -f frpsrm -f frps.inivi frpc.ini 客户端的配置如下 12345678910111213141516171819[common]server_addr = x.x.x.xserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000[nas]type = httplocal_port = 5000custom_domains = no1.sunnyrx.com[web]type = httplocal_port = 80custom_domains = no2.sunnyrx.com 上面的配置和服务端是对应的。 [common]中的server_addr填frp服务端的ip（也就是外网主机的IP），server_port填frp服务端的bind_prot。 [ssh]中的local_port填群晖的ssh端口。 [nas]中的type对应服务端配置。local_port填群晖的DSM端口。custom_domains为要映射的域名，记得域名的A记录要解析到外网主机的IP。 [web]同上，local_port填群晖的web端口。这里创建了两个http反向代理是为了分别映射群晖两个重要的端口，5000和80，前者用于登录群晖管理，后者用于群晖的Web Station和DS Photo。 保存配置，输入以下指令运行frp客户端。（同样如果需要在后台运行，请往下翻阅关于后台运行的部分。） 1./frpc -c ./frpc.ini 此时在服务端会看到”start proxy sucess”字样，即连接成功。 现在可以用SSH通过外网主机IP:6000和群晖建立SSH连接。通过浏览器访问no1.sunnyrx.com:8080打开群晖nas的管理页面，访问no2.sunnyrx.com:8080打开群晖Web Station的网站，DS Photo app可以连接no2.sunnyrx.com:8080进入DS Photo管理。 让frp在后台运行虽然现在frp运作起来了，内网穿透也实现了，但这还是不够的。此时如果断开与服务端或者客户端的SSH连接（比如关掉了Xshell）也就中止了frp的运行。 保持frp运行是关键是让服务端的frp和客户端的frp在后台运行，这里提两个方法供参考，一个是使用screen指令，另一个是使用nohup指令。由于群晖的系统默认是没有screen指令的，这里也不提供安装screen的方法，所以推荐群晖直接使用nohup。 其实服务端也直接用’nohup’就好了。 使用screen让frp在后台运行下面的示范是运行服务端的frp，客户端就不示范了，前面提过群晖的系统没有screen指令。 首先使用screen指令创建一个会话。 1screen -dmS frp 然后进入这个会话。 1screen -r frp 最后使用运行frp的指令，在后面加上” &amp;”。（如果之前断开了SSH连接，记得用cd指令进入frp的目录先。） 1./frps -c ./frps.ini &amp; 这样就让frp在后台运行了。 使用nohup指令nohup指令的使用方法相对简单，只需要在nohup后面加上frp的运行指令即可。下面示范的指令是运行frp客户端。（同样，如果之前断开了SSH连接，记得用cd指令进入frp的目录先。） 1nohup ./frpc -c ./frpc.ini &amp; 这样就成功让frp在后台运行了。 ▲ 注意nohup千万不要达成nohub，不然是没有效果的，有的时候会报错告诉你 没有nohub这个命令，有的时候终端（terminal）直接会消失而没有反应 摘自链接：https://www.jianshu.com/p/e8e26bcc6fe6 经过教程操作后，发现客户端电脑能够连接到学长家里已经搭好的frp服务器，但是就是连接不上阿里云。于是猜测是阿里云某些端口没有打开，一查果然如此，解决方案如下 为阿里云的安全服务限制，只有几个端口是默认打开的，所以要自己登陆阿里云服务器后台更改端口限制。 ECS服务器修改网络和安全组中的安全组配置 轻量级服务器修改安全-防火墙,如图 添加好以后,发现客户端仍然连不上去。担心是需要重启，于是重启后还是不行。到最后才发现原来是客户端的frpc.ini中server_addr写错了一位IP字段，QAQ… 最后还要记得在防火墙中打开6000端口，协议还是TCP，最后即可以通过IP:6000就可以访问到内网主机了 12345[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"},{"name":"网络知识","slug":"网络知识","permalink":"https://nymrli.top/tags/网络知识/"}]},{"title":"Cmake 入门","slug":"Cmake-入门","date":"2019-02-18T08:42:36.000Z","updated":"2019-02-18T08:43:22.053Z","comments":true,"path":"2019/02/18/Cmake-入门/","link":"","permalink":"https://nymrli.top/2019/02/18/Cmake-入门/","excerpt":"","text":"Cmake 入门入门案例：单个源文件例如，假设现在我们的项目中只有一个源文件 main.cc ，该程序的用途是计算一个数的指数幂。 1.首先编写 CMakeLists.txt 文件，并保存在与 main.cc 源文件同个目录下123456# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo1)# 指定生成目标add_executable(Demo main.cc) 语法: 由命令、注释和空格组成，其中命令是不区分大小写的。 符号 # 后面的内容被认为是注释 命令由命令名称、小括号和参数组成 参数之间使用空格进行间隔 2.编译项目之后，在当前目录执行 cmake . ，得到 Makefile 后再使用 make 命令编译得到 Demo1 可执行文件。 同一目录，多个源文件如果多文件，结构变成 1234567./Demo2 | +--- main.cc | +--- MathFunctions.cc | +--- MathFunctions.h cmakelist.txt需要改成 123456# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo2)# 指定生成目标add_executable(Demo main.cc MathFunctions.cc) 区别: 即在 add_executable 命令中增加了一个 MathFunctions.cc 源文件 省事的方法是使用 aux_source_directory 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。语法为aux_source_directory(&lt;dir&gt; &lt;variable&gt;) 123456789# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo2)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(Demo $&#123;DIR_SRCS&#125;) 多个目录，多个源文件文件结构: 123456789./Demo3 | +--- main.cc | +--- math/ | +--- MathFunctions.cc | +--- MathFunctions.h 对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。 根目录中的 CMakeLists.txt ：123456789101112131415# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo3)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# ▲添加 math 子目录add_subdirectory(math)# 指定生成目标 add_executable(Demo main.cc)# 添加链接库target_link_libraries(Demo MathFunctions) 使用命令 add_subdirectory 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理. 使用命令 target_link_libraries 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 子目录中的 CMakeLists.txt：12345# 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 生成链接库add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;) 在该文件中使用命令 add_library 将 src 目录中的源文件编译为静态链接库 摘自CMake 入门实战 set指令详解语法： SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])指令功能: 用来显式的定义变量例子: SET (SRC_LST main.c other.c)说明: 用变量代替值，例子中定义SRC_LST代替后面的字符串。 例子:一. CMAKE_SOURCE_DIR –&gt;CMakeLists.txt所在的目录set(libs &quot;${CMAKE_SOURCE_DIR}/src/main/jnilibs&quot;)定义了一个变量libs，并且变量的值为${CMAKE_SOURCE_DIR}/src/main/jnilibs，其中CMAKE_SOURCE_DIR 是一个cmake内置变量，指定了CMakeLists.txt所在的目录 二.CMAKE_LIBRARY_OUTPUT_DIRECTORY–&gt;cmake编译输出的东西应该放在什么地方set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/src/main/jnilibs/${ANDROID_ABI})这个命令用于给CMAKE_LIBRARY_OUTPUT_DIRECTORY宏赋值，该宏指定了cmake编译输出的东西应该放在什么地方。 这个例子中的地方是${PROJECT_SOURCE_DIR}/src/main/jnilibs/${ANDROID_ABI}其中PROJECT_SOURCE_DIR 是cmake内置宏，指向构建工程的全路径。 include包含库、头文件添加头文件路径，对应的函数叫include_directories添加库路径，对应的函数叫LINK_DIRECTORIES添加库，对应的函数叫LINK_LIBRARIES，把所有的库加进去即可环境变量使用$ENV{NAME}指令就可以调用系统的环境变量了。比如MESSAGE(STATUS “HOME dir: $ENV{HOME}”)设置环境变量的方式是:SET(ENV{变量名} 值) dl、rt1234567target_link_libraries(agentspark$&#123;RCSSNET3D_LIBRARY&#125;$&#123;Boost_SYSTEM_LIBRARY&#125;dl$&#123;CMAKE_THREAD_LIBS_INIT&#125;rt ) dl是libdl.so,rt是librt.so的缩写···其实是静态加载了这两个动态链接库！！！","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"Python+adb操作手机","slug":"Python-adb操作手机","date":"2019-02-06T05:00:09.000Z","updated":"2019-03-18T04:05:23.145Z","comments":true,"path":"2019/02/06/Python-adb操作手机/","link":"","permalink":"https://nymrli.top/2019/02/06/Python-adb操作手机/","excerpt":"","text":"Adbwifi连接调试 adb connect {ip}如果你不想用usb连接调试，可以选择使用adb 连接调试，命令是 adb connect {ip} ，需要在同一个局域网内。这个功能也比较实用，但首次连接时，需要另外一些配置，建议可以网上搜索下adb wifi连接手机等关键字看看。 屏幕截屏 screencap -p {图片存储地址}这个其实直接通过手机截屏再发送到电脑就可以了，但我开发的是TV应用，在盒子上没法截屏，所以这个命令对我来说还是较实用的。 获取或推送文件 adb pull/push这个也挺实用的，获取手机指定位置的文件到电脑上，或者从电脑发送文件到手机上 模拟按键事件//这条命令相当于按了设备的Back key键adb shell input keyevent 4 //可以解锁屏幕 adb shell input keyevent 82 //在屏幕上做划屏操作，前四个数为坐标点，后面是滑动的时间（单位毫秒） adb shell input swipe 50 250 250 250 500 手机分辨率一般为1080*1920，其中左上角为（0,0），右下角为（1080*1920）,还可以增加一个参数为持续时间 //在屏幕上点击坐标点x=50 y=250的位置。 adb shell input tap 50 250 //输入字符abc adb shell input text abc 跳一跳游戏adb教程 事件介绍 代码演示都是在进入 adb shell模式下 input swipe模拟的是滑动事件 , 如左滑:input swipe 600 800 300 800 可以输入文本的文本框之类的控件上输入出 OuyangPeng 字符串: input text OuyangPeng input tap命令模拟触摸屏幕input tap 600 800 input keyevent用法: 12345678910input keyevent 3 // Homeinput keyevent 4 // Backinput keyevent 19 //Upinput keyevent 20 //Downinput keyevent 21 //Leftinput keyevent 22 //Rightinput keyevent 23 //Select/Okinput keyevent 24 //Volume+input keyevent 25 // Volume-input keyevent 82 // Menu 菜单 功能adb 启动应用:adb shell am start -n packgage名 /.activity如 adb shell am start -n com.android.calculator2/.Calculator 提醒点：一定要找到、找对activity和package 长时间按某个元素：adb input shell …adb -s 4d0041be98b01f shell input touchscreen swipe 540 716 545 718 1000 语义：-s 后跟设备号，swipe 先传移动坐标范围‘540 716 545 718’，然后1000是长按时间，单位毫秒。 Python语句调用: os.system(只有执行命令是否成功的结果) 123456import osCMD = r'.\\adb.exe version'res = os.system(CMD)print(res) # 0&gt;&gt; Android Debug Bridge version 1.0.32&gt;&gt; 0 os.popen(可读取执行语句的结果) 12345import osCMD = r'.\\adb.exe version'version = os.popen().read()print(version)&gt;&gt; Android Debug Bridge version 1.0.32 subprocess.call 123456import subprocessCMD = r'.\\adb.exe version'version = subprocess.call(CMD)print(version) # 0&gt;&gt; Android Debug Bridge version 1.0.32&gt;&gt; 0 subprocess.Popen(也是一个执行系统命令的工具,但这边效果不太好) 12345import subprocessCMD = r'.\\adb.exe version'version = subprocess.Popen(CMD)print(version) # 这边是个Popen对象,&gt;&gt; &lt;subprocess.Popen object at 0x00000219392981D0&gt; 附录event值记录 https://blog.csdn.net/jlminghui/article/details/39268419","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"模拟操作","slug":"模拟操作","permalink":"https://nymrli.top/tags/模拟操作/"}]},{"title":"ACM_动态规划","slug":"ACM-动态规划","date":"2019-02-03T07:49:10.000Z","updated":"2019-02-07T11:33:36.167Z","comments":true,"path":"2019/02/03/ACM-动态规划/","link":"","permalink":"https://nymrli.top/2019/02/03/ACM-动态规划/","excerpt":"","text":"图解动态规划 : http://www.sohu.com/a/153858619_466939 动态规划 : 最优子结构 边界 状态转移方程式 题目二： 国王和金矿有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？ 解法一: 排列组合时间复杂度 : O(2^N) 解法二 : DP1.找到最优子结构 10人4金矿(有一个金矿没挖) 10-3人4金矿(挖了一个金矿) 2.最优选择5个金矿的最优选择，就是（前4座金矿10工人的挖金数量）和（前4座金矿7工人的挖金数量+第5座金矿的挖金数量）的最大值！ 3.边界 经过整理可得 状态转移方程式: 边界: F(n,w) = 0 (n&lt;=1, w&lt;p[0]); F(n,w) = g[0] (n==1, w&gt;=p[0]); 推导式 F(n,w) = F(n-1,w) (n&gt;1, w&lt;p[n-1]) F(n,w) = max(F(n-1,w), F(n-1,w-p[n-1])+g[n-1]) (n&gt;1, w&gt;=p[n-1]) 实现方法:简单递归记忆搜索法动态规划(递推式) 01背包问题简单递归12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* 01背包问题 */pair&lt;int,int&gt; wv[maxn];int N; // 物品数量int W; // 背包重量int rec(int i,int j)&#123; int res = 0; if( i == N) res= 0; else if( j &lt; wv[i].first ) res = rec(i+1,j); else res = max(rec(i+1,j) , rec(i+1,j-wv[i].first) + wv[i].second); return res;&#125;void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; cout &lt;&lt; rec(0,W) &lt;&lt; endl;&#125;int main()&#123; solve(); return 0;&#125; 记忆搜索1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* 01背包问题 */pair&lt;int,int&gt; wv[maxn];int N; // 物品数量int W; // 背包重量int dp[maxn][maxn]; //2.多了个记忆数组(称为DP数组)int rec(int i,int j)&#123; if ( dp[i][j] &gt; 0 ) return dp[i][j]; // 如果已经计算过,就直接使用之前的结果 int res = 0; if( i == N) res= 0; else if( j &lt; wv[i].first ) res = rec(i+1,j); else res = max(rec(i+1,j) , rec(i+1,j-wv[i].first) + wv[i].second); dp[i][j] =res; // 2.将结果记录 return res;&#125;void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; cout &lt;&lt; rec(0,W) &lt;&lt; endl;&#125;int main()&#123; solve(); return 0;&#125; 动态规划解法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* 01背包问题 */pair&lt;int,int&gt; wv[maxn];int N; // 物品数量int W; // 背包重量int dp[maxn][maxn]; //2.多了个记忆数组(称为DP数组)// 逆序推导void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; for( int i= N-1 ; i &gt;= 0 ; i--)&#123; for( int j=0;j&lt;= W ; j++)&#123; if( j &lt; wv[i].first ) dp[i][j] = dp[i+1][j]; else dp[i][j] = max( dp[i+1][j] , dp[i+1][j - wv[i].first] + wv[i].second); &#125; &#125; cout &lt;&lt; dp[0][W] &lt;&lt;endl;&#125;// 顺序推导void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; for( int i= 0 ; i &lt; N ; i++)&#123; for( int j=0;j&lt;= W ; j++)&#123; if( j &lt; wv[i].first ) dp[i+1][j] = dp[i][j]; else dp[i+1][j] = max( dp[i][j] , dp[i][j - wv[i].first] + wv[i].second); // 推导式也变了,下一行的依据上一行写成dp[i+1][j] = ... &#125; &#125; cout &lt;&lt; dp[N][W] &lt;&lt;endl; // 输出的结果变了&#125;int main()&#123; solve(); return 0;&#125; ▲注意，边界一定要注意处理。 这题由于边界全为0，而全局数组初始化默认是0，所以不需要处理，否则得像 国王和金矿提供的题解一样书写。 最长公共子序列问题1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* LCS */int dp[maxn+1][maxn+1];void solve()&#123; int m,n; cin &gt;&gt; n &gt;&gt; m; string sn,sm; cin &gt;&gt; sn &gt;&gt; sm; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if( sn[i] == sm[j] ) dp[i+1][j+1] = dp[i][j] + 1; // p[i+1][j+1] = max(dp[i][j] + 1 , max(dp[i+1][j] , dp[i][j+1]));化简而来 else dp[i+1][j+1] = max(dp[i][j+1] , dp[i+1][j] ); &#125; &#125; cout &lt;&lt; dp[n][m] &lt;&lt; endl;&#125;int main()&#123; solve(); return 0;&#125; 完全背包问题多重部分和","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"DP","slug":"DP","permalink":"https://nymrli.top/tags/DP/"}]},{"title":"ACM_贪心专题","slug":"ACM-贪心专题","date":"2019-02-01T12:17:50.000Z","updated":"2019-02-02T12:19:38.617Z","comments":true,"path":"2019/02/01/ACM-贪心专题/","link":"","permalink":"https://nymrli.top/2019/02/01/ACM-贪心专题/","excerpt":"","text":"贪心专题1.活动安排有若干个活动，第i个开始时间和结束时间是[Si,fi)，只有一个教室，活动之间不能交叠，求最多安排多少个活动？ Input 123第一行一个正整数n (n &lt;= 10000)代表活动的个数。第二行到第(n + 1)行包含n个开始时间和结束时间。开始时间严格小于结束时间，并且时间都是非负整数，小于1000000000 Output 1一行包含一个整数表示活动个数。 Input示例 123431 23 42 9 Output示例 12 博主提供: 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e4+5;struct node&#123; int s,e; //start , end &#125; a[maxn];//由于使用结构体,所以需要自定义cmp函数bool cmp(node x,node y)&#123; if(x.e&lt;y.e) return true; else if(x.e==y.e&amp;&amp;x.s&gt;y.s) return true; return false;&#125;int main()&#123; int n,i,j,ans,end; cin&gt;&gt;n; for(i = 0;i&lt;n;i++) cin&gt;&gt;a[i].s&gt;&gt;a[i].e; sort(a,a+n,cmp); ans = 0; end = -1e9-100; for(i =0;i&lt;n;i++)&#123; if(a[i].s&gt;=end)&#123; // 结束最早的 ans++; end=a[i].e; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 不使用结构体,使用map: 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1e4 +5;int main()&#123; int N; while(scanf(\"%d\",&amp;N) == 1)&#123; pair&lt;int,int&gt; itv[maxn]; for(int i = 0 ; i&lt;N; i++) scanf(\"%d%d\",&amp;itv[i].second , &amp;itv[i].first); sort( itv , itv + N); int ans = 0 ; int t = 0; for( int i =0 ; i&lt; N ; i++)&#123; if ( t &lt; itv[i].second )&#123; ans ++; t = itv[i].first; &#125; &#125; printf(\"%d\",ans); &#125; return 0;&#125; HUD OJ 2037今年暑假不AC感觉像是板子题，都是时间规划类，需要最多目标的题目。但是在第15行时，必须写&lt;=,否则WA. &lt;= 的结果是 5 ; &lt; 的结果是 3 经过与上题的对比发现，主要的区别在于这句话 ：上题规定 开始时间严格小于结束时间，并且时间都是非负整数，小于1000000000 ，而这题 开始时间是可以等于结束时间的 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1e4+ 5;pair&lt;int,int&gt; node[maxn];int main()&#123; int N; while( cin &gt;&gt; N)&#123; if ( !N ) break; for(int i=0;i&lt;N;i++) cin &gt;&gt; node[i].second &gt;&gt; node[i].first ; sort(node,node+N); int ans =0 , endt =0 ; for( int i=0 ;i&lt;N;i ++)&#123; if( endt &lt;= node[i].second )&#123; ans ++ ; endt = node[i].first; &#125; &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125; 字典序比较123456789101112131415161718192021222324252627282930313233include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;char s[maxn];void solve(int n)&#123; int a = 0 , b = n-1; while( a &lt;= b)&#123; bool left = false; for(int i = 0 ; a+i &lt;=b ; i++)&#123; if( s[a+i] &lt; s[b-i] )&#123; left = true; break; &#125;else if (s[a+i] &gt; s[b-i])&#123; left = false; break; &#125;else continue; &#125; if( left ) putchar(s[a++]); else putchar(s[b--]); &#125; putchar('\\n');&#125;int main()&#123; int N; scanf(\"%d\",&amp;N); scanf(\"%s\",s); solve(N); return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"贪心","slug":"贪心","permalink":"https://nymrli.top/tags/贪心/"}]},{"title":"学习nginx配置","slug":"学习nginx配置","date":"2019-01-24T08:45:40.000Z","updated":"2019-01-24T08:47:29.469Z","comments":true,"path":"2019/01/24/学习nginx配置/","link":"","permalink":"https://nymrli.top/2019/01/24/学习nginx配置/","excerpt":"","text":"nginx配置多台虚拟主机:1.分配IP地址 2.新建、编写usr/local/nginx的conf配置文件 12345678910111213http&#123; sever&#123; listen 192.168.1.17:80; //监听 (IP地址:) 端口 server_name 192.168.1.17; // 域名或者ip access_log logs/server1.access.log conbined;//指定位置+使用日志文件默认格式 location / &#123; index index.html index.htm; //index表示意义(关键字),左边优先级高.指定的首页 root html/ss2; //虚拟主机目录(网站目录)==&gt;ss2下的所以html文件都可以通过192.168.1.17/xxx访问 &#125; &#125;&#125; 3.编写目录下的首页index.html文件 4.运行nginx usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/xnzj.conf ▲在根目录下可以直接通过路径访问,如根目录下只有index文件,而配置中设置的是index index.html此时没有找到index.html后就会显示403错误,但是可以通过192.168.1.17==&gt;192.168.1.17/index添加路径的方法来加载index界面 其他配置 缓存 12345678910server&#123; listen xxx; server_name yyy; location ~.*\\.(jpg|png|)$&#123; expires 30d; &#125; location ~.*\\.(css|js|)$&#123; expires 1h; &#125;&#125; 自动列目录 12345678910[/ect/nginx/nginx.conf]server&#123; .. location / &#123; root html; index index.html index.hml; autoindex on; #▲ &#125; &#125; uwsgi模块使用安装source activate# 开启虚拟开发环境模式pip install uwsgi # 安装uwsgi配置uwsgi配置文件支持很多格式，我采用.ini格式，命名为uconfig.ini具体内容如下： 启动uwsgi , 命令输入uwsgi uconfig.ini 外部访问测试 此时在外部访问 公网IP：5000就可以访问了 12345678910111213141516[uwsgi]# 外部访问地址，可以指定多种协议，现在用http便于调试，之后用sockethttp = 0.0.0.0:5000# 指向项目目录chdir = /home/pythonproject/my_flask/py3env/myblog/# flask启动程序文件wsgi-file = manage.py# flask在manage.py文件中的app名callable = app #很多人习惯将Flask应用对象取名为”app”，但是WSGI标准是”application”。uWSGI提供了一个功能，可以指定应用对象，方法就是在配置文件中加上”callable”项：# 处理器数processes = 4# 线程数threads = 2#状态检测地址stats = 127.0.0.1:9191 1234location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:3031;&#125; 这段配置表明Nginx会将收到的所有请求都转发到”127.0.0.1:3031″端口上，即uWSGI服务器上。现在让我们重启Nginx，","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"C++日期操作","slug":"C++日期操作","date":"2019-01-24T07:00:56.000Z","updated":"2019-02-06T08:23:36.537Z","comments":true,"path":"2019/01/24/C++日期操作/","link":"","permalink":"https://nymrli.top/2019/01/24/C++日期操作/","excerpt":"","text":"C++日期操作12345678910111213int main( )&#123; time_t now = time(0); // 基于当前系统的当前日期/时间 的时间戳 cout &lt;&lt; \"1970 到目前经过秒数:\" &lt;&lt; now &lt;&lt; endl; tm *ltm = localtime(&amp;now);// 将时间戳转换为结构体,再输出 tm 结构的各个组成部分 cout &lt;&lt; \"年: \"&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl; cout &lt;&lt; \"月: \"&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl; cout &lt;&lt; \"日: \"&lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl; cout &lt;&lt; \"时间: \"&lt;&lt; ltm-&gt;tm_hour &lt;&lt; \":\"; cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; \":\"; cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl; getchar();&#125; time_t结构体12345678910111213141516171819202122232425262728#include &lt;time.h&gt; #include &lt;stdio.h&gt; int main( void ) &#123; time_t t = time(0); char tmp[64]; strftime( tmp, sizeof(tmp), \"%Y/%m/%d %X %A 本年第%j天 %z\",localtime(&amp;t) ); puts( tmp ); return 0; &#125; // ---第二种#include &lt;string&gt;#include &lt;time.h&gt;using namespace std;string getTime()&#123; time_t timep; time (&amp;timep); char tmp[64]; strftime(tmp, sizeof(tmp), \"%Y-%m-%d %H:%M:%S\",localtime(&amp;timep) ); return tmp;&#125;int main()&#123; string time = getTime(); cout &lt;&lt; time &lt;&lt; endl; return 0;&#125; size_t strftime(char strDest, size_t maxsize, const char format, const struct tm timeptr);根据格式字符串生成字符串。struct tm localtime(const time_t *timer);取得当地时间，localtime获取的结果由结构tm返回返回的字符串可以依下列的格式而定：%a 星期几的缩写。Eg:Tue%A 星期几的全名。 Eg: Tuesday%b 月份名称的缩写。%B 月份名称的全名。%c 本地端日期时间较佳表示字符串。%d 用数字表示本月的第几天 (范围为 00 至 31)。日期%H 用 24 小时制数字表示小时数 (范围为 00 至 23)。%I 用 12 小时制数字表示小时数 (范围为 01 至 12)。%j 以数字表示当年度的第几天 (范围为 001 至 366)。%m 月份的数字 (范围由 1 至 12)。%M 分钟。%p 以 ‘’AM’’ 或 ‘’PM’’ 表示本地端时间。%S 秒数。%U 数字表示为本年度的第几周，第一个星期由第一个周日开始。%W 数字表示为本年度的第几周，第一个星期由第一个周一开始。%w 用数字表示本周的第几天 ( 0 为周日)。%x 不含时间的日期表示法。%X 不含日期的时间表示法。 Eg: 15:26:30%y 二位数字表示年份 (范围由 00 至 99)。%Y 完整的年份数字表示，即四位数。 Eg:2008%Z(%z) 时区或名称缩写。Eg:中国标准时间%% % 字符。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"程序开发经验","slug":"程序开发经验","permalink":"https://nymrli.top/tags/程序开发经验/"}]},{"title":"Shell代码编写记录","slug":"Shell代码编写记录","date":"2019-01-23T05:48:59.000Z","updated":"2019-01-24T03:06:07.015Z","comments":true,"path":"2019/01/23/Shell代码编写记录/","link":"","permalink":"https://nymrli.top/2019/01/23/Shell代码编写记录/","excerpt":"","text":"随机选取端口12345# 随机设置代理和监控端口，允许每台机器有多个代理# 注意:$RANDOM返回一个从0到32767的值，端口&lt;= 1024保留给root用户# TODO:不是随机选择端口，而是绑定到可用端口export SPARK_SERVERPORT=$[$RANDOM + 1025]export SPARK_AGENTPORT=$[$RANDOM + 1025] 后台执行,获取其PID12345678rcssserver3d --agent-port $SPARK_AGENTPORT --server-port $SPARK_SERVERPORT &amp;# 将rcssserver3d后台运行在随机获得的端口上PID=$! # 获得进程号,最后用进程PID关闭rcssserver3d# ---类比学习---python ./test1.py &amp;PID=$!echo $PID 组合命令12345678910sleep 5 #延迟时间DIR_SCRIPT=\"$( cd \"$( dirname \"$0\" )\" &amp;&amp; pwd )\" # 先运行 cd切换目录,再将当前工作目录赋值给 DIR_SCRIPTTYPE=$1 #TYPE为读取第二个参数DIR_PARAMS=\"$( cd \"$( dirname \"$2\" )\" &amp;&amp; pwd )\"DIR_OUTPUT=\"$( cd \"$( dirname \"$3\" )\" &amp;&amp; pwd )\"PARAMS_FILE=$DIR_PARAMS/$(basename $2)# basename返回文件名OUTPUT_FILE=$DIR_OUTPUT/$(basename $3) 输出判断1234567891011121314while [ ! -f $OUTPUT_FILE ] &amp;&amp; [ $total_wait_time -lt $maxWaitTimeSecs ]do sleep 1 total_wait_time=`expr $total_wait_time + 1` # expr 表示后面是运算表达式done # -f 是正常文件 # Shell 中 ()用[]代替if [ ! -f $OUTPUT_FILE ]then echo \"Timed out while waiting for script to complete, current wait time is $total_wait_time seconds.\"else echo \"Completed with a wait time of $total_wait_time seconds.\"fi 关闭进程12345echo \"Killing Simulator\"kill -s 2 $PID# kill -s 信号名 进程号echo \"Killing Agent\"kill -s 2 $AGENTPID 格式：kill &lt;pid&gt; 格式：kill -TERM &lt;pid&gt; 发送SIGTERM旌旗灯号到指定过程，若是过程没有捕获该旌旗灯号，则过程终止（If no signal is specified， the TERM signal is sent. The TERM signal will kill processes which do not catch this signal.） 格式：kill -l 列出所有旌旗灯号名称（Print a list of signal names. These are found in /usr/include/linux/signal.h）。只有第9种旌旗灯号（SIGKILL）才可以无前提终止过程，其他旌旗灯号过程都有权力忽视。下面是常用的旌旗灯号： 旌旗灯号名称 HUP 1 终端断线 INT 2 中断（同 Ctrl + C） QUIT 3 退出（同 Ctrl + ） TERM 15 终止 KILL 9 强迫终止 CONT 18 持续（与STOP相反， fg/bg号令） STOP 19 暂停（同 Ctrl + Z） Bash Shell 脚本获取进程 pid 第一种方法: ps -ef | grep &quot;Processname&quot; | grep -v grep | awk &#39;{print $2}&#39; 第二种 最简单的方法是使用 pgrep： pgrep -f name 根据PID关闭进程kill -9 PID 根据进程名关闭进程法一: 1kill -f name1 法二: 如果是可执行程序的话，可以直接使用 pidof 1pidof name 关闭Roboviz.sh里java进程的方法: grep -v ：显示不包含匹配文本的所有行(反向查找)。比如 grep -v grep 就是查找不含有 grep 字段的行 写法一:kill -9 $(ps x | grep Roboviz.jar | grep -v grep | awk &#39;{print $1}&#39;) 写法二: ps -ef | grep Roboviz.jar | grep -v grep | awk &#39;{print $2}&#39; | xargs kill -9 shell脚本中的冒号作用作用一: 占位符&lt;==&gt;pass12345if egrep '.*vmlinuz-2.6.32-220.23.1.lvs.el6.*nohz=off' /boot/grub/grub.conf ;then :else sed -i -r 's/(.*vmlinuz-2.6.32-220.23.1.lvs.el6.*)/\\1 nohz=off/' /boot/grub/grub.conffi 作用二: 分隔符 冒号(:)常用来做路径的分隔符（PATH），数据字段的分隔符（/etc/passwd） 宏特殊变量: $$ 当前脚本PID $! 后台子进程PID $? 上句执行结果","categories":[],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://nymrli.top/tags/Shell/"}]},{"title":"Matlab基础教程","slug":"Matlab基础教程","date":"2019-01-23T05:43:34.000Z","updated":"2019-02-23T12:48:13.593Z","comments":true,"path":"2019/01/23/Matlab基础教程/","link":"","permalink":"https://nymrli.top/2019/01/23/Matlab基础教程/","excerpt":"","text":"Matlab学习1234A = [1 3 5];max(A)ans = 5 如果存在多个输入参数，请使用逗号加以分隔： 12345B = [10 6 4];max(A,B)ans = 10 6 5%A中列元素与B中列元素一一比较. clc 函数清除命令行窗口。 函数123disp(&apos;hello world&apos;)hello world要调用不需要任何输入且不会返回任何输出的函数，请只键入函数名称： 二维绘图 r--&#39; 字符串为线条设定。每个设定可包含表示线条颜色、样式和标记的字符。标记是在绘制的每个数据点上显示的符号，例如，+、o 或 *。例如，&#39;g:*&#39; 请求绘制使用 * 标记的绿色点线。 请注意，为第一幅绘图定义的标题和标签不再被用于当前的图窗口中。默认情况下，每次调用绘图函数、重置坐标轴及其他元素以准备新绘图时，MATLAB® 都会清除图形。 要将绘图添加到现有图形中，请使用 hold。 1234567x = 0:pi/100:2*pi;y = sin(x);plot(x,y)hold ony2 = cos(x);plot(x,y2,&apos;:&apos;)legend(&apos;sin&apos;,&apos;cos&apos;) 三维绘图123[X,Y] = meshgrid(-2:.2:2);Z = X .* exp(-X.^2 - Y.^2);surf(X,Y,Z) surf 函数及其伴随函数 mesh 以三维形式显示曲面图。surf 使用颜色显示曲面图的连接线和面。mesh 生成仅以颜色标记连接定义点的线条的线框曲面图。（surf填充-sruface） M文件 脚本文件 函数文件 1234567891011脚本文件 1.多条命令的综合体 2.没有输入、输出变量 3.使用MATLAB基本工作空间 4.没有函数声明行 函数文件1.常用于扩充MATLAB函数库2.可以包含输入、输出变量3.运算中生成的所有变量都存放在函数工作空间4.包含函数声明行 函数名为mymax，文件名为mymax.m（必须相同）。它需要五个数字作为参数并返回最大的数字。 1234567891011121314151617创建函数文件，名为mymax.m 并输入下面的代码： function max = mymax(n1, n2, n3, n4, n5) %This function calculates the maximum of the % five numbers given as input max = n1; if(n2 &gt; max) max = n2; end if(n3 &gt; max) max = n3; end if(n4 &gt; max) max = n4; end if(n5 &gt; max) max = n5; end 符号变量与符号表达式x y; %定义x,y为符号变量>>z123456需要用syms或sym定义，例如&gt;&gt;syms x y; %定义x,y为符号变量&gt;&gt;z=x^2+y^2 ％定义z为含有x与y的符号表达式也可以这样定义z， &gt;&gt;z=sym(‘x^2+y^2’) %与上面等价 关于符号表达式的基本命令 命令 含义 pretty(s) 将s显示为数学书写形式 symsum(s,x,a,b) 对s中的x从a到b求和 findsym(s) 给出s中所有的符号变量 findsym(s,n) 给出s中离x最近的n个符号变量，n大于s中符号变量个数时则按字母表顺序返回符号变量 subs(s,a,b) 将s中的a置换成b double(s) 将s转换成数值形式 str2num(s) 字符变量转换为数值变量 num2str(s) 数值变量转换为字符变量 sym(a) 将a转换为符号变量 digits(d) 给出有效数字个数为d的近似值 vpa(s,d) 计算s在精度为d位有效数字的解 eval(s) 执行符号表达式s 命 令 含 义 collect(s) 合并s中的同类项 compose(f,g,x,y) 计算复合函数f(g(y)),x,y分别为f,g的自变量 g＝finverse(f) 计算f(x)的反函数，g的自变量仍为x expand(s) 展开表达式s factor(s) 因式分解s [N,D]=numden(s) 通分s中各式，其和的分子为N，分母为D simplify(s) 对s进行综合化简 simple(s) 给出s的所有最简式 微积分 命 令 含 义 limit(f,x,a) 计算函数f(x)当x-&gt;a时的极限 limit(f,x,a,’right’) 计算函数f(x)当x-&gt;a+时的右极限 limit(f,x,a,’left’) 计算函数f(x)当x-&gt;a-时的左极限 x=fminbnd(f,a,b) 计算函数f(x)在区间[a,b]上的最小值点 [x,fmin]=fminbnd(f,a,b) 计算函数f(x)在区间[a,b]上的最小值点及最小值fmin diff(f,’x’,n) 计算函数f(x)对变量x的n阶导数，’x’可省 int(f,x) 计算函数f(x)的不定积分，积分变量为x int(f,x,a,b) 计算函数f(x)在[a,b]上的定积分(符号) quad(f,a,b) 计算函数f(x)在[a,b]上的定积分值 taylor(f) 计算函数f(x)在x=0处的5阶泰勒展开式 taylor(f,n,x,a) 计算函数f(x)在x=a处的n-1阶泰勒展开式 ▲需要注意的是，在进行这些计算前必须申明是符号计算，即要加上syms x y;等语句 基本的绘图步骤 步 骤 典 型 代 码 1. 准备绘图数据 x = 0:0.2:12; y1 = bessel(1,x); 2. 选择一个窗口并在窗口中给图形定位 figure(1) ，subplot(2,2,1) 3. 调用基本的绘图函数 h = plot(x,y1,x,y2,x,y3); 4. 选择线型和标记特性 set(h,’LineWidth’,2,{‘LineStyle’},{‘–’;’:’;’-.’}) 5. 设置坐标轴的极限值、标记符号和网格线 axis([0 12 -0.5 1]) 6. 使用坐标轴标签、图例和文本对图形进行注释 xlabel(‘Time’)ylabel(‘Amplitude’) 7. 输出图形 print -depsc -tiff -r200 myplot # 二维曲线图1234例：&gt;&gt; x= 0:0.01:10;&gt;&gt; y=sin(x);&gt;&gt; plot(x,y) # 函数绘图1234fplot(‘function’,范围)，例如 fplot(&apos;sin(x)&apos;,[0,2*pi],&apos;r&apos;)后面选项与plot一致。再如 fplot(‘[sin(x),cos(x)]’,[0,2*pi])同时画出两个函数图形 #符号函数绘图1格式ezplot(f,[a,b]) 画出符号函数f在[a,b]上的图形 # 极坐标图形1234MATLAB提供了polar函数来在极坐标下绘制图形 ：&gt;&gt; x= 0:0.01:10;&gt;&gt; y=1+cos(x);&gt;&gt; polar(x,y,&apos;rs&apos;) 图形控制与修饰 命令 含义 axis auto 坐标轴缺省设置 axis equal 纵、横轴采用相等单位长度 axis image 纵、横轴采用相等单位长度，且坐标框紧贴数据范围 axis([x1 x2 y1 y2]) 设定坐标范围 grid on 画出网格线 grid off 不画网格线 hold on 使以后图形画在当前图形上 hold off 使以后图形不画在当前图形上 命令 含义 title(x,y,‘name’) 在(x,y)处标示图名 xlabel(‘xtext’) 横坐标轴名 ylabel(‘ytext’) 纵坐标轴名 legend(‘first’,’second’,n) 对一个坐标系中的两幅图作出图例注解 figure 另开图形窗口 subplot(m,n,k) m×n幅子图的第k幅称为当前图 多个图形的绘制方法1234subplot函数 可以实现多个图形的绘制：&gt;&gt; x = 0:.1:20;&gt;&gt; subplot(2,2,1)&gt;&gt; plot(x,sin(x)); # 三维网线图12345671.mesh(X,Y,Z) ，例 x=-5:0.2:5;y=x; [X Y]=meshgrid(x,y); %生成格点矩阵 Z=sin(sqrt(X.^2+Y.^2)); mesh(X,Y,Z) 2. ezmesh(‘f’,‘g’,‘h’,[u1,u2,v1,v2] )，例 ezmesh(&apos;cos(u)*cos(v)&apos;,&apos;sin(u)*cos(v)&apos;,&apos;sin(v)&apos;,[0,2*pi,-pi,pi]); axis equal 数值变量与符号变量数值变量的常用函数，一般都可以直接用在符号变量上，比如三角函数，这些都是可以通用的，而且函数的含义也完全一样。 但偏偏有些函数非常蛋疼，对符号变量与数值变量都可以进行操作，但操作的含义完全不同，比如diff，diff对于一个数值变量的运算结果是差分，而对于一个符号变量的运算结果则是求导 。 另外也存在很多函数只能对数值变量操作，比如离散傅里叶变换fft。还有很多函数只能对符号变量操作，比如泰勒展开taylor。因此在matlab使用中，一定要区分变量的类型，其实真的用起来也好区分，因为完成特定的计算任务，要么全部用数值，要么全部用符号，这也符合一般处理问题的原则。 4.字符串的常用函数 matlab中字符串的常用算符就更少了，但都非常有用，这里介绍几个： 1）num2str和str2num：可以实现数值变量和字符串变量的转换，比如 a=1 b=num2str(1)复制代码运算结果显示a是一个数值变量，b是一个字符串变量，函数名中的2就是英文中to的意思，也就是把num数值类型转化成str字符类型。str2num就是这个函数的反函数，这两个命令结合，可以实现特定的功能，比如提取一个数字的最高位： a=123456 b=num2str(a) c=b(1) d=str2num(c) 2.3for循环 ​ for循环的语法是： 12345678910for 数值变量=向量 执行语句end---其含义是，数值变量会取向量中的每一个值，然后执行语句，在执行语句中，数值变量是一个1*1的矩阵。比如for a=[0 1 3]---则会让a=0，执行语句，然后a=1，执行语句，最后a=3，执行语句。这里容易和赋值语句混淆，因为a=[0 1 3]是一个数值变量赋值，赋值后a是个向量，但加上了for后，a是1*1矩阵。另外，在数值变量赋值那段，我们说过有一种常用的赋值方法是&quot;a=初始值:步长:终值&quot;，其结果是把a赋值成一个向量，因此这也广泛用于for语句中 for a=初始值:步长:终值 ---则在执行语句中，a是一个遍历初值到终值的1*1矩阵。","categories":[],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://nymrli.top/tags/Matlab/"}]},{"title":"中文Bois模式界面","slug":"中文Bois模式界面","date":"2019-01-23T05:40:19.000Z","updated":"2019-01-23T05:42:54.257Z","comments":true,"path":"2019/01/23/中文Bois模式界面/","link":"","permalink":"https://nymrli.top/2019/01/23/中文Bois模式界面/","excerpt":"","text":"暗夜精灵的Bois界面。觉得还挺友好的。","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"Chrome开发者工具Network","slug":"Chrome开发者工具Network","date":"2019-01-23T05:38:12.000Z","updated":"2019-01-23T05:39:27.448Z","comments":true,"path":"2019/01/23/Chrome开发者工具Network/","link":"","permalink":"https://nymrli.top/2019/01/23/Chrome开发者工具Network/","excerpt":"","text":"Chrome开发者工具中Network功能介绍 第一列Name:请求的名称，一般会将URL的最后一 部分内容当作名称。 第二列Status: 响应的状态码，这里显示为200，代表响应是正常的。通过状态码，我们可 以判断发送了请求之后是否得到了正常的响应。 第三列Type: 请求的文档类型。这里为document, 代表我们这次请求的是一个HTML文档,内容就是一些HTML代码。 第四列initiator: 请求源。用来标记请求是由哪个对象或进程发起的。 第五列Size: 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示from cache。 第六列Time:发起请求到获取响应所用的总时间。 第七列Waterfall:网络请求的可视化瀑布流。 响应中分General部分，请求头、响应头： 其中General含： Request URL为请求的URL， Request Method为请求的方法 Status Code为响应状态码， Remote Address为远程服务器的地址和端口 Referrer Policy为Referrer判别策略。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"AU使用","slug":"AU使用","date":"2019-01-23T05:36:05.000Z","updated":"2019-01-23T05:36:39.080Z","comments":true,"path":"2019/01/23/AU使用/","link":"","permalink":"https://nymrli.top/2019/01/23/AU使用/","excerpt":"","text":"AU学习使用 留人声、去伴奏 First. ▲侧边声道电平控制微弱，中置声道电平控制效果强。 ▲交叉渗透，越大伴奏声音越不明显 Second. 前面几排调低到满意。（童声高音频率范围为260-880Hz,低音频率范围为196-700Hz,女声高音频率范围为220-1.1KHz,低音频率范围为200-700KHz,男声高音频率范围为160-523KHz低音频率范围为80-358Hz. 国际通信标准制定为300Hz-3400Hz! ） 留伴奏、去人声 ···选中所有，菜单栏-收藏夹-移除人声","categories":[],"tags":[{"name":"多媒体","slug":"多媒体","permalink":"https://nymrli.top/tags/多媒体/"}]},{"title":"Charles配置","slug":"Charles配置","date":"2019-01-23T05:32:21.000Z","updated":"2019-01-23T05:33:19.644Z","comments":true,"path":"2019/01/23/Charles配置/","link":"","permalink":"https://nymrli.top/2019/01/23/Charles配置/","excerpt":"","text":"Charles配置 下载SSL证书 设置SSL端口 *为通配IP网址，一般SSL的端口都是443 手机抓包 打开Charles代理 具体配置，电脑端不用做任何配置，但是需要把防火墙关掉（这点很重要）！charles需要设置下代理端口：进入Proxy，点击Proxy Setting, 端口设置为8888（一般默认为这个） 配置手机SSL证书 然后手机打开浏览器输入chls.pro/ssl下载证书 小米手机安装charles证书 1.使用第三方浏览器下载.pem 格式的文件 （我使用的是QQ浏览器）2.将这个文件放入小米的 DownLoad 文件夹下 (这步也可以不做，只要在4中的从存储设备安装能找到这个文件就行)3.将.pem 文件修改为.crt 格式4.设置—更多设置—系统安全—加密与凭据—-从存储设备安装–选择文件，选定该文件 注：本人用的是小米6。 手机设置代理 其中PAC地址打开Cmd，输入ipconfig查看 参考博客: Charles配置 https://blog.csdn.net/liulanghk/article/details/46342205 https://www.jianshu.com/p/7a88617ce80b Charles使用 http://www.bubuko.com/infodetail-2252870.html","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"}]},{"title":"Python中对时间戳、时间的处理","slug":"Python中对时间戳、时间的处理","date":"2019-01-23T02:17:34.000Z","updated":"2019-01-23T02:17:44.466Z","comments":true,"path":"2019/01/23/Python中对时间戳、时间的处理/","link":"","permalink":"https://nymrli.top/2019/01/23/Python中对时间戳、时间的处理/","excerpt":"","text":"Python中对时间戳、时间的处理time模块获得时间戳123timestmamp = time.time()&gt;&gt;&gt; # 1548208280.4581678 将时间戳转换成时间12345678import timetimestamp = 1462451334timeArr = time.localtime(timestamp) # 转换成时间数组print(timeArr)# &gt;&gt;&gt;time.struct_time(tm_year=2016, tm_mon=5, tm_mday=5, tm_hour=20, tm_min=28, tm_sec=54, tm_wday=3, tm_yday=126, tm_isdst=0)dt = time.strftime(\"%Y-%m-%d %H:%M:%S\",timeArr) # 指定转换成时间格式print(dt) 将时间转换成时间戳 利用strptime()函数将时间转换成时间数组 利用mktime()函数将时间数组转换成时间戳 123456import timedt = \"2016-05-05 20:28:54\"timeArray = time.strptime(dt, \"%Y-%m-%d %H:%M:%S\") #转换成时间数组timestamp = time.mktime(timeArray) #转换成时间戳print (timestamp)# &gt;&gt;&gt; 1462451334.0 重新格式化时间 利用strptime()函数将时间转换成时间数组 利用strftime()函数重新格式化时间 1234567import timedt = \"2016-05-05 20:28:54\"timeArray = time.strptime(dt, \"%Y-%m-%d %H:%M:%S\") #转换成时间数组dt_new = time.strftime(\"%Y%m%d-%H:%M:%S\",timeArray) #转换成新的时间格式(20160505-20:28:54)print (dt_new) 按指定的格式获取当前时间12345678import time#获取当前时间time_now = int(time.time()) time_local = time.localtime(time_now)# 转换成localtimedt = time.strftime(\"%Y-%m-%d %H:%M:%S\",time_local)# 转换成新的时间格式(2016-05-09 18:59:20)print(dt)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"基础网络知识","slug":"基础网络知识","date":"2019-01-22T11:31:47.000Z","updated":"2019-01-23T03:53:41.909Z","comments":true,"path":"2019/01/22/基础网络知识/","link":"","permalink":"https://nymrli.top/2019/01/22/基础网络知识/","excerpt":"","text":"什么是客户端、服务器端?客户端 :​ 发送数据、接收返回数据端 服务器:​ 处理数据端 TCP :面向连接—&gt; 打电话(相互回复,一来一回) 客户端向服务器端 拨号 , 三次握手 , UDP :面向无连接 –&gt; 寄快递(寄出去就不管了). 比如 : 直播 UDP四层结构 网络访问层(链路层): 物理连接设备(网线)、MAC地址（物理地址） 互联网层： IP地址（定位设备） 传输层： port (端口号) : 表示通信进程,将数据交给哪个应用处理 应用层： 自己定义的协议（处理字符串消息的方法） port : 知名端口 : 0 - 1023，有指定的应用程序 可自由使用的端口 : 1024 - 65535 ▲广播只能使用UDP，TCP没有广播功能。一般广播只用在局域网内（路由器不转发广播）。 套接字(socket) ：特殊的设备文件 ， 写网络应用程序的接口，写入后就是发送，接收就是读取。 应该类似于 esp8266吧… Python演示程序服务器端程序 123456789101112import sockets = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) '''参数说明:AF_INET IPv4STREAM TCPSOCK_DGRAM UDP'''server_addr = ('127.0.0.1',8888) # 本地回环地址 , 端口s.bind(server_addr) # 绑定、传入信息data,cilent_addr = s.recvfrom(1024) # BUF_SIZE指定接收数据长度 , (数据内容,客户端地址)s.sendto(data,cilent_addr) # 给客户端发送数据 客户端程序1234import sockets = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) server_addr = ('192.168.43.3',8888)s.sendto(b'hello',server_addr) 广播程序 255.255.255.255为广播地址 广播端接收程序 123456789101112import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)PORT = 9999s.bind( ('', PORT) ) # 这边必须是'',不能为自己的IP(否则只接受自己IP的,不接受255.255.255.2555的广播)print('Listening for broadcast at ', s.getsockname())while True: data, address = s.recvfrom(65535) print('Server received from &#123;&#125;:&#123;&#125;'.format(address, data.decode('utf-8'))) 广播发送程序 12345678import socket s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)s.setsockopt(socket.SOL_SOCKET,socket.SO_BROADCAST,1)# 创建套接字,UDP默认没有广播权限PORT = 9999network = '&lt;broadcast&gt;'# &lt;==&gt; network = '255.255.255.255's.sendto(b'hel',(network,PORT)) 拓展 :大端和小端模式的概念 网络通信时 通常使用大端 Linxu下ifconfig命令: eth0 网卡 wlan0 无线网卡 偶然发现安卓开热点的局域网地址是192.18.x.x，而苹果的热点局域网IP地址是172.20.x.x，于是搜了了解下 192.168网段是一种私有IP地址网段，任何人在私有网络中都可以任意使用这些IP地址，但是如果要连接外网就要使用网络地址转换NAT技术进行转换后才能连接外网； 在宽带路由器上一般默认的内网IP地址为192.168.0或192.168.1网段，它是经过路由器的NAT技术转换为WAN接口的公用IP地址而连接外网的； 这样的私有IP地址除了这个网段外，还有B类网络的172.16-172.31及A类网络的10网段都是私有IP地址。","categories":[],"tags":[{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Jupyter使用","slug":"Jupyter使用","date":"2019-01-21T02:46:56.000Z","updated":"2019-01-21T03:19:14.826Z","comments":true,"path":"2019/01/21/Jupyter使用/","link":"","permalink":"https://nymrli.top/2019/01/21/Jupyter使用/","excerpt":"","text":"准备安装pip install jupyter 运行jupyter notebook 基础概念与操作Jupyter有三种类型的cells： code cells markdown cells raw cells 常用的是code cells和 markdown cells类型。 Cells状态分为命令模式和编辑模式，Enter进入编辑模式，ESC进入命令模式，命令模式和编辑模式下支持很多操作快捷键，非常好用。 常用命令模式快捷键： y: 单元进入代码状态 m: 转入markdown状态 r：转入raw状态 a: 上方插入新单元 b：下方插入新单元 x：剪切选中单元 c: 复制选中单元 shift-v：粘贴到上方单元 v：粘贴到下方单元 d,d（连续按两次d）:删除选中单元 z：恢复最后删除单元 ctrl+Enter:运行本单元，两种模式都适用 shift+Enter：运行本单元，并跳到下个单元，两种模式都适用 alt+Enter：运行本单元，并在下方插入新单元，两种模式都适用 常用编辑模式快捷键： Tab：代码补齐或缩进 Shift+Tab：调用方法提示，非常有用，在调用包中函数时，对于函数中的使用说明和相关参数配置，按两次shift+Tab可获取详细的方法提示。 Ctrl+]：缩进 Ctrl+[ : 解除缩进 Ctrl+A: 全选 Ctrl+Backspace：删除光标前面本行所有的内容 Ctrl+Delete:删除光标后本行所有的内容 Shift+Home：往前选取本行所有内容 Shift+End：往后选取本行所有内容； 执行当前cell，并自动跳到下一个cell：Shift Enter执行当前cell，执行后不自动调转到下一个cell：Ctrl-Enter载入代码%load /Users/chenqionghe/test.py 插件jupyter notebook 写代码自动补全进入命令行环境，有两种方式进入命令行。 方法1：通过anconda navigator界面，选择environments，选择对应环境名，选择open terminal 方法2：直接使用cmd或者terminal等终端进入命令行。激活你想要配置代码补全的环境（如果是默认环境不用激活） 1.安装nbextensions12$ pip install jupyter_contrib_nbextensions -i https://pypi.mirrors.ustc.edu.cn/simple$ jupyter contrib nbextension install --user 2.安装nbextensions_configurator12$ pip install --user jupyter_nbextensions_configurator $ jupyter nbextensions_configurator enable --user 效果如图","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"河海大学AI+机器人冬令营(12-26)","slug":"河海大学AI-机器人冬令营","date":"2019-01-19T14:31:19.000Z","updated":"2019-01-31T14:09:48.482Z","comments":true,"path":"2019/01/19/河海大学AI-机器人冬令营/","link":"","permalink":"https://nymrli.top/2019/01/19/河海大学AI-机器人冬令营/","excerpt":"","text":"河海大学AI+机器人冬令营(19-26)The First Day~1911:50和CXY从学校出发，坐地铁的途中感觉比想象中舒服多了，没有很多挤着急着回家的学生党。 宾馆打卡13:30到尚客优宾馆，环境挺好。还有个办公桌,很舒服。 在房间里待到了大概3点，人都差不多到齐了以后，河海的负责人张老师带领我们去了河海大学。 校门口打卡 计软院的副院长、该活动的负责人幽默、诙谐地给我讲了讲活动背景、及要求和合作的机器人公司优必选。 下面是机器人表演舞蹈串烧的照片。关节自由多真的很多啊….很多很难的动作~ 介绍环节大约在4点就结束了。之后是在图书馆门口的签名墙上花费了巨大的时间，每个人都单独拍了两次照，说是要给我们留在纪念册上，很期待呢。 100号人拍完照已经是5：30左右了，拿到饭票后，院长就带我们前往了食堂。平常的学生食堂似乎已经关门了，接待我们的是一个据说连河海本校学生也不知道的xx食堂。 食堂打卡大家围在圆桌上等饭吃，^_^ 饭终于上来了O(∩_∩)O，两荤一小荤+两素，水果+酸奶的组合已经非常不错了，下午3点才吃午饭的我，表示强行吃完这些后撑得不行。 吃完后，负责人告诉我们可以回去了。找到了南邮的其他人，我们就浩浩荡荡地回宾馆了，河海的新校区很大，给我的感觉跟南理工一样，但南理工由于居民区的存在可能显得更热闹点，放假的河海闲的挺冷清的。天黑的很快，我们开着导航，最终成功回到了宾馆。 19号的活动大致就结束了。 The Second Day~20冬令营今天算正式开营，7:30要求在宾馆集合。床挺软的，睡得还行，早上却被一个不太好的梦在大约6:50做哟与惊醒，但还是在床上黏到了7：15的闹钟响。起了后以为应该算早的了，但最后在7：31的时候才弄好，到了一楼大厅，发现很多人都已经到了，看来大家的热情还很高涨。老师也很干脆利落，7:33就直接出发去学校了。 7:33出发，到河海的校门口大约在7:40左右。冬青食堂在学校的西北角，要走进去很多，到的时候约为7:50。比规定的时间8:10早到了15分钟，结果我们100号人就在食堂门口等了大约15分钟QAQ。 事实证明应该不需要这么早集合！ 早上是包子+稀饭，配上少许的拌饭菜–咸菜，早餐就算勉强吃完了。 教学楼打卡早上9:00上课，非常准时。 上午的任务是组装好机器人，是个挺有逼格的机器人。从开箱到拼装，都交给我们完成了。据说这个是卖2W+的教育类机器人，顺丰快递单上表明的价格似乎是20W，运费都要110+。 开箱 组成 终于拼好了 与机器人交互需要连接WIFI和蓝牙，又折腾了好久才终于连上，期间我的同伴还错连了一个女生的机器人，瞎几把按了几个好玩的东西，引得女生大吼：“谁连了我的机器人啊”。 玩了玩几个高难度动作：单手俯卧撑、舞蹈串烧……就11:30了，上午的授课就算结束了。 仍是食堂打卡水果换成了小橘子，肯定没有香蕉好吃啦，期望明天是苹果^_^ 档案袋资料,在上午结束后发的。但开营式还要等河海的领导到齐后才能开，大约定在了明天21号的下午。 档案袋 学员卡 下午讲了很久的Linux的基础知识。=.=很无聊啊，我连《机器学习Python实践》一本书都快读完了。 下午5:30挺准时下课的，6:30就要上课了，所以只好直接去食堂就餐了。 晚上6:30开始教授的是vim的基本操作，小测是让我们用VIM写个C程序编译，然后在最后结束的时候让我们10个人组个组，一起学习。队名、口号想了很久，最后很鸡贼的选了yeah当口号，不如跳舞是我们的队名。 表上说是7:30结束的，到最后，我们组是最后一个完成的，时间已经是8:30了。到宾馆几乎9点。 解决了Markdown的渲染问题TypeError: Cannot set property &#39;lastIndex&#39; of undefined 再码码代码也就休息了，希望今天能睡个好觉~ The Third Day~21早上还是很早就醒了，不知道为什么睡不深。 走的时候看了一下档案袋，想到了下午有开幕式，结果还是忘记了带营员证，结果只好中午吃饭后跑回来拿。 早上吃的是还是豆浆、粥，肉包，与昨天不同的是，菜包已经没了，很有可能是大家都不爱吃，最后剩下了很多。虽然肉包的皮也很厚，但毕竟是个肉吧2333。还多了油条，辣榨菜，这两个是我比较喜欢吃的，配粥很下饭。 上午，在调呼吸灯，感觉记忆力退化的很厉害，当初的PWM现在已经都不太会了。调了挺久，到中午吃饭的时候，才调出来。 下午，主要在看MMDR_N4的算法，总算厘清了思路，可以直接用了。授课方面的话介绍的是舵机的使用，只不过由于机器人用的是数字舵机，操作比较方便，再加上API封装的比较好，完成的就很轻松，不需要自己手写PWM。 在两点的时候，凑齐了各方的领导，终于在图书馆举办了开幕式。 结束的还挺迅速的，稍微玩了下手机就结束了。 晚上的任务是完成布置的作业: 金鸡独立： 保存机器人初始的舵机状态 控制舵机的方式实现金鸡独立（腿抬高，手臂动作） 站稳 恢复舵机状态 使用APP上的回读编程，完成一个动作序列（可以加音乐） 保存到机器人上，通过ubtRobotStartAction接口调用自己编排的动作 由于脚掌体积较大,所以将原来向后的动作加了个往前抬腿，转动脚踝的动作，使得平衡出了很大的问题，最终弄到9点都还没弄完，只好留到第二天完成了。 回到宾馆后，跟活动室的学长们视频了一波，汇报了一下进度和了解了下他们的情况，最后将看的MMDR_N4抽出，写了个文档，睡觉的时候都快11:30了。今天睡得比较晚了。 The Fourth Day~22早上7:15的闹钟,黏了7分钟才起。隔天没Debug出来，睡的也比较晚，导致起的时候非常的疲倦。所幸的是，我们到楼下时发现老师还没来，大部队也还没走。等了好几分钟，看老师还没来，就带头直接去食堂了。早餐不同的是桃酥饼，和萝卜丝馅饼，吃完之后才收到老师的消息，得知老师也没爬起来。 上午介绍的是机器人的五个传感器的使用，主要是使用它提供的Api。传感器有： 压力、触摸、超声波、红外、气温气压。这些都比较基础，就一直在看optimization里的优化细节。WDD问了下Andriod方面的需求，就花了时间整理了下思路，安排了人员。 下午据说有电视台采访，于是没怎么看Apollo的资料，认真调了下机器人的代码。就在准备展示我们的作品，上电视的时候，机器人的动作错了，导致没站稳直接摔到了。摄影小哥等我们调试了几分钟还没调好后，就放弃我们了:sob: 晚上跟前几天比结束的很早，讲了点TCP/UDP及网络的基础知识，让我们写了个UDP接收信息的程序就结束了。这方面感觉老师讲的还挺好的，经验、涉及面很丰富。 The Fifth Day~23图像处理，介绍了人脸检测、人脸识别、表情检测的接口。 具体的我也忘记做了啥了…我应该都在敲机器学习. The Fifth Day~24下午1点还是2点，公布了项目的要求。大家就都热火朝天的开始干起来了，我们进度算很快了，吃饭前就完成了所有基础功能，我把图灵机器人和天气的Api都已经写好了。 晚上处理了人脸跟踪的功能，但碰到了python2中字符串不可变的问题，确实很棘手处理了很久才搞定。 主要发现的问题是: 当字符串&lt;4时,如’123’，那么输出的话是’’. 当赋值为a=&#39;notfound&#39;时,,怀疑是zhx后面还是多余的空格而没有被输出出来 当写成a=&#39;notfounda&#39;的时候，if判断得写成 if a == &#39;notfound\\x00&#39; The Sixth Day~25完成项目的拓展功能和答辩。我们昨天就完成了所有的基础功能，第二天的任务就是添加拓展功能。我们选择了三个：随机播放或中途暂停音乐、语音识别 、 人脸识别跟踪行走。 除了语音识别功能，其实有不少在昨天晚上都已经搞定了，但是当天演示时却bug了。真的是很悲催，再加上抽签的运气不是很好，第二个就上场了，导致最后的演示效果很差。 计划2点开始演示，但真正的开始时间却是2:30，我们大约是3：10分演示的，由于机器人金鸡独立时摔倒的缘故，存储人脸的机器人重启了，导致人脸数据丢失而无法演示人脸跟踪。 后面几组演示的就比较幸运，第7组都已经是吃完晚饭6:30以后演示的了…真的抽签太看运气了。 虽然演示后结果不太令人满意吧，但好在大家也没有太沮丧。说实话，演示完后就已经没什么心思看别人的演示了。于是我和张志兴学长以及南大计软的一个女生交流了一会。向张志兴学长讨教了不少单片机方面的知识，张志兴学长很棒… 说实话我一直以为他是大二的… The Seventh Day~26忍了很久想吃面的欲望，最后一天，决定不吃食堂，找了河海外面的一家早餐店吃了面。 最后一天是闭营典礼，主要是副院长讲话，然后颁奖，昨天的答辩环节效果很差，注定了今天我们只能当观众。大家的心情都不是很好吧，毕竟都花了挺多心思，但没有获奖，真的挺可惜的。 颁完奖，拍完照，就解散了。我和我的小组成员留了一会，总结了一下这次很多地方的问题，以及交流了一下，主要是感觉对不起大家，我们完全是有能力获奖的，但由于种种原因而失败了，非常的遗憾。总结的过程被副院长听到了，很尴尬，他要我写篇感想23333，不慎惶恐。 总结结束后，我并不是很急着回学校，于是找张老师聊了聊天。得知张洪涛老师是内蒙古人，大学就读于杭州，现在工作于深圳，真的是横跨了整个中国。他也是自动化专业的，很大程度上也是因为家庭原因，直接选择了工作，据他所说大学是玩了4年，91年生的，目前也工作了6-7年了，但我感觉他的知识面还是挺广的，他讲解的网络方面的一点东西对我还是有不少启发的，所以也不知他说的是不是真的。 跟他交流了大概两个小时吧，主要是自动化的学科方向，以及之后的工作方向。感觉找前辈聊天真的是个很愉快的过程，不管他的经验是否能够借鉴，但每个人的经历都耐人寻味，想了解更多人的生活。 10点半结束的，大约12点半才离开河海，上地铁回南邮。 下面是我提交的感想，院长说会帮我润色一下的，也不知道他刊在哪里了。 大学入学以来，一直都在为了竞赛和学业而疲于奔命。经常为生活圈子日益狭窄，压力日益繁重而恐慌。于是经过一系列思考后，最终在数模美赛、电赛培训…多种寒假活动中选择参加了由江苏省教育部发起，河海大学组织的“AI+机器人”冬令营活动。选择这个冬令营原因，一是因为机器人是个交叉的学科，在接触的过程中，即可以了解硬件，又会涉及软件开发，对个人能力都会有比较高的提高；二是，想找点真正感兴趣的东西做做放松下身心，而不是像在学校那样再为了能力分和绩点终日劳神费心。 冬令营聚集了江苏省各所高校里有能力和想法的学生，在这里我们能碰到很多志同道合的朋友，刚来初到的前几天，我认识了我们学校同批参加冬令营的同学。后来几天经过交流认识了各个学校参加各种项目的同学，有做机甲大师的、有参加飞思卡尔的，有弄Robocup的……在不上课的时间里，就听他们讲说了各地的轶事、各个方面的细节…… 为时一共七天的冬令营，前五天，张洪涛老师都非常耐心地带着大家一个一个模块完成任务，每一阶段的成功，都极大地调动了我们的积极性和成就感。也为我们能够从容接受最后的项目实战做了很大的铺垫。 最后两天是完成项目，要求十个人组成一只队伍，分布式地操作机器人。在提出五个基本要求的基础上，张老师也给了我们一点启发性的意见作为评比的加分项。24号下午项目要求一公布出来，我们就在组内分配好了任务。由于基础工作比较明确，我们很快的就分配好了各自的工作，经过大家的全身心投入，我们很顺利的在吃晚饭之前就几乎把所有基础功能都做完了，但是却没有进行即时阶段性的汇总，导致第二天展示前调试比较匆忙，这也是比较可惜的地方。 吃完晚饭后，大家都很快的回到了机房，继续为更好的功能而调试。晚上规定在6:30-7:30的交流时间之后就能回去了，但为了调试代码，我们全组都选择留了下来，直到9点左右才走。当时我们在攻克的是跟踪人脸行走功能，困扰我们的是Python2上的编码问题，无论是否检测得到人脸都会向前行走。所以虽然效果能算达到，但并不是为了单纯演示就行，我们还是决定从原理上彻底查明这个的原因。由于负责的同学没怎么接触过这个问题，于是我们花了很大的功夫，在调试了N遍以后终于找了原因和解决方案。事实上也证明了我们的付出没有白费，第二天有其他小组也碰到了这样的问题，我们为他们讲明了原因，他们也很快的实现了这个功能。 我们的拓展功能还有随机播放或中途暂停音乐及语音识别，我们第二天的时间全都在测试这些。但由于语音识别的效果比较差，最后我们还是只能选择放弃演示。而播放音乐的功能全在演示前的一段时间被调错而无法使用。所有最终我们的演示效果很差，成绩也不是很理想。 作为我们队长，以及在接触Python比较多的情况下，没有带领团队获得比较好的成绩我还是比较自责的。但回想整个完成的过程，其实感慨、收获还是颇多的。首先是学长学姐对我的支持，大三学长张志兴个人能力很强，但有时我的错误指挥，他都给了很大的宽容。其次是大家团队合作的热情和态度，碰到BUG大家甚至会不吃饭选择一起解决；还有由于人数原因而后来被分配到我们小组的周轶凡，虽然跟组离得很远，逐渐边缘化，有时我甚至都没有想起他来，但是他都会非常积极地要求任务和积极参加讨论，让我感受到了团队合作的感觉，感受到了we are a team!再者是徐弘毅的热情，他跟我同是大二的，由于没怎么接触过python，还特地带了Python的书，碰到了那个编码问题，也是钻研了很久；还有的是一个比较好玩的事，当初刚开始合作完成项目的时候，大家连人名都不知道，偶然听到一个张志兴的名字，就一直把徐弘毅叫做张志兴，因为每次这么叫他队友时，徐弘毅总是第一个回头的…… 但同时我们确实也存在很多的问题：答辩展示的重点并不是很明确，有些基础功能觉得大家都展示过，自己就太轻视而可能没有展示；拓展功能完成的太顺利而没有介绍到……都是一些答辩上完成的不够好的地方，以及临场应变还不熟练。还有的是缺少团队合作经验，导致很多程序架构方面的事都没有说清楚，比如Python在缩进上要求很严格，而我在我的笔记本上汇总总程序都是4个空格一层缩进，他们在机器人上的代码都是8个空格一层的。但队友都比较好心，没有提出问题，而是默默的每次都帮我改好，直到最后演示前又发了一遍代码后才发现这个由于没有沟通而导致严重的架构问题。同时还有，分工上也太牵强了，虽然基础功能分工的比较明确，都挺好的实现了，但是拓展功能，由于我做该方面做的比较多，我没有分配下去而是选择了一人承担，导致汇总以及拓展功能的调试都落在我身上，在展示前一段调试的时间里，哪边出了问题都得我去处理，最后确实有点无暇分身、弄得很乱…… 这次的项目有很多好好坏坏，但这次的合作，让我们从全都不认识，到现在能相互开玩笑；不能写Python代码到能写Python项目，真的成长了太多。虽然成绩比较可惜，但是我为认识他们而高兴。在此，我要再次感谢我的队友：张志兴、徐弘毅、王青雅、侍亚东、林丹丹、陈晓谦、陈怀新。大家在各自的领域内都是大手子，而这次我能荣幸的担任他们的队长，真的是很不容易，从心里感谢他们的包容和理解、配合与支持。 因为你们，不虚此行~ 附: 安排表 三角包子(实心,没馅的!!! 两大荤、一小荤、两素的套餐，多图警告","categories":[],"tags":[{"name":"生活小记","slug":"生活小记","permalink":"https://nymrli.top/tags/生活小记/"}]},{"title":"DFS专项练习","slug":"DFS专项练习","date":"2019-01-19T12:53:03.000Z","updated":"2019-01-19T12:53:26.486Z","comments":true,"path":"2019/01/19/DFS专项练习/","link":"","permalink":"https://nymrli.top/2019/01/19/DFS专项练习/","excerpt":"","text":"DFS专题leetcode 104. 二叉树的最大深度123456789101112131415161718/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */#include&lt;algorithm&gt;class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(root==NULL)return 0; int l1=maxDepth(root-&gt;left); int l2=maxDepth(root-&gt;right); return max(l1,l2)+1; &#125; DFS模板总结1234567891011121314151617181920212223void dfs()//参数用来表示状态 &#123; if(到达终点状态) &#123; ...//根据题意添加 return; &#125; if(越界或者是不合法状态) return; if(特殊状态)//剪枝 return ; for(扩展方式) &#123; if(扩展方式所达到状态合法) &#123; 修改操作;//根据题意来添加 标记； dfs（）； (还原标记)； // visited[i] = 1; //是否还原标记根据题意 //如果加上（还原标记）就是 回溯法 // visited[i] = 0 &#125; &#125; &#125; 全排列问题1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std; int p[10]=&#123;0&#125;;bool vis[10]=&#123;0&#125;;int n;void dfs(int x)&#123; if (x==n+1)&#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;p[i]&lt;&lt;\" \"; cout&lt;&lt;endl; return ; &#125; for (int i=1;i&lt;=n;i++)&#123; if (vis[i]==false ) &#123; p[x] = i; vis[i] = true; dfs(x+1); vis[i] = false; &#125; &#125;&#125; int main()&#123; n=4; dfs(1); return 0;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"}]},{"title":"Typora可选选项","slug":"Typora可选选项","date":"2019-01-19T12:51:11.000Z","updated":"2019-01-19T12:52:14.319Z","comments":true,"path":"2019/01/19/Typora可选选项/","link":"","permalink":"https://nymrli.top/2019/01/19/Typora可选选项/","excerpt":"","text":"用了这么久markdown才发现原来支持Latex的符号公式，但是在Typera中需要自行设置出来，文件--&gt;偏好设置--&gt;markdown拓展语法（内联公式）、代码块（显示行号） Latex 公式：$\\frac{3}{2}​$ 带有行号的代码块 12345#include &lt;stdio.h&gt;int main()&#123; printf(\"hello world\"); return 0;&#125; 其他功能自行发现吧！^_^","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"Latex学习","slug":"Latex学习","date":"2019-01-19T12:49:31.000Z","updated":"2019-01-20T13:56:04.756Z","comments":true,"path":"2019/01/19/Latex学习/","link":"","permalink":"https://nymrli.top/2019/01/19/Latex学习/","excerpt":"","text":"基本概念和使用Hello, world!12345\\documentclass&#123;article&#125;%这里是导言区\\begin&#123;document&#125;Hello, world!\\end&#123;document&#125; 请注意，TeX 对控制序列的大小写是敏感的部分控制序列还有被方括号[]包括的可选参数。出现了控制序列 begin，这个控制序列总是与 end 成对出现。这两个控制序列以及他们中间的内容被称为「环境」；他们之后的第一个必要参数总是一致的，被称为环境名。 只有在 “document” 环境中的内容，才会被正常输出到文档中去或是作为控制序列对文档产生影响。也就是说，在 \\end{document} 之后插入任何内容都是无效的。 \\begin{document} 与 \\documentclass{article} 之间的部分被称为导言区。导言区中的控制序列，通常会影响到整个输出文档。 输出中文使用命令行输入texworks打开tex编辑器 1234\\documentclass[UTF8]&#123;ctexart&#125;\\begin&#123;document&#125;你好，world!\\end&#123;document&#125; 文档类从 article 变为 ctexart； 增加了文档类选项 UTF8。 12345678\\documentclass[UTF8]&#123;ctexart&#125;\\title&#123;你好，world!&#125;\\author&#123;Liam&#125;\\date&#123;\\today&#125;\\begin&#123;document&#125;\\maketitle你好，world!\\end&#123;document&#125; 笔记中文问题面对中文编码问题，CJK被淘汰，使用ctexart编译中文 ▲注意，编译方式必须改为xeLaTex，只有部分环境下 pdfLaTex 也可以编译成功 1234\\documentclass[UTF8]&#123;ctexart&#125;\\begin&#123;document&#125;您可以看到，说明你编译成功了！\\end&#123;document&#125; 标准文类 article：短文，评论，学术论文；无左右页区分，无章设置。对应中文类ctexart。 book：著作，学位论文；默认有左右页区分，章起右页。对应中文类ctexbook。 report：商业，科技，试验报告，默认无左右页区分，章起新页。对应中文类：ctexrep。 beamer：论文陈述幻灯片；提供多种主题式样，可方便更改幻灯片的整体风格。 常用宏包不是必须记住，需要用哪个现查即可，列出这些是为了浏览别人的源文件时知道人家调用了哪个宏包。 amsmath 公式环境和数学命令 amssymb 数学符号生成命令 array 数组和表格制作 calc 四则运算 caption 插图和表格标题格式设置 fancyhdr 页眉页脚设置 fancyvrb 抄录格式设置 fontspec 字体选择 geometry 版面尺寸设置 graphicx 插图处理 hyperref 创建超文本链接和PDF书签 longtable 制作跨页表格 multicol 多栏排版 ntheorem 定理设置 paralist 多种列表环境 tabularx 自动设置表格列宽 titlesec 章节标题格式设置 titletoc 目录格式设置 xcolor 颜色处理 xeCJK 中日朝文字处理和字体选择","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"Latex","slug":"Latex","permalink":"https://nymrli.top/tags/Latex/"}]},{"title":"每日codewars","slug":"每日codewars","date":"2019-01-19T12:47:50.000Z","updated":"2019-02-07T11:40:18.887Z","comments":true,"path":"2019/01/19/每日codewars/","link":"","permalink":"https://nymrli.top/2019/01/19/每日codewars/","excerpt":"","text":"Codewars12.17Sum without highest and lowest number1234567891011121314151617181920212223242526272829#include&lt;vector&gt;#include&lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int sum(vector&lt;int&gt; numbers)&#123; /* Sum without highest and lowest number &#123; 6, 2, 1, 8, 10 &#125; =&gt; 16 &#123; 1, 1, 11, 2, 3 &#125; =&gt; 6 */ if(numbers.empty()) return 0; if(numbers.size()==1) return 0; sort(numbers.begin(),numbers.end()); int sum=0; for( vector&lt;int&gt;::iterator it = numbers.begin()+1;it != numbers.end()-1;it++) sum += *it; return sum;&#125;int main()&#123; vector&lt;int&gt; n; n.push_back(1); n.push_back(3); n.push_back(5); cout &lt;&lt; sum(n); return 0;&#125; C++11支持的新特性12345vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5,7&#125;;// 支持了vector &#123;&#125;的初始化方式for(int i : a) cout &lt;&lt; i;//支持了for(:) 12.19reverseSum of positive 1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;algorithm&gt;/**Hex to Decimal**/int hexToDec(std::string hexString)&#123; reverse(hexString.begin(),hexString.end()); int base = 1; int sum =0 ; bool fu = 0; for(string::iterator it = hexString.begin() ; it != hexString.end() ; it++ )&#123; if( *it == '-') &#123;fu = 1; continue;&#125; int num = 0; if( *it &gt;= 'A' &amp;&amp; *it &lt;= 'F' ) num = *it - 'A' + 10; else if( *it &gt;= 'a' &amp;&amp; *it &lt;= 'f' ) num = *it - 'a' + 10; else num = *it - '1' + 1; sum += num * base; base *= 16; &#125; return fu?-sum:sum;&#125;//base来控制相应位数，Aa都要考虑，负数 12for(string::iterator it = hexString.begin() ; it != hexString.end() ; it++ )// *it 是 char类型的 12.20stoi、istringstream、sscanfHex to Decimal 12345#include &lt;string&gt;int hexToDec(const std::string&amp; hexString)&#123; return std::stoi(hexString, nullptr, 16); //return std::stoi(hexString, 0, 16);&#125; 123456#include &lt;ios&gt;int hexToDec(std::string hexString)&#123; int n; std::istringstream(hexString) &gt;&gt; std::hex &gt;&gt; n; return n;&#125; 123int hexToDec(std::string hexString)&#123; return (int)strtol(hexString.c_str(), 0, 16);&#125; 12345int hexToDec(std::string hex) &#123; int decValue; sscanf(hex.c_str(), \"%x\", &amp;decValue); return decValue;&#125; 12.21增强的for(ch : vowels )Vowel Count 123456789101112#include &lt;string&gt;using namespace std;int getCount(const string&amp; inputStr)&#123; int num_vowels = 0; vector&lt;char&gt; vowels = &#123;'a', 'e', 'i', 'o', 'u' &#125;; for(int it = 0; it != inputStr.size() ; it++ ) for(char ch : vowels ) if( ch == inputStr[it] ) num_vowels++; return num_vowels;&#125;/**const string&amp; inputStr**/for(string::const_iterator it = inputStr.begin() ; it != inputStr.end() ; it++) // 迭代器为const_iterator，而不是iterator 优秀解答： count_if12345678910111213141516171819202122232425int getCount(const string&amp; inputStr)&#123; return count_if(inputStr.begin(), inputStr.end(), [](const char ch) &#123; switch(ch) &#123; case 'a': case'e': case'i': case'o': case'u': return true; default: return false;&#125; &#125;);&#125;// &lt;=====&gt;#include &lt;string&gt;using namespace std;bool is_vowel(char c) &#123; return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');&#125;int getCount(const string&amp; inputStr) &#123; return count_if(inputStr.begin(), inputStr.end(), is_vowel);&#125; 12.22for_each和C11的匿名函数Invert values 123456789/**Invert values**/#include &lt;vector&gt;std::vector&lt;int&gt; invert(std::vector&lt;int&gt; values)&#123; std::vector&lt;int&gt; v2; for_each(values.begin(),values.end(),[ &amp;v2](int c)&#123; v2.push_back(-c); &#125;); return v2;&#125;// 学会使用了 for_each和C11的匿名函数 匿名函数参数1234[](int x, int y) &#123; return x + y; &#125; // 隐式返回类型[](int&amp; x) &#123; ++x; &#125; // 没有return语句 -&gt; lambda 函数的返回类型是'void'[]() &#123; ++global_x; &#125; // 没有参数,仅访问某个全局变量[]&#123; ++global_x; &#125; // 与上一个相同,省略了() 技巧: 没有return ， 则 lambda的返回类型是void 如果没有参数，则可以省略参数 捕获 值捕获 引用捕获 123456[] //未定义变量.试图在Lambda内使用任何外部变量都是错误的.[x, &amp;y] //x 按值捕获, y 按引用捕获.[&amp;] //用到的任何外部变量都隐式按引用捕获[=] //用到的任何外部变量都隐式按值捕获[&amp;, x] //x显式地按值捕获. 其它变量按引用捕获[=, &amp;z] //z按引用捕获. 其它变量按值捕获 12.23▲transform算法transform()提供以下两种能力： 1.第一形式有4个参数，把源区间的元素转换到目标区间。也就是说，复制和修改元素一气呵成； transform(sourceBeg,sourceEnd,destBeg,op) (1)针对源区间[sourceBeg,sourceEnd)中的每一个元素调用：op(elem) 并将结果写到以destBeg起始的目标区间内； (2)返回目标区间内“最后一个被转换元素”的下一个位置，也就是第一个未被覆盖的元素位置； (3)调用者必须确保目标区间有足够的空间，要不就得使用插入型迭代器； (4)sourceBeg于destBeg可以相同，所以，和for_each()算法一样，你可以使用这个算法来变动某一序列内的元素； (5)如果想以某值替换符合某一准则的元素，应使用replace()算法； (6)复杂度：线性； 12345678910#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int test()&#123; vector&lt;int&gt; coll1; for (int i=1;i&lt;9;i++) coll1.push_back(i); transform(coll1.begin(),coll1.end(),coll1.begin(),negate&lt;int&gt;()); for (int i=0;i&lt;8;i++) cout &lt;&lt; coll1.at(i) &lt;&lt;endl; //-1 -2 -3 -4 -5 .. -8&#125; 2.第二形式有5个参数，将前两个源序列中的元素合并，并将结果写入目标区间。 transform(source1Beg,source1End,source2Beg,destBeg,op) (1)针对第一源区间[source1Beg,source1End)以及“从source2Beg开始的第二源区间”的对应元素，调用:op(source1Elem,source2Elem) 并将结果写入以destBeg起始的目标区间内； (2)返回区间内的“最后一个被转换元素”的下一位置，就是第一个未被覆盖的元素的位置； (3)调用者必须保证第二源区间有足够空间（至少拥有和第一区间相同的空间大小）； (4)调用者必须确保目标区间有足够空间，要不就得使用插入型迭代器； (5)source1Beg，source2Beg，destBeg可以相同。所以，可以让元素自己和自己结合，然后将结果覆盖至某个序列； (6)复杂度:线性； 12345678910#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int test()&#123; vector&lt;int&gt; coll1; for (int i=1;i&lt;9;i++) coll1.push_back(i); transform(coll1.begin(),coll1.end(),coll1.begin(),coll1.begin(),multiplies&lt;int&gt;()); for (int i=0;i&lt;8;i++) cout &lt;&lt; coll1.at(i) &lt;&lt;endl; // 1,4,16,25...81&#125; http://lib.csdn.net/article/cplusplus/32641 Remove exclamation marks123456789101112131415161718#include &lt;queue&gt;#include &lt;string&gt;using namespace std;std::string removeExclamationMarks(std::string str)&#123; //your code here queue&lt;char&gt; st; for(string::iterator it = str.begin() ; it != str.end() ; it++) if( *it != '!') st.push(*it); string s; for(int i = st.size() ; i &gt;0 ; i--)&#123; s += st.front(); st.pop(); &#125; return s;&#125;// &gt;&gt;&gt; 2323!!asd ===&gt; 2323asd 12.24Maximum Multiple12345int maxMultiple(int divisor, int bound) &#123; // Your Code is Here ... Enjoy !!! if ( bound % divisor == 0) return bound; return divisor * ( bound / divisor);&#125; 12.25nth_element()函数 部分排序 头文件：#include&lt;algorithm&gt; 作用：nth_element(a+l,a+k,a+r) 它会使a这个数组中区间[l,r)内的第k大的元素处在第k个位置上(相对位置)，但是它并不保证其他元素有序！且第 n 个元素之前的元素都小于它，但不必是有序的。同样，第 n 个元素后的元素都大于它，但也不必是有序的。 排序后a[n]就是数列中第n+1大的数 12nth_element(intVect.begin(),intVect.begin()+3,intVect.end());cout &lt;&lt; intVect[2]&lt;&lt; endl; https://zhidao.baidu.com/question/1447317576049306340.html 12.26Mumbling1234567891011121314151617181920212223242526using namespace std;class Accumul&#123;public: static std::string accum(const std::string &amp;s) &#123; stringstream result; for (int i = 0; i &lt; s.length(); i++) result &lt;&lt; \"-\" &lt;&lt; string(1, toupper(s[i])) &lt;&lt; string(i, tolower(s[i])); return result.str().substr(1); &#125;&#125;;class Accumul&#123;public: static std::string accum(const std::string &amp;s) &#123; std::string result; for (int i = 0; i &lt; s.length(); i++) &#123; result.append(\"-\"); result.append(std::string(1,toupper(s[i]))); result.append(std::string(i,tolower(s[i]))); &#125; return result.substr(1,result.length()); &#125;&#125;; 12.27Highest and Lowest12345678910111213141516171819//[mySolution]#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;string highAndLow(const string&amp; numbers)&#123; string single; //每个字符 stringstream ss(numbers); //字符流 vector&lt;int&gt; s; //存储每个数字的vec while( getline(ss,single,' ') ) //根据空格分割 //while(ss &gt;&gt; s) s.push_back(stoi(single)); sort(s.begin(),s.end(),greater&lt;int&gt;()); //从大到小排序 //将整数拼合起来 stringstream sss; sss &lt;&lt; s.at(0) &lt;&lt; \" \" &lt;&lt; s.at(s.size() - 1) ; return sss.str();&#125; boost库1234567891011#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;boost&gt;using namespace std;using namespace boost;int main() &#123; string s = \" hello boost!! \"; trim(s); cout &lt;&lt; s &lt;&lt; endl;&#125; 返回 编译器允许的 int 型数 最大值std::numeric_limits&lt;int&gt;::max ()1.1Minimize Sum Of Array (Array Series #1)12345678910111213141516171819#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int minSum (vector&lt;int&gt;passed)&#123; sort(passed.begin(),passed.end()); int sum = 0 ; int n = passed.size(); for(int i=0;i&lt; n/2; i++)&#123; sum += passed.at(i) * passed.at(n-1-i); &#125; return sum ;&#125;int main()&#123; cout &lt;&lt; minSum(&#123;5,4,2,3&#125;); //最远的两个数相乘，内积 return 0;&#125; 函数形参为vec时，可以直接将{x1,x2,x3}当参数传入。 inner_product定义在 numeric 头文件中的 inner_product() 算法可以计算两个 vector 的内积。这个函数模板有 4 个参数：前两个参数是定义第 1 个 vector 的输入迭代器，第 3 个参数是确定第 2 个 vector 的开始输入迭代器，第 4 个参数是和的初值。算法会返回 vector 的内积。例如： cout &lt;&lt; inner_product(begin(passed),begin(passed)+n,passed.rbegin(),0) &lt;&lt; endl; 1.2关于删除可迭代对象中元素 123456789101112131415161718//正确写法std::list&lt; int&gt; List;std::list&lt; int&gt;::iterator itList;for( itList = List.begin(); itList != List.end(); )&#123; if( WillDelete( *itList) ) itList = List.erase( itList); //或者 List.erase( itList ); //反正就是不能让下标一下进两个，如果将++写在for里面，会导致删除后漏了一个元素判断 else itList++;&#125;//错误写法std::list&lt; int&gt; List;std::list&lt; int&gt;::iterator itList;for( itList = List.begin(); itList != List.end(); itList++)&#123; if( WillDelete( *itList) ) List.erase( itList);&#125; 错误原因：在调用erase方法之后使用“++”来获取下一个元素的位置，由于在调用erase方法以后，该元素的位置已经被删除，如果在根据这个旧的位置来获取下一个位置，则会出现异常。 在Python里面遍历删除元素时，下标问题，会使略过元素==&gt; 解决方法： if，else Disemvowel Trolls12345678910111213# include &lt;string&gt;std::string disemvowel(std::string str)&#123; for(std::string::iterator it = str.begin() ; it != str.end() ;)&#123; if ( *it == 'A' || *it == 'I' || *it == 'U' || *it == 'E' || *it == 'O' || *it == 'a' || *it == 'o' || *it == 'i' || *it == 'u' || *it == 'e' ) str.erase(it); else it++; &#125; return str;&#125; c++正则123456# include &lt;string&gt;# include &lt;regex&gt;std::string disemvowel(std::string str)&#123; std::regex vowels(&quot;[aeiouAEIOU]&quot;); return std::regex_replace(str, vowels, &quot;&quot;);&#125; 1.3在string中查找子串string:: string::find(string &amp;); 123456789101112131415161718int main()&#123; string a=\"abcdefghigklmn\"; string b=\"def\"; string c=\"123\"; string::size_type idx; idx=a.find(b);//在a中查找b. if(idx == string::npos )//不存在。 cout &lt;&lt; \"not found\\n\"; else//存在。 cout &lt;&lt;\"found\\n\"; idx=a.find(c);//在a中查找c。 if(idx == string::npos )//不存在。 cout &lt;&lt; \"not found\\n\"; else//存在。 cout &lt;&lt;\"found\\n\"; return 0;&#125; 当没有找到时返回string::npos 1.412345678910111213141516171819202122232425262728293031class CountDig&#123;public: static int nbDig(int n, int d);&#125;;using namespace std;//计算num中出现数字d的次数int contain(int num,int d)&#123; int n =0 ; while( num &gt;= 1)&#123; int ge = num % 10; num = num / 10; if( ge == d) n++; &#125; return n;&#125;//要求的成员函数int CountDig::nbDig(int n, int d)&#123; vector&lt;int&gt; v; for(int i=0 ; i &lt;= n ; i++) v.push_back( i*i ); int cnt =0; for_each(v.begin(),v.end(),[d,&amp;cnt](int x)&#123; int appn = contain(x,d); cnt += appn ; &#125;); return d==0?++cnt:cnt ; //由于contain函数会舍去0的情况，所以这边补上&#125; topow(int ,int) 丢精度问题尚未解决 1.5Compare Strings by Sum of Charsisalpha的使用，sum为int类型，当sum+= char类型的c时，实际加的就是c的ASCII码值 12345678910111213// Calculate the char-value of the stringint charvalue(std::string s)&#123; int sum = 0; for(char &amp;c : s)&#123; if(!std::isalpha(c)) return 0; sum += std::toupper(c); &#125; return sum;&#125;bool compare(std::string s1, std::string s2)&#123; return charvalue(s1) == charvalue(s2);&#125; 1.6号后开始认真复习考试周忙，空了好多练习 1.24缺少main函数报错 1.28 PTA求自定类型元素的平均12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Average( ElementType S[], int N );int main ()&#123; ElementType S[MAXN]; int N, i; scanf(\"%d\", &amp;N); for ( i=0; i&lt;N; i++ ) scanf(\"%f\", &amp;S[i]); printf(\"%.2f\\n\", Average(S, N)); return 0;&#125;ElementType Average( ElementType S[], int N )&#123; int i; ElementType sum; for(i=0;i&lt;N;i++) sum += S[i]; return sum/(ElementType)(N);&#125; 求单链表结点的阶乘和链表 + 阶乘123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node *PtrToNode;struct Node &#123; int Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */&#125;;typedef PtrToNode List; /* 定义单链表类型 */int FactorialSum( List L );int main()&#123; int N, i; List L, p; scanf(\"%d\", &amp;N); L = NULL; for ( i=0; i&lt;N; i++ ) &#123; p = (List)malloc(sizeof(struct Node)); scanf(\"%d\", &amp;p-&gt;Data); p-&gt;Next = L; L = p; &#125; printf(\"%d\\n\", FactorialSum(L)); return 0;&#125;// ----完成部分----int FactorialSum( List L )&#123; struct Node* p = L; int sum = 0; while( p )&#123; int fac=1; for(int i=1;i&lt;=p-&gt;Data ;i++) fac *= i; //计算N的阶乘 sum += fac; p = p-&gt;Next; &#125; return sum;&#125; 统计某类完全平方数平方数,取出各位1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;math.h&gt;int IsTheNumber ( const int N );int main()&#123; int n1, n2, i, cnt; scanf(\"%d %d\", &amp;n1, &amp;n2); cnt = 0; for ( i=n1; i&lt;=n2; i++ ) &#123; if ( IsTheNumber(i) ) cnt++; &#125; printf(\"cnt = %d\\n\", cnt); return 0;&#125;int IsTheNumber ( const int N )&#123; int n = (int )sqrt(N); if( N == n*n ) &#123; int arr[10] = &#123;0&#125;; int m = N; while( m &gt; 0)&#123; int tmp = m%10; arr[tmp] += 1; for( int i = 0 ;i&lt;10;i++)&#123; if( arr[i] == 2)return 1; &#125; m /= 10; &#125; return 0; // 注意这边得考虑 &#125;else return 0;&#125; 1.29统计个位数字1234567891011121314151617181920212223#include &lt;stdio.h&gt;int Count_Digit ( const int N, const int D );int main()&#123; int N, D; scanf(\"%d %d\", &amp;N, &amp;D); printf(\"%d\\n\", Count_Digit(N, D)); return 0;&#125; Count_Digit ( const int N, const int D )&#123; int cnt =0 ; if ( N == 0 ) return 1; //需要考虑 N = 0的情况 int m =N&gt;0?N:-N; //以及负数情况, 这边取绝对值 while(m &gt; 0 )&#123; int tmp = m%10; if( tmp == D) cnt++; m /= 10; &#125; return cnt;&#125; 6-10 阶乘计算升级版 —-高精度题解 123456789101112131415161718192021222324252627282930void Print_Factorial ( const int N )&#123; long i,s=1; if(N&gt;=0&amp;&amp;N&lt;=12)&#123; //剪枝.减少时间复杂度 for(i=2 ;i&lt;=N ;i++)s *= i; printf(\"%ld\\n\",s); &#125;else if(N&gt;12&amp;&amp;N&lt;=1000)&#123; int num[3000] = &#123;0&#125;; num[0] = 1; int k=1; //位数 int n=0; //进位 int temp; for(int i=2 ;i&lt;=N ;i++)&#123; for(int j=0;j&lt;k;j++)&#123; temp = num[j]*i+n; //每一位相乘 再+进位 num[j] = temp%10; //更新每一位的数字 n = temp/10; //判断能否进位 &#125; while(n!=0)&#123; //如果可以进位 num[k] = n%10; //新增一位 n /=10; //继续判断能否进位 k++; &#125; &#125; for(int x=k-1;x&gt;=0;x--)printf(\"%d\",num[x]); //逆序输出数字 &#125; else&#123; printf(\"%s\\n\",\"Invalid input\"); &#125;&#125; 我的做法(错误): 123456789101112131415161718192021222324252627282930int mutliply(int a[],int n,int b)&#123; for(int i = n - 1 ;i &gt;= 0 ; i--)&#123; //计算机计算时, 4*6 , 先将十位确定,再确定个位 int tmp = a[i] * b; while( tmp &gt;= 10 ) &#123; /*▲. 这样的写法,存在124,无法在百位进位的缺陷 还是最好 tmp %= 10; n /= 10; */ tmp -=10; a[i+1] += 1; &#125; a[i] = tmp; &#125;&#125;void Print_Factorial ( const int N )&#123; if( N &lt; 0 ) &#123; printf(\"Invalid input\"); return ; &#125; int a[10000]=&#123;0&#125;; a[0] = 1; int n =10000; for(int i=1;i&lt;=N;i++)&#123; mutliply(a,n,i); &#125; for(int i=n-1;i &gt;= 0; i--) printf(\"%d \",a[i]); &#125; 总结 : 如果arr[0] = 1, 则得逆序输出。 由于要考虑前缀0的原因，必须考虑位数问题，这也是为什么我的方法一开始没有考虑位数问题，最后就算不下去的原因、 修改后重版 123456789101112131415161718192021222324252627282930313233void mutliply(int a[],int *n,int b)&#123; int w = 0; //进位 for(int j = 0 ;j &lt; *n; j++)&#123; // 对目前存在每一位相乘 int tmp = a[j] * b + w; //这样写不用担心,个位多了后十位先进了x,然后十位原有y,结果为(x+y)*b的情况 //因为这样写,十位是同时处理的,而不是像a[j++]先在十位加上w后,再在加上w的基础上*b a[j] = tmp %10; w = tmp / 10; &#125; while( w != 0)&#123; //比原来n位,进位的情况 a[ *n ] = w %10; w /= 10; (*n) ++; //这边出现了个运算优先级的问题 &#125;&#125;void Print_Factorial ( const int N )&#123; if( N &lt; 0 ) &#123; printf(\"Invalid input\"); return ; &#125; int a[10000]=&#123;0&#125;; a[0] = 1; int n = 1; //位数 for(int i=2; i &lt;= N;i++)&#123; //阶乘的数目 , 从2开始,可以少算1个1 , 结果一样 mutliply(a,&amp;n,i); &#125; for(int i= n-1 ;i &gt;= 0; i--) printf(\"%d\",a[i]); // 逆序输出数字 &#125; 关于++ 和取地址符*的优先级顺序 1.30蛇皮卡排序题6-11 求自定类型元素序列的中位数开始用冒泡算法，最后一个测试点过不去 用快速排序，最后一个测试点过不去，数据太多数相同；数据特殊导致时间复杂度退化。 用希尔排序，ac 我的代码: 选择排序12345678910111213141516ElementType Median( ElementType A[], int N )&#123; for(int i= 0; i&lt; N-1 ; i++)&#123; int nmax = i; for( int j = i+1;j&lt;N;j++)&#123; if( A[nmax] &lt; A[j] ) nmax = j; &#125; if( nmax != i )&#123; int tmp = A[i]; A[i] = A[nmax]; A[nmax] = tmp; &#125; &#125; return A[ N /2 ];&#125; 运行后PE.. 搜了题解,发现全部用的是 希尔排序(shell_sort) 希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序 同时该算法是冲破O(n2）的第一批算法之一 关于希尔排序increment（增量）的取法 增量increment的取法有各种方案。最初shell提出取increment=n/2向下取整，increment=increment/2向下取整，直到increment=1。但由于直到最后一步，在奇数位置的元素才会与偶数位置的元素进行比较，这样使用这个序列的效率会很低。后来Knuth提出取increment=n/3向下取整+1.还有人提出都取奇数为好，也有人提出increment互质为好。应用不同的序列会使希尔排序算法的性能有很大的差异。 原文：https://blog.csdn.net/weixin_37818081/article/details/79202115 题解: 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 题解一ElementType Median( ElementType A[], int N)&#123; int i, j, Increment; ElementType Tmp; //将数组排序 for ( Increment = N / 2; Increment &gt; 0; Increment /= 2)&#123; for ( i = Increment; i &lt; N; i++)&#123; Tmp = A[ i ]; for (j = i;j &gt;= Increment ; j -= Increment )&#123; if ( Tmp &lt; A[ j - Increment ]) A[ j ] = A[ j - Increment ]; else break; &#125; A[ j ] = Tmp; &#125; &#125; return A[ N / 2 ];&#125;// 题解二:void shell_sort(ElementType A[],int N);ElementType Median(ElementType A[],int N)&#123; if(N==1) return A[0]; shell_sort(A,N); return A[N/2];&#125;void shell_sort(ElementType A[],int N)&#123; int i,j,gap; // 三层循环 for(gap=N/2;gap&gt;0;gap/=2) for(i=gap;i&lt;N;i++) for(j=i-gap; j&gt;=0 &amp;&amp; A[j]&gt;A[j+gap] ; j-=gap)&#123; // 交换位置 ElementType temp=A[j]; A[j]=A[j+gap]; A[j+gap]=temp; &#125;&#125; 判断奇偶性1234int even( int n )&#123; return n%2==0; // 由于优先级原因, 不能写成 return !n%2;&#125; 6-13 折半查找题目要求 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;#define MAXSIZE 50typedef int KeyType;typedef struct&#123; KeyType key;&#125; ElemType;typedef struct&#123; ElemType *R; int length;&#125; SSTable;void Create(SSTable &amp;T)&#123; int i; T.R=new ElemType[MAXSIZE+1]; cin&gt;&gt;T.length; for(i=1;i&lt;=T.length;i++) // 注意这边构造的时候,下标是从1开始的, // 所以下面写二分搜索的LOW,HIGH也需要相应的改 cin&gt;&gt;T.R[i].key;&#125;int Search_Bin(SSTable T, KeyType k);int main ()&#123; SSTable T; KeyType k; Create(T); cin&gt;&gt;k; int pos=Search_Bin(T,k); if(pos==0) cout&lt;&lt;\"NOT FOUND\"&lt;&lt;endl; else cout&lt;&lt;pos&lt;&lt;endl; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// 题解int Search_Bin(SSTable T, KeyType k)&#123; int low = 1 , high = T.length ; // 下标是 1, N int m; while( low &lt;= high)&#123; m = (low+high) / 2; if ( T.R[m].key == k ) return m ; else if (k&lt; T.R[m].key ) high = m-1; else low = m+1; &#125; return 0;&#125;// 数据结构书上#include &lt;cstdio&gt;int binsearch(int a[],int N,int k)&#123; int low=0 ,high = N -1; // 下标是 0 , N-1 int m; while( low&lt;=high)&#123; m = (low +high ) /2 ; if( a[m] &lt; k) low = m+1; else if( a[m] &gt; k) high = m -1; else return m; &#125; return -1;&#125;int main()&#123; int a[10]; int N; scanf(\"%d\",&amp;N); for(int i= 0 ;i&lt;N ;i++) scanf(\"%d\",&amp;a[i]); int k; scanf(\"%d\",&amp;k); int pos = binsearch(a,N,k); if( pos == -1) printf(\"NOT FOUND\"); else printf(\" index is : %d\",pos); return 0;&#125; 1.31编程题 厘米换算英尺英寸1234567891011#include&lt;cstdio&gt;int main()&#123; int N; while( scanf(\"%d\",&amp;N) == 1)&#123; int foot = N / 30.48; int inch = 12 * ( N / 30.48 - foot); // 这边的 N / 30.48 结果并不是整数 , 而是double类型的 printf(\"%d %d\\n\",foot, inch); &#125; return 0;&#125; 7-2 然后是几点 题目考察了对提取不同位数,再组合的能力 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;int main()&#123; int x,y; while( scanf(\"%d%d\",&amp;x,&amp;y) == 2)&#123; int hour_split = x/100; int reminderm = y % 60 + x%100; int moreh = reminderm / 60 ; int h = hour_split+ y / 60 + moreh; int leftm = reminderm % 60; printf(\"%d\\n\", h * 100 + leftm); &#125; return 0;&#125;// 由于第一种没有考虑到负数的情况,所以改进就额外加了个if#include &lt;cstdio&gt;int main()&#123; int x,y; int minush = 0; int h ; int moreh ; while( scanf(\"%d%d\",&amp;x,&amp;y) == 2)&#123; int hour_split = x/100; // 根据x切割出原来的小时 int reminderm = y % 60 + x%100; // 根据提供的流逝分钟数,找到结合x,y分钟数的结果 int leftm = reminderm % 60; // 区别主要是负数时要限制 , 题解也是如此思路 //分钟在0-60之内,小时减去相应的值, 但是得考虑-20, y/60==0的情况 if( leftm &lt; 0 )&#123; moreh = reminderm / 60 - 1; int minusm = 60 + leftm ; // 由于leftm &lt; 0 且 在0-60之内,所以minusm在0-60之内 h = hour_split+ y / 60 + moreh ; printf(\"%d\\n\", h * 100 + minusm ); &#125;else&#123; moreh = reminderm / 60 ; h = hour_split+ y / 60 + moreh; printf(\"%d\\n\", h * 100 + leftm ); &#125; &#125; return 0;&#125; 题解 1234567891011121314151617181920212223#include&lt;stdio.h&gt; int main()&#123; int basis, add; scanf(\"%d %d\", &amp;basis, &amp;add); if (add &gt;= 0)//注意题干指明add可能为负的情况 &#123; int up = (basis % 100 + add) / 60; int min = (basis % 100 + add) % 60; int end = (basis / 100) * 100 + 100 * up + min; printf(\"%d\", end); &#125; else&#123; int down = (basis % 100 + add) / 60; int dmin = (basis % 100 + add) % 60; int end = (basis / 100) * 100 + 100 * down - 100 + 60 + dmin; // 对小时的操作 (basis / 100) * 100 + 100 * down - 100 , 多了个减100,即-20/60==0的情况 // 对分钟的操作 60 + dmin 限制在 0-60之内 printf(\"%d\", end); &#125; return 0;&#125;// 直接分两个情况讨论,更加直观 2.1贪心专题2.27-3 逆序的三位数 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main()&#123; int N; while( cin &gt;&gt; N )&#123; int a = N/100; int b= N/10%10; int c= N%10; if( c == 0)&#123; if( b==0)&#123; cout &lt;&lt; a; &#125;else&#123; cout &lt;&lt; a + b*10; &#125; &#125;else&#123; cout &lt;&lt; 100 * c +10*b + a; &#125; &#125; return 0;&#125; 2.3DP训练2.4除夕过节 2.5过年休息 2.6 字典序比较–&gt;贪心 快速幂123456789101112long long Mode(long long a, long long b, long long mode)&#123; long long sum = 1; a = a % mode; while (b &gt; 0) &#123; if (b % 2 == 1) sum = (sum * a) % mode; // 判断是否是奇数，是奇数的话将多出来的数事先乘如sum b /= 2; a = (a * a) % mode;// 不断的两两合并再取模，减小a和b的规模 &#125; return sum;&#125; 当然有时候你可能会碰到用&amp;的运算符的代码实现，其实和这个大致相同，只不过是用&amp;操作符对b的奇偶性进行判断而已 补充:a=2 ,b=0 ,c=1 这种很简单的情况却会WA 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,c; int ans=1; while(scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c)!=EOF)&#123; //int ans = 1; if(b&gt;0)&#123; a=a%c; int h; h=b; while(h&gt;0) &#123; if(h%2==1) ans=(ans*a)%c; h=h/2; a=(a*a)%c; &#125;// if(b==0 &amp;&amp; c==1)// cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl; &#125; else if(b==0 &amp;&amp; c==1) cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; else if(b==0 &amp;&amp; c!=1) cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; &#125; return 0; &#125; &amp;的操作符：二进制位中，1 &amp; 1 = 1，其余组合均为0 123456789101112long long Mode(long long a, long long b, long long mode)&#123; long long sum = 1; while (b) &#123; if (b &amp; 1) &#123; sum = (sum * a) % mode; b--; &#125; b /= 2; a = a * a % mode; &#125; return sum;&#125; 2.7数据记录: 65536 $2^{16}$ 4 294 967 296 $2^{32}$ unsigned int 0～4294967295 int -2147483648～2147483647 （10位） unsigned long 0～4294967295 long -2147483648～2147483647 long long的最大值 9223372036854775807 （19位） long long的最小值： -9223372036854775808 unsigned long long的最大值 1844674407370955161 __int64的最大值 9223372036854775807 __int64的最小值： -9223372036854775808 unsigned __int64的最大值 18446744073709551615 一个由C/C++编译的程序占用的内存分为以下几个部分1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另 一块区域。 程序结束后由系统释放。 4、文字常量区 —常量字符串就 是放在这里的。 程序结束后由系统释放 5、程序代码区—存放函数体的二进制代码。 12345678910111213141516#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int c[20000][20000]; //在本人环境中全局数组能开到20000*20000int main()&#123; int b[1024*505]; int b2[700*700]; char a[4*518028]; int b1[500000]; //5*10^5 函数中的char数组最大能开4*518028，int最大能开到518028。 static int c[20000][20000]; //static能开到10^7*10^7。 注意 static和 全局开的是同一块空间 printf(\"1\");&#125;; 四舍五入,小数点位数 修改C++的输出流， 对小数会进行四舍五入 c++默认的流输出数值有效位是6，包括整数和小数，若数值超出6位，则第七位四舍五入到6位数 fixed ：浮点值显示为定点十进制。 默认是小数6位数，不包含整数，若小数位超出6位，则四舍五入到6位数 123456789101112131415161718192021222324252627282930#include &lt;iomanip&gt;// 需要引入这个头文件#include &lt;iostream&gt;using namespace std;int main()&#123; double PI = -3.14125001; cout &lt;&lt; setprecision(5); cout &lt;&lt; PI; return 0;&#125;// &gt;&gt;&gt; -3.1413int main()&#123; double PI = -3.14125001; cout&lt;&lt; setiosflags(ios::fixed); // ▲ cout &lt;&lt; setprecision(5); cout &lt;&lt; PI; return 0;&#125;// &gt;&gt;&gt; -3.14125/*拓展：如果与setiosnags(ios::scientific)合用， 可以控制指数表示法的小数位数。setiosflags(ios::scientific)是用指数方式表示实数。cout &lt;&lt; setiosflags(ios::scientific) &lt;&lt; setprecision(3);&gt;&gt;&gt; -3.141e+000*/ 1.setprecision(n)指定一个浮点数的精度默认设置输出的数字的总位数为n，包含整数和小数部分；其中setprecision（0）效果是跟c++默认的流输出数值一样，有效位是6位，包括整数和小数 2.fixed：必须与setprecision(n)配合使用，用来控制小数位数，不够补0，只要写一次fixed，后面的setprecision（n）就都是指小数了。 fixed与setprecision谁先谁后没有关系，但通常是fixed在前先固定6位小数（若此时小数已经超出6位，则先四舍五入到6位）再precision(n)取n位小数（n&lt;6） 3.如果与setiosnags(ios::scientific)合用， 可以控制指数表示法的小数位数。setiosflags(ios::scientific)是用指数方式表示实数。 4.resetiosflags(ios::fixed)取消精度的设置。 四舍五入进整1234567#include &lt;iomanip&gt;int main()&#123; double PI = 3.51; cout &lt;&lt; setprecision(1); cout &lt;&lt; \"PI:\" &lt;&lt; PI; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"},{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"12-27 Team Leader","slug":"12-27-Team-Leader","date":"2019-01-19T12:40:37.000Z","updated":"2019-01-19T12:46:52.114Z","comments":true,"path":"2019/01/19/12-27-Team-Leader/","link":"","permalink":"https://nymrli.top/2019/01/19/12-27-Team-Leader/","excerpt":"","text":"How Is An Excellent Team Leader A couple of days ago, my friend and I took part in a science and technology competition which was completed by a team of four. Usually, The person who can come up with the best idea is the caption, leading or so-called principal. For the reason, I was the principal of the team which consists of the same teammates last time. And this time, someone came up with a better idea, so the principal changed and not me. I’m not saying that changing is bad, or that I’m unsatisfied with it that I didn’t continue to play such an important role. At the beginning, everything is ok and everyone is full of fighting spirit. We have more than 30 days to finish this work, but actually the workload is only about 6 days at most. As a team that has completed several works together, we still keep the excellent habit of meeting and discussing regularly. Maybe it isn’t as important as the last one, or maybe the division is so clear that nothing has to be discussed always. Everyone has his work, and takes responsibility to his own job, so it seems very easy to solve the project. In fact, we spent lots of time laughing and talking together and fussing around trifles, instead of really discussing the problem. There was nothing wrong at that time. The problem occurred three days before the start of the evaluation. Everyone had finished his own work and waited to consolidate the modules and summarize all the work. This is a good proposal, but if fact, two people are debugging the code, while the other two people are working at their own job, can this be called discussion or teamwork? It’s natural to do with their own things if they have finished what they should do. However, what makes me angry is that we are both up to my ears in work while the others who are free feel nothing to do with himself. We hoped they could come to our aid, but they even didn’t understand what was wrong and not to mention what to do. To sum up, there was a communication problem which reflected in the form of failing to cope with work’s distribution. I have said just now that the division is very clear and easy. There were four people in the competition team, but the work was divided into three modules: SCM, machine learning, and Web services. So it’s enough for three people to do this and we felt easy and relaxed also. Nobody complained about there was somebody doing nothing. But maybe when it comes to the principal, the condition is different. First of all, as a team leader, he may be criticized if he doesn’t do anything. This is still a small matter. The most important thing is efficiency. What really pissed me off that night was that the summary didn’t end from 8:30 p.m. to 11:00 p.m., and the biggest reason was that no one knew exactly how to tackle it. And that lies about the principal. Although, he did a good job in the report which needs the structural diagram of the whole work and even designed the flow chart. The project needed supervision and urging, and he had completed it well. Every weekend, he tries to organize the gather everyone. Also, he gets on well with teammates and so on. It can be said he is basically qualified. However, I must pointed out that he is not a good leader by no means. First of all, he only did the things required by the competition, such as the system block diagram, but he did not manage the division of labor and summary of each of us in length. What’s more, he only organized and attended each discussion symbolically. He neither discussed the project with any purpose nor proposed any better suggestion. He organized the discussion formally for several times and seemed quite responsible. But that’s a waste of time, in my view, the biggest difference between a responsible person and no responsible person is reflected in the organization. A good organization can improve the efficiency, while a poor organization is just dispensable or even wasteful. It wasn’t as easy as I thought it would be that day. Eventually, it took us three more meetings before we actually assembled the work. During this period, I couldn’t bear to give suggestions to principal that You can do nothing, but you have to know our progress and what we are doing. ‘Of course,’ he replied. ‘that’s why I come to every discussion, just to get a sense of where you’re going,or I don’t have to come.’ I was speechless, for there seemed to be nothing wrong with it. The biggest conflict occurred the night before the game, when a module that had been available suddenly broke down. After several previous quarrels, it was difficult for me and principal to discuss together. But this is a very serious question, how to make decisions now. Do it the same as before? Or abandon all the previous modules to implement the worst solution? After I put forward the proposal of starting again as soon as possible, he finally led the people to carry out the worst plan. And this is without my knowledge. They followed worked on worst plan all afternoon, and all looked very frustrated. I realized that they didn’t follow my plan until they said they had a problem that was a little difficult to solve. I was so angry that I called them and asked them why they didn’t do what I said. They were vague, and I called them names because I thought they could do it if they did what I told them. So, I immediately met with them, it was raining, the atmosphere was very depressed, the leader did not speak, the other two players looked very depressed. At that time, I tried not to shout at the wrong leader. and first I stressed that we could definitely make it if we continued to do it. After inspiring for a while, everyone seemed quite motivated, so I immediately lead them to try in this direction. Fortunately, we solved the problem again in less than two hours. What I want to say is that all teams will confront with difficulties, and then there must be a strong and confident person to lead the team to a good direction, rather than thinking about how not to lose his face and take a not smart solution. Later, the principal reflected it was tight at that time, and we had some conflicts before, so he did not want to prove that he could not solve the problem. That’s the whole story, a very verbose story. I’m not talking about how good I am at what I do. I want to emphasize that as a good leader, one must think for the team and improve the efficiency of the team fundamentally, instead of wasting everyone’s time by being formalistic. And As a leader of a team it’s important that the first thing that comes to mind is how to solve the problem better, instead of escaping from the trouble. I just want to save my face and make a bad but not wrong decision. Last but not least, full of confidence and fighting spirit, can actively lead the team to success. If you do not believe in yourself, how can you let others believe in yourself. Further, the ideal leader, in addition to giving a good direction of effort, but also can help members solve the actual problems encountered, of course, this is difficult and just the ideal situation. Because it is difficult for anyone to understand all aspects, I dare to make such a decision this time, and I am confident that I can succeed in doing so, largely because I known about the modules which everyone should be responsible for. This is what I learned from this competition, what I understand the responsible leader should behave like.Thanks.","categories":[],"tags":[{"name":"English Speaking","slug":"English-Speaking","permalink":"https://nymrli.top/tags/English-Speaking/"},{"name":"生活小记","slug":"生活小记","permalink":"https://nymrli.top/tags/生活小记/"}]},{"title":"阿里云nginx+wsgi部署flask","slug":"阿里云nginx-wsgi部署flask","date":"2019-01-17T13:33:14.000Z","updated":"2019-05-30T03:39:34.630Z","comments":true,"path":"2019/01/17/阿里云nginx-wsgi部署flask/","link":"","permalink":"https://nymrli.top/2019/01/17/阿里云nginx-wsgi部署flask/","excerpt":"","text":"云服务器nginx+wsgi部署flask更新源12sudo apt-get updatesudo apt-get upgrade 安装nginx123sudo apt-get install nginxsudo /etc/init.d/nginx start (start可以改成restart/stop)#或是sudo service nginx start 然后浏览器输入服务器IP或是127.0.0.1,观察是否有welcom to nginx! 安装py3和virtualenv12sudo apt-get install git python3 python3-pipsudo pip3 install virtualenv 修改python版本:法一:(不建议)123456789$ gedit ~/.bashrc #gedit .bash_aliases在顶部加入一行alias python=python3$ source ~/.bashrc #或是source ~/.bash_aliases o$ python --version就会发现是Python 3.5.2啦/*orOpen your .bashrc file nano ~/.bashrc. Type alias python=python3 on to a new line at the top of the file then save the file with ctrl+o and close the file with ctrl+x. Then, back at your command line type source ~/.bashrc. Now your alias should be permanent.*/ Ubuntu16.04切换python3和python2▲.切换Python3为默认版本：(建议)12sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 切换Python2为默认版本： 1$ sudo update-alternatives --config python 安装虚拟环境virtualenv12$ cd /var/www$ sudo virtualenv env35 pipenv1$ pipenv install MySQL123456789$ sudo apt install mysql-server mysql-client$ cd /etc/mysql/mysql.conf.d$ mysql -p -u root&gt; password for root:&gt; use mysql;&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;&gt; flush privileges; 最后按Ctrl + z 退出 安装、测试uwsgi1$ sudo pip3 install uwsg 编辑/var/www下的uwsgi.ini123456789101112[uwsgi]chdir=/home/apollo3d/Documents/Beidou wsgi-file=wsgi.pyhome=/home/apollo3d/Documents/envcallable=app; master=Trueprocesses=10socket= :81chmod socket=666vacuum=Truemax-requests=5000#pythonpath=/var/www/env 编辑/var/www下的nginx.conf123456789101112131415server &#123; listen 80; server_name 127.0.0.1; charset utf-8; client_max_body_size 75M; location /static&#123; alias /home/apollo3d/Documents/Beidou/static; &#125;location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:81;# uwsgi_param UWSGI_PYHOME /home/apollo3d/Documents/Beidou/env; uwsgi_param UWSGI_SCRIPT app:app; # 启动flask的文件:Flask的实例&#125;&#125; 编辑/var/www下的uwsgi_params12345678910111213141516uwsgi_param QUERY_STRING $query_string;uwsgi_param REQUEST_METHOD $request_method;uwsgi_param CONTENT_TYPE $content_type;uwsgi_param CONTENT_LENGTH $content_length; uwsgi_param REQUEST_URI $request_uri; uwsgi_param PATH_INFO $document_uri; uwsgi_param DOCUMENT_ROOT $document_root; uwsgi_param SERVER_PROTOCOL $server_protocol; uwsgi_param REQUEST_SCHEME $scheme; uwsgi_param HTTPS $https if_not_empty; uwsgi_param REMOTE_ADDR $remote_addr; uwsgi_param REMOTE_PORT $remote_port; uwsgi_param SERVER_PORT $server_port; uwsgi_param SERVER_NAME $server_name; 软连接12345$ cd /etc/nginx$ cd sites-enabled$ rm default$ sudo ln -s /var/www/nginx.conf homework_submission$ ls 重启nginxsudo /etc/init.d/nginx restart 运行uwsgi12cd /var/wwwuwsgi --ini uwsgi.ini 让uwsgi自启动 vim /etc/rc.local(注意非虚拟环境也得安装uwsgi模块) 1234添加下面代码:/usr/local/bin/uwsgi --ini /var/www/uwsgi.iniexit 0 uwsgi的热启动 在uwsgi.ini中加入 py-autoreload=1 重启一下:killall -9 uwsgi、/usr/local/bin/uwsgi --ini /var/www/uwsgi.ini 总结关于etc/ linit. d 如果你使用过inux系统,那么你一定听说过 init. d目录,这个目录到底是干嘛的呢?它归根结底只做了一件事情,但这件事情非同小可,是为整个系统做的,因此它非常重要。init.d目录包含许多系统各种服务的启动和停止脚本 关于 /etc/rc.local rc.local也是我经常使用的一个脚本,该脚本是在系统初始化级别脚本运行之后再执行的,因此可以安’, ‘地在里面添加你想在系统启动之后执行的脚本. 总结 Linux是灵活的,正因为它的灵活性,我们总是可以找到许多不同的办法来解决同一个问题，服务的例子就是一个很好的佐证,有了 /etc/init.d目录下的脚本,再加上 /etc/rc. local这个利器，你可以放心的确保你的服务可以完美的启动和运行","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"}]},{"title":"前端Vue框架学习","slug":"前端Vue框架学习","date":"2019-01-17T12:47:22.000Z","updated":"2019-01-17T12:47:49.527Z","comments":true,"path":"2019/01/17/前端Vue框架学习/","link":"","permalink":"https://nymrli.top/2019/01/17/前端Vue框架学习/","excerpt":"","text":"前端Vue框架学习(未完)MVVM模型使用Vue的初次操作创建一个Vue实例123456var c = new Vue(&#123; //初始化一个Vue对象 el: '#box', //对象,后面跟的是选择器 el(是element缩写 data : &#123; //数据成员,必须用关键字data msg:'welcome' &#125;&#125;) 完整的html页面1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; window.onload=function (ev) &#123; new Vue(&#123; el: '#box', data:&#123; msg:'hello' &#125; &#125;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\"&gt; &#123;&#123;msg&#125;&#125; &lt;!--&lt;li&gt;&lt;/li&gt;--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 常用指令v-model一般是放在表单中,实现了双向绑定123456//如上初始化一个Vue实例&lt;div id='box'&gt; &lt;input type='text' v-model=\"msg\" &gt; //\"双向绑定\",修改输入框内容,msg内容也会改变 &lt;br&gt; &#123;&#123;msg&#125;&#125;&lt;/div&gt; v-repeat===&gt;v-for=&quot;变量名 in 数组&quot; 使用变量的话,使用索引 1234567/* data:&#123;msg:'hello',array:['he','bo','ce']&#125;*/&lt;li v-for=\"value in array\"&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt; v-on侦听用户事件 click mousedown dblclick mouseover mouseout 123456789101112131415161718window.onload=function () &#123; new Vue(&#123; el: '#box', data:&#123; msg:'hello', array:['he','bo','ce'] &#125;, methods :&#123; //注意是methods , 而不是method show:function () &#123; alert(1); &#125; &#125; &#125;) &#125; &lt;body&gt; &lt;input type=\"button\" value=\"按钮\" v-on:click=\"show()\"&gt; &lt;/body&gt; v-show=&quot;true&quot; Bootstrap + Vue Bootstrap 是个 css框架，类似jqueryMoblie一样,只需要给标签加class就行了 Bootstrap 需要 .css + .js ，由于依赖jqery,所以需要将jquery.js也导入","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"}]},{"title":"git使用","slug":"git使用","date":"2019-01-17T12:43:43.000Z","updated":"2019-02-06T08:19:05.808Z","comments":true,"path":"2019/01/17/git使用/","link":"","permalink":"https://nymrli.top/2019/01/17/git使用/","excerpt":"","text":"概念工作区:工作空间分为三个状态区: 工作区 暂存区 历史记录区 三个区域关系：工作区是我们能看到的区域，我们在工作区修改增加代码；完成编辑后，我们用git add 将工作区文件添加到暂存区；然后利用git commit 提交文件到我们自己的分支。 HEAD头指针:Head指向的是当前版本(最新的提交) 基础命令123456$ git add 文件名# 将文件添加到暂存区中 (其中git add.可以将当前目录的子目录文件都添加到暂存区中)$ git status # 显示工作目录和暂存区的状态$ git diff ID1/ID2# 查看版本差异: 分支操作1234567891011121314$ git branch # 分支一展表&gt;&gt;&gt; *(branch)显示当前分支$ git checkout -b 分支名 # 创建,且切换到新建分支 &lt;==等价于==&gt; git branch 分支名,git checkout 分支名$ git branch -d [分支名称] # 删除一个分支, -d选项只能删除已经参与过合并的分支，对于未参与合并的分支是无法删除的。# 如果想强制删除一个分支，可以使用-D选项$ git checkout 文件名 :切换分支 (git checkout - 为切换到上一个分支)$ git merge --no-f 分支名 : 合并分支$ git rebase -i # 压缩历史(如果出现拼写错误时需要): git rebase -i HEAD~2pick xxxx...pick xxxx... 只要将这个(出现拼写错误的那个提交ID前的pick改成fixup就行了) 远程仓库123456789101112131415161718192021222324$ git remote add 远程仓库名 # 添加远程仓库$ git@github.com:用户名/git-tutorial.git $ git push -u 远程仓库名 本地分支名# 将本地分支推送到远程仓库中:$ git checkout -b 新仓库名 远仓库名/远程分支名$ git pull [远程仓库名] [本地分支名称] # 更新:拉取远程仓库代码,如果你远程只有一个分支,本地只有一个分支,后面中括号内容都可以省略$ git push [远程仓库名] [本地分支名称]# 推送代码到远程仓库$ git remote -v# 查看远程仓库$ git remote rm [远程仓库名]# 清除远程代码仓库:$ git push origin 本地分支名:master # 提交本地分支提交到远程的master分支$ git push origin :heads/[分支名称] 或 $ git push origin :[分支名称] # 删除远程分支$ git branch -r# 查看远程git服务器上的分支: $ git fetch origin# 获取远端库最新信息$ git diff master origin/master# 查看本地与远程服务端的不同 日志1234$ git log# 提交日志(当前状态为终点) 会产生版本库里一系列单独提交的历史$ git log -p README.md$ git log -graph 撤销操作撤销文件提交到暂存区 1$ git rm 文件名 撤销上一次提交(commit),并重新提交 修改提交信息 12$ git commit --amend# 可以重新修改提交信息,也可以不修改 ▲.将暂存区内的文件代替工作区的(工作区内的文件复原) 1git checkout -- . ▲.将将最近一次版本库文件代替暂存区的(暂存区内的文件复原) 1234git reset HEAD .# 将暂存区拉回工作区git checkout -- .# 将工作区复原 从云服务器更新文件到仓库1.查看git 版本(是否安装,一般都是默认安装好了的)2.设置github账号密码:12$ git config --global user.email \"you@example.com\"$ git config --global user.name \"Your Name\" 3.设置上传方式1git config --global push.default simple matching（匹配所有分支）matching 参数是 Git 1.x 的默认参数，也就是老的执行方式。其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。 simple（匹配单个分支) simple参数是 Git 2.x 默认参数，意思是执行 git push 没有指定分支时，只有当前分支会被 push 到远程仓库。 4.上传需要上传的文件1234#git init 如果没有初始化仓库的话....(更新的话就不需要git add . git commit -m \"xxx\"git push 附录:Git远程操作详解使用git将项目上传到github（最简单方法）","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"数据结构实验1——线性表及多项式的运算","slug":"数据结构实验1——线性表及多项式的运算","date":"2018-12-28T11:42:11.000Z","updated":"2018-12-30T13:48:10.948Z","comments":true,"path":"2018/12/28/数据结构实验1——线性表及多项式的运算/","link":"","permalink":"https://nymrli.top/2018/12/28/数据结构实验1——线性表及多项式的运算/","excerpt":"","text":"链表操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int Status;typedef int ElemType;typedef struct Node&#123; ElemType elem; struct Node *link;&#125;Node;typedef struct &#123; struct Node* first; int n;&#125;SingleList;SingleList list; //声明全局的Status Init(SingleList *L)&#123; L-&gt;first = NULL; L-&gt;n = 0; return OK;&#125;Status Find(SingleList L,int i,ElemType *x)&#123; Node *p; int j; if (i&lt;0 || i&gt; L.n-1) return ERROR; p = L.first; for (j = 0; j &lt; i; ++i) p=p-&gt;link; *x = p-&gt;elem; return OK;&#125;Status Insert(SingleList *L,int j,ElemType x)&#123; Node *p,*q; int i; if(j&lt;-1 || j&gt; L-&gt;n) return ERROR; p = L-&gt;first; for(i=0;i&lt;j;i++) p=p-&gt;link; //p==&gt;a(i-1) q = (Node *)malloc(sizeof(Node)); q-&gt;elem = x; if (j&gt;-1) &#123; q-&gt;link = p-&gt;link; // a(i-1)==&gt;??? ===&gt; a(i)-&gt;??? p-&gt;link = q ; // a(i-1)-&gt;a(i) &#125;else &#123; q-&gt;link = L-&gt;first; L-&gt;first = q; &#125; L-&gt;n++; return OK;&#125;Status Delete(SingleList *L,int j)&#123; int i; Node *p,*q; if(!L-&gt;n) return ERROR; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; q = L-&gt;first; p = L-&gt;first; for(i=0;i&lt;j-1;i++) q = q-&gt;link; //q指向 a(i-1) if (i==0) L-&gt;first = L-&gt;first-&gt;link; else&#123; p = q-&gt;link; //此时p指向a(i) q-&gt;link = p-&gt;link; //将q指向a(a+1) &#125; free(p); L-&gt;n -- ; return OK;&#125;Status Output(SingleList L)&#123; Node *p; if(!L.n) return ERROR; p = L.first; while(p)&#123; printf(\"%d \",p-&gt;elem ); p = p-&gt;link; &#125; return OK;&#125;void Destory(SingleList *L)&#123; Node *p; while(L-&gt;first)&#123; p = L-&gt;first-&gt;link; //保存后继节点地址,防止断链 free(L-&gt;first); //释放first节点所指节点的存储空间 从前往后释放 L-&gt;first = p; &#125; &#125;int main()&#123; int i,x; Init(&amp;list); for (i = 0; i &lt; 9; ++i) Insert(&amp;list,i-1,i); printf(\"the linked list is :\"); Output(list); Delete(&amp;list,1); printf(\"\\nafter deleting the list is:\"); Output(list); Find(list,0,&amp;x); printf(\"\\nthe value is %d\\n\",x ); Destory(&amp;list); system(\"pause\"); return 0;&#125; 带表头节点的单链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct Node&#123; ElemType elem; struct Node *link;&#125;Node;typedef struct &#123; struct Node* head; int n;&#125;Headlist;Status Init(Headlist *L)&#123; L-&gt;head = (Node*)malloc(sizeof(Node)); if(!L-&gt;head) return ERROR; L-&gt;head-&gt;link = NULL; //注意到这边没有对L-&gt;head-&gt;element作设置,因为不会用到 L-&gt;n = 0; return OK;&#125;Status Sort(Headlist *L)&#123; Node *p=L-&gt;head,*pre=NULL; Node *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;elem &lt; p-&gt;elem) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125; return OK;&#125;Status deleleab(Headlist *L, int a,int b)&#123; Node *q = L-&gt;head,*p=L-&gt;head-&gt;link; // q为上一个,p为当前的 while( p ) if(p-&gt;elem &gt;= a &amp;&amp; p-&gt;elem &lt;= b) &#123; q-&gt;link = p-&gt;link; // 1 - 2 - 3 1==&gt;3,1的指针域指向3 free(p); //释放2 p = q-&gt;link; // 当前的指针变成3 &#125;else&#123; p = p-&gt;link; q = p-&gt;link; &#125; return OK; &#125;/*****思路为: 将顺序遍历的结点不断插入为L-&gt;head-&gt;link******/Status Converse(Headlist *L)&#123; Node *p = NULL,*cur= NULL; Node *q = L-&gt;head-&gt;link; if(L-&gt;head &amp;&amp; L-&gt;head-&gt;link)&#123; //如果表不存在或是为空,则return ERROR while( q != NULL ) //q按照原来的顺序依次遍历各结点 &#123; cur = q; //cur为当前结点 q = q-&gt;link; //q保存下一个结点 L-&gt;head-&gt;link = cur; //为了不动头结点,所以头结点link始终指向当前要加的结点 cur-&gt;link = p; //当前的link指向上一个结点 p = cur; //保存上一个结点 &#125; &#125;else return ERROR; return OK;&#125;Status Insert(Headlist *L,int j,ElemType x)&#123; int i; Node *p=NULL,*q=NULL; if(j&lt;-1 || j&gt; L-&gt; n-1) return ERROR; p = L-&gt;head; for(i=0;i&lt;=j;i++) p=p-&gt;link; // 与普通链表不同,这边是 &lt;= , 因为要多一个表头Node q = (Node *)malloc(sizeof(Node)); q-&gt;elem = x; q-&gt;link = p-&gt;link; p-&gt;link = q; L-&gt;n++; return OK;&#125;Status Output(Headlist L)&#123; Node *p = L.head-&gt;link; if(!L.n) return ERROR; while(p)&#123; printf(\"%d \",p-&gt;elem ); p = p-&gt;link; &#125; return OK;&#125;Status Destory(Headlist *L)&#123; Node *p=NULL; while(L-&gt;head)&#123; p = L-&gt;head-&gt;link; free(L-&gt;head); L-&gt;head = p; &#125; return OK; &#125;Status Delete(Headlist *L,int j)&#123; //下标j Node *p = L-&gt;head,*q = L-&gt;head; // q = tmp int i; if(!L-&gt;n) return ERROR; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j-1;i++) p = p-&gt;link; q = p; p = p-&gt;link; q-&gt;link = p-&gt;link; free(p); return OK;&#125;Status Find(Headlist *L,int j,ElemType *x)&#123; Node *p= L-&gt;head; int i; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j;i++) p = p-&gt;link; *x = p-&gt;elem; return OK;&#125;int main()&#123; int x; Headlist list; Init(&amp;list); Insert(&amp;list,-1,3); Insert(&amp;list,0,2); Insert(&amp;list,-1,5); Insert(&amp;list,2,7); Insert(&amp;list,-1,1); printf(\"the linked list is :\"); Output(list); printf(\"\\nAfter sorted:\"); Sort(&amp;list); Output(list); printf(\"\\nAfter Conversed:\"); Converse(&amp;list); Output(list); printf(\"\\nAfter delete index of 0,the list is:\"); Delete(&amp;list,0); Output(list); Find(&amp;list,2,&amp;x); printf(\"\\nthe index of 2:%d\\n\",x); Destory(&amp;list); system(\"pause\"); return 0;&#125; 带表头的链表和普通链表的区别在于: 带表头链表的头结点的数据域是不设置的,真正有用的结点是L-&gt;head-&gt;link指向的结点.而普通链表L-&gt;first指向的结点 这样的好处是不用特殊考虑是不是头结点. 代码实现细节:1.插入的i,是$a_{i}$后面再添加一项,所以for条件为j=0;j&lt;i 进行j次link 2.删除时,删除的是$a_{i}$,for(j=0;j &lt; i - 1;j++),为什么是 i-1跟代码实现有关,先把q指向要删除的前一个结点,p=q-&gt;link,q-&gt;link = p-&gt;link从而将p即$a_{i}$孤立出来 ▲带表头的话,将&lt;变为&lt;=,因为要多推个link,跳过head结点 设计上最大的区别在于▲多了个表头以后,就不用再考虑,删除和插入的时候去动List-&gt;first指针，带表头后，修改的都是L-&gt;head-&gt;link之后的结点Node 单链表实现多项式加减、相乘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct PNode&#123; ElemType ceof; ElemType exp; struct PNode *link;&#125;PNode;typedef struct &#123; struct PNode *head;&#125;polynominal;Status Init(polynominal *p)&#123; p-&gt;head = (PNode *)malloc(sizeof(PNode)); p-&gt;head-&gt;exp = -1; p-&gt;head-&gt;link = NULL; return OK;&#125;Status Create(polynominal *p)&#123; PNode *pn = NULL,*q=NULL,*pre=NULL; p-&gt;head = (PNode *)malloc(sizeof(PNode)); p-&gt;head-&gt;exp = -1; p-&gt;head-&gt;link = NULL; for (;;) &#123; pn = (PNode *)malloc(sizeof(PNode)); printf(\"ceof:\\n\"); scanf(\"%d\",&amp;pn-&gt;ceof); printf(\"exp:\\n\"); scanf(\"%d\",&amp;pn-&gt;exp); if (pn-&gt;exp &lt; 0) &#123;printf(\"End the input\\n\"); break;&#125; pre = p-&gt;head; //pre从链表头开始 q=p-&gt;head-&gt;link; while(q &amp;&amp; q-&gt;exp &gt; pn-&gt;exp)&#123; //pn为当前结点,q为链表中结点 pre = q; // q = q-&gt;link; &#125; pn-&gt;link = q; // 在pre和q之间插入pn,(q为null时,相当于末尾插入pn) pre-&gt;link = pn; // pre =&gt; pn =&gt; q &#125; return OK;&#125;Status Sort(polynominal *L)&#123; //从大到小 PNode *p=L-&gt;head,*pre=NULL; PNode *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;exp &lt; p-&gt;exp) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125; return OK;&#125;Status Add(polynominal *px,polynominal *qx)&#123; //目的:将q改成p+q PNode *q1=qx-&gt;head, *p=px-&gt;head-&gt;link; //q1指向qx表头结点 PNode *q=q1-&gt;link; //p指向多项式px第一个结点,q指向qx第一个 PNode *temp = NULL; //q1是q前驱 while( q &amp;&amp; p)&#123; while( p-&gt;exp &lt; q-&gt;exp )&#123; //找到qx中 大于等于q指数项的项,q不断右移 q1 = q; q = q-&gt;link; &#125; if (p-&gt;exp == q-&gt;exp )&#123; q-&gt;ceof = q-&gt;ceof + p-&gt;ceof; if (q-&gt;ceof == 0)&#123; q1-&gt;link = q-&gt;link; //释放当前q的内存 free(q); q = q1-&gt;link; p = p-&gt;link; &#125;else&#123; //p\\q都右移 q1 = q; //q1 q = q-&gt;link; p = p-&gt;link; &#125; &#125;else&#123; //p-&gt;exp &gt; q-&gt;exp temp = (PNode * )malloc(sizeof(PNode)); temp-&gt;ceof = p-&gt;ceof; temp-&gt;exp = p-&gt;exp; temp-&gt;link = q1-&gt;link; q1-&gt;link = temp; p = p-&gt;link; &#125; &#125; return OK;&#125;void Output(polynominal *p)&#123; PNode *q = p-&gt;head-&gt;link; int last = 0; while( q!=NULL )&#123; if(q-&gt;link == NULL) last =1; printf(\"%dx^%d\", q-&gt;ceof,q-&gt;exp); if(!last) printf(\"+\"); q = q-&gt;link; &#125; printf(\"\\n\");&#125;void Destory(polynominal *p)&#123; PNode *q = NULL; while(p-&gt;head)&#123; q = p-&gt;head-&gt;link; free(p-&gt;head); p-&gt;head = q; &#125;&#125;/***********合并同类项*****************//***********合并即free*****************/Status unify(polynominal *t)&#123; PNode *p=NULL; PNode *q=NULL; PNode *last=NULL; PNode *tmp; //while(p-&gt;link != NULL)&#123; for(p=t-&gt;head-&gt;link;p!=NULL;p=p-&gt;link)&#123; //选择 last = p; for(q=last-&gt;link; q!=NULL ; )&#123; //q指针向后推移指向下一结点 if(q-&gt;exp == p-&gt;exp)&#123; //相等计算 p-&gt;ceof += q-&gt;ceof; //q为 滑动项 tmp = q-&gt;link; last-&gt;link = q-&gt;link; //last保存上一个q free(q); // 吧q的空间释放掉 q= tmp; &#125;else&#123; last= q; q=q-&gt;link;&#125; //如果不相等就判断下一个 &#125; &#125; return OK;&#125;polynominal Multiply(polynominal *px,polynominal *qx)&#123; PNode *p = px-&gt;head; PNode *q = qx-&gt;head; PNode *x = NULL; PNode *tmp = NULL; polynominal newpoly; Init(&amp;newpoly); x = newpoly.head; for (p=px-&gt;head-&gt;link; p!=NULL; p=p-&gt;link)&#123; for (q=qx-&gt;head-&gt;link; q!=NULL; q=q-&gt;link)&#123; tmp = (PNode*)malloc(sizeof(PNode)); tmp-&gt;ceof = p-&gt;ceof * q-&gt;ceof; tmp-&gt;exp = p-&gt;exp + q-&gt;exp; tmp-&gt;link = x-&gt;link; //新生成的结点指向上一个生成的结点的地址 x-&gt;link = tmp; //使链表记录当前tmp结点 x = x-&gt;link; //取下一个结点 &#125; &#125; unify(&amp;newpoly); Sort(&amp;newpoly); return newpoly;&#125;int main()&#123; polynominal p,q; polynominal mul; Create(&amp;p); Output(&amp;p); // printf(\"After unify:\\n\"); Unify // unify(&amp;p); // Output(p); Create(&amp;q); Output(&amp;q); printf(\"After Multiplied:\\n\"); //Mul mul = Multiply(&amp;p,&amp;q); Output(&amp;mul); Add(&amp;p,&amp;q); //ADD printf(\"After added:\"); Output(&amp;q); printf(\"\\n\"); system(\"pause\"); return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"数据结构实验2——二叉树的基本操作及哈夫曼编码译码系统的实现","slug":"数据结构实验2——二叉树的基本操作及哈夫曼编码译码系统的实现","date":"2018-12-28T11:35:38.000Z","updated":"2018-12-28T11:40:12.182Z","comments":true,"path":"2018/12/28/数据结构实验2——二叉树的基本操作及哈夫曼编码译码系统的实现/","link":"","permalink":"https://nymrli.top/2018/12/28/数据结构实验2——二叉树的基本操作及哈夫曼编码译码系统的实现/","excerpt":"","text":"二叉树的遍历及计算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int T;typedef struct BTNode&#123; T Data; struct BTNode *LChild,*RChild;&#125;BTNode;typedef struct BTTree&#123; BTNode *root;&#125;BTTree;/*先序建树*/BTNode* PreCreateBt(BTNode *t)&#123; char ch; ch = getchar(); if( ch == '#' ) t = NULL; else&#123; t = (BTNode *)malloc(sizeof(BTNode)); t-&gt;Data = ch; t-&gt;LChild = PreCreateBt(t-&gt;LChild); t-&gt;RChild = PreCreateBt(t-&gt;RChild); &#125; return t;&#125;void PrebuildTree(BTTree *tree)&#123; tree-&gt;root = PreCreateBt(tree-&gt;root);&#125;/*先序遍历*/void PreOrderTransverse(BTNode *t)&#123; if(t == NULL) return ; printf(\"%c\", t-&gt;Data); PreOrderTransverse(t-&gt;LChild); PreOrderTransverse(t-&gt;RChild);&#125;void TreePreOrder(BTTree *tree)&#123; if(tree) PreOrderTransverse(tree-&gt;root);&#125;/*中序遍历*/void InOrderTransverse(BTNode *t)&#123; if(t == NULL) return ; InOrderTransverse(t-&gt;LChild); printf(\"%c\", t-&gt;Data); InOrderTransverse(t-&gt;RChild);&#125;void TreeInOrder(BTTree *tree)&#123; if(tree) InOrderTransverse(tree-&gt;root);&#125;/*后序遍历*/void AfterOrderTransverse(BTNode *t)&#123; if(t == NULL) return ; AfterOrderTransverse(t-&gt;LChild); AfterOrderTransverse(t-&gt;RChild); printf(\"%c\", t-&gt;Data);&#125;void TreeAfterOrder(BTTree *tree)&#123; if(tree) AfterOrderTransverse(tree-&gt;root);&#125;/*结点数目*/int countNode(BTNode *t)&#123; if( t != NULL) return countNode(t-&gt;LChild)+countNode(t-&gt;RChild)+1; else return 0; //如果t为空,则该t的父亲结点是子结点,该t结点不需要计数&#125;int Nodenum(BTTree *tree)&#123; if(tree) return countNode(tree-&gt;root); else return -1;&#125;/*叶子结点数目*/int countLeafNode(BTNode *t)&#123; if( t != NULL)&#123; if( t-&gt;LChild == NULL &amp;&amp; t-&gt;RChild == NULL) return 1; else return countLeafNode(t-&gt;LChild)+countLeafNode(t-&gt;RChild); &#125; else return 0; //如果t为空,则该t的父亲结点是子结点,该t结点不需要计数&#125;int leafNodenum(BTTree *tree)&#123; if(tree) return countLeafNode(tree-&gt;root); else return -1;&#125;/*计算树的高度*/int coutTreeHeight(BTNode *t)&#123; if(t == NULL) return 0; else &#123; int l = coutTreeHeight(t-&gt;LChild); int r = coutTreeHeight(t-&gt;RChild); if ( l &gt; r) return l+1; else return r+1; // return max(r,l)+1; &#125;&#125;int TreeHeight(BTTree *tree)&#123; if(tree) return coutTreeHeight(tree-&gt;root); else return -1;&#125;/*翻转整个二叉树(左右子树交换)*/BTNode* ReverseLeftRightChild(BTNode *t)&#123; //先序遍历 if(t!=NULL)&#123; if( t-&gt;LChild!=NULL || t-&gt;RChild!=NULL)&#123; BTNode *p,*q; p = ReverseLeftRightChild(t-&gt;LChild); q = ReverseLeftRightChild(t-&gt;RChild); t-&gt;LChild = q; t-&gt;RChild = p; &#125;&#125;return t;&#125;void ReverseBtree(BTTree *tree)&#123; if(tree) ReverseLeftRightChild(tree-&gt;root);&#125;int main(int argc, char const *argv[])&#123; BTTree tree; printf(\"先序建树:\"); PrebuildTree(&amp;tree); printf(\"\\n先序遍历:\"); TreePreOrder(&amp;tree); printf(\"\\n中序遍历:\"); TreeInOrder(&amp;tree); printf(\"\\n后序遍历:\"); TreeAfterOrder(&amp;tree); printf(\"\\n结点数目:%d\\n\",Nodenum(&amp;tree)); printf(\"\\n叶子结点数目:%d\\n\",leafNodenum(&amp;tree)); printf(\"\\n树的高度:%d\\n\",TreeHeight(&amp;tree)); printf(\"翻转二叉树:\\n\"); ReverseBtree(&amp;tree); printf(\"\\n后序遍历:\"); TreeAfterOrder(&amp;tree); printf(\"\\n\"); return 0;&#125; 哈夫曼树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;stdio.h&gt;#define n 5 //叶子数目#define m (2*n-1) //结点总数#define maxval 10000.0#define maxsize 100 //哈夫曼编码的最大位数typedef struct&#123; char ch; float weight; int lchild,rchild,parent;&#125;hufmtree;typedef struct&#123; char bits[n]; //位串 int start; //编码在位串中的起始位置 char ch; //字符&#125;codetype;//建立哈夫曼树void huffman(hufmtree tree[])&#123; int i,j,p1,p2;//p1,p2分别记住每次合并时 权值最小 和 次小 的两个根结点的下标 float small1,small2,f; char c; for(i=0;i&lt;m;i++)&#123; //初始化 tree[i].parent=0; tree[i].lchild=-1; tree[i].rchild=-1; tree[i].weight=0.0; &#125; for(i=0;i&lt;n;i++)&#123; //读入前n个叶子结点的字符及权值 printf(\"输入第%d个字符为和权值:\",i+1); scanf(\"%c %f\",&amp;c,&amp;f); getchar(); tree[i].ch=c; tree[i].weight=f; &#125; for(i=n;i&lt;m;i++)&#123; //进行n-1次合并，产生n-1个新结点 p1=0;p2=0; small1=maxval;small2=maxval; //maxval是float类型的最大值 for(j=0;j&lt;i;j++) //选出两个权值最小的根结点 if(tree[j].parent==0) if(tree[j].weight&lt;small1)&#123; small2=small1; //改变最小权、次小权及对应的位置 small1=tree[j].weight; p2=p1; p1=j; &#125;else if(tree[j].weight&lt;small2)&#123; small2=tree[j].weight; //改变次小权及位置 p2=j; &#125; tree[p1].parent=i; tree[p2].parent=i; tree[i].lchild=p1; //最小权根结点是新结点的左孩子 tree[i].rchild=p2; //次小权根结点是新结点的右孩子 tree[i].weight=tree[p1].weight+tree[p2].weight; &#125;&#125;//huffman//根据哈夫曼树求出哈夫曼编码//codetype code[]为求出的哈夫曼编码//hufmtree tree[]为已知的哈夫曼树void huffmancode(codetype code[],hufmtree tree[])&#123; int i,c,p; codetype cd; //缓冲变量 for(i=0;i&lt;n;i++)&#123; cd.start=n; cd.ch=tree[i].ch; c=i; //从叶结点出发向上回溯 p=tree[i].parent; //tree[p]是tree[i]的双亲 while(p!=0)&#123; cd.start--; if(tree[p].lchild==c) cd.bits[cd.start]='0'; //tree[i]是左子树，生成代码'0' else cd.bits[cd.start]='1'; //tree[i]是右子树，生成代码'1' c=p; p=tree[p].parent; &#125; code[i]=cd; //第i+1个字符的编码存入code[i] &#125;&#125;//huffmancode//哈夫曼树译码void decode(hufmtree tree[])&#123; int i,j; char b[maxsize]; i=m-1; //从根结点开始往下搜索 printf(\"输入发送的编码(以'#'为结束标志)：\"); gets(b); printf(\"译码后的字符为\"); for(j=0;b[j]!='#';j++)&#123; if(b[j]=='0') i=tree[i].lchild; //走向左孩子 else i=tree[i].rchild; //走向右孩子 if(tree[i].lchild==-1) &#123; //tree[i]是叶结点 printf(\"%c\",tree[i].ch); i=m-1; //回到根结点 &#125; &#125; if(tree[i].lchild!=-1 &amp;&amp; b[j]!= '#') //电文读完，但尚未到叶子结点 printf(\"\\nERROR\\n\"); //输入电文有错&#125;void input(hufmtree tree[],codetype code[])&#123; int i,j;//循环变量 printf(\"【哈夫曼编码】\\n\"); printf(\"总共有%d个字符\\n\",n); huffman(tree);//建立哈夫曼树 huffmancode(code,tree);//根据哈夫曼树求出哈夫曼编码 printf(\"【输出每个字符的哈夫曼编码】\\n\"); for(i=0;i&lt;n;i++)&#123; printf(\"%c: \",code[i].ch); for(j=code[i].start;j&lt;n;j++) printf(\"%c\",code[i].bits[j]); printf(\"\\n\"); &#125;&#125;int main()&#123; hufmtree tree[m]; codetype code[n]; input(tree,code); printf(\"【哈夫曼译码】\\n\"); decode(tree);//依次读入电文，根据哈夫曼树译码 return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"数据结构实验4——各种内排序算法的实现及性能比较","slug":"数据结构实验4——各种内排序算法的实现及性能比较","date":"2018-12-28T11:20:19.000Z","updated":"2019-01-17T12:58:35.900Z","comments":true,"path":"2018/12/28/数据结构实验4——各种内排序算法的实现及性能比较/","link":"","permalink":"https://nymrli.top/2018/12/28/数据结构实验4——各种内排序算法的实现及性能比较/","excerpt":"","text":"部分代码辅助函数1234567891011121314/**生成随机数**/void RandCreate(int *a)&#123; int i; for ( i = 0; i &lt; N; ++i) a[i] = 1 + (rand()%1000);&#125;/***交换数组中,两个下标的值***/void Swap(int *a,int i,int j)&#123; int tmp; tmp = a[i]; a[i] = a[j]; a[j] = tmp;&#125; 简单选择排序 123456789/**简单选择排序**/void SelectSort(int *l)&#123; int minx,i,j; for (i= 0; i &lt; N-1; ++i)&#123; minx = i; //默认标记为每次第一位元素下标 for (j = i+1; j &lt; N; ++j) if( l[minx] &gt; l[j] ) minx = j; if( minx != i) Swap(l,minx,i); //判断起始位置是否为最小值 &#125;&#125; 直接插入排序12345678910111213/**直接插入排序**/void InsertSort(int *l)&#123; int i,j; //i标识待插入元素下标 for(i = 1;i &lt; N;i ++)&#123; int insertItem = l[i]; //标记每次第一位元素 for(j = i-1;j &gt;= 0;j --)&#123; //不断将有序序列中元素向后移动,为待插入元素空出一个位置 if(insertItem &lt; l[j]) l[j+1] = l[j]; else break; &#125; l[j+1] = insertItem; //待插入元素有序存放至有序序列中 &#125;&#125; 冒泡排序12345678910111213141516//冒泡排序void BubbleSort(int *l)&#123; int i,j; //i标识每趟排序范围最后一个元素下标,每趟排序元素下标范围是0~i for(i = N-1;i &gt; 0;i --)&#123; int isSwap = 0; //教材错误,应该放到第二层循环前 for(j = 0; j&lt;i;j ++)&#123; if(l[j] &gt; l[j+1])&#123; Swap(l,j,j+1); isSwap = 1; &#125; &#125; if(!isSwap) break; //如果本趟排序没有发生元素交换,则直接可以认为排序已完成 &#125;&#125; 快速排序1234567891011121314151617181920212223242526272829//序列划分方法int Partition(int *l,int low,int high)&#123; int i = low,j = high + 1; int pivot = l[low]; //pivot是分割元素 do&#123; do i++; while(l[i] &lt; pivot); //i前进 do j--; while(l[j] &gt; pivot); //j前进 if(i &lt; j) Swap(l,i,j); &#125;while(i &lt; j); Swap(l,low,j); return j; //此时j是分割元素下标&#125;//快速排序void QuickSort(int *l,int low,int high)&#123; //快速排序的递归函数 int k; if(low &lt; high)&#123; //当前待排序序列至少包含2个元素 k = Partition(l,low,high); QuickSort(l,low,k-1); QuickSort(l,k+1,high); &#125;&#125;void QSort(int *l)&#123; //快速排序算法的主调用函数 QuickSort(l,0,N-1);&#125; 两路合并排序123456789101112131415161718192021222324252627282930313233343536373839//Merge函数,参考了陈慧南老师的《数据结构——C语言描述》教材void Merge(int *l,int Temp[],int i1,int j1,int i2,int j2,int *k)&#123; int i = i1,j = i2; while((i &lt;= j1)&amp;&amp;(j&lt;=j2))&#123; //若两个子序列都不空,则循环 if(l[i] &lt;= l[j])&#123; Temp[(*k)++] = l[i++]; //将较小元素存入Temp[*k] &#125; else Temp[(*k)++] = l[j++]; &#125; while(i &lt;= j1) Temp[(*k)++] = l[i++]; //将子序列1中剩余元素存入Temp while(j &lt;= j2) Temp[(*k)++] = l[j++]; //将子序列2中剩余元素存入Temp&#125;//MergeSort函数void MergeSort(int *l)&#123; int Temp[N]; int i1,j1,i2,j2,i,k,size = 1; //i1,j1和i2,j2分别是两个子序列的上,下界 while(size &lt; N)&#123; i1 = 0; k = 0; while(i1+size &lt; N)&#123; //若i1+size &lt; n,则说明存在两个子序列,需要再两两合并 i2 = i1+size; //确定子序列2的下界和子序列1的上界 j1 = i2-1; if(i2+size-1 &gt; N-1)&#123; //设置子序列2的上界 j2 = N-1; &#125; else j2 = i2+size-1; Merge(l,Temp,i1,j1,i2,j2,&amp;k); //合并相邻两个子序列 i1 = j2+1; //确定下一次合并第一个子序列的下界 &#125; for(i = 0;i &lt; k;i ++)&#123; l[i] = Temp[i]; &#125; size *= 2; //子序列长度扩大一倍 &#125;&#125; 堆排序123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct heap&#123; int n; int *data;&#125;heap;/**向下调整为最大堆**/void AdjustHeap(int Heap[],int s,int m)&#123; int temp = Heap[s]; for(int j = 2*s+1;j &lt;= m; j *= 2)&#123; if(j &lt; m &amp;&amp;Heap[j] &lt; Heap[j+1]) j++; if(temp &gt; Heap[j]) break; Heap[s] = Heap[j]; s = j; &#125; Heap[s] = temp;&#125;/**建堆**/void CreateHeap(int *heap,int n)&#123; int i; for(i = (n-2)/2;i &gt;= 0;i --) AdjustHeap(heap,i,n);&#125;/**堆初始化**/void heapInit(heap *hp,int *a,int n)&#123; hp-&gt;n = n; hp-&gt;data = (int *)malloc( sizeof(int) *n); int i; for( i = 0;i &lt; n;i ++) hp-&gt;data[i] = a[i]; CreateHeap(hp-&gt;data ,N-1);&#125;/**堆排序**/void HeapSort(heap *hp)&#123; int i; for( i=hp-&gt;n/2 ; i&gt;0 ;i--) AdjustHeap(hp-&gt;data,i,hp-&gt;n); for( i = hp-&gt; n-1 ;i&gt;0;i--)&#123; Swap( hp-&gt;data,0,i); AdjustHeap(hp-&gt;data,0,i-1); &#125;&#125; ▲向下调整法====&gt; 建堆 … 给一堆数据,一次性建堆 ▲向上调整法====&gt; 在已经是最小或最大堆的基础上,增加一个节点,仍保持为最大或最小堆 总体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define N 100000void RandCreate(int *a)&#123; int i; for ( i = 0; i &lt; N; ++i) a[i] = 1 + (rand()%1000);&#125;/***交换数组中,两个下标的值***/void Swap(int *a,int i,int j)&#123; int tmp; tmp = a[i]; a[i] = a[j]; a[j] = tmp;&#125;/**简单选择排序**/void SelectSort(int *l)&#123; int minx,i,j; for (i= 0; i &lt; N-1; ++i)&#123; minx = i; //默认标记为每次第一位元素下标 for (j = i+1; j &lt; N; ++j) if( l[minx] &gt; l[j] ) minx = j; if( minx != i) Swap(l,minx,i); //判断起始位置是否为最小值 &#125;&#125;/**直接插入排序**/void InsertSort(int *l)&#123; int i,j; //i标识待插入元素下标 for(i = 1;i &lt; N;i ++)&#123; int insertItem = l[i]; //标记每次第一位元素 for(j = i-1;j &gt;= 0;j --)&#123; //不断将有序序列中元素向后移动,为待插入元素空出一个位置 if(insertItem &lt; l[j]) l[j+1] = l[j]; else break; &#125; l[j+1] = insertItem; //待插入元素有序存放至有序序列中 &#125;&#125;/**冒泡排序**/void BubbleSort(int *l)&#123; int i,j; //i标识每趟排序范围最后一个元素下标,每趟排序元素下标范围是0~i for(i = N-1;i &gt; 0;i --)&#123; int isSwap = 0; //教材错误,应该放到第二层循环前 for(j = 0; j&lt;i;j ++)&#123; if(l[j] &gt; l[j+1])&#123; Swap(l,j,j+1); isSwap = 1; &#125; &#125; if(!isSwap) break; //如果本趟排序没有发生元素交换,则直接可以认为排序已完成 &#125;&#125;/**快速排序**///序列划分方法int Partition(int *l,int low,int high)&#123; int i = low,j = high + 1; int pivot = l[low]; //pivot是分割元素 do&#123; do i++; while(l[i] &lt; pivot); //i前进 do j--; while(l[j] &gt; pivot); //j前进 if(i &lt; j) Swap(l,i,j); &#125;while(i &lt; j); Swap(l,low,j); return j; //此时j是分割元素下标&#125;//快速排序void QuickSort(int *l,int low,int high)&#123; //快速排序的递归函数 int k; if(low &lt; high)&#123; //当前待排序序列至少包含2个元素 k = Partition(l,low,high); QuickSort(l,low,k-1); QuickSort(l,k+1,high); &#125;&#125;void QSort(int *l)&#123; //快速排序算法的主调用函数 QuickSort(l,0,N-1);&#125;/**快速排序**//**两路合并排序**///Merge函数void Merge(int *l,int Temp[],int i1,int j1,int i2,int j2,int *k)&#123; int i = i1,j = i2; while((i &lt;= j1)&amp;&amp;(j&lt;=j2))&#123; //若两个子序列都不空,则循环 if(l[i] &lt;= l[j])&#123; Temp[(*k)++] = l[i++]; //将较小元素存入Temp[*k] &#125; else Temp[(*k)++] = l[j++]; &#125; while(i &lt;= j1) Temp[(*k)++] = l[i++]; //将子序列1中剩余元素存入Temp while(j &lt;= j2) Temp[(*k)++] = l[j++]; //将子序列2中剩余元素存入Temp&#125;//MergeSort函数void MergeSort(int *l)&#123; int Temp[N]; int i1,j1,i2,j2,i,k,size = 1; //i1,j1和i2,j2分别是两个子序列的上,下界 while(size &lt; N)&#123; i1 = 0; k = 0; while(i1+size &lt; N)&#123; //若i1+size &lt; n,则说明存在两个子序列,需要再两两合并 i2 = i1+size; //确定子序列2的下界和子序列1的上界 j1 = i2-1; if(i2+size-1 &gt; N-1)&#123; //设置子序列2的上界 j2 = N-1; &#125; else j2 = i2+size-1; Merge(l,Temp,i1,j1,i2,j2,&amp;k); //合并相邻两个子序列 i1 = j2+1; //确定下一次合并第一个子序列的下界 &#125; for(i = 0;i &lt; k;i ++)&#123; l[i] = Temp[i]; &#125; size *= 2; //子序列长度扩大一倍 &#125;&#125;/**两路合并排序**//*****堆排序*****/typedef struct heap&#123; int n; int *data;&#125;heap;/**向下调整为最大堆**/void AdjustHeap(int Heap[],int s,int m)&#123; int temp = Heap[s]; for(int j = 2*s+1;j &lt;= m; j *= 2)&#123; if(j &lt; m &amp;&amp;Heap[j] &lt; Heap[j+1]) j++; if(temp &gt; Heap[j]) break; Heap[s] = Heap[j]; s = j; &#125; Heap[s] = temp;&#125;/**建堆**/void CreateHeap(int *heap,int n)&#123; int i; for(i = (n-2)/2;i &gt;= 0;i --) AdjustHeap(heap,i,n);&#125;/**堆初始化**/void heapInit(heap *hp,int *a,int n)&#123; hp-&gt;n = n; hp-&gt;data = (int *)malloc( sizeof(int) *n); int i; for( i = 0;i &lt; n;i ++) hp-&gt;data[i] = a[i]; CreateHeap(hp-&gt;data ,N-1);&#125;/**堆排序**/void HeapSort(heap *hp)&#123; int i; for( i=hp-&gt;n/2 ; i&gt;0 ;i--) AdjustHeap(hp-&gt;data,i,hp-&gt;n); for( i = hp-&gt; n-1 ;i&gt;0;i--)&#123; Swap( hp-&gt;data,0,i); AdjustHeap(hp-&gt;data,0,i-1); &#125;&#125;/*****堆排序*****/int main()&#123; srand(time( NULL )); int a[6][N]; int i,j; RandCreate(a[0]); for (int i = 1; i &lt; 6; ++i) for (int j = 0; j &lt; N; ++j) a[i][j] = a[0][j]; double start1 = (double) clock(); SelectSort(a[0]); double end1 = (double) clock(); double diff1 = difftime(end1,start1); printf(\"%18s%10lf\\n\",\"简单选择排序时间:\",diff1); double start2 = (double) clock(); InsertSort(a[1]); double end2 = (double) clock(); double diff2 = difftime(end2,start2); printf(\"%18s%10lf\\n\",\"直接插入排序时间:\",diff2); double start3 = (double) clock(); BubbleSort(a[2]); double end3 = (double) clock(); double diff3 = difftime(end3,start3); printf(\"%18s%10lf\\n\",\"冒泡排序时间:\",diff3); double start5 = (double) clock(); MergeSort(a[4]); double end5 = (double) clock(); double diff5 = difftime(end5,start5); printf(\"%18s%10lf\\n\",\"两路排序时间:\",diff5); double start4 = (double) clock(); QSort(a[3]); double end4 = (double) clock(); double diff4 = difftime(end4,start4); printf(\"%18s%10lf\\n\",\"快速排序时间:\",diff4); heap hp; heapInit(&amp;hp,a[5],N); double start6 = (double) clock(); HeapSort(&amp;hp); double end6 = (double) clock(); double diff6 = difftime(end6,start6); printf(\"%18s%10lf\\n\",\"堆排序时间:\",diff6); system(\"pause\"); return 0;&#125; 关于堆排序的理解限选课对堆排的没有要求,但是在实验中涉及了。平时也没怎么看过堆排序，所以这次写的时候出现了理解上的错误，在此记下： 向上和向下调整法的区别: 区别在于用途不一样，而不是 生成最小堆和最大堆的区别 向下调整法====&gt; 建堆 … 给一堆数据,一次性建堆 向上调整法====&gt; 在已经是最小或最大堆的基础上,增加一个节点,仍保持为最大或最小堆 具体而言： 给定一个乱序的数组，要构建最小或最大堆==&gt; 向下调整 已经是个最大或最小堆的数组,插入或删除一个元素，仍要保持最小堆 ;优先权队列===&gt; 向上调整 123456789101112131415//最大堆void AdjustHeap(int Heap[],int s,int m)&#123; int temp = Heap[s]; for(int j = 2*s+1;j &lt;= m; j *= 2)&#123; if(j &lt; m &amp;&amp;Heap[j] &lt; Heap[j+1])&#123; j++; &#125; if(temp &gt; Heap[j])&#123; break; &#125; Heap[s] = Heap[j]; s = j; &#125; Heap[s] = temp;&#125; 区别在于第5行和第8行 123456789101112131415//最小堆void AdjustHeap(int Heap[],int s,int m)&#123; int temp = Heap[s]; for(int j = 2*s+1;j &lt;= m; j = j*2+1)&#123; if(j &lt; m &amp;&amp;Heap[j] &gt; Heap[j+1])&#123; j++; &#125; if(temp &lt; Heap[j])&#123; break; &#125; Heap[s] = Heap[j]; s = j; &#125; Heap[s] = temp;&#125; 建堆的执行过程大致是: CreateHeap函数从下往上建，即从[s,m]==&gt;[s-1,m],在保证从s到m是最小堆后,再用向下调整法使[s-1,m]也成为堆。 向下调整的过程： 从s–&gt;m,依次调整 总的逻辑是，由于要使左子树和右子树满足要求，所以需要从下往上调整。","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"南邮《信号与系统B》复习知识点大纲","slug":"南邮《信号与系统B》复习知识点大纲","date":"2018-12-26T14:15:36.000Z","updated":"2018-12-28T12:08:06.570Z","comments":true,"path":"2018/12/26/南邮《信号与系统B》复习知识点大纲/","link":"","permalink":"https://nymrli.top/2018/12/26/南邮《信号与系统B》复习知识点大纲/","excerpt":"","text":"友情提示请将图片右键另存为，保存到本地放大查看。 第一章 第二章","categories":[],"tags":[{"name":"学业","slug":"学业","permalink":"https://nymrli.top/tags/学业/"}]},{"title":"不蒜子统计阅读次数失效——Cxo主题","slug":"不蒜子统计阅读次数失效","date":"2018-12-26T00:57:37.000Z","updated":"2018-12-26T01:11:43.622Z","comments":true,"path":"2018/12/26/不蒜子统计阅读次数失效/","link":"","permalink":"https://nymrli.top/2018/12/26/不蒜子统计阅读次数失效/","excerpt":"","text":"官方通知 12&gt; ！！！！2018年9月 - 重要提示 ！！！！大家好，因七牛强制过期原有的『dn-lbstatics.qbox.me』域名（预计2018年10月初），与客服沟通数次无果，即使我提出为此付费也不行，只能更换域名到『busuanzi.ibruce.info』！因我是最早的一批七牛用户，为七牛至少带来了数百个邀请用户，很痛心，很无奈！各位继续使用不蒜子提供的服务，只需把原有的：&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;域名改一下即可：&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;只需要修改该js域名，其他均未改变。若有疑问，可以加入不蒜子交流QQ群：`419260983`，对您带来的不便，非常抱歉！！！还是那句话，不蒜子不会中断服务！！！！&gt; 不蒜子 原因分析由于定位到是不蒜子统计功能突然有问题了，所以前往不蒜子官网进行查看，发现官网有一段很重要的提示： “因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！” 所以定位到问题，原来是不蒜子使用的七牛的域名被强制过期。 需要把 dn-lbstatics.qbox.me 域名更换为 busuanzi.ibruce.info 实际操作找到含busuanzi插件设置的文件 修改指向的网址 修改完后","categories":[],"tags":[]},{"title":"Ubuntu下Sublime配置python编译环境及新手使用指导","slug":"Ubuntu下Sublime配置python编译环境及新手使用指导","date":"2018-12-26T00:41:18.000Z","updated":"2019-03-28T02:56:14.409Z","comments":true,"path":"2018/12/26/Ubuntu下Sublime配置python编译环境及新手使用指导/","link":"","permalink":"https://nymrli.top/2018/12/26/Ubuntu下Sublime配置python编译环境及新手使用指导/","excerpt":"","text":"##Sublime下配置python编译环境及搭建虚拟环境:(windows下大致相同) 1.编译环境配置 2019-3-6更新教程，发现好像 官方网址打不开了，要改一下源才行。 解决办法： 点击 Preferences -&gt; Settings -&gt; Preferences.sublime-Settings—— User(一个新窗口) 添加配置(在原有大括号{}里面添加)：&quot;channels&quot;: [&quot;https://raw.githubusercontent.com/HBLong/channel_v3_daily/master/channel_v3.json&quot;], 代码不变，仍然是下面的代码 感谢HBLong提供的解决方案和源: 原有链接 : 解决：Sublime Text3 packagecontrol.io 无法访问的问题 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 1.点击 官方网址 从 Sublime Text 3 官方获取用于安装的代码。从菜单栏View –&gt;Show Console或者使用Ctrl+`(esc键下面的按键)，调出sublime的控制台，将官网中的python代码粘贴进去并按Enter执行，最终可以安装完成。在控制台中粘贴刚才的代码，然后点击回车。最后重启ST3。2.现在你可以通过快捷键 cmd+shift+P 打开 Package Control 来安装其他的插件了。输入 install 然后你就能看见屏幕上出现了 Package Control: Install Package，点击回车,然后搜索sublimeREPL 安装成功后，可以在菜单栏的’TOOL’中找到SublimeREPL，如图所示 2.将菜单栏改为中文 若需要将菜单栏改成中文可如上操作下载插件“ConvertToUTF8”或是安装插件“ChineseLocalizations”(本人使用的是这个，没试ConvertToUTF8的效果) (参考博客:http://blog.51cto.com/11970781/2087971) 3.安装Anaconda插件 1.点击刚刚生成的Package Control -&gt;输入install2.进入安装界面，安装好后再在新窗口命令行中输入Anaconda并点击第一个备选项进行安装。 安装完成后会显示messages文档。 安装Anaconda插件完成之后，会看到如下选项栏，说明Anaconda安装成功。 Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数或者类的定义。 Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下) Anaconda会自动补全代码，之前用惯了pycharm发现突然没了代码补全后很不习惯，Anaconda的补全功能虽然没有pycharm那么好用，但还是不错的还有需要注意的是，安装Anaconda插件后，如果python代码没有遵循PEP8规范，会出现白色的框框，或是可以使用快捷键Ctrl+Alt+R进行规范代码(这个可以去除，步骤如下) 在Settings-User选项中添加配置:{&quot;anaconda_linting&quot;:false} 4.安装虚拟环境 1.首先使用终端安装virtualenv，pip3 install virtualenv2.在需要创建的地方进行虚拟环境的搭建，代码如下：123mkdir pytest(文件夹名)cd pytestvirtualenv venv 1.在终端进入虚拟环境的话是在pytest文件夹下输入命令source /bin/activate而要在sublime中进入虚拟环境的话就得按照如下操作：首先在sublime中安装virtualenv插件，Ctrl + Shift + P，然后输入install,回车，然后搜索virtualenv。 可能出现的问题: :dart:由于 官方网址打不开的缘故，需要换源，但是根据#1.编译环境配置设置的channel貌似还是会出错,如果出错按如下方法解决 2.安装完成virtualenv插件后，直接按Ctrl + Shift + P，再输入Activate，若没有该选项则virtualenv安装中出现问题，需要重新安装。如果有的会选择Activate就能发现刚刚创建的虚拟环境，选中后回车即可进入虚拟环境 3.如果Activate选中后没有出现我们刚刚创建的虚拟环境，则需要我们手动添加路径.Ctrl + Shift + P，然后输入Add directory，回车，屏幕下面会出现输入行（Directory path）:再将刚创建的虚拟环境路径填入即可 另外，我曾碰到过Add directory后仍然没用的情况。那时，可选择“”Project”=&gt;”Add folder to project”选择文件后=&gt;”Save Project as”==&gt;保存好即可工程配置文件为：.sublime-workspace、.sublime-project其中sublime-project为: 123456789101112131415161718&#123; \"build_systems\": [ &#123; \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\", \"name\": \"Anaconda Python Builder\", \"selector\": \"source.python\", \"shell_cmd\": \"\\\"python\\\" -u \\\"$file\\\"\" &#125; ], \"folders\": [ &#123; \"path\": \"爬虫\" &#125; ], \"virtualenv\": \"G:\\\\pachong\\\\venv\"&#125; 这样环境就配置好了。按Ctrl+B编译时，观察”Tools”-&gt;”Build System”-&gt;是否为”Python+ Virtualenv”，如果不是，则选用这个再Ctrl+B就是在虚拟环境中编译了! ubuntu下sublime默认情况下好像不能输入中文，需要用下面命令就可以完美支持中文输入：1234$ sudo apt-get update &amp;&amp; sudo apt-get upgrade$ git clone https://github.com/lyfeyaj/sublime-text-imfix.git$ cd sublime-text-imfix$ ./sublime-imfix 转自博客截图好像有点问题，菜单栏都没有截到，用到的三个分别为“项目(Project)”，“首选项(Preferences)”，“帮助(Help)” 附录无论是Python或者C/C++程序按Ctrl+b后运行没有输出。发现是编译选项出了问题。 解决方法如下： 按下Ctrl +Shift + b选择编译方法，光标移到有Run的选项,再按Ctrl+b编译 成功如图~","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"}]},{"title":"PythonWeb--flask部署内网电脑","slug":"PythonWeb-flask部署内网电脑","date":"2018-12-21T14:08:04.000Z","updated":"2018-12-22T04:37:07.907Z","comments":true,"path":"2018/12/21/PythonWeb-flask部署内网电脑/","link":"","permalink":"https://nymrli.top/2018/12/21/PythonWeb-flask部署内网电脑/","excerpt":"","text":"PythonWeb–flask部署问题以前在云服务器上都是用root权限部署的,很流畅..这次用了活动室电脑是管理员权限apollo3d..于是出现了很大的问题…. 内网穿透活动室电脑的IP是通过路由器分配的IP,如192.168.1.145,这是一个局域网,别人是不可能通过这个IP访问到你的服务器的.（访问都是通过公网的。除非两台电脑在同一个局域网内）。 于是想到直接连活动室的网不就行了吗（如果活动室的是公网IP，只要对路由器设置个端口映射就行了），但发现，活动室的IP也是校园网分配的，已经经过了多次的NAT，于是这个方法也没用。 搜了下网上关于“内网中的电脑当做服务器”，找到了方案就是“内网穿透”，而能实现这个功能的软件不少如花生壳、frp…在此,我用花生壳达成了目的,花了6元… 花生壳注册账号后会送给你一个域名，而“内网穿透”的功能是需要买的。他实现的原理大致是将动态变化的IP绑定在了这个域名上，每次IP变换的时候就重新DNS解析，所以达成了“IP跟随” 设置好后，就可以直接通过域名访问到内网下的电脑了！ 非root权限——管理员权限之前都是部署在/var/www目录下的,这次也没多想,也照样…结果踩了坑,弄了几小时. 先是pip install virtualenv安装了virtualenv库,然后用virtualenv env新建了个虚拟环境 但问题来了，windows下的目录结构跟linux下的有些小小的不同,导致运行uwsgi报错No module flask时一直没找到原因 linux下结构:1234567891011--|env-----|lib-------|python---------|site-packagess---------|.....-----|includes--------|python3.5m-----|bin-------|python3.5-------|pip-------|activate 正常情况下只要激活了虚拟环境,那么pip安装的库应该都是在该虚拟环境下的,这次出了什么问题呢?1.猜测没有site-packages当时因为linux终端显示的原因没看到site-packages,于是就以为没有linux下建立的虚拟环境没有site-packages,但事实证明这个是没有关系的.. 2.uwsgi.ini没有指定虚拟环境网上给出的都是因为没有进入虚拟环境执行或者是配置中没有指定虚拟环境路径 3.加了sudo根据报错显示知道，sudo pip install -r requirements.txt的库都安装到了默认python目录下了…原因是因为加了sudo. ▲一定不要使用sudo pip … ,这里是在虚拟环境中安装python包，如果使用了sudo权限，python包会被安装在主机非虚拟环境下，在虚拟环境中找不到这个包。 永远不要使用sudo pip install; 你可以在不知情的情况下覆盖重要的东西。使用pip install –user代替 于是那就不加吧,命令改为pip install -r requirements.txt,此时有报错Could not install packages due to anEnvironmentError: [Error 13] Permission denied:...,consider using &#39;--user&#39; options,既然提示用--user参数那就试试吧. 结果返回的是Can not perform a &#39;--user&#39; install. User site-packages are not visible in this virtualenv,这是为什么还是不行呢? 官方解释 pip install --user 遵循四条规则： 当全局安装的软件包位于python路径上，并且它们 与安装要求冲突时，它们将被忽略，而不会被 卸载。 当全局安装的软件包位于python路径上并且它们满足 安装要求时，pip什么都不做，并报告满足要求（类似于在--system-site-packages virtualenv中安装软件包时全局软件包如何满足要求）。 由于用户站点不在python路径上，因此pip不会--user在--no-site-packages的virtualenv（即默认类型的virtualenv）中执行安装。安装没有意义。 123import sysprint(sys.path)&gt;&gt;&gt; ['C:\\\\Users\\\\10630\\\\Desktop', 'D:\\\\python\\\\python36.zip', 'D:\\\\python\\\\DLLs', 'D:\\\\python\\\\lib', 'D:\\\\python', 'C:\\\\Users\\\\10630\\\\AppData\\\\Roaming\\\\Python\\\\Python36\\\\site-packages', 'D:\\\\python\\\\lib\\\\site-packages', 'D:\\\\python\\\\lib\\\\site-packages\\\\win32', 'D:\\\\python\\\\lib\\\\site-packages\\\\win32\\\\lib', 'D:\\\\python\\\\lib\\\\site-packages\\\\Pythonwin'] 在--system-site-packagesvirtualenv中，pip不会安装与virtualenv site-packages中的包冲突的包。-user安装缺少sys.path优先级并且毫无意义。 那应该就是3的原因了…需要在当前的env虚拟环境中将权限开放,我的做法是sudo chmod 777 -R * 最终解决方式:于是我并没有再纠结这个,而是选择了不在/var/www这个目录下,因为这个目录下的权限关系非常严格,于是我在~/Documents/env新建了个虚拟环境,一切又如以前一样解决了. Ubuntu下使用matplotlib库,需要安装python3-tk`”raise ImportError(str(msg) + ‘, please install the python3-tk package’) ImportError: No module named ‘_tkinter’, please install the python3-tk package”的错误 解决方案:sudo apt-get install python3-tk(如果没更新源,最好更新下源) 附录:sudo-pip-install-vs-pip-install-user:回答1:sudo pip install可能意味着您要在系统范围内安装软件包。对于某些软件包，例如virtualenvwrapper，这可能是有用的，但除此之外，我将避免安装系统范围的软件包并为每个应用程序创建virtualenv并将pip安装到该virtualenv（可以在没有sudo的情况下完成）。 回答2:1$ sudo pip install 在python安装中全局安装包，即对所有用户安装。 1$ pip install --user 安装到本地用户目录，即〜/ .local / lib / python - 只是你。 例： 12$ sudo pip install jupyter$ jupyter notebook 将运行jupyter，打开Web浏览器，允许您使用笔记本。 12$ pip install --user jupyter$ jupyter notebook 在将本地目录添加到PATH之前，将不执行任何操作。 最近pypi中包含了恶意代码。切勿使用sudo来安装pip。这与以root身份运行病毒相同。将本地文件夹添加到PATH或使用virtualenv。","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"配置环境","slug":"配置环境","permalink":"https://nymrli.top/tags/配置环境/"}]},{"title":"Pandas速成","slug":"Pandas速成","date":"2018-12-21T13:57:29.000Z","updated":"2018-12-21T13:57:48.527Z","comments":true,"path":"2018/12/21/Pandas速成/","link":"","permalink":"https://nymrli.top/2018/12/21/Pandas速成/","excerpt":"","text":"Pandas速成 Series : 一位数组, 只允许存储相同的数据类型 Time-Series : 以时间为索引的Series DataFrame : 二维的表格型数据结构 , 可以理解为是Series 的容器 Panel : 三维数组,可以理解为DataFrame 的容器 Series1234567891011121314151617import matplotlib.pyplot as pltimport pandas as pdimport numpy as nparr = np.array([1,2,3])index = ['a','b','c']myseries = pd.Series(arr,index)print(myseries)print('Series中第一个元素&#123;&#125;'.format(myseries[0]))print('Series中索引为C的元素'.format(myseries['c']))&gt;&gt;&gt;a 1b 2c 3dtype: int32Series中第一个元素1Series中索引为C的元素 DataFrame1234567891011121314arr= np.array([ [1,2,3], [2,3,4], [3,4,5]])rowindex = ['row1','row2','row3']colindex = ['col1','col2','col3']dataframe= pd.DataFrame(data=arr,index= rowindex,columns=colindex)print(dataframe)&gt;&gt;&gt; col1 col2 col3row1 1 2 3row2 2 3 4row3 3 4 5 1234567891011121314arr= np.array([ [1,2,3], [2,3,4], [3,4,5]])rowindex = [&apos;row1&apos;,&apos;row2&apos;,&apos;row3&apos;]colindex = [&apos;col1&apos;,&apos;col2&apos;,&apos;col3&apos;]dataframe= pd.DataFrame(data=arr,index = rowindex,columns=colindex)print(dataframe._ixs(0))&gt;&gt;&gt;col1 1col2 2col3 3Name: row1, dtype: int32 获取行列 1.ix[ ] 先行后列 12345print(dataframe.ix[[0]]) #获得第一行内容# print(dataframe.ix[&apos;row1&apos;]) #以索引名称获得print(dataframe.ix[[0]])` #获得第一列内容print(dataframe.ix[:,&apos;col1&apos;]) 2.loc[ ] loc,是基于索引的名称选取数据集，这里的索引名称可以是数字,先行后列。注意，[0:2]是选取名称为0， 1， 2行的数据，一共三，只能写行和列的名称，不能写序号。 123456789print(dataframe.loc[&apos;row1&apos;])&gt;&gt;&gt; col1 1col2 2col3 3Name: row1, dtype: int32print(dataframe.loc[:,&apos;col1&apos;]) #获得&apos;col1&apos;列的值print(dataframe.loc[&apos;row1&apos;,&apos;col1&apos;]) #获得某行某列的值 3.iloc[] iloc，它是基于索引位来选取数据集，也就是数字序号来选取，0:2就是选取 0，1这两行，需要注意的是这里是前闭后开集合。只能写行和列的序号，不能写名称，否则会报错。 12345678print(dataframe.iloc[2])&gt;&gt;&gt; col1 3col2 4col3 5Name: row3, dtype: int32print(dataframe.iloc[0,:])","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"BaiduMap_API","slug":"BaiduMap-API","date":"2018-12-21T13:55:50.000Z","updated":"2018-12-21T13:56:37.113Z","comments":true,"path":"2018/12/21/BaiduMap-API/","link":"","permalink":"https://nymrli.top/2018/12/21/BaiduMap-API/","excerpt":"","text":"Baidu Map API核心类Map 构造函数 描述 Map(container: String \\ HTMLElement, opts: MapOptions) 在指定的容器内创建地图实例，之后需要调用Map.centerAndZoom()方法对地图进行初始化。未进行初始化的地图将不能进行任何操作 12var map = new BMap.Map(\"MAP\");map.centerAndZoom(points[0], 15); 方法 返回值 描述 enableDragging() none 启用地图拖拽，默认启用 enableScrollWheelZoom() none 启用滚轮放大缩小，默认禁用 enableDoubleClickZoom() none 启用双击放大，默认启用 enableKeyboard() none 启用键盘操作，默认禁用。 enablePinchToZoom() none 启用双指操作缩放，默认启用 enableAutoResize() none 启用自动适应容器尺寸变化，默认启用 setMinZoom(zoom: Number) none 设置地图允许的最小级别。取值不得小于地图类型所允许的最小级别 getCenter() Point 返回地图当前中心点 getDistance(start: Point, end: Point) Number 返回两点之间的距离，单位是米 centerAndZoom(center: Point, zoom: Number) none 设初始化地图。 如果center类型为Point时，zoom必须赋值，范围3-19级，若调用高清底图（针对移动端开发）时，zoom可赋值范围为3-18级。如果center类型为字符串时，比如“北京”，zoom可以忽略，地图将自动根据center适配最佳zoom级别 panTo(center: Point, opts: PanOptions) none 将地图的中心点更改为给定的点。如果该点在当前的地图视图中已经可见，则会以平滑动画的方式移动到中心点位置。可以通过配置强制移动过程不使用动画效果 setCenter(center: Point \\ String) none 设置地图中心点。center除了可以为坐标点以外，还支持城市名 getZoom() Number 返回地图当前缩放级别 setZoom(zoom: Number) none 将视图切换到指定的缩放等级，中心点坐标不变。注意：当有信息窗口在地图上打开时，地图缩放将保证信息窗口所在的坐标位置不动 addOverlay(overlay: Overlay) none 将覆盖物添加到地图中，一个覆盖物实例只能向地图中添加一次 clearOverlays() none 清除地图上所有覆盖物 控件类Control基类 initialize(map: Map) HTMLElement 抽象方法。调用Map.addControl()方法添加控件时将调用此方法，从而实现该控件的初始化。自定义控件时需要实现此方法，并将元素的DOM元素在该方法中返回。DOM元素需要添加到地图的容器中，使用map.getContainer()方法可获得地图容器元素 setAnchor(anchor: ControlAnchor) none 设置控件停靠的位置 getAnchor() ControlAnchor 返回控件停靠的位置 setOffset(offset: Size) none 设置控件停靠的偏移量 getOffset() Size 返回控件停靠的偏移量 show() none 显示控件 hide() none 隐藏控件 isVisible() Boolean 判断控件的可见性 ControlAnchor: 此常量表示控件的定位。 常量 描述 BMAP_ANCHOR_TOP_LEFT 控件将定位到地图的左上角 BMAP_ANCHOR_TOP_RIGHT 控件将定位到地图的右上角 BMAP_ANCHOR_BOTTOM_LEFT 控件将定位到地图的左下角 BMAP_ANCHOR_BOTTOM_RIGHT 控件将定位到地图的右下角 NavigationControl 此类表示地图的平移缩放控件，可以对地图进行上下左右四个方向的平移和缩放操作。 GeolocationControl 此类是负责进行地图定位的控件，使用html5浏览器定位功能，此类继承Control所有功能。 OverviewMapControl 此类表示缩略地图控件。 ScaleControl 此类表示比例尺控件。 CopyrightControl 此类表示版权控件，您可以在地图上添加自己的版权信息。每一个版权信息需要包含如下内容：版权的唯一标识、版权内容和其适用的区域范围。 覆盖物类Marker:此类表示地图上一个图像标注。 构造函数 描述 Marker(point: Point, opts: MarkerOptions) 创建一个图像标注实例。point参数指定了图像标注所在的地理位置 1234markers = new BMap.Marker(new BMap.Point(118.93015,32.1091),&#123;\"title\":'Point'&#125;);label = new BMap.Label('label');markers.setLabel(l);map.addOverlay(markers); Icon此类表示标注覆盖物所使用的图标。 构造函数 描述 Icon(url: String, size: Size, opts: IconOptions) 以给定的图像地址和大小创建图标对象实例 Label此类表示地图上的文本标注。 构造函数 描述 Label(content: String, opts: LabelOptions) 创建一个文本标注实例。point参数指定了文本标注所在的地理位置 1234label = new BMap.Label(\"\", &#123;offset: new BMap.Size(-20, -20)&#125;); car = new BMap.Marker(points[0]); car.setLabel(label); map.addOverlay(car);","categories":[],"tags":[{"name":"API","slug":"API","permalink":"https://nymrli.top/tags/API/"}]},{"title":"Postman模拟上传文件","slug":"Postman模拟上传文件","date":"2018-12-20T10:57:35.000Z","updated":"2018-12-20T12:11:59.979Z","comments":true,"path":"2018/12/20/Postman模拟上传文件/","link":"","permalink":"https://nymrli.top/2018/12/20/Postman模拟上传文件/","excerpt":"","text":"Postman模拟1.首先得知道前端的样子: 2.针对前端字段进行模拟POST ▲这边key为&lt;input&gt;中的name属性 ▲▲URL最后的’/‘:POST请求URL要对应12345@app.route(&apos;/photo/&apos;,methods = [&apos;GET&apos;,&apos;POST&apos;] )http://127.0.0.1:5000/photo/@app.route(&apos;/photo&apos;,methods = [&apos;GET&apos;,&apos;POST&apos;] )http://127.0.0.1:5000/photo ​ 当Web服务器接收到对某个末尾不含斜杠的url请求时，例如“http://www.abc.com/abc”，这时服务器会搜索网站根目录下有没有名为“abc”的文件，**如果没有就把abc当做目录处理**，然后返回abc目录下的默认首页。当Web服务器接收到的是末尾带斜杠的请求时就会直接当做目录处理。，当浏览器解析 /ie 这样的url时，服务器会执行301转向到/ie/，两个链接都有效，但是第二种更快。 ​ 对于静态资源服务器来说，请求https://imgss.github.io/demo/这样的路径能访问到页面，是因为服务器会自动在demo路径下尝试找index.html之类的文件并发给浏览器，所以html的当前路径一定是demo下的，也是因为这样，浏览器才会通过重定向自动加上/，防止相对路径解析出错，保证浏览器能正确的请求到资源。 requests模拟1234567url = 'http://127.0.0.1:5000/photo/'filename = &#123; 'src' : open(\"C:\\\\Users\\\\10630\\\\Desktop\\\\为什么电流被一分为2.jpg\",'rb')&#125;html = requests.post(url,files=filename)print(html.text)# &#123;\"msg\":\"success\",\"status\":200&#125;","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Postman","slug":"Postman","permalink":"https://nymrli.top/tags/Postman/"}]},{"title":"flask-sqlalchemy踩坑——外键","slug":"flask-sqlalchemy踩坑","date":"2018-12-19T11:47:54.000Z","updated":"2018-12-19T11:56:43.863Z","comments":true,"path":"2018/12/19/flask-sqlalchemy踩坑/","link":"","permalink":"https://nymrli.top/2018/12/19/flask-sqlalchemy踩坑/","excerpt":"","text":"12.19：外键使用今天要设计一个如图关系的表关系时,踩了好几个坑…记录下 代码: 123456789101112131415161718192021222324from exts import dbclass Account(db.Model): __tablename__ = 'account' id = db.Column(db.Integer,primary_key=True,autoincrement=True) Username = db.Column(db.String(30),nullable=True,unique=True) PWD = db.Column(db.String(20),nullable=True) email = db.Column(db.String(20),nullable=True,unique=True)class Info(db.Model): __tablename__ = 'info' id = db.Column(db.Integer,primary_key=True,autoincrement=True) email = db.Column(db.String(20),db.ForeignKey('account.email')) timestamp = db.Column(db.Float,nullable=True,unique=True)class Tmp(db.Model): __tablename__ = 'tmp' id = db.Column(db.Integer,primary_key=True,autoincrement=True) tmp = db.Column(db.Float,db.ForeignKey('info.timestamp')) # 一组的开始时间 nowtime = db.Column(db.FLOAT,nullable=True) # 当前记录的时间 longitude = db.Column(db.FLOAT,nullable=True) latitude = db.Column(db.FLOAT,nullable=True) id的类型是int,没有id这种类型 ▲.外键必须是主表的唯一键(unique)（如上，学生表 sid 是主键，而主键是唯一的，所以能够作为分数表 stu 的外键） 外键不一定须要作为从表的主键。外键也不一定是主表的主键。主表的唯一键就能够作为从表的外键。 外键的类型必须与父表的主键类型完全一致(类型和长度) 总结下来：","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"数据库","slug":"数据库","permalink":"https://nymrli.top/tags/数据库/"}]},{"title":"数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题","slug":"数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题","date":"2018-12-16T09:50:05.000Z","updated":"2018-12-16T10:30:17.535Z","comments":true,"path":"2018/12/16/数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题/","link":"","permalink":"https://nymrli.top/2018/12/16/数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题/","excerpt":"","text":"实验3.图的基本运算及职能交通中的最佳路径选择问题3.2-邻接矩阵的DFS和BFS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define ERROR 0#define OK 1#define Overflow 2 //表示上溢#define Underflow 3 //表示下溢#define NotPresent 4 //表示元素不存在#define Duplicate 5 //表示有重复元素#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status;typedef int BOOL;/************队列操作**************///循环队列的结构体定义typedef struct&#123; int front; int rear; int maxSize; //最大容量 ElemType *element;&#125;Queue;//创建一个能容纳mSize个单元的空队列void Create(Queue *Q,int mSize)&#123; Q-&gt;maxSize=mSize; Q-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize); Q-&gt;front=Q-&gt;rear=0;&#125; //判断队列是否为空,若是,则返回TRUE;否则返回FALSEBOOL IsEmpty(Queue *Q)&#123; return Q-&gt;front==Q-&gt;rear;&#125; //判断队列是否已满,若是,则返回TRUE,否则返回FALSEBOOL IsFULL(Queue *Q)&#123; return (Q-&gt;rear+1)%Q-&gt;maxSize==Q-&gt;front;&#125; //获取队头元素,并通过x返回.若操作成功,则返回TRUE,否则返回FALSEBOOL Front(Queue *Q,ElemType *x)&#123; if(IsEmpty(Q)) //空队列处理 return FALSE; *x=Q-&gt;element[(Q-&gt;front+1)%Q-&gt;maxSize]; return TRUE;&#125; //入队.在队列Q的队尾插入元素x(入队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL EnQueue(Queue *Q,ElemType x)&#123; if(IsFULL(Q)) //溢出处理 return FALSE; Q-&gt;rear=(Q-&gt;rear+1)%Q-&gt;maxSize; Q-&gt;element[Q-&gt;rear]=x; return TRUE;&#125; //出队.从队列Q中删除队头元素(出队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL DeQueue(Queue *Q)&#123; if(IsEmpty(Q))&#123; //空队列处理 return FALSE; &#125; Q-&gt;front=(Q-&gt;front+1)%Q-&gt;maxSize; return TRUE;&#125; /************队列操作**************///邻接矩阵的结构体定义typedef struct&#123; ElemType **a; //邻接矩阵 int n; //图的当前顶点数 int e; //图的当前边数 ElemType noEdge; //两顶点间无边时的值&#125;mGraph; //邻接矩阵的初始化Status Init(mGraph *mg,int nSize,ElemType noEdgeValue)&#123; int i,j; mg-&gt;n = nSize; //初始化顶点数 mg-&gt;e = 0; //初始化时没有边 mg-&gt;noEdge = noEdgeValue; //初始化没有边时的取值 mg-&gt;a = (ElemType**)malloc(nSize*sizeof(ElemType *)); //生成长度为n的一维指针数组 if(!mg-&gt;a) return ERROR; for(i = 0;i &lt; mg-&gt;n;i ++)&#123; //动态生成二维数组 mg-&gt;a[i] = (ElemType*)malloc(nSize*sizeof(ElemType)); for(j = 0;j &lt; mg-&gt;n;j ++)&#123; mg-&gt;a[i][j] = mg-&gt;noEdge; &#125; mg-&gt;a[i][i] = 0; //自回路设置为0 &#125; return OK;&#125; //邻接矩阵的撤销(改成了int型，有返回值),先释放一维数组,再释放指针数组int Destory(mGraph *mg)&#123; int i; for(i = 0;i &lt; mg-&gt;n;i ++)&#123; free(mg-&gt;a[i]); //释放n个一维数组的存储空间 &#125; free(mg-&gt;a); //释放一维数组的存储空间 return 1;&#125; //邻接矩阵的边的搜索Status Exist(mGraph *mg,int u,int v)&#123; if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v||mg-&gt;a[u][v] == mg-&gt;noEdge) return ERROR; return OK;&#125; //邻接矩阵的边的插入Status Insert(mGraph *mg,int u,int v,ElemType w)&#123; if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v) return ERROR; if(mg-&gt;a[u][v] != mg-&gt;noEdge) return Duplicate; //若待插入边已存在,则返回出错信息 mg-&gt;a[u][v] = w; //插入新边 mg-&gt;e ++; //增加一条边 return OK;&#125; //邻接矩阵的边的删除Status Remove(mGraph *mg,int u,int v)&#123; if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v) return ERROR; if(mg-&gt;a[u][v] == mg-&gt;noEdge) return NotPresent; //若待删除边不存在,则返回出错信息 mg-&gt;a[u][v] = mg-&gt;noEdge; //删除边 mg-&gt;e --; return OK;&#125; void DFS(mGraph mg,int v,int visited[])&#123; int j; printf(\"%d\",v ); visited[v] = 1; for( j = 0; j &lt; mg.n; j++)&#123; //遍历v的邻接点 if(!visited[j] &amp;&amp; mg.a[v][j] &gt; 0)&#123; //当未被访问且有权值 DFS(mg,j,visited); &#125; &#125;&#125;//DFS搜索全图void DFSGraph(mGraph mg)&#123; int i; int *visited = (int *)malloc(mg.n * sizeof(int)); //访问为1,未访问为0 for(i=0; i&lt; mg.n;i++) visited[i] = 0; //visted数组初始化 for(i=0;i&lt; mg.n; i++) if( !visited[i] ) DFS(mg,i,visited); free(visited); //整个图的DFS遍历后,释放visted数组&#125; void BFS(mGraph mg,int v,int visited[])&#123; Queue q; Create(&amp;q,mg.n); visited[v] = 1; printf(\"%d\",v); EnQueue(&amp;q,v); //将当前顶点v放入队列 while( !IsEmpty(&amp;q) )&#123; Front(&amp;q,&amp;v); DeQueue(&amp;q); //队首顶点出队列 for(int i = 0;i &lt; mg.n;i ++)&#123; //遍历图的每一项 if( !visited[i] &amp;&amp; mg.a[v][i] &gt; 0)&#123; //若未被访问且有权值,则将其访问并放入队列 visited[i] = 1; printf(\"%d\",i); EnQueue(&amp;q,i); &#125; &#125; &#125;&#125;//BFS搜索全图void BFSGraph(mGraph mg)&#123; int i; int *visited = (int *)malloc(mg.n * sizeof(int)); //访问为1,未访问为0 for(i=0; i&lt; mg.n;i++) visited[i] = 0; //visted数组初始化 for(i=0;i&lt; mg.n; i++) if( !visited[i] ) BFS(mg,i,visited); free(visited); //整个图的BFS遍历后,释放visted数组&#125; int main()&#123; mGraph g; int nSize,edge,u,v,i; ElemType w; printf(\"Enter the mgraph's Size:\"); scanf(\"%d\",&amp;nSize); Init(&amp;g,nSize,-1); printf(\"Enter the mgraph's Edge num:\"); scanf(\"%d\",&amp;edge); for(i = 0;i &lt; edge;i ++)&#123; printf(\"Please enter the edge(Pu,Pv,Weight):\"); scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); Insert(&amp;g,u,v,w); &#125; printf(\"DFS:\"); DFSGraph(g); printf(\"\\nBFS:\"); BFSGraph(g); printf(\"\\n\"); system(\"pause\"); return 0;&#125; 3.4-邻接表的BFS和DFS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define ERROR 0#define OK 1#define Overflow 2 //表示上溢#define Underflow 3 //表示下溢#define NotPresent 4 //表示元素不存在#define Duplicate 5 //表示有重复元素#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status;typedef int BOOL;/************队列操作**************///循环队列的结构体定义typedef struct&#123; int front; int rear; int maxSize; //最大容量 ElemType *element;&#125;Queue;//创建一个能容纳mSize个单元的空队列void Create(Queue *Q,int mSize)&#123; Q-&gt;maxSize=mSize; Q-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize); Q-&gt;front=Q-&gt;rear=0;&#125; //判断队列是否为空,若是,则返回TRUE;否则返回FALSEBOOL IsEmpty(Queue *Q)&#123; return Q-&gt;front==Q-&gt;rear;&#125; //判断队列是否已满,若是,则返回TRUE,否则返回FALSEBOOL IsFULL(Queue *Q)&#123; return (Q-&gt;rear+1)%Q-&gt;maxSize==Q-&gt;front;&#125; //获取队头元素,并通过x返回.若操作成功,则返回TRUE,否则返回FALSEBOOL Front(Queue *Q,ElemType *x)&#123; if(IsEmpty(Q)) //空队列处理 return FALSE; *x=Q-&gt;element[(Q-&gt;front+1)%Q-&gt;maxSize]; return TRUE;&#125; //入队.在队列Q的队尾插入元素x(入队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL EnQueue(Queue *Q,ElemType x)&#123; if(IsFULL(Q)) //溢出处理 return FALSE; Q-&gt;rear=(Q-&gt;rear+1)%Q-&gt;maxSize; Q-&gt;element[Q-&gt;rear]=x; return TRUE;&#125; //出队.从队列Q中删除队头元素(出队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL DeQueue(Queue *Q)&#123; if(IsEmpty(Q))&#123; //空队列处理 return FALSE; &#125; Q-&gt;front=(Q-&gt;front+1)%Q-&gt;maxSize; return TRUE;&#125; /************队列操作**************///邻接表的结构体定义typedef struct ENode&#123; int adjVex; //任意顶点u相邻的顶点 ElemType w; //边的权值 struct ENode *nextArc; //指向下一个边结点&#125;ENode; typedef struct&#123; int n; //图的当前顶点数 int e; //图的当前边数 ENode **a; //指向一维指针数组&#125;LGraph; //邻接表的初始化Status Init(LGraph *lg,int nSize)&#123; int i; lg-&gt;n = nSize; lg-&gt;e = 0; lg-&gt;a = (ENode**)malloc(nSize*sizeof(ENode*)); //动态生成长度为n的一维指针数组 if(!lg-&gt;a) return ERROR; for(i = 0;i &lt; lg-&gt;n;i ++) lg-&gt;a[i] = NULL; //将指针数组a置空 return OK;&#125; //邻接表的撤销int Destory(LGraph *lg)&#123; int i; ENode *p,*q; for(i = 0;i &lt; lg-&gt;n;i ++)&#123; //链表的撤销操作 p = lg-&gt;a[i]; //指针p指向顶点i的单链表的第一个边结点 q = p; while(p)&#123; //释放顶点i的单链表中所有边结点 p = p-&gt;nextArc; free(q); q = p; &#125; &#125; free(lg-&gt;a); //释放一维指针数组a的存储空间 return OK; //改为int型函数,有返回值&#125; //邻接表的搜索边Status Exist(LGraph *lg,int u,int v)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1 ||v &gt; lg-&gt;n-1 ||u == v) return ERROR; p = lg-&gt;a[u]; //指针p指向顶点u的单链表的第一个边结点 while(p!=NULL &amp;&amp; p-&gt;adjVex != v)&#123; p = p-&gt;nextArc; &#125; if(!p) return ERROR; else return OK;&#125; //邻接表的插入边Status Insert(LGraph *lg,int u,int v,ElemType w)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1||v &gt; lg-&gt;n-1 ||u == v) return ERROR; if(Exist(lg,u,v)) return Duplicate; //此边已存在,返回错误 p = (ENode*)malloc(sizeof(ENode)); //为新的边结点分配存储空间 p-&gt;adjVex = v; p-&gt;w = w; p -&gt; nextArc = lg-&gt;a[u]; //将新的边结点插入单链表的最前面 lg-&gt;a[u] = p; lg-&gt;e ++; return OK;&#125; //邻接表的删除边Status Remove(LGraph *lg,int u,int v)&#123; ENode *p,*q; if(u &lt; 0 || v &lt; 0 || u &gt; lg-&gt;n-1 || v &gt; lg-&gt;n-1 || u == v) return ERROR; p = lg-&gt;a[u]; q = NULL; while(p &amp;&amp; p-&gt;adjVex != v)&#123; //查找待删除边是否存在 q = p; p = p-&gt;nextArc; &#125; if(!p) return NotPresent; if(q) q-&gt;nextArc = p-&gt;nextArc; //从单链表删除此边 else lg-&gt;a[u] = p-&gt;nextArc; free(p); lg-&gt;e --; return OK;&#125; void BFS(LGraph lg,int v,int visited[])&#123; ENode *j; Queue q; Create(&amp;q,lg.n); visited[v] = 1; printf(\"%d\", v); EnQueue(&amp;q,v); //访问的节点入队 while( !IsEmpty(&amp;q) )&#123; //一直到该层没有节点为止 Front(&amp;q,&amp;v); // 取出父节点 DeQueue(&amp;q); for (j=lg.a[v]; j!= NULL;j=j-&gt;nextArc )&#123; if ( !visited[j-&gt;adjVex])&#123; visited[j-&gt;adjVex] = 1; printf(\"%d\", j-&gt;adjVex); EnQueue(&amp;q,j-&gt;adjVex); &#125; &#125; &#125;&#125;void BFSGraph(LGraph lg)&#123; int i; int *visited = (int *)malloc(sizeof(int)* lg.n); //记录n个节点的访问情况 for(i=0; i&lt; lg.n;i++) visited[i] = 0; //visted数组初始化 for (int i = 0; i &lt; lg.n; ++i) if( !visited[i] ) BFS(lg,i,visited); free(visited);&#125;void DFS(LGraph lg,int v,int visited[])&#123; ENode *j; printf(\"%d\",v ); visited[v] = 1; for (j = lg.a[v];j!=NULL;j= j-&gt;nextArc) //lg.a链表的循环 if( !visited[j-&gt;adjVex] ) DFS(lg,j-&gt;adjVex,visited);&#125;void DFSGraph(LGraph lg)&#123; int i; int *visited = (int *)malloc(sizeof(int)* lg.n); //记录n个节点的访问情况 for(i=0; i&lt; lg.n ; i++) visited[i] = 0; //visted数组初始化 for (int i = 0; i &lt; lg.n; ++i) if( !visited[i] ) DFS(lg,i,visited); free(visited);&#125; int main()&#123; LGraph g; int i,u,v,enode,edge; ElemType w; printf(\"Enter the number of mgraph's Nodes:\"); scanf(\"%d\",&amp;enode); Init(&amp;g,enode); printf(\"Enter the mgraph's Edge num:\"); scanf(\"%d\",&amp;edge); for(i = 0;i &lt; edge;i ++)&#123; printf(\"Please enter the edge(Pu,Pv,Weight):\"); scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); Insert(&amp;g,u,v,w); &#125; printf(\"DFS:\"); DFSGraph(g); printf(\"\\nBFS:\"); BFSGraph(g); printf(\"\\n\"); system(\"pause\"); return 0;&#125; 以上大多直接从学长的博客搬运过来. 3.5- 飞机换乘最短距离(Dijkstra单源最短路径)编写程序，实现智能交通中的最佳路径选择问题：设有n个地点，编号为0~n-1，m条路径的起点、终点和代价由用户输入提供，采用实验3.1所示邻接矩阵为存储结构，寻找最佳路径方案(如花费时间最少、路径长度最短、交通费用最小等，任选其一即可)。 借了学长的整体框架,将邻接矩阵改成了邻接表,并完成了题目要求的给定起点、终点，算最短路径。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define ERROR 0#define OK 1#define Overflow 2 //表示上溢#define Underflow 3 //表示下溢#define NotPresent 4 //表示元素不存在#define Duplicate 5 //表示有重复元素#define INFTY 32657 //表示正无穷#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status;typedef int BOOL;//邻接表的结构体定义typedef struct ENode&#123; int adjVex; //任意顶点u相邻的顶点 ElemType w; //边的权值 struct ENode *nextArc; //指向下一个边结点&#125;ENode; typedef struct&#123; int n; //图的当前顶点数 int e; //图的当前边数 ENode **a; //指向一维指针数组&#125;LGraph; //邻接表的初始化Status Init(LGraph *lg,int nSize)&#123; int i; lg-&gt;n = nSize; lg-&gt;e = 0; lg-&gt;a = (ENode**)malloc(nSize*sizeof(ENode*)); //动态生成长度为n的一维指针数组 if(!lg-&gt;a) return ERROR; for(i = 0;i &lt; lg-&gt;n;i ++) lg-&gt;a[i] = NULL; //将指针数组a置空 return OK;&#125; //邻接表的撤销int Destory(LGraph *lg)&#123; int i; ENode *p,*q; for(i = 0;i &lt; lg-&gt;n;i ++)&#123; //链表的撤销操作 p = lg-&gt;a[i]; //指针p指向顶点i的单链表的第一个边结点 q = p; while(p)&#123; //释放顶点i的单链表中所有边结点 p = p-&gt;nextArc; free(q); q = p; &#125; &#125; free(lg-&gt;a); //释放一维指针数组a的存储空间 return OK; //改为int型函数,有返回值&#125; //邻接表的搜索边Status Exist(LGraph *lg,int u,int v)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1 ||v &gt; lg-&gt;n-1 ||u == v) return ERROR; p = lg-&gt;a[u]; //指针p指向顶点u的单链表的第一个边结点 while(p!=NULL &amp;&amp; p-&gt;adjVex != v)&#123; p = p-&gt;nextArc; &#125; if(!p) return ERROR; else return OK;&#125; //邻接表的插入边Status Insert(LGraph *lg,int u,int v,ElemType w)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1||v &gt; lg-&gt;n-1 ||u == v) return ERROR; if(Exist(lg,u,v)) return Duplicate; //此边已存在,返回错误 p = (ENode*)malloc(sizeof(ENode)); //为新的边结点分配存储空间 p-&gt;adjVex = v; p-&gt;w = w; p -&gt; nextArc = lg-&gt;a[u]; //将新的边结点插入单链表的最前面 lg-&gt;a[u] = p; lg-&gt;e ++; return OK;&#125; //邻接表的删除边Status Remove(LGraph *lg,int u,int v)&#123; ENode *p,*q; if(u &lt; 0 || v &lt; 0 || u &gt; lg-&gt;n-1 || v &gt; lg-&gt;n-1 || u == v) return ERROR; p = lg-&gt;a[u]; q = NULL; while(p &amp;&amp; p-&gt;adjVex != v)&#123; //查找待删除边是否存在 q = p; p = p-&gt;nextArc; &#125; if(!p) return NotPresent; if(q) q-&gt;nextArc = p-&gt;nextArc; //从单链表删除此边 else lg-&gt;a[u] = p-&gt;nextArc; free(p); lg-&gt;e --; return OK;&#125; //选出最小的d[i],i ∈ V-Sint Choose(int d[],int n,int s[])&#123; int minpos; int i; ElemType min; min = INFTY; minpos = -1; for(i = 0;i &lt; n;i ++)&#123; //这里i初值改为0 if( d[i] &lt;= min &amp;&amp; !s[i])&#123; //&lt;改为&lt;= // printf(\"Choose: d[%d]:%d \",i, d[i]); //可以将这段注释打开理解 min = d[i]; minpos = i; &#125; &#125; return minpos; //返回下标位置&#125; //Dijkstra算法Status Dijkstra(LGraph g,int v,int d[],int path[])&#123; int i,k,w,distance = 0; //增加了一个distance记录最短距离之和 int *s; if(v &lt; 0 || v &gt; g.n-1) return ERROR; ENode *j; /*对辅助数据结构的初始化*/ s = (int*)malloc(g.n*sizeof(int)); /*非源点结点初始化*/ for(i = 0;i &lt; g.n;i ++)&#123; s[i] = 0; //表示顶点i是否在s中 for( j=g.a[v];j!=NULL; j=j-&gt;nextArc) if(j-&gt;adjVex == i ) d[i] = j-&gt;w; //v到i的距离 if(i != v &amp;&amp; d[i] &lt; INFTY) path[i] = v; //如果与源点有边相通,标识指向i的源点v else path[i] = -1; &#125; /*源点初始化*/ s[v] = 1; //顶点v为源点,将原点v加入集合S printf(\"The order:%d \",v); //输出源点0 d[v] = 0; /*对辅助数据结构的初始化*/ for(i = 1;i &lt;= g.n-1;i ++)&#123; //最多产生n-1条最短路径,&lt;改为&lt;= k = Choose(d, g.n ,s); //求当前路径最短者k s[k] = 1; //将k加入集合S中 printf(\"%d \",k); for( j = g.a[k]; j!=NULL; j= j-&gt;nextArc)&#123; //更新d和path if( !s[j-&gt;adjVex] &amp;&amp; d[k] + j-&gt;w &lt; d[ j-&gt;adjVex ])&#123; //未被访问过,且 当前边+到前个结点的权值 &lt; 现在的路径长度 //j-&gt;adjVex为所有与v相邻接的顶点 d[j-&gt;adjVex ] = d[k] + j-&gt;w; distance = d[j-&gt;adjVex ]; //计算所有路径中的min距离 path[j-&gt;adjVex ] = k; &#125; &#125; &#125; return OK;&#125; int main()&#123; LGraph g; int nSize,edge,u,v,i; int s,t; //起点,终点 int d[100]; for(int i=0;i&lt;100;i++) d[i] = INFTY; int path[100]; ElemType w; printf(\"Enter the number of mgraph's Nodes:\"); scanf(\"%d\",&amp;nSize); Init(&amp;g,nSize); printf(\"Enter the mgraph's Edge num:\"); scanf(\"%d\",&amp;edge); for(i = 0;i &lt; edge;i ++)&#123; printf(\"Please enter the edge(Pu,Pv,Weight):\"); scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); Insert(&amp;g,u,v,w); &#125; printf(\"Enter the Start Point :\"); scanf(\"%d\",&amp;s); printf(\"Enter the Destination Point :\"); scanf(\"%d\",&amp;t); Dijkstra(g,0,d,path); printf(\"\\nThe shortest distance from %d to Point %d:%d\\n\",s,t, d[t]); system(\"pause\"); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"},{"name":"图论","slug":"图论","permalink":"https://nymrli.top/tags/图论/"},{"name":"实验作业","slug":"实验作业","permalink":"https://nymrli.top/tags/实验作业/"}]},{"title":"数据结构——图","slug":"数据结构——图","date":"2018-12-16T03:41:46.000Z","updated":"2018-12-26T01:11:22.545Z","comments":true,"path":"2018/12/16/数据结构——图/","link":"","permalink":"https://nymrli.top/2018/12/16/数据结构——图/","excerpt":"","text":"数据结构——图连通图 无向图 连通图 : 图中任意两点都连通 连通:如果从v到w存在一条(无向)路径,则称v和w是连通的 路径:V到w的路径是一系列顶点{V,v1,V2，vn,w}的集合,其中任一对相邻的顶点间都有图中的边。路径的长度是路径中的边数(如果带权,则是所有边的权重和)。如果v到w之间的所有顶点都不同,则称简单路径 ▲路径是边的超集,一条路径中可以有多条边 回路:起点等于终点的路径 ==&gt; 有回路的路径为非简单路径 有向图: 强连通 : 有向图中顶点v和W之间存在双向路径,则称v和w是强连通的强连通图 强连通图 : 有向图中任意两顶点均强连通强连通分量:有向图的极大强连通子图 弱连通图 : 将有向图中边的方向擦去,能变成连通图的图叫 弱连通图 图不连通咋办? 非连通图 无向图 连通分量: 无向图的极大连通子图 极大顶点数 : 再加1个顶点就不连通了 极大边数 : 包含子图中所有顶点相连的所有边 图的边可以是具有某种属性的对象: 007案例中的岸边 最小代价生成树基础概念 最小生成树问题 : 村村通—&gt; 使图连通的( 最少的边 \\ 花销最小的 ) 树 连通的 无回路 V个顶点 , v-1条边 生成 包含所有的顶点 V-1条边都在图里 任意加一条边都会构成回路 最小 边的权重和最小 ▲ 最小代价生成树不存在 图不连通 贪心算法: 贪: 每一步是最好的 好: 权重是最小的 约束: 只能用图里有的边 正好用掉 v-1条边 不能有回路 算法实现:Prim算法——让小树成长： kruskal——将森林合并成树: 更贪心,直接将权重最小的边收进来 拓补排序AOV 以顶点来表示活动。 一个活动是另一个活动的先决条件 不断抹去 没有前驱顶点(入度为0) 的顶点 提倡的做法: 将入度为0的顶点放到容器中 ▲.这种方法还可以用来检测是不是有向无环图(DAG) 关键路径AOE: 一般用于安排项目的工序 由绝不允许延误的活动组成的路径 关键路径长度: earliest(n) 没有机动时间的路径为关键路径","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"},{"name":"图论","slug":"图论","permalink":"https://nymrli.top/tags/图论/"}]},{"title":"win自带邮件使用","slug":"win自带邮件使用","date":"2018-12-16T02:48:27.000Z","updated":"2019-05-17T13:29:46.314Z","comments":true,"path":"2018/12/16/win自带邮件使用/","link":"","permalink":"https://nymrli.top/2018/12/16/win自带邮件使用/","excerpt":"","text":"Windows10 自带邮箱 创意大赛忘记提交附件的经历，让我决定这几天把邮箱的问题彻底解决了。 一.打开Windows自带的邮件1.附件栏里 2.直接搜索”邮件” 二.添加账号打开后界面是这样的,左边是我已经添加好的账号 1.点击下面的”齿轮” 2.点击”管理账号” 3.点击”添加账户” 将信息按规则填好后.需要注意的是▲.在按登录之前需要翻墙,否则会出现如图”我们无法找到你的设置“.其次要注意的是,密码为IMAP或者POP、SMTP的密码，授权码查询如下网易：图一 图二： 图三： 此步他会要求你设置自己的授权码 QQ邮箱：图一： 图二： 此步他会要求你发送“配置邮箱客户端”到某个号码上，然后会生成授权码。这个不是自己设置的 翻墙成功，在确保密码也正确的情况下就可以按“登录”了。 附录：添加账号：从“开始“中打开 附件自动下载:下载的附件一般在C:\\Users\\账户名\\AppData\\Local\\Packages\\microsoft.windowscommunicationsapps_邮箱代码\\LocalState\\Files\\S0\\1055（我的在1055里）","categories":[],"tags":[{"name":"邮件","slug":"邮件","permalink":"https://nymrli.top/tags/邮件/"},{"name":"Window10","slug":"Window10","permalink":"https://nymrli.top/tags/Window10/"}]},{"title":"2018-12-15小记","slug":"2018-12-15小记","date":"2018-12-15T14:22:25.000Z","updated":"2018-12-18T12:13:57.125Z","comments":true,"path":"2018/12/15/2018-12-15小记/","link":"","permalink":"https://nymrli.top/2018/12/15/2018-12-15小记/","excerpt":"","text":"数据结构上机,由于最近烦心事也比较多,没有任何准备,在机房想要自己把代码敲出来也是不现实的。于是，就搜吧。无意中搜到了[学长的博客](https://me.csdn.net/Wonz5130),大二转计科，看了他努力的点滴，也颇有感触，于是下笔，略述己见。 之前一直在博客里都是发的技术性的文章，有时想说点话，也找不到合适的人。发条说说，不懂的人不知所措，懂的人也无从安慰，于是也只好作罢。也曾想过在博客里写，太又感觉未免太过矫情，今日所感，还是决定记录些情感、回忆。 大一上报了院科协与校科协，入大学前已经略有琢磨过C语言学习的我自然没有再接着学C，于是趁着Python的大热，也正是听说了Python的简洁、可以做爬虫、网站、人工智能等有趣的时就决定学了这门语言。于是加入了Python组，碰到了李林伟与王宇学长，李林伟学长很负责，大一的课几乎都是由他授的，当初还有事嫌他讲的不够好，现在自己当了讲师后才发现根本无暇准备。大一的时光很多都泡在了图书馆，一个学期下来已经借了20+本书了，整个学年下来一共借了40+本书，虽然没有全部看完，都明显的感觉到自己的努力。大二一般都是在看视频，图书馆很少去了，书也借的少了。 大一还学了单片机，说来也可惜，第一次院级比赛优之杰做了个所有授课内容如 蜂鸣器、LCD1602、跑马灯、矩阵按键 的作品已经很了不起了，就没有再深入学些什么，不知那些更优秀的人已经开始准备电赛、飞思卡尔了。很遗憾吧，最终在下学期的4月份“海善达杯”结束后就再也没碰过单片机，所有学过的单片机代码也逐渐忘却。 大二，一直呆在学科楼220，但没有怎么忙Apollo的项目，说来也比较惭愧。这半个学期也已经过了，感觉自己一直在忙些奇奇怪怪的事，学了前端HTML、CSS、JS；还学了微信小程序，为的就是想参加一些比赛，但到如今却都凉了。为了天翼杯做了个物联网的猫粮，但是天翼杯初赛就被刷；参加创意大赛，结果自己忘记提交附件了；同时，学长的不看好，让我也对完成点子的作品产生了怀疑：这种没技术含量的作品真的能获奖吗？无论如何，最近也得不到答案了。这让我对开发产生了一种厌恶与疲倦，下学期想好好弄弄算法或是机器学习了，静下心来弄点真技术。 有的时候真的会比较迷茫吧？考研还是工作的问题，每隔一段时间都会思考。昨天的分光计无疑让我又一次受挫。准备了3天的物理实验，结果最后誊错数据，同时也是最后几个离开实验室的。确实，分光计真的很简单，但有模糊的地方、以及平时没解决放过的地方在你最薄弱的时候就可能一下子要了你的命。无法确定是否要修正、无法确定是否要算θ0……导致没有一开始就画表，导致了最后的誊错，感觉像是命中注定，就如同创意大赛的没有提交。最近过的很背，期望能够有个水逆退散、柳暗花明。","categories":[],"tags":[{"name":"生活小记","slug":"生活小记","permalink":"https://nymrli.top/tags/生活小记/"}]},{"title":"Python中邮件的发送","slug":"Python中邮件的发送","date":"2018-12-12T14:17:38.000Z","updated":"2018-12-12T14:25:42.949Z","comments":true,"path":"2018/12/12/Python中邮件的发送/","link":"","permalink":"https://nymrli.top/2018/12/12/Python中邮件的发送/","excerpt":"","text":"Python普通的邮件发送需要一个安全的连接，例如SSL，因此接下来我们会使用SSL的方式去登录，但是在那之前，我们需要做一些准备，打开qq邮箱，点击设置-&gt;账户，找到POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务，开启IMAP/SMTP服务，然后根据要求使用手机发送到指定号码，获取授权码，这个授权码就是你接下来登录要使用的密码. 123456789101112131415161718from email.mime.text import MIMETextimport smtplib_user = &apos;1063052964@qq.com&apos;_pwd = &apos;pykhotuhghdjbeci&apos;_to = &apos;2035420834@qq.com&apos;msg = MIMEText(mail_body) //MIMEText中_subtype默认为plain,html格式,只需改这个参数msg[&quot;Subject&quot;] = &apos;来自[不吐不快]网站的网友意见&apos;msg[&quot;From&quot;] = _usermsg[&quot;To&quot;] = _totry: s = smtplib.SMTP_SSL(&quot;smtp.qq.com&quot;, 465) //或是使用s = smtplib.SMTP(&quot;smtp.qq.com&quot;,25) s.login(_user, _pwd) s.sendmail(_user, _to, msg.as_string()) s.quit() message = &apos;感谢你的来信&apos;except: message = &apos;发送失败&apos; ▲smtplib.SMTP_SSL([host[, port[, local_hostname[, keyfile[, certfile[, timeout]]]]]]) 这是一个派生自SMTP的子类，通过SSL加密的套接字连接（使用此类，您需要使用SSL支持编译的套接字模块）。如果未指定主机，则使用“（本地主机）”。如果省略端口，则使用标准的SMTP-over-SSL端口（465） 本机已安装了支持 SMTP 的服务，如：sendmail: 12345import smtplibfrom email.mime.text import MIMETextfrom email.header import Headermessage[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;) 第三方SMTP发送邮件: 1234567import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddrmsg[&apos;From&apos;]=formataddr([&quot;FromRunoob&quot;,my_sender]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号msg[&apos;To&apos;]=formataddr([&quot;FK&quot;,my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号*没有formataddr的昵称默认为账号* Python 发送带附件的邮件: 发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/python# -*- coding: UTF-8 -*- import smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.header import Header sender = &apos;from@runoob.com&apos;receivers = [&apos;429240967@qq.com&apos;] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 #创建一个带附件的实例message = MIMEMultipart()message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)message[&apos;To&apos;] = Header(&quot;测试&quot;, &apos;utf-8&apos;)subject = &apos;Python SMTP 邮件测试&apos;message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;) #邮件正文内容message.attach(MIMEText(&apos;这是菜鸟教程Python 邮件发送测试……&apos;, &apos;plain&apos;, &apos;utf-8&apos;)) # 构造附件1，传送当前目录下的 test.txt 文件att1 = MIMEText(open(&apos;test.txt&apos;, &apos;rb&apos;).read(), &apos;base64&apos;, &apos;utf-8&apos;)att1[&quot;Content-Type&quot;] = &apos;application/octet-stream&apos;# 这里的filename可以任意写，写什么名字，邮件中显示什么名字att1[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&quot;test.txt&quot;&apos;message.attach(att1) # 构造附件2，传送当前目录下的 runoob.txt 文件att2 = MIMEText(open(&apos;runoob.txt&apos;, &apos;rb&apos;).read(), &apos;base64&apos;, &apos;utf-8&apos;)att2[&quot;Content-Type&quot;] = &apos;application/octet-stream&apos;att2[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&quot;runoob.txt&quot;&apos;message.attach(att2) try: smtpObj = smtplib.SMTP(&apos;localhost&apos;) smtpObj.sendmail(sender, receivers, message.as_string()) print &quot;邮件发送成功&quot;except smtplib.SMTPException: print &quot;Error: 无法发送邮件&quot; 在 HTML 文本中添加图片123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python# -*- coding: UTF-8 -*- import smtplibfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.header import Header sender = &apos;from@runoob.com&apos;receivers = [&apos;429240967@qq.com&apos;] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 msgRoot = MIMEMultipart(&apos;related&apos;) //创建MIMEMultipart()实例msgRoot[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)msgRoot[&apos;To&apos;] = Header(&quot;测试&quot;, &apos;utf-8&apos;)subject = &apos;Python SMTP 邮件测试&apos;msgRoot[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;) msgAlternative = MIMEMultipart(&apos;alternative&apos;)msgRoot.attach(msgAlternative) mail_msg = &quot;&quot;&quot;&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.runoob.com&quot;&gt;菜鸟教程链接&lt;/a&gt;&lt;/p&gt;&lt;p&gt;图片演示：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;cid:image1&quot;&gt;&lt;/p&gt;&quot;&quot;&quot;msgAlternative.attach(MIMEText(mail_msg, &apos;html&apos;, &apos;utf-8&apos;)) //内容 # 指定图片为当前目录fp = open(&apos;test.png&apos;, &apos;rb&apos;)msgImage = MIMEImage(fp.read())fp.close() # 定义图片 ID，在 HTML 文本中引用msgImage.add_header(&apos;Content-ID&apos;, &apos;&lt;image1&gt;&apos;)msgRoot.attach(msgImage) //附件 try: smtpObj = smtplib.SMTP(&apos;localhost&apos;) smtpObj.sendmail(sender, receivers, msgRoot.as_string()) print &quot;邮件发送成功&quot;except smtplib.SMTPException: print &quot;Error: 无法发送邮件&quot; Python SMTP发送邮件 flask-email官方文档 阻塞发送最简单的调用123456789101112131415161718from flask import Flaskfrom flask_mail import Mail,Messageapp = Flask(__name__)app.config['MAIL_SERVER'] = 'smtp.qq.com'app.config['MAIL_PORT'] = 587app.config['MAIL_USE_TLS'] = Trueapp.config['MAIL_USERNAME'] = '1063052964@qq.com'app.config['MAIL_PASSWORD'] = '#'mail = Mail(app)msg = Message('邮件主题', sender='1063052964@qq.com', recipients=['2035420834@qq.com'])msg.body = '邮件内容'msg.html = \"&lt;h1&gt;邮件的html模板&lt;h1&gt; body\"with app.app_context(): mail.send(msg) 读取配置+视图函数中调用[config.py] 123456789# 配置邮箱信息MAIL_SERVER = 'smtp.qq.com'MAIL_PORT = 465MAIL_USE_TLS = FalseMAIL_USE_SSL = True# 注意此处，很多人配置发不出去和这个是有关系的MAIL_PASSWORD = '**********'MAIL_USERNAME = '********@qq.com'# qq郵箱默認走ssl，所以創建的smtp對象必須要支持加密傳輸，且需要指定port=465 app.py 123456789101112131415161718192021222324252627from flask import Flaskfrom flask_mail import Message,Mailfrom threading import Threadimport configapp = Flask(__name__)app.config.from_object(config)mail = Mail(app)def sendMail(): msg = Message('test', sender = '1063052964@qq.com', recipients=[\"2035420834@qq.com\"]) # recipients是个列表，包含所有收件人 # 此处的test是邮箱的主题，sender和config中的MAIL_USERNAME要一致哦 msg.body = '123' msg.html = '&lt;b&gt;test&lt;/b&gt;body' mail.send(msg)@app.route('/')def hello_world(): sendMail() return 'Hello World!'if __name__ == '__main__': app.run(debug=True) tips:tip：具体工程中，配置可以写在单独一个文件如”.env”，然后利用python-envcfg来读取配置，如：app.config.from_object(‘envcfg.raw’) 异步发送12345678910111213141516171819202122232425262728293031323334353637from flask import Flaskfrom flask_mail import Message,Mailfrom threading import Threadimport configapp = Flask(__name__)app.config.from_object(config)mail = Mail(app)def send_async_email(app,msg): with app.app_context(): mail.send(message=msg)def SendMail(): msg = Message('test',sender='106305964@qq.com',\\ recipients=[\"870545361@qq.com\"]) # recipients是个列表，包含所有收件人 # 此处的test是邮箱的主题，sender和config中的MAIL_USERNAME要一致哦 msg.body = 'testbody' msg.html = '&lt;b&gt;test&lt;/b&gt;body' # 邮件发送给目标，可以有文本，两种方式呈现，你能看见怎样的取决于你的客户端 thr = Thread(target=send_async_email,args=[app,msg]) # 使用多线程，在实际开发中，若是不使用异步、多线程等方式，网页会卡住 thr.start() return 'ok'@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run(debug=True) ▲. 许多Flask的扩展都是假定自己运行在一个活动的应用和请求上下文中，Flask-Mail的send函数使用到current_app 这个上下文了，所以当 mail.send()函数在一个线程中执行的时候需要人为的创建一个上下文。在示例 send_async_email 中使用了 app.app_context() 来创建一个上下文。 既然异步的邮件发送功能已经实现了，如果将来我们需要实现其它异步的函数，还有什么需要改进的吗？我们需要为每一个实现异步功能的函数拷贝多线程的代码吗？这并不好。 我们可以通过实现一个 装饰器 来解决这个问题。有了装饰器，上面的代码可以修改为: 123456789101112from .decorators import async@asyncdef send_async_email(app, msg): with app.app_context(): mail.send(msg)def send_email(subject, sender, recipients, text_body, html_body): msg = Message(subject, sender=sender, recipients=recipients) msg.body = text_body msg.html = html_body send_async_email(app, msg) 好的多了吧，对不对？ 这个神奇的代码其实很简单。我们把它放入一个新文件(文件 app/decorators.py): 1234567from threading import Threaddef async(f): def wrapper(*args, **kwargs): thr = Thread(target = f, args = args, kwargs = kwargs) thr.start() return wrapper 作为一个练习，大家可以考虑考虑如何用 *multiprocessing* 模块来实现上面的功能。 摘自flask文档 django.core.mail邮件EmailMessage: 标题. 内容.发件人.收件人 1234from django.core.mail import send_mailsend_mail(u&apos;邮件标题&apos;, u&apos;邮件内容&apos;, &apos;from@example.com&apos;, [&apos;to@example.com&apos;], fail_silently=False) send_mail() subject, message, from_email and recipient_list 这四个参数是必须的。 subject: 字符串，表示邮件标题。 message: 字符串，表示邮件内容。 from_email: 字符串，表示发件邮箱。 recipient_list: 字符串列表，列表中每个成员都是一个邮箱地址，而且每个收件人都会在 “收件人/To:” 栏看到出现在 recipient_list 中的其他收件人。 fail_silently: （可选）布尔值。为 False 时， send_mail 会抛出 smtplib.SMTPException 异常。 smtplib 文档列出了所有可能的异常。 这些异常都是 SMTPException 的子类。 auth_user: （可选）SMTP服务器的认证用户名。没提供该参数的情况下，Django会使用 EMAIL_HOST_USER 配置项的设置。 auth_password: （可选）SMTP服务器的认证密码，没提供该参数的情况下，Django会使用 EMAIL_HOST_PASSWORD配置项的设置。 connection: （可选）发送邮件的后端。没提供该参数的情况下，Django会使用默认后端的实例。可查看 Email backends 了解更多细节。 send_mass_mail() 和 send_mail() 的区别在于： send_mail() 每发送一封邮件就会打开一次邮件服务器链接，而send_mass_mail() 则是打开一次链接，发送所有的邮件。 send_mass_mail() 明显更高效。 main_admins()mail_admins(subject, message, fail_silently=False, connection=None, html_message=None) django.core.mail.mail_admins() 是一个给网站后台管理员(admin)发邮件的快捷方法，管理员设置放在 ADMINS 配置项。 mail_admins() 使用 EMAIL_SUBJECT_PREFIX 配置项的值做为邮件标题的前缀，默认情况下是 &quot;[Django] &quot; 。 mail_managers()mail_managers`(subject, message, fail_silently=False, connection=None, html_message=None) mail_managers(*subject*, *message*, *fail_silently=False*, *connection=None*, *html_message=None*)django.core.mail.mail_managers()is just likemail_admins()，不同之处在于该方法的邮件接收人是网站负责人(manager)， 可以在 [MANAGERS`]配置项设置网站负责人 EmailMessage 对象 class EmailMessage EmailMessage 类使用下列参数初始化（除非使用位置参数，否则默认顺序如下）。所有参数均可选，均可在调用 send()方法之前的任何时间对其赋值。 加入了 cc 参数（cc是抄送） subject: 邮件的标题行 body: 邮件的主体内容文本，须是纯文本信息。 from_email: 发送者的地址。 `fred@example.com或Fred &#x66;&#114;&#x65;&#x64;&#64;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;格式都是合法的。如果忽略该参数，Django就会使用 [DEFAULT_FROM_EMAIL`](https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-DEFAULT_FROM_EMAIL) 配置项。 to: 收件人地址列表或元组。 bcc: 发送邮件时用于”Bcc”头信息的一组列表或元组，也就是暗送的收件人。 connection: 一个邮件后端实例。用同一个链接发送多封邮件就要用到该参数。忽略该参数时，会在调用 send() 时自动创建一个新链接。 attachments: 置于邮件报文内的附件列表。列表元素可以是 email.MIMEBase.MIMEBase 实例，也可以是 (filename, content, mimetype) 三部分构成的元组。 headers: 置于邮件报文内的其他头信息(header)的字典。字典的key是头信息的名称，字典的value是头信息的值。 这样做能确保头信息的名称和对应值会以正确的格式保存于邮件报文中。 cc: 发送邮件时放于”Cc”头信息的一系列列表或元组。 例如: 123email = EmailMessage(&apos;Hello&apos;, &apos;Body goes here&apos;, &apos;from@example.com&apos;, [&apos;to1@example.com&apos;, &apos;to2@example.com&apos;], [&apos;bcc@example.com&apos;], headers = &#123;&apos;Reply-To&apos;: &apos;another@example.com&apos;&#125;) 该类方法如下: send(fail_silently=False) 发送邮件报文。如果在构造邮件时如果指定了某个链接(connection)，就会使用该链接发邮件。 否则，就会使用默认后端的实例发邮件。如果关键字参数 fail_silently 为 True ，就会忽略邮件发送时抛出的异常。 message() 构造了一个 django.core.mail.SafeMIMEText 对象 (Python的 email.MIMEText.MIMEText 类的子类) 或是 django.core.mail.SafeMIMEMultipart 对象（该对象保存即将发送出去邮件报文）。如需扩展 EmailMessage类，一般情况下要覆写该方法，将你所需的内容添加到MIME对象中。 recipients() 返回邮件中所有收件人的列表，不管收件人是在 to 还是 bcc 属性中。这是另一个经常被继承覆写的方法， 因为SMTP服务器在发送邮件报文时，要接收完整的收件人列表。即使你自己的类使用其他方式来指定收件人，也仍然需要使用该方法返回收件人列表。 attach() 创建一个新的文件附件，并把它添加到邮件报文中。 有两种方法调用 attach(): 传递一个单独的 email.MIMEBase.MIMEBase 实例做为参数。该实例会直接添加到最终的邮件报文中。 或者，给 attach() 传递三个参数: filename, content 和 mimetype. filename 是出现在邮件中的附件文件的名称， content 是附件的内容，而 mimetype 是附件所使用的MIME类型。 如果忽略 mimetype, Django会自动根据附件文件名来推测MIME内容类型。 例如: 1message.attach(&apos;design.png&apos;, img_data, &apos;image/png&apos;) attach_file() 使用当前文件系统下的某个文件做为附件。调用时，传入某个文件的完整路径，以及该附件的MIME类型(可选的)。 忽略MIME类型的话，Django会自动根据附件文件名来推测MIME类型。最简单的用法如下: 1message.attach_file(&apos;/images/weather_map.png&apos;) 发送多用途邮件在同一封邮件中包含多种版本的内容是非常有用的；典型的例子就是发送既有纯文本版本内容又有HTML版本内容的邮件。 在Django的邮件库中，可以使用 EmailMultiAlternatives 类来达到该目的。 EmailMessage 的子类有一个attach_alternative() 方法用来包含其他版本的邮件主体内容。所有其他方法(包括类的初始化方法)都直接继承自 EmailMessage 。 发送一封文本/HTML混合邮件，代码如下: 12345678from django.core.mail import EmailMultiAlternativessubject, from_email, to = &apos;hello&apos;, &apos;from@example.com&apos;, &apos;to@example.com&apos;text_content = &apos;This is an important message.&apos;html_content = &apos;&lt;p&gt;This is an &lt;strong&gt;important&lt;/strong&gt; message.&lt;/p&gt;&apos;msg = EmailMultiAlternatives(subject, text_content, from_email, [to])msg.attach_alternative(html_content, &quot;text/html&quot;)msg.send() 默认情况下，EmailMessage 类中的 body 参数的MIME类型是 &quot;text/plain&quot; 。 大多数情况下，没必要更改该MIME，因为这样能保证每个收件人能够阅读该邮件，而不论他们使用的是什么邮件客户端。 不过，在能确保收件人能处理多用途邮件的情况下，可以使用:class:~django.core.mail.EmailMessage 类的 content_subtype 属性 来更改邮件内容类型。主类型总是 &quot;text&quot; ，子类型可以设置为别的版本(比如html)，例如: 123msg = EmailMessage(subject, html_content, from_email, [to])msg.content_subtype = &quot;html&quot; # 主内体现在变成 text/htmlmsg.send() 获取邮件发送后端的实例123django.core.mail 的 get_connection() 函式返回你当前使用的邮件后端的实例。get_connection(backend=None, fail_silently=False, *args, **kwargs) SMTP backend –默认的后端 Console backend File backend –该后端并不建议在生产环境下使用–它仅仅是为开发提供方便 In-memory backend(内存后端) Dummy backend(空后端) 需要在 settings.py中设置的东西:123456EMAIL_BACKEND = &apos;django.core.mail.backends.smtp.EmailBackend&apos;EMAIL_USE_SSL = TrueEMAIL_HOST = &apos;smtp.gmail.com&apos;EMAIL_PORT = 587EMAIL_HOST_USER = &apos;urusername@gmail.com&apos;EMAIL_HOST_PASSWORD = &apos;password&apos;","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"使用Cerbot申请免费证书升级 http到https","slug":"使用Cerbot申请免费证书升级-http到https","date":"2018-12-08T08:10:03.000Z","updated":"2018-12-08T08:10:18.673Z","comments":true,"path":"2018/12/08/使用Cerbot申请免费证书升级-http到https/","link":"","permalink":"https://nymrli.top/2018/12/08/使用Cerbot申请免费证书升级-http到https/","excerpt":"","text":"使用 Cerbot 免费证书 简单 升级 http 到 https1、安装 cerbot: 12git clone https://github.com/letsencrypt/letsencryptcd letsencrypt 要求： Python 2.7 Git环境 连接外网 2、运行: 12// 根据自己的需求调整代码./certbot-auto certonly --standalone --email admin@example.com -d example.com -d www.example.com -d other.example.net 成功提示: 12345678910IMPORTANT NOTES:Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/sast.nymrli.top/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/sast.nymrli.top/privkey.pem Your cert will expire on 2019-02-08. To obtain a new or tweaked version of this certificate in the future, simply run certbot-auto again. To non-interactively renew *all* of your certificates, run &quot;certbot-auto renew&quot; - If you like Certbot, please consider supporting our work by: 3、配置Nginx: server 不再监听80端口，因为TLS要使用的是443端口，然后引入证书和key 123456789server&#123; listen 443 ssl; server_name sast.nymrli.top; //这里是你的域名 index index_page.html; root /var/www/homework_submission-master/; //网站目录 ssl_certificate /etc/letsencrypt/live/sast.nymrli.top/fullchain.pem; //前面生成的证书，改一下里面的域名就行，不建议更换路径 ssl_certificate_key /etc/letsencrypt/live/sast.nymrli.top/privkey.pem; //前面生成的密钥，改一下里面的域名就行，不建议更换路径&#125; 重启Nginx： 1sudo service nginx restart OK! 问题解决:1Problem binding to port 80: Could not bind to IPv4 or IPv6. 原因是 nginx 占用了80端口，输入service nginx stop。然后再次执行证书安装命令，即可顺利安装。安装完毕后，输入service nginx start，重启 nginx 服务。","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"}]},{"title":"pipenv 新款Python虚拟环境工具详解[转]","slug":"pipenv-新款Python虚拟环境工具详解-转","date":"2018-12-08T08:08:23.000Z","updated":"2018-12-08T08:08:44.023Z","comments":true,"path":"2018/12/08/pipenv-新款Python虚拟环境工具详解-转/","link":"","permalink":"https://nymrli.top/2018/12/08/pipenv-新款Python虚拟环境工具详解-转/","excerpt":"","text":"pipenv 新款Python虚拟环境工具详解[转]pipenv是requests库作者Kenneth Reitz编写的一个用于创建和管理Python虚拟环境的工具。 Pipenv是Python官方机构推荐的Python包工具。 我们知道，为了管理Python虚拟环境，通常用得比较多的是virtualenv和pyenv。但是有人觉得它们还不够好用，不够偷懒。这个人是谁，就是上面的那位。于是他开发了一个pipenv，结合了pip及virtualenv的功能和优点，集成出了pipenv这个工具。其目的是替代virtualenv和pyenv，将pip及virtualenv的功能集于一身。 一、安装pipenvwindows下很简单： 1pip install pipenv Linux下： 1sudo pip install pipenv 在苹果操作系统下： 1$ brew install pipenv 也就是说，无法用pip管理的包，pipenv同样无法使用。 pipenv依赖：psutil, virtualenv-clone, pew, certifi, urllib3, chardet, requests, mccabe, pyflakes, pycodestyle, flake8等第三方模块。 pipenv有很漂亮的彩色终端界面。 二、简单使用进入你的Python项目文件夹： 12cd your_projectpipenv install windows操作系统中，虚拟环境创建过程如下： 1234567891011121314151617D:\\test\\test_pipenv&gt;pipenv installCreating a virtualenv for this project…Using base prefix &apos;c:\\\\python36&apos;New python executable in C:\\Users\\Administrator\\.virtualenvs\\test_pipenv-XHxuOsjn\\Scripts\\python.exeInstalling setuptools, pip, wheel...done.Virtualenv location: C:\\Users\\Administrator\\.virtualenvs\\test_pipenv-XHxuOsjnCreating a Pipfile for this project…Pipfile.lock not found, creating…Locking [dev-packages] dependencies…Locking [packages] dependencies…Updated Pipfile.lock (c23e27)!Installing dependencies from Pipfile.lock (c23e27)… ================================ 0/0 - 00:00:00To activate this project&apos;s virtualenv, run the following: $ pipenv shell 如果你给命令添加–two或–three参数，它将分别使用Python2或3来初始化你的虚拟环境，否则将使用默认的Python版本。 注意：pipenv默认把虚拟环境的真实文件全都放在了C:\\Users\\Administrator\\.virtualenvs\\test_pipenv-XHxuOsjn\\Scripts\\python.exe中，而在实际的项目文件夹内只创建了两个新文件Pipfile和Pipfile.lock。这可能造成C盘存有大量的文件，不是个好的做法。（但好像无法修改这一路径….） 看一下Pipfile中的内容： 1234567891011[[source]]url = &quot;https://pypi.python.org/simple&quot;verify_ssl = truename = &quot;pypi&quot;[packages][dev-packages] 最关键的是定义了安装第三方库使用的源，默认为官方的pypi。 而Pipfile.lock文件内容呢？ 12345678910111213141516171819202122232425262728293031&#123; &quot;_meta&quot;: &#123; &quot;hash&quot;: &#123; &quot;sha256&quot;: &quot;5f0257fe8c7a73db1c8de519faa92c658282a01087eb2bfafba7962704c23e27&quot; &#125;, &quot;host-environment-markers&quot;: &#123; &quot;implementation_name&quot;: &quot;cpython&quot;, &quot;implementation_version&quot;: &quot;3.6.4&quot;, &quot;os_name&quot;: &quot;nt&quot;, &quot;platform_machine&quot;: &quot;AMD64&quot;, &quot;platform_python_implementation&quot;: &quot;CPython&quot;, &quot;platform_release&quot;: &quot;7&quot;, &quot;platform_system&quot;: &quot;Windows&quot;, &quot;platform_version&quot;: &quot;6.1.7601&quot;, &quot;python_full_version&quot;: &quot;3.6.4&quot;, &quot;python_version&quot;: &quot;3.6&quot;, &quot;sys_platform&quot;: &quot;win32&quot; &#125;, &quot;pipfile-spec&quot;: 6, &quot;requires&quot;: &#123;&#125;, &quot;sources&quot;: [ &#123; &quot;name&quot;: &quot;pypi&quot;, &quot;url&quot;: &quot;https://pypi.python.org/simple&quot;, &quot;verify_ssl&quot;: true &#125; ] &#125;, &quot;default&quot;: &#123;&#125;, &quot;develop&quot;: &#123;&#125;&#125; 初始情况下，文件里只包含一些操作系统的基本信息。 Pipfile和Pipfile.lock两个文件互相配合，完成虚拟环境的管理工作。 三、安装第三方模块Pipfile包含关于项目的依赖包的信息，并取代通常在Python项目中使用的requirements.txt文件。 如果你在具有requirements.txt文件的项目中启动了Pipenv，则在把它从项目中删除之前，应该使用Pipenv安装该requirements中列出的所有依赖包。 使用pipenv创建虚拟环境后，进入pipfile所在目录，使用install命令安装第三方库。 例如： 1pipenv install django 这个时候，你其实把pipenv当作pip来使用。无需像virtualenv那样需要额外的先启动虚拟环境。pipenv区分你是在给哪个虚拟环境工作，依赖的是Pipfile文件的位置。 要卸载某个第三方库： 1pipenv uninstall beautifulsoup4 四、冻结Pipfile冻结就相当于将项目所使用的第三方库列表进行打包输出，类似于virtualenv中生成requirements.txt文件。 通过更新Pipfile.lock来冻结库名称及其版本，以及其依赖关系的列表。需要使用lock参数： 1pipenv lock 如果另一个用户拷贝了你的项目，他们只需要安装Pipenv，然后： 1pipenv install Pipenv会在项目文件夹下自动寻找Pipfile和Pipfile.lock文件，创建一个新的虚拟环境并安装必要的软件包。 也就是说pipenv install的时候有三种逻辑： 如果目录下没有Pipfile和Pipfile.lock文件，表示创建一个新的虚拟环境； 如果有，表示使用已有的Pipfile和Pipfile.lock文件中的配置创建一个虚拟环境； 如果后面带诸如django这一类库名，表示为当前虚拟环境安装第三方库。 五、管理开发环境通常有一些Python包只在你的开发环境中需要，而不是在生产环境中，例如单元测试包。 Pipenv使用–dev标志区分两个环境。 1pipenv install --dev django django库现在将只在开发虚拟环境中使用。如果你要在你的生产环境中安装你的项目： 1pipenv install 这不会安装django包。 但是，如果有一个开发人员将你的项目克隆到自己的开发环境中，他们可以使用–dev标志，将django也安装： 1pipenv install --dev 也就是说一个–dev参数，帮你在同一个虚拟环境中又区分出了开发和非开发环境。 六、在虚拟环境中运行命令使用run参数，提供要运行的命令： 1pipenv run python manage.py runserver 这将使用当前虚拟环境关联的Python解释器，执行命令。 或者简单的执行脚本： 1pipenv run python your_script.py 如果你不想每次运行Python时都输入这么多字符，可以在shell中设置一个别名，例如， 1alias prp=&quot;pipenv run python&quot; 七、pipenv选项解释pipenv 具有下列的选项： 12345678910111213141516171819$ pipenvUsage: pipenv [OPTIONS] COMMAND [ARGS]...Options: --update 更新Pipenv &amp; pip --where 显示项目文件所在路径 --venv 显示虚拟环境实际文件所在路径 --py 显示虚拟环境Python解释器所在路径 --envs 显示虚拟环境的选项变量 --rm 删除虚拟环境 --bare 最小化输出 --completion 完整输出 --man 显示帮助页面 --three / --two 使用Python 3/2创建虚拟环境（注意本机已安装的Python版本） --python TEXT 指定某个Python版本作为虚拟环境的安装源 --site-packages 附带安装原Python解释器中的第三方库 --jumbotron 不知道啥玩意.... --version 版本信息 -h, --help 帮助信息 pipenv 可使用的命令参数： 12345678910Commands: check 检查安全漏洞 graph 显示当前依赖关系图信息 install 安装虚拟环境或者第三方库 lock 锁定并生成Pipfile.lock文件 open 在编辑器中查看一个库 run 在虚拟环境中运行命令 shell 进入虚拟环境 uninstall 卸载一个库 update 卸载当前所有的包，并安装它们的最新版本 一些使用例子： 123456789101112Usage Examples: 使用Python 3.6创建虚拟环境: $ pipenv --python 3.6 安装包括开发环境中的第三方库: $ pipenv install --dev 锁定pipfile: $ pipenv lock --pre Install a local setup.py into your virtual environment/Pipfile: $ pipenv install -e . 八、一些使用过程展示定位项目路径: 12$ pipenv --where/Users/kennethreitz/Library/Mobile Documents/com~apple~CloudDocs/repos/kr/pipenv/test 定位虚拟环境 12$ pipenv --venv/Users/kennethreitz/.local/share/virtualenvs/test-Skyy4vre 定位Python解释器： 12$ pipenv --py/Users/kennethreitz/.local/share/virtualenvs/test-Skyy4vre/bin/python 安装包： 12345678910$ pipenv installCreating a virtualenv for this project......No package provided, installing all dependencies.Virtualenv location: /Users/kennethreitz/.local/share/virtualenvs/test-EJkjoYtsInstalling dependencies from Pipfile.lock......To activate this project&apos;s virtualenv, run the following:$ pipenv shell 安装一个开发环境中才使用的包： 1234$ pipenv install pytest --devInstalling pytest......Adding pytest to Pipfile&apos;s [dev-packages]... 显示依赖关系： 123456$ pipenv graphrequests==2.18.4 - certifi [required: &gt;=2017.4.17, installed: 2017.7.27.1] - chardet [required: &gt;=3.0.2,&lt;3.1.0, installed: 3.0.4] - idna [required: &gt;=2.5,&lt;2.7, installed: 2.6] - urllib3 [required: &lt;1.23,&gt;=1.21.1, installed: 1.22] 生成lock文件: 123456$ pipenv lockAssuring all dependencies from Pipfile are installed...Locking [dev-packages] dependencies...Locking [packages] dependencies...Note: your project now has only default [packages] installed.To install [dev-packages], run: $ pipenv install --dev 安装开发环境依赖： 123456$ pipenv install --devPipfile found at /Users/kennethreitz/repos/kr/pip2/test/Pipfile. Considering this to be the project home.Pipfile.lock out of date, updating...Assuring all dependencies from Pipfile are installed...Locking [dev-packages] dependencies...Locking [packages] dependencies... 卸载所有的包： 12345$ pipenv uninstall --allNo package provided, un-installing all dependencies.Found 25 installed package(s), purging......Environment now purged and fresh! 使用虚拟环境的shell。exit退出： 123$ pipenv shellLoading .env environment variables…Launching subshell in virtual environment. Type &apos;exit&apos; or &apos;Ctrl+D&apos; to return. 本文来自刘江的博客和教程网站http://www.liujiangblog.com/blog/","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"#ifdef、#ifndef、#endif","slug":"ifdef、-ifndef、-endif","date":"2018-12-08T08:07:37.000Z","updated":"2018-12-08T08:08:08.970Z","comments":true,"path":"2018/12/08/ifdef、-ifndef、-endif/","link":"","permalink":"https://nymrli.top/2018/12/08/ifdef、-ifndef、-endif/","excerpt":"","text":"#ifdef、#ifndef、#endif使用说明目的:防止头文件重复include示例说明:a.h12#include &lt;stdio.h&gt;#include &quot;b.h&quot; b.h1#include &quot;a.h&quot; c.c12345#include &quot;a.h&quot;#include &quot;b.h&quot;int main()&#123; printf(&quot;Hello!&quot;);&#125; 如果你程序是这样写的话，编译器就会出现Error #include nested too deeply的错误。因为这里 b.h 和 a.h 都互相include，c.c文件在include的时候重复include了a.h，我们希望c.c文件中执行#include “b.h”的时候 b.h 能进行判断，如果没有#include “a.h”则include，如果已经include了，则不再重复定义。 可以将b.h修改为： 1234#ifndef _A_H#define _A_H #include &quot;a.h&quot;#endif 原因是: &gt; c.c中先include了a.h文件，其中a.h中又包括了b.h，所以会定义宏_A_H，当c,c中又includeb,h时判断_A_H是否已经被定义了,如果被定义了,则不再includea.h","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"小程序——高德地图API调用","slug":"小程序——高德地图API调用","date":"2018-12-06T09:11:14.000Z","updated":"2019-05-30T03:34:56.676Z","comments":true,"path":"2018/12/06/小程序——高德地图API调用/","link":"","permalink":"https://nymrli.top/2018/12/06/小程序——高德地图API调用/","excerpt":"","text":"小程序——高德地图API调用配置将压缩包解压至使用的小程序目录下，创建libs文件夹，包含amap-wx.js 导入使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var amapFile = require('..­/../../../libs/amap-wx.js');Page(&#123; data: &#123; src: '' &#125;, onLoad: function () &#123; var that = this; var myAmapFun = new amapFile.AMapWX(&#123; key: \" dbb8be907441c2650218bdfd78848cf6\" &#125;); wx.getSystemInfo(&#123; success: function (data) &#123; //获得手机屏幕的高度宽度 var height = data.windowHeight; var width = data.windowWidth; var size = width + \"*\" + height; myAmapFun.getStaticmap(&#123; location: \"118.9301,32.109\", //地图中心 zoom: 15, //缩放比例 size: size, //尺寸大小 scale: 2, //像素,普通图、高清图 markers: //标记 \"large,0xFF0000,A:118.9301,32.109|mid,0xFF0000,B:118.9301,32.110\", success: function (data) &#123; that.setData(&#123; src: data.url &#125;) &#125;, fail: function (info) &#123; wx.showModal(&#123; title: info.errMsg &#125;) &#125; &#125;) &#125; &#125;) &#125;, onReady: function () &#123; &#125;, onShow: function () &#123; &#125;, onHide: function () &#123; &#125;, onUnload: function () &#123; &#125;, onPullDownRefresh: function () &#123; &#125;, onReachBottom: function () &#123; &#125;, onShareAppMessage: function () &#123; &#125;&#125;) API使用说明 参数名称 含义 规则说明 是否必填 默认值 key 用户唯一标识 用户在高德地图官网申请 必填 无 location 地图中心点 中心点坐标。规则：经度和纬度用”,”分隔 经纬度小数点后不得超过6位。 部分条件必填 无 zoom 地图级别 地图缩放级别:[1,17] 可选 无 size 地图大小 图片宽度图片高度。最大值为10241024 可选 400*400 scale 普通/高清 1:返回普通图；2:调用高清图，图片高度和宽度都增加一倍，zoom也增加一倍（当zoom为最大值时，zoom不再改变）。 可选 1 markers 标注 使用规则见markers详细说明，标注最大数10个 可选 无 labels 标签 使用规则见labels详细说明，标签最大数10个 可选 无 paths 折线 使用规则见paths详细说明，折线和多边形最大数4个 可选 无 traffic 交通路况标识 底图是否展现实时路况。 可选值： 0，不展现；1，展现。 可选 0 sig 数字签名 数字签名认证用户必填 可选 无 markers:123markers:\"large,0xFF0000,A:118.9301,32.109|mid,0xFF0000,B:118.9301,32.110\",//ormarkers:\"large,0xFF0000,A:118.9301,32.109;B:118.9301,32.110\", 参数名称 说明 默认值 size 可选值： small,mid,large small color 选值范围：[0x000000, 0xffffff]例如：0x000000 black,0x008000 green,0x800080 purple,0xFFFF00 yellow,0x0000FF blue,0x808080 gray,0xffa500 orange,0xFF0000 red,0xFFFFFF white 0xFC6054 label [0-9]、[A-Z]、[单个中文字] 当size为small时，图片不展现标注名。 无 label，font ,bold, fontSize，fontColor，background 自定义markersStyle: -1，url，0。-1表示为自定义图片，URL为图片的网址。自定义图片只支持PNG格式。 https://restapi.amap.com/v3/staticmap?markers=-1,http://ico.ooopic.com/ajax/iconpng/?id=158688.png,0:116.37359,39.92437&amp;key=您的key labelslabels=labelsStyle1:location1;location2|labelsStyle2:location3;location4..|labelsStyleN:locationN;locationM labelsStyle：label, font, bold, fontSize, fontColor, background。 各参数使用”,”分隔，如有默认值则可为空。 参数名称 说明 默认值 content 标签内容，字符最大数目为15 无 font 0：微软雅黑；1：宋体；2：Times New Roman;3：Helvetica 0 bold 0：非粗体；1：粗体 0 fontSize 字体大小，可选值[1,72] 10 fontColor 字体颜色，取值范围：[0x000000, 0xffffff] 0xFFFFFF background 背景色，取值范围：[0x000000, 0xffffff] 0x5288d8 pathspaths=pathsStyle1:location1;location2..|pathsStyle2:location3;location4..|pathsStyleN:locationN;locationM.. ▲.LocationN : 118.9301,32.109先经度后维度 pathsStyle：weight, color, transparency, fillcolor, fillTransparency 参数名称 说明 默认值 weight 线条粗细。可选值： [2,15] 5 color 折线颜色。 选值范围：[0x000000, 0xffffff]例如：0x000000 black,0x008000 green,0x800080 purple,0xFFFF00 yellow,0x0000FF blue,0x808080 gray,0xffa500 orange,0xFF0000 red,0xFFFFFF white 0x0000FF transparency 透明度。可选值[0,1]，小数后最多2位，0表示完全透明，1表示完全不透明。 1 fillcolor 多边形的填充颜色，此值不为空时折线封闭成多边形。取值规则同color 无 fillTransparency 填充面透明度。可选值[0,1]，小数后最多2位，0表示完全透明，1表示完全不透明。 0.5 折线示例: 1paths: &apos;10,0x0000ff,1,,:116.31604,39.96491;116.320816,39.966606;116.321785,39.966827;116.32361,39.966957&apos;, 区域示例: 1paths: &quot;10,0x0000ff,0.1,0x0000ff,0.7:116.31604,39.96491;116.320816,39.966606;116.321785,39.966827;116.32361,39.966957;116.39361,39.966957;116.39361,39.936957&quot;,","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"HTML和CSS学习","slug":"HTML和CSS学习","date":"2018-12-06T02:57:32.000Z","updated":"2018-12-06T02:59:19.689Z","comments":true,"path":"2018/12/06/HTML和CSS学习/","link":"","permalink":"https://nymrli.top/2018/12/06/HTML和CSS学习/","excerpt":"","text":"HTML学习&lt;head&gt;中的&lt;meta&gt;标签 属性 值 描述 http-equiv content-typeexpiresrefreshset-cookie 把 content 属性关联到 HTTP 头部。 name authordescriptionkeywordsgeneratorrevisedothers 把 content 属性关联到一个名称。 scheme some_text 定义用于翻译 content 属性值的格式。 name 属性 name 属性提供了名称/值对中的名称。 “keywords” 是一个经常被用到的名称。它为文档定义了一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。 1&lt;meta name=&quot;keywords&quot; content=&quot;HTML,ASP,PHP,SQL&quot;&gt; ▲如果没有提供 name 属性，那么名称/值对中的名称会采用 http-equiv 属性的值。 http-equiv 属性http-equiv 属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。 使用带有 http-equiv 属性的 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。例如，添加： 12&lt;meta http-equiv=&quot;charset&quot; content=&quot;iso-8859-1&quot;&gt;&lt;meta http-equiv=&quot;expires&quot; content=&quot;31 Dec 2008&quot;&gt; 这样发送到浏览器的头部就应该包含： 123content-type: text/htmlcharset:iso-8859-1expires:31 Dec 2008 content 属性content 属性提供了名称/值对中的值。该值可以是任何有效的字符串。 content 属性始终要和 name 属性或 http-equiv 属性一起使用。 标签 &lt;em&gt;和&lt;strong&gt;标签是为了强调一段话中的关键字时使用，它们的语义是强调。 &lt;span&gt;标签是没有语义的，它的作用就是为了设置单独的样式用的。 &lt;q&gt;引用文本&lt;/q&gt;,注意要引用的文本不用加双引号，浏览器会对q标签自动添加双引号。 &lt;blockquote&gt;引用长文本&lt;/blockquote&gt; 使用&lt;br&gt;标签分行显示文本 空格&amp;nbsp; 认识&lt;hr /&gt;标签，添加水平横线 &lt;address&gt;标签，为网页加入地址信息 &lt;code&gt;var i=i+300;&lt;/code&gt;一行代码 &lt;pre&gt;语言代码段&lt;/pre&gt;大段代码 使用&lt;ul&gt;，添加新闻信息列表 创建表格table的四个元素： tbody：如果不加&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt; , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。 tr表格的一行，所以有几对tr 表格就有几行。 th表格表头。 td一行中数据单元格的个数。 &lt;caption&gt;标题文本&lt;/caption&gt; &lt;table summary=&quot;表格简介文本&quot;&gt;摘要 CSS学习Q:CSS样式可以写在哪些地方呢？A: 内联式 : 把css代码直接写在现有的HTML标签中 &lt;p style=&quot;color:red&quot;&gt;这里文字是红色。&lt;/p&gt; 嵌入式 : 把css样式代码写在&lt;style type=&quot;text/css&quot;&gt;&lt;/style标签之间，一般情况下嵌入式css样式写在&lt;head&gt;&lt;/head&gt;之间 12345&lt;style type=&quot;text/css&quot;&gt;span&#123;color:red;&#125;&lt;/style&gt; 外部式 : 把css代码写一个单独的外部文件中,这个css样式文件以“.css”为扩展名 &lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; ▲.三种方法的优先级 内联式 &gt; 嵌入式 &gt; 外部式 嵌入式&gt;外部式有一个前提：嵌入式css样式的位置一定在外部式的后面 ==&gt;其实总结来说，就是--就近原则（离被设置元素越近优先级别越高）。 权值:标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100 12345p&#123;color:red;&#125; /*权值为1*/p span&#123;color:green;&#125; /*权值为1+1=2*/.warning&#123;color:white;&#125; /*权值为10*/p span.warning&#123;color:purple;&#125; /*权值为1+1+10=12*/#footer .note p&#123;color:yellow;&#125; /*权值为100+10+1=111*/ 还有一个权值比较特殊–继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。 ==&gt;根据权值和层叠的想法:内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 提高权值的方法:重要性12p&#123;color:red!important;&#125;p.first&#123;color:green;&#125; CSS格式化排版字体 font-family: 字体 body{font-family:&quot;宋体&quot;;} font-size:字号 body{font-size:12px;color:#666} 1234p span&#123;font-weight:bold;&#125; //粗体p a&#123;font-style:italic;&#125; //斜体p a&#123;text-decoration:underline;&#125; //下划线.oldPrice&#123;text-decoration:line-through;&#125; //删除线 段落排版 text-indent:段落缩进 p{ text-indent:2em;} 行间距（行高） p{ line-height:1.5em;} 中文字间距、字母间距 h1{ word-spacing:50px;} 为块状元素中的文本、图片设置居中样式 h1{ text-align:center;} 元素分类块状元素(block) 1&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行） 2、元素的高度、宽度、行高以及顶和底边距都可设置。 3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 内联元素(又叫行内元素):inline 1&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 1、和其他元素都在一行上； 2、元素的高度、宽度及顶部和底部边距不可设置； 3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 内联块状元素(inline-block） 1&lt;img&gt;、&lt;input&gt; 1、和其他元素都在一行上； 2、元素的高度、宽度、行高以及顶和底边距都可设置。 盒子模型 块级元素都具有盒子模型的特征 外边距 : marigin 内边距 : padding 边框 : border 盒模型–宽度和高度元素的实际高度为 : 自身height+ padding-top +padding-bottom 元素的实际宽度为 : 自身width+ padding-left +padding-right ▲ 一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 总宽度计算: 开发工具查看: 边框: border-style（边框样式）常见样式有： dashed（虚线）| dotted（点线）| solid（实线） border-color（边框颜色）中的颜色可设置为十六进制颜色，如: border-color:#888;//前面的井号不要忘掉。 border-width（边框宽度）中的宽度也可以设置为： thin | medium | thick（但不是很常用），最常还是用像素（px）。 css布局模型1、流动模型（Flow）2、浮动模型 (Float)3、层模型（Layer） 流动模型（Flow）流动（Flow）是默认的网页布局模式. 2个比较典型的特征： 第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。 第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行） 浮动模型 (Float) 想让两个块状元素并排显示..任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动， 1234567/*实现两个 div 元素一行显示。*/div&#123; width:200px; height:200px; border:2px red solid; float:left;&#125; 层模型（Layer） 如何让html元素在网页中精确定位，就像图像软件PhotoShop中的图层一样可以对每个图层能够精确定位操作 1、绝对定位(position: absolute) 将元素从文档流中拖出来，然后使用left(距离左)、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口 2、相对定位(position: relative) 相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 Q:什么叫做“偏移前的位置保留不动” A: 虽然div元素相对于以前的位置产生了偏移，但是div元素以前的位置还是保留着，所以后面的span元素是显示在了div元素以前位置的后面。 ===&gt; 所占的位置不变,但是显示的位置发生了变化. 3、固定定位(position: fixed) 与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身. 由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响， 用途 : 可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。 水平居中设置行内元素 如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的 块状元素 定宽~ : 宽度width为固定值 通过设置“左右margin”值为“auto”来实现居中的 不定宽~ 加入 table 标签 table长度自适应性,其长度根据其内文本长度决定 12345678910111213&lt;div&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt; &lt;ul&gt; &lt;li&gt;我是第一行文本&lt;/li&gt; &lt;li&gt;我是第二行文本&lt;/li&gt; &lt;li&gt;我是第三行文本&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; css代码： 123456&lt;style&gt;table&#123; border:1px solid; margin:0 auto;&#125;&lt;/style&gt; ▲补充代码实现右侧中的 class 为 wrap 的 div 水平居中显示（要注意是这个 div元素 居中，而不是里面的文本居中啊）。 设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置 改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。如下例子： html代码： 123456789&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; css代码： 1234567891011121314151617&lt;style&gt;.container&#123; text-align:center;&#125;/* margin:0;padding:0（消除文本与div边框之间的间隙）*/.container ul&#123; list-style:none; margin:0; padding:0; display:inline;&#125;/* margin-right:8px（设置li文本之间的间隔）*/.container li&#123; margin-right:8px; display:inline;&#125;&lt;/style&gt; ▲ 改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。如下例子： 父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的 代码如下： 123456789&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; css代码： 1234567891011121314151617&lt;style&gt;.container&#123; float:left; position:relative; left:50%&#125;.container ul&#123; list-style:none; margin:0; padding:0; position:relative; left:-50%;&#125;.container li&#123;float:left;display:inline;margin-right:8px;&#125;&lt;/style&gt; 垂直居中父元素高度确定的单行文本 通过设置父元素的 height 和 line-height 高度一致来实现的。 1234567&lt;style&gt;.container&#123; height:100px; line-height:100px; background:#999;&#125;&lt;/style&gt; 父元素高度确定的多行文本、图片 使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。 html代码： 12345678910111213&lt;body&gt;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=\"wrap\"&gt; &lt;div&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt; css代码： 12345table td&#123; height:500px; background:#ccc&#125;/*因为 td 标签默认情况下就默认设置了 vertical-align 为 middle，所以我们不需要显式地设置了。*/ 在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的display为 table-cell（设置为表格单元显示），激活 vertical-align 属性 html代码： 1234567&lt;div class=\"container\"&gt; &lt;div&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; css代码： 12345678&lt;style&gt;.container&#123; height:300px; background:#ccc; display:table-cell;/*IE8以上及Chrome、Firefox*/ vertical-align:middle;/*IE8以上及Chrome、Firefox*/&#125;&lt;/style&gt; 隐性改变display类型 position : absolute float : left 或 float:right 只要html代码中出现以上两句之一，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"HTML","slug":"HTML","permalink":"https://nymrli.top/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://nymrli.top/tags/CSS/"}]},{"title":"Pyinstaller使用","slug":"Pyinstaller使用","date":"2018-12-03T03:54:22.000Z","updated":"2018-12-03T03:57:42.957Z","comments":true,"path":"2018/12/03/Pyinstaller使用/","link":"","permalink":"https://nymrli.top/2018/12/03/Pyinstaller使用/","excerpt":"","text":"pyinstaller使用安装1、安装pywin32==&gt;pyinstaller依赖于 下载安装文件：查找到跟自己适用的python版本及window系统版本匹配的pywin32，下载后安装 使用pip命令安装：pip install pywin32 2、安装Pyinstaller 下载安装文件安装：官网 使用pip命令安装：pip install PyInstaller 使用Pycharm直接搜索pyinstaller会自动安装依赖库pywin32 使用1、使用下载安装的方式安装的Pyinstaller打包方式将需要打包的文件放在解压得到的Pyinstaller文件夹中，打开cmd窗口，把路径切换到当前路径打开命令提示行，输入以下内容（最后的是文件名）==&gt;调用pyinstaller.py文件打包： python pyinstaller.py -F myfile.py 2、使用pip方式安装的Pyinstaller打包方式打开cmd窗口，把路径切换到文件所在路径(文件随便放在哪里都行)打开命令提示行，输入以下内容（最后的是文件名）： pyinstaller -F myfile.py 使用实例pyinstaller -F test.py -i src\\logo.ico -F 表示生成单个可执行文件 -w 表示去掉控制台窗口，这在GUI界面时非常有用。不过如果是命令行程序的话那就把这个选项删除吧！ -p 表示你自己自定义需要加载的库路径，一般情况下用不到 -i 表示可执行文件的图标 ▲. -i的参数为.ico格式,其他格式的图片会报错 文件中使用了第三方库的打包方式在打包之前务必找到第三方库的包，把包复制到到跟myfile.py同目录下，然后再使用以上2种方式打包，否则会打包失败或者即使打包成功，程序也会闪退。 pyqt5打包出现错误一 、当写这篇文章的时候，pyinstaller官网版本对pyqt5打包可能会遇到Could not find QtWebEngineProcess.exe.的错误。解决方法为：安装最新的pyinstaller 1.在github下载新版本的开发包。2.打开解压后的文件夹，shift+鼠标右键，点击“在此处打开命令窗口”。之后依次运行如下命令: 123pip uninstall pyinstallerpython setup.py buildpython setup.py install 二 、如果有报错：“could not find or load the Qt platform plugin &quot;windows&quot; ”。原因之一可能是你把打包后的文件放在了中文目录下。只需要将打包后的文件放在英文目录下，就可以解决。 多文件打包1234pyinstaller [主文件] -p [其他文件1] -p [其他文件2] --hidden-import [自建模块1] --hidden-import [自建模块2]# 以上为一整条命令 1pyinstaller main.py -p mysql.py -p other.py --hidden-import mysql --hidden-import other","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"pyqt5与QT5","slug":"pyqt与QT5","date":"2018-11-26T04:11:52.000Z","updated":"2018-11-26T05:17:39.620Z","comments":true,"path":"2018/11/26/pyqt与QT5/","link":"","permalink":"https://nymrli.top/2018/11/26/pyqt与QT5/","excerpt":"","text":"添加QT Designer、PyUIc、Pyrcc 1.添加外部工具(Extenal Tools)QT Designer File–&gt;Settings–&gt;Tools–&gt;Extenal Tools –&gt; ‘’+’’ &gt; 添加具体细节,如图一图二 ​ 图一 ​ 图二 修改Name为QT Designer,Program为QT目录下designer.exe文件,不需要参数,Work directory为D:\\QT\\{QT version}\\msvc2015_64\\bin 添加后就可以在菜单栏的Tools中找到..点击后,就可以直接打开QT Designer设计窗口 QT Designer QT UIC1.Program设置为当前虚拟环境的python解释器python.exe,(一旦设置好后,每次新建虚拟环境,pycharm会自动帮你修改选择的解释器) 2.▲.Arguments参数设置为: 12345-mPyQt5.uic.pyuic$FileName$-o$FileNameWithoutExtension$.py 这个参数主要是用uic这个工具需要指定的参数 3.working directory设置为$FileDir$(当前文件目录)===&gt;含义是:根据.UI生成的py窗口文件的位置完成后,效果如图..一开始是没有window.py 将光标选择window.ui文件,然后选择Tools里面的PyUIC就可以自动生成一个window.py文件直接使用了. 控制台输出内容: 123G:\\PyGui\\venv\\Scripts\\python.exe -m PyQt5.uic.pyuic window.ui -o window.py#点击PyUIC就相当于输出了在setting里面写好的代码,$FileName$为我们光标选择的文件名,输出的名字为$FileNameWithoutExtension$.py,输出的路径为当前文件目录$FileDir$Process finished with exit code 0 QT Rcc1.将program设置为QT目录下的rcc.exe文件 2.设置Arguments为123$FileName$-o$FileNameWithoutExtension$.py 道理同上-o 是输出的意思 3.work directory设置为$FileDir$4.新建.qrc资源文件打开QT Designer选择下面的资源管理器,单击铅笔,如图操作 单击左边蓝色的存储后,意思是指定.qrc文件存储位置 选择好以后,再操作右边的选择卡,填好前缀,然后点击蓝色的按键,选择要添加的资源文件(如图片什么的) 此时打开.qrc文件就可以看到他指定了哪些资源文件 上述步骤完成后就可以使用rcc工具将.qrc文件转换成.py的资源文件使用了 光标选择.qrc资源后,选择Pyrcc后就会生成相应的py文件 需要用到图片时,直接导入图片的.py文件即可 12[mainwindow.py]import picture 12345678910111213[main.py]#显示加载界面if __name__ == '__main__': app = QApplication(sys.argv) splash = QSplashScreen(QPixmap(':/load/loading.jpg')) splash.show() splash.showMessage('正在加载请稍等..') time.sleep(0.5) app.processEvents() ui = caofunction.MyWindow() ui.show() splash.finish(ui) sys.exit(app.exec_()) ####","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"机器学习——数学概念","slug":"机器学习——数学概念","date":"2018-11-24T05:00:34.000Z","updated":"2019-01-21T01:26:20.403Z","comments":true,"path":"2018/11/24/机器学习——数学概念/","link":"","permalink":"https://nymrli.top/2018/11/24/机器学习——数学概念/","excerpt":"","text":"箱线图箱线图（Box plot）也称箱须图（Box-whisker Plot）、箱线图、盒图，可以用来反映一组或多组连续型定量数据分布的中心位置和散布范围，因形状如箱子而得名。 - 连续型数据：在一定区间内可以任意取值的变量叫连续变量，其数值是连续不断的。例如，生产零件的规格尺寸，人体测量的身高、体重等，其数值只能用测量或计量的方法取得。可视化这类数据的图表主要有箱形图和直方图。 - 离散型数据：数值只能用自然数或整数单位计算的则为离散变量。例如，企业个数，职工人数，设备台数等，只能按计量单位数计数，数值一般用计数方法取得。大多数图表可视化的都是这类数据，比如柱状图、折线图等。 ## 优点:箱形图最大的优点就是不受异常值的影响，能够准确稳定地描绘出数据的离散分布情况，同时也利于数据的清洗。 箱子上的线四分位数Q1:第一四分位数(下四分位数) Q2:中位数 Q3:第三四分位数(上四分位数) 一组数据按照从小到大顺序排列后，把该组数据四等分的数，称为四分位数。第一四分位数 (Q1)、第二四分位数 (Q2，也叫“中位数”)和第三四分位数 (Q3)分别等于该样本中所有数值由小到大排列后第25%、第50%和第75%的数字。第三四分位数与第一四分位数的差距又称四分位距（interquartile range, IQR）。 **箱子的高度在一定程度上反映了数据的波动程度 上下线上下边缘则代表了该组数据的最大值和最小值 上限 :上限是非异常范围内的最大值。 下限:下限是非异常范围内的最小值。 有时候箱子外部会有一些点，可以理解为数据中的“异常值”。 偏态与正态分布相对，指的是非对称分布的偏斜状态。在统计学上，众数和平均数之差可作为分配偏态的指标之一：如平均数大于众数，称为正偏态（或右偏态）；相反，则称为负偏态（或左偏态）。 偏态表示偏离程度，异常值集中在较小值一侧，则分布呈左偏态；异常值集中在较大值一侧，则分布呈右偏态。 Confusion_martrix(混淆矩阵)混淆矩阵: 一种特定的矩阵用来呈现算法性能的可视化效果，通常是监督学习（非监督学习，通常用匹配矩阵：matching matrix） 其每一列代表预测值，每一行代表的是实际的类别。这个名字来源于它可以非常容易的表明多个类别是否有混淆（也就是一个class被预测成另一个class）。 Example样例说明:假设有一个用来对猫（cats）、狗（dogs）、兔子（rabbits）进行分类的系统，混淆矩阵就是为了进一步分析性能而对该算法测试结果做出的总结。假设总共有 27 只动物：8只猫， 6条狗， 13只兔子。结果的混淆矩阵如下图： 在这个混淆矩阵中，实际有 8只猫，但是系统将其中3只预测成了狗；对于 6条狗，其中有 1条被预测成了兔子，2条被预测成了猫。从混淆矩阵中我们可以看出系统对于区分猫和狗存在一些问题，但是区分兔子和其他动物的效果还是不错的。所有正确的预测结果都在对角线上，所以从混淆矩阵中可以很方便直观的看出哪里有错误，因为他们呈现在对角线外面。 Table of confusion(混淆表格)有时也称混淆矩阵. 由false positives，false negatives，true positives和true negatives组成的两行两列的表格。它允许我们做出更多的分析，而不仅仅是局限在正确率.。 它允许我们做出更多的分析，而不仅仅是局限在正确率。准确率对于分类器的性能分析来说，并不是一个很好地衡量指标，因为如果数据集不平衡（每一类的数据样本数量相差太大），很可能会出现误导性的结果。例如，如果在一个数据集中有95只猫，但是只有5条狗，那么某些分类器很可能偏向于将所有的样本预测成猫。整体准确率为95%，但是实际上该分类器对猫的识别率是100%，而对狗的识别率是0%。 对于上面的说明样例，其对应的对猫这个类别的混淆表格如下： 假定一个实验有 P个positive实例，在某些条件下有 N 个negative实例。那么上面这四个输出可以用下面的偶然性表格（或混淆矩阵）来表示： 更多详情见博客 摘自博客 : https://blog.csdn.net/vesper305/article/details/44927047","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"数学知识","slug":"数学知识","permalink":"https://nymrli.top/tags/数学知识/"}]},{"title":"机器学习——python实践.笔记","slug":"机器学习——Python实践-笔记","date":"2018-11-23T13:20:18.000Z","updated":"2019-01-21T03:20:14.724Z","comments":true,"path":"2018/11/23/机器学习——Python实践-笔记/","link":"","permalink":"https://nymrli.top/2018/11/23/机器学习——Python实践-笔记/","excerpt":"","text":"机器学习——Python实践 Numpy: python开源数值计算拓展,用来存储和处理大型矩阵,提供了许多高级的数值编程工具,如 矩阵数据类型、矢量处理、精密的运算库 利用Numpy数组来准备机器学习算法的数据 matplotlib: python中最著名的2D绘图库,适合交互式的进行制图;也可作为绘图空间,嵌入GUI应用程序中 创建图表,展示数据 Pandas: 基于Numpy的工具,为了解决数据分析任务而创建的.~纳入了大量库和标准的数据模型,提供了操作大型数据集的工具,和快速便捷处理数据的函数和方法 导入、展示数据，以便挣钱对数据的理解和数据清洗、转换等工作 ##### 预测模型所需的六个步骤: 第一章：鸢尾花(Iris Flower) 所有特征数据都是数字,不需要考虑如何导入和处理数据—&gt;有的图表有标题等的,需要处理- 分类问题===&gt;监督学习算法 多分类问题,可能需要一些特殊处理 所有特征的数值采用相同单位,不需要进行尺度转换 步骤: 1.导入数据集123456789from pandas import read_csvfrom matplotlib import pyplotfrom sklearn.svm import SVCfilename = 'iris.data.csv'names = ['separ-length','separ-width','petal-length','petal-width','class']# 花萼长度+宽度 , 花瓣长度+宽度dataset = read_csv(filename,names = names)print(dataset) # 150 * 5 2.概述数据 从下列角度审查数据: 数据的维度 查看数据的自身 统计描述所有的数据特征 数据分类的分布情况 1.数据的维度了解数据集中有多少行数据,数据有几个属性 12print('数据的维度: 行 %s , 列 %s' % (dataset.shape))#&gt;&gt;&gt;数据的维度: 行 150 , 列 5 2.参看数据本身直观的看到数据的特征,数据的类型,以及大概的数据分布范围 12345678print(dataset.head(5))&gt;&gt;&gt; separ-length separ-width ... petal-width class0 5.1 3.5 ... 0.2 Iris-setosa1 4.9 3.0 ... 0.2 Iris-setosa2 4.7 3.2 ... 0.2 Iris-setosa3 4.6 3.1 ... 0.2 Iris-setosa4 5.0 3.6 ... 0.2 Iris-setosa 3.统计描述数据数据特征的统计描述信息包括数据的行数、中位值、最大值、最小值、均值、四分位值等统计数据信息 1234567891011print(dataset.describe())&gt;&gt;&gt; separ-length separ-width petal-length petal-widthcount 150.000000 150.000000 150.000000 150.000000mean 5.843333 3.054000 3.758667 1.198667std 0.828066 0.433594 1.764420 0.763161min 4.300000 2.000000 1.000000 0.10000025% 5.100000 2.800000 1.600000 0.30000050% 5.800000 3.000000 4.350000 1.30000075% 6.400000 3.300000 5.100000 1.800000max 7.900000 4.400000 6.900000 2.500000 4.数据分类分布了解数据在不同分类的分布情况..==&gt;每个分类数据量的绝对数值 1234567print(dataset.groupby('class').size())&gt;&gt;&gt;classIris-setosa 50Iris-versicolor 50Iris-virginica 50dtype: int64 ▲ 如果数据分布不平衡,可能会影响到模型的准确性,..==&gt;不平衡时,需要对数据进行调整,方法有: 扩大数据样本 通常容易被忽略的选择…但往往找到更大的数据集就有可能挖掘出更平衡的方面提高算法准确度 数据的重新抽样 过抽样(复制少数类样本)..数据少时考虑 欠抽样(删除多数类样本)..数据多时考虑 尝试生成人工样本 从少数类的实例中随机抽样特征属性,生成更多数据 异常检测和变化检测 尝试从不同观点思考,异常检测是对罕见事件的检测,将小类作为异常值类 3.数据可视化 单变量图表: 理解每一个特征属性 多变量图表: 理解不同特征属性之间的关系 单变量图: 箱线图: 一种用作显示一组数据分散情况资料的统计图。因形状如箱子而得名。 主要用于反映原始数据分布的特征，还可以进行多组数据分布特征的比 较。箱线图的绘制方法是：先找出一组数据的最大值、最小值、中位数和两个四分位数；然后， 连接两个四分位数画出箱子；再将最大值和最小值与箱子相连接，中位数在箱子中间。 12345678#箱线图 , 因为每个特征属性都是数字 , 所以 用箱线图展示 属性与中位值的离散程度dataset.plot(kind='box',subplots = True,layout = (2,2) , sharex = False , sharey = False)# 参数说明 : box箱线 , subplots 允许多个子图, layout 布局为2*2 , sharex.sharey 不共享x,ypyplot.show()#---#直方图 , x轴为值 , y轴为数量dataset.hist()pyplot.show() 多变量图:12345from pandas.plotting import scatter_matrix#散点矩阵图scatter_matrix(dataset)pyplot.show()#pyplot.savefig(\"scatter_matrix.png\") 4.评估算法 分离出评估数据集 采用10折交叉验证来评估算法模型 生成6个不同的模型来预测新数据 选择最优模型 1.分离出评估数据集:heart:要想知道算法模型对真是数据的准确度,所以保留一部分数据来评估算法模型. 12345678from sklearn.model_selection import train_test_splitarray = dataset.valuesX = array[:,0:4] #除了最后的class类别Y = array[:,4] #类别,目标validation_size = 0.2 #验证比例seed = 7 #随机种子X_train , X_validation , Y_train , Y_validation = \\ train_test_split(X,Y,test_size=validation_size,random_state=seed) 2.评估模式采用10折交叉验证来分离训练数据集 : 随机将数据分成10份,9份用来训练模型,1份用来评估算法 3.创建模型线性 线性回归(LR) 线性判别分析(LDA) 非线性 K近邻(KNN) 分类与回归树(CART) 贝叶斯分类器(NB) 支持向量机(SVM) ▲ 在每次对算法进行评估前都会重新设置随机数种子,以保证每次对算法的评估都是用相同的数据集 12345678910111213141516171819202122from sklearn.linear_model import LogisticRegression,LinearRegression #LRfrom sklearn.tree import DecisionTreeClassifier #CARTfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis #LDAfrom sklearn.naive_bayes import GaussianNB #NBfrom sklearn.neighbors import KNeighborsClassifier #KNNfrom sklearn.svm import SVC #SVMfrom sklearn.model_selection import KFold,cross_val_scoremodels = &#123;&#125;models['LR'] = LogisticRegression()models['LDA'] = LinearDiscriminantAnalysis()models['CART'] = DecisionTreeClassifier()models['NB'] = GaussianNB()models['KNN'] = KNeighborsClassifier()models['SVM'] = SVC()#评估算法resutls = []for key in models: kfold = KFold(n_splits=10,random_state=seed) cv_result = cross_val_score(models[key],X_train,Y_train,cv = kfold , scoring = 'accuracy') #cross_val_score将交叉验证的整个过程连接起来，不用再进行手动的分割数据, cv参数用于规定将原始数据分成多少份 resutls.append(cv_result) print(\"%s: %f (%f)\" % (key,cv_result.mean(),cv_result.std())) #均值,标准差 4.选择最优模型1234567&gt;&gt;&gt;LR: 0.966667 (0.040825)LDA: 0.975000 (0.038188)CART: 0.966667 (0.040825)NB: 0.975000 (0.053359)KNN: 0.983333 (0.033333)SVM: 0.991667 (0.025000) 为什么使用 10折交叉验证?进行模型验证的一个重要目的是要选出一个最合适的模型，对于监督学习而言，我们希望模型对于未知数据的泛化能力强，所以就需要模型验证这一过程来体现不同的模型对于未知数据的表现效果。 训练准确度==&gt;测试准确度最先我们用训练准确度（用全部数据进行训练和测试）来衡量模型的表现，这种方法会导致模型过拟合(方差大)；===&gt;&gt;为了解决这一问题，我们将所有数据分成训练集和测试集两部分，我们用训练集进行模型训练，得到的模型再用测试集来衡量模型的预测表现能力，这种度量方式叫测试准确度，这种方式可以有效避免过拟合。 测试准确度==&gt;10折交叉验证测试准确度的一个缺点是其样本准确度是一个高方差估计（high variance estimate）, 所以该样本准确度会依赖不同的测试集，其表现效果不尽相同。 12345678910111213for i in xrange(1,5): print \"random_state is \", i,\", and accuracy score is:\" X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=i) knn = KNeighborsClassifier(n_neighbors=5) knn.fit(X_train, y_train) y_pred = knn.predict(X_test) print metrics.accuracy_score(y_test, y_pred)&gt;&gt;&gt;random_state is 1 , and accuracy score is:1.0random_state is 2 , and accuracy score is:1.0random_state is 3 , and accuracy score is:0.947368421053random_state is 4 , and accuracy score is:0.973684210526 上面的测试准确率可以看出，不同的训练集、测试集分割的方法导致其准确率不同，而交叉验证的基本思想是：1.将数据集进行一系列分割，生成一组不同的训练测试集，2.然后分别训练模型并计算测试准确率，3.最后对结果进行平均处理。这样来有效降低测试准确率的差异。 K折交叉验证: 将数据集平均分割成K个等份子集 使用1份数据(子集)作为测试数据，其余(K-1)份作为训练数据 计算测试准确率 使用不同的测试集，重复2、3步骤 对测试准确率做平均，作为对未知数据预测准确率的估计 ==&gt; cross_val_score.mean() 不同的训练集、测试集分割的方法导致其准确率不同，而交叉验证的基本思想是：将数据集进行一系列分割，生成一组不同的训练测试集，然后分别训练模型并计算测试准确率，最后对结果进行平均处理。这样来有效降低测试准确率的差异。 来自周志华&lt;&lt;机器学习&gt;&gt;: 分割方法1234# 下面代码演示了K-fold交叉验证是如何进行数据分割的# simulate splitting a dataset of 25 observations into 5 foldsfrom sklearn.cross_validation import KFoldkf = KFold(25, n_folds=5, shuffle=False) 12cv_result = cross_val_score(models[key],X_train,Y_train,cv = 10 , scoring = 'accuracy')#cross_val_score将交叉验证的整个过程连接起来，不用再进行手动的分割数据, cv参数用于规定将原始数据分成多少份 5.实施预测12345678910111213141516171819#使用评估数据集评估算法svm = SVC()svm.fit(X = X_train ,y = Y_train) #参数为 X , ypredictions = svm.predict(X_validation)print(accuracy_score(Y_validation,predictions)) #测试集结果 与 预测结果 相比print(confusion_matrix(Y_validation,predictions))print(classification_report(Y_validation,predictions))&gt;&gt;&gt;0.9333333333333333[[ 7 0 0] [ 0 10 2] #混淆矩阵只出现了两个错误,2 [ 0 0 11]] precision(精确度) recall(召回率) f1-score(F1值) support(总和) Iris-setosa 1.00 1.00 1.00 7Iris-versicolor 1.00 0.83 0.91 12 Iris-virginica 0.85 1.00 0.92 11 avg / total 0.94 0.93 0.93 30 召回率(Recall Rate,也叫查全率) 是检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率； 精度(Precise) 是检索出的相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率。 TP: 预测为正，实际为正 (第一个是实际T或F,第二个是预测P或N) FP: 预测为正，实际为负 TN:预测为负，实际为负 FN: 预测为负，实际为正 精确率、准确率：Accuracy=(TP+TN)/(TP+TN+FN+FP) //精准率、查准率：P = TP/ (TP+FP) 召回率、查全率：R = TP/ (TP+FN) F1-score: 2*TP/(2*TP + FP + FN) ◆. 精确度是“搜索结果有多大用处”，而召回是“结果如何完整”。 F1分数: 概述 : 统计学中用来衡量二分类模型精确度的一种指标。它同时兼顾了分类模型的准确率和召回率。F1分数可以看作是模型准确率和召回率的一种加权平均，它的最大值是1，最小值是0。 人们通常使用准确率和召回率这两个指标，来评价二分类模型的分析效果。 但是当这两个指标发生冲突时，我们很难在模型之间进行比较。比如，我们有如下两个模型A、B，A模型的召回率高于B模型，但是B模型的准确率高于A模型，A和B这两个模型的综合性能，哪一个更优呢？ 准确率 召回率 A 80% 90% B 90% 80% 为了解决这个问题，人们提出了$F_{\\beta}$ 分数。$F_{\\beta}$的物理意义就是将准确率和召回率这两个分值合并为一个分值，在合并的过程中，召回率的权重是准确率的 $\\beta$倍。$F_{1}$分数认为召回率和准确率同等重要， $F_{2}$ 分数认为召回率的重要程度是准确率的2倍，而分$F_{0.5}$数认为召回率的重要程度是准确率的一半。 $F _ { \\beta } = \\left( 1 + \\beta ^ { 2 } \\right) \\cdot \\frac { \\text { precision recall} } { \\left( \\beta ^ { 2 } \\cdot \\text { precision } \\right) + \\text {recall} }$ $\\beta = \\frac { \\text {recall rate} } { \\text {accuracy rate} }$ ▲ 如何计算Precise、Recall、F1-score见博客https://blog.csdn.net/akadiao/article/details/78788864 Confusion_martrix(混淆矩阵)混淆矩阵: 一种特定的矩阵用来呈现算法性能的可视化效果，通常是监督学习（非监督学习，通常用匹配矩阵：matching matrix） 其每一列代表预测值，每一行代表的是实际的类别。这个名字来源于它可以非常容易的表明多个类别是否有混淆（也就是一个class被预测成另一个class）。 Example样例说明:假设有一个用来对猫（cats）、狗（dogs）、兔子（rabbits）进行分类的系统，混淆矩阵就是为了进一步分析性能而对该算法测试结果做出的总结。假设总共有 27 只动物：8只猫， 6条狗， 13只兔子。结果的混淆矩阵如下图： 在这个混淆矩阵中，实际有 8只猫，但是系统将其中3只预测成了狗；对于 6条狗，其中有 1条被预测成了兔子，2条被预测成了猫。从混淆矩阵中我们可以看出系统对于区分猫和狗存在一些问题，但是区分兔子和其他动物的效果还是不错的。所有正确的预测结果都在对角线上，所以从混淆矩阵中可以很方便直观的看出哪里有错误，因为他们呈现在对角线外面。**","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Pycharm里无法查看Sqlite数据表","slug":"Pycharm里无法查看Sqlite数据表","date":"2018-11-23T07:27:38.000Z","updated":"2018-11-23T07:32:06.720Z","comments":true,"path":"2018/11/23/Pycharm里无法查看Sqlite数据表/","link":"","permalink":"https://nymrli.top/2018/11/23/Pycharm里无法查看Sqlite数据表/","excerpt":"","text":"Pycharm里无法查看Sqlite数据表听说Pycharm可以直接看数据库,于是试了试,发现无法读取sqlite数据库的内容…于是发现下载相应的驱动.如图 解决方法:一.打开右侧的Database选项卡,选择Data Source的Sqlite 二.点击黄色三角Download下载相应的驱动软件 三.安装完成,正常使用","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://nymrli.top/tags/数据库/"}]},{"title":"flask-sqlalchemy使用与sqlalchemy对比","slug":"flask-sqlalchemy使用与sqlalchemy对比","date":"2018-11-23T07:22:48.000Z","updated":"2018-12-06T03:07:03.384Z","comments":true,"path":"2018/11/23/flask-sqlalchemy使用与sqlalchemy对比/","link":"","permalink":"https://nymrli.top/2018/11/23/flask-sqlalchemy使用与sqlalchemy对比/","excerpt":"","text":"flask-sqlalchemy使用与sqlalchemy对比flask-sqlalchemy12345678910111213141516171819202122232425from exts import dbclass MGroup(db.Model): __tablename__ = 'Group' id = db.Column(db.Integer, primary_key=True, autoincrement=True) name = db.Column(db.String(50),nullable=False,unique = True)class MUserinfo(db.Model): __tablename__ = 'Userinfo' id = db.Column(db.Integer,primary_key=True,autoincrement=True) stuid = db.Column(db.String(15),unique = True ,nullable=False) subject = db.Column(db.String(50), nullable=False) name = db.Column(db.String(10), nullable=False) qq = db.Column(db.Integer,nullable = False) dirction = db.Column(db.String(20),db.ForeignKey('Group.name'),default='3D仿真组')class Mmessage(db.Model): __tablename__ = 'Contact' id = db.Column(db.Integer,primary_key=True,autoincrement=True) name = db.Column(db.String(10), nullable=False) email = db.Column(db.String(20), nullable=False) subject = db.Column(db.String(20), nullable=False) message = db.Column(db.Text, nullable=False) sqlalchemy123456789101112131415161718192021import sqlalchemyfrom sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmakerprint(sqlalchemy.__version__)engine = create_engine('sqlite:///test.db',echo = True) #将数据库执行的语句打印出来Base = declarative_base() #声明一个基类实例class User(Base): __tablename__ = 'User' #表的名称 #类的属性,而不是在析构函数中定义的原因是,Base类中有构造函数 Uid = sqlalchemy.Column(sqlalchemy.Integer,autoincrement=True,primary_key=True) name = sqlalchemy.Column(sqlalchemy.String(20),nullable=False) def __str__(self): return \"&lt;Uid&gt;:&#123;&#125;,&lt;name&gt;:&#123;&#125;\".format(self.Uid,self.name)Base.metadata.create_all(engine) #创建数据库表,sqlalchemy会自动覆盖已存在的表 flask-sqlalchemy sqlalchemy 表继承的类 db = SQLAlchemy(app),db.Model Base = declarative_base() 都是从工厂函数中声明的一个实例类,作为声明性类基类 链接数据库函数 create_engine() 创建表函数 db.create_all() Base.metadata.create_all(engine) 表单字段 db.Column() sqlalchemy.Column() 字段类型 db.Integer sqlalchemy.Integer 插入数据 msg = Mmessage(name=data.get(‘name’),email=data.get(‘email’), subject=data.get(‘subject’),message=data.get(‘message’)) db.session.add(msg) db.session.commit() user = User(name=’mrli’) Session = sessionmaker(bind=engine) session = Session() session.add(user) session.commit() 查询 Item.query.filter(Item.table == json_data.get(&#39;table&#39;)).first() user = session.query(User).filter_by(name=&#39;mrli&#39;).first() backref 文本输出 def __repr__(self): （与django的__str__不同） sqlalchemy:查: 1234567891011121314151617181920212223242526272829user = session.query(User).all()user = session.query(User).filter_by(name='mrli').first()# 排序for row in user = session.query(User).order_by(User.id): pass# in_for row in session.query(User).filter(User.name.in_(['nymrli','cl'])): pass&gt;&gt;&gt; &lt;Uid&gt;:1,&lt;name&gt;:mrli&gt;&gt;&gt;&gt; &lt;Uid&gt;:3,&lt;name&gt;:qsy for row in session.query(~User.name.in_(['nymrli','cl'])): print(row) &gt;&gt;&gt;(True,)&gt;&gt;&gt;(False,)&gt;&gt;&gt;(True,)# ~ in for row in session.query(User).filter(~User.name.in_(['nymrli','cl'])): pass#计数user = session.query(User).filter(User.name=='mrli').count()#▲.注意filter()的==与filter_by()的=的使用区别# and_ or_ sqlalchemy core (核心层,更接近SQL语句) 代码很接近、形似SQL原生语句,可以写sqlalchemy的SQL方言(dialect) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import sqlalchemyfrom sqlalchemy import create_enginefrom sqlalchemy import Table,MetaDataprint(sqlalchemy.__version__)engine = create_engine('sqlite:///test.db',echo = True) #将数据库执行的语句打印出来metadata = MetaData()users = Table( 'users',metadata, sqlalchemy.Column('id',sqlalchemy.Integer,primary_key=True), sqlalchemy.Column('name',sqlalchemy.String))addresses = Table( 'addresses' , metadata, sqlalchemy.Column('id', sqlalchemy.Integer, primary_key=True), sqlalchemy.Column('user_id', None,primary_key('users.isd')), sqlalchemy.Column('email_address', sqlalchemy.String, nullable=False))metadata.create_all(engine)users = Table( 'users',metadata, sqlalchemy.Column('id',sqlalchemy.Integer,primary_key=True), sqlalchemy.Column('name',sqlalchemy.String))addresses = Table( 'addresses' , metadata, sqlalchemy.Column('id', sqlalchemy.Integer, primary_key=True), sqlalchemy.Column('user_id', None,primary_key('users.id')), sqlalchemy.Column('email_address', sqlalchemy.String, nullable=False))metadata.create_all(engine)conn = engine.connect()conn.execute(users.insert(),[ dict(name='nymrli'), dict(name='cl')])conn.execute(users.insert(),[ dict(user_id=1,email_address='1063052964@qq.com'), dict(user_id=1,email_address='2042423232@qq.com'), dict(user_id=2, email_address='1063052923@qq.com'), dict(user_id=2, email_address='2042423232@qq.com'),])from sqlalchemy.sql import selects = select([users])result = conn.execute(s)for x in result: print(x)# s = select([users.addresses]).where(users.c.id == addresses.c.user_id)from sqlalchemy.sql import texts = text( \"SELECT user.name || ',' || addresses.email_address AS title \" \"FROM users.addresses \" \"WHERE users.id == addresses.user_id \" \"AND users.name BETWEEN :x AND :y \" \"AND (addresses.email_address LIKE :e1 \" \"OR addresses.email_address LIKE :e2)\")print(conn.execute(s,x='m',y='z',e1=\"%@aoq.com\",e2='@qwe.com').fetchall()) 注意下最后text()里面写的内容””引号最后要有空格,与下面的语句分割开 无空格的样子: 有空格的样子","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://nymrli.top/tags/数据库/"}]},{"title":"Flask系列–将应用部署在Heroku上","slug":"Flask系列–将应用部署在Heroku上","date":"2018-11-21T07:54:01.000Z","updated":"2018-12-26T00:35:45.617Z","comments":true,"path":"2018/11/21/Flask系列–将应用部署在Heroku上/","link":"","permalink":"https://nymrli.top/2018/11/21/Flask系列–将应用部署在Heroku上/","excerpt":"","text":"Flask补充系列–将应用部署在Heroku上之前曾经介绍过如何将Flask应用部署在自己的服务器上，对于手头并不宽裕的程序员来说，购置一台托管服务器还是一笔不小的开销。即便现在有公有云服务器可以买，不过如果你只是以学习为目的，这笔开销还是能省则省了。另外，如果你的应用中需要访问国外被河蟹掉的资源，在服务器上翻墙也是件麻烦事，所以这里我们补充一篇如何将Flask应用部署在Heroku上。 环境准备Heroku是一个PaaS服务提供商，使用前，你需要先注册一个Heroku帐号，注册帐号是免费的。 此外你本地必须要有Python 2.7的开发环境，并且装好了Pip, Setuptools, Virtualenv等工具。对于Python开发者来说，这些都是必备的吧。此外Git客户端也是必须的，因为Heroku的代码管理用的是Git。 Heroku提供了一个非常方便的Getting Start教程，每种开发环境都有，我们可以打开Python的Getting Start，然后参照其说明创建一个Python Web应用。懒得看英文的朋友们，可以看我下面写的步骤。 在开始创建应用之前，你还需要安装Heroku的客户端工具，你可以根据你本地的操作系统选择安装包下载。这是一个命令行工具，基于Ruby实现，所以使用起来每个操作系统都一样。安装完成后，你可以打开命令行，输入下面的命令来验证安装是否成功： 1$ heroku --version 如果安装成功，就在本地命令行里登录Heroku，执行命令： 1$ heroku login 并输入你注册号的Heroku帐号及密码即可。 创建应用网页创建应用环境准备就绪了，我们开始创建一个应用。浏览器打开Heroku应用控制台，点击右上角的”+”号，并选择”Create new app”。 在创建页面中，输入你的应用名称，比如”flask-bjhee”，如果名称没有被占用，则会跳出绿色提示”flask-bjhee is available”。运行环境默认在美国，也可以选择欧洲。信息填完后，点击下方的”Create App”按钮，应用就创建完成了。 接下来打开命令行，我们要初始化本地及远程代码库： 1234$ mkdir /home/bjhee/flask-bjhee # 创建本地代码工作目录$ cd /home/bjhee/flask-bjhee # 切换到本地代码工作目录$ git init # 创建本地代码库$ heroku git:remote -a flask-bjhee # 连接远程Heroku的flask-bjhee代码库 现在，我们就可以编写应用代码，并提交到Heroku上去了。 命令行创建应用 1234$ heroku create (xxx) #省略会自动默认$ git add .$ git commit -m &quot;yyy&quot;$ heroku git:remote -a flask-bjhee 部署应用既然主要是在讲部署，那代码逻辑就简单些，Hello World吧。我们写一个Flask Web程序”run.py”，内容如下： 123456789from flask import Flaskapp = Flask(__name__) @app.route(&apos;/&apos;)def index(): return &apos;Hello World!&apos; if __name__ == &apos;__main__&apos;: app.run(host=&apos;0.0.0.0&apos;, debug=True) 然后，我们就写个”requirements.txt”文件，应用部署时Heroku远程环境会自动执行： 1$ pip install -r requirements.txt 来安装应用依赖的库。我们的”requirements.txt”文件如下： 12Flask==0.10.1gunicorn==19.4.5 项目依赖Flask很好理解，为什么还要依赖gunicorn呢？因为我们不能靠Flask自带的Web服务器来运行Flask程序，所以gunicorn是个很好的选择。还记得如何通过Gunicorn运行Flask应用吗？对于上面的代码，我们只需执行”gunicorn run:app”即可。现在我们要告诉Heroku，应该使用这个命令来运行我们的应用。怎么做呢，就是在项目根目录里创建一个”Procfile”文件，然后写上： 1web: gunicorn run:app --log-file - 这就告诉Heroku，启动Web时，要执行”gunicorn run:app –log-file -“。后面的”–log-file -“参数，是为了让日志只打印到标准输出stdout上，因为Heroku不提供我们写本地磁盘的功能。 再接下来，我们要写一个app.json来描述项目信息，”app.json”内容大致如下： 1234567&#123; &quot;name&quot;: &quot;Flask sample on Heroku&quot;, &quot;description&quot;: &quot;An example of deploying Flask web app to Heroku.&quot;, &quot;image&quot;: &quot;heroku/python&quot;, &quot;repository&quot;: &quot;https://git.heroku.com/flask-bjhee&quot;, &quot;keywords&quot;: [&quot;python&quot;, &quot;flask&quot; ]&#125; 另外根据习惯，我们应该写一个”README.md”来给用户看，”.gitignore”描述哪些文件类型不需要提交到代码库中去。好了，现在我们的目录结构如下： 1234567flask-bjhee/ ├ .gitignore ├ app.json ├ Procfile ├ README.md ├ requirements.txt └ run.py 让我们执行git提交命令，来部署到远程Heroku上去吧： 123$ git add .$ git commit -m &quot;Initialize Project&quot;$ git push heroku master # 提交到远程master分支 想看看效果，命令行里输入： 1$ heroku open 就会启动浏览器，并打开地址”https://flask-bjhee.herokuapp.com/”，当然你也可以直接浏览器访问这个地址。有没有看到”Hello World!”？ 本篇的示例代码可以在这里下载。 部分转自: 思诚之道 ▲ 注意部署的时候有两个文件不能少,分别是Procfile和requestments.txt(名字必须完全一样,我就是拼错了一次和少了个s),失败的报错情况如图 完成后是这样的.heorku会自动根据你提供的requestments.txt安装相应的依赖库 配置数据库环境、迁移文件、表heroku提供了自己的控制台,打开的命令为heroku run bash,之后就可以像在linux的终端下一样操作了 除了这种方法还可以指明使用heroku命令,需要做的是加上前缀heroku run,如heroku run python manage.py db init 官方介绍为:(如图 自定义域名1$ heroku domains:add apollo.nymrli.top ▲.注意需要认证账户,否则会出现下图结果 待认证好后,还需要用DNS解析,我用的是阿里云的万网解析,将heroku domains:add apollo.nymrli.top后heroku的值用CHAME记录解析.等个几秒后就可以用apollo.nymrli.top访问heroku上面的应用程序了 还有一个做法呢,是直接在heroku相应app的设置里面设置自定义域名,但是由于显示问题,容易复制错,导致无法被解析的问题…如果设置好CHAME解析30秒后还是无法用自定义域名打开的话,看看是不是值复制错了. 所以还是比较建议用命令heroku domains:add xxx来绑定","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"}]},{"title":"二分搜索降低时间复杂度","slug":"二分搜索降低时间复杂度","date":"2018-11-10T13:36:01.000Z","updated":"2018-11-10T13:38:14.609Z","comments":true,"path":"2018/11/10/二分搜索降低时间复杂度/","link":"","permalink":"https://nymrli.top/2018/11/10/二分搜索降低时间复杂度/","excerpt":"","text":"二分搜索降低时间复杂度123456int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;n;i++) cin &gt;&gt; s[i]; canFit(); return 0;&#125; 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 150using namespace std;int n,m,s[MAXN];int ss[MAXN];bool canFit()&#123; int flag = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) for(int l=0;l&lt;n;l++) if( s[i] + s[j] + s[l] + s[k] == m) flag = true; if(flag) cout &lt;&lt; \"YES\"; else cout &lt;&lt; \"NO\" ;&#125; 时间复杂度为O(n^4),只能在n较小的情况下,若n较大,则TLE.. 时间复杂度为O(n^3log2(n))的做法:一层二分搜索 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 150using namespace std;int n,m,s[MAXN];int ss[MAXN];bool binSearch(int k)&#123; int r=n,l=0; while(l &lt;= r)&#123; int i = (r+l)/2; if ( s[i] == k) return true; else if( s[i] &lt; k) l = i+1; else r= i-1; &#125; return false;&#125;bool canFit()&#123; int flag = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if( binSearch(m-s[i] - s[j] - s[k]) flag = true; if(flag) cout &lt;&lt; \"YES\"; else cout &lt;&lt; \"NO\" ;&#125; O(n^2log2(n))做法: 排序O(n^2log2(n)),循环O(n^2log2(n)),总共也是O(n^2log2(n)) 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 150using namespace std;int n,m,s[MAXN];int ss[MAXN];bool binSearch(int k)&#123; int l=0,r=n*n; while(l &lt;= r)&#123; int i = (r+l)/2; if ( s[i] == k) return true; else if( s[i] &lt; k) l = i+1; else r= i-1; &#125; return false;&#125;void enumeration()&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) ss[i*n+j] = s[i] + s[j];&#125;bool canFit()&#123; enumeration(); sort(ss,ss+n*n); //二分搜索的前提是有序 int flag = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if( binSearch(m- s[i] - s[j] )) flag = true; if(flag) cout &lt;&lt; \"YES\"; else cout &lt;&lt; \"NO\" ;&#125; ▲需要注意的是,ss[n*n]的数组需要先排序才能使用二分搜索 —-出自:&lt;&lt;挑战程序设计竞赛&gt;&gt;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"matplotlib.pyplot使用","slug":"matplotlib-pyplot使用","date":"2018-11-10T04:58:51.000Z","updated":"2019-01-17T11:06:34.349Z","comments":true,"path":"2018/11/10/matplotlib-pyplot使用/","link":"","permalink":"https://nymrli.top/2018/11/10/matplotlib-pyplot使用/","excerpt":"","text":"matplotlib.pyplot使用注释1234567891011121314151617181920212223242526272829303132333435## 方法一####################for x_value,y_value in zip(x,y): plt.text(x_value,y_value,y_value,fontsize= 15) #文字标注(x,y,值)###################### 方法二####################for xy in zip(x, y): plt.annotate(\"(%s,%s)\" % xy, xy=xy, xytext=(-20, 10), textcoords='offset points') x0 = 1y0 = 2* x0plt.annotate(r'$&#123;&#125;+&#123;&#125;=&#123;&#125;$'.format(x0,x0,y0),xy=(x0,y0),xycoords='data',xytext=(+30,-30),textcoords = 'offset points', fontsize=16,arrowprops=dict( arrowstyle='-&gt;', connectionstyle='arc3,rad=.2' ))##################### 添加注释(annotate),参数说明plt.annotate(r'$2x+1=&#123;&#125;$'.format(y),xy=(x,y),xycoords='data',xytext=(+30,-30),textcoords = 'offset points',fontsize=16, arrowprops=dict( arrowstyle='-&gt;', connectionstyle='arc3,rad=.2') )# 第一个参数是注释的内容# xy设置箭头尖的坐标# xytext设置注释内容显示的起始位置# arrowprops 用来设置箭头# facecolor 设置箭头的颜色# headlength 箭头的头的长度# headwidth 箭头的宽度# width 箭身的宽度 坐标轴转移1234567ax = plt.gca()ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)ax.xaxis.set_ticks_position(&apos;bottom&apos;)ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;,0))ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;left&apos;].set_position((&apos;data&apos;,0)) 图形类型 散列图 ax1.scatter(x,y,c = &#39;r&#39;,marker = &#39;o&#39;) 折线图plt.plot() 直方图plt.hist() 条形图plt.bar(left=index,height=y,color=&#39;green&#39;,width=0.5) 饼状图:plt.pie(x=fracs,labels=labels,autopct=&#39;%.0f%%&#39;,explode=explode)#autopct显示百分比 箱形图plt.boxplot(data,labels=labels) 等高线 plt.contourf(X,Y,f(X,Y),8,alpha = .75,cmap = plt.cm.hot) scatter基本的用法 条形图123456789fig = plt.figure(dpi=256, figsize=(10, 8))plt.plot(U,I,&apos;r*&apos;)plt.xlabel(&apos;U(V)&apos;,fontsize=10)plt.ylabel(&apos;I(10e-9A)&apos;,fontsize=10)plt.title(&apos;The line chart of the relation between U and I&apos;,fontsize=15)plt.ylim(0,max(I)+0.5)x = np.linspace(0,max(I)+0.5,40)plt.yticks(x,fontsize=6) 线条选项12plt.plot(x,y,&apos;r*&apos;) # 默认为蓝色# 等价于plt.plot(x,y,color= &apos;r&apos;, marker =&apos;*&apos;) 散点图12345678n =100X = np.random.normal(0,10,n)Y = np.random.normal(0,10,n)T = np.arctan2(Y,X)plt.scatter(X,Y,c= T,s=6)plt.xticks(())plt.yticks(())plt.show() 柱状图1234567891011121314n=12X=np.arange(n)Y1=(1-X/float(n))*np.random.uniform(0.5,1.0,n)Y2=(1-X/float(n))*np.random.uniform(0.5,1.0,n)plt.bar(X,+Y1,facecolor='#9999ff',edgecolor='white')plt.bar(X,-Y2,facecolor='#ff9999',edgecolor='white')for x,y in zip(X,Y1): plt.text(x+0,y+0.05,\"%.2f\" %y,ha='center',va='bottom') # horizontal alignment , vertical alignmentplt.xlim(-.5,n)plt.xticks(())plt.ylim(-1.25,1.25)plt.yticks(())plt.show() 等高线123456789101112def f(x,y): # return 1 + 1/x**3 + y**5 return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)n = 256x = np.linspace(-3,3,n)y = np.linspace(-3,3,n)X,Y = np.meshgrid(x,y)plt.contourf(X,Y,f(X,Y),8,alpha = .75 , cmap = plt.cm.hot)C = plt.contour(X,Y,f(X,Y),8,colors = &apos;black&apos;)plt.clabel(C,inline = True,fontsize = 10) 图例123l1 , = plt.plot(x,y,linestyle= '--',color = 'red',linewidth=2.0)# 返回值为一个元组plt.legend(handles=[l1],labels = ['les'],loc='best') 3D图形1234567891011121314from matplotlib import pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)x = np.linspace(-4,4,50)y = np.linspace(-4,4,50)X,Y = np.meshgrid(x,y)R = np.sqrt(X**2 + Y**2)Z = np.sin(R)ax.plot_surface(X,Y,Z,rstride=1,cstride=1,cmap = plt.get_cmap('rainbow'))ax.contour(X,Y,Z,zdir='x',offset = -5)#画等高线图,往哪个(x)轴压缩,到x=-5位置plt.show() ### 分格画子图123456789101112131415161718192021# method 1: subplot2grid##########################plt.figure()axl=plt. subplot2grid((3,3),(0,0), colspan=3, rowspan=1)# 三行三列, 从源点(0,0)开始画,第一张图占一行三列axl.plot([1,2],[1,2])ax1.set_title('xxx')# 原来plt.title()设置的方法,现在都变成了ax?.set_xxx,多了前缀set_ax2=plt. subplot2grid((3,3),(1,0), colspan=2,)ax3=plt. subplot2grid((3,3),(1,2), rowspan=2)ax4=plt. subplot2grid((3,3),(2,0) #method 2 :gridspec import matplotlib.gridspec as gridspeccplt.figure()gs=gridspec.GridSpec(3,3)ax1=plt.subplot(gs[0, :])ax2=plt.subplot(gs[1, :2])ax3=plt.subplot(gs[1: ,2])ax4=plt.subplot(gs[-1,0])ax5=plt.subplot(gs[-1,-2]) 附录:温习源自WeiboSpider12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Cgraph(object): def __init__(self): self.db = db self.create_dir() self.Start_timestmp = time.mktime(time.strptime('2018-7-5 00:00','%Y-%m-%d %H:%M')) def judge_over(self, _time): # start_time is timestamp ''' 判断时间是否已经超过预设时间 :param Start_timestmp: :param _time: :return: ''' timestamp = time.mktime(time.strptime(_time, '%Y-%m-%d %H:%M')) # Start_timestamp = time.mktime(time.strptime(Start_time,'%Y-%m-%d %H:%M')) if timestamp - self.Start_timestmp &lt; 0: return True else: return False def create_dir(self): if not os.path.isdir('.\\\\graph'): os.makedirs('.\\\\graph') def count(self,lists): exist_dict = OrderedDict() for x in lists: if x not in exist_dict: exist_dict[x] = 1 else: exist_dict[x] += 1 return dict(sorted(exist_dict.items(),key=lambda x:x[0])) def unify_time(self,_time): c = _time.split('-') _time = '-'.join(['0' + x if len(x.strip()) == 1 else x for x in c]) if _time[:4] == '2018': _time = _time[5:10] return _time[:10] def Draw(self): timelist = [] for alls in self.db.find(): if alls.get('time'): print(alls.get('time')) timelist.append(self.unify_time(alls.get('time'))) infodict = self.count(timelist[::-1]) plt.figure(figsize=(40, 18)) #设置图片大小 # plt.rcParams['figure.figsize'] = (40.0, 12.0) 设置图片大小的另外一种方法 # plt.rcParams['figure.dpi'] = 400 x = list(infodict.keys()) y = list(infodict.values()) plt.plot(x,y,linewidth=2,color='r',marker='o',markersize=8) for x_value,y_value in zip(x,y): plt.text(x_value,y_value,y_value,fontsize= 15) #文字标注(x,y,值) plt.ylim((0, max(y))) #纵坐标y的上下限 plt.yticks([x for x in range(0,max(y)+10,10)]) #y的比例尺 plt.xlabel('Time') plt.ylabel('Keyword times') #y轴的标签 plt.title('Weibo Keyword\\'s Trendency') #图的标题 plt.savefig('.\\\\graph\\\\&#123;&#125;.jpg'.format(TABLE)) #保存图片 plt.clf()if __name__ == '__main__': graph = Cgraph() graph.Draw() print('完成') 使用:大物实验画折线图12345678910111213141516171819202122232425262728293031323334import csvfrom matplotlib import pyplot as pltimport osimport numpy as npI = []U = []def extractFromCsv(filename): with open(filename,'r') as f: reader = csv.reader(f) for row in reader: if reader.line_num == 1: #跳过表头 continue U.append(float(row[0])) I.append((float(row[1])))def drawPic(filename): fig = plt.figure(dpi=256, figsize=(10, 8)) plt.plot(U,I,'r*') plt.xlabel('U(V)',fontsize=10) plt.ylabel('I(10e-9A)',fontsize=10) plt.title('The line chart of the relation between U and I',fontsize=15) plt.ylim(0,max(I)+0.5) x = np.linspace(0,max(I)+0.5,40) plt.yticks(x,fontsize=6) if not os.path.exists(\".\\\\graph\"): os.mkdir('.\\\\graph') plt.savefig('.\\\\graph\\\\&#123;&#125;.jpg'.format(filename))if __name__ == \"__main__\": filename='phy.csv' extractFromCsv(filename) drawPic(filename)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"apt代理的设置","slug":"apt代理的设置","date":"2018-11-10T04:56:53.000Z","updated":"2018-11-10T04:57:21.033Z","comments":true,"path":"2018/11/10/apt代理的设置/","link":"","permalink":"https://nymrli.top/2018/11/10/apt代理的设置/","excerpt":"","text":"原因是在apt-get update时遇到了Unable to connect to 代理，（由于apt-get update一直显示无法连接172.17.18.141百度后发现并不是个特殊的IP,）于是想到是否使用了代理。 apt代理的设置：临时方法export http_proxy=http://10.3.0.1:80 长久方法(1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。) Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;; 保存apt.conf文件。 (2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件) 建立文件 vim proxyfile Acquire::http::proxy &quot;http://10.3.0.1:80&quot;; Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;; Acquire::https::proxy &quot;http://10.3.0.1:80&quot;; 使用时sudo apt-get install xxx -c proxyfile (2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 ) 在您的.bashrc文件末尾添加如下内容export http_proxy=http://用户名:密码@地址:端口/export https_proxy=http://用户名:密码@地址:端口/ export ftp_proxy=http://用户名:密码@地址:端口/ https://blog.csdn.net/qq3399013670/article/details/81300497","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://nymrli.top/tags/Ubuntu/"}]},{"title":"Ubuntu更改nginx默认端口","slug":"Ubuntu更改nginx默认端口","date":"2018-11-10T04:55:13.000Z","updated":"2018-11-10T04:56:15.277Z","comments":true,"path":"2018/11/10/Ubuntu更改nginx默认端口/","link":"","permalink":"https://nymrli.top/2018/11/10/Ubuntu更改nginx默认端口/","excerpt":"","text":"Ubuntu更改nginx默认端口 nginx 默认使用80端口，有时候我们希望nginx运行在其他端口，就需要更改nginx配置 nginx配置文件在/etc/nginx目录下的nginx.conf。(可以修改处理器数量、日志路径、pid文件路径等，默认的日志。) 错误日志 /var/log/nginx/error.log访问日志 /var/log/nginx/access.log 在nginx.conf-&gt;http选项末尾有引入两个目录下的文件分别为： 123456[/etc/nginx/nginx.conf]http &#123; # 省略部分内容 include /etc/nginx/conf.d/*.conf; #意思是把用户自己的配置放到conf.d/* include /etc/nginx/sites-enabled/*;&#125; 查看/etc/nginx/sites-enabled/目录，会找到一个default文件，在server选项下前两行就可以找到使用的80端口号： 1234[/etc/nginx/sites-enabled/default]server &#123; listen 80 default_server; listen [::]:80 default_server; 将80端口号改为想使用的端口号，保存文件，如果没有启动nginx，启动即可。如果nginx已经在运行，重新加载即可。 12sudo nginx start #运行nginxsudo nginx -s reload #重启nginx 如果遇到nginx报以下错误：nginx: [error] open() &quot;/run/nginx.pid&quot; failed (2: No such file or directory)则`sudo nginx -c path/.conf #指定nginx配置.conf的位置` 查看nginx运行的端口`sudo netstat -anp | grep nginx` ▲如果启用防火墙，则需开启对应端口，使用AWS服务器需要更改服务器安全组，添加响应入站规则，开启对应端口。","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://nymrli.top/tags/Ubuntu/"}]},{"title":"Pythonanywhere解决链接Mysql问题(部署flask)","slug":"Pythonanywhere解决链接Mysql问题-部署flask","date":"2018-11-10T04:54:14.000Z","updated":"2018-12-26T00:35:33.196Z","comments":true,"path":"2018/11/10/Pythonanywhere解决链接Mysql问题-部署flask/","link":"","permalink":"https://nymrli.top/2018/11/10/Pythonanywhere解决链接Mysql问题-部署flask/","excerpt":"","text":"Pythonanywhere解决链接Mysql问题(部署flask) 由于在bash控制台里通过命令mysql -p(这其实是因为错误的连接方式,由于不是默认的端口3306,自然连接不到,官方文档中有正确的连接方式)链接不到Mysql时,再加上进虚拟环境用python manage db migrate也失败后,我是异常慌张的..然后立马发现关于pythonanywhere链接Mysql的解决不是很多,要么就是说免费账号是无法用的…心顿时拔凉,但最后还是找到了pythonanywhere官方的文档,解决了这个问题,发现都是配置的问题 一开始的我本地及阿里云链接mysql数据库配置文件是这样写的: 1234567891011121314#[config.py]DIALECT = 'mysql'DRIVER = 'pymysql'USERNAME = 'root'PASSWORD = 'zxcqwe' #瞎写的HOST = '127.0.0.1'PORT = '3306'DATABASE = 'restaurant'DEBUG = TrueSQLALCHEMY_DATABASE_URI = \"&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8\".format( DIALECT,DRIVER,USERNAME,PASSWORD,HOST,PORT,DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False 后来根据说明改成了如下: 123456789101112#[config.py]DIALECT = 'mysql'DRIVER = 'pymysql'USERNAME = 'nymrli'PASSWORD = 'zxcqwe' #瞎写的HOST = 'nymrli.mysql.pythonanywhere-services.com'PORT = '3306'DATABASE = 'nymrli$restaurant'DEBUG = TrueSQLALCHEMY_DATABASE_URI = \"&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8\".format( DIALECT, DRIVER, USERNAME, PASSWORD, HOST, PORT, DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False 其中修改的地方为 USERNAME为pythonanywhere账号 PASSWORD为Database详情页设置的数据库密码 HOST为Database详情页上的Database host address DATABASE为Database详情页上 create a database的数据库名,但pythonanywhere会自动给你加上前缀&lt;username&gt;$&lt;database_name&gt;,所以我这边就是nymrli$restaurant PORT默认还是3306 附上官方文档:配置说明: 开始使用MySQL,您需要去在仪表板的MySQL选项卡,并设置一个密码。你也会找到连接设置选项卡(主机名、用户名),以及创建新的数据库的能力。 你可以开始一个新的MySQL控制台访问数据库从这个选项卡,或者您可以打开一个MySQL从bash shell使用以下命令控制台或ssh会话: mysql -u USERNAME -h HOSTNAME -p &#39;USERNAME$DATABASENAME&#39; Using MySQL 通过SSH链接,据说免费账户不支持:12345678910Setting ValueSSH Hostname: ssh.pythonanywhere.comSSH Username: your PythonAnywhere usernameSSH Password: the password you use to log in to the PythonAnywhere websiteSSH Key file: should not be necessary when you specify the passwordMySQL Hostname: your PythonAnywhere database hostname, eg. yourusername.mysql.pythonanywhere-services.comMySQL Server Port: 3306Username: your PythonAnywhere usernamePassword: your PythonAnywhere database passwordDefault Schema: your database name, eg yourusername$mydatabase Accessing your MySQL database from outside PythonAnywhere","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"MySQL","slug":"MySQL","permalink":"https://nymrli.top/tags/MySQL/"}]},{"title":"写爬虫过程中碰到的编码问题","slug":"写爬虫过程中碰到的编码问题","date":"2018-11-08T04:23:19.000Z","updated":"2018-12-03T15:02:19.224Z","comments":true,"path":"2018/11/08/写爬虫过程中碰到的编码问题/","link":"","permalink":"https://nymrli.top/2018/11/08/写爬虫过程中碰到的编码问题/","excerpt":"","text":"写爬虫过程中碰到的编码问题遇到 ‘ \\uxxxx ‘ 的16进制字符串编解码问题，使用unicode-escape解决之。实际上，在将unicode存储到文本的过程中，还有一种存储方式，不需要将unicode转换为实际的文本存储字符集，而是将unicode的内存编码值进行存储，读取文件的时候再反向转换回来，是采用：unicode-escape的转换方式。 将unicode的内存编码值进行存储，读取文件时在反向转换回来。这里就采用了unicode-escape的方式 12345678print(u&apos;中文测试&apos;.encode(&apos;utf-8&apos;))print(&apos;中文测试&apos;.encode(&apos;utf-8&apos;))print(u&apos;中文测试&apos;.encode(&apos;unicode-escape&apos;))print(&apos;中文测试&apos;.encode(&apos;unicode-escape&apos;))==&gt; b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe6\\xb5\\x8b\\xe8\\xaf\\x95&apos;==&gt; b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe6\\xb5\\x8b\\xe8\\xaf\\x95&apos;==&gt; b&apos;\\\\u4e2d\\\\u6587\\\\u6d4b\\\\u8bd5&apos;==&gt; b&apos;\\\\u4e2d\\\\u6587\\\\u6d4b\\\\u8bd5&apos; ASCII码只有128个字符，符合英文，一个英文字符只用1个字节(最高位恒为0) ANSI：面向中文编码的GBK、GB2312是ANSI码的一种，ANSI码是对ASCII的拓展，所以一个英文只用一个字节，而中文需要拓展ASCII，所以用到两个字节。 0x80~0xFFFF =&gt;2**16 Unicode编码:为了解决不同国家ANSI编码的冲突问题，最常用的是用两个字节表示一个字符 。但是这样的话，原本可以用一个字节存储的英文字母在Unicode里面必须存两个字节，这就产生了浪费。那么有没有一种既能消除乱码，又能避免浪费的编码方式呢？===&gt;答案就是UTF-8 。000000 -10FFFF 12&gt; UNICODE 的范围是 0x0000 - 0xFFFF 共6万多个字符，其中光汉字就占用了4万多个&gt; UTF-8编码：当字符在ASCII码的范围时，就用一个字节表示 ，所以英文字符也只用一个字节，▲值得注意的是unicode编码中一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。utf-8长度是1-6个字节 （可变的） Unicode编码(十六进制) UTF-8 字节流(二进制) 000000-00007F 0xxxxxxx 000080-0007FF 110xxxxx 10xxxxxx 000800-00FFFF 1110xxxx 10xxxxxx 10xxxxxx 010000-10FFFF 11110xxx 10xxxxxx 10xxxxxx10xxxxxx 超出10FFFF后，UTF-8与Unicode不再对应 总结： UTF-8 vs GBK： UTF-8版本虽然具有良好的国际兼容性，但中文需要比GBK/BIG5版本多占用50%的数据库存储空间，因此并非推荐使用，仅供对国际兼容性有特殊要求的用户使用。简单地说：对于中文较多的网站，适宜用GBK编码节省数据库空间。对于英文较多的网站，适宜用UTF-8节省数据库空间。 字符编码ANSI和ASCII区别、Unicode和UTF-8区别 Python中编码问题 在python中，unicode是内存编码集，一般我们将数据存储到文件时，需要将数据先编码为其他编码集，比如utf-8、gbk等。 读取数据的时候再通过同样的编码集进行解码即可。 但是其实还有一种unicode-escape编码集，他是将unicode内存编码值直接存储： 在使用python3的requests模块时，发现获取响应有两种方式 其一，为文本响应内容, r.text是Unicode的响应内容 其二，为二进制响应内容，r.content是二进制的响应内容 Python2 的编码问题一直非常让人恼火，不过你的问题稍微简单一些。在交互式命令模式(Interactive shell)下，可以这样来明白你遇到的问题的根源： 1234567import sys sys.stdout.encoding 在 Windows 下，如果你的系统是简体中文，一般输出会是 cp936 import codecs codecs.lookup(&apos;cp936&apos;).name &apos;gbk&apos; 这就是在 Windows 终端里面使用的编码。在 print 的时候，无论字符串源采取什么样的编码，最终输出的字符串的编码必须跟 shell 的编码一致，也就是说:print some_stringPython 会做这样一个动作：codecs.encode(some_string, coding, errors=’strict’)在你遇到的情况下，some_string 是一个 unicode 字符串，coding 是 gbk。由于你的 unicode 字符串里面包含 gbk 字符集里面没有的字符，Python 就会抛出一个 UnicodeEncodeError. 对于输出到文件中情况是类似的，Python2 的 open() 函数不会传入 encoding，以 ‘w’ 方式打开文件，如果写入 unicode 字符串，Python 会获取当前默认的编码，然后以此种编码把字符串写入文件。可惜的是，“默认编码”只是 Python 自己默认的，在 Objects/unicodeobject.c 中，用一个全局变量 unicode_default_encoding 来表示默认的编码： /* Default encoding to use and assume when NULL is passed as encoding parameter; it is initialized by _PyUnicode_Init(). ​ Always use the PyUnicode_SetDefaultEncoding() and​ PyUnicode_GetDefaultEncoding() APIs to access this global. static char unicode_default_encoding[100 + 1] = &quot;ascii&quot;;这个值在 Python 中有C接口（PyUnicode_SetDefaultEncoding）去改变，但可惜的是没有 Python 层的接口。所以在调用到类似 file.write(some_string) 的时候，首先会有这样的编码过程:codecs.encode(some_string, coding, errors=’restrict’)当你的 some_string 是一个 unicode 字符串，并且包含 ascii 字符串不存在的字符时，就会抛出一个 UnicodeEncodeError。 所以，为了解决这个问题，可以这么处理： (1) 在 Windows shell 下面: &gt;&gt;&gt; print some_string.encode(‘gbk’, errors=’ignore’) # replace 也可，只要不是 restrict(2) 在写入文件时，两种方法： a. 忽略不存在的字符，同(1) &gt;&gt;&gt; f = open(filename, ‘w’) &gt;&gt;&gt; f.write(some_string.encode(‘gbk’, errors=’ignore’) b. byte 方式写入： &gt;&gt;&gt; f = open(filename, ‘wb’) &gt;&gt;&gt; f.write(some_string.encode(‘utf-8’))​ a 会损失字符，b 不会。 来自http://www.newsmth.net/nForum/#!article/Python/124657 如果CMD命令行是gbk编码的，则输出的utf-8字符有些也显示不了 Win10 临时修改cmd命令行窗口UTF-8编码 只作用于当前打开的窗口 进入cmd窗口后，直接执行“chcp 65001”，执行完后，cmd的编码格式就是UTF-8 永远修改 Windows 控制台使用注册表永久修改编码问题方法一：1.在cmd中输入regedit进入注册表 2.找到HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe 3.新建一个 DWORD（32位值）,命名为CodePage，值设为65001 4.已有CodePage的话，修改它，改为十进制，65001 方法二：(亲测有效)1.新建一个cmd.reg注册表文件: 2.内容输入如下： 123456789Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe]&quot;CodePage&quot;=dword:0000fde9&quot;FontFamily&quot;=dword:00000036&quot;FontWeight&quot;=dword:00000190&quot;FaceName&quot;=&quot;Consolas&quot;&quot;ScreenBufferSize&quot;=dword:232900d2&quot;WindowSize&quot;=dword:002b00d2 3.双击运行","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Shell脚本基础","slug":"Shell脚本基础","date":"2018-11-08T04:19:49.000Z","updated":"2018-11-08T04:20:26.700Z","comments":true,"path":"2018/11/08/Shell脚本基础/","link":"","permalink":"https://nymrli.top/2018/11/08/Shell脚本基础/","excerpt":"","text":"Shell编写打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。 12#!/bin/bash#!/usr/bin/php “#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。 作为可执行程序12chmod +x test.sh./test.sh 注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。 变量定义变量12your_name=&quot;qinjx&quot;▲.变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。 使用变量使用一个定义过的变量，只要在变量名前面加美元符号即可，如： 123your_name=&quot;qinjx&quot;echo $your_nameecho $&#123;your_name&#125; 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： 123for skill in Ada Coffe Action Java; do echo &quot;I am good at $&#123;skill&#125;Script&quot;done 字符串字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了，哈哈），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。 单引号1str=&apos;this is a string&apos; 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行） 双引号12your_name=&apos;qinjx&apos;str=&quot;Hello, I know your are \\&quot;$your_name\\&quot;! \\n&quot; 双引号里可以有变量 双引号里可以出现转义字符 字符串操作拼接字符串12345your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;echo $greeting $greeting_1 获取字符串长度：12string=&quot;abcd&quot;echo $&#123;#string&#125; #输出：4 提取子字符串12string=&quot;alibaba is a great company&quot;echo $&#123;string:1:4&#125; #输出：liba 查找子字符串12string=&quot;alibaba is a great company&quot;echo `expr index &quot;$string&quot; is`#输出：3，这个语句的意思是：找出字母i在这名话中的位置，要在linux下运行，mac下会报错 流程控制和Java、PHP等语言不一样，sh的流程控制不可为空，如： 1234567&lt;?phpif (isset($_GET[&quot;q&quot;])) &#123; search(q);&#125;else &#123; //do nothing&#125; 在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。 还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下： 12ll /usr/bin/[-rwxr-xr-x. 1 root root 33408 6月 22 2012 /usr/bin/[ 正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0] if elseif1234567if conditionthen command1 command2 ... commandN fi 写成一行（适用于终端命令提示符）： 1if `ps -ef | grep ssh`; then echo hello; fi 末尾的fi就是if倒过来拼写，后面还会遇到类似的 if else123456789if conditionthen command1 command2 ... commandNelse commandfi if else-if else12345678if condition1then command1elif condition2 command2else commandNfi for whilefor在开篇的示例里演示过了： 1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 写成一行： 1for var in item1 item2 ... itemN; do command1; command2… done; C风格的for123456for (( EXP1; EXP2; EXP3 ))do command1 command2 command3done while1234while conditiondo commanddone 无限循环1234while :do commanddone 或者 1234while truedo commanddone 或者 1for (( ; ; )) until1234until conditiondo commanddone case123456789101112131415161718192021222324252627case &quot;$&#123;opt&#125;&quot; in &quot;Install-Puppet-Server&quot; ) install_master $1 exit ;; &quot;Install-Puppet-Client&quot; ) install_client $1 exit ;; &quot;Config-Puppet-Server&quot; ) config_puppet_master exit ;; &quot;Config-Puppet-Client&quot; ) config_puppet_client exit ;; &quot;Exit&quot; ) exit ;; * ) echo &quot;Bad option, please choose again&quot;esac case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break 学习自：Shell脚本编程30分钟入门","categories":[],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://nymrli.top/tags/Shell/"},{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"多媒体Au使用","slug":"多媒体Au使用","date":"2018-11-08T04:18:47.000Z","updated":"2018-11-08T04:19:20.150Z","comments":true,"path":"2018/11/08/多媒体Au使用/","link":"","permalink":"https://nymrli.top/2018/11/08/多媒体Au使用/","excerpt":"","text":"AU使用。 留人声、去伴奏 First. ▲侧边声道电平控制微弱，中置声道电平控制效果强。 ▲交叉渗透，越大伴奏声音越不明显 Second. 前面几排调低到满意。（童声高音频率范围为260-880Hz,低音频率范围为196-700Hz,女声高音频率范围为220-1.1KHz,低音频率范围为200-700KHz,男声高音频率范围为160-523KHz低音频率范围为80-358Hz. 国际通信标准制定为300Hz-3400Hz! ） 留伴奏、去人声 ···选中所有，菜单栏-收藏夹-移除人声","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"Au","slug":"Au","permalink":"https://nymrli.top/tags/Au/"}]},{"title":"定时执行Python脚本","slug":"定时执行Python脚本","date":"2018-11-07T09:51:16.000Z","updated":"2018-11-10T02:44:35.736Z","comments":true,"path":"2018/11/07/定时执行Python脚本/","link":"","permalink":"https://nymrli.top/2018/11/07/定时执行Python脚本/","excerpt":"","text":"定时任务执行python脚本使用linux的crontab1.开启crontab日志。crontab默认不开启日志，所以先开启定时任务的日志来查看 修改rsyslog服务，将/etc/rsyslog.d/50-default.conf 文件中的#cron.*前的 #删掉；用service rsyslog restart重启rsyslog服务： 2.写定时任务开启本用户的定时任务,即创建以本用户名为文件名的定时任务文件，位置在/var/spool/cron/crontabs/。crontab -e 定时任务语句格式为：执行周期+命令，周期有5个域，分别是 M: 分（0-59） H：时（0-23） D：天（1-31） m: 月（1-12） d: 周（0-6） //0为星期日 ▲每个域不加限制任意的话用* 所以命令语句就是 12*/5 * * * * cd /home/iris/; python aa.py#时间# #command ; commond 写完后需要重启cron服务:service cron restart 附录 常用周期格式: 每五分钟执行 */5 * * * * 每小时执行 0 * * * * 每天执行 0 0 * * * 每周执行 0 0 * * 0 每月执行 0 0 1 * * 每年执行 0 0 1 1 * 5 * * * * ls 指定每小时的第5分钟执行一次ls命令30 5 * * * ls 指定每天的 5:30 执行ls命令30 7 8 * * ls 指定每月8号的7：30分执行ls命令30 5 8 6 * ls 指定每年的6月8日5：30执行ls命令30 5 8 6 * ls 指定每年的6月8日5：30执行ls命令30 6 * * 0 ls 指定每星期日的6:30执行ls命令30 3 10,20 * * ls 每月10号及20号的3：30执行ls命令25 8-11 * * * ls 每天8-11点的第25分钟执行ls命令*/15 * * * * ls 每15分钟执行一次ls命令30 6 */10 * * ls 每个月中，每隔10天6:30执行一次ls命令22 4 * * * root run-parts /etc/cron.daily每天4：22以root身份执行/etc/cron.daily目录中的所有可执行文件，run-parts参数表示，执行后面目录中的所有可执行文件。 ~/Python_project/SeverChan_Nyedu使用python crontab设置linux定时任务 通过python 来写 crontab配置 123456789101112131415161718192021222324252627282930313233from crontab import CronTab# 创建当前用户的crontab，当然也可以创建其他用户的，但得有足够权限my_user_cron = CronTab(user=True)# 创建任务job = my_user_cron.new(command='echo date &gt;&gt; ~/time.log')# 设置任务执行周期，每两分钟执行一次job.setall('*/2 * * * *')# 当然还支持其他更人性化的设置方式，简单列举一些job.minute.during(5,50).every(5)job.hour.every(4)job.day.on(4, 5, 6)job.dow.on('SUN')job.dow.on('SUN', 'FRI')job.month.during('APR', 'NOV')job.setall(time(10, 2))job.setall(date(2000, 4, 2))job.setall(datetime(2000, 4, 2, 10, 2))# 同时可以给任务设置comment，这样就可以根据comment查询，很方便job.set_comment(\"time log job\")# 根据comment查询，当时返回值是一个生成器对象，不能直接根据返回值判断任务是否#存在，如果只是判断任务是否存在，可直接遍历my_user_cron.cronsiter = my_user_cron.find_comment('time log job')# 同时还支持根据command和执行周期查找，基本类似，不再列举# 任务的disable和enable， 默认enablejob.enable(False)job.enable()# 最后将crontab写入配置文件my_user_cron.write() python中的轻量级定时任务调度库：schedule提供博客python中的轻量级定时任务调度库：schedule","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"ServerChan+南邮教务处","slug":"ServerChan-南邮教务处","date":"2018-11-07T09:32:10.000Z","updated":"2018-11-10T01:57:47.887Z","comments":true,"path":"2018/11/07/ServerChan-南邮教务处/","link":"","permalink":"https://nymrli.top/2018/11/07/ServerChan-南邮教务处/","excerpt":"","text":"SeverChan_NyeduCrawl the infomation about competitons, when new infos comes, remind people on Wechat by ServerChan: 😍该程序通过爬取南邮教务处,将当前时间与最新时间进行匹配,如果是当日则通过ServerChan发送到本人的微信,提醒有新的竞赛. 完成笔记:1.关于lxml中etree.xpath()对于tbody的处理 该网页通过table对页面进行分布设置,其中table标签会自动生成tbody标签,如图..此时用xpath进行匹配的时候就不需要将tbody加上,否则匹配不到 布局&lt;Table&gt; 表格&lt;table&gt; 可以看到的是在Chrome调试助手里面,&lt;table&gt;下面都是会自动生成&lt;tbody&gt;标签的(一般tbody是浏览器自动产生的，一般情况要去掉),而我们再通过网页源码看看..==&gt;可以发现的是: &lt;table&gt;布局是没有&lt;tbody&gt;的,只有表格才有,所以这也是为什么用xpath()表格里必须加上tbody才能匹配,而table布局中不能加tbody的原因 123456789101112#布局获得内容for content in contentList: title = content.xpath('td/table/tr/td[1]/a/text()')[0] href = content.xpath('td/table/tr/td[1]/a/@href')[0] submittime = content.xpath('td/table/tr/td[2]/div/text()')[0]#表格if content.tag == 'table': tabletitle = content.xpath('tbody/tr[1]/td') # 表格头 tabletitleList = map(lambda x: x.xpath('string(.)'), tabletitle) tablehead = '|' + '|'.join(tabletitleList) + '|' tableover = '|' + ':---:|' * len(tabletitle) # 居中显示 2.requests.get()获得的response的编码问题123html = requests.get('http://jwc.njupt.edu.cn/1594/list.htm',headers = headers)html.encoding = 'utf-8'#Requests库的自身编码为: r.encoding = ‘ISO-8859-1’ Github地址:Freedomisgood/SeverChan_Nyedu","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"高科GSWIFI江苏破解教程","slug":"高科GSWIFI江苏破解教程","date":"2018-11-04T02:06:34.000Z","updated":"2018-12-18T11:28:14.325Z","comments":true,"path":"2018/11/04/高科GSWIFI江苏破解教程/","link":"","permalink":"https://nymrli.top/2018/11/04/高科GSWIFI江苏破解教程/","excerpt":"","text":"1.重置路由器设置 为了以防之前其他人已经设置过某些东西,可能会影响到之后的使用，所以干脆直接重置。 2.连接路由器电源,不用插任何的wan口或者lan口 P.S.如果第二步,手机和电脑无法直接通过IP地址进入管理界面的话,可以考虑将 网线一头插入2号口,一头插入电脑的插口 , 然后再通过IP地址进入管理界面 3.登录路由器管理界面▲注意： 大多数路由器的管理界面IP地址为 192.168.1.1或者192.168.100.1,虽然高科路由器后面贴纸上说明的IP地址是192.168.8.1,但是那个不是初始的IP,需要自己设置到192.168.8.1. 如下是我已经修改好的IP为192.168.8.1的登录界面,默认密码为admin,登录后选择不保存密码 4.进入管理界面后先观察 首先是要观察软件版本与 GSWIFI 公众号中的最新能用的版本进行匹配,如果是一样的话就不需要升级系统固件,如果当前软件版本比较低就可能无法使用. 其次,由于没接网线,所以网线状态是WAN口未连接 5.修改配置修改WAN口设置 如何查看手机MAC地址说明:由于我使用的是英文系统…可能手机界面有点不同 1.进入WLAN 2.进入更多设置 最下面的MAC address就是 6.WIFI设置2.4G 7.LAN口设置 该步之后,等30s配置完成后,你会无法进入192.168.1.1,页面也会无响应,此时访问192.168.8.1重进管理界面 8.开始连接网线(查看网线状态)▲▲.由于该路由器的WAN口被商家调到了3号LAN口,我也被这步坑了挺久..所以上述步骤都完成以后,将网线插入路由器的3号LAN口,再登录管理界面,此时应该就能看到这样的界面了.. (p.s.或许你的路由器就是WAN口没改也说不定,反正如果没有效果的话,每个端口都试一下就是了) 能够正常显示这几个,则路由器已设置完成. 9.使用GSWIFI小助手对路由器再次设置 ▲注意,使用客服提供的APP,网盘链接在附录中 按照我们的教程来,IP地址填为192.168.8.1,然后按下”开始联网“,之后会有4步,这个过程中WIFI会不断的掉线,需要自己不断重连自己的WIFI(“Hello“),等到4步完成后就可以开始用掌上大学连上WIFI后一键上网了 完成图如下 10.使用掌上大学一键上网 教程到此就结束了,按照上述步骤应该就能完成高科GSWIFI路由器的破解上网了… 附录:GSWIFI小助手江苏版:网盘:https://pan.baidu.com/share/init?surl=vwza9BJd9kjjMKH6f3ek3g 提取码:svdg 更新系统固件找到GSWIFI公众号: 选择系统升级 然后查看升级教程 和 1082正式版系统(目前最新的系统固件)，然后根据里面提供的网盘将文件下载下来 下载后===&gt;解压===&gt;进入管理界面===&gt;系统升级===&gt;选择文件===&gt;刷写固件===&gt;执行（其中过程千万不能关闭电源或是乱动，就算按错了，等2-3分钟好了以后再重新刷写也无妨，但是千万不能断电源）","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"WSGI uWSGI uwsgi及nginx说明","slug":"WSGI-uWSGI-uwsgi及nginx说明","date":"2018-11-02T07:50:12.000Z","updated":"2018-11-02T08:16:15.520Z","comments":true,"path":"2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/","link":"","permalink":"https://nymrli.top/2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/","excerpt":"","text":"客户端发出请求==&gt;服务器接受、处理请求与响应 的过程示意图 1. WSGI： 全称是Web Server Gateway Interface(服务器网关接口)。WSGI不是服务器，python模块，框架，API或者任何软件，只是一种规范( 是一个Web服务器（如nginx）与应用服务器（如uWSGI）通信的一种规范（协议）==&gt; 可以理解为服务器与应用程序通信的接口规范要求)，描述web server如何与web application通信的规范。server和application的规范在PEP 3333中有具体描述。因为WSGI没有官方的实现, 所以WSGI更像一个协议，只要遵照这些协议，都可以在任何服务器(Server)上运行 2.uwsgi： 与WSGI一样是一种通信协议，是uWSGI服务器的独占协议，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种不同的协议。该协议据说性能非常高，是fcgi协议的10倍快;而且内存占用率低，为mod_wsgi的一半左右，同时它还支持多应用的管理及应用的性能监控 3.uWSGI： 是一个web服务器，而且也可以当做中间件。它实现了WSGI协议、uwsgi协议、http协议等。在生产环境中使用uWSGI作为python web的服务器,可以用来托管 Python WSGI应用。它具有应用服务器，代理，进程管理及应用监控等功能(但可以把看作是一个应用程序，帮助我们实现WSGI协议)，这样我们可以不再关注网络通信的底层实现，将精力更多放在处理HTTP请求数据，返回HTML。 4.uWSGI+nginx 综上所述可以看出uWSGI可以直接当做服务器，而为了进一步的并发提升就需要加上nginx(提高负载均衡) ▲.当uWSGI+nginx使用时，nginx作为web服务器，而uWSGI作为中间件(这边不一定正确,个人理解) uWSGI不足的地方: uWIGS也可以返回静态文件(css,js,img…)，但是很笨拙，所以更好的做法是用反向代理服务器（比如Nginx）来处理此类请求，减轻应用服务器的负载，获得更好的性能。 利用uWIGS可以是我们的web应用得到更强的并发能力，uWIGS也可以返回静态文件(css,js,img…)，但是很笨拙，一般静态文件都交由Nginx进行传输，所以配置中一般不配置static-map,如果直接由uWIGS接受HTTP请求则需要设置http:xxxx，如果只需要与反向代理服务器进行交互则只需要接受socket，uWIGS与Nginx交互相当于两个进程间交互，一般使用的是.sock文件或者指定端口接受socket。指定端口时再使用浏览器访问相应端口，uWIGS会提示skip，跳过该HTTP请求。 同时还有的是uWSGI本身的负载均衡没有nginx牛逼。所以阉割掉不用。 5.Nginx是一个Http和反向代理服务器 什么是反向代理服务器呢？ ▲正向的就是由浏览器主动的想代理服务器发出请求，经代理服务器做出处理后再转给目标服务器▲反向的就是不管浏览器同不同意，请求都会经过代理服务器处理再发给目标服务器 这其中的区别就是必须经过Nginx反向代理服务器，这就有了使用Nginx的几个好处： 安全：不管什么请求都要经过代理服务器，这样就避免了外部程序直接攻击web服务器 负载均衡：根据请求情况和服务器负载情况，将请求分配给不同的web服务器，保证服务器性能 提高web服务器的IO性能：这个我也没看懂，总结来说就是请求从客户端传到web服务器是需要时间的，传递多长时间就会让这个进程阻塞多长时间，而通过反向代理，就可以在反向代理这完整接受请求，然后再传给web服务器，从而保证服务器性能，而且有的一些简单的事情（比如静态文件）可以直接由反向代理处理，不经过web服务器 总结","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"apt-get update无法连接","slug":"apt-get-update无法连接","date":"2018-11-02T05:21:45.000Z","updated":"2018-11-02T05:44:44.227Z","comments":true,"path":"2018/11/02/apt-get-update无法连接/","link":"","permalink":"https://nymrli.top/2018/11/02/apt-get-update无法连接/","excerpt":"","text":"出现的问题原因是在apt-get update时遇到了Unable to connect to 代理，（由于apt-get update一直显示无法连接172.17.18.141百度后发现这并不是个特殊的IP,而且也可以ping到百度）于是想到是否使用了代理。 apt代理的设置：临时方法export http_proxy=http://10.3.0.1:80 长久方法(1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。) Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;; 保存apt.conf文件。 (2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件) 建立文件 vim proxyfile Acquire::http::proxy &quot;http://10.3.0.1:80&quot;; Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;; Acquire::https::proxy &quot;http://10.3.0.1:80&quot;; 使用时sudo apt-get install xxx -c proxyfile (2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 ) 在您的.bashrc文件末尾添加如下内容export http_proxy=http://用户名:密码@地址:端口/export https_proxy=http://用户名:密码@地址:端口/ export ftp_proxy=http://用户名:密码@地址:端口/ 附上一篇ubuntu设置代理的文章:ubuntu设置代理 Ubuntu下让终端走SS代理的方法Ubuntu下让终端走SS代理需要第三方软件的帮助，即privoxy。privoxy 是非快取式 (non-caching) 的网页代理伺服器，具有进阶的过滤能力，可强化隐私权，还可以修改网页资料、管理 HTTP cookies、去除广告等。 安装 privoxysudo apt-get install privoxy 安装完成后在 /etc/privoxy 目录下可以找到配置文件 config。 配置 privoxy一般地，改配置前应该备份配置。 mv /etc/privoxy/config /etc/privoxy/config.back 然后打开 config 文件，找到listen-address那一行，修改值为 privoxy 监听的地址，一般使用默认。 然后再找到forward-socks5那一行，去掉注释，值为SS代理监听的地址。 让终端走SS代理,修改配置后，重启 privoxy。 sudo /etc/init.d/privoxy restart 然后在终端下添加 http 代理。 export http_proxy=”127.0.0.1:8118” export https_proxy=”127.0.0.1:8118” 然后就可以愉快的用终端翻墙了。 原文：https://blog.csdn.net/tailgo/article/details/52075643","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"Windows控制台Cmd乱码（及永久修改编码）解决方法","slug":"Windows-控制台Cmd乱码（及永久修改编码）解决方法","date":"2018-10-28T08:42:20.000Z","updated":"2018-10-28T08:47:00.882Z","comments":true,"path":"2018/10/28/Windows-控制台Cmd乱码（及永久修改编码）解决方法/","link":"","permalink":"https://nymrli.top/2018/10/28/Windows-控制台Cmd乱码（及永久修改编码）解决方法/","excerpt":"","text":"我本机的系统环境：`OS Name: Microsoft Windows 10 家庭中文版 Windows 控制台Cmd乱码的解决办法(一次性)在cmd中输入 CHCP 65001 注：CHCP是一个计算机指令，能够显示或设置活动代码页编号。 代码页 描述 65001 UTF-8代码页 950 繁体中文 936 简体中文默认的GBK 437 MS-DOS 美国英语 但是通过CHCP设置编码是治标不治本的,想永久的更改cmd编码值需要修改注册表 Windows 控制台Cmd乱码的解决办法(永久性)方法一：1.在cmd中输入regedit进入注册表 2.找到HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe 3.新建一个 DWORD（32位值）,命名为CodePage，值设为65001 4.已有CodePage的话，修改它，改为十进制，65001 方法二：(亲测有效)1.新建一个cmd.reg注册表文件: 2.内容输入如下： 123456789Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe]&quot;CodePage&quot;=dword:0000fde9&quot;FontFamily&quot;=dword:00000036&quot;FontWeight&quot;=dword:00000190&quot;FaceName&quot;=&quot;Consolas&quot;&quot;ScreenBufferSize&quot;=dword:232900d2&quot;WindowSize&quot;=dword:002b00d2 3.双击运行","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"JS正则及常用方法函数总结","slug":"JS正则及常用方法函数总结","date":"2018-10-25T03:55:20.000Z","updated":"2018-11-13T15:03:03.619Z","comments":true,"path":"2018/10/25/JS正则及常用方法函数总结/","link":"","permalink":"https://nymrli.top/2018/10/25/JS正则及常用方法函数总结/","excerpt":"","text":"JS正则及常用方法函数总结 正则表达式作为一种匹配处理字符串的利器在很多语言中都得到了广泛实现和应用，web开发本质上是处理字符串（服务端接受请求处理后拼接字符串作为响应，这在早期的CGI编程中最明显，然后客户端解析字符串进行渲染和执行），所以说，JS作为一门常用于web开发的语言，必然要具备正则这种强大的特性，本文将对JS中的正则用法及常用函数进行一番总结。 1.正则对象及其属性首先正则对象是JS中内置的一个对象，好比Array以及Math一样，不需要第三方库的支持，通常我们采取两种方式来定义一个正则对象. 1）构造函数方式12345var reg=new RegExp('abc','gi');/*这里，第一个参数是正则的内容，第二个参数是修饰符，修饰符通常有三种，i,g,m，i表示的含义是忽略大小写进行匹配，g表示全局匹配即匹配到第一个之后不停止继续匹配，m表示多行匹配即遇到换行后不停止匹配继续直到被匹配字符串结束。*/ /i (忽略大小写) /g (全文查找出现的所有匹配字符,否则只匹配第一个出现的) /m (多行查找) /gi(全文查找、忽略大小写) /ig(全文查找、忽略大小写) 2）字面量方式123456var reg=/abc/gi;consolo.dir(reg);/**▲.两个斜杠之间的是定义的正则内容*，最后一个斜杠之后的是修饰符，这种方式比第一种简单高效，所以通常使用第二种方式来定义正则。*/ 2.属性在控制台中打印一个正则对象如下： global属性，该属性为布尔类型，用来表示该正则是否是全局匹配， ignoreCase属性，布尔类型，用来指示是否忽略大小写， lastIndex为number类型，用来表示上次匹配成功的位置， multiline，布尔类型，用来表示是否是多行匹配，source，string类型，用来表示正则的内容。 lastIndex 属性表示的索引处为目标字符串匹配（并且不会尝试从后续索引匹配）,你不能直接更改这个属性，它是只读的。可以通过^ unicode标志开启了多种 Unicode 相关的特性。使用 “u” 标志，任何 Unicode 代码点的转义都会被解释。 3.方法通常对于一个正则对象来讲，我们能够使用的方法基本上有三个，即regObj.test,regObj.exec及regObj.compile 1）test方法该方法用来测试某个字符串是否与正则匹配，匹配就返回true，否则返回false。该方法接受一个字符串作为参数 123 var reg=/boy(s)?\\s+and\\s+girl(s)?/gi; console.log(reg.test('boy and girl'));//==&gt;true 2)compile方法该方法的作用是能够对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，适合于对一个正则对象(模式)多次调用的情况下，如果对一个正则只使用一两次，那么该方法没有特别显著的效应。 接受的参数也是一个正则。 1234567var reg=/[abc]/gi; console.log(reg.test('a')); //==&gt;true reg=/[cde]/gi; console.log(reg.test('a')); //==&gt;false reg.compile(reg); console.log(reg.test('a')); //==&gt;false//被编译的正则和没有编译的正则在测试结果上没有任何区别，只是多次调用的效率上会更高一些。 3）exec方法该方法属于一个比较复杂的方法，它接受一个字符串，返回的是一个数组，数组中第0个元素是匹配的子字符串，第二个元素是正则中的第一个子分组匹配的结果（如果有子分组，即正则中存在用圆括号括起来的分组），第三个是正则中第二个子分组匹配的结果（如果有第二个子分组）…以此类推，如果没有正则子分组，那么该数组长度仅仅为1，就是匹配到的那个子字符串。同时，返回的这个数组同时还是一个对象，它拥有两个属性，分别为index表示当前匹配到的子字符串所处的位置，input属性表示被匹配的原始字符串。最后，该方法中的正则对象如果不是全局匹配，即没有g修饰符，则每次调用只会从字符串开头处匹配第一个结果，且每次调用结果都是一样的。只有指定为全局匹配，才能够按照从左往右依次去匹配，每次调用匹配一个结果，正则对象的lastIndex属性前进到本次匹配的末尾位置，下回再调用的时候，会从lastIndex处开始匹配而不是从头匹配。 12345678var reg=/(\\w)l(\\w)/g;var str=\"hello world hello 123 hello programmer hello test\";var arr=reg.exec(str); while(arr)&#123; console.dir(arr); console.log(\"lastIndex:\"+reg.lastIndex); arr=reg.exec(str); &#125; 结果如下： 12345678910111213141516//非全局匹配代码：var reg=/(\\w)l(\\w)/; var str=\"hello world hello 123 hello programmer hello test\"; var arr=reg.exec(str); var i=0; while(arr)&#123; i++; if(i&lt;=4)&#123; console.dir(arr); console.log(\"lastIndex:\"+reg.lastIndex); arr=reg.exec(str); &#125; else&#123; break; &#125; &#125; 这个时候每次调用的结果都一样，lastIndex根本没有发生变化。 以上就是正则对象及其方法，其实在使用的过程中，JS中的String类型的对象也拥有一些和正则相关的方法，如下： String类型的对象的正则方法1）search方法该方法是string对象的一个方法，用来查找第一次匹配的子字符串的位置，如果找到就返回一个number类型的index值，否则返回-1,它返回的只是第一次匹配的位置。 它接受一个正则或者子字符串为参数，这里我们只讨论正则的情况。 123var str=\"hello world\";console.log(str.search(/o/g));//输出结果为4，可以看到尽管具有多个匹配结果而且也声明为全局匹配，但是还是返回的是第一个匹配到的子串的位置； 2）replace方法该方法用来将字符串中的某些子串替换为需要的内容，接受两个参数，第一个参数可以为正则或者子字符串，表示匹配需要被替换的内容，第二个参数为被替换的新的子字符串。如果声明为全局匹配则会替换所有结果，否则只替换第一个匹配到的结果。 1234var str=&quot;hello world,hello test&quot;;console.log(str.replace(/hello/g,&apos;hi&apos;));//结果为hi world,hi test//如果将上面代码中的g修饰符去掉，则返回的结果是hi world,hello test 3）split方法该方法主要用来将一个字符串拆分成一个数组，它接受一个正则或者子字符（串）作为参数，返回一个数组，简单情况下，我们不需要使用正则，只有在字符串拆分规则不统一的情况下才需要使用正则，如下： 12345var str=\"how|old*are you\";var arr=str.split(/\\||\\*|\\s+/);// 以|、*、多项空格为分隔符// \\s 匹配任何空白字符,包括空格、制表符、换页符等等console.log(arr); 这里需要将str拆分为单词数组，由于每个单词之间存在不一样的分隔符，我们采取正则来匹配，结果如下： 4）match方法该方法接受一个正则作为参数，用来匹配一个字符串，它的输出结果在不是全局匹配的情况下和exec方法的结果一致即一个数组并带有额外的属性，如果采用全局匹配，则不返回任何和其被匹配字符串相关的信息，只返回匹配的结果。 12345678910111213141516//非全局匹配代码：var reg2=/(\\w)s(\\w)/;var str2=\"ws1esr\";var result=str2.match(reg2);var i=0; while(result)&#123; i++; if(i&lt;=4)&#123; console.dir(result); console.log(\"lastIndex:\"+reg2.lastIndex); &#125; else&#123; break; &#125; &#125;//非全局匹配下，结果和exec非全局匹配方法返回的完全一致， 12345//全局匹配代码：var reg3=/(\\w)s(\\w)/g;var str4=\"ws1estqsa\";console.dir(str4.match(reg3));//可以看到，在全局匹配下的时候，它不同于exec方法，它会一次性将所有匹配结果以数组形式返回，且这个数组没有其他属性用来指向被匹配字符串的信息，而exec方法在全局匹配下每次返回的依然是本次匹配的结果数组，且这个数组中只包含本次匹配信息，同时又拥有指向被匹配字符串的信息，即match方法在全局匹配下一次性返回了所有匹配结果，而exec在全局匹配下返回的依然是当次匹配结果。","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://nymrli.top/tags/JavaScript/"}]},{"title":"Sublime Text3 Python虚拟环境（补充）——解决控制台中文乱码情况","slug":"Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况","date":"2018-10-24T10:52:35.000Z","updated":"2018-10-24T10:53:11.813Z","comments":true,"path":"2018/10/24/Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况/","link":"","permalink":"https://nymrli.top/2018/10/24/Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况/","excerpt":"","text":"转自：edwardgui的博客 正常的用python编译控制台是不会出现乱码的，但是在使用虚拟环境的情况下中文总是乱码，一开始以为是windows控制台编码的问题。找了挺久后发现是python+virtualenv编译系统的问题，现在我就带领大家解决这个问题。 ▲注：Windows环境下 首先看下是否已经安装了Virtualenv package插件，如果没有，则Ctrl+Shift+P，install Package,输入Virtualenv安装。 找到插件安装的地方：C:\\Users{Username}\\AppData\\Roaming\\Sublime Text 3\\Installed Packages ==&gt;注意改变一下Username 解压Virtualenv.sublime-package文件，可以通过先添加后缀.zip变为Virtualenv.sublime-package.zip再解压 包含文件如下：修改Python + Virtualenv.sublime-build文件， 增加一行：&quot;env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf8&quot;},使其变成1234567&#123;&quot;env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf8&quot;&#125;,&quot;target&quot;: &quot;virtualenv_exec&quot;,&quot;shell_cmd&quot;: &quot;python -u \\&quot;$file\\&quot;&quot;,&quot;file_regex&quot;: &quot;^[ ]*File \\&quot;(...*?)\\&quot;, line ([0-9]*)&quot;,&quot;selector&quot;: &quot;source.python&quot;&#125; 然后保存，再把该文件打包为Virtualenv.sublime-package.zip再去掉后缀，就大功告成了。 最后打开Sublime Text3使用Python + Virtualenv 编译，就能看到中文正常输出啦！","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"}]},{"title":"Python爬虫知识点——将Cookie保存到本地的多种方法介绍","slug":"Python爬虫知识点——将Cookie保存到本地的多种方法介绍","date":"2018-10-24T10:43:34.000Z","updated":"2018-10-24T10:45:29.249Z","comments":true,"path":"2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/","excerpt":"","text":"方法一：urllib2 结合cookielib及urllib2，Python2时期比较常用的方法，年代比较久远了。个人觉得太麻烦，改用requests. ▲需要注意的是cookielib在python3中已经改成了http.cookiejar 1234567891011121314151617181920212223242526272829303132333435#该方法本人未测试import urllib2import cookielib#将cookie保存在文件中def saveCookie(): #设置保存cookie的文件 filename = &apos;cookie.txt&apos; #声明一个MozillaCookieJar对象来保存cookie，之后写入文件 cookie = cookielib.MozillaCookieJar(filename) #创建cookie处理器 handler = urllib2.HTTPCookieProcessor(cookie) #构建opener opener = urllib2.build_opener(handler) #创建请求 res = opener.open(&apos;http://www.baidu.com&apos;) #保存cookie到文件 #ignore_discard的意思是即使cookies将被丢弃也将它保存下来 #ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入 cookie.save(ignore_discard=True,ignore_expires=True)#从文件中获取cookie并且访问(我们通过这个方法就可以打开保存在本地的cookie来模拟登录)def getCookie(): #创建一个MozillaCookieJar对象 cookie = cookielib.MozillaCookieJar() #从文件中的读取cookie内容到变量 cookie.load(&apos;cookie.txt&apos;,ignore_discard=True,ignore_expires=True) #打印cookie内容,证明获取cookie成功 for item in cookie: print &apos;name:&apos; + item.name + &apos;-value:&apos; + item.value #利用获取到的cookie创建一个opener handler = urllib2.HTTPCookieProcessor(cookie) opener = urllib2.build_opener(handler) res = opener.open(&apos;http://www.baidu.com&apos;) print res.read() 方法二: 使用requests.cookie 读取cookies在这里我用的是LWPCookieJar保存在txt文件中，还有个是MozillaCookieJar，都是由FileCookieJar 派生而来，实现了save()方法，而FileCookieJar 没有实现save() MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。 LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。 123456789#实例化一个LWPCookieJar对象load_cookiejar = cookielib.LWPCookieJar()#从文件中加载cookies(LWP格式)load_cookiejar.load(&apos;cookies.txt&apos;, ignore_discard=True, ignore_expires=True)#工具方法转换成字典load_cookies = requests.utils.dict_from_cookiejar(load_cookiejar)#工具方法将字典转换成RequestsCookieJar，赋值给session的cookies.self.session.cookies = requests.utils.cookiejar_from_dict(load_cookies) 存储cookies将cookies转换成LWP格式然后保存为文本格式 123456789#实例化一个LWPcookiejar对象new_cookie_jar = cookielib.LWPCookieJar(&apos;cookie.txt&apos;)#将转换成字典格式的RequestsCookieJar（这里我用字典推导手动转的）保存到LWPcookiejar中===&gt;RequestsCookieJar没有实现save()方法requests.utils.cookiejar_from_dict(&#123;c.name: c.value for c in self.session.cookies&#125;, new_cookie_jar)#保存到本地文件new_cookie_jar.save(&apos;cookies.txt&apos;, ignore_discard=True, ignore_expires=True) 方法三: 将cookie字典弄成字典形式然后pickle或者json写入文件中 存储cookie12345678import requests,json,pprints = requests.session()s.headers = &#123;...&#125;a = s.get(&quot;https://www.baidu.com&quot;)cookies = requests.utils.dict_from_cookiejar(s.cookies)with open(&quot;.\\\\cook.txt&quot;, &quot;w&quot;) as fp: json.dump(cookies, fp)pprint.pprint(cookies,width=5) 读取cookie123with open(&quot;.\\cook.txt&quot;, &quot;w&quot;) as fp: load_cookies=son.load(fp)session.cookie = requests.utils.cookiejar_from_dict(load_cookies) 方法四: 将requests.cookie设置为LWPCookieJar、或MozillaCookieJar保存 123456session = requests.Session()#创建个 LWPCookieJar对象session.cookies = LWPCookieJar(filename=&apos;cook.txt&apos;)s.get(&apos;https://www.baidu.com/&apos;,headers=headers)session.cookies.save(ignore_discard=True, ignore_expires=True)#如果save()时没有写filename参数，则默认为实例化LWPCookieJar时给的文件名 save()方法的两个重要参数 ignore_discard: save even cookies set to be discarded. ignore_expires: save even cookies that have expired.The file is overwritten if it already exists ignore_discard的意思是即使cookies将被丢弃也将它保存下来，ignore_expires的意思是如果cookies已经过期也将它保存并且文件已存在时将覆盖 总结方法二和方法三可以看出，就是要将cookie转换成然后save() 简单介绍下cookielib模块作用，科普下实现cookie知识 python3中将cookielib模块改为了http.cookiejar 12345678910&gt; cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。例如可以利用本模块 的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送。coiokielib模块用到的对象主要有下面几个：CookieJar、 FileCookieJar、MozillaCookieJar、LWPCookieJar。其中他们的关系如下：&gt; &gt; CookieJar &gt; &gt; | &gt; &gt; FileCookieJar &gt; &gt; / \\ &gt; MozillaCookieJar LWPCookieJar","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Python爬虫知识点——Session与Cookie","slug":"Python爬虫知识点——Session与Cookie","date":"2018-10-24T10:36:56.000Z","updated":"2018-10-24T10:41:34.630Z","comments":true,"path":"2018/10/24/Python爬虫知识点——Session与Cookie/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——Session与Cookie/","excerpt":"","text":"Session和Cookie： Cookie：保持登录后的认证状态而保存在本地的数据 session:用cookie来标记用户，cookie携带了会话ID消息，通过检查cookie就能找到会话(session) cookie与session相互配合，一个处于客户端，一个处于服务端，两者相互协作。 会话cookie和持久cookie 会话Cookie：把cookie放在浏览器内存里，浏览器关闭后失效。 持久Cookie：保存cookie到客户端的硬盘中，下次继续使用。 由Cookie的Max Age和Expires决定了过期的时间。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——代理","slug":"Python爬虫知识点——代理","date":"2018-10-24T10:36:28.000Z","updated":"2018-10-24T10:41:27.406Z","comments":true,"path":"2018/10/24/Python爬虫知识点——代理/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——代理/","excerpt":"","text":"代理基本原理代理实际上指代理服务器。功能是代理 网络用户去取得网络信息，是网络信息的中转站。 正常的请求过程为：发送请求给服务器===&gt;web服务器吧响应传回 设置代理服务器后：==&gt;向代理服务器发送请求==&gt;请求发送给代理服务器==&gt;再由代理服务器发送web服务器==&gt;由代理服务器把web服务器返回的响应转发给本机 作用突破自身IP访问限制，访问些平时不能访问的站点。 访问一些单位或团体内部资源:比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。 提高访问速度:通常代理服务器都设置-一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息传给用户，以提高访问速度。 隐藏真实IP:上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP,防止自身的IP被封锁。 代理分类根据代理的协议，代理可以分为如下类别。 FTP代理服务器: 主要用于访问FTP服务器，一般有上传、 下载以及缓存功能，端口一般为 21、2121等。 HTTP代理服务器:主要用于访问网页，一般有内容过滤和缓存功能，端口一般为808080、3128 等。 SSL/TLS代理:主要用于访同加密网站，般有 SsL 或TLS 加密功能(最高支持128位加密强度)，端口一般为443。 RTSP代理:主要用于访问Real流媒体服务器，一般有缓存功能， 端口般为554。 Telnet代理: 主要用于tenei远程控制黑客人侵计算机时常用于隐藏身份)，端口一般为23 POP3/SMTP代理:主要用于POP3/SMTP方式收发邮件，一般有缓存功能，端口-般为1025.口SOCKS代理:只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般 有 存功能，端口一般为1080。SOCKS代理协议又分为SOCKS4和SOCKS5,前者只支持TCP而后者支持TCP和UDP，还支持各种身份验证机制、服务器端域名解析等。简单来说SOCKS4能做到的SOCKS5都可以做到，但SOCKSS能做到的SOCKS4不一定能做到。 2.根据匿名程度区分 根据代理的匿名程度，代理可以分为如下类别。 高度匿名代理：会将数据包原封不动地转发，在服务端看来就好像真的是一 个普通客户端访问，而记录的IP是代理服务器的IP。 普通匿名代理：会在数据包上做一些改动， 服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实IP。代理服务器通常会加人的HTTP头有HTTP_VIA和HTTP_X_FORWARDED_FOR. 透明代理：不但改动了数据包，还会告诉服务器客户端的真实IP。这种代理除了能用缓存技术调高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。 间谍代理：指组织或个人创建的用于记录用户传输的数据， 然后进行研究、监控等目的代理服务器。 常用代理设置 网上的免费代理 付费的代理服务 ADSL拨号","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——请求","slug":"Python爬虫知识点——请求","date":"2018-10-24T10:36:21.000Z","updated":"2018-10-24T10:40:33.145Z","comments":true,"path":"2018/10/24/Python爬虫知识点——请求/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——请求/","excerpt":"","text":"请求 :请求方法、请求网址、请求头、请求体 请求方法： 常见的为:GET、POST GET与POST主要区别： GET请求参数包含在URL，可从URL中看出。POST请求的URL不包含参数，都是通过表单的形式传输的，包含在请求体中 GET请求提交的数据最多只有1024字节，POST无限制 其他还有HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE 请求的网址： 即URL，我们想要请求的资源 请求头：用来说明服务器要使用的附加信息，比较总要的有Cookie、Referer、User-Agent等。 Accept:请求报头域，用于指定客户端可接受哪些类型的信息。 Accept-Language:指定客户端可接受的语言类型。 Accept-Encoding:指定客户端可接受的内容编码。 Host:用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位 置。从HTTP1.1版本开始，请求必须包含此内容。 Cookie:也常用复数形式Cookies, 是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输人用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies 并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。 Referer:此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。 User-Agent: 简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等消息。在做爬虫时加上此信息，可以伪装成浏览器；如果不加，很可能被识别出为爬虫 Content-Type:也叫互联网媒体类型( Intermet Media Type)或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。更多对应关系可以查看此对表:http://tool.oschina.net/commons 文件扩展名 Content-Type(Mime-Type) .html、 .htx 、 .htm text/html .gif image/gif .json application/json ​ Content-Type与POST提交数据方式的关系 Content-Type 提交数据的方式 appication/x-www-urlencodeed 表单数据 multipart/form-data 表单文件上传 applicatiobn/json 序列化json数据 text/html XML数据 如果构造POST请求，需要使用正确的Content-Type，不然可能导致POST提交后无法正常响应 ==&gt;因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。 请求体： 请求体一般承载的内容是POST请求中的表单数据，而对GET请求，请求体则为空。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——响应","slug":"Python爬虫知识点——响应","date":"2018-10-24T10:36:17.000Z","updated":"2018-10-24T10:42:19.208Z","comments":true,"path":"2018/10/24/Python爬虫知识点——响应/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——响应/","excerpt":"","text":"响应：响应状态码、响应头、响应体 响应状态码：表2-3常见的错误代码及错误原因 状态码 说明 详情 100 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换。 200 成功 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 201 已创建 请求成功并且服务器创建了新的资源。 202 已接受 服务器已接受请求，但尚未处理。 203 非授权信息 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 无内容 服务器成功处理了请求，但没有返回任何内容。 205 重置内容 服务器成功处理了请求，但没有返回任何内容。 206 部分内容 服务器成功处理了部分 GET 请求。 300 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 查看其他位置 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 未修改 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 305 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307 临时重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 400 错误请求 服务器不理解请求的语法。 401 未授权 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 禁止 服务器拒绝请求。 404 未找到 服务器找不到请求的网页。 405 方法禁用 禁用请求中指定的方法。 406 不接受 无法使用请求的内容特性响应请求的网页。 407 需要代理授权 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 请求超时 服务器等候请求时发生超时。 409 冲突 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。 410 已删除 如果请求的资源已永久删除，服务器就会返回此响应。 411 需要有效长度 服务器不接受不含有效内容长度标头字段的请求。 412 未满足前提条件 服务器未满足请求者在请求中设置的其中一个前提条件。 413 请求实体过大 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 请求的 URI 过长 请求的 URI（通常为网址）过长，服务器无法处理。 415 不支持的媒体类型 请求的格式不受请求页面的支持。 416 请求范围不符合要求 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 未满足期望值 服务器未满足”期望”请求标头字段的要求。 500 服务器内部错误 服务器遇到错误，无法完成请求。 501 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502 错误网关 服务器作为网关或代理，从上游服务器收到无效响应。 503 服务不可用 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504 网关超时 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 HTTP 版本不受支持 服务器不支持请求中所用的 HTTP 协议版本。 响应头 响应头包含了服务器对请求的应答信息，如Cmene-Type. Serve. Set-cookie等。 下面简要说有 一些常用的头信息。 Date:标识响应产生的时间。 Last-Modifed:指定资源的最后修改时间。 公有地会 Content-Encoding:指定响应内容的编码。 Server:包含服务器的信息，比如名称、版本号等。 Content-Type:文档类型，指定返回的数据类型是什么，如texthtmI代表返回HTML文档， application/x-javascript则代表返回JavaScript文件，imagefjpeg 则代表返回图片。 Set-Cookie:设置Cookies。 响应头中的Set-Cookie 告诉浏览器需要将此内容放在Cooke 中，下次请求携带Cookies请求。 Expires:指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。立 果再次访问时，就可以直接从缓存中加载，降低服务器负载，编短加载时间。 响应体最重要的当属响应体的内容了。 响应的正文数据都在响应体中，比如请求网页时，它的响应体就 是网页的HTML代码:请求一张图片时， 它的响应体就是图片的二进制数据。我们做爬虫请求后主 要解析的内容就是响应体。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——爬虫的基本原理","slug":"Python爬虫知识点——爬虫的基本原理","date":"2018-10-24T10:36:10.000Z","updated":"2018-10-24T10:42:36.885Z","comments":true,"path":"2018/10/24/Python爬虫知识点——爬虫的基本原理/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——爬虫的基本原理/","excerpt":"","text":"爬虫的基本原理 爬虫就是获取网页并提取和保存信息的自动化程序 获取网页：获取网页就是获取网页的源码，只要把源码获取下来，就可以从中提取想要的消息 爬虫的流程：想网站的服务器发送一个请求，返回的响应体就是网页的源代码。 ​ ==&gt;1,构造请求发送给服务器===&gt;2.接受响应并解析 提取信息：通过分析网页结构，提取网页信息。通常使用的解析库有:BeautifulSoup、lxml、pyquery，也可以使用正则，但是构造正则表达式比较复杂且易错 保存数据：将提取的数据保存到某处以便后续利用。保存形式有：TXT、Json、数据库：MySQL、MongoDB、或远程服务器SFTP… 自动化程序替人完成完成爬取工作的自动化程序，可以在抓取过程中进行异常处理……保证爬取的高效运行","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——URL与URI","slug":"Python爬虫知识点——URL与URI","date":"2018-10-24T10:35:53.000Z","updated":"2018-10-24T10:41:12.634Z","comments":true,"path":"2018/10/24/Python爬虫知识点——URL与URI/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——URL与URI/","excerpt":"","text":"URL与URI URL全称：Uniform Resource Locator(统一资源定位符) URI全称：Uniform Resource Identifier(统一资源标识符) 如https://github.com/favicon.ico为例，它既是一个URL又是一个URI。我们通过URL/URI唯一指定了它的访问方式。其中包括访问协议https、访问路径、资源名称favicon.ico。通过这个链接提供的消息，我们就可以直接访问到此资源所在的位置。这便是URL、URI的作用。 URL是URI的子集。===&gt;每个URL都是URI，但不是每个URI都是URL。 URI包括两个子类:URN和URL。其中URN只命名资源但不指定如何定位资源(如urn:isbn:0451450523)指定了一本书的ISBN，可以唯一标识，但未定位。 ▲.目前互联网中URN用得很少，几乎所有的URI都是URL。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——Chrome开发者工具Network","slug":"Python爬虫知识点——Chrome开发者工具Network","date":"2018-10-24T10:35:31.000Z","updated":"2018-10-24T10:38:09.294Z","comments":true,"path":"2018/10/24/Python爬虫知识点——Chrome开发者工具Network/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——Chrome开发者工具Network/","excerpt":"","text":"Chrome开发者工具中Network功能介绍 第一列Name:请求的名称，一般会将URL的最后一 部分内容当作名称。 第二列Status: 响应的状态码，这里显示为200，代表响应是正常的。通过状态码，我们可 以判断发送了请求之后是否得到了正常的响应。 第三列Type: 请求的文档类型。这里为document, 代表我们这次请求的是一个HTML文档,内容就是一些HTML代码。 第四列initiator: 请求源。用来标记请求是由哪个对象或进程发起的。 第五列Size: 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示from cache。 第六列Time:发起请求到获取响应所用的总时间。 第七列Waterfall:网络请求的可视化瀑布流。 响应中分General部分，请求头、响应头： 其中General含： Request URL为请求的URL， Request Method为请求的方法 Status Code为响应状态码， Remote Address为远程服务器的地址和端口 Referrer Policy为Referrer判别策略。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"XShell通过SSH远程连接云服务器通过SSH远程连接云服务器","slug":"XShell通过SSH远程连接云服务器","date":"2018-10-24T10:32:05.000Z","updated":"2018-10-24T10:33:38.150Z","comments":true,"path":"2018/10/24/XShell通过SSH远程连接云服务器/","link":"","permalink":"https://nymrli.top/2018/10/24/XShell通过SSH远程连接云服务器/","excerpt":"","text":"1.账号密码登录法一: 法二:","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"复制Django项目时需要注意、修改的地方","slug":"复制Django项目时需要注意、修改的地方","date":"2018-10-24T10:25:37.000Z","updated":"2018-10-24T10:26:19.740Z","comments":true,"path":"2018/10/24/复制Django项目时需要注意、修改的地方/","link":"","permalink":"https://nymrli.top/2018/10/24/复制Django项目时需要注意、修改的地方/","excerpt":"","text":"复制Django项目: manage.py中需要修改的地方 1os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;window.settings&quot;) settings.py中需要修改的地方 12345&quot;&quot;&quot;Django settings for window project.&quot;&quot;&quot;ROOT_URLCONF = &apos;window.urls&apos;WSGI_APPLICATION = &apos;window.wsgi.application&apos; urls.py中需要改动的地方 1&quot;&quot;&quot;window URL Configuration wsgi.py中需要修改的地方 123&quot;&quot;&quot;WSGI config for window project.os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;window.settings&quot;) django可复用模板 在project_name文件下的*.py 再在终端键入django-admin startproject xx –template= (为文件夹中py文件名) 12345678910111213141516171819202122232425262728293031323334import osimport sysfrom django.conf import settingsDEBUG = os.environ.get(&apos;DEBUG&apos;,&apos;on&apos;)== &apos;on&apos;ALLOW_HOSTS = [&apos;*&apos;]SECRET_KEY = os.environ.get(&apos;SECRET&apos;,&apos;&#123;&#123; secret_key &#125;&#125;&apos;)settings.configure( DEBUG = DEBUG, ALLOW_HOSTS = ALLOW_HOSTS, SECRET_KEY = SECRET_KEY, ROOT_URLCONF = __name__, MIDDLEWARE_CLASSES = ( &apos;django.middleware.common.CommonMiddleware&apos;, &apos;django.middleware.csrf.CsrfViewMiddleware&apos;, &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;, ))from django.conf.urls import urlfrom django.core.wsgi import get_wsgi_applicationfrom django.http import HttpResponsedef index(request): return HttpResponse(&apos;Hello Word&apos;)urlpatterns = ( url(r&apos;$&apos;,index),)application = get_wsgi_application()if __name__ == &apos;__main__&apos;: from django.core.management import execute_from_command_line execute_from_command_line(sys.argv)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Django","slug":"Django","permalink":"https://nymrli.top/tags/Django/"}]},{"title":"Python Web——Django笔记","slug":"Python Web——Django笔记(一)","date":"2018-10-24T10:23:40.000Z","updated":"2018-10-24T11:06:36.423Z","comments":true,"path":"2018/10/24/Python Web——Django笔记(一)/","link":"","permalink":"https://nymrli.top/2018/10/24/Python Web——Django笔记(一)/","excerpt":"","text":"Python Web——Django笔记新建项目: django-admin startproject blog .创建应用程序(APP):python manage.py startapp fsite添加app:INSTALLED_APPS=[&#39;...&#39;] 新建的 app 如果不加到 INSTALL_APPS 中的话, django 就不能自动找到app中的模板文件(app-name/templates/下的文件)和静态文件(app-name/static/中的文件) .小提示，DEBUG=True 的时候，Django 还可以自动找到 各 app 下 static 文件夹中的静态文件（js，css，图片等资源） 创建SQLite数据库:python manage.py migrate #创建数据表使模型生效:python manage.py makemigrations# Django 在 blog 应用的 migrations\\ 目录下生成了一个 0001_initial.py 文件，这个文件是 Django 用来记录我们对模型做了哪些修改的文件创建管理员:python manage.py createsuperuser添加template: &#39;DIRS&#39;:[os.path.join(BASE_DIR,&#39;templates&#39;)],清空数据库:python manage.py flushBASE_DIR 是 settings.py 在配置开头前面定义的变量添加静态文件:123STATIC_URL = &apos;/static/&apos;STATICFILES_DIRS = [os.path.join(BASE_DIR,&apos;static&apos;)]STATIC_ROOT = &quot;/home/nymrli/mvote/staticfiles/&quot; urls.py头文件 1234&gt; from django.contrib import admin&gt; from django.conf.urls import include,url&gt; from fsite.views import homepage,showpost&gt; views.py头文件 12345&gt; from django.shortcuts import render,redirect&gt; from django.http import HttpResponse,request&gt; from .models import Post&gt; from django.template.loader import get_template&gt; 使显示标题:12def __str__(self): return self.title 书上的unicode和repr都没有用 增加显示其他时 12class PostAdmin(admin.ModelAdmin): list_display = (&apos;title&apos;,&apos;slug&apos;,&apos;pub_date&apos;) 要记得在admin.site.register(Post,PostAdmin)中增加PostAdmin 在urls.py中的url()的库文件要修改 12from django.contrib import adminfrom django.conf.urls import include,url 同时记得这点: 1234urlpatterns = [ url(&apos;^admin/&apos;, admin.site.urls), ## &apos;^admin/&apos;在/后面不能加$ url(r&apos;^$&apos;,homepage), ] views.py视图函数: 12def homepage(request): ##首先记得是*def* posts = Post.objects.all() ##虽然pycharm没提示Post有objects但仍有效果 count,post in enumerate(posts):1234for count,post in enumerate(posts): post_lists.append(&quot;NO.&#123;&#125;&quot;.format(str(count)) + str(post) + &quot;&lt;hr&gt;&quot;) post_lists.append(&quot;&lt;small&gt;&quot; + str(post.body.encode(&apos;utf-8&apos;)) + &quot;&lt;/small&gt;&lt;br&gt;&quot;) ### 这边的encode没必要加 template 步骤1: 在settings.py 中设置模板文件夹的位置. 步骤2:在urls.py中创建网址和views.py中函数的对应关系 步骤3:创建.html文件(例如index.html)做好排版数据要放的位置 步骤4:运行程序,以objects.all()在views.py中取得数据或资料 步骤5:以render函数把数据(posts)送到指定的模板文件(例如index.html)中. 网页对应urls.py 步骤1: 在urls.py中设置,只要是/post/开头的网址,就把后面接着的文字当做参数传送slug给post_detail显示单篇文章的函数 步骤2:在views.py中新增一个post_detail函数.除了接受request参数外,也接受slug参数. 步骤3:在templates文件夹中创建一个用来显示单篇文章的post.html 步骤4:在post_detail函数中,以slug为关键字搜索数据集,找出是否有符合的项目 步骤5:如果有符合的,就把找到的数据项传送给render函数,找出post.html模板页进行渲染(即进行页面显示),再把结果交给HttpResponse回传给浏览器 步骤6:如果没有符合的项目,就把网页转回首页 共享模板的使用: 文件名 用途说明 base.html 网站的基础模板，提供网站的主要设计、外观风格 header.html 网站中每一个网页共享的标题元素，通常是放置网站 Log 的地方 footer.html 网站中每一个网页的共享页尾，用来放置版权声明或其他参考信息 index.html 此范例网站的首页 post.html 此范例网站用来显示单篇文章的网页 显示图片 要用过滤器,不然就是串html代码. Wampserver初始: 12账号:root密码:空 bootstrap的CDN: HTML.CSS放在之前,JS的放在之前 12345678910111213&lt;head&gt;&lt;!-- Latest compiled and minified CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; integrity= &quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- Optional theme --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css&quot; integrity=&quot;sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- Latest compiled and minified JavaScript --&gt;&lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js&quot; integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/head&gt; 12345&lt;body&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.1.0.min.js&quot; integrity=&quot;sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/body&gt; 后台管理的自定义admin.py显示更多的小标题12345class ProductAdmin(admin.ModelAdmin): list_display = (&apos;pmodel&apos;,&apos;nickname&apos;,&apos;price&apos;,&apos;year&apos;) search_fields = (&apos;nickname&apos;,) ordering = (&apos;price&apos;,)admin.site.register(Product,ProductAdmin) 要显示中文的小标题12345678class Product(models.Model): pmodel = models.ForeignKey(PModel,on_delete=models.CASCADE,verbose_name=&apos;型号&apos;) nickname = models.CharField(max_length=15,default=&apos;超值二手机&apos;,verbose_name=&apos;摘要&apos;) description = models.TextField(default=&apos;暂无说明&apos;) year = models.PositiveIntegerField(default=2018,verbose_name=&apos;出厂年份&apos;) price = models.PositiveIntegerField(default=0,verbose_name=&apos;价格&apos;) def __str__(self): //python3.*中都用__str__,不用__unicode__ return self.nickname 注意:admin.py 中的class ProductAdmin 仍需要 12345try: product = models.Product.objects.get(id=id) images = models.PPhoto.objects.filter(product=product)except: pass django中的ORM中如果用get找不到,就会产生一个DoseNotExist的异常中断程序 filter作用:我们很少会一次性从数据库中取出所有的数据；通常都只针对一部分数据进行操作 所以要将product中的成员单独 python 中没有null 与C不同的是，在python中是没有NULL的，取而代之的是None，它的含义是为空 python是把0，空字符串‘ ’和None都看作False，把其他数值和非空字符串都看作True 表示该值是一个空对象，空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 123456&lt;label for=&quot;byear&quot;&gt;你的年份:&lt;/label&gt;&lt;select name=&apos;byear&apos;&gt; &#123;% for year in years %&#125; &lt;option value=&quot;&#123;&#123; year &#125;&#125;&quot;&gt;&#123;&#123; year &#125;&#125;&lt;/option&gt; &#123;% endfor %&#125;&lt;/select&gt;&lt;br&gt; 这个也要放到中 对数据的提取:12345try: urid = request.GET[&apos;user_id&apos;] urpass = request.GET[&apos;user_pass&apos;] urfcolor = request.GET.getlist(&apos;fcolor&apos;) #注意区别()与[] uryear = request.GET[&apos;byear&apos;]","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Django","slug":"Django","permalink":"https://nymrli.top/tags/Django/"}]},{"title":"网络宽带和网络延迟","slug":"网络宽带和网络延迟","date":"2018-10-24T08:42:27.000Z","updated":"2018-10-24T08:44:50.602Z","comments":true,"path":"2018/10/24/网络宽带和网络延迟/","link":"","permalink":"https://nymrli.top/2018/10/24/网络宽带和网络延迟/","excerpt":"","text":"网络宽带和网络延迟网络带宽，网络延迟是2个概念（网络延迟往往更容易被忽略！） 国内大陆 建立在互联网基础上 很多对延迟性要求比较高的应用，体验效果都不如人意。比如高清晰度网络电视、在线视频语音实时业务（qq、skype） 某些在线游戏 等等。最简单的例子：如果ping某个网站，高于50ms的网站，打开就慢。10-30ms的网站，打开就比较快。如果都是同一个宽带服务商，即使升级到10M 20M 100M的宽带，这种网络延迟情况，短时间内应该也不会有改善 1、“下载电影这种活儿就看带宽，不在乎服务器发出数据后晚几秒钟收到，传输层有“窗口协议”，不必等到上一段数据的应答再传下一段数据，可以看做是一种“异步应用”。一般说，交互性的应用比较讲究低延迟，我用“同步应用”来描述之。同步应用别说晚几秒钟，就是晚0.1秒收到数据，影响也很大,如a、比如fps游戏会觉得很不爽，明明瞄准了怎么打不到。b、至于视频语音等，对带宽、延迟都有一定要求，带宽太小无法传输清晰的图像和声音，延迟太大你一句话“我爱你”，对方的mm没有任何反应……另外还有一个指标是抖动，通俗说是数据能不能平稳传输，还是一会儿快一会儿慢一会儿堵塞。” 2、理论上说，带宽越大，在网络拓扑中的优先级就越高，所对应的响应速度就越快，对于用户和ISP之间来说带宽越高，每秒传输的数据越多，延迟就越小。但是延迟高低是由很多个因素决定的，网络上的每一个服务器（路由器）都是一个节点，所有的节点加在一起的响应速度，才是你的网络延迟，如果某一中间节点出现出题，无法提供服务，其它节点就会重新计算路由，但是重新计算路由之前会有一个超时记时器，只有目的节点的响应时间超出记时器时才会重新进行路由计算。还有DNS服务器的影响等等， 所以把网络带宽和网络延迟扯在一起谈是没用的，ISP只能保证你的接入网络带宽和网络延迟无问题，与其它节点的服务就没法保证了。（世界上最远的距离不是天涯和海角，而是电信和网通）” 3、“任何FPS游戏，网络条件是最关键的——到服务器的ping稳定性和延迟时间，对战绩的影响最大。比如ping服务器5分钟，延迟ms数一直不变，或者误差不超过5%，随便什么FPS，哪怕你从没玩过没有经验不熟悉地图和武器，你的成绩也差不了。如果这ms数比多数人还少，那你更屌了。 ADSL线路分交织模式interleave和快速模式fast,区别在于交织模式在本地会对数据包进行纠错加密，因此可保证线路的稳定，当然相应的延迟就会上升，电信提供的线路默认也都是交织模式，于是有种减低延迟的方法就是让电信帮你线路改成FAST,当然随之而来的问题是可能导致线路的不稳定，尤其是家里离接入网机房比较远的情况。 延迟这个问题只要是网络都会存在,差别在于大小,标志着整个架构的合理性和完善性。可以简单的认为带宽相当于马路上的车道数量，延迟就相当于堵塞的程度。因此，营运商即使是相同带宽的情况下对延迟不同的线路收费也是不同的。当然一般家庭用户是不会享受这个的。 ADSLADSL（Asymmetric Digital Subscriber Loop）技术是一种不对称数字用户线实现宽带接入互连网的技术。 实际传输速度也要分上行和下行，上行速率就是发送出去数据的速度(上传速度)，下行就是收到数据的速度(下载速度). 总结 带宽代表一定时间内能运多少货。 延迟代表货物运输时间。比如万吨轮就是属于大带宽，高延迟。私人飞机属于低延迟，小带宽。比如都给一个月的时间，万吨轮拉的东西肯定比私人飞机多,如果土豪做生意，血汗工厂t恤运去去美国，肯定用轮船，对带宽敏感，对延迟不敏感的业务。但是如果土豪要移植肾了，这玩意路上放久会臭，就属于对延迟比较敏感的应用，还是用私人飞机运比较好。","categories":[],"tags":[{"name":"计算机知识","slug":"计算机知识","permalink":"https://nymrli.top/tags/计算机知识/"}]},{"title":"linux下apt-get介绍","slug":"linux下apt-get介绍","date":"2018-10-24T08:42:20.000Z","updated":"2018-11-21T14:33:22.237Z","comments":true,"path":"2018/10/24/linux下apt-get介绍/","link":"","permalink":"https://nymrli.top/2018/10/24/linux下apt-get介绍/","excerpt":"","text":"apt-get Advanced Package Tool又名apt-get，是一条linux命令，适用于deb包管理式的操作系统如Unix和Linux系统的应用程序管理器，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。 rpm包和deb包是两种Linux系统下最常见的安装包格式，在安装一些软件或服务的时候免不了要和它们打交道。rpm包主要应用在RedHat系列包括 Fedora等发行版的Linux系统上，deb包主要应用于Debian系列包括现在比较流行的Ubuntu等发行版上。 我们知道如果要安装现成的这两种包的话，安装rpm包的命令是“rpm -参数”，安装deb包的命令是“dpkg -参数”。而Linux系统很方便和人性化的一点就是很多软件或服务根本就不用我们去下载，直接使用相应的命令就可以管理了，可能这就是传说中的 “云”的概念。 yum可以用于运作rpm包，例如在Fedora系统上对某个软件的管理：安装：yum install &lt;package_name&gt;卸载：yum remove &lt;package_name&gt;更新：yum update &lt;package_name&gt; apt-get可以用于运作deb包，例如在Ubuntu系统上对某个软件的管理：安装：apt-get install &lt;package_name&gt;卸载：apt-get remove &lt;package_name&gt;更新：apt-get update &lt;package_name&gt; ▲.apt-get命令一般需要root权限执行，所以一般跟着sudo命令。 12345678910111213apt-get update#1、apt-get update是同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。#2、apt-get update只是更新了apt的资源列表，没有真正的对系统执行更新。如果需要，要使用apt-get upgrade来更新。apt-get upgrade#可以使用这条命令更新软件包，apt-get upgrade不仅可以从相同版本号的发布版中更新软件包，也可以从新版本号的发布版中更新软件包，尽管实现后一种更新的推荐命令为apt-get dist-upgrade(将系统升级到新版本)。#总结:▲ apt-get update 是更新本地软件列表，在线安装的时候可以在软件列表找到软件； apt-get upgrade 是更新本地已安装的软件，要谨慎执行。 #dpkg -l#列出所有已安装的软件包。 在Ubuntu中，有时候运用sudo apt-get install 安装软件时，会出现一下的情况 E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 主要是因为apt还在运行,解决方案是 1.找到并且杀掉所有的apt-get 和apt进程123456ps -A | grep apt找出所有的 apt 以及 apt-get 进程$ sudo kill -9 processnumber 或者$ sudo kill -SIGKILL processnumber比如，下面命令中的9是 SIGKILL 的信号数，它会杀掉第一个 apt 进程$ sudo kill -9 进程ID 或者$ sudo kill -SIGKILL 进程ID 2、删除锁定文件锁定的文件会阻止 Linux 系统中某些文件或者数据的访问，这个概念也存在于 Windows 或者其他的操作系统中。 一旦你运行了 apt-get 或者 apt 命令，锁定文件将会创建于 /var/lib/apt/lists/、/var/lib/dpkg/、/var/cache/apt/archives/ 中。 这有助于运行中的 apt-get或者 apt 进程能够避免被其它需要使用相同文件的用户或者系统进程所打断。当该进程执行完毕后，锁定文件将会删除。 当你没有看到 apt-get或者 apt 进程的情况下在上面两个不同的文件夹中看到了锁定文件，这是因为进程由于某个原因被杀掉了，因此你需要删除锁定文件来避免该错误。 123456789101112#首先运行下面的命令来移除 /var/lib/dpkg/ 文件夹下的锁定文件：$ sudo rm /var/lib/dpkg/lock#之后像下面这样强制重新配置软件包：$ sudo dpkg --configure -a#也可以删除 /var/lib/apt/lists/ 以及缓存文件夹下的锁定文件：$ sudo rm /var/lib/apt/lists/lock$ sudo rm /var/cache/apt/archives/lock#接下来，更新你的软件包源列表：$ sudo apt update 或者 $ sudo apt-get update","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"python中关于round函数的注意事项","slug":"python中关于round函数的注意事项","date":"2018-10-18T03:37:00.000Z","updated":"2018-10-18T03:37:23.461Z","comments":true,"path":"2018/10/18/python中关于round函数的注意事项/","link":"","permalink":"https://nymrli.top/2018/10/18/python中关于round函数的注意事项/","excerpt":"","text":"python中关于round函数的注意事项 round函数很简单，对浮点数进行近似取值，保留几位小数。 比如: 12345&gt;&gt;&gt; round(10.0/3, 2)3.33&gt;&gt;&gt; round(20/7)3#第一个参数是一个浮点数，第二个参数是保留的小数位数，可选，如果不写的话默认保留到整数。 12345678910#[round]函数文档-py3def round(number, ndigits=None): # real signature unknown; restored from __doc__ \"\"\" round(number[, ndigits]) -&gt; number Round a number to a given precision in decimal digits (default 0 digits). This returns an int when called with one argument, otherwise the same type as the number. ndigits may be negative. \"\"\" return 0 翻译一下什么意思呢?: 将数字四舍五入到给定精度,如果不给第二个精度参数的话就默认保留到0位(即整数) 这么简单的函数，能有什么坑呢？1、round的结果跟python版本有关 1234567#-------python2---------&gt;&gt;&gt; round(0.5)1.0#======python3==========&gt;&gt;&gt; round(0.5)0 原因在于: 在python2.7的doc中，round()的最后写着，“Values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done away from 0.” 保留值将保留到离上一位更近的一端（四舍六入），如果距离两端一样远，则保留到离0远的一边。所以round(0.5)会近似到1，而round(-0.5)会近似到-1。 但是到了python3.5的doc中，文档变成了“values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice.” 如果距离两边一样远，会保留到偶数的一边。比如round(0.5)和round(-0.5)都会保留到0，而round(1.5)会保留到2。 然而需要注意的是 2、特殊数字round出来的结果可能未必是想要的。 12&gt;&gt;&gt; round(2.675, 2)2.67 官方举例:python2和python3的doc 123NoteThe behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more information. 简单的说就是，round(2.675, 2) 的结果，不论我们从python2还是3来看，结果都应该是2.68的，结果它偏偏是2.67，为什么？这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串1和0后可能是无限位数的，机器已经做出了截断处理)。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离2.67要更近一点点，所以保留两位小数时就近似到了2.67。 例子2: 12&gt;&gt;&gt; round(123.45, 1)123.5 意思就是说计算机需要先将十进制123.45转换为二进制,这个过程会导致二进制的值比123.45略大(比如123.45000001之类的),那么自然就得到123.5这个值了. 以上。除非对精确度没什么要求，否则尽量避开用round()函数。近似计算我们还有其他的选择： 使用math模块中的一些函数，比如math.ceiling（天花板除法）。 python自带整除，python2中是/，3中是//，还有div函数。 字符串格式化可以做截断使用，例如 “%.2f” % value（保留两位小数并变成字符串……如果还想用浮点数请披上float()的外衣）。 当然，对浮点数精度要求如果很高的话，请用嘚瑟馍，不对不对，请用decimal模块。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"HDOJ Problem 1002 - A + B Problem II","slug":"HDOJ-Problem-1002-A-B-Problem-II","date":"2018-10-18T03:36:23.000Z","updated":"2018-10-18T03:36:44.900Z","comments":true,"path":"2018/10/18/HDOJ-Problem-1002-A-B-Problem-II/","link":"","permalink":"https://nymrli.top/2018/10/18/HDOJ-Problem-1002-A-B-Problem-II/","excerpt":"","text":"HDOJ Problem 1002 - A + B Problem II:大数定理 Problem Description I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000. Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line is the an equation “A + B = Sum”, Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases. Sample Input12321 2112233445566778899 998877665544332211 Sample Output12345Case 1:1 + 2 = 3Case 2:112233445566778899 + 998877665544332211 = 1111111111111111110 解法一: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;char a[1000],b[1000];int aar[1001],bar[1001];int main()&#123; int alen,blen,maxlen; int time; cin &gt;&gt; time; for (int i=1;i&lt;=time;i++) &#123; cin &gt;&gt; a &gt;&gt; b; alen = strlen(a); blen = strlen(b); int tmp = 0; for (int j=alen-1;j&gt;=0;j--) aar[tmp++] = a[j]-'0'; tmp = 0; for (int j=blen-1;j&gt;=0;j--) bar[tmp++] = b[j]-'0'; //123 ==&gt; 321 为了保证之后便于计算 if ( alen &gt; blen)&#123; maxlen = alen; for(int j=blen;j&lt;alen;j++)&#123; //长度不同时,短的那个需要补零 bar[j] = 0; &#125; aar[alen] = 0; &#125; else if ( alen &lt; blen)&#123; maxlen = blen; for(int j=alen;j&lt;blen;j++) &#123; aar[j] = 0; &#125; bar[blen] = 0; &#125; else&#123; maxlen = alen; aar[maxlen]=0; bar[maxlen]=0; &#125; for (int j=0;j&lt;maxlen;j++)&#123; cout &lt;&lt; aar[j] &lt;&lt; '\\t'; cout &lt;&lt; bar[j] &lt;&lt;endl; aar[j] += bar[j]; if(aar[j] &gt;= 10)&#123;//如果当前位大于10则进一位 aar[j] -=10; aar[j+1] += 1; &#125; &#125;//将a+b的和保存在aar数组里 cout &lt;&lt; \"Case:\" &lt;&lt; i&lt;&lt; endl; cout &lt;&lt; a &lt;&lt; \" + \" &lt;&lt; b &lt;&lt; \" = \" ; if (aar[maxlen] == 0 ) //判断第一位是否为0,如果是的话就从第二位开始读,这个是逆序 for (int j=maxlen-1;j&gt;=0;j--) cout &lt;&lt; aar[j]; else for (int j=maxlen;j&gt;=0;j--) cout &lt;&lt; aar[j]; if(i != time) //注意要求的输出格式 cout &lt;&lt; endl&lt;&lt; endl; else cout &lt;&lt; endl; &#125; return 0;&#125; 解法二:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;using namespace std;int i,j,y,n,k,h,p,lena,lenb;int a[1000],b[1000],sum[1000],f[1000];int main()&#123; string a1,b1; cin&gt;&gt;n; for(y=1;y&lt;=n;y++) &#123; cin&gt;&gt;a1&gt;&gt;b1; lena=a1.length(); lenb=b1.length(); for(i=0;i&lt;1000;i++)&#123; a[i]=0;b[i]=0;f[i]=0;//f数组是记录a+b和 //这个补零是先全都设为0,再把不为0的填入 &#125; for(i=lena-1;i&gt;=0;i--) /*1234 ==&gt; 4321*/ a[lena-1-i]=a1[i]-'0'; //字符'9' - '0' 才是数字9 for(i=lenb-1;i&gt;=0;i--) b[lenb-1-i]=b1[i]-'0'; k=0; for(i=0;i&lt;lenb || i&lt;lena;i++)&#123; //i--&gt; max( lena , lenb ) h=a[i]+b[i]+k; //k是下一位是否进一 f[i]=h%10; //f[i]必然是0-9 k=h/10; //如果h大于10,则k=1,如果h小于10,则k=0 &#125; if(k!=0) //如果k=1,则最高位加一 f[i++]=k; cout&lt;&lt;\"Case \"&lt;&lt;y&lt;&lt;\":\"&lt;&lt;endl&lt;&lt; a1 &lt;&lt;\" + \"&lt;&lt; b1 &lt;&lt;\" = \"; p=0; for(j=i-1;j&gt;=0;j--)&#123; //将之前为了计算时的倒序,再反正过来 if(p==0 &amp;&amp; f[j]==0)&#123; //目的是去前导0,实则这步多余了 continue; //如果最高位是0的话i就不会++,如果是1的话,那么f[j]就不会是0,所以这步必然是进入else &#125; else&#123; p=1; cout&lt;&lt;f[j]; &#125; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; ▲总结: 1.为什么用字符数组==&gt;因为数字太大,long long也存储不下 2.用int数组记录每一位的数字,然后模拟手算 3.为什么倒置==&gt;因为为了让末尾对齐,方便计算”个位对个位,十位对十位……”","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"}]},{"title":"LeetCode 26. 删除排序数组中的重复项","slug":"LeetCode-26-删除排序数组中的重复项","date":"2018-10-18T03:35:36.000Z","updated":"2018-10-18T03:35:50.502Z","comments":true,"path":"2018/10/18/LeetCode-26-删除排序数组中的重复项/","link":"","permalink":"https://nymrli.top/2018/10/18/LeetCode-26-删除排序数组中的重复项/","excerpt":"","text":"LeetCode 26. 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 方法：双指针法算法 数组完成排序后，我们可以放置两个指针 i和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。 当我们遇到 nums[j] != nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。 1234567891011public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; 复杂度分析 时间复杂度：O(n)， 假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。 空间复杂度：O(1)。 Python实现:1234567891011121314class Solution: def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) &lt;= 1: return len(nums) s = 0 for f in range(1, len(nums)): if nums[s] != nums[f]: s += 1 nums[s] = nums[f] return s + 1","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"}]},{"title":"素数判别","slug":"素数判别","date":"2018-10-15T14:30:55.000Z","updated":"2019-04-25T00:49:26.886Z","comments":true,"path":"2018/10/15/素数判别/","link":"","permalink":"https://nymrli.top/2018/10/15/素数判别/","excerpt":"","text":"素数判别 由于1既不是素数也不是合数，所以下面暂未判断。如果需要则需特判如if (num == 1) return false; 方法一123456789bool isPrime_2( int num )&#123; int tmp =sqrt( num); for(int i= 2;i &lt;=tmp; i++) if(num %i== 0) return 0 ; return 1 ;&#125;//一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n)。若sqrt(n)左侧找不到约数，那么右侧也一定找不到约数 方法二(筛选法)123456789101112131415161718192021222324252627282930#include\"cstdio\"#include\"cstring\"using namespace std;#define MAX 100000//求MAX范围内的素数long long su[MAX],cnt;bool isprime[MAX];void prime()&#123; cnt=1; memset(isprime,1,sizeof(isprime));//初始化认为所有数都为素数 isprime[0]=isprime[1]=0;//0和1不是素数 for(long long i=2;i&lt;=MAX;i++) &#123; if(isprime[i])//保存素数 &#123; su[cnt++]=i; &#125; for(long long j=i*2;j&lt;=MAX;j+=i)//素数的倍数都为合数 &#123; isprime[j]=0; &#125; &#125;&#125;int main()&#123; prime(); for(long long i=1;i&lt;cnt;i++) printf(\"%d \",su[i]); return 0;&#125; 方法三(剪枝) 证明：令x≥1，将大于等于5的自然数表示如下： ······ 6x-1，6x，6x+1，6x+2，6x+3，6x+4 | 6x+5，6(x+1），6(x+1)+1 ······ 可以看到，不在6的倍数两侧，即6x两侧的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。这里有个题外话，关于孪生素数，有兴趣的道友可以再另行了解一下，由于与我们主题无关，暂且跳过。这里要注意的一点是，在6的倍数相邻两侧并不是一定就是质数。===&gt;只需判断6两侧的是不是质数(6x-1、6x+1) 此时判断质数可以6个为单元快进，即将方法（2）循环中i++步长加大为6，加快判断速度，原因是，假如要判定的数为n，则n必定是6x-1或6x+1的形式，对于循环中6i-1，6i，6i+1,6i+2，6i+3，6i+4，其中如果n能被6i，6i+2，6i+4整除，则n至少得是一个偶数，但是6x-1或6x+1的形式明显是一个奇数，故不成立；另外，如果n能被6i+3整除，则n至少能被3整除，但是6x能被3整除，故6x-1或6x+1（即n）不可能被3整除，故不成立。===&gt;综上，循环中只需要考虑6i-1和6i+1的情况(被本身更小的因数所除如22/11)，即循环的步长可以定为6，每次判断循环变量k和k+2的情况即可，理论上讲整体速度应该会是方法（2）的3倍。代码如下： 12345678910111213141516bool isPrime_3( int num )&#123; //两个较小数另外处理 if(num ==2|| num==3 ) return 1 ; //不在6的倍数两侧的一定不是质数 if(num %6!= 1&amp;&amp;num %6!= 5) return 0 ; int tmp =sqrt( num); //在6的倍数两侧的也可能不是质数 for(int i= 5;i &lt;=tmp; i+=6 ) if(num %i== 0||num %(i+ 2)==0 ) return 0 ; //排除所有，剩余的是质数 return 1 ;&#125; for循环i从5开始而不是从7开始的原因: 从5、7开始的区别在于i &lt;= sqrt(num)..如果是5的话，判断条件为25；如果是7的话，判断的条件就为49。 而仔细观察49内的所有质数，发现25之前的质数都是6k左右的数(6k-1,6k+1)，而25以后，就不定都有了。如26则不为质数。 所以如果从5开始的话，那么25以内的数 都不会进入for循环，经过if(num %6!= 1&amp;&amp;num %6!= 5)的筛选后，就都是素数了。 而如果是从7开始，那么25-49之内的数不符合条件却不会进入for循环，所以26缺少这个for的循环判断后就被误判为素数了。 ==&gt;以我浅薄的数学见识理解，25以内素数规律的巧合性使得 这些数不需要进入for循环判断，所以相比于从7开始的错误，5开始是正确的 给出Py代码12345678910import mathdef prime_num(num): if num == 2 or num == 3: return 1 if num%6 != 1 and num%6!=5: return 0 for i in range(5,math.ceil(math.sqrt(num))+1,6): #就剩6k-1 和 6k+1 if num%i == 0 or num%(i-2)==0: return 0 return 1 参考:https://blog.csdn.net/huang_miao_xin/article/details/51331710","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"}]},{"title":"\\r - \\n - \\r\\n的区别","slug":"回车和换行区别","date":"2018-10-13T12:33:33.000Z","updated":"2019-05-30T03:34:19.030Z","comments":true,"path":"2018/10/13/回车和换行区别/","link":"","permalink":"https://nymrli.top/2018/10/13/回车和换行区别/","excerpt":"","text":"\\r - \\n - \\r\\n 的区别代码演示:123456781: string s1 = \"已经习惯了回车和换行一次搞定\\n，敲一个回车键，即是回\";2: 3: Console.WriteLine(s1);4: s1 = \"已经习惯了回车和换行一次搞定\\r，敲一个回车键，即是回\";5: Console.WriteLine(s1);6: s1 = \"已经习惯了回车和换行一次搞定\\r\\n，敲一个回车键，即是回\";7: Console.WriteLine(s1);8: Console.ReadLine(); Result:==&gt; 回车、换行的区别: \\r , \\n, \\r\\n的区别其实是回车与换行的区别 符号 ASCII码 意义 \\n 10 换行 \\r 13 回车CR 先来段历史 回车”（Carriage Return）和“换行”（Line Feed）这两个概念的来历和区别。 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33，Linux/Unix下的tty概念也来自于此）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 在Windows中： ‘\\r’ 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖； ‘\\n’ 换行，换到当前位置的下一行，而不会回到行首； Unix系统里，每行结尾只有“&lt;换行&gt;”，即”\\n”；Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“\\r\\n”；Mac系统里，每行结尾是“&lt;回车&gt;”，即”\\r”；。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 例 $ echo -en &#39;12\\n34\\r56\\n\\r78\\r\\n&#39; &gt; tmp.txt ==&gt;Linux中遇到换行符(“\\n”)会进行回车+换行的操作，回车符反而只会作为控制字符(“^M”)显示，不发生回车的操作。而windows中要回车符+换行符(“\\r\\n”)才会回车+换行，缺少一个控制符或者顺序不对都不能正确的另起一行。 ▲注意点： 在解析文本或其他格式的文件内容时，常常要碰到判定回车换行的地方，这个时候就要注意既要判定”**r**\\n”又要判定”\\n”。 写程序时可能得到一行,将其进行trim掉’**r**’,这样能得到你所需要的string了。 拓展程序测试 123456789101112131415161718192021222324252627282930/*==========================程序二===============================*/#include &lt;stdio.h&gt;int main(void)&#123; int i; FILE *fp; if((fp=fopen(\"test.txt\",\"w\")) == NULL) &#123; fprintf(stderr,\"open file error\\n\"); return 1; &#125; for(i=0;i&lt;100;i++) fprintf(fp,\"test\\n\"); fclose(fp); return 0;&#125;/*==========================程序二===============================*/#include &lt;stdio.h&gt;int main(void)&#123; int i; FILE *fp; if((fp=fopen(\"test.bin\",\"wb\")) == NULL) &#123; fprintf(stderr,\"open file error\\n\"); return 1; &#125; for(i=0;i&lt;100;i++) fprintf(fp,\"test\\n\"); fclose(fp); return 0;&#125; ​ 程序一输出文件大小是600字节，程序二输出文件大小是500字节，用记事本打开程序一的输出没有什么问题，每行一个test，打开程序二的输出发现所有的test连成一行，test之间是一个黑色方框符号分隔。用UltraEdit-32以16进制编辑模式打开test.bin可以查看到黑色方框符号就是0A也就是\\n，打开test.txt则会发现换行是\\r\\n，这就是两个文件大小相差100字节的原因。Unix类系统用户打开windows中的文件就会遇到这种苦恼。为什么会有这种区别呢？ ​ 毕竟是源自Unix系统，C语言中使用\\n表示换行，而在实际的文件中换行符号需要同操作系统一致，所以当我们在C中使用fopen打开一个文本文件时流实现了实际换行符与C中\\n之间的转换。在windows中当我们用fopen打开文本文件，然后从中读到\\r\\n时流会转换为\\n，而当我们往文件中写入\\n时流会转换为\\r\\n。程序一是打开文本文件，程序二打开的是二进制文件，因为流只对文本文件进行换行表示的转换，以二进制模式打开流不会做任何处理。所以当你以二进制模式打开一个文本文件时将产生错乱，你必须亲自将\\r\\n解释为\\n,同样的问题也会出现在以文本模式打开二进制文件的情况.这也解释了为什么Unix类系统中的文件不区分文本文件和二进制文件的原因。 当我们使用标准输入输出函数时有这种情况吗？再回到我们熟悉的标准输入输出stdin,stdout​ C的控制台程序在加载进内存成为进程运行前C运行时库自动打开三个设备并关联到三个流：标准输入流stdin，标准输出流stdout，标准出错流stderr ​ 通常在通用计算机中，没有重定向前这三个流对应的设备是：键盘，显示器，显示器。这三个都是字符设备，所以是以文本文件的模式打开的，在windows下当我们在键盘上敲入回车键时产生字符\\r\\n，但是在OS内核把键盘驱动中读到的字符发送给流的缓冲区时流会将之转换为\\n，当我们向控制台输出\\n时流将之转换为\\r\\n再传递至内核，当我们绕过标准输入输出直接调用windows中coredll.lib进行控制台输入输出时就必须面对这一现实，程序员负责实现这一转换。 摘自:https://www.cnblogs.com/xiaotiannet/p/3510586.html","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"云服务器Ubuntu更改默认python版本","slug":"云服务器Ubuntu更改默认python版本","date":"2018-10-12T05:07:48.000Z","updated":"2018-12-18T15:12:06.142Z","comments":true,"path":"2018/10/12/云服务器Ubuntu更改默认python版本/","link":"","permalink":"https://nymrli.top/2018/10/12/云服务器Ubuntu更改默认python版本/","excerpt":"","text":"云服务器Ubuntu更改默认python版本1、基于用户修改 Python 版本：想要为某个特定用户修改 Python 版本，只需要在其 home 目录下创建一个 alias(别名) 即可。打开该用户的 ~/.bashrc文件，添加新的别名信息来修改默认使用的 Python 版本。 vim ~/.bashrc 增加一行alias python=python3和修改pip版本alias pip=pip3 source ~/.bashrc再输入python --version,就能发现显示的是Python 3.x啦 2、 在系统级修改 Python 版本(建议)12# update-alternatives --list pythonupdate-alternatives: error: no alternatives for python 如果出现以上所示的错误信息，则表示 Python 的替代版本尚未被 update-alternatives 命令识别。想解决这个问题，我们需要更新一下替代列表，将 python2.7 和 python3.4 放入其中。 12345$ update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1# update-alternatives: using /usr/bin/python2.7 to provide /usr/bin/python (python) in auto mode$ update-alternatives --install /usr/bin/python python /usr/bin/python3.4 2# update-alternatives: using /usr/bin/python3.4 to provide /usr/bin/python (python) in auto mode –install 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。这个例子中，我们为 /usr/bin/python3.4 设置的优先级为2，所以update-alternatives 命令会自动将它设置为默认 Python 版本。 1234# 接下来，我们再次列出可用的 Python 替代版本。# update-alternatives --list python/usr/bin/python2.7/usr/bin/python3.4","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"nginx+uwsi搭建django环境服务器","slug":"nginx+uwsi搭建django环境服务器","date":"2018-10-12T04:44:09.000Z","updated":"2019-03-02T11:13:48.841Z","comments":true,"path":"2018/10/12/nginx+uwsi搭建django环境服务器/","link":"","permalink":"https://nymrli.top/2018/10/12/nginx+uwsi搭建django环境服务器/","excerpt":"","text":"阿里云搭建服务器更新源12sudo apt-get updatesudo apt-get upgrade 安装nginx1234sudo apt-get install nginxsudo /etc/init.d/nginx start (start可以改成restart/stop)#或是sudo service nginx start然后浏览器输入服务器IP,观察是否有welcom to nginx! 安装py3和virtualenv12sudo apt-get install git python3 python3-pipsudo pip3 install virtualenv 修改python版本:法一:(不建议)123456789$ gedit ~/.bashrc #gedit .bash_aliases在顶部加入一行alias python=python3$ source ~/.bashrc #或是source ~/.bash_aliases o$ python --version就会发现是Python 3.5.2啦/*orOpen your .bashrc file nano ~/.bashrc. Type alias python=python3 on to a new line at the top of the file then save the file with ctrl+o and close the file with ctrl+x. Then, back at your command line type source ~/.bashrc. Now your alias should be permanent.*/ Ubuntu16.04切换python3和python2▲.切换Python3为默认版本：(建议)12sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 切换Python2为默认版本： 1sudo update-alternatives --config python 安装虚拟环境12$ cd /var/www$ sudo virtualenv env35 下载和配置网站1234$ sudo git clone https://github.com/KyrieWang233/homework_submission-master.git$ source env35/bin/activate$ cd home...$ sudo pip3 install -r requirements.txt 123456$ sudo python manage.py collectstatic$ sudo python manage.py migrate$ python manage.py createsuperuser$ sudo vim settings.py将其中的ALLOWED_HOST=[*]改为自己的IP然后输入 python manage.py runserver 0.0.0.0:8000 安装、测试uwsgi12$ sudo pip3 install uwsgi$ uwsgi --http :8000 --module homework_submission.wsgi 编辑/var/www下的uwsgi.ini12345678910[uwsgi]chdir=/var/www/homework_submission-mastermodule=homework_submission.wsgihome=/var/www/env35master=Trueprocesses=10socket= :8001chmod socket=666vacuum=Truemax-requests=5000 编辑/var/www下的nginx.conf12345678910111213141516upstream django&#123;server 127.0.0.1:8001;&#125;server &#123;listen 80;server_name sast.nymrli.top;charset utf-8;client_max_body_size 75M;location /static&#123;alias /var/www/homework_submission-master/static; &#125;location /&#123;uwsgi_pass django;include /var/www/uwsgi_params;&#125;&#125; 编辑/var/www下的uwsgi_params12345678910111213141516uwsgi_param QUERY_STRING $query_string;uwsgi_param REQUEST_METHOD $request_method;uwsgi_param CONTENT_TYPE $content_type;uwsgi_param CONTENT_LENGTH $content_length; uwsgi_param REQUEST_URI $request_uri; uwsgi_param PATH_INFO $document_uri; uwsgi_param DOCUMENT_ROOT $document_root; uwsgi_param SERVER_PROTOCOL $server_protocol; uwsgi_param REQUEST_SCHEME $scheme; uwsgi_param HTTPS $https if_not_empty; uwsgi_param REMOTE_ADDR $remote_addr; uwsgi_param REMOTE_PORT $remote_port; uwsgi_param SERVER_PORT $server_port; uwsgi_param SERVER_NAME $server_name; 软连接12345cd /etc/nginxcd sites-enabledrm defaultln -s /var/www/nginx.conf homework_submissionls 重启nginx/etc/init.d/nginx restart 运行uwsgi12cd /var/wwwuwsgi --ini uwsgi.ini 让uwsgi自启动 vim /etc/rc.local(注意非虚拟环境也得安装uwsgi模块) 1234添加下面代码:/usr/local/bin/uwsgi --ini /var/www/uwsgi.iniexit 0 uwsgi的热启动 在uwsgi.ini中加入 py-autoreload=1 重启一下:killall -9 uwsgi、/usr/local/bin/uwsgi --ini /var/www/uwsgi.ini 总结关于etc/ linit. d 如果你使用过inux系统,那么你一定听说过 init. d目录,这个目录到底是干嘛的呢?它归根结底只做了一件事情,但这件事情非同小可,是为整个系统做的,因此它非常重要。init.d目录包含许多系统各种服务的启动和停止脚本 关于 /etc/rc.local rc.local也是我经常使用的一个脚本,该脚本是在系统初始化级别脚本运行之后再执行的,因此可以安’, ‘地在里面添加你想在系统启动之后执行的脚本. 总结 Linux是灵活的,正因为它的灵活性,我们总是可以找到许多不同的办法来解决同一个问题，服务的例子就是一个很好的佐证,有了 /etc/init.d目录下的脚本,再加上 /etc/rc. local这个利器，你可以放心的确保你的服务可以完美的启动和运行","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"小程序开发遇到的坑","slug":"小程序开发遇到的坑","date":"2018-10-04T12:26:58.000Z","updated":"2018-10-04T12:30:16.418Z","comments":true,"path":"2018/10/04/小程序开发遇到的坑/","link":"","permalink":"https://nymrli.top/2018/10/04/小程序开发遇到的坑/","excerpt":"","text":"小程序开发遇到的坑function 与 =&gt; 的区别 在JS中，箭头函数并不是简单的function(){}匿名函数的简写语法糖，实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，在编写函数时就已经确定了。而匿名函数的this指向运行时实际调用该方法的对象，无法在编写函数时确定。 箭头函数和普通函数的区别 不可以当做构造函数，也就是说，不可以使用 new 命令，否则会抛出错误。 this、arguments、caller等对象在函数体内都不存在。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 ==&gt;箭头函数除了传入的参数之外，其它的对象都没有！在箭头函数引用了this、arguments或者参数之外的变量，那它们一定不是箭头函数本身包含的，而是从父级作用域继承的。 代码实例:123456789101112function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 setTimeout(function()&#123; console.log(this.num); // undefined &#125;, 500); &#125;;&#125;var obj = new Test();obj.func();//这里的方法里调用了setTimeout函数，该函数500毫秒后调用我们定义的函数时，实际上是window对象调用的，所以这时匿名函数的this是指向window而不是指向obj了。 在箭头函数出现之前一般都是这么写的： 12345678910111213141516171819202122232425function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 var that = this; //保存一份当前的this对象 setTimeout(function()&#123; console.log(that.num); // 100 &#125;, 500); &#125;;&#125;var obj = new Test();obj.func();//这是利用了闭包的概念。箭头函数可以看做这种方式的语法糖。//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 setTimeout(() =&gt; &#123; console.log(this.num); // 100 //箭头函数没有this,所以从上层父级继承 &#125;, 500); &#125;;&#125;var obj = new Test();obj.func(); ▲同时需要注意的是:this是指向当前的对象，随着上下文作用域的切换this的执行this的指向会发生改变，我们可以先保存一份this的值然后再使用：var that = this 生成带参数的二维码123456789101112131415161718192021222324 onShow:function()&#123; var that = this; function get_code() &#123; wx.request(&#123; url: 'https://api.weixin.qq.com/cgi- bin/token?grant_type=client_credential&amp;appid=' + that.data.APP_ID + '&amp;secret=' + that.data.APP_SECRET, method: 'GET', success: function (res) &#123; // console.log(res.data.access_token); wx.request(&#123; data: &#123; 'path': \"pages/index\" &#125;, url: 'https://api.weixin.qq.com/wxa/getwxacode?access_token=' + res.data.access_token, method: 'POST', success: function (res) &#123; console.log(res.data);//2jin zhi &#125; &#125;) &#125; &#125;) &#125; get_code();&#125;//官方接口得到的是图片的二进制流 通过草料微信小程序生成二维码: 12345678910111213141516171819202122232425262728293031const app = getApp()Page(&#123; data: &#123; APP_ID: 'wx05818046869e4078', APP_SECRET: '5d4429375e84d6ab9476b643f8733af9', path: 'pages/index', photo:null, &#125;, onShow:function()&#123; var that = this; console.log(that.data.APP_ID + ' ' + that.data.APP_SECRET + ' ' + that.data.path) wx.request(&#123; url: 'https://cli.im/home/weapp/create', method:'POST', data:&#123; 'weapp_id': that.data.APP_ID,'weapp_secret': that.data.APP_SECRET,'weapp_url': that.data.path &#125;, header:&#123; 'content- type': 'application/x- www- form- urlencoded' &#125;, success:(res)=&gt;&#123; console.log(res.data.data) that.setData(&#123; photo: res.data.data &#125;) &#125; &#125;) &#125;&#125;) 组件的自定义数据属性:123&lt;view bindtap=&quot;f0&quot; data- xxx- yyy=&apos;blabla&apos;&gt;&lt;/view&gt;//在点击触发事件f0的参数event中,dataset为自定义参数的字典,其中,键值为驼峰命名法.xxxYyy ▲.bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡 wx.requests是异步调用的 wx.requests这个api是不会阻塞的,什么时候收到response就什么时候调用回调函数(success…),如果在wx.requests方法调用后还有运行代码(1),则(1)比回调函数早执行 组件: 以某种方式对 业务逻辑和 功能**的封装 特点:高内聚,可复用 视图组件 表单组件 媒体组件 画布组件 基础内容组件 导航组件 地图组件 开放能力组件 自定义组件:​ 内容略 ES6新特性:js中let和var定义变量的区别 声明后未赋值，表现相同: 如果未在 let 、var 语句中初始化您的变量，则将自动为其分配 JavaScript 值 undefined 使用未声明的变量，表现不同: var有变量提升，let无变量提升 重复声明同一个变量时，表现不同： var重复声明时覆盖，let重复声明时报错 变量作用范围，表现不同： 使用 let 语句声明一个变量，该变量的范围限于声明它的块中。 ==&gt;代码演示: 123456789101112(function() &#123; var varTest = 'test var OK.'; let letTest = 'test let OK.'; &#123; var varTest = 'varTest changed.'; let letTest = 'letTest changed.'; &#125; console.log(varTest); //输出\"varTest changed.\"，内部\"&#123;&#125;\"中声明的varTest变量覆盖外部的letTest声明 console.log(letTest); //输出\"test let OK.\"，内部\"&#123;&#125;\"中声明的letTest和外部的letTest不是同一个变量&#125;());","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"带表头的单链表的基本操作","slug":"带表头的单链表的基本操作","date":"2018-09-27T14:12:17.000Z","updated":"2018-09-27T14:25:50.649Z","comments":true,"path":"2018/09/27/带表头的单链表的基本操作/","link":"","permalink":"https://nymrli.top/2018/09/27/带表头的单链表的基本操作/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct Node&#123; ElemType elem; struct Node *link;&#125;Node;typedef struct &#123; struct Node* head; int n;&#125;Headlist;Status Init(Headlist *L)&#123; L-&gt;head = (Node*)malloc(sizeof(Node)); if(!L-&gt;head) return ERROR; L-&gt;head-&gt;link = NULL; L-&gt;n = 0; return OK;&#125;void Sort(Headlist *L)&#123; Node *p=L-&gt;head,*pre=NULL; Node *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;elem &lt; p-&gt;elem) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125;&#125;void deleleab(Headlist *L, int a,int b)&#123; Node *q = L-&gt;head,*p=L-&gt;head-&gt;link; // q为上一个,p为当前的 while( p ) if(p-&gt;elem &gt;= a &amp;&amp; p-&gt;elem &lt;= b) &#123; q-&gt;link = p-&gt;link; // 1 - 2 - 3 1==&gt;3,1的指针域指向3 free(p); //释放2 p = q-&gt;link; // 当前的指针变成3 &#125;else&#123; p = p-&gt;link; q = p-&gt;link; &#125; &#125;Status Converse(Headlist *L)&#123; Node *p = NULL,*cur= NULL; Node *q = L-&gt;head-&gt;link; if(L-&gt;head &amp;&amp; L-&gt;head-&gt;link)&#123; //如果表不存在或是为空,则return ERROR while( q != NULL ) //q按照原来的顺序依次遍历各结点 &#123; cur = q; //cur为当前结点 q = q-&gt;link; //q保存下一个结点 L-&gt;head-&gt;link = cur; //为了不动头结点,所以头结点link始终指向当前要加的结点 cur-&gt;link = p; //当前的link指向上一个结点 p = cur; //保存上一个结点 &#125; &#125;else return ERROR; return OK;&#125;Status Insert(Headlist *L,int j,ElemType x)&#123; Node *p=NULL,*q=NULL; int i; if(j&lt;-1 || j&gt; L-&gt; n-1) return ERROR; p = L-&gt;head; for(i=0;i&lt;=j;i++) p=p-&gt;link; q = (Node *)malloc(sizeof(Node)); q-&gt;elem = x; q-&gt;link = p-&gt;link; p-&gt;link = q; L-&gt;n++; return OK;&#125;Status Output(Headlist L)&#123; Node *p = L.head-&gt;link; if(!L.n) return ERROR; while(p)&#123; printf(\"%d \",p-&gt;elem ); p = p-&gt;link; &#125; return OK;&#125;Status Destory(Headlist *L)&#123; Node *p=NULL; while(L-&gt;head)&#123; //不断删除head所指向的内存,直到head被释放 p = L-&gt;head-&gt;link; free(L-&gt;head); L-&gt;head = p; &#125; return OK; &#125;Status Delete(Headlist *L,int j)&#123; //下标j Node *p = L-&gt;head,*q = L-&gt;head; // q = tmp int i; if(!L-&gt;n) return ERROR; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j-1;i++) p = p-&gt;link; q = p; p = p-&gt;link; q-&gt;link = p-&gt;link; free(p); return OK;&#125;Status Find(Headlist *L,int j,ElemType *x)&#123; Node *p= L-&gt;head; int i; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j;i++) p = p-&gt;link; *x = p-&gt;elem; return OK;&#125;int main()&#123; int x; Headlist list; Init(&amp;list); Insert(&amp;list,-1,3); Insert(&amp;list,0,2); Insert(&amp;list,-1,5); Insert(&amp;list,2,7); Insert(&amp;list,-1,1); printf(\"the linked list is :\"); Output(list); printf(\"\\nAfter sorted:\"); Sort(&amp;list); Output(list); printf(\"\\nAfter Conversed:\"); Converse(&amp;list); Output(list); printf(\"\\nAfter delete index of 0,the list is:\"); Delete(&amp;list,0); Output(list); Find(&amp;list,2,&amp;x); printf(\"\\nthe index of 2:%d\\n\",x); Destory(&amp;list); system(\"pause\"); return 0;&#125;//无论是什么都要略过head表头结点,表头结点的elem是任意的. (一)实验中遇到的主要问题及解决方法 1.题目二，带表头的单链表在插入时出现了点问题，书上给出的方法是错的，且是C++代码。于是在尝试理解他的想法及每步Debug中终于写出了正确的代码。（L-&gt;head-&gt;link = NULL,其中L-&gt;head-&gt;data 不填） 2.题目二中带表头节点的单链表中插入时for( j=0;j&lt;=i; j++) 和之前j&lt;i以及删除时for( j=0;j&lt;=i-1; j++) 和之前j&lt;i-1有很大不同,通过debug知道了是为了略过第一个表头节点。 3.逆置过程中,为了不动表头,略过第一个表头结点时出现了点麻烦.并且在第一个元素逆置后指向NULL,第二个结点指向第一个结点时没有想明白,后来才想到了先让P=NULL,然后记录上一个结点就能达到效果了.同时还有个问题是一直没有保存原来链表的顺序,再因为P=NULL导致会访问到非法内存而程序崩溃 （二）实验心得 2.题目二中,带表头单链表和不带表头单链表,在删除和插入时的循环条件不同要注意.及初始化时带表头的L-&gt;head-&gt;link= NULL; 与 无表头的 L-&gt;first = NULL;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"带表头的单链表应用——多项式","slug":"带表头的单链表应用——多项式","date":"2018-09-27T14:04:31.000Z","updated":"2018-09-27T14:26:11.753Z","comments":true,"path":"2018/09/27/带表头的单链表应用——多项式/","link":"","permalink":"https://nymrli.top/2018/09/27/带表头的单链表应用——多项式/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct PNode&#123; ElemType ceof; ElemType exp; struct PNode *link;&#125;PNode;typedef struct &#123; struct PNode *head;&#125;polynominal;Status Init(polynominal *p)&#123; p-&gt;head = (PNode *)malloc(sizeof(PNode)); p-&gt;head-&gt;exp = -1; p-&gt;head-&gt;link = NULL; return OK;&#125;Status Create(polynominal *p)&#123; PNode *pn = NULL,*q=NULL,*pre=NULL; Init(p); //p-&gt;head = (PNode *)malloc(sizeof(PNode)); //p-&gt;head-&gt;exp = -1; //p-&gt;head-&gt;link = NULL; for (;;) // &lt;==&gt;while(1) &#123; pn = (PNode *)malloc(sizeof(PNode)); printf(\"ceof:\\n\"); scanf(\"%d\",&amp;pn-&gt;ceof); printf(\"exp:\\n\"); scanf(\"%d\",&amp;pn-&gt;exp); if (pn-&gt;exp &lt; 0) &#123;printf(\"End the input\\n\"); break;&#125; pre = p-&gt;head; //pre从链表头开始 q=p-&gt;head-&gt;link; while(q &amp;&amp; q-&gt;exp &gt; pn-&gt;exp)&#123; //pn为当前结点,q为链表中结点 pre = q; // q = q-&gt;link; &#125; pn-&gt;link = q; // 在pre和q之间插入pn,(q为null时,相当于末尾插入pn) pre-&gt;link = pn; // pre =&gt; pn =&gt; q &#125; return OK;&#125;Status Sort(polynominal *L)&#123; //从大到小 PNode *p=L-&gt;head,*pre=NULL; PNode *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;exp &lt; p-&gt;exp) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125; return OK;&#125;Status Add(polynominal *px,polynominal *qx)&#123; //目的:将q改成p+q PNode *q1=qx-&gt;head, *p=px-&gt;head-&gt;link; //q1指向qx表头结点 PNode *q=q1-&gt;link; //p指向多项式px第一个结点,q指向qx第一个 PNode *temp = NULL; //q1是q前驱 while( q &amp;&amp; p)&#123; while( p-&gt;exp &lt; q-&gt;exp )&#123; //找到qx中 大于等于q指数项的项,q不断右移 q1 = q; q = q-&gt;link; &#125; if (p-&gt;exp == q-&gt;exp )&#123; q-&gt;ceof = q-&gt;ceof + p-&gt;ceof; if (q-&gt;ceof == 0)&#123; q1-&gt;link = q-&gt;link; //释放当前q的内存 free(q); q = q1-&gt;link; p = p-&gt;link; &#125;else&#123; //p\\q都右移 q1 = q; //q1 q = q-&gt;link; p = p-&gt;link; &#125; &#125;else&#123; //p-&gt;exp &gt; q-&gt;exp temp = (PNode * )malloc(sizeof(PNode)); temp-&gt;ceof = p-&gt;ceof; temp-&gt;exp = p-&gt;exp; temp-&gt;link = q1-&gt;link; q1-&gt;link = temp; p = p-&gt;link; &#125; &#125; return OK;&#125;void Output(polynominal *p)&#123; PNode *q = p-&gt;head-&gt;link; int last = 0; while( q!=NULL )&#123; if(q-&gt;link == NULL) last =1; printf(\"%dx^%d\", q-&gt;ceof,q-&gt;exp); if(!last) printf(\"+\"); //此处注意个+的小细节 q = q-&gt;link; &#125; printf(\"\\n\");&#125;void Destory(polynominal *p)&#123; PNode *q = NULL; while(p-&gt;head)&#123; //不断删除head所指向的内存,直到head被释放 q = p-&gt;head-&gt;link; free(p-&gt;head); p-&gt;head = q; &#125;&#125;/***********合并同类项*****************//***********合并即free*****************/Status unify(polynominal *t)&#123; PNode *p=NULL; PNode *q=NULL; PNode *last=NULL; PNode *tmp; //while(p-&gt;link != NULL)&#123; for(p=t-&gt;head-&gt;link;p!=NULL;p=p-&gt;link)&#123; //选择 last = p; for(q=last-&gt;link; q!=NULL ; )&#123; //q指针向后推移指向下一结点 if(q-&gt;exp == p-&gt;exp)&#123; //相等计算 p-&gt;ceof += q-&gt;ceof; //q为 滑动项 tmp = q-&gt;link; last-&gt;link = q-&gt;link; //last保存上一个q free(q); // 吧q的空间释放掉 q= tmp; &#125;else&#123; last= q; q=q-&gt;link;&#125; //如果不相等就判断下一个 &#125; &#125; return OK;&#125;polynominal Multiply(polynominal *px,polynominal *qx)&#123; PNode *p = px-&gt;head; PNode *q = qx-&gt;head; PNode *x = NULL; PNode *tmp = NULL; polynominal newpoly; Init(&amp;newpoly); x = newpoly.head; for (p=px-&gt;head-&gt;link; p!=NULL; p=p-&gt;link)&#123; for (q=qx-&gt;head-&gt;link; q!=NULL; q=q-&gt;link)&#123; tmp = (PNode*)malloc(sizeof(PNode)); tmp-&gt;ceof = p-&gt;ceof * q-&gt;ceof; tmp-&gt;exp = p-&gt;exp + q-&gt;exp; tmp-&gt;link = x-&gt;link; //新生成的结点指向上一个生成的结点的地址 x-&gt;link = tmp; //使链表记录当前tmp结点 x = x-&gt;link; //取下一个结点 &#125; &#125; unify(&amp;newpoly); Sort(&amp;newpoly); return newpoly;&#125;int main()&#123; polynominal p,q; polynominal mul; Create(&amp;p); Output(&amp;p); // printf(\"After unify:\\n\"); Unify // unify(&amp;p); // Output(p); Create(&amp;q); Output(&amp;q); // Add(&amp;p,&amp;q); ADD // printf(\"q:\"); // Output(q); printf(\"After Multiplied:\\n\"); mul = Multiply(&amp;p,&amp;q); Output(&amp;mul); system(\"pause\"); return 0;&#125;//其中Sort,unify,add,multiply,需要捉摸一下 (一)实验中遇到的主要问题及解决方法 1.题目二，带表头的单链表在插入时出现了点问题，书上给出的方法是错的，且是C++代码。于是在尝试理解他的想法及每步Debug中终于写出了正确的代码。（L-&gt;head-&gt;link = NULL,其中L-&gt;head-&gt;data 不填） 2.题目二中带表头节点的单链表中插入时for( j=0;j&lt;=i; j++) 和之前j&lt;i以及删除时for( j=0;j&lt;=i-1; j++) 和之前j&lt;i-1有很大不同,通过debug知道了是为了略过第一个表头节点。 3.逆置过程中,为了不动表头,略过第一个表头结点时出现了点麻烦.并且在第一个元素逆置后指向NULL,第二个结点指向第一个结点时没有想明白,后来才想到了先让P=NULL,然后记录上一个结点就能达到效果了.同时还有个问题是一直没有保存原来链表的顺序,再因为P=NULL导致会访问到非法内存而程序崩溃 4.合并同类项的过程中,使用了选择排序类似的思想,但是在里层for(q=last-&gt;link; q!=NULL ; )出了问题,一开始写成 for(q=last-&gt;link; q!=NULL ; q=q-&gt;link)但是如果指数相等,q就会被free掉,此时q=q-&gt;link就会出问题 （二）实验心得 1.题目一中，顺序表是malloc动态申请的空间，是连续的，可以直接通过下标访问。 2.题目二中,带表头单链表和不带表头单链表,在删除和插入时的循环条件不同要注意.及初始化时带表头的L-&gt;head-&gt;link = NULL; 与 无表头的 L-&gt;first = NULL; 3.Debug过程中F10和F11的区别,在malloc和free处按F11会进入malloc函数、free函数的汇编的运行过程 4.排序和逆置时都要有个指针记住原来链表的顺序,然后才能再依次按顺序进行. 5.理清要做的事,再下手写代码,画图有时很重要.","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"小程序蓝牙","slug":"小程序蓝牙API","date":"2018-09-20T02:57:01.000Z","updated":"2018-10-04T12:30:02.067Z","comments":true,"path":"2018/09/20/小程序蓝牙API/","link":"","permalink":"https://nymrli.top/2018/09/20/小程序蓝牙API/","excerpt":"","text":"提供蓝牙模块APIwx.openBluetoothAdapter(OBJECT)​ 初始化小程序蓝牙模块 wx.closeBluetoothAdapter(OBJECT)​ 关闭蓝牙模块，使其进入未初始化状态。 wx.getBluetoothAdapterState(OBJECT)​ 获取本机蓝牙适配器状态 wx.onBluetoothAdapterStateChange(CALLBACK)​ 监听蓝牙适配器状态变化事件 wx.startBluetoothDevicesDiscovery(OBJECT)​ 开始搜寻附近的蓝牙外围设备。注意，该操作比较耗费系统资源，请在搜索并连接到设备后调用 stop 方法停止搜索。 wx.stopBluetoothDevicesDiscovery(OBJECT)​ 停止搜寻附近的蓝牙外围设备。若已经找到需要的蓝牙设备并不需要继续搜索时，建议调用该接口停止蓝牙搜索。 wx.getBluetoothDevices(OBJECT)​ 获取在小程序蓝牙模块生效期间所有已发现的蓝牙设备，包括已经和本机处于连接状态的设备。 wx.onBluetoothDeviceFound(CALLBACK)​ 监听寻找到新设备的事件 wx.createBLEConnection(OBJECT)​ 连接低功耗蓝牙设备。 wx.closeBLEConnection(OBJECT)​ 断开与低功耗蓝牙设备的连接 wx.getBLEDeviceServices(OBJECT)​ 获取蓝牙设备所有 service（服务） wx.getBLEDeviceCharacteristics(OBJECT)​ 获取蓝牙设备某个服务中的所有 characteristic（特征值） wx.readBLECharacteristicValue(OBJECT)​ 读取低功耗蓝牙设备的特征值的二进制数据值。注意：必须设备的特征值支持read才可以成功调用，具体参照 characteristic 的 properties 属性 wx.writeBLECharacteristicValue(OBJECT)​ 向低功耗蓝牙设备特征值中写入二进制数据。注意：必须设备的特征值支持write才可以成功调用，具体参照 characteristic 的 properties 属性 tips: 并行调用多次读写接口存在读写失败的可能性* wx.notifyBLECharacteristicValueChange(OBJECT)​ 启用低功耗蓝牙设备特征值变化时的 notify 功能，订阅特征值。注意：必须设备的特征值支持notify或者indicate才可以成功调用，具体参照 characteristic 的 properties 属性 ​ 另外，必须先启用notify才能监听到设备 characteristicValueChange 事件 wx.onBLEConnectionStateChange(CALLBACK)​ 监听低功耗蓝牙连接状态的改变事件，包括开发者主动连接或断开连接，设备丢失，连接异常断开等等 wx.onBLECharacteristicValueChange(CALLBACK)​ 监听低功耗蓝牙设备的特征值变化。必须先启用notify接口才能接收到设备推送的notification。 ### 示例代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// pages/bluetooth/bluetooth.jsPage(&#123; data:&#123;&#125;, onLoad:function(options)&#123; // 页面初始化 options为页面跳转所带来的参数 &#125;, //初始化蓝牙适配器 openBluetooth:function()&#123; wx.openBluetoothAdapter(&#123; success: function(res)&#123; console.log(res.errMsg) // success wx.showToast(&#123; title:\"初始化蓝牙适配器成功\", duration:2000 &#125;) &#125;, &#125;) &#125;,//关闭蓝牙模块closeBluetooth:function()&#123; wx.openBluetoothAdapter() wx.closeBluetoothAdapter(&#123; success: function(res)&#123; // success console.log(\"success\"+res) &#125; &#125;)&#125;,//获取本机蓝牙适配器状态getBluetoothAdapterState:function()&#123;wx.getBluetoothAdapterState(&#123; success: function(res)&#123; // success console.log(\"res:\"+res) console.log(\"errMsg:\"+res.errMsg) &#125;&#125;)&#125;,//监听蓝牙适配器状态变化事件 onBluetoothAdapterStateChange:function()&#123; wx.onBluetoothAdapterStateChange(function(res) &#123; console.log(`adapterState changed, now is`, res) &#125;)&#125;, // 开始搜寻附近的蓝牙外围设备 startBluetoothDevicesDiscovery:function()&#123; wx.startBluetoothDevicesDiscovery(&#123; success: function (res) &#123; console.log(res) &#125; &#125;)&#125;, // 停止搜寻附近的蓝牙外围设备 stopBluetoothDevicesDiscovery:function()&#123; wx.stopBluetoothDevicesDiscovery(&#123; success: function (res) &#123; console.log(res) &#125; &#125;)&#125;, //获取所有已发现的蓝牙设备 getBluetoothDevices:function()&#123; wx.getBluetoothDevices(&#123; success: function(res)&#123; // success console.log(res) &#125;, &#125;) &#125;, //监听寻找到新设备的事件 onBluetoothDeviceFound:function()&#123; wx.onBluetoothDeviceFound(function(res) &#123; // callback console.log(res) &#125;) &#125;, //根据 uuid 获取处于已连接状态的设备 getConnectedBluetoothDevices:function()&#123; wx.getConnectedBluetoothDevices(&#123; success: function (res) &#123; console.log(res) &#125;&#125;)&#125;,//连接低功耗蓝牙设备createBLEConnection:function()&#123; wx.createBLEConnection(&#123; deviceId: 'AC:BC:32:C1:47:80', success: function(res)&#123; // success console.log(res) &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;,//断开与低功耗蓝牙设备的连接closeBLEConnection:function()&#123; wx.closeBLEConnection(&#123; deviceId: 'AC:BC:32:C1:47:80', success: function (res) &#123; console.log(res) &#125;&#125;)&#125;,//监听低功耗蓝牙连接的错误事件，包括设备丢失，连接异常断开等等onBLEConnectionStateChanged:function()&#123; wx.onBLEConnectionStateChanged(function(res) &#123; console.log(`device $&#123;res.deviceId&#125; state has changed, connected: $&#123;res.connected&#125;`)&#125;)&#125;,//获取蓝牙设备所有 service（服务）getBLEDeviceServices:function()&#123; wx.getBLEDeviceServices(&#123; deviceId: '48:3B:38:88:E3:83', success: function(res)&#123; // success console.log('device services:', res.services.serviceId) &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;,//获取蓝牙设备所有 characteristic（特征值）getBLEDeviceCharacteristics:function()&#123; wx.getBLEDeviceCharacteristics(&#123; deviceId: '48:3B:38:88:E3:83', serviceId: 'serviceId', success: function(res)&#123; // success &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;&#125;)","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"电信路由器上网","slug":"电信路由器上网","date":"2018-09-20T02:01:16.000Z","updated":"2018-10-04T07:32:40.777Z","comments":true,"path":"2018/09/20/电信路由器上网/","link":"","permalink":"https://nymrli.top/2018/09/20/电信路由器上网/","excerpt":"","text":"链接: https://pan.baidu.com/s/1QaW7DMhjb2YHd0ZVWterSw 密码：联系QQ1063052964,或是在下方评论处留言QQ","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"小程序入门学习","slug":"小程序入门学习","date":"2018-09-20T01:57:01.000Z","updated":"2018-09-20T02:06:14.438Z","comments":true,"path":"2018/09/20/小程序入门学习/","link":"","permalink":"https://nymrli.top/2018/09/20/小程序入门学习/","excerpt":"","text":"IDE搭建:下载:微信公众平台官网 预备知识: 个人认为入门小程序相对比较简单,需要了解HTML+CSS 大概知道是干啥的就行,JavaScrip还是要看看的，推荐教程 廖雪峰的博客以及W3Cschool的JS教程 项目目录结构介绍: 小程序中一共有四种类型的文件: js ———- JavaScrip文件 json ——– 项目配置文件，负责窗口颜色等等 wxml ——- 类似HTML文件 wxss ——- 类似CSS文件 重要文件-APP讲解: app.json(必需) :监听并处理小程序的生命周期函数、声明全局变量。 app.js(建议保存) : *作为配置整个APP的入口,可以什么都不写只输入{}.对整个小程序的全局配置。记录了页面组成(定义了每个页面)，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。* ​ ==&gt;没有最简单的小程序也能运行. app.wxml app.wxss ===&gt; 所以只有app.js和app.json的项目是最简单的小程序 具体页面下的 js文件配置页面入口 wxml配置布局 一起完成对页面的渲染 wxss样式文件 json配置文件 会覆盖app.json和app.wxss全局设置的内容,实现单个网页的个性化 app.js 12345678910111213141516171819202122232425262728293031323334353637Page(&#123; //* 页面的初始数据 data: &#123; &#125;, // * 生命周期函数--监听页面加载 onLoad: function (options) &#123; &#125;, //* 生命周期函数--监听页面初次渲染完成 onReady: function () &#123; &#125;, //* 生命周期函数--监听页面显示 onShow: function () &#123; &#125;, //* 生命周期函数--监听页面隐藏 onHide: function () &#123; &#125;, //* 生命周期函数--监听页面卸载 onUnload: function () &#123; &#125;, //* 页面相关事件处理函数--监听用户下拉动作 onPullDownRefresh: function () &#123; &#125;, //* 页面上拉触底事件的处理函数 onReachBottom: function () &#123; &#125;, //* 用户点击右上角分享 onShareAppMessage: function () &#123; &#125;&#125;) app.json 1234&quot;pages&quot;:[ &quot;pages/index/index&quot; //pages 里面的路径其实是指向js文件的,其中第一个就是登陆首页] 实现路由配置,及全局的某些设置 app.js** 定义了每个页面,每个页面的.js又调用了Page()方法实现该页面的配置信息 小程序事件 事件 == 事件类型+具体事件 具体事件 tap longtap toustart、touchend、touchmove、touchcancel(电话中断) submint、input…… 事件类型 bind 冒泡事件 catch 非冒泡事件 currentTarget 被绑定的组件 dataset 控件相应的属性 target 发生事件的组件 页面跳转 navigateTo({ url :&#39;xxx&#39; }) &lt;navigator url=&quot;../logs/logs?id=1&amp;title=&#39;as&#39;&quot; &gt; &lt;/navigator&gt; Flex容器和元素容器属性 flex-direction : 决定主轴方向 flex-wrap : 处理如何换行 flex-flow : flex-dirction和flex-wrap合并简写 justify-content: 元素在主轴的对齐方式 space-bewteen 两端对齐 center 居中对齐 flex-start 左侧对齐 flex-end 右侧对齐 align-items : 元素在交叉轴的对齐方式 stretch 拉伸,当没设置item高度时,占满整个容器 baseline :以文字为底线对齐 元素属性 flex-grow (默认0): 当有多余空间时,元素的放大比例 flex-shrink(默认1) : 当空间不足时,元素的放大比例 flex-basis: 元素在主轴上占据的空间 flex : flex-grow、flex-shrink、flex-basis的合并简写 order : 定义元素的排列顺序 align-self : 定义元素自身的对齐方式 定位 相对定位: 相对定位的元素是相对自身进行定位,参照物是自己 绝对定位 : 绝对定位的元素是相对离它最近的一个已定位的父级元素进行定位,如果没有,则以整个页面进行定位 margin和padding的区别 margin是指从 自身边框 到 另一个容器边框 之间的距离，就是容器外距离。（外边距） padding是指 自身边框 到 自身内部另一个容器边框 之间的距离，就是容器内距离。（内边距） rpx 动态单位 css布局实例123456789101112wxml: &lt;view class='list-item' wx:for=\"&#123;&#123;listItem&#125;&#125;\"&gt; &lt;view class='list-item-images'&gt; &lt;image src='../../images/img2.png' class='list-item-images-img' /&gt; &lt;!-- &lt;image class='avatar' src='../../images/avatar.png'/&gt; --&gt; &lt;/view&gt; &lt;view class=\"list-item-text\"&gt; &lt;text&gt;这是一个标题&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415wxss:.list-item&#123; height:500rpx; //整个 图片+文字 一共高为500rpx width: 100%;&#125; .list-item-images&#123; height: 300rpx; // 其中图片的高度为300rpx width: 100%;&#125;.list-item-images image&#123; //图片高、宽全部伸展 height: 100%; width: 100%;&#125;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"Spy++使用介绍","slug":"Spy-使用介绍","date":"2018-09-02T11:39:45.000Z","updated":"2018-09-02T11:40:26.032Z","comments":true,"path":"2018/09/02/Spy-使用介绍/","link":"","permalink":"https://nymrli.top/2018/09/02/Spy-使用介绍/","excerpt":"","text":"Spy++ (SPYXX.EXE) 是一个基于 Win32 的实用工具，它提供系统的进程、线程、窗口和窗口消息的图形视图。使用 Spy++ 可以执行下列操作： 显示系统对象（包括进程、线程和窗口）之间关系的图形树。 搜索指定的窗口、线程、进程或消息。 查看选定的窗口、线程、进程或消息的属性。 我们可以使用微软的Spy++来查看窗口类名等信息，然后再结合pywin32实现。 加载初始界面: 然后点击工具栏的望远镜。如图所示: 出现搜索窗口，然后通过移动靶心到想要查找句柄的窗口后单击就行了。==&gt;它的句柄、标题、类都会显示 再点击确定。 此时会有两种情况。 成功搜索到 搜索不到 原因是你查找的窗口是在打开spy++后打开的，解决的办法就是按F5进行刷新，然后就行了 成功后都会出现如下： 右键，点击“属性”能看到更多详细内容。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"解决安装PyUserInput、pyHook遇到的问题——AttributeError: 'HookManager' object has no attribute 'keyboard_hook","slug":"解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook","date":"2018-09-02T11:33:32.000Z","updated":"2018-09-02T11:33:55.065Z","comments":true,"path":"2018/09/02/解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook/","link":"","permalink":"https://nymrli.top/2018/09/02/解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook/","excerpt":"","text":"安装PyUserInput失败。 经查看发现是pyHook（pyHook是一个用来进行键盘、鼠标等层面事件监控的库。这个库的正常工作需要pythoncom等操作系统的API的支持。）无法安装，不知道是不是因为这个库可以被用于一些比较邪恶的目的。经搜索发现直接pip install pyHook是找不到相关包的，但可以下源码编译安装，可以在 https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyhook 这里可以直接下载到.whl文件，这个文件可以作为pip install 的参数来进行安装。 直接输入pip install pyHook-1.5.1-cp36-cp36m-win_amd64.whl好像还是不行，经提示使用G:\\Py_opencv\\venv\\Scripts\\python.exe -m pip install pyHook-1.5.1-cp36-cp36m-win_amd64.whl第一个参数是python解释器，-m选项可以让python以脚本的方式运行一个模块，pip install后面就是要安装的包名。 pyHook-1.5.1-cp36-cp36m-win_amd64.whl pyHook:库名1.5.1：版本号cp3.6m：Cpython3.6版本,编码是ucs2,UCS2认为每个字符占用2个字节，UCS4认为每个字节占用4个字符，都是UNICODE的编码形式。win_amd64:windows64位环境whl:压缩包，在其中包含了py文件，以及经过编译的pyd文件。可以使用pip安装 电脑系统环境查看，可以右键“我的电脑”-&gt;“属性”查看 然后再直接在命令行里输入pip install pyuserinput或是在pycharm下载安装都可以了。（需要先安装pywin32） 上述下载的pyHook是基于Python2的,在python3下会报错:TypeError: MouseSwitch() missing 8 required positional arguments: &#39;msg&#39;, &#39;x&#39;, &#39;y&#39;, &#39;data&#39;, &#39;flags&#39;, &#39;time&#39;, &#39;hwnd&#39;, and &#39;window_name&#39;或者AttributeError: &#39;HookManager&#39; object has no attribute &#39;keyboard_hook&#39; 感谢:python3.5安装pyHook,解决【TypeError: MouseSwitch() missing 8 required positional arguments: ‘msg’, ‘x’, ‘y’, ‘data’, ‘time’, ‘hwnd’, and ‘window_name’】这个错误！、使用Python 3.5/3.6监听本机任意窗口中的按键操作提供的解决方法 需要的模块：扩展库pyhook_py3k（注意，不要使用pyhook），pywin32。第一步，安装pywin32，地址：http://www.lfd.uci.edu/~gohlke/pythonlibs/#pywin32第二步，下载pyhook_py3k，地址：https://github.com/Answeror/pyhook_py3k第三步，下载swig.exe，地址：http://www.swig.org/download.html ==&gt;.zip格式解压第四步，解压缩pyhook_py3k，并进行编译，命令：python setup.py build_ext –swig=..\\swigwin-3.0.12\\swig.exe，可以根据实际情况修改swig.exe的路径，另外本机最好已安装VC2008第五步，安装编译好的pyhook_py3k，命令：pip install . 然后就可以正常操作了!!~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"开学小蓝车180天免费卡","slug":"开学小蓝车180天免费卡","date":"2018-09-02T08:44:54.000Z","updated":"2019-01-19T14:27:25.771Z","comments":true,"path":"2018/09/02/开学小蓝车180天免费卡/","link":"","permalink":"https://nymrli.top/2018/09/02/开学小蓝车180天免费卡/","excerpt":"各位看客老爷,可以加下我的公众号哦!虽然没啥东东….微信搜索公众号”我只要瓶果粒橙就好” 原来是180天的,现在好像只有30还是60天了..","text":"各位看客老爷,可以加下我的公众号哦!虽然没啥东东….微信搜索公众号”我只要瓶果粒橙就好” 原来是180天的,现在好像只有30还是60天了..","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"例题4:1-3 古老的密码、刽子手的游戏，救济金发放","slug":"例题4-1-3-古老的密码、刽子手的游戏，救济金发放","date":"2018-09-01T10:46:59.000Z","updated":"2018-09-01T12:38:41.000Z","comments":true,"path":"2018/09/01/例题4-1-3-古老的密码、刽子手的游戏，救济金发放/","link":"","permalink":"https://nymrli.top/2018/09/01/例题4-1-3-古老的密码、刽子手的游戏，救济金发放/","excerpt":"","text":"例题4-1 古老的密码 因为字母可以重排,所以顺序不重要,而又同时因为可以映射,所以字母具体是什么不重要==&gt;只要统计排序后的结果相同就行了 RE(Runtime error)错法加一: 题号提交错误 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;void Bubblesort(int *cnt)//冒泡排序,从大到小顺序&#123; int i,j; int min=cnt[0]; for (i = 0; i &lt;26; ++i) &#123; for ( j = i+1; j &lt; 26; ++j) &#123; if (cnt[i] &lt; cnt[j]) &#123; min = cnt[i]; cnt[i]=cnt[j]; cnt[j] = min; &#125; &#125; &#125;&#125;int main()&#123; char s[2][105]; //存放猜测字符串的 int cnt[2][27]; //存放字母出现次数 int nlen[2]; //字符串的长度 while(scanf(\"%s%s\",s[0],s[1])!= EOF) &#123; memset(cnt,0,sizeof(cnt)); int i; for ( i = 0; i &lt; 2; ++i) &#123; nlen[i]= strlen(s[i]); int j; for ( j = 0; j &lt; nlen[i]; ++j) cnt[i][s[i][j]-'A'] ++; Bubblesort(cnt[i]); &#125; int k; for ( k = 0; k &lt; 26; ++k) &#123; if (cnt[0][k] != cnt[1][k]) &#123; printf(\"NO\\n\"); break; &#125; &#125; if (k==26) printf(\"YES\\n\" ); //如果26个字母出现次数比完全相等,则可以说相同. &#125; return 0;&#125; 例题4-2 刽子手的游戏 注意全局变量是否使用的问题,全局变量尽量少用…但维护内容较多的情况下,可以考虑 采用”自顶向下”的顺序 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 100char ans[maxn],gue[maxn];int left,chance;int win,lose;void guess(char ch)&#123; int bad=1; int i; for ( i = 0; i &lt; strlen(ans); ++i) //判断ch字母是否在字符串中 &#123; if (ans[i]==ch) &#123; ans[i] = ' '; bad =0; left--; //如果在的话,还剩未猜中字母数-1,机会不变 &#125; &#125; if (bad) chance--; //如果不在的话机会-1 if(!chance) lose=1; if(!left) win=1;&#125;int main()&#123; int rnd; while(scanf(\"%d%s%s\",&amp;rnd,ans,gue)==3 &amp;&amp; rnd !=-1) &#123; printf(\"Round %d\\n\",rnd); win = lose =0; left= strlen(ans); chance = 7; int i; int anslen=strlen(gue); for( i=0;i&lt; anslen;i++) &#123; guess(gue[i]); if(win || lose) break;&#125; if(win) printf(\"You win.\\n\"); else if(lose) printf(\"You lose.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;char a[1000],g[1000];//储存字符串 int abook[26],gbook[26];//标记26个字母出现频率 int main()&#123; int k; int alen,glen; int i; int j; int suc,fau; int acount; while(scanf(\"%d\",&amp;k)==1&amp;&amp;k!=-1)&#123; scanf(\"%s%s\",a,g); memset(abook,0,sizeof(abook)); memset(gbook,0,sizeof(gbook)); alen=strlen(a); glen=strlen(g); for(i=0;i&lt;alen;i++)//统计答案字母频率 abook[a[i]-'a']++; acount=0; for(i=0;i&lt;26;i++) if(abook[i])//统计答案的字母组成个数（扣除雷同字母） acount++; suc=0;//猜对次数 fau=0;//猜错次数 for(i=0;i&lt;glen;i++)&#123;//以猜测字母为基准进行扫描 j=g[i]-'a'; if(abook[j]==0)&#123;//答案无此字母，猜测错误 fau++; if(fau==7)//彻底失败 break; &#125;else if(abook[j]!=0)&#123;//猜中字母 suc++; abook[j]=0;//将此字母从答案中剔除出去，此句比较关键!(再猜无效) if(suc==acount)//成功 break; &#125; &#125; printf(\"Round %d\\n\",k); if(fau&gt;=7)//猜错7次及以上 printf(\"You lose.\\n\"); else if(suc==acount)//全部猜对 printf(\"You win.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 例题4-3 救济金发放 圆圈如何轮回==&gt;本质上是要求,大于n变成1,小于1变成n…实现1.越界后归正。2.(xxx)%n, 领过设为1,没领过(初始)设为1 较为简洁、清晰的做法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;string.h&gt;int book[100];//领过的标记1，没领过的标记0 int main()&#123; int n,k,m; int kcount,mcount; int ki,mi; int kout,mout; int first; int ncount; while(scanf(\"%d%d%d\",&amp;n,&amp;k,&amp;m)==3&amp;&amp;n&amp;&amp;k&amp;&amp;m)&#123; memset(book,0,sizeof(book)); ncount=0; ki=0; mi=n+1; first=1; while(ncount!=n)&#123;//n个人全被处理完毕//处理手法有些类似快速排序 kcount=0; mcount=0; //每数一个人,都要判断是不是该越过他.只有0(未领过,才计数) while(kcount!=k)&#123;//k系列处理 ki++; if(ki&gt;n)//ki越界处理 ki=1; if(book[ki]==0)//未被选中计数 ki为当前值 kcount++; &#125; while(mcount!=m)&#123;//m系列处理 mi--; if(mi&lt;1)//mi越界处理 mi=n; if(book[mi]==0)//未被选中计数 mi为当前值 mcount++; &#125; book[ki]=1;//不用担心ki==mi(重复设置为1不影响) book[mi]=1; if(first)&#123;//打印处理 first=0; if(ki!=mi)&#123; printf(\"%3d%3d\",ki,mi); ncount+=2; &#125; else&#123; printf(\"%3d\",ki); ncount++; &#125; &#125;else&#123; if(ki!=mi)&#123; printf(\",%3d%3d\",ki,mi); ncount+=2; &#125; else&#123; printf(\",%3d\",ki); ncount++; &#125; &#125; &#125; printf(\"\\n\"); &#125; return 0;&#125; 书上做法123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 25int n,k,m,a[maxn];int go(int p,int d,int t)&#123; while(t--) //每数一个人都要判断他是否已经领过 do&#123; p = (n+p+d)%n; &#125;while(!a[p]); //==0,领过 return p;&#125;int main()&#123; while(scanf(\"%d,%d,%d\",&amp;n,&amp;k,&amp;m)==3 &amp;&amp; n) &#123; for (int i = 0; i &lt; n; ++i) a[i]=i; int left =n; int p1 =n,p2=1; while(left) &#123; p1= go(p1,-1,k); p2= go(p2,1,m); printf(\"%d\",p1);left--; if(p1!=p2) printf(\" %d\",p2); a[p1]=a[p2]=0; //领了设置为0 if(left) printf(\",\"); //注意输出格式 &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"},{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"WampSever配置本地环境，解决打开打开本地网站问题","slug":"WampSever配置本地环境，解决打开打开本地网站问题","date":"2018-09-01T06:19:39.000Z","updated":"2018-09-01T06:26:52.393Z","comments":true,"path":"2018/09/01/WampSever配置本地环境，解决打开打开本地网站问题/","link":"","permalink":"https://nymrli.top/2018/09/01/WampSever配置本地环境，解决打开打开本地网站问题/","excerpt":"","text":"WampServer是一款由法国人开发的Apache Web服务器、PHP解释器以及MySQL数据库的整合软件包。免去了开发人员将时间花费在繁琐的配置环境过程，从而腾出更多精力去做开发。 直接点击本地的.html是静态加载的，需要动态加载的文件是无法被加载的。会出现如下情况。 于是选用了Wamp搭本地服务器浏览网站，这样就能成功加载动态文件了。 在此分享下配置WampSever时碰到的问题和解决的方法： 服务器是否已正常运行如果能登上则表示服务器能够正常运行。(在地址栏中输入localhost:端口(或是127.0.0.1:端口) 或是左键图标选择’localhost’) localhost 指你所在的计算机本身。 在windows系统它成了127.0.0.1的别名 ，在Unix系统下，查看网卡配置会发现作为本地回环的方式，一定程度上使用localhost比127.0.0.1要快一些。 在Hosts文件中，localhost指向的IP是127.0.0.1这个关系是可以修改的。 查看、修改端口 配置本地环境、添加项目、打开本地网站 1项目中是空的,需要手动将要打开的网站放到&apos;www&apos;目录中 1可以选择输入路径，也可以直接左键选择&apos;www目录&apos;打开 1将要打开网站的文件夹复制到&apos;www目录下&apos;，会发现刚添加的文件夹出现在了项目中。 勾选’Add localhost in url’1看似到此已经大功告成，然而再点击进去这些文件夹时会出现如下情况： 1可以看到的是URL并不对，我们是想要实现通过web服务器的方式访问这些网站，然而这个明显没达到我们想要的效果，根据提示，我找到了原因。 1右键选择&apos;Wamp Settings&apos;中将&apos;Add localhost in url&apos;选项勾上后再次如上打开项目即可。（记得重新打开一次localhost页面或是刷新一下） 1可以看到网站成功地通过web服务器打开了，那些之前提示需要动态加载的文件也成功加载了。 撒花完结！~200成功！ ▲.看到这，我相信你也明白了为什么必须要有’Add localhost in url’这步了。同时也猜到了，其实直接在网址里面输入正确的网址也是可以的，如http://localhost:8080/data-visualize-chain-master/,结果也是能打开的。 希望能对你们有所帮助。","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"WAMP","slug":"WAMP","permalink":"https://nymrli.top/tags/WAMP/"}]},{"title":"Ubuntu下Sublime配置Python环境使用指导:","slug":"Ubuntu下Sublime配置Python环境使用指导","date":"2018-09-01T06:04:47.000Z","updated":"2019-03-06T14:25:34.113Z","comments":true,"path":"2018/09/01/Ubuntu下Sublime配置Python环境使用指导/","link":"","permalink":"https://nymrli.top/2018/09/01/Ubuntu下Sublime配置Python环境使用指导/","excerpt":"","text":"Sublime配置python编译环境及搭建虚拟环境:(windows下大致相同)1.编译环境配置 2019-3-6更新教程，发现好像 官方网址打不开了，要改一下源才行。 解决办法： 点击 Preferences -&gt; Settings -&gt; Preferences.sublime-Settings—— User(一个新窗口) 添加配置(在原有大括号{}里面添加)：&quot;channels&quot;: [&quot;https://raw.githubusercontent.com/HBLong/channel_v3_daily/master/channel_v3.json&quot;], 代码不变，仍然是下面的代码 感谢HBLong提供的解决方案和源: 原有链接 : 解决：Sublime Text3 packagecontrol.io 无法访问的问题 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 1.点击 官方网址 从 Sublime Text 3 官方获取用于安装的代码(即上面的代码)。从菜单栏View –&gt;Show Console或者使用Ctrl+`(esc键下面的按键)，调出sublime的控制台，将官网中的python代码粘贴进去并按Enter执行，最终可以安装完成。在控制台中粘贴刚才的代码，然后点击回车。最后重启ST3。 2.现在你可以通过快捷键 cmd+shift+P 打开 Package Control 来安装其他的插件了。输入 install 然后你就能看见屏幕上出现了 Package Control: Install Package，点击回车,然后搜索sublimeREPL 安装成功后，可以在菜单栏的’TOOL’中找到SublimeREPL，如图所示 2.将菜单栏改为中文若需要将菜单栏改成中文可如上操作下载插件“ConvertToUTF8”或是安装插件“ChineseLocalizations”(本人使用的是这个，没试ConvertToUTF8的效果) (参考博客:http://blog.51cto.com/11970781/2087971) 3.安装Anaconda插件 1.点击刚刚生成的Package Control -&gt;输入install 2.进入安装界面，安装好后再在新窗口命令行中输入Anaconda并点击第一个备选项进行安装。 安装完成后会显示messages文档。 安装Anaconda插件完成之后，会看到如下选项栏，说明Anaconda安装成功。 - Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数或者类的定义。 - Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 - Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下) Anaconda会自动补全代码，之前用惯了pycharm发现突然没了代码补全后很不习惯，Anaconda的补全功能虽然没有pycharm那么好用，但还是不错的 还有需要注意的是，安装Anaconda插件后，如果python代码没有遵循PEP8规范，会出现白色的框框，或是可以使用快捷键Ctrl+Alt+R进行规范代码(这个可以去除，步骤如下) 在Settings-User选项中添加配置:{“anaconda_linting”:false} 4.安装虚拟环境 1.首先使用终端安装virtualenv，pip3 install virtualenv2.在需要创建的地方进行虚拟环境的搭建，代码如下： 123mkdir pytest(文件夹名)cd pytestvirtualenv venv 在终端进入虚拟环境的话是在pytest文件夹下输入命令source /bin/activate而要在sublime中进入虚拟环境的话就得按照如下操作： １．首先在sublime中安装virtualenv插件，Ctrl + Shift + P，然后输入install,回车，然后搜索virtualenv。 2. 安装完成后，直接按Ctrl + Shift + P，再输入Activate，若没有该选项则virtualenv安装中出现问题，需要重新安装。如果有的会选择Activate就能发现刚刚创建的虚拟环境，选中后回车即可进入虚拟环境 3. 如果Activate选中后没有出现我们刚刚创建的虚拟环境，则需要我们手动添加路径.Ctrl + Shift + P，然后输入Add directory，回车，屏幕下面会出现输入行（Directory path）:再将刚创建的虚拟环境路径填入即可 另外，我曾碰到过Add directory后仍然没用的情况。那时，可选择“”Project”=&gt;”Add folder to project”选择文件后=&gt;”Save Project as”==&gt;保存好即可 工程配置文件为： .sublime-workspace、.sublime-project 其中sublime-project为: 123456789101112131415161718&#123; &quot;build_systems&quot;: [ &#123; &quot;file_regex&quot;: &quot;^[ ]File &quot;(...?)&quot;, line ([0-9]*)&quot;, &quot;name&quot;: &quot;Anaconda Python Builder&quot;, &quot;selector&quot;: &quot;source.python&quot;, &quot;shell_cmd&quot;: &quot;&quot;python&quot; -u &quot;$file&quot;&quot; &#125; ], &quot;folders&quot;: [ &#123; &quot;path&quot;: &quot;爬虫&quot; &#125; ], &quot;virtualenv&quot;: &quot;G:\\pachong\\venv&quot;&#125; 这样环境就配置好了。按Ctrl+B编译时，观察”Tools”-&gt;”Build System”-&gt;是否为”Python+ Virtualenv”，如果不是，则选用这个再Ctrl+B就是在虚拟环境中编译了! ubuntu下sublime默认情况下好像不能输入中文，需要用下面命令就可以完美支持中文输入： 1234sudo apt-get update &amp;&amp; sudo apt-get upgradegit clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix./sublime-imfix 转自CV_YOU的博客 完美解决Sublime无法输入中文问题 截图好像有点问题，菜单栏都没有截到，用到的三个分别为“项目(Project)”，“首选项(Preferences)”，“帮助(Help)”","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"}]},{"title":"python pywin32 PyUserInput实现自动化脚本","slug":"python-win32api-win32gui-win32con-PyUserInput实现自动化脚本","date":"2018-08-31T11:43:00.000Z","updated":"2018-08-31T11:56:56.677Z","comments":true,"path":"2018/08/31/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本/","link":"","permalink":"https://nymrli.top/2018/08/31/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本/","excerpt":"","text":"pywin32用spy++工具查找到句柄，再结合PyUserInput就能很好地实现自动化脚本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import win32guiimport win32conimport win32api# 从顶层窗口向下搜索主窗口，无法搜索子窗口# FindWindow(lpClassName=None, lpWindowName=None) 窗口类名 窗口标题名handle = win32gui.FindWindow(&quot;Notepad&quot;, None) # 获取窗口位置left, top, right, bottom = win32gui.GetWindowRect(handle)#获取某个句柄的类名和标题title = win32gui.GetWindowText(handle) clsname = win32gui.GetClassName(handle)# 打印句柄# 十进制print(handle)# 十六进制print(&quot;%x&quot; %(handle) )# 搜索子窗口# 枚举子窗口hwndChildList = [] win32gui.EnumChildWindows(handle, lambda hwnd, param: param.append(hwnd), hwndChildList)# FindWindowEx(hwndParent=0, hwndChildAfter=0, lpszClass=None, lpszWindow=None) # 父窗口句柄 若不为0，则按照z-index的顺序从hwndChildAfter向后开始搜索子窗体，否则从第一个子窗体开始搜索。 子窗口类名 子窗口标题subHandle = win32gui.FindWindowEx(handle, 0, &quot;EDIT&quot;, None)# 获得窗口的菜单句柄menuHandle = win32gui.GetMenu(subHandle)# 获得子菜单或下拉菜单句柄 # 参数：菜单句柄 子菜单索引号subMenuHandle = win32gui.GetSubMenu(menuHandle, 0)# 获得菜单项中的的标志符，注意，分隔符是被编入索引的 # 参数：子菜单句柄 项目索引号 menuItemHandle = win32gui.GetMenuItemID(subMenuHandle, 0)# 发送消息，加入消息队列，无返回 # 参数：句柄 消息类型 WParam IParamwin32gui.postMessage(subHandle, win32con.WM_COMMAND, menuItemHandle, 0)# wParam的定义是32位整型，high word就是他的31至16位，low word是它的15至0位。# 当参数超过两个，wParam和lParam不够用时，可以将wParam就给拆成两个int16来使用。# 这种时候在python里记得用把HIWORD的常数向左移16位，再加LOWORD，即wParam = HIWORD&lt;&lt;16+LOWORD。# 下选框内容更改# 参数：下选框句柄； 消息内容； #参数下选框的哪一个item，以0起始的待选选项的索引；如果该值为-1，将从组合框列表中删除当前选项，并使当前选项为空；# 参数CB_Handle为下选框句柄，PCB_handle下选框父窗口句柄if win32api.SendMessage(CB_handle, win32con.CB_SETCURSEL, 1, 0) == 1:# 下选框的父窗口命令# 参数：父窗口句柄； 命令； # 参数：WParam：高位表示类型，低位表示内容；参数IParam，下选框句柄# CBN_SELENDOK当用户选择了有效的列表项时发送，提示父窗体处理用户的选择。 LOWORD为组合框的ID. HIWORD为CBN_SELENDOK的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x90000, CB_handle) # CBN_SELCHANGE当用户更改了列表项的选择时发送，不论用户是通过鼠标选择或是通过方向键选择都会发送此通知。LOWORD为组合框的ID. HIWORD为CBN_SELCHANGE的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x10000, CB_handle) # 设置文本框内容，等窗口处理完毕后返回true。中文需编码成gbk # 参数：句柄；消息类型；# 参数WParam，无需使用； # 参数IParam，要设置的内容，字符串win32api.SendMessage(handle, win32con.WM_SETTEXT, 0, os.path.abspath(fgFilePath).encode(&apos;gbk&apos;))# 控件点击确定,处理消息后返回0# 参数:窗口句柄; 消息类型; 参数WParam HIWORD为0（未使用），LOWORD为控件的ID; 参数IParam 0（未使用）,确定控件的句柄win32api.SendMessage(Mhandle, win32con.WM_COMMAND, 1, confirmBTN_handle)# 获取窗口文本不含截尾空字符的长度# 参数：窗口句柄； 消息类型； 参数WParam； 参数IParambufSize = win32api.SendMessage(subHandle, win32con.WM_GETTEXTLENGTH, 0, 0) +1# 利用api生成BufferstrBuf = win32gui.PyMakeBuffer(bufSize)print(strBuf)# 发送消息获取文本内容# 参数：窗口句柄； 消息类型；文本大小； 存储位置length = win32gui.SendMessage(subHandle, win32con.WM_GETTEXT, bufSize, strBuf)# 反向内容，转为字符串# text = str(strBuf[:-1])address, length = win32gui.PyGetBufferAddressAndLen(strBuf) text = win32gui.PyGetString(address, length) # print(&apos;text: &apos;, text)# 鼠标单击事件#鼠标定位到(30,50)win32api.SetCursorPos([30,150])#执行左单键击，若需要双击则延时几毫秒再点击一次即可win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP | win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)#右键单击win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP | win32con.MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0)def click1(x,y): #第一种 win32api.SetCursorPos((x,y)) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,0,0) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,0,0)def click2(x,y): #第二种 ctypes.windll.user32.SetCursorPos(x,y) ctypes.windll.user32.mouse_event(2,0,0,0,0) ctypes.windll.user32.mouse_event(4,0,0,0,0)def click_it(pos): #第三种 handle= win32gui.WindowFromPoint(pos) client_pos =win32gui.ScreenToClient(handle,pos) tmp=win32api.MAKELONG(client_pos[0],client_pos[1]) win32gui.SendMessage(handle, win32con.WM_ACTIVATE,win32con.WA_ACTIVE,0) win32gui.SendMessage(handle, win32con.WM_LBUTTONDOWN,win32con.MK_LBUTTON,tmp) win32gui.SendMessage(handle, win32con.WM_LBUTTONUP,win32con.MK_LBUTTON,tmp)# 发送回车win32api.keybd_event(13,0,0,0)win32api.keybd_event(13,0,win32con.KEYEVENTF_KEYUP,0)# 关闭窗口win32gui.PostMessage(win32lib.findWindow(classname, titlename), win32con.WM_CLOSE, 0, 0)# 检查窗口是否最小化，如果是最大化if(win32gui.IsIconic(hwnd)):# win32gui.ShowWindow(hwnd, win32con.SW_SHOWNORMAL) win32gui.ShowWindow(hwnd, 8) sleep(0.5)# SW_HIDE：隐藏窗口并激活其他窗口。nCmdShow=0。# SW_MAXIMIZE：最大化指定的窗口。nCmdShow=3。# SW_MINIMIZE：最小化指定的窗口并且激活在Z序中的下一个顶层窗口。nCmdShow=6。# SW_RESTORE：激活并显示窗口。如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置。在恢复最小化窗口时，应用程序应该指定这个标志。nCmdShow=9。# SW_SHOW：在窗口原来的位置以原来的尺寸激活和显示窗口。nCmdShow=5。# SW_SHOWDEFAULT：依据在STARTUPINFO结构中指定的SW_FLAG标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递给CreateProcess函数的。nCmdShow=10。# SW_SHOWMAXIMIZED：激活窗口并将其最大化。nCmdShow=3。# SW_SHOWMINIMIZED：激活窗口并将其最小化。nCmdShow=2。# SW_SHOWMINNOACTIVE：窗口最小化，激活窗口仍然维持激活状态。nCmdShow=7。# SW_SHOWNA：以窗口原来的状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=8。# SW_SHOWNOACTIVATE：以窗口最近一次的大小和状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=4。# SW_SHOWNORMAL：激活并显示一个窗口。如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小。应用程序在第一次显示窗口的时候应该指定此标志。nCmdShow=1。 感谢python win32api win32gui win32con 窗口句柄 发送消息 常用方法 键盘输入，代码主要来自于他 ▲.需要注意在windows和mac下接口参数可能有所不同。win32虽然也可控制键盘，但不如使用PyUserInput的方便。安装PyUserInput教程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pymouse import PyMousefrom pykeyboard import PyKeyboard#实例化m = PyMouse() k = PyKeyboard()x_dim, y_dim = m.screen_size()# 鼠标点击 参数:x,y,button=1(左键)、2(右键)、3(中间),次数m.click(x_dim, y_dim, button=1,n=1) # 键盘输入 参数:str,间隔k.type_string(&apos;Hello, World!&apos;,interval=0)# 按住一个键k.press_key(&apos;H&apos;)# 松开一个键k.release_key(&apos;H&apos;)# 相当于===&gt;按住并松开，tap一个键k.tap_key(&apos;e&apos;)# tap支持重复的间歇点击键,参数:str,次数,间隔k.tap_key(&apos;l&apos;,n=2,interval=5) #创建组合键===&gt;press_key和release_key结合使用k.press_key(k.alt_key)k.tap_key(k.tab_key)k.release_key(k.alt_key)# 特殊功能键k.tap_key(k.function_keys[5]) # Tap F5k.tap_key(k.numpad_keys[&apos;Home&apos;]) # Tap &apos;Home&apos; on the numpadk.tap_key(k.numpad_keys[5], n=3) # Tap 5 on the numpad, thrice# Mac系统按键k.press_keys([&apos;Command&apos;,&apos;shift&apos;,&apos;3&apos;])# Windows系统按键k.press_keys([k.windows_l_key,&apos;d&apos;])其中pymouse的PyMouseEvent和pykeyboard的PyKeyboardEvent还可用于监听鼠标和键盘事件的输入class Clickonacci(PyMouseEvent): def __init__(self): PyMouseEvent.__init__(self) self.fibo = fibo() def click(self, x, y, button, press): &apos;&apos;&apos;Print Fibonacci numbers when the left click is pressed.&apos;&apos;&apos; if button == 1: if press: print(&apos;Press times:%d&apos;.format(press)) else: # Exit if any other mouse button used self.stop()C = Clickonacci()C.run()class TapRecord(PyKeyboardEvent): def __init__(self): PyKeyboardEvent.__init__(self) def tap(self, keycode, character, press): print(time.time(), keycode, character, press)t = TapRecord()t.run()#这些对象是一个架构用于监听鼠标和键盘的输入；他们除了监听之外不会做任何事，需要继承重构他们#PyKeyboardEvent为编写完成，所以这里是一个继承PyMouseEvent的例子：","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"Python字典基本操作介绍","slug":"Python字典基本操作介绍","date":"2018-08-30T13:14:27.000Z","updated":"2018-10-27T01:57:02.042Z","comments":true,"path":"2018/08/30/Python字典基本操作介绍/","link":"","permalink":"https://nymrli.top/2018/08/30/Python字典基本操作介绍/","excerpt":"","text":"创建字典 info={} info=dict() 初始化字典法一123key = &apos;name&apos;info = &#123; key :&apos;cold&apos;&#125;==&#123;&apos;name&apos;:&apos;cold&apos;&#125; 法二12info = dict(key = &apos;cold&apos;)==&#123;&apos;key&apos;:&apos;cold&apos;&#125; 法三1#还有可以使用dict(zip(a,b))其中a,b都是列表,会生成以A中元素为键,B中元素为值的字典 插入新的键值对(更新) info.update(name=’cold’, blog=’www.linuxzen.com&#39;) 在字典有没有k这个键时可以使用dict.setdefault(key,value) 还可以使用dict(var = value)其中var可以是变量,也可以不是,注意不用加 或是_dict[‘xxx’]=’yyy’ 获得键值 确定存在的情况下- info.get(‘xxx’) info[‘xxx’] 不确定是否存在 info.get(‘xxx’) 遍历字典 获得key,再通过key来获得valuefor key in dicprint(%d,%d%(key,_dict[key])) 使用dict.items()for key,value in dic.items()print ‘key is %s,value is %s’%(key,value) 字典删除del(info[&#39;xxx&#39;]) or del info[&#39;xxx&#39;]","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Hello 搭建Hexo博客","slug":"hello-hexo","date":"2018-08-30T13:14:27.000Z","updated":"2018-09-01T10:33:39.636Z","comments":true,"path":"2018/08/30/hello-hexo/","link":"","permalink":"https://nymrli.top/2018/08/30/hello-hexo/","excerpt":"","text":"电脑环境是Windows，安装好git后，所有搭建操作均在git bash内完成 1.需要安装git, node.js, npm 注:第一次安装Git会让配置user信息 123&gt; $git config --global user.name &quot;yourname&quot; #（yourname是git的用户名）&gt; $git config --global user.email &quot;youremail&quot;）&gt; 2.使用npm安装hexo： npm install -g hexo3.创建hexo文件夹，并单击鼠标右键选择 Git bash：(我的创建路径是：E:\\hexo）4.在刚刚打开的git bash命令框中操作：1234$hexo init #hexo 会自动创建网站所需要的文件$npm install #安装依赖包$hexo generate # 等价于hexo g$hexo server #现在可以用127.0.0.1:4000访问hexo默认的hello world界面,等价于hexo s 5.部署到github (https://github.com/)， 首先注册登录,然后创建页面仓库，Repository name 命名必须是 youname.github.io ，（youname 就是你注册时候用的name） ssh-keygen -t rsa -C &quot;email&quot; #生成ssh密钥，按三次回车键，密码为空,这边会生成id_rsa和_rsa.pub文件，打开id_rsa.pub，复制全文添加到GitHub 的Add SSH key中。 最后可以验证一下ssh -T git@github.com,看出现的是不是Hi &quot;Yourname&quot;如果出现了你的github用户名,则成功了 6.下载Hexo主题 $git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载hexo的yilia 模板到自己的文件目录下 打开项目目录下的_config.yml文件，更改theme：yilia ▲注意: _config.yml文件中配置时:后面都要加空格,与:隔开 7.开启评论功能：使用gitment$npm install gitment --save #安装gitment 然后在 https://github.com/settings/applications/new 进行注册，获取Client ID和Client Secret ▲注意:其中Authorization callback URL是个坑: 这一项不能乱填,不让就不能&quot;初始化评论&quot;.. 应该怎么填呢? 如果你绑定了自己的域名就直接写自己的域名: https://nymrli.top/ 如果没有的话才填写http://Freedomisgood.github.io,否则会一直弹回博客首页,而不能”初始化评论”或者”发表评论” 其中的原因就在于,既可以通过www.nymrli.top解析，也可通过nymrli.top解析,还可以通http://Freedomisgood.github.io解析,而Authorization callback URL只能写一个.(最终解析到的网站)…===&gt;就是nymrli.top △.感谢IsResultXaL提供的思路 打开themes/yilia目录下的_config.yml文件进行修改并保存： 再次生成网站,提交网站:hexo d -g就可以输入网址:https://yourname.github.io打开你的博客了 8.显示文章摘要图片 1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在hexo目录下打开git Bsh或者power Shell,npm install hexo-asset-image --save安装插件 再运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 1![你想输入的替代文字](xxxx/图片名.jpg) ▲ .之前一直失败,原因在于,我写图片链接的时候是直接拖动图片到编辑器中的,路径为![v2-代替文字](E:\\hexo\\source\\_posts\\xxxx\\图片名.jpg),后来一直错误,无法正常显示后，发现只需要写成![代替文字](xxxx\\图片名.jpg)即可.. 文章总体框架:12345678910---layout: phototitle: Hello Hexodate: 2018-08-30 21:14:27tags: - hexo---![代替文字](xxxx\\图片名.jpg)&lt;!--more--&gt;正文 →推一个不错的文章Hexo+Coding+Github部署个人博客Error全集,如果出现未能解决的问题,希望能从这篇文章略微得到启发.","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"hexo","slug":"hexo","permalink":"https://nymrli.top/tags/hexo/"}]}]}