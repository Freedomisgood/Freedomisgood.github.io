{"meta":{"title":"Mrli's Blog","subtitle":"别装作很努力，结局不会陪你演戏。","description":"想和你讲，说了会心动 ，缄默会心安。","author":"Mrli","url":"https://nymrli.top"},"pages":[{"title":"","date":"2020-07-25T12:19:59.503Z","updated":"2018-12-21T09:57:11.353Z","comments":true,"path":"google6b632f121e4f7422.html","permalink":"https://nymrli.top/google6b632f121e4f7422.html","excerpt":"","text":"google-site-verification: google6b632f121e4f7422.html"},{"title":"关于我","date":"2018-08-31T07:56:42.000Z","updated":"2018-09-04T04:36:10.718Z","comments":true,"path":"about/index.html","permalink":"https://nymrli.top/about/index.html","excerpt":"","text":"本人南邮自动化本科学生一枚.热爱捣鼓计算机,涉及Python、C、Java等语言.参加Robocup,ACM,未来打算弄机器学习、数据挖掘方面"},{"title":"css","date":"2018-08-31T11:13:48.000Z","updated":"2018-08-31T11:19:21.810Z","comments":false,"path":"tags/index.html","permalink":"https://nymrli.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux服务器同步时钟","slug":"Linux服务器同步时钟","date":"2020-11-22T04:49:35.000Z","updated":"2020-11-22T04:50:08.208Z","comments":true,"path":"2020/11/22/Linux服务器同步时钟/","link":"","permalink":"https://nymrli.top/2020/11/22/Linux服务器同步时钟/","excerpt":"","text":"因为今天在集群193跑程序的时候发现时间不同步, 因此想想把集群的时间全部同步一下 在Linux中设置系统时间，可以用date命令： 1234# 查看时间$ date# 修改时间$ date -s \"20140225 20:16:00\" #yyyymmdd hh:mm:ss Linux硬件时间的设置 硬件时间的设置，可以用hwclock或者clock命令。两者基本相同，只用一个就行，只不过clock命令除了支持x86硬件体系外，还支持Alpha硬件体系。 系统时间和硬件时间的同步 同步系统时间和硬件时间，可以使用hwclock命令。 4. 不同机器之间的时间同步 为了避免主机时间因为长期运行下所导致的时间偏差，进行时间同步（synchronize）的工作是非常必要的。Linux系统下，一般使用ntp服务器来同步不同机器的时间。一台机器，可以同时是ntp服务端和ntp客户端。在生产系统中，推荐使用像DNS服务器一样分层的时间服务器来同步时间。 不同机器间同步时间，可以使用ntpdate命令，也可以使用ntpd服务。==&gt;▲. 注意两个不能同时使用: 如果使用了ntpd后还是用ntpdate会报错ntpdate[39462]: the NTP socket is in use, exiting, 要查询ntp的状态，用ntpq命令，比如看目前是否和ntp server同步，用ntpq -p 1234567891011121314 remote refid st t when poll reach delay offset jitter============================================================================== 0.ubuntu.pool.n .POOL. 16 p - 64 0 0.000 0.000 0.000 1.ubuntu.pool.n .POOL. 16 p - 64 0 0.000 0.000 0.000 2.ubuntu.pool.n .POOL. 16 p - 64 0 0.000 0.000 0.000 3.ubuntu.pool.n .POOL. 16 p - 64 0 0.000 0.000 0.000 ntp.ubuntu.com .POOL. 16 p - 64 0 0.000 0.000 0.000 ntp1.ams1.nl.le 130.133.1.10 2 u 1 64 1 305.632 -43.387 0.146*120.25.115.20 10.137.53.7 2 u 1 64 1 29.425 -1.059 0.410 203.107.6.88 100.107.25.114 2 u 1 64 1 32.056 -2.093 0.257 ntp.xtom.nl 84.199.11.211 2 u 1 64 1 175.286 -6.179 0.210 94.130.49.186 ( 195.13.23.5 3 u 2 64 1 212.348 -17.943 0.561 tock.ntp.infoma .GPS. 1 u 2 64 1 239.693 -11.135 0.175 119.28.206.193 100.122.36.196 2 u - 64 1 41.525 -4.034 0.002 可以看到*号标出的就是集群正在同步的时钟服务器: 120.25.115.20是阿里云 由于不能同时使用， 而ntpdate的稳定性不好， 因此ntpdate用来一次性同步时间（或者ntpdate+cron组合）、或者用ntpdate同步一次时间后，持续用ntpd服务器来同步。 下面使用ntpdate来同步时间：使用ntpdate前, 先将ntpd关闭: service ntpd stop或sudo systemctl stop ntp 1234# /usr/sbin/ntpdate time.stdtime.gov.twError : Temporary failure in name resolution29 Oct 14:18:59 ntpdate[25327]: can't find host time.stdtime.gov.tw29 Oct 14:18:59 ntpdate[25327]: no servers can be used, exiting 确认防火墙没有问题后，执行域名解析，发现失败 12# nslookup time.stdtime.gov.tw;; connection timed out; no servers could be reached 尝试ping外网，以确认能正常连到外网，连网正常 1234567# ping 8.8.8.8PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.64 bytes from 8.8.8.8: icmp_seq=1 ttl=53 time=1.48 ms64 bytes from 8.8.8.8: icmp_seq=2 ttl=53 time=1.40 ms--- 8.8.8.8 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1000msrtt min/avg/max/mdev = 1.404/1.445/1.487/0.056 ms 于是修改DNS文件, /etc/resolv.conf, 虽然这边提示不要手动修改, 但是临时改掉是没问题的 1234# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN#nameserver 127.0.1.1nameserver 8.8.8.8 修改后，再次执行时间同步，ok鸟！ 12apollo3d@apollo15:~/cl/Python_project/cplm/Min38$ sudo ntpdate ntp1.aliyun.com21 Nov 23:04:25 ntpdate[40285]: adjust time server 120.25.115.20 offset 0.002194 se 除了阿里云的还有pool.ntp.org可以用来同步。 ▲但是同步之后时间还是不太对， 于是观察时区， 发现集群两台电脑上其实只是时区是不同的， 同步的服务器都是一样的阿里云的。 12345apollo3d@apollo2:~$ date2020年 11月 22日 星期日 12:14:11 CSTapollo3d@apollo15:~/cl/Python_project/cplm/Min38$ dateSat Nov 21 23:14:01 EST 2020 发现一个是EST和CST。网上查询得知 EST代表英国时间, CST代表北京时间, EDT：指美国东部夏令时间 那么现在只要改成北京时间的时区CST就可以了，修改如下： 123[root@localhost ~]# mv /etc/localtime /etc/localtime.bak[root@localhost ~]# ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime[root@localhost ~]# date 但是发现两台语言不一样, 一个是中文, 一个是英文, 猜测是操作系统中英版导致的: 输出环境变量: 123456789101112131415161718192021apollo3d@apollo2:~$ date2020年 11月 22日 星期日 12:14:11 CST$ env# 可以看到时区是中国HOME=/home/apollo3dLOGNAME=apollo3dLESSCLOSE=/usr/bin/lesspipe %s %sLC_TIME=zh_CN.UTF-8LC_NAME=zh_CN.UTF-8_=/usr/bin/envapollo3d@apollo15:~/cl/Python_project/cplm/Min38$ dateSat Nov 21 23:14:01 EST 2020$ env# 可以看到语言是en_US, 但是没设置时区MAIL=/var/mail/apollo3dPWD=/home/apollo3d/cl/Python_project/cplm/Min38JAVA_HOME=/home/apollo3d/Apollo_Rescue/jdk1.8.0_161LANG=en_US.UTF-8HOME=/home/apollo3dSUDO_COMMAND=/bin/su 因此可以修改LANG: 12$ sudo vim /etc/sysconfig/i18nLANG=\"en_US.UTF-8\"改为LANG=\"zh_CN.GB2312\" 再运行我的Python脚本的时候发现竟然报错了: ValueError: Timezone offset does not match system offset: -18000 != 28800. Please, check your config files. 因为系统时区和代码运行时区不一样导致。解决办法：在创建BlockingScheduler对象时指定上海的时区scheduler = BlockingScheduler(timezone=&quot;Asia/Shanghai&quot;)","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"李宏毅机器学习_摘要","slug":"李宏毅机器学习-摘要","date":"2020-11-17T12:36:05.000Z","updated":"2020-11-23T04:14:20.229Z","comments":true,"path":"2020/11/17/李宏毅机器学习-摘要/","link":"","permalink":"https://nymrli.top/2020/11/17/李宏毅机器学习-摘要/","excerpt":"","text":"P3Regression - Case Study regularization解决overfitting(L2正则化解决过拟合问题) regularization可以使曲线变得更加smooth，training data上的error变大，但是 testing data上的error变小。有关regularization的具体原理说明详见下一部分 原来的loss function只考虑了prediction的error，即$$\\sum_{i}{n}\\left(\\hat{y}{i}-\\left(b+\\sum_{j} w_{j} x_{j}\\right)\\right)^{2}$$；而regularization则是在原来的loss function的基础上加上了一项$$\\lambda \\sum\\left(w_{i}\\right)^{2}$$，就是把这个model里面所有的Wi的平方和用λ加权(其中i代表遍历n个training data，j代表遍历model的每一项) 也就是说，*我们期待参数w i w_i*w*i*越小甚至接近于0的function，为什么呢？ 因为参数值接近0的function，是比较平滑的；所谓的平滑的意思是，当今天的输入有变化的时候，output对输入的变化是比较不敏感的。举例来说，对y=b+∑wixiy=b+\\sum w_{i} x_{i}y=b+∑wi​xi​这个model，当input变化Δ x，output的变化就是，$$w_{i} \\Delta x_{i}$$也就是说，如果w越i小越接近0的话，输出对输入就越不sensitive敏感，我们的function就是一个越平滑的function；说到这里你会发现，我们之前没有把bias——b这个参数考虑进去的原因是bias的大小跟function的平滑程度是没有关系的，bias值的大小只是把function上下移动而已 那为什么我们喜欢比较平滑的function呢？ 如果我们有一个比较平滑的function，由于输出对输入是不敏感的，测试的时候，一些noises噪声对这个平滑的function的影响就会比较小，而给我们一个比较好的结果 注：这里的λ需要我们手动去调整以取得最好的值 λ值越大代表考虑smooth的那个regularization那一项的影响力越大，我们找到的function就越平滑 观察下图可知，当我们的λ越大的时候，在training data上得到的error其实是越大的，但是这件事情是非常合理的，因为当λ越大的时候，我们就越倾向于考虑w的值而越少考虑error的大小；但是有趣的是，虽然在training data上得到的error越大，但是在testing data上得到的error可能会是比较小的 我们喜欢比较平滑的function，因为它对noise不那么sensitive；但是我们又不喜欢太平滑的function，因为它就失去了对data拟合的能力；而function的平滑程度，就需要通过调整λ来决定，就像下图中，当λ=100时，在testing data上的error最小，因此我们选择λ=100 P4Basic Concept bias和variance bias表示离靶心的距离, 而variance表示散布情况 图中所示，只有足够大的函数搜索空间，才能找到正确的“靶心”，因此就需要吧模型设计得足够复杂。而复杂模型需要大数据来降低方差， 因此需要大量的数据防止过拟合 如果来自variance的误差很大， 那么就是过拟合； 如果来自bias的误差很大，那么就是欠拟合（underfitting） bias大： 如果无法fit训练数据, 证明是欠拟合;如果能fit训练数据，但是在测试数据上有较大的误差，那么就是过拟合——做法：增大特征or增大次项 variance大： 更多的数据（数据增强）or 正则化 交叉验证： 在trainingset训练后,虽然在公开的测试集上表示良好,但是private testing set不好的话, 则还是比较糟糕的模型。因此在判断一个模型的好坏的时候， 可以将trainingSet进行交叉验证 非常不建议因为在public testing set上表现不好而反过来重新选择trainingSet的模型， 因为这相当于在训练的时候吧testing也考虑在内了， 违背了设计的初衷，并且这样的结果在private testing set上也会表现不好。 N-fold cross validation （十折交叉验证） 如果不相信某一个trainset的结果的话， 那就分很多trainset 5. P5Gradient Descent θ∗=arg⁡min⁡θL(θ)\\theta^{*}=\\arg \\min _{\\theta} L(\\theta) θ∗=argθmin​L(θ) L: loss function θ\\thetaθ : parameters(上标表示第几组参数, 下标表示这组参数中的第几个参数) 当参数有很多个的时候(&gt;3)，其实我们很难做到将loss随每个参数的变化可视化出来(因为最多只能可视化出三维的图像，也就只能可视化三维参数)，但是我们可以把update的次数作为唯一的一个参数，将loss随着update的增加而变化的趋势给可视化出来(上图右半部分) 所以做gradient descent一个很重要的事情是，要把不同的learning rate下，loss随update次数的变化曲线给可视化出来，它可以提醒你该如何调整当前的learning rate的大小，直到出现稳定下降的曲线 总结：梯度下降法指的是函数值loss随梯度下降的方向减小 Adaptive Learning rates 显然这样手动地去调整learning rates很麻烦，因此我们需要有一些自动调整learning rates的方法 最基本、最简单的大原则是：learning rate通常是随着参数的update越来越小的 因为在起始点的时候，通常是离最低点是比较远的，这时候步伐就要跨大一点；而经过几次update以后，会比较靠近目标，这时候就应该减小learning rate，让它能够收敛在最低点的地方 Adagrad Divide the learning rate of each parameter by the root mean square(方均根) of its previous derivatives Adagrad就是将不同参数的learning rate分开考虑的一种算法(adagrad算法update到后面速度会越来越慢，当然这只是adaptive算法中最简单的一种) Stochastic Gradicent Descent 随机梯度下降的方法可以让训练更快速，传统的gradient descent的思路是看完所有的样本点之后再构建loss function，然后去update参数；而stochastic gradient descent的做法是，看到一个样本点就update一次，因此它的loss function不是所有样本点的error平方和，而是这个随机样本点的error平方 Feature Scaling 概念介绍 特征缩放，当多个特征的分布范围很不一样时，最好将这些不同feature的范围缩放成一样 对gradient decent的帮助 之前我们做的demo已经表明了，对于这种长椭圆形的error surface，如果不使用Adagrad之类的方法，是很难搞定它的，因为在像w1和w2这样不同的参数方向上，会需要不同的learning rate，用相同的lr很难达到最低点 如果有scale的话，loss在参数w1、w2平面上的投影就是一个正圆形，update参数会比较容易 而且gradient descent的每次update并不都是向着最低点走的，每次update的方向是顺着等高线的方向(梯度gradient下降的方向)，而不是径直走向最低点；但是当经过对input的scale使loss的投影是一个正圆的话，不管在这个区域的哪一个点，它都会向着圆心走。因此feature scaling对参数update的效率是有帮助的 scaling method: z-score: 归一化 gradient descent数学理论 注意 learning rate需要设置好, 否则Δθ不为0, 则泰勒近似不成立。 gradient descent的限制 ▲gradient descent的限制是，它在gradient即微分值接近于0的地方就会停下来，而这个地方不一定是global minima，它可能是local minima，可能是saddle point鞍点，甚至可能是一个loss很高的plateau平缓高原 6. P10Classification_1 特征、特征向量是什么？ 要想把一个东西当做计算机能理解的function的input，就需要把它数值化 特性数值化：用一组数字来描述一只宝可梦的特性， 比如用一组数字表示它有多强(total strong)、它的生命值(HP)、它的攻击力(Attack)、它的防御力(Defense)、它的特殊攻击力(Special Attack)、它的特殊攻击的防御力(Special defend)、它的速度(Speed)，以皮卡丘为例，我们可以用以上七种特性的数值就是特征量， 而多个特征量所组成的vector就是特征向量 我们希望蓝色的这些属于class 1的宝可梦，input到Regression的model，output越接近1越好；红色的属于class 2的宝可梦，input到Regression的model，output越接近-1越好。如果使用回归来硬解分类问题的话， 异常值影响比较大。 异常值则远远大于1， 跟目标不一致 Regression的output是连续性质的数值，而classification要求的output是离散性质的点，我们很难找到一个Regression的function使大部分样本点的output都集中在某几个离散的点附近 因此，Regression定义model好坏的定义方式对classification来说是不适用的 Solution：Generative model——朴素贝叶斯分类器 ![function](E:\\hexo\\source_posts\\李宏毅机器学习-摘要\\P6 classification\\function.jpg) 我们可以把loss function定义成L^(f)=∑nδ(f(xn)≠y^n)\\hat{L}(f)=\\sum_{n} \\delta\\left(f\\left(x^{n}\\right) \\neq \\hat{y}^{n}\\right)L^(f)=∑n​δ(f(xn)​=y^​n)，即这个model在所有的training data上predict预测错误的次数，也就是说分类错误的次数越少，这个function表现得就越好 贝叶斯公式=单条路径概率/所有路径概率和 ![beyas](E:\\hexo\\source_posts\\李宏毅机器学习-摘要\\P6 classification\\beyas.jpg) 这一整套想法叫做Generative model(生成模型)，为什么叫它Generative model呢？因为有这个model的话，就可以拿它来generate生成x(如果你可以计算出每一个x出现的概率，就可以用这个distribution分布来生成x、sample x出来) 现在的问题是，怎么得到P(x∣C1)P\\left(x \\mid C_{1}\\right)P(x∣C1​) 和 P(x∣C2)P\\left(x \\mid C_{2}\\right)P(x∣C2​) 的值==&gt; 认为数据服从 高斯分布 高斯分布 fμ,Σ(x)=1(2π)D/21∣Σ∣1/2exp⁡{−12(x−μ)TΣ−1(x−μ)}f_{\\mu, \\Sigma}(x)=\\frac{1}{(2 \\pi)^{D / 2}} \\frac{1}{|\\Sigma|^{1 / 2}} \\exp \\left\\{-\\frac{1}{2}(x-\\mu)^{T} \\Sigma^{-1}(x-\\mu)\\right\\}fμ,Σ​(x)=(2π)D/21​∣Σ∣1/21​exp{−21​(x−μ)TΣ−1(x−μ)} 假设海龟的vector是[103 45]，虽然这个点在已有的数据里并没有出现过，但是不可以认为它出现的概率为0，我们需要用已有的数据去估测海龟出现的可能性 你可以想象说这已有的79只水系宝可梦的data其实只是冰山一角，假定水系神奇宝贝的Defense和SP Defense是从一个Gaussian的distribution里面sample出来的，下图只是采样了79个点之后得到的分布，但是从高斯分布里采样出海龟这个点的几率并不是0，那从这79个已有的点，怎么找到那个Gaussian distribution函数呢？ 最大似然估计_参数估计 那接下来的问题就是怎么去找出这个Gaussian，只需要去估测出这个Gaussian的均值和协方差即可 估测和的方法就是极大似然估计法(Maximum Likelihood)，极大似然估计的思想是，找出最特殊的那对u和covariance，从它们共同决定的高斯函数中再次采样出79个点，使”得到的分布情况与当前已知79点的分布情况相同“这件事情发生的可能性最大===&gt;最大似然估计 根据sample样本, 求得使出现该样本组合可能性最大(所以是每一个点产生的概率相乘)的那组参数 ![最大似然估计](E:\\hexo\\source_posts\\李宏毅机器学习-摘要\\P6 classification\\最大似然估计.jpg) ![估计出参数](E:\\hexo\\source_posts\\李宏毅机器学习-摘要\\P6 classification\\估计出参数.jpg) 预测： ![预测](E:\\hexo\\source_posts\\李宏毅机器学习-摘要\\P6 classification\\预测.jpg) ===&gt; 训练结束：再把testing data上得到的结果可视化出来，即右下角的图，发现分的不是太好，正确率才是47%我们之前用的只是Defense和SP Defense这两个参数，在二维空间上得到的效果不太好，但实际上一开始就提到了宝可梦总共是有6个features的，也许在二维空间上它们是重叠在一起的，但是在六维空间上看它们也许会分得很好，每一个宝可梦都是六维空间中的一个点，于是我们的是一个6-dim的vector，则是一个6*6的matrix，发现得到的准确率也才64%，这个分类器表现得很糟糕，是否有办法将它改进的更好？ Modifying Model 其实之前使用的model是不常见的，你是不会经常看到给每一个Gaussian都有自己的mean和covariance，比如我们的class 1用的是u1和Σ1\\Sigma_1Σ1​，class 2用的是u2和Σ2\\Sigma_2Σ2​，比较常见的做法是，不同的class可以share同一个cocovariance matrix 其实variance是跟input的feature size的平方成正比的，所以当feature的数量很大的时候，Σ\\SigmaΣ大小的增长是可以非常快的，在这种情况下，给不同的Gaussian以不同的covariance matrix，会造成model的参数太多，而参数多会导致该model的variance过大，出现overfitting的现象，因此对不同的class使用同一个covariance matrix，可以有效减少参数 案例总结 回顾几率模型 machine learning可以概况为以下三个step ![threeSteps](E:\\hexo\\source_posts\\李宏毅机器学习-摘要\\P6 classification\\threeSteps.jpg) ![threeSteps笔记](E:\\hexo\\source_posts\\李宏毅机器学习-摘要\\P6 classification\\threeSteps笔记.jpg) ![概率分布](E:\\hexo\\source_posts\\李宏毅机器学习-摘要\\P6 classification\\概率分布.jpg) 选择的概率分布为经验之谈： 可以选择任意你喜欢的， 但是最后还是得看效果： 如果你选择的是简单的分布函数(参数比较少)，那你的bias就大，variance就小；如果你选择复杂的分布函数，那你的bias就小，variance就大，那你就可以用data set来判断一下，用什么样的Probability distribution作为model是比较好的 朴素贝叶斯： 这里每一个dimension的分布函数都是一维的Gaussian distribution，如果这样假设的话，等于是说，原来那多维度的Gaussian，它的covariance matrix变成是diagonal(对角的)，在不是对角线的地方，值都是0，这样就可以更加减少需要的参数量，就可以得到一个更简单的model 我们把上述这种方法叫做Naive Bayes Classifier(朴素贝叶斯分类法)，如果真的明确了所有的feature之间是相互独立的，是不相关的，使用朴素贝叶斯分类法的performance是会很好的，如果这个假设是不成立的，那么Naive bayes classfier的bias就会很大，它就不是一个好的classifier(朴素贝叶斯分类法本质就是减少参数) 当然这个例子里如果使用这样的model，得到的结果也不理想，因为各种feature之间的covariance还是必要的，比如战斗力和防御力它们之间是正相关的，covariance不能等于0 总之，寻找model总的原则是，尽量减少不必要的参数，但是必然的参数绝对不能少 那怎么去选择分布函数呢？有很多时候凭直觉就可以看出来，比如宝可梦有某个feature是binary的，它代表的是：是或不是，这个时候就不太可能是高斯分布了，而很有可能是伯努利分布(两点分布) Analysis Posterior Probability分析后置概率的表达式 上面的推导过程可能比较复杂，但是得到的最终结果还是比较好的：(当和共用一个时，经过化简相消z就变成了一个linear的function，x的系数是一个vector w，后面的一大串数字其实就是一个常数项b) P(C1∣x)=σ(w⋅x+b)P\\left(C_{1} \\mid x\\right)=\\sigma(w \\cdot x+b)P(C1​∣x)=σ(w⋅x+b)这个式子就解释了，当class 1和class 2共用的时候，它们之间的boundary会是linear的 7. P11Logistic Regression Three Steps of machine learning Step 1：function set 这里的function set就是Logistic Regression——逻辑回归 Step 2：Goodness of a function 现在我们有N笔Training data，每一笔data都要标注它是属于哪一个class 假设这些Training data是从我们定义的posterior Probability中产生的(后置概率，某种意义上就是概率密度函数)，而w和b就决定了这个posterior Probability，那我们就可以去计算某一组w和b去产生这N笔Training data的概率，利用极大似然估计的思想，最好的那组参数就是有最大可能性产生当前N笔Training data分布的和 似然函数只需要将每一个点产生的概率相乘即可，注意，这里假定是二元分类，class 2的概率为1减去class 1的概率. fw,b(x)f_{w, b}(x)fw,b​(x)为x为C1种类的概率, 则在二元分类中(1−fw,b(x))( 1 - f_{w, b}(x) )(1−fw,b​(x)) 由于 L(w,b)L(w, b)L(w,b) 是乘积项的形式, 为了方便计算, 我们将上式做个变换: (注意这边的L(w,b) 是最大似然函数, 而不是Loss function) w∗,b∗=arg⁡max⁡w,bL(w,b)=arg⁡min⁡w,b(−ln⁡L(w,b))−ln⁡L(w,b)=−ln⁡fw,b(x1)−ln⁡fw,b(x2)−ln⁡(1−fw,b(x3))−…\\begin{array}{l} \\qquad w^{*}, b^{*}=\\arg \\max _{w, b} L(w, b)=\\arg \\min _{w, b}(-\\ln L(w, b)) \\\\ -\\ln L(w, b)=-\\ln f_{w, b}\\left(x^{1}\\right) \\\\ \\quad-\\ln f_{w, b}\\left(x^{2}\\right) \\\\ \\quad-\\ln \\left(1-f_{w, b}\\left(x^{3}\\right)\\right) \\\\ \\quad-\\ldots \\end{array} w∗,b∗=argmaxw,b​L(w,b)=argminw,b​(−lnL(w,b))−lnL(w,b)=−lnfw,b​(x1)−lnfw,b​(x2)−ln(1−fw,b​(x3))−…​ 由于class 1和class 2的概率表达式不统一，上面的式子无法写成统一的形式, 为了统一格式, 这里将Logistic Regression里的所有Training data都打上0和1的标签, 即output y^=1\\hat{y}=1y^​=1 代表class 1,1,1, output y^=0\\hat{y}=0y^​=0 代表class 2,2,2, 于是上式进一步改写成: −ln⁡L(w,b)=−[y^1ln⁡fw,b(x1)+(1−y^1)ln⁡(1−fw,b(x1))]−[y^2ln⁡fw,b(x2)+(1−y^2)ln⁡(1−fw,b(x2))]−[y^3ln⁡fw,b(x3)+(1−y^3)ln⁡(1−fw,b(x3))]−…\\begin{aligned} -\\ln L(w, b)=&amp;-\\left[\\hat{y}^{1} \\ln f_{w, b}\\left(x^{1}\\right)+\\left(1-\\hat{y}^{1}\\right) \\ln \\left(1-f_{w, b}\\left(x^{1}\\right)\\right)\\right] \\\\ &amp;-\\left[\\hat{y}^{2} \\ln f_{w, b}\\left(x^{2}\\right)+\\left(1-\\hat{y}^{2}\\right) \\ln \\left(1-f_{w, b}\\left(x^{2}\\right)\\right)\\right] \\\\ &amp;-\\left[\\hat{y}^{3} \\ln f_{w, b}\\left(x^{3}\\right)+\\left(1-\\hat{y}^{3}\\right) \\ln \\left(1-f_{w, b}\\left(x^{3}\\right)\\right)\\right] \\\\ &amp;-\\ldots \\end{aligned} −lnL(w,b)=​−[y^​1lnfw,b​(x1)+(1−y^​1)ln(1−fw,b​(x1))]−[y^​2lnfw,b​(x2)+(1−y^​2)ln(1−fw,b​(x2))]−[y^​3lnfw,b​(x3)+(1−y^​3)ln(1−fw,b​(x3))]−…​ 现在已经有了统一的格式, 我们就可以把要minimize的对象写成一个summation的形式: −ln⁡L(w,b)=∑n−[y^nln⁡fw,b(xn)+(1−y^n)ln⁡(1−fw,b(xn))]-\\ln L(w, b)=\\sum_{n}-\\left[\\hat{y}^{n} \\ln f_{w, b}\\left(x^{n}\\right)+\\left(1-\\hat{y}^{n}\\right) \\ln \\left(1-f_{w, b}\\left(x^{n}\\right)\\right)\\right] −lnL(w,b)=n∑​−[y^​nlnfw,b​(xn)+(1−y^​n)ln(1−fw,b​(xn))] 这里表示第n个样本点，表示第n个样本点的class标签(1表示class 1,0表示class 2)，最终这个summation的形式，里面其实是两个Bernouli distribution(两点分布)的cross entropy(交叉熵) 交叉熵 假设有如上图所示的两个distribution p和q，它们的交叉商就是 H(p,q)=−∑xp(x)ln⁡(q(x)),H(p, q)=-\\sum_{x} p(x) \\ln (q(x)),H(p,q)=−∑x​p(x)ln(q(x)), 这也就是之前的 推导中在 −ln⁡L(w,b)-\\ln L(w, b)−lnL(w,b) 前加一个负号的原因 cross entropy交叉嫡的含义是表达这两个distribution有多接近, 如果p和q这两个distribution一模一样的话, 那 它们算出来的cross entropy就是0(详细解释在“信息论&quot;中), 而这里 f(xn)f\\left(x^{n}\\right)f(xn) 表示function的output, y^n\\hat{y}^{n}y^​n 表示预期 的 target, 因此交叉嫡实际上表达的是希望这个function的output和它的target越接近越好 总之, 我们要找的参数实际上就是: w∗,b∗=arg⁡max⁡w,bL(w,b)=arg⁡min⁡w,b(−ln⁡L(w,b)=∑n−[y^nln⁡fw,b(xn)+(1−y^n)ln⁡(1−fw,b(xn))]w^{*}, b^{*}=\\arg \\max _{w, b} L(w, b)=\\arg \\min _{w, b}\\left(-\\ln L(w, b)=\\sum_{n}-\\left[\\hat{y}^{n} \\ln f_{w, b}\\left(x^{n}\\right)+\\left(1-\\hat{y}^{n}\\right) \\ln \\left(1-f_{w, b}\\left(x^{n}\\right)\\right)\\right]\\right. w∗,b∗=argw,bmax​L(w,b)=argw,bmin​(−lnL(w,b)=n∑​−[y^​nlnfw,b​(xn)+(1−y^​n)ln(1−fw,b​(xn))] step 3：Find the best function 实际上就是去找到使loss function即交叉嫡之和最小的那组参数 w∗,b∗w^{*}, b^{*}w∗,b∗ 就行了， 这里用gradient descent的方法进 行运算就Ok 这里sigmoid function的微分可以直接作为公式记下来: ∂σ(z)∂z=σ(z)(1−σ(z)),\\frac{\\partial \\sigma(z)}{\\partial z}=\\sigma(z)(1-\\sigma(z)),∂z∂σ(z)​=σ(z)(1−σ(z)), sigmoid和它的微分的图像如 下: 先计算 −ln⁡L(w,b)=∑n−[y^nln⁡fw,b(xn)+(1−y^n)ln⁡(1−fw,b(xn))]-\\ln L(w, b)=\\sum_{n}-\\left[\\hat{y}^{n} \\ln f_{w, b}\\left(x^{n}\\right)+\\left(1-\\hat{y}^{n}\\right) \\ln \\left(1-f_{w, b}\\left(x^{n}\\right)\\right)\\right]−lnL(w,b)=∑n​−[y^​nlnfw,b​(xn)+(1−y^​n)ln(1−fw,b​(xn))] 对 wiw_{i}wi​ 的偏微分 ,,, 这里 y^n\\hat{y}^{n}y^​n 和 1−y^n1-\\hat{y}^{n}1−y^​n 是常数先不用管它，只需要分别求出 lnfw,b(xn)lnf_{w, b}\\left(x^{n}\\right)lnfw,b​(xn) 和 ln⁡(1−fw,b(xn))\\ln \\left(1-f_{w, b}\\left(x^{n}\\right)\\right)ln(1−fw,b​(xn)) 对 wiw_{i}wi​ 的偏微分即可，整体推导过程如下： 将得到的式子进行进一步化简，可得： 梯度: θ∗=arg⁡min⁡θL(θ)\\theta^{*}=\\arg \\min _{\\theta} L(\\theta) θ∗=argθmin​L(θ) L: loss function θ\\thetaθ : parameters(上标表示第几组参数, 下标表示这组参数中的第几个参数) 正好跟gradient descent的目标一致, 因此可以直接用gradient descent来找到最好的参数θ 梯度更新公式: [Δθ1Δθ2]=−η[uv]=&gt;[θ1θ2]=[ab]−η[uv]=[ab]−η[∂L(a,b)∂θ1∂L(a,b)∂θz]\\left[\\begin{array}{l}\\Delta \\theta_{1} \\\\ \\Delta \\theta_{2}\\end{array}\\right]=-\\eta\\left[\\begin{array}{l}u \\\\ v\\end{array}\\right]=&gt;\\left[\\begin{array}{l}\\theta_{1} \\\\ \\theta_{2}\\end{array}\\right]=\\left[\\begin{array}{l}a \\\\ b\\end{array}\\right]-\\eta\\left[\\begin{array}{l}u \\\\ v\\end{array}\\right]=\\left[\\begin{array}{l}a \\\\ b\\end{array}\\right]-\\eta\\left[\\begin{array}{l}\\frac{\\partial L(a, b)}{\\partial \\theta_{1}} \\\\ \\frac{\\partial L(a, b)}{\\partial \\theta_{z}}\\end{array}\\right][Δθ1​Δθ2​​]=−η[uv​]=&gt;[θ1​θ2​​]=[ab​]−η[uv​]=[ab​]−η[∂θ1​∂L(a,b)​∂θz​∂L(a,b)​​] or θi=θi−1−η∇L(θi−1)\\theta^{i}=\\theta^{i-1}-\\eta \\nabla L\\left(\\theta^{i-1}\\right)θi=θi−1−η∇L(θi−1) 我们发现最终的结果竟然异常的简洁，gradient descent每次update只需要做： wi=wi−η(∑n−(y^n−fw,b(xn))xin)w_{i}=w_{i}-\\eta (\\sum_{n}-\\left(\\hat{y}^{n}-f_{w, b}\\left(x^{n}\\right)\\right) x_{i}^{n})wi​=wi​−η(∑n​−(y^​n−fw,b​(xn))xin​) 那这个式子到底代表着什么意思呢? 现在你的update取决于三件事: learning rate, 是你自己设定的 ⋅xi,\\cdot x_{i},⋅xi​, 来自于data y^n−fw,b(xn),\\hat{y}^{n}-f_{w, b}\\left(x^{n}\\right),y^​n−fw,b​(xn), 代表function的output跟理想target的差距有多大, 如果离目标越远, update的步伐就要越 大 Logistic Regression V.s. Linear Regression compare in step1 Logistic Regression是把每一个feature xix_{i}xi​ 加权求和, 加上bias, 再通过sigmoid function, 当做function的 output 因为Logistic Regression的output是通过sigmoid function产生的, 因此一定是介于0 1之间; 而linear Regression的output并没有通过sigmoid function, 所以它可以是任何值 compare in step2 在Logistic Regression中，我们定义的loss function, 即要去minimize的对象, 是所有example(样本点)的 output (f(xn))\\left(f\\left(x^{n}\\right)\\right)(f(xn)) )和实际target (y^n)\\left(\\hat{y}^{n}\\right)(y^​n) 在Bernoulli distribution(两点分布)下的cross entropy(交叉嫡)总和 交叉嫡的描述：这里把 f(xn)f\\left(x^{n}\\right)f(xn) 和 y^n\\hat{y}^{n}y^​n 各自看做是一个Bernoulli distribution(两点分布)，那它们的cross entropy l(f(xn),y^n)=−[y^nln⁡f(xn)+(1−y^n)ln⁡(1−f(xn))]l\\left(f\\left(x^{n}\\right), \\hat{y}^{n}\\right)=-\\left[\\hat{y}^{n} \\ln f\\left(x^{n}\\right)+\\left(1-\\hat{y}^{n}\\right) \\ln \\left(1-f\\left(x^{n}\\right)\\right)\\right]l(f(xn),y^​n)=−[y^​nlnf(xn)+(1−y^​n)ln(1−f(xn))] 之和, 就是我们要去minimize的对象, 直观来讲, 就 是希望function的output f(xn)f\\left(x^{n}\\right)f(xn) 和它的target y^n\\hat{y}^{n}y^​n 越接近越好 注：这里的“看做&quot;只是为了方便理解和计算，并不是真的做出它们是两点分布的假设 而在linear Regression中, loss function的定义相对比较简单, 就是单纯的function的output (f(xn))\\left(f\\left(x^{n}\\right)\\right)(f(xn)) 和实际 target⁡(y^n)\\operatorname{target}\\left(\\hat{y}^{n}\\right)target(y^​n) 在数值上的平方和的均值 这里可能会有一个疑惑, 为什么Logistic Regression的loss function不能像linear Regression一样用square error 来表示呢? 后面会有进一步的解释 compare in step3 神奇的是，Logistic Regression和linear Regression的update的方式是一模一样的，唯一不一样的是，Logistic Regression的target 和output 都必须是在0和1之间的，而linear Regression的target和output的范围可以是任意值 Logistic Regression + Square error？ 先说结论, 在分类问题中Square error不合适, cross entropy适合于分类问题 Square error求微分情况: 现在会遇到一个问题：如果第n个点的目标target是class 1,1,1, 则 y^n=1,\\hat{y}^{n}=1,y^​n=1, 此时如果function的output fw,b(xn)=1f_{w, b}\\left(x^{n}\\right)=1fw,b​(xn)=1 的话, 说明现在离target很接近了, fw,b(x)−y^丶xˉf_{w, b}(x)-\\hat{y} 丶 \\bar{x}fw,b​(x)−y^​丶xˉ 一项是0, 于是得到的微分 ∂L∂wi\\frac{\\partial L}{\\partial w_{i}}∂wi​∂L​ 会变成0，这件事情是很合理的; 但是当function的output fw,b(xn)=0f_{w, b}\\left(x^{n}\\right)=0fw,b​(xn)=0 的时候, 说明离target还很遥远, 但是由于在step3中求出来的update表达 式中有一个 fw,b(xn),f_{w, b}\\left(x^{n}\\right),fw,b​(xn), 因此这个时候也会导致得到的微分 ∂L∂wi\\frac{\\partial L}{\\partial w_{i}}∂wi​∂L​ 变成0==&gt;简而言之, 微分的结果不便于下一步的gradient descent 如果举class 2的例子，得到的结果与class 1是一样的 如果我们把参数的变化对total loss作图的话, loss function选择cross entropy或square error, 参数的变化跟 loss的变化情况可视化出来如下所示：(黑色的是cross entropy, 红色的是square error) 假设中心点就是距离目标很近的地方，如果是cross entropy的话，距离目标越远，微分值就越大，参数update的时候变化量就越大，迈出去的步伐也就越大 但当你选择square error的时候，过程就会很卡，因为距离目标远的时候，微分也是非常小的，移动的速度是非常慢的，我们之前提到过，实际操作的时候，当gradient接近于0的时候，其实就很有可能会停下来，因此使用square error很有可能在一开始的时候就卡住不动了，而且这里也不能随意地增大learning rate，因为在做gradient descent的时候，你的gradient接近于0，有可能离target很近也有可能很远，因此不知道learning rate应该设大还是设小 综上，尽管square error可以使用，但是会出现update十分缓慢的现象，而使用cross entropy可以让你的Training更顺利 Discriminative v.s. Generative same model but different currency Logistic Regression的方法，我们把它称之为discriminative的方法；而我们用Gaussian来描述posterior Probability这件事，我们称之为Generative的方法, 实际上它们用的model(function set)是一模一样的, 都是 P(C1∣x)=σ(w⋅x+b),P\\left(C_{1} \\mid x\\right)=\\sigma(w \\cdot x+b),P(C1​∣x)=σ(w⋅x+b), 如果是用Logistic Regression 的话, 可以用gradient descent的方法直接去把b和W找出来; 如果是用Generative model的话，我们要先去算 u1,u2,Σ−1u_{1}, u_{2}, \\Sigma^{-1} \\quadu1​,u2​,Σ−1 然后算出b和w 区别在于: 是否有假设? 你会发现用这两种方法得到的b和w是不同的，尽管我们的function set是同一个，但是由于做了不同的假设，最终从同样的Training data里找出来的参数会是不一样的 在Logistic Regression里面，我们没有做任何实质性的假设，没有对Probability distribution有任何的描述，我们就是单纯地去找b和w(推导过程中的假设只是便于理解和计算，对实际结果没有影响) 而在Generative model里面，我们对Probability distribution是有实质性的假设的，之前我们假设的是Gaussian(高斯分布)，甚至假设在相互独立的前提下是否可以是naive bayes(朴素贝叶斯)，根据这些假设我们才找到最终的b和w 例子: https://sakura-gh.github.io/ML-notes/ML-notes-html/7_Logistic-Regression.html 所以，Generative model和discriminative model的差别就在于，Generative的model它有做了某些假设，假设你的data来自于某个概率模型；而Discriminative的model是完全不作任何假设的, 完全根据数据说话 Generative model做的事情就是脑补，它会自己去想象一些事情，于是会做出一个和我们人类直觉想法不太一样的判断结果，就像toy example里，我们做了naive bayes这样一个假设(事实上我们并不知道这两个feature是否相互独立)，于是Naive bayes会在class 2里并没有出现过两个feature都是1的样本点的前提下，自己去脑补有这样的点 通常脑补不是一件好的事情，因为你给你的data强加了一些它并没有告诉你的属性，但是在data很少的情况下，脑补也是有用的，discriminative model并不是在所有的情况下都可以赢过Generative model，discriminative model是十分依赖于data的，当data数量不足或是data本身的label就有一些问题，那Generative model做一些脑补和假设，反而可以把data的不足或是有问题部分的影响给降到最低 Conclusion 对于分类的问题(主要是二元分类)，我们一般有两种方法去处理问题，一种是Generative的方法，另一种是Discriminative的方法，注意到分类问题的model都是从贝叶斯方程出发的，即 P(Ci∣x)=P(Ci)P(x∣Ci)∑j=1nP(Cj)P(x∣Cj)(1)=σ(z)=11+e−z=11+e−(b+∑kwkxk)\\begin{aligned} P\\left(C_{i} \\mid x\\right)=&amp; \\frac{P\\left(C_{i}\\right) P\\left(x \\mid C_{i}\\right)}{\\sum_{j=1}^{n} P\\left(C_{j}\\right) P\\left(x \\mid C_{j}\\right)}(1) \\\\ &amp;=\\sigma(z)=\\frac{1}{1+e^{-z}}=\\frac{1}{1+e^{-\\left(b+\\sum_{k} w_{k} x_{k}\\right)}} \\end{aligned}P(Ci​∣x)=​∑j=1n​P(Cj​)P(x∣Cj​)P(Ci​)P(x∣Ci​)​(1)=σ(z)=1+e−z1​=1+e−(b+∑k​wk​xk​)1​​ Generative model的好处是，它对data的依赖并没有像discriminative model那么严重，在data数量少或者data本身就存在noise的情况下受到的影响会更小，而它还可以做到Prior部分与class-dependent部分分开处理，如果可以借助其他方式提高Prior model的准确率，对整一个model是有所帮助的(比如前面提到的语音辨识) 而Discriminative model的好处是，在data充足的情况下，它训练出来的model的准确率一般是比Generative model要来的高的 Multi-class Classification softmax softmax的意思是对最大值做强化，因为在做第一步的时候，对取exponential会使大的值和小的值之间的差距被拉得更开，也就是强化大的值 Limitation of Logistic Regression Logistic Regression其实有很强的限制，给出下图的例子中的Training data，想要用Logistic Regression对它进行分类，其实是做不到的, 如异或 Feature Transformation 如果坚持要用Logistic Regression的话，有一招叫做Feature Transformation，原来的feature分布不好划分，那我们可以将之转化以后，找一个比较好的feature space，让Logistic Regression能够处理 但麻烦的是，我们并不知道怎么做feature Transformation，如果在这上面花费太多的时间就得不偿失了，于是我们会希望这个Transformation是机器自己产生的，怎么让机器自己产生呢？我们可以让很多Logistic Regression cascade(连接)起来 我们让一个input x的两个feature x1,x2x_{1}, x_{2}x1​,x2​ 经过两个Logistic Regression的transform, 得到新的feature x1′,x2′,x_{1}^{\\prime}, x_{2}^{\\prime},x1′​,x2′​, 在 这个新的feature space上, class 1和class 2是可以用一条直线分开的, 那么最后只要再接另外一个Logistic Regression的model(对它来说, x1′,x2′x_{1}^{\\prime}, x_{2}^{\\prime}x1′​,x2′​ 才是每一个样本点的&quot;feature&quot;, 而不是原先的 x1,x2),\\left.x_{1}, x_{2}\\right),x1​,x2​), 它根据新的 feature, 就可以把class 1和class 2分开 Powerful Cascading Logistic Regression 通过上面的例子，我们发现，多个Logistic Regression连接起来会产生powerful的效果，我们把每一个Logistic Regression叫做一个neuron(神经元)，把这些Logistic Regression串起来所形成的network，就叫做Neural Network，就是类神经网路，这个东西就是Deep Learning！ 8. P12 Brief Introduction of Deep Learning Ups and downs of Deep Learning 1958：Perceptron(linear model)，感知机的提出 和Logistic Regression类似，只是少了sigmoid的部分 1969：Perceptron has limitation，from MIT 1980s：Multi-layer Perceptron，多层感知机 和今天的DNN很像 1986：Backpropagation，反向传播 Hinton propose的Backpropagation 存在problem：通常超过3个layer的neural network，就train不出好的结果 、1989: 1 hidden layer is “good enough”，why deep？ 有人提出一个理论：只要neural network有一个hidden layer，它就可以model出任何的function，所以根本没有必要叠加很多个hidden layer，所以Multi-layer Perceptron的方法又坏掉了，这段时间Multi-layer Perceptron这个东西是受到抵制的 2006：RBM initialization(breakthrough)：Restricted Boltzmann Machine，受限玻尔兹曼机 Deep learning -&gt; another Multi-layer Perceptron ？在当时看来，它们的不同之处在于在做gradient descent的时候选取初始值的方法如果是用RBM，那就是Deep learning；如果没有用RBM，就是传统的Multi-layer Perceptron 那实际上呢，RBM用的不是neural network base的方法，而是graphical model，后来大家试验得多了发现RBM并没有什么太大的帮助，因此现在基本上没有人使用RBM做initialization了 RBM最大的贡献是，它让大家重新对Deep learning这个model有了兴趣(石头汤的故事) 2009：GPU加速的发现 2011：start to be popular in speech recognition，语音识别领域 2012：win ILSVRC image competition，Deep learning开始在图像领域流行开来 实际上，Deep learning跟machine learning一样，也是“大象放进冰箱”的三个步骤： 在Deep learning的step1里define的那个function，就是neural network Neural Network concept 把多个Logistic Regression前后connect在一起，然后把一个Logistic Regression称之为neuron，整个称之为neural network 我们可以用不同的方法连接这些neuron，就可以得到不同的structure，neural network里的每一个Logistic Regression都有自己的weight和bias，这些weight和bias集合起来，就是这个network的parameter，我们用来描述 Network Structure 如果一个neural network的参数weight和bias已知的话，它就是一个function，它的input是一个vector，output是另一个vector，这个vector里面放的是样本点的feature，vector的dimension就是feature的个数 input的地方，叫做input layer，输入层(严格来说input layer其实不是一个layer，它跟其他layer不一样，不是由neuron所组成的) output的地方，叫做output layer，输出层 其余的地方，叫做hidden layer，隐藏层 激活函数: 每一个neuron里面的sigmoid function，在Deep Learning中被称为activation function(激励函数)，事实上它不见得一定是sigmoid function，还可以是其他function(sigmoid function是从Logistic Regression迁移过来的，现在已经较少在Deep learning里使用了) ★.network structure+neuron该如何连接在一起的含义: 其实是define了一个function set(model) Feedforward network ▲.全连接: 因为layer和layer之间，所有的neuron都是两两连接，所以它叫Fully connected的network；因为现在传递的方向是从layer 1-&gt;2-&gt;3，由后往前传，所以它叫做Feedforward network Output Layer 我们可以把hidden layers这部分，看做是一个feature extractor(特征提取器)，这个feature extractor就replace了我们之前手动做feature engineering，feature transformation这些事情，经过这个feature extractor得到的就可以被当作一组新的feature output layer做的事情，其实就是把它当做一个Multi-class classifier，它是拿经过feature extractor转换后的那一组比较好的feature(能够被很好地separate)进行分类的，由于我们把output layer看做是一个Multi-class classifier，所以我们会在最后一个layer加上softmax 整个手写体识别分析: 我们唯一需要的就是一个function，这个function的input是一个256的vector，output是一个10维的vector，这个function就是neural network(这里我们用简单的Feedforward network) input固定为256维(图片)，output固定为10维的feedforward neural network，实际上这个network structure就已经确定了一个function set(model)的形状，在这个function set里的每一个function都可以拿来做手写数字识别，接下来我们要做的事情是用gradient descent去计算出一组参数，挑一个最适合拿来做手写数字识别的function 注：input、output的dimension，加上network structure，就可以确定一个model的形状，前两个是容易知道的，而决定这个network的structure则是整个Deep Learning中最为关键的步骤 所以这里很重要的一件事情是，我们要对network structure进行design，之前在做Logistic Regression或者是linear Regression的时候，我们对model的structure是没有什么好设计的，但是对neural network来说，我们现在已知的constraint只有input是256维，output是10维，而中间要有几个hidden layer，每个layer要有几个neuron，都是需要我们自己去设计的，它们近乎是决定了function set长什么样子 如果你的network structure设计的很差，这个function set里面根本就没有好的function，那就会像大海捞针一样，结果针并不在海里(滑稽 Step 1：Neural Network intput输入为16*16的图片(256维) --&gt;经过神经网络(函数) --&gt; 输出10维的vector --&gt; 经过softmax函数选出可能性最大的结果输出-output Step 2：Goodness of function input这张image的256个pixel，通过这个neural network之后，会得到一个output，称之为y；而从这张image的label中转化而来的target，称之为，有了output 和target 之后，要做的事情是计算它们之间的cross entropy(交叉熵)，这个做法跟我们之前做Multi-class classification的时候是一模一样的—&gt; 分类问题多使用交叉熵 Cross Entropy :l(y,y^)=−∑i=110y^i: l(y, \\hat{y})=-\\sum_{i=1}^{10} \\hat{y}_{i}:l(y,y^​)=−∑i=110​y^​i​lnyi_{i}i​ Step 3：Pick the best function 接下来就去调整参数，让这个cross entropy越小越好，当然整个training data里面不会只有一笔data，你需要把所有data的cross entropy都sum起来, 得到一个total loss L=∑n=1NlnL=\\sum_{n=1}^{N} l^{n}L=∑n=1N​ln （所有case的Cross Entropy ）, 得到loss function之后你要做的事情是找一组network的parameters：θ∗\\theta^{*}θ∗。它可以minimize这个total loss，这组parameter对应的function就是我们最终训练好的model 老规矩：我们使用Gradient Descent来优化total loss来获得model。实际上在deep learning里面用gradient descent，跟在linear regression里面使用完全没有什么差别，只是function和parameter变得更复杂了而已，其他事情都是一模一样的。 但是相比在liner model中求导还是比较轻松的， 在network中的function式子到底是长什么样子呢？==&gt; 需要用到反向传播—&gt;但是人工计算是比较复杂的, 因此有了pytorch, tensorflow等微分toolkit可以来计算Backpropagation Design network structure V.s. Feature Engineering(网络结构设计 vs 特征工程) deep learning: 通过network 找到一组合适的param来训练, 让机器自动学会如何提取特征==&gt;获得model 传统方法: 通过古圣先贤的先验知识对信息进行特征提取和分析==&gt;获得model 其实network structure的design是一件蛮难的事情，我们到底要怎么决定layer的数目和每一个layer的neuron的数目呢？其实这个只能够凭着经验和直觉、多方面的尝试，有时候甚至会需要一些domain knowledge(专业领域的知识)，从非deep learning的方法到deep learning的方法，并不是说machine learning比较简单，而是我们把一个问题转化成了另一个问题 原先非deep learning的model，要得到一个好的结果，往往需要做feature engineering(特征工程)，也就是做feature transform，然后找一组好的feature；一开始学习deep learning的时候，好像会觉得deep learning的layers之间也是在做feature transform，但实际上在做deep learning的时候，往往不需要一个好的feature ，比如说在做影像辨识的时候，你可以把所有的pixel直接丢进去，但是在过去做图像识别，你是需要对图像抽取出一些人定的feature出来的，这件事情就是feature transform，但是有了deep learning之后，你完全可以直接丢pixel进去硬做 但是，今天deep learning制造了一个新的问题，它所制造的问题就是，你需要去design network的structure，所以你的问题从本来的如何抽取feature==&gt;(转化成)怎么design network structure，所以deep learning是不是真的好用，取决于你觉得解决哪一个问题比较容易(如，以前做音频识别需要知道DFT些信号处理知识和方法，现在完全可以交给机器，让其自己学会DFT) 如果是影响辨识或者是语音辨识的话，design network structure可能比feature engineering要来的容易，因为，虽然我们人都会看、会听，但是这件事情，它太过潜意识了，它离我们意识的层次太远，我们无法意识到，我们到底是怎么做语音辨识这件事情，所以对人来说，你要抽一组好的feature，让机器可以很方便地用linear的方法做语音辨识，其实是很难的，因为人根本就不知道好的feature到底长什么样子；所以还不如design一个network structure，或者是尝试各种network structure，让machine自己去找出好的feature，这件事情反而变得比较容易，对影像来说也是一样的 有这么一个说法：deep learning在NLP上面的performance并没有那么好。语音辨识和影像辨识这两个领域是最早开始用deep learning的，一用下去进步量就非常地惊人，比如错误率一下子就降低了20%这样，但是在NLP上，它的进步量似乎并没有那么惊人，甚至有很多做NLP的人，现在认为说deep learning不见得那么work，这个原因可能是，人在做NLP这件事情的时候，由于人在文字处理上是比较强的，比如叫你设计一个rule去detect一篇document是正面的情绪还是负面的情绪，你完全可以列表，列出一些正面情绪和负面情绪的词汇，然后看这个document里面正面情绪的词汇出现的百分比是多少，你可能就可以得到一个不错的结果。所以NLP这个task，对人来说是比较容易设计rule的，你设计的那些ad-hoc(特别的)的rule，往往可以得到一个还不错的结果，这就是为什么deep learning相较于NLP传统的方法，觉得没有像其他领域一样进步得那么显著(但还是有一些进步的)===&gt;简言之, 这个语言问题较为容易研究, 以及前人传统方法研究已经非常深入, 效果也较好, 因此机器学习并没有太多的提升 长久而言，可能文字处理中会有一些隐藏的资讯是人自己也不知道的，所以让机器自己去学这件事情，还是可以占到一些优势，只是眼下它跟传统方法的差异看起来并没有那么的惊人，但还是有进步的 P15Why Deep- Q:参数变多,是变宽还是变深呢? 是不是暴力的方法呢? A: 论文比较相同参数, 深度效果好于宽度; DNN结构一个很大的优势是，Modularization(模块化)，它用的是结构化的架构 Modularization 就像写程序一样，shallow network实际上就是把所有的程序都写在了同一个main函数中，所以它去检测不同的class使用的方法是相互独立的；而deep network则是把整个任务分为了一个个小任务，每个小任务又可以不断细分下去，以形成modularization，就像下图一样 在DNN的架构中，实际上每一层layer里的neuron都像是在解决同一个级别的任务，它们的output作为下一层layer处理更高级别任务的数据来源，低层layer里的neuron做的是对不同小特征的检测，高层layer里的neuron则根据需要挑选低层neuron所抽取出来的不同小特征，去检测一个范围更大的特征；neuron就像是一个个classifier ，后面的classifier共享前面classifier的参数 这样做的好处是，低层的neuron输出的信息可以被高层不同的neuron重复使用，而并不需要像shallow network一样，每次在用到的时候都要重新去检测一遍，因此大大降低了程序的复杂度 理解效果：模组化： 如分类长发的女孩、长头发的男孩、短发的女孩、短发男孩。 ​ 如果按照shallow network的想法，我们分别独立地train四个classifier(其实就相当于训练四个独立的model)，然后就可以解决这个分类的问题。但是显而易见的是长头发的男生样本会非常少，没有太多的training data，所以，你train出来的classifier就比较weak，去detect长头发男生的performance就比较差 ![模组化](E:\\hexo\\source_posts\\李宏毅机器学习-摘要\\P12\\模组化.jpg 但其实我们的input并不是没有关联的，长头发的男生和长头发的女生都有一个共同的特征，就是长头发，因此如果我们分别独立地训练四个model作为分类器，实际上就是忽视了这个共同特征，也就是没有高效地用到data提供的全部信息，这恰恰是shallow network的弊端 而利用modularization的思想，使用deep network的架构，我们可以训练一个model作为分类器就可以完成所有的任务，我们可以把整个任务分为两个子任务： Classifier1：检测是男生或女生 Classifier2：检测是长头发或短头发 虽然长头发的男生data很少，但长头发的人的data就很多，经过前面几层layer的特征抽取，就可以头发的data全部都丢给Classifier2，把男生或女生的data全部都丢给Classifier1，这样就真正做到了充分、高效地利用数据，最终的Classifier再根据Classifier1和Classifier2提供的信息给出四类人的分类结果 你会发现，经过层层layer的任务分解，其实每一个Classifier要做的事情都是比较简单的，又因为这种分层的、模组化的方式充分利用了data，并提高了信息利用的效率，所以只要用比较少的training data就可以把结果train好 deep -&gt; modularization 做modularization的好处是把原来比较复杂的问题变得简单，比如原来的任务是检测一个长头发的女生，但现在你的任务是检测长头发和检测性别，而当检测对象变简单的时候，就算training data没有那么多，我们也可以把这个task做好，并且所有的classifier都用同一组参数检测子特征，提高了参数使用效率，这就是modularization、这就是模块化的精神 由于deep learning的deep就是在做modularization这件事，所以它需要的training data反而是比较少的，这可能会跟你的认知相反，AI=big data+deep learning，但deep learning其实是为了解决less data的问题才提出的 每一个neuron其实就是一个basic的classifier： 第一层neuron，它是一个最basic的classifier，检测的是颜色、线条这样的小特征 第二层neuron是比较复杂的classifier，它用第一层basic的classifier的output当作input，也就是把第一层的classifier当作module，利用第一层得到的小特征分类出不同样式的花纹 而第三层的neuron又把第二层的neuron当作它module，利用第二层得到的特征分类出蜂窝、轮胎、人 以此类推 这边要强调的是，在做deep learning的时候，怎么做模块化这件事情是machine自动学到的，也就是说，第一层要检测什么特征、第二层要检测什么特征…这些都不是人为指定的，人只有定好有几层layer、每层layer有几个neuron，剩下的事情都是machine自己学到的 传统的机器学习算法，是人为地根据domain knowledge指定特征来进行提取，这种指定的提取方式，甚至是提取到的特征，也许并不是实际最优的，所以它的识别成功率并没有那么高；但是如果提取什么特征、怎么提取这件事让机器自己去学，它所提取的就会是那个最优解，因此识别成功率普遍会比人为指定要来的高 Conclusion Deep总结： 考虑input之间的内在关联，所有的class用同一个model来做分类 modularization思想，复杂问题简单化，把检测复杂特征的大任务分割成检测简单特征的小任务 所有的classifier使用同一组参数的子特征检测器，共享检测到的子特征 不同的classifier会share部分的参数和data，效率高 联系logic circuit和剪纸画的例子 多层hidden layer对complex问题的处理上比较有优势 9. P13Backpropagation Backpropagation是神经网络中用来做gradient descent的方法， 目的是使优化函数尽可能得变成我们想要的， 假设我们现在要处理的是分类任务，loss function为交叉熵， total loss为L(θ)=∑n=1Nln(θ)L(\\theta)=\\sum_{n=1}^{N} l^{n}(\\theta)L(θ)=∑n=1N​ln(θ) 我们把training data里任意一个样本点 xnx^{n}xn 代到neural network里面, 它会output一个 yn,y^{n},yn, 我们把这个output跟样 本点本身的label标注的target y^n\\hat{y}^{n}y^​n 作cross entropy, 这个交叉嫡定义了output yny^{n}yn 与target y^n\\hat{y}^{n}y^​n 之间的距离 ln(θ)l^{n}(\\theta)ln(θ)。 如果cross entropy比较大的话, 说明output和target之间距离很远, 这个network的parameter的loss是比较大 的, 反之则说明这组parameter是比较好的， 然后总和所有training data的cross entropy ln(θ),l^{n}(\\theta),ln(θ), 得到total loss L(θ),L(\\theta),L(θ), 这就是我们的loss function, 用这个 L(θ)L(\\theta)L(θ) 对某一个参数w做偏微分, 表达式如下: ∂L(θ)∂w=∑n=1N∂ln(θ)∂w\\frac{\\partial L(\\theta)}{\\partial w}=\\sum_{n=1}^{N} \\frac{\\partial l^{n}(\\theta)}{\\partial w} ∂w∂L(θ)​=n=1∑N​∂w∂ln(θ)​ 这个表达式告诉我们, 只需要考虑如何计算对某一笔data的 ∂ln(θ)∂w,\\frac{\\partial l^{n}(\\theta)}{\\partial w},∂w∂ln(θ)​, 再将所有training data的cross entropy对参数 w的偏微分累计求和, 就可以把total loss对某一个参数w的偏微分给计算出来。 我们逐一分析，我们先考虑某一个neuron, 先拿出上图中被红色三角形圈住的neuron, 假设只有两个input x1,x2,x_{1}, x_{2},x1​,x2​, 通过这个 neuron, 我们先得到 z=b+w1x1+w2x2,z=b+w_{1} x_{1}+w_{2} x_{2},z=b+w1​x1​+w2​x2​, 然后经过activation function从这个neuron中output出来, 作为后 续neuron的input, 再经过了非常非常多的事情以后, 会得到最终的output y1,y2y_{1}, y_{2}y1​,y2​ 现在的问题是这样： ∂l∂w\\frac{\\partial l}{\\partial w}∂w∂l​ 该怎么算? 按照chain rule, 可以把它拆分成两项, ∂l∂w=∂z∂w∂l∂z,\\frac{\\partial l}{\\partial w}=\\frac{\\partial z}{\\partial w} \\frac{\\partial l}{\\partial z},∂w∂l​=∂w∂z​∂z∂l​, 这两项分别去把它计算 出来。前面这一项是比较简单的, 后面这一项是比较复杂的 计算前面这一项 ∂z∂w\\frac{\\partial z}{\\partial w}∂w∂z​ 的这个process, 我们称之为Forward pass; 而计算后面这项 ∂l∂z\\frac{\\partial l}{\\partial z}∂z∂l​ 的process, 我们称之为 Backward pass Forward pass 先考虑 ∂z∂w\\frac{\\partial z}{\\partial w}∂w∂z​ 这一项, 完全可以秒算出来, ∂z∂w1=x1,∂z∂w2=x2\\frac{\\partial z}{\\partial w_{1}}=x_{1}, \\frac{\\partial z}{\\partial w_{2}}=x_{2}∂w1​∂z​=x1​,∂w2​∂z​=x2​ 它的规律是这样的：求 ∂z∂w,\\frac{\\partial z}{\\partial w},∂w∂z​, 就是看w前面连接的input是什么, 那微分后的 ∂z∂w\\frac{\\partial z}{\\partial w}∂w∂z​ 值就是什么，因此只要计算出 neural network里面每一个neuron的output就可以知道任意的z对W的偏微分 比如input layer作为neuron的输入时，前面连接的是，所以微分值就是；前面连接的是，所以微分值就是 比如hidden layer作为neuron的输入时，那该neuron的input就是前一层neuron的output，于是的值就是前一层的z经过activation function之后输出的值(下图中的数据是假定activation function为sigmoid function得到的) Backward pass 再考虑 ∂l∂z\\frac{\\partial l}{\\partial z}∂z∂l​ 这一项, 它是比较复杂的, 这里我们依旧假设activation function是sigmoid function 公式推导 我们的z通过activation function得到a, 这个neuron的output是 a=σ(z),a=\\sigma(z),a=σ(z), 接下来这个a会乘上某一个weight w3w_{3}w3​ 再加上其它一大堆的value得到 z′,z^{\\prime},z′, 它是下一个neuron activation function的input, 然后a又会乘上另一个 weight w4,w_{4},w4​, 再加上其它一雄value得到 z′′,z^{\\prime \\prime},z′′, 后面还会发生很多很多其他事情, 不过这里我们就只先考虑下一步会 发生什公事情: ∂l∂z=∂a∂z∂l∂a\\frac{\\partial l}{\\partial z}=\\frac{\\partial a}{\\partial z} \\frac{\\partial l}{\\partial a} ∂z∂l​=∂z∂a​∂a∂l​ 这里的 ∂a∂z\\frac{\\partial a}{\\partial z}∂z∂a​ 实际上就是1. activation function的微分(在这里就是sigmoid function的微分)，接下来的问题是 ∂l∂a\\frac{\\partial l}{\\partial a}∂a∂l​ 应该长 什么样子呢? a会影响 z′z^{\\prime}z′ 和 z′′,z^{\\prime \\prime},z′′, 而 z′z^{\\prime}z′ 和 z′′z^{\\prime \\prime}z′′ 会影响 l,l,l, 所以通过chain rule可以得到 ∂l∂a=∂z′∂a∂l∂z′+∂z′′∂a∂l∂z′′\\frac{\\partial l}{\\partial a}=\\frac{\\partial z^{\\prime}}{\\partial a} \\frac{\\partial l}{\\partial z^{\\prime}}+\\frac{\\partial z^{\\prime \\prime}}{\\partial a} \\frac{\\partial l}{\\partial z^{\\prime \\prime}} ∂a∂l​=∂a∂z′​∂z′∂l​+∂a∂z′′​∂z′′∂l​ 这里的 ∂z′∂a=w3,∂z′′∂a=w4,\\frac{\\partial z^{\\prime}}{\\partial a}=w_{3}, \\frac{\\partial z^{\\prime \\prime}}{\\partial a}=w_{4},∂a∂z′​=w3​,∂a∂z′′​=w4​, 那 ∂l∂z′\\frac{\\partial l}{\\partial z^{\\prime}}∂z′∂l​ 和 ∂l∂z′′\\frac{\\partial l}{\\partial z^{\\prime \\prime}}∂z′′∂l​ 又该怎么算呢? 这里先假设我们已经通过某种方法把 ∂l∂z′\\frac{\\partial l}{\\partial z^{\\prime}}∂z′∂l​ 和 ∂l∂z′′\\frac{\\partial l}{\\partial z^{\\prime \\prime}}∂z′′∂l​ 这两项给算出来了，然后回过头去就可以把 ∂l∂z\\frac{\\partial l}{\\partial z}∂z∂l​ 给轻易地算出来 ==&gt; 上面是个递归的过程，因此需要从output计算 ∂l∂a\\frac{\\partial l}{\\partial a}∂a∂l​ ∂l∂z=∂a∂z∂l∂a=σ′(z)[w3∂l∂z′+w4∂l∂z′′]\\frac{\\partial l}{\\partial z}=\\frac{\\partial a}{\\partial z} \\frac{\\partial l}{\\partial a}=\\sigma^{\\prime}(z)\\left[w_{3} \\frac{\\partial l}{\\partial z^{\\prime}}+w_{4} \\frac{\\partial l}{\\partial z^{\\prime \\prime}}\\right] ∂z∂l​=∂z∂a​∂a∂l​=σ′(z)[w3​∂z′∂l​+w4​∂z′′∂l​] case 1: Output Layer 假设蓝色的这个neuron已经是hidden layer的最后一层了, 也就是说连接在 z′z^{\\prime}z′ 和 z′′z^{\\prime \\prime}z′′ 后的这两个红色的neuron已经 是output layer, 它的output就已经是整个network的output了, 这个时候计算就比较简单 ∂l∂z′=∂y1∂z′∂l∂y1\\frac{\\partial l}{\\partial z^{\\prime}}=\\frac{\\partial y_{1}}{\\partial z^{\\prime}} \\frac{\\partial l}{\\partial y_{1}} ∂z′∂l​=∂z′∂y1​​∂y1​∂l​ 其中 ∂y1∂z′\\frac{\\partial y_{1}}{\\partial z^{\\prime}}∂z′∂y1​​ 就是output layer的activation function (softmax) 对 z′z^{\\prime}z′ 的偏微分 而 ∂l∂y1\\frac{\\partial l}{\\partial y_{1}}∂y1​∂l​ 就是loss function对 y1y_{1}y1​ 的偏微分, 它取决于你的loss function是怎么定义的, 也就是你的output和target之间是怎么 evaluate的, 你可以用cross entropy, 也可以用mean square error, 用不同的定义, ∂l∂y1\\frac{\\partial l}{\\partial y_{1}}∂y1​∂l​ 的值就不一样 这个时候, 你就已经可以把l对 w1w_{1}w1​ 和 w2w_{2}w2​ 的偏微分 ∂l∂w1,∂l∂u2\\frac{\\partial l}{\\partial w_{1}}, \\frac{\\partial l}{\\partial u_{2}}∂w1​∂l​,∂u2​∂l​ 算出来了 另一个观点——反向计算的一句 这个式子还是蛮简单的, 然后, 我们可以从另外一个观点来看待这个式子 你可以想象说, 现在有另外一个neuron, 它不在我们原来的network里面, 在下图中它被画成三角形, 这个 neuron的input就是 ∂l∂z′\\frac{\\partial l}{\\partial z^{\\prime}}∂z′∂l​ 和 ∂l∂zn,\\frac{\\partial l}{\\partial z^{n}},∂zn∂l​, 那input ∂l∂z′\\frac{\\partial l}{\\partial z^{\\prime}}∂z′∂l​ 就乘上 w3,w_{3},w3​, input ∂l∂z′′\\frac{\\partial l}{\\partial z^{\\prime \\prime}}∂z′′∂l​ 就乘上 w4,w_{4},w4​, 它们两个相加再乘上activation function的微分 σ′(z),\\sigma^{\\prime}(z),σ′(z), 就可以得到output ∂l∂z\\frac{\\partial l}{\\partial z}∂z∂l​ 这张图描述了一个新的“neuron&quot;，它的含义跟图下方的表达式是一模一样的, 作这张图的目的是为了方便理解 值得注意的是, 这里的 σ′(z)\\sigma^{\\prime}(z)σ′(z) 是一个constant常数, 它并不是一个function, 因为z其实在计算forward pass的时候 就已经被决定好了, z是一个固定的值 所以这个neuron其实跟我们之前看到的sigmoid function是不一样的, 它并不是把input通过一个non-linear进行 转换, 而是直接把input乘上一个constant σ′(z),\\sigma^{\\prime}(z),σ′(z), 就得到了output, 因此这个neuron被画成三角形, 代表它跟我 们之前看到的圆形的neuron的运作方式是不一样的, 它是直接乘上一个constant(这里的三角形有点像电路里的运 算放大器op-amp, 它也是乘上一个constant) 知道 z′z^{\\prime}z′ 和 z′′z^{\\prime \\prime}z′′ 就可以知道 z,z,z, 知道 zaz_{a}za​ 和 zbz_{b}zb​ 就可以知道 z′,……,z^{\\prime}, \\ldots \\ldots,z′,……, 现在这个过程就可以反复进行下去, 直到找到output layer, 我们可以算出确切的值, 然后再一层一层反推回去 你可能会想说, 这个方法听起来挺让人崩溃的, 每次要算一个微分的值, 都要一路往后走, 一直走到network的 output, 如果写成表达式的话, 一层一层往后展开, 感觉会是一个很可怕的式子, 但是! 实际上并不是这个样子 做的 你只要换一个方向, 从output layer的 ∂l∂z\\frac{\\partial l}{\\partial z}∂z∂l​ 开始算, 你就会发现它的运算量跟原来的network的Feedforward path 其实是一样的 ▲注: 如果是正向做Backward pass的话, 实际上每次计算一个 ∂l∂z,\\frac{\\partial l}{\\partial z},∂z∂l​, 就需要把该neuron后面所有的 ∂l∂z\\frac{\\partial l}{\\partial z}∂z∂l​ 都给计算一 遍, 会造成很多不必要的里复运算, 如果写成code的形式, 就相当于调用了很多次里复的函数; 而如果是反向做 Backward pass，实际上就是把这些调用函数的过程都变成调用“值&quot;的过程, 因此可以直接计算出结果, 而不需要 占用过多的堆栈空间 Summary 最后，我们来总结一下Backpropagation是怎么做的 Forward pass，每个neuron的activation function的output，就是它所连接的weight的 Backward pass，建一个与原来方向相反的neural network，它的三角形neuron的output就是 把通过forward pass得到的和通过backward pass得到的乘起来就可以得到对的偏微分 11. P17Convolutional Neural Network 11_Convolutional Neural Network part1 12_Convolutional Neural Network part2 12. P14Tips for Training DNN 附录 机器学习系列10-手写数字识别(Keras2.0) ——10_Keras 机器学习系列6-分类问题(概率生成模型) P16PyTorch Tutorial P8Optimization for Deep Learning (1_2) (选学)","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"}]},{"title":"JupyterHub搭建","slug":"JupyterHub搭建","date":"2020-11-15T14:08:52.000Z","updated":"2020-11-20T05:59:09.392Z","comments":true,"path":"2020/11/15/JupyterHub搭建/","link":"","permalink":"https://nymrli.top/2020/11/15/JupyterHub搭建/","excerpt":"","text":"之前搭建的JupyterLab逐渐被使用起来了, 单用户的模式还是不太方便, 因此准备用JupyterHub来做下用户隔离 1. 安装nodejs和npm 按照JupyterLab官方教程, 先是安装最新的nodejs和npm, 但是由于16.04的apt源安装的nodejs版本比较久, 因此在后面的安装中会有坑, 这边根据网上的教程手动安装最新的nodejs 12$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -$ sudo apt-get install -y nodejs 安装成功后输入node --version看到有版本返回输出证明安装成功, 同时这种方式会同时安装npm, 同样npm --version测试npm安装成功 2. 安装 2.1 安装虚拟环境 由于我个人喜欢自己配置虚拟环境, 因此, 我先安装虚拟环境。但阿里云上的virtualenv太久不用，版本太老了， 出现了使用virtualenv创建虚拟环境报错 error code 2现象，因此通过 1234sudo pip install setuptools #安装setuptoolssudo pip install --upgrade setuptools #更新setuptools到最新版本sudo pip install virtualenv #安装virtualenvsudo pip install --upgrade virtualenv #更新virtualenv到最新版本 来更新setuptools和virtualenv到最新的版本 1$ virtualenv mlEnv 2.2 安装jupyterhub 根据官方教程，有两种方式安装：pip 安装 ; conda安装 1234567# pip安装$ python3 -m pip install jupyterhub$ sudo npm install -g configurable-http-proxy$ python3 -m pip install notebook # needed if running the notebook servers locally# conda安装$ conda install -c conda-forge jupyterhub # installs jupyterhub and proxy$ conda install notebook # needed if running the notebook servers locally 2.2.1 问题1_虚拟环境 但在安装过程中出现了以下报错 12ERROR: Could not install packages due to an EnvironmentError: [Errno 13] Permission denied: '/home/mrli/MLproject/mlEnv/lib/python3.5/site-packages/idna'Consider using the `--user` option or check the permissions. 通过which pip可以看到我使用的pip正是虚拟环境下的pip, 同时提示中的site-packages文件夹也是存在的。便按照提示加上了–user， 但是出现了如下新报错ERROR: Can not perform a '--user' install. User site-packages are not visible in this virtualenv. (注意, 不用加sudo来保证权限, 应为加上sudo pip吧库安装到的路径是在root下的) 经过查询发现, 是因为整个虚拟环境下的权限不够, 因此需要加权sudo chmod 777 -R mlEnv=&gt;遂问题解决 永久更改pip源和创建虚拟环境 2.2.2 问题2_npm安装报错 执行sudo npm install -g configurable-http-proxy时有如下报错Error: EACCES: permission denied, access '/usr/lib/node_modules'已经加上了sudo也无济于事。 ==&gt; 通过node的npm无法安装（无法过墙），也可以用阿里的自己的cnpm进行安装sudo npm install -g cnpm --registry=https://registry.npm.taobao.org,然后再输入sudo cnpm install -g configurable-http-proxy–&gt;解决! 3. 测试安装成功 jupyterhub -h、 configurable-http-proxy -h查看是否有输出, jupyterhub然后在https://localhost:8000中查看 4. 配置 生成配置文件 12$ jupyterhub --generate-config -f /etc/jupyterhub/jupyterhub_config.py$ jupyterhub --generate-config # 会在你的当前目录下生成一个jupyterhub_config.py文件, 我们在其中配置我们的网络和用户管理 1234567891011121314c.JupyterHub.ip = '192.168.2.4' # 本机局域网的ip，记得是局域网c.JupyterHub.port = 12443 # 指定服务端口c.Spawner.ip = '127.0.0.1' c.PAMAuthenticator.encoding = 'utf8'c.Authenticator.whitelist = &#123;'root','admin', 'tv', 'aiker'&#125; #默认不能使用root登录，需要修改配置. 这里面需要将linux的用户名添加进入，这样该用户就可以通过浏览器利用linux的用户名和密码登录自己的账户，jupyterhub采用和linux系统相同的认证方式，所以我们不需要另外建立用户，只需要登录linux的用户和密码即可 ==&gt; 用户白名单的用户会自动添加，但无密. 需要修改密需要创建linux用户才能登录；c.LocalAuthenticator.create_system_users = Truec.Authenticator.admin_users = &#123;'root', 'admin'&#125; # 指定admin用户c.JupyterHub.authenticator_class = 'dummyauthenticator.DummyAuthenticator'c.JupyterHub.statsd_prefix = 'jupyterhubc.Spawner.notebook_dir = '/volume1/study/' #jupyterhub自定义目录c.JupyterHub.statsd_prefix = 'jupyterhub'c.JupyterHub.ssl_cert = '/usr/syno/etc/certificate/_archive/xYa1nX/fullchain.pem'c.JupyterHub.ssl_key = '/usr/syno/etc/certificate/_archive/xYa1nX/privkey.pem' 默认情况下，要真正的实现分配用户账号，需要满足以下两点要求： c.Authenticator.whitelist 指定了用户名 在系统中创建了该用户（adduser / useradd） tips: 默认情况下，密码为系统中该用户对应的密码 用户管理 用户白名单的用户会自动添加，但无密码，需要修改密码才能登录； 新添加用户：useradd crxis -d /home/user/crxis -m 用户添加组：adduser crxis group1 修改用户密码：echo crxis:crxis|chpasswd 123456c.JupyterHub.admin_users = &#123;&apos;root&apos;, &apos;admin&apos;&#125;c.JupyterHub.bind_url = &apos;http://127.0.0.1:22223&apos;c.JupyterHub.hub_bind_url = &apos;http://127.0.0.1:22224&apos;c.JupyterHub.hub_port = 22225c.Authenticator.whitelist = &#123;&apos;root&apos;, &apos;mrli&apos;&#125;c.JupyterHub.hub_port = 22226 5. 运行 在存放jupyterhub_config.py的文件夹下执行jupyterhub启动服务 配置查看: https://blog.51cto.com/m51cto/2370679——GPU坑, 配置github登入 附录: 修改pip默认源: 1$ vim ~/.pip/pip.conf # 如果当前用户没有.pip文件夹, 则创建一个 添加下列内容 123456[global]index-url = http://pypi.douban.com/simple[install]use-mirrors =truemirrors =http://pypi.douban.com/simple/trusted-host =pypi.douban.com Linux上安装最新版的Python 查看 Python 的版本号：python2 -V, python3 -V 下载3.x新版本 可以访问python的官方网站查看最新的python版本以及下载链接：https://www.python.org/downloads/，将鼠标移到想要官网上想要下载的版本号上就可以看到下载地址，例如我需要在Linux下安装，可以使用这个链接：https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz（如果想要下载其他版本，直接修改版本号即可）。找到下载地址后，在命令行输入：wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz 下载完成后解压缩tar -zxvf Python-3.8.5.tgz 下载完成后解压缩cd Python-3.8.5/; ./configure, 由于使用3.8出现了virtualenv无法使用的情况, 因此需要对配置文件进行修改: 修改Python-3.8.5/Modules路径的Setup文件: sudo vim Setup: 编译sudo make; sudo make install 但是发现修改后报错缺少xxssl.h的头文件, wget https://www.openssl.org/source/openssl-1.0.2h.tar.gz tar zxf openssl-1.0.2h.tar.gz; cd openssl-1.0.2h ./config shared zlib; make depend sudo make; sudo make install 检测是否安装成功: openssl version -a ▲.再次到python中make install, 报错: subprocess.CalledProcessError: Command ‘(‘lsb_release’, ‘-a’)’ returned non-zero exit status 1. 解决方法 find /usr/bin -name lsb_release sudo rm -rf /usr/bin/lsb_release 此时再到Python/中make install即可","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"GithubActions","slug":"GithubAction","date":"2020-11-12T08:20:54.000Z","updated":"2020-11-12T09:35:54.644Z","comments":true,"path":"2020/11/12/GithubAction/","link":"","permalink":"https://nymrli.top/2020/11/12/GithubAction/","excerpt":"","text":"GitHub Actions 是 GitHub 的持续集成服务，于2018年10月推出。 GitHub Actions 是什么？ 大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。 如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。 GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 基础名词概念 GitHub Actions 有一些自己的术语。 （1）workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 （2）job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 （3）step（步骤）：每个 job 由多个 step 构成，一步步完成。 （4）action （动作）：每个 step 可以依次执行一个或多个命令（action）。 GitHub Actions阮一峰 具体内容说明: name自动构建的名字 on触发条件 watch监视 type:started 类型：点击了星标 可以是数组： [push, pull_request] env环境变量 jobs任务 build工作的id run-on工作运行的环境平台 if工作运行的判断 steps 包含一系列任务步骤 name子任务名 uses 使用官方的一些action库完成一些操作 run 运行脚本 id运行id workflow 文件 GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。 workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如foo.yml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。 综上, Github actions配合GithubPages会非常方便 什么是 GitHub Pages? 打开 GitHub Pages 的首页我们会看到如下图所示： 他可以当做你或者你的项目的 Websites，那么我们可以知道 GitHub Pages 有两种最基本的用法： 作为你自己（或者组织）的网站（访问地址示例：http://username.github.io） 作为你某一个项目的网站（访问地址示例：http://username.github.io/projectname） 由于性能不太好, 因此最主要的用途是作为部署静态网页, 给demo展示: 做 demo 展示不同于做项目开发, 我们需要的是快速轻便的开发和部署, 而不是完备的一整套开发流程. Github pages 的好处 使用零成本: github pages 集成在 github 中, 直接和代码管理绑定在一起, 随着代码更新自动重新部署, 使用非常方便. 免费: 免费提供 username.github.io 的域名, 免费的静态网站服务器. 无数量限制: github pages 没有使用的数量限制, 每一个 github repository 都可以部署为一个静态网站. workflowDemo 官方demo 默认的生成模板: 会在仓库的./github/workflows目录下创建一个.yml的文件 123456789101112131415161718192021222324252627282930313233343536# This is a basic workflow to help you get started with Actionsname: CI# Controls when the action will run. Triggers the workflow on push or pull request# events but only for the main branchon: push: branches: [ main ] pull_request: branches: [ main ]# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs: # This workflow contains a single job called \"build\"——任务名 build: # The type of runner that the job will run on # To set the operating system for your job, specify the operating system using runs-on: ubuntu-latest, ubuntu-18.04, or ubuntu-16.04、windows-latest or windows-2019、macos-latest or macos-10.15 runs-on: ubuntu-latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it # 检出， 将代码从代码库中拉下来， 然后复制到本地的虚拟机上 - uses: actions/checkout@v2 # Runs a single command using the runners shell # 给操作——run, 起个操作名——name - name: Run a one-line script run: echo Hello, world! # Runs a set of commands using the runners shell - name: Run a multi-line script run: | echo Add other actions to build, echo test, and deploy your project. BiliBiliTool的workflow 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950name: bilibili-daily-taskon: push: # push触发 branches: [ main ] workflow_dispatch: # 手动触发 schedule: # 计划任务触发 - cron: '10 6 * * *' # cron表达式，Actions时区是UTC时间，所以要往前推8个小时,如上表示每天14点10分 jobs: run-bilibili-tool: runs-on: ubuntu-latest steps: # 检出 - name: Checkout uses: actions/checkout@v2 # 设置服务器时区为东八区 - name: Set time zone run: sudo timedatectl set-timezone 'Asia/Shanghai' # .Net Core 环境 - name: Setup .NET Core uses: actions/setup-dotnet@v1 with: dotnet-version: 3.1.301 # 安装依赖 - name: Install dependencies run: dotnet restore # 构建应用 - name: Build run: dotnet build --configuration Release --no-restore # 运行 - name: Run # env是从仓库settings的secrets中取值 env: userId: $&#123;&#123;secrets.USERID&#125;&#125; sessData: $&#123;&#123;secrets.SESSDATA&#125;&#125; biliJct: $&#123;&#123;secrets.BILIJCT&#125;&#125; otherConfigs: $&#123;&#123;secrets.OTHERCONFIGS&#125;&#125; run: dotnet run -p ./src/Ray.BiliBiliTool.Console -userId=$&#123;userId&#125; -sessData=$&#123;sessData&#125; -biliJct=$&#123;biliJct&#125; -closeConsoleWhenEnd=1 $&#123;otherConfigs&#125;","categories":[],"tags":[{"name":"小白文","slug":"小白文","permalink":"https://nymrli.top/tags/小白文/"}]},{"title":"南邮校园网CSDN等部分网站图片无法加载解决方案","slug":"南邮校园网CSDN等部分网站图片无法加载解决方案","date":"2020-11-10T10:14:56.000Z","updated":"2020-11-10T10:28:28.033Z","comments":true,"path":"2020/11/10/南邮校园网CSDN等部分网站图片无法加载解决方案/","link":"","permalink":"https://nymrli.top/2020/11/10/南邮校园网CSDN等部分网站图片无法加载解决方案/","excerpt":"","text":"问题定位 转自： https://blog.csdn.net/pamzerbhu/article/details/108549279 用语言描述如下： 打开页面后页面加载正常，但是图片完全没有加载。但是挂全局代理是可以看到图片的。挂代理后如下所示： 开始定位问题： 点击审查元素，接着找到我这张图的链接，直接用浏览器打开，报错**NET::ERR_CERT_COMMON_NAME_INVALID** 然后点击 高级–继续访问 img-blog.csdn.net (不安全) 图片成功加载： 好了，找到了问题。接下来就是面向搜索引擎的找方法时间。 经过查询发现是DNS的问题（或者可以打开cmd，然后输入ipconfig/all看DNS地址）： 解决方案 我们尝试修改dns，并刷新。 修改教程点我. 再次查看确认已经不再是坑爹的南邮DNS了。访问csdn发现一切正常。OK结束。 ERR_CERT_COMMON_NAME_INVALID 实际上，可以认为，ERR_CERT_COMMON_NAME_INVALID就是用一个错误的域名访问了某个节点的https资源。导致这个错误的原因，基本是 dns污染 host设置错误 官方更新了dns，但是dns缓存没有被更新，导致错误解析。","categories":[],"tags":[]},{"title":"scrcpy+AutoJS","slug":"scrcpy-AutoJS","date":"2020-11-09T03:26:19.000Z","updated":"2020-11-14T07:17:12.129Z","comments":true,"path":"2020/11/09/scrcpy-AutoJS/","link":"","permalink":"https://nymrli.top/2020/11/09/scrcpy-AutoJS/","excerpt":"","text":"scrcpy简介 特点: 利用电脑的键盘和鼠标可以控制手机。把 APK 文件拖拽到电脑窗口即可安装应用到手机，把普通文件拖拽到窗口即可复制到手机。 不需要在手机上安装任何应用。 简单地来说，scrcpy就是通过adb调试的方式来将手机屏幕投到电脑上，并可以通过电脑控制您的Android设备。它可以通过USB连接，也可以通过Wifi连接（类似于隔空投屏），而且不需要任何root权限，不需要在手机里安装任何程序。scrcpy同时适用于GNU / Linux，Windows和macOS。 它的一些特性： 亮度（原生，仅显示设备屏幕） 性能（30~60fps） 质量（1920×1080或以上） 低延迟（35~70ms） 启动时间短（显示第一张图像约1秒） 非侵入性（设备上没有安装任何东西） 此项目为开源项目，Github地址：Genymobile/scrcpy: Display and control your Android device 使用scrcpy的要求 Android设备至少需要API 21（Android 5.0以上版本）; 确保在您的设备上启用了adb调试; 在某些设备上，您还需要启用其他选项以使用键盘和鼠标控制它。 adb调试的开启一般是多次点击手机系统版本，如我用的是MIUI10，开启方法是 “设置”-&gt;“我的设备”-&gt;“全部参数”-&gt;点击7下MIUI版本，开启“开发者选项”。然后在 “设置”-&gt;“更多设置”-&gt;“开发者选项” 中同时开启 USB调试 和 USB调试(安全设置)。 使用说明 程序使用了Java语言，我们需要在电脑中搭建Java运行环境，参考：Windows10 配置 Java 开发环境 使用USB进行连接 此方式推荐使用，相对更加流畅。 手机通过USB连接到PC上，首次连接会弹出是否信任该电脑，点击始终信任即可。 运行adb usb查看是否连接成功 12D:\\Github_Run\\scrcpy-win64-v1.10&gt;adb usbrestarting in USB mode 运行scrcpy即可。 使用无线连接 可参考官方文档：Open Source Project - Scrcpy now works wirelessly 此连接方式更加方便快捷，若宽带速率高，使用效果更佳，使用方法也非常简单。 确保PC和手机在同一Wifi中 手机先通过USB与PC相连 在PC上运行 adb tcpip 服务端口，如端口为5555 12D:\\Github_Run\\scrcpy-win64-v1.10&gt;adb tcpip 5555restarting in TCP mode port: 5555 拔下你的设备，断开USB连接 在PC上运行 adb connect 手机IP:服务端口（手机IP可通过手机的状态信息查看，或者登录路由器查看，一般以192.168开头） 12D:\\Github_Run\\scrcpy-win64-v1.10&gt;adb connect 192.168.0.4:5555connected to 192.168.0.4:5555 运行scrcpy，在cmd中输入scrcpy.exe即可 注: 若要切换回USB模式：adb usb 1234# 附调节比特率和分辨率$ scrcpy --bit-rate 2M --max-size 800# 或者简写$ scrcpy -b2M -m800 AutoJS 一个支持无障碍服务的Android平台上的JavaScript IDE，其发展目标是JsBox和Workflow。 Auto.js使用JavaScript作为脚本语言，目前使用Rhino 1.7.7.2作为脚本引擎，支持ES5与部分ES6特性。 官方教程: https://hyb1996.github.io/AutoJs-Docs/#/?id=autojs 使用教程视频: 笔青居 如何连接? 手机安装使用步骤： ① 开启无障碍服务 ② 音量上键停止脚本：当脚本处于无法停止的状态时，使用音量上键强制停止脚本。 ③ 开启悬浮窗： ④ 连接手机(如果不习惯在手机上coding, 可以安装作者提供的VsCode插件, 在Vscode上编码: Auto.js-VSCodeExt——插件的使用教程也非常简洁易懂， 在此就不重复了。 微信朋友圈点赞demo 123456789comment = desc(\"评论\").findOne();log(comment);comment.click();sleep(1000);// 由于\"赞\"控件的Clickable是false, 所以点击它的父控件praise = text(\"赞\").findOne();praiseParent = praise.parent();praiseParent.click(); Js知识补充 作用域: JS只有函数作用域和全局作用域 全局作用域: 如果是显性的写在全局的, 则变量的作用域为全局 12345678910111213141516&gt; /*&gt; * 作用域&gt; * - 作用域指一个变量的作用的范围&gt; * - 在JS中一共有两种作用域：&gt; * 1.全局作用域&gt; * - 直接编写在script标签中的JS代码，都在全局作用域&gt; * - 全局作用域在页面打开时创建，在页面关闭时销毁&gt; * - 在全局作用域中有一个全局对象window，&gt; * 它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用&gt; * - 在全局作用域中：&gt; * 创建的变量都会作为window对象的属性保存&gt; * 创建的函数都会作为window对象的方法保存&gt; * 一切皆对象&gt; * - 全局作用域中的变量都是全局变量，&gt; * 在页面的任意的部分都可以访问的到&gt; 块级作用域: {}为块, {}内即为块级作用域。但是注意JS没有块级作用域， 即块里声明的变量, 作用域实际为全局。—&gt;ES6 新增了let命令，用来声明局部变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效，而且有暂时性死区的约束。==&gt;ES6用新增的let，来声明块级作用域的变量。(let另一个特性: let变量不能重复声明–var可以, 以最后的为准, 效果跟python声明变量类似) 123456for(var i = 1; i &lt; 10; i++)&#123;&#125;log(i); // 输出为10for(let i = 1; i &lt; 10; i++)&#123;&#125;log(i); // ReferenceError: \"i\" is not defined. ([remote]test.js#14)ReferenceError: \"i\" is not defined. 函数作用域: 在函数内即为函数作用域， 如果不用var表明， 则声明的是全局变量。用var表明是局部变量 123456789101112&gt; /*&gt; * 函数作用域&gt; * - 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁&gt; * - 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的&gt; * - 在函数作用域中可以访问到全局作用域的变量&gt; * 在全局作用域中无法访问到函数作用域的变量&gt; * - 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用&gt; * 如果没有则向上一级作用域中寻找，直到找到全局作用域，&gt; * 如果全局作用域中依然没有找到，则会报错ReferenceError&gt; * - 在函数中要访问全局变量可以使用window对象&gt; */&gt; 12345678function test()&#123; a = 1; var b = 2;&#125;test();log(a); // 输出1log(b); // ReferenceError: \"b\" is not defined. ([remote]test.js#19)ReferenceError: \"b\" is not defined. 数组 12345678910a = [1,2,3] // 第一种声明数组的方式a.push(4) // 往数组最后添加元素log(a);log(a.indexOf(2)); // 找出某元素在数组中的索引a.pop(); // 弹出最后一个元素log(a);b = Array(); // 第二种声明数组的方式log(b); 数据类型: string、number、boolean、nullundefined Object：Function、Array、Date 可以使用typeof来查看对象的类型 变量函数提前声明 123456789101112131415161718192021222324252627/** 变量的声明提前* - 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），* 但是如果声明变量时不使用var关键字，则变量不会被声明提前** 函数的声明提前* - 使用函数声明形式创建的函数 function 函数()&#123;&#125;* 它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数* 使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用*//*console.log(&quot;a = &quot;+a);情况1：使用 var a = 123; a是undefined，声明变量在此句之后，但var a 会使变量提前声明，情况2： 使用 a = 123; a未找到，会报错，因为a未提前声明a = 123； 等价于 window.a = 123;var a = 123;*/ 到了此句才赋值，等价于在所有代码之前 声明a var a; 执行到此句再赋值 a=123;//fun();//函数声明，会被提前创建function fun()&#123;console.log(&quot;我是一个fun函数&quot;);&#125;//函数表达式，不会被提前创建，此句只是提前声明了fun2，不知道是不是函数，可能是变量， undefined而在此次才开始赋值一个函数表达式var fun2 = function()&#123;console.log(&quot;我是fun2函数&quot;);&#125;;fun2(); Andriod开发知识： packageName： 应用包名 applicationName: 应用名 currenetActivity: 当前页面 Js是单线程的, 在任务调度上，同步任务优先级最高， 微任务其次(new Promise)， 宏任务最后(setInterval, setTimeOut): https://www.bilibili.com/video/BV1NJ411W7wh?p=336 123456789new Promise( (resolve, reject) =&gt;&#123; resolve(); // 调用resolve表示成功, 调用reject表示失败 console.log(\"yes\") // 第一个大括号里的都是同步任务, 优先级很高&#125;).then(value =&gt;&#123; // 成功执行这个. 这个是微任务 console.log(\"成功\")&#125;, reason =&gt; &#123; console.log(\"失败\") // 失败执行这个. 这个是微任务&#125;)// 输出结果: yes =&gt; 成功","categories":[],"tags":[]},{"title":"粒子滤波Matlab代码解读","slug":"粒子滤波Matlab代码解读","date":"2020-10-27T09:39:23.000Z","updated":"2020-10-31T02:12:39.559Z","comments":true,"path":"2020/10/27/粒子滤波Matlab代码解读/","link":"","permalink":"https://nymrli.top/2020/10/27/粒子滤波Matlab代码解读/","excerpt":"","text":"粒子滤波概念 理解粒子滤波(particle filter) 粒子滤波的Matlab仿真算法实现 1.1 机器人定位问题 关于机器人定位，有三大问题，它们分别是： (1)“全局定位”：指初始位置未知，机器人靠自身运动确定自己在地图中的位姿。 (2)“位姿跟踪”：指已知自身位姿或者已经通过“全局定位”得到了一个较好的位姿估计，在后续运动时补偿精度较差的运动控制误差； (3)“绑架劫持”：指机器人在已知自身位姿的情况下，得到了一个错误的位姿信息或者外界将其放到另外一个位姿，而里程计信息给出了错误的信息甚至没有给出控制信息。 1.2 粒子滤波步骤(可结合2中例题) (1)初始状态：用大量粒子模拟运动状态，使粒子在空间内均匀分布； (2)预测阶段：根据状态转移方程，将每一个粒子带入，得到一个预测粒子； (3)校正阶段：对预测粒子进行评价（计算权重），越接近于真实状态的粒子，其权重越大； (4)重采样：根据粒子权重对粒子进行筛选，筛选过程中，既要大量保留权重大的粒子，又要有一小部分权重小的粒子； (5)滤波：将重采样后的粒子带入状态转移方程得到新的预测粒子，即步骤(2)。 代码分析 虽然选修课选修了Matlab， 但是自己Matlab工程代码到底写了太少， 特别是涉及维度转换以及数学相关的玩的都不是很好， 因此这次看这份代码学到了很多基础入门的写法， 记录一下： 变量关系： X为对象的真实位置， Z是观测到对象的观测位置（在真实的坐标上加上了噪声），P是粒子群，Pcenter是所有粒子的几何中心 变量维度的确定： 行为一维，列为二维。其中X(1, :)表示X坐标， X(2, :)表示Y坐标。其中列的T表示多少测量数量，测量时间。 err大小也是(2, T)， 但是(第一行为粒子与真实路径误差 第二行为测量与真实路径误差) 权重更新方式： 权重 (权重与距离的关系 为 均值是0,方差是sqrt®的高斯分布曲线) 代码组成部分： 参数设置 初始化粒子群 开始运动 绘制轨迹 绘制误差图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128%粒子滤波(定位运动轨迹)%在二维空间,假设运动物体的一组(非线性)运动位置、速度、加速度数据,用粒子滤波方法进行处理clc,clear,close all%% 参数设置N = 200; %粒子总数Q = 5; %过程噪声(控制误差) 状态转移方程中使用R = 5; %测量噪声 由真实位置叠加测量噪声得到测量位置T = 10; %测量时间(总步数)theta = pi/T; %旋转角度distance = 80/T; %每次走的距离(步长)WorldSize = 100; %世界大小% 设定变量维度X = zeros(2, T); %存储系统状态(每列存储二维位置坐标(x,y),共T个位置)Z = zeros(2, T); %存储系统的观测状态(每列存储二维位置坐标(x,y),共T次测量)P = zeros(2, N); %建立粒子群(每列存储当前粒子的二维位置坐标,共N个粒子)PCenter = zeros(2, T); %所有粒子的中心位置w = zeros(N, 1); %每个粒子的权重err = zeros(2,T); %误差(第一行为粒子与真实路径误差 第二行为测量与真实路径误差)X(:, 1) = [50; 20]; %初始系统状态 即初始位置在坐标(50,20)Z(:, 1) = X(:,1) + wgn(2,1,10*log10(R)); %初始系统的观测状态(为真实位姿叠加高斯噪声) %y = wgn(m,n,p) 产生一个m行n列的高斯白噪声的矩阵，p以dBW为单位指定输出噪声的强度%% 初始化粒子群for i = 1 : N P(:, i) = [WorldSize*rand; WorldSize*rand]; %随机产生第i个粒子的坐标(rand为产生[0,1]之间均匀分布) dist = norm(P(:, i)-Z(:, 1)); %与测量位置相差的距离 %求权重 (权重与距离的关系 为 均值是0,方差是sqrt(R)的高斯分布曲线) % 因为均值为0且距离大于0 因此权重随着距离增加沿高斯曲线右侧递减 w(i) = (1 / sqrt(R) / sqrt(2 * pi)) * exp(-(dist)^2 / 2 / R); endPCenter(:, 1) = sum(P, 2) / N;%t=1时刻(初始时刻)所有粒子的几何中心位置% 初始状态(t=1)画图err(1,1) = norm(X(:, 1) - PCenter(:, 1));%粒子群几何中心与系统真实状态的误差err(2,1) = wgn(1, 1, 10*log10(R));figure(1);hold onset(0,'defaultfigurecolor','w')plot(X(1, 1), X(2, 1), 'r.', 'markersize',30) %真实的初始状态位置(红点表示)%grid onaxis([0 100 0 100]);set(gca,'XTick',0:10:100) %改变x轴坐标间隔显示 这里间隔为10set(gca,'YTick',0:10:100) %改变y轴坐标间隔显示 这里间隔为10plot(P(1, :), P(2, :), 'k.', 'markersize',5); %各个粒子位置(N个黑点)plot(PCenter(1, 1), PCenter(2, 1), 'b.', 'markersize',25); %所有粒子的中心位置(蓝点表示)legend('真实位置', '粒子群', '粒子群的几何中心');title('初始状态');hold off%% 开始运动for k = 2 : T %从t=2到T %模拟一个弧线运动的状态 X(:, k) = X(:, k-1) + distance * [(-cos(k * theta)); sin(k * theta)] + wgn(2, 1, 10*log10(Q)); %状态方程 Z(:, k) = X(:, k) + wgn(2, 1, 10*log10(R)); %观测方程(状态上叠加测量的高斯噪声) %粒子滤波 % 1.预测 for i = 1 : N P(:, i) = P(:, i) + distance * [-cos(k * theta); sin(k * theta)] + wgn(2, 1, 10*log10(Q));%粒子群带入状态方程 dist = norm(P(:, i)-Z(:, k)); %粒子群中各粒子 与 测量位置 的距离 w(i) = (1 / sqrt(R) / sqrt(2 * pi)) * exp(-(dist)^2 / 2 / R); %求权重(距离近权重大) end % 2.归一化权重 wsum = sum(w); for i = 1 : N w(i) = w(i) / wsum; end % 3.重采样（更新）——可以理解为转转盘 for i = 1 : N wmax = 2 * max(w) * rand; %另一种重采样规则 index = randi(N, 1);%生成一个在[1(默认值),N]之间均匀分布的伪随机整数 while(wmax &gt; w(index)) % 找到具体落在哪个区间上 wmax = wmax - w(index); index = index + 1; if index &gt; N index = 1; end end Pnext(:, i) = P(:, index); %得到新粒子放入临时集Pnext end P=Pnext;%用临时集Pnext更新粒子集P PCenter(:, k) = sum(P, 2) / N; %重采样后所有粒子的中心位置 %计算误差 err(1,k) = norm(X(:, k) - PCenter(:, k)); %粒子几何中心与系统真实状态的误差 err(2,k) = norm(X(:, k) - Z(:, k)); %画图 figure(2); set(0,'defaultfigurecolor','w') clf;%清空figure(2)中的图像 以便循环重新画 hold on plot(X(1, k), X(2, k), 'r.', 'markersize',30); %系统状态位置 plot(P(1, :), P(2, :), 'k.', 'markersize',5); %各个粒子位置 plot(PCenter(1, k), PCenter(2, k), 'b.', 'markersize',25); %所有粒子的中心位置 axis([0 100 0 100]); title('运动过程'); legend('真实状态', '粒子群', '粒子群的几何中心'); hold off pause(0.1);%停0.1s开始下次迭代end%% 绘制轨迹figure(3);set(0,'defaultfigurecolor','w')plot(X(1,:), X(2,:), 'r.-', Z(1,:), Z(2,:), 'g.-', PCenter(1,:), PCenter(2,:), 'b.-');axis([0 100 0 100]);set(gca,'XTick',0:10:100) %改变x轴坐标间隔显示 这里间隔为10set(gca,'YTick',0:10:100) %改变y轴坐标间隔显示 这里间隔为10legend('真实轨迹', '测量轨迹', '粒子群几何中心轨迹');xlabel('横坐标 x'); ylabel('纵坐标 y');%% 绘制误差figure(4);set(0,'defaultfigurecolor','w')%set(gca,'FontSize',12);%设置图标字体大小plot(err(1,:),'b.-');%err1为各时刻 真实位置与粒子群中心的几何距离hold onplot(err(2,:),'r.-');%err2为各时刻 真实位置与测量位置的几何距离hold offxlabel('步数 t');legend('粒子群误差', '测量误差');title('真实位置与粒子群中心的集合距离'); 用到的函数记录 Matlab中的norm demo代码中有关norm的运用如下, 12345678%% 初始化粒子群for i = 1 : N P(:, i) = [WorldSize*rand; WorldSize*rand]; %随机产生第i个粒子的坐标(rand为产生[0,1]之间均匀分布) dist = norm(P(:, i)-Z(:, 1)); %与测量位置相差的距离 %求权重 (权重与距离的关系 为 均值是0,方差是sqrt(R)的高斯分布曲线) % 因为均值为0且距离大于0 因此权重随着距离增加沿高斯曲线右侧递减 w(i) = (1 / sqrt(R) / sqrt(2 * pi)) * exp(-(dist)^2 / 2 / R); end 其中没有特别指出是啥范数, 因此可以通过help norm来查看一下关于norm的使用介绍. 1234567&gt;&gt; help norm norm Matrix or vector norm. norm(X,2) returns the 2-norm of X. norm(X) is the same as norm(X,2). norm(X,1) returns the 1-norm of X. 可以得到, norm(X)的效果默认是取2-范数的。 同时， norm函数既可以取向量范数又可以取矩阵范数： 1、如果A为矩阵 n=norm(A) 《Simulink与信号处理》 返回A的最大奇异值，即max(svd(A)) n=norm(A,p) 根据p的不同，返回不同的值 p 返回值 1 返回A中最大一列和，即max(sum(abs(A))) 2 返回A的最大奇异值，和n=norm(A)用法一样 inf 返回A中最大一行和，即max(sum(abs(A’))) ‘fro’ A和A‘的积的对角线和的平方根，即sqrt(sum(diag(A’*A))) 2、如果A为向量 norm(A,p) 返回向量A的p范数。即返回 sum(abs(A).p)(1/p),对任意 1&lt;p&lt;+∞. norm(A) 返回向量A的2范数，即等价于norm(A,2)。 norm(A,inf) 返回max(abs(A)) norm(A,-inf) 返回min(abs(A)) Matlab中的sum sum(A, 1)： 对一维求和， 如果A为二维数组， 则按列求和 sum(A, 2): 对二维求和， 如果A为二维数组， 则按行求和 Matlab中的wgn 12345678&gt;&gt; help wgn wgn Generate white Gaussian noise. Y = wgn(M,N,P) generates an M-by-N matrix of white Gaussian noise. P specifies the power of the output noise in dBW. The unit of measure for the output of the wgn function is Volts. For power calculations, it is assumed that there is a load of 1 Ohm. Y = wgn(M,N,P,IMP) specifies the load impedance in Ohms.","categories":[],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://nymrli.top/tags/Matlab/"}]},{"title":"范数的概念_MATLAB使用","slug":"范数的概念-MATLAB使用","date":"2020-10-27T08:13:30.000Z","updated":"2020-10-27T10:26:44.365Z","comments":true,"path":"2020/10/27/范数的概念-MATLAB使用/","link":"","permalink":"https://nymrli.top/2020/10/27/范数的概念-MATLAB使用/","excerpt":"","text":"范数 之前大二在看机器学习的时候一直看到&quot;范数&quot;这个名词, 但是一直没有去详细了解过, 就只知道2-范数相当于两个点在二维平面的距离。这次在看粒子滤波matlab实现代码的时候看到了norm函数, 正好补一下关于范数的概念。 向量的范数 定义 注: 简言之: ①向量的范数是定义在线性空间上的非负实数.②实内积空间和酉空间中向量的长度∣x∣=(x,x)|x|=\\sqrt{(x,x)}∣x∣=(x,x)​都是向量的范数③酉空间向量范数∣∣x∣∣||x||∣∣x∣∣用向量长度|x|来定义时,记作∣∣x∣∣2=∣x∣=xxH=sumi=1nξξˉ||x||_2 = |x| = \\sqrt{xx^H} = \\sqrt{sum^{n}_{i=1}{ξ\\bar{ξ}}}∣∣x∣∣2​=∣x∣=xxH​=sumi=1n​ξξˉ​​ 通式——P-范数 注: 当P-&gt;∞时∣∣X∣∣=maxξ||X|| = max{\\xi}∣∣X∣∣=maxξ 矩阵的范数 ▲以上概念来自于B站视频: 向量范数矩阵范数 Matlab中的norm demo代码中有关norm的运用如下, 12345678%% 初始化粒子群for i = 1 : N P(:, i) = [WorldSize*rand; WorldSize*rand]; %随机产生第i个粒子的坐标(rand为产生[0,1]之间均匀分布) dist = norm(P(:, i)-Z(:, 1)); %与测量位置相差的距离 %求权重 (权重与距离的关系 为 均值是0,方差是sqrt(R)的高斯分布曲线) % 因为均值为0且距离大于0 因此权重随着距离增加沿高斯曲线右侧递减 w(i) = (1 / sqrt(R) / sqrt(2 * pi)) * exp(-(dist)^2 / 2 / R); end 其中没有特别指出是啥范数, 因此可以通过help norm来查看一下关于norm的使用介绍. 1234567&gt;&gt; help norm norm Matrix or vector norm. norm(X,2) returns the 2-norm of X. norm(X) is the same as norm(X,2). norm(X,1) returns the 1-norm of X. 可以得到, norm(X)的效果默认是取2-范数的。 同时， norm函数既可以取向量范数又可以取矩阵范数： 1、如果A为矩阵 n=norm(A) 《Simulink与信号处理》 返回A的最大奇异值，即max(svd(A)) n=norm(A,p) 根据p的不同，返回不同的值 p 返回值 1 返回A中最大一列和，即max(sum(abs(A))) 2 返回A的最大奇异值，和n=norm(A)用法一样 inf 返回A中最大一行和，即max(sum(abs(A’))) ‘fro’ A和A‘的积的对角线和的平方根，即sqrt(sum(diag(A’*A))) 2、如果A为向量 norm(A,p) 返回向量A的p范数。即返回 sum(abs(A).p)(1/p),对任意 1&lt;p&lt;+∞. norm(A) 返回向量A的2范数，即等价于norm(A,2)。 norm(A,inf) 返回max(abs(A)) norm(A,-inf) 返回min(abs(A)) Matlab中的sum sum(A, 1)： 对一维求和， 如果A为二维数组， 则按列求和 sum(A, 2): 对二维求和， 如果A为二维数组， 则按行求和 Matlab中的wgn white Gaussian noise 12345678&gt;&gt; help wgn wgn Generate white Gaussian noise. Y = wgn(M,N,P) generates an M-by-N matrix of white Gaussian noise. P specifies the power of the output noise in dBW. The unit of measure for the output of the wgn function is Volts. For power calculations, it is assumed that there is a load of 1 Ohm. Y = wgn(M,N,P,IMP) specifies the load impedance in Ohms.","categories":[],"tags":[{"name":"Math","slug":"Math","permalink":"https://nymrli.top/tags/Math/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://nymrli.top/tags/MATLAB/"}]},{"title":"Python中import的细节","slug":"Python中import的细节","date":"2020-10-23T13:01:21.000Z","updated":"2020-11-12T07:04:11.635Z","comments":true,"path":"2020/10/23/Python中import的细节/","link":"","permalink":"https://nymrli.top/2020/10/23/Python中import的细节/","excerpt":"","text":"防忘系列… Pycharm并没有IDEA一样可以设置对import进行排序以及自动消除没用到的库（要用快捷键Ctrl + Alt + O）， 并且如果导入方式不正确会 1.找不到自定义包 2.Pycharm对指定内容报错（下划线或红线） Python中模块，包，库概念 模块：就是.py文件，里面定义了一些函数和变量，需要的时候就可以导入这些模块。 包：在模块之上的概念，为了方便管理而将文件进行打包。包目录下第一个文件便是__init__.py，然后是一些模块文件和子目录，假如子目录中也有__init__.py，那么它就是这个包的子包了。 库：具有相关功能模块、包的集合。这也是Python的一大特色之一，即具有强大的标准库、第三方库以及自定义模块。 标准库：就是下载安装的python里那些自带的模块，要注意的是，里面有一些模块是看不到的比如像sys模块，这与linux下的cd命令看不到是一样的情况。 第三方库：就是由其他的第三方机构，发布的具有特定功能的模块。 自定义模块：用户自己可以自行编写模块，然后使用。 总结: 我们pip install &lt;package&gt;安装的是库，库下有很多包，我们在自己的项目文件中import有以下几种用法: import numpy as np import urllib.parse import urlencode from lxml import HTML 之前大家应该碰到过，命名自己pip install xx安装的是叫xx的库，但是在用的时候写的却是from yy import zz，明显不对应嘛。因此，其实库和包的区别还可以通过setup.py打包成库来看。——使用setup.py打包python文件； Python实现打包成库供别的模块调用 其中比较重要的就是5.编写:setup.py， 注意：setup.py与要打包的test_package包同在bricewulib根目录下。 其中比较重要的几项是:name,version,packages name:描述的是你打包的文件夹名。 version描述的是文件的版本号。 packages是所有要打包的包（package），这里需要打包的是test_package包以及test_package包下的test_package。输入python setup.py sdist然后就能创建bricewulib库，使用test_package包 12345setup( name = &quot;bricewulib&quot;, version = &quot;1.0&quot;, packages=[&quot;test_package&quot;,&quot;test_package.test_package2&quot;]) import推荐顺序 我们推荐所有的模块在 Python 模块的开头部分导入。 而且最好按照这样的顺序: Python 标准库模块 Python 第三方模块 应用程序自定义模块 通过空行来分割——(Python’s Style Guide), PEP8 。 Python的import机制 运行、编写Python代码时，一定要注意的是脚本路径和脚本执行路径，以及相对路径和绝对路径 如果在项目中运用了相对路径,则一定要注意脚本执行路径 假设A是B的父目录, 如我们想在A目录调用B中模块, 而B中模板是又import了A下模板, 如login: from login import ftSession。命令行在A路径下输入python B/main.py时, 会报错。因为import其实就是在搜索目录下按相对路径找的。 Pycharm的坑: 借鉴: Python的import机制坑在哪？ pycharm里打出来的路径是更多的，它把项目根目录加进去了。(也可以设置: 进入设置，找到Console下的Python Console，勾选选项**“Add source roots to PYTHONPAT”** ) 查看搜索路径:print(sys.path) What’s resource root? 以上导致的问题就是: pycharm中，project folder是默认的source root，当你使用import语句导入模块时，Pycharm默认在project folder中寻找；所以当你在project folder下的某个subfolder导入某个同样定义在这个subfolder中的模块时，会出现导入错误。 pycharm中的第一个文件夹，即代表项目, 当在其中再次建立文件夹时，是按package处理的 如果要在这些文件夹内import其他文件，需要将完整路径导入进来 所以最终在Pycharm中导入的方式有两种: burning回答 从project folder开始相对导入 将module文件夹直接定义为source root pycharm在同目录下import划红线但实际可以运行 解决方法: 右键将model所在的文件夹设置为source root __init__文件作用 在Python工程里，当python检测到一个目录下存在__init__.py文件时，python就会把这个目录当成一个包(package)。Module跟C＋＋的命名空间和Java的Package的概念很像，都是为了科学地组织化工程，管理命名空间。 __init__.py的设计原则 __init__.py的原始使命是声明一个模块，所以它可以是一个空文件。 A、不要污染现有的命名空间。模块一个目的，是为了避免命名冲突，如果你在种用__init__.py时违背这个原则，是反其道而为之，就没有必要使用模块了。 B、利用__init__.py对外提供类型、变量和接口，对用户隐藏各个子模块的实现。一个模块的实现可能非常复杂，你需要用很多个文件，甚至很多子模块来实现，但用户可能只需要知道一个类型和接口。就像我们的arithmetic例子中，用户只需要知道四则运算有add、sub、mul、dev四个接口，却并不需要知道它们是怎么实现的，也不想去了解arithmetic中是如何组织各个子模块的。由于各个子模块的实现有可能非常复杂，而对外提供的类型和接口有可能非常的简单，我们就可以通过这个方式来对用户隐藏实现，同时提供非常方便的使用。 C、只在__init__.py中导入有必要的内容，不要做没必要的运算。像我们的例子，import arithmetic语句会执行__ini__.py中的所有代码。如果我们在__init__.py中做太多事情，每次import都会有额外的运算，会造成没有必要的开销。一句话，init.py只是为了达到B中所表述的目的，其它事情就不要做啦。 上述来自: https://zhuanlan.zhihu.com/p/115350758 __all__变量 __all__是一个字符串list； 约束作用：用来定义模块中对于from XXX import *时要对外导出的符号，即要暴露的借口，但它只对import *起作用(即如果在使用脚本中对当前包使用import *，那么可以管理当前包下模块的导入情况)，对from XXX import XXX不起作用。","categories":[],"tags":[{"name":"防忘系列","slug":"防忘系列","permalink":"https://nymrli.top/tags/防忘系列/"}]},{"title":"emplace_back与push_back","slug":"emplace-back与push-back","date":"2020-10-18T15:14:49.000Z","updated":"2020-10-25T07:08:58.265Z","comments":true,"path":"2020/10/18/emplace-back与push-back/","link":"","permalink":"https://nymrli.top/2020/10/18/emplace-back与push-back/","excerpt":"","text":"之前看1002. 查找常用字符题解的时候，发现有人用了emplace_back，将char转型成了string塞进了vector&lt;string&gt;，感觉是个骚操作。 之前也看过emplace_back和push_back的区别， 只不过又忘记了， 因此本次也算个防忘系列把… 1234567vector&lt;string&gt; ans;for (int i = 0; i &lt; M; i++) &#123; for (int j = 0; j &lt; minFreq[i]; j++) &#123; // emplace_back 骚操作 ans.emplace_back(1, 'a' + i); &#125;&#125; 在STL中，进行插入元素的时候，有insert和push两种选择方式，而在有了右值引用和移动语义的时候，在C++11中就提出了更高效的插入方法：emplace_back 目前的趋势是希望：使用emplace_back()取代push_back() 据统计，emplace_back()函数要比push_back()函数要快一倍。 empalce与push的区别： push_back()函数向容器中加入一个临时对象（右值元素）时， 首先会调用构造函数生成这个对象，然后调用拷贝构造函数将这个对象的拷贝放入容器中， 最后释放临时对象，这样造成的问题是临时变量申请的资源就浪费。但是emplace_back()函数向容器中中加入临时对象， 临时对象原地构造，只有转移的过程，没有赋值或拷贝的操作（不需要触发拷贝构造）。 emplace_back中调用构造函数 官网demo Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt; struct President&#123; std::string name; std::string country; int year; // 构造函数 President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year)&#123; std::cout &lt;&lt; \"I am being constructed.\\n\"; &#125; // 转移构造函数 President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year)&#123; std::cout &lt;&lt; \"I am being moved.\\n\"; &#125; // 拷贝赋值操作符 President&amp; operator=(const President&amp; other) = default; // 拷贝构造函数&#125;; int main()&#123; std::vector&lt;President&gt; elections; std::cout &lt;&lt; \"emplace_back:\\n\"; // noted: 这边并没有写成President(\"Nelson Mandela\", \"South Africa\", 1994) elections.emplace_back(\"Nelson Mandela\", \"South Africa\", 1994); std::vector&lt;President&gt; reElections; std::cout &lt;&lt; \"\\npush_back:\\n\"; reElections.push_back(President(\"Franklin Delano Roosevelt\", \"the USA\", 1936)); std::cout &lt;&lt; \"\\nContents:\\n\"; for (President const&amp; president: elections) &#123; std::cout &lt;&lt; president.name &lt;&lt; \" was elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; &#125; for (President const&amp; president: reElections) &#123; std::cout &lt;&lt; president.name &lt;&lt; \" was re-elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; &#125;&#125; ▲看到noted标出来的地方后, 就能知道Leetcode题解中的骚操作其实就是根据T类型判断出了调用构造函数。按如下代码得证 123string a(1, 'a'+ 1);cout &lt;&lt; a &lt;&lt; endl;// &gt;&gt;&gt; b 引申：什么是std::move? 借鉴: c++ 之 std::move 原理实现与用法总结 在C++11中，标准库在&lt;utility&gt;中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue); 左值、左值引用、右值、右值引用概念 左值的声明符号为”&amp;”， 为了和左值区分，右值的声明符号为”&amp;&amp;”。 临时对象是作为右值处理的 右值引用的意义 直观意义：为临时变量续命，也就是为右值续命，因为右值在表达式结束后就消亡了，如果想继续使用右值，那就会动用昂贵的拷贝构造函数。（关于这部分，推荐一本书《深入理解C11》） 右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。 转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。 通过转移语义，临时对象中的资源能够转移其它的对象里。 在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。 普通的函数和操作符也可以利用右值引用操作符实现转移语义。 extra： std::move执行一个无条件的转化到右值。它本身并不移动任何东西； std::forward把其参数转换为右值，仅仅在那个参数被绑定到一个右值时； std::move和std::forward在运行时（runtime）都不做任何事。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"防忘系列","slug":"防忘系列","permalink":"https://nymrli.top/tags/防忘系列/"}]},{"title":"AutoLianliankan笔记","slug":"AutoLianliankan笔记","date":"2020-10-13T10:58:47.000Z","updated":"2020-10-14T04:35:38.806Z","comments":true,"path":"2020/10/13/AutoLianliankan笔记/","link":"","permalink":"https://nymrli.top/2020/10/13/AutoLianliankan笔记/","excerpt":"","text":"近来无事，又研究其了之前看到过的自动连连看的代码，碰到了一些问题， 因此做下笔记 pywin32 win32gui：定位窗体，操作窗体 win32api：提供API，操作鼠标、键盘 win32con：具体API事件 ==&gt;对于窗体的操作使用win32gui；而对键盘、鼠标操作可以用更高级封装的库pymouse、pykeyboard；剪切板使用win32clipboard 程序的设计： getWindowPosition=&gt;先确定游戏窗口位置pos，并置顶 getScreenImage()==&gt;在窗口置顶后再截图 getAllSquare()=&gt;找到游戏边界，pos[0]+100, pos[1]+100,即中间所有图块部分。切割出所有图案；getAllSquareTypes()将所有图案进行比较分类，归纳出所有不同的种类 1234567# ndarray的切片方法，[纵坐标起始位置：纵坐标结束为止，横坐标起始位置：横坐标结束位置]square = screen_image[game_y + y * SQUARE_HEIGHT :game_y + (y+1) * SQUARE_HEIGHT, game_x + x * SQUARE_WIDTH:game_x + (x+1) * SQUARE_WIDTH]# np.shape(square) == (65, 65, 3)# 因为有些图片的边缘不一致造成干扰（主要是空白区域的切图），所以把每张小方块向内缩小一部分再# 对所有的方块进行处理屏蔽掉外边缘 然后返回return [square[SUB_LT_Y:SUB_RB_Y, SUB_LT_X:SUB_RB_X] for square in all_square] getAllSquareRecord()==&gt;将不同种类的图案做映射，转换成相对应的数字矩阵。 autoRemove(result, board_pos)==&gt;执行自动消除 Matcher类==&gt;实现游戏规则: 横消，纵消， 单拐点消除，双拐点消除。需要注意跟QQ连连看不同的是没有实现更高阶的拐点消除。 附录: 遇到的问题 列表的清空 代码中有一段，在line满了后，会将line清空，再添加 123if len(line) == V_NUM: result.append(line) line = [] 注意： 这边的写法line = []是可行的。而line.clear()是不行的。原因是涉及内存空间引用问题 原因在于: list.clear()会清除当前变量指向的内存地址内容，而line = []其实是指向了另一块地址。因此导致了最终的结果是line = []的result为[[1,2,3...], [2, 3, 4...]]；而list.clear()的result全为空[[],[],[]]] 123456789a= [1, 2, 3]print(id(a))# 1785191184200a = [1, 2]print(id(a))# 1785191276296a.clear()print(id(a))# 1785191276296 图片的维度问题: 开源代码提供的empty.png图片规格为: 25*21像素。而25对应的为y， 21对应的为x。而需要注意的是在代码中，表达为img[0: 25, 0: 21] GetWindowRect窗口大小有误 1234567891011121314# 获取窗体坐标位置(左上)def getGameWindowPosition(): # FindWindow(lpClassName=None, lpWindowName=None) 窗口类名 窗口标题名 window = win32gui.FindWindow(None,WINDOW_TITLE) # 没有定位到游戏窗体 while not window: print('定位游戏窗体失败，5秒后重试...') time.sleep(5) window = win32gui.FindWindow(None,WINDOW_TITLE) # 定位到游戏窗体 win32gui.SetForegroundWindow(window) # 将窗体顶置 pos = win32gui.GetWindowRect(window) print(\"定位到游戏窗体：\" + str(pos)) return (pos[0],pos[1]) 如图操作下来, 发现返回的pos为(408, 172)，但用spy++抓到的窗口左上角坐标为(510, 215)，研究发现横、纵都是1.25倍， 以为是分辨率的问题，所以打开了“显示设置”，结果正好看到了缩放布局是125%，因此问题可能出现在这个设置上，果然修改为100%后，程序能够正常运行。 额外，百度也找到了这个问题——win32gui.GetWindowRect在win10上获取窗口宽高不正确的另一种可能; win32gui.GetWindowRect() 取值不准的解决方案——亲测这个无效 附录: config.py中需要注意的设置 12345678910111213# 方块宽度(算上了边界)SQUARE_WIDTH = 65# 方块高度(算上了边界)SQUARE_HEIGHT = 65# ==&gt; 所以每块的大小为(65, 65, 3)# 切片处理时候的左上、右下坐标：# 注意 这里要么保证是21*25(因为开源代码里的empty.png提供的是21*25像素的)。如果不是（比如四个数据是10,10,50,50；也就是40*40像素），那么就把empty.png图片替换成对应大小的一张图片（比如40*40）。图片可以没用，但程序中不能SUB_LT_X = 5SUB_LT_Y = 5# 下面两个值得小于60, 因此还有5是边界SUB_RB_X = 26SUB_RB_Y = 30","categories":[],"tags":[{"name":"GitCode","slug":"GitCode","permalink":"https://nymrli.top/tags/GitCode/"}]},{"title":"手撕操作系统中的页面置换算法","slug":"手撕操作系统中的页面置换算法","date":"2020-09-21T11:14:25.000Z","updated":"2020-10-31T02:39:14.652Z","comments":true,"path":"2020/09/21/手撕操作系统中的页面置换算法/","link":"","permalink":"https://nymrli.top/2020/09/21/手撕操作系统中的页面置换算法/","excerpt":"","text":"操作系统基础 内存换页算法 公平算法： 随机算法、先来先出（FIFO）算法、第二次机会算法、时钟算法 非公平算法： 最优OPT算法、NRU算法、LRU算法、工作集算法、工作集时钟算法 其中LRU算法会被面试的时候要求手撕， 因此本篇就稍微介绍一下LRU和LFU两个算法， 这两个算法除了在内存换页上会被使用到， 简单介绍一些算法： 随机更换算法 需要替换页面的时候，产生一个随机页面号，替换与该页面对应的物理页面。 先来先出（FIFO）算法 更换最早进入内存的页面。其中有Belady异常现象: 缺页率随内存块数增加而增加 最优OPT算法： 最佳置换算法是由Belady于1966年提出的一种理论上的算法。其所选择的被淘汰页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面。 采用最佳置换算法通常可保证获得最低的缺页率。 ▲由于人们目前还无法预知，一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的。 Q： 既然无法实现， 那么他的价值是什么呢？ A： 他被作为评价一个内存换页算法效率的标榜 NRU算法 最近未使用算法（Not Recently Used，NRU），就是选择一个最近没有被访问的页面来替换，在所有的最近没有使用的页面里，按照各个页面的修改位和访问位的组合来进行划分。相比LRU需要较多硬件支持， NRU算法在页表项设置两个状态位：引用位R和修改位M LRU Q、什么是 LRU 算法? A: Least Recently Used最近最久未使用算法，本质一种缓存淘汰策略。 计算机的缓存容量有限，如果缓存满了就要删除一些内容，给新内容腾位置。但问题是，删除哪些内容呢？我们肯定希望删掉哪些没什么用的缓存，而把有用的数据继续留在缓存里，方便之后继续使用。那么，什么样的数据，我们判定为「有用的」的数据呢？ LRU 缓存淘汰算法就是一种常用策略。LRU 的全称是 Least Recently Used，也就是说我们认为最近使用过的数据应该是是「有用的」，很久都没用过的数据应该是无用的，内存满了就优先删那些很久没用过的数据。 ▲同时它也是一种换页算法， 在内存换页上需要较多的硬件支持（计数器or栈） 常见的缓存算法 LRU (Least recently used) 最近最少使用，如果数据最近被访问过，那么将来被访问的几率也更高。 LFU (Least frequently used) 最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。 LFU由于涉及频率, 因此在代码实现上有个计数器来统计出现次数T，在需要换页（缓存更新的时候）将替换掉最低T的key FIFO (Fist in first out) 先进先出， 如果一个数据最先进入缓存中，则应该最早淘汰掉。 LRU算法与OPT算法比较 OPT是从“向后看”的观点出发的，即它是依据以后各页的使用情况进行判断，是理想状况；而LRU算法则是“向前看”的，即根据各页以前的使用情况来判断，而页面过去和未来的走向之间虽无必然的联系，但也有一定的预测关系。 总的来说，LRU算法是一种比较好的算法。 Q: 算法要求 LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。其中， get(key)的时候会把这个新查询的key放到最前端 由于性能要求，get 和 put 方法必须都是 O(1) 的时间复杂度。 get需要O(1) --&gt; hash or 线性表 put需要O(1) --&gt;链表 Coding实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package lru;import java.util.HashMap;import java.util.Map;public class LRUCache &#123; class Node &#123; Integer key; Integer val; // 双向列表: 前后向节点 Node nxt, prev; public Node() &#123; &#125; Node(int k, int v) &#123; this.key = k; this.val = v; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"key=\" + key + \", val=\" + val + '&#125;'; &#125; &#125; class DoubleList&#123; private int size; // 头尾空指针 private final Node head; private final Node tail; DoubleList() &#123; // 初始化 this.size = 0; this.head = new Node(); this.tail = new Node(); this.head.nxt = tail; this.tail.prev = head; &#125; /** * 将节点到头部, head-&gt;nxt = node; * @param node 待插入节点 */ public void addFirst(Node node)&#123; // 4个指针关系 node.nxt = head.nxt; node.prev = head; head.nxt.prev = node; head.nxt = node; // 记得增加当前容器Size this.size ++; &#125; public void remove(Node node)&#123; // 略过当前节点, 调整前后指针 node.nxt.prev = node.prev; node.prev.nxt = node.nxt; // 调整容器Size this.size--; &#125; public Node removeLast()&#123; // 删除尾节点, 为tail.prev Node node = tail.prev; // ▲笔误写错, 查了半小时 node.nxt= tail; remove(node); // 删除的时候还要在mp中删除索引, 因此要返回值 return node; &#125; public int getSize() &#123; return this.size; &#125; @Override public String toString() &#123; return \"DoubleList&#123;\" + \"size=\" + size + '&#125;'; &#125; &#125; int capacity; Map&lt;Integer, Node&gt; mp; DoubleList list; public LRUCache(int capacity) &#123; this.capacity = capacity; list = new DoubleList(); mp = new HashMap&lt;Integer, Node&gt;(); &#125; /** * 访问过的key对应的Node需要放到队首部(最近查询) * @param key 键 * @return 有相应的key则返回对应Node的val, 无则返回-1 */ public int get(int key) &#123; if ( mp.containsKey( key) )&#123; int res = mp.get(key).val; // ★ 把当前访问的放到队首 put(key, res); return res; &#125; else return -1; &#125; /** * 1. 如果已有key, 则删除容器中原有的Node, 将其放到队首 * 2. 如果没有key, * 2.1 如果容器已满, 则将队尾的排出, 再将新Node加在队首 * 2.2 如果容器未满, 则直接将新Node加在队首 * @param key * @param value */ public void put(int key, int value) &#123; Node node = new Node(key, value); if (mp.containsKey(key))&#123; list.remove(mp.get(key)); list.addFirst(node); mp.put(key, node); &#125;else&#123; if ( list.getSize() == capacity )&#123; Node last = list.removeLast(); mp.remove(last.key); &#125; list.addFirst(node); mp.put(key, node); &#125; &#125; @Override public String toString() &#123; return \"LRUCache&#123;\" + \"capacity=\" + capacity + \", mp=\" + mp.toString() + \", list=\" + list.toString() + '&#125;'; &#125;&#125; LeetCode代码检验 : 146. LRU缓存机制 算法实现参考： LRU算法：手把手带你实现一个干啥都快的快乐算法， 思路挺清晰的， 只不过只有LRUCache的代码， 需要自己实现双向链表 LFU LFU (Least frequently used) 最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。 LFU由于涉及频率, 因此在代码实现上有个计数器来统计出现次数T，在需要换页（缓存更新的时候）将替换掉最低T的ke 算法实现思路： O(1)查询： hash+ O(1)修改+频率排序：set 附录 参考链接: 【1】简单易懂，包你学会！ | 操作系统 | 页面置换 —— 认知性了解 操作系统-页面置换算法（OPT、FIFO、LRU、——换页过程","categories":[],"tags":[]},{"title":"docsify使用记录","slug":"docsify使用记录","date":"2020-09-15T02:30:43.000Z","updated":"2020-09-15T07:45:46.873Z","comments":true,"path":"2020/09/15/docsify使用记录/","link":"","permalink":"https://nymrli.top/2020/09/15/docsify使用记录/","excerpt":"","text":"Docsify 是什么？ Docsify 一个神奇的动态生成文档网站的工具。 不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html 文件，所有转换工作都是在运行时进行。 较多使用的场景是GitHub中对某一开源程序的文档介绍，由于docsify的主题较为好看， 且轻量、易使用，因此使用也较为广泛。同时它也支持很多插件来丰富功能。但跟Hexo相比，个人感官上Hexo更适合做个人博客， 而docsify更适合专门来写程序的介绍文档 春招的时候背了很多的面经， 只不过秋招回头来看基本上又都记不太清了，于是想自己整理些面经笔记啥的。 之前也试过在个人博客上发表， 只不过感觉还是不适合阅读，因此正好想起来之前了解过Docsify，因此这次打算在写面经的时候顺便也练习、熟练下Docsify。 官方文档快速使用介绍的很全了，先贴个官方文档。 Start to Run it 1.安装docsify工具:npm i docsify-cli -g 2.初始化项目: docsify init [./docs] , []中内容为指定生成目录, 不填默认为当前目录 初始化成功后，可以看到生成 目录下创建的几个文件 index.html 入口文件、插件等配置都写在这 README.md 会做为主页内容渲染，编辑即可更新文档内容 .nojekyll 用于阻止 GitHub Pages 忽略掉下划线开头的文件 3.预览效果： docsify serve [docs]， 通过运行 docsify serve 启动一个本地服务器，可以方便地实时预览效果。默认访问地址 http://localhost:3000 。 多页文档 定制化 自定义导航栏: 设置为 true 后会加载 _navbar.md 文件，也可以自定义文件名。 自定义侧边栏: 设置为 true 后会加载 _sidebar.md 文件，也可以自定义文件名。 启用封面页: 开启后是加载 _coverpage.md 文件，也可以自定义文件名。 markdown配置 插件 index.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; window.$docsify = &#123; name: 'Java工程师成神之路', repo: 'https://github.com/hollischuang/toBeTopJavaer', loadSidebar: true, subMaxLevel: 3, autoHeader: true, search: &#123; paths: 'auto', placeholder: '🔍 搜索 ', noData: '哎呀，没有找到呀！ ', // Headline depth, 1 - 6 depth: 3 &#125;, copyCode: &#123; buttonText : '复制', errorText : 'Error', successText: 'OK!' &#125;, pagination: &#123; previousText: '上一章', nextText: '下一章', &#125;, coverpage: true &#125;&lt;/script&gt;&lt;script src=\"//unpkg.com/docsify/lib/docsify.min.js\"&gt;&lt;/script&gt;&lt;!--代码块复制插件--&gt;&lt;script src=\"//unpkg.com/docsify-copy-code\"&gt;&lt;/script&gt;&lt;!-- 图片缩放插件 --&gt;&lt;script src=\"https://cyc-1256109796.cos.ap-guangzhou.myqcloud.com/zoom-image.min.js\"&gt;&lt;/script&gt;&lt;!--搜索插件--&gt;&lt;script src=\"https://cdn.bootcss.com/docsify/4.5.9/plugins/search.min.js\"&gt;&lt;/script&gt;&lt;!--语法高亮插件--&gt;&lt;script src=\"//unpkg.com/prismjs/components/prism-java.min.js\"&gt;&lt;/script&gt;&lt;script src=\"//unpkg.com/prismjs/components/prism-bash.min.js\"&gt;&lt;/script&gt;&lt;!--分页插件--&gt;&lt;script src=\"//unpkg.com/docsify-pagination/dist/docsify-pagination.min.js\"&gt;&lt;/script&gt;&lt;!--统计访问量插件--&gt;&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 附录： To Be Top Javaer - Java工程师成神之路","categories":[],"tags":[]},{"title":"数据结构——单调栈","slug":"数据结构——单调栈","date":"2020-09-08T11:25:38.000Z","updated":"2020-09-23T01:08:12.742Z","comments":true,"path":"2020/09/08/数据结构——单调栈/","link":"","permalink":"https://nymrli.top/2020/09/08/数据结构——单调栈/","excerpt":"","text":"秋季PAT的第一题就是单调栈，之前没怎么学过， 因此这次专门学习做下笔记。 单调栈Monotone Stack 概念: 从行为上看，它不仅仅是用存储与访问受限的栈，而是一种辅助工具，用于检测数据的单调性变化并作出反应（表现: 当入栈元素会影响栈总体单调性时，要出栈一些元素以维持单调性） 场景： 向左or向右找到第一个稍大（小）的元素、其索引下标； 确定某条件（单调）下的最长区间； 确定区间构成的极值，如max f（la，b]）； Point： 单调递增栈: 指栈内元素的出栈序列递增（或递减），而栈内元素是递减（或递增），即当元素比栈顶小的时候入栈。因此需要输出下一个最大的元素。 当然也有人是直接根据栈内元素大小关系来区别， 比如栈内元素递减就叫做递减栈。 此外没有双向栈的存在。 核心思想 在元素Y入栈的时候会跟栈顶元素X比较， 如果Y比栈内所有元素Xs都大的话，就可以拿到栈里所有的元素即区间。关键是这个比较， 就可以找到第一个满足要求的数据。 e.g.有列表[1, 3, 2, 0, 7]，从左向右遍历，当遍历为7时栈里有[3, 2, 0]，此时入栈元素为7， 能得到==&gt;那么对于0来说，右边最大的就是当前入栈元素7， 左边最小的就是栈内下一个元素2。而对3来说，此时3上边的元素就都是比3小的元素们。 Code模板： 123456789def getFirstMax(nums: List[int]): # 站内元素递减栈， 输出序列递增 stack = [] for i in range(len(nums) - 1, -1, -1): val = nums[i] if stack and val &gt; stack[-1]: stack.pop() # 入栈操作在之前逻辑都执行完之哦吼，最后再入栈 stack.append(val) 这种写法， 主要是运用的stack.pop元素 例题 Leetcode#496： 单调栈 Leetcode #496. 下一个更大元素 I 12345678910class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: hash_dict = dict() stack = [] for i in nums2: while stack and i &gt; stack[-1]: # 在原有序列中比栈顶元素大的就是当前入栈元素i hash_dict[stack.pop()] = i stack.append(i) return [hash_dict.get(i,-1) for i in nums1] Leetcode#962. 最大宽度坡： 单调栈 Q： 为什么想到了单调栈？ A：参看题解：首先把A数组中的以A[0]开头的递减序列抽取出来，我们最后要求的最大的宽度坡一定是以这个序列中的某一个i为坡底的，我们反证一下 假设存在某个元素位置k不存在于上面的递减序列中，且有最大宽度j-k，这也就说明k位置的元素一定是小于k前面所有的元素的，否则就会有更长的宽度，但是既然k小于前面所有的元素，那么k就一定会被加入到序列中，与假设矛盾，所以不存在k，解一定存在递减序列中 这样的话我们可以逆向遍历数组，每次遇到元素大于栈顶的就可以计算宽度，然后将栈顶弹出，因为是逆序遍历的，所以这个宽度一定是栈顶这个坡底i能形成的最大宽度了， 逆序遍历再往前的话即使大于这个栈顶，形成的宽度也只会减小，所以这个栈顶是可以直接pop出去的，我们遍历所有的坡底求最大值就行了，时间复杂度O(N) 作者：resolmi https://leetcode-cn.com/problems/maximum-width-ramp/solution/java-dan-diao-zhan-er-fen-jie-fa-chang-shi-jie-shi/ 12345678910111213141516171819202122232425262728293031323334353637/* * @Author: Mrli * @Date: 2020-09-14 10:16:57 * @LastEditTime: 2020-09-14 11:03:29 * @Description: */#include &lt;bits/stdc++.h&gt;using namespace std;int maxWidthRamp(vector&lt;int&gt;&amp; A) &#123; stack&lt; int &gt; st; int len = A.size(); // 维护一个递减栈 for (int i = 0; i &lt; len; i++) &#123; if (st.empty() || A[i] &lt;= A[st.top()]) st.push(i); &#125; int ans = 0; int i = len - 1; while( i &gt; ans)&#123; // 根据单调栈的含义， 此时入栈A[i]， 可以得到 st.top() 右边比其大的为A[i]， 同时栈里也都是比A[i]小的元素 while( !st.empty() &amp;&amp; A[st.top()] &lt;= A[i] )&#123; // printf(\"A[%d]:%d A[%d]:%d\\n\", st.top(), A[st.top()], i, A[i] ); ans = max(ans, i - st.top()); st.pop(); &#125; i --; &#125; return ans;&#125; int main()&#123; vector&lt;int&gt; A = &#123;6,0,8,2,1,5&#125;; int ans = maxWidthRamp(A); cout &lt;&lt;ans &lt;&lt;endl; return 0;&#125; Leetcode#1124： 前缀和+单调栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;int longestWPI(vector&lt;int&gt;&amp; hours) &#123; int len = hours.size(); // hash for(int i = 0; i &lt; len; i ++ )&#123; if ( hours[i] &gt; 8) hours[i] = 1; else hours[i] = -1; &#125; // 1, 1, -1, -1, -1, -1, 1 vector&lt;int&gt; sum(len + 1, 0); for(int i = 1; i &lt;= len; i++ )&#123; sum[i] = sum[i - 1] + hours[i - 1]; &#125; stack&lt;int&gt; st; // 顺序生成单调栈，栈中元素从第一个元素开始严格单调递减，最后一个元素肯定是数组中的最小元素所在位置 for(int i = 0; i &lt;= len; i++ )&#123; if ( st.empty() || sum[i] &lt; sum[st.top()]) st.push(i); &#125; int ans = 0; /** 常规写法： */ for (int i = len; i &gt;= 0 ; i--) &#123; while( !st.empty() &amp;&amp; sum[st.top()] &lt; sum[i])&#123; ans = max(ans, i - st.top()); st.pop(); &#125; &#125; /** 写法二: */ int i = len; // 倒序扫描数组，求最大长度坡 while( i &gt; ans)&#123; // sum[st.top()] &lt; sum[i]实际就是找到 sum &gt; 0, 即后面索引j的sum - 前面索引i的sum &gt; 0 while( !st.empty() &amp;&amp; sum[st.top()] &lt; sum[i])&#123; ans = max(ans, i - st.top()); st.pop(); &#125; i -= 1; &#125; return ans;&#125; int main()&#123; vector&lt;int&gt; A = &#123;9,9,6,0,6,6,9&#125;; int ans = longestWPI(A); cout &lt;&lt;ans &lt;&lt;endl; return 0;&#125;// 此题单调栈具体怎么来的可以看题解： https://leetcode-cn.com/problems/longest-well-performing-interval/solution/can-kao-liao-ji-ge-da-shen-de-ti-jie-zhi-hou-zong-/ 参看：Bilibili【带写03】python前缀和与单调栈.mp4 单调队列 P1886 滑动窗口 /【模板】单调队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;// 这个写法可以借鉴一下struct node&#123; int val; int id; // 下标&#125;;vector&lt;int&gt; v1; // 最小vector&lt;int&gt; v2; // 最大int n, k;deque&lt;node&gt; q1;deque&lt;node&gt; q2;int main()&#123; cin &gt;&gt; n &gt;&gt; k; int val; for (int i = 1; i &lt;= n; i++) &#123; node nd; cin &gt;&gt; nd.val; nd.id = i; // 如果当前元素小于栈顶元素， 则栈顶元素出栈 // --&gt;获得栈顶小于当前预算 while( !q1.empty() &amp;&amp; nd.val &lt;= q1.back().val)&#123; q1.pop_back(); &#125; while( !q2.empty() &amp;&amp; nd.val &gt;= q2.back().val) q2.pop_back(); q1.push_back(nd); q2.push_back(nd); if ( i - q1.front().id + 1 &gt; k) q1.pop_front(); // 如果栈底元素已经超出边界则出栈 if ( i - q2.front().id + 1 &gt; k) q2.pop_front(); if (i &gt;= k)&#123; // 当索引满足窗口大小的时候才进行操作 v1.push_back(q1.front().val); // 栈底元素为当前k窗口中最小的 v2.push_back(q2.front().val); // 栈底元素为当前k窗口中最大的 &#125; &#125; int len = v1.size(); for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; v1[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; len = v2.size(); for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; v2[i] &lt;&lt; \" \"; &#125; return 0;&#125; holiday 题目描述 经过几个月辛勤的工作，FJ决定让奶牛放假。 假期可以在1…N天内任意选择一段（需要连续），每一天都有一个享受指数W。但是奶牛的要求非常苛刻，假期不能短于P天，否则奶牛不能得到足够的休息；假期也不能超过Q天，否则奶牛会玩的腻烦。 FJ想知道奶牛们能获得的最大享受指数。 输入格式 第一行：N,P,Q. 第二行：N个数字，中间用一个空格隔开。 输出格式 一个整数，奶牛们能获得的最大享受指数。 样例数据 input 125 2 4-9 -4 -3 8 -6 output 15 Hint 选择第3-4天，享受指数为-3+8=5。 数据规模与约定 50% 1≤N≤10000，100% 1≤N≤100000 时间限制：1s， 空间限制：256MB 思路： 用前缀和处理前i天的指数和 其实就是从P的位置开始枚举，每次把i-P压入队列，如果i-Q大于队首元素的位置，弹出队首 每次取出队首让ans=max（sum[i]-sum[Day.front()]） 最后输出ans 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;#define INF 9999999999long long sum[100300];int n,p,q;long long ans=-INF;deque&lt;long long&gt; Day; int main()&#123; freopen(\"holiday.in\",\"r\",stdin); // freopen(\"holiday.out\",\"w\",stdout); scanf(\"%d%d%d\",&amp;n,&amp;p,&amp;q); long long x; // 前缀和 for(int i=1;i&lt;=n;i++)&#123; scanf(\"%lld\",&amp;x); sum[i]=sum[i-1]+x; &#125; for(int i=p;i&lt;=n;i++)&#123; int nowIndex = i - p; // 指数和小的放前面 while(!Day.empty() &amp;&amp; sum[nowIndex] &lt; sum[Day.back()] ) Day.pop_back(); Day.push_back(nowIndex); // 实际上应该理解为 当前日期i - 队首的日期 &gt; Q天, 则让pop_front while(!Day.empty() &amp;&amp; i - q &gt; Day.front()) Day.pop_front(); // sum[i] - sum[Day.front()] 为索引i~Day.front()这几天的指数和 ans=max(ans, sum[i]-sum[Day.front()]); &#125; cout&lt;&lt;ans; return 0;&#125; 总结: 单调队列对于处理线性滑动区间最值可谓游刃有余 借鉴: 数据结构之单调队列与单调栈 单调栈 P2866 [USACO06NOV]Bad Hair Day S 根据题目细品: 第N头牛站最前面, 第1头站最后面, 然后如果Hi &gt; Hn, 则能看到。要求累加第i头牛能看到前面牛的头发数， 即可以理解为第i头牛往前看， 找到比它大的Hi或者边界（边界可以看做为Hi=0的）。===&gt; 输入样例从左往右找比当前元素大的第一个元素，单调递减栈–&gt;正常for i = 0 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const long long INF = 0x3f3f3f3f;int n;struct cow&#123; int id; int height;&#125;;stack&lt;cow&gt; st;int main()&#123; int tmp; int ans = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; // C_i的高度 cin &gt;&gt; tmp; // 找到比当前元素大的一个元素， 期间小的都累计 while( !st.empty() &amp;&amp; tmp &gt;= st.top().height ) &#123; ans += ( i - st.top().id - 1); st.pop(); &#125; st.push(&#123;i, tmp&#125;); &#125; // 到最后的时候， 剩下的递减的都是前面没有比自己高的牛了， 如样例最后剩5&lt;-6， 那么6(2)前面没数字了， 所以为0， 5前面(12)只有6了，且6的2高&lt;5的12高， 因此6-5=1有1头牛 while(!st.empty())&#123; int now = st.top().id; st.pop(); ans += (n - now); &#125; cout &lt;&lt; ans &lt;&lt;endl; return 0;&#125; 思路2： 每次输入一头牛的身高，找比这头牛矮的，出栈 剩下的牛皆可以看到这只牛 ans值加等于栈中牛的个数 这头牛入栈 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int n,t;long long ans; //注意要开long long stack &lt;int&gt; a;int main() &#123; cin&gt;&gt;n; for (int i=1; i&lt;=n; i++) &#123; cin&gt;&gt;t; // 将栈内删到全都是比t的高的 while (!a.empty() &amp;&amp; t &gt;= a.top() ) a.pop(); // 那么栈里的元素都能看到i ans+=a.size(); // 注意： 先size后push a.push(t); &#125; cout&lt;&lt;ans; return 0;&#125; 气温 列表 #739 每日温度 从左往右找比当前元素大的–&gt;如果当前元素比栈顶元素大，那么栈顶元素右边比其第一个大的元素就是当前入栈元素—&gt;单调递减栈（从栈底到栈顶递减）–&gt;val &gt; st.top()，正常for i = 0 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3;int n;int ans[maxn]; // 答案struct temperature&#123; int id; int tmp;&#125;;/**input:873 74 75 71 69 72 76 73output:1 1 4 2 1 1 0 0*/int main()&#123; stack&lt;temperature&gt; st; cin &gt;&gt; n; int val; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; val ; while ( !st.empty() &amp;&amp; val &gt; st.top().tmp )&#123; ans[st.top().id] = i - st.top().id ; st.pop(); &#125; st.push(&#123;i, val&#125;); // 塞进去的是索引 &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt;ans[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; return 0;&#125; 逆序写： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3;int n;int ans[maxn]; // 答案struct temperature&#123; int id; int tmp; temperature()&#123;&#125; temperature(int _id, int _tmp): id(_id), tmp(_tmp)&#123;&#125;&#125;;/**input:873 74 75 71 69 72 76 73output:1 1 4 2 1 1 0 0*/int main()&#123; stack&lt;temperature&gt; st; cin &gt;&gt; n; int val; vector&lt;int&gt; v(n+1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125; for (int i = n; i &gt;= 1; i--) &#123; int val = v[i]; while( !st.empty() &amp;&amp; val &gt;= st.top().tmp) st.pop(); ans[i] = st.empty()? 0 : st.top().id - i; st.push(temperature(i, val)); &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt;ans[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; return 0;&#125; P5788 【模板】单调栈 模板写法 123456789101112131415161718192021222324252627// ▲不知道为啥必须点开洛谷的O2优化才不会被卡后面4个点#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3;int n;int main()&#123; scanf(\"%d\", &amp;n); vector&lt;int&gt; v; v.resize(n+1); stack&lt; pair&lt;int, int&gt; &gt; st; vector&lt;int&gt; ans(n+1); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;v[i]); while( !st.empty() &amp;&amp; v[i] &gt; v[st.top().first])&#123; ans[ st.top().first ] = i; st.pop(); &#125; st.push(&#123;i, v[i]&#125;); &#125; // 遍历完的时候栈里其实还有元素 // cout &lt;&lt; \"size: \"&lt;&lt;st.size() &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; if ( i == 1) printf(\"%d\", ans[i]); else printf(\" %d\", ans[i]); &#125; return 0;&#125; for遍历倒着写 12345678//myfor (int i = n; i &gt;= 1 ; i--) &#123; while( !st.empty() &amp;&amp; v[i] &gt;= v[st.top().first])&#123; st.pop(); &#125; ans[ i ] = st.empty() ? 0: st.top().first; st.push(&#123;i, v[i]&#125;);&#125; // 找的题解 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[3000001],b[3000001];stack&lt;int&gt; q;//开一个STL的栈 栈里面存的是数的下标即位置int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];//输入 for(int i=n;i&gt;=1;i--)&#123; while(!q.empty() and a[q.top()]&lt;=a[i])//查找第一个大于a[i]的数 q.pop(); //否则就直接出栈 if(q.empty()) //如果最后没有比a[i]大的数 b[i]=0; else b[i]=q.top(); //否则就记录下来 q.push(i); //将i入栈 &#125; for(int i=1;i&lt;=n;i++) cout&lt;&lt;b[i]&lt;&lt;\" \";//输出答案 结束 return 0;&#125; 区别在于： 站内元素是栈顶元素的右边； 而顺着写， 那么栈内元素是栈顶元素的左边， 即栈顶元素为站内元素的右边；同时还有一个区别是： 顺着先能边读边写， 而倒着写必须读完再写 不用v[]的写法, 其实直接可以用stack&lt; pair&lt;int, int&gt; &gt;st来写，可能会更直观一些 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3;int n;int main()&#123; int val; scanf(\"%d\", &amp;n); stack&lt; pair&lt;int, int&gt; &gt; st; vector&lt;int&gt; ans(n+1); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;val); while( !st.empty() &amp;&amp; val &gt; st.top().second )&#123; ans[ st.top().first ] = i; st.pop(); &#125; st.push(&#123;i, val&#125;); &#125; for (int i = 1; i &lt;= n; i++) &#123; if ( i == 1) printf(\"%d\", ans[i]); else printf(\" %d\", ans[i]); &#125; return 0;&#125; 总结 单调栈可利用的点: 剩下的元素 跟 当前元素的关系；弹出元素的个数；剩余元素的个数 栈顶 和 当前元素的关系==&gt; 找到第一个比数大、小的 递减栈的while中条件写 val &gt; st.top()的时候pop，正着写和反着写都一样， 但是要注意等于号的区别；顺着写判断条件完全满足题意（利用pop的动作做处理），而逆着则要考虑先后，如气温题，找第一个反而要加等号， 要pop掉直到左边第一个出现。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"扇区、块/簇","slug":"扇区、块-簇","date":"2020-09-06T06:29:31.000Z","updated":"2020-09-06T07:04:38.846Z","comments":true,"path":"2020/09/06/扇区、块-簇/","link":"","permalink":"https://nymrli.top/2020/09/06/扇区、块-簇/","excerpt":"","text":"扇区 概念： 扇区，顾名思义，每个磁盘有多条同心圆似的磁道，磁道被分割成多个部分。每部分的弧长加上到圆心的两个半径，恰好形成一个扇形，所以叫做扇区。扇区是磁盘中最小的物理存储单位。 扇区大小: 512B -&gt; 4KB 扇区(Sector)大小是固定的，默认情况下，每个扇区（Sector）为512字节，2009年后，硬盘厂商开始发布4KB字节扇区的硬盘了，4KB扇区硬盘已经在消费级市场广泛应用。但是同一块硬盘上的扇区大小一定是一致的。不可能存在多种不同大小的扇区。 逻辑扇区、物理扇区 物理扇区是磁盘上真实存在对应的扇区； 逻辑扇区是由于扇区大小由512B变成4KB后， 为了与老系统兼容，操作系统层面上提出来的一个概念，是为了方便操作系统读取写入硬盘数据而设置的， 给系统进行识别后，可以通过一定的公式与物理地址对应再找到到指定的物理扇区上去。 由来 关于物理扇区（physical setctor）与逻辑扇区，这个还得扯上扇区大小，由于近年来，随着对硬盘容量的要求不断增加，为了提高数据记录密度，硬盘厂商往往采用增大扇区大小的方法，于是出现了扇区大小为4096字节的硬盘。我们将这样的扇区称之为“物理扇区”。但是这样的大扇区会有兼容性问题，有的系统或软件无法适应。为了解决这个问题，硬盘内部将物理扇区在逻辑上划分为多个扇区片段并将其作为普通的扇区（一般为512字节大小）报告给操作系统及应用软件。这样的扇区片段我们称之为“逻辑扇区”。实际读写时由硬盘内的程序（固件）负责在逻辑扇区与物理扇区之间进行转换，上层程序“感觉”不到物理扇区的存在。 逻辑扇区是硬盘可以接受读写指令的最小操作单元，是操作系统及应用程序可以访问的扇区，多数情况下其大小为512字节。我们通常所说的扇区一般就是指的逻辑扇区。物理扇区是硬盘底层硬件意义上的扇区，是实际执行读写操作的最小单元。是只能由硬盘直接访问的扇区，操作系统及应用程序一般无法直接访问物理扇区。一个物理扇区可以包含一个或多个逻辑扇区（比如多数硬盘的物理扇区包含了8个逻辑扇区）。当要读写某个逻辑扇区时，硬盘底层在实际操作时都会读写逻辑扇区所在的整个物理扇区。 参考： 存储基础知识：扇区与块/簇——带物理结构图 块/簇 **概念：**块（Block）/簇（Cluster）是逻辑上的概念，或者说是虚拟出来的概念（逻辑概念）。 分别对应Linux与Windows操作系统中的概念。 通俗的来讲，在Windows下如NTFS等文件系统中叫做簇；在Linux下如Ext4等文件系统中叫做块（block）。每个簇或者块可以包括2、4、8、16、32、64…2048、4096等2的n次方个扇区。 为什么要用磁盘块/簇？ A： 读取方便：由于扇区的Size比较小，数目众多时寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。(操作系统通过操作块， 来间接操作底层磁盘对扇区的读取，先找街道再找门户) 分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位。 扇区与块/簇的区别 磁盘的读写基本单位是扇区。 磁盘的原理，物理实现，磁盘控制器是按照扇区这个单位读取等操作数据的。 文件系统就是操作系统的一部分，所以**文件系统读写(操作文件)**的最小单位是块。 操作系统是通过块/簇来做为单位读取等操作数据的。 and 从磁盘的物理结构来看存取信息的最小单位是扇区，一个扇区是512字节； 从操作系统对硬盘的存取管理来看，存取信息的最小单位是簇，簇是一个逻辑概念，一个簇可以是2、4、8、16、32或64个连续的扇区。 一个簇只能被一个文件占用，哪怕是只有1个字节的文件，在磁盘上存储时也要占用一个簇，这个簇里剩下的扇区是无用的。例如用NTFS文件系统格式化的时候默认是8个扇区组成一个簇，即4096字节。所以你如果保存了一个只有1字节的文件（例如字母N），它在磁盘上实际也要占用4096字节（4K），所以“簇”也可以理解为操作系统存取信息的最小单位。 QA: Q、为什么磁盘块大小必须是扇区大小的整数倍呢？ A: 磁盘读取数据的基本单位就是一个扇区的大小，一个块的大小对于磁盘来说就是一次获取数据读取的扇区数*扇区大小，如果是整数倍的扇区数对于磁盘的IO更好，速度更快，也会更合理的利用资源。否则会对扇区进行分割。 Q、那么分成“大簇”和“小簇”有什么区别呢？ A：我如果硬盘下很多小文件，那么每一个小文件，都会占用一个“簇”。虽然这些小文件都小于一个“簇”。 “大簇”和“小簇”当然有很多区别，但是最大的区别是：“小簇”会节省空间，而“大簇”则反之。“大簇”的优势在于有益于文件的读取存取，简单而不严谨的说就是提升硬盘性能。 “大簇”——读取存取速度快，占用空间大 “小簇”——读取存取速度慢，占用空间小 而现在TB时代，即便是“大簇”大家完全也HOLD住，即便你全部是几KB、几字节的小文件。“大簇”盘也不会“小簇”盘多占出太多空间，但是性能的提升确是最少几倍的，特别是面对大型程序或者游戏的时候。 4K 4K对齐的意思是对齐到磁盘开头的4K这个数值。和按4K来格式化不是一回事。 Ans1: 4K对齐 随着时代发展，硬盘容量不断扩展，使得之前定义的每个扇区512字节不再是那么的合理，于是将每个扇区512字节改为每个扇区4096 个字节，也就是现在常说的“4K扇区”。随着NTFS成为了标准的硬盘文件系统，其文件系统的默认分配单元大小（簇）也是4096字节，为了使簇与扇区相对应，即使物理硬盘分区与计算机使用的逻辑分区对齐，保证硬盘读写效率，所以就有了“4K对齐”的概念。 新标准的”4K扇区”的硬盘在厂商为了保证与操作系统兼容的前提下，也将扇区模拟成512B（逻辑扇区），会默认定义为4096字节大小为一个簇，但因为其引导区占用了一个磁道共63个扇区，真正的文件系统在63号扇区之后。 我们通过计算得出前63个扇区大小为：512Bx63=32256B。并按照默认簇大小得出63扇区为：32256B÷4096B=7.875簇 即从第63个扇区结束，往后的每一个簇都会跨越两个物理单元，占据前一个单元的一小部分和后一个单元的一大部分。 而“4K对齐”主要是将硬盘的模拟扇区(512B)对齐到8的整数倍个“实际”4K扇区，即4096B*8=32768B，其正好跨过了63扇区的特性，从第64个扇区对齐。 Ans2: 4K格式化 4k对齐是硬盘分区中的一个专业术语，4K对齐就是符合4K扇区定义格式化过的硬盘，并且按照4K扇区的规则写入数据。一般来说，在给固态硬盘进行分区的时候，一定要勾选上4K对齐，否则会影响到SSD固态硬盘的性能与寿命。通俗的说，如果SSD不进行4K对齐，写入数据的写入点正好会介于两个4K扇区的之间，也就是说即使是写入最小量的数据，也会使用到两个4K扇区，这样会造成跨区读写，读写次数放大，从而影响磁盘性能。 SSD中的4K对齐的4K指4096字节，其中1个扇区为512字节。固态硬盘4K对齐中的2048是指2048个扇区，即 512B*2048=1048576B=1024KB，即1M对齐（4096就是2MB对齐），并满足4K对齐，该值只要是4096B的倍数就是4K对齐，理论上4K对齐只要是4096整数倍就可以，不过标准的一般都是选择4096。从实测来看，固态硬盘4K对齐选2048还是4096，性能区别并不大，小容量固态硬盘4K对齐，选择2048扇区对齐是可以的。而在Win10或者大容量SSD场景下，建议还是选默认的4096扇区对齐。 分区操作","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"SQL练习","slug":"SQL练习","date":"2020-09-04T07:54:57.000Z","updated":"2020-11-08T05:12:45.626Z","comments":true,"path":"2020/09/04/SQL练习/","link":"","permalink":"https://nymrli.top/2020/09/04/SQL练习/","excerpt":"","text":"SQL练习 鉴于同学被字节狂问SQL题，因此也激发了我的危机感。 作为非科班的， 写SQL还是比较慌的， 因此做下专题训练。 理论知识: SQL语句执行顺序 1.sql执行顺序 12345678910(1) from (3) join (2) on (4) where (5) group by(开始使用select中的别名，后面的语句中都可以使用)(6) avg,sum.... (7) having (8) select (9) distinct (10) order by 2.sql语句执行顺序 12345678910(8) SELECT (9)DISTINCT&lt;select_list&gt;(1) FROM &lt;left_table&gt;(3) &lt;join_type&gt; JOIN &lt;right_table&gt;(2) ON &lt;join_condition&gt;(4) WHERE &lt;where_condition&gt;(5) GROUP BY &lt;group_by_list&gt;(6) WITH &#123;CUBE|ROLLUP&#125;(7) HAVING &lt;having_condition&gt;(10) ORDER BY &lt;order_by_list&gt;(11) LIMIT &lt;limit_number&gt; 用group by需要注意的: 在select指定的字段 要么就是包含在Group By语句的后面，为作为分组的依据的字段； 要么就要被包含在聚合函数中, e…g: sum, avg, count。 SQL查询语句中的 limit 与 offset 的区别： limit y 分句表示: 读取 y 条数据 limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据 limit y offset x 分句表示: 跳过 x 条数据，读取 y 条数据 分页操作 语法：limit开始索引，每页查询的记录数 注：索引从0开始 公式：开始索引=（当前页码-1）*每页查询的记录数即 index = (nowPageNum - 1) * pageSize 123456SELECT * FROM table WHERE 查询条件 ORDER BY 排序条件 LIMIT ((页码-1)*页大小),页大小;-- LIMIT (pageNum-1)*pageSize, pageSize-- 第一个参数是偏移量， 第二个是所取数据数 引号区别 在标准 SQL 中，字符串使用的是单引号。 如果字符串本身也包括单引号，则使用两个单引号（注意，不是双引号，字符串中的双引号不需要另外转义）。 但在其它的数据库中可能存在对 SQL 的扩展，比如在 MySQL 中允许使用单引号和双引号两种。 MySQL 参考手册： 字符串指用单引号'或双引号&quot;引起来的字符序列。例如： ‘a string’ “another string” 如果SQL服务器模式启用了NSI_QUOTES，可以只用单引号引用字符串。用双引号引用的字符串被解释为一个识别符。 1234567891011121314使用双字符:插入时 库中'aa''b''cc' aa'b'cc\"aa\"b\"\"cc\" aa\"b\"cc使用转义字符(\\):插入时 库中'aa\\'b\\'cc' aa'b'cc\"aa\\\"b\\\"cc\" aa\"b\"cc在单引号包裹的字符串中使用双引号、在双引号包裹的字符串中使用单引号 不需要使用双引号或转义字符。插入时 库中\"aa'b'cc\" aa'b'cc'aa\"b\"cc' aa\"b\"cc 反引号（`） 12345678910保留字不能用于表名，比如desc，此时需要加入反引号来区别，但使用表名时可忽略反引号。create table desc报错create table `desc`成功create table `test`成功drop table test成功 保留字不能用于字段名，比如desc，此时也需要加入反引号，并且insert等使用时也要加上反引号。create table `test`（`desc` varchar(255)）成功insert into test(desc) values('fxf')失败insert into test(`desc`) values('fxf')成功 +号 字符串数据是用单引号包在外面的，而+号只是用来连接这些字符串的. 数据库里的字段是整型的时候不要加单引号，是字符串的时候要加，其它类型根据实际情况来,双引号就是用来拼接字符串的，单引号是sql文的固有写法，因为你要动态的来拼接，涉及到变量，所以要用“+”来组合各个字符串片段。最终结果无非就是得出能在数据库查询分析器中执行的sql文。 123String sql = \"insert into student values ( \" + student.getId() + \" ,' \" + student.getUsername() + \" ', \" + student.getAge() + \" ,' \" + student.getClassnumber()+\" ')\"; 因为id和age是int型的所以不用加单引号，你的Username在数据库中定义的是一个varchar型的,而对字符型进行条件查询的时候是要加 ’ '号的：select count(*) from student where username= 'aaa ' 因此在后台写查询字符串的时候就必须这样写: string sql = &quot;select count(*) from student where username= ' &quot;+userName+ &quot; ' &quot;，这样映射成的查询语句就是: select count(*) from student where student= 'aaa ' 了. 题目 1 查找最晚入职员工的所有信息(入门题) 1select * from employees order by hire_date limit 1; 2查找入职员工时间排名倒数第三的员工所有信息 123select * from employees order by hire_date desc -- 递减排序limit 2,1 ; -- offset 2， 取1 SQL查询语句中的 limit 与 offset 的区别： limit y 分句表示: 读取 y 条数据 limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据 limit y offset x 分句表示: 跳过 x 条数据，读取 y 条数据 3 查找各个部门当前领导当前薪水详情以及其对应部门编号dept_no 123456select s.*, d.dept_no from salaries as s join dept_manager as d on s.emp_no = d.emp_nowhere d.to_date='9999-01-01' and s.to_date='9999-01-01'order by s.emp_no; 4 查找所有已经分配部门的员工的last_name和first_name 1234select e.last_name, e.first_name, d.dept_no from employees e inner join dept_emp d on e.emp_no = d.emp_no; 5查找所有员工的last_name和first_name以及对应部门编号dept_no 暂时没有分配具体部门的员工==&gt; employees有信息, 而dept_emp表中可能还没有信息；两表联合查询时以employees为准， 匹配不到dept_emp的数据用null填充—&gt;所以用外部联结的左联结 1234select e.last_name, e.first_name, d.dept_no from employees eleft join dept_emp don e.emp_no = d.emp_no join 内联结(Inner join) 联接仅返回两个联接表中都具有匹配项的行。例如，您可以将employees和departments表联接在一起，以创建一个显示每个雇员的部门名称的结果集。在内部联接中，没有部门信息的雇员不包括在结果集中，没有雇员的部门也不会包括在结果集中。 外联结(Outer join) 外联接是内部联接的扩展。 即使外联接在联接表中没有相关行，外联接也会返回这些行。 外联接共有三种类型：左联接（left join），右联接（right join）和完全联接（full join）。 left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等（有匹配项）的记录 ，否则用NULL right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录 inner join(等值连接) 只返回两个表中联结字段相等的行 总结: inner join是两集合取交集 FULL [OUTER] JOIN: 两集合取并集 left [outer] join: 产生表A的完全集, B中有匹配则有值, 没匹配则为null left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID). B表记录不足的地方均为NULL填充. Q: 最上层的两张图分别是全A和全B，那么left join和right join的作用是什么呢? A: 联表查询, 拓展字段 6 查找所有员工入职时候的薪水情况 两表并列查找，题目重点在于: 有多条薪水信息中找出入职时候的薪水情况 1234select e.emp_no, s.salary from employees e, salaries swhere e.emp_no = s.emp_no and e.hire_date = s.from_dateorder by e.emp_no desc 联表查询 12345select e.emp_no,s.salary from employees eleft join salaries swhere e.emp_no= s.emp_no and e.hire_date = s.from_date order by e.emp_no desc 7查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t 将select出来的数据重命名 having用法 12345select s.emp_no, count(s.emp_no) as tfrom salaries sgroup by s.emp_nohaving count(salary) &gt; 15 -- 由于吧count(s.emp_no)替换成t了, 因此这边可以写成 having t &gt; 15, 见执行顺序avg,count等聚合函数优先于having Question: Q: select count(s.emp_no) as t的执行顺序在having t &gt; 15之前吗? A: No是聚合函数count优先于having SQL 别名: AS SQL 别名用于为 表 或 表中的列 提供临时名称。 SQL 别名通常用于使 表名 或 列名 更具可读性。 SQL 一个别名只存在于查询期间。 别名使用 AS 关键字赋予。 什么情况下需要给表起别名？ 1.表名比较长 2.当需要在多个表中进行查询并把查询内容同时输出的时候 3.当需要进行表连接的时候（其实和2一个意思，一般情况下多个表进行连接主要目的就是为了从多个表中查询所需要的内容） having 在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。 HAVING 子句可以让我们筛选分组后的各组数据。 聚合函数 聚合函数对一组值执行计算并返回单一的值 聚合函数有什么特点？ 除了 COUNT 以外，聚合函数忽略空值。 聚合函数经常与 SELECT 语句的 GROUP BY 子句一同使用。 所有聚合函数都具有确定性。任何时候用一组给定的输入值调用它们时，都返回相同的值。 标量函数：只能对单个的数字或值进行计算。主要包括字符函数、日期/时间函数、数值函数和转换函数这四类。 8 找出所有员工当前具体的薪水salary情况 1234567891011select distinct salary from salarieswhere to_date = '9999-01-01'order by salary desc-- 或者使用group byselect salary from salaries where to_date = '9999-01-01' group by salaryorder by salary desc 说明： 对于distinct与group by的使用： 1.当对系统的性能高并且数据量大时使用group by 2.当对系统的性能不高时或者使用数据量少时两者借口 3.尽量使用group by 9获取所有部门当前manager的当前薪水情况 12345678910-- 用where连接并列查询的两表select d.dept_no, s.emp_no, s.salary from dept_manager as d, salaries as swhere d.emp_no = s.emp_no and d.to_date='9999-01-01' and s.to_date='9999-01-01';-- 用inner join合并两表select d.dept_no, s.emp_no, s.salaryfrom dept_manager as dinner join salaries as son d.to_date = '9999-01-01' and s.to_date = '9999-01-01' and d.emp_no = s.emp_no; 10 获取所有非manager的员工emp_no 把在dept_manager中的都筛选掉, 之前join的练习: A - A∩B 12345678910111213-- LEFT JOIN左连接 + IS NULLselect e.emp_nofrom employees as eleft join dept_manager don e.emp_no = d.emp_no where d.emp_no is null-- where d.emp_no isnull 中 isnull是个关键字, 正确用法是-- ISNULL ( check_expression , replacement_value )将被检查是否为 NULL的表达式替换为replacement_value-- NOT IN+子查询select emp_nofrom employees where emp_no not in (select emp_no from dept_manager) 使用见: #join 只有left join的效果 加上is null的效果 ==&gt; 找出B表中emp_no不匹配的(他们填充的数据都是null) 11 获取所有员工当前的manager 123456789101112-- myselect de.emp_no, dm.emp_no as manager_nofrom dept_emp as deleft join dept_manager dmon de.dept_no = dm.dept_nowhere dm.to_date ='9999-01-01' and dm.emp_no != de.emp_no-- 题解: INNER JOIN+不等于; 不等于可以用&lt;&gt;或者!=表示SELECT de.emp_no, dm.emp_no AS manager_no FROM dept_emp AS de INNER JOIN dept_manager AS dmON de.dept_no = dm.dept_no WHERE dm.to_date = '9999-01-01' AND de.to_date = '9999-01-01' AND de.emp_no &lt;&gt; dm.emp_no 12 获取所有部门中当前员工薪水最高的相关信息 12345select de.dept_no, de.emp_no, max(s.salary) from dept_emp as de inner join salaries as son s.emp_no = de.emp_no and de.to_date = '9999-01-01' and s.to_date = '9999-01-01'group by de.dept_no 使用GROUP BY子句时，SELECT子句中只能有聚合键、聚合函数、常数。 13 从titls表获取按照title进行分组 1234select title, count(title) as tfrom titlesgroup by titlehaving t &gt;= 2 14 从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略 忽略重复的emp_no， 上题的count(title) 其实可以写成count(emp_no) , 即有一条包含title的条目就++，而emp_no是其主键, 因此可以用emp_no的数目来代替title的数目。因此这题要求的不重复emp_no直接加个distinct即可 1234select title, count(distinct emp_no) as tfrom titlesgroup by titlehaving t &gt;= 2 15 查找employees表所有emp_no为奇数 12345select emp_no, birth_date, first_name, last_name, gender, hire_datefrom employeeswhere emp_no % 2 == 1 and last_name != 'Mary' -- 补充：emp_no % 2=1也可以改成MOD(emp_no, 2)=1，但是某些sql版本可能不支持后者(比如题库就不支持)order by hire_date desc 16 统计出当前各个title类型对应的员工当前薪水对应的平均工资 通过t.title来进行分组 123456select t.title, avg(s.salary)from titles as tinner join salaries as son t.emp_no = s.emp_no and t.to_date ='9999-01-01' and s.to_date = '9999-01-01'-- on t.emp_no=s.emp_no where t.to_date='9999-01-01' and s.to_date='9999-01-01' 也行, 表示在on执行后生成的虚拟表上再执行wheregroup by t.title 注意：AVG(*)是自动命名为avg的，所以不用重命名 17 获取当前薪水第二多的员工的emp_no以及其对应的薪水 考验limit用法 1234select emp_no, salary from salariesorder by salary desclimit 1, 1 18 查找当前薪水排名第二多的员工编号emp_no 1234567-- 用MAX函数，先查出最大salary，再利用&lt;得到不含最大salary的子表，在子表上再求最大值select e.emp_no, max(s.salary), e.last_name, e.first_namefrom employees as einner join salaries as son e.emp_no = s.emp_nowhere to_date = '9999-01-01'and salary &lt; ( select max(salary) from salaries as s where s.to_date = '9999-01-01') 19查找所有员工的last_name和first_name以及对应的dept_name 列出employees表里所有员工last_name, first_name, 根据employees中emp_no对应dept_emp中的dept_no,没有分配的员工找不到对应–&gt;采用LEFT JOIN 再根据dept_no对应departments表中的dept_name,没有分配的员工找不到对应–&gt;采用LEFT JOIN 123456select e.last_name, e.first_name, dm.dept_namefrom employees as eleft join dept_emp as de -- 这边使用left join因为要针对没有分配部门的员工on e.emp_no = de.emp_noleft join departments as dmon de.dept_no = dm.dept_no 20查找员工编号emp_now为10001其自入职以来的薪水salary涨幅值growth 最大值-最小值 1234-- 题解, sum的结果默认为growthselect (max(salary)-min(salary)) as growthfrom salarieswhere emp_no='10001'; 21 查找所有员工自入职以来的薪水涨幅情况 这题比较有难度 12345678910111213select la.emp_no, (now.salary - la.salary) as growthfrom (select e.emp_no, s.salary from employees as e left join salaries as s on e.emp_no = s.emp_no and e.hire_date = s.from_date ) as la -- 入职时的工资表inner join (select e.emp_no, s.salary from employees as e left join salaries as s on e.emp_no = s.emp_no where s.to_date = '9999-01-01') as now -- 现在的工资表on la.emp_no = now.emp_noorder by growth asc -- order by 默认asc 22统计各个部门的工资记录数 1234567891011121314151617181920-- myselect d.dept_no, d.dept_name, count(d.emp_no) as `sum`from (select * from dept_emp as de inner join departments as dm on de.dept_no = dm.dept_no) as dinner join salaries as son d.emp_no = s.emp_no group by d.dept_no -- 根据题目要求（统计各个部门的工资记录数）确定group by对象-- 题解select dm.dept_no, dm.dept_name, count(*)from departments as dminner join (select * from dept_emp as de -- (dept_emp as de 也可以 inner join salaries as s on de.emp_no = s.emp_no) as don dm.dept_no = d.dept_nogroup by d.dept_no 23对所有员工的当前薪水按照salary进行按照1-N的排名 SQL窗口函数（OLAP函数）中用于排序的专用窗口函数用法: RANK函数的使用 -&gt;mysql不支持 123select emp_no, salary, dense_rank() over (order by salary desc) as rankfrom salarieswhere to_date = '9999-01-01' 下面介绍三种用于进行排序的专用窗口函数： 1、RANK() 在计算排序时，若存在相同位次，会跳过之后的位次。 例如，有3条排在第1位时，排序为：1，1，1，4······ 2、DENSE_RANK() 这就是题目中所用到的函数，在计算排序时，若存在相同位次，不会跳过之后的位次。 例如，有3条排在第1位时，排序为：1，1，1，2······ 3、ROW_NUMBER() 这个函数赋予唯一的连续位次。 例如，有3条排在第1位时，排序为：1，2，3，4······ 窗口函数用法： 1&lt;开窗函数&gt; over ([partition by &lt;列清单&gt;] order by &lt;排序用列清单&gt;) 开窗函数大体可以分为以下两种： 1.能够作为开窗函数的聚合函数（sum，avg，count，max，min） 2.rank，dense_rank。row_number等专用开窗函数。 1.4 开窗函数和聚合函数的区别 （1）SQL 标准允许将所有聚合函数用作开窗函数，用OVER 关键字区分开窗函数和聚合函数。 （2）聚合函数每组只返回一个值，开窗函数每组可返回多个值。 24 获取所有非manager员工当前的薪水情况 123456789-- 方法1：多表联查+NOT INSELECT de.dept_no, de.emp_no, s.salary FROM dept_emp AS de, employees AS e, salaries AS sWHERE de.emp_no=e.emp_no AND de.emp_no=s.emp_no AND s.to_date='9999-01-01' AND e.emp_no NOT IN (SELECT emp_noFROM dept_manager WHERE to_date='9999-01-01') 25 获取员工其当前的薪水比其manager当前薪水还高的相 12345678910111213141516171819202122232425262728select de.emp_no, dm.emp_no as manager_no, s1.salary as emp_salary, s2.salary as manager_salaryfrom dept_emp as de, dept_manager as dm, salaries s1, salaries s2 where de.dept_no = dm.dept_no -- 找到部门的bossand de.emp_no = s1.emp_noand dm.emp_no = s2.emp_noand s1.salary &gt; s2.salaryand s2.to_date='9999-01-01'and s1.to_date='9999-01-01';-- 依次构造两张表, 再链表查询SELECT a.emp_no, b.manager_no, a.emp_salary, b.manager_salaryFROM ( SELECT de.dept_no, de.emp_no, s.salary AS emp_salary FROM dept_emp AS de, salaries AS s WHERE de.emp_no=s.emp_no AND de.to_date='9999-01-01' AND s.to_date='9999-01-01') AS a, ( SELECT dm.dept_no, dm.emp_no AS manager_no, s.salary AS manager_salary FROM dept_manager AS dm, salaries AS s WHERE dm.emp_no=s.emp_no AND dm.to_date='9999-01-01' AND s.to_date='9999-01-01') AS bWHERE a.dept_no=b.dept_no AND a.emp_salary&gt;b.manager_salary; 26 汇总各个部门当前员工的title类型的分配数目 1234567891011121314151617181920212223use niuke;select dp.dept_no, dp.dept_name, t.title, count(t.title) from departments as dp, dept_emp as de, titles as twhere dp.dept_no = de.dept_noand de.emp_no = t.emp_noand de.to_date = '9999-01-01'and t.to_date = '9999-01-01'group by dp.dept_no,t.title -- 题目的难点在于理解group by的条件-- 题解SELECT de.dept_no AS dept_no, d.dept_name AS dept_name, t.title AS title, COUNT(*) AS `count` -- 分好组后计算每个组内有多少行FROM (SELECT * FROM dept_emp AS de1 WHERE de1.to_date='9999-01-01') AS de, (SELECT * FROM titles AS t1 WHERE t1.to_date='9999-01-01') AS t, departments AS dWHERE d.dept_no = de.dept_noAND de.emp_no = t.emp_noGROUP BY d.dept_no, t.title 对于group by多个关键字的使用， 见B站视频 group by和distinct可以实现相同效果， 在redshift中group by快于distinct 27 给出每个员工每年薪水涨幅超过5000的员工编号emp_no 1234567-- 两个salary子查询相减: 表内根据某一列进行差值比较, 就需要分别获得两行数据, 因此可以获得两次表, on找到对应数据SELECT s1.emp_no, s2.from_date, (s2.salary - s1.salary) AS salary_growth FROM salaries AS s1 JOIN salaries AS s2ON s1.emp_no = s2.emp_no AND s1.to_date = s2.from_date WHERE s2.salary - s1.salary &gt; 5000 ORDER BY salary_growth DESC; 注意: 这边只能是(inner) JOIN, 如果LEFT JOIN, RIGHT JOIN会报错; 原数据7条, join以后变成49条(把s2的每一条都对应给了s1的每一条, 7*7)==&gt;和SELECT * FROM salaries AS s1, salaries AS s2;效果一样，但left join、right join效果不一样 12345678-- 其他题SELECT s1.emp_no, s2.from_date, (s2.salary - s1.salary) AS salary_growthFROM salaries AS s1, salaries AS s2WHERE s1.emp_no=s2.emp_noAND (STRFTIME('%Y', s2.from_date) - STRFTIME('%Y', s1.from_date) = 1OR STRFTIME('%Y', s2.to_date) - STRFTIME('%Y', s1.to_date) = 1)AND salary_growth&gt;5000ORDER BY salary_growth DESC; 28 查找描述信息中包括robot的电影对应的分类名称以及电影数目 这题题意其实是有一点绕的： 查找描述信息中包含robot的电影对应的分类名称以及电影数目，注意需要该分类包含电影总数量&gt;=5部 包含robot的数据, 通过like选出: select * from film where film.description like '%robot%'; 记录: category: 16条 film: 10条 film_category: 10条 1234567891011121314select * from film f,category c,film_category fc -- 1600条数据where f.description like '%robot%' -- 160条数据and f.film_id = fc.film_id -- 16条数据-- 题解:select c.name AS `分类名称category.name`, COUNT(fc.film_id) AS `电影数目count(film.film_id)`from film f,category c,film_category fcwhere f.description like '%robot%'and f.film_id=fc.film_idand fc.category_id=c.category_idand c.category_id in (select category_id from film_category group by category_id having count(film_id)&gt;=5) -- 需要该分类包含电影总数量(count(film_category.category_id))&gt;=5部 ▲注: 这题无论怎么写在本地的MYSQL上都跑不出来, 但是OJ上能过. 具体报错为: In aggregated query without GROUP BY, expression #1 of SELECT list contains nonaggregated column 'niuke.c.name'; this is incompatible with sql_mode=only_full_group_by, 这个是由于sql_mode设置不当引起的，修改下sql_mode即可. 做法为: https://cloud.tencent.com/developer/article/1404739 29 使用join查询方式找出没有分类的电影id以及名称 12345select f.film_id as '电影id', f.title as '名称'from film f left join film_category as fc on f.film_id = fc.film_idwhere fc.category_id is null -- 注意什么时候用on 什么时候用where, 这边是固定用法 30 使用子查询的方式找出属于Action分类的所有电影对应的title,description 要求子查询， 就需要先根据类别为Action将子表给筛选出来 1234567891011121314-- 联子表， 用inner join一样的select f.title, f.description from film as f, (SELECT fc.film_id from film_category fc, category c where fc.category_id = c.category_id and c.name = 'Action') as ffwhere f.film_id = ff.film_id;-- 题解select title,descriptionfrom film fwhere f.film_id in (select fc.film_id from category c join film_category fc on c.category_id=fc.category_id where name='Action') inner join 和 where比较(实际上是cross join笛卡尔积) 123456789A: select a.x, b.x from table1 a,table2 b where a.id=b.idB: select * from table1 a cross join table2 b where a.id=b.id (注：cross join后加条件只能用where,不能用on)C: select * from table1 a inner join table2 b on a.id=b.id 一般不建议使用方法A和B，因为如果有WHERE子句的话，往往会先生成两个表行数乘积的行的数据表然后才根据WHERE条件从中选择。因此，如果两个需要求交际的表太大，将会非常非常慢，不建议使用。 连接查询与子查询 初步实践证明：连接查询的性能优于子查询，所以能用连接查询的地方尽量少用子查询 连接查询 连接查询是将两个或多个的表按某个条件连接起来，从中选取需要的数据，连接查询是同时查询两个或两个以上的表的使用的。当不同的表中存在相同意义的字段时，可以通过该字段来连接这几个表。 32 将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分 123456789101112-- sqlite中无concat函数select (last_name||' '||first_name) as Name from employees -- mysqlCREATE TABLE if NOT EXISTS `employees`(`last_name` VARCHAR(60),`first_name` VARCHAR(60));INSERT INTO `employees` VALUES('mr', 'li');select concat(last_name, ' ', first_name) as 'Name' from employees -- sqlite 练习CRUD 33 创建一个actor表，包含如下列信息 123456789101112131415-- 发现图中有的含义列不需要用comment表示出create table if not exists `actor`( `actor_id` smallint(5) not null , `first_name` varchar(45) not null , `last_name` varchar(45) not null , `last_update` date not null, primary key(actor_id));-- 题解CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY, -- 设置主键first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime('now','localtime'))) -- 获取默认系统时间 34 批量插入数据 123insert into `actor`values (1, 'PENELOPE', 'GUINESS', '2006-02-15 12:34:33'), (2, 'NICK', 'WAHLBERG', '2006-02-15 12:34:33'); 35 批量插入数据,如果数据已经存在，请忽略，不使用replace操作 1234567-- sqliteinsert or ignore into actorvalues(3,'ED','CHASE','2006-02-15 12:34:33');-- mysqlinsert into actorvalues(3,'ED','CHASE','2006-02-15 12:34:33'); 36 创建一个actor_name表，将actor表中的所有first_name以及last_name导入改表 123456CREATE TABLE IF NOT EXISTS `actor_name`(`first_name` varchar(45) not null,`last_name` VARCHAR(45) not null);INSERT INTO `actor_name` SELECT first_name, last_name from actor; 37 对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastname 123456789-- sqlite在已有表上创建索引方式 -- 1.创建单列普通索引CREATE INDEX index_name ON table_name (column_name); -- 2.创建唯一索引CREATE UNIQUE INDEX index_name ontable_name (column_name);-- 注意, 这边索引是不能用``或者''框起来的CREATE UNIQUE INDEX uniq_idx_firstname on actor (first_name);CREATE INDEX idx_lastname ON actor (last_name); 38 针对actor表创建视图actor_name_view 123CREATE VIEW actor_name_view ASSELECT first_name first_name_v ,last_name last_name_vFROM actor; 39 针对上面的salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005, 针对salaries表emp_no字段创建了索引idx_emp_no。请强制使用索引查询emp_no为10005 123456&gt; -- sqlite使用索引查询的语法为&gt; SELECT|DELETE|UPDATE column1, column2...&gt; INDEXED BY (index_name)&gt; table_name&gt; WHERE (CONDITION);&gt; 它可以与 DELETE、UPDATE 或 SELECT 语句一起使用。 “INDEXED BY index-name” 子句规定必须用命名的索引来查找前面表中值，如果索引名 index-name 不存在或不能用于查询，SQLite 语句的查询失败。 1SELECT * FROM salaries INDEXED BY idx_emp_no WHERE emp_no = 10005 40 在last_update后面新增加一列名字为create_date 12345-- 向表中添加列 alter table table_name add col_name char-- 答案ALTER TABLE actor ADD create_date datetime NOT NULL DEFAULT('0000-00-00 00:00:00'); 41 构造一个触发器audit_log，在向employees表中插入一条数据的时候，触发插入相关的数据到audit中 12345-- 在MySQL中，创建触发器语法如下：CREATE TRIGGER trigger_nametrigger_time trigger_event ON tbl_nameFOR EACH ROWtrigger_stmt trigger_name：标识触发器名称，用户自行指定； trigger_time：标识触发时机，取值为 BEFORE 或 AFTER； trigger_event：标识触发事件，取值为 INSERT、UPDATE 或 DELETE； tbl_name：标识建立触发器的表名，即在哪张表上建立触发器； trigger_stmt：触发器程序体，可以是一句SQL语句，或者用 BEGIN 和 END 包含的多条语句，每条语句结束要分号结尾。 1234567create trigger audit_log after insert on employees_testfor each rowbegin insert into audit values(new.id,new.name); -- new为插入到employees_test的数据end 【NEW 与 OLD 详解】 MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据。 具体地： 在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据； 在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据； 在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据； 使用方法： NEW.columnName （columnName 为相应数据表某一列名） 42 删除emp_no重复的记录，只保留最小的id对应的记录。 12345delete from titles_test where id not in ( select min(id) from titles_test group by emp_no); 43 将所有to_date为9999-01-01的全部更新为NULL,且 from_date更新为2001-01-01 1update titles_test set to_date = null, from_date = '2001-01-01' where to_date ='9999-01-01'; 44 将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005,其他数据保持不变，使用replace实现。 123-- 考察replace函数: 其中包含三个参数，第一个参数为该字段的名称，第二参数为该字段的需要被修改值，第三个参数为该字段修改后的值update titles_test set emp_no = replace(emp_no, 10001, 10005) where id = 5; 45 将titles_test表名修改为titles_2017 12-- 因为在 MySQL里面修改表名和表里的字段都是用的 ALTER TABLE + table_name + 后面的修改部分alter table titles_test rename to titles_2017; 结合[40 在last_update后面新增加一列名字为create_date](#40 在last_update后面新增加一列名字为create_date)一起看 ALTER TABLE 表名 ADD 列名/索引/主键/外键等； ALTER TABLE 表名 DROP 列名/索引/主键/外键等； ALTER TABLE 表名 ALTER 仅用来改变某列的默认值； ALTER TABLE 表名 RENAME 列名/索引名 TO 新的列名/新索引名； ALTER TABLE 表名 RENAME TO/AS 新表名; ALTER TABLE 表名 MODIFY 列的定义但不改变列名； ALTER TABLE 表名 CHANGE 列名和定义都可以改变。 46 在audit表上创建外键约束，其emp_no对应employees_test表的主键id 123456DROP TABLE audit; CREATE TABLE audit( emp_no INT NOT NULL, create_date datetime NOT NULL, FOREIGN KEY(emp_no) REFERENCES employees_test(id) ) 48 将所有获取奖金的员工当前的薪水增加10% 123456update salaries set salary = 1.1*salary where salaries.to_date = '9999-01-01'and emp_no in ( select emp_no from emp_bonus) 50 将employees表中的所有员工的last_name和first_name通过(’)连接起来。 1select (last_name || \"'\" || first_name ) as name from employees; 51 查找字符串’10,A,B’ 把串 “10,A,B” 中的 逗号用空串替代， 变成了 “10AB”, 然后原来串的长度 - 替换之后的串的长度 就是 被替换的 逗号的个数 1select ( length('10,A,B') - length(replace('10,A,B', ',', '')) ) as cnt; 52 获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列 用mysql的话有函数right函数。就是取右边第几位的意思，同样还有一个 left 函数。select * from salaries order by right(emp_no,2)但是本题数据库是SQlite 只能用substr(emp_no,-2) 1234select e.first_namefrom employees as eorder by substr(e.first_name, -2) asc;-- substr(e.first_name, -2, 2) 从最后第二位开始取2位 53 按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employees 聚合函数group_concat（X，Y），其中X是要连接的字段，Y是连接时用的符号，默认为逗号，可省略。此函数必须与GROUP BY配合使用。 此题以dept_no作为分组，将每个分组中不同的emp_no用逗号连接起来（即可省略Y）。 123select dept_no, group_concat(emp_no) as employeesfrom dept_empgroup by dept_no 54 查找排除当前最大、最小salary之后的员工的平均工资avg_salary 12345select avg(s.salary) as avg_salaryfrom salaries as swhere to_date= '9999-01-01'and s.salary not in ( select min(salary) from salaries where to_date= '9999-01-01' )and s.salary not in ( select max(salary) from salaries where to_date= '9999-01-01' ); 55 分页查询employees表，每5行一页，返回第2页的数据 limit offset, size size是每页几条数据pageCnt，分页时offset输出页数（pageNum-1）*pageCnt 123select *from employeeslimit (2-1)*5, 5; 56 获取所有员工的emp_no 57 使用含有关键字exists查找未分配具体部门的员工的所有信息。 59 获取有奖金的员工相关信息。 60 统计salary的累计和running_total 66 牛客每个人最近的登录日期(一) 123select max(date)from logingroup by user_id 67 牛客每个人最近的登录日期(二) 123456select user.name,client.name,max(login.date)from loginleft join user on login.user_id = user.idleft join client on login.client_id = client.idgroup by user_idorder by user.name; 用group by需要注意的: 在select指定的字段 要么就要包含在Group By语句的后面，作为分组的依据； 要么就要被包含在聚合函数中。","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"SQL","slug":"SQL","permalink":"https://nymrli.top/tags/SQL/"}]},{"title":"IDEA插件开发","slug":"IDEA插件开发","date":"2020-07-11T07:50:42.000Z","updated":"2020-07-11T12:02:09.031Z","comments":true,"path":"2020/07/11/IDEA插件开发/","link":"","permalink":"https://nymrli.top/2020/07/11/IDEA插件开发/","excerpt":"","text":"新建IDEA 插件工程 File -&gt; new -&gt; Project -&gt; Plugin即可 初始会生成一个项目xml配置文件, 以下是我进行修改后的 12345678910111213141516171819202122232425262728293031323334353637&lt;idea-plugin&gt; &lt;id&gt;top.nymrli.privatesee&lt;/id&gt; &lt;name&gt;privateSee&lt;/name&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;vendor email=\"nymrli99@163.com\" url=\"http://nymrli.top\"&gt;Mrli&lt;/vendor&gt; &lt;description&gt;&lt;![CDATA[ Highlight when private methods are called. ]]&gt;&lt;/description&gt; &lt;change-notes&gt;&lt;![CDATA[ &lt;br&gt; &lt;em&gt;First created. This time will be tried&lt;/em&gt; &lt;br&gt; ]]&gt; &lt;/change-notes&gt; &lt;!-- please see https://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/build_number_ranges.html for description --&gt; &lt;idea-version since-build=\"173.0\"/&gt; &lt;!-- please see https://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/plugin_compatibility.html on how to target different products --&gt; &lt;depends&gt;com.intellij.modules.platform&lt;/depends&gt; &lt;extensions defaultExtensionNs=\"com.intellij\"&gt; &lt;!-- Add your extensions here --&gt; &lt;/extensions&gt; &lt;actions&gt; &lt;!-- Add your actions here --&gt; &lt;action id=\"FirstPluginActionId\" class=\"top.nymrli.privatesee.FirstPluginAction\" text=\"测试\" description=\"测试描述\"&gt; &lt;add-to-group group-id=\"ToolsMenu\" anchor=\"first\"/&gt; &lt;keyboard-shortcut keymap=\"$default\" first-keystroke=\"ctrl I\"/&gt; &lt;/action&gt; &lt;/actions&gt;&lt;/idea-plugin&gt; 新建action 123456789101112public class FirstPluginAction extends AnAction &#123; @Override public void actionPerformed(AnActionEvent e) &#123; // TODO: insert action logic here NotificationGroup notificationgroup = new NotificationGroup(\"flugin_id\", NotificationDisplayType.BALLOON, true); Notification notification = notificationgroup.createNotification(\"点击测试\", MessageType.INFO); Notifications.Bus.notify(notification); &#125;&#125; 运行测试: edit configuration选择plugin, 然后选择运行 启动初始化 新建一个类 123456789public class MyApplicationComponent implements ApplicationComponent &#123; @Override public void initComponent() &#123; System.out.println(\"插件初始化\"); TanChuanDialog dialog = new TanChuanDialog(); dialog.show(); &#125;&#125; 在xml配置指定 1234567&lt;application-components&gt; &lt;component&gt; &lt;implementation-class&gt; top.nymrli.privatesee.MyApplicationComponent &lt;/implementation-class&gt; &lt;/component&gt;&lt;/application-components&gt; 弹窗效果 1234567891011121314151617181920212223242526272829303132333435public class TanChuanDialog extends DialogWrapper &#123; JPanel jPanel; JLabel label; JButton btn; public TanChuanDialog() &#123; super(true); // 设置弹窗的标题 setTitle(\"启动弹窗\"); init(); &#125; // 设置弹窗中间展示内容 @Nullable @Override protected JComponent createCenterPanel() &#123; jPanel = new JPanel(); label = new JLabel(\"显示内容\"); jPanel.add(label); return jPanel; &#125; // 自定义设置底部的按钮 @Override protected JComponent createSouthPanel() &#123; jPanel = new JPanel(); btn = new JButton(\"再干一杯\"); btn.addActionListener(e-&gt;&#123; label.setText(\"被点击了哦\"); &#125;); jPanel.add(btn); return jPanel; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"}]},{"title":"getBargains的record和Solution","slug":"getBargains的record和Solution","date":"2020-05-24T08:44:25.000Z","updated":"2020-05-31T11:38:26.323Z","comments":true,"path":"2020/05/24/getBargains的record和Solution/","link":"","permalink":"https://nymrli.top/2020/05/24/getBargains的record和Solution/","excerpt":"","text":"该篇为**getBargains**仓库README.md直接搬运，记录一些appnium和andriod 10碰到的问题 自动拿券 通过别人发的口令, 打开淘宝APP进行抢券 1.itchat接收群消息 2.将口令复制到剪贴板 3.打开淘宝APP点击抢券 碰到的问题: 出现如下警告:Warning: Activity not started, its current task has been brought to the front or Warning: Activity not started, intent has been delivered to currently running top-most instance. A: 不用管他就行, 只是个警告, 提示你有应用切到了顶层 出现提示: /system/bin/sh: adb: inaccessible or not found A: 已经在adb shell中输入的命令不需要再加上adb shell前缀 e.g.umi:/ $ adb shell am start ca.zgrs.clipper/.Main (umi:/)提示已经在adb shell中了 查找app包名和Activity活动页面(Andriod 10) A: 原本的adb shell dumpsys activity | find &quot;mFocusedActivity&quot;在andriod 10上好像检测不出来 1234# 查看包名$ adb shell pm list packages# 查看Activity# $ adb shell dumpsys activity com.taobao.taobao | grep ACTIVITY adb打开应用的命令? A: adb shell am start -n package/launch activity appnium声明driver的时候是打开指定app程序, 但如果每次都是重新打开, 那么加载淘宝的速度会很慢。应该使用切换后台 A: 使用driver.start_activity('com.taobao.taobao', 'com.taobao.tao.TBMainActivity') appium：一个手机运行两个APP，APP之间相互切换 ADB滑动解锁问题: 在一个位置按住 A: 暂时还没解决, appnium可以, 但ADB好像没有找到解决方案 桌面的activity: A: .launcher.Launcher 报错selenium.common.exceptions.InvalidSessionIdException: Message: A session is either terminated or not started A: 原因是driver长时间没收到command自动关闭了, 与使用driver.quit()后再用driver执行操作报相同的错误。 -&gt;解决方案: 在desirable_caps中将newCommandTimeout设置大一点: 'newCommandTimeout': 1800 附录： python3使用appnium运行手机上的APP clipper - Broken on Android 10 (Android Q) #9 Appium Python API 中文版 By-HZJ Appium配置desired_capability详解 查看包名和activity 123456 # 在米6(Andriod 10)上尝试可行 $ adb shell dumpsys window windows | findstr mFocusedApp $ adb shell dumpsys window windows | findstr &quot;Current&quot; # 下失效 $ adb shell dumpsys activity | find mFocusedActivity 如果在有apk的情况下, aapt dump badging d:\\\\test.apk 打开APP-&gt;adb logcat &gt; D:/log.txt -&gt; 胡乱的对APP做一些操作-&gt;Ctrl+c 结束adb命令-&gt;打开log.txt文件，搜索：Displayed","categories":[],"tags":[]},{"title":"IDEA配置——自定义快捷键、生成注释","slug":"IDEA配置——自定义快捷键、生成注释","date":"2020-05-15T02:22:20.000Z","updated":"2020-09-06T08:18:25.674Z","comments":true,"path":"2020/05/15/IDEA配置——自定义快捷键、生成注释/","link":"","permalink":"https://nymrli.top/2020/05/15/IDEA配置——自定义快捷键、生成注释/","excerpt":"","text":"IDEA配置——自定义快捷键、生成注释 以前因为上JAVA课，还是不常用Java， 所以安装了个Eclipse， 但是现在要经常使用java的话， 感觉还是IDEA的支持做的可能更加到位一点 Maven换源: 因为有段时间写SpringBoot被依赖给坑过，所以把Maven换源写在最前面。 IDEA是会有默认的Maven工具的， 因此之前如果修改过Maven配置， 还需要在IDEA中指定具体使用的是哪一个MAVEN，使用哪一个配置文件。 ▲(Ctrl + Alt + S修改的是当前工程)， 如果需要对新工程进行修改， 则点击File-&gt;New Projects Settings-&gt;Settings for new Projects 其中User settings file选择之前配置过的Maven_settings就行了，换源在里面修改。注意， mirror标签要放在mirrors标签内才能生效, 跟dependencies一样， 我后来才发现我竟然没放进去。 123456789101112131415161718192021&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 补充: 还可以在pom.xml文件中指定改源, 填下下列字段: 1234567&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 自动补全提示: 菜单栏Settings(快捷键ctrl + alt + s)-&gt;Editr-&gt;General-&gt;Code Completion-&gt; 取消选中&quot;Match case&quot; IDEA自定义快捷键 功能 英文描述 快捷键 回退上一次光标位置 back Ctrl +alt + ← 前进到下一次光标位置 forward Ctrl +alt + → 选中当前部分 extend selection Ctrl + D 复制当前行↑ Duplicate Line or Selection shift + alt + ↑ 复制当前行↓ Duplicate Entire Lines shift + alt + ↓ 切换到上行 Move Line Up alt+↑ 切换到下行 Move Line Down alt+↓ 下一个方法 next Method ctrl + alt+ ↓ 上一个方法 Previous Method ctrl + alt+ ↑ 生成getter等方法 generate ctrl + L 在下生成空白一行 Start New Line Shift + Enter 在上生成空白一行 Start New Line Before Current Ctrl+ Shift + Ctrl 完成该行——添加末尾分号+换到下行 Complete Current Statement ctrl + shift + enter 剪切改行（可当成删除改行使用） Cut ctrl + X 工程中跳转指定class Navigate-class Ctrl + M 新建 Main Menu-File-New Ctrl + N 关闭当前标签页 Editor Tabs - Close Ctrl + W 未改变的快捷键设置 功能 英文描述 快捷键 格式化代码 Reformat Code ctrl + alt + L 根据上下文完成动作（导包） Show Context Actions Alt + enter 优化import导入 Optimize lmports Shift + Ctrl + O 插入生成模板(psvm) Insert Live Template Ctrl + J 打开设置面板 open settings Ctrl + alt + s 统一修改变量名 Main Menu - Refactor- Rename Shift + F6 搜索指定Class Main Menu-Navigate-class Ctrl + M 重写方法 override Methods Ctrl + o 查看类继承关系 ctrl+H 查看类继承关系图 ctrl+alt+H ▲、以上以windows设置为模板修改 生成类注释、文件注释 没弄图， 主要是按照idea生成类注释和方法注释的正确方法配置的 生成类注释 打开Preferences Editor -&gt; File and Code Templates -&gt; Files -&gt; Class 123456789101112#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != \"\")package $&#123;PACKAGE_NAME&#125;;#end#parse(\"File Header.java\")/*** @program: $&#123;PROJECT_NAME&#125;* @description: $&#123;description&#125;* @author: MrLi* @create: $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;HOUR&#125;:$&#123;MINUTE&#125;**/public class $&#123;NAME&#125; &#123;&#125; 生成方法注释 打开Preferences Editor -&gt; Live Templates -&gt; 点击右边加号为自己添加一个Templates Group -&gt; 然后选中自己的Group-&gt;再次点击加号添加Live Templates 记得要把最下面的提示▲.No applicable contexts yet.Define-&gt;设置为java 然后在Edit variables里面添加参数和返回值的自动取值 按上述步骤设置完后就可以使用了： 在方法上面直接输入/ + 你设置的Abbreviation快捷键 + tab键就直接生成了 （我设置的是/ + q + tab） 神秘密码(Template text中填的): 1234567** * @Description: $description$ * @Param: $params$ * @Return: $returns$ * @Author: MrLi* @Date: $date$ */ 删除没有用到的包 1.手动快捷键 1Ctrl + Alt + O1 2.配置自动清理 1Ctrl + Alt + S 打开设置-&gt;editor-&gt;auto import Intellij idea 报错：Error : java 不支持发行版本5 解决方案： https://blog.csdn.net/qq_22076345/article/details/82392236 Intellij IDEA 神器居然还有这些小技巧[转]","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"重拾Java笔记","slug":"重拾Java笔记","date":"2020-05-15T02:22:04.000Z","updated":"2020-08-04T16:20:06.583Z","comments":true,"path":"2020/05/15/重拾Java笔记/","link":"","permalink":"https://nymrli.top/2020/05/15/重拾Java笔记/","excerpt":"","text":"重拾Java笔记 工作主要用Java, 因此开始准备Java基础再补补。根据小猴子1024-JAVA基础整理笔记 命名规范: 没怎么写， 所以一直忘， 这次写在最前面， 便于翻阅。 大驼峰命名（UpperCamelCase）：每个单词的第一个字母大写，其他字母小写。e.g.MyException 小驼峰命名（lowerCamelCase）：如果仅有一个单词，那么所有字母全部小写，如果是两个及以上的单词组成的名称，那么除了第一个单词是全部小写外，其他都是的首字母大写，其他字母小写。e.g.getMyName 1.1 包的命名 包的命名由全部小写的单词组成。一般使用公司的域名的作为自己程序包的唯一前缀，使用倒域名规则，例如：com.baidu.项目名，然后针对每个具体的模块在区分每个模块包名，例如：论坛模块的整体包名：com.baidu.项目名.tribune(域名倒写) 1.2 类的命名 类的命名遵循大驼峰命名的规则 1.3 接口的命名 接口命名遵循大驼峰命名的规则，以大写的I开头，表示这是一个接口，以able或ible截尾。 1.4 变量命名 变量的命名遵循小驼峰命名的规则，其中控件的变量建议使用控件缩写+逻辑名称的格式，例如： 1.5 常量的命名 常量名称的每个单词都大写，并且每个单词之间通过下划线（_）连接，例如： 1.6 方法的命名 方法的命名遵循小驼峰命名的规则，以动词+名词的方式组成，例如初始化view：initView()。 1.7 资源文件命名 全部小写，并通过下划线连接。 1.7.1 布局文件的命名 作者：summer_七七 链接：https://www.jianshu.com/p/511cc270400f 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 class与文件名: 在一个Java文件里面，可以声明多个class，但是只能声明一个public class 如果使用class来声明类，文件名可以是任何合法的文件名称，文件名不需要和Class类一致 如果采用public class来声明class，那么文件名必须和类名一致 结论: 使用javac命令所编译出的class文件的名称跟java的文件名没有关系，而是跟类名一致。 函数传参: 如果参数是基本数据类型, 是会生成一个新的形参 如果参数是引用数据类型(不包括封装数据类型), 那么会生成该对象的引用（类、 接口类型、 数组类型、 枚举类型、 注解类型、 字符串型）==&gt;引用数据类型变量，调用方法时作为参数是按引用传递的 参看: Java中的基本数据类型和引用数据类型的区别 代码块的分类 使用{}括起来的代码被称为代码块，根据其位置和声明的不同可以分为下面4种： 局部代码块，在方法中出现，限定变量生命周期，及早释放，提高内存利用率 构造代码块，在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行 静态代码块， 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。一般用于加载驱动。 同步代码块(后面多线程部分会讲解) 执行顺序: 1.静态代码块，随着类加载而加载,且只执行一次 2.构造代码块，每创建一个对象就会执行一次，优先于构造方法执行 3.构造方法，每创建一个对象就会执行一次 this指针 ▲注意点: 在构造函数中调用该对象的另一个构造方法时, this(实参)必须写在最前面 12345678//构造方法//需求：在创建日期对象的时候，默认的日期是:1970-1-1MyDate()&#123; //通过this调用有参的构造方法 this(1970,1,1);//必须出现在第一行，否则将编译报错 //构造方法不能这样调用 //MyDate(1970,1,1);Error&#125; 继承问题： 静态代码块Fu 静态代码块Zi 构造代码块Fu 构造方法Fu 构造代码块Zi 构造方法Zi 分析： 1.系统将Fu.class和Zi.class分别加载到方法区的内存里面，静态代码会随着.class文件一块加载到方法区里面，所以先打印出了静态代码块中的内容。 2.构造代码块优先于构造方法执行，父类初始化之前，所以打印出父类中的构造代码块和构造方法中的内容。 多态： 在工作当中尽量面向抽象编程，不要面向具体编程，即合理利用多态——SOLID原则中依赖倒置：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。换言之，要针对接口编程，而不是针对实现编程。 多态的优点 提高程序的扩展性 降低代码之间的耦合 用法 向上转型：上面代码中子类向父类型进行转换，是自动类型转换。 向下转型： 父类向子类型转换，是强制类型转换。 重写 重写，也叫做覆盖，当父类中的方法无法满足子类需求时，子类可以将父类的方法进行重写编写来满足需求。比如孩子继承了父亲的房子，可以将房子重新装修。 方法重写的条件： 两个类必须是继承关系 必须具有相同的方法名，相同的返回值类型，相同的参数列表. 重写的方法不能比被重写的方法拥有更低的访问权限。 重写的方法不能比被重写的方法抛出更宽泛的异常。(关于异常后面的章节再讲。) 私有的方法不能被重写。 构造方法无法被重写，因为构造方法无法被继承。 静态的方法不存在重写。 重写指的是成员方法，和成员变量无关。 Super关键字: 什么时候使用super？ 子类和父类中都有某个数据，例如，子类和父类中都有name这个属性。如果要再子类中访问父类中的name属性，需要使用super。例1 子类重写了父类的某个方法（假设这个方法名叫m1），如果在子类中需要调用父类中的m1方法时，需要使用super。例1 子类调用父类中的构造方法时，需要使用super。 Object类之finalize方法 java对象如果没有更多的引用指向它（引用技术），则该java对象成为垃圾数据，等待垃圾回收器的回收，垃圾回收器在回收这个java对象之前会自动调用该对象的finalize方法==&gt;可以理解为解析函数 访问控制权限 方法访问控制权限 修饰词 本类 同一个包的类 子类 任何地方 private √ × × × default（默认） √ √ × × protected √ √ √ × public √ √ √ √ 方法访问控制权限 ▲。注意以上对类的修饰只有：public和default，内部类除外(只有内部类可以设置为protected/private) priavte和public都比较好理解和记忆，这里就不演示了，主要演示一下不同包下的两个具有父子关系的类里面使用protected和default的区别。 构造函数的权限问题: public是一个访问权限（访问修复饰符）。一般构造函数可加可不加public。 如果加上制public,就代表此类可以对外开放,其他的类可以继承它,外部也可以实例化该对象。 如果不加public,则默认的修饰词是default,表示可以被这个类的子类或者和这个类同包的类调用。 除了这两个,你还可以添加private和default 记录一下默认修饰符： 类（class）: ****缺省****就是没有修饰符，在同一个包中的类中可见，在其他包中不能用import导入。 变量（variable）: 缺省在同一个包中可见，子类不在一个包中，子类中也不可见 方法(method)：缺省在同一个包中可见，子类不在一个包中，子类中也不可见 接口（interface）： 缺省同一个包中可见 Java的interface中，成员变量的默认修饰符为：public static final；方法的默认修饰符，方法的默认修饰符是：public abstract（接口中的方法只能使用public和abstract修饰符 ）==&gt; 接口只是对一类事物属性和行为的更高次抽象；对修改关闭，对扩展开放，可以说是java中开闭原则的一种体现吧。 Final关键字: 特点为确定不可变 final修饰的类无法被继承。 final修饰的方法无法被重写。 final修饰的局部变量，一旦赋值，不可再改变。 final修饰的成员变量必须初始化值。 static关键字 static的作用 static可以修饰变量，被static修饰的变量叫做静态变量，静态变量在类加载阶段赋值，并且只赋值一次。请看例1 static可以修饰方法，被static修饰的方法叫做静态方法，不用创建对象就能能直接访问该方法，即使用类名.静态方法名的方式。静态方法不能访问非静态的数据，静态方法不能使用this。请看例2 static可以定义静态语句块，静态语句块在类加载阶段执行，并且只执行一次，并且是自上而下的顺序执行，在构造方法之前执行。请看例3 static修饰的变量、方法、代码块都是隶属于**类(class)**级别的,跟对象无关。某一类物体如果可以被多个其他物体所共享，那么可以将这类物体使用static修饰。 比如wifi，多个人可以共同使用同一个wifi，所以wifi可以使用static修饰。手机是每人使用自己的，就不能用static修饰。 抽象类的特点 抽象类无法被实例化，无法创建抽象类的对象。 虽然抽象类没有办法实例化，但是抽象类也有构造方法，该构造方法是给子类创建对象用的。这也算是多态的一种。 抽象类中不一定有抽象方法，但抽象方法必须出现在抽象类中。 抽象类中的子类可以是抽象类，如果不是抽象类的话必须对抽象类中的抽象方法进行重写。 抽象类和抽象方法不能被final修饰 接口： 接口中只能出现常量和抽象方法（jdk8之后可以有default方法） 接口里面没有构造方法，无法创建接口的对象 接口和接口之间支持多继承，即一个接口可以有多个父接口 一个类可以实现多个接口，即一个类可以有多个父接口 一个类如果实现了接口，那么这个类需要重写接口中所有的抽象方法（建议），如果不重写则这个类需要声明为抽象类（不建议） equals == 两边如果是引用类型，则比较内存地址，地址相同则是true,反之则false. Object中的equals方法比较的是两个引用的内存地址。 但是在现实的业务逻辑当中，不应该比较内存地址，应该比较地址里面的内容，所以需要对equals方法进行重写。 ==&gt;▲注意：在使用自己创建的类进行equals比较时，一定要先重写equals方法 1234567891011121314151617//根据需求规定重写equals方法//s1.equals(s2);public boolean equals(Object obj)&#123; if(this==obj)&#123; return true; &#125; if(obj instanceof Star)&#123; Star s = (Star)obj; if(s.id == id &amp;&amp; s.name.equals(name))&#123; return true; &#125; &#125; return false;&#125; 内部类的分类 内部类，顾名思义就是在一个类的内部声明一个类。内部类主要分为： 静态内部类 匿名内部类 成员内部类 局部内部类 异常的分类 异常: 指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止——JVM处理异常的方式是中断处理。 异常主要分为：Error、一般性异常、RuntimeException Error(强制中断错误)：如果程序出现了Error，那么将无法恢复，只能重新启动程序，最典型的Error的异常是：OutOfMemoryError Exception（一般性异常（编译时异常）：出现了这种异常必须在程序里面显示的处理，否则程序无法编译通过 RuntimeException（运行时异常）：此种异常可以不用显示的处理，例如被0除异常，java没有要求我们一定要处理。 JVM是如何处理异常的 main方法自己将该问题处理,然后继续运行 自己没有针对的处理方式,只有交给调用main的jvm来处理，jvm有一个默认的异常处理机制。例如上面出现的ArithmeticException，jvm在控制台里面打印出来了异常信息。 大致流程: native method自己解决-&gt;交给Main解决-&gt;交给JVM解决 更好的讲解: B站视频 throw和throws throws 用在方法声明后面，跟的是异常类名 public void m1() throws Exception 可以跟多个异常类名，用逗号隔开 表示抛出异常，由该方法的调用者来处理 (向上抛出指定异常) throw 用在方法体内，跟的是异常对象名 ==&gt; throw new Exception() 只能抛出一个异常对象名 表示抛出异常，由方法体内的语句处理，需要直接在此处解决异常(在当前语句抛出指定异常) 自定义异常 1.自定义异常类一般都是以Exception结尾，说明该类是一个异常类 2.自定义异常类，必须的继承Exception或者RuntimeException - 继承Exception：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try…catch - 继承RuntimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理） 12345678910111213141516public class MyException extends Exception&#123; /** * 添加一个空参数的构造方法 */ public MyException()&#123; super(); &#125; /** * 添加一个带异常信息的构造方法 * 查看源码发现，所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的构造方法，让父类来处理这个异常信息 */ public MyException(String s)&#123; super(s); &#125;&#125; catch 12345catch (ArithmeticException | ArrayIndexOutOfBoundsException e) &#123; // 出现多个异常,采取同样的处理措施 // 多个异常见用 | 隔开 // 多个异常必须是平级关系&#125; 字符串的不可变性 String类不能被继承 通过源码可以看到String类前面加了final修饰，因此String类是不能够被继承的。将其设置为不能被继承的原因是为了减少歧义。 字符串（String）的不可变性 String创建好之后值是不可以被改变的，这里指的是在堆中的字符串的值是不可以被改变。 String不可变的主要原因是其底层使用了一个final修饰的byte数组(jdk9之后版本中)，final修饰的变量是不能被改变的。在jdk8版本中，String底层使用的是final修饰的char数组。这个版本之间的变化。 String、StringBuffer、StringBuilder 拼接执行效率: String &lt; StringBuffer &lt; StringBuilder 线程安全: 线程安全 原因 String 安全 常量无线程安全问题 stringBuffer 安全 方法全为syncronized关键字修饰 stringbuilder 不安全 无 字符串常量池 我们声明的字符串会放到一个叫做字符串常量池的地方，这样可以减少内存的使用，字符串常量池是堆的一部分。 如果用new String(&quot;monkey&quot;)会在字符串常量池中再建一个monkey, 其实是浪费了内存。所以开发中建议使用String s = “monkey1024”;这种方式创建字符串对象，可以减少堆内存的使用。==&gt;比较两个字符串是否一致最好使用equals方法(看引用的内存地址是否一致) 详细请看: http://www.monkey1024.com/javase/481 String、StringBuffer、StringBuilder 如果需要对字符串进行频繁拼接的话，建议使用StringBuffer或者StringBuilder StringBuffer StringBuffer是一个字符串缓冲区，如果需要频繁的对字符串进行拼接时，建议使用StringBuffer。 StringBuffer的底层是byte数组（jdk9之后），jdk8中底层是char数组，如果没有明确设定，则系统会默认创建一个长度为16的byte类型数组，在使用时如果数组容量不够了，则会通过数组的拷贝对数组进行扩容，所以在使用StringBuffer时最好预测并手动初始化长度，这样能够减少数组的拷贝，从而提高效率。 StringBuilder和StringBuffer的区别 通过API可以看到StringBuilder和StringBuffer里面的方法是一样的，那他们有什么区别呢？ StringBuffer是jdk1.0版本中加入的，是线程安全的，效率低 StringBuilder是jdk5版本加入的，是线程不安全的，效率高 什么是自动拆箱和自动装箱？ 自动装箱：把基本类型转换为包装类类型 自动拆箱：把包装类类型转换为基本类型 集合 接口Collection: 由三个接口组成——List / Set / Queue 集合的由来 数组长度是固定,如果要改变数组的长度需要创建新的数组将旧数组里面的元素拷贝过去，使用起来不方便。 java给开发者提供了一些集合类，能够存储任意长度的对象，长度可以随着元素的增加而增加,随着元素的减少而减少，使用起来方便一些。 集合类的一些特点 List：里面存放的数据是有顺序的，可以存放重复的数据。 Set：里面存放的数据是没有顺序的，不能存放重复的数据。 Queue：是一个队列，里面的数据是先进先出，可以存放重复的数据。 区别 区别1: 数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值 集合只能存储引用数据类型(对象)，如果存储基本数据类型时，会自动装箱变成相应的包装类 区别2: 数组长度是固定的,不能自动增长 集合的长度的是可变的,可以根据元素的增加而自动增长 List两个子类的特点 ArrayList: 底层数据结构是数组，查询快，增删慢。 LinkedList: 底层数据结构是链表，查询慢，增删快。 ArrayList和LinkedList的区别 ArrayList底层是数组结果,查询和修改快 LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢 共同点:都是线程不安全的 ArrayList线程安全的方案 如果使用ArrayList需要考虑线程安全的问题，有两种方案： 可以使用Collections工具类中的synchronizedList方法可以将ArrayList变成线程安全的 1List list = Collections.synchronizedList(new ArrayList()); 使用java.util.concurrent包下面的CopyOnWriteArrayList，使用方式跟ArrayList一样 集合数组的互转 集合转数组： 123456789101112List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"a\");list.add(\"b\");list.add(\"c\");list.add(\"d\");//当集合转换数组时,数组长度如果是&lt;=集合的size时,转换后的数组长度等于集合的size//如果数组的长度大于了size,分配的数组长度就和你指定的长度一样String[] array = list.toArray(new String[3]);for(String s : array)&#123; System.out.println(s);&#125; 数组转集合 12345678910111213// 注意转换后的集合不能调用其add方法向里面添加数据，否则会报出UnsupportedOperationException//数组转集合String[] arr = &#123;\"a\",\"b\",\"c\"&#125;;//将数组转换成集合List&lt;String&gt; listArray = Arrays.asList(arr); //不能添加//listArray.add(\"d\"); System.out.println(listArray);//通过这种方式将listArray转换成真正的ArrayListArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(listArray);//通过Arrays.asList((T… a))的源码可以看到，这里面返回的ArrayList是在Arrays类里面定义的一个内部类，并非java.util包下的ArrayList。 基本数据类型的数组转换成集合,会将整个数组当作一个对象转换，下面程序将会打印出list的对象地址 1234int[] arr = &#123;1,2,3,4,5&#125;; List&lt;int[]&gt; list = Arrays.asList(arr); System.out.println(list);// ==&gt;[[I@282ba1e] ==&gt;▲.将数组转换成集合,数组中的数据必须是引用数据类型 1234Integer[] arr = &#123;11,22,33,44,55&#125;; List&lt;Integer&gt; list = Arrays.asList(arr);System.out.println(list);// ==&gt;[11, 22, 33, 44, 55] Collection集合 Set的特点 Set里面存储的元素不能重复，没有索引，存取顺序不一致。 ▲.这里需要注意：在向HashSet中存放自定义类型对象时，一定要重写hashCode和equals方法，原因是无重复的话需要比较， 所以得。 TreeSet简介 TreeSet的特点是可以对存放进去的元素进行排序。 ∴ 使用TreeSet存储自定义类型。这里还是存储之前定义的Person对象，需要实现Comparable接口并且重写compareTo方法，先根据name的字典顺序排序，然后再根据年龄进行排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package top.nymrli.day07;import javafx.scene.PerspectiveCamera;import javafx.util.converter.PercentageStringConverter;import java.util.*;/** * @Program: testIDEA * @Description: Set测试 * @Author: MrLi * @Create: 2020-05-16 09:09 **/public class day07 &#123; public static void main(String[] args) &#123;// HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();// boolean b1 = hs.add(\"a\");// System.out.println(hs);// boolean c1 = hs.add(\"b\");// System.out.println(hs);// for (String s : hs) &#123;// System.out.println(s);// &#125; // Q1:// HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();// Random random = new Random();// while (hashSet.size() &lt; 10) &#123;// int num = random.nextInt(20);// hashSet.add(num);// &#125;//// for (Integer i : hashSet) &#123;// System.out.println(i);// &#125; // Q2;Treeset TreeSet&lt;Person&gt; ts = new TreeSet&lt;&gt;(); ts.add(new Person(\"cl\", 30)); ts.add(new Person(\"qsy\", 25)); ts.add(new Person(\"sxh\", 30)); ts.add(new Person(\"ll\", 15)); for (Person p : ts) &#123; System.out.println(p); &#125; &#125;&#125;class Person implements Comparable&lt;Person&gt; &#123; private String name; private int age; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(getName(), person.getName()); &#125; @Override public int hashCode() &#123; return Objects.hash(getName(), age); &#125; @Override public int compareTo(Person o) &#123; int nameSame = this.name.compareTo(o.name); if (nameSame != 0)&#123; // 如果name不相等 // 当compareTo方法返回正数的时候，系统将元素存储到右边，所以集合存取顺序一致 return nameSame; &#125;else&#123; return this.age - o.age; &#125; &#125;&#125; Map接口概述 map中的元素是以键-值的方式存在的，通过键可以获取到值，键是不可以重复的，跟地图比较像，通过一个坐标就可以找到具体的位置。该接口由三个类实现: HashMap / HashTable / AbstractMap ▲与前两个相比，添加元素的函数由add =&gt; put 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class day08_Map &#123; public static void main(String[] args) &#123; HashMap&lt;String, Integer&gt; hashmap = new HashMap&lt;&gt;(); hashmap.put(\"Cl\", 18); hashmap.put(\"GJQ\", 15); hashmap.put(\"SXH\", 10); hashmap.put(\"HSR\", 12); System.out.println(hashmap); System.out.println(hashmap.containsValue(\"CL\")); System.out.println(hashmap.containsKey(\"GJQ\")); System.out.println(\"------\"); Collection&lt;Integer&gt; values = hashmap.values(); System.out.println(values); System.out.println(\"----------\"); Integer res = hashmap.remove(\"SXH\"); System.out.println(res); // Map的遍历 // 方法一 Set&lt;String&gt; keySet = hashmap.keySet(); Iterator&lt;String&gt; iterator = keySet.iterator(); System.out.println(keySet); while (iterator.hasNext()) &#123; String key = iterator.next(); System.out.println(\"Key: \" + key + \" value: \" + hashmap.get(key)); &#125; System.out.println(\"---------\"); // 上述的代替写法// for (String key : keySet) &#123;// System.out.println(\"Key:\" + key + \"value: \" + hashmap.get(key));// &#125; // 方法二 // Map中的键和值被封装成了Entry对象,并存储在Set集合中，通过entrySet()可以获取到这个Set集合。 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = hashmap.entrySet();// Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entriesIterator = entries.iterator(); for (Map.Entry&lt;String, Integer&gt; en : entries) &#123; System.out.println(\"Key:\" + en.getKey() + \" value: \" + en.getValue()); &#125; System.out.println(\"_______________\"); &#125;&#125; LinkedHashMap LinkedHashMap的特点：存取顺序一致 TreeMap TreeMap的特点：可以对存储的元素进行排序 HashMap和Hashtable的区别 Hashtable是JDK1.0版本出现的,是线程安全的,效率低，不可以存储null键和null值 HashMap是JDK1.2版本出现的，是线程不安全,效率高，可以存储null键和null值 Collection工具 1234Collections.sort(list);Collections.shuffle(list);Collections.reverse(list);Collections.binarySearch(list, 6); Collection总结 List(存取有序,有索引,可以重复) ArrayList 底层是数组实现的,线程不安全,查找和修改快,增和删比较慢 LinkedList 底层是链表实现的,线程不安全,增和删比较快,查找和修改比较慢 Vector 底层是数组实现的,线程安全的,无论增删改查都慢 如果查找和修改多,用ArrayList 如果增和删多,用LinkedList 如果都多,用ArrayList Set(存取无序,无索引,不可以重复) HashSet 底层是哈希算法实现 LinkedHashSet 底层是链表实现,可以保证元素唯一,存取顺序一致 TreeSet 底层是二叉树算法实现，可以排序，存储自定义类型时需要注意实现Comparable接口并重写compareTo方法 一般在开发的时候不需要对存储的元素排序,所以在开发的时候大多用HashSet,HashSet的效率比较高.TreeSet在面试的时候比较多 Map HashMap 底层是哈希算法 LinkedHashMap 底层是链表，存取顺序一致 TreeMap 底层是二叉树算法，可以排序 开发中用HashMap比较多 HashCode HashCode方法的作用 在HashSet中的元素是不能重复的，jvm可以通过equals方法来判断两个对象是否相同，假设自定义一个Person类里面有10个成员变量，每调用一次equals方法需要做10次if判断分别比较这10个成员变量是否相等，如果想HashSet中存放100个对象，那就会做1000次if判断，数据量大的话会严重影响性能。 要解决这个问题的话可以这样做，将一些特征相似或相近的对象归类放到一起给他们一个编号，在做equals判断时，先比较这些编号，编号相同的话再去比较equals，这样可以减少一些比较次数。这个编号可以通过HashCode方法获得。HashCode方法的作用就是将对象进行分类，然后获取到编号值。 举个例子，图书馆里面的书都是分好类的，想找《java编程思想》这本书，先找到计算机类的书架，然后再去找就行，倘若图书馆里面的书籍没有分类，那找起来就如大海捞针。 如何重写HashCode HashCode算法决定了对象的归类，如果算法编写的不好可能不会对性能有所提升。在编写时最好可以让对象均匀的散列开，这里假设可以将对象分为10个种类，那么每个种类中存放的对象的数量最好不要相差太多。 将Person的name和age属性都加上了，可以将Person进行细分，开发中建议使用： 12345678@Overridepublic int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result;&#125; 为什么上面的prime的值是31？其实这个值改成别的也可以，只不过定义为31之后有一些好处： 31是一个质数,质数是能被1和自己本身整除的数，并且这个数不大也不小 31这个数好算,2的五次方-1,2向左移动5位 关于重写HashCode方法的一些说明 任何时候对同一对象多次调用 hashCode 方法，都必须一直返回同样的整数。 如果两个对象通过 equals(Object) 方法来比较相等，那么这两个对象的 hashCode的值必须相等。 如果两个对象通过 equals(Object) 方法比较结果不等，可以相等也可以不相等。 Properties类 123456789101112131415161718192021222324252627282930313233343536373839404142public class PropTest &#123; public static void main(String[] args) throws IOException &#123; Properties properties = new Properties(); try &#123; properties.load(new FileReader(\"store.txt\")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Set&lt;String&gt; set = properties.stringPropertyNames(); for (String k : set) &#123; String value = properties.getProperty(k); System.out.println(k + \"=\" + value); &#125; &#125; public static void loadInto() &#123; &#125; public static void storeInto() &#123; FileWriter fileWriter = null; try &#123; final Properties properties = new Properties(); properties.setProperty(\"陈力\", \"18\"); properties.setProperty(\"SQY\", \"19\"); properties.store(fileWriter, \"Save data\"); fileWriter = new FileWriter(\"store.txt\"); fileWriter.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fileWriter.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 泛型的概念 在编写集合相关代码时在eclipse里面总有一些黄色警告，在不使用注解的情况下，使用泛型之后，就不会有这些黄色警告了。 通过API可以看到Collection,List,ArrayList,这几个类里面都有,这个就是泛型，里面的E可以是任何引用数据类型，使用泛型指明了数据类型之后，这个集合里面只能存储这种数据类型的对象。 不使用泛型时，要进行多次类型强制转换。如List list = new ArrayList(); 使用泛型: List&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); 泛型的优点 可以统一集合中的数据类型，提高安全性 可以减少强制类型转换 自定义泛型 通过JDK的源码可以看到，泛型一般写的都是或者，里面的T和E就是表示使用者指定的类型。可以自己定义一个使用泛型的类 泛型通配符 在实际工作当中，有可能通过调用某个方法来接受一个返回值List的数据，这样就不太好确定返回值中的数据类型，这样可以使用泛型通配符&lt;?&gt; 1List&lt;?&gt; list = new ArrayList&lt;Integer&gt;();//=号右边可能是通过调用某个方法返回的List 使用泛型通配符限定子类或者父类 ? extends E 向下限定，E及其子类，可以存储当前类型的子类 ? super E 向上限定，E及其父类，可以存储当前类型的父类 123456789101112/** * ? extends E 向下限定，E及其子类，可以存储当前类型的子类 * ? super E 向上限定，E及其父类，可以存储当前类型的父类 */public class GenericTest03 &#123; public static void main(String[] args) &#123; List&lt;Person&gt; personList = new ArrayList&lt;&gt;(); List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(); //因为studentList中存放的Student是Person类的子类，所以可以将studentList放入personList中 personList.addAll(studentList); &#125;&#125; 集合框架中的三种迭代方式删除数据 普通for循环,可以删除,注意让索引做自减运算 1234567//1,普通for循环删除,索引做自减运算for(int i = 0; i &lt; list.size(); i++) &#123; if(\"b\".equals(list.get(i))) &#123; list.remove(i); i--; &#125;&#125; 迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常 增强for循环不能删除 可变参数 注意：如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个。 1234567// 修饰符 返回值类型 方法名(数据类型… 变量名)&#123;&#125;//可变参数其实是一个数组public static void print(int ... arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 注解: 之前也看过一些Java-Spring Boot的视频, 有些讲的详细的会去讲源码，然后当时就是看到有很多注解， 就不懂是什么意思， 形成了理解障碍。 所以这次特地又去了解了一下 Spring-Boot的入口函数是由@SpringBootApplication注解的main，无疑@SpringBootApplication这个注解是非常重要的。 123456789101112131415161718192021@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited// ---@SpringBootConfiguration@EnableAutoConfiguration// ---@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; ...&#125; 上述一共七个注解，一共可以分成三类： 元注解、配置注解、Component组件注解。之前学的时候就是被这么多注解给吓到了，而且课上对注解的讲解也特别小， 所以一直感觉注解是个高深莫测的东西。 元注解讲解： Java 元注解 @Inherited使用该注解的注解父类的子类可以继承父类的注解。请注意，如果使用注释类型来注释除类之外的任何内容，则此元注释类型不起作用。 还要注意，这个元注释只会导致从超类继承注释; 已实现的接口上的注释无效。 配置注解源码讲解: 尚硅谷SpringBoot顶尖教程(springboot之idea版spring boot) @AutoConfigurationPackage由@Import({Registrar.class})注解，其中Registrar 123public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; AutoConfigurationPackages.register(registry, (String[])(new AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(new String[0])); // 后面第二个参数的结果是metadata中的所有包==&gt;即获得主配置类所在包及以下子包&#125; 将主配置类(@SpringBootApplication标注的类)所在包及下面子包里面的所有组件扫描到Spring容器中 注解（Annontion）是Java5开始引入的新特征。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。==&gt;类似注释，但能将内容传递给程序，对修饰对象有约束作用。 IO流 123456//每次调用的时候会读取一个字节的数据，如果read返回结果是-1，则说明读取完毕int temp;//保存当前读取的字节数据//将读取的数据赋值给temp，然后再判断while ((temp = f.read()) != -1) &#123; System.out.print((char)temp);&#125; 使用File.separator解决不同系统的路径问题 在windos中的文件路径是以&quot;“来分隔 在linux中的文件路径是以”/&quot;来分隔 如果将上面代码部署到linux中会读取不到文件，为了保证编写的代码跨平台需要使用java.io包下的File.separator来替代文件路径的分隔符，如下：fis = new FileInputStream(&quot;file&quot; + File.separator + &quot;monkey.txt&quot;); 文件IO读写FileInputStream 1234567891011121314151617181920212223242526272829303132333435363738394041public class copy_io &#123; public static void main(String[] args) &#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(\"C:\\\\Users\\\\10630\\\\Desktop\\\\TODO\\\\ok.yml\"); File file = new File(\"good.txt\"); if (!file.exists()) &#123; boolean newFile = file.createNewFile(); System.out.println(\"Yes, Create it~\"); &#125; fos = new FileOutputStream(\"good.txt\"); byte[] arr= new byte[1024]; int length; while ((length = fis.read(arr)) != -1) &#123; // f.read(arr)和f.read()不一样， // f.read(arr)会一次性读取arr大小的数据， 然后长度用length来记录读取了多少字符 // write写的时候， 将数组arr中length写入文件 // 在while中输出了length的大小， 为1024， 842 fos.write(arr, 0, length); System.out.println(length); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; finally&#123; try &#123; fis.close(); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 使用缓冲流进行文件拷贝BufferedInputStream Java中提供了BufferedInputStream和BufferedOutputStream缓冲流用来读取和写出， BufferedInputStream读取时会创建一个长度为8192的byte类型数组，程序一次读取8192个字节数据到数组中 使用缓冲流之后就不用再自定义byte类型数组了。 12345678910111213141516171819202122232425262728293031public class bufferStream_io &#123; public static void main(String[] args) throws IOException &#123; BufferedInputStream ` = null; BufferedOutputStream bos = null; try &#123; bis = new BufferedInputStream(new FileInputStream(\"C:\\\\Users\\\\10630\\\\Desktop\\\\TODO\\\\ok.yml\")); bos = new BufferedOutputStream(new FileOutputStream(\"test.txt\")); // 其实不存在会自动创建, 不需要下面的代码 File f = new File(\"text.txt\"); if (!f.exists()) &#123; boolean newFile = f.createNewFile(); System.out.println(\"创建成功~\"); &#125; int tmp; while ((tmp = bis.read()) != -1) &#123; bos.write(tmp); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (bis != null) &#123; bis.close(); &#125; if (bos != null) &#123; bos.close(); &#125; &#125; &#125;&#125; 使用自定义数组和buffer的图解 jdk7的新写法 在jdk7中新加入了AutoCloseable接口，IO流中的类都实现了这个接口，这样在读取或者写出操作结束之后，系统会自动close相关资源，开发者不需要再手动close了 12345678try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"C:\\\\Users\\\\10630\\\\Desktop\\\\TODO\\\\ok.yml\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"auto.txt\"));) &#123; int tmp; while ((tmp = bis.read()) != -1) &#123; bos.write(tmp); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用字符流解决乱码问题FileReader 字符流FileReader主要用来读取字符的IO流，使用字符流读取文本文件可以解决乱码问题。 12345678910111213public class FileReader_io &#123; public static void main(String[] args) &#123; try (FileReader fileReader = new FileReader(\"G:\\\\C与C++、\\\\java\\\\testIDEA\\\\src\\\\testForChinests.txt\")) &#123; int c; while ((c = fileReader.read()) != -1) &#123; System.out.print((char) c); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用缓冲流BufferedReader可以一次读取一行的文字： 12345678910// 读取try (BufferedReader bufferedReader = new BufferedReader(new FileReader(\"G:\\\\C与C++、\\\\java\\\\testIDEA\\\\src\\\\testForChinests.txt\"))) &#123; String s; while ((s = bufferedReader.readLine()) != null)&#123; System.out.print(s); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 写入 12345678910111213141516171819// 写入 try(FileWriter fw = new FileWriter(\"newword.txt\");)&#123; fw.write(\"我喜欢学习java\"); fw.write(32); // 空格 fw.write(97); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try(BufferedWriter bw = new BufferedWriter(new FileWriter(\"newword.txt\"));)&#123; bw.write(\"我喜欢打篮球\"); bw.newLine();//换行 bw.write(\"我喜欢踢足球\"); bw.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; BufferedWriter、BufferedInputStream内的参数都是原有的FileWrite、FileInputStream，实际上使用了装饰模式（设计模式） BufferedWriter、BufferedReader多了writeLine、readLine方法 装饰者设计模式的优点： 不用修改被装饰对象的源码，装饰者与被装饰者耦合度不高。 转换流——编码格式转换InputStreamReader： 字节-&gt;字符 如果要解决上面问题，需要使用InputStreamReader和OutputStreamWriter指明文本文件的编码，这两个类都属于字符流，可以将字节流输出为字符流。 1234567891011121314151617public static void main(String[] args) &#123; // 使用FileInputStream读取文本内容，然后通过InputStreamReader和指定的编码将字符转换为字节 try (BufferedReader br = new BufferedReader( new InputStreamReader(new FileInputStream(\"utf-8.txt\"), \"utf-8\")); BufferedWriter bw = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(\"gbk.txt\"), \"gbk\"));) &#123; String msg; while((msg = br.readLine()) != null)&#123; bw.write(msg); &#125; bw.flush(); &#125; catch (UnsupportedEncodingException | FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125;&#125; 上面的代码中再FileInputStream对象上使用了InputStreamReader装饰，从而将字节转换为字符，之后再InputStreamReader对象上又使用了BufferedReader将字符进行缓冲，从而提高。==&gt;都有reader 输出指定目录下的所有文件名称 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class OutputAllFiles &#123; private static int cnt = 0; public static void main(String[] args) &#123; final File file = getFile(); getListFiles(file); &#125; public static void getListFiles(File f) &#123; final File[] files = f.listFiles(); for (int i = 0; i &lt; files.length; i++) &#123; for (int j = 0; j &lt; cnt; j++) &#123; System.out.print('\\t'); &#125; System.out.println(files[i]); if (files[i].isDirectory()) &#123; cnt++; getListFiles(files[i]); cnt--; &#125; &#125; &#125; public static File getFile() &#123; System.out.print(\"请输入要遍历的目录: \"); final Scanner scanner = new Scanner(System.in); while (true) &#123; final String next = scanner.nextLine(); // next()不会吸取字符前/后的空格/Tab键，只吸取字符，开始吸取字符（字符前后不算）直到遇到空格/Tab键/回车截止吸取； // nextLine()吸取字符前后的空格/Tab键，回车键截止。 final File file = new File(next); if (!file.exists()) &#123; System.out.println(\"输出的路径错误, 请重新输入\"); &#125; else if (file.isFile()) &#123; System.out.println(\"请输入一个文件夹路径\"); &#125; else &#123; return file; &#125; &#125; &#125;&#125; 序列化和反序列化 在工作中有可能遇到多台机器远程通信的情况，如果要将机器A中的某个java对象传输到机器B上面，需要将这个java对象转换为字节序列然后进行传输。将对象转换为字节序列的过程叫做序列化，反之叫做反序列化。 使用序列化还可以将一个对象保存到硬盘中，然后再通过反序列化将该对象读取到内存里面。 一个对象如果支持序列化，需要实现Serializable的接口，这个接口中没有任何方法，实现该接口后，JVM会给这个对象做特殊待遇 123456789101112131415public class SerializableTest &#123; public static void main(String[] args) &#123; final Student s = new Student(\"张三\"); try (ObjectOutputStream zhangsan = new ObjectOutputStream(new FileOutputStream(\"zhangsan\"))) &#123; // try()括号中，如果是多句， 则加;， 单句不需要加; // ObjectOutputStream也是一个装饰模式 zhangsan.writeObject(s); zhangsan.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在一个类实现Serializable接口后，系统会给每个对象一个序列化版本号，当这个类的源码被修改后，系统会重新分配一个新的序列化版本号，这样做的好处就是保证序列化和反序列化的对象内容一致。例如将一个对象序列化到硬盘之后，修改这个对象所对应类的源码，在进行反序列化是就会报出InvalidClassException异常。如果手动编写序列化版本号之后，就不会出现这个异常了。 1234/** * 自动生成序列化版本号 */private static final long serialVersionUID = -716323668524282676L; transient关键字 如果不希望将Student类中的age属性序列化，可以使用transient声明该属性，在序列化时将忽略这个属性。transient private int age; 多线程 三种创建方式 继承Thread类， 重写run方法 优点:可以直接使用Thread类中的方法,代码简单 缺点:继承Thread类之后就不能继承其他的类 实现runnable接口， 重写run方法 优点:即时自定义类已经有父类了也不受影响，因为可以实现多个接口 缺点:在run方法内部需要获取到当前线程的Thread对象后才能使用Thread中的方法 实现Callable接口创建线程 优点：可以获取返回值，可以抛出异常 缺点：代码编写较为复杂 1.自定义一个类实现java.util.concurrent包下的Callable接口 2.重写call方法 3.将要在线程中执行的代码编写在call方法中 4.创建ExecutorService线程池 5.将自定义类的对象放入线程池里面 6.获取线程的返回结果 7.关闭线程池，不再接收新的线程，未执行完的线程不会被关闭 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//1.定义一个类实现Callable&lt;V&gt;接口class MyCallable implements Callable&lt;Integer&gt; &#123; // 2.重写call方法 @Override public Integer call() throws Exception &#123; // 3.将要执行的代码写在call方法中 //返回一个随机数 Random r = new Random(); int num = r.nextInt(100); return num; &#125;&#125;public class MultiThread_callable &#123; public static void main(String[] args) &#123; //4.创建ExecutorService线程池 ExecutorService exec = Executors.newCachedThreadPool(); //5.将自定义类的对象放入线程池里面 //开启两个线程 Future&lt;Integer&gt; result1 = exec.submit(new MyCallable()); Future&lt;Integer&gt; result2 = exec.submit(new MyCallable()); //判断线程是否计算完毕 while (!result1.isDone() &amp;&amp; !result2.isDone()) &#123; System.out.println(\"等待线程计算完毕\"); &#125; //6.获取线程的返回结果 Integer i1 = null; try &#123; i1 = result1.get(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; Integer i2 = null; try &#123; i2 = result2.get(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println(i1); System.out.println(i2); //7.关闭线程池，不再接收新的线程，未执行完的线程不会被关闭 exec.shutdown(); &#125;&#125; 线程池 线程池是初始化一个多线程应用程序过程中创建一个线程集合，即一次创建多个线程，然后在需要执行新的任务时直接去这个线程集合中获取，而不是重新创建一个线程。任务执行结束后，线程放回到池子中等待下一次的分配。 线程池的作用 解决创建单个线程耗费时间和资源的问题。 创建线程池 上面代码中演示了两种方式创建线程池 Executors.newFixedThreadPool(int nThreads); 通过传入的int类型参数来指定创建线程池中的线程数，如果任务数量大于线程数量，则任务会进行等待。 Executors.newCachedThreadPool(); 会根据需要创建新线程的线程池，如果线程池中的线程数量小于任务数时，会创建新的线程，线程池中的线程最大数量是Integer.MAX_VALUE，int类型的最大值。如果线程的处理速度小于任务的提交速度时，会不断创建新的线程来执行任务，这样有可能会因为创建过多线程而耗尽CPU 和内存资源。 匿名内部类、labmbda表达式创建 12345678910111213141516171819202122232425262728293031323334353637383940414243public class NewWayCreateThread &#123; /** * @Description: 匿名内部类 * @Author: MrLi * @Param: [args] * @Return: void * @Date: 2020/5/18 */ public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println( Thread.currentThread().getName() + \" \" + i); System.out.println( getClass() + \" \" + i); &#125; &#125; &#125;).start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"main\" + i); &#125; &#125; /** * @Description: labmbda表达式 * @Author: MrLi * @Param: [args] * @Return: void * @Date: 2020/5/18 */ public static void main(String[] args) &#123; new Thread(() -&gt;&#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; &#125;).start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"main \" + i); &#125; &#125;&#125; synchronized同步方法与同步代码块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class SleepThread &#123; public static long begin1; public static long end1; public static long begin2; public static long end2; public static void main(String[] args) &#123; LongTask ts = new LongTask(); Thread t1 =new Thread(() -&gt; &#123; begin1 = System.currentTimeMillis(); ts.add(); end1 = System.currentTimeMillis(); &#125;); Thread t2 = new Thread(() -&gt; &#123;// new Thread(syncValue::add).start(); begin2 = System.currentTimeMillis(); ts.add(); end2 = System.currentTimeMillis(); &#125;); t1.start(); t2.start(); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long begin = 0; long end = 0; if(begin1 &gt; begin2)&#123; begin = begin2; &#125;else&#123; begin = begin1; &#125; if(end1 &gt; end2)&#123; end = end1; &#125;else&#123; end = end2; &#125; System.out.println(\"两个线程总共耗时：\" + (end -begin) + \"ms\"); &#125;&#125;class LongTask &#123; private static int num = 0; Object obj = new Object();// public synchronized void add() &#123;// try &#123;// Thread.sleep(3000L);// System.out.println(\"执行耗时任务\");// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// num++;// System.out.println(num);// &#125; //两个线程总共耗时：6001ms public void add() &#123; try &#123; Thread.sleep(3000L); System.out.println(\"执行耗时任务\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj)&#123; num++; System.out.println(num); &#125; &#125; //两个线程总共耗时：3001ms&#125; 修改后将需要同步的代码放到synchronized代码块中，再次运行SynchronizedTest02类，打印结果是3秒，因为那段耗时较长的代码是在异步情况下运行，所以节省了一些时间。 注意：多个线程在执行synchronized同步代码块时，代码块括号里面可以传入任意对象，但一定要保证多个线程访问的是同一个对象。(这里代码只有一个实例, 这个实例的obj是相同的) 单例模式 饿汉式 构造方法私有化 创建当前类对象 对外提供公共的访问方法将SingletonHungary对象暴露给外部 懒汉式 构造方法私有化 创建当前类的引用 对外提供公共的访问方法将SingletonHungary对象暴露给外部 单例模式的案例Runtime java.lang包下的Runtime类使用了单例模式，使用该类可以执行windows系统里面的一些命令，例如：mspaint（打开画图软件），shutdown（关机）等等。 1234public static void main(String[] args) throws IOException &#123; Runtime rt = Runtime.getRuntime(); rt.exec(\"mspaint\");&#125; 使用Timer类来实现定时任务 123456789101112131415161718192021222324public class TimerTest &#123; public static void main(String[] args) throws ParseException &#123; final Timer t = new Timer();// t.schedule(new TimerTask() &#123;// @Override// public void run() &#123;// final Date date = new Date();// System.out.println(date);// &#125;// &#125;, new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss SSS\").parse(\"2017-07-03 18:09:00 000\"), 5000); //第一个参数接收TimerTask对象，即上面创建的MyTimerTask //第二参数的Date类型是定时任务执行的开始时间 //第三个参数指定定时任务每隔多少毫秒执行一次 t.schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println(new Date()); &#125; &#125;, 0, 1000); &#125;&#125; Lambda表达式和匿名内部类 使用lambda表达式的前提是： 必须为函数式接口（有且只有一个抽象方法的接口，可以用@FunctionalInterface,接口中可以包含默认、静态、私有方法） 匿名内部类会生成一个xxxx$1.class文件， 而lambda表达式不会生成 lambda 有延迟加载的效果，从而不存在性能浪费——优化日志 From: https://www.bilibili.com/video/BV1A4411K7Gx?p=417 反射 获得字节码class的三种方式 Source源代码阶段=&gt;Class.forName(&quot;全类名&quot;) 多用于配i文件，捋类名定义在配文件中。读取文件，加载类 Class类对象阶段=&gt;类名.class 多用于参数的传递 Runtime运行阶段=&gt;对象.getClass() 多用于对象的获取字节码的方式 ▲结论: 同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 123456789101112131415// way1： Class.forNameClass cls1 = Class.forName(\"top.nymrli.day17_reflect.Person\");System.out.println(cls1);// way2:Class&lt;Person&gt; cls2 = Person.class;System.out.println(cls2);// way3:Person person = new Person();Class cls3 = person.getClass();System.out.println(cls3);System.out.println(cls3 == cls2);System.out.println(cls1 == cls2); Class对象功能: 获取功能: 获得成员变量 Filed[] getFields()——获得public修饰的字段 Field getField(String name)——获得所有字段，无视修饰符 Field[] getDeclaredFields() Field getDeclaredField(String name) 获得构造方法 Constructor constructor = cls1.getConstructor(String name); Constructor[] constructors = cls1.getConstructors(); Constructor declaredConstructor = cls1.getDeclaredConstructor(String name); Constructor[] declaredConstructors = cls1.getDeclaredConstructors(); 获得成员方法 Method method = cls1.getMethod(String name); Method[] methods = cls1.getMethods(); Method declaredMethod = cls1.getDeclaredMethod(String name); Method[] declaredMethods = cls1.getDeclaredMethods(); 12345678910111213141516171819202122232425Class cls1 = Class.forName(\"top.nymrli.day17_reflect.Person\");System.out.println(cls1);Person p = new Person();Field name = null;try &#123; name = cls1.getDeclaredField(\"name\");&#125; catch (NoSuchFieldException e) &#123; e.printStackTrace();&#125;Object o = null;try &#123; name.setAccessible(true); // private私有方法, 暴力反射 o = name.get(p);&#125; catch (IllegalAccessException e) &#123; e.printStackTrace();&#125;System.out.println(o);try &#123; name.set(p, \"cl\"); o = name.get(p);&#125; catch (IllegalAccessException e) &#123; e.printStackTrace();&#125;System.out.println(o); 案例： *需求：写一个“框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 实现： 1.配置文件 2.反射 步骤 1.捋需要创建的对象的全类名和需要执行的方法定义在配置文件中 2.在程序中加载读取配置文件 3.使用反射技术来加载类文件进内存 4.创建对象 5.执行方法 123456789101112131415161718192021public class Example &#123;// public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; public static void main(String[] args) throws Exception &#123; Properties properties = new Properties(); ClassLoader classLoader = Example.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(\"prop.properties\"); properties.load(is); String className = properties.getProperty(\"className\"); String classMethod = properties.getProperty(\"classMethod\"); Class cls = Class.forName(className); // 直接newInstance在java 9已被弃用 Object o = cls.getDeclaredConstructor().newInstance(); Method method = cls.getMethod(classMethod); method.invoke(o); &#125;&#125; 类的加载与初始化 类的加载过程： 加载–&gt;链接（验证、准备（为静态量开辟空间并赋予初始值）、解析（将class中的符号引用转变为运行时的地址的直接引用））–&gt;初始化 为类的静态变量赋值，然后执行类的初始化（static）语句 初始化的详细过程： 如果类还没有被加载和链接，那就先进行加载和链接 如果类存在父类，并且父类还没有初始化，那就先初始化直接父类 如果类中存在初始化语句，顺序执行初始化语句 class初始化时机 创建类的实例（四种方式） 访问类中的某个静态变量，或者对静态变量进行赋值 主动调用类的静态方法 Class.forName（“包类名&quot;）完成子类的初始化，也会完成对本类的初始化（接口例外） 该类是程序引导入口（mian入口或者test入口） 双亲委派机制 bootstrap的加载过程是用c来完成的，在java中输出bootstrap加载器结果为null 加载类的过程： 不断将加载任务交给父类加载器，是个递归的过程。如果父类能够加载，那么就加载，如果不能加载，那么就交给子类去加载。 bootstrap：提供核心环境 、extension classloader负责拓展内容、application classloader负责程序运行期间自己写的class对象 1234567891011121314151617181920212223242526272829303132333435363738protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; // 这边是递归的过程，会去找父加载器， 直至parent为null即用bootstrap加载 if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats PerfCounter.getParentDelegationTime().addTime(t1 - t0); PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 作用： 避免类的重复加载 保护程序安全，防止核心的JAVA语言环境遭受破坏 正则匹配 字符 说明 . 匹配除&quot;\\r\\n&quot;之外的任何单个字符。若要匹配包括&quot;\\r\\n&quot;在内的任意字符，请使用诸如&quot;[\\s\\S]&quot;之类的模式。 * 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配&quot;z&quot;和&quot;zoo&quot;。* 等效于 {0,}。 + 一次或多次匹配前面的字符或子表达式。例如，&quot;zo+&quot;与&quot;zo&quot;和&quot;zoo&quot;匹配，但与&quot;z&quot;不匹配。+ 等效于 {1,}。 ? 零次或一次匹配前面的字符或子表达式。例如，&quot;do(es)?“匹配&quot;do&quot;或&quot;does&quot;中的&quot;do”。? 等效于 {0,1}。 方法说明： matches ：尝试将整个区域与模式匹配。 lookingAt： 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。 find： 尝试查找与该模式匹配的输入序列的下一个子序列。 find(int start）：重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。 替换： replaceFirst 替换首次匹配，replaceAll 替换所有匹配。 ▲强调: 使用group()之前一定得指定个以上的匹配方法 匹配模式： 123456Pattern compile = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);/** private static final int ALL_FLAGS = CASE_INSENSITIVE | MULTILINE | DOTALL | UNICODE_CASE | CANON_EQ | UNIX_LINES | LITERAL | UNICODE_CHARACTER_CLASS | COMMENTS;*/ 附录 Q:java 定义long和float为什么要加L和F？ A:整形默认值为int，如果定义long 必须要加L来区分，浮点型默认值为double双精度，定义单精度float要加F来区分。 Java中@SuppressWarnings的作用 A:作用：告诉编译器忽略指定的警告，不用在编译完成后出现警告信息。如@SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)等同于@SuppressWarnings(“unchecked”, “deprecation”) 输出变量类型——Python中type关键字 1234public static String getType(Object o)&#123; //通过反射来获取变量类型方法 return o.getClass().toString(); //使用int类型的getClass()方法 // return o.getClass().getName(); //使用int类型的getClass()方法&#125; ▲. 基本数据类型无效， 如int， 但可以查看包装数据类型。 JDBC链接MYSQL Maven的pom.xml中的配置 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;top.nymrli.jdbc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- 引入mysql驱动jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.25&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; java文件内容 123456789101112131415161718192021222324252627282930313233public class JDBCTest &#123; public static void main(String[] args) throws Exception&#123; // 1.加载驱动程序， 这个包名是固定的 Class.forName(\"com.mysql.jdbc.Driver\"); // 2.创建连接 String url=\"jdbc:mysql://localhost:3306/fortest?useSSL=false&amp;serverTimezone=UTC\"; String username=\"root\"; String userpwd=\"cl123123\"; Connection conn = DriverManager.getConnection(url,username,userpwd); // 3.定义SQL语句 String table = \"stu\";// String sql = String.format(\"SELECT * FROM %s;\", table); String sql = String.format(\"UPDATE %s set age = 50 where name = 'cl';\", table); // 4. 获取执行sql的对象 Statement stat = conn.createStatement(); // 5.执行SQL语句// ResultSet resultSet = stat.executeQuery(sql); int res = stat.executeUpdate(sql);// System.out.println(resultSet); // 6. 查看执行结果 System.out.println(res); // 7.释放资源 stat.close(); conn.close(); &#125;&#125; DriverManager：驱动管理对象 Connection：数据库连接对象 statement：执行sql的对象 Resultset：结果集对象 Preparedstatement：执行sq1的对象roper SQL操作 分页操作 语法：limit开始索引，每页查询的记录数 注：索引从0开始 公式：开始索引=（当前页码-1）*每页查询的记录数即 index = (nowPageNum - 1) * pageSize 插入语句： insert into `train`.`student` (`name`, `age`) values (&quot;gb&quot;, 19); ▲注意这边是`train`.`student`，如果写成`train.student`是会找不到表的","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"}]},{"title":"华为春招4.29笔试题","slug":"华为春招4-29笔试题","date":"2020-04-29T14:43:54.000Z","updated":"2020-04-29T14:47:07.162Z","comments":true,"path":"2020/04/29/华为春招4-29笔试题/","link":"","permalink":"https://nymrli.top/2020/04/29/华为春招4-29笔试题/","excerpt":"","text":"4.29三道笔试题： 做了其他大厂的笔试题后，好像确实华为的稍微简单点。只不过其他的笔试题是有模拟题的，华为的这三道题基本上都是DFS A： 带有重复元素的全排列问题，求不重复的排列数。以下做法50%, TLE了。正确做法是直接用公式计算 123456789101112131415161718192021222324252627282930'''@Author: Mrli@Date: 2020-04-29 20:23:34@LastEditTime: 2020-04-29 21:24:40@Description: '''s = input().strip()ans = list(s)sz = len(s)res = []def dfs(depth): if depth &gt; sz-1: return if depth == sz-1: enter = ''.join(ans) if enter not in res: res.add(enter) for i in range(sz): swap(i, depth) dfs(depth+1) swap(i, depth) def swap(x, y): tmp = ans[x] ans[x] = ans[y] ans[y] = tmpdfs(0)print(len(res)) B 求去掉K个字母，留下字典序最小的字符串。当时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879'''@Author: Mrli@Date: 2020-04-29 19:01:55@LastEditTime: 2020-04-29 22:31:07@Description: '''\"\"\"# 看错题, 以为是从开头去掉k个。一分钟写的过了40%\"\"\"# s = input().strip()# n = int(input().strip())# print( s[n:])'''# 第一次尝试, ''-&gt;加n-k个-&gt; 过10%'''# 选择移除K个字母, 要使留下来的字符串字典序最小# s = input().strip()# n = int(input().strip())# fans = s# def dfs(ans, index, depth):# global fans# if index &gt;= len(s): return # if depth &gt; n: return# if depth == n:# if ans &lt;= fans:# fans = ans# print(ans + s[index])# dfs(ans + s[index], index+1, depth + 1)# dfs(ans, index+1, depth) # dfs('', 0, 0)# print(fans)'''当时dfs('', 0, 0)的写法报了点错, 以为不能这么写, 于是换成s中去k个'''# s = input().strip()# sz = len(s)# n = int(input().strip())# fans = ''.join('z' for i in range(sz))# def dfs(ans, index, depth):# global fans# if index &gt;= sz: return # if depth == n:# if ans &lt;= fans:# fans = ans# # print(ans[0:index] + ans[index+1:])# dfs(ans[0:index] + ans[index+1:], index+1, depth + 1)# dfs(ans, index+1, depth)# dfs(s, 0, 0)# print(fans)'''第三次尝试, 重新接回第一种到n-k个数时结束的写法. 考完以后写出来的. 但不知道能不能过全部样例'''s = input().strip()sz = len(s)n = int(input().strip())fans = ''.join('z' for i in range(sz)) # 初始化为最大def dfs(ans, index): global fans if index == sz: return if len(ans) == sz-n: # print(ans, fans, ans &lt;= fans) if ans &lt;= fans: fans = ans dfs(ans + s[index], index+1) dfs(ans, index+1)dfs('', 0)print(fans) C: k, n, r： 有k个硬币， n个城市， r条单向边 要求在硬币足够的情况下的最短距离 ▲一开始以为是dijistra+硬币数(第二指标)判断，但是实际情况并不是在求最短距离的情况下的硬币数，而是在硬币充足的情况下最短距离是多少===&gt;实际就变成了一个非常简单的DFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160/* * @Author: Mrli * @Date: 2020-04-29 19:05:27 * @LastEditTime: 2020-04-29 21:12:04 * @Description: */#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 105;const int INF = 0x3f3f3f3f;int dist[MAXN][MAXN];int T[MAXN][MAXN];bool visited[MAXN] = &#123;false&#125;;// int d[MAXN];// int cost[MAXN];int mans = INF;bool haveans = false;int k, n ,r; // 硬币数、城市数、道路数/* dijistra做法的尝试 */// void dijistra(int s)&#123;// d[s] = 0;// cost[s] = 0;// for (int i = 1; i &lt;= n; i++) &#123;// int u = -1, MIN = INF;// for (int j = 1; j &lt;= n; j++) &#123;// if (visited[j] == false &amp;&amp; d[j] &lt; MIN)&#123;// u = j;// MIN = d[j];// &#125;// &#125;// if ( u == -1) return;// visited[u] = true;// // 保证路径最短, 再确定硬币// // for (int v = 1; v &lt;= n; v++) &#123;// // if (visited[v] == false &amp;&amp; dist[u][v] != INF)&#123;// // if ( dist[u][v] + d[u] &lt; d[v] )&#123;// // d[v] = dist[u][v] + d[u];// // cost[v] = T[u][v] + cost[u]; // // &#125;else if (dist[u][v] + d[u] == d[v])&#123;// // if( cost[u] + T[u][v] &lt; cost[v] )&#123;// // cost[v] = cost[u] + T[u][v];// // &#125;// // &#125;// // &#125;// // &#125;// // 保证硬币足够的情况下// for (int v = 1; v &lt;= n; v++) &#123;// if (visited[v] == false &amp;&amp; dist[u][v] != INF)&#123;// if ( T[u][v] + cost[u] &lt; cost[v] )&#123; // if ( dist[u][v] + d[u] &lt; d[v] )&#123;// d[v] = dist[u][v] + d[u];// &#125;// cost[v] = T[u][v] + cost[u]; // &#125;else if ( T[u][v] + cost[u] == cost[v] )&#123;// if( dist[u][v] + d[u] &lt; d[v] )&#123;// d[v] = dist[u][v] + d[u];// // cost[v] = T[u][v] + cost[u]; // &#125;// &#125;// &#125;// &#125;// &#125;// &#125;/* 思考过用BFS */// void bfs(int s)&#123;// queue&lt;int&gt; q;// q.push(s);// visited[s] = true;// while (!q.empty())&#123;// int u = q.front();// q.pop();// for (int v = 0; v &lt; n; v++) &#123;// if ( visited[v] == false &amp;&amp; dist[u][v] != INF)&#123;// &#125;// &#125;// &#125;// &#125;void dfs(int u, int ans, int q)&#123; if ( u == n )&#123; if ( q &lt;= k)&#123; if (ans &lt;= mans)&#123; mans = ans; &#125; haveans = true; &#125; &#125; for (int v = 2; v &lt;= n; v++) &#123; if ( visited[v] == false &amp;&amp; dist[u][v] != INF)&#123; visited[v] = true; // cout &lt;&lt; \"next: \" &lt;&lt;v &lt;&lt;endl; dfs(v, ans + dist[u][v], q + T[u][v]); visited[v] = false; &#125; &#125;&#125;void init()&#123; fill(dist[0], dist[0] + MAXN* MAXN, INF); fill(T[0], T[0] + MAXN* MAXN, INF); // fill(d, d+MAXN, INF); // fill(cost, cost+MAXN, INF);&#125;int main()&#123; cin &gt;&gt; k &gt;&gt; n &gt;&gt; r; init(); for (int i = 0; i &lt; r; i++) &#123; int s, d, w, cost; cin &gt;&gt; s &gt;&gt; d &gt;&gt; w &gt;&gt; cost; dist[s][d] = w; T[s][d] = cost; &#125; dfs(1, 0, 0); if (haveans) cout &lt;&lt; mans &lt;&lt;endl; else cout &lt;&lt; -1 &lt;&lt;endl; // for (int i = 1; i &lt;= n; i++) &#123; // for (int j = 1; j &lt;= n; j++) &#123; // cout &lt;&lt; dist[i][j] &lt;&lt;\" \"; // &#125; // cout &lt;&lt; endl; // &#125; // visited[1] = true; // for (int i = 1; i &lt;= n; i++) &#123; // for (int j = 1; j &lt;= n; j++) &#123; // cout &lt;&lt; T[i][j] &lt;&lt;\" \"; // &#125; // cout &lt;&lt; endl; // &#125; // dijistra(1); // for (int i = 1; i &lt;= n; i++) &#123; // cout &lt;&lt; d[i] &lt;&lt; endl; // &#125; // cout &lt;&lt;\"---\" &lt;&lt;endl; // for (int i = 1; i &lt;= n; i++) &#123; // cout &lt;&lt; cost[i] &lt;&lt; endl; // &#125; // cout &lt;&lt; d[n] &lt;&lt; endl; // if ( cost[n] &lt;= k)&#123; // cout &lt;&lt; d[n] &lt;&lt;endl; // &#125;else&#123; // cout &lt;&lt; -1 &lt;&lt;endl; // &#125; return 0;&#125; 牛客网华为练习题 合并表记录 12345678odict = dict()n = int(input().strip())for i in range(n): ids, val = map(int, input().split()) odict[ids] = odict.setdefault(ids, 0) + valslist = sorted(odict.items(), key= lambda d: d[0], reverse=True)for k, v in odict.items(): print(k, v) Python 中字典的有序无序针对的是插入顺序而不是键值大小顺序,要想根据key或value排序可以直接用sort后再输出。而如果输出要保持输入的顺序，则使用 collections下的 OrderedDict(‘记住插入顺序的字典’) Python逆序输出 1234567891011# reversen = input().strip()# for i in range()rev = reversed(n)for i in rev: print(i)# range(-1)s = 'hello'for i in range(len(s)-1, -1, -1): print(s[i])","categories":[],"tags":[]},{"title":"剑指Offer_leetcode刷题记录","slug":"剑指Offer-leetcode刷题记录","date":"2020-04-20T05:10:13.000Z","updated":"2020-09-08T06:48:08.250Z","comments":true,"path":"2020/04/20/剑指Offer-leetcode刷题记录/","link":"","permalink":"https://nymrli.top/2020/04/20/剑指Offer-leetcode刷题记录/","excerpt":"","text":"由于临近春招末期，时间比较紧，就不记录思考过程了，直接贴AC代码。以后有空补上 代码大多用C++，仅是过而已，没有进行优化。 面试题03. 数组中重复的数字 12345678910111213141516class Solution &#123;public: int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; std::ios::sync_with_stdio(false); int size = nums.size(); if (size &lt;0 ) return 0; vector&lt;int&gt; arr(size); for(int i=0; i &lt; size; i++)&#123; arr[nums[i]] += 1; if (arr[nums[i]] &gt; 1)&#123; return nums[i]; &#125; &#125; return 0; &#125;&#125;; 面试题04. 二维数组中的查找 123456789101112131415161718192021222324class Solution &#123;public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty()) return false; int column = matrix[0].size(); int row = matrix.size(); if (column &lt;= 0 || row &lt;= 0) return false; int r = 0 ; int c = column - 1; while( r &lt; row &amp;&amp; c &gt;= 0 )&#123; if (matrix[r][c] == target)&#123; return true; &#125;else if(matrix[r][c] &gt; target)&#123; c --; &#125;else&#123; r ++; &#125; &#125; return false; &#125;&#125;; 面试题05. 替换空格 123class Solution: def replaceSpace(self, s: str) -&gt; str: return s.replace(' ', '%20') 面试题06. 从尾到头打印链表 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt; ans; ListNode *p = head; while( p != NULL)&#123; ans.insert(ans.begin(), p-&gt;val); // or : ans.push_back(); // then : return reverse(ans.begin(), ans.end()); p = p-&gt;next; &#125; return ans;; &#125;&#125;; 顺便重新再写遍链表吧: 12 面试题07. 重建二叉树 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; if (preorder.empty() &amp;&amp; inorder.empty()) return NULL; TreeNode *root = createTree(preorder, inorder, 0, preorder.size()-1, 0, inorder.size()-1); return root; &#125; TreeNode *createTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int preL, int preR, int inL, int inR)&#123; if (preL&gt; preR) return NULL; int k; for( k=inL; k&lt;=inR; k++)&#123; // ▲写的挺熟练了, 就是多了个int被恶心坏了 if (preorder[preL] == inorder[k]) break; &#125; TreeNode *root= new TreeNode(preorder[preL]); int numLeft = k - inL; root-&gt;left = createTree(preorder, inorder, preL+1, preL + numLeft, inL, k-1); root-&gt;right = createTree(preorder, inorder, preL +numLeft + 1, preR, k+1, inR); return root; &#125;&#125;; 面试题09. 用两个栈实现队列 123456789101112131415161718192021222324252627282930313233343536class CQueue &#123;private: stack&lt;int&gt; s1; stack&lt;int&gt; s2;public: CQueue() &#123; &#125; void appendTail(int value) &#123; s1.push(value); &#125; int deleteHead() &#123; int ans; if(s1.empty() &amp;&amp; s2.empty() )return -1; if (s2.empty())&#123; while(!s1.empty())&#123; s2.push(s1.top()); s1.pop(); &#125; &#125; ans = s2.top(); s2.pop(); return ans; &#125;&#125;;/** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj-&gt;appendTail(value); * int param_2 = obj-&gt;deleteHead(); */ 面试题10- I. 斐波那契数列 12345678910111213141516171819202122class Solution &#123;private: int arr[105]; const int MOD = 1000000007;public: int fib(int n) &#123; if (n == 0)&#123; arr[n] = 0; return arr[n]; &#125;else if (n == 1)&#123; arr[n] = 1; return arr[n]; &#125; if ( arr[n] )&#123; return arr[n]; &#125;else&#123; // 这边是递归而不是arr[n-1] + arr[n-2] arr[n] = (fib(n-1)%MOD + fib(n-2)%MOD)%MOD; return arr[n]; &#125; &#125;&#125;; 面试题10- II. 青蛙跳台阶问题 问题实质就是fib 12345678910111213141516171819202122232425class Solution &#123; private: int arr[105]; const int MOD = 1000000007;public: int numWays(int n) &#123; if (n == 1)&#123; arr[n] = 1; return arr[n]; &#125;else if (n == 2)&#123; arr[n] = 2; return arr[n]; &#125;else if (n==0)&#123;// 比上题多了个范围 arr[n] = 1; return arr[n]; &#125; if ( arr[n] )&#123; return arr[n]; &#125;else&#123; // 这边是递归而不是arr[n-1] + arr[n-2] arr[n] = (numWays(n-1)%MOD + numWays(n-2)%MOD)%MOD; return arr[n]; &#125; &#125;&#125;; 面试题15. 二进制中1的个数 n &amp; (n-1)结果为 n &lt;- 将n最右边的1改成0的数 123456789101112class Solution &#123;public: int hammingWeight(uint32_t n) &#123; uint32_t tmp = n; int ans = 0; while(tmp)&#123; ans ++; tmp = tmp &amp; (tmp-1); &#125; return ans; &#125;&#125;; 面试题16. 数值的整数次方 快速幂， 对负数判断一下 123456789101112131415double myPow(double base, int n) &#123; double res = 1; bool fu = false; if (n&lt;0) fu = true; int tmp = abs(n); while(tmp&gt;0)&#123; if(tmp&amp;1) res = res * base; // cout &lt;&lt; res &lt;&lt; \" \" ; base = base * base; tmp &gt;&gt;= 1; &#125; if (fu) return 1/res; else return res;&#125; 面试题17. 打印从1到最大的n位数 因为n的范围没给， 所以其实需要考虑大数的，只不过不考虑好像也能过。 12345678910111213141516171819202122232425class Solution &#123;public: int pow(int base, int n)&#123; int res =1; for(int i=0;i&lt;n;i++) res *= base;; return res; &#125; vector&lt;int&gt; printNumbers(int n) &#123; int ans = 0; for(int i=0 ; i &lt; n ; i++)&#123; ans += 9*pow(10, i); &#125; vector&lt;int&gt; v; for(int i=1; i &lt;= ans; i ++) v.push_back(i); return v; &#125;&#125;; 写了个奇怪的东西 1234567891011121314151617181920212223242526#include &lt;algorithm&gt;#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; printNumbers(int n) &#123; vector&lt;int&gt; res; int arr[10005]; for(int i=0;i &lt; n;i++) //cout &lt;&lt; a &lt;&lt; \" \"; arr[i] = i; do&#123; string ans; for(int i=0;i &lt; n;i++) ans += '0'+arr[i]; res.push_back(atoi(ans.c_str())); &#125;while(next_permutation(arr, arr+n)); return res;&#125;int main()&#123; vector&lt;int&gt; v = printNumbers(3); for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; return 0;&#125; 面试题18. 删除链表的节点 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteNode(ListNode* head, int val) &#123; if (head == NULL) return NULL; if (head-&gt;val == val &amp;&amp; head-&gt;next == NULL) return NULL; if (head-&gt;val == val) return head-&gt;next; ListNode *pre = head; ListNode *p = head-&gt;next; while(p != NULL)&#123; if (p-&gt;val == val)&#123; pre-&gt;next = p-&gt;next; delete(p); p = pre-&gt;next; &#125;else&#123; pre = p; p = p-&gt;next; &#125; &#125; return head; &#125; &#125;; 面试题22. 链表中倒数第k个节点 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; if( head == NULL) return NULL; // int (k == 0 ) ; return head; // 把0删了就可以了 ListNode *p = head; for(int i = 0; i &lt; k-1; i++)&#123; if (p-&gt;next == NULL) return NULL; p = p-&gt;next; &#125; ListNode *jnode = head; while(p-&gt;next != NULL)&#123; p = p-&gt;next; jnode = jnode-&gt;next; &#125; return jnode; &#125;&#125;; 面试题24. 反转链表 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL) return NULL; // pre这个NULL卡了很久，如果反转的话，第一个节点需要指向NULL ListNode *pre = NULL; ListNode *p = head; ListNode *ans = NULL; if (p-&gt;next==NULL) return head; while (p != NULL)&#123; ListNode *next = p-&gt;next; if (next == NULL) ans = p; p-&gt;next = pre; pre = p; p = next; &#125; return ans; &#125;&#125;; 面试题25. 合并两个排序的链表 大晚上感觉思路还行, 就是细节过不了. 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(l1 == NULL) return l2; if(l2 == NULL) return l1; if (l1 == NULL &amp;&amp; l2 == NULL) return NULL; ListNode *head =new ListNode(0); // 随便生成一个表头, 最后忽略这个就行了 ListNode *newlist = head; while( l1 &amp;&amp; l2)&#123; if ( l1-&gt;val &lt; l2-&gt;val )&#123; newlist-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; newlist-&gt;next = l2; l2 = l2-&gt;next; &#125; newlist = newlist-&gt;next; // 指针也要往后 &#125; newlist-&gt;next = l1 ? l1 : l2; // 最后只剩一个 return head-&gt;next; &#125;&#125;; 面试题26. 树的子结构 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSubStructure(TreeNode* A, TreeNode* B) &#123; bool notsub = false; // if(A == NULL || B == NULL) return false; if ( A &amp;&amp; B)&#123; if ( A-&gt;val == B-&gt;val ) // 找到根节点 // notsub = isSubStructure(A, B); notsub = same(A,B); if (!notsub)&#123; // notsub = same(A-&gt;left,B); notsub = isSubStructure(A-&gt;left,B); &#125; if (!notsub)&#123; // notsub = same(A-&gt;right, B); notsub = isSubStructure(A-&gt;right, B); &#125; &#125; return notsub; &#125; bool same(TreeNode* A, TreeNode* B)&#123; if (B == NULL) return true; if (A==NULL) return false; if( A-&gt;val != B-&gt;val) return false; return same(A-&gt;left,B-&gt;left) &amp;&amp; same(A-&gt;right, B-&gt;right); &#125;&#125;; 面试题30. 包含min函数的栈 同时维护一个存储最小值的栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MinStack &#123;private: stack&lt;int&gt; common; stack&lt;int&gt; assist;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; common.push(x); if (assist.empty()) assist.push(x); else&#123; int top = assist.top(); if ( x &lt; top ) assist.push(x); else assist.push(top); &#125; &#125; void pop() &#123; // int tmp = common.top(); common.pop(); assist.pop(); // return tmp; &#125; int top() &#123; int tmp = common.top(); return tmp; &#125; int min() &#123; int tmp = assist.top(); // assist.pop(); return tmp; &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;min(); */ 面试题31. 栈的压入、弹出序列 123456789101112131415161718class Solution &#123;public: bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123; stack&lt;int&gt; st; int n = popped.size(); int j = 0; for (int i = 0; i &lt; pushed.size(); ++i)&#123; st.push(pushed[i]); while(!st.empty() &amp;&amp; j &lt; n &amp;&amp; st.top() == popped[j])&#123; // 注意逻辑短路问题， 判断是否为空 必须在top之前 st.pop(); ++j; &#125; &#125; return st.empty(); // return (j == sz); &#125;&#125;; 面试题32 - I. 从上到下打印二叉树 BFS层次遍历 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; levelOrder(TreeNode* root) &#123; vector&lt;int&gt; ans; if (root == NULL) return ans; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty())&#123; TreeNode *now = q.front(); q.pop(); ans.push_back(now-&gt;val); if (now-&gt;left) q.push(now-&gt;left); if (now-&gt;right) q.push(now-&gt;right); &#125; return ans; &#125;&#125;; 面试题32 - II. 从上到下打印二叉树 II 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt; int&gt; &gt; ans; if (root == NULL) return ans; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty())&#123; int sz = q.size(); // 统计当层的节点数 vector&lt;int&gt; row; for(int i=0; i &lt; sz; i++)&#123; TreeNode *now = q.front(); q.pop(); row.push_back(now-&gt;val); if (now-&gt;left) q.push(now-&gt;left); if (now-&gt;right) q.push(now-&gt;right); &#125; ans.push_back(row); &#125; return ans; &#125;&#125;; 面试题32 - III. 从上到下打印二叉树 III 控制an.push_back的内容 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt; vector&lt;int&gt; &gt; ans ; if (root== NULL) return ans; queue&lt;TreeNode*&gt; q; int level = 1; // 基层从前往后， 偶层从后往前 q.push(root); // 第一层 while(!q.empty())&#123; int n = q.size(); vector&lt;int&gt; line; for(int i = 0; i &lt; n; i ++)&#123; TreeNode *now = q.front(); q.pop(); line.push_back(now-&gt;val); if ( now-&gt;left != NULL) q.push(now-&gt;left); if ( now-&gt;right != NULL ) q.push(now-&gt;right); &#125; if ( level % 2 == 1) ans.push_back(line); else &#123; reverse(line.begin(), line.end()); ans.push_back(line); &#125; level ++; &#125; return ans; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123; if (postorder.empty()) return false; int sz = postorder.size(); return helper(postorder, 0, sz-1); &#125; bool helper(vector&lt;int&gt;&amp; postorder, int l, int r)&#123; int sz = postorder.size(); int rootkey = postorder[sz-1]; int smallp = 0; while( postorder[smallp] &lt; rootkey) smallp++; // 之后smallp 为第一个 &gt;= rootkey的索引， 即右子树的第一个 int bigp = smallp; while( bigp &lt; sz-1 )&#123; // 检测右子树是不是符合全部大于key if(postorder[bigp] &lt; rootkey) return false; &#125; bool left = true; if ( smallp &gt; 0 ) left = helper(postorder, l, smallp-1); bool right = false; if ( bigp &gt; 0) right = helper(postorder, smallp, r-1); return (left &amp;&amp; right); &#125;&#125;; 剑指 Offer 41. 数据流中的中位数 Java中priorityQueue的使用——借用堆完成 add+offer（push）、element+peek（front-top）、remove+poll（pop） c++优先队列(priority_queue)用法详解 参数缺省的话，优先队列就是大顶堆，队头元素最大。最小堆可以用仿函数less指定 如果是自定义类型, 则需要自己重载operator&lt; 或者 自己写仿函数() 仿函数: （functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符 12// priority_queue&lt;Type, Container, Functional&gt;, 其中Functional为仿函数, 如greater, less 数组中数字出现的次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std; int findFirst1(int n)&#123; int i = 0; cout &lt;&lt; \"enter\" &lt;&lt; n; // &amp;&amp; (i &lt; sizeof(int) * 8) while( ( n &amp; 1) == 0) &#123; //▲最后排查出来时这边括号没加 n = n &gt;&gt; 1; i++; &#125; // cout &lt;&lt; \"findFirst1\" &lt;&lt; i &lt;&lt; endl; return i; &#125; bool isbit1(int n, int index)&#123; n = n &gt;&gt; index; return (n &amp; 1); &#125; void solve(vector&lt;int&gt; &amp;v, int &amp;one, int &amp;two)&#123; int sz = v.size(); cout &lt;&lt; sz &lt;&lt; endl; int firstXOR = 0; // cout &lt;&lt; \"begin\" ; for(int i = 0; i &lt;sz; i++) &#123; cout &lt;&lt; v[i]; firstXOR ^= v[i]; &#125; // cout &lt;&lt; endl; // cout &lt;&lt; \"firstXOR\" &lt;&lt; firstXOR &lt;&lt; endl; int index = findFirst1(firstXOR); // cout &lt;&lt; index &lt;&lt; endl; for(int i = 0; i &lt; sz;i++ )&#123; if ( isbit1(v[i], index) )&#123; one ^= v[i]; &#125;else&#123; two ^= v[i]; &#125; &#125; &#125; vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; v(2); if (nums.empty()) return v; solve(nums, v[0], v[1]); return v; &#125;int main()&#123; int arr[] = &#123;1,2,5,2&#125;; vector&lt;int&gt; v(arr, arr+ 4); vector&lt;int&gt; ans = singleNumbers(v);; cout &lt;&lt; ans[0] &lt;&lt; \" \" &lt;&lt; ans[1] &lt;&lt; endl;&#125; 面试题47. 礼物的最大价值-dp 12345678910111213141516class Solution: def maxValue(self, grid: List[List[int]]) -&gt; int: row, col = len(grid), len(grid[0]) # print(row, col ) # 初始化第一列 for r in range(1, row): grid[r][0] += grid[r-1][0] # 初始化第一行 for c in range(1, col): grid[0][c] += grid[0][c - 1] # dp状态更新 for i in range(1, row): for j in range(1, col): grid[i][j] += max(grid[i-1][j], grid[i][j - 1]) return grid[row - 1][col - 1] 面试题49. 丑数 12345678910class Solution: def nthUglyNumber(self, n: int) -&gt; int: dp, a, b, c = [1] * n, 0 , 0, 0 for i in range(1, n): n2, n3, n4 = dp[a] * 2, dp[b] * 3, dp[c] * 5 dp[i] = min(n2, n3, n4) if dp[i] == n2: a+=1 if dp[i] == n3: b+=1 if dp[i] == n4: c+=1 return dp[-1] 面试题50. 第一个只出现一次的字符 1234567891011from collections import OrderedDictclass Solution: def firstUniqChar(self, s: str) -&gt; str: hashtable = OrderedDict() for i in s: hashtable[i] = hashtable.setdefault(i, 0) + 1 for k, v in hashtable.items(): if v == 1: return k return ' ' 剑指 Offer 53 - I. 在排序数组中查找数字 I 看到&quot;在排序数组中查询&quot;==&gt; 二分查找 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; return getRight(nums, target) - getLeft(nums, target) + 1; &#125; // 找到和target相等的最边界(target 最小的下标) int getLeft(vector&lt;int&gt;&amp; v, int target)&#123; int len = v.size(); int l = 0, r = len-1; while( l &lt;= r)&#123; int m = l + r &gt;&gt; 1; if ( v[m] &lt; target)&#123; l = m + 1; &#125;else&#123; // 如果相等的话缩小右边边界 r = m - 1; &#125; &#125; return l; &#125; // 找到和target的最右界(比target大的最小下标) int getRight(vector&lt;int&gt;&amp; v, int target)&#123; int len = v.size(); int l = 0, r = len-1; while( l &lt;= r)&#123; int m = l + r &gt;&gt; 1; if ( v[m] &lt;= target)&#123; // 如果相等的话, 说明之前都是正确的, 那么就需要缩小左边界的范围 l = m + 1; &#125;else&#123; r = m - 1; &#125; &#125; return r; &#125;&#125;; [剑指 Offer 53 - II. 0～n-1中缺失的数字 一个长度为n-1的递增排序数组中的所有数字都是唯一的==&gt;二分 为什么最后return l解析 1234567891011121314151617class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int l = 0, r = len - 1; while( l &lt;= r) &#123; // 当 arr[r - l] 为空时跳出 int mid = (l + r) &gt;&gt; 1; if ( nums[mid] == mid)&#123; l = mid + 1; &#125;else if ( nums[mid] &gt; mid)&#123; r = mid - 1; &#125; &#125; // 当 r == l == mid时,还会再进行一轮, 此时有arr[mid] != mid 那么就是当前数字出了问题, return谁都可以, 但由于mid是在while里声明的, 因此只考虑return l or r, 由于不相等的情况下该轮while结束后r := mid - 1, 因此就偏离了。 最终就选取l了. return l; &#125;&#125;; 面试题52. 两个链表的第一个公共节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: node1, node2 = headA, headB while node1 != node2: node1 = node1.next if node1 else headB node2 = node2.next if node2 else headA return node1 # # Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = None# def getListLength(head):# if head == None:# return -1# ans = 0# while head != None:# ans += 1# head = head.next# return ans# def getIntersectionNode(headA: ListNode, headB: ListNode) -&gt; ListNode:# # print(headA, headB)# lena = getListLength(headA)# lenb = getListLength(headB)# print(lena, lenb)# diff = lena - lenb # if diff&gt;0:# flagalong = True# else:# flagalong = False# if flagalong:# listLong = headA# listShort = headB# else:# listLong = headB# listShort = headA# diff = -diff# # print(diff)# for i in range(diff):# listLong = listLong.next # # print(listLong.val, listShort.val)# while listLong != None and listShort != None and listLong.val != listShort.val:# listShort = listShort.next# listLong = listLong.next# return listLong # headA2 = ListNode(4)# headA1 = ListNode(3)# HeadA = ListNode(1)# headA1.next = headA2# HeadA.next = headA1# headB2 = ListNode(4)# headB1 = ListNode(3)# HeadB = ListNode(2)# headB1.next = headB2# HeadB.next = headB1 面试题54. 二叉搜索树的第k大节点 中序遍历, 从右往左的顺序就是从大往小 123456789101112131415161718192021class Solution &#123;public: int kthLargest(TreeNode* root, int k) &#123; help(root,k); return ans; &#125; void help(TreeNode* root,int k)&#123; if(root!=nullptr)&#123; help(root-&gt;right,k); visit(root,k); help(root-&gt;left,k); &#125; &#125; void visit(TreeNode* root,int k)&#123; th++; if(th==k) ans=root-&gt;val; &#125;private: int th=0; int ans=0;&#125;; 面试题57. 和为s的两个数字 12345678910111213class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: l = 0 r = len(nums) - 1 while l &lt; r: sums = nums[l] + nums[r] if sums &gt; target: r -= 1 elif sums &lt; target: l += 1 else:return nums[l], nums[r] return [] 面试题58 - I. 翻转单词顺序 12345678class Solution: def reverseWords(self, s: str) -&gt; str: res = s.split() return ' '.join(reversed(res)) def reverseWords(self, s: str) -&gt; str: res = s.split() return ' '.join(reversed(res)) 面试题58 - II. 左旋转字符串 123class Solution: def reverseLeftWords(self, s: str, n: int) -&gt; str: return s[n:] + s[:n] 面试题59 - I. 滑动窗口的最大值 12345678class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: ans = [] if not nums: return [] for i in range(len(nums) - k + 1): ans.append(max(nums[i: i + k])) return ans 面试题59 - II. 队列的最大值 1234567891011121314151617181920212223242526from queue import deque, Queueclass MaxQueue: def __init__(self): self.queue = Queue() self.deque = deque() def max_value(self) -&gt; int: return self.deque[0] if self.deque else -1 def push_back(self, value: int) -&gt; None: while self.deque and value &gt; self.deque[-1]: self.deque.pop() self.deque.append(value) self.queue.put(value) def pop_front(self) -&gt; int: if not self.deque: return -1 ans = self.queue.get() if ans == self.deque[0]: self.deque.popleft() return ans 面试题60. n个骰子的点数-dp 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;double&gt; twoSum(int n) &#123; int dp[15][70]; memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= 6; i ++) &#123; dp[1][i] = 1; &#125; for (int i = 2; i &lt;= n; i ++) &#123; for (int j = i; j &lt;= 6*i; j ++) &#123; for (int cur = 1; cur &lt;= 6; cur ++) &#123; if (j - cur &lt;= 0) &#123; break; &#125; dp[i][j] += dp[i-1][j-cur]; &#125; &#125; &#125; int all = pow(6, n); vector&lt;double&gt; ret; for (int i = n; i &lt;= 6 * n; i ++) &#123; ret.push_back(dp[n][i] * 1.0 / all); &#125; return ret; &#125;&#125;; 面试题61. 扑克牌中的顺子 123456789101112131415161718192021class Solution: def isStraight(self, nums: List[int]) -&gt; bool: if not nums: return False sort_list = sorted(nums) anything = 0 # if sort_list[-1] - sort_list[0] == 4: gap = 0 for index in range(len(sort_list) - 1): now_val = sort_list[index] next_val = sort_list[index+1] # print(now_val, next_val) if now_val == 0: anything += 1 elif now_val &gt; 0: # 出现对子 if now_val == next_val: return False else: gap += next_val - now_val -1 # print(gap, anything) if gap &gt; anything: return False else: return True 面试题62. 圆圈中最后剩下的数字 123456789def f(n, m): if n == 0: return 0 x = f(n - 1, m) return (m + x) % nclass Solution: def lastRemaining(self, n: int, m: int) -&gt; int: return f(n, m) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# # Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = None# def getListLength(head):# if head == None:# return -1# ans = 0# while head != None:# ans += 1# head = head.next# return ans# def getIntersectionNode(headA: ListNode, headB: ListNode) -&gt; ListNode:# # print(headA, headB)# lena = getListLength(headA)# lenb = getListLength(headB)# print(lena, lenb)# diff = lena - lenb # if diff&gt;0:# flagalong = True# else:# flagalong = False# if flagalong:# listLong = headA# listShort = headB# else:# listLong = headB# listShort = headA# diff = -diff# # print(diff)# for i in range(diff):# listLong = listLong.next # # print(listLong.val, listShort.val)# while listLong != None and listShort != None and listLong.val != listShort.val:# listShort = listShort.next# listLong = listLong.next # return listLong # headA2 = ListNode(4)# headA1 = ListNode(3)# HeadA = ListNode(1)# headA1.next = headA2# HeadA.next = headA1# headB2 = ListNode(4)# headB1 = ListNode(3)# HeadB = ListNode(2)# headB1.next = headB2# HeadB.next = headB1 最长公共前缀 12345678910111213141516171819class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if len(strs) == 0: return '' if len(strs) == 1: return strs[0] strs = sorted(strs) idx = 0 minlen = min(len(strs[0]), len(strs[-1])) print( strs[0], strs[-1]) while idx &lt; minlen: if strs[0][idx] != strs[-1][idx]: return strs[0][:idx] idx += 1 return len(strs[0]) if len(strs[0]) &lt; len(strs[-1]) else len(strs[-1]) # s = Solution()print(s.longestCommonPrefix(['abcd', 'abdd', 'aad'])) 模拟队列 腾讯笔试题第一题，第四题为“两个栈模拟队列” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * @Author: Mrli * @Date: 2020-04-26 19:58:20 * @LastEditTime: 2020-04-27 22:58:50 * @Description: */// #include &lt;bits/stdc++.h&gt; //万能头文件#include &lt;iostream&gt;using namespace std; //命名空间const int MAXN = 1005;int arr[MAXN];int main() &#123; ios::sync_with_stdio(false); //取消输入输出流等待同步 int T; cin &gt;&gt;T; while(T--)&#123; int n; // n个操作 cin &gt;&gt;n; fill(arr, arr+MAXN, 0); int di = 0; int start = di; int p = di; // 栈底为-1 尾指针 for(int i = 0; i &lt; n; i ++)&#123; string operate; cin &gt;&gt; operate; // cout &lt;&lt; \"p:\" &lt;&lt; p &lt;&lt; start &lt;&lt; endl; if (operate == \"PUSH\") &#123; int num; cin &gt;&gt; num; arr[p++] = num; &#125;else if (operate == \"TOP\")&#123; if ( p == start) cout &lt;&lt; -1 &lt;&lt;endl; else cout &lt;&lt; arr[start] &lt;&lt;endl; &#125;else if (operate == \"POP\")&#123; if (p == start) cout &lt;&lt; -1 &lt;&lt;endl; else start++; &#125;else if (operate == \"SIZE\")&#123; cout &lt;&lt; p - start &lt;&lt; endl; &#125;else if (operate == \"CLEAR\")&#123; p = di; start = di; &#125; &#125; &#125; return 0;&#125;// 2// 7// PUSH 1// PUSH 2// TOP// POP// TOP// POP// POP// 5// PUSH 1// PUSH 2// SIZE// POP// SIZE 记一下二维vector的初始化 1234567vector&lt; vector&lt;int&gt; &gt; v(3, vector&lt;int&gt;(5,4));for(int i = 0; i &lt; v.size() ; i ++)&#123; for(int j = 0 ; j &lt; v[0].size(); j++)&#123; cout &lt;&lt; v[i][j] ; &#125; cout &lt;&lt; endl; &#125; 和通过数组来初始化 12int arr[] = &#123;1,6,3,2,5&#125;;vector&lt;int&gt; ans(arr, arr + sizeof(arr)); 华为2016年秋招题： A: 123456789101112131415161718while True: try: # try一定要最后加， 不然不好debug n, m = map(int, input().split()) grades = list(map(int, input().split())) for i in range(m): opt, (ids), (val) = input().strip().split() ids = int(ids) val = int(val) if opt == 'U': grades[ids-1] = val elif opt == 'Q': start, end = sorted([ids, val]) print(max( grades[start-1: end])) except: break# print(\"a\" &lt; \"b\" , \"3\" &lt; \"4\")# print('a' &lt; 'b' , '3' &lt; '4')# print('A' &lt; 'b' , 'A' &lt; '2') B[编程题]简单错误记录 123456789101112131415161718192021222324252627282930313233343536'''@Author: Mrli@Date: 2020-04-28 21:47:46@LastEditTime: 2020-04-28 22:22:20@Description: '''import collections# import sysrec_dict = collections.OrderedDict()# 另一种输入方式# for line in sys.stdin:# ele = line.split('\\\\')[-1].strip('\\n')# if ele not in lst:# lst.append(ele)# if ele in dct:# dct[ele] = dct[ele] + 1# else:# dct[ele] = 1while True: try: ins = input().strip() path = ins.split('\\\\')[-1] if path not in rec_dict: rec_dict[path] = 1 else: rec_dict[path] += 1 except EOFError: break# print(rec_dict)sort_res = sorted(rec_dict.items(), key = lambda d: d[1], reverse=True)# print(rec_dict)for k, v in sort_res[:8]: path, linenum = k.split() print(path[-16:], linenum, v) Tips: 两种输入方式的推出都为：ctrl + z EOF是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。资料源通常称为档案或串流。 而在不同系统的EOF所代表的值是不一样的，在Visual Studio 2017下为ctrl+c，windows下为ctrl+z，linux/unix下为ctrl+c或ctrl+d； 运用这个小技巧可以在调试的时候手动结束，很方便。 两路合并算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980void merge(int *arr, int l, int mid, int r)&#123; int begin1, begin2; begin1 = l; begin2 = mid+1; int index; // 新数组添加元素的索引值 // int *newarr = (int *)malloc((r-l+1)*sizeof(int)); int *newarr = new int[r-l+1]; for(index = 0; begin1 &lt;= mid &amp;&amp; begin2 &lt;= r; )&#123; if ( arr[begin1] &lt; arr[begin2] )&#123; newarr[index++] = arr[begin1++]; &#125; else&#123; newarr[index++] = arr[begin2++]; &#125; &#125; cout &lt;&lt;\"lmr: \" &lt;&lt; l &lt;&lt;\" \" &lt;&lt;mid &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; // cout &lt;&lt; \"res:\" &lt;&lt; (begin1 &lt;= mid) &lt;&lt; (begin2 &lt;= r) &lt;&lt;endl; // while (begin1 &lt;= mid)&#123; // newarr[index++] = arr[begin1++]; // &#125; // while(begin2 &lt;= r)&#123; // newarr[index++] = arr[begin2++]; // &#125; if (begin1 &lt;= mid)&#123; newarr[index++] = arr[begin1++]; &#125; else&#123; newarr[index++] = arr[begin2++]; &#125; int start = l; // arr开始更新的地方 int k = 0; // 新数组 // while( start &lt;= r)&#123; // 将新数组全部拷贝进 arr[l] -&gt; arr[r] // arr[start++] = newarr[k++]; //copy排好序的数。 // &#125; for(int i = l; i &lt;= r; i++)&#123; cout &lt;&lt; newarr[k]; arr[i] = newarr[k++]; &#125;&#125;void mergesort(int *arr, int l, int r)&#123; if (l &lt; r)&#123; int mid = l + ((r-l) &gt;&gt;1); // ▲位运算一定要加括号 // int mid = (l+r)/2; mergesort(arr, l, mid); mergesort(arr, mid+1, r); merge(arr, l, mid, r); cout &lt;&lt;\"arr: \" &lt;&lt; l &lt;&lt;\" \" &lt;&lt;mid &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; &#125;&#125; void mergeSort(int* arr, int s, int t) &#123; if (s &lt; t) &#123; int m = (s + t) / 2; mergeSort(arr, s, m); mergeSort(arr, m + 1, t); merge(arr, s, m, t); &#125; &#125;int main()&#123; // srand( (unsigned)time( NULL ) ); // Random(N); int a[N] = &#123;3,2,5,4,1&#125;; for(int i = 0 ; i &lt; N; i++) cout &lt;&lt; a[i] &lt;&lt;\" \"; // // mergeSort(a, 0, N-1);// 改 mergesort(a, 0, N-1); cout &lt;&lt; \"after sort:\" &lt;&lt;endl; for(int i = 0 ; i &lt; N; i++) cout &lt;&lt; a[i] &lt;&lt;\" \"; // for(int i= 0; i &lt; 10 ;i ++)&#123; // for( int j = 0; j &lt; 5; j ++)&#123; // cout &lt;&lt; ( i + j)/ 2 &lt;&lt;\" \" &lt;&lt; (i + (j-2)) // &#125; // &#125; return 0;&#125; 快排 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;void quickSort(int a[], int m,int n);int partion(int a[], int m, int n);int main()&#123; int a[] = &#123; 6,1,2,7,9,3,4,5,10,8 &#125;; int m = 0; int n = (sizeof(a) / 4)-1; quickSort(a, m,n); for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125;&#125;void quickSort(int a[], int m, int n)&#123; if (m &lt; n) &#123; int q = partion(a, m, n); quickSort(a, m, q ); quickSort(a, q + 1, n); &#125;&#125;int partion(int a[], int m, int n)&#123; int key=m; int j= n,i=m; int temp1, temp2; while (i != j) &#123; while (a[j] &gt; a[key] &amp;&amp; i &lt; j) &#123; --j; &#125; while ((a[i] &lt; a[key]) &amp;&amp; (i &lt; j)) &#123; ++i; &#125;if (i &lt; j) &#123; temp1 = a[j]; a[j] = a[i]; a[i] = temp1; &#125; &#125; temp2 = a[key]; a[key] = a[i]; a[i] = temp2; return i;&#125; 123456789101112131415void quickSort(int arr[], int l, int r)&#123; if ( l &gt;= r) return; int i = l, j = r; int key = l + r &gt;&gt; 1; int x = arr[key]; while ( i &lt; j)&#123; while (arr[j] &gt; x ) j --; while (arr[i] &lt; x) i++; if (i &lt; j)&#123; swap(arr, i, j); &#125; quickSort(arr, l, j); quickSort(arr, j+1, r); &#125;&#125; 上述两种有重复元素就爬了 12345678910111213void quick_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) &#123; do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j), quick_sort(q, j + 1, r);&#125; 记录下C++的split写法： 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; getline(cin, s); // cout &lt;&lt; s &lt;&lt; endl; int dindex = s.find('-'); cout &lt;&lt; dindex&lt;&lt; endl; string a = s.substr(0, dindex); string b = s.substr(dindex+1); cout &lt;&lt; a &lt;&lt; \"*\" &lt;&lt; b; cout &lt;&lt; set return 0;&#125; C/C++中substr函数的应用(简单讲解) C++如何保留两位有效数字！！！！ 123456def removeElement(nums, val): # print(nums) nums = list(map(str, nums)) st = &apos;&apos;.join(nums) st = st.replace(str(val), &apos;&apos;) return list(map(int, st)) 1234567891011121314class Solution: @staticmethod def firstUniqChar( s: str) -&gt; str: hashtable = OrderedDict() ans = '' for i in s: hashtable[i] = hashtable.setdefault(i, 0) + 1 for k, v in hashtable.items(): if v == 1: return kres = Solution.firstUniqChar(\"abaccdeff\")print(res) Sum为m, 拆成n个数, 有哪些情况?(非连续) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; ans;int idx;void printRes()&#123; for(auto &amp;i: ans)&#123; cout &lt;&lt; i &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;// way1void func(int val, int n)&#123; if (n == 1)&#123; ans.push_back(val); idx ++; cout &lt;&lt; \"Case:\" &lt;&lt; idx &lt;&lt; endl; printRes(); cout &lt;&lt; \"==========\" &lt;&lt; endl; ans.pop_back(); return ; &#125; // 去重 int last; if ( ans.empty() ) last = 1; else last = ans.back(); for (int i = last; i &lt;= val/2 ; i++) &#123; ans.push_back(i); func(val-i, n-1); ans.pop_back(); &#125;&#125;// way2// void func(int val, int n, int start)&#123;// if (n == 1)&#123;// ans.push_back(val);// idx ++;// cout &lt;&lt; \"Case:\" &lt;&lt; idx &lt;&lt; endl;// printRes();// cout &lt;&lt; \"==========\" &lt;&lt; endl;// ans.pop_back();// return ;// &#125;// for (int i = start; i &lt;= val/2 ; i++) &#123;// ans.push_back(i);// func(val-i, n-1, i);// ans.pop_back();// &#125;// &#125;int main()&#123; // way1 func(20, 4); // way2 // func(20, 4, 1); return 0;&#125; Sum为m, 拆成n个数, 有哪些情况?(连续) 1234567891011121314151617181920212223public int subarraySum(int[] nums, int k) &#123; // hash // 记录合适的连续字符串数量 int count=0; // 记录前面数字相加之和 int pre=0; // map记录前几个数字之和为K出现相同和的次数为V HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); // 初始化 map.put(0,1); for (int i = 0; i &lt; nums.length; i++) &#123; pre+= nums[i]; // 如果前面数字之和加上这个数字正好等于K（存在一个数字加上nums[i]结果为K // 说明找到了 if (map.containsKey(pre-k))&#123; // 累计 count+=map.get(pre-k); &#125; // 计算新的和放入map map.put(pre,map.getOrDefault(pre,0)+1); &#125; return count; &#125;","categories":[],"tags":[]},{"title":"VsCode环境、配置Latex(texLive)","slug":"VsCode配置Latex(texLive)环境","date":"2020-03-23T07:04:53.000Z","updated":"2020-09-17T02:00:15.623Z","comments":true,"path":"2020/03/23/VsCode配置Latex(texLive)环境/","link":"","permalink":"https://nymrli.top/2020/03/23/VsCode配置Latex(texLive)环境/","excerpt":"","text":"写在前面: 除了配置VsCode以外， 我还配置了Sublime，一开始是不想用SumatraPDF，以为能省的。事实上，Vscode也确实提供了三种方法：在web browser、编辑器tab、外部PDF阅读器，共三种办法。个人感觉tab界面太小、浏览器查看毕竟还是没有PDF舒服，最后都体验下来还是选择了外部阅读器，而且SumatraPDF支持正向、反向搜索，挺香的。当然，还有种做法是把PDF编译出来以后，再用日常使用的阅读器打开PDF阅读也是可以的，我个人平时用福昕PDF阅读器会多一点 SumatraPDF阅读器是个非常轻量级的PDF阅读器，开源轻巧，免安装，共14.6MB。要想配套使用PDF阅读器，网上教程基本上推荐的都是SumatraPDF，应该是SumatraPDF在适配Latex上做的比较好。我试了试指定福昕失败了。 安装Texlive 上Texlive的官网， 有在线安装和DVD安装两种方式，我们选择后者。在http://mirrors.sjtug.sjtu.edu.cn/ctan/systems/texlive/Images/中下载texlive2019.iso的镜像，之后解压，选择install-tl-advanced.bat配置高级版(最好右键管理员身份运行)。 可以点击“Advanced”进入高级安装来修改安装位置、取消你不需要安装的宏包。其中TeXworks 前端就是它自带的编辑器，不需要的可以取消。语言我基本就只选了Chinese, Chinese/Janpanse/Korean, English 点击“Customize”来取消勾选不需要的宏包。 很多宏包和功能我个人并不需要，因此我在这里取消勾选，大家可以根据需要勾选自己需要的功能，如果嫌麻烦全部安装也可以，并不消耗多少空间。 设置完安装路径等选项之后点击“安装”，之后静坐 20 分钟等待安装完成。 安装VsCode 略, 基本安装就行了。用了很久的Sublime， 突然间想换个新的了， 而且VsCode确实也非常好看。 安装VsCode中Latex插件—— LaTeX Workshop 此时导入Latex工程，查看tex文件就可以看到关键字高亮了。 配置LaTeX Workshop 插件 菜单栏&quot;File-&gt;Preference-&gt;Settings&quot;然后选择右上角三个按钮中最左边的(Open settings(JSON)), 然后将括号里的内容填充到大括号里就行了，下面已经是我JSON配置的安装文件，可复制直接替换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&#123; \"latex-workshop.showContextMenu\":true, //右键菜单 \"latex-workshop.latex.tools\": [ &#123; \"name\": \"latexmk\", \"command\": \"latexmk\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"-pdf\", \"%DOC%\" ] &#125;, &#123; \"name\": \"xelatex\", \"command\": \"xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] &#125;, &#123; \"name\": \"pdflatex\", \"command\": \"pdflatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] &#125;, &#123; \"name\": \"bibtex\", \"command\": \"bibtex\", \"args\": [ \"%DOCFILE%\" ] &#125; ],\"latex-workshop.latex.recipes\": [ &#123; \"name\": \"xelatex\", \"tools\": [ \"xelatex\" ] &#125;, &#123; \"name\": \"latexmk\", \"tools\": [ \"latexmk\" ] &#125;, &#123; \"name\": \"pdflatex -&gt; bibtex -&gt; pdflatex*2\", \"tools\": [ \"pdflatex\", \"bibtex\", \"pdflatex\", \"pdflatex\" ] &#125; ],\"latex-workshop.view.pdf.viewer\": \"browser\", //\"latex-workshop.view.pdf.viewer\": \"external\",//\"latex-workshop.view.pdf.ref.viewer\":\"external\",//\"latex-workshop.view.pdf.external.viewer.command\": \"E:\\\\a常用工具\\\\SumatraPDF-3.2-64\\\\SumatraPDF-3.2-64.exe\", // 注意修改路径//\"latex-workshop.view.pdf.external.synctex\": &#123;// \"command\": \"E:\\\\a常用工具\\\\SumatraPDF-3.2-64\\\\SumatraPDF-3.2-64.exe\",// \"args\": [// \"-forward-search\", // \"%TEX%\",// \"%LINE%\",// \"%PDF%\"// ]//&#125;,\"latex-workshop.latex.clean.fileTypes\": [ \"*.aux\", \"*.bbl\", \"*.blg\", \"*.idx\", \"*.ind\", \"*.lof\", \"*.lot\", \"*.out\", \"*.toc\", \"*.acn\", \"*.acr\", \"*.alg\", \"*.glg\", \"*.glo\", \"*.gls\", \"*.ist\", \"*.fls\", \"*.log\", \"*.fdb_latexmk\" ]&#125; ▲保存后，一定要重启VsCode，不然无法生效。我当时就是直接去编译了，报了Recipe terminated with fatal error: spawn pdflatex ENOENT.的错误提示。 其中需要指出的是：&quot;latex-workshop.view.pdf.viewer&quot;: &quot;browser&quot;,设置的是默认阅览PDF的方式，一共有3种：web browser、编辑器tab、外部PDF阅读器。我注释掉的是设置SumatraPDF的方式。这个设置好后，再在Vscode中选择View Latex PDF时就会根据这个配置打开默认阅读PDF的方式，当然也可以点开View Latex PDF的下拉选项，进行指定方式的查阅。 正向搜索 查看code中选中的内容在PDF中什么位置。 选择外部阅读器后，可以通过加入下列实现正向搜索功能。 123456789\"latex-workshop.view.pdf.external.synctex\": &#123; \"command\": \"E:/Programs/SumatraPDF/SumatraPDF.exe\", // 修改SumatraPDF路径 \"args\": [ \"-forward-search\", \"%TEX%\", \"%LINE%\", \"%PDF%\" ]&#125;, 正向搜索的使用：将光标移动到TeX文件的正文。ctrl+alt+x，找到&quot;navigator,select and edit&quot;，点击第一项syncTeX from cursor(或右键选择，或快捷键ctrl+alt+j)，会切换到PDF文件的相应位置。——设置“Latex右键菜单”后也可以右键选择syncTeX from cursor 反向搜索 查看PDF中选中的内容在code中什么位置。 选择&quot;设置-&gt;选项&quot; 将下列内容填入箭头所指位置，路径修改下即可（为一行内容） 1&quot;C:\\Users\\Marvey\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe&quot; &quot;C:\\Users\\Marvey\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\out\\cli.js&quot; -g &quot;%f&quot;:&quot;%l&quot; 感谢 @Macrofuns指出，如果不加双引号，在文件路径有空格的情况下会导致无法反向搜索） 其他设置 LaTeX Workshop 默认保存的时候自动编译，如果不喜欢这个设置，可以添加以下代码进入设置区： 123\"latex-workshop.showContextMenu\":true, //右键菜单 \"latex-workshop.intellisense.package.enabled\": true, //根据加载的包，自动完成命令或包 \"latex-workshop.latex.autoBuild.run\": \"never\", //禁止保存文件时自动build 借鉴From： 使用VSCode编写LaTeX(latex+vscode+SumatraPDF) 最后推荐两个配置视频： 使用 Sublime Text +TexLive 搭建 LaTeX 编写环境——用sublime看这个视频基本就够了 为VSCode配置LaTex编译环境(TeXLive) VsCode其他配置 不准备单独再开一篇文章介绍我怎么配置的了， 就在此篇文章里略微提及下把。 插件 Code run 能够让你的IDE基本上运行大多数代码，只好安装编程语言时Path设置正确，默认配置就可以直接运行。 默认编译运行的快捷键是ctrl + Alt + N，由于之前用的都是Sublime， 里面编译是Ctrl+B， 因此用习惯后有点不想改就直接修改掉了。方法为：Ctrl + Shift + P打开输入框，输入Keyboard Shortcuts, 就会弹出目前所有的快捷键，然后再将原来的Ctrl +B的快捷键取消(直接输入Ctrl +B就能找到目前谁的快捷键是Ctrl +B)，然后再输入Code run，将其快捷键设置为Ctrl +B即可。 在运行Python代码的过程中，一直报错: The environment variable 'Path' seems to have some paths containing the '&quot;' character. The existence of such a character is known to have caused the Python extension to not load. If the extension fails to load please modify your paths to remove this '&quot;' character.后来在找到解决方案😗* 是因为你在添加其他环境变量时，加了; 分号—&gt;删掉就好了** open in browser 编写html页面调试时比较方便 koroFileHeader 自动生成头部注释和函数注释的，测试了一下，除了html以外基本上都能用，挺好使的。 如果不满意默认配置， 可以自己再稍微调一调，展示下我的设置： 12345678910111213141516171819202122232425262728&#123; /** * @description: Latex相关配置 */ \"latex-workshop.showContextMenu\":true, //右键菜单 // ...Latex的太多了, 就不一一展示了. /** * @description: koroFileHeader相关配置 * ctrl+alt+i,添加文件头注释, ctrl+alt+t,添加函数注释 * \"Do not edit\"的内容会自动添加 */ \"fileheader.customMade\": &#123; //文件头部注释 \"Author\": \"Mrli\", \"Date\": \"Do not edit\", // 文件创建事件 \"LastEditTime\": \"Do not edit\", // 文件最后编辑时间 \"Description\": \"\", &#125;, \"fileheader.cursorMode\": &#123; // 函数注释 \"Author\": \"Mrli\", \"Date\": \"Do not edit\", // 当前时间, 函数的开始编写、完成编写时间 \"Description\": \"\", \"param\": \"\", \"return\": \"\", &#125;, \"editor.fontFamily\": \"Monaco, 'Courier New', monospace\"&#125;// 好用插件推荐 https://blog.csdn.net/qq_41139830/article/details/85221330 用户对插件的自定义配置基本上都是写在这个settings.json下。当然，可以对某个项目单独设置配置，即会在项目文件夹下生成.vscode文件夹，里面会有个settings.json来进行配置. Bracket Pair Colorizer 编写JS代码时我是感觉真的好用，JS里大括号和括号有时真的很难记得匹配次序。 Anaconda Extension Pack 就图他的关键字提醒补全。 插件比较大， 安装了挺久的，好像还自带一个Python Extension插件。 Autopep8 测试自动规范代码(Alt + Shift + F)时，提示要安装Autopep8，那就安装咯。但这个应该只能算Python的插件，python.exe -m pip install -U autopep8 --user Path Autocomplete 有时候程序需要读取文件，自己手动去复制文件路径还是比较麻烦的，不过有了这个插件就方便多了，它能自动感知当前目录下所有的文件，只需要你自己选择就好了。 windows opacity 设置窗口透明度的，一开始以为挺好用， 用了后发现自己还想不太喜欢， 真的是太透明了，可以设置0-255， 240我用着差不多。（0的话会消失的） 还有些可以网上再找找，推个挺不错的博客： https://blog.csdn.net/hnshhshjq/article/details/80140401 ★ https://mp.weixin.qq.com/s?__biz=MzAxOTcxNTIwNQ==&amp;mid=2457918435&amp;idx=2&amp;sn=78a94468973f701e674246f1d520434b&amp;chksm=8cb6be09bbc1371fc6582cc7eda6791278165c6527e385f49ee56ceea94e9ca2e3f45efce368&amp;scene=21#wechat_redirect 用户自定义快捷代码段： File -&gt; Preferences -&gt; User snippets， 附一段我的C++设置 -&gt; cpp.sjon 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected. // Example: // \"Print to console\": &#123; // \"prefix\": \"log\", // \"body\": [ // \"console.log('$1');\", // \"$2\" // ], // \"description\": \"Log output to console\" // &#125; \"Print out fori\": &#123; \"prefix\": \"fori\", \"body\": [ \"for (int i = 0; i &lt; $1; i++) &#123;\", \" $0\", \"&#125;\" ], \"description\": \"Output Loop 'fori'\" &#125;, \"Print out forj\": &#123; \"prefix\": \"forj\", \"body\": [ \"for (int j = 0; j &lt; $1; j++) &#123;\", \" $0\", \"&#125;\" ], \"description\": \"Output Loop 'forj'\" &#125;, \"Common template\": &#123; \"prefix\": \"qqq\", \"body\": [ \"#include &lt;bits/stdc++.h&gt;\", \"using namespace std;\", \"const int INF = 0x3f3f3f3f;\", \"int n;\", \"\", \"\", \"int main()&#123;\", \" ios::sync_with_stdio(false);\", \" cin.tie(0);\", \" \", \" $0\", \" \", \" return 0;\", \"&#125;\" ] &#125;&#125; 快捷键: https://www.cnblogs.com/schut/p/10461840.html","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"算法笔记Codeup题解","slug":"算法笔记Codeup题解","date":"2020-03-04T06:21:49.000Z","updated":"2020-03-04T14:22:59.262Z","comments":true,"path":"2020/03/04/算法笔记Codeup题解/","link":"","permalink":"https://nymrli.top/2020/03/04/算法笔记Codeup题解/","excerpt":"","text":"100000612 - 《算法笔记》9.3小节——数据结构专题(2)-&gt;树的遍历 问题 A: 树查找 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e3 + 5;int arr[MAXN];typedef long long ll;ll fast_pow(int d, int base)&#123; int n = d; ll res = 1; while(n&gt;0)&#123; if( n &amp; 1) res = res*base; base = base * base; n &gt;&gt;= 1; &#125; return res;&#125;int main(int argc, char const *argv[])&#123; int n, d; while(cin &gt;&gt;n &amp;&amp; n)&#123; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; arr[i]; cin &gt;&gt;d; if ( n &lt; fast_pow(d, 2) )&#123; // d层没有节点 cout &lt;&lt; \"EMPTY\"&lt;&lt;endl; &#125;else&#123; int beginn = fast_pow(d-1, 2); int endn = fast_pow(d, 2); cout &lt;&lt; beginn; for (int i = beginn+ 1; i &lt; n &amp;&amp; i&lt; endn; ++i) cout&lt;&lt; \" \" &lt;&lt; i ; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 问题 B: 树的高度 题目要求我们练习树的静态写法。但其实这道题直接计算每个节点的高度就行了。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e3 + 5;int n;struct Node&#123; int height; std::vector&lt;int&gt; child;&#125;Nodearr[MAXN];int getHeight()&#123; int m = -1; for (int i = 1; i &lt;= n; ++i)&#123; if(Nodearr[i].height &gt; m) m = Nodearr[i].height; &#125; return m;&#125;int main(int argc, char const *argv[])&#123; scanf(\"%d\", &amp;n); int a, b; Nodearr[1].height = 1; while(scanf(\"%d %d\",&amp;a,&amp;b)!=EOF)&#123; // Nodearr[a].child.push_back(b); Nodearr[b].height = Nodearr[a].height +1; &#125; cout &lt;&lt; getHeight() &lt;&lt; endl; return 0;&#125; 正规写法：先构建树， 然后再层次遍历计算高度 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int m=10010;struct node&#123; int layer; vector&lt;int&gt; child;&#125;tree[m];int MaxHigh;// 树的静态写法的层次遍历void BFS(int root)&#123; MaxHigh=0; queue&lt;int&gt; q; tree[root].layer =1; q.push(root); if(tree[root].layer&gt;MaxHigh) MaxHigh=tree[root].layer; while(!q.empty())&#123; int front=q.front() ; q.pop(); for(int i=0;i&lt;tree[front].child.size();i++)&#123; int child=tree[front].child[i]; tree[child].layer =tree[front].layer +1; q.push(child); if(tree[child].layer&gt;MaxHigh) MaxHigh=tree[child].layer; &#125; &#125;&#125;int main()&#123; int n,a,b; while(scanf(\"%d\",&amp;n)!=EOF)&#123; while(scanf(\"%d %d\",&amp;a,&amp;b)!=EOF)&#123; tree[a].child.push_back(b); &#125; BFS(1); printf(\"%d\\n\",MaxHigh); &#125; return 0;&#125; 100000613 - 《算法笔记》9.4小节——数据结构专题(2)-&gt;二叉查找树（BST） 问题 A: 二叉排序树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e3 + 5;int n;int data[MAXN];struct Node&#123; int v; Node *lc, *rc;&#125;;Node* newNode(int x)&#123; Node *now = new Node; now-&gt;v = x; now-&gt;lc = now-&gt;rc = NULL; return now;&#125;void insert(Node* &amp;root, int x)&#123; if(root == NULL)&#123; root = newNode(x); &#125; if(root-&gt;v == x) return; // 已存在 else if (x &lt; root-&gt;v ) insert(root-&gt;lc, x); else if (x &gt; root-&gt;v ) insert(root-&gt;rc, x);&#125;Node *createTree()&#123; Node *root = NULL; // ▲注意此处是NULL， 而不是new Node for (int i = 0; i &lt; n; ++i) insert(root, data[i]); return root;&#125;void preOrder(Node *root)&#123; if(root == NULL ) return; cout &lt;&lt; root-&gt;v &lt;&lt; \" \"; preOrder(root-&gt;lc); preOrder(root-&gt;rc);&#125;void inOrder(Node *root)&#123; if(root == NULL ) return; inOrder(root-&gt;lc); cout &lt;&lt; root-&gt;v &lt;&lt; \" \"; inOrder(root-&gt;rc);&#125;void postOrder(Node *root)&#123; if(root == NULL ) return; postOrder(root-&gt;lc); postOrder(root-&gt;rc); cout &lt;&lt; root-&gt;v &lt;&lt; \" \";&#125;int main(int argc, char const *argv[])&#123; while(cin &gt;&gt; n)&#123; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; data[i]; Node* root = createTree(); preOrder(root); cout &lt;&lt; endl; inOrder(root); cout &lt;&lt; endl; postOrder(root); cout &lt;&lt; endl; &#125; return 0;&#125; 问题 B: 二叉搜索树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e3 + 5;int n;int data[MAXN];struct Node&#123; char v; Node *lc, *rc;&#125;;Node* newNode(char x)&#123; Node *now = new Node; now-&gt;v = x; now-&gt;lc = now-&gt;rc = NULL; return now;&#125;void insert(Node* &amp;root, char x)&#123; if (root == NULL)&#123; root = newNode(x); return ; &#125; if (x == root-&gt;v ) return; else if (x &lt; root-&gt;v ) insert(root-&gt;lc, x); else if (x &gt; root-&gt;v ) insert(root-&gt;rc, x);&#125;Node* createTree(string s)&#123; Node *root = NULL; for (int i = 0; i &lt; s.size(); ++i)&#123; insert(root, s[i]); &#125; return root;&#125;void preOrder(Node *root, string &amp;s)&#123; if(root == NULL ) return; s += root-&gt;v; preOrder(root-&gt;lc, s); preOrder(root-&gt;rc, s);&#125;void inOrder(Node *root, string &amp;s)&#123; if(root == NULL ) return; inOrder(root-&gt;lc, s); s += root-&gt;v; inOrder(root-&gt;rc, s);&#125;void postOrder(Node *root, string &amp;s)&#123; if(root == NULL ) return; postOrder(root-&gt;lc, s); postOrder(root-&gt;rc, s); s += root-&gt;v;&#125;int main(int argc, char const *argv[])&#123; int n; while( cin &gt;&gt; n &amp;&amp; n)&#123; string target; cin &gt;&gt; target; string preans, postans; Node *ans = createTree(target); preOrder(ans, preans); postOrder(ans, postans); // inOrder(root, in); // 由于中序遍历的结果就是排序的结果, 因此都一样 for (int i = 0; i &lt; n; ++i)&#123; string s; cin &gt;&gt; s; string in, pre, post; Node *root = createTree(s); preOrder(root, pre); if (pre == preans)&#123; postOrder(root, post); if (post == postans) cout &lt;&lt; \"YES\" &lt;&lt;endl; else cout &lt;&lt; \"NO\" &lt;&lt;endl; &#125;else cout &lt;&lt; \"NO\" &lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"}]},{"title":"PAT冲冲冲——乙级","slug":"PAT冲冲冲——乙级","date":"2020-02-02T08:26:41.000Z","updated":"2020-09-05T04:45:09.548Z","comments":true,"path":"2020/02/02/PAT冲冲冲——乙级/","link":"","permalink":"https://nymrli.top/2020/02/02/PAT冲冲冲——乙级/","excerpt":"","text":"PAT冲冲冲——乙级 PAT甲级练习题 ——PAT (Advanced Level) Practice PAT甲级(Advanced Level)真题 柳婼 の blog经验 saquarius’s blog PAT甲级题目及分类总结 pat甲级题解目录 ▲报名费256，可以刷牛客网的题来获得-50的优惠券，该练习场下的所有题目只要通过都算 乙级练习题 NowCoder数列 没想到第二题就是考了个数据范围，由于0≤n≤1000000，所以F(n)必然比long long大，而判断3的倍数可表示为===&gt; F(n) % 3 —&gt; (F(n-1)%3 + F(n-2)%3) % 3 求余运算性质：a = b+c --&gt; a%d = (b%d+c%d) % d 12345678910111213141516171819#include&lt;stdio.h&gt;long long f[1000000+5];int main()&#123; int n,i; f[0]=7; f[1]=11; for(i=2;i&lt;=1000000;i++)&#123; f[i]=(f[i-1]%3+f[i-2]%3)%3; &#125; while(scanf(\"%d\",&amp;n)!=EOF)&#123; if(f[n]!=0) printf(\"No\\n\"); else printf(\"Yes\\n\"); &#125; return 0;&#125; 养兔子 非常经典的斐波那契数列题 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 90+5ll arr[N]; int main()&#123; int n; arr[1] = 1; arr[2] = 2; for(int i = 3;i&lt;=N;i++)&#123; arr[i] = arr[i-1] + arr[i-2]; &#125; while( cin &gt;&gt; n)&#123; cout &lt;&lt; arr[n] &lt;&lt;endl; &#125; return 0;&#125; 客似云来 斐波那契数列的拓展题，将其中某个区间的值累加输出（需要特判是否为某个点） 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 80+5ll arr[N]; int main()&#123; int from, to; arr[1] = 1; arr[2] = 1; for(int i = 3;i&lt;=N;i++)&#123; arr[i] = arr[i-1] + arr[i-2]; &#125; while( cin &gt;&gt; from &gt;&gt; to)&#123; ll tmp = 0 ; // 注意需要特判是否相等 if (from == to) tmp = arr[from]; else&#123; for(int i=from; i&lt;= to;i++)&#123; tmp += arr[i] ; &#125; &#125; cout &lt;&lt; tmp &lt;&lt;endl; &#125; return 0;&#125; 斐波那契凤尾 一遍还挺难过的，有不少的坑点 1.虽然也是斐波那契数列，但是一定要注意前两项的取值 2.输出末尾的6位，那么就是%1e6，但是如果有前置0，需要补零，我是使用iomanip中的setw和setfill实现的 3.怎么判断超过6位：找出超过6位的n应该算比较简单的方法了吧 123456789101112131415161718192021222324252627282930313233#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100000 + 5ll arr[N]; int main()&#123; int n; arr[1] = 1; arr[2] = 2; for(int i = 3;i&lt;=N;i++)&#123; /* 用来找到超过1e6的n arr[i] = (arr[i-1] + arr[i-2]); if (arr[i] &gt; 1000000)&#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; */ arr[i] = (arr[i-1]%1000000 + arr[i-2]%1000000)%1000000; &#125; while( cin &gt;&gt; n)&#123; if (n&gt;= 30)&#123; cout &lt;&lt; setw(6)&lt;&lt;setfill('0') &lt;&lt; arr[n] &lt;&lt;endl; &#125;else&#123; cout &lt;&lt; arr[n] &lt;&lt; endl; &#125; &#125; return 0;&#125; Po个C的代码，使用printf的格式化输出的特性 123456789101112131415161718#include&lt;stdio.h&gt; int a[100005];int main()&#123; int n; a[1]=1; a[2]=2; for(int i=3;i&lt;=100000;i++) a[i]=(a[i-1]+a[i-2])%1000000; while(scanf(\"%d\",&amp;n)!=EOF) &#123; if(n&gt;=30) printf(\"%06d\\n\",a[n]); else printf(\"%d\\n\",a[n]); &#125; return 0; &#125; 星际密码 说实话，一开始没看懂题，因为输入的n跟题目里提到的n不是同一个东西：矩阵X为[[1 1],[0 1]]，题目中的n是指多少次幂；而输入里的n是指有多少个密码，真正的n其实是第二行的输入Xi 那么分析下思路，Xi=1时1，Xi=2时2，Xi=3时==3 123456789101112131415161718192021222324252627282930#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100000 + 5ll arr[N]; void initFib()&#123; arr[1] = 1; arr[2] = 2; for(int i = 3;i&lt;=N;i++)&#123; arr[i] = (arr[i-1]%10000 + arr[i-2]%10000)%10000; &#125;&#125;int main()&#123; int n; int input[100+5]; initFib(); while( cin &gt;&gt; n)&#123; for (int i = 0; i &lt; n; ++i)&#123; int tmp; cin &gt;&gt; tmp; cout &lt;&lt; setw(4)&lt;&lt;setfill('0') &lt;&lt; arr[tmp] ; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 母牛的故事 变形的Fib，公式更新为f(n)=f(n−1)+f(n−3)f(n) = f(n-1) + f(n-3)f(n)=f(n−1)+f(n−3) 最主要的就是确定前几项，比较好的是样例都给出了2==&gt;2,4==&gt;4,5==&gt;6，这样就比较好确定每头小母牛从第四个年头开始，每年年初也生一头小母牛到底是什么意思了 1234567891011121314151617181920212223#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100000 + 5ll arr[N]; void initFib()&#123; arr[1] = 1; arr[2] = 2;arr[3]=3;arr[4]=4; for(int i = 5;i&lt;=N;i++)&#123; arr[i] = arr[i-1] + arr[i-3]; &#125;&#125;int main()&#123; int n; initFib(); while( cin &gt;&gt; n)&#123; cout &lt;&lt; arr[n]&lt;&lt;endl; &#125; return 0;&#125; 童年生活二三事 Fib数列的板子题，只不过需要理解一下 123456789101112131415161718192021222324#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 90 + 5ll arr[N]; void initFib()&#123; arr[1] = 1; arr[2] = 2; for(int i = 3;i&lt;=N;i++)&#123; arr[i] = arr[i-1] + arr[i-2]; &#125;&#125;int main()&#123; int n; initFib(); while( cin &gt;&gt; n)&#123; cout &lt;&lt; arr[n] &lt;&lt; endl; &#125; return 0;&#125; 蜜蜂寻路 如果固定起点为1，计算到某个位置的走法数的话，跟走阶梯其实是一种思路，就是f(n) = f(n-1) + f(n-2)，即第n个位置的走法数=第n-1位置走法数 + 第n-2位置走法数 1-&gt;2 1 2-&gt;3 1 3-&gt;4 1 1-&gt;3 2 2-&gt;4 2 3-&gt;5 2 1-&gt;4 3 2-&gt;5 3 3-&gt;6 3 1-&gt;5 5 2-&gt;6 5 3-&gt;7 5 1-&gt;6 8 2-&gt;7 8 3-&gt;8 8 可以发现其中的规律：走法数一直是Fib数列，而值为fib(Nto−Nfrom)fib(N_{to} - N_{from})fib(Nto​−Nfrom​) ▲但这题还有一个难点在于用例的范围(0 &lt; a &lt; b &lt; 231)，即b-a~=232-1，为int最大范围，会导致的问题有两个 fib数列通常使用数组来存储，但是无法开个2^32大小的数组 ==&gt;滚动数组、递推（不用数组） 输出的Fib(n)就远远超过long long了，因此要么模拟大数相加，那么另寻他法。 ==&gt;△还需要注意到的一点是,输出数据结果范围是 [0, 2^63)，那么意思是题目要求的输出其实是在long long 范围内的，那么就可以考虑截取输出了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;// ll credit = 9.2e18;开的足够大能过样例就行ll credit;/** * 幂计算 * @author mrli 2019-10-27 * @param n [less than 63] * @return [long long type] */ll pow(int n)&#123; ll ans = 1; for (int i = 0; i &lt; n; ++i) ans *= 2; return ans;&#125;ll Fib(int del)&#123; if (del == 1) return 1; else if(del == 2) return 2; else&#123; ll f1 = 1; ll f2=2; ll ans; for(int i = 3;i&lt;=del;i++)&#123; // ans = f1 + f2 ;也过了 ans = ( f1%(credit) + f2%(credit) )%credit; f1 = f2; f2 = ans; &#125; return ans; &#125;&#125;int main()&#123; int n; credit = pow(63)-1; cin &gt;&gt; n; while( n-- )&#123; int from, to; cin &gt;&gt; from &gt;&gt; to; ll ans; cout &lt;&lt; Fib(to-from) &lt;&lt; endl; &#125; return 0;&#125; 看了别人的题解后,发现想多了。题目的意思是得分点的输出值都在long long 范围内，而不是需要你把输出值压缩在long long范围内，果然去掉 %运算也过了。 123456789101112131415161718192021222324252627282930313233343536373839//蜜蜂寻路#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;using namespace std;#define ms(x, n) memset(x,n,sizeof(x));typedef long long LL;const LL maxn = 2147483648+5; LL dp[3]; //滚动数组int n, a, b;LL solve()&#123; ms(dp, 0); dp[0] = 1, dp[1] = 1; for(int i = 2; i &lt; b-a+1; i++) dp[i%3] = dp[0]+dp[1]+dp[2]-dp[i%3]; //即dp[i]=dp[i-1]+dp][i-2] LL ans = 0; for(int i = 0; i &lt; 3; i++) ans = max(dp[i], ans); return ans;&#125; int main()&#123; cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; solve() &lt;&lt; endl; //从1到4和从2到5答案是一样的 &#125; return 0;&#125; 分数运算 牛客网周赛做到过一次，感觉当时写的比现在的简单。难点在使用GCD进行约分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std; typedef long long ll; /** * 辗转相除法,求最大公约数 * @author mrli 2019-10-28 * @param a [description] * @param b [description] * @return [description] */int gcd(int a, int b)&#123; if (b==0) return a; return gcd(b,a%b);&#125; int main()&#123; int a1,a2,b1,b2; char op3; while( scanf(\"%d/%d %d/%d %c\", &amp;a1, &amp;a2, &amp;b1, &amp;b2, &amp;op3) != EOF)&#123; int fenmu; int fenzi; if (op3 == '+')&#123; fenmu = a2*b2; fenzi = a1*b2+a2*b1; &#125; else if (op3 == '-')&#123; fenmu = a2*b2; fenzi = a1*b2-a2*b1; &#125; else if (op3 == '*')&#123; fenmu = a2*b2; fenzi = a1*b1; &#125; else&#123; //if (op3 == '*')&#123; fenmu = a2*b1; fenzi = a1*b2; &#125; // 找出最大公因子,约分 int common = gcd(fenmu,fenzi); int res_zi = fenzi/common; int res_mu = fenmu/common; if ( res_mu * res_zi &gt; 0) cout &lt;&lt; abs(fenzi/common) &lt;&lt; '/' &lt;&lt; abs(fenmu/common) &lt;&lt; endl; else cout &lt;&lt; '-' &lt;&lt;abs(fenzi/common) &lt;&lt; '/' &lt;&lt; abs(fenmu/common) &lt;&lt; endl; &#125; return 0;&#125; 分解因数 使用小学的短除法，我们很清楚的知道，要想求出它的每一个质因数，我们需要用质数去试除。90能被2整除，那就拿商继续除以2，除不尽就换3，一直到除到质数为止。基础代码框架类似判断质数，只是被判断的数字在过程中不断被除，最终循环结束的时候，那个被处理过的数字，就是最后一个质因数。 12345678910111213141516171819202122#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n; while( cin &gt;&gt; n)&#123; bool first = true; int tmpn = n; cout &lt;&lt; n &lt;&lt; \" = \" ; for (int i = 2; i &lt;= sqrt(n); ++i)&#123; while ( tmpn%i == 0 &amp;&amp; tmpn != i)&#123; tmpn /= i; cout &lt;&lt; i &lt;&lt; \" * \"; &#125; &#125; cout &lt;&lt; tmpn &lt;&lt; endl; &#125; return 0;&#125; 我的第一次做法： 一直TLE，估计这种的话，必须得线性筛，我搜了几个题解的结果也证明除了上述题解，其他的都是线性筛，上面的就比较巧妙 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; bool isPrime( int num )&#123; //两个较小数另外处理 if (num==1) return false; if(num ==2|| num==3 ) return true ; //不在6的倍数两侧的一定不是质数 if(num %6!= 1&amp;&amp;num %6!= 5) return false; //在6的倍数两侧的也可能不是质数 for(int i= 5;i &lt;= sqrt( num); i+=6 ) if(num %i== 0||num %(i+ 2)==0 ) return false ; //排除所有，剩余的是质数 return true;&#125;int main()&#123; int n; while( cin &gt;&gt; n)&#123; bool first = true; cout &lt;&lt; n &lt;&lt; \" = \" ; int tmpn = n; for(int i=2;i&lt;=tmpn;i++)&#123; while ( isPrime(i) &amp;&amp; n%i == 0)&#123; n /= i; if (first) &#123; first = false; cout &lt;&lt; i ; &#125; else cout &lt;&lt; \" * \" &lt;&lt; i ; if (n==0) break; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 因子个数 用到了上题的结论，一个正整数总可以分解成一个或多个素数的积，一开始理解错题目了，以为是所有因数的个数，其实是因数的种数，比如20-&gt;2是因为2，2，5；30-&gt;3是因为2，3，5。 因此这边还是需要素数判别，卡的点也在这，要用线性筛，其实就是上题的回答方式不同罢了 123456789101112131415161718192021222324#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n; while( cin &gt;&gt; n)&#123; int ans=0; int tmp = n; for (int i = 2; i &lt;= n; ++i)&#123; bool first = true; while (tmp%i==0)&#123; tmp/=i; if (first)&#123; first = !first; ans ++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 12345678910111213141516171819202122232425#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n; while( cin &gt;&gt; n)&#123; int ans=0; int tmp = n; for (int i = 2; i &lt;= sqrt(n); ++i)&#123; // bool first = true; if (tmp%i==0)&#123; while (tmp%i==0)&#123; tmp/=i; &#125; ans++; &#125; &#125; if (tmp!=1) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; skew数 模拟题、实现一个幂运算 12345678910111213141516171819202122232425262728293031#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int pow2(int n)&#123; int ans=1; for (int i = 0; i &lt; n; ++i) ans *= 2; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); string s; while( cin &gt;&gt; s )&#123; int size = s.size(); int ans=0; for (int i = 0; i &lt; size; ++i)&#123; /* code */ if (s[i] == '2')&#123; ans += 2*(pow2(size-i)-1); break; &#125; ans += (s[i]-'0')*(pow2(size-i)-1); &#125; cout &lt;&lt; ans &lt;&lt;endl; &#125; return 0;&#125; 一的个数 非常基础的一道题：r进制表示 12345678910111213141516171819#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n, r; while( cin &gt;&gt; n &gt;&gt; r)&#123; int ans=0; while(n)&#123; if (n%r==1) &#123; ans++; &#125; n /= r; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 外星人的语言 r进制的拓展，需要将各位输出出来，由于是逆序的，所以需要一1.个栈来反转一下、或是2.使用string的反转功能 123456789101112131415161718192021222324252627282930313233#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n, r; stack&lt;char&gt; s; while( cin &gt;&gt; n &gt;&gt; r)&#123; int ans=0; while(n)&#123; // 0-9 char c = n%r+48; if (n%r&gt;=10) &#123; // A-F c = n%r-10+65; &#125; n /= r; // 不直接cout，而是存栈 s.push(c); &#125; while(!s.empty())&#123; // 取出栈里的内容 char c = s.top(); s.pop(); cout &lt;&lt; c; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 数位和 代码为一的个数+外星人的语言的结合版。 题目要求，将数n，先表示成r进制的形式，然后再计算r进制下n的位数和，然后再用r进制来表示位数和的结果 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; // ACM比赛中cin,的使用比较耗时,因为默认的时候，cin与stdin总是保持同步的，使用这句可以使cin达到和scanf相差无几的输入效率。 ios::sync_with_stdio(false); int n, r; while( cin &gt;&gt; n &gt;&gt; r)&#123; int ans=0; while(n)&#123; ans += n%r; n /= r; &#125; stack &lt;char&gt; s; while(ans)&#123; // 0-9 char c = ans%r+48; if (ans%r&gt;=10) &#123; // A-F c = ans%r-10+65; &#125; ans /= r; // 不直接cout，而是存栈 s.push(c); &#125; while(!s.empty())&#123; // 取出栈里的内容 char c = s.top(); s.pop(); cout &lt;&lt; c; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 进制回文数 还是r进制的拓展， 1.r需要用个2-16的循环 2.判断字符串的镜像对称s[i] != s[ssize-i-1] 3.踩了个坑,n每次都会被除到很小,因此需要用个临时变量来处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int N; while( cin &gt;&gt; N)&#123; bool yes=false; for (int r = 2; r &lt;= 16; ++r)&#123; string s; int n = N; while(n)&#123; char c = n%r+48; if (n%r&gt;=10) &#123; c = n%r-10+65; &#125; n /= r; s += c; &#125; // 检测出r进制变换时,n已经被除的很小了,因此需要用个临时变量 // cout &lt;&lt; r &lt;&lt; \"进制：\" &lt;&lt; endl; // for (int i = 0; i &lt; s.size(); ++i) // &#123; // cout &lt;&lt; s[i] &lt;&lt; endl; // /* code */ // &#125; bool mirror = true; int ssize = s.size(); for (int i = 0; i &lt;= ssize/2; ++i)&#123; if (s[i] != s[ssize-i-1])&#123; mirror = false; break; &#125; &#125; if (mirror)&#123; yes=true; break; &#125; &#125; if (yes) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125; 发邮件 一道数学题，递推公式为f(n)=(n−1)∗[f(n−1)+f(n−2)]f(n) = (n-1)*[f(n-1)+f(n-2)]f(n)=(n−1)∗[f(n−1)+f(n−2)] 坑点:超出了int，需要用longlong 123456789101112131415161718192021#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll email(int n)&#123; if (n==2) return 1; else if(n==3) return 2; else&#123; return (n-1)*(email(n-1)+email(n-2)); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); int n; while( cin &gt;&gt; n )&#123; cout &lt;&lt; email(n) &lt;&lt; endl; &#125; return 0;&#125; 说反话 (20) 考查了：对行的读取、字符串的切割。 本来还以为考了个string的反转，结果比想象中的更简单一点 123456789101112131415161718192021222324252627282930#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ios::sync_with_stdio(false); string s; while( getline(cin, s) )&#123; stringstream strings; string tmps; strings &lt;&lt; s; while( getline(strings, tmps, ' ') )&#123; ss.push(tmps); &#125; while(!ss.empty())&#123; string couts = ss.top(); ss.pop(); if (!ss.empty()) cout &lt;&lt; couts &lt;&lt;' '; else cout &lt;&lt; couts ; &#125; cout &lt;&lt;endl; &#125; return 0;&#125; 补充——string的反转： 1234567891011121314151617181920212223/*法一:使用string::reverse_iterator迭代器,直接用iterator会报错*/for (string::reverse_iterator it=couts.rbegin(); it != couts.rend() ; ++it) cout &lt;&lt; *it;/*法二:使用algorithm算法中的reverse函数*/// 会修改str中的内容reverse(str.begin(),str.end());/*法三:使用使用string.h中的strrev函数△只能处理char[],不支持string类型*/char s[]=\"hello\";strrev(s);cout&lt;&lt;s&lt;&lt;endl;/*法四:自己编写*/void Reverse(char *s,int n)&#123; for(int i=0,j=n-1;i&lt;j;i++,j--)&#123; char c=s[i]; s[i]=s[j]; s[j]=c; &#125;&#125; 一元多项式求导 (25) 被读取方式卡了会 这边有个坑点: 忽略了常数项的问题 比如 输入 2 0 应该输出 0 0 1234567891011121314151617#include&lt;cstdio&gt; int main()&#123; int exp,coe; bool flag=false; while(scanf(\"%d %d\",&amp;coe,&amp;exp)!=EOF) &#123; if(exp!=0) &#123; if(flag) printf(\" \"); printf(\"%d %d\",coe*exp,exp-1); flag=true; &#125; &#125; if(flag==false) printf(\"0 0\\n\"); return 0;&#125; 别人的处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct poly&#123; int coef; int index;&#125;typedef poly;int main()&#123; ios::sync_with_stdio(false); int coef; int index; std::queue&lt;poly&gt; q; // scanf和getchar合用比较方便,cin再用getchar无效 while(scanf(\"%d%d\", &amp;coef, &amp;index) != EOF)&#123; if (index!=0)&#123; poly *p = new poly(); p-&gt;coef = coef*index; p-&gt;index = index-1 ; q.push(*p); &#125; // 放最后能过,放最初的时候有些过不了 if (getchar()=='\\n') break; &#125; if (q.size()==0) printf(\"0 0\\n\"); else&#123; while(!q.empty())&#123; poly p = q.front(); q.pop(); if (p.coef != 0)&#123; if (q.empty()) printf(\"%d %d\", p.coef, p.index ); else printf(\"%d %d \", p.coef, p.index ); &#125; &#125; &#125; return 0;&#125; 刷完了牛客网PAT乙级练习题的第一、第三页。大多都是些模拟题、简单题，相当于弱一点的蓝桥杯省赛。由于报名考的是甲级，所以就没继续做下去了…","categories":[],"tags":[]},{"title":"sshpass——shell脚本实现SSH连接其他主机并执行终端命令","slug":"sshpass——shell脚本实现SSH连接其他主机并执行终端命令","date":"2019-12-25T09:29:08.000Z","updated":"2019-12-25T10:16:16.390Z","comments":true,"path":"2019/12/25/sshpass——shell脚本实现SSH连接其他主机并执行终端命令/","link":"","permalink":"https://nymrli.top/2019/12/25/sshpass——shell脚本实现SSH连接其他主机并执行终端命令/","excerpt":"","text":"sshpass ssh登陆不能在命令行中指定密码。sshpass的出现，解决了这一问题。即sshpass可以用于非交互SSH的密码验证，一般用在sh脚本中，无须再次输入密码。 sshpass允许用-p参数指定明文密码，然后直接登录远程服务器。(支持密码从命令行、文件、环境变量中读取) 1.安装sudo apt install sshpass 2.使用说明 12345678910111213141516171819# -p 直接指定密码sshpass -p '123456' ssh user_name@host_ip# -f: -f filename #后跟保存密码的文件名，密码是文件内容的第一行。[root@zhu ~]# cat 1.txt123456[root@zhu ~]# sshpass -f 1.txt ssh root@192.168.56.102Last login: Fri Apr 18 13:48:20 2014 from 192.168.56.101[root@jiang ~]# exitlogoutConnection to 192.168.56.102 closed.# -e #将环境变量SSHPASS作为密码[root@zhu ~]# export SSHPASS=123456[root@zhu ~]# sshpass -e ssh root@192.168.56.102Last login: Fri Apr 18 13:51:45 2014 from 192.168.56.101[root@jiang ~]# exitlogoutConnection to 192.168.56.102 closed. shell脚本实现SSH连接其他主机并执行终端命令 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bash# command -v &lt;the_command&gt; 检测命令是否存在返回命令所在路径,等价于which# if [ -x file ] 如果文件存在且可执行if ! [ -x \"$(command -v sshpass)\" ]; then sudo apt-get install sshpassfiport=20005# echo -e 会进行转义echo -e \"\\n请输入用户名！\\n\"# read-将交互输入保存在变量中read name# 获得当前脚本的工作路径dir=$(cd $(dirname $0);pwd)# 分割-&gt;获得文件名file_name=\"$&#123;dir##*/&#125;\"# 传输文件echo -e \"\\n[开始传输文件]\\n\"sshpass -p \"$key\" scp -r -P $port $dir username@IP_address:/data/cluster/$nameif [ $pool -eq 1 ]||[ $pool -eq 2 ]||[ $pool -eq 3 ] then # remotessh为标记符,下面的内容全部重定向到ssh连接的终端中, 一定要保证下面的全是以字符串的形式 # 由于shell会进行预转换,所以shell特殊的量需要额外注意,否则结果将只会是当前主机的。因此需要加\\ # man sshpass中提示:多个-t选项强制分配tty，即使ssh没有本地tty,所以使用-tt参数来强制伪终端分配(表示为这个连接分配TTY)，即使标准输入不是终端，否则退出后会提示`Pseudo-terminal will not be allocated because stdin is not a terminal的错`。 即指明是来自脚本的调用 # 控制终端（/dev/tty）就是当前进程的控制终端的设备特殊文件，可以进行写入写出 sshpass -p \"$key\" ssh -tt -p $(($port+$pool)) username@IP_address &lt;&lt; remotessh Condor_number=\\`condor_q | grep jobs | awk '&#123;print \\$1&#125;'\\` if [ \\$Condor_number -le 1 ] then echo -e \"\\n创建任务失败！\\n\" else echo -e \"\\n创建任务成功！\\n\" fi exitremotesshelse echo -e \"没有该资源池\\n\" exitfi man sshpass中关于-t参数的说明 Force pseudo-terminal allocation. This can be used to execute arbitrary screen-based programs on a remote machine, which can be very useful, e.g. when implementing menu services. Multiple -t options force tty allocation, even if ssh has no local tty. 总结： 所以实现的方法主要是: SSHpass非交互式登录 SSH终端执行多条命令 附录 ssh@host:ssh切换到其他机器上执行多条命令 Shell表达式，${file##*/} 取后缀 shell-if表达式（-f,-d,-s,-r,-w,-x,-eq,-ne,-ge,-gt,-le,-lt ） Linux检测命令是否存在","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://nymrli.top/tags/运维/"},{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"树莓派初始化操作","slug":"树莓派初始化操作","date":"2019-12-12T10:59:06.000Z","updated":"2019-12-12T11:21:49.504Z","comments":true,"path":"2019/12/12/树莓派初始化操作/","link":"","permalink":"https://nymrli.top/2019/12/12/树莓派初始化操作/","excerpt":"","text":"安装系统镜像: 官网下载镜像，解压下载好的Zip文件会得到.img镜像文件。下载win32DiskImage 方式: SSH VNC Xrdp 系统设置: $ sudo raspi-reconfig 1.安装字体 默认安装的是英文字体，如果时区选择中文，将会乱码，因此需要安装中文字体进行汉化。 sudo apt-get install ttf-wqy-zenhei 2.安装中文输入发 3.修改键盘布局 键盘布局默认是英标的，需要将其改成美标 输入sudo dpkg-reconfigure keyboard-configuration后选择通用的104键PC键盘(Generic 104 Key PC),在Layout中选择Ohter,然后在选项中选择English(US)，然后不断选择OK退出即可","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://nymrli.top/tags/嵌入式/"}]},{"title":"ACM-网络流","slug":"ACM-网络流","date":"2019-12-08T11:03:34.000Z","updated":"2019-12-08T11:48:50.230Z","comments":true,"path":"2019/12/08/ACM-网络流/","link":"","permalink":"https://nymrli.top/2019/12/08/ACM-网络流/","excerpt":"","text":"最大流 FF算法 最基本找増广路的算法 dinic实现(基础的FF算法) 反边：我们知道，当我们在寻找增广路的时候，在前面找出的不一定是最优解，如果我们在减去残量网络中正向边的同时将相对应的反向边加上对应的值，我们就相当于可以反悔从这条边流过。 技巧：flow[u]正边，flow[u^1]反边 建边的时候是同时建的，比如1的反边为2，2的反边为1，▲边不能从0开始 主要思路： 求增广路 分层图 dinic的优化 当前弧优化(作用不明显) 12345678910111213141516171819202122232425262728// 最原始int dfs(int now,int fl)&#123; if(now==aim)return fl; int f=e; for(int u=fir[now];u &amp;&amp; fl;u=nxt[u])&#123; if(flow[uj&amp;&amp;deep[to[u]]==deep[now]+1)&#123; int x=dfs(to[u],min(fl,flow[u])); flow[u]-=x;flow[u^1]+=x;fl-=x;f+=x; &#125; &#125; if(lf)deep[now]=-2; return f;&#125;// 当前弧优化int dfs(int now,int fl)&#123; if(now==aim) return fl; int f=0; // 修改为curfir[now] for(int u=curfir[now];u&amp;&amp;fl;u=nxt[u])&#123; curfir=u; // 加了此处 if(flow[u]&amp;&amp;deep[to[u]]==deep[now]+1)&#123; int dfs(to[u],min(fl,flow[u])); flow[u]-=x;flow[u^1]+=x;fl-=x;f+=x; &#125; &#125; if(!f)deep[now]=-2; // 炸点优化 return f;&#125; 多路增广 炸点 最大流最小割定理：最小割总和的权值==最大流的值，对于每张图都是成立的。（网络流的对称形式） 具体代码: 12345678910111213141516171819202122232425262728293031323334353637int maxflow(int s, int t)&#123; // 外层循环 aim = T;int ret = 0; while(bfs(s, t))&#123; ret += dfs(s, 1&lt;&lt;30); &#125; return ret;&#125;bool bfs(int s, int t)&#123; // 建立分层图 memset(deep,0,(tot+2)&lt;&lt;2); deep[S]=1;d1[1]=S;int head=0,tail=1; while(head!=tail)&#123; int v=dl[++head]; for(int u=fir[v];u;u=nxt[u])&#123; if(flow[u]&amp;&amp;!deep[to[u]])&#123; deep[to[u]]=deep[v]+1; d1[++tail]=to[u]; &#125; &#125; &#125; return deep[T];&#125;int dfs(int now,int fl)&#123; // dfs找増广路 if(now==aim) return fl; int f=0; // // 当前弧优化,修改为curfir[now] for(int u=curfir[now];u&amp;&amp;fl;u=nxt[u])&#123; curfir=u; // 加了此处 if(flow[u]&amp;&amp;deep[to[u]]==deep[now]+1)&#123; int dfs(to[u],min(fl,flow[u])); flow[u]-=x;flow[u^1]+=x;fl-=x;f+=x; &#125; &#125; if(!f)deep[now]=-2; // 炸点优化 return f;&#125; EK算法 引入了反相边：在原有的有向图上引入了反向的边，且容量相等 执行过程： BFS找増广路 找到的话，更新最大流、残余网路 找不到则走完了 两者的思想都是：找増广路，找到找不到为止 参考: 最大流（最小割）的EK算法 最小费用最大流","categories":[],"tags":[]},{"title":"ACM-树状数组和线段树","slug":"ACM-树状数组和线段树","date":"2019-12-07T05:04:53.000Z","updated":"2020-09-12T06:48:46.827Z","comments":true,"path":"2019/12/07/ACM-树状数组和线段树/","link":"","permalink":"https://nymrli.top/2019/12/07/ACM-树状数组和线段树/","excerpt":"","text":"高性能问题： Q：需求：（老板给你分了台2GHz单核，内存500M的服务器然后让你写程序）程序每秒会收到一组数据，每组数据包含10万条命令，总共会有100万个仓库，每个仓库库存没有上限且可为负，库存初始为0。你需要在一秒内完成全部的命令，然后将查询结果按顺序得出后传回，命令如下： Add i j，i和j为正整数，表示第i个仓库增加j个库存（j不超过220） Sub i j，i和j为正整数，表示第i个仓库减少个库存（j不超过220） Query i j，i和j为正整数，i&lt;=j，表示询问第i到第个仓库的总库存；End 表示结束，这条命令在每组数据最后出现； 思路一：用array去存储每个仓库的容量，在查询时用循环取出(L,R)的总容量。此时Update为O(1)，Query为O(N) 思路二：前缀数组和：在array1储存每个仓库容量的同时维护array2来记录前n个仓库的总容量，当计算某个区间的容量(L,R)可以通过s[R]-s[L-1]求出。此时Query为O(1)，但Update为O(N) 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3;int arr[maxn];int main()&#123; int n; cin &gt;&gt; n; int tmp; cin &gt;&gt; tmp; arr[1] = tmp; for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; tmp; arr[i] = tmp + arr[i-1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt;endl; &#125; // 可以算出2-4的和 cout &lt;&lt; arr[4] - arr[2-1] &lt;&lt; endl; return 0;&#125; 思路三：树状数组：Update和Query的时间复杂度进行折中后都为O(logN) 树状数组 又叫二叉索引树，最早是为了解决数据压缩里的累积频率问题，现多用来解决数组区间查询问题的数据结构，即高效解决数列的前缀和、区间和问题。 low bit算法 核心：将一个数拆分成若干个二进制数相加，原理：每一个数都有二进制表示，即所有数都可以表示成x个不同的2的幂之和。 做法：找到二进制最后低一位1表示的数。 代码：通过计算n&amp;-n找到n最右边的1。 举个栗子： Q： 6可以怎么计算得到呢？ A： 6==0110，i=110，通过lowbit可以拆分成两个数100+010=110 因此树状数组的维护更新过程如下：已知i=6 ①S+= C[6] ②找到i最右边的1，即得到lowbit=(10)2=(2)10lowbit=(10)_{2}=(2)_{10}lowbit=(10)2​=(2)10​ ③更新i:i′=i−lowbit=(0110)2−(0010)2=(0100)2i&#x27;= i - lowbit = (0110)_{2}-(0010)_{2}=(0100)_{2}i′=i−lowbit=(0110)2​−(0010)2​=(0100)2​，即i′=6−2=(4)10i&#x27;=6-2=(4)_{10}i′=6−2=(4)10​； ④S+= C[4] ⑤再继续找i最右边的1，即得到了lowbit=(100)2=(4)10lowbit=(100)_{2}=(4)_{10}lowbit=(100)2​=(4)10​， ⑥更新i:i′=i−lowbit=(0100)2−(0100)2=(0000)2i&#x27;= i - lowbit =(0100)_{2}-(0100)_{2}=(0000)_{2}i′=i−lowbit=(0100)2​−(0100)2​=(0000)2​， ⑦此时i最右边无1(即全零为0)，算法结束，即最终C[6]=C[4] + C[2] 计算步骤： 找到(n)2(n)_2(n)2​最右边的1的数(n1)2(n1)_2(n1)2​ 更新n′=(n)2−(n1)2n&#x27;=(n)_2 - (n1)_2n′=(n)2​−(n1)2​ 如果(n′)2(n&#x27;)_2(n′)2​还能找到1，那么重复1-2 123456789101112131415161718192021222324252627282930313233343536N = 1e6 + 5arr = [0] * N# 自底向上建树def add(i, j): ''' 修改第i仓库Ci。但注意执行某个仓库的update操作，后面所有仓库都得更新 ''' while i &lt;= N: arr[i] += j # 加上low bit位 i += i&amp;-i def sub(i, j): add(i, -j) def sum(i): ''' 通过Ci求出1-i仓库的总库存 S[6] = C[6] + C[4], 推导如下: 如果i=6,那么 ans += c[6] , i &lt;- i-2 = 6-2 = 4, ans += c[4] , i &lt;- i-4 = 4-4 = 0 ∴ans = c[6] + c[4] = A[6]+A[5]+A[4]+A[3]+A[2]+A[1] ''' ans = 0 while i &gt; 0: ans += arr[i] i -= i&amp;(-i) return ansdef query(i, j); ''' 查询某个区间的总库存，sum(i, j) = S(R) - S(L-1) ''' return sum(j) - sum(i-1) 符号说明： Ai：第i个仓库的库存数 Ci：所构建的数的第i个节点的值，C[i] = A[i-lowbit(i)+1] + …+A[i] Si：第1个仓库到第i个仓库库存数之和 Ans（i，j）：显然就等于SR−SL−1S_{R}-S_{L-1}SR​−SL−1​ 形式 一.从原数组A[],维护树状数组C[] ▲lowbit又叫子叶数，表示了有多少个A[]相加，C[i]表示从C[i] = A[i-lowbit(i)+1] + …+A[i] (&lt;===&gt;C[i] = A[i-2^x+1] + … + A[i])， For Example： i=6 参考： 树状数组——黑板讲解,NICE 树状数组算法——初步了解，有些点讲的并不那么纤细 洛谷: P3374 【模板】树状数组 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define N 500000 + 5using namespace std;int c[N];void add(int i, int k)&#123; int index = i; while (index&lt;=N)&#123; c[index] += k; index += index&amp;(-index); &#125;&#125;int sum(int n)&#123; int index = n; int ans = 0; while (index)&#123; ans += c[index]; index -= index&amp;(-index); &#125; return ans;&#125;int query(int l, int r)&#123; return sum(r) - sum(l-1);&#125; int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i)&#123; int val; cin &gt;&gt; val; add(i, val); &#125; for (int i = 0; i &lt; m; ++i)&#123; int op; int x, k; cin &gt;&gt; op &gt;&gt; x &gt;&gt; k; if (op==1) add(x, k); else cout &lt;&lt; query(x, k) &lt;&lt; endl; &#125; return 0;&#125; 线段树 在求解前缀和、区间和问题上，两者是没有差别的，并且树状数组的空间复杂度更低。但是线段树还有更多的功能，比如求取区间最大值。 完满二叉树(Full Binary Tree) 根据元素的下标进行划分 一个节点代表一个区间的信息 特点： 每个节点维护一个闭区间1,r的信息。 根节点表示[1,n]的信息。如果1=r那就是叶子结点. 如果1&lt;r那就是内部节点,它有两个子节点[1,(1+r)/2]，[(1+r)/2+1,r]. 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 更新/*用1表示根节点。下标为x的点的左子节点下标为2x，右子节点2x+1。用sum[x]表示x代表的区间里所有数的和。对于叶子结点x，它代表[1，r]（1=r），sum[x]=a[1]*/void update(int x)&#123; // 更新某个节点X的值 sum[x]= sum[x*2] + sum[x*2+1];&#125;// 构建, 自顶向下/*对于存储在i号位置的节点，它的左孩子存在2i号位置，右孩子2i+1号位置。同时我们也不需要记录每个位置对应的区间，只要在递归的找这个点的时候边找边修改即可。*/void build(int 1,int r,int x)&#123; if(l==r)&#123; //叶子结点 sum[x]=a[1]; return; &#125; int mid=(1+r)&gt;〉1; build(1,mid,x*2); build(mid+1,r,x*2+1); update(x);//更新信息&#125;// 查询/*假设询问区间是[A,B],现在所在的节点表示的区间为[1,r]- 计算mid=(1+r)/2,左子节点的区间为[1,mid],右子节点的区间为[mid+1,r].如果A&lt;=mid,即询问区间与左子节点有重合,需要递归到左子节点。如果B&gt;=mid+1,即询问区间与右子节点有重合,需要递归到右子节点。递归完之后,需要把两个孩子询问的结果加起来作为返回值。*/int query(int A,int B,int 1,int r,int x)&#123; if(A&lt;=1&amp;&amp;r&lt;=B) return sum[x]; int mid=(1+r)&gt;&gt;1,ans=0; if(A&lt;=mid) ans+=query(A,B,1,mid,x*2); if(mid&lt;B) ans+=query(A,B,mid+1,r,x*2+1); return ans;&#125;// 修改/*由于修改是对单个元素进行修改。比如修改第i个元素。我们先找到[i，i]所在的节点，然后修改它的sum，然后一路向上更新每个祖先的sum即可。*/int change(int pos,int v,int 1,int r,int x)&#123; if( l==r)&#123; //找到了要修改的叶子结点 sum[x]=v; return; &#125; int mid=(1+r)&gt;&gt;1; if(pos&lt;=mid)//pos在左子节点 change(pos,v,1,mid,x*2); else change(pos,v,mid+1,r,x*2+1); update(x);//一定要加！因为这条路上的sum值发生了改变&#125; 性质 节点数：假设线段树处理的数列长度为n，即根节点的区间为[1，n].那么结点数不超过2n个.因此线段树的空间复杂度是0（n）。是完满二叉树(Full Binary Tree)，但一般申请4*n的空间大小 深度：可以看作满二叉树，深度不超过log2(n-1)+1 线段树能把区间上的任意一条长度为L的线段都分成不超过2*log(L)条线段。 注意： 由于链表表示的内存是不连续的，且申请指针比较费时间，所以采用数组矩阵的形式存储。 数组存储也有一点不好，因为线段树并不是真正的完全二叉树。 最后一层可能很空。且空节点的数量可以达到2n个。 因此维护长度为n的序列，用数组存线段树的话，最好要开到4*n的长度，才能保证数组不越界。 形式 例题： Q：对于第i个数，我们要统计前面有多少个数大于a[i]。 对每个数都统计一遍加起来即是答案。 假设我们可以对[0，109]建一个线段树（实际上太大了）每次先查询[a[i]+1，109]的区间和，加入答案。 e.g.如果一个值为1，一个值为108，那么要开108大小 Solve: 10^9范围太大了，因此我们先要对n个数进行离散化。离散化的过程，就是对n个数进行排序，最小的数赋值为1，第二小的赋值为2，以此类推，这样n个数的取值范围就在[1，n]中了。 e.g.上面的情况，将会把1–&gt;1,10^8–&gt;2,那么只要开长度为2的线段树就够了 12345678910// 离散化代码，假设对a[1,2...,n]进行离散化int cnt=0;for(int i=1;i&lt;=n;i ++) // 另外的数组存储 bin[++cnt]=a[i];sort(bin+1,bin+n+1);// 消重cnt=unique(bin+1,bin+cnt+1)-bin-1;for(inti=1;i&lt;=n;i ++) a[i]=lower_bound(bin+1,bin+cnt+1,a[i])-bin; 参考： 高中信息学竞赛线段树与树状数组——万门教育 SWPU-ACM每周算法讲堂-线段树入门（一）","categories":[],"tags":[]},{"title":"KM(Kuhn-Munkres)算法","slug":"KM-Kuhn-Munkres-算法","date":"2019-12-05T13:52:58.000Z","updated":"2019-12-10T14:15:29.634Z","comments":true,"path":"2019/12/05/KM-Kuhn-Munkres-算法/","link":"","permalink":"https://nymrli.top/2019/12/05/KM-Kuhn-Munkres-算法/","excerpt":"","text":"KM(Kuhn-Munkres)算法 带权二分图最佳完美匹配，O(n^3)，（运用匈牙利算法辅助求解），同时也是完备匹配 只适用于带权最大匹配一定是完备匹配的情况，实践中建议用费用流来解决。 完全二分图一定是偶数个点 可行顶标（Feasible Labeling）：结点函数（x），任意边（x，y）：1（x）+l（y）≥w（xiy）。 相等子图：G的生成子图，包含所有点以及满足l（x）+I（y）=w（x，y）的边（x，y） 如果EL有完美匹配为PM，则该M是原图的最大权匹配： PM的权和等于所有点的顶标之和SV。 G的任一个最大权匹配M，边满足w（xy）≤l（x）+（y）→M边权和≤SV=PM边权和 关键就是寻找好的可行顶标，使相等子图有完美匹配。 ==&gt;找到原图的完美匹配–只要–&gt;找到相等子图的完美匹配即可 ▲KM完成之后所有的l(x)之和最小 执行过程 一般对KM算法的描述，基本上可以概括成以下几个步骤： 1.用邻接矩阵（或其他方法也行啦）来储存图。 2.运用贪心算法初始化标杆。 3.运用匈牙利算法找到完备匹配。 4.如果找不到，则通过修改标杆，增加一些边。 5.重复3，4的步骤，直到完全匹配时可结束。 二分图匹配里面我们找最大边进行连边!但是遇到某个点被匹配了两次怎么办？ 那就用匈牙利算法进行更改匹配！ 这就是KM算法的思路了：尽量找最大的边进行连边，如果不能则换一条较大的。 找对象例子理解重点： 女生的每轮选择都是从第一个男生开始往后选择一个男生，使男女两人的期望和要等于两人之间的好感度。 注意：每一轮匹配，每个男生只会被尝试匹配一次！ 如果找对象失败，那么此时参与匹配过的女生期望值都降低d，本轮被选择的男生期望值都增加d：d为任意一个这轮参与过匹配的女生能换到***任意一个这轮没有被选择过的男生所需要降低的最小值*（遍历左边已配对的X，标杆值Lx，与右边这一轮没被选择过的男生Y，标杆值Ly，挑出需要降低的最小值，即 d=min(Lx+Ly-W, d) ） 复杂度 朴素的实现方法，时间复杂度为O(n4)——需要找O(n)次增广路，每次增广最多需要修改O(n)次顶标，每次修改顶标时由于要枚举边来求d值，复杂度为O(n2)。 实际上KM算法的复杂度是可以做到O(n3) 的。我们给每个Y顶点一个“松弛量”函数slack，每次开始找增广路时初始化为无穷大。在寻找增广路的过程中，检查边(i,j)时，如果它不在相等子图中，则让slack[j]变成原值与A[i]+B[j]-w[i,j]的较小值。这样，在修改顶标时，取所有不在交错树中的Y顶点的slack值中的最小值作为d值即可。但还要注意一点：修改顶标后，要把所有的slack值都减去d。（即用在执行匈牙利算法的时候，进行对slack的更新，从而减少一层找到最小d的循环） 举个栗子: 少林决胜(Golden Tiger Claw，UVa11383) 给定一个N*N矩阵，每个格子里都有一个正整数w(i,j)。你的任务是给每行确定一个整数row(i)，每列也确定一个整数col(i)，使得对于任意格子(i, j)，w(i, j)≤row(i)+colj)。所有row(i)和col(i)之和应尽量小。 【分析】 1.行看作二分图X点，列看作二分图Y点。 2.和最佳匹配没有任何关系，KM算法副产品。 3.KM中算法等式l（x）+l（y）≥w（x，y）。行X，列Y。 4.KM过程中，所有顶标不断减小，算法结束后，所有顶标之和是最小的。 蚂蚁（Ants，NEERC2008，LA4043） 给出n个白点和n个黑点的坐标，要求用n条不相交的线段把它们连接起来，其中每条线段恰好连接一个白点和一个黑点，每个点恰好连接到一条线段，如图所示。 【分析】 点有黑白两色，构造二分图，白X黑Y。每个黑点和每个白点相连，权值等于欧氏距离。 连接方案实际上是计算一个完美匹配，匹配中假设al-b1与a2-b2相交，那么dist(a1，b1)+dist(a2，b2)&gt;dist(al，b2)+dist(a2，b1)，这两条线段改成al-b2和a2-b1后总长度会变少。 所以最小匹配中不会出现线段相交。 套KM算法即可计算最小完美匹配即可。 附录 O(n^3)代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;using namespace std;const int MAXN = 305;const int INF = 0x3f3f3f3f;// X为女生节点， Y为男生节点int love[MAXN][MAXN]; // 记录每个妹子和每个男生的好感度int ex_girl[MAXN]; // 每个妹子的期望值int ex_boy[MAXN]; // 每个男生的期望值bool vis_girl[MAXN]; // 记录每一轮匹配匹配过的女生bool vis_boy[MAXN]; // 记录每一轮匹配匹配过的男生int match[MAXN]; // 记录每个男生匹配到的妹子 如果没有则为-1int slack[MAXN]; // 记录每个汉子如果能被妹子倾心最少还需要多少期望值int N;bool dfs(int girl)&#123; vis_girl[girl] = true; for (int boy = 0; boy &lt; N; ++boy) &#123; if (vis_boy[boy]) continue; // 每一轮匹配 每个男生只尝试一次 int gap = ex_girl[girl] + ex_boy[boy] - love[girl][boy]; if (gap == 0) &#123; // 如果符合要求 vis_boy[boy] = true; if (match[boy] == -1 || dfs( match[boy] )) &#123; // 找到一个没有匹配的男生 或者该男生的妹子可以找到其他人 match[boy] = girl; return true; &#125; &#125; else &#123; slack[boy] = min(slack[boy], gap); // slack 可以理解为该男生要得到女生的倾心 还需多少期望值 取最小值 备胎的样子【捂脸 &#125; &#125; return false;&#125;int KM()&#123; // ▲初始化有关被选择的男生的量1-2 [选择他的女生、男生方标杆] memset(match, -1, sizeof match); // 初始每个男生都没有匹配的女生 memset(ex_boy, 0, sizeof ex_boy); // 初始每个男生的期望值为0 // ▲初始化3 [女生方的标杆] // 每个女生的初始期望值是与她相连的男生最大的好感度 for (int i = 0; i &lt; N; ++i) &#123; ex_girl[i] = love[i][0]; for (int j = 1; j &lt; N; ++j) &#123; ex_girl[i] = max(ex_girl[i], love[i][j]); &#125; &#125; // 尝试为每一个女生解决归宿问题 for (int i = 0; i &lt; N; ++i) &#123; // ▲初始化4 [slack-找到最小的d] fill(slack, slack + N, INF); // 因为要取最小值 初始化为无穷大 while (1) &#123; // 为每个女生解决归宿问题的方法是 ：如果找不到就降低期望值，直到找到为止 // 初始化5-6 [该轮中那些女生已经尝试匹配过，该轮中那些男生被选择过] // 记录每轮匹配中男生女生是否被尝试匹配过 memset(vis_girl, false, sizeof vis_girl); memset(vis_boy, false, sizeof vis_boy); if (dfs(i)) break; // 找到归宿 退出 // 如果不能找到 就降低期望值 // 最小可降低的期望值 int d = INF; for (int j = 0; j &lt; N; ++j) if (!vis_boy[j]) d = min(d, slack[j]); for (int j = 0; j &lt; N; ++j) &#123; // 所有访问过的女生降低期望值 if (vis_girl[j]) ex_girl[j] -= d; // 所有访问过的男生增加期望值 if (vis_boy[j]) ex_boy[j] += d; // 没有访问过的boy 因为girl们的期望值降低，距离得到女生倾心又进了一步！ else slack[j] -= d; &#125; &#125; &#125; // 匹配完成 求出所有配对的好感度的和 int res = 0; for (int i = 0; i &lt; N; ++i) res += love[ match[i] ][i]; return res;&#125;int main()&#123; while (~scanf(\"%d\", &amp;N)) &#123; for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; N; ++j) scanf(\"%d\", &amp;love[i][j]); printf(\"%d\\n\", KM()); &#125; return 0;&#125; 裸题:HDU2255 奔小康赚大钱 输入数据包含多组测试用例，每组数据的第一行输入n,表示房子的数量(也是老百姓家的数量)，接下来有n行,每行n个数表示第i个村名对第j间房出的价格(n&lt;=300)。 123456Sample Input2 // 一共有两个房子100 10 // 村民1对第一间出价100, 第二间1015 23 // 村民1对第一间出价15, 第二间23Sample Output123 // 第一间给1,第二间给2 获得其他数据： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int main()&#123; N = 3; srand(time(0)); for (int i = 0; i &lt; N; ++i)&#123; for (int j = 0; j &lt; N; ++j)&#123; int tmp = rand() % 3*N + 1; love[i][j] = tmp; printf(\"%d \", love[i][j] ); &#125; printf(\"\\n\"); &#125; printf(\"%d\\n\", KM()); int sum = 0; for (int i = 0; i &lt; N; ++i)&#123; printf(\"%d-&gt;%d\\n\", match[i], i); sum += love[match[i]][i]; &#125; printf(\"和最大：%d\\n\", sum); for (int i = 0; i &lt; N; ++i)&#123; for (int j = 0; j &lt; N; ++j)&#123; love[i][j] = -love[i][j] ; printf(\"%d \", love[i][j] ); &#125; printf(\"\\n\"); &#125; printf(\"和最小：%d\\n\", -KM()); sum = 0; for (int i = 0; i &lt; N; ++i)&#123; printf(\"%d-&gt;%d\\n\", match[i], i); sum += love[match[i]][i]; &#125; printf(\"%d\\n\", sum); return 0;&#125;/**4 1 7 1 4 7 1 7 4 180-&gt;02-&gt;11-&gt;218-4 -1 -7 -1 -4 -7 -1 -7 -4 61-&gt;00-&gt;12-&gt;2-6*/ 参考资料： 二分图匹配之最佳匹配——KM算法 KM算法详解+模板——男女相亲匹配 带你入门多目标跟踪（三）匈牙利算法&amp;KM算法——以图像目标跟踪距离","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"}]},{"title":"ACM-二分图","slug":"ACM-二分图","date":"2019-12-05T09:45:57.000Z","updated":"2019-12-08T14:21:09.471Z","comments":true,"path":"2019/12/05/ACM-二分图/","link":"","permalink":"https://nymrli.top/2019/12/05/ACM-二分图/","excerpt":"","text":"二分图的判定： 染色法1：假设DFS初始点A涂黑色，与它相邻的点就涂白色。如果搜到某一个点u的相邻点v已经涂色并且与u同色，就不可能是二分图啦~ 染色法2：就是给每个点进行标号，标为-1，1如果存在一条边连接的两个点标号相同，那么就是存在一个奇数环… 热身题： 判断无向图是否有环 用DFS遍历图g，如果访问到已经访问过的顶点，那么有环 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;using namespace std;#define SIZE 100+5/** * 起点编号从0开始 */struct graph&#123; int en; // 边数 int vn; // 顶点数 int map[SIZE][SIZE]; // 邻接矩阵 int vis[SIZE]; // 记录矩阵 bool huan = false; // 是否有环&#125;;/**u: 当前节点节点prev: 记录上一个节点g: 图指针 */void dfs(int u, int prev, graph *g)&#123; // 遍历图 for (int v = 0; v &lt; g-&gt;vn; ++v)&#123; // v为下一个可达的节点 // 自己到自己为0, 是没有边的 if (v == prev) continue; if ( g-&gt;vis[v] != 2 &amp;&amp; g-&gt;map[u][v] )&#123; g-&gt;vis[v] = 1; dfs(v, u, g); &#125;else if(g-&gt;vis[v] == 2 &amp;&amp; g-&gt;map[u][v] )&#123; printf(\"now: %d %d\\n\",u ,v ); g-&gt;huan = true; return ; &#125; &#125;&#125;void showGraph(const graph *g)&#123; printf(\"\\t\"); for (int i = 0; i &lt; g-&gt;vn; ++i)&#123; printf(\"%d \", i); &#125; printf(\"\\n\"); for (int i = 0; i &lt; g-&gt;vn; ++i)&#123; printf(\"v:%d\\t\", i); for (int j = 0; j &lt; g-&gt;vn; ++j)&#123; printf(\"%d \", g-&gt;map[i][j]); &#125; printf(\"\\n\"); &#125;&#125;int main(int argc, char const *argv[])&#123; int n; graph *g = new graph(); scanf(\"%d%d\", &amp;g-&gt;vn, &amp;g-&gt;en); memset(g-&gt;map, 0, sizeof(int)*g-&gt;en*g-&gt;vn); for (int i = 0; i &lt; g-&gt;en; ++i)&#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); g-&gt;map[u][v] = g-&gt;map[v][u] = 1; &#125; showGraph(g); for (int i = 0; i &lt; g-&gt;vn; ++i)&#123; // 如果节点i没被访问过 if (g-&gt;vis[i] == 0 &amp;&amp; g-&gt;huan == false)&#123; g-&gt;vis[i] = 2; dfs(i, -1, g); g-&gt;vis[i] = 1; &#125;else if(g-&gt;huan == true) break; &#125; if (g-&gt;huan) printf(\"有环\\n\"); else printf(\"无环\\n\"); return 0;&#125; 判断一个环是否为奇数环 1356: Catch 题意：给出一个起始点，一些边，有人从这个起始点开始随意走，问在某一个时候，它是否可以处于任意位置。 思路：思考下，就可以明白，只要是一个联通图，并且存在奇数点形成的环，那么在某一个时候就可以处于任意位置。 12 最大匹配数——匈牙利算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 150;int line[maxn][maxn]; // 邻接矩阵,表示男生是否有好感(可达)int used[maxn]; // 在位男生i匹配的那轮中,女生i是否被尝试过匹配int nxt[maxn]; // 如果匹配到了的话,那么男生是谁,女生i的对象为nxt[i]int m, n, t;/** * 为男生x匹配到一个女生i,如果匹配到的女生有主,那么让已配对女生的对象(男)修改匹配对象 * @author mrli 2019-12-08 * @param x 男生 * @return 男生x是否能匹配到女生 */bool Find(int x)&#123; // 遍历所有妹子Y节点 for (int i = 1; i &lt;= m; ++i)&#123; // 如果男生对女生互有好感(即边可达) 且 妹子没有匹配过 if (line[x][i] &amp;&amp; !used[i])&#123; // 在男生该轮,将该女生i标记为已经被尝试匹配过 used[i] = 1; // 如果妹子没有对象 或者 已匹配到的男生是可以转移对象的 if ( nxt[i]==0 || Find( nxt[i]) )&#123; // 将女生的已配对对象改为x nxt[i] = x; return true; &#125; &#125; &#125; return false;&#125;/** * 为所有男生进行匹配 * @author mrli 2019-12-08 * @return 最大匹配数 */int match()&#123; // 最大匹配数 int sum = 0; // 遍历所有男生X节点 for (int i = 1; i &lt;= n; ++i)&#123; // 在男生i该轮,所有女生都没有被修改过匹配 memset(used, 0, sizeof(used)); // 如果当前男生能找到匹配女生,那么最大匹配数++ if (Find(i)) sum++; &#125; return sum;&#125;int main(int argc, char const *argv[])&#123; int u, v; cin &gt;&gt; t; // XY节点数 n = m = 4; memset(line, 0, sizeof(line)); memset(nxt, 0, sizeof(nxt)); while(t--)&#123; cin &gt;&gt; u &gt;&gt; v; line[u][v] = 1; &#125; cout &lt;&lt; match(); return 0;&#125;/**input:71 11 22 22 33 13 24 3output:3 */ 拓展题:无题II HDU2236 二分图：为什么会想到用二分图呢？不同行不同列，仔细想一下，如果某点（x,y），被选中，那么横坐标上x的值不能再选，纵坐标上的y值也不能再选，这相当于二维上有很多值，但是每个值都只能用一次，这就可以想到用二分图匹配求完美匹配了。 二分答案：求n个数的最大最小的差值最小，首先这个差值一定是**0-(maxv-minv)**区间的，然后我们二分差值为外循环，枚举下界为内循环，得到一个区间。做法：修改二分图匹配模板：如果这个二分图的匹配点是在这个区间里的前去匹配，hungry()函数中返回是否为完美匹配，对于每一个二分的差值，只要它能找到一个满足区间条件的完美匹配，就记录一下答案。 Q：首先明白在求什么 A： 首先需要明白：图中每个数值X + 最大差值 &lt;= 最大值 我对上面的理解： 1.最大的差值是个具体的数值δ，最初可以确定的范围在[0, maxv - minv] 之间，因此可以通过二分搜索的方式来找到这个值==&gt;二分搜索 2.那怎么进行二分来缩小这个区间范围呢?Ans：如果符合最大差值的条件(表中所有数都满足 ：数值x+差值 &lt;= 最大值)，即所有点都能完成匹配，那么证明最大差值在这个区间中----&gt;完美匹配==&gt;匈牙利算法 ▲所以算法变成了，不断缩小最大差值可以取值的区间，核心： 判断所有数是否在[p, p+差值]区间内 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 150;const int inf=0x3f3f3f3f;int line[maxn][maxn]; // 邻接矩阵,表示男生是否有好感(可达)int used[maxn]; // 在位男生i匹配的那轮中,女生i是否被尝试过匹配int nxt[maxn]; // 如果匹配到了的话,那么男生是谁,女生i的对象为nxt[i]int m, n, t, maxv, minv;int l, r, mid;int p;/***input:141 1 1 12 2 2 23 3 3 34 4 4 4*/bool Find(int x)&#123; for (int i = 1; i &lt;= m; ++i)&#123; // 修改模板：增加界定二分[p, p+mid]的区间 // 判断边x是否还在[minv, minv+差值]之间 /*if条件解释:执行过程分析 如题,l=0, r=4, 第一次mid=2,p=1, 此时并不是所有点都在[1, 1+2]之间,所以匹配失败 因为1+2&lt;=4(maxv),所以p++后再进入,此时mid=2,p=2,此时仍然不是所有点在这个范围[2,2+2]内,所以失败,第一次二分失败,区间不在[l,mid]即[0,2]之间 第二次更新l=mid+1=2+1=3,mid=(3+4)/2=3 p=1时,判断是否所有点都在[1,1+3]范围,==&gt;结果是的,hungarian返回true,二分确定在[mid, r]即[3,4]之间,更新r=mid-1=3,mid=(l+r)/2=3,此时有l=r=3所以找到了最大差值mid */ if(p &lt;= line[x][i] &amp;&amp; line[x][i]&lt;= p+mid &amp;&amp; !used[i])&#123; used[i] = 1; if ( nxt[i]==0 || Find( nxt[i]) )&#123; nxt[i] = x; return true; &#125; &#125; &#125; return false;&#125;int hungarian()&#123; int sum = 0; // 这边改了，每次都是新情况 memset(nxt, 0, sizeof(nxt)); for (int i = 1; i &lt;= n; ++i)&#123; memset(used, 0, sizeof(used)); if (Find(i)) sum++; &#125; // 修改模板 return sum==n?1:0;&#125;int main(int argc, char const *argv[])&#123; int size; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; size; m = n = size; maxv = -inf; minv = inf; for (int i = 1; i &lt;= size; ++i)&#123; for (int j = 1; j &lt;= size; ++j)&#123; cin &gt;&gt; line[i][j]; maxv = max(maxv, line[i][j]); minv = min(minv, line[i][j]); &#125; &#125; l = 0; r = maxv - minv; int ans = 0; // 二分搜索，不断缩小区间 while( l &lt;= r)&#123; bool flag = false; mid = (l+r) &gt;&gt; 1; // mid为差值 // 遍历下界的搜索,枚举最小值，检查当前差值是否可以匹配成功,条件是“最小值+差值&lt;=最大值” // 核心： 判断所有数是否在[p, p+差值]区间内 for (p = minv; p+mid &lt;= maxv; ++p)&#123; if (hungarian())&#123; // 这句类似二分搜索里的if一旦找到哪个区间，就直接在这个区间里继续二分， flag = true; break; &#125; &#125; // 因为是从[min,min+mid]~[max-mid, max]的搜索,区间大小为mid,如果true,意思是最大差值mid就在[l, mid]之间 if (flag) ans = mid,r = mid-1; // 如果全不符合,那么区间小了,mid得大点,所以mid范围变为[mid, r] else l = mid+1; &#125; // 二分搜索中如果l==r，那么搜索数x的索引就是最后的mid cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 最佳匹配——KM算法 解决有权的完美匹配问题，成为最佳匹配，又称为有权完美匹配。最佳匹配同时也是完备匹配 KM算法详解+模板——含图讲解","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"Hungarian algorithm匈牙利算法","slug":"Hungarian-algorithm匈牙利算法","date":"2019-12-05T05:08:11.000Z","updated":"2019-12-22T13:50:20.336Z","comments":true,"path":"2019/12/05/Hungarian-algorithm匈牙利算法/","link":"","permalink":"https://nymrli.top/2019/12/05/Hungarian-algorithm匈牙利算法/","excerpt":"","text":"Hungarian algorithm匈牙利算法 主要用来解决不带权的分配问题，O(V*E) 首先，需要明白二分图（又名二部图）的概念 二分图Bipartite Graph 二分图是图论中一种特殊模型。设G=(V,E)是一个无向图(当且仅当图中不存在长度为奇数的环。)，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。 注意：如果一图是二分图，那么它一定没有奇环。如果一图没有奇环的话，那么它可以是二分图。(没有奇环是二分图的必要条件) ▲通常被用来解决分配、匹配问题，如资源分配、工作安排、任务调度……任务的核心本质是求配对关系，或者给顶点和边赋权，求某种条件下的最优分配问题。 △匹配问题可以用网络流解决，或者KM算法（KM算法是一种计算机算法，功能是求完备匹配下的最大权匹配），但是增广路算法更加简洁。 二分图的判定： 染色法1：假设DFS初始点A涂黑色，与它相邻的点就涂白色。如果搜到某一个点u的相邻点v已经涂色并且与u同色，就不可能是二分图啦~ 染色法2：就是给每个点进行标号，标为-1，1如果存在一条边连接的两个点标号相同，那么就是存在一个奇数环… 二分图的匹配 匹配：将E的子集M称作一个匹配(子集M中的任意两条边都没有公共端点) 最大匹配：边数最多的匹配称作最大匹配——maximal matching X(Y)完全匹配：如果X（Y）中的所有的顶点都出现在匹配M中，则称M是X(Y)完全匹配——perfect matching M完全匹配：如果M既是X-完全匹配，又是Y-完全匹配，称M是完全匹配。此时∣X∣=∣Y∣|X| = |Y|∣X∣=∣Y∣，也就是说这个匹配里的所有边刚好经过所有点一次。 最大匹配和完全匹配的应用： Q：教师-课程安排，G=&lt;U,E,V&gt;，U为教师集合，V为课程集合，E中的边&lt;u,v&gt;表示某位教师u可以上课程v。需要求最大匹配，使得每门课程有人教，每人都有课上。 A:匈牙利算法 匈牙利算法 执行过程 ①任意取一个匹配M（可以是空集或只有一条边） ②令S是非饱和点（尚未匹配的点）的集合自如果S=0，则M已经是最大匹配 ④从S中取出一个非饱和点山作为起点，从此起点走交错路（交替属于M和非M的边构成的极大无重复点通路或回路）P ③如果P是一个增广路（P的终点也是非饱和点），则令M=MeP=（M-P）U（P-M） ⑥如果P都不是增广路，则从S中去掉uo，转到step3 ▲.顶点数不同，即∣X∣≠∣Y∣|X| \\neq |Y|∣X∣​=∣Y∣的二分图一定没有完全匹配 ▲正则的∣X∣≠∣Y∣|X| \\neq |Y|∣X∣​=∣Y∣的二分图一定有完全匹配(正则:每个顶点的度数都相同) 核心思想：不断挪 増广路定理： 任意一个非最大匹配的匹配一定存在增广路。 从一个未匹配点（未盖点）出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 两个端点都是未盖点→增广路（Augmenting Path，AP） 比如：8→4→7→1→5→2，图中红色是匹配边。 特殊的：3-6也是增广路。 把AP上的匹配边和非匹配边互换，得到的匹配比刚才多一条边。 匹配点只连一条匹配边（？），这样做不会破坏匹配的性质。 增广路定理：即一个匹配是最大匹配等价于不存在增广路。 匈牙利算法的核心原理：就是不断找増广路（依据性质3），直至无法找到新的増广路，即为最大匹配。——使用递归（一直找增广路，不断交换匹配） 增广路可以用来改进匹配，最大匹配可以通过反复找增广路来求解。 已经匹配的点永远不会退出匹配，只会更换匹配 注：（匹配点又叫做盖点，非匹配点叫做未盖点（所谓“盖”指的是被一条边盖住） 实现的细节： 每次选一个未盖点u进行DFS。如果找不到u开头的增广路，则换一个未盖点进行DFS，且以后再也不从u出发找增广路。 12345678910111213141516171819202122232425262728293031struct BPM&#123; //二分图最大基数匹配，邻接矩阵写法 int n，m，G[maxn][maxn];//左右顶点个数，G[x][y]=1，边x-y int left[maxn]; //1eft[i]为右边第i个点的匹配点编号，-1表示不存在 bool T[maxn]; //T[i]为右边第i个点是否已标记 void init(int n，int m)&#123; this-&gt;n=n，this-&gt;m=m;_zero(G);&#125; bool match(int u)&#123; // 递归进行挪 for(intv=e;v&lt;m;v++) if(G[u][v]&amp;&amp;！T[v])&#123; T[v]=true; if(left[v]==-1 || match(left[v]))&#123; //left[v]！=-1，1eft[v]-v是匹配边 left[v]=u; return true; &#125; &#125; return false;&#125; int solve（)&#123; //求最大匹配 memset(left，-1，sizeof(left)); int ans=0; for(int u=e;u&lt;n;u++)&#123;//从左边结点u开始增广 _zero(T); if(match(u)) ans++;//u是未盖点 &#125; return ans; &#125;&#125;; 具体实现代码见文章：《ACM-二分图》 其他相关概念： 最小顶点覆盖： 是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相连 &amp;二分图的最小顶点覆盖数=二分图的最大匹配数 DAG最小不相交路径覆盖 也称为最小边覆盖，是指用尽量少的顶点不相交（只经过一次）的简单路径覆盖二分图中的所有顶点 路径长度可以为0 &amp;二分图的最小路径覆盖数=|V|-二分图的最大匹配数 *最小可相交路径覆盖 最大独立集 最大独立集是指寻找一个点集，使得其中任意两点在图中无对应边。 对于一般图来说，最大独立集是一个NP完全问题，对于二分图来说最大独立集 =|V| - 二分图的最大匹配数 KM(Kuhn-Munkres)算法 带权二分图最佳完美匹配，O(n^3)，（运用匈牙利算法辅助求解） 只适用于带权最大匹配一定是完备匹配的情况，实践中建议用费用流来解决。 完全二分图一定是偶数个点 可行顶标（Feasible Labeling）：结点函数（x），任意边（x，y）：1（x）+l（y）≥w（xiy）。 相等子图：G的生成子图，包含所有点以及满足l（x）+I（y）=w（x，y）的边（x，y） 如果EL有完美匹配为PM，则该M是原图的最大权匹配： PM的权和等于所有点的顶标之和SV。 G的任一个最大权匹配M，边满足w（xy）≤l（x）+（y）→M边权和≤SV=PM边权和 关键就是寻找好的可行顶标，使相等子图有完美匹配。 ==&gt;找到原图的完美匹配–只要–&gt;找到相等子图的完美匹配即可 ▲KM完成之后所有的l(x)之和最小 举个栗子: 少林决胜(Golden Tiger Claw，UVa11383) 给定一个N*N矩阵，每个格子里都有一个正整数w(i,j)。你的任务是给每行确定一个整数row(i)，每列也确定一个整数col(i)，使得对于任意格子(i, j)，w(i, j)≤row(i)+colj)。所有row(i)和col(i)之和应尽量小。 【分析】 1.行看作二分图X点，列看作二分图Y点。 2.和最佳匹配没有任何关系，KM算法副产品。 3.KM中算法等式l（x）+l（y）≥w（x，y）。行X，列Y。 4.KM过程中，所有顶标不断减小，算法结束后，所有顶标之和是最小的。 蚂蚁（Ants，NEERC2008，LA4043） 给出n个白点和n个黑点的坐标，要求用n条不相交的线段把它们连接起来，其中每条线段恰好连接一个白点和一个黑点，每个点恰好连接到一条线段，如图所示。 【分析】 点有黑白两色，构造二分图，白X黑Y。每个黑点和每个白点相连，权值等于欧氏距离。 连接方案实际上是计算一个完美匹配，匹配中假设al-b1与a2-b2相交，那么dist(a1，b1)+dist(a2，b2)&gt;dist(al，b2)+dist(a2，b1)，这两条线段改成al-b2和a2-b1后总长度会变少。 所以最小匹配中不会出现线段相交。 套KM算法即可计算最小完美匹配即可。 参考资料： 离散数学：图论：二分图的匹配——陈斌 北京大学地球与空间科学学院 二分匹配——匈牙利算法和KM算法——里面推荐的文章更值得一看 带你入门多目标跟踪（三）匈牙利算法&amp;KM算法——以图像目标跟踪距离 二分图匹配问题与匈牙利算法——里面包含概念挺全的 二分图大合集——二分图最大匹配（最小覆盖数），完美匹配以及最优匹配（带权最大匹配）——对概念的介绍比上个更准确点，推荐 二分图最大匹配以及常见模型——ACM角度 任务分配问题—匈牙利算法——含Gungary算法执行过程伪代码","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"}]},{"title":"PIL的Image笔记","slug":"PIL的Image笔记","date":"2019-11-26T10:06:58.000Z","updated":"2019-11-26T10:07:16.139Z","comments":true,"path":"2019/11/26/PIL的Image笔记/","link":"","permalink":"https://nymrli.top/2019/11/26/PIL的Image笔记/","excerpt":"","text":"PIL的Image学习 transpose和rotate transpose 1234from PIL import Imageimg = getCaptcha()# 对称反转img.transpose(Image.FLIP_LEFT_RIGHT) rotate 123456from PIL import Imageimg = getCaptcha()# expand默认为False时,超出原有尺寸的部分将用黑色填充,不会拓展尺寸img = img.rotate(45)# expand为True时,会根据图片大小,拓展尺寸img = img.rotate(45,expand=True) Pillow官网介绍 【图像处理】Python-Image 基本的图像处理 convert函数 参数为mode(图像模式)。这是一个字符串，指定图像使用的像素格式。典型值为“1”，“L”，“RGB”或“CMYK”。 1img = img.convert(\"1\") 1 (1-bit pixels, black and white, stored with one pixel per byte) L (8-bit pixels, black and white) P (8-bit pixels, mapped to any other mode using a color palette) RGB (3x8-bit pixels, true color) RGBA (4x8-bit pixels, true color with transparency mask) CMYK (4x8-bit pixels, color separation) YCbCr (3x8-bit pixels, color video format) LAB (3x8-bit pixels, the Lab color space) HSV (3x8-bit pixels, Hue, Saturation, Value color space) I (32-bit signed integer pixels) F (32-bit floating point pixels) PIL image与np.array互转 1. PIL image转换成array img = np.asarray(image)或img=np.array(image) 需要注意的是，如果出现read-only错误，并不是转换的错误，一般是你读取的图片的时候，默认选择的是&quot;r&quot;,&quot;rb&quot;模式有关。 修正的办法: 手动修改图片的读取状态 img.flags.writeable = True # 将数组改为读写模式 2. array转换成image 方法1 12from PIL import ImageImage.fromarray(np.uint8(img)) 方法2 1234import cv2cv2.imwrite(\"output.png\", out)# out可以是uint16类型数据# 16位深度图像转8位灰度 方法3 matlab 123img=imread('output.png')img1=im2uint8(img)imwrite(img1,'result.jpg') Numpy将二维数组添加到空数组 12345678910111213a=np.empty(shape=[0,3], dtype=np.int32)b = np.array([[1,2,3],[4,5,6]])c=[[7,8,9]] print(a.shape)print(b.shape) a = np.append(a, b, axis=0)a = np.append(a, c, axis=0)# 当axis为0时，数组是加在下面（列数要相同）：# 当axis为1时，数组是加在右边（行数要相同）：print(a.shape)print(b.shape) reshape函数是numpy中一个很常用的函数，作用是在不改变矩阵的数值的前提下修改矩阵的形状。 1.简单使用 1234y = np.reshape([[1,2],[3,4]],(1,4))'''array([[1, 2, 3, 4]])''' 2.使用缺省值-1 缺省值-1代表我不知道要给行（或者列）设置为几，reshape函数会根据原矩阵的形状自动调整。 1234567y = np.reshape([[1,2],[3,4]],(4,-1))'''array([[1], [2], [3], [4]])''' 1234567891011121314151617181920212223242526272829import PIL.Image as Imageimport os IMAGES_PATH = 'E:\\picture\\新垣结衣\\\\' # 图片集地址IMAGES_FORMAT = ['.jpg', '.JPG'] # 图片格式IMAGE_SIZE = 256 # 每张小图片的大小IMAGE_ROW = 4 # 图片间隔，也就是合并成一张图后，一共有几行IMAGE_COLUMN = 4 # 图片间隔，也就是合并成一张图后，一共有几列IMAGE_SAVE_PATH = 'E:\\\\picture\\\\新垣结衣\\\\final.jpg' # 图片转换后的地址 # 获取图片集地址下的所有图片名称image_names = [name for name in os.listdir(IMAGES_PATH) for item in IMAGES_FORMAT if os.path.splitext(name)[1] == item] # 简单的对于参数的设定和实际图片集的大小进行数量判断if len(image_names) != IMAGE_ROW * IMAGE_COLUMN: raise ValueError(\"合成图片的参数和要求的数量不能匹配！\") # 定义图像拼接函数def image_compose(): to_image = Image.new('RGB', (IMAGE_COLUMN * IMAGE_SIZE, IMAGE_ROW * IMAGE_SIZE)) #创建一个新图 # 循环遍历，把每张图片按顺序粘贴到对应位置上 for y in range(1, IMAGE_ROW + 1): for x in range(1, IMAGE_COLUMN + 1): from_image = Image.open(IMAGES_PATH + image_names[IMAGE_COLUMN * (y - 1) + x - 1]).resize( (IMAGE_SIZE, IMAGE_SIZE),Image.ANTIALIAS) to_image.paste(from_image, ((x - 1) * IMAGE_SIZE, (y - 1) * IMAGE_SIZE)) return to_image.save(IMAGE_SAVE_PATH) # 保存新图image_compose() #调用函数","categories":[],"tags":[{"name":"编程笔记","slug":"编程笔记","permalink":"https://nymrli.top/tags/编程笔记/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"科学计算","slug":"科学计算","permalink":"https://nymrli.top/tags/科学计算/"}]},{"title":"2019年8月23号运维笔记","slug":"2019年8月23号运维笔记","date":"2019-11-26T07:50:55.000Z","updated":"2019-11-26T07:51:12.893Z","comments":true,"path":"2019/11/26/2019年8月23号运维笔记/","link":"","permalink":"https://nymrli.top/2019/11/26/2019年8月23号运维笔记/","excerpt":"","text":"2019年8月23号运维笔记 docker docker stop containerID，以后再重新启动时报错 1Error response from daemon: driver failed programming external connectivity on endpoint app (3c0c01ac6b42b7a420644fc2b4debfbbcc0e1d2e74e6294155c28aca82f794c4): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 12345 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name. A: 重启docker即可：systemctl restart docker 再开启你的容器： docker run xxxx或docker start xxx 查看docker容器的运行日志 docker logs containerID docker端口映射到宿主机后外网仍无法访问容器的web A： 1234567891011121314# 解决办法：$ sudo vi /etc/sysctl.conf或者$ sudo vi /usr/lib/sysctl.d/00-system.conf# 添加如下代码：net.ipv4.ip_forward=1重启network服务$ sudo systemctl restart network查看是否修改成功$ sudo sysctl net.ipv4.ip_forward#如果返回为“net.ipv4.ip_forward = 1”则表示成功了 nginx 查看nginx安装路径 ps -ef | grep nginx 查看nginx日志 systemctl status nginx.service journalctl -xe 指定运行配置文件 直接运行nginx可执行文件即可启动，nginx会自动读取配置文件目录下的“nginx.conf”配置文件，也可以在后面接“-c”参数来指定配置文件： /usr/sbin/nginx -c /etc/nginx/sites-enabled/nginx.conf 校验配置文件是否正确 由于nginx的配置文件比较复杂容易出错，修改配置后可以用“-t”参数来校验配置文件是否正确： 12nginx -t # 校验默认的配置文件nginx -t -c /path/to/configfile # 校验指定配置文件 了解日志管理 我们查看nginx安装目录下（/var/log/nginx）有个logs，包含了三个文件 “access.log 、error.log、nginx.pid”。 当然，日志配置肯定也是通过nginx.conf配置文件来进行配置的 ，那我先来看配置文件是怎么写的。 access_log logs/access.log main这个是指access.log日志用main格式来显示。 error_log logs/error.log error main格式是什么？mian格式是我们已经定义好了的一种各种，并取个名字便于引用。 默认的main格式中具体用了哪些选项来记录日志呢？ 12345678910111213141516$remote_addr, $http_x_forwarded_for 记录客户端IP地址$remote_user 记录客户端用户名称$request 记录请求的URL和HTTP协议$status 记录请求状态$body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。$bytes_sent 发送给客户端的总字节数。$connection 连接的序列号。$connection_requests 当前通过一个连接获得的请求数量。$msec 日志写入时间。单位为秒，精度是毫秒。$pipe 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。$http_referer 记录从哪个页面链接访问过来的$http_user_agent 记录客户端浏览器相关信息$request_length 请求的长度（包括请求行，请求头和请求正文）。$request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。$time_iso8601 ISO8601标准格式下的本地时间。$time_local 通用日志格式下的本地时间。 nginx.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445//该文件是存放到nginx安装目录下conf文件夹中 //全局区 //代表着当前有一个工作的子进程，可以自行修改，但是太多了无益因为会争夺cpu资源。一般最多设置成cpu数*核数worker_processes 1; //一般配置nginx的连接特性events &#123; //这里是指一个子进程最大允许连接1024个连接 worker_connections 1024;&#125; //这里是配置http服务器的主要段http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; //这里配置的是日志的显示格式 #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; //这里调用指定日志显示的格式 #access_log logs/access.log main; //这里是配置虚拟主机段 server &#123; listen 80;//监听的端口 server_name localhost;//监听访问地址 #charset koi8-r; #access_log logs/host.access.log main; //定位，把特殊的文件或者路径再次定位 location / &#123; root html;//定位的目录，默认是ngxin安装目录下的html文件夹中 index index.html index.htm;//定位的具体文件 &#125; nginx日志分析 分析截止目前为止访问量最高的IP排20名。 awk'{print $1}' /usr/local/nginx/logs/access.log |sort | uniq-c I|sort -nr 分析从早上9点至中午12点总的访问量。 sed-n&quot;/2016:09:00/,/2016:12:00/&quot; paccess_20161121.log 分析上一秒的访问请求数。 sed -n&quot;/2016：09：00：00/&quot; paccess_20161121.log https签名：https://www.jianshu.com/p/0d455c7a9326 Q：nginx和uwsgi区别 nginx的作用： 1.反向代理，可以拦截一些web攻击，保护后端的web服务器 2.负载均衡，根据轮询算法，分配请求到多节点web服务器 3.缓存静态资源，加快访问速度，释放web服务器的内存占用，专项专用 uWSGI的适用： 1.单节点服务器的简易部署 2.轻量级，好部署 Q：已知一个使用nginx配置的web服务器的域名为www.my.com监听80端口,假设在服务器的/var/www/html这个目录下面有静态文件index.html,那么在配置文件其它部分相同的情况下，分别使用下面两种配置： 12345678Location /abc &#123; root /var/www/html; index index.html; &#125;location/abc &#123; alias /var/ww/html/; index index.html;&#125; 访问http://www.my.com/abc分别会有什么结果？ A： root 的为/var/www/html/abc/index.html alias的为/var/www/html/index.html Q：所以使用浏览器访问的话这两种配置会有什么区别？ A：root的为404，alias的为200. 注：如果通过两个路径都能访问到的话，那无论哪个配置都是200","categories":[],"tags":[{"name":"编程笔记","slug":"编程笔记","permalink":"https://nymrli.top/tags/编程笔记/"},{"name":"运维","slug":"运维","permalink":"https://nymrli.top/tags/运维/"}]},{"title":"app测试","slug":"app测试","date":"2019-11-26T07:49:58.000Z","updated":"2019-11-26T07:50:10.506Z","comments":true,"path":"2019/11/26/app测试/","link":"","permalink":"https://nymrli.top/2019/11/26/app测试/","excerpt":"","text":"app测试 命令 adb shell monkey 500随机执行500次 adb shell pm list packages -3 查看第三方包 adb shell monkey -p tv.danmaku.bili指定在某个软件中随机压力测试 adb shell monkey -p tv.danmaku.bili -p com.umaman.laiyifen 500会先执行来伊份 ▲.在测试应用程序某些选项的同时，也会进行系统级功能的测试，如截图、调音量等 adb shell monkey [-options] times 参数说明 1234567-s seed种子值：种子相同时，就能产生一样的伪随机操作序列-p package指定包名：压力测试执行在某个软件内--pct-touch percentage：指定触摸的比例--throttle MILLSEC ：设置每个操作之间的间隔为xx毫秒-v [-v [-v]]：输出日志，v越多越详细--ignore-crashes ：不管程序有无崩溃，都执行完所有操作 各事件比例（Event percentages:） 0: 50.0% -pct-touch 触摸操作 1: 5.8823533% -pct-motion 移动操作 2: 1.1764706% -pct-pinchzoom 缩放操作 3: 8.82353% -pct-traceball 滚动操作 异常 event injected数量不对 crash闪退 ANR没有响应 出现异常后，需要提供给开发的东西 l.被测手机详细信息 2.monkey测试日志 3.手机运行截图 4.monkey运行射手机日志 测试用例 测试用例设计三部曲 要测试什么 -业务 怎么纠样测试 -测试环境搭建 如何判新正确与否 -需求 测试计划 不同的环境下（兼容性） 正常安装 空间不足-&gt;验证松勤安卓APP在HWX空间不足的条件下的安装行为 √正常行为：提示空间不够 x死机 提示错误代码，emor code201 安装过程没电-重新安装 断网-网络Fiddler 常用功能测试点 常用的功能测试方法有“界面测试方法”和“黑盒测试技术”，具体可参见测试组配置库中的相应文档。下面列举了一些常用的功能测试点： 1.页面链接检查每一个链接是否都有对应的页面，并且页面之间切换正确。 2.相关性检查：删除/增加一项会不会对其他项产生影响，如果产生影响，这些影响是否都正确。 3.检查按钮的功能是否正确：如新增、修改、取消、删除、保存等功能是否正确。 4.字符串长度检查：输入超出需求规定的字符串长度的内容，看系统是否检查字符串长度，会不会有提示窗口。 5.字符类型检查：在应该输入指定类型的内容的地方输入其他类型的内容（如在应该输入整型的地方输入其他字符类型），看系统是否检查字符类型，是否会有提示窗口。 6.标点符号检查：输入内容包括各种标点符号，特别是空格，各种引号，回车键，看系统是否会有异常错误。 7.信息重复：在一些需要命名，且名字应该唯一的地方输入重复的名字或ID，看系统怎么处理，是否报错；重名是否区分大小写，以及在输入内容的前后输入空格，系统是否作出正确处理。 8.检查删除功能：在一些可以一次删除多个信息的地方，不选择任何信息，进行删除，看系统如何处理，是否出错；选择一个和多个信息，进行删除，看是否正确处理。 9.检查添加和修改是否一致：检查添加和修改信息的要求是否一致，如添加要求必填的项，修改也应该必填；添加规定为整型的项，修改也必须为整型。 10.检查修改重名：修改时把不能重名的项改为已存在的内容，看系统是否处理，报重名的错。 11.重复提交表单：一条已经成功提交的纪录，退出后再提交，看看系统是否会做什么处理。 12.查询功能：在有查询功能的地方输入系统存在和不存在的内容，结果是否正确；如果可以输入多个查询条件，同时添加合理和不合理的条件，看系统处理是否正确。 13.输入信息位置：注意在光标停留的地方输入信息时，光标和所输入的信息是否跳到别的地方。 14.上传下载文件检查：上传下载文件的功能是否实现，上传文件是否能打开。对上传文件的格式有何规定，系统是否有提示信息。 15.必填项检查：应该填写的项没有填写时系统是否都做了处理，对必填项是否有提示信息，如在必填项放加*。 16.快捷键检查：是否支持常用快捷键，如Ctl+C Ctrl+V Backspace等，对一些不允许输入信息的字段，如选人，选日期是否也有快捷键。 17.回车键检查：在输入结束后直接按回车键，看系统处理如何，会否报错。","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://nymrli.top/tags/测试/"}]},{"title":"2019-9月7号C++编程笔记","slug":"2019-9月7号C-编程笔记","date":"2019-11-26T07:47:55.000Z","updated":"2019-11-26T07:48:23.861Z","comments":true,"path":"2019/11/26/2019-9月7号C-编程笔记/","link":"","permalink":"https://nymrli.top/2019/11/26/2019-9月7号C-编程笔记/","excerpt":"","text":"2019-9月7号C++编程笔记 auto 定义变量时放在变量前，无需知道具体变量类型，系统可自行推断类型，减少编程工作，特别是在模板使用时，使用更方便。 123456789101112131415161718auto a=1;auto b='a';auto s=\"abdc\";auto c;//这样使用时错误的，系统无法自动推断出变量类型//下面为迭代指针使用，很方便vector&lt;int&gt; vec;auto it=vec.begin();/**模板使用案例*/template&lt;typename InputIterator&gt; TreeNode *creatTree(InputIterator in_beg,InputIterator in_end...) &#123; ..... auto inRootPos=find(in_beg,in_end,val); ...... &#125; std::next 123// Defined in header &lt;iterator&gt;template&lt; class ForwardIt &gt;ForwardIt next( ForwardIt it, typename std::iterator_traits&lt;ForwardIt&gt;::difference_type n = 1 ); Parameters: it – 迭代指针 n – 向前进的元素个数，缺省默认为1 Return value The nth successor of iterator it.（返回it的第n个后继迭代指针） 1234for (int i = 0; i &lt; vals.size(); ++i) &#123; // *std::next(vals.cbegin(), i)遍历set的所有值，每次取出一个val // count为计算values中包含val的个数 int count = std::count(values.cbegin(), values.cend(), *std::next(vals.cbegin(), i)); std::prev 123// 使用方法与next相似，不同的是prev返回的是it的第n个前驱迭代指针,即返回指针是begin()和rbegin()区别template&lt; class BidirIt &gt;BidirIt prev( BidirIt it, typename std::iterator_traits&lt;BidirIt&gt;::difference_type n = 1 ); std::advance 方法与prev和next相似，只是无返回指针 12345template&lt;class ForwardIt&gt;ForwardIt next(ForwardIt it, typename std::iterator_traits&lt;ForwardIt&gt;::difference_type n = 1)&#123; std::advance(it, n); return it;&#125; const_cast 去掉const属性：const_cast&lt;int*&gt; (&amp;num)，常用，因为不能把一个const变量直接赋给一个非const变量，必须要转换。 加上const属性：const int* k = const_cast&lt;const int*&gt;(j)，一般很少用，因为可以把一个非const变量直接赋给一个const变量，比如：const int* k = j; 1binary_tree* tmp = const_cast&lt;binary_tree*&gt;(node); C++11对vector成员函数的扩展 emplace_back std::vector::cbegin和std::vector::cend 这两个方法是与std::vector::begin和std::vector::end相对应的，从字面就能看出来，多了一个’c’，顾名思义就是const的意思。同理，std::vector::crbegin和std::vector::crend std::vector::emplace 之前已经对emplace_back进行了讨论，其实还有一个方法叫emplace。 我想说的就是，emplace之于emplace_back就像insert之于push_back。如下使用 12345678910111213141516171819202122&lt;code class=\"hljs cpp\"&gt;#include &lt;iostream&gt;#include &lt;vector&gt; int main ()&#123; std::vector&lt;int&gt; myvector = &#123;10,20,30&#125;; auto it = myvector.emplace ( myvector.begin()+1, 100 ); myvector.emplace ( it, 200 ); myvector.emplace ( myvector.end(), 300 ); std::cout &lt;&lt; \"myvector contains:\"; for (auto&amp; x: myvector) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output:myvector contains: 10 200 100 20 30 300&lt;/int&gt;&lt;/vector&gt;&lt;/iostream&gt;&lt;/code&gt; std::vector::data Returns a direct pointer to the memory array used internally by the vector to store its owned elements. 1234567891011121314151617&lt;code class=\"hljs cpp\"&gt;#include &lt;iostream&gt;#include &lt;vector&gt; int main ()&#123; std::vector&lt;int&gt; myvector (5); int* p = myvector.data(); *p = 10; ++p; *p = 20; p[2] = 100; std::cout &lt;&lt; \"myvector contains:\"; for (unsigned i=0; i&lt;myvector.size(); ++i) std::cout &lt;&lt; myvector[i] &lt;&lt; '\\n'; return 0;&#125; =\"\" output:=\"\" myvector=\"\" contains:=\"\" 10=\"\" 20=\"\" 0=\"\" 100=\"\" 0&lt;/int&gt;&lt;/vector&gt;&lt;/iostream&gt;&lt;/code&gt;","categories":[],"tags":[{"name":"编程笔记","slug":"编程笔记","permalink":"https://nymrli.top/tags/编程笔记/"}]},{"title":"MinMax-极小极大算法——2048","slug":"MinMax-极小极大算法——2048","date":"2019-11-26T07:46:41.000Z","updated":"2020-02-04T03:45:53.681Z","comments":true,"path":"2019/11/26/MinMax-极小极大算法——2048/","link":"","permalink":"https://nymrli.top/2019/11/26/MinMax-极小极大算法——2048/","excerpt":"","text":"MinMax-极小极大算法——2048 算法介绍 MinMax 大家在编程的时候应该或多或少都接触到过这样的写法:min(max(xxx,yyy))，MinMax算法的表达形式就是如此，不过其中的Min和Max都是具有对应含义的。 一般解决博弈类问题的自然想法是将格局组织成一棵），树的每一个节点表示一种格局，而父子关系表示由父格局经过一步可以到达子格局。Minimax也不例外，它通过对以当前格局为根的格局树搜索来确定下一步的选择。而一切格局树搜索算法的核心都是对每个格局价值的评价。Minimax算法基于以下朴素思想确定格局价值： Minimax是一种悲观算法，即假设对手每一步都会将我方引入从当前看理论上价值最小的格局方向，即对手具有完美决策能力。因此我方的策略应该是选择那些对方所能达到的让我方最差情况中最好的，也就是让对方在完美决策下所对我造成的损失最小。 Minimax不找理论最优解，因为理论最优解往往依赖于对手是否足够愚蠢，Minimax中我方完全掌握主动，如果对方每一步决策都是完美的，则我方可以达到预计的最小损失格局，如果对方没有走出完美决策，则我方可能达到比预计的最悲观情况更好的结局。总之我方就是要在最坏情况中选择最好的。 举例For Example： 现在考虑这样一个游戏：有三个盘子A、B和C，每个盘子分别放有三张纸币。A放的是1、20、50；B放的是5、10、100；C放的是1、5、20。单位均为“元”。有甲、乙两人，两人均对三个盘子和上面放置的纸币有可以任意查看。游戏分三步： 甲从三个盘子中选取一个。 乙从甲选取的盘子中拿出两张纸币交给甲。 甲从乙所给的两张纸币中选取一张，拿走。 其中甲的目标是最后拿到的纸币面值尽量大，乙的目标是让甲最后拿到的纸币面值尽量小。 分析过程可看 MinMax和Alpha-beta剪枝分析[转] Alpha-beta剪枝 是在Minmax的基础上通过对每个结点下界alpha和上界beta值的维护进行了剪枝 偶数层为Max层（己方），奇数层为Min层（对手），其中root为当前形势。 执行过程 在root层，α′=max(N1.β,N2.β,...,Ni.β)==(self.β,Ni.β)\\alpha&#x27; = max(N_1.\\beta, N_2.\\beta,...,N_i.\\beta)==(self.\\beta,N_i.\\beta)α′=max(N1​.β,N2​.β,...,Ni​.β)==(self.β,Ni​.β) 在Max层 初始，α′=max(−∞,N.β)\\alpha&#x27;=max(-\\infty, N.\\beta)α′=max(−∞,N.β) 非叶子节点更新(包括根节点), α′=max(α,N1.β,...,Ni.β)\\alpha&#x27;=max(\\alpha,N_1.\\beta,...,N_i.\\beta)α′=max(α,N1​.β,...,Ni​.β) 叶子节点更新, α′=max(self.α,N1.v,...,Ni.v)\\alpha&#x27;=max(self.\\alpha, N_1.v,...,N_i.v)α′=max(self.α,N1​.v,...,Ni​.v) 根节点更新，α′=max(α,N1.β,...,Ni.β)\\alpha&#x27;=max(\\alpha,N_1.\\beta,...,N_i.\\beta)α′=max(α,N1​.β,...,Ni​.β) ▲更新后发现self.α′&gt;self.βself.\\alpha&#x27;&gt;self.\\betaself.α′&gt;self.β则剪枝，不再搜索 在Min层, 初始，β′=min(∞,N.v)\\beta&#x27;=min(\\infty, N.v)β′=min(∞,N.v) 叶子节点更新，β′=min(N1.v,...,Ni.v)\\beta&#x27;=min(N_1.v,...,N_i.v)β′=min(N1​.v,...,Ni​.v) 非叶子节点更新, β′=min(self.β,N1.α,...,Ni.α)\\beta&#x27;=min(self.\\beta,N_1.\\alpha,...,N_i.\\alpha)β′=min(self.β,N1​.α,...,Ni​.α) ▲更新后发现self.β′&lt;self.αself.\\beta&#x27;&lt;self.\\alphaself.β′&lt;self.α则剪枝，不再搜索 △其中N为子节点; self.α表示当前节点已更新的α值 伪代码 1234567891011121314151617function alphabeta(node, depth, α, β, Player) //达到最深搜索深度或胜负已分 if depth = 0 or node is a terminal node return the heuristic value of node if Player = MaxPlayer // 极大节点 for each child of node // 子节点是极小节点 α := max(α, alphabeta(child, depth-1, α, β, not(Player) )) if β ≤ α // 该极大节点的值&gt;=α&gt;=β，该极大节点后面的搜索到的值肯定会大于β，因此不会被其上层的极小节点所选用了。对于根节点，β为正无穷 break //beta剪枝 return α else // 极小节点 for each child of node //子节点是极大节点 β := min(β, alphabeta(child, depth-1, α, β, not(Player) )) // 极小节点 if β ≤ α // 该极大节点的值&lt;=β&lt;=α，该极小节点后面的搜索到的值肯定会小于α，因此不会被其上层的极大节点所选用了。对于根节点，α为负无穷 break //alpha剪枝 return β 2048AI介绍 游戏规则: 2048游戏共有16个格子，初始时初始数字由2或者4构成，之后每次移动生成2的概率为0.9，生成4的概率为0.1，见2048随机生成新数字源码。 1、手指向一个方向滑动，所有格子会向那个方向运动。 2、相同数字的两个格子，相撞时数字会相加。 3、每次滑动时，空白处会随机刷新出一个数字的格子。 4、当界面不可运动时（当界面全部被数字填满时），游戏结束；当界面中最大数字是2048时，游戏胜利。 建模: 之前的对弈类游戏, 博弈双方的地位都是对等的. 但这边只有游戏者一人, 对手在哪里? 让人脑洞大开的是, 2048游戏AI的设计者, 创造性把棋局环境本身做为了博弈的另一方. 当然双方追求的胜利目标不一样: • 我方：游戏者(AI)， 追求2048及2048以上的方块出现 • 对方：计算机(棋局环境)， 填满棋局格子, 使得4个方向皆不能移动 • 胜利条件：出现某个方块的数值为“2048”。 •失败条件：格子全满，且无法向四个方向中任何一个方向移动（均不能触发合并）。 ▲.游戏模型就被建模成了信息完备的双人对弈问题. 而传统博弈树和技巧就自然有了用武之地. 评估函数: 评估函数是算法的核心，如何评价当前格局的价值是重中之重。依据游戏经验, 作者选用了如下评估因素: (1) 单调性: 指方块从左到右、从上到下均遵从递增或递减. (2) 平滑性: 指每个方块与其直接相邻方块数值的差，其中差越小越平滑. (3) 空格数: 局面的空格总数. (4) 最大数: 当前局面的最大数字, 该特征为积极因子. 采用线性函数, 并添加权重系数: 123456789101112131415161718// static evaluation functionAI.prototype.eval = function() &#123; var emptyCells = this.grid.availableCells().length; var smoothWeight = 0.1, //monoWeight = 0.0, //islandWeight = 0.0, mono2Weight = 1.0, emptyWeight = 2.7, maxWeight = 1.0; return this.grid.smoothness() * smoothWeight //+ this.grid.monotonicity() * monoWeight //- this.grid.islands() * islandWeight + this.grid.monotonicity2() * mono2Weight + Math.log(emptyCells) * emptyWeight + this.grid.maxValue() * maxWeight;&#125;; 分析：前3项能衡量一个局面的好坏, 而最大数该项, 则让游戏AI多了一点积极和&quot;冒险&quot; 执行过程 游戏AI的决策过程, 是标准的maxmin search和alpha+beta pruning的实现. 所有的方向(上下左右)都会去尝试. Alpha+beta pruning + worst consideration pruning 然而在游戏本身做决策时, 在Min节点还采用了另一种剪枝，即只考虑对方走出让格局最差的那一步（而实际2048中计算机的选择是随机的），做为搜索分支的剪枝条件，即不是每个空格都去尝试填{2, 4}。 这种假定环境生成了最坏的局面的剪枝做法，可以很好地提高搜索效率，并且获得更强的生存能力。如果全部搜索的话，对方所有可能的选择就为变成了“空格数×2”种，使得搜索效率很低，严重限制搜索深度。而这种选择性地丢掉了很多搜索分支，能够大大地提高搜索效率。 12345678910111213141516171819202122232425// try a 2 and 4 in each cell and measure how annoying it is// with metrics from evalvar candidates = [];var cells = this.grid.availableCells();var scores = &#123; 2: [], 4: [] &#125;;for (var value in scores) &#123; for (var i in cells) &#123; scores[value].push(null); var cell = cells[i]; var tile = new Tile(cell, parseInt(value, 10)); this.grid.insertTile(tile); scores[value][i] = -this.grid.smoothness() + this.grid.islands(); this.grid.removeTile(cell); &#125;&#125; // now just pick out the most annoying movesvar maxScore = Math.max(Math.max.apply(null, scores[2]), Math.max.apply(null, scores[4]));for (var value in scores) &#123; // 2 and 4 for (var i=0; i&lt;scores[value].length; i++) &#123; if (scores[value][i] == maxScore) &#123; candidates.push( &#123; position: cells[i], value: parseInt(value, 10) &#125; ); &#125; &#125;&#125; 分析：对于选择性忽略搜索节点, 其实很有争议. 在某些情况下, 会失去获取最优解的机会. 不过砍掉了很多分支后, 其搜索深度大大加强. 生存能力更强大. 限时的迭代深搜 12345678910111213141516// performs iterative deepening over the alpha-beta searchAI.prototype.iterativeDeep = function() &#123; var start = (new Date()).getTime(); var depth = 0; var best; do &#123; var newBest = this.search(depth, -10000, 10000, 0 ,0); if (newBest.move == -1) &#123; break; &#125; else &#123; best = newBest; &#125; depth++; &#125; while ( (new Date()).getTime() - start &lt; minSearchTime); return best&#125; 该代码没有限制搜索的深度，但是限制了每次“思考”的时间：超时判断在每个深度探索结束后进行, 这未必会精确, 甚至误差很大. 我还是推崇前文谈到过的实现方式.但不管怎样, 作者基本达到了其每100ms决策一步的要求. Python实现核心代码: 12 附录 极大极小算法有些不明白 ? 极小极大算法主要应用于什么样的游戏： 零和游戏（Zero-sum Game） 完全信息（Perfect Information）——Max代表你自己，Min代表你的对手 对弈类游戏的人工智能(5)–2048游戏AI的解读 把环境拟人化的对弈模型, 也是面对反馈类场景的一种很好的评估决策思路. 2048-AI程序算法分析——Java实现 一图流解释 Alpha-Beta 剪枝(Alpha-Beta Pruning) 2048高分技巧 1、最大数尽可能放在角落。 2、数字按顺序紧邻排列。 3、首先满足最大数和次大数在的那一列/行是满的。 4、时刻注意活动较大数（32以上）旁边要有相近的数。 5、以大数所在的一行为主要移动方向 6、不要急于“清理桌面”。 2048随机生成新数字源码 12345678910// Adds a tile in a random positionGrid.prototype.addRandomTile = function () &#123; if (this.cellsAvailable()) &#123; var value = Math.random() &lt; 0.9 ? 2 : 4; //var value = Math.random() &lt; 0.9 ? 256 : 512; var tile = new Tile(this.randomAvailableCell(), value); this.insertTile(tile); &#125;&#125;; ▲需要注意的是，2的几率是0.9，4的几率是0.1，但是除了开局会随机出现1或者2个方块，而在正常游戏中每次移动后只出现一个随机方块。——我当时自己写的是随机1-2个，导致我的分数挺低的。","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"},{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"MinMax和Alpha-beta剪枝分析[转]","slug":"MinMax和Alpha-beta剪枝分析-转","date":"2019-11-26T07:45:45.000Z","updated":"2019-11-26T07:46:23.931Z","comments":true,"path":"2019/11/26/MinMax和Alpha-beta剪枝分析-转/","link":"","permalink":"https://nymrli.top/2019/11/26/MinMax和Alpha-beta剪枝分析-转/","excerpt":"","text":"MinMax和Alpha-beta剪枝分析[转] 一般解决博弈类问题的自然想法是将格局组织成一棵），树的每一个节点表示一种格局，而父子关系表示由父格局经过一步可以到达子格局。Minimax也不例外，它通过对以当前格局为根的格局树搜索来确定下一步的选择。而一切格局树搜索算法的核心都是对每个格局价值的评价。Minimax算法基于以下朴素思想确定格局价值： Minimax是一种悲观算法，即假设对手每一步都会将我方引入从当前看理论上价值最小的格局方向，即对手具有完美决策能力。因此我方的策略应该是选择那些对方所能达到的让我方最差情况中最好的，也就是让对方在完美决策下所对我造成的损失最小。 Minimax不找理论最优解，因为理论最优解往往依赖于对手是否足够愚蠢，Minimax中我方完全掌握主动，如果对方每一步决策都是完美的，则我方可以达到预计的最小损失格局，如果对方没有走出完美决策，则我方可能达到比预计的最悲观情况更好的结局。总之我方就是要在最坏情况中选择最好的。 实际举例: 现在考虑这样一个游戏：有三个盘子A、B和C，每个盘子分别放有三张纸币。A放的是1、20、50；B放的是5、10、100；C放的是1、5、20。单位均为“元”。有甲、乙两人，两人均对三个盘子和上面放置的纸币有可以任意查看。游戏分三步： 甲从三个盘子中选取一个。 乙从甲选取的盘子中拿出两张纸币交给甲。 甲从乙所给的两张纸币中选取一张，拿走。 其中甲的目标是最后拿到的纸币面值尽量大，乙的目标是让甲最后拿到的纸币面值尽量小。 下面用Minimax算法解决这个问题。 解题： 建树 下图是上述示例问题的格局树： 注意，由于示例问题格局数非常少，我们可以给出完整的格局树。这种情况下我可以找到Minimax算法的全局最优解。而真实情况中，格局树非常庞大，即使是计算机也不可能给出完整的树，因此我们往往只搜索一定深度，这时只能找到局部最优解。 我们从甲的角度考虑。其中正方形节点表示轮到我方（甲），而三角形表示轮到对方（乙）。经过三轮对弈后（我方-对方-我方），将进入终局。黄色叶结点表示所有可能的结局。从甲方看，由于最终的收益可以通过纸币的面值评价，我们自然可以用结局中甲方拿到的纸币面值表示终格局的价值。 下面考虑倒数第二层节点，在这些节点上，轮到我方选择，所以我们应该引入可选择的最大价值格局，因此每个节点的价值为其子节点的最大值： 这些轮到我方的节点叫做max节点，max节点的值是其子节点最大值。 倒数第三层轮到对方选择，假设对方会尽力将局势引入让我方价值最小的格局，因此这些节点的价值取决于子节点的最小值。这些轮到对方的节点叫做min节点。 最后，根节点是max节点，因此价值取决于叶子节点的最大值。最终完整赋值的格局树如下： 总结一下Minimax算法的步骤： 首先确定最大搜索深度D，D可能达到终局，也可能是一个中间格局。 在最大深度为D的格局树叶子节点上，使用预定义的价值评价函数对叶子节点价值进行评价。 自底向上为非叶子节点赋值。其中max节点取子节点最大值，min节点取子节点最小值。 每次轮到我方时（此时必处在格局树的某个max节点），选择价值等于此max节点价值的那个子节点路径。 在上面的例子中，根节点的价值为20，表示如果对方每一步都完美决策，则我方按照上述算法可最终拿到20元，这是我方在Minimax算法下最好的决策。格局转换路径如下图红色路径所示： 对于真实问题中的Minimax，再次强调几点： 真实问题一般无法构造出完整的格局树，所以需要确定一个最大深度D，每次最多从当前格局向下计算D层。 因为上述原因，Minimax一般是寻找一个局部最优解而不是全局最优解，搜索深度越大越可能找到更好的解，但计算耗时会呈指数级膨胀。 也是因为无法一次构造出完整的格局树，所以真实问题中Minimax一般是边对弈边计算局部格局树，而不是只计算一次，但已计算的中间结果可以缓存。 Alpha-beta剪枝 简单的Minimax算法有一个很大的问题就是计算复杂性。由于所需搜索的节点数随最大深度呈指数膨胀，而算法的效果往往和深度相关，因此这极大限制了算法的效果。 Alpha-beta剪枝是对Minimax的补充和改进。采用Alpha-beta剪枝后，我们可不必构造和搜索最大深度D内的所有节点，在构造过程中，如果发现当前格局再往下不能找到更好的解，我们就停止在这个格局及以下的搜索，也就是剪枝。 Alpha-beta基于这样一种朴素的思想：时时刻刻记得当前已经知道的最好选择，如果从当前格局搜索下去，不可能找到比已知最优解更好的解，则停止这个格局分支的搜索（剪枝），回溯到父节点继续搜索。 Alpha-beta算法可以看成变种的Minimax，基本方法是从根节点开始采用深度优先的方式构造格局树，在构造每个节点时，都会读取此节点的alpha和beta两个值，其中alpha表示搜索到当前节点时已知的最好选择的下界，而beta表示从这个节点往下搜索最坏结局的上界。由于我们假设对手会将局势引入最坏结局之一，因此当beta小于alpha时，表示从此处开始不论最终结局是哪一个，其上限价值也要低于已知的最优解，也就是说已经不可能此处向下找到更好的解，所以就会剪枝。 下面同样以上述示例介绍Alpha-beta剪枝算法的工作原理。我们从根节点开始，详述使用Alpha-beta的每一个步骤： 根节点的alpha和beta分别被初始化为−∞−∞，和+∞+∞。 深度优先搜索第一个孩子，不是叶子节点，所以alpha和beta继承自父节点，分别为−∞−∞，和+∞+∞ 搜索第三层的第一个孩子，同上。 搜索第四层，到达叶子节点，采用评价函数得到此节点的评价值为1。 此叶节点的父节点为max节点，因此更新其alpha值为1，表示此节点取值的下界为1。 再看另外一个子节点，值为20，大于当前alpha值，因此将alpha值更新为20。 此时第三层最左节点所有子树搜索完毕，作为max节点，更新其真实值为当前alpha值：20。 由于其父节点（第二层最左节点）为min节点，因此更新其父节点beta值为20，表示这个节点取值最多为20。 搜索第二层最左节点的第二个孩子及其子树，按上述逻辑，得到值为50（注意第二层最左节点的beta值要传递给孩子）。由于50大于20，不更新min节点的beta值。 搜索第二层最左节点的第三个孩子。当看完第一个叶子节点后，发现第三个孩子的alpha=beta，此时表示这个节点下不会再有更好解，于是剪枝。 继续搜索B分支，当搜索完B分支的第一个孩子后，发现此时B分支的alpha为20，beta为10。这表示B分支节点的最大取值不会超过10，而我们已经在A分支取到20，此时满足alpha大于等于beta的剪枝条件，因此将B剪枝。并将B分支的节点值设为10，注意，这个10不一定是这个节点的真实值，而只是上线，B节点的真实值可能是5，可能是1，可能是任何小于10的值。但是已经无所谓了，反正我们知道这个分支不会好过A分支，因此可以放弃了。 在C分支搜索时遇到了与B分支相同的情况。因此讲C分支剪枝。 此时搜索全部完毕，而我们也得到了这一步的策略：应该走A分支。 可以看到相比普通Minimax要搜索18个叶子节点相比，这里只搜索了9个。采用Alpha-beta剪枝，可以在相同时间内加大Minimax的搜索深度，因此可以获得更好的效果。并且Alpha-beta的解和普通Minimax的解是一致的。 文章摘自2048-AI程序算法分析","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"},{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"Python网络编程Websocket","slug":"Python网络编程Websocket","date":"2019-11-24T02:17:11.000Z","updated":"2019-11-28T12:00:00.222Z","comments":true,"path":"2019/11/24/Python网络编程Websocket/","link":"","permalink":"https://nymrli.top/2019/11/24/Python网络编程Websocket/","excerpt":"","text":"网络知识——Websocket TCP ：面向连接—&gt; 打电话(相互回复,一来一回)，客户端向服务器端 拨号 , 三次握手 , UDP : 面向无连接 --&gt; 寄快递(寄出去就不管了) e.g.直播 UDP四层结构 网络访问层(链路层): 物理连接设备(网线)、MAC地址（物理地址） 互联网层： IP地址（定位设备） 传输层： port (端口号) : 表示通信进程,将数据交给哪个应用处理 应用层： 自己定义的协议（处理字符串消息的方法） 套接字(socket) ： 特殊的设备文件 ， 写网络应用程序的接口，写入后就是发送，接收就是读取。 类似于 esp8266吧… 基本的socket操作 1234567891011121314import sockets = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) '''参数说明:AF_INET IPv4----STREAM TCPSOCK_DGRAM UDP,无listen、accpet'''server_addr = ('127.0.0.1',8888) # 本地回环地址 , 端口s.bind(server_addr) # 绑定、传入信息data, cilent_addr = s.recvfrom(1024) # BUF_SIZE指定接收数据长度 , (数据内容,客户端地址)s.sendto(data,cilent_addr) # 给客户端发送数据 12345678910import socketbuf = 1024ADDR = (\"127.0.0.1\", 8999)tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)tcpSock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)tcpSock.bind(ADDR)tcpSock.listen(5)conn, addr = tcpSock.accept() 什么是webscoket？ WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。HTML5 WebSocket 设计出来的目的就是要取代轮询和 Comet 技术，使客户端浏览器具备像 C/S 架构下桌面系统的实时通讯能力。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，其本质是保持TCP连接。 客户端 : 发送数据、接收返回数据端 服务端: 处理数据端 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import socket,base64,hashlibdef get_headers(data): '''提取请求头,将请求头转换为字典''' header_dict = &#123;&#125; data = str(data,encoding=\"utf-8\") header,body = data.split(\"\\r\\n\\r\\n\",1) header_list = header.split(\"\\r\\n\") for i in range(0,len(header_list)): if i == 0: if len(header_list[0].split(\" \")) == 3: header_dict['method'],header_dict['url'],header_dict['protocol'] = header_list[0].split(\" \") else: k,v=header_list[i].split(\":\",1) header_dict[k]=v.strip() return header_dictsock = socket.socket()sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)# 指定IP和侦听端口Portsock.bind((\"127.0.0.1\",8888))sock.listen(5)#等待用户连接conn,addr = sock.accept()print(\"conn from \",conn,addr)#获取握手消息，magic string ,sha1加密#发送给客户端#握手消息data = conn.recv(8096)headers = get_headers(data)# 对请求头中的sec-websocket-key进行加密,需要返回的头response_tpl = \"HTTP/1.1 101 Switching Protocols\\r\\n\" \\ \"Upgrade:websocket\\r\\n\" \\ \"Connection: Upgrade\\r\\n\" \\ \"Sec-WebSocket-Accept: %s\\r\\n\" \\ \"WebSocket-Location: ws://%s%s\\r\\n\\r\\n\"# magic_string为一个固定的字符串magic_string = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'# 加密value = headers['Sec-WebSocket-Key'] + magic_stringac = base64.b64encode(hashlib.sha1(value.encode('utf-8')).digest())# 返回的信息response_str = response_tpl % (ac.decode('utf-8'), headers['Host'], headers['url'])# 响应【握手】信息conn.send(bytes(response_str, encoding='utf-8'))#复制代码 客户端 Python 1234567891011121314151617try: import threadexcept ImportError: import _thread as threadimport time# import websocketimport websocket# ws = websocket.WebSocket()ws = websocket.create_connection(\"ws://127.0.0.1:8999/\")# ws.connect(\"ws://127.0.0.1:8999/\")data = &#123;\"body\":&#123;\"address\":\"陕西省\"&#125;&#125;ws.send(json.dumps(data)) #json转化为字符串，必须转化while True: data = ws.recv() print(data) Java Script 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; &lt;script&gt; ws =new WebSocket(\"ws://127.0.0.1:8888\"); ws.onopen = function (ev) &#123; //若是连接成功，onopen函数会执行 console.log(ev) &#125; ws.onmessage = function (ev) &#123; //若是连接成功，onopen函数会执行 console.log(ev) &#125; &lt;/script&gt;&lt;/html&gt; 大端和小端模式 网络通信时 通常使用大端 解析websocket协议 使用、创建demo： 长连接 12345678910111213141516171819202122232425262728293031import websockettry: import threadexcept ImportError: import _thread as threadimport timedef on_message(ws, message): print(message)def on_error(ws, error): print(error)def on_close(ws): print(\"### closed ###\")def on_open(ws): def run(*args): ws.send(\"hello1\") time.sleep(1) ws.close() thread.start_new_thread(run,())if __name__ == \"__main__\": websocket.enableTrace(True) ws = websocket.WebSocketApp(\"ws://echo.websocket.org/\", on_message = on_message, on_error = on_error, on_close = on_close) ws.on_open = on_open ws.run_forever(ping_interval=60,ping_timeout=5) ▲ Python的websocket代码是仿js websocket写法的，重新写了一遍脚本，流畅接受消息，自动重连发送指令，连接时间明显减少，基本做到无遗漏数据，与网站js的ws连接实现一样。 短链接： 12345678910from websocket import create_connectionws = create_connection(\"ws://echo.websocket.org/\")print(\"Sending 'Hello, World'...\")ws.send(json.dumps(&#123;\"op\":\"unconfirmed_sub\"&#125;)) # 不能使用str()，要以json格式输出ws.send(\"Hello, World\")print(\"Sent\")print(\"Receiving...\")result = ws.recv()print(\"Received '%s'\" % result)ws.close() 一步一步分析请求过程！！ 服务端（socket服务端） *1.服务端开启socket服务监听IP和端口 *3.允许连接 *5.服务端接收到特殊值【加密sha1，特殊值，migic string=“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”】 *6.加密后的值发送给客户端 客户端（浏览器） *2.客户端发起连接请求（IP和端口） *4.客户端生成一个xxx，【加密sha1，特殊值，migic string=“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”】，向服务端发送一段特殊值 *7.客户端接收到加密的值 1. 启动服务端 1234567import socketsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8002))sock.listen(5)# 等待用户连接conn, address = sock.accept() 2. 客户端连接 1234&lt;script type=\"text/javascript\"&gt; var socket = new WebSocket(\"ws://127.0.0.1:8002/xxoo\"); ...&lt;/script&gt; 3. 建立连接【握手】 获取请求信息 123456789101112131415161718192021222324import socket sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8002))sock.listen(5)# 获取客户端socket对象conn, address = sock.accept()# 获取客户端的【握手】信息data = conn.recv(1024)b'''GET /chatsocket HTTP/1.1Host: 127.0.0.1:8002Connection: UpgradePragma: no-cacheCache-Control: no-cacheUpgrade: websocketOrigin: http://localhost:63342Sec-WebSocket-Version: 13Sec-WebSocket-Key: mnwFxiOlctXFN/DeMt1Amg==Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits''' 请求和响应的【握手】信息需要遵循规则： 从请求【握手】信息中提取 Sec-WebSocket-Key 利用magic_string 和 Sec-WebSocket-Key 进行hmac1加密，再进行base64加密 将加密结果响应给客户端 注：magic string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11 提取Sec-WebSocket-Key值并加密： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import socketimport base64import hashlib def get_headers(data): \"\"\" 将请求头格式化成字典 :param data: :return: \"\"\" header_dict = &#123;&#125; data = str(data, encoding='utf-8') for i in data.split('\\r\\n'): print(i) header, body = data.split('\\r\\n\\r\\n', 1) header_list = header.split('\\r\\n') for i in range(0, len(header_list)): if i == 0: if len(header_list[i].split(' ')) == 3: header_dict['method'], header_dict['url'], header_dict['protocol'] = header_list[i].split(' ') else: k, v = header_list[i].split(':', 1) header_dict[k] = v.strip() return header_dict sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8002))sock.listen(5) conn, address = sock.accept()data = conn.recv(1024)headers = get_headers(data) # 提取请求头信息# 对请求头中的sec-websocket-key进行加密response_tpl = \"HTTP/1.1 101 Switching Protocols\\r\\n\" \\ \"Upgrade:websocket\\r\\n\" \\ \"Connection: Upgrade\\r\\n\" \\ \"Sec-WebSocket-Accept: %s\\r\\n\" \\ \"WebSocket-Location: ws://%s%s\\r\\n\\r\\n\"magic_string = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'value = headers['Sec-WebSocket-Key'] + magic_stringac = base64.b64encode(hashlib.sha1(value.encode('utf-8')).digest())response_str = response_tpl % (ac.decode('utf-8'), headers['Host'], headers['url'])# 响应【握手】信息conn.send(bytes(response_str, encoding='utf-8')) 只有在服务端又发回&quot;响应&quot;的握手信息后，才算建立了链接。握手的作用是保证通信双方使用的协议相同 4.客户端和服务端收发数据 12345678910111213141516171819数据报内容，第一行为字节，第二行为相应的每一位。0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len | Extended payload length ||I|S|S|S| (4) |A| (7) | (16/64) ||N|V|V|V| |S| | (if payload len==126/127) || |1|2|3| |K| | |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +| Extended payload length continued, if payload len == 127 |+ - - - - - - - - - - - - - - - +-------------------------------+| |Masking-key, if MASK set to 1 |+-------------------------------+-------------------------------+| Masking-key (continued) | Payload Data |+-------------------------------- - - - - - - - - - - - - - - - +: Payload Data continued ... :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +| Payload Data continued ... |+---------------------------------------------------------------+ 官网给出的解析规则 The MASK bit simply tells whether the message is encoded. Messages from the client must be masked, so your server should expect this to be 1. (In fact, section 5.1 of the spec says that your server must disconnect from a client if that client sends an unmasked message.) When sending a frame back to the client, do not mask it and do not set the mask bit. We’ll explain masking later. *Note: You have to mask messages even when using a secure socket.*RSV1-3 can be ignored, they are for extensions. The opcode field defines how to interpret the payload data: 0x0 for continuation, 0x1 for text (which is always encoded in UTF-8), 0x2 for binary, and other so-called “control codes” that will be discussed later. In this version of WebSockets, 0x3 to 0x7 and 0xB to 0xF have no meaning. The FIN bit tells whether this is the last message in a series. If it’s 0, then the server will keep listening for more parts of the message; otherwise, the server should consider the message delivered. More on this later. Decoding Payload Length To read the payload data, you must know when to stop reading. That’s why the payload length is important to know. Unfortunately, this is somewhat complicated. To read it, follow these steps: Read bits 9-15 (inclusive) and interpret that as an unsigned integer. If it’s 125 or less, then that’s the length; you’re done. If it’s 126, go to step 2. If it’s 127, go to step 3. Read the next 16 bits and interpret those as an unsigned integer. You’re done. Read the next 64 bits and interpret those as an unsigned integer (The most significant bit MUST be 0). You’re done. Reading and Unmasking the Data If the MASK bit was set (and it should be, for client-to-server messages), read the next 4 octets (32 bits); this is the masking key. Once the payload length and masking key is decoded, you can go ahead and read that number of bytes from the socket. Let’s call the data ENCODED, and the key MASK. To get DECODED, loop through the octets (bytes a.k.a. characters for text data) of ENCODED and XOR the octet with the (i modulo 4)th octet of MASK. In pseudo-code (that happens to be valid JavaScript): var DECODED = “”; for (var i = 0; i &lt; ENCODED.length; i++) { DECODED[i] = ENCODED[i] ^ MASK[i % 4]; } Now you can figure out what DECODED means depending on your application. 获取客户端发送的数据【解包】 123456789101112131415161718192021222324252627282930313233def analyze_info(info): # 处理数据头 # mask占4个字节，在确定数据头的首部需要占多少字节后，再向后推4个字节 # mask之后的就是数据的真正内容，但需要根据规则进行解析 payload_len = info[1] &amp; 127 if payload_len == 126: # payload_len==126首部信息还要拓展2个字节(16 bits) # 见上文的 Decoding Payload Length-2 extend_payload_len = info[2:4] mask = info[4:8] decoded = info[8:] elif payload_len == 127: # payload_len==127那么需要再拓展8个字节(64 bits) # 见上文的 Decoding Payload Length-3 extend_payload_len = info[2:10] mask = info[10:14] decoded = info[14:] else: extend_payload_len = None mask = info[2:6] decoded = info[6:] ''' var DECODED = \"\"; for (var i = 0; i &lt; ENCODED.length; i++) &#123; DECODED[i] = ENCODED[i] ^ MASK[i % 4]; &#125; ''' bytes_list = bytearray() for i in range(len(decoded)): chunk = decoded[i] ^ mask[i % 4] bytes_list.append(chunk) content = str(bytes_list, encoding='utf-8') return content 向客户端发送数据【封包】 123456789101112131415161718192021def send_msg(conn, msg_bytes): \"\"\" WebSocket服务端向客户端发送消息 :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept() :param msg_bytes: 向客户端发送的字节 :return: \"\"\" import struct token = b\"\\x81\" length = len(msg_bytes) if length &lt; 126: token += struct.pack(\"B\", length) elif length &lt;= 0xFFFF: token += struct.pack(\"!BH\", 126, length) else: token += struct.pack(\"!BQ\", 127, length) msg = token + msg_bytes conn.send(msg) return True 转自武沛齐的你真的了解WebSocket吗？ 完整DEMO： Python服务端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/usr/bin/env python# -*- coding:utf-8 -*-import socketimport base64import hashlibdef get_headers(data): \"\"\" 将请求头格式化成字典 :param data: :return: \"\"\" header_dict = &#123;&#125; data = str(data, encoding='utf-8') header, body = data.split('\\r\\n\\r\\n', 1) header_list = header.split('\\r\\n') for i in range(0, len(header_list)): if i == 0: if len(header_list[i].split(' ')) == 3: header_dict['method'], header_dict['url'], header_dict['protocol'] = header_list[i].split(' ') else: k, v = header_list[i].split(':', 1) header_dict[k] = v.strip() return header_dictdef send_msg(conn, msg_bytes): \"\"\" WebSocket服务端向客户端发送消息 :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept() :param msg_bytes: 向客户端发送的字节 :return: \"\"\" import struct token = b\"\\x81\" length = len(msg_bytes) if length &lt; 126: token += struct.pack(\"B\", length) elif length &lt;= 0xFFFF: token += struct.pack(\"!BH\", 126, length) else: token += struct.pack(\"!BQ\", 127, length) msg = token + msg_bytes conn.send(msg) return Truedef init_socket(): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sock.bind(('127.0.0.1', 8003)) sock.listen(5) conn, address = sock.accept() data = conn.recv(1024) headers = get_headers(data) response_tpl = \"HTTP/1.1 101 Switching Protocols\\r\\n\" \\ \"Upgrade:websocket\\r\\n\" \\ \"Connection:Upgrade\\r\\n\" \\ \"Sec-WebSocket-Accept:%s\\r\\n\" \\ \"WebSocket-Location:ws://%s%s\\r\\n\\r\\n\" value = headers['Sec-WebSocket-Key'] + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11' ac = base64.b64encode(hashlib.sha1(value.encode('utf-8')).digest()) response_str = response_tpl % (ac.decode('utf-8'), headers['Host'], headers['url']) conn.send(bytes(response_str, encoding='utf-8')) return conn, sockdef analyze_info(info): payload_len = info[1] &amp; 127 if payload_len == 126: extend_payload_len = info[2:4] mask = info[4:8] decoded = info[8:] elif payload_len == 127: extend_payload_len = info[2:10] mask = info[10:14] decoded = info[14:] else: extend_payload_len = None mask = info[2:6] decoded = info[6:] bytes_list = bytearray() for i in range(len(decoded)): chunk = decoded[i] ^ mask[i % 4] bytes_list.append(chunk) content = str(bytes_list, encoding='utf-8') return contentdef run(): conn, sock = init_socket() while True: try: info = conn.recv(8096) except Exception as e: info = None if not info: break content = analyze_info(info) send_msg(conn, content.encode('utf-8')) sock.close()if __name__ == '__main__': run() html的客户端代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;input type=\"text\" id=\"txt\"/&gt; &lt;input type=\"button\" id=\"btn\" value=\"提交\" onclick=\"sendMsg();\"/&gt; &lt;input type=\"button\" id=\"close\" value=\"关闭连接\" onclick=\"closeConn();\"/&gt; &lt;/div&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var socket = new WebSocket(\"ws://127.0.0.1:8003/chatsocket\"); socket.onopen = function () &#123; /* 与服务器端连接成功后，自动执行 */ var newTag = document.createElement('div'); newTag.innerHTML = \"【连接成功】\"; document.getElementById('content').appendChild(newTag); &#125;; socket.onmessage = function (event) &#123; /* 服务器端向客户端发送数据时，自动执行 */ var response = event.data; var newTag = document.createElement('div'); newTag.innerHTML = response; document.getElementById('content').appendChild(newTag); &#125;; socket.onclose = function (event) &#123; /* 服务器端主动断开连接时，自动执行 */ var newTag = document.createElement('div'); newTag.innerHTML = \"【关闭连接】\"; document.getElementById('content').appendChild(newTag); &#125;; function sendMsg() &#123; var txt = document.getElementById('txt'); socket.send(txt.value); txt.value = \"\"; &#125; function closeConn() &#123; socket.close(); var newTag = document.createElement('div'); newTag.innerHTML = \"【关闭连接】\"; document.getElementById('content').appendChild(newTag); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; tornado初探 123456ws = websocket.WebSocketApp(\"ws://echo.websocket.org/\", on_message = on_message, on_error = on_error, on_close = on_close)ws.on_open = on_openws.run_forever() 长连接，参数介绍： （1）url: websocket的地址。 （2）header: 客户发送websocket握手请求的请求头，{‘head1:value1’,‘head2:value2’}。 （3）on_open：在建立Websocket握手时调用的可调用对象，这个方法只有一个参数，就是该类本身。 （4）on_message：这个对象在接收到服务器返回的消息时调用。有两个参数，一个是该类本身，一个是我们从服务器获取的字符串（utf-8格式）。 （5）on_error：这个对象在遇到错误时调用，有两个参数，第一个是该类本身，第二个是异常对象。 （6）on_close：在遇到连接关闭的情况时调用，参数只有一个，就是该类本身。 （7）on_cont_message：这个对象在接收到连续帧数据时被调用，有三个参数，分别是：类本身，从服务器接受的字符串（utf-8），连续标志。 （8）on_data：当从服务器接收到消息时被调用，有四个参数，分别是：该类本身，接收到的字符串（utf-8），数据类型，连续标志。 （9）keep_running：一个二进制的标志位，如果为True，这个app的主循环将持续运行，默认值为True。 （10）get_mask_key：用于产生一个掩码。 （11）subprotocols：一组可用的子协议，默认为空。 tornado.hello_world Http 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import tornado.ioloopimport tornado.webclass IndexHandler(RequestHandler): # 正常1，抛错1、5 def set_default_headers(self): print \"调用了set_default_headers()\" # 正常2，抛错2 def initialize(self): print \"调用了initialize()\" # 正常3，抛错3 def prepare(self): print \"调用了prepare()\" # 正常4，抛错4 def get(self): print \"调用了get()\" # 正常4，抛错4 def post(self): print \"调用了post()\" self.send_error(200) # 注意此出抛出了错误 # 正常无、抛错6 def write_error(self, status_code, **kwargs): print \"调用了write_error()\" # 正常5、抛错7 def on_finish(self): print \"调用了on_finish()\" # 定义Http处理类型class MainHandler(tornado.web.RequestHandler): # 处理路由参数 def initialize(self, subject): self.subject = subject # 添加一个处理get请求方式的方法 def get(self): # write方法是写到缓冲区的 self.write(\"Hello, world\") # write会自动检测json类型，进行包装，并设Content-Type设置为application/json; charset=UTF-8。def make_app(): settings = &#123; 'template_path': 'templates', 'static_path': 'static', &#125; return tornado.web.Application([ (r\"/main\", MainHandler, &#123;\"subject\":\"c++\"&#125;), # 指定路由信息,路由参数会传入initialize()中 (r\"/\", IndexHandler), ], debug=True, **settings) # debug=True时，有自动重启、提供追踪信息等功能if __name__ == \"__main__\": app = make_app() # 创建一个应用对象,得返回Application对象 app.listen(8888) # 设置端口 tornado.ioloop.IOLoop.current().start() # 启动web程序，开始监听端口的连接 Websocket 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# ▲继承的类为WebSocketHandlerclass ChatHandler(tornado.websocket.WebSocketHandler): # 用户存储当前聊天室用户 waiters = set() # 用于存储历时消息 messages = [] def open(self): \"\"\" 客户端连接成功时，自动执行 :return: \"\"\" ChatHandler.waiters.add(self) uid = str(uuid.uuid4()) self.write_message(uid) for msg in ChatHandler.messages: content = self.render_string('message.html', **msg) self.write_message(content) def on_message(self, message): \"\"\" 客户端连发送消息时，自动执行 :param message: :return: \"\"\" msg = json.loads(message) ChatHandler.messages.append(message) for client in ChatHandler.waiters: content = client.render_string('message.html', **msg) client.write_message(content) def on_close(self): \"\"\" 客户端关闭连接时，，自动执行 :return: \"\"\" ChatHandler.waiters.remove(self) def run(): settings = &#123; 'template_path': 'templates', 'static_path': 'static', &#125; application = tornado.web.Application([ (r\"/\", IndexHandler), (r\"/chat\", ChatHandler), ], **settings) application.listen(8888) tornado.ioloop.IOLoop.instance().start()if __name__ == \"__main__\": run() 基于Tornado——聊天室 项目结构 12345678│ app.py│├───static│ jquery-2.1.4.min.js│└───templates index.html message.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#!/usr/bin/env python# -*- coding:utf-8 -*-# app.pyimport uuidimport jsonimport tornado.ioloopimport tornado.webimport tornado.websocketclass IndexHandler(tornado.web.RequestHandler): def get(self): self.render('index.html')class ChatHandler(tornado.websocket.WebSocketHandler): # 用户存储当前聊天室用户 waiters = set() # 用于存储历时消息 messages = [] def open(self): \"\"\" 客户端连接成功时，自动执行 :return: \"\"\" ChatHandler.waiters.add(self) uid = str(uuid.uuid4()) self.write_message(uid) for msg in ChatHandler.messages: content = self.render_string('message.html', **msg) self.write_message(content) def on_message(self, message): \"\"\" 客户端连发送消息时，自动执行 :param message: :return: \"\"\" msg = json.loads(message) ChatHandler.messages.append(message) # 向当前在线的每个用户发送最新的消息界面 for client in ChatHandler.waiters: content = client.render_string('message.html', **msg) client.write_message(content) def on_close(self): \"\"\" 客户端关闭连接时，，自动执行 :return: \"\"\" ChatHandler.waiters.remove(self)def run(): settings = &#123; 'template_path': 'templates', 'static_path': 'static', &#125; application = tornado.web.Application([ (r\"/\", IndexHandler), (r\"/chat\", ChatHandler), ], **settings) application.listen(8888) tornado.ioloop.IOLoop.instance().start()if __name__ == \"__main__\": run() index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Python聊天室&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;input type=\"text\" id=\"txt\"/&gt; &lt;input type=\"button\" id=\"btn\" value=\"提交\" onclick=\"sendMsg();\"/&gt; &lt;input type=\"button\" id=\"close\" value=\"关闭连接\" onclick=\"closeConn();\"/&gt; &lt;/div&gt; &lt;div id=\"container\" style=\"border: 1px solid #dddddd;margin: 20px;min-height: 500px;\"&gt; &lt;/div&gt; &lt;script src=\"/static/jquery-2.1.4.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function () &#123; wsUpdater.start(); &#125;); var wsUpdater = &#123; socket: null, uid: null, start: function() &#123; var url = \"ws://127.0.0.1:8888/chat\"; wsUpdater.socket = new WebSocket(url); wsUpdater.socket.onmessage = function(event) &#123; console.log(event); if(wsUpdater.uid)&#123; wsUpdater.showMessage(event.data); &#125;else&#123; wsUpdater.uid = event.data; &#125; &#125; &#125;, showMessage: function(content) &#123; $('#container').append(content); &#125; &#125;; // 按下提交按钮后，客户端向服务端发送信息，服务端再将数据给message.html渲染 function sendMsg() &#123; var msg = &#123; uid: wsUpdater.uid, message: $(\"#txt\").val() &#125;; console.log(JSON.stringify(msg)); wsUpdater.socket.send(JSON.stringify(msg)); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; message.html 1234&lt;div style=\"border: 1px solid #dddddd;margin: 10px;\"&gt; &lt;div&gt;游客&#123;&#123;uid&#125;&#125;&lt;/div&gt; &lt;div style=\"margin-left: 20px;\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/div&gt; ▲ 整个执行流程： 按下提交后调用html.sendMsg–&gt; 数据message–&gt;在后自动调用on_message，会将message传给massage.html渲染，将渲染结果(字符串)返回给用户(write_message)–&gt; 客户端收到消息后自动执行html.on_message会调用html.showMessage，把content即字符串(event.data)用jquery追加显示index.html页面上$('#container').append(content); 附录文献: websocket获取实时数据的几种常见链接方式 python使用websocket的几种方式 Python Web 框架：Tornado初探 ▲Python学习笔记——Tornado深入 完整的websocket使用——聊天室 坑点记录： 1.create_connection导入失败 Q:ImportError: cannot import name 'create_connection' from 'websocket' (unknown location) A:在使用create_connection之前要安装websocket_client ,即 pip install websocket-client 个人的HTML客户端代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;2048客户端&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div align=\"center\"&gt; &lt;input type=\"button\" value=\"↑\" name=\"↑\" onclick=\"up()\" style=\"height:50px; width:50px;\"&gt; &lt;input type=\"button\" value=\"↓\" name=\"↓\" onclick=\"down()\" style=\"height:50px; width:50px;\"&gt; &lt;input type=\"button\" value=\"←\" name=\"←\" onclick=\"left()\" style=\"height:50px; width:50px;\"&gt; &lt;input type=\"button\" value=\"→\" name=\"→\" onclick=\"right()\" style=\"height:50px; width:50px;\"&gt; &lt;/div&gt;&lt;/body&gt; &lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function () &#123; wsUpdater.start(); &#125;); var wsUpdater = &#123; socket: null, uid: null, start: function () &#123; var url = \"ws://127.0.0.1:8888/game\"; wsUpdater.socket = new WebSocket(url); wsUpdater.socket.onmessage = function (event) &#123; &#125;; wsUpdater.socket.onopen = function (ev) &#123; //若是连接成功，onopen函数会执行 console.log(ev); msg = 'success'; wsUpdater.socket.send(JSON.stringify(msg)); &#125;; wsUpdater.socket.onclose = function () &#123; console.log(\"Client断开连接!\"); &#125;; &#125; &#125;; function up() &#123; wsUpdater.socket.send(0); &#125; function down() &#123; wsUpdater.socket.send(1); &#125; function left() &#123; wsUpdater.socket.send(2); &#125; function right() &#123; wsUpdater.socket.send(3); &#125; &lt;/script&gt;&lt;/html&gt; js客户端 先用npm install ws，再输入node doit.js运行代码 doit.js 12345678910111213141516171819202122232425262728var WebSocket = require('ws');console.log('hello');var wsUpdater = &#123; socket: null, uid: null, start: function () &#123; var url = \"ws://127.0.0.1:8888/game\"; wsUpdater.socket = new WebSocket(url); wsUpdater.socket.onmessage = function (ev) &#123; console.log(ev); game = JSON.parse(ev.data); console.log(game); &#125;; wsUpdater.socket.onopen = function (ev) &#123; //若是连接成功，onopen函数会执行 console.log(ev); msg = 'success'; wsUpdater.socket.send(JSON.stringify(msg)); &#125;; wsUpdater.socket.onclose = function () &#123; console.log(\"Client断开连接!\"); &#125;; &#125;&#125;;wsUpdater.start(); Python代码 123456789101112131415161718192021222324252627282930import jsonfrom ws4py.client.threadedclient import WebSocketClientimport multiprocessingfrom core import Gameclass GamePlayer(WebSocketClient): def opened(self): # req = '&#123;\"event\":\"subscribe\", \"channel\":\"eth_usdt.deep\"&#125;' # self.send(req) print(\"连接成功\") def closed(self, code, reason=None): # print(\"Closed down:\", code, reason) print(\"连接中断\") def received_message(self, resp): resp = json.loads(str(resp)) print(resp)if __name__ == '__main__': # in_pipe, out_pipe = multiprocessing.Pipe(True) ws = None try: ws = GamePlayer('ws://127.0.0.1:23456/game') ws.connect() ws.run_forever() except KeyboardInterrupt: ws.close()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"网络知识","slug":"网络知识","permalink":"https://nymrli.top/tags/网络知识/"}]},{"title":"第二十八届“和巨耀通杯”南京邮电大学在线测评系统程序设计邀请赛--","slug":"第二十八届“和巨耀通杯”NOJ邀请赛","date":"2019-11-17T09:43:56.000Z","updated":"2019-11-17T09:58:12.998Z","comments":true,"path":"2019/11/17/第二十八届“和巨耀通杯”NOJ邀请赛/","link":"","permalink":"https://nymrli.top/2019/11/17/第二十八届“和巨耀通杯”NOJ邀请赛/","excerpt":"","text":"第二十八届“和巨耀通杯”NOJ邀请赛 三人团队赛， 正好最近在刷PTA， 于是一个人报名尝试了一下。 一共AC了三题， Rank28 C. Battle game 签到题 Description: You are playing a game which you will battle with an enemy. As you don’t want to lose, your total power can’t be lower than your enemy’s. Your power is simply added by the power of your soldiers, and all of your soldiers’ power is exactly aa. Now you have known that your enemy’s total power is bb. You want to know how many soldiers you need in order not to lose the battle. Input: A line with two integers a,ba,b, (1≤a,b≤109)(1≤a,b≤109). Output: A line with one integer, denotes the minimum number of soldiers you need. Sample Input: 1123 456 Sample Output: 14 AC代码 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b; while(cin &gt;&gt; a&gt;&gt; b)&#123; int ans=1; if ( b%a != 0) ans= b/a+1;// cout &lt;&lt; b/a+1&lt;&lt; endl; else ans = b/a;// cout &lt;&lt; b/a &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D. Gomoku Description: Alice and Bob are playing a game called Gomoku (a.k.a. Five in a Row). Alice is sente(black, moves first) and Bob is gote(white, moves second). Alice wants to know whether she can win(have five or more consecutive stones of the same color in a diagonal, vertical, or horizontal row) in one step, and now is Alice’s turn. It is guranteed that neither Alice or Bob wins currently. Prohibitions are not considered in this problem. Input: The first line contains one integer nn, which denotes the size of the board is n×nn×n. Next nn lines each has a string of length nn, use @ to represent black, O to represent white, + to represent there’s no stone at that position. Output: If Alice can win in one step, output YES, otherwise output NO. Sample Input: 123456787+++O++++@+@++++O@@@+++++@++++++O@++++OOOO++++++++ Sample Output: 1YES AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;stdlib.h&gt;const int maxn = 1e3 + 5;/*7+++O++++@+@++++O@@@+++++@++++++O@++++OOOO++++++++*/using namespace std;char maze[maxn][maxn];bool can=false;const int dirnum = 8;// -&gt; , 2, &lt;- , 8,int xdir[dirnum] = &#123;1, 0, -1, 0, 1, -1, -1, 1&#125;;int ydir[dirnum] = &#123;0, 1, 0, -1, 1, 1, -1, -1&#125;;void dfs(int x, int y, int depth, int dir, int plustime)&#123; if (depth == 5)&#123; can = true;// cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl; return; &#125; if (plustime == 2) return; if (maze[x][y] == 'O') return; if (!maze[x][y]) return; if (can == false)&#123; int xt = xdir[dir] + x; int yt = ydir[dir] + y;// cout &lt;&lt; \" x:\" &lt;&lt; xt &lt;&lt; \" y:\"&lt;&lt; yt &lt;&lt; \" \" &lt;&lt; maze[xt][yt] &lt;&lt; \"plustime:\"&lt;&lt; plustime&lt;&lt; endl; if (maze[xt][yt] == '+' &amp;&amp; plustime==0)&#123; maze[xt][yt] = '@'; dfs(xt, yt, depth+1, dir, plustime+1); maze[xt][yt] = '+'; &#125;else if(maze[xt][yt] == '@' )&#123; dfs(xt, yt, depth+1, dir, plustime); &#125;else return; &#125;else return;&#125;int main()&#123; // 5- 1e3 ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++) cin &gt;&gt;maze[i][j]; &#125;// for(int i=1;i&lt;=n;i++)&#123;// for(int j=1;j&lt;=n;j++)// cout &lt;&lt; maze[i][j];// cout &lt;&lt; endl;// &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if (maze[i][j]== '@')&#123;// cout &lt;&lt; \"test\" &lt;&lt; \"x:\" &lt;&lt; i &lt;&lt; \" y:\"&lt;&lt; j &lt;&lt; \" \"&lt;&lt; maze[i][j]&lt;&lt; endl; for(int k=0; k&lt;dirnum; k++)&#123; int xt = xdir[k] + i; int yt = ydir[k] + j; if (maze[xt][yt]=='@')// cout &lt;&lt; \" in \" &lt;&lt; \"x:\" &lt;&lt; xt &lt;&lt; \" y:\"&lt;&lt; yt &lt;&lt; \" \"&lt;&lt; maze[xt][yt]&lt;&lt; endl; dfs(xt, yt, 2, k, 0); else if (maze[xt][yt] == '+') dfs(xt, yt, 2, k, 1); &#125; &#125;// else cout &lt;&lt; \"new\" &lt;&lt; \"x:\" &lt;&lt; i &lt;&lt; \" y:\"&lt;&lt; j &lt;&lt; \" \"&lt;&lt; maze[i][j]&lt;&lt; endl; &#125; &#125; if (can) printf(\"YES\\n\"); else printf(\"NO\\n\"); return 0;&#125; G. Number 规律题 Description: 0xfaner just learned the factorial today, and the factorial is defined as follows:x!=1×2×⋯×xx!=1×2×⋯×xx!=1×2×⋯×xx!=1×2×⋯×xx!=1×2×⋯×xx!=1×2×⋯×x He found that $10!=362880010!=3628800 $， 20!=243290200817664000020!=243290200817664000020!=2432902008176640000 , the number of trailing zeros is increasing. Now 0xfaner wants to know the the number of trailing zeros of n!n!to each given nn . Input: The only line contains one integer nn ( 1≤n≤1091≤n≤109 ). Output: Print the number of trailing zeros of n!n! . Sample Input: 125 Sample Output: 16 AC 规律题 12345678910111213141516171819202122232425262728293031import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static int solve(int n)&#123; BigInteger res = new BigInteger(\"1\"); for(int i=1;i&lt;=n;i++)&#123; BigInteger tmp = new BigInteger(String.valueOf(i)); res = res.multiply(tmp); &#125;// System.out.printf(\"%s\\n\",res.bitCount());// System.out.printf(\"%s\\n\",res.bitLength());// System.out.printf(\"%d\\n\",res.byteValue()); String s = res.toString(); int ans = 0; for(int j=s.length()-1;j&gt;=0;j--)&#123; if (s.charAt(j)=='0') ans ++; else break; &#125; return ans; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); System.out.printf(\"%d\",solve(n)); &#125; &#125; 执行后一直TLE，于是猜测是否有规律 AC代码 1234567891011121314151617#include &lt;iostream&gt;typedef long long ll;using namespace std;int main()&#123; ios::sync_with_stdio(false); ll n; while(cin &gt;&gt; n)&#123; ll ans = 0; while(n)&#123; ans += n/5; n /= 5; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"}]},{"title":"PAT冲冲冲——甲级","slug":"PAT冲冲冲——甲级","date":"2019-10-24T10:30:45.000Z","updated":"2020-10-08T05:28:35.497Z","comments":true,"path":"2019/10/24/PAT冲冲冲——甲级/","link":"","permalink":"https://nymrli.top/2019/10/24/PAT冲冲冲——甲级/","excerpt":"","text":"PAT冲冲冲——甲级 PAT甲10级练习题 ——PAT (Advanced Level) Practice PAT甲级(Advanced Level)真题 柳婼 の blog经验 saquarius’s blog PAT甲级题目及分类总结 pat甲级题解目录 PAT考试经验总结（甲乙级均适用）想满分的请看这里！——前人经验 ▲报名费256，可以刷牛客网的题来获得-50的优惠券，该练习场下的所有题目只要通过都算 甲级练习题 由于甲级题目较多，也较难，因此决定还是将两者分开写两篇文章了。 1001 A+B Format (20 分) 看似很简单的一道题，但坑点确实不少，一遍过挺难的 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll m, n; // 考虑到每次都是取后三位，所以需要用栈来逆序输出 stack&lt;ll&gt; s; while(scanf(\"%lld%lld\",&amp;m,&amp;n) != EOF)&#123; ll res_ans = m + n; // 这边0得特判 if (res_ans==0)printf(\"0\"); else if (res_ans&lt;0)&#123; printf(\"-\"); &#125;else ; ll ans = abs(res_ans); while( ans )&#123; ll three = ans%1000; s.push(three); ans /= 1000; &#125; bool first = true; // 逆序输出 while(!s.empty())&#123; ll n = s.top(); s.pop(); // 首个三位不需要补零，其他的都需要补零 if (first) &#123; printf(\"%lld\", n); first = !first; &#125; else printf(\"%03lld\", n); if (!s.empty()) printf(\",\"); &#125; printf(\"\\n\"); &#125; return 0;&#125; 1002 A+B for Polynomials 模拟题，对我来说，又重新温习了遍Map的使用。 该题就一个坑点：系数为0的项不需要显示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int main()&#123; int m, n; std::map&lt;int, float&gt; mp; std::map&lt;int, float&gt;::iterator i; scanf(\"%d\", &amp;m); for (int i = 0; i &lt; m; ++i)&#123; float coef; int exp; scanf(\"%d %f\", &amp;exp, &amp;coef); mp[exp] = coef; &#125; scanf(\"%d\", &amp;n); for (int j = 0; j &lt; n; ++j)&#123; // 两个临时变量 float coef; int exp; scanf(\"%d %f\", &amp;exp, &amp;coef); i = mp.find(exp); if ( i != mp.end() )&#123; float sum = i-&gt;second + coef; if ( abs( sum - 0) &lt; 1e-6 )&#123; // △坑点:如果系数为0,不显示 mp.erase(exp); &#125;else mp[exp] = sum; &#125;else&#123; mp[exp] = coef; &#125; &#125; // 从小到大输出 // for ( i = mp.begin(); i != mp.end(); ++i) printf(\"%d\", mp.size()); // 使用反向迭代器-&gt;从大到小输出 for (std::map&lt;int, float&gt;::reverse_iterator i = mp.rbegin(); i != mp.rend(); ++i)&#123; printf(\" %d %.1f\", i-&gt;first, i-&gt;second); &#125; printf(\"\\n\"); return 0;&#125; 1003 Emergency 作为一个城市紧急援救队的指挥者，你得到了一个国家的特殊地图。地图上分散着几座城市，城市间用道路连接着。每个城市援救队的数量以及两座城市之间每条道路的长度已经在地图上标出。当某些城市发生了突发事件，需要你的帮助时，你的工作是带领你的队伍尽快的赶到事发现场，与此同时，召集尽可能多的在路上的队伍。 输入 每个输入文件包含一个测试实例。每个实例的第一行有四个正整数：N(&lt;= 500)是城市的个数（城市的编号从0到N-1），M是道路的个数，C1和C2分别是你现在所在的城市以及你必须去救援的城市。下一行有N个整数，第i个整数是第i个城市中救援队的数量。然后下面有M行，每行表示一条道路。每一行有三个整数c1,c2和L，分别表示道路连接的两个城市以及道路的长度。保证C1到C2之间存在至少一条路径。 输出 对于每个测试实例，在一行中输出两个数字：C1和C2之间不同的最短路径的个数，你能聚集起来的最多的救援队数量。 一行中的所有数字必须被一个空格分隔开，在每行的结尾不允许出现空格。 思路：本题是求起点到目标点的最短路径的数目，以及所有最短路径中点权的最大值，可用dijkstra算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;#define INF 0x3f3f3fusing namespace std;typedef long long ll;int n, m, s, d;const int maxn = 500+5;/*关于起点为s的路径的变量(记录的都是以 起点s 为中心的量)：pathl(path_length缩写)存储从起点到所有点的最短路径的边权(本例为起点城市到所有城市的最短路径的距离) ————最短路maxv(max_hands缩写)存储从起点到其他点的全部最短路径中的点权最大值(本例为起点城市到其他城市的所有最短路径中 即人手最多的那条路径的人手数) ———— 最短路中能获得最大权值的节点权值e.g.maxv[3]即s-&gt;3能获得的最大权值▲核心思想是根据路径最短来更新的,所以即使v' &lt; v, 但只要l' &lt; l,那么也会更新。即@77代码处pathc(path_count缩写)存储从起点到其他点的最短路径的数目； △根据题意,额外需要维护的值*/int pathc[maxn];int pathl[maxn];int maxv[maxn];/* 图信息的变量 */// e(edges):点间的边关系, 初始化默认为0// visited:判断v是否被访问过// 存放节点v权值的量, node_valueint e[maxn][maxn];int visited[maxn];int value[maxn];/** * [dijkstra description] * dijkstra求最短路径的特点是探索当前节点-&gt;下个节点,边权值最小的将被当做下个节点 * 最终可以找出节点s到所有节点的最短路径 * 原理:根据初始点，挨个的把离初始点最近的点一个一个找到并加入集合,集合中所有的点的d[i]都是该点到初始点最短路径长度 * @author mrli 2019-11-09 */void dijkstra()&#123; /* 这份dijkstra的思路为: 第一次, for1先遍历选中一个节点v, 然后使用for2找到遍历, 找到与v路径最短的下一个节点v', then更新 第二次, for1那么根据与下个节点路径最短的规则,还是会找到v', 因此minI=v', 然后再找v'' 第二种: 先安排节点s, 设个while(1) 以外的节点, 保存当前节点v编号, 然后遍历,tmpv为需要更新的节点的编号 区别在于 法一:当前的v未访问过,所以设置visited[v]=1,然后找下一个tmpv,在下次的while循环的时候再设置visited 法二:当前的v已经是visited==1, 在找到tmpv后直接设置visited[tmpv]=1, */ // 初始化数组 fill(pathl, pathl+ maxn, INF); pathc[s] = 1; pathl[s] = 0; maxv[s] = value[s]; while(1)&#123; /*找出本轮尚未确定最短路径的城市中，起点到剩余城市中，距离最小minl的那个城市minI。 如果minl是无穷大，证明起点城市与剩余城市均不可达，即不连通； 如果minI就是目标城市d，则表明已经确定起点城市到目标城市的最短路径，提前结束寻找。 否则，将本轮能确定最短路径的城市minI设为已经处理好,v[minI]=1； */ int minl = INF, minI = -1; // 以s节点为例, 先遍历边其他未访问过的节点,找到其中边权值最小的作为下一个访问节点 // 首先第一个访问的肯定是s节点 for (int i = 0; i &lt; n; ++i)&#123; if (visited[i] == 1) continue; if (pathl[i] &lt; minl)&#123; minl = pathl[i]; minI = i; &#125; &#125; // 终止条件: // 1.在 dijkstra 算法里, 如果节点已经判断到终点了, 那么到终点的最短路径就已经被计算出来了,此时可以结束 // 2.当前循环全是Visited == 1的节点,所有节点都被遍历过了, 循环结束 if (minI == d || minl== INF) break; visited[minI] = 1; // minI节点-&gt;下个节点 for (int i = 0; i &lt; n; ++i)&#123; // 在未达、且可达的节点中考虑，否则continue if( visited[i] == 1 || e[minI][i] == 0) continue; // 当节点minI的最短路径 + 当前minI-&gt;下一个节点的边权值 int tmpl = pathl[minI] + e[minI][i]; int tmpv = value[i] + maxv[minI]; // 判断是否要更新, 如果当前路径l小于之前的话,那么更新 if(tmpl &lt; pathl[i])&#123; pathl[i] = tmpl; maxv[i] = tmpv; pathc[i] = pathc[minI]; &#125; // 如果长度是相等的,那么最大化Value else if (tmpl == pathl[i])&#123; pathc[i] += pathc[minI]; if (tmpv &gt; maxv[i]) maxv[i] = tmpv; &#125; &#125; &#125;&#125;int main()&#123; scanf(\"%d %d %d %d\", &amp;n, &amp;m, &amp;s, &amp;d); for (int i = 0; i &lt; n; ++i)&#123; scanf(\"%d\", &amp;value[i]); &#125; for (int i = 0; i &lt; m; ++i)&#123; int v1, v2, l; scanf(\"%d %d %d\", &amp;v1, &amp;v2, &amp;l); e[v1][v2] = l; e[v2][v1] = l; &#125; dijkstra(); // 最短的路径, 最大的权值 printf(\"%d %d\\n\", pathc[d], maxv[d]); return 0;&#125; 大佬的代码(带注释) 1004 Counting Leaves 一个家庭的层级结构经常被表现为一个家谱树。你的任务是统计这些家庭成员中谁没有孩子。 输入 每个输入文件包含一个测试实例。每个实例开始的一行包含N和M，N指树中的结点个数（0&lt;N&lt;100），M指非叶结点的个数。然后下面有M行，每行的格式如下： ID K ID[1] ID[2] …ID[K] ID是一个两位数的数字，表示一个非叶结点。K表示其孩子的数量。随后是一个序列，序列中是该结点的孩子结点的两位数ID。为了简单起见，我们把根结点的ID固定为01。 输出 对于每个测试实例，你应该计算从根结点开始的每一层中没有孩子的家庭成员的个数。数字必须在一行内输出，用空格分隔，在每行结尾不能有多余的空格。 测试样例表示了一个只有两个结点的树，01是根结点，02是它仅有的孩子。因此在根结点01层级，没有叶节点。再下一层级，有一个叶结点。然后我们应该在一行内输出“0 1”。 节点带有孩子的信息用vector来模拟图中的邻接表写法，然后用BFS来实现遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100+5;// 类似邻接表的写法记录节点std::vector&lt;int&gt; v[MAXN];// 用来记录每一层的叶子节点数int cnt[MAXN];// 来计算层数// level记录当前节点p的所在层数int level[MAXN];// maxlevel记录深度0-Nint maxlevel;void bfs()&#123; queue&lt;int&gt; q; // 设置起点，root==01节点 q.push(1); while(!q.empty())&#123; int p = q.front(); q.pop(); // 自己是个叶子节点 if(v[p].size() == 0)&#123; cnt[level[p]] ++; maxlevel = max(level[p], maxlevel); &#125;else&#123; // 如果当前节点p不是叶子节点， 则继续向其叶子节点扩展 for (int i = 0; i &lt; v[p].size() ; ++i)&#123; q.push(v[p][i]); // p节点的叶子节点的层数为p节点层数+1 level[v[p][i]] = level[p] + 1; &#125; &#125; &#125;&#125;int main()&#123; int N, M; cin &gt;&gt; N &gt;&gt; M; while(M--)&#123; int parent, num; cin &gt;&gt; parent &gt;&gt; num; // 类似邻接表， parent记录了其孩子 for (int i = 0; i &lt; num; ++i)&#123; int tmp; cin &gt;&gt; tmp; v[parent].emplace_back(tmp); &#125; &#125; bfs(); // 0为第一层 for (int i = 0; i &lt;= maxlevel; ++i)&#123; if(i==0) cout &lt;&lt; cnt[i]; else cout &lt;&lt; \" \" &lt;&lt; cnt[i] &lt;&lt; endl; &#125; return 0;&#125; 1005 Spell It Right 感觉突然来了一道放水题，就纯模拟 坑点：全0的时候特判为zero 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 100 + 5int arr[maxn];string num[10] = &#123;\"zero\" ,\"one\" ,\"two\" ,\"three\", \"four\" ,\"five\", \"six\", \"seven\", \"eight\", \"nine\"&#125;;int main() &#123; int sum = 0; char ch = getchar(); stack&lt;int&gt; s; while( ch != '\\n' )&#123; int tmp = ch - '0'; sum += tmp; ch = getchar(); &#125; // 坑点,需要特判0 if(sum==0)&#123; printf(\"zero\\n\"); &#125;else&#123; while(sum)&#123; int ge = sum %10; sum /= 10; s.push(ge); &#125; bool first = true; while(!s.empty())&#123; int ans = s.top(); s.pop(); if (first) &#123; printf(\"%s\", num[ans].c_str()); first = !first; &#125; else printf(\" %s\", num[ans].c_str()); &#125; &#125; printf(\"\\n\"); return 0;&#125; ▲小结一下: 每次用while来取位的时候，必须先判断while(xxx)中的xxx是否初始就为0 1006 Sign In and Sign Out (25 分) 更加简单的模拟题，由于string的比较特性可以直接用来比较时间，所以处理很方便 △学会使用algorithm里的sort能省很多时间 ▲比较运算符&lt;重载、或是编写外部比较函数，都会按照return里为true的逻辑排序,如first.xxx &lt; second.xxx那么就是从小到大 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;using namespace std;struct record&#123; string id; string intime; string outtime;&#125;typedef rc;// 按照进入的时间排序, 从小到大bool cmpin(const rc&amp; f, const rc&amp; s)&#123; return f.intime &lt; s.intime;&#125;// 按照出去的时间排序, 从大到小bool cmpout(const rc&amp; f, const rc&amp; s)&#123; return f.outtime &gt; s.outtime;&#125;int main() &#123; int T; std::vector&lt;rc&gt; v; std::vector&lt;rc&gt;::iterator it; cin &gt;&gt; T; while(T--)&#123; rc* p = new rc(); cin &gt;&gt; p-&gt;id &gt;&gt; p-&gt;intime &gt;&gt; p-&gt;outtime; v.emplace_back(*p); &#125; sort(v.begin(), v.end(), cmpin); cout &lt;&lt; v.begin()-&gt;id &lt;&lt; \" \"; sort(v.begin(), v.end(), cmpout); cout &lt;&lt; v.begin()-&gt;id &lt;&lt;endl; // for(it = v.begin(); it!= v.end(); it++)&#123; // cout &lt;&lt; it-&gt;id &lt;&lt; \" \"&lt;&lt; it-&gt;intime &lt;&lt;\" \"&lt;&lt; it-&gt;outtime &lt;&lt; endl; // &#125; return 0;&#125; C++中sort的比较函数写法 注意：比较函数必须写在类外部（全局区域）或声明为静态函数 1007 Maximum Subsequence Sum Dp, 最大公共子串 12 1008 Elevator 模拟 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100+5;int order[MAXN];int main()&#123; int N; // 所有用时 int t=0; // 上一个位置 int ptr=0; cin &gt;&gt; N; for(int i = 0; i&lt;N; i++)&#123; cin &gt;&gt; order[i]; &#125; for(int i = 0; i&lt;N; i++)&#123; int res = order[i] - ptr; ptr = order[i]; if(res&gt;0) t+= 6*res + 5; else t += 4*abs(res) + 5; &#125; cout &lt;&lt; t &lt;&lt; endl; return 0;&#125; 1009 Product of Polynomials 模拟题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int maxn = 1e4;struct poly&#123; int exp; double xishu;&#125;arr[maxn];double ans[maxn * 2];int main()&#123; int n, m ; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int e; double a; scanf(\"%d%lf\", &amp;e, &amp;a); arr[i].exp = e; arr[i].xishu += a; &#125; cin &gt;&gt; m ; for (int j = 0; j &lt; m; j++) &#123; int e; double a; scanf(\"%d%lf\", &amp;e, &amp;a); for (int i = 0; i &lt; n; i++) &#123; ans[e + arr[i].exp] += a * arr[i].xishu; &#125; &#125; int number = 0; for (int i = 0; i &lt;= 2000 ; i++) &#123; if (ans[i] != 0.0)&#123; number ++; &#125; &#125; printf(\"%d\", number); for (int i = 2000; i &gt;= 0; i--) &#123; if ( ans[i] != 0.0)&#123; printf(\" %d %.1f\", i, ans[i]); &#125; &#125; return 0;&#125; 浙大复试 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * @Author: Mrli * @Date: 2020-10-08 10:43:31 * @LastEditTime: 2020-10-08 11:57:09 * @Description: */#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int n;const int maxn = 2000;int arr[maxn];int main()&#123; cin &gt;&gt; n; vector&lt;int&gt; v(n+1, 0); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125; arr[0] = v[1]; arr[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; int xarr[maxn]; int carr[maxn]; for (int j = n; j &gt;= 0; j--) &#123; xarr[j + 1] = arr[j]; carr[j] = v[i] *arr[j]; &#125; xarr[0] = 0; for (int j = 0; j &lt;= n; j++) &#123; arr[j] = xarr[j] + carr[j]; &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; \" \"; &#125; return 0;&#125; 1010 Radix 模拟题 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100+5;int order[MAXN];int main()&#123; int N1, N2, tag, radix; cout &lt;&lt;\"Impossible\" &lt;&lt;endl; return 0;&#125; 1011 World Cup Betting 模拟题 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;using namespace std;struct games&#123; double one, two, three;&#125;typedef Gm;int main() &#123; int T=3; double win=1; std::vector&lt;int&gt; v; while(T--)&#123; double arr[3]; int maxi = 0; scanf(\"%lf%lf%lf\",&amp;arr[0], &amp;arr[1], &amp;arr[2]); for (int i = 1; i &lt; 3; ++i)&#123; if (arr[i] &gt; arr[maxi])&#123; maxi = i; &#125; &#125; v.emplace_back(maxi); win *= arr[maxi]; &#125; std::vector&lt;int&gt;::iterator it; for(it= v.begin(); it!= v.end(); it++)&#123; switch(*it)&#123; case 0: printf(\"W \"); break; case 1: printf(\"T \"); break; case 2: printf(\"L \"); break; &#125; &#125; printf(\"%.2lf\\n\", (win*0.65 - 1)*2 ); return 0;&#125; 1012 The Best Rank 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;using namespace std;int N, M;struct Student&#123; int id; // c m e a int g[4], r[4]; char c[4] = &#123;'A', 'C', 'M', 'E'&#125;;&#125;typedef stu;std::vector&lt;stu&gt; v;int num=0;bool cmp(stu &amp;f1 , stu &amp;f2)&#123; return f1.g[num] &gt; f2.g[num];&#125;void getRank()&#123; for (int j = 0; j &lt; 4; ++j)&#123; sort(v.begin(), v.end(), cmp); for (int i = 0; i &lt; N; ++i)&#123; v.at(i).r[num] = i+1; &#125; num++; &#125;&#125;void maxRank(const stu *s)&#123; int best_rank = 0; for (int i = 1; i &lt;4; i++)&#123; if(s-&gt;r[i] &lt; s-&gt;r[best_rank]) best_rank = i; &#125; cout &lt;&lt; s-&gt;r[best_rank] &lt;&lt; \" \" &lt;&lt; s-&gt;c[best_rank] &lt;&lt; endl;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt;M; // scanf(\"%d%d\", &amp;N, &amp;M); for (int i = 0; i &lt; N; ++i)&#123; stu *s = new stu(); cin &gt;&gt; s-&gt;id &gt;&gt; s-&gt;g[1] &gt;&gt; s-&gt;g[2] &gt;&gt; s-&gt;g[3]; s-&gt;g[0] = (s-&gt;g[1] + s-&gt;g[2]+ s-&gt;g[3])/3; v.emplace_back(*s); &#125; getRank(); for (int i = 0; i &lt; M; ++i)&#123; int tmpid; bool find=false; cin &gt;&gt; tmpid; for (int i = 0; i &lt; N; ++i)&#123; if ( v.at(i).id == tmpid) &#123; maxRank(&amp;v.at(i)); find=true; &#125; &#125; if (!find) cout &lt;&lt; \"N/A\" &lt;&lt; endl; &#125; return 0;&#125; 1013 Battle Over Cities In:给出n个城市，城市间有m条路，k个要检查的城市 Out:假如被检查的城市ki被攻占，则所有与Ki相关的路线全部瘫痪，要使其他城市保持连通，至少需要修缮多少条路?即 删除图的一个节点，是其他节点成为连通图，至少需要添加多少条线 解法一:图的遍历:DFS计算连通分量数目==&gt; 计算出连通分量数N。如果想要构成连通图，那么需要添加res=N-1条线，即最少需要N-1条线。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;#define SIZE 1001using namespace std;int p[SIZE][SIZE];bool visit[SIZE];int n; // 顶点数// 找到node下的所有连通节点,把其标记为truevoid dfs(int node)&#123; visit[node] = true; for (int i = 1; i &lt;= n; ++i)&#123; if ( visit[i] == false &amp;&amp; p[node][i] == 1)&#123; dfs(i); &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; // 边数和case数 int m ,k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; m; ++i)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; p[u][v] = p[v][u] = 1; &#125; // case K for (int i = 0; i &lt; k; ++i)&#123; int cnt=0; int tmp; // 每次都得重置visit 即所有城市未被遍历 fill(visit, visit+SIZE, false); cin &gt;&gt; tmp; visit[tmp] = true; // 不让tmp进入考虑 for (int j = 1; j &lt;= n; ++j)&#123; if (visit[j] == false)&#123; dfs(j); cnt ++; &#125; &#125; cout &lt;&lt; cnt-1 &lt;&lt; endl; &#125; return 0;&#125; 解法二:无向图的连通性，可以考虑并查集==&gt; 但是需要注意最后结果的处理，并查集后可以知道现在的图分成了几块，但是有一块肯定是被占领的那一个城市，所以结果记得减去这一块，还有，两块地图联通只需要修建一条道路。综上所述，res=图的块数-2； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std; const int N=1010; int f[N]; //存储boss；用来计算有几个连通分量的int c;int n,m,k;vector&lt;pair&lt;int,int&gt; &gt;a;//存储城市之间的连接(边)；int getf(int v)//递归查找boss；&#123; if(f[v]==v) return v; else return f[v]=getf(f[v]);&#125; void merge(int u,int v)//合并；&#123; int t1=getf(u); int t2=getf(v); if(t1!=t2)//boss节点不同就合并； &#123; f[t2]=t1; &#125;&#125; void init()//初始化；&#123; for(int i=1; i&lt;=n; i++) &#123; f[i]=i;//自己的boss是自己； &#125;&#125; // 图被分成了2部分:// 1.与城市X相连的点(不会进行merge)、 X城市本身 (sum的两个组成部分)// 2.与X不相连的(会进行merge)int pan(int x)&#123; // x为被占领的城市 int sum=0; for(int i=0; i&lt;a.size(); i++)&#123; if((a[i].first!=x) &amp;&amp; (a[i].second!=x))//和城市x相连的路全部断掉； merge(a[i].first,a[i].second);//不是和城市x相连的就合并； &#125; //查看整个图分成了几块； for(int i=1; i&lt;=n; i++)&#123; if(f[i]==i) sum++; &#125; /** * 结果记得处理； * n个节点,需要n-1条边才能构成连通分量; * △还有节点x自己得去掉,这也是跟1的区别(会多数个本身); */ return sum-2;&#125;//除去被占领的城市，两个城市之间只需要一条路连接； int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); a.resize(m);//设置容器的大小； for(int i=0; i&lt;m; i++)&#123; int aa,bb; scanf(\"%d%d\",&amp;aa,&amp;bb); // a[i]=make_pair(aa,bb); a.push_back(make_pair(aa,bb)); &#125; for(int i=1; i&lt;=k; i++)&#123; // c为被占领的城市 scanf(\"%d\",&amp;c); init(); int res= pan(c); printf(\"%d\\n\",res); &#125; return 0;&#125; 1014 Waiting in Line 队列queue的模拟操作，分两部分解决，一部分是在黄线中的M*N个人，直接进行操作，另一部分黄线外的人需要一个个判断，哪个窗口目前是最少的，然后对该窗口进行更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#include &lt;queue&gt;using namespace std;struct windows&#123; // 前者为队首顾客出队时间：为了计算让黄线外的人可以计算出哪一个队列先空出人来 // 后者为队尾顾客出队时间：为了计算入队后加上自己本身的taketime可以计算出自己何时才能被服务完毕 // 以及得知自己是不是需要被Sorry(如果前一个人服务结束时间超过17:00，自己当前入队的人就是sorry) int start_pop_time, end_pop_time; // 该窗口排队的人 queue&lt;int&gt; q;&#125;typedef win;int main()&#123; // n个窗口， m个黄线内顾客， 总共k个顾客， 求解q个询问 int n, m, k, q; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;q); std::vector&lt;int&gt; taketime(k+1); // 每个cos需要的处理时间 std::vector&lt;int&gt; quiz(k+1); // 测验 std::vector&lt;bool&gt; sorry(k+1, false); // 是否能被服务 std::vector&lt;win&gt; window(n+1); // 窗口 for(int i=1;i&lt;=k;i++)scanf(\"%d\", &amp;taketime[i]); // 解答 // 指针，当前新被处理的人， 从1号顾客开始 int index=1; // 如果总人数正好在m*n范围内 for (int i = 1; i &lt;= m; ++i)&#123; for (int j = 1; j &lt;= n; ++j)&#123; if (index &lt;= k)&#123; window[j].q.push(taketime[index]); // 如果该窗口处理当前黄线内排队的人已经有大于540的了，那么新加入的必sorry if (window[j].end_pop_time&gt;=(17-8)*60) sorry[index] = true; // 当前窗口的结束时间更新规则为： 已有的结束时间 + 当前顾客index的服务时间 window[j].end_pop_time += taketime[index]; // 第一个pop的时间需要特殊处理一下 if (i==1) window[j].start_pop_time = window[j].end_pop_time; // 在这种情况下， 顾客的结束时间就是该窗口的end_time quiz[index] = window[j].end_pop_time; // 处理下一个顾客 index++; &#125; &#125; &#125; // 如果k&gt;m*n，那么在这边处理 剩下的index~k位顾客，此时需要不断更新window安排顾客进栈 while( index &lt;= k)&#123; int min_time = window[1].start_pop_time, min_win = 1; // 黄线外顾客要找到一个对他来说最短的窗口， 编号小的优先 for (int i = 2; i &lt;= n; ++i)&#123; if ( window[i].start_pop_time &lt;= min_time)&#123; min_time = window[i].start_pop_time; min_win = i; &#125; &#125; // 将最短窗口的队首顾客出队 window[min_win].q.pop(); // 黄线外第一个顾客入队 window[min_win].q.push(taketime[index]); // 更新队首的顾客结束时间 window[min_win].start_pop_time += window[min_win].q.front(); // 如果该窗口处理当前黄线内排队的人已经有大于540的了，那么新加入的必sorry if (window[min_win].end_pop_time&gt;=(17-8)*60) sorry[index] = true; // 当前窗口的结束时间更新为： 已有的时间 + 新进入的顾客的处理时间 window[min_win].end_pop_time += taketime[index]; // 在这种情况下， 顾客的结束时间就是该窗口的end_pop_time quiz[index] = window[min_win].end_pop_time; // 处理下一个顾客 index++; &#125; // 回答问题 for(int i = 1; i &lt;= q; i++) &#123; int query, ans; scanf(\"%d\", &amp;query); ans = quiz[query]; // 先判断是否sorry， 如果非sorry， 那么就有服务结束时间 if(sorry[query] == true) printf(\"Sorry\\n\"); // 规范输出结果 else printf(\"%02d:%02d\\n\",(ans + 8*60) / 60, (ans + 8*60) % 60); &#125; return 0;&#125; 1016 Phone Bills 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; // 写法一 string date; cin &gt;&gt; date; const char *s = date.data(); int month, day, hour, minute; sscanf(s, \"%d:%d:%d:%d\", &amp;month, &amp;day, &amp;hour, &amp;minute); cout &lt;&lt; month &lt;&lt; \"\\t\"&lt;&lt;day&lt;&lt;\"\\t\"&lt;&lt;hour&lt;&lt;\"\\t\"&lt;&lt;minute&lt;&lt; endl; // 写法二 string date; cin &gt;&gt; date; stringstream ss(date); string month, day, hour, minute; getline(ss, month, ':'); cout &lt;&lt; month&lt;&lt;endl; getline(ss, day, ':'); cout &lt;&lt; day&lt;&lt;endl; getline(ss, hour, ':'); cout &lt;&lt; hour&lt;&lt;endl; getline(ss, minute, ':'); cout &lt;&lt; minute&lt;&lt;endl; return 0;&#125; 1017 Queueing at Bank 将达到时间换算成秒（这样可以避免小数），我这里将到达时间以开门时间（8点）为0值，来早的即为负数（绝对值为等待时间），然后进行排序。 判断有效人数是否大于0，不是则提前输出0.0（保留一位小数！！） 设置windows[k]为窗口可以处理下一个客户的时间，默认值为0 1018 Public Bike Management 1019 General Palindromic Number 1020 Tree Traversals 考察树的遍历。二叉树的前序、中序、后序遍历需要用到栈（递归的过程也就是一个栈）(DFS)，层次遍历需要借助队列这个数据结构==&gt;(BFS)。 中序的结构的特点是：左子树+根结点+右子树。 而后序结构的特点是：左子树+右子树+根结点。 解题思路:后序(postOrder)和先序(preOrder)遍历提供根节点位置，然后再中序(inOrder)序列中区分出左子树和右子树，递归建树，然后BFS层序遍历。 柳婼Code 二叉树利用数组来完成, 未使用结构体 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; post, in, level(100000, -1);void pre(int root, int start, int end, int index) &#123; cout&lt;&lt;\"root = \"&lt;&lt;root&lt;&lt;\" start\"&lt;&lt;start&lt;&lt;\" end=\"&lt;&lt;end&lt;&lt;\" index=\"&lt;&lt;index&lt;&lt;endl; if(start &gt; end) return ; int i = start; // 通过后序根节点找到中序根节点的索引 while(i &lt; end &amp;&amp; in[i] != post[root]) i++; // 对于后序遍历，最后一个结点是根节点 level[index] = post[root]; // 【这段递归是本代码的亮点所在】 // (root -(end - i + 1)) 后序root地址 - (中序左子树长度)，得到下一次的左子树的后序root地址 pre(root - (end - i + 1), start, i - 1, 2 * index + 1); // root - 1 后序root地址 左邻接点右子树的根 pre(root - 1, i + 1, end, 2 * index + 2);&#125;int main() &#123; int n, cnt = 0; scanf(\"%d\", &amp;n); // 预置n个结点 post.resize(n); in.resize(n); for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;post[i]); for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;in[i]); pre(n-1, 0, n-1, 0); for(int i = 0; i &lt; level.size(); i++) &#123; // if (level[i] != -1) &#123; if (cnt != 0) printf(\" \"); printf(\"%d\", level[i]); cnt++; &#125; if (cnt == n) break; &#125; return 0;&#125; My 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 50;int post[MAXN], in[MAXN];int n;int num; struct Node&#123; int v; Node *lchild; Node *rchild;&#125;typedef Node;/** * [根据中序和先序遍历构建树, 参数全为索引] * @author mrli 2020-01-28 * @param postl [后序左边界] * @param postr [后序右边界] * @param inl [中序左边界] * @param inr [中序右边界] * @return [节点] */Node *createTree(int postl, int postr, int inl, int inr)&#123; // 先序左指针&gt;右指针 if (postl&gt;postr) return NULL; int k; // 找到根节点后序的索引值 for (k = 0; k &lt;= inr; ++k) if (in[k] == post[postr]) break; // 分界线 int numLeft = k - inl; Node* root = new Node(); root-&gt;v = post[postr]; root-&gt;lchild = createTree(postl, postl+numLeft-1, inl, k-1); root-&gt;rchild = createTree(postl+numLeft, postr-1, k+1, inr); return root;&#125;// 对numLeft定义进行了修改Node *createTree(int postl, int postr, int inl, int inr)&#123; // 先序左指针&gt;右指针 if (postl&gt;postr) return NULL; int k; // 找到根节点中序的索引值: 后序遍历的最后一个为根节点,由于都是不同的数,所以找到值相等的, // 此时k即为中序遍历中根的索引值 for (k = 0; k &lt;= inr; ++k) if (in[k] == post[postr]) break; // 计算左子树节点个数X ==&gt; 找到分界线, postl+numLeft-1为后序的左子树, post+numLeft为后序右子树. // 真正意义上的左子树节点个数numLeft = k - inl - 1 int numLeft = k - inl -1; Node* root = new Node(); root-&gt;v = post[postr]; // 后序遍历访问左子树时,左边界不变认为postl, 右边界变为postr+numLeft-1,访问右子树时,左边界为postl+numLeft, 右边界为postr-1(去掉了此轮的根节点) // postl + numleft 也为第二个根节点索引值 // k为中序遍历节点的根, 所以访问左子树时左边界改为k-1, 右边界为k+1;访问右子树时左边界为k+1,右边界为inr root-&gt;lchild = createTree(postl, postl+numLeft, inl, k-1); root-&gt;rchild = createTree(postl+numLeft+1, postr-1, k+1, inr); return root;&#125;void BFS(Node* tree)&#123; queue&lt;Node*&gt; q; q.push(tree); while(!q.empty())&#123; Node* now = q.front(); q.pop(); cout &lt;&lt; now-&gt;v; num ++; if (num &lt; n) cout &lt;&lt;\" \"; if (now-&gt;lchild != NULL) q.push(now-&gt;lchild); if (now-&gt;rchild != NULL) q.push(now-&gt;rchild); &#125;&#125;int main(int argc, char const *argv[])&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; post[i]; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; in[i]; Node* tree = createTree(0, n-1, 0, n-1); BFS(tree); return 0;&#125; Codeup问题 A: 复原二叉树 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1e3 + 5;string pre;string in;struct Node&#123; char v; Node* lc, *rc;&#125;;Node *createTree(int preL, int preR, int inL, int inR)&#123; if (preL &gt; preR) return NULL; Node *root = new Node(); root-&gt;v = pre[preL]; // 先序找到根节点 int k; // 根节点在中序遍历中的 for (k = inL; k &lt; inR; ++k)&#123; // ▲千万不要多Int会再声明成局部变量 if (in[k] == pre[preL]) // 找到根节点 break; &#125; int numLeft = k-inL; // 由于不包括K, 所以不需要+1 // 左子树继续 root-&gt;lc = createTree(preL+1, preL+ numLeft, inL, k-1); // 右子树 root-&gt;rc = createTree(preL+numLeft+1, preR, k+1, inR); return root;&#125;void postOrder(Node *root)&#123; if(root == NULL) return ; postOrder(root-&gt;lc); postOrder(root-&gt;rc); cout &lt;&lt; root-&gt;v;&#125;int main(int argc, char const *argv[])&#123; while(cin &gt;&gt; pre &gt;&gt; in)&#123; Node *root = createTree(0, pre.size()-1, 0, in.size()-1); postOrder(root); cout &lt;&lt; endl; &#125; return 0;&#125; ▲前提都是不同元素！ Codeup问题 B: 二叉树 根据完全二叉树的性质：左孩子的编号一定是2m， 右孩子一定是2m+1。可以写出暴力递归的写法， 但是会超时。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1e3 + 5;int m, n; // 求解， 总共节点数int ans;void cnt(int v)&#123; if(v &gt; n) return; cnt(2*v); cnt(2*v+1); ans ++ ;&#125;int main(int argc, char const *argv[])&#123; while(cin &gt;&gt; m &gt;&gt; n)&#123; if ( m == 0 &amp;&amp; n == 0) break; ans = 0; cnt(m); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 改用递推写法： 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1e3 + 5;int main(int argc, char const *argv[])&#123; int m, n; // 求解， 总共节点数 while( cin &gt;&gt; m &gt;&gt; n &amp;&amp; n &amp;&amp; m)&#123; int ans = 1; int l= 2*m, r = 2*m+1; while(r &lt;= n)&#123; // 如果当前行的节点数是全的（不是最后一行残缺行） ans += r - l + 1; // 加上该行所有节点 l = l*2, r = r*2 + 1; // 继续向下 &#125;// 当找到最后一行时跳出 if ( l &lt;= n )&#123; // 判断最后一行是否有节点 ans += n - l + 1; // 有的话加上 &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Codeup 问题 D: 二叉树遍历 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e3 + 5;int n; // 总共的节点数string str;int depth=-1;struct Node&#123; char v; Node *lc, *rc;&#125;;Node *createTree()&#123; Node *root = new Node; depth ++; if(str[depth] == '#') &#123; return NULL; &#125; root-&gt;v = str[depth]; root-&gt;lc = createTree(); root-&gt;rc = createTree(); return root;&#125;void inOrder(Node *root)&#123; if(root == NULL) return; inOrder(root-&gt;lc); cout &lt;&lt; root-&gt;v &lt;&lt;\" \" ; inOrder(root-&gt;rc);&#125;int main(int argc, char const *argv[])&#123; while(cin &gt;&gt; str)&#123; depth = -1; Node *root= createTree(); inOrder(root); cout &lt;&lt; endl; &#125; return 0;&#125; 更多Codeup的专题训练放在《算法笔记Codeup题解》中了。 1021 Deepest Root 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/* * @Author: Mrli * @Date: 2020-06-03 15:28:11 * @LastEditTime: 2020-06-03 15:57:35 * @Description: */ #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e4 + 5;int arr[MAXN]; // 连通块数量vector&lt;int&gt; G[MAXN]; // 领接表int n; // 节点数void init()&#123; for (int i = 1; i &lt;= n ; i++) &#123; arr[i] = i; &#125;&#125;// 递归写法int find(int u)&#123; if ( find(u) == u) return u; else&#123; arr[u] = find(arr[u]); return arr[u]; &#125;&#125;// 迭代写法// node为某次具体操作节点, tmp_node为其能找到group头// 关系类似链表中的p、q, 一个当前, 一个记录下一个或上一个节点int findFather(int v)&#123; int node = v; while ( arr[v] != v ) &#123; v = arr[v]; &#125; // v此时指向的是该group的头 // 路径压缩, 把该group中所有成员都指向一个头v while ( node != arr[node] )&#123; int tmp_node = node; node = arr[node]; arr[tmp_node] = v; &#125; return v;&#125;int countBlock()&#123; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; if ( arr[i] == i) ans ++; &#125; return ans;&#125;void merge(int u, int v)&#123; // int fa = find(u); // int fb = find(v); int fa = findFather(u); int fb = findFather(v); if ( fa != fb ) arr[fa] = fb; &#125;vector&lt;int&gt; temp, ans;int maxHeight;void DFS(int u, int height, int pre)&#123; if (height &gt; maxHeight)&#123; temp.clear(); temp.push_back(u); maxHeight = height; &#125;else if (height == maxHeight)&#123; temp.push_back(u); &#125; for (int v = 0; v &lt; G[u].size(); v++) &#123; if (G[u][v] == pre) continue; DFS(G[u][v], height+1, u); &#125;&#125;int main()&#123; cin &gt;&gt; n; int bian = n-1; init(); while(bian--)&#123; int u, v; cin &gt;&gt; u &gt;&gt;v; G[u].push_back(v); G[v].push_back(u); merge(u, v); &#125; int block_num = countBlock(); // 只有一个连通块的N个节点, n-1条边一定是树 if (block_num == 1)&#123; DFS(1, 1, -1); ans = temp; // 随意找ans中的节点 DFS(ans[0], 1, -1); // 取并集 for (int i = 0; i &lt; temp.size(); i++) &#123; ans.push_back(temp[i]); &#125; sort(ans.begin(), ans.end()); cout &lt;&lt; ans[0] &lt;&lt;endl; for (int i = 1; i &lt; ans.size(); i++) &#123; if (ans[i] != ans[i-1]) cout &lt;&lt; ans[i] &lt;&lt; endl; &#125; &#125;else&#123; cout &lt;&lt; \"Error: \" &lt;&lt; block_num &lt;&lt; \" components\" &lt;&lt;endl; &#125; return 0;&#125; 1023 Have Fun with Numbers 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;unordered_map&lt;char, int&gt; mp;// 高精度*低精度string multiply(const string s, int n)&#123; string ans; int t = 0; int len = s.length(); string rev = s; reverse(rev.begin(), rev.end()); for (int i = 0; i &lt; len|| t; i++) &#123; if ( i &lt; len )&#123; t += (rev[i] - '0') * n; mp[rev[i]] += 1; &#125; ans += char(t%10+'0'); t /= 10; &#125; while( ans.length() &gt; 1 &amp;&amp; ans.back() == '0') ans.pop_back(); reverse(ans.begin(), ans.end()); return ans;&#125;string doubleIt(const string s)&#123; return multiply(s, 2);&#125;bool YesorNo()&#123; for(unordered_map&lt;char, int&gt;::iterator it = mp.begin(); it != mp.end() ; it++)&#123; if (it-&gt;second != 0) return false; &#125; return true;&#125;int main()&#123; string n; cin &gt;&gt; n; string doublen = doubleIt(n); for (int i = 0; i &lt; doublen.size(); i++) &#123; // cout &lt;&lt; doublen[i] &lt;&lt; \" \" &lt;&lt; mp[doublen[i]] &lt;&lt; endl; mp[ doublen[i] ]--; &#125; string ans = YesorNo() ? \"Yes\" : \"No\"; cout &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; doublen &lt;&lt;endl; return 0;&#125; unordered_map使用: https://blog.csdn.net/fengbingchun/article/details/52235026 Palindromic Number 大数相加 闫总模板: https://www.acwing.com/blog/content/277/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;string add(string a, string b)&#123; string ans; // 第四个点， 去前置0 a = a.substr(a.find_first_not_of(\"0\")); b = b.substr(b.find_first_not_of(\"0\")); reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int t = 0; for (int i = 0; i &lt; a.size() || i &lt; a.size() || t; i++) &#123; if ( i &lt; a.size() ) t += a[i] - '0'; if ( i &lt; b.size() ) t += b[i] - '0'; ans += char(t % 10 + '0'); t /= 10; &#125; reverse(ans.begin(), ans.end()); return ans.substr(ans.find_first_not_of(\"0\"));&#125;string getReverseString(string a)&#123; string s(a.rbegin(), a.rend()); return s;&#125;bool isPalindromic(string n)&#123; int len = n.length(); // 第三个测试点： 1也算是回文数==&gt; 如果是个数的话， 那么step为0 // if (len == 1 || len == 0) return false; for (int i = 0, j = len - 1; i &lt; len; i++, j--) &#123; if ( n[i] != n[j]) return false; &#125; return true;&#125;int main()&#123; string n; int T; cin &gt;&gt; n &gt;&gt; T; string tmp = n; int i; for (i = 0; i &lt; T; i++) &#123; if (isPalindromic(tmp)) &#123; break; &#125; tmp = add(tmp, getReverseString(tmp)); &#125; cout &lt;&lt; tmp &lt;&lt; endl &lt;&lt; i &lt;&lt; endl; return 0;&#125; 1025 PAT Ranking 通过率为0.27, 题意较简单, 但是处理起来会有坑，也算学习到了吧。 vector的拼接： v.insert(v.begin(), va.begin(), va.end()) sort自定义函数：在嵌套比较时注意if的条件，return true的将会被放在前面 排名的处理: 排名相同的一致，不同的在其排序索引上+1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;struct rc&#123; string ID; //记录ID int grade; //成绩 int local_num; //场次 int local_rank; //该场次的排名&#125;typedef rc;bool cmp(rc &amp;a, rc &amp;b)&#123; if(a.grade != b.grade) return a.grade&gt;b.grade; else return (a.ID&lt;b.ID);&#125;/**或者写成bool cmp(const node &amp;a, const node &amp;b)&#123; return a.score==b.score ? a.id&lt;b.id : a.score&gt;b.score; // 如果得分相等,ID小的在前,如果得分不等,那么得分大的在前&#125;*/int main(int argc, char const *argv[])&#123; int N; cin &gt;&gt; N; std::vector&lt;rc&gt; vall; for (int j = 1; j &lt;= N; ++j)&#123; int K; cin &gt;&gt; K; std::vector&lt;rc&gt; v; for (int i = 0; i &lt; K; ++i)&#123; rc r; cin &gt;&gt; r.ID &gt;&gt; r.grade; r.local_num = j; v.push_back(r); &#125; sort(v.begin(), v.end(), cmp); // 先将当局排名算出 int rank = 1; int rankv = v[0].grade; v[0].local_rank = rank; for (int i = 1; i &lt; v.size(); ++i)&#123; // 思路 // if(rankv == v[i].grade)&#123; // v[i].local_rank = rank; // &#125;else&#123; // rank = i+1; // v[i].local_rank = rank; // &#125; /* 简洁写法 */ if(rankv != v[i].grade)&#123; rank = i+1; &#125; v[i].local_rank = rank; rankv = v[i].grade; &#125; vall.insert(vall.end(), v.begin(), v.end()); // 将每个场次的结果拼起来 &#125; sort(vall.begin(), vall.end(), cmp); // 对总结果进行排序算出finalRank int Ssize = vall.size(); cout &lt;&lt; Ssize &lt;&lt; endl; int finalRank = 1; // 用来处理排名相同的情况 int rankv = vall[0].grade; // 用来确定何时排名相同 cout &lt;&lt; vall.at(0).ID &lt;&lt; \" \"&lt;&lt;finalRank &lt;&lt; \" \"&lt;&lt;vall.at(0).local_num &lt;&lt; \" \"&lt;&lt;vall.at(0).local_rank &lt;&lt; endl; for (int i = 1; i &lt; Ssize; ++i)&#123; // 这样看思路更清晰一点 // if(rankv == vall[i].grade)&#123; // cout &lt;&lt; vall.at(i).ID &lt;&lt;\" \"&lt;&lt; finalRank &lt;&lt;\" \"&lt;&lt; vall.at(i).local_num &lt;&lt;\" \"&lt;&lt; vall.at(i).local_rank &lt;&lt; endl; // &#125;else&#123; // finalRank = i+1; // cout &lt;&lt; vall.at(i).ID &lt;&lt;\" \"&lt;&lt; finalRank &lt;&lt;\" \"&lt;&lt; vall.at(i).local_num &lt;&lt;\" \"&lt;&lt; vall.at(i).local_rank &lt;&lt; endl; // &#125; /* 简洁写法 */ if(rankv != vall[i].grade)&#123; finalRank = i+1; &#125; cout &lt;&lt; vall.at(i).ID &lt;&lt;\" \"&lt;&lt; finalRank &lt;&lt;\" \"&lt;&lt; vall.at(i).local_num &lt;&lt;\" \"&lt;&lt; vall.at(i).local_rank &lt;&lt; endl; rankv = vall[i].grade; &#125; return 0;&#125; ▲我这边判断两个rc是否相同，是用rankv和finalrank来记录上一次的结果的，其实还能在for里面判断v.[i].grade == v[i-1].grade 1027 Colors in Mars 考察点： 进制的转换 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;string int2string(int ans)&#123; switch(ans)&#123; case 10: return \"A\"; case 11: return \"B\"; case 12: return \"C\"; default: return to_string(ans); &#125;&#125;string decimal2radix(int n)&#123; if(n&lt;13) return \"0\"+int2string(n); int tmp = n; string res; while(tmp&gt;0)&#123; res.insert(0, int2string(tmp%13)); tmp /= 13; &#125; return res;&#125;int main(int argc, char const *argv[])&#123; int r, g, b; cin &gt;&gt; r &gt;&gt; g &gt;&gt; b ; cout &lt;&lt; \"#\" &lt;&lt; decimal2radix(r) &lt;&lt; decimal2radix(g) &lt;&lt; decimal2radix(b) &lt;&lt; endl; return 0;&#125; 1034 Head of a Gang 题目很难理解。首先要明确的是本题为无向图。 涉及一个点权的维护， 在增加一条边的时候，把这个边的两端点都加上相应的权值。 需要做的是： DFS遍历每个连通块， 获得点权最大的点、 成员个数（&gt;2)、 总边权（&gt;K) 本题也可以使用并查集解决。在使用并查集时，只要注意合并函数中需要总是保持点权更大的结点为集合的根结点（原先的合并函数是随意指定其中一个根结点为合并后集合的根结点），就能符合题目的要求。而为了达到题目对总边权与成员人数的要求，需要定义两个数组：一个数组用来存放以当前结点为根结点的集合的总边权；另一个数组用来存放以当前结点为根结点的集合中的成员人数。这样当所有通话记录合并处理完毕后，这两个数组就自动存放了每个集合的总边权和成员人数，再根据题意进行筛选即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 2e3 + 5;const int INF = 0x3f3f3f3f;// map&lt;stirng, int&gt;可以直接按字典序排序； 如果要自己定义结构体， 得实现排序功能std::map&lt;string, int&gt; gang;std::map&lt;int, string&gt; int2string; // 通过遍历后找到的节点编号ID来反着找到字符串IDstd::map&lt;string, int&gt; string2int; // 用来检索当前字符串ID是否存在int G[MAXN][MAXN]; // 邻接矩阵int ts[MAXN] = &#123;0&#125;; // 权值数组, 记录每个点的点权bool visited[MAXN] = &#123;false&#125;;int numPerson = 0; // 结点编号, 最终为一共有的节点数int N, K;void dfs(int u, int &amp;head, int &amp;numMember, int &amp;totalValue)&#123; visited[u] = true; numMember ++; if ( ts[u] &gt; ts[head] )&#123; // 如果当前访问节点的点权大于head的点权，则更换头目 head = u; &#125; for (int v = 0; v &lt; numPerson; ++v)&#123; if(G[u][v] &gt; 0)&#123; // 存在边可达 totalValue += G[u][v]; // 连通块的总边权增加该边权 G[u][v] = G[v][u] = 0; // 删除此边防止回头 if(visited[v] == false)&#123; dfs(v, head, numMember, totalValue); &#125; &#125; &#125;&#125;void dfsTravel()&#123; for (int i = 0; i &lt; numPerson; ++i)&#123; if (visited[i] == false)&#123; int head = i, numMember = 0, totalValue = 0; dfs(i, head, numMember, totalValue); if(numMember &gt; 2 &amp;&amp; totalValue &gt; K)&#123; gang[int2string[head]] = numMember; &#125; &#125; &#125;&#125;// 将输入的字符编号转换为数字编号int change(string tmp)&#123; if ( string2int.find(tmp) != string2int.end() )&#123; // 如果存在 return string2int[tmp]; &#125;else&#123; // 如果不存在 string2int[tmp] = numPerson; int2string[numPerson] = tmp; return numPerson++; // 放回编号 &#125;&#125;int main(int argc, char const *argv[])&#123; cin &gt;&gt; N &gt;&gt;K; int t; for (int i = 0; i &lt; N; ++i)&#123; string a, b; cin &gt;&gt; a &gt;&gt; b &gt;&gt; t; int id1 = change(a); // 将结点字符转换为数字编号 int id2 = change(b); ts[id1] += t; ts[id2] += t; G[id1][id2] += t; G[id2][id1] += t; // 用vector(int) G[MAXN]不行-&gt;vector没初始化不允许相加 &#125; dfsTravel(); cout &lt;&lt; gang.size() &lt;&lt;endl; for (std::map&lt;string, int&gt;::iterator i = gang.begin(); i != gang.end(); ++i)&#123; cout &lt;&lt; i-&gt;first &lt;&lt;\" \" &lt;&lt; i-&gt;second &lt;&lt;endl; &#125; return 0;&#125; ▲. map&lt;type1，type2&gt;是自动按照 type1从小到大进行排序的，因此使用map&lt;string，int&gt;建立头目姓名与成员人数的关系便于输出结果。当然，也可以使用结构体来存放头目姓名与成员人数，如下所示 123456789struct Gang&#123; string head; int numMember;&#125;Gangarr[MAXN];// 按字典序排序， map有这个功能bool cmp(Gang &amp;a, Gang &amp;b)&#123; return a.head &lt; b.head;&#125; 补充： vector初始化 1234567891011// 一位初始化 // 指定初始化std::vector&lt;int&gt; v = &#123;2, 3, 4, 5&#125;; // 5个0std::vector&lt;int&gt; v(5); // 5个2std::vector&lt;int&gt; v(5, 2);...// 二维初始化std::vector&lt;int&gt; v[MAXN]= &#123;&#123;2, 4, 1&#125;, &#123;3, 5, 7&#125;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;const int N = 1e5 + 5;struct staticList&#123; int nxt; char val; bool visited; // 结构体数组每个元素都会经过这个初始化过程, 因此这步就可以直接初始化 staticList(): visited(false)&#123;&#125;;&#125;arr[N];using namespace std;int main()&#123; int start1, start2, n; scanf(\"%d %d %d\", &amp;start1, &amp;start2, &amp;n); int t = n; int addr, nexta; char c; while(t--)&#123; scanf(\"%d %c %d\", &amp;addr, &amp;c, &amp;nexta); arr[addr].val = c; arr[addr].nxt = nexta; &#125; int ans; // 注意这边结束结束条件是ans!=-1 // 如果写成arr[addr].nxt != -1, 第4个测试点会超时 // 原因是如果start就为-1, 那么会调到0, 0-&gt;0, // 实际上道理就跟写链表一样: while(head != NULL) for (ans = start1; ans != -1; ans = arr[ans].nxt) &#123; arr[ans].visited = true; &#125; for (ans = start2; ans != -1; ans = arr[ans].nxt) &#123; if (arr[ans].visited) break; &#125; // if (arr[ans].nxt != -1) if (ans != -1) printf(\"%05d\\n\", ans); else printf(\"-1\\n\"); return 0;&#125; 1028 List Sorting (25分) 简单排序, 但是不能用cin, 不然会超时。用ios::sync_with_stdio可以过 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;struct record&#123; string id; string name; int grade; record()&#123;&#125; record(string idx, string namex, int gradex): id(idx), name(namex), grade(gradex)&#123;&#125;&#125;typedef record;bool cmp1(const record &amp;r1, const record &amp;r2)&#123; return r1.id &lt; r2.id;&#125;bool cmp2(const record &amp;r1, const record &amp;r2)&#123; if (r1.name == r2.name)&#123; return r1.id &lt; r2.id; &#125; return r1.name &lt; r2.name;&#125;bool cmp3(const record &amp;r1, const record &amp;r2)&#123; if (r1.grade == r2.grade) return r1.id &lt; r2.id; return r1.grade &lt; r2.grade;&#125;int main()&#123; int n, c; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt;c; vector&lt;record&gt; v; for (int i = 0; i &lt; n; i++) &#123; string idx, name; int grade; cin &gt;&gt; idx &gt;&gt; name &gt;&gt; grade; record r = record(idx, name, grade); v.push_back(r); &#125; if (c == 1)&#123; sort(v.begin(), v.end(), cmp1); &#125;else if (c == 2)&#123; sort(v.begin(), v.end(), cmp2); &#125;else&#123; sort(v.begin(), v.end(), cmp3); &#125; for (int i = 0; i &lt; v.size(); i++) &#123; record r = v.at(i); cout &lt;&lt; r.id &lt;&lt;\" \" &lt;&lt; r.name &lt;&lt; \" \" &lt;&lt;r.grade &lt;&lt;endl; &#125; return 0;&#125; 1029 Median 12345678910111213141516171819202122232425262728293031323334353637383940414243 #include &lt;bits/stdc++.h&gt; using namespace std;typedef long long ll; int main()&#123; ios::sync_with_stdio(false); int n, m; vector&lt;ll&gt; v1; vector&lt;ll&gt; v2; ll tmp; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; v1.push_back(tmp); &#125; cin &gt;&gt; m; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; tmp; v2.push_back(tmp); &#125; int a = 0, b = 0; int x = 0; int len1 = v1.size(), len2 = v2.size(); int sumlen = len1 + len2 + 1 &gt;&gt; 1; ll ans = -1; for (int i = 0, j = 0, k = 0; k &lt; sumlen ; k++) &#123; if ( ( i &lt; len1 &amp;&amp; j &gt;= len2 ) || ( i &lt; len1 &amp;&amp; j &lt; len2 &amp;&amp; v1[i] &lt;= v2[j]) )&#123; ans = v1[i]; i++; &#125;else&#123; ans = v2[j]; j++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 下面做法是v1, v2在末尾都加了个无穷大的数, 保证不会越界, 在自己遍历完后直接遍历另一个vec。 思路跟PAT甲级辅导课（试听课）（二）讲坏掉的键盘[#1084](#1084 Broken Keyboard)一样，防止j++无限的加， 最后b[j]越出边界，添加了一个不会出现的字符# 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;int main()&#123; ios::sync_with_stdio(false); int n1, n2; cin &gt;&gt; n1; vector&lt;int&gt; v1, v2; int tmp; for (int i = 0; i &lt; n1; i++) &#123; cin &gt;&gt; tmp; v1.push_back(tmp); &#125; v1.push_back(INF); cin &gt;&gt; n2; for (int i = 0; i &lt; n2; i++) &#123; cin &gt;&gt; tmp; v2.push_back(tmp); &#125; v2.push_back(INF); int cnt = 0; int mid = (n1+n2-1)/2; int i= 0, j=0; while(cnt &lt; mid)&#123; if ( v1[i] &lt; v2[j])&#123; i ++; &#125;else&#123; j ++; &#125; cnt ++; &#125; if (v1[i] &lt; v2[j]) cout &lt;&lt; v1[i] &lt;&lt; endl; else cout &lt;&lt; v2[j] &lt;&lt; endl; return 0;&#125; ▲1030 Travel Plan 练习dijkstra和 dijkstra+dfs 最经典、合适的一题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/* * @Author: Mrli * @Date: 2020-07-19 15:38:12 * @LastEditTime: 2020-07-19 16:18:08 * @Description: */ #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3 + 5;int n, m;int arr[maxn][maxn];vector&lt;int&gt; chess;bool judge(int i)&#123; // i为行数, 即放的第几个 // chess[x] 记录的列数 for (int j = 0; j &lt; i; j++) &#123; // 同一列和对角线判断 if ( ( chess[i] == chess[j] ) || ( abs(chess[i] - chess[j]) == abs(i - j))) return false; &#125; return true;&#125;int main()&#123; int T; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt;n; chess.resize(n); bool yes = true; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; chess[i]; if(judge(i) == false)&#123; yes = false; // break; &#125; &#125; if (yes) cout &lt;&lt; \"YES\" &lt;&lt;endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; return 0;&#125;/* * @Author: Mrli * @Date: 2020-07-19 23:55:28 * @LastEditTime: 2020-07-20 00:11:19 * @Description: Dijkstra + DFS */ #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 5e2 + 5;const int INF = 0x3f3f3f3f;int n, m, s, d;int G[maxn][maxn];int C[maxn][maxn];int dd[maxn]; // 区别少了个cc[maxn]bool vis[maxn];vector&lt;int&gt; pre[maxn]; // pre[maxn]变成了vector数组vector&lt;int&gt; tempPath, path; // 多了两个记录路径的vec, 用来dfs比较, path为最终的答案/** 只涉及G[][], 不涉及C[][]*/void dijkstra(int s)&#123; fill(dd, dd+maxn, INF); dd[s] = 0; for (int i = 0; i &lt; n; i++) &#123; // 循环n个节点 int u = -1, MIN = INF; for (int j = 0; j &lt; n; j++) &#123; if (vis[j] == false &amp;&amp; dd[j] &lt; MIN)&#123; MIN = dd[j]; u = j; &#125; &#125; if ( u == -1) return ; vis[u] = true; for (int v = 0; v &lt; n; v++) &#123; if ( vis[v] == false &amp;&amp; G[u][v] != INF)&#123; if ( dd[u] + G[u][v] &lt; dd[v])&#123; dd[v] = dd[u] + G[u][v]; pre[v].clear(); pre[v].push_back(u); // 记录v的前驱 &#125;else if ( dd[u] + G[u][v] == dd[v] )&#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;int Mincost = INF;/** 只涉及C[][], 不涉及G[][]*/void dfs(int v)&#123; if ( v == s)&#123; tempPath.push_back(v); int tmpCost = 0; for (int i = tempPath.size() - 1; i &gt; 0 ; i--) &#123; int idx = tempPath[i], idnxt = tempPath[i-1]; tmpCost += C[idx][idnxt]; // 之前的digistra不记录Cost, 只记录路径, DFS时找出最低cost &#125; if (tmpCost &lt; Mincost)&#123; Mincost = tmpCost; path = tempPath; &#125; tempPath.pop_back(); return; &#125; tempPath.push_back(v); for (int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempPath.pop_back();&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d; int u, v, dist, cost; fill(G[0], G[0] + maxn* maxn , INF); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; dist &gt;&gt; cost; G[u][v] = G[v][u] = dist; C[u][v] = C[v][u] = cost; &#125; dijkstra(s); dfs(d); for (int i = path.size() - 1; i &gt;= 0; i--) &#123; printf(\"%d \", path[i]); &#125; printf(\"%d %d\\n\", dd[d], Mincost); return 0;&#125; 1031 Hello World for U 模拟题 1234567891011121314151617181920212223242526272829303132333435/** @Author: Mrli* @Date: 2020-06-26 18:12:39 * @LastEditTime: 2020-06-26 19:38:37* @Description: */ #include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); string s; cin &gt;&gt; s; int N = s.size(); int n1 = ( N + 2 ) / 3, n3 = n1, n2 = ( N + 2 - n1 - n3); // cout &lt;&lt; n1 &lt;&lt; n2 &lt;&lt; n3 &lt;&lt; endl; for (int i = 0; i &lt; n1 -1; i++) &#123; cout &lt;&lt; s[i]; // 输出左侧字符 for (int j = 1; j &lt; n2 - 1; j++) &#123; cout &lt;&lt; \" \"; // 输出中间的空格 &#125; cout &lt;&lt; s[N - i - 1] &lt;&lt; endl; // 输出右侧的字符 &#125; for (int i = 0; i &lt; n2; i++) &#123; cout &lt;&lt; s[n1 - 1 + i ]; // 输出最底层的字符 &#125; return 0;&#125; 1036 Boys vs Girls 考点: 结构体； sort比较函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;struct Record&#123; string name; string sex; string subject; int grade;&#125;typedef rc;bool cmp(rc &amp;r1, rc &amp;r2)&#123; if(r1.sex == \"M\" &amp;&amp; r2.sex == \"F\") return true; else if(r1.sex == \"F\" &amp;&amp; r2.sex == \"M\") return false; else return r1.grade &lt; r2.grade;&#125;int main(int argc, char const *argv[])&#123; int n; cin &gt;&gt; n; std::vector&lt;rc&gt; v(n); for (int i = 0; i &lt; n; ++i)&#123; rc r; cin &gt;&gt; r.name &gt;&gt; r.sex &gt;&gt; r.subject &gt;&gt; r.grade; v[i] = r; &#125; sort(v.begin(), v.end(), cmp); // for (std::vector&lt;rc&gt;::iterator i = v.begin(); i != v.end(); ++i) // cout &lt;&lt; i-&gt;name &lt;&lt; \" \" &lt;&lt; i-&gt;sex &lt;&lt; \" \" &lt;&lt; i-&gt;subject &lt;&lt; \" \" &lt;&lt; i-&gt;grade &lt;&lt;endl; std::vector&lt;rc&gt;::iterator boy = v.begin(); std::vector&lt;rc&gt;::iterator girl = v.end()-1; bool absent = false; if(girl-&gt;sex == \"F\")&#123; cout &lt;&lt; girl-&gt;name &lt;&lt; \" \" &lt;&lt; girl-&gt;subject &lt;&lt;endl; &#125; else&#123; cout &lt;&lt; \"Absent\" &lt;&lt; endl; absent = true; &#125; if(boy-&gt;sex == \"M\")&#123; cout &lt;&lt; boy-&gt;name &lt;&lt; \" \" &lt;&lt; boy-&gt;subject &lt;&lt;endl; &#125; else&#123; cout &lt;&lt; \"Absent\" &lt;&lt; endl; absent = true; &#125; if(!absent)&#123; cout &lt;&lt; girl-&gt;grade - boy-&gt;grade &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; \"NA\" &lt;&lt;endl; &#125; return 0;&#125; 1037 Magic Coupon 贪心， 证明a&gt; b, c &gt; b存在ad &gt; bc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * @Author: Mrli * @Date: 2020-06-26 19:38:35 * @LastEditTime: 2020-06-26 19:45:59 * @Description: */ #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ios::sync_with_stdio(false); int nc, np; cin &gt;&gt; nc; vector&lt;int&gt; v1, v2; int tmp; for (int i = 0; i &lt; nc; i++) &#123; cin &gt;&gt; tmp; v1.push_back(tmp); &#125; cin &gt;&gt; np; for (int i = 0; i &lt; np; i++) &#123; cin &gt;&gt; tmp; v2.push_back(tmp); &#125; int len1 = v1.size(), len2 = v2.size(); sort(v1.begin(), v1.end()); sort(v2.begin(), v2.end()); int x, y; x = 0, y = 0; ll ans = 0; // while( v1[x] &lt; 0 &amp;&amp; v2[y] &lt; 0)&#123; while( v1[x] &lt; 0 &amp;&amp; v2[y] &lt; 0 &amp;&amp; x &lt; len1 &amp;&amp; y &lt; len2)&#123; ans += v1[x++] * v2[y++]; &#125; x = len1 - 1, y = len2 - 1; // while( v1[x] &gt; 0 &amp;&amp; v2[y] &gt; 0)&#123; while( v1[x] &gt; 0 &amp;&amp; v2[y] &gt; 0 &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0)&#123; ans += v1[x--] * v2[y--]; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 1038 Recover the Smallest Number 新cmp中通过 string + string 来比, 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * @Author: Mrli * @Date: 2020-09-17 13:46:24 * @LastEditTime: 2020-09-17 14:09:58 * @Description: */#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int n;const int maxn = 1e4 + 5;string arr[maxn];bool cmp(string &amp;a, string &amp;b)&#123; return a + b &lt; b + a;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt;n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; sort(arr, arr+n, cmp); string ans; for (int i = 0; i &lt; n; i++) &#123; ans += arr[i]; &#125; while(ans.length() != 0 &amp;&amp; ans[0] == '0') ans.erase(ans.begin()); if(ans.length() == 0) cout &lt;&lt; 0; cout &lt;&lt; ans; return 0;&#125; B1023 最小的数 贪心 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int n;int arr[10];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); for (int i = 0; i &lt; 10; i++) &#123; cin &gt;&gt; arr[i]; &#125; for (int i = 1; i &lt; 10; i++) &#123; if ( arr[i] &gt; 0)&#123; cout &lt;&lt; i; arr[i] --; break; &#125; &#125; for (int i = 0; i &lt; 10; i++) &#123; int len = arr[i]; for (int j = 0; j &lt; len; j++) &#123; cout &lt;&lt; i; arr[i]--; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 总结: 上面两题都是根据输入排出一个最小的数。 第一题是不能改变原有的数字顺序， 所以直接用string拼接比较。 第二个是根据给出0-9数字的个数自己去排； 还有第三种， 类似第一题的输入， 需要自己去计算0-9的个数， 然后再像第二题一样去贪心排 1040 Longest Symmetric String 12345678910111213141516171819202122232425262728293031323334/* * @Author: Mrli * @Date: 2020-09-17 13:07:21 * @LastEditTime: 2020-09-17 13:39:11 * @Description: */#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int n;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); string s; getline(cin, s); int len = s.size(); int max_ans = 0; for (int i = 0; i &lt; len; i++) &#123; // for (int j = len - 1; j &gt;= 1; j--) &#123; //245ms for (int j = len - i; j &gt;= 1 &amp;&amp; j - i &gt;= max_ans; j--) &#123; // 138ms string ss = s.substr(i, j); string rev(ss.rbegin(), ss.rend()); if ( ss == rev &amp;&amp; max_ans &lt; ss.size() )&#123; max_ans = ss.size(); &#125; &#125; &#125; cout &lt;&lt;max_ans &lt;&lt;endl; return 0;&#125; 1041 Be Unique 模拟题，难点在找到第一个。此处的table为int型数组的哈希表–&gt;可以使用STL中的map代替 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5 + 5;int table[MAXN];int a[MAXN];int main(int argc, char const *argv[])&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i)&#123; // a[i]来记录不同数字出现的顺序 cin &gt;&gt; a[i]; // table记录出现的次数 table[a[i]] ++ ; &#125; int ans=-1; for (int i = 0; i &lt; n; ++i)&#123; // 按照出现的顺序遍历, 查看是否有数出现的次数为1 if ( table[a[i]] == 1)&#123; // 如果找到出现次数为1的就输出 ans = a[i]; break; &#125; &#125; if (ans == -1) cout &lt;&lt;\"None\" &lt;&lt; endl; else cout &lt;&lt;ans &lt;&lt;endl; return 0;&#125; 1042 Shuffling Machine 模拟题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* * @Author: Mrli * @Date: 2020-06-26 22:57:16 * @LastEditTime: 2020-06-26 23:51:57 * @Description: */ #include &lt;bits/stdc++.h&gt;#include &lt;iomanip&gt;using namespace std;const int n = 54;string color[] = &#123;\"S\", \"H\", \"C\", \"D\", \"J\"&#125;;vector&lt;int&gt; order(n+1, 0);vector&lt;int&gt; startArr(n+1, 0);vector&lt;int&gt; endArr(n+1, 0);void init()&#123; for (int i = 1; i &lt;= n; i++) &#123; startArr[i] = i; &#125;&#125; void mock()&#123; for (int i = 0; i &lt; n; i++) &#123; endArr[i] = i; &#125;&#125; int main()&#123; int k; cin &gt;&gt; k; init(); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; order[i]; &#125; for (int i = 1; i &lt;= k; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; endArr[order[j]]= startArr[j]; &#125; for (int j = 1; j &lt;= n; j++) &#123; startArr[j] = endArr[j]; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; int endNum = endArr[i] - 1; if (i == n )&#123; cout &lt;&lt; color[ endNum / 13 ] &lt;&lt; endNum% 13 + 1; &#125;else&#123; cout &lt;&lt; color[ endNum / 13 ] &lt;&lt; endNum % 13 + 1&lt;&lt; \" \"; &#125; &#125; return 0;&#125;/**自己写的版本， 当时没注意下标*/#include &lt;bits/stdc++.h&gt;#include &lt;iomanip&gt;using namespace std;const int n = 54;string color[] = &#123;\"S\", \"H\", \"C\", \"D\", \"J\"&#125;;vector&lt;int&gt; order(n, 0);vector&lt;int&gt; startArr(n, 0);vector&lt;int&gt; endArr(n, 0);void init()&#123; for (int i = 0; i &lt; n; i++) &#123; startArr[i] = i; &#125;&#125; int main()&#123; int k; cin &gt;&gt; k; init(); for (int i = 0; i &lt; n; i++) &#123; int tmp; cin &gt;&gt; tmp; order[i] = tmp - 1; &#125; for (int i = 0; i &lt; k; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; endArr[order[j]]= startArr[j]; &#125; for (int j = 0; j &lt; n; j++) &#123; startArr[j] = endArr[j]; // cout &lt;&lt; startArr[j] &lt;&lt; \" \"; &#125; // cout &lt;&lt; endl; &#125; for (int i = 0; i &lt; n; i++) &#123; int endNum = endArr[i]; if (i == n - 1)&#123; cout &lt;&lt; color[ endNum / 13 ] &lt;&lt; endNum% 13 + 1; &#125;else&#123; cout &lt;&lt; color[ endNum / 13 ] &lt;&lt; endNum % 13 + 1&lt;&lt; \" \"; &#125; &#125; return 0;&#125; 1043 Is It a Binary Search Tree 二叉搜索树: 要点: 建树的时候insert函数中如果val==结点val, 那么当前节点该插到右边中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* * @Author: Mrli * @Date: 2020-06-27 10:52:28 * @LastEditTime: 2020-06-27 16:17:04 * @Description: */ #include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; origin, pre, preM, post, postM;struct Node&#123; int v; Node* lc, *rc; Node()&#123;&#125; Node(int val)&#123; v = val; lc = rc = NULL; &#125;&#125;typedef Node;/**根据BST规则进行插入*/void insert(Node * &amp;root, int val)&#123; if (root == NULL) &#123; root = new Node(val); // 创建树根节点 return ; // 这边记得return 结束 &#125; if ( val &lt; root-&gt;v ) insert(root-&gt;lc, val); else insert(root-&gt;rc, val); // ▲key: BST结点相同时放右边&#125;void preOrder(Node* root, vector&lt;int&gt; &amp;v)&#123; if (root == NULL ) return ; v.push_back(root-&gt;v); preOrder(root-&gt;lc, v); preOrder(root-&gt;rc, v);&#125;void preMOrder(Node* root, vector&lt;int&gt; &amp;v)&#123; if (root == NULL ) return ; v.push_back(root-&gt;v); preMOrder(root-&gt;rc, v); preMOrder(root-&gt;lc, v);&#125;void postOrder(Node* root, vector&lt;int&gt; &amp;v)&#123; if (root == NULL ) return ; postOrder(root-&gt;lc, v); postOrder(root-&gt;rc, v); v.push_back(root-&gt;v);&#125;void postMOrder(Node* root, vector&lt;int&gt; &amp;v)&#123; if (root == NULL ) return ; postMOrder(root-&gt;rc, v); postMOrder(root-&gt;lc, v); v.push_back(root-&gt;v);&#125;int main()&#123; int n; int tmp; cin &gt;&gt; n; Node* root = NULL; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; origin.push_back(tmp); insert(root, tmp); &#125; preOrder(root, pre); // for(auto i: pre)&#123; // cout &lt;&lt; i &lt;&lt; \" \"; // &#125; // cout &lt;&lt;endl; preMOrder(root, preM); postOrder(root, post); postMOrder(root, postM); if ( origin == pre )&#123; cout &lt;&lt; \"YES\" &lt;&lt; endl; for (int i = 0; i &lt; post.size(); i++) &#123; if (i != post.size() - 1) cout &lt;&lt; post.at(i) &lt;&lt; \" \"; else cout &lt;&lt; post.at(i) &lt;&lt; endl; &#125; &#125;else if (origin == preM)&#123; cout &lt;&lt; \"YES\" &lt;&lt; endl; for (int i = 0; i &lt; postM.size(); i++) &#123; if (i != postM.size() - 1) cout &lt;&lt; postM.at(i) &lt;&lt; \" \"; else cout &lt;&lt; postM.at(i) &lt;&lt; endl; &#125; &#125;else&#123; cout &lt;&lt; \"NO\" &lt;&lt;endl; &#125; return 0;&#125; 1044 Shopping in Mars 前缀和 + 二分 本题思路最大的亮点在于， 用前缀和构造了单调递增的数列， 然后使用二分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int n;int s;vector&lt;int&gt;sum;// [L, r)找到第一个大于x的位置int upper_bound(int left, int right, int x)&#123; int mid; int l = left, r = right; while( l &lt; r)&#123; mid = (l+r) &gt;&gt; 1; if ( sum[mid] &gt; x)&#123; r = mid; &#125;else&#123; l = mid + 1; &#125; &#125; return l;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; s; sum.resize(n+1, 0); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; sum[i]; sum[i] = sum[i] + sum[i-1]; &#125; int nearS = INF; // 为最接近S的最小值 for (int i = 1; i &lt;= n; i++) &#123; // 使用STL函数 int j = upper_bound(sum.begin()+i, sum.end(), sum[i-1] + s, less&lt;int&gt;()) - sum.begin() ; // 教材:法二 // int j = upper_bound(i, n + 1, sum[i-1]+s); // j为大于等于 sum[i-1] + S的值, 如果能和为s, 那么sum[j-1]就是能对应匹配的值 if ( sum[j-1] - sum[i-1] == s)&#123; nearS = s; break; // 否则sum[j] - sum[i-1] 可能为最接近的 &#125;else if ( j &lt;=n &amp;&amp; sum[j] - sum[i-1] &lt; nearS )&#123; nearS = sum[j] - sum[i-1]; &#125; &#125; for (int i = 1; i &lt;= n ; i++) &#123; int j = upper_bound(sum.begin()+i, sum.end(), sum[i-1] + nearS, less&lt;int&gt;())- sum.begin() ; // int j = upper_bound(i, n + 1, sum[i-1]+nearS); if ( sum[j-1] - sum[i-1] == nearS)&#123; cout &lt;&lt; i &lt;&lt; \"-\" &lt;&lt; j-1 &lt;&lt;endl; &#125; &#125; return 0;&#125; 1046 Shortest Distance 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int main()&#123; int N; ll d; vector&lt;ll&gt; distArr; // 存放的是第i + 1号到起点的顺时针距离和 ll sum = 0; cin &gt;&gt; N; // 书上答案 // distArr.resize(N + 1); // distArr[0] = 0; // for (int i = 1; i &lt;= N; i++) &#123; // cin &gt;&gt; distArr[i]; // sum += distArr[i]; // distArr[i] = distArr[i] + distArr[i- 1]; // &#125; distArr.resize(N); distArr[0] = 0; for (int i = 1; i &lt; N; i++) &#123; cin &gt;&gt; distArr[i]; distArr[i] = distArr[i] + distArr[i-1]; &#125; int lastDist; cin &gt;&gt; lastDist; sum = lastDist + distArr[N-1]; int k; int s, t; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; s &gt;&gt; t; if (t &lt; s) swap(s, t); ll twoDist = distArr[t - 1] - distArr[s - 1]; cout &lt;&lt; min( twoDist, sum - twoDist ) &lt;&lt; endl; &#125; return 0;&#125; 1050 String Subtraction 题意:将S1中出现的S2字符全部删除。 解题：删一个改一个，但是考虑到字符串可以理解为数组，所以修改必然要牵扯到移位。此时有个细节，到底是从头往后遍历还是从后往前遍历。从前往后修改存在的问题是，如果是判断相等后立马修改,则后面的索引值会错位(因为删除后后面的字符串往前调整,而指针却+1,所以会略过一个字符) 突然发现这个移位的功能不需要自己写，string有提供erase函数！：C++ string字符串修改和替换方法详解 （1）erase(pos,n); 删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符 （2）erase(position);删除position处的一个字符(position是个string类型的迭代器),如果是数字会截断索引值为position后字符串 （3）erase(first,last);删除从first到last之间的字符（first和last都是迭代器） △因此，我使用的是从后往前用erase函数进行删除；读取行内容使用getline 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main(int argc, char const *argv[])&#123; string origin; string out; getline(cin, origin); getline(cin, out); int Lorigin = origin.size(); int Lout = out.size(); for (int j = Lorigin-1; j &gt;= 0; --j)&#123; for (int i = 0; i &lt; Lout; ++i)&#123; // 在string2中找 ==&gt; 找某个是否存在--&gt; hashmap if(origin[j] == out[i])&#123; origin.erase(j,1); &#125; &#125; &#125; cout &lt;&lt; origin &lt;&lt;endl; return 0;&#125; 123456789101112131415161718192021public class StringSubtraction1035 &#123; public static void main(String[] args) &#123; String longs, shorts; Scanner scanner = new Scanner(System.in); longs = scanner.nextLine(); // 遇到\\n结束读取, \\n不在string中 shorts = scanner.nextLine(); HashMap&lt;Character, Integer&gt; hs = new HashMap&lt;&gt;(); for (int i = 0; i &lt; shorts.length(); i++) &#123; hs.put(shorts.charAt(i), 1); &#125; for (int i = 0; i &lt; longs.length(); i++) &#123; if (!hs.containsKey(longs.charAt(i))) &#123; System.out.print(longs.charAt(i)); &#125; &#125; System.out.println(); &#125;&#125; 1234567891011//基于平衡树实现：0（logn）//有序set&lt;int&gt;a;map&lt;int，int&gt;b;multiset&lt;int&gt;c;multiset&lt;int，int&gt;d;//基于哈希表实现：0（1）//无序unordered_set&lt;int&gt;e;unordered_map&lt;int，int&gt;f;unordered_multiset&lt;int&gt;g;unordered_multimap&lt;int，int&gt;h; 1052 Linked List Sorting 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* * @Author: Mrli * @Date: 2020-06-27 16:20:42 * @LastEditTime: 2020-06-27 17:31:58 * @Description: */ #include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int n;const int MAXN = 1e6;struct node&#123; int val; // addr为了在最后遍历输出结果时输出, nextaddr为了能够按照一开始给定的链表顺序遍历整条链表 int addr, nextaddr; bool flag; // 计算哪些节点是在链表上的 node()&#123; flag = false; &#125;&#125;;// node v[MAXN];vector&lt;node&gt; v(MAXN);bool cmp(node a, node b)&#123; if ( a.flag == false || b.flag == false)&#123; return a.flag &gt; b.flag; &#125;else&#123; return a.val &lt; b.val; &#125;&#125;int main()&#123; cin &gt;&gt;n; int root; cin &gt;&gt; root; for (int i = 0; i &lt; n; i++) &#123; int addr, val, nextaddr; cin &gt;&gt; addr &gt;&gt; val &gt;&gt; nextaddr; v[addr].addr =addr ; v[addr].val = val; v[addr].nextaddr = nextaddr; &#125; // 计算有效节点 int cnt = 0, p = root; while( p != -1)&#123; v[p].flag = true; cnt ++ ; p = v[p].nextaddr; &#125; if (!cnt)&#123; printf(\"0 -1\\n\"); &#125;else&#123; sort(v.begin(), v.end(), cmp); // 用vector时 // sort(v, v+MAXN, cmp); 用数组时 printf(\"%d %05d\\n\", cnt, v[0].addr); for (int i = 0; i &lt; cnt; i++) &#123; if ( i != cnt - 1) printf(\"%05d %d %05d\\n\", v[i].addr, v[i].val, v[i+1].addr); else printf(\"%05d %d -1\\n\", v[i].addr, v[i].val); &#125; &#125; return 0;&#125; 1053 Path of Equal Weight 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* * @Author: Mrli * @Date: 2020-06-27 16:20:42 * @LastEditTime: 2020-06-27 18:07:21 * @Description: */ #include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int MAXN = 100 + 5;struct Tree&#123; int w; vector&lt;int&gt; ch;&#125;v[MAXN];bool cmp(int a, int b)&#123; return v[a].w &gt; v[b].w;&#125;// 存放路径上节点的idvector&lt;int&gt; path;void dfs(int iddex, int nowS, int target)&#123; if (nowS &gt; target)&#123; return ; &#125;else if( nowS == target)&#123; if(v[iddex].ch.size() != 0 ) return ; // 未到叶子节点 for (int i = 0; i &lt; path.size(); i++) &#123; if ( i == path.size() - 1) cout &lt;&lt; v[path[i]].w &lt;&lt;endl; else cout &lt;&lt; v[path[i]].w &lt;&lt;\" \"; &#125; return ; &#125; // nows &lt; target for (int i = 0; i &lt; v[iddex].ch.size(); i++) &#123; int nxtNode = v[iddex].ch[i]; path.push_back(nxtNode); dfs(nxtNode, nowS + v[nxtNode].w, target); path.pop_back(); &#125;&#125;int main()&#123; int nn, notleaf, s; int tmp; cin &gt;&gt; nn &gt;&gt; notleaf &gt;&gt; s; for (int i = 0; i &lt; nn; i++) &#123; cin &gt;&gt; v[i].w; &#125; int id, k, c; for (int j = 0; j &lt; notleaf; j++) &#123; cin &gt;&gt; id &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; c; v[id].ch.push_back(c); &#125; sort(v[id].ch.begin(), v[id].ch.end(), cmp); &#125; path.push_back(0); dfs(0, v[0].w, s); return 0;&#125; 1054 The Dominant Color 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1000+5;int main()&#123; int M, N; map&lt;string, int&gt; mp; string tmp; cin &gt;&gt; M &gt;&gt; N; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++)&#123; cin &gt;&gt; tmp; mp[tmp]++; &#125; &#125; int maxn = -1; string ans; for(auto m:mp)&#123; if(m.second &gt; maxn)&#123; maxn = m.second; ans = m.first; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 1055 The World’s Richest 1056 Mice and Rice 题目有点长，看了题解的解释才懂。在此复述一遍：给你NP个老鼠以及他们的重量W，每NG个老鼠分为一组，不够NG个数的单独算一个组，比较他们每个组的最大值，将最大值进入下一轮的比较，同组其余老鼠皆为淘汰，并与其他组同时被淘汰的老鼠排名一致，最后求所有老鼠的排名。 输入解释：第一行分别为NP和NG，第二行是每个老鼠的体重，第三行是每个老鼠的编号。第三行的需要特表说明，如输入样例：6 0 8 7 10 5 9 1 4 2 3， 意思是标号6、0、8为一组，7、10、5为一组，一次往后，即这行说明的是分组顺序 解题思路： 这道题的难点在于对数据进行分组，比较并进行排名，其中，老鼠的排名==该轮比赛分组个数+1——本轮比较分group个组，意味着有group个优胜者，也就是说，其余所有被淘汰的都在这group之后，即group+1.所以我们直接每轮的分组数即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 10e3 + 5;struct mice&#123; int weight; int num; int init; int rank;&#125;typedef mice;int main(int argc, char const *argv[])&#123; int NP, NG; cin &gt;&gt; NP &gt;&gt; NG; std::vector&lt;mice&gt; v(NP); queue&lt;int&gt; q; // 存储下标 for (int i = 0; i &lt; NP; ++i)&#123; cin &gt;&gt; v.at(i).weight; &#125; for (int i = 0; i &lt; NP; ++i)&#123; int tmp; cin &gt;&gt; tmp; q.push(tmp); &#125; int turnP; while(q.size() &gt; 1)&#123; int turnP = q.size(); // 记录每轮的所有人数，q.size()为总人数，+1是结束值 int turnG = (turnP%NG==0) ? turnP/NG : turnP/NG + 1; // 该轮分组个数 for (int j = 0; j &lt; turnG; ++j)&#123; // 循环结束为一轮 std::vector&lt;int&gt; cmp; // 找出该group中的最大数 for (int i = 0; i &lt; NG; ++i)&#123; // 将元素加入cmp中 // j:0-3, NG=3, i=0-2 if( j * NG + i == turnP) break; // 当超出含有数量时结束 // 样例输入NP=11，0-10,到11时无效 cmp.push_back(q.front()); q.pop(); &#125; /** 调试部分 */ cout &lt;&lt; \" cmp.size():\"&lt;&lt; cmp.size()&lt;&lt; endl; for (int i = 0; i &lt; cmp.size(); ++i) &#123; cout &lt;&lt; cmp[i] &lt;&lt; \"\\t\"; &#125; cout &lt;&lt; endl; int maxV = v.at(cmp[0]).weight; // 当前组中的体重最大值 int maxI = 0; // 当前组中最大值的索引 cout &lt;&lt; \"初始最大值:\" &lt;&lt; maxV &lt;&lt; endl; for (int i = 0; i &lt; cmp.size(); ++i)&#123;// 如果正好能全部分完 int w = v.at(cmp[i]).weight; if ( w &gt; maxV)&#123; maxV = w; maxI = i; &#125; // &#125;else&#123; // 被淘汰的,排名为该轮分组数+1 // v.at(cmp[i]).rank = turnG + 1; // &#125; v.at(cmp[i]).rank = turnG + 1; cout &lt;&lt; \"更新rank：\" &lt;&lt; cmp[i] &lt;&lt; \"为\" &lt;&lt; turnG + 1&lt;&lt;endl; &#125; cout &lt;&lt; \"最大值：\" &lt;&lt; maxV &lt;&lt; \"索引值\" &lt;&lt; cmp[maxI] &lt;&lt; endl; // 将胜出的重新加如 q.push(cmp[maxI]); cout &lt;&lt; \"本gourp加入\" &lt;&lt; cmp[maxI] &lt;&lt; endl; cout &lt;&lt; \"q.size()\" &lt;&lt; q.size() &lt;&lt; endl; cmp.clear(); &#125; &#125;// end while when q.size == 1 int campionIndex = q.front(); cout &lt;&lt; \"campionIndex\" &lt;&lt; campionIndex &lt;&lt; endl; v[campionIndex].rank = 1; cout &lt;&lt; \"结果：\" ; // 按格式输出结果 cout &lt;&lt; v[0].rank; for (int i = 1; i &lt; NP; ++i) cout &lt;&lt; \" \" &lt;&lt; v[i].rank; cout &lt;&lt; endl; return 0;&#125; ▲真的挺难的一题，首先是题目比较难理解，其次需要找到如果确定每个player的排名规律，最后再是每轮中处理不满一组的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * @Author: Mrli * @Date: 2020-09-18 23:02:14 * @LastEditTime: 2020-09-18 23:10:24 * @Description: int */#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int n;const int maxn = 1e5 + 5;struct Node&#123; int addr; int val; int nxt;&#125;arr[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); vector&lt;Node&gt; v; int st, n, k; cin &gt;&gt; st &gt;&gt; n &gt;&gt; k; int addr; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; addr; cin &gt;&gt; arr[addr].val &gt;&gt; arr[addr].nxt; arr[addr].addr = addr; &#125; int p = st; while( p != -1)&#123; v.push_back(arr[p]); p = arr[p].nxt; &#125; int group = v.size() / k; for (int i = 0; i &lt; group; i++) &#123; reverse(v.begin() + i * k, v.begin() + i * k + k); &#125; for (int i = 0; i &lt; v.size(); i++) &#123; printf(\"%05d %d \", v[i].addr, v[i].val); if ( i &lt; v.size() - 1) printf(\"%05d\\n\", v[i+1].addr); else printf(\"-1\\n\"); &#125; return 0;&#125; 1057 Stack 分块思想， 可以实时动态查询topK 碰到一个问题, ios::sync_with_stdio(false);使用后重定向的结果跟直接屏幕输入的结果不一致， [1077 [Kuchiguse]](#1077 [Kuchiguse])(同样也是因为这个原因过不了OJ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* * @Author: Mrli * @Date: 2020-09-17 16:21:00 * @LastEditTime: 2020-09-20 11:02:11 * @Description: */#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const int sqrN = sqrt(maxn);const int INF = 0x3f3f3f3f;int n;stack&lt;int&gt; st;int table[maxn];int block[sqrN];void peekMedian(int k)&#123; int sum = 0; int idx = 0; while( sum + block[idx] &lt; k)&#123; sum += block[idx]; idx += 1; &#125; int num = idx * sqrN; while( sum + table[num] &lt; k)&#123; sum += table[num]; num += 1; &#125; printf(\"%d\\n\", num); &#125;void Push(int x)&#123; st.push(x); block[ x / sqrN ] ++ ; table[x] ++;&#125;void Pop()&#123; int x = st.top(); st.pop(); block[ x / sqrN] --; table[x] --; cout &lt;&lt; x &lt;&lt;endl;&#125;int main()&#123; cin &gt;&gt; n; string op; while(n -- )&#123; cin &gt;&gt; op; if (op == \"Pop\")&#123; if ( st.size() == 0) cout &lt;&lt; \"Invalid\" &lt;&lt; endl; else Pop(); &#125;else if ( op == \"PeekMedian\")&#123; int len = st.size(); int k; if ( len == 0) cout &lt;&lt; \"Invalid\" &lt;&lt; endl; else &#123; if (len % 2 == 0)&#123; k = len / 2; &#125;else&#123; k = (len+1) / 2; &#125; peekMedian(k); &#125; &#125;else if (op == \"Push\")&#123; int tmp; cin &gt;&gt; tmp; Push(tmp); &#125; &#125; return 0;&#125; 1062 Talent and Virtue 题意理解: 将输入的人分为三类，圣人sage，君子nobleman，愚人foolman和小人small man。输出他们的排名，规则如下，列出N行数据，L最低线，H最高限。sage为virtue品德和talent才能分数都高于H，他们之间的排名通过两者总分来区分；nobleman为talent才能低于H，但是virtue高于H的，同样也通过总分来区分，但是他们排在sage之后；如果两项得分都低于H，并且virtue不低于talent的为foolman，他们排在nobleman之后；剩下过了L线的人都排在foolman之后。（必须两个分数都高于L才能被显示） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;int n, L, H;struct record&#123; string ID; int de; int cai; record(string id, int d, int c): ID(id), de(d), cai(c)&#123;&#125; // record(int id, int d, int c): ID(id), de(d), cai(c)&#123;&#125;&#125;;bool cmp(const record &amp;a, const record &amp;b)&#123; if ( ( a.cai + a.de ) != ( b.cai + b.de )) return ( a.cai + a.de ) &gt; ( b.cai + b.de ); else if ( a.de != b.de) return a.de &gt; b.de; else return a.ID &lt; b.ID;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; L &gt;&gt; H; vector&lt;record&gt; v[4]; int total = n; for (int i = 0; i &lt; n; i++) &#123; string tmpid; // int tmpid; int tmpde, tmpcai; cin &gt;&gt; tmpid &gt;&gt; tmpde &gt;&gt; tmpcai; record r = record(tmpid, tmpde, tmpcai); if (tmpde &lt; L || tmpcai &lt; L)&#123; total --; &#125;else if ( tmpde &gt;= H &amp;&amp; tmpcai &gt;= H)&#123; v[0].push_back(r); &#125;else if ( tmpde &gt;= H &amp;&amp; tmpcai &lt; H)&#123; v[1].push_back(r); &#125;else if (tmpde &lt; H &amp;&amp; tmpcai &lt; H &amp;&amp; tmpde &gt;= tmpcai)&#123; v[2].push_back(r); &#125;else&#123; v[3].push_back(r); &#125; &#125; cout &lt;&lt; total &lt;&lt;endl; for (int i = 0; i &lt; 4; i++) &#123; sort(v[i].begin(), v[i].end(), cmp); for (int j = 0; j &lt; v[i].size(); j++) &#123; cout &lt;&lt; v[i][j].ID &lt;&lt; \" \" &lt;&lt; v[i][j].de &lt;&lt; \" \" &lt;&lt; v[i][j].cai&lt;&lt; endl; &#125; &#125; return 0;&#125; 1063 Set Similarity Nc表示两个集合中相同的元素(the number of distinct common numbers shared by the two sets)，Nt表示两个集合总的不相同元素的个数， 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int n;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt;n; // set&lt;int&gt; v[n]; vector&lt;int&gt; arr(n+1); vector&lt; set&lt;int&gt; &gt; v(n+1); int m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; m; arr[i] = m; int tmp; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; tmp; v[i].insert(tmp); &#125; &#125; int k; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; set&lt;int&gt; res; set_intersection(v[a].begin(), v[a].end(), v[b].begin(), v[b].end(), insert_iterator&lt;set&lt;int&gt;&gt;(res, res.begin()) ); int total = v[a].size() + v[b].size() - res.size(); printf(\"%.1lf%\\n\", res.size()*1.0 / total * 1.0 *100); &#125; return 0;&#125; 1064 Complete Binary Search Tree 一棵排序二叉树的中序遍历就是这一组数的递增序列。这边是完全二叉树，假设从0开始，那么节点i的左孩子的标号就是2i+1，右孩子的标号就是2(i+1)。先将这组数按照递增来排序，然后用中序遍历复原这棵完全排序二叉树，最后直接输出。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; v;vector&lt;int&gt; in;int n;int k = 0;// 中序遍历复原这棵完全排序二叉树， 顺序输出in就是层次遍历void inOrder(int root)&#123; if (root &gt;= n) return ; inOrder(2*root + 1); in[root] = v[k++]; // printf(\"%d ====%d\\n\",root,k-1); inOrder(2*root + 2);&#125;int main()&#123; cin &gt;&gt; n; v.resize(n); in.resize(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v[i]; &#125; sort(v.begin(), v.end()); inOrder(0); if (n &gt; 1)&#123; cout &lt;&lt; in[0] ; for (int i = 1; i &lt; n; i++) &#123; cout &lt;&lt; \" \" &lt;&lt; in[i]; &#125; cout &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; in[0] &lt;&lt;endl; &#125; return 0;&#125; 1077 Kuchiguse 碰到一个问题, ios::sync_with_stdio(false);使用后重定向的结果跟直接屏幕输入的结果不一致， [1057 [ Stack]](#1057 [ Stack])同样也是因为这个原因过不了OJ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int n;int main()&#123; scanf(\"%d\", &amp;n); // cin跟getline(cin, s)配合会出问题， 因此用cin分开 getchar(); // 这边得用getchar吃掉换行符 vector&lt;string&gt; v(n); int minLen = INF; for (int i = 0; i &lt; n; i++) &#123; getline(cin, v[i]); reverse(v[i].begin(), v[i].end()); if (v[i].size() &lt; minLen) minLen = v[i].size(); &#125; string ans = \"\"; for (int i = 0; i &lt; minLen; i++) &#123; char ch = v[0][i]; bool allmatch = true; for (int j = 1; j &lt; n; j++) &#123; if ( v[j][i] != ch)&#123; allmatch = false; break; &#125; &#125; if (allmatch == true) &#123; ans = ch + ans; &#125; else break; &#125; if (ans.empty()) cout &lt;&lt; \"nai\" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 1078 Hashing Hash题，一开始审题错误，是平方探测法。 不算难，转化大小很简单，主要在这个平方探测上面。 是(key + step * step) % size 而不是(key % size + step * step)， 知道了这个，就比较好办了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 10e6;int M, N;std::vector&lt;int&gt; in; // 记录输入, 查询相应位置是否有数std::vector&lt;int&gt; v; // 用来记录相应数的索引位置, 输出值: v[0]就是第一个数的hash值bool isprime(int n)&#123; if ( n== 1) return false; if ( n == 2 || n == 3) return true; if ( (n%6!= 1) &amp;&amp; (n%6!= 5)) return false; int tmp = sqrt(n); for (int i = 5; i &lt;= tmp; i+=6)&#123; if ( n % i ==0 || n%(i+2) == 0) return false; &#125; return true;&#125;int main(int argc, char const *argv[])&#123; cin &gt;&gt; M &gt;&gt; N; while(!isprime(M)) M++; // ▲将数扩大到最小质数 // cout &lt;&lt; \"最小的质数为:\" &lt;&lt; M &lt;&lt; endl; v.resize(N); in.resize(M); // 这句很重要 for (int i = 0; i &lt; N; ++i)&#123; int tmp; cin &gt;&gt; tmp; bool yes = false; for (int j = 0; j &lt; M; ++j)&#123; int index = (tmp+j*j)%M; if ( in[index] == 0)&#123; v[i] = index; in[index] = tmp; yes = true; break; &#125; &#125; if (!yes) v[i] = -1; /** 为二次再散列法*/ // if(in[index] == 0)&#123; // 如果没有冲突, 则安放 // v[i] = index; // in[index] = tmp; // // cout &lt;&lt; \"yes\" &lt;&lt;endl; // &#125;else&#123; // // cout &lt;&lt; \"no\" &lt;&lt;endl; // // 二次 // int new_index = index%M; // if (in[new_index] ==0)&#123; // v[i] = new_index; // in[new_index] = tmp; // &#125;else&#123; // v[i] = -1; // &#125; // &#125; &#125; // 输出处理 if(v[0] == -1)cout &lt;&lt; \"-\"; else cout &lt;&lt; v[0]; for (int i = 1; i &lt; N; ++i)&#123; if(v[i] == -1) cout &lt;&lt; \" -\"; else cout &lt;&lt; \" \" &lt;&lt; v[i]; &#125; cout &lt;&lt;endl; return 0;&#125; 1067 Sort with Swap(0, i) 贪心: 将0与0当前所在位置下标的数交换, 如0在4位置, 那么就与4交换。而一个数一旦被交换过后就不会再需要被交换了 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n ; int ans = 0; scanf(\"%d\", &amp;n); vector&lt;int&gt; v; v.resize(n); int left = n - 1; // 除0以外已在自己位置上的 int k = 1; // 尚未归位的位置, 默认从第0+1位置 for (int i = 0; i &lt; n; i++) &#123; int pos; scanf(\"%d\", &amp;pos); v[pos] = i; // pos位置为i if (pos == i &amp;&amp; pos != 0)&#123; // left定义就是除0外未归位的 left --; &#125; &#125; while(left &gt; 0)&#123; if (v[0] == 0)&#123; while(k &lt; n)&#123; if (v[k] != k)&#123; // 找到下个未归位的下标 swap(v[0], v[k]); ans ++; break; &#125; k++; &#125; &#125; while(v[0] != 0)&#123; // 0不在0位上 swap(v[0], v[v[0]]); ans ++; left --; &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125; 1069 The Black Hole of Numbers 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;string sub(string a, string b)&#123; int ansn = stoi(a) - stoi(b); string s = to_string(ansn); while(s.size()!=4) s = \"0\" + s; return s;&#125;void solution(string n)&#123; string s = n; string b = n; string tmpans; while(true)&#123; sort(s.begin(), s.end(), greater&lt;char&gt;()); // string比较用char string revs(s.rbegin(), s.rend()); tmpans = sub(s, revs); cout &lt;&lt; s &lt;&lt; \" - \" &lt;&lt; revs &lt;&lt; \" = \" &lt;&lt; tmpans &lt;&lt; endl; s = tmpans; if (tmpans == \"0000\" || tmpans == \"6174\") break; &#125;&#125;int main()&#123; string s; cin &gt;&gt; s; while( s.size() &lt; 4) s = \"0\" + s; // 第2、3、4个点 solution(s); return 0;&#125; 1070 Mooncake 最简单的贪心: 拿单价最高的月饼种类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;struct mooncake&#123; double tons; // 题目只是说正数, 没说正数, 第3个测试样例会卡这个 double totalprice; double singleprice;&#125;;bool cmp(const mooncake &amp;a, const mooncake &amp;b)&#123; return a.singleprice &gt; b.singleprice;&#125;int main()&#123; int n, d; scanf(\"%d%d\", &amp;n, &amp;d); vector&lt;mooncake&gt; v(n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%lf\", &amp;v[i].tons); &#125; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%lf\", &amp;v[i].totalprice); // 输入用%lf, 输出用%f v[i].singleprice = v[i].totalprice / v[i].tons; &#125; sort(v.begin(), v.end(), cmp); double maxProfit = 0; int len = v.size(); for (int i = 0; i &lt; len ; i++) &#123; if ( d )&#123; if ( d &gt; v[i].tons ) &#123; d -= v[i].tons; maxProfit += v[i].totalprice; &#125;else&#123; maxProfit += v[i].singleprice * d; d = 0; &#125; &#125;else break; &#125; printf(\"%.2f\\n\", maxProfit); return 0;&#125; 1073 Scientific Notation 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;// 测试样例// -3.1415E+004// -3.1415926E+4// +3.1415926E-01// -3.1415926E-0005// -2.32E+0int main()&#123; ios::sync_with_stdio(false); cin.tie(0); string s; cin &gt;&gt; s; int len = s.size(); // s[0] 符号位, s[1]整数位, s[2]小数点 int dot = 2; int epos = s.find(\"E\"); int expSigPos = epos + 1; int exp = 0; // 越过指数符号位, 计算指数 for (int i = expSigPos + 1; i &lt; len; i++) &#123; exp = exp*10 + (s[i] - '0'); &#125; if ( exp == 0)&#123; cout &lt;&lt; \"1\"; return 0; &#125; if ( s[0] == '-') cout &lt;&lt; \"-\"; // cout &lt;&lt;exp &lt;&lt; endl; if ( s[expSigPos] == '-')&#123; // 负指数 cout &lt;&lt; \"0.\"; for (int i = 0; i &lt; exp - 1; i++) &#123; // 补0 cout &lt;&lt; \"0\"; &#125; for (int i = 1; i &lt; epos; i++) &#123; if ( i == dot) continue; cout &lt;&lt; s[i]; &#125; &#125;else&#123; // 小数点和E之间数字的个数 (dot, epos) int nums = epos - dot - 1; // 是否有小数点 // 无小数点情况 if ( exp - nums &gt;= 0)&#123; for (int i = 1; i &lt; epos; i++) &#123; if ( i == dot) continue; cout &lt;&lt; s[i]; &#125; for (int j = 0; j &lt; exp - nums; j++) &#123; // cout &lt;&lt; \"0\"; &#125; &#125;else&#123; // 第4个样例 // 有小数点情况 for (int i = 1; i &lt; epos; i++) &#123; if ( i == dot) continue; // 略过小数点 if ( i == exp + dot + 1) cout &lt;&lt;\".\"; cout &lt;&lt; s[i]; // 出错过一次, 这边不应该是else &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 1076 Forwards on Weibo 一道图的基础遍历题。英文题目有点难懂。意思是N个点，L层深度最多能遍历到几个点。由于有关注和被关注的关系，所以是有向图。接下来有N行，分别表示用户i有M[i]个关注，因此M[i]个user[j]转发的文章可以被用户i再次转发。最后一行是回答K个问题，分别是K[i]发文章在L的限制内最多被几个人转发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 10e4 + 5; struct Node&#123; int id; // 当前节点的编号 int layer; // 当前的层数&#125;typedef Node;std::vector&lt;Node&gt; G[MAXN];bool visited[MAXN] = &#123;false&#125;;/** * [BFS description] * @author mrli 2020-02-21 * @param s [起点] * @param L [最大深度] */int BFS(int s, int L)&#123; int ans = 0; queue&lt;Node&gt; q; Node tmp; tmp.id = s; tmp.layer = 0; q.push(tmp); // 将起点压入队列 visited[s] = true; // 记得对起点做设置 while(!q.empty())&#123; tmp = q.front(); q.pop(); int u = tmp.id; for (int v = 0; v &lt; G[u].size(); ++v)&#123; // BFS层次遍历该节点的所有结点 Node next = G[u][v]; next.layer = tmp.layer + 1; // 用BFS的形式来维护深度 if( visited[next.id] == false &amp;&amp; next.layer &lt;= L )&#123; // 如果是第一次被访问, 且在L深度内, 则答案++ q.push(next); visited[next.id] = true; // △对访问过的设置不能忘记 ans ++ ; // cout &lt;&lt; \"next.id: \" &lt;&lt; next.id &lt;&lt;'\\t'; &#125; &#125; &#125; return ans;&#125;int main(int argc, char const *argv[])&#123; int N, L; cin &gt;&gt; N &gt;&gt; L; Node user; for (int i = 1; i &lt;= N; ++i)&#123; // 编号从1开始-&gt;根据题目K问题的形式确定 user.id = i; int follownum; // 跟随j的用户人数 cin &gt;&gt; follownum; for (int j = 0; j &lt; follownum; ++j)&#123; int follow; cin &gt;&gt; follow; G[follow].push_back(user); &#125; &#125; // answer to the question int numQuery, s; cin &gt;&gt; numQuery; for (int i = 0; i &lt; numQuery; ++i)&#123; cin &gt;&gt; s; memset(visited, false, sizeof(visited)); int ans = BFS(s, L); cout &lt;&lt; ans &lt;&lt;endl; &#125; return 0;&#125; 1081 Rational Sum 分数计算的加强版，多个分数相加。我采用了一次性计算，其实可以直接用乙级的做法，两个两个依次计算。 ▲牛客网和PTA的样例点真的不一样，PTA上我有一个点过不了，但牛客的都能过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;typedef long long ll;#define INF 0x3f3f3fusing namespace std;struct Fenshu&#123; ll fenmu; ll fenzi;&#125;typedef Fenshu;// 找到分子和分母的最大公因数ll biggestNum(ll a, ll b)&#123; if (b==0) return a; return biggestNum(b,a%b);&#125;// 找到分子和分母的最小公倍数ll smallestNum(ll a,ll b)&#123; return a*b/biggestNum(a, b);&#125;int main(int argc, char const *argv[])&#123; int n; std::vector&lt;Fenshu&gt; v; while(scanf(\"%d\",&amp;n) != EOF)&#123; for (int i = 0; i &lt; n; ++i)&#123; Fenshu *fs = new Fenshu(); scanf(\"%lld/%lld\",&amp;fs-&gt;fenzi,&amp;fs-&gt;fenmu); v.emplace_back(*fs); &#125; // 找到所有分母的最小公倍数 ll mul = v.begin()-&gt;fenmu; for (std::vector&lt;Fenshu&gt;::iterator i = v.begin(); i != v.end(); ++i)&#123; std::vector&lt;Fenshu&gt;::iterator nx = std::next(i,1); if (nx != v.end())&#123; mul = smallestNum(mul, nx-&gt;fenmu); // printf(\"i-&gt;fenmu:%lld, nx-&gt;fenmu:%lld, tmp_mul:%lld\\n\", i-&gt;fenmu, nx-&gt;fenmu, tmp_mul); // 错误尝试写法：思路错了:变成了找到两个分母最小公倍数中最大的 // if (mul &lt; tmp_mul) &#123; // printf(\"tmp_biggest:%lld\\n\", tmp_biggest); // mul = tmp_mul; // &#125; &#125; &#125; // 相加再约分 ll sum = 0; for (std::vector&lt;Fenshu&gt;::iterator i = v.begin(); i != v.end(); ++i)&#123; // printf(\"%lld,%lld\\n\",i-&gt;fenzi, i-&gt;fenmu ); sum += i-&gt;fenzi*mul/(i-&gt;fenmu); &#125; if (sum == 0)&#123; // 采坑1:除0问题 printf(\"0\\n\"); &#125;else&#123; // 由于读取的设定,所以其实只有分子会是负数, yue也可能是负数 ll yue = abs(biggestNum(sum, mul)); ll res_fenzi = sum/yue; ll res_fenmu = mul/yue; // printf(\"sum:%lld\\n\", sum); // printf(\"%lld,%lld/%lld\\n\", yue, res_fenzi, res_fenmu); // printf(\"biggest:%lld\\n\", mul); // 需要化成真分数--&gt;采坑2:分子和为负数 if ( abs(res_fenzi) &gt; res_fenmu) &#123; if (res_fenzi%res_fenmu == 0) printf(\"%lld\\n\", res_fenzi/res_fenmu); else printf(\"%lld %lld/%lld\\n\", res_fenzi/res_fenmu, res_fenzi%res_fenmu, res_fenmu); &#125;else printf(\"%lld/%lld\\n\", res_fenzi, res_fenmu); &#125; v.clear(); &#125; return 0;&#125; ▲判断迭代器是否为空:就是拿返回的迭代器与.end()作比较。 踩坑记录： 负数求余仍是负数,0求余任何数为0 分子为负数、0、正数的时候都得分别考虑 找到所有分母的最小公倍数==&gt;写成了找到两个分母最小公倍数中最大的 浮点错误的意思-PAT 、OJ 是否可能出现了一个数除以0的情况 是否可能出现了一个数取余0的情况 是否发生了数据溢出而导致的除以0或者取余0的情况 1083 List Grades (25) 模拟题 考了输入输出+排序： 切割数据、操作符重载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;#ifndef N#define N 1000#endifusing namespace std;struct Record&#123; string name; string id; int grade; // 操作符重载 bool operator &lt;(const Record &amp;that) const&#123; return grade &gt; that.grade; &#125;&#125;typedef Record;int main()&#123; string row; std::vector&lt;Record&gt; v; int n; int a,b; scanf(\"%d\",&amp;n); getchar(); for(int i=0;i&lt;n;i++)&#123; // 获得行信息 getline(cin, row); stringstream ss(row); // 分割出name string name; getline(ss, name, ' '); // 分割出id string id; getline(ss, id, ' '); // 通过stringstream分割出grade: int int grade; ss &gt;&gt; grade; // 存到vector中 Record* r = new Record(); r-&gt;name = name; r-&gt;id = id; r-&gt;grade = grade; v.emplace_back(*r); &#125; // 根据grade进行从大到小排序 sort(v.begin(), v.end()); scanf(\"%d%d\", &amp;a, &amp;b); bool none = true; // 是否有在区间中人 for (int i = 0; i &lt; n; ++i)&#123; if (v[i].grade &gt;= a &amp;&amp; v[i].grade &lt;= b)&#123; none = false; cout &lt;&lt; v[i].name &lt;&lt; \" \" &lt;&lt; v[i].id &lt;&lt; endl; &#125; &#125; // 如果没有符合条件的人 if (none) cout &lt;&lt; \"NONE\" &lt;&lt; endl; return 0;&#125; 在此巩固复习一下&quot;操作符重载的知识&quot;: 1.为了实现对自定义类型的加减操作。 实现一个操作符重载的方式通常分为两种情况： 将操作符重载实现为类的成员函数； 使用O.operator#(); 操作符重载实现为非类的成员函数（即全局函数）。 使用 operator#(O); 区别在于，成员函数默认有this指针；后者需要为每次操作传递两个参数 △大多数操作符都能重载，不能的为如下几个：：、::、.*、?:、sizeof ▲重载运算符函数可以对运算符作出新的解释，但原有基本语义不变： 不改变运算符的优先级 不改变运算符的结合性 不改变运算符所需要的操作数 不能创建新的运算符 △一个运算符被重载后，原有意义没有失去，只是定义了相对一特定类的一个新运算符 ++前缀、后缀 1234567891011121314151617181920212223242526272829class Time&#123; public: // 重载前缀递增运算符（ ++ ）： 不传参 Time operator++ () &#123; ++minutes; // 对象加 1 if(minutes &gt;= 60) &#123; ++hours; minutes -= 60; &#125; return Time(hours, minutes); &#125; // 重载后缀递增运算符（ ++ ）: 传参 Time operator++( int ) &#123; // 保存原始值 Time T(hours, minutes); // 对象加 1 ++minutes; if(minutes &gt;= 60) &#123; ++hours; minutes -= 60; &#125; // 返回旧的原始值 return T; &#125;&#125; io操作符： ▲&lt;&lt;操作符只能通过友元来实现 A： 如果要重载&lt;&lt;操作符输出结果，一般的写法是cout&lt;&lt;s;也即是说左侧不是成员函数或类可以通过this指针调用的量，这就造成必须使用两个参数的成员操作符重载，把第一个参数作为&lt;&lt;左侧参数，第二个参数做为&lt;&lt;右侧参数输入，然而会发现如： ostream&amp; operator&lt;&lt;(ostream&amp; out, MyString&amp; s);*//报错，error:此运算符的参数太多* 1234567class xxx&#123; friend ostream&amp; operator&lt;&lt;(ostream &amp;out, const Complax &amp;c1);&#125;ostream&amp; operator&lt;&lt;(ostream &amp;out, const Complax &amp;c1)&#123; out &lt;&lt; \"c1.a = \" &lt;&lt; c1.a &lt;&lt; \"\\t c1.b = \" &lt;&lt; c1.b &lt;&lt; endl;&#125; 1084 Broken Keyboard 思路是遍历下面的短的字符串，然后用指针再遍历长的，用index指针来手动控制；边遍历边输出，就可以解决先后问题，否则用set会排序；用set记录是否已经输出过； 踩的坑点： set.find() == set.end()表示不存在，写IF条件的时候想反了，检查了半天；如果长的已经把短的所有都跑遍后，之后还有需要吧index继续跑完slen-inlen的长度 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100+5;std::set&lt;char&gt; cS;int main(int argc, char const *argv[])&#123; string s; cin &gt;&gt; s; string in; cin &gt;&gt; in; int slen = s.length(); int inlen = in.length(); int index=0; // 记录当前遍历到的位置 for (int i = 0; i &lt; inlen; ++i)&#123; while( s[index] != in[i] )&#123; char now = toupper( s[index] ); if( cS.find(now) == cS.end())&#123; cS.insert(now); cout &lt;&lt; now; &#125; index++; &#125; index++; &#125; while(index != slen)&#123; char now = toupper( s[index] ); if( cS.find(now) == cS.end())&#123; cS.insert(now); cout &lt;&lt; now; &#125; index++; &#125; cout &lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435import java.lang.reflect.Array;import java.util.Arrays;import java.util.Scanner;/** * @Program: testIDEA * @Description: * @Author: MrLi * @Create: 2020-05-26 15:28 **/public class Main &#123; public static void main(String[] args) &#123; String a, b; Scanner scanner = new Scanner(System.in); a = scanner.next(); b = scanner.next(); b += \"#\"; // 如果b为全空, 那么直接就会越界, 因此末尾补充一个, 这题由于上下有关联所以没关系, 但是对此类问题都可以养成这种习惯 boolean[] chars = new boolean[256]; Arrays.fill(chars, Boolean.FALSE); for (int i = 0, j = 0; i &lt; a.length(); i++) &#123; char x = Character.toUpperCase(a.charAt(i)); char y = Character.toUpperCase(b.charAt(j)); if (x == y) j ++ ; else&#123; if (!chars[x])&#123; System.out.print(x); chars[x] = true; &#125; &#125; &#125; &#125;&#125; 1086 Tree Traversals Again 建树老套路了, 只不过要识别出, 入栈对应先序, 出栈对应中序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;vector&lt;int&gt; pre;vector&lt;int&gt; in;int noden; // 节点个数struct node&#123; int val; node *lc, *rc; node()&#123;&#125; node (int v)&#123; val = v; lc = rc = NULL; &#125;&#125;;node *createTree(int preL, int preR, int inL, int inR)&#123; if (preL &gt; preR) return NULL; // 这边忘记了写错成preL &gt; inL了 int key = pre[preL]; int k; for (k = inL; k &lt;= inR; k++) &#123; // 找到根节点在中序中的位置 if (in[k] == key)&#123; break; &#125; &#125; // cout &lt;&lt; \"key: \" &lt;&lt; key &lt;&lt; \" k: \" &lt;&lt; k+1 &lt;&lt; endl; node *root = new node(key); root-&gt;val = key; int leftNum = k - inL; // 当前节点左边有多少节点个数 root-&gt;lc = createTree(preL+1, preL+leftNum, inL, k - 1); root-&gt;rc = createTree(preL+leftNum+1, preR, k+1, inR); return root;&#125;int coutNum = 0; // 已经输出的节点数void postOrder(node *root)&#123; if (root == NULL) return; postOrder(root-&gt;lc); postOrder(root-&gt;rc); // 官方输出格式 // cout &lt;&lt; root-&gt;val; // coutNum ++; // if (coutNum &lt; noden)&#123; // cout &lt;&lt;\" \" ; // &#125;else&#123; // cout &lt;&lt;endl; // &#125; coutNum ++; if (coutNum &lt; noden)&#123; cout &lt;&lt; root-&gt;val &lt;&lt; \" \"; &#125;else&#123; cout &lt;&lt; root-&gt;val &lt;&lt;endl; &#125;&#125;int main()&#123; int nodenum; // push操作数 int num; // pop结果 string op; stack&lt;int&gt; st; cin &gt;&gt; noden; for (int i = 0; i &lt; 2 * noden; i++) &#123; cin &gt;&gt; op; if (op == \"Push\")&#123; cin &gt;&gt; nodenum; pre.push_back(nodenum); st.push(nodenum); &#125;else if (op == \"Pop\")&#123; num = st.top(); st.pop(); in.push_back(num); &#125; &#125; node *root = createTree(0, pre.size() - 1,0, in.size() - 1); postOrder(root); return 0;&#125; 1091 Speech Patterns 题目不难， 主要是库函数的应用isdigit()、isalpha以及isalnum，还有map的应用 坑点比较多： 1.“”（即空会被记入map计算）；2.当已经是最后一个字母时要把最后一个单词记入（想了很久没过最后一个测试点） 本来以为要统计的是&quot;&quot;内的内容，结果好像不需要 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 0x3f3f3f3f;const int MOD = 1000000007;std::map&lt;string, int&gt; smap;int main(int argc, char const *argv[])&#123; string s; getline(cin, s); int slen = s.length(); string nows; // bool start = false; for (int i = 0; i &lt; slen; ++i) &#123; char now = s[i]; // if (now == '\"') start = !start; // if (start)&#123; if (isalnum(now))&#123; nows += tolower(now); &#125; if ( !isalnum(now) || i == slen-1)&#123; if(!nows.empty())&#123; // nows.size()会更好 smap[nows] += 1; nows.clear(); &#125; &#125; // &#125; &#125; int maxn = -MAXN; string ans; for (std::map&lt;string, int&gt;::iterator i = smap.begin(); i != smap.end(); ++i)&#123; if ( i-&gt;second &gt; maxn)&#123; maxn = i-&gt;second; ans = i-&gt;first; &#125; &#125; cout &lt;&lt; ans &lt;&lt; \" \" &lt;&lt; maxn &lt;&lt; endl; return 0;&#125; 1093 Count PAT’s 卡时限，普通思路会超时， 题解给的思路是找A然后计算前P的个数N，后T的个数M，然后得出M*N个，时间复杂度为O(n2) 个人的思路(过2个点，还有3个超时) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 0x3f3f3f3f;const int MOD = 1000000007;std::vector&lt;int&gt; P;std::vector&lt;int&gt; A;std::vector&lt;int&gt; T;int main(int argc, char const *argv[])&#123; string s; cin &gt;&gt; s; int l; l = s.length(); for (int i = 0; i &lt; l; ++i) &#123; if (s[i]=='P') P.push_back(i); else if (s[i]=='A') A.push_back(i); else if (s[i]=='T') T.push_back(i); else ; &#125; int pl = P.size(); int al = A.size(); int tl = T.size(); int ans = 0; for (int i = 0; i &lt; pl; ++i)&#123; for (int j = 0; j &lt; al; ++j)&#123; if (P.at(i)&lt;A.at(j))&#123; for (int k = 0; k &lt; tl; ++k) &#123; if (A.at(j) &lt; T.at(k))&#123; ans = (ans+1) %MOD; // break; &#125; &#125; &#125; &#125; &#125; cout &lt;&lt;ans&lt;&lt; endl; return 0;&#125; Deduplication on a Linked List 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * @Author: Mrli * @Date: 2020-06-27 10:52:28 * @LastEditTime: 2020-06-30 23:58:52 * @Description: */ #include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5 + 5;vector&lt;bool&gt; visited(MAXN);struct Node&#123; int addr; int val; int nextaddr;&#125;LinkList[MAXN];vector&lt;Node&gt; leftvec;vector&lt;Node&gt; removed;int main()&#123; int root, N; scanf(\"%d%d\", &amp;root, &amp;N); int addr; for (int i = 0; i &lt; N; i++) &#123; scanf(\"%d\", &amp;addr); scanf(\"%d%d\", &amp;LinkList[addr].val, &amp;LinkList[addr].nextaddr); LinkList[addr].addr = addr; &#125; int start = root; while(start != -1)&#123; int value = int(abs(LinkList[start].val)); if ( !visited[ value ]) leftvec.push_back(LinkList[start]); else removed.push_back(LinkList[start]); visited[value] = true; start = LinkList[start].nextaddr; &#125; int leftLen = leftvec.size(); int removedLen = removed.size(); for (int i = 0; i &lt; leftLen; i++) &#123; if ( i != leftLen - 1)&#123; printf(\"%05d %d %05d\\n\", leftvec[i].addr, leftvec[i].val, leftvec[i+1].addr); &#125;else&#123; printf(\"%05d %d -1\\n\", leftvec[i].addr, leftvec[i].val); &#125; &#125; for (int i = 0; i &lt; removedLen;i++) &#123; if ( i != removedLen - 1)&#123; printf(\"%05d %d %05d\\n\", removed[i].addr, removed[i].val, removed[i+1].addr); &#125;else&#123; printf(\"%05d %d -1\\n\", removed[i].addr, removed[i].val); &#125; &#125; return 0;&#125; 链表套路 写了几个静态链表的题了, 总结下套路: 判断给的节点是否在链表上——增加一个flag的字段。 如果不需要一般静态链表的节点定义为 12345struct Node&#123; int addr; int val; int nextaddr;&#125;LinkList[MAXN]; 读取套路 12345for (int i = 0; i &lt; N; i++) &#123; scanf(\"%d\", &amp;addr); scanf(\"%d%d\", &amp;LinkList[addr].val, &amp;LinkList[addr].nextaddr); LinkList[addr].addr = addr;&#125; 遍历 12345678910int start = root;while(start != -1)&#123; int value = int(abs(LinkList[start].val)); if ( !visited[ value ]) leftvec.push_back(LinkList[start]); else removed.push_back(LinkList[start]); visited[value] = true; start = LinkList[start].nextaddr;&#125; 输出 1234567for (int i = 0; i &lt; leftLen; i++) &#123; if ( i != leftLen - 1)&#123; printf(\"%05d %d %05d\\n\", leftvec[i].addr, leftvec[i].val, leftvec[i+1].addr); &#125;else&#123; printf(\"%05d %d -1\\n\", leftvec[i].addr, leftvec[i].val); &#125;&#125; 1096 Consecutive Factors 一个比较重要的点: n不能被大于sqrt(n)的整除 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * @Author: Mrli * @Date: 2020-07-01 23:25:13 * @LastEditTime: 2020-07-02 00:19:04 * @Description: */ #include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int main()&#123; ll n; scanf(\"%lld\", &amp;n); ll sqrtn = (ll)sqrt(n); ll ansI = 0, maxlen = 0; // 注意这边maxlen不能设置为-1, 因为下面是用0判断的 for (ll i = 2; i &lt;= sqrtn; i++) &#123; ll j = i; ll tmp = 1; while(true)&#123; tmp *= j; if ( n % tmp != 0) break; if (j - i + 1 &gt; maxlen)&#123; maxlen = j - i + 1; ansI = i; &#125; j ++; &#125; &#125; if ( maxlen == 0) printf(\"1\\n%lld\\n\", n); else&#123; printf(\"%lld\\n\", maxlen); for (ll i = 0; i &lt; maxlen; i++) &#123; if ( i &lt; maxlen - 1)&#123; printf(\"%lld*\", ansI + i); &#125;else&#123; printf(\"%lld\", ansI + i); &#125; // 第二种输出 // for (ll i = 0; i &lt; maxlen; i++) &#123; // printf(\"%lld\", ansI + i); // if ( i &lt; maxlen - 1) printf(\"*\"); // &#125; &#125; &#125; return 0;&#125; 1099 Build A Binary Search Tree // 跟1064对比, 这边是真遍历。 v为存储结点信息的树。 那题是完全二叉树， 这题是二叉搜索树， 所以在层次遍历的构造上是不一样的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Node&#123; int val; int left, right; &#125;;int n;vector&lt;Node&gt; v;vector&lt;int&gt; in;bool cmp(const Node a , const Node b )&#123; return a.val &lt; b.val;&#125;int k = 0;// 跟1064对比, 这边是真遍历。 v为存储结点信息的树void inOrder(int root)&#123; if (root == -1) return ; inOrder(v[root].left); v[root].val = in[k++]; inOrder(v[root].right);&#125;void bfs(int root)&#123; queue&lt;int&gt; q; q.push(root); k = 0; while(!q.empty())&#123; int now = q.front(); q.pop(); cout &lt;&lt; v[k].val; k++; if ( k &lt; n) cout &lt;&lt; \" \"; if (v[now].left != -1) q.push(v[now].left); if (v[now].right != -1) q.push(v[now].right); &#125;&#125;int main()&#123; cin &gt;&gt; n; v.resize(n); in.resize(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v[i].left &gt;&gt; v[i].right; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; in[i]; &#125; sort(in.begin(), in.end()); inOrder(0); bfs(0); return 0;&#125; 1102 Invert a Binary Tree 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* * @Author: Mrli * @Date: 2020-07-19 11:28:37 * @LastEditTime: 2020-07-19 14:22:32 * @Description: */ #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;const int maxn = 1e2;bool isRoot[maxn];struct Node&#123; int left; int right;&#125;Nodearr[maxn];int chr2int(char ch)&#123; if ( ch == '-' ) return -1; else &#123; isRoot[ ch - '0'] = false; return ch - '0'; &#125;&#125;int findRoot()&#123; for (int i = 0; i &lt; n; i++) &#123; if ( isRoot[i] == true)&#123; return i; &#125; &#125; return -1;&#125;void postOrder(int root)&#123; if (root == -1) return ; // if ( Nodearr[root].left != -1 ) postOrder(Nodearr[root].left); // if ( Nodearr[root].right != -1 ) postOrder(Nodearr[root].right); swap(Nodearr[root].right, Nodearr[root].left);&#125;int cnt = 0;void print(int idx)&#123; if ( cnt == n-1)&#123; cout &lt;&lt; idx &lt;&lt; endl; &#125;else &#123; cout &lt;&lt; idx &lt;&lt; \" \"; &#125; cnt ++;&#125;void inOrder(int root)&#123; if (root == -1) return ; inOrder(Nodearr[root].left); print(root); inOrder(Nodearr[root].right);&#125;void levelOrder(int root)&#123; queue&lt;int&gt; q; q.push(root); while( !q.empty() )&#123; int now = q.front(); q.pop(); print(now); if ( Nodearr[now].left != -1 ) q.push(Nodearr[now].left); if ( Nodearr[now].right != -1 ) q.push(Nodearr[now].right); &#125;&#125;int main()&#123; scanf(\"%d\", &amp;n); fill(isRoot, isRoot+n, true); for (int i = 0; i &lt; n; i++) &#123; char left, right; scanf(\"%*c%c %c\", &amp;left, &amp;right); Nodearr[i].left = chr2int(left); Nodearr[i].right= chr2int(right); &#125; int root = findRoot(); postOrder(root); levelOrder(root); cnt = 0; inOrder(root); return 0;&#125; 1107 Social Clusters 并查集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000 + 5;int n;int arr[maxn]; // 并查集int h[maxn]; // 爱好int hx[maxn]; // 爱好void init()&#123; for (int i = 0; i &lt;= n; i++) &#123; arr[i] = i ; &#125;&#125;int getf(int u)&#123; // 找到u的父亲 int v = u; while( u != arr[u])&#123; u = arr[u]; &#125; // 路径压缩 while ( arr[v] != v)&#123; int tmp = v; // 记录当前v的值 v = arr[v]; // 记录下一个点-&gt;v arr[tmp] = u; // 把当前点的父亲设置为u &#125; return u;&#125;void merge(int u, int v)&#123; int f1 = getf(u); int f2 = getf(v); if (f1 != f2)&#123; arr[f2] = f1; &#125;&#125;int main()&#123; int tmp; scanf(\"%d\", &amp;n); init(); for (int i = 1; i &lt;= n; i++) &#123; int k; scanf(\"%d:\", &amp;k); for (int j = 0; j &lt; k; j++) &#123; scanf(\"%d\", &amp;tmp); if (!h[tmp]) h[tmp] = i; else merge(h[tmp], i); &#125; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; hx[getf(i)]++; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (hx[i]!=0)ans++; &#125; // 直接用arr不行, 必须用getf找, 对样例是都能跑通的, 但会挂3个点。网上也都是用getf找的父亲， 而不是用arr // for (int i = 1; i &lt;= n; i++) &#123; // cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"]:\" &lt;&lt; arr[i] &lt;&lt; '\\t'; // cout &lt;&lt; \"getf(i\" &lt;&lt; i &lt;&lt; \"):\" &lt;&lt; getf(i) &lt;&lt; endl; // &#125; // int ans = 0; // for (int i = 1; i &lt;= n; i++) &#123; // if ( arr[i] == i )&#123; // ans ++; // &#125; // hx[arr[i]] ++; // &#125; cout &lt;&lt; ans &lt;&lt;endl; sort(hx+1, hx+1+n, greater&lt;int&gt;()); for (int i = 1; i &lt;= ans; i++) &#123; cout &lt;&lt; hx[i]; if (i &lt; ans) cout &lt;&lt; ' '; &#125; return 0;&#125; 1109Group Photo 排序, 模拟 思路: 从排好序的vecotr中取元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int n, k;const int maxn = 1e4 + 5;struct Student&#123; string name; int h; Student()&#123;&#125;; Student(string _name, int _h): name(_name), h(_h)&#123;&#125;;&#125;arr[maxn];// 1. 每行n/k（向下取整）人， 多出的剩下的人数站最后一行// 2. 后面排的身高 &gt;= 前面排的, 字典序大的前// 3. 最高的站中间， 两边依次降低bool cmp(Student &amp;a, Student &amp;b)&#123; if (a.h != b.h) return a.h &lt; b.h; return a.name &gt; b.name;&#125;// ▲.关键void printLine(int st, int ed)&#123; int nums = ed - st + 1; // 数的个数 int mid = (nums) / 2 + 1; // 中间编号, v: [1,ed] vector&lt;int&gt; v( nums + 1, 0); v[mid] = ed; // 中间的序号为ed int l = mid - 1, r = mid + 1; while( l &gt;= 1)&#123; // 实现交替--ed if (l &gt;= 1) v[l--] = --ed; // 左侧依次-1 if (r &lt;= nums) v[r++] = --ed; &#125; // 从arr中按照v[i]取出名字 for (int i = 1; i &lt;= nums; i++) &#123; if ( i == 1) cout &lt;&lt; arr[ v[i] ].name; else cout &lt;&lt; \" \" &lt;&lt; arr[ v[i] ].name ; &#125; cout &lt;&lt; endl;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; k; string name; int h; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; name &gt;&gt; h; arr[i] = Student(name, h); &#125; sort(arr + 1, arr+ n + 1, cmp); int rowNum = floor(n / k); for (int i = k; i &gt;= 1; i--) &#123; if ( i &lt; k)&#123; int st = rowNum * ( i - 1) + 1; int ed = rowNum * i; // cout &lt;&lt; \"st: \" &lt;&lt;st &lt;&lt; \"\\t\" &lt;&lt; \"ed:\" &lt;&lt; ed &lt;&lt;endl; printLine(st, ed); &#125;else&#123; // 第一行 int st = rowNum * ( i - 1) + 1; int ed = n; // cout &lt;&lt; \"st: \" &lt;&lt;st &lt;&lt; \"\\t\" &lt;&lt; \"ed:\" &lt;&lt; ed &lt;&lt;endl; printLine(st, ed); &#125; &#125; return 0;&#125; 1113 Integer Set Partition 大水题 将输入的数分成两个不相交的集合，在满足个数差最小的条件下，找两个集合所有元素和差最大值。 其实是道找规律题：将数进行从小到大排序，然后一分为二，根据奇偶数的不同，n之差直有1和0两种可能，差值最大的情况便是大数-小数 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int SIZE = 1e5 + 5;int arr[SIZE];int main(int argc, char const *argv[])&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; arr[i]; sort(arr, arr+n); int s1 = 0, s2 = 0 ; if( n % 2 == 1)&#123; for (int i = 0; i &lt; (n-1)/2; ++i) s1 += arr[i]; for (int i = (n-1)/2; i &lt; n; ++i) s2 += arr[i]; cout &lt;&lt; 1 &lt;&lt; \" \" &lt;&lt; s2 -s1 &lt;&lt; endl; &#125;else&#123; for (int i = 0; i &lt; n/2; ++i) s1 += arr[i]; for (int i = n/2; i &lt; n; ++i) s2 += arr[i]; cout &lt;&lt; 0 &lt;&lt; \" \" &lt;&lt; s2 -s1 &lt;&lt; endl; &#125; return 0;&#125; 1116 Come on! Let’s C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;using namespace std;const int num = 1e4 + 5;int arr[num];bool isPrime(int n)&#123; // if ( n &lt; 0 ) return false; if (n == 1) return false; if ( n == 2 || n == 3) return true; if ( n % 6 != 5 &amp;&amp; n % 6 != 1) return false; for (int i = 5; i &lt;= sqrt(n); i+=6) &#123; if ( n % i == 0 || n % (i + 2) == 0) return false; &#125; return true;&#125;string coutList[5] = &#123; \"Are you kidding?\", \"Mystery Award\", \"Minion\", \"Chocolate\", \"Checked\"&#125;;int main()&#123; ios::sync_with_stdio(false); int n, k; cin &gt;&gt; n; int tmp; int q; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tmp; arr[tmp] = i; if (i == 1)&#123; arr[tmp] = 1; &#125;else if( isPrime(i) )&#123; arr[tmp] = 2; &#125;else&#123; arr[tmp] = 3; &#125; &#125; cin &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; q; printf(\"%04d: %s\\n\", q, coutList[arr[q]].c_str() ); if (arr[q])&#123; arr[q] = 4; &#125; &#125; return 0;&#125; 1117 Eddington Number 12345678910111213141516171819202122232425262728/* * @Author: Mrli * @Date: 2020-09-05 09:27:31 * @LastEditTime: 2020-09-05 09:36:35 * @Description: */#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; scanf(\"%d\", &amp;n); vector&lt;int&gt; v(n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;v[i]); &#125; sort(v.begin(), v.end(), less&lt;int&gt;()); // 实质上就是双指针法， ans必须从1开始， 因为他是最长的天数 // int ans = !v.empty() ? v[0] : 1; 错误写法， 最大距离可以是E， 但是天数不可能为 int ans = 1; for (int i = n - 1; i &gt;= 0 ; ans++, i -- ) &#123; if ( ans &gt;= v[i]) break; &#125; cout &lt;&lt; ans - 1 &lt;&lt; endl; return 0;&#125; 1120 Friend Numbers 我使用的是Map，但set效果更好 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int SIZE = 1e5 + 5;int arr[SIZE];int main(int argc, char const *argv[])&#123; int n; cin &gt;&gt; n; std::map&lt;int, int&gt; map; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; arr[i]; for (int i = 0; i &lt; n; ++i)&#123; int sum = 0; int tmp = arr[i]; while(tmp&gt;0)&#123; sum += tmp%10; tmp /= 10; &#125; map[sum] ++; &#125; std::vector&lt;int&gt; v; cout &lt;&lt; map.size() &lt;&lt; endl; for (std::map&lt;int, int&gt;::iterator i = map.begin(); i != map.end(); ++i) &#123; // end()-1好像不行 // std::map&lt;int, int&gt;::iterator e = map.end()-1; // if(i != e) // cout &lt;&lt; i-&gt;first &lt;&lt; ' '; // else // cout &lt;&lt; i-&gt;first &lt;&lt; endl; //第二种写法 // std::map&lt;int, int&gt;::iterator e = map.end()-1; // if(i != map.begin()) // cout &lt;&lt; ' '; // else // cout &lt;&lt; i-&gt;first &lt;&lt; endl; // 第三种办法 // 使用flag记录 /*第四种 if(it==out.begin()) cout&lt;&lt;*it; else cout&lt;&lt;\" \"&lt;&lt;*it; */ // 我的笨办法 v.push_back(i-&gt;first); &#125; for (int i = 0; i &lt; v.size(); ++i) &#123; if(i!=v.size()-1) cout &lt;&lt; v[i] &lt;&lt; \" \"; else cout &lt;&lt; v[i] &lt;&lt; endl; &#125; return 0;&#125; 1128 N Queens Puzzle 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3 + 5;int n, m;vector&lt;int&gt; chess;bool judge(int i)&#123; // i为行数, 即放的第几个 // chess[x] 记录的列数 for (int j = 0; j &lt; i; j++) &#123; if ( ( chess[i] == chess[j] ) || ( abs(chess[i] - chess[j]) == abs(i - j))) return false; &#125; return true;&#125;int main()&#123; int T; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt;n; chess.resize(n); bool yes = true; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; chess[i]; if(judge(i) == false)&#123; yes = false; // break; &#125; &#125; if (yes) cout &lt;&lt; \"YES\" &lt;&lt;endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; return 0;&#125; 1134 Vertex Cover 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/* * @Author: Mrli * @Date: 2020-06-25 13:35:38 * @LastEditTime: 2020-06-25 14:42:20 * @Description: */ #include &lt;bits/stdc++.h&gt;using namespace std;/**两种思路:- 将边都收集后, 待遍历query点集时每遍历一个点, 就把其相连的边置为已访问, 当遍历完所有点, 再看有没有边时未访问的- 将边都收集后, 遍历每一条边, 看边的两端是否在query的点集中*/// 方法一, 遍历点时将边标记为1, 最后再遍历看看有没有边没访问过int main()&#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); vector&lt;int&gt; vec[n]; // 链表 vector&lt;int&gt; visited; visited.resize(m+1); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); vec[u].push_back(i); vec[v].push_back(i); &#125; int q; int x; scanf(\"%d\", &amp;x); while(x--)&#123; scanf(\"%d\", &amp;q); // 每次将访问结果清空 fill(visited.begin(), visited.end(), 0); for (int j = 0; j &lt; q; j++) &#123; int u; scanf(\"%d\", &amp;u); for (int v = 0; v &lt; vec[u].size(); v++) &#123; if (!visited[ vec[u][v] ] ) visited[ vec[u][v] ] = 1; &#125; &#125; bool all = true; for (int i = 1; i &lt;= m; i++) &#123; if (visited[i] == 0)&#123; printf(\"No\\n\"); all = false; break; &#125; &#125; if( all ) printf(\"Yes\\n\"); &#125; return 0;&#125;// 方法二, 遍历边, 判断是否有边两端都不在query点集中.struct node&#123; int u; int v; node()&#123;&#125; node(int uu, int vv)&#123; u = uu; v = vv; &#125;&#125;;int main()&#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); // 需要有node()&#123;&#125; 参数为空的构造函数, 所以如果声明了带参数的构造函数, 那么需要特地写个空的构造函数 vector&lt;node&gt; edge; edge.resize(m); for (int i = 0; i &lt; m; i++) &#123; int u, v; scanf(\"%d%d\", &amp;edge[i].u, &amp;edge[i].v); &#125; int x; cin &gt;&gt; x; while(x--)&#123; bool all = true;unordered int q; scanf(\"%d\", &amp;q); int tmp; unordered_set&lt;int&gt; se; for (int i = 0; i &lt; q; i++) &#123; scanf(\"%d\", &amp;tmp); se.insert(tmp); &#125; for (int j = 0; j &lt; m; j++) &#123; if (se.find(edge[j].u) == se.end() &amp;&amp; se.find(edge[j].v) == se.end() )&#123; all =false; break; &#125; &#125; if (all) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125; 1146 Topological Order 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e4 + 5;int n, m;vector&lt;int&gt; ve[maxn];vector&lt;int&gt; in; // 入度void bfs()&#123; queue&lt;int&gt; q; for (int i = 0; i &lt; n; i++) &#123; if ( in[i] == 0)&#123; q.push(i); &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; in.resize(n + 1); int u, v; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; ve[u].push_back(v); in[v]++; &#125; int k; vector&lt;int&gt; ans; cin &gt;&gt; k; bool first = true; for (int i = 0; i &lt; k; i++) &#123; vector&lt;int&gt; copyin(in.begin(), in.end()); bool flag = true; int tmp; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; tmp; if ( copyin[tmp] ) flag = false; for(auto &amp;k: ve[tmp]) copyin[k]--; &#125; if (flag == false) ans.push_back(i); &#125; int sz = ans.size(); for (int i = 0; i &lt; sz; i++) &#123; if (i == sz - 1) cout &lt;&lt; ans[i] &lt;&lt; endl; else cout &lt;&lt; ans[i] &lt;&lt; \" \"; &#125; return 0;&#125; 1151 LCA in a Binary Tree LCA找最近公共祖先 给出中序、先序遍历的序列（给出的不是值， 而是节点编号）； 由于节点值都是不同的， 因此可以构造BST二叉搜索数， 用静态数组的形式进行遍历， 否则就跟LeetCode#236一样建树然后DFS遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* * @Author: Mrli * @Date: 2020-09-22 11:53:35 * @LastEditTime: 2020-09-22 13:28:51 * @Description: */#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int m, n;/** pos是位置position的意思，pos是个map，主要是用来标记中序的， 因为有的时候不仅需要知道i下标的中序是j， 还需要知道结点j对应的位置是i， 主要用来保存和in[i]相反的对应的映射关系*/map&lt;int, int&gt;pos;vector&lt;int&gt; in, pre;// https://www.bilibili.com/video/BV1X5411b7C2/?spm_id_from=333.788.videocard.0void lca(int inL, int inR, int a, int b, int preRoot)&#123; if (inL &gt; inR) return; // preRoot节点在中序中的位置 int inRoot = pos[pre[preRoot]]; // 节点a, b在中序的节点位置 int aIn = pos[a], bIn = pos[b]; if ( aIn &lt; inRoot &amp;&amp; bIn &lt; inRoot)&#123; lca(inL, inR - 1, a, b, preRoot + 1); &#125;else if ( (aIn &lt; inRoot &amp;&amp; bIn &gt; inRoot) || ( aIn &gt; inRoot &amp;&amp; bIn &lt; inRoot ))&#123; printf(\"LCA of %d and %d is %d.\\n\", a, b, in[inRoot]); &#125;else if ( aIn == inRoot)&#123; printf(\"%d is an ancestor of %d.\\n\", a, b); &#125;else if ( bIn == inRoot)&#123; printf(\"%d is an ancestor of %d.\\n\", b, a); &#125; // else if ( aIn &gt; inRoot &amp;&amp; bIn &gt; inRoot)&#123; else&#123; // 左子树节点个数 int numLeft = (inRoot - inL) + 1; lca(inRoot + 1, inR, a, b, preRoot + numLeft); &#125; // else&#123; // 两个都不相等, 证明inRoot是他们两个的祖先 // printf(\"LCA of %d and %d is %d.\", a, b, inRoot); // &#125; &#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; m &gt;&gt; n; in.resize(n + 1); pre.resize(n + 1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; in[i]; // 中序遍历的结果是有序的, 但是这边输入的是值的节点编号id. // 记录节点编号在中序中的索引 pos[in[i]] = i; &#125; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; pre[j]; &#125; for (int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; // 如果pos[a] == 0 表示节点a没有出现过 if ( pos[a] == 0 &amp;&amp; pos[b] == 0) printf(\"ERROR: %d and %d are not found.\\n\", a, b); else if ( pos[a] == 0 ) printf(\"ERROR: %d is not found.\\n\", a); else if ( pos[b] == 0)printf(\"ERROR: %d is not found.\\n\", b); else &#123; lca(1, n, a, b, 1); &#125; &#125; return 0;&#125; 1154 Vertex Coloring 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * @Author: Mrli * @Date: 2020-07-18 20:55:38 * @LastEditTime: 2020-07-18 21:18:07 * @Description: */ #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, m;struct edge&#123; int uu,vv;&#125;;/** 每条边的两个顶点都是不同的颜色， 最多能有多少种颜色 */int main()&#123; cin &gt;&gt; n &gt;&gt; m; vector&lt;edge&gt; v(m); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; v[i].uu &gt;&gt; v[i].vv; &#125; int k; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; // 记录顶点颜色 vector&lt;int&gt; cv(n); // 记录颜色个数 set&lt;int&gt; se; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; cv[j]; se.insert(cv[j]); &#125; bool flag = true; for (int j = 0; j &lt; m; j++) &#123; // cout &lt;&lt; v[j].uu &lt;&lt; \"\\t\" &lt;&lt; v[j].vv &lt;&lt; \"\\t\" &lt;&lt; cv[ v[j].uu ] &lt;&lt; \"\\t\" &lt;&lt; cv[ v[j].vv ] &lt;&lt; endl; if ( cv[ v[j].uu ] == cv[ v[j].vv ])&#123; flag = false; break; &#125; &#125; if (flag)&#123; cout &lt;&lt; se.size() &lt;&lt; \"-coloring\" &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0;&#125; 1155 Heap Paths 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * @Author: Mrli * @Date: 2020-07-18 21:37:50 * @LastEditTime: 2020-07-18 21:37:50 * @Description: */ #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;vector&lt;int&gt; tree;bool maxHeap = false;bool minHeap = false;void dfs(int root, vector&lt;int&gt; path)&#123; path.push_back(tree[root]); int left = root*2 + 1; int right = root*2 + 2; if (left &gt;= n) &#123; // 以一个子节点为根据, 反向探索 int sz = path.size(); for (int i = 0; i &lt; sz; i++) &#123; cout &lt;&lt; path[i]; if ( i == sz - 1)&#123; cout &lt;&lt; endl; &#125;else&#123; cout &lt;&lt;\" \"; if ( path[i] &lt; path[i+1] &amp;&amp; i+1 &lt; n) minHeap = true; else if( path[i] &gt; path[i+1] &amp;&amp; i+1 &lt; n) maxHeap = true; &#125; &#125; &#125;else if (left == n-1)&#123; // 判断左子树是否为最后一个节点-&gt;是否有右子树 dfs(left, path); &#125;else&#123; dfs(right, path); dfs(left, path); &#125;&#125;int main()&#123; cin &gt;&gt; n; tree.resize(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tree[i]; &#125; vector&lt;int&gt; path; dfs(0, path); if ( maxHeap &amp;&amp; minHeap )cout &lt;&lt;\"Not Heap\" &lt;&lt;endl; else if (maxHeap) cout &lt;&lt; \"Max Heap\" &lt;&lt;endl; else if (minHeap) cout &lt;&lt; \"Min Heap\" &lt;&lt;endl; else cout &lt;&lt;\"Not Heap\" &lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** @Author: Mrli* @Date: 2020-05-26 20:10:10 * @LastEditTime: 2020-05-26 20:36:44* @Description: */ #include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;using namespace std;struct School&#123; string name; double total; int testee; School(): name(\"\"), testee(0), total(0.0)&#123;&#125; bool operator&lt; (const School &amp;that) const&#123; if ( abs(total - that.total) &gt; 1e-8 ) // 不相等, 记得加abs绝对值 // if ( total != that.total ) // 不相等 return total &gt; that.total; if ( testee != that.testee ) return testee &lt; that.testee; return name &lt; that.name; &#125;&#125;;int main()&#123; int n; cin &gt;&gt; n; unordered_map&lt;string, School&gt; hash; while(n -- )&#123; string sch, id; double score ; cin &gt;&gt; id &gt;&gt; score &gt;&gt; sch; for(auto &amp;s: sch) s = tolower(s); if ( id[0] == 'B') score /= 1.5; else if (id[0]== 'T' ) score *= 1.5; hash[sch].testee ++; hash[sch].total += score; hash[sch].name = sch; &#125; vector&lt;School&gt; v; for(auto item: hash)&#123; item.second.total = int( item.second.total + 1e-8); v.push_back(item.second); &#125; sort(v.begin(), v.end()); cout &lt;&lt; v.size() &lt;&lt; endl; int rank = 1; for (int i = 0; i &lt; v.size(); i++) &#123; School s = v.at(i); if (i == 0) &#123; cout &lt;&lt; rank &lt;&lt; \" \" &lt;&lt; s.name &lt;&lt; \" \" &lt;&lt; s.total &lt;&lt; \" \" &lt;&lt; s.testee &lt;&lt; endl; &#125;else&#123; if( s.total != v.at(i-1).total) rank = i+1; cout &lt;&lt; rank &lt;&lt; \" \" &lt;&lt; s.name &lt;&lt; \" \" &lt;&lt; s.total &lt;&lt; \" \" &lt;&lt; s.testee &lt;&lt; endl; &#125; &#125; return 0;&#125; 附录 刷PAT好用到哭的函数 好用的函数 string-&gt;int 12345678// 法一int grade;string s = \"123\";stringstream ss;ss &gt;&gt; grade;// 法二stoi() // 在cstring中 int-&gt;string 1234// 法一to_string()// C++11之后才支持// 法二itos() // cstring中 sort中cmp函数编写 123456789101112131415161718192021222324252627// 从大到小排序bool cmp(rc &amp;a, rc &amp;b)&#123; return a.grade &gt; b.grade;&#125;// 从小到大排序bool cmp(rc &amp;a, rc &amp;b)&#123; return a.grade &lt; b.grade;&#125;// 如果为M则排前，F排后； 如果字符相同，就比成绩// -&gt;排前的return truebool cmp(rc &amp;r1, rc &amp;r2)&#123; if(r1.sex == \"M\" &amp;&amp; r2.sex == \"F\") return true; else if(r1.sex == \"F\" &amp;&amp; r2.sex == \"M\") return false; else return r1.grade &lt; r2.grade;&#125;// 一般情况下,对相等的情况不需要特殊处理,因此&lt;/&gt;也可以处理相等的情况,// 但是一旦题目要求处理相等情况, 那么就需要额外拎出判断, 见1025 PAT Rankingbool cmp(rc &amp;a, rc &amp;b)&#123; if(a.grade != b.grade) return a.grade&gt;b.grade; else return (a.ID&lt;b.ID);&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"}]},{"title":"软件测试笔记","slug":"软件测试笔记","date":"2019-10-18T13:03:29.000Z","updated":"2019-11-02T02:05:36.942Z","comments":true,"path":"2019/10/18/软件测试笔记/","link":"","permalink":"https://nymrli.top/2019/10/18/软件测试笔记/","excerpt":"","text":"软件测试笔记 移动应用测试 appnium使用 安装的是appnium-desktop,没有教程中所说的Appium/node_modules/.bin/路径，使用命令行输入appnium和appium-doctor也都没啥反应，后来索性没管，直接跑代码 真机测试 使用的时候报错Build info: version: 'unknown', revision: 'unknown', time: 'unknown'，以为是appnium版本的问题，第一次安装的是1.13，后来换成了1.9，其实没多大区别，只不过据说要保证版本在1.6以上。 更换版本后，发现还是Build info: version: 'unknown', revision: 'unknown', time: 'unknown'问题，于是试了多次，才终于解决。 步骤一： 这边是设置appnium连接参数的 由于群里的高分脚本也是这么设置的，我就以为没多大问题，其实这边还是要修改不少东西的 1234567891011//设置自动化相关参数DesiredCapabilities capabilities = new DesiredCapabilities();capabilities.setCapability(\"browserName\", \"\");// 确定自己的手机系统是Android、ios的话需要需改capabilities.setCapability(\"platformName\", \"Android\");// 这边要设置成自己的设备uuid，通过adb devices查看capabilities.setCapability(\"deviceName\", \"Android Emulator\");// 这个demo代码会提供好，就不需要自己去找了capabilities.setCapability(\"appPackage\", \"cn.etouch.ecalendar\");capabilities.setCapability(\"appActivity\", \".ECalendar\");capabilities.setCapability(\"noSign\", \"true\"); appPackage查看包名(可以找到唯一的应用)：adb shell dumpsys activity | find &quot;mFocusedActivity&quot;，需要的结果即cn.etouch.ecalendar 12adb shell dumpsys activity | find \"mFocusedActivity\"&gt;&gt;&gt; mFocusedActivity: ActivityRecord&#123;1510a73 u0 cn.etouch.ecalendar/.MainActivity t2&#125; activityName查询类名(找到应用上的某个界面)：aapt dump badging &lt;apkPath&gt;然后找到launchable-activity 123# e.g.E:\\android-sdk-windows\\build-tools\\28.0.3\\aapt dump badging C:\\mooctest\\projects\\3399\\52660\\Zhwnl\\apk\\Zhwnl.apk | grep launchable-activity&gt;&gt;&gt; launchable-activity: name='cn.etouch.ecalendar.ECalendar' label='中华万年历' icon='' 步骤二： 除了代码上设置好连接手机的参数，手机也需要设置电脑能操作手机 需要打开三个选项：“USB调试”、“USB安装”、“USB调试（安全设置）” 以小米6手机为例:“更多设置”-&gt;“开发者选项”-&gt;“USB调试”、“USB安装”、“USB调试（安全设置）” 由于之前使用python玩过ADB，所以**“USB调试”、&quot;USB调试（安全设置）&quot;是开启的，而没打开USB安装**，所以导致了一直失败。实际上打开USB安装后，会安装几个程序比如Unlock、appnium settings等。其实报错一开始也提示了，没检测到手机，啥啥安装不上，只不过当时没留意 123Exception in thread &quot;main&quot; org.openqa.selenium.WebDriverException: An unknown server-side error occurred while processing the command. Original error: Unable to find an active device or emulator with OS 4.1.1. The following are available: cf46749d (8.0.0) (WARNING: The server did not provide any stacktrace information)Command duration or timeout: 469 millisecondsBuild info: version: &apos;unknown&apos;, revision: &apos;unknown&apos;, time: &apos;unknown&apos; ▲后来又发现，不设置platformVersion、deviceName直接设置成Android Emulator也行，看来最主要的原因还是手机第一次使用Appnium之前需要安装写appnium的软件 这个应该就是这两行所安装的东西 1234//设置使用unicode键盘，支持输入中文和特殊字符capabilities.setCapability(\"unicodeKeyboard\",\"true\");//设置用例执行完成后重置键盘capabilities.setCapability(\"resetKeyboard\",\"true\"); 夜深模拟器测试 1 开启USB调试 设置-&gt;关于平板电脑-&gt;多次点击&quot;版本号&quot;进入开发者模式-&gt;开发者选项-&gt;打开**“USB调试”和&quot;允许模拟位置&quot;** 2 查看deviceName 命令行中输入adb devices，如果一直没检测到，解决方案如下（我是需要这么做的）： 12345678910111213如果在设备连接过程中，确定设备已经开启USB调试且正确连接到PC，但是仍旧使用adb devices指令查到设备列表为空，则有可能是已安装的安卓SDK中的adb程序版本和模拟器自带的adb程序版本不一致导致的。解决办法可能有很多种，这里暂介绍楼主亲测实用的方案：第一步：关闭正在运行的的模拟器第二步：替换adb.exe程序。逍遥模拟器：进入安装目录（默认为..\\Microvirt\\MEmu），找到adb.exe文件，执行删除。然后进入SDK的安装目录（默认为..\\android-sdk-windows\\platform-tools），拷贝系统adb.exe到逍遥的原目录即可。夜神模拟器：进入安装目录，找到nox_adb.exe文件，执行删除。然后进入SDK的安装目录（默认为..\\android-sdk-windows\\platform-tools），拷贝系统adb.exe到逍遥的原目录，重命名为“nox_adb.exe”即可。第三步：启动模拟器。启动完毕后，打开cmd命令窗口输入 adb devices 再次检查设备连接情况，一般就能正常看到已连接的虚拟设备信息了。 运行代码main.java 123456789//设置自动化相关参数DesiredCapabilities capabilities = new DesiredCapabilities();capabilities.setCapability(\"browserName\", \"\");capabilities.setCapability(\"platformName\", \"Android\");// capabilities.setCapability(\"platformVersion\", \"8.0.0\");capabilities.setCapability(\"deviceName\", \"127.0.0.1:62001\");capabilities.setCapability(\"appPackage\", \"cn.etouch.ecalendar\");capabilities.setCapability(\"appActivity\", \".ECalendar\");capabilities.setCapability(\"noSign\", \"true\"); 然后运行测试代码就能看到这样的画面了 进入元素审查 安装教程，我是安装软件测试大赛提供的教程安装下来的，只不过感觉这篇可能将的更好一点。（ appium-doctor 是需要额外用npm安装的，而不是像比赛教程中写的那样） 踩坑记录： 出现报错UiAutomator exited unexpectedly with code 0, signal null 123456$ adb shell$ cd /data/local/tmp （如果一次性进不去，可以分层一层层进入）# 3、进入data/local/tmp 后ls查看全部目录，应该有一个 AppiumBootstrap.jar，可能你的名字是 AppiumBoots 或者 AppiumBootstrap.jar。# 4、将andriod sdk下的AppiumBootstrap.jar发送上去$ adb push C:\\Users\\10630\\AppData\\Local\\Programs\\Appium\\resources\\app\\node_modules\\appium\\node_modules\\appium-android-driver\\bootstrap\\bin\\AppiumBootstrap.jar /data/local/tmp# 5、ok，大功告成 adb unauthorized 1.使用adb连接手机时，即使打开了usb调试，手机添加了信任，仍然出现unauthorized的提示 2.C:\\Users\\(Username)\\.android里面删掉adbkey和adbkey.pub两个文件(没添加过信任的话是没有的)，然后重新插拔手机 执行： 12adb kill-serveradb start-server △如果上述方式还是无效的话，选择“开发者测试”-&gt;&quot;调试&quot;中的撤销USB调试授权，然后重新上述操作 特殊元素定位之获取toast java-client版本必须满足5.0+ desiredCapabilities中指定automationName为：UIAutomator2 UIAutomator2只支持安卓版本5.0+ getElement(By.xpath(&quot;//*[contains(@text,'tips')]&quot;)); Monkey使用 脚本优势：简单、快捷、不需要借助任何工具，可以做简单的性能测试 脚本缺点：只能简单实现坐标、按键等基本操作（根据像素点来进行操作） 123456789101112131415161718192021222324#头文件、控制monkey发送消息的参数type=raw eventscount=10speed=1.0#以下monkey命令start data&gt;&gt; # 开启柠檬杯appLaunchActivity（com.lemon.lemonban，com.lemon.lemonban.activity.WelcomeActivity）#让脚本暂停运行4S UserWait（4000）#点击我的柠檬元素Tap（600，1220）#点击我的头像登录#让脚本暂停运行1S UserWait（1000）Tap（300，200）#让脚本暂停运行1s UserWait（2000）#输入手机号码DispatchString（18588220110）#点击密码输入框Tap（200，650）#输入密码DispatchString（123456）#点击登录按钮Tap（320，800）UserWait（3000） 1234# 上传monkey脚本adb push monkeyScript.txt /sdcard/# 运行monkey脚本adb shell monkey -f /sdcard/monkeyScript.txt uiautomatorviewer使用 位置E:\\android-sdk-windows\\tools 1234567@echo onadb shell uiautomator dump /sdcard/app.uixadb pull /sdcard/app.uix .adb shell screencap -p /sdcard/app.pngadb pull /sdcard/app.png . 采坑记录: 小米手机有点坑啊，进行Android开发时需要设置挺多东西的。 关闭MIUI优化不然没法调试 如果进行uiautomatorviewer调试的话，必须还要把悬浮球给关了，不然没法获取界面。 TouchAction 点击操作 123456789101112// pressTouchAction ta=new TouchAction(driver);//创建一个TouchAction对象ta.press(element).release().perform();//按一个元素ta.press(500, 450).release().perform();//按一个坐标点//按一个元素上的某个点，从左上角偏移100ta.press(element,100,100).release().perform();// tapta.tap(element).release().perform();//点一个元素ta.tap(300, 500).release().perform();//点一个坐标点//按一个元素的某个点，从左上角偏移100ta.tap(element, 100, 100).release().perform(); 长按操作 12345678910// longPressTouchAction ta=new TouchAction(driver);//创建一个TouchAction对象ta.longPress(element).release().perform();//长按某个元素ta.longPress(element, 5000).release().perform();//长按某个元素，时间是5秒ta.longPress(300, 500).release().perform();//长按某个坐标点ta.longPress(300, 500, 3000).release().perform();//长按某个坐标点，时间是5秒//长按某元素上的某个点，从左上角偏移100ta.longPress(element, 100, 100).release().perform();//长按某元素上的某个点，从左上角偏移100，时间是3秒ta.longPress(element, 100, 100, 3000).release().perform(); 组合操作–拖拽 12345// press + moveToTouchAction ta=new TouchAction(driver);//创建一个TouchAction对象ta.press(element1).moveTo(element2).release().perform();//两个元素互换位置//将元素拖拽到另外一个位置，moveTo中的是相对偏移量ta.press(element1).waitAction(500).moveTo(0,200).waitAction(500).release().perform(); 连续滑动手势（可用于手势解锁） 12345678// press + moveToTouchAction ta=new TouchAction(driver);//创建一个TouchAction对象//从第一个点一直滑动到第四个点ta.press(200, 200).moveTo(0, 100).moveTo(100, 0).moveTo(100, 100).release().perform();//从第一个元素一直滑动到第四元素ta.press(element1).moveTo(element2).moveTo(element3).moveTo(element4).release().perform()// swipedriver.swipe(width * 3 / 4, height / 2, width / 4, height / 2, during); 其他 1234//在 0% 到 100% 内双指缩放屏幕 driver.pinch(element=el)//放大屏幕 在 100% 以上放大屏幕 driver.zoom(element=el) appnium定位+操作方式(python)——老版本 ▲Appium java-client库更新到6.x后，滑动 swipe() 已弃用，且TouchAction类中很多方法也有改变。 （ 总的来看，弃用的是 press() longPress() moveTo() tap() 参数使用 x、y轴和webElement 的这种类型，和用到Duration类型的方法 ） 取而代之的是参数类型变了，涉及到XY轴定位的方法，参数使用了PointOption.point(X坐标, Y坐标)；涉及到Duration的方法waitAction()，参数使用了WaitOptions.waitOptions(Duration.ofNanos(时间间隔)) 123456//java-client 4.x 滑动 swipe() 案例：driver.swipe(width * 3 / 4, height / 2, width / 4, height / 2, during); //java-client 6.x 滑动案例：int nanos=(int) (second*1000); TouchAction action = new TouchAction(driver).press(PointOption.point(width* 3/4,height/2)).waitAction(WaitOptions.waitOptions(Duration.ofNanos(nanos))).moveTo(PointOption.point(width/4, height/2)).release().perform(); java-client 5.0.4后被移除的函数 众测的思路： 常见输入框的输入范围、限制 手机号11位、验证码6位、敏感信息、特殊字符 toast提示框是否正确 控件是否有错别字 附录： 众包测试报告评分规则 1、众包测试得分=bug报告得分（包括单一状bug报告、fork的bug报告） +评审得分（点赞，点踩） 2、每个Bug报告满分10分，Bug报告基础分1-5分，选手提交的Bug等级仅供参考，以评审人员判定为准； 3、Bug描述简洁清晰、复现步骤连贯、按序号排序，评审人员可根据其描述顺利的进行操作并复现Bug，附加3分。 4、Bug截图相关则附加1分，截图上使用红框标注Bug位置则附加1分； 5、点赞点踩得分规则：即为正确的bug报告点赞，错误的bug报告点踩可得分；反之扣分。 6、若两人提交bug报告相同，依据时间优先原则，后提交的报告计低分，所以若发现的bug已被他人提交，建议Fork（复制并补充修改）或对bug报告进行评审（点赞，点踩）。 开发者测试 语句覆盖： 保证程序中的每一个语句至少被执行一次。 被认为是“最弱的覆盖” 语句覆盖率：被执行语句的比例 判定覆盖(分支覆盖)：CFG (control Flow Graph控制流图 )所有的边都被访问/所有的分支都被访问 ▲针对判断语句，在设定案例的时候，要设定True和False的两种案例；与语句覆盖不同的是增加了False的情况 分支覆盖率：被访问的分支的比例 条件覆盖 针对判断语句里面案例的取值都要去一次，不考虑条件的取值。 每个小判断分别为真，其他为假的情况 判定/条件覆盖 判定覆盖各条件覆盖交叉，针对于判定中的条件取值 、 每个判定真假各一次(判定覆盖) 每个判定中的条件各取一次(条件覆盖) 组合覆盖 判定-条件覆盖的加强版 判定中所有可能的条件组合 路径覆盖 走完所有可能的路径 语句覆盖、条件覆盖（分支覆盖）、判定覆盖、条件-判定覆盖、组合覆盖、路径覆盖 输入域上的测试 –随机测试 –等价类划分 –边界值分析 最小值(min) 略大于最小值(min+) 输入值域内的任意值(nom) 略小于最大值(max-) 最大值(max) Input Domain-Based Techniques(continue) •Random Testing •Combinatorial Testing","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"},{"name":"软件测试","slug":"软件测试","permalink":"https://nymrli.top/tags/软件测试/"}]},{"title":"玩玩Stm32","slug":"玩玩Stm32","date":"2019-10-15T08:33:09.000Z","updated":"2019-10-18T08:56:46.703Z","comments":true,"path":"2019/10/15/玩玩Stm32/","link":"","permalink":"https://nymrli.top/2019/10/15/玩玩Stm32/","excerpt":"","text":"玩玩Stm32 文件结构 12345678910111213141516G:.├───CORE # startup_stm32f10x_hd.s汇编编写的启动文件| # core_cm3.c底层函数├───HARDWARE # 相关外设的初始化代码├───OBJ├───STM32F10x_FWLib # 固件库包: GPIO/i2c/...│ ├───inc│ └───src├───SYSTEM # 正点原子提供的常用、通用模块│ ├───delay│ ├───sys│ └───usart└───USER # stm32f10x_it.c 中断管理文件 | # stm32f10x.h ├───Listings └───Objects 编写规范： 用户编写的执行代码写在main.c中,其中#include &quot;stm32f10x.h&quot;作用相当于C51的#include &lt;reg51.h&gt;，是操作寄存器的主要固件库文件,在任何地方引用到固件库函数时都需要导入这个文件。 stm32f10x_it.c、stm32f10x_it.h, 专门存放中断服务函数的C文件 ,大多中断函数都 写在此文件中,方便 管理中断函数,但并不是一定要写在这里面。 GPIO ◆端口复用功能 STM32的大部分端口都具有复用功能。 所谓复用,就是一些端口不仅仅可以做为通用lO口,还可以复用为一些外设引脚,比如PA9,PA10可以复用为STM32的串口1引脚。 ▲作用：最大限度的利用端口资源 ◆端口重映射功能 就是可以把某些功能引脚映射到其他引脚。 比如串口1默认引脚是PA9,PA10可以通过配置重映射映射到PB6,PB7 作用：为了方便布线 ▲所有I0口都可以作为中断输入 工作模式： 推挽输出：可以输出强高低电平 上拉输入: 一端是接地低电平,所以默认情况下另一端需要检测到高电平(按键扫描中,三个引脚需要设置为IPU,按下时&lt;==&gt;输入口检测到低电平) 下拉输入：(按下时&lt;==&gt;输入口检测到低电平) GPIO重要函数 12345678910111213//1个初始化函数：void GPIO_Init(GPIO_TypeDef* GPIOx,GPIO_InitTypeDef* GPIO_InitStruct)；//2个读取输入电平函数：uint8t GPIO_ReadlinputDataBit(GPIO TypeDef* GPIOx,uint16_t GPIO_Pin)；uint16_t GPIO_ReadinputData(GPIO_TypeDef* GPIOx)；//2个读取输出电平函数：uint8t GPIO_ReadOutputDataBit(GPiO_TypeDef* GPiOx,uint16_t GPIO_Pin)；uint16t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)；//4个设置输出电平函数：前两个常用,后两个不常用void GPIO_SetBits(GPIOTypeDef* GPIOx, uint16_t GPIOPin)；void GP1O_ResetBits(GPIOTypeDef GPIOx,uint16_t GPIOPin)；void GPIO_WriteBit(GPIOTypeDef* GPIOx,uint16_t GPIO_Pin,BitAction BitVal)；void GPIO_Write(GPIOTypeDef* GPIOx, uint16_t PortVal) 具体说明 1234567891011121314151617181920212223void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)/*GPIO_TypeDef为GPIO寄存器组合的类型typedef struct&#123; __IO uint32_t CRL; __IO uint32_t CRH; __IO uint32_t IDR; __IO uint32_t ODR; __IO uint32_t BSRR; __IO uint32_t BRR; __IO uint32_t LCKR;&#125; GPIO_TypeDef;GPIOx的选择可以为GPIOA-&gt;GPIOG*/ /*typedef struct&#123; uint16_t GPIO_Pin; GPIOSpeed_TypeDef GPIO_Speed; GPIOMode_TypeDef GPIO_Mode; &#125;GPIO_InitTypeDef;*/ 初始化示例 12345678910// 声明结构体变量GPIO_InitTypeDef GPIO_InitStructure；//LEDO--&gt;PB.5端口配置GPIO InitStructure.GPIO Pin =GPIO_Pin_5；//推挽输出GPIO InitStructure.GPIO Mode=GPIO_Mode_Out_PP；//IO口速度为50MHzGPIO InitStructure.GPIO Speed=GPIO_Speed_50MHz；//根据设定参数初始化GPIOB.5GPIO_Init(GPIOB,&amp;GPIO_InitStructure); ▲在使用GPIO前,需要使能IO口时钟,调用函数RCC_APB2PeriphColckCmd(); 1234567891011121314151617181920212223242526void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)/*RCC_APB2Periph 可以为RCC_APB2Periph_AFIO RCC_APB2Periph_GPIOA RCC_APB2Periph_GPIOB RCC_APB2Periph_GPIOC RCC_APB2Periph_GPIOD RCC_APB2Periph_GPIOE RCC_APB2Periph_GPIOF RCC_APB2Periph_GPIOG RCC_APB2Periph_ADC1 RCC_APB2Periph_ADC2 RCC_APB2Periph_TIM1 RCC_APB2Periph_SPI1 RCC_APB2Periph_TIM8 RCC_APB2Periph_USART1 RCC_APB2Periph_ADC3 RCC_APB2Periph_TIM15 RCC_APB2Periph_TIM16 RCC_APB2Periph_TIM17 RCC_APB2Periph_TIM9 RCC_APB2Periph_TIM10 RCC_APB2Periph_TIM11 NewState 为ENABLE / DISABLE*/ 提示：不能通过IO口直接驱动大功率器件。 △复位之后，IO口默认为浮空状态，如果不接下拉电阻，那么电平不确定为高还是低电平。(到是小电流的时候，电流会直接通过下拉电阻到地，不会经过三极管；只有电流足够大，才会经过三极管) demo : 跑马灯实验 当将PE5设置为低电平时,通过上拉电阻连到VCC后,LED就能点亮。PE5被设置为高电平时与上拉高电平之间没有压差,此时LED熄灭。 完整代码: led.c文件内容 12345678910111213141516171819202122#include \"led.h\"#include \"stm32f10x.h\" // 在任何地方引用到固件库时都需要导入这个文件void LED_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOE,ENABLE); GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOB,&amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOE,&amp;GPIO_InitStruct); // 设置为高电平,熄灭 GPIO_SetBits(GPIOB, GPIO_Pin_5);&#125; main.c文件内容 12345678910111213141516#include \"stm32f10x.h\"#include \"led.h\"#include \"delay.h\" int main(void)&#123; delay_init(); LED_Init(); while(1)&#123; GPIO_SetBits(GPIOB,GPIO_Pin_5); GPIO_SetBits(GPIOE,GPIO_Pin_5); delay_ms(500); GPIO_ResetBits(GPIOB,GPIO_Pin_5); GPIO_ResetBits(GPIOE,GPIO_Pin_5); delay_ms(500); &#125; &#125; 操作IO口的三种方式： 位操作：#define BEEP PBout(8);后BEEP = 1 库函数：GPIO_SetBits(GPIOB, GPIO_Pin_8); 寄存器： 中断管理 对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。IP bit决定了对每个中断共有2^4(位) = 16级的中断优先级设置 高优先级的抢占优先级是可以打断正在进行的低抢占优先级中断的。 抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。 抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行。 如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行； 总结：中断嵌套执行看抢占优先级；占优先级相同时,响应优先级高的先响应；两者都一样的话，执行顺序看发生的时间 △.优先级0最高，4最低。 ▲.系统代码执行过程中，只设置一次中断优先，一般不会再改变分组。 1234567891011121314// 中断优先级分组函数void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)// demo: NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2) // 对某个中断设置优先级void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)/*typedef struct&#123; uint8_t NVIC_IRQChannel; uint8_t NVIC_IRQChannelPreemptionPriority; uint8_t NVIC_IRQChannelSubPriority; FunctionalState NVIC_IRQChannelCmd; &#125; NVIC_InitTypeDef;*/ 中断优先级控制的寄存器组：IP[240]对每个中断进行管理,STM32F10x系列一共有60个可屏蔽中断。全称是：Interrupt Priority Registers 中断优先级设置步骤 123456789101112131415//①统运行后先设置中断优先级分组。调用函数：//整个系统执行过程中，只设置一次中断分组。void NVIC_Priority_GroupConfig(uint32_t NVIC_PriorityGroup)；//②针对每个中断，设置对应的抢占优先级和响应优先级：void NVIC Init(NVIC_InitTypeDef* NVIC_Initstructy；/* demo:NVIC_InitStructure.NVIC_IRQChannel=EXTI3_IRQn://使能按键KEY1所在的外部中断通道NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0x02：//抢占优先级2NVIC_InitStructure.NVIC_IRQChannelSubPriority =0x01：∥字优先级1NVIC_InitStructure.NVIC_IRQChannelCmd =ENABLE://使能外部中断通道NWIC_Init(&amp;WIC_Init Structure)：/根据NIC_InitStruct中指定的参数初始化外设NVIC寄存器*/ //③如果需要挂起/解挂，查看中断当前激活状态，分别调用相关函数即可。 串口通信 异步: 跟系统时钟无关 同步: 跟系统时钟有关 波特率计算方法:Tx/RxBaudrate=fPCLKx(16∗USARTDIV)\\mathrm{Tx} / \\mathrm{Rx} \\quad Baud rate=\\frac{f_{P C L K x}}{(16 * U S A R T D I V)}Tx/RxBaudrate=(16∗USARTDIV)fPCLKx​​ 配置的一般步骤: 串口作为外设，需要使能:RCC_APB2PeriphClockCmdO;、以及使能GPIO的时钟 GPIO端口模式设置GPIOInit0;，模式设置为GPIO_Mode_AFPP复用推挽(PA.9/10复用为串口1) 串口参数初始化 使能串口USART Cma); 串口数据收发 ▲ UART串口通信只需连接TX，RX，GND ， 一般不需要连接VCC A：TX、RX是正负压的，所以有个地做参考就行了 A： 通信两端一般都有各自的供电电压，所以不需要VCC，只有一端没有电源的情况下才会用VCC向对方输送电源 A：就像像耳机只要联地、音频左、音频右，而不联vcc一个道理 正点原子提供的USART库： 以回车换行结束的协议 usart.h 1234567#define USART_REC_LEN 200 //定义最大接收字节数 200#define EN_USART1_RX 1 //使能（1）/禁止（0）串口1接收 extern u8 USART_RX_BUF[USART_REC_LEN]; //接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 extern u16 USART_RX_STA; //接收状态标记 //如果想串口中断接收，请不要注释以下宏定义void uart_init(u32 bound); 数据全保存在USART_RX_BUF中。根据STA的有效数据个数比如50个，将USART_RX_BUF中前50个数据拿出处理。处理完所有标志位将被清零 ▲程序要求，发送的字符是以回车换行结束(Ox0D,0x0A)。 △串口调试助手里勾选&quot;发送新行&quot;选项 usart.c 程序理解 12345678910111213141516171819202122232425262728293031323334353637void USART1_IRQHandler(void) //串口1中断服务程序 &#123; u8 Res;#if SYSTEM_SUPPORT_OS //如果SYSTEM_SUPPORT_OS为真，则需要支持OS. OSIntEnter(); #endif if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) //接收中断(接收到的数据必须是0x0d 0x0a结尾) &#123; Res =USART_ReceiveData(USART1); //读取接收到的数据(单个字符) if((USART_RX_STA&amp;0x8000)==0)//没收到\\n,即接收未完成 &#123; if(USART_RX_STA&amp;0x4000)//接收到了0x0d(\\r) &#123; if(Res!=0x0a)USART_RX_STA=0;//如果下一个不是\\n,那么接收错误,重新开始 else USART_RX_STA|=0x8000; //如果接受到\\n,则接收完成,将USART_RX_STA bit15置1 &#125; else //还没收到0X0D,即处理真正数据 &#123; // 如果当前接收到\\r,那么将Bit14置1 if(Res==0x0d)USART_RX_STA|=0x4000; else &#123; // 将当前收到的字符Res存到数组USART_RX_BUF保存 USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=Res ; // 索引+1 USART_RX_STA++; // 如果数据超额,那么判断为接收错误 if(USART_RX_STA&gt;(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收 &#125; &#125; &#125; &#125; #if SYSTEM_SUPPORT_OS //如果SYSTEM_SUPPORT_OS为真，则需要支持OS. OSIntExit(); #endif&#125; Res =USART_ReceiveData(USART1);获得的是当前接收的字符，如果使用中断，那么调用USART_SendData(USART1, Res)就能接收一个字符，发送一个字符。 USART_RX_BUF的作用是，保存一次字符串发送过来的所有数据 USART_RX_STA是个寄存器，通过Bit14，Bit15来判断接收是否有效 main.c 12345678910111213141516171819202122232425262728293031int main(void)&#123; u16 t; u16 len; u16 times=0; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 KEY_Init(); //初始化与按键连接的硬件接口 while(1)&#123; if(USART_RX_STA&amp;0x8000)&#123; len=USART_RX_STA&amp;0x3fff;//得到此次接收到的数据长度 printf(\"\\r\\n您发送的消息为:\\r\\n\\r\\n\"); for(t=0;t&lt;len;t++)&#123; USART_SendData(USART1, USART_RX_BUF[t]);//向串口1发送数据 while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);//等待发送结束 &#125; printf(\"\\r\\n\\r\\n\");//插入换行 USART_RX_STA=0; &#125;else&#123; times++; if(times%5000==0)&#123; printf(\"\\r\\n战舰STM32开发板 串口实验\\r\\n\"); printf(\"正点原子@ALIENTEK\\r\\n\\r\\n\"); &#125; if(times%200==0)printf(\"请输入数据,以回车键结束\\n\"); if(times%30==0)LED0=!LED0;//闪烁LED,提示系统正在运行. delay_ms(10); &#125; &#125; &#125; ▲printf可以将发送到串口，默认是USART1，如果需要修改，在usart.c的fputc函数中,将USART1修改即可 外部中断 每个IO口都可以作为外部中断输入 IO与中断线的映射,16* 7 = 112, 一共有16个中断线 Q:什么是中断线,能干什么? A:中断线能发出中断请求 △.同一时刻只有一个引脚能映射到某根中断线 原理: GPIOX.0映射到EXT10 GPIOX.1映射到EXT11 GPIOX.15映射到EXTI15 e.g.PA.0~PG.0可以映射到EXIT0 I0口外部中断在中断向量表中只分配了7个中断向量，也就是只能使用7个中断服务函数 常用库函数 123456789void GPIO_EXTILineConig(uint8_t GPIO,uint8_t PortSource,uint8_t GPIO_PinSource)//设置IO口与中断线的映射关系：exp:GPIO_EXTILineContig(GPIO_PortSourceGPIOE, GPIO_PinSource2)void EXTIInit(EXTI_InitTypeDef* EXTI_InitStruct);//初始化中断线：触发方式等ITStatus EXTI_GetlTStatus(uint32_t EXTI_hLine);//判断中断线中断状态，是否发生void EXTI_ClearlTPendingBit(uint32_t EXTI_Line)//清除中断线上的中断标志位 12345EXTI_InitStructure.EXTI_Line=EXTI_Line2;// 指定要配置的中断线EXTI_InitStructure.EXTI_Mode =EXTI_Mode_Interrupt;// 模式:事件or中断EXTI_InitStructure.EXTI_Trigger =EXTI_Trigger_Faling;//上升沿、下降沿、双触发沿EXTI_InitStructure.EXTI_LineCmd =ENABLE;// 使能、失能EXTI_Init(&amp; EXTI_InitStructure); 配置的一般步骤 demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384void EXTIX_Init(void)&#123; // 声明初始化结构体变量 EXTI_InitTypeDef EXTI_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; KEY_Init(); // 按键端口初始化 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //使能复用功能时钟 //GPIOE.2 中断线以及中断初始化配置 下降沿触发 GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2); EXTI_InitStructure.EXTI_Line=EXTI_Line2; //KEY2 EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 // ▲由于参数一致，所以不需要修改EXTI_InitStructure的功能参数 //GPIOE.3 中断线以及中断初始化配置 下降沿触发 //KEY1 GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource3); EXTI_InitStructure.EXTI_Line=EXTI_Line3; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 //GPIOA.0 中断线以及中断初始化配置 上升沿触发 PA0 WK_UP GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0); EXTI_InitStructure.EXTI_Line=EXTI_Line0; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; //使能按键WK_UP所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2， NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn; //使能按键KEY2所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2， NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级2 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn; //使能按键KEY1所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01; //子优先级1 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器&#125;//外部中断2服务程序void EXTI2_IRQHandler(void)&#123; delay_ms(10);//消抖 if(KEY2==0) //按键KEY2 &#123; LED0=!LED0; &#125; EXTI_ClearITPendingBit(EXTI_Line2); //清除LINE2上的中断标志位 &#125;//外部中断3服务程序void EXTI3_IRQHandler(void)&#123; delay_ms(10);//消抖 if(KEY1==0) //按键KEY1 &#123; LED1=!LED1; &#125; EXTI_ClearITPendingBit(EXTI_Line3); //清除LINE3上的中断标志位 &#125;void EXTI4_IRQHandler(void)&#123; delay_ms(10);//消抖 if(KEY0==0) //按键KEY0 &#123; LED0=!LED0; LED1=!LED1; &#125; EXTI_ClearITPendingBit(EXTI_Line4); //清除LINE4上的中断标志位 &#125; main.c 1234567891011121314int main(void) &#123; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //初始化与LED连接的硬件接口 BEEP_Init(); //初始化蜂鸣器端口 KEY_Init(); //初始化与按键连接的硬件接口 EXTIX_Init(); //外部中断初始化 LED0=0; //点亮LED0 while(1)&#123; printf(\"OK\\r\\n\"); delay_ms(1000); &#125; &#125; 附录: u8、u16、Size_t是什么类型? u8、u16 123456789/*!&lt; Signed integer types */typedef signed char int8_t; //有符号8位数typedef signed short int16_t; //有符号16位数typedef signed long int32_t; //有符号32位数 /*!&lt; Unsigned integer types */typedef unsigned char uint8_t; //无符号8位数typedef unsigned short uint16_t; //无符号16位数typedef unsigned long uint32_t; //无符号32位数 size_t size_t是C++标准在stddef.h中定义的。这个类型足以用来表示对象的大小。size_t的真实类型与操作系统有关。size_t在32位架构上是4字节，在64位架构上是8字节，在不同架构上进行编译时需要注意这个问题。而int在不同架构下都是4字节，与size_t不同；且int为带符号数，size_t为无符号数。 电平相关知识 单片机是一种数字集成芯片，数字电路中只有两种电平高电平和低电平。为了让大家在刚起步的时候对电平特性有一个清晰的认识，我们暂且定义单片机输出与输入为TTL电平，其中高电平为+5V,低电平为0V。计算机的串口为RS-232C电平。这里要强调的是，RS-232C电平为负逻辑电平。因此当计算机与单片机之间要通信时，需要加电平转换芯片，我们在TX-1C单片机实验板上所加的电平转换芯片是MAX232 。 常用的逻辑电平有TTL、CMOS、LVTTL、ECL、PECL、 GTL 、RS-232. RS-422. RS-485、LVDS等.其中TTL和CMOS的逻辑电平按典型电压可分为四类：5V系列(5V TL和5V CMOS)、3.3V 系列，2.5V 系列和1.8V系列， T电平信号用的最多，这是因为，数据表示通常采用二进制，+5V等价于逻辑1，0V等价于逻辑0）.这被称为TTL（晶体管一晶体管逻辑电平）信号系统，这是计算机处理器控制的设备内部各部分之间通信的标准技术。TTL电平信号对于计算机处理器控制的设备内部的数据传输是很理想的，首先计算机处理器控制的设备内部的数据传输对于电源的要求不高，热损耗也较低，另外TTL电平信号直接与集成电路连接而不需要价格昂贵的线路驱动器 功能函数 判断u8数组开头 123456789101112131415161718#include &lt;string.h&gt;/////////////////////////// 判断u8 arr开头是否为str //////////////////////////int u8cmp(u8 *arr, const char *str)&#123; int i; int len = strlen(str); for ( i = 0; i &lt; len; i++)&#123; if( arr[i] != str[i])&#123; // arr shorter than str if (arr[i] == '\\0') return -1; // not start with return 0; &#125; &#125; // arr start with str return 1;&#125;","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://nymrli.top/tags/嵌入式/"}]},{"title":"蒙特卡洛树搜索MCTS","slug":"蒙特卡洛树搜索MCTS","date":"2019-10-07T09:18:02.000Z","updated":"2019-11-26T10:12:38.435Z","comments":true,"path":"2019/10/07/蒙特卡洛树搜索MCTS/","link":"","permalink":"https://nymrli.top/2019/10/07/蒙特卡洛树搜索MCTS/","excerpt":"","text":"蒙特卡洛树搜索MCTS 跟围棋的关联 AlphaGo Zero 蒙特卡洛树搜索——内含用于树遍历的 PUCT 函数的某些变体 残差卷积神经网络——其中的策略和价值网络被用于评估棋局，以进行下一步落子位置的先验概率估算。 强化学习——通过自我对弈进行神经网络训练 AlphaGo Zero跟AlphaGo的最大区别是抛弃人类棋谱的，完全通过自我对弈来学会下棋的，并且仅用40小时就到达了AlphaGo的棋力。 过程是这样，首先生成棋谱，然后将棋谱作为输入训练神经网络，训练好的神经网络用来预测落子和胜率。如下图： 在AlphaGo Zero中蒙特卡洛树搜索主要是用来生成棋谱的 蒙特卡洛树搜索 Q:MCTS干了什么? A:给出一个「游戏状态」并选择「胜率最高的下一步」 适用于有限两人零和回合制游戏 MCTS算法是一种决策算法，每次模拟（simulation）分为4步： Tree traversal(树的遍历): UCB1(Si)=Vi‾+clog⁡Nni,c=2UCB1(S_{i})=\\overline{V_{i}}+c \\sqrt{\\frac{\\log N}{n_{i}}}, c=2UCB1(Si​)=Vi​​+cni​logN​​,c=2 其中，表Vi‾\\overline{V_{i}}Vi​​示SiS_iSi​状态的平均value(下面会进一步解释） Node expansion(拓展节点) Rollout (random simulation)(模拟) Backpropagation(方向传播) 蒙特卡洛计算过程 UCB(Upper Confidence Bounds置信上限)其实就是UCT(UCB for Tree)中需要计算的值，而UCT是根据UCB值来迭代的算法 第一、二步的流程（遍历、拓展节点）： 1.从状态S0开始，要在下面两个动作中进行选择（假设只有两个动作可选），选择的标准就是UCB1(Si)UCB1(S_{i})UCB1(Si​)值，选择最大化 UCT 的节点作为下一个节点。初始情况两个UCB1(S1)=UCB1(S2)=∞UCB1(S_{1})=UCB1(S_{2})=\\inftyUCB1(S1​)=UCB1(S2​)=∞,按顺序选择S1 2.判断目前的结点S1(current node)是不是叶节点，这里叶节点是指其没有被展开（expansion）过。 3.接下来，按照流程图，需要判断结点S1被访问的系数是否为0。是0，则要进行Rollout。(Rollout其实就是在接下来的步骤中每一步都随机采取动作，直到停止点（围棋中的对局结束），得到一个最终的value。)==&gt;假设Rollout最终值为20. 4.Backpropagation，即利用Rollout最终得到的value来更新路径上每个结点的T,N值。(之后把Rollout的结果删除：MCTS的想法就是要从出S0发不断的进行迭代，不断更新结点值，直到达到一定的迭代次数或者时间。) 5.如果没有达到一定的迭代次数或者时间，继续从根节点进行1-4 第三步rollout模拟: 1234567891011/*这个函数接受一个表示博弈状态的参数，然后返回下一步行动。实际上，它被设计得非常快，从而可以让很多模拟快速进行——默认的 rollout policy 函数是一个均衡分布的随机数生成函数。*/Rollout(S_i): loop forever: /* 如果当前状态结点是个终止结点 */ if S_i is a terminal state: /* 那么直接返回它的value值*/ return value(S_i) /* 找到下一个动作 */ A_i = random(available-actions(S_i)) /* 选择下一个状态进行拓展 */ S_i = simulate(A_i,S_i) 例子说明见:蒙特卡洛树搜索（MCTS）算法-计算过程，视频讲解见B站:【MCTS】Youtube上迄今为止最好的蒙特卡罗树搜索讲解 相比极大极小法（minimax）。这个策略假定你的对手发挥了最好的博弈水平，然后以此调整策略来最大化你的收益。简单地说，给定状态，你想要找到一个能产生最大收益的 move ，假定你的对手想要最小化你的收益（最大化他自己的收益）。因此，名字叫作极小化极大。 极小化极大算法的最大劣势是，需要扩展整个博弈树。对于分支因子较高的博弈（例如围棋或者国际象棋），这会导致庞大的博弈树从而失败。 UCT算法——树的置信上限(UCB for Trees) Upper Confidence Bounds(置信上限) UCT是一个让我们从已访问的节点中选择下一个节点来进行遍历的函数，也是MCTS的核心函数。 UCT(vi,v)=Q(vi)N(vi)+clog⁡(N(v))N(vi)UCT(v_{i}, v)=\\frac{Q(v_{i})}{N(v_{i})}+c \\sqrt{\\frac{\\log (N(v))}{N(v_{i})}} UCT(vi​,v)=N(vi​)Q(vi​)​+cN(vi​)log(N(v))​​ exploitation component(利用) 第一部分是undefined​ ，也称作exploitation component 可以看做是子节点Vi的胜率估计（总收益/总次数=平均每次的收益）。但是不能只选择胜率高的下一步，因为这种贪婪方式的搜索会很快导致游戏结束，这往往会导致搜索不充分，错过最优解。 举个简单的例子。现在假设MCTS的UCT函数只用了探索成分，从根节点开始，我们对所有子节点进行了一次模拟，然后在下一步中只访问至少赢了一次的子节点。那么在第一次模拟中那些不幸未被选中的节点（实际中rollout策略函数通常是随机的）将会被立刻抛弃 exploration component(探索) c \\sqrt{\\frac{\\log(N(v))}{N(v_{i})}}$$，这个成分更倾向于那些想对较少被探索的节点N(Vi)小。 参数c是exploitation和exploration之间的折中系数。 ### MCTS的终止 终止条件(or)： - 达到一定的迭代次数 - 达到规定的搜索时间 当MSCT程序结束时，最佳的移动通常是访问次数最多的那个节点，也是UCT最大的点。 ## 参考: [深度学习入门：AlphaGo Zero蒙特卡洛树搜索](https://blog.csdn.net/mergerly/article/details/83788862) [蒙特卡洛树搜索（MCTS）算法-计算过程](https://blog.csdn.net/ljyt2/article/details/78332802) [【MCTS】Youtube上迄今为止最好的蒙特卡罗树搜索讲解](https://www.bilibili.com/video/av67847675?from=search&amp;seid=7487786042631726209) ## 实现: [python实现的基于蒙特卡洛树搜索(MCTS)与UCB的五子棋游戏](https://blog.csdn.net/white_gl/article/details/56521880) [mctspy：蒙特卡洛树搜索算法的python实现](https://github.com/int8/monte-carlo-tree-search)","categories":[],"tags":[{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"Python多进程","slug":"Python多进程","date":"2019-10-06T12:17:44.000Z","updated":"2019-10-07T04:15:31.316Z","comments":true,"path":"2019/10/06/Python多进程/","link":"","permalink":"https://nymrli.top/2019/10/06/Python多进程/","excerpt":"","text":"Python多进程 守护进程 守护进程其实就是**“子进程“是否伴随主进程一起结束**:守护==&gt;伴随，即守护进程会伴随主进程的代码运行完毕后而死掉 进程：当父进程需要将一个任务并发出去执行，需要将该任务放到以个子进程里 守护：当该子进程内的代码在父进程代码运行完毕后就没有存在的意义了，就应该 将该子进程设置为守护进程，会在父进程代码结束后死掉 1234567891011121314151617181920212223from multiprocessing import Processimport timedef foo(): print(123) time.sleep(1) print(\"end123\")def bar(): print(456) time.sleep(3) print(\"end456\")if __name__ == '__main__': p1=Process(target=foo) p2=Process(target=bar) # 将子进程p1设置为守护进程，守护进程要放在进程start之前 # 所以p1会在print(\"main-------\")打印完成后死掉，所以p1进程不会打印 p1.daemon=True p1.start() p2.start() # time.sleep(1) print(\"main-------\") 进程锁 主要使用multiprocessing下的Lock对象 就是将要执行任务的部门代码（只涉及到修改共享数据的代码）变成串行，作用是让进程不乱掉，下面代码就是可以避免 i 乱打印 12345678910111213from multiprocessing import Process, Lock def f(l, i): l.acquire() #锁住进程 try: print('hello world', i) finally: l.release() #释放锁 if __name__ == '__main__': lock = Lock() for num in range(10): Process(target=f, args=(lock, num)).start() （理解为用锁来限制，同一时间只能让一个人拿着锁去改数据，先抢到锁的人 就有优先购买的权限） 1234# 主要就是用的这三个lock = lock()lock.acquire() # 拿钥匙，开门lock.release() #还钥匙，关门 抢票demo 写法一 1234567891011121314151617181920212223242526272829303132333435363738394041#模拟抢票软件的原理：from multiprocessing import Lock,Processimport json,os,time,randomdef check(): #查票功能实现并行访问 time.sleep(1) with open('db.txt','rt',encoding='utf-8') as f: dic=json.load(f) print('%s 查看余票数为 %s'%(os.getpid(),dic['count']))def get(): #购票因为牵涉到对后台数据的修改，所以加互斥锁目的是逐一进行访问修改，以免数据错乱 with open('db.txt', 'rt',encoding='utf-8') as f: dic = json.load(f) time.sleep(2) if dic['count'] &gt;0: #有票 dic['count']-=1 time.sleep(random.randint(1, 3)) #在购票时，模拟网络延迟... with open('db.txt', 'wt',encoding='utf-8') as f: json.dump(dic,f) print('%s 购票成功'%os.getpid()) else: print('%s 没有余票'%os.getpid())def task(mutex): #查看（并行访问） check() #抢票（加入互斥锁，实现串行访问，先到先得原则） mutex.acquire() get() mutex.release() #第一个购买完成后，解锁，后续进入继续购买if __name__ == '__main__': mutex=Lock() #调用Lock类拿到一个对象 for i in range(10): p=Process(target=task,args=(mutex,)) p.start() 写法二: 123456789101112131415161718192021222324252627282930313233343536# 锁# 火车票import jsonimport timefrom multiprocessing import Processfrom multiprocessing import Lockdef show(i): with open('ticket') as f: dic = json.load(f) print('余票: %s'%dic['ticket'])def buy_ticket(i,lock): lock.acquire() #拿钥匙进门 with open('ticket') as f: dic = json.load(f) time.sleep(0.1) if dic['ticket'] &gt; 0 : dic['ticket'] -= 1 print('\\033[32m%s买到票了\\033[0m'%i) else: print('\\033[31m%s没买到票\\033[0m'%i) time.sleep(0.1) with open('ticket','w') as f: json.dump(dic,f) lock.release() # 还钥匙if __name__ == '__main__': for i in range(10): p = Process(target=show,args=(i,)) p.start() lock = Lock() for i in range(10): p = Process(target=buy_ticket, args=(i,lock)) p.start() 进程间的通信** 用一块儿共享的内存==&gt;实现进程间的共享 特点: 一定是内存空间 能够自动帮忙处理锁的问题 实现进程间的通讯（IPC）的方式有很多种，如：管道(Pipe)，消息队列(Queue: == PIPE+锁（队列）)，共享内存，信号，信号量，套接字 管道 消息队列 共享内存 开辟空间 内存 内存 内存 读写方式 两端读写[双向/单向] 先进先出 覆盖之前的内容 效率 一般 一般 较高 应用 多用于父子进程 广泛灵活 需要注意互斥 注意： 1.队列占用的是内存空间 2.不应该往队列中放大数据，应该只存放数据量较小的精简的内容 生产者消费者模型 生产者：比喻的是程序中负责产生数据的任务 消费者：比喻的是程序中负责处理数据的任务 生产者———&gt;共享的介质(队列)&lt;————消费者 Q:作用是什么? A: 实现生产者与消费者的解耦和，生产者可以不停的生产，消费者也可以不停的消费从而平衡了生产者的生产能力与消费者消费能力，提升了而整体运行的效率 Q:什么时候用? A:当我们程序中存在明显的两类任务，一类是负责产生数据，一类是负责处理数据，此时就应该考虑使用生产者消费者模型来提升程序的效率 多进程中的join() 在进程中可以阻塞主进程的执行, 直到等待子线程全部完成之后, 才继续运行主线程后面的代码 12345678910111213141516171819202122232425import threadingimport timedef test(num): time.sleep(1) print(num)#定义一个用来装子线程的列表threads = []for i in range(5): #target 指定子线程要执行的funtion, args 指定该funtion需要传入的参数 thread = threading.Thread(target = test, args = [i]) #上面的 thread 是一个个参数i都不同的线程, 现在把它一个个装进列表 threads 里面 threads.append(thread)for i in threads: #for 循环执行 threads 列表里面的全部线程, 没有用 join()线程是无序执行的, # 就连最后一句print('end')可能比所有子线程都要先执行 i.start()print('end')'''end41230''' 将其修改为 123456789101112for i in tsreads: i.start() i.join()'''01234end[Finished in 5.2s]''' 每个都会隔一秒的进行输出,因为for循环也是主进程操作,也会被阻塞直到子进程完成。 12345678910111213for i in tsreads: i.start()for i in threads: i.join()'''23104end[Finished in 1.2s]''' 在这里看一看出来, join()还是阻挡了主线程的执行, 让所有的子线程执行完毕之后再执行, 而且前面的子线程的执行都是无序地执行完毕了 △.一般来说，join函数应该在所有的start函数之后(即一般情况下，让所有进程都执行，然后等待子进程结束，再进行下面的主进程)。 Python多进程之Manager 可以用来进程间共享对象、资源、变量===&gt;使用公共内存 12345678910111213141516171819202122232425from multiprocessing import Process,Managerimport os# 这里实现的就是多个进程之间共享内存，并修改数据# 这里不需要加锁，因为manager已经默认给你加锁了def f(d,l): d[1] = '1' d['2'] = 2 d[0.25] = None l.append(os.getpid()) print(l)if __name__ == '__main__': with Manager() as manager: d = manager.dict() #生成一个字典 l = manager.list(range(5)) #生成一个列表 p_list = [] for i in range(10): p = Process(target=f,args=(d,l)) p.start() p_list.append(p) for res in p_list: res.join() print(d) print(l) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from multiprocessing import Process, Lock, Valuefrom multiprocessing.managers import BaseManagerclass Employee(object): def __init__(self, name, salary): self.name = name self.salary = Value('i', salary) self.data = [] def increase(self): self.salary.value += 100 self.data.append(self.salary.value) print(self.data) def getPay(self): return self.name + ':' + str(self.salary.value)class MyManager(BaseManager): ''' 继承即可 ''' passdef Manager(): m = MyManager() m.start() return mMyManager.register('Employee', Employee)def func(em, lock): with lock: em.increase()if __name__ == '__main__': manager = Manager() em = manager.Employee('zhangsan', 1000) lock = Lock() proces = [Process(target=func, args=(em, lock)) for i in range(10)] for p in proces: p.start() for p in proces: p.join() print(em.getPay())'''&gt;&gt;&gt;[1100][1100, 1200][1100, 1200, 1300][1100, 1200, 1300, 1400][1100, 1200, 1300, 1400, 1500][1100, 1200, 1300, 1400, 1500, 1600][1100, 1200, 1300, 1400, 1500, 1600, 1700][1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800][1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900][1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000]zhangsan:2000''' Queue 其实就是一个队列（FIFO），两个进程可以通过传入的参数q，来获得里面的内容，从而数据共享、通信。 123456789101112131415161718192021222324252627282930313233#导入Queue,Processfrom multiprocessing import Queue,Processimport os #写入进程def wp(q): print(\"%s开始写入：\"%os.getpid) for i in \"WANG\": #将信息写入队列 q.put(i) print(i) #读取进程def rd(q): print(\"%s开始读取\"%os.getpid()) while True: if not q.empty(): #从队列读取信息 print(\"read to %s\"%q.get()) if __name__==\"__main__\": #创建队列 q = Queue() #创建写入进程 w = Process(target=wp,args=(q,)) #启动写入进程 w.start() #创建读取进程 r = Process(target=rd,args=(q,)) #启动读取进程 r.start() Pipe管道 和队列的功能差不多，实现两个进程之间数据的传递，只不过是FILO的: 123456789101112131415'''管道pipe'''from multiprocessing import Process, Pipe def f(conn): conn.send('hello') #发送hello print(conn.recv()) #收到牛逼 conn.close() #关闭 if __name__ == '__main__': parent_conn, child_conn = Pipe() #管道会产生两个返回值 p = Process(target=f, args=(child_conn,)) #创建一个子进程 p.start() print(parent_conn.recv()) #收到'hello'\" parent_conn.send('牛逼') #发送牛逼 p.join() 借鉴: Python守护进程、进程互斥锁、进程间通信ICP（Queue队列）、生产者消费者模型 多进程 之 join() Java 多线程中两个线程交替执行 Python多进程消息队列实现进程间通讯 Queue详细内容","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Openmv使用","slug":"Openmv使用","date":"2019-10-06T01:45:28.000Z","updated":"2019-11-07T12:36:38.416Z","comments":true,"path":"2019/10/06/Openmv使用/","link":"","permalink":"https://nymrli.top/2019/10/06/Openmv使用/","excerpt":"","text":"Openmv使用 下载Openmv IDE Openmv官网 中国代理——星瞳 Github_release 推荐下载星瞳的，这个是中文版的，并且其他两个下载非常慢。 捕捉图片设置： 设置彩色／黑白 sensor.set_pixformat() 设置像素模式。 sensor.GRAYSCALE: 灰度，每个像素8bit。 sensor.RGB565: 彩色，每个像素16bit。 设置图像大小 sensor.set_framesize() 设置图像的大小 sensor.QQVGA: 160x120 sensor.QQVGA2: 128x160 (用于 lcd 扩展板) sensor.HQVGA: 240x160 sensor.QVGA: 320x240 sensor.VGA: 640x480 (只用于OpenMV Cam M7 的灰度图处理图像，或者彩图采集图像) sensor.QQCIF: 88x72 sensor.QCIF: 176x144 sensor.CIF: 352x288 设置窗口ROI sensor.set_windowing(roi) 设置翻转 sensor.set_hmirror(True) 水平方向翻转 sensor.set_vflip(True) 垂直方向翻转 Demo例程： openmv虽然比较贵,但是它的功能非常强大,已经提供了相当多的例程了。具体例程可以去星瞳的官网上查看，说明非常详细。 在此，我只介绍点我们这次需要用到的功能。 我使用的是OPENMV-H7 R1，芯片是STM32H743，镜头为IR 1080P 2.8mm Hello World 1234567891011121314151617# Hello World Example## Welcome to the OpenMV IDE! Click on the green run arrow button below to run the script!import sensor, image, timesensor.reset() # Reset and initialize the sensor.sensor.set_pixformat(sensor.RGB565) # Set pixel format to RGB565 (or GRAYSCALE)sensor.set_framesize(sensor.QVGA) # Set frame size to QVGA (320x240)sensor.skip_frames(time = 2000) # Wait for settings take effect.clock = time.clock() # Create a clock object to track the FPS.while(True): clock.tick() # Update the FPS clock. img = sensor.snapshot() # Take a picture and return the image. print(clock.fps()) # Note: OpenMV Cam runs about half as fast when connected # to the IDE. The FPS should increase once disconnected. 二维码识别 12345678910111213141516171819202122# QRCode Example## This example shows the power of the OpenMV Cam to detect QR Codes# using lens correction (see the qrcodes_with_lens_corr.py script for higher performance).import sensor, image, timesensor.reset()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QVGA)sensor.skip_frames(time = 2000)sensor.set_auto_gain(False) # must turn this off to prevent image washout...clock = time.clock()while(True): clock.tick() img = sensor.snapshot() img.lens_corr(1.8) # strength of 1.8 is good for the 2.8mm lens. for code in img.find_qrcodes(): img.draw_rectangle(code.rect(), color = (255, 0, 0)) print(code) print(clock.fps()) 代码是用python编写的，文件系统为microPython，具有Cpython解释器翻译成机器码。需要脱机运行的文件命名为main.py即可(具体详情见microPython规范)。可放于flash或者32GB以下的SD卡中，SD卡读取优先级高于Flash，且flash内容容易丢失，且擦写次数有限，建议使用SD卡。 主要需要用的库： sersor:通过这个对象可以控制摄像头及相关配置； image：处理图像的功能函数都在这个库里 sensor.snapshot()会返回一个&lt;class ‘Image’&gt; time：跟Python自带的time模块不同，这个是专门用来记录摄像头用时的 颜色追踪 颜色阈值需要使用LAB色彩空间 LAB的范围选择，个人比较快截的方法是通过IDE右边的帧缓冲区来获取，即框出ROI区域后，再打开“工具-&gt;机器视觉-&gt;阈值编辑器-&gt;帧缓冲区”,然后根据直方图中的数据就可以筛选出想要的对象辣(白色是选出，黑色是过滤，好像跟PS的蒙版是反的?) ▲颜色识别时，一定要关闭自动增益、白平衡 sensor.set_auto_gain() 自动增益开启（True）或者关闭（False）。在使用颜色追踪时，需要关闭自动增益。 sensor.set_auto_whitebal() 自动白平衡开启（True）或者关闭（False）。在使用颜色追踪时，需要关闭自动白平衡。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Measure the distance## This example shows off how to measure the distance through the size in imgage# This example in particular looks for yellow pingpong ball.import sensor, image, time, lcd# For color tracking to work really well you should ideally be in a very, very,# very, controlled enviroment where the lighting is constant...#yellow_threshold = (22, 74, -12, 31, 23, 62)box_threshold = (40, 80, -4, 21, 14, 51)red_threshold = (40, 59, 61, 84, 30, 79)# You may need to tweak the above settings for tracking green things...# Select an area in the Framebuffer to copy the color settings.sensor.reset() # Initialize the camera sensor.sensor.set_pixformat(sensor.RGB565) # use RGB565.sensor.set_framesize(sensor.QVGA) # use QQVGA for speed.sensor.skip_frames(10) # Let new settings take affect.sensor.set_auto_whitebal(False) # turn this off.clock = time.clock() # Tracks FPS.#lcd.init() # Initialize the lcd screen.K=5000#the value should be measuredwhile(True): clock.tick() # Track elapsed milliseconds between snapshots(). img = sensor.snapshot() # Take a picture and return the image. blobs = img.find_blobs([red_threshold]) if len(blobs) == 1: # Draw a rect around the blob. #b = blobs[0] #img.draw_rectangle(b[0:4]) # rect #img.draw_cross(b[5], b[6]) # cx, cy #Lm = (b[2]+b[3])/2 #length = K/Lm #print(length) b = blobs[0] img.draw_rectangle(b[0:4]) img.draw_cross(b[5], b[6]) #lcd.display(sensor.snapshot()) # Take a picture and display the image. #print(clock.fps()) # Note: Your OpenMV Cam runs about half as fast while # connected to your computer. The FPS should increase once disconnected. 识别圆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 圆形检测例程## 这个例子展示了如何用Hough变换在图像中找到圆。# https://en.wikipedia.org/wiki/Circle_Hough_Transform## 请注意，find_circles（）方法将只能找到完全在图像内部的圆。圈子之外的# 图像/ roi被忽略...import sensor, image, timesensor.reset()sensor.set_pixformat(sensor.RGB565) # grayscale is fastersensor.set_framesize(sensor.QQVGA)sensor.skip_frames(time = 2000)clock = time.clock()while(True): clock.tick() #lens_corr(1.8)畸变矫正 img = sensor.snapshot().lens_corr(1.8) # Circle对象有四个值: x, y, r (半径), 和 magnitude。 # magnitude是检测圆的强度。越高越好 # roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， # ROI 即图像矩形。操作范围仅限于roi区域内的像素。 # x_stride 是霍夫变换时需要跳过的x像素的数量。若已知圆较大，可增加 # x_stride 。 # y_stride 是霍夫变换时需要跳过的y像素的数量。若已知直线较大，可增加 # y_stride 。 # threshold 控制从霍夫变换中监测到的圆。只返回大于或等于阈值的圆。 # 应用程序的阈值正确值取决于图像。注意：一条圆的大小是组成圆所有 # 索贝尔滤波像素大小的总和。 # x_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 # r_margin的部分合并。 # y_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 # r_margin 的部分合并。 # r_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 # r_margin 的部分合并。 # r_min，r_max和r_step控制测试圆的半径。 # 缩小测试圆半径的数量可以大大提升性能。 # threshold = 3500比较合适。如果视野中检测到的圆过多，请增大阈值； # 相反，如果视野中检测到的圆过少，请减少阈值。 for c in img.find_circles(threshold = 3500, x_margin = 10, y_margin = 10, r_margin = 10,r_min = 2, r_max = 100, r_step = 2):# (80,60,80,60) img.draw_circle(c.x(), c.y(), c.r(), color = (255, 0, 0)) print(c) for r in img.find_rects(threshold = 3500): img.draw_rectangle(r.rect(), color=(255,0,0)) for p in r.corners(): img.draw_circle(p[0], p[1], 5, color=(0,255,0)) print(r) print(\"FPS %f\" % clock.fps()) 测距和测量物块大小 由于 OpenMV采用的是单目摄像头，想要实现测距，就需要选参照物，利用参照物的大小比例来计算距离。 Len∝1pixelconutLen ∝ \\frac{1}{pixelconut}Len∝pixelconut1​&gt;dist=Cpixeldist = \\frac{C}{pixel}dist=pixelC​实际长度和摄像头里的像素成反比 **&gt;** 距离 = 一个常数/直径的像素 先测出这个常数的值，怎么测不用说了吧，就是先让球距离摄像头10cm，打印出摄像头里直径的像素值，然后相乘，就得到了k的值！ 就可以算出距离了(=这个常数/摄像头里像素点数) 12345678910111213141516171819202122232425262728293031323334353637383940414243# Measure the distance## This example shows off how to measure the distance through the size in imgage# This example in particular looks for yellow pingpong ball.import sensor, image, time# For color tracking to work really well you should ideally be in a very, very,# very, controlled enviroment where the lighting is constant...yellow_threshold = ( 56, 83, 5, 57, 63, 80)# box_threshold = (40, 80, -4, 21, 14, 51)# red_threshold = (40, 59, 61, 84, 30, 79)# You may need to tweak the above settings for tracking green things...# Select an area in the Framebuffer to copy the color settings.sensor.reset() # Initialize the camera sensor.sensor.set_pixformat(sensor.RGB565) # use RGB565.sensor.set_framesize(sensor.QQVGA) # use QQVGA for speed.sensor.skip_frames(10) # Let new settings take affect.sensor.set_auto_whitebal(False) # turn this off.clock = time.clock() # Tracks FPS.K=5000#the value should be measured# K = 36*10while(True): clock.tick() # Track elapsed milliseconds between snapshots(). img = sensor.snapshot() # Take a picture and return the image. blobs = img.find_blobs([yellow_threshold]) if len(blobs) == 1: # Draw a rect around the blob. b = blobs[0] img.draw_rectangle(b[0:4]) # rect img.draw_cross(b[5], b[6]) # cx, cy Lm = (b[2]+b[3])/2 # 像素点数 # index 2 is length, 3 is width length = K/Lm # 距离 print(length) #print(clock.fps()) # Note: Your OpenMV Cam runs about half as fast while # connected to your computer. The FPS should increase once disconnected. LCD显示 由于正好有个LCD显示屏，那就也记录下LCD的代码把 123456789101112131415# LCD Example## Note: To run this example you will need a LCD Shield for your OpenMV Cam.## The LCD Shield allows you to view your OpenMV Cam's frame buffer on the go.import sensor, image, lcdsensor.reset() # Initialize the camera sensor.sensor.set_pixformat(sensor.RGB565) # or sensor.GRAYSCALEsensor.set_framesize(sensor.QQVGA2) # Special 128x160 framesize for LCD Shield.lcd.init() # Initialize the lcd screen.while(True): lcd.display(sensor.snapshot()) # Take a picture and display the image. 串口通信 12345678910111213141516171819202122# UART Control## This example shows how to use the serial port on your OpenMV Cam. Attach pin# P4 to the serial input of a serial LCD screen to see \"Hello World!\" printed# on the serial LCD display.import timefrom pyb import UART# Always pass UART 3 for the UART number for your OpenMV Cam.# The second argument is the UART baud rate. For a more advanced UART control# example see the BLE-Shield driver.uart = UART(3, 19200)while(True): # 发送数据 uart.write(\"Hello World!\\r\") time.sleep(1000) # 接收数据 if uart.any(): a=uart.readline() print(a) 与STM32通信 openmv 1234567891011121314import time,sensor, imagefrom pyb import UARTuart = UART(3, 115200)uart.init(115200, bits=8, parity=None, stop=1)while(True): # 由于正点原子提供的串口通信协议需要以\\r\\n结尾,所以,这边必须也要写\\r\\n uart.write(\"Hello World!\\r\\n\") # 中文好像解析不了 if uart.any(): a=uart.readline() print(a) main.c 123456789101112131415161718192021222324252627282930313233#include \"led.h\"#include \"delay.h\"#include \"key.h\"#include \"sys.h\"#include \"usart.h\"int main(void)&#123; u16 t; u16 len; u16 times=0; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 KEY_Init(); //初始化与按键连接的硬件接口 while(1)&#123; if(USART_RX_STA&amp;0x8000)&#123; len=USART_RX_STA&amp;0x3fff;//得到此次接收到的数据长度 printf(\"Your message is:\\r\\n\\r\\n\"); for(t=0;t&lt;len;t++)&#123; USART_SendData(USART1, USART_RX_BUF[t]);//向串口1发送数据 while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);//等待发送结束 &#125; //printf(\"\\r\\n\\r\\n\");//插入换行 USART_RX_STA=0; &#125;else&#123; times++; if(times%200==0) printf(\"Waiting for input.2333\\r\\n\"); if(times%30==0)LED0=!LED0;//闪烁LED,提示系统正在运行. delay_ms(10); &#125; &#125; &#125; 测试结果（暂时还没理解）： 补充: openmv 发送16进制数 附录: OpenMV中文入门教程 视频教程: B站OpenMV视频教程 星瞳官网 B站的清晰度和加载速度比较快，星瞳官网的还有额外的教程（他家的拓展版） 画图： 12image.draw_line((10,10,20,30), color=(255,0,0))image.draw_rectangle(rect_tuple, color=(255,0,0)) 画线 image.draw_line(line_tuple, color=White) 在图像中画一条直线。 line_tuple的格式是(x0, y0, x1, y1)，意思是(x0, y0)到(x1, y1)的直线。 颜色可以是灰度值(0-255)，或者是彩色值(r, g, b)的tupple。默认是白色 画框 image.draw_rectangle(rect_tuple, color=White) 在图像中画一个矩形框。 rect_tuple 的格式是 (x, y, w, h)。 画圆 image.draw_circle(x, y, radius, color=White) 在图像中画一个圆。 x,y是圆心坐标 radius是圆的半径 画十字 image.draw_cross(x, y, size=5, color=White) 在图像中画一个十字 x,y是坐标 size是两侧的尺寸 写字 image.draw_string(x, y, text, color=White) 在图像中写字 8x10的像素 x,y是坐标。使用\\n, \\r, and \\r\\n会使光标移动到下一行。 text是要写的字符串。 需要调参的地方： 测大小的常数k 形状检测的阈值 颜色识别的阈值","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://nymrli.top/tags/嵌入式/"}]},{"title":"TD-afterstate","slug":"TD-afterstate","date":"2019-10-03T11:28:36.000Z","updated":"2019-10-03T11:30:03.963Z","comments":true,"path":"2019/10/03/TD-afterstate/","link":"","permalink":"https://nymrli.top/2019/10/03/TD-afterstate/","excerpt":"","text":"TD-afterstate afterstae: 当前执行一个动作后的状态，可以理解为中间态 是处理问题的一个改动,一种思想 以俄罗斯方块为例: 状态是由当前的局面和一个随机方块组成，执行一个下落动作之后会产生一个局面就称为afterstate，即动作结束后不能进行新的动作（没有新方块）的状态。 中间态和下一个随机方块构成了下一个状态 对于没有这种随机性的问题，afterstate就是next state td做预测，afterstate做控制 更多: 强化学习经典入门书的读书笔记系列–第六篇Temporal-Difference","categories":[],"tags":[{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"git命令详解","slug":"git命令详解","date":"2019-09-29T09:39:07.000Z","updated":"2019-12-12T10:59:20.655Z","comments":true,"path":"2019/09/29/git命令详解/","link":"","permalink":"https://nymrli.top/2019/09/29/git命令详解/","excerpt":"","text":"git命令详解 自己的仓库管理： git add &lt;filename&gt; 将文件添加到暂存区中 (其中git add.可以将当前目录的子目录文件都添加到暂存区中) git commit -m &quot;...&quot;: 保存仓库的历史记录,其中 -m &quot;…&quot;提交信息(概述) git config --global user.name &quot;...&quot;、git config --global user.email &quot;...&quot;: 配置提交作者信息 git log: 查看提交日志(当前状态为终点) 会产生版本库里一系列单独提交的历史 git diff ID1/ID2: 查看版本差异 git mv 新名字,旧名字 重命名: git branch -a [-v] 分支一展表, -r 查看远程git服务器上的分支 git checkout 分支名: 切换分支 -b创建,且切换到新建分支 等价于git branch 分支名 + git checkout 分支名 git branch -d [分支名称] 删除一个分支, -d选项只能删除已经参与过合并的分支，对于未参与合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项、 git rest --head ID : 退回之前提交版本 git status : 查看仓库当前状态； git reflog : 查看当前仓库的操作日志 git rebase -i: 压缩历史(如果出现拼写错误时需要): git rebase -i HEAD~2 git merge --no-f 分支名 : 合并分支 git remote set-url origin https://github.com/Freedomisgood/NjuptGo.git 修改仓库指定新的远程仓库 git commit --amend: 修改上次commit备注信息 远程仓库 如果本地没有仓库，则clone: git clone http://github.com/xxx/yyy.git 在本地增加远程仓库信息：git remote add apollo3d http://github.com/xxx/yyy.git,此时远程库名为origin、apollo3d 删除远程分支git push origin --delete kickof git push代码到远程新分支 git push origin master:my_remote_new_branch git pull 如果本地有仓库，则拉取更新命令为: git pull &lt;远程库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 比如，取回远程库中的online分支，与本地的online分支进行merge，要写成： git pull origin online:online 如果是要与本地当前分支merge，则冒号后面的&lt;本地分支名&gt;可以不写 git pull origin online 通常，git会将本地库分支与远程分支之间建立一种追踪关系。比如，在git clone的时候，所有本地分支默认与远程库的同名分支建立追踪关系。也就是说，本地的master分支自动追踪origin/master分支。因此，如果当前处于本地online分支上，并且本地online分支与远程的online分支有追踪关系，那么远程的分支名可以省略： 比如，取回远程库中的online分支，与本地的online分支进行merge，要写成： git pull origin 其实，git pull 命令等同于先做了git fetch ，再做了git merge。即： 123git fetch origin onlinegit checkout onlinegit merge origin/online git push 二.推送本地分支到远程仓库 （一）.创建本地分支git checkout -b 新分支名 （二）.推送本地分支到远程仓库git push --set-upstream origin 分支名 三、将远程git仓库里的指定分支拉取到本地（本地不存在的分支） git checkout -b 本地分支名 origin/远程分支名 修改了.gitignore生效指令 123git rm -r --cached . // 删除本地缓存git add . // 添加要提交的文件git commit -m &apos;update .gitignore&apos; // 更新本地的缓存 参考 Git远程操作详解:http://www.ruanyifeng.com/blog/2014/06/git_remote.html 使用git将项目上传到github（最简单方法）:https://www.cnblogs.com/cxk1995/p/5800196.html &lt;&lt;Git入门与实践&gt;&gt;:日本 Git恢复之前版本的两种方法reset、revert（图文详解） 采坑记录 Q: 不小心git reset --hard HEAD^导致工作区文件全没了 A:解决方案: Undo git reset --hard with uncommitted files in the staging area 恢复git reset --hard删除的文件 根据这篇博客操作的结果git cat-file -p ID &gt; a.md是个对比文件 1234567891011100644 blob cdca566953e3b7b56897b2fa6995129170403212 Q-learning.ipynb100644 blob 47735fcc505315aa61583dad9dc4facb7c00fbdc Q-learning.py100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 __init__.py040000 tree db76babbe2f2df4566b607e732c0c835418f9a83 __pycache__100644 blob debb716313cfbf28c055e89ce4a625a1d7801f5b agents.py100644 blob 30ec43da68efe5eb5e8e31cb431fea981e256b6a approximator.py100644 blob 1e8ac820d62943d16fa56fa981d72e27239527d9 core.py100644 blob a0cfa7ac7f9f15a658ace5c5c7c5bbe73f680502 myringworld.py100644 blob 69cb25ba30f4350454a0e731a70890cbf2530217 ringworld.py100644 blob 5638e012cb1b68783e6cdf45d2e769cca96e591f utils.py100644 blob 96aa662c03d991487e6da8120884b6f647be7202 viewer.py △.关于git reset --hard导致文件丢失的血的教训——亲测有效 解决add了但没有commit的文件，可以用上述方法找回 12341. 执行 git fsck --lost-found；2. 在.git/lost-found目录下找找看有没有你丢失的文件；3.有的话复制出来，如果是文本，直接改成正确扩展名，你就笑了；4. 没有的话，就再去Google吧； 分支git branch参数区别","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"numpy使用记录","slug":"numpy使用记录","date":"2019-09-28T03:13:29.000Z","updated":"2019-11-27T03:36:08.072Z","comments":true,"path":"2019/09/28/numpy使用记录/","link":"","permalink":"https://nymrli.top/2019/09/28/numpy使用记录/","excerpt":"","text":"Numpy使用记录 numpy中的random numpy.random.choice(a, size=None, replace=True, p=None) a : 如果是一维数组，就表示从这个一维数组中随机采样；如果是int型，就表示从0到a-1这个序列中随机采样。 size : 采样结果的数量，默认为1.可以是整数，表示要采样的数量；也可以为tuple，如(m, n, k)，则要采样的数量为m * n * k，size为(m, n, k) replace : boolean型，采样的样本是否要更换？这个地方我不太理解，测了一下发现replace指定为True时，采样的元素会有重复；当replace指定为False时，采样不会重复。 p : 一个一维数组，制定了a中每个元素采样的概率，若为默认的None，则a中每个元素被采样的概率相同。 12345678choice(a[, size, replace, p])&gt;&gt;&gt; np.random.choice(5, 3, replace=False)array([3,1,0])&gt;&gt;&gt; #This is equivalent to np.random.permutation(np.arange(5))[:3]# Generate a non-uniform random sample from np.arange(5) of size 3 without replacement:&gt;&gt;&gt; np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])array([2, 3, 0]) np.random.randint 123np.random.randint(2,5,size=(2,3))# 函数原型randint(low[, high, size])# - 返回随机的整数，位于半开区间 [low, high)。 np.random.rand 12345&gt;&gt;&gt; np.random.rand(3,2)array([[ 0.14022471, 0.96360618], #random [ 0.37601032, 0.25528411], #random [ 0.49313049, 0.94909878]]) #random# 跟random_sample([size])、random([size])和ranf([size])一样 array操作 广播啥的就不介绍了，主要是介绍一点函数方法的使用 array、asarray、asanyarray 1234567891011121314151617a = np.array([1,2,3])print(a)&gt;&gt;&gt;[1 2 3]c = np.array(a)c[1]=3print(a,c)&gt;&gt;&gt;[1 2 3] [1 3 3]b = np.asarray(a)b[1]=3print(a,b)&gt;&gt;&gt;[1 3 3] [1 3 3]# array和asarray的不同在于array对目标做一个拷贝，而asarray不会 np.asanyarray 会返回 ndarray 或者ndarray的子类，而np.asarray 只返回 ndarray. np.where(cond,x,y)：满足条件（cond）输出x，不满足输出y 这个函数非常有用，非常香，但是他的参数需要narray 降维 1234567891011a = np.array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]])# 法一：ravelprint(a.ravel())# 法二：flattenprint(a.flatten())# 法三：reshape([1,-1])print(a.reshape([1,-1])) ▲参数-1讲解：一个参数为-1时，那么reshape函数会根据另一个参数的维度计算出数组的另外一个shape属性值 […]语法简单使用 在切片中...跟:的效果是一样的，都是缺省默认取所有的意思 123# 两者等价print(a[:,2])print(a[...,2])","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"}]},{"title":"Python random","slug":"Python-random","date":"2019-09-27T14:11:59.000Z","updated":"2019-09-29T09:01:11.576Z","comments":true,"path":"2019/09/27/Python-random/","link":"","permalink":"https://nymrli.top/2019/09/27/Python-random/","excerpt":"","text":"Python random 老是忘记random中每个函数之间的区别，而且常常跟numpy里的random也经常搞混，因此还是写篇文章记一下吧。 random模块 choice和sample python中random.choice()可以从给定的可迭代对象中随机挑选出一个。 而python中random.sample()方法则可以随机地从给定的可迭代对象中提取出N个不同的元素，列表的维数没有限制。（即第二参数给出个数N） 1234567891011import randomprint(random.sample([chr(97 + x) for x in range(int(9))],2))# 函数原型sample(self, population, k)&gt;&gt;&gt; ['e', 'c']# ---print( random.randint(1,10) ) # 产生 1 到 10 的一个整数型随机数 print( random.random() ) # 产生 0 到 1 之间的随机浮点数print( random.uniform(1.1,5.4) ) # 产生 1.1 到 5.4 之间的随机浮点数，区间可以不是整数print( random.choice('tomorrow') ) # 从序列中随机选取一个元素# 函数原型def choice(self, seq)print( random.randrange(1,100,2) ) # 生成从1到100的间隔为2的随机整数 shuffle 正如字面所示，也就是打乱的意思 1234a=[1,3,5,6,7] # 将序列a中的元素顺序打乱random.shuffle(a)print(a)&gt;&gt;&gt; [1, 6, 7, 3, 5] numpy中的random numpy.random.choice(a, size=None, replace=True, p=None) a : 如果是一维数组，就表示从这个一维数组中随机采样；如果是int型，就表示从0到a-1这个序列中随机采样。 size : 采样结果的数量，默认为1.可以是整数，表示要采样的数量；也可以为tuple，如(m, n, k)，则要采样的数量为m * n * k，size为(m, n, k) replace : boolean型，采样的样本是否要更换？这个地方我不太理解，测了一下发现replace指定为True时，采样的元素会有重复；当replace指定为False时，采样不会重复。 p : 一个一维数组，制定了a中每个元素采样的概率，若为默认的None，则a中每个元素被采样的概率相同。 12345678choice(a[, size, replace, p])&gt;&gt;&gt; np.random.choice(5, 3, replace=False)array([3,1,0])&gt;&gt;&gt; #This is equivalent to np.random.permutation(np.arange(5))[:3]# Generate a non-uniform random sample from np.arange(5) of size 3 without replacement:&gt;&gt;&gt; np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])array([2, 3, 0]) np.random.randint 123np.random.randint(2,5,size=(2,3))# 函数原型randint(low[, high, size])# - 返回随机的整数，位于半开区间 [low, high)。 np.random.rand 12345&gt;&gt;&gt; np.random.rand(3,2)array([[ 0.14022471, 0.96360618], #random [ 0.37601032, 0.25528411], #random [ 0.49313049, 0.94909878]]) #random# 跟random_sample([size])、random([size])和ranf([size])一样 ▲需要注意的是np.random.randint和random.randint的区间不同，前者左闭右开()，后者左右都是闭区间[]▲","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"OpenAI Gym使用、rendering画图","slug":"OpenAI-Gym使用","date":"2019-09-26T09:53:27.000Z","updated":"2019-10-07T10:01:00.137Z","comments":true,"path":"2019/09/26/OpenAI-Gym使用/","link":"","permalink":"https://nymrli.top/2019/09/26/OpenAI-Gym使用/","excerpt":"","text":"OpenAI Gym使用、rendering画图 gym开源库：包含一个测试问题集，每个问题成为环境（environment），可以用于自己的RL算法开发。这些环境有共享的接口，允许用户设计通用的算法。其包含了deep mind 使用的Atari游戏测试床。 在强化学习中有2个基本概念，一个是环境（environment），称为外部世界，另一个为智能体agent（写的算法）。agent发送action至environment，environment返回观察和回报。 Gym官方文档 Hello gym 123456789import gym# 创建一个小车倒立摆模型env = gym.make(‘CartPole-v0’)# 初始化环境env.reset()# 刷新当前环境，并显示for _ in range(1000): env.render() env.step(env.action_space.sample()) # take a random action 设计理念图,一个环境的step函数返回需要的信息，有4种返回值 observation reward done :判断是否到了重新设定(reset)环境 info :用于调试的诊断信息，有时也用于学习，但智能体（agent ）在正式的评价中不允许使用该信息进行学习。 该进程通过调用reset()来启动，它返回一个初始observation。 所以之前代码的更恰当的方法是遵守done的标志： 空间（Spaces） 在上面的例子中，已经从环境的动作空间中抽取随机动作。但这些行动究竟是什么呢？ 每个环境都带有action_space 和observation_space对象。这些属性是Space类型，它们描述格式化的有效的行动和观察。 1234567import gymenv = gym.make('CartPole-v0')# 离散空间允许固定范围的非负数，因此在这种情况下，有效的动作是0或1. print(env.action_space)#&gt; Discrete(2)print(env.observation_space)#&gt; Box(4,) Box空间表示一个n维box，所以有效的观察将是4个数字的数组。 也可以检查Box的范围： 1234print(env.observation_space.high)#&gt; array([ 2.4 , inf, 0.20943951, inf])print(env.observation_space.low)#&gt; array([-2.4 , -inf, -0.20943951, -inf]) 这种内省可以帮助编写适用于许多不同环境的通用代码。box和discrete是最常见的空间。你可以从一个空间中取样，或者检查某物是否属于它： 12345from gym import spacesspace = spaces.Discrete(8) # Set with 8 elements &#123;0, 1, 2, ..., 7&#125;x = space.sample()assert space.contains(x)assert space.n == 8 Env.render画图 参考Gym 简单画图 123456789101112131415161718192021222324252627282930313233# 首先，导入库文件（包括gym模块和gym中的渲染模块）import gymfrom gym.envs.classic_control import rendering# 我们生成一个类，该类继承 gym.Env. 同时，可以添加元数据，改变渲染环境时的参数class Test(gym.Env): # 如果你不想改参数，下面可以不用写 metadata = &#123; 'render.modes': ['human', 'rgb_array'], 'video.frames_per_second': 2 &#125;# 我们在初始函数中定义一个 viewer ，即画板 def __init__(self): self.viewer = rendering.Viewer(600, 400) # 600x400 是画板的长和框 # 继承Env render函数 def render(self, mode='human', close=False): # 下面就可以定义你要绘画的元素了 line1 = rendering.Line((100, 300), (500, 300)) line2 = rendering.Line((100, 200), (500, 200)) # 给元素添加颜色 line1.set_color(0, 0, 0) line2.set_color(0, 0, 0) # 把图形元素添加到画板中 self.viewer.add_geom(line1) self.viewer.add_geom(line2) return self.viewer.render(return_rgb_array=mode == 'rgb_array') # 最后运行if __name__ == '__main__': t = Test() while True: t.render() △.值得注意的是，画板的水平方向是 x 轴， 垂直方向是 y 轴， 且原点在左下角 画个圆 1234567891011def render(self, mode='human', close=False): # 画一个直径为 30 的园 circle = rendering.make_circle(30) # 添加一个平移操作 circle_transform = rendering.Transform(translation=(100, 200)) # 让圆添加平移这个属性, circle.add_attr(circle_transform) self.viewer.add_geom(circle) return self.viewer.render(return_rgb_array=mode == 'rgb_array') △注意.是圆心在平移 RingViewr 研究rings时写的render 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import gymfrom gym.envs.classic_control import renderingimport timeimport numpy as npimport randomclass ringViewer(rendering.Viewer): ''' 画板,直接继承自rendering.Viewer ''' def __init__(self,width, height, display=None): super(ringViewer, self).__init__(width, height, display=None) @staticmethod def pos2loc(pos=0): ''' 根据位置索引确定画图坐标 :param pos: 位置索引0-9 :return: loc ''' pass @staticmethod def getSize(size): ''' 设置画圆的半径 :param size:[0-2] :return: radius ''' pass @staticmethod def getColor(c=0): ''' 根据颜色索引选择圆圈颜色 :param c: :return: list ''' pass def drawNewring(self, newring:list=None): ''' 画新生成的圆 :param newring: :return: ''' for i in range(len(newring)): if newring[i] != 0: ring = rendering.make_circle(radius=self.getSize(i), res=50, filled=False) r, g, b = self.getColor(newring[i]) ring.set_color(r, g, b) ring_transform = rendering.Transform(translation=(150,30)) ring.add_attr(ring_transform) self.add_geom(ring) def _drawQG(self, qgs: list=None): ''' 画棋盘上各个棋格的圆圈 :param qgs: :return: None ''' for num,qg in enumerate(qgs): for i in range(len(qg)): if qg[i] != 0: ring = rendering.make_circle(radius=self.getSize(i), res = 50, filled=False) r, g, b = self.getColor(qg[i]) ring.set_color(r, g, b) ring_transform = rendering.Transform(translation=self.pos2loc(num)) ring.add_attr(ring_transform) self.add_geom(ring) def getQG(self, qg: list=None): ''' 将len=27的list转换为[[],[],...] :param qg: (27,1)的list :return: (9,1)的list ''' qgs = [] for x in range(3): for y in range(3): tmp = [] for z in range(3): tmp.append(qg[9*x+3*y+z]) qgs.append(tmp) self._drawQG(qgs)class Testenv(gym.Env): # 如果你不想改参数，下面可以不用写 metadata = &#123; 'render.modes': ['human', 'rgb_array'], 'video.frames_per_second': 2 &#125; def __init__(self): self.viewer = ringViewer(300, 400) # 600x400 是画板的长和框 self.state:list = [] self.state:list = [] def setState(self, state): self.state = state def setNewring(self, newring=None): self.newring = newring def render(self, mode='human', close=False): # 由于没有找到viewer源码中删除组件的代码,于是每次在渲染前 清空上一次geoms和onetime_geoms列表 来达到消除的目的 if self.state.any(): self.viewer.geoms.clear() self.viewer.onetime_geoms.clear() self.viewer.getQG(self.state) if self.newring: self.viewer.drawNewring(self.newring) return self.viewer.render(return_rgb_array=mode == 'rgb_array')if __name__ == '__main__': v = Testenv() while True: v.setState(np.random.randint(0,6,(27))) v.setNewring([random.randint(0,5) for x in range(3)]) print(v.state) print(v.newring) v.render() time.sleep(2) △.由于没有找到viewer源码中删除组件的代码,于是每次在渲染前 清空上一次geoms和onetime_geoms列表 来达到消除的目的 效果图如下 深入剖析gym环境构建[转] 由于该博客的代码展示实在太乱,于是重新帮他排版了一下 我们继续讲，从第1小节的尾巴开始。有三个重要的函数： env = gym.make(‘CartPole-v0’) env.reset() env.render() 第一个函数是创建环境，我们会在第3小节具体讲如何创建自己的环境，所以这个函数暂时不讲。第二个函数env.reset()和第三个函数env.render()是每个环境文件都包含的函数。我们以cartpole为例，对这两个函数进行讲解。 Cartpole的环境文件在~你的gym目录/gym/envs/classic_control/cartpole.py. 该文件定义了一个CartPoleEnv的环境类，该类的成员函数有：seed(), step(),reset()和render(). 第1小节调用的就是CartPoleEnv的两个成员函数reset()和render()。下面，我们先讲讲这两个函数，再介绍step()函数 2.1 reset()函数详解 reset()为重新初始化函数。那么这个函数有什么用呢？ 在强化学习算法中，智能体需要一次次地尝试，累积经验，然后从经验中学到好的动作。一次尝试我们称之为一条轨迹或一个episode. 每次尝试都要到达终止状态. 一次尝试结束后，智能体需要从头开始，这就需要智能体具有重新初始化的功能。函数reset()就是这个作用。 reset()的源代码为： 1234567def _reset() # 利用均匀随机分布初试化环境的状态 self.state = self.np_random.uniform(low=-0.05, high=0.05, size=(4,)) # 设置当前步数为None self.steps_beyond_done = None # 返回环境的初始化状态 return np.array(self.state) 2.2 render()函数详解 render()函数在这里扮演图像引擎的角色。一个仿真环境必不可少的两部分是物理引擎和图像引擎。物理引擎模拟环境中物体的运动规律；图像引擎用来显示环境中的物体图像。其实，对于强化学习算法，该函数可以没有。但是，为了便于直观显示当前环境中物体的状态，图像引擎还是有必要的。另外，加入图像引擎可以方便我们调试代码。下面具体介绍gym如何利用图像引擎来创建图像。 我们直接看源代码： 123456789101112131415from gym.envs.classic_control import rendering# 这一句导入rendering模块，利用rendering模块中的画图函数进行图形的绘制class myenv(gym.Env) def _render(self, mode=’human’, close=False): if close: pass #省略，直接看关键代码部分 if self.viewer is None: # 如绘制600*400的窗口函数为： self.viewer = rendering.Viewer(screen_width, screen_height) # 其中screen_width=600， screen_height=400 # 创建小车的代码为： l,r,t,b = -cartwidth/2, cartwidth/2, cartheight/2, -cartheight/2 axleoffset =cartheight/4.0 cart = rendering.FilledPolygon([(l,b), (l,t), (r,t), (r,b)]) # 其中rendering.FilledPolygon为填充一个矩形。 创建完cart的形状，接下来给cart添加平移属性和旋转属性。将车的位移设置到cart的平移属性中，cart就会根据系统的状态变化左右运动。具体代码解释，我已上传到github上面了，gxnk/reinforcement-learning-code 。想深入了解的同学可去下载学习。 2.3 step()函数详解 该函数在仿真器中扮演物理引擎的角色。其输入是动作a，输出是：下一步状态，立即回报，是否终止，调试项。 该函数描述了智能体与环境交互的所有信息，是环境文件中最重要的函数。在该函数中，一般利用智能体的运动学模型和动力学模型计算下一步的状态和立即回报，并判断是否达到终止状态。 我们直接看源代码： 12345678910111213141516def _step(self, action): assert self.action_space.contains(action), \"%r (%s) invalid\"%(action, type(action)) state = self.state x, x_dot, theta, theta_dot = state #系统的当前状态 force = self.force_mag if action==1 else -self.force_mag #输入动作，即作用到车上的力 costheta = math.cos(theta) #余弦函数 sintheta = math.sin(theta) #正弦函数 #底下是车摆的动力学方程式，即加速度与动作之间的关系。 temp = (force + self.polemass_length * theta_dot * theta_dot * sintheta) / self.total_mass thetaacc = (self.gravity * sintheta - costheta* temp) / (self.length * (4.0/3.0 - self.masspole * costheta * costheta / self.total_mass)) #摆的角加速度 xacc = temp - self.polemass_length * thetaacc * costheta / self.total_mass #小车的平移加速 x = x + self.tau * x_dot x_dot = x_dot + self.tau * xacc theta = theta + self.tau * theta_dot theta_dot = theta_dot + self.tau * thetaacc #积分求下一步的状态 self.state = (x,x_dot,theta,theta_dot) 2.4 一个简单的demo 下面，我给出一个最简单的demo，让大家体会一下上面三个函数如何使用。 1234567891011121314151617181920import gymimport timeenv = gym.make('CartPole-v0') #创造环境observation = env.reset() #初始化环境，observation为环境状态count = 0for t in range(100): action = env.action_space.sample() #随机采样动作 observation, reward, done, info = env.step(action) #与环境交互，获得下一步的时刻 if done: break env.render() #绘制场景 count+=1 time.sleep(0.2) #每次等待0.2s print(count) #打印该次尝试的步数 第3小节：创建自己的gym环境并利示例qlearning的方法 在上一小节中以cartpole为例子深入剖析了gym环境文件的重要组成。我们知道，一个gym环境最少的组成需要包括reset()函数和step()函数。当然，图像显示函数render()一般也是需要的。这一节，我会以机器人找金币为例给大家演示如何构建一个全新的gym环境，并以此环境为例，示例最经典的强化学习算法qlearning算法。在3.1节中，给出机器人找金币的问题陈述；第3.2节中，给出构建gym环境的过程；第3.3节中，利用qlearning方法实现机器人找金币的智能决策。全部代码已传到github上。 3.1 机器人找金币的问题陈述 图1.1 机器人找金币 如图1.1 为机器人在网格世界找金币的示意图。该网格世界一共有８个状态，其中状态６和状态8为死亡区域，状态７为金币区域。机器人的初始位置为网格世界中任意一个状态。机器人从初始状态出发寻找金币。机器人进行一次探索，进入死亡区域或找到金币，本次探测结束。机器人找到金币的回报为１，进入死亡区域回报为－１，机器人在区域１－５之间转换时，回报为０。我们的目标是找到一个策略使得机器人不管处在什么状态（１－５）都能找到金币。对于这个机器人找金币的游戏，我们可以利用强化学习的方法来实现。 构建网格世界的gym环境 该例子的代码,除了本篇博客有以外,OpenAI Gym构建自定义强化学习环境有更仔细和规范的代码贴出 一个gym的环境文件，其主体是个类，在这里我们定义类名为：GridEnv, 其初始化为环境的基本参数，因为机器人找金币的过程是一个马尔科夫过程，我们在强化学习入门课程的第一讲已经介绍过了一个马尔科夫过程应该包括状态空间，动作空间，回报函数，状态转移概率。因此，我们在类GridEnv的初始化时便给出了相应的定义。网格世界的全部代码在gxnk/reinforcement-learning-code,文件名为 grid_mdp.py. 我们看源代码： 12345678910111213141516171819202122# 状态空间为：self.states = [1,2,3,4,5,6,7,8]# 动作空间为： self.actions = ['n','e','s','w']# 回报函数为： self.rewards = dict(); #回报的数据结构为字典 self.rewards['1_s'] = -1.0 self.rewards['3_s'] = 1.0 self.rewards['5_s'] = -1.0# 状态转移概率为： self.t = dict(); #状态转移的数据格式为字典 self.t['1_s'] = 6 self.t['1_e'] = 2 self.t['2_w'] = 1 self.t['2_e'] = 3 self.t['3_s'] = 7 self.t['3_w'] = 2 self.t['3_e'] = 4 self.t['4_w'] = 3 self.t['4_e'] = 5 self.t['5_s'] = 8 self.t['5_w'] = 4 有了状态空间，动作空间和状态转移概率，我们便可以写step(a)函数了。这里特别注意的是，step()函数的输入是动作，输出为：下一个时刻的动作，回报，是否终止，调试信息。尤其需要注意的是输出的顺序不要弄错了。对于调试信息，可以为空，但不能缺少，否则会报错，常用{}来代替。我们看源代码： step函数的建立: 123456789101112131415161718192021def _step(self, action): #系统当前状态 state = self.state ＃判断系统当前状态是否为终止状态 if state in self.terminate_states: return state, 0, True, &#123;&#125; key = \"%d_%s\"%(state, action) #将状态和动作组成字典的键值 #状态转移 if key in self.t: next_state = self.t[key] else: next_state = state self.state = next_state is_terminal = False if next_state in self.terminate_states: is_terminal = True if key not in self.rewards: r = 0.0 else: r = self.rewards[key] return next_state, r,is_terminal,&#123;&#125; step()函数就是这么简单。下面我们重点介绍下如何写render()函数。从图1.1机器人找金币的示意图我们可以看到，网格世界是由一些线和圆组成的。因此，我们可以调用rendering中的画图函数来绘制这些图像。 render函数的建立: 整个图像是一个600*400的窗口，可用如下代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from gym.envs.classic_control import renderingself.viewer = rendering.Viewer(screen_width, screen_height)# 创建网格世界，一共包括11条直线，事先算好每条直线的起点和终点坐标，然后绘制这些直线，代码如下：#创建网格世界def render(self): self.line1 = rendering.Line((100,300),(500,300)) self.line2 = rendering.Line((100, 200), (500, 200)) self.line3 = rendering.Line((100, 300), (100, 100)) self.line4 = rendering.Line((180, 300), (180, 100)) self.line5 = rendering.Line((260, 300), (260, 100)) self.line6 = rendering.Line((340, 300), (340, 100)) self.line7 = rendering.Line((420, 300), (420, 100)) self.line8 = rendering.Line((500, 300), (500, 100)) self.line9 = rendering.Line((100, 100), (180, 100)) self.line10 = rendering.Line((260, 100), (340, 100)) self.line11 = rendering.Line((420, 100), (500, 100)) # 接下来，创建死亡区域，我们用黑色的圆圈代表死亡区域，源代码如下： # 创建第一个骷髅 self.kulo1 = rendering.make_circle(40) self.circletrans = rendering.Transform(translation=(140,150)) self.kulo1.add_attr(self.circletrans) self.kulo1.set_color(0,0,0) # 创建第二个骷髅 self.kulo2 = rendering.make_circle(40) self.circletrans = rendering.Transform(translation=(460, 150)) self.kulo2.add_attr(self.circletrans) self.kulo2.set_color(0, 0, 0) # 创建金币区域，用金色的圆来表示： # 创建金条 self.gold = rendering.make_circle(40) self.circletrans = rendering.Transform(translation=(300, 150)) self.gold.add_attr(self.circletrans) self.gold.set_color(1, 0.9, 0) # 创建机器人，我们依然用圆来表示机器人，为了跟死亡区域和金币区域不同，我们可以设置不同的颜色： # 创建机器人 self.robot= rendering.make_circle(30) self.robotrans = rendering.Transform() self.robot.add_attr(self.robotrans) self.robot.set_color(0.8, 0.6, 0.4) # 创建完之后，给11条直线设置颜色，并将这些创建的对象添加到几何中代码如下： self.line1.set_color(0, 0, 0) self.line2.set_color(0, 0, 0) self.line3.set_color(0, 0, 0) self.line4.set_color(0, 0, 0) self.line5.set_color(0, 0, 0) self.line6.set_color(0, 0, 0) self.line7.set_color(0, 0, 0) self.line8.set_color(0, 0, 0) self.line9.set_color(0, 0, 0) self.line10.set_color(0, 0, 0) self.line11.set_color(0, 0, 0) # 添加组件到Viewer中 self.viewer.add_geom(self.line1) self.viewer.add_geom(self.line2) self.viewer.add_geom(self.line3) self.viewer.add_geom(self.line4) self.viewer.add_geom(self.line5) self.viewer.add_geom(self.line6) self.viewer.add_geom(self.line7) self.viewer.add_geom(self.line8) self.viewer.add_geom(self.line9) self.viewer.add_geom(self.line10) self.viewer.add_geom(self.line11) self.viewer.add_geom(self.kulo1) self.viewer.add_geom(self.kulo2) self.viewer.add_geom(self.gold) self.viewer.add_geom(self.robot) # 接下来，开始设置机器人的位置。机器人的位置根据其当前所处的状态不同，所在的位置不同。我们事先计算出每个状态处机器人位置的中心坐标，并存储到两个向量中，并在类初始化中给出： self.x=[140,220,300,380,460,140,300,460] self.y=[250,250,250,250,250,150,150,150] # 根据这两个向量和机器人当前的状态，我们就可以设置机器人当前的圆心坐标了即： if self.state is None: return None self.robotrans.set_translation(self.x[self.state-1], self.y[self.state- 1]) # 最后还需要一个返回语句： return self.viewer.render(return_rgb_array=mode == 'rgb_array') 以上便完成了render()函数的建立 reset()函数的建立： reset()函数常常用随机的方法初始化机器人的状态，即： 123def _reset(self): self.state = self.states[int(random.random() * len(self.states))] return self.state 环境的注册 全部的代码请去github上下载学习。下面重点讲一讲如何将建好的环境进行注册，以便通过gym的标准形式进行调用。其实环境的注册很简单，只需要３步： 第一步：将我们自己的环境文件（我创建的文件名为grid_mdp.py)拷贝到你的gym安装目录/gym/gym/envs/classic_control文件夹中。（拷贝在这个文件夹中因为要使用rendering模块。当然，也有其他办法。该方法不唯一） 第二步：打开该文件夹（第一步中的文件夹）下的__init__.py文件，在文件末尾加入语句：from gym.envs.classic_control.grid_mdp import GridEnv 第三步：进入文件夹你的gym安装目录/gym/gym/envs，打开该文件夹下的__init__.py文件，添加代码： 12345678register( # gym.make(‘id’)时的id id='GridWorld-v0', # 函数路口 entry_point='gym.envs.classic_control:GridEnv', max_episode_steps=200, reward_threshold=100.0,) 第一个参数id就是你调用gym.make(‘id’)时的id, 这个id你可以随便选取，我取的，名字是GridWorld-v0 第二个参数就是函数路口了。 后面的参数原则上来说可以不必要写。 经过以上三步，就完成了注册。 下面，我们给个简单的demo来测试下我们的环境的效果吧： 我们依然写个终端程序： 12345import gymenv = gym.make('GridWorld-v0')env.reset()env.render()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"Linux安装selenium执行Python程序","slug":"Linux安装selenium执行Python程序","date":"2019-09-24T14:13:20.000Z","updated":"2020-11-21T03:34:25.149Z","comments":true,"path":"2019/09/24/Linux安装selenium执行Python程序/","link":"","permalink":"https://nymrli.top/2019/09/24/Linux安装selenium执行Python程序/","excerpt":"","text":"Linux安装selenium执行Python程序 配置python运行环境 安装selenium,pip install selenium 安装chrome 提供下载网站chromedownloads,下载google-chrome-stable_current_amd64-75.0.3770.80.deb 123456789101112$ sudo apt-get install libxss1 libappindicator1 libindicator7# 注意需要先把google-chrome-stable_current_amd64-75.0.3770.80.deb 下载下来$ sudo dpkg -i google-chrome-stable_current_amd64-75.0.3770.80.deb # 执行sudo dpkg -i google-chrome*.deb后报错的话，那就执行一下sudo apt-get install -f# 安装后在/usr/bin目录下查看是否有google-chrome文件# 检查chrome版本：$ google-chrome-stable --version# 当时无法查到版本,并报错error while loading shared libraries: libasound.so.2,# 输入sudo apt-get install -f后解决$ google-chrome-stable --version 安装chromedriver 123456789101112$ wget -N http://chromedriver.storage.googleapis.com/75.0.3770.8/chromedriver_linux64.zip$ unzip chromedriver_linux64.zip$ sudo chmod +x chromedriver$ sudo mv -f chromedriver /usr/local/share/chromedriver$ sudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriver$ sudo ln -s /usr/local/share/chromedriver /usr/bin/chromedrive$ chromedriver -v# 如果发现版本不对，chrome可以使用这样卸载：$ yum remove google-chrome# chromedriver可以直接删除目录：$ sudo rm -f /usr/bin/chromedriver 编写python测试代码 12345678from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument('--no-sandbox')chrome_options.add_argument('--disable-dev-shm-usage')chrome_options.add_argument('--headless')browser = webdriver.Chrome(chrome_options=chrome_options)browser.get('https://www.baidu.com/') 我使用的xshell会提示我转发, 因此需要在会话中关闭该属性: 属性-&gt;连接-&gt;SSH-&gt;隧道-&gt;取消&quot;转发X11连接到&quot;的勾选 报错记录: Message: unknown error: Chrome failed to start: exited abnormally (unknown error: DevToolsActivePort file doesn't exist) (The process started from chrome location /usr/bin/google-chrome is no longer running, so ChromeDriver is assuming that Chrome has crashed.) 解决方法：添加参数chrome_options.add_argument(’–no-sandbox’) 1234567chrome_options = Options()chrome_options.add_argument('--headless')chrome_options.add_argument('--no-sandbox')chrome_options.add_argument('user-agent=%s' % random.choice(MY_USER_AGENT_PC))driver = webdriver.Chrome(executable_path='/usr/local/bin/chromedriver', chrome_options=chrome_options)driver.set_window_size(1366, 1000) # 调整页面尺寸driver.implicitly_wait(3)","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"Ubuntu16.04+CUDA toolkit10.1+cudNN7.6+bazel0.26.1","slug":"Ubuntu16-04-CUDA-toolkit10-1-cudNN7-6-bazel0-26-1","date":"2019-09-23T08:38:55.000Z","updated":"2019-10-24T12:36:42.792Z","comments":true,"path":"2019/09/23/Ubuntu16-04-CUDA-toolkit10-1-cudNN7-6-bazel0-26-1/","link":"","permalink":"https://nymrli.top/2019/09/23/Ubuntu16-04-CUDA-toolkit10-1-cudNN7-6-bazel0-26-1/","excerpt":"","text":"Ubuntu 16.04 + CUDA toolkit 10.1 + cudNN7.6 + bazel 0.26.1 保证cuDNN跟CUDA SDK的版本一致即可. 从源码编译的话需要查看显卡的计算能力,可在查看GPU计算能力，在配置的时候填入即可，跟CUDA SDK的版本无关 ▲必须注册账号后，才能选择下载 ▲最好先看我的踩坑记录，先确保自己知道有这些坑 ▲.全程保持能连接外网（翻墙） 安装NVIDIA驱动 123$ ubuntu-drivers devices # 查看# 查看NVIDIA驱动版本$ sudo dpkg --list | grep nvidia-* 显卡驱动与CUDA版本对应关系 最新的根据官网查看 下载NVIDIA驱动 ▲注意:得对应匹配!!! 安装完成后，可以通过nvidia-smi查看GPU使用情况 CUDA toolkit 10.1 安装之前先看显卡的驱动版本 1234# 安装过程$ sudo dpkg -i cuda-repo-ubuntu1604-10-1-local-10.1.243-418.87.00_1.0-1_amd64.deb$ sudo apt update$ sudo apt install cuda 设置环境变量 123456$ sudo vim ~/.bashrc# 设置环境变量$ export PATH=/usr/local/cuda-8.0/bin:$PATH$ export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64:$LD_LIBRARY_PATH# 生效$ source ~/.bashrc 验证安装完成 1234$ nvcc -V$ cd /usr/local/cuda/samples/1_Utilities/deviceQuery$ sudo make$ ./deviceQuery △.如果显示Result:PASS才是安装成功。这一步一定要保证错误，不然之后bazel编译时报错就很难分析问题！！！！！(只有在驱动安装好的情况下才能运行成功,不然会报no CUDA-capable device is detected，或者GPU is lost) 如果失败,卸载重装 12$ cd /usr/local/cuda/bin$ sudo ./uninstall_cuda_9.2.pl 安装 Python 和 TensorFlow 软件包依赖项 1sudo apt install python-dev python-pip # or python3-dev python3-pip 安装 TensorFlow pip 软件包依赖项（如果使用虚拟环境，请省略 --user 参数）： 123pip install -U --user pip six numpy wheel setuptools mock future&gt;=0.17.1pip install -U --user keras_applications==1.0.6 --no-depspip install -U --user keras_preprocessing==1.0.5 --no-deps cudNN 7.6.3 选择cuDNN Library for Linux 12345678# 解压cudNN$ cp cudnn-8.0-linux-x64-v5.1.solitairetheme8 /usr/local/cuda/cudnn-8.0-linux-x64-v5.1.tgz$ cd /usr/local/cuda/$ tar -xvf cudnn-8.0-linux-x64-v5.1.tgzsudo cp cuda/include/cudnn.h /usr/local/cuda/includesudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn* Bazel 构建Tensorflow需要用bazel,而wget下载很慢,需要代理,可以试着去github上下载后再传到服务器 后来./configure配置TensorFlow时,提示Bazel版本太高…(这个问题出现在我下载的不是github下载下来的tensorflow，网盘下载的可能版本太低了) 123WARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the command \"bazel shutdown\".You have bazel 0.29.1 installed.Please downgrade your bazel installation to version 0.26.1 or lower to build TensorFlow! To downgrade: download the installer for the old version (from https://github.com/bazelbuild/bazel/releases) then run the installer. 从源码构建和安装Tensorflow 第一次安装的是2.0的版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566git clone https://github.com/tensorflow/tensorflow.gitcd tensorflow(tf) apollo3d@apollo1:~/Downloads/tensorflow-master$ ./configure WARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the command \"bazel shutdown\".You have bazel 0.26.0 installed.Please specify the location of python. [Default is /home/apollo3d/tf/bin/python]: /usr/bin/python3Found possible Python library paths: /usr/local/lib/python3.5/dist-packages /usr/lib/python3/dist-packagesPlease input the desired Python library path to use. Default is [/usr/local/lib/python3.5/dist-packages]Do you wish to build TensorFlow with XLA JIT support? [Y/n]: XLA JIT support will be enabled for TensorFlow.Do you wish to build TensorFlow with OpenCL SYCL support? [y/N]: No OpenCL SYCL support will be enabled for TensorFlow.Do you wish to build TensorFlow with ROCm support? [y/N]: No ROCm support will be enabled for TensorFlow.Do you wish to build TensorFlow with CUDA support? [y/N]: yCUDA support will be enabled for TensorFlow.Do you wish to build TensorFlow with TensorRT support? [y/N]: No TensorRT support will be enabled for TensorFlow.Found CUDA 10.1 in: /usr/local/cuda/lib64 /usr/local/cuda/includeFound cuDNN 7 in: /usr/local/cuda/lib64 /usr/local/cuda/includePlease specify a list of comma-separated CUDA compute capabilities you want to build with.You can find the compute capability of your device at: https://developer.nvidia.com/cuda-gpus.Please note that each additional compute capability significantly increases your build time and binary size, and that TensorFlow only supports compute capabilities &gt;= 3.5 [Default is: 3.5,7.0]: 5.0Do you want to use clang as CUDA compiler? [y/N]: NClang will be used as CUDA compiler.Do you wish to download a fresh release of clang? (Experimental) [y/N]: NClang will be downloaded and used to compile tensorflow.Please specify optimization flags to use during compilation when bazel option \"--config=opt\" is specified [Default is -march=native -Wno-sign-compare]: --config=v2Would you like to interactively configure ./WORKSPACE for Android builds? [y/N]: Not configuring the WORKSPACE for Android builds.Preconfigured Bazel build configs. You can use any of the below by adding \"--config=&lt;&gt;\" to your build command. See .bazelrc for more details. --config=mkl # Build with MKL support. --config=monolithic # Config for mostly static monolithic build. --config=ngraph # Build with Intel nGraph support. --config=numa # Build with NUMA support. --config=dynamic_kernels # (Experimental) Build kernels into separate shared objects. --config=v2 # Build TensorFlow 2.x instead of 1.x.Preconfigured Bazel build configs to DISABLE default on features: --config=noaws # Disable AWS S3 filesystem support. --config=nogcp # Disable GCP support. --config=nohdfs # Disable HDFS support. --config=nonccl # Disable NVIDIA NCCL support. Configuration finished 第二次1.14 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980(pythonEnv) apollo3d@apollo1:~/Downloads/tensorflow$ ./configure WARNING: Running Bazel server needs to be killed, because the startup options are different.WARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the command \"bazel shutdown\".You have bazel 0.26.0 installed.Please specify the location of python. [Default is /home/apollo3d/pythonEnv/bin/python]: Traceback (most recent call last): File \"&lt;string&gt;\", line 1, in &lt;module&gt;AttributeError: module 'site' has no attribute 'getsitepackages'Found possible Python library paths: /home/apollo3d/pythonEnv/lib/python3.5/site-packagesPlease input the desired Python library path to use. Default is [/home/apollo3d/pythonEnv/lib/python3.5/site-packages]Do you wish to build TensorFlow with XLA JIT support? [Y/n]: XLA JIT support will be enabled for TensorFlow.Do you wish to build TensorFlow with OpenCL SYCL support? [y/N]: nNo OpenCL SYCL support will be enabled for TensorFlow.Do you wish to build TensorFlow with ROCm support? [y/N]: No ROCm support will be enabled for TensorFlow.Do you wish to build TensorFlow with CUDA support? [y/N]: yCUDA support will be enabled for TensorFlow.Do you wish to build TensorFlow with TensorRT support? [y/N]: No TensorRT support will be enabled for TensorFlow.Found CUDA 10.1 in: /usr/local/cuda/lib64 /usr/local/cuda/includeFound cuDNN 7 in: /usr/local/cuda/lib64 /usr/local/cuda/includePlease specify a list of comma-separated CUDA compute capabilities you want to build with.You can find the compute capability of your device at: https://developer.nvidia.com/cuda-gpus.Please note that each additional compute capability significantly increases your build time and binary size, and that TensorFlow only supports compute capabilities &gt;= 3.5 [Default is: 5.2]: 5.0Do you want to use clang as CUDA compiler? [y/N]: nnvcc will be used as CUDA compiler.Please specify which gcc should be used by nvcc as the host compiler. [Default is /usr/bin/gcc]: Do you wish to build TensorFlow with MPI support? [y/N]: No MPI support will be enabled for TensorFlow.Please specify optimization flags to use during compilation when bazel option \"--config=opt\" is specified [Default is -march=native -Wno-sign-compare]: Would you like to interactively configure ./WORKSPACE for Android builds? [y/N]: Not configuring the WORKSPACE for Android builds.Preconfigured Bazel build configs. You can use any of the below by adding \"--config=&lt;&gt;\" to your build command. See .bazelrc for more details. --config=mkl # Build with MKL support. --config=monolithic # Config for mostly static monolithic build. --config=gdr # Build with GDR support. --config=verbs # Build with libverbs support. --config=ngraph # Build with Intel nGraph support. --config=numa # Build with NUMA support. --config=dynamic_kernels # (Experimental) Build kernels into separate shared objects.Preconfigured Bazel build configs to DISABLE default on features: --config=noaws # Disable AWS S3 filesystem support. --config=nogcp # Disable GCP support. --config=nohdfs # Disable HDFS support. --config=noignite # Disable Apache Ignite support. --config=nokafka # Disable Apache Kafka support. --config=nonccl # Disable NVIDIA NCCL support.Configuration finished...INFO: Elapsed time: 4826.834s, Critical Path: 298.31sINFO: 24978 processes: 24978 local.INFO: Build completed successfully, 26636 total actions# 大概用了一个半小时 △.期间可能多次出现ERROR:[GET returned 404 Not Found, connect timed out],继续重试即可 编译 pip 软件包 12345678910$ (tf) apollo3d@apollo1:~/Downloads/tensorflow-master$ bazel build -c --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package# -c 不链接直接编译Starting local Bazel server and connecting to it...WARNING: The following configs were expanded more than once: [cuda_clang, using_cuda, download_clang_use_lld]. For repeatable flags, repeats are counted twice and may lead to unexpected behavior.WARNING: option '--crosstool_top' was expanded to from both option '--config=cuda_clang' (source /home/apollo3d/Downloads/tensorflow-master/.tf_configure.bazelrc) and option '--config=download_clang' (source /home/apollo3d/Downloads/tensorflow-master/.tf_configure.bazelrc)$ bazel-bin/tensorfLow/tools/pip_package/build_pip_package ~/tensorflow/bin # 传入一个表示Python whell文件存储路径的参数# 在虚拟环境打开的情况下安装 附录： windows上安装cuda时一直显示不能安装，就是系统默认安装的版本太低了，或者根本就没有安装。只有到显卡驱动下载安装了驱动后，才能正常安装CUDA windows安装建议 安装完linux后,我在自己笔记本上又安装了个Windows10的，两个是相通的，windows的很快我就安装好了。主要卡壳的时间全都是浪费在了驱动版本安装错误，只要把驱动的版本弄对了。然后依次安装NVIDIA驱动、CUDA、Cudnn就可以了。 采坑记录 ▲下载tensorflow，一定要从官网下载最新的。千万不要去网盘上下载，我就是被这个坑了很久。最后从github下了后才逐渐正常。（github下载会很慢，可以见我的另外一篇文章，如何提速） ▲./configure的配置也很重要，除了CUDA选项其他都选默认 Linux系统下安装TensorFlow的GPU版本 CUDA、显卡驱动和Tensorflow版本之间的对应关系 Linux x86_64 Driver Version与CUDA Toolkit的对应，一定要对应好，CUDA超出了Driver Version的话，是无法使用的^提示 ==&gt;CUDA 10.1的需要Linux x86_64 Driver Version&gt;=410.48。同时，tensorflow-gpu默认安装的是1.14版本，要求的cudNN为7，CUDA为9 ▲google.xxxx.xxxx==&gt;unknown hosts 报了这个错以后才发现，服务器的DNS没配置（云服务器一般不会出现这样的问题） 12345$ sudo vim /etc/resolv.conf# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTENnameserver 8.8.8.8nameserver 8.8.4.4 ▲An error occurred during the fetch of repository ‘llvm’:Error 404 ， cant connect 多次重试即可 1$ (tf) apollo3d@apollo1:~/Downloads/tensorflow-master$ bazel build -c --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package ▲报错 AttributeError: ‘_NamespacePath’ object has no attribute 'sort’ 重新安装setuptools 123(pythonEnv) $ pip uninstall setuptools(pythonEnv) $ pip install setuptools(pythonEnv) $ pip install googleapis-common-protos 执行上述命令需要相当长的一段时间，具体时长取决于你的计算机性能。 12345Target //tensorflow/tools/pip_package:build_pip_package up-to-date: bazel-bin/tensorflow/tools/pip_package/build_pip_packageINFO: Elapsed time: 77.892s, Critical Path: 77.18sINFO: 45 processes: 45 local.INFO: Build completed successfully, 46 total actions 待Bazel成功完成上述任务后会输出，运行输出的可执行程序，并传入一个表示Python whee文件存储路径的参数： bazel-bin/tensorflow/tools/pip_package/build_pip_package ~/ 12345678910111213141516(pythonEnv) apollo3d@apollo1:~/Downloads/tensorflow$ bazel-bin/tensorflow/tools/pip_package/build_pip_package ~/2019年 09月 24日 星期二 14:34:05 CST : === Preparing sources in dir: /tmp/tmp.pguTqrHuLA~/Downloads/tensorflow ~/Downloads/tensorflow~/Downloads/tensorflow/tmp/tmp.pguTqrHuLA/tensorflow/include ~/Downloads/tensorflow~/Downloads/tensorflow2019年 09月 24日 星期二 14:34:11 CST : === Building wheelwarning: no files found matching &apos;*.pyd&apos; under directory &apos;*&apos;warning: no files found matching &apos;*.pd&apos; under directory &apos;*&apos;warning: no files found matching &apos;*.dylib&apos; under directory &apos;*&apos;warning: no files found matching &apos;*.dll&apos; under directory &apos;*&apos;warning: no files found matching &apos;*.lib&apos; under directory &apos;*&apos;warning: no files found matching &apos;*.csv&apos; under directory &apos;*&apos;warning: no files found matching &apos;*.h&apos; under directory &apos;tensorflow_core/include/tensorflow&apos;warning: no files found matching &apos;*&apos; under directory &apos;tensorflow_core/include/third_party&apos;2019年 09月 24日 星期二 14:34:33 CST : === Output wheel file is in: /home/apollo3d/ pip安装 上述命令将在~/tensorlowbn下创建一个Python.wh文件。请确保你的“tensor-fow Virtualenv不境处于活动状态，然后用pip安装该whee文件（请注意该二进制文件的具体名称会依所安装的TensorFlow版本、所使用的操作系统和Python版本而不同）： (pythonEnv) apollo3d@apollo1:~$ pip install tensorflow-2.0.0rc2-cp35-cp35m-linux_x86_64.whl ▲安装成功后，使用时报错 使用TensorFlow时报错FutureWarning: Passing (type, 1) or ‘1type’ as a synonym of type is deprecated; in a future version of numpy… 报错原因：numpy1-17-0版本过高，使用numpy-1.16-0版本即可 解决方法：重新安装numpy-1.16-0 12$ pip uninstall numpy$ pip install numpy==1.16.0","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"Github下载、访问慢解决方法[转]","slug":"Github下载、访问慢解决方法-转","date":"2019-09-23T08:36:21.000Z","updated":"2019-09-29T09:38:38.048Z","comments":true,"path":"2019/09/23/Github下载、访问慢解决方法-转/","link":"","permalink":"https://nymrli.top/2019/09/23/Github下载、访问慢解决方法-转/","excerpt":"","text":"Github下载、访问慢解决方法[转] 下载tensorflow就16KiB/s,改完后能有900+KiB/s 修改hosts 1234567891011121314151617151.101.44.249 github.global.ssl.fastly.net192.30.253.113 github.com103.245.222.133 assets-cdn.github.com23.235.47.133 assets-cdn.github.com203.208.39.104 assets-cdn.github.com204.232.175.78 documentcloud.github.com204.232.175.94 gist.github.com107.21.116.220 help.github.com207.97.227.252 nodeload.github.com199.27.76.130 raw.github.com107.22.3.110 status.github.com204.232.175.78 training.github.com207.97.227.243 www.github.com185.31.16.184 github.global.ssl.fastly.net185.31.18.133 avatars0.githubusercontent.com185.31.19.133 avatars1.githubusercontent.com192.30.253.120 codeload.github.com windows更新:ipconfig /flushdns linux重启网络服务:service network restart&lt;===&gt;/etc/init.d/networking restart(两个都没尝试) 我重新打开终端就行了","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"},{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"同性交友网站Github的骚操作","slug":"同性交友网站Github的骚操作","date":"2019-09-21T03:56:19.000Z","updated":"2020-09-15T02:57:33.475Z","comments":true,"path":"2019/09/21/同性交友网站Github的骚操作/","link":"","permalink":"https://nymrli.top/2019/09/21/同性交友网站Github的骚操作/","excerpt":"","text":"做好看的REAMDE 123456789101112131415161718&lt;p align=\"center\"&gt; &lt;a href=\"https://travis-ci.com/xkcoding/spring-boot-demo\"&gt;&lt;img alt=\"Travis-CI\" src=\"https://travis-ci.com/xkcoding/spring-boot-demo.svg?branch=master\"/&gt;&lt;/a&gt; &lt;a href=\"https://www.codacy.com/app/xkcoding/spring-boot-demo?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=xkcoding/spring-boot-demo&amp;amp;utm_campaign=Badge_Grade\"&gt;&lt;img alt=\"Codacy\" src=\"https://api.codacy.com/project/badge/Grade/1f2e3d437b174bfc943dae1600332ec1\"/&gt;&lt;/a&gt; &lt;a href=\"https://xkcoding.com\"&gt;&lt;img alt=\"author\" src=\"https://img.shields.io/badge/author-Yangkai.Shen-blue.svg\"/&gt;&lt;/a&gt; &lt;a href=\"https://www.oracle.com/technetwork/java/javase/downloads/index.html\"&gt;&lt;img alt=\"JDK\" src=\"https://img.shields.io/badge/JDK-1.8.0_162-orange.svg\"/&gt;&lt;/a&gt; &lt;a href=\"https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/html/\"&gt;&lt;img alt=\"Spring Boot\" src=\"https://img.shields.io/badge/Spring Boot-2.1.0.RELEASE-brightgreen.svg\"/&gt;&lt;/a&gt; &lt;a href=\"https://github.com/xkcoding/spring-boot-demo/blob/master/LICENSE\"&gt;&lt;img alt=\"LICENSE\" src=\"https://img.shields.io/github/license/xkcoding/spring-boot-demo.svg\"/&gt;&lt;/a&gt; &lt;/p&gt;&lt;p align=\"center\"&gt; &lt;a href=\"https://github.com/xkcoding/spring-boot-demo/stargazers\"&gt;&lt;img alt=\"star\" src=\"https://img.shields.io/github/stars/xkcoding/spring-boot-demo.svg?label=Stars&amp;style=social\"/&gt;&lt;/a&gt; &lt;a href=\"https://github.com/xkcoding/spring-boot-demo/network/members\"&gt;&lt;img alt=\"star\" src=\"https://img.shields.io/github/forks/xkcoding/spring-boot-demo.svg?label=Fork&amp;style=social\"/&gt;&lt;/a&gt; &lt;a href=\"https://github.com/xkcoding/spring-boot-demo/watchers\"&gt;&lt;img alt=\"star\" src=\"https://img.shields.io/github/watchers/xkcoding/spring-boot-demo.svg?label=Watch&amp;style=social\"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p align=\"center\"&gt; &lt;span&gt;中文 | &lt;a href=\"./README.en.md\"&gt;English&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 项目条幅 Q: Github 上各式各样的小徽章从何而来? A: Substats 和 Shields.io Shields.io语法规则 : ![{左半部分标签}](https://img.shields.io/badge/{左半部分标签}-{右半部分标签}-{右半部分颜色}), 效果如下 Substats 对动态徽章支持的更好! 1234[![Stargazers](https://img.shields.io/github/stars/NJUPTFreeExams/NJUPT-CS-Free-Exams.svg?style=for-the-badge)](https://github.com/NJUPTFreeExams/NJUPT-CS-Free-Exams/stargazers)[![Forks](https://img.shields.io/github/forks/NJUPTFreeExams/NJUPT-CS-Free-Exams.svg?style=for-the-badge)](https://github.com/NJUPTFreeExams/NJUPT-CS-Free-Exams/network/members)[![cloed prs](https://img.shields.io/github/issues-pr-closed-raw/NJUPTFreeExams/NJUPT-CS-Free-Exams.svg?style=for-the-badge)](https://github.com/NJUPTFreeExams/NJUPT-CS-Free-Exams/pulls)! sponsors资助者: opencollective——https://opencollective.com/ 贡献者名单 123456789101112131415161718192021## 贡献者名单&lt;a href=\"https://github.com/imguozr\"&gt; &lt;img src=\"https://avatars1.githubusercontent.com/u/30227124?v=4\" width=\"50px\"&gt;&lt;/a&gt;&lt;a href=\"https://github.com/Wonz5130\"&gt; &lt;img src=\"https://avatars1.githubusercontent.com/u/35889526?v=4\" width=\"50px\"&gt;&lt;/a&gt;&lt;a href=\"https://github.com/Wen-He\"&gt; &lt;img src=\"https://avatars0.githubusercontent.com/u/18651139?v=4\" width=\"50px\"&gt;&lt;/a&gt;&lt;a href=\"https://github.com/chenkangyang\"&gt; &lt;img src=\"https://avatars2.githubusercontent.com/u/28588778?v=4\" width=\"50px\"&gt;&lt;/a&gt;&lt;a href=\"https://github.com/Davont\"&gt; &lt;img src=\"https://avatars0.githubusercontent.com/u/28757633?v=4\" width=\"50px\"&gt;&lt;/a&gt; 中英文Readme 由于Github会默认展示当前目录下的README.md，因此README.md中的内容为默认语言即可。 而需要提供其他语言版本的README，需要额外创建markdown文件， 然后通过超链接切换。e.g.默认英文，则REAMDE.md中用英文做介绍，同时再创一个中文的README-zh_CN.md即可。 Copy README 授人鱼不如授人以渔 Q：别人的REAMDE都那么炫酷，怎么办呢？ A:点击他人的README.md文件，然后显示Raw就能看到html辣，由于markdown语法是支持嵌入html，因此只要把结构复制、改下内容就成了。 收藏的好看的REAMDE ant-design-vue shield教程： 附录 单击列表 当提Issue的时候，总会贴很长的代码，有没有什么办法美观一点呢，方法如下 12345&lt;details&gt;&lt;summary&gt;Content of debug log&lt;/summary&gt;&lt;pre&gt;Paste content here ...&lt;/pre&gt;&lt;/details&gt; 效果如下","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"搭建Jupyter、JupyterLab服务器","slug":"搭建Jupyter服务器","date":"2019-09-21T01:53:01.000Z","updated":"2020-11-15T14:07:32.615Z","comments":true,"path":"2019/09/21/搭建Jupyter服务器/","link":"","permalink":"https://nymrli.top/2019/09/21/搭建Jupyter服务器/","excerpt":"","text":"搭建Jupyter服务器 1.配置好Python环境及安装pip 2.安装jupyter: pip3 install jupyter (此处使用的是python3) 3.生成配置文件 jupyter notebook --generate-config 4.生成密钥: 终端输入$ ipython 123456In [1]: from notebook.auth import passwdIn [2]: passwd()Enter password: Verify password: #此时会让你两次输入密码，然后就会生成秘钥#＊＊＊＊＊＊＊＊＊＊＊＊ 5.修改配置文件vim ~/.jupyter/jupyter_notebook_config.py 1234567c=get_config()c.IPKernelApp.pylab =\"inline\"c.NotebookApp.ip='*' # 设置所有ip皆可访问c.NotebookApp.password = 'sha1:x' # 刚生成的密文c.NotebookApp.open_browser = False # 禁止自动打开浏览器c.NotebookApp.port = 9999 # 指定运行端口c.NotebookApp.notebook_dir = '/home/apollo3d/tf/jupyter_home' # 指定Jupyter的工作目录 拓展:云服务器搭建神器JupyterLab(转) JupyterLab是一个交互式的开发环境，其用于应对包含着notebook、代码以及数据的工作场景。 1、前言 如果说vim是编辑器之神，那么JupyterLab就是笔记本之神。 从2017年开始我注意到这一神奇的IDE笔记本，第一眼见到它，就觉得它真的太强大了，作为一个交互式的Python开发工具，其实也不算开发工具，准确的来说，它是一个演示代码的科学数据工具，支持markdown预览，支持Draw扩展，支持丰富的文件格式和多种开发语言，拥有众多插件诸于GitHub， Google-Dirve， Git和TOC，更重要的是，它是把浏览器当作开发工具，十分有创意。JupyterLab的开发者众多，GitHub上面的isuue也十分活跃，众多的大牛开发者也纷纷加入到JupyterLab的阵营，为JupyterLab的发展作贡献，JupyterLab得到迅速发展。 好的工具当然是要好好利用了，回归正题，怎样通过云服务器搭建一个可远程使用的JupyterLab? 2、添加ppa源 1234root@iZwz9huxtbd86xp91s3j16Z:~# sudo add-apt-repository ppa:chronitis/jupyter$ sudo: add-apt-repository: command not found# 出现这种情况,可以如下解决# $ sudo apt-get install software-properties-common 3、配置python 123456$ sudo apt-get install python-pip python-dev build-essential $ sudo pip install --upgrade pip # $ sudo pip install --upgrade virtualenv #安装虚拟环境# 升级pip$ sudo pip3 install --upgrade pip$ sudo pip2 install --upgrade pip 如果没有换源,先进行换源,下载速度会快很多 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 123cat &gt; ~/.pip/pip.conf[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple npm和yarn也可以换源，更简单，自行google。 pip国内的一些镜像包,换源之后出现python2版本过低的情况导致以前的包下载不了，那就直接将文件夹~/.pip/pip.conf删除就可以恢复原来的源。 pip指向问题 有时候会出现pip,pip2,pip3都TM指向python2，这个之后就需要改一下这这三个文件。 编辑这三个文件，将第一行注释分别改为python\\python2\\python3 12345678~ $which pip/usr/local/bin/pip21:36 alien@alien-Inspiron-3443:~ $which pip2/usr/local/bin/pip221:36 alien@alien-Inspiron-3443:~ $which pip3/usr/local/bin/pip3 安装yarn和nodejs 配置仓库 12curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -echo \"deb https://dl.yarnpkg.com/debian/ stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list 安装yarn 123sudo apt-get updatesudo apt-get install yarn# 如果这边安装后,报错NameError: name 'CoreConfig' is not defined,那么需要更新nodejs版本 注意这里yarn自动安装了nodejs，不过版本太低，安装jupyterlab的时候会出问题，而且使用n或者nvm安装的nodejs也有问题，总之nodejs要按照下面这种方式就没事，这个是官方的bug，官方issue也提到过，但是目前还未解决。 如果版本过低,安装插件、或是jupyter lab build发生NameError: name 'CoreConfig' is not defined错误,则可能是nodejs版本过低导致.我出现这个Bug后找了提了issue也没解决,后来突然想起了这边提到的nodejs版本问题,于是更新后解决…nodejs更新方式见附录 安装nodejs 创建一个新文件，输入两行deb，结束之后Ctrl+C: 123cat &gt; /etc/apt/sources.list.d/nodesource.listdeb https://deb.nodesource.com/node_6.x xenial maindeb-src https://deb.nodesource.com/node_6.x xenial main 导入公匙并安装nodejs，这个版本的nodejs对jupyterlab支持比较友好。 123456789101112131415161718192021curl -s https://deb.nodesource.com/gpgkey/nodesource.gpg.key | sudo apt-key add -sudo apt-get updateapt-cache policy nodejssudo apt-get install nodejsnodejs --version​```shell#### 安装`ipython,matplotlib,scipy,pandas,numpy`最好`python2`和`python3`都安装。## 安装`JupyterLab`及其配置&gt; 配置同上文Jupyter配置​```shell# 安装sudo pip3 install jupyterlab# 生成密码jupyter-notebook password 创建哈希密码 12345from notebook.auth import passwdpasswd()# 输入你自己设置登录JupyterLab界面的密码，# 然后就会生产下面这样的密码，将它记下来，待会儿用'sha1:b92f3fb7d848:a5d40ab2e26aa3b296ae1faa17aa34d3df351704' 修改JupyterLab配置文件 先生成一个配置文件，记下输出的配置文件地址 jupyter lab --generate-config-&gt; 123456c.NotebookApp.allow_root = True #允许以root方式运行jupyterlabc.NotebookApp.ip = '0.0.0.0' #允许任意ip段访问c.NotebookApp.notebook_dir = u'/root/JupyterLab' # 设置jupyterlab页面的根目录c.NotebookApp.open_browser = False#默认运行时不启动浏览器，因为服务器默认只有终端c.NotebookApp.password = u'sha1:b92f3fb7d848:a5d40ab2e26aa3b296ae1faa17aa34d3df351704'#设置之前生产的哈希密码c.NotebookApp.port = 8080#设置访问端口 到此，JupyterLab已经安装成功了。 12345678$ jupyter-lab --version&gt;&gt;&gt; 0.33.12$ jupyter lab build# build没成功，可以看看是不是内存限制，试试下面的命令# cross-env NODE_OPTIONS=--max_old_space_size=4096 webpack --config webpack.prod.minimize.config.jserror Command failed with exit code 1.\"\"\"# jupyter lab build --minimize=False jupyter lab build时间有点久，如果没报错就成功了 4、运行JupyterLab 1$ jupyter lab &amp; JupyterLab运行虚拟环境 在jupyter lab中使用虚拟环境 进入虚拟环境后输入以下代码，则在jupyter中创建出虚拟环境(env_name)下的kernel 12pip install ipykernelpython -m ipykernel install --user --name env_name 删除创建的kernel CMD窗口下打开jupyter lab后若要关闭，Ctrl+C；也可在jupyter lab中打开终端输入命令，但此时输入退出/打开虚拟环境命令(deactivate/workon等)是无效的，即始终处在虚拟环境中 12jupyter kernelspec list #查看所有kerneljupyter kernelspec remove kernel_name #卸载kernel_name JupyterLab扩展安装 1234567jupyter labextension list # 查看已经安装的扩展及其状态：jupyter labextension install @mflevine/jupyterlab_html # 比如安装一个扩展jupyterlab_html，支持html预览:jupyter labextension uninstall @mflevine/jupyterlab_html #卸载扩展:jupyter labextension update --all #更新所有扩展:# 安装一个生成目录的插件jupyter labextension install @jupyterlab/toc 还有功能 支持做图 markdown 多标签 内部打开网页 latex 快捷键 编辑模式命令 执行当前cell，执行后不自动调转到下一个cell：Ctrl-Enter 使当前的cell进入编辑模式：Enter 退出当前cell的编辑模式：Esc 命令模式: 删除当前的cell：双D 为当前的cell加入line number：单L 将当前的cell转化为具有一级标题的maskdown：单1 将当前的cell转化为具有二级标题的maskdown：单2 将当前的cell转化为具有三级标题的maskdown：单3 撤销对某个cell的删除：z 浏览器的各个Tab之间切换：Up和Dn 附录 nodejs更新 1234567891011# 查看更新前的版本$ node -vv4.2.1$ sudo npm cache clean -f$ sudo npm install -g n$ sudo n stable # 软链接,VERSION改成新的版本(删了后按TAB键)$ sudo ln -sf /usr/local/n/versions/node/&lt;VERSION&gt;/bin/node /usr/bin/nodejs# 查看是否更新成功$ node -vv10.16.3 安装内核 安装Python内核 如果需要python2和python3同时存在的话 12345678$ sudo pip2 install ipykernel$ sudo pip3 install ipykernel# 查看已经安装的内核jupyter kernelspec list# 删除你不需要的内核$ jupyter kernelspec remove &lt;kernel_name&gt;/root/JupyterLab 安装ijavascript 12345sudo add-apt-repository ppa:chronitis/jupytersudo apt-get updatesudo apt-get install ijavascript# ihaskell、ijulia、irkernel、iruby# https://github.com/jupyter/jupyter/wiki/Jupyter-kernels 插件安装 jupyterlab-toc(目录功能) Installation 1jupyter labextension install @jupyterlab/toc Jupyterlab-Tensorboard Installation 1$ jupyter labextension install jupyterlab_tensorboard ](http://image.rexking6.top/img/clip1545289922.png) JupyterLab drawio(processon图) Installation 1jupyter labextension install jupyterlab-drawio 注,图片来自RexKing6’s Note variableinspector 像matlab一样查看工作区变量 jupyter labextension install @lckr/jupyterlab_variableinspector go_to_definition插件 在lab中按alt+ 点击变量名 or 函数名，可以跳转到其对应的最初定义的地方(注意看闪烁光标的位置变化)。 快捷键 Up : 选中上方单元 K : 选中上方单元 Down : 选中下方单元 J : 选中下方单元 Shift-K : 扩大选中上方单元 Shift-J : 扩大选中下方单元 A : 在上方插入新单元 B : 在下方插入新单元 X : 剪切选中的单元 C : 复制选中的单元 Shift-V : 粘贴到上方单元 V : 粘贴到下方单元 Z : 恢复删除的最后一个单元 D,D : 删除选中的单元 Shift-M : 合并选中的单元 I,I : 中断Notebook内核0,0 0,0 :重启Notebook内核 Tab : 代码补全或缩进 Shift-Tab : 提示 Ctrl-] : 缩进 Ctrl-[ : 解除缩进 Ctrl-A : 全选 Ctrl-Z : 复原 Ctrl-Shift-Z : 再做 Ctrl-Y : 再做 Ctrl-Home : 跳到单元开头 Ctrl-Up : 跳到单元开头 Ctrl-End : 跳到单元末尾 Ctrl-Down : 跳到单元末尾 Ctrl-Left : 跳到左边一个字首 Ctrl-Right : 跳到右边一个字首 Ctrl-Backspace : 删除前面一个字 Ctrl-Delete : 删除后面一个字 Esc : 进入命令模式 Ctrl-M : 进入命令模式 Shift-Enter : 运行本单元，选中下一单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在下面插入一单元 Ctrl-Shift-- : 分割单元 Ctrl-Shift-Subtract : 分割单元 Ctrl-S : 文件存盘 Shift : 忽略 Up : 光标上移或转入上一单元 Down :光标下移或转入下一单元","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"深度学习","slug":"深度学习","date":"2019-09-19T12:32:44.000Z","updated":"2019-10-05T07:28:34.746Z","comments":true,"path":"2019/09/19/深度学习/","link":"","permalink":"https://nymrli.top/2019/09/19/深度学习/","excerpt":"","text":"深度学习——神经网络 构建网络的总原则 一、增大网络容量，直到过拟命 二、采取措施抑制过拟合 三、继续增大网络容量，直到过拟合 线性回归 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-# Commented out IPython magic to ensure Python compatibility.import kerasimport numpy as npimport matplotlib.pyplot as plt# %matplotlib inlinex = np.linspace(0,80,50)y = 3*x + np.random.randn(50)*15# print(x,y,sep='\\n')plt.scatter(x,y)from keras import layers# 初始化模型model = keras.Sequential()# 增加一层：全连接层model.add(layers.Dense(1,input_dim=1))model.summary()# 编译模型model.compile(optimizer='adam', loss='mse')# 训练模型# 方法一model.fit(x,y,epochs=2000)# 方法二#for setp in range(3001):# cost = model.train_on_batch(x_data,y_data)# if step % 500 == 0:# print('cost:',cost)#w,b = model.layers[0].get_weights()predict_y = model.predict(x)plt.scatter(x,y,s=10,c='r')plt.plot(x,predict_y) 非线性回归 激活函数 softmax Si=ei∑jejS_{i}=\\frac{e^{i}}{\\sum_{j} e^{j}}Si​=∑j​ejei​ sigmod: logistic: 范围是[0,1] f(t)=etet+1=11+e−tf(t)=\\frac{\\mathrm{e}^{t}}{\\mathrm{e}^{t}+1}=\\frac{1}{1+\\mathrm{e}^{-t}}f(t)=et+1et​=1+e−t1​ reLU f(x)=max(0,x)f(x)=max(0,x)f(x)=max(0,x) tanh 跟sigmoid函数很像,但是范围是[-1,1],而不是[0,1],实质是sigmoid函数平移 tanh⁡(x)=sinh⁡xcosh⁡x=ex−e−xex+e−x\\tanh(x)=\\frac{\\sinh x}{\\cosh x}=\\frac{e^{x}-e^{-x}}{e^{x}+e^{-x}}tanh(x)=coshxsinhx​=ex+e−xex−e−x​ TensorFlow中其他的函数： ●tf.nn.elu(x)： 指数线性单元； 如果输入小于0， 返回exp(x)-1； 否 则， 返回x； ●tf.softsign(x)： 返回x/(abs(x)+1)； ●tf.nn.bias_add(value,bias)： 增加一个bias到value。 Tensorflow: 张量——数据 : 多维数组,阶:张量的维数 计算图——神经网络 搭建神经网络的计算过程,只搭建,不运算 会话——执行计算图===&gt;优化线上的权重====&gt;权重 神经网络实现过程 1.准备数据集,提取特征,作为输入 2.搭建NN结构,从输入到输出==&gt;(NN前向传播) 3.大量特征数据喂给NN,迭代优化NN参数==&gt;(NN反向传播) 4.使用训练好的模型预测和分类 &gt;八股:准备,前传,后传,迭代&lt; 12x = tf.placehold(tf.float32,shape=(1,2)) #占位符sess.run(要计算的节点,feed_dict=&#123;x:[[1.3,2.0]]&#125;) 12Init_op = tf.global_variables_initializer()sess.run(Init_op) y = matmul(x,w1)`相乘 《TensorFlow机器学习项目实战》笔记 张量 TensorFlow基于张量数据管理。 张量是数学领域的概念， 并且被开 发为向量和矩阵的线性代数项的泛化。 一个张量就是一个张量类的实例， 是绑定了相关运算的一个特定类型的多维数组。 张量的属性 有一个静态的类型和动态的维数 只有张量类型的对象才能在计算图的节点中 传递。 秩rank 数据类型type 形状shape numpy数组到TensorFlow张量 TensorFlow与numpy是可互操作的， 通常调用eval()函数会返回 numpy对象。因为张量对象只是一个操作结果的符号化句柄， 所以它并不持有该操作的结果 ,必须使用eval()方法来获得实际的 值 12345678import tensorflow as tf #we import tensorflowimport numpy as np #we import numpysess = tf.Session() #start a new Session Objectx_data = np.array([[1.,2.,3.],[3.,2.,6.]]) # 2x3 matrixx = tf.convert_to_tensor(x_data,dtype=tf.float32) #Finally, we create the#tensor, starting from the fload 3x matrix tf.convert_to_tensor``： 该方法将Python对象转化为tensor对象。 它的 输入可以是tensor对象、 numpy数组、 Python列表和Python标量。 数据流图(data flow graph) 数据流图是完整的TensorFlow计算 节点(node) 表示操作(operation) ,实现数学运算， 同时也表示数据或变量的供给(feed) ， 或输出结果 。一旦其输入边缘上的所有张量都到位， 则开始异步地并行执行 边(edge) 表示各操作之间流通的数据 ,描述节点之间的输入/输出关系。 这些数据边缘专门传输张量 计算图(computation graph) 由用户在创建张量(tensor) 和操作(op 有用的操作对象方法如下： ●tf.Operation.type： 返回操作的类型(例如， MatMul) ； ●tf.Operation.inputs： 返回表示操作的输入张量对象列表； ●tf.Graph.get_operations()： 返回计算图中的操作列表； ●tf.Graph.version： 返回计算图的版本信息。 变量 正如字面意思所示,是个变化的量。在TensorFlow具体表现为需要更新的参数 在大多数计算中， 会多次执行计算图。 大多数张量的生存周期不会 超过单次执行周期。 然而， 变量是一种特殊的操作， 它返回一个持久 的、 可变的张量的句柄， 存活于多次计算图执行之中。 对于TensorFlow 的机器学习应用， 模型的参数通常存储在变量中， 并且在运行模型的训 练阶段被更新。 placehold 给之后喂给的数据占位 会话 客户端程序通过创建会话(Session)与TensorFlow系统交互。 Session对象是运行环境的表示。Session对象开始为空，当程序员创建不同的操作和张量时，它们将被自动添加到Session，直到Run方法被调用，才开始运算。 Run方法输入是需要计算的操作，以及一组可选的张量，用来代替图中某些节点的输出。 如果我们调用这个方法，并且有命名操作所依赖的操作，Session对象将执行所有这些操作，然后继续执行命名操作。 用以下简单的代码可以创建一个会话： s=tf.Session() 矩阵运算 转置、 乘法、 获取行列式和逆 1234tf. transpose(x). eval()# Transposetf. matmul(x,y). eval()# Matrixtf. matrix determinant(floatx). eval()# 行列式tf.matrix_inverse(floatx).eval() # 求逆 约简(reduction) 是一种跨维度张量操作， 计算结果比原张量缩减 一个维度。 12345678910111213141516171819202122In [1]: import tensorflow as tf In[2]: sess=tf. InteractiveSession()In[3]:x=tf. constant([[1,2,3], [3,2,1], [-1,2,-3]])In[5]: tf.reduce_prod(x, reduction_indices=1). eval() # reduce prod,行操作,0为列操作 0ut[5]: array([6,6,-6], dtype=int32)In [6]: tf. reduce_min(x, reduction_indices=1). eval()# reduce min 0ut[6]: array([1,1,-3], dtype=int32)In [7]: tf. reduce_max(x, reduction_indices=1). eval()# reduce max 0ut[7]: array([3,3,-1], dtype=int32)In [8]: tf. reduce_mean(x, reduction indices=1). eval()# reduce mean 0ut[8]: array([ 2,2,-2], dtype=int32) In[9]: tf. reduce_all(boolean_tensor, reduction_indices=1). eval()# reduce all Out[9]: array([ False, False, False], dtype=bool)In [10]: tf. reduce_any(boolean_tensor, 序列实用程序包括诸如argmin和argmax(显示维度的最小和最大 值) ， listdiff(显示列表之间的交集的补码) ， where(显示张量上的真 实值的索引) 和unique(在列表上去除重复的元素) 。 1234567891011121314151617181920212223import tensorflow as tf sess=tf. InteractiveSession()x=tf. constant([[2,5,3,-5],…:[0,3,-2,5],……:[4,3,5,3],…:[6,1,4,0jj)listx=tf. constant([1,2,3,4,5,6,7,8])listy=tf. constant([4,5,8,9])boolx=tf. constant([[ True, False],[ False, True]]) tf. argmin(x,1). eval()# Position of the maximum value of columns&gt;&gt;&gt; array([3,2,1,3]) tf. argmax(x,1). eval()# Position of the minimum value of rows&gt;&gt;&gt; array([1,3,2,0]) tf. listdiff(listx, listy)[0]. eval()#List differences&gt;&gt;&gt; array([1,2,3,6,7], dtype=int32) tf.where(boolx). eval()# Show true values&gt;&gt;&gt; array([[o,0],[1,1]]) tf. unique(listx)[0]. eval()# Unique values in list&gt;&gt;&gt; array([1,2,3,4,5,6,7,8], dtype=int32) 形状变换 : 例如squeeze和expand_dims。 1234567891011121314151617181920212223242526272829303132333435In [1]: import tensorflow as tf In [2]: sess=tf. InteractiveSession()In [3]:x=tf. constant([[2,5,3,-5], ……:[0,3,-2,5], …:[4,3153, …:[6,1,4,0]])tf. shape(x). eval()# Shape of the tensor&gt;&gt;&gt; array([4,4], dtype=int32)tf. size(x). eval()# size of the tensor&gt;&gt;&gt;16tf. rank(x). eval()# rank of the tensor&gt;&gt;&gt;2tf. reshape(x,[8,2]). eval()#converting to a 10×2 matrix&gt;&gt;&gt;array([[ 2,5],[3,-5],[0,3],[-2,5],[1,4],[3,1],[5,3],[6,1],[4,0]], dtype=int32)tf. squeeze(x). eval()# squeezing&gt;&gt;&gt; array([[ 2,5,3,-5],[0,3,-2,5],4,3,5,3],[6,1,4,0]], dtype=int32)tf. expand_dims(x,1). eval()# Expanding dims&gt;&gt;&gt;array([[[ 2,5,3,-5]],[[ 0,3,-2,5]],[[4,3,5,3]],[i 6,1,4,0jji, dtype=int32) 切片(slicing) 和连接(joining) :提取矩阵切片、 拆分、 添加填充(add padding) ， 以及打包(pack) 和解包(unpack) 行。 123456789101112131415161718192021222324252627282930313233343536373839404142import tensorflow as tf sess=tf. InteractiveSession()t_matrix=tf. constant([[1,2,3], ……:[4,5,6], …:[7,8,9]])t_array=tf. constant([1,2,3,4,9,8,6,5])t array2=tf. constant([2,3,4,5,6,7,8,9]) tf. slice(t _matrix,[1,1],[2,2]). eval()# cutting an slice&gt;&gt;&gt;array([[5,6],[8,9]], dtype=int32)tf. split(0,2,t_array)# splitting the array in two&gt;&gt;&gt;[&lt;tf. Tensor ' split:0' shape=(4,) dtype=int32&gt;,&lt;tf. Tensor ' split:1' shape=(4,) dtype=int32&gt;]tf. tile([1,2],[3]). eval()# tiling this little tensor 3 times重复&gt;&gt;&gt; array([1,2,1,2,1,2], dtype=int32)tf. pad(t_matrix,[[0,1],[2,1]]). evai()#padding&gt;&gt;&gt; array(i[o,o,1,2,3,0],[0,0,4,5,6,0],[o.0.7.8.9.01.[o,o,o,0,0,0]], dtype=int32)tf. concat(0,[t_array, t_array2]). eval()# concatenating list&gt;&gt;&gt; array([1,2,3,4,9,8,6,5,2,3,4,5,6,7,8,9], dtype=int32)tf. pack([t_array,t_array2]). eval()# packing 拼接0ut[11]:array([[1,2,3,4,9,8,6,5],[2,3,4,5,6,7,8,9]], dtype=int32) sess.run(tf. unpack(t_matrix))#Unpacking, we need the run method to view the tensors&gt;&gt;&gt;[array([1,2,3],dtype=int32),array([4,5,6],dtype=int32),array([7,8,9];dtype=int32) In [13]: tf. reverse(t_matrix,[ False, True]). eval()# Reverse matrix,行不变,列反转0ut[13]: array([[3,2,1],[6,5,41;9,8,7]], dtype=int32) 从磁盘读取信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 列表格式——CSV import tensorflow as tfsess=tf.Session()filename_queue= tf.train.string_input_producer(tf.train.match_filenames_once(\"./*.csv\"),shuffle=True)reader=tf.TextLineReader(skip_header_lines=1)key, value=reader.read(filename_queue)record_defaults=[[0.],[0.],[0],[0.],[\"\"]]col1, col2, col3, col4, col5=tf.decode_csv(value,record_defaults=record_defaults)# Convert CSVrecords to tensors.Each# column maps to one tensor.features=tf.pack([ col1, col2, col3, col4])tf.initialize_all_variables().run(session=sess)coord=tf.train.Coordinator()threads=tf.train.start_queue_runners(coord=coord, sess=sess)for iteration in range(0,5):example=sess.run([ features])print(example)coord.request_stop()coord.join(threads)# 加载和处理图像import tensorflow as tf sess=tf.Session()filename_queue=tf.train.string_input_producer(tf.train.match_filenames_once('./blue_jay.jpg'))reader=tf.WholeFileReader()key, value= reader.read(filename_queue)image=tf.image.decode_jpeg(value)fliplmageUpDown=tf.image.encode _jpeg(tf.image.fli p_up_down(image))# 获得上下翻转的图片 fliplmageleftRight=tf.image.encode_jpeg(tf.image.flip_left_right(image))# 获得左右翻转的图片 tf.initialize_all_variables().run(session=sess)coord=tf.train.Coordinator()threads=tf.train.start_queue_runners(coord=coord, sess=sess)example=sess.run(fliplmageLeftRight)print example file=open (\"flippedUpDown.jpg\",\"wb+\")file.write (fliplmageUpDown.eval(session=sess))# 写入上下翻转图file.close()file=open (\"flippedLeftRight.jpg\",\"wb+\")# 写入左右翻转图file.write(fliplmageLeftRight.eval(session=sess))file.close() 流程: 创建一个文件队列对象:tf.train.string_input_producer(tf.train.match_filenames_once('xxx')) 创建一个reader对象 读取,并解码 提取特征 initialize_all_variables-&gt;Coordinator-&gt;start_queue_runners-&gt;run logit函数 logit⁡(p)=log⁡(p1−p)\\operatorname{logit}(\\mathrm{p})=\\log \\left(\\frac{\\mathrm{p}}{1-\\mathrm{p}}\\right)logit(p)=log(1−pp​) 该函数实现了从区间[0,1]到区间(-∞,+∞)之间的映射。 那么我们只要将y用一个输入的线性函数替换， 那么就实现了输入的线性变化和区间[0,1]之间的映射。 logistic函数 对数几率函数的逆函数 logit⁡−1(α)=logistic⁡(α)=11+exp⁡(−α)=ep⁡(α)exp⁡(α)+1\\operatorname{logit}^{-1}(\\alpha)=\\operatorname{logistic}(\\alpha)=\\frac{1}{1+\\exp (-\\alpha)}=\\frac{\\operatorname{ep}(\\alpha)}{\\exp (\\alpha)+1}logit−1(α)=logistic(α)=1+exp(−α)1​=exp(α)+1ep(α)​ 这是一个Sigmoid函数。 Logistic函数将使得我们能够在我们的回归任务表示为二项选择。 σ(t)=etet+1=11+e−t\\sigma(t)=\\frac{\\mathrm{e}^{t}}{\\mathrm{e}^{t}+1}=\\frac{1}{1+\\mathrm{e}^{-t}}σ(t)=et+1et​=1+e−t1​ 一般的解释就是t为一个独立变量， 该函数将t映射到区间[0,1]之 间。 但是我们提升了这个模型， 将t转变为变量x的一个线性映射(当x 是一个多变量的向量时， t就是该向量中各个元素的线性组合) 。 我们可以将t表示如下： t=wx+b 我们就能够得到以下方程 logit⁡(p)=In⁡(p1−p)=wx+b\\operatorname{logit}(\\mathrm{p})=\\operatorname{In}\\left(\\frac{p}{1-p}\\right)=w x+blogit(p)=In(1−pp​)=wx+b 对于所有的元素， 我们计算了回归方程， 得出如下概率。 p^=eβ0+β1x1+eβ0+β1x\\hat{p}=\\frac{\\mathrm{e}^{\\beta_{0}+\\beta_{1} x}}{1+\\mathrm{e}^{\\beta_{0}+\\beta_{1} x}}p^​=1+eβ0​+β1​xeβ0​+β1​x​ 线性函数的参数起什么作用呢？ 它们可以改变直线的斜率和 Sigmoid函数零的位置。 通过调整线性方程中的参数， 来缩小预测值与 真实值之间的差距。 Logistic函数的属性 函数空间中每个曲线都可以被描述成它所应用的可能目标。 具体到Logistic函数： ●事件的可能性p依赖于一个或者多个变量。 比如， 根据之前的资 历,预测获奖的可能性。 ●对于特定的观察， 估算事件发生的可能性。 ●预测改变独立变量对二项响应的影响。 ●通过计算可能性， 将观测分配到某个确定的类。 损失函数 loss =−∑iyi∙log⁡(ypredi)+(1−yi)∙log⁡(1−ypredi)=-\\sum_{i} y_{i} \\bullet \\log \\left(y p r e d_{i}\\right)+\\left(1-y_{i}\\right) \\bullet \\log \\left(1-y p r e d_{i}\\right)=−∑i​yi​∙log(ypredi​)+(1−yi​)∙log(1−ypredi​) 该损失函数的主要性质就是偏爱相似行为， 而当误差超过0.5的时 候， 惩罚会急剧增加。 多类分类应用——Softmax回归 当我们面对多于二类的情况， 通常有两种方法： 一对多和一对所 有。 ●第一类技术计算多个模型。 针对每个类都计算一个“一vs所有 (one against all) ”的概率。 ●第二类技术只计算出一个概率集合， 每个概率表示属于其中某一 类的可能性。 ●第二种技术的输出是Softmax回归格式， 这是Logistic回归对于n类 的泛化。 损失函数 loss=∑i∑cyc∙log⁡(ypredc)=∑i∑cyc∙e−xc∑j=0c−1log⁡(e−xj)loss=\\sum_{i} \\sum_{c} y_{c} \\bullet \\log \\left(y p r e d_{c}\\right)=\\sum_{i} \\sum_{c} y_{c} \\bullet \\frac{e^{-x_{c}}}{\\sum_{j=0}^{c-1} \\log \\left(e^{-x_{j}}\\right)}loss=∑i​∑c​yc​∙log(ypredc​)=∑i​∑c​yc​∙∑j=0c−1​log(e−xj​)e−xc​​ 感知器算法 简单来说就是一个二元分类函数 简化版的感知器算法如下： ① 以一个随机分布初始化权值和偏差(通常比较小) ； ② 选择一个输入向量， 并将其放入神经网络中； ③ 将输入与权重相乘， 并加上偏差， 计算网络的输出y’； ④ 感知器的函数如下： f(x)={1if w⋅x+b&gt;00otherwisef(x)=\\left\\{\\begin{array}{ll}{1} &amp; {if \\; w \\cdot x+b&gt;0} \\\\ {0} &amp; otherwise \\end{array}\\right.f(x)={10​ifw⋅x+b&gt;0otherwise​ ⑤ 如果y′≠y， 将权重wi加上Δw=yxi； ⑥ 返回第②步。 TensorFlow中损失优化方法 ●tf.train.GradientDescentOptimizer(learning_rate, use_locking, name)： 原始梯度下降方法， 唯一参数就是学习率。 ●tf.train.AdagradOptimizer： 自适应调整学习率， 累加历史梯度的平 方， 作为分母， 防止有些方向的梯度值过大， 提高优化效率， 善于处理 稀疏梯度。 ●tf.train.AdadeltaOptimizer： 扩展AdaGrad优化方法， 只累加最近的 梯度值， 而不对整个历史上的梯度值进行累加。 ●tf.train.AdamOptimizertf.train.AdamOptimizer． (learningrate, beta1, beta2, epsilon, use locking, name)： 梯度的一阶矩估计和二阶矩估计动态 调整每个参数的学习率。 Adam是自适应矩估计(Adaptive Moment Estimation) 的首字母缩写。 Sklearn预处理函数 我们看一些下面的Sklearn数据预处理函数： ●preprocessing.StandardScaler()： 数据正规化(Normalization) 是机 器学习估计的一个常见要求， 为了模型能更好地收敛， 我们通常会将数 据集预处理到一个零均值单位方差的高斯状分布。 通常， 我们会将数据 的各个维度都减去它的均值， 然后乘上一个非零的数。 这个非零的数就 是数据集的标准差。 对于该任务， 我们直接使用StandardScaler， 它已经 实现了我们上面提到的操作。 它也保留了变换操作， 让我们可以直接用 在测试集上。 ●StandardScaler .fit_transform()： 将数据调整到所需要的形式。 StandardScaler对象会存储数据变化的变量， 这样我们可以把数据解正规 化到原先的格式。 ●cross_validation.train_test_split： 该方法能够将数据集分割成训练 集和测试集。 我们只需要提供两者的比例， 该方法能够自动帮我们处 理 书籍推荐 了解tensorflow基础对象——《面向机器智能的tensorflow实践》 进阶操作tensor对象——《Tensorflow机器学习项目实战》 Hello TensorFlow import tensorflow as tf如果报错dtype…可以降低numpy的版本(从1.16-&gt;1.17) 123456789101112131415161718192021import tensorflow as tfimport numpy as npimport matplotlib.pyplot as plt% matplotlib inline a=tf.random_normal([2,20])sess=tf.Session()out=sess.run(a)x,y=outplt.scatter(x,y)plt. show()'''%matplotlib inline这是一条专门的命令，用于通知笔记本将matplotib图表直接显示在浏览器中。下面逐行分析其余代码，如果你不理解某些术语，请不必担心，后面章节还会一一进行讲解：1)用TensorFlow定义一个由随机数构成的2×20的矩阵，并将其赋给变量a。2)启动TensorFlow Session，并将其赋予一个ses对象。3)用sess.run()方法执行对象a，并将输出(NumPy数组)赋给ot。4)将这个2×20的矩阵划分为两个1×10的向量x和y。5)利用pyplot模块绘制散点图，x对应横轴，y对应纵轴。''' sess=tf.Session() Session对象在运行时负责对数据流图进行监督，并且是运行数据流图的主要接口。在本练习之后，我们还将对Session对象进行更为深入的探讨，但现在只需了解在TensorFow中，如果希望运行自己的代码，必须定义一个Session对象。上述代码将Session对象赋给了变量sess，以便后期能够对其进行访问。 target指定了所要使用的执行引擎。对于大多数应用，该参数取为默认的空字符串。在分布式设置中使用Session对象时，该参数用于连接不同的tftrain Server实例(本书后续章节将对此进行介绍)。 graph参数指定了将要在Session对象中加载的Graph对象，其默认值为None，表示将使用当前默认数据流图。当使用多个数据流图时，最好的方式是显式传入你希望运行的Graph对象(而非在一个with语句块内创建Session对象)。 config参数允许用户指定配置Session对象所需的选项，如限制CPU或GPU的使用数目，为数据流图设置优化参数及日志选项等。 Sesionnn()方法接收一个参数fetches，以及其他三个可选参数：feed_dict、options和rnn_metadata。本书不打算对options和run_metadata进行介绍，因为它们尚处在实验阶段(因此以后很可能会有变动)，且目前用途非常有限，但理解ed_dict非常重要，下文将对其进行讲解。 1.fetches参数 fetches参数接收任意的数据流图元素(Op或Tensor对象)，后者指定了用户希望执行的对象。如果请求对象为Tensor对象，则rnun()的输出将为一NumPy数组：如果请求对象为一个Op，则输出将为None。 除了利用fetches获取Tensor对象输出外，还将看到这样的例子：有时也会赋予ftches一个指向某个Op的句柄，这是在运行中的一种有价值的用法。 tf.initialize_all_variables()使是一个这样的例子，它会准备将要使用的所有TensorFow Variable对象(本章稍后将介绍Variable对象)。我们仍然将该Op传给etches参数，但Session.run()的结果将为None： 1执行初始化Variable对象所需的计算，但返回值为None sess.run(tf.initialize_all_variables()) 2.feed_dict参数 参数feed_dict用于覆盖数据流图中的Tensor对象值，它需要Python字典对象作为输入。字典中的“键”为指向应当被覆盖的Tensor对象的句柄，而字典的“值”可以是数字、字符串、列表或NumPy数组(之前介绍过)。这些“值”的类型必须与Tensor的“键”相同，或能够转换为相同的类型。下面通过一些代码来展示如何利用feed_dict重写之前的数据流图中a的值： 12345678910111213inport tensorflow as tf#创建Op、Tensor对象等(使用默认的数据流图)a=tf.add(2，5)b=tf.mul(a，3)#利用默认的数据流图启动一个Session对象sess=tf.Session()#定义一个字典，比如将a的值替换为15replace_dict=&#123;a：15&#125;#运行Session对象，将replace_dict赋给feed_dictsess.run(b，feed_dict=replace_dict)#返回45'''请注意，即便a的计算结果通常为7，我们传给eeddict的字典也会将它替换为15。在相当多的场合中，fed_dict都极为有用。由于张量的值是预先提供的，数据流图不再需要对该张量的任何普通依赖节点进行计算。这意味着如果有一个规模较大的数据流图，并希望用一些虚构的值对某些部分进行测试，TensorFlow将不会在不必要的计算上浪费时间。对于指定输入值，eed_dict也十分有用，在稍后的占位符一节中我们将对此进行介绍。''' tf.placehold 之前定义的数据流图并未使用真正的“输入”，它总是使用相同的数值5和3。我们真正希望做的是从客户那里接收输入值，这样便可对数据流图中所描述的变换 以各种不同类型的数值进行复用，借助“占位符”可达到这个目的。正如其名称所预示的那样，占位符的行为与Tesor对象一致，但在创建时无须为它们指定具体的数值。它们的作用是为运行时即将到来的某个Tensor对象预留位置，因此实际上变成了“输入”节点。利用tfplaceholderOp可创建占位符： 123456789import tensorflow as tfinport numpy as np#创建一个长度为2、数据类型为int32的占位向量a=tf.placeholder(tf.int32，shape=[2]，name=\"my_input\")#将该占位向量视为其他任意Tensor对象，加以使用b=tf.reduce_prod(a，name=\"prod_b\")c=tf.reduce_sum(a，name=\"sum_c\")#完成数据流图的定义d=tf.add(b，c，name=\"add_d\") 调用tf.placehoder()时，dtype参数是必须指定的，而shape参数可选： dtype指定了将传给该占位符的值的数据类型。该参数是必须指定的，因为需要确保不出现类型不匹配的错误。 shape指定了所要传入的Tensor对象的形状。请参考前文中对Tensor形状的讨论。shape参数的默认值为None，表示可接收任意形状的Tensor对象。 与任何Op一样，也可在fpaceholer中指定一个name标识符。 为了给占位符传入一个实际的值，需要使用Sesionnm()中的eed_dict参数。我们将指向占位符输出的句柄作为字典(在上述代码中，对应变量a)的“键”，而 将希望传入的Tensor对象作为字典的“值”： 12345678#定义一个TensorFlow Session对象sess=tf.Session()#创建一个将传给feed_dict参数的字典#键：a’，指向占位符输出Tensor对象的句柄#值：一个值为[5，3]、类型为int32的向量input_dict=&#123;a:np.array([5，3]，dtype=np.int32)&#125;#计算d的值，将input_dict的“值”传给asess.run(d，feed_dict=input_dict) 必须在eed dixt中为待计算的节点的每个依赖占位符包含一个键值对。在上面的代码中，需要计算d的输出，而它依赖于a的输出。如果还定义了一些d不依赖的其他占位符，则无需将它们包含在eed_dict中。 placeholder的值是无法计算的—如果试图将其传入Session.nn()，将引发一个异常。 Variable对象 1.创建Variable对象 Tensor对象和Op对象都是不可变的(immmtable)，但机器学习任务的本质决定了需要一种机制保存随时间变化的值。借助TensorFbw中的Varable对象，便可达到这个目的。Variabe对象包含了在对Session.un()多次调用中可持久化的可变张量值。Variabk对象的创建可通过Variabe类的构造方法tVariable()完成： 123456789101112131415inport tensorflow as tf#为Variable对象传入一个初始值3my_var=tf.Variable(3，name=\"my_variable\")#Variable对象可用于任何可能会使用Tensor对象的TensorFlbw函数或Op中，其当前值将传给使用它的Op：add=tf.add(5，my_var)mul=tf.mul(8，my_var)#Variables对象的初值通常是全0、全1或用随机数填充的阶数较高的张量。为使创建具有这些常见类型初值的张量更加容易，TensorFlow提供了大量辅助Op，如tferos()、tfones()、tfrandom normal()和tfrandomuiform()，每个Op都接收一个sape参数，以指定所创建的Tensor对象的形状：#2×2的零矩阵zeros=tf.zeros([2，2])#长度为6的全1向量ones=tf.ones([6])#3×3×3的张量，其元素服从0~10的均匀分布uniform=tf.random_uniform([3，3，3]，minval=0，maxval=10)#3×3×3的张量，其元素服从0均值、标准差为2的正态分布normal=tf.random_normal([3，3，3]，mean=0.0，stddev=2.0) 除了tfrandom normal()外，经常还会看到人们使用ttrmncated nomal()，因为它不会创建任何偏离均值超过2倍标准差的值，从而可以防止有一个或两个元素与该张量中的其他元素显著不同的情况出现： 12345#该Tensor对象不会返回任何小于3.0或大于7.0的值trunc=tf.truncated_normal([2，2]，mean=5.0，stddev=1.0)可像手工初始化张量那样将这些Op作为Variable对象的初值传入：#默认均值为0，默认标准差为1.0randon_var=tf.Variable(tf.truncated_normal([2，2])) 2.Variable对象的初始化 Variable对象与大多数其他TensorFlow对象在Graph中存在的方式都比较类似，但它们的状态实际上是由Session对象管理的。因此，为使用Varinbe对象，需要采取一些额外的步骤—必须在一个Session对象内对Variable对象进行初始化。这样会使Session对象开始追踪这个Variable对象的值的变化。Varabe对象的初始化通常是通过将tinitialize_all_variabkes()Op传给Sessionrun()完成的： 123456789init=tf.initialize_all_variables()sess=tf.Session()sess.run(init)#如果只需要对数据流图中定义的一个Variable对象子集初始化，可使用tfinitialie variables()。该函数可接收一个要进行初始化的Variable对象列表：var1=tf.Variable(0，name=\"initialize_me\")var2=tf.Variable(1，name=\"no_initialization\")init=tf.initialize_variables([var1]，name=\"init_var1\")sess=tf.Session()sess.run(init) 3.Variable对象的修改 要修改Variablk对象的值，可使用Variable.assign()方法。该方法的作用是为Variable对象赋予新值。请注意，Variable.assign()是一个Op，要使其生效必须在一个Session对象中运行： 1234567891011121314151617181920212223#创建一个初值为1的Variable对象my_var=tf.Variable(1)#创建一个Op，使其在每次运行时都将该Variable对象乘以2my_var_times_two=my_var.assign(my_var*2)#初始化Op init=tf.initialize_all_variables()#启动一个会话sess=tf.Session()#初始化Variable对象sess.run(init)#将Variable对象乘以2，并将其返回sess.run(my_var_times_two)##输出：2#再次相乘sess.run(my_var_times_two)##输出：4#再次相乘sess.run(my_var_times_two)##输出：8对于Variablk对象的简单自增和自减，TensorFlow提供了Variable.asign add()方法和Variable.assignsub()方法：#自增1sess.run(my_var.assign_add(1))#自减1sess.run(my_var.assign_sub(1)) △由于不同Session对象会各自独立地维护Varablk对象的值，因此每个Session对象都拥有自己的、在Graph对象中定义的Variabe对象的当前值： 4.trainable参数 在本书的后续章节将介绍各种能够自动训练机器学习模型的Optinmizer类，这意味着这些类将自动修改Variable对象的值，而无须显式做出请求。在大多数情况下，这与读者的期望一致，但如果要求Graph对象中的一些Variabk对象只可手工修改，而不允许使用Optimizer类时，可在创建这些Variable对象时将其raimbe参数设为False：not_trainable=tf.Variable(0，trainable=False)","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"}]},{"title":"常用域名记录解释","slug":"常用域名记录解释","date":"2019-09-17T09:47:35.000Z","updated":"2019-09-17T09:47:50.806Z","comments":true,"path":"2019/09/17/常用域名记录解释/","link":"","permalink":"https://nymrli.top/2019/09/17/常用域名记录解释/","excerpt":"","text":"常用域名记录解释 A记录 A记录是用来创建到IP地址的记录。 A记录设置技巧 1、如果想创建不带www的记录，即ezloo.com，在主机记录中填写@或者留空，不同的注册商可能不一样。 2、创建多个域名到同一个IP，比如给博客建了二级域名，可以使用*.blog.ezloo.com来指向一个IP，这样的话，不管是访问a.blog.ezloo.com还是b.blog.ezloo.com都能到同一个IP。 3、如果你给同一个二级域名设置了多个A记录，比如你建了两个blog的A记录，其中一个指向了111.111.111.111，另一个指向了111.111.111.112，那么在查询的时候，每次返回的数据包含了两个IP地址，但是在返回的过程中数据排列的顺序每次都不相同。由于大 部分的客户端只选择第一条记录所以通过这种方式可以实现一定程度的负载均衡。 在命令行下可以通过nslookup -qt=a www.ezloo.com来查看A记录。 MX记录 在命令行下可以通过 nslookup -qt=mx ezloo.com 来查看MX记录。 mx 记录的权重对 Mail 服务是很重要的，当发送邮件时，Mail 服务器先对域名进行解析，查找 mx 记录。先找权重数最小的服务器（比如说是 10），如果能连通，那么就将服务器发送过去；如果无法连通 mx 记录为 10 的服务器，那么才将邮件发送到权重为 20 的 mail 服务器上。 这里有一个重要的概念，权重 20 的服务器在配置上只是暂时缓存 mail ，当权重 20 的服务器能连通权重为 10 的服务器时，仍会将邮件发送的权重为 10 的 Mail 服务器上。当然，这个机制需要在 Mail 服务器上配置。（http://blog.ixpub.net/viewthread-1308142） CNAME记录 CNAME记录也成别名记录，它允许你将多个记录映射到同一台计算机上。比如你建了如下几条记录： a1 CNAME a.ezloo.com a2 CNAME a.ezloo.com a3 CNAME a.ezloo.com a A 111.222.111.222 我们访问a1（a2，a3）.ezloo.com的时候，域名解析服务器会返回一个CNAME记录，并且指向a.ezloo.com，然后我们的本地电脑会再发送一个请求，请求a.ezloo.com的解析，返回IP地址。 当我们要指向很多的域名到一台电脑上的时候，用CNAME比较方便，就如上面的例子，我们如果服务器更换IP了，我们只要更换a.ezloo.com的A记录即可。 在命令行下可以使用nslookup -qt=cname a.ezloo.com来查看CNAME记录。 TXT记录 TXT记录一般是为某条记录设置说明，比如你新建了一条a.ezloo.com的TXT记录，TXT记录内容&quot;this is a test TXT record.&quot;，然后你用 nslookup -qt=txt a.ezloo.com ，你就能看到&quot;this is a test TXT record&quot;的字样。 除外，TXT还可以用来验证域名的所有，比如你的域名使用了Google的某项服务，Google会要求你建一个TXT记录，然后Google验证你对此域名是否具备管理权限。 在命令行下可以使用nslookup -qt=txt a.ezloo.com来查看TXT记录。 AAAA记录 AAAA记录是一个指向IPv6地址的记录。 可以使用nslookup -qt=aaaa a.ezloo.com来查看AAAA记录。 NS记录 NS记录是域名服务器记录，用来指定域名由哪台服务器来进行解析。可以使用nslookup -qt=ns ezloo.com来查看。 TTL值 TTL=time to live，表示解析记录在DNS服务器中的缓存时间。比如当我们请求解析www.ezloo.com的时候，DNS服务器发现没有该记录，就会下个NS服务器发出请求，获得记录之后，该记录在DNS服务器上保存TTL的时间长度。当我们再次发出请求解析www.ezloo.com 的时候，DNS服务器直接返回刚才的记录，不去请求NS服务器。TTL的时间长度单位是秒，一般为3600秒。","categories":[],"tags":[{"name":"网络知识","slug":"网络知识","permalink":"https://nymrli.top/tags/网络知识/"}]},{"title":"SpringBoot学习笔记","slug":"SpringBoot学习笔记","date":"2019-09-17T09:01:40.000Z","updated":"2020-09-04T08:05:10.647Z","comments":true,"path":"2019/09/17/SpringBoot学习笔记/","link":"","permalink":"https://nymrli.top/2019/09/17/SpringBoot学习笔记/","excerpt":"","text":"Spring Boot hello word 第一个controller 12345678910111213141516171819202122232425262728/** * Project Name:demo * File Name:HelloController.java * Package Name:com.example.demo * Date:2019年9月15日下午8:27:56 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.example.demo;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @Value(\"$&#123;cupsize&#125;\") private String cupsize; @RequestMapping(value=\"hello\",method= RequestMethod.GET)// @GetMapping(\"/hello\") public String say() &#123; return cupsize; &#125;&#125; application.yml 12345678server: port: 5000# servlet:# context-path: /girlcupsize: Bspring.datasource.url: jdbc:mysql://127.0.0.1:3306/spring.datasource.username: root spring.datasource.password: 123456spring.datasource.driver-class-name: com.mysql.jdbc Controller的使用 @Controller处理http请求Spring4之后新加的注解，原来返回json 需要返回模板,即return “index”; 需要在POM.XML中添加spring-boot-starter-thymeleaf的依赖 1234&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; @RestController等价于&lt;==&gt;@Controller+@ResponseBody 可以返回JSON格式 @RequestMapping 配置url映射 ▲如果没有指定Method那么所有方式都可以 给某个方法指定url路由 @RequestMapping(value={&quot;/hello&quot;,&quot;/hil&quot;},method=RequestMethod.GET) 给整个class指定路由 123456789101112131415161718192021222324252627/** * Project Name:demo * File Name:HelloController.java * Package Name:com.example.demo * Date:2019年9月15日下午8:27:56 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.example.demo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(value=\"/hello\")public class HelloController &#123; @Autowired private GirlProperties girlProperties; @RequestMapping(value = \"/say\", method= RequestMethod.GET) public String say() &#123; return girlProperties.getCupSize(); &#125;&#125; @RequestMapping(value=xxx,method=RequestMethod.GET)等价于XxxMapping GetMapping PostMapping @PathVariable 1234@RequestMapping(value = \"/say/&#123;id&#125;\", method= RequestMethod.GET)public String say(@PathVariable(\"id\") Integer id) &#123;return \"id:\" + id;&#125; @RequestParam 12345678910@RequestMapping(value = \"/say\", method= RequestMethod.GET)public String say(@RequestParam(\"id\") Integer mid) &#123; return \"id:\" + mid;&#125;@RequestMapping(value = \"/say\", method= RequestMethod.GET) // defaultValue值必须为String public String say(@RequestParam(value=\"id\", required=false, defaultValue=\"0\") Integer mid) &#123; return \"id:\" + mid; &#125; 数据库管理 JPA（Java Persistence APl）定义了一系列对象持久化的标准，目前实现这一规范的产品有Hibernate、TopLink等。 启用JPA application.yml 123456789101112spring: profiles: active: dev datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/dbgirl?characterEncoding=utf-8&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC username: root password: cl123123 jpa: hibernate: ddl-auto: create show-sql: true 增删改查CURD 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Project Name:demo * File Name:Girl.java * Package Name:com.example.demo * Date:2019年9月16日下午6:34:14 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.example.demo;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entitypublic class Girl &#123; @Id @GeneratedValue private Integer id; private String cupSize; private Integer age; public Girl() &#123; // TODO Auto-generated constructor stub &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getCupSize() &#123; return cupSize; &#125; public void setCupSize(String cupSize) &#123; this.cupSize = cupSize; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"&#123;\\\"id\\\":\\\"\" + id + \"\\\",\\\"cupSize\\\":\\\"\" + cupSize + \"\\\",\\\"age\\\":\\\"\" + age + \"\\\"&#125; \"; &#125;&#125; GirlControllr.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Project Name:demo * File Name:GirlController.java * Package Name:com.example.demo * Date:2019年9月17日下午3:44:06 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.example.demo;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GirlController &#123; @Autowired private GirlRepository girlRepository; @GetMapping(value= \"/girls\") public List&lt;Girl&gt; girlList()&#123; return girlRepository.findAll(); &#125; @PostMapping(value = \"/girls\") public Girl addGirl(@RequestParam(\"cupSize\") String cupSize, @RequestParam(\"age\") Integer age) &#123; System.out.println(\"cupsize\"+cupSize); Girl girl= new Girl(); girl.setCupSize(cupSize); girl.setAge(age); return girlRepository.save(girl); &#125; @GetMapping(value=\"/girls/&#123;id&#125;\") public Girl girlFindOne(@PathVariable(\"id\") Integer id) &#123; return girlRepository.findById(id).get();// return girlRepository.getOne(id); 无效，需要实例json &#125; @PutMapping(value=\"/girls/&#123;id&#125;\") public Girl girlUpdate(@PathVariable(\"id\") Integer id, @RequestParam(\"cupSize\") String cupSize, @RequestParam(\"age\") Integer age) &#123; Girl girl = new Girl(); girl.setId(id); girl.setAge(age); girl.setCupSize(cupSize); return girlRepository.save(girl); &#125; @DeleteMapping(value=\"/girls/&#123;id&#125;\") public void girlDelete(@PathVariable(\"id\") Integer id) &#123; girlRepository.deleteById(id); &#125; @GetMapping(value=\"/girls/age/&#123;age&#125;\") public List&lt;Girl&gt; girlListByAge(@PathVariable(\"age\") Integer age)&#123; return girlRepository.findByAge(age); &#125;&#125; ▲注意.视频中的findOne已经被淘汰，因为springboot版本问题，新的版本不再支持findone(id)方法。 可用findById(id).get()或getOne(id)来替换，区别是前者当参数id为空时返回null，后者直接报异常，因为getOne返回的是对象的引用。 我试了下getOne会报错，据说是要设置json的返回格式？ 自定义搜索方式findByAge 12345678910111213141516171819/** * Project Name:demo * File Name:GirlRepository.java * Package Name:com.example.demo * Date:2019年9月17日下午3:44:33 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.example.demo;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;public interface GirlRepository extends JpaRepository&lt;Girl, Integer&gt;&#123; public List&lt;Girl&gt; findByAge(Integer age);&#125; 数据库事务管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Project Name:demo * File Name:GirlController.java * Package Name:com.example.demo * Date:2019年9月17日下午3:44:06 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ @PostMapping(value = \"/girls/two\") public void girlTwo() &#123; girlService.insertTwo(); &#125;/** * Project Name:demo * File Name:GirlService.java * Package Name:com.example.demo * Date:2019年9月17日下午4:39:00 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.example.demo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class GirlService &#123; @Autowired private GirlRepository girlRepository; @Transactional public void insertTwo() &#123; Girl girlA = new Girl(); girlA.setCupSize(\"A\"); girlA.setAge(18); girlRepository.save(girlA); Girl girlB = new Girl(); girlB.setCupSize(\"BBBB\"); girlB.setAge(19); girlRepository.save(girlB); &#125;&#125; 在项目开发过程中，使用了Spring data jpa自动创建表。但是默认情况下，创建出来的表类型为MyISAM。 （MySQL数据库默认的存储引擎类型是MyISAM，这种存储引擎类型不支持事务处理。）改成InnoDB存储引擎会就可以了。 123456jpa: database: MYSQL hibernate: ddl-auto: update show-sql: true database-platform: org.hibernate.dialect.MySQL5InnoDBDialect 在navicat中数据库—&gt;表—&gt;单击表名，在右边可以出现表的所有信息 Spring Boot 2.0深度实践-初遇Spring Boot 多模块：web、persistence、mdel 项目打包——多模块重构后 运行模式 IDEA: 有图形界面的开发环境 JAR/WAR: 线上、服务器上的生产环境 123$ mvn install $ cd target$ java -jar MAVEN插件: 无图形界面的开发环境 mvn spring-boot:run 热加载： pom.xml中加上依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 热部署: 就是容器状态在运行的情况下重新部署整个项目.在这种情况下一般整个内存会清空,重新加载.简单来说就是Tomcat或者其他的web服务器会帮我们重新加载项目.这种方式可能会造成sessin丢失等情况. 热加载: 就是容器状态在运行的情况下重新加载改变编译后的类.在这种情况下内存不会清空,sessin不会丢失,但容易造成内存溢出,或者找不到方法。因为内存无法转变成对像.一般改变类的结构和模型就会有异常，在已经有的变量和方法中改变是不会出问题的 2020.5.29 春招上岸了, 准备下后端的相关开发知识 注解含义 @SpringBootApplication内容-&gt;configuration配置相关 1234567891011121314151617@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited// 上述四个为元注解, 不需要看@SpringBootConfiguration // 表示这是一个配置类, 由原来spring中的configuration封装而成(代替xml)@EnableAutoConfiguration // 允许自动配置@ComponentScan( // 扫描设置: 指定IOC容器扫描的包 excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;) @EnableAutoConfiguration 1234567891011121314@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage // 指定自动配置的包@Import(&#123;AutoConfigurationImportSelector.class&#125;) // Import指定导入某个类 // AutoConfigurationImportSelector 为导入选择器public @interface EnableAutoConfiguration &#123; // 自动导入配置 String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; @AutoConfigurationPackage 12345678910@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;Registrar.class&#125;) // 通过Registrar将主启动类所在包和它的子包中所有的组件扫描到IOC容器中public @interface AutoConfigurationPackage &#123; // 指定自动配置的包 String[] basePackages() default &#123;&#125;; Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;&#125; 1234567891011121314151617public abstract class AutoConfigurationPackages &#123; // ... static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; Registrar() &#123; &#125; // 静态内部类 public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; AutoConfigurationPackages.register(registry, (String[])(new AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(new String[0])); // 第二个参数: 找到主启动类的包及其子包 &#125; public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.singleton(new AutoConfigurationPackages.PackageImports(metadata)); &#125; &#125; &#125; 主动导入的配置在:External Library-&gt; META-INF/spring.factories-&gt;Maven: org.springframework.boot:spring-boot-autoconfigure:2.3.0.RELEASE 1234# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ 随便点一个进去可以看到, 比如redis 123456789101112131415161718@Configuration( proxyBeanMethods = false)@ConditionalOnClass(&#123;EnableRedisRepositories.class&#125;)@ConditionalOnBean(&#123;RedisConnectionFactory.class&#125;)@ConditionalOnProperty( // 会去读properties文件， 如果读取到了相关参数参会加载 prefix = \"spring.data.redis.repositories\", name = &#123;\"enabled\"&#125;, havingValue = \"true\", matchIfMissing = true // 如果不存在也行)@ConditionalOnMissingBean(&#123;RedisRepositoryFactoryBean.class&#125;)@Import(&#123;RedisRepositoriesRegistrar.class&#125;)@AutoConfigureAfter(&#123;RedisAutoConfiguration.class&#125;)public class RedisRepositoriesAutoConfiguration &#123; public RedisRepositoriesAutoConfiguration() &#123; &#125;&#125; 12345678910111213141516171819202122232425262728@Configuration( proxyBeanMethods = false)@ConditionalOnWebApplication( type = Type.SERVLET)@ConditionalOnClass(&#123;WebServlet.class&#125;)@ConditionalOnProperty( // 会去读properties文件， 如果读取到了相关参数参会加载 prefix = \"spring.h2.console\", name = &#123;\"enabled\"&#125;, havingValue = \"true\", matchIfMissing = false // 如果不存在就不会加载)@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class&#125;)@EnableConfigurationProperties(&#123;H2ConsoleProperties.class&#125;) // 允许通过properties文件加载public class H2ConsoleAutoConfiguration &#123; // ...&#125;// 。。。@ConfigurationProperties( prefix = \"spring.h2.console\" // 通过properties文件配置， 读取前缀为\"spring.h2.console\"的设置)public class H2ConsoleProperties &#123; // ...&#125; @ComponentScan： 表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service、@Repository等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。 如果没有配置的话，Spring Boot中@SpringBootApplication会扫描启动类所在包下以及子包下的组件。 @bean注解: 相当于xml中的bean标签, 标注在方法上，用于把一个类对象加入IOC容器(返回某个实例的方法)，交给spring管理（官网解释：bean是一个由Spring IoC容器实例化、组装和管理的对象。）。并且注意，Spring上加@Bean注解的都是默认单例模式 参考： https://www.awaimai.com/2596.html ioC：在 Spring 中，类的实例化、依赖的实例化、依赖的传入都交由 Spring Bean 容器控制，而不是用new方式实例化对象、通过非构造函数方法传入依赖等常规方式。在Spring中，我们基本不需要 new 一个类，这些都是让 Spring 去做的。Spring 启动时会把所需的类实例化成对象，如果需要依赖，则先实例化依赖，然后实例化当前类。 依赖注入:因为依赖必须通过构建函数传入，所以实例化时，当前类就会接收并保存所有依赖的对象。 @Import注解: 相对于@bean注解, 可以更便捷地将一个类加入IOC容器 @condition*注解: 一个类满足特定的条件时才加入IOC容器（实例化对象） @RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。 @RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。 @ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@Responsebody后返回结果不会被解析为跳转路径(直接return 'index'表示跳转到index.html)，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。 @RequestBody将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。 SpringBoot提供的获取参数注解包括：@PathVariable，@RequestParam，@RequestBody,三者的区别如下 接收json数据一定需要使用@RequestBody @RequestParam: 表示从请求参数中获取的, 比如表单参数username @RequestVariable: 表示从url中提取的, 比如&quot;/user/{id}&quot;, 则写成@RequestVariable(&quot;id&quot;) Integer id @Propertysource: 可以指定读取的配置文件，跟@Value一起使用 @Value：注入Spring boot application.properties配置的属性的值 @Autowired：自动导入依赖的bean, bean都是独立的, 但实际工作中，很多对象会依赖其他对象完成任务。这时候就需要能够将组件扫描得到的bean和他们依赖装配在一起 annotation之@Autowired、@Inject、@Resource三者区别 @ImportResource：用来加载xml配置文件。 @Configuration和@Bean @Configuration 和@Bean Spring的Java配置方式是通过@Configuration和@Bean 这两个注解实现的： 1、@Configuration作用于类上，相当于一个xml配置文件； 2、@Bean作用于方法上，相当于xml配置中的&lt;bean&gt;；启动过程中会IOC容器找到Bean注解后会执行。要获得@Bean标注的对象时通过@Autowired从IOC容器中得到 SpringBoot工作原理 读取spring.factories文件 SpringBoot启动时会读取spring-boot-autoconfigure-2.1.6.RELEASE.jar包下的META-INF/spring.factories文件。读取org.springframework.boot.autoconfigure.EnableAutoConfiguration属性的值加载自动配置类。 加载XxxProperties类 根据自动配置类中指定的XxxProperties类设置自动配置的属性值，开发者也可以根据XxxProperties类中指定的属性在yml配置文件中修改自动配置。 根据@ConditionalXxx注解决定加载哪些组件 SpringBoot通过@ConditionalXxx注解指定特定组件加入IOC容器时所需要具备的特定条件。这个组件会在满足条件时加入IOC容器。 https://www.bilibili.com/video/BV1KE411K7PH?p=17 spring boot自动配置原理 spring boot中的@EnableAutoConfiguration注解的作用就是开启自动配置，正是因为开启了自动配置，开发者在使用spring boot的时候就不用再填写繁琐的的配置项了，那么spring boot是如何实现这个自动配置的呢? spring boot会根据开发者添加的依赖判断是否使用了某个技术，比如在依赖中有DispatcherServlet，那就说明使用了spring mvc技术。 spring boot判断出开发者所使用的技术之后（导入相关依赖），会从自动配置（AutoConfigure）相关的包下找到该技术相关的配置类。 spring boot会加载这些配置类，如果配置文件有写相关的配置信息的话会将该信息读取到配置类的对象中，然后加载到spring容器中，这样就完成了自动配置了。 在spring boot中自动配置类和配置类命名都是符合下面格式的: 自动配置类——*AutoConfiguration; 配置类——*Properties ▲如果不需要自动配置，可以@SpringBootApplication(exclude={RedisAutoConfiguration.class}) Springboot启动类 参考: https://www.bilibili.com/video/BV1sc411h7pN?p=8 配置文件 存放位置 当前项目根目录中 当前项目根目录下的一个/config子目录中 项目的resources即classpath根路径中 项目的resources即classpath根路径下的/config目录中 配置文件加载顺序 不同格式的加载顺序: 如果同一个目录下，有application.yml也有application.properties，默认先读取application.properties。 如果同一个配置属性，在多个配置文件都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的。 不同位置的加载顺序: 当前项目根目录下的一个/config子目录中(1最高) 当前项目根目录中（2其次） 项目的resources即classpath根路径下的/config目录中(3一般) 项目的resources即classpath根路径中(4最后) SpringBoot2.x整合redis 我是先尝试的thymeleaf,弄了我一下午;接着是mybatis也弄了很久;最后才是redis, 虽然是因为解决了IDEA的Maven问题, 但确实也是redis连接最简单 1.[官网下载Redis](https://redis.io/download， 因为windows支持的不好， 因此还是直接在服务器上使用 1234567$ wget http://download.redis.io/releases/redis-6.0.4.tar.gz$ tar xzf redis-6.0.4.tar.gz$ cd redis-6.0.4$ make$ cd src$ ./redis-server # 启动server服务$ ./redis-cli # 使用redis, 类似shell 外网连接设置 sudo vim /home/mrli/redis-6.0.4/redis.conf 将bind 127.0.0.1注释掉（含义为绑定可访问IP， 也就是说只能通过127.0.0.1访问） 将protected-mode yes设置为protected-mode no 解释: 默认情况bind=127.0.0.1只能接受本机的访问请求 不写的情况下，无限制接受任何ip地址的访问 如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的相应 fromB站视频: https://www.bilibili.com/video/BV1J4411x7U1?p=45 3.使用Springboot整合 设置依赖 yml配置IP 编写连接Test Springboot整合代码[代码重工]: http://39.108.113.88/content/country-spring-boot/detail/spring-boot-08 SpringBoot2.x整合Thymeleaf 问题: 我默认从创建工程的SpringBoot版本是2.3.0， 然后直接导入maven依赖， 在IDEA中是显示红色，无法使用的。==&gt;按照thymeleaf官方提供的2.3.0的导入方法仍然无效 A： 降低Springboot版本为2.1.14, 问题解决 问题罗列 浏览器显示: -&gt;没有配置路由 123456Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Fri May 29 15:30:09 CST 2020There was an unexpected error (type=Not Found, status=404).No message available 浏览器显示: -&gt;找不到模板 controller中返回的模板名与html文件名不一致 yml配置中prefix: classpath:/templates/设置错误，缺少末尾的/ 123456Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Fri May 29 15:30:49 CST 2020There was an unexpected error (type=Internal Server Error, status=500).Error resolving template [hello], template might not exist or might not be accessible by any of the configured Template Resolvers 成功案例 yml配置文件内容 123456789spring: thymeleaf: # 配置模板路径，默认是templates，可以不用配置 prefix: classpath:/templates/ # 要注意/的数量与位置 suffix: .html # 编码 可不用配置 encoding: UTF-8 # 开发配置为false,避免修改模板还要重启服务器 cache: false controller内容 123456789@Controllerpublic class ThymeLeafGo &#123; @RequestMapping(\"/test/thymeleaf\") public String testThymeleaf() &#123; System.out.println(\"yes\"); return \"hello\"; &#125;&#125; hello.html内容 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p th:text=\"经过服务器处理后可以看到的内容\"&gt;直接打开HMTL查看到的内容&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 文档教程: SpringBoot整合Thymeleaf-基于SpringBoot2.X版本 Thymeleaf语法: th:text：文本替换； th:value：属性赋值 th:each：遍历循环元素 th:if：判断条件，类似的还有th:unless，th:switch，th:case ${...} 变量表达式，Variable Expressions @{...} 链接表达式，Link URL Expressions #{...} 消息表达式，Message Expressions ~{...} 代码块表达式，Fragment Expressions *{...} 选择变量表达式，Selection Variable Expressions 常用的内置对象(用${#xxx}提取) ctx ：上下文对象。 vars ：上下文变量。 locale：上下文的语言环境。 request：（仅在web上下文）的 HttpServletRequest 对象。 response：（仅在web上下文）的 HttpServletResponse 对象。 session：（仅在web上下文）的 HttpSession 对象。 servletContext：（仅在web上下文）的 ServletContext 对象 常用的内置方法(用${#xxx}提取) strings：字符串格式化方法，常用的Java方法它都有。比如：equals，equalsIgnoreCase，length，trim，toUpperCase，toLowerCase，indexOf，substring，replace，startsWith，endsWith，contains，containsIgnoreCase等 numbers：数值格式化方法，常用的方法有：formatDecimal等 bools：布尔方法，常用的方法有：isTrue，isFalse等 arrays：数组方法，常用的方法有：toArray，length，isEmpty，contains，containsAll等 lists，sets：集合方法，常用的方法有：toList，size，isEmpty，contains，containsAll，sort等 maps：对象方法，常用的方法有：size，isEmpty，containsKey，containsValue等 dates：日期方法，常用的方法有：format，year，month，hour，createNow等 SpringBoot2.x整合Mybatis 最大的问题还是依赖问题， 在pom.xml写入了但是没生效。重建一个新项目， 更换了IDEA的Maven后问题解决 先放个成功的结果 12345678910111213141516171819202122232425 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.1.14.RELEASE)2020-05-29 20:21:38.066 INFO 9096 --- [ main] c.e.demo.test.DemoApplicationTests : Starting DemoApplicationTests on Mrli-computer with PID 9096 (started by Mr.li in G:\\SpringBootProject\\batis)2020-05-29 20:21:38.066 DEBUG 9096 --- [ main] c.e.demo.test.DemoApplicationTests : Running with Spring Boot v2.1.14.RELEASE, Spring v5.1.15.RELEASE2020-05-29 20:21:38.067 INFO 9096 --- [ main] c.e.demo.test.DemoApplicationTests : No active profile set, falling back to default profiles: default2020-05-29 20:21:40.807 INFO 9096 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService &apos;applicationTaskExecutor&apos;2020-05-29 20:21:41.700 INFO 9096 --- [ main] c.e.demo.test.DemoApplicationTests : Started DemoApplicationTests in 4.224 seconds (JVM running for 5.81)2020-05-29 20:21:42.163 ERROR 9096 --- [ main] com.alibaba.druid.pool.DruidDataSource : testWhileIdle is true, validationQuery not set2020-05-29 20:21:42.179 INFO 9096 --- [ main] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; inited2020-05-29 20:21:42.451 DEBUG 9096 --- [ main] c.e.demo.mapper.EmpMapper.selectAll : ==&gt; Preparing: select emp_id empId, emp_name empName, emp_age empAge from emp 2020-05-29 20:21:42.490 DEBUG 9096 --- [ main] c.e.demo.mapper.EmpMapper.selectAll : ==&gt; Parameters: 2020-05-29 20:21:42.530 DEBUG 9096 --- [ main] c.e.demo.mapper.EmpMapper.selectAll : &lt;== Total: 22020-05-29 20:21:42.533 DEBUG 9096 --- [ main] c.e.demo.test.DemoApplicationTests : Emp&#123;empId=12, empName=&apos;cl&apos;, empAge=18&#125;2020-05-29 20:21:42.533 DEBUG 9096 --- [ main] c.e.demo.test.DemoApplicationTests : Emp&#123;empId=14, empName=&apos;qsy&apos;, empAge=19&#125;2020-05-29 20:21:42.560 INFO 9096 --- [ Thread-1] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; closed2020-05-29 20:21:42.562 INFO 9096 --- [ Thread-1] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService &apos;applicationTaskExecutor&apos; 项目目录树 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.14.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; src-main-resources-application.yml 12345678910111213141516171819202122232425262728293031323334server: port: 8888spring: thymeleaf: suffix: .html #模板的模式，支持 HTML, XML TEXT JAVASCRIPT # mode: HTML5 #编码 可不用配置 encoding: UTF-8 #开发配置为false,避免修改模板还要重启服务器 cache: false #配置模板路径，默认是templates，可以不用配置 prefix: classpath:/templates/ datasource: name: mydb type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://127.0.0.1:3306/smybatis?serverTimezone=UTC username: root password: * driver-class-name: com.mysql.cj.jdbc.Drivermybatis: mapper-locations: classpath*:/mybatis/mapper/*Mapper.xmllogging: level: com: example: demo: mapper: debug test: debug src-main-resources-EmpMapper.yml 123456789&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.example.demo.mapper.EmpMapper\"&gt; &lt;select id=\"selectAll\" resultType=\"com.example.demo.entity.Emp\"&gt; select emp_id empId, emp_name empName, emp_age empAge from emp &lt;/select&gt;&lt;/mapper&gt; src-main-java-DemoApplication.java 123456789101112package com.example.demo;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@MapperScan(\"com.example.demo.mapper\") //在上面的dao接口中，我们添加了@mapper注解，这样spring boot就可以扫描到该接口从而使用// mybatis动态代理了。除了这种方式之外，可以在spring boot的启动类上添加@MapperScan注解，这样就无需再dao接口上添加@mapper注解了。@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123;SpringApplication.run(DemoApplication.class, args);&#125;&#125; src-main-java-com.example.demo.mapper 123456789101112131415161718package com.example.demo.mapper;import com.example.demo.entity.Emp;import java.util.List;/** * @Program: demo * @Description: * @Author: MrLi * @Create: 2020-05-29 19:51 **/public interface EmpMapper &#123; List&lt;Emp&gt; selectAll();&#125; src-main-java-com.example.demo.entity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.example.demo.entity;/** * @Program: demo * @Description: * @Author: MrLi * @Create: 2020-05-29 19:50 **/public class Emp &#123; private Integer empId; private String empName; private Integer empAge; public Emp(Integer empId, String empName, Integer empAge) &#123; this.empId = empId; this.empName = empName; this.empAge = empAge; &#125; public Emp() &#123; &#125; public Integer getEmpId() &#123; return empId; &#125; public void setEmpId(Integer empId) &#123; this.empId = empId; &#125; public String getEmpName() &#123; return empName; &#125; public void setEmpName(String empName) &#123; this.empName = empName; &#125; public Integer getEmpAge() &#123; return empAge; &#125; public void setEmpAge(Integer empAge) &#123; this.empAge = empAge; &#125; @Override public String toString() &#123; return \"Emp&#123;\" + \"empId=\" + empId + \", empName='\" + empName + '\\'' + \", empAge=\" + empAge + '&#125;'; &#125;&#125; com.example.demo.test 1234567891011121314151617181920212223242526272829303132package com.example.demo.test;import com.example.demo.entity.Emp;import com.example.demo.mapper.EmpMapper;import org.junit.jupiter.api.Test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTestclass DemoApplicationTests &#123; @Autowired private EmpMapper empMapper; // IDEA上有波浪线, 提示Could not autowire. No beans of 'EmpMapper' type found. 但可运行 private Logger logger = LoggerFactory.getLogger(DemoApplicationTests.class); @Test public void testSelectAll() &#123; List&lt;Emp&gt; emps = empMapper.selectAll(); for (Emp emp : emps) &#123;// System.out.println(emp); logger.debug(emp.toString()); &#125; &#125;&#125; 视频提供的代码配置链接: http://39.108.113.88/content/country-spring-boot/detail/spring-boot-07 上述几个整合教程来自B站: https://www.bilibili.com/video/BV1KE411K7PH/?p=20&amp;t=790 [SpringBoot2.x整合SpringDataJPA 文档链接: https://www.cnblogs.com/wadmwz/p/10313495.html ★B站视频链接:https://www.bilibili.com/video/BV1v4411G72q?p=8 包括之前几个内容的整合都可以观看这个视频, 这个质量高一点 代码组成: 12345678910111213141516171819202122// PersonController.java@RestControllerpublic class PersonController &#123; @Autowired PersonRepository personRepository; @GetMapping(\"/findall\") public List&lt;Person&gt; findAll() &#123; List&lt;Person&gt; personRepositoryAll = personRepository.findAll(); return personRepositoryAll; &#125; @GetMapping(\"/findById/&#123;id&#125;\") public Person findById(@PathVariable(\"id\") Integer id) &#123; return personRepository.findById(id).get(); &#125; @PostMapping(\"/save\") public Person save(@RequestBody Person person)&#123; return personRepository.save(person); &#125;&#125; 123456789101112// Person.java@Data@Entity // ▲记得加public class Person &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column private String username; @Column private String password;&#125; 12345678910111213// PersonRepository.java//CREATE DATABASE if not exists person;// use person;// CREATE table if not EXISTS person (// id int(11) auto_increment,// username varchar(24) ,// `password` varchar(24),// PRIMARY key(id)// );// TODO: 需要将库和表生成好, 如果需要自动建库建表, 按照文档说明的增加jpa的properties配置public interface PersonRepository extends JpaRepository&lt;Person, Integer&gt; &#123;&#125; 123456789101112# application.yml datasource: name: mydb url: jdbc:mysql://127.0.0.1:3306/person?serverTimezone=UTC username: root password: cl123123 driver-class-name: com.mysql.cj.jdbc.Driver jpa: show-sql: true properties: hibernate: format_sql: true 实体类定义规则 PO，entity:persistent object 持久对象 有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。 Vo: view object 表现层对象 主要对应页面显示（web页面/swt、swing界面）的数据对象。 可以和表对应，也可以不，这根据业务的需要。 DTO（TO）：Data Transfer Object 数据传输对象 比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。 POJO:plain ordinary java object 无规则简单java对象 一个中间对象，可以转化为PO、DTO、VO。 POJO持久化之后==&gt;PO POJO用作表示层==&gt;VOI POJO传输过程中==&gt;DTO application.yml常用配置 12345spring.mvc.static-path-pattern=classpath:/# 更多可查看ResourceProperties类中# private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]&#123;&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;&#125;;server.port=8889 12345678910111213141516171819202122232425262728# tomcat相关server: port: 8889# sping相关spring: datasource: name: mydb url: jdbc:mysql://127.0.0.1:3306/person?serverTimezone=UTC username: root password: cl123123 driver-class-name: com.mysql.cj.jdbc.Driver # jpa相关 jpa: show-sql: true properties: hibernate: format_sql: true # 关闭默认图标 mvc: favicon: enabled: false# mybatis mybatis: mapper-locations: classpath*:/mybatis/mapper/*Mapper.xml# 日志logging: level: com.atguigu.spring.boot.mapper: debug","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://nymrli.top/tags/Web/"}]},{"title":"如何成为一位老司机——考驾照经历","slug":"如何成为一位老司机——考驾照经历","date":"2019-09-14T04:32:33.000Z","updated":"2019-09-15T08:07:31.044Z","comments":true,"path":"2019/09/14/如何成为一位老司机——考驾照经历/","link":"","permalink":"https://nymrli.top/2019/09/14/如何成为一位老司机——考驾照经历/","excerpt":"","text":"如何成为一位老司机——考驾照经历 大一下报的名，几经转折，终于在2019-9-12，中秋放假前一天拿到了本本。 科一理论考试 太久远了，已经忘记了… 科二 训练 倒车入库： 左边小镜子底座盖过黄线，向左打死。 正手倒车时，靠近左边直角距离3个手指回正，然后看左边镜子出现直角，然后。 左手是一到二指头。 ▲入库重在自己调整，记住准则：左右镜子，哪边空隙大，方向盘往哪边打 小四项： 直角转弯: 人在路中间，直角重合于车窗黑线后向左打死。 S弯道： 确保人在路中间，可以略微偏左。左边小镜子底座压住右边黄线。方向盘一圈右手放在2点方向。如果黄线偏下，那么往1点方向调整，否则往3点方向调整。然后保持到车头中间碰到左边黄线回正；然后向前一小段距离，使得右边镜子与黄线只差一条线的距离，然后向右一圈，左手11点，保持小镜子与黄线夹角是钝角，然后一直保持到项目结束。 坡道停车： 对准坡道上的黄线大约在车头的右边三分之一处。上去之后，保持黄线在小镜子的左边三分之一处，大约与车身成三角形，接近接触。 侧方停车： 车头盖过蓝线后看右边后视镜，到第二根白线在后视镜中央开始倒车，直至消失时，向右一圈到11点，然后保持直至右边的黄线跑到两个把手的中间时回正，接着看左边，头伸出一点，看后车轮压倒虚线时立马向左打死，然后直至车身完全进入。 出去时，左方向灯和换1档，缓速出来，等到车头中央碰到黄线时回正，然后稍微开个0.5s向后一圈左右，车身回正。 视频资源——SXH科二教练,提取码：gvqa 考试 我考的是6号线，也就是S弯结束后立马是直角的那条线。考试的直角给我的感觉是比谷峰训练的时候多很多，所以其实不用担心。至于这个S弯结束后立马是直角，根据模拟的时候开就行了，即出来就向右打死，然后开到路中间 科三 灯光+上路行驶 训练 灯光 起步和靠边停车 图片来自于科三教练——杨作栋 考试 科三比科二简单很多。科二10节课，科三只有8节也能说明一二。但感觉科三与科二最不同的地方是，科三记的点比科二自然很多。在转头看左右后视镜，我在临近考试的最后两天最后一节课上才练的，一开始觉得右边的后视镜为什么离得那么远，跑了两圈后就发现，看后视镜是件很自然的事，因为你就需要右边的信息。 而在考试过程中，虽然有安全员在旁边，可能会比科二紧张一些，但是整体上来讲，科三还是很容易的，只要记得，每次完成一个东西后，左右看后视镜基本上就行了。 ▲.我考试的时候，前面有个挂了的人倒是补上了我一个盲点，原来提示前方路口后，如果你打了右方向灯，那么接着往后看。之前我还以为只有真过路口、点刹的时候才需要。只不过面对这种现象，还是之前说的，不管做了什么，左右摇头就是了。 挂到五档也不用担心，我当时考试时有两条路的路况绝对算不上好，但是我一共还是3次挂到了五档，所以其实升挡的机会还是很多的。 最后，需要注意的是灯光一定不能错。我是第三个考的，第一个女生灯光挂了一次；第二个男生，起步没打左方向灯，也挂了。 科四理论考试 刷了1280道题，由于有10道多选题的存在，所以真正考试的时候还是比较慌的，一上来就错了两题，最终考了94.","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"软件测试大赛","slug":"软件测试大赛","date":"2019-09-14T04:07:12.000Z","updated":"2019-11-02T02:05:41.344Z","comments":true,"path":"2019/09/14/软件测试大赛/","link":"","permalink":"https://nymrli.top/2019/09/14/软件测试大赛/","excerpt":"","text":"软件测试大赛 初学流程 首先了解比赛,查看帮助文档平台帮助 然后在工具下载中下载工具、eclipse插件 最后根据教程中将插件安装好即可 移动应用测试开发 环境配置 配置Java环境 略,见Java 开发环境配置_菜鸟教程 安装ADB 1.菜单——&gt;Tools——&gt;Settings，将Server地址为 mirrors.neusoft.edu.cn， 端口 80 ，并且在Others里勾选 Force https://…,最后一定要选择菜单——&gt;Packages菜单——&gt;Reload 注:其他可用的镜像 2.把 Android SDK 路径下的tools 和 platform-tools 两个目录路径加入到系统环境变量 Path 3.在终端(cmd)输入命令 adb ，回车，输出 adb 版本和帮助信息说明环境配置成功 安装Node.js 略 安装Appium 1)下载安装文件： http://pan.baidu.com/s/1jGvAISu Windows 下载zip文件，MAC请下载dmg 2)直接双击appium-installer.exe文件安装就好(务必记住安装路径)，桌面会生成一个Appium的图标 此时已经可以通过Appium在桌面快捷方式启动Appium桌面应用程序，并点击应用程序右上侧启动状按钮启动Appium，若成功启动会输出数行[info]级别的日志，打印出Appium server启动成功后占用的端口。 如果无法显示appium-doctor,可以npm install -g appium安装 UIautomatorviewer使用 Android 4.1发布的，uiautomator是用来做UI测试的。也就是普通的手工测试，点击每个控件元素 看看输出的结果是否符合预期。比如 登陆界面 分别输入正确和错误的用户名密码然后点击登陆按钮看看是否能否登陆以及是否有错误提示等。 找到Andriod sdk安装目录下的uiautomatorviewer.bat,E:\\android-sdk-windows\\tools\\uiautomatorviewer.bat,双击打开 由于自动获得手机信息失败,因此我只能通过手工进行获取 123Error obtaining UI hierarchyReason:Error while creating temporary file to save snapshot:null 自动导入成功的结果： 手工获取手机信息 据说Andriod8.0以上就无法使用uiautomator直接连接了，因此需要截图一步步操作 123456# dump资源文件 再导出到本地$ adb shell uiautomator dump$ adb pull /sdcard/window_dump.xml# 获取截图 导出$ adb shell screencap -p /data/local/tmp/app.png$ adb pull /data/local/tmp/app.png . 或者编写bat脚本 1234567@echo onadb shell uiautomator dump /sdcard/app.uixadb pull /sdcard/app.uix .adb shell screencap -p /sdcard/app.pngadb pull /sdcard/app.png . 传到Window里，有了截图文件和资源文件，点击UI Automator Viewer菜单栏第一个图标手工导入后即可解析，分析UI 获取快照 当你要分析一个页面时，首先将手机的页面停留在你要分析的页面，然后用数据线连接电脑。 页面层级 右上方的整个区域，就是当前页面布局的层级关系 不可用区域 右上方的整个区域中的第二个按钮Toggle NAF Nodes，按下后出现的黄色区域代表，这些控件是不被Uiautomator工具识别，无法获取到这些控件的实例 属性详情： 右下方的整个区域，是当前选中的页面或者是控件的属性信息。写代码的时候就是需要通过查看属性中的控件的id或者是text等来获取控件的实例，然后点击操作它。 编写脚本 创建项目：创建新的Java项目(注意不是Android项目)。在该项目中来创建测试代码。 导入库和包：在Project Explorer视图中，右键点击测试项目，选择“ Properties &gt; Java Build Path”，然后选择“Libraries” tab界面。在“Libraries”界面选择“ Add Library &gt; JUnit”来添加JUnit3 库；然后点击“Add External JARs… ”并导航到Android SDK目录。选择platforms目录下面的 uiautomator.jar 和 android.jar文件。 uiautomatorviewer uiautomatorviewer详解、脚本介绍 踩坑记录 报错adb devices: list of devices attached unauthorized 设置-&gt;更多设置-&gt;开发者选项-&gt;撤销USB调试授权-&gt;重新授权即可 offline 12$ adb kill server$ adb start server ▲. AC-&gt;Activity coverage、WC-&gt;Widget coverage 开发者测试 同样需要配置Java sdk和Andriod SDK环境,除此之外还需要配置maven 配置maven 1.在maven官网下载 apache-maven-3.6.2-bin.zip后解压,根据视频配置好maven 2.发现最初安装eclipse时没有安装maven,于是安装maven.菜单–&gt;windwos–&gt;install new software–&gt;输入 http://download.eclipse.org/technology/m2e/milestones/1.4后回车 环境配置好后,测试一下 branchscore是主要评分规则 变异得分无法实时查看，使用选手最后一次的提交脚本统一运行 Junit使用 DEMO坑点记录: 1.JUnit4和JRE1.7配套使用,Junit5需要8以上。而JUnit4和JUnit5都不支持JRE11，所以当时我的报错是The import org.apache cannot be resolved. 2.右键项目-&gt;build path -&gt; Config build path -&gt; Libraries后还是报错,java.lang.NoClassDefFoundError: org/junit/runner/manipulation/Filter…解决方法是:①菜单栏-&gt;projects-&gt;clean②build path -&gt; Config build path -&gt; Libraries-&gt;remove重新导入Junit③运行OK 编写规范 1.测试方法上必须使用@Test进行修饰 2.测试方法必须使用public void 进行修饰，不能带任何的参数 3.新建一个源代码目录来存放我们的测试代码 4.测试类的包应该和被测试类保持一致 5.测试单元中的每个方法必须可以独立测试，测试方法间不能有任何的依赖 6.测试类使用Test作为类名的后缀（不是必须） 7.测试方法使用test作为方法名的前缀（不星必须）| 运行流程 1.@BeforeClass修饰的方法会在所有方法被调用前被执行，而且该方法是静态的，所以当测试类被加载后接着就会运行它，而且在内存中它只会存在一份实例，它比较适合加载配置文件。 2.@AfterClass所修饰的方法通常用来对资源的清理，如关闭数据库的连接 3.@Before和@After会在每个测试方法即(@Test修饰的方法函数)的前后各执行一次。 @Test：将一个普通的方法修饰成为一个测试方法 @Test（expected=XX.class） 12345@Test(expected=ArithmeticException.class)private void divided() &#123; // TODO Auto-generated method stub assertEquals(0, new calculate().divide(6, 0));&#125; @Test（timeout=毫秒） @BeforeClass：它会在所有的方法运行前被执行，static修饰 @AfterClass：它会在所有的方法运行结束后被执行，static修饰 @Before：会在每一个测试方法被运行前执行一次 @After：会在每一个测试方法运行后被执行一次 @lgnore：所修饰的测试方法会被测试运行器忽略 @RunWith：可以更改测试运行器org.junit.runner.Runner 测试套件 1.测试套件就是组织测试类一起运行的 写一个作为测试套件的入口类，这个类里不包含其他的方法 更改测试运行器Suite.class 将要测试的类作为数组传入到Suite.SuiteClasses（0） 12345678910111213141516171819202122/** * Project Name:softTest * File Name:SuiteTest.java * Package Name:com.test.demo * Date:2019年9月15日下午1:57:13 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.test.demo;import static org.junit.Assert.*;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Suite;import org.junit.runners.Suite.SuiteClasses;@RunWith(Suite.class)@Suite.SuiteClasses(&#123;calculateTest.class&#125;)public class SuiteTest &#123;&#125; 参数化设置 1.更改默认的测试运行器为RunWith（Parameterized.class） 2.声明变量来存放预期值和结果值 3.声明一个返回值为Collection的公共静态方法，并使用@Parameters进行修饰 4.为测试类声明一个带有参数的公共构造函数，并在其中为之声明变量赋值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Project Name:softTest * File Name:parameterTest.java * Package Name:com.test.demo * Date:2019年9月15日下午2:06:38 * Copyright (c) 2019, chenzhou1025@126.com All Rights Reserved. * */ package com.test.demo;import static org.junit.Assert.assertEquals;import java.util.Arrays;import java.util.Collection;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters;@RunWith(Parameterized.class)public class parameterTest &#123; private int expected = 0; private int input1 = 0; private int input2 = 0; @Parameters // 给构造函数赋值的时候被调用的 public static Collection&lt;Object[]&gt; t() &#123; return Arrays.asList(new Object[][] &#123; &#123;3,1,2&#125;, &#123;4,2,2&#125;, &#125;); &#125; public parameterTest(int expected, int input1, int input2) &#123; this.expected = expected; this.input1 = input1; this.input2 = input2; &#125; @Test public void testAdd() &#123; assertEquals(expected, new calculate().add(input1, input2)); &#125;&#125; 注意点： 定位控件的参数选择要求： 对脚本控件定位参数的选择要追求在要求范围内的唯一性： 参数选择优先级：控件 Resource-id (driver.findElementById())&gt; 控件 XPath(driver.findElementByXPath()) id举例：com.floral.life:id/tv_title Xpath举例：//android.widget.TextView[@text='鲜切花 ']，▲.(此处’鲜切花 '的花字后面还有一个空格，所以不要自己输入属性值，应该直接把在 UI Automator Viewer 中的值直接拷贝到代码中去)。 Xpath选择时，首要选择 text、content-desc 这种特殊性较强的属性值，不要选择 index、bounds 这种多个控件极易相同(即未满足全局唯一)的属性值。 脚本中使用 XPath 进行定位时，务必与脚本编写要求中的 XPath 格式完全一致，即//控件类名[@控件属性名='控件属性值']不要使用//*[@控件属性名='控件属性值']等一系列其他格式 脚本中不要使用 driver.findElementsByxxx()一类的方法，不要用该方法 定位多个控件得到一个 list 再循环来操作 list 中控件(除非该控件的 XPath都不能满足在测试范围内的全局唯一)。 脚本中允许自定义函数，但对于 driver.findElementById()这类原生方法，不要进行封装。 逻辑上是一句话的代码务必写在一行内，不要在函数的参数处换行。 编程建议: 必须使用断言 确认最后提交的测试用例全部正确， Webide或者客户端能运行得分 使用setup()和teardown()方法进行环境初始化 使用timeout限制测试用例运行时间，避免测试用例出现无响应情况 Evosuite生成的捕获异常的自动测试用例，可能导致变异无法跑通， 学生自己注意 测试点注意事项: 对double类型进行判断 123456@Testpublic void test()&#123; double a = 1.0; assertEquals(1.0,a,0.00001) // bingo //assertEquals(1.0,a,0.00001) wrong&#125; 对控制台输出进行测试 12345678910111213141516171819202122232425262728293031323334import static org.junit.Assert.*;public class BinPackageTest&#123; String sep； BinPackage bp； PrintStream console=null； ByteArray InputStream in=null； ByteArrayOutputStream out=null； InputStream input=null；@Beforepublic void setUp()throws Exception &#123; bp=new BinPackage()； out=new ByteArrayoutputstream()； input=System.in； console=System.out； System.setout(new PrintStream(out))； sep=System.getProperty(\"line.separator\")；&#125; @Afterpublic void tearDown()throws Exception &#123; System.setIn(input)； out.close()； System.setout(console)；&#125;@Test(timeout=4000) public void test1()&#123; in=new ByteArrayInputStream((\"2\"+sep+\"12\"tsep +\"3\"+sep+\"211\"+sep+\"222\"+sep+\"232\").getBytes())； System.setIn(in)； bp.entrance()； string ans=out.tostring()； assertEquals(\"false\"+ sep+\"true\"+sep+\"22\"+sep+\"false\"+sep，ans)；&#125; 对异常报错进行测试 1234567891011121314151617181920212223import static org.junit.Assert.*;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;public class AccountTest&#123; private static final double DOUBLE_DELTA=1e-15; @Rule public ExpectedException thrown=ExpectedException.none(); @Test(timeout=4000) public void test1()&#123; Bank bank=new Bank(); Account checkingAccount=new Account(Account.CHECKING); Customer bill=new Customer(\"Bi11\").openAccount(checkingAccount); bank.addCustomer(bil1); thrown.expect(I1legalArgumentException.class); thrown.expectMessage(\"amount must be greater than zero\"); checkingAccount.withdraw(-100.e); &#125;&#125; Nextday 参数化单元测试(测试用例)设计 附录 更新mooctest插件：mooctest.net_plugin 在官网下载最新的插件mooctest.net_plugin.zip后解压，然后打开eclipse中的Help-&gt;Install new software-&gt;add-&gt;local-&gt;选择解压文件夹，安装即可 adb unauthorized 1.使用adb连接手机时，即使打开了usb调试，手机添加了信任，仍然出现unauthorized的提示 2.C:\\Users\\(Username)\\.android里面删掉adbkey和adbkey.pub两个文件(没添加过信任的话是没有的)，然后重新插拔手机 执行： 12adb kill-serveradb start-server △如果上述方式还是无效的话，选择“开发者测试”-&gt;&quot;调试&quot;中的撤销USB调试授权，然后重新上述操作","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"},{"name":"软件测试","slug":"软件测试","permalink":"https://nymrli.top/tags/软件测试/"}]},{"title":"Java自动化构建工具——Maven","slug":"Java自动化构建工具——Maven","date":"2019-09-13T03:45:50.000Z","updated":"2019-09-15T08:07:30.945Z","comments":true,"path":"2019/09/13/Java自动化构建工具——Maven/","link":"","permalink":"https://nymrli.top/2019/09/13/Java自动化构建工具——Maven/","excerpt":"","text":"Java自动化构建工具——Maven 目前的技术在开发中存在的问题、Maven作用 ①一个项目就是一个工程 如果项目非常庞大，就不适合继续使用package来划分模块。最好是每一个模块对应一个工程，利于分工协作。 △借助于Maven就可以将一个项目拆分成多个工程。 ②项目中需要的jar包必须手动“复制”、“粘贴”到WEB-INF/lib目录下 带来的问题是：同样的jar包文件重复出现在不同的项目工程中，一方面浪费存储空间，另外也让工程比较臃肿。 △借助Maven，可以将jar包仅仅保存在“仓库”中，有需要使用的工程“引用”这个文件接口，并不需要真的把jar包复制过来。 ③jar包需要别人替我们准备好，或到官网下载 不同技术的官网提供jar包下载的形式是五花八门的。 有些技术的官网就是通过Maven或SVN等专门的工具来提供下载的。 如果是以不规范的方式下载的jar包，那么其中的内容很可能也是不规范的。 △借助于Maven可以以一种规范的方式下载jar包。因为所有知名框架或第三方工具的jar包以及按照统一的规范存放在了Maven的中央仓库中。 以规范的方式下载的jar包，内容也是可靠的。 ④一个jar包依赖的其他jar包需要自己手动加入到项目中 FileUpload组件→IO组件。commons-fileupload-1.3.jar依赖于commons-io-2.0.1.jar。如果所有jar包之间的依赖关系都需要程序员自己非常清楚的了解，那么就会极大的增加学习成本。 △Maven会自动将被依赖的jar包导入进来。 Maven是什么[What] ①Maven是一款服务于Java平台的自动化构建工具。 Make→Ant→Maven→Gradle妹文、麦文 ②构建 [1]概念：以&quot;ava源文件”、“框架配置文件”、&quot;JSP”、“HTML”、“图片”等资源为“原材料”，去“生产”一个可以运行的项目的过程。 编译 部署 搭建 [2]编译：Java源文件[User.java]→编译→Class字节码文件[User.class]→交给JVM去执行 [3]部署：一个BS项目最终运行的并不是动态Web工程本身，而是这个动态Web工程“编译的结果&quot; 生的鸡→处理一熟的鸡 动态Web工程→编译、部署→编译结果 构建过程中的各个环节 [1]清理：将以前编译得到的旧的class字节码文件删除，为下一次编译做准备 [2]编译：将Java源程序编程成class字节码文件 [3]测试：自动测试，自动调用junit程序 [4]报告：测试程序执行的结果 [5]打包：动态Web工程打war包，Java工程打jar包 [6]安装：Maven特定的概念——将打包得到的文件复制到“仓库”中的指定位置 [7]部署：将动态Web工程生成的war包复制到Servlet容器的指定目录下，使其可以运行 常用Maven命令 ①注意：执行与构建过程相关的Maven命令，必须进入pom.xml所在的目录。 与构建过程相关：编译、测试、打包、…… ②常用命令 [1]mvn clean：清理 [2]mvn compile：编译主程序 [3]mvn test-compile：编译测试程序 [4]mvn test：执行测试 [5]mvn package：打包 联网问题 ①Maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含在Maven的核心程序中。 ②当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。 ③本地仓库的默认位置：[系统中当前用户的家目录]/.m2/repository 如C:/Users/[登录当前系统的用户名]/.m2/repository ④Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载。 ⑤如果此时无法连接外网，则构建失败。 ⑥修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找插件 [1]找到Maven解压目录/conf/settings.xml [2]在settings.xml文件中找到localRepository标签 [3]将&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;从注释中取出E:/apache-maven-3.6.2/MavenRepo [4]将标签体内容修改为已经准备好的Maven仓库目录 补充: 换镜像,可以在settings.xml的第153行左右,设置阿里云镜像 123456&lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 介绍Maven的视频","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"}]},{"title":"打jar包和使用jar包","slug":"打jar包和使用jar包","date":"2019-09-13T03:45:11.000Z","updated":"2019-09-15T08:07:31.064Z","comments":true,"path":"2019/09/13/打jar包和使用jar包/","link":"","permalink":"https://nymrli.top/2019/09/13/打jar包和使用jar包/","excerpt":"","text":"打jar包和使用jar包 一、为什么要打jar包 给别人用的时候一般给别人的是class文件。如果有很多类这么办？把类变成一个压缩包！windows下的压缩包是.zip格式等，而eclipse压缩包是.jar格式。 二、如何查看jar包 用解压缩软件解压即可。可以看到里面有哪些class文件。 三、如何开发jar包 开发jar包的人员开发流程： 步骤1:编写类 12345678//GetSum.javapackage cn.itcast.sum;public class GetSum&#123; public static getSum(int a,int b)&#123; return a+b; &#125;&#125; 步骤2:打包成jar包 在要导出的类上,右键-&gt;Export-&gt;java -&gt; JAR file,然后选择路径,如D:/sum.jar -&gt;导出。 打开jar包可以看到jar包中含有class文件。 四、如何使用jar包 当别人发过来一个jar包(jar包里面有很多class文件)后，比如上面的sum.jar包，如何使用呢？ 有两种方法。第一种方法一般不用，太low了。 使用方法一：这个方法太low了，不用 步骤1:编写Test.java文件 123456789//Test.javaimport cn.itcast.sum.*;//光设置classpath的环境变量还是不够，还要导入包 public class Test&#123; public static void main(String[] args)&#123; int a = GetSum.getSum(1,2); System.out.println(); &#125;&#125; 步骤2:在cmd窗口中使用 123&gt;set classpath = D:/sum.jar; //设置环境变量，知道在哪里找jar包。只在当前的窗口有效。&gt;javac Test.java&gt;java Test 使用方法二：一般使用这个方法 步骤1:在工程目录下新建文件夹lib：File-&gt;New-&gt;Folder,文件名lib，将需要使用的jar包复制进去（ctrl c、ctrl v）。在工程上右键刷新就可以看到jar包了 步骤2:在需要使用的jar包上，右键-&gt;build path -&gt;Add to build Path，发现多了一个小奶瓶～ 步骤3:编写测试类Test.java 123456789//Test.javaimport cn.itcast.GetSum;//不用自己导入。当下面输入GetSum.getSum()时候，按Ctrl+Shift+o自动输入包名。public class Test&#123; public static void main(String[] args)&#123; int a = GetSum.getSum(1,2); //直接使用jar包下面的class类 System.out.println(); &#125;&#125; 注意： 鼠标点到getSum()上，然后按F3，是看不到源码的。出现下面这种界面。这是因为源码不在jdk里面。 可以点击Attach Source按钮，然后点击&quot;External File…&quot;或者&quot;External Folder&quot;找到jar包对应的源码。（jar包中有class文件，并不是源码。）","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nymrli.top/tags/Java/"}]},{"title":"验证码识别程序设计流程","slug":"验证码识别程序设计流程","date":"2019-09-09T13:31:35.000Z","updated":"2019-10-07T10:17:04.838Z","comments":true,"path":"2019/09/09/验证码识别程序设计流程/","link":"","permalink":"https://nymrli.top/2019/09/09/验证码识别程序设计流程/","excerpt":"","text":"验证码识别程序设计流程 以南邮正方教务系统为例 找到验证码图片的链接 “http://jwxt.njupt.edu.cnCheckCode.aspx” 1234567def getCaptcha(): CAPTCHA_URL = \"http://jwxt.njupt.edu.cn/CheckCode.aspx\" r = requests.get(CAPTCHA_URL) img = r.content img = Image.open(BytesIO(img)) return img 对图片去噪 12345678910111213141516171819202122232425def image_pre_process(self): # 去除杂色点 for x in range(self.image.width): for y in range(self.image.height): pix = self.image.getpixel((x, y)) if pix == 43: self.image.putpixel((x, y), WHITE) else: self.image.putpixel((x, y), BLACK) # 去除单像素噪点并进行二值化(八值法) for x in range(self.image.width): for y in range(self.image.height): count = 0 if x != 0 and y != 0 and x != self.image.width - 1 and y != self.image.height - 1: for i in range(-1, 2): for j in range(-1, 2): tx = x + i ty = y + j if self.image.getpixel((tx, ty)) == BLACK: count += 1 if self.image.getpixel((x, y)) == WHITE and count == 8: # 如果一个白色区域的附近八连通区域都是黑色,那么该点也认为是黑色 self.image.putpixel((x, y), BLACK) self.image = self.image.convert('1') △二值化:将需要识别的蓝色字符(43)转为白色(WHITE),其他的全部变为黑色(BLACK) 二值化的过程需要灵性一点,不能直接用convert函数,那样的效果并不理想。 直接convert的效果: 先对蓝色43进行二值化，然后去单点噪声、最后二值化的效果： 设计打码程序设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566\"\"\"方便收集验证码的简单打码工具\"\"\"import tkinterfrom io import BytesIOimport requestsfrom PIL import Image, ImageTkfrom bs4 import BeautifulSoupclass CaptchaGUI: captcha_url = \"http://jwxt.njupt.edu.cn/CheckCode.aspx\" login_url = \"http://jwxt.njupt.edu.cn/default2.aspx\" def __init__(self): self.s = requests.session() self.get_viewstate() self.r = self.s.get(self.captcha_url) self.im = Image.open(BytesIO(self.r.content)) self.root = tkinter.Tk() self.tkimg = ImageTk.PhotoImage(self.im) self.imgLabel = tkinter.Label(self.root, image=self.tkimg) self.imgLabel.pack() self.message = tkinter.Entry(self.root) self.message.pack() self.root.bind('&lt;Return&gt;', self.judge_and_save) self.root.mainloop() def get_viewstate(self): r = self.s.get(self.login_url) soup = BeautifulSoup(r.content, \"lxml\") self.viewstate = soup.find('input', attrs=&#123;\"name\": \"__VIEWSTATE\"&#125;).get(\"value\") def judge_and_save(self, event): captcha_value = self.message.get() print(captcha_value) data = &#123; \"__VIEWSTATE\": self.viewstate, 'txtUserName': \"\", # 账号 'TextBox2': \"\", # 密码 'RadioButtonList1': \"%D1%A7%C9%FA\", \"Button1\": \"\", \"txtSecretCode\": captcha_value, \"hidPdrs\": \"\", \"hidsc\": \"\" &#125; r = self.s.post(self.login_url, data=data) if \"请到信息维护中完善个人联系方式\" in r.text: print(\"成功！\") with open(\"captchas/&#123;&#125;.gif\".format(captcha_value), 'wb+') as f: f.write(self.r.content) else: print(\"验证码输错了\") self.get_viewstate() self.r = self.s.get(self.captcha_url) self.im = Image.open(BytesIO(self.r.content)) self.tkimg = ImageTk.PhotoImage(self.im) self.imgLabel.config(image=self.tkimg) self.message.delete(0, 'end')if __name__ == \"__main__\": captcha_gui = CaptchaGUI() 将结果分割到每个字符 123456def handle_split_image(self): # 切割验证码，返回包含四个字符图像的列表 y_min, y_max = 0, 22 split_lines = [5, 17, 29, 41, 53] ims = [rotate_img(self.image.crop([u, y_min, v, y_max])) for u, v in zip(split_lines[:-1], split_lines[1:])] return ims 123456789101112131415161718192021222324def spilt2chars(): \"\"\" 分割已有的数据为字符并保存 \"\"\" try: shutil.rmtree('captcha_chars') except: pass os.mkdir(\"captcha_chars\") values = \"abcdefghijklmnopqrstuvwxyz1234567890\" for value in values: os.mkdir('captcha_chars/&#123;&#125;'.format(value)) file_names = os.listdir('captchas') for file_name in file_names: # if not os.path.isdir(file_name) and file_name != '.DS_Store': values = file_name[:4] im = Image.open('captchas/&#123;&#125;'.format(file_name)) captcha = ZhengfangCaptcha(im) # 用的是去噪、二值化的图片 for im_part, value in zip(captcha.handle_split_image(), values): m = hashlib.md5() m.update(\"&#123;&#125;&#123;&#125;\".format(time.time(), value).encode('utf8')) im_part.save(\"captcha_chars/&#123;&#125;/&#123;&#125;.png\".format(value, m.hexdigest())) 保存模型数据 12345678910111213141516if __name__ == \"__main__\": # spilt2chars() letters = list('qwertyuiopasdfghjklzcxvbnm1234567890') # 将图像数据转为向量数据并保存 imageset = [] for letter in letters: try: for img in os.listdir('captcha_chars/&#123;&#125;/'.format(letter)): if img != \"Thumbs.db\" and img != \".DS_Store\": vector = ZhengfangCaptcha.buildvector(Image.open(\"captcha_chars/&#123;&#125;/&#123;&#125;\".format(letter, img))) imageset.append(&#123;letter: vector&#125;) except FileNotFoundError as e: pass with open('image_data.json', 'w') as f: json.dump(imageset, f) 识别 辅助函数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import mathimport operatorfrom functools import reduceBLACK = 0WHITE = 255def magnitude(concordance): total = reduce(operator.add, map(lambda x: x ** 2, concordance)) return math.sqrt(total)# 计算矢量之间的余弦距离def distance_cos(vector1, vector2): sum_value = 0 for value1, value2 in zip(vector1, vector2): sum_value += value1 * value2 return 1 - sum_value / (magnitude(vector1) * magnitude(vector2))def distance_hanmming(vector1, vector2): \"\"\" 计算两向量的汉明距，（向量只包含0，1时） \"\"\" count = 0 for value1, value2 in zip(vector1, vector2): if value1 != value2: count += 1 return countdef build_vector(image, binary=True): \"\"\" 图像转一维特征向量 :param image: pillow Image object with mode 1 or mode L :param binary: 黑白图是否生成为0，1向量 :return: list of int \"\"\" vector = [] for pixel in image.getdata(): if binary: vector.append(1 if pixel == 255 else 0) else: vector.append(pixel) return vectordef rotate_img(image): \"\"\" 根据图像在x轴方向投影大小确定字符的摆放方向 :param image: PIL.Image object :return: rotated Image object \"\"\" min_count = 1000 final_angle = 0 for angle in range(-45, 45): x_count = 0 ti = image.rotate(angle, expand=True) for x in range(ti.width): for y in range(ti.height): if ti.getpixel((x, y)) == WHITE: x_count += 1 break if x_count &lt; min_count: min_count = x_count final_angle = angle image = image.rotate(final_angle, expand=False) return image 识别部分: 1234567891011121314151617181920212223242526272829class xxx(object): \"\"\" knn 识别正方验证码 \"\"\" def __init__(self, image): self.image = image self.image_pre_process() # 初始化时就对图片进行去噪和二值化 def crack(self): result = [] # 加载数据 with open(os.path.join(current_dir, 'image_data.json'), 'rb') as f: image_data = json.load(f) for letter in self.handle_split_image(): letter_vector = build_vector(letter) guess = [] for image in image_data: for x, y in image.items(): guess.append((distance_hanmming(y, letter_vector), x)) guess.sort() neighbors = guess[:15] # 距离最近的十五个向量 class_votes = &#123;&#125; # 投票 for neighbor in neighbors: class_votes.setdefault(neighbor[-1], 0) class_votes[neighbor[-1]] += 1 sorted_votes = sorted(class_votes.items(), key=lambda x: x[1], reverse=True) result.append(sorted_votes[0][0]) return ''.join(result) △.在对象的识别上,一定要保证两者的统一性。而因为进行预处理的图片识别率更高。即模型需要保存去噪、二值化的数据，识别的图片在识别前也要做相应的处理。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"新加坡游玩经验","slug":"新加坡游玩经验","date":"2019-09-09T11:35:49.000Z","updated":"2019-10-18T08:46:58.629Z","comments":true,"path":"2019/09/09/新加坡游玩经验/","link":"","permalink":"https://nymrli.top/2019/09/09/新加坡游玩经验/","excerpt":"","text":"新加坡南洋理工大学访学 此次访学长达14天，不少安排都是学校安排，在此仅列出个人安排、经验心得。 门票购买： 番薯游：这是老师推荐我们的，但下载以后感觉界面还是比较丑的，而且价格也不是非常便宜。这家是唯一一家促进扫码买门票的公司。 KLOOK客路：界面比番薯游好多了，还是非常精致的。最大的优势在于可以找到经典的位置及景点介绍、门票时间等信息。 淘宝：跟好几个平台对比之后，价格应该是最低的，并且时间限制比较小，其他的可能要预约，而TB当天购买就行（强调：动物园门票） ▲特别说明下，动物园的门票水很深。当面购买$50,我当时去时没有预约，结果在KLOOK上看当天的票已经没有库存了，于是问了下换票机旁边的黄牛，他看我一个人，给我的报价也是50，不知道他咋想的。最后这个预约问题是通过淘宝解决的，￥156一张夜间动物园门票，5分钟就出票了。购买后会有一张带有二维码的PDF发到邮箱中，用机子扫出后即可。 地铁卡购买： 网上的说法都推荐购买EZ-LINK，但我们在NTU里的711便利店买时最后一张正好卖掉了，于是我们买的是这样的卡，后来发现这卡比EZ-LINK强多了。 由于它支持多家银行支付（由于种种原因，扫码支付在新加坡很难推行），因此其实这张卡十分的方便。既能在学校食堂消费，又能在外消费，同时地铁公交也都支持。 地铁公交价格明细： 如果有卡和没卡，价格区别是很大的，因此如果出行需要坐公交、地铁的话，强烈建议直接办地铁卡。 虽然每次充钱最低10/，但几乎每次坐车都在0.83/，但几乎每次坐车都在0.83/，但几乎每次坐车都在0.83/以上，所以开销还是非常大的。2.坐地铁低于2/就无法进站，公交低于1就无法进站，公交低于1就无法进站，公交低于1（不知道是不是所有） 行为规范： 新加坡的治安、素质是相当高的。其中比较明显的现象有：不乱丢垃圾；在地铁上不能饮食；地铁、公交先下后上； ▲1.如果有残疾人士，会有人帮忙放下挡板，帮残疾人士下车。我看到的那次是车上只有司机，坐轮椅的老奶奶要下公交，司机特地跑来放挡板，帮老人下车。 2.问司机路，他甚至会下车下来给你指往哪个方向怎么走 3.公交车到站需要按BUS STOPPING按钮，不然司机是真的不会停的！地铁的话几乎每站都会停。还有个非常重要的是，BUS每一站是不会报的，因此在新加坡坐公交很容易坐过头，这就需要看清楚地图定位和留意每一站名字。 地图推荐 高德不支持国外，因此我主要使用的是两个：Google Maps、百度地图。 其实百度地图挺好用的，我同学都用的百度，没必要特地去下载Google Maps。而在此我说一下我用Google Maps碰到的问题。1.坐地铁、公交时不会提醒花费。2.没有Google Player服务，周围推荐功能无法使用。3.我用的是MI6，但总感觉有时定位效果特别差，不知道是我手机GPS功能问题，还是Google Maps的问题 总结 新加坡是非常适合国人旅游的，首先是新加坡双语教学，很多人都会说中文，遇上麻烦，看看周围的人总能碰到说中文的；其次是商城里也大多有中文介绍，买东西时几乎每个店都会有说中文的店员来做国人生意，也几乎不太会碰上麻烦。 新加坡有70%的人是中国人或是华裔，10%是印度人，10%是马来人，还有10%是来自欧洲和日本、韩国等地。总的来说中国人比例还是非常大的，而且85%左右的旅客都来自中国，所以其实路上看到很多说中文的说不定也是跟你一样的游客。我交流比较多的都是中国人，特别是彭年纪大的老奶奶或是老爷爷，你如果向他问路，他们都会非常热心地帮助，恨不得亲自带你去了。 外文缩写 新加坡，几乎都有双语标注，因此英语不好的问题也不大。这边就列出几个常见的缩写 st --&gt; street rd --&gt; road sch --&gt; school 景点推荐： 乌节路 Orchard road 购物一条街，ION商城，义乌城……里面全是品牌。 圣淘沙 Sentosa 环球影城就在这岛上，门票350+，我没去，同学去了，感觉很不错，类似迪士尼的游乐园，有多种的主题 滨海湾 Marina Bay superTree Grove是免费的，晚上有表演，大约在8：45左右开始，非常的好看。此处景点有两个收费的地方，我也没去。 靠近湖边，有两个博物馆，一个是红点设计博物馆（这个我去了，门票大约￥70，地方很小，出来的商店卖的东西很贵）；另一个是金沙艺术科学博物馆（主题是“超越未来”，看介绍有点像是失恋博物馆里的光影效果） 鱼尾狮公园 Merlion Park 其实没啥好看的，有鱼尾狮，打个卡、拍个照差不多了。 植物园 Botanic garden 免费，徒步走还挺大的，大约半小时。里面植物很多，一般都是国内看不到的，喜欢看植物的人可以去看一下。同时那也有不少动物，都可以当个小型动物园了。 小印度 Little Indian 印度人很多，印度氛围很重。其他的话个人感觉没什么意思，在那边比较有名的印度餐馆里吃了咖喱鱼头，味道还不错，只不过两个人吃点中份的有点太多了。 Mustafa百货商城，真的很大，有两栋楼互相连通，深不见底，一共有四层。那边的东西也是比较便宜的，比如在NTU超市里买的饮料/$2.5，这边只要/$1.8左右；还有oldTown咖啡，在fairprice超市卖/$7.2，在Mustafa只要$5.4。这边非常值得去，可以在这捎点带给朋友的东西 夜间动物园 比较偏，去和回都很麻烦，坐地铁转公交啥的回NTU要1个半钟头，打车回只要15分钟。门票现场买时/$50，淘宝上￥150。买了门票进去后现有游览车观光，但是如果不加钱是英文讲解的（几乎听不懂w_w）。由于夜色较暗（灯光考虑到对动物的效果也不是很亮），且大多动物都已睡眠，所以游览车观光没什么意思。比较有意思的是动物表演，去的人几乎都会推荐，但需要注意的是，要提前等，因为先来先得位置，位置满后就不能进了，超时10分钟也不会让进了（表演一共15-20分钟左右）。游览车观光后的自由行也是比较有意思的，氛围就像是在丛林中，隔一段距离就是一个品种的动物。有很多平时没见过的大动物与小动物，小动物一般都有玻璃格挡，大动物的站台与马路就一道坎的隔离，管理员似乎很放心他们不会跑出来（老虎除外） 城市规划馆URA 很有意思，由60岁的Steven给我们讲解了新加坡建设的历史以及未雨绸缪地规划，其中3D立体模型图非常精致地还原了各地地细节，在游玩之前看一下这个对出游有极大的帮助 国家博物馆 真的很有意思，比国内的博物馆真实多了。在里面能看到新加坡的发展史、侵略史，能看到英军的身影，也能看到中国和日本的身影。当然其中比较有意思的是有真的坦克在里面展览。 比较遗憾的是我们是上午10点开门的时候去的，而讲解在11：30才开始，因此我们全参观完后讲解正刚开始，侥幸还听到了一点，真的很有意思，建议要去的话凑着这个时间点去，因为虽然有手册介绍，但是自己看真的可能看不明白 国家美术馆 由于8月上旬新加坡国庆在美术馆附近举行，因此8月9日之前都关闭着，因此没几乎进去看看。 美食推荐 叻沙 沙爹 福建炒面 印度飞饼 辣椒螃蟹(Big Eater seafood) 肉骨茶 附录：2019年8月9日新加坡国庆节节目安排 （万事通根据预演推测独家整理） 下午6点3分-6点10分 红狮跳伞队表演（随天气变化时间） 下午6点27分-下午6点30分 特遣队入场 下午6:35-6:38 国家色彩和荣誉护卫队入场 下午6:39 总理抵达 下午6:44 总统抵达 下午6:45-6:46 国旗飞扬 下午6:47 新加坡空军空中表演（F15战斗机） 下午6:49-6:52 鸣礼炮21响致敬 下午6:56-6:57 欢乐之火（大型篝火） 下午6:57 飞行表演 晚上7:00-7:01 新加坡空军多架F15战斗机飞行表演 晚上7:01-7:12 阅兵仪式 晚上7:14-7:39 机动部队出动 晚上8:00-8:05 新加坡河烟花表演（亚洲文明博物馆附近） 晚上8:10-8:18 烟花表演 办理签证 新加坡签证材料 1 两张 白底彩色近照 3.5*4.5cm 2身份证复印件 3户口本复印件 4护照原件 5 在读证明原件","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"CDN加速个人博客——又拍云","slug":"CDN加速个人博客——又拍云","date":"2019-09-09T11:34:27.000Z","updated":"2019-09-15T08:07:30.925Z","comments":true,"path":"2019/09/09/CDN加速个人博客——又拍云/","link":"","permalink":"https://nymrli.top/2019/09/09/CDN加速个人博客——又拍云/","excerpt":"","text":"CDN加速个人博客——又拍云 CDN(Content Delivery Network)内容发布网络，基本思路就是将你网站放置在各地节点服务器，用户访问时找最近的节点服务器获取数据，达到加速的目的。 几大厂商的CDN方案 资费介绍页面 免费额度 是否支持HTTPS 额外限制 注册邀请链接 七牛云 10GB/月 按量付费支持 / &gt;&gt;&gt; 点击注册 腾讯云 10GB/月 免费支持 加了腾讯云CDN没有感觉多大加速 / 百度云 10GB/天 年费付费支持 巨贵… / 又拍云 15GB/月 免费支持 加入又拍云联盟，并在网站底部放置logo &gt;&gt;&gt; 点击注册 因此，选择尝试了下“又拍云”。 一.创建CDN服务 1.服务名称为唯一的ID 2.加速域名就是自己的网站域名 3.选择一个应用场景，在这，我选的是“网页图片” 4.回源管理-&gt;源站设置，网站原本是什么协议就选择什么协议。 回源: 当缓存服务器(CDN提供的服务器)上找不到资源的时候,将会去回源服务器(自己的服务器)上找相应的资源 当然最省事的是选择“协议跟随” 5.选择“创建”，则服务创建完成 6.需要完成“实名认证”，否则服务将处于“关闭”状态 有“支付宝认证”和“身份认证”，“支付宝认证”是直接拍照采取你的个人照片，拍完即认证完毕比较迅速，但可能会泄露更多的个人信息， 毕竟支付宝上已经收集了很多个人信息了。&quot;身份认证&quot;通过提交手持身份证正反面的照片来认证，提交后会有一天的审核期，相对于“支付宝认证”来说可能慢一点。 二.配置SSL证书（非必须） 7.如果博客没有配置HTTPS，可以在这申请免费的SSL证书配置 又拍云提供了两款证书的免费申请方案，用户可通过 SSL 证书申购平台，免费申请 Symantec-TrustAsia、Let’s Encrypt 的 DV（域名型） SSL 证书，帮助用户零成本实现全站部署 HTTPS。并且还实现了 Let’s Encrypt 证书到期自动续签，用户无需担心证书过期时间，降低维护成本。 服务中的&quot;HTTPS&quot;-&gt;“HTTPS配置”–&gt;“无证书，可前往 SSL 证书管理 添加自有证书或申购新证书” 短信验证，付款完成后，需要“请前往证书申购界面补全后续信息&quot;，在”SSL证书服务“中能看到证书，但还需要执行”补全“步骤。 之后，如果当前域名为第一次配置证书，那么需要”域名所有权验证“。可以查看又拍云提供的帮助文档，分为OV 或 EV SSL 证书和DV SSL证书验证，其中DV SSL证书验证又分为”文件检验“和&quot;DNS 验证&quot;. DNS验证，需要修改域名的 DNS，添加 TXT 记录，然后 CA 机构通过解析域名的 TXT 记录来验证域名所有权。其中如果是阿里云解析，在设置过CNAME记录的同时再添加新的TXT记录会报错，说有冲突。此时可查看解决方案 只不过此时状态仍为“审核中”，即CA 机构信息审核验证状态，一般需要 1 个工作日。 ▲我测试了两个免费的证书，发现“Let’s Encrypt DV SSL 单域名证书”审核比&quot;TrustAsia DV SSL 单域名证书&quot;快多了，几乎5分钟就自动审核通过了。 e.g.由于我的博客是搭建在Github pages的，所以配置了HTTPS，因此，这个我就不需要再弄了。 附录 阿里云绑定加速域名解析时，提示TXT与@记录冲突解决办法 方法一： 实际上，TXT记录的作用只是做域名所有权验证。也就是说，一旦域名被验证，就可以删除它。 知道了这个原理，我们可以在解析时先删除其他@主机记录的解析，然后添加百度云加速TXT记录。 通过百度云加速后台显示验证后，我们删除TXT并解析其他@主机记录就可以了。 方法二： 如果你是使用免费智能 DNS 解析服务——CloudXNS 来解析域名应该是不会遇到这些问题，但是如果使用阿里云解析的话，应该或多或少都会遇到解析记录冲突的问题。所以可以采取更换解析商，即把阿里云解析更换为 CloudXNS 解析 方法三： **解析到不同的线路来解决。**默认情况下，我们 CNAME 解析时，只填写主机记录和记录值，其他都是默认，这个时候“解析线路”就是默认线路。如果后续你添加 TXT 记录或 MX 记录时，解析线路也是默认线路，那么就会出现解析记录冲突从而无法成功解析。此时，需要做的就是在解析 TXT 或 MX 记录时，把“解析线路”选择到其他线路，如选择“中国电信”或其他线路，然后保存就不会与 CNANE 的默认线路冲突了。","categories":[],"tags":[]},{"title":"RL强化学习概念","slug":"RL强化学习概念","date":"2019-09-09T11:33:12.000Z","updated":"2019-09-15T08:07:30.999Z","comments":true,"path":"2019/09/09/RL强化学习概念/","link":"","permalink":"https://nymrli.top/2019/09/09/RL强化学习概念/","excerpt":"","text":"RL强化学习概念 方法汇总 价值-直接-想象 通过价值选择行为： Q Learning Sarsa Deep Q Network 直接选择行为： Policy Gradients 想象环境并从中学习 Model Based RL 基于模型 Model-Free RL（无模型）不需要去理解环境的含义 Q Learning Sarsa Policy Gradients Model-Based RL（有环境）需要去理解环境的含义，在&quot;脑子&quot;中模拟虚拟环境 Q Learning Sarsa Policy Gradient 前者需要一步一步得到环境的反馈后才能进行下一步；而后者通过想象来预判断接下来会发生的情况。 基于概率-价值 基于概率（Policy Based RL）： Policy Gradients 即使是概率最高的也不一定能被选择到，因此基于价值的结果更为铁定 基于价值（Value Based RL）： Q Learning Sarsa 不能用于连续动作，但基于概率能使用概率分布在连续动作中选择一个动作 两者的统一体：Actor-Critic 回合-单步 回合更新（Monte-Carlo update） 基础版Policy Gradients Monte-Carlo Learning 在整个回合结束后再学习转折点 单步更新（Temporal-Difference update） Q Learning Sarsa 升级版Policy Gradients 不需要等待回合结束，边玩边学习 更多的情况下单步更新效率更高，但围棋游戏一般采用的都是回合更新 在线-离线 在线学习（online ） 本人在场，本人边玩边学习。 Sarsa Sarsa(/lambda/lambda/lambda) 离散学习（offline） 可以选择自己玩或者看别人玩。可以从保存的结果中学习 Q Learning Deep Q Network onPolicy-offPolicy on-policy Agent必然执行使Q函数最大的动作MAX_ACTION Sarsa off-plicy Agent实际不一定执行使Q函数最大的动作MAX_ACTION Q Learning","categories":[],"tags":[{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"强化学习——QLearning","slug":"强化学习——QLearning","date":"2019-09-09T11:32:08.000Z","updated":"2019-09-15T08:07:31.061Z","comments":true,"path":"2019/09/09/强化学习——QLearning/","link":"","permalink":"https://nymrli.top/2019/09/09/强化学习——QLearning/","excerpt":"","text":"强化学习——QLearning 价值转移公式只有一条Q(s,a)&lt;=Q(s,a)+/alpha∗(reward−Q(s,a)+/gamma∗maxaQ(s′,a))=(1−/alpha)∗Q(s,a)+/alpha∗(reward+/gamma∗maxaQ(s′,a))Q(s,a) &lt;= Q(s,a) + /alpha*(reward - Q(s,a) + /gamma*max_aQ(s&#x27;,a)) = (1-/alpha)*Q(s,a) + /alpha*(reward + /gamma*max_aQ(s&#x27;,a))Q(s,a)&lt;=Q(s,a)+/alpha∗(reward−Q(s,a)+/gamma∗maxa​Q(s′,a))=(1−/alpha)∗Q(s,a)+/alpha∗(reward+/gamma∗maxa​Q(s′,a))，即新Q(s1,a2)=老Q(s1,a2)+/alpha∗差距(现实−估计)新Q(s1,a2) = 老Q(s1,a2) + /alpha * 差距(现实-估计)新Q(s1,a2)=老Q(s1,a2)+/alpha∗差距(现实−估计) ALPHA为学习率，设置估计与现实的差距有多少被学习。能够使得更新比较平缓，防止模型过早收敛到局部解 如果有两种途径都能得到Reward宝藏，如果直接设置1，那么很大程度上，算法都会沿着已尝试出有Reward的路走，虽然有E-Greedy的探索，但是那样的得分可能不至于让第二条路成为更优的选择。所以设置学习率有助于找到第二条路。 GAMMA为衰减系数，maxaQ(s′,a)max_aQ(s&#x27;,a)maxa​Q(s′,a)是下一个时间点的最大期望奖励，因此需要用衰减系数来权衡下。即Q(s1)=r2+/gammaQ(s2)=r2+/gamma(r3+/gammaQ(S3))=...=r2+/gamma∗r3+/gamma2∗r4+/gamma3r5+...Q(s1) = r2 + /gamma Q(s2) = r2 + /gamma(r3+/gamma Q(S3)) = ...= r2 + /gamma *r3+/gamma^{2} *r4+ /gamma^{3} r5 + ...Q(s1)=r2+/gammaQ(s2)=r2+/gamma(r3+/gammaQ(S3))=...=r2+/gamma∗r3+/gamma2∗r4+/gamma3r5+...，约后面的影响越小 GAMMA == 1时，Agent能看到之后所有步的奖励。 只不过真正的理解应该时反序的，即最后一步是得到最终的reward，然后之前的状态的动作选择回报是在这个最终的reward上不断乘以GAMMA进行衰减，使得S1的选择不至于被最后的选择而过多影响 GAMMA == 0时，Agent只能看到眼前的奖励 ▲需要注意的是，这个公式是更新公式，而不是等式，因此两边不能化简，用代码来表示就是Q[state, action] = (1-ALPHA)*Q[state, action] + ALPHA*(reward + GAMMA*Q[newstate, action].max()) QLearning-Maze夺宝藏： demo代码： 环境代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# env.pyfrom __future__ import print_functionimport copyMAP = / '''.......... .. o .. ..........'''# MAP = /# '''# .........# . x .# . x o .# . .# .........# '''MAP = MAP.strip().split('/n')MAP = [[c for c in line] for line in MAP]DX = [-1, 1, 0, 0]DY = [0, 0, -1, 1]class Env(object): def __init__(self): self.map = copy.deepcopy(MAP) self.x = 1 self.y = 1 self.step = 0 self.total_reward = 0 self.is_end = False def interact(self, action): assert self.is_end is False new_x = self.x + DX[action] new_y = self.y + DY[action] new_pos_char = self.map[new_x][new_y] self.step += 1 if new_pos_char == '.': reward = 0 # do not change position elif new_pos_char == ' ': self.x = new_x self.y = new_y reward = 0 elif new_pos_char == 'o': self.x = new_x self.y = new_y self.map[new_x][new_y] = ' ' # update map self.is_end = True # end reward = 100 elif new_pos_char == 'x': self.x = new_x self.y = new_y self.map[new_x][new_y] = ' ' # update map reward = -5 self.total_reward += reward return reward @property def state_num(self): rows = len(self.map) cols = len(self.map[0]) return rows * cols @property def present_state(self): cols = len(self.map[0]) return self.x * cols + self.y def print_map(self): printed_map = copy.deepcopy(self.map) printed_map[self.x][self.y] = 'A' print('/n'.join([''.join([c for c in line]) for line in printed_map])) def print_map_with_reprint(self, output_list): printed_map = copy.deepcopy(self.map) printed_map[self.x][self.y] = 'A' printed_list = [''.join([c for c in line]) for line in printed_map] for i, line in enumerate(printed_list): output_list[i] = line Agent代码 1234567891011121314151617181920212223242526272829303132333435363738# qlearning.pyfrom __future__ import print_functionimport numpy as npimport timefrom env import EnvEPSILON = 0.1ALPHA = 0.1GAMMA = 0.9MAX_STEP = 30np.random.seed(0)def epsilon_greedy(Q, state): if (np.random.uniform() &gt; 1 - EPSILON) or ((Q[state, :] == 0).all()): action = np.random.randint(0, 4) # 0~3 else: action = Q[state, :].argmax() return actione = Env()Q = np.zeros((e.state_num, 4))for i in range(200): e = Env() while (e.is_end is False) and (e.step &lt; MAX_STEP): action = epsilon_greedy(Q, e.present_state) state = e.present_state reward = e.interact(action) new_state = e.present_state Q[state, action] = (1 - ALPHA) * Q[state, action] + / ALPHA * (reward + GAMMA * Q[new_state, :].max()) e.print_map() time.sleep(0.1) print('Episode:', i, 'Total Step:', e.step, 'Total Reward:', e.total_reward) time.sleep(2) 第一次魔改代码： 环境代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from __future__ import print_functionimport copymaze = /'''........... .. o .. ...........'''# print(maze)maze = maze.strip().split('/n')# print(maze)MAP = [[col for col in line] for line in maze]# print(MAP)DX = [-1, 0, 1, 0]DY = [0, 1, 0, -1]class Env(object): ''' 交互环境 ''' def __init__(self): self.map = copy.deepcopy(MAP) self.x = 1 self.y = 1 self.step = 0 self.isEnd = False self._score = 0 def interact(self, action): # state = self.state # assert self.isEnd is True newx = self.x + DX[action] newy = self.y + DY[action] newPos = self.map[newx][newy] self.step += 1 if newPos == '.': reward = -10 elif newPos == ' ': self.x = newx self.y = newy reward = 2 elif newPos == 'o': self.x = newx self.y = newy reward = 100 # self.map[newx][newy] = ' '如果不update会怎么样？ self.isEnd = True self._score += reward return reward @property def state_num(self): rows = len(self.map) cols = len(self.map[0]) return rows * cols @property def score(self): return self._score @property def present_state(self): return len(self.map[0])*self.x + self.y def printMap(self): printed_map = copy.deepcopy(self.map) printed_map[self.x][self.y] = 'A' print('/n'.join([''.join([c for c in line]) for line in printed_map]))if __name__ == '__main__': e = Env() e.printMap() print(e.score) 进行了如下的修改： 碰到边界'.'时，将会扣分 如果没有任何事发生的话，那么奖励2分 修改后结果如下 Agent代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from __future__ import print_functionimport numpy as npfrom pprint import pprintfrom env import Envimport timeEPSILON = 0.2ALPHA = 0.1GAMMA = 0.9MAX_STEP = 30TIMES = 30def epsilonGreedy(Q, state): if np.random.uniform() &gt; 1-EPSILON or ((Q[state, :] == 0).all()): action = np.random.randint(0,4) # 0-3，随机选择一个方向探索 else: action = Q[state, :].argmax() # 找到当前价值最大的决策 return actione = Env()np.random.seed(0)Q = np.zeros((e.state_num, 4))success = 0for i in range(TIMES): ne = Env() while (ne.isEnd == False) and (ne.step &lt; MAX_STEP): state = ne.present_state action = epsilonGreedy(Q, state) print(action) # print(Q[ne.x*10+ne.y,:]) reward = ne.interact(action) newstate = ne.present_state if ne.map[newstate//10][newstate%10] == 'o': success += 1 print('success=',success) print(\"结果为：\") ne.printMap() print(\"再下一步的得分：\",Q[newstate,:]) Q[state, action] = (1-ALPHA)*Q[state, action] + / ALPHA*(reward + GAMMA*Q[newstate, action].max()) time.sleep(.05) print('Episode:', i, 'Total Step:', ne.step, 'Total Reward:', ne.score) # Qp = np.reshape(Q, (5,10,4)) # print(Qp) # [第一行,[10列,4个方向]] # [第二行,[10列,4个方向]] # ... time.sleep(2)print(Q)print(success) 修改后结果 走&quot; &quot;得奖励值设为+2得情况下，当EPSILON=0.1时，30次训练，几乎都在起点左右摇摆。 原因是没碰到宝藏前，他们这样漫无目的的走是得分最高的。 处理的方法：1.修改Epsilon值，让他们有更多的机会去探索；2.增大训练的次数，一旦他们曾经到过宝藏，那么他们会往这个好的方向优化 注意，如果设置&quot; &quot;的奖励的话，需要慎重考虑，因为左右摇摆最高的奖励值在MAX_STEP=30的情况下是能达到60的。所以宝藏的奖励值一定要略大于MAX_SETP*EMPTY_REWARD才能达到训练的目的；同时，可能导致找不到最快寻到宝藏的可能,比如在宝藏门前来回晃悠来获得&quot; &quot;奖励-&gt;解决方案：可以根据当前步数来设置宝藏的分数 碰到'.'扣分，使得Agent不倾向于撞墙，这个是个不错的修改，从Q表中也能看到明显的效果。但是一旦之后出现有陷阱的情况&quot;X&quot;，那么这边的惩罚值得设定需要慎重考虑 第二次魔改代码 环境代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from __future__ import print_functionimport copyTREASURE = 'o'TRAP = 'X'maze = /'''........... &#123;trap&#125; .. &#123;treasure&#125; .. ...........'''.format(treasure=TREASURE,trap=TRAP)# print(maze)maze = maze.strip().split('/n')# print(maze)MAP = [[col for col in line] for line in maze]# print(MAP)DX = [-1, 0, 1, 0]DY = [0, 1, 0, -1]class Env(object): ''' 交互环境 ''' def __init__(self): self.map = copy.deepcopy(MAP) self.x = 1 self.y = 1 self.step = 0 self.isEnd = False self._score = 0 def interact(self, action): # state = self.state # assert self.isEnd is True newx = self.x + DX[action] newy = self.y + DY[action] newPos = self.map[newx][newy] self.step += 1 if newPos == '.': reward = -10 elif newPos == ' ': self.x = newx self.y = newy reward = 2 elif newPos == 'o': self.x = newx self.y = newy reward = 100 # self.map[newx][newy] = ' '如果不update会怎么样？ self.isEnd = True elif newPos == 'X': self.x = newx self.y = newy reward = -50 self.isEnd = True self._score += reward return reward @property def state_num(self): rows = len(self.map) cols = len(self.map[0]) return rows * cols @property def score(self): return self._score @property def present_state(self): return len(self.map[0])*self.x + self.y def printMap(self): printed_map = copy.deepcopy(self.map) printed_map[self.x][self.y] = 'A' print('/n'.join([''.join([c for c in line]) for line in printed_map]))if __name__ == '__main__': e = Env() e.printMap() print(e.score) 进行了如下修改 碰到陷阱'X'时，将会扣较多的分 Agent代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from __future__ import print_functionimport numpy as npfrom pprint import pprintfrom env import Envimport timeEPSILON = 0.2ALPHA = 0.1GAMMA = 0.9MAX_STEP = 30TIMES = 40TEST_TIMES = 5def epsilonGreedy(Q, state): if np.random.uniform() &gt; 1-EPSILON or ((Q[state, :] == 0).all()): action = np.random.randint(0,4) # 0-3，随机选择一个方向探索 else: action = Q[state, :].argmax() # 找到当前价值最大的决策 return actione = Env()np.random.seed(0)Q = np.zeros((e.state_num, 4))# 用Epsilon_Greedy策略获得Q表def Qtrain(): success = 0 for i in range(TIMES): ne = Env() while (ne.isEnd == False) and (ne.step &lt; MAX_STEP): state = ne.present_state action = epsilonGreedy(Q, state) print(\"当前的选择为：\",action) # print(Q[ne.x*10+ne.y,:]) reward = ne.interact(action) newstate = ne.present_state if ne.map[newstate//10][newstate%10] == 'o': success += 1 print('success=',success) print(\"结果为：\") ne.printMap() print(\"再下一步的得分：\",Q[newstate,:],'/n') Q[state, action] = (1-ALPHA)*Q[state, action] + / ALPHA*(reward + GAMMA*Q[newstate, action].max()) time.sleep(.05) print('Episode:', i, 'Total Step:', ne.step, 'Total Reward:', ne.score) print('-'*20, '/n/n') # Qp = np.reshape(Q, (5,10,4)) # print(Qp) time.sleep(2) print(Q) print(success)# 使用Q表走棋测试,由于Q表确定，所以其实每次的结果都是一样的def Qtest(): print('*'*10,\"开始测试\",'*'*10) for i in range(TEST_TIMES): ne = Env() while (ne.isEnd == False) and (ne.step &lt; MAX_STEP): state = ne.present_state action = Q[state,:].argmax() print(\"当前的选择为：\",action) # print(Q[ne.x*10+ne.y,:]) reward = ne.interact(action) newstate = ne.present_state print(\"结果为：\") ne.printMap() print(\"再下一步的得分：\",Q[newstate,:],'/n') time.sleep(.05) print('Episode:', i, 'Total Step:', ne.step, 'Total Reward:', ne.score) print('-'*20,'/n/n') time.sleep(2)if __name__ == '__main__': Qtrain() Qtest() 修改后结果： 由于走空&quot; &quot;现象仍然存在，感觉奖励给2仍是太多 EPSILON=0.2，随机乱走的几率很高，导致开局踩到陷阱X的概率很大 暴毙结果(训练中没碰到过宝藏) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748********** 开始测试 **********当前的选择为： 2结果为：........... X ..A o .. ...........再下一步的得分： [ 0.12753822 0. 1.0434062 -2.9701 ] 当前的选择为： 2结果为：........... X .. o ..A ...........再下一步的得分： [ 0.21147844 2.30159071 0. -1.99 ] 当前的选择为： 1结果为：........... X .. o .. A ...........再下一步的得分： [-0.313 0.398 -1. 1.04984339] 当前的选择为： 3结果为：........... X .. o ..A ...........再下一步的得分： [ 0.21147844 2.30159071 0. -1.99 ] 当前的选择为： 1结果为：........... X .. o .. A ...........再下一步的得分： [-0.313 0.398 -1. 1.04984339] ...之后都是1和3的循环选择 可以看到，这边上下变成了死循环。这是当所有训练中都没有踩到过宝藏的情况。 ▲.使训练中更有可能碰到宝藏的方法 训练的次数T足够多 如果训练次数少的话，需要合理设置EPSILON，使得Agent有更多的机会探索 MAX_STEP设置合理 特殊情况考虑（发生概率很小） ▲.还有一点要说明的是：Q:有种情况是，同样都是走空得2分，为什么向上得得分是18，而向右得得分是2呢？ A：因为Dx，Dy的循序（上右下左）决定了。当四个得分都一样时如[2,2,2,2]，那么将会优先选择上，因为如果走空有奖励，所以上比右的得分会高很多。 1234567891011# env.pyDX = [-1, 0, 1, 0]DY = [0, 1, 0, -1]# ...def epsilonGreedy(Q, state): if np.random.uniform() &gt; 1-EPSILON or ((Q[state, :] == 0).all()): action = np.random.randint(0,4) # 0-3，随机选择一个方向探索 else: action = Q[state, :].argmax() # 找到当前价值最大的决策 # ▲argmax()当最大值相同时，取索引最小的 return action 即 12345678910111213# Test1a = np.array([ [1,0,1,1], [2,1,3,1]])print(a[0,:].argmax())# 0# Test2a = np.array([ [1,0,3,3], [2,1,3,1]])print(a[0,:].argmax())# 2 测试走空–奖励值 走空无奖励值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647当前的选择为： 2结果为：........... X ..A o .. ...........再下一步的得分： [-0.501399 23.9585123 0. -3.940399 ] 当前的选择为： 1结果为：........... X .. A o .. ...........再下一步的得分： [-20.4755 41.20097133 0. -0.267309 ] 当前的选择为： 1结果为：........... X .. A o .. ...........再下一步的得分： [-0.457659 66.18493075 -0.2439 0. ] 当前的选择为： 1结果为：........... X .. Ao .. ...........再下一步的得分： [ 0. 94.1850263 0. 0. ] 当前的选择为： 1结果为：........... X .. A .. ...........再下一步的得分： [0. 0. 0. 0.] Episode: 4 Total Step: 5 Total Reward: 100-------------------- 走空有+2奖励的结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647当前的选择为： 2结果为：........... X ..A o .. ...........再下一步的得分： [-0.41254159 6.24693379 -0.03645728 -3.940399 ] 当前的选择为： 1结果为：........... X .. A o .. ...........再下一步的得分： [-9.5 21.14440154 0.2981 0. ] 当前的选择为： 1结果为：........... X .. A o .. ...........再下一步的得分： [ 5.16800000e-01 5.26069497e+01 -3.14898100e-02 3.80000000e-01] 当前的选择为： 1结果为：........... X .. Ao .. ...........再下一步的得分： [ 0.45506025 83.3228183 1.0434062 2.28281481] 当前的选择为： 1结果为：........... X .. A .. ...........再下一步的得分： [0. 0. 0. 0.] Episode: 4 Total Step: 5 Total Reward: 108-------------------- 多次测试经验总结：","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"RL","slug":"RL","permalink":"https://nymrli.top/tags/RL/"}]},{"title":"机器学习——决策树","slug":"机器学习——决策树","date":"2019-08-30T13:44:35.000Z","updated":"2019-10-07T10:14:32.825Z","comments":true,"path":"2019/08/30/机器学习——决策树/","link":"","permalink":"https://nymrli.top/2019/08/30/机器学习——决策树/","excerpt":"","text":"机器学习——决策树 决策树基础概念 决策树分为分类树和回归树两种，分类树对离散变量做决策树，回归树对连续变量做决策树。 每个内部节点（非叶子节点）表示一个属性上的测试条件，每个分支代表一个测试输出结果，每个叶节点代表一种类别 决策树分为分类树和回归树两种，分类树对离散变量做决策树，回归树对连续变量做决策树。 决策树的构造过程就是找到这些具有决定性作用的特征，根据其决定性程度来构造一个倒立的树–决定性作用最大的那个特征作为根节点，然后递归找到各分支下子数据集中次大的决定性特征，直至子数据集中所有数据都属于同一类。 特征： 有监督的学习 非参数学习算法 自顶向下递归方式构造决策树 在每一步选择中都采取在当前状态下最好\\优的选择 决策树生成过程 一棵决策树的生成过程主要分为以下3个部分: 特征选择：特征选择是指从训练数据中众多的特征中选择一个特征作为当前节点的分裂标准，如何选择特征有着很多不同量化评估标准标准，从而衍生出不同的决策树算法。 决策树生成： 根据选择的特征评估标准，从上至下递归地生成子节点，直到数据集不可分则停止决策树停止生长。 树结构来说，递归结构是最容易理解的方式。 剪枝：决策树容易过拟合，一般来需要剪枝，缩小树结构规模、缓解过拟合。剪枝技术有预剪枝和后剪枝两种。 基于信息论的三种决策树算法 划分数据集的最大原则是：使无序的数据变的有序。 熵降低的速度越快越好==&gt;树的高度最矮 基于信息论的决策树算法有ID3、CART和C4.5等算法，其中C4.5和CART两种算法从ID3算法中衍生而来。 ID3算法 信息增益作为评估标准，分支节点选择特征X信息增益最大的 可用于划分标称型数据集，没有剪枝的过程，为了去除过度数据匹配的问题，可通过裁剪合并相邻的无法产生大量信息增益的叶子节点（例如设置信息增益阀值）。使用信息增益的话，其实是有一个缺点，那就是它偏向于具有大量值的属性–就是说在训练集中，某个属性所取的不同值的个数越多，那么越有可能拿它来作为分裂属性 C4.5算法 C4.5是ID3的一个改进算法，继承了ID3算法的优点。 C4.5算法用信息增益率来选择属性， 克服了用信息增益选择属性时偏向选择取值多的属性的不足在树构造过程中进行剪枝； 能够完成对连续属性的离散化处理；能够对不完整数据进行处理。 CART算法（Classification And Regression Tree） **采用的是Gini指数（选Gini指数最小的特征s）**作为分裂标准 同时它也是包含后剪枝操作 ID3和C4.5虽可尽可能挖掘数据信息，但生成的决策树分支较大。CART可以简化决策树的规模，提高生成决策树的效率 决策树优缺点 决策树适用于数值型和标称型（离散型数据，变量的结果只在有限目标集中取值），能够读取数据集合，提取一些列数据中蕴含的规则。在分类问题中使用决策树模型有很多的优点，1.决策树计算复杂度不高、便于使用、而且高效，2.决策树可处理具有不相关特征的数据、3.可很容易地构造出易于理解的规则，而规则通常易于解释和理解。 决策树模型也有一些缺点，比如1.处理缺失数据时的困难、2.过度拟合以及3.忽略数据集中属性之间的相关性等。 ID3数学原理 信息熵(香农熵)： 一种度量不确定性的方式，是用来衡量随机变量不确定性的，熵就是信息的期望值 如果待分类的事物可能划分在多个分类之中，则符号xi的信息定义为I(xi)=−log⁡2p(xi)\\mathrm{I}\\left(x_{i}\\right)=-\\log _{2} p\\left(x_{i}\\right)I(xi​)=−log2​p(xi​)，其中p(xi)是选择该分类的概率。 有人可能会问，信息为啥这样定义啊？答曰：前辈得出的结论。这就跟1+1等于2一样，记住并且会用即可。上述式中的对数以2为底，也可以e为底(自然对数)。 若随机事件发生的结果记为X，且待分类的事物可能划分在N类中，分别是x1，x2，……，xn，每一种取到的概率分别是P1，P2，……，Pn，那么X的熵就定义为： H=−∑i=1np(xi)log⁡2p(xi)\\mathrm{H}=-\\sum_{\\mathrm{i}=1}^{n} \\mathrm{p}\\left(x_{i}\\right) \\log _{2} p\\left(x_{i}\\right)H=−∑i=1n​p(xi​)log2​p(xi​) 反映了每一个元素在该类别下的不纯度，如{1,2,3,4}跟{1,1,1,2}相比,每个元素1-4的logPi都很大,因此sum的熵就要大很多。 注：有&quot;某个类别的结果&quot;的熵（某个特征有多个值），也有&quot;某事件结果&quot;的熵（该事件有多个特征）。直观来讲，结果种类越多，熵值越大。 当熵中的概率由数据估计(特别是最大似然估计)得到时，所对应的熵称为经验熵(empirical entropy)。什么叫由数据估计？比如有10个数据，一共有两个类别，A类和B类。其中有7个数据属于A类，则该A类的概率即为十分之七。其中有3个数据属于B类，则该B类的概率即为十分之三。浅显的解释就是，这概率是我们根据数据数出来的。 经验熵举例： 我们定义贷款申请样本数据表中的数据为训练数据集D，则训练数据集D的经验熵为H(D)。|D|表示其样本容量，即样本个数。设有K个类Ck, = 1,2,3,…,K,|Ck|为属于类Ck的样本个数，因此经验熵公式就可以写为 ： H(D)=−∑k=1K∣ck∣∣D∣log⁡2∣Ck∣∣D∣\\mathrm{H}(\\mathrm{D})=-\\sum_{k=1}^{K} \\frac{\\left|c_{k}\\right|}{|D|} \\log _{2} \\frac{\\left|C_{k}\\right|}{|D|}H(D)=−∑k=1K​∣D∣∣ck​∣​log2​∣D∣∣Ck​∣​ ，即p(Ck)=∣Ck∣∣D∣p(C_k)=\\frac{\\left|C_{k}\\right|}{|D|}p(Ck​)=∣D∣∣Ck​∣​由样本数据出来的结果。 根据此公式计算经验熵H(D)，分析贷款申请样本数据表中的数据。最终分类结果只有两类，即放贷和不放贷。根据表中的数据统计可知，在15个数据中，9个数据的结果为放贷，6个数据的结果为不放贷。所以数据集D的经验熵H(D)为： H(D)=−915log⁡2915−615log⁡2615=0.971\\mathrm{H}(\\mathrm{D})=-\\frac{9}{15} \\log _{2} \\frac{9}{15}-\\frac{6}{15} \\log _{2} \\frac{6}{15}=0.971H(D)=−159​log2​159​−156​log2​156​=0.971 经过计算可知，数据集D的经验熵H(D)的值为0.971。 ▲熵值越高，则数据混合的种类越高，其蕴含的含义是一个变量可能的变化越多（反而跟变量具体的取值没有任何关系，只和值的种类多少以及发生概率有关） 条件熵 表示在已知随机变量X的条件下随机变量Y的不确定性，其定义为X在给定条件下Y的条件概率分布的熵对X的数学期望: H(Y∣X)=∑i=1npiH(Y∣X=xi)H(Y | X)=\\sum_{i=1}^{n} p_{i} H\\left(Y | X=x_{i}\\right)H(Y∣X)=∑i=1n​pi​H(Y∣X=xi​),其中pi=P(X=xi),i=1,2,⋯ ,np_{i}=P\\left(X=x_{i}\\right), i=1,2, \\cdots, \\mathrm{n}pi​=P(X=xi​),i=1,2,⋯,n 经验条件熵举例： 设特征A有n个不同的取值{a1,a2,···,an}，根据特征A的取值将D划分为n个子集{D1,D2，···,Dn}，|Di|为Di的样本个数。记子集Di中属于Ck的样本的集合为Dik，即Dik = Di ∩ Ck，|Dik|为Dik的样本个数 \\begin{align*}\\mathrm{H}(\\mathrm{D} | \\mathrm{A}) &amp; =\\sum_{i=1}^{\\mathrm{n}} \\frac{\\left|D_{i}\\right|}{|D|} \\mathrm{H}\\left(D_{i}\\right) \\\\ &amp; =-\\sum_{i=1}^{n} \\frac{\\left|D_{i}\\right|}{|D|} \\sum_{k=1}^{K} \\frac{\\left|D_{i k}\\right|}{\\left|D_{i}\\right|} \\log _{2} \\frac{\\left|D_{i k}\\right|}{\\left|D_{i}\\right|}\\end{align*} 信息增益 信息增益(information gain)表示得知特征X的信息后，而使得Y的不确定性减少的程度。定义为集合D的经验熵H(D)与给定特征A条件下D的经验条件熵H(D|A)之差: g(D,A)=H(D)−H(D∣A)g(D, A)=H(D)-H(D| A)g(D,A)=H(D)−H(D∣A) 一般地，熵H(D)与条件熵H(D|A)之差称为互信息(mutual information)。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。 举例：以贷款申请样本数据表为例进行说明。看下年龄这一列的数据，也就是特征A1，一共有三个类别，分别是：青年、中年和老年。我们只看年龄是青年的数据，年龄是青年的数据一共有5个，所以年龄是青年的数据在训练数据集出现的概率是5\\15，也就是1\\3。同理，年龄是中年和老年的数据在训练数据集出现的概率也都是1\\3。现在我们只看年龄是青年的数据的最终得到贷款的概率为2\\5，因为在五个数据中，只有两个数据显示拿到了最终的贷款，同理，年龄是中年和老年的数据最终得到贷款的概率分别为3\\5、4\\5。所以计算年龄的信息增益，过程如下： g(D,A1)=H(D)−H(D∣A1)=H(D)−∑i=1n∣Di∣∣D∣H(Di)=H(D)−[∣D1∣∣D∣H(D1)+∣D2∣∣D∣H(D2)+∣D3∣∣D∣H(D3)]=H(D)−∣Di∣∣D∣∑i=13pi∗log⁡2pi=0.971−[515(−25log⁡225−35log⁡235)+515(−35log⁡235−25log⁡225)+515(−45log⁡245−15log⁡215)]=0.971−0.888=0.083\\begin{aligned} \\mathrm{g}\\left(\\mathrm{D}, A_{1}\\right) &amp;=H(D)-H\\left(D | A_{1}\\right) \\\\ &amp;=H(D)-\\sum_{i=1}^{\\mathrm{n}} \\frac{\\left|D_{i}\\right|}{|D|} \\mathrm{H}\\left(D_{i}\\right) \\\\ &amp;=H(D)-\\left[\\frac{\\left|D_{1}\\right|}{|D|}H\\left(\\mathrm{D}_{1}\\right)+\\frac{\\left|D_{2}\\right|}{|D|} H\\left(D_{2}\\right)+\\frac{\\left|D_{3}\\right|}{|D|} H\\left(D_{3}\\right)\\right] \\\\ &amp;=H(D)- \\frac{\\left|D_{i}\\right|}{|D|} \\sum_{i=1}^{3} p_{i} * \\log _{2} p_{i} \\\\ &amp;=0.971-\\left[\\frac{5}{15}\\left(-\\frac{2}{5} \\log _{2} \\frac{2}{5}-\\frac{3}{5} \\log _{2} \\frac{3}{5}\\right)+\\frac{5}{15}\\left(-\\frac{3}{5} \\log _{2} \\frac{3}{5}-\\frac{2}{5} \\log _{2} \\frac{2}{5}\\right)\\right.\\\\ &amp;\\left.+\\frac{5}{15}\\left(-\\frac{4}{5} \\log _{2} \\frac{4}{5}-\\frac{1}{5} \\log _{2} \\frac{1}{5}\\right)\\right] \\\\ &amp;=0.971-0.888=0.083 \\end{aligned}g(D,A1​)​=H(D)−H(D∣A1​)=H(D)−i=1∑n​∣D∣∣Di​∣​H(Di​)=H(D)−[∣D∣∣D1​∣​H(D1​)+∣D∣∣D2​∣​H(D2​)+∣D∣∣D3​∣​H(D3​)]=H(D)−∣D∣∣Di​∣​i=1∑3​pi​∗log2​pi​=0.971−[155​(−52​log2​52​−53​log2​53​)+155​(−53​log2​53​−52​log2​52​)+155​(−54​log2​54​−51​log2​51​)]=0.971−0.888=0.083​ 其中|Di|为特征该类别的数量，Pi为该类别下为true（事件发生）的概率 C4.5数学原理 以信息增益进行分类决策时，存在偏向于取值较多的特征的问题。于是有了基于信息增益比的分类决策方法C4.5。C4.5与ID3都是利用贪心算法进行求解，不同的是分类决策的依据不同。 信息增益比率度量:信息增益比率度量Gain(D，X) \\ 分裂信息度量SplitInformation(D，X) SplitInformation(D，X）=−∑i=1nPxi∗log2PxiSplitInformation(D，X） = -\\sum_{i=1}^{n}{P_{x_i} }*log_2{P_{x_i} }SplitInformation(D，X）=−∑i=1n​Pxi​​∗log2​Pxi​​ GainRatio(D,X)=Gain(D,X)÷SplitInformation(D,X)GainRatio(D,X) = Gain(D,X) \\div SplitInformation(D,X)GainRatio(D,X)=Gain(D,X)÷SplitInformation(D,X) CART数学原理 基尼指数GINI 1、是一种不等性度量，表示一个随机选中的样本在子集中被分错的可能性； 2、通常用来度量收入不平衡，可以用来度量任何不均匀分布； 3、是介于0~1之间的数，0-完全相等，1-完全不相等； 4、总体内包含的类别越杂乱，GINI指数就越大（跟熵的概念很相似） Gini系数的计算方式如下 Gini(p)=∑k=1Kpk(1−pk)=1−∑k=1Kpk2Gini(p)=\\sum_{k=1}^{K} p_{k}\\left(1-p_{k}\\right)=1-\\sum_{k=1}^{K} p_{k}^{2}Gini(p)=∑k=1K​pk​(1−pk​)=1−∑k=1K​pk2​ 上面式子表述的意思就是，加入特征X以后，数据不纯度减小的程度. 如果D为样本数据集，Gini(D)=1−∑k=1K(∣Ck∣∣D∣)2Gini(D)=1-\\sum_{k=1}^{K}\\left(\\frac{\\left|C_{k}\\right|}{|D|}\\right)^{2}Gini(D)=1−∑k=1K​(∣D∣∣Ck​∣​)2其中Ck是D中属于第k类的样本子集，K是类的个数。 如果D被特征A划分为D1、D2两部分，这个时候就是统计均值，样本数据集D的基尼系数： Gini(D,A)=∣D1∣∣D∣Gini(D1)+∣D2∣∣D∣Gini(D2)Gini(D, A)=\\frac{\\left|D_{1}\\right|}{|D|} Gini\\left(D_{1}\\right)+\\frac{\\left|D_{2}\\right|}{|D|} Gini\\left(D_{2}\\right)Gini(D,A)=∣D∣∣D1​∣​Gini(D1​)+∣D∣∣D2​∣​Gini(D2​) [统计学习方法：CART算法](https:\\www.cnblogs.com\\xingshansi\\p\\6847334.html) 最小二乘回归树 一个回归树对应着输入空间（即特征空间）的一个划分以及在划分的单元上的输出值。假设已将输入空间划分为M个单元R1,R2,…Rm，并且在每个单元Rm上有一个固定的输出值Cm，于是回归树模型可表示为： f(x)=∑m=1McmI(x∈Rm)f(x)=\\sum_{m=1}^{M} c_{m} I\\left(x \\in R_{m}\\right)f(x)=∑m=1M​cm​I(x∈Rm​) 模型输出值与实际值的误差：∑xi∈Rm(yi−f(xi))2\\sum_{x_{i} \\in R_{m}}\\left(y_{i}-f\\left(x_{i}\\right)\\right)^{2}∑xi​∈Rm​​(yi​−f(xi​))2 我们希望每个单元上的Cm，可以是的这个平方误差最小化。易知，当Cm为相应单元的所有实际值的均值时，可以到最优： c^m=ave(yi∣xi∈Rm)\\hat{c}_{m}=ave\\left(y_{i} | x_{i} \\in R_{m}\\right)c^m​=ave(yi​∣xi​∈Rm​) 假设，我们选择变量 xj 为切分变量，它的取值 s 为切分点，那么就会得到两个区域： R1(j,s)={x∣x(j)≤s},R2(j,s)={x∣x(j)&gt;s}\\mathrm{R}_{1}(j, s)=\\left\\{x | x^{(j)} \\leq s\\right\\}, \\mathrm{R}_{2}(j, s)=\\left\\{x | x^{(j)}&gt;s\\right\\}R1​(j,s)={x∣x(j)≤s},R2​(j,s)={x∣x(j)&gt;s} 当j和s固定时，我们要找到两个区域的代表值c1，c2使各自区间上的平方差最小： min⁡j,s[min⁡c1∑xi∈R1(j,s)(yi−c1)2+min⁡c2∑xi∈R2(j,s)(yi−c2)2]\\min _{j, s}\\left[\\min _{c_{1}} \\sum_{x_{i} \\in R_{1}(j, s)}\\left(y_{i}-c_{1}\\right)^{2}+\\min _{c_{2}} \\sum_{x_{i} \\in R_{2}(j, s)}\\left(y_{i}-c_{2}\\right)^{2}\\right]minj,s​[minc1​​∑xi​∈R1​(j,s)​(yi​−c1​)2+minc2​​∑xi​∈R2​(j,s)​(yi​−c2​)2] 前面已经知道c1，c2为区间上的平均： c^1=ave(yi∣xiϵR1(j,s)),c^2=ave(yi∣xiϵR1(j,s))\\hat{c}_{1}=ave\\left(y_{i} | x_{i} \\epsilon R_{1}(j, s)\\right), \\hat{c}_{2}=ave\\left(y_{i} | x_{i} \\epsilon R_{1}(j, s)\\right)c^1​=ave(yi​∣xi​ϵR1​(j,s)),c^2​=ave(yi​∣xi​ϵR1​(j,s)) 那么对固定的 j 只需要找到最优的s，然后通过遍历所有的变量，我们可以找到最优的j，这样我们就可以得到最优对（j，s）,（特征j，特征分类值s），并s得到两个区间。 这样的回归树通常称为最小二乘回归树（least squares regression tree）。 上述过程表示的算法步骤为: 处理连续数值型特征 C4.5和CART既可以处理离散型属性，也可以处理连续性属性。对于离散型描述属性，处理方法与ID3相同。对于连续分布的特征，其处理方法是： 以C4.5为例子，在C4.5中，对连续属性的处理如下： 1、对特征的取值进行升序排序 2、两个特征取值之间的中点作为可能的分裂点，从分裂点将数据集分成两部分，计算每个可能的分裂点的信息增益（InforGain）。优化算法就是只计算分类属性发生改变的那些特征取值。 3、选择修正后信息增益(InforGain)最大的分裂点作为该特征的最佳分裂点 4、计算最佳分裂点的信息增益率（Gain Ratio）作为特征的Gain Ratio。注意，此处需对最佳分裂点的信息增益进行修正：减去log2(N-1)|D|（N是连续特征的取值个数，D是训练数据数目，此修正的原因在于：当离散属性和连续属性并存时，C4.5算法倾向于选择连续特征做最佳树分裂点） Q：为什么这边是使用的信息增益率？ A：经证明，在决定连续特征的分界点时采用增益这个指标（因为若采用增益率，splittedinfo影响分裂点信息度量准确性，若某分界点恰好将连续特征分成数目相等的两部分时其抑制作用最大），而选择属性的时候才使用增益率这个指标能选择出最佳分类特征。 剪枝 预剪枝(Pre-pruning) 在构建决策树的过程时，提前停止。 根据一些原则及早的停止树增长，如树的深度达到用户所要的深度、节点中样本个数少于用户指定个数、不纯度指标下降的最大幅度小于用户指定的幅度等 采用检验技术对当前结点对应的样本集合进行检验，如果该样本集合的样本数量已小于事先指定的最小允许值，那么停止该结点的继续生长，并将该结点变为叶子结点，否则可以继续扩展该结点。 ▲核心问题是如何事先指定树的最大深度，如果设置的最大深度不恰当，那么将会导致过于限制树的生长，使决策树的表达式规则趋于一般，不能更好地对新数据集进行分类和预测 后剪枝(Post-pruning) 决策树构建好后，然后才开始裁剪。 代价复杂性剪枝、最小误差剪枝、悲观误差剪枝等等 是一个边修剪边检验的过程。 在决策树的不断剪枝操作过程中，将原样本集合或新数据集合作为测试数据，检验决策树对测试数据的预测精度，并计算出相应的错误率，如果剪掉某个子树后的决策树对测试数据的预测精度或其他测度不降低，那么剪掉该子树。 ▲关键就是用独立的验证数据集对训练集生长的树进行剪枝 CART剪枝 先来看看剪枝用到的准则函数：Cα(T)=C(T)+α∣Tleaf∣C_{\\alpha}(T)=C(T)+\\alpha|T_{leaf}|Cα​(T)=C(T)+α∣Tleaf​∣ C（T）是叶节点特性的度量，C4.3里它是熵的均值，CART决策树里它是基尼系数的概率均值，原理类似。多一个正则项，就是稀疏性约束。TleafT_{leaf}Tleaf​为叶子节点个数，越多，损失越大 ID3、C4.5算法中的剪枝原理是给定α，事实上很难一次给出理想的α。CART剪枝不再给定一个α，然后选择最优决策树，而是通过设定不同的α，通过交叉验证选择最优CART树，也就是： 训练集：得到不同的子树; 测试集：交叉验证选择最优树. 从有限个子树{T0,T1,…,Tn}\\left\\{T_{0}, T_{1}, \\ldots, T_{n}\\right\\}{T0​,T1​,…,Tn​}中计算最优子树，最优子树由验证集得出的测试误差决定，哪个最小就是哪个。 这里就引出了一个问题，每次剪哪一个节点呢？如何让TleafT_{leaf}Tleaf​到达一个合适的点呢？先看分析剪枝的两个极端情况： 1）完全没剪： Cα(Tt)=C(Tt)+α∣Tt∣C_{\\alpha}\\left(T_{t}\\right)=C\\left(T_{t}\\right)+\\alpha\\left|T_{t}\\right|Cα​(Tt​)=C(Tt​)+α∣Tt​∣ 2）只剩根节点： Cα(t)=C(t)+αC_{\\alpha}(t)=C(t)+\\alphaCα​(t)=C(t)+α 在α较小或者为0时，有： Cα(Tt)&lt;Cα(t)C_{\\alpha}\\left(T_{t}\\right)&lt;C_{\\alpha}(t)Cα​(Tt​)&lt;Cα​(t) 在α取+∞大时，有： Cα(Tt)&gt;Cα(t)C_{\\alpha}\\left(T_{t}\\right)&gt;C_{\\alpha}(t)Cα​(Tt​)&gt;Cα​(t) α是连续变量，因此总有临界点： Cα(Tt)=Cα(t)C_{\\alpha}\\left(T_{t}\\right)=C_{\\alpha}(t)Cα​(Tt​)=Cα​(t) 为了不混淆变量，重新定义： g(t)=C(t)−C(Tt)∣Tt∣−1g(t)=\\frac{C(t)-C\\left(T_{t}\\right)}{\\left|T_{t}\\right|-1}g(t)=∣Tt​∣−1C(t)−C(Tt​)​ α大于g(t)就是该剪。简而言之： 对于同一棵树的结点，α都是一样的，当α从0开始缓慢增大（或者从+∞慢慢减小），总会有某棵子树该剪，其他子树不该剪的情况，即α超过了某个结点的g(t)，但还没有超过其他结点的g(t)。这样随着alpha不断增大，不断地剪枝，就得到了n+1棵子树，接下来只要用独立数据集测试这n+1棵子树，试试哪棵子树的误差最小 就知道那棵是最好的方案了。 CART剪枝的算法过程 代码编写注意点 递归的结束条件： 一.到达叶节点 1.当某集合的值全是同一类时，那么该子集直接可作为叶子节点，为一个类别，此时不再下探。 2.在决策树构造过程中可能会出现这种情况：所有特征都作为分裂特征用光了，但子集还不是纯净集（集合内的元素不属于同一类别）。在这种情况下，由于没有更多信息可以使用了，一般对这些子集进行“多数表决”，即使用此子集中出现次数最多的类别作为此节点类别，然后将此节点作为叶子节点，此时不再下探 二.预剪枝条件 1.树的深度达到用户所要的深度 2.节点中样本个数少于用户指定个数 附录 借鉴： 机器学习实战教程（三）：决策树实战篇之为自己配个隐形眼镜 决策树算法原理及实现","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"}]},{"title":"Sklearn——决策树","slug":"Sklearn——决策树","date":"2019-08-30T13:43:27.000Z","updated":"2019-09-15T08:07:31.004Z","comments":true,"path":"2019/08/30/Sklearn——决策树/","link":"","permalink":"https://nymrli.top/2019/08/30/Sklearn——决策树/","excerpt":"","text":"Sklearn——决策树 注明：转载自Jack Gui的博客 1、实战背景 进入本文的正题：眼科医生是如何判断患者需要佩戴隐形眼镜的类型的？一旦理解了决策树的工作原理，我们甚至也可以帮助人们判断需要佩戴的镜片类型。 隐形眼镜数据集是非常著名的数据集，它包含很多换着眼部状态的观察条件以及医生推荐的隐形眼镜类型。隐形眼镜类型包括硬材质(hard)、软材质(soft)以及不适合佩戴隐形眼镜(no lenses)。数据来源与UCI数据库，数据集下载地址：[lenses.txt)]([https://github.com/Jack-Cherish/Machine-Learning/blob/master/Decision Tree/lenses.txt](https://github.com/Jack-Cherish/Machine-Learning/blob/master/Decision Tree/lenses.txt)) young myope no reduced no lenses young myope no normal soft young myope yes reduced no lenses young myope yes normal hard young hyper no reduced no lenses young hyper no normal soft young hyper yes reduced no lenses young hyper yes normal hard pre myope no reduced no lenses pre myope no normal soft pre myope yes reduced no lenses pre myope yes normal hard pre hyper no reduced no lenses pre hyper no normal soft pre hyper yes reduced no lenses pre hyper yes normal no lenses presbyopic myope no reduced no lenses presbyopic myope no normal no lenses presbyopic myope yes reduced no lenses presbyopic myope yes normal hard presbyopic hyper no reduced no lenses presbyopic hyper no normal soft presbyopic hyper yes reduced no lenses presbyopic hyper yes normal no lenses 一共有24组数据，数据的Labels依次是age、prescript、astigmatic、tearRate、class，也就是第一列是年龄，第二列是症状，第三列是是否散光，第四列是眼泪数量，第五列是最终的分类标签。数据如下图所示： 2、使用Sklearn构建决策树 官方英文文档地址：http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html sklearn.tree模块提供了决策树模型，用于解决分类问题和回归问题： 本次实战内容使用的是DecisionTreeClassifier和export_graphviz，前者用于决策树构建，后者用于决策树可视化。 DecisionTreeClassifier构建决策树： 让我们先看下DecisionTreeClassifier这个函数，一共有12个参数： 参数说明如下： **criterion：**特征选择标准，可选参数，默认是gini，可以设置为entropy。gini是基尼不纯度，是将来自集合的某种结果随机应用于某一数据项的预期误差率，是一种基于统计的思想。entropy是香农熵，也就是上篇文章讲过的内容，是一种基于信息论的思想。Sklearn把gini设为默认参数，应该也是做了相应的斟酌的，精度也许更高些？ID3算法使用的是entropy，CART算法使用的则是gini。 **splitter：**特征划分点选择标准，可选参数，默认是best，可以设置为random。每个结点的选择策略。best参数是根据算法选择最佳的切分特征，例如gini、entropy。random随机的在部分划分点中找局部最优的划分点。默认的&quot;best&quot;适合样本量不大的时候，而如果样本数据量非常大，此时决策树构建推荐&quot;random&quot;。 max_features： 划分时考虑的最大特征数，可选参数，默认是None。寻找最佳切分时考虑的最大特征数(n_features为总共的特征数)，有如下6种情况： 如果max_features是整型的数，则考虑max_features个特征； 如果max_features是浮点型的数，则考虑int(max_features * n_features)个特征； 如果max_features设为auto，那么max_features = sqrt(n_features)； 如果max_features设为sqrt，那么max_featrues = sqrt(n_features)，跟auto一样； 如果max_features设为log2，那么max_features = log2(n_features)； 如果max_features设为None，那么max_features = n_features，也就是所有特征都用。 一般来说，如果样本特征数不多，比如小于50，我们用默认的&quot;None&quot;就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。 **max_depth：**决策树最大深，可选参数，默认是None。这个参数是这是树的层数的。层数的概念就是，比如在贷款的例子中，决策树的层数是2层。如果这个参数设置为None，那么决策树在建立子树的时候不会限制子树的深度。一般来说，数据少或者特征少的时候可以不管这个值。或者如果设置了min_samples_slipt参数，那么直到少于min_smaples_split个样本为止。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。 **min_samples_split：**内部节点再划分所需最小样本数，可选参数，默认是2。这个值限制了子树继续划分的条件。如果min_samples_split为整数，那么在切分内部结点的时候，min_samples_split作为最小的样本数，也就是说，如果样本已经少于min_samples_split个样本，则停止继续切分。如果min_samples_split为浮点数，那么min_samples_split就是一个百分比，ceil(min_samples_split * n_samples)，数是向上取整的。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 **min_samples_leaf：**叶子节点最少样本数，可选参数，默认是1。这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。叶结点需要最少的样本数，也就是最后到叶结点，需要多少个样本才能算一个叶结点。如果设置为1，哪怕这个类别只有1个样本，决策树也会构建出来。如果min_samples_leaf是整数，那么min_samples_leaf作为最小的样本数。如果是浮点数，那么min_samples_leaf就是一个百分比，同上，celi(min_samples_leaf * n_samples)，数是向上取整的。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 **min_weight_fraction_leaf：**叶子节点最小的样本权重和，可选参数，默认是0。这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。 **max_leaf_nodes：**最大叶子节点数，可选参数，默认是None。通过限制最大叶子节点数，可以防止过拟合。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。 **class_weight：**类别权重，可选参数，默认是None，也可以字典、字典列表、balanced。指定样本各类别的的权重，主要是为了防止训练集某些类别的样本过多，导致训练的决策树过于偏向这些类别。类别的权重可以通过{class_label：weight}这样的格式给出，这里可以自己指定各个样本的权重，或者用balanced，如果使用balanced，则算法会自己计算权重，样本量少的类别所对应的样本权重会高。当然，如果你的样本类别分布没有明显的偏倚，则可以不管这个参数，选择默认的None。 **random_state：**可选参数，默认是None。随机数种子。如果是证书，那么random_state会作为随机数生成器的随机数种子。随机数种子，如果没有设置随机数，随机出来的数与当前系统时间有关，每个时刻都是不同的。如果设置了随机数种子，那么相同随机数种子，不同时刻产生的随机数也是相同的。如果是RandomState instance，那么random_state是随机数生成器。如果为None，则随机数生成器使用np.random。 **min_impurity_split：**节点划分最小不纯度,可选参数，默认是1e-7。这是个阈值，这个值限制了决策树的增长，如果某节点的不纯度(基尼系数，信息增益，均方差，绝对差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。 **presort：**数据是否预排序，可选参数，默认为False，这个值是布尔值，默认是False不排序。一般来说，如果样本量少或者限制了一个深度很小的决策树，设置为true可以让划分点选择更加快，决策树建立的更加快。如果样本量太大的话，反而没有什么好处。问题是样本量少的时候，我速度本来就不慢。所以这个值一般懒得理它就可以了。 除了这些参数要注意以外，其他在调参时的注意点有： 当样本数量少但是样本特征非常多的时候，决策树很容易过拟合，一般来说，样本数比特征数多一些会比较容易建立健壮的模型 如果样本数量少但是样本特征非常多，在拟合决策树模型前，推荐先做维度规约，比如主成分分析（PCA），特征选择（Losso）或者独立成分分析（ICA）。这样特征的维度会大大减小。再来拟合决策树模型效果会好。 推荐多用决策树的可视化，同时先限制决策树的深度，这样可以先观察下生成的决策树里数据的初步拟合情况，然后再决定是否要增加深度。 在训练模型时，注意观察样本的类别情况（主要指分类树），如果类别分布非常不均匀，就要考虑用class_weight来限制模型过于偏向样本多的类别。 决策树的数组使用的是numpy的float32类型，如果训练数据不是这样的格式，算法会先做copy再运行。 如果输入的样本矩阵是稀疏的，推荐在拟合前调用csc_matrix稀疏化，在预测前调用csr_matrix稀疏化。 sklearn.tree.DecisionTreeClassifier()提供了一些方法供我们使用，如下图所示： Code1 12345678910# -*- coding: UTF-8 -*-from sklearn import treeif __name__ == '__main__': fr = open('lenses.txt') lenses = [inst.strip().split('/t') for inst in fr.readlines()] print(lenses) lensesLabels = ['age', 'prescript', 'astigmatic', 'tearRate'] clf = tree.DecisionTreeClassifier() lenses = clf.fit(lenses, lensesLabels) ▲ 我们可以看到程序报错了，这是为什么？因为在fit()函数不能接收string类型的数据，通过打印的信息可以看到，数据都是string类型的。在使用fit()函数之前，我们需要对数据集进行编码，这里可以使用两种方法： LabelEncoder ：将字符串转换为增量值 OneHotEncoder：使用One-of-K算法将字符串转换为整数 为了对string类型的数据序列化，需要先生成pandas数据，这样方便我们的序列化工作。这里我使用的方法是，原始数据-&gt;字典-&gt;pandas数据，编写代码如下： 12345678910111213141516171819202122# -*- coding: UTF-8 -*-import pandas as pdif __name__ == '__main__': with open('lenses.txt', 'r') as fr: #加载文件 lenses = [inst.strip().split('/t') for inst in fr.readlines()] #处理文件 lenses_target = [] #提取每组数据的类别，保存在列表里 for each in lenses: lenses_target.append(each[-1]) lensesLabels = ['age', 'prescript', 'astigmatic', 'tearRate'] #特征标签 lenses_list = [] #保存lenses数据的临时列表 lenses_dict = &#123;&#125; #保存lenses数据的字典，用于生成pandas for each_label in lensesLabels: #提取信息，生成字典 for each in lenses: lenses_list.append(each[lensesLabels.index(each_label)]) lenses_dict[each_label] = lenses_list lenses_list = [] print(lenses_dict) #打印字典信息 lenses_pd = pd.DataFrame(lenses_dict) #生成pandas.DataFrame print(lenses_pd) # 顺利生成pandas数据。 接下来，将数据序列化，编写代码如下： 1234567891011121314151617181920212223242526272829# -*- coding: UTF-8 -*-import pandas as pdfrom sklearn.preprocessing import LabelEncoderimport pydotplusfrom sklearn.externals.six import StringIOif __name__ == '__main__': with open('lenses.txt', 'r') as fr: #加载文件 lenses = [inst.strip().split('/t') for inst in fr.readlines()] #处理文件 lenses_target = [] #提取每组数据的类别，保存在列表里 for each in lenses: lenses_target.append(each[-1]) lensesLabels = ['age', 'prescript', 'astigmatic', 'tearRate'] #特征标签 lenses_list = [] #保存lenses数据的临时列表 lenses_dict = &#123;&#125; #保存lenses数据的字典，用于生成pandas for each_label in lensesLabels: #提取信息，生成字典 for each in lenses: lenses_list.append(each[lensesLabels.index(each_label)]) lenses_dict[each_label] = lenses_list lenses_list = [] # print(lenses_dict) #打印字典信息 lenses_pd = pd.DataFrame(lenses_dict) # 生成pandas.DataFrame print(lenses_pd) #打印pandas.DataFrame le = LabelEncoder() #创建LabelEncoder()对象，用于序列化 for col in lenses_pd.columns: #为每一列序列化 lenses_pd[col] = le.fit_transform(lenses_pd[col]) print(lenses_pd) 从打印结果可以看到，我们已经将数据顺利序列化，接下来。我们就可以fit()数据，构建决策树了。 3、使用Graphviz可视化决策树 Graphviz的是AT&amp;T Labs Research开发的图形绘制工具，他可以很方便的用来绘制结构化的图形网络，支持多种格式输出，生成图片的质量和速度都不错。它的输入是一个用dot语言编写的绘图脚本，通过对输入脚本的解析，分析出其中的点，边以及子图，然后根据属性进行绘制。是使用Sklearn生成的决策树就是dot格式的，因此我们可以直接利用Graphviz将决策树可视化。 在讲解编写代码之前，我们需要安装两样东西，即pydotplus和Grphviz。 （1）安装Pydotplus pydotplus可以在CMD窗口中，直接使用指令安装：pip3 install pydotplus （2）安装Graphviz Graphviz不能使用pip进行安装，我们需要手动安装，下载地址：https://www.graphviz.org，可能下载比较慢。 安装以后，需要设置环境变量，如将D:/graphviz-2.38/release/bin加入到Path中，然后运行下之后的代码看是否能正常使用。 （3）编写代码 Talk is Cheap, show me the code.(废话少说，放码过来)。可视化部分的代码不难，都是有套路的，直接填参数就好，详细内容可以查看官方教程：http://scikit-learn.org/stable/modules/tree.html#tree 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: UTF-8 -*-from sklearn.preprocessing import LabelEncoder, OneHotEncoderfrom sklearn.externals.six import StringIOfrom sklearn import treeimport pandas as pdimport numpy as npimport pydotplusif __name__ == '__main__': with open('lenses.txt', 'r') as fr: #加载文件 lenses = [inst.strip().split('/t') for inst in fr.readlines()] #处理文件 lenses_target = [] #提取每组数据的类别，保存在列表里 for each in lenses: lenses_target.append(each[-1]) print(lenses_target) lensesLabels = ['age', 'prescript', 'astigmatic', 'tearRate'] #特征标签 lenses_list = [] #保存lenses数据的临时列表 lenses_dict = &#123;&#125; #保存lenses数据的字典，用于生成pandas for each_label in lensesLabels: #提取信息，生成字典 for each in lenses: lenses_list.append(each[lensesLabels.index(each_label)]) lenses_dict[each_label] = lenses_list lenses_list = [] # print(lenses_dict) #打印字典信息 lenses_pd = pd.DataFrame(lenses_dict) #生成pandas.DataFrame # print(lenses_pd) #打印pandas.DataFrame le = LabelEncoder() #创建LabelEncoder()对象，用于序列化 for col in lenses_pd.columns: #序列化 lenses_pd[col] = le.fit_transform(lenses_pd[col]) # print(lenses_pd) #打印编码信息 clf = tree.DecisionTreeClassifier(max_depth = 4) #创建DecisionTreeClassifier()类 clf = clf.fit(lenses_pd.values.tolist(), lenses_target) #使用数据，构建决策树 dot_data = StringIO() tree.export_graphviz(clf, out_file = dot_data, #绘制决策树 feature_names = lenses_pd.keys(), class_names = clf.classes_, filled=True, rounded=True, special_characters=True) graph = pydotplus.graph_from_dot_data(dot_data.getvalue()) graph.write_pdf(\"tree.pdf\") #保存绘制好的决策树，以PDF的形式存储。 运行代码，在该python文件保存的相同目录下，会生成一个名为tree的PDF文件，打开文件，我们就可以看到决策树的可视化效果图了。 确定好决策树之后，我们就可以做预测了。可以根据自己的眼睛情况和年龄等特征，看一看自己适合何种材质的隐形眼镜。使用如下代码就可以看到预测结果：print(clf.predict([[1,1,1,0]])) #预测 总结 决策树的一些优点： 易于理解和解释。决策树可以可视化。 几乎不需要数据预处理。其他方法经常需要数据标准化，创建虚拟变量和删除缺失值。决策树还不支持缺失值。 使用树的花费（例如预测数据）是训练数据点(data points)数量的对数。 可以同时处理数值变量和分类变量。其他方法大都适用于分析一种变量的集合。 可以处理多值输出变量问题。 使用白盒模型。如果一个情况被观察到，使用逻辑判断容易表示这种规则。相反，如果是黑盒模型（例如人工神经网络），结果会非常难解释。 即使对真实模型来说，假设无效的情况下，也可以较好的适用。 决策树的一些缺点： 决策树学习可能创建一个过于复杂的树，并不能很好的预测数据。也就是过拟合。修剪机制（现在不支持），设置一个叶子节点需要的最小样本数量，或者数的最大深度，可以避免过拟合。 决策树可能是不稳定的，因为即使非常小的变异，可能会产生一颗完全不同的树。这个问题通过decision trees with an ensemble来缓解。 概念难以学习，因为决策树没有很好的解释他们，例如，XOR, parity or multiplexer problems。 如果某些分类占优势，决策树将会创建一棵有偏差的树。因此，建议在训练之前，先抽样使样本均衡。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Pythton","slug":"Pythton","permalink":"https://nymrli.top/tags/Pythton/"}]},{"title":"ACM-博弈论","slug":"ACM-博弈论","date":"2019-08-30T13:41:28.000Z","updated":"2019-09-15T08:07:30.912Z","comments":true,"path":"2019/08/30/ACM-博弈论/","link":"","permalink":"https://nymrli.top/2019/08/30/ACM-博弈论/","excerpt":"","text":"ACM-博弈论（gambling） 博弈论：是二人或多人在平等的对局中各自利用对方的策略变换自己的对抗策略，达到取胜目标的理论。假设，双方每步都是最优决策 博弈论是研究互动决策的理论。博弈可以分析自己与对手的利弊关系，从而确立自己在博弈中的优势，因此有不少博弈理论，可以帮助对弈者分析局势，从而采取相应策略，最终达到取胜的目的。 巴什博弈 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 显然，如果n=m+1，1那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了先手如何取胜的法则：除了先手取以外，之后每个双方回合时保证取走m+1个物品则能保证先手胜。 ▲即如果n=(m+1)*r+s，（r为任意自然数，0&lt;s&lt;=m），那么先取者要拿走s个物品，如果后取者拿走k（&lt;=m）个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。 结论 编程解题的方法就是判断n是否能表示为(m+1)*r+s，找到这个m，和存在r，s s不为0，所以当n=(m+1)*r时，后手必胜 这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。 例题HDU1846——Brave Game，裸题 n为总价、总和，m为每次能取的大小 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, m; int t; cin &gt;&gt; t; while(t--)&#123; cin&gt;&gt;n &gt;&gt;m; int mod = n%(m+1); if (mod != 0) cout &lt;&lt; \"first\" &lt;&lt;endl; else cout &lt;&lt; \"second\" &lt;&lt; endl; &#125; return 0;&#125; Public Sale 区别在于还存在n&lt;m的情况，由于题目要求每次加价的幅度要在1～N之间，当价格大于或等于田地的成本价 M 时，主办方就把这块田地卖给这次叫价的人。，所以此时，第一次出价n+1~m都可以直接将物品买下，需要单独考虑 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, m; while (cin &gt;&gt; n&gt;&gt;m)&#123; if (n&lt;m) &#123; for(int i=n+1;i&lt;=m;i++) cout &lt;&lt; i &lt;&lt; \" \"; cout &lt;&lt; endl; &#125;else&#123; int mod = n%(m+1); if (mod == 0) cout &lt;&lt; \"none\"&lt;&lt;endl; //s=0，后手必胜 else cout &lt;&lt; mod &lt;&lt; endl; //存在s，即先手的Lele能买到 &#125; &#125; return 0;&#125; 斐波那契博弈 有一堆个数为n的石子，游戏双方轮流取石子，满足： 1）先手不能在第一次把所有的石子取完； 2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。 ▲ 游戏规则动态化 这个游戏叫做Fibonacci Nim，肯定和Fibonacci数列：f[n]：1，2，3，5，8，13，21，34，55，89…有密切的关系。如果试验一番之后，可以猜测：先手胜当且仅当n不是Fibonacci数。换句话说，必败态构成Fibonacci数列。 就像“Wythof博弈”需要“Beatty定理”来帮忙一样，这里需要借助**“Zeckendof定理”（齐肯多夫定理）**：任何正整数可以表示为若干个不连续的Fibonacci数之和。定理的证明可以在这里看到，不过我觉得更重要的是自己动手分解一下。 e.g.比如，我们要分解83，注意到83被夹在55和89之间，于是把83可以写成83=55+28；然后再想办法分解28，28被夹在21和34之间，于是28=21+7；依此类推7=5+2，故； 如果n=83，我们看看这个分解有什么指导意义：假如先手取2颗，那么后手无法取5颗或更多，而5是一个Fibonacci数，如果猜测正确的话，（面临这5颗的先手实际上是整个游戏的后手）归纳得如果需要取走斐波那契数n，那么后手必胜，即那么一定是游戏的先手（此时为取5个的后手）取走这5颗石子中的最后一颗，而这个我们可以通过第二类归纳法来绕过，同样的道理，接下去先手取走接下来的后21颗中的最后一颗，再取走后55颗中的最后一颗，那么先手赢。需要注意到的是分解后不连续的若干个数单个的两倍都小于分解的最大数，即2n&lt;m ▲如果n是斐波那契数，后手一定赢，如果不是，先手一定赢（先手胜当且仅当n不是斐波那契数列）。因为如果n是斐波那契数，那么先手取走数之后剩下的一定不是斐波那契数，后手必胜 例题hdoj 2516 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int arr[50];// feiboint main()&#123; int n; arr[0] = 2,arr[1] = 3; for(int i=2;i&lt;=50;i++) arr[i]=arr[i-1]+arr[i-2]; while (cin &gt;&gt; n &amp;&amp; n)&#123; int flag = 1; for(int i=0;i&lt;=50;i++)&#123; if (arr[i]==n) flag=0,cout&lt;&lt;\"Second win\"&lt;&lt;endl; if (arr[i]&gt;n) break; &#125; if (flag) cout &lt;&lt; \"First win\" &lt;&lt;endl; &#125; return 0;&#125; 总结： 不需要深究博弈论数学原理，只需要知道结论，就可以写出代码。如， 巴什博弈：判断mod=n%(m+1)的结果s 斐波那契博弈：判断n是否为斐波那契数 威佐夫博弈 有两维各若干个物品(ak, bk)，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况下是颇为复杂的。我们用（ak，bk）（ak&lt;=bk，k=0，1，2，.……n）表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出，a0=b0=0，ak是未在前面出现过的最小自然数，而bk=ak+k，奇异局势有如下三条性质： 1.任何自然数都包含在一个且仅有一个奇异局势中。 由于ak是未在前面出现过的最小自然数，所以有ak&gt;ak-1，而bk=ak+k&gt;ak-1+k-1=bk-1&gt;ak-1。所以性质1。成立。 2.任意操作都可将奇异局势变为非奇异局势。 事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。 3.采用适当的方法，可以将非奇异局势变为奇异局势。 从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，面对奇异局势，则后拿者取胜。 Betty定理:… ▲那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： ak =[k（1+V5）/2]，bk=ak+k（k=0，1，2，.……n方括号表示取整函数）奇妙的是其中出现了黄金分割数（1+V5）/2=1.618…，因此，由ak，bk组成的矩形近似为黄金矩形，由于2/（1+V5）=（V5-1）/2，可以先求出j=[a（V5-1）/2]，若a=[（1+V5）/2]，那么a=aj，bj=aj+j，若不等于，那么a=aj+1，bj+1=aj+1+j+1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。===&gt; 如果(b-a)*(sqrt(5.0)+1)/2 == a的话就是奇异局势 例题poj 1067，裸题 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a, b, c; while(cin &gt;&gt; a &gt;&gt; b)&#123; if (a&gt;b) swap(a,b); int c = floor((b-a)*(sqrt(5.0)+1)/2); if (a==c) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; 1 &lt;&lt; endl; &#125; return 0;&#125; 尼姆博弈（Nim） 有n堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 以n=3为例子，这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情形。 然而这并不是博弈的重点，博弈之王道乃是SG值，当sg值为0的时候，就是输，不为0就是赢； SG值：一个点的SG值就是一个不等于它的后继点SG值的且大于等于零的最小整数。 不属于它后继点SG值集的值 大概的意思就是：在步骤允许的情况下，与前面一个必败点的差（也就是说这个差是规定的、能走的、其中一个步数）！ 后继点：也就是按照题目要求的走法（比如取石子可以取的数量，方法）能够走一步达到的那个点。（sg值的理解很抽象。需要多画画） 举个栗子：比如一堆石子，我们可以取任意个，那么x个石子的石子的sg值是多少呢？可以知道，0个石子sg为0，1的时候我们可以取一个，剩下0，0的sg是0(SG(0)=0)，那么mex(0)就是1，所以1的sg为1(SG(1)=1)。即SG(1) = mex{SG(0)}=mex{0}=1 例题hdoj 1847 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int arr[15],sg[1005];int mex(int x)&#123; if(sg[x] != -1) return sg[x]; // 记忆化搜索,如果存在直接返回 bool vis[1005]; for(int i=0; i&lt;1005;i++) vis[i] = false; for (int i =0;i&lt;=10;i++) &#123; int temp = x - arr[i]; if (temp&lt;0) break; // SG值为非负整数 sg[temp] = mex(temp); // 需要递归调用，分治求出小的部分的结果 vis[sg[temp]] = true; &#125; for (int i =0;;i++) if(!vis[i]) &#123; // 找到最小的数，mex&#123;0,1,2&#125;=3，mex&#123;1,2,3&#125;=0，mex&#123;0,1,3&#125;=2； sg[x]=i; break; &#125; return sg[x];&#125;int main()&#123; int n; arr[0] = 1; for (int i = 1; i&lt;=10; i++) arr[i] = arr[i-1]*2; while(cin &gt;&gt; n)&#123; memset(sg,-1,sizeof(sg)); if (mex(n)) cout &lt;&lt; \"Kiki\" &lt;&lt;endl; else cout &lt;&lt; \"Cici\" &lt;&lt; endl; &#125; return 0;&#125; 组合博弈：（博弈的精华） 组合博弈无疑是对sg值的熟练操作例如：有n堆石子，每次可以从第1堆石子里取1颗、2颗或3颗，可以从第2堆石子里取奇数颗，可以从第3堆及以后石子里取任意颗.……我们可以把它看作3个子游戏，第1个子游戏只有一堆石子，每次可以取1、2、3颗，很容易看出x颗石子的局面的SG值是×%4。第2个子游戏也是只有一堆石子，每次可以取奇数颗，经过简单的画图可以知道这个游戏有x颗石子时的SG值是×%2。第3个游戏有n-2堆石子，就是一个Nim游戏。对于原游戏的每个局面，把三个子游戏的SG值异或一下就得到了整个游戏的SG值，然后就可以根据这个SG值判断是否有必胜策略以及做出决策了。其实看作3个子游戏还是保守了些，干脆看作n个子游戏，其中第1、2个子游戏如上所述，第3个及以后的子游戏都是“1堆石子，每次取几颗都可以”，称为“任取石子游戏”，这个超简单的游戏有x颗石子的SG值显然就是x。 SWPU-ACM每周算法讲堂-博弈论入门 计算机博弈大赛 蒙特卡洛方法 由冯·诺依曼、乌拉姆等人发明，因蒙特卡洛赌场而闻名，一种基于概率的方法的统称。 一种让人感觉“我去，这也行”的方法——根据大概率逼近真实结果的方法 拉斯维加斯（Las Vegas）方法——找老婆（必须要精确找到那一个答案，其他都不行。采样越多，越有机会找到最优解） 找1W人才能准确确定 蒙特卡罗（Monte Carlo）方法——民意调查（一直在找，找的是逐渐贴近于最优解的结果。当样越多，越近似最优解） 找了2K人大致能确定了 相关方法： 蒙特卡罗算法、蒙特卡罗模拟、蒙特卡罗过程 蒙特卡罗搜索树一—AlphaGo 工作原理： 不断抽样（中心极限定理，n-&gt;∞） 逐渐逼近（依概率逼近） 蒙特卡洛树搜索 （MCTS，Monte Carlo tree search） 一种用于某些决策过程的启发式搜索算法，最引人注目的是在游戏中的使用 双人有限零和顺序游戏 MCTS运行所在的框架/环境是一个游戏，它本身是一个非常抽象和宽泛的概念，因此这里我们只关注一种游戏类型：双人有限零和顺序游戏。这个名词一开始听起来会有些复杂，但是实际上非常简单，现在来让我们将它分解一下： 游戏：意味着我们在一种需要交互的情境中，交互通常会涉及一个或多个角色 有限：表明在任意时间点，角色之间存在的交互方式都是有限的 双人：游戏中只有两个角色 顺序：玩家依次交替进行他们的动作 零和：参与游戏的两方有完全相反的目标，换句话说就是，游戏的任意结束状态双方的收益之和等于零 我们可以很轻松的验证，围棋、国际象棋和井字棋都是双人有限零和顺序游戏：有两位玩家参与，玩家能进行的动作总是有限的，双方的游戏目标是完全相反的（所有游戏的结果之和等于0）。 如何表示一个游戏 从程序员的角度来看，可以用一种常见的数据结构以来表示游戏——游戏树。 游戏树是一个数，其中每一个节点代表游戏的一个确定状态。从一个节点到该节点的一个子节点（如果存在）是一个移动。节点的子节点数目称为分支因子。游戏树的根节点代表游戏的初始状态。游戏树的终端节点是没有子节点的节点，至此游戏结束，无法再进行移动。终端节点的状态也就是游戏的结果（输/赢/平局）。 游戏树是一种递归的数据结构，每次选择完最佳的下一步时，会移动到下一个子节点，而这个子节点又是它子树的根节点。因此我们可以把一局游戏视为“最佳下一步”的一个问题序列，每一次都可以由一个不同根节点的游戏树表示。通常在实际应用中，我们不需要记住到当前状态的路径，因为这不是当前游戏状态的关注点。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"Linux三剑客","slug":"Linux三剑客","date":"2019-08-30T13:37:36.000Z","updated":"2019-09-15T08:07:30.957Z","comments":true,"path":"2019/08/30/Linux三剑客/","link":"","permalink":"https://nymrli.top/2019/08/30/Linux三剑客/","excerpt":"","text":"Linux三剑客 bash命令执行顺序 把命令行分成单个命令词 展开别名 展开大括号的声明（{}） 展开波浪符声明（~） 命令替换$0和&quot;) 再次把命令行分成命令词 展开文件通配（*、？、[abc]等等） 准备I/0重导向（&lt;、&gt;） 运行命令 文件查找 非实时搜索locate 速度快 更新updatabase 实时搜索工具find 搜索速度略慢 精确查找 只能搜索用户具备读取和执行权限的目录 sed(Stream EDitor): sed使用单引号 sed -n '22,$p' test 指令解释:常用选项[-n]，‘地址定界[22,$],编辑命令[p]’ 地址定界: 不给地址: 全文处理 单地址 #: 指定行 $: 最后一行 /pattern: 正则匹配 地址范围 #,#,如1,20即1-20行 e.g.sed -n '22,$p' test #,+#,如2,+20即2-2+20 行 #;#如3;5即第3和第5行 /pat1/,/pat2/ #,/pat1/ 步进~ 1~2 奇数行 sed -n &quot;1~2p&quot; f1 2~2 偶数行 正则 sed ‘/regex expression/[option] text’ filename ^匹配每一行的开头 $匹配行的结尾 匹配包含2、3、或者4的行 sed -n '/[234]/p' employee.txt 删除所有以#开头的行 **sed -e 's/^#./*// ; /^$/d' employee.txt** 删除所有注释和空行 sed -e 's/#.*//;/^$/ d' /etc/profile 只删除注释行不删除空行 sed '/^#.*/d' /etc/profile 常用选项 -n不自动打印 -f 指定文件中读取编辑脚本 script.txt 12~2p sed -n -f script.txt f1 -r支持使用拓展正则表达式 sed -r 's/(GRUB_CMDLINE_LINUX.*)&quot;$//1 xyz&quot;/'/etc/default/grub echo&quot;/etc/sysconfig/network/&quot; | sed -r 's/(.*//)([^/]//?$)//1/' -i.bak生成备份文件bak并原处编辑 如果没有-i表示只是预览,不会真正执行 -e多点编辑,即多次处理文件 编辑命令 d删除末世空间匹配的行,并启用下一轮循环 sed -n 'd' test全删 sed -n '1d' test只删第一行 p打印当前模式空间内容,追加到默认输出后 a[/]test 指定行追加 i[/]test 行前插入 c[/]test 替换行为单行或多行 = 为模式空间中的行打印行号 sed -n ‘3,5{=;p}’ test ! 模式空间中匹配行取反 w/path/somefile：保存模式匹配的行至指定文件 r/path/somefile：读取指定文件的文本至模式空间中匹配到的行后 sed'/User/r sed.txt' .bashrc 搜索代替 123sed &apos;s/xxx/xxx/&apos; filename# sed &apos;s@xxx@xxx&apos; filename# sed &apos;s#xxx#xxx&apos; filename 替换标记： g：行内全局替换 p：显示替换成功的行 W/PATH/TO/SOMEFILE：将替换成功的行保存至文件中 以下命令如果需要在文本中更改 需要加 -i 或者 -ri参数 用sed在aaa前加#注释 1sed 's/^aaa/#&amp;/' zimu.txt # &amp;的意思是匹配任意字符（就是说未知数，啥都行） 这条命令是 替换以aaa开头的 用sed取消bbb前面的注释 12sed 's/^#(bbb)//1/' zimu.txt #/1的意思 就类似于 前面的 (bbb/） /1就是复制这个位置的内容 如果有 第二个 那么久/2就是复制第二个位置的内容sed 's/^#bbb/bbb/' zimu.txt 上面那条命令等同于 awk 优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一 ifconfig获得ip_addr的命令 1.ifconfig | grep inet | awk '{print $2}' | awk -F 'addr:' '{print $2}' 2.ifconfig | grep addr:192.168.* | awk '{print$2}' | awk '{split($0,a,/&quot;:/&quot;);print(a[2])}' ▲.尽量使用单引号'',而不是&quot;&quot; -F分隔符 e.g.echo &quot;A|B|C|D&quot; | awk -F &quot;|&quot; '{print($1)}' NF列的个数 awk -F: '$3&lt;10{print $1 &lt;====&gt; $NF}' /etc/passwd {}中的内容为要要执行的内容 NR当前行号 linux单双引号区别 双引号：把双引号的内容输出出来；如果内容中有命令，变量等，会先把命令，变量解析出结果，然后再输出最终内容来。双引号内命令或变量的写法为命令或变量或$（命令或变量） 单引号：所见即所得，将单引号内的内容原样输出，阻止所有字符的转义 不加引号：不会将含有空格的字符串视为一个整体输出，如果内容中有命令，变量等，会先把命令，变量解析出结果，然后再输出最终内容来，如果字符串含有空格等特殊字符，则不能完整输出，则需改加双引号。 倒引号（反引号Esc键下方）：进行命令的替换，在倒引号内部的shell命令将会被执行，其结果输出代替用倒引号括起来的文本。 echo &quot;1111/n222&quot;不会转移/n echo -e &quot;11111/n222&quot;会转义/n xargs -n1每行1个元素;xargs -n2 每行2个元素; grep(Globally search a Regular Expression and Print) 一种强大的文本搜索工具，它能使用特定模式匹配（包括正则表达式）搜索文本，并默认输出匹配行 常见命令ps -aux | grep xxxx 选项与参数： -a ：将 binary 文件以 text 文件的方式搜寻数据 -c ：计算找到 ‘搜寻字符串’ 的次数 -i ：忽略大小写的不同，所以大小写视为相同 -n ：顺便输出行号 -v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！ -x --line-regexp : 只显示全列符合的列。","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://nymrli.top/tags/运维/"},{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"2019_6月编程笔记","slug":"2019-6月编程笔记","date":"2019-08-30T13:26:03.000Z","updated":"2019-11-26T07:42:09.614Z","comments":true,"path":"2019/08/30/2019-6月编程笔记/","link":"","permalink":"https://nymrli.top/2019/08/30/2019-6月编程笔记/","excerpt":"","text":"2019_6月编程笔记 注，不少内容比较多，已单独分出去成为独立的文章，更详细的介绍可见这些文章 硬盘格式 fat32 单文件4G， 做引导分区 系统引导程序能读fat32 只能主引导记录，选择能找到efi程序 exfat 支持更大空间，引导识别不了，做不了系统盘 Python all __all__是一个字符串list； 约束作用：用来定义模块中对于from XXX import *时要对外导出的符号，即要暴露的借口，但它只对import *起作用，对from XXX import XXX不起作用。 from njupt.zhengfang import Zhengfang是在__init__.py里用all标出后在该目录下的其他模块能直接通过from njupt import Zhengfang来调用。修改了导入的方式 eval 和 exec 1.exec能执行多段Python代码，eval只能执行当行 123456exec(\"\"\"print('hello')print('world')\"\"\")eval(\"print('hello')\") 2.而Python中的eval函数可以计算Python表达式，并返回结果；（exec不返回结果，print(eval(&quot;…&quot;))打印None）； os.environ 12345678910111213# 使用os.environ来读取和修改环境变量：import osprint (os.environ[\"TEMP\"])mydir = \"c://mydir\"os.environ[\"MYDIR\"] = mydirprint (os.environ[\"MYDIR\"])pathV = os.environ[\"PATH\"]print (pathV)os.environ[\"PATH\"]= mydir + \";\" + os.environ[\"PATH\"]print (os.environ[\"PATH\"]) sys.path的insert和append python程序中使用 import XXX 时，python解析器会在当前目录、已安装和第三方模块中搜索 xxx，如果都搜索不到就会报错。 使用sys.path.append()方法可以临时添加搜索路径，方便更简洁的import其他包和模块。这种方法导入的路径会在python程序退出后失效。 1.对于模块和自己写的脚本不在同一个目录下，在脚本开头加 12import sys sys.path.append(’引用模块的地址') 2.把路径添加到系统的环境变量，或把该路径的文件夹放进已经添加到系统环境变量的路径内。环境变量的内容会自动添加到模块搜索路径中。 insert：定义搜索优先顺序 12import syssys.path.insert(1, \"./model\") sys.path.insert(1, &quot;./crnn&quot;)定义搜索路径的优先顺序，序号从0开始，表示最大优先级，sys.path.insert()加入的也是临时搜索路径，程序退出后失效。 sphinx使用 pip install sphinx 1.新建docs文件夹 2.sphinx-quickstart 3.配置 教程说明： 12345678910111213141516171819202122&gt; Root path for the documentation [.]: doc # 在当前目录下新建doc文件夹存放sphinx相关信息&gt; Separate source and build directories (y/n) [n]: # 默认，直接回车&gt; Name prefix for templates and static dir [_]:&gt; Project name: python123 # 输入项目名称&gt; Author name(s): 123 # 作者&gt; Project version: 1.0 # 项目版本&gt; Project release [1.0]:&gt; Project language [en]: # 默认，回车&gt; Source file suffix [.rst]:&gt; Name of your master document (without suffix) [index]:&gt; Do you want to use the epub builder (y/n) [n]:&gt; autodoc: automatically insert docstrings from modules (y/n) [n]: y # 这个很重要，输入y&gt; doctest: automatically test code snippets in doctest blocks (y/n) [n]:&gt; intersphinx: link between Sphinx documentation of different projects (y/n) [n]:&gt; todo: write \"todo\" entries that can be shown or hidden on build (y/n) [n]:&gt; coverage: checks for documentation coverage (y/n) [n]:&gt; pngmath: include math, rendered as PNG images (y/n) [n]:&gt; mathjax: include math, rendered in the browser by MathJax (y/n) [n]:&gt; ifconfig: conditional inclusion of content based on config values (y/n) [n]:&gt; viewcode: include links to the source code of documented Python objects (y/n) [n]: y # 很重要，输入y，表示将源码也放到文档中，你看很多python的模块的文档，其实都是包含代码的。&gt; Create Makefile? (y/n) [y]:&gt; Create Windows command file? (y/n) [y]: windows实测： 1234567891011121314151617181920212223242526272829303132333435363738(Python_web) E:/Python_web/Code/Quan&gt;sphinx-quickstartWelcome to the Sphinx 2.1.0 quickstart utility.Please enter values for the following settings (just press Enter toaccept a default value, if one is given in brackets).Selected root path: .You have two options for placing the build directory for Sphinx output.Either, you use a directory \"_build\" within the root path, or you separate\"source\" and \"build\" directories within the root path.&gt; Separate source and build directories (y/n) [n]: nThe project name will occur in several places in the built documentation.&gt; Project name: TaobaoQuan&gt; Author name(s): Mrli&gt; Project release []: 1.0If the documents are to be written in a language other than English,you can select a language here by its language code. Sphinx will thentranslate text that it generates into that language.For a list of supported codes, seehttp://sphinx-doc.org/config.html#confval-language.&gt; Project language [en]: enCreating file ./conf.py.Creating file ./index.rst.Creating file ./Makefile.Creating file ./make.bat.Finished: An initial directory structure has been created.You should now populate your master file ./index.rst and create other documentationsource files. Use the Makefile to build the docs, like so: make builderwhere \"builder\" is one of the supported builders, e.g. html, latex or linkcheck. 编写好目录下的所有.rst（默认生成了模板index.rst）文件后./make.bat html可以生成网页目录 conf.py默认模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# Configuration file for the Sphinx documentation builder.## This file only contains a selection of the most common options. For a full# list see the documentation:# http://www.sphinx-doc.org/en/master/config# -- Path setup --------------------------------------------------------------# If extensions (or modules to document with autodoc) are in another directory,# add these directories to sys.path here. If the directory is relative to the# documentation root, use os.path.abspath to make it absolute, like shown here.## import os# import sys# sys.path.insert(0, os.path.abspath('.'))# -- Project information -----------------------------------------------------project = 'TaobaoQuan'copyright = '2019, Mrli'author = 'Mrli'# The full version, including alpha/beta/rc tagsrelease = '1.0'# -- General configuration ---------------------------------------------------# Add any Sphinx extension module names here, as strings. They can be# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom# ones.extensions = []# Add any paths that contain templates here, relative to this directory.templates_path = ['_templates']# List of patterns, relative to source directory, that match files and# directories to ignore when looking for source files.# This pattern also affects html_static_path and html_extra_path.exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']# -- Options for HTML output -------------------------------------------------# The theme to use for HTML and HTML Help pages. See the documentation for# a list of builtin themes.#html_theme = 'alabaster'# Add any paths that contain custom static files (such as style sheets) here,# relative to this directory. They are copied after the builtin static files,# so a file named \"default.css\" will overwrite the builtin \"default.css\".html_static_path = ['_static'] Gaoliang模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161# -*- coding: utf-8 -*-## Configuration file for the Sphinx documentation builder.## This file does only contain a selection of the most common options. For a# full list see the documentation:# http://www.sphinx-doc.org/en/master/config# -- Path setup --------------------------------------------------------------# If extensions (or modules to document with autodoc) are in another directory,# add these directories to sys.path here. If the directory is relative to the# documentation root, use os.path.abspath to make it absolute, like shown here.#import osimport sys# sys.path.insert(0, os.path.abspath('.'))# Insert NJUPT-API' path into the system.sys.path.insert(0, os.path.abspath('..'))# -- Project information -----------------------------------------------------project = '...'copyright = '...'author = '...'# The short X.Y versionversion = ''# The full version, including alpha/beta/rc tagsrelease = ''# -- General configuration ---------------------------------------------------# If your documentation needs a minimal Sphinx version, state it here.## needs_sphinx = '1.0'# Add any Sphinx extension module names here, as strings. They can be# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom# ones.extensions = [ 'sphinx.ext.autodoc',]html_logo = \"_static/logo_tiny.png\"# Add any paths that contain templates here, relative to this directory.templates_path = ['_templates']# The suffix(es) of source filenames.# You can specify multiple suffix as a list of string:## source_suffix = ['.rst', '.md']source_suffix = '.rst'# The master toctree document.master_doc = 'index'# The language for content autogenerated by Sphinx. Refer to documentation# for a list of supported languages.## This is also used if you do content translation via gettext catalogs.# Usually you set \"language\" from the command line for these cases.language = 'zh_CN'# List of patterns, relative to source directory, that match files and# directories to ignore when looking for source files.# This pattern also affects html_static_path and html_extra_path .exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']# The name of the Pygments (syntax highlighting) style to use.pygments_style = 'sphinx'# -- Options for HTML output -------------------------------------------------# The theme to use for HTML and HTML Help pages. See the documentation for# a list of builtin themes.## html_theme = 'sphinx_rtd_theme'# html_theme = 'alabaster'# html_theme = 'flask'# Theme options are theme-specific and customize the look and feel of a theme# further. For a list of options available for each theme, see the# documentation.#html_theme_options = &#123; # 'show_powered_by': False,&#125;# Add any paths that contain custom static files (such as style sheets) here,# relative to this directory. They are copied after the builtin static files,# so a file named \"default.css\" will overwrite the builtin \"default.css\".html_static_path = ['_static']# Custom sidebar templates, must be a dictionary that maps document names# to template names.## The default sidebars (for documents that don't match any pattern) are# defined by theme itself. Builtin themes are using these templates by# default: ``['localtoc.html', 'relations.html', 'sourcelink.html',# 'searchbox.html']``.#html_show_sourcelink = False# -- Options for HTMLHelp output ---------------------------------------------# Output file base name for HTML help builder.htmlhelp_basename = 'NJUPT-APIdoc'# -- Options for LaTeX output ------------------------------------------------latex_elements = &#123; # The paper size ('letterpaper' or 'a4paper'). # # 'papersize': 'letterpaper', # The font size ('10pt', '11pt' or '12pt'). # # 'pointsize': '10pt', # Additional stuff for the LaTeX preamble. # # 'preamble': '', # Latex figure (float) alignment # # 'figure_align': 'htbp',&#125;# Grouping the document tree into LaTeX files. List of tuples# (source start file, target name, title,# author, documentclass [howto, manual, or own class]).latex_documents = [ (master_doc, 'NJUPT-API.tex', 'NJUPT-API Documentation', 'gaoliang', 'manual'),]# -- Options for manual page output ------------------------------------------# One entry per manual page. List of tuples# (source start file, name, description, authors, manual section).man_pages = [ (master_doc, 'njupt-api', 'NJUPT-API Documentation', [author], 1)]# -- Options for Texinfo output ----------------------------------------------# Grouping the document tree into Texinfo files. List of tuples# (source start file, target name, title, author,# dir menu entry, description, category)texinfo_documents = [ (master_doc, 'NJUPT-API', 'NJUPT-API Documentation', author, 'NJUPT-API', 'One line description of project.', 'Miscellaneous'),]# -- Extension configuration ------------------------------------------------- python代码docstring生成文档之sphinx Python 验证码识别 通过pytesseracthttps://blog.csdn.net/weixin_42812527/article/details/81264189 windows10安装使用pytesseract坑：https://blog.csdn.net/weixin_42812527/article/details/81908674 123456789101112131415161718192021222324# coding=utf-8import requestsimport pytesseractfrom PIL import Imagefrom io import BytesIOcaptcha_url = 'http://182.92.169.64:8088/808gps/rand.action'captcha_content = requests.get(url=captcha_url)# 获得图片的二进制内容captcha_content = captcha_content.content# 用BytesIO读取图片image = Image.open(BytesIO(captcha_content))# 转化为灰度图imgry = image.convert('L')# 二值化处理table = [0 if i &lt; 140 else 1 for i in range(256)]# 使字体更加突出的显示out = imgry.point(table,'1')# out.show()captcha = pytesseract.image_to_string(out)captcha = captcha.strip()captcha = captcha.upper()print (captcha) Python异常 Python所有的错误都是从BaseException类派生的，常见的错误类型和继承关系 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StandardError | +-- BufferError | +-- ArithmeticError | | +-- FloatingPointError | | +-- OverflowError | | +-- ZeroDivisionError | +-- AssertionError | +-- AttributeError | +-- EnvironmentError | | +-- IOError | | +-- OSError | | +-- WindowsError (Windows) | | +-- VMSError (VMS) | +-- EOFError | +-- ImportError | +-- LookupError | | +-- IndexError | | +-- KeyError | +-- MemoryError | +-- NameError | | +-- UnboundLocalError | +-- ReferenceError | +-- RuntimeError | | +-- NotImplementedError | +-- SyntaxError | | +-- IndentationError | | +-- TabError | +-- SystemError | +-- TypeError | +-- ValueError | +-- UnicodeError | +-- UnicodeDecodeError | +-- UnicodeEncodeError | +-- UnicodeTranslateError +-- Warning +-- DeprecationWarning +-- PendingDeprecationWarning +-- RuntimeWarning +-- SyntaxWarning +-- UserWarning +-- FutureWarning +-- ImportWarning +-- UnicodeWarning +-- BytesWarning java异常 继承、Super super() 函数是用于调用父类(超类)的一个方法，只有在新式类中可以使用 super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO，Method Resolution Order，采用广度优先（区别于深度优先）的规则定义）、重复调用（钻石继承）等种种问题。 MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。 语法 以下是 super() 方法的语法: 1234# 菜鸟教程super(type [, object-or-type])# 个人理解super( ThisClass [, object(self)]) 参数 type – 类（type），通常是当前子类。 object-or-type – 类实例，一般是 self 含义 用self这个实例对象去查找ThisClass类的父类拥有的属性（成员方法、数据成员） ▲. Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx : 即平时写的 1234567class TestClass(object): def __init__(self, *arg, **kwarg): super(TestClass, self).__init__() # 此时init里不用self # 等价于 super().__init__() , 含义是用父类的构造函数初始化某些变量 # 相当于旧式类的 object.__init__(self) # 需要传参self self.arg = arg self.kwarg = kwarg 完整代码 12345678910111213141516class clsSuper(object): age = 18 def __init__(self, name): print(name)class clsSub(clsSuper): def __init__(self): print(super().age) # 当只是单继承的时候可以直接使用 print(clsSuper.age)，if __name__ == '__main__': a = clsSuper('cl') b = clsSub() 特点 super().func()是不用传参self的 super(type, obj).func()函数调用的是obj实例在MRO中下一个父类的可调用func()，而不是type的父类中的func()。即调用最近的可用func() 使用super()不用指定父类的名称，便于修改维护；同时当继承多个类A、B的时候，用super().__init__()相当于调用多个类的A.__ini__(self)、B.__ini__(self) 与java对比 Python中子类不会默认调用父类的构造函数，即下面代码。并不会要要求给传name。当然也可以理解为跟java一样调用了一个全空、没有任何内容的构造函数，但是在python中不需要显性写出来，原因部分是特点2（java中存在有参数的构造函数时，必须将空参数的构造函数显式写出，不然子类默认隐式调用空参数的构造函数时会报错说不存在）。 Python中的构造函数只有一个。但由于存在*arg,**kwarg的存在，所以只要执行类型检查执行不同的代码；即实现了多个构造函数 Python的类可以多继承，java只能单继承。 123456789101112131415class clsSuper(object): age = 18 def __init__(self, name): self.name = name print(self.name)class clsSub(clsSuper): def __init__(self, age): print(age)if __name__ == '__main__': b = clsSub(18) Cmder Windows 下的终端神器 视频字幕制作 arctime国人自制的免费软件。自动打轴和语音识别功能积分使用注册绑定任务、签到白嫖能鸽很久。 制作完成后保存工程文件，ass，软件-&gt;导出，可以导出一份srt字母文件，可以直接上传到B站当CC字幕使用 Pr自带工具一句一句打===&gt;ps批量制作字幕图层===&gt;arctime mitmProxy手机抓包软件 Q:为什么好多加密算法都要用到异或？ A:位操作 cpu运行非常快 加密的源是形形色色的，其加密结果也要求是尽量差异化。在二元的位运算符中，也就只有&quot;位与&quot;、“位或”、&quot;异或&quot;三种。一个加密过程往往需要经过若干次运算，若采用&quot;位与&quot;运算，竟多次计算的话，其结果值将趋向于比特位全部是0；同样，采用&quot;位或&quot;的话，其结果值将趋向于比特位全部是1。剩下的只有采用&quot;异或&quot;运算了 测试注解的正确性 注解仅仅起到了注释的作用，不会影响代码的执行，所以即使你类型注解写错了，程序运行的时候还是会按照正确的类型去运行。 Python提供了一个工具方便我们测试代码里的类型注解正确性mypy 首先安装：pip install mypy 使用测试：mypy filename.py Python3.7新特性dataclass 写法对比 1234567891011121314class student(object): \"\"\"docstring for student\"\"\" def __init__(self, name, age): super(student, self).__init__() self.name = name self.age = agefrom dataclasses import dataclass@dataclassclass student(object): \"\"\"docstring for ClassName\"\"\" name: str age: int 功能对比 传统的class写法的__eq__并不认为两个实例相同，即存储数据不同 12345678910111213141516171819202122232425262728293031class student(object): \"\"\"docstring for student\"\"\" def __init__(self, name, age): super(student, self).__init__() self.name = name self.age = age s1 = student('cl', 18)s2 = student('cl', 18)print(s1 == s2)# &gt;&gt;&gt; False#数据的角度来讲，这两个实例代表的是同一个Student，理应相等。所以我们可以重写内置的__eq__方法如下class student(object): \"\"\"docstring for student\"\"\" def __init__(self, name, age): super(student, self).__init__() self.name = name self.age = age def __eq__(self, other): if self.__class__ is not other.__class__: return False return (self.name, self.age) == (other.name, other.age)s1 = student('cl', 18)s2 = student('cl', 18)print(s1 == s2)# &gt;&gt;&gt; True 注意: name和age并不是Class Attribute，也就是不能通过NewStudent.name和NewStudent.age直接访问，大家可以通过dir(NewStudent)验证一下。 name和age后面的类型指定并没有实际的效果，也就是如果我们实例化传入错误的数据类型，不会报错，比如 s3 = NewStudent(‘Mark’, ‘20’) 更多功能 通过使用装饰器的选项，可以为用例进一步定制 data class，默认选项是： 1@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False) init决定是否生成__init__ dunder 方法 repr决定是否生成__repr__ dunder方法 eq对__eq__ dunder 方法也是如此，它决定相等性检查的行为（your_class_instance == another_instance） order 实际上创建了四种 dunder 方法，它们确定所有检查小于，and/or，大于的行为，如果将其设置为 true，则可以对对象列表进行排序。 最后两个选项确定对象是否可以被哈希化，如果你想使用你的 class 的对象作为字典键的话，这是必要的。 链接：https://www.jianshu.com/p/bea5c202cf85 协程 不是进程，也不是线程，是用户空间调度的完成并发处理的方式。是在用户空间内部完成的。线程和进程是操作系统内完成的。 Github感谢贡献者 1&lt;a href=\"https://github.com/spencerwooo/dowww/graphs/contributors\"&gt;&lt;img src=\"https://opencollective.com/dowww/contributors.svg?button=false\" /&gt;&lt;/a&gt; java equals 和 == == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型比较的是值，引用数据类型比较的是内存地址)。 equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。 即通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。 一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 说明： String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址(即==)，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 hashCode（）介绍 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode 我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 通过我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。**hashCode()在散列表中才有用，在其它情况下没用。**在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。 hashCode（）与equals（）的相关规定 如果两个对象相等，则hashcode一定也是相同的 两个对象相等,对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）==&gt;通过统一哈希值，使两个对象equals时结果返回哈希值一致便输出true static{}静态代码块与{}非静态代码块、构造方法 类的执行顺序: static{}静态代码块–&gt;{}静态代码块–&gt;构造方法 static{}静态代码块与{}非静态代码块不同点： 静态代码块只在第一次new执行一次，之后不再执行 一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。 而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法 两者的区别是 静态代码块是自动执行的而静态方法是被调用才执行的. 非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 1234567891011121314151617181920212223242526272829303132package classtest;public class testClass &#123; public testClass() &#123; System.out.print(\"默认构造方法！--\"); &#125; //非静态代码块 &#123; System.out.print(\"非静态代码块！--\"); &#125; // 静态代码块,指挥执行一次 static &#123; System.out.print(\"静态代码块！--\"); &#125; public static void test() &#123; System.out.print(\"静态方法中的内容! --\"); &#123; System.out.print(\"静态方法中的代码块！--\"); &#125; &#125; public static void main(String[] args) &#123; testClass test = new testClass(); testClass.test();//静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！-- System.out.println(); testClass test2 = new testClass(); &#125;&#125;/**静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！--非静态代码块！--默认构造方法！--*/ Ansible 运维自动化 ( 配置管理工具 )","categories":[],"tags":[{"name":"编程日记","slug":"编程日记","permalink":"https://nymrli.top/tags/编程日记/"}]},{"title":"Python爬虫常规流程","slug":"Python爬虫常规流程","date":"2019-08-30T13:07:05.000Z","updated":"2019-09-15T08:07:30.988Z","comments":true,"path":"2019/08/30/Python爬虫常规流程/","link":"","permalink":"https://nymrli.top/2019/08/30/Python爬虫常规流程/","excerpt":"","text":"Python爬虫常规流程 以爬取有道翻译为例子。 挖取可自用的API web 端的有道翻译，在之前是直接可以爬的。也就是说只要获取到了他的接口，你就可以肆无忌惮的使用他的接口进行翻译而不需要支付任何费用。那么自从有道翻译推出他的API服务的时候，就对这个接口做一个反爬虫机制（如果大家都能免费使用到他的翻译接口，那他的APl服务怎么赚钱）。这个反爬虫机制在爬虫领域算是一个非常经典的技术手段。 1.查看要爬取的内容是否是静态加载的。 比如在翻译输入框中输入apple，翻译输出框中会出现苹果，然后在``页面中右键-&gt;查看网页源代码，直接Ctrl+F搜索是否存在apple或者苹果`，如果没有的话，证明不是静态加载的。 2.查看内容如何加载的 页面初始化get、post请求 局部刷新发送ajax请求 如果存在局部更新内容产生变化的（Url没有发生变化，或者没有页面发生跳转、刷新的感觉），一般都是采用的AJAX更新技术，发送了POST、GET请求获得局部需要更新的数据，可以直接在Network项的XHR里面找到动态加载的文件 (可以看下Ajax技术实现了解下为什么可以在XHR中找到) 这边的话，可以看到输入一个要翻译的内容后，页面没有产生多大的变化，因此猜想是AJAX加载的。在XHR里也找到了相应的Response文件。 使用Chrome自带的抓包工具（页面中右键-&gt;检查或者按F12都可以打开，然后选择-&gt;Network项（网络监听窗口）就可以看到抓包的数据了） 然后同样在翻译输入框中输入apple，然后可以观察到抓包工具中出现了很多内容。为了确定apple的翻译苹果是在哪个文件中返回的，可以直接Ctrl+F打开搜索框后直接搜索，如图所示。 JS加密破解 1.使用Python进行模仿JS加密计算 2.运行JS代码获得加密结果 使用python-js2py模块 如一个参数生成的结果是这样的{&quot;LoginKey&quot;:&quot;46fd82c2-3108-b2a4-3056-0eaa426f975b&quot;,&quot;data&quot;:&quot;{/&quot;User_Oid/&quot;:/&quot;账号/&quot;,/&quot;User_Password/&quot;:/&quot;密码/&quot;}&quot;} 找到生成LoginKey值的JS文件加密算法是这样的： 123456function s4() &#123;return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);&#125;;function guid() &#123;return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();&#125; 然后安装pip install js2py后 123456789101112#coding=utf-8import js2pyLoginKey = js2py.eval_js('''function s4() &#123;return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);&#125;;function guid() &#123;return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();&#125;var a = guid() // 在这里是需要调用的''')print LoginKey 就能获得结果了。 使用pyexe、PyV8、js2py模块 12345678910111213141516171819import execjsdef get_des_psswd(data, key): jsstr = get_js() ctx = execjs.compile(jsstr) #加载JS文件 return (ctx.call('strEnc', data, key)) #调用js方法 第一个参数是JS的方法名，后面的data和key是js方法的参数def get_js(): f = open(\"./../lib/des.js\", 'r', encoding='utf-8') # 打开JS文件 line = f.readline() htmlstr = '' while line: htmlstr = htmlstr+line line = f.readline() return htmlstrif __name__ == '__main__': print(get_des_psswd('123456', 'RUY2OTdCRUFFRTg0OUQ0Q0E0ODNDRDMxN0YzOEEzREQudG9tY2F0OTQ=')) js2py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import js2pycontext = js2py.EvalJs()# - 拷贝使用到js文件的内容到本项目中# - 读取js文件的内容,使用context来执行它们with open(\"BigInt.js\", 'r', encoding='utf8') as f: context.execute(f.read()) with open(\"RSA.js\", 'r', encoding='utf8') as f: context.execute(f.read())with open(\"Barrett.js\", 'r', encoding='utf8') as f: context.execute(f.read())# - 向context环境中添加需要数据context.t = &#123;'password': password&#125;context.n = n# - 执行加密密码的js字符js = ''' t.password = t.password.split(\"\").reverse().join(\"\"), setMaxDigits(130); var o = new RSAKeyPair(n.e,\"\",n.n) , r = encryptedString(o, t.password); '''context.execute(js)# - 通过context获取加密后密码信息# print(context.r)password = context.r# - 使用session发送登录请求# - URL: http://activity.renren.com/livecell/ajax/clog# - 请求方法: POST# - 数据:# - phoneNum: 15565280933# - password: (加密后生产的)# - c1: 0# - rKey: rkey请求获取的data = &#123; 'phoneNum': '131....', 'password': password, 'c1':0, 'rKey':n['rkey']&#125; # print(session.headers)response = session.post(\"http://activity.renren.com/livecell/ajax/clog\", data=data)print(response.content.decode()) # 访问登录的资源response = session.get(\"http://activity.renren.com/home#profile\")print(response.content.decode())# https://blog.csdn.net/guodejie/article/details/81436556 逐步确定JS对密码的加密逻辑 ==&gt; 定位到加密函数 两种思路 全局搜索password字段 全局搜加密算法的名字 加密一般都是JS加密，加密算法一般比较出名的就那么几个，比如MD5，base64,aes（对称密码），rsa（非对称加密算法）都是可以用来加密的，你可以全局搜这些加密算法的名字 https://www.jianshu.com/p/055e1ddf7bb2 rsa加密 对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破==&gt;为什么密码要大于6位。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Word2016配置使用MathType","slug":"Word2016配置使用MathType","date":"2019-08-30T12:58:53.000Z","updated":"2020-03-26T06:13:48.023Z","comments":true,"path":"2019/08/30/Word2016配置使用MathType/","link":"","permalink":"https://nymrli.top/2019/08/30/Word2016配置使用MathType/","excerpt":"","text":"Word 2016 使用MathType 据说MathType 6.9b后就能与Word 2016兼容了，所以不用特地去找7.0以上的版本，据说更新的功能差别也不是很大。只不过本人还是使用的7+版本，新一点功能会更全点嘛。 闲谈 这边的方法是我个人的操作过程，但是感觉应该不是这么搞得。 安装好MathType后，打开word查看工具栏中是否有MathType工具，如果没有的话，则手动选择“插入-&gt;获得加载项-&gt;应用商店”搜索Mathtype。如果还是没有的话，然后在“选项-&gt;加载项-&gt;模板”然后指定MathType Commands 6 For Word2016.dotm的路径，之后是能在应用商城搜到Mathtype了，但是每次打开word都会弹出找不到MathPage.wll，而且最麻烦的是还删不掉这个路径，于是找了很多资料后，发现了“信任中心”，比较像能解决问题。只不过试了后还是不行，最后发现，自己拷贝的是64位的文件，找到了一个解决方案提醒到：如果你复制的是64的MathPage.wll还出错换成32的就好了。然后按照提示改了后就行了，同时需要注意的是根据路径显示需要将Mathtype安装目录中的和MathPage.wll 安装过程 需要将安装好的mathtype目录下提取两个文件MathPage.wll和MathType Commands 6 For Word 2016.dotm复制到指定目录 如果使用的Office是32位的话。在Mathtype安装后，安装路径（假设装在C盘的话）C:\\Program Files (x86)\\MathType\\MathPage\\32中有文件MathPage.wll； 安装路径C:\\Program Files (x86)\\MathType\\Office Support\\32中有文件 MathType Commands 6 For Word.dotm；将这两个文件复制到桌面。 （当然，这里都是针对Windows 64位系统而言的，注windows10是64位操作系统。如果是Windows 32位系统，路径中就不会包含有（x86）了，请注意。） 如果使用的Office是64位的话。在Mathtype安装后，安装路径（假设装在C盘的话）C:\\Program Files (x86)\\MathType\\MathPage\\64中有文件MathPage.wll； 安装路径C:\\Program Files (x86)\\MathType\\Office Support\\64中有文件 MathType Commands 6 For Word 2016.dotm；将这两个文件复制到桌面。 **如果不清楚自己的Office是32位还是64位，就按照32位的来，一般来说，向下兼容，实在不行就都试一试。▲.===&gt;我就是以为自己的是64位结果是32位被坑了很久都用不成。 或者像如下查看自己的word版本，打开word点击“账号” 选择“关于word” 对于自己安装Office 2016的用户，需要找到Office 2016的安装文件夹（假设装在C盘的话）C:\\Program Files\\Microsoft Office\\Office16\\STARTUP（对于****64位的Office用户）；或C:\\Program Files (x86)\\Microsoft Office\\Office16\\STARTUP（对于****32位的Office用户）。然后，直接将桌面上的那两个文件剪切放进去即可，重新启动Word后就会出现Mathtype插件栏。 对于Office预装的用户，想找到Office的安装路径就不那么容易了，这个时候就只能发挥一下Windows自身的搜索功能（安利Everythisng搜索）了，从前面提到的可以看出Mathtype安装文件中有两个文件需要手动移植到Office安装路劲下的一个STARTUP文件夹中，因此需要找到这个STARTUP文件夹。 在搜索框中输入STARTUP。 找到最后为**~Microsoft\\Word\\STARTUP**的文件夹子目录，可能会有多个。逐次添加桌面上的两个文件【如下图】到这些文件夹中，并重新启动Word进行查证。 需要复制的文件 复制到的位置 1.STARTUP目录，如果没有的话自己新建C:\\Users\\10630\\AppData\\Local\\Packages\\Microsoft.LanguageExperiencePackzh-cn_8wekyb3d8bbwe\\LocalCache\\Roaming\\Microsoft\\Word\\STARTUP 2.这个路径我忘记了，但是搜索的时候发现自己复制了C:\\Users\\10630\\AppData\\Roaming\\Microsoft\\AddIns 注意事项：如果在C:\\Program Files\\Microsoft Office\\Office16\\STARTUP中，含有MathType Commands 6 For Word.dot，那么就会出现无法粘贴的现象。（复制的话，word会关闭） 😄总算安好了把，配合Mathpix，感觉应该挺香的. 兼容模式问题 当拿到低版本打开后出现一些格式或者兼容性不对的提示，其实很简单，我们可以在保存时候，就可以设置为兼容性模式。 如何关闭&quot;兼容模式&quot; 当自己使用的Word版本较高，打开doc的版本较低时(.doc)，就会进入**“兼容模式”**，这样能保证大致上的排版格式是正确的，但是图片、公式什么的信息很有可能就会丢失（公式变成了图片、图片显示不全），解决的方案是关闭兼容模式。 兼容模式，如图 解决步骤1： 解决步骤2： 如何保存为&quot;兼容模式&quot;？ 实质上就是保存为.doc–&gt;.docx的变化","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"算法设计与分析C_概念点区分","slug":"算法设计与分析C-概念点区分","date":"2019-08-22T12:39:29.000Z","updated":"2019-09-15T08:07:31.090Z","comments":true,"path":"2019/08/22/算法设计与分析C-概念点区分/","link":"","permalink":"https://nymrli.top/2019/08/22/算法设计与分析C-概念点区分/","excerpt":"","text":"算法设计与分析C 算法5_分治法 分治法——将一个复杂的问题分解成若干个规模较小、相互独立，但类型相同的子问题求解；然后再将各子问题的解组合成原始问题的一个完整答案，这样的问题求解策略就叫分治法。 分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定的程度就可以容易地解决； 该问题可以分解为若干个规模较小的相同问题； 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。 由分治法产生的子问题往往是原问题的较小模式。 直接或间接地调用自身的算法称为：递归算法。用函数自身给出定义的函数称为：递归函数。 分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。 算法6_贪心法 可行解 ——问题给定某些约束条件，满足约束条件的问题解，即称为可行解。 最优解 ——问题给出目标函数衡量可行解的好坏，使目标函数取最大（或最小）值的可行解称为最优解。 1.最优子结构性质： 一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。 问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。 2.贪心选择性质 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。 这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。 算法7_动态规划法 （1）子问题重叠性质 （递归算法求解问题时）每次产生的子问题并不总是新问题，有些子问题被反复计算多次，这种性质称为子问题重叠性质。 动态规划算法对每一个子问题只解一次，而后将其解保存在一个表格（通常用二维数组）中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。 通常不同的子问题个数随问题的大小呈多项式增长。因此用动态规划算法只需要多项式级时间，从而获得较高的解题效率。 （2）最优子结构性质——用动态规划法求解的前提。 当一个问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。 一个问题的活动过程可以分为若干个阶段，每个阶段可包含一个或多个状态，从初始阶段的初始状态出发做出每个阶段的决策，形成一个决策序列。 利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。 用动态规划算法求解问题的步骤： 1、找出最优解的性质，并刻划其结构特征； 2、递归地定义最优解值； 3、自底向上求最优解值； 4、根据计算最优解值时得到的信息构造一个最优解（此步只在要求得到最优解时才需要做） 。 动态规划法是一种求解最优化问题的重要算法策略。 利用最优子结构性质及所获得的递推关系式（较小子问题最优解与较大子问题最优解之间存在的数值关系）去求取最优解，可以使计算量较之穷举法急剧减少。 共同点： 将待求解的问题分解成若干子问题，先求解子问题，然后再从这些子问题的解得到原问题的解。 不同点： 1、适合于用动态规划法求解的问题，分解得到的各子问题往往不是相互独立的；而分治法中子问题相互独立。 2、动态规划法用表保存已求解过的子问题的解，再次碰到同样的子问题时不必重新求解，而只需查询答案，故可获得多项式级时间复杂度，效率较高；而分治法中对于每次出现的子问题均求解，导致同样的子问题被反复求解，故产生指数增长的时间复杂度，效率较低。 备忘录方法与动态规划法比较 1、与动态规划法的共同点：用一个表格来保存已求解的子问题的答案，使下次需要解此子问题时，只简单地查看答案，不重新计算。 2、与动态规划法的区别：备忘录的递归方式是自顶向下，而动态规划法的递归方式是自底向上。 如何选择使用动态规划法或备忘录法？ ★当一个问题的所有子问题都至少要解一次时，选用动态规划法较好，此时没有任何多余的计算，还可利用规则的表格存取方式，减少时间和空间需求。 ★当一个问题只有部分子问题需要求解时，选用备忘录法较好，它只解那些确实需要求解的子问题。 备忘录方法与递归方法比较 1、与递归方法的共同点：递归方式均为自顶向下 2、与递归方法的区别：备忘录方法用一个表格来保存已求解的子问题的答案，使下次需要解此子问题时，只简单地查看答案，不重新计算；而递归方法在每次遇到子问题都要重新计算。 共同点： 都是求解最优化问题；都具有最优子结构性质。 不同点： 1、求解方式不同： 动态规划法：自底向上； 贪心法：自顶向下。以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为一个规模更小的子问题。 2、对子问题的依赖不同： 动态规划法：依赖于各子问题的解。只有在解出相关子问题后,才能作出选择；应使各子问题最优，才能保证整体最优； 贪心法：不依赖于子问题的解。仅在当前状态下作出最好选择，即局部最优选择。 算法8_回溯法 回溯法是比贪心法和动态规划法更一般的方法。 解为n-元组(x0,x1,…,xn-1)形式。 通过搜索状态空间树来求问题的可行解（满足约束条件）或最优解（使目标函数取最大或最小值）。 使用约束函数和限界函数来压缩需要实际生成的状态空间树的结点数。 通常情况下，回溯法是为了找出满足约束条件的所有可行解。 显式约束：规定每个xi取值的约束条件。 （显式约束规定了问题的候选解集——解空间） 隐式约束：给出了判定一个候选解是否为可行解的条件。为满足问题的解而对不同分量之间施加的约束。 目标函数（代价函数）：衡量每个可行解的优劣，使目标函数取最大（或最小）值的可行解为问题的最优解。 状态空间树：描述问题解空间的树形结构。 树中每个结点称为一个问题状态； 若从根到树中某个状态的路径代表一个候选解元组，则该状态为解状态； 若从根到某个解状态的路径代表一个可行解元组，则该解状态为答案状态； 如果求解的是最优化问题，还要用目标函数衡量每个答案结点，找出其中目标函数取最优值的最优答案结点。 回溯法与穷举搜索不同：回溯法使用约束函数，剪去那些可以断定不含答案状态的子树，从而提高算法效率。回溯法适用于解一些组合数相当大的问题。 事实上，状态空间树并不需要事先生成，而只需在求解的过程中，随着搜索算法的进展，逐个生成状态空间树的问题状态结点。 常用的剪枝函数： 用约束函数剪去已知不含答案状态（可行解）的子树； 用限界函数剪去得不到最优答案结点（最优解）的子树。 蒙特卡洛估计 用蒙特卡罗（Monte Carlo）方法估计回溯法处理实例时，实际生成的结点数： 在状态空间树中,从根开始随机选择一条路径(x0,x1,…,xn-1); 假定搜索树中这条随机选出的路径上，代表部分向量(x0,x1,…,xk-1)的结点X处不受限制的孩子数目,和其他路径上与X同层的的结点不受限制的孩子数目一样，都是mk; 则可以估计整个状态空间树上实际生成的结点数为: m=1+m0+m0m1+m0m1m2+...... 算法9_分枝限界法 采用广度优先产生状态空间树的结点，并使用剪枝函数的方法称为——分枝限界法。 分枝限界法的基本做法是： 以广度优先的方式搜索问题的状态空间树。每一个活结点只有一次机会成为扩展结点。 按照广度优先的原则，活结点一旦成为扩展结点（E结点）R后，就依次生成它的所有孩子结点。在这些孩子结点中，导致不可行解或导致非最优解的孩子结点被舍弃，其余孩子结点被一一加入活结点表中。 此后，R自身成为死结点，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。 这个过程一直持续到找到所需的解或活结点表为空时为止。 一、分枝限界法与回溯法的共同点 都是在问题的状态空间树上搜索问题解的算法,都通过活结点表实现。都用约束函数剪去不含答案结点的分枝,用限界函数剪去不含最优解的分枝. 二、分枝限界法与回溯法的区别 （1）求解目标不同：回溯法的求解目标是找出解空间树中满足约束条件的所有可行解；而分枝限界法的求解目标则是找出满足约束条件的一个可行解，或某种意义下的最优解。 （2）搜索方式不同：回溯法以深度优先的方式搜索解空间树，而分枝限界法则以广度优先的方式搜索解空间树。 （3）对当前扩展结点的扩展方式不同：回溯法中的每个活结点可能多次成为当前扩展结点，纵深方向扩展其一个儿子，然后再回溯后扩展其他儿子；而分枝限界法中每一个活结点只有一次机会成为扩展结点，一次产生所有孩子结点，自身成为死结点，之后无需再返回该结点处。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"},{"name":"学业","slug":"学业","permalink":"https://nymrli.top/tags/学业/"}]},{"title":"通信企业管理_线上考试","slug":"通信企业管理-线上考试","date":"2019-08-22T12:37:49.000Z","updated":"2019-09-15T08:07:31.097Z","comments":true,"path":"2019/08/22/通信企业管理-线上考试/","link":"","permalink":"https://nymrli.top/2019/08/22/通信企业管理-线上考试/","excerpt":"","text":"通信企业管理 看清题目和选项 单选题 1单选(2分) 在总公司领导下设立多个分支，各分支有各自独立的产品和市场，实行独立核算，经营管理上拥有自主性和独立性。这是（ A ）组织结构。 A.事业部型 B.矩阵型 C.职能型 D.直线型 2单选(2分) 按照最新版《中华人民共和国公司法》规定，股份有限公司的发起人最多不超过（ C ）。 A.100人 B.50人 C.200人 D.150人 3单选(2分) 工作或行动之前预先拟定具体的工作内容和步骤是管理的（ D ）职能。 A.组织职能 B.控制职能 C.领导职能 D.计划职能 4单选(2分) 提出“14项管理原则”的是（C ）。 A.巴纳德 B.梅奥 C.法约尔 D.泰勒 5单选(2分) 企业战略是关于企业在激烈的竞争中如何与竞争对手相抗衡、同时也是针对来自多方面的冲击、压力、威胁和困难迎击这些挑战的行动方案。这体现了企业战略的（ D ）。 A.长远性 B.协同性 C.全局性 D.抗争性 6单选(2分) 在对企业总体环境分析中，人们生活方式的变化属于（ B ）。 A.经济环境 B.社会环境 C.政治环境 D.技术环境 7单选(2分) 为了增强企业实力而与同行业企业进行联合的一种战略称为（ C ）。 A.复合多样化 B.纵向一体化 C.横向一体化 D.同心多样化 8单选(2分) 在流程型生产过程中，物料是均匀、连续地按一定工艺顺序运动的。它的特点是工艺过程的（ A ）。 A.连续性 B.稳定性 C.离散性 D.流动性 9单选(2分) 服务是一种活动，在消费之前通常无法为顾客感觉、体验和评价，这体现了服务的（ B ）。 A.劳动力密集性 B.无形性 C.异质性 D.易逝性 10单选(2分) 尽管不同产品具有不同的外部质量特征，但可以用（ B ）来概括产品质量。 A.安全性 B.适用性 C.经济性 D.可靠性 11单选(2分) 质量管理经历的第四阶段是（ C ）。 A.统计质量控制阶段 B.质量检验阶段 C. ISO9000质量管理体系认证阶段 D.全面质量管理阶段 12单选(2分) 下面（ A ）不是朱兰三部曲中所要求的内容。 A.质量检验 B.质量计划 C.质量提高 D.质量控制 13单选(2分) 职业生涯规划属于 人力资源管理的（ C ）方面的内容。 A.用人 B.进人 C.育人 D.留人 14单选(2分) 一般来说，我们可以从工作业绩、工作能力和工作态度3个方面来评价员工的绩效体现了绩效的（ C ）特征。 A.动态性 B.多因性 C.多维性 D.稳定性 15单选(2分) 薪酬中属于间接经济性报酬的是（ D ）。 A.津贴 B.基本工资 C.奖金 D.基本社会保险 16单选(2分) 企业财务管理的基本内容包括：①资金筹集管理；②成本费用管理；③投资管理；④利润（收支差额）及其分配管理；⑤物资管理；中的（ A ）。 A.①②③④ B.①③④⑤ C.①②④⑤ D.①②③④⑤ 17单选(2分) 以下不属于企业的筹资方式的是（ D ）。 A.买方信贷 B.发行股票 C.银行贷款 D.来自个人的闲散资金 18单选(2分) 某大学生在4年学习期间，每年年初从银行贷款3000元用于支付学费，若按年利率5%计复利，第4年末需要一次性归还全部本息（ D ）元。 A.12000 B.12930.4 C.16576.9 D.13576.9 19单选(2分) 为了保证产品达到规定的功能和技术要求所必需的材料消耗是（A ）。 A.有效性消耗 B.工艺性消耗 C.非工艺性消耗 D.材料消耗 20单选(2分) 设备在使用或闲置过程中，由于新技术出现而引起的设备价值损失，称为（ A ）。 A.无形磨损 B.价值磨损 C.技术磨损 D.使用磨损 21单选(2分) 企业在相邻两批物资进厂间隔期内，为保证生产正常进行所必需的、经济合理的储备数量是（ D ）。 A.保险储备定额 B.物资储备定额 C.季节性储备定额 D.经常储备定额 22单选(2分) 快速渗透策略是推广处于生命周期（C ）产品的企业，可以采用的市场营销策略。 A.衰退期 B.成长期 C.引入期 D.成熟期 23单选(2分) 以下不属于促销组合中的促销工具的是（ D ）。 A.销售促进 B.公关宣传 C.广告 D.尾数定价 24单选(2分) 营销人员可以通过接近和影响消费者群体中的意见领袖的方式来开展营销活动，这体现了影响消费者购买的主要因素中的（ D ）的作用。 A.经济因素 B.个人因素 C.社会文化因素 D.心理因素 25单选(2分) 品种繁多，每种仅生产一件，生产重复程度低是以下哪种生产方式的特点（ B ）。 A.批量生产 B.单件生产 C.大量生产 D.备货型生产 判断题 26判断(2分) 个体企业是个人出资兴办的企业，具有法人资格。 错 27判断(2分) 在管理过程中，只有把人的要素作为根本，才能协调好其他要素，实现高水平的管理。 对 28判断(2分) 企业不仅是经济性组织，也是社会性组织。 对 29判断(2分) 梅奥认为，影响人们积极性的因素除了物质方面外，还有社会与心理方面。 对 30判断(2分) 企业提供的产品服务标新立异，满足顾客特殊的需求，形成竞争优势的战略是差异化战略。 对 31判断(2分) 高质量的社会物流系统属于战略制定中企业的外部资源。 对 32判断(2分) 企业价值活动中，技术开发属于基本活动。 错 33判断(2分) 企业生产系统是由输入、转化、输出、反馈四部分构成，其核心是输出。 错 34判断(2分) 辅助生产部门主要是为基本生产和辅助生产服务的单位（如仓储、后勤）。 错 35判断(2分) 对于顾客来说，服务是发生在服务设施环境中的经历，如果服务设施的设计符合消费者的需要，就可以提高服务质量。 对 36判断(2分) ISO9000族标准是进行国际贸易时强制要求必须进行的标准认证。 错 37判断(2分) 质量体系认证中使用的基本标准是产品技术标准。 错 38判断(2分) 质量管理的目标就是提高产品质量，产品质量越高越好。 错 39判断(2分) 广义的人力资源概念是指能够推动国民经济和社会发展的具有智力劳动和体力劳动能力的人的总和，包括数量和质量两个方面。 错 40判断(2分) 工作说明书具体说明了工作的目的与任务、工作内容与特征、工作责任与权力、工作标准与要求、工作时间与地点等问题。 错 41判断(2分) 设定绩效目标时，管理者一般根据组织总体目标或上级部门的目标，围绕本部门业务重点或职责，制定本部门的工作目标计划，保证部门工作目标与组织的总体目标相一致。 对 42判断(2分) 企业的运营能力反映了企业资金周转状况，可以用成本费用净利率来衡量。 错 43判断(2分) 资本公积、盈余公积都属于企业权益资本的范畴。 对 44判断(2分) 盈亏平衡点是指技术方案的盈利和亏损在产量、单价、成本等方面的临界值。 对 45判断(2分) 在设备的自然寿命周期中，设备故障率随着使用的时间的延伸而越来越高。 对 46判断(2分) 设备更新改造时，不仅要考虑设备的自然寿命，还要考察技术寿命和经济寿命。 对 47判断(2分) 从价值形态上看，无论是有形磨损还是无形磨损都会引起设备价值的降低，因此我们要采取措施尽量减少各种类型的设备磨损。 错 48判断(2分) 关系营销就是利用亲属关系以及朋友关系来开展营销活动。 错 49判断(2分) 在目标市场中采用无差异的市场营销策略历来都不是一种明智的选择。 错 50判断(2分) 招徕定价是一种利用顾客心理因素来进行定价的策略。 对 附： 记个正则替换，本是强哥每题copy到word里的，后来通过正则规范了下格式 复制结果： /1. int[][] a=new int[2][3]，则该数组包含（ ）个数组元素。 A.2 B.3 C.6 D.不确定 正确答案是: C /2. 已知类person是类student的父类，以下数组定义和赋值正确的是( )。 A.person p[]=new person[3]; p[1]=new student(); B.student s[]=new person[3]; s[1]=new person(); C.person p[]= new student[3];p[1]= new person(); D.student s[]=new student[3];s[1]=new person; 正确答案是: A 查找(/d.)替换为/n - /1 效果如下: int[][] a=new int[2][3]，则该数组包含（ ）个数组元素。 A.2 B.3 C.6 D.不确定 正确答案是: C 已知类person是类student的父类，以下数组定义和赋值正确的是( )。 A.person p[]=new person[3]; p[1]=new student(); B.student s[]=new person[3]; s[1]=new person(); C.person p[]= new student[3];p[1]= new person(); D.student s[]=new student[3];s[1]=new person; 正确答案是: A","categories":[],"tags":[{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"},{"name":"学业","slug":"学业","permalink":"https://nymrli.top/tags/学业/"}]},{"title":"Let's Encrypt安装配置nginx的SSL证书教程","slug":"Let-s-Encrypt安装配置SSL证书教程","date":"2019-08-22T12:34:04.000Z","updated":"2019-09-15T08:07:30.956Z","comments":true,"path":"2019/08/22/Let-s-Encrypt安装配置SSL证书教程/","link":"","permalink":"https://nymrli.top/2019/08/22/Let-s-Encrypt安装配置SSL证书教程/","excerpt":"","text":"Let’s Encrypt 安装配置nginx的SSL证书教程 使用cerbot生成证书 安装Let’s Encrypt 安装非常简单直接克隆就可以了 1git clone https://github.com/letsencrypt/letsencrypt 如果网速较慢（国外服务器应该快点） 1.可以登录https://github.com/letsencrypt/letsencrypt，下载后通过lrzsz传到云服务器上，再解压 2.修改hosts 查找域名对应的ip地址，并修改hosts文件 123456789101112131415linuxidc@linuxidc:~/linuxidc.com$ nslookup github.global.ssl.fastly.NetServer: 127.0.0.53Address: 127.0.0.53#53Non-authoritative answer:Name: github.global.ssl.fastly.NetAddress: 151.101.229.194linuxidc@linuxidc:~/linuxidc.com$ nslookup github.comServer: 127.0.0.53Address: 127.0.0.53#53Non-authoritative answer:Name: github.comAddress: 13.229.188.59 然后修改hosts文件 sudo vim /etc/hosts 在hosts文件末尾添加两行 12github.com 13.229.188.59github.global.ssl.fastly.Net 151.101.229.194 刷新DNS缓存 sudo /etc/init.d/networking restart 使用cerbot: 123cd letsencrypt# 根据自己的需求调整代码./certbot-auto certonly --standalone --email admin@example.com -d example.c 成功提示 12345678910IMPORTANT NOTES:Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/sast.nymrli.top/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/sast.nymrli.top/privkey.pem Your cert will expire on 2019-02-08. To obtain a new or tweaked version of this certificate in the future, simply run certbot-auto again. To non-interactively renew *all* of your certificates, run &quot;certbot-auto renew&quot; - If you like Certbot, please consider supporting our work by: 配置Nginx: server 不再监听80端口，因为TLS要使用的是443端口，然后引入证书和key 123456789101112131415161718server &#123; listen 443 ssl; server_name 127.0.0.1; charset utf-8; client_max_body_size 75M; location /static&#123; alias /home/mrli/Python_project/QQoauth_remote/static; &#125; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:81; uwsgi_param UWSGI_SCRIPT app:app; # 启动flask的文件:Flask的实例 &#125; ssl_certificate /etc/letsencrypt/live/test.nymrli.top/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/test.nymrli.top/privkey.pem; #前面生成的证书，改一下里面的域名就行，不建议更换路径&#125; 重启Nginx： 1sudo service nginx restart 使用acme.sh 下载acme 123git clone https://github.com/Neilpang/acme.sh.gitcd acme.sh./acme.sh --install 提示信息 1234567891011[Thu Aug 22 19:58:00 CST 2019] It is recommended to install socat first.[Thu Aug 22 19:58:00 CST 2019] We use socat for standalone server if you use standalone mode.[Thu Aug 22 19:58:00 CST 2019] If you don&apos;t use standalone mode, just ignore this warning.[Thu Aug 22 19:58:00 CST 2019] Installing to /home/mrli/.acme.sh[Thu Aug 22 19:58:00 CST 2019] Installed to /home/mrli/.acme.sh/acme.sh[Thu Aug 22 19:58:00 CST 2019] Installing alias to &apos;/home/mrli/.bashrc&apos;[Thu Aug 22 19:58:00 CST 2019] OK, Close and reopen your terminal to start using acme.sh[Thu Aug 22 19:58:00 CST 2019] Installing cron job1 0 * * * &quot;/home/mrli/.acme.sh&quot;/acme.sh --cron --home &quot;/home/mrli/.acme.sh&quot; &gt; /dev/null[Thu Aug 22 19:58:00 CST 2019] Good, bash is found, so change the shebang to use bash as preferred.[Thu Aug 22 19:58:01 CST 2019] OK 生成证书 123export Ali_Key=\"xxxx\"export Ali_Secret=\"yyyy\"acme.sh --issue --dns dns_ali -d nymrli.top -d *.nymrli.top 注：这边的Key和secret需要找到你的阿里云API密钥，Acesskey ![accesskeys](C:/Users/10630/Documents/Let’s Encrypt 安装配置 SSL 证书教程/accesskeys.png) 输出信息** 12345678910111213141516171819202122232425262728293031323334353637383940[Thu Aug 22 20:01:53 CST 2019] Create account key ok.[Thu Aug 22 20:01:53 CST 2019] Registering account[Thu Aug 22 20:01:55 CST 2019] Registered[Thu Aug 22 20:01:55 CST 2019] ACCOUNT_THUMBPRINT='YljrV0ThIsQxXtfdxksrd91g1fWvM9Btn9Dazt8OWyo'[Thu Aug 22 20:01:55 CST 2019] Creating domain key[Thu Aug 22 20:01:55 CST 2019] The domain key is here: /home/mrli/.acme.sh/nymrli.top/nymrli.top.key[Thu Aug 22 20:01:55 CST 2019] Multi domain='DNS:nymrli.top,DNS:*.nymrli.top'[Thu Aug 22 20:01:55 CST 2019] Getting domain auth token for each domain[Thu Aug 22 20:01:56 CST 2019] Getting webroot for domain='nymrli.top'[Thu Aug 22 20:01:56 CST 2019] Getting webroot for domain='*.nymrli.top'[Thu Aug 22 20:01:57 CST 2019] Adding txt value: NyNt2AxJ3OmW8s_wVn2C3CNN9_yT1o_v2o0MhmdUoTs for domain: _acme-challenge.nymrli.top[Thu Aug 22 20:01:59 CST 2019] The txt record is added: Success.[Thu Aug 22 20:01:59 CST 2019] Adding txt value: ADqtxSTlQ0DH7jHZzlP9UZB0dT9U2oVYSk_zTabYN3w for domain: _acme-challenge.nymrli.top[Thu Aug 22 20:02:01 CST 2019] The txt record is added: Success.[Thu Aug 22 20:02:01 CST 2019] Let's check each dns records now. Sleep 20 seconds first.[Thu Aug 22 20:02:22 CST 2019] Checking nymrli.top for _acme-challenge.nymrli.top[Thu Aug 22 20:02:24 CST 2019] Domain nymrli.top '_acme-challenge.nymrli.top' success.[Thu Aug 22 20:02:24 CST 2019] Checking nymrli.top for _acme-challenge.nymrli.top[Thu Aug 22 20:02:25 CST 2019] Domain nymrli.top '_acme-challenge.nymrli.top' success.[Thu Aug 22 20:02:25 CST 2019] All success, let's return[Thu Aug 22 20:02:25 CST 2019] Verifying: nymrli.top[Thu Aug 22 20:02:28 CST 2019] Success[Thu Aug 22 20:02:28 CST 2019] Verifying: *.nymrli.top[Thu Aug 22 20:02:31 CST 2019] Success[Thu Aug 22 20:02:31 CST 2019] Removing DNS records.[Thu Aug 22 20:02:31 CST 2019] Removing txt: NyNt2AxJ3OmW8s_wVn2C3CNN9_yT1o_v2o0MhmdUoTs for domain: _acme-challenge.nymrli.top[Thu Aug 22 20:02:34 CST 2019] Removed: Success[Thu Aug 22 20:02:34 CST 2019] Removing txt: ADqtxSTlQ0DH7jHZzlP9UZB0dT9U2oVYSk_zTabYN3w for domain: _acme-challenge.nymrli.top[Thu Aug 22 20:02:38 CST 2019] Removed: Success[Thu Aug 22 20:02:38 CST 2019] Verify finished, start to sign.[Thu Aug 22 20:02:38 CST 2019] Lets finalize the order, Le_OrderFinalize: https://acme-v02.api.letsencrypt.org/acme/finalize/64001779/941369076[Thu Aug 22 20:02:40 CST 2019] Download cert, Le_LinkCert: https://acme-v02.api.letsencrypt.org/acme/cert/034f6880d75703381da6f5efedb159772580[Thu Aug 22 20:02:40 CST 2019] Cert success.-----BEGIN CERTIFICATE-----xxxxx-----END CERTIFICATE-----[Thu Aug 22 20:02:40 CST 2019] Your cert is in /home/mrli/.acme.sh/nymrli.top/nymrli.top.cer [Thu Aug 22 20:02:40 CST 2019] Your cert key is in /home/mrli/.acme.sh/nymrli.top/nymrli.top.key [Thu Aug 22 20:02:40 CST 2019] The intermediate CA cert is in /home/mrli/.acme.sh/nymrli.top/ca.cer [Thu Aug 22 20:02:40 CST 2019] And the full chain certs is there: /home/mrli/.acme.sh/nymrli.top/fullchain.cer nginx配置文件内容 123456789101112131415161718server &#123; listen 443 ssl; server_name 127.0.0.1; charset utf-8; client_max_body_size 75M; location /static&#123; alias /home/mrli/Python_project/QQoauth_remote/static; &#125; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:81; uwsgi_param UWSGI_SCRIPT app:app; # 启动flask的文件:Flask的实例 &#125; ssl_certificate /home/mrli/.acme.sh/nymrli.top/fullchain.cer; ssl_certificate_key /home/mrli/.acme.sh/nymrli.top/nymrli.top.key; #前面生成的证书，改一下里面的域名就行，不建议更换路径&#125; 阿里云免费SSL证书symantec 从云盾证书服务(包年)中选择免费的symantec生成后，按下载，选择nginx证书 文件内容如下 我们需要把这两个文件放到我们的服务器中，如果是linux系统，推荐放到/etc/ssl/目录下 示例：nginx节点配置 1234567891011121314151617181920212223242526272829http&#123; #http节点中可以添加多个server节点 server&#123; #监听443端口 listen 443; #对应的域名，把test.nymrli.top改成你们自己的域名就可以了 server_name test.nymrli.top; ssl on; #从腾讯云获取到的第一个文件的全路径 ssl_certificate /etc/ssl/1474527_www.nymrli.top.pem; #从腾讯云获取到的第二个文件的全路径 ssl_certificate_key /etc/ssl/1474527_www.nymrli.top.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; #这是我的主页访问地址，因为使用的是静态的html网页，所以直接使用location就可以完成了。 location / &#123; #文件夹 root /usr/local/service/ROOT; #主页文件 index index.html; &#125; &#125;&#125; ▲.crt、pem、key都是证书文件 问题解决: 1Problem binding to port 80: Could not bind to IPv4 or IPv6. 原因是 nginx 占用了80端口，输入service nginx stop。然后再次执行证书安装命令，即可顺利安装。安装完毕后，输入service nginx start，重启 nginx 服务。 2.重启nginx失败=&gt;conf配置有问题 12See &quot;systemctl status nginx.service&quot; and &quot;journalctl -xe&quot; for details. failed! A:.conf文件的注释是#而不是//","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"}]},{"title":"时间序列概念及主要模型","slug":"时间序列概念及主要模型","date":"2019-07-29T11:05:18.000Z","updated":"2019-09-15T08:07:31.076Z","comments":true,"path":"2019/07/29/时间序列概念及主要模型/","link":"","permalink":"https://nymrli.top/2019/07/29/时间序列概念及主要模型/","excerpt":"","text":"时间序列概念及主要模型 Q:什么是时间序列分析? A:时间序列是按照时间顺序，按照一定时间间隔取得的一系列观测值 Q:怎样做时间序列分析? A:时间序列分析尝试找出序列值在过去呈现的特征模式，假定这种模式在未来能够持续，进而对未来进行预测 时间序列三大特征 序列相关性：当期的序列值和前期某个或某些序列值线性相关 √ 自相关系数（全相关系数）（ACF）：用来度量同一事件在不同时期之间的相关程度。ρh=r(h)r(0)\\rho_{h}=\\frac{r(h)}{r(0)}ρh​=r(0)r(h)​，其中r（h）为h期协方差函数，r（0）为方差 √ 偏自相关系数（PACF）：度量去除中间变量影响后的相关程度。XtX_{t}Xt​和Xt−2X_{t-2}Xt−2​通过Xt−1X_{t-1}Xt−1​产生关联，PACF即为去除Xt−1X_{t- 1}Xt−1​的关联后两者的相关程度 趋势性：序列整体上呈现单调性，如平稳，上涨或下跌 ARMA模型是平稳的时间序列模型，在建模前必须去除趋势性 随机性：序列在一定程度上呈现不确定性 模型并不能够捕捉到现实世界中的所有特征，总有一些噪声的存在，这些噪声叫做白噪声 时间序列模型预测方法： 算术平均法，移动平均法，加权移动平均法，指数平滑法，自回归法和移动平均法（ARIMA） 算数平均法：对时间序列的过去数据进行简单平均来进行预测 移动平均法(ARIMA)：不考虑远期的数据，仅考虑近期数据产生的影响。 加权移动平均法：给予近期数据较大的权重，远期数据较小的权重 指数平滑法：给予近期数据较大的权重，远期数据较小的权重，但是权重以指 数的形式适减 自回归法和移动平均法（ARIMA）:先对数据做了差分，之后再使用自回归滑动平均模型[^ARMA]模型。优点信息浪费最少，集趋势性，相关性和随机性于一身 基本概念 T时刻的时间序列值表示为XtX_tXt​,T-1时刻的序列值表述为Xt−1X_{t-1}Xt−1​或者X[t−1]X[t-1]X[t−1] 一个时间序列可以表述为：{Xt∣t=1,2,3…n}\\left\\{X_{t} | t=1,2,3 \\dots n\\right\\}{Xt​∣t=1,2,3…n} 滞后算子BX,=Xt−1B X,=X_{t-1}BX,=Xt−1​ 时间序列的差分:Xt−Xt−1X_{t}-X_{t-1}Xt​−Xt−1​或者X[t]−X[t−1]X[t]-X[t-1]X[t]−X[t−1] 一阶差分：Xt−Xt−1=Xt−BXt=(1−B)XtX_{t}-X_{t-1}=X_{t}-B X_{t}=(1-B) X_{t}Xt​−Xt−1​=Xt​−BXt​=(1−B)Xt​ 二阶差分：∇(∇Xt)=∇Xt−∇Xr−1=(Xt−Xt−1)−(Xt−1−Xt−2)=Xt−2Xt−1+Xt−2=(1−B)2Xt\\nabla\\left(\\nabla X_{t}\\right)=\\nabla X_{t}-\\nabla X_{r-1}=\\left(X_{t}-X_{t-1}\\right)-\\left(X_{t-1}-X_{t-2}\\right)=X_{t}-2 X_{t-1}+X_{t-2}=(1-B)^{2} X_{t}∇(∇Xt​)=∇Xt​−∇Xr−1​=(Xt​−Xt−1​)−(Xt−1​−Xt−2​)=Xt​−2Xt−1​+Xt−2​=(1−B)2Xt​ k步差分：Xt−Xt−k=Xt−BkXt=(1−Bk)XtX_{t}-X_{t-k}=X_{t}-B^{k} X_{t}=\\left(1-B^{k}\\right) X_{t}Xt​−Xt−k​=Xt​−BkXt​=(1−Bk)Xt​ 思考： 1.三阶差分如何表达？3步差分如何表达？ 2.为什么要进行一阶差分？二阶差分？ 3.为什么要进行k步差分？ 4.阶次差分与步长差分的区别？ 时间序列分类 Q:什么是序列平稳？ A: 1.E(Xt)=μE\\left(X_{t}\\right)=\\muE(Xt​)=μ，对于所有t而言，序列的期望为一常数，见图一 2.Var⁡(Xt)=σ\\operatorname{Var}\\left(X_{t}\\right)=\\sigmaVar(Xt​)=σ，对于所有t，序列方差为一常数，见图二 3.r(h)=Cov⁡(Xt,Xt−l)r(h)=\\operatorname{Cov}\\left(X_{t}, X_{t-l}\\right)r(h)=Cov(Xt​,Xt−l​)对于所有t以及h〉0，序列的协方差为是由h唯一决定的函数，即h阶的相关性只与h有关，与时刻t无关，如：{Xn,Xn+1,Xn+2,…,Xn},{X1,X2,X3,…,Xn+1−n]\\left\\{X_{n}, X_{n+1}, X_{n+2}, \\ldots, X_{n}\\right\\},\\left\\{X_{1}, X_{2}, X_{3}, \\ldots, X_{n+1}-n\\right]{Xn​,Xn+1​,Xn+2​,…,Xn​},{X1​,X2​,X3​,…,Xn+1​−n]与{Xh+5,Xh+6,Xh+7,…,Xn+5},{X6,X7,X8,…,Xn+6−h}\\left\\{X_{h+5}, X_{h+6}, X_{h+7}, \\ldots, X_{n+5}\\right\\},\\left\\{X_{6}, X_{7}, X_{8}, \\ldots, X_{n+6-h}\\right\\}{Xh+5​,Xh+6​,Xh+7​,…,Xn+5​},{X6​,X7​,X8​,…,Xn+6−h​}的相关性一致 根据序列是否平稳，时间序列可以分为： 平稳序列：白噪声序列、AR（p）序列，MA（a）序列，ARWA（p.g）序列 非平稳序列：ARlMA（P.d.g）序列 平稳条件: 1.E(xt)=μE\\left(x_{t}\\right)=\\muE(xt​)=μ序列的均值应该是一个常数，而不是随时间变化的函数。下图中左图满足要求，而右图的均值是随时间而变化的。 2.Var⁡(Xt)=σ\\operatorname{Var}\\left(X_{t}\\right)=\\sigmaVar(Xt​)=σ,序列的方差为一个常数，而不随时间的变化 3.Cov⁡(yt,yt+k)=y0\\operatorname{Cov}(y t, y t+k)=y 0Cov(yt,yt+k)=y0,k,序列协方差的值只与时间间隔k有关，与时间t无关 白噪声序列 (高斯)白噪声模型:Xt=et∣et∼WN(0,σ2)X_{t}=\\mathrm{e}_{\\mathrm{t}} | \\mathrm{e}_{\\mathrm{t}} \\sim \\mathrm{WN}\\left(0, \\sigma^{2}\\right)Xt​=et​∣et​∼WN(0,σ2) (高斯)白噪声就是一系列独立分布的正态序列： 序列相关性：无 趋势性：无 随机性：是 白噪声的每一个时序点都是服从正态分布的 序列无规律可循，在均值处反复震荡 1234567891011clear,clc;N=0:1000;fs=1024;t=N./fs;y=3*sin(2*pi*t);x=wgn(1,1001,2); % wgn产生高斯白噪声i=y+x; % 给原有信号y叠加高斯白噪声%i=awgn(y,2); % awgn在信号y中加入高斯白噪声。subplot(3,1,1),plot(x);subplot(3,1,2),plot(y);subplot(3,1,3),plot(i); 自回归模型AR ▲AR§: Xt=β1Xt−1+β2Xt−2+…+βpXt−p+etet∼WN(0,σ2)X_{t} = \\beta_{1}X_{t-1}+\\beta_{2} X_{t-2}+\\ldots+\\beta_{p} X_{t-p}+\\mathrm{e}_{t} \\quad \\mathrm{e}_{t} \\sim \\mathrm{WN}\\left(0, \\sigma^{2}\\right)Xt​=β1​Xt−1​+β2​Xt−2​+…+βp​Xt−p​+et​et​∼WN(0,σ2) 当前时刻的时序值可由其过去值的线性组合加上一个白噪声 建模的目的就是要搞清过去几期的历史值会影响当前值 模型特征： 趋势性：无 相关性：有 随机性：有 ▲AR（1）模型: Xt=β1Xt−1+etX_{t}=\\beta_{1} X_{t-1}+e_{t}Xt​=β1​Xt−1​+et​ 一阶自回归模型是最简单的自回归模型 该模型在t+1时的情形:Xt+1=β⊥Xt+et+1X_{t+1}=\\beta_{\\perp} X_{t}+e_{t+1}Xt+1​=β⊥​Xt​+et+1​ 自相关系数：ρ1=β1,ρ2=β12,…,ρk=β1k,k≥3\\rho_{1}=\\beta_{1}, \\rho_{2}=\\beta_{1}^{2}, \\ldots, \\rho_{k}=\\beta_{1}^{k}, \\mathrm{k} \\geq 3ρ1​=β1​,ρ2​=β12​,…,ρk​=β1k​,k≥3 偏自相关系数：φ11=ρ1,φkk=0,k⩾2\\varphi_{11}=\\rho_{1}, \\varphi_{k k}=0, k \\geqslant 2φ11​=ρ1​,φkk​=0,k⩾2 AR（1）的序列相关性： ACF星现指数下降趋势 PACF在一阶处出现峰值，之后截断 Q:如何识别自回归阶数 A: PACF显示出剧烈地下降，并截断在P阶，而ACF呈指数下降趋势 PACF截尾的阶数即为AR模型的阶数 移动平均模型MA ▲MA(a): Xt=et+β˙1et−1+β2et−2+…+βqet−qX_{t}=e_{t}+\\dot{\\beta}_{1} e_{t-1}+\\beta_{2} e_{t-2}+\\ldots+\\beta_{q} e_{t-q}Xt​=et​+β˙​1​et−1​+β2​et−2​+…+βq​et−q​ , et∼WN(0,σ2)e_{t} \\sim W N\\left(0, \\sigma^{2}\\right)et​∼WN(0,σ2) 序列当前时刻的时序值是过去q阶白噪声的线性组合 建模的目的在于： 找出过去几期的白噪声影响了当前值 找出过去a期冲击效应对当前值的影响 模型特征： 趋势性：无 相关性：有 随机性：有 ▲MA（1）模型: Xt=et+β1et−1X_{t}=e_{t}+\\beta_{1} e_{t-1}Xt​=et​+β1​et−1​ 一阶移动平均模型是最简单的移动平均模型 该模型在t+1时的情形？Xt+1=et+1+β1etX_{t+1}=e_{t+1}+\\beta_{1} e_{t}Xt+1​=et+1​+β1​et​ ​ MA（1）模型是利用t时刻的冲击变量值来预测将来 自相关系数：ρk=γkγ0={β11+β12,k=10k≥2\\rho_{k}=\\frac{\\gamma_{k}}{\\gamma_{0}}=\\left\\{\\begin{array}{cc}{\\frac{\\beta_{1}}{1+\\beta_{1}^{2}},} &amp; {k=1} \\\\ {0} &amp; {k \\geq 2}\\end{array}\\right.ρk​=γ0​γk​​={1+β12​β1​​,0​k=1k≥2​ 偏自相关系数：φkk={ρ1,k=1−ρ121−ρ12k=2−φk−1,k−1ρ11−φk−1,1ρ1k≥3\\varphi_{k k}=\\left\\{\\begin{array}{cc}{\\rho_{1},} &amp; {k=1} \\\\ {\\frac{-\\rho_{1}^{2}}{1-\\rho_{1}^{2}}} &amp; {k=2} \\\\ {\\frac{-\\varphi_{k-1, k-1} \\rho_{1}}{1-\\varphi_{k-1,1} \\rho_{1}}} &amp; {k \\geq 3}\\end{array}\\right.φkk​=⎩⎪⎨⎪⎧​ρ1​,1−ρ12​−ρ12​​1−φk−1,1​ρ1​−φk−1,k−1​ρ1​​​k=1k=2k≥3​ 自回归滑动平均模型ARMA ▲ARMA（p,q）:Xt=β1Xt−1+…+βpXt−p+et+α1et−1+α2et−2+…+αqet−qX_{t}=\\beta_{1} X_{t-1}+\\ldots+\\beta_{p} X_{t-p}+e_{t}+\\alpha_{1} e_{t-1}+\\alpha_{2} e_{t-2}+\\ldots+\\alpha_{q} e_{t-q}Xt​=β1​Xt−1​+…+βp​Xt−p​+et​+α1​et−1​+α2​et−2​+…+αq​et−q​ ARMA（p,q）模型就是AR（p）和MA（q）模型的组合 ARMA模型是更普遍的一类模型 模型特征： 趋势性：无 相关性：有 随机性：有 ▲ARMA(1,1)： 通过查看自相关函数ACF和偏自相关函数PACF识别相关性 ACF呈指数下降趋势 PACF呈现指数下降趋势 Q:如何识别一个ARMA的阶数p和q? A: 1.由于ACF与PACF均呈现指数下降，判断阶数需要靠不断尝试 2.在模型的不同尝试中，通过选择AIC较小的为最优模型 AIC=2k+n∗ln⁡(RSSn)A I C=2 k+n * \\ln (\\frac{R S S}{n})AIC=2k+n∗ln(nRSS​)k为参教数量，RSS为残差平方和 AR，MA，ARMA模型识别 ARIMA模型 ARIMA是在ARMA基础上发展而来的更加综合性的模型，体现为： ■ 趋势性 ■ 序列相关性 ■ 随机性 ARIMA是不平稳的时间序列，不能直接用ARMA建模。ARIMA模型是在ARMA模型演变出来的，它实际上是先对数据做了差分，之后再使用ARMA模型；换句话说，ARIMA模型是先将非平稳数据变得平稳（用差分），之后再用ARMA模型处理平稳数据 ARIMA（1，1，0）的时间序列： 序列有很强的趋势性 ARIMA（1，1，0）的序列相关性： ACF下降极其缓慢 ARIMA（1，1，0）的序列图和ACF： ARIMA(p,d,q) ∇dXt=(1−B)dXt=Yt\\nabla_{d} X_{t}=(1-B)^{d} X_{t}=Y_{t}∇d​Xt​=(1−B)dXt​=Yt​ Yt=β1Yt−1+...+βpYt−p+et+α1et−1+α2et−2+…+αqet−qY_{t}=\\beta_{1} Y_{t-1}+...+\\beta_{p} Y_{t-p}+e_{t}+\\alpha_{1} e_{t-1}+\\alpha_{2} e_{t-2}+\\ldots+\\alpha_{q} e_{t-q}Yt​=β1​Yt−1​+...+βp​Yt−p​+et​+α1​et−1​+α2​et−2​+…+αq​et−q​ 差分后的序列符合ARMA（p，g） 符号△为差分算子，∇dXt\\nabla_{d} X_{t}∇d​Xt​代表d阶差分序列 一阶差分序列ΔXt=(1−B)∗Xt=Xt−Xt−1\\Delta X_{t}=(1-B)^{*} X_{t}=X_{t}-X_{t-1}ΔXt​=(1−B)∗Xt​=Xt​−Xt−1​ 预测的评价指标 ME（误差）：Mean（Actual-Predict） MAE（绝对误差）：Mean（abs（Actual-Predict）） MAPE（百分比误差）：Mean（abs（Actual-Predict/Actual） MSE（均方误差平方和）：Mean（（Actual-Predict）2） RMSE（标准差）：Sqrt（Mean（（Actual-Predict）A2）） 在模型选择方法上，通常会结合客户的建议以及其他的时间序列模型方法，选择某个评价指标，进而选择使该评价指标最小的模型方法 参考:https://blog.csdn.net/weixin_41636030/article/details/89115370","categories":[],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"https://nymrli.top/tags/数学建模/"}]},{"title":"基础知识补充——白噪声、高斯白噪声","slug":"基础知识补充——白噪声、高斯白噪声","date":"2019-07-29T10:47:04.000Z","updated":"2019-09-15T08:07:31.041Z","comments":true,"path":"2019/07/29/基础知识补充——白噪声、高斯白噪声/","link":"","permalink":"https://nymrli.top/2019/07/29/基础知识补充——白噪声、高斯白噪声/","excerpt":"","text":"白噪声、高斯白噪声 白噪声过程: 对于一个随机变量X(t)（t=1，2，3……），如果是由一个不相关的随机变量的序列构成的，即对于所有s不等于t，随机变量X(t)和X(s)的协方差为零，则称其为纯随机过程。对于一个纯随机过程来说，若其期望为0，方差为常数，则称之为白噪声过程。 白噪声: 白噪声序列，是指白噪声过程的样本实称，简称白噪声[1]。白噪声是**在较宽的频率范围内，各等带宽的频带所含的噪声能量相等的噪声**[2]，是一种功率频谱密度为常数的随机信号或随机过程，也就是说，此信号在各个频段上的功率是一样的。 理想的白噪声具有无限的带宽，因而其能量无限大，但这是不可能实际存在的，所以，我们把有限带宽内的平整讯号视为白噪声[^3]，以便我们实际应用当中的分析。 近似计算:一般情况下，若一个噪声过程所具有的频谱宽度远远大于它所作用系统的带宽，并且在该带宽中其功率谱密度基本为一常数，那么就能够把其作为白噪声来对待。 白噪声的功率密度函数恒定，为Pn(t)=n02(−∞&lt;f&lt;+∞)(W/HZ)P_{n}(t)=\\frac{n_{0}}{2}(-\\infty&lt;f&lt;+\\infty)(\\mathrm{W} / \\mathrm{HZ})Pn​(t)=2n0​​(−∞&lt;f&lt;+∞)(W/HZ) Pn(t)=n0(0&lt;f&lt;+∞)(W/Hz)P_{n}(t)=n_{0}(0&lt;f&lt;+\\infty)(\\mathrm{W} / \\mathrm{Hz})Pn​(t)=n0​(0&lt;f&lt;+∞)(W/Hz)，其中n0n_0n0​是常数。 高斯白噪声 高斯噪声指的是它的概率密度函数服从正态分布的噪声。 高斯分布，记为N (μ,σ2)，其中μ为高斯分布的均值（数学期望），σ2为高斯分布的方差，当μ=0，σ2=1时，该分布称为标准正态分布。高斯分布的一维概率密度可表示为式：P(x)=12πσexp⁡(−(x−μ)22σ2)P(x)=\\frac{1}{\\sqrt{2 \\pi} \\sigma} \\exp \\left(-\\frac{(x-\\mu)^{2}}{2 \\sigma^{2}}\\right)P(x)=2π​σ1​exp(−2σ2(x−μ)2​) 在通信信道中，一般噪声的均值μ=0。，那么可以得知当噪声的均值是零的时候，噪声的平均功率等于其方差。 高斯白噪声的高斯指的是概率分布为正态分布，白噪声指的是其二阶矩不相关，一阶矩为常数的噪声。故把瞬时值概率分布服从高斯分布，功率谱密度服从均匀分布的噪声称为高斯白噪声[^1]。这两个条件是判断高斯白噪声性能的标准。 由于高斯白噪声能够反映实际通信信道中的噪声情况，能够比较真实的反映信道噪声的一些特性，并且可以用具体的数学表达式表示，适合分析、计算系统的抗噪声性能，所以广泛应用于通信系统的理论分析。 高斯白噪声模型:Xt=et∣et∼WN(0,σ2)X_{t}=\\mathrm{e}_{\\mathrm{t}} | \\mathrm{e}_{\\mathrm{t}} \\sim \\mathrm{WN}\\left(0, \\sigma^{2}\\right)Xt​=et​∣et​∼WN(0,σ2)","categories":[],"tags":[{"name":"信号处理","slug":"信号处理","permalink":"https://nymrli.top/tags/信号处理/"}]},{"title":"傅里叶变换->小波变化","slug":"傅里叶变换-小波变化","date":"2019-07-29T01:51:32.000Z","updated":"2019-11-26T07:51:52.476Z","comments":true,"path":"2019/07/29/傅里叶变换-小波变化/","link":"","permalink":"https://nymrli.top/2019/07/29/傅里叶变换-小波变化/","excerpt":"","text":"傅里叶变换-&gt;小波变化 声明:文中大多数内容来自(知乎1335)[https://www.zhihu.com/people/zhi-yuan-ya-77],matlab源代码:1368069096/From_FT_to_WT_examples-,部分为个人理解阐明 一.傅里叶变换FT 基础知识 （FOURIER TRANSFORM，简称FT） 为什么傅里叶变换可以把一个信号从时域变换到频域? 先给出公式，傅里叶变换的形式为：X(w)=∫−∞+∞x(t)e−jwtdtX(w)=\\int_{-\\infty}^{+\\infty} x(t) e^{-j w t} d tX(w)=∫−∞+∞​x(t)e−jwtdt PS：傅里叶变换还存在系数，有的文章写的是 12π\\frac{1}{2 \\pi}2π1​ ，有的文章写的是12π\\sqrt\\frac{1}{2 \\pi}2π1​​ ，两个系数只要满足正变换系数乘上逆变换系数等于12π\\frac{1}{2 \\pi}2π1​ 即可。这是为了保证经过一次正变换和反变换之后，得到的信号与原信号幅值相同，与我们接下来的讨论关系不大。 1.理解变换公式 我们知道，根据欧拉公式，e−jwt=cos⁡(wt)−jsin⁡(wt)e^{-j w t}=\\cos (w t)-j \\sin (w t)e−jwt=cos(wt)−jsin(wt)。也就是说，傅里叶变换的本质就是：将原始信号乘上一组三角函数（正余弦），之后在整个时间域上积分。就这么简单！ y=sin(3t)图 我们来看一个信号：y = sin(3t)，如下图： 很好的周期性质，且每个周期的积分值都是0。如果对这个函数在(−∞,+∞)(-\\infty,+\\infty)(−∞,+∞)积分，那就是基本是0，因为 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞)包含了无数个周期。 PS：虽然这个积分在高数上不可积，但是你应该明白这里我要表达的意思：因为良好的周期性，且每个周期积分值是0，那么最后在很长的一段时间区间上积分，得到的还是一个很小的数，近似为0。 我们来用一段较长的时间区间计算一下，∫050sin⁡(3t)dt=0.1002\\int_{0}^{50} \\sin (3 t) d t=0.1002∫050​sin(3t)dt=0.1002，结果符合我们的预计。 y=sin(4t)sin(3t)图 现在，我们来将这个信号乘上一个sin(4t) ，则信号变为y1 = sin(3t)*sin(4t)，如下图： 具有一个较短的小幅震动的周期和一个较长的主体周期，对吧？且每个主体周期的积分值都是0。同以上讨论，如果对这个函数在(−∞,+∞)(-\\infty,+\\infty)(−∞,+∞)积分，基本还接近于0，因为 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞)包含了无数个主体周期。 y=sin(3.1t)sin(3t)图 之后呢，我们来将这个信号乘上一个sin(3.1t) ，则信号变为y2 = sin(3t)*sin(3.1t)，如下图： 同样是有一个较短的小幅震动的周期和一个较长的主体周期，对吧？可以判断，每个主体周期的积分值都是0（虽然（0，50）这个区间没有完整地展示主题周期）。那么，依然同以上讨论，如果对这个函数在(−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 积分，基本还接近于0，因为(−∞,+∞)(-\\infty,+\\infty)(−∞,+∞)包含了无数个主体周期。 我们来用之前的时间区间计算一下， ∫050sin⁡(3t)∗sin⁡(3.1t)dt=−4.7731\\int_{0}^{50} \\sin (3 t) * \\sin (3.1 t) d t=-4.7731∫050​sin(3t)∗sin(3.1t)dt=−4.7731 。 咦？这一次怎么距离0这么远了呢？ 原因就是：对于sin(3t)*sin(4t)，它的主体周期较短，（0，50）是包含了好几个主体周期的，也就是说（0，50）在某种程度上是类似于 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 的。但是，对于sin(3t)*sin(3.1t)，它的主体周期很长，（0，50）连它的一个完整的主体周期都没有包含，那么（0，50）是不能类似于 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 的，积分值自然就比较大。 我们此时可以这样小小总结一下，对于信号y = sin(3t)，它的频率是3rad/s，（如果你喜欢用HZ，那就除以2π2\\pi2π ，就是 32π\\frac{3}{2\\pi}2π3​HZ，这里使用rad/s，是为了与前面的傅里叶变换的公式中的w一致），而sin(4t)的频率是4rad/s，sin(3.1t)的频率是3.1rad/s。 如果在 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 积分，那么y1 = sin(3t)*sin(4t)，y2 = sin(3t)*sin(3.1t)的积分值都是0，也就是说，sin(4t)和sin(3.1t)在这里是没差别的。 但是！！！如果在一个有限区间内积分，由于sin(3.1t)的频率3.1rad/s，距离原信号y = sin(3t)的频率3rad/s更近，那么sin(3.1t)和sin(3t)的乘积，也就是y2 = sin(3t)*sin(3.1t)的积分的绝对值会更大，也就是会离0更远。这里已经显示出一定的频率选择性了。 最后，让我们请出我们今天的主角，将这个信号乘上一个自己同频率的sin(3t) ，则信号变为y3 = sin(3t)*sin(3t)，如图： Amazing！！！发现了什么？良好的周期性？还有呢？**由于乘上了自己，任何时间的幅值都大于等于0了！不再满足周期内积分值为0这个条件了！**那么，此时，我们对这个信号在 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 积分，就会得到一个非常非常大的数字。这个很大很大的数字就告诉你，这个信号和你乘的信号是同频率的！这就是可以知道信号中具有哪些频率部分了，不是吗？ 我们还是来用之前的时间区间计算一下， ∫050sin⁡(3t)∗sin⁡(3t)dt=25.0833\\int_{0}^{50} \\sin (3 t) * \\sin (3 t) d t=25.0833∫050​sin(3t)∗sin(3t)dt=25.0833。是不是比其他的积分值都大了好多？ 好了，我们已经知道，▲.将一个信号乘上一个特定频率的sin函数，在 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 上积分，可以将信号中与sin函数同频率的部分筛选出来。那么，原则上讲，只要乘上所有频率的sin函数，并积分，不就知道原始信号中的所有频率部分了吗？ **但是这样做需要把所有频率乘进去，做无数次计算哈！**算不出来的。所以，我们将所乘的sin函数的频率作为符号变量w，来进行积分，即： X(w)=∫−∞+∞x(t)sin⁡(wt)dtX(w)=\\int_{-\\infty}^{+\\infty} x(t) \\sin (w t) d tX(w)=∫−∞+∞​x(t)sin(wt)dt 注意：这里的w只是一个符号变量，这样的话，就只需要做一次积分，可以计算了。 计算出来X(w)之后，想知道特定的频率w0对应的积分值，直接将w0带入X(w)就立马得到积分值。，如想知道是否含有w0=3rad/s分量,那么久计算X(3)看结果是否为0，这样就能知道原信号中是否含有这一频率的部分了。 好了，我们推导的这个式子，是不是与傅里叶变换的式子： X(w)=∫−∞+∞x(t)e−jwtdt=∫−∞+∞x(t)(cos⁡(wt)−jsin⁡(wt))dtX(w)=\\int_{-\\infty}^{+\\infty} x(t) e^{-j w t} d t=\\int_{-\\infty}^{+\\infty} x(t)(\\cos (w t)-j \\sin (w t)) d tX(w)=∫−∞+∞​x(t)e−jwtdt=∫−∞+∞​x(t)(cos(wt)−jsin(wt))dt 很像了呢？ 这就是傅里叶变换的原理！乘上带有符号变量的sin、cos函数，并积分，就知道原始信号中的所有频率部分啦！ 2、傅里叶变换（FT）的正交性 傅里叶变换是一种变换。在变换中，我们将原始信号乘上的变化信号称为基函数。 在傅里叶变换中，一系列不同频率的sin、cos等函数称为这个变换的基函数。至于为什么需要既使用sin，又使用cos，这涉及到一点点正交函数的概念。傅里叶变换中的不同频率的sin、cos等函数是正交函数，使用正交函数组成的基函数会带给变换一些方便。 什么是正交性? 向量正交: 我们都知道，向量 的内积为 。正交的定义为内积为0，即a/cdotb=0a /cdot b=0a/cdotb=0。如a=(1,0)a=(1,0)a=(1,0) 表示x轴，$b=(0,1) $表示y轴，则 a/cdotb=0a /cdot b=0a/cdotb=0即意味着x轴与y轴正交。 假设有一个向量 v=(x0,y0)v=\\left(x_{0}, y_{0}\\right)v=(x0​,y0​)， x0x_0x0​ 在x轴上定位v，y0y_0y0​ 在y轴上定位v。当x轴与y轴正交时，意味着x坐标和y坐标表示的信息是彼此独立的，两坐标可以完全定位v。 那么，当我们已知向量v，已知x轴a与y轴b，如果知道v的坐标呢？答案就是，投影/内积。 将v向x轴a做投影/内积： ，可以得到；将v向y轴b做投影/内积： ，可以得到。 正交基 类似的，函数$ f_{1}(x), f_{2}(x) 的内积定义如下：的内积定义如下：的内积定义如下：\\int_{-\\infty}^{+\\infty} f_{1}(x) f_{2}(x) d x$。函数正交的定义同样为内积为0，即 ∫−∞+∞f1(x)f2(x)dx=0\\int_{-\\infty}^{+\\infty} f_{1}(x) f_{2}(x) d x=0∫−∞+∞​f1​(x)f2​(x)dx=0 。PS：对于周期函数，定义中的积分区间为一个周期T。 我们来看， ∫0Tsin⁡(w1x)cos⁡(w2x)dx=0(1)\\int_{0}^{T} \\sin \\left(w_{1} x\\right) \\cos \\left(w_{2} x\\right) d x=0 (1)∫0T​sin(w1​x)cos(w2​x)dx=0(1) ∫0Tsin⁡(w1x)sin⁡(w2x)dx=0,w1≠w2(2)\\int_{0}^{T} \\sin \\left(w_{1} x\\right) \\sin \\left(w_{2} x\\right) d x=0, w_{1} \\neq w_{2}(2)∫0T​sin(w1​x)sin(w2​x)dx=0,w1​​=w2​(2) ∫0Tcos⁡(w1x)cos⁡(w2x)dx=0,w1≠w2(3)\\int_{0}^{T} \\cos \\left(w_{1} x\\right) \\cos \\left(w_{2} x\\right) d x=0, w_{1} \\neq w_{2}(3)∫0T​cos(w1​x)cos(w2​x)dx=0,w1​​=w2​(3) ▲.因此，傅里叶变换中的不同频率的sin、cos等函数都是正交函数。我们将cos想象为一个轴，将sin想象为一个轴 ，这两个轴，就张了一个函数空间。 我们已经知道，x(t)的傅里叶变换为： X(w)=∫−∞+∞x(t)(cos⁡(wt)−jsin⁡(wt))dt=∫−∞+∞x(t)cos⁡(wt)dt−j∫−∞+∞x(t)sin⁡(wt)dtX(w)=\\int_{-\\infty}^{+\\infty} x(t)(\\cos (w t)-j \\sin (w t)) d t=\\int_{-\\infty}^{+\\infty} x(t) \\cos (w t) d t-j \\int_{-\\infty}^{+\\infty} x(t) \\sin (w t) d tX(w)=∫−∞+∞​x(t)(cos(wt)−jsin(wt))dt=∫−∞+∞​x(t)cos(wt)dt−j∫−∞+∞​x(t)sin(wt)dt 我们来看，实部 ∫−∞+∞x(t)cos⁡(wt)dt\\int_{-\\infty}^{+\\infty} x(t) \\cos (w t) d t∫−∞+∞​x(t)cos(wt)dt 即相当于将x(t)与cos做内积，即向cos轴投影，得到的是在这个函数空间内的cos坐标，也就是与cos的相似度；虚部∫−∞+∞x(t)sin⁡(wt)dt\\int_{-\\infty}^{+\\infty} x(t) \\sin (w t) d t∫−∞+∞​x(t)sin(wt)dt 即相当于将x(t)与sin做内积，即向sin轴投影，得到的是在这个函数空间内的sin坐标，也就是与sin的相似度。cos坐标和sin坐标都确定后，该信号就确定了。 因此，傅里叶变换之后，实部是与cos的相似度，虚部是与sin的相似度，傅里叶变换也就是与cos的相似度和与sin的相似度的总和，也就表示了相应的频率信息。 相似度的理解：通过相似度，可以将跟本身频率相似的频率挑选出来 3、小例子 最后，我们对于y=sin(3t)做傅里叶变换（这里画图用的matlab的FFT，是FT的离散快速算法，不是积分出来的，但是原理是相同的，仅做展示使用），变换后的图像如下： 可以看到，与我们的预期相同，变换之后，在 ω=3rad/s\\omega=3 rad/ sω=3rad/s 处，出现了峰值，即表示该信号中包含了 的 ω=3rad/s\\omega=3 rad/ sω=3rad/s 频率成分。 这里需要说明三点： 1、这边的作图结果不是理想FT，如果是理想的FT，即在 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 上积分，那么除了 ω=3rad/s\\omega=3 rad/ sω=3rad/s 的积分值将是 +∞+\\infty+∞ 之外，其他任意频率处的值都应该是0，得到的将是一个冲激函数。但是，这里我用的是离散傅里叶变换（详见我的下一篇文章），可以暂时理解为类似于我们讨论过的有限区间，当频率靠近3rad/s时（如之前提到的3.1rad/s的例子），也会积分出来一个较大的数值，所以这里不是一个冲击函数，而是一个山峰状的函数； 2、傅里叶变换之后是具有实部和虚部的，实部是与cos的相似度，虚部是与sin的相似度。我们要频率信息的时候，不管是与某一频率w的cos的相似还是与某一频率w的sin的相似，都是这一频率w嘛，不需要区分。因此，这里画图取了模，就不存在实部和虚部了。 3、在ω=3rad/s\\omega=3 r a d / sω=3rad/s处之所以没有出现我们讨论的很大很大很大的值，是因为画图之前对于变换之后的幅值统一除以了信号取样点的个数，统一压缩了一定的倍数。 总结 1.由于sin和cos是一对正交基，所以所有的信号都可以分解成正弦信号与余弦信号的线性叠加。 2.除了与乘以本身频率w的正余弦相同信号再在(−∞,+∞)(-\\infty,+\\infty)(−∞,+∞)范围上积分的结果会是非0以外，乘以其他频率信号的结果都是0.通过这个特性可以将是否含有w频率信号鉴别出 2.傅里叶变化的基函数ejwte^{jwt}ejwt由欧拉公式可分解为e−jwt=cos⁡(wt)−jsin⁡(wt)e^{-j w t}=\\cos (w t)-j \\sin (w t)e−jwt=cos(wt)−jsin(wt),所以根据公式:X(w)=∫−∞+∞x(t)cos⁡(wt)dt−j∫−∞+∞x(t)sin⁡(wt)dtX(w)=\\int_{-\\infty}^{+\\infty} x(t) \\cos (w t) d t-j \\int_{-\\infty}^{+\\infty} x(t) \\sin (w t) d tX(w)=∫−∞+∞​x(t)cos(wt)dt−j∫−∞+∞​x(t)sin(wt)dt，前部分乘以cos(wt)能挑出cos成分中的信号频率，后部分乘以的sin(wt)能挑出sin成分中的信号频率。再将挑出的各信号频率线性叠加的结果就是分解信号总的含有各谐波分量的频率 二.傅里叶变换（FT）的缺点与短时傅里叶变换（STFT） 离散傅里叶变换（DFT） 在本文正式开始之前，我们需要明确一下实际信号进行的FT的一些特殊之处。实际采集的信号往往是这样的： 实际的信号往往具有两个特点： 1、离散性，就是采集数据不连续，很容易理解，采集信号肯定是一个一个数据采集的； 2、有限性，虽然理想的傅里叶变换是从 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 进行积分，但是实际信号往往实在一个区间内(a,b)的。 所以，我们要用到离散傅里叶变换（DISCRETE FOURIER TRANSFORM，简称DFT），DFT与FT相比，就是多了两个特征：1、离散型，2、有限性。 我们来一起试一试如何推导DFT公式。首先设采集了N个信号点，其时刻为 t0,t1,…tN−1t_{0}, t_{1}, \\ldots t_{N-1}t0​,t1​,…tN−1​，对应时刻采集到的信号值为x(t0),x(t1),…x(tN−1)x\\left(t_{0}\\right), x\\left(t_{1}\\right), \\ldots x\\left(t_{N-1}\\right)x(t0​),x(t1​),…x(tN−1​) 。很自然的，原来信号连续，是积分，现在数据离散了，那就是把积分变成累加。于是我们得到： X(w)=∑i=0N−1x(ti)e−jwtiX(w)=\\sum_{i=0}^{N-1} x\\left(t_{i}\\right) e^{-j w t_{i}}X(w)=∑i=0N−1​x(ti​)e−jwti​ 这么一来，我们发现，原信号有N个数据点，DFT变换后的信号却变成连续的了，我们将之称为离散时间傅里叶变换（DISCRETE TIME FOURIER TRANSFORM，简称DTFT）。 DTFT有两个缺点，第一， 且连续，需要进行无数次计算，计算机无法计算；第二，在进行计算的时候，我们需要已知：t0,t1,/ldotstN−1t_{0}, t_{1}, /ldots t_{N-1}t0​,t1​,/ldotstN−1​和 x/left(t0/right),x/left(t1/right),/ldotsx/left(tN−1/right)x/left(t_{0}/right), x/left(t_{1}/right), /ldots x/left(t_{N-1}/right)x/left(t0​/right),x/left(t1​/right),/ldotsx/left(tN−1​/right) ，但是调用过FFT函数的同学都知道，FFT只需要已知x/left(t0/right),x/left(t1/right),/ldotsx/left(tN−1/right)x/left(t_{0}/right), x/left(t_{1}/right), /ldots x/left(t_{N-1}/right)x/left(t0​/right),x/left(t1​/right),/ldotsx/left(tN−1​/right)就可以进行。 这是怎么回事呢？ 首先，我们**使用相对采样时间 代替真实采样时间 ，**可以得到： 。 此时我们发现， X(w)X(w)X(w) 变成了以 2/pi2/pi2/pi为周期的函数，即 那么，我们只需要计算 w/in(0,2/pi)w /in(0,2 /pi)w/in(0,2/pi) 区间的 X(w)X(w)X(w) ，就可以得到 w/in(−/infty,+/infty)w /in(-/infty,+/infty)w/in(−/infty,+/infty) 区间的X(w)X(w)X(w)了。也就是说，通过使用相对采样时间 代替真实采样时间t0,t1,/ldotstN−1t_{0}, t_{1}, /ldots t_{N-1}t0​,t1​,/ldotstN−1​，我们将 的范围从 (−/infty,+/infty)(-/infty,+/infty)(−/infty,+/infty) 缩小到了(0,2/pi2/pi2/pi). 自然地，我们希望将(0,2π2\\pi2π)离散化称为N个点，这样计算机就可以计算了！则取w=2πkN,k=0,1,…N−1w=\\frac{2 \\pi k}{N}, k=0,1, \\ldots N-1w=N2πk​,k=0,1,…N−1，则有： X(k)=∑n=0N−1x(n)e−j2πkNn,k=0,1…N−1X(k)=\\sum_{n=0}^{N-1} x(n) e^{-j \\frac{2 \\pi k}{N} n}, k=0,1 \\ldots N-1X(k)=∑n=0N−1​x(n)e−jN2πk​n,k=0,1…N−1 好了，这就是离散傅里叶变换DFT了！ 接下来，来看DFT的两个性质： 第一， ，即 是所有元素的和，通常会比其他的元素大几个数量级。 第二， ， ， ，即第二个元素和最后一个元素共轭，同理有 等等。 如下图所示，DFT之后的N 个元素中，第一个为均值；之后的 N-1个元素，只有一半元素是独立的。 需要说明，这里 是一种相对频率，独立元素中，最小相对频域为1，最大相对频率为 /fracN2/frac{N}{2}/fracN2 。要想把 还原到真实的频率 ，只需要 ，将 映射到 即可， 为采样频率。 PS：简单说一下，根据香农采样定理，当采样频率为 时，能采到的最大信号频率为。因此，将相对频率 通过公式 ，得到的 就在区间内，也就是真实频率的区间了。 所以DFT公式为： PS：DFT公式的形式很多，有的是从时域到频域，有的是从空间域到频域，但是本质都是一样的，抓住离散性和有限性两个特点即可。离散性是指积分变成了累加，有限性是指积分/累加区间不是 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 了，而是一个有限区间了。 傅里叶变换（FT）的缺点 应该说明，虽然本小节的题目是FT的缺点，但是FT和DFT的本质是相同的。由于信号都是有限长度的、离散的，所以接下来进行的都是DFT，不过在某些部分为了方便理解，还是写了FT的公式。在看本文的时候，你不需要刻意区分这两个概念。 我们现在来看两个信号，如下图： y1=sin⁡(5t)∗(0&lt;t&lt;25)+sin⁡(t)∗(25&lt;t&lt;50)y 1=\\sin (5 t) *(0&lt;t&lt;25)+\\sin (t) *(25&lt;t&lt;50)y1=sin(5t)∗(0&lt;t&lt;25)+sin(t)∗(25&lt;t&lt;50) y2=sin⁡(t)∗(0&lt;t&lt;25)+sin⁡(5t)∗(25&lt;t&lt;50)y 2=\\sin (t) *(0&lt;t&lt;25)+\\sin (5 t) *(25&lt;t&lt;50)y2=sin(t)∗(0&lt;t&lt;25)+sin(5t)∗(25&lt;t&lt;50) 这两个信号都是由sin(t)和sin(5t)组成的，y1是先出现了sin(5t)，再出现了sin(t)，y2是先出现了sin(t)，再出现了sin(5t)。 我们对它们进行FT，看看他们包含怎么样的频率，如下图： y1,FT y2,FT Amazing！发现了什么？变换后的结果是一模一样的，都在w=1rad/s和w=5rad/s出现了峰值！这就可以说明FT的缺点了——FT只能提供频域信息，而完全丢失了时域信息！！！ 不管某一频率的信号出现的时间是早还是晚，FT都是将它一视同仁地乘上sin和cos(FT的变换基函数)，然后在整个时间区间加和。因此，它不能提供某一频率信号出现的时间。 比如，对于上面两个信号，FT只能告诉我们，它们都有1rad/s和5rad/s的频率，而不能告诉我们1rad/s和5rad/s分别出现在哪个时间段。 所以，怎么办呢？？？ 那就是把信号分成左右两半啊！左边进行一次FT，右边进行一次FT，很简单吧！好了，这就是短时傅里叶变换（STFT）的基本原理。 所以，接下来我们要正式开始步入——短时傅里叶变换（STFT），看看它是如何解决这个问题的。 短时傅里叶变换（STFT） 如上所述，我们将信号从中间截断，左边进行一次FT，右边进行一次FT，分别来看看。 y1左 y1右 y2左 y2右 可以看出，y1的左半部分是5rad/s，右半部分是1rad/s，y2恰好相反。这就说明，在y1中，(0, 25)的信号是5rad/s的频率，(25, 50)的信号是5rad/s的频率，y2恰好相反。这就是短时傅里叶变换的基本原理。 但是数学嘛，能用一个公式表达的，就别用一段话表达，截断、切开这些语句太不专业了。截断、切开的操作，更专业的讲叫作分窗，其实是可以通过数学上的处理变成DFT变换的基函数的一部分的。接下来我们来看一看。 首先，你可以想象一下，有一个窗子在这个信号上从左向右滑动，每次你都只能看到这个信号的一部分，所以我们把这个长度叫作窗长width。 现在我们来定义一个方窗函数ywindow=1∗(−width/2&lt;t&lt;width/2)y_{\\text {window}}=1 *(-\\text {width} / 2&lt;t&lt;\\text {width} / 2)ywindow​=1∗(−width/2&lt;t&lt;width/2) ，如下图，即是width = 10 的一个方窗函数： 定义了方窗函数之后，我们只需要对方窗函数进行平移，再与原信号作乘，就相当于原来的截断、切开的操作，因此这种操作更专业地叫作分窗。 那么，将方窗函数向右平移了 （s可能是sliding的意思吧），再与原信号相乘，由于方窗函数除了中心的width部分是1外，其他部分都是0，这就相当于提取出了原信号在处，宽度为width的部分，这个信号分窗这个操作就可以写成： 。 如下两图所示，将 与 相乘，就相当于取出来了 中的(20,30)中的一段。 那么，我们对原信号中被提取出来的这一部分进行FT，就可以写成： X(w,ts)=∫−∞+∞ywindow(t−ts)y(t)e−jw(t−ts)dtX\\left(w, t_{s}\\right)=\\int_{-\\infty}^{+\\infty} y_{w i n d o w}\\left(t-t_{s}\\right) y(t) e^{-j w\\left(t-t_{s}\\right)} d tX(w,ts​)=∫−∞+∞​ywindow​(t−ts​)y(t)e−jw(t−ts​)dt PS：这里之所以 要变成 ，是为了保证做FT的时候相乘的基函数具有统一性。 如此，变换后的代表原信号在处、宽度为width的部分的傅里叶变换，也就可以提取出来原信号在处、宽度为width的部分，包含各个频率部分的多少！带入不同的 ，也就是随着窗子的滑动，就可以知道不同的时间段内频率的成分。 我们采用width为10的方窗函数对y3=sin⁡(20t)∗(0&lt;t&lt;25)+sin⁡(t)∗(25&lt;t&lt;50)y 3=\\sin (20 t) *(0&lt;t&lt;25)+\\sin (t) *(25&lt;t&lt;50)y3=sin(20t)∗(0&lt;t&lt;25)+sin(t)∗(25&lt;t&lt;50)进行STFT，如下： 首先，方窗函数位于 处，与原始信号相乘，选择出(0,10)的信号。 对选择出来的信号进行FT。可以看到，当t=5s时，选择的时间区间为(0,10)，这一部分只包含了 的频率成分。 之后，方窗函数向右移动，与原始信号相乘，选择出不同时间区间的信号，进行FT。这里选择t=25s进行展示。 可以看到，当t=25s时，选择的时间区间为(20,30)，这一部分即包含了 的频率成分，也包含了 的频率成分。 重复以上过程，我们可以将方窗函数选择的不同时间区间的信号的FT的结果拼合起来，形成一张三维图。由此，我们即可知道，在 的时间区间内，信号具有怎么样的频率成分。 通过width = 10的方窗的STFT结果，我们可以知道，对于信号： ，在(0,10)、(10,20)时间区间内，具有20rad/s的频率成分；在(20,30)时间区间内，具有1rad/s和20rad/s的频率成分；在(30,40)、(40,50)时间区间内，具有1rad/s的频率成分。 最后，进行三点重要的讨论。 第一点，变换之后的 是一个三维函数，它有两个自变量， 和w。 指的是原信号在**处，**w上一篇文章我们已经讨论过了，就是频率。所以，STFT提取出来的信息就是：原信号在处、宽度为width的部分，包含的频率信息。 原则上讲，可以得到任一对应的频率成分，如下图。 但是 是连续的，并不意味着你知道了每个时刻的频率成分，你知道的还只是 这一段区间内的频率信息。所以一般不需要计算所有的 ，每隔width计算一次即可。 你或许会想，我**把width缩小一些，不就可以知道更精确的时间范围内的频率了吗？**是的，你的猜想很对！但是，**如此做也会带来一些频域分辨率的问题。**这一点涉及到一些时域分辨率和频域分辨率的知识，我们下一篇文章会着重讲。 本质变化: 第二点，方窗函数是可以包含入变换基函数内部的，这组成了新的基函数，同时反映了STFT的本质。 我们来看， 如果定义 ，那么 那么，STFT的公式： 就可以写成： 我们在上一篇文章里说过，变换就是将原信号乘上一个基函数，再积分的过程，那么，SDFT的基函数就是 ！ Amazing！所以，STFT的本质是什么呢？ **STFT的本质就是将FT的基函数 乘上一个方窗函数，形成了一个新的基函数 ！**前面说的分窗、截断之类的都是表象，STFT的本质是基函数的改变！ 那么，为什么STFT的基函数可以用于分窗，而FT的基函数不行呢？我们来看，我用正弦函数sin(5t)表示原来的基函数 ，那么FT基函数和STFT基函数如下： 原因就是：FT的基函数是在时域无限延伸的，因此，无论怎么平移，都是任分布在整个时域的，起不到分窗的作用。而STFT的基函数只在时域一段不为0，在剩下的时域都是0，因此，STFT的基函数的平移，就相当于自动加了窗子啦！ 紧支撑性: 这种只在时域一段不为0，在剩下的时域都是0的性质被称为“紧支撑性”（compactly supported），具有这种性质的函数，平移之后与一个信号相乘，就相当于分窗操作。这一点很重要，我们之后讲小波变换的基函数的时候还会讲。 第三点，我们前面对于分窗操作使用的函数一直称为“方窗函数”，这是一种最理想的窗函数。还有一些其他的窗函数，比如，汉宁窗、海明窗、高斯窗等。窗函数本质都是一个窗子而已，原理是一模一样的，上面所有的讨论也都成立，只是这些窗子会让信号稍稍变形一丢丢而已。你就想像方窗函数就是一面平面镜，其他的窗函数就是哈哈镜就行了。 总结: Q:为什么要用相对采样时间代替真实采样时间? A:原来做傅立叶变换，既需要知道真实采样时间，也需要知道采样数据，用相对采样时间替代真实采样时间之后，只需要知道采样数据。这极大地拓展了傅立叶变换的使用范围。比如，并不是所有傅立叶变换的对象都可以具有真实采样时间。一副图像也是可以傅立叶变换的，但是在图像里，并没有采样时间这个概念，只有0123456这些像素索引值，对图像做傅立叶变换，就是把索引值作为相对采样时间。 三.短时傅里叶变换（STFT）的缺点与连续小波变换（CWT） 三、短时傅里叶变换（STFT）的缺点与连续小波变换（CWT） 1、分辨率问题 首先，我们需要了解一下海德堡测不准原理： ， 为信号的时间不确定度， 为信号的频率不确定度。即，我们永远无法同时确定一个信号的确切时间和确切频率。 原因比较简单，频率其实就是时域周期性。如果我只给你一个数据点，问你这个数据点的频率是多少，这肯定是做不到的。要确定频率，就需要一个时域区间（包含几个时域周期）的信号。 时域区间越宽，信号的时间定位越不准，时间不确定度 越大，但是得到的频率越准，频率不确定度 越小；我们称之为：低的时域分辨率，高的频域分辨率。 时域区间越窄，信号的时间定位越准，时间不确定度 越小，但是得到的频率越不准，频率不确定度 越大；我们称之为：高的时域分辨率，低的频域分辨率。 如上两图，对于第一个图中 的信号，要确定频率，即使把 都拿来，还是不太准，因为只包含了一个周期；对于第二个图中 的信号，要确定频率，取个 就差不多了，因为已经包含了好几个周期了。 我们来总结一下。 对于低频信号，为了更好地确定频率，我们希望，时域区间宽一些，即时间不确定度 大一些，根据海德堡测不准原理，频率不确定度 自然小一些；即低频信号，我们希望：宽窗子，低的时域分辨率，高的频域分辨率。 对于高频信号，为了更好地在时域定位，我们希望，时域区间窄一些，即时间不确定度 小一些，根据海德堡测不准原理，频率不确定度 自然大一些；即高频信号，我们希望：窄窗子，高的时域分辨率，低的频域分辨率。 上图所示是我们希望的动态分辨率。图中每个小矩形的 轴方向的宽度是时间区间大小， 轴方向的宽度是频率区间大小。注意，每个小矩形的面积是相等的，这保证了时域分辨率乘上频域分辨率是定值，最大程度满足海德堡测不准原理。通过图可以看出，我们希望，对于低频信号：低的时域分辨率，高的频域分辨率；对于高频信号：高的时域分辨率，低的频域分辨率。 对于整体低频、局部高频的信号，这种动态调整分辨率的规则特别有用。在实际信号中，频率非常高的高频信号往往是一种噪声，只在局部出现，基本都满足整体低频、局部高频这一条件。 最后，我们再来看两张分辨率图来强化一下对于分辨率的理解。 上图是一张采集信号的分辨率图。每个小矩形的 轴方向的宽度是很小， 轴方向的宽度很大。也就是说，其时域分辨率很好，可以确切地确定每个信号采样点的时间，但是其频域分辨率很差，或者说完全不具有频域分辨率。 上图是一张傅里叶变换（FT）的分辨率图。每个小矩形的 轴方向的宽度是很大， 轴方向的宽度很小。也就是说，其频域分辨率很好，可以比较精确地确定信号中的频率成分，但是其时域分辨率很差，或者说完全丢失了时域分辨率。 傅里叶变换的这一特性，这一点我在上一篇文章里讲过，这也是我们转而使用短时傅里叶变换（STFT）的原因。 2、短时傅里叶变换（STFT）的缺点 我们来回忆一下STFT（详见：1335：从傅里叶变换进阶到小波变换（二）），STFT的窗长是固定的，即时域分辨率是固定的，根据海德堡测不准原理，其频域分辨率也是固定的。其分辨率图如下： 每个小矩形的 轴方向的宽度和 轴方向的宽度是恒定的！也就是说，不论高频低频，其时域和频域分辨率都不可调，这与我们之前讨论的“对于低频信号：低的时域分辨率，高的频域分辨率；对于高频信号：高的时域分辨率，低的频域分辨率”这一原则不符合。 这种不符合会带来什么后果呢？ 如图所示正弦信号，0250ms：300HZ，250500ms：200HZ ，500~750ms：100HZ ， 750~1000ms：50HZ。 ) 选择一个较窄的窗子 做STFT，结果如下： 当窗子较窄的时候，STFT的时域分辨率还行，但是频域分辨率不佳。 我们选择一个宽一些的窗子 做STFT，结果如下： 当窗子较宽的时候，STFT的频域分辨率很好，基本可以确定频率，但是时间轴上开始出现交叠了，也就是时域分辨率下降了。 我们选择一个更宽的窗子 做STFT，结果如下： 当窗子更宽的时候，STFT的频域分辨率非常好了，但是时域分辨率已经很差了，时间轴上出现了大规模的交叠现象。 我们来总结一下，对于STFT，如果窗子的宽度选择合适，是可以得到时域和频域分辨率都“还可以”的结果的（由于STFT的分辨率固定，只能说“还可以”，不能说“满意”，因为我们最想要的是动态分辨率）。但是，在变换之前，我们也不知道选择多宽的窗子是合适的。 这就是STFT的缺点：1、时间和频率分辨率都固定，不能随着频率的高低实现动态可调；2、选择一个合适的窗宽十分困难。 3、连续小波变换（CWT） 为了实现动态分辨率，我们引入了小波母函数。 需要说明，小波母函数并不是一个特定的函数，而是一种函数的集合，满足了一定条件的函数均可以作为小波母函数。小波母函数 需要满足的有： 条件1，紧支撑性： ，即仅在一小部分定义域里不为0，剩下部分均为0。这个性质带来的便利我们在前一篇文章讲过了，就是具有紧支撑性的基函数，在原信号的时间轴上平移，就相当于对于原信号就行了加窗操作。 条件2，波动性： ，即在所有定义域内积分值为0，这说明小波母函数是一个波。 条件3，容许条件： ，这个条件使变换可逆。其中， 是小波函数傅里叶变换的共轭。由3可知 ，也就是条件2。 条件4，正交性：这个条件也是为了使变换可逆。 PS：条件3、4的数学证明比较复杂，所以仅仅提了一下他们的作用，就是使得变换可逆。 上图就是一个小波母函数的例子，我们看到了： 1、紧支撑性：仅在一小部分定义域里不为0，剩下部分均为0；2、波动性： 在所有定义域内积分值为0。这两个条件是满足的。 小波母函数既然是一个波，那么就具有频率。根据我们第一篇文章讲的内容（1335：从傅里叶变换进阶到小波变换（一）），将小波母函数作为基函数，与采集到的信号相乘并积分，可以筛选出：信号在小波母函数非0部分，频率与小波母函数相近的成分。 需要说明，不同于FT的基函数 ，小波母函数不具有特定的某一频率，而是具有一个范围内的频率，因此筛选的是一定范围的频率，类似于一个带通滤波器。 接下来我们讲一讲，小波母函数的变换，变换公式如下： 一是平移，用上式中的 控制，改变，就相当于 在时间轴上不断的平移。 二是缩放，用上式中的 控制。 变换后的函数 称为小波函数。 如下图，中间的图，较小，相当于挤压；右侧的图， **较大，相当于拉伸。**变换公式前的是为了能量守恒，没有特别目的。 ![img](data:image/svg+xml;utf8,) 我们再来仔细观察一下上图。中间的图，较小，相当于挤压，是不是频率提高了？右侧的图，**较大，相当于拉伸，是不是频率降低了？**咦？有点意思了吧？缩放就是改变频率！另外，一定记住， 越大，频率 越低， 是倒数关系。 我们再来更仔细地观察一下上图。回忆一下上一篇文章，具有紧支撑性的基函数，滑动相当于分窗。那么，这个窗长有多大呢？是不是就是基函数不为零的长度呢？那么，中间的图，较小，相当于挤压，频率提高了，窗长是不是变小了？右侧的图，较大，相当于拉伸，频率降低了，窗长是不是变大了？ 这不正是我们需要的**“低频，宽窗，差的时间分辨率，好的频域分辨率；高频，窄窗，好的时间分辨率，差的频域分辨率”吗？** ![img](data:image/svg+xml;utf8,) 和上图对一下，是不是一模一样了呢？这就是动态调分辨率，得来全不费工夫啊！ 接下来我们对一个信号就行一次连续小波变换（CWT）。下图中蓝色部分为小波函数（但原图没画成波的形式，只是表示小波函数的时间轴位置和不为0的部分的宽度），黄色部分为信号。 ![img](data:image/svg+xml;utf8,)图源：THE WAVELET TUTORIAL 如上图，选择较小的 对小波母函数进行缩放，此时小波函数频率较高，窗子较窄（小波函数不为0的部分窄），用来筛选高频部分。小波函数在时间轴上平移，每一次平移就先相乘，再积分，筛选出信号中与自己频率相近的部分。 此时，窗子较窄（小波函数不为0的部分窄），时间分辨率好，频率分辨率差。 ![img](data:image/svg+xml;utf8,)图源：THE WAVELET TUTORIAL 如上图，将 增大，对小波母函数进行缩放，此时小波函数频率降低，窗子变宽（小波函数不为0的部分变宽），用来筛选中频部分。小波函数在时间轴上平移，每一次平移就先相乘，再积分，筛选出信号中与自己频率相近的部分。 此时，窗子变宽了（小波函数不为0的部分变宽），时间分辨率变差，频率分辨率变好。 ![img](data:image/svg+xml;utf8,)图源：THE WAVELET TUTORIAL 如上图，将 进一步增大，对小波母函数进行缩放，此时小波函数频率再次降低，窗子更宽（小波函数不为0的部分更宽），用来筛选低频部分。小波函数在时间轴上平移，每一次平移就先相乘，再积分，筛选出信号中与自己频率相近的部分。 此时，窗子很宽（小波函数不为0的部分很宽），时间分辨率差，频率分辨率很好。 这就是连续小波变换CWT啦！ 将上述CWT的过程写成公式就是： 注意：上图中我们只列举了三种 （即三次缩放）和4种 （每种缩放对应四个时间位置，但是事实上， 是连续的，无穷多个的。 还是这个正弦信号，0250ms：300HZ，250500ms：200HZ ，500~750ms：100HZ ， 750~1000ms：50HZ。 ![img](data:image/svg+xml;utf8,) 其小波变换如下图所示（忽略图中坐标，原图如此，坐标不太对，还得映射一下，有空了我自己再画一张改一改）： ![img](data:image/svg+xml;utf8,)图源：THE WAVELET TUTORIAL 我们来看，绿色的小峰，对应小的 ，也就是高的频率。他们的时间分辨率很好， 的区间很小，根据 的倒数关系，对应的 的区间就很大，因此频率分辨率不好。 粉色的高峰，对应高的 ，也就是低的频率， 的区间很大，根据 的倒数关系，对应的 的区间就很小，因此频率分辨率很好，时间分辨率不好（有混叠）。 这也就再一次说明了CWT是动态分辨率的，这也是CWT相对于STFT的优势所在。 4、FT、STFT、CWT基函数对比 最后，再来看看，FT、STFT、CWT的基函数之间的不同，以便加深理解。 ![img](data:image/svg+xml;utf8,)图源：百度图片 FT的基函数，是分布在 的 ，不具有紧支撑性，只能筛选频率，使得FT完全丧失了时间信息，不具有时间分辨率。 STFT的基函数，是用窗函数截断的 （图中是被高斯窗截断的），具有了紧支撑性，时域平移等同于分窗，使得STFT既能筛选频率，也能筛选时间。但是STFT基函数是：先确定频率，再与窗函数相乘构成的。因此不同的频率，具有同样的时间和频率分辨率。另外，窗函数的长短也比较难以确定。 CWT的基函数，是小波函数，具有紧支撑性，时域平移等同于分窗，使得CWT既能筛选频率，也能筛选时间。小波函数在改变频率的时候，是通过**“缩放”**实现的，**这使得小波函数在改变频率的同时，改变了窗长。**因此不同的频率，具有不同的时间和频率分辨率，实现了分辨率动态可调。 最后，再说一下，有很多类型的小波母函数，比如haar小波，db系列小波，sym系列小波，coif系列小波等等等等。具体哪一个小波适应哪种情况，估计都能写一本书了，我也没深入钻研过。我在利用小波变换做肌电信号识别的时候就是读一读有关肌电信号识别的论文，看看别人试过哪些小波，是一种上手比较快的方法。 连续小波变换（CWT）的缺点与离散小波变换（DWT） 四、连续小波变换（CWT）的缺点与离散小波变换（DWT） 1、连续小波变换（CWT）的缺点 在上一篇文章（https://zhuanlan.zhihu.com/p/68323379）中我们讲解了 CWT可以实现动态分辨率的时频分析。CWT公式为：， 表示原始信号。你可能已经注意到了，这里的 是一个连续函数。 但是在第二篇文章（https://zhuanlan.zhihu.com/p/66246381）中我们讲过，实际采样信号往往具有两个特点：1、离散性，就是采集数据不连续，很容易理解，采集信号肯定是一个一个数据采集的；2、有限性，虽然理想的CWT是从 进行积分的，但是实际信号往往实在一个区间内 的。如下图所示。 所以，由于CWT需要一个连续信号，但是实际采样信号往往是离散的，我们无法直接对实际信号进行CWT。 或许你想，我们对实际采样信号进行插值连续化不就可以使得其连续了吗？ 是的。将实际采样信号插值连续化之后，我们——人，是可对它进行CWT的。 但是，我们也都知道，我们的帮手——计算机，是无法处理连续问题的。计算机只能处理离散问题。如果计算机要进行CWT，就意味着需要计算机做无穷次运算，计算机计算能力再强也是做不到的。 因此，为了使得计算机可以进行小波变换，我们需要引入离散小波变换（DWT）。 2、离散小波变换（DWT）的Wallet算法 DWT有很多种实现方式，我们在这里介绍Wallet算法，它是DWT的以一种经典的快速算法，也比较易懂。 我们首先来回顾一下上一篇文章讲过的动态分辨率图：高频部分，窄窗，高的时域分辨率，低的频域分辨率；低频部分，宽窗，低的时域分辨率，高的频域分辨率。 我们是利用小波母函数的挤压和拉伸来实现动态分辨率的： 当小波母函数被挤压的时候，频率就高，此时窗子窄，时域分辨率就好，根据海森堡测不准原理，频域分辨率就差； 当小波母函数被拉伸的时候，频率就低，此时窗子宽，时域分辨率就差，根据海森堡测不准原理，频域分辨率就好。 也就是说，我们控制的是不同频率对应的窗长（即时域分辨率），频率分辨率是通过海森堡测不准原理得到的，从而达到了动态分辨率。 那么，如果我们这次不控制窗长（即时域分辨率），转而控制频域分辨率，能否达到动态分辨率呢？ 答案是可以，这就是Wallet算法要解决的问题。 半子带滤波 我们知道，小波母函数本质上是一种带通滤波器。那么，假设可以通过小波母函数构造得到两个滤波器（至于怎么得到后续会介绍一下），包括一个高通滤波器和一个低通滤波器。 假设信号中的最高频率为 。那么，高通滤波器的作用就是得到 的部分，低通滤波器的作用就是得到 的部分。如下图所示： 我们将这个过程称为一次半子带滤波。 下采样与上采样 我们定义一个N倍下采样过程：将采样点N倍稀释。如下，就是一个2倍下采样过程，将采样点稀释2倍，即：每2个点采样数据点，就去除一个点。 N倍上采样过程：将采样点数量增加N倍。一般通过补0，或者插值的方法实现上采样。 离散小波分解 我们将一次半子带滤波+一次2倍下采样称为一层小波分解。如下图所示，图中的“箭头+2”表示一次2倍下采样。 假设原采样信号有 N 个点，信号最高频率为 （根据采样定律， 为采样频率的一半）。 经过一次高通滤波后，得到了 的部分，也是 N 个点，再经过一次2倍下采样，变成了 /fracN2/frac{N}{2}/fracN2 个点，我们将这/fracN2/frac{N}{2}/fracN2个点称为小波分解的高频系数（为什么叫作系数会在后面解释）。 经过一次低通滤波后，得到了 的部分，也是 N 个点，再经过一次2倍下采样，变成了 /fracN2/frac{N}{2}/fracN2 个点，我们将这/fracN2/frac{N}{2}/fracN2个点称为小波分解的低频系数。 也就是说，经过一层小波分解的信号，它的总长度加起来，还是 N ，是不变的。 现在，我们已经对 个点的原信号进行了第一层小波分解，得到了个点的高频系数和 个点的低频系数。 那么，我们保持 个点的高频系数不变，把 个点的低频系数作为信号，再进行一次小波分解。于是可以得到 个点的高频系数和 个点的低频系数。 这个过程被称为**第2层小波分解。**我们验证一下，经过2层小波分解的信号，它的总长度加起来，还是N ，是不变的。 依此类推，我们可以进行第三层，第四层小波分解，如图所示，直到第 层小波分解。在第 层小波分解，由于不断的下采样，低频系数和高频系数都只剩1个数了，小波分解无法进行下去了。 因此，小波分解的原始信号个数一般也需要是2的幂次。不过，在各种数学计算软件里，如果输入不是2的幂次，它会自动帮你补零到2的幂次。 我们取4层小波分解的结果来看一下。 在频域上，我们得到的是 ，，，，频域区间的系数。 在时域上，由于不断的2倍下采样，不断地丢弃数据，所以最后一层分解得到的，的时域分辨率最差，第一层分解保留的 时域分辨率最好。 那么，我们得到的分辨率就是这样子的： 这，不就是上一篇文章我们讲过的小波变换得到的动态分辨率吗？ 是的！这就是离散小波变换的快速算法之一——Wallet算法，通过不断的半子带滤波和下采样，控制不同频率成分的频域分辨率，进而达到动态分辨率。 最后，用一张比较经典的图，再来演示一下小波分解的过程。 为采样信号的最高频率。 代表高通滤波器， 代表低通滤波器，“箭头+2”表示2倍下采样。 图源：THE WAVELET TUTORIAL 再来举个例子形象地说明一下DWT的使用吧。 希望对于一个采样率为1000HZ的非稳态信号进行小波分解，下图为包含了256个采样点（即256ms）的原始采样信号。 1、首先，选择小波分解的层次。 可以根据对最低频率区间的要求来选择小波分解的层数。比如，我之前做项目的时候，采样率为1000HZ，那么信号的最高频率为 。我认为对于频率低于20HZ的成分，不需要再进一步区分了。因此，我选择５层小波分解，得到的最低一层的频率区间为 ，即为 ，这就够用了。 2、接下来，进行5层小波分解，得到小波分解系数。 如下图中，图1依然是原始采样信号 ，图2到图6为第1层到第5层小波分解的高频系数，图7为第5层小波分解的低频系数。如图所示，这些小波分解系数对应着不同的频率区间。 这就是DWT了，又称为小波分解。 这里提一下，小波分解是可逆的，即可以通过不同频率区间的小波分解系数进行重构，得到不同频率区间的重构信号。 3、所以，最后，进行小波重构，得到重构信号。 如下图中，图1依然是原始采样信号，图2到图7为通过不同频率区间的小波系数进行重构，得到的重构信号。将图2到图7加起来就可以得到重构原始信号，其和原始采样信号的误差称为重构误差。 3、Wallet算法背后的数学原理简介 这一部分主要是为了解答上一部分中的两个问题。 1、在上一部分，我们“假设可以通过小波母函数构造得到两个滤波器”，那么，怎么得到刚好可以具有以上特性的滤波器呢？ 2、在上一部分，我们将小波分解之后的结果称为“系数”，那么，为什么称为系数呢？ 先说一下，这部分我不是弄得非常懂，毕竟我只是个做工程的本科生，不是做数学的大佬。我凭自己的理解写一写大概，并推荐了两篇个人觉得讲得很好的回答。 我们用Haar小波做例子。 首先，介绍一个Haar尺度函数（又称为父小波），记为 ， ，如下图。 通过Haar尺度函数 ，可以得到Haar母小波 ， ，如下图。 现在，对于一个 N 点的原始采样信号，如果我们可以用 N 个做了时域平移的Haar尺度函数和 N 个做了时域平移的Haar母小波，来逼近原信号，就可以得到用 N 个Haar尺度函数的系数和 N 个Haar母小波的系数。 从直观上看，Haar尺度函数只是一条线，而Haar母小波则是一个波。所以，Haar母小波所能表示出来的信息应该更加细致。因此，N 个Haar母小波组合起来，应该代表的是原始信号的细节部分，也就是高频部分；N 个Haar尺度函数组合起来，代表的是原始信号的粗略部分，也就是低频部分。 我们将N 个Haar母小波的系数称为高频系数，将N 个Haar尺度函数的系数称为低频系数。 所以，DWT的滤波功能，是通过利用尺度函数和母小波重构信号，获取重构系数来获得的，这已经定性地解决了本部分提出的问题。 关于DWT背后的数学原理，推荐两篇回答： https://zhuanlan.zhihu.com/p/28575472 https://zhuanlan.zhihu.com/p/44217268 最后，由于DWT分解得到的是高频系数和低频系数，也就是用尺度函数以及母小波表示原信号的时候的一些重构系数，所以通过重构系数可以重构该信号，这被称为**小波分解的重构。**这也说明了小波分解是可逆的。 小波变换 小波变换的主旨：傅里叶变换将信号分解成为正弦波的叠加，傅里叶变换将信号分解成为正弦波的叠加。因此，如果要准确分析带突变的信号或图像，必须采用在时域和频域都含有定位信息的新方法 小波是一种快速衰减的、零均值的波形震荡,不像永远震荡的正弦波，小波持续的时间是有限的 中心频率: 尺度系数和频率之间是常系数倒数关系 较大的尺度系数会拉伸小波，对应的可表示低频 较小的尺度系数会压缩小波，对应的可表示高频 拉伸的小波可以捕捉信号中慢变的成分 而压缩的小波可以有效捕捉突变 连续小波、离散小波 他们的区别就是尺度缩放或者位移的方式不同","categories":[],"tags":[{"name":"信号处理","slug":"信号处理","permalink":"https://nymrli.top/tags/信号处理/"}]},{"title":"Vim记忆","slug":"Vim记忆","date":"2019-07-26T02:34:34.000Z","updated":"2019-09-15T08:07:31.012Z","comments":true,"path":"2019/07/26/Vim记忆/","link":"","permalink":"https://nymrli.top/2019/07/26/Vim记忆/","excerpt":"","text":"VIM记忆技巧 增 i(insert) I最前面insert a(append) A最后面append o(open a line)往下开启一行 O往上开启一行 删 d（delete） dw（delet word） dd（删除一行） x（删除一个字符） 拓展 diw(delete inner word) daw(delete around word) 改 c（change） ciw（change inner word） ci&quot;(change inner &quot;) ct）修改到右括号 查 fs(find s) 跳到本行第一个s字符 /往后查找,如/xxx 全文搜索xxx ;查找下一个 ?往前查找 移动 h← j↓ k↑ l→ w(word)往后跳一个单词 b(back word)往前返回一个单词 以空格为界区分单词 行间跳转 :18 跳转到第18行 18G 跳转到第18行 行内跳转: 0行首 $行尾 ctrl+o返回上一个位置 G文件结尾 gg文件开头 ctrl+f(forward)往后翻页 ctrl+u(upward)往前翻页 vim安装插件 修改配置 123456789101112131415161718set numberset history=1000set background=darksyntax onset autoindentset smartindentset tabstop=4set shiftwidth=4set showmatchset guioptions-=Tset vb t_vb=set rulerset nohlsset incsearchcall plug#begin() Plug &apos;flazz/vim-colorschemes&apos;call plug#end() 最后进入vim执行 输入:PluginInstall 便可自动安装 要卸载插件，先在.vimrc中注释或删除对应插件配置信息，然后在vim中执行 :PluginClean便可卸载对应插件 批量更新，只需执行:PluginUpdate","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"Docker使用","slug":"Docker使用","date":"2019-07-25T02:58:19.000Z","updated":"2020-04-24T15:37:43.403Z","comments":true,"path":"2019/07/25/Docker使用/","link":"","permalink":"https://nymrli.top/2019/07/25/Docker使用/","excerpt":"","text":"Docker学习 轻部署,省成本,易迁移 docker和虚拟机VM的区别 一、本质上的区别： VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用； Container(Docker容器)，在宿主机器、宿主机器操作系统上创建Docker引擎，在引擎的基础上再安装应用。 那么问题来了，没有操作系统，怎么运行程序？ 可以在Docker中创建一个ubuntu的镜像文件，这样就能将ubuntu系统集成到Docker中，运行的应用就都是ubuntu的应用。 二、使用上的区别： Size: 虚拟机ubuntu大小为:24.1GB Docker中镜像文件占用内存: 81.2MB Startup： Docker在宿主机器的操作系统上创建Docker引擎，直接在宿主主机的操作系统上调用硬件资源，而不是虚拟化操作系统和硬件资源，所以操作速度快。 这个其实安装一个ubuntu的虚拟机和拉取一个Docker的ubuntu镜像文件，运行一下就知道了，区别很明显，虚拟机开一下大概得2分多钟，而Docker只需要2秒钟。 宿主机、镜像与容器 宿主机器: 运行docker的机器 镜像:不可以修改内容 容器:可以修改能内容,相当于虚拟机,默认情况下彼此相互独立（容器之间可以通信） △.可以依据镜像来创建容器,也可以封装容器为一个镜像,即容器&lt;===&gt;镜像 Docker命令 搜索镜像: docker search python 下载镜像: docker pull NAME 创新容器: docker run -tid (--name xxx) IMAGE ID ti表示以交互的形式创建容器，d表示不进入 -d, --detach=false， 指定容器运行于前台还是后台，默认为false -i, --interactive=false， 打开STDIN，用于控制台交互 -t, --tty=false， 分配tty设备，该可以支持终端登录，默认为false 运行容器: docker start CONTAINER_ID 进入容器： docker attach CONTAINER_ID 进入容器前得前运行容器 退出容器： ctrl + p + q , 以ctrl + z 、exit将会终止容器运行 封装容器为镜像: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] 1234-a :提交的镜像作者；-c :使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停。 容器通信-创建子节点链接中心节点: docker run -tid (--name xxx) (--link CONTAINER_NAMES) IMAGE ID 查看容器ip: cat /ect/hosts 123456789root@b68943564e76:/# cat /etc/hosts 127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.2 test 4e02c004539e172.17.0.3 b68943564e76 ▲初次使用, ifconfig使用无效,ping也无效,原因如下 我创建的容器是拉取的Base镜像，而因为用Docker拉取的Base镜像如Centos和Ubuntu的话都是最简版本，不包含Ping工具，而对Docker进行Docker network和Docker链接操作时往往要用到Ping工具测试两个容器间的网络，此时就要用到Ping工具了，下面是Ubuntu下安装Ping工具的命令：apt-get update &amp;&amp; apt-get install iputils-ping、安装ifconfig工具:apt install net-tools 从容器里面拷文件到宿主机 docker cp 容器名：要拷贝的文件在容器里面的路径 要拷贝到宿主机的相应路径 宿主机上执行:$ docker cp testtomcat：/usr/local/tomcat/webapps/test/js/test.js /opt 从宿主机拷文件到docker容器里面 docker cp 要拷贝的文件路径 容器名：要拷贝到容器里面对应的路径 宿主机上执行$ docker cp requirements.txt apptest:/app ▲注:容器NAME可以通过docker ps命令查看 Dockerfile指令 Dockerfile文件D一定要大写 $ docker build -t=&quot;dormanctpress/df_test2&quot; . .为Dockerfile的路径 1.FROM &lt;image&gt;:&lt;tag&gt; 2.MAINTAINER 3.RUN 镜像构建中运行的命令 4.EXPOSE 如果是端口的话，只是声明会使用xx端口,但是实际使用时还是需要run -p xx $ docker build -t=&quot;dormanctpress/df_test2&quot; . 设置环境变量 CMD 在容器运行时运行的默认命令(命令行中添加的命令可以代替掉Dokcerfile中写的CMD指令) 每个Dockerfile只能够包含一个CMD，多个CMD 只有最后一个能有效 定义的三种方式 CMD这个会当做/bin/sh-c“cmd”来执行 CMD[“executable&quot;，“arg1”，“arg2”] 一定要双引号 CMD[“arg1&quot;，“arg2”]，这个时候CMD作为ENTRYPOINT的参数 ENTRYPOINT 每个Dockerfile只能够包含一个ENTRYPOINI，多个ENTRYPOINT只有最后一个能有效 不会像CMD命令一样被覆盖,除非使用`` 当定义了ENTRYPOINT后,CMD将被作为参数使用。如果定义了CMD，那么docker run -t test/osf2 xxxx后面即xxxx的内容全会被当做参数传递ENTRYPOINT 组合使用ENTRYPOINT和CMD: ENTRYPOINT指定命令,CMD指定默认参数 ADD&amp;COPY 共同点 ADD&amp;COPY的源必须在context路径下 当在源代码构建的方式下，可以通过ADD和COPY的方式，把Host上的文件或者目录复制到Image ADD 包含类似tar解压的功能 当src为网络URL的情况下，ADD指令可以把它下载到Dest的指定位置，这个在任何build的方式下都可以Work COPY 如果单纯复制文件,Docker推荐COPY ADD&amp;COPY的源必须在context路径下 当在源代码构建的方式下，可以通过ADD和COPY的方式，把Host上的文件或者目录复制到Image VOLUME[’/data’] 设置数据卷 WORKDIR /path/to/workdir 一般使用绝对路径 ENV 用来设置环境变量，后续的RUN可以使用它所创建的环境变量。 当创建基于该镜像的Container的时候，会自动拥有设置的环境变量 USER daemon 指定UID或者username，来决定运行RUN指令的用户 如果不指定,则默认root ONBUILD 触发器 dockerfile构建过程 从基础镜像运行一个容器 执行一条指令，对容器做出修改 执行类似docker commit的操作，提交一个新的镜像层 再基于刚提交的镜像运行一个新容器 执行Dockerfile中的下一条指令，直至所有指令执行完毕 使用中间层镜像进行调试 查找错误 Dockerfile 镜像缓存 构建缓存：将之前的镜像缓存 不使用缓存docker build --no-cache 查看镜像构建的过程 查看构建过程:docker history xxx/yyy 数据卷 sudo docker run -v ~/container_data:/data -it ubuntu /bin/bash 参数说明:使用-v选项,第一个参数为宿主机目录,:后的目录为在容器中使用的目录(挂载);ubuntu为镜像 查看容器是否挂载了数据卷 docker inspect CONTAINER_ID可以查看容器是否挂载了数据卷 给数据卷增加权限 sudo docker run -v ~/datavolume:/data:ro -it ubuntu/bin/bash ro是read-only 数据卷容器 命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器 挂载数据卷容器的方法 docker run--volumes-from [CONTAINER NAME] MySQL通信 12345678910&gt;&gt;&gt; can't connect to MySQL server on '172.17.0.8'(111)$ vim /etc/mvsal/my.cnf # 将bind-address=127.0.0.1注释掉&gt;&gt;&gt; Host '2eaf92ef2ff6'is not allowed to connect to this MySQL server$ create user \"weiwei\"@\"%\"identified by\"weijc7789\"# 创建用户$ grant create, select, update, delete, insert on *.* to weiwei;# 增添权限$ mysq1-h 172.17.0.8-u weiwei-p# 链接 redis通信 1234567$ redis-cli -h 172.17.0.8&gt;&gt;&gt; Could not connect to Redis at 172.17.0.8:6379:Connection refused$ vim /etc/redis /redis.conf# 将bind-address=127.0.0.1注释掉# 如果修改后/ect/init.d/redis-server restart后还是链接不了,重启进入容器$ redis-cli-h 172.17.0.8-p 6379 一条命令实现停用并删除容器： 1docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq) 一条命令删除所有镜像： 1docker rmi `docker images -q` 一条命令删除创建失败的镜像: docker images | sed -n '2p' | awk '{print$3}' | xargs docker rmi 附录 Dockerfile RUN，CMD，ENTRYPOINT命令区别 RUN命令执行命令并创建新的镜像层，通常用于安装软件包 CMD命令设置容器启动后默认执行的命令及其参数，但CMD设置的命令能够被docker run命令后面的命令行参数替换 ENTRYPOINT配置容器启动时的执行命令（不会被忽略，一定会被执行，即使运行 docker run时指定了其他命令） Shell格式和Exec格式运行命令 我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式： Shell格式： 。例如：apt-get install python3 多条命令用&amp;&amp;链接 Exec格式： [“executable”, “param1”, “param2”, …]。例如： [“apt-get”, “install”, “python3”] CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。 总结 使用 RUN 指令安装应用和软件包，构建镜像。 如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。 如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。 Docker 运行python flask的web程序 1创建镜像 1.1 ubuntu16.04+python3.6 18.04卡在了PPA环节,并且git安装也没安装上,后来使用了dockerHub上搜素到的github仓库中的16.04 Xenial就解决了。 注：镜像TAG版本需要到dockerHub上才能查看，最初下载成18.04就是因为这个原因被坑了 18.04PPA问题: aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Ubuntu/bionic意思是18.04该PPA没有资源.bionic是版本代号,如16.04的 Xenial ⑴使用下载好的Xenial的Dockerfile进行创建镜像docker run 1604ubuntu . 为了使用国内源用阿里云，先编辑一个sources.list，放在dokcerfile同目录下，作为docker创建镜像时的上下文。 1234567891011121314151617deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse ⑵根据官方的镜像来编写自己的Dockerfile创建具有工具的Ubuntu1604 涉及交互式选择项（如下），docker build的时候会报错。设置 DEBIAN_FRONTEND=noninteractive 1234567891011121314151617181920212223242526272829303132333435FROM 1604ubuntuMAINTAINER mrli#用ubuntu国内源替换默认源RUN rm /etc/apt/sources.listCOPY sources.list /etc/apt/sources.list#安装python3.6必要的包。源镜像太精简了，ip ifconfig之类的都没有。后续安装python pip也需要一些。但是build_essential似乎不必须，先去了。如果后面安装numpy之类需要gcc了，再加上RUN apt update#RUN apt upgradeRUN apt install -y apt-utils apt-transport-https vim iproute2 net-tools ca-certificates curl build-essential wget python-software-properties software-properties-common psmisc#安装python3.6 来自第三方RUN add-apt-repository ppa:jonathonf/python-3.6RUN apt updateRUN apt install -y python3.6RUN apt install -y python3.6-devRUN apt install -y python3.6-venv#为3.6安装pipRUN wget https://bootstrap.pypa.io/get-pip.pyRUN python3.6 get-pip.py#设置默认python为python3RUN update-alternatives --install /usr/bin/python python /usr/bin/python2 100RUN update-alternatives --install /usr/bin/python python /usr/bin/python3 150#和自带的3.5共存,设置python3默认为3.6#RUN update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.5 1RUN update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.6 2# 更新配置RUN update-alternatives --config python3#print()时在控制台正常显示中文ENV PYTHONIOENCODING=utf-8 在dockerfile所在路径下执行，建立image 1docker build -t uos:1604 . 因为开头几步用了国内源，所以非常快。 1.2 开发环境 再建一个dockerfile，开头使用刚才建立的镜像uos1604 123456789101112131415161718192021222324252627FROM uos:1604MAINTAINER mrli#代码复制过来后的路径RUN mkdir /app# 指定容器启动时执行的命令都在app目录下执行WORKDIR /app# 将本地app目录下的内容拷贝到容器的app目录下COPY ./app/ /app/# 安装nginxRUN apt -y install nginx mysql-server RUN /etc/init.d/nginx start# 替换nginx的配置RUN rm /etc/nginx/sites-enabled/defaultRUN cp nginx.conf /etc/nginx/sites-enabled/nginx.confRUN pip3 install uwsgi#安装需要的python库# 启动nginx和uwsgi#ENTRYPOINT pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple some-package --no-cache-dir &amp;&amp; service nginx restart &amp;&amp; uwsgi --ini uwsgi.ini# 为了保证能之后进入所以最后一个命令为/bin/shENTRYPOINT pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple some-package --no-cache-dir &amp;&amp; service nginx restart &amp;&amp; uwsgi --ini uwsgi.ini &amp; &amp;&amp; /bin/sh 创建uflask镜像:docker build -t uflask . 根据镜像创建运行容器:docker run -tid -p 12345:80 flaskdemo IMAGE_ID 此时就可以通过VPS的IP地址:宿主机端口访问这个应用程序 查看日志:docker logs 应用名(NAMES)如docker logs flaskdemo 关于mysql的建议 mysql建议作为单独容器来跑数据库,然后远程连接数据库.或是使用数据卷 1234567# # 搜索# docker search mysql# 拉取# docker pull mysql:5.7#运行# docker run --name mysql5.7 -e MYSQL_ROOT_PASSWORD=123456 -p 3307:3306 -d mysql:5.7 2启动容器(转) Docker 一种开源容器应用，供开发者打包自己的开发环境，可以任意移植 docker-compose 一种管理多个Docker容器的工具，可以简化我们启动容器的各种命令 2.1手动敲docker命令 先试试用docker命令行启动容器： 1docker run --name quotation_api -itd -p 5000:5000 -v /home/quotation:/code quotation_dev:latest 用到的参数分别是 –name为容器命名； -itd 输入输出终端，后台运行 -p host端口:容器端口 将宿主机5000端口的请求转发到容器5000端口,用5000是flask默认 -v host路径:容器内路径(挂载数据卷) quotation_dev:latest 最后是使用的镜像名（前面刚用dockerfile build出来的） 然后进入容器 1docker attach quotation_api 用python3 main.py启动flask，OK。 这样flask运行在docker里了。 在host改代码，可以看见docker的控制台在更新，和在host一样了。(使用数据卷) 2.2使用dock-compose 如果没有安装先进行安装apt install docker-compose dock-compose用来管理多个container的运行，特别适合1个host上跑多个container的情况。 得天独厚，docker官网上dock-compose的gettingstarted文档就是flask的(说明flask+docker代表了先进生产力的前进方向O Yeah！),看完了基本就能用了。 dock-compose采用yaml作为配置文件。查了一下，yaml参考了xml和json，以及python的语法，采用了python之缩进，无XML之标记，无json之括号，无字符串之引号。特别适合作为配置文件用。 建立docker-compose.yaml文件(无镜像,但有dockerfile)： 123456version: &apos;2&apos; # 表示该 Docker-Compose 文件使用的是 Version 2 fileservices: docker-demo: # 指定服务名称 build: . # 指定 Dockerfile 所在路径 ports: # 指定端口映射 - &quot;9000:8761&quot; 建立docker-compose.yaml文件(已有镜像)： 12345678910version: &quot;3&quot;services: quotation_api: # 指定服务名称 image: quotation_dev:latest # 指定镜像 volumes: # 选择数据卷 - /home/quotation:/code ports: # 端口映射 - &quot;5000:5000&quot; command: python3 main.py # 执行命令 基本对应手动敲的docker命令，最后还省了敲python3 main.py。 当然如果是部署，这句可以用CMD 写进Dockfile。但是开发过程，文件名之类的会改变，比如最终部署运行用可能是gunicorn+wsgi.py，所以还是写在dockerfile外面比较方便 运行，在控制台执行：docker-compose up、docker-compose up -d // 后台启动并运行容器 docker-compose更多介绍 坑点记录 docker容器启动后马上退出解决方案 dokcerfile中的最后一个命令不能在后台执行,不然会启动后马上退出 原因 Docker容器同时只能管理一个进程，如果这个进程退出那么容器也就退出了，但这不表示容器只能运行一个进程(其他进程可在后台运行)，但是要使容器不退出必须有一个前台执行的进程。 解决方法： 脚本中最后一个进程一定要用前台运行方式即在进程最后不加&amp;(&amp;表示后台运行)，否则容器会退出。 如何正确的使用docker attach Q:由于执行着uwsgi --ini uwsig.ini命令,用户就无法直接进入到容器中去，docker attach CONTAINER_id 就会一直卡着。 A: attach早已过时了，可用: docker exec -it containerID /bin/bash，一开始使用的是/bin/sh然后还是一直卡住.但是/bin/bash是可以的 附Uuntu版本代号: 版本号 代号 发布时间 18.04 Bionic Beaver（仿生海狸） 即将发布2018年4月(LTS) 17.10 Artful Aardvark(机灵的土豚) 2017年10月 16.04 LTS Xenial Xerus 好客的非洲地松鼠 即将发布 2016/4 15.10 Wily Werewolf 狡诈的狼人 2015/10/22 15.04 Vivid Vervet 活泼的小猴 2015/04/23 14.10 Utopic Unicorn 乌托邦独角兽 2014/10/23 14.04 LTS Trusty Tahr 值得信赖的塔尔羊 2014/04/18 13.10 Saucy Salamander 活泼的蝾螈 2013/10/17 13.04 Raring Ringtail 铆劲浣熊 2013/04/25 12.10 Quantal Quetzal 缤纷的绿咬鹃 2012/10/18 12.04 LTS Precise Pangolin 精准的穿山甲 2012/04/26 11.10 Oneiric Ocelot 有梦的虎猫 2011/10/13 11.04 Unity成为默认桌面环境 Natty Narwhal 敏捷的独角鲸 2011/04/28 10.10 Maverick Meerkat 标新立异的的狐獴 2010/10/10 10.04 LTS Lucid Lynx 清醒的猞猁 2010/04/29 9.10 Karmic Koala 幸运的无尾熊 2009/10/29 9.04 Jaunty Jackalope 活泼的兔子 2009/04/23 8.10 Intrepid Ibex 无畏的高地山羊 2008/10/30 8.06 官方查不到此版本发布信息 Haughty Husky 骄傲的哈士奇 2008/06/07 8.04 LTS Hardy Heron 坚强的苍鹭 2008/04/24 7.10 Gutsy Gibbon 勇敢的长臂猿 2007/10/18 7.04 Feisty Fawn 烦躁不安的小鹿 2007/04/19 6.10 Edgy Eft 尖利的小蜥蜴 2006/10/26 6.06 LTS Dapper Drake 整洁的公鸭 2006/06/01 5.10 Breezy Badger 活泼的獾 2005/10/13 5.04 Hoary Hedgehog 白发得刺猬 2005/04/08 **4.10 **初始发布版本 Warty Warthog 多疣的疣猪 2004/10/20 docker-compose使用[转] docker-compose常见命令 ps：列出所有运行容器 1docker-compose ps logs：查看服务日志输出 1docker-compose logs port：打印绑定的公共端口，下面命令可以输出 eureka 服务 8761 端口所绑定的公共端口 1docker-compose port eureka 8761 build：构建或者重新构建服务 1docker-compose build start：启动指定服务已存在的容器 1docker-compose start eureka stop：停止已运行的服务的容器 1docker-compose stop eureka rm：删除指定服务的容器 1docker-compose rm eureka up：构建、启动容器 1docker-compose up kill：通过发送 SIGKILL 信号来停止指定服务的容器 1docker-compose kill eureka pull：下载服务镜像 scale：设置指定服务运气容器的个数，以 service=num 形式指定 1docker-compose scale user=3 movie=3 run：在一个服务上执行一个命令 1docker-compose run web bash docker-compose.yml 字段含义 version：指定 docker-compose.yml 文件的写法格式 services：多个容器集合 build：配置构建时，Compose 会利用它自动构建镜像，该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数 1234567build: ./dir---------------build: context: ./dir dockerfile: Dockerfile args: buildno: 1 command：覆盖容器启动后默认执行的命令 123command: bundle exec thin -p 3000----------------------------------command: [bundle,exec,thin,-p,3000] dns：配置 dns 服务器，可以是一个值或列表 12345dns: 8.8.8.8------------dns: - 8.8.8.8 - 9.9.9.9 dns_search：配置 DNS 搜索域，可以是一个值或列表 12345dns_search: example.com------------------------dns_search: - dc1.example.com - dc2.example.com environment：环境变量配置，可以用数组或字典两种方式 1234567environment: RACK_ENV: development SHOW: &apos;ture&apos;-------------------------environment: - RACK_ENV=development - SHOW=ture env_file：从文件中获取环境变量，可以指定一个文件路径或路径列表，其优先级低于 environment 指定的环境变量 1234env_file: .env---------------env_file: - ./common.env expose：暴露端口，只将端口暴露给连接的服务，而不暴露给主机 123expose: - &quot;3000&quot; - &quot;8000&quot; image：指定服务所使用的镜像 1image: java network_mode：设置网络模式 12345network_mode: &quot;bridge&quot;network_mode: &quot;host&quot;network_mode: &quot;none&quot;network_mode: &quot;service:[service name]&quot;network_mode: &quot;container:[container name/id]&quot; ports：对外暴露的端口定义，和 expose 对应 123ports: # 暴露端口信息 - &quot;宿主机端口:容器暴露端口&quot;- &quot;8763:8763&quot;- &quot;8763:8763&quot; links：将指定容器连接到当前连接，可以设置别名，避免ip方式导致的容器重启动态改变的无法连接情况 12links: # 指定服务名称:别名 - docker-compose-eureka-server:compose-eureka volumes：卷挂载路径 123volumes: - /lib - /var logs：日志输出信息 1234--no-color 单色输出，不显示其他颜.-f, --follow 跟踪日志输出，就是可以实时查看日志-t, --timestamps 显示时间戳--tail 从日志的结尾显示，--tail=200 更新容器 当服务的配置发生更改时，可使用 docker-compose up 命令更新配置 此时，Compose 会删除旧容器并创建新容器，新容器会以不同的 IP 地址加入网络，名称保持不变，任何指向旧容起的连接都会被关闭，重新找到新容器并连接上去 links 服务之间可以使用服务名称相互访问，links 允许定义一个别名，从而使用该别名访问其它服务 12345678version: &apos;2&apos;services: web: build: . links: - &quot;db:database&quot; db: image: postgres 这样 Web 服务就可以使用 db 或 database 作为 hostname 访问 db 服务了 docker stop containerID，以后再重新启动时报错 1Error response from daemon: driver failed programming external connectivity on endpoint app (3c0c01ac6b42b7a420644fc2b4debfbbcc0e1d2e74e6294155c28aca82f794c4): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 12345 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name. A: 重启docker即可：systemctl restart docker 再开启你的容器： docker run xxxx或docker start xxx 查看docker容器的运行日志 docker logs containerID docker端口映射到宿主机后外网仍无法访问容器的web A： 1234567891011121314# 解决办法：$ sudo vi /etc/sysctl.conf或者$ sudo vi /usr/lib/sysctl.d/00-system.conf# 添加如下代码：net.ipv4.ip_forward=1重启network服务$ sudo systemctl restart network查看是否修改成功$ sudo sysctl net.ipv4.ip_forward#如果返回为“net.ipv4.ip_forward = 1”则表示成功了 安装 由于ubuntu维护的docker版本比较老，所以建议使用docker自己维护的版本 法一： 较为麻烦 123456789apt-get updateapt-get install-y apt-transport-httpsecho deb https://get.docker.com/ubuntu docker main&gt;/etc/apt/sources.list.d/docker.list# 添加仓库的key$apt-key adv--keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9#安装$ apt-get update$ apt-get install -y lxc-docker 法二： docker简易安装方法-&gt;脚本 123456# 如果没有安装curl，先安装curl$ sudo apt-get install -y curl# 淘汰!$ curl -sSL https://get.docker.com/ubuntu/ | sudo sh# 推荐用wget$ wget -qO- https://get.docker.com/ | sh","categories":[],"tags":[{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"Python中的正则匹配","slug":"Python中的正则匹配","date":"2019-07-25T01:50:19.000Z","updated":"2019-09-15T08:07:30.982Z","comments":true,"path":"2019/07/25/Python中的正则匹配/","link":"","permalink":"https://nymrli.top/2019/07/25/Python中的正则匹配/","excerpt":"","text":"Python中的正则匹配 虽然正则早就会用了,但是有些使用方法老是忘记,因此还是写篇记录一下 特殊字符 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\’ 匹配 “”，而 ‘(’ 则匹配 “(”。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 特殊字符 所谓特殊字符，就是一些有特殊含义的字符，如上面说的 runoo*b 中的 *****，简单的说就是表示任何字符串的意思。如果要查找字符串中的 ***** 符号，则需要对 ***** 进行转义，即在其前加一个 ***: runo*ob 匹配 runoob。 许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符&quot;转义&quot;，即，将反斜杠字符**** 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\’ 匹配 “”，而 ‘(’ 则匹配 “(”。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 限定符 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。‘o{1,}’ 等价于 ‘o+’。‘o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}” 将匹配 “fooooood” 中的前三个 o。‘o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 定位符 定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 正则表达式的定位符有： 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 捕获与非捕获 选择 用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。 其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 反向引用 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例： 正则 ?&lt;= 和 ?= 用法](https://www.cnblogs.com/whaozl/p/5462865.html) 方法1： 匹配，捕获(存储) 正则表达式：(?&lt;=(href=&quot;)).{1,200}(?=(&quot;&gt;)) 解释： (?&lt;=(href=&quot;)) 表示 匹配以(href=&quot;)开头的字符串，并且**捕获(存储)**到分组中 (?=(&quot;&gt;)) 表示 匹配以(&quot;&gt;)结尾的字符串，并且**捕获(存储)**到分组中 方法2： 匹配，不捕获(不存储) 正则表达式：(?&lt;=(?:href=&quot;)).{1,200}(?=(?:&quot;&gt;)) ​ 解释：(?&lt;=(**?:href=&quot;)) 表示 匹配以(href=&quot;)开头的字符串，并且不捕获(不存储)**到分组中 ​ (?=(?:&quot;&gt;)) 表示 匹配以(&quot;&gt;)结尾的字符串，并且**不捕获(不存储)**到分组中 (?:pattern) 非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 (?=pattern) 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。 (?&lt;=pattern) 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题 分组语法 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name’exp) (?:exp) 匹配exp,不捕获匹配的文本 位置指定 (?=exp) 匹配exp前面的位置 (?&lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的组不对正则表达式的处理产生任何影响，只是为了提供让人阅读注释 我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面。 位置指定 接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们用于指定一个位置，就像\\b,^,$那样，因此它们也被称为零宽断言。最好还是拿例子来说明吧： (?=exp)也叫零宽先行断言，它匹配文本中的某些位置，这些位置的后面能匹配给定的后缀exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如果在查找I’m singing while you’re dancing.时，它会匹配sing和danc。 (?&lt;=exp)也叫零宽后行断言，它匹配文本中的某些位置，这些位置的前面能给定的前缀匹配exp。比如(?&lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。 假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\\d)\\d{3})*\\b。请仔细分析这个表达式，它可能不像你第一眼看出来的那么简单。 下面这个例子同时使用了前缀和后缀：(?&lt;=\\s)\\d+(?=\\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。 附录: 常见正则表达式 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、“XXXX-XXXXXXXX”、“XXX-XXXXXXX”、“XXX-XXXXXXXX”、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：[1][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：[2]\\w{5,17}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ a-zA-Z ↩︎ a-zA-Z ↩︎","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"利用wireshark抓取TCP的整个过程分析[转]","slug":"利用wireshark抓取TCP的整个过程分析","date":"2019-07-24T07:51:29.000Z","updated":"2019-09-15T08:07:31.030Z","comments":true,"path":"2019/07/24/利用wireshark抓取TCP的整个过程分析/","link":"","permalink":"https://nymrli.top/2019/07/24/利用wireshark抓取TCP的整个过程分析/","excerpt":"","text":"原文地址：https://www.cnblogs.com/NickQ/p/9226579.html 最近，已经很久都没有更新博客了。看看时间，想想自己做了哪些事情，突然发现自己真的是太贪心，到头来却一个都没搞好。手头的嵌入式都还没学出名堂，竟然还想着学FPGA,物联网，机器学习。然而，遇到新奇的事物，就会控制不住的去想，去找资料，实际上只是逃避遇到的问题，不想去解决而已。。最后的结果就是手头的活堆起来了，然后花大把整块的时间解决。真的是讨厌现在的自己。 以后还是慢慢记录吧，不管做了什么，都慢慢尝试积累。。其他的东西，像FPGA，机器学习什么的，让他随风去吧，用到啥学啥。其他的当看客，了解了解就好。 这是计算机网络的一次作业，学习抓取TCP/IP建立连接和断开连接的过程，以下是正文： 步骤： 首先尝试抓百度，腾讯等网络连接，发现会有许多问题需要考虑，断开连接操作不好操作，且数据冗杂不利于学习。 所以借助手机和电脑完成此次过程，操作如下： 1、在手机端，安装TCP测试工具，开启TCP监听，端口8088； 2、打开wireshark监听WIFI网卡。 3、打开电脑端TCP测试客户端，连接TCP服务器。 此处，我的手机IP为192.168.255.5，端口8088；电脑的IP地址为192.168.255.6。 4、通过电脑客户端，发送两次信息到手机。 5、通过手机客户端，发送两次信息到电脑。 6、断开连接。 7、通过ip.addr eq 192.168.255.5 and ip.addr eq 192.168.255.6 and tcp过滤掉其他报文。 至于wireshark过滤的语法，可以参考其他的一些博文：https://blog.csdn.net/wojiaopanpan/article/details/69944970 协议及过程分析： TCP三次握手：如下图中蓝色方框所示。 TCP握手协议在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；如下图中报文No.7 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；如下图中报文No.8 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据。如下图中报文No.9 TCP四次挥手：如上图中红色方框所示。 注：此处，由于先断开的服务器，所以手机服务器是客户端A。 第一次挥手：客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 如图中报文No.255 第二次挥手：服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。如图中报文No.256 第三次挥手：服务器B关闭与客户端A的连接，发送一个FIN给客户端A。如图中报文No.257 第四次挥手：客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。如图中报文No.258 其他: 下图是其中一帧数据解析，可以看到数据是由192.168.255.6:62643(电脑客户端)发送给192.168.255.5:8088(手机服务端）。 消息内容为：201521111083","categories":[],"tags":[{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"C++学习笔记","slug":"C-学习笔记","date":"2019-07-13T01:00:50.000Z","updated":"2019-09-15T08:07:30.924Z","comments":true,"path":"2019/07/13/C-学习笔记/","link":"","permalink":"https://nymrli.top/2019/07/13/C-学习笔记/","excerpt":"","text":"C++学习笔记 system（）就是调用（DOS）系统命令（和shell命令）。 pause ，即DOS命令集合中的暂停命令； sprintf 123456789101112#include &lt;stdio.h&gt;int main( void )&#123; char buffer[200], s[] = &quot;computer&quot;, c = &apos;l&apos;; int i = 35, j; float fp = 1.7320534f; // 格式化并打印各种数据到buffer j = sprintf( buffer, &quot; String: %s\\n&quot;, s ); // C4996 j += sprintf( buffer + j,&quot; Character: %c\\n&quot;, c ); j += sprintf( buffer + j,&quot; Integer: %d\\n&quot;, i ); j += sprintf( buffer + j,&quot; Real: %f\\n&quot;, fp ); printf( &quot;Output:\\n%s\\ncharacter count = %d\\n&quot;, buffer, j );&#125; 返回写入buffer 的字符数，出错则返回-1. 如果 buffer 或 format 是空指针，且不出错而继续，函数将返回-1 sprintf 返回以format为格式argument为内容组成的结果被写入buffer 的字节数，结束字符‘\\0’不计入内。即，如果“Hello”被写入空间足够大的buffer后，函数sprintf 返回5。 引用 声明引用： 12int a = 1;int &amp;c=a; //int &amp; c=a; △.声明引用时必须初始化 传引用参数 12void func(int&amp; a)&#123;&#125; //函数名(xxx)xxx其实是创建形参变量的过程func(b); 传指针 1void func2(int *a)&#123;&#125; 返回引用 返回值不能是局部变量（局部变量在生命期结束后会被销毁） ​ （c中生命周期结束后，立马销毁，而在python中垃圾回收机制会在判断之后不使用的情况下再销毁） func2(&amp;b); 增强的for循环: 在vc6.0中 for(int i=4;i&gt;0;i–) i的作用域为 整个外部作用域如 void main() { ​ for(int i=4;i&gt;0;i–) //作用域为整个main函数 } 而在vs中 for(int i=4;i&gt;0;i–) i的作用域为 该个for循环内 void main() { ​ for(int i=4;i&gt;0;i–) //作用域为该个for循环 } 默认参数 从右往左连续 返回值不是函数重载的条件 malloc和free 不会触发构造函数或是析构函数 new和delete 可以 类 不做特别说明，类的数据成员和成员函数都被认为是private this指针 this 是类成员函数的隐含参数，不是类的数据成员 静态成员无this指针 常函数 常函数不能修改类中的数据成员的值 析构函数和构造函数不能是常函数 常变量只能调用常函数，不能调用普通函数 常对象只能调用常函数，不能调用普通函数 静态成员 是类本身的属性，无对象时也可以直接调用Cstu::sta 静态成员函数只能调用静态数据成员 类外初始化 不需要static关键字 如： int Cstu::sta = 12; 创建数组 12a = new int[2];delete[] a; 浅拷贝和深拷贝 系统默认的为浅拷贝 有指针承运啊时得内存拷贝，所以使用深拷贝， 为了避免拷贝构造，运算符重载应该传引用 拷贝构造 何时会调用 1.新建一个对象，并将其初始化为同类现有对象 123456Cstu a;- Cstu a1(a);- Cstu a2 = a;- Cstu a3 = Cstu(a); //创建了临时对象- Cstu a4 = new Cstu(a);- △.赋值并不会发生拷贝构造 2.当程序生成对象副本时 12345678910111213141516171819202122232425262728293031- 参数是本类的常引用Cstu(const Cstu&amp;)- 普通构造函数如果空的话是不执行内容的，拷贝构造空的话是执行内容的- 默认的复制构造函数，逐个复制非静态成员的值，## 内联函数inline- 函数代码少，流程直接，调用频繁，如循环- 类内定义的都是内联函数（隐式），写inline为显性- 内联函数的定义一般写在头文件内- 只在声明位置写inline不管用，定义与声明都要有inline关键字- 空间换时间，使用频率低时速度快，频率高时，比较占用内存，主要看性价比- 递归不能是内联函数## 操作符重载------- 为了避免拷贝构造，运算符重载应该传引用或是传地址- 操作符重载必须有一个类类型的参数- =、[]、()、-&gt;必须是诚邀- 复合赋值运算符通常是成员- 改变对象状态的运算符，递增、解引用，通常是成员### 输出运算符重载:- 参数1是ostream引用，参数2是对象的常引用- 必须是类外重载，原因为1- 输出私有成员时，要用友元 void operator &lt;&lt; (ostream&amp; os,const &amp;Csty)，os &lt;&lt;st.nAge; ostream&amp; operator &lt;&lt; (ostream&amp; os,const &amp;Csty)，os &lt;&lt;st.nAge; 12345### 输入运算符重载:- 参数不匹配用ist.fail()检测- 输出=&gt; ist&gt;&gt;st.nAge &gt;&gt; st.dbHeight; istream&amp; operator &gt;&gt;(istream&amp; ist,CStu&amp; st) 1234------### 前置+ +与后置+ +重载 int operator++(Cstu* st){} =&gt;前置++ int operator++(Cstu* st,int n) =&gt;后置++ { int a =st.nage; st.nage +=1; return a; } 1234------类型转换重载 operator int()const{} //无返回值，但有return 1234△.必须在类内。▲.const## 模板 template void func(Y a) cout &lt;&lt; a &lt;&lt; endl; 12模板的具体化: temlpate &lt;&gt; void func(Node&amp; a){} 1234567891011121314151617181920212223242526&gt; 模板具体化的执行优先级高于通用的优先级，◇.注意，STL头文件没有扩展名.h------# CPP```该类接受2个参数初始化列表class CStu&#123; int a; int arr[4]; float b;//构造函数： CStu(*float c,int d*):a(2),b(2.2f),arr() #成员初始化顺序只与声明顺序有关，与此处书写顺序无关 &#123; #新增语法，arr数组全初始化为0 &#125;&#125; ▲.类必须先初始化成员变量。 ​ 。float c和int d 两个变量的作用域仅限于构造函数内.所以要想在整个类中使用该变量，就得将传入的参数初始化赋值给类中的变量。 ​ 若有多个构造函数，会执行初始化列表绑定所在的构造函数（构造函数的重载） 数组的赋值： 初始化列表arr() 构造函数中for循环赋值 memset(&amp;arr[0],0,16) △.析构函数没有重载，且不接受参数。对象声明调用周期结束时自动调用。 ▲构造函数和析构函数都必须写在public访问控制符下 malloc和new、free和delete区别 malloc不会触发构造函数，new可以 free不会触发析构函数，delete可以 This指针 指针类型为类的类型。 this不是类的成员。 this指针为成员函数的隐含参数，相当于python类中的self…(所以this指针的作用域为类内部) 常函数 CStu&#123;&#125;123456class CStu&#123; public: void show() const #在括号之后 &#123;&#125;&#125; ◆.析构函数、构造函数不能是常函数 ◆.常函数不能修改数据成员（是类的），但可以修改常函数内的变量。 ▲常函数的this指针的类型为const CStu* ★常对象(const CStu st)只能调用常函数，不能调用普通函数 静态成员 1234567class CStu&#123; static int b; public: void show() const #在括号之后 &#123;&#125;&#125; ∷不能在构造函数的初始化列表中初始化，但可以类外初始化 ∷类外初始化不用加static，而是int CStu::b = 12; ▲static受访问控制符约束。 调用方法： 12类名作用域：cout&lt;&lt; CStu::b &lt;&lt; endl;对象： ○只有静态常量整型数据才能直接在类中初始化，其他得在初始化列表或者构造函数中赋值（静态数据成员可以类外赋值），普通数据成员不能类外初始化。 ●静态成员是跟类一一对应的，跟对象无关。 静态成员函数 他是属于类的属性，不是对象的，即同一个类的所有对象共有一个（可以作为指挥类所有对象的方法） 无this指针 不能调用普通成员，只能调用静态成员 拷贝构造 public: ​ Cstu(const Cstu &amp;a){} 形式。参数是本类的常引用 何时调用： 1234567891.新建一个对象，并将其初始化为同类时：- Cstu a1(a); #a为一个Cstu对象- Cstu a2 = a; 将不会再触发构造函数。- Cstu a3 = Cstu(a); 用a来拷贝构造一个临时对象，再用这个临时对象给a3- Cstu* a4 = new Cstu(a);2.当程序生成对象副本时： 函数参数传递对象的值void fun(Cstu a)&#123;&#125; （∵当调用这个函数的时候会为这个形参生成空间） ▲有时为了效率要避免这种拷贝构造的产生，解决：传引用 函数返回值 Cstu fun()&#123; Cstu a; return a;&#125; 返回值为创建了临时对象承接，然后再把临时变量返回。 赋值不会调用： Cstu s1; Cstu s2; s2 = s1; 默认拷贝构造（浅拷贝） 逐个赋值非静态成员，（即默认拷贝构造中是有内容的，默认的构造函数是没有内容的） 内存排布一样，地址不同 深拷贝(涉及类中有指针) 如果是浅拷贝，则两个对象的指针都会指向同一个空间，如果第一个对象被消除后，这个空间就会被delete（free掉），所以第二个对象被删除时再操作（free）这个被释放掉的空间（已经还给系统），就相当于控制野指针，所以会报错。 解决方法1深拷贝： 123this-&gt;a = new int[2];memcpy(this-&gt;a,b.a,8);strcpy(...) 解决方法2传引用（不经过拷贝构造）： 123Cstu&amp; fun(CStu&amp; a)&#123; return a; &#125;fun(a); 解决方法3传地址： 123Cstu* fun(CStu* a)&#123; return a; &#125;fun(&amp;a); inline内联函数 常规函数的调用过程：调用时，根据函数地址，跳到函数代码空间，执行指令，执行完再跳转到调用的位置。 内联函数：将函数代码直接复制到执行部分，不跳转。 比常规函数稍快 占用更多内存（增加代码长度） ▲声明和定义都要加inline 关键字 ▲递归不能是内联函数 △.函数代码少时、调用频繁（for循环里）大多用内联函数（常规函数的话，跳转所耗时间占比就大） ▲.类内定义的函数都是内联函数，但如果定义在类外的话加inline为内联函数，不加就不是内联函数。 △.内联函数通常定义在头文件里。 操作符重载 operator为关键字 “operator+”必须有一个类类型的形参； 继承： 继承控制符： public 父类：父类为什么访问控制符，子类就继承什么样的。 protected 父类:继承之后，父类的public降级为protected，低级或者同级的访问控制符不变（即protectedh和private) private 父类：继承之后，父类全变为私有。 多态和虚函数 多态：同样的调用有多种结果 通过虚函数调用子类的成员函数，形式为virtual void Show(){} (函数名与子类相同) 具体执行那个子类的函数由父类所指向的子类所决定. CFather* fa = new CSon1; C++中声明结构体变量不需要‘struct’，struct默认为public,class 默认为private c静态变量在预处理时声明。 cpp静态成员在类声明时声明。 STL初始化 (1): vector v; 默认初始化，vector为空， size为0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。 (2): vector v2(v); vector v2= v; 两种方式等价 ，ilist2 初始化为ilist 的拷贝，ilist必须与ilist2 类型相同，也就是同为int的vector类型，ilist2将具有和ilist相同的容量和元素 (3): vector ilist = {1,2,3.0,4,5,6,7}; vector ilist {1,2,3.0,4,5,6,7}; 初始化为列表中元素的拷贝，列表中元素必须与ilist的元素类型相容 (4): vector ilist3(ilist.begin()+2,ilist.end()-1); 初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与ilist3 的元素类型相容 (5): vector ilist4(7); 默认值初始化，ilist4中将包含7个元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0， (6):vector ilist5(7,3); 指定值初始化，ilist5被初始化为包含7个值为3的int 12std::vector&lt;int&gt; idxs中for(int i : idxs) ====&gt; for i in indx ..... i 为idxs中元素","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"通过XDRP实现Windows远程访问ubuntu桌面","slug":"通过XDRP实现Windows远程访问ubuntu桌面","date":"2019-07-13T00:57:05.000Z","updated":"2019-09-15T08:07:31.098Z","comments":true,"path":"2019/07/13/通过XDRP实现Windows远程访问ubuntu桌面/","link":"","permalink":"https://nymrli.top/2019/07/13/通过XDRP实现Windows远程访问ubuntu桌面/","excerpt":"","text":"通过XDRP实现Windows远程访问 1234567891011121314#安装xrdp $ sudo apt-get install xrdp #安装vnc4server $ sudo apt-get install vnc4server tightvncserver#安装xubuntu-desktop $ sudo apt-get install xubuntu-desktop #向xsession中写入xfce4-session $ echo “xfce4-session” &gt;~/.xsession #开启xrdp服务 $ sudo service xrdp restart 上面是网上大多数示例所展示的，都是依靠第三方桌面系统实现远程访问，下面讲解的是如何直接访问原生系统。 步骤一、下载TigerVNC Server软件包 下载地址：Tigervnc Deb软件包（适用于Ubuntu 16.04.1 - 64位） 步骤二、 安装TigerVNC Server软件包 1、打开终端，进入到刚刚你你下载TigerVNC Server的存放目录，我是直接下载到默认的DownLoads下的，因为下载的是zip文件，记得解压出来，得到deb安装文件。 2、再输入一下安装命令进行安装（需要su密码） 12$ sudo apt-get install -f$ sudo dpkg -i tigervncserver_1.6.80-4_amd64.deb 步骤三、安装xrdp 打开终端，输入一下命令（需要su密码） 1sudo apt-get install xrdp -y 步骤四、配置xrdp设置 需要通过xrdp连接到桌面，需要正确配置相关信息并填充到.xsession文件（针对每个用户）或/etc/startwm.sh（针对所有用户），输入如下命令 123$ echo unity&gt;~/.xsession# 或者$ sudo sed -i.bak '/fi/a #xrdp multi-users \\n unity \\n' /etc/xrdp/startwm.sh 步骤五、重启xrdp 1sudo service xrdp restart 步骤六、开启桌面共享功能 进入系统-》首选项-》桌面共享，或者直接搜索桌面共享，如图所示 将【允许其他人查看您的桌面】这一项勾上，如图所示： 到这一步基本上已经完成了，接下来就是来测试是否能正常连接到Ubuntu了 三、xrdp测试连接到Ubuntu 1、查看Ubuntu服务器的IP地址，如图所示： 2、启动Windows远程桌面工具(mstc)，输入Ubuntu的IP地址（192.168.226.131），如图所示： 3、点击连接之后，正常情况会自动跳出xrdp的登录界面，需要我们输入用户名和密码即可，模式选择默认就行，如图所示： 4、我们可以看到xrdp的实时日志，如图所示： 5、最终我们连接到上了Ubuntu，是不是很熟悉的界面~~（ヾ(๑╹◡╹)ﾉ&quot;） 至此，xrdp连接Ubuntu 16.04的所有步骤已完成","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://nymrli.top/tags/Ubuntu/"}]},{"title":"自动化运维工具Ansible","slug":"自动化运维工具Ansible","date":"2019-07-08T06:45:45.000Z","updated":"2019-12-16T13:16:40.946Z","comments":true,"path":"2019/07/08/自动化运维工具Ansible/","link":"","permalink":"https://nymrli.top/2019/07/08/自动化运维工具Ansible/","excerpt":"","text":"简介 ​ ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。 ansible是基于 paramiko 开发的,并且基于模块化工作，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。ansible不需要在远程主机上安装client/agents，因为它们是基于ssh来和远程主机通讯的。ansible目前已经已经被红帽官方收购，是自动化运维工具中大家认可度最高的，并且上手容易，学习简单。是每位运维工程师必须掌握的技能之一。 ansible 特点 部署简单，只需在主控端部署Ansible环境，被控端无需做任何操作； 默认使用SSH协议对设备进行管理； 有大量常规运维操作模块，可实现日常绝大部分操作； 配置简单、功能强大、扩展性强； 支持API及自定义模块，可通过Python轻松扩展； 通过Playbooks来定制强大的配置、状态管理； 轻量级，无需在客户端安装agent(代理)，更新时，只需在操作机上进行一次更新即可； 提供一个功能强大、操作性强的Web管理界面和REST API接口——AWX平台。 Ansible适用于中小型应用环境；SaltStack适合大型（Ansible由于不需要代理,只是通过ssh,因此只能性能不如Saltstack高） Ansible安装 法1.在已有python-pip的情况下 1$ pip install ansible 法2: 1234sudo apt-get install software-properties-commonsudo apt-add-repository ppa:ansible/ansiblesudo apt-get updatesudo apt-get install ansible 如果安装失败请换源sudo sed -i -re 's/\\w+\\.archive\\.ubuntu\\.com/archive.ubuntu.com/g' /etc/apt/sources.list,更新安装库sudo apt-get update ansible 架构图 上图中我们看到的主要模块如下： Ansible：Ansible核心程序。 HostInventory：主机清单 , 记录由Ansible管理的主机信息，包括端口、密码、ip等。 Playbooks：“剧本”YAML格式文件，多个任务定义在一个文件中，定义主机需要调用哪些模块来完成的功能。 CoreModules：核心模块，主要操作是通过调用核心模块来完成管理任务。 CustomModules：自定义模块，完成核心模块无法完成的功能，支持多种语言。 ConnectionPlugins：连接插件，Ansible和Host通信使用 ansible配置文件查找顺序 检查环境变量ANSIBLE_CONFIG指向的路径文件(export ANSIBLE_CONFIG=/etc/ansible.cfg)； HOME目录下的配置文件~/.ansible.cfg 检查当前目录下的ansible.cfg配置文件； /etc/ansible.cfg检查etc目录的配置文件。 使用特性 模块化：调用特定的模块，完成特定任务 有Paramiko，PyYAML，Jinja2（模板语言）三个关键模块支持自定义模块 基于Python语言实现 部署简单，基于python和SSH（默认已安装），agentless安全，基于OpenSSH支持playbook编排任务 幂等性：一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况 无需代理不依赖PKI（无需ssl）可使用任何编程语言写模块 YAML格式，编排任务，支持丰富的数据结构 较强大的多层解决方案 管理方式: Ad-Hoc，及Ansible命令，主要用于临时命令使用场景 Ansible-Playbook，脚本，用于长期规划好，大型项目的场景，需要有提前的规划 Ansible-playbook（剧本）执行过程： 将已有编排好的任务集写入Ansible-Playbook 通过ansible-playbook命令分拆任务集至逐条ansible命令，按预定规则逐条执行 相关文件 配置文件 /etc/ansible/ansible.cfg 主配置文件，配置ansible工作特性 /etc/ansible/hosts 主机清单 /etc/ansible/roles/存放角色的目录 程序 /usr/bin/ansible 主程序，临时命令执行工具 /usr/bin/ansible-doc 查看配置文档，模块功能查看工具 /usr/bin/ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台 /usr/bin/ansible-playbook定制自动化任务，编排剧本工具/usr/bin/ansible-pull远程执行命令的工具 /usr/bin/ansible-vault 文件加密工具 /usr/bin/ansible-console 基于console界面与用户交互的执行工具 1.设置被管理的主机清单vim /etc/ansible/hosts 2.1口令验证方式.ansible 192.168.30.101 -m ping -k用账号密码去确认受控端的身份 ▲如果出现了这样的情况,需要先安装sshpass , sudo apt install sshpass 1234192.168.100.180 | FAILED! =&gt; &#123; \"failed\": true, \"msg\": \"ERROR! to use the 'ssh' connection type with passwords, you must install the sshpass program\"&#125; 2.2基于key验证 123456789101112$ ssh-keygen$ ssh-copy-id 192.168.30.101Generating public/private rsa key pair.Enter file in which to save the key (/xxxxxx/): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in xxxxxxxxx.Your public key has been saved in xxxxx.The key fingerprint is:SHA256:xxxxxxxxxxxxxxThe key's randomart image is: 如果设置了passphrase,那么链接时需要输入passphrase,如果是ad-hoc就相当麻烦,而playbooks中有解决方法 ad-hoc使用 将host_key_checking取消注释,否则链接对象必须在known_hosts中 123$ sudo vim /etc/ansible/ansible.cfg uncomment this to disable SSH key host checking#host_key_checking = False 显示日志,取消注释log_path = /var/log/ansible.log △.ansible不是长期执行的服务,不长期执行,因此修改配置后不需要重启服务 12345ansible &lt;host-pattern&gt;[-m module_name][-a args]ansible dbsrvs -m command -a 'ls /root'-u wang-k -b-K -u 以wang的身份登录,-b将wang切换成root,-K 输入root密码. -m 指定模块名,-a指定模块参数 ansible的Host-pattern即匹配主机的列表 123456789All：表示所有Inventory中的所有主机ansible all-m ping：通配符ansible&quot;&quot;-m pingansible 192.168.1.-m pingansible&quot;srvs&quot;-m ping或关系ansible&quot;websrvsiappsrvs&quot;-m pingansible&quot;192.168.1.10：192.168.1.20&quot;-m ping 逻辑与 ansible &quot;websrvs:&amp;dbsrvs&quot; -m ping在websrvs组并且在dbsrvs组中的主机,单引号、双引号都行 逻辑非 ansible 'websrvs:ldbsrvs'-m ping在websrvs组，但不在dbsrvs组中的主机 注意：此处为单引号 综合逻辑 ansible 'websrvs:dbsrvs:&amp;appsrvs:lftpsrvs'-m ping 正则表达式 ansible &quot;websrvs:&amp;dbsrvs&quot; -m ping ansible &quot;~（webldb）.*\\.magedu\\.com&quot; -m ping ansible command creates= 存在,不执行 removes= 不存在,不执行 chdir= 切换目录后执行 命令返回颜色说明 绿色： 表示查看信息，对远程主机未做改动的命令 红色： 批量管理产生错误信息 黄色： 对远程主机做了相应改动 紫色： 对操作提出建议或忠告 常用模块 command shell : 远程节点执行模块 ansible all -m shel1 -a 'getenforce' script: 在远程执行本地的脚本 ansible test -m script -a &quot;/sh/test.sh&quot; copy : 复制模块 ansible all -m copy -a 'src=/root/ansible/selinux dest=/etc/selinux/config backup=yes' ansible all -m copy-a 'src=/etc/shadow dest=/data/mode=000 owner=wang' fetch : 远程获取 ansible srv-m fetch -a 'src=/root/a. sh dest=/data/scripts' file : 文件操作,删除、创建 ansible test -m file -a &quot;dest=/tmp/hello state=touch&quot; unarchieve、achieve : 压缩解压 ansible test -m unarchive -a 'src=/srv/tomcat8/apache-tomcat-8.0.29.tar.gz dest=/usr/local copy=no mode=0755' cron 开启ansible all-m cron -a 'minute=* weekday=1,3,5 jcb=&quot;/usr/bin/wall FBI warning&quot; name=warningcron' 禁用ansible all -m cron -a 'disabled=true job=&quot;/usr/bin/wall FBI warning&quot;name=warningcron'、启用ansible all -m cron -a 'disabled=falsejob=&quot;/usr/bin/wall FBI warning&quot;name=warningcron' 删除ansible all -m cron -a 'job=&quot;/usr/bin/wall FBI warning&quot;name=warningcron state=absent' apt、yum ansible all -m apt 'name=vim update_cache=yes' user group service service:name=httpd state=started enabled=yes setup ansible websrvs -m setup -a 'filter=*address*' template(不能放在ad-hoc)中,只能在playbook中使用 command模块在针对管道、*重定向有…**有问题==&gt;使用shell模块 常用模块介绍 ▲一般 present 表示生成、下载, absent 表示删除或卸载。 系列命令 galaxy ansible-galaxy install geerlingguy.nginx 其中geerlingguy为角色在./ansible/roles/ playbooks Yaml YAML Ain’t Markup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是：“Yet Another Markup Language”（仍是一种标记语言） 核心元素 Hosts 执行的远程主机列表 Tasks 任务集 Varniables 内置变量或自定义变量在playbook中调用Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件Handlers 和notity结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行 tags 标签指定某条任务执行，用于选择运行playbook中的部分代码。 ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断 ansible-playbook-t tagsname useradd.yml 加密 加密ansible-vault encrypt hello.yml 解密查看ansible-vault view hello.yml 重新制定口令ansible-vault rekey hello.yml 基础组件 如果命令或脚本的退出码不为零，可以使用如下方式替代 123tasks: - name:run this command and ignore the result shell: /usr/bin/somecommand || /bin/true 或者使用ignore_errors来忽略错误信息： 1234tasks： - name:run this command and ignore the result shell:/usr/bin/somecommandignore_errors:True 运行playbook的方式 ansible-playbook &lt;filename.yml&gt;..[options] 常见选项 -check(-C)只检测可能会发生的改变，但不真正执行操作 --list-hosts列出运行任务的主机 --limit主机列表只针对主机列表中的主机执行 -V显示过程-vw-vwv更详细 handlers和notify 12345678910tasks: - name: install httpd package yum: name=httpd - name: copy conf file copy:src=files/httpd.conf dest=/etc/httpd/conf/backup=yes notify: restart service - name: start service service: name=httpd state=started enabled=yes handlers: - name:restart service service:name=httpd state=restarted 标签 指定标签来执行指定任务 ansible-playbook -t rshttp,xxxx httpd.yml 变量使用 jinjia2语法 1&#123;&#123; var &#125;&#125; 法一：ansible setup facts 远程主机的所有变量都可直接调用 法二：在/etc/ansible/hosts中定义普通变量：主机组中主机单独定义，优先级高于公共变量公共（组）变量：针对主机组中所有主机定义统一变量 123456[websrvs]192.168.30.101 http_port=81192.168.30.102 http_port=82[websrvs:vars]nodename=www domainname=magedu.com 法三：ansible-playbook -e 'var=xxx' app.html，优先级比法二高 法四: 1234567- hosts: remote_user: root vars: - var: xxx tasks: - name: yum: ... 迭代机制 1234567tasks: - name: file: name=/data/&#123;&#123; item &#125;&#125; with_items: - file1 - file2 - file3 迭代嵌套自变量 123456789101112131415- hosts: websrvs remote_user: root tasks: - name: add some groups group: name=&#123;&#123; item ]&#125; state=present with_items: - group1 - group2 - group3 - name: add some users user: name=&#123;&#123; item. name ]&#125; group=&#123;&#123; item. group )&#125; state=present with items: - &#123; name: user1, group:' group1'&#125; - &#123; name: 'user2, group:' group2'&#125; - &#123; name: 'user3', group:' group3'&#125; 1234&#123;% for vhost in nginx_vhosts%&#125;server&#123;listen&#123;&#123; vhost &#125;&#125;&#123;% endfor %&#125; 12345678910- hosts: websrvs remote_user: root vars: ports: - listen_port: 81 - listen_port: 82 - listen_port: 83 tasks: - name: copy conf template: src=forl.conf.j2 dest=/data/for1.conf 条件判断 1234567891011121314151617- hosts: all remote_user: root tasks:#如果系统中存在主机名为nfs或者backup的主机，则创建文件 - name: Create File file: path=/tmp/this_is_&#123;&#123; ansible_hostname &#125;&#125;_file state=touch when: (ansible_hostname == \"nfs\") or (ansible_hostname == \"backup\") #系统为centos的主机才会执行 - name: Centos Install httpd yum: name=httpd state=present when: (ansible_distribution == \"CentOS\") #系统为ubuntu的主机才会执行 - name: Ubuntu Install httpd yum: name=httpd2 state=present when: (ansible_distribution == \"Ubuntu\") 12345tasks: - name: run df -h sudo_user: test sudo: yes shell: name=df -h ansible sudo 即将变更为become 1234567[s21]#代替原来192.168.1.21 ansible_ssh_user=i ansible_ssh_pass=i的写法192.168.1.21 ansible_ssh_user=i ansible_ssh_private_key_file=/home/i/.ssh/id_rsa ansible_become=true ansible_become_user=root ansible_become_pass=&apos;i&apos; 获取执行命令的输出 –Register[转] 1234567- name: echo date command: date register: date_output - name: echo date_output command: echo \"30\" when: date_output.stdout.split(' ')[2] == \"30\" 判断文件是否存在[转] 12345678910- name: judge a file or dir is exits shell: ls /home/sfy ignore_errors: True register: result- shell: echo \"file exit\" when: result|succeeded- shell: echo \"file not exit\" when: result|failed 权限问题 关于权限问题，可以通过ansible -h查看 123456789101112131415161718192021222324Privilege Escalation Options: control how and which user you become as on target hosts -s, --sudo run operations with sudo (nopasswd) (deprecated, use become) -U SUDO_USER, --sudo-user=SUDO_USER desired sudo user (default=root) (deprecated, use become) -S, --su run operations with su (deprecated, use become) -R SU_USER, --su-user=SU_USER run operations with su as this user (default=None) (deprecated, use become) -b, --become run operations with become (does not imply password prompting) --become-method=BECOME_METHOD privilege escalation method to use (default=sudo), valid choices: [ sudo | su | pbrun | pfexec | doas | dzdo | ksu | runas | pmrun ] --become-user=BECOME_USER run operations as this user (default=root) --ask-sudo-pass ask for sudo password (deprecated, use become) --ask-su-pass ask for su password (deprecated, use become) -K, --ask-become-pass ask for privilege escalation password ▲其中deprecated表示是将被弃用的，将全部被become代替，（即参数-b） 关于-b和-K的作用，可以通过如下命令进行测试 12345$ ansible test -m shell -a \"whoami\" -K mrli身份使用sudo权限$ ansible test -m shell -a \"whoami\" -b 切换到root身份$ ansible test -m shell -a \"whoami\" -b -K ▲这个权限问题在ansible执行shell脚本的时候需要特别注意 个人写过的Playbook-demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071- hosts: 192.168.100.190 remote_user: apollo3d become: yes vars: spark: /home/apollo3d/SimSpark/spark/build rcssserver3d: /home/apollo3d/SimSpark/rcssserver3d/build tasks: - name: judge former platform directory Exsit shell: 'ls /home/apollo3d/simspark-0.3.0/build' ignore_errors: True register: formerDirExsit - name: uninstall command: 'chdir=&#123;&#123; item &#125;&#125; make uninstall' with_items: - /home/apollo3d/simspark-0.3.0/build - /home/apollo3d/rcssserver3d-0.7.1/build when: formerDirExsit|succeeded - name: remove file: dest: '&#123;&#123; item &#125;&#125;' state: absent with_items: - /home/apollo3d/simspark-0.3.0/ - /home/apollo3d/rcssserver3d-0.7.1/ when: formerDirExsit|succeeded - name: judge new zip shell: ls /home/apollo3d/SimSpark.tar.gz ignore_errors: True register: zipExsit - name: jieya unarchive: src: /home/apollo3d/SimSpark.tar.gz dest: /home/apollo3d/ copy: no mode: 0755 when: zipExsit|succeeded - name: mk dirs file: \"dest=&#123;&#123; item &#125;&#125; state=directory\" with_items: - /home/apollo3d/SimSpark/spark/build - /home/apollo3d/SimSpark/rcssserver3d/build when: zipExsit|succeeded - name: install1 command: 'chdir=&#123;&#123; spark &#125;&#125; &#123;&#123; item &#125;&#125;' with_items: - cmake .. - make -j4 - make install when: zipExsit|succeeded - name: install2 command: 'chdir=&#123;&#123; rcssserver3d &#125;&#125; &#123;&#123; item &#125;&#125;' with_items: - cmake .. - make -j4 - make install when: zipExsit|succeeded - name: config shell: '&#123;&#123; item &#125;&#125;' with_items: - echo '/usr/local/lib/simspark\\n/usr/local/lib/rcssserver3d' | sudo tee /etc/ld.so.conf.d/spark.conf - ldconfig when: zipExsit|succeeded roles ansilbe自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中 复杂场景：建议使用roles，代码复用度高 变更指定主机或主机组 如命名不规范维护和传承成本大 某些功能需多个Playbook，通过Includes即可实现 roles目录结构： playbook.yml roles/ project/ tasks/ files/ vars/不常用 default/不常用 templates/ handlers/ meta/不常用 附录 Ansible 配置SSH公钥认证 安装好Ansible之后，要开始工作，还需要创建一个被控制主机列表清单.默认读取/etc/ansible/hosts,如果该文件不存在，则要收到进行创建. 也可以通过环境变量 ANSIBLE_INVENTORY 来设置默认清单文件,1.9版本之前用 ANSIBLE_HOSTSexport ANSIBLE_INVENTORY=~/ansible_hosts 创建SSH认证文件 该操作是在控制主机中进行。 SSH认证文件创建成功之后，将控制主机的公钥文件 id_rsa.pub 添加到被控制主机的~/.ssh/authorized_keys。 \\ ~指的是控制主机和被控制主机通信的用户家目录。 \\ id_rsa 是控制主机的私钥文件，要严格保管。 \\ id_rsa.pub是控制主机的公钥文件，可随意分发。 法一:ansible all -m shell -a &quot;cat /tmp/authorized_keys &gt;&gt; /root/.ssh/authorized_keys&quot; -k ▲注意 如果被控制主机中用户家目录中不存在.ssh目录，就创建。 然后将上传的公钥文件追加到用户的authorized_keys文件中 法二: (亲测) 通过authorized_key模块来进行添加 1ansible para -i /tmp/inventory.txt -m authorized_key -a \"user=root key='&#123;&#123; lookup('file','/root/.ssh/id_rsa.pub') &#125;&#125;'\" -k lookup('file','/root/.ssh/id_rsa.pub') 是读取/root/.ssh/id_rsa.pub的内容 使用公钥密钥对验证的方法登录 1. 在本地也创建一个 apple 用户,并创建 /home/apple/.ssh/ 目录 $ useradd apple -s /bin/bash -d /home/apple/ 创建 .ssh 目录mkdir /home/apple/.ssh 修改 .ssh 目录的权限chmod 700 /home/apple/.ssh 创建 /home/apple/.ssh/known_hosts 文件 2.收集所有远程主机的公钥，保存在上 /home/apple/.ssh/known_hosts 文件。这一步的作用，是为了在后面第一次ssh 连接时，不需要再输密码。 收集所有远程主机的 公钥，主要是利用 ssh-keyscan 命令：ssh-keyscan -f ip.txt &gt;&gt; /home/apple/.ssh/known_hosts 说明： ip.txt 文件存放所有的远程主机 ip 地址，一行代表一台主机。 3.创建公钥私钥对： 一般在对应用户的 /home/apple/.ssh/ 目录下创建。这也不是强制的，因为在ssh 发起连接时，可以指定使用的私钥文件。 ssk-keygen -t rsa 一直按回车键就可以了。但要注意生成的 id_rsa 和 id_rsa.pub 存放的路径。 4.将公钥推送到所有的远程主机 我们编写playbook 文件，利用authorized_key 模块就可以快速完成： 12345678[root@centos_7 roles]$ cat ssh-addkey.yml ---- hosts: apps 对apps 组里的所有远程主机 gather_facts: False tasks: - name: install sshkey authorized_key: user: apple key: \"&#123;&#123; lookup('file', '/home/apple/.ssh/id_rsa.pub') &#125;&#125;\" state: present 说明： 在前面1,2,3步中，我们已经准备好了公私钥对了。推送到远程主机，可以手动推送，或者使用scp 复制到远程主机。但是利用scp 复制之后，还需要修改远程主机上的 /home/apple/.ssh/authorize_keys 文件的权限等等。 ansible 的 authorized_key 模块就自动帮我们做了这些工作。 执行， ansible-playbook ssh-addkye.yml 在多台远程主机中创建用户 不用ansible，单个操作 1234567891011121314151617 在 root 用户下运行这条命令创建一个新用户，yangxg 是用户名 因为我叫杨学光，所以我取的用户名是 yangxg 选择一个你喜欢的用户名，不一定非得和我的相同root@localhost:~ useradd -m -s /bin/bash yangxg 把新创建的用户加入超级权限组root@localhost:~ usermod -a -G sudo yangxg 为新用户设置密码 注意在输密码的时候不会有字符显示，不要以为键盘坏了，正常输入即可root@localhost:~ passwd yangxg 切换到创建的新用户root@localhost:~ su - yangxg 切换成功，@符号前面已经是新用户名而不是 root 了yangxg@localhost:~$ ansible 1234567891011121314---- hosts: all vars: user: test password: \"$6$rounds=100000$O2BHfT2XIF6oDb9w$8Hhv4vOrLN6JF/nRVYDd8zZdnn9TNkQutyYYywIcPF2kRiHgkwAjqHIN7sDUkd1DcjLRABWT9ULHZPBOF2bZS/\" remote_user: root tasks: - name: Add user &#123;&#123; user &#125;&#125; user: name=&#123;&#123;user&#125;&#125; comment=\"ceph user\" password=&#123;&#123; password &#125;&#125; - name: Config /etc/sudoers lineinfile: dest=/etc/sudoers state=present line='&#123;&#123;item&#125;&#125;' validate='visudo -cf %s' with_items: - \"&#123;&#123; user&#125;&#125; ALL=(ALL) NOPASSWD: ALL\" - \"Defaults: &#123;&#123;user&#125;&#125; !requiretty\" 12345678$ python -c 'import crypt; print crypt.crypt(\"rescue\", \"hadoop\")' hadoop为salt，可以改成其他的。rescue是需要加密的内容$ ansible rescue -m user -a \"name=rescue shell=/bin/bash home=/home/rescue password= state=present\" -b -K$ ansible rescue -m shell -a \"usermod -a -G sudo rescue\" -b -K user模块增加 update_password=always时，可以更新密码 一键挂载NFS: ansible full -m mount -a &quot;name=/data src=192.168.100.179:/data fstype=nfs state=mounted&quot; -b -K 挂载需要用SUDO权限,所以-K必不可少.同时,在这之前已经使用过ssh进行了配对因此不需要输入登录用户密码. 其他命令记录 ss -ntl | grep 80 vim /etc/sysconfig/network-scripts/ifcfg-eth0建议可以使用Alias service network restart重启网络服务","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://nymrli.top/tags/运维/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"staticmethod和classmethod区别","slug":"staticmethod和classmethod区别","date":"2019-07-07T02:06:00.000Z","updated":"2019-09-15T08:07:31.006Z","comments":true,"path":"2019/07/07/staticmethod和classmethod区别/","link":"","permalink":"https://nymrli.top/2019/07/07/staticmethod和classmethod区别/","excerpt":"","text":"staticmethod和classmethod 类的实例化基本遵循创建实例对象、初始化实例对象、最后返回(产生)实例对象这么一个过程 123456789101112131415161718class Test(object): data = 'world' # 类对象的数据成员 def __init__(self, arg): self.arg = arg @staticmethod # 静态方法，不能访问类数据成员 def func(): print(\"hello\") @classmethod # 类方法,能访问类数据成员 def getData(cls): print(cls.data)if __name__ == '__main__': t = Test('A') Test.func() Test.getData() 共同: 两个都是装饰器，装饰的成员函数可以通过类名.方法名(...)来调用 区别: ▲最显著的特点是classmethod需要传递一个参数cls，而staticmethod不需要。因此可以访问、修改类的属性，类的方法，实例化对象等，避免硬编码；而staticmethod不行 classmethod可以判断出自己是通过基类被调用，还是通过某个子类被调用 用途： classmethod多用于设计模式之工厂模式，将解析逻辑封装在方法本身内部。（也可认为构造前交互，即在进行实例化类对象之前先进行某些逻辑操作，即可看作进行不同的构造函数，然后返回一个类实例，见具体代码）,更多拓展见附录__new__和__init__ staticmethod用法就跟其他的语言中的静态static用法相同（可看作是属于该类的一个工具、辅助函数） 具体代码 12345678910111213141516171819202122232425# Python program to demonstrate # use of class method and static method. class time(object): def __init__(self, year): super(time, self).__init__() self.year = year print(self.year) # a class method to create a time that one day following the data 'year' @classmethod def tomorrow(cls,year): print(type(cls)) # &gt;&gt;&gt; ▲ Python所有类都继承自`&lt;class 'type'&gt;`，包括新式类`object` return cls(year+1) # a static method to check whether the given data 'year' is after 2000. @staticmethod def twoThoundYear(year): return year&gt;2000if __name__ == '__main__': t1 = time(1999) t2 = time.tomorrow(1999) print( time.twoThoundYear(2001) ) 可看下这篇class method vs static method in Python 附录__new__和__init__ 知识点 ▲1. 首先要弄懂调用顺序__new__–&gt;__init__： 所以__init__其实不是实例化一个类的时候第一个被调用 的方法。当使用 Persion(name, age) 这样的表达式来实例化一个类时，最先被调用的方法 其实是__new__方法。 __new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供（实例化时加的参数，也会被认为时cls的属性，见①）。即系统知道__new__() 方法始终都是类的类方法，即使没有被加上类方法装饰器。 __new__方法接受的参数虽然也是和__init__一样，但__init__是在类实例创建之后调用，而 __new__方法正是创建这个类实例的方法。 ▲2. __init__有一个参数self，就是这个__new__中return的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值。而__new__必须有（可以return父类__new__出来的实例，或者直接是object的__new__出来的实例）。__new__方法决定了创建哪个类的实例（可以是父类，也可以是子类），因此不一定调用当前类的__init__。即（若__new__没有正确返回当前类cls的实例，那__init__是不会被调用的，即使是父类的实例也不行） 3.继承自object的新式类才有__new__，同时，在任何新式类的__new__()方法，不能调用自身的__new__()来制造实例，因为这会造成死循环，即class Foo(object)的__new__中不能Foo.__new__(cls, *args, **kwargs)。 区别 1.__init__ 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。 2.__new__ 通常用于控制生成一个新实例的过程。它是类级别的方法。 依照Python官方文档的说法，__new__方法主要是当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的metaclass。 12345678910111213141516171819202122class A(object): # 新式类:继承自object def __init__(self,something): print('init') print(something) # def __new__(cls): 不行，因为A(\"...\")参数不匹配 # pass def __new__(cls, *args, **kwargs): print('new') self = object.__new__(cls) # ①cls中包含了*args, **kwargs信息 self.x = '1' return self # 调用父类的`__new__`方法会返回一个A对象，init里的参数self调用的就是这个self实例 # `__new__`必须具有返回值，否则无法创建对象，因为`__init__`函数需要这个返回值 # 自己在定义`__new__`的时候，参数要与`__init__`函数的参数匹配，我可以不用到这些参数，但一定要匹配。或者可以使用*arg和**args的形式。if __name__ == '__main__': # a = A.__new__(A) #&gt;&gt;&gt; new a = A('do it') # &gt;&gt;&gt; new init print(a.__dict__) # &#123;'x': '1'&#125; # 2、new定义在type元类中，必须具有返回值， # 3、new的作用就是创建实例，然后将创建的实例传递给init进行初始化 总结： a = A() --&gt; __new__方法，return调用父类__new__生成一个类实例对象 --&gt;__init__(self,...)中的self实例就是这个父类__new__出来的实例 __new__() 是在新式类中新出现的方法，它作用在构造方法建造实例之前，可以这么理解，在 Python 中存在于类里面的构造方法 __init__() 负责将类的实例化，而在 __init__() 启动之前，__new__() 决定是否要使用该 __init__() 方法，因为__new__() 可以调用其他类的构造方法或者直接返回别的对象来作为本类的实例。 用__new__来实现设计模式中的–单例模式 只能实例化一个类对象 12345class Singleton(object): def __new__(cls, *args, **kwargs): if not hasattr(cls, 'instance'): cls.instance = super(Singleton, cls).__new__(cls, *args, **kwargs) return cls.instance ▲ Python所有类都继承自&lt;class 'type'&gt;，包括新式类object","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"yaml基础语法_spring_boot","slug":"yaml基础语法-spring-boot","date":"2019-07-07T02:04:35.000Z","updated":"2019-09-15T08:07:31.018Z","comments":true,"path":"2019/07/07/yaml基础语法-spring-boot/","link":"","permalink":"https://nymrli.top/2019/07/07/yaml基础语法-spring-boot/","excerpt":"","text":"yaml基础语法_spring_boot yaml aren’t markup language 即yaml不是标语语言： xml（标记语言）: 1234&gt; &lt;server&gt;&gt; &lt;port&gt;8888&lt;/port&gt;&gt; &lt;/server&gt;&gt; java spring boot默认全局配置文件: application.properties 使用的时 key=value application.yaml: k:v 通过缩进，垂直对齐指定层次关系 字符串可以默认不写引号，写引号中的转义符会被翻译：e.g.&quot;天\\n津&quot; 12345678910111213141516171819202122server: port: 8888student: name: 张三 age: 18 birthday: 2019/07/19 location: # &lt;==&gt; &#123;province: 陕西, city: 西安&#125; 行内写法 province: 陕西 city: 西安 # 对应java里的字典map hobbies: # &lt;==&gt; [足球,篮球] - 足球 - 篮球 # 对应java里的列表List skills: # &lt;==&gt;[编程,金融] - 编程 - 金融 # 对应java里的集合set pet: # &lt;==&gt;&#123;name: wc, type: hsq&#125; name: wc type: hsq # entity的另一个类pet.java [Set,List,数组\\Array]、{Map、对象类型的属性StudentPet}，[]可以省略，{}不可以省略","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"Python类的继承-super()使用","slug":"Python类的继承-super-使用","date":"2019-07-07T02:03:49.000Z","updated":"2019-09-15T08:07:30.997Z","comments":true,"path":"2019/07/07/Python类的继承-super-使用/","link":"","permalink":"https://nymrli.top/2019/07/07/Python类的继承-super-使用/","excerpt":"","text":"Python类的继承即super()使用 Super super() 函数是用于调用父类(超类)的一个方法，只有在新式类中可以使用 super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO，Method Resolution Order，采用广度优先（区别于深度优先）的规则定义）、重复调用（钻石继承）等种种问题。 MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。 语法 以下是 super() 方法的语法: 1234# 菜鸟教程super(type [, object-or-type])# 个人理解super( ThisClass [, object(self)]) 参数 type – 类（type），通常是当前子类。 object-or-type – 类实例，一般是 self 含义 用self这个实例对象去查找ThisClass类的父类拥有的属性（成员方法、数据成员） ▲. Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx : 即平时写的 1234567class TestClass(object): def __init__(self, *arg, **kwarg): super(TestClass, self).__init__() # 此时init里不用self # 等价于 super().__init__() , 含义是用父类的构造函数初始化某些变量 # 相当于旧式类的 object.__init__(self) # 需要传参self self.arg = arg self.kwarg = kwarg 完整代码 12345678910111213141516class clsSuper(object): age = 18 def __init__(self, name): print(name)class clsSub(clsSuper): def __init__(self): print(super().age) # 当只是单继承的时候可以直接使用 print(clsSuper.age)，if __name__ == '__main__': a = clsSuper('cl') b = clsSub() 特点 super().func()是不用传参self的 super(type, obj).func()函数调用的是obj实例在MRO中下一个父类的可调用func()，而不是type的父类中的func()。即调用最近的可用func() 使用super()不用指定父类的名称，便于修改维护；同时当继承多个类A、B的时候，用super().__init__()相当于调用多个类的A.__ini__(self)、B.__ini__(self) 与java对比 Python中子类不会默认调用父类的构造函数，即下面代码。并不会要要求给传name。当然也可以理解为跟java一样调用了一个全空、没有任何内容的构造函数，但是在python中不需要显性写出来，原因部分是特点2（java中存在有参数的构造函数时，必须将空参数的构造函数显式写出，不然子类默认隐式调用空参数的构造函数时会报错说不存在）。 Python中的构造函数只有一个。但由于存在*arg,**kwarg的存在，所以只要执行类型检查执行不同的代码；即实现了多个构造函数 Python的类可以多继承，java只能单继承。 123456789101112131415161718192021class clsSuper(object): age = 18 def __init__(self, name): self.name = name print(self.name)class clsSub(clsSuper): def __init__(self, age): print(age)'''class clsSub(clsSuper): def __init__(self, age): super().__init__() #调用父类的构造函数 print(age)''' if __name__ == '__main__': b = clsSub(18)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Base64编码原理与应用[转]","slug":"Base64编码原理与应用[转]","date":"2019-06-15T04:08:53.000Z","updated":"2019-09-15T08:07:30.921Z","comments":true,"path":"2019/06/15/Base64编码原理与应用[转]/","link":"","permalink":"https://nymrli.top/2019/06/15/Base64编码原理与应用[转]/","excerpt":"","text":"Base64编码原理与应用[转] 2015年，我们在青云平台上实现了“百度云观测”应用。青云应用本质上是一个iframe，在向iframe服务方发送的请求中会携带一些数据，青云平台会使用Base64 URL对这些数据进行编码，其提供的编码解码算法示例如下： 12345678// php版本function base64_URL_encode($data) &#123; return rtrim(strtr(base64_encode($data), '+/', '-_'), '=');&#125;function base64_URL_decode($data) &#123; return base64_decode(str_pad(strtr($data, '-_', '+/'), strlen($data) % 4, '=', STR_PAD_RIGHT));&#125; 可以看出，Base64 URL 是标准Base64编码的一个变种，分别用 -、_ 替换标准Base64编码结果中的 + 、 / ，并删除结果最后的 = 。 在实现 “百度云观测” 青云应用时，我在想： 为什么要使用Base64编码？ Base64编码算法是什么样的？ 本文是围绕这两个问题思考和实践的结果。 我认为，理解Base64或其他类似编码的关键有两点： 计算机最终存储和执行的是01二进制序列，这个二进制序列的含义则由解码程序/解释程序决定 很多场景下的数据传输要求数据只能由简单通用的字符组成，比如HTTP协议要求请求的首行和请求头都必须是ASCII编码 以青云应用为例，简单解释这两点。青云平台通过POST一个表单来获取iframe，表单有 payload 和 signature 两项， payload 原本是一个JSON对象，其中的键值可能包含一些特殊字符，比如 &amp;、/ 等，由于青云设计的一种通用的请求交互方案，需要考虑iframe服务方服务器端的各种可能实现，有些服务器端实现没有考虑表单值有这些特殊字符，或者POST请求被中间服务器转换成GET请求再次发出，对于URL来说，&amp;、/都是具有特殊含义的字符，所以需要对请求数据进行特殊编码避免这些字符出现 - 数据发送方对数据按规则进行编码，接收方对应地按规则解码数据。 Base64编码原理 Base64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码。标准Base64编码使用的64个字符为： 这64个字符是各种字符编码（比如ASCII编码）所使用字符的子集，基本，并且可打印。唯一有点特殊的是最后两个字符，因对最后两个字符的选择不同，Base64编码又有很多变种，比如Base64 URL编码。 Base64编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续6比特（2的6次方=64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。 假设我们要对 Hello! 进行Base64编码，按照ASCII表，其转换过程如下图所示： 可知 Hello! 的Base64编码结果为 SGVsbG8h ，原始字符串长度为6个字符，编码后长度为8个字符，每3个原始字符经Base64编码成4个字符，编码前后长度比4/3，这个长度比很重要 - 比原始字符串长度短，则需要使用更大的编码字符集，这并不我们想要的；长度比越大，则需要传输越多的字符，传输时间越长。Base64应用广泛的原因是在字符集大小与长度比之间取得一个较好的平衡，适用于各种场景。 是不是觉得Base64编码原理很简单？ 但这里需要注意一个点：Base64编码是每3个原始字符编码成4个字符(如Hel被编成了SGVs)，如果原始字符串长度不能被3整除，那怎么办？使用0值来补充原始字符串。===&gt;Base64的编码长度为4的倍数。 以 Hello!! 为例，其转换过程为： 注：图表中蓝色背景的二进制0值是额外补充的。 Hello!! Base64编码的结果为 SGVsbG8hIQAA 。最后2个零值只是为了Base64编码而补充的，在原始字符中并没有对应的字符，那么Base64编码结果中的最后两个字符 AA 实际不带有效信息，所以需要特殊处理，以免解码错误。 标准Base64编码通常用 = 字符来替换最后的 A（完全由补充的0组成的A，跟b'H'的结果SA==区别一下），即编码结果为 SGVsbG8hIQ==。因为 = 字符并不在Base64编码索引表中，其意义在于结束符号，在Base64解码时遇到 = 时即可知道一个Base64编码字符串结束。 如果Base64编码字符串不会相互拼接再传输，那么最后的 = 也可以省略，解码时如果发现Base64编码字符串长度不能被4整除，则先补充 = 字符，再解码即可。 解码是对编码的逆向操作，但注意一点：对于最后的两个 = 字符，转换成两个 A 字符，再转成对应的两个6比特二进制0值，接着转成原始字符之前，需要将最后的两个6比特二进制0值丢弃，因为它们实际上不携带有效信息。 为了理解Base64编码解码过程，个人实现了一个非常简陋的Base64编码解码程序，见：youngsterxyf/xiaBase64。 由于Base64应用广泛，所以很多编程语言的标准库都内置Base64编码解码包，如： PHP：base64_encode、base64_decode Python：base64包 Go：encoding/base64 … Base64编码应用 本文开始提到的青云应用例子只是Base64编码的应用场景之一。由于Base64编码在字符集大小与编码后数据长度之间做了较好的平衡，以及Base64编码变种形式的多样，使得Base64编码的应用场景非常广泛。下面举2个常用常见的例子。 HTML内嵌Base64编码图片 前端在实现页面时，对于一些简单图片，通常会选择将图片内容直接内嵌在页面中，避免不必要的外部资源加载，增大页面加载时间，但是图片数据是二进制数据，该怎么嵌入呢？[绝大多数现代浏览器](http://caniuse.com/#search=Data URI)都支持一种名为 Data URLs 的特性，允许使用Base64对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。以百度搜索首页为例，其中语音搜索的图标是个背景图片，其内容以 Data URLs 形式直接写在css中，这个css内容又直接嵌在HTML页面中，如下图所示： Data URLs 格式为：url(data:文件类型;编码方式,编码后的文件内容)。 当然，也可以直接基于image标签嵌入图片，如下所示： 1&lt;img alt=&quot;Embedded Image&quot; src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIA...&quot; /&gt; 但请注意：如果图片较大，图片的色彩层次比较丰富，则不适合使用这种方式，因为其Base64编码后的字符串非常大，会明显增大HTML页面，影响加载速度。 MIME（多用途互联网邮件扩展） 我们的电子邮件系统，一般是使用SMTP（简单邮件传输协议）将邮件从客户端发往服务器端，邮件客户端使用POP3（邮局协议，第3版本）或IMAP（交互邮件访问协议）从服务器端获取邮件。 SMTP协议一开始是基于纯ASCII文本的，对于二进制文件（比如邮件附件中的图像、声音等）的处理并不好，所以后来新增MIME标准来编码二进制文件，使其能够通过SMTP协议传输。 举例来说，我给自己发封邮件，正文为空，带一个名为hello.txt的附件，内容为 您好！世界！。导出邮件源码，其关键部分如下图所示： MIME-Version: 1.0：表示当前使用MIME标准1.0版本。 Content-Type: text/plain; name=&quot;hello.txt&quot;：表示附件文件名为 hello.txt ，格式为纯文本。 Content-Transfer-Encoding: base64：表示附件文件内容使用base64编码后传输。 5oKo5aW977yM5LiW55WM77yB：则是文件内容 您好，世界！ Base64编码后的结果。 不过，MIME使用的不是标准Base64编码。 切忌误用 可能会有人在不理解Base64编码的情况下，将其误用于数据加密或数据校验。 Base64是一种数据编码方式，目的是让数据符合传输协议的要求。标准Base64编码解码无需额外信息即完全可逆，即使你自己自定义字符集设计一种类Base64的编码方式用于数据加密，在多数场景下也较容易破解。 对于数据加密应该使用专门的目前还没有有效方式快速破解的加密算法。比如：对称加密算法AES-128-CBC，对称加密需要密钥，只要密钥没有泄露，通常难以破解；也可以使用非对称加密算法，如 RSA，利用极大整数因数分解的计算量极大这一特点，使得使用公钥加密的数据，只有使用私钥才能快速解密。 对于数据校验，也应该使用专门的消息认证码生成算法，如 HMAC - 一种使用单向散列函数构造消息认证码的方法，其过程是不可逆的、唯一确定的，并且使用密钥来生成认证码，其目的是防止数据在传输过程中被篡改或伪造。将原始数据与认证码一起传输，数据接收端将原始数据使用相同密钥和相同算法再次生成认证码，与原有认证码进行比对，校验数据的合法性。 那么针对各大网站被脱库的问题，请问应该怎么存储用户的登录密码？ 答案是：在注册时，根据用户设置的登录密码，生成其消息认证码，然后存储用户名和消息认证码，不存储原始密码。每次用户登录时，根据登录密码，生成消息认证码，与数据库中存储的消息认证码进行比对，以确认是否为有效用户，这样即使网站被脱库，用户的原始密码也不会泄露，不会为用户使用的其他网站带来账号风险。 当然，使用的消息认证码算法其哈希碰撞的概率应该极低才行，目前一般在HMAC算法中使用SHA256。对于这种方式需要注意一点：防止用户使用弱密码，否则也可能会被暴力破解。现在的网站一般要求用户密码6个字符以上，并且同时有数字和大小写字母，甚至要求有特殊字符。 另外，也可以使用加入随机salt的哈希算法来存储校验用户密码。这里暂不细述。 总结 Base64兼顾字符集大小和编码后数据长度，并且可以灵活替换字符集的最后两个字符，以应对多样的需求，使其适用场景非常广泛。 当然，很多场景下有多种编码方式可选择，并非Base64编码不可，视需求，权衡利弊而定。 补充 Base64、Base32、Base16区别 标准Base64： 包含大写字母（A-Z）,小写字母（a-z），数字（0-9）以及+/; Base32: 而Base32中只有大写字母（A-Z）和数字234567； Base16: 而Base16就是16进制，他的范围是数字(0-9)，字母（ABCDEF）； 顺便说一句，当ASCll用Base加密达不到所对应的位数的时候用=号补齐； 在这里附带由三种Base加密的:I love you！ Base64:SSBsb3ZlIHlvde+8gQ== Base32:JEQGY33WMUQHS33V566IC=== Base16:49206c6f766520796f75efbc81 1.由上可知，Base64编码后字符串长度为4的倍数 2.标准Base64编码通常用 = 字符来替换最后的 A（完全由补充的0组成的A，跟b'H'的结果SA==区别一下，SA==的A并不是全部由补充的0组成）","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"}]},{"title":"Python的构建工具setup.py","slug":"Python的构建工具setup-py","date":"2019-06-15T04:08:44.000Z","updated":"2019-09-15T08:07:30.996Z","comments":true,"path":"2019/06/15/Python的构建工具setup-py/","link":"","permalink":"https://nymrli.top/2019/06/15/Python的构建工具setup-py/","excerpt":"","text":"Python的构建工具setup.py setup.py各参数介绍： 12345678910111213141516171819202122232425--name 库名称，▲需要注意的是不要大写，不然会有坑--version (-V) 包版本--author 程序的作者--author_email 程序的作者的邮箱地址--maintainer 维护者--maintainer_email 维护者的邮箱地址--url 程序的官网地址--license 程序的授权信息--description 程序的简单描述--long_description 程序的详细描述--platforms 程序适用的软件平台列表--classifiers 程序的所属分类列表--keywords 程序的关键字列表--packages 需要处理的包目录（包含__init__.py的文件夹） --py_modules 需要打包的python文件列表--download_url 程序的下载地址--cmdclass --data_files 打包时需要打包的数据文件，如图片，配置文件等--scripts 安装时需要执行的脚步列表--package_dir 告诉setuptools哪些目录下的文件被映射到哪个源码包。一个例子：package_dir = &#123;&apos;&apos;: &apos;lib&apos;&#125;，表示“root package”中的模块都在lib 目录中。--requires 定义依赖哪些模块 --provides定义可以为哪些模块提供依赖 --find_packages() 对于简单工程来说，手动增加packages参数很容易，刚刚我们用到了这个函数，它默认在和setup.py同一目录下搜索各个含有 __init__.py的包。--install_requires = [&quot;requests&quot;] 需要安装的依赖包--entry_points 动态发现服务和插件，下面详细讲 find_packages()还可以将包统一放在一个src目录中，另外，这个包内可能还有aaa.txt文件和data数据文件夹。另外，也可以排除一些特定的包 find_packages(exclude=[&quot;*.tests&quot;, &quot;*.tests.*&quot;, &quot;tests.*&quot;, &quot;tests&quot;]) 实测操作 需要事前交代的内容 模板setup.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#!/usr/bin/env python# -*- coding: utf-8 -*-# Note: To use the 'upload' functionality of this file, you must:# $ pip install twineimport ioimport osimport sysfrom shutil import rmtreefrom setuptools import find_packages, setup, Command# Package meta-data.NAME = 'cltest'DESCRIPTION = 'know how to'URL = ''EMAIL = '10630529664@qq.com'AUTHOR = 'Gao Liang'REQUIRES_PYTHON = '&gt;=3.0.0'VERSION = '0.3.0'# What packages are required for this module to be executed?REQUIRED = [ 'requests &gt;= 2.20.0',]# The rest you shouldn't have to touch too much :)# ------------------------------------------------# Except, perhaps the License and Trove Classifiers!# If you do change the License, remember to change the Trove Classifier for that!here = os.path.abspath(os.path.dirname(__file__))# Import the README and use it as the long-description.# Note: this will only work if 'README.md' is present in your MANIFEST.in file!try: with io.open(os.path.join(here, 'README.md'), encoding='utf-8') as f: long_description = '\\n' + f.read()except FileNotFoundError: long_description = DESCRIPTION# Load the package's __version__.py module as a dictionary.about = &#123;&#125;if not VERSION: with open(os.path.join(here, NAME, '__version__.py')) as f: exec(f.read(), about)else: about['__version__'] = VERSIONclass UploadCommand(Command): \"\"\"Support setup.py upload.\"\"\" description = 'Build and publish the package.' user_options = [] @staticmethod def status(s): \"\"\"Prints things in bold.\"\"\" print('\\033[1m&#123;0&#125;\\033[0m'.format(s)) def initialize_options(self): pass def finalize_options(self): pass def run(self): try: self.status('Removing previous builds…') rmtree(os.path.join(here, 'dist')) except OSError: pass self.status('Building Source and Wheel (universal) distribution…') os.system('&#123;0&#125; setup.py sdist bdist_wheel --universal'.format(sys.executable)) self.status('Uploading the package to PyPI via Twine…') os.system('twine upload dist/*') self.status('Pushing git tags…') os.system('git tag v&#123;0&#125;'.format(about['__version__'])) os.system('git push --tags') sys.exit()# Where the magic happens:setup( name=NAME, version=about['__version__'], description=DESCRIPTION, long_description=long_description, long_description_content_type='text/markdown', author=AUTHOR, author_email=EMAIL, python_requires=REQUIRES_PYTHON, url=URL, packages=find_packages(exclude=('tests',)), # If your package is a single module, use this instead of 'packages': # py_modules=['mypackage'], # entry_points=&#123; # 'console_scripts': ['mycli=mymodule:cli'], # &#125;, install_requires=REQUIRED, include_package_data=True, license='MIT', classifiers=[ # Trove classifiers # Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers 'License :: OSI Approved :: MIT License', 'Programming Language :: Python', 'Programming Language :: Python :: 3', 'Programming Language :: Python :: 3.6', 'Programming Language :: Python :: Implementation :: CPython', 'Programming Language :: Python :: Implementation :: PyPy' ], # $ setup.py publish support. cmdclass=&#123; 'upload': UploadCommand, &#125;,) 待打包的目录树： E:. │ MANIFEST.in │ out.json │ README.md │ setup.py │ └─files in.json txt.txt world.py __init__.py 12345678910ACCOUNT = 'mrli'def printHello(): print(\"hello &#123;&#125;\".format(ACCOUNT))def readTXT(): with open('txt.txt', 'r') as f: print(f.read()) # print( os.listdir() ) MANIFEST.in内容 MANIFEST.in决定了除了Py文件外的什么说明、配置文件会被打包进去(如.txt、.json) 12345678# Include the READMEinclude *.md# Include the txt fileinclude */*.txt# Include the data files# recursive-include xxxx/utils */*.json 注意我操作这边时并没有include json文件，所以生成的项目树中也没有任何的json文件（无论是in.json还是out.json），而txt.txt是包含的，并且之后甚至能用readTXT()函数，直接读取打包的txt.txt的内容。 关于MANIFEST.in 项目里会有一些非py文件，比如html和js等，这时候就要靠include_package_data 和 package_data及packages来指定了。package_data一般写成 {'your_package_name': [&quot;files&quot;]}。keywords便于pypi索引。 ▲.然而只设置了include_package_data还没完，还需要一个MANIFEST.in文件来明确指定哪些文件需要打到包中。===&gt;如果include_package_data=True的话，那么还需要写个MANIFEST.in来明确。 python setup.py install安装 安装后的目录树 │ MANIFEST.in │ out.json(这是原来就在的) │ README.md │ setup.py │ ├─build（生成的文件夹） │ ├─bdist.win-amd64 │ └─lib │ └─files │ txt.txt │ world.py │ init.py │ ├─cltest.egg-info（生成的文件夹） │ dependency_links.txt │ PKG-INFO │ requires.txt │ SOURCES.txt │ top_level.txt │ ├─dist（生成的文件夹） │ cltest-0.3.0-py3.7.egg │ └─files in.json txt.txt world.py __init__.py 一共生成了3个文件夹为build、dist、cltest.egg-info， build\\lib下的就是自己想要打包的库的内容，即files里的模块。 dist是加入到虚拟环境库下的文件venv\\Lib\\site-packages中可以找到cltest-0.3.0-py3.7.egg cltest.egg-info中有生成很多文件 dependency_links.txt空的 PKG-INFO内容是setup.py中设置的，关于库的描述 1234567891011121314151617181920212223Metadata-Version: 2.1Name: cltestVersion: 0.3.0Summary: know how toHome-page: UNKNOWNAuthor: Gao LiangAuthor-email: 10630529664@qq.comLicense: MITDescription: # 测试Setup工具 hhhh Platform: UNKNOWNClassifier: License :: OSI Approved :: MIT LicenseClassifier: Programming Language :: PythonClassifier: Programming Language :: Python :: 3Classifier: Programming Language :: Python :: 3.6Classifier: Programming Language :: Python :: Implementation :: CPythonClassifier: Programming Language :: Python :: Implementation :: PyPyRequires-Python: &gt;=3.0.0Description-Content-Type: text/markdown requires.txt：内容是setup.py中install_requires=REQUIRED里设置的依赖内容，写法参看requirements.txt SOURCES.txt：列出了所有被打包的文件 1234567891011MANIFEST.inREADME.mdsetup.pycltest.egg-info/PKG-INFOcltest.egg-info/SOURCES.txtcltest.egg-info/dependency_links.txtcltest.egg-info/requires.txtcltest.egg-info/top_level.txtfiles/__init__.pyfiles/txt.txtfiles/world.py top_level.txt：列出了可用的模块，应该是由packages=find_packages(exclude=('tests',)),决定的，由于我只写了一个包files，所以内容也只有 1files 如何使用？ 这边需要注意的是在setup.py中设置name='cltest'是指的整个库的名字，但真正使用的是要看这个库下有哪些可用的包，包下有哪些模块。 在我的这个例子下面，可以通过库名cltest来找到、下载我这个库。在安装完以后，导入就得知道包名了，这边是files，所以使用得代码应该是 12from files import worldworld.readTXT() 这个现象其实还挺常见的，比如beautifulSoup4库，使用的时候是from bs4 import ..；以及python-opencv2库，需要import cv2 as cv。其实就是这边库名与包名的区别。 坑点记录: 1234567from files import world'''def readTXT(): with open('txt.txt', 'r') as f: print(f.read())'''world.readTXT() 由于’txt.txt’是相对路径，所以只有在运行脚本位置有txt.txt文件时才不会报错，一开始from files import world时报错txt.txt以为时txt.txt没有被打包进去（其实可以通过Sources.txt文件查看到底有没有被打包进去），后来才明白是使用readTXT()的当前目录下不存在而已。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Oauth2原理、使用","slug":"Oauth2原理、使用","date":"2019-06-03T13:22:30.000Z","updated":"2019-09-15T08:07:30.966Z","comments":true,"path":"2019/06/03/Oauth2原理、使用/","link":"","permalink":"https://nymrli.top/2019/06/03/Oauth2原理、使用/","excerpt":"","text":"Oauth2原理、使用 原理 快递员–&gt;门禁–&gt;小区–&gt;我家 &lt;=====&gt; 第三方应用 --&gt; 微信墙 —&gt;账号–&gt;个人数据 简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。 OAuth 的核心就是向第三方应用颁发令牌 令牌特点： （1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。 （2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。 （3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。 OAuth是什么？ 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。…资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。 四种获得令牌的流程: 授权码（authorization-code） 1.发送请求A-&gt;B 12345https://b.com/oauth/authorize? response_type=code&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read A（客户端）-&gt;B（）response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。 第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像https://a.com/callback?code=AUTHORIZATION_CODE 第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。 123456https://b.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL 上面 URL 中，client_id参数和client_secret参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uri参数是令牌颁发后的回调网址。 第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。 123456789&#123; \"access_token\":\"ACCESS_TOKEN\", \"token_type\":\"bearer\", \"expires_in\":2592000, \"refresh_token\":\"REFRESH_TOKEN\", \"scope\":\"read\", \"uid\":100101, \"info\":&#123;...&#125;&#125; 上面 JSON 数据中，access_token字段就是令牌，A 网站在后端拿到了。 隐藏式（implicit） 有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。 12345https://b.com/oauth/authorize? response_type=token&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read response_type参数为token，表示要求直接返回令牌。 https://a.com/callback#token=ACCESS_TOKEN``token参数就是令牌，A 网站因此直接在前端拿到令牌。 ▲注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在&quot;中间人攻击&quot;的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。 密码式（password）： 如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为&quot;密码式&quot;（password）。 客户端凭证（client credentials） 适用于没有前端的命令行应用，即在命令行下请求令牌。 clientID和ClientSecret均是App需要申请的API密钥 使用 Github Oauth QQ Oauth 本地测试QQ的写法 12345678910111213141516171819202122232425262728293031323334353637383940414243# 方法一：在hosts中将nymrli.top修改到127.0.0.1@app.route('/login')def login(): params = &#123; 'response_type' : 'code', 'client_id' : '101568872', 'redirect_uri' : 'http://beta.nymrli.top/oauth/qq', 'state' : '1', &#125; url = 'https://graph.qq.com/oauth2.0/authorize?' urlParams = urlencode(params) # ▲需要url编码 comleteUrl = url + urlParams # return url_for( ) ''' ▲应该用redirect，而不是requests.get的text内容或者是url_for ''' return redirect( comleteUrl) @app.route('/oauth/qq')def getCode(): return request.args.get('code') # 方法二：随便申请一个应用@app.route('/login')def login(): params = &#123; 'response_type' : 'code', 'client_id' : '101584056', # 'redirect_uri' : 'http://beta.nymrli.top/oauth/qq', 'redirect_uri' : 'http://127.0.0.1:8000/oauth/redirect', 'state' : 'test' &#125; url = 'https://graph.qq.com/oauth2.0/authorize?' urlParams = urlencode(params) comleteUrl = url + urlParams return redirect( comleteUrl)@app.route('/oauth/redirect')def getCode(): print(request.args) return 'hello' 坑点记录：部署 经过调试发现部署上去后，在http://beta.nymrli.top/info页面下获得不到 access_token = session.get('access_token')于是猜想session设置有问题。果然linux下os.urandom(24)有问题， 结果是无法获得到信息。经修改后能正常获得结果 1SECRET_KEY= os.urandom(24) # 设置为24位的字符,每次运行服务器都是不同的，所以服务器启动一次上次的session就清除。 改成随便的SECRET_KEY的就行了，比如SECRET_KEY='asdzxcqwe'","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Web","slug":"Web","permalink":"https://nymrli.top/tags/Web/"}]},{"title":"lua学习","slug":"lua学习","date":"2019-06-03T13:22:03.000Z","updated":"2019-09-15T08:07:30.962Z","comments":true,"path":"2019/06/03/lua学习/","link":"","permalink":"https://nymrli.top/2019/06/03/lua学习/","excerpt":"","text":"lua学习 动态脚本语言，可嵌入C和C++，Lua负责逻辑，C、C++负责功能 C编译，跨平台性良好 12345678910111213141516-- 循环结构 [1,10]for i=1,10 do print(i)end-- 函数function function_name( ... ) -- bodyend-- 选择结构if elseend 表{} &lt;==&gt;字典 12345678910Conftg=&#123; hello=\"Hello Lua\", world=\"World\"&#125;Config.words=\"Hello\"Config.num=180Config[\"name\"]=\"ZhangSan\"print(Config[\"words\"])print(Config. name)print(Config, hello)for key, var in pairs(Config) do print(key, var)end 数组{} 12345678910arr = &#123;1,2,3,'hello'&#125;for k,v in pairs(arr) do print(k,v)end&gt;&gt;&gt; 1 12 2 3 3 4 hello ▲索引从1开始 使用APItable 1234567891011-- 数组插入for i=1,10 do table.insert( arr , 1, i) -- 经sxh发现结果是逆序的,19-&gt;2,20-&gt;1 ， 原因是每次都从头部插入，相当于LIFO , 此时感觉像是数组（带索引key）...并且table.insert( arr , 2, i)结果只有2--&gt;20 ，此时像字典（只有键2） -- 正序的顺出 table.insert( arr , i) -- 默认在尾部开始插入 -- 或者arr[i] = iend-- 获得数组长度table.maxn(arr) 面向对象 没有class类关键字，但可以自己实现类的功能： 复制表table 函数闭包 复制表table 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364people = &#123;&#125;-- 法一function people.sayHi() print('Hi')end-- 法二people.sayHi = function () print('Hi') end-- 拷贝function clone( tab ) local arr = &#123;&#125; for k,v in pairs(tab) do arr[k] = tab[v] end return arrend-- 相当于是构造方法People.new = function (name) local self = clone(People) self.name = name return self end-- 成员函数People.sayHi = function(self) -- self是类示例变量 -- ..是字符串连接 print(\"People say hi:\".. self. name)end -- 测试可以实现类的功能--local p = clone(People)--p.sayHi()-- 测试构造函数local p = People.new(\"ZhangSan\")-- 需要传类示例p.sayHi(p)-- 使用：可以不用传类示例p:sayHi()Man=&#123;&#125;-- 实现类的继承的功能Man.new = function (name) local self =People.new(name) copy(self, Man) return self end-- 增添成员函数Man.sayHello=function() print(\"Man say hello\")end -- 重写成员函数Man.sayHi = function (self) print(\"Man sayHi\".. self.name)end 函数闭包 123456789101112131415161718192021222324function People() local self = &#123;&#125; function init( name ) self.name = name end function sayHello() print(\"Hello \"..self.name) end init() return selfend-- 继承function Man(name) local self= People(name) -- local function init() -- end self.sayHello=function () print(\"hello\"..self.name) end return selfend 学习自 https://www.bilibili.com/video/av46428956/?p=8 通过表的特性实现switch关键字功能 1234567891011121314local key = 1 local switch = &#123; [1] = function() print(\"switch:\"..1) end, [2] = function() print(\"switch:\"..2) end, [\"test\"] = function() print(\"switch:test\") end, &#125; switch[2]()-- &gt;&gt;&gt; 2 伪随机数的生成 123456-- 因此“短时间内多次运行程序” 这样的需求下 os.time 还真不大好。可是又没有比 time 函数更方便的种子生成器， 怎么办呢？math.randomseed(tostring(os.time()):reverse():sub(1, 6))for i=1, 5 do print(math.random(4))end-- 就是把 time返回的数值字串倒过来（低位变高位）， 再取高位6位。 这样， 即使 time变化很小， 但是因为低位变了高位， 种子数值变化却很大，就可以使伪随机序列生成的更好一些","categories":[],"tags":[{"name":"lua","slug":"lua","permalink":"https://nymrli.top/tags/lua/"}]},{"title":"Java课程第三次实验报告","slug":"Java课程第三次实验报告","date":"2019-06-03T13:21:19.000Z","updated":"2019-09-15T08:07:30.947Z","comments":true,"path":"2019/06/03/Java课程第三次实验报告/","link":"","permalink":"https://nymrli.top/2019/06/03/Java课程第三次实验报告/","excerpt":"","text":"Java课程第三次实验报告 \\1. 在前面实验二已定义的学生类Student的基础上，以Student类为父类，为学生类派生出一个子类为大学生类（CollegeStudent）。 CollegeStudent 类在学生类上增加一个专业（profession）数据属性；方法上增加获得专业和设置专业两个方法。并对超类中的toString( )方法进行重写，使得CollegeStudent类中的toString( )方法除了显示学生类的信息外，还要显示它的专业属性。 编写测试程序的主类。在主类中创建一个Student对象和CollegeStudent对象，并显示或修改这两个对象的属性值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//package homework; package student ; public class Student &#123; private int UID; private String name; private Boolean gender; // G- B- private int age; static int cnt ; public Student() &#123;&#125; public Student(int UID,String name,Boolean gender,int age) &#123; cnt ++ ; this.UID = UID; this.name = name; this.gender = gender; this.age = age; &#125; /** * @target 获得私有参数 */ public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public Boolean getGender() &#123; return gender; &#125; public int getUID() &#123; return UID; &#125; /** * @target 修改私有参数 */ public void setAge(int age) &#123; this.age = age; &#125; public void setUID(int uID) &#123; UID = uID; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setGender(Boolean gender) &#123; this.gender = gender; &#125; @Override protected void finalize() throws Throwable &#123; // TODO Auto-generated method stub System.out.println(\"对象已被销毁\");; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub if (gender) return \"该同学的学号为：\" + UID +\"，姓名叫：\" + name + \"，性别：男\" + \"，年龄：\" + age; return \"该同学的学号为：\" + UID +\"，姓名叫：\" + name + \"，性别：女\" + \"，年龄：\" + age; &#125; public static int getCnt() &#123; return cnt; &#125; &#125; //新建立的CoolegeStudent对象 class CollegeStudent extends Student&#123; private String profession; CollegeStudent(int studentID, String name, Boolean sex, int age, String profession) &#123; super( studentID, name, sex, age ); this.profession = profession; &#125; public String getProfession() &#123; return profession; &#125; public void setProfession(String profession) &#123; this.profession = profession; &#125; @Override public String toString() &#123; return \"CollegeStudent&#123;\" + \"profession='\" + profession + '\\'' + \"studentID='\" + super.getUID() + '\\'' + \", name='\" + super.getName() + '\\'' + \", sex='\" + super.getGender() + '\\'' + \", age=\" + super.getAge() + '&#125;'; &#125; &#125; 设计一个人员类（Person），其中包含一个方法pay，代表人员的工资支出。再从Person类派生出助教类（Assistant）、讲师类（Instructor）、副教授类（Assistant Professor）和教授类（Professor）。其中：工资支出=基本工资+授课时数*每课时兼课金。 但助教基本工资为800，每课时兼课金25，讲师基本工资为1000，每课时兼课金35， 副教授基本工资为1200，每课时兼课金40，教授基本工资为1400，每课时兼课金50。 1.将Person定义为抽象类，pay为抽象方法，设计程序实现多态性。 2.将Person定义为接口，设计程序实现多态性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//Person写成类： class Person &#123; public int basic; public int hour; public int charge; public Person() &#123; &#125; public Person(int basic, int charge) &#123; this.basic = basic; this.charge = charge; &#125; public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (basic + hour * charge) ); &#125; &#125; class Assistant extends Person &#123; public Assistant() &#123; super( 800, 25 ); &#125; &#125; class Instructor extends Person &#123; public Instructor() &#123; super( 1000, 35 ); &#125; &#125; class AssistantProfessor extends Person &#123; public AssistantProfessor() &#123; super( 1200, 40 ); &#125; &#125; class Professor extends Person &#123; public Professor() &#123; super( 1400, 50 ); &#125; &#125; //Person写成抽象类 abstract class Person &#123; public int hour; public abstract void pay(int hour); class Assistant extends Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (800 + hour * 25) ); &#125; &#125; class Instructor extends Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1000 + hour * 35) ); &#125; &#125; class AssistantProfessor extends Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1200 + hour * 40) ); &#125; &#125; class Professor extends Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1400 + hour * 50) ); &#125; &#125; /** * @author mrli * 接口写法 */ interface Person &#123; void pay(int hour); &#125; class Assistant implements Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (800 + hour * 25) ); &#125; &#125; class Instructor implements Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1000 + hour * 35) ); &#125; &#125; class AssistantProfessor implements Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1200 + hour * 40) ); &#125; &#125; class Professor implements Person &#123; @Override public void pay(int hour) &#123; System.out.println( hour + \"小时后的工资为\" + (1400 + hour * 50) ); &#125; &#125; 从键盘输入两个数，进行相除，显示商。当输入串中含有非数字时或除数为0时，通过异常处理机制，使程序能正确运行。 1234567891011121314151617181920212223242526import java.util.InputMismatchException; import java.util.Scanner; public class yichang &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; Scanner scanner = new Scanner(System.in); System.out.print( \"请输入除数:\" ); int dividedNum = scanner.nextInt(); System.out.print( \"请输入被除数:\" ); int divNum = scanner.nextInt(); System.out.println( \"计算结果：\" + dividedNum / divNum ); &#125; catch (InputMismatchException e1) &#123; // TODO: handle exception System.out.println(\"输入不为数字!\"); &#125;catch (ArithmeticException e2) &#123; // TODO: handle exception System.out.println(\"不能除0!\"); &#125; &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"南京邮电大学java程序设计作业在线编程第八次作业","slug":"南京邮电大学java程序设计作业在线编程第八次作业","date":"2019-06-03T13:20:12.000Z","updated":"2019-09-15T08:07:31.037Z","comments":true,"path":"2019/06/03/南京邮电大学java程序设计作业在线编程第八次作业/","link":"","permalink":"https://nymrli.top/2019/06/03/南京邮电大学java程序设计作业在线编程第八次作业/","excerpt":"","text":"总分：100 选择题得分：70 int[][] a=new int[2][3]，则该数组包含（ ）个数组元素。 A.2 B.3 C.6 D.不确定 正确答案是: C 已知类person是类student的父类，以下数组定义和赋值正确的是( )。 A.person p[]=new person[3]; p[1]=new student(); B.student s[]=new person[3]; s[1]=new person(); C.person p[]= new student[3];p[1]= new person(); D.student s[]=new student[3];s[1]=new person; 正确答案是: A 下面关于java中类的说法不正确的是( )。 A.类体中包含了变量定义和成员方法的定义 B.构造函数是类中的特殊方法 C.类一定要声明为public的，才可以执行 D.一个java文件中可以有多个class定义 正确答案是: C 关于接口下列说法正确的( )。 A.实现一个接口必须实现接口的所有方法 B.接口间不能有继承关系 C.一个类只能实现一个接口 D.接口和抽象类是同一回事 正确答案是: A 以下有关构造方法的说法，正确的是( )。 A.一个类的构造方法可以有多个 B.构造方法不可以重载 C.构造方法可以有返回值 D.构造方法可以和类同名，也可以和类名不同 正确答案是: A 下列论述中，错误的是（ ）。 A.Java源代码的后缀名是.java。 B.Java源代码中的每个类经过编译后都会生成一个.class文件。 C.在一个名为A.java的文件中只能定义一个类。 D.Java源代码中可以定义类和接口。 正确答案是: C 下列论述中，正确的是（ ）。 A.抽象方法是没有方法体的方法。 B.抽象方法一定存在于抽象类中。 C.抽象类中一定要包含抽象方法。 D.抽象类可以创建对象。 正确答案是: A MyClass类定义如下： class MyClass{ public MyClass(int x){ } } 如下方式创建对象，（ ）是正确的 A.MyClass myobj=new Myclass; B.MyClass myobj=new Myclass(); C.MyClass myobj=new Myclass(1); D.MyClass myobj=new Myclass(1,2); 正确答案是: C 关于方法void fjv(int x,int y){}，下面（ ）不能成为它的重载。 A.void fjv(int x,float y){} B.void fjv(int x){} C.void fjv(float x,int y){} D.int fjv(int y,int x){} 正确答案是: D 下述（ ）说法是不正确的 A.实例变量是用static关键字声明的； B.实例变量是类的成员变量； C.方法变量可在方法执行时创建； D.方法变量在使用之前必须初始化； 正确答案是: A 如果一个方法被修饰为________方法，则这个方法不能被重写。 A.final B.static C.void D.protected 正确答案是: A 在Java中，下面说法正确的是（ ）。 A.一个子类可以有多个父类，一个父类也可以有多个子类 B.一个子类可以有多个父类，但一个父类只可以有一个子类 C.一个子类可以有一个父类，但一个父类可以有多个子类 D.上述说法都不对 正确答案是: C ___________变量在内存中只有一个拷贝，被该类的所有对象共享。 A.成员 B.局部 C.全局 D.类 正确答案是: D MAX_LENGTH是int型public成员变量, 变量值保持为常量100，下面哪句定义语句是正确的。 A.public int MAX_LENGTH=100; B.final int MAX_LENGTH=100; C.final public int MAX_LENGTH=100; D.public final int MAX_LENGTH=100; 正确答案是: D 1234567891011121314151617181920212223242526272829303132333435363738394041// 编写Main类，生成若干实例并验证程序的功能，请勿改动Main类的定义内容。public class Main&#123; public static void main(String[] args) &#123; Pet pet=new Dog(\"WangCai\"); System.out.println(pet.getName()+\":\"+pet.shout()); pet=new Cat(\"XiaoHua\"); System.out.println(pet.getName()+\":\"+pet.shout()); &#125;&#125;// 请在本行之后添加你的代码内容abstract class Pet&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; abstract String shout();&#125;class Dog extends Pet&#123; Dog(String name) &#123; setName( name ); &#125; @Override String shout() &#123; return \"Wang Wang Wang\"; &#125;&#125;class Cat extends Pet&#123; Cat(String name) &#123; setName( name ); &#125; @Override String shout() &#123; return \"Miao Miao Miao\"; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Windows下命令行神器cmder","slug":"Windows下命令行神奇cmder","date":"2019-06-03T13:17:28.000Z","updated":"2019-09-15T08:07:31.014Z","comments":true,"path":"2019/06/03/Windows下命令行神奇cmder/","link":"","permalink":"https://nymrli.top/2019/06/03/Windows下命令行神奇cmder/","excerpt":"","text":"Cmder 安装 http://cmder.net/ 有两个版本，分别是mini与full版 mini 没有内建msysgit工具，这是Git for Windows的标准配备； 全安装版 cmder 自带了 msysgit, 压缩包 108M 除了 git 本身这个命令之外, 里面可以使用大量的 linux 命令；比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl 可以交叉使用 cygwin 的部分增强命令 把 cmder 加到环境变量 将解压后的文件夹路径加入到系统环境变量的Path中 添加 cmder 到右键菜单 配置环境变量后，在管理员权限的终端输入以下语句 Win 8 或者 Win10 可以直接 win+x 再按 a 键进入 或者在开始中输入命令，然后在弹出的最佳匹配中，选择命令行工具右键-&gt;以管理员身份打开 1Cmder.exe /REGISTER ALL 修改命令提示符号 1.3 之后版本 修改文件 ${CMDER_HOME}\\vendor\\clink.lua 12345if env == nil then lambda = &quot;λ&quot;else lambda = &quot;(&quot;..env..&quot;) λ&quot;end 改成 12345if env == nil then lambda = &quot;$&quot;else lambda = &quot;(&quot;..env..&quot;) $&quot;end 其他符号也行，看你自己的喜好 1.3 以前版本 编辑Cmder安装目录下的 vendor\\init.bat 批处理文件 1@prompt $E[1;32;40m$P$S&#123;git&#125;&#123;hg&#125;$S$_$E[1;30;40m &#123;lamb&#125; $S$E[0m 修改为 1@prompt $E[1;32;40m$P$S&#123;git&#125;&#123;hg&#125;$S$_$E[1;30;40m $$ $S$E[0m PowerShell.exe 需要另外设置 打开文件 config/cmder.lua（prompt.lua 也有版本是这个），将第二行中的λ修改为**$** 新标签打开个管理员权限终端 快捷键 Ctrl + t 后勾选Run as administrator 设置默认终端 如果你有其它的command希望通过 Cmder 打开，可以在 Startup 下的 Tasks 中添加。里面已经默认帮你配置了 Cmder、PowerShell、MinTTY、Git Bash。 默认启动的是 Cmder ，如果你想默认启动其它的command，你可以在 Startup 设置为其它的command 同时还可以快速的切换当前使用的终端，假设你正在使用的 cmd ，这时输入 bash 回车一下，便可以将当前标签页的终端切换成 Git Bash 中文和命令ll支持 Cmder 是不支持中文，这需要你在 Startup 下的 Environment 中设置一下。将 set LANG=zh_CN.UTF-8 cmder原生没有 ll 命令，但可以通过设置别名来实现：打开cmder安装目录下的\\config\\user-aliases.cmd文件，添加以下别名设置： Chocolatey软件包管理系统 chocolatey 是windows 下面的 yum brew 这种包管理器 运行如下命令(需要管理员权限) 1@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin 安装软件命令 choco install softwareName, 短写是 cinst softwareName 查询安装包是否存在 clist softwareName 可安装包列表 window下常用的开发环境应用 123456789101112choco install autohotkey.portable #安装 AutoHotkey (Portable)choco install nodejs.install #安装 nodechoco install git.install #安装 gitchoco install python #安装 pythonchoco install ruby #安装 rubychoco install jdk8 #安装 JDK8choco install googlechrome #安装 Chromechoco install google-chrome-x64 #Google Chrome (64-bit only)choco install firefox #安装 firefoxchoco install notepadplusplus.install #安装 notepad++choco install Atom #安装 Atomchoco install SublimeText3 #安装 SublimeText3","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"安利","slug":"安利","permalink":"https://nymrli.top/tags/安利/"}]},{"title":"微信公众号Pyhton","slug":"微信公众号Pyhton","date":"2019-05-27T14:01:10.000Z","updated":"2019-09-15T08:07:31.063Z","comments":true,"path":"2019/05/27/微信公众号Pyhton/","link":"","permalink":"https://nymrli.top/2019/05/27/微信公众号Pyhton/","excerpt":"","text":"微信公众号Pyhton开发 编写上传代码到SAE 1.申请SAE（sina application enginer），创建应用，SAE使用文档 2.编写上传代码 weixin.py 12345678910111213141516171819202122232425262728#-*-coding:utf-8-*-import web import os import hashlib import time class WeixinInterface: def __init__(self): self.app_root=os.path.dirname(__file__) self.templates_root=os.path.join(self.app_root,'templates') self.render=web.template.render(self.templates_root) def GET(self): data=web.input() signature=data.signature timestamp=data.timestamp nonce=data.nonce echostr=data.echostr token=\"wxpython\" l=[token,timestamp,nonce] l.sort() sha1=hashlib.sha1() map(sha1.update,l) hashcode=sha1.hexdigest() if hashcode == signature: return echostr index.wsgi 12345678910111213141516171819#-*-coding:utf-8-*-import os import saeimport web from weixin import WeixinInterface urls=(&apos;/weixin&apos;,&apos;WeixinInterface&apos;)app_root=os.path.dirname(__file__)templates_root=os.path.join(app_root,&apos;templates&apos;)render=web.template.render(templates_root)app=web.application(urls,globals()).wsgifunc()application=sae.create_wsgi_app(app) config.yaml 123456789101112name: wxpytest version: 1libraries:- name: webpy version: \"0.36\"- name: lxml version: \"2.3.4\"... ​ 3.微信公众号修改服务器配置 Token与代码中编写的保持一致，URL也要与指定的一致(即...\\weixin)。 注意直接访问&lt;http://vxquan.applinzi.com/weixin&gt;是会报错的，但是可以通过微信公众平台的认证（因为直接访问是没有参数的，data=web.input没有异常处理） 处理普通文本信息 12345678&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt; &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt; ▲.注意这边的OpenID不是真正的用户ID，不同公众号对相同用户获得的OpenID是不同的，换言之，这个只是该公众号能获得该用户的一个ID。 12345678910def POST(self): str_xml=web. data() xml=etree.fromstring(str_xml) msgType=xml.find(\"MsgType\").text fromuser=xml.find(\"FromUserName\").text touser=xml.find(\"ToUserName\").text if msgType==\"text\": content=xml. find(\"Content\").text return self.render.reply_text(fromuser,touser,int(time.time()),content) # 注意这边To和from的改变，服务器(发送)--&gt;wx后台--&gt;用户(接收) 记遇到的坑： 1.POST好像必须要有处理，返回信息 python2.7下字符串加u","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"Web","slug":"Web","permalink":"https://nymrli.top/tags/Web/"}]},{"title":"DigitalOcean VPS注册","slug":"DigitalOcean-VPS注册","date":"2019-05-27T13:57:56.000Z","updated":"2020-02-15T11:57:13.124Z","comments":true,"path":"2019/05/27/DigitalOcean-VPS注册/","link":"","permalink":"https://nymrli.top/2019/05/27/DigitalOcean-VPS注册/","excerpt":"","text":"DigitalOcean VPS搭梯子 DigitalOcean VPS注册 首先通过 邀请链接(https://m.do.co/c/e89da76f57f2)点进去注册，双方都会获得$10奖励（注意是注册，我当时就没注意到，少了10$ 然后在Github Education申请学生优惠，注意这边的学生优惠邮箱是校园邮箱(xxxx@njupt.edu.cn)那个。我当时是将github账号与校园邮箱进行链接的。 学生优惠申请到后，pack界面会变成这样 进入DO的页面后，用学校邮箱注册后，选用Paypal支付（先注册好Paypal），然后支付即可。 ▲由于一开始我并没有使用学校邮箱注册，而是QQ邮箱，后来又注册了以后，发现这个账号被锁了，付的$5也退了回来。按网上的说法，DO会直接锁了我的账号，原因是一个人注册了多个账号。于是找解决方案。 网上说要发邮件，其中比较关键的是Ticket，一开始一直没找到，后来才发现这个是在support中选出来的. 等了一天最终收到的答复却是： 我们检查了该帐户，发现它符合与违反我们的服务条款和可接受使用策略相关的异常模式。虽然我们无法提供所观察到的特定标志的详细信息，但我们已经确定，恢复对该帐户的访问是不可能的。不便之处，敬请原谅。 最终无奈之下，想起了使用的话跟学校邮箱没关系，那个只是提供优惠券的。于是重新尝试了下第一个注册的账号pay了$5以后就成功了。 创建主机 SSR: [搭建SSR科学上网（利用DigitalOcean服务器）](https://blog.ooolg.com/index.php/20181125/131=131.html) V2Ray 从零开始：史上最详尽V2Ray搭建图文教程 使用优惠券 DigitalOcean 的学生包代金券使用教程 输入Github Education上获得的优惠券Code，就能拿到$50的优惠券了 附录 ubuntu一键更换内核 安装锐速 - 16.04 14.04可用 PAC和全局模式 1.在全局模式下，所有的网站都默认走代理（使你的所有http/socks数据经过代理服务器的转发送出。） 2.在PAC模式是只有被墙了的网站才会走代理（连接网站的时候读取PAC文件里的规则，来确定你访问的网站有没有被墙，如果符合，那就会使用代理服务器连接网站） 优惠网站 https://xianhuo.org/2016digitalocean-youhuima.html 未测试","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"PyWinAuto使用","slug":"PyWinAuto使用","date":"2019-05-27T13:54:45.000Z","updated":"2020-11-07T03:45:50.734Z","comments":true,"path":"2019/05/27/PyWinAuto使用/","link":"","permalink":"https://nymrli.top/2019/05/27/PyWinAuto使用/","excerpt":"","text":"PyWinAuto使用 简单操作示例： 12app = application.Application().start(r'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe')# app = application.Application().start('notepad.exe') (一) 判断程序的backend 注意，首先需要判断你要进行的程序是用什么语言写的，在实例化的时候会有区别，主要是判断backend是什么。 (二)确定自动化入口点 这里主要是限制自动化控制进程的范围。如一个程序有多个实例，自动化控制一个实例，而保证其他实例(进程)不受影响。 主要有两种对象可以建立这种入口点——Application() , Desktop(). Application的作用范围是一个进程，如一般的桌面应用程序都为此类。 Desktop的作用范围可以跨进程。主要用于像win10的计算器这样包含多个进程的程序。这种目前比较少见。使用方法见entry-points-for-automation (三)连接到进程 建立好入口后，我们需要连接到进程中。这里有两种方法: 使用Application对象的start()方法 app = Application().start(r&quot;D:\\Program Files (x86)\\tlxsoft\\屏幕录像专家 共享版 V2017\\屏录专家.exe&quot;) 连接到已有的进程。使用Application对象的connect()方法。这个方法对已有进程的绑定非常灵活。 app = Application().connect(process=19188) 使用窗口句柄绑定 app = Application().connect(handle=0x00230DB6) 使用程序路径绑定★ app = Application().connect(path=r&quot;D:\\Program Files (x86)\\tlxsoft\\屏幕录像专家 共享版 V2017\\屏录专家.exe&quot;) 使用标题、类型等匹配★★（灵活性比较高） app = Application().connect(title_re=&quot;屏幕录像专家.*&quot;, class_name=&quot;TMainForm&quot;) 菜单操作 12dlg_spec = app.window(title='屏幕录像专家 V2017')dlg_spec.menu_select(r\"转换工具-&gt;EXE/LXE转成MP4\") 快捷键操作 12dlg_spec = app.window(title='屏幕录像专家 V2017')dlg_spec.type_keys('%TP') 1234567891011121314151617181920212223242526272829303132333435SHIFT + CTRL ^ ALT %空格键 &#123;SPACE&#125; BACKSPACE &#123;BACKSPACE&#125;、&#123;BS&#125; or &#123;BKSP&#125; BREAK &#123;BREAK&#125; CAPS LOCK &#123;CAPSLOCK&#125; DEL or DELETE &#123;DELETE&#125; or &#123;DEL&#125; DOWN ARROW &#123;DOWN&#125; END &#123;END&#125; ENTER &#123;ENTER&#125; or ~ ESC &#123;ESC&#125; HELP &#123;HELP&#125; HOME &#123;HOME&#125; INS or INSERT &#123;INSERT&#125; or &#123;INS&#125; LEFT ARROW &#123;LEFT&#125; NUM LOCK &#123;NUMLOCK&#125; PAGE DOWN &#123;PGDN&#125; PAGE UP &#123;PGUP&#125; PRINT SCREEN &#123;PRTSC&#125; RIGHT ARROW &#123;RIGHT&#125; SCROLL LOCK &#123;SCROLLLOCK&#125; TAB &#123;TAB&#125; UP ARROW &#123;UP&#125; + &#123;ADD&#125; - &#123;SUBTRACT&#125; * &#123;MULTIPLY&#125; / &#123;DIVIDE&#125;F1 &#123;F1&#125; F2 &#123;F2&#125; F3 &#123;F3&#125; .....F15 &#123;F15&#125; F16 &#123;F16&#125; 参考 pywinauto 使用 [python自动化工具之pywinauto](https://www.cnblogs.com/mapu/p/9235587.html)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"Google Colab使用","slug":"Google-Colab使用","date":"2019-05-27T13:53:31.000Z","updated":"2019-09-15T14:02:20.372Z","comments":true,"path":"2019/05/27/Google-Colab使用/","link":"","permalink":"https://nymrli.top/2019/05/27/Google-Colab使用/","excerpt":"","text":"Google Colab使用 Google colab(Colaboratory)在编辑时候和jupyter notebook类似，并且提供免费的GPU以供使用，这对于需要处理大量数据运算的机器项目来说再合适不过了。挺香的 新建一个笔记本（.ipynb）后，选择&quot;修改-&gt;笔记本设置-&gt;硬件加速器-&gt;GPU&quot;就可以想要用英伟达Tesla K80 GPU啦(2599美元一块) colab中文件交互 文档里提供了四种方式，分别是： 从本地直接上传 连接Google Drive 连接Google Sheet 连接Google Cloud Storage 与本地文件交互 本地文件上传 files.upload() 返回一个由我们上传的所有文件构成的一个字典。 这个字典的key是文件名, 这个字典的value是我们上传的文件的data。 123456from google.colab import filesuploaded = files.upload()for fn in uploaded.keys(): print(&apos;User uploaded file &quot;&#123;name&#125;&quot; with length &#123;length&#125; bytes&apos;.format(name=fn, length=len(uploaded[fn]))) 从colab下载文件到本地 1234from google.colab import fileswith open(&apos;example.txt&apos;, &apos;w&apos;) as f: f.write(&apos;some content&apos;)files.download(&apos;example.txt&apos;) 连接Google Drive PyDrive 这里官方有提供了许多种方法。这里我就挑一种介绍了，有兴趣的可以点进这个Colab官方文档进去看。 这里只介绍使用PyDrive的方法。PyDrive是google-api-python-client的包装库，简化了许多常见的Google Drive API任务。 12345678910111213141516171819202122232425!pip install -U -q PyDrivefrom pydrive.auth import GoogleAuthfrom pydrive.drive import GoogleDrivefrom google.colab import authfrom oauth2client.client import GoogleCredentials# 1. 验证身份并创建pydrive客户端.auth.authenticate_user()gauth = GoogleAuth()gauth.credentials = GoogleCredentials.get_application_default()drive = GoogleDrive(gauth)# PyDrive 参考:# https://gsuitedevs.github.io/PyDrive/docs/build/html/index.html# 2. 创建并上传一个文本文档.uploaded = drive.CreateFile(&#123;'title': 'Sample upload.txt'&#125;)uploaded.SetContentString('Sample upload file content')uploaded.Upload()print('Uploaded file with ID &#123;&#125;'.format(uploaded.get('id')))# 3. 通过id访问文件并输出它的内容.downloaded = drive.CreateFile(&#123;'id': uploaded.get('id')&#125;)print('Downloaded content \"&#123;&#125;\"'.format(downloaded.GetContentString())) Mounting Google Drive locally 首先把整个项目工程上传到 Google Drive 中，然后在该项目文件夹下（执行的主函数文件同一目录）新建一个 run.ipynb。新建方法与之前一样，在项目文件夹中 右键-更多-Colaboratory。 然后，在新建的笔记本中挂载 Google Drive： 12from google.colab import drivedrive.mount(&apos;/content/drive/&apos;) 执行以上语句后，会出现一个链接。点击链接，获取并键入 authorization code，回车，等待圈圈转完就能在左侧刷新，看到挂载的Drive 挂载 Drive 网上还有另一种方法，语句很多很复杂，但这个好像没啥区别。。 对于这个服务器而言，整体目录结构是这样的： 顶级目录为 content，我们进入笔记本后无论笔记本在哪，当前工作目录都是 /content。/content下默认有 sample_data 目录，其中包括运行示例程序的一些必要数据文件。我们的 Google Drive 作为一个 My Drive 文件夹挂载在 /content/drive 文件夹下。我的项目是“我的云端硬盘”里的一个tiny-yolo文件夹，因此我的项目的路径应该为 /content/drive/My Drive/tiny-yolo。这里大家试一试就明白了，比我说啥都快。 注意事项 为了保证资源的合理分配，google 会按照一定机制将服务器回收：它会一定时间后自动回收已连接但闲置的服务器，和有运行代码但未连接的服务器。所以想挂机跑代码，要保证与服务器保持连接（不掉线），否则一早起来可能就会发现它被悄悄的回收了。稍微掉线个几分钟就连回去是没什么问题的。 在回收服务器后，写到 My Drive 以外其他文件夹下的文件都将被删除，下次再连接就是一台崭新的服务器了。 挂载 Drive 后再向 Google Drive上传文件，同步到 notebook 那边会有一定的延迟，大概等个几秒钟到半分钟不等，多刷新几下就会出现了。删除文件也是。然而在删除 a.py 后，如果没等 notebook 那边反应过来就重新再传一个 a.py，notebook 那边很可能就出现一个被重命名的文件 a(1).py。。难道是我姿势不对？？ 有一次我上传近 3000 张图片作为训练集到 Drive，上传成功，但是 notebook 没读全，!ls “/content/drive/My Drive/tiny-yolo/data” | wc -l 看一眼花式少文件，我也不知道为啥。。总是迷之过会 (hen) 儿 (jiu) 就好了。。搞得我也是很醉。 如何使用google drive的免费GPU进行深度学习 连接Google Sheet 连接Google Cloud Storage 参考：colab读写外部文件的四种方式","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"图像处理","slug":"图像处理","permalink":"https://nymrli.top/tags/图像处理/"}]},{"title":"Keras使用——图像增强","slug":"Keras使用——图像增强","date":"2019-05-27T13:52:14.000Z","updated":"2019-09-15T08:07:30.952Z","comments":true,"path":"2019/05/27/Keras使用——图像增强/","link":"","permalink":"https://nymrli.top/2019/05/27/Keras使用——图像增强/","excerpt":"","text":"Keras使用——图像增强 使用Keras进行深度学习的图像增强（Image Augmentation） Keras是一个高层神经网络API，Keras由纯Python编写而成并基Tensorflow、Theano以及CNTK后端。 Keras为支持快速实验而生，能够把你的idea迅速转换为结果，如果你有如下需求，请选择Keras： 简易和快速的原型设计（keras具有高度模块化，极简，和可扩充特性） 支持CNN和RNN，或二者的结合 无缝CPU和GPU切换 ImageDataGenerator Keras提供了ImageDataGenerator类，定义关于图片准备和增强的配置。包括以下功能：样本级的标准化特征级的标准化ZCA白化.随机旋转、转换、剪切、翻转维度重排.将增强的图片保存在本地. 1234567891011121314151617181920212223from keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_imgimport osDatagen = ImageDataGenerator(rotation_range=20, shear_range=0.2, zoom_range=0.2, horizontal_flip=True, vertical_flip = True, fill_mode='nearest')for file_name in os.listdir('.'): if file_name =='.config' or file_name == 'sample_data': continue img = load_img(file_name) x_img = img_to_array(img) x_img = x_img.reshape((1,)+ x_img.shape) i = 0 for img_batch in Datagen.flow(x_img, batch_size=32, save_to_dir='.', save_prefix='candy', save_format='jpg'): i +=1 if i &gt; 10: break ImageDataGenerator参数详解及用法实例 12345678910111213141516171819keras.preprocessing.image.ImageDataGenerator(featurewise_center=False, samplewise_center=False, featurewise_std_normalization=False, samplewise_std_normalization=False, zca_whitening=False, zca_epsilon=1e-6, rotation_range=0., width_shift_range=0., height_shift_range=0., shear_range=0., zoom_range=0., channel_shift_range=0., fill_mode='nearest', cval=0., horizontal_flip=False, vertical_flip=False, rescale=None, preprocessing_function=None, data_format=K.image_data_format()) ▲用以生成一个batch的图像数据，支持实时数据提升。训练时该函数会无限生成数据，直到达到规定的epoch次数为止。 featurewise_center：布尔值，使输入数据集去中心化（均值为0）, 按feature执行 samplewise_center：布尔值，使输入数据的每个样本均值为0 featurewise_std_normalization：布尔值，将输入除以数据集的标准差以完成标准化, 按feature执行 samplewise_std_normalization：布尔值，将输入的每个样本除以其自身的标准差 zca_whitening：布尔值，对输入数据施加ZCA白化 zca_epsilon: ZCA使用的eposilon，默认1e-6 rotation_range：整数，数据提升时图片随机转动的角度 width_shift_range：浮点数，图片宽度的某个比例，数据提升时图片水平偏移的幅度 height_shift_range：浮点数，图片高度的某个比例，数据提升时图片竖直偏移的幅度 shear_range：浮点数，剪切强度（逆时针方向的剪切变换角度） zoom_range：浮点数或形如[lower,upper]的列表，随机缩放的幅度，若为浮点数，则相当于[lower,upper] = [1 - zoom_range, 1+zoom_range] channel_shift_range：浮点数，随机通道偏移的幅度 fill_mode：；‘constant’，‘nearest’，‘reflect’或‘wrap’之一，当进行变换时超出边界的点将根据本参数给定的方法进行处理 cval：浮点数或整数，当fill_mode=constant时，指定要向超出边界的点填充的值 horizontal_flip：布尔值，进行随机水平翻转 vertical_flip：布尔值，进行随机竖直翻转 rescale: 重放缩因子,默认为None. 如果为None或0则不进行放缩,否则会将该数值乘到数据上(在应用其他变换之前) preprocessing_function: 将被应用于每个输入的函数。该函数将在图片缩放和数据提升之后运行。该函数接受一个参数，为一张图片（秩为3的numpy array），并且输出一个具有相同shape的numpy array data_format：字符串，“channel_first”或“channel_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channel_last”对应原本的“tf”，“channel_first”对应原本的“th”。以128x128的RGB图像为例，“channel_first”应将数据组织为（3,128,128），而“channel_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channel_last” 12345678910111213141516171819202122232425262728293031323334353637from keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_imgimport osDatagen = ImageDataGenerator( rotation_range=5,#图片随机翻转的角度 width_shift_range=[0,0.15], height_shift_range=[0,0.2], zoom_range=[0.8,1.5], #随机放大 zca_whitening=True, brightness_range=[0.1, 1.5] , fill_mode='nearest')IMG_PATH = './images'OUT_PATH = './add'# for i in os.listdir(OUT_PATH):# if i.startswith('N'):# os.remove(os.path.join(OUT_PATH,i) )for file_name in os.listdir(IMG_PATH): img = load_img( os.path.join(IMG_PATH,file_name) ) x_img = img_to_array(img) x_img = x_img.reshape( (1,)+ x_img.shape ) i = 0 if( not os.path.exists( os.path.join( OUT_PATH,file_name ) ) ): os.mkdir( os.path.join( OUT_PATH,file_name )) for img_batch in Datagen.flow(x_img, batch_size=2, #batch_size一次增强的图片个数 save_to_dir= os.path.join(OUT_PATH,file_name), save_prefix='N', save_format='jpg'): i +=1 if i == 80: breakprint('done') 参考资料： 参数说明 keras中文手册 https://www.cnblogs.com/hutao722/p/10075150.html https://www.cnblogs.com/hutao722/p/10075150.html flow_from_directory实现从文件夹中提取图片和进行简单归一化处理 12345678flow_from_directory(self, directory, target_size=(256, 256), color_mode='rgb', classes=None, class_mode='categorical', batch_size=32, shuffle=True, seed=None, save_to_dir=None, save_prefix='', save_format='jpeg', follow_links=False) 最值得注意的是directory这个参数： directory: path to the target directory. It should contain one subdirectory per class. Any PNG, JPG, BMP, PPM or TIF images inside each of the subdirectories directory tree will be included in the generator. 这是官方文档的定义，它的目录格式一定要注意是包含一个子目录下的所有图片这种格式，driectoty路径只要写到标签路径上面的那个路径即可。 target_size：可是实现对图片的尺寸转换，是预处理中比较常用的方法 save_to_dir: 可以设置保存处理后图片的路径。 save_prefix: 可以对处理后图片设置前缀。 123456789101112131415161718192021222324252627282930313233343536373839import matplotlib.pyplot as pltimport globfrom PIL import Imagefrom keras.preprocessing import image path = 'train/'gen_path = 'result/' def print_result(path): name_list = glob.glob(path) fig = plt.figure() for i in range(9): img = Image.open(name_list[i]) # add_subplot(331) 参数一：子图总行数，参数二：子图总列数，参数三：子图位置 sub_img = fig.add_subplot(331 + i) sub_img.imshow(img) plt.show() return fig # 打印图片列表name_list = glob.glob(path + '*/*')print(name_list)# ['train\\\\00a366d4b4a9bbb6c8a63126697b7656.jpg', 'train\\\\00f34ac0a16ef43e6fd1de49a26081ce.jpg', 'train\\\\0a5f744c5077ad8f8d580081ba599ff5.jpg', 'train\\\\0a70f64352edfef4c82c22015f0e3a20.jpg', 'train\\\\0a783538d5f3aaf017b435ddf14cc5c2.jpg', 'train\\\\0a896d2b3af617df543787b571e439d8.jpg', 'train\\\\0abdda879bb143b19e3c480279541915.jpg', 'train\\\\0ac12f840df2b15d46622e244501a88c.jpg', 'train\\\\0b6c5bc46b7a0e29cddfa45b0b786d09.jpg'] # 打印图片fig = print_result(path + '*/*') # 保存图片fig.savefig(gen_path + '/original_0.png', dpi=200, papertype='a5') # 原图datagen = image.ImageDataGenerator()gen_data = datagen.flow_from_directory(path, batch_size=1, shuffle=False, save_to_dir=gen_path , save_prefix='dog_gen', target_size=(224, 224))for i in range(9): gen_data.next() fig = print_result(gen_path + '/*')fig.savefig(gen_path + '/original_1.png', dpi=200, papertype='a5')","categories":[],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"https://nymrli.top/tags/图像处理/"},{"name":"深度学习","slug":"深度学习","permalink":"https://nymrli.top/tags/深度学习/"}]},{"title":"Python机器学习及实践——从零开始通往Kaggle竞赛之路","slug":"Python机器学习及实践——从零开始通往Kaggle竞赛之路","date":"2019-05-27T13:50:34.000Z","updated":"2019-09-15T08:07:30.987Z","comments":true,"path":"2019/05/27/Python机器学习及实践——从零开始通往Kaggle竞赛之路/","link":"","permalink":"https://nymrli.top/2019/05/27/Python机器学习及实践——从零开始通往Kaggle竞赛之路/","excerpt":"","text":"Python机器学习及实践——从零开始通往Kaggle竞赛之路 监督学习模型 分类 线性模型 Logistic 逻辑回归函数 ： $g(z)=\\frac {1}{1+_e^{-z}} $ 逻辑回归模型hw,b(x)=g(f(w,x,b))=11+e−z=11+e−(wTx+b)h_{w,b}(x)=g(f(w,x,b)) = \\frac{1}{1+e^{-z}} = \\frac {1}{1+e^{-(w^{T}x+b)}}hw,b​(x)=g(f(w,x,b))=1+e−z1​=1+e−(wTx+b)1​ 处理缺省值的方法： 1.缺省值较少时直接删除数据 12data = data.replace(to_replace='? ' ,value = np.nan)data = data.dropna(how='any') 分割数据 123from sklearn.cross_validation import train_test_splitX_train , Y_train , X_test , Y_test = train_test_split(data[names[1:10]],data[names[10]],test_size = 0.25,random_state = 33)# 参数说明 ： $1X，$2Y，$3分割规模，$4分割种子 标准化数据 保证每个维度的特征数据方差为1，均值为0，使得预测结果不回被某些维度过大的特征值主导 1234from sklearn.preprocessing import StandardScalers = StandardScaler()X_train = s.fit_transform(X_train)X_test = s.transform(X_test) 混淆矩阵 … 🎯逻辑回归对参数的计算采用精确解析的方式，时间长性能高；SGD（随机梯度上升）分类估计模型参数，时间短性能低。数据规模在10W量级时考虑对时间的消耗，更推荐使用随机梯度方法对模型参数进行估计。 📝说明用例：良恶性肿瘤 支持向量机（​​分类） 决定直线位置的并不是所有数据，而是其中 两个空间间隔最小 的 两个不同类别 的数据点，把着中国真正帮助决策最有线性分类模型的数据点叫做“支持向量” 。同时要指出的是，logistic模型考虑了所有数据样本对参数的影响，所以不一定能获得最佳的分类器。 多分类的SVM 将其中一类看作是阳性（正）样本，其余的全看成负样本。如有10个类别，则创造10个二分类任务。 🎯SVM具有精妙的模型假设，可以在高维度的数据中筛选对预测任务有效的少数训练样本，不仅节省模型学习需要的数据内存，还提高了模型的预测性能，但是同时是以CPU资源和计算时间为代价的。 📝手写体数据​： 需要知道的是，经典模型没有对结构性信息学习的能力，所以这边对图片的处理其实是将2D图片像素矩阵（scikit-learn数据集里的是8*8）逐行首尾拼接为1D的像素特征向量。 非线性模型 朴素贝叶斯 单独考量每一个维度特征被分类的条件概论，进而综合这些概率并对其所在的特征向量做出分类预测。 数学假设：各个维度上的特征被分类的条件概率之间是相互独立的。 🎯具有较强的特征条件独立假设，使得模型预测所需要估计的参数规模从幂指数量级向线性量级减少，极大​节约了内存消耗和计算时间。但也受限与这种强假设的限制，训练时无法将各个特征之间的联系考量在内，使得该模型再其他数据特征关联性较强的分类任务上的性能表现不佳。 📝文本分类：互联网新闻分类、垃圾邮件筛选 K近邻（KNN） 设有一个测试样本点，以及已经分好类（带有标签）的训练样本。那么该样本点的类别判定会根据在特征空间中最近的K个已标记样本作为参考。因此模型的性能很大程度上取决于K值的设定，但是K值不属于训练数据后学习的参数，而是模型初始化时需要提前确定的。 🎯是无参数模型中最简单的一种，由于需要对预先加载在内存的训练样本进行遍历，逐一计算相似度、排序且选择K个最近邻训练样本的标记。所以是O(N2)的算法复杂度，一旦数据量大，可能会花费更多的时间（另一种理解为空间换时间，可探讨） 📝 iris鸢尾花数据集​ : ▲在对数据进行分割时请保证随机取样！ 由于scikit-learn获得的Iris数据集是根据类别依次排列的，所以如果只采样前25%那么所有采样的样本都是同一个类别，同时由于训练样本是不平衡的(Unbalanced)，这样取得的结果存在偏差，且可信度低。因此随机采样train_test_split(data[names[1:10]],data[names[10]],test_size = 0.25,random_state = 33)设置随机种子是必要的。 决策树 每个节点可以看作是二分类任务，根据不同特征组合搭建多层决策树，在学习时需要考虑特征节点的选择顺序。（度量方式：信息熵、基尼不纯性） 数据处理 缺省值： 1234X = titannic[['pclass','age','sex']]...# 补充age里的数据，使用平均数或者中位数都是对模型偏离成都造成最小影响的策略X['age'].fillna(X['age'].mean(),inplace = True) 特征值转换 类别性特征值转换为数值特征，用0/1代替 12345from sklearn.feature_extraction import DictVectorizervec = DictVectorizer(sparse = False)X_train = vec.fit_transform(X_train.to_dict(orient='record'))print(vec.feature_names)&gt;&gt;&gt; ['age','plcass=1st','pclass=2nd', 'sex=female','sex=male'] 🎯决策树在模型描述上有巨大的优势，推断逻辑非常直观，有清晰的可解释性，也方便模型的可视化。同时这些特性也保证了使用决策树时，无需考虑对数据量化甚至标准化。决策树属于有参数模型，需要花费更多时间在训练数据上面 📝泰坦尼克号沉船事故 回归 线性回归器 🎯美国波士顿地区房价 KNN 支持向量机 回归树 集成模型 无监督学习模型 数据聚类 K均值（K-means） 特征降维 主成分分析（PCA）","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"ACM-强连通分量","slug":"ACM-强连通分量","date":"2019-04-25T01:27:03.000Z","updated":"2019-09-15T08:07:30.915Z","comments":true,"path":"2019/04/25/ACM-强连通分量/","link":"","permalink":"https://nymrli.top/2019/04/25/ACM-强连通分量/","excerpt":"","text":"Tarjan 算法&amp;模板 Tarjan 算法一种由Robert Tarjan提出的求解有向图强连通分量的算法，它能做到线性时间的复杂度。 如果两个顶点可以相互通达，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。 1234567891011121314151617181920212223void Tarjan ( int x ) &#123; dfn[ x ] = ++dfs_num ; low[ x ] = dfs_num ; vis [ x ] = true ;//是否在栈中 stack [ ++top ] = x ; for ( int i=head[ x ] ; i!=0 ; i=e[i].next )&#123; int temp = e[ i ].to ; if ( !dfn[ temp ] )&#123; Tarjan ( temp ) ; low[ x ] = gmin ( low[ x ] , low[ temp ] ) ; &#125; else if ( vis[ temp ])low[ x ] = gmin ( low[ x ] , dfn[ temp ] ) ; &#125; if ( dfn[ x ]==low[ x ] ) &#123;//构成强连通分量 vis[ x ] = false ; color[ x ] = ++col_num ;//染色 while ( stack[ top ] != x ) &#123;//清空 color [stack[ top ]] = col_num ; vis [ stack[ top-- ] ] = false ; &#125; top -- ; &#125;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"ACM-并查集","slug":"ACM-并查集","date":"2019-04-25T01:21:30.000Z","updated":"2020-06-03T07:57:58.505Z","comments":true,"path":"2019/04/25/ACM-并查集/","link":"","permalink":"https://nymrli.top/2019/04/25/ACM-并查集/","excerpt":"","text":"并查集 ACM竞赛中，并查集（DisjointSets）这个数据结构经常使用。顾名思义，并查集即表示集合，并且支持快速查找、合并操作。 用于高效的查找某两个元素是否属于同一个集合； 并查集如何表示一个集合？它借助树的思想，将一个集合看成一棵有根树。那又如何表示一棵树？初始状态下，一个元素即一棵树，根即是元素本身。 合并 并查集如何支持合并操作？不难发现，按照树的思想，在同一棵树中的所有元素，根都是相同的。也就是说，合并两个不同的集合，只需要将其中一个集合的根设置为另一个集合的根即可，而需要改变根的那个集合，其实只需要改变根节点的父节点即可。 如何支持快速查找操作 如果完全按照上面的合并方法进行合并操作，最后生成的树，可能是完全线性的，那么查询的时间复杂度就退化成了O(n)，因为在这种情况下，程序不得不遍历完所有节点才能查询到当前元素所属的根节点。 路径压缩算法优化并查集查询操作。按照集合原来的定义，集合中的元素是满足无序性的，因此可以在查询操作进行的过程中，当程序遍历到根节点然后返回的时候，将所有属于当前根节点的元素的父节点直接设置为当前根节点。如此一来，原来的一条链就变成了一般的树了。当下一次查询的时候，就可以很快的遍历到根节点了，复杂度下降为O(1)。 还有一种优化查询速度的方法，那就是合并两个集合的时候，按秩进行合并，这里的秩代表的以当前元素为根节点的元素个数。很明显，将秩较小的树合并到秩较大的树上更优。 最后，就是具体如何用代码实现并查集？其实，并查集中只涉及到了保存当前元素的父节点这一信息，所以利用一个数组set[i]代表节点i的父节点即可，如果set[i]=i那么代表当前集合的根即为i元素本身。 以一道例题为例，HDOJ：1212，时空转移（点击打开链接）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt; const int NumSets = 1005;typedef int DisjSet[NumSets + 1];typedef int Rank[NumSets + 1];DisjSet S;Rank R; // Initialize the set and rankvoid Initialize()&#123; for(int i=0; i&lt;NumSets; ++i) &#123; S[i] = i; R[i] = 1; &#125;&#125; // Find father of the value, with the function of path compressionint Find(int value)&#123; if(S[value] != value) S[value] = Find(S[value]); return S[value];&#125; // Union the value1 and value2 by the rank of the set which them local invoid SetUnion(int value1, int value2)&#123; int fa1 = Find(value1); int fa2 = Find(value2); if(fa1 == fa2) return ; if(R[fa1] &gt;= R[fa2]) &#123; S[fa2] = fa1; R[fa1] += R[fa2]; &#125; else &#123; S[fa1] = fa2; R[fa2] += R[fa1]; &#125;&#125; int main()&#123;//freopen(\"sample.txt\", \"r\", stdin); int cas; scanf(\"%d\", &amp;cas); while(cas--) &#123; int n, m; Initialize(); scanf(\"%d%d\", &amp;n, &amp;m); for(int i=0; i&lt;m; ++i) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); if(Find(a) != Find(b)) &#123; SetUnion(a, b); --n; &#125; &#125; printf(\"%d\\n\", n); &#125; return 0;&#125;！ 摘自(https://blog.csdn.net/u011787119/article/details/46834903) 例题 解密犯罪团伙 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;int f[1001]=&#123;0&#125;,n,m,sum=0;//这里是初始化，非常地重要，数组里面存的是自己数组下标的编号就好了。void init()&#123; int i; for(i=1;i&lt;=n;i++) f[i]=i; return; &#125;//这是找爹的递归函数，不停地去找爹，直到找到祖宗为止，其实就是去找犯罪团伙的最高领导人，//“擒贼先擒王”原则。int getf(int v) &#123; if(f[v]==v) return v; else&#123; //这里是路径压缩，每次在函数返回的时候，顺带把路上遇到的人的“BOSS”改为最后找 //到的祖宗编号，也就是犯罪团伙的最高领导人编号。这样可以提高今后找到犯罪团伙的 //最高领导人（其实就是树的祖先）的速度。 f[v]=getf(f[v]);//这里进行了路径压缩 return f[v]; &#125;&#125;// 迭代写法// node为某次具体操作节点, tmp_node为其能找到group头// 关系类似链表中的p、q, 一个当前, 一个记录下一个或上一个节点int findFather(int v)&#123; int node = v; while ( arr[v] != v ) &#123; v = arr[v]; &#125; // v此时指向的是该group的头 // 路径压缩, 把该group中所有成员都指向一个头v while ( node != arr[node] )&#123; int tmp_node = node; node = arr[node]; arr[tmp_node] = v; &#125; return v;&#125;//这里是合并两子集合的函数void merge(int v,int u) &#123; int t1,t2;//t1、t2分别为v和u的大BOSS（首领），每次双方的会谈都必须是各自最高领导人才行 t1=getf(v); t2=getf(u); if( t1!=t2 ) //判断两个结点是否在同一个集合中，即是否为同一个祖先。 f[t2]=t1; //“靠左”原则，左边变成右边的BOSS。即把右边的集合，作为左边集合的子集合。 return;&#125;//请从此处开始阅读程序，从主函数开始阅读程序是一个好习惯。int main()&#123; int i,x,y; scanf(\"%d %d\",&amp;n,&amp;m); init(); //初始化是必须的 for(i=1;i&lt;=m;i++)&#123; //开始合并犯罪团伙 scanf(\"%d %d\",&amp;x,&amp;y); merge(x,y); &#125; //最后扫描有多少个独立的犯罪团伙 for(i=1;i&lt;=n;i++)&#123; if(f[i]==i) sum++; &#125; printf(\"%d\\n\",sum); getchar();getchar(); return 0;&#125; 用并查集判断无向图的连通性(或求连通分支个数)~ 给定一个无向图和其中的所有边，判断这个图是否所有顶点都是连通的。 输入：每组数据的第一行是两个整数n 和m（0&lt; n &lt;=1000）。n 表示图的顶点 数目，m 表示图中边的数目。如果n 为0 表示输入结束。随后有m 行数据，每 行有两个值x 和y（0&lt;x, y &lt;=n），表示顶点x 和y 相连，顶点的编号从1 开始计 算。输入不保证这些边是否重复。 输出：对于每组输入数据，如果所有顶点都是连通的，输出 ’YES’ ，否则输 出 ’NO’。 123456789101112===样例输入===4 31 22 33 23 21 22 30 0===样例输出===NOYES 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;int map[1005];int n,m;int find(int i)&#123; return map[i]==i?i:find(map[i]);&#125;void init()&#123; for(int i=0;i&lt;n;i++) map[i]=i;&#125;int main()&#123; while(scanf(\"%d%d\",&amp;n,&amp;m)==2) &#123; if(n==0) break; init(); int a,b; for(int i=0;i&lt;m;i++) &#123; scanf(\"%d%d\",&amp;a,&amp;b); a--;b--; map[find(a)]=map[find(b)]; &#125; int cnt=0; for(int i=0;i&lt;n;i++) &#123; if(map[i]==i) cnt++; &#125; if(cnt==1) printf(\"YES\\n\"); else printf(\"NO\\n\"); &#125; return 0;&#125; 例子 题目链接：http://poj.org/problem?id=1611 题目大意： 中文就不解释了； 做法：把同一个集合的所有元素都放到同一个集合里， 当放完之后， 检查一下0号同学在哪个集合， 再判断一下剩下的同学是否和它在同一个集合里面； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// Created by fkjs on 2015-09-17// Copyright (c) 2015 fkjs. All rights reserved.////#pragma comment(linker, \"/STACK:1024000000,1024000000\")#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#define clr(x) memset(x, 0, sizeof(x))using namespace std;const int INF = 0x3f3f3f3f;const int maxm = 505;const int maxn = 30000 + 10;typedef long long int ll;int n, m;int pa[maxn];int find(int x)&#123;//并查集的基础-&gt;find函数， 它的特点就是pa[x] = find(pa[x]), 这一语句可以把该路径上的所有点的父亲都改成根节点； return x == pa[x] ? x : pa[x] = find(pa[x]);&#125;void connect(int x, int y)&#123;//链接两个并查集 int fa = find(x);//找到根节点， 当然找的过程中会更新路上的点； int fb = find(y);//同上； pa[fa] = fb;//链接两个集合；&#125;int main(void) &#123;#ifdef LOCAL //freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\in.txt\", \"r\", stdin); //freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\out.txt\", \"w\", stdout);#endif //ios_base::sync_with_stdio(0); while(scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; (n || m))&#123; for(int i = 0; i &lt; n; i++) pa[i] = i; for(int i = 0; i &lt; m; i++)&#123; int len; scanf(\"%d\", &amp;len); int x; scanf(\"%d\", &amp;x); int tp = x; for(int i = 1; i &lt; len; i++)&#123; scanf(\"%d\", &amp;x); connect(x, tp); tp = x; &#125; &#125; int ans = 0; int p = find(0);//找到最初感染者所在的集合， 它的根是p； for(int i = 0; i &lt; n; i++)//凡是根是p的人都被感染了； if(find(i) == p) ans++; printf(\"%d\\n\", ans); &#125; return 0;&#125; ​","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"Java课程第二次实验报告","slug":"Java课程第二次实验报告","date":"2019-04-25T00:58:21.000Z","updated":"2019-09-15T08:07:30.948Z","comments":true,"path":"2019/04/25/Java课程第二次实验报告/","link":"","permalink":"https://nymrli.top/2019/04/25/Java课程第二次实验报告/","excerpt":"","text":"Java课程第二次实验报告 1.寻找并输出11~999之间的数m，它满足m、m2、m3均为回文数。回文数是各位数字左右对称的整数。判断是否为回文要求通过编写方法来完成。 123456789101112131415161718public class HelloWorld &#123; public static boolean isPalindrome(int s) &#123; String str = Integer.toString(s); if( str.charAt(0) == str.charAt(str.length() - 1) ) return true; else return false; &#125; public static void main(String []args) &#123; for (int s = 11; s &lt; 1000; s++) &#123; if (isPalindrome(s) &amp;&amp; isPalindrome(s*s) &amp;&amp; isPalindrome(s*s*s) ) System.out.println(s); &#125; &#125; &#125; 2.由键盘输入10个整数，比较并输出其中的最大值和最小值。 12345678910111213141516import java.util.Scanner;public class HelloWorld &#123; public static void main(String []args) &#123; Scanner s = new Scanner(System.in); int []arr = new int[10]; int maxn = -1000000000; int minn = 1000000000; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = s.nextInt(); if ( arr[i] &lt; minn ) minn = arr[i]; if ( arr[i] &gt; maxn) maxn = arr[i]; &#125; System.out.printf(\"最大值:%d ，最小值:%d \\n\",maxn,minn); &#125;&#125; 3.随机产生50个1-100之间的整数，存放于一个10´5的二维数组中，要求按照10´5的格式打印这个数组（即共显示10行，每行5个数，数与数之间间隔一个空格），并求出该数组所有元素之和。 1234567891011121314151617181920public class HelloWorld &#123; final static int row = 10; final static int col = 5; static int [][]arr = new int[row][col]; public static void main(String []args) &#123; int sum = 0; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; arr[i][j] = (int)(Math.random()*100 + 1); sum += arr[i][j]; System.out.printf(\"%d \",arr[i][j]); &#125; System.out.println(); &#125; System.out.println(\"SUM:\"+sum+\"\"); &#125;&#125; 4.学生类的创建和使用 ①创建一个学Student类，成员变量包括：学号、班号、姓名、性别、年龄等，且都是private类型。 ②声明一个构造方法，初始化所有成员变量。 ③分别声明获得各属性的public类型的成员方法，方法名要求以get开头。 ④分别声明修改各属性的public类型的成员方法，方法名要求以set开头。 ⑤声明一个public类型的toString（）方法，把该类中的所有域信息组合成一个字符串。 ⑥声明统计创建Student对象的个数的私有域count和得到Student对象的个数的public方法。 ⑦将类Student放在子包student中。 ⑧在子包student外，创建测试类Student的主类。 在主类中：创建2个Student对象，输出对象的所有域信息；修改对象的姓名和年龄，输出修改后的姓名和年龄；比较两个Student对象的年龄的大小，输出年龄较大的Student对象。 Student.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package student;public class Student &#123; private int uid; private int classNum; private String name; private String gender; private int age; private static int cnt = 0; public Student(int uid , int classNum , String name , String gender , int age) &#123; this.uid = uid; this.classNum =classNum; this.name = name; this.gender = gender; this.age = age; cnt += 1; // TODO Auto-generated constructor stub &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; public int getUid() &#123; return uid; &#125; public void setClassNum(int classNum) &#123; this.classNum = classNum; &#125; public int getClassNum() &#123; return classNum; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getGender() &#123; return gender; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public static int getCnt() &#123; return cnt; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return String.format(\"学号为%d的同学，在%d班，姓名为%s，性别为%s，年龄为%d，\", uid,classNum,name,gender,age); &#125; &#125; HelloWorld.java 12345678910111213import student.*;public class HelloWorld &#123; public static void main(String []args) &#123; Student stu1 = new Student(1,1,\"cl\", \"male\", 20); Student stu2 = new Student(3,2,\"cjl\", \"female\", 20); System.out.println(stu1); System.out.println(stu2); stu1.setName(\"cl2\"); stu1.setAge(21); System.out.printf(\"修改之后的姓名:%s,修改后的年龄:%d\\n\",stu1.getName(),stu1.getAge()); System.out.println( stu1.getAge() &gt; stu2.getAge() ?stu1 : stu2); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"ACM-大数定理（高精度）","slug":"ACM-大数定理（高精度）","date":"2019-04-25T00:53:27.000Z","updated":"2020-05-28T10:40:42.046Z","comments":true,"path":"2019/04/25/ACM-大数定理（高精度）/","link":"","permalink":"https://nymrli.top/2019/04/25/ACM-大数定理（高精度）/","excerpt":"","text":"ACM-大数定理（高精度） 由于c/c++中数据类型的范围比较固定，因此有些题目的数据范围正好卡在这些正常范围之外，此时就需要自己实现大数加减乘除的运算。 c/c++需要自己手写 java中有BigInteger类 C++ 加法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;string add(string a , string b)&#123; a = a.substr(a.find_first_not_of(\"0\")); // 去前导0 b = b.substr(b.find_first_not_of(\"0\")); ll lenA = a.length(); ll lenB = b.length(); ll len = max(lenA,lenB) + 10; reverse(a.begin(),a.end()); // 翻转,方便相加 reverse(b.begin(),b.end());// cout &lt;&lt; \"a\" &lt;&lt; a &lt;&lt; endl;// cout &lt;&lt; \"b\" &lt;&lt; b &lt;&lt; endl; string ans(len,'0'); // ans全赋值为0 for(int i =0 ; i &lt; lenA ; i ++) ans[i] = a[i]; int tmp = 0; for(int i = 0 ; i &lt; len;i++)&#123; if ( i &lt; b.length() ) tmp += (ans[i] - '0') + (b[i] - '0'); else tmp += (ans[i] - '0') ; ans[i] = (tmp % 10) + '0'; tmp /= 10; &#125; reverse(ans.begin(),ans.end()); // 再将运算结果反转回来 return ans.substr(ans.find_first_not_of(\"0\")); // 仍然需要去前导0&#125;int main()&#123; string a = \"3\"; string b = \"2\"; cout &lt;&lt; add(a,b) &lt;&lt;endl; return 0 ;&#125; 1234567891011121314151617/**A/B/C都是倒序的数字, 比如123, 那么vector&lt;int&gt; A = &#123;3, 2, 1&#125;*/vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size() || i &lt; B.size() || t; i++) &#123; if (i &lt; A.size() ) t += A[i]; if (i &lt; B.size() ) t += B[i]; C.push_back(t % 10); t /= 10; &#125; // 去末尾0（前置） while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125; Java 加减乘除 1234567891011121314151617public class HelloWorld &#123; public static void main(String []args) &#123; BigInteger a = new BigInteger(\"100\"); BigInteger b = new BigInteger(\"2\"); System.out.println(a.add(b)); // 102 System.out.println(a.subtract(b)); // 98 System.out.println(a.multiply(b)); // 200 System.out.println(a.divide(b)); // 50 BigInteger []c = a.divideAndRemainder(b); System.out.printf(\"除数为:%d,余数为:%d\\n\", c[0],c[1] ); // 除数为:50,余数为:0 &#125;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"}]},{"title":"使用git将项目上传到github（最简单方法）","slug":"使用git将项目上传到github（最简单方法）","date":"2019-03-28T11:39:36.000Z","updated":"2019-09-15T08:07:31.024Z","comments":true,"path":"2019/03/28/使用git将项目上传到github（最简单方法）/","link":"","permalink":"https://nymrli.top/2019/03/28/使用git将项目上传到github（最简单方法）/","excerpt":"","text":"使用git将项目上传到github（最简单方法） 首先你需要一个github账号，所有还没有的话先去注册吧！ Github **我们使用git需要先安装git工具，这里给出下载地址，下载后一路直接安装即可：**https://git-for-windows.github.io/ 1.进入Github首页，点击New repository新建一个项目 2.填写相应信息后点击create即可 Repository name: 仓库名称 Description(可选): 仓库描述介绍 Public, Private : 仓库权限（公开共享，私有或指定合作者） Initialize this repository with a README: 添加一个README.md gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore license: 证书类型，对应生成文件LICENSE 创建完成后会变成（添加了README.md或者有license) 3.点击Clone or dowload会出现一个地址，copy这个地址备用。 4.接下来就到本地操作了 首先右键你的项目，如果你之前安装git成功的话，右键会出现两个新选项，分别为Git Gui Here,Git Bash Here,这里我们选择Git Bash Here，进入如下界面，Test_Bluetooth即为我的项目名。 5.接下来输入如下代码（关键步骤），把github上面的仓库克隆到本地 git clone https://github.com/CKTim/BlueTooth.git（https://github.com/CKTim/BlueTooth.git替换成你之前复制的地址） 6.复制文件到刚出来的文件夹中 这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名，如图我多出了个Test文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹不用），其余都复制到那个新多出的文件夹下， 7.接着继续输入命令 cd Test，进入Test文件夹 8.接下来依次输入以下代码即可完成其他剩余操作： 123git add . （注：别忘记后面的.，此操作是把Test文件夹下面的文件都添加进来）git commit -m \"提交信息\" （注：“提交信息”里面换成你需要，如“first commit”）git push -u origin master （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码）","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"学会Pull request","slug":"学会Pull-request","date":"2019-03-28T11:18:14.000Z","updated":"2019-09-15T08:07:31.046Z","comments":true,"path":"2019/03/28/学会Pull-request/","link":"","permalink":"https://nymrli.top/2019/03/28/学会Pull-request/","excerpt":"","text":"GitHub中发起PR(pull Request) PR是为了贡献代码: ​ 贡献代码，通俗的说，就是自己修改了代码，希望合并到别人的Repository(仓库)中。将自己的智慧贡献给开源社区。 一.贡献代码: 1.第一步:Fork 在GitHub社区闲逛时，看中了某个项目代码，如：spring-projects/spring-framework，点击页面Fork按钮，会生成一个自己的Repository(仓库：thinkingfioa/spring-framework),如下图： 2.第二步：修改 Fork成功后，通过git clone、修改、commit、push等操作后，将修改的内容，提交到自己仓库(thinkingfioa/spring-framework)中。如果对git clone、commit和push不知道的，自行百度。如下图: 3 第三步：请求合并代码(Pull Request) 在2步骤时，我们修改了自己的仓库(thinkingfioa/spring-framework)代码。我们希望贡献自己的一份力量，将修改的Commit也提交到别人的仓库(spring-projects/spring-framework)中。则要进行Pull Request。 3.1 创建PR 3.2 Create pull request 请特别注意下图中标红的部分，不能搞反了。点击: Create pull request 绿色按钮，完成提交PR。 3.3 等待 提交PR完成后，等待对方仓库(spring-projects/spring-framework)的管理员审核，如果他同意，则贡献代码完成了。 二.同步最新代码 PR除了贡献代码外，还可以同步对方最新代码。通俗的说，fork某个仓库(如: spring-projects/spring-framework)代码一段时间后，为了同步自己仓库(thinkingfioa/spring-framework)和对方仓库(spring-projects/spring-framework)代码，保证自己仓库代码是最新版本。 2.1.1 Create pull request 这一步和上面3.2一样的，只是要注意箭头，哪个仓库合并哪个仓库。请自习注意下图标红部分 2.1.2 点击绿色按钮，完成代码同步 摘自:https://blog.csdn.net/thinking_fioa/article/details/79516352?tdsourcetag=s_pctim_aiomsg GitHub之接收、处理Pull Request 1.创建一个仓库来演示下。 假设创建仓库的人称为:“老大” 2.成员Fork后修改 成员x695 在自己的网页上fork这个仓库，然后git clone到本地，然后创建特性分支，基于特性分支修改完成提交，push到origin 远程仓库git push origin (master(本地):master(远程) ) 3.成员发PR到老大 4.老大登陆自己的账号，到PR页签 5.老大在本地的检查 为了防止这个成员乱改，如果不检查可以直接进行步骤6老大还要检查下假如还要用于演示的话，老大就要把代码拉到本地了，看看修改后有啥区别 git clone 自己创建的项目 git remote add stream 项目成员的仓库/获取项目成员仓库设置为本地仓库的远程仓库 git fetch 获取项目成员的仓库数据 将成员的仓库和分支数据全部拉到自己本地后，创建一个用户检查的分支 pr1，并进入这个分支 将项目成员的number1 分支和自己的分支pr1进行合并 git merge stream/number1 这样一来分支pr1就和项目成员的分支number1一样了，检查完毕，进行删除 git branch -D pr1 6.老大合并或评论PR 点击 add number1 可以回复评论，然后也可以直接点击 merge pull request 通过 老大如果不愿意登陆网页，也可以在本地进行如下操作 在步骤5中已经完成了，前2步的前提下进行下一步 git checkout master,切换到主分支 git merge stream/number1 将成员的分支合并到主分支 push前进行检查，git diff oragin/master 看看本地合并后的仓库和远端的有啥区别 如果确认无误直接进行git push 就可以了 完成上面的5步之后，仓库的Pull Request 会自动成Open状态变成Close 状态。 摘自:https://blog.csdn.net/x6_9x/article/details/50902777 Github官方文档 About pull requests Merging a pull request Closing a pull request Checking out pull requests locally","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"蓝桥杯突击训练","slug":"蓝桥杯突击训练","date":"2019-03-28T02:35:12.000Z","updated":"2020-09-17T02:09:36.481Z","comments":true,"path":"2019/03/28/蓝桥杯突击训练/","link":"","permalink":"https://nymrli.top/2019/03/28/蓝桥杯突击训练/","excerpt":"","text":"ACM 3-20笔记 3部排序 左指针，右指针， 探路指针–&gt;链表的pq 马虎的算式 枚举（五重循环，注意条件） 内存1000ms大约运行10^8的指令 大数除法 减法 除法 39级阶梯 斐波那契 简化模型后再加上考虑条件 错误票据 获得一行内容：getline()前要用getchar()吃掉换行符 分割一行以空格分隔的元素 12345string s;getline(cin,s);stringstream ss(s);string tmp;while( getline(ss,tmp,\" \") ) ▲翻硬币 ACM 3-21笔记 （2014年） 奇怪的分式 gcd辗转相除法 枚举 蚂蚁感冒 日本白书的蚂蚁模型：穿过身体 ▲地宫取宝 深搜 递归 取模 面对&amp;41004^{100}4100优化思考方向： 贪心 ： 知道有一条最好的路 —X---&gt; 这题要求每种情况都遍历 重复子问题 ： 记忆化搜索 dfs(int x, int y , int max,int cnt)，虽然x,y都是不同的，但max,cnt可能会有相同的值，这些情况是重复的 动态规划 （递推方式）： ACM 3-22笔记 (2015) T5-全排列 DFS框架 递归 回溯 T7-牌型种数 排列组合 一般都是用递归解决 回溯（恢复初始状态）：袋子理论 --&gt; 每次都得把自己的袋子清空再返回 两种思路： 13次选牌(O(1313)O(13^{13})O(1313)) 每张牌选几次（更简单O(513)O(5^{13})O(513)) T9-垒骰子 递归 分治法 逐步生成 ACM 3-23 (2016) 凑数字 多个不同的数字----&gt;全排列问题 附录：通用的代码工具 void i2s(string &amp;s, int &amp;num) 12345void i2s(string &amp;s, int &amp;num)&#123; stringstream ss; ss &lt;&lt; num; ss &gt; s;&#125; string去前置0 123void removePre0(string &amp;s)&#123; s = s.substr(s.find_first_not_of(\"0\"))&#125; string回溯去最后一个元素 123path += pai[i];f(k-1,path);path.erase(path.end()-1) 求最大公因数(辗转相除法)： 123456int gcd(int a,int b)&#123; if( a%b == 0) return b; //极端情况最大的公约数为两个中最小的一个 return gcd(b,a%b); // 被除数为其中小的那个&#125; 漫画图解 全排列 next_premutation 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; while(scanf(\"%d\",&amp;n)&amp;&amp;n)&#123; int a[1000]; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; sort(a,a+n);//可以自行测试一下删除后的结果 do&#123; for(int i=0;i&lt;n;i++) printf(\"%d \",a[i]); printf(\"\\n\"); &#125;while(next_permutation(a,a+n)); &#125; return 0;&#125; 如果有sort()，输出为 0 1 2 0 2 1 1 0 2 1 2 0 2 0 1 2 1 0 若无，则输出为 1 0 2 1 2 0 2 0 1 2 1 0 可以发现少了许多种组合方法。 不过，仔细比较各种组合方法和有无sort()的输出，可以发现函数next_permutation()是按照字典序产生排列的，并且是从数组中当前的字典序开始依次增大直至到最大字典序。 △.sort()默认排序从小到大 DFS+回溯法 123456789101112131415161718192021222324252627282930#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100+5;#define NUM 5int arr[] = &#123;1,2,3,4,5&#125;;void f(int k)&#123; if( k == NUM)&#123; for(int i = 0 ; i&lt; NUM; i++) cout &lt;&lt; arr[i]; cout &lt;&lt;endl; return ; &#125; for(int i=k ; i &lt;NUM ; i++)&#123; &#123; int t = arr[i]; arr[i] = arr[k]; arr[k] = t; &#125; f(k+1); // 回溯复原 &#123; int t = arr[i]; arr[i] = arr[k]; arr[k] = t; &#125; &#125;&#125; C++输入输出流设置 1234567#include &lt;bits/stdc++.h&gt; //万能头文件using namespace std; //命名空间int main() &#123; ios::sync_with_stdio(false); //取消输入输出流等待同步 ... if (i != n) cout &lt;&lt; endl; //每个输出样例间有换行,(可理解每个CASE后加个换行,最后一行没有)&#125; C语言里的输入输出问题 1234int d,float f,char str[20],scanf(\"%d%f%s\",d,f,str); scanf: 使用 scanf 输入 42 scanf()中使用%c说明符，该函数将只读取字符4 并将其存储在一个char类型的变量中 如果使用%s说明符，该函数会读取两个字符，即字符4和字符2，并将它们存储在一个字符串中。 如果使用%d说明符，则scanf 读取同样的两个字符，但是随后它会继续计算与它们的相应的整数值为4*10+2 得到 42；然后将该整数的二进制表示保存在一个int变量中， 如果使用%f说明符 则scanf（）读取这两个字符 计算它们对应的数值 42，然后以内部的浮点表述该值，并将结果保存在一个float变量中 123456789101112/**0234500067103456050020456006710000000089通过控制读入的位数,读入矩阵*/for(c=1;c&lt;=m;c++)&#123; //循环变量稍微有点奇怪 for(d=1;d&lt;=n;d++) scanf(\"%1d\",&amp;mapp[c][d]); &#125; getchar(): getchar()只能输入字符型,输入时遇到回车键才从缓冲区依次提取字符. 说明：当程序调用getchar()函数时，程序就等着用户按键，用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止（回车字符也放在缓冲区中）。当用户键入回车之后，getchar()函数才开始从键盘缓冲区中每次读入一个字符。也就是说，后续的getchar()函数调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才重新等待用户按键。 分割输入 123456789101112131415161718192021222324252627282930313233/* 迷宫题目010010001000000101110000*/for(int i=1 ; i &lt;= row ; i++)&#123; for(int j= 1; j &lt;= col ; j++) scanf(\"%c\",&amp;maze[i][j]); getchar();&#125;// ---错误票据--int n ;cin &gt;&gt; n ;getchar();vector&lt;int&gt; v;while(n--)&#123; string s; getline(cin,s); stringstream ss(s); string tmp; while( getline(ss,tmp,' ') )&#123; v.push_back( s2i(tmp) ); &#125;&#125;// ****C++输入流不同步设置****int main()&#123; ios::sync_with_stdio(false); ...&#125; 循环移位运算 12345678910111213141516171819202122232425262728/*** 递推得到幂运算* @param base基底，n幂次*/int selfpow(int base,int n)&#123; int res = 1; while( n-- )&#123; res *= base; &#125; return res;&#125;/*** 自己实现x位二进制循环左移* e.g. 8=1000 ， 左移=&gt; 0001* @param n为len位中只有一位为1的十进制数*/int ROL(int n,int len,int dir = 1)&#123; if ( dir == 1) &#123; n &lt;&lt;= 1; if ( n % selfpow(2,len) == 0 ) n = 1; &#125;else&#123; n &gt;&gt;= 1; if( n == 0 ) n = selfpow(2,len-1); &#125; return n;&#125; 宏定义循环 123456789101112#define rep(i,n) for (int i = 0; i &lt; (n); ++i)#define Forneq(i,s,n) for (int i = (s); i &lt; (n); ++i)#define Foreq(i,s,n) for (int i = (s); i &lt;= (n); ++i)int main()&#123; rep(i,3)&#123; cout &lt;&lt; 1 &lt;&lt; endl; &#125; For(i,1,2)&#123; cout &lt;&lt; 2 &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"C++机器学习库MLPack","slug":"C++机器学习库MLPack","date":"2019-03-25T09:44:11.000Z","updated":"2019-09-15T08:07:30.922Z","comments":true,"path":"2019/03/25/C++机器学习库MLPack/","link":"","permalink":"https://nymrli.top/2019/03/25/C++机器学习库MLPack/","excerpt":"","text":"C++机器学习库MLPack mlpack: a scalable C++ machine learning library 由于在网上查了一下发现安装这个库碰到了不少问题，所以还是记录一下安装过程。 安装 列出两种安装教程吧，第一种实测可以。第二种在测试Armadillo的时候没通过，还是缺库，有兴趣的人可以通过给的Armadillo官网链接下载安装Armadillo再试试 安装方法一： Mlpack 官网 提供了下载的方法 ： sudo apt-get install libmlpack-dev ， 但貌似有博客指出目前国内源里是没有这个镜像的，所以采取的办法是直接从观望上下载mlpack-3.0.0.tar.gz（没敢使用最新的，怕出错） 来编译安装 12345678$ tar -xvf mlpack-3.0.0.tar.gz $ cd mlpack-1.0.12 $ mkdir build $ sudo apt-get install libboost-math-dev libboost-program-options-dev libboost-random-dev libboost-test-dev libxml2-dev libarmadillo-dev $ cd build $ cmake ..$ make -j4$ sudo make install 注意根据报错信息：Maybe need administrative privileges.，所以 make install 前面要加上sudo权限 1234567[ 51%] Built target mlpack_sparse_coding[100%] Built target mlpack_testInstall the project...-- Install configuration: \"\"CMake Error at cmake_install.cmake:36 (file): file cannot create directory: /usr/local/lib/pkgconfig. Maybe need administrative privileges. 然后就是可选的编译条件，就是你只想安装其中一些包，也是可以的： $ make pca allknn allkfn ,只安装pca allknn allkfn这几个算法包。 摘自：http://www.linuxdiyf.com/linux/27052.html 安装方式二：（不推荐） 安装依赖库 1234Armadillo &gt;= 6.500.0Boost (program_options, math_c99, unit_test_framework, serialization, spirit)CMake &gt;= 2.8.5 Aramdillo 安装 （Ubuntu为例子） 首先安装Armadillo依赖的库：lapack, blas, boost 123$ sudo apt-get install liblapack-dev$ sudo apt-get install libblas-dev$ sudo apt-get install libboost-dev 接下来 安装Armadillo：sudo apt-get libarmadillo-dev 之后，安装完成，测试是否完成！以上步骤，都是应该可以直接完成的，需要Cmake和g++提前安装。 g++ test.cpp -o test -larmadillo 1234567891011#include &lt;iostream&gt;#include &lt;armadillo&gt;using namespace std;using namespace arma;//test.cppint main(int argc,char** argv) &#123; mat A=randu&lt;mat&gt;(4,5); mat B=randu&lt;mat&gt;(4,5); cout&lt;&lt;A*trans(B)&lt;&lt;endl; return 0;&#125; 网上还有说Armadillo也无法找不到镜像， 于是还是到官网下载下来编译安装，[Armadillo C++ matrix library]( Boost库的安装 apt-get install libboost-math-dev libboost-program-options-dev libboost-random-dev libboost-test-dev libxml2-dev mlpack安装 也是去官网下载编译安装 12345678910$ tar -xzf mlpack-2.0.1.tar.gz # tar解压$ cd mlpack-2.0.1 # 进入解压后的目录$ unzip mlpack-2.0.1.zip # zip解压$ cd mlpack-2.0.1 # 进入解压后的目录# 之后，建立build目录，cmake，make即可$ mkdir build$ cd build$ cmake ../$ make $ sudo make install 使用mlpack 源文件中有各种算法的例子，可以学习其使用方法，这里需要注意一点，在编译和链接时，都要加上-lmlpack -larmadillo，来包含所需库。 如编写下列代码: 123456#include &lt;mlpack/core.hpp&gt;using namespace std;int main()&#123; cout &lt;&lt; mlpack::util::GetVersion() &lt;&lt; endl; return 0;&#125; ▲.注意.编译的命令为g++ -std=c++11 testmlpack.cpp -o testlars -l mlpack -l armadillo，其中要加上**-std=c++11**，不然无法编译通过。 [Armadillo C++ ML library]http://arma.sourceforge.net/download.html) 如果Armadillo出错，可以去官网[Armadillo C++ ML library]http://arma.sourceforge.net/download.html)下载编译安装","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"南京邮电大学java程序设计作业在线编程第六次作业","slug":"南京邮电大学java程序设计作业在线编程第六次作业","date":"2019-03-17T05:29:36.000Z","updated":"2019-09-15T08:07:31.038Z","comments":true,"path":"2019/03/17/南京邮电大学java程序设计作业在线编程第六次作业/","link":"","permalink":"https://nymrli.top/2019/03/17/南京邮电大学java程序设计作业在线编程第六次作业/","excerpt":"","text":"总分：100 选择题得分：40 1.下列方法定义中，正确的是（） A.double me（int a，int b）{int r; r = ab} B.double me（a，b）{return b;} C.int me（int a，int b）{return（a-b）;} D.int me（inta，b）{return（a-b）;} 正确答案是：C 2.下列方法定义中，不正确的是（） A.float x（int a，int b）{return（ab）;} B.int x（int a，int b）{return ab;} C.int x（int a，int b）{return a * b;} D.int x（int a，int b）{return 1.2 *（a + b）;} 正确答案是：D 3.下面哪个数据类型占用的内存最大？（） A.int B.float C.double D.byte 正确答案是：C 4.下面哪个不属于Java的关键字？（） A.static B.final C.super D.sub 正确答案是：D 5.下面的标识符中哪个是合法的标识符？（） A.–a B.Test C.class D.＃ABC 正确答案是：B 6.下列语句序列执行后，c的值是（）int a = 3，b = 4，c = 0; （（a ）&lt;（ - b）） c; A.0 B.1 C.2 D.3 正确答案是：A 7.下面关于数组定义语句不正确的是（） A.float f [] = new {2.4f，3.5f，5.7f，7.9f}; B.int a [] = {1,2,3,4,5} C.double [] d = new double [10]; D.int [] a2; 正确答案是：A 8.下面（）是Java数据类型中的int类型的取值范围。 A.$-2^ 7 $〜27−12^ 7 -127−1 B.0 〜 216−12 ^ {16} -1216−1 C.$-2 ^ {15} $^ 〜 215−12 ^{ 15} -1215−1 D.−231​-2 ^ {31}​−231​ 〜231−1​2 ^ {31} -1​231−1​ 正确答案是：D 9.在Java语言中，下面（）类型可以表示整数基本数据类型。 A.single B.byte C.double D.char 正确答案是：B 10.假设int a = -3; 则表达式a&gt; 0？a：-a的结果是（） A.true B.false C.-3 D.3 正确答案是：D 编程题得分：60 输出所有的3位数字的质数得分：10/10 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.IOException;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args) throws IOException&#123; int size = 1000; int prime[] = new int[1000]; int pos=0; boolean flag; for (int i = 100; i &lt; size; i++) &#123; flag = false; for(int j=2; j &lt;= Math.sqrt(i) ; j++) &#123; if (i%j == 0)&#123; flag = true; break; &#125; &#125; if ( !flag ) prime[pos++] = i; &#125; int pf=0; for (int i = 0; i &lt; prime.length; i++) &#123; if (prime[i] != 0) &#123; System.out.printf(\"%6d\",prime[i]); pf ++; if (pf == 5) &#123; pf = 0; System.out.println(); &#125; &#125; &#125; &#125;&#125; 数列求和得分：10/10 12345678910111213141516171819202122232425262728293031323334353637import java.io.IOException;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args) throws IOException&#123; Scanner s = new Scanner(System.in); double x = s.nextDouble(); int cnt = 1; double sum = 0; double single ; do &#123; single = Math.pow(x, cnt)/fac(cnt); sum += Math.pow(-1, (cnt+1) % 2)*single; cnt ++; &#125; while ( Math.abs(single) &gt; 1e-4 ); System.out.printf(\"%.2f\\n\",sum); &#125; /** * @Target: 递归求阶乘 * @param a * @return a! */ public static int fac (int a) &#123; if (a == 0 || a == 1) return 1; return a*fac(a-1); &#125; &#125; 最大公约数得分：10/10 12345678910111213141516171819202122import java.io.IOException;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args) throws IOException&#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); int b = s.nextInt(); System.out.printf(\"%d\",gcd(a,b)); &#125; public static int gcd(int a,int b) &#123; if ( b==0 ) return a; return gcd(b,a%b); &#125;&#125; 输出斐波那契数列的前10得分：10/10 1234567891011121314151617181920212223import java.io.IOException;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args) throws IOException&#123; int arr[] = new int[20]; int len = 10; arr[0] = 1; arr[1] = 1; for (int i = 2; i &lt;len; i++) arr[i] = arr[i-2] + arr[i-1]; for (int i = 0; i &lt;len; i++) &#123; System.out.printf(\"%d\",arr[i]); if( i != len - 1) System.out.print(\" \"); else System.out.println(); &#125; &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"南京邮电大学java程序设计作业在线编程第五次作业","slug":"南京邮电大学java程序设计作业在线编程第五次作业","date":"2019-03-17T03:44:36.000Z","updated":"2019-09-15T08:07:31.036Z","comments":true,"path":"2019/03/17/南京邮电大学java程序设计作业在线编程第五次作业/","link":"","permalink":"https://nymrli.top/2019/03/17/南京邮电大学java程序设计作业在线编程第五次作业/","excerpt":"","text":"总分：100 选择题得分：50 以下哪一个工具是Java的编译器？( ) A.javac.exe B.java.exe C.javap.exe D.javadoc.exe 正确答案是: A 以下哪一个数据类型不属于Java的基本数据类型？( ) A.boolean B.char C.int D.String 正确答案是: D 假设有如下类的定义： public class test{ public static void main(String[] args){ int a= 3, b = 4; swap(a,b); System.out.println(“a=”+a + &quot; b=&quot; + b); } public static void swap(int a,int b){ int tmp = a; a = b; b = tmp; } } 程序运行后结果为( ) A.a=4 b=3 B.a=3 b=4 C.a=a b=b D.无结果输出 正确答案是: B 执行如下代码后，b的值是( ) int a=0, b=0; do{ --b; a = a-1; }while(a&gt;0); A.0 B.1 C.-1 D.死循环 正确答案是: C 下列关于Java中的数组的说法，错误的是( )。 A.数组中的元素的类型必须相同 B.数组中的元素是有顺序的 C.数组对象，属于引用类型 D.数组的大小可以任意改变 正确答案是: D 在循环体中，如果想结束本次循环，可以使用哪个语句？（ ）。 A.break B.continue C.final D.finally 正确答案是: B 下列标识符中，哪一个是非法标识符？（ ） A.statics B.static_10 C.10static D.$statics10 正确答案是: C 设有数组的定义int[] a = new int[3]，则下面对数组元素的引用错误的是（ ）。 A.a[0] B.a[a.length-1] C.int i=0;a[i] D.a[a.length]-1 正确答案是: D int a=new int[2][3]，则该数组包含（ ）个数组元素。 A.2 B.3 C.6 D.不确定 正确答案是: C 下面的代码段执行之后count的值是什么（ ） int count = 1; for (int i = 1; i &lt;= 5; i++) { count += i; } System.out.println(count); A.5 B.1 C.15 D.16 正确答案是: D 编程题得分：50 数字加密 得分：10 / 10 1234567891011121314151617181920212223import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123;public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int n = s.nextInt(); int arr[] = new int[4]; int cnt = 3; while(n!=0) &#123; arr[cnt--] = (n%10 + 9)%10; n /= 10; &#125; System.out.printf(\"The encrypted number is %d%d%d%d\\n\",arr[2],arr[3],arr[0],arr[1]); &#125; &#125; 数列排序 得分：10 / 10 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int arr[] = new int[20]; int len = arr.length; for(int i=0; i &lt; len; i++) arr[i] = s.nextInt(); bubble(arr); for(int i=0; i &lt; len; i++) &#123; System.out.printf(\"%4d\",arr[i]); if ( i == len-1) System.out.println(); //else System.out.print(\" \"); &#125; &#125; /** * @Target: 冒泡排序 * @param arr待排数组 */ public static void bubble(int arr[]) &#123; int start = 5; // 第6个元素的下标是5 int len = 14; // 第15个元素的下标是14 int tmp ; // 交换的临时变量 for (int i = start; i &lt; len; i++) &#123; for (int j = start; j &lt; len-(i-start); j++) &#123; // 类比从0 开始的冒泡,这边需要改成len-(i-start),因为j的范围只能是(start,len) if ( arr[j] &lt; arr[j+1]) &#123; tmp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = tmp; &#125; &#125; &#125; &#125; &#125; 打印杨辉三角形 得分：10 / 10 12345678910111213141516171819202122232425262728293031import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int hang = s.nextInt(); int arr[][] = new int[hang][hang]; arr[0][0] = 1; for (int i = 1; i &lt; hang ; i++) &#123; arr[i][0] = 1; arr[i][i] = 1; for (int j = 1; j &lt; hang; j++) &#123; arr[i][j] = arr[i-1][j] + arr[i-1][j-1]; &#125; &#125; for (int i = 0; i &lt; hang ; i++) &#123; for (int j = 0; j &lt; hang; j++) &#123; if (arr[i][j] != 0 ) System.out.printf(\"%5d\",arr[i][j]); &#125; System.out.println(); &#125; &#125;&#125; 构造指定的数列 得分：10 / 10 12345678910111213141516171819202122232425import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); int b = s.nextInt(); int cnt = 0 ; int arr[] = new int[1000]; for (int i = a; i &lt;= b; i++) &#123; if ( i % 7 == 0 || i % 11 == 0) &#123; if ( !(i % 7 == 0 &amp;&amp; i % 11 == 0) ) arr[cnt++] = i; &#125; &#125; for(int x : arr) if ( x!= 0) System.out.printf(\"%d \",x); &#125;&#125; 求平均值 得分：10 / 10 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.IOException;import java.util.Arrays;import java.util.Scanner;/** * @author Mr.li * @Date 2019年3月17日 */public class Main &#123; public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int num = s.nextInt(); int sum = 0; //去除最大最小值的总和 int cnt = 0; //要去掉的个数 int arr[] = new int[num]; for (int i = 0; i &lt; num; i++) arr[i]= s.nextInt(); Arrays.sort(arr); // 排序,默认从大到小 System.out.printf(\"max element:%d\\n\", arr[num-1]); // 第一个是最大的 System.out.printf(\"min element:%d\\n\", arr[0]); // 最后一个是最小的 // 去掉最大和最小项 for (int i = 1; i &lt; num-1; i++) &#123; if ( arr[i] == arr[0] || arr[i] == arr[num-1] ) &#123; arr[i] = 0 ; cnt ++ ; &#125; &#125; // 是否全是最小最大值 boolean flag = false; for (int i = 1; i &lt; num-1; i++) &#123; if (arr[i] != 0) &#123; flag = true; sum += arr[i]; &#125; &#125; if (flag == true) System.out.printf(\"average is %5.2f\\n\", (double)sum/(num-(cnt+2))); else System.out.printf(\"no solution\\n\"); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Linux命令手册","slug":"Linux命令手册","date":"2019-03-15T14:33:26.000Z","updated":"2019-12-11T09:38:36.126Z","comments":true,"path":"2019/03/15/Linux命令手册/","link":"","permalink":"https://nymrli.top/2019/03/15/Linux命令手册/","excerpt":"","text":"scp 1、从服务器上下载文件 1scp username@servername:/path/filename /var/www/local_dir（本地目录） 例如scp root@192.168.0.101:/var/www/test.txt 把192.168.0.101上的/var/www/test.txt 的文件下载到/var/www/local_dir（本地目录） 2、上传本地文件到服务器 1scp /path/filename username@servername:/path 例如scp /var/www/test.php root@192.168.0.101:/var/www/ 把本机/var/www/目录下的test.php文件上传到192.168.0.101这台服务器上的/var/www/目录中 3、从服务器下载整个目录 1scp -r username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录） 例如:scp -r root@192.168.0.101:/var/www/test /var/www/ 4、上传目录到服务器 1scp -r local_dir username@servername:remote_dir例如：scp -r test root@192.168.0.101:/var/www/ 把当前目录下的test目录上传到服务器的/var/www/ 目录 12345678910111213141516$ ssh root@47.98.233.15@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:8hgJ8jpcBr1tm6HS72FpXwMrjba8MQqlqYJQLPB/Qf4.Please contact your system administrator.Add correct host key in /Users/wangdong/.ssh/known_hosts to get rid of this message.Offending ECDSA key in /Users/wangdong/.ssh/known_hosts:26ECDSA host key for 47.98.233.15 has changed and you have requested strict checking.Host key verification failed.# 从网上截的,自己电脑报错没报错按报错的提示,需要将C:\\Users\\10630\\.ssh中的known_hosts中的内容删掉,因为他默认先从这里边找相同IP的,删掉后就行了 ssh SSH分客户端openssh-client和服务器端openssh-server，如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudo apt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server 下面讲解openssh-server 首先更新源 1sudo apt-get update 安装ssh服务 1sudo apt-get install openssh-server 检测是否已启动 1ps -e | grep ssh 看到有ssh字样，说明已启动，如果没有就手动启动 1/etc/init.d/ssh start 配置ssh-server，配置文件位于/etc/ssh/sshd_config，默认端口为22，为了安全，一般自定义为其他端口，然后重启 1sudo /etc/init.d/ssh resart 增加桌面快捷方式 Launcher : ​ 在/usr/share/applications/中写入Roboviz.desktop文件(sudo vim Roboviz.desktop) 123456789[Desktop Entry]Name=RobovizComment=RobovizExec=/home/apollo3d/RoboViz-dev/bin/linux-amd64/roboviz.shIcon=/home/apollo3d/RoboViz-dev/bin/linux-amd64/resources/images/icon.pngTerminal=trueStartupNotify=trueType=ApplicationCategories=Development;IDE; ps aux | grep进程名 ps -A 显示所有程序。 ps e 列出程序时，显示每个程序所使用的环境变量。 kill －9 324 killall -9 NAME Linux下还提供了一个killall命令，可以直接使用进程的名字而不是进程标识号 chmod {u|g|o|a}{+|-|=}{r|w|x} filename 修改权限 find pathname [option] expression 寻找文件 grep [option] pattern filenames 搜索文件中匹配符 ​ grep -r 二进制 /home/apollo3d/Documents ./文件名 进入到进程的执行文件所在的路径下，执行文件 https://www.cnblogs.com/lcword/p/6046261.html 端口操作 端口监听信息 netstat -plant 一、查看哪些端口被打开 netstat -anp 二、关闭端口号:iptables -A OUTPUT -p tcp --dport 端口号 -j DROP 三、打开端口号：iptables -A INPUT -ptcp --dport 端口号 -j ACCEPT 四、以下是linux打开端口命令的使用方法。 nc -lp 23 &amp;(打开23端口，即telnet) netstat -an | grep 23 (查看是否打开23端口) 或者 lsof -i:80 五、linux打开端口命令每一个打开的端口，都需要有相应的监听程序才可以 创建新用户 在 root 用户下运行这条命令创建一个新用户，yangxg 是用户名 因为我叫杨学光，所以我取的用户名是 yangxg 选择一个你喜欢的用户名，不一定非得和我的相同 root@localhost:~# useradd -m -s /bin/bash yangxg 把新创建的用户加入超级权限组 root@localhost:~# usermod -a -G sudo yangxg 为新用户设置密码 注意在输密码的时候不会有字符显示，不要以为键盘坏了，正常输入即可 root@localhost:~# passwd yangxg 切换到创建的新用户 root@localhost:~# su - yangxg 切换成功，@符号前面已经是新用户名而不是 root 了 yangxg@localhost:~$ 为root用户提供初始密码 sudo passwd root 修改为阿里云 DNS 您必须是管理员root或者具有管理员权限 sudo vim /etc/resolv.conf 加入: 12nameserver 223.5.5.5nameserver 223.6.6.6 保存退出，然后使用dig 验证: dig www.taobao.com +short若出现结果则表示正常。 换源(更换数据源) 12345rootdubuntu:/home/lusifer# curl -sSL https://get. daocloud. io/docker | shExecuting docker install script, commit:1d31602+sh-c apt-get update-qq&gt;/dev/null E: Could not get Lock /var/lib/apt/lists/lock-open (11: Resource temporarily unavailable)E: Unable to lock directory /var/lib/apt/lists/ 原因可能是没有更新数据源 1.备份默认的源sudo cp /etc/apt/sources.list /etc/apt/sources_init.list 2.用你熟悉的编辑器打开：如vim /etc/apt/sources.list替换默认的http://archive.ubuntu.com/为mirrors.aliyun.com 123456789101112131415deb http://mirrors.aliyun.com/ubuntu/ xenial maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial maindeb http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe 最后输入sudo apt-get update Ubuntu无法找到add-apt-repository问题的解决方法 网上查了一下资料，原来是需要python-software-propertiduanjkes 于是apt-get install python-software-properties 除此之外还要安装software-properties-common 于是apt-get install software-properties-common 然后就能用add-apt-repository了 代理 搜索代理 env | grep proxy、sudo grep -r -i http_proxy=代理地址 配置代理 临时:export http_proxy=http://10.3.0.1:80 (1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。) Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;; 保存apt.conf文件。 (2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件) 建立文件 vim proxyfile Acquire::http::proxy &quot;http://10.3.0.1:80&quot;; Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;; Acquire::https::proxy &quot;http://10.3.0.1:80&quot;; 使用时sudo apt-get install xxx -c proxyfile (2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 ) 在您的.bashrc文件末尾添加如下内容 export http_proxy=http://用户名:密码@地址:端口/ export https_proxy=http://用户名:密码@地址:端口/ export ftp_proxy=http://用户名:密码@地址:端口/ ubuntu 代理配置 PPA 1.vim /usr/lib/python3/dist-packages/softwareproperties/ppa.py 在函数def _get_https_content_py3（lp_url）的catch案例中添加了一个print（e）显示了错误的真正原因。 2.系统时间是否正确 3.除了配置代理之外，请告诉sudo使用-E该标志来考虑环境 123export http_proxy=http://&lt;proxy&gt;:&lt;port&gt;export https_proxy=http://&lt;proxy&gt;:&lt;port&gt;sudo -E apt-add-repository ppa:canonical-qt5-edgers/qt5-proper with username and password: 1export https_proxy=&lt;username&gt;:&lt;password&gt;@&lt;proxy&gt;:&lt;port&gt; Ubuntu下让终端走SS代理的方法 Ubuntu下让终端走SS代理需要第三方软件的帮助，即privoxy。 privoxy 是非快取式 (non-caching) 的网页代理伺服器，具有进阶的过滤能力，可强化隐私权，还可以修改网页资料、管理 HTTP cookies、去除广告等。 安装 privoxy sudo apt-get install privoxy 安装完成后在 /etc/privoxy 目录下可以找到配置文件 config。 配置 privoxy 一般地，改配置前应该备份配置。 mv /etc/privoxy/config /etc/privoxy/config.back 然后打开 config 文件，找到listen-address那一行，修改值为 privoxy 监听的地址，一般使用默认。 然后再找到forward-socks5那一行，去掉注释，值为SS代理监听的地址。 让终端走SS代理,修改配置后，重启 privoxy。 sudo /etc/init.d/privoxy restart 然后在终端下添加 http 代理。 export http_proxy=”127.0.0.1:8118” export https_proxy=”127.0.0.1:8118” 然后就可以愉快的用终端翻墙了。 原文：https://blog.csdn.net/tailgo/article/details/52075643 Lets Encrypt 配置SSL错误 DNS problem: NXDOMAIN looking up A for xxx 刚刚解析了A记录，解析服务器还没有生效 服务器本地 DNS缓存未更新 1. 首先确定A记录是否成效 确定的方式很简单，在浏览器输入自己的域名，查看能否访问成功。 2. 确定DNS是否有问题 1) ping主机 12# ping主机，如果无法发现host，则确定是dns问题$ ping demo.ptbird.cn 2) 更新DNS缓存 不建议直接 network restart 使用nscd 如果系统没装可以装一下，nscd做DNS缓存加速很有用。 centos : yum install nscd、ubuntu ：apt-get install nscd 如果已经装了直接更新 1234# 主要是hosts$ nscd -i passwd$ nscd -i group$ nscd -i hosts grep指令参数说明 https://www.cnblogs.com/forestwolf/p/6413916.html 查看文件最后修改日期,返回值为时间戳stat -c %Y filename 查看系统(软件)时间date、硬件时间clock -s,用硬件时间覆盖软件时间 -w,用软件时间覆盖硬件时间 与远程主机同步时间ntpdate ip 内部、外部命令 enable查看内部命令 外部命令的搜索目录在$PATH中指定 搜索时的优秀顺序根据hash缓存来决定,hash -d name清空name的缓存,hash -r清空所有缓存 使用内部命令而不使用别名 e.g. ls 12345678ls &lt;==&gt; /bin/ls --color=auto# 如何不调用别名呢1. /bin/ls2. \\ls3. 'ls'4. \"ls\"5. command ls 别名alias: 优先级: alias &gt; 内部命令 &gt; 外部命令 设置别名alias xxx=yyy 取消所有别名unalias -a 设置语言 1.先修改配置文件vim /etc/sysconfig/i18n中将en_US.UTF-8改成zh_CN.UTF-8, 2.然后. /etc/sysconfig/i18n立即生效 3.测试wall &quot;Hello&quot;给登录该服务器的用户发送信息 查看历史命令 history,查看到id后,可以!id进行再调用…!!执行前一个命令 123456!string 重复前一个以“string\"开头的命令!?string 重复前一个包含string的命令!string:p仅打印命令历史，而不执行!$：p打印输出！$（上一条命令的最后一个参数）的内容!*：p打印输出！*（上一条命令的所有参数）的内容Astring 删除上一条命令中的第一个string Astring1Astring2将上一条命令中的第一个string1替换为string2!:gs/string1/string2将上一条命令中所有的string1都替换为string2 $HISTSIZE记录了最大记录数 命令行历史保存在历史中,直到正常退出后会写入~/.bash_history里 VIM插件管理 1.安装 1234# 如果没安装curl的话,先安装curl$ sudo apt install curl$ curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 2.修改~/.vimrc文件 123call plug#begin() Plug 'flazz/vim-colorschemes'call plug#end() 3.执行更新 这步要确保安装了git 12:PlugStatus # 查看插件类型:PlugInstall # 安装插件 4.使用插件 删除插件:PlugClean 查询帮助 which: 查找文件： 会在环境变量$PATH设置的目录里查找符合条件的文件 type: 返回命令的类型 whatis: 查看命令功能 查询一个命令执行什么功能,可以查询到man需要的章节号 whereis：查找文件 会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件 只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令 内部命令: help command ，如help type 外部命令: command --help man(manual),帮助手册放在/usr/share/man 123date -d \"yesterday\" +%Fdate -d \"-2 day\" +%Ftouch `date -d \"yesterday\" +%F`.log Linux登陆欢迎提示信息的设置 Linux可以设置登录前后的欢迎信息，虽然没啥技术含量，但却是非常实用的一个小技巧。 实现登录消息的功能，可以修改3个文件。 1、/etc/issue 本地登陆显示的信息，本地登录前 2、/etc/issue.net 网络登陆显示的信息，登录后显示，需要由sshd配置 3、/etc/motd 常用于通告信息，如计划关机时间的警告等，登陆后的提示信息 Linux下如何卸载软件（apt系） 此方法适用于Debian、Ubuntu等带apt工具的操作系统。 首先我们需要知道将要卸载的软件名称，比如我现在打算卸载tightvncserver，但是如果你不确定名称，没关系，可以用Tab键自动补全来确定。 12345$ sudo apt-get autoremove --purge tigh[TAB]# sudo——获取 root 权限 # apt-get——执行安装卸载功能的软件 # autoremove——告诉 apt-get 我们所要做的操作是移除软件 # –purge——注意这前面是两个短划线，这个参数是告诉他们要完整的干净的彻底的移除 1lsblk查看硬盘挂载 恢复rm删除的文件: 注意：查看一下当前系统版本号，及文件系统格式 df -T 12345678910111213# 查看当前硬盘分区$ df .# 使用debugfs$ debugfs -w /dev/mapper/ubuntu--vg-root# 列出当前目录下删除过的文件$ ls -d /home/apollo3d# 找到删除文件前的&lt;&gt;中的数据,即节点号$ logdum -i &lt;num&gt;# 退出debugfs模式$ quit# 进行恢复$ sudo dd if=/dev/mapper/ubuntu--vg-root of=/home/apollo3d/xxx.py bs=2944 count=1 skip=9438337# bs为offset量, skip为block量 apt-get update出现NO_PUBKEY错误的解决方法 在使用apt-get update命令时，出现了如下的错误，形式如“W: GPG error: http://security.ubuntu.com trusty-security Release: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY XXXXX” 1234# 执行更新,查看他缺少什么key $ sudo apt-get update# 复制他提示缺少的key:xxx,输入即可$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key xxxx","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"搭建Gitlab服务器","slug":"搭建Gitlab服务器","date":"2019-03-14T10:32:26.000Z","updated":"2019-12-12T12:29:24.682Z","comments":true,"path":"2019/03/14/搭建Gitlab服务器/","link":"","permalink":"https://nymrli.top/2019/03/14/搭建Gitlab服务器/","excerpt":"","text":"搭建Gitlab服务器 下载安装Gitlab 由于直接下载Gitlab会很慢(被墙的缘故) ， 于是选择清华的镜像安装，清华源 Ubuntu 16.04 用户 Linux其他版本或者不是Ubuntu 16.04 见官网修改方式 首先信任 GitLab 的 GPG 公钥: 1curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null ▲如果这步不行，先进行下一步 文本框中内容写进 /etc/apt/sources.list.d/gitlab-ce.list 1deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu xenial main 安装 gitlab-ce: 12sudo apt-get updatesudo apt-get install gitlab-ce 安装成功后，会显示“狐狸头”。 初次配置服务 1sudo gitlab-ctl reconfigure 启动服务 1sudo gitlab-ctl start 初始化管理员root账号 汉化(用不了–&gt;建议另找) 1.下载社区提供的汉化包，在 https://gitlab.com/xhang/gitlab/ 中找到相应的汉化分支。 1sudo wget wget -cO gitlab-9.0_zh.tar.gz https://gitlab.com/xhang/gitlab/repository/archive.tar.gz?ref=9-0-stable-zh 2.解压包 1sudo tar zxvf gitlab-9.0_zh.tar.gz 3.停止 GitLab 服务 1sudo gitlab-ctl stop 4.备份 gitlab-rails 目录，该目录下主要是web应用部分，也是当前项目仓库的起始版本，也是汉化包要覆盖的目录。 1sudo tar zcvf /opt/gitlab/embedded/service/gitlab-rails-bak.tar.gz gitlab-rails 5.将解压后的汉化补丁覆盖原来的 1sudo cp -rf gitlab-9-0-stable-zh/* gitlab-rails/ 6.启动服务 1sudo gitlab-ctl start 7.重新执行配置命令 1sudo gitlab-ctl reconfigure 注意gitlab的配置文件在/etc/gitlab/gitlab.rb中,我个人操作是要经过一次reconfigure后，gitlab.rb才有内容的。（但/opt/gitlab/etcgitlab.rb.template 中一直有，应该就是因为是模板的原因吧） gitlab修改默认端口 gitlab.rb修改 123456789101112131415161718## Advanced settingsunicorn['listen'] = '127.0.0.1'unicorn['port'] = 8082...################################################################################## GitLab Web server# web_server['shell'] = '/bin/false'# web_server['home'] = '/var/opt/gitlab/nginx'################################################################################## GitLab NGINX##! Docs: https://docs.gitlab.com/omnibus/settings/nginx.html################################################################################nginx['listen_addresses'] = ['*']nginx['listen_port'] = 82 # override only if you use a reverse proxy: https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#setting-the-nginx-listen-port gitlab-rails修改 1234# What ports/sockets to listen on, and what options for them.#listen \"127.0.0.1:8080\", :tcp_nopush =&gt; truelisten \"127.0.0.1:8082\", :tcp_nopush =&gt; truelisten \"/var/opt/gitlab/gitlab-rails/sockets/gitlab.socket\", :backlog =&gt; 1024 gitlab nginx 修改 1234567server &#123; listen *:82; server_name gitlab.123.123.cn; server_tokens off; ## Don&apos;t show the nginx version number, a security best practice&#125; 修改完成后，重启下sudo gitlab-ctl reconfigure,sudo gitlab-ctl restart，就可以放82端口的gitlab了。 附录: 参考链接: https://www.linuxidc.com/Linux/2018-01/150319.htm https://blog.csdn.net/hnmpf/article/details/80518460 (未看，但觉得应该还行) 之前记录的,先放着 配置Gitlab 1.安装 1）查看电脑配置 github对内核有限制 64位,内核3.0 uname -a 、 uname --m 2）安装 https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/ 3） 配置开启GitLab 1sudo gitlab-ctl reconfigure 2.配置 1.查看主机名然后登陆 你第一次访问, 你会被自动导向到密码重置界面，重置完成密码后 会重新返回登陆界面 默认账户的 username 是 root. 提供给你的密码容易创建和登录. 登录后你可以将 username 改成你希望的. 2. 配置服务器及访问路径 123$ vim /etc/gitlab~ external_url = \"http://gitlab.aaa.com\"$ Gitlab-ctl reconfigure 3.配置nginx及DNS域名解析 docker 下 Gitlab搭建 1.配置vim docker-compose.yml 1234567891011121314151617181920212223version:3services: gitlab: image: twang2218/g1tlab-ce-zh:9.4 restart: always hostname:192,16875.129 # environment里才是gitlab的设置,包含nginx和gitlab # gitlab的网页访问是通过nginx的方向代理访问的 environment: TZ: Asia/Shanghei GITLAB_OMNIBUS_CONFIG: | external _url 'http://192 168.75.129:8080' gitlab_rails[' gitlab_shell_ssh_port']=2222 unicorn[' port']=8888 nginx[' listen_port']=8080 ports: # 左边是宿主机的端口, 右边是容器的端口 - '8080:8080' - '8443:443' - '2222:22' volumes: - /usr/local/docker/gitlab/config:/etc/gitlab - /usr/local/docker/gitlab/data:/var/opt/gitlab - /usr/local/docker/gitlab/logs:/var/log/gitlab 配置好后通过http://192 168.75.129:8080进行访问 2.配置root用户初始密码","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"},{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"程序设计周cpp学习笔记","slug":"程序设计周cpp学习笔记","date":"2019-03-07T11:56:14.000Z","updated":"2019-09-15T08:07:31.088Z","comments":true,"path":"2019/03/07/程序设计周cpp学习笔记/","link":"","permalink":"https://nymrli.top/2019/03/07/程序设计周cpp学习笔记/","excerpt":"","text":"文件名传参 123456789101112131415using namespace std;#define FILENAME \"data.csv\"void readfile(string file)&#123; ifstream inFile; inFile.open(file.c_str(), ios::out); // 打开模式可省略 string lineStr; while (getline(inFile, lineStr) ) // 打印整行字符串 cout &lt;&lt; lineStr &lt;&lt; '-'&lt;&lt; endl; &#125; int main()&#123; readfile(FILENAME); return 0; &#125; 输入Q退出 123456789101112131415161718void studentMenu()&#123; string UID; string PWD; int confirmed = false; //判断是否认证成功 do&#123; cout &lt;&lt;\"请输入普通账号ID:\" &lt;&lt;endl; cin &gt;&gt; UID; cout &lt;&lt;\"请输入密码:\" &lt;&lt;endl; cin &gt;&gt; PWD; confirmed = confirmStatus(UID,PWD); if( !confirmed ) cout &lt;&lt; \"账号或密码错误,请尝试.账号ID输入'Q'退出\"; &#125;while( !confirmed &amp;&amp; UID != \"Q\"); if(confirmed) &#123; cout &lt;&lt; \"成功认证\"; //进入学生界面 &#125;&#125; !!! 标准库文件是在.h还是.cpp中include? 现有两个文件Test.h 和Test.cpp#include &lt;iostream&gt;在Test.h中包含 和在Test.cpp中包含有什么区别? 1、在cpp文件中包含.h文件，要么你要用到这个头文件中的函数或者类，要么就是实现这个头文件； 2、.h —就是为了放一堆声明所产生的东西。 如果是定义放在.h中。 如果.h被重复包含多次，那么则会被报重定义。所以在.h 中都要—如果函数就要是inline ,如果是变量就要 selectany (windows)才不会被报错。 3、#include尽量写到cpp文件里。两个文件在.h文件里相互include,就会产生编译错误，而两个文件在.c文件互相include，就不会有该问题，因此在.h文件include就要避免互相包含的问题，而.cpp文件就不需要考虑 4、1）在 .h 里面 include 的好处是：如果很多.c,.cpp文件，都包含一批头文件,如果复制很容易遗漏，如果输入，很容易出错 如果全部在一个.h, include 那么每个.c,.cpp文件只需要一个#include 语句这样不仅输入量减少，而且代码也美观多了代码也主次分明了毕竟，.c.cpp, 里面要实现的函数，才是主要代码 2）主要缺陷， 可能会包含完全不需要的头文件， 增加编译工作量 5、如果你在a.h头文件中include了“stdio.h”，“iostream”，……一大堆 那么你的a.cpp源文件只要include你的a.h，就相当于include了“stdio.h”，“iostream”，……一大堆 但是当其他文件include你的a.h的同时也就包含了“stdio.h”，“iostream”，……一大堆这个要看你个人需要，如果你需要让其他文件也include一大堆，那么写在a.h中就可以，其他文件包含a.cpp简单整洁无脑如果只有a.cpp需要include一大堆，那么还是建议在a.cpp中include一大堆 6、如果a.c包含了头文件a.h，a.h包含了头文件b.h，b.c也包含了b.h，那么当b.h发生改变时，a.c和b.c都会重新编译也就是所有包含了b.h的都会重新编译，无论是直接包含，还是间接包含 7、2点原则： 第一个原则：如果可以不包含头文件，那就不要包含了，这时候前置声明可以解决问题。如果使用的仅仅是一个类的指针，没有使用这个类的具体对象（非指针），也没有访问到类的具体成员，那么前置声明就可以了。因为指针这一数据类型的大小是特定的，编译器可以获知（C++编译器自上而下编译源文件的时候，对每一个数据的定义，总是需要知道定义的数据的类型的大小） 第二个原则：尽量在CPP文件中包含头文件，而非在头文件中。假设类A的一个成员是是一个指向类B的指针，在类A的头文件中使用了类 B的前置声明并编译成功，那么在A的实现中我们需要访问B的具体成员，因此需要包含头文件，那么我们应该在类A的实现部分（CPP文件）包含类B的头文件而非声明部分(H文件) 摘自:https://www.cnblogs.com/fengzhengfly/p/8884581.html C++ 构造函数的使用 1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class CUser&#123; public: string UID; int status; void login(); CUser():UID(\"0\"),status(0)&#123;&#125; CUser(string id,int sts):UID(id),status(sts)&#123;&#125;&#125;;int main()&#123; CUser user(\"hello\",12); cout &lt;&lt; user.UID &lt;&lt; user.status; getchar(); return 0;&#125; string转int 1234567891011atoi(rstatus.c_str()) //atoi(&quot;04&quot;); ===&gt; 4 可以忽略0---使用stringstream:string s = &quot;17&quot;;stringstream ss;ss&lt;&lt;s;int i;ss&gt;&gt;i;cout&lt;&lt;i&lt;&lt;endl; // 17//stringstream可以吞下任何类型，根据实际需要吐出不同的类型 int转string 123456int n = 0;std::stringstream ss;std::string str;ss&lt;&lt;n;ss&gt;&gt;str;//或者cout &lt;&lt; ss.str(); 1itoa(num, str, 10); string转int 12std::string str = &quot;123&quot;;int n = atoi(str.c_str()); int 转string 12345678910这是C++11新增的，使用非常方便，简单查了下：C++11标准增加了全局函数std::to_string，string to_string (int val);string to_string (long val);string to_string (long long val);string to_string (unsigned val);string to_string (unsigned long val);string to_string (unsigned long long val);string to_string (float val);string to_string (double val);string to_string (long double val) 一.string转char * data() c_str() copy(); 1、string转char*。 1234561 string str = &quot;hello&quot;;2 const char* p = str.data();//加const 或者用char * p=(char*)str.data();的形式/* 同时有一点需要说明，这里在devc++中编译需要添加const，否则会报错invalid conversion from const char* to char *，这里可以再前面加上const或者在等号后面给强制转化成char*的类型。 下面解释下该问题，const char*是不能直接赋值到char*的,这样编译都不能通过,理由:假如可以的话,那么通过char*就可以修改const char指向的内容了,这是不允许的。所以char*要另外开辟新的空间，即上面的形式。 */ 2.c_str()方法，如： 121 string str=“world”;2 const char *p = str.c_str();//同上，要加const或者等号右边用char* 3.copy()方法，如： 12341 string str=&quot;hmmm&quot;;2 char p[50];3 str.copy(p, 5, 0);//这里5代表复制几个字符，0代表复制的位置，4 *(p+5)=‘\\0’;//注意手动加结束符！！！ 二、char * 转string。 1231 string s;2 char *p = &quot;hello&quot;;//直接赋值3 s = p; 这里有一点要说明，当声明了string类型变量s后，用printf(&quot;%s&quot;,s);是会出错的，因为“%s”要求后面的对象的首地址。但是string不是这样的一个类型。所以肯定出错。 1234567891011121314151617181920class A&#123;public: void co(); void bo();&#125;;void A::co()&#123; cout &lt;&lt; \"hello\"; A::bo();&#125;void A::bo()&#123; cout &lt;&lt; \"world\";&#125;#include &lt;cstdio&gt;int main()&#123; A a; a.co(); getchar();&#125; 1234567891011121314151617181920int main()&#123; ifstream inFile(&quot;data1.csv&quot;, ios::in); if (inFile.fail())&#123; cout &lt;&lt; &quot;Cannot open file&quot; &lt;&lt; endl; return -1; &#125; vector&lt;string&gt; line; string lineStr; while (getline(inFile, lineStr) )&#123; line.push_back(lineStr); &#125; for(vector&lt;string&gt;::iterator i=line.begin();i!=line.end();i++)&#123; // cout &lt;&lt; strArray.at(i)&lt;&lt;endl; cout &lt;&lt; (*i) &lt;&lt; endl; &#125; getchar(); return 0;&#125; 1234cout &lt;&lt; &quot;请输入书的数量：&quot; &lt;&lt; endl; do&#123; cin &gt;&gt; tmp.TotalNumber;&#125;while( atoi( tmp.TotalNumber.c_str()) == 0 ) ; //非数字情况 操作二维Vector 123456789101112131415string lineStr;vector&lt;vector&lt;string&gt;&gt; strArray;while (getline(inFile, lineStr) )&#123; stringstream ss(lineStr); string str; vector&lt;string&gt; lineArray;while (getline(ss, str, &apos;,&apos;)) lineArray.push_back(str); strArray.push_back(lineArray);for(vector&lt;vector&lt;string&gt;&gt;::iterator i=strArray.begin();i!=strArray.end();i++)&#123; for(vector&lt;string&gt;::iterator j=(*i).begin();j!=(*i).end();j++)&#123; cout &lt;&lt; &quot;*j &quot; ; &#125; cout &lt;&lt; endl; &#125;&#125; 改好的 12345678910111213141516171819202122232425262728293031323334int main()&#123; ifstream inFile(\"data1.csv\", ios::in); vector&lt;vector&lt;string&gt;&gt; lineVec; if (inFile.fail())&#123; cout &lt;&lt; \"Cannot open file\" &lt;&lt; endl; return -1; &#125; string lineStr; vector&lt;vector&lt;string&gt;&gt; vecArray; vector&lt;string&gt; newvec; while (getline(inFile, lineStr) )&#123; stringstream ss(lineStr); string str; vector&lt;string&gt; lineVec; while (getline(ss, str, ',')) lineVec.push_back(str); vecArray.push_back(lineVec); for(vector&lt;vector&lt;string&gt;&gt;::iterator i=vecArray.begin();i!=vecArray.end();i++)&#123; vector&lt;string&gt;::iterator j=(*i).begin(); if( *j != \"100009/1\" ) &#123;newvec.push_back(lineStr); break; &#125; &#125; &#125; for (std::vector&lt;string&gt;::iterator i = newvec.begin(); i != newvec.end(); ++i) cout &lt;&lt; *i &lt;&lt; endl; system(\"pause\"); return 0;&#125; 二维Vector 1234567891011121314151617int main(int argc, char const *argv[])&#123; vector&lt;vector&lt;string&gt;&gt; row; vector&lt;string&gt; col1; vector&lt;string&gt; col2; col1.push_back(&quot;Q&quot;); col1.push_back(&quot;W&quot;); col2.push_back(&quot;A&quot;); col2.push_back(&quot;S&quot;); row.push_back(col1); row.push_back(col2); cout &lt;&lt; row.at(0).at(1); getchar(); return 0;&#125; 查看vector中是否含指定的string 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(int argc, char const *argv[])&#123; std::vector&lt;string&gt; v; v.push_back(&quot;hello&quot;); v.push_back(&quot;1ord&quot;); v.push_back(&quot;asd&quot;); if (std::find(v.begin(), v.end(), &quot;he&quot;) != v.end()) &#123; cout &lt;&lt; &quot;yes&quot;; &#125; getchar(); return 0;&#125; 循环时删除某个元素,不影响循环==&gt;每个元素仍能被遍历 1234567891011121314int main()&#123; vector&lt;string&gt; v; v.push_back(\"1\"); v.push_back(\"2\"); v.push_back(\"3\"); v.push_back(\"4\"); for (int i = 0; i &lt; v.size(); ++i)&#123; if (v.at(i) == \"2\") v.erase(v.begin()+i); &#125; for (int i = 0; i &lt; v.size(); ++i) cout &lt;&lt; v.at(i) &lt;&lt; endl; system(\"pause\"); return 0;&#125; 跳过索引值,只输出id 123456789101112131415161718192021int main(int argc, char const *argv[])&#123; ifstream inFile; inFile.open(&quot;data1.csv&quot;); string lineStr; vector&lt;vector&lt;string&gt; &gt; row; vector&lt;string&gt; newvec; while (getline(inFile, lineStr) )&#123; stringstream ss(lineStr); string str; vector&lt;string&gt; col; while (getline(ss, str, &apos;,&apos;)) col.push_back(str); row.push_back(col); &#125; for (int i = 1; i &lt; row.size(); ++i) cout &lt;&lt; row.at(i).at(0) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 避免错误输入 1while(getchar()!=&apos;\\n&apos;) ; 分割时间 12345678910111213141516171819202122232425void CData(string &amp;timestr)&#123; stringstream ss(timestr); int year; int mon; int day; string str; getline(ss, str, &apos;/&apos;); year = atoi(str.c_str()); getline(ss, str, &apos;/&apos;); mon = atoi(str.c_str()); getline(ss, str, &apos;/&apos;); day = atoi(str.c_str()); cout &lt;&lt; year &lt;&lt; &quot;,&quot; &lt;&lt; mon &lt;&lt; &quot;,&quot; &lt;&lt; day &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123; // string a =&quot;2017/04/02&quot;; // CData(a); stringstream ss; ss &lt;&lt; 1 &lt;&lt; &quot;/&quot; &lt;&lt; 2 &lt;&lt; &quot;/&quot; &lt;&lt; 3; cout &lt;&lt; ss.str(); getchar(); return 0;&#125; 12stringstream ss;ss &lt;&lt; 1 &lt;&lt; &quot;/&quot; &lt;&lt; 2 &lt;&lt; &quot;/&quot; &lt;&lt; 3; vector最大值 1int maxn = *max_element(v.begin(),v.end()); 找到最大ID 123456789101112vector&lt;string&gt; idcol;string lineStr; while (getline(infile, lineStr) )&#123; //获取行 stringstream ss(lineStr); string bookid; //记录列数据,必须写在这个循环里 getline(ss, bookid, &apos;,&apos;); idcol.push_back(bookid);&#125; int addid = vecMAX(idcol)+1; stringstream inttostring; inttostring &lt;&lt; addid; tmp.BookID = inttostring.str(); 二维VEC排序 12345678910111213141516171819int main()&#123; std::vector&lt;std::vector&lt;int&gt; &gt; s; vector&lt;int&gt; v1; vector&lt;int&gt; v2; v1.push_back(5); v1.push_back(13); s.push_back(v1); v2.push_back(7); v2.push_back(4); s.push_back(v2); sort(s.begin(), s.end()); for (int i = 0; i &lt; s.size(); ++i)&#123; for (int j = 0; j &lt; v1.size(); ++j) cout &lt;&lt; s.at(i).at(j); cout &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 123out.open(USERTMPFILE) 可以打开宏定义ios::in + ios::out 从开头加ios::app 从结尾加 获得值最大的键 12345678910111213141516bool cmp(const pair&lt;string, int&gt;&amp; lhs, const pair&lt;string, int&gt;&amp; rhs) &#123; return lhs.second &gt; rhs.second; &#125; int main(int argc, char const *argv[])&#123; map&lt;string,int&gt; a ; a.insert(pair&lt;string, int&gt;(&quot;ssd&quot;, 3)); a[&quot;hello&quot;]=3; a[&quot;world&quot;]=9; a[&quot;cl&quot;]=6; std::vector&lt; pair&lt;string, int&gt; &gt; v(a.begin(), a.end()); sort(v.begin(), v.end(),cmp); cout &lt;&lt; &quot;max&quot; &lt;&lt; v.at(0).first &lt;&lt; endl; getchar(); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"程序设计","slug":"程序设计","permalink":"https://nymrli.top/tags/程序设计/"}]},{"title":"ACM-DFS、BFS","slug":"ACM-DFS、BFS","date":"2019-03-07T11:55:03.000Z","updated":"2020-11-05T13:01:51.466Z","comments":true,"path":"2019/03/07/ACM-DFS、BFS/","link":"","permalink":"https://nymrli.top/2019/03/07/ACM-DFS、BFS/","excerpt":"","text":"深度优先搜索(DFS) 从某个状态,不断转移状态直到无法转移,然后回退到前一步的状态,继续转移到其他状态,如此不断重复,直到找到最终解. ====&gt; 递归函数 隐式的用到了栈(stack) 123456789101112131415161718192021222324252627//[部分和问题]#include &lt;iostream&gt;#define MAXN 10000int n,k;int s[MAXN];using namespace std;bool dfs(int i,int sum)&#123; if( i == n ) return sum == k;//如果前n项计算过了，返回sum=k是否相等 if ( dfs(i+1 , sum) ) return true; //不加上s[i]的情况； if ( dfs(i+1, sum + s[i] )) return true; //加上s[i]的情况 return false; //无论加不加上s[i]&#125;void input()&#123; cin &gt;&gt; n; for(int i=0;i&lt;n;i++) cin &gt;&gt; s[i]; cin &gt;&gt; k;&#125;int main()&#123; input(); if (dfs(0,0)) cout &lt;&lt; \"YES\"; else cout &lt;&lt;\"NO\"; return 0;&#125; laking countiing 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//[laking countiing]#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 10000using namespace std;int N,M;char field[MAXN][MAXN]=&#123;&#123;\"W........WW.\"&#125;,&#123;\".WWW.....WWW\"&#125;,&#123;\"....WW...WW.\"&#125;,&#123;\".........WW.\"&#125;,&#123;\".........W..\"&#125;,&#123;\"..W.......W.\"&#125;,&#123;\".W.W.....WW.\"&#125;,&#123;\"W.W.W.....W.\"&#125;,&#123;\".W.W......W.\"&#125;,&#123;\"..W.......W.\"&#125;&#125;;void dfs(int x,int y)&#123; field[x][y] = '.'; //循环遍历移动的8个方向,检测八连通位置 for(int dx=-1;dx&lt;=1;dx++) for(int dy=-1;dy&lt;=1;dy++)&#123; int nx=x+dx; //移动后的结果为(nx,ny) int ny=y+dy; if( (0 &lt;= nx &amp;&amp; nx&lt; N) &amp;&amp; (0 &lt;= ny &amp;&amp; ny &lt; M) &amp;&amp; field[nx][ny]=='W') dfs(nx,ny); //此处为做题的关键 : 不断 &#125; return ;&#125;void solve()&#123; int res = 0; //水坑数量 for(int i=0;i&lt;N;i++) for(int j=0;j&lt;M;j++)&#123; if(field[i][j] == 'W')&#123; dfs(i,j); res++; &#125; &#125; printf(\"%d\\n\",res);&#125;void printLake()&#123; N=10;M=12; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++) cout &lt;&lt; field[i][j] ; cout &lt;&lt; endl; &#125;&#125;int main()&#123; N=10; M=12; solve(); return 0;&#125; 宽度优先搜索(BFS) 总是优先搜索距离初始状态最近的状态,复杂度 = O(状态书 * 转移的方式) 显式利用队列(queue),搜索时首先将初始状态添加到队列里,此后从队列的最前端不断取出状态,吧从该状态可以转移到的状态中尚未访问过的部分加入队列,如此往返,直至队列被取空或是找到了问题的解 广度优先搜索思想 设图G的初态是所有顶点均未访问，在G 中任选一顶点i作为初始点，则广度优先搜索的基本思想是： （1）从图中的某个顶点V出发，访问之；并将其访问标志置为已被访问，即visited[i]=1； （2）依次访问顶点V的各个未被访问过的邻接 点，将V的全部邻接点都访问到； （3）分别从这些邻接点出发，依次访问它们的未被访问过的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接 点”被访问，直到图中所有已被访问过的顶点的邻接点都被访问到。依此类推，直到图中所有顶点都被访问完为止 。 广度优先搜索在搜索访问一层时，需要记住已被访问的顶点，以便在访问下层顶点时，从已被访问的顶点出发搜索访问其邻接点。所以在广度优先搜索中需要设置一个队列Queue，使已被访问的顶点顺序由队尾进入队列。在搜索访问下层顶点时，先从队首取出一个已被访问的上层顶点，再从该顶点出发搜索访问它的各个邻接点。 1234567891011W........WW..WWW.....WWW....WW...WW..........WW..........W...........WW...W.......W..W.W.....WW.W.W.W.....W..W.W......W...W.......W. 1234567891011&#123;W........WW.&#125;&#123;.WWW.....WWW&#125;&#123;....WW...WW.&#125;&#123;.........WW.&#125;&#123;.........W..&#125;&#123;.........WW.&#125;&#123;..W.......W.&#125;&#123;.W.W.....WW.&#125;&#123;W.W.W.....W.&#125;&#123;.W.W......W.&#125;&#123;..W.......W.&#125; 2019蓝桥杯省赛–maze 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#include &lt;string&gt;#include &lt;queue&gt;/*010010001000000101110000访问次数:9访问次序:DRDRDRRR*/using namespace std;typedef pair&lt;int ,int&gt; State;const int maxn = 1000;const int row = 4;const int col = 6;//const int INF = 10000000;char maze[row+1][col+1];int visited[row+1][col+1]; //是否访问过，记录次数string trace[row+1][col+1]; //记录每次移动的方向int X[] = &#123;-1,0,1,0&#125;; // 这边可能定义错了，这个对应的是行int Y[] = &#123;0,1,0,-1&#125;; // 这个对应的是列，而不是X,Ystring sarr[] = &#123;\"U\",\"R\",\"D\",\"L\"&#125;;int x=1;int y=1;void bfs()&#123; queue&lt;State&gt; q; // 起点 q.push(State(x,y)); while( !q.empty() )&#123; // 取状态 State s = q.front(); q.pop(); if( x == row &amp;&amp; y == col ) break; // 到达终点 // 一个数组记录四个方向 for( int i = 0 ; i &lt; 4; i++)&#123; int nx = s.first + X[i]; int ny = s.second + Y[i]; if( nx &gt;= 1 &amp;&amp; nx &lt;= row &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= col &amp;&amp; maze[nx][ny] != '1'&amp;&amp; visited[nx][ny] == 0 ) &#123; //cout &lt;&lt; nx &lt;&lt; ny &lt;&lt; endl; visited[nx][ny] = 1; //cout &lt;&lt; maze[nx][ny] &lt;&lt; sarr[i] &lt;&lt; endl; //cout &lt;&lt; endl; visited[nx][ny] = visited[s.first][s.second] +1; trace[nx][ny] = trace[s.first][s.second] + sarr[i]; q.push(State(nx,ny)); &#125; &#125; &#125; cout &lt;&lt;\"times:\"&lt;&lt; visited[row][col] &lt;&lt;endl; cout &lt;&lt;\"order:\"&lt;&lt; trace[row][col] &lt;&lt;endl;&#125;int main()&#123; // 初始化 for(int i=1 ; i &lt;= row ; i++) for(int j= 1; j &lt;= col ; j++) visited[i][j] = 0; // 起点为(1,1) visited[1][1] = 1; //处理输入 for(int i=1 ; i &lt;= row ; i++)&#123; for(int j= 1; j &lt;= col ; j++) scanf(\"%c\",&amp;maze[i][j]); getchar(); &#125; bfs(); return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"ACM-快速幂","slug":"ACM-快速幂","date":"2019-03-07T11:54:05.000Z","updated":"2019-09-15T08:07:30.915Z","comments":true,"path":"2019/03/07/ACM-快速幂/","link":"","permalink":"https://nymrli.top/2019/03/07/ACM-快速幂/","excerpt":"","text":"简单位运算快速幂 假设我们要求ab，那么其实b是可以拆成二进制的，该二进制数第i位的权为2(i-1)，例如当b==11时，a11=a(20+21+2^3) 123456789int poww(int a,int b)&#123; int ans=1,base=a; while(b!)&#123; if(b&amp;1) ans*=base; base*=base; b&gt;&gt;=1; &#125; return ans;&#125; 11的二进制是``1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算a^(2^0)*a^(2^1)*a^(2^3) 其中比较重要的一步:base*=base,即基底不断增加,如果二进制是1则*上基底否则不,ans为所有基底相乘 1234567base*base==base^2下一步再乘，就是base^2*base^2==base^4然后同理 base^4 * base4 = base^8 see?是不是做到了base--&gt;base^2--&gt;base^4--&gt;base^8--&gt;base^16--&gt;base^32.......指数正是 2^i ，再看上面的例子，a¹¹ = a^(2^0) * a^(2^1) * a^(2^3)，这三项是不是完美解决了，，嗯，快速幂就是这样。 ▲.由于指数函数是爆炸增长的函数，所以很有可能会爆掉int的范围，根据题意决定是用 long long啊还是unsigned int啊还是mod某个数啊自己看着办。 12345678910typedef long long ll;ll mod_pow(ll base,ll n,ll mod)&#123; ll res=1; while(n&gt;0)&#123; if( n &amp; 1 ) res = res*base%mod; base = base*base%mod; n&gt;&gt;= 1; &#125; return res;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"}]},{"title":"南京邮电大学java程序设计作业在线编程第三次作业","slug":"南京邮电大学java程序设计作业在线编程第三次作业","date":"2019-03-07T11:12:47.000Z","updated":"2019-09-15T08:07:31.033Z","comments":true,"path":"2019/03/07/南京邮电大学java程序设计作业在线编程第三次作业/","link":"","permalink":"https://nymrli.top/2019/03/07/南京邮电大学java程序设计作业在线编程第三次作业/","excerpt":"","text":"选择题得分：60 \\1. 设有如下定义语句： String s1=”My cat”; int m=s1.compareTo(“My a cat”); 语句被执行后m的值为（ ） A.2 B.1 C.0 D.-2 正确答案是: A \\2. 语句 String s1=new String(“Hello”); String s2=new String(“Hello”); System.out.println(s1==s2); System.out.printlv(s1.equals(s2)); 执行后的输出结果是（ ） A.Hello false B.Hello true C.Hello Hello D.false true 正确答案是: D \\3. 执行下列语句 int[] lx={2,3,4,5}; lx[3]=lx[3]==–lx[0]?++lx[1]:lx[2]–; 后，数组lx的元素值分别为（ ） A.1,2,3,4 B.1,3,3,3 C.1,2,3,3 D.1,3,3,4 正确答案是: D \\4. 在一个应用程序中定义了数组a：int[] a={1,2,3,4,5,6,7,8,9,10}，为了打印输出数组a的最后一个数组元素，下面正确的代码是（ ） A.System.out.println(a[10]); B.System.out.println(a[9]); C.System.out.println(a[8]); D.System.out.println(a[a.length]); 正确答案是: B \\5. 设有定义语句int a[]={36,72,99};则以下对此语句叙述错误的是（ ） A.该语句定义了一个名为a的一维数组； B.a数组有3个元素； C.数组中的每个元素是整型； D.a数组的元素的下标为1~3； 正确答案是: D \\6. 下面关于数组定义语句不正确的是（ ） A.float f[]=new{2.4f,3.5f,5.7f,7.9f}; B.int a[]={1,2,3,4,5} C.double[]d=new double[10]; D.int[]a2; 正确答案是: A \\7. 下列语句序列执行后，c的值是（ ） int a=3,b=4,c=0; while ((a++)&lt;(–b))++c; A.0 B.1 C.2 D.3 正确答案是: A \\8. 下列语句序列执行后，a的值是（ ） int a=1; for(int i=5;i&gt;0;i-=2) a*=i; A.0 B.1 C.15 D.60 正确答案是: C \\9. 下列语句序列执行后，c的值是（ ） int a=10,b=18,c=30; switch(b-a){ case 8 : c++; case 9 : c+=2; case 10 : c+=3; default :c/=b; } A.31 B.32 C.2 D.33 正确答案是: C \\10. 设a、b为int型变量，c、d为fload类型变量，ch为char类型变量，且所有变量均已赋值，则下列正确的switch语句是（ ） A.switch(a+b);{…} B.switch(ch+1){…} C.switch ch {…} D.switch(c+d){…} 正确答案是: B \\11. 下列语句序列执行后，c的值是（ ） int a=4,b=5,c=9,d=6; if (a&gt;b||c&lt;d) c–; else c++; A.6 B.10 C.8 D.9 正确答案是: B \\12. 下列语句序列执行后，c的值是（ ） int a=6,b=3,c=5; if (a==b) c+=a;else c=++a*c; A.15 B.25 C.35 D.45 正确答案是: C \\13. 下列语句序列执行后，c变量的值为（ ） int a=2,b=4,c=5; if (a&lt;–b) c*=a; A.5 B.20 C.15 D.10 正确答案是: D \\14. 下列语句序列执行后，ch1变量中的值为（ ） char ch1=’A’,ch2=’B’; if (ch1+2&lt;ch2)++ch1; A.‘A’ B.‘B’ C.A D.B 正确答案是: A \\15. 以下选项中，合法的赋值语句是（ ） A.++m!=n–; B.++m; C.m=m+1=5; D.m==1; 正确答案是: B \\16. 设有定义“int a=22;long b=56;”，下面赋值不正确的语句是（ ） A.a=b; B.b=(long)a; C.a=(int)b; D.b=a; 正确答案是: A \\17. 下面选项中，（ ）是正确的输出结果 int m=2,n=1; m+=m-=n; System.out.println(“m=”+m); A.m=1 B.m=2 C.m=3 D.m=4 正确答案是: C \\18. 下列语句序列执行后的结果为（ ） int a=10,b=4,c=20,d=6; System.out.println(a++b+c–d); A.144 B.140 C.28 D.不能执行 正确答案是: B \\19. 假设以下选项中的变量都已经正确定义，则不合法的表达式是（ ） A.a&gt;4==6&lt;1; B.’n’-3; C.’a’=8; D.’A’%6 正确答案是: C \\20. 假设a为已经声明并以赋初值的int类型变量，则对于a的赋值语句正确的是（ ） A.int a=6; B.a==3; C.a=3.2f; D.a+=a*3; 正确答案是: D 编程题得分：40 1.打印每月有几天 得分：10 / 10 1234567891011121314151617181920212223242526272829import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123; public static boolean isYeap(int year) &#123; if ( year%4==0 &amp;&amp; year%100 != 0 ) return true; if (year%400 == 0) return true; return false; &#125; public static void main(String []args) &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); int b = s.nextInt(); int yeap[] = &#123;31,29,31,30,31,30,31,31,30,31,30,31&#125;; int noyeap[] = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; if ( isYeap(a) ) System.out.println(\"\"+a+\"-\"+b+\"-\"+yeap[b-1]+\"\"); else System.out.println(\"\"+a+\"-\"+b+\"-\"+noyeap[b-1]+\"\"); &#125;&#125; 4-3-2 百分制成绩转换等级制成绩 得分：10 / 10 1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123;public static void main(String []args) &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); if ( a&lt;0 || a &gt; 100) System.out.printf(\"Error input\\n\"); else &#123; int REa = a/10; switch (REa) &#123; case 6: System.out.printf(\"%d -- %c\\n\",a,'D'); break; case 7: System.out.printf(\"%d -- %c\\n\",a,'C'); break; case 8: System.out.printf(\"%d -- %c\\n\",a,'B'); break; case 9: case 10: System.out.printf(\"%d -- %c\\n\",a,'A'); break; default: System.out.printf(\"%d -- %c\\n\",a,'E'); &#125; &#125; &#125; &#125; 用if语句求解分段函数 得分：10 / 10 1234567891011121314151617181920import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123;public static void main(String []args) &#123; Scanner s = new Scanner(System.in); double a = s.nextDouble(); double b=0; if (a&lt;20) b=a+100; else if ( a&gt;100 ) b=a-100; else b=a; System.out.printf(\"x=%.2f,y=%.2f\\n\",a,b); &#125; &#125; 2-2 混合类型数据格式化输入 得分：10 / 10 12345678910111213141516171819import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123;public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); double d1 = s.nextDouble(); int i = s.nextInt(); String ss = s.next(); char ch = ss.charAt( 0 ); double d2 = s.nextDouble(); System.out.printf(\"%c %d %.2f %.2f\",ch,i,d1,d2); &#125; &#125; 3-4-1a 计算三位数的位数和 得分：10 / 10 12345678910111213141516171819202122import java.util.Scanner;import java.io.*;/** * @author Mr.li * @Date 2019年3月7日 */public class Main &#123;public static void main(String []args)throws IOException &#123; Scanner s = new Scanner(System.in); int n = s.nextInt(); int sum = 0; if ( n &lt; 0) n = -n; // 保证绝对值 while(n!=0) &#123; int left = n%10; sum += left; n/= 10; &#125; System.out.printf(\"%d\\n\",sum); &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Linux下开机启动Python脚本","slug":"Linux下开机启动Python脚本","date":"2019-03-03T11:48:46.000Z","updated":"2019-09-15T08:07:30.959Z","comments":true,"path":"2019/03/03/Linux下开机启动Python脚本/","link":"","permalink":"https://nymrli.top/2019/03/03/Linux下开机启动Python脚本/","excerpt":"","text":"/etc/rc.local 将脚本写在/etc/rc.local文件 输入命令：sudo vi /etc/rc.local 在exit 0上一行输入：python /usr/bin/python /home/pi/test.py 重启就可以看效果sudo reboot 当然，rc.local 文件需要有执行权限（默认没有） $ sudo chmod +x /etc/rc.local 对于命令，最好是先which python查出命令路径，写命令时写绝对路径 /etc/init.d 写一个服务放到linux的/etc/init.d目录中 并且授权bash脚本chmod 755 /etc/init.d/mypython 1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin/bash# chkconfig: 2345 66 36# /etc/rc.d/init.d/opt/python# description: spython#case \"$1\" in start) echo -n \"Starting python: \" echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python date +\"! %T %a %D : Starting python .\" &gt;&gt;/var/log/python echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python echo start cd /root/finmonAgent/bin ./finmonAgent.py &amp; #sh /root/finmonAgent/startpy echo \"Done.\" echo \"\" echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python date +\"! %T %a %D : Finished.\" &gt;&gt;/var/log/python echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python touch /var/lock/subsys/python ;; stop) echo -n \"Shutting Down python Listeners: \" echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python date +\"! %T %a %D : Shutting Down python.\" &gt;&gt;/var/log/python echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python echo \"python\" killall -9 finmonAgent.py echo \"Done.\" rm -f /var/lock/subsys/python echo \"Done.\" echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python date +\"! %T %a %D : Finished.\" &gt;&gt;/var/log/python echo \"---------------------------------------------------------------------------------\" &gt;&gt;/var/log/python ;; *) echo \"Usage: python &#123; start | stop | restart &#125;\" exit 1esacexit 0 /ect/profile /ect/profile 文件是系统默认的主启动文件，系统上每个用户登录时都会执行； linux 配置文件（启动文件、环境文件）启动顺序 1、登录shell 登录shell时，linux会按一定规则读取启动几个配置文件： /ect/profile $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile 其中 /ect/profile 文件是系统默认的主启动文件，系统上每个用户登录时都会执行； a、命令行登录和ssh登录，shell会按照以下顺序，运行第一个被找到的文件，余下的会被忽略： $HOME/.bash_profile $HOME/.bash_login $HOME/.profile 上面没有 $HOME/.bashrc ，因为该文件一般通过其他文件运行。 b、图形界面登录，只加载 /ect/profile和$HOME/.profile，其他的会被忽略。 对于 no-login shell，即图形界面打开的shell，只会读入 $HOME/.bashrc 文件，不会检查 /etc/.profile 等其他登录shell文件。 2、交互式shell 不是登录系统时启动，提供命令行提示符来输入命令。（不会访问 /etc/profile 文件，会检查 $HOME/.bashrc 文件） 3、非交互式shell 系统执行脚本时所用，没有命令行提示符。 linux将指令加入开机启动或加入环境变量 （2）在profile中添加PATH，这种方法对所有用户都是永久生效。 a）打开profile文件 1`vim /etc/profile` b）在profile文件的PATH中添加mongo指令。在PATH后面添加“:/usr/local/webserver/mongo/bin”，＝ 等号两边不能有任何空格。 1`PATH=``$PATH``:/usr/local/webserver/mongo/bin` c）执行指令，使profile修改立即生效。 1`source profile` （3）在当前profile中添加PATH，这种方法对当前用户永久生效。与第二步类似，将profile替换为bash_profile。 1`vim ~/.bash_profile` 1`PATH=``$PATH``:/usr/local/webserver/mongo/bin` 1`source ~/.bash_profile` 2，linux将指令加入开机启动 在/etc/rc.local中添加指令即可 1`/usr/local/webserver/mongodb/bin/mongod --dbpath=/data0/mongodb/data --logpath=/data0/mongodb/logs --logappend --port=27017`","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"}]},{"title":"codeblocks中boost库安装","slug":"codeblocks中boost库安装","date":"2019-03-03T11:04:59.000Z","updated":"2019-09-15T08:07:30.928Z","comments":true,"path":"2019/03/03/codeblocks中boost库安装/","link":"","permalink":"https://nymrli.top/2019/03/03/codeblocks中boost库安装/","excerpt":"","text":"首先要提出的是，boost在VS中是可以直接导入的，但是在CB中是不行的，所以写了下这篇文章。 安装boost 1.首先先去boost官网下载boost的源码 ， 选择你要下载的版本。 2.解压（可能会耗费一段时间，小文件比较多） 3.双击运行脚本文件bootstrap.bat（引导程序），之后就生成这两个可执行文件 我们为了能直观的看到编译boost的细节信息，进入dos (win +ｒ快捷键 输入cmd ) 4.cd 到解压boost库的目录下 5.命令执行bjam.exe 4-5是没必要的，要是不想看输出的东西的话，其实双击bjam.exe即可 ▲.编译的时间略久（你可以干一会其他事，喝个茶） 注: 安装boost貌似需要VS的某个模块，一开始在活动室电脑上装由于没有VS，所以没装成，最后在自己的电脑上装好的。 codeblocks设置 点击settings，选择下拉菜单中的 compiler选项 注意这里选择Search directories第三项 最下面有一个add按钮，点击将boost解压路径添加即可。 之后你可以随便写一点程序进行测试 12345678910#include &lt;boost/lambda/lambda.hpp&gt;#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;int main()&#123; using namespace boost::lambda; typedef std::istream_iterator&lt;int&gt; in; std::for_each( in(std::cin), in(), std::cout &lt;&lt; (_1 * 3) &lt;&lt; \" \" );&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"ACM_线性筛","slug":"ACM-线性筛","date":"2019-03-03T08:57:36.000Z","updated":"2019-10-29T12:31:18.223Z","comments":true,"path":"2019/03/03/ACM-线性筛/","link":"","permalink":"https://nymrli.top/2019/03/03/ACM-线性筛/","excerpt":"","text":"什么是线性筛? 筛素数是为了求得一个区间内的所有素数，而把不是素数的筛去。 最普通的办法——判断一个数是不是素数 123456789101112131415161718#define SIZE 1000000int main()&#123; int check[SIZE]; int prime[SIZE] = &#123;0&#125;; int pos; int flag; for (int i = 2 ; i &lt; SIZE ; i++)&#123; flag = 1; for (int j = 2 ; j &lt; sqrt(i) ; j++)&#123; if (i % j == 0) flag = 0; &#125; if (flag == 1) prime[pos++] = i; &#125; printf(\"%.2f\", (double)clock()/CLOCKS_PER_SEC); return 0;&#125; 普通筛素数——将不是素数的筛掉 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;#define SIZE 1000int main()&#123; int checked[SIZE] = &#123;0&#125;; // 如果是1的话就是合数 int prime[SIZE] = &#123;0&#125;; int pos = 0; int i,j; for( i = 2;i &lt; SIZE ; i++)&#123; if ( ! checked[i] )&#123; prime[pos++] = i; &#125; for( j = 2*i; j &lt; SIZE ; j += i ) checked[j] = 1; &#125; for( i = 0;i&lt; SIZE ; i++) if (prime[i] == 0)&#123; cout &lt;&lt; i-1 &lt;&lt; endl; // 素数的个数 break; &#125; return 0;&#125;// output : 168 普通筛素数 基本思想 一次循环筛掉当前素数的倍数 缺点 存在重复筛选，比如6既可以被2筛掉，又可以被3筛掉。 原因：任意一个整数可以写成一些素数的乘积 n=p1a∗p2b∗p3cn=p_{1}^{a} * p_{2}^{b} * p_{3}^{c}n=p1a​∗p2b​∗p3c​，其中p1&lt;p2&lt;p3p1&lt;p2&lt;p3p1&lt;p2&lt;p3，这样这个数n就能被p1,p2和p3筛掉 解决方法：按照一个数的最小素因子筛去(也就是这里的p1)就可以啦，这也就有了线性筛素数 线性筛素数 1234567891011121314151617181920212223242526272829303132#define SIZE 1000int main()&#123; int check[SIZE] = &#123;0&#125;;//元素值为0代表是素数 int prime[SIZE] = &#123;0&#125;; int pos=0; for (int i = 2 ; i &lt; SIZE ; i++)&#123; if (!check[i])//如果是素数 prime[pos++] = i; // ★.区别在于此 for (int j = 0 ; j &lt; pos &amp;&amp; i*prime[j] &lt; SIZE ; j++)&#123;/* cl觉得可以写成for (int j = 0 ; i*prime[j] &lt; SIZE ; j++)j &lt; pos 是多余的,如果i是个素数,比如7,那么prime[x]=7,当j=x的时候必然有if (i % prime[j] == 0), 此时x=pos - 1如果是个合数,比如15,那么肯定有最小素因子使得(i % prime[j] == 0),此时j &lt; pos 如果i是个偶数,比如8,那么if (i % prime[j] == 0) 此时在2的时候就退出了。j=0 &lt; pos2019-4-26 j&lt;pos不能删,这个是主要控制j取值的大小的因素,控制取出的都是已知的素数*/ check[i*prime[j]] = 1;//筛掉 //标注一 // 通过这步可以找到最小素数因子, // 比如12,那么 prime[j] 最先== prime[0] == 2 , 即找到了最小的因子2, // 那12就不是个素数,就不用再判断它是不是能被3合成 if (i % prime[j] == 0) break; &#125; &#125; printf(\"%.2f\", (double)clock()/CLOCKS_PER_SEC); return 0;&#125; 基本思想 当前数字是n=p1a∗p2b∗p3cn=p_{1}^{a} * p_{2}^{b} * p_{3}^{c}n=p1a​∗p2b​∗p3c​(p1&lt;p2&lt;p3且均为素数)，一次循环筛除小于等于p1的素数乘以n得到的数。比如p1之前有pi,pj和pk三个素数，则此次循环筛掉pi*n,pj*n,pk*n和p1*n ，实现见代码的标注一，prime 里的素数都是升序排列的，break时的prime[j] 就是这里的p1。 优点：没有重复筛同一个数 原因：按照一个数的最小素因子筛选，比如6只按2筛去 从图上我们看到，第一列筛掉的是最小素因子是2的数，第二列筛掉的是最小素因子为3的数，第三列最小素因子是prime[2]==5 ，依次类推，可以把所有的合数都筛掉。 由于每列筛掉的合数都是 它自身的平方 ， 即 一个素数最小的因子除了1就是它本身， 所以 素数的平方的最小素因子就是 它本身 ， 而通过i % prime[j] == 0就可以控制不多筛。 因为是按照最小素因子筛选，所以可以保证每个数都只会被筛一遍 ==&gt; 18--9x2 摘自：这只菜鸟总算搞懂了线性筛素数 素数的判别挺有意思的，剪枝的方法可以见我的另一篇博客 : 素数判别","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"线性筛","slug":"线性筛","permalink":"https://nymrli.top/tags/线性筛/"}]},{"title":"flask+nginx如何获得真实IP","slug":"flask-nginx如何获得真实IP","date":"2019-03-02T12:53:58.000Z","updated":"2019-09-15T08:07:30.933Z","comments":true,"path":"2019/03/02/flask-nginx如何获得真实IP/","link":"","permalink":"https://nymrli.top/2019/03/02/flask-nginx如何获得真实IP/","excerpt":"","text":"如果是通过 flask 的 request.remote_addr获取的 ip 都是 127.0.0.1 解决方案: nginx.conf中添加 123# proxy_set_header Host $host:80; # proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 全文 12345678910111213141516server &#123; listen 8888; server_name 0.0.0.0; charset utf-8; client_max_body_size 75M; location /static&#123; alias /home/apollo3d/Documents/Cl/webenv/.../static; &#125;location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8889; uwsgi_param UWSGI_SCRIPT app:app; # 启动flask的文件:Flask的实例 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; Python代码 1234if request.headers.getlist(&quot;X-Forwarded-For&quot;): ip = request.headers.getlist(&quot;X-Forwarded-For&quot;)[0]else: ip = request.remote_addr 查自:V2EX 拓展: X-Forwarded-For 可能会有多个 IP ，如果浏览器使用了代理的话 正确的做法应该是抓 X-Real-IP，或者分隔 X-Forwarded-For取第 1 个值","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"nginx","slug":"nginx","permalink":"https://nymrli.top/tags/nginx/"}]},{"title":"frp结合nginx实现内网web服务和tcp的转发","slug":"frp结合nginx实现内网web服务和tcp的转发","date":"2019-03-02T10:48:23.000Z","updated":"2020-05-26T08:42:10.690Z","comments":true,"path":"2019/03/02/frp结合nginx实现内网web服务和tcp的转发/","link":"","permalink":"https://nymrli.top/2019/03/02/frp结合nginx实现内网web服务和tcp的转发/","excerpt":"","text":"服务端 - 阿里云服务器: Ubuntu 16.04 客户端 - 活动室电脑 : Ubuntu 16.04 配置server端 1$ sudo vim frps.ini 1234[common] #必须有的配置段，在frpc.ini和frps.ini中都必须要有bind_port = 7000 #服务端服务的监听端口vhost_http_port = 16666 #自己设定的http访问端口vhost_https_port = 17777 #自己设定的https访问端口 保存并且退出，使用如下服务命令启动frps服务 1$ nohup ./frps -c ./frps.ini &amp; client端: 1$ sudo vim frpc.ini 1234567891011121314[common] #必须有的配置段，在frpc.ini和frps.ini中都必须要有server_addr = x.x.x.x #服务端的公网IP（外网IP）server_port = 7000 #服务端服务的监听端口[web] #自己定义的服务转发标签（自定义，非严格）type = http #定义转发类型为http（严格）local_port = 8800 #定义所需要转发的本地web服务的端口为8800,跟nginx设置的一致custom_domains = node1.xxx.com #定义访问转发服务的域名（确保使用该域名访问可以解析到有公网IP的服务端）[ssh] #自己定义的服务转发标签（自定义，严格）type = tcp #定义转发类型为tcp（严格）local_ip = 127.0.0.1 #由于转发代理的ssh服务在本地，因此填写本地地址local_port = 22 #ssh服务本地的监听端口remote_port = 6000 #实际开启ssh时连接时访问的端口 1$ nohup ./frpc -c ./frps.ini &amp; 解释说明 123456789#server[common] #必须有的配置段，在frpc.ini和frps.ini中都必须要有bind_port = 7000 #服务端服务的监听端口vhost_http_port = 16666 #自己设定的http访问端口# client[web] #自己定义的服务转发标签（自定义，非严格）type = http #定义转发类型为http（严格）local_port = 8800 #定义所需要转发的本地web服务的端口为8800,跟nginx设置的一致 △.将16666端口的http请求转发到内网设备的8800端口应用上，真正做处理的其实是内网中的8800端口的web应用 1234[common]中的server_addr填frp服务端的ip（也就是外网主机的IP），server_port填frp服务端的bind_prot(s和c必须一致)。[web]中，type转发类型为http，local_port填转发的web端口，custom_domains 填 能够使用的域名.说到这里，域名解析，服务端建议使用阿里云，直接填写A记录，三级子域名专门申请几个，备用.类似：node1.xxx.com、node2.xxx.com、node3.xxx.com 阿里云设置A记录: 一开始以为一个IP不能写多个A记录，后来发现是可以的。如下 这里还要注意几点： 1234[web]上下文中，凡是type类型为http或者同一个类型，custom_domains中填写的域名必须为不同的域名，相同域名会报错不同类型的type，例如[test]中的type类型为tcp，则可以使用相同域名简单来说type类型相同，不能使用同一个域名type类型不同，可以使用相同的域名。 测试和访问 web服务访问格式为：域名+端口,具体如下: 123http://node1.xxx.com:16666 页面转到内网客户端使用nginx反向代理的web服务8800http://node2.xxx.com:16666 页面转到内网客户端使用nginx反向代理的web服务8801http://node3.xxx.com:16666 页面转到内网客户端本地的web服务端口8088 ▲当然要记得去阿里云的防火墙将16666端口打开才行， 然后我测试了一下，通过IP访问好像是不行的，域名:port是可以的 ssh服务远程和连接 12ssh -Port=6000 username@x.x.x.x注：x.x.x.x为服务端的公网IP 摘自：https://www.jianshu.com/p/0c49556e8e15 附录 一个Server,多个Client配置 服务器端的配置都是一样的，只需要在新添加的客户端上修改frpc.ini 1234567891011121314[common] #必须有的配置段，在frpc.ini和frps.ini中都必须要有server_addr = x.x.x.x #服务端的公网IP（外网IP）server_port = 7000 #服务端服务的监听端口[web_3] #▲自己定义的服务转发标签（自定义，非严格）type = http #定义转发类型为http（严格）local_port = 8800 #定义所需要转发的本地web服务的端口为8800,跟nginx设置的一致custom_domains = node2.xxx.com #▲定义访问转发服务的域名（确保使用该域名访问可以解析到有公网IP的服务端）[ssh_3] #▲自己定义的服务转发标签（自定义，严格）type = tcp #定义转发类型为tcp（严格）local_ip = 127.0.0.1 #由于转发代理的ssh服务在本地，因此填写本地地址local_port = 22 #ssh服务本地的监听端口remote_port = 8000 #▲实际开启ssh时连接时访问的端口 ▲1.注意上述有▲的地方，就是修改的地方，这个配置信息的头每个客户端必须不一样。即[web_3]与[web]不一样。 ▲2.SSH的话：每个客户端要配置进入ssh的端口 , 比如x.x.x.x:6000进入1号,x.x.x.x:8000进入二号 ▲3.WEB服务的话：每个客户端要配置进入web的域名 , 比如a.nymrli.top:8888进入1号,b.nymrli.top:8888进入二号","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"构造一个能发数据的POST请求头","slug":"构造一个能发数据的POST请求头","date":"2019-03-01T14:23:52.000Z","updated":"2019-09-15T08:07:31.081Z","comments":true,"path":"2019/03/01/构造一个能发数据的POST请求头/","link":"","permalink":"https://nymrli.top/2019/03/01/构造一个能发数据的POST请求头/","excerpt":"","text":"之前学请求、响应的时候只是过了一边，大致知道有这些东西。但这次真正要用的时候却又忘了到底该如何写，错误的请求头、请求体的格式导致esp8266一直发送不了数据到服务器上，又重新看了遍请求request的知识，才终于搞明白 请求 最初的写法: 由于在esp8266上已经选择、连接好了了httpbin.org的穿透，就以为Host可以不用加了，于是产生了 最初的写法： 1POST /post?= HTTP/1.1 ▲根据玩单片机的小伙伴说必须多出一行\\r\\n，所以这边是有一行空行的 结果： 400 BAD_REQUEST 搜索过后得知 : 如果使用http 1.1协议的话主机名HOST字段是必须的 第二次写法: 12POST /post?= HTTP/1.1 Host:httpbin.org 可以注意到的是Host是顶层域名，/post只是其中的一个路由 结果: 成功，这样就算可以正常发送post请求了 于是下一步就是研究如何上传数据 第三次写法： 123POST /post?= HTTP/1.1Host: httpbin.orgtempt=57 于是这次都没有返回值了. 想起了表单是有形式的，于是添加了 Content-Type: application/x-www-form-urlencoded 这个形式的参数应该写成a=1&amp;b=..&amp;.. 注.如果请求网页的表单中没设置 enctype 属性，那么最终就会默认以 application/x-www-form-urlencoded 方式提交数据。 如果是Content-Type: application/json 则改写成{'a':1 , 'b'=.. , ...} multipart/form-data，我们使用表单上传文件时，必须让 form 的 enctyped等于这个值，请求示例 12345678910111213POST http://www.example.com HTTP/1.1 Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=&quot;text&quot; title ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot; Content-Type: image/png PNG ... content of chrome.png ... ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 说明: 首先生成了一个boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以mutipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。关于 mutipart/form-data的详细定义，请前往 rfc1867 查看。 text/xml，XML-RPC 是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的： 123456789101112POST http://www.example.com HTTP/1.1 Content-Type: text/xml &lt;!--?xml version=&quot;1.0&quot;?--&gt; &lt;methodcall&gt; &lt;methodname&gt;examples.getStateName&lt;/methodname&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/params&gt; &lt;/methodcall&gt; 但是虽然能接受到返回的结果，但是响应数据中发现form一直是空的，那就是参数没传过去，于是想到是不是格式的错误 第四次写法 后来上网找寻了一下结果发现我遗漏了模板中的\\r\\n\\r\\n这行，即请求头 和 请求体 之间至少有一行换行！！！ 12345POST /get HTTP/1.1Content-Type: application/x-www-form-urlencodedConnection:closea=23&amp;b=34 中间的空行不能省略 ， 这样httpbin.org那边才不返回 ERROR或是BAD_REQUEST 但是数据还是发送不出 于是咨询了qk大佬以后，才发现原来请求头也必须要加上Content-Length:8… 最终完成版 123456POST /get HTTP/1.1Content-Type: application/x-www-form-urlencodedConnection:closeContent-Length:8a=23&amp;b=34 哎…本来很简单的事，竟然弄了一个多小时才搞定，真只能怪自己学艺不精了。幸好的是，还是调出来了。 附录: HTTP请求报文解剖 : 组成 HTTP请求报文由3部分组成（请求行+请求头+请求体）： 内容 格式 HttpWatch HttpWatch是强大的网页数据分析工具，安装后将集成到Internet Explorer工具栏中。它不用代理服务器或一些复杂的网络监控工具，就能抓取请求及响应的完整信息，包括Cookies、消息头、查询参数、响应报文等，是Web应用开发人员的必备工具。 摘自HTTP请求行、请求头、请求体详解","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"为了不跑操而Excel——Orz","slug":"为了不跑操而Excel——Orz","date":"2019-03-01T07:45:07.000Z","updated":"2019-09-15T08:07:31.021Z","comments":true,"path":"2019/03/01/为了不跑操而Excel——Orz/","link":"","permalink":"https://nymrli.top/2019/03/01/为了不跑操而Excel——Orz/","excerpt":"","text":"为了不跑操而Excel——Orz 3月1日 Excel 15、16、17、18级分类——筛选、开头是（?15通配符）、制不同表 获得50m、800-1000m、身高、肺活量……各年级数据和总的平均值 有的单元框内容虽然看上去像数字(数值靠右)，但其实是文本(文本靠左)，需要做处理后才能进行公示计算——分列 复杂的重复公示最好还是指明地址 翻到下一个非空单元格——Ctrl + ↓ 或 ↑ 3月4日 文字排版不支持竖版，所以弄成图片后发布的 4月28日 图片排版,体育部的网站支持源代码修改,因此可以修改html代码. 123456789101112131415161718192021&lt;table cellspacing=\"100\" cellpadding=\"20\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; &lt;img data-layer=\"photo\" src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/20a324aa-c891-4be2-9174-590277bff71d.jpg\" original-src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/20a324aa-c891-4be2-9174-590277bff71d_d.jpg\" sudyfile-attr=\"&#123;'title':'webwxgetmsgimg (1).jpg'&#125;\" width=\"600\" height=\"400\" border=\"0\" hspace=\"0\" vspace=\"0\" style=\"width:600px;height:400px;\" /&gt; &lt;/td&gt; &lt;td&gt; &lt;img data-layer=\"photo\" src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/c9fdcc12-a3e5-422e-b4cb-ac6c5ecd9e64.jpg\" original-src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/c9fdcc12-a3e5-422e-b4cb-ac6c5ecd9e64_d.jpg\" sudyfile-attr=\"&#123;'title':'webwxgetmsgimg (2).jpg'&#125;\" style=\"font-size:14px;width:600px;height:400px;\" width=\"600\" height=\"400\" border=\"0\" hspace=\"0\" vspace=\"0\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img data-layer=\"photo\" src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/67108b99-b0f6-42bf-aac4-a6e012e7e66d.jpg\" original-src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/67108b99-b0f6-42bf-aac4-a6e012e7e66d_d.jpg\" style=\"width:600px;height:400px;\" sudyfile-attr=\"&#123;'title':'webwxgetmsgimg (3).jpg'&#125;\" width=\"600\" height=\"400\" border=\"0\" hspace=\"0\" vspace=\"0\" /&gt; &lt;/td&gt; &lt;td&gt; &lt;img data-layer=\"photo\" src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/69659dd8-a9a2-424f-bdb7-324c1807af18.jpg\" original-src=\"/_upload/article/images/c4/cb/d351f4fa408e8414b718debf8b99/69659dd8-a9a2-424f-bdb7-324c1807af18_d.jpg\" sudyfile-attr=\"&#123;'title':'webwxgetmsgimg (4).jpg'&#125;\" width=\"600\" height=\"400\" border=\"0\" hspace=\"0\" vspace=\"0\" style=\"width:600px;height:400px;\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;","categories":[],"tags":[{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Flask 本地局域网连接","slug":"Flask-本地局域网连接","date":"2019-02-28T10:43:55.000Z","updated":"2019-09-15T08:07:30.934Z","comments":true,"path":"2019/02/28/Flask-本地局域网连接/","link":"","permalink":"https://nymrli.top/2019/02/28/Flask-本地局域网连接/","excerpt":"","text":"Flask 本地局域网连接 之前都是在活动室的电脑上配好web环境，但其实发现很多比赛只要截图就够了。所以这次看了下能不能用局域网访问。一查果然flask可以通过局域网进行访问 使用pycharm的朋友要这样设定 1.run-&gt;Edit Configurations 2.Additional options 3.运行run（Ctrl+shift+F10）即可 注:如果没有这样设定 pycharm启动 是不会有作用的（就像这样）地址依旧会是127.0.0.1 查看自己的IP地址 1.命令行方式 cmd-&gt;ipconfig-&gt;IPv4 2.查网络与共享中心 打开端口 如果还不行的话就可能是 端口没有打开 解决方案: 开始中搜索 windows防火墙 ， 这样就大功告成了！ 然后通过 局域网IP：PORT就可以访问到网页啦","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"eclipse使用","slug":"eclipse使用","date":"2019-02-26T05:18:25.000Z","updated":"2019-11-27T02:25:01.964Z","comments":true,"path":"2019/02/26/eclipse使用/","link":"","permalink":"https://nymrli.top/2019/02/26/eclipse使用/","excerpt":"","text":"Eclipse 选择工作路径 新建工程 一.选择File-&gt;New-&gt;Project 二.Java-&gt;Java Project 三.工程配置 这步可以选择创建或者不创建，目前都没有什么影响。（Java 9最大的特性——模块化） 四.是否打开导航视图窗口 此类项目与Java透视图相关联。 此透视图旨在支持Java开发。它提供了包资源管理器、类型层次结构和特定于java的导航操作。 您现在想打开这个透视图吗? 如果按了create的话，就会产生该文件 ▲注意 一个工作空间中只能有一个工程有main 五.新建class 编写第一个程序 123456// package java;public class hello &#123; public static void main(String []args) &#123; System.out.println(\"Hello World\"); &#125;&#125; 如果编写完成后，选择工具栏的运行。如果运行按钮无法按下、或按下无效，请检查代码。 类名是否和文件名一致（在IDE下应该不会产生这样的问题） main是否写对 String []args要写上,不能缺省 注意 . 如果发生错误 ， 会产生如下弹窗 ， 此时应该再次检查语法 navigation导航栏说明 附录 自动添加注释 一、新建class时自动添加注释 windows–&gt;preference进入选项卡。 然后选择Java–&gt;Code Style–&gt;Code Templates，如图： 按下Edit，然后添加一行@(随意) ${date}即可，${date}为固定的宏，大小写写错无效 保存配置后，选中类，使用快捷键alt＋shift+j可以快速添加注释。 新建类自动添加注释 选择Code Templates选项卡内的Code—&gt;New Java files，编辑它。 123456789$&#123;filecomment&#125;$&#123;package_declaration&#125;/*** @author 作者* @version 创建时间：$&#123;date&#125; $&#123;time&#125;* 类说明*/$&#123;typecomment&#125;$&#123;type_declaration&#125; 注释内容摘自eclipse自动添加作者、日期等注释 设置补全代码 打开eclipse依次点击Window --&gt; Perferences --&gt; Java --&gt; Editor --&gt; Content Assist-&gt;在【Auto activation triggers for Java：】选项后的文本框中会看到一个**&quot;.&quot;**，将其改成qwertyuiopasdfghjklzxcvbnm即可 ▲初始安装完eclipse后，默认情况下只有在你输入&quot;.&quot;之后才会有代码提示和自动补全。 修改补全提示时间 Window --&gt; Perferences --&gt; Java --&gt; Editor --&gt; Content Assist-&gt;在【Auto activation delay(ms)：】 快捷键介绍 Alt+ Shift + j , 快速注释 Alt + ↑ 向上切换 ctrl +D 删除该行 Alt+↔ 切回上一处编辑位置 Shift+Alt+↔ 选中单词 Ctrl + Enter 切换到行尾 Shift + Enter 直接切换下一行 Ctrl+Alt+↑，即可以在上面快速复制一行。 Ctrl+Shift+f: 格式化代码 快速添加get和set方法： 首先创建好该类的field; 选中需要生成的变量，然后shift+alt+s，选择generate getters and getters,","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"IDE","slug":"IDE","permalink":"https://nymrli.top/tags/IDE/"}]},{"title":"南京邮电大学java程序设计作业在线编程第二次作业","slug":"南京邮电大学java程序设计作业在线编程第二次作业","date":"2019-02-26T04:52:41.000Z","updated":"2019-09-15T08:07:31.035Z","comments":true,"path":"2019/02/26/南京邮电大学java程序设计作业在线编程第二次作业/","link":"","permalink":"https://nymrli.top/2019/02/26/南京邮电大学java程序设计作业在线编程第二次作业/","excerpt":"","text":"总分：100 选择题得分：60 \\1. 表达式9==8&amp;&amp;3&lt;7的运算结果是（ ） A.1 B.0 C.true D.false 正确答案是: D \\2. 表达式(3&gt;2)?8:9的运算结果是（ ） A.3 B.2 C.8 D.9 正确答案是: C \\3. 表达式9-7&lt;0||11&gt;8的运算结果（ ） A.true B.false C.1 D.0 正确答案是: A \\4. 表达式48%9+5*5-4的运算结果（ ） A.24 B.26 C.-30 D.46 正确答案是: A \\5. 表达式2&gt;=5的运算结果是（ ） A.2 B.5 C.true D.false 正确答案是: D \\6. 表达式15+4*5-12的运算结果是（ ） A.15 B.23 C.12 D.-133 正确答案是: B \\7. 以下（ ）不属于复合类型的数据类型 A.类 B.字符型 C.数组 D.接口 正确答案是: B \\8. 在Java中，不属于整数类型的是（ ） A.double B.long C.int D.byte 正确答案是: A \\9. 下列变量定义中，（ ）是错误的 A.float x;y; B.float x,y=3.14f; C.public int i=100,j=2,k; D.int i=100;int j=200; 正确答案是: A \\10. 以下选项中，（ ）能正确表示Java语言中的一个整型常量。 A.-8.0 B.1,000,000 C.-30 D.“456” 正确答案是: C \\11. 下面程序段执行后的结论是（ ）int m=2,n=2; m+=m-=m*m; n-=n*n; n=n+n; A.m=n B.m&gt;n C.m&lt;n D.m与n类型不同，不能比较 正确答案是: B \\12. 执行下列程序段： int no; int a=19,b=8; no=(a%b&gt;5)?a+b:a-b; System.out.println(no);输出结果是： A.2 B.9 C.11 D.27 正确答案是: C \\13. 下列语句执行后的输出结果是：( ) int e=Integer.parseInt(&quot;&quot;+3+3); System.out.println(e-2.5); A.30.5 B.3.5 C.332.5 D.8.5 正确答案是: A \\14. 定义a为int类型的变量并且已被赋初值，则合法的赋值语句是（ ） A.a+1==4; B.a+=a*8; C.a=6.6f; D.int a=18; 正确答案是: B \\15. 设m、n、x、y为已赋值的int变量，下列（ ）的运算结果属于非逻辑值。 A.m!=n&amp;x%y&lt;m B.m++==m+n+x+y C.++m*b–+y D.m+n&gt;=x+y 正确答案是: C \\16. 以下选项中的变量都已经正确定义并且赋初值，不合法的表达式是（ ） A.m &gt;= 6 == n &gt; 1 B.‘m’ + 6 C.‘m’ = 8 D.‘M’ % 8 正确答案是: C \\17. 以下标识符中，（ ）是不合法的 A.inter_net B.i_nong C.Helo D.*member 正确答案是: D \\18. 以下字符常量中不合法的是（ ） A.’#’ B.’&amp;’ C.“P” D.‘囧’ 正确答案是: C \\19. 下面（ ）是Java数据类型中int类型的取值范围。 A.-27~27-1 B.0~216-1 C.-215-215-1 D.-231~231-1 正确答案是: D \\20. 在Java语言中，下面（ ）类型可以表示整数基本数据类型。 A.single B.byte C.double D.char 正确答案是: B 编程题得分：40 2-1 是不是太胖了 得分：10 / 10 12345678910import java.util.Scanner;public class Main &#123; public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int height = scanner.nextInt(); double result = (height-100)*0.9*2; System.out.printf(\"%.1f\\n\" , result); &#125; &#125; 2-2 Say hello to integers 得分：10 / 10 1234567891011import java.util.Scanner;public class Main &#123; public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int one = scanner.nextInt(); int two = scanner.nextInt(); System.out.printf(\"Hello, %d and %d!\\n\" ,one,two); //System.out.println( \"Hello, \"+one+\" and \"+two+\"!\"); &#125; &#125; 2-3 求整数的平均值 得分：10 / 10 12345678910111213import java.util.Scanner;public class Main &#123; public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int one = scanner.nextInt(); int two = scanner.nextInt(); int thr = scanner.nextInt(); int four = scanner.nextInt(); int sum = one+two+thr+four; System.out.printf(\"Sum=%d;Average=%.1f\\n\" ,sum,sum/4.0); &#125; &#125; 2-4 整数四则运算 得分：10 / 10 123456789101112131415161718import java.util.Scanner;public class Main &#123; /** * @author Mr.li * @param args */ public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(); int b = scanner.nextInt(); System.out.printf(\"%d+%d=%d\\n\" , a,b,a + b); System.out.printf(\"%d-%d=%d\\n\" , a,b,a - b); System.out.printf(\"%d*%d=%d\\n\" , a,b,a * b); System.out.printf(\"%d/%d=%d\\n\" , a,b,a / b); // System.out.println(a+\"+\"+b+\"=\"+(a+b)); &#125; &#125; 2-3 华氏温度转换摄氏温度 得分：10 / 10 123456789import java.util.Scanner;public class Main &#123; public static void main(String []args) &#123; Scanner scanner = new Scanner(System.in); int Ftem = scanner.nextInt(); int Ctem = 5*(Ftem-32)/9; System.out.printf(\"Celsius=\"+Ctem+\"\" ); &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"南京邮电大学java程序设计作业在线编程第一次作业","slug":"南京邮电大学java程序设计作业在线编程第一次作业","date":"2019-02-26T04:50:14.000Z","updated":"2019-09-15T08:07:31.032Z","comments":true,"path":"2019/02/26/南京邮电大学java程序设计作业在线编程第一次作业/","link":"","permalink":"https://nymrli.top/2019/02/26/南京邮电大学java程序设计作业在线编程第一次作业/","excerpt":"","text":"总分：100 选择题得分：40 \\1. Java语言中，基本数据类型一共有（ ）种。 A.16 B.2 C.4 D.8 正确答案是: D \\2. Java虚拟机的英文缩写是（ ） A.JRE B.ECLIPSE C.JVM D.JDK 正确答案是: C \\3. Java程序中，最常见的对主方法的定义是（ ）。 A.private static int main(String args[ ]){ } B.public static void main(String args[ ]){ } C.public static int main(char args[ ]){ } D.private static void main(char args[ ]){ } 正确答案是: B \\4. Java源程序的文件名必须和程序中（ ）的名字相同。 A.公共类 B.主函数 C.主程序 D.主方法 正确答案是: A \\5. Java语言字节码文件的后缀名为（ ）。 A…byte B…bit C…class D…java 正确答案是: C \\6. Java语言源程序的文件后缀是（ ）。 A…j B…ja C…jav D…java 正确答案是: D \\7. Java语言中实现将源代码转换成字节码文件的过程，被称为（ ）。 A.翻译 B.编译 C.解释 D.汇编 正确答案是: B \\8. 下列哪一种语言不支持面向对象的编程思想？ A.C B.C++ C.Java D.Python 正确答案是: A 编程题得分：60 1-3 输出What is a computer?得分：10 / 10 12345public class Main &#123; public static void main(String[] args) &#123; System.out.println(\"What is a computer?\"); &#125;&#125; 1-2 输出I Love Programming! 得分：10 / 10 12345public class Main &#123; public static void main(String[] args) &#123; System.out.println(\"I Love Programming!\"); &#125;&#125; 1-1 输出Hello World! 得分：10 / 10 123456import java.io.*;public class Main &#123; public static void main(String[] args) throws IOException&#123; System.out.println(\"Hello World!\"); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://nymrli.top/tags/java/"},{"name":"NJUPT","slug":"NJUPT","permalink":"https://nymrli.top/tags/NJUPT/"}]},{"title":"Python任务调度模块APScheduler","slug":"Python任务调度模块APScheduler","date":"2019-02-24T11:30:06.000Z","updated":"2019-09-15T08:07:30.985Z","comments":true,"path":"2019/02/24/Python任务调度模块APScheduler/","link":"","permalink":"https://nymrli.top/2019/02/24/Python任务调度模块APScheduler/","excerpt":"","text":"Python任务调度模块APScheduler APScheduler是一个python的第三方库，用来提供python的后台程序。包含四个组件，分别是： triggers： 任务触发器组件，提供任务触发方式 triggers（触发器）中包含调度逻辑，每个作业都由自己的触发器来决定下次运行时间。除了他们自己初始配置意外，触发器完全是无状态的。 job stores： 任务商店组件，提供任务保存方式 job stores（作业存储器）存储被调度的作业，默认的作业存储器只是简单地把作业保存在内存中，其他的作业存储器则是将作业保存在数据库中。当作业被保存到一个持久化的作业存储器中的时候，该作业的数据会被序列化，并在加载时被反序列化。作业存储器不能共享调度器。 executors： 任务调度组件，提供任务调度方式 executors（执行器）处理作业的运行，他们通常通过在作业中提交指定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。 schedulers： 任务调度组件，提供任务工作方式 schedulers（调度器）配置作业存储器和执行器可以在调度器中完成，例如添加、修改和移除作业。根据不同的应用场景可以选用不同的调度器，可选的有BlockingScheduler,BackgroundScheduler,AsyncIOScheduler,GeventScheduler,TornadoScheduler,TwistedScheduler,QtScheduler 7种。 其中BlockingScheduler与BackgroundScheduler是其中最常用的两种调度器。那他们之间有什么区别呢？ BlockingScheduler: 调用start函数后会阻塞当前线程。当调度器是你应用中唯一要运行的东西时 BackgroundScheduler: 调用start后主线程不会阻塞。当你不运行任何其他框架时使用，并希望调度器在你应用的后台执行。 使用的一个简单实例 1234567891011121314from apscheduler.schedulers.blocking import BlockingScheduler # 阻塞import time# 实例化一个调度器scheduler = BlockingScheduler() def job1(): print \"%s: 执行任务\" % time.asctime()# 添加任务并设置触发方式为3s一次scheduler.add_job(job1, 'interval', seconds=3)# 开始运行调度器scheduler.start() 触发器 date 一次性指定日期 interval 在某个时间范围内间隔多长时间执行一次 cron 和Linux crontab格式兼容，最为强大 date 最基本的一种调度，作业只会执行一次。它的参数如下： run_date (datetime|str) – 作业的运行日期或时间 timezone (datetime.tzinfo|str) – 指定时区 1234# 2016-12-12运行一次job_functionsched.add_job(job_function, 'date', run_date=date(2016, 12, 12), args=['text'])# 2016-12-12 12:00:00运行一次job_functionsched.add_job(job_function, 'date', run_date=datetime(2016, 12, 12, 12, 0, 0), args=['text']) interval 间隔调度，参数如下： weeks (int) – 间隔几周 days (int) – 间隔几天 hours (int) – 间隔几小时 minutes (int) – 间隔几分钟 seconds (int) – 间隔多少秒 start_date (datetime|str) – 开始日期 end_date (datetime|str) – 结束日期 12# 每两个小时调一下job_functionsched.add_job(job_function, 'interval', hours=2) cron参数如下： year (int|str) – 年，4位数字 month (int|str) – 月 (范围1-12) day (int|str) – 日 (范围1-31) week (int|str) – 周 (范围1-53) day_of_week (int|str) – 周内第几天或者星期几 (范围0-6 或者 mon,tue,wed,thu,fri,sat,sun) hour (int|str) – 时 (范围0-23) minute (int|str) – 分 (范围0-59) second (int|str) – 秒 (范围0-59) start_date (datetime|str) – 最早开始日期(包含) end_date (datetime|str) – 最晚结束时间(包含) timezone (datetime.tzinfo|str) – 指定时区 1234# job_function将会在6,7,8,11,12月的第3个周五的1,2,3点运行sched.add_job(job_function, 'cron', month='6-8,11-12', day='3rd fri', hour='0-3')# 截止到2016-12-30 00:00:00，每周一到周五早上五点半运行job_functionsched.add_job(job_function, 'cron', day_of_week='mon-fri', hour=5, minute=30, end_date='2016-12-31') 添加任务 有两种方法，一种是使用add_job()函数，还有一种方式是通过scheduled_job()装饰器。 add_job()函数方式 123456789101112131415from apscheduler.schedulers.blocking import BlockingSchedulerimport datetime def my_job1(): print 'my_job1 is running, Now is %s' % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") def my_job2(): print 'my_job2 is running, Now is %s' % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") sched = BlockingScheduler()# 每隔5秒运行一次my_job1sched.add_job(my_job1, 'interval', seconds=5,id='my_job1')# 每隔5秒运行一次my_job2sched.add_job(my_job2,'cron',second='*/5',id='my_job2')sched.start() scheduled_job()装饰器方式 1234567891011121314from apscheduler.schedulers.blocking import BlockingSchedulerimport datetime sched = BlockingScheduler()#每隔5秒运行一次my_job1@sched.scheduled_job('interval',seconds=5,id='my_job1')def my_job1(): print 'my_job1 is running, Now is %s' % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") #每隔5秒运行一次my_job2@sched.scheduled_job('cron',second='*/5',id='my_job2')def my_job2(): print 'my_job2 is running, Now is %s' % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")sched.start() 使用SQLAlchemy作业存储器存放作业 12345678910111213141516171819202122from apscheduler.schedulers.blocking import BlockingSchedulerfrom datetime import datetime,timedeltaimport logging sched = BlockingScheduler()def my_job(): print 'my_job is running, Now is %s' % datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")#使用sqlalchemy作业存储器url='mysql+mysqldb://root:123456@localhost:3306/scrapy?charset=utf8'sched.add_jobstore('sqlalchemy',url=url)#添加作业sched.add_job(my_job,'interval',id='myjob',seconds=5) log = logging.getLogger('apscheduler.executors.default')log.setLevel(logging.INFO) # DEBUG#设定日志格式fmt = logging.Formatter('%(levelname)s:%(name)s:%(message)s')h = logging.StreamHandler()h.setFormatter(fmt)log.addHandler(h) sched.start() 部分摘自:APScheduler浅析 Flask-APScheduler 大致用法跟APScheduler一致，只不过需要 1.在配置中设置SCHEDULER_API_ENABLED = True 2.app配置 12345from flask_apscheduler import APScheduler;scheduler = APScheduler();scheduler.init_app(app)scheduler.start() 3.添加任务 exts.py 12from flask_apscheduler import APSchedulersche = APScheduler() aap.py 123456789101112from exts import db,mail,schesche.init_app(app)...def refreshinfo(): passsche.add_job(func=refreshinfo, id='whetherInfo', trigger='interval', seconds=150)sche.start()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"搭建frp服务--阿里云服务器","slug":"搭建frp服务-阿里云服务器","date":"2019-02-24T06:56:27.000Z","updated":"2019-09-15T08:07:31.065Z","comments":true,"path":"2019/02/24/搭建frp服务-阿里云服务器/","link":"","permalink":"https://nymrli.top/2019/02/24/搭建frp服务-阿里云服务器/","excerpt":"","text":"搭建frp服务–阿里云服务器 为了可以远程访问活动室的电脑，需要进行内网穿透。之前9块钱买了花生壳的服务，勉强用用还行，带宽很有限。听说了frp后,打算在阿里云上安个frp服务，充当中转服务器。 什么是frp frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。 开始搭建 外网主机 SSH连接上外网主机后，使用wget指令下载frp。 wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gz 使用tar指令解压tar.gz文件 tar -zxvf frp_0.20.0_linux_amd64.tar.gz 使用cd指令进入解压出来的文件夹 1cd frp_0.20.0_linux_amd64/ 外网主机作为服务端，可以删掉不必要的客户端文件，使用rm指令删除文件。 12rm -f frpcrm -f frpc.ini 接下来要修改服务器配置文件，即frps.ini文件。使用vi指令对目标文件进行编辑。 1vi frps.ini 打开frps.ini后可以看到默认已经有很多详细的配置和示范样例，该文章仅以达到内网穿透为目的，所以这里选择删掉或注释掉里面的所有内容，然后根据群晖的情况，按照官方的中文文档添加以下配置。（这里的操作都使用vi命令，关于vi命令的使用方式这里不作详细介绍，可以自行搜索相关使用方法。） 123[common]bind_port = 7000vhost_http_port = 8080 [common]部分是必须有的配置，其中bind_port是自己设定的frp服务端端口，vhost_http_port是自己设定的http访问端口。 保存上面的配置后，使用以下指令启动frp服务端。（如果需要在后台运行，请往下翻阅关于后台运行的部分。） 1./frps -c ./frps.ini 服务端的工作就到此结束了。 客户端 客户端前面的操作和服务端是一模一样的，这里不一一解释。 123456wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gztar -zxvf frp_0.20.0_linux_amd64.tar.gzcd frp_0.20.0_linux_amd64rm -f frpsrm -f frps.inivi frpc.ini 客户端的配置如下 12345678910111213141516171819[common]server_addr = x.x.x.xserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000[nas]type = httplocal_port = 5000custom_domains = no1.sunnyrx.com[web]type = httplocal_port = 80custom_domains = no2.sunnyrx.com 上面的配置和服务端是对应的。 [common]中的server_addr填frp服务端的ip（也就是外网主机的IP），server_port填frp服务端的bind_prot。 [ssh]中的local_port填群晖的ssh端口。 [nas]中的type对应服务端配置。local_port填群晖的DSM端口。custom_domains为要映射的域名，记得域名的A记录要解析到外网主机的IP。 [web]同上，local_port填群晖的web端口。这里创建了两个http反向代理是为了分别映射群晖两个重要的端口，5000和80，前者用于登录群晖管理，后者用于群晖的Web Station和DS Photo。 保存配置，输入以下指令运行frp客户端。（同样如果需要在后台运行，请往下翻阅关于后台运行的部分。） 1./frpc -c ./frpc.ini 此时在服务端会看到&quot;start proxy sucess&quot;字样，即连接成功。 现在可以用SSH通过外网主机IP:6000和群晖建立SSH连接。通过浏览器访问no1.sunnyrx.com:8080打开群晖nas的管理页面，访问no2.sunnyrx.com:8080打开群晖Web Station的网站，DS Photo app可以连接no2.sunnyrx.com:8080进入DS Photo管理。 让frp在后台运行 虽然现在frp运作起来了，内网穿透也实现了，但这还是不够的。此时如果断开与服务端或者客户端的SSH连接（比如关掉了Xshell）也就中止了frp的运行。 保持frp运行是关键是让服务端的frp和客户端的frp在后台运行，这里提两个方法供参考，一个是使用screen指令，另一个是使用nohup指令。由于群晖的系统默认是没有screen指令的，这里也不提供安装screen的方法，所以推荐群晖直接使用nohup。 其实服务端也直接用’nohup’就好了。 使用screen让frp在后台运行 下面的示范是运行服务端的frp，客户端就不示范了，前面提过群晖的系统没有screen指令。 首先使用screen指令创建一个会话。 1screen -dmS frp 然后进入这个会话。 1screen -r frp 最后使用运行frp的指令，在后面加上&quot; &amp;&quot;。（如果之前断开了SSH连接，记得用cd指令进入frp的目录先。） 1./frps -c ./frps.ini &amp; 这样就让frp在后台运行了。 使用nohup指令 nohup指令的使用方法相对简单，只需要在nohup后面加上frp的运行指令即可。下面示范的指令是运行frp客户端。（同样，如果之前断开了SSH连接，记得用cd指令进入frp的目录先。） 1nohup ./frpc -c ./frpc.ini &amp; 这样就成功让frp在后台运行了。 ▲ 注意nohup千万不要达成nohub，不然是没有效果的，有的时候会报错告诉你 没有nohub这个命令，有的时候终端（terminal）直接会消失而没有反应 摘自链接：https://www.jianshu.com/p/e8e26bcc6fe6 经过教程操作后，发现客户端电脑能够连接到学长家里已经搭好的frp服务器，但是就是连接不上阿里云。于是猜测是阿里云某些端口没有打开，一查果然如此，解决方案如下 为阿里云的安全服务限制，只有几个端口是默认打开的，所以要自己登陆阿里云服务器后台更改端口限制。 ECS服务器修改网络和安全组中的安全组配置 轻量级服务器修改安全-防火墙,如图 添加好以后,发现客户端仍然连不上去。担心是需要重启，于是重启后还是不行。到最后才发现原来是客户端的frpc.ini中server_addr写错了一位IP字段，QAQ… 最后还要记得在防火墙中打开6000端口，协议还是TCP，最后即可以通过IP:6000就可以访问到内网主机了 12345[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Linux","slug":"Linux","permalink":"https://nymrli.top/tags/Linux/"},{"name":"网络知识","slug":"网络知识","permalink":"https://nymrli.top/tags/网络知识/"}]},{"title":"Cmake 入门","slug":"Cmake-入门","date":"2019-02-18T08:42:36.000Z","updated":"2019-09-15T08:07:30.927Z","comments":true,"path":"2019/02/18/Cmake-入门/","link":"","permalink":"https://nymrli.top/2019/02/18/Cmake-入门/","excerpt":"","text":"Cmake 入门 入门案例：单个源文件 例如，假设现在我们的项目中只有一个源文件 main.cc ，该程序的用途是计算一个数的指数幂。 1.首先编写 CMakeLists.txt 文件，并保存在与 main.cc 源文件同个目录下 123456# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo1)# 指定生成目标add_executable(Demo main.cc) 语法: 由命令、注释和空格组成，其中命令是不区分大小写的。 符号 # 后面的内容被认为是注释 命令由命令名称、小括号和参数组成 参数之间使用空格进行间隔 2.编译项目 之后，在当前目录执行 cmake . ，得到 Makefile 后再使用 make 命令编译得到 Demo1 可执行文件。 同一目录，多个源文件 如果多文件，结构变成 1234567./Demo2 | +--- main.cc | +--- MathFunctions.cc | +--- MathFunctions.h cmakelist.txt需要改成 123456# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo2)# 指定生成目标add_executable(Demo main.cc MathFunctions.cc) 区别: 即在 add_executable 命令中增加了一个 MathFunctions.cc 源文件 省事的方法是使用 aux_source_directory 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。语法为aux_source_directory(&lt;dir&gt; &lt;variable&gt;) 123456789# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo2)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(Demo $&#123;DIR_SRCS&#125;) 多个目录，多个源文件 文件结构: 123456789./Demo3 | +--- main.cc | +--- math/ | +--- MathFunctions.cc | +--- MathFunctions.h 对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。 根目录中的 CMakeLists.txt ： 123456789101112131415# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo3)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# ▲添加 math 子目录add_subdirectory(math)# 指定生成目标 add_executable(Demo main.cc)# 添加链接库target_link_libraries(Demo MathFunctions) 使用命令 add_subdirectory 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理. 使用命令 target_link_libraries 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 子目录中的 CMakeLists.txt： 12345# 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 生成链接库add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;) 在该文件中使用命令 add_library 将 src 目录中的源文件编译为静态链接库 摘自CMake 入门实战 set指令详解 语法： SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) 指令功能: 用来显式的定义变量 例子: SET (SRC_LST main.c other.c) 说明: 用变量代替值，例子中定义SRC_LST代替后面的字符串。 例子: 一. CMAKE_SOURCE_DIR --&gt;CMakeLists.txt所在的目录 set(libs &quot;${CMAKE_SOURCE_DIR}/src/main/jnilibs&quot;)定义了一个变量libs，并且变量的值为${CMAKE_SOURCE_DIR}/src/main/jnilibs，其中CMAKE_SOURCE_DIR 是一个cmake内置变量，指定了CMakeLists.txt所在的目录 二.CMAKE_LIBRARY_OUTPUT_DIRECTORY–&gt;cmake编译输出的东西应该放在什么地方 set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/src/main/jnilibs/${ANDROID_ABI})这个命令用于给CMAKE_LIBRARY_OUTPUT_DIRECTORY宏赋值，该宏指定了cmake编译输出的东西应该放在什么地方。 这个例子中的地方是${PROJECT_SOURCE_DIR}/src/main/jnilibs/${ANDROID_ABI}其中PROJECT_SOURCE_DIR 是cmake内置宏，指向构建工程的全路径。 include包含库、头文件 添加头文件路径，对应的函数叫include_directories 添加库路径，对应的函数叫LINK_DIRECTORIES 添加库，对应的函数叫LINK_LIBRARIES，把所有的库加进去即可 环境变量 使用$ENV{NAME}指令就可以调用系统的环境变量了。比如MESSAGE(STATUS “HOME dir: $ENV{HOME}”) 设置环境变量的方式是:SET(ENV{变量名} 值) dl、rt 1234567target_link_libraries(agentspark$&#123;RCSSNET3D_LIBRARY&#125;$&#123;Boost_SYSTEM_LIBRARY&#125;dl$&#123;CMAKE_THREAD_LIBS_INIT&#125;rt ) dl是libdl.so,rt是librt.so的缩写···其实是静态加载了这两个动态链接库！！！","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"Python+adb操作手机","slug":"Python-adb操作手机","date":"2019-02-06T05:00:09.000Z","updated":"2019-09-15T08:07:30.977Z","comments":true,"path":"2019/02/06/Python-adb操作手机/","link":"","permalink":"https://nymrli.top/2019/02/06/Python-adb操作手机/","excerpt":"","text":"Adb wifi连接调试 adb connect {ip} 如果你不想用usb连接调试，可以选择使用adb 连接调试，命令是 adb connect {ip} ，需要在同一个局域网内。这个功能也比较实用，但首次连接时，需要另外一些配置，建议可以网上搜索下adb wifi连接手机等关键字看看。 屏幕截屏 screencap -p {图片存储地址} 这个其实直接通过手机截屏再发送到电脑就可以了，但我开发的是TV应用，在盒子上没法截屏，所以这个命令对我来说还是较实用的。 获取或推送文件 adb pull/push 这个也挺实用的，获取手机指定位置的文件到电脑上，或者从电脑发送文件到手机上 模拟按键事件 //这条命令相当于按了设备的Back key键 adb shell input keyevent 4 //可以解锁屏幕 adb shell input keyevent 82 //在屏幕上做划屏操作，前四个数为坐标点，后面是滑动的时间（单位毫秒） adb shell input swipe 50 250 250 250 500 手机分辨率一般为1080*1920，其中左上角为（0,0），右下角为（1080*1920）,还可以增加一个参数为持续时间 //在屏幕上点击坐标点x=50 y=250的位置。 adb shell input tap 50 250 //输入字符abc adb shell input text abc 跳一跳游戏adb教程 事件介绍 代码演示都是在进入 adb shell模式下 input swipe模拟的是滑动事件 , 如左滑:input swipe 600 800 300 800 可以输入文本的文本框之类的控件上输入出 OuyangPeng 字符串: input text OuyangPeng input tap命令模拟触摸屏幕input tap 600 800 input keyevent用法: 12345678910input keyevent 3 // Homeinput keyevent 4 // Backinput keyevent 19 //Upinput keyevent 20 //Downinput keyevent 21 //Leftinput keyevent 22 //Rightinput keyevent 23 //Select/Okinput keyevent 24 //Volume+input keyevent 25 // Volume-input keyevent 82 // Menu 菜单 功能 adb 启动应用: adb shell am start -n packgage名 /.activity如 adb shell am start -n com.android.calculator2/.Calculator 提醒点：一定要找到、找对activity和package 长时间按某个元素：adb input shell … adb -s 4d0041be98b01f shell input touchscreen swipe 540 716 545 718 1000 语义：-s 后跟设备号，swipe 先传移动坐标范围‘540 716 545 718’，然后1000是长按时间，单位毫秒。 Python语句调用: os.system(只有执行命令是否成功的结果) 123456import osCMD = r'.\\adb.exe version'res = os.system(CMD)print(res) # 0&gt;&gt; Android Debug Bridge version 1.0.32&gt;&gt; 0 os.popen(可读取执行语句的结果) 12345import osCMD = r'.\\adb.exe version'version = os.popen().read()print(version)&gt;&gt; Android Debug Bridge version 1.0.32 subprocess.call 123456import subprocessCMD = r'.\\adb.exe version'version = subprocess.call(CMD)print(version) # 0&gt;&gt; Android Debug Bridge version 1.0.32&gt;&gt; 0 subprocess.Popen(也是一个执行系统命令的工具,但这边效果不太好) 12345import subprocessCMD = r'.\\adb.exe version'version = subprocess.Popen(CMD)print(version) # 这边是个Popen对象,&gt;&gt; &lt;subprocess.Popen object at 0x00000219392981D0&gt; 附录 event值记录 https://blog.csdn.net/jlminghui/article/details/39268419","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"模拟操作","slug":"模拟操作","permalink":"https://nymrli.top/tags/模拟操作/"}]},{"title":"ACM_动态规划","slug":"ACM-动态规划","date":"2019-02-03T07:49:10.000Z","updated":"2019-09-15T08:07:30.911Z","comments":true,"path":"2019/02/03/ACM-动态规划/","link":"","permalink":"https://nymrli.top/2019/02/03/ACM-动态规划/","excerpt":"","text":"图解动态规划 : http://www.sohu.com/a/153858619_466939 动态规划 : 最优子结构 边界 状态转移方程式 题目二： 国王和金矿 有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？ 解法一: 排列组合 时间复杂度 : O(2^N) 解法二 : DP 1.找到最优子结构 10人4金矿(有一个金矿没挖) 10-3人4金矿(挖了一个金矿) 2.最优选择 5个金矿的最优选择，就是*（前4座金矿10工人的挖金数量）和（前4座金矿7工人的挖金数量+第5座金矿的挖金数量）*的最大值！ 3.边界 经过整理可得 状态转移方程式: 边界: F(n,w) = 0 (n&lt;=1, w&lt;p[0]); F(n,w) = g[0] (n==1, w&gt;=p[0]); 推导式 F(n,w) = F(n-1,w) (n&gt;1, w&lt;p[n-1]) F(n,w) = max(F(n-1,w), F(n-1,w-p[n-1])+g[n-1]) (n&gt;1, w&gt;=p[n-1]) 实现方法: 简单递归 记忆搜索法 动态规划(递推式) 01背包问题 简单递归 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* 01背包问题 */pair&lt;int,int&gt; wv[maxn];int N; // 物品数量int W; // 背包重量int rec(int i,int j)&#123; int res = 0; if( i == N) res= 0; else if( j &lt; wv[i].first ) res = rec(i+1,j); else res = max(rec(i+1,j) , rec(i+1,j-wv[i].first) + wv[i].second); return res;&#125;void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; cout &lt;&lt; rec(0,W) &lt;&lt; endl;&#125;int main()&#123; solve(); return 0;&#125; 记忆搜索 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* 01背包问题 */pair&lt;int,int&gt; wv[maxn];int N; // 物品数量int W; // 背包重量int dp[maxn][maxn]; //2.多了个记忆数组(称为DP数组)int rec(int i,int j)&#123; if ( dp[i][j] &gt; 0 ) return dp[i][j]; // 如果已经计算过,就直接使用之前的结果 int res = 0; if( i == N) res= 0; else if( j &lt; wv[i].first ) res = rec(i+1,j); else res = max(rec(i+1,j) , rec(i+1,j-wv[i].first) + wv[i].second); dp[i][j] =res; // 2.将结果记录 return res;&#125;void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; cout &lt;&lt; rec(0,W) &lt;&lt; endl;&#125;int main()&#123; solve(); return 0;&#125; 动态规划解法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* 01背包问题 */pair&lt;int,int&gt; wv[maxn];int N; // 物品数量int W; // 背包重量int dp[maxn][maxn]; //2.多了个记忆数组(称为DP数组)// 逆序推导void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; for( int i= N-1 ; i &gt;= 0 ; i--)&#123; for( int j=0;j&lt;= W ; j++)&#123; if( j &lt; wv[i].first ) dp[i][j] = dp[i+1][j]; else dp[i][j] = max( dp[i+1][j] , dp[i+1][j - wv[i].first] + wv[i].second); &#125; &#125; cout &lt;&lt; dp[0][W] &lt;&lt;endl;&#125;// 顺序推导void solve()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i=0 ; i &lt;N ; i++) cin &gt;&gt; wv[i].first &gt;&gt; wv[i].second; cin &gt;&gt; W; for( int i= 0 ; i &lt; N ; i++)&#123; for( int j=0;j&lt;= W ; j++)&#123; if( j &lt; wv[i].first ) dp[i+1][j] = dp[i][j]; else dp[i+1][j] = max( dp[i][j] , dp[i][j - wv[i].first] + wv[i].second); // 推导式也变了,下一行的依据上一行写成dp[i+1][j] = ... &#125; &#125; cout &lt;&lt; dp[N][W] &lt;&lt;endl; // 输出的结果变了&#125;int main()&#123; solve(); return 0;&#125; ▲注意，边界一定要注意处理。 这题由于边界全为0，而全局数组初始化默认是0，所以不需要处理，否则得像 国王和金矿提供的题解一样书写。 最长公共子序列问题 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4;/* LCS */int dp[maxn+1][maxn+1];void solve()&#123; int m,n; cin &gt;&gt; n &gt;&gt; m; string sn,sm; cin &gt;&gt; sn &gt;&gt; sm; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if( sn[i] == sm[j] ) dp[i+1][j+1] = dp[i][j] + 1; // p[i+1][j+1] = max(dp[i][j] + 1 , max(dp[i+1][j] , dp[i][j+1]));化简而来 else dp[i+1][j+1] = max(dp[i][j+1] , dp[i+1][j] ); &#125; &#125; cout &lt;&lt; dp[n][m] &lt;&lt; endl;&#125;int main()&#123; solve(); return 0;&#125; 完全背包问题 多重部分和","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"DP","slug":"DP","permalink":"https://nymrli.top/tags/DP/"}]},{"title":"ACM_贪心专题","slug":"ACM-贪心专题","date":"2019-02-01T12:17:50.000Z","updated":"2019-09-15T08:07:30.917Z","comments":true,"path":"2019/02/01/ACM-贪心专题/","link":"","permalink":"https://nymrli.top/2019/02/01/ACM-贪心专题/","excerpt":"","text":"贪心专题 1.活动安排 有若干个活动，第i个开始时间和结束时间是[Si,fi)，只有一个教室，活动之间不能交叠，求最多安排多少个活动？ Input 123第一行一个正整数n (n &lt;= 10000)代表活动的个数。第二行到第(n + 1)行包含n个开始时间和结束时间。开始时间严格小于结束时间，并且时间都是非负整数，小于1000000000 Output 1一行包含一个整数表示活动个数。 Input示例 123431 23 42 9 Output示例 12 博主提供: 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e4+5;struct node&#123; int s,e; //start , end &#125; a[maxn];//由于使用结构体,所以需要自定义cmp函数bool cmp(node x,node y)&#123; if(x.e&lt;y.e) return true; else if(x.e==y.e&amp;&amp;x.s&gt;y.s) return true; return false;&#125;int main()&#123; int n,i,j,ans,end; cin&gt;&gt;n; for(i = 0;i&lt;n;i++) cin&gt;&gt;a[i].s&gt;&gt;a[i].e; sort(a,a+n,cmp); ans = 0; end = -1e9-100; for(i =0;i&lt;n;i++)&#123; if(a[i].s&gt;=end)&#123; // 结束最早的 ans++; end=a[i].e; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 不使用结构体,使用map: 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1e4 +5;int main()&#123; int N; while(scanf(\"%d\",&amp;N) == 1)&#123; pair&lt;int,int&gt; itv[maxn]; for(int i = 0 ; i&lt;N; i++) scanf(\"%d%d\",&amp;itv[i].second , &amp;itv[i].first); sort( itv , itv + N); int ans = 0 ; int t = 0; for( int i =0 ; i&lt; N ; i++)&#123; if ( t &lt; itv[i].second )&#123; ans ++; t = itv[i].first; &#125; &#125; printf(\"%d\",ans); &#125; return 0;&#125; HUD OJ 2037今年暑假不AC 感觉像是板子题，都是时间规划类，需要最多目标的题目。但是在第15行时，必须写&lt;=,否则WA. &lt;= 的结果是 5 ; &lt; 的结果是 3 经过与上题的对比发现，主要的区别在于这句话 ：上题规定 开始时间严格小于结束时间，并且时间都是非负整数，小于1000000000 ，而这题 开始时间是可以等于结束时间的 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1e4+ 5;pair&lt;int,int&gt; node[maxn];int main()&#123; int N; while( cin &gt;&gt; N)&#123; if ( !N ) break; for(int i=0;i&lt;N;i++) cin &gt;&gt; node[i].second &gt;&gt; node[i].first ; sort(node,node+N); int ans =0 , endt =0 ; for( int i=0 ;i&lt;N;i ++)&#123; if( endt &lt;= node[i].second )&#123; ans ++ ; endt = node[i].first; &#125; &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125; 字典序比较 123456789101112131415161718192021222324252627282930313233include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;char s[maxn];void solve(int n)&#123; int a = 0 , b = n-1; while( a &lt;= b)&#123; bool left = false; for(int i = 0 ; a+i &lt;=b ; i++)&#123; if( s[a+i] &lt; s[b-i] )&#123; left = true; break; &#125;else if (s[a+i] &gt; s[b-i])&#123; left = false; break; &#125;else continue; &#125; if( left ) putchar(s[a++]); else putchar(s[b--]); &#125; putchar('\\n');&#125;int main()&#123; int N; scanf(\"%d\",&amp;N); scanf(\"%s\",s); solve(N); return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"贪心","slug":"贪心","permalink":"https://nymrli.top/tags/贪心/"}]},{"title":"学习nginx配置","slug":"学习nginx配置","date":"2019-01-24T08:45:40.000Z","updated":"2019-09-15T08:07:31.045Z","comments":true,"path":"2019/01/24/学习nginx配置/","link":"","permalink":"https://nymrli.top/2019/01/24/学习nginx配置/","excerpt":"","text":"nginx配置 多台虚拟主机: 1.分配IP地址 2.新建、编写usr/local/nginx的conf配置文件 12345678910111213http&#123; sever&#123; listen 192.168.1.17:80; //监听 (IP地址:) 端口 server_name 192.168.1.17; // 域名或者ip access_log logs/server1.access.log conbined;//指定位置+使用日志文件默认格式 location / &#123; index index.html index.htm; //index表示意义(关键字),左边优先级高.指定的首页 root html/ss2; //虚拟主机目录(网站目录)==&gt;ss2下的所以html文件都可以通过192.168.1.17/xxx访问 &#125; &#125;&#125; 3.编写目录下的首页index.html文件 4.运行nginx usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/xnzj.conf ▲在根目录下可以直接通过路径访问,如根目录下只有index文件,而配置中设置的是index index.html此时没有找到index.html后就会显示403错误,但是可以通过192.168.1.17==&gt;192.168.1.17/index添加路径的方法来加载index界面 其他配置 缓存 12345678910server&#123; listen xxx; server_name yyy; location ~.*\\.(jpg|png|)$&#123; expires 30d; &#125; location ~.*\\.(css|js|)$&#123; expires 1h; &#125;&#125; 自动列目录 12345678910[/ect/nginx/nginx.conf]server&#123; .. location / &#123; root html; index index.html index.hml; autoindex on; #▲ &#125; &#125; uwsgi模块使用 安装 source activate# 开启虚拟开发环境模式 pip install uwsgi # 安装uwsgi 配置 uwsgi配置文件支持很多格式，我采用.ini格式，命名为uconfig.ini具体内容如下： 启动uwsgi , 命令输入uwsgi uconfig.ini 外部访问测试 此时在外部访问 公网IP：5000就可以访问了 12345678910111213141516[uwsgi]# 外部访问地址，可以指定多种协议，现在用http便于调试，之后用sockethttp = 0.0.0.0:5000# 指向项目目录chdir = /home/pythonproject/my_flask/py3env/myblog/# flask启动程序文件wsgi-file = manage.py# flask在manage.py文件中的app名callable = app #很多人习惯将Flask应用对象取名为”app”，但是WSGI标准是”application”。uWSGI提供了一个功能，可以指定应用对象，方法就是在配置文件中加上”callable”项：# 处理器数processes = 4# 线程数threads = 2#状态检测地址stats = 127.0.0.1:9191 1234location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:3031;&#125; 这段配置表明Nginx会将收到的所有请求都转发到”127.0.0.1:3031″端口上，即uWSGI服务器上。现在让我们重启Nginx，","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"C++日期操作","slug":"C++日期操作","date":"2019-01-24T07:00:56.000Z","updated":"2019-09-15T08:07:30.922Z","comments":true,"path":"2019/01/24/C++日期操作/","link":"","permalink":"https://nymrli.top/2019/01/24/C++日期操作/","excerpt":"","text":"C++日期操作 12345678910111213int main( )&#123; time_t now = time(0); // 基于当前系统的当前日期/时间 的时间戳 cout &lt;&lt; \"1970 到目前经过秒数:\" &lt;&lt; now &lt;&lt; endl; tm *ltm = localtime(&amp;now);// 将时间戳转换为结构体,再输出 tm 结构的各个组成部分 cout &lt;&lt; \"年: \"&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl; cout &lt;&lt; \"月: \"&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl; cout &lt;&lt; \"日: \"&lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl; cout &lt;&lt; \"时间: \"&lt;&lt; ltm-&gt;tm_hour &lt;&lt; \":\"; cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; \":\"; cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl; getchar();&#125; time_t结构体 12345678910111213141516171819202122232425262728#include &lt;time.h&gt; #include &lt;stdio.h&gt; int main( void ) &#123; time_t t = time(0); char tmp[64]; strftime( tmp, sizeof(tmp), \"%Y/%m/%d %X %A 本年第%j天 %z\",localtime(&amp;t) ); puts( tmp ); return 0; &#125; // ---第二种#include &lt;string&gt;#include &lt;time.h&gt;using namespace std;string getTime()&#123; time_t timep; time (&amp;timep); char tmp[64]; strftime(tmp, sizeof(tmp), \"%Y-%m-%d %H:%M:%S\",localtime(&amp;timep) ); return tmp;&#125;int main()&#123; string time = getTime(); cout &lt;&lt; time &lt;&lt; endl; return 0;&#125; size_t strftime(char *strDest, size_t maxsize, const char *format, const struct tm *timeptr); 根据格式字符串生成字符串。 struct tm *localtime(const time_t *timer); 取得当地时间，localtime获取的结果由结构tm返回 返回的字符串可以依下列的格式而定： %a 星期几的缩写。Eg:Tue %A 星期几的全名。 Eg: Tuesday %b 月份名称的缩写。 %B 月份名称的全名。 %c 本地端日期时间较佳表示字符串。 %d 用数字表示本月的第几天 (范围为 00 至 31)。日期 %H 用 24 小时制数字表示小时数 (范围为 00 至 23)。 %I 用 12 小时制数字表示小时数 (范围为 01 至 12)。 %j 以数字表示当年度的第几天 (范围为 001 至 366)。 %m 月份的数字 (范围由 1 至 12)。 %M 分钟。 %p 以 ‘‘AM’’ 或 ‘‘PM’’ 表示本地端时间。 %S 秒数。 %U 数字表示为本年度的第几周，第一个星期由第一个周日开始。 %W 数字表示为本年度的第几周，第一个星期由第一个周一开始。 %w 用数字表示本周的第几天 ( 0 为周日)。 %x 不含时间的日期表示法。 %X 不含日期的时间表示法。 Eg: 15:26:30 %y 二位数字表示年份 (范围由 00 至 99)。 %Y 完整的年份数字表示，即四位数。 Eg:2008 %Z(%z) 时区或名称缩写。Eg:中国标准时间 %% % 字符。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"程序开发经验","slug":"程序开发经验","permalink":"https://nymrli.top/tags/程序开发经验/"}]},{"title":"Shell代码编写记录","slug":"Shell代码编写记录","date":"2019-01-23T05:48:59.000Z","updated":"2019-09-15T08:07:31.001Z","comments":true,"path":"2019/01/23/Shell代码编写记录/","link":"","permalink":"https://nymrli.top/2019/01/23/Shell代码编写记录/","excerpt":"","text":"随机选取端口 12345# 随机设置代理和监控端口，允许每台机器有多个代理# 注意:$RANDOM返回一个从0到32767的值，端口&lt;= 1024保留给root用户# TODO:不是随机选择端口，而是绑定到可用端口export SPARK_SERVERPORT=$[$RANDOM + 1025]export SPARK_AGENTPORT=$[$RANDOM + 1025] 后台执行,获取其PID 12345678rcssserver3d --agent-port $SPARK_AGENTPORT --server-port $SPARK_SERVERPORT &amp;# 将rcssserver3d后台运行在随机获得的端口上PID=$! # 获得进程号,最后用进程PID关闭rcssserver3d# ---类比学习---python ./test1.py &amp;PID=$!echo $PID 组合命令 12345678910sleep 5 #延迟时间DIR_SCRIPT=\"$( cd \"$( dirname \"$0\" )\" &amp;&amp; pwd )\" # 先运行 cd切换目录,再将当前工作目录赋值给 DIR_SCRIPTTYPE=$1 #TYPE为读取第二个参数DIR_PARAMS=\"$( cd \"$( dirname \"$2\" )\" &amp;&amp; pwd )\"DIR_OUTPUT=\"$( cd \"$( dirname \"$3\" )\" &amp;&amp; pwd )\"PARAMS_FILE=$DIR_PARAMS/$(basename $2)# basename返回文件名OUTPUT_FILE=$DIR_OUTPUT/$(basename $3) 输出判断 1234567891011121314while [ ! -f $OUTPUT_FILE ] &amp;&amp; [ $total_wait_time -lt $maxWaitTimeSecs ]do sleep 1 total_wait_time=`expr $total_wait_time + 1` # expr 表示后面是运算表达式done # -f 是正常文件 # Shell 中 ()用[]代替if [ ! -f $OUTPUT_FILE ]then echo \"Timed out while waiting for script to complete, current wait time is $total_wait_time seconds.\"else echo \"Completed with a wait time of $total_wait_time seconds.\"fi 关闭进程 12345echo \"Killing Simulator\"kill -s 2 $PID# kill -s 信号名 进程号echo \"Killing Agent\"kill -s 2 $AGENTPID 格式：kill &lt;pid&gt; 格式：kill -TERM &lt;pid&gt; 发送SIGTERM旌旗灯号到指定过程，若是过程没有捕获该旌旗灯号，则过程终止（If no signal is specified， the TERM signal is sent. The TERM signal will kill processes which do not catch this signal.） 格式：kill -l 列出所有旌旗灯号名称（Print a list of signal names. These are found in /usr/include/linux/signal.h）。只有第9种旌旗灯号（SIGKILL）才可以无前提终止过程，其他旌旗灯号过程都有权力忽视。下面是常用的旌旗灯号： 旌旗灯号名称 HUP 1 终端断线 INT 2 中断（同 Ctrl + C） QUIT 3 退出（同 Ctrl + ） TERM 15 终止 KILL 9 强迫终止 CONT 18 持续（与STOP相反， fg/bg号令） STOP 19 暂停（同 Ctrl + Z） Bash Shell 脚本获取进程 pid 第一种方法: ps -ef | grep &quot;Processname&quot; | grep -v grep | awk '{print $2}' 第二种 最简单的方法是使用 pgrep： pgrep -f name 根据PID关闭进程 kill -9 PID 根据进程名关闭进程 法一: 1kill -f name1 法二: 如果是可执行程序的话，可以直接使用 pidof 1pidof name 关闭Roboviz.sh里java进程的方法: grep -v ：显示不包含匹配文本的所有行(反向查找)。比如 grep -v grep 就是查找不含有 grep 字段的行 写法一:kill -9 $(ps x | grep Roboviz.jar | grep -v grep | awk '{print $1}') 写法二: ps -ef | grep Roboviz.jar | grep -v grep | awk '{print $2}' | xargs kill -9 shell脚本中的冒号作用 作用一: 占位符&lt;==&gt;pass 12345if egrep '.*vmlinuz-2.6.32-220.23.1.lvs.el6.*nohz=off' /boot/grub/grub.conf ;then :else sed -i -r 's/(.*vmlinuz-2.6.32-220.23.1.lvs.el6.*)/\\1 nohz=off/' /boot/grub/grub.conffi 作用二: 分隔符 冒号(:)常用来做路径的分隔符（PATH），数据字段的分隔符（/etc/passwd） 宏 特殊变量: 当前脚本PID 当前脚本PID 当前脚本PID $? 上句执行结果","categories":[],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://nymrli.top/tags/Shell/"}]},{"title":"Matlab基础教程","slug":"Matlab基础教程","date":"2019-01-23T05:43:34.000Z","updated":"2019-09-15T08:07:30.963Z","comments":true,"path":"2019/01/23/Matlab基础教程/","link":"","permalink":"https://nymrli.top/2019/01/23/Matlab基础教程/","excerpt":"","text":"Matlab学习 1234A = [1 3 5];max(A)ans = 5 如果存在多个输入参数，请使用逗号加以分隔： 12345B = [10 6 4];max(A,B)ans = 10 6 5%A中列元素与B中列元素一一比较. clc 函数清除命令行窗口。 函数 123disp(&apos;hello world&apos;)hello world要调用不需要任何输入且不会返回任何输出的函数，请只键入函数名称： 二维绘图 r--' 字符串为线条设定。每个设定可包含表示线条颜色、样式和标记的字符。标记是在绘制的每个数据点上显示的符号，例如，+、o 或 *。例如，'g:*' 请求绘制使用 * 标记的绿色点线。 请注意，为第一幅绘图定义的标题和标签不再被用于当前的图窗口中。默认情况下，每次调用绘图函数、重置坐标轴及其他元素以准备新绘图时，MATLAB® 都会清除图形。 要将绘图添加到现有图形中，请使用 hold。 1234567x = 0:pi/100:2*pi;y = sin(x);plot(x,y)hold ony2 = cos(x);plot(x,y2,&apos;:&apos;)legend(&apos;sin&apos;,&apos;cos&apos;) 三维绘图 123[X,Y] = meshgrid(-2:.2:2);Z = X .* exp(-X.^2 - Y.^2);surf(X,Y,Z) surf 函数及其伴随函数 mesh 以三维形式显示曲面图。surf 使用颜色显示曲面图的连接线和面。mesh 生成仅以颜色标记连接定义点的线条的线框曲面图。（surf填充-sruface） M文件 脚本文件 函数文件 1234567891011脚本文件 1.多条命令的综合体 2.没有输入、输出变量 3.使用MATLAB基本工作空间 4.没有函数声明行 函数文件1.常用于扩充MATLAB函数库2.可以包含输入、输出变量3.运算中生成的所有变量都存放在函数工作空间4.包含函数声明行 函数名为mymax，文件名为mymax.m（必须相同）。它需要五个数字作为参数并返回最大的数字。 1234567891011121314151617创建函数文件，名为mymax.m 并输入下面的代码： function max = mymax(n1, n2, n3, n4, n5) %This function calculates the maximum of the % five numbers given as input max = n1; if(n2 &gt; max) max = n2; end if(n3 &gt; max) max = n3; end if(n4 &gt; max) max = n4; end if(n5 &gt; max) max = n5; end 符号变量与符号表达式 x y; %定义x,y为符号变量>>z123456需要用syms或sym定义，例如&gt;&gt;syms x y; %定义x,y为符号变量&gt;&gt;z=x^2+y^2 ％定义z为含有x与y的符号表达式也可以这样定义z， &gt;&gt;z=sym(‘x^2+y^2’) %与上面等价 关于符号表达式的基本命令 命令 含义 pretty(s) 将s显示为数学书写形式 symsum(s,x,a,b) 对s中的x从a到b求和 findsym(s) 给出s中所有的符号变量 findsym(s,n) 给出s中离x最近的n个符号变量，n大于s中符号变量个数时则按字母表顺序返回符号变量 subs(s,a,b) 将s中的a置换成b double(s) 将s转换成数值形式 str2num(s) 字符变量转换为数值变量 num2str(s) 数值变量转换为字符变量 sym(a) 将a转换为符号变量 digits(d) 给出有效数字个数为d的近似值 vpa(s,d) 计算s在精度为d位有效数字的解 eval(s) 执行符号表达式s 命 令 含 义 collect(s) 合并s中的同类项 compose(f,g,x,y) 计算复合函数f(g(y)),x,y分别为f,g的自变量 g＝finverse(f) 计算f(x)的反函数，g的自变量仍为x expand(s) 展开表达式s factor(s) 因式分解s [N,D]=numden(s) 通分s中各式，其和的分子为N，分母为D simplify(s) 对s进行综合化简 simple(s) 给出s的所有最简式 微积分 命 令 含 义 limit(f,x,a) 计算函数f(x)当x-&gt;a时的极限 limit(f,x,a,’right’) 计算函数f(x)当x-&gt;a+时的右极限 limit(f,x,a,’left’) 计算函数f(x)当x-&gt;a-时的左极限 x=fminbnd(f,a,b) 计算函数f(x)在区间[a,b]上的最小值点 [x,fmin]=fminbnd(f,a,b) 计算函数f(x)在区间[a,b]上的最小值点及最小值fmin diff(f,’x’,n) 计算函数f(x)对变量x的n阶导数，’x’可省 int(f,x) 计算函数f(x)的不定积分，积分变量为x int(f,x,a,b) 计算函数f(x)在[a,b]上的定积分(符号) quad(f,a,b) 计算函数f(x)在[a,b]上的定积分值 taylor(f) 计算函数f(x)在x=0处的5阶泰勒展开式 taylor(f,n,x,a) 计算函数f(x)在x=a处的n-1阶泰勒展开式 ▲需要注意的是，在进行这些计算前必须申明是符号计算，即要加上syms x y;等语句 基本的绘图步骤 步 骤 典 型 代 码 1. 准备绘图数据 x = 0:0.2:12; y1 = bessel(1,x); 2. 选择一个窗口并在窗口中给图形定位 figure(1) ，subplot(2,2,1) 3. 调用基本的绘图函数 h = plot(x,y1,x,y2,x,y3); 4. 选择线型和标记特性 set(h,‘LineWidth’,2,{‘LineStyle’},{’–’;’:’;’-.’}) 5. 设置坐标轴的极限值、标记符号和网格线 axis([0 12 -0.5 1]) 6. 使用坐标轴标签、图例和文本对图形进行注释 xlabel(‘Time’)ylabel(‘Amplitude’) 7. 输出图形 print -depsc -tiff -r200 myplot # 二维曲线图 1234例：&gt;&gt; x= 0:0.01:10;&gt;&gt; y=sin(x);&gt;&gt; plot(x,y) # 函数绘图 1234fplot(‘function’,范围)，例如 fplot(&apos;sin(x)&apos;,[0,2*pi],&apos;r&apos;)后面选项与plot一致。再如 fplot(‘[sin(x),cos(x)]’,[0,2*pi])同时画出两个函数图形 #符号函数绘图 1格式ezplot(f,[a,b]) 画出符号函数f在[a,b]上的图形 # 极坐标图形 1234MATLAB提供了polar函数来在极坐标下绘制图形 ：&gt;&gt; x= 0:0.01:10;&gt;&gt; y=1+cos(x);&gt;&gt; polar(x,y,&apos;rs&apos;) 图形控制与修饰 命令 含义 axis auto 坐标轴缺省设置 axis equal 纵、横轴采用相等单位长度 axis image 纵、横轴采用相等单位长度，且坐标框紧贴数据范围 axis([x1 x2 y1 y2]) 设定坐标范围 grid on 画出网格线 grid off 不画网格线 hold on 使以后图形画在当前图形上 hold off 使以后图形不画在当前图形上 命令 含义 title(x,y,‘name’) 在(x,y)处标示图名 xlabel(‘xtext’) 横坐标轴名 ylabel(‘ytext’) 纵坐标轴名 legend(‘first’,’second’,n) 对一个坐标系中的两幅图作出图例注解 figure 另开图形窗口 subplot(m,n,k) m×n幅子图的第k幅称为当前图 多个图形的绘制方法 1234subplot函数 可以实现多个图形的绘制：&gt;&gt; x = 0:.1:20;&gt;&gt; subplot(2,2,1)&gt;&gt; plot(x,sin(x)); # 三维网线图 12345671.mesh(X,Y,Z) ，例 x=-5:0.2:5;y=x; [X Y]=meshgrid(x,y); %生成格点矩阵 Z=sin(sqrt(X.^2+Y.^2)); mesh(X,Y,Z) 2. ezmesh(‘f’,‘g’,‘h’,[u1,u2,v1,v2] )，例 ezmesh(&apos;cos(u)*cos(v)&apos;,&apos;sin(u)*cos(v)&apos;,&apos;sin(v)&apos;,[0,2*pi,-pi,pi]); axis equal 数值变量与符号变量 数值变量的常用函数，一般都可以直接用在符号变量上，比如三角函数，这些都是可以通用的，而且函数的含义也完全一样。 但偏偏有些函数非常蛋疼，对符号变量与数值变量都可以进行操作，但操作的含义完全不同，比如diff，diff对于一个数值变量的运算结果是差分，而对于一个符号变量的运算结果则是求导 。 另外也存在很多函数只能对数值变量操作，比如离散傅里叶变换fft。还有很多函数只能对符号变量操作，比如泰勒展开taylor。因此在matlab使用中，一定要区分变量的类型，其实真的用起来也好区分，因为完成特定的计算任务，要么全部用数值，要么全部用符号，这也符合一般处理问题的原则。 4.字符串的常用函数 matlab中字符串的常用算符就更少了，但都非常有用，这里介绍几个： 1）num2str和str2num：可以实现数值变量和字符串变量的转换，比如 a=1 b=num2str(1)复制代码运算结果显示a是一个数值变量，b是一个字符串变量，函数名中的2就是英文中to的意思，也就是把num数值类型转化成str字符类型。str2num就是这个函数的反函数，这两个命令结合，可以实现特定的功能，比如提取一个数字的最高位： a=123456 b=num2str(a) c=b(1) d=str2num© 2.3for循环 ​ for循环的语法是： 12345678910for 数值变量=向量 执行语句end---其含义是，数值变量会取向量中的每一个值，然后执行语句，在执行语句中，数值变量是一个1*1的矩阵。比如for a=[0 1 3]---则会让a=0，执行语句，然后a=1，执行语句，最后a=3，执行语句。这里容易和赋值语句混淆，因为a=[0 1 3]是一个数值变量赋值，赋值后a是个向量，但加上了for后，a是1*1矩阵。另外，在数值变量赋值那段，我们说过有一种常用的赋值方法是&quot;a=初始值:步长:终值&quot;，其结果是把a赋值成一个向量，因此这也广泛用于for语句中 for a=初始值:步长:终值 ---则在执行语句中，a是一个遍历初值到终值的1*1矩阵。","categories":[],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://nymrli.top/tags/Matlab/"}]},{"title":"中文Bois模式界面","slug":"中文Bois模式界面","date":"2019-01-23T05:40:19.000Z","updated":"2019-09-15T08:07:31.020Z","comments":true,"path":"2019/01/23/中文Bois模式界面/","link":"","permalink":"https://nymrli.top/2019/01/23/中文Bois模式界面/","excerpt":"","text":"暗夜精灵的Bois界面。觉得还挺友好的。","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"Chrome开发者工具Network","slug":"Chrome开发者工具Network","date":"2019-01-23T05:38:12.000Z","updated":"2019-09-15T08:07:30.926Z","comments":true,"path":"2019/01/23/Chrome开发者工具Network/","link":"","permalink":"https://nymrli.top/2019/01/23/Chrome开发者工具Network/","excerpt":"","text":"Chrome开发者工具中Network功能介绍 第一列Name:请求的名称，一般会将URL的最后一 部分内容当作名称。 第二列Status: 响应的状态码，这里显示为200，代表响应是正常的。通过状态码，我们可 以判断发送了请求之后是否得到了正常的响应。 第三列Type: 请求的文档类型。这里为document, 代表我们这次请求的是一个HTML文档,内容就是一些HTML代码。 第四列initiator: 请求源。用来标记请求是由哪个对象或进程发起的。 第五列Size: 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示from cache。 第六列Time:发起请求到获取响应所用的总时间。 第七列Waterfall:网络请求的可视化瀑布流。 响应中分General部分，请求头、响应头： 其中General含： Request URL为请求的URL， Request Method为请求的方法 Status Code为响应状态码， Remote Address为远程服务器的地址和端口 Referrer Policy为Referrer判别策略。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"Charles配置","slug":"Charles配置","date":"2019-01-23T05:32:21.000Z","updated":"2019-09-15T08:07:30.926Z","comments":true,"path":"2019/01/23/Charles配置/","link":"","permalink":"https://nymrli.top/2019/01/23/Charles配置/","excerpt":"","text":"Charles配置 下载SSL证书 设置SSL端口 *为通配IP网址，一般SSL的端口都是443 手机抓包 打开Charles代理 具体配置，电脑端不用做任何配置，但是需要把防火墙关掉（这点很重要）！ charles需要设置下代理端口：进入Proxy，点击Proxy Setting, 端口设置为8888（一般默认为这个） 配置手机SSL证书 然后手机打开浏览器输入chls.pro/ssl下载证书 小米手机安装charles证书 1.使用第三方浏览器下载.pem 格式的文件 （我使用的是QQ浏览器） 2.将这个文件放入小米的 DownLoad 文件夹下 (这步也可以不做，只要在4中的从存储设备安装能找到这个文件就行) 3.将.pem 文件修改为.crt 格式 4.设置—更多设置—系统安全—加密与凭据----从存储设备安装–选择文件，选定该文件 注：本人用的是小米6。 手机设置代理 其中PAC地址打开Cmd，输入ipconfig查看 参考博客: Charles配置 https://blog.csdn.net/liulanghk/article/details/46342205 https://www.jianshu.com/p/7a88617ce80b Charles使用 http://www.bubuko.com/infodetail-2252870.html","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"}]},{"title":"Python中对时间戳、时间的处理","slug":"Python中对时间戳、时间的处理","date":"2019-01-23T02:17:34.000Z","updated":"2019-09-15T08:07:30.981Z","comments":true,"path":"2019/01/23/Python中对时间戳、时间的处理/","link":"","permalink":"https://nymrli.top/2019/01/23/Python中对时间戳、时间的处理/","excerpt":"","text":"Python中对时间戳、时间的处理 time模块 获得时间戳 123timestmamp = time.time()&gt;&gt;&gt; # 1548208280.4581678 将时间戳转换成时间 12345678import timetimestamp = 1462451334timeArr = time.localtime(timestamp) # 转换成时间数组print(timeArr)# &gt;&gt;&gt;time.struct_time(tm_year=2016, tm_mon=5, tm_mday=5, tm_hour=20, tm_min=28, tm_sec=54, tm_wday=3, tm_yday=126, tm_isdst=0)dt = time.strftime(\"%Y-%m-%d %H:%M:%S\",timeArr) # 指定转换成时间格式print(dt) 将时间转换成时间戳 利用strptime()函数将时间转换成时间数组 利用mktime()函数将时间数组转换成时间戳 123456import timedt = \"2016-05-05 20:28:54\"timeArray = time.strptime(dt, \"%Y-%m-%d %H:%M:%S\") #转换成时间数组timestamp = time.mktime(timeArray) #转换成时间戳print (timestamp)# &gt;&gt;&gt; 1462451334.0 重新格式化时间 利用strptime()函数将时间转换成时间数组 利用strftime()函数重新格式化时间 1234567import timedt = \"2016-05-05 20:28:54\"timeArray = time.strptime(dt, \"%Y-%m-%d %H:%M:%S\") #转换成时间数组dt_new = time.strftime(\"%Y%m%d-%H:%M:%S\",timeArray) #转换成新的时间格式(20160505-20:28:54)print (dt_new) 按指定的格式获取当前时间 12345678import time#获取当前时间time_now = int(time.time()) time_local = time.localtime(time_now)# 转换成localtimedt = time.strftime(\"%Y-%m-%d %H:%M:%S\",time_local)# 转换成新的时间格式(2016-05-09 18:59:20)print(dt)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"基础网络知识","slug":"基础网络知识","date":"2019-01-22T11:31:47.000Z","updated":"2019-09-15T08:07:31.042Z","comments":true,"path":"2019/01/22/基础网络知识/","link":"","permalink":"https://nymrli.top/2019/01/22/基础网络知识/","excerpt":"","text":"什么是客户端、服务器端? 客户端 : ​ 发送数据、接收返回数据端 服务器: ​ 处理数据端 TCP : 面向连接—&gt; 打电话(相互回复,一来一回) 客户端向服务器端 拨号 , 三次握手 , UDP : 面向无连接 --&gt; 寄快递(寄出去就不管了). 比如 : 直播 UDP四层结构 网络访问层(链路层): 物理连接设备(网线)、MAC地址（物理地址） 互联网层： IP地址（定位设备） 传输层： port (端口号) : 表示通信进程,将数据交给哪个应用处理 应用层： 自己定义的协议（处理字符串消息的方法） port : 知名端口 : 0 - 1023，有指定的应用程序 可自由使用的端口 : 1024 - 65535 ▲广播只能使用UDP，TCP没有广播功能。一般广播只用在局域网内（路由器不转发广播）。 套接字(socket) ： 特殊的设备文件 ， 写网络应用程序的接口，写入后就是发送，接收就是读取。 应该类似于 esp8266吧… Python演示程序 服务器端程序 123456789101112import sockets = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) '''参数说明:AF_INET IPv4STREAM TCPSOCK_DGRAM UDP'''server_addr = ('127.0.0.1',8888) # 本地回环地址 , 端口s.bind(server_addr) # 绑定、传入信息data,cilent_addr = s.recvfrom(1024) # BUF_SIZE指定接收数据长度 , (数据内容,客户端地址)s.sendto(data,cilent_addr) # 给客户端发送数据 客户端程序 1234import sockets = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) server_addr = ('192.168.43.3',8888)s.sendto(b'hello',server_addr) 广播程序 255.255.255.255为广播地址 广播端接收程序 123456789101112import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)PORT = 9999s.bind( ('', PORT) ) # 这边必须是'',不能为自己的IP(否则只接受自己IP的,不接受255.255.255.2555的广播)print('Listening for broadcast at ', s.getsockname())while True: data, address = s.recvfrom(65535) print('Server received from &#123;&#125;:&#123;&#125;'.format(address, data.decode('utf-8'))) 广播发送程序 12345678import socket s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)s.setsockopt(socket.SOL_SOCKET,socket.SO_BROADCAST,1)# 创建套接字,UDP默认没有广播权限PORT = 9999network = '&lt;broadcast&gt;'# &lt;==&gt; network = '255.255.255.255's.sendto(b'hel',(network,PORT)) 拓展 : 大端和小端模式的概念 网络通信时 通常使用大端 Linxu下ifconfig命令: eth0 网卡 wlan0 无线网卡 偶然发现安卓开热点的局域网地址是192.18.x.x，而苹果的热点局域网IP地址是172.20.x.x，于是搜了了解下 192.168网段是一种私有IP地址网段，任何人在私有网络中都可以任意使用这些IP地址，但是如果要连接外网就要使用网络地址转换NAT技术进行转换后才能连接外网； 在宽带路由器上一般默认的内网IP地址为192.168.0或192.168.1网段，它是经过路由器的NAT技术转换为WAN接口的公用IP地址而连接外网的； 这样的私有IP地址除了这个网段外，还有B类网络的172.16-172.31及A类网络的10网段都是私有IP地址。","categories":[],"tags":[{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Jupyter使用","slug":"Jupyter使用","date":"2019-01-21T02:46:56.000Z","updated":"2019-09-15T08:07:30.950Z","comments":true,"path":"2019/01/21/Jupyter使用/","link":"","permalink":"https://nymrli.top/2019/01/21/Jupyter使用/","excerpt":"","text":"Jupyter使用 准备 安装pip install jupyter 运行jupyter notebook 基础概念与操作 Jupyter有三种类型的cells： code cells markdown cells raw cells 常用的是code cells和 markdown cells类型。 Cells状态分为命令模式和编辑模式，Enter进入编辑模式，ESC进入命令模式，命令模式和编辑模式下支持很多操作快捷键，非常好用。 常用命令模式快捷键： y: 单元进入代码状态 m: 转入markdown状态 r：转入raw状态 a: 上方插入新单元 b：下方插入新单元 x：剪切选中单元 c: 复制选中单元 shift-v：粘贴到上方单元 v：粘贴到下方单元 d,d（连续按两次d）:删除选中单元 z：恢复最后删除单元 ctrl+Enter:运行本单元，两种模式都适用 shift+Enter：运行本单元，并跳到下个单元，两种模式都适用 alt+Enter：运行本单元，并在下方插入新单元，两种模式都适用 常用编辑模式快捷键： Tab：代码补齐或缩进 Shift+Tab：调用方法提示，非常有用，在调用包中函数时，对于函数中的使用说明和相关参数配置，按两次shift+Tab可获取详细的方法提示。 Ctrl+]：缩进 Ctrl+[ : 解除缩进 Ctrl+A: 全选 Ctrl+Backspace：删除光标前面本行所有的内容 Ctrl+Delete:删除光标后本行所有的内容 Shift+Home：往前选取本行所有内容 Shift+End：往后选取本行所有内容； 执行当前cell，并自动跳到下一个cell：Shift Enter 执行当前cell，执行后不自动调转到下一个cell：Ctrl-Enter 载入代码 %load /Users/chenqionghe/test.py 插件 jupyter notebook 写代码自动补全 进入命令行环境，有两种方式进入命令行。 方法1：通过anconda navigator界面，选择environments，选择对应环境名，选择open terminal 方法2：直接使用cmd或者terminal等终端进入命令行。激活你想要配置代码补全的环境（如果是默认环境不用激活） 1.安装nbextensions 12$ pip install jupyter_contrib_nbextensions -i https://pypi.mirrors.ustc.edu.cn/simple$ jupyter contrib nbextension install --user 2.安装nbextensions_configurator 12$ pip install --user jupyter_nbextensions_configurator $ jupyter nbextensions_configurator enable --user 效果如图 Jupyter Notebooks：一份全面的初学者实用指南 Tableof Contents(目录索引) 这个功能可以自动找到所有的标题，生成目录。 并且这个目录还是移动的呦，你可以放在侧边栏，也可以拖动到任何你喜欢的地方悬浮起来。 Hinterland(代码补全) Hinterland功能可以让你每敲完一个键，就出现下拉菜单，可以直接选中你需要的词汇。 Snippets Snippets在工具栏里加了一个下拉菜单，可以非常方便的直接插入代码段，完全不用手动敲。 Autopep8 一键美化代码，强迫症的福音。 Qgrid Qgrid也是一个Jupyter的小部件，不过它主要用于数据帧，装上之后，就可以像操作Excel里的筛选功能一样，方便的处理数据。 1234$ pip install qgrid$ jupyter nbextension enable --py --sys-prefix qgrid# only required if you have not enabled the ipywidgets nbextension yet$ jupyter nbextension enable --py --sys-prefix widgetsnbextension 主题设置 安装主题包:pip install --upgrade jupyterthemes 查看可用主题：jt -l Available Themes: chesterish grade3 gruvboxd gruvboxl monokai oceans16 onedork solarizedd solarizedl 比如Chesterish主题： solarizedl主题： 上述图片来自量子位[1] consolamono主题: 命令参数: 修改主题命令$ jt --lineh 140 -f consolamono -tf ptmono -t grade3 -ofs 14 -nfs 14 -tfs 14 -fs 14 -T -N 附录 代码补全,不使用额外插件: 使用jedi 1.打开Anaconda Prompt或者jupyter安装的虚拟环境 输出下行代码生成 .ipython 配置文件 1ipython profile create 在当前用户 ~/.ipython/profile_default/下打开生成的文件,如我的是 C:/Users/mrli/.ipython/profile_default 2.修改ipython_config.py中的配置 123c.Completer.jedi_compute_type_timeout = 400c.Completer.greedy = Truec.Completer.use_jedi = True 3.重启jupyter http://www.eeworld.com.cn/mp/QbitAI/a58625.jspx ↩︎","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"河海大学AI+机器人冬令营(12-26)","slug":"河海大学AI-机器人冬令营","date":"2019-01-19T14:31:19.000Z","updated":"2019-09-15T08:07:31.086Z","comments":true,"path":"2019/01/19/河海大学AI-机器人冬令营/","link":"","permalink":"https://nymrli.top/2019/01/19/河海大学AI-机器人冬令营/","excerpt":"","text":"河海大学AI+机器人冬令营(19-26) The First Day~19 11:50和CXY从学校出发，坐地铁的途中感觉比想象中舒服多了，没有很多挤着急着回家的学生党。 宾馆打卡 13:30到尚客优宾馆，环境挺好。还有个办公桌,很舒服。 在房间里待到了大概3点，人都差不多到齐了以后，河海的负责人张老师带领我们去了河海大学。 校门口打卡 计软院的副院长、该活动的负责人幽默、诙谐地给我讲了讲活动背景、及要求和合作的机器人公司优必选。 下面是机器人表演舞蹈串烧的照片。关节自由多真的很多啊…很多很难的动作~ 介绍环节大约在4点就结束了。之后是在图书馆门口的签名墙上花费了巨大的时间，每个人都单独拍了两次照，说是要给我们留在纪念册上，很期待呢。 100号人拍完照已经是5：30左右了，拿到饭票后，院长就带我们前往了食堂。平常的学生食堂似乎已经关门了，接待我们的是一个据说连河海本校学生也不知道的xx食堂。 食堂打卡 大家围在圆桌上等饭吃，_ 饭终于上来了O(∩_∩)O，两荤一小荤+两素，水果+酸奶的组合已经非常不错了，下午3点才吃午饭的我，表示强行吃完这些后撑得不行。 吃完后，负责人告诉我们可以回去了。找到了南邮的其他人，我们就浩浩荡荡地回宾馆了，河海的新校区很大，给我的感觉跟南理工一样，但南理工由于居民区的存在可能显得更热闹点，放假的河海闲的挺冷清的。天黑的很快，我们开着导航，最终成功回到了宾馆。 19号的活动大致就结束了。 The Second Day~20 冬令营今天算正式开营，7:30要求在宾馆集合。床挺软的，睡得还行，早上却被一个不太好的梦在大约6:50做哟与惊醒，但还是在床上黏到了7：15的闹钟响。起了后以为应该算早的了，但最后在7：31的时候才弄好，到了一楼大厅，发现很多人都已经到了，看来大家的热情还很高涨。老师也很干脆利落，7:33就直接出发去学校了。 7:33出发，到河海的校门口大约在7:40左右。冬青食堂在学校的西北角，要走进去很多，到的时候约为7:50。比规定的时间8:10早到了15分钟，结果我们100号人就在食堂门口等了大约15分钟QAQ。 事实证明应该不需要这么早集合！ 早上是包子+稀饭，配上少许的拌饭菜–咸菜，早餐就算勉强吃完了。 教学楼打卡 早上9:00上课，非常准时。 上午的任务是组装好机器人，是个挺有逼格的机器人。从开箱到拼装，都交给我们完成了。据说这个是卖2W+的教育类机器人，顺丰快递单上表明的价格似乎是20W，运费都要110+。 开箱 组成 终于拼好了 与机器人交互需要连接WIFI和蓝牙，又折腾了好久才终于连上，期间我的同伴还错连了一个女生的机器人，瞎几把按了几个好玩的东西，引得女生大吼：“谁连了我的机器人啊”。 玩了玩几个高难度动作：单手俯卧撑、舞蹈串烧……就11:30了，上午的授课就算结束了。 仍是食堂打卡 水果换成了小橘子，肯定没有香蕉好吃啦，期望明天是苹果_ 档案袋资料,在上午结束后发的。但开营式还要等河海的领导到齐后才能开，大约定在了明天21号的下午。 档案袋 学员卡 下午讲了很久的Linux的基础知识。=.=很无聊啊，我连《机器学习Python实践》一本书都快读完了。 下午5:30挺准时下课的，6:30就要上课了，所以只好直接去食堂就餐了。 晚上6:30开始教授的是vim的基本操作，小测是让我们用VIM写个C程序编译，然后在最后结束的时候让我们10个人组个组，一起学习。队名、口号想了很久，最后很鸡贼的选了yeah当口号，不如跳舞是我们的队名。 表上说是7:30结束的，到最后，我们组是最后一个完成的，时间已经是8:30了。到宾馆几乎9点。 解决了Markdown的渲染问题TypeError: Cannot set property 'lastIndex' of undefined 再码码代码也就休息了，希望今天能睡个好觉~ The Third Day~21 早上还是很早就醒了，不知道为什么睡不深。 走的时候看了一下档案袋，想到了下午有开幕式，结果还是忘记了带营员证，结果只好中午吃饭后跑回来拿。 早上吃的是还是豆浆、粥，肉包，与昨天不同的是，菜包已经没了，很有可能是大家都不爱吃，最后剩下了很多。虽然肉包的皮也很厚，但毕竟是个肉吧2333。还多了油条，辣榨菜，这两个是我比较喜欢吃的，配粥很下饭。 上午，在调呼吸灯，感觉记忆力退化的很厉害，当初的PWM现在已经都不太会了。调了挺久，到中午吃饭的时候，才调出来。 下午，主要在看MMDR_N4的算法，总算厘清了思路，可以直接用了。授课方面的话介绍的是舵机的使用，只不过由于机器人用的是数字舵机，操作比较方便，再加上API封装的比较好，完成的就很轻松，不需要自己手写PWM。 在两点的时候，凑齐了各方的领导，终于在图书馆举办了开幕式。 结束的还挺迅速的，稍微玩了下手机就结束了。 晚上的任务是完成布置的作业: 金鸡独立： 保存机器人初始的舵机状态 控制舵机的方式实现金鸡独立（腿抬高，手臂动作） 站稳 恢复舵机状态 使用APP上的回读编程，完成一个动作序列（可以加音乐） 保存到机器人上，通过ubtRobotStartAction接口调用自己编排的动作 由于脚掌体积较大,所以将原来向后的动作加了个往前抬腿，转动脚踝的动作，使得平衡出了很大的问题，最终弄到9点都还没弄完，只好留到第二天完成了。 回到宾馆后，跟活动室的学长们视频了一波，汇报了一下进度和了解了下他们的情况，最后将看的MMDR_N4抽出，写了个文档，睡觉的时候都快11:30了。今天睡得比较晚了。 The Fourth Day~22 早上7:15的闹钟,黏了7分钟才起。隔天没Debug出来，睡的也比较晚，导致起的时候非常的疲倦。所幸的是，我们到楼下时发现老师还没来，大部队也还没走。等了好几分钟，看老师还没来，就带头直接去食堂了。早餐不同的是桃酥饼，和萝卜丝馅饼，吃完之后才收到老师的消息，得知老师也没爬起来。 上午介绍的是机器人的五个传感器的使用，主要是使用它提供的Api。传感器有： 压力、触摸、超声波、红外、气温气压。这些都比较基础，就一直在看optimization里的优化细节。WDD问了下Andriod方面的需求，就花了时间整理了下思路，安排了人员。 下午据说有电视台采访，于是没怎么看Apollo的资料，认真调了下机器人的代码。就在准备展示我们的作品，上电视的时候，机器人的动作错了，导致没站稳直接摔到了。摄影小哥等我们调试了几分钟还没调好后，就放弃我们了😭 晚上跟前几天比结束的很早，讲了点TCP/UDP及网络的基础知识，让我们写了个UDP接收信息的程序就结束了。这方面感觉老师讲的还挺好的，经验、涉及面很丰富。 The Fifth Day~23 图像处理，介绍了人脸检测、人脸识别、表情检测的接口。 具体的我也忘记做了啥了…我应该都在敲机器学习. The Fifth Day~24 下午1点还是2点，公布了项目的要求。大家就都热火朝天的开始干起来了，我们进度算很快了，吃饭前就完成了所有基础功能，我把图灵机器人和天气的Api都已经写好了。 晚上处理了人脸跟踪的功能，但碰到了python2中字符串不可变的问题，确实很棘手处理了很久才搞定。 主要发现的问题是: 当字符串&lt;4时,如’123’，那么输出的话是’’. 当赋值为a='notfound'时,,怀疑是zhx后面还是多余的空格而没有被输出出来 当写成a='notfounda'的时候，if判断得写成 if a == 'notfound\\x00' The Sixth Day~25 完成项目的拓展功能和答辩。我们昨天就完成了所有的基础功能，第二天的任务就是添加拓展功能。我们选择了三个：随机播放或中途暂停音乐、语音识别 、 人脸识别跟踪行走。 除了语音识别功能，其实有不少在昨天晚上都已经搞定了，但是当天演示时却bug了。真的是很悲催，再加上抽签的运气不是很好，第二个就上场了，导致最后的演示效果很差。 计划2点开始演示，但真正的开始时间却是2:30，我们大约是3：10分演示的，由于机器人金鸡独立时摔倒的缘故，存储人脸的机器人重启了，导致人脸数据丢失而无法演示人脸跟踪。 后面几组演示的就比较幸运，第7组都已经是吃完晚饭6:30以后演示的了…真的抽签太看运气了。 虽然演示后结果不太令人满意吧，但好在大家也没有太沮丧。说实话，演示完后就已经没什么心思看别人的演示了。于是我和张志兴学长以及南大计软的一个女生交流了一会。向张志兴学长讨教了不少单片机方面的知识，张志兴学长很棒… 说实话我一直以为他是大二的… The Seventh Day~26 忍了很久想吃面的欲望，最后一天，决定不吃食堂，找了河海外面的一家早餐店吃了面。 最后一天是闭营典礼，主要是副院长讲话，然后颁奖，昨天的答辩环节效果很差，注定了今天我们只能当观众。大家的心情都不是很好吧，毕竟都花了挺多心思，但没有获奖，真的挺可惜的。 颁完奖，拍完照，就解散了。我和我的小组成员留了一会，总结了一下这次很多地方的问题，以及交流了一下，主要是感觉对不起大家，我们完全是有能力获奖的，但由于种种原因而失败了，非常的遗憾。总结的过程被副院长听到了，很尴尬，他要我写篇感想23333，不慎惶恐。 总结结束后，我并不是很急着回学校，于是找张老师聊了聊天。得知张洪涛老师是内蒙古人，大学就读于杭州，现在工作于深圳，真的是横跨了整个中国。他也是自动化专业的，很大程度上也是因为家庭原因，直接选择了工作，据他所说大学是玩了4年，91年生的，目前也工作了6-7年了，但我感觉他的知识面还是挺广的，他讲解的网络方面的一点东西对我还是有不少启发的，所以也不知他说的是不是真的。 跟他交流了大概两个小时吧，主要是自动化的学科方向，以及之后的工作方向。感觉找前辈聊天真的是个很愉快的过程，不管他的经验是否能够借鉴，但每个人的经历都耐人寻味，想了解更多人的生活。 10点半结束的，大约12点半才离开河海，上地铁回南邮。 下面是我提交的感想，院长说会帮我润色一下的，也不知道他刊在哪里了。 大学入学以来，一直都在为了竞赛和学业而疲于奔命。经常为生活圈子日益狭窄，压力日益繁重而恐慌。于是经过一系列思考后，最终在数模美赛、电赛培训…多种寒假活动中选择参加了由江苏省教育部发起，河海大学组织的“AI+机器人”冬令营活动。选择这个冬令营原因，一是因为机器人是个交叉的学科，在接触的过程中，即可以了解硬件，又会涉及软件开发，对个人能力都会有比较高的提高；二是，想找点真正感兴趣的东西做做放松下身心，而不是像在学校那样再为了能力分和绩点终日劳神费心。 冬令营聚集了江苏省各所高校里有能力和想法的学生，在这里我们能碰到很多志同道合的朋友，刚来初到的前几天，我认识了我们学校同批参加冬令营的同学。后来几天经过交流认识了各个学校参加各种项目的同学，有做机甲大师的、有参加飞思卡尔的，有弄Robocup的……在不上课的时间里，就听他们讲说了各地的轶事、各个方面的细节…… 为时一共七天的冬令营，前五天，张洪涛老师都非常耐心地带着大家一个一个模块完成任务，每一阶段的成功，都极大地调动了我们的积极性和成就感。也为我们能够从容接受最后的项目实战做了很大的铺垫。 最后两天是完成项目，要求十个人组成一只队伍，分布式地操作机器人。在提出五个基本要求的基础上，张老师也给了我们一点启发性的意见作为评比的加分项。24号下午项目要求一公布出来，我们就在组内分配好了任务。由于基础工作比较明确，我们很快的就分配好了各自的工作，经过大家的全身心投入，我们很顺利的在吃晚饭之前就几乎把所有基础功能都做完了，但是却没有进行即时阶段性的汇总，导致第二天展示前调试比较匆忙，这也是比较可惜的地方。 吃完晚饭后，大家都很快的回到了机房，继续为更好的功能而调试。晚上规定在6:30-7:30的交流时间之后就能回去了，但为了调试代码，我们全组都选择留了下来，直到9点左右才走。当时我们在攻克的是跟踪人脸行走功能，困扰我们的是Python2上的编码问题，无论是否检测得到人脸都会向前行走。所以虽然效果能算达到，但并不是为了单纯演示就行，我们还是决定从原理上彻底查明这个的原因。由于负责的同学没怎么接触过这个问题，于是我们花了很大的功夫，在调试了N遍以后终于找了原因和解决方案。事实上也证明了我们的付出没有白费，第二天有其他小组也碰到了这样的问题，我们为他们讲明了原因，他们也很快的实现了这个功能。 我们的拓展功能还有随机播放或中途暂停音乐及语音识别，我们第二天的时间全都在测试这些。但由于语音识别的效果比较差，最后我们还是只能选择放弃演示。而播放音乐的功能全在演示前的一段时间被调错而无法使用。所有最终我们的演示效果很差，成绩也不是很理想。 作为我们队长，以及在接触Python比较多的情况下，没有带领团队获得比较好的成绩我还是比较自责的。但回想整个完成的过程，其实感慨、收获还是颇多的。首先是学长学姐对我的支持，大三学长张志兴个人能力很强，但有时我的错误指挥，他都给了很大的宽容。其次是大家团队合作的热情和态度，碰到BUG大家甚至会不吃饭选择一起解决；还有由于人数原因而后来被分配到我们小组的周轶凡，虽然跟组离得很远，逐渐边缘化，有时我甚至都没有想起他来，但是他都会非常积极地要求任务和积极参加讨论，让我感受到了团队合作的感觉，感受到了we are a team!再者是徐弘毅的热情，他跟我同是大二的，由于没怎么接触过python，还特地带了Python的书，碰到了那个编码问题，也是钻研了很久；还有的是一个比较好玩的事，当初刚开始合作完成项目的时候，大家连人名都不知道，偶然听到一个张志兴的名字，就一直把徐弘毅叫做张志兴，因为每次这么叫他队友时，徐弘毅总是第一个回头的…… 但同时我们确实也存在很多的问题：答辩展示的重点并不是很明确，有些基础功能觉得大家都展示过，自己就太轻视而可能没有展示；拓展功能完成的太顺利而没有介绍到……都是一些答辩上完成的不够好的地方，以及临场应变还不熟练。还有的是缺少团队合作经验，导致很多程序架构方面的事都没有说清楚，比如Python在缩进上要求很严格，而我在我的笔记本上汇总总程序都是4个空格一层缩进，他们在机器人上的代码都是8个空格一层的。但队友都比较好心，没有提出问题，而是默默的每次都帮我改好，直到最后演示前又发了一遍代码后才发现这个由于没有沟通而导致严重的架构问题。同时还有，分工上也太牵强了，虽然基础功能分工的比较明确，都挺好的实现了，但是拓展功能，由于我做该方面做的比较多，我没有分配下去而是选择了一人承担，导致汇总以及拓展功能的调试都落在我身上，在展示前一段调试的时间里，哪边出了问题都得我去处理，最后确实有点无暇分身、弄得很乱…… 这次的项目有很多好好坏坏，但这次的合作，让我们从全都不认识，到现在能相互开玩笑；不能写Python代码到能写Python项目，真的成长了太多。虽然成绩比较可惜，但是我为认识他们而高兴。在此，我要再次感谢我的队友：张志兴、徐弘毅、王青雅、侍亚东、林丹丹、陈晓谦、陈怀新。大家在各自的领域内都是大手子，而这次我能荣幸的担任他们的队长，真的是很不容易，从心里感谢他们的包容和理解、配合与支持。 因为你们，不虚此行~ 附: 安排表 三角包子(实心,没馅的!!! 两大荤、一小荤、两素的套餐，多图警告","categories":[],"tags":[{"name":"生活小记","slug":"生活小记","permalink":"https://nymrli.top/tags/生活小记/"}]},{"title":"DFS专项练习","slug":"DFS专项练习","date":"2019-01-19T12:53:03.000Z","updated":"2019-09-15T08:07:30.929Z","comments":true,"path":"2019/01/19/DFS专项练习/","link":"","permalink":"https://nymrli.top/2019/01/19/DFS专项练习/","excerpt":"","text":"DFS专题 leetcode 104. 二叉树的最大深度 123456789101112131415161718/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */#include&lt;algorithm&gt;class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(root==NULL)return 0; int l1=maxDepth(root-&gt;left); int l2=maxDepth(root-&gt;right); return max(l1,l2)+1; &#125; DFS模板总结 1234567891011121314151617181920212223void dfs()//参数用来表示状态 &#123; if(到达终点状态) &#123; ...//根据题意添加 return; &#125; if(越界或者是不合法状态) return; if(特殊状态)//剪枝 return ; for(扩展方式) &#123; if(扩展方式所达到状态合法) &#123; 修改操作;//根据题意来添加 标记； dfs（）； (还原标记)； // visited[i] = 1; //是否还原标记根据题意 //如果加上（还原标记）就是 回溯法 // visited[i] = 0 &#125; &#125; &#125; 全排列问题 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std; int p[10]=&#123;0&#125;;bool vis[10]=&#123;0&#125;;int n;void dfs(int x)&#123; if (x==n+1)&#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;p[i]&lt;&lt;\" \"; cout&lt;&lt;endl; return ; &#125; for (int i=1;i&lt;=n;i++)&#123; if (vis[i]==false ) &#123; p[x] = i; vis[i] = true; dfs(x+1); vis[i] = false; &#125; &#125;&#125; int main()&#123; n=4; dfs(1); return 0;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"}]},{"title":"Typora可选选项","slug":"Typora可选选项","date":"2019-01-19T12:51:11.000Z","updated":"2019-09-15T08:07:31.008Z","comments":true,"path":"2019/01/19/Typora可选选项/","link":"","permalink":"https://nymrli.top/2019/01/19/Typora可选选项/","excerpt":"","text":"用了这么久markdown才发现原来支持Latex的符号公式，但是在Typera中需要自行设置出来，文件--&gt;偏好设置--&gt;markdown拓展语法（内联公式）、代码块（显示行号） Latex 公式：32​\\frac{3}{2}​23​​ 带有行号的代码块 12345#include &lt;stdio.h&gt;int main()&#123; printf(\"hello world\"); return 0;&#125; 其他功能自行发现吧！_","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"Latex学习","slug":"Latex学习","date":"2019-01-19T12:49:31.000Z","updated":"2019-09-15T08:07:30.953Z","comments":true,"path":"2019/01/19/Latex学习/","link":"","permalink":"https://nymrli.top/2019/01/19/Latex学习/","excerpt":"","text":"基本概念和使用 Hello, world! 12345\\documentclass&#123;article&#125;%这里是导言区\\begin&#123;document&#125;Hello, world!\\end&#123;document&#125; 请注意，TeX 对控制序列的大小写是敏感的 部分控制序列还有被方括号[]包括的可选参数。 出现了控制序列 begin，这个控制序列总是与 end 成对出现。这两个控制序列以及他们中间的内容被称为「环境」；他们之后的第一个必要参数总是一致的，被称为环境名。 只有在 “document” 环境中的内容，才会被正常输出到文档中去或是作为控制序列对文档产生影响。也就是说，在 \\end{document} 之后插入任何内容都是无效的。 \\begin{document} 与 \\documentclass{article} 之间的部分被称为导言区。导言区中的控制序列，通常会影响到整个输出文档。 输出中文 使用命令行输入texworks打开tex编辑器 1234\\documentclass[UTF8]&#123;ctexart&#125;\\begin&#123;document&#125;你好，world!\\end&#123;document&#125; 文档类从 article 变为 ctexart； 增加了文档类选项 UTF8。 12345678\\documentclass[UTF8]&#123;ctexart&#125;\\title&#123;你好，world!&#125;\\author&#123;Liam&#125;\\date&#123;\\today&#125;\\begin&#123;document&#125;\\maketitle你好，world!\\end&#123;document&#125; 笔记 中文问题 面对中文编码问题，CJK被淘汰，使用ctexart编译中文 ▲注意，编译方式必须改为xeLaTex，只有部分环境下 pdfLaTex 也可以编译成功 1234\\documentclass[UTF8]&#123;ctexart&#125;\\begin&#123;document&#125;您可以看到，说明你编译成功了！\\end&#123;document&#125; 标准文类 article：短文，评论，学术论文；无左右页区分，无章设置。对应中文类ctexart。 book：著作，学位论文；默认有左右页区分，章起右页。对应中文类ctexbook。 report：商业，科技，试验报告，默认无左右页区分，章起新页。对应中文类：ctexrep。 beamer：论文陈述幻灯片；提供多种主题式样，可方便更改幻灯片的整体风格。 常用宏包 不是必须记住，需要用哪个现查即可，列出这些是为了浏览别人的源文件时知道人家调用了哪个宏包。 amsmath 公式环境和数学命令 amssymb 数学符号生成命令 array 数组和表格制作 calc 四则运算 caption 插图和表格标题格式设置 fancyhdr 页眉页脚设置 fancyvrb 抄录格式设置 fontspec 字体选择 geometry 版面尺寸设置 graphicx 插图处理 hyperref 创建超文本链接和PDF书签 longtable 制作跨页表格 multicol 多栏排版 ntheorem 定理设置 paralist 多种列表环境 tabularx 自动设置表格列宽 titlesec 章节标题格式设置 titletoc 目录格式设置 xcolor 颜色处理 xeCJK 中日朝文字处理和字体选择","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"Latex","slug":"Latex","permalink":"https://nymrli.top/tags/Latex/"}]},{"title":"每日codewars","slug":"每日codewars","date":"2019-01-19T12:47:50.000Z","updated":"2019-09-15T08:07:31.084Z","comments":true,"path":"2019/01/19/每日codewars/","link":"","permalink":"https://nymrli.top/2019/01/19/每日codewars/","excerpt":"","text":"Codewars 12.17 Sum without highest and lowest number 1234567891011121314151617181920212223242526272829#include&lt;vector&gt;#include&lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int sum(vector&lt;int&gt; numbers)&#123; /* Sum without highest and lowest number &#123; 6, 2, 1, 8, 10 &#125; =&gt; 16 &#123; 1, 1, 11, 2, 3 &#125; =&gt; 6 */ if(numbers.empty()) return 0; if(numbers.size()==1) return 0; sort(numbers.begin(),numbers.end()); int sum=0; for( vector&lt;int&gt;::iterator it = numbers.begin()+1;it != numbers.end()-1;it++) sum += *it; return sum;&#125;int main()&#123; vector&lt;int&gt; n; n.push_back(1); n.push_back(3); n.push_back(5); cout &lt;&lt; sum(n); return 0;&#125; C++11支持的新特性 12345vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5,7&#125;;// 支持了vector &#123;&#125;的初始化方式for(int i : a) cout &lt;&lt; i;//支持了for(:) 12.19 reverse Sum of positive 1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;algorithm&gt;/**Hex to Decimal**/int hexToDec(std::string hexString)&#123; reverse(hexString.begin(),hexString.end()); int base = 1; int sum =0 ; bool fu = 0; for(string::iterator it = hexString.begin() ; it != hexString.end() ; it++ )&#123; if( *it == '-') &#123;fu = 1; continue;&#125; int num = 0; if( *it &gt;= 'A' &amp;&amp; *it &lt;= 'F' ) num = *it - 'A' + 10; else if( *it &gt;= 'a' &amp;&amp; *it &lt;= 'f' ) num = *it - 'a' + 10; else num = *it - '1' + 1; sum += num * base; base *= 16; &#125; return fu?-sum:sum;&#125;//base来控制相应位数，Aa都要考虑，负数 12for(string::iterator it = hexString.begin() ; it != hexString.end() ; it++ )// *it 是 char类型的 12.20 stoi、istringstream、sscanf Hex to Decimal 12345#include &lt;string&gt;int hexToDec(const std::string&amp; hexString)&#123; return std::stoi(hexString, nullptr, 16); //return std::stoi(hexString, 0, 16);&#125; 123456#include &lt;ios&gt;int hexToDec(std::string hexString)&#123; int n; std::istringstream(hexString) &gt;&gt; std::hex &gt;&gt; n; return n;&#125; 123int hexToDec(std::string hexString)&#123; return (int)strtol(hexString.c_str(), 0, 16);&#125; 12345int hexToDec(std::string hex) &#123; int decValue; sscanf(hex.c_str(), \"%x\", &amp;decValue); return decValue;&#125; 12.21 增强的for(ch : vowels ) Vowel Count 123456789101112#include &lt;string&gt;using namespace std;int getCount(const string&amp; inputStr)&#123; int num_vowels = 0; vector&lt;char&gt; vowels = &#123;'a', 'e', 'i', 'o', 'u' &#125;; for(int it = 0; it != inputStr.size() ; it++ ) for(char ch : vowels ) if( ch == inputStr[it] ) num_vowels++; return num_vowels;&#125;/**const string&amp; inputStr**/for(string::const_iterator it = inputStr.begin() ; it != inputStr.end() ; it++) // 迭代器为const_iterator，而不是iterator 优秀解答： count_if 12345678910111213141516171819202122232425int getCount(const string&amp; inputStr)&#123; return count_if(inputStr.begin(), inputStr.end(), [](const char ch) &#123; switch(ch) &#123; case 'a': case'e': case'i': case'o': case'u': return true; default: return false;&#125; &#125;);&#125;// &lt;=====&gt;#include &lt;string&gt;using namespace std;bool is_vowel(char c) &#123; return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');&#125;int getCount(const string&amp; inputStr) &#123; return count_if(inputStr.begin(), inputStr.end(), is_vowel);&#125; 12.22 for_each和C11的匿名函数 Invert values 123456789/**Invert values**/#include &lt;vector&gt;std::vector&lt;int&gt; invert(std::vector&lt;int&gt; values)&#123; std::vector&lt;int&gt; v2; for_each(values.begin(),values.end(),[ &amp;v2](int c)&#123; v2.push_back(-c); &#125;); return v2;&#125;// 学会使用了 for_each和C11的匿名函数 匿名函数 参数 1234[](int x, int y) &#123; return x + y; &#125; // 隐式返回类型[](int&amp; x) &#123; ++x; &#125; // 没有return语句 -&gt; lambda 函数的返回类型是'void'[]() &#123; ++global_x; &#125; // 没有参数,仅访问某个全局变量[]&#123; ++global_x; &#125; // 与上一个相同,省略了() 技巧: 没有return ， 则 lambda的返回类型是void 如果没有参数，则可以省略参数 捕获 值捕获 引用捕获 123456[] //未定义变量.试图在Lambda内使用任何外部变量都是错误的.[x, &amp;y] //x 按值捕获, y 按引用捕获.[&amp;] //用到的任何外部变量都隐式按引用捕获[=] //用到的任何外部变量都隐式按值捕获[&amp;, x] //x显式地按值捕获. 其它变量按引用捕获[=, &amp;z] //z按引用捕获. 其它变量按值捕获 12.23 ▲transform 算法transform()提供以下两种能力： 1.第一形式有4个参数，把源区间的元素转换到目标区间。也就是说，复制和修改元素一气呵成； transform(sourceBeg,sourceEnd,destBeg,op) (1)针对源区间[sourceBeg,sourceEnd)中的每一个元素调用：op(elem) 并将结果写到以destBeg起始的目标区间内； (2)返回目标区间内“最后一个被转换元素”的下一个位置，也就是第一个未被覆盖的元素位置； (3)调用者必须确保目标区间有足够的空间，要不就得使用插入型迭代器； (4)sourceBeg于destBeg可以相同，所以，和for_each()算法一样，你可以使用这个算法来变动某一序列内的元素； (5)如果想以某值替换符合某一准则的元素，应使用replace()算法； (6)复杂度：线性； 12345678910#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int test()&#123; vector&lt;int&gt; coll1; for (int i=1;i&lt;9;i++) coll1.push_back(i); transform(coll1.begin(),coll1.end(),coll1.begin(),negate&lt;int&gt;()); for (int i=0;i&lt;8;i++) cout &lt;&lt; coll1.at(i) &lt;&lt;endl; //-1 -2 -3 -4 -5 .. -8&#125; 2.第二形式有5个参数，将前两个源序列中的元素合并，并将结果写入目标区间。 transform(source1Beg,source1End,source2Beg,destBeg,op) (1)针对第一源区间[source1Beg,source1End)以及“从source2Beg开始的第二源区间”的对应元素，调用:op(source1Elem,source2Elem) 并将结果写入以destBeg起始的目标区间内； (2)返回区间内的“最后一个被转换元素”的下一位置，就是第一个未被覆盖的元素的位置； (3)调用者必须保证第二源区间有足够空间（至少拥有和第一区间相同的空间大小）； (4)调用者必须确保目标区间有足够空间，要不就得使用插入型迭代器； (5)source1Beg，source2Beg，destBeg可以相同。所以，可以让元素自己和自己结合，然后将结果覆盖至某个序列； (6)复杂度:线性； 12345678910#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int test()&#123; vector&lt;int&gt; coll1; for (int i=1;i&lt;9;i++) coll1.push_back(i); transform(coll1.begin(),coll1.end(),coll1.begin(),coll1.begin(),multiplies&lt;int&gt;()); for (int i=0;i&lt;8;i++) cout &lt;&lt; coll1.at(i) &lt;&lt;endl; // 1,4,16,25...81&#125; http://lib.csdn.net/article/cplusplus/32641 Remove exclamation marks 123456789101112131415161718#include &lt;queue&gt;#include &lt;string&gt;using namespace std;std::string removeExclamationMarks(std::string str)&#123; //your code here queue&lt;char&gt; st; for(string::iterator it = str.begin() ; it != str.end() ; it++) if( *it != '!') st.push(*it); string s; for(int i = st.size() ; i &gt;0 ; i--)&#123; s += st.front(); st.pop(); &#125; return s;&#125;// &gt;&gt;&gt; 2323!!asd ===&gt; 2323asd 12.24 Maximum Multiple 12345int maxMultiple(int divisor, int bound) &#123; // Your Code is Here ... Enjoy !!! if ( bound % divisor == 0) return bound; return divisor * ( bound / divisor);&#125; 12.25 nth_element()函数 部分排序 头文件：#include&lt;algorithm&gt; 作用：nth_element(a+l,a+k,a+r) 它会使a这个数组中区间[l,r)内的第k大的元素处在第k个位置上(相对位置)，**但是它并不保证其他元素有序！**且第 n 个元素之前的元素都小于它，但不必是有序的。同样，第 n 个元素后的元素都大于它，但也不必是有序的。 排序后a[n]就是数列中第n+1大的数 12nth_element(intVect.begin(),intVect.begin()+3,intVect.end());cout &lt;&lt; intVect[2]&lt;&lt; endl; https://zhidao.baidu.com/question/1447317576049306340.html 12.26 Mumbling 1234567891011121314151617181920212223242526using namespace std;class Accumul&#123;public: static std::string accum(const std::string &amp;s) &#123; stringstream result; for (int i = 0; i &lt; s.length(); i++) result &lt;&lt; \"-\" &lt;&lt; string(1, toupper(s[i])) &lt;&lt; string(i, tolower(s[i])); return result.str().substr(1); &#125;&#125;;class Accumul&#123;public: static std::string accum(const std::string &amp;s) &#123; std::string result; for (int i = 0; i &lt; s.length(); i++) &#123; result.append(\"-\"); result.append(std::string(1,toupper(s[i]))); result.append(std::string(i,tolower(s[i]))); &#125; return result.substr(1,result.length()); &#125;&#125;; 12.27 Highest and Lowest 12345678910111213141516171819//[mySolution]#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;string highAndLow(const string&amp; numbers)&#123; string single; //每个字符 stringstream ss(numbers); //字符流 vector&lt;int&gt; s; //存储每个数字的vec while( getline(ss,single,' ') ) //根据空格分割 //while(ss &gt;&gt; s) s.push_back(stoi(single)); sort(s.begin(),s.end(),greater&lt;int&gt;()); //从大到小排序 //将整数拼合起来 stringstream sss; sss &lt;&lt; s.at(0) &lt;&lt; \" \" &lt;&lt; s.at(s.size() - 1) ; return sss.str();&#125; boost库 1234567891011#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;boost&gt;using namespace std;using namespace boost;int main() &#123; string s = \" hello boost!! \"; trim(s); cout &lt;&lt; s &lt;&lt; endl;&#125; 返回 编译器允许的 int 型数 最大值std::numeric_limits&lt;int&gt;::max () 1.1 Minimize Sum Of Array (Array Series #1) 12345678910111213141516171819#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int minSum (vector&lt;int&gt;passed)&#123; sort(passed.begin(),passed.end()); int sum = 0 ; int n = passed.size(); for(int i=0;i&lt; n/2; i++)&#123; sum += passed.at(i) * passed.at(n-1-i); &#125; return sum ;&#125;int main()&#123; cout &lt;&lt; minSum(&#123;5,4,2,3&#125;); //最远的两个数相乘，内积 return 0;&#125; 函数形参为vec时，可以直接将{x1,x2,x3}当参数传入。 inner_product 定义在 numeric 头文件中的 inner_product() 算法可以计算两个 vector 的内积。这个函数模板有 4 个参数：前两个参数是定义第 1 个 vector 的输入迭代器，第 3 个参数是确定第 2 个 vector 的开始输入迭代器，第 4 个参数是和的初值。算法会返回 vector 的内积。例如： cout &lt;&lt; inner_product(begin(passed),begin(passed)+n,passed.rbegin(),0) &lt;&lt; endl; 1.2 关于删除可迭代对象中元素 123456789101112131415161718//正确写法std::list&lt; int&gt; List;std::list&lt; int&gt;::iterator itList;for( itList = List.begin(); itList != List.end(); )&#123; if( WillDelete( *itList) ) itList = List.erase( itList); //或者 List.erase( itList ); //反正就是不能让下标一下进两个，如果将++写在for里面，会导致删除后漏了一个元素判断 else itList++;&#125;//错误写法std::list&lt; int&gt; List;std::list&lt; int&gt;::iterator itList;for( itList = List.begin(); itList != List.end(); itList++)&#123; if( WillDelete( *itList) ) List.erase( itList);&#125; 错误原因：在调用erase方法之后使用“++”来获取下一个元素的位置，由于在调用erase方法以后，该元素的位置已经被删除，如果在根据这个旧的位置来获取下一个位置，则会出现异常。 在Python里面遍历删除元素时，下标问题，会使略过元素==&gt; 解决方法： if，else Disemvowel Trolls 12345678910111213# include &lt;string&gt;std::string disemvowel(std::string str)&#123; for(std::string::iterator it = str.begin() ; it != str.end() ;)&#123; if ( *it == 'A' || *it == 'I' || *it == 'U' || *it == 'E' || *it == 'O' || *it == 'a' || *it == 'o' || *it == 'i' || *it == 'u' || *it == 'e' ) str.erase(it); else it++; &#125; return str;&#125; c++正则 123456# include &lt;string&gt;# include &lt;regex&gt;std::string disemvowel(std::string str)&#123; std::regex vowels(&quot;[aeiouAEIOU]&quot;); return std::regex_replace(str, vowels, &quot;&quot;);&#125; 1.3 在string中查找子串 string:: string::find(string &amp;); 123456789101112131415161718int main()&#123; string a=\"abcdefghigklmn\"; string b=\"def\"; string c=\"123\"; string::size_type idx; idx=a.find(b);//在a中查找b. if(idx == string::npos )//不存在。 cout &lt;&lt; \"not found\\n\"; else//存在。 cout &lt;&lt;\"found\\n\"; idx=a.find(c);//在a中查找c。 if(idx == string::npos )//不存在。 cout &lt;&lt; \"not found\\n\"; else//存在。 cout &lt;&lt;\"found\\n\"; return 0;&#125; 当没有找到时返回string::npos 1.4 12345678910111213141516171819202122232425262728293031class CountDig&#123;public: static int nbDig(int n, int d);&#125;;using namespace std;//计算num中出现数字d的次数int contain(int num,int d)&#123; int n =0 ; while( num &gt;= 1)&#123; int ge = num % 10; num = num / 10; if( ge == d) n++; &#125; return n;&#125;//要求的成员函数int CountDig::nbDig(int n, int d)&#123; vector&lt;int&gt; v; for(int i=0 ; i &lt;= n ; i++) v.push_back( i*i ); int cnt =0; for_each(v.begin(),v.end(),[d,&amp;cnt](int x)&#123; int appn = contain(x,d); cnt += appn ; &#125;); return d==0?++cnt:cnt ; //由于contain函数会舍去0的情况，所以这边补上&#125; topow(int ,int) 丢精度 问题尚未解决 1.5 Compare Strings by Sum of Chars isalpha的使用，sum为int类型，当sum+= char类型的c时，实际加的就是c的ASCII码值 12345678910111213// Calculate the char-value of the stringint charvalue(std::string s)&#123; int sum = 0; for(char &amp;c : s)&#123; if(!std::isalpha(c)) return 0; sum += std::toupper(c); &#125; return sum;&#125;bool compare(std::string s1, std::string s2)&#123; return charvalue(s1) == charvalue(s2);&#125; 1.6号后开始认真复习 考试周忙，空了好多练习 1.24 缺少main函数报错 1.28 PTA 求自定类型元素的平均 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Average( ElementType S[], int N );int main ()&#123; ElementType S[MAXN]; int N, i; scanf(\"%d\", &amp;N); for ( i=0; i&lt;N; i++ ) scanf(\"%f\", &amp;S[i]); printf(\"%.2f\\n\", Average(S, N)); return 0;&#125;ElementType Average( ElementType S[], int N )&#123; int i; ElementType sum; for(i=0;i&lt;N;i++) sum += S[i]; return sum/(ElementType)(N);&#125; 求单链表结点的阶乘和 链表 + 阶乘 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node *PtrToNode;struct Node &#123; int Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */&#125;;typedef PtrToNode List; /* 定义单链表类型 */int FactorialSum( List L );int main()&#123; int N, i; List L, p; scanf(\"%d\", &amp;N); L = NULL; for ( i=0; i&lt;N; i++ ) &#123; p = (List)malloc(sizeof(struct Node)); scanf(\"%d\", &amp;p-&gt;Data); p-&gt;Next = L; L = p; &#125; printf(\"%d\\n\", FactorialSum(L)); return 0;&#125;// ----完成部分----int FactorialSum( List L )&#123; struct Node* p = L; int sum = 0; while( p )&#123; int fac=1; for(int i=1;i&lt;=p-&gt;Data ;i++) fac *= i; //计算N的阶乘 sum += fac; p = p-&gt;Next; &#125; return sum;&#125; 统计某类完全平方数 平方数,取出各位 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;math.h&gt;int IsTheNumber ( const int N );int main()&#123; int n1, n2, i, cnt; scanf(\"%d %d\", &amp;n1, &amp;n2); cnt = 0; for ( i=n1; i&lt;=n2; i++ ) &#123; if ( IsTheNumber(i) ) cnt++; &#125; printf(\"cnt = %d\\n\", cnt); return 0;&#125;int IsTheNumber ( const int N )&#123; int n = (int )sqrt(N); if( N == n*n ) &#123; int arr[10] = &#123;0&#125;; int m = N; while( m &gt; 0)&#123; int tmp = m%10; arr[tmp] += 1; for( int i = 0 ;i&lt;10;i++)&#123; if( arr[i] == 2)return 1; &#125; m /= 10; &#125; return 0; // 注意这边得考虑 &#125;else return 0;&#125; 1.29 统计个位数字 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int Count_Digit ( const int N, const int D );int main()&#123; int N, D; scanf(\"%d %d\", &amp;N, &amp;D); printf(\"%d\\n\", Count_Digit(N, D)); return 0;&#125; Count_Digit ( const int N, const int D )&#123; int cnt =0 ; if ( N == 0 ) return 1; //需要考虑 N = 0的情况 int m =N&gt;0?N:-N; //以及负数情况, 这边取绝对值 while(m &gt; 0 )&#123; int tmp = m%10; if( tmp == D) cnt++; m /= 10; &#125; return cnt;&#125; 6-10 阶乘计算升级版 ----高精度 题解 123456789101112131415161718192021222324252627282930void Print_Factorial ( const int N )&#123; long i,s=1; if(N&gt;=0&amp;&amp;N&lt;=12)&#123; //剪枝.减少时间复杂度 for(i=2 ;i&lt;=N ;i++)s *= i; printf(\"%ld\\n\",s); &#125;else if(N&gt;12&amp;&amp;N&lt;=1000)&#123; int num[3000] = &#123;0&#125;; num[0] = 1; int k=1; //位数 int n=0; //进位 int temp; for(int i=2 ;i&lt;=N ;i++)&#123; for(int j=0;j&lt;k;j++)&#123; temp = num[j]*i+n; //每一位相乘 再+进位 num[j] = temp%10; //更新每一位的数字 n = temp/10; //判断能否进位 &#125; while(n!=0)&#123; //如果可以进位 num[k] = n%10; //新增一位 n /=10; //继续判断能否进位 k++; &#125; &#125; for(int x=k-1;x&gt;=0;x--)printf(\"%d\",num[x]); //逆序输出数字 &#125; else&#123; printf(\"%s\\n\",\"Invalid input\"); &#125;&#125; 我的做法(错误): 123456789101112131415161718192021222324252627282930int mutliply(int a[],int n,int b)&#123; for(int i = n - 1 ;i &gt;= 0 ; i--)&#123; //计算机计算时, 4*6 , 先将十位确定,再确定个位 int tmp = a[i] * b; while( tmp &gt;= 10 ) &#123; /*▲. 这样的写法,存在124,无法在百位进位的缺陷 还是最好 tmp %= 10; n /= 10; */ tmp -=10; a[i+1] += 1; &#125; a[i] = tmp; &#125;&#125;void Print_Factorial ( const int N )&#123; if( N &lt; 0 ) &#123; printf(\"Invalid input\"); return ; &#125; int a[10000]=&#123;0&#125;; a[0] = 1; int n =10000; for(int i=1;i&lt;=N;i++)&#123; mutliply(a,n,i); &#125; for(int i=n-1;i &gt;= 0; i--) printf(\"%d \",a[i]); &#125; 总结 : 如果arr[0] = 1, 则得逆序输出。 由于要考虑前缀0的原因，必须考虑位数问题，这也是为什么我的方法一开始没有考虑位数问题，最后就算不下去的原因、 修改后重版 123456789101112131415161718192021222324252627282930313233void mutliply(int a[],int *n,int b)&#123; int w = 0; //进位 for(int j = 0 ;j &lt; *n; j++)&#123; // 对目前存在每一位相乘 int tmp = a[j] * b + w; //这样写不用担心,个位多了后十位先进了x,然后十位原有y,结果为(x+y)*b的情况 //因为这样写,十位是同时处理的,而不是像a[j++]先在十位加上w后,再在加上w的基础上*b a[j] = tmp %10; w = tmp / 10; &#125; while( w != 0)&#123; //比原来n位,进位的情况 a[ *n ] = w %10; w /= 10; (*n) ++; //这边出现了个运算优先级的问题 &#125;&#125;void Print_Factorial ( const int N )&#123; if( N &lt; 0 ) &#123; printf(\"Invalid input\"); return ; &#125; int a[10000]=&#123;0&#125;; a[0] = 1; int n = 1; //位数 for(int i=2; i &lt;= N;i++)&#123; //阶乘的数目 , 从2开始,可以少算1个1 , 结果一样 mutliply(a,&amp;n,i); &#125; for(int i= n-1 ;i &gt;= 0; i--) printf(\"%d\",a[i]); // 逆序输出数字 &#125; 关于++ 和取地址符*的优先级顺序 1.30 蛇皮卡排序题 6-11 求自定类型元素序列的中位数 开始用冒泡算法，最后一个测试点过不去 用快速排序，最后一个测试点过不去，数据太多数相同；数据特殊导致时间复杂度退化。 用希尔排序，ac 我的代码: 选择排序 12345678910111213141516ElementType Median( ElementType A[], int N )&#123; for(int i= 0; i&lt; N-1 ; i++)&#123; int nmax = i; for( int j = i+1;j&lt;N;j++)&#123; if( A[nmax] &lt; A[j] ) nmax = j; &#125; if( nmax != i )&#123; int tmp = A[i]; A[i] = A[nmax]; A[nmax] = tmp; &#125; &#125; return A[ N /2 ];&#125; 运行后PE… 搜了题解,发现全部用的是 希尔排序(shell_sort) 希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序 同时该算法是冲破O(n2）的第一批算法之一 关于希尔排序increment（增量）的取法 增量increment的取法有各种方案。最初shell提出取increment=n/2向下取整，increment=increment/2向下取整，直到increment=1。但由于直到最后一步，在奇数位置的元素才会与偶数位置的元素进行比较，这样使用这个序列的效率会很低。后来Knuth提出取increment=n/3向下取整+1.还有人提出都取奇数为好，也有人提出increment互质为好。应用不同的序列会使希尔排序算法的性能有很大的差异。 原文：https://blog.csdn.net/weixin_37818081/article/details/79202115 题解: 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 题解一ElementType Median( ElementType A[], int N)&#123; int i, j, Increment; ElementType Tmp; //将数组排序 for ( Increment = N / 2; Increment &gt; 0; Increment /= 2)&#123; for ( i = Increment; i &lt; N; i++)&#123; Tmp = A[ i ]; for (j = i;j &gt;= Increment ; j -= Increment )&#123; if ( Tmp &lt; A[ j - Increment ]) A[ j ] = A[ j - Increment ]; else break; &#125; A[ j ] = Tmp; &#125; &#125; return A[ N / 2 ];&#125;// 题解二:void shell_sort(ElementType A[],int N);ElementType Median(ElementType A[],int N)&#123; if(N==1) return A[0]; shell_sort(A,N); return A[N/2];&#125;void shell_sort(ElementType A[],int N)&#123; int i,j,gap; // 三层循环 for(gap=N/2;gap&gt;0;gap/=2) for(i=gap;i&lt;N;i++) for(j=i-gap; j&gt;=0 &amp;&amp; A[j]&gt;A[j+gap] ; j-=gap)&#123; // 交换位置 ElementType temp=A[j]; A[j]=A[j+gap]; A[j+gap]=temp; &#125;&#125; 判断奇偶性 1234int even( int n )&#123; return n%2==0; // 由于优先级原因, 不能写成 return !n%2;&#125; 6-13 折半查找 题目要求 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;#define MAXSIZE 50typedef int KeyType;typedef struct&#123; KeyType key;&#125; ElemType;typedef struct&#123; ElemType *R; int length;&#125; SSTable;void Create(SSTable &amp;T)&#123; int i; T.R=new ElemType[MAXSIZE+1]; cin&gt;&gt;T.length; for(i=1;i&lt;=T.length;i++) // 注意这边构造的时候,下标是从1开始的, // 所以下面写二分搜索的LOW,HIGH也需要相应的改 cin&gt;&gt;T.R[i].key;&#125;int Search_Bin(SSTable T, KeyType k);int main ()&#123; SSTable T; KeyType k; Create(T); cin&gt;&gt;k; int pos=Search_Bin(T,k); if(pos==0) cout&lt;&lt;\"NOT FOUND\"&lt;&lt;endl; else cout&lt;&lt;pos&lt;&lt;endl; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// 题解int Search_Bin(SSTable T, KeyType k)&#123; int low = 1 , high = T.length ; // 下标是 1, N int m; while( low &lt;= high)&#123; m = (low+high) / 2; if ( T.R[m].key == k ) return m ; else if (k&lt; T.R[m].key ) high = m-1; else low = m+1; &#125; return 0;&#125;// 数据结构书上#include &lt;cstdio&gt;int binsearch(int a[],int N,int k)&#123; int low=0 ,high = N -1; // 下标是 0 , N-1 int m; while( low&lt;=high)&#123; m = (low +high ) /2 ; if( a[m] &lt; k) low = m+1; else if( a[m] &gt; k) high = m -1; else return m; &#125; return -1;&#125;int main()&#123; int a[10]; int N; scanf(\"%d\",&amp;N); for(int i= 0 ;i&lt;N ;i++) scanf(\"%d\",&amp;a[i]); int k; scanf(\"%d\",&amp;k); int pos = binsearch(a,N,k); if( pos == -1) printf(\"NOT FOUND\"); else printf(\" index is : %d\",pos); return 0;&#125; 1.31 编程题 厘米换算英尺英寸 1234567891011#include&lt;cstdio&gt;int main()&#123; int N; while( scanf(\"%d\",&amp;N) == 1)&#123; int foot = N / 30.48; int inch = 12 * ( N / 30.48 - foot); // 这边的 N / 30.48 结果并不是整数 , 而是double类型的 printf(\"%d %d\\n\",foot, inch); &#125; return 0;&#125; 7-2 然后是几点 题目考察了对提取不同位数,再组合的能力 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;int main()&#123; int x,y; while( scanf(\"%d%d\",&amp;x,&amp;y) == 2)&#123; int hour_split = x/100; int reminderm = y % 60 + x%100; int moreh = reminderm / 60 ; int h = hour_split+ y / 60 + moreh; int leftm = reminderm % 60; printf(\"%d\\n\", h * 100 + leftm); &#125; return 0;&#125;// 由于第一种没有考虑到负数的情况,所以改进就额外加了个if#include &lt;cstdio&gt;int main()&#123; int x,y; int minush = 0; int h ; int moreh ; while( scanf(\"%d%d\",&amp;x,&amp;y) == 2)&#123; int hour_split = x/100; // 根据x切割出原来的小时 int reminderm = y % 60 + x%100; // 根据提供的流逝分钟数,找到结合x,y分钟数的结果 int leftm = reminderm % 60; // 区别主要是负数时要限制 , 题解也是如此思路 //分钟在0-60之内,小时减去相应的值, 但是得考虑-20, y/60==0的情况 if( leftm &lt; 0 )&#123; moreh = reminderm / 60 - 1; int minusm = 60 + leftm ; // 由于leftm &lt; 0 且 在0-60之内,所以minusm在0-60之内 h = hour_split+ y / 60 + moreh ; printf(\"%d\\n\", h * 100 + minusm ); &#125;else&#123; moreh = reminderm / 60 ; h = hour_split+ y / 60 + moreh; printf(\"%d\\n\", h * 100 + leftm ); &#125; &#125; return 0;&#125; 题解 1234567891011121314151617181920212223#include&lt;stdio.h&gt; int main()&#123; int basis, add; scanf(\"%d %d\", &amp;basis, &amp;add); if (add &gt;= 0)//注意题干指明add可能为负的情况 &#123; int up = (basis % 100 + add) / 60; int min = (basis % 100 + add) % 60; int end = (basis / 100) * 100 + 100 * up + min; printf(\"%d\", end); &#125; else&#123; int down = (basis % 100 + add) / 60; int dmin = (basis % 100 + add) % 60; int end = (basis / 100) * 100 + 100 * down - 100 + 60 + dmin; // 对小时的操作 (basis / 100) * 100 + 100 * down - 100 , 多了个减100,即-20/60==0的情况 // 对分钟的操作 60 + dmin 限制在 0-60之内 printf(\"%d\", end); &#125; return 0;&#125;// 直接分两个情况讨论,更加直观 2.1 贪心专题 2.2 7-3 逆序的三位数 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main()&#123; int N; while( cin &gt;&gt; N )&#123; int a = N/100; int b= N/10%10; int c= N%10; if( c == 0)&#123; if( b==0)&#123; cout &lt;&lt; a; &#125;else&#123; cout &lt;&lt; a + b*10; &#125; &#125;else&#123; cout &lt;&lt; 100 * c +10*b + a; &#125; &#125; return 0;&#125; 2.3 DP训练 2.4 除夕过节 2.5 过年休息 2.6 字典序比较–&gt;贪心 快速幂 123456789101112long long Mode(long long a, long long b, long long mode)&#123; long long sum = 1; a = a % mode; while (b &gt; 0) &#123; if (b % 2 == 1) sum = (sum * a) % mode; // 判断是否是奇数，是奇数的话将多出来的数事先乘如sum b /= 2; a = (a * a) % mode;// 不断的两两合并再取模，减小a和b的规模 &#125; return sum;&#125; 当然有时候你可能会碰到用&amp;的运算符的代码实现，其实和这个大致相同，只不过是用&amp;操作符对b的奇偶性进行判断而已 补充:a=2 ,b=0 ,c=1 这种很简单的情况却会WA 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,c; int ans=1; while(scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c)!=EOF)&#123; //int ans = 1; if(b&gt;0)&#123; a=a%c; int h; h=b; while(h&gt;0) &#123; if(h%2==1) ans=(ans*a)%c; h=h/2; a=(a*a)%c; &#125;// if(b==0 &amp;&amp; c==1)// cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl; &#125; else if(b==0 &amp;&amp; c==1) cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; else if(b==0 &amp;&amp; c!=1) cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; &#125; return 0; &#125; &amp;的操作符： 二进制位中，1 &amp; 1 = 1，其余组合均为0 123456789101112long long Mode(long long a, long long b, long long mode)&#123; long long sum = 1; while (b) &#123; if (b &amp; 1) &#123; sum = (sum * a) % mode; b--; &#125; b /= 2; a = a * a % mode; &#125; return sum;&#125; 2.7 数据记录: 65536 2162^{16}216 4 294 967 296 2322^{32}232 unsigned int 0～4294967295 int -2147483648～2147483647 （10位） unsigned long 0～4294967295 long -2147483648～2147483647 long long的最大值 9223372036854775807 （19位） long long的最小值： -9223372036854775808 unsigned long long的最大值 1844674407370955161 __int64的最大值 9223372036854775807 __int64的最小值： -9223372036854775808 unsigned __int64的最大值 18446744073709551615 一个由C/C++编译的程序占用的内存分为以下几个部分 1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另 一块区域。 程序结束后由系统释放。 4、文字常量区 —常量字符串就 是放在这里的。 程序结束后由系统释放 5、程序代码区—存放函数体的二进制代码。 12345678910111213141516#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int c[20000][20000]; //在本人环境中全局数组能开到20000*20000int main()&#123; int b[1024*505]; int b2[700*700]; char a[4*518028]; int b1[500000]; //5*10^5 函数中的char数组最大能开4*518028，int最大能开到518028。 static int c[20000][20000]; //static能开到10^7*10^7。 注意 static和 全局开的是同一块空间 printf(\"1\");&#125;; 四舍五入,小数点位数 修改C++的输出流， 对小数会进行四舍五入 c++默认的流输出数值有效位是6，包括整数和小数，若数值超出6位，则第七位四舍五入到6位数 fixed ：浮点值显示为定点十进制。 默认是小数6位数，不包含整数，若小数位超出6位，则四舍五入到6位数 123456789101112131415161718192021222324252627282930#include &lt;iomanip&gt;// 需要引入这个头文件#include &lt;iostream&gt;using namespace std;int main()&#123; double PI = -3.14125001; cout &lt;&lt; setprecision(5); cout &lt;&lt; PI; return 0;&#125;// &gt;&gt;&gt; -3.1413int main()&#123; double PI = -3.14125001; cout&lt;&lt; setiosflags(ios::fixed); // ▲ cout &lt;&lt; setprecision(5); cout &lt;&lt; PI; return 0;&#125;// &gt;&gt;&gt; -3.14125/*拓展：如果与setiosnags(ios::scientific)合用， 可以控制指数表示法的小数位数。setiosflags(ios::scientific)是用指数方式表示实数。cout &lt;&lt; setiosflags(ios::scientific) &lt;&lt; setprecision(3);&gt;&gt;&gt; -3.141e+000*/ 1.setprecision(n)指定一个浮点数的精度默认设置输出的数字的总位数为n，包含整数和小数部分；其中setprecision（0）效果是跟c++默认的流输出数值一样，有效位是6位，包括整数和小数 2.fixed：必须与setprecision(n)配合使用，用来控制小数位数，不够补0，只要写一次fixed，后面的setprecision（n）就都是指小数了。 fixed与setprecision谁先谁后没有关系，但通常是fixed在前先固定6位小数（若此时小数已经超出6位，则先四舍五入到6位）再precision(n)取n位小数（n&lt;6） 3.如果与setiosnags(ios::scientific)合用， 可以控制指数表示法的小数位数。setiosflags(ios::scientific)是用指数方式表示实数。 4.resetiosflags(ios::fixed)取消精度的设置。 四舍五入进整 1234567#include &lt;iomanip&gt;int main()&#123; double PI = 3.51; cout &lt;&lt; setprecision(1); cout &lt;&lt; \"PI:\" &lt;&lt; PI; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://nymrli.top/tags/Algorithm/"},{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"12-27 Team Leader","slug":"12-27-Team-Leader","date":"2019-01-19T12:40:37.000Z","updated":"2019-09-15T08:07:30.906Z","comments":true,"path":"2019/01/19/12-27-Team-Leader/","link":"","permalink":"https://nymrli.top/2019/01/19/12-27-Team-Leader/","excerpt":"","text":"How Is An Excellent Team Leader A couple of days ago, my friend and I took part in a science and technology competition which was completed by a team of four. Usually, The person who can come up with the best idea is the caption, leading or so-called principal. For the reason, I was the principal of the team which consists of the same teammates last time. And this time, someone came up with a better idea, so the principal changed and not me. I’m not saying that changing is bad, or that I’m unsatisfied with it that I didn’t continue to play such an important role. At the beginning, everything is ok and everyone is full of fighting spirit. We have more than 30 days to finish this work, but actually the workload is only about 6 days at most. As a team that has completed several works together, we still keep the excellent habit of meeting and discussing regularly. Maybe it isn’t as important as the last one, or maybe the division is so clear that nothing has to be discussed always. Everyone has his work, and takes responsibility to his own job, so it seems very easy to solve the project. In fact, we spent lots of time laughing and talking together and fussing around trifles, instead of really discussing the problem. There was nothing wrong at that time. The problem occurred three days before the start of the evaluation. Everyone had finished his own work and waited to consolidate the modules and summarize all the work. This is a good proposal, but if fact, two people are debugging the code, while the other two people are working at their own job, can this be called discussion or teamwork? It’s natural to do with their own things if they have finished what they should do. However, what makes me angry is that we are both up to my ears in work while the others who are free feel nothing to do with himself. We hoped they could come to our aid, but they even didn’t understand what was wrong and not to mention what to do. To sum up, there was a communication problem which reflected in the form of failing to cope with work’s distribution. I have said just now that the division is very clear and easy. There were four people in the competition team, but the work was divided into three modules: SCM, machine learning, and Web services. So it’s enough for three people to do this and we felt easy and relaxed also. Nobody complained about there was somebody doing nothing. But maybe when it comes to the principal, the condition is different. First of all, as a team leader, he may be criticized if he doesn’t do anything. This is still a small matter. The most important thing is efficiency. What really pissed me off that night was that the summary didn’t end from 8:30 p.m. to 11:00 p.m., and the biggest reason was that no one knew exactly how to tackle it. And that lies about the principal. Although, he did a good job in the report which needs the structural diagram of the whole work and even designed the flow chart. The project needed supervision and urging, and he had completed it well. Every weekend, he tries to organize the gather everyone. Also, he gets on well with teammates and so on. It can be said he is basically qualified. However, I must pointed out that he is not a good leader by no means. First of all, he only did the things required by the competition, such as the system block diagram, but he did not manage the division of labor and summary of each of us in length. What’s more, he only organized and attended each discussion symbolically. He neither discussed the project with any purpose nor proposed any better suggestion. He organized the discussion formally for several times and seemed quite responsible. But that’s a waste of time, in my view, the biggest difference between a responsible person and no responsible person is reflected in the organization. A good organization can improve the efficiency, while a poor organization is just dispensable or even wasteful. It wasn’t as easy as I thought it would be that day. Eventually, it took us three more meetings before we actually assembled the work. During this period, I couldn’t bear to give suggestions to principal that You can do nothing, but you have to know our progress and what we are doing. ‘Of course,’ he replied. ‘that’s why I come to every discussion, just to get a sense of where you’re going,or I don’t have to come.’ I was speechless, for there seemed to be nothing wrong with it. The biggest conflict occurred the night before the game, when a module that had been available suddenly broke down. After several previous quarrels, it was difficult for me and principal to discuss together. But this is a very serious question, how to make decisions now. Do it the same as before? Or abandon all the previous modules to implement the worst solution? After I put forward the proposal of starting again as soon as possible, he finally led the people to carry out the worst plan. And this is without my knowledge. They followed worked on worst plan all afternoon, and all looked very frustrated. I realized that they didn’t follow my plan until they said they had a problem that was a little difficult to solve. I was so angry that I called them and asked them why they didn’t do what I said. They were vague, and I called them names because I thought they could do it if they did what I told them. So, I immediately met with them, it was raining, the atmosphere was very depressed, the leader did not speak, the other two players looked very depressed. At that time, I tried not to shout at the wrong leader. and first I stressed that we could definitely make it if we continued to do it. After inspiring for a while, everyone seemed quite motivated, so I immediately lead them to try in this direction. Fortunately, we solved the problem again in less than two hours. What I want to say is that all teams will confront with difficulties, and then there must be a strong and confident person to lead the team to a good direction, rather than thinking about how not to lose his face and take a not smart solution. Later, the principal reflected it was tight at that time, and we had some conflicts before, so he did not want to prove that he could not solve the problem. That’s the whole story, a very verbose story. I’m not talking about how good I am at what I do. I want to emphasize that as a good leader, one must think for the team and improve the efficiency of the team fundamentally, instead of wasting everyone’s time by being formalistic. And As a leader of a team it’s important that the first thing that comes to mind is how to solve the problem better, instead of escaping from the trouble. I just want to save my face and make a bad but not wrong decision. Last but not least, full of confidence and fighting spirit, can actively lead the team to success. If you do not believe in yourself, how can you let others believe in yourself. Further, the ideal leader, in addition to giving a good direction of effort, but also can help members solve the actual problems encountered, of course, this is difficult and just the ideal situation. Because it is difficult for anyone to understand all aspects, I dare to make such a decision this time, and I am confident that I can succeed in doing so, largely because I known about the modules which everyone should be responsible for. This is what I learned from this competition, what I understand the responsible leader should behave like.Thanks.","categories":[],"tags":[{"name":"English Speaking","slug":"English-Speaking","permalink":"https://nymrli.top/tags/English-Speaking/"},{"name":"生活小记","slug":"生活小记","permalink":"https://nymrli.top/tags/生活小记/"}]},{"title":"阿里云nginx+wsgi部署flask","slug":"阿里云nginx-wsgi部署flask","date":"2019-01-17T13:33:14.000Z","updated":"2019-10-23T11:46:35.930Z","comments":true,"path":"2019/01/17/阿里云nginx-wsgi部署flask/","link":"","permalink":"https://nymrli.top/2019/01/17/阿里云nginx-wsgi部署flask/","excerpt":"","text":"云服务器nginx+wsgi部署flask 更新源 12sudo apt-get update -ysudo apt-get upgrade -y 安装nginx 123sudo apt-get install nginx -ysudo /etc/init.d/nginx start #(start可以改成restart/stop)#或是sudo service nginx start 然后浏览器输入服务器IP或是127.0.0.1,观察是否有welcom to nginx! 安装py3和virtualenv 12sudo apt-get install git python3 python3-pip -ysudo pip3 install virtualenv 修改python版本: 法一:(不建议) 123456789$ gedit ~/.bashrc #gedit .bash_aliases在顶部加入一行alias python=python3$ source ~/.bashrc #或是source ~/.bash_aliases o$ python --version就会发现是Python 3.5.2啦/*orOpen your .bashrc file nano ~/.bashrc. Type alias python=python3 on to a new line at the top of the file then save the file with ctrl+o and close the file with ctrl+x. Then, back at your command line type source ~/.bashrc. Now your alias should be permanent.*/ Ubuntu16.04切换python3和python2 ▲.切换Python3为默认版本：(建议) 12sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 切换Python2为默认版本： 1$ sudo update-alternatives --config python 安装虚拟环境 virtualenv 123$ cd /var/www# 最好指定下python解释器$ sudo virtualenv -p /usr/bin/python3 env35 pipenv 1$ pipenv install MySQL 123456789$ sudo apt install mysql-server mysql-client -y$ cd /etc/mysql/mysql.conf.d$ mysql -p -u root&gt; password for root:&gt; use mysql;&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;&gt; flush privileges; 最后按Ctrl + z 退出 安装、测试uwsgi 1$ sudo pip3 install uwsgi 编辑/var/www下的uwsgi.ini 123456789101112[uwsgi]chdir=/home/apollo3d/Documents/Beidou wsgi-file=wsgi.pyhome=/home/apollo3d/Documents/envcallable=app; master=Trueprocesses=10socket= :81chmod socket=666vacuum=Truemax-requests=5000#pythonpath=/var/www/env 编辑/var/www下的nginx.conf 1234567891011121314server &#123; listen 80; server_name 127.0.0.1; charset utf-8; client_max_body_size 75M; location /static&#123; alias /home/apollo3d/Documents/Beidou/static; &#125;location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:81;# uwsgi_param UWSGI_PYHOME /home/apollo3d/Documents/Beidou/env; uwsgi_param UWSGI_SCRIPT app:app; # 启动flask的文件:Flask的实例&#125; 2004/10/20 | 编辑/var/www下的uwsgi_params 12345678910111213141516uwsgi_param QUERY_STRING $query_string;uwsgi_param REQUEST_METHOD $request_method;uwsgi_param CONTENT_TYPE $content_type;uwsgi_param CONTENT_LENGTH $content_length; uwsgi_param REQUEST_URI $request_uri; uwsgi_param PATH_INFO $document_uri; uwsgi_param DOCUMENT_ROOT $document_root; uwsgi_param SERVER_PROTOCOL $server_protocol; uwsgi_param REQUEST_SCHEME $scheme; uwsgi_param HTTPS $https if_not_empty; uwsgi_param REMOTE_ADDR $remote_addr; uwsgi_param REMOTE_PORT $remote_port; uwsgi_param SERVER_PORT $server_port; uwsgi_param SERVER_NAME $server_name; 软连接 1234$ rm /etc/nginx/sites-enabled/default$ cd /etc/nginx/sites-enabled$ sudo ln -s /var/www/nginx.conf Beidou$ ls 重启nginx sudo /etc/init.d/nginx restart 运行uwsgi 12cd /var/wwwuwsgi --ini uwsgi.ini 让uwsgi自启动 vim /etc/rc.local(注意非虚拟环境也得安装uwsgi模块) 123添加下面代码:/usr/local/bin/uwsgi --ini /var/www/uwsgi.iniexit 0 uwsgi的热启动 在uwsgi.ini中加入 py-autoreload=1 重启一下:killall -9 uwsgi、/usr/local/bin/uwsgi --ini /var/www/uwsgi.ini 总结 关于etc/ linit. d 如果你使用过inux系统,那么你一定听说过 init. d目录,这个目录到底是干嘛的呢?它归根结底只做了一件事情,但这件事情非同小可,是为整个系统做的,因此它非常重要。init.d目录包含许多系统各种服务的启动和停止脚本 关于 /etc/rc.local rc.local也是我经常使用的一个脚本,该脚本是在系统初始化级别脚本运行之后再执行的,因此可以安’, '地在里面添加你想在系统启动之后执行的脚本. 总结 Linux是灵活的,正因为它的灵活性,我们总是可以找到许多不同的办法来解决同一个问题，服务的例子就是一个很好的佐证,有了 /etc/init.d目录下的脚本,再加上 /etc/rc. local这个利器，你可以放心的确保你的服务可以完美的启动和运行 /etc/nginx/sites-available/default 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586### You should look at the following URL&apos;s in order to grasp a solid understanding# of Nginx configuration files in order to fully unleash the power of Nginx.# http://wiki.nginx.org/Pitfalls# http://wiki.nginx.org/QuickStart# http://wiki.nginx.org/Configuration## Generally, you will want to move this file somewhere, and start with a clean# file but keep this around for reference. Or just disable in sites-enabled.## Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.### Default server configuration#server &#123; listen 80 default_server; listen [::]:80 default_server; # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; # # Note: You should disable gzip for SSL traffic. # See: https://bugs.debian.org/773332 # # Read up on ssl_ciphers to ensure a secure configuration. # See: https://bugs.debian.org/765782 # # Self signed certs generated by the ssl-cert package # Don&apos;t use them in a production server! # # include snippets/snakeoil.conf; root /var/www/html; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html; server_name _; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; &#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # include snippets/fastcgi-php.conf; # # # With php7.0-cgi alone: # fastcgi_pass 127.0.0.1:9000; # # With php7.0-fpm: # fastcgi_pass unix:/run/php/php7.0-fpm.sock; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125;# Virtual Host configuration for example.com## You can move that to a different file under sites-available/ and symlink that# to sites-enabled/ to enable it.##server &#123;# listen 80;# listen [::]:80;## server_name example.com;## root /var/www/example.com;# index index.html;## location / &#123;# try_files $uri $uri/ =404;# &#125;#&#125;","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"}]},{"title":"前端Vue框架学习","slug":"前端Vue框架学习","date":"2019-01-17T12:47:22.000Z","updated":"2019-09-15T08:07:31.031Z","comments":true,"path":"2019/01/17/前端Vue框架学习/","link":"","permalink":"https://nymrli.top/2019/01/17/前端Vue框架学习/","excerpt":"","text":"前端Vue框架学习(未完) MVVM模型 使用Vue的初次操作 创建一个Vue实例 123456var c = new Vue(&#123; //初始化一个Vue对象 el: '#box', //对象,后面跟的是选择器 el(是element缩写 data : &#123; //数据成员,必须用关键字data msg:'welcome' &#125;&#125;) 完整的html页面 1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; window.onload=function (ev) &#123; new Vue(&#123; el: '#box', data:&#123; msg:'hello' &#125; &#125;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\"&gt; &#123;&#123;msg&#125;&#125; &lt;!--&lt;li&gt;&lt;/li&gt;--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 常用指令 v-model一般是放在表单中,实现了双向绑定 123456//如上初始化一个Vue实例&lt;div id='box'&gt; &lt;input type='text' v-model=\"msg\" &gt; //\"双向绑定\",修改输入框内容,msg内容也会改变 &lt;br&gt; &#123;&#123;msg&#125;&#125;&lt;/div&gt; v-repeat===&gt;v-for=&quot;变量名 in 数组&quot; 使用变量的话,使用索引 1234567/* data:&#123;msg:'hello',array:['he','bo','ce']&#125;*/&lt;li v-for=\"value in array\"&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt; v-on侦听用户事件 click mousedown dblclick mouseover mouseout 123456789101112131415161718window.onload=function () &#123; new Vue(&#123; el: '#box', data:&#123; msg:'hello', array:['he','bo','ce'] &#125;, methods :&#123; //注意是methods , 而不是method show:function () &#123; alert(1); &#125; &#125; &#125;) &#125; &lt;body&gt; &lt;input type=\"button\" value=\"按钮\" v-on:click=\"show()\"&gt; &lt;/body&gt; v-show=&quot;true&quot; Bootstrap + Vue Bootstrap 是个 css框架，类似jqueryMoblie一样,只需要给标签加class就行了 Bootstrap 需要 .css + .js ，由于依赖jqery,所以需要将jquery.js也导入","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"}]},{"title":"git基础知识","slug":"git使用","date":"2019-01-17T12:43:43.000Z","updated":"2019-12-23T13:59:44.740Z","comments":true,"path":"2019/01/17/git使用/","link":"","permalink":"https://nymrli.top/2019/01/17/git使用/","excerpt":"","text":"概念 工作区: 工作空间分为三个状态区: 工作区 暂存区 历史记录区 三个区域关系：工作区是我们能看到的区域，我们在工作区修改增加代码；完成编辑后，我们用git add 将工作区文件添加到暂存区；然后利用git commit 提交文件到我们自己的分支。 HEAD头指针: Head指向的是当前版本(最新的提交) 基础命令 123456$ git add 文件名# 将文件添加到暂存区中 (其中git add.可以将当前目录的子目录文件都添加到暂存区中)$ git status # 显示工作目录和暂存区的状态$ git diff ID1/ID2# 查看版本差异: 分支操作 1234567891011121314$ git branch # 分支一展表&gt;&gt;&gt; *(branch)显示当前分支$ git checkout -b 分支名 # 创建,且切换到新建分支 &lt;==等价于==&gt; git branch 分支名,git checkout 分支名$ git branch -d [分支名称] # 删除一个分支, -d选项只能删除已经参与过合并的分支，对于未参与合并的分支是无法删除的。# 如果想强制删除一个分支，可以使用-D选项$ git checkout 文件名 :切换分支 (git checkout - 为切换到上一个分支)$ git merge --no-f 分支名 : 合并分支$ git rebase -i # 压缩历史(如果出现拼写错误时需要): git rebase -i HEAD~2pick xxxx...pick xxxx... 只要将这个(出现拼写错误的那个提交ID前的pick改成fixup就行了) 远程仓库 123456789101112131415161718192021222324$ git remote add 远程仓库名 # 添加远程仓库$ git@github.com:用户名/git-tutorial.git $ git push -u 远程仓库名 本地分支名# 将本地分支推送到远程仓库中:$ git checkout -b 新仓库名 远仓库名/远程分支名$ git pull [远程仓库名] [本地分支名称] # 更新:拉取远程仓库代码,如果你远程只有一个分支,本地只有一个分支,后面中括号内容都可以省略$ git push [远程仓库名] [本地分支名称]# 推送代码到远程仓库$ git remote -v# 查看远程仓库$ git remote rm [远程仓库名]# 清除远程代码仓库:$ git push origin 本地分支名:master # 提交本地分支提交到远程的master分支$ git push origin :heads/[分支名称] 或 $ git push origin :[分支名称] # 删除远程分支$ git branch -r# 查看远程git服务器上的分支: $ git fetch origin# 获取远端库最新信息$ git diff master origin/master# 查看本地与远程服务端的不同 删除远程分支git push origin --delete kickof git status 命令 表示 查看仓库当前状态； git diff 命令 表示 查看修改内容； git push代码到远程新分支 git push origin master:my_remote_new_branch remote: You are not allowed to push code to this project. fatal: unable to access ‘http://lyl233.f3322.net:11111/apollo/Apollo_Open_Resources.git/’: The requested URL returned error: 403 git remote set-url origin http://lyl233.f3322.net:11111/Chenli/Apollo_Open_Resources.git 日志 1234$ git log# 提交日志(当前状态为终点) 会产生版本库里一系列单独提交的历史$ git log -p README.md$ git log -graph 撤销操作 撤销文件提交到暂存区 1$ git rm 文件名 撤销上一次提交(commit),并重新提交 修改提交信息 12$ git commit --amend# 可以重新修改提交信息,也可以不修改 ▲.将暂存区内的文件代替工作区的(工作区内的文件复原) 1git checkout -- . ▲.将将最近一次版本库文件代替暂存区的(暂存区内的文件复原) 1234git reset HEAD .# 将暂存区拉回工作区git checkout -- .# 将工作区复原 从云服务器更新文件到仓库 1.查看git 版本(是否安装,一般都是默认安装好了的) 2.设置github账号密码: 12$ git config --global user.email \"you@example.com\"$ git config --global user.name \"Your Name\" 3.设置上传方式 1git config --global push.default simple matching（匹配所有分支） matching 参数是 Git 1.x 的默认参数，也就是老的执行方式。其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。 simple（匹配单个分支) simple参数是 Git 2.x 默认参数，意思是执行 git push 没有指定分支时，只有当前分支会被 push 到远程仓库。 4.上传需要上传的文件 1234#git init 如果没有初始化仓库的话....(更新的话就不需要git add . git commit -m \"xxx\"git push 修改.gitignore生效指令 123git rm -r --cached . // 删除本地缓存git add . // 添加要提交的文件git commit -m &apos;update .gitignore&apos; // 更新本地的缓存 附录: Git远程操作详解 使用git将项目上传到github（最简单方法）","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://nymrli.top/tags/git/"}]},{"title":"数据结构实验1——线性表及多项式的运算","slug":"数据结构实验1——线性表及多项式的运算","date":"2018-12-28T11:42:11.000Z","updated":"2019-09-15T08:07:31.069Z","comments":true,"path":"2018/12/28/数据结构实验1——线性表及多项式的运算/","link":"","permalink":"https://nymrli.top/2018/12/28/数据结构实验1——线性表及多项式的运算/","excerpt":"","text":"链表操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int Status;typedef int ElemType;typedef struct Node&#123; ElemType elem; struct Node *link;&#125;Node;typedef struct &#123; struct Node* first; int n;&#125;SingleList;SingleList list; //声明全局的Status Init(SingleList *L)&#123; L-&gt;first = NULL; L-&gt;n = 0; return OK;&#125;Status Find(SingleList L,int i,ElemType *x)&#123; Node *p; int j; if (i&lt;0 || i&gt; L.n-1) return ERROR; p = L.first; for (j = 0; j &lt; i; ++i) p=p-&gt;link; *x = p-&gt;elem; return OK;&#125;Status Insert(SingleList *L,int j,ElemType x)&#123; Node *p,*q; int i; if(j&lt;-1 || j&gt; L-&gt;n) return ERROR; p = L-&gt;first; for(i=0;i&lt;j;i++) p=p-&gt;link; //p==&gt;a(i-1) q = (Node *)malloc(sizeof(Node)); q-&gt;elem = x; if (j&gt;-1) &#123; q-&gt;link = p-&gt;link; // a(i-1)==&gt;??? ===&gt; a(i)-&gt;??? p-&gt;link = q ; // a(i-1)-&gt;a(i) &#125;else &#123; q-&gt;link = L-&gt;first; L-&gt;first = q; &#125; L-&gt;n++; return OK;&#125;Status Delete(SingleList *L,int j)&#123; int i; Node *p,*q; if(!L-&gt;n) return ERROR; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; q = L-&gt;first; p = L-&gt;first; for(i=0;i&lt;j-1;i++) q = q-&gt;link; //q指向 a(i-1) if (i==0) L-&gt;first = L-&gt;first-&gt;link; else&#123; p = q-&gt;link; //此时p指向a(i) q-&gt;link = p-&gt;link; //将q指向a(a+1) &#125; free(p); L-&gt;n -- ; return OK;&#125;Status Output(SingleList L)&#123; Node *p; if(!L.n) return ERROR; p = L.first; while(p)&#123; printf(\"%d \",p-&gt;elem ); p = p-&gt;link; &#125; return OK;&#125;void Destory(SingleList *L)&#123; Node *p; while(L-&gt;first)&#123; p = L-&gt;first-&gt;link; //保存后继节点地址,防止断链 free(L-&gt;first); //释放first节点所指节点的存储空间 从前往后释放 L-&gt;first = p; &#125; &#125;int main()&#123; int i,x; Init(&amp;list); for (i = 0; i &lt; 9; ++i) Insert(&amp;list,i-1,i); printf(\"the linked list is :\"); Output(list); Delete(&amp;list,1); printf(\"\\nafter deleting the list is:\"); Output(list); Find(list,0,&amp;x); printf(\"\\nthe value is %d\\n\",x ); Destory(&amp;list); system(\"pause\"); return 0;&#125; 带表头节点的单链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct Node&#123; ElemType elem; struct Node *link;&#125;Node;typedef struct &#123; struct Node* head; int n;&#125;Headlist;Status Init(Headlist *L)&#123; L-&gt;head = (Node*)malloc(sizeof(Node)); if(!L-&gt;head) return ERROR; L-&gt;head-&gt;link = NULL; //注意到这边没有对L-&gt;head-&gt;element作设置,因为不会用到 L-&gt;n = 0; return OK;&#125;Status Sort(Headlist *L)&#123; Node *p=L-&gt;head,*pre=NULL; Node *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;elem &lt; p-&gt;elem) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125; return OK;&#125;Status deleleab(Headlist *L, int a,int b)&#123; Node *q = L-&gt;head,*p=L-&gt;head-&gt;link; // q为上一个,p为当前的 while( p ) if(p-&gt;elem &gt;= a &amp;&amp; p-&gt;elem &lt;= b) &#123; q-&gt;link = p-&gt;link; // 1 - 2 - 3 1==&gt;3,1的指针域指向3 free(p); //释放2 p = q-&gt;link; // 当前的指针变成3 &#125;else&#123; p = p-&gt;link; q = p-&gt;link; &#125; return OK; &#125;/*****思路为: 将顺序遍历的结点不断插入为L-&gt;head-&gt;link******/Status Converse(Headlist *L)&#123; Node *p = NULL,*cur= NULL; Node *q = L-&gt;head-&gt;link; if(L-&gt;head &amp;&amp; L-&gt;head-&gt;link)&#123; //如果表不存在或是为空,则return ERROR while( q != NULL ) //q按照原来的顺序依次遍历各结点 &#123; cur = q; //cur为当前结点 q = q-&gt;link; //q保存下一个结点 L-&gt;head-&gt;link = cur; //为了不动头结点,所以头结点link始终指向当前要加的结点 cur-&gt;link = p; //当前的link指向上一个结点 p = cur; //保存上一个结点 &#125; &#125;else return ERROR; return OK;&#125;Status Insert(Headlist *L,int j,ElemType x)&#123; int i; Node *p=NULL,*q=NULL; if(j&lt;-1 || j&gt; L-&gt; n-1) return ERROR; p = L-&gt;head; for(i=0;i&lt;=j;i++) p=p-&gt;link; // 与普通链表不同,这边是 &lt;= , 因为要多一个表头Node q = (Node *)malloc(sizeof(Node)); q-&gt;elem = x; q-&gt;link = p-&gt;link; p-&gt;link = q; L-&gt;n++; return OK;&#125;Status Output(Headlist L)&#123; Node *p = L.head-&gt;link; if(!L.n) return ERROR; while(p)&#123; printf(\"%d \",p-&gt;elem ); p = p-&gt;link; &#125; return OK;&#125;Status Destory(Headlist *L)&#123; Node *p=NULL; while(L-&gt;head)&#123; p = L-&gt;head-&gt;link; free(L-&gt;head); L-&gt;head = p; &#125; return OK; &#125;Status Delete(Headlist *L,int j)&#123; //下标j Node *p = L-&gt;head,*q = L-&gt;head; // q = tmp int i; if(!L-&gt;n) return ERROR; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j-1;i++) p = p-&gt;link; q = p; p = p-&gt;link; q-&gt;link = p-&gt;link; free(p); return OK;&#125;Status Find(Headlist *L,int j,ElemType *x)&#123; Node *p= L-&gt;head; int i; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j;i++) p = p-&gt;link; *x = p-&gt;elem; return OK;&#125;int main()&#123; int x; Headlist list; Init(&amp;list); Insert(&amp;list,-1,3); Insert(&amp;list,0,2); Insert(&amp;list,-1,5); Insert(&amp;list,2,7); Insert(&amp;list,-1,1); printf(\"the linked list is :\"); Output(list); printf(\"\\nAfter sorted:\"); Sort(&amp;list); Output(list); printf(\"\\nAfter Conversed:\"); Converse(&amp;list); Output(list); printf(\"\\nAfter delete index of 0,the list is:\"); Delete(&amp;list,0); Output(list); Find(&amp;list,2,&amp;x); printf(\"\\nthe index of 2:%d\\n\",x); Destory(&amp;list); system(\"pause\"); return 0;&#125; 带表头的链表和普通链表的区别在于: 带表头链表的头结点的数据域是不设置的,真正有用的结点是L-&gt;head-&gt;link指向的结点.而普通链表L-&gt;first指向的结点 这样的好处是不用特殊考虑是不是头结点. 代码实现细节: 1.插入的i,是aia_{i}ai​后面再添加一项,所以for条件为j=0;j&lt;i 进行j次link 2.删除时,删除的是aia_{i}ai​,for(j=0;j &lt; i - 1;j++),为什么是 i-1跟代码实现有关,先把q指向要删除的前一个结点,p=q-&gt;link,q-&gt;link = p-&gt;link从而将p即aia_{i}ai​孤立出来 ▲带表头的话,将&lt;变为&lt;=,因为要多推个link,跳过head结点 设计上最大的区别在于 ▲多了个表头以后,就不用再考虑,删除和插入的时候去动List-&gt;first指针，带表头后，修改的都是L-&gt;head-&gt;link之后的结点Node 单链表实现多项式加减、相乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct PNode&#123; ElemType ceof; ElemType exp; struct PNode *link;&#125;PNode;typedef struct &#123; struct PNode *head;&#125;polynominal;Status Init(polynominal *p)&#123; p-&gt;head = (PNode *)malloc(sizeof(PNode)); p-&gt;head-&gt;exp = -1; p-&gt;head-&gt;link = NULL; return OK;&#125;Status Create(polynominal *p)&#123; PNode *pn = NULL,*q=NULL,*pre=NULL; p-&gt;head = (PNode *)malloc(sizeof(PNode)); p-&gt;head-&gt;exp = -1; p-&gt;head-&gt;link = NULL; for (;;) &#123; pn = (PNode *)malloc(sizeof(PNode)); printf(\"ceof:\\n\"); scanf(\"%d\",&amp;pn-&gt;ceof); printf(\"exp:\\n\"); scanf(\"%d\",&amp;pn-&gt;exp); if (pn-&gt;exp &lt; 0) &#123;printf(\"End the input\\n\"); break;&#125; pre = p-&gt;head; //pre从链表头开始 q=p-&gt;head-&gt;link; while(q &amp;&amp; q-&gt;exp &gt; pn-&gt;exp)&#123; //pn为当前结点,q为链表中结点 pre = q; // q = q-&gt;link; &#125; pn-&gt;link = q; // 在pre和q之间插入pn,(q为null时,相当于末尾插入pn) pre-&gt;link = pn; // pre =&gt; pn =&gt; q &#125; return OK;&#125;Status Sort(polynominal *L)&#123; //从大到小 PNode *p=L-&gt;head,*pre=NULL; PNode *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;exp &lt; p-&gt;exp) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125; return OK;&#125;Status Add(polynominal *px,polynominal *qx)&#123; //目的:将q改成p+q PNode *q1=qx-&gt;head, *p=px-&gt;head-&gt;link; //q1指向qx表头结点 PNode *q=q1-&gt;link; //p指向多项式px第一个结点,q指向qx第一个 PNode *temp = NULL; //q1是q前驱 while( q &amp;&amp; p)&#123; while( p-&gt;exp &lt; q-&gt;exp )&#123; //找到qx中 大于等于q指数项的项,q不断右移 q1 = q; q = q-&gt;link; &#125; if (p-&gt;exp == q-&gt;exp )&#123; q-&gt;ceof = q-&gt;ceof + p-&gt;ceof; if (q-&gt;ceof == 0)&#123; q1-&gt;link = q-&gt;link; //释放当前q的内存 free(q); q = q1-&gt;link; p = p-&gt;link; &#125;else&#123; //p\\q都右移 q1 = q; //q1 q = q-&gt;link; p = p-&gt;link; &#125; &#125;else&#123; //p-&gt;exp &gt; q-&gt;exp temp = (PNode * )malloc(sizeof(PNode)); temp-&gt;ceof = p-&gt;ceof; temp-&gt;exp = p-&gt;exp; temp-&gt;link = q1-&gt;link; q1-&gt;link = temp; p = p-&gt;link; &#125; &#125; return OK;&#125;void Output(polynominal *p)&#123; PNode *q = p-&gt;head-&gt;link; int last = 0; while( q!=NULL )&#123; if(q-&gt;link == NULL) last =1; printf(\"%dx^%d\", q-&gt;ceof,q-&gt;exp); if(!last) printf(\"+\"); q = q-&gt;link; &#125; printf(\"\\n\");&#125;void Destory(polynominal *p)&#123; PNode *q = NULL; while(p-&gt;head)&#123; q = p-&gt;head-&gt;link; free(p-&gt;head); p-&gt;head = q; &#125;&#125;/***********合并同类项*****************//***********合并即free*****************/Status unify(polynominal *t)&#123; PNode *p=NULL; PNode *q=NULL; PNode *last=NULL; PNode *tmp; //while(p-&gt;link != NULL)&#123; for(p=t-&gt;head-&gt;link;p!=NULL;p=p-&gt;link)&#123; //选择 last = p; for(q=last-&gt;link; q!=NULL ; )&#123; //q指针向后推移指向下一结点 if(q-&gt;exp == p-&gt;exp)&#123; //相等计算 p-&gt;ceof += q-&gt;ceof; //q为 滑动项 tmp = q-&gt;link; last-&gt;link = q-&gt;link; //last保存上一个q free(q); // 吧q的空间释放掉 q= tmp; &#125;else&#123; last= q; q=q-&gt;link;&#125; //如果不相等就判断下一个 &#125; &#125; return OK;&#125;polynominal Multiply(polynominal *px,polynominal *qx)&#123; PNode *p = px-&gt;head; PNode *q = qx-&gt;head; PNode *x = NULL; PNode *tmp = NULL; polynominal newpoly; Init(&amp;newpoly); x = newpoly.head; for (p=px-&gt;head-&gt;link; p!=NULL; p=p-&gt;link)&#123; for (q=qx-&gt;head-&gt;link; q!=NULL; q=q-&gt;link)&#123; tmp = (PNode*)malloc(sizeof(PNode)); tmp-&gt;ceof = p-&gt;ceof * q-&gt;ceof; tmp-&gt;exp = p-&gt;exp + q-&gt;exp; tmp-&gt;link = x-&gt;link; //新生成的结点指向上一个生成的结点的地址 x-&gt;link = tmp; //使链表记录当前tmp结点 x = x-&gt;link; //取下一个结点 &#125; &#125; unify(&amp;newpoly); Sort(&amp;newpoly); return newpoly;&#125;int main()&#123; polynominal p,q; polynominal mul; Create(&amp;p); Output(&amp;p); // printf(\"After unify:\\n\"); Unify // unify(&amp;p); // Output(p); Create(&amp;q); Output(&amp;q); printf(\"After Multiplied:\\n\"); //Mul mul = Multiply(&amp;p,&amp;q); Output(&amp;mul); Add(&amp;p,&amp;q); //ADD printf(\"After added:\"); Output(&amp;q); printf(\"\\n\"); system(\"pause\"); return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"数据结构实验2——二叉树的基本操作及哈夫曼编码译码系统的实现","slug":"数据结构实验2——二叉树的基本操作及哈夫曼编码译码系统的实现","date":"2018-12-28T11:35:38.000Z","updated":"2019-09-15T08:07:31.070Z","comments":true,"path":"2018/12/28/数据结构实验2——二叉树的基本操作及哈夫曼编码译码系统的实现/","link":"","permalink":"https://nymrli.top/2018/12/28/数据结构实验2——二叉树的基本操作及哈夫曼编码译码系统的实现/","excerpt":"","text":"二叉树的遍历及计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int T;typedef struct BTNode&#123; T Data; struct BTNode *LChild,*RChild;&#125;BTNode;typedef struct BTTree&#123; BTNode *root;&#125;BTTree;/*先序建树*/BTNode* PreCreateBt(BTNode *t)&#123; char ch; ch = getchar(); if( ch == '#' ) t = NULL; else&#123; t = (BTNode *)malloc(sizeof(BTNode)); t-&gt;Data = ch; t-&gt;LChild = PreCreateBt(t-&gt;LChild); t-&gt;RChild = PreCreateBt(t-&gt;RChild); &#125; return t;&#125;void PrebuildTree(BTTree *tree)&#123; tree-&gt;root = PreCreateBt(tree-&gt;root);&#125;/*先序遍历*/void PreOrderTransverse(BTNode *t)&#123; if(t == NULL) return ; printf(\"%c\", t-&gt;Data); PreOrderTransverse(t-&gt;LChild); PreOrderTransverse(t-&gt;RChild);&#125;void TreePreOrder(BTTree *tree)&#123; if(tree) PreOrderTransverse(tree-&gt;root);&#125;/*中序遍历*/void InOrderTransverse(BTNode *t)&#123; if(t == NULL) return ; InOrderTransverse(t-&gt;LChild); printf(\"%c\", t-&gt;Data); InOrderTransverse(t-&gt;RChild);&#125;void TreeInOrder(BTTree *tree)&#123; if(tree) InOrderTransverse(tree-&gt;root);&#125;/*后序遍历*/void AfterOrderTransverse(BTNode *t)&#123; if(t == NULL) return ; AfterOrderTransverse(t-&gt;LChild); AfterOrderTransverse(t-&gt;RChild); printf(\"%c\", t-&gt;Data);&#125;void TreeAfterOrder(BTTree *tree)&#123; if(tree) AfterOrderTransverse(tree-&gt;root);&#125;/*结点数目*/int countNode(BTNode *t)&#123; if( t != NULL) return countNode(t-&gt;LChild)+countNode(t-&gt;RChild)+1; else return 0; //如果t为空,则该t的父亲结点是子结点,该t结点不需要计数&#125;int Nodenum(BTTree *tree)&#123; if(tree) return countNode(tree-&gt;root); else return -1;&#125;/*叶子结点数目*/int countLeafNode(BTNode *t)&#123; if( t != NULL)&#123; if( t-&gt;LChild == NULL &amp;&amp; t-&gt;RChild == NULL) return 1; else return countLeafNode(t-&gt;LChild)+countLeafNode(t-&gt;RChild); &#125; else return 0; //如果t为空,则该t的父亲结点是子结点,该t结点不需要计数&#125;int leafNodenum(BTTree *tree)&#123; if(tree) return countLeafNode(tree-&gt;root); else return -1;&#125;/*计算树的高度*/int coutTreeHeight(BTNode *t)&#123; if(t == NULL) return 0; else &#123; int l = coutTreeHeight(t-&gt;LChild); int r = coutTreeHeight(t-&gt;RChild); if ( l &gt; r) return l+1; else return r+1; // return max(r,l)+1; &#125;&#125;int TreeHeight(BTTree *tree)&#123; if(tree) return coutTreeHeight(tree-&gt;root); else return -1;&#125;/*翻转整个二叉树(左右子树交换)*/BTNode* ReverseLeftRightChild(BTNode *t)&#123; //先序遍历 if(t!=NULL)&#123; if( t-&gt;LChild!=NULL || t-&gt;RChild!=NULL)&#123; BTNode *p,*q; p = ReverseLeftRightChild(t-&gt;LChild); q = ReverseLeftRightChild(t-&gt;RChild); t-&gt;LChild = q; t-&gt;RChild = p; &#125;&#125;return t;&#125;void ReverseBtree(BTTree *tree)&#123; if(tree) ReverseLeftRightChild(tree-&gt;root);&#125;int main(int argc, char const *argv[])&#123; BTTree tree; printf(\"先序建树:\"); PrebuildTree(&amp;tree); printf(\"\\n先序遍历:\"); TreePreOrder(&amp;tree); printf(\"\\n中序遍历:\"); TreeInOrder(&amp;tree); printf(\"\\n后序遍历:\"); TreeAfterOrder(&amp;tree); printf(\"\\n结点数目:%d\\n\",Nodenum(&amp;tree)); printf(\"\\n叶子结点数目:%d\\n\",leafNodenum(&amp;tree)); printf(\"\\n树的高度:%d\\n\",TreeHeight(&amp;tree)); printf(\"翻转二叉树:\\n\"); ReverseBtree(&amp;tree); printf(\"\\n后序遍历:\"); TreeAfterOrder(&amp;tree); printf(\"\\n\"); return 0;&#125; 哈夫曼树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;stdio.h&gt;#define n 5 //叶子数目#define m (2*n-1) //结点总数#define maxval 10000.0#define maxsize 100 //哈夫曼编码的最大位数typedef struct&#123; char ch; float weight; int lchild,rchild,parent;&#125;hufmtree;typedef struct&#123; char bits[n]; //位串 int start; //编码在位串中的起始位置 char ch; //字符&#125;codetype;//建立哈夫曼树void huffman(hufmtree tree[])&#123; int i,j,p1,p2;//p1,p2分别记住每次合并时 权值最小 和 次小 的两个根结点的下标 float small1,small2,f; char c; for(i=0;i&lt;m;i++)&#123; //初始化 tree[i].parent=0; tree[i].lchild=-1; tree[i].rchild=-1; tree[i].weight=0.0; &#125; for(i=0;i&lt;n;i++)&#123; //读入前n个叶子结点的字符及权值 printf(\"输入第%d个字符为和权值:\",i+1); scanf(\"%c %f\",&amp;c,&amp;f); getchar(); tree[i].ch=c; tree[i].weight=f; &#125; for(i=n;i&lt;m;i++)&#123; //进行n-1次合并，产生n-1个新结点 p1=0;p2=0; small1=maxval;small2=maxval; //maxval是float类型的最大值 for(j=0;j&lt;i;j++) //选出两个权值最小的根结点 if(tree[j].parent==0) if(tree[j].weight&lt;small1)&#123; small2=small1; //改变最小权、次小权及对应的位置 small1=tree[j].weight; p2=p1; p1=j; &#125;else if(tree[j].weight&lt;small2)&#123; small2=tree[j].weight; //改变次小权及位置 p2=j; &#125; tree[p1].parent=i; tree[p2].parent=i; tree[i].lchild=p1; //最小权根结点是新结点的左孩子 tree[i].rchild=p2; //次小权根结点是新结点的右孩子 tree[i].weight=tree[p1].weight+tree[p2].weight; &#125;&#125;//huffman//根据哈夫曼树求出哈夫曼编码//codetype code[]为求出的哈夫曼编码//hufmtree tree[]为已知的哈夫曼树void huffmancode(codetype code[],hufmtree tree[])&#123; int i,c,p; codetype cd; //缓冲变量 for(i=0;i&lt;n;i++)&#123; cd.start=n; cd.ch=tree[i].ch; c=i; //从叶结点出发向上回溯 p=tree[i].parent; //tree[p]是tree[i]的双亲 while(p!=0)&#123; cd.start--; if(tree[p].lchild==c) cd.bits[cd.start]='0'; //tree[i]是左子树，生成代码'0' else cd.bits[cd.start]='1'; //tree[i]是右子树，生成代码'1' c=p; p=tree[p].parent; &#125; code[i]=cd; //第i+1个字符的编码存入code[i] &#125;&#125;//huffmancode//哈夫曼树译码void decode(hufmtree tree[])&#123; int i,j; char b[maxsize]; i=m-1; //从根结点开始往下搜索 printf(\"输入发送的编码(以'#'为结束标志)：\"); gets(b); printf(\"译码后的字符为\"); for(j=0;b[j]!='#';j++)&#123; if(b[j]=='0') i=tree[i].lchild; //走向左孩子 else i=tree[i].rchild; //走向右孩子 if(tree[i].lchild==-1) &#123; //tree[i]是叶结点 printf(\"%c\",tree[i].ch); i=m-1; //回到根结点 &#125; &#125; if(tree[i].lchild!=-1 &amp;&amp; b[j]!= '#') //电文读完，但尚未到叶子结点 printf(\"\\nERROR\\n\"); //输入电文有错&#125;void input(hufmtree tree[],codetype code[])&#123; int i,j;//循环变量 printf(\"【哈夫曼编码】\\n\"); printf(\"总共有%d个字符\\n\",n); huffman(tree);//建立哈夫曼树 huffmancode(code,tree);//根据哈夫曼树求出哈夫曼编码 printf(\"【输出每个字符的哈夫曼编码】\\n\"); for(i=0;i&lt;n;i++)&#123; printf(\"%c: \",code[i].ch); for(j=code[i].start;j&lt;n;j++) printf(\"%c\",code[i].bits[j]); printf(\"\\n\"); &#125;&#125;int main()&#123; hufmtree tree[m]; codetype code[n]; input(tree,code); printf(\"【哈夫曼译码】\\n\"); decode(tree);//依次读入电文，根据哈夫曼树译码 return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"数据结构实验4——各种内排序算法的实现及性能比较","slug":"数据结构实验4——各种内排序算法的实现及性能比较","date":"2018-12-28T11:20:19.000Z","updated":"2020-04-28T01:23:17.333Z","comments":true,"path":"2018/12/28/数据结构实验4——各种内排序算法的实现及性能比较/","link":"","permalink":"https://nymrli.top/2018/12/28/数据结构实验4——各种内排序算法的实现及性能比较/","excerpt":"","text":"部分代码 辅助函数 1234567891011121314/**生成随机数**/void RandCreate(int *a)&#123; int i; for ( i = 0; i &lt; N; ++i) a[i] = 1 + (rand()%1000);&#125;/***交换数组中,两个下标的值***/void Swap(int *a,int i,int j)&#123; int tmp; tmp = a[i]; a[i] = a[j]; a[j] = tmp;&#125; 简单选择排序 123456789/**简单选择排序**/void SelectSort(int *l)&#123; int minx,i,j; for (i= 0; i &lt; N-1; ++i)&#123; minx = i; //默认标记为每次第一位元素下标 for (j = i+1; j &lt; N; ++j) if( l[minx] &gt; l[j] ) minx = j; if( minx != i) Swap(l,minx,i); //判断起始位置是否为最小值 &#125;&#125; 直接插入排序 12345678910111213/**直接插入排序**/void InsertSort(int *l)&#123; int i,j; //i标识待插入元素下标 for(i = 1;i &lt; N;i ++)&#123; int insertItem = l[i]; //标记每次第一位元素 for(j = i-1;j &gt;= 0;j --)&#123; //不断将有序序列中元素向后移动,为待插入元素空出一个位置 if(insertItem &lt; l[j]) l[j+1] = l[j]; else break; &#125; l[j+1] = insertItem; //待插入元素有序存放至有序序列中 &#125;&#125; 冒泡排序 12345678910111213141516//冒泡排序void BubbleSort(int *l)&#123; int i,j; //i标识每趟排序范围最后一个元素下标,每趟排序元素下标范围是0~i for(i = N-1;i &gt; 0;i --)&#123; int isSwap = 0; //教材错误,应该放到第二层循环前 for(j = 0; j&lt;i;j ++)&#123; if(l[j] &gt; l[j+1])&#123; Swap(l,j,j+1); isSwap = 1; &#125; &#125; if(!isSwap) break; //如果本趟排序没有发生元素交换,则直接可以认为排序已完成 &#125;&#125; 快速排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;void quickSort(int a[], int m,int n);int partion(int a[], int m, int n);int main()&#123; int a[] = &#123; 6,1,2,7,9,3,4,5,10,8 &#125;; int m = 0; int n = (sizeof(a) / 4)-1; quickSort(a, m,n); for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125;&#125;void quickSort(int a[], int m, int n)&#123; if (m &lt; n) &#123; int q = partion(a, m, n); quickSort(a, m, q ); quickSort(a, q + 1, n); &#125;&#125;int partion(int a[], int m, int n)&#123; int key=m; // m为左, n为右边界 int j= n,i=m; int temp1, temp2; while (i != j) &#123; while (a[j] &gt; a[key] &amp;&amp; i &lt; j) &#123; --j; &#125; while ((a[i] &lt; a[key]) &amp;&amp; (i &lt; j)) &#123; ++i; &#125;if (i &lt; j) &#123; temp1 = a[j]; a[j] = a[i]; a[i] = temp1; &#125; &#125; temp2 = a[key]; a[key] = a[i]; a[i] = temp2; return i;&#125; 两路合并排序 123456789101112131415161718192021222324252627282930313233343536373839//Merge函数,参考了陈慧南老师的《数据结构——C语言描述》教材void Merge(int *l,int Temp[],int i1,int j1,int i2,int j2,int *k)&#123; int i = i1,j = i2; while((i &lt;= j1)&amp;&amp;(j&lt;=j2))&#123; //若两个子序列都不空,则循环 if(l[i] &lt;= l[j])&#123; Temp[(*k)++] = l[i++]; //将较小元素存入Temp[*k] &#125; else Temp[(*k)++] = l[j++]; &#125; while(i &lt;= j1) Temp[(*k)++] = l[i++]; //将子序列1中剩余元素存入Temp while(j &lt;= j2) Temp[(*k)++] = l[j++]; //将子序列2中剩余元素存入Temp&#125;//MergeSort函数void MergeSort(int *l)&#123; int Temp[N]; int i1,j1,i2,j2,i,k,size = 1; //i1,j1和i2,j2分别是两个子序列的上,下界 while(size &lt; N)&#123; i1 = 0; k = 0; while(i1+size &lt; N)&#123; //若i1+size &lt; n,则说明存在两个子序列,需要再两两合并 i2 = i1+size; //确定子序列2的下界和子序列1的上界 j1 = i2-1; if(i2+size-1 &gt; N-1)&#123; //设置子序列2的上界 j2 = N-1; &#125; else j2 = i2+size-1; Merge(l,Temp,i1,j1,i2,j2,&amp;k); //合并相邻两个子序列 i1 = j2+1; //确定下一次合并第一个子序列的下界 &#125; for(i = 0;i &lt; k;i ++)&#123; l[i] = Temp[i]; &#125; size *= 2; //子序列长度扩大一倍 &#125;&#125; 堆排序 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct heap&#123; int n; int *data;&#125;heap;/**向下调整为最大堆**/void AdjustHeap(int Heap[],int s,int m)&#123; int temp = Heap[s]; for(int j = 2*s+1;j &lt;= m; j *= 2)&#123; if(j &lt; m &amp;&amp;Heap[j] &lt; Heap[j+1]) j++; if(temp &gt; Heap[j]) break; Heap[s] = Heap[j]; s = j; &#125; Heap[s] = temp;&#125;/**建堆**/void CreateHeap(int *heap,int n)&#123; int i; for(i = (n-2)/2;i &gt;= 0;i --) AdjustHeap(heap,i,n);&#125;/**堆初始化**/void heapInit(heap *hp,int *a,int n)&#123; hp-&gt;n = n; hp-&gt;data = (int *)malloc( sizeof(int) *n); int i; for( i = 0;i &lt; n;i ++) hp-&gt;data[i] = a[i]; CreateHeap(hp-&gt;data ,N-1);&#125;/**堆排序**/void HeapSort(heap *hp)&#123; int i; for( i=hp-&gt;n/2 ; i&gt;0 ;i--) AdjustHeap(hp-&gt;data,i,hp-&gt;n); for( i = hp-&gt; n-1 ;i&gt;0;i--)&#123; Swap( hp-&gt;data,0,i); AdjustHeap(hp-&gt;data,0,i-1); &#125;&#125; ▲向下调整法====&gt; 建堆 … 给一堆数据,一次性建堆 ▲向上调整法====&gt; 在已经是最小或最大堆的基础上,增加一个节点,仍保持为最大或最小堆 总体代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define N 100000void RandCreate(int *a)&#123; int i; for ( i = 0; i &lt; N; ++i) a[i] = 1 + (rand()%1000);&#125;/***交换数组中,两个下标的值***/void Swap(int *a,int i,int j)&#123; int tmp; tmp = a[i]; a[i] = a[j]; a[j] = tmp;&#125;/**简单选择排序**/void SelectSort(int *l)&#123; int minx,i,j; for (i= 0; i &lt; N-1; ++i)&#123; minx = i; //默认标记为每次第一位元素下标 for (j = i+1; j &lt; N; ++j) if( l[minx] &gt; l[j] ) minx = j; if( minx != i) Swap(l,minx,i); //判断起始位置是否为最小值 &#125;&#125;/**直接插入排序**/void InsertSort(int *l)&#123; int i,j; //i标识待插入元素下标 for(i = 1;i &lt; N;i ++)&#123; int insertItem = l[i]; //标记每次第一位元素 for(j = i-1;j &gt;= 0;j --)&#123; //不断将有序序列中元素向后移动,为待插入元素空出一个位置 if(insertItem &lt; l[j]) l[j+1] = l[j]; else break; &#125; l[j+1] = insertItem; //待插入元素有序存放至有序序列中 &#125;&#125;/**冒泡排序**/void BubbleSort(int *l)&#123; int i,j; //i标识每趟排序范围最后一个元素下标,每趟排序元素下标范围是0~i for(i = N-1;i &gt; 0;i --)&#123; int isSwap = 0; //教材错误,应该放到第二层循环前 for(j = 0; j&lt;i;j ++)&#123; if(l[j] &gt; l[j+1])&#123; Swap(l,j,j+1); isSwap = 1; &#125; &#125; if(!isSwap) break; //如果本趟排序没有发生元素交换,则直接可以认为排序已完成 &#125;&#125;/**快速排序**///序列划分方法int Partition(int *l,int low,int high)&#123; int i = low,j = high + 1; int pivot = l[low]; //pivot是分割元素 do&#123; do i++; while(l[i] &lt; pivot); //i前进 do j--; while(l[j] &gt; pivot); //j前进 if(i &lt; j) Swap(l,i,j); &#125;while(i &lt; j); Swap(l,low,j); return j; //此时j是分割元素下标&#125;//快速排序void QuickSort(int *l,int low,int high)&#123; //快速排序的递归函数 int k; if(low &lt; high)&#123; //当前待排序序列至少包含2个元素 k = Partition(l,low,high); QuickSort(l,low,k-1); QuickSort(l,k+1,high); &#125;&#125;void QSort(int *l)&#123; //快速排序算法的主调用函数 QuickSort(l,0,N-1);&#125;/**快速排序**//**两路合并排序**///Merge函数void Merge(int *l,int Temp[],int i1,int j1,int i2,int j2,int *k)&#123; int i = i1,j = i2; while((i &lt;= j1)&amp;&amp;(j&lt;=j2))&#123; //若两个子序列都不空,则循环 if(l[i] &lt;= l[j])&#123; Temp[(*k)++] = l[i++]; //将较小元素存入Temp[*k] &#125; else Temp[(*k)++] = l[j++]; &#125; while(i &lt;= j1) Temp[(*k)++] = l[i++]; //将子序列1中剩余元素存入Temp while(j &lt;= j2) Temp[(*k)++] = l[j++]; //将子序列2中剩余元素存入Temp&#125;//MergeSort函数void MergeSort(int *l)&#123; int Temp[N]; int i1,j1,i2,j2,i,k,size = 1; //i1,j1和i2,j2分别是两个子序列的上,下界 while(size &lt; N)&#123; i1 = 0; k = 0; while(i1+size &lt; N)&#123; //若i1+size &lt; n,则说明存在两个子序列,需要再两两合并 i2 = i1+size; //确定子序列2的下界和子序列1的上界 j1 = i2-1; if(i2+size-1 &gt; N-1)&#123; //设置子序列2的上界 j2 = N-1; &#125; else j2 = i2+size-1; Merge(l,Temp,i1,j1,i2,j2,&amp;k); //合并相邻两个子序列 i1 = j2+1; //确定下一次合并第一个子序列的下界 &#125; for(i = 0;i &lt; k;i ++)&#123; l[i] = Temp[i]; &#125; size *= 2; //子序列长度扩大一倍 &#125;&#125;/**两路合并排序**//*****堆排序*****/typedef struct heap&#123; int n; int *data;&#125;heap;/**向下调整为最大堆**/void AdjustHeap(int Heap[],int s,int m)&#123; int temp = Heap[s]; for(int j = 2*s+1;j &lt;= m; j *= 2)&#123; if(j &lt; m &amp;&amp;Heap[j] &lt; Heap[j+1]) j++; if(temp &gt; Heap[j]) break; Heap[s] = Heap[j]; s = j; &#125; Heap[s] = temp;&#125;/**建堆**/void CreateHeap(int *heap,int n)&#123; int i; for(i = (n-2)/2;i &gt;= 0;i --) AdjustHeap(heap,i,n);&#125;/**堆初始化**/void heapInit(heap *hp,int *a,int n)&#123; hp-&gt;n = n; hp-&gt;data = (int *)malloc( sizeof(int) *n); int i; for( i = 0;i &lt; n;i ++) hp-&gt;data[i] = a[i]; CreateHeap(hp-&gt;data ,N-1);&#125;/**堆排序**/void HeapSort(heap *hp)&#123; int i; for( i=hp-&gt;n/2 ; i&gt;0 ;i--) AdjustHeap(hp-&gt;data,i,hp-&gt;n); for( i = hp-&gt; n-1 ;i&gt;0;i--)&#123; Swap( hp-&gt;data,0,i); AdjustHeap(hp-&gt;data,0,i-1); &#125;&#125;/*****堆排序*****/int main()&#123; srand(time( NULL )); int a[6][N]; int i,j; RandCreate(a[0]); for (int i = 1; i &lt; 6; ++i) for (int j = 0; j &lt; N; ++j) a[i][j] = a[0][j]; double start1 = (double) clock(); SelectSort(a[0]); double end1 = (double) clock(); double diff1 = difftime(end1,start1); printf(\"%18s%10lf\\n\",\"简单选择排序时间:\",diff1); double start2 = (double) clock(); InsertSort(a[1]); double end2 = (double) clock(); double diff2 = difftime(end2,start2); printf(\"%18s%10lf\\n\",\"直接插入排序时间:\",diff2); double start3 = (double) clock(); BubbleSort(a[2]); double end3 = (double) clock(); double diff3 = difftime(end3,start3); printf(\"%18s%10lf\\n\",\"冒泡排序时间:\",diff3); double start5 = (double) clock(); MergeSort(a[4]); double end5 = (double) clock(); double diff5 = difftime(end5,start5); printf(\"%18s%10lf\\n\",\"两路排序时间:\",diff5); double start4 = (double) clock(); QSort(a[3]); double end4 = (double) clock(); double diff4 = difftime(end4,start4); printf(\"%18s%10lf\\n\",\"快速排序时间:\",diff4); heap hp; heapInit(&amp;hp,a[5],N); double start6 = (double) clock(); HeapSort(&amp;hp); double end6 = (double) clock(); double diff6 = difftime(end6,start6); printf(\"%18s%10lf\\n\",\"堆排序时间:\",diff6); system(\"pause\"); return 0;&#125; 关于堆排序的理解 限选课对堆排的没有要求,但是在实验中涉及了。平时也没怎么看过堆排序，所以这次写的时候出现了理解上的错误，在此记下： 向上和向下调整法的区别: 区别在于用途不一样，而不是 生成最小堆和最大堆的区别 向下调整法====&gt; 建堆 … 给一堆数据,一次性建堆 向上调整法====&gt; 在已经是最小或最大堆的基础上,增加一个节点,仍保持为最大或最小堆 具体而言： 给定一个乱序的数组，要构建最小或最大堆==&gt; 向下调整 已经是个最大或最小堆的数组,插入或删除一个元素，仍要保持最小堆 ;优先权队列===&gt; 向上调整 123456789101112131415//最大堆void AdjustHeap(int Heap[],int s,int m)&#123; int temp = Heap[s]; for(int j = 2*s+1;j &lt;= m; j *= 2)&#123; if(j &lt; m &amp;&amp;Heap[j] &lt; Heap[j+1])&#123; j++; &#125; if(temp &gt; Heap[j])&#123; break; &#125; Heap[s] = Heap[j]; s = j; &#125; Heap[s] = temp;&#125; 区别在于第5行和第8行 123456789101112131415//最小堆void AdjustHeap(int Heap[],int s,int m)&#123; int temp = Heap[s]; for(int j = 2*s+1;j &lt;= m; j = j*2+1)&#123; if(j &lt; m &amp;&amp;Heap[j] &gt; Heap[j+1])&#123; j++; &#125; if(temp &lt; Heap[j])&#123; break; &#125; Heap[s] = Heap[j]; s = j; &#125; Heap[s] = temp;&#125; 建堆的执行过程大致是: CreateHeap函数从下往上建，即从[s,m]==&gt;[s-1,m],在保证从s到m是最小堆后,再用向下调整法使[s-1,m]也成为堆。 向下调整的过程： 从s–&gt;m,依次调整 总的逻辑是，由于要使左子树和右子树满足要求，所以需要从下往上调整。","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"南邮《信号与系统B》复习知识点大纲","slug":"南邮《信号与系统B》复习知识点大纲","date":"2018-12-26T14:15:36.000Z","updated":"2019-09-15T08:07:31.039Z","comments":true,"path":"2018/12/26/南邮《信号与系统B》复习知识点大纲/","link":"","permalink":"https://nymrli.top/2018/12/26/南邮《信号与系统B》复习知识点大纲/","excerpt":"","text":"友情提示 请将图片右键另存为，保存到本地放大查看。 第一章 第二章","categories":[],"tags":[{"name":"学业","slug":"学业","permalink":"https://nymrli.top/tags/学业/"}]},{"title":"不蒜子统计阅读次数失效——Cxo主题","slug":"不蒜子统计阅读次数失效","date":"2018-12-26T00:57:37.000Z","updated":"2019-09-15T08:07:31.020Z","comments":true,"path":"2018/12/26/不蒜子统计阅读次数失效/","link":"","permalink":"https://nymrli.top/2018/12/26/不蒜子统计阅读次数失效/","excerpt":"","text":"官方通知 12&gt; ！！！！2018年9月 - 重要提示 ！！！！大家好，因七牛强制过期原有的『dn-lbstatics.qbox.me』域名（预计2018年10月初），与客服沟通数次无果，即使我提出为此付费也不行，只能更换域名到『busuanzi.ibruce.info』！因我是最早的一批七牛用户，为七牛至少带来了数百个邀请用户，很痛心，很无奈！各位继续使用不蒜子提供的服务，只需把原有的：&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;域名改一下即可：&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;只需要修改该js域名，其他均未改变。若有疑问，可以加入不蒜子交流QQ群：`419260983`，对您带来的不便，非常抱歉！！！还是那句话，不蒜子不会中断服务！！！！&gt; 不蒜子 原因分析 由于定位到是不蒜子统计功能突然有问题了，所以前往不蒜子官网进行查看，发现官网有一段很重要的提示： “因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！” 所以定位到问题，原来是不蒜子使用的七牛的域名被强制过期。 需要把 dn-lbstatics.qbox.me 域名更换为 busuanzi.ibruce.info 实际操作 找到含busuanzi插件设置的文件 修改指向的网址 修改完后","categories":[],"tags":[]},{"title":"Ubuntu下Sublime配置python编译环境及新手使用指导","slug":"Ubuntu下Sublime配置python编译环境及新手使用指导","date":"2018-12-26T00:41:18.000Z","updated":"2019-09-15T08:07:31.010Z","comments":true,"path":"2018/12/26/Ubuntu下Sublime配置python编译环境及新手使用指导/","link":"","permalink":"https://nymrli.top/2018/12/26/Ubuntu下Sublime配置python编译环境及新手使用指导/","excerpt":"","text":"##Sublime下配置python编译环境及搭建虚拟环境:(windows下大致相同) 1.编译环境配置 2019-3-6更新教程，发现好像 官方网址打不开了，要改一下源才行。 解决办法： 点击 Preferences -&gt; Settings -&gt; Preferences.sublime-Settings—— User(一个新窗口) 添加配置**(在原有大括号{}里面添加**)：&quot;channels&quot;: [&quot;https://raw.githubusercontent.com/HBLong/channel_v3_daily/master/channel_v3.json&quot;], 代码不变，仍然是下面的代码 感谢HBLong提供的解决方案和源: 原有链接 : 解决：Sublime Text3 packagecontrol.io 无法访问的问题 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 1.点击 官方网址 从 Sublime Text 3 官方获取用于安装的代码。从菜单栏View --&gt;Show Console或者使用Ctrl+`(esc键下面的按键)，调出sublime的控制台，将官网中的python代码粘贴进去并按Enter执行，最终可以安装完成。在控制台中粘贴刚才的代码，然后点击回车。最后重启ST3。 2.现在你可以通过快捷键 cmd+shift+P 打开 Package Control 来安装其他的插件了。输入 install 然后你就能看见屏幕上出现了 Package Control: Install Package，点击回车,然后搜索sublimeREPL 安装成功后，可以在菜单栏的’TOOL’中找到SublimeREPL，如图所示 2.将菜单栏改为中文 若需要将菜单栏改成中文可如上操作下载插件“ConvertToUTF8”或是安装插件“ChineseLocalizations”(本人使用的是这个，没试ConvertToUTF8的效果) (参考博客:http://blog.51cto.com/11970781/2087971) 3.安装Anaconda插件 1.点击刚刚生成的Package Control -&gt;输入install 2.进入安装界面，安装好后再在新窗口命令行中输入Anaconda并点击第一个备选项进行安装。 安装完成后会显示messages文档。 安装Anaconda插件完成之后，会看到如下选项栏，说明Anaconda安装成功。 Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数或者类的定义。 Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下) Anaconda会自动补全代码，之前用惯了pycharm发现突然没了代码补全后很不习惯，Anaconda的补全功能虽然没有pycharm那么好用，但还是不错的 还有需要注意的是，安装Anaconda插件后，如果python代码没有遵循PEP8规范，会出现白色的框框，或是可以使用快捷键Ctrl+Alt+R进行规范代码(这个可以去除，步骤如下) 在Settings-User选项中添加配置:{&quot;anaconda_linting&quot;:false} 4.安装虚拟环境 1.首先使用终端安装virtualenv，pip3 install virtualenv 2.在需要创建的地方进行虚拟环境的搭建，代码如下： 123mkdir pytest(文件夹名)cd pytestvirtualenv venv 1.在终端进入虚拟环境的话是在pytest文件夹下输入命令source /bin/activate 而要在sublime中进入虚拟环境的话就得按照如下操作： 首先在sublime中安装virtualenv插件，Ctrl + Shift + P，然后输入install,回车，然后搜索virtualenv。 可能出现的问题: 🎯由于 官方网址打不开的缘故，需要换源，但是根据#1.编译环境配置设置的channel貌似还是会出错,如果出错按如下方法解决 2.安装完成virtualenv插件后，直接按Ctrl + Shift + P，再输入Activate，若没有该选项则virtualenv安装中出现问题，需要重新安装。如果有的会选择Activate就能发现刚刚创建的虚拟环境，选中后回车即可进入虚拟环境 3.如果Activate选中后没有出现我们刚刚创建的虚拟环境，则需要我们手动添加路径.Ctrl + Shift + P，然后输入Add directory，回车，屏幕下面会出现输入行（Directory path）:再将刚创建的虚拟环境路径填入即可 另外，我曾碰到过Add directory后仍然没用的情况。那时，可选择“”Project”=&gt;&quot;Add folder to project&quot;选择文件后=&gt;“Save Project as”==&gt;保存好即可 工程配置文件为： .sublime-workspace、.sublime-project 其中sublime-project为: 123456789101112131415161718&#123; \"build_systems\": [ &#123; \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\", \"name\": \"Anaconda Python Builder\", \"selector\": \"source.python\", \"shell_cmd\": \"\\\"python\\\" -u \\\"$file\\\"\" &#125; ], \"folders\": [ &#123; \"path\": \"爬虫\" &#125; ], \"virtualenv\": \"G:\\\\pachong\\\\venv\"&#125; 这样环境就配置好了。按Ctrl+B编译时，观察&quot;Tools&quot;-&gt;“Build System”-&gt;是否为&quot;Python+ Virtualenv&quot;，如果不是，则选用这个再Ctrl+B就是在虚拟环境中编译了! ubuntu下sublime默认情况下好像不能输入中文，需要用下面命令就可以完美支持中文输入： 1234$ sudo apt-get update &amp;&amp; sudo apt-get upgrade$ git clone https://github.com/lyfeyaj/sublime-text-imfix.git$ cd sublime-text-imfix$ ./sublime-imfix 转自博客 截图好像有点问题，菜单栏都没有截到，用到的三个分别为“项目(Project)”，“首选项(Preferences)”，“帮助(Help)” 附录 无论是Python或者C/C++程序按Ctrl+b后运行没有输出。发现是编译选项出了问题。 解决方法如下： 按下Ctrl +Shift + b选择编译方法，光标移到有Run的选项,再按Ctrl+b编译 成功如图~","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"}]},{"title":"PythonWeb--flask部署内网电脑","slug":"PythonWeb-flask部署内网电脑","date":"2018-12-21T14:08:04.000Z","updated":"2020-05-15T03:12:43.618Z","comments":true,"path":"2018/12/21/PythonWeb-flask部署内网电脑/","link":"","permalink":"https://nymrli.top/2018/12/21/PythonWeb-flask部署内网电脑/","excerpt":"","text":"PythonWeb–flask部署问题 以前在云服务器上都是用root权限部署的,很流畅…这次用了活动室电脑是管理员权限apollo3d…于是出现了很大的问题… 内网穿透 活动室电脑的IP是通过路由器分配的IP,如192.168.1.145,这是一个局域网,别人是不可能通过这个IP访问到你的服务器的.（访问都是通过公网的。除非两台电脑在同一个局域网内）。 于是想到直接连活动室的网不就行了吗（如果活动室的是公网IP，只要对路由器设置个端口映射就行了），但发现，活动室的IP也是校园网分配的，已经经过了多次的NAT，于是这个方法也没用。 搜了下网上关于“内网中的电脑当做服务器”，找到了方案就是“内网穿透”，而能实现这个功能的软件不少如花生壳、frp…在此,我用花生壳达成了目的,花了6元… 花生壳 注册账号后会送给你一个域名，而“内网穿透”的功能是需要买的。他实现的原理大致是将动态变化的IP绑定在了这个域名上，每次IP变换的时候就重新DNS解析，所以达成了“IP跟随” 设置好后，就可以直接通过域名访问到内网下的电脑了！ frp 见另外一篇博客的配置方法《frp结合nginx实现内网web服务和tcp的转发》 非root权限——管理员权限 之前都是部署在/var/www目录下的,这次也没多想,也照样…结果踩了坑,弄了几小时. 先是pip install virtualenv安装了virtualenv库,然后用virtualenv env新建了个虚拟环境 但问题来了，windows下的目录结构跟linux下的有些小小的不同,导致运行uwsgi报错No module flask时一直没找到原因 linux下结构: 1234567891011--|env-----|lib-------|python---------|site-packagess---------|.....-----|includes--------|python3.5m-----|bin-------|python3.5-------|pip-------|activate 正常情况下只要激活了虚拟环境,那么pip安装的库应该都是在该虚拟环境下的,这次出了什么问题呢? 1.猜测没有site-packages 当时因为linux终端显示的原因没看到site-packages,于是就以为没有linux下建立的虚拟环境没有site-packages,但事实证明这个是没有关系的… 2.uwsgi.ini没有指定虚拟环境 网上给出的都是因为没有进入虚拟环境执行或者是配置中没有指定虚拟环境路径 3.加了sudo 根据报错显示知道，sudo pip install -r requirements.txt的库都安装到了默认python目录下了…原因是因为加了sudo. ▲一定不要使用sudo pip … ,这里是在虚拟环境中安装python包，如果使用了sudo权限，python包会被安装在主机非虚拟环境下，在虚拟环境中找不到这个包。 永远不要使用sudo pip install; 你可以在不知情的情况下覆盖重要的东西。使用pip install --user代替 于是那就不加吧,命令改为pip install -r requirements.txt,此时有报错Could not install packages due to anEnvironmentError: [Error 13] Permission denied:...,consider using '--user' options,既然提示用--user参数那就试试吧. 结果返回的是Can not perform a '--user' install. User site-packages are not visible in this virtualenv,这是为什么还是不行呢? 官方解释 pip install --user 遵循四条规则： 当全局安装的软件包位于python路径上，并且它们 与安装要求冲突时，它们将被忽略，而不会被 卸载。 当全局安装的软件包位于python路径上并且它们满足 安装要求时，pip什么都不做，并报告满足要求（类似于在--system-site-packages virtualenv中安装软件包时全局软件包如何满足要求）。 由于用户站点不在python路径上，因此pip不会--user在--no-site-packages的virtualenv（即默认类型的virtualenv）中执行安装。安装没有意义。 123import sysprint(sys.path)&gt;&gt;&gt; ['C:\\\\Users\\\\10630\\\\Desktop', 'D:\\\\python\\\\python36.zip', 'D:\\\\python\\\\DLLs', 'D:\\\\python\\\\lib', 'D:\\\\python', 'C:\\\\Users\\\\10630\\\\AppData\\\\Roaming\\\\Python\\\\Python36\\\\site-packages', 'D:\\\\python\\\\lib\\\\site-packages', 'D:\\\\python\\\\lib\\\\site-packages\\\\win32', 'D:\\\\python\\\\lib\\\\site-packages\\\\win32\\\\lib', 'D:\\\\python\\\\lib\\\\site-packages\\\\Pythonwin'] 在--system-site-packagesvirtualenv中，pip不会安装与virtualenv site-packages中的包冲突的包。-user安装缺少sys.path优先级并且毫无意义。 那应该就是3的原因了…需要在当前的env虚拟环境中将权限开放,我的做法是sudo chmod 777 -R * 最终解决方式: 于是我并没有再纠结这个,而是选择了不在/var/www这个目录下,因为这个目录下的权限关系非常严格,于是我在~/Documents/env新建了个虚拟环境,一切又如以前一样解决了. Ubuntu下使用matplotlib库,需要安装python3-tk `&quot;raise ImportError(str(msg) + ‘, please install the python3-tk package’) ImportError: No module named ‘_tkinter’, please install the python3-tk package&quot;的错误 解决方案:sudo apt-get install python3-tk(如果没更新源,最好更新下源) 附录: sudo-pip-install-vs-pip-install-user: 回答1: sudo pip install可能意味着您要在系统范围内安装软件包。对于某些软件包，例如virtualenvwrapper，这可能是有用的，但除此之外，我将避免安装系统范围的软件包并为每个应用程序创建virtualenv并将pip安装到该virtualenv（可以在没有sudo的情况下完成）。 回答2: 1$ sudo pip install 在python安装中全局安装包，即对所有用户安装。 1$ pip install --user 安装到本地用户目录，即〜/ .local / lib / python - 只是你。 例： 12$ sudo pip install jupyter$ jupyter notebook 将运行jupyter，打开Web浏览器，允许您使用笔记本。 12$ pip install --user jupyter$ jupyter notebook 在将本地目录添加到PATH之前，将不执行任何操作。 最近pypi中包含了恶意代码。切勿使用sudo来安装pip。这与以root身份运行病毒相同。将本地文件夹添加到PATH或使用virtualenv。","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"}]},{"title":"Pandas速成","slug":"Pandas速成","date":"2018-12-21T13:57:29.000Z","updated":"2019-09-15T08:07:30.967Z","comments":true,"path":"2018/12/21/Pandas速成/","link":"","permalink":"https://nymrli.top/2018/12/21/Pandas速成/","excerpt":"","text":"Pandas速成 Series : 一位数组, 只允许存储相同的数据类型 Time-Series : 以时间为索引的Series DataFrame : 二维的表格型数据结构 , 可以理解为是Series 的容器 Panel : 三维数组,可以理解为DataFrame 的容器 Series 1234567891011121314151617import matplotlib.pyplot as pltimport pandas as pdimport numpy as nparr = np.array([1,2,3])index = ['a','b','c']myseries = pd.Series(arr,index)print(myseries)print('Series中第一个元素&#123;&#125;'.format(myseries[0]))print('Series中索引为C的元素'.format(myseries['c']))&gt;&gt;&gt;a 1b 2c 3dtype: int32Series中第一个元素1Series中索引为C的元素 DataFrame 1234567891011121314arr= np.array([ [1,2,3], [2,3,4], [3,4,5]])rowindex = ['row1','row2','row3']colindex = ['col1','col2','col3']dataframe= pd.DataFrame(data=arr,index= rowindex,columns=colindex)print(dataframe)&gt;&gt;&gt; col1 col2 col3row1 1 2 3row2 2 3 4row3 3 4 5 1234567891011121314arr= np.array([ [1,2,3], [2,3,4], [3,4,5]])rowindex = [&apos;row1&apos;,&apos;row2&apos;,&apos;row3&apos;]colindex = [&apos;col1&apos;,&apos;col2&apos;,&apos;col3&apos;]dataframe= pd.DataFrame(data=arr,index = rowindex,columns=colindex)print(dataframe._ixs(0))&gt;&gt;&gt;col1 1col2 2col3 3Name: row1, dtype: int32 获取行列 1.ix[ ] 先行后列 12345print(dataframe.ix[[0]]) #获得第一行内容# print(dataframe.ix[&apos;row1&apos;]) #以索引名称获得print(dataframe.ix[[0]])` #获得第一列内容print(dataframe.ix[:,&apos;col1&apos;]) 2.loc[ ] loc,是基于索引的名称选取数据集，这里的索引名称可以是数字,先行后列。注意，[0:2]是选取名称为0， 1， 2行的数据，一共三，只能写行和列的名称，不能写序号。 123456789print(dataframe.loc[&apos;row1&apos;])&gt;&gt;&gt; col1 1col2 2col3 3Name: row1, dtype: int32print(dataframe.loc[:,&apos;col1&apos;]) #获得&apos;col1&apos;列的值print(dataframe.loc[&apos;row1&apos;,&apos;col1&apos;]) #获得某行某列的值 3.iloc[] iloc，它是基于索引位来选取数据集，也就是数字序号来选取，0:2就是选取 0，1这两行，需要注意的是这里是前闭后开集合。只能写行和列的序号，不能写名称，否则会报错。 12345678print(dataframe.iloc[2])&gt;&gt;&gt; col1 3col2 4col3 5Name: row3, dtype: int32print(dataframe.iloc[0,:])","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"BaiduMap_API","slug":"BaiduMap-API","date":"2018-12-21T13:55:50.000Z","updated":"2019-09-15T08:07:30.920Z","comments":true,"path":"2018/12/21/BaiduMap-API/","link":"","permalink":"https://nymrli.top/2018/12/21/BaiduMap-API/","excerpt":"","text":"Baidu Map API 核心类Map 构造函数 描述 Map(container: String | HTMLElement, opts: MapOptions) 在指定的容器内创建地图实例，之后需要调用Map.centerAndZoom()方法对地图进行初始化。未进行初始化的地图将不能进行任何操作 12var map = new BMap.Map(\"MAP\");map.centerAndZoom(points[0], 15); 方法 返回值 描述 enableDragging() none 启用地图拖拽，默认启用 enableScrollWheelZoom() none 启用滚轮放大缩小，默认禁用 enableDoubleClickZoom() none 启用双击放大，默认启用 enableKeyboard() none 启用键盘操作，默认禁用。 enablePinchToZoom() none 启用双指操作缩放，默认启用 enableAutoResize() none 启用自动适应容器尺寸变化，默认启用 setMinZoom(zoom: Number) none 设置地图允许的最小级别。取值不得小于地图类型所允许的最小级别 getCenter() Point 返回地图当前中心点 getDistance(start: Point, end: Point) Number 返回两点之间的距离，单位是米 centerAndZoom(center: Point, zoom: Number) none 设初始化地图。 如果center类型为Point时，zoom必须赋值，范围3-19级，若调用高清底图（针对移动端开发）时，zoom可赋值范围为3-18级。如果center类型为字符串时，比如“北京”，zoom可以忽略，地图将自动根据center适配最佳zoom级别 panTo(center: Point, opts: PanOptions) none 将地图的中心点更改为给定的点。如果该点在当前的地图视图中已经可见，则会以平滑动画的方式移动到中心点位置。可以通过配置强制移动过程不使用动画效果 setCenter(center: Point | String) none 设置地图中心点。center除了可以为坐标点以外，还支持城市名 getZoom() Number 返回地图当前缩放级别 setZoom(zoom: Number) none 将视图切换到指定的缩放等级，中心点坐标不变。注意：当有信息窗口在地图上打开时，地图缩放将保证信息窗口所在的坐标位置不动 addOverlay(overlay: Overlay) none 将覆盖物添加到地图中，一个覆盖物实例只能向地图中添加一次 clearOverlays() none 清除地图上所有覆盖物 控件类 Control基类 initialize(map: Map) HTMLElement 抽象方法。调用Map.addControl()方法添加控件时将调用此方法，从而实现该控件的初始化。自定义控件时需要实现此方法，并将元素的DOM元素在该方法中返回。DOM元素需要添加到地图的容器中，使用map.getContainer()方法可获得地图容器元素 setAnchor(anchor: ControlAnchor) none 设置控件停靠的位置 getAnchor() ControlAnchor 返回控件停靠的位置 setOffset(offset: Size) none 设置控件停靠的偏移量 getOffset() Size 返回控件停靠的偏移量 show() none 显示控件 hide() none 隐藏控件 isVisible() Boolean 判断控件的可见性 ControlAnchor: 此常量表示控件的定位。 常量 描述 BMAP_ANCHOR_TOP_LEFT 控件将定位到地图的左上角 BMAP_ANCHOR_TOP_RIGHT 控件将定位到地图的右上角 BMAP_ANCHOR_BOTTOM_LEFT 控件将定位到地图的左下角 BMAP_ANCHOR_BOTTOM_RIGHT 控件将定位到地图的右下角 NavigationControl 此类表示地图的平移缩放控件，可以对地图进行上下左右四个方向的平移和缩放操作。 GeolocationControl 此类是负责进行地图定位的控件，使用html5浏览器定位功能，此类继承Control所有功能。 OverviewMapControl 此类表示缩略地图控件。 ScaleControl 此类表示比例尺控件。 CopyrightControl 此类表示版权控件，您可以在地图上添加自己的版权信息。每一个版权信息需要包含如下内容：版权的唯一标识、版权内容和其适用的区域范围。 覆盖物类 Marker:此类表示地图上一个图像标注。 构造函数 描述 Marker(point: Point, opts: MarkerOptions) 创建一个图像标注实例。point参数指定了图像标注所在的地理位置 1234markers = new BMap.Marker(new BMap.Point(118.93015,32.1091),&#123;\"title\":'Point'&#125;);label = new BMap.Label('label');markers.setLabel(l);map.addOverlay(markers); Icon此类表示标注覆盖物所使用的图标。 构造函数 描述 Icon(url: String, size: Size, opts: IconOptions) 以给定的图像地址和大小创建图标对象实例 Label此类表示地图上的文本标注。 构造函数 描述 Label(content: String, opts: LabelOptions) 创建一个文本标注实例。point参数指定了文本标注所在的地理位置 1234label = new BMap.Label(\"\", &#123;offset: new BMap.Size(-20, -20)&#125;); car = new BMap.Marker(points[0]); car.setLabel(label); map.addOverlay(car);","categories":[],"tags":[{"name":"API","slug":"API","permalink":"https://nymrli.top/tags/API/"}]},{"title":"Postman模拟上传文件","slug":"Postman模拟上传文件","date":"2018-12-20T10:57:35.000Z","updated":"2019-09-15T08:07:30.970Z","comments":true,"path":"2018/12/20/Postman模拟上传文件/","link":"","permalink":"https://nymrli.top/2018/12/20/Postman模拟上传文件/","excerpt":"","text":"Postman模拟 1.首先得知道前端的样子: 2.针对前端字段进行模拟POST ▲这边key为&lt;input&gt;中的name属性 ▲▲URL最后的’/’: POST请求URL要对应 12345@app.route(&apos;/photo/&apos;,methods = [&apos;GET&apos;,&apos;POST&apos;] )http://127.0.0.1:5000/photo/@app.route(&apos;/photo&apos;,methods = [&apos;GET&apos;,&apos;POST&apos;] )http://127.0.0.1:5000/photo ​ 当Web服务器接收到对某个末尾不含斜杠的url请求时，例如“http://www.abc.com/abc”，这时服务器会搜索网站根目录下有没有名为“abc”的文件，如果没有就把abc当做目录处理，然后返回abc目录下的默认首页。当Web服务器接收到的是末尾带斜杠的请求时就会直接当做目录处理。，当浏览器解析 /ie 这样的url时，服务器会执行301转向到/ie/，两个链接都有效，但是第二种更快。 ​ 对于静态资源服务器来说，请求https://imgss.github.io/demo/这样的路径能访问到页面，是因为服务器会自动在demo路径下尝试找index.html之类的文件并发给浏览器，所以html的当前路径一定是demo下的，也是因为这样，浏览器才会通过重定向自动加上/，防止相对路径解析出错，保证浏览器能正确的请求到资源。 requests模拟 1234567url = 'http://127.0.0.1:5000/photo/'filename = &#123; 'src' : open(\"C:\\\\Users\\\\10630\\\\Desktop\\\\为什么电流被一分为2.jpg\",'rb')&#125;html = requests.post(url,files=filename)print(html.text)# &#123;\"msg\":\"success\",\"status\":200&#125;","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Postman","slug":"Postman","permalink":"https://nymrli.top/tags/Postman/"}]},{"title":"flask-sqlalchemy踩坑——外键","slug":"flask-sqlalchemy踩坑","date":"2018-12-19T11:47:54.000Z","updated":"2019-09-15T08:07:30.933Z","comments":true,"path":"2018/12/19/flask-sqlalchemy踩坑/","link":"","permalink":"https://nymrli.top/2018/12/19/flask-sqlalchemy踩坑/","excerpt":"","text":"12.19：外键使用 今天要设计一个如图关系的表关系时,踩了好几个坑…记录下 代码: 123456789101112131415161718192021222324from exts import dbclass Account(db.Model): __tablename__ = 'account' id = db.Column(db.Integer,primary_key=True,autoincrement=True) Username = db.Column(db.String(30),nullable=True,unique=True) PWD = db.Column(db.String(20),nullable=True) email = db.Column(db.String(20),nullable=True,unique=True)class Info(db.Model): __tablename__ = 'info' id = db.Column(db.Integer,primary_key=True,autoincrement=True) email = db.Column(db.String(20),db.ForeignKey('account.email')) timestamp = db.Column(db.Float,nullable=True,unique=True)class Tmp(db.Model): __tablename__ = 'tmp' id = db.Column(db.Integer,primary_key=True,autoincrement=True) tmp = db.Column(db.Float,db.ForeignKey('info.timestamp')) # 一组的开始时间 nowtime = db.Column(db.FLOAT,nullable=True) # 当前记录的时间 longitude = db.Column(db.FLOAT,nullable=True) latitude = db.Column(db.FLOAT,nullable=True) id的类型是int,没有id这种类型 ▲.外键必须是主表的唯一键(unique)（如上，学生表 sid 是主键，而主键是唯一的，所以能够作为分数表 stu 的外键） 外键不一定须要作为从表的主键。外键也不一定是主表的主键。主表的唯一键就能够作为从表的外键。 外键的类型必须与父表的主键类型完全一致(类型和长度) 总结下来：","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"数据库","slug":"数据库","permalink":"https://nymrli.top/tags/数据库/"}]},{"title":"数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题","slug":"数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题","date":"2018-12-16T09:50:05.000Z","updated":"2019-09-15T08:07:31.073Z","comments":true,"path":"2018/12/16/数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题/","link":"","permalink":"https://nymrli.top/2018/12/16/数据结构实验3——图的基本运算及职能交通中的最佳路径选择问题/","excerpt":"","text":"实验3.图的基本运算及职能交通中的最佳路径选择问题 3.2-邻接矩阵的DFS和BFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define ERROR 0#define OK 1#define Overflow 2 //表示上溢#define Underflow 3 //表示下溢#define NotPresent 4 //表示元素不存在#define Duplicate 5 //表示有重复元素#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status;typedef int BOOL;/************队列操作**************///循环队列的结构体定义typedef struct&#123; int front; int rear; int maxSize; //最大容量 ElemType *element;&#125;Queue;//创建一个能容纳mSize个单元的空队列void Create(Queue *Q,int mSize)&#123; Q-&gt;maxSize=mSize; Q-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize); Q-&gt;front=Q-&gt;rear=0;&#125; //判断队列是否为空,若是,则返回TRUE;否则返回FALSEBOOL IsEmpty(Queue *Q)&#123; return Q-&gt;front==Q-&gt;rear;&#125; //判断队列是否已满,若是,则返回TRUE,否则返回FALSEBOOL IsFULL(Queue *Q)&#123; return (Q-&gt;rear+1)%Q-&gt;maxSize==Q-&gt;front;&#125; //获取队头元素,并通过x返回.若操作成功,则返回TRUE,否则返回FALSEBOOL Front(Queue *Q,ElemType *x)&#123; if(IsEmpty(Q)) //空队列处理 return FALSE; *x=Q-&gt;element[(Q-&gt;front+1)%Q-&gt;maxSize]; return TRUE;&#125; //入队.在队列Q的队尾插入元素x(入队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL EnQueue(Queue *Q,ElemType x)&#123; if(IsFULL(Q)) //溢出处理 return FALSE; Q-&gt;rear=(Q-&gt;rear+1)%Q-&gt;maxSize; Q-&gt;element[Q-&gt;rear]=x; return TRUE;&#125; //出队.从队列Q中删除队头元素(出队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL DeQueue(Queue *Q)&#123; if(IsEmpty(Q))&#123; //空队列处理 return FALSE; &#125; Q-&gt;front=(Q-&gt;front+1)%Q-&gt;maxSize; return TRUE;&#125; /************队列操作**************///邻接矩阵的结构体定义typedef struct&#123; ElemType **a; //邻接矩阵 int n; //图的当前顶点数 int e; //图的当前边数 ElemType noEdge; //两顶点间无边时的值&#125;mGraph; //邻接矩阵的初始化Status Init(mGraph *mg,int nSize,ElemType noEdgeValue)&#123; int i,j; mg-&gt;n = nSize; //初始化顶点数 mg-&gt;e = 0; //初始化时没有边 mg-&gt;noEdge = noEdgeValue; //初始化没有边时的取值 mg-&gt;a = (ElemType**)malloc(nSize*sizeof(ElemType *)); //生成长度为n的一维指针数组 if(!mg-&gt;a) return ERROR; for(i = 0;i &lt; mg-&gt;n;i ++)&#123; //动态生成二维数组 mg-&gt;a[i] = (ElemType*)malloc(nSize*sizeof(ElemType)); for(j = 0;j &lt; mg-&gt;n;j ++)&#123; mg-&gt;a[i][j] = mg-&gt;noEdge; &#125; mg-&gt;a[i][i] = 0; //自回路设置为0 &#125; return OK;&#125; //邻接矩阵的撤销(改成了int型，有返回值),先释放一维数组,再释放指针数组int Destory(mGraph *mg)&#123; int i; for(i = 0;i &lt; mg-&gt;n;i ++)&#123; free(mg-&gt;a[i]); //释放n个一维数组的存储空间 &#125; free(mg-&gt;a); //释放一维数组的存储空间 return 1;&#125; //邻接矩阵的边的搜索Status Exist(mGraph *mg,int u,int v)&#123; if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v||mg-&gt;a[u][v] == mg-&gt;noEdge) return ERROR; return OK;&#125; //邻接矩阵的边的插入Status Insert(mGraph *mg,int u,int v,ElemType w)&#123; if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v) return ERROR; if(mg-&gt;a[u][v] != mg-&gt;noEdge) return Duplicate; //若待插入边已存在,则返回出错信息 mg-&gt;a[u][v] = w; //插入新边 mg-&gt;e ++; //增加一条边 return OK;&#125; //邻接矩阵的边的删除Status Remove(mGraph *mg,int u,int v)&#123; if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v) return ERROR; if(mg-&gt;a[u][v] == mg-&gt;noEdge) return NotPresent; //若待删除边不存在,则返回出错信息 mg-&gt;a[u][v] = mg-&gt;noEdge; //删除边 mg-&gt;e --; return OK;&#125; void DFS(mGraph mg,int v,int visited[])&#123; int j; printf(\"%d\",v ); visited[v] = 1; for( j = 0; j &lt; mg.n; j++)&#123; //遍历v的邻接点 if(!visited[j] &amp;&amp; mg.a[v][j] &gt; 0)&#123; //当未被访问且有权值 DFS(mg,j,visited); &#125; &#125;&#125;//DFS搜索全图void DFSGraph(mGraph mg)&#123; int i; int *visited = (int *)malloc(mg.n * sizeof(int)); //访问为1,未访问为0 for(i=0; i&lt; mg.n;i++) visited[i] = 0; //visted数组初始化 for(i=0;i&lt; mg.n; i++) if( !visited[i] ) DFS(mg,i,visited); free(visited); //整个图的DFS遍历后,释放visted数组&#125; void BFS(mGraph mg,int v,int visited[])&#123; Queue q; Create(&amp;q,mg.n); visited[v] = 1; printf(\"%d\",v); EnQueue(&amp;q,v); //将当前顶点v放入队列 while( !IsEmpty(&amp;q) )&#123; Front(&amp;q,&amp;v); DeQueue(&amp;q); //队首顶点出队列 for(int i = 0;i &lt; mg.n;i ++)&#123; //遍历图的每一项 if( !visited[i] &amp;&amp; mg.a[v][i] &gt; 0)&#123; //若未被访问且有权值,则将其访问并放入队列 visited[i] = 1; printf(\"%d\",i); EnQueue(&amp;q,i); &#125; &#125; &#125;&#125;//BFS搜索全图void BFSGraph(mGraph mg)&#123; int i; int *visited = (int *)malloc(mg.n * sizeof(int)); //访问为1,未访问为0 for(i=0; i&lt; mg.n;i++) visited[i] = 0; //visted数组初始化 for(i=0;i&lt; mg.n; i++) if( !visited[i] ) BFS(mg,i,visited); free(visited); //整个图的BFS遍历后,释放visted数组&#125; int main()&#123; mGraph g; int nSize,edge,u,v,i; ElemType w; printf(\"Enter the mgraph's Size:\"); scanf(\"%d\",&amp;nSize); Init(&amp;g,nSize,-1); printf(\"Enter the mgraph's Edge num:\"); scanf(\"%d\",&amp;edge); for(i = 0;i &lt; edge;i ++)&#123; printf(\"Please enter the edge(Pu,Pv,Weight):\"); scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); Insert(&amp;g,u,v,w); &#125; printf(\"DFS:\"); DFSGraph(g); printf(\"\\nBFS:\"); BFSGraph(g); printf(\"\\n\"); system(\"pause\"); return 0;&#125; 3.4-邻接表的BFS和DFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define ERROR 0#define OK 1#define Overflow 2 //表示上溢#define Underflow 3 //表示下溢#define NotPresent 4 //表示元素不存在#define Duplicate 5 //表示有重复元素#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status;typedef int BOOL;/************队列操作**************///循环队列的结构体定义typedef struct&#123; int front; int rear; int maxSize; //最大容量 ElemType *element;&#125;Queue;//创建一个能容纳mSize个单元的空队列void Create(Queue *Q,int mSize)&#123; Q-&gt;maxSize=mSize; Q-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize); Q-&gt;front=Q-&gt;rear=0;&#125; //判断队列是否为空,若是,则返回TRUE;否则返回FALSEBOOL IsEmpty(Queue *Q)&#123; return Q-&gt;front==Q-&gt;rear;&#125; //判断队列是否已满,若是,则返回TRUE,否则返回FALSEBOOL IsFULL(Queue *Q)&#123; return (Q-&gt;rear+1)%Q-&gt;maxSize==Q-&gt;front;&#125; //获取队头元素,并通过x返回.若操作成功,则返回TRUE,否则返回FALSEBOOL Front(Queue *Q,ElemType *x)&#123; if(IsEmpty(Q)) //空队列处理 return FALSE; *x=Q-&gt;element[(Q-&gt;front+1)%Q-&gt;maxSize]; return TRUE;&#125; //入队.在队列Q的队尾插入元素x(入队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL EnQueue(Queue *Q,ElemType x)&#123; if(IsFULL(Q)) //溢出处理 return FALSE; Q-&gt;rear=(Q-&gt;rear+1)%Q-&gt;maxSize; Q-&gt;element[Q-&gt;rear]=x; return TRUE;&#125; //出队.从队列Q中删除队头元素(出队操作)。操作成功,则返回TRUE,否则返回FALSEBOOL DeQueue(Queue *Q)&#123; if(IsEmpty(Q))&#123; //空队列处理 return FALSE; &#125; Q-&gt;front=(Q-&gt;front+1)%Q-&gt;maxSize; return TRUE;&#125; /************队列操作**************///邻接表的结构体定义typedef struct ENode&#123; int adjVex; //任意顶点u相邻的顶点 ElemType w; //边的权值 struct ENode *nextArc; //指向下一个边结点&#125;ENode; typedef struct&#123; int n; //图的当前顶点数 int e; //图的当前边数 ENode **a; //指向一维指针数组&#125;LGraph; //邻接表的初始化Status Init(LGraph *lg,int nSize)&#123; int i; lg-&gt;n = nSize; lg-&gt;e = 0; lg-&gt;a = (ENode**)malloc(nSize*sizeof(ENode*)); //动态生成长度为n的一维指针数组 if(!lg-&gt;a) return ERROR; for(i = 0;i &lt; lg-&gt;n;i ++) lg-&gt;a[i] = NULL; //将指针数组a置空 return OK;&#125; //邻接表的撤销int Destory(LGraph *lg)&#123; int i; ENode *p,*q; for(i = 0;i &lt; lg-&gt;n;i ++)&#123; //链表的撤销操作 p = lg-&gt;a[i]; //指针p指向顶点i的单链表的第一个边结点 q = p; while(p)&#123; //释放顶点i的单链表中所有边结点 p = p-&gt;nextArc; free(q); q = p; &#125; &#125; free(lg-&gt;a); //释放一维指针数组a的存储空间 return OK; //改为int型函数,有返回值&#125; //邻接表的搜索边Status Exist(LGraph *lg,int u,int v)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1 ||v &gt; lg-&gt;n-1 ||u == v) return ERROR; p = lg-&gt;a[u]; //指针p指向顶点u的单链表的第一个边结点 while(p!=NULL &amp;&amp; p-&gt;adjVex != v)&#123; p = p-&gt;nextArc; &#125; if(!p) return ERROR; else return OK;&#125; //邻接表的插入边Status Insert(LGraph *lg,int u,int v,ElemType w)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1||v &gt; lg-&gt;n-1 ||u == v) return ERROR; if(Exist(lg,u,v)) return Duplicate; //此边已存在,返回错误 p = (ENode*)malloc(sizeof(ENode)); //为新的边结点分配存储空间 p-&gt;adjVex = v; p-&gt;w = w; p -&gt; nextArc = lg-&gt;a[u]; //将新的边结点插入单链表的最前面 lg-&gt;a[u] = p; lg-&gt;e ++; return OK;&#125; //邻接表的删除边Status Remove(LGraph *lg,int u,int v)&#123; ENode *p,*q; if(u &lt; 0 || v &lt; 0 || u &gt; lg-&gt;n-1 || v &gt; lg-&gt;n-1 || u == v) return ERROR; p = lg-&gt;a[u]; q = NULL; while(p &amp;&amp; p-&gt;adjVex != v)&#123; //查找待删除边是否存在 q = p; p = p-&gt;nextArc; &#125; if(!p) return NotPresent; if(q) q-&gt;nextArc = p-&gt;nextArc; //从单链表删除此边 else lg-&gt;a[u] = p-&gt;nextArc; free(p); lg-&gt;e --; return OK;&#125; void BFS(LGraph lg,int v,int visited[])&#123; ENode *j; Queue q; Create(&amp;q,lg.n); visited[v] = 1; printf(\"%d\", v); EnQueue(&amp;q,v); //访问的节点入队 while( !IsEmpty(&amp;q) )&#123; //一直到该层没有节点为止 Front(&amp;q,&amp;v); // 取出父节点 DeQueue(&amp;q); for (j=lg.a[v]; j!= NULL;j=j-&gt;nextArc )&#123; if ( !visited[j-&gt;adjVex])&#123; visited[j-&gt;adjVex] = 1; printf(\"%d\", j-&gt;adjVex); EnQueue(&amp;q,j-&gt;adjVex); &#125; &#125; &#125;&#125;void BFSGraph(LGraph lg)&#123; int i; int *visited = (int *)malloc(sizeof(int)* lg.n); //记录n个节点的访问情况 for(i=0; i&lt; lg.n;i++) visited[i] = 0; //visted数组初始化 for (int i = 0; i &lt; lg.n; ++i) if( !visited[i] ) BFS(lg,i,visited); free(visited);&#125;void DFS(LGraph lg,int v,int visited[])&#123; ENode *j; printf(\"%d\",v ); visited[v] = 1; for (j = lg.a[v];j!=NULL;j= j-&gt;nextArc) //lg.a链表的循环 if( !visited[j-&gt;adjVex] ) DFS(lg,j-&gt;adjVex,visited);&#125;void DFSGraph(LGraph lg)&#123; int i; int *visited = (int *)malloc(sizeof(int)* lg.n); //记录n个节点的访问情况 for(i=0; i&lt; lg.n ; i++) visited[i] = 0; //visted数组初始化 for (int i = 0; i &lt; lg.n; ++i) if( !visited[i] ) DFS(lg,i,visited); free(visited);&#125; int main()&#123; LGraph g; int i,u,v,enode,edge; ElemType w; printf(\"Enter the number of mgraph's Nodes:\"); scanf(\"%d\",&amp;enode); Init(&amp;g,enode); printf(\"Enter the mgraph's Edge num:\"); scanf(\"%d\",&amp;edge); for(i = 0;i &lt; edge;i ++)&#123; printf(\"Please enter the edge(Pu,Pv,Weight):\"); scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); Insert(&amp;g,u,v,w); &#125; printf(\"DFS:\"); DFSGraph(g); printf(\"\\nBFS:\"); BFSGraph(g); printf(\"\\n\"); system(\"pause\"); return 0;&#125; 以上大多直接从学长的博客搬运过来. 3.5- 飞机换乘最短距离(Dijkstra单源最短路径) 编写程序，实现智能交通中的最佳路径选择问题：设有n个地点，编号为0~n-1，m条路径的起点、终点和代价由用户输入提供，采用实验3.1所示邻接矩阵为存储结构，寻找最佳路径方案(如花费时间最少、路径长度最短、交通费用最小等，任选其一即可)。 借了学长的整体框架,将邻接矩阵改成了邻接表,并完成了题目要求的给定起点、终点，算最短路径。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define ERROR 0#define OK 1#define Overflow 2 //表示上溢#define Underflow 3 //表示下溢#define NotPresent 4 //表示元素不存在#define Duplicate 5 //表示有重复元素#define INFTY 32657 //表示正无穷#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status;typedef int BOOL;//邻接表的结构体定义typedef struct ENode&#123; int adjVex; //任意顶点u相邻的顶点 ElemType w; //边的权值 struct ENode *nextArc; //指向下一个边结点&#125;ENode; typedef struct&#123; int n; //图的当前顶点数 int e; //图的当前边数 ENode **a; //指向一维指针数组&#125;LGraph; //邻接表的初始化Status Init(LGraph *lg,int nSize)&#123; int i; lg-&gt;n = nSize; lg-&gt;e = 0; lg-&gt;a = (ENode**)malloc(nSize*sizeof(ENode*)); //动态生成长度为n的一维指针数组 if(!lg-&gt;a) return ERROR; for(i = 0;i &lt; lg-&gt;n;i ++) lg-&gt;a[i] = NULL; //将指针数组a置空 return OK;&#125; //邻接表的撤销int Destory(LGraph *lg)&#123; int i; ENode *p,*q; for(i = 0;i &lt; lg-&gt;n;i ++)&#123; //链表的撤销操作 p = lg-&gt;a[i]; //指针p指向顶点i的单链表的第一个边结点 q = p; while(p)&#123; //释放顶点i的单链表中所有边结点 p = p-&gt;nextArc; free(q); q = p; &#125; &#125; free(lg-&gt;a); //释放一维指针数组a的存储空间 return OK; //改为int型函数,有返回值&#125; //邻接表的搜索边Status Exist(LGraph *lg,int u,int v)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1 ||v &gt; lg-&gt;n-1 ||u == v) return ERROR; p = lg-&gt;a[u]; //指针p指向顶点u的单链表的第一个边结点 while(p!=NULL &amp;&amp; p-&gt;adjVex != v)&#123; p = p-&gt;nextArc; &#125; if(!p) return ERROR; else return OK;&#125; //邻接表的插入边Status Insert(LGraph *lg,int u,int v,ElemType w)&#123; ENode *p; if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1||v &gt; lg-&gt;n-1 ||u == v) return ERROR; if(Exist(lg,u,v)) return Duplicate; //此边已存在,返回错误 p = (ENode*)malloc(sizeof(ENode)); //为新的边结点分配存储空间 p-&gt;adjVex = v; p-&gt;w = w; p -&gt; nextArc = lg-&gt;a[u]; //将新的边结点插入单链表的最前面 lg-&gt;a[u] = p; lg-&gt;e ++; return OK;&#125; //邻接表的删除边Status Remove(LGraph *lg,int u,int v)&#123; ENode *p,*q; if(u &lt; 0 || v &lt; 0 || u &gt; lg-&gt;n-1 || v &gt; lg-&gt;n-1 || u == v) return ERROR; p = lg-&gt;a[u]; q = NULL; while(p &amp;&amp; p-&gt;adjVex != v)&#123; //查找待删除边是否存在 q = p; p = p-&gt;nextArc; &#125; if(!p) return NotPresent; if(q) q-&gt;nextArc = p-&gt;nextArc; //从单链表删除此边 else lg-&gt;a[u] = p-&gt;nextArc; free(p); lg-&gt;e --; return OK;&#125; //选出最小的d[i],i ∈ V-Sint Choose(int d[],int n,int s[])&#123; int minpos; int i; ElemType min; min = INFTY; minpos = -1; for(i = 0;i &lt; n;i ++)&#123; //这里i初值改为0 if( d[i] &lt;= min &amp;&amp; !s[i])&#123; //&lt;改为&lt;= // printf(\"Choose: d[%d]:%d \",i, d[i]); //可以将这段注释打开理解 min = d[i]; minpos = i; &#125; &#125; return minpos; //返回下标位置&#125; //Dijkstra算法Status Dijkstra(LGraph g,int v,int d[],int path[])&#123; int i,k,w,distance = 0; //增加了一个distance记录最短距离之和 int *s; if(v &lt; 0 || v &gt; g.n-1) return ERROR; ENode *j; /*对辅助数据结构的初始化*/ s = (int*)malloc(g.n*sizeof(int)); /*非源点结点初始化*/ for(i = 0;i &lt; g.n;i ++)&#123; s[i] = 0; //表示顶点i是否在s中 for( j=g.a[v];j!=NULL; j=j-&gt;nextArc) if(j-&gt;adjVex == i ) d[i] = j-&gt;w; //v到i的距离 if(i != v &amp;&amp; d[i] &lt; INFTY) path[i] = v; //如果与源点有边相通,标识指向i的源点v else path[i] = -1; &#125; /*源点初始化*/ s[v] = 1; //顶点v为源点,将原点v加入集合S printf(\"The order:%d \",v); //输出源点0 d[v] = 0; /*对辅助数据结构的初始化*/ for(i = 1;i &lt;= g.n-1;i ++)&#123; //最多产生n-1条最短路径,&lt;改为&lt;= k = Choose(d, g.n ,s); //求当前路径最短者k s[k] = 1; //将k加入集合S中 printf(\"%d \",k); for( j = g.a[k]; j!=NULL; j= j-&gt;nextArc)&#123; //更新d和path if( !s[j-&gt;adjVex] &amp;&amp; d[k] + j-&gt;w &lt; d[ j-&gt;adjVex ])&#123; //未被访问过,且 当前边+到前个结点的权值 &lt; 现在的路径长度 //j-&gt;adjVex为所有与v相邻接的顶点 d[j-&gt;adjVex ] = d[k] + j-&gt;w; distance = d[j-&gt;adjVex ]; //计算所有路径中的min距离 path[j-&gt;adjVex ] = k; &#125; &#125; &#125; return OK;&#125; int main()&#123; LGraph g; int nSize,edge,u,v,i; int s,t; //起点,终点 int d[100]; for(int i=0;i&lt;100;i++) d[i] = INFTY; int path[100]; ElemType w; printf(\"Enter the number of mgraph's Nodes:\"); scanf(\"%d\",&amp;nSize); Init(&amp;g,nSize); printf(\"Enter the mgraph's Edge num:\"); scanf(\"%d\",&amp;edge); for(i = 0;i &lt; edge;i ++)&#123; printf(\"Please enter the edge(Pu,Pv,Weight):\"); scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); Insert(&amp;g,u,v,w); &#125; printf(\"Enter the Start Point :\"); scanf(\"%d\",&amp;s); printf(\"Enter the Destination Point :\"); scanf(\"%d\",&amp;t); Dijkstra(g,0,d,path); printf(\"\\nThe shortest distance from %d to Point %d:%d\\n\",s,t, d[t]); system(\"pause\"); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"},{"name":"图论","slug":"图论","permalink":"https://nymrli.top/tags/图论/"},{"name":"实验作业","slug":"实验作业","permalink":"https://nymrli.top/tags/实验作业/"}]},{"title":"数据结构——图","slug":"数据结构——图","date":"2018-12-16T03:41:46.000Z","updated":"2019-09-15T08:07:31.067Z","comments":true,"path":"2018/12/16/数据结构——图/","link":"","permalink":"https://nymrli.top/2018/12/16/数据结构——图/","excerpt":"","text":"数据结构——图 连通图 无向图 连通图 : 图中任意两点都连通 连通:如果从v到w存在一条(无向)路径,则称v和w是连通的 **路径:**V到w的路径是一系列顶点{V,v1,V2，vn,w}的集合,其中任一对相邻的顶点间都有图中的边。路径的长度是路径中的边数(如果带权,则是所有边的权重和)。如果v到w之间的所有顶点都不同,则称简单路径 ▲路径是边的超集,一条路径中可以有多条边 回路:起点等于终点的路径 ==&gt; 有回路的路径为非简单路径 有向图: 强连通 : 有向图中顶点v和W之间存在双向路径,则称v和w是强连通的强连通图 强连通图 : 有向图中任意两顶点均强连通强连通分量:有向图的极大强连通子图 弱连通图 : 将有向图中边的方向擦去,能变成连通图的图叫 弱连通图 图不连通咋办? 非连通图 无向图 连通分量: 无向图的极大连通子图 极大顶点数 : 再加1个顶点就不连通了 极大边数 : 包含子图中所有顶点相连的所有边 图的边可以是具有某种属性的对象: 007案例中的岸边 最小代价生成树 基础概念 最小生成树问题 : 村村通—&gt; 使图连通的( 最少的边 \\ 花销最小的 ) 树 连通的 无回路 V个顶点 , v-1条边 生成 包含所有的顶点 V-1条边都在图里 任意加一条边都会构成回路 最小 边的权重和最小 ▲ 最小代价生成树不存在 &lt;----&gt; 图不连通 贪心算法: 贪: 每一步是最好的 好: 权重是最小的 约束: 只能用图里有的边 正好用掉 v-1条边 不能有回路 算法实现: Prim算法——让小树成长： kruskal——将森林合并成树: 更贪心,直接将权重最小的边收进来 拓补排序 AOV 以顶点来表示活动。 一个活动是另一个活动的先决条件 不断抹去 没有前驱顶点(入度为0) 的顶点 提倡的做法: 将入度为0的顶点放到容器中 ▲.这种方法还可以用来检测是不是有向无环图(DAG) 关键路径 AOE: 一般用于安排项目的工序 由绝不允许延误的活动组成的路径 关键路径长度: earliest(n) 没有机动时间的路径为关键路径","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"},{"name":"图论","slug":"图论","permalink":"https://nymrli.top/tags/图论/"}]},{"title":"win自带邮件使用","slug":"win自带邮件使用","date":"2018-12-16T02:48:27.000Z","updated":"2019-09-15T08:07:31.015Z","comments":true,"path":"2018/12/16/win自带邮件使用/","link":"","permalink":"https://nymrli.top/2018/12/16/win自带邮件使用/","excerpt":"","text":"Windows10 自带邮箱 创意大赛忘记提交附件的经历，让我决定这几天把邮箱的问题彻底解决了。 一.打开Windows自带的邮件 1.附件栏里 2.直接搜索&quot;邮件&quot; 二.添加账号 打开后界面是这样的,左边是我已经添加好的账号 1.点击下面的&quot;齿轮&quot; 2.点击&quot;管理账号&quot; 3.点击&quot;添加账户&quot; 将信息按规则填好后.需要注意的是▲.在按登录之前需要翻墙,否则会出现如图&quot;我们无法找到你的设置&quot;. 其次要注意的是,密码为IMAP或者POP、SMTP的密码，授权码查询如下 网易： 图一 图二： 图三： 此步他会要求你设置自己的授权码 QQ邮箱： 图一： 图二： 此步他会要求你发送“配置邮箱客户端”到某个号码上，然后会生成授权码。这个不是自己设置的 翻墙成功，在确保密码也正确的情况下就可以按“登录”了。 附录： 添加账号： 从“开始“中打开 附件自动下载: 下载的附件一般在C:\\Users\\账户名\\AppData\\Local\\Packages\\microsoft.windowscommunicationsapps_邮箱代码\\LocalState\\Files\\S0\\1055（我的在1055里）","categories":[],"tags":[{"name":"邮件","slug":"邮件","permalink":"https://nymrli.top/tags/邮件/"},{"name":"Window10","slug":"Window10","permalink":"https://nymrli.top/tags/Window10/"}]},{"title":"2018-12-15小记","slug":"2018-12-15小记","date":"2018-12-15T14:22:25.000Z","updated":"2019-09-15T08:07:30.907Z","comments":true,"path":"2018/12/15/2018-12-15小记/","link":"","permalink":"https://nymrli.top/2018/12/15/2018-12-15小记/","excerpt":"","text":"数据结构上机,由于最近烦心事也比较多,没有任何准备,在机房想要自己把代码敲出来也是不现实的。于是，就搜吧。无意中搜到了学长的博客,大二转计科，看了他努力的点滴，也颇有感触，于是下笔，略述己见。 之前一直在博客里都是发的技术性的文章，有时想说点话，也找不到合适的人。发条说说，不懂的人不知所措，懂的人也无从安慰，于是也只好作罢。也曾想过在博客里写，太又感觉未免太过矫情，今日所感，还是决定记录些情感、回忆。 大一上报了院科协与校科协，入大学前已经略有琢磨过C语言学习的我自然没有再接着学C，于是趁着Python的大热，也正是听说了Python的简洁、可以做爬虫、网站、人工智能等有趣的时就决定学了这门语言。于是加入了Python组，碰到了李林伟与王宇学长，李林伟学长很负责，大一的课几乎都是由他授的，当初还有事嫌他讲的不够好，现在自己当了讲师后才发现根本无暇准备。大一的时光很多都泡在了图书馆，一个学期下来已经借了20+本书了，整个学年下来一共借了40+本书，虽然没有全部看完，都明显的感觉到自己的努力。大二一般都是在看视频，图书馆很少去了，书也借的少了。 大一还学了单片机，说来也可惜，第一次院级比赛优之杰做了个所有授课内容如 蜂鸣器、LCD1602、跑马灯、矩阵按键 的作品已经很了不起了，就没有再深入学些什么，不知那些更优秀的人已经开始准备电赛、飞思卡尔了。很遗憾吧，最终在下学期的4月份“海善达杯”结束后就再也没碰过单片机，所有学过的单片机代码也逐渐忘却。 大二，一直呆在学科楼220，但没有怎么忙Apollo的项目，说来也比较惭愧。这半个学期也已经过了，感觉自己一直在忙些奇奇怪怪的事，学了前端HTML、CSS、JS；还学了微信小程序，为的就是想参加一些比赛，但到如今却都凉了。为了天翼杯做了个物联网的猫粮，但是天翼杯初赛就被刷；参加创意大赛，结果自己忘记提交附件了；同时，学长的不看好，让我也对完成点子的作品产生了怀疑：这种没技术含量的作品真的能获奖吗？无论如何，最近也得不到答案了。这让我对开发产生了一种厌恶与疲倦，下学期想好好弄弄算法或是机器学习了，静下心来弄点真技术。 有的时候真的会比较迷茫吧？考研还是工作的问题，每隔一段时间都会思考。昨天的分光计无疑让我又一次受挫。准备了3天的物理实验，结果最后誊错数据，同时也是最后几个离开实验室的。确实，分光计真的很简单，但有模糊的地方、以及平时没解决放过的地方在你最薄弱的时候就可能一下子要了你的命。无法确定是否要修正、无法确定是否要算θ0……导致没有一开始就画表，导致了最后的誊错，感觉像是命中注定，就如同创意大赛的没有提交。最近过的很背，期望能够有个水逆退散、柳暗花明。","categories":[],"tags":[{"name":"生活小记","slug":"生活小记","permalink":"https://nymrli.top/tags/生活小记/"}]},{"title":"Python中邮件的发送","slug":"Python中邮件的发送","date":"2018-12-12T14:17:38.000Z","updated":"2020-11-12T08:15:50.837Z","comments":true,"path":"2018/12/12/Python中邮件的发送/","link":"","permalink":"https://nymrli.top/2018/12/12/Python中邮件的发送/","excerpt":"","text":"Python普通的邮件发送 需要一个安全的连接，例如SSL，因此接下来我们会使用SSL的方式去登录，但是在那之前，我们需要做一些准备，打开qq邮箱，点击设置-&gt;账户，找到POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务，开启IMAP/SMTP服务，然后根据要求使用手机发送到指定号码，获取授权码，这个授权码就是你接下来登录要使用的密码. 123456789101112131415161718from email.mime.text import MIMETextimport smtplib_user = '1063052964@qq.com'_pwd = 'pykhotuhghdjbeci'_to = '2035420834@qq.com'msg = MIMEText(mail_body) //MIMEText中_subtype默认为plain,html格式,只需改这个参数msg[\"Subject\"] = '来自[不吐不快]网站的网友意见'msg[\"From\"] = _usermsg[\"To\"] = _totry: s = smtplib.SMTP_SSL(\"smtp.qq.com\", 465) # 或是使用s = smtplib.SMTP(\"smtp.qq.com\",25) s.login(_user, _pwd) s.sendmail(_user, _to, msg.as_string()) s.quit() message = '感谢你的来信'except: message = '发送失败' ▲smtplib.SMTP_SSL([host[, port[, local_hostname[, keyfile[, certfile[, timeout]]]]]]) 这是一个派生自SMTP的子类，通过SSL加密的套接字连接（使用此类，您需要使用SSL支持编译的套接字模块）。如果未指定主机，则使用“（本地主机）”。如果省略端口，则使用标准的SMTP-over-SSL端口（465） 本机已安装了支持 SMTP 的服务，如：sendmail: 12345import smtplibfrom email.mime.text import MIMETextfrom email.header import Headermessage[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;) 第三方SMTP发送邮件: 1234567import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddrmsg[&apos;From&apos;]=formataddr([&quot;FromRunoob&quot;,my_sender]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号msg[&apos;To&apos;]=formataddr([&quot;FK&quot;,my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号*没有formataddr的昵称默认为账号* Python 发送带附件的邮件: 发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/python# -*- coding: UTF-8 -*- import smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.header import Header sender = 'from@runoob.com'receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 #创建一个带附件的实例message = MIMEMultipart()message['From'] = Header(\"菜鸟教程\", 'utf-8')message['To'] = Header(\"测试\", 'utf-8')subject = 'Python SMTP 邮件测试'message['Subject'] = Header(subject, 'utf-8') #邮件正文内容message.attach(MIMEText('这是菜鸟教程Python 邮件发送测试……', 'plain', 'utf-8')) # 构造附件1，传送当前目录下的 test.txt 文件att1 = MIMEText(open('test.txt', 'rb').read(), 'base64', 'utf-8')att1[\"Content-Type\"] = 'application/octet-stream'# 这里的filename可以任意写，写什么名字，邮件中显示什么名字att1[\"Content-Disposition\"] = 'attachment; filename=\"test.txt\"'message.attach(att1) # 构造附件2，传送当前目录下的 runoob.txt 文件att2 = MIMEText(open('runoob.txt', 'rb').read(), 'base64', 'utf-8')att2[\"Content-Type\"] = 'application/octet-stream'att2[\"Content-Disposition\"] = 'attachment; filename=\"runoob.txt\"'message.attach(att2) try: smtpObj = smtplib.SMTP('localhost') smtpObj.sendmail(sender, receivers, message.as_string()) print \"邮件发送成功\"except smtplib.SMTPException: print \"Error: 无法发送邮件\" 在 HTML 文本中添加图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python# -*- coding: UTF-8 -*- import smtplibfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.header import Header sender = 'from@runoob.com'receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 msgRoot = MIMEMultipart('related') //创建MIMEMultipart()实例msgRoot['From'] = Header(\"菜鸟教程\", 'utf-8')msgRoot['To'] = Header(\"测试\", 'utf-8')subject = 'Python SMTP 邮件测试'msgRoot['Subject'] = Header(subject, 'utf-8') msgAlternative = MIMEMultipart('alternative')msgRoot.attach(msgAlternative) mail_msg = \"\"\"&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;&lt;p&gt;&lt;a href=\"http://www.runoob.com\"&gt;菜鸟教程链接&lt;/a&gt;&lt;/p&gt;&lt;p&gt;图片演示：&lt;/p&gt;&lt;p&gt;&lt;img src=\"cid:image1\"&gt;&lt;/p&gt;\"\"\"msgAlternative.attach(MIMEText(mail_msg, 'html', 'utf-8')) //内容 # 指定图片为当前目录fp = open('test.png', 'rb')msgImage = MIMEImage(fp.read())fp.close() # 定义图片 ID，在 HTML 文本中引用msgImage.add_header('Content-ID', '&lt;image1&gt;')msgRoot.attach(msgImage) //附件 try: smtpObj = smtplib.SMTP('localhost') smtpObj.sendmail(sender, receivers, msgRoot.as_string()) print \"邮件发送成功\"except smtplib.SMTPException: print \"Error: 无法发送邮件\" Python SMTP发送邮件 flask-email 官方文档 阻塞发送 最简单的调用 123456789101112131415161718from flask import Flaskfrom flask_mail import Mail,Messageapp = Flask(__name__)app.config['MAIL_SERVER'] = 'smtp.qq.com'app.config['MAIL_PORT'] = 587app.config['MAIL_USE_TLS'] = Trueapp.config['MAIL_USERNAME'] = '1063052964@qq.com'app.config['MAIL_PASSWORD'] = '#'mail = Mail(app)msg = Message('邮件主题', sender='1063052964@qq.com', recipients=['2035420834@qq.com'])msg.body = '邮件内容'msg.html = \"&lt;h1&gt;邮件的html模板&lt;h1&gt; body\"with app.app_context(): mail.send(msg) 读取配置+视图函数中调用 [config.py] 123456789# 配置邮箱信息MAIL_SERVER = 'smtp.qq.com'MAIL_PORT = 465MAIL_USE_TLS = FalseMAIL_USE_SSL = True# 注意此处，很多人配置发不出去和这个是有关系的MAIL_PASSWORD = '**********'MAIL_USERNAME = '********@qq.com'# qq郵箱默認走ssl，所以創建的smtp對象必須要支持加密傳輸，且需要指定port=465 app.py 123456789101112131415161718192021222324252627from flask import Flaskfrom flask_mail import Message,Mailfrom threading import Threadimport configapp = Flask(__name__)app.config.from_object(config)mail = Mail(app)def sendMail(): msg = Message('test', sender = '1063052964@qq.com', recipients=[\"2035420834@qq.com\"]) # recipients是个列表，包含所有收件人 # 此处的test是邮箱的主题，sender和config中的MAIL_USERNAME要一致哦 msg.body = '123' msg.html = '&lt;b&gt;test&lt;/b&gt;body' mail.send(msg)@app.route('/')def hello_world(): sendMail() return 'Hello World!'if __name__ == '__main__': app.run(debug=True) tips:tip：具体工程中，配置可以写在单独一个文件如”.env”，然后利用python-envcfg来读取配置，如： app.config.from_object(‘envcfg.raw’) 异步发送 12345678910111213141516171819202122232425262728293031323334353637from flask import Flaskfrom flask_mail import Message,Mailfrom threading import Threadimport configapp = Flask(__name__)app.config.from_object(config)mail = Mail(app)def send_async_email(app,msg): with app.app_context(): mail.send(message=msg)def SendMail(): msg = Message('test',sender='106305964@qq.com',\\ recipients=[\"870545361@qq.com\"]) # recipients是个列表，包含所有收件人 # 此处的test是邮箱的主题，sender和config中的MAIL_USERNAME要一致哦 msg.body = 'testbody' msg.html = '&lt;b&gt;test&lt;/b&gt;body' # 邮件发送给目标，可以有文本，两种方式呈现，你能看见怎样的取决于你的客户端 thr = Thread(target=send_async_email,args=[app,msg]) # 使用多线程，在实际开发中，若是不使用异步、多线程等方式，网页会卡住 thr.start() return 'ok'@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run(debug=True) ▲. 许多Flask的扩展都是假定自己运行在一个活动的应用和请求上下文中，Flask-Mail的send函数使用到current_app 这个上下文了，所以当 mail.send()函数在一个线程中执行的时候需要人为的创建一个上下文。在示例 send_async_email 中使用了 app.app_context() 来创建一个上下文。 既然异步的邮件发送功能已经实现了，如果将来我们需要实现其它异步的函数，还有什么需要改进的吗？我们需要为每一个实现异步功能的函数拷贝多线程的代码吗？这并不好。 我们可以通过实现一个 装饰器 来解决这个问题。有了装饰器，上面的代码可以修改为: 123456789101112from .decorators import async@asyncdef send_async_email(app, msg): with app.app_context(): mail.send(msg)def send_email(subject, sender, recipients, text_body, html_body): msg = Message(subject, sender=sender, recipients=recipients) msg.body = text_body msg.html = html_body send_async_email(app, msg) 好的多了吧，对不对？ 这个神奇的代码其实很简单。我们把它放入一个新文件(文件 app/decorators.py): 1234567from threading import Threaddef async(f): def wrapper(*args, **kwargs): thr = Thread(target = f, args = args, kwargs = kwargs) thr.start() return wrapper 作为一个练习，大家可以考虑考虑如何用 *multiprocessing* 模块来实现上面的功能。 摘自flask文档 django.core.mail邮件 EmailMessage: 标题. 内容.发件人.收件人 1234from django.core.mail import send_mailsend_mail(u&apos;邮件标题&apos;, u&apos;邮件内容&apos;, &apos;from@example.com&apos;, [&apos;to@example.com&apos;], fail_silently=False) send_mail() subject, message, from_email and recipient_list 这四个参数是必须的。 subject: 字符串，表示邮件标题。 message: 字符串，表示邮件内容。 from_email: 字符串，表示发件邮箱。 recipient_list: 字符串列表，列表中每个成员都是一个邮箱地址，而且每个收件人都会在 “收件人/To:” 栏看到出现在 recipient_list 中的其他收件人。 fail_silently: （可选）布尔值。为 False 时， send_mail 会抛出 smtplib.SMTPException 异常。 smtplib 文档列出了所有可能的异常。 这些异常都是 SMTPException 的子类。 auth_user: （可选）SMTP服务器的认证用户名。没提供该参数的情况下，Django会使用 EMAIL_HOST_USER 配置项的设置。 auth_password: （可选）SMTP服务器的认证密码，没提供该参数的情况下，Django会使用 EMAIL_HOST_PASSWORD配置项的设置。 connection: （可选）发送邮件的后端。没提供该参数的情况下，Django会使用默认后端的实例。可查看 Email backends 了解更多细节。 send_mass_mail() 和 send_mail() 的区别在于： send_mail() 每发送一封邮件就会打开一次邮件服务器链接，而send_mass_mail() 则是打开一次链接，发送所有的邮件。 send_mass_mail() 明显更高效。 main_admins() mail_admins(subject, message, fail_silently=False, connection=None, html_message=None) django.core.mail.mail_admins() 是一个给网站后台管理员(admin)发邮件的快捷方法，管理员设置放在 ADMINS 配置项。 mail_admins() 使用 EMAIL_SUBJECT_PREFIX 配置项的值做为邮件标题的前缀，默认情况下是 &quot;[Django] &quot; 。 mail_managers() mail_managers`(subject, message, fail_silently=False, connection=None, html_message=None) mail_managers(*subject*, *message*, *fail_silently=False*, *connection=None*, *html_message=None*)django.core.mail.mail_managers()is just likemail_admins()，不同之处在于该方法的邮件接收人是网站负责人(manager)， 可以在 [MANAGERS`]配置项设置网站负责人 EmailMessage 对象 *class *EmailMessage EmailMessage 类使用下列参数初始化（除非使用位置参数，否则默认顺序如下）。所有参数均可选，均可在调用 send()方法之前的任何时间对其赋值。 加入了 cc 参数（cc是抄送） subject: 邮件的标题行 body: 邮件的主体内容文本，须是纯文本信息。 from_email: 发送者的地址。 fred@example.com 或 Fred &lt;fred@example.com&gt; 格式都是合法的。如果忽略该参数，Django就会使用 DEFAULT_FROM_EMAIL 配置项。 to: 收件人地址列表或元组。 bcc: 发送邮件时用于”Bcc”头信息的一组列表或元组，也就是暗送的收件人。 connection: 一个邮件后端实例。用同一个链接发送多封邮件就要用到该参数。忽略该参数时，会在调用 send() 时自动创建一个新链接。 attachments: 置于邮件报文内的附件列表。列表元素可以是 email.MIMEBase.MIMEBase 实例，也可以是 (filename, content, mimetype) 三部分构成的元组。 headers: 置于邮件报文内的其他头信息(header)的字典。字典的key是头信息的名称，字典的value是头信息的值。 这样做能确保头信息的名称和对应值会以正确的格式保存于邮件报文中。 cc: 发送邮件时放于”Cc”头信息的一系列列表或元组。 例如: 123email = EmailMessage(&apos;Hello&apos;, &apos;Body goes here&apos;, &apos;from@example.com&apos;, [&apos;to1@example.com&apos;, &apos;to2@example.com&apos;], [&apos;bcc@example.com&apos;], headers = &#123;&apos;Reply-To&apos;: &apos;another@example.com&apos;&#125;) 该类方法如下: send(fail_silently=False) 发送邮件报文。如果在构造邮件时如果指定了某个链接(connection)，就会使用该链接发邮件。 否则，就会使用默认后端的实例发邮件。如果关键字参数 fail_silently 为 True ，就会忽略邮件发送时抛出的异常。 message() 构造了一个 django.core.mail.SafeMIMEText 对象 (Python的 email.MIMEText.MIMEText 类的子类) 或是 django.core.mail.SafeMIMEMultipart 对象（该对象保存即将发送出去邮件报文）。如需扩展 EmailMessage类，一般情况下要覆写该方法，将你所需的内容添加到MIME对象中。 recipients() 返回邮件中所有收件人的列表，不管收件人是在 to 还是 bcc 属性中。这是另一个经常被继承覆写的方法， 因为SMTP服务器在发送邮件报文时，要接收完整的收件人列表。即使你自己的类使用其他方式来指定收件人，也仍然需要使用该方法返回收件人列表。 attach() 创建一个新的文件附件，并把它添加到邮件报文中。 有两种方法调用 attach(): 传递一个单独的 email.MIMEBase.MIMEBase 实例做为参数。该实例会直接添加到最终的邮件报文中。 或者，给 attach() 传递三个参数: filename, content 和 mimetype. filename 是出现在邮件中的附件文件的名称， content 是附件的内容，而 mimetype 是附件所使用的MIME类型。 如果忽略 mimetype, Django会自动根据附件文件名来推测MIME内容类型。 例如: 1message.attach(&apos;design.png&apos;, img_data, &apos;image/png&apos;) attach_file() 使用当前文件系统下的某个文件做为附件。调用时，传入某个文件的完整路径，以及该附件的MIME类型(可选的)。 忽略MIME类型的话，Django会自动根据附件文件名来推测MIME类型。最简单的用法如下: 1message.attach_file(&apos;/images/weather_map.png&apos;) 发送多用途邮件 在同一封邮件中包含多种版本的内容是非常有用的；典型的例子就是发送既有纯文本版本内容又有HTML版本内容的邮件。 在Django的邮件库中，可以使用 EmailMultiAlternatives 类来达到该目的。 EmailMessage 的子类有一个attach_alternative() 方法用来包含其他版本的邮件主体内容。所有其他方法(包括类的初始化方法)都直接继承自 EmailMessage 。 发送一封文本/HTML混合邮件，代码如下: 12345678from django.core.mail import EmailMultiAlternativessubject, from_email, to = &apos;hello&apos;, &apos;from@example.com&apos;, &apos;to@example.com&apos;text_content = &apos;This is an important message.&apos;html_content = &apos;&lt;p&gt;This is an &lt;strong&gt;important&lt;/strong&gt; message.&lt;/p&gt;&apos;msg = EmailMultiAlternatives(subject, text_content, from_email, [to])msg.attach_alternative(html_content, &quot;text/html&quot;)msg.send() 默认情况下，EmailMessage 类中的 body 参数的MIME类型是 &quot;text/plain&quot; 。 大多数情况下，没必要更改该MIME，因为这样能保证每个收件人能够阅读该邮件，而不论他们使用的是什么邮件客户端。 不过，在能确保收件人能处理多用途邮件的情况下，可以使用:class:~django.core.mail.EmailMessage 类的 content_subtype 属性 来更改邮件内容类型。主类型总是 &quot;text&quot; ，子类型可以设置为别的版本(比如html)，例如: 123msg = EmailMessage(subject, html_content, from_email, [to])msg.content_subtype = &quot;html&quot; # 主内体现在变成 text/htmlmsg.send() 获取邮件发送后端的实例 123django.core.mail 的 get_connection() 函式返回你当前使用的邮件后端的实例。get_connection(backend=None, fail_silently=False, *args, **kwargs) SMTP backend --默认的后端 Console backend File backend --该后端并不建议在生产环境下使用–它仅仅是为开发提供方便 In-memory backend(内存后端) Dummy backend(空后端) 需要在 settings.py中设置的东西: 123456EMAIL_BACKEND = &apos;django.core.mail.backends.smtp.EmailBackend&apos;EMAIL_USE_SSL = TrueEMAIL_HOST = &apos;smtp.gmail.com&apos;EMAIL_PORT = 587EMAIL_HOST_USER = &apos;urusername@gmail.com&apos;EMAIL_HOST_PASSWORD = &apos;password&apos;","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://nymrli.top/tags/flask/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"使用Cerbot申请免费证书升级 http到https","slug":"使用Cerbot申请免费证书升级-http到https","date":"2018-12-08T08:10:03.000Z","updated":"2019-10-07T10:15:12.177Z","comments":true,"path":"2018/12/08/使用Cerbot申请免费证书升级-http到https/","link":"","permalink":"https://nymrli.top/2018/12/08/使用Cerbot申请免费证书升级-http到https/","excerpt":"","text":"使用 Cerbot 免费证书 简单 升级 http 到 https 1、安装 cerbot: 12git clone https://github.com/letsencrypt/letsencryptcd letsencrypt 要求： Python 2.7 Git环境 连接外网 2、运行: 12// 根据自己的需求调整代码./certbot-auto certonly --standalone --email admin@example.com -d example.com -d www.example.com -d other.example.net 成功提示: 12345678910IMPORTANT NOTES:Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/sast.nymrli.top/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/sast.nymrli.top/privkey.pem Your cert will expire on 2019-02-08. To obtain a new or tweaked version of this certificate in the future, simply run certbot-auto again. To non-interactively renew *all* of your certificates, run &quot;certbot-auto renew&quot; - If you like Certbot, please consider supporting our work by: 3、配置Nginx: server 不再监听80端口，因为TLS要使用的是443端口，然后引入证书和key 123456789server&#123; listen 443 ssl; server_name sast.nymrli.top; //这里是你的域名 index index_page.html; root /var/www/homework_submission-master/; //网站目录 ssl_certificate /etc/letsencrypt/live/sast.nymrli.top/fullchain.pem; //前面生成的证书，改一下里面的域名就行，不建议更换路径 ssl_certificate_key /etc/letsencrypt/live/sast.nymrli.top/privkey.pem; //前面生成的密钥，改一下里面的域名就行，不建议更换路径&#125; 重启Nginx： 1sudo service nginx restart OK! 问题解决: 1Problem binding to port 80: Could not bind to IPv4 or IPv6. 原因是 nginx 占用了80端口，输入service nginx stop。然后再次执行证书安装命令，即可顺利安装。安装完毕后，输入service nginx start，重启 nginx 服务。","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"}]},{"title":"pipenv 新款Python虚拟环境工具详解[转]","slug":"pipenv-新款Python虚拟环境工具详解-转","date":"2018-12-08T08:08:23.000Z","updated":"2019-09-15T08:07:30.969Z","comments":true,"path":"2018/12/08/pipenv-新款Python虚拟环境工具详解-转/","link":"","permalink":"https://nymrli.top/2018/12/08/pipenv-新款Python虚拟环境工具详解-转/","excerpt":"","text":"pipenv 新款Python虚拟环境工具详解[转] pipenv是requests库作者Kenneth Reitz编写的一个用于创建和管理Python虚拟环境的工具。 Pipenv是Python官方机构推荐的Python包工具。 我们知道，为了管理Python虚拟环境，通常用得比较多的是virtualenv和pyenv。但是有人觉得它们还不够好用，不够偷懒。这个人是谁，就是上面的那位。于是他开发了一个pipenv，结合了pip及virtualenv的功能和优点，集成出了pipenv这个工具。其目的是替代virtualenv和pyenv，将pip及virtualenv的功能集于一身。 一、安装pipenv windows下很简单： 1pip install pipenv Linux下： 1sudo pip install pipenv 在苹果操作系统下： 1$ brew install pipenv 也就是说，无法用pip管理的包，pipenv同样无法使用。 pipenv依赖：psutil, virtualenv-clone, pew, certifi, urllib3, chardet, requests, mccabe, pyflakes, pycodestyle, flake8等第三方模块。 pipenv有很漂亮的彩色终端界面。 二、简单使用 进入你的Python项目文件夹： 12cd your_projectpipenv install windows操作系统中，虚拟环境创建过程如下： 1234567891011121314151617D:\\test\\test_pipenv&gt;pipenv installCreating a virtualenv for this project…Using base prefix &apos;c:\\\\python36&apos;New python executable in C:\\Users\\Administrator\\.virtualenvs\\test_pipenv-XHxuOsjn\\Scripts\\python.exeInstalling setuptools, pip, wheel...done.Virtualenv location: C:\\Users\\Administrator\\.virtualenvs\\test_pipenv-XHxuOsjnCreating a Pipfile for this project…Pipfile.lock not found, creating…Locking [dev-packages] dependencies…Locking [packages] dependencies…Updated Pipfile.lock (c23e27)!Installing dependencies from Pipfile.lock (c23e27)… ================================ 0/0 - 00:00:00To activate this project&apos;s virtualenv, run the following: $ pipenv shell 如果你给命令添加–two或–three参数，它将分别使用Python2或3来初始化你的虚拟环境，否则将使用默认的Python版本。 注意：pipenv默认把虚拟环境的真实文件全都放在了C:\\Users\\Administrator\\.virtualenvs\\test_pipenv-XHxuOsjn\\Scripts\\python.exe中，而在实际的项目文件夹内只创建了两个新文件Pipfile和Pipfile.lock。这可能造成C盘存有大量的文件，不是个好的做法。（但好像无法修改这一路径…） 看一下Pipfile中的内容： 1234567891011[[source]]url = &quot;https://pypi.python.org/simple&quot;verify_ssl = truename = &quot;pypi&quot;[packages][dev-packages] 最关键的是定义了安装第三方库使用的源，默认为官方的pypi。 而Pipfile.lock文件内容呢？ 12345678910111213141516171819202122232425262728293031&#123; &quot;_meta&quot;: &#123; &quot;hash&quot;: &#123; &quot;sha256&quot;: &quot;5f0257fe8c7a73db1c8de519faa92c658282a01087eb2bfafba7962704c23e27&quot; &#125;, &quot;host-environment-markers&quot;: &#123; &quot;implementation_name&quot;: &quot;cpython&quot;, &quot;implementation_version&quot;: &quot;3.6.4&quot;, &quot;os_name&quot;: &quot;nt&quot;, &quot;platform_machine&quot;: &quot;AMD64&quot;, &quot;platform_python_implementation&quot;: &quot;CPython&quot;, &quot;platform_release&quot;: &quot;7&quot;, &quot;platform_system&quot;: &quot;Windows&quot;, &quot;platform_version&quot;: &quot;6.1.7601&quot;, &quot;python_full_version&quot;: &quot;3.6.4&quot;, &quot;python_version&quot;: &quot;3.6&quot;, &quot;sys_platform&quot;: &quot;win32&quot; &#125;, &quot;pipfile-spec&quot;: 6, &quot;requires&quot;: &#123;&#125;, &quot;sources&quot;: [ &#123; &quot;name&quot;: &quot;pypi&quot;, &quot;url&quot;: &quot;https://pypi.python.org/simple&quot;, &quot;verify_ssl&quot;: true &#125; ] &#125;, &quot;default&quot;: &#123;&#125;, &quot;develop&quot;: &#123;&#125;&#125; 初始情况下，文件里只包含一些操作系统的基本信息。 Pipfile和Pipfile.lock两个文件互相配合，完成虚拟环境的管理工作。 三、安装第三方模块 Pipfile包含关于项目的依赖包的信息，并取代通常在Python项目中使用的requirements.txt文件。 如果你在具有requirements.txt文件的项目中启动了Pipenv，则在把它从项目中删除之前，应该使用Pipenv安装该requirements中列出的所有依赖包。 使用pipenv创建虚拟环境后，进入pipfile所在目录，使用install命令安装第三方库。 例如： 1pipenv install django 这个时候，你其实把pipenv当作pip来使用。无需像virtualenv那样需要额外的先启动虚拟环境。pipenv区分你是在给哪个虚拟环境工作，依赖的是Pipfile文件的位置。 要卸载某个第三方库： 1pipenv uninstall beautifulsoup4 四、冻结Pipfile 冻结就相当于将项目所使用的第三方库列表进行打包输出，类似于virtualenv中生成requirements.txt文件。 通过更新Pipfile.lock来冻结库名称及其版本，以及其依赖关系的列表。需要使用lock参数： 1pipenv lock 如果另一个用户拷贝了你的项目，他们只需要安装Pipenv，然后： 1pipenv install Pipenv会在项目文件夹下自动寻找Pipfile和Pipfile.lock文件，创建一个新的虚拟环境并安装必要的软件包。 也就是说pipenv install的时候有三种逻辑： 如果目录下没有Pipfile和Pipfile.lock文件，表示创建一个新的虚拟环境； 如果有，表示使用已有的Pipfile和Pipfile.lock文件中的配置创建一个虚拟环境； 如果后面带诸如django这一类库名，表示为当前虚拟环境安装第三方库。 五、管理开发环境 通常有一些Python包只在你的开发环境中需要，而不是在生产环境中，例如单元测试包。 Pipenv使用–dev标志区分两个环境。 1pipenv install --dev django django库现在将只在开发虚拟环境中使用。如果你要在你的生产环境中安装你的项目： 1pipenv install 这不会安装django包。 但是，如果有一个开发人员将你的项目克隆到自己的开发环境中，他们可以使用–dev标志，将django也安装： 1pipenv install --dev 也就是说一个–dev参数，帮你在同一个虚拟环境中又区分出了开发和非开发环境。 六、在虚拟环境中运行命令 使用run参数，提供要运行的命令： 1pipenv run python manage.py runserver 这将使用当前虚拟环境关联的Python解释器，执行命令。 或者简单的执行脚本： 1pipenv run python your_script.py 如果你不想每次运行Python时都输入这么多字符，可以在shell中设置一个别名，例如， 1alias prp=&quot;pipenv run python&quot; 七、pipenv选项解释 pipenv 具有下列的选项： 12345678910111213141516171819$ pipenvUsage: pipenv [OPTIONS] COMMAND [ARGS]...Options: --update 更新Pipenv &amp; pip --where 显示项目文件所在路径 --venv 显示虚拟环境实际文件所在路径 --py 显示虚拟环境Python解释器所在路径 --envs 显示虚拟环境的选项变量 --rm 删除虚拟环境 --bare 最小化输出 --completion 完整输出 --man 显示帮助页面 --three / --two 使用Python 3/2创建虚拟环境（注意本机已安装的Python版本） --python TEXT 指定某个Python版本作为虚拟环境的安装源 --site-packages 附带安装原Python解释器中的第三方库 --jumbotron 不知道啥玩意.... --version 版本信息 -h, --help 帮助信息 pipenv 可使用的命令参数： 12345678910Commands: check 检查安全漏洞 graph 显示当前依赖关系图信息 install 安装虚拟环境或者第三方库 lock 锁定并生成Pipfile.lock文件 open 在编辑器中查看一个库 run 在虚拟环境中运行命令 shell 进入虚拟环境 uninstall 卸载一个库 update 卸载当前所有的包，并安装它们的最新版本 一些使用例子： 123456789101112Usage Examples: 使用Python 3.6创建虚拟环境: $ pipenv --python 3.6 安装包括开发环境中的第三方库: $ pipenv install --dev 锁定pipfile: $ pipenv lock --pre Install a local setup.py into your virtual environment/Pipfile: $ pipenv install -e . 八、一些使用过程展示 定位项目路径: 12$ pipenv --where/Users/kennethreitz/Library/Mobile Documents/com~apple~CloudDocs/repos/kr/pipenv/test 定位虚拟环境 12$ pipenv --venv/Users/kennethreitz/.local/share/virtualenvs/test-Skyy4vre 定位Python解释器： 12$ pipenv --py/Users/kennethreitz/.local/share/virtualenvs/test-Skyy4vre/bin/python 安装包： 12345678910$ pipenv installCreating a virtualenv for this project......No package provided, installing all dependencies.Virtualenv location: /Users/kennethreitz/.local/share/virtualenvs/test-EJkjoYtsInstalling dependencies from Pipfile.lock......To activate this project&apos;s virtualenv, run the following:$ pipenv shell 安装一个开发环境中才使用的包： 1234$ pipenv install pytest --devInstalling pytest......Adding pytest to Pipfile&apos;s [dev-packages]... 显示依赖关系： 123456$ pipenv graphrequests==2.18.4 - certifi [required: &gt;=2017.4.17, installed: 2017.7.27.1] - chardet [required: &gt;=3.0.2,&lt;3.1.0, installed: 3.0.4] - idna [required: &gt;=2.5,&lt;2.7, installed: 2.6] - urllib3 [required: &lt;1.23,&gt;=1.21.1, installed: 1.22] 生成lock文件: 123456$ pipenv lockAssuring all dependencies from Pipfile are installed...Locking [dev-packages] dependencies...Locking [packages] dependencies...Note: your project now has only default [packages] installed.To install [dev-packages], run: $ pipenv install --dev 安装开发环境依赖： 123456$ pipenv install --devPipfile found at /Users/kennethreitz/repos/kr/pip2/test/Pipfile. Considering this to be the project home.Pipfile.lock out of date, updating...Assuring all dependencies from Pipfile are installed...Locking [dev-packages] dependencies...Locking [packages] dependencies... 卸载所有的包： 12345$ pipenv uninstall --allNo package provided, un-installing all dependencies.Found 25 installed package(s), purging......Environment now purged and fresh! 使用虚拟环境的shell。exit退出： 123$ pipenv shellLoading .env environment variables…Launching subshell in virtual environment. Type &apos;exit&apos; or &apos;Ctrl+D&apos; to return. 本文来自刘江的博客和教程网站http://www.liujiangblog.com/blog/","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"#ifdef、#ifndef、#endif","slug":"ifdef、-ifndef、-endif","date":"2018-12-08T08:07:37.000Z","updated":"2019-09-15T08:07:30.944Z","comments":true,"path":"2018/12/08/ifdef、-ifndef、-endif/","link":"","permalink":"https://nymrli.top/2018/12/08/ifdef、-ifndef、-endif/","excerpt":"","text":"#ifdef、#ifndef、#endif使用说明 目的:防止头文件重复include 示例说明: a.h 12#include &lt;stdio.h&gt;#include &quot;b.h&quot; b.h 1#include &quot;a.h&quot; c.c 12345#include &quot;a.h&quot;#include &quot;b.h&quot;int main()&#123; printf(&quot;Hello!&quot;);&#125; 如果你程序是这样写的话，编译器就会出现Error #include nested too deeply的错误。 因为这里 b.h 和 a.h 都互相include，c.c文件在include的时候重复include了a.h，我们希望c.c文件中执行#include &quot;b.h&quot;的时候 b.h 能进行判断，如果没有#include &quot;a.h&quot;则include，如果已经include了，则不再重复定义。 可以将b.h修改为： 1234#ifndef _A_H#define _A_H #include &quot;a.h&quot;#endif 原因是: &gt; c.c中先include了a.h文件，其中a.h中又包括了b.h，所以会定义宏_A_H，当c,c中又includeb,h时判断_A_H是否已经被定义了,如果被定义了,则不再includea.h","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"小程序——高德地图API调用","slug":"小程序——高德地图API调用","date":"2018-12-06T09:11:14.000Z","updated":"2019-09-15T08:07:31.048Z","comments":true,"path":"2018/12/06/小程序——高德地图API调用/","link":"","permalink":"https://nymrli.top/2018/12/06/小程序——高德地图API调用/","excerpt":"","text":"小程序——高德地图API调用 配置 将压缩包解压至使用的小程序目录下，创建libs文件夹，包含amap-wx.js 导入使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var amapFile = require('..­/../../../libs/amap-wx.js');Page(&#123; data: &#123; src: '' &#125;, onLoad: function () &#123; var that = this; var myAmapFun = new amapFile.AMapWX(&#123; key: \" dbb8be907441c2650218bdfd78848cf6\" &#125;); wx.getSystemInfo(&#123; success: function (data) &#123; //获得手机屏幕的高度宽度 var height = data.windowHeight; var width = data.windowWidth; var size = width + \"*\" + height; myAmapFun.getStaticmap(&#123; location: \"118.9301,32.109\", //地图中心 zoom: 15, //缩放比例 size: size, //尺寸大小 scale: 2, //像素,普通图、高清图 markers: //标记 \"large,0xFF0000,A:118.9301,32.109|mid,0xFF0000,B:118.9301,32.110\", success: function (data) &#123; that.setData(&#123; src: data.url &#125;) &#125;, fail: function (info) &#123; wx.showModal(&#123; title: info.errMsg &#125;) &#125; &#125;) &#125; &#125;) &#125;, onReady: function () &#123; &#125;, onShow: function () &#123; &#125;, onHide: function () &#123; &#125;, onUnload: function () &#123; &#125;, onPullDownRefresh: function () &#123; &#125;, onReachBottom: function () &#123; &#125;, onShareAppMessage: function () &#123; &#125;&#125;) API使用说明 参数名称 含义 规则说明 是否必填 默认值 key 用户唯一标识 用户在高德地图官网申请 必填 无 location 地图中心点 中心点坐标。规则：经度和纬度用&quot;,&quot;分隔 经纬度小数点后不得超过6位。 部分条件必填 无 zoom 地图级别 地图缩放级别:[1,17] 可选 无 size 地图大小 图片宽度图片高度。最大值为10241024 可选 400*400 scale 普通/高清 1:返回普通图；2:调用高清图，图片高度和宽度都增加一倍，zoom也增加一倍（当zoom为最大值时，zoom不再改变）。 可选 1 markers 标注 使用规则见markers详细说明，标注最大数10个 可选 无 labels 标签 使用规则见labels详细说明，标签最大数10个 可选 无 paths 折线 使用规则见paths详细说明，折线和多边形最大数4个 可选 无 traffic 交通路况标识 底图是否展现实时路况。 可选值： 0，不展现；1，展现。 可选 0 sig 数字签名 数字签名认证用户必填 可选 无 markers: 123markers:\"large,0xFF0000,A:118.9301,32.109|mid,0xFF0000,B:118.9301,32.110\",//ormarkers:\"large,0xFF0000,A:118.9301,32.109;B:118.9301,32.110\", 参数名称 说明 默认值 size 可选值： small,mid,large small color 选值范围：[0x000000, 0xffffff]例如：0x000000 black,0x008000 green,0x800080 purple,0xFFFF00 yellow,0x0000FF blue,0x808080 gray,0xffa500 orange,0xFF0000 red,0xFFFFFF white 0xFC6054 label [0-9]、[A-Z]、[单个中文字] 当size为small时，图片不展现标注名。 无 label，font ,bold, fontSize，fontColor，background 自定义markersStyle: -1，url，0。 -1表示为自定义图片，URL为图片的网址。自定义图片只支持PNG格式。 https://restapi.amap.com/v3/staticmap?markers=-1,http://ico.ooopic.com/ajax/iconpng/?id=158688.png,0:116.37359,39.92437&amp;key=您的key labels labels=labelsStyle1:location1;location2|labelsStyle2:location3;location4..|labelsStyleN:locationN;locationM labelsStyle：label, font, bold, fontSize, fontColor, background。 各参数使用&quot;,&quot;分隔，如有默认值则可为空。 参数名称 说明 默认值 content 标签内容，字符最大数目为15 无 font 0：微软雅黑；1：宋体；2：Times New Roman;3：Helvetica 0 bold 0：非粗体；1：粗体 0 fontSize 字体大小，可选值[1,72] 10 fontColor 字体颜色，取值范围：[0x000000, 0xffffff] 0xFFFFFF background 背景色，取值范围：[0x000000, 0xffffff] 0x5288d8 paths paths=pathsStyle1:location1;location2..|pathsStyle2:location3;location4..|pathsStyleN:locationN;locationM.. ▲.LocationN : 118.9301,32.109先经度后维度 pathsStyle：weight, color, transparency, fillcolor, fillTransparency 参数名称 说明 默认值 weight 线条粗细。可选值： [2,15] 5 color 折线颜色。 选值范围：[0x000000, 0xffffff]例如：0x000000 black,0x008000 green,0x800080 purple,0xFFFF00 yellow,0x0000FF blue,0x808080 gray,0xffa500 orange,0xFF0000 red,0xFFFFFF white 0x0000FF transparency 透明度。可选值[0,1]，小数后最多2位，0表示完全透明，1表示完全不透明。 1 fillcolor 多边形的填充颜色，此值不为空时折线封闭成多边形。取值规则同color 无 fillTransparency 填充面透明度。可选值[0,1]，小数后最多2位，0表示完全透明，1表示完全不透明。 0.5 折线示例: 1paths: &apos;10,0x0000ff,1,,:116.31604,39.96491;116.320816,39.966606;116.321785,39.966827;116.32361,39.966957&apos;, 区域示例: 1paths: &quot;10,0x0000ff,0.1,0x0000ff,0.7:116.31604,39.96491;116.320816,39.966606;116.321785,39.966827;116.32361,39.966957;116.39361,39.966957;116.39361,39.936957&quot;,","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"HTML和CSS学习","slug":"HTML和CSS学习","date":"2018-12-06T02:57:32.000Z","updated":"2019-09-15T08:07:30.944Z","comments":true,"path":"2018/12/06/HTML和CSS学习/","link":"","permalink":"https://nymrli.top/2018/12/06/HTML和CSS学习/","excerpt":"","text":"HTML学习 &lt;head&gt;中的&lt;meta&gt;标签 属性 值 描述 http-equiv content-typeexpiresrefreshset-cookie 把 content 属性关联到 HTTP 头部。 name authordescriptionkeywordsgeneratorrevisedothers 把 content 属性关联到一个名称。 scheme some_text 定义用于翻译 content 属性值的格式。 name 属性 name 属性提供了名称/值对中的名称。 “keywords” 是一个经常被用到的名称。它为文档定义了一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。 1&lt;meta name=&quot;keywords&quot; content=&quot;HTML,ASP,PHP,SQL&quot;&gt; ▲如果没有提供 name 属性，那么名称/值对中的名称会采用 http-equiv 属性的值。 http-equiv 属性 http-equiv 属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。 使用带有 http-equiv 属性的 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。例如，添加： 12&lt;meta http-equiv=&quot;charset&quot; content=&quot;iso-8859-1&quot;&gt;&lt;meta http-equiv=&quot;expires&quot; content=&quot;31 Dec 2008&quot;&gt; 这样发送到浏览器的头部就应该包含： 123content-type: text/htmlcharset:iso-8859-1expires:31 Dec 2008 content 属性 content 属性提供了名称/值对中的值。该值可以是任何有效的字符串。 content 属性始终要和 name 属性或 http-equiv 属性一起使用。 标签 &lt;em&gt;和&lt;strong&gt;标签是为了强调一段话中的关键字时使用，它们的语义是强调。 &lt;span&gt;标签是没有语义的，它的作用就是为了设置单独的样式用的。 &lt;q&gt;引用文本&lt;/q&gt;,注意要引用的文本不用加双引号，浏览器会对q标签自动添加双引号。 &lt;blockquote&gt;引用长文本&lt;/blockquote&gt; 使用&lt;br&gt;标签分行显示文本 空格&amp;nbsp; 认识&lt;hr /&gt;标签，添加水平横线 &lt;address&gt;标签，为网页加入地址信息 &lt;code&gt;var i=i+300;&lt;/code&gt;一行代码 &lt;pre&gt;语言代码段&lt;/pre&gt;大段代码 使用&lt;ul&gt;，添加新闻信息列表 创建表格table的四个元素： tbody：如果不加&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt; , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。 tr表格的一行，所以有几对tr 表格就有几行。 th表格表头。 td一行中数据单元格的个数。 &lt;caption&gt;标题文本&lt;/caption&gt; &lt;table summary=&quot;表格简介文本&quot;&gt;摘要 CSS学习 Q:CSS样式可以写在哪些地方呢？ A: 内联式 : 把css代码直接写在现有的HTML标签中 &lt;p style=&quot;color:red&quot;&gt;这里文字是红色。&lt;/p&gt; 嵌入式 : 把css样式代码写在&lt;style type=&quot;text/css&quot;&gt;&lt;/style标签之间，一般情况下嵌入式css样式写在&lt;head&gt;&lt;/head&gt;之间 12345&lt;style type=&quot;text/css&quot;&gt;span&#123;color:red;&#125;&lt;/style&gt; 外部式 : 把css代码写一个单独的外部文件中,这个css样式文件以“.css”为扩展名 &lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; ▲.三种方法的优先级 内联式 &gt; 嵌入式 &gt; 外部式 嵌入式&gt;外部式有一个前提：嵌入式css样式的位置一定在外部式的后面 ==&gt;其实总结来说，就是--就近原则（离被设置元素越近优先级别越高）。 权值: 标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100 12345p&#123;color:red;&#125; /*权值为1*/p span&#123;color:green;&#125; /*权值为1+1=2*/.warning&#123;color:white;&#125; /*权值为10*/p span.warning&#123;color:purple;&#125; /*权值为1+1+10=12*/#footer .note p&#123;color:yellow;&#125; /*权值为100+10+1=111*/ 还有一个权值比较特殊–继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。 ==&gt;根据权值和层叠的想法: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 提高权值的方法:重要性 12p&#123;color:red!important;&#125;p.first&#123;color:green;&#125; CSS格式化排版 字体 font-family: 字体 body{font-family:&quot;宋体&quot;;} font-size:字号 body{font-size:12px;color:#666} 1234p span&#123;font-weight:bold;&#125; //粗体p a&#123;font-style:italic;&#125; //斜体p a&#123;text-decoration:underline;&#125; //下划线.oldPrice&#123;text-decoration:line-through;&#125; //删除线 段落排版 text-indent:段落缩进 p{ text-indent:2em;} 行间距（行高） p{ line-height:1.5em;} 中文字间距、字母间距 h1{ word-spacing:50px;} 为块状元素中的文本、图片设置居中样式 h1{ text-align:center;} 元素分类 块状元素(block) 1&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行） 2、元素的高度、宽度、行高以及顶和底边距都可设置。 3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 内联元素(又叫行内元素):inline 1&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 1、和其他元素都在一行上； 2、元素的高度、宽度及顶部和底部边距不可设置； 3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 内联块状元素(inline-block） 1&lt;img&gt;、&lt;input&gt; 1、和其他元素都在一行上； 2、元素的高度、宽度、行高以及顶和底边距都可设置。 盒子模型 块级元素都具有盒子模型的特征 外边距 : marigin 内边距 : padding 边框 : border 盒模型–宽度和高度 元素的实际高度为 : 自身height+ padding-top +padding-bottom 元素的实际宽度为 : 自身width+ padding-left +padding-right ▲ 一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 总宽度计算: 开发工具查看: 边框: border-style（边框样式）常见样式有： dashed（虚线）| dotted（点线）| solid（实线） border-color（边框颜色）中的颜色可设置为十六进制颜色，如: border-color:#888;//前面的井号不要忘掉。 border-width（边框宽度）中的宽度也可以设置为： thin | medium | thick（但不是很常用），最常还是用像素（px）。 css布局模型 1、流动模型（Flow） 2、浮动模型 (Float) 3、层模型（Layer） 流动模型（Flow） 流动（Flow）是默认的网页布局模式. 2个比较典型的特征： 第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。 第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行） 浮动模型 (Float) 想让两个块状元素并排显示…任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动， 1234567/*实现两个 div 元素一行显示。*/div&#123; width:200px; height:200px; border:2px red solid; float:left;&#125; 层模型（Layer） 如何让html元素在网页中精确定位，就像图像软件PhotoShop中的图层一样可以对每个图层能够精确定位操作 1、绝对定位(position: absolute) 将元素从文档流中拖出来，然后使用left(距离左)、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口 2、相对定位(position: relative) 相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于**以前的位置移动，**移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 Q:什么叫做“偏移前的位置保留不动” A: 虽然div元素相对于以前的位置产生了偏移，但是div元素以前的位置还是保留着，所以后面的span元素是显示在了div元素以前位置的后面。 ===&gt; 所占的位置不变,但是显示的位置发生了变化. 3、固定定位(position: fixed) 与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身. 由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响， 用途 : 可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。 水平居中设置 行内元素 如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的 块状元素 定宽~ : 宽度width为固定值 通过设置“左右margin”值为“auto”来实现居中的 不定宽~ 加入 table 标签 table长度自适应性,其长度根据其内文本长度决定 12345678910111213&lt;div&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt; &lt;ul&gt; &lt;li&gt;我是第一行文本&lt;/li&gt; &lt;li&gt;我是第二行文本&lt;/li&gt; &lt;li&gt;我是第三行文本&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; css代码： 123456&lt;style&gt;table&#123; border:1px solid; margin:0 auto;&#125;&lt;/style&gt; ▲补充代码实现右侧中的 class 为 wrap 的 div 水平居中显示（要注意是这个 div元素 居中，而不是里面的文本居中啊）。 设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置 改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。如下例子： html代码： 123456789&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; css代码： 1234567891011121314151617&lt;style&gt;.container&#123; text-align:center;&#125;/* margin:0;padding:0（消除文本与div边框之间的间隙）*/.container ul&#123; list-style:none; margin:0; padding:0; display:inline;&#125;/* margin-right:8px（设置li文本之间的间隔）*/.container li&#123; margin-right:8px; display:inline;&#125;&lt;/style&gt; ▲ 改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。如下例子： 父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的 代码如下： 123456789&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; css代码： 1234567891011121314151617&lt;style&gt;.container&#123; float:left; position:relative; left:50%&#125;.container ul&#123; list-style:none; margin:0; padding:0; position:relative; left:-50%;&#125;.container li&#123;float:left;display:inline;margin-right:8px;&#125;&lt;/style&gt; 垂直居中 父元素高度确定的单行文本 通过设置父元素的 height 和 line-height 高度一致来实现的。 1234567&lt;style&gt;.container&#123; height:100px; line-height:100px; background:#999;&#125;&lt;/style&gt; 父元素高度确定的多行文本、图片 使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。 html代码： 12345678910111213&lt;body&gt;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=\"wrap\"&gt; &lt;div&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt; css代码： 12345table td&#123; height:500px; background:#ccc&#125;/*因为 td 标签默认情况下就默认设置了 vertical-align 为 middle，所以我们不需要显式地设置了。*/ 在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的display为 table-cell（设置为表格单元显示），激活 vertical-align 属性 html代码： 1234567&lt;div class=\"container\"&gt; &lt;div&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; css代码： 12345678&lt;style&gt;.container&#123; height:300px; background:#ccc; display:table-cell;/*IE8以上及Chrome、Firefox*/ vertical-align:middle;/*IE8以上及Chrome、Firefox*/&#125;&lt;/style&gt; 隐性改变display类型 position : absolute float : left 或 float:right 只要html代码中出现以上两句之一，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"HTML","slug":"HTML","permalink":"https://nymrli.top/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://nymrli.top/tags/CSS/"}]},{"title":"Pyinstaller使用","slug":"Pyinstaller使用","date":"2018-12-03T03:54:22.000Z","updated":"2019-09-15T08:07:30.972Z","comments":true,"path":"2018/12/03/Pyinstaller使用/","link":"","permalink":"https://nymrli.top/2018/12/03/Pyinstaller使用/","excerpt":"","text":"pyinstaller使用 安装 1、安装pywin32==&gt;pyinstaller依赖于 下载安装文件：查找到跟自己适用的python版本及window系统版本匹配的pywin32，下载后安装 使用pip命令安装：pip install pywin32 2、安装Pyinstaller 下载安装文件安装：官网 使用pip命令安装：pip install PyInstaller 使用Pycharm直接搜索pyinstaller会自动安装依赖库pywin32 使用 1、使用下载安装的方式安装的Pyinstaller打包方式 将需要打包的文件放在解压得到的Pyinstaller文件夹中，打开cmd窗口，把路径切换到当前路径打开命令提示行，输入以下内容（最后的是文件名）==&gt;调用pyinstaller.py文件打包： python pyinstaller.py -F myfile.py 2、使用pip方式安装的Pyinstaller打包方式 打开cmd窗口，把路径切换到文件所在路径(文件随便放在哪里都行)打开命令提示行，输入以下内容（最后的是文件名）： pyinstaller -F myfile.py 使用实例 pyinstaller -F test.py -i src\\logo.ico -F 表示生成单个可执行文件 -w 表示去掉控制台窗口，这在GUI界面时非常有用。不过如果是命令行程序的话那就把这个选项删除吧！ -p 表示你自己自定义需要加载的库路径，一般情况下用不到 -i 表示可执行文件的图标 ▲. -i的参数为.ico格式,其他格式的图片会报错 文件中使用了第三方库的打包方式 在打包之前务必找到第三方库的包，把包复制到到跟myfile.py同目录下，然后再使用以上2种方式打包，否则会打包失败或者即使打包成功，程序也会闪退。 pyqt5打包出现错误 一 、当写这篇文章的时候，pyinstaller官网版本对pyqt5打包可能会遇到Could not find QtWebEngineProcess.exe.的错误。解决方法为：安装最新的pyinstaller 1.在github下载新版本的开发包。 2.打开解压后的文件夹，shift+鼠标右键，点击“在此处打开命令窗口”。之后依次运行如下命令: 123pip uninstall pyinstallerpython setup.py buildpython setup.py install 二 、如果有报错：“could not find or load the Qt platform plugin &quot;windows&quot; ”。原因之一可能是你把打包后的文件放在了中文目录下。只需要将打包后的文件放在英文目录下，就可以解决。 多文件打包 1234pyinstaller [主文件] -p [其他文件1] -p [其他文件2] --hidden-import [自建模块1] --hidden-import [自建模块2]# 以上为一整条命令 1pyinstaller main.py -p mysql.py -p other.py --hidden-import mysql --hidden-import other","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"pyqt5与QT5","slug":"pyqt与QT5","date":"2018-11-26T04:11:52.000Z","updated":"2019-09-17T09:44:06.126Z","comments":true,"path":"2018/11/26/pyqt与QT5/","link":"","permalink":"https://nymrli.top/2018/11/26/pyqt与QT5/","excerpt":"","text":"Pyqt5和QT5 拖拽式布局 添加QT Designer、PyUIc、Pyrcc 1.添加外部工具(Extenal Tools) QT Designer File–&gt;Settings–&gt;Tools–&gt;Extenal Tools --&gt; ‘’+’’ &gt; 添加具体细节,如图一图二 ​ 图一 ​ 图二 修改Name为QT Designer,Program为QT目录下designer.exe文件,不需要参数,Work directory为D:\\QT\\{QT version}\\msvc2015_64\\bin 添加后就可以在菜单栏的Tools中找到…点击后,就可以直接打开QT Designer设计窗口 QT Designer QT UIC 1.Program设置为当前虚拟环境的python解释器python.exe,(一旦设置好后,每次新建虚拟环境,pycharm会自动帮你修改选择的解释器) 2.▲.Arguments参数设置为: 12345-mPyQt5.uic.pyuic$FileName$-o$FileNameWithoutExtension$.py 这个参数主要是用uic这个工具需要指定的参数 3.working directory设置为$FileDir$(当前文件目录)===&gt;含义是:根据.UI生成的py窗口文件的位置 完成后,效果如图…一开始是没有window.py 将光标选择window.ui文件,然后选择Tools里面的PyUIC就可以自动生成一个window.py文件直接使用了. 控制台输出内容: 123G:\\PyGui\\venv\\Scripts\\python.exe -m PyQt5.uic.pyuic window.ui -o window.py#点击PyUIC就相当于输出了在setting里面写好的代码,$FileName$为我们光标选择的文件名,输出的名字为$FileNameWithoutExtension$.py,输出的路径为当前文件目录$FileDir$Process finished with exit code 0 QT Rcc 1.将program设置为QT目录下的rcc.exe文件 2.设置Arguments为 123$FileName$-o$FileNameWithoutExtension$.py 道理同上-o 是输出的意思 3.work directory设置为$FileDir$ 4.新建.qrc资源文件 打开QT Designer选择下面的资源管理器,单击铅笔,如图操作 单击左边蓝色的存储后,意思是指定.qrc文件存储位置 选择好以后,再操作右边的选择卡,填好前缀,然后点击蓝色的按键,选择要添加的资源文件(如图片什么的) 此时打开.qrc文件就可以看到他指定了哪些资源文件 上述步骤完成后就可以使用rcc工具将.qrc文件转换成.py的资源文件使用了 光标选择.qrc资源后,选择Pyrcc后就会生成相应的py文件 需要用到图片时,直接导入图片的.py文件即可 12[mainwindow.py]import picture 12345678910111213[main.py]#显示加载界面if __name__ == '__main__': app = QApplication(sys.argv) splash = QSplashScreen(QPixmap(':/load/loading.jpg')) splash.show() splash.showMessage('正在加载请稍等..') time.sleep(0.5) app.processEvents() ui = caofunction.MyWindow() ui.show() splash.finish(ui) sys.exit(app.exec_()) Main.py 123456789import sysimport caofunctionfrom PyQt5.QtWidgets import QApplication, QMainWindowif __name__ == &apos;__main__&apos;: app = QApplication(sys.argv) ui = caofunction.MyWindow() ui.show() sys.exit(app.exec_()) 12345678启动窗口的run()函数# if __name__ == &quot;__main__&quot;:# app = QtWidgets.QApplication(sys.argv)# Dialog = QtWidgets.QDialog()# ui = Ui_Dialog()# ui.setupUi(Dialog)# Dialog.show()# sys.exit(app.exec_()) 槽函数.py 12345678910111213from PyQt5 import QtWidgetsfrom PyQt5.QtWidgets import QMessageBoximport helloclass MyWindow(QtWidgets.QMainWindow,hello.Ui_MainWindow): def __init__(self,parent=None): QtWidgets.QMainWindow.__init__(self,parent) # super(MyWindow,self).__init__() self.setupUi(self) self.pushButton_2.clicked.connect(self.pint) def pint(self): my_choice = QMessageBox.information(self,&apos;提示框&apos;,&apos;Maybe wrong&apos;) 一个bottom最好只对应一个槽函数。 信号与槽连接函数： 123456self.pushButton_2.clicked.connect(Ui_MainWindow.pint)*connect()括号中可以选为/Ui_MainWindow/（父类类名）,/MainWindow/（父类中实例窗口名），/继承父类Ui_MainWindow的子类类名/，还有一种/self.pint/*★/*Qt5中的槽函数不在限定必须是slot，可以是普通的函数、类的普通成员函数、lambda函数等*/▲注意是pint，而不是pint(),传入的是函数的名称（函数地址）△如果在子类和父类中重复了connect，则会被执行多遍 QMessageBox: information question warning critial about aboutQT 用户输入对话框： 12345678my_choice = QInputDialog.getText(self,&apos;字符串&apos;,&apos;请在此处输入&apos;,QLineEdit.Normal,&apos;...&apos;)返回的是一个元祖(str,bool)my_choice = QInputDialog.getText(self,&apos;字符串&apos;,&apos;请在此处输入&apos;,2，0,30)//最后2：最小和最大返回的是一个元祖(int,bool)---my = [&apos;apple&apos;,&apos;orange&apos;]my_choice = QtWidgets.QInputDialog.getItem(self,&apos;输入框&apos;,&apos;请在此输入&apos;,my)■.pyqt5中没有Qstring类型，所以没有QString() 加载界面设计： 1234567891011if __name__ == &apos;__main__&apos;: app = QApplication(sys.argv) splash = QSplashScreen(QPixmap(&apos;:/test/3.jpg&apos;)) splash.show() splash.showMessage(&apos;正在加载请稍等&apos;) time.sleep(0.5) app.processEvents() ui = caofunction.MyWindow() ui.show() splash.finish(ui) sys.exit(app.exec_()) 转化.qrc资源文件为py文件： -o ui_form.py form.ui1CMD: pyrcc5 -o picture.py picture.qrc 菜单栏 1234567class MyWindow(QtWidgets.QMainWindow,hello.Ui_MainWindow): def __init__(self,parent=None): QtWidgets.QMainWindow.__init__(self,parent) self.action_4.triggered.connect(self.exit) def exit(self): self.close() 类中再定义函数时，定义和调用应为: 123456789101112self.mostphoto(file_path)#调用def mostphoto(self,filename): import re with open(filename, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f: data = f.read() times = re.findall(re.compile(r&quot;(\\d\\d):\\d\\d:\\d\\d&quot;), data) phototimes = re.findall(re.compile(r&quot;[图片]&quot;), data) if (len(phototimes) &gt; (len(times) - len(phototimes))): QMessageBox.information(self,&apos;提示框&apos;,&apos;两位斗图鬼才用表情包征服了彼此&apos;) else: QMessageBox.information(self,&apos;提示框&apos;,&apos;情话绵绵，爱情已融入生活中的点滴&apos;) 弹出对话框： 12my_info = Dialog()my_info.exec_() QApplication类代表应用程序，在每个程序中只能有一个它的实例。在有图形界面的程序中必须有一个QApplication类的实例，并且必须在所有窗口类的实例生成之前生成。它最主要的功能是实现主事件循环。在主事件循环内，窗口才可以相应消息，并对事件做出处理。QApplication类的exec方法代表启动主事件循环.在主事件循环内，窗口才可以响应消息，并对事件做出处理。QApplication类的exec方法代表启动主事件循环，这个函数在正常运行时不会返回，只有当主事件循环退出时才返回，通常这也就意味着整个程序要退出。 ​ QApplication类的构造函数接受与main函数相同的参数，它也能够处理执行程序时的命令行参数。这里的参数传递是必需的，因为在执行程序时要用到QApplication类才能识别的-qws参数。 本文来自 Tyrion-Lannister 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/HMSIWTV/article/details/7533524?utm_source=copy pyQT使用教程","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"机器学习——数学概念","slug":"机器学习——数学概念","date":"2018-11-24T05:00:34.000Z","updated":"2019-09-15T08:07:31.080Z","comments":true,"path":"2018/11/24/机器学习——数学概念/","link":"","permalink":"https://nymrli.top/2018/11/24/机器学习——数学概念/","excerpt":"","text":"箱线图 箱线图（Box plot）也称箱须图（Box-whisker Plot）、箱线图、盒图，可以用来反映一组或多组连续型定量数据分布的中心位置和散布范围，因形状如箱子而得名。 - 连续型数据：在一定区间内可以任意取值的变量叫连续变量，其数值是连续不断的。例如，生产零件的规格尺寸，人体测量的身高、体重等，其数值只能用测量或计量的方法取得。可视化这类数据的图表主要有箱形图和直方图。 - 离散型数据：数值只能用自然数或整数单位计算的则为离散变量。例如，企业个数，职工人数，设备台数等，只能按计量单位数计数，数值一般用计数方法取得。大多数图表可视化的都是这类数据，比如柱状图、折线图等。 优点: 箱形图最大的优点就是不受异常值的影响，能够准确稳定地描绘出数据的离散分布情况，同时也利于数据的清洗。 箱子上的线 四分位数 Q1:第一四分位数(下四分位数) Q2:中位数 Q3:第三四分位数(上四分位数) 一组数据按照从小到大顺序排列后，把该组数据四等分的数，称为四分位数。第一四分位数 (Q1)、第二四分位数 (Q2，也叫“中位数”)和第三四分位数 (Q3)分别等于该样本中所有数值由小到大排列后第25%、第50%和第75%的数字。第三四分位数与第一四分位数的差距又称四分位距（interquartile range, IQR）。 **箱子的高度在一定程度上反映了数据的波动程度 上下线 上下边缘则代表了该组数据的最大值和最小值 上限 :上限是非异常范围内的最大值。 下限:下限是非异常范围内的最小值。 有时候箱子外部会有一些点，可以理解为数据中的“异常值”。 偏态 与正态分布相对，指的是非对称分布的偏斜状态。在统计学上，众数和平均数之差可作为分配偏态的指标之一：如平均数大于众数，称为正偏态（或右偏态）；相反，则称为负偏态（或左偏态）。 偏态表示偏离程度，异常值集中在较小值一侧，则分布呈左偏态；异常值集中在较大值一侧，则分布呈右偏态。 Confusion_martrix(混淆矩阵) 混淆矩阵: 一种特定的矩阵用来呈现算法性能的可视化效果，通常是监督学习（非监督学习，通常用匹配矩阵：matching matrix） 其每一列代表预测值，每一行代表的是实际的类别。这个名字来源于它可以非常容易的表明多个类别是否有混淆（也就是一个class被预测成另一个class）。 Example样例说明: 假设有一个用来对猫（cats）、狗（dogs）、兔子（rabbits）进行分类的系统，混淆矩阵就是为了进一步分析性能而对该算法测试结果做出的总结。假设总共有 27 只动物：8只猫， 6条狗， 13只兔子。结果的混淆矩阵如下图： 在这个混淆矩阵中，实际有 8只猫，但是系统将其中3只预测成了狗；对于 6条狗，其中有 1条被预测成了兔子，2条被预测成了猫。从混淆矩阵中我们可以看出系统对于区分猫和狗存在一些问题，但是区分兔子和其他动物的效果还是不错的。所有正确的预测结果都在对角线上，所以从混淆矩阵中可以很方便直观的看出哪里有错误，因为他们呈现在对角线外面。 Table of confusion(混淆表格) 有时也称混淆矩阵. 由false positives，false negatives，true positives和true negatives组成的两行两列的表格。它允许我们做出更多的分析，而不仅仅是局限在正确率.。 它允许我们做出更多的分析，而不仅仅是局限在正确率。准确率对于分类器的性能分析来说，并不是一个很好地衡量指标，因为如果数据集不平衡（每一类的数据样本数量相差太大），很可能会出现误导性的结果。例如，如果在一个数据集中有95只猫，但是只有5条狗，那么某些分类器很可能偏向于将所有的样本预测成猫。整体准确率为95%，但是实际上该分类器对猫的识别率是100%，而对狗的识别率是0%。 对于上面的说明样例，其对应的对猫这个类别的混淆表格如下： 假定一个实验有 P个positive实例，在某些条件下有 N 个negative实例。那么上面这四个输出可以用下面的偶然性表格（或混淆矩阵）来表示： 更多详情见博客 摘自博客 : https://blog.csdn.net/vesper305/article/details/44927047","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"数学知识","slug":"数学知识","permalink":"https://nymrli.top/tags/数学知识/"}]},{"title":"机器学习——python实践.笔记","slug":"机器学习——Python实践-笔记","date":"2018-11-23T13:20:18.000Z","updated":"2019-09-15T08:07:31.078Z","comments":true,"path":"2018/11/23/机器学习——Python实践-笔记/","link":"","permalink":"https://nymrli.top/2018/11/23/机器学习——Python实践-笔记/","excerpt":"","text":"机器学习——Python实践 Numpy: python开源数值计算拓展,用来存储和处理大型矩阵,提供了许多高级的数值编程工具,如 矩阵数据类型、矢量处理、精密的运算库 利用Numpy数组来准备机器学习算法的数据 matplotlib: python中最著名的2D绘图库,适合交互式的进行制图;也可作为绘图空间,嵌入GUI应用程序中 创建图表,展示数据 Pandas: 基于Numpy的工具,为了解决数据分析任务而创建的.~纳入了大量库和标准的数据模型,提供了操作大型数据集的工具,和快速便捷处理数据的函数和方法 导入、展示数据，以便挣钱对数据的理解和数据清洗、转换等工作 预测模型所需的六个步骤: 第一章： 鸢尾花(Iris Flower) 所有特征数据都是数字,不需要考虑如何导入和处理数据—&gt;有的图表有标题等的,需要处理- 分类问题===&gt;监督学习算法 多分类问题,可能需要一些特殊处理 所有特征的数值采用相同单位,不需要进行尺度转换 步骤: 1.导入数据集 123456789from pandas import read_csvfrom matplotlib import pyplotfrom sklearn.svm import SVCfilename = 'iris.data.csv'names = ['separ-length','separ-width','petal-length','petal-width','class']# 花萼长度+宽度 , 花瓣长度+宽度dataset = read_csv(filename,names = names)print(dataset) # 150 * 5 2.概述数据 从下列角度审查数据: 数据的维度 查看数据的自身 统计描述所有的数据特征 数据分类的分布情况 1.数据的维度 了解数据集中有多少行数据,数据有几个属性 12print('数据的维度: 行 %s , 列 %s' % (dataset.shape))#&gt;&gt;&gt;数据的维度: 行 150 , 列 5 2.参看数据本身 直观的看到数据的特征,数据的类型,以及大概的数据分布范围 12345678print(dataset.head(5))&gt;&gt;&gt; separ-length separ-width ... petal-width class0 5.1 3.5 ... 0.2 Iris-setosa1 4.9 3.0 ... 0.2 Iris-setosa2 4.7 3.2 ... 0.2 Iris-setosa3 4.6 3.1 ... 0.2 Iris-setosa4 5.0 3.6 ... 0.2 Iris-setosa 3.统计描述数据 数据特征的统计描述信息包括数据的行数、中位值、最大值、最小值、均值、四分位值等统计数据信息 1234567891011print(dataset.describe())&gt;&gt;&gt; separ-length separ-width petal-length petal-widthcount 150.000000 150.000000 150.000000 150.000000mean 5.843333 3.054000 3.758667 1.198667std 0.828066 0.433594 1.764420 0.763161min 4.300000 2.000000 1.000000 0.10000025% 5.100000 2.800000 1.600000 0.30000050% 5.800000 3.000000 4.350000 1.30000075% 6.400000 3.300000 5.100000 1.800000max 7.900000 4.400000 6.900000 2.500000 4.数据分类分布 了解数据在不同分类的分布情况…==&gt;每个分类数据量的绝对数值 1234567print(dataset.groupby('class').size())&gt;&gt;&gt;classIris-setosa 50Iris-versicolor 50Iris-virginica 50dtype: int64 ▲ 如果数据分布不平衡,可能会影响到模型的准确性,…==&gt;不平衡时,需要对数据进行调整,方法有: 扩大数据样本 通常容易被忽略的选择…但往往找到更大的数据集就有可能挖掘出更平衡的方面提高算法准确度 数据的重新抽样 过抽样(复制少数类样本)…数据少时考虑 欠抽样(删除多数类样本)…数据多时考虑 尝试生成人工样本 从少数类的实例中随机抽样特征属性,生成更多数据 异常检测和变化检测 尝试从不同观点思考,异常检测是对罕见事件的检测,将小类作为异常值类 3.数据可视化 单变量图表: 理解每一个特征属性 多变量图表: 理解不同特征属性之间的关系 单变量图: 箱线图: 一种用作显示一组数据分散情况资料的统计图。因形状如箱子而得名。 主要用于反映原始数据分布的特征，还可以进行多组数据分布特征的比 较。箱线图的绘制方法是：先找出一组数据的最大值、最小值、中位数和两个四分位数；然后， 连接两个四分位数画出箱子；再将最大值和最小值与箱子相连接，中位数在箱子中间。 12345678#箱线图 , 因为每个特征属性都是数字 , 所以 用箱线图展示 属性与中位值的离散程度dataset.plot(kind='box',subplots = True,layout = (2,2) , sharex = False , sharey = False)# 参数说明 : box箱线 , subplots 允许多个子图, layout 布局为2*2 , sharex.sharey 不共享x,ypyplot.show()#---#直方图 , x轴为值 , y轴为数量dataset.hist()pyplot.show() 多变量图: 12345from pandas.plotting import scatter_matrix#散点矩阵图scatter_matrix(dataset)pyplot.show()#pyplot.savefig(\"scatter_matrix.png\") 4.评估算法 分离出评估数据集 采用10折交叉验证来评估算法模型 生成6个不同的模型来预测新数据 选择最优模型 1.分离出评估数据集 ❤️要想知道算法模型对真是数据的准确度,所以保留一部分数据来评估算法模型. 12345678from sklearn.model_selection import train_test_splitarray = dataset.valuesX = array[:,0:4] #除了最后的class类别Y = array[:,4] #类别,目标validation_size = 0.2 #验证比例seed = 7 #随机种子X_train , X_validation , Y_train , Y_validation = \\ train_test_split(X,Y,test_size=validation_size,random_state=seed) 2.评估模式 采用10折交叉验证来分离训练数据集 : 随机将数据分成10份,9份用来训练模型,1份用来评估算法 3.创建模型 线性 线性回归(LR) 线性判别分析(LDA) 非线性 K近邻(KNN) 分类与回归树(CART) 贝叶斯分类器(NB) 支持向量机(SVM) ▲ 在每次对算法进行评估前都会重新设置随机数种子,以保证每次对算法的评估都是用相同的数据集 12345678910111213141516171819202122from sklearn.linear_model import LogisticRegression,LinearRegression #LRfrom sklearn.tree import DecisionTreeClassifier #CARTfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis #LDAfrom sklearn.naive_bayes import GaussianNB #NBfrom sklearn.neighbors import KNeighborsClassifier #KNNfrom sklearn.svm import SVC #SVMfrom sklearn.model_selection import KFold,cross_val_scoremodels = &#123;&#125;models['LR'] = LogisticRegression()models['LDA'] = LinearDiscriminantAnalysis()models['CART'] = DecisionTreeClassifier()models['NB'] = GaussianNB()models['KNN'] = KNeighborsClassifier()models['SVM'] = SVC()#评估算法resutls = []for key in models: kfold = KFold(n_splits=10,random_state=seed) cv_result = cross_val_score(models[key],X_train,Y_train,cv = kfold , scoring = 'accuracy') #cross_val_score将交叉验证的整个过程连接起来，不用再进行手动的分割数据, cv参数用于规定将原始数据分成多少份 resutls.append(cv_result) print(\"%s: %f (%f)\" % (key,cv_result.mean(),cv_result.std())) #均值,标准差 4.选择最优模型 1234567&gt;&gt;&gt;LR: 0.966667 (0.040825)LDA: 0.975000 (0.038188)CART: 0.966667 (0.040825)NB: 0.975000 (0.053359)KNN: 0.983333 (0.033333)SVM: 0.991667 (0.025000) 为什么使用 10折交叉验证? 进行模型验证的一个重要目的是要选出一个最合适的模型，对于监督学习而言，我们希望模型对于未知数据的泛化能力强，所以就需要模型验证这一过程来体现不同的模型对于未知数据的表现效果。 训练准确度==&gt;测试准确度 最先我们用训练准确度（用全部数据进行训练和测试）来衡量模型的表现，这种方法会导致模型过拟合(方差大)；===&gt;&gt;为了解决这一问题，我们将所有数据分成训练集和测试集两部分，我们用训练集进行模型训练，得到的模型再用测试集来衡量模型的预测表现能力，这种度量方式叫测试准确度，这种方式可以有效避免过拟合。 测试准确度==&gt;10折交叉验证 测试准确度的一个缺点是其样本准确度是一个高方差估计（high variance estimate）, 所以该样本准确度会依赖不同的测试集，其表现效果不尽相同。 12345678910111213for i in xrange(1,5): print \"random_state is \", i,\", and accuracy score is:\" X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=i) knn = KNeighborsClassifier(n_neighbors=5) knn.fit(X_train, y_train) y_pred = knn.predict(X_test) print metrics.accuracy_score(y_test, y_pred)&gt;&gt;&gt;random_state is 1 , and accuracy score is:1.0random_state is 2 , and accuracy score is:1.0random_state is 3 , and accuracy score is:0.947368421053random_state is 4 , and accuracy score is:0.973684210526 上面的测试准确率可以看出，不同的训练集、测试集分割的方法导致其准确率不同，而交叉验证的基本思想是：1.将数据集进行一系列分割，生成一组不同的训练测试集，2.然后分别训练模型并计算测试准确率，3.最后对结果进行平均处理。这样来有效降低测试准确率的差异。 K折交叉验证: 将数据集平均分割成K个等份子集 使用1份数据(子集)作为测试数据，其余(K-1)份作为训练数据 计算测试准确率 使用不同的测试集，重复2、3步骤 对测试准确率做平均，作为对未知数据预测准确率的估计 ==&gt; cross_val_score.mean() 不同的训练集、测试集分割的方法导致其准确率不同，而交叉验证的基本思想是：将数据集进行一系列分割，生成一组不同的训练测试集，然后分别训练模型并计算测试准确率，最后对结果进行平均处理。这样来有效降低测试准确率的差异。 来自周志华&lt;&lt;机器学习&gt;&gt;: 分割方法 1234# 下面代码演示了K-fold交叉验证是如何进行数据分割的# simulate splitting a dataset of 25 observations into 5 foldsfrom sklearn.cross_validation import KFoldkf = KFold(25, n_folds=5, shuffle=False) 12cv_result = cross_val_score(models[key],X_train,Y_train,cv = 10 , scoring = 'accuracy')#cross_val_score将交叉验证的整个过程连接起来，不用再进行手动的分割数据, cv参数用于规定将原始数据分成多少份 5.实施预测 12345678910111213141516171819#使用评估数据集评估算法svm = SVC()svm.fit(X = X_train ,y = Y_train) #参数为 X , ypredictions = svm.predict(X_validation)print(accuracy_score(Y_validation,predictions)) #测试集结果 与 预测结果 相比print(confusion_matrix(Y_validation,predictions))print(classification_report(Y_validation,predictions))&gt;&gt;&gt;0.9333333333333333[[ 7 0 0] [ 0 10 2] #混淆矩阵只出现了两个错误,2 [ 0 0 11]] precision(精确度) recall(召回率) f1-score(F1值) support(总和) Iris-setosa 1.00 1.00 1.00 7Iris-versicolor 1.00 0.83 0.91 12 Iris-virginica 0.85 1.00 0.92 11 avg / total 0.94 0.93 0.93 30 召回率(Recall Rate,也叫查全率) 是检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率； 精度(Precise) 是检索出的相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率。 TP: 预测为正，实际为正 (第一个是实际T或F,第二个是预测P或N) FP: 预测为正，实际为负 TN:预测为负，实际为负 FN: 预测为负，实际为正 精确率、准确率：Accuracy=(TP+TN)/(TP+TN+FN+FP) //精准率、查准率：P = TP/ (TP+FP) 召回率、查全率：R = TP/ (TP+FN) F1-score: 2*TP/(2*TP + FP + FN) ◆. 精确度是“搜索结果有多大用处”，而召回是“结果如何完整”。 F1分数: 概述 : 统计学中用来衡量二分类模型精确度的一种指标。它同时兼顾了分类模型的准确率和召回率。F1分数可以看作是模型准确率和召回率的一种加权平均，它的最大值是1，最小值是0。 人们通常使用准确率和召回率这两个指标，来评价二分类模型的分析效果。 但是当这两个指标发生冲突时，我们很难在模型之间进行比较。比如，我们有如下两个模型A、B，A模型的召回率高于B模型，但是B模型的准确率高于A模型，A和B这两个模型的综合性能，哪一个更优呢？ 准确率 召回率 A 80% 90% B 90% 80% 为了解决这个问题，人们提出了FβF_{\\beta}Fβ​ 分数。FβF_{\\beta}Fβ​的物理意义就是将准确率和召回率这两个分值合并为一个分值，在合并的过程中，召回率的权重是准确率的 β\\betaβ倍。F1F_{1}F1​分数认为召回率和准确率同等重要， F2F_{2}F2​ 分数认为召回率的重要程度是准确率的2倍，而分F0.5F_{0.5}F0.5​数认为召回率的重要程度是准确率的一半。 Fβ=(1+β2)⋅ precision recall(β2⋅ precision )+recallF _ { \\beta } = \\left( 1 + \\beta ^ { 2 } \\right) \\cdot \\frac { \\text { precision recall} } { \\left( \\beta ^ { 2 } \\cdot \\text { precision } \\right) + \\text {recall} }Fβ​=(1+β2)⋅(β2⋅ precision )+recall precision recall​ β=recall rateaccuracy rate\\beta = \\frac { \\text {recall rate} } { \\text {accuracy rate} }β=accuracy raterecall rate​ ▲ 如何计算Precise、Recall、F1-score见博客https://blog.csdn.net/akadiao/article/details/78788864 Confusion_martrix(混淆矩阵) 混淆矩阵: 一种特定的矩阵用来呈现算法性能的可视化效果，通常是监督学习（非监督学习，通常用匹配矩阵：matching matrix） 其每一列代表预测值，每一行代表的是实际的类别。这个名字来源于它可以非常容易的表明多个类别是否有混淆（也就是一个class被预测成另一个class）。 Example样例说明: 假设有一个用来对猫（cats）、狗（dogs）、兔子（rabbits）进行分类的系统，混淆矩阵就是为了进一步分析性能而对该算法测试结果做出的总结。假设总共有 27 只动物：8只猫， 6条狗， 13只兔子。结果的混淆矩阵如下图： 在这个混淆矩阵中，实际有 8只猫，但是系统将其中3只预测成了狗；对于 6条狗，其中有 1条被预测成了兔子，2条被预测成了猫。从混淆矩阵中我们可以看出系统对于区分猫和狗存在一些问题，但是区分兔子和其他动物的效果还是不错的。所有正确的预测结果都在对角线上，所以从混淆矩阵中可以很方便直观的看出哪里有错误，因为他们呈现在对角线外面。****","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://nymrli.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Pycharm里无法查看Sqlite数据表","slug":"Pycharm里无法查看Sqlite数据表","date":"2018-11-23T07:27:38.000Z","updated":"2019-09-15T08:07:30.971Z","comments":true,"path":"2018/11/23/Pycharm里无法查看Sqlite数据表/","link":"","permalink":"https://nymrli.top/2018/11/23/Pycharm里无法查看Sqlite数据表/","excerpt":"","text":"Pycharm里无法查看Sqlite数据表 听说Pycharm可以直接看数据库,于是试了试,发现无法读取sqlite数据库的内容…于是发现下载相应的驱动.如图 解决方法: 一.打开右侧的Database选项卡,选择Data Source的Sqlite 二.点击黄色三角Download下载相应的驱动软件 三.安装完成,正常使用","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://nymrli.top/tags/数据库/"}]},{"title":"flask-sqlalchemy使用与sqlalchemy对比","slug":"flask-sqlalchemy使用与sqlalchemy对比","date":"2018-11-23T07:22:48.000Z","updated":"2019-09-15T08:07:31.019Z","comments":true,"path":"2018/11/23/flask-sqlalchemy使用与sqlalchemy对比/","link":"","permalink":"https://nymrli.top/2018/11/23/flask-sqlalchemy使用与sqlalchemy对比/","excerpt":"","text":"flask-sqlalchemy使用与sqlalchemy对比 flask-sqlalchemy 12345678910111213141516171819202122232425from exts import dbclass MGroup(db.Model): __tablename__ = 'Group' id = db.Column(db.Integer, primary_key=True, autoincrement=True) name = db.Column(db.String(50),nullable=False,unique = True)class MUserinfo(db.Model): __tablename__ = 'Userinfo' id = db.Column(db.Integer,primary_key=True,autoincrement=True) stuid = db.Column(db.String(15),unique = True ,nullable=False) subject = db.Column(db.String(50), nullable=False) name = db.Column(db.String(10), nullable=False) qq = db.Column(db.Integer,nullable = False) dirction = db.Column(db.String(20),db.ForeignKey('Group.name'),default='3D仿真组')class Mmessage(db.Model): __tablename__ = 'Contact' id = db.Column(db.Integer,primary_key=True,autoincrement=True) name = db.Column(db.String(10), nullable=False) email = db.Column(db.String(20), nullable=False) subject = db.Column(db.String(20), nullable=False) message = db.Column(db.Text, nullable=False) sqlalchemy 123456789101112131415161718192021import sqlalchemyfrom sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmakerprint(sqlalchemy.__version__)engine = create_engine('sqlite:///test.db',echo = True) #将数据库执行的语句打印出来Base = declarative_base() #声明一个基类实例class User(Base): __tablename__ = 'User' #表的名称 #类的属性,而不是在析构函数中定义的原因是,Base类中有构造函数 Uid = sqlalchemy.Column(sqlalchemy.Integer,autoincrement=True,primary_key=True) name = sqlalchemy.Column(sqlalchemy.String(20),nullable=False) def __str__(self): return \"&lt;Uid&gt;:&#123;&#125;,&lt;name&gt;:&#123;&#125;\".format(self.Uid,self.name)Base.metadata.create_all(engine) #创建数据库表,sqlalchemy会自动覆盖已存在的表 flask-sqlalchemy sqlalchemy 表继承的类 db = SQLAlchemy(app),db.Model Base = declarative_base() 都是从工厂函数中声明的一个实例类,作为声明性类基类 链接数据库函数 create_engine() 创建表函数 db.create_all() Base.metadata.create_all(engine) 表单字段 db.Column() sqlalchemy.Column() 字段类型 db.Integer sqlalchemy.Integer 插入数据 msg = Mmessage(name=data.get(‘name’),email=data.get(‘email’), subject=data.get(‘subject’),message=data.get(‘message’)) db.session.add(msg) db.session.commit() user = User(name=‘mrli’) Session = sessionmaker(bind=engine) session = Session() session.add(user) session.commit() 查询 Item.query.filter(Item.table == json_data.get('table')).first() user = session.query(User).filter_by(name='mrli').first() backref 文本输出 def __repr__(self): （与django的__str__不同） sqlalchemy: 查: 1234567891011121314151617181920212223242526272829user = session.query(User).all()user = session.query(User).filter_by(name='mrli').first()# 排序for row in user = session.query(User).order_by(User.id): pass# in_for row in session.query(User).filter(User.name.in_(['nymrli','cl'])): pass&gt;&gt;&gt; &lt;Uid&gt;:1,&lt;name&gt;:mrli&gt;&gt;&gt;&gt; &lt;Uid&gt;:3,&lt;name&gt;:qsy for row in session.query(~User.name.in_(['nymrli','cl'])): print(row) &gt;&gt;&gt;(True,)&gt;&gt;&gt;(False,)&gt;&gt;&gt;(True,)# ~ in for row in session.query(User).filter(~User.name.in_(['nymrli','cl'])): pass#计数user = session.query(User).filter(User.name=='mrli').count()#▲.注意filter()的==与filter_by()的=的使用区别# and_ or_ sqlalchemy core (核心层,更接近SQL语句) 代码很接近、形似SQL原生语句,可以写sqlalchemy的SQL方言(dialect) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import sqlalchemyfrom sqlalchemy import create_enginefrom sqlalchemy import Table,MetaDataprint(sqlalchemy.__version__)engine = create_engine('sqlite:///test.db',echo = True) #将数据库执行的语句打印出来metadata = MetaData()users = Table( 'users',metadata, sqlalchemy.Column('id',sqlalchemy.Integer,primary_key=True), sqlalchemy.Column('name',sqlalchemy.String))addresses = Table( 'addresses' , metadata, sqlalchemy.Column('id', sqlalchemy.Integer, primary_key=True), sqlalchemy.Column('user_id', None,primary_key('users.isd')), sqlalchemy.Column('email_address', sqlalchemy.String, nullable=False))metadata.create_all(engine)users = Table( 'users',metadata, sqlalchemy.Column('id',sqlalchemy.Integer,primary_key=True), sqlalchemy.Column('name',sqlalchemy.String))addresses = Table( 'addresses' , metadata, sqlalchemy.Column('id', sqlalchemy.Integer, primary_key=True), sqlalchemy.Column('user_id', None,primary_key('users.id')), sqlalchemy.Column('email_address', sqlalchemy.String, nullable=False))metadata.create_all(engine)conn = engine.connect()conn.execute(users.insert(),[ dict(name='nymrli'), dict(name='cl')])conn.execute(users.insert(),[ dict(user_id=1,email_address='1063052964@qq.com'), dict(user_id=1,email_address='2042423232@qq.com'), dict(user_id=2, email_address='1063052923@qq.com'), dict(user_id=2, email_address='2042423232@qq.com'),])from sqlalchemy.sql import selects = select([users])result = conn.execute(s)for x in result: print(x)# s = select([users.addresses]).where(users.c.id == addresses.c.user_id)from sqlalchemy.sql import texts = text( \"SELECT user.name || ',' || addresses.email_address AS title \" \"FROM users.addresses \" \"WHERE users.id == addresses.user_id \" \"AND users.name BETWEEN :x AND :y \" \"AND (addresses.email_address LIKE :e1 \" \"OR addresses.email_address LIKE :e2)\")print(conn.execute(s,x='m',y='z',e1=\"%@aoq.com\",e2='@qwe.com').fetchall()) 注意下最后text()里面写的内容&quot;&quot;引号最后要有空格,与下面的语句分割开 无空格的样子: 有空格的样子","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://nymrli.top/tags/数据库/"}]},{"title":"Flask系列–将应用部署在Heroku上","slug":"Flask系列–将应用部署在Heroku上","date":"2018-11-21T07:54:01.000Z","updated":"2019-09-15T08:07:30.936Z","comments":true,"path":"2018/11/21/Flask系列–将应用部署在Heroku上/","link":"","permalink":"https://nymrli.top/2018/11/21/Flask系列–将应用部署在Heroku上/","excerpt":"","text":"Flask补充系列–将应用部署在Heroku上 之前曾经介绍过如何将Flask应用部署在自己的服务器上，对于手头并不宽裕的程序员来说，购置一台托管服务器还是一笔不小的开销。即便现在有公有云服务器可以买，不过如果你只是以学习为目的，这笔开销还是能省则省了。另外，如果你的应用中需要访问国外被河蟹掉的资源，在服务器上翻墙也是件麻烦事，所以这里我们补充一篇如何将Flask应用部署在Heroku上。 环境准备 Heroku是一个PaaS服务提供商，使用前，你需要先注册一个Heroku帐号，注册帐号是免费的。 此外你本地必须要有Python 2.7的开发环境，并且装好了Pip, Setuptools, Virtualenv等工具。对于Python开发者来说，这些都是必备的吧。此外Git客户端也是必须的，因为Heroku的代码管理用的是Git。 Heroku提供了一个非常方便的Getting Start教程，每种开发环境都有，我们可以打开Python的Getting Start，然后参照其说明创建一个Python Web应用。懒得看英文的朋友们，可以看我下面写的步骤。 在开始创建应用之前，你还需要安装Heroku的客户端工具，你可以根据你本地的操作系统选择安装包下载。这是一个命令行工具，基于Ruby实现，所以使用起来每个操作系统都一样。安装完成后，你可以打开命令行，输入下面的命令来验证安装是否成功： 1$ heroku --version 如果安装成功，就在本地命令行里登录Heroku，执行命令： 1$ heroku login 并输入你注册号的Heroku帐号及密码即可。 创建应用 网页创建应用 环境准备就绪了，我们开始创建一个应用。浏览器打开Heroku应用控制台，点击右上角的”+”号，并选择”Create new app”。 在创建页面中，输入你的应用名称，比如”flask-bjhee”，如果名称没有被占用，则会跳出绿色提示”flask-bjhee is available”。运行环境默认在美国，也可以选择欧洲。信息填完后，点击下方的”Create App”按钮，应用就创建完成了。 接下来打开命令行，我们要初始化本地及远程代码库： 1234$ mkdir /home/bjhee/flask-bjhee # 创建本地代码工作目录$ cd /home/bjhee/flask-bjhee # 切换到本地代码工作目录$ git init # 创建本地代码库$ heroku git:remote -a flask-bjhee # 连接远程Heroku的flask-bjhee代码库 现在，我们就可以编写应用代码，并提交到Heroku上去了。 命令行创建应用 1234$ heroku create (xxx) #省略会自动默认$ git add .$ git commit -m &quot;yyy&quot;$ heroku git:remote -a flask-bjhee 部署应用 既然主要是在讲部署，那代码逻辑就简单些，Hello World吧。我们写一个Flask Web程序”run.py”，内容如下： 123456789from flask import Flaskapp = Flask(__name__) @app.route(&apos;/&apos;)def index(): return &apos;Hello World!&apos; if __name__ == &apos;__main__&apos;: app.run(host=&apos;0.0.0.0&apos;, debug=True) 然后，我们就写个”requirements.txt”文件，应用部署时Heroku远程环境会自动执行： 1$ pip install -r requirements.txt 来安装应用依赖的库。我们的”requirements.txt”文件如下： 12Flask==0.10.1gunicorn==19.4.5 项目依赖Flask很好理解，为什么还要依赖gunicorn呢？因为我们不能靠Flask自带的Web服务器来运行Flask程序，所以gunicorn是个很好的选择。还记得如何通过Gunicorn运行Flask应用吗？对于上面的代码，我们只需执行”gunicorn run:app”即可。现在我们要告诉Heroku，应该使用这个命令来运行我们的应用。怎么做呢，就是在项目根目录里创建一个”Procfile”文件，然后写上： 1web: gunicorn run:app --log-file - 这就告诉Heroku，启动Web时，要执行”gunicorn run:app –log-file -“。后面的”–log-file -“参数，是为了让日志只打印到标准输出stdout上，因为Heroku不提供我们写本地磁盘的功能。 再接下来，我们要写一个app.json来描述项目信息，”app.json”内容大致如下： 1234567&#123; &quot;name&quot;: &quot;Flask sample on Heroku&quot;, &quot;description&quot;: &quot;An example of deploying Flask web app to Heroku.&quot;, &quot;image&quot;: &quot;heroku/python&quot;, &quot;repository&quot;: &quot;https://git.heroku.com/flask-bjhee&quot;, &quot;keywords&quot;: [&quot;python&quot;, &quot;flask&quot; ]&#125; 另外根据习惯，我们应该写一个”README.md”来给用户看，”.gitignore”描述哪些文件类型不需要提交到代码库中去。好了，现在我们的目录结构如下： 1234567flask-bjhee/ ├ .gitignore ├ app.json ├ Procfile ├ README.md ├ requirements.txt └ run.py 让我们执行git提交命令，来部署到远程Heroku上去吧： 123$ git add .$ git commit -m &quot;Initialize Project&quot;$ git push heroku master # 提交到远程master分支 想看看效果，命令行里输入： 1$ heroku open 就会启动浏览器，并打开地址”https://flask-bjhee.herokuapp.com/”，当然你也可以直接浏览器访问这个地址。有没有看到”Hello World!”？ 本篇的示例代码可以在这里下载。 部分转自: 思诚之道 ▲ 注意部署的时候有两个文件不能少,分别是Procfile和requestments.txt(名字必须完全一样,我就是拼错了一次和少了个s),失败的报错情况如图 完成后是这样的.heorku会自动根据你提供的requestments.txt安装相应的依赖库 配置数据库环境、迁移文件、表 heroku提供了自己的控制台,打开的命令为heroku run bash,之后就可以像在linux的终端下一样操作了 除了这种方法还可以指明使用heroku命令,需要做的是加上前缀heroku run,如heroku run python manage.py db init 官方介绍为:(如图 自定义域名 1$ heroku domains:add apollo.nymrli.top ▲.注意需要认证账户,否则会出现下图结果 待认证好后,还需要用DNS解析,我用的是阿里云的万网解析,将heroku domains:add apollo.nymrli.top后heroku的值用CHAME记录解析.等个几秒后就可以用apollo.nymrli.top访问heroku上面的应用程序了 还有一个做法呢,是直接在heroku相应app的设置里面设置自定义域名,但是由于显示问题,容易复制错,导致无法被解析的问题…如果设置好CHAME解析30秒后还是无法用自定义域名打开的话,看看是不是值复制错了. 所以还是比较建议用命令heroku domains:add xxx来绑定","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"}]},{"title":"二分搜索降低时间复杂度","slug":"二分搜索降低时间复杂度","date":"2018-11-10T13:36:01.000Z","updated":"2019-09-15T08:07:31.022Z","comments":true,"path":"2018/11/10/二分搜索降低时间复杂度/","link":"","permalink":"https://nymrli.top/2018/11/10/二分搜索降低时间复杂度/","excerpt":"","text":"二分搜索降低时间复杂度 123456int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;n;i++) cin &gt;&gt; s[i]; canFit(); return 0;&#125; 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 150using namespace std;int n,m,s[MAXN];int ss[MAXN];bool canFit()&#123; int flag = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) for(int l=0;l&lt;n;l++) if( s[i] + s[j] + s[l] + s[k] == m) flag = true; if(flag) cout &lt;&lt; \"YES\"; else cout &lt;&lt; \"NO\" ;&#125; 时间复杂度为O(n^4),只能在n较小的情况下,若n较大,则TLE… 时间复杂度为O(n^3log2(n))的做法:一层二分搜索 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 150using namespace std;int n,m,s[MAXN];int ss[MAXN];bool binSearch(int k)&#123; int r=n,l=0; while(l &lt;= r)&#123; int i = (r+l)/2; if ( s[i] == k) return true; else if( s[i] &lt; k) l = i+1; else r= i-1; &#125; return false;&#125;bool canFit()&#123; int flag = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if( binSearch(m-s[i] - s[j] - s[k]) flag = true; if(flag) cout &lt;&lt; \"YES\"; else cout &lt;&lt; \"NO\" ;&#125; O(n^2log2(n))做法: 排序O(n^2log2(n)),循环O(n^2log2(n)),总共也是O(n^2log2(n)) 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 150using namespace std;int n,m,s[MAXN];int ss[MAXN];bool binSearch(int k)&#123; int l=0,r=n*n; while(l &lt;= r)&#123; int i = (r+l)/2; if ( s[i] == k) return true; else if( s[i] &lt; k) l = i+1; else r= i-1; &#125; return false;&#125;void enumeration()&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) ss[i*n+j] = s[i] + s[j];&#125;bool canFit()&#123; enumeration(); sort(ss,ss+n*n); //二分搜索的前提是有序 int flag = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if( binSearch(m- s[i] - s[j] )) flag = true; if(flag) cout &lt;&lt; \"YES\"; else cout &lt;&lt; \"NO\" ;&#125; ▲需要注意的是,ss[n*n]的数组需要先排序才能使用二分搜索 ----出自:&lt;&lt;挑战程序设计竞赛&gt;&gt;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://nymrli.top/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"matplotlib.pyplot使用","slug":"matplotlib-pyplot使用","date":"2018-11-10T04:58:51.000Z","updated":"2019-12-11T14:11:12.354Z","comments":true,"path":"2018/11/10/matplotlib-pyplot使用/","link":"","permalink":"https://nymrli.top/2018/11/10/matplotlib-pyplot使用/","excerpt":"","text":"matplotlib.pyplot使用 注释 1234567891011121314151617181920212223242526272829303132333435## 方法一####################for x_value,y_value in zip(x,y): plt.text(x_value,y_value,y_value,fontsize= 15) #文字标注(x,y,值)###################### 方法二####################for xy in zip(x, y): plt.annotate(\"(%s,%s)\" % xy, xy=xy, xytext=(-20, 10), textcoords='offset points') x0 = 1y0 = 2* x0plt.annotate(r'$&#123;&#125;+&#123;&#125;=&#123;&#125;$'.format(x0,x0,y0),xy=(x0,y0),xycoords='data',xytext=(+30,-30),textcoords = 'offset points', fontsize=16,arrowprops=dict( arrowstyle='-&gt;', connectionstyle='arc3,rad=.2' ))##################### 添加注释(annotate),参数说明plt.annotate(r'$2x+1=&#123;&#125;$'.format(y),xy=(x,y),xycoords='data',xytext=(+30,-30),textcoords = 'offset points',fontsize=16, arrowprops=dict( arrowstyle='-&gt;', connectionstyle='arc3,rad=.2') )# 第一个参数是注释的内容# xy设置箭头尖的坐标# xytext设置注释内容显示的起始位置# arrowprops 用来设置箭头# facecolor 设置箭头的颜色# headlength 箭头的头的长度# headwidth 箭头的宽度# width 箭身的宽度 坐标轴转移 1234567ax = plt.gca()ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)ax.xaxis.set_ticks_position(&apos;bottom&apos;)ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;,0))ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;left&apos;].set_position((&apos;data&apos;,0)) 图形类型 散列图 ax1.scatter(x,y,c = 'r',marker = 'o') 折线图plt.plot() 直方图plt.hist() 条形图plt.bar(left=index,height=y,color='green',width=0.5) 饼状图:plt.pie(x=fracs,labels=labels,autopct='%.0f%%',explode=explode)#autopct显示百分比 箱形图plt.boxplot(data,labels=labels) 等高线 plt.contourf(X,Y,f(X,Y),8,alpha = .75,cmap = plt.cm.hot) scatter基本的用法 条形图 123456789fig = plt.figure(dpi=256, figsize=(10, 8))plt.plot(U,I,&apos;r*&apos;)plt.xlabel(&apos;U(V)&apos;,fontsize=10)plt.ylabel(&apos;I(10e-9A)&apos;,fontsize=10)plt.title(&apos;The line chart of the relation between U and I&apos;,fontsize=15)plt.ylim(0,max(I)+0.5)x = np.linspace(0,max(I)+0.5,40)plt.yticks(x,fontsize=6) 线条选项 12plt.plot(x,y,&apos;r*&apos;) # 默认为蓝色# 等价于plt.plot(x,y,color= &apos;r&apos;, marker =&apos;*&apos;) 散点图 12345678n =100X = np.random.normal(0,10,n)Y = np.random.normal(0,10,n)T = np.arctan2(Y,X)plt.scatter(X,Y,c= T,s=6)plt.xticks(())plt.yticks(())plt.show() 柱状图 1234567891011121314n=12X=np.arange(n)Y1=(1-X/float(n))*np.random.uniform(0.5,1.0,n)Y2=(1-X/float(n))*np.random.uniform(0.5,1.0,n)plt.bar(X,+Y1,facecolor='#9999ff',edgecolor='white')plt.bar(X,-Y2,facecolor='#ff9999',edgecolor='white')for x,y in zip(X,Y1): plt.text(x+0,y+0.05,\"%.2f\" %y,ha='center',va='bottom') # horizontal alignment , vertical alignmentplt.xlim(-.5,n)plt.xticks(())plt.ylim(-1.25,1.25)plt.yticks(())plt.show() 等高线 123456789101112def f(x,y): # return 1 + 1/x**3 + y**5 return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)n = 256x = np.linspace(-3,3,n)y = np.linspace(-3,3,n)X,Y = np.meshgrid(x,y)plt.contourf(X,Y,f(X,Y),8,alpha = .75 , cmap = plt.cm.hot)C = plt.contour(X,Y,f(X,Y),8,colors = &apos;black&apos;)plt.clabel(C,inline = True,fontsize = 10) 图例 123l1 , = plt.plot(x,y,linestyle= '--',color = 'red',linewidth=2.0)# 返回值为一个元组plt.legend(handles=[l1],labels = ['les'],loc='best') 3D图形 1234567891011121314from matplotlib import pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)x = np.linspace(-4,4,50)y = np.linspace(-4,4,50)X,Y = np.meshgrid(x,y)R = np.sqrt(X**2 + Y**2)Z = np.sin(R)ax.plot_surface(X,Y,Z,rstride=1,cstride=1,cmap = plt.get_cmap('rainbow'))ax.contour(X,Y,Z,zdir='x',offset = -5)#画等高线图,往哪个(x)轴压缩,到x=-5位置plt.show() 分格画子图 123456789101112131415161718192021# method 1: subplot2grid##########################plt.figure()axl=plt. subplot2grid((3,3),(0,0), colspan=3, rowspan=1)# 三行三列, 从源点(0,0)开始画,第一张图占一行三列axl.plot([1,2],[1,2])ax1.set_title('xxx')# 原来plt.title()设置的方法,现在都变成了ax?.set_xxx,多了前缀set_ax2=plt. subplot2grid((3,3),(1,0), colspan=2,)ax3=plt. subplot2grid((3,3),(1,2), rowspan=2)ax4=plt. subplot2grid((3,3),(2,0) #method 2 :gridspec import matplotlib.gridspec as gridspeccplt.figure()gs=gridspec.GridSpec(3,3)ax1=plt.subplot(gs[0, :])ax2=plt.subplot(gs[1, :2])ax3=plt.subplot(gs[1: ,2])ax4=plt.subplot(gs[-1,0])ax5=plt.subplot(gs[-1,-2]) 附录: 温习源自WeiboSpider 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Cgraph(object): def __init__(self): self.db = db self.create_dir() self.Start_timestmp = time.mktime(time.strptime('2018-7-5 00:00','%Y-%m-%d %H:%M')) def judge_over(self, _time): # start_time is timestamp ''' 判断时间是否已经超过预设时间 :param Start_timestmp: :param _time: :return: ''' timestamp = time.mktime(time.strptime(_time, '%Y-%m-%d %H:%M')) # Start_timestamp = time.mktime(time.strptime(Start_time,'%Y-%m-%d %H:%M')) if timestamp - self.Start_timestmp &lt; 0: return True else: return False def create_dir(self): if not os.path.isdir('.\\\\graph'): os.makedirs('.\\\\graph') def count(self,lists): exist_dict = OrderedDict() for x in lists: if x not in exist_dict: exist_dict[x] = 1 else: exist_dict[x] += 1 return dict(sorted(exist_dict.items(),key=lambda x:x[0])) def unify_time(self,_time): c = _time.split('-') _time = '-'.join(['0' + x if len(x.strip()) == 1 else x for x in c]) if _time[:4] == '2018': _time = _time[5:10] return _time[:10] def Draw(self): timelist = [] for alls in self.db.find(): if alls.get('time'): print(alls.get('time')) timelist.append(self.unify_time(alls.get('time'))) infodict = self.count(timelist[::-1]) plt.figure(figsize=(40, 18)) #设置图片大小 # plt.rcParams['figure.figsize'] = (40.0, 12.0) 设置图片大小的另外一种方法 # plt.rcParams['figure.dpi'] = 400 x = list(infodict.keys()) y = list(infodict.values()) plt.plot(x,y,linewidth=2,color='r',marker='o',markersize=8) for x_value,y_value in zip(x,y): plt.text(x_value,y_value,y_value,fontsize= 15) #文字标注(x,y,值) plt.ylim((0, max(y))) #纵坐标y的上下限 plt.yticks([x for x in range(0,max(y)+10,10)]) #y的比例尺 plt.xlabel('Time') plt.ylabel('Keyword times') #y轴的标签 plt.title('Weibo Keyword\\'s Trendency') #图的标题 plt.savefig('.\\\\graph\\\\&#123;&#125;.jpg'.format(TABLE)) #保存图片 plt.clf()if __name__ == '__main__': graph = Cgraph() graph.Draw() print('完成') 使用:大物实验画折线图 12345678910111213141516171819202122232425262728293031323334import csvfrom matplotlib import pyplot as pltimport osimport numpy as npI = []U = []def extractFromCsv(filename): with open(filename,'r') as f: reader = csv.reader(f) for row in reader: if reader.line_num == 1: #跳过表头 continue U.append(float(row[0])) I.append((float(row[1])))def drawPic(filename): fig = plt.figure(dpi=256, figsize=(10, 8)) plt.plot(U,I,'r*') plt.xlabel('U(V)',fontsize=10) plt.ylabel('I(10e-9A)',fontsize=10) plt.title('The line chart of the relation between U and I',fontsize=15) plt.ylim(0,max(I)+0.5) x = np.linspace(0,max(I)+0.5,40) plt.yticks(x,fontsize=6) if not os.path.exists(\".\\\\graph\"): os.mkdir('.\\\\graph') plt.savefig('.\\\\graph\\\\&#123;&#125;.jpg'.format(filename))if __name__ == \"__main__\": filename='phy.csv' extractFromCsv(filename) drawPic(filename) 参考: matplotlib 画图颜色参数值及对应色卡 matplotlib绘图总结——对画图句柄的操作 matplotlib中plt.scatter()参数详解——很详细","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"apt代理的设置","slug":"apt代理的设置","date":"2018-11-10T04:56:53.000Z","updated":"2019-09-15T08:07:30.919Z","comments":true,"path":"2018/11/10/apt代理的设置/","link":"","permalink":"https://nymrli.top/2018/11/10/apt代理的设置/","excerpt":"","text":"原因是在apt-get update时遇到了Unable to connect to 代理，（由于apt-get update一直显示无法连接172.17.18.141百度后发现并不是个特殊的IP,）于是想到是否使用了代理。 apt代理的设置： 临时方法 export http_proxy=http://10.3.0.1:80 长久方法 (1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。) Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;; 保存apt.conf文件。 (2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件) 建立文件 vim proxyfile Acquire::http::proxy &quot;http://10.3.0.1:80&quot;; Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;; Acquire::https::proxy &quot;http://10.3.0.1:80&quot;; 使用时sudo apt-get install xxx -c proxyfile (2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 ) 在您的.bashrc文件末尾添加如下内容 export http_proxy=http://用户名:密码@地址:端口/ export https_proxy=http://用户名:密码@地址:端口/ export ftp_proxy=http://用户名:密码@地址:端口/ https://blog.csdn.net/qq3399013670/article/details/81300497","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://nymrli.top/tags/Ubuntu/"}]},{"title":"Ubuntu更改nginx默认端口","slug":"Ubuntu更改nginx默认端口","date":"2018-11-10T04:55:13.000Z","updated":"2019-09-15T08:07:31.011Z","comments":true,"path":"2018/11/10/Ubuntu更改nginx默认端口/","link":"","permalink":"https://nymrli.top/2018/11/10/Ubuntu更改nginx默认端口/","excerpt":"","text":"Ubuntu更改nginx默认端口 nginx 默认使用80端口，有时候我们希望nginx运行在其他端口，就需要更改nginx配置 nginx配置文件在/etc/nginx目录下的nginx.conf。(可以修改处理器数量、日志路径、pid文件路径等，默认的日志。) 错误日志 /var/log/nginx/error.log 访问日志 /var/log/nginx/access.log 在nginx.conf-&gt;http选项末尾有引入两个目录下的文件分别为： 123456[/etc/nginx/nginx.conf]http &#123; # 省略部分内容 include /etc/nginx/conf.d/*.conf; #意思是把用户自己的配置放到conf.d/* include /etc/nginx/sites-enabled/*;&#125; 查看/etc/nginx/sites-enabled/目录，会找到一个default文件，在server选项下前两行就可以找到使用的80端口号： 1234[/etc/nginx/sites-enabled/default]server &#123; listen 80 default_server; listen [::]:80 default_server; 将80端口号改为想使用的端口号，保存文件，如果没有启动nginx，启动即可。如果nginx已经在运行，重新加载即可。 12sudo nginx start #运行nginxsudo nginx -s reload #重启nginx **如果遇到nginx报以下错误：nginx: [error] open() &quot;/run/nginx.pid&quot; failed (2: No such file or directory)则sudo nginx -c path/*.conf #指定nginx配置*.conf的位置** **查看nginx运行的端口sudo netstat -anp | grep nginx** ▲如果启用防火墙，则需开启对应端口，使用AWS服务器需要更改服务器安全组，添加响应入站规则，开启对应端口。","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://nymrli.top/tags/Ubuntu/"}]},{"title":"Pythonanywhere解决链接Mysql问题(部署flask)","slug":"Pythonanywhere解决链接Mysql问题-部署flask","date":"2018-11-10T04:54:14.000Z","updated":"2019-09-15T08:07:30.978Z","comments":true,"path":"2018/11/10/Pythonanywhere解决链接Mysql问题-部署flask/","link":"","permalink":"https://nymrli.top/2018/11/10/Pythonanywhere解决链接Mysql问题-部署flask/","excerpt":"","text":"Pythonanywhere解决链接Mysql问题(部署flask) 由于在bash控制台里通过命令mysql -p(这其实是因为错误的连接方式,由于不是默认的端口3306,自然连接不到,官方文档中有正确的连接方式)链接不到Mysql时,再加上进虚拟环境用python manage db migrate也失败后,我是异常慌张的…然后立马发现关于pythonanywhere链接Mysql的解决不是很多,要么就是说免费账号是无法用的…心顿时拔凉,但最后还是找到了pythonanywhere官方的文档,解决了这个问题,发现都是配置的问题 一开始的我本地及阿里云链接mysql数据库配置文件是这样写的: 1234567891011121314#[config.py]DIALECT = 'mysql'DRIVER = 'pymysql'USERNAME = 'root'PASSWORD = 'zxcqwe' #瞎写的HOST = '127.0.0.1'PORT = '3306'DATABASE = 'restaurant'DEBUG = TrueSQLALCHEMY_DATABASE_URI = \"&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8\".format( DIALECT,DRIVER,USERNAME,PASSWORD,HOST,PORT,DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False 后来根据说明改成了如下: 123456789101112#[config.py]DIALECT = 'mysql'DRIVER = 'pymysql'USERNAME = 'nymrli'PASSWORD = 'zxcqwe' #瞎写的HOST = 'nymrli.mysql.pythonanywhere-services.com'PORT = '3306'DATABASE = 'nymrli$restaurant'DEBUG = TrueSQLALCHEMY_DATABASE_URI = \"&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8\".format( DIALECT, DRIVER, USERNAME, PASSWORD, HOST, PORT, DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False 其中修改的地方为 USERNAME为pythonanywhere账号 PASSWORD为Database详情页设置的数据库密码 HOST为Database详情页上的Database host address DATABASE为Database详情页上 create a database的数据库名,但pythonanywhere会自动给你加上前缀&lt;username&gt;$&lt;database_name&gt;,所以我这边就是nymrli$restaurant PORT默认还是3306 附上官方文档: 配置说明: 开始使用MySQL,您需要去在仪表板的MySQL选项卡,并设置一个密码。你也会找到连接设置选项卡(主机名、用户名),以及创建新的数据库的能力。 你可以开始一个新的MySQL控制台访问数据库从这个选项卡,或者您可以打开一个MySQL从bash shell使用以下命令控制台或ssh会话: mysql -u USERNAME -h HOSTNAME -p 'USERNAME$DATABASENAME' [Using MySQL](https://help.pythonanywhere.com/pages/UsingMySQL/) 通过SSH链接,据说免费账户不支持: 12345678910Setting ValueSSH Hostname: ssh.pythonanywhere.comSSH Username: your PythonAnywhere usernameSSH Password: the password you use to log in to the PythonAnywhere websiteSSH Key file: should not be necessary when you specify the passwordMySQL Hostname: your PythonAnywhere database hostname, eg. yourusername.mysql.pythonanywhere-services.comMySQL Server Port: 3306Username: your PythonAnywhere usernamePassword: your PythonAnywhere database passwordDefault Schema: your database name, eg yourusername$mydatabase Accessing your MySQL database from outside PythonAnywhere","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"MySQL","slug":"MySQL","permalink":"https://nymrli.top/tags/MySQL/"}]},{"title":"写爬虫过程中碰到的编码问题","slug":"写爬虫过程中碰到的编码问题","date":"2018-11-08T04:23:19.000Z","updated":"2019-09-15T08:07:31.030Z","comments":true,"path":"2018/11/08/写爬虫过程中碰到的编码问题/","link":"","permalink":"https://nymrli.top/2018/11/08/写爬虫过程中碰到的编码问题/","excerpt":"","text":"写爬虫过程中碰到的编码问题 遇到 ’ \\uxxxx ’ 的16进制字符串编解码问题，使用unicode-escape解决之。 实际上，在将unicode存储到文本的过程中，还有一种存储方式，不需要将unicode转换为实际的文本存储字符集，而是将unicode的内存编码值进行存储，读取文件的时候再反向转换回来，是采用：unicode-escape的转换方式。 将unicode的内存编码值进行存储，读取文件时在反向转换回来。这里就采用了unicode-escape的方式 12345678print(u&apos;中文测试&apos;.encode(&apos;utf-8&apos;))print(&apos;中文测试&apos;.encode(&apos;utf-8&apos;))print(u&apos;中文测试&apos;.encode(&apos;unicode-escape&apos;))print(&apos;中文测试&apos;.encode(&apos;unicode-escape&apos;))==&gt; b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe6\\xb5\\x8b\\xe8\\xaf\\x95&apos;==&gt; b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe6\\xb5\\x8b\\xe8\\xaf\\x95&apos;==&gt; b&apos;\\\\u4e2d\\\\u6587\\\\u6d4b\\\\u8bd5&apos;==&gt; b&apos;\\\\u4e2d\\\\u6587\\\\u6d4b\\\\u8bd5&apos; ASCII码只有128个字符，符合英文，一个英文字符只用1个字节(最高位恒为0) ANSI：面向中文编码的GBK、GB2312是ANSI码的一种，ANSI码是对ASCII的拓展，所以一个英文只用一个字节，而中文需要拓展ASCII，所以用到两个字节。 0x80~0xFFFF =&gt;2**16 Unicode编码:为了解决不同国家ANSI编码的冲突问题，最常用的是用两个字节表示一个字符 。但是这样的话，原本可以用一个字节存储的英文字母在Unicode里面必须存两个字节，这就产生了浪费。那么有没有一种既能消除乱码，又能避免浪费的编码方式呢？===&gt;答案就是UTF-8 。000000 -10FFFF 12&gt; UNICODE 的范围是 0x0000 - 0xFFFF 共6万多个字符，其中光汉字就占用了4万多个&gt; UTF-8编码：当字符在ASCII码的范围时，就用一个字节表示 ，所以英文字符也只用一个字节，▲值得注意的是unicode编码中一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。utf-8长度是1-6个字节 （可变的） Unicode编码(十六进制) UTF-8 字节流(二进制) 000000-00007F 0xxxxxxx 000080-0007FF 110xxxxx 10xxxxxx 000800-00FFFF 1110xxxx 10xxxxxx 10xxxxxx 010000-10FFFF 11110xxx 10xxxxxx 10xxxxxx10xxxxxx 超出10FFFF后，UTF-8与Unicode不再对应 总结： UTF-8 vs GBK： UTF-8版本虽然具有良好的国际兼容性，但中文需要比GBK/BIG5版本多占用50%的数据库存储空间，因此并非推荐使用，仅供对国际兼容性有特殊要求的用户使用。简单地说：对于中文较多的网站，适宜用GBK编码节省数据库空间。对于英文较多的网站，适宜用UTF-8节省数据库空间。 字符编码ANSI和ASCII区别、Unicode和UTF-8区别 Python中编码问题 在python中，unicode是内存编码集，一般我们将数据存储到文件时，需要将数据先编码为其他编码集，比如utf-8、gbk等。 读取数据的时候再通过同样的编码集进行解码即可。 但是其实还有一种unicode-escape编码集，他是将unicode内存编码值直接存储： 在使用python3的requests模块时，发现获取响应有两种方式 其一，为文本响应内容, r.text是Unicode的响应内容 其二，为二进制响应内容，r.content是二进制的响应内容 Python2 的编码问题一直非常让人恼火，不过你的问题稍微简单一些。 在交互式命令模式(Interactive shell)下，可以这样来明白你遇到的问题的根源： 1234567import sys sys.stdout.encoding 在 Windows 下，如果你的系统是简体中文，一般输出会是 cp936 import codecs codecs.lookup(&apos;cp936&apos;).name &apos;gbk&apos; 这就是在 Windows 终端里面使用的编码。在 print 的时候，无论字符串源采取什么样的编码，最终输出的字符串的编码必须跟 shell 的编码一致，也就是说: print some_string Python 会做这样一个动作： codecs.encode(some_string, coding, errors=‘strict’) 在你遇到的情况下，some_string 是一个 unicode 字符串，coding 是 gbk。由于你的 unicode 字符串里面包含 gbk 字符集里面没有的字符，Python 就会抛出一个 UnicodeEncodeError. 对于输出到文件中情况是类似的，Python2 的 open() 函数不会传入 encoding，以 ‘w’ 方式打开文件，如果写入 unicode 字符串，Python 会获取当前默认的编码，然后以此种编码把字符串写入文件。可惜的是，“默认编码”只是 Python 自己默认的，在 Objects/unicodeobject.c 中，用一个全局变量 unicode_default_encoding 来表示默认的编码： /* Default encoding to use and assume when NULL is passed as encoding parameter; it is initialized by _PyUnicode_Init(). ​ Always use the PyUnicode_SetDefaultEncoding() and ​ PyUnicode_GetDefaultEncoding() APIs to access this global. static char unicode_default_encoding[100 + 1] = &quot;ascii&quot;; 这个值在 Python 中有C接口（PyUnicode_SetDefaultEncoding）去改变，但可惜的是没有 Python 层的接口。 所以在调用到类似 file.write(some_string) 的时候，首先会有这样的编码过程: codecs.encode(some_string, coding, errors=‘restrict’) 当你的 some_string 是一个 unicode 字符串，并且包含 ascii 字符串不存在的字符时，就会抛出一个 UnicodeEncodeError。 所以，为了解决这个问题，可以这么处理： (1) 在 Windows shell 下面: &gt;&gt;&gt; print some_string.encode(‘gbk’, errors=‘ignore’) # replace 也可，只要不是 restrict (2) 在写入文件时，两种方法： a. 忽略不存在的字符，同(1) &gt;&gt;&gt; f = open(filename, ‘w’) &gt;&gt;&gt; f.write(some_string.encode(‘gbk’, errors=‘ignore’) b. byte 方式写入： &gt;&gt;&gt; f = open(filename, ‘wb’) &gt;&gt;&gt; f.write(some_string.encode(‘utf-8’)) ​ a 会损失字符，b 不会。 来自http://www.newsmth.net/nForum/#!article/Python/124657 如果CMD命令行是gbk编码的，则输出的utf-8字符有些也显示不了 Win10 临时修改cmd命令行窗口UTF-8编码 只作用于当前打开的窗口 进入cmd窗口后，直接执行“chcp 65001”，执行完后，cmd的编码格式就是UTF-8 永远修改 Windows 控制台使用注册表永久修改编码问题 方法一： 1.在cmd中输入regedit进入注册表 2.找到HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe 3.新建一个 DWORD（32位值）,命名为CodePage，值设为65001 4.已有CodePage的话，修改它，改为十进制，65001 方法二：(亲测有效) 1.新建一个cmd.reg注册表文件: 2.内容输入如下： 123456789Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe]&quot;CodePage&quot;=dword:0000fde9&quot;FontFamily&quot;=dword:00000036&quot;FontWeight&quot;=dword:00000190&quot;FaceName&quot;=&quot;Consolas&quot;&quot;ScreenBufferSize&quot;=dword:232900d2&quot;WindowSize&quot;=dword:002b00d2 3.双击运行","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Shell脚本基础","slug":"Shell脚本基础","date":"2018-11-08T04:19:49.000Z","updated":"2020-09-04T07:48:47.590Z","comments":true,"path":"2018/11/08/Shell脚本基础/","link":"","permalink":"https://nymrli.top/2018/11/08/Shell脚本基础/","excerpt":"","text":"Shell 编写 打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。 12#!/bin/bash#!/usr/bin/php “#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。 作为可执行程序 12chmod +x test.sh./test.sh 注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。 变量 定义变量 12your_name=&quot;qinjx&quot;▲.变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。 使用变量 使用一个定义过的变量，只要在变量名前面加美元符号即可，如： 123your_name=&quot;qinjx&quot;echo $your_nameecho $&#123;your_name&#125; 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： 123for skill in Ada Coffe Action Java; do echo &quot;I am good at $&#123;skill&#125;Script&quot;done 字符串 字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了，哈哈），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。 单引号 1str=&apos;this is a string&apos; 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行） 双引号 12your_name=&apos;qinjx&apos;str=&quot;Hello, I know your are \\&quot;$your_name\\&quot;! \\n&quot; 双引号里可以有变量 双引号里可以出现转义字符 字符串操作 拼接字符串 12345your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;echo $greeting $greeting_1 获取字符串长度： 12string=\"abcd\"echo $&#123;#string&#125; #输出：4 提取子字符串 12string=&quot;alibaba is a great company&quot;echo $&#123;string:1:4&#125; #输出：liba 查找子字符串 12string=&quot;alibaba is a great company&quot;echo `expr index &quot;$string&quot; is`#输出：3，这个语句的意思是：找出字母i在这名话中的位置，要在linux下运行，mac下会报错 流程控制 和Java、PHP等语言不一样，sh的流程控制不可为空，如： 1234567&lt;?phpif (isset($_GET[&quot;q&quot;])) &#123; search(q);&#125;else &#123; //do nothing&#125; 在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。 还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下： 12ll /usr/bin/[-rwxr-xr-x. 1 root root 33408 6月 22 2012 /usr/bin/[ 正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0] if else if 1234567if conditionthen command1 command2 ... commandN fi 写成一行（适用于终端命令提示符）： 1if `ps -ef | grep ssh`; then echo hello; fi 末尾的fi就是if倒过来拼写，后面还会遇到类似的 if else 123456789if conditionthen command1 command2 ... commandNelse commandfi if else-if else 12345678if condition1then command1elif condition2 command2else commandNfi for while for 在开篇的示例里演示过了： 1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 写成一行： 1for var in item1 item2 ... itemN; do command1; command2… done; C风格的for 123456for (( EXP1; EXP2; EXP3 ))do command1 command2 command3done while 1234while conditiondo commanddone 无限循环 1234while :do commanddone 或者 1234while truedo commanddone 或者 1for (( ; ; )) until 1234until conditiondo commanddone case 123456789101112131415161718192021222324252627case &quot;$&#123;opt&#125;&quot; in &quot;Install-Puppet-Server&quot; ) install_master $1 exit ;; &quot;Install-Puppet-Client&quot; ) install_client $1 exit ;; &quot;Config-Puppet-Server&quot; ) config_puppet_master exit ;; &quot;Config-Puppet-Client&quot; ) config_puppet_client exit ;; &quot;Exit&quot; ) exit ;; * ) echo &quot;Bad option, please choose again&quot;esac case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break 学习自：Shell脚本编程30分钟入门","categories":[],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://nymrli.top/tags/Shell/"},{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"多媒体Au使用","slug":"多媒体Au使用","date":"2018-11-08T04:18:47.000Z","updated":"2019-09-15T08:07:31.044Z","comments":true,"path":"2018/11/08/多媒体Au使用/","link":"","permalink":"https://nymrli.top/2018/11/08/多媒体Au使用/","excerpt":"","text":"AU使用。 留人声、去伴奏 First. ▲侧边声道电平控制微弱，中置声道电平控制效果强。 ▲交叉渗透，越大伴奏声音越不明显 Second. 前面几排调低到满意。（童声高音频率范围为260-880Hz,低音频率范围为196-700Hz,女声高音频率范围为220-1.1KHz,低音频率范围为200-700KHz,男声高音频率范围为160-523KHz低音频率范围为80-358Hz. 国际通信标准制定为300Hz-3400Hz! ） 留伴奏、去人声 ···选中所有，菜单栏-收藏夹-移除人声","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"Au","slug":"Au","permalink":"https://nymrli.top/tags/Au/"},{"name":"多媒体","slug":"多媒体","permalink":"https://nymrli.top/tags/多媒体/"}]},{"title":"定时执行Python脚本","slug":"定时执行Python脚本","date":"2018-11-07T09:51:16.000Z","updated":"2020-03-29T14:22:33.660Z","comments":true,"path":"2018/11/07/定时执行Python脚本/","link":"","permalink":"https://nymrli.top/2018/11/07/定时执行Python脚本/","excerpt":"","text":"定时任务执行python脚本 使用linux的crontab 1.开启crontab日志。 crontab默认不开启日志，所以先开启定时任务的日志来查看 修改rsyslog服务，将/etc/rsyslog.d/50-default.conf 文件中的#cron.*前的 #删掉；用service rsyslog restart重启rsyslog服务： 2.写定时任务 开启本用户的定时任务,即创建以本用户名为文件名的定时任务文件，位置在/var/spool/cron/crontabs/。crontab -e 定时任务语句格式为：执行周期+命令，周期有5个域，分别是 M: 分（0-59） H：时（0-23） D：天（1-31） m: 月（1-12） d: 周（0-6） //0为星期日 ▲每个域不加限制任意的话用* 所以命令语句就是 12*/5 * * * * cd /home/iris/; python aa.py#时间# #command ; commond 写完后需要重启cron服务:service cron restart 如果定时运行的脚本需要root权限，那么可以直接把任务写在root用户的cron中 1sudo crontab -u root -e 或者切换到root用户下再进行设置cron 12345678# 可以以root身份执行crontab，sudo默认是需要输入密码。下面是运用这个方法的具体操作方法，命令执行顺序如下：# 切换到root用户下su - # 执行如下命令进入到root用户crontab配置中crontab -e# 最后，加入你的任务0 * * * * clear_img.sh &gt;&gt;clear_img.log ▲最后写完后需要重启cron服务:service cron restart 附录 常用周期格式: 每五分钟执行 */5 * * * * 每小时执行 0 * * * * 每天执行 0 0 * * * 每周执行 0 0 * * 0 每月执行 0 0 1 * * 每年执行 0 0 1 1 * 5 * * * * ls 指定每小时的第5分钟执行一次ls命令 30 5 * * * ls 指定每天的 5:30 执行ls命令 30 7 8 * * ls 指定每月8号的7：30分执行ls命令 30 5 8 6 * ls 指定每年的6月8日5：30执行ls命令 30 5 8 6 * ls 指定每年的6月8日5：30执行ls命令 30 6 * * 0 ls 指定每星期日的6:30执行ls命令 30 3 10,20 * * ls 每月10号及20号的3：30执行ls命令 25 8-11 * * * ls 每天8-11点的第25分钟执行ls命令 */15 * * * * ls 每15分钟执行一次ls命令 30 6 */10 * * ls 每个月中，每隔10天6:30执行一次ls命令 22 4 * * * root run-parts /etc/cron.daily每天4：22以root身份执行/etc/cron.daily目录中的所有可执行文件，run-parts参数表示，执行后面目录中的所有可执行文件。 ~/Python_project/SeverChan_Nyedu 使用python crontab设置linux定时任务 通过python 来写 crontab配置 123456789101112131415161718192021222324252627282930313233from crontab import CronTab# 创建当前用户的crontab，当然也可以创建其他用户的，但得有足够权限my_user_cron = CronTab(user=True)# 创建任务job = my_user_cron.new(command='echo date &gt;&gt; ~/time.log')# 设置任务执行周期，每两分钟执行一次job.setall('*/2 * * * *')# 当然还支持其他更人性化的设置方式，简单列举一些job.minute.during(5,50).every(5)job.hour.every(4)job.day.on(4, 5, 6)job.dow.on('SUN')job.dow.on('SUN', 'FRI')job.month.during('APR', 'NOV')job.setall(time(10, 2))job.setall(date(2000, 4, 2))job.setall(datetime(2000, 4, 2, 10, 2))# 同时可以给任务设置comment，这样就可以根据comment查询，很方便job.set_comment(\"time log job\")# 根据comment查询，当时返回值是一个生成器对象，不能直接根据返回值判断任务是否#存在，如果只是判断任务是否存在，可直接遍历my_user_cron.cronsiter = my_user_cron.find_comment('time log job')# 同时还支持根据command和执行周期查找，基本类似，不再列举# 任务的disable和enable， 默认enablejob.enable(False)job.enable()# 最后将crontab写入配置文件my_user_cron.write() python中的轻量级定时任务调度库：schedule 提供博客python中的轻量级定时任务调度库：schedule","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"ServerChan+南邮教务处","slug":"ServerChan-南邮教务处","date":"2018-11-07T09:32:10.000Z","updated":"2019-09-15T08:07:31.000Z","comments":true,"path":"2018/11/07/ServerChan-南邮教务处/","link":"","permalink":"https://nymrli.top/2018/11/07/ServerChan-南邮教务处/","excerpt":"","text":"SeverChan_Nyedu Crawl the infomation about competitons, when new infos comes, remind people on Wechat by ServerChan: 😍该程序通过爬取南邮教务处,将当前时间与最新时间进行匹配,如果是当日则通过ServerChan发送到本人的微信,提醒有新的竞赛. 完成笔记: 1.关于lxml中etree.xpath()对于tbody的处理 该网页通过table对页面进行分布设置,其中table标签会自动生成tbody标签,如图…此时用xpath进行匹配的时候就不需要将tbody加上,否则匹配不到 布局&lt;Table&gt; 表格&lt;table&gt; 可以看到的是在Chrome调试助手里面,&lt;table&gt;下面都是会自动生成&lt;tbody&gt;标签的(一般tbody是浏览器自动产生的，一般情况要去掉),而我们再通过网页源码看看…==&gt;可以发现的是: &lt;table&gt;布局是没有&lt;tbody&gt;的,只有表格才有,所以这也是为什么用xpath()表格里必须加上tbody才能匹配,而table布局中不能加tbody的原因 123456789101112#布局获得内容for content in contentList: title = content.xpath('td/table/tr/td[1]/a/text()')[0] href = content.xpath('td/table/tr/td[1]/a/@href')[0] submittime = content.xpath('td/table/tr/td[2]/div/text()')[0]#表格if content.tag == 'table': tabletitle = content.xpath('tbody/tr[1]/td') # 表格头 tabletitleList = map(lambda x: x.xpath('string(.)'), tabletitle) tablehead = '|' + '|'.join(tabletitleList) + '|' tableover = '|' + ':---:|' * len(tabletitle) # 居中显示 2.requests.get()获得的response的编码问题 123html = requests.get('http://jwc.njupt.edu.cn/1594/list.htm',headers = headers)html.encoding = 'utf-8'#Requests库的自身编码为: r.encoding = ‘ISO-8859-1’ Github地址:Freedomisgood/SeverChan_Nyedu","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"高科GSWIFI江苏破解教程","slug":"高科GSWIFI江苏破解教程","date":"2018-11-04T02:06:34.000Z","updated":"2019-09-15T08:07:31.102Z","comments":true,"path":"2018/11/04/高科GSWIFI江苏破解教程/","link":"","permalink":"https://nymrli.top/2018/11/04/高科GSWIFI江苏破解教程/","excerpt":"","text":"1.重置路由器设置 为了以防之前其他人已经设置过某些东西,可能会影响到之后的使用，所以干脆直接重置。 2.连接路由器电源,不用插任何的wan口或者lan口 P.S.如果第二步,手机和电脑无法直接通过IP地址进入管理界面的话,可以考虑将 网线一头插入2号口,一头插入电脑的插口 , 然后再通过IP地址进入管理界面 3.登录路由器管理界面 ▲注意： 大多数路由器的管理界面IP地址为 192.168.1.1或者192.168.100.1,虽然高科路由器后面贴纸上说明的IP地址是192.168.8.1,但是那个不是初始的IP,需要自己设置到192.168.8.1. 如下是我已经修改好的IP为192.168.8.1的登录界面,默认密码为admin,登录后选择不保存密码 4.进入管理界面后先观察 首先是要观察软件版本与 GSWIFI 公众号中的最新能用的版本进行匹配,如果是一样的话就不需要升级系统固件,如果当前软件版本比较低就可能无法使用. 其次,由于没接网线,所以网线状态是WAN口未连接 5.修改配置 修改WAN口设置 如何查看手机MAC地址说明: 由于我使用的是英文系统…可能手机界面有点不同 1**.进入WLAN** 2.进入更多设置 最下面的MAC address就是 6.WIFI设置2.4G 7.LAN口设置 该步之后,等30s配置完成后,你会无法进入192.168.1.1,页面也会无响应,此时访问192.168.8.1重进管理界面 8.开始连接网线(查看网线状态) ▲▲.由于该路由器的WAN口被商家调到了3号LAN口,我也被这步坑了挺久…所以上述步骤都完成以后,将网线插入路由器的3号LAN口,再登录管理界面,此时应该就能看到这样的界面了… (p.s.或许你的路由器就是WAN口没改也说不定,反正如果没有效果的话,每个端口都试一下就是了) 能够正常显示这几个,则路由器已设置完成. 9.使用GSWIFI小助手对路由器再次设置 ▲注意,使用客服提供的APP,网盘链接在附录中 按照我们的教程来,IP地址填为192.168.8.1,然后按下&quot;开始联网&quot;,之后会有4步,这个过程中WIFI会不断的掉线,需要自己不断重连自己的WIFI(“Hello”),等到4步完成后就可以开始用掌上大学连上WIFI后一键上网了 完成图如下 10.使用掌上大学一键上网 教程到此就结束了,按照上述步骤应该就能完成高科GSWIFI路由器的破解上网了… 附录: GSWIFI小助手江苏版: 网盘:https://pan.baidu.com/share/init?surl=vwza9BJd9kjjMKH6f3ek3g 提取码:svdg 更新系统固件 找到GSWIFI公众号: 选择系统升级 然后查看升级教程 和 1082正式版系统(目前最新的系统固件)，然后根据里面提供的网盘将文件下载下来 下载后===&gt;解压===&gt;进入管理界面===&gt;系统升级===&gt;选择文件===&gt;刷写固件===&gt;执行（其中过程千万不能关闭电源或是乱动，就算按错了，等2-3分钟好了以后再重新刷写也无妨，但是千万不能断电源）","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"WSGI uWSGI uwsgi及nginx说明","slug":"WSGI-uWSGI-uwsgi及nginx说明","date":"2018-11-02T07:50:12.000Z","updated":"2019-09-15T08:07:31.016Z","comments":true,"path":"2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/","link":"","permalink":"https://nymrli.top/2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/","excerpt":"","text":"客户端发出请求==&gt;服务器接受、处理请求与响应 的过程示意图 1. WSGI： 全称是Web Server Gateway Interface(服务器网关接口)。WSGI不是服务器，python模块，框架，API或者任何软件，只是一种规范( 是一个**Web服务器（如nginx）与应用服务器（如uWSGI）**通信的一种规范（协议）==&gt; 可以理解为服务器与应用程序通信的接口规范要求)，描述web server如何与web application通信的规范。server和application的规范在PEP 3333中有具体描述。因为WSGI没有官方的实现, 所以WSGI更像一个协议，只要遵照这些协议，都可以在任何服务器(Server)上运行 2.uwsgi： 与WSGI一样是一种通信协议，是uWSGI服务器的独占协议，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种不同的协议。该协议据说性能非常高，是fcgi协议的10倍快;而且内存占用率低，为mod_wsgi的一半左右，同时它还支持多应用的管理及应用的性能监控 3.uWSGI： 是一个web服务器，而且也可以当做中间件。它实现了WSGI协议、uwsgi协议、http协议等。在生产环境中使用uWSGI作为python web的服务器,可以用来托管 Python WSGI应用。它具有应用服务器，代理，进程管理及应用监控等功能(但可以把看作是一个应用程序，帮助我们实现WSGI协议)，这样我们可以不再关注网络通信的底层实现，将精力更多放在处理HTTP请求数据，返回HTML。 4.uWSGI+nginx 综上所述可以看出uWSGI可以直接当做服务器，而为了进一步的并发提升就需要加上nginx(提高负载均衡) ▲.当uWSGI+nginx使用时，nginx作为web服务器，而uWSGI作为中间件(这边不一定正确,个人理解) uWSGI不足的地方: uWIGS也可以返回静态文件(css,js,img…)，但是很笨拙，所以更好的做法是用反向代理服务器（比如Nginx）来处理此类请求，减轻应用服务器的负载，获得更好的性能。 利用uWIGS可以是我们的web应用得到更强的并发能力，uWIGS也可以返回静态文件(css,js,img…)，但是很笨拙，一般静态文件都交由Nginx进行传输，所以配置中一般不配置static-map,如果直接由uWIGS接受HTTP请求则需要设置http:xxxx，如果只需要与反向代理服务器进行交互则只需要接受socket，uWIGS与Nginx交互相当于两个进程间交互，一般使用的是.sock文件或者指定端口接受socket。指定端口时再使用浏览器访问相应端口，uWIGS会提示skip，跳过该HTTP请求。 同时还有的是uWSGI本身的负载均衡没有nginx牛逼。所以阉割掉不用。 5.Nginx是一个Http和反向代理服务器 什么是反向代理服务器呢？ ▲正向的就是由浏览器主动的想代理服务器发出请求，经代理服务器做出处理后再转给目标服务器 ▲反向的就是不管浏览器同不同意，请求都会经过代理服务器处理再发给目标服务器 这其中的区别就是必须经过Nginx反向代理服务器，这就有了使用Nginx的几个好处： 安全：不管什么请求都要经过代理服务器，这样就避免了外部程序直接攻击web服务器 负载均衡：根据请求情况和服务器负载情况，将请求分配给不同的web服务器，保证服务器性能 提高web服务器的IO性能：这个我也没看懂，总结来说就是请求从客户端传到web服务器是需要时间的，传递多长时间就会让这个进程阻塞多长时间，而通过反向代理，就可以在反向代理这完整接受请求，然后再传给web服务器，从而保证服务器性能，而且有的一些简单的事情（比如静态文件）可以直接由反向代理处理，不经过web服务器 总结","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"apt-get update无法连接","slug":"apt-get-update无法连接","date":"2018-11-02T05:21:45.000Z","updated":"2019-09-15T08:07:30.919Z","comments":true,"path":"2018/11/02/apt-get-update无法连接/","link":"","permalink":"https://nymrli.top/2018/11/02/apt-get-update无法连接/","excerpt":"","text":"出现的问题 原因是在apt-get update时遇到了Unable to connect to 代理，（由于apt-get update一直显示无法连接172.17.18.141百度后发现这并不是个特殊的IP,而且也可以ping到百度）于是想到是否使用了代理。 apt代理的设置： 临时方法 export http_proxy=http://10.3.0.1:80 长久方法 (1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。) Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;; Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;; 保存apt.conf文件。 (2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件) 建立文件 vim proxyfile Acquire::http::proxy &quot;http://10.3.0.1:80&quot;; Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;; Acquire::https::proxy &quot;http://10.3.0.1:80&quot;; 使用时sudo apt-get install xxx -c proxyfile (2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 ) 在您的.bashrc文件末尾添加如下内容 export http_proxy=http://用户名:密码@地址:端口/ export https_proxy=http://用户名:密码@地址:端口/ export ftp_proxy=http://用户名:密码@地址:端口/ 附上一篇ubuntu设置代理的文章:ubuntu设置代理 Ubuntu下让终端走SS代理的方法 Ubuntu下让终端走SS代理需要第三方软件的帮助，即privoxy。 privoxy 是非快取式 (non-caching) 的网页代理伺服器，具有进阶的过滤能力，可强化隐私权，还可以修改网页资料、管理 HTTP cookies、去除广告等。 安装 privoxy sudo apt-get install privoxy 安装完成后在 /etc/privoxy 目录下可以找到配置文件 config。 配置 privoxy 一般地，改配置前应该备份配置。 mv /etc/privoxy/config /etc/privoxy/config.back 然后打开 config 文件，找到listen-address那一行，修改值为 privoxy 监听的地址，一般使用默认。 然后再找到forward-socks5那一行，去掉注释，值为SS代理监听的地址。 让终端走SS代理,修改配置后，重启 privoxy。 sudo /etc/init.d/privoxy restart 然后在终端下添加 http 代理。 export http_proxy=”127.0.0.1:8118” export https_proxy=”127.0.0.1:8118” 然后就可以愉快的用终端翻墙了。 原文：https://blog.csdn.net/tailgo/article/details/52075643","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"Windows控制台Cmd乱码（及永久修改编码）解决方法","slug":"Windows-控制台Cmd乱码（及永久修改编码）解决方法","date":"2018-10-28T08:42:20.000Z","updated":"2019-09-15T08:07:31.013Z","comments":true,"path":"2018/10/28/Windows-控制台Cmd乱码（及永久修改编码）解决方法/","link":"","permalink":"https://nymrli.top/2018/10/28/Windows-控制台Cmd乱码（及永久修改编码）解决方法/","excerpt":"","text":"我本机的系统环境：`OS Name: Microsoft Windows 10 家庭中文版 Windows 控制台Cmd乱码的解决办法(一次性) 在cmd中输入 CHCP 65001 注：CHCP是一个计算机指令，能够显示或设置活动代码页编号。 代码页 描述 65001 UTF-8代码页 950 繁体中文 936 简体中文默认的GBK 437 MS-DOS 美国英语 但是通过CHCP设置编码是治标不治本的,想永久的更改cmd编码值需要修改注册表 Windows 控制台Cmd乱码的解决办法(永久性) 方法一： 1.在cmd中输入regedit进入注册表 2.找到HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe 3.新建一个 DWORD（32位值）,命名为CodePage，值设为65001 4.已有CodePage的话，修改它，改为十进制，65001 方法二：(亲测有效) 1.新建一个cmd.reg注册表文件: 2.内容输入如下： 123456789Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe]&quot;CodePage&quot;=dword:0000fde9&quot;FontFamily&quot;=dword:00000036&quot;FontWeight&quot;=dword:00000190&quot;FaceName&quot;=&quot;Consolas&quot;&quot;ScreenBufferSize&quot;=dword:232900d2&quot;WindowSize&quot;=dword:002b00d2 3.双击运行","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"JS正则及常用方法函数总结","slug":"JS正则及常用方法函数总结","date":"2018-10-25T03:55:20.000Z","updated":"2019-09-15T08:07:30.949Z","comments":true,"path":"2018/10/25/JS正则及常用方法函数总结/","link":"","permalink":"https://nymrli.top/2018/10/25/JS正则及常用方法函数总结/","excerpt":"","text":"JS正则及常用方法函数总结 正则表达式作为一种匹配处理字符串的利器在很多语言中都得到了广泛实现和应用，web开发本质上是处理字符串（服务端接受请求处理后拼接字符串作为响应，这在早期的CGI编程中最明显，然后客户端解析字符串进行渲染和执行），所以说，JS作为一门常用于web开发的语言，必然要具备正则这种强大的特性，本文将对JS中的正则用法及常用函数进行一番总结。 1.正则对象及其属性 首先正则对象是JS中内置的一个对象，好比Array以及Math一样，不需要第三方库的支持，通常我们采取两种方式来定义一个正则对象. 1）构造函数方式 12345var reg=new RegExp('abc','gi');/*这里，第一个参数是正则的内容，第二个参数是修饰符，修饰符通常有三种，i,g,m，i表示的含义是忽略大小写进行匹配，g表示全局匹配即匹配到第一个之后不停止继续匹配，m表示多行匹配即遇到换行后不停止匹配继续直到被匹配字符串结束。*/ /i (忽略大小写) /g (全文查找出现的所有匹配字符,否则只匹配第一个出现的) /m (多行查找) /gi(全文查找、忽略大小写) /ig(全文查找、忽略大小写) 2）字面量方式 123456var reg=/abc/gi;consolo.dir(reg);/**▲.两个斜杠之间的是定义的正则内容*，最后一个斜杠之后的是修饰符，这种方式比第一种简单高效，所以通常使用第二种方式来定义正则。*/ 2.属性 在控制台中打印一个正则对象如下： global属性，该属性为布尔类型，用来表示该正则是否是全局匹配， ignoreCase属性，布尔类型，用来指示是否忽略大小写， lastIndex为number类型，用来表示上次匹配成功的位置， multiline，布尔类型，用来表示是否是多行匹配，source，string类型，用来表示正则的内容。 lastIndex 属性表示的索引处为目标字符串匹配（并且不会尝试从后续索引匹配）,你不能直接更改这个属性，它是只读的。可以通过^ unicode标志开启了多种 Unicode 相关的特性。使用 “u” 标志，任何 Unicode 代码点的转义都会被解释。 3.方法 通常对于一个正则对象来讲，我们能够使用的方法基本上有三个，即regObj.test,regObj.exec及regObj.compile 1）test方法 该方法用来测试某个字符串是否与正则匹配，匹配就返回true，否则返回false。该方法接受一个字符串作为参数 123 var reg=/boy(s)?\\s+and\\s+girl(s)?/gi; console.log(reg.test('boy and girl'));//==&gt;true 2)compile方法 该方法的作用是能够对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，适合于对一个正则对象(模式)多次调用的情况下，如果对一个正则只使用一两次，那么该方法没有特别显著的效应。 接受的参数也是一个正则。 1234567var reg=/[abc]/gi; console.log(reg.test('a')); //==&gt;true reg=/[cde]/gi; console.log(reg.test('a')); //==&gt;false reg.compile(reg); console.log(reg.test('a')); //==&gt;false//被编译的正则和没有编译的正则在测试结果上没有任何区别，只是多次调用的效率上会更高一些。 3）exec方法 该方法属于一个比较复杂的方法，它接受一个字符串，返回的是一个数组，数组中第0个元素是匹配的子字符串，第二个元素是正则中的第一个子分组匹配的结果（如果有子分组，即正则中存在用圆括号括起来的分组），第三个是正则中第二个子分组匹配的结果（如果有第二个子分组）…以此类推，如果没有正则子分组，那么该数组长度仅仅为1，就是匹配到的那个子字符串。同时，返回的这个数组同时还是一个对象，它拥有两个属性，分别为index表示当前匹配到的子字符串所处的位置，input属性表示被匹配的原始字符串。最后，该方法中的正则对象如果不是全局匹配，即没有g修饰符，则每次调用只会从字符串开头处匹配第一个结果，且每次调用结果都是一样的。只有指定为全局匹配，才能够按照从左往右依次去匹配，每次调用匹配一个结果，正则对象的lastIndex属性前进到本次匹配的末尾位置，下回再调用的时候，会从lastIndex处开始匹配而不是从头匹配。 12345678var reg=/(\\w)l(\\w)/g;var str=\"hello world hello 123 hello programmer hello test\";var arr=reg.exec(str); while(arr)&#123; console.dir(arr); console.log(\"lastIndex:\"+reg.lastIndex); arr=reg.exec(str); &#125; 结果如下： 12345678910111213141516//非全局匹配代码：var reg=/(\\w)l(\\w)/; var str=\"hello world hello 123 hello programmer hello test\"; var arr=reg.exec(str); var i=0; while(arr)&#123; i++; if(i&lt;=4)&#123; console.dir(arr); console.log(\"lastIndex:\"+reg.lastIndex); arr=reg.exec(str); &#125; else&#123; break; &#125; &#125; 这个时候每次调用的结果都一样，lastIndex根本没有发生变化。 以上就是正则对象及其方法，其实在使用的过程中，JS中的String类型的对象也拥有一些和正则相关的方法，如下： String类型的对象的正则方法 1）search方法 该方法是string对象的一个方法，用来查找第一次匹配的子字符串的位置，如果找到就返回一个number类型的index值，否则返回-1,它返回的只是第一次匹配的位置。 它接受一个正则或者子字符串为参数，这里我们只讨论正则的情况。 123var str=\"hello world\";console.log(str.search(/o/g));//输出结果为4，可以看到尽管具有多个匹配结果而且也声明为全局匹配，但是还是返回的是第一个匹配到的子串的位置； 2）replace方法 该方法用来将字符串中的某些子串替换为需要的内容，接受两个参数，第一个参数可以为正则或者子字符串，表示匹配需要被替换的内容，第二个参数为被替换的新的子字符串。如果声明为全局匹配则会替换所有结果，否则只替换第一个匹配到的结果。 1234var str=&quot;hello world,hello test&quot;;console.log(str.replace(/hello/g,&apos;hi&apos;));//结果为hi world,hi test//如果将上面代码中的g修饰符去掉，则返回的结果是hi world,hello test 3）split方法 该方法主要用来将一个字符串拆分成一个数组，它接受一个正则或者子字符（串）作为参数，返回一个数组，简单情况下，我们不需要使用正则，只有在字符串拆分规则不统一的情况下才需要使用正则，如下： 12345var str=\"how|old*are you\";var arr=str.split(/\\||\\*|\\s+/);// 以|、*、多项空格为分隔符// \\s 匹配任何空白字符,包括空格、制表符、换页符等等console.log(arr); 这里需要将str拆分为单词数组，由于每个单词之间存在不一样的分隔符，我们采取正则来匹配，结果如下： 4）match方法 该方法接受一个正则作为参数，用来匹配一个字符串，它的输出结果在不是全局匹配的情况下和exec方法的结果一致即一个数组并带有额外的属性，如果采用全局匹配，则不返回任何和其被匹配字符串相关的信息，只返回匹配的结果。 12345678910111213141516//非全局匹配代码：var reg2=/(\\w)s(\\w)/;var str2=\"ws1esr\";var result=str2.match(reg2);var i=0; while(result)&#123; i++; if(i&lt;=4)&#123; console.dir(result); console.log(\"lastIndex:\"+reg2.lastIndex); &#125; else&#123; break; &#125; &#125;//非全局匹配下，结果和exec非全局匹配方法返回的完全一致， 12345//全局匹配代码：var reg3=/(\\w)s(\\w)/g;var str4=\"ws1estqsa\";console.dir(str4.match(reg3));//可以看到，在全局匹配下的时候，它不同于exec方法，它会一次性将所有匹配结果以数组形式返回，且这个数组没有其他属性用来指向被匹配字符串的信息，而exec方法在全局匹配下每次返回的依然是本次匹配的结果数组，且这个数组中只包含本次匹配信息，同时又拥有指向被匹配字符串的信息，即match方法在全局匹配下一次性返回了所有匹配结果，而exec在全局匹配下返回的依然是当次匹配结果。","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"},{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://nymrli.top/tags/JavaScript/"}]},{"title":"Sublime Text3 Python虚拟环境（补充）——解决控制台中文乱码情况","slug":"Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况","date":"2018-10-24T10:52:35.000Z","updated":"2019-09-15T08:07:31.007Z","comments":true,"path":"2018/10/24/Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况/","link":"","permalink":"https://nymrli.top/2018/10/24/Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况/","excerpt":"","text":"转自：edwardgui的博客 正常的用python编译控制台是不会出现乱码的，但是在使用虚拟环境的情况下中文总是乱码，一开始以为是windows控制台编码的问题。找了挺久后发现是python+virtualenv编译系统的问题，现在我就带领大家解决这个问题。 ▲注：Windows环境下 首先看下是否已经安装了Virtualenv package插件，如果没有，则Ctrl+Shift+P，install Package,输入Virtualenv安装。 找到插件安装的地方：C:\\Users{Username}\\AppData\\Roaming\\Sublime Text 3\\Installed Packages ==&gt;注意改变一下Username 解压Virtualenv.sublime-package文件，可以通过先添加后缀.zip变为Virtualenv.sublime-package.zip再解压 包含文件如下： 修改Python + Virtualenv.sublime-build文件， 增加一行：&quot;env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf8&quot;}, 使其变成 1234567&#123;&quot;env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf8&quot;&#125;,&quot;target&quot;: &quot;virtualenv_exec&quot;,&quot;shell_cmd&quot;: &quot;python -u \\&quot;$file\\&quot;&quot;,&quot;file_regex&quot;: &quot;^[ ]*File \\&quot;(...*?)\\&quot;, line ([0-9]*)&quot;,&quot;selector&quot;: &quot;source.python&quot;&#125; 然后保存，再把该文件打包为Virtualenv.sublime-package.zip再去掉后缀，就大功告成了。 最后打开Sublime Text3使用Python + Virtualenv 编译，就能看到中文正常输出啦！","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"}]},{"title":"Python爬虫知识点——将Cookie保存到本地的多种方法介绍","slug":"Python爬虫知识点——将Cookie保存到本地的多种方法介绍","date":"2018-10-24T10:43:34.000Z","updated":"2019-09-15T08:07:30.994Z","comments":true,"path":"2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/","excerpt":"","text":"方法一：urllib2 结合cookielib及urllib2，Python2时期比较常用的方法，年代比较久远了。个人觉得太麻烦，改用requests. ▲需要注意的是cookielib在python3中已经改成了http.cookiejar 1234567891011121314151617181920212223242526272829303132333435#该方法本人未测试import urllib2import cookielib#将cookie保存在文件中def saveCookie(): #设置保存cookie的文件 filename = &apos;cookie.txt&apos; #声明一个MozillaCookieJar对象来保存cookie，之后写入文件 cookie = cookielib.MozillaCookieJar(filename) #创建cookie处理器 handler = urllib2.HTTPCookieProcessor(cookie) #构建opener opener = urllib2.build_opener(handler) #创建请求 res = opener.open(&apos;http://www.baidu.com&apos;) #保存cookie到文件 #ignore_discard的意思是即使cookies将被丢弃也将它保存下来 #ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入 cookie.save(ignore_discard=True,ignore_expires=True)#从文件中获取cookie并且访问(我们通过这个方法就可以打开保存在本地的cookie来模拟登录)def getCookie(): #创建一个MozillaCookieJar对象 cookie = cookielib.MozillaCookieJar() #从文件中的读取cookie内容到变量 cookie.load(&apos;cookie.txt&apos;,ignore_discard=True,ignore_expires=True) #打印cookie内容,证明获取cookie成功 for item in cookie: print &apos;name:&apos; + item.name + &apos;-value:&apos; + item.value #利用获取到的cookie创建一个opener handler = urllib2.HTTPCookieProcessor(cookie) opener = urllib2.build_opener(handler) res = opener.open(&apos;http://www.baidu.com&apos;) print res.read() 方法二: 使用requests.cookie 读取cookies 在这里我用的是LWPCookieJar保存在txt文件中，还有个是MozillaCookieJar，都是由FileCookieJar 派生而来，实现了save()方法，而FileCookieJar 没有实现save() MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。 LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。 123456789#实例化一个LWPCookieJar对象load_cookiejar = cookielib.LWPCookieJar()#从文件中加载cookies(LWP格式)load_cookiejar.load(&apos;cookies.txt&apos;, ignore_discard=True, ignore_expires=True)#工具方法转换成字典load_cookies = requests.utils.dict_from_cookiejar(load_cookiejar)#工具方法将字典转换成RequestsCookieJar，赋值给session的cookies.self.session.cookies = requests.utils.cookiejar_from_dict(load_cookies) 存储cookies 将cookies转换成LWP格式然后保存为文本格式 123456789#实例化一个LWPcookiejar对象new_cookie_jar = cookielib.LWPCookieJar(&apos;cookie.txt&apos;)#将转换成字典格式的RequestsCookieJar（这里我用字典推导手动转的）保存到LWPcookiejar中===&gt;RequestsCookieJar没有实现save()方法requests.utils.cookiejar_from_dict(&#123;c.name: c.value for c in self.session.cookies&#125;, new_cookie_jar)#保存到本地文件new_cookie_jar.save(&apos;cookies.txt&apos;, ignore_discard=True, ignore_expires=True) 方法三: 将cookie字典弄成字典形式然后pickle或者json写入文件中 存储cookie 12345678import requests,json,pprints = requests.session()s.headers = &#123;...&#125;a = s.get(&quot;https://www.baidu.com&quot;)cookies = requests.utils.dict_from_cookiejar(s.cookies)with open(&quot;.\\\\cook.txt&quot;, &quot;w&quot;) as fp: json.dump(cookies, fp)pprint.pprint(cookies,width=5) 读取cookie 123with open(&quot;.\\cook.txt&quot;, &quot;w&quot;) as fp: load_cookies=son.load(fp)session.cookie = requests.utils.cookiejar_from_dict(load_cookies) 方法四: 将requests.cookie设置为LWPCookieJar、或MozillaCookieJar保存 123456session = requests.Session()#创建个 LWPCookieJar对象session.cookies = LWPCookieJar(filename=&apos;cook.txt&apos;)s.get(&apos;https://www.baidu.com/&apos;,headers=headers)session.cookies.save(ignore_discard=True, ignore_expires=True)#如果save()时没有写filename参数，则默认为实例化LWPCookieJar时给的文件名 save()方法的两个重要参数 ignore_discard: save even cookies set to be discarded. ignore_expires: save even cookies that have expired.The file is overwritten if it already exists ignore_discard的意思是即使cookies将被丢弃也将它保存下来，ignore_expires的意思是如果cookies已经过期也将它保存并且文件已存在时将覆盖 总结方法二和方法三可以看出，就是要将cookie转换成然后save() 简单介绍下cookielib模块作用，科普下实现cookie知识 python3中将cookielib模块改为了http.cookiejar 12345678910&gt; cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。例如可以利用本模块 的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送。coiokielib模块用到的对象主要有下面几个：CookieJar、 FileCookieJar、MozillaCookieJar、LWPCookieJar。其中他们的关系如下：&gt; &gt; CookieJar &gt; &gt; | &gt; &gt; FileCookieJar &gt; &gt; / \\ &gt; MozillaCookieJar LWPCookieJar","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"Python爬虫知识点——Session与Cookie","slug":"Python爬虫知识点——Session与Cookie","date":"2018-10-24T10:36:56.000Z","updated":"2019-09-15T08:07:30.990Z","comments":true,"path":"2018/10/24/Python爬虫知识点——Session与Cookie/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——Session与Cookie/","excerpt":"","text":"Session和Cookie： Cookie：保持登录后的认证状态而保存在本地的数据 session:用cookie来标记用户，cookie携带了会话ID消息，通过检查cookie就能找到会话(session) cookie与session相互配合，一个处于客户端，一个处于服务端，两者相互协作。 会话cookie和持久cookie 会话Cookie：把cookie放在浏览器内存里，浏览器关闭后失效。 持久Cookie：保存cookie到客户端的硬盘中，下次继续使用。 由Cookie的Max Age和Expires决定了过期的时间。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——代理","slug":"Python爬虫知识点——代理","date":"2018-10-24T10:36:28.000Z","updated":"2019-09-15T08:07:30.992Z","comments":true,"path":"2018/10/24/Python爬虫知识点——代理/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——代理/","excerpt":"","text":"代理 基本原理 代理实际上指代理服务器。功能是代理 网络用户去取得网络信息，是网络信息的中转站。 正常的请求过程为：发送请求给服务器===&gt;web服务器吧响应传回 设置代理服务器后：&gt;向代理服务器发送请求&gt;请求发送给代理服务器==&gt;再由代理服务器发送web服务器==&gt;由代理服务器把web服务器返回的响应转发给本机 作用 突破自身IP访问限制，访问些平时不能访问的站点。 访问一些单位或团体内部资源:比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。 提高访问速度:通常代理服务器都设置-一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息传给用户，以提高访问速度。 隐藏真实IP:上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP,防止自身的IP被封锁。 代理分类 根据代理的协议，代理可以分为如下类别。 FTP代理服务器: 主要用于访问FTP服务器，一般有上传、 下载以及缓存功能，端口一般为 21、2121等。 HTTP代理服务器:主要用于访问网页，一般有内容过滤和缓存功能，端口一般为808080、3128 等。 SSL/TLS代理:主要用于访同加密网站，般有 SsL 或TLS 加密功能(最高支持128位加密强度)，端口一般为443。 RTSP代理:主要用于访问Real流媒体服务器，一般有缓存功能， 端口般为554。 Telnet代理: 主要用于tenei远程控制黑客人侵计算机时常用于隐藏身份)，端口一般为23 POP3/SMTP代理:主要用于POP3/SMTP方式收发邮件，一般有缓存功能，端口-般为1025.口SOCKS代理:只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般 有 存功能，端口一般为1080。SOCKS代理协议又分为SOCKS4和SOCKS5,前者只支持TCP而后者支持TCP和UDP，还支持各种身份验证机制、服务器端域名解析等。简单来说SOCKS4能做到的SOCKS5都可以做到，但SOCKSS能做到的SOCKS4不一定能做到。 2.根据匿名程度区分 根据代理的匿名程度，代理可以分为如下类别。 高度匿名代理：会将数据包原封不动地转发，在服务端看来就好像真的是一 个普通客户端访问，而记录的IP是代理服务器的IP。 普通匿名代理：会在数据包上做一些改动， 服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实IP。代理服务器通常会加人的HTTP头有HTTP_VIA和HTTP_X_FORWARDED_FOR. 透明代理：不但改动了数据包，还会告诉服务器客户端的真实IP。这种代理除了能用缓存技术调高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。 间谍代理：指组织或个人创建的用于记录用户传输的数据， 然后进行研究、监控等目的代理服务器。 常用代理设置 网上的免费代理 付费的代理服务 ADSL拨号","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——请求","slug":"Python爬虫知识点——请求","date":"2018-10-24T10:36:21.000Z","updated":"2019-09-15T08:07:30.995Z","comments":true,"path":"2018/10/24/Python爬虫知识点——请求/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——请求/","excerpt":"","text":"请求 :请求方法、请求网址、请求头、请求体 请求方法： 常见的为:GET、POST GET与POST主要区别： GET请求参数包含在URL，可从URL中看出。POST请求的URL不包含参数，都是通过表单的形式传输的，包含在请求体中 GET请求提交的数据最多只有1024字节，POST无限制 其他还有HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE 请求的网址： 即URL，我们想要请求的资源 请求头： 用来说明服务器要使用的附加信息，比较总要的有Cookie、Referer、User-Agent等。 Accept:请求报头域，用于指定客户端可接受哪些类型的信息。 Accept-Language:指定客户端可接受的语言类型。 Accept-Encoding:指定客户端可接受的内容编码。 Host:用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位 置。从HTTP1.1版本开始，请求必须包含此内容。 Cookie:也常用复数形式Cookies, 是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输人用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies 并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。 Referer:此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。 User-Agent: 简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等消息。在做爬虫时加上此信息，可以伪装成浏览器；如果不加，很可能被识别出为爬虫 Content-Type:也叫互联网媒体类型( Intermet Media Type)或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。更多对应关系可以查看此对表:http://tool.oschina.net/commons 文件扩展名 Content-Type(Mime-Type) .html、 .htx 、 .htm text/html .gif image/gif .json application/json ​ Content-Type与POST提交数据方式的关系 Content-Type 提交数据的方式 appication/x-www-urlencodeed 表单数据 multipart/form-data 表单文件上传 applicatiobn/json 序列化json数据 text/html XML数据 如果构造POST请求，需要使用正确的Content-Type，不然可能导致POST提交后无法正常响应 ==&gt;因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。 请求体： 请求体一般承载的内容是POST请求中的表单数据，而对GET请求，请求体则为空。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——响应","slug":"Python爬虫知识点——响应","date":"2018-10-24T10:36:17.000Z","updated":"2019-09-15T08:07:30.993Z","comments":true,"path":"2018/10/24/Python爬虫知识点——响应/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——响应/","excerpt":"","text":"响应： 响应状态码、响应头、响应体 响应状态码： 表2-3常见的错误代码及错误原因 状态码 说明 详情 100 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换。 200 成功 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 201 已创建 请求成功并且服务器创建了新的资源。 202 已接受 服务器已接受请求，但尚未处理。 203 非授权信息 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 无内容 服务器成功处理了请求，但没有返回任何内容。 205 重置内容 服务器成功处理了请求，但没有返回任何内容。 206 部分内容 服务器成功处理了部分 GET 请求。 300 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 查看其他位置 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 未修改 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 305 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307 临时重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 400 错误请求 服务器不理解请求的语法。 401 未授权 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 禁止 服务器拒绝请求。 404 未找到 服务器找不到请求的网页。 405 方法禁用 禁用请求中指定的方法。 406 不接受 无法使用请求的内容特性响应请求的网页。 407 需要代理授权 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 请求超时 服务器等候请求时发生超时。 409 冲突 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。 410 已删除 如果请求的资源已永久删除，服务器就会返回此响应。 411 需要有效长度 服务器不接受不含有效内容长度标头字段的请求。 412 未满足前提条件 服务器未满足请求者在请求中设置的其中一个前提条件。 413 请求实体过大 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 请求的 URI 过长 请求的 URI（通常为网址）过长，服务器无法处理。 415 不支持的媒体类型 请求的格式不受请求页面的支持。 416 请求范围不符合要求 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 未满足期望值 服务器未满足&quot;期望&quot;请求标头字段的要求。 500 服务器内部错误 服务器遇到错误，无法完成请求。 501 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502 错误网关 服务器作为网关或代理，从上游服务器收到无效响应。 503 服务不可用 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504 网关超时 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 HTTP 版本不受支持 服务器不支持请求中所用的 HTTP 协议版本。 响应头 响应头包含了服务器对请求的应答信息，如Cmene-Type. Serve. Set-cookie等。 下面简要说有 一些常用的头信息。 Date:标识响应产生的时间。 Last-Modifed:指定资源的最后修改时间。 公有地会 Content-Encoding:指定响应内容的编码。 Server:包含服务器的信息，比如名称、版本号等。 Content-Type:文档类型，指定返回的数据类型是什么，如texthtmI代表返回HTML文档， application/x-javascript则代表返回JavaScript文件，imagefjpeg 则代表返回图片。 Set-Cookie:设置Cookies。 响应头中的Set-Cookie 告诉浏览器需要将此内容放在Cooke 中，下次请求携带Cookies请求。 Expires:指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。立 果再次访问时，就可以直接从缓存中加载，降低服务器负载，编短加载时间。 响应体 最重要的当属响应体的内容了。 响应的正文数据都在响应体中，比如请求网页时，它的响应体就 是网页的HTML代码:请求一张图片时， 它的响应体就是图片的二进制数据。我们做爬虫请求后主 要解析的内容就是响应体。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——爬虫的基本原理","slug":"Python爬虫知识点——爬虫的基本原理","date":"2018-10-24T10:36:10.000Z","updated":"2019-09-15T08:07:30.994Z","comments":true,"path":"2018/10/24/Python爬虫知识点——爬虫的基本原理/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——爬虫的基本原理/","excerpt":"","text":"爬虫的基本原理 爬虫就是获取网页并提取和保存信息的自动化程序 获取网页： 获取网页就是获取网页的源码，只要把源码获取下来，就可以从中提取想要的消息 爬虫的流程：想网站的服务器发送一个请求，返回的响应体就是网页的源代码。 ​ &gt;1,构造请求发送给服务器=&gt;2.接受响应并解析 提取信息： 通过分析网页结构，提取网页信息。通常使用的解析库有:BeautifulSoup、lxml、pyquery，也可以使用正则，但是构造正则表达式比较复杂且易错 保存数据： 将提取的数据保存到某处以便后续利用。保存形式有：TXT、Json、数据库：MySQL、MongoDB、或远程服务器SFTP… 自动化程序 替人完成完成爬取工作的自动化程序，可以在抓取过程中进行异常处理……保证爬取的高效运行","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——URL与URI","slug":"Python爬虫知识点——URL与URI","date":"2018-10-24T10:35:53.000Z","updated":"2019-09-15T08:07:30.991Z","comments":true,"path":"2018/10/24/Python爬虫知识点——URL与URI/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——URL与URI/","excerpt":"","text":"URL与URI URL全称：Uniform Resource Locator(统一资源定位符) URI全称：Uniform Resource Identifier(统一资源标识符) 如https://github.com/favicon.ico为例，它既是一个URL又是一个URI。我们通过URL/URI唯一指定了它的访问方式。其中包括访问协议https、访问路径、资源名称favicon.ico。通过这个链接提供的消息，我们就可以直接访问到此资源所在的位置。这便是URL、URI的作用。 URL是URI的子集。===&gt;每个URL都是URI，但不是每个URI都是URL。 URI包括两个子类:URN和URL。其中URN只命名资源但不指定如何定位资源(如urn:isbn:0451450523)指定了一本书的ISBN，可以唯一标识，但未定位。 ▲.目前互联网中URN用得很少，几乎所有的URI都是URL。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"计算机网络知识","slug":"计算机网络知识","permalink":"https://nymrli.top/tags/计算机网络知识/"}]},{"title":"Python爬虫知识点——Chrome开发者工具Network","slug":"Python爬虫知识点——Chrome开发者工具Network","date":"2018-10-24T10:35:31.000Z","updated":"2019-09-15T08:07:30.989Z","comments":true,"path":"2018/10/24/Python爬虫知识点——Chrome开发者工具Network/","link":"","permalink":"https://nymrli.top/2018/10/24/Python爬虫知识点——Chrome开发者工具Network/","excerpt":"","text":"Chrome开发者工具中Network功能介绍 第一列Name:请求的名称，一般会将URL的最后一 部分内容当作名称。 第二列Status: 响应的状态码，这里显示为200，代表响应是正常的。通过状态码，我们可 以判断发送了请求之后是否得到了正常的响应。 第三列Type: 请求的文档类型。这里为document, 代表我们这次请求的是一个HTML文档,内容就是一些HTML代码。 第四列initiator: 请求源。用来标记请求是由哪个对象或进程发起的。 第五列Size: 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示from cache。 第六列Time:发起请求到获取响应所用的总时间。 第七列Waterfall:网络请求的可视化瀑布流。 响应中分General部分，请求头、响应头： 其中General含： Request URL为请求的URL， Request Method为请求的方法 Status Code为响应状态码， Remote Address为远程服务器的地址和端口 Referrer Policy为Referrer判别策略。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://nymrli.top/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"XShell通过SSH远程连接云服务器通过SSH远程连接云服务器","slug":"XShell通过SSH远程连接云服务器","date":"2018-10-24T10:32:05.000Z","updated":"2019-09-15T08:07:31.017Z","comments":true,"path":"2018/10/24/XShell通过SSH远程连接云服务器/","link":"","permalink":"https://nymrli.top/2018/10/24/XShell通过SSH远程连接云服务器/","excerpt":"","text":"1.账号密码登录 法一: 法二:","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"复制Django项目时需要注意、修改的地方","slug":"复制Django项目时需要注意、修改的地方","date":"2018-10-24T10:25:37.000Z","updated":"2019-09-15T08:07:31.043Z","comments":true,"path":"2018/10/24/复制Django项目时需要注意、修改的地方/","link":"","permalink":"https://nymrli.top/2018/10/24/复制Django项目时需要注意、修改的地方/","excerpt":"","text":"复制Django项目: manage.py中需要修改的地方 1os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;window.settings&quot;) settings.py中需要修改的地方 12345&quot;&quot;&quot;Django settings for window project.&quot;&quot;&quot;ROOT_URLCONF = &apos;window.urls&apos;WSGI_APPLICATION = &apos;window.wsgi.application&apos; urls.py中需要改动的地方 1&quot;&quot;&quot;window URL Configuration wsgi.py中需要修改的地方 123&quot;&quot;&quot;WSGI config for window project.os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;window.settings&quot;) django可复用模板 在project_name文件下的*.py 再在终端键入django-admin startproject xx --template=* (*为文件夹中py文件名) 12345678910111213141516171819202122232425262728293031323334import osimport sysfrom django.conf import settingsDEBUG = os.environ.get(&apos;DEBUG&apos;,&apos;on&apos;)== &apos;on&apos;ALLOW_HOSTS = [&apos;*&apos;]SECRET_KEY = os.environ.get(&apos;SECRET&apos;,&apos;&#123;&#123; secret_key &#125;&#125;&apos;)settings.configure( DEBUG = DEBUG, ALLOW_HOSTS = ALLOW_HOSTS, SECRET_KEY = SECRET_KEY, ROOT_URLCONF = __name__, MIDDLEWARE_CLASSES = ( &apos;django.middleware.common.CommonMiddleware&apos;, &apos;django.middleware.csrf.CsrfViewMiddleware&apos;, &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;, ))from django.conf.urls import urlfrom django.core.wsgi import get_wsgi_applicationfrom django.http import HttpResponsedef index(request): return HttpResponse(&apos;Hello Word&apos;)urlpatterns = ( url(r&apos;$&apos;,index),)application = get_wsgi_application()if __name__ == &apos;__main__&apos;: from django.core.management import execute_from_command_line execute_from_command_line(sys.argv)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Django","slug":"Django","permalink":"https://nymrli.top/tags/Django/"}]},{"title":"Python Web——Django笔记(一)","slug":"Python Web——Django笔记(一)","date":"2018-10-24T10:23:40.000Z","updated":"2019-09-15T08:07:30.975Z","comments":true,"path":"2018/10/24/Python Web——Django笔记(一)/","link":"","permalink":"https://nymrli.top/2018/10/24/Python Web——Django笔记(一)/","excerpt":"","text":"Python Web——Django笔记 新建项目: django-admin startproject blog . 创建应用程序(APP):python manage.py startapp fsite 添加app:INSTALLED_APPS=['...'] 新建的 app 如果不加到 INSTALL_APPS 中的话, django 就不能自动找到app中的模板文件(app-name/templates/下的文件)和静态文件(app-name/static/中的文件) .小提示，DEBUG=True 的时候，Django 还可以自动找到 各 app 下 static 文件夹中的静态文件（js，css，图片等资源） 创建SQLite数据库:python manage.py migrate #创建数据表 使模型生效:python manage.py makemigrations # Django 在 blog 应用的 migrations\\ 目录下生成了一个 0001_initial.py 文件，这个文件是 Django 用来记录我们对模型做了哪些修改的文件 创建管理员:python manage.py createsuperuser 添加template: 'DIRS':[os.path.join(BASE_DIR,'templates')], 清空数据库:python manage.py flush BASE_DIR 是 settings.py 在配置开头前面定义的变量 添加静态文件: 123STATIC_URL = &apos;/static/&apos;STATICFILES_DIRS = [os.path.join(BASE_DIR,&apos;static&apos;)]STATIC_ROOT = &quot;/home/nymrli/mvote/staticfiles/&quot; urls.py头文件 1234&gt; from django.contrib import admin&gt; from django.conf.urls import include,url&gt; from fsite.views import homepage,showpost&gt; views.py头文件 12345&gt; from django.shortcuts import render,redirect&gt; from django.http import HttpResponse,request&gt; from .models import Post&gt; from django.template.loader import get_template&gt; 使显示标题: 12def __str__(self): return self.title 书上的__unicode__和__repr__都没有用 增加显示其他时 12class PostAdmin(admin.ModelAdmin): list_display = (&apos;title&apos;,&apos;slug&apos;,&apos;pub_date&apos;) 要记得在admin.site.register(Post,PostAdmin)中增加PostAdmin 在urls.py中的url()的库文件要修改 12from django.contrib import adminfrom django.conf.urls import include,url 同时记得这点: 1234urlpatterns = [ url(&apos;^admin/&apos;, admin.site.urls), ## &apos;^admin/&apos;在/后面不能加$ url(r&apos;^$&apos;,homepage), ] views.py视图函数: 12def homepage(request): ##首先记得是*def* posts = Post.objects.all() ##虽然pycharm没提示Post有objects但仍有效果 count,post in enumerate(posts):1234for count,post in enumerate(posts): post_lists.append(&quot;NO.&#123;&#125;&quot;.format(str(count)) + str(post) + &quot;&lt;hr&gt;&quot;) post_lists.append(&quot;&lt;small&gt;&quot; + str(post.body.encode(&apos;utf-8&apos;)) + &quot;&lt;/small&gt;&lt;br&gt;&quot;) ### 这边的encode没必要加 template 步骤1: 在settings.py 中设置模板文件夹的位置. 步骤2:在urls.py中创建网址和views.py中函数的对应关系 步骤3:创建.html文件(例如index.html)做好排版数据要放的位置 步骤4:运行程序,以objects.all()在views.py中取得数据或资料 步骤5:以render函数把数据(posts)送到指定的模板文件(例如index.html)中. 网页对应urls.py 步骤1: 在urls.py中设置,只要是/post/开头的网址,就把后面接着的文字当做参数传送slug给post_detail显示单篇文章的函数 步骤2:在views.py中新增一个post_detail函数.除了接受request参数外,也接受slug参数. 步骤3:在templates文件夹中创建一个用来显示单篇文章的post.html 步骤4:在post_detail函数中,以slug为关键字搜索数据集,找出是否有符合的项目 步骤5:如果有符合的,就把找到的数据项传送给render函数,找出post.html模板页进行渲染(即进行页面显示),再把结果交给HttpResponse回传给浏览器 步骤6:如果没有符合的项目,就把网页转回首页 共享模板的使用: 文件名 用途说明 base.html 网站的基础模板，提供网站的主要设计、外观风格 header.html 网站中每一个网页共享的标题元素，通常是放置网站 Log 的地方 footer.html 网站中每一个网页的共享页尾，用来放置版权声明或其他参考信息 index.html 此范例网站的首页 post.html 此范例网站用来显示单篇文章的网页 显示图片 要用过滤器,不然就是串html代码. Wampserver初始: 12账号:root密码:空 bootstrap的CDN: HTML.CSS放在之前,JS的放在之前 12345678910111213&lt;head&gt;&lt;!-- Latest compiled and minified CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; integrity= &quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- Optional theme --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css&quot; integrity=&quot;sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- Latest compiled and minified JavaScript --&gt;&lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js&quot; integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/head&gt; 12345&lt;body&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.1.0.min.js&quot; integrity=&quot;sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/body&gt; 后台管理的自定义admin.py 显示更多的小标题 12345class ProductAdmin(admin.ModelAdmin): list_display = (&apos;pmodel&apos;,&apos;nickname&apos;,&apos;price&apos;,&apos;year&apos;) search_fields = (&apos;nickname&apos;,) ordering = (&apos;price&apos;,)admin.site.register(Product,ProductAdmin) 要显示中文的小标题 12345678class Product(models.Model): pmodel = models.ForeignKey(PModel,on_delete=models.CASCADE,verbose_name=&apos;型号&apos;) nickname = models.CharField(max_length=15,default=&apos;超值二手机&apos;,verbose_name=&apos;摘要&apos;) description = models.TextField(default=&apos;暂无说明&apos;) year = models.PositiveIntegerField(default=2018,verbose_name=&apos;出厂年份&apos;) price = models.PositiveIntegerField(default=0,verbose_name=&apos;价格&apos;) def __str__(self): //python3.*中都用__str__,不用__unicode__ return self.nickname 注意:admin.py 中的class ProductAdmin 仍需要 12345try: product = models.Product.objects.get(id=id) images = models.PPhoto.objects.filter(product=product)except: pass django中的ORM中如果用get找不到,就会产生一个DoseNotExist的异常中断程序 filter作用:我们很少会一次性从数据库中取出所有的数据；通常都只针对一部分数据进行操作 所以要将product中的成员单独 ***python 中没有null *** 与C不同的是，在python中是没有NULL的，取而代之的是None，它的含义是为空 python是把0，空字符串‘ ’和None都看作False，把其他数值和非空字符串都看作True 表示该值是一个空对象，空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 123456&lt;label for=&quot;byear&quot;&gt;你的年份:&lt;/label&gt;&lt;select name=&apos;byear&apos;&gt; &#123;% for year in years %&#125; &lt;option value=&quot;&#123;&#123; year &#125;&#125;&quot;&gt;&#123;&#123; year &#125;&#125;&lt;/option&gt; &#123;% endfor %&#125;&lt;/select&gt;&lt;br&gt; 这个也要放到中 对数据的提取: 12345try: urid = request.GET[&apos;user_id&apos;] urpass = request.GET[&apos;user_pass&apos;] urfcolor = request.GET.getlist(&apos;fcolor&apos;) #注意区别()与[] uryear = request.GET[&apos;byear&apos;]","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Django","slug":"Django","permalink":"https://nymrli.top/tags/Django/"}]},{"title":"Python Web——Django笔记(二)","slug":"Python Web——Django笔记(二)","date":"2018-10-24T10:23:40.000Z","updated":"2019-09-15T08:07:30.976Z","comments":true,"path":"2018/10/24/Python Web——Django笔记(二)/","link":"","permalink":"https://nymrli.top/2018/10/24/Python Web——Django笔记(二)/","excerpt":"","text":"Method= POST的操作 在posting.html中的&lt;form&gt;中加入标识符 1234&gt; &#123;% csrf_token %&#125;&gt; &lt;form name=&apos;my form&apos; action=&apos;.&apos; method=&apos;POST&apos;&gt; &gt; &#123;% csrf_token %&#125;&gt; ▲注意action='???' 12345678910在views.posting处理函数中改用RequestContext作为网页显示的内容: from django.template import RequestContext def posting(request): template = get_template('posting.html') moods = models.Mood.objects.all() message = '如果....' request_context = RequestContext(request) request_context.push(locals()) html = template.render(context=locals(), request=request) return HttpResponse(html) 窗体Form与ModelForm区别 Form 的所有选项都是自己在forms.py 中class定义的一个类,而ModelForm则是直接引用写好的models.py中的模型. 123456789101112131415from django import formsclass ContactForm(forms.Form): CITY = [ ['TP', 'Taipei'], ['TY', 'Taoyuang'], ['TC', 'Taichung'], ['TN', 'Tainan'], ['KS', 'Kaohsiung'], ['NA', 'Others'], ] user_name = forms.CharField(label='你的姓名',max_length=50,initial='李大仁') user_city = forms.ChoiceField(label='居住的城市',choices=CITY) user_school = forms.BooleanField(label='是否在学',required=False) user_email = forms.EmailField(label='电子邮件') user_message = forms.CharField(label='你的意见',widget=forms.Textarea) 1234567891011121314151617181920212223242526-----------------------------------------------------------------------------------------&lt;!--posting.html--&gt;&#123;% extends &quot;base.html&quot; %&#125;&#123;% block title %&#125;我有话要说&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=&apos;container&apos;&gt;&#123;% if message %&#125; &lt;div class=&apos;alert alert-warning&apos;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#123;% endif %&#125;&lt;form name=&apos;my form&apos; action=&apos;/&apos; method=&apos;POST&apos;&gt; &#123;% csrf_token %&#125; 现在的心情：&lt;br/&gt; &#123;% for m in moods %&#125; &lt;input type=&apos;radio&apos; name=&apos;mood&apos; value=&apos;&#123;&#123; m.status &#125;&#125;&apos;&gt;&#123;&#123; m.status &#125;&#125; &#123;% endfor %&#125; &lt;br/&gt; 心情留言板：&lt;br/&gt; &lt;textarea name=&apos;user_post&apos; rows=3 cols=70&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;label for=&apos;user_id&apos;&gt;你的昵称：&lt;/label&gt; &lt;input id=&apos;user_id&apos; type=&apos;text&apos; name=&apos;user_id&apos;&gt; &lt;label for=&apos;user_pass&apos;&gt;张贴/删除密码：&lt;/label&gt; &lt;input id=&apos;user_pass&apos; type=&apos;password&apos; name=&apos;user_pass&apos;&gt;&lt;br/&gt; &lt;input type=&apos;submit&apos; value=&apos;张贴&apos;&gt; &lt;input type=&apos;reset&apos; value=&apos;清除重填&apos;&gt;&lt;/form&gt;&lt;/div&gt;&#123;% endblock %&#125; 1234567891011121314151617181920212223242526&lt;!-- index.html (ch08www project) --&gt; &#123;% extends &quot;base.html&quot; %&#125; &#123;% block title %&#125;我有话要说&#123;% endblock %&#125; &#123;% block content %&#125; &lt;div class=&apos;container&apos;&gt; &#123;% if message %&#125; &lt;div class=&apos;alert alert-warning&apos;&gt;&#123;&#123; message &#125;&#125; &lt;/div&gt; &#123;% endif %&#125; &lt;form name=&apos;my form&apos; action=&apos;/&apos; method=&apos;POST&apos;&gt; &#123;% csrf_token %&#125; 现在的心情：&lt;br/&gt; &#123;% for m in moods %&#125; &lt;input type=&apos;radio&apos; name=&apos;mood&apos; value=&apos;&#123;&#123; m.status &#125;&#125;&apos;&gt;&#123;&#123; m.status &#125;&#125; &#123;% endfor %&#125; &lt;br/&gt; 心情留言板：&lt;br/&gt; &lt;textarea name=&apos;user_post&apos; rows=3 cols=70&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;label for=&apos;user_id&apos;&gt;你的昵称：&lt;/label&gt; &lt;input id=&apos;user_id&apos; type=&apos;text&apos; name=&apos;user_id&apos;&gt; &lt;label for=&apos;user_pass&apos;&gt;张贴/删除密码：&lt;/label&gt; &lt;input id=&apos;user_pass&apos; type=&apos;password&apos; name=&apos;user_pass&apos;&gt;&lt;br/&gt; &lt;input type=&apos;submit&apos; value=&apos;张贴&apos;&gt; &lt;input type=&apos;reset&apos; value=&apos;清除重填&apos;&gt; &lt;/form&gt; &lt;/div&gt; &#123;% endblock %&#125; 12345678910111213from django import formsfrom . import modelsclass PostForm(forms.ModelForm): class Meta: model = models.Post //告诉model 与那个模型耦合 fields = ['mood','nickname','message','del_pass'] //需要显示的data def __init__(self,*args,**kwargs): super().__init__(self,*args,**kwargs) self.fields['mood'].label = '现在的心情' self.fields['nickname'].label = '您的昵称' self.fields['message'].label = '心情留言' self.fields['del_pass'].label = '设置密码' 12345678910111213141516171819-----------------------------------------------------------------------------------------&lt;!--post2db.html--&gt;&#123;% extends &quot;base.html&quot; %&#125;&#123;% block title %&#125;我有话要说&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=&apos;container&apos;&gt;&#123;% if message %&#125; &lt;div class=&apos;alert alert-warning&apos;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#123;% endif %&#125; &lt;form name=&apos;my form&apos; action=&apos;/&apos; method=&apos;POST&apos;&gt; &#123;% csrf_token %&#125; &lt;table&gt; &#123;&#123; post_form.as_table&#125;&#125; //省去了前端对表格的代码 &lt;/table&gt; &lt;input type=&quot;submit&quot; value=&quot;张贴&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重填&quot;&gt;&lt;/form&gt;&lt;/div&gt;&#123;% endblock %&#125; △同时用ModelForm 的还有一好处为:并没有特别处理’‘现在的心情’'那部分,但ModelForm自动帮我们处理好了,外键的字段自动获得数据,并自动成为下拉式菜单 提交的数据接收: 12345678910111213141516基本窗体: &lt;form method=&quot;GET&quot;&gt; # 所以获取数据为: user_id = request.GET[&apos;user_id&apos;] &lt;form method=&quot;POST&quot;&gt; # user_id = request.POST[&apos;user_id&apos;]自定义窗体:(Form类) &lt;form method= &apos;POST&apos;&gt; # form(实例).cleaned_data[&apos;user_id&apos;] ModelForm : post_form.save() 数据的保存: 基本窗体: 123mood = models.Mood.objects.get(status=user_mood)post = models.Post.objects.create(mood=mood, nickname=user_id, message=user_post, del_pass=user_pass)post.save() ModelForm: 1post_form.save() 验证码功能(Django-simple-captcha): 安装Django-simple-captcha INSTALL_APPS中添加 python manage.py migrate url(r'^captcha/',include('captcha.urls')), 安装Pillow 1234class PostForm(forms.ModelForm): captcha = CaptchaField() def __init__(self,*args,**kwargs): self.fields[&apos;captcha&apos;].label = &apos;验证码&apos; 123456&gt; COLORS = [&gt; [&apos;黄&apos;,&apos;黄&apos;],&gt; [&apos;白&apos;,&apos;白&apos;],&gt; [&apos;红&apos;,&apos;红&apos;], //前面的是值,后面的是显示的选项&gt; ]&gt; 1234*render 与 render_to_response的区别* return render(request, &apos;blog_add.html&apos;, &#123;&apos;blog&apos;: blog, &apos;form&apos;: form, &apos;id&apos;: id, &apos;tag&apos;: tag&#125;)-----------------------------------------------------------------------------------------return render_to_response(&apos;blog_add.html&apos;, &#123;&apos;blog&apos;: blog, &apos;form&apos;: form, &apos;id&apos;: id, &apos;tag&apos;: tag&#125;) render比render_to_response少填一个request参数 12345request.session[&apos;username&apos;] = user.name //设置sessionif &apos;username&apos; in request.session: username = request.session[&apos;username&apos;] //取出session del request.session[&apos;username&apos;] //删除session 12345678if username: response.set_cookie(&apos;username&apos;,username) //设置Cookie //django1.11需要加encoding(&apos;utf-8&apos;),2.0不需要if &apos;username&apos; in request.COOKIES and &apos;usercolor&apos; in request.COOKIES: username = request.COOKIES[&apos;username&apos;] //取出COOKIEdef logout(request): response = HttpResponseRedirect(&apos;/&apos;) response.delete_cookie(&apos;username&apos;) //删除cookie Django的信息显示框架:messages framework 123from django.contrib import messages主要提供两个函数: messages.add_message(request,messages.SUCCESS,&apos;成功登陆了!&apos;) messages.get_messages(request) ▲注意message后面有没有s add_message()信息的内容类型默认分成以下几个等级: DEBUG 调试信息字符串 INFO 信息字符串 SUCCESS 成功信息字符串 WARNING 警告信息字符串 ERROR 错误信息字符串 Django auth用户验证 from django.contrib.auth.models import User 主要提供三个函数: authenticate(yz = input ,[]) //验证 login(request,user) //将数据存入Session,user为authenticate的返回值 logout(request) if user.is_active //检查账号是否有效,也没有括号 1234from django.contrib.auth.models import Userfrom django.contrib.auth import authenticatefrom django.contrib import auth //为了避免和自定义的 login.logout重名from django.contrib.auth.decorators import login_required 验证session是否存在: 12if request.user.is_authenticated: #▲1.11不加(),2.0可加可不加 需要登录才能浏览 1@login_required(login_url=&apos;/login/&apos;) 增加auth的User字段 123456789101112models.py中from django.contrib.auth.models import Userclass Profile(models.Model): user = models.OneToOneField(User,on_delete=models.CASCADE) height = models.PositiveIntegerField(default=60) male = models.BooleanField(default=False) website = models.URLField(null=True) admin.py中admin.site.register(models.Profile)terminal: python mange.py migrate\\makemigrations 显示增加的User字段 123456789101112@login_required(login_url=&apos;/login/&apos;)def userinfo(request): if request.user.is_authenticated: username = request.user.username try: user = User.objects.get(username = username) userinfo = models.Profile.objects.get(user = user) except: pass template = get_template(&apos;userinfo.html&apos;) html = template.render(locals()) return HttpResponse(html) 点击的方式输入日期: 1234567891011121314151617class DateInput(forms.DateInput): //不是forms.DateField input_type = &apos;date&apos;class DiaryForm(forms.ModelForm): class Meta: model = models.Diary fields = [&apos;budget&apos;,&apos;weight&apos;,&apos;note&apos;,&apos;ddate&apos;] #没有指出user字段...通过ORM取出 widgets = &#123; &apos;ddate&apos;:DateInput(), &#125; def __init__(self,*args,**kwargs): super(DiaryForm,self).__init__(*args,**kwargs) self.fields[&apos;budget&apos;].label = &apos;今日话费(元)&apos; self.fields[&apos;weight&apos;].label = &apos;今日体重(KG)&apos; self.fields[&apos;note&apos;].label = &apos;心情留言&apos; self.fields[&apos;ddate&apos;].label = &apos;日期&apos; 123456789class Diary(models.Model): user = models.ForeignKey(User,on_delete=models.CASCADE) budget = models.FloatField(default=0) weight = models.FloatField(default=0) note = models.TextField() ddate = models.DateField() def __str__(self): return &apos;&#123;&#125;&#123;&#125;&apos;.format(self.ddate,self.user) 123user = User.objects.get(username = username) //DiaryFrom中没有user,通过Django的ORM取出diary= models.Diary(user=user)post_form = forms.DiaryForm(request.POST,instance=diary) //把所有信息合并 建立django-registration所需的模板: 模板或文件名 用途说明 registration_form.html 显示注册窗体的页面,默认使用form变量作为窗体各字段的内容 registration_complete.html 填写完注册窗体,单击’提交’按钮后显示的信息页面 activation_complete.html 当账号顺利完成启用时会显示的页面 activate.html 当账号顺利启用失败时会显示的页面 activation_email.txt 在发送启用邮件时使用的邮件内容 activation_email_subject.txt 在发送启用邮件时使用的邮件主题 Markdown 使用命令 pip install markdown 安装 将 Markdown 格式的文本渲染成 HTML 文本: 12345678910111213blog/views.pyimport markdownfrom django.shortcuts import render, get_object_or_404from .models import Postdef detail(request, pk): post = get_object_or_404(Post, pk=pk) # 记得在顶部引入 markdown 模块 post.body = markdown.markdown(post.body, extensions=[ &apos;markdown.extensions.extra&apos;, &apos;markdown.extensions.codehilite&apos;,#语法高亮拓展 &apos;markdown.extensions.toc&apos;, #自动生成目录 ]) return render(request, &apos;blog/detail.html&apos;, context=&#123;&apos;post&apos;: post&#125;) ​ Django 出于安全方面的考虑，任何的 HTML 代码在 Django 的模板中都会被转义（即显示原始的 HTML 代码，而不是经浏览器渲染后的格式）。为了解除转义，只需在模板标签使用 safe 过滤器即可，告诉 Django，这段文本是安全的，你什么也不用做。 代码高亮 pip install Pygments 安装 Pygments 的工作原理是把代码切分成一个个单词，然后为这些单词添加 css 样式，不同的词应用不同的样式，这样就实现了代码颜色的区分，即高亮了语法。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"https://nymrli.top/tags/后端/"},{"name":"Django","slug":"Django","permalink":"https://nymrli.top/tags/Django/"}]},{"title":"网络宽带和网络延迟","slug":"网络宽带和网络延迟","date":"2018-10-24T08:42:27.000Z","updated":"2019-09-15T08:07:31.092Z","comments":true,"path":"2018/10/24/网络宽带和网络延迟/","link":"","permalink":"https://nymrli.top/2018/10/24/网络宽带和网络延迟/","excerpt":"","text":"网络宽带和网络延迟 网络带宽，网络延迟是2个概念（网络延迟往往更容易被忽略！） 国内大陆 建立在互联网基础上 很多对延迟性要求比较高的应用，体验效果都不如人意。比如高清晰度网络电视、在线视频语音实时业务（qq、skype） 某些在线游戏 等等。 最简单的例子：如果ping某个网站，高于50ms的网站，打开就慢。10-30ms的网站，打开就比较快。 如果都是同一个宽带服务商，即使升级到10M 20M 100M的宽带，这种网络延迟情况，短时间内应该也不会有改善 1、“下载电影这种活儿就看带宽，不在乎服务器发出数据后晚几秒钟收到，传输层有“窗口协议”，不必等到上一段数据的应答再传下一段数据，可以看做是一种“异步应用”。一般说，交互性的应用比较讲究低延迟，我用“同步应用”来描述之。同步应用别说晚几秒钟，就是晚0.1秒收到数据，影响也很大,如 a、比如fps游戏会觉得很不爽，明明瞄准了怎么打不到。 b、至于视频语音等，对带宽、延迟都有一定要求，带宽太小无法传输清晰的图像和声音，延迟太大你一句话“我爱你”，对方的mm没有任何反应…… 另外还有一个指标是抖动，通俗说是数据能不能平稳传输，还是一会儿快一会儿慢一会儿堵塞。” 2、理论上说，带宽越大，在网络拓扑中的优先级就越高，所对应的响应速度就越快，对于用户和ISP之间来说带宽越高，每秒传输的数据越多，延迟就越小。但是延迟高低是由很多个因素决定的，网络上的每一个服务器（路由器）都是一个节点，所有的节点加在一起的响应速度，才是你的网络延迟，如果某一中间节点出现出题，无法提供服务，其它节点就会重新计算路由，但是重新计算路由之前会有一个超时记时器，只有目的节点的响应时间超出记时器时才会重新进行路由计算。还有DNS服务器的影响等等， 所以把网络带宽和网络延迟扯在一起谈是没用的，ISP只能保证你的接入网络带宽和网络延迟无问题，与其它节点的服务就没法保证了。（世界上最远的距离不是天涯和海角，而是电信和网通）” 3、“任何FPS游戏，网络条件是最关键的——到服务器的ping稳定性和延迟时间，对战绩的影响最大。 比如ping服务器5分钟，延迟ms数一直不变，或者误差不超过5%，随便什么FPS，哪怕你从没玩过没有经验不熟悉地图和武器，你的成绩也差不了。 如果这ms数比多数人还少，那你更屌了。 ADSL线路分交织模式interleave和快速模式fast,区别在于交织模式在本地会对数据包进行纠错加密，因此可保证线路的稳定，当然相应的延迟就会上升，电信提供的线路默认也都是交织模式，于是有种减低延迟的方法就是让电信帮你线路改成FAST,当然随之而来的问题是可能导致线路的不稳定，尤其是家里离接入网机房比较远的情况。 延迟这个问题只要是网络都会存在,差别在于大小,标志着整个架构的合理性和完善性。可以简单的认为带宽相当于马路上的车道数量，延迟就相当于堵塞的程度。因此，营运商即使是相同带宽的情况下对延迟不同的线路收费也是不同的。当然一般家庭用户是不会享受这个的。 ADSL ADSL（Asymmetric Digital Subscriber Loop）技术是一种不对称数字用户线实现宽带接入互连网的技术。 实际传输速度也要分上行和下行，上行速率就是发送出去数据的速度(上传速度)，下行就是收到数据的速度(下载速度). 总结 带宽代表一定时间内能运多少货。 延迟代表货物运输时间。 比如万吨轮就是属于大带宽，高延迟。 私人飞机属于低延迟，小带宽。 比如都给一个月的时间，万吨轮拉的东西肯定比私人飞机多,如果土豪做生意，血汗工厂t恤运去去美国，肯定用轮船，对带宽敏感，对延迟不敏感的业务。 但是如果土豪要移植肾了，这玩意路上放久会臭，就属于对延迟比较敏感的应用，还是用私人飞机运比较好。","categories":[],"tags":[{"name":"计算机知识","slug":"计算机知识","permalink":"https://nymrli.top/tags/计算机知识/"}]},{"title":"linux下apt-get介绍","slug":"linux下apt-get介绍","date":"2018-10-24T08:42:20.000Z","updated":"2019-09-15T08:07:30.958Z","comments":true,"path":"2018/10/24/linux下apt-get介绍/","link":"","permalink":"https://nymrli.top/2018/10/24/linux下apt-get介绍/","excerpt":"","text":"apt-get Advanced Package Tool又名apt-get，是一条linux命令，适用于deb包管理式的操作系统如Unix和Linux系统的应用程序管理器，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。 rpm包和deb包是两种Linux系统下最常见的安装包格式，在安装一些软件或服务的时候免不了要和它们打交道。rpm包主要应用在RedHat系列包括 Fedora等发行版的Linux系统上，deb包主要应用于Debian系列包括现在比较流行的Ubuntu等发行版上。 我们知道如果要安装现成的这两种包的话，安装rpm包的命令是“rpm -参数”，安装deb包的命令是“dpkg -参数”。而Linux系统很方便和人性化的一点就是很多软件或服务根本就不用我们去下载，直接使用相应的命令就可以管理了，可能这就是传说中的 “云”的概念。 yum可以用于运作rpm包，例如在Fedora系统上对某个软件的管理： 安装：yum install &lt;package_name&gt; 卸载：yum remove &lt;package_name&gt; 更新：yum update &lt;package_name&gt; apt-get可以用于运作deb包，例如在Ubuntu系统上对某个软件的管理： 安装：apt-get install &lt;package_name&gt; 卸载：apt-get remove &lt;package_name&gt; 更新：apt-get update &lt;package_name&gt; ▲.apt-get命令一般需要root权限执行，所以一般跟着sudo命令。 12345678910111213apt-get update#1、apt-get update是同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。#2、apt-get update只是更新了apt的资源列表，没有真正的对系统执行更新。如果需要，要使用apt-get upgrade来更新。apt-get upgrade#可以使用这条命令更新软件包，apt-get upgrade不仅可以从相同版本号的发布版中更新软件包，也可以从新版本号的发布版中更新软件包，尽管实现后一种更新的推荐命令为apt-get dist-upgrade(将系统升级到新版本)。#总结:▲ apt-get update 是更新本地软件列表，在线安装的时候可以在软件列表找到软件； apt-get upgrade 是更新本地已安装的软件，要谨慎执行。 #dpkg -l#列出所有已安装的软件包。 在Ubuntu中，有时候运用sudo apt-get install 安装软件时，会出现一下的情况 E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 主要是因为apt还在运行,解决方案是 1.找到并且杀掉所有的apt-get 和apt进程 123456ps -A | grep apt找出所有的 apt 以及 apt-get 进程$ sudo kill -9 processnumber 或者$ sudo kill -SIGKILL processnumber比如，下面命令中的9是 SIGKILL 的信号数，它会杀掉第一个 apt 进程$ sudo kill -9 进程ID 或者$ sudo kill -SIGKILL 进程ID 2、删除锁定文件 锁定的文件会阻止 Linux 系统中某些文件或者数据的访问，这个概念也存在于 Windows 或者其他的操作系统中。 一旦你运行了 apt-get 或者 apt 命令，锁定文件将会创建于 /var/lib/apt/lists/、/var/lib/dpkg/、/var/cache/apt/archives/ 中。 这有助于运行中的 apt-get或者 apt 进程能够避免被其它需要使用相同文件的用户或者系统进程所打断。当该进程执行完毕后，锁定文件将会删除。 当你没有看到 apt-get或者 apt 进程的情况下在上面两个不同的文件夹中看到了锁定文件，这是因为进程由于某个原因被杀掉了，因此你需要删除锁定文件来避免该错误。 123456789101112#首先运行下面的命令来移除 /var/lib/dpkg/ 文件夹下的锁定文件：$ sudo rm /var/lib/dpkg/lock#之后像下面这样强制重新配置软件包：$ sudo dpkg --configure -a#也可以删除 /var/lib/apt/lists/ 以及缓存文件夹下的锁定文件：$ sudo rm /var/lib/apt/lists/lock$ sudo rm /var/cache/apt/archives/lock#接下来，更新你的软件包源列表：$ sudo apt update 或者 $ sudo apt-get update","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://nymrli.top/tags/linux/"}]},{"title":"python中关于round函数的注意事项","slug":"python中关于round函数的注意事项","date":"2018-10-18T03:37:00.000Z","updated":"2019-09-15T08:07:30.980Z","comments":true,"path":"2018/10/18/python中关于round函数的注意事项/","link":"","permalink":"https://nymrli.top/2018/10/18/python中关于round函数的注意事项/","excerpt":"","text":"python中关于round函数的注意事项 round函数很简单，对浮点数进行近似取值，保留几位小数。 比如: 12345&gt;&gt;&gt; round(10.0/3, 2)3.33&gt;&gt;&gt; round(20/7)3#第一个参数是一个浮点数，第二个参数是保留的小数位数，可选，如果不写的话默认保留到整数。 12345678910#[round]函数文档-py3def round(number, ndigits=None): # real signature unknown; restored from __doc__ \"\"\" round(number[, ndigits]) -&gt; number Round a number to a given precision in decimal digits (default 0 digits). This returns an int when called with one argument, otherwise the same type as the number. ndigits may be negative. \"\"\" return 0 翻译一下什么意思呢?: 将数字四舍五入到给定精度,如果不给第二个精度参数的话就默认保留到0位(即整数) 这么简单的函数，能有什么坑呢？ 1、round的结果跟python版本有关 1234567#-------python2---------&gt;&gt;&gt; round(0.5)1.0#======python3==========&gt;&gt;&gt; round(0.5)0 原因在于: 在python2.7的doc中，round()的最后写着，“Values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done away from 0.” 保留值将保留到离上一位更近的一端（四舍六入），如果距离两端一样远，则保留到离0远的一边。所以round(0.5)会近似到1，而round(-0.5)会近似到-1。 但是到了python3.5的doc中，文档变成了“values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice.” 如果距离两边一样远，会保留到偶数的一边。比如round(0.5)和round(-0.5)都会保留到0，而round(1.5)会保留到2。 然而需要注意的是 2、特殊数字round出来的结果可能未必是想要的。 12&gt;&gt;&gt; round(2.675, 2)2.67 官方举例:python2和python3的doc 123NoteThe behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more information. 简单的说就是，round(2.675, 2) 的结果，不论我们从python2还是3来看，结果都应该是2.68的，结果它偏偏是2.67，为什么？这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串1和0后可能是无限位数的，机器已经做出了截断处理)。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离2.67要更近一点点，所以保留两位小数时就近似到了2.67。 例子2: 12&gt;&gt;&gt; round(123.45, 1)123.5 意思就是说计算机需要先将十进制123.45转换为二进制,这个过程会导致二进制的值比123.45略大(比如123.45000001之类的),那么自然就得到123.5这个值了. 以上。除非对精确度没什么要求，否则尽量避开用round()函数。近似计算我们还有其他的选择： 使用math模块中的一些函数，比如math.ceiling（天花板除法）。 python自带整除，python2中是/，3中是//，还有div函数。 字符串格式化可以做截断使用，例如 “%.2f” % value（保留两位小数并变成字符串……如果还想用浮点数请披上float()的外衣）。 当然，对浮点数精度要求如果很高的话，请用嘚瑟馍，不对不对，请用decimal模块。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]},{"title":"HDOJ Problem 1002 - A + B Problem II","slug":"HDOJ-Problem-1002-A-B-Problem-II","date":"2018-10-18T03:36:23.000Z","updated":"2019-09-15T08:07:30.941Z","comments":true,"path":"2018/10/18/HDOJ-Problem-1002-A-B-Problem-II/","link":"","permalink":"https://nymrli.top/2018/10/18/HDOJ-Problem-1002-A-B-Problem-II/","excerpt":"","text":"HDOJ Problem 1002 - A + B Problem II: 大数定理 Problem Description I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000. Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line is the an equation “A + B = Sum”, Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases. Sample Input 12321 2112233445566778899 998877665544332211 Sample Output 12345Case 1:1 + 2 = 3Case 2:112233445566778899 + 998877665544332211 = 1111111111111111110 解法一: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;char a[1000],b[1000];int aar[1001],bar[1001];int main()&#123; int alen,blen,maxlen; int time; cin &gt;&gt; time; for (int i=1;i&lt;=time;i++) &#123; cin &gt;&gt; a &gt;&gt; b; alen = strlen(a); blen = strlen(b); int tmp = 0; for (int j=alen-1;j&gt;=0;j--) aar[tmp++] = a[j]-'0'; tmp = 0; for (int j=blen-1;j&gt;=0;j--) bar[tmp++] = b[j]-'0'; //123 ==&gt; 321 为了保证之后便于计算 if ( alen &gt; blen)&#123; maxlen = alen; for(int j=blen;j&lt;alen;j++)&#123; //长度不同时,短的那个需要补零 bar[j] = 0; &#125; aar[alen] = 0; &#125; else if ( alen &lt; blen)&#123; maxlen = blen; for(int j=alen;j&lt;blen;j++) &#123; aar[j] = 0; &#125; bar[blen] = 0; &#125; else&#123; maxlen = alen; aar[maxlen]=0; bar[maxlen]=0; &#125; for (int j=0;j&lt;maxlen;j++)&#123; cout &lt;&lt; aar[j] &lt;&lt; '\\t'; cout &lt;&lt; bar[j] &lt;&lt;endl; aar[j] += bar[j]; if(aar[j] &gt;= 10)&#123;//如果当前位大于10则进一位 aar[j] -=10; aar[j+1] += 1; &#125; &#125;//将a+b的和保存在aar数组里 cout &lt;&lt; \"Case:\" &lt;&lt; i&lt;&lt; endl; cout &lt;&lt; a &lt;&lt; \" + \" &lt;&lt; b &lt;&lt; \" = \" ; if (aar[maxlen] == 0 ) //判断第一位是否为0,如果是的话就从第二位开始读,这个是逆序 for (int j=maxlen-1;j&gt;=0;j--) cout &lt;&lt; aar[j]; else for (int j=maxlen;j&gt;=0;j--) cout &lt;&lt; aar[j]; if(i != time) //注意要求的输出格式 cout &lt;&lt; endl&lt;&lt; endl; else cout &lt;&lt; endl; &#125; return 0;&#125; 解法二: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;using namespace std;int i,j,y,n,k,h,p,lena,lenb;int a[1000],b[1000],sum[1000],f[1000];int main()&#123; string a1,b1; cin&gt;&gt;n; for(y=1;y&lt;=n;y++) &#123; cin&gt;&gt;a1&gt;&gt;b1; lena=a1.length(); lenb=b1.length(); for(i=0;i&lt;1000;i++)&#123; a[i]=0;b[i]=0;f[i]=0;//f数组是记录a+b和 //这个补零是先全都设为0,再把不为0的填入 &#125; for(i=lena-1;i&gt;=0;i--) /*1234 ==&gt; 4321*/ a[lena-1-i]=a1[i]-'0'; //字符'9' - '0' 才是数字9 for(i=lenb-1;i&gt;=0;i--) b[lenb-1-i]=b1[i]-'0'; k=0; for(i=0;i&lt;lenb || i&lt;lena;i++)&#123; //i--&gt; max( lena , lenb ) h=a[i]+b[i]+k; //k是下一位是否进一 f[i]=h%10; //f[i]必然是0-9 k=h/10; //如果h大于10,则k=1,如果h小于10,则k=0 &#125; if(k!=0) //如果k=1,则最高位加一 f[i++]=k; cout&lt;&lt;\"Case \"&lt;&lt;y&lt;&lt;\":\"&lt;&lt;endl&lt;&lt; a1 &lt;&lt;\" + \"&lt;&lt; b1 &lt;&lt;\" = \"; p=0; for(j=i-1;j&gt;=0;j--)&#123; //将之前为了计算时的倒序,再反正过来 if(p==0 &amp;&amp; f[j]==0)&#123; //目的是去前导0,实则这步多余了 continue; //如果最高位是0的话i就不会++,如果是1的话,那么f[j]就不会是0,所以这步必然是进入else &#125; else&#123; p=1; cout&lt;&lt;f[j]; &#125; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; ▲总结: 1.为什么用字符数组==&gt;因为数字太大,long long也存储不下 2.用int数组记录每一位的数字,然后模拟手算 3.为什么倒置==&gt;因为为了让末尾对齐,方便计算&quot;个位对个位,十位对十位……&quot;","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"}]},{"title":"LeetCode 26. 删除排序数组中的重复项","slug":"LeetCode-26-删除排序数组中的重复项","date":"2018-10-18T03:35:36.000Z","updated":"2019-09-15T08:07:30.954Z","comments":true,"path":"2018/10/18/LeetCode-26-删除排序数组中的重复项/","link":"","permalink":"https://nymrli.top/2018/10/18/LeetCode-26-删除排序数组中的重复项/","excerpt":"","text":"LeetCode 26. 删除排序数组中的重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 方法：双指针法 算法 数组完成排序后，我们可以放置两个指针 i和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。 当我们遇到 nums[j] != nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。 1234567891011public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; 复杂度分析 时间复杂度：O(n)， 假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。 空间复杂度：O(1)。 Python实现: 1234567891011121314class Solution: def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) &lt;= 1: return len(nums) s = 0 for f in range(1, len(nums)): if nums[s] != nums[f]: s += 1 nums[s] = nums[f] return s + 1","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"}]},{"title":"素数判别","slug":"素数判别","date":"2018-10-15T14:30:55.000Z","updated":"2019-12-04T13:13:27.198Z","comments":true,"path":"2018/10/15/素数判别/","link":"","permalink":"https://nymrli.top/2018/10/15/素数判别/","excerpt":"","text":"素数判别 由于1既不是素数也不是合数，所以下面暂未判断。如果需要则需特判如if (num == 1) return false; 方法一 123456789bool isPrime_2( int num )&#123; int tmp =sqrt( num); for(int i= 2;i &lt;=tmp; i++) if(num %i== 0) return 0 ; return 1 ;&#125;//一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n)。若sqrt(n)左侧找不到约数，那么右侧也一定找不到约数 方法二(筛选法) 123456789101112131415161718192021222324252627282930#include\"cstdio\"#include\"cstring\"using namespace std;#define MAX 100000//求MAX范围内的素数long long su[MAX],cnt;bool isprime[MAX];void prime()&#123; cnt=1; memset(isprime,1,sizeof(isprime));//初始化认为所有数都为素数 isprime[0]=isprime[1]=0;//0和1不是素数 for(long long i=2;i&lt;=MAX;i++) &#123; if(isprime[i])//保存素数 &#123; su[cnt++]=i; &#125; for(long long j=i*2;j&lt;=MAX;j+=i)//素数的倍数都为合数 &#123; isprime[j]=0; &#125; &#125;&#125;int main()&#123; prime(); for(long long i=1;i&lt;cnt;i++) printf(\"%d \",su[i]); return 0;&#125; 方法三(剪枝) 证明：令x≥1，将大于等于5的自然数表示如下： ······ 6x-1，6x，6x+1，6x+2，6x+3，6x+4 | 6x+5，6(x+1），6(x+1)+1 ······ 可以看到，不在6的倍数两侧，即6x两侧的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。这里有个题外话，关于孪生素数，有兴趣的道友可以再另行了解一下，由于与我们主题无关，暂且跳过。这里要注意的一点是，在6的倍数相邻两侧并不是一定就是质数。===&gt;只需判断6两侧的是不是质数(6x-1、6x+1) 此时判断质数可以6个为单元快进，即将方法（2）循环中i++步长加大为6，加快判断速度，原因是，假如要判定的数为n，则n必定是6x-1或6x+1的形式，对于循环中6i-1，6i，6i+1,6i+2，6i+3，6i+4，其中如果n能被6i，6i+2，6i+4整除，则n至少得是一个偶数，但是6x-1或6x+1的形式明显是一个奇数，故不成立；另外，如果n能被6i+3整除，则n至少能被3整除，但是6x能被3整除，故6x-1或6x+1（即n）不可能被3整除，故不成立。===&gt;综上，循环中只需要考虑6i-1和6i+1的情况(被本身更小的因数所除如22/11)，即循环的步长可以定为6，每次判断循环变量k和k+2的情况即可，理论上讲整体速度应该会是方法（2）的3倍。代码如下： 12345678910111213141516bool isPrime_3( int num )&#123; //两个较小数另外处理 if(num ==2|| num==3 ) return 1 ; //不在6的倍数两侧的一定不是质数 if(num %6!= 1&amp;&amp;num %6!= 5) return 0 ; int tmp =sqrt( num); //在6的倍数两侧的也可能不是质数 for(int i= 5;i &lt;=tmp; i+=6 ) if(num %i== 0||num %(i+ 2)==0 ) return 0 ; //排除所有，剩余的是质数 return 1 ;&#125; for循环i从5开始而不是从7开始的原因: 从5、7开始的区别在于i &lt;= sqrt(num)…如果是5的话，判断条件为25；如果是7的话，判断的条件就为49。 而仔细观察49内的所有质数，发现25之前的质数都是6k左右的数(6k-1,6k+1)，而25以后，就不定都有了。如26则不为质数。 所以如果从5开始的话，那么25以内的数 都不会进入for循环，经过if(num %6!= 1&amp;&amp;num %6!= 5)的筛选后，就都是素数了。 而如果是从7开始，那么25-49之内的数不符合条件却不会进入for循环，所以26缺少这个for的循环判断后就被误判为素数了。 ==&gt;以我浅薄的数学见识理解，25以内素数规律的巧合性使得 这些数不需要进入for循环判断，所以相比于从7开始的错误，5开始是正确的 给出Py代码 12345678910import mathdef prime_num(num): if num == 2 or num == 3: return 1 if num%6 != 1 and num%6!=5: return 0 for i in range(5,math.ceil(math.sqrt(num))+1,6): #就剩6k-1 和 6k+1 if num%i == 0 or num%(i-2)==0: return 0 return 1 参考:https://blog.csdn.net/huang_miao_xin/article/details/51331710","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"}]},{"title":"\\r - \\n - \\r\\n的区别","slug":"回车和换行区别","date":"2018-10-13T12:33:33.000Z","updated":"2019-09-15T08:07:31.041Z","comments":true,"path":"2018/10/13/回车和换行区别/","link":"","permalink":"https://nymrli.top/2018/10/13/回车和换行区别/","excerpt":"","text":"\\r - \\n - \\r\\n 的区别 代码演示: 123456781: string s1 = \"已经习惯了回车和换行一次搞定\\n，敲一个回车键，即是回\";2: 3: Console.WriteLine(s1);4: s1 = \"已经习惯了回车和换行一次搞定\\r，敲一个回车键，即是回\";5: Console.WriteLine(s1);6: s1 = \"已经习惯了回车和换行一次搞定\\r\\n，敲一个回车键，即是回\";7: Console.WriteLine(s1);8: Console.ReadLine(); Result:==&gt; 回车、换行的区别: \\r , \\n, \\r\\n的区别其实是回车与换行的区别 符号 ASCII码 意义 \\n 10 换行 \\r 13 回车CR 先来段历史 回车”（Carriage Return）和“换行”（Line Feed）这两个概念的来历和区别。 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33，Linux/Unix下的tty概念也来自于此）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 在Windows中： ‘\\r’ 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖； ‘\\n’ 换行，换到当前位置的下一行，而不会回到行首； Unix系统里，每行结尾只有“&lt;换行&gt;”，即&quot;\\n&quot;；Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“\\r\\n”；Mac系统里，每行结尾是“&lt;回车&gt;”，即&quot;\\r&quot;；。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 例 $ echo -en '12\\n34\\r56\\n\\r78\\r\\n' &gt; tmp.txt ==&gt;Linux中遇到换行符(&quot;\\n&quot;)会进行回车+换行的操作，回车符反而只会作为控制字符(&quot;^M&quot;)显示，不发生回车的操作。而windows中要回车符+换行符(&quot;\\r\\n&quot;)才会回车+换行，缺少一个控制符或者顺序不对都不能正确的另起一行。 ▲注意点： 在解析文本或其他格式的文件内容时，常常要碰到判定回车换行的地方，这个时候就要注意既要判定&quot;*r*\\n&quot;又要判定&quot;\\n&quot;。 写程序时可能得到一行,将其进行trim掉’*r*’,这样能得到你所需要的string了。 拓展程序测试 123456789101112131415161718192021222324252627282930/*==========================程序二===============================*/#include &lt;stdio.h&gt;int main(void)&#123; int i; FILE *fp; if((fp=fopen(\"test.txt\",\"w\")) == NULL) &#123; fprintf(stderr,\"open file error\\n\"); return 1; &#125; for(i=0;i&lt;100;i++) fprintf(fp,\"test\\n\"); fclose(fp); return 0;&#125;/*==========================程序二===============================*/#include &lt;stdio.h&gt;int main(void)&#123; int i; FILE *fp; if((fp=fopen(\"test.bin\",\"wb\")) == NULL) &#123; fprintf(stderr,\"open file error\\n\"); return 1; &#125; for(i=0;i&lt;100;i++) fprintf(fp,\"test\\n\"); fclose(fp); return 0;&#125; ​ 程序一输出文件大小是600字节，程序二输出文件大小是500字节，用记事本打开程序一的输出没有什么问题，每行一个test，打开程序二的输出发现所有的test连成一行，test之间是一个黑色方框符号分隔。用UltraEdit-32以16进制编辑模式打开test.bin可以查看到黑色方框符号就是0A也就是\\n，打开test.txt则会发现换行是\\r\\n，这就是两个文件大小相差100字节的原因。Unix类系统用户打开windows中的文件就会遇到这种苦恼。 为什么会有这种区别呢？ ​ 毕竟是源自Unix系统，C语言中使用\\n表示换行，而在实际的文件中换行符号需要同操作系统一致，所以当我们在C中使用fopen打开一个文本文件时流实现了实际换行符与C中\\n之间的转换。在windows中当我们用fopen打开文本文件，然后从中读到\\r\\n时流会转换为\\n，而当我们往文件中写入\\n时流会转换为\\r\\n。程序一是打开文本文件，程序二打开的是二进制文件，因为流只对文本文件进行换行表示的转换，以二进制模式打开流不会做任何处理。所以当你以二进制模式打开一个文本文件时将产生错乱，你必须亲自将\\r\\n解释为\\n,同样的问题也会出现在以文本模式打开二进制文件的情况.这也解释了为什么Unix类系统中的文件不区分文本文件和二进制文件的原因。 当我们使用标准输入输出函数时有这种情况吗？ 再回到我们熟悉的标准输入输出stdin,stdout ​ C的控制台程序在加载进内存成为进程运行前C运行时库自动打开三个设备并关联到三个流：标准输入流stdin，标准输出流stdout，标准出错流stderr ​ 通常在通用计算机中，没有重定向前这三个流对应的设备是：键盘，显示器，显示器。这三个都是字符设备，所以是以文本文件的模式打开的，在windows下当我们在键盘上敲入回车键时产生字符\\r\\n，但是在OS内核把键盘驱动中读到的字符发送给流的缓冲区时流会将之转换为\\n，当我们向控制台输出\\n时流将之转换为\\r\\n再传递至内核，当我们绕过标准输入输出直接调用windows中coredll.lib进行控制台输入输出时就必须面对这一现实，程序员负责实现这一转换。 摘自:https://www.cnblogs.com/xiaotiannet/p/3510586.html","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://nymrli.top/tags/计算机基础知识/"}]},{"title":"云服务器Ubuntu更改默认python版本","slug":"云服务器Ubuntu更改默认python版本","date":"2018-10-12T05:07:48.000Z","updated":"2019-09-15T08:07:31.023Z","comments":true,"path":"2018/10/12/云服务器Ubuntu更改默认python版本/","link":"","permalink":"https://nymrli.top/2018/10/12/云服务器Ubuntu更改默认python版本/","excerpt":"","text":"云服务器Ubuntu更改默认python版本 1、基于用户修改 Python 版本： 想要为某个特定用户修改 Python 版本，只需要在其 home 目录下创建一个 alias(别名) 即可。打开该用户的 ~/.bashrc文件，添加新的别名信息来修改默认使用的 Python 版本。 vim ~/.bashrc 增加一行alias python=python3和修改pip版本alias pip=pip3 source ~/.bashrc 再输入python --version,就能发现显示的是Python 3.x啦 2、 在系统级修改 Python 版本(建议) 12# update-alternatives --list pythonupdate-alternatives: error: no alternatives for python 如果出现以上所示的错误信息，则表示 Python 的替代版本尚未被 update-alternatives 命令识别。想解决这个问题，我们需要更新一下替代列表，将 python2.7 和 python3.4 放入其中。 12345$ update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1# update-alternatives: using /usr/bin/python2.7 to provide /usr/bin/python (python) in auto mode$ update-alternatives --install /usr/bin/python python /usr/bin/python3.4 2# update-alternatives: using /usr/bin/python3.4 to provide /usr/bin/python (python) in auto mode –install 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。这个例子中，我们为 /usr/bin/python3.4 设置的优先级为2，所以update-alternatives 命令会自动将它设置为默认 Python 版本。 1234# 接下来，我们再次列出可用的 Python 替代版本。# update-alternatives --list python/usr/bin/python2.7/usr/bin/python3.4","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"nginx+uwsi搭建django环境服务器","slug":"nginx+uwsi搭建django环境服务器","date":"2018-10-12T04:44:09.000Z","updated":"2019-09-18T14:35:07.346Z","comments":true,"path":"2018/10/12/nginx+uwsi搭建django环境服务器/","link":"","permalink":"https://nymrli.top/2018/10/12/nginx+uwsi搭建django环境服务器/","excerpt":"","text":"阿里云搭建服务器 更新源 12sudo apt-get updatesudo apt-get upgrade 安装nginx 1234sudo apt-get install nginxsudo /etc/init.d/nginx start (start可以改成restart/stop)#或是sudo service nginx start然后浏览器输入服务器IP,观察是否有welcom to nginx! 安装py3和virtualenv 12sudo apt-get install git python3 python3-pipsudo pip3 install virtualenv 修改python版本: 法一:(不建议) 123456789$ gedit ~/.bashrc #gedit .bash_aliases在顶部加入一行alias python=python3$ source ~/.bashrc #或是source ~/.bash_aliases o$ python --version就会发现是Python 3.5.2啦/*orOpen your .bashrc file nano ~/.bashrc. Type alias python=python3 on to a new line at the top of the file then save the file with ctrl+o and close the file with ctrl+x. Then, back at your command line type source ~/.bashrc. Now your alias should be permanent.*/ Ubuntu16.04切换python3和python2 ▲.切换Python3为默认版本：(建议) 12sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 切换Python2为默认版本： 1sudo update-alternatives --config python 安装虚拟环境 12$ cd /var/www$ sudo virtualenv env35 下载和配置网站 1234$ sudo git clone https://github.com/KyrieWang233/homework_submission-master.git$ source env35/bin/activate$ cd home...$ sudo pip3 install -r requirements.txt 123456$ sudo python manage.py collectstatic$ sudo python manage.py migrate$ python manage.py createsuperuser$ sudo vim settings.py将其中的ALLOWED_HOST=[*]改为自己的IP然后输入 python manage.py runserver 0.0.0.0:8000 安装、测试uwsgi 12$ sudo pip3 install uwsgi$ uwsgi --http :8000 --module homework_submission.wsgi 编辑/var/www下的uwsgi.ini 12345678910[uwsgi]chdir=/var/www/homework_submission-mastermodule=homework_submission.wsgihome=/var/www/env35master=Trueprocesses=10socket= :8001chmod socket=666vacuum=Truemax-requests=5000 编辑/var/www下的nginx.conf 12345678910111213141516upstream django&#123;server 127.0.0.1:8001;&#125;server &#123;listen 80;server_name sast.nymrli.top;charset utf-8;client_max_body_size 75M;location /static&#123;alias /var/www/homework_submission-master/static; &#125;location /&#123;uwsgi_pass django;include /var/www/uwsgi_params;&#125;&#125; 编辑/var/www下的uwsgi_params 12345678910111213141516uwsgi_param QUERY_STRING $query_string;uwsgi_param REQUEST_METHOD $request_method;uwsgi_param CONTENT_TYPE $content_type;uwsgi_param CONTENT_LENGTH $content_length; uwsgi_param REQUEST_URI $request_uri; uwsgi_param PATH_INFO $document_uri; uwsgi_param DOCUMENT_ROOT $document_root; uwsgi_param SERVER_PROTOCOL $server_protocol; uwsgi_param REQUEST_SCHEME $scheme; uwsgi_param HTTPS $https if_not_empty; uwsgi_param REMOTE_ADDR $remote_addr; uwsgi_param REMOTE_PORT $remote_port; uwsgi_param SERVER_PORT $server_port; uwsgi_param SERVER_NAME $server_name; 软连接 12345cd /etc/nginxcd sites-enabledrm defaultln -s /var/www/nginx.conf homework_submissionls 重启nginx /etc/init.d/nginx restart 运行uwsgi 12cd /var/wwwuwsgi --ini uwsgi.ini 让uwsgi自启动 vim /etc/rc.local(注意非虚拟环境也得安装uwsgi模块) 1234添加下面代码:/usr/local/bin/uwsgi --ini /var/www/uwsgi.iniexit 0 uwsgi的热启动 在uwsgi.ini中加入 py-autoreload=1 重启一下:killall -9 uwsgi、/usr/local/bin/uwsgi --ini /var/www/uwsgi.ini 总结 关于etc/ linit. d 如果你使用过inux系统,那么你一定听说过 init. d目录,这个目录到底是干嘛的呢?它归根结底只做了一件事情,但这件事情非同小可,是为整个系统做的,因此它非常重要。init.d目录包含许多系统各种服务的启动和停止脚本 关于 /etc/rc.local rc.local也是我经常使用的一个脚本,该脚本是在系统初始化级别脚本运行之后再执行的,因此可以安’, '地在里面添加你想在系统启动之后执行的脚本. 总结 Linux是灵活的,正因为它的灵活性,我们总是可以找到许多不同的办法来解决同一个问题，服务的例子就是一个很好的佐证,有了 /etc/init.d目录下的脚本,再加上 /etc/rc. local这个利器，你可以放心的确保你的服务可以完美的启动和运行","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"环境部署","slug":"环境部署","permalink":"https://nymrli.top/tags/环境部署/"},{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"小程序开发遇到的坑","slug":"小程序开发遇到的坑","date":"2018-10-04T12:26:58.000Z","updated":"2019-09-15T08:07:31.050Z","comments":true,"path":"2018/10/04/小程序开发遇到的坑/","link":"","permalink":"https://nymrli.top/2018/10/04/小程序开发遇到的坑/","excerpt":"","text":"小程序开发遇到的坑 function 与 =&gt; 的区别 在JS中，箭头函数并不是简单的function(){}匿名函数的简写语法糖，实际上，箭头函数和匿名函数有个明显的区别：**箭头函数内部的this是词法作用域，在编写函数时就已经确定了。**而匿名函数的this指向运行时实际调用该方法的对象，无法在编写函数时确定。 箭头函数和普通函数的区别 不可以当做构造函数，也就是说，不可以使用 new 命令，否则会抛出错误。 this、arguments、caller等对象在函数体内都不存在。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 ==&gt;箭头函数除了传入的参数之外，其它的对象都没有！在箭头函数引用了this、arguments或者参数之外的变量，那它们一定不是箭头函数本身包含的，而是从父级作用域继承的。 代码实例: 123456789101112function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 setTimeout(function()&#123; console.log(this.num); // undefined &#125;, 500); &#125;;&#125;var obj = new Test();obj.func();//这里的方法里调用了setTimeout函数，该函数500毫秒后调用我们定义的函数时，实际上是window对象调用的，所以这时匿名函数的this是指向window而不是指向obj了。 在箭头函数出现之前一般都是这么写的： 12345678910111213141516171819202122232425function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 var that = this; //保存一份当前的this对象 setTimeout(function()&#123; console.log(that.num); // 100 &#125;, 500); &#125;;&#125;var obj = new Test();obj.func();//这是利用了闭包的概念。箭头函数可以看做这种方式的语法糖。//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 setTimeout(() =&gt; &#123; console.log(this.num); // 100 //箭头函数没有this,所以从上层父级继承 &#125;, 500); &#125;;&#125;var obj = new Test();obj.func(); ▲同时需要注意的是:this是指向当前的对象，随着上下文作用域的切换this的执行this的指向会发生改变，我们可以先保存一份this的值然后再使用：var that = this 生成带参数的二维码 123456789101112131415161718192021222324 onShow:function()&#123; var that = this; function get_code() &#123; wx.request(&#123; url: 'https://api.weixin.qq.com/cgi- bin/token?grant_type=client_credential&amp;appid=' + that.data.APP_ID + '&amp;secret=' + that.data.APP_SECRET, method: 'GET', success: function (res) &#123; // console.log(res.data.access_token); wx.request(&#123; data: &#123; 'path': \"pages/index\" &#125;, url: 'https://api.weixin.qq.com/wxa/getwxacode?access_token=' + res.data.access_token, method: 'POST', success: function (res) &#123; console.log(res.data);//2jin zhi &#125; &#125;) &#125; &#125;) &#125; get_code();&#125;//官方接口得到的是图片的二进制流 通过草料微信小程序生成二维码: 12345678910111213141516171819202122232425262728293031const app = getApp()Page(&#123; data: &#123; APP_ID: 'wx05818046869e4078', APP_SECRET: '5d4429375e84d6ab9476b643f8733af9', path: 'pages/index', photo:null, &#125;, onShow:function()&#123; var that = this; console.log(that.data.APP_ID + ' ' + that.data.APP_SECRET + ' ' + that.data.path) wx.request(&#123; url: 'https://cli.im/home/weapp/create', method:'POST', data:&#123; 'weapp_id': that.data.APP_ID,'weapp_secret': that.data.APP_SECRET,'weapp_url': that.data.path &#125;, header:&#123; 'content- type': 'application/x- www- form- urlencoded' &#125;, success:(res)=&gt;&#123; console.log(res.data.data) that.setData(&#123; photo: res.data.data &#125;) &#125; &#125;) &#125;&#125;) 组件的自定义数据属性: 123&lt;view bindtap=&quot;f0&quot; data- xxx- yyy=&apos;blabla&apos;&gt;&lt;/view&gt;//在点击触发事件f0的参数event中,dataset为自定义参数的字典,其中,键值为驼峰命名法.xxxYyy ▲.bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡 wx.requests是异步调用的 wx.requests这个api是不会阻塞的,什么时候收到response就什么时候调用回调函数(success…),如果在wx.requests方法调用后还有运行代码(1),则(1)比回调函数早执行 组件: 以某种方式对 业务逻辑和* *功能**的封装 特点:高内聚,可复用 视图组件 表单组件 媒体组件 画布组件 基础内容组件 导航组件 地图组件 开放能力组件 自定义组件: ​ 内容略 ES6新特性: js中let和var定义变量的区别 声明后未赋值，表现相同: 如果未在 let 、var 语句中初始化您的变量，则将自动为其分配 JavaScript 值 undefined 使用未声明的变量，表现不同: var有变量提升，let无变量提升 重复声明同一个变量时，表现不同： var重复声明时覆盖，let重复声明时报错 变量作用范围，表现不同： 使用 let 语句声明一个变量，该变量的范围限于声明它的块中。 ==&gt;代码演示: 123456789101112(function() &#123; var varTest = 'test var OK.'; let letTest = 'test let OK.'; &#123; var varTest = 'varTest changed.'; let letTest = 'letTest changed.'; &#125; console.log(varTest); //输出\"varTest changed.\"，内部\"&#123;&#125;\"中声明的varTest变量覆盖外部的letTest声明 console.log(letTest); //输出\"test let OK.\"，内部\"&#123;&#125;\"中声明的letTest和外部的letTest不是同一个变量&#125;());","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"带表头的单链表的基本操作","slug":"带表头的单链表的基本操作","date":"2018-09-27T14:12:17.000Z","updated":"2019-09-15T08:07:31.057Z","comments":true,"path":"2018/09/27/带表头的单链表的基本操作/","link":"","permalink":"https://nymrli.top/2018/09/27/带表头的单链表的基本操作/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct Node&#123; ElemType elem; struct Node *link;&#125;Node;typedef struct &#123; struct Node* head; int n;&#125;Headlist;Status Init(Headlist *L)&#123; L-&gt;head = (Node*)malloc(sizeof(Node)); if(!L-&gt;head) return ERROR; L-&gt;head-&gt;link = NULL; L-&gt;n = 0; return OK;&#125;void Sort(Headlist *L)&#123; Node *p=L-&gt;head,*pre=NULL; Node *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;elem &lt; p-&gt;elem) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125;&#125;void deleleab(Headlist *L, int a,int b)&#123; Node *q = L-&gt;head,*p=L-&gt;head-&gt;link; // q为上一个,p为当前的 while( p ) if(p-&gt;elem &gt;= a &amp;&amp; p-&gt;elem &lt;= b) &#123; q-&gt;link = p-&gt;link; // 1 - 2 - 3 1==&gt;3,1的指针域指向3 free(p); //释放2 p = q-&gt;link; // 当前的指针变成3 &#125;else&#123; p = p-&gt;link; q = p-&gt;link; &#125; &#125;Status Converse(Headlist *L)&#123; Node *p = NULL,*cur= NULL; Node *q = L-&gt;head-&gt;link; if(L-&gt;head &amp;&amp; L-&gt;head-&gt;link)&#123; //如果表不存在或是为空,则return ERROR while( q != NULL ) //q按照原来的顺序依次遍历各结点 &#123; cur = q; //cur为当前结点 q = q-&gt;link; //q保存下一个结点 L-&gt;head-&gt;link = cur; //为了不动头结点,所以头结点link始终指向当前要加的结点 cur-&gt;link = p; //当前的link指向上一个结点 p = cur; //保存上一个结点 &#125; &#125;else return ERROR; return OK;&#125;Status Insert(Headlist *L,int j,ElemType x)&#123; Node *p=NULL,*q=NULL; int i; if(j&lt;-1 || j&gt; L-&gt; n-1) return ERROR; p = L-&gt;head; for(i=0;i&lt;=j;i++) p=p-&gt;link; q = (Node *)malloc(sizeof(Node)); q-&gt;elem = x; q-&gt;link = p-&gt;link; p-&gt;link = q; L-&gt;n++; return OK;&#125;Status Output(Headlist L)&#123; Node *p = L.head-&gt;link; if(!L.n) return ERROR; while(p)&#123; printf(\"%d \",p-&gt;elem ); p = p-&gt;link; &#125; return OK;&#125;Status Destory(Headlist *L)&#123; Node *p=NULL; while(L-&gt;head)&#123; //不断删除head所指向的内存,直到head被释放 p = L-&gt;head-&gt;link; free(L-&gt;head); L-&gt;head = p; &#125; return OK; &#125;Status Delete(Headlist *L,int j)&#123; //下标j Node *p = L-&gt;head,*q = L-&gt;head; // q = tmp int i; if(!L-&gt;n) return ERROR; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j-1;i++) p = p-&gt;link; q = p; p = p-&gt;link; q-&gt;link = p-&gt;link; free(p); return OK;&#125;Status Find(Headlist *L,int j,ElemType *x)&#123; Node *p= L-&gt;head; int i; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j;i++) p = p-&gt;link; *x = p-&gt;elem; return OK;&#125;int main()&#123; int x; Headlist list; Init(&amp;list); Insert(&amp;list,-1,3); Insert(&amp;list,0,2); Insert(&amp;list,-1,5); Insert(&amp;list,2,7); Insert(&amp;list,-1,1); printf(\"the linked list is :\"); Output(list); printf(\"\\nAfter sorted:\"); Sort(&amp;list); Output(list); printf(\"\\nAfter Conversed:\"); Converse(&amp;list); Output(list); printf(\"\\nAfter delete index of 0,the list is:\"); Delete(&amp;list,0); Output(list); Find(&amp;list,2,&amp;x); printf(\"\\nthe index of 2:%d\\n\",x); Destory(&amp;list); system(\"pause\"); return 0;&#125;//无论是什么都要略过head表头结点,表头结点的elem是任意的. (一)实验中遇到的主要问题及解决方法 1.题目二，带表头的单链表在插入时出现了点问题，书上给出的方法是错的，且是C++代码。于是在尝试理解他的想法及每步Debug中终于写出了正确的代码。（L-&gt;head-&gt;link = NULL,其中L-&gt;head-&gt;data 不填） 2.题目二中带表头节点的单链表中插入时for( j=0;j&lt;=i; j++) 和之前j&lt;i以及删除时for( j=0;j&lt;=i-1; j++) 和之前j&lt;i-1有很大不同,通过debug知道了是为了略过第一个表头节点。 3.逆置过程中,为了不动表头,略过第一个表头结点时出现了点麻烦.并且在第一个元素逆置后指向NULL,第二个结点指向第一个结点时没有想明白,后来才想到了先让P=NULL,然后记录上一个结点就能达到效果了.同时还有个问题是一直没有保存原来链表的顺序,再因为P=NULL导致会访问到非法内存而程序崩溃 （二）实验心得 2.题目二中,带表头单链表和不带表头单链表,在删除和插入时的循环条件不同要注意.及初始化时带表头的L-&gt;head-&gt;link= NULL; 与 无表头的 L-&gt;first = NULL;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"带表头的单链表应用——多项式","slug":"带表头的单链表应用——多项式","date":"2018-09-27T14:04:31.000Z","updated":"2019-09-15T08:07:31.054Z","comments":true,"path":"2018/09/27/带表头的单链表应用——多项式/","link":"","permalink":"https://nymrli.top/2018/09/27/带表头的单链表应用——多项式/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct PNode&#123; ElemType ceof; ElemType exp; struct PNode *link;&#125;PNode;typedef struct &#123; struct PNode *head;&#125;polynominal;Status Init(polynominal *p)&#123; p-&gt;head = (PNode *)malloc(sizeof(PNode)); p-&gt;head-&gt;exp = -1; p-&gt;head-&gt;link = NULL; return OK;&#125;Status Create(polynominal *p)&#123; PNode *pn = NULL,*q=NULL,*pre=NULL; Init(p); //p-&gt;head = (PNode *)malloc(sizeof(PNode)); //p-&gt;head-&gt;exp = -1; //p-&gt;head-&gt;link = NULL; for (;;) // &lt;==&gt;while(1) &#123; pn = (PNode *)malloc(sizeof(PNode)); printf(\"ceof:\\n\"); scanf(\"%d\",&amp;pn-&gt;ceof); printf(\"exp:\\n\"); scanf(\"%d\",&amp;pn-&gt;exp); if (pn-&gt;exp &lt; 0) &#123;printf(\"End the input\\n\"); break;&#125; pre = p-&gt;head; //pre从链表头开始 q=p-&gt;head-&gt;link; while(q &amp;&amp; q-&gt;exp &gt; pn-&gt;exp)&#123; //pn为当前结点,q为链表中结点 pre = q; // q = q-&gt;link; &#125; pn-&gt;link = q; // 在pre和q之间插入pn,(q为null时,相当于末尾插入pn) pre-&gt;link = pn; // pre =&gt; pn =&gt; q &#125; return OK;&#125;Status Sort(polynominal *L)&#123; //从大到小 PNode *p=L-&gt;head,*pre=NULL; PNode *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;exp &lt; p-&gt;exp) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125; return OK;&#125;Status Add(polynominal *px,polynominal *qx)&#123; //目的:将q改成p+q PNode *q1=qx-&gt;head, *p=px-&gt;head-&gt;link; //q1指向qx表头结点 PNode *q=q1-&gt;link; //p指向多项式px第一个结点,q指向qx第一个 PNode *temp = NULL; //q1是q前驱 while( q &amp;&amp; p)&#123; while( p-&gt;exp &lt; q-&gt;exp )&#123; //找到qx中 大于等于q指数项的项,q不断右移 q1 = q; q = q-&gt;link; &#125; if (p-&gt;exp == q-&gt;exp )&#123; q-&gt;ceof = q-&gt;ceof + p-&gt;ceof; if (q-&gt;ceof == 0)&#123; q1-&gt;link = q-&gt;link; //释放当前q的内存 free(q); q = q1-&gt;link; p = p-&gt;link; &#125;else&#123; //p\\q都右移 q1 = q; //q1 q = q-&gt;link; p = p-&gt;link; &#125; &#125;else&#123; //p-&gt;exp &gt; q-&gt;exp temp = (PNode * )malloc(sizeof(PNode)); temp-&gt;ceof = p-&gt;ceof; temp-&gt;exp = p-&gt;exp; temp-&gt;link = q1-&gt;link; q1-&gt;link = temp; p = p-&gt;link; &#125; &#125; return OK;&#125;void Output(polynominal *p)&#123; PNode *q = p-&gt;head-&gt;link; int last = 0; while( q!=NULL )&#123; if(q-&gt;link == NULL) last =1; printf(\"%dx^%d\", q-&gt;ceof,q-&gt;exp); if(!last) printf(\"+\"); //此处注意个+的小细节 q = q-&gt;link; &#125; printf(\"\\n\");&#125;void Destory(polynominal *p)&#123; PNode *q = NULL; while(p-&gt;head)&#123; //不断删除head所指向的内存,直到head被释放 q = p-&gt;head-&gt;link; free(p-&gt;head); p-&gt;head = q; &#125;&#125;/***********合并同类项*****************//***********合并即free*****************/Status unify(polynominal *t)&#123; PNode *p=NULL; PNode *q=NULL; PNode *last=NULL; PNode *tmp; //while(p-&gt;link != NULL)&#123; for(p=t-&gt;head-&gt;link;p!=NULL;p=p-&gt;link)&#123; //选择 last = p; for(q=last-&gt;link; q!=NULL ; )&#123; //q指针向后推移指向下一结点 if(q-&gt;exp == p-&gt;exp)&#123; //相等计算 p-&gt;ceof += q-&gt;ceof; //q为 滑动项 tmp = q-&gt;link; last-&gt;link = q-&gt;link; //last保存上一个q free(q); // 吧q的空间释放掉 q= tmp; &#125;else&#123; last= q; q=q-&gt;link;&#125; //如果不相等就判断下一个 &#125; &#125; return OK;&#125;polynominal Multiply(polynominal *px,polynominal *qx)&#123; PNode *p = px-&gt;head; PNode *q = qx-&gt;head; PNode *x = NULL; PNode *tmp = NULL; polynominal newpoly; Init(&amp;newpoly); x = newpoly.head; for (p=px-&gt;head-&gt;link; p!=NULL; p=p-&gt;link)&#123; for (q=qx-&gt;head-&gt;link; q!=NULL; q=q-&gt;link)&#123; tmp = (PNode*)malloc(sizeof(PNode)); tmp-&gt;ceof = p-&gt;ceof * q-&gt;ceof; tmp-&gt;exp = p-&gt;exp + q-&gt;exp; tmp-&gt;link = x-&gt;link; //新生成的结点指向上一个生成的结点的地址 x-&gt;link = tmp; //使链表记录当前tmp结点 x = x-&gt;link; //取下一个结点 &#125; &#125; unify(&amp;newpoly); Sort(&amp;newpoly); return newpoly;&#125;int main()&#123; polynominal p,q; polynominal mul; Create(&amp;p); Output(&amp;p); // printf(\"After unify:\\n\"); Unify // unify(&amp;p); // Output(p); Create(&amp;q); Output(&amp;q); // Add(&amp;p,&amp;q); ADD // printf(\"q:\"); // Output(q); printf(\"After Multiplied:\\n\"); mul = Multiply(&amp;p,&amp;q); Output(&amp;mul); system(\"pause\"); return 0;&#125;//其中Sort,unify,add,multiply,需要捉摸一下 (一)实验中遇到的主要问题及解决方法 1.题目二，带表头的单链表在插入时出现了点问题，书上给出的方法是错的，且是C++代码。于是在尝试理解他的想法及每步Debug中终于写出了正确的代码。（L-&gt;head-&gt;link = NULL,其中L-&gt;head-&gt;data 不填） 2.题目二中带表头节点的单链表中插入时for( j=0;j&lt;=i; j++) 和之前j&lt;i以及删除时for( j=0;j&lt;=i-1; j++) 和之前j&lt;i-1有很大不同,通过debug知道了是为了略过第一个表头节点。 3.逆置过程中,为了不动表头,略过第一个表头结点时出现了点麻烦.并且在第一个元素逆置后指向NULL,第二个结点指向第一个结点时没有想明白,后来才想到了先让P=NULL,然后记录上一个结点就能达到效果了.同时还有个问题是一直没有保存原来链表的顺序,再因为P=NULL导致会访问到非法内存而程序崩溃 4.合并同类项的过程中,使用了选择排序类似的思想,但是在里层for(q=last-&gt;link; q!=NULL ; )出了问题,一开始写成 for(q=last-&gt;link; q!=NULL ; q=q-&gt;link)但是如果指数相等,q就会被free掉,此时q=q-&gt;link就会出问题 （二）实验心得 1.题目一中，顺序表是malloc动态申请的空间，是连续的，可以直接通过下标访问。 2.题目二中,带表头单链表和不带表头单链表,在删除和插入时的循环条件不同要注意.及初始化时带表头的L-&gt;head-&gt;link = NULL; 与 无表头的 L-&gt;first = NULL; 3.Debug过程中F10和F11的区别,在malloc和free处按F11会进入malloc函数、free函数的汇编的运行过程 4.排序和逆置时都要有个指针记住原来链表的顺序,然后才能再依次按顺序进行. 5.理清要做的事,再下手写代码,画图有时很重要.","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"小程序蓝牙","slug":"小程序蓝牙API","date":"2018-09-20T02:57:01.000Z","updated":"2019-09-15T08:07:31.053Z","comments":true,"path":"2018/09/20/小程序蓝牙API/","link":"","permalink":"https://nymrli.top/2018/09/20/小程序蓝牙API/","excerpt":"","text":"提供蓝牙模块API wx.openBluetoothAdapter(OBJECT) ​ 初始化小程序蓝牙模块 wx.closeBluetoothAdapter(OBJECT) ​ 关闭蓝牙模块，使其进入未初始化状态。 wx.getBluetoothAdapterState(OBJECT) ​ 获取本机蓝牙适配器状态 wx.onBluetoothAdapterStateChange(CALLBACK) ​ 监听蓝牙适配器状态变化事件 wx.startBluetoothDevicesDiscovery(OBJECT) ​ 开始搜寻附近的蓝牙外围设备。注意，该操作比较耗费系统资源，请在搜索并连接到设备后调用 stop 方法停止搜索。 wx.stopBluetoothDevicesDiscovery(OBJECT) ​ 停止搜寻附近的蓝牙外围设备。若已经找到需要的蓝牙设备并不需要继续搜索时，建议调用该接口停止蓝牙搜索。 wx.getBluetoothDevices(OBJECT) ​ 获取在小程序蓝牙模块生效期间所有已发现的蓝牙设备，包括已经和本机处于连接状态的设备。 wx.onBluetoothDeviceFound(CALLBACK) ​ 监听寻找到新设备的事件 wx.createBLEConnection(OBJECT) ​ 连接低功耗蓝牙设备。 wx.closeBLEConnection(OBJECT) ​ 断开与低功耗蓝牙设备的连接 wx.getBLEDeviceServices(OBJECT) ​ 获取蓝牙设备所有 service（服务） wx.getBLEDeviceCharacteristics(OBJECT) ​ 获取蓝牙设备某个服务中的所有 characteristic（特征值） wx.readBLECharacteristicValue(OBJECT) ​ 读取低功耗蓝牙设备的特征值的二进制数据值。注意：必须设备的特征值支持read才可以成功调用，具体参照 characteristic 的 properties 属性 wx.writeBLECharacteristicValue(OBJECT) ​ 向低功耗蓝牙设备特征值中写入二进制数据。注意：必须设备的特征值支持write才可以成功调用，具体参照 characteristic 的 properties 属性 tips: 并行调用多次读写接口存在读写失败的可能性* wx.notifyBLECharacteristicValueChange(OBJECT) ​ 启用低功耗蓝牙设备特征值变化时的 notify 功能，订阅特征值。注意：必须设备的特征值支持notify或者indicate才可以成功调用，具体参照 characteristic 的 properties 属性 ​ 另外，必须先启用notify才能监听到设备 characteristicValueChange 事件 wx.onBLEConnectionStateChange(CALLBACK) ​ 监听低功耗蓝牙连接状态的改变事件，包括开发者主动连接或断开连接，设备丢失，连接异常断开等等 wx.onBLECharacteristicValueChange(CALLBACK) ​ 监听低功耗蓝牙设备的特征值变化。必须先启用notify接口才能接收到设备推送的notification。 示例代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// pages/bluetooth/bluetooth.jsPage(&#123; data:&#123;&#125;, onLoad:function(options)&#123; // 页面初始化 options为页面跳转所带来的参数 &#125;, //初始化蓝牙适配器 openBluetooth:function()&#123; wx.openBluetoothAdapter(&#123; success: function(res)&#123; console.log(res.errMsg) // success wx.showToast(&#123; title:\"初始化蓝牙适配器成功\", duration:2000 &#125;) &#125;, &#125;) &#125;,//关闭蓝牙模块closeBluetooth:function()&#123; wx.openBluetoothAdapter() wx.closeBluetoothAdapter(&#123; success: function(res)&#123; // success console.log(\"success\"+res) &#125; &#125;)&#125;,//获取本机蓝牙适配器状态getBluetoothAdapterState:function()&#123;wx.getBluetoothAdapterState(&#123; success: function(res)&#123; // success console.log(\"res:\"+res) console.log(\"errMsg:\"+res.errMsg) &#125;&#125;)&#125;,//监听蓝牙适配器状态变化事件 onBluetoothAdapterStateChange:function()&#123; wx.onBluetoothAdapterStateChange(function(res) &#123; console.log(`adapterState changed, now is`, res) &#125;)&#125;, // 开始搜寻附近的蓝牙外围设备 startBluetoothDevicesDiscovery:function()&#123; wx.startBluetoothDevicesDiscovery(&#123; success: function (res) &#123; console.log(res) &#125; &#125;)&#125;, // 停止搜寻附近的蓝牙外围设备 stopBluetoothDevicesDiscovery:function()&#123; wx.stopBluetoothDevicesDiscovery(&#123; success: function (res) &#123; console.log(res) &#125; &#125;)&#125;, //获取所有已发现的蓝牙设备 getBluetoothDevices:function()&#123; wx.getBluetoothDevices(&#123; success: function(res)&#123; // success console.log(res) &#125;, &#125;) &#125;, //监听寻找到新设备的事件 onBluetoothDeviceFound:function()&#123; wx.onBluetoothDeviceFound(function(res) &#123; // callback console.log(res) &#125;) &#125;, //根据 uuid 获取处于已连接状态的设备 getConnectedBluetoothDevices:function()&#123; wx.getConnectedBluetoothDevices(&#123; success: function (res) &#123; console.log(res) &#125;&#125;)&#125;,//连接低功耗蓝牙设备createBLEConnection:function()&#123; wx.createBLEConnection(&#123; deviceId: 'AC:BC:32:C1:47:80', success: function(res)&#123; // success console.log(res) &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;,//断开与低功耗蓝牙设备的连接closeBLEConnection:function()&#123; wx.closeBLEConnection(&#123; deviceId: 'AC:BC:32:C1:47:80', success: function (res) &#123; console.log(res) &#125;&#125;)&#125;,//监听低功耗蓝牙连接的错误事件，包括设备丢失，连接异常断开等等onBLEConnectionStateChanged:function()&#123; wx.onBLEConnectionStateChanged(function(res) &#123; console.log(`device $&#123;res.deviceId&#125; state has changed, connected: $&#123;res.connected&#125;`)&#125;)&#125;,//获取蓝牙设备所有 service（服务）getBLEDeviceServices:function()&#123; wx.getBLEDeviceServices(&#123; deviceId: '48:3B:38:88:E3:83', success: function(res)&#123; // success console.log('device services:', res.services.serviceId) &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;,//获取蓝牙设备所有 characteristic（特征值）getBLEDeviceCharacteristics:function()&#123; wx.getBLEDeviceCharacteristics(&#123; deviceId: '48:3B:38:88:E3:83', serviceId: 'serviceId', success: function(res)&#123; // success &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;&#125;)","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"电信路由器上网","slug":"电信路由器上网","date":"2018-09-20T02:01:16.000Z","updated":"2019-09-15T08:07:31.086Z","comments":true,"path":"2018/09/20/电信路由器上网/","link":"","permalink":"https://nymrli.top/2018/09/20/电信路由器上网/","excerpt":"","text":"链接: https://pan.baidu.com/s/1QaW7DMhjb2YHd0ZVWterSw 密码：联系QQ1063052964,或是在下方评论处留言QQ","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"小程序入门学习","slug":"小程序入门学习","date":"2018-09-20T01:57:01.000Z","updated":"2019-09-15T08:07:31.049Z","comments":true,"path":"2018/09/20/小程序入门学习/","link":"","permalink":"https://nymrli.top/2018/09/20/小程序入门学习/","excerpt":"","text":"IDE搭建: 下载:微信公众平台官网 预备知识: 个人认为入门小程序相对比较简单,需要了解HTML+CSS 大概知道是干啥的就行,JavaScrip还是要看看的，推荐教程 廖雪峰的博客以及W3Cschool的JS教程 项目目录结构介绍: 小程序中一共有四种类型的文件: js ---------- JavaScrip文件 json -------- 项目配置文件，负责窗口颜色等等 wxml ------- 类似HTML文件 wxss ------- 类似CSS文件 重要文件-APP讲解: app.json(必需) :监听并处理小程序的生命周期函数、声明全局变量。 app.js(建议保存) : *作为配置整个APP的入口,可以什么都不写只输入{}.对整个小程序的全局配置。记录了页面组成(定义了每个页面)，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。* ​ ==&gt;没有最简单的小程序也能运行. app.wxml app.wxss ===&gt; 所以只有app.js和app.json的项目是最简单的小程序 具体页面下的 js文件配置页面入口 wxml配置布局 一起完成对页面的渲染 wxss样式文件 json配置文件 会覆盖app.json和app.wxss全局设置的内容,实现单个网页的个性化 app.js 12345678910111213141516171819202122232425262728293031323334353637Page(&#123; //* 页面的初始数据 data: &#123; &#125;, // * 生命周期函数--监听页面加载 onLoad: function (options) &#123; &#125;, //* 生命周期函数--监听页面初次渲染完成 onReady: function () &#123; &#125;, //* 生命周期函数--监听页面显示 onShow: function () &#123; &#125;, //* 生命周期函数--监听页面隐藏 onHide: function () &#123; &#125;, //* 生命周期函数--监听页面卸载 onUnload: function () &#123; &#125;, //* 页面相关事件处理函数--监听用户下拉动作 onPullDownRefresh: function () &#123; &#125;, //* 页面上拉触底事件的处理函数 onReachBottom: function () &#123; &#125;, //* 用户点击右上角分享 onShareAppMessage: function () &#123; &#125;&#125;) app.json 1234&quot;pages&quot;:[ &quot;pages/index/index&quot; //pages 里面的路径其实是指向js文件的,其中第一个就是登陆首页] 实现路由配置,及全局的某些设置 app.js** 定义了每个页面,每个页面的.js又调用了Page()方法实现该页面的配置信息 小程序事件 事件 == 事件类型+具体事件 具体事件 tap longtap toustart、touchend、touchmove、touchcancel(电话中断) submint、input…… 事件类型 bind 冒泡事件 catch 非冒泡事件 currentTarget 被绑定的组件 dataset 控件相应的属性 target 发生事件的组件 页面跳转 navigateTo({ url :'xxx' }) &lt;navigator url=&quot;../logs/logs?id=1&amp;title='as'&quot; &gt; &lt;/navigator&gt; Flex容器和元素 容器属性 flex-direction : 决定主轴方向 flex-wrap : 处理如何换行 flex-flow : flex-dirction和flex-wrap合并简写 justify-content: 元素在主轴的对齐方式 space-bewteen 两端对齐 center 居中对齐 flex-start 左侧对齐 flex-end 右侧对齐 align-items : 元素在交叉轴的对齐方式 stretch 拉伸,当没设置item高度时,占满整个容器 baseline :以文字为底线对齐 元素属性 flex-grow (默认0): 当有多余空间时,元素的放大比例 flex-shrink(默认1) : 当空间不足时,元素的放大比例 flex-basis: 元素在主轴上占据的空间 flex : flex-grow、flex-shrink、flex-basis的合并简写 order : 定义元素的排列顺序 align-self : 定义元素自身的对齐方式 定位 相对定位: 相对定位的元素是相对自身进行定位,参照物是自己 绝对定位 : 绝对定位的元素是相对离它最近的一个已定位的父级元素进行定位,如果没有,则以整个页面进行定位 margin和padding的区别 margin是指从 自身边框 到 另一个容器边框 之间的距离，就是容器外距离。（外边距） padding是指 自身边框 到 自身内部另一个容器边框 之间的距离，就是容器内距离。（内边距） rpx 动态单位 css布局实例 123456789101112wxml: &lt;view class='list-item' wx:for=\"&#123;&#123;listItem&#125;&#125;\"&gt; &lt;view class='list-item-images'&gt; &lt;image src='../../images/img2.png' class='list-item-images-img' /&gt; &lt;!-- &lt;image class='avatar' src='../../images/avatar.png'/&gt; --&gt; &lt;/view&gt; &lt;view class=\"list-item-text\"&gt; &lt;text&gt;这是一个标题&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415wxss:.list-item&#123; height:500rpx; //整个 图片+文字 一共高为500rpx width: 100%;&#125; .list-item-images&#123; height: 300rpx; // 其中图片的高度为300rpx width: 100%;&#125;.list-item-images image&#123; //图片高、宽全部伸展 height: 100%; width: 100%;&#125;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"Spy++使用介绍","slug":"Spy-使用介绍","date":"2018-09-02T11:39:45.000Z","updated":"2019-09-15T08:07:31.005Z","comments":true,"path":"2018/09/02/Spy-使用介绍/","link":"","permalink":"https://nymrli.top/2018/09/02/Spy-使用介绍/","excerpt":"","text":"Spy++ (SPYXX.EXE) 是一个基于 Win32 的实用工具，它提供系统的进程、线程、窗口和窗口消息的图形视图。使用 Spy++ 可以执行下列操作： 显示系统对象（包括进程、线程和窗口）之间关系的图形树。 搜索指定的窗口、线程、进程或消息。 查看选定的窗口、线程、进程或消息的属性。 我们可以使用微软的Spy++来查看窗口类名等信息，然后再结合pywin32实现。 加载初始界面: 然后点击工具栏的望远镜。如图所示: 出现搜索窗口，然后通过移动靶心到想要查找句柄的窗口后单击就行了。==&gt;它的句柄、标题、类都会显示 再点击确定。 此时会有两种情况。 成功搜索到 搜索不到 原因是你查找的窗口是在打开spy++后打开的，解决的办法就是按F5进行刷新，然后就行了 成功后都会出现如下： 右键，点击“属性”能看到更多详细内容。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"解决安装PyUserInput、pyHook遇到的问题——AttributeError: 'HookManager' object has no attribute 'keyboard_hook","slug":"解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook","date":"2018-09-02T11:33:32.000Z","updated":"2019-09-15T08:07:31.096Z","comments":true,"path":"2018/09/02/解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook/","link":"","permalink":"https://nymrli.top/2018/09/02/解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook/","excerpt":"","text":"安装PyUserInput失败。 经查看发现是pyHook（pyHook是一个用来进行键盘、鼠标等层面事件监控的库。这个库的正常工作需要pythoncom等操作系统的API的支持。）无法安装，不知道是不是因为这个库可以被用于一些比较邪恶的目的。经搜索发现直接pip install pyHook是找不到相关包的，但可以下源码编译安装，可以在 https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyhook 这里可以直接下载到.whl文件，这个文件可以作为pip install 的参数来进行安装。 直接输入pip install pyHook-1.5.1-cp36-cp36m-win_amd64.whl好像还是不行，经提示使用G:\\Py_opencv\\venv\\Scripts\\python.exe -m pip install pyHook-1.5.1-cp36-cp36m-win_amd64.whl第一个参数是python解释器，-m选项可以让python以脚本的方式运行一个模块，pip install后面就是要安装的包名。 pyHook-1.5.1-cp36-cp36m-win_amd64.whl pyHook:库名 1.5.1：版本号 cp3.6m：Cpython3.6版本,编码是ucs2,UCS2认为每个字符占用2个字节，UCS4认为每个字节占用4个字符，都是UNICODE的编码形式。 win_amd64:windows64位环境 whl:压缩包，在其中包含了py文件，以及经过编译的pyd文件。可以使用pip安装 电脑系统环境查看，可以右键“我的电脑”-&gt;“属性”查看 然后再直接在命令行里输入pip install pyuserinput或是在pycharm下载安装都可以了。（需要先安装pywin32） 上述下载的pyHook是基于Python2的,在python3下会报错: TypeError: MouseSwitch() missing 8 required positional arguments: 'msg', 'x', 'y', 'data', 'flags', 'time', 'hwnd', and 'window_name' 或者AttributeError: 'HookManager' object has no attribute 'keyboard_hook' 感谢:python3.5安装pyHook,解决【TypeError: MouseSwitch() missing 8 required positional arguments: ‘msg’, ‘x’, ‘y’, ‘data’, ‘time’, ‘hwnd’, and ‘window_name’】这个错误！、[使用Python 3.5/3.6监听本机任意窗口中的按键操作](使用Python 3.5/3.6监听本机任意窗口中的按键操作)提供的解决方法 需要的模块：扩展库pyhook_py3k（注意，不要使用pyhook），pywin32。 第一步，安装pywin32，地址：http://www.lfd.uci.edu/~gohlke/pythonlibs/#pywin32 第二步，下载pyhook_py3k，地址：https://github.com/Answeror/pyhook_py3k 第三步，下载swig.exe，地址：http://www.swig.org/download.html ==&gt;.zip格式解压 第四步，解压缩pyhook_py3k，并进行编译，命令：python setup.py build_ext --swig=…\\swigwin-3.0.12\\swig.exe，可以根据实际情况修改swig.exe的路径，另外本机最好已安装VC2008 第五步，安装编译好的pyhook_py3k，命令：pip install . 然后就可以正常操作了!!~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"开学小蓝车180天免费卡","slug":"开学小蓝车180天免费卡","date":"2018-09-02T08:44:54.000Z","updated":"2019-09-15T08:07:31.058Z","comments":true,"path":"2018/09/02/开学小蓝车180天免费卡/","link":"","permalink":"https://nymrli.top/2018/09/02/开学小蓝车180天免费卡/","excerpt":"各位看客老爷,可以加下我的公众号哦!虽然没啥东东…微信搜索公众号&quot;我只要瓶果粒橙就好&quot; 原来是180天的,现在好像只有30还是60天了…","text":"各位看客老爷,可以加下我的公众号哦!虽然没啥东东…微信搜索公众号&quot;我只要瓶果粒橙就好&quot; 原来是180天的,现在好像只有30还是60天了…","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"例题4:1-3 古老的密码、刽子手的游戏，救济金发放","slug":"例题4-1-3-古老的密码、刽子手的游戏，救济金发放","date":"2018-09-01T10:46:59.000Z","updated":"2019-09-15T08:07:31.026Z","comments":true,"path":"2018/09/01/例题4-1-3-古老的密码、刽子手的游戏，救济金发放/","link":"","permalink":"https://nymrli.top/2018/09/01/例题4-1-3-古老的密码、刽子手的游戏，救济金发放/","excerpt":"","text":"例题4-1 古老的密码 因为字母可以重排,所以顺序不重要,而又同时因为可以映射,所以字母具体是什么不重要==&gt;只要统计排序后的结果相同就行了 RE(Runtime error)错法加一: 题号提交错误 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;void Bubblesort(int *cnt)//冒泡排序,从大到小顺序&#123; int i,j; int min=cnt[0]; for (i = 0; i &lt;26; ++i) &#123; for ( j = i+1; j &lt; 26; ++j) &#123; if (cnt[i] &lt; cnt[j]) &#123; min = cnt[i]; cnt[i]=cnt[j]; cnt[j] = min; &#125; &#125; &#125;&#125;int main()&#123; char s[2][105]; //存放猜测字符串的 int cnt[2][27]; //存放字母出现次数 int nlen[2]; //字符串的长度 while(scanf(\"%s%s\",s[0],s[1])!= EOF) &#123; memset(cnt,0,sizeof(cnt)); int i; for ( i = 0; i &lt; 2; ++i) &#123; nlen[i]= strlen(s[i]); int j; for ( j = 0; j &lt; nlen[i]; ++j) cnt[i][s[i][j]-'A'] ++; Bubblesort(cnt[i]); &#125; int k; for ( k = 0; k &lt; 26; ++k) &#123; if (cnt[0][k] != cnt[1][k]) &#123; printf(\"NO\\n\"); break; &#125; &#125; if (k==26) printf(\"YES\\n\" ); //如果26个字母出现次数比完全相等,则可以说相同. &#125; return 0;&#125; 例题4-2 刽子手的游戏 注意全局变量是否使用的问题,全局变量尽量少用…但维护内容较多的情况下,可以考虑 采用&quot;自顶向下&quot;的顺序 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 100char ans[maxn],gue[maxn];int left,chance;int win,lose;void guess(char ch)&#123; int bad=1; int i; for ( i = 0; i &lt; strlen(ans); ++i) //判断ch字母是否在字符串中 &#123; if (ans[i]==ch) &#123; ans[i] = ' '; bad =0; left--; //如果在的话,还剩未猜中字母数-1,机会不变 &#125; &#125; if (bad) chance--; //如果不在的话机会-1 if(!chance) lose=1; if(!left) win=1;&#125;int main()&#123; int rnd; while(scanf(\"%d%s%s\",&amp;rnd,ans,gue)==3 &amp;&amp; rnd !=-1) &#123; printf(\"Round %d\\n\",rnd); win = lose =0; left= strlen(ans); chance = 7; int i; int anslen=strlen(gue); for( i=0;i&lt; anslen;i++) &#123; guess(gue[i]); if(win || lose) break;&#125; if(win) printf(\"You win.\\n\"); else if(lose) printf(\"You lose.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;char a[1000],g[1000];//储存字符串 int abook[26],gbook[26];//标记26个字母出现频率 int main()&#123; int k; int alen,glen; int i; int j; int suc,fau; int acount; while(scanf(\"%d\",&amp;k)==1&amp;&amp;k!=-1)&#123; scanf(\"%s%s\",a,g); memset(abook,0,sizeof(abook)); memset(gbook,0,sizeof(gbook)); alen=strlen(a); glen=strlen(g); for(i=0;i&lt;alen;i++)//统计答案字母频率 abook[a[i]-'a']++; acount=0; for(i=0;i&lt;26;i++) if(abook[i])//统计答案的字母组成个数（扣除雷同字母） acount++; suc=0;//猜对次数 fau=0;//猜错次数 for(i=0;i&lt;glen;i++)&#123;//以猜测字母为基准进行扫描 j=g[i]-'a'; if(abook[j]==0)&#123;//答案无此字母，猜测错误 fau++; if(fau==7)//彻底失败 break; &#125;else if(abook[j]!=0)&#123;//猜中字母 suc++; abook[j]=0;//将此字母从答案中剔除出去，此句比较关键!(再猜无效) if(suc==acount)//成功 break; &#125; &#125; printf(\"Round %d\\n\",k); if(fau&gt;=7)//猜错7次及以上 printf(\"You lose.\\n\"); else if(suc==acount)//全部猜对 printf(\"You win.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 例题4-3 救济金发放 圆圈如何轮回==&gt;本质上是要求,大于n变成1,小于1变成n…实现1.越界后归正。2.(xxx)%n, 领过设为1,没领过(初始)设为1 较为简洁、清晰的做法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;string.h&gt;int book[100];//领过的标记1，没领过的标记0 int main()&#123; int n,k,m; int kcount,mcount; int ki,mi; int kout,mout; int first; int ncount; while(scanf(\"%d%d%d\",&amp;n,&amp;k,&amp;m)==3&amp;&amp;n&amp;&amp;k&amp;&amp;m)&#123; memset(book,0,sizeof(book)); ncount=0; ki=0; mi=n+1; first=1; while(ncount!=n)&#123;//n个人全被处理完毕//处理手法有些类似快速排序 kcount=0; mcount=0; //每数一个人,都要判断是不是该越过他.只有0(未领过,才计数) while(kcount!=k)&#123;//k系列处理 ki++; if(ki&gt;n)//ki越界处理 ki=1; if(book[ki]==0)//未被选中计数 ki为当前值 kcount++; &#125; while(mcount!=m)&#123;//m系列处理 mi--; if(mi&lt;1)//mi越界处理 mi=n; if(book[mi]==0)//未被选中计数 mi为当前值 mcount++; &#125; book[ki]=1;//不用担心ki==mi(重复设置为1不影响) book[mi]=1; if(first)&#123;//打印处理 first=0; if(ki!=mi)&#123; printf(\"%3d%3d\",ki,mi); ncount+=2; &#125; else&#123; printf(\"%3d\",ki); ncount++; &#125; &#125;else&#123; if(ki!=mi)&#123; printf(\",%3d%3d\",ki,mi); ncount+=2; &#125; else&#123; printf(\",%3d\",ki); ncount++; &#125; &#125; &#125; printf(\"\\n\"); &#125; return 0;&#125; 书上做法 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 25int n,k,m,a[maxn];int go(int p,int d,int t)&#123; while(t--) //每数一个人都要判断他是否已经领过 do&#123; p = (n+p+d)%n; &#125;while(!a[p]); //==0,领过 return p;&#125;int main()&#123; while(scanf(\"%d,%d,%d\",&amp;n,&amp;k,&amp;m)==3 &amp;&amp; n) &#123; for (int i = 0; i &lt; n; ++i) a[i]=i; int left =n; int p1 =n,p2=1; while(left) &#123; p1= go(p1,-1,k); p2= go(p2,1,m); printf(\"%d\",p1);left--; if(p1!=p2) printf(\" %d\",p2); a[p1]=a[p2]=0; //领了设置为0 if(left) printf(\",\"); //注意输出格式 &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"},{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"WampSever配置本地环境，解决打开打开本地网站问题","slug":"WampSever配置本地环境，解决打开打开本地网站问题","date":"2018-09-01T06:19:39.000Z","updated":"2019-09-15T08:07:31.013Z","comments":true,"path":"2018/09/01/WampSever配置本地环境，解决打开打开本地网站问题/","link":"","permalink":"https://nymrli.top/2018/09/01/WampSever配置本地环境，解决打开打开本地网站问题/","excerpt":"","text":"WampServer是一款由法国人开发的Apache Web服务器、PHP解释器以及MySQL数据库的整合软件包。免去了开发人员将时间花费在繁琐的配置环境过程，从而腾出更多精力去做开发。 直接点击本地的.html是静态加载的，需要动态加载的文件是无法被加载的。会出现如下情况。 于是选用了Wamp搭本地服务器浏览网站，这样就能成功加载动态文件了。 在此分享下配置WampSever时碰到的问题和解决的方法： 服务器是否已正常运行 如果能登上则表示服务器能够正常运行。(在地址栏中输入localhost:端口(或是127.0.0.1:端口) 或是左键图标选择’localhost’) localhost 指你所在的计算机本身。 在windows系统它成了127.0.0.1的别名 ，在Unix系统下，查看网卡配置会发现作为本地回环的方式，一定程度上使用localhost比127.0.0.1要快一些。 在Hosts文件中，localhost指向的IP是127.0.0.1这个关系是可以修改的。 查看、修改端口 配置本地环境、添加项目、打开本地网站 1项目中是空的,需要手动将要打开的网站放到&apos;www&apos;目录中 1可以选择输入路径，也可以直接左键选择&apos;www目录&apos;打开 1将要打开网站的文件夹复制到&apos;www目录下&apos;，会发现刚添加的文件夹出现在了项目中。 勾选’Add localhost in url’ 1看似到此已经大功告成，然而再点击进去这些文件夹时会出现如下情况： 1可以看到的是URL并不对，我们是想要实现通过web服务器的方式访问这些网站，然而这个明显没达到我们想要的效果，根据提示，我找到了原因。 1右键选择&apos;Wamp Settings&apos;中将&apos;Add localhost in url&apos;选项勾上后再次如上打开项目即可。（记得重新打开一次localhost页面或是刷新一下） 1可以看到网站成功地通过web服务器打开了，那些之前提示需要动态加载的文件也成功加载了。 撒花完结！~200成功！ ▲.看到这，我相信你也明白了为什么必须要有’Add localhost in url’这步了。同时也猜到了，其实直接在网址里面输入正确的网址也是可以的，如http://localhost:8080/data-visualize-chain-master/,结果也是能打开的。 希望能对你们有所帮助。","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"WAMP","slug":"WAMP","permalink":"https://nymrli.top/tags/WAMP/"}]},{"title":"Ubuntu下Sublime配置Python环境使用指导:","slug":"Ubuntu下Sublime配置Python环境使用指导","date":"2018-09-01T06:04:47.000Z","updated":"2019-09-15T08:07:31.009Z","comments":true,"path":"2018/09/01/Ubuntu下Sublime配置Python环境使用指导/","link":"","permalink":"https://nymrli.top/2018/09/01/Ubuntu下Sublime配置Python环境使用指导/","excerpt":"","text":"Sublime配置python编译环境及搭建虚拟环境:(windows下大致相同) 1.编译环境配置 2019-3-6更新教程，发现好像 官方网址打不开了，要改一下源才行。 解决办法： 点击 Preferences -&gt; Settings -&gt; Preferences.sublime-Settings—— User(一个新窗口) 添加配置**(在原有大括号{}里面添加**)：&quot;channels&quot;: [&quot;https://raw.githubusercontent.com/HBLong/channel_v3_daily/master/channel_v3.json&quot;], 代码不变，仍然是下面的代码 感谢HBLong提供的解决方案和源: 原有链接 : 解决：Sublime Text3 packagecontrol.io 无法访问的问题 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 1.点击 官方网址 从 Sublime Text 3 官方获取用于安装的代码(即上面的代码)。从菜单栏View --&gt;Show Console或者使用Ctrl+`(esc键下面的按键)，调出sublime的控制台，将官网中的python代码粘贴进去并按Enter执行，最终可以安装完成。在控制台中粘贴刚才的代码，然后点击回车。最后重启ST3。 2.现在你可以通过快捷键 cmd+shift+P 打开 Package Control 来安装其他的插件了。输入 install 然后你就能看见屏幕上出现了 Package Control: Install Package，点击回车,然后搜索sublimeREPL 安装成功后，可以在菜单栏的’TOOL’中找到SublimeREPL，如图所示 2.将菜单栏改为中文 若需要将菜单栏改成中文可如上操作下载插件“ConvertToUTF8”或是安装插件“ChineseLocalizations”(本人使用的是这个，没试ConvertToUTF8的效果) (参考博客:http://blog.51cto.com/11970781/2087971) 3.安装Anaconda插件 1.点击刚刚生成的Package Control -&gt;输入install 2.进入安装界面，安装好后再在新窗口命令行中输入Anaconda并点击第一个备选项进行安装。 安装完成后会显示messages文档。 安装Anaconda插件完成之后，会看到如下选项栏，说明Anaconda安装成功。 - Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数或者类的定义。 - Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 - Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下) Anaconda会自动补全代码，之前用惯了pycharm发现突然没了代码补全后很不习惯，Anaconda的补全功能虽然没有pycharm那么好用，但还是不错的 还有需要注意的是，安装Anaconda插件后，如果python代码没有遵循PEP8规范，会出现白色的框框，或是可以使用快捷键Ctrl+Alt+R进行规范代码(这个可以去除，步骤如下) 在Settings-User选项中添加配置:{“anaconda_linting”:false} 4.安装虚拟环境 1.首先使用终端安装virtualenv，pip3 install virtualenv2.在需要创建的地方进行虚拟环境的搭建，代码如下： 123mkdir pytest(文件夹名)cd pytestvirtualenv venv 在终端进入虚拟环境的话是在pytest文件夹下输入命令source /bin/activate而要在sublime中进入虚拟环境的话就得按照如下操作： １．首先在sublime中安装virtualenv插件，Ctrl + Shift + P，然后输入install,回车，然后搜索virtualenv。 2. 安装完成后，直接按Ctrl + Shift + P，再输入Activate，若没有该选项则virtualenv安装中出现问题，需要重新安装。如果有的会选择Activate就能发现刚刚创建的虚拟环境，选中后回车即可进入虚拟环境 3. 如果Activate选中后没有出现我们刚刚创建的虚拟环境，则需要我们手动添加路径.Ctrl + Shift + P，然后输入Add directory，回车，屏幕下面会出现输入行（Directory path）:再将刚创建的虚拟环境路径填入即可 另外，我曾碰到过Add directory后仍然没用的情况。那时，可选择“”Project”=&gt;&quot;Add folder to project&quot;选择文件后=&gt;“Save Project as”==&gt;保存好即可 工程配置文件为： .sublime-workspace、.sublime-project 其中sublime-project为: 123456789101112131415161718&#123; &quot;build_systems&quot;: [ &#123; &quot;file_regex&quot;: &quot;^[ ]File &quot;(...?)&quot;, line ([0-9]*)&quot;, &quot;name&quot;: &quot;Anaconda Python Builder&quot;, &quot;selector&quot;: &quot;source.python&quot;, &quot;shell_cmd&quot;: &quot;&quot;python&quot; -u &quot;$file&quot;&quot; &#125; ], &quot;folders&quot;: [ &#123; &quot;path&quot;: &quot;爬虫&quot; &#125; ], &quot;virtualenv&quot;: &quot;G:\\pachong\\venv&quot;&#125; 这样环境就配置好了。按Ctrl+B编译时，观察&quot;Tools&quot;-&gt;“Build System”-&gt;是否为&quot;Python+ Virtualenv&quot;，如果不是，则选用这个再Ctrl+B就是在虚拟环境中编译了! ubuntu下sublime默认情况下好像不能输入中文，需要用下面命令就可以完美支持中文输入： 1234sudo apt-get update &amp;&amp; sudo apt-get upgradegit clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix./sublime-imfix 转自CV_YOU的博客 完美解决Sublime无法输入中文问题 截图好像有点问题，菜单栏都没有截到，用到的三个分别为“项目(Project)”，“首选项(Preferences)”，“帮助(Help)”","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"}]},{"title":"python pywin32 PyUserInput实现自动化脚本","slug":"python-win32api-win32gui-win32con-PyUserInput实现自动化脚本","date":"2018-08-31T11:43:00.000Z","updated":"2020-11-07T03:39:42.948Z","comments":true,"path":"2018/08/31/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本/","link":"","permalink":"https://nymrli.top/2018/08/31/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本/","excerpt":"","text":"python pywin32 PyUserInput实现自动化脚本 pywin32用spy++工具查找到句柄，再结合PyUserInput就能很好地实现自动化脚本。 句柄是一个32位整数，在windows中标记对象用，类似一个dict中的key，详情参看这篇文章。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import win32guiimport win32conimport win32api# 从顶层窗口向下搜索主窗口，无法搜索子窗口# FindWindow(lpClassName=None, lpWindowName=None) 窗口类名 窗口标题名handle = win32gui.FindWindow(\"Notepad\", None) # 获取窗口位置left, top, right, bottom = win32gui.GetWindowRect(handle)#获取某个句柄的类名和标题title = win32gui.GetWindowText(handle) clsname = win32gui.GetClassName(handle)# 打印句柄# 十进制print(handle)# 十六进制print(\"%x\" %(handle) )# 搜索子窗口# 枚举子窗口hwndChildList = [] win32gui.EnumChildWindows(handle, lambda hwnd, param: param.append(hwnd), hwndChildList)# FindWindowEx(hwndParent=0, hwndChildAfter=0, lpszClass=None, lpszWindow=None) # 父窗口句柄 若不为0，则按照z-index的顺序从hwndChildAfter向后开始搜索子窗体，否则从第一个子窗体开始搜索。 子窗口类名 子窗口标题subHandle = win32gui.FindWindowEx(handle, 0, \"EDIT\", None)# 获得窗口的菜单句柄menuHandle = win32gui.GetMenu(subHandle)# 获得子菜单或下拉菜单句柄 # 参数：菜单句柄 子菜单索引号subMenuHandle = win32gui.GetSubMenu(menuHandle, 0)# 获得菜单项中的的标志符，注意，分隔符是被编入索引的 # 参数：子菜单句柄 项目索引号 menuItemHandle = win32gui.GetMenuItemID(subMenuHandle, 0)# 发送消息，加入消息队列，无返回 # 参数：句柄 消息类型 WParam IParamwin32gui.postMessage(subHandle, win32con.WM_COMMAND, menuItemHandle, 0)# wParam的定义是32位整型，high word就是他的31至16位，low word是它的15至0位。# 当参数超过两个，wParam和lParam不够用时，可以将wParam就给拆成两个int16来使用。# 这种时候在python里记得用把HIWORD的常数向左移16位，再加LOWORD，即wParam = HIWORD&lt;&lt;16+LOWORD。# 下选框内容更改# 参数：下选框句柄； 消息内容； #参数下选框的哪一个item，以0起始的待选选项的索引；如果该值为-1，将从组合框列表中删除当前选项，并使当前选项为空；# 参数CB_Handle为下选框句柄，PCB_handle下选框父窗口句柄if win32api.SendMessage(CB_handle, win32con.CB_SETCURSEL, 1, 0) == 1:# 下选框的父窗口命令# 参数：父窗口句柄； 命令； # 参数：WParam：高位表示类型，低位表示内容；参数IParam，下选框句柄# CBN_SELENDOK当用户选择了有效的列表项时发送，提示父窗体处理用户的选择。 LOWORD为组合框的ID. HIWORD为CBN_SELENDOK的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x90000, CB_handle) # CBN_SELCHANGE当用户更改了列表项的选择时发送，不论用户是通过鼠标选择或是通过方向键选择都会发送此通知。LOWORD为组合框的ID. HIWORD为CBN_SELCHANGE的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x10000, CB_handle) # 设置文本框内容，等窗口处理完毕后返回true。中文需编码成gbk # 参数：句柄；消息类型；# 参数WParam，无需使用； # 参数IParam，要设置的内容，字符串win32api.SendMessage(handle, win32con.WM_SETTEXT, 0, os.path.abspath(fgFilePath).encode('gbk'))# 控件点击确定,处理消息后返回0# 参数:窗口句柄; 消息类型; 参数WParam HIWORD为0（未使用），LOWORD为控件的ID; 参数IParam 0（未使用）,确定控件的句柄win32api.SendMessage(Mhandle, win32con.WM_COMMAND, 1, confirmBTN_handle)# 获取窗口文本不含截尾空字符的长度# 参数：窗口句柄； 消息类型； 参数WParam； 参数IParambufSize = win32api.SendMessage(subHandle, win32con.WM_GETTEXTLENGTH, 0, 0) +1# 利用api生成BufferstrBuf = win32gui.PyMakeBuffer(bufSize)print(strBuf)# 发送消息获取文本内容# 参数：窗口句柄； 消息类型；文本大小； 存储位置length = win32gui.SendMessage(subHandle, win32con.WM_GETTEXT, bufSize, strBuf)# 反向内容，转为字符串# text = str(strBuf[:-1])address, length = win32gui.PyGetBufferAddressAndLen(strBuf) text = win32gui.PyGetString(address, length) # print('text: ', text)# 鼠标单击事件#鼠标定位到(30,50)win32api.SetCursorPos([30,150])#执行左单键击，若需要双击则延时几毫秒再点击一次即可win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP | win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)#右键单击win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP | win32con.MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0)def click1(x,y): #第一种 win32api.SetCursorPos((x,y)) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,0,0) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,0,0)def click2(x,y): #第二种 ctypes.windll.user32.SetCursorPos(x,y) ctypes.windll.user32.mouse_event(2,0,0,0,0) ctypes.windll.user32.mouse_event(4,0,0,0,0)def click_it(pos): #第三种 handle= win32gui.WindowFromPoint(pos) client_pos =win32gui.ScreenToClient(handle,pos) tmp=win32api.MAKELONG(client_pos[0],client_pos[1]) win32gui.SendMessage(handle, win32con.WM_ACTIVATE,win32con.WA_ACTIVE,0) win32gui.SendMessage(handle, win32con.WM_LBUTTONDOWN,win32con.MK_LBUTTON,tmp) win32gui.SendMessage(handle, win32con.WM_LBUTTONUP,win32con.MK_LBUTTON,tmp)# 发送回车win32api.keybd_event(13,0,0,0)win32api.keybd_event(13,0,win32con.KEYEVENTF_KEYUP,0)# 关闭窗口win32gui.PostMessage(win32lib.findWindow(classname, titlename), win32con.WM_CLOSE, 0, 0)# 检查窗口是否最小化，如果是最大化if(win32gui.IsIconic(hwnd)):# win32gui.ShowWindow(hwnd, win32con.SW_SHOWNORMAL) win32gui.ShowWindow(hwnd, 8) sleep(0.5)# SW_HIDE：隐藏窗口并激活其他窗口。nCmdShow=0。# SW_MAXIMIZE：最大化指定的窗口。nCmdShow=3。# SW_MINIMIZE：最小化指定的窗口并且激活在Z序中的下一个顶层窗口。nCmdShow=6。# SW_RESTORE：激活并显示窗口。如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置。在恢复最小化窗口时，应用程序应该指定这个标志。nCmdShow=9。# SW_SHOW：在窗口原来的位置以原来的尺寸激活和显示窗口。nCmdShow=5。# SW_SHOWDEFAULT：依据在STARTUPINFO结构中指定的SW_FLAG标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递给CreateProcess函数的。nCmdShow=10。# SW_SHOWMAXIMIZED：激活窗口并将其最大化。nCmdShow=3。# SW_SHOWMINIMIZED：激活窗口并将其最小化。nCmdShow=2。# SW_SHOWMINNOACTIVE：窗口最小化，激活窗口仍然维持激活状态。nCmdShow=7。# SW_SHOWNA：以窗口原来的状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=8。# SW_SHOWNOACTIVATE：以窗口最近一次的大小和状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=4。# SW_SHOWNORMAL：激活并显示一个窗口。如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小。应用程序在第一次显示窗口的时候应该指定此标志。nCmdShow=1。 感谢python win32api win32gui win32con 窗口句柄 发送消息 常用方法 键盘输入，代码主要来自于他 ▲.需要注意在windows和mac下接口参数可能有所不同。 win32虽然也可控制键盘，但不如使用PyUserInput的方便。安装PyUserInput教程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pymouse import PyMousefrom pykeyboard import PyKeyboard#实例化m = PyMouse() k = PyKeyboard()x_dim, y_dim = m.screen_size()# 鼠标点击 参数:x,y,button=1(左键)、2(右键)、3(中间),次数m.click(x_dim, y_dim, button=1,n=1) # 键盘输入 参数:str,间隔k.type_string('Hello, World!',interval=0)# 按住一个键k.press_key('H')# 松开一个键k.release_key('H')# 相当于===&gt;按住并松开，tap一个键k.tap_key('e')# tap支持重复的间歇点击键,参数:str,次数,间隔k.tap_key('l',n=2,interval=5) #创建组合键===&gt;press_key和release_key结合使用k.press_key(k.alt_key)k.tap_key(k.tab_key)k.release_key(k.alt_key)# 特殊功能键k.tap_key(k.function_keys[5]) # Tap F5k.tap_key(k.numpad_keys['Home']) # Tap 'Home' on the numpadk.tap_key(k.numpad_keys[5], n=3) # Tap 5 on the numpad, thrice# Mac系统按键k.press_keys(['Command','shift','3'])# Windows系统按键k.press_keys([k.windows_l_key,'d'])其中pymouse的PyMouseEvent和pykeyboard的PyKeyboardEvent还可用于监听鼠标和键盘事件的输入class Clickonacci(PyMouseEvent): def __init__(self): PyMouseEvent.__init__(self) self.fibo = fibo() def click(self, x, y, button, press): '''Print Fibonacci numbers when the left click is pressed.''' if button == 1: if press: print('Press times:%d'.format(press)) else: # Exit if any other mouse button used self.stop()C = Clickonacci()C.run()class TapRecord(PyKeyboardEvent): def __init__(self): PyKeyboardEvent.__init__(self) def tap(self, keycode, character, press): print(time.time(), keycode, character, press)t = TapRecord()t.run()#这些对象是一个架构用于监听鼠标和键盘的输入；他们除了监听之外不会做任何事，需要继承重构他们#PyKeyboardEvent为编写完成，所以这里是一个继承PyMouseEvent的例子： 附录 查找窗体句柄 貌似在win32编程的世界里，包括窗口到文本框的所有控件就是窗体，所有的窗体都有独立的句柄。要操作任意一个窗体，你都需要找到这个窗体的句柄 123456FindWindow(lpClassName=None, lpWindowName=None):自顶层窗口（也就是桌面）开始搜索条件匹配的窗体，并返回这个窗体的句柄。不搜索子窗口、不区分大小写。找不到就返回0参数：lpClassName：字符型，是窗体的类名，这个可以在Spy++里找到。lpWindowName：字符型，是窗口名，也就是标题栏上你能看见的那个标题。说明：这个函数我们仅能用来找主窗口。 12345678FindWindowEx(hwndParent=0, hwndChildAfter=0, lpszClass=None, lpszWindow=None);描述：搜索类名和窗体名匹配的窗体，并返回这个窗体的句柄。不区分大小写，找不到就返回0。参数：hwndParent：若不为0，则搜索句柄为hwndParent窗体的子窗体。hwndChildAfter：若不为0，则按照z-index的顺序从hwndChildAfter向后开始搜索子窗体，否则从第一个子窗体开始搜索。lpClassName：字符型，是窗体的类名，这个可以在Spy++里找到。lpWindowName：字符型，是窗口名，也就是标题栏上你能看见的那个标题。说明：找到了主窗口以后就靠它来定位子窗体啦 另外，python中找回来的句柄都是十进制整型，Spy++里显示的都是十六进制整型，这个要注意下，调试的时候用十六进制输出句柄，如下：print &quot;%x&quot; % (handle) 1234567891011121314151617GetMenu(hwnd) 描述：获取窗口的菜单句柄。 参数： hwnd：整型，需要获取菜单的窗口的句柄。 说明：获取的是插图中黄色的部分。GetSubMenu(hMenu, nPos) 描述：获取菜单的下拉菜单或者子菜单。 参数： hMenu：整型，菜单的句柄，从GetMenu获得。 nPos：整型，下拉菜单或子菜单的的索引，从0算起。 说明：这个可以获取插图中蓝色的部分；如描述所述，这个不仅可以获取本例中的下拉菜单，还可以获取子菜单。GetMenuItemID(hMenu, nPos) 描述：获取菜单中特定项目的标识符。 参数： hMenu：整型，包含所需菜单项的菜单句柄，从GetSubMenu获得。 nPos：整型，菜单项的索引，从0算起。 说明：这个获取的就是红色区域中的项目啦，注意，分隔符是被编入索引的，所以Open的索引是2而非1，而Exit的索引是9而非6。 12345678PostMessage(hWnd, Msg, wParam, lParam) 描述：在消息队列中加入为指定的窗体加入一条消息，并马上返回，不等待线程对消息的处理。 参数： hWnd：整型，接收消息的窗体句柄 Msg：整型，要发送的消息，这些消息都是windows预先定义好的，可以参见系统定义消息（System-Defined Messages） wParam：整型，消息的wParam参数 lParam：整型，消息的lParam参数 说明：简单说，就是给指定程序发一个消息，这些消息都用整型编好号，作为windows的常量可以查询的。在这里，我们用的就是win32con这个库里定义的WM_COMMAND这个消息，具体的wParam和lParam是根据消息的不同而不同的。具体请根据MSDN查阅。 查阅MSDN的消息时，会发现有的wParam定义了low word和high word，这是什么呢？wParam的定义是32位整型，high word就是他的31至16位，low word是它的15至0位，如图。有时，一个消息只需要不超过两个参数，那wParam就可以当一个参数用。万一参数多了，wParam就给拆成了两个int16来使用。这种时候在python里记得用16进制把整形表示出来就比较清爽啦。 用了SendMessage而不是PostMessage，其区别就在于我们可以通过SendMessage取得消息的返回信息。因为对于我们要设置文本框信息的WM_SETTEXT信息来说，设置成功将返回True。 123456789101112131415161718SendMessage(hWnd, Msg, wParam, lParam) 描述：在消息队列中加入为指定的窗体加入一条消息，直到窗体处理完信息才返回。 参数： hWnd：整型，接收消息的窗体句柄 Msg：整型，要发送的消息，这些消息都是windows预先定义好的，可以参见系统定义消息（System-Defined Messages） wParam：整型，消息的wParam参数 lParam：整型，消息的lParam参数 说明：wParam和IParam根据具体的消息不同而有不同的定义，详情参阅Part 2. WM_SETTEXT 消息 描述：设置窗体的文本 参数： wParam：未使用 lParam：一个指针，指向以null结尾的字符串。窗体文本将被设置为该字符串。 返回值： 如果成功设置，则返回1（MSDN原文是返回True） 说明： 上面的定义是直接从MSDN上翻译过来的，在Python的语境里面没有指针，你只需要把变量名作为lParam传入就好了。 另外，请注意编码，包含中文请用gbk编码，否则乱码。 123456WM_COMMAND 消息描述：当用户选择了菜单（或按钮等控件的）命令，或控件发送通知到父窗口，或加速键击（accelerator keystroke is translated）时发送。参数：根据情景不同而不同，在这里属于用户命令，参数配置如下wParam：HIWORD为0（未使用），LOWORD为控件的IDlParam：0（未使用）返回值：如果窗体处理了消息，应返回0 1234567891011121314顺便，如果要获取目标文本框的内容呢，可以使用WM_GETTEXT，如下：WM_GETTEXT消息：描述：将窗体的文本内容复制到指定的buffer对象中参数：wParam：要复制字符的最大长度，包括截尾的空字节lParam：用来保存字符串的buffer的指针返回值：返回复制字符的数量，不包括截尾的空字节利用win32gui.PyMakeBuffer(len, addr)可以造一个buffer对象，类似python3中的bytearray，lParam的返回值。而利用WM_GETTEXTLENGTH可以获取不含截尾空字节的文本长度的长度，可以用来设置Buffer的长度。完整的示例如下：buf_size = win32gui.SendMessage(hwnd, win32con.WM_GETTEXTLENGTH, 0, 0) + 1 # 要加上截尾的字节str_buffer = win32gui.PyMakeBuffer(buf_size) # 生成buffer对象win32api.SendMessage(hwnd, win32con.WM_GETTEXT, buf_size, str_buffer) # 获取bufferstr = str(str_buffer[:-1]) # 转为字符串 1234567891011121314151617181920212223242526272829303132333435363738Part 4：控件操作B——下拉至于另存为图片，情况要稍微复杂一点，因为另存为图片的默认选项是BMP，特别不巧，我使用的FaceGen版本保存为BMP有BUG，不能成功保存，所以我们除了定位保存文件的路径以外，还需要对文件类型的下拉组合框(ComboBox进)行操作：我们假设我们找到了组合框的句柄为CB_handle，我们可以用CB_SETCURSEL消息来更改当前的选项：CB_SETCURSEL 消息描述：参数：wParam：以0起始的待选选项的索引；如果该值为-1，将从组合框列表中删除当前选项，并使当前选项为空lParam：未使用。返回值：更改选择成功将返回所设置选项的索引号。只要给组合框发一个CB_SETCURSEL消息，你就会发现下拉列表的选项已经改变了。这时点保存，你就会发现，这保存的跟之前的一样啊！根本没有变！问题在哪里？我们用鼠标或者键盘操作一下，是没有问题的，一旦更保存类型，保存窗口里的预览也会随之变化。所以，除了CB_SETCURSEL以外，一定还缺了点儿什么。调用Spy++的消息机制查看手动操作，我们的下拉组合框除了渲染和点击，好像没有什么特别值得注意的。那再看看父窗体呢？好像有点儿不太一样的东西：CBN_SELENDOK 通知（notification code）描述：当用户选择了有效的列表项时发送，提示父窗体处理用户的选择。父窗体通过WM_COMMAND消息接收这个通知。参数：（作为WM_COMMAND的参数）wParam：LOWORD为组合框的ID. HIWORD为CBN_SELENDOK的值。lParam：组合框的句柄。CBN_SELCHANGE 通知（notification code）描述：当用户更改了列表项的选择时发送，不论用户是通过鼠标选择或是通过方向键选择都会发送此通知。父窗体通过WM_COMMAND消息接收这个通知。参数：（作为WM_COMMAND的参数）wParam：LOWORD为组合框的ID. HIWORD为CBN_SELCHANGE的值。lParam：组合框的句柄。说明：他们是WM_COMMAND消息wParam的high word（wParam的16-31位，详情参见Part 2）的常数之一，在Python中可以用位移操作将其移动到高位上（a&lt;&lt;16），再用加法加上低位的内容。继续查MSDN的资料，我们发现，对于一个有效的选择，一定会发送这两个通知，发送完CBN_SELENDOK以后马上发送CBN_SELCHANGE。而且，使用CB_SETCURSEL消息时，CBN_SELCHANGE通知是不会被送达的！问题就在这里，加上这两个消息之后，就能正常操作下拉菜单了。 12345if win32api.SendMessage(CB_handle, win32con.CB_SETCURSEL, format_dict[format], 0) == format_dict[format]:win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, win32con.CBN_SELENDOK&lt;&lt;16+0, CB_handle) # 控件的ID是0，所以低位直接加0win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, win32con.CBN_SELCHANGE&lt;&lt;16+0, CB_handle)else:raise Exception(\"Change saving type failed\")","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"Hello 搭建Hexo博客","slug":"hello-hexo","date":"2018-08-30T13:14:27.000Z","updated":"2019-09-15T08:07:30.942Z","comments":true,"path":"2018/08/30/hello-hexo/","link":"","permalink":"https://nymrli.top/2018/08/30/hello-hexo/","excerpt":"","text":"电脑环境是Windows，安装好git后，所有搭建操作均在git bash内完成 1.需要安装git, node.js, npm 注:第一次安装Git会让配置user信息 123&gt; $git config --global user.name &quot;yourname&quot; #（yourname是git的用户名）&gt; $git config --global user.email &quot;youremail&quot;）&gt; 2.使用npm安装hexo： npm install -g hexo 3.创建hexo文件夹，并单击鼠标右键选择 Git bash：(我的创建路径是：E:\\hexo） 4.在刚刚打开的git bash命令框中操作： 1234$hexo init #hexo 会自动创建网站所需要的文件$npm install #安装依赖包$hexo generate # 等价于hexo g$hexo server #现在可以用127.0.0.1:4000访问hexo默认的hello world界面,等价于hexo s 5.部署到github (https://github.com/)， 首先注册登录,然后创建页面仓库，Repository name 命名必须是 youname.github.io ，（youname 就是你注册时候用的name） ssh-keygen -t rsa -C &quot;email&quot; #生成ssh密钥，按三次回车键，密码为空,这边会生成id_rsa和_rsa.pub文件，打开id_rsa.pub，复制全文添加到GitHub 的Add SSH key中。 最后可以验证一下ssh -T git@github.com,看出现的是不是Hi &quot;Yourname&quot;如果出现了你的github用户名,则成功了 6.下载Hexo主题 $git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载hexo的yilia 模板到自己的文件目录下 打开项目目录下的**_config.yml**文件，更改theme：yilia ▲注意: _config.yml文件中配置时:后面都要加空格,与:隔开 7.开启评论功能：使用gitment $npm install gitment --save #安装gitment 然后在 https://github.com/settings/applications/new 进行注册，获取Client ID和Client Secret ▲注意:其中Authorization callback URL是个坑: 这一项不能乱填,不让就不能&quot;初始化评论&quot;… 应该怎么填呢? 如果你绑定了自己的域名就直接写自己的域名: https://nymrli.top/ 如果没有的话才填写http://Freedomisgood.github.io,否则会一直弹回博客首页,而不能&quot;初始化评论&quot;或者&quot;发表评论&quot; 其中的原因就在于,既可以通过www.nymrli.top解析，也可通过nymrli.top解析,还可以通http://Freedomisgood.github.io解析,而Authorization callback URL只能写一个.(最终解析到的网站)…===&gt;就是nymrli.top △.感谢IsResultXaL提供的思路 打开themes/yilia目录下的_config.yml文件进行修改并保存： 再次生成网站,提交网站:hexo d -g就可以输入网址:https://yourname.github.io打开你的博客了 8.显示文章摘要图片 1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在hexo目录下打开git Bsh或者power Shell,npm install hexo-asset-image --save安装插件 再运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 1![你想输入的替代文字](xxxx/图片名.jpg) ▲ .之前一直失败,原因在于,我写图片链接的时候是直接拖动图片到编辑器中的,路径为![v2-代替文字](E:/hexo/source/_posts/xxxx/图片名.jpg),后来一直错误,无法正常显示后，发现只需要写成![代替文字](xxxx/图片名.jpg)即可… 文章总体框架: 12345678910---layout: phototitle: Hello Hexodate: 2018-08-30 21:14:27tags: - hexo---![代替文字](xxxx/图片名.jpg)&lt;!--more--&gt;正文 →推一个不错的文章Hexo+Coding+Github部署个人博客Error全集,如果出现未能解决的问题,希望能从这篇文章略微得到启发.","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"hexo","slug":"hexo","permalink":"https://nymrli.top/tags/hexo/"}]},{"title":"Python字典基本操作介绍","slug":"Python字典基本操作介绍","date":"2018-08-30T13:14:27.000Z","updated":"2019-09-15T08:07:30.986Z","comments":true,"path":"2018/08/30/Python字典基本操作介绍/","link":"","permalink":"https://nymrli.top/2018/08/30/Python字典基本操作介绍/","excerpt":"","text":"创建字典 info={} info=dict() 初始化字典 法一 123key = &apos;name&apos;info = &#123; key :&apos;cold&apos;&#125;==&#123;&apos;name&apos;:&apos;cold&apos;&#125; 法二 12info = dict(key = &apos;cold&apos;)==&#123;&apos;key&apos;:&apos;cold&apos;&#125; 法三 1#还有可以使用dict(zip(a,b))其中a,b都是列表,会生成以A中元素为键,B中元素为值的字典 插入新的键值对(更新) info.update(name=‘cold’, blog=‘www.linuxzen.com’) 在字典有没有k这个键时可以使用dict.setdefault(key,value) 还可以使用dict(var = value)其中var可以是变量,也可以不是,注意不用加 或是_dict[‘xxx’]=‘yyy’ 获得键值 确定存在的情况下- info.get(‘xxx’) info[‘xxx’] 不确定是否存在 info.get(‘xxx’) 遍历字典 获得key,再通过key来获得valuefor key in dicprint(%d,%d%(key,_dict[key])) 使用dict.items()for key,value in dic.items()print ‘key is %s,value is %s’%(key,value) 字典删除 del(info['xxx']) or del info['xxx']","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]}]}