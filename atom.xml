<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>果粒橙的博客</title>
  
  <subtitle>别装作很努力，结局不会陪你演戏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nymrli.top/"/>
  <updated>2019-07-29T03:11:08.008Z</updated>
  <id>https://nymrli.top/</id>
  
  <author>
    <name>果粒橙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>傅里叶变换-&gt;小波变化</title>
    <link href="https://nymrli.top/2019/07/29/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-%E5%B0%8F%E6%B3%A2%E5%8F%98%E5%8C%96/"/>
    <id>https://nymrli.top/2019/07/29/傅里叶变换-小波变化/</id>
    <published>2019-07-29T01:51:32.000Z</published>
    <updated>2019-07-29T03:11:08.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="傅里叶变换-gt-小波变化"><a href="#傅里叶变换-gt-小波变化" class="headerlink" title="傅里叶变换-&gt;小波变化"></a>傅里叶变换-&gt;小波变化</h1><blockquote><p>声明:文中大多数内容来自(<a href="https://www.zhihu.com/people/zhi-yuan-ya-77" target="_blank" rel="noopener">知乎1335</a>)[<a href="https://www.zhihu.com/people/zhi-yuan-ya-77],matlab源代码:[1368069096/From_FT_to_WT_examples-](https://link.zhihu.com/?target=https%3A//github.com/1368069096/From_FT_to_WT_examples-),部分为个人理解阐明" target="_blank" rel="noopener">https://www.zhihu.com/people/zhi-yuan-ya-77],matlab源代码:[1368069096/From_FT_to_WT_examples-](https://link.zhihu.com/?target=https%3A//github.com/1368069096/From_FT_to_WT_examples-),部分为个人理解阐明</a></p></blockquote><p>[TOC]</p><h2 id="傅里叶变换FT"><a href="#傅里叶变换FT" class="headerlink" title="傅里叶变换FT"></a>傅里叶变换FT</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote><p>（FOURIER TRANSFORM，简称FT）</p></blockquote><h3 id="为什么傅里叶变换可以把一个信号从时域变换到频域"><a href="#为什么傅里叶变换可以把一个信号从时域变换到频域" class="headerlink" title="为什么傅里叶变换可以把一个信号从时域变换到频域?"></a>为什么傅里叶变换可以把一个信号从时域变换到频域?</h3><p>先给出公式，傅里叶变换的形式为：$X(w)=\int_{-\infty}^{+\infty} x(t) e^{-j w t} d t$</p><p>PS：傅里叶变换还存在系数，有的文章写的是 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B2%5Cpi%7D" alt="[公式]"> ，有的文章写的是 <img src="https://www.zhihu.com/equation?tex=%5Csqrt%7B%5Cfrac%7B1%7D%7B2%5Cpi%7D%7D" alt="[公式]"> ，两个系数只要满足正变换系数乘上逆变换系数等于 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B2%5Cpi%7D" alt="[公式]"> 即可。这是为了保证经过一次正变换和反变换之后，得到的信号与原信号幅值相同，与我们接下来的讨论关系不大。</p><h3 id="1-理解变换公式"><a href="#1-理解变换公式" class="headerlink" title="1.理解变换公式"></a>1.理解变换公式</h3><p>我们知道，根据欧拉公式，$e^{-j w t}=\cos (w t)-j \sin (w t)$。也就是说，傅里叶变换的本质就是：将原始信号乘上一组<strong>三角函数</strong>（正余弦），之后<strong>在整个时间域上积分</strong>。就这么简单！</p><h4 id="y-sin-3t-图"><a href="#y-sin-3t-图" class="headerlink" title="y=sin(3t)图"></a>y=sin(3t)图</h4><p>我们来看一个信号：y = sin(3t)，如下图：</p><p><img src="https://pic2.zhimg.com/80/v2-0cd28b5014a967f161a3327a44793ba5_hd.jpg" alt="img"></p><p>很好的周期性质，且每个周期的积分值都是0。如果对这个函数在$(-\infty,+\infty)$积分，那就是基本是0，因为 $(-\infty,+\infty)$包含了无数个周期。</p><p>PS：虽然这个积分在高数上不可积，但是你应该明白这里我要表达的意思：<strong>因为良好的周期性，且每个周期积分值是0，那么最后在很长的一段时间区间上积分，得到的还是一个很小的数，近似为0。</strong></p><p>我们来用一段较长的时间区间计算一下，$\int_{0}^{50} \sin (3 t) d t=0.1002$，结果符合我们的预计。</p><h4 id="y-sin-4t-sin-3t-图"><a href="#y-sin-4t-sin-3t-图" class="headerlink" title="y=sin(4t)sin(3t)图"></a>y=sin(4t)sin(3t)图</h4><p>现在，我们来将这个信号乘上一个sin(4t) ，则信号变为y1 = sin(3t)*sin(4t)，如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-5f0c8596fe05899d0cb5a1acaec70cfe_hd.jpg" alt="img"></p><p>具有一个较短的小幅震动的周期和一个较长的主体周期，对吧？且每个主体周期的积分值都是0。同以上讨论，如果对这个函数在 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%2C%2B%5Cinfty%EF%BC%89" alt="[公式]"> 积分，<strong>基本还接近于0</strong>，因为 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%2C%2B%5Cinfty%29" alt="[公式]"> 包含了无数个主体周期。</p><h4 id="y-sin-3-1t-sin-3t-图"><a href="#y-sin-3-1t-sin-3t-图" class="headerlink" title="y=sin(3.1t)sin(3t)图"></a>y=sin(3.1t)sin(3t)图</h4><p>之后呢，我们来将这个信号乘上一个sin(3.1t) ，则信号变为y2 = sin(3t)*sin(3.1t)，如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-5af405c36d2d0ef48ab9f91ac7fb1672_hd.jpg" alt="img"></p><p>同样是有一个较短的小幅震动的周期和一个较长的主体周期，对吧？可以判断，每个主体周期的积分值都是0（虽然（0，50）这个区间没有完整地展示主题周期）。那么，依然同以上讨论，如果对这个函数在 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%2C%2B%5Cinfty%29" alt="[公式]"> 积分，基本还接近于0，因为 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%2C%2B%5Cinfty%29" alt="[公式]"> 包含了无数个主体周期。</p><p>我们来用之前的时间区间计算一下， <img src="https://www.zhihu.com/equation?tex=%5Cint_%7B0%7D%5E%7B50%7D+sin%283t%29%2Asin%283.1t%29+dt+%3D+-4.7731" alt="[公式]"> 。</p><p>咦？这一次怎么距离0这么远了呢？</p><p>原因就是：<strong>对于sin(3t)*sin(4t)，它的主体周期较短</strong>，（0，50）是包含了好几个主体周期的，也就是说（0，50）在某种程度上是类似于 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%EF%BC%8C%2B%5Cinfty%29" alt="[公式]"> 的。但是，<strong>对于sin(3t)*sin(3.1t)，它的主体周期很长</strong>，（0，50）连它的一个完整的主体周期都没有包含，那么（0，50）是不能类似于 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%EF%BC%8C%2B%5Cinfty%29" alt="[公式]"> 的，积分值自然就比较大。</p><p>我们此时可以这样小小总结一下，对于信号y = sin(3t)，它的频率是3rad/s，（如果你喜欢用HZ，那就除以 <img src="https://www.zhihu.com/equation?tex=2%5Cpi+" alt="[公式]"> ，就是 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B3%7D%7B2%5Cpi%7D" alt="[公式]"> HZ，这里使用rad/s，是为了与前面的傅里叶变换的公式中的w一致），而sin(4t)的频率是4rad/s，sin(3.1t)的频率是3.1rad/s。</p><p>如果在 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%EF%BC%8C%2B%5Cinfty%29" alt="[公式]"> 积分，那么y1 = sin(3t)<em>sin(4t)，y2 = sin(3t)</em>sin(3.1t)的积分值都是0，也就是说，sin(4t)和sin(3.1t)在这里是没差别的。</p><p>但是！！！<strong>如果在一个<u>有限区间内</u>积分，由于sin(3.1t)的频率3.1rad/s，距离原信号y = sin(3t)的频率3rad/s更近，那么sin(3.1t)和sin(3t)的乘积，也就是y2 = sin(3t)*sin(3.1t)的积分的绝对值会更大，也就是会离0更远。这里已经显示出一定的频率选择性了。</strong></p><p>最后，让我们请出我们今天的主角，将这个信号乘上一个自己同频率的sin(3t) ，则信号变为y3 = sin(3t)*sin(3t)，如图：</p><p><img src="https://pic2.zhimg.com/80/v2-639fbf1ab8e20ee318da83b21c641da1_hd.jpg" alt="img"></p><p>Amazing！！！发现了什么？良好的周期性？还有呢？<strong>由于乘上了自己，任何时间的幅值都大于等于0了！不再满足周期内积分值为0这个条件了！</strong>那么，此时，我们对这个信号在 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%EF%BC%8C%2B%5Cinfty%29" alt="[公式]"> 积分，就会得到一个非常非常大的数字。<strong>这个很大很大的数字就告诉你，这个信号和你乘的信号是同频率的！这就是可以知道信号中具有哪些频率部分了，不是吗？</strong></p><p>我们还是来用之前的时间区间计算一下， $\int_{0}^{50} \sin (3 t) * \sin (3 t) d t=25.0833$。<strong>是不是比其他的积分值都大了好多？</strong></p><p>好了，我们已经知道，<strong>▲.将一个信号乘上一个特定频率的sin函数，在 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%EF%BC%8C%2B%5Cinfty%29" alt="[公式]"> 上积分，可以将信号中与sin函数同频率的部分筛选出来。那么，原则上讲，只要乘上所有频率的sin函数，并积分，不就知道原始信号中的所有频率部分了吗？</strong></p><p><strong>但是这样做需要把所有频率乘进去，做无数次计算哈！</strong>算不出来的。所以，<strong>我们将所乘的sin函数的频率作为符号变量w，来进行积分，即：</strong></p><p>$X(w)=\int_{-\infty}^{+\infty} x(t) \sin (w t) d t$</p><p>注意：这里的w只是一个符号变量，这样的话，<strong>就只需要做一次积分，可以计算了。</strong></p><p><strong>计算出来X(w)之后，想知道特定的频率w0对应的积分值，直接将w0带入X(w)就立马得到积分值。</strong>，如想知道是否含有w0=3rad/s分量,那么久计算X(3)看结果是否为0，这样就能知道原信号中是否含有这一频率的部分了。</p><p>好了，我们推导的这个式子，是不是与傅里叶变换的式子：</p><p>$X(w)=\int_{-\infty}^{+\infty} x(t) e^{-j w t} d t=\int_{-\infty}^{+\infty} x(t)(\cos (w t)-j \sin (w t)) d t$</p><p>很像了呢？</p><p><strong>这就是傅里叶变换的原理！乘上带有符号变量的sin、cos函数，并积分，就知道原始信号中的所有频率部分啦！</strong></p><h3 id="2、傅里叶变换（FT）的正交性"><a href="#2、傅里叶变换（FT）的正交性" class="headerlink" title="2、傅里叶变换（FT）的正交性"></a><strong>2、傅里叶变换（FT）的正交性</strong></h3><p>傅里叶变换是一种变换。在变换中，我们<strong>将原始信号乘上的变化信号称为基函数</strong>。</p><p>在傅里叶变换中，一系列不同频率的sin、cos等函数称为这个变换的基函数。至于为什么需要既使用sin，又使用cos，这涉及到一点点正交函数的概念。傅里叶变换中的不同频率的<strong>sin、cos等函数是正交函数</strong>，使用正交函数组成的基函数会带给变换一些方便。</p><h4 id="什么是正交性"><a href="#什么是正交性" class="headerlink" title="什么是正交性?"></a>什么是正交性?</h4><h5 id="向量正交"><a href="#向量正交" class="headerlink" title="向量正交:"></a>向量正交:</h5><p>我们都知道，向量 <img src="https://www.zhihu.com/equation?tex=a%2Cb" alt="[公式]"> 的内积为<img src="https://www.zhihu.com/equation?tex=a%5Ccdot+b" alt="[公式]"> 。<strong>正交的定义为内积为0</strong>，即 <img src="https://www.zhihu.com/equation?tex=a%5Ccdot+b+%3D+0" alt="[公式]"> 。如 <img src="https://www.zhihu.com/equation?tex=a+%3D+%281%2C0%29" alt="[公式]"> 表示x轴， <img src="https://www.zhihu.com/equation?tex=b+%3D+%280%2C1%29" alt="[公式]"> 表示y轴，则 <img src="https://www.zhihu.com/equation?tex=a%5Ccdot+b+%3D+0" alt="[公式]"> 即意味着x轴与y轴正交。</p><p>假设有一个向量 <img src="https://www.zhihu.com/equation?tex=v+%3D+%28x_0%2Cy_0%29" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=x_0" alt="[公式]"> 在x轴上定位v，<img src="https://www.zhihu.com/equation?tex=y_0" alt="[公式]"> 在y轴上定位v。<strong>当x轴与y轴正交时，意味着x坐标和y坐标表示的信息是彼此独立的，两坐标可以完全定位v。</strong></p><p>那么，当我们已知向量v，已知x轴a与y轴b，如果知道v的坐标呢？答案就是，<strong>投影/内积</strong>。</p><p>将v向x轴a做投影/内积： <img src="https://www.zhihu.com/equation?tex=x_0+%3D+v%5Ccdot+a" alt="[公式]"> ，可以得到<img src="https://www.zhihu.com/equation?tex=x_0" alt="[公式]">；将v向y轴b做投影/内积： <img src="https://www.zhihu.com/equation?tex=y_0+%3D+v%5Ccdot+b" alt="[公式]">，可以得到<img src="https://www.zhihu.com/equation?tex=y_0" alt="[公式]">。</p><h5 id="正交基"><a href="#正交基" class="headerlink" title="正交基"></a>正交基</h5><p>类似的，函数 <img src="https://www.zhihu.com/equation?tex=+f_1%28x%29%2C+f_2%28x%29" alt="[公式]"> 的内积定义如下： <img src="https://www.zhihu.com/equation?tex=%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7D+f_1%28x%29f_2%28x%29+dx" alt="[公式]">。<strong>函数正交的定义同样为内积为0</strong>，即 <img src="https://www.zhihu.com/equation?tex=%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7D+f_1%28x%29f_2%28x%29+dx+%3D+0" alt="[公式]"> 。PS：对于周期函数，定义中的积分区间为一个周期T。</p><p>我们来看，<img src="https://www.zhihu.com/equation?tex=%5Cint_%7B0%7D%5E%7BT%7D+sin%28w_1x%29cos%28w_2x%29+dx+%3D+0" alt="[公式]"> ，<img src="https://www.zhihu.com/equation?tex=%5Cint_%7B0%7D%5E%7BT%7D+sin%28w_1x%29sin%28w_2x%29+dx+%3D+0%2C+w_1+%5Cne+w_2" alt="[公式]"> ，<img src="https://www.zhihu.com/equation?tex=%5Cint_%7B0%7D%5E%7BT%7D+cos%28w_1x%29cos%28w_2x%29+dx+%3D+0%2C+w_1+%5Cne+w_2" alt="[公式]"> </p><p>▲.因此，傅里叶变换中的不同频率的sin、cos等函数都是正交函数。我们<strong>将cos想象为一个轴，将sin想象为一个轴</strong> ，这两个轴，就张了一个<strong>函数空间</strong>。</p><p>我们已经知道， <img src="https://www.zhihu.com/equation?tex=x%28t%29" alt="[公式]"> 的傅里叶变换为：</p><p>$X(w)=\int_{-\infty}^{+\infty} x(t)(\cos (w t)-j \sin (w t)) d t=\int_{-\infty}^{+\infty} x(t) \cos (w t) d t-j \int_{-\infty}^{+\infty} x(t) \sin (w t) d t$</p><p>我们来看，实部 <img src="https://www.zhihu.com/equation?tex=%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7D+x%28t%29cos%28wt%29dt++" alt="[公式]"> 即相当于将 <img src="https://www.zhihu.com/equation?tex=x%28t%29" alt="[公式]"> 与cos做内积，即向cos轴投影，得到的是在这个<strong>函数空间</strong>内的cos坐标，也就是与cos的相似度；虚部<img src="https://www.zhihu.com/equation?tex=%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7Dx%28t%29sin%28wt%29dt++" alt="[公式]"> 即相当于将 <img src="https://www.zhihu.com/equation?tex=x%28t%29" alt="[公式]"> 与sin做内积，即向sin轴投影，得到的是在这个函数空间内的sin坐标，也就是与sin的相似度。cos坐标和sin坐标都确定后，该信号就确定了。</p><p>因此，傅里叶变换之后，<strong>实部是与cos的相似度，虚部是与sin的相似度</strong>，傅里叶变换也就是与cos的相似度和与sin的相似度的总和，也就表示了相应的频率信息。</p><p>相似度的理解：通过相似度，可以将跟本身频率相似的频率挑选出来</p><p><strong>3、小例子</strong></p><p>最后，我们对于y=sin(3t)做傅里叶变换（这里画图用的matlab的FFT，是FT的离散快速算法，不是积分出来的，但是原理是相同的，仅做展示使用），变换后的图像如下：</p><p><img src="https://pic4.zhimg.com/80/v2-ffb3a17723fa1ef528dfc2350a36bd6f_hd.jpg" alt="img"></p><p>可以看到，与我们的预期相同，变换之后，在 <img src="https://www.zhihu.com/equation?tex=%5Comega+%3D+3+rad%2Fs" alt="[公式]"> 处，出现了峰值，即表示该信号中包含了 <img src="https://www.zhihu.com/equation?tex=%5Comega+%3D+3+rad%2Fs" alt="[公式]"> 的频率成分。</p><h3 id="这里需要说明三点："><a href="#这里需要说明三点：" class="headerlink" title="这里需要说明三点："></a>这里需要说明三点：</h3><p>1、这边的作图结果不是理想FT，如果是理想的FT，即在 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%EF%BC%8C%2B%5Cinfty%29" alt="[公式]"> 上积分，那么除了 <img src="https://www.zhihu.com/equation?tex=%5Comega+%3D+3+rad%2Fs" alt="[公式]"> 的积分值将是 <img src="https://www.zhihu.com/equation?tex=%2B%5Cinfty" alt="[公式]"> 之外，其他任意频率处的值都应该是0，得到的将是一个冲激函数。但是，这里我用的是离散傅里叶变换（详见我的下一篇文章），可以暂时理解为<strong>类似于我们讨论过的有限区间</strong>，当频率靠近3rad/s时（如之前提到的3.1rad/s的例子），也会积分出来一个较大的数值，所以这里不是一个冲击函数，而是一个山峰状的函数；</p><p>2、傅里叶变换之后是具有<strong>实部和虚部的</strong>，实部是与cos的相似度，虚部是与sin的相似度。我们要频率信息的时候，不管是与某一频率w的cos的相似还是与某一频率w的sin的相似，都是这一频率w嘛，不需要区分。因此，这里画图取了模，就不存在实部和虚部了。</p><p>3、在<img src="https://www.zhihu.com/equation?tex=%5Comega+%3D+3+rad%2Fs" alt="[公式]">处之所以没有出现我们讨论的很大很大很大的值，是因为画图之前对于变换之后的幅值统一除以了信号取样点的个数，统一压缩了一定的倍数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.由于sin和cos是一对正交基，所以所有的信号都可以分解成正弦信号与余弦信号的线性叠加。</p><p>2.除了与乘以本身频率w的正余弦相同信号再在$(-\infty,+\infty)$范围上积分的结果会是非0以外，乘以其他频率信号的结果都是0.通过这个特性可以将是否含有w频率信号鉴别出</p><p>2.傅里叶变化的基函数$e^{jwt}$由欧拉公式可分解为$e^{-j w t}=\cos (w t)-j \sin (w t)$,所以根据公式:$X(w)=\int_{-\infty}^{+\infty} x(t) \cos (w t) d t-j \int_{-\infty}^{+\infty} x(t) \sin (w t) d t$，前部分乘以cos(wt)能挑出cos成分中的信号频率，后部分乘以的sin(wt)能挑出sin成分中的信号频率。再将挑出的各信号频率线性叠加的结果就是分解信号总的含有各谐波分量的频率</p><hr><h2 id="傅里叶变换（FT）的缺点与短时傅里叶变换（STFT）"><a href="#傅里叶变换（FT）的缺点与短时傅里叶变换（STFT）" class="headerlink" title="傅里叶变换（FT）的缺点与短时傅里叶变换（STFT）"></a>傅里叶变换（FT）的缺点与短时傅里叶变换（STFT）</h2><h3 id="离散傅里叶变换（DFT）"><a href="#离散傅里叶变换（DFT）" class="headerlink" title="离散傅里叶变换（DFT）"></a>离散傅里叶变换（DFT）</h3><p>在本文正式开始之前，我们需要明确一下实际信号进行的FT的一些特殊之处。实际采集的信号往往是这样的：</p><p><img src="https://pic4.zhimg.com/80/v2-fb5df4498e5bd43450ec0476c56129f3_hd.jpg" alt="img"></p><p>实际的信号往往具有两个特点：</p><p>1、<strong>离散性</strong>，就是采集数据不连续，很容易理解，采集信号肯定是一个一个数据采集的；</p><p>2、<strong>有限性</strong>，虽然理想的傅里叶变换是从 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%2C%2B%5Cinfty%29" alt="[公式]"> 进行积分，但是实际信号往往实在一个区间内(a,b)的。</p><p>所以，我们要用到离散傅里叶变换（DISCRETE FOURIER TRANSFORM，简称DFT），DFT与FT相比，就是多了两个特征：<strong>1、离散型，2、有限性</strong>。</p><p>我们来一起试一试如何推导DFT公式。首先设采集了N个信号点，其时刻为 <img src="https://www.zhihu.com/equation?tex=t_0%2Ct_1%2C...t_%7BN-1%7D" alt="[公式]">，对应时刻采集到的信号值为 <img src="https://www.zhihu.com/equation?tex=x%28t_0%29%2Cx%28t_1%29%2C...x%28t_%7BN-1%7D%29" alt="[公式]"> 。很自然的，原来信号连续，是积分，现在数据离散了，那就是把积分变成累加。于是我们得到： $X(w)=\sum_{i=0}^{N-1} x\left(t_{i}\right) e^{-j w t_{i}}$</p><p>这么一来，我们发现，原信号有N个数据点，DFT变换后的信号却变成连续的了，我们将之称为<strong>离散时间傅里叶变换（</strong>DISCRETE TIME FOURIER TRANSFORM，简称<strong>DTFT）</strong>。</p><p>DTFT有两个缺点，第一， <img src="https://www.zhihu.com/equation?tex=w+%5Cin+%28-%5Cinfty%2C%2B%5Cinfty%29" alt="[公式]"> 且连续，需要进行无数次计算，计算机无法计算；第二，在进行计算的时候，我们需要已知： <img src="https://www.zhihu.com/equation?tex=t_0%2Ct_1%2C...t_%7BN-1%7D" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=x%28t_0%29%2Cx%28t_1%29%2C...x%28t_%7BN-1%7D%29" alt="[公式]"> ，但是调用过FFT函数的同学都知道，FFT只需要已知<img src="https://www.zhihu.com/equation?tex=x%28t_0%29%2Cx%28t_1%29%2C...x%28t_%7BN-1%7D%29" alt="[公式]">就可以进行。</p><p>这是怎么回事呢？</p><p>首先，我们<strong>使用相对采样时间 <img src="https://www.zhihu.com/equation?tex=n+%3D+0%2C1%2C...N-1" alt="[公式]"> 代替真实采样时间 <img src="https://www.zhihu.com/equation?tex=t_0%2Ct_1%2C...t_%7BN-1%7D" alt="[公式]"> ，</strong>可以得到： <img src="https://www.zhihu.com/equation?tex=X%28w%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-jwn%7D" alt="[公式]"> 。</p><p>此时我们发现， <img src="https://www.zhihu.com/equation?tex=X%28w%29" alt="[公式]"> 变成了以 <img src="https://www.zhihu.com/equation?tex=2%5Cpi" alt="[公式]"> 为周期的函数，即 <img src="https://www.zhihu.com/equation?tex=X%28w%2B2%5Cpi%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-j%28w%2B2%5Cpi%29n%7D+%3D++%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-jwn%7De%5E%7B-j2%5Cpi+n%7D+%3D++%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-jwn%7D+%3D+X%28w%29" alt="[公式]"></p><p>那么，我们只需要计算 <img src="https://www.zhihu.com/equation?tex=w+%5Cin+%280%2C2%5Cpi%29" alt="[公式]"> 区间的 <img src="https://www.zhihu.com/equation?tex=X%28w%29" alt="[公式]"> ，就可以得到 <img src="https://www.zhihu.com/equation?tex=+w+%5Cin%28-%5Cinfty%2C%2B%5Cinfty%29" alt="[公式]"> 区间的<img src="https://www.zhihu.com/equation?tex=X%28w%29" alt="[公式]">了。也就是说，通过使用相对采样时间 <img src="https://www.zhihu.com/equation?tex=n+%3D+0%2C1%2C...N-1" alt="[公式]"> 代替真实采样时间 <img src="https://www.zhihu.com/equation?tex=t_0%2Ct_1%2C...t_%7BN-1%7D" alt="[公式]">，我们将 <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> 的范围从 <img src="https://www.zhihu.com/equation?tex=+%28-%5Cinfty%2C%2B%5Cinfty%29" alt="[公式]"> 缩小到了 <img src="https://www.zhihu.com/equation?tex=%280%2C2%5Cpi%29" alt="[公式]"> 。</p><p>自然地，我们希望将<img src="https://www.zhihu.com/equation?tex=%280%2C2%5Cpi%29" alt="[公式]"> 离散化称为N个点，这样计算机就可以计算了！则取$w=\frac{2 \pi k}{N}, k=0,1, \ldots N-1$，则有： $X(k)=\sum_{n=0}^{N-1} x(n) e^{-j \frac{2 \pi k}{N} n}, k=0,1 \ldots N-1$</p><p>好了，这就是<strong>离散傅里叶变换DFT</strong>了！</p><p>接下来，来看DFT的两个性质：</p><ul><li><p>第一， <img src="https://www.zhihu.com/equation?tex=X%280%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29" alt="[公式]"> ，即 <img src="https://www.zhihu.com/equation?tex=X%280%29" alt="[公式]"> 是所有元素的和，通常会比其他的元素大几个数量级。</p></li><li><p>第二， <img src="https://www.zhihu.com/equation?tex=X%281%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-j+2%5Cpi%5Cfrac%7B1%7D%7BN%7D+n%7D" alt="[公式]"> ，<img src="https://www.zhihu.com/equation?tex=X%28N-1%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-j+2%5Cpi%5Cfrac%7BN-1%7D%7BN%7D+n%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=X%281%29+%3D+%5Ctilde%7BX%28N-1%29%7D" alt="[公式]"> ，即第二个元素和最后一个元素共轭，同理有<img src="https://www.zhihu.com/equation?tex=X%282%29+%3D+%5Ctilde%7BX%28N-2%29%7D" alt="[公式]"> 等等。</p></li></ul><p>如下图所示，DFT之后的 <img src="https://www.zhihu.com/equation?tex=N" alt="[公式]"> 个元素中，第一个为均值；之后的 <img src="https://www.zhihu.com/equation?tex=N-1" alt="[公式]"> 个元素，只有一半元素是独立的。</p><p><img src="https://pic3.zhimg.com/80/v2-7779743b0ad81ce875fe42c0f69adbc2_hd.jpg" alt="img"></p><p>需要说明，这里 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 是一种相对频率，独立元素中，最小相对频域为1，最大相对频率为 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> 。<strong>要想把</strong> <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> <strong>还原到真实的频率</strong> <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> <strong>，只需要 <img src="https://www.zhihu.com/equation?tex=w+%3D+%5Cfrac%7Bk-1%7D%7BN%7DFs" alt="[公式]"> ，将</strong> <img src="https://www.zhihu.com/equation?tex=k%3D1%2C2...%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> <strong>映射到</strong> <img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29" alt="[公式]"> <strong>即可</strong>， <img src="https://www.zhihu.com/equation?tex=Fs" alt="[公式]"> <strong>为采样频率。</strong></p><p>PS：简单说一下，根据香农采样定理，当采样频率为 <img src="https://www.zhihu.com/equation?tex=Fs" alt="[公式]"> 时，能采到的最大信号频率为<img src="https://www.zhihu.com/equation?tex=%5Cfrac%7BFs%7D%7B2%7D" alt="[公式]">。因此，将相对频率 <img src="https://www.zhihu.com/equation?tex=k%3D1%2C2...%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> 通过公式 <img src="https://www.zhihu.com/equation?tex=w+%3D+%5Cfrac%7Bk-1%7D%7BN%7DFs" alt="[公式]"> ，得到的 <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> 就在区间<img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29" alt="[公式]">内，也就是真实频率的区间了。</p><p>所以DFT公式为： <img src="https://www.zhihu.com/equation?tex=X%28k%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-j%5Cfrac%7B2%5Cpi+k%7D%7BN%7Dn%7D%2C+k+%3D+0%2C1...N-1" alt="[公式]"></p><p>PS：DFT公式的形式很多，有的是从时域到频域，有的是从空间域到频域，但是本质都是一样的，抓住<strong>离散性</strong>和<strong>有限性</strong>两个特点即可。<strong>离散性是指积分变成了累加，有限性是指积分/累加区间不是 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%2C%2B%5Cinfty%29" alt="[公式]"> 了，而是一个有限区间了。</strong></p><h3 id="傅里叶变换（FT）的缺点"><a href="#傅里叶变换（FT）的缺点" class="headerlink" title="傅里叶变换（FT）的缺点"></a><strong>傅里叶变换（FT）的缺点</strong></h3><p>应该说明，虽然本小节的题目是FT的缺点，但是FT和DFT的本质是相同的。由于信号都是有限长度的、离散的，所以接下来进行的都是DFT，不过在某些部分为了方便理解，还是写了FT的公式。在看本文的时候，你不需要刻意区分这两个概念。</p><p>我们现在来看两个信号，如下图： <img src="https://www.zhihu.com/equation?tex=y1%3Dsin%285t%29%2A%280%3Ct%3C25%29%2Bsin%28t%29%2A%2825%3Ct%3C50%29" alt="[公式]"> ，<img src="https://www.zhihu.com/equation?tex=y2%3Dsin%28t%29%2A%280%3Ct%3C25%29%2Bsin%285t%29%2A%2825%3Ct%3C50%29" alt="[公式]"> 。</p><p><img src="https://pic3.zhimg.com/80/v2-023a9ca6d0985e9dc271a08a199269de_hd.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-4ea09915e3f6f18391df410eab709da4_hd.jpg" alt="img"></p><p>这两个信号都是由sin(t)和sin(5t)组成的，y1是先出现了sin(5t)，再出现了sin(t)，y2是先出现了sin(t)，再出现了sin(5t)。</p><p>我们对它们进行FT，看看他们包含怎么样的频率，如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-8a1cd705a0354cb0cbeb067e1f7ce992_hd.jpg" alt="img">                                                                    y1,FT</p><p><img src="https://pic1.zhimg.com/80/v2-c95d1c9d11a72b51447425f5fbd0e0c8_hd.jpg" alt="img">                                                                        y2,FT</p><p>Amazing！发现了什么？<strong>变换后的结果是一模一样的，都在w=1rad/s和w=5rad/s出现了峰值！这就可以说明FT的缺点了——FT只能提供频域信息，而完全丢失了时域信息！！！</strong></p><p><strong>不管某一频率的信号出现的时间是早还是晚，FT都是将它一视同仁地乘上sin和cos(FT的变换基函数)，然后在整个时间区间加和。因此，它不能提供某一频率信号出现的时间。</strong></p><p>比如，对于上面两个信号，FT只能告诉我们，它们都有1rad/s和5rad/s的频率，而不能告诉我们1rad/s和5rad/s分别出现在哪个时间段。</p><p>所以，怎么办呢？？？</p><p><strong>那就是把信号分成左右两半啊！左边进行一次FT，右边进行一次FT，很简单吧！好了，这就是短时傅里叶变换（STFT）的基本原理。</strong></p><p>所以，接下来我们要正式开始步入——短时傅里叶变换（STFT），看看它是如何解决这个问题的。</p><h3 id="短时傅里叶变换（STFT）"><a href="#短时傅里叶变换（STFT）" class="headerlink" title="短时傅里叶变换（STFT）"></a><strong>短时傅里叶变换（STFT）</strong></h3><p>如上所述，我们将信号从中间截断，左边进行一次FT，右边进行一次FT，分别来看看。</p><p><img src="https://pic4.zhimg.com/80/v2-43e0b0a1d3e8758f32fc784a35b00183_hd.jpg" alt="img">y1左</p><p><img src="https://pic3.zhimg.com/80/v2-6ccbe7a93f390033d4444a949bcd356e_hd.jpg" alt="img">y1右</p><p><img src="https://pic2.zhimg.com/80/v2-271124958efcef10cd9a370d3f5061b9_hd.jpg" alt="img">y2左</p><p><img src="https://pic4.zhimg.com/80/v2-417fda7319483f84086bc73b299c5b03_hd.jpg" alt="img">y2右</p><p>可以看出，y1的左半部分是5rad/s，右半部分是1rad/s，y2恰好相反。这就说明，在y1中，(0, 25)的信号是5rad/s的频率，(25, 50)的信号是5rad/s的频率，y2恰好相反。<strong>这就是短时傅里叶变换的基本原理。</strong></p><p>但是数学嘛，能用一个公式表达的，就别用一段话表达，截断、切开这些语句太不专业了。<strong>截断、切开的操作，更专业的讲叫作分窗，其实是可以通过数学上的处理变成DFT变换的基函数的一部分的。接下来我们来看一看。</strong></p><p>首先，你可以想象一下，有一个窗子在这个信号上从左向右滑动，每次你都只能看到这个信号的一部分，<strong>所以我们把这个长度叫作窗长width。</strong></p><p>现在我们来定义一个方窗函数： <img src="https://www.zhihu.com/equation?tex=y_%7Bwindow%7D+%3D+1+%2A%28-width%2F2%3Ct%3Cwidth%2F2%29" alt="[公式]"> ，如下图，即是width = 10 的一个方窗函数：</p><p><img src="https://pic2.zhimg.com/80/v2-bd998377f53a5dffc8546cf019d119a1_hd.jpg" alt="img"></p><p>定义了方窗函数之后，我们<strong>只需要对方窗函数进行平移，再与原信号作乘，就相当于原来的截断、切开的操作，因此这种操作更专业地叫作分窗。</strong></p><p>那么，<strong>将方窗函数向右平移了 <img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]">（s可能是sliding的意思吧），再与原信号相乘，由于方窗函数除了中心的width部分是1外，其他部分都是0，这就相当于提取出了原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处，宽度为width的部分</strong>，这个信号分窗这个操作就可以写成： <img src="https://www.zhihu.com/equation?tex=y_%7Bwindow%7D%28t+-+t_s%29++y%28t%29" alt="[公式]"> 。</p><p>如下两图所示，将 <img src="https://www.zhihu.com/equation?tex=y%28t%29%3Dsin%285t%29" alt="[公式]"> 与 <img src="https://www.zhihu.com/equation?tex=y_%7Bwindow%7D%28t+-+25%29" alt="[公式]"> 相乘，就相当于取出来了 <img src="https://www.zhihu.com/equation?tex=y%28t%29%3Dsin%285t%29" alt="[公式]"> 中的(20,30)中的一段。</p><p>那么，我们对原信号中被提取出来的这一部分进行FT，就可以写成： <img src="https://www.zhihu.com/equation?tex=X%28w%2Ct_s%29+%3D+%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7Dy_%7Bwindow%7D%28t+-+t_s%29++y%28t%29e%5E%7B-jw%28t-t_s%29%7Ddt" alt="[公式]"></p><p>PS：这里之所以 <img src="https://www.zhihu.com/equation?tex=e%5E%7B-jwt%7D" alt="[公式]"> 要变成 <img src="https://www.zhihu.com/equation?tex=e%5E%7B-jw%28t-t_s%29%7D" alt="[公式]"> ，是为了保证做FT的时候相乘的基函数具有统一性。</p><p>如此，变换后的<img src="https://www.zhihu.com/equation?tex=X%28w%2Ct_s%29" alt="[公式]">代表<strong>原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处、宽度为width的部分的傅里叶变换</strong>，也就可以提取出来<strong>原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处、宽度为width的部分，包含各个频率部分的多少！带入不同的</strong> <img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"> <strong>，也就是随着窗子的滑动，就可以知道不同的时间段内频率的成分。</strong></p><p>我们采用width为10的方窗函数对<img src="https://www.zhihu.com/equation?tex=y3%3Dsin%2820t%29%2A%280%3Ct%3C25%29%2Bsin%28t%29%2A%2825%3Ct%3C50%29" alt="[公式]"> 进行STFT，如下：</p><p>首先，方窗函数位于 <img src="https://www.zhihu.com/equation?tex=t+%3D+5s" alt="[公式]"> 处，与原始信号相乘，选择出(0,10)的信号。</p><p><img src="https://pic4.zhimg.com/80/v2-9c184aa29068c665f5ead3439d42cd0b_hd.jpg" alt="img"></p><p>对选择出来的信号进行FT。可以看到，当<img src="https://www.zhihu.com/equation?tex=t+%3D+5s" alt="[公式]">时，选择的时间区间为(0,10)，这一部分只包含了 <img src="https://www.zhihu.com/equation?tex=w+%3D+20rad%2Fs" alt="[公式]"> 的频率成分。</p><p><img src="https://pic4.zhimg.com/80/v2-ec4cc9c93dc4d7b763ac5843fd02be8b_hd.jpg" alt="img"></p><p>之后，方窗函数向右移动，与原始信号相乘，选择出不同时间区间的信号，进行FT。这里选择<img src="https://www.zhihu.com/equation?tex=t+%3D+25s" alt="[公式]">进行展示。</p><p><img src="https://pic1.zhimg.com/80/v2-6df4bbf241bd086b20e7db05a31cf7d0_hd.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-3bd9b031d41ce1e3349d762e74b850fa_hd.jpg" alt="img"></p><p>可以看到，当<img src="https://www.zhihu.com/equation?tex=t+%3D+25s" alt="[公式]">时，选择的时间区间为(20,30)，这一部分即包含了 <img src="https://www.zhihu.com/equation?tex=w+%3D+20rad%2Fs" alt="[公式]"> 的频率成分，也包含了 <img src="https://www.zhihu.com/equation?tex=w+%3D+1rad%2Fs" alt="[公式]"> 的频率成分。</p><p>重复以上过程，我们可以<strong>将方窗函数选择的不同时间区间的信号的FT的结果拼合起来，形成一张三维图</strong>。由此，我们即可知道，<strong>在 <img src="https://www.zhihu.com/equation?tex=%28t_s-width%2F2%2C+t_s%2Bwidth%2F2%29" alt="[公式]"> 的时间区间内，信号具有怎么样的频率成分。</strong></p><p><img src="https://pic4.zhimg.com/80/v2-389958865460686e1d15a0b2f9ddb277_hd.jpg" alt="img"></p><p>通过width = 10的方窗的STFT结果，我们可以知道，对于信号：<img src="https://www.zhihu.com/equation?tex=y3%3Dsin%2820t%29%2A%280%3Ct%3C25%29%2Bsin%28t%29%2A%2825%3Ct%3C50%29" alt="[公式]"> ，在(0,10)、(10,20)时间区间内，具有20rad/s的频率成分；在(20,30)时间区间内，具有1rad/s和20rad/s的频率成分；在(30,40)、(40,50)时间区间内，具有1rad/s的频率成分。</p><p>最后，进行三点重要的讨论。</p><p>第一点，<strong>变换之后的</strong> <img src="https://www.zhihu.com/equation?tex=X%28w%2Ct_s%29" alt="[公式]"> <strong>是一个三维函数，它有两个自变量，</strong> <img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"> <strong>和w。</strong><img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"> 指的是<strong>原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处，</strong>w上一篇文章我们已经讨论过了，就是频率。所以，STFT提取出来的信息就是：<strong>原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处、宽度为width的部分，包含的频率信息。</strong></p><p><strong>原则上讲，可以得到任一<img src="https://www.zhihu.com/equation?tex=+t_s" alt="[公式]">对应的频率成分，如下图。</strong></p><p><img src="https://pic2.zhimg.com/80/v2-dccf7c6b239c4777b934a1c871f86aed_hd.jpg" alt="img"></p><p><strong>但是</strong> <strong><img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"> 是连续的，并不意味着你知道了每个时刻的频率成分，你知道的还只是 <img src="https://www.zhihu.com/equation?tex=%28t_s-width%2F2%2C+t_s%2Bwidth%2F2%29" alt="[公式]">这一段区间内的频率信息。所以一般不需要计算所有的</strong> <img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"><strong>，每隔width计算一次即可。</strong></p><p>你或许会想，我<strong>把width缩小一些，不就可以知道更精确的时间范围内的频率了吗？</strong>是的，你的猜想很对！但是，<strong>如此做也会带来一些频域分辨率的问题。</strong>这一点涉及到一些时域分辨率和频域分辨率的知识，我们下一篇文章会着重讲。</p><h4 id="本质变化"><a href="#本质变化" class="headerlink" title="本质变化:"></a>本质变化:</h4><p>第二点，<strong>方窗函数是可以包含入变换基函数内部的，这组成了新的基函数，同时反映了STFT的本质。</strong></p><p>我们来看， 如果定义 <img src="https://www.zhihu.com/equation?tex=%5Cphi+%28t%29+%3D+e%5E%7B-jwt%7D+y_%7Bwindow%7D%28t%29" alt="[公式]"> ，那么<img src="https://www.zhihu.com/equation?tex=%5Cphi+%28t+-+t_s%29+%3D+e%5E%7B-jw%28t-+t_s%29%7D+y_%7Bwindow%7D%28t-+t_s%29" alt="[公式]"></p><p>那么，STFT的公式： <img src="https://www.zhihu.com/equation?tex=X%28w%2Ct_s%29+%3D++%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7Dy_%7Bwindow%7D%28t+-+t_s%29++y%28t%29e%5E%7B-jw%28t-+t_s%29%7Ddt" alt="[公式]"> 就可以写成： <img src="https://www.zhihu.com/equation?tex=X%28w%2C+t_s%29++%3D++%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7Dy%28t%29%5Cphi%28t+-+t_s%29+dt" alt="[公式]"></p><p>我们在上一篇文章里说过，<strong>变换就是将原信号乘上一个基函数，再积分的过程，那么，SDFT的基函数就是 <img src="https://www.zhihu.com/equation?tex=%5Cphi%28t%29+%3D+e%5E%7B-jwt%7D+y_%7Bwindow%7D%28t%29" alt="[公式]"> ！</strong></p><p>Amazing！所以，STFT的本质是什么呢？</p><p><strong>STFT的本质就是将FT的基函数 <img src="https://www.zhihu.com/equation?tex=e%5E%7B-jwt%7D" alt="[公式]"> 乘上一个方窗函数，形成了一个新的基函数<img src="https://www.zhihu.com/equation?tex=%5Cphi%28t%29+%3D+e%5E%7B-jwt%7D+y_%7Bwindow%7D%28t%29" alt="[公式]"> ！</strong>前面说的分窗、截断之类的都是表象，<strong>STFT的本质是基函数的改变！</strong></p><p>那么，为什么STFT的基函数可以用于分窗，而FT的基函数不行呢？我们来看，我用正弦函数sin(5t)表示原来的基函数<img src="https://www.zhihu.com/equation?tex=e%5E%7B-jwt%7D" alt="[公式]"> ，那么FT基函数和STFT基函数如下：</p><p><img src="https://pic4.zhimg.com/80/v2-9fb003e0c1ca9b79cba81b58a6d06003_hd.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-02cb52f656bb597ba81ea90af534044b_hd.jpg" alt="img"></p><p>原因就是：FT的基函数是在时域无限延伸的，因此，无论怎么平移，都是任分布在整个时域的，起不到分窗的作用。<strong>而STFT的基函数只在时域一段不为0，在剩下的时域都是0，因此，STFT的基函数的平移，就相当于自动加了窗子啦！</strong></p><h4 id="紧支撑性"><a href="#紧支撑性" class="headerlink" title="紧支撑性:"></a>紧支撑性:</h4><p><strong>这种只在时域一段不为0，在剩下的时域都是0的性质被称为“紧支撑性”（compactly supported），具有这种性质的函数，平移之后与一个信号相乘，就相当于分窗操作。这一点很重要，我们之后讲小波变换的基函数的时候还会讲。</strong></p><p>第三点，<strong>我们前面对于分窗操作使用的函数一直称为“方窗函数”</strong>，这是一种最理想的窗函数。<strong>还有一些其他的窗函数，比如，汉宁窗、海明窗、高斯窗等</strong>。窗函数本质都是一个窗子而已，原理是一模一样的，上面所有的讨论也都成立，只是这些窗子会让信号稍稍变形一丢丢而已。你就想像方窗函数就是一面平面镜，其他的窗函数就是哈哈镜就行了。</p><hr><h2 id="短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）"><a href="#短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）" class="headerlink" title="短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）"></a>短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）</h2><hr><h2 id="连续小波变换（CWT）的缺点与离散小波变换（DWT）"><a href="#连续小波变换（CWT）的缺点与离散小波变换（DWT）" class="headerlink" title="连续小波变换（CWT）的缺点与离散小波变换（DWT）"></a>连续小波变换（CWT）的缺点与离散小波变换（DWT）</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;傅里叶变换-gt-小波变化&quot;&gt;&lt;a href=&quot;#傅里叶变换-gt-小波变化&quot; class=&quot;headerlink&quot; title=&quot;傅里叶变换-&amp;gt;小波变化&quot;&gt;&lt;/a&gt;傅里叶变换-&amp;gt;小波变化&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;声明:文中大多数内容来
      
    
    </summary>
    
    
      <category term="信号处理" scheme="https://nymrli.top/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Vim记忆</title>
    <link href="https://nymrli.top/2019/07/26/Vim%E8%AE%B0%E5%BF%86/"/>
    <id>https://nymrli.top/2019/07/26/Vim记忆/</id>
    <published>2019-07-26T02:34:34.000Z</published>
    <updated>2019-07-26T02:44:56.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VIM记忆技巧"><a href="#VIM记忆技巧" class="headerlink" title="VIM记忆技巧"></a>VIM记忆技巧</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><ul><li>i(insert)</li><li>I最前面insert</li><li>a(append)</li><li>A最后面append</li><li>o(open a line)往下开启一行</li><li>O往上开启一行</li></ul><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><ul><li>d（delete）</li><li>dw（delet word）</li><li>dd（删除一行）</li><li>x（删除一个字符）</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li>diw(delete inner word)</li><li>daw(delete around word)</li></ul><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><ul><li>c（change）</li><li>ciw（change inner word）</li><li>ci”(change inner “)</li><li>ct）修改到右括号</li></ul><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><ul><li>fs(find s) 跳到本行第一个s字符</li><li><code>/</code>往后查找,如/xxx 全文搜索xxx<ul><li><code>;</code>查找下一个</li></ul></li><li><code>?</code>往前查找</li></ul><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><ul><li>h←</li><li>j↓</li><li>k↑</li><li><p>l→</p></li><li><p>w(word)往后跳一个单词</p></li><li><p>b(back word)往前返回一个单词</p><ul><li>以空格为界区分单词</li></ul></li><li>行间跳转<ul><li><code>:18</code> 跳转到第18行</li><li><code>18G</code> 跳转到第18行</li></ul></li><li>行内跳转:<ul><li><code>0</code>行首</li><li><code>$</code>行尾</li></ul></li><li><code>ctrl+o</code>返回上一个位置</li><li><code>G</code>文件结尾</li><li><code>gg</code>文件开头</li><li><code>ctrl+f</code>(forward)往后翻页</li><li><code>ctrl+u</code>(upward)往前翻页</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VIM记忆技巧&quot;&gt;&lt;a href=&quot;#VIM记忆技巧&quot; class=&quot;headerlink&quot; title=&quot;VIM记忆技巧&quot;&gt;&lt;/a&gt;VIM记忆技巧&lt;/h1&gt;&lt;h2 id=&quot;增&quot;&gt;&lt;a href=&quot;#增&quot; class=&quot;headerlink&quot; title=&quot;增&quot;&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://nymrli.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用</title>
    <link href="https://nymrli.top/2019/07/25/Docker%E4%BD%BF%E7%94%A8/"/>
    <id>https://nymrli.top/2019/07/25/Docker使用/</id>
    <published>2019-07-25T02:58:19.000Z</published>
    <updated>2019-07-26T14:17:15.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h1><blockquote><p>轻部署,省成本,易迁移</p></blockquote><h2 id="docker和虚拟机VM的区别"><a href="#docker和虚拟机VM的区别" class="headerlink" title="docker和虚拟机VM的区别"></a>docker和虚拟机VM的区别</h2><h3 id="一、本质上的区别："><a href="#一、本质上的区别：" class="headerlink" title="一、本质上的区别："></a>一、本质上的区别：</h3><p><img src="https://img-blog.csdn.net/20180711090727241?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmd6aHVuYmlhbmNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用；</p><p>Container(Docker容器)，在宿主机器、宿主机器操作系统上创建Docker引擎，在引擎的基础上再安装应用。</p><p>那么问题来了，没有操作系统，怎么运行程序？</p><p>可以在Docker中创建一个ubuntu的镜像文件，这样就能将ubuntu系统集成到Docker中，运行的应用就都是ubuntu的应用。</p><h3 id="二、使用上的区别："><a href="#二、使用上的区别：" class="headerlink" title="二、使用上的区别："></a>二、使用上的区别：</h3><p><img src="https://img-blog.csdn.net/20180711094611205?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmd6aHVuYmlhbmNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>Size:</p><ul><li>虚拟机ubuntu大小为:24.1GB</li><li>Docker中镜像文件占用内存: 81.2MB</li></ul><p>Startup：</p><ul><li>Docker在宿主机器的操作系统上创建Docker引擎，直接在宿主主机的操作系统上调用硬件资源，而不是虚拟化操作系统和硬件资源，所以操作速度快。</li><li>这个其实安装一个ubuntu的虚拟机和拉取一个Docker的ubuntu镜像文件，运行一下就知道了，区别很明显，虚拟机开一下大概得2分多钟，而Docker只需要2秒钟。</li></ul><h2 id="宿主机、镜像与容器"><a href="#宿主机、镜像与容器" class="headerlink" title="宿主机、镜像与容器"></a>宿主机、镜像与容器</h2><p>宿主机器: 运行docker的机器</p><p>镜像:不可以修改内容</p><p>容器:可以修改能内容,相当于虚拟机,默认情况下彼此相互独立（容器之间可以通信）</p><p>△.可以依据镜像来创建容器,也可以封装容器为一个镜像,即<strong>容器&lt;===&gt;镜像</strong></p><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><p>搜索镜像: <code>docker search python</code></p><p>下载镜像: <code>docker pull NAME</code></p><p>创新容器: <code>docker run -tid  (--name xxx)  IMAGE ID</code></p><ul><li><code>ti</code>表示以交互的形式创建容器，<code>d</code>表示不进入<ul><li><code>-d, --detach=false</code>， 指定容器运行于前台还是后台，默认为false</li><li><code>-i, --interactive=false</code>， 打开STDIN，用于控制台交互</li><li><code>-t, --tty=false</code>， 分配tty设备，该可以支持终端登录，默认为false</li></ul></li></ul><p>运行容器: <code>docker start CONTAINER_ID</code>  </p><p>进入容器： <code>docker attach CONTAINER_ID</code></p><ul><li>进入容器前得前运行容器</li></ul><p>退出容器： <code>ctrl + p + q</code> , 以<code>ctrl + z</code> 、<code>exit</code>将会终止容器运行</p><p>封装容器为镜像: <code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a :提交的镜像作者；</span><br><span class="line">-c :使用Dockerfile指令来创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line">-p :在commit时，将容器暂停。</span><br></pre></td></tr></table></figure><p>容器通信-创建子节点链接中心节点: <code>docker run -tid  (--name xxx)  (--link CONTAINER_NAMES) IMAGE ID</code></p><p>查看容器ip: <code>cat /ect/hosts</code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@b68943564e76:/# cat /etc/hosts </span><br><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">ff00::0ip6-mcastprefix</span><br><span class="line">ff02::1ip6-allnodes</span><br><span class="line">ff02::2ip6-allrouters</span><br><span class="line">172.17.0.2test 4e02c004539e</span><br><span class="line">172.17.0.3b68943564e76</span><br></pre></td></tr></table></figure><p>▲初次使用,  <code>ifconfig</code>使用无效,<code>ping</code>也无效,原因如下</p><blockquote><p>我创建的容器是拉取的Base镜像，而因为用Docker拉取的<strong>Base镜像</strong>如Centos和Ubuntu的话都是<strong>最简版本</strong>，不包含Ping工具，而对Docker进行Docker network和Docker链接操作时往往要用到Ping工具测试两个容器间的网络，此时就要用到Ping工具了，下面是Ubuntu下安装Ping工具的命令：<code>apt-get update &amp;&amp; apt-get install iputils-ping</code>、安装ifconfig工具:<code>apt install net-tools</code></p></blockquote><p><strong>从容器里面拷文件到宿主机</strong></p><p> docker cp 容器名：要拷贝的文件在容器里面的路径       要拷贝到宿主机的相应路径 </p><p>宿主机上执行:<code>$ docker cp testtomcat：/usr/local/tomcat/webapps/test/js/test.js /opt</code></p><p><strong>从宿主机拷文件到docker容器里面</strong></p><p> docker cp 要拷贝的文件路径 容器名：要拷贝到容器里面对应的路径</p><p>宿主机上执行<code>$ docker cp requirements.txt apptest:/app</code></p><p>▲注:容器NAME可以通过<code>docker ps</code>命令查看</p><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><blockquote><p>Dockerfile文件D一定要大写</p><p><code>$ docker build -t=&quot;dormanctpress/df_test2&quot; .</code></p><ul><li>.为Dockerfile的路径</li></ul></blockquote><p>1.<code>FROM &lt;image&gt;:&lt;tag&gt;</code></p><p>2.MAINTAINER</p><p>3.RUN</p><ul><li>镜像构建中运行的命令</li></ul><p>4.EXPOSE</p><ul><li>如果是端口的话，只是声明会使用xx端口,但是实际使用时还是需要run -p xx    <code>$ docker build -t=&quot;dormanctpress/df_test2&quot; .</code></li><li>设置环境变量</li></ul><p>CMD</p><ul><li>在容器运行时运行的默认命令(命令行中添加的命令可以代替掉Dokcerfile中写的CMD指令)</li><li>每个Dockerfile只能够包含一个CMD，多个CMD 只有最后一个能有效</li><li>定义的三种方式<ul><li>CMD<cmd>这个会当做/bin/sh-c“cmd”来执行</cmd></li><li>CMD[“executable”，”arg1”，”arg2”]<ul><li>一定要双引号</li></ul></li><li>CMD[“arg1”，”arg2”]，这个时候CMD作为ENTRYPOINT的参数</li></ul></li></ul><p>ENTRYPOINT</p><ul><li><p>每个Dockerfile只能够包含一个ENTRYPOINI，多个ENTRYPOINT只有最后一个能有效</p></li><li><p>不会像CMD命令一样被覆盖,除非使用<code></code></p></li><li>当定义了ENTRYPOINT后,CMD将被作为参数使用。如果定义了CMD，那么<code>docker run -t test/osf2 xxxx</code>后面即xxxx的内容全会被当做参数传递ENTRYPOINT</li></ul><p>组合使用ENTRYPOINT和CMD: ENTRYPOINT指定命令,CMD指定默认参数</p><p>ADD&amp;COPY</p><p>共同点</p><ul><li><p>ADD&amp;COPY的源必须在context路径下</p></li><li><p>当在源代码构建的方式下，可以通过ADD和COPY的方式，把Host上的文件或者目录复制到Image</p><p>ADD</p></li><li><p>包含类似tar解压的功能</p></li><li><p>当src为网络URL的情况下，ADD指令可以把它下载到Dest的指定位置，这个在任何build的方式下都可以Work</p></li></ul><p>COPY</p><ul><li>如果单纯复制文件,Docker推荐COPY</li><li>ADD&amp;COPY的源必须在context路径下</li><li>当在源代码构建的方式下，可以通过ADD和COPY的方式，把Host上的文件或者目录复制到Image</li></ul><p>VOLUME[‘/data’]</p><ul><li>设置数据卷</li></ul><p>WORKDIR /path/to/workdir</p><ul><li>一般使用绝对路径</li></ul><p>ENV <key> <value></value></key></p><ul><li>用来设置环境变量，后续的RUN可以使用它所创建的环境变量。</li><li>当创建基于该镜像的Container的时候，会自动拥有设置的环境变量</li></ul><p>USER daemon</p><ul><li><p>指定UID或者username，来决定运行RUN指令的用户</p></li><li><p>如果不指定,则默认root</p></li></ul><p>ONBUILD</p><ul><li>触发器</li></ul><h3 id="dockerfile构建过程"><a href="#dockerfile构建过程" class="headerlink" title="dockerfile构建过程"></a>dockerfile构建过程</h3><ol><li>从基础镜像运行一个容器</li><li>执行一条指令，对容器做出修改</li><li>执行类似docker commit的操作，提交一个新的镜像层</li><li>再基于刚提交的镜像运行一个新容器</li><li>执行Dockerfile中的下一条指令，直至所有指令执行完毕</li></ol><h3 id="使用中间层镜像进行调试"><a href="#使用中间层镜像进行调试" class="headerlink" title="使用中间层镜像进行调试"></a>使用中间层镜像进行调试</h3><p>查找错误</p><h3 id="Dockerfile-镜像缓存"><a href="#Dockerfile-镜像缓存" class="headerlink" title="Dockerfile 镜像缓存"></a>Dockerfile 镜像缓存</h3><p>构建缓存：将之前的镜像缓存</p><p>不使用缓存<code>docker build --no-cache</code></p><h3 id="查看镜像构建的过程"><a href="#查看镜像构建的过程" class="headerlink" title="查看镜像构建的过程"></a>查看镜像构建的过程</h3><p>查看构建过程:<code>docker history xxx/yyy</code></p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>sudo docker run -v ~/container_data:/data -it ubuntu /bin/bash</code></p><p>参数说明:使用-v选项,第一个参数为宿主机目录,:后的目录为在容器中使用的目录(挂载);ubuntu为镜像</p><h3 id="查看容器是否挂载了数据卷"><a href="#查看容器是否挂载了数据卷" class="headerlink" title="查看容器是否挂载了数据卷"></a>查看容器是否挂载了数据卷</h3><p><code>docker inspect CONTAINER_ID</code>可以查看容器是否挂载了数据卷</p><h3 id="给数据卷增加权限"><a href="#给数据卷增加权限" class="headerlink" title="给数据卷增加权限"></a>给数据卷增加权限</h3><p><code>sudo docker run -v ~/datavolume:/data:ro -it ubuntu/bin/bash</code></p><p>ro是read-only</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><blockquote><p>命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器</p></blockquote><p>挂载数据卷容器的方法</p><p><code>docker run--volumes-from [CONTAINER NAME]</code></p><h2 id="MySQL通信"><a href="#MySQL通信" class="headerlink" title="MySQL通信"></a>MySQL通信</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; can<span class="string">'t connect to MySQL server on '</span>172.17.0.8<span class="string">'(111)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/mvsal/my.cnf </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将<span class="built_in">bind</span>-address=127.0.0.1注释掉</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Host <span class="string">'2eaf92ef2ff6'</span>is not allowed to connect to this MySQL server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> create user <span class="string">"weiwei"</span>@<span class="string">"%"</span>identified by<span class="string">"weijc7789"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grant create, select, update, delete, insert on *.* to weiwei;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增添权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysq1-h 172.17.0.8-u weiwei-p</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 链接</span></span><br></pre></td></tr></table></figure><h2 id="redis通信"><a href="#redis通信" class="headerlink" title="redis通信"></a>redis通信</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 172.17.0.8</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Could not connect to Redis at 172.17.0.8:6379:Connection refused</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/redis /redis.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将<span class="built_in">bind</span>-address=127.0.0.1注释掉</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果修改后/ect/init.d/redis-server restart后还是链接不了,重启进入容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli-h 172.17.0.8-p 6379</span></span><br></pre></td></tr></table></figure><p>一条命令实现停用并删除容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>一条命令删除所有镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi `docker images -q`</span><br></pre></td></tr></table></figure><p>一条命令删除创建失败的镜像:</p><p><code>docker images | sed -n &#39;2p&#39; | awk &#39;{print$3}&#39; | xargs docker rmi</code></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Dockerfile-RUN，CMD，ENTRYPOINT命令区别"><a href="#Dockerfile-RUN，CMD，ENTRYPOINT命令区别" class="headerlink" title="Dockerfile RUN，CMD，ENTRYPOINT命令区别"></a>Dockerfile RUN，CMD，ENTRYPOINT命令区别</h3><blockquote><p>RUN命令执行命令并创建新的镜像层，通常用于安装软件包</p><p>CMD命令设置容器启动后默认执行的命令及其参数，但CMD设置的命令能够被<code>docker run</code>命令后面的命令行参数替换</p><p>ENTRYPOINT配置容器启动时的执行命令（不会被忽略，一定会被执行，即使运行 <code>docker run</code>时指定了其他命令）</p></blockquote><p>Shell格式和Exec格式运行命令</p><p>我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式：</p><ul><li>Shell格式：<instruction> <command>。例如：apt-get install python3<ul><li>多条命令用&amp;&amp;链接</li></ul></instruction></li><li>Exec格式：<instruction> [“executable”, “param1”, “param2”, …]。例如： [“apt-get”, “install”, “python3”]</instruction></li></ul><p><strong>CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。</strong></p><p>### </p><p><strong>总结</strong></p><ul><li>使用 RUN 指令安装应用和软件包，构建镜像。</li><li>如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。</li><li>如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。</li></ul><hr><h3 id="Docker-运行python-flask的web程序"><a href="#Docker-运行python-flask的web程序" class="headerlink" title="Docker 运行python flask的web程序"></a>Docker 运行python flask的web程序</h3><h4 id="1创建镜像"><a href="#1创建镜像" class="headerlink" title="1创建镜像"></a>1创建镜像</h4><h5 id="1-1-ubuntu16-04-python3-6"><a href="#1-1-ubuntu16-04-python3-6" class="headerlink" title="1.1 ubuntu16.04+python3.6"></a>1.1 ubuntu16.04+python3.6</h5><blockquote><p>18.04卡在了PPA环节,并且git安装也没安装上,后来使用了<a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">dockerHub</a>上搜素到的github仓库中的<a href="https://github.com/tianon/docker-brew-ubuntu-core/tree/105329f5da5f205e3d2bcb1f96ce32a472e56239/xenial" target="_blank" rel="noopener">16.04 Xenial</a>就解决了。</p><p>注：<strong>镜像TAG版本需要到dockerHub上才能查看，最初下载成18.04就是因为这个原因被坑了</strong></p><p>18.04PPA问题:</p><p><code>aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Ubuntu/bionic</code>意思是18.04该PPA没有资源.bionic是<a href="#附Uuntu版本代号:">版本代号</a>,如16.04的  Xenial</p></blockquote><p>⑴使用下载好的Xenial的Dockerfile进行创建镜像<code>docker run 1604ubuntu .</code></p><p>为了使用国内源用阿里云，先编辑一个sources.list，放在dokcerfile同目录下，作为docker创建镜像时的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><p>⑵根据官方的镜像来编写自己的Dockerfile创建具有工具的Ubuntu1604</p><blockquote><p>涉及交互式选择项（如下），docker build的时候会报错。设置 DEBIAN_FRONTEND=noninteractive</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">FROM 1604ubuntu</span><br><span class="line">MAINTAINER mrli</span><br><span class="line">#用ubuntu国内源替换默认源</span><br><span class="line">RUN rm /etc/apt/sources.list</span><br><span class="line">COPY sources.list /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">#安装python3.6必要的包。源镜像太精简了，ip ifconfig之类的都没有。后续安装python pip也需要一些。但是build_essential似乎不必须，先去了。如果后面安装numpy之类需要gcc了，再加上</span><br><span class="line">RUN apt update</span><br><span class="line">#RUN apt upgrade</span><br><span class="line"></span><br><span class="line">RUN apt install -y apt-utils apt-transport-https  vim iproute2 net-tools ca-certificates curl build-essential wget python-software-properties software-properties-common psmisc</span><br><span class="line"></span><br><span class="line">#安装python3.6 来自第三方</span><br><span class="line">RUN add-apt-repository ppa:jonathonf/python-3.6</span><br><span class="line">RUN apt update</span><br><span class="line">RUN apt install -y python3.6</span><br><span class="line">RUN apt install -y python3.6-dev</span><br><span class="line">RUN apt install -y python3.6-venv</span><br><span class="line"></span><br><span class="line">#为3.6安装pip</span><br><span class="line">RUN wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">RUN python3.6 get-pip.py</span><br><span class="line"></span><br><span class="line">#设置默认python为python3</span><br><span class="line">RUN update-alternatives --install /usr/bin/python python /usr/bin/python2 100</span><br><span class="line">RUN update-alternatives --install /usr/bin/python python /usr/bin/python3 150</span><br><span class="line"></span><br><span class="line">#和自带的3.5共存,设置python3默认为3.6</span><br><span class="line">#RUN update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.5 1</span><br><span class="line">RUN update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.6 2</span><br><span class="line"></span><br><span class="line"># 更新配置</span><br><span class="line">RUN update-alternatives --config python3</span><br><span class="line">#print()时在控制台正常显示中文</span><br><span class="line">ENV PYTHONIOENCODING=utf-8</span><br></pre></td></tr></table></figure><p>在dockerfile所在路径下执行，建立image</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t uos:1604 .</span><br></pre></td></tr></table></figure><p>因为开头几步用了国内源，所以非常快。</p><h5 id="1-2-开发环境"><a href="#1-2-开发环境" class="headerlink" title="1.2 开发环境"></a>1.2 开发环境</h5><p>再建一个dockerfile，开头使用刚才建立的镜像uos1604</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FROM uos:1604</span><br><span class="line">MAINTAINER mrli</span><br><span class="line"></span><br><span class="line">#代码复制过来后的路径</span><br><span class="line">RUN mkdir /app</span><br><span class="line"># 指定容器启动时执行的命令都在app目录下执行</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 将本地app目录下的内容拷贝到容器的app目录下</span><br><span class="line">COPY ./app/ /app/</span><br><span class="line"></span><br><span class="line"># 安装nginx</span><br><span class="line">RUN apt -y install nginx mysql-server </span><br><span class="line"></span><br><span class="line">RUN /etc/init.d/nginx start</span><br><span class="line"># 替换nginx的配置</span><br><span class="line">RUN rm  /etc/nginx/sites-enabled/default</span><br><span class="line">RUN cp nginx.conf /etc/nginx/sites-enabled/nginx.conf</span><br><span class="line"></span><br><span class="line">RUN pip3 install uwsgi</span><br><span class="line"></span><br><span class="line">#安装需要的python库</span><br><span class="line"># 启动nginx和uwsgi</span><br><span class="line">#ENTRYPOINT pip install -r requirements.txt  -i  https://pypi.tuna.tsinghua.edu.cn/simple some-package --no-cache-dir &amp;&amp; service nginx restart &amp;&amp; uwsgi --ini uwsgi.ini</span><br><span class="line"></span><br><span class="line"># 为了保证能之后进入所以最后一个命令为/bin/sh</span><br><span class="line">ENTRYPOINT pip install -r requirements.txt  -i  https://pypi.tuna.tsinghua.edu.cn/simple some-package --no-cache-dir &amp;&amp; service nginx restart &amp;&amp; uwsgi --ini uwsgi.ini &amp; &amp;&amp; /bin/sh</span><br></pre></td></tr></table></figure><p>创建uflask镜像:<code>docker build -t uflask .</code></p><p><a href="#2启动容器">根据镜像创建运行容器</a>:<code>docker run -tid -p 12345:80 flaskdemo IMAGE_ID</code></p><p>此时就可以通过<code>VPS的IP地址:宿主机端口</code>访问这个应用程序</p><p>查看日志:<code>docker logs 应用名(NAMES)</code>如<code>docker logs flaskdemo</code></p><h5 id="关于mysql的建议"><a href="#关于mysql的建议" class="headerlink" title="关于mysql的建议"></a>关于mysql的建议</h5><blockquote><p>mysql建议作为单独容器来跑数据库,然后远程连接数据库.或是使用数据卷</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line"># 搜索</span><br><span class="line"># docker search mysql</span><br><span class="line"># 拉取</span><br><span class="line"># docker pull mysql:5.7</span><br><span class="line">#运行</span><br><span class="line"># docker run --name mysql5.7 -e MYSQL_ROOT_PASSWORD=123456 -p 3307:3306 -d mysql:5.7</span><br></pre></td></tr></table></figure><h4 id="2启动容器-转"><a href="#2启动容器-转" class="headerlink" title="2启动容器(转)"></a>2启动容器(转)</h4><ul><li><p>Docker</p><p>一种开源容器应用，供开发者打包自己的开发环境，可以任意移植</p></li></ul><ul><li>docker-compose<br>一种管理多个Docker容器的工具，可以简化我们启动容器的各种命令</li></ul><h5 id="2-1手动敲docker命令"><a href="#2-1手动敲docker命令" class="headerlink" title="2.1手动敲docker命令"></a>2.1手动敲docker命令</h5><p>先试试用docker命令行启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name quotation_api -itd -p 5000:5000 -v /home/quotation:/code quotation_dev:latest</span><br></pre></td></tr></table></figure><p>用到的参数分别是</p><blockquote><p>–name为容器命名；</p><p>-itd  输入输出终端，后台运行</p><p>-p   host端口:容器端口</p><ul><li>将宿主机5000端口的请求转发到容器5000端口,用5000是flask默认</li></ul><p>-v  host路径:容器内路径(挂载数据卷)</p><p>quotation_dev:latest 最后是使用的镜像名（前面刚用dockerfile build出来的）</p></blockquote><p>然后进入容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach quotation_api</span><br></pre></td></tr></table></figure><p>用python3 main.py启动flask，OK。</p><p>这样flask运行在docker里了。</p><p>在host改代码，可以看见docker的控制台在更新，和在host一样了。(使用数据卷)</p><h5 id="2-2使用dock-compose"><a href="#2-2使用dock-compose" class="headerlink" title="2.2使用dock-compose"></a>2.2使用dock-compose</h5><blockquote><p>如果没有安装先进行安装<code>apt install docker-compose</code></p></blockquote><p>dock-compose用来管理多个container的运行，特别适合1个host上跑多个container的情况。</p><p>得天独厚，<a href="https://docs.docker.com/compose/gettingstarted/" target="_blank" rel="noopener">docker官网上dock-compose的gettingstarted文档</a>就是flask的(说明flask+docker代表了先进生产力的前进方向O Yeah！),看完了基本就能用了。</p><p>dock-compose采用yaml作为配置文件。查了一下，yaml参考了xml和json，以及python的语法，采用了python之缩进，无XML之标记，无json之括号，无字符串之引号。特别适合作为配置文件用。</p><p>建立docker-compose.yaml文件(无镜像,但有dockerfile)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos; # 表示该 Docker-Compose 文件使用的是 Version 2 file</span><br><span class="line">services:</span><br><span class="line">  docker-demo:  # 指定服务名称</span><br><span class="line">    build: .  # 指定 Dockerfile 所在路径</span><br><span class="line">    ports:    # 指定端口映射</span><br><span class="line">      - &quot;9000:8761&quot;</span><br></pre></td></tr></table></figure><p>建立docker-compose.yaml文件(已有镜像)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  quotation_api: # 指定服务名称</span><br><span class="line">    image: quotation_dev:latest  # 指定镜像</span><br><span class="line">    volumes:# 选择数据卷</span><br><span class="line">      - /home/quotation:/code</span><br><span class="line">    ports:# 端口映射</span><br><span class="line">      - &quot;5000:5000&quot;</span><br><span class="line">    command: python3 main.py# 执行命令</span><br></pre></td></tr></table></figure><p>基本对应手动敲的docker命令，最后还省了敲python3 main.py。</p><p>当然如果是部署，这句可以用CMD 写进Dockfile。但是开发过程，文件名之类的会改变，比如最终部署运行用可能是gunicorn+wsgi.py，所以还是写在dockerfile外面比较方便</p><p>运行，在控制台执行：<code>docker-compose up</code>、<code>docker-compose up -d  // 后台启动并运行容器</code></p><p><a href="https://www.jianshu.com/p/658911a8cff3" target="_blank" rel="noopener">docker-compose更多介绍</a></p><h3 id="坑点记录"><a href="#坑点记录" class="headerlink" title="坑点记录"></a>坑点记录</h3><h4 id="docker容器启动后马上退出解决方案"><a href="#docker容器启动后马上退出解决方案" class="headerlink" title="docker容器启动后马上退出解决方案"></a><strong>docker容器启动后马上退出解决方案</strong></h4><blockquote><p>dokcerfile中的最后一个命令不能在后台执行,不然会启动后马上退出</p></blockquote><p><strong>原因</strong></p><p>Docker容器同时只能管理一个进程，如果这个进程退出那么容器也就退出了，但这不表示容器只能运行一个进程(其他进程可在后台运行)，但是要使容器不退出必须有一个前台执行的进程。</p><p><strong>解决方法</strong>：</p><p>脚本中最后一个进程一定要用前台运行方式即在进程最后不加&amp;(&amp;表示后台运行)，否则容器会退出。</p><h4 id="如何正确的使用docker-attach"><a href="#如何正确的使用docker-attach" class="headerlink" title="如何正确的使用docker attach"></a><a href="http://dockone.io/question/399" target="_blank" rel="noopener">如何正确的使用docker attach</a></h4><p>Q:由于执行着<code>uwsgi --ini uwsig.ini</code>命令,用户就无法直接进入到容器中去，<code>docker attach CONTAINER_id</code> 就会一直卡着。</p><p>A: attach早已过时了，可用: <code>docker exec -it containerID /bin/bash</code>，一开始使用的是<code>/bin/sh</code>然后还是一直卡住.但是/bin/bash是可以的</p><h3 id="附Uuntu版本代号"><a href="#附Uuntu版本代号" class="headerlink" title="附Uuntu版本代号:"></a>附Uuntu版本代号:</h3><table><thead><tr><th>版本号</th><th>代号</th><th>发布时间</th></tr></thead><tbody><tr><td>18.04</td><td>Bionic Beaver（仿生海狸）</td><td>即将发布2018年4月(LTS)</td></tr><tr><td>17.10</td><td>Artful Aardvark(机灵的土豚)</td><td>2017年10月</td></tr><tr><td><strong>16.04 LTS</strong></td><td>Xenial Xerus <code>好客的非洲地松鼠</code></td><td>即将发布 2016/4</td></tr><tr><td>15.10</td><td>Wily Werewolf <code>狡诈的狼人</code></td><td>2015/10/22</td></tr><tr><td>15.04</td><td>Vivid Vervet <code>活泼的小猴</code></td><td>2015/04/23</td></tr><tr><td>14.10</td><td>Utopic Unicorn <code>乌托邦独角兽</code></td><td>2014/10/23</td></tr><tr><td><strong>14.04 LTS</strong></td><td>Trusty Tahr <code>值得信赖的塔尔羊</code></td><td>2014/04/18</td></tr><tr><td>13.10</td><td>Saucy Salamander <code>活泼的蝾螈</code></td><td>2013/10/17</td></tr><tr><td>13.04</td><td>Raring Ringtail <code>铆劲浣熊</code></td><td>2013/04/25</td></tr><tr><td>12.10</td><td>Quantal Quetzal <code>缤纷的绿咬鹃</code></td><td>2012/10/18</td></tr><tr><td><strong>12.04 LTS</strong></td><td>Precise Pangolin <code>精准的穿山甲</code></td><td>2012/04/26</td></tr><tr><td>11.10</td><td>Oneiric Ocelot <code>有梦的虎猫</code></td><td>2011/10/13</td></tr><tr><td>11.04 <code>Unity成为默认桌面环境</code></td><td>Natty Narwhal <code>敏捷的独角鲸</code></td><td>2011/04/28</td></tr><tr><td>10.10</td><td>Maverick Meerkat <code>标新立异的的狐獴</code></td><td>2010/10/10</td></tr><tr><td><strong>10.04 LTS</strong></td><td>Lucid Lynx <code>清醒的猞猁</code></td><td>2010/04/29</td></tr><tr><td>9.10</td><td>Karmic Koala <code>幸运的无尾熊</code></td><td>2009/10/29</td></tr><tr><td>9.04</td><td>Jaunty Jackalope <code>活泼的兔子</code></td><td>2009/04/23</td></tr><tr><td>8.10</td><td>Intrepid Ibex <code>无畏的高地山羊</code></td><td>2008/10/30</td></tr><tr><td>8.06 <code>官方查不到此版本发布信息</code></td><td>Haughty Husky <code>骄傲的哈士奇</code></td><td>2008/06/07</td></tr><tr><td><strong>8.04 LTS</strong></td><td>Hardy Heron <code>坚强的苍鹭</code></td><td>2008/04/24</td></tr><tr><td>7.10</td><td>Gutsy Gibbon <code>勇敢的长臂猿</code></td><td>2007/10/18</td></tr><tr><td>7.04</td><td>Feisty Fawn <code>烦躁不安的小鹿</code></td><td>2007/04/19</td></tr><tr><td>6.10</td><td>Edgy Eft <code>尖利的小蜥蜴</code></td><td>2006/10/26</td></tr><tr><td><strong>6.06 LTS</strong></td><td>Dapper Drake <code>整洁的公鸭</code></td><td>2006/06/01</td></tr><tr><td>5.10</td><td>Breezy Badger <code>活泼的獾</code></td><td>2005/10/13</td></tr><tr><td>5.04</td><td>Hoary Hedgehog <code>白发得刺猬</code></td><td>2005/04/08</td></tr><tr><td><strong>4.10 </strong><code>初始发布版本</code></td><td>Warty Warthog <code>多疣的疣猪</code></td><td>2004/10/20</td></tr></tbody></table><h3 id="docker-compose使用-转"><a href="#docker-compose使用-转" class="headerlink" title="docker-compose使用[转]"></a>docker-compose使用[转]</h3><h4 id="docker-compose常见命令"><a href="#docker-compose常见命令" class="headerlink" title="docker-compose常见命令"></a>docker-compose常见命令</h4><ul><li><strong>ps</strong>：列出所有运行容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><ul><li><strong>logs</strong>：查看服务日志输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs</span><br></pre></td></tr></table></figure><ul><li><strong>port</strong>：打印绑定的公共端口，下面命令可以输出 eureka 服务 8761 端口所绑定的公共端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose port eureka 8761</span><br></pre></td></tr></table></figure><ul><li><strong>build</strong>：构建或者重新构建服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br></pre></td></tr></table></figure><ul><li><strong>start</strong>：启动指定服务已存在的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose start eureka</span><br></pre></td></tr></table></figure><ul><li><strong>stop</strong>：停止已运行的服务的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop eureka</span><br></pre></td></tr></table></figure><ul><li><strong>rm</strong>：删除指定服务的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose rm eureka</span><br></pre></td></tr></table></figure><ul><li><strong>up</strong>：构建、启动容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><ul><li><strong>kill</strong>：通过发送 SIGKILL 信号来停止指定服务的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose kill eureka</span><br></pre></td></tr></table></figure><ul><li><strong>pull</strong>：下载服务镜像</li><li><strong>scale</strong>：设置指定服务运气容器的个数，以 service=num 形式指定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose scale user=3 movie=3</span><br></pre></td></tr></table></figure><ul><li><strong>run</strong>：在一个服务上执行一个命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run web bash</span><br></pre></td></tr></table></figure><p>### </p><h4 id="docker-compose-yml-字段含义"><a href="#docker-compose-yml-字段含义" class="headerlink" title="docker-compose.yml 字段含义"></a>docker-compose.yml 字段含义</h4><ul><li><strong>version</strong>：指定 docker-compose.yml 文件的写法格式</li><li><strong>services</strong>：多个容器集合</li><li><strong>build</strong>：配置构建时，Compose 会利用它自动构建镜像，该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">build: ./dir</span><br><span class="line">---------------</span><br><span class="line">build:</span><br><span class="line">    context: ./dir</span><br><span class="line">    dockerfile: Dockerfile</span><br><span class="line">    args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure><ul><li><strong>command</strong>：覆盖容器启动后默认执行的命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command: bundle exec thin -p 3000</span><br><span class="line">----------------------------------</span><br><span class="line">command: [bundle,exec,thin,-p,3000]</span><br></pre></td></tr></table></figure><ul><li><strong>dns</strong>：配置 dns 服务器，可以是一个值或列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line">------------</span><br><span class="line">dns:</span><br><span class="line">    - 8.8.8.8</span><br><span class="line">    - 9.9.9.9</span><br></pre></td></tr></table></figure><ul><li><strong>dns_search</strong>：配置 DNS 搜索域，可以是一个值或列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line">------------------------</span><br><span class="line">dns_search:</span><br><span class="line">    - dc1.example.com</span><br><span class="line">    - dc2.example.com</span><br></pre></td></tr></table></figure><ul><li><strong>environment</strong>：环境变量配置，可以用数组或字典两种方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">    RACK_ENV: development</span><br><span class="line">    SHOW: &apos;ture&apos;</span><br><span class="line">-------------------------</span><br><span class="line">environment:</span><br><span class="line">    - RACK_ENV=development</span><br><span class="line">    - SHOW=ture</span><br></pre></td></tr></table></figure><ul><li><strong>env_file</strong>：从文件中获取环境变量，可以指定一个文件路径或路径列表，其优先级低于 environment 指定的环境变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line">---------------</span><br><span class="line">env_file:</span><br><span class="line">    - ./common.env</span><br></pre></td></tr></table></figure><ul><li><strong>expose</strong>：暴露端口，只将端口暴露给连接的服务，而不暴露给主机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line">    - &quot;3000&quot;</span><br><span class="line">    - &quot;8000&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>image</strong>：指定服务所使用的镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: java</span><br></pre></td></tr></table></figure><ul><li><strong>network_mode</strong>：设置网络模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name/id]&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>ports</strong>：对外暴露的端口定义，和 expose 对应</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ports:   # 暴露端口信息  - &quot;宿主机端口:容器暴露端口&quot;</span><br><span class="line">- &quot;8763:8763&quot;</span><br><span class="line">- &quot;8763:8763&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>links</strong>：将指定容器连接到当前连接，可以设置别名，避免ip方式导致的容器重启动态改变的无法连接情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">links:    # 指定服务名称:别名 </span><br><span class="line">    - docker-compose-eureka-server:compose-eureka</span><br></pre></td></tr></table></figure><ul><li><strong>volumes</strong>：卷挂载路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - /lib</span><br><span class="line">  - /var</span><br></pre></td></tr></table></figure><ul><li><strong>logs</strong>：日志输出信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--no-color          单色输出，不显示其他颜.</span><br><span class="line">-f, --follow        跟踪日志输出，就是可以实时查看日志</span><br><span class="line">-t, --timestamps    显示时间戳</span><br><span class="line">--tail              从日志的结尾显示，--tail=200</span><br></pre></td></tr></table></figure><h4 id="更新容器"><a href="#更新容器" class="headerlink" title="更新容器"></a>更新容器</h4><ul><li>当服务的配置发生更改时，可使用 docker-compose up 命令更新配置</li><li>此时，Compose 会删除旧容器并创建新容器，新容器会以不同的 IP 地址加入网络，名称保持不变，任何指向旧容起的连接都会被关闭，重新找到新容器并连接上去</li></ul><h4 id="links"><a href="#links" class="headerlink" title="links"></a>links</h4><ul><li>服务之间可以使用服务名称相互访问，links 允许定义一个别名，从而使用该别名访问其它服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">    web:</span><br><span class="line">        build: .</span><br><span class="line">        links:</span><br><span class="line">            - &quot;db:database&quot;</span><br><span class="line">    db:</span><br><span class="line">        image: postgres</span><br></pre></td></tr></table></figure><ul><li>这样 Web 服务就可以使用 db 或 database 作为 hostname 访问 db 服务了</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker学习&quot;&gt;&lt;a href=&quot;#Docker学习&quot; class=&quot;headerlink&quot; title=&quot;Docker学习&quot;&gt;&lt;/a&gt;Docker学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;轻部署,省成本,易迁移&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="自动化运维" scheme="https://nymrli.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Python中的正则匹配</title>
    <link href="https://nymrli.top/2019/07/25/Python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"/>
    <id>https://nymrli.top/2019/07/25/Python中的正则匹配/</id>
    <published>2019-07-25T01:50:19.000Z</published>
    <updated>2019-07-25T01:59:58.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的正则匹配"><a href="#Python中的正则匹配" class="headerlink" title="Python中的正则匹配"></a>Python中的正则匹配</h1><blockquote><p>虽然正则早就会用了,但是有些使用方法老是忘记,因此还是写篇记录一下</p></blockquote><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table><thead><tr><th style="text-align:left">特别字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。</td></tr><tr><td style="text-align:left">( )</td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。要匹配 <em> 字符，请使用 \</em>。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td></tr><tr><td style="text-align:left">.</td><td style="text-align:left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。</td></tr><tr><td style="text-align:left">{</td><td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用 {。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left"></td><td>指明两项之间的一个选择。要匹配 \</td><td>，请使用 \</td><td>。</td></tr></tbody></table><hr><h2 id="特殊字符-1"><a href="#特殊字符-1" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <strong>runoo*b</strong> 中的 <strong>*</strong>，简单的说就是表示任何字符串的意思。如果要查找字符串中的 <strong>*</strong> 符号，则需要对 <strong>*</strong> 进行转义，即在其前加一个 <strong>\</strong>: <strong>runo*ob</strong> 匹配 runo*ob。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符<strong>\</strong> 放在它们前面。下表列出了正则表达式中的特殊字符：</p><table><thead><tr><th style="text-align:left">特别字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。</td></tr><tr><td style="text-align:left">( )</td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。要匹配 <em> 字符，请使用 \</em>。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td></tr><tr><td style="text-align:left">.</td><td style="text-align:left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。</td></tr><tr><td style="text-align:left">{</td><td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用 {。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left"></td><td>指明两项之间的一个选择。要匹配 \</td><td>，请使用 \</td><td>。</td></tr></tbody></table><hr><p><strong>*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。</strong></p><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 <strong>*</strong> 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td style="text-align:left">{n}</td><td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td style="text-align:left">{n,}</td><td style="text-align:left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td style="text-align:left">{n,m}</td><td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>定位符用来描述字符串或单词的边界，<strong>^</strong> 和 <strong>$</strong> 分别指字符串的开始与结束，<strong>\b</strong> 描述单词的前或后边界，<strong>\B</strong> 表示非单词边界。</p><p>正则表达式的定位符有：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td style="text-align:left">\B</td><td style="text-align:left">非单词边界匹配。</td></tr></tbody></table><h2 id="捕获与非捕获"><a href="#捕获与非捕获" class="headerlink" title="捕获与非捕获"></a>捕获与非捕获</h2><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。</p><p>其中 <strong>?:</strong> 是非捕获元之一，还有两个非捕获元是 <strong>?=</strong> 和 <strong>?!</strong>，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p><hr><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <strong>\n</strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p><p>可以使用非捕获元字符 <strong>?:</strong>、<strong>?=</strong> 或 <strong>?!</strong> 来重写捕获，忽略对相关匹配的保存。</p><p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：</p><h2 id="正则-lt-和-用法-https-www-cnblogs-com-whaozl-p-5462865-html"><a href="#正则-lt-和-用法-https-www-cnblogs-com-whaozl-p-5462865-html" class="headerlink" title="正则 ?&lt;= 和 ?= 用法](https://www.cnblogs.com/whaozl/p/5462865.html)"></a>正则 ?&lt;= 和 ?= 用法](<a href="https://www.cnblogs.com/whaozl/p/5462865.html" target="_blank" rel="noopener">https://www.cnblogs.com/whaozl/p/5462865.html</a>)</h2><p><strong>方法1： 匹配，捕获(存储)</strong></p><p>正则表达式：(?&lt;=(href=”)).{1,200}(?=(“&gt;))</p><p>解释：</p><p>(?&lt;=(href=”)) 表示 <strong>匹配</strong>以(href=”)<strong>开头</strong>的字符串，并且<strong>捕获(存储)</strong>到分组中</p><p>(?=(“&gt;)) 表示 <strong>匹配</strong>以(“&gt;)<strong>结尾</strong>的字符串，并且<strong>捕获(存储)</strong>到分组中</p><p><strong>方法2： 匹配，不捕获(不存储)</strong></p><p> 正则表达式：(?&lt;=(<strong>?:</strong>href=”)).{1,200}(?=(<strong>?:</strong>“&gt;))</p><p>​       解释：(?&lt;=(<strong>?:</strong>href=”)) 表示 <strong>匹配</strong>以(href=”)<strong>开头</strong>的字符串，并且<strong>不捕获(不存储)</strong>到分组中</p><p>​               (?=(<strong>?:</strong>“&gt;)) 表示 <strong>匹配</strong>以(“&gt;)<strong>结尾</strong>的字符串，并且<strong>不捕获(不存储)</strong>到分组中</p><table><thead><tr><th>(?:pattern)</th><th>非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(\</th><th>)”来组合一个模式的各个部分是很有用。例如“industr(?:y\</th><th>ies)”就是一个比“industry\</th><th>industries”更简略的表达式。</th></tr></thead><tbody><tr><td>(?=pattern)</td><td>非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95\</td><td>98\</td><td>NT\</td><td>2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95\</td><td>98\</td><td>NT\</td><td>2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。</td></tr><tr><td>(?&lt;=pattern)</td><td>非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95\</td><td>98\</td><td>NT\</td><td>2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td></tr><tr><td>(?&lt;!pattern)</td><td>非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95\</td><td>98\</td><td>NT\</td><td>2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题</td></tr></tbody></table><p> <strong>分组语法 捕获</strong><br><strong>(exp)</strong> 匹配exp,并捕获文本到自动命名的组里<br><strong>(?<name>exp)</name></strong> 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)<br><strong>(?:exp)</strong> 匹配exp,不捕获匹配的文本<br><strong>位置指定</strong><br><strong>(?=exp)</strong> 匹配exp前面的位置<br><strong>(?&lt;=exp)</strong> 匹配exp后面的位置<br><strong>(?!exp)</strong> 匹配后面跟的不是exp的位置<br><strong>(?&lt;!exp)</strong> 匹配前面不是exp的位置<br><strong>注释</strong><br><strong>(?#comment)</strong> 这种类型的组不对正则表达式的处理产生任何影响，只是为了提供让人阅读注释</p><p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面。</p><p><strong>位置指定</strong><br>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们用于指定一个位置，就像\b,^,$那样，因此它们也被称为零宽断言。最好还是拿例子来说明吧：</p><p>(?=exp)也叫零宽先行断言，它匹配文本中的某些位置，这些位置的后面能匹配给定的后缀exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如果在查找I’m singing while you’re dancing.时，它会匹配sing和danc。</p><p>(?&lt;=exp)也叫零宽后行断言，它匹配文本中的某些位置，这些位置的前面能给定的前缀匹配exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。</p><p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})*\b。请仔细分析这个表达式，它可能不像你第一眼看出来的那么简单。</p><p>下面这个例子同时使用了前缀和后缀：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><h3 id="常见正则表达式"><a href="#常见正则表达式" class="headerlink" title="常见正则表达式"></a>常见正则表达式</h3><ul><li><p>Email地址：^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$ </p></li><li><p>域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? </p></li><li><p>InternetURL：[a-zA-z]+://[^\s]<em> 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]</em>)?$ </p></li><li><p>手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ </p></li><li><p>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$  </p></li><li><p>身份证号(15位、18位数字)：^\d{15}|\d{18}$ </p></li><li><p>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</p></li><li><p>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$</p></li><li><p>日期格式：^\d{4}-\d{1,2}-\d{1,2}</p></li><li><p>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</p></li><li><p>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python中的正则匹配&quot;&gt;&lt;a href=&quot;#Python中的正则匹配&quot; class=&quot;headerlink&quot; title=&quot;Python中的正则匹配&quot;&gt;&lt;/a&gt;Python中的正则匹配&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;虽然正则早就会用了,但是有些使用方
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>利用wireshark抓取TCP的整个过程分析[转]</title>
    <link href="https://nymrli.top/2019/07/24/%E5%88%A9%E7%94%A8wireshark%E6%8A%93%E5%8F%96TCP%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://nymrli.top/2019/07/24/利用wireshark抓取TCP的整个过程分析/</id>
    <published>2019-07-24T07:51:29.000Z</published>
    <updated>2019-07-25T01:50:26.413Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://www.cnblogs.com/NickQ/p/9226579.html" target="_blank" rel="noopener">https://www.cnblogs.com/NickQ/p/9226579.html</a> </p><p>最近，已经很久都没有更新博客了。看看时间，想想自己做了哪些事情，突然发现自己真的是太贪心，到头来却一个都没搞好。手头的嵌入式都还没学出名堂，竟然还想着学FPGA,物联网，机器学习。然而，遇到新奇的事物，就会控制不住的去想，去找资料，实际上只是逃避遇到的问题，不想去解决而已。。最后的结果就是手头的活堆起来了，然后花大把整块的时间解决。真的是讨厌现在的自己。</p><p>以后还是慢慢记录吧，不管做了什么，都慢慢尝试积累。。其他的东西，像FPGA，机器学习什么的，让他随风去吧，用到啥学啥。其他的当看客，了解了解就好。</p><p>这是计算机网络的一次作业，学习抓取TCP/IP建立连接和断开连接的过程，以下是正文：</p><p><strong>步骤：</strong></p><p>首先尝试抓百度，腾讯等网络连接，发现会有许多问题需要考虑，断开连接操作不好操作，且数据冗杂不利于学习。</p><p><img src="https://images2018.cnblogs.com/blog/1249999/201806/1249999-20180625223300726-249267524.png" alt="img"></p><p>所以借助手机和电脑完成此次过程，操作如下：</p><p>1、在手机端，安装TCP测试工具，开启TCP监听，端口8088；</p><p><img src="https://images2018.cnblogs.com/blog/1249999/201806/1249999-20180625221400357-2132003606.jpg" alt="img"></p><p>2、打开wireshark监听WIFI网卡。</p><p>3、打开电脑端TCP测试客户端，连接TCP服务器。</p><p>此处，我的手机IP为192.168.255.5，端口8088；电脑的IP地址为192.168.255.6。</p><p>4、通过电脑客户端，发送两次信息到手机。</p><p>5、通过手机客户端，发送两次信息到电脑。</p><p>6、断开连接。</p><p>7、通过ip.addr eq 192.168.255.5 and ip.addr eq 192.168.255.6 and tcp过滤掉其他报文。</p><p>至于wireshark过滤的语法，可以参考其他的一些博文：<a href="https://blog.csdn.net/wojiaopanpan/article/details/69944970" target="_blank" rel="noopener">https://blog.csdn.net/wojiaopanpan/article/details/69944970</a></p><p><strong>协议及过程分析：</strong></p><p>TCP三次握手：如下图中蓝色方框所示。</p><p>TCP握手协议在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p><p>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；如下图中报文No.7</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；如下图中报文No.8</p><p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据。如下图中报文No.9</p><p><img src="https://images2018.cnblogs.com/blog/1249999/201806/1249999-20180625221206712-792100790.png" alt="img"></p><p>TCP四次挥手：如上图中红色方框所示。</p><p>注：此处，由于先断开的服务器，所以手机服务器是客户端A。</p><p>第一次挥手：客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</p><p>如图中报文No.255</p><p>第二次挥手：服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。如图中报文No.256</p><p>第三次挥手：服务器B关闭与客户端A的连接，发送一个FIN给客户端A。如图中报文No.257</p><p>第四次挥手：客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。如图中报文No.258</p><p><strong>其他:</strong></p><p>下图是其中一帧数据解析，可以看到数据是由192.168.255.6:62643(电脑客户端)发送给192.168.255.5:8088(手机服务端）。</p><p>消息内容为：201521111083</p><p><img src="https://images2018.cnblogs.com/blog/1249999/201806/1249999-20180625223511076-53478793.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/NickQ/p/9226579.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/NickQ/p/9226579.html&lt;/
      
    
    </summary>
    
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="https://nymrli.top/2019/07/13/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2019/07/13/C-学习笔记/</id>
    <published>2019-07-13T01:00:50.000Z</published>
    <updated>2019-07-13T01:01:29.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-学习笔记"><a href="#C-学习笔记" class="headerlink" title="C++学习笔记"></a>C++学习笔记</h1><blockquote><p>system（）就是调用（DOS）系统命令（和shell命令）。<br>pause ，即DOS命令集合中的暂停命令；</p></blockquote><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main( void )</span><br><span class="line">&#123;</span><br><span class="line">  char  buffer[200], s[] = &quot;computer&quot;, c = &apos;l&apos;;</span><br><span class="line">  int   i = 35, j;</span><br><span class="line">  float fp = 1.7320534f;  // 格式化并打印各种数据到buffer</span><br><span class="line">  j  = sprintf( buffer,    &quot;   String:    %s\n&quot;, s ); // C4996</span><br><span class="line">  j += sprintf( buffer + j,&quot;   Character: %c\n&quot;, c );</span><br><span class="line">  j += sprintf( buffer + j,&quot;   Integer:   %d\n&quot;, i );</span><br><span class="line">  j += sprintf( buffer + j,&quot;   Real:      %f\n&quot;, fp );</span><br><span class="line">  printf( &quot;Output:\n%s\ncharacter count = %d\n&quot;, buffer, j );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>返回写入buffer 的字符数，出错则返回-1. 如果 buffer 或 format 是空指针，且不出错而继续，函数将返回-1</li><li>sprintf 返回以format为格式argument为内容组成的结果被写入buffer 的字节数，结束字符‘\0’不计入内。即，如果“Hello”被写入空间足够大的buffer后，函数sprintf 返回5。</li></ul></blockquote><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>声明引用：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int &amp;c=a;  //int &amp; c=a;   △.声明引用时必须初始化</span><br></pre></td></tr></table></figure><p><strong>传引用参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func(int&amp; a)&#123;&#125; //函数名(xxx)xxx其实是创建形参变量的过程</span><br><span class="line">func(b);</span><br></pre></td></tr></table></figure><p><strong>传指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void func2(int *a)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>返回引用</strong></p><p>返回值不能是局部变量（局部变量在生命期结束后会被销毁）<br>​    （c中生命周期结束后，立马销毁，而在python中垃圾回收机制会在判断之后不使用的情况下再销毁）<br>func2(&amp;b);</p><h2 id="增强的for循环"><a href="#增强的for循环" class="headerlink" title="增强的for循环:"></a>增强的for循环:</h2><blockquote><p>在vc6.0中 for(int i=4;i&gt;0;i–)  i的作用域为　整个外部作用域如<br>void main()<br>{<br>​    for(int i=4;i&gt;0;i–) //作用域为整个main函数<br>}<br>   而在vs中 for(int i=4;i&gt;0;i–)  i的作用域为　该个for循环内<br>void main()<br>{<br>​    for(int i=4;i&gt;0;i–) //作用域为该个for循环<br>}</p></blockquote><hr><p>默认参数　从右往左连续</p><p>返回值不是函数重载的条件</p><hr><blockquote><p>malloc和free　不会触发构造函数或是析构函数<br>new和delete　可以</p></blockquote><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote><p>不做特别说明，类的数据成员和成员函数都被认为是private</p></blockquote><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><ul><li>this 是类成员函数的隐含参数，不是类的数据成员</li><li>静态成员无this指针</li></ul><h2 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h2><ul><li><p>常函数不能修改类中的数据成员的值</p></li><li><p>析构函数和构造函数不能是常函数</p></li><li>常变量只能调用常函数，不能调用普通函数</li><li>常对象只能调用常函数，不能调用普通函数</li></ul><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><ul><li>是类本身的属性，无对象时也可以直接调用Cstu::sta</li><li>静态成员函数只能调用静态数据成员<br>类外初始化　不需要static关键字 如： int Cstu::sta = 12;</li></ul><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = new int[2];</span><br><span class="line">delete[] a;</span><br></pre></td></tr></table></figure><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><ul><li>系统默认的为浅拷贝</li><li>有指针承运啊时得内存拷贝，所以使用深拷贝，</li><li>为了避免拷贝构造，运算符重载应该传引用</li></ul><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p><strong>何时会调用</strong></p><blockquote><p>1.新建一个对象，并将其初始化为同类现有对象</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cstu a;</span><br><span class="line">- Cstu a1(a);</span><br><span class="line">- Cstu a2 = a;</span><br><span class="line">- Cstu a3 = Cstu(a);　//创建了临时对象</span><br><span class="line">- Cstu a4 = new Cstu(a);</span><br><span class="line">- △.赋值并不会发生拷贝构造</span><br></pre></td></tr></table></figure><blockquote><p>2.当程序生成对象副本时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 参数是本类的常引用Cstu(const Cstu&amp;)</span><br><span class="line"></span><br><span class="line">- 普通构造函数如果空的话是不执行内容的，拷贝构造空的话是执行内容的</span><br><span class="line">- 默认的复制构造函数，逐个复制非静态成员的值，</span><br><span class="line"></span><br><span class="line">## 内联函数inline</span><br><span class="line"></span><br><span class="line">- 函数代码少，流程直接，调用频繁，如循环</span><br><span class="line">- 类内定义的都是内联函数（隐式），写inline为显性</span><br><span class="line">- 内联函数的定义一般写在头文件内</span><br><span class="line"></span><br><span class="line">- 只在声明位置写inline不管用，定义与声明都要有inline关键字</span><br><span class="line">- 空间换时间，使用频率低时速度快，频率高时，比较占用内存，主要看性价比</span><br><span class="line">- 递归不能是内联函数</span><br><span class="line"></span><br><span class="line">## 操作符重载</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 为了避免拷贝构造，运算符重载应该传引用或是传地址</span><br><span class="line">- 操作符重载必须有一个类类型的参数</span><br><span class="line">- =、[]、()、-&gt;必须是诚邀</span><br><span class="line">- 复合赋值运算符通常是成员</span><br><span class="line">- 改变对象状态的运算符，递增、解引用，通常是成员</span><br><span class="line"></span><br><span class="line">### 输出运算符重载:</span><br><span class="line"></span><br><span class="line">- 参数1是ostream引用，参数2是对象的常引用</span><br><span class="line">- 必须是类外重载，原因为1</span><br><span class="line">- 输出私有成员时，要用友元</span><br></pre></td></tr></table></figure></p></blockquote><p>void operator &lt;&lt; (ostream&amp; os,const &amp;Csty)，os &lt;&lt;st.nAge;<br>ostream&amp; operator &lt;&lt; (ostream&amp; os,const &amp;Csty)，os &lt;&lt;st.nAge;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 输入运算符重载:</span><br><span class="line"></span><br><span class="line">- 参数不匹配用ist.fail()检测</span><br><span class="line">- 输出=&gt;  ist&gt;&gt;st.nAge &gt;&gt; st.dbHeight;</span><br></pre></td></tr></table></figure></p><p>istream&amp; operator &gt;&gt;(istream&amp; ist,CStu&amp; st)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 前置+ +与后置+ +重载</span><br></pre></td></tr></table></figure></p><p>int operator++(Cstu* st){} =&gt;前置++</p><p>int operator++(Cstu* st,int n) =&gt;后置++<br>{<br>    int a =st.nage;<br>    st.nage +=1;<br>    return a;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">类型转换重载</span><br></pre></td></tr></table></figure></p><p>operator int()const{}            //无返回值，但有return </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">△.必须在类内。▲.const</span><br><span class="line"></span><br><span class="line">## 模板</span><br></pre></td></tr></table></figure><p>template <typename y=""><br>void func(Y a) cout &lt;&lt; a　&lt;&lt; endl;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">模板的具体化:</span><br></pre></td></tr></table></figure></typename></p><p>temlpate &lt;&gt; void func<node>(Node&amp; a){}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 模板具体化的执行优先级高于通用的优先级，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">◇.注意，STL头文件没有扩展名.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"># CPP</span><br><span class="line"></span><br><span class="line">```该类接受2个参数</span><br><span class="line">初始化列表</span><br><span class="line">class CStu</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int arr[4];</span><br><span class="line">    float b;</span><br><span class="line">//构造函数： </span><br><span class="line">CStu(*float c,int d*):a(2),b(2.2f),arr()    #成员初始化顺序只与声明顺序有关，与此处书写顺序无关</span><br><span class="line">    &#123;#新增语法，arr数组全初始化为0</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></node></p><p>▲.类必须先初始化成员变量。</p><p>​    。float c和int d 两个变量的作用域仅限于构造函数内.所以要想在整个类中使用该变量，就得将传入的参数初始化赋值给类中的变量。</p><p>​    若有多个构造函数，会执行初始化列表绑定所在的构造函数（构造函数的重载）</p><blockquote><p>数组的赋值：</p><blockquote><ul><li>初始化列表arr()</li><li>构造函数中for循环赋值</li><li>memset(&amp;arr[0],0,16)</li></ul></blockquote></blockquote><p>△.析构函数没有重载，且不接受参数。对象声明调用周期结束时自动调用。</p><p>▲构造函数和析构函数都必须写在public访问控制符下</p><hr><h2 id="malloc和new、free和delete区别"><a href="#malloc和new、free和delete区别" class="headerlink" title="malloc和new、free和delete区别"></a>malloc和new、free和delete区别</h2><ul><li>malloc不会触发构造函数，new可以</li><li>free不会触发析构函数，delete可以</li></ul><hr><h2 id="This指针"><a href="#This指针" class="headerlink" title="This指针"></a>This指针</h2><p>指针类型为类的类型。</p><p>this不是类的成员。</p><p>this指针为成员函数的隐含参数，相当于python类中的self…..(所以this指针的作用域为类内部)</p><hr><h2 id="常函数-1"><a href="#常函数-1" class="headerlink" title="常函数"></a>常函数</h2><figure class="highlight plain"><figcaption><span>CStu&#123;&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CStu</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    void show() const  #在括号之后</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>◆.析构函数、构造函数不能是常函数</p><p>◆.常函数不能修改数据成员（是类的），但可以修改常函数内的变量。</p><p>▲常函数的this指针的类型为const CStu*</p><p>★常对象(const CStu st)只能调用常函数，不能调用普通函数</p><hr><h2 id="静态成员-1"><a href="#静态成员-1" class="headerlink" title="静态成员"></a>静态成员</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CStu</span><br><span class="line">&#123;</span><br><span class="line">static int b;</span><br><span class="line">    public:</span><br><span class="line">    void show() const  #在括号之后</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>∷不能在构造函数的初始化列表中初始化，但可以类外初始化</p><p>∷类外初始化不用加static，而是int CStu::b = 12;</p><p>▲static受访问控制符约束。</p><p>调用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名作用域：cout&lt;&lt; CStu::b &lt;&lt; endl;</span><br><span class="line">对象：</span><br></pre></td></tr></table></figure><p>○只有静态常量整型数据才能直接在类中初始化，其他得在初始化列表或者构造函数中赋值（静态数据成员可以类外赋值），普通数据成员不能类外初始化。</p><p>●静态成员是跟类一一对应的，跟对象无关。</p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><blockquote><p>他是属于类的属性，不是对象的，即同一个类的所有对象共有一个（可以作为指挥类所有对象的方法）</p><p>无this指针</p><p>不能调用普通成员，只能调用静态成员</p></blockquote><hr><h2 id="拷贝构造-1"><a href="#拷贝构造-1" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><blockquote><p>public:</p><p>​    Cstu(const Cstu &amp;a){} 形式。参数是本类的常引用</p></blockquote><p>何时调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.新建一个对象，并将其初始化为同类时：</span><br><span class="line">- Cstu a1(a);#a为一个Cstu对象</span><br><span class="line">- Cstu a2 = a;  将不会再触发构造函数。</span><br><span class="line">- Cstu a3 = Cstu(a);   用a来拷贝构造一个临时对象，再用这个临时对象给a3</span><br><span class="line">- Cstu* a4 = new Cstu(a);</span><br><span class="line">2.当程序生成对象副本时：</span><br><span class="line">函数参数传递对象的值void fun(Cstu a)&#123;&#125;   （∵当调用这个函数的时候会为这个形参生成空间）</span><br><span class="line">▲有时为了效率要避免这种拷贝构造的产生，解决：传引用</span><br><span class="line">函数返回值 Cstu fun()&#123; Cstu a; return a;&#125; 返回值为创建了临时对象承接，然后再把临时变量返回。</span><br></pre></td></tr></table></figure><p>赋值不会调用：</p><blockquote><p>Cstu s1;</p><p>Cstu s2;</p><p>s2 = s1;</p></blockquote><h3 id="默认拷贝构造（浅拷贝）"><a href="#默认拷贝构造（浅拷贝）" class="headerlink" title="默认拷贝构造（浅拷贝）"></a>默认拷贝构造（浅拷贝）</h3><blockquote><p>逐个赋值非静态成员，（即默认拷贝构造中是有内容的，默认的构造函数是没有内容的）</p><p>内存排布一样，地址不同</p></blockquote><h3 id="深拷贝-涉及类中有指针"><a href="#深拷贝-涉及类中有指针" class="headerlink" title="深拷贝(涉及类中有指针)"></a>深拷贝(涉及类中有指针)</h3><p>如果是浅拷贝，则两个对象的指针都会指向同一个空间，如果第一个对象被消除后，这个空间就会被delete（free掉），所以第二个对象被删除时再操作（free）这个被释放掉的空间（已经还给系统），就相当于控制野指针，所以会报错。</p><p>解决方法1深拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this-&gt;a = new int[2];</span><br><span class="line">memcpy(this-&gt;a,b.a,8);</span><br><span class="line">strcpy(...)</span><br></pre></td></tr></table></figure><p>解决方法2传引用（不经过拷贝构造）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cstu&amp; fun(CStu&amp; a)</span><br><span class="line">&#123;return a;&#125;</span><br><span class="line">fun(a);</span><br></pre></td></tr></table></figure><p>解决方法3传地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cstu* fun(CStu* a)</span><br><span class="line">&#123;return a;&#125;</span><br><span class="line">fun(&amp;a);</span><br></pre></td></tr></table></figure><hr><h2 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h2><p>常规函数的调用过程：调用时，根据函数地址，跳到函数代码空间，执行指令，执行完再跳转到调用的位置。</p><p>内联函数：将函数代码直接复制到执行部分，不跳转。</p><blockquote><p>比常规函数稍快</p><p>占用更多内存（增加代码长度）</p></blockquote><p>▲声明和定义都要加inline 关键字</p><p>▲递归不能是内联函数</p><p>△.函数代码少时、调用频繁（for循环里）大多用内联函数（常规函数的话，跳转所耗时间占比就大）</p><p>▲.类内定义的函数都是内联函数，但如果定义在类外的话加inline为内联函数，不加就不是内联函数。</p><p>△.内联函数通常定义在头文件里。</p><hr><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>operator为关键字</p><p>“operator+”必须有一个类类型的形参；</p><hr><h2 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h2><blockquote><p>继承控制符：</p><p>public 父类：父类为什么访问控制符，子类就继承什么样的。</p><p>protected 父类:继承之后，父类的public降级为protected，低级或者同级的访问控制符不变（即protectedh和private)</p><p>private 父类：继承之后，父类全变为私有。</p></blockquote><h2 id="多态和虚函数"><a href="#多态和虚函数" class="headerlink" title="多态和虚函数"></a>多态和虚函数</h2><h3 id="多态：同样的调用有多种结果"><a href="#多态：同样的调用有多种结果" class="headerlink" title="多态：同样的调用有多种结果"></a>多态：同样的调用有多种结果</h3><p>通过虚函数调用子类的成员函数，形式为virtual void Show(){}  (函数名与子类相同)</p><blockquote><p>具体执行那个子类的函数由父类所指向的子类所决定. CFather* fa = new CSon1;</p></blockquote><hr><p>C++中声明结构体变量不需要‘struct’，struct默认为public,class 默认为private</p><p>c静态变量在预处理时声明。</p><p>cpp静态成员在类声明时声明。</p><h2 id="STL初始化"><a href="#STL初始化" class="headerlink" title="STL初始化"></a>STL初始化</h2><hr><ul><li><p>(1): vector<int> v;</int></p><blockquote><p>默认初始化，vector为空， size为0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。</p></blockquote></li><li><p>(2): vector<int> v2(v);</int></p><p>vector<int> v2= v; </int></p><blockquote><p>两种方式等价 ，ilist2 初始化为ilist 的拷贝，ilist必须与ilist2 类型相同，也就是同为int的vector类型，ilist2将具有和ilist相同的容量和元素</p></blockquote></li><li><p>(3): vector<int> ilist = {1,2,3.0,4,5,6,7};</int></p><p>vector<int> ilist {1,2,3.0,4,5,6,7};</int></p></li></ul><blockquote><p>初始化为列表中元素的拷贝，列表中元素必须与ilist的元素类型相容 </p></blockquote><ul><li><p>(4): vector<int> ilist3(ilist.begin()+2,ilist.end()-1); </int></p><blockquote><p>初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与ilist3 的元素类型相容 </p></blockquote></li><li><p>(5): vector<int> ilist4(7); </int></p><blockquote><p>默认值初始化，ilist4中将包含7个元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0， </p></blockquote></li><li><p>(6):vector<int> ilist5(7,3); </int></p><blockquote><p>指定值初始化，ilist5被初始化为包含7个值为3的int </p></blockquote></li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; idxs中</span><br><span class="line">for(int i : idxs)  ====&gt; for i in indx ..... i 为idxs中元素</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-学习笔记&quot;&gt;&lt;a href=&quot;#C-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;C++学习笔记&quot;&gt;&lt;/a&gt;C++学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;system（）就是调用（DOS）系统命令（和shell命令）。&lt;br&gt;pau
      
    
    </summary>
    
    
      <category term="C++" scheme="https://nymrli.top/tags/C/"/>
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>通过XDRP实现Windows远程访问ubuntu桌面</title>
    <link href="https://nymrli.top/2019/07/13/%E9%80%9A%E8%BF%87XDRP%E5%AE%9E%E7%8E%B0Windows%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEubuntu%E6%A1%8C%E9%9D%A2/"/>
    <id>https://nymrli.top/2019/07/13/通过XDRP实现Windows远程访问ubuntu桌面/</id>
    <published>2019-07-13T00:57:05.000Z</published>
    <updated>2019-07-13T00:57:31.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过XDRP实现Windows远程访问"><a href="#通过XDRP实现Windows远程访问" class="headerlink" title="通过XDRP实现Windows远程访问"></a>通过XDRP实现Windows远程访问</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装xrdp </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install xrdp </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装vnc4server </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install vnc4server tightvncserver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装xubuntu-desktop </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install xubuntu-desktop </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">向xsession中写入xfce4-session </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> “xfce4-session” &gt;~/.xsession </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">开启xrdp服务 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service xrdp restart</span></span><br></pre></td></tr></table></figure><p>上面是网上大多数示例所展示的，都是依靠第三方桌面系统实现远程访问，下面讲解的是如何直接访问原生系统。</p><h3 id="步骤一、下载TigerVNC-Server软件包"><a href="#步骤一、下载TigerVNC-Server软件包" class="headerlink" title="步骤一、下载TigerVNC Server软件包"></a>步骤一、下载TigerVNC Server软件包</h3><p>　　下载地址：<a href="http://www.c-nergy.be/downloads/tigervncserver_1.6.80-4_amd64.zip" target="_blank" rel="noopener">Tigervnc Deb软件包（适用于Ubuntu 16.04.1 - 64位）</a></p><h3 id="步骤二、-安装TigerVNC-Server软件包"><a href="#步骤二、-安装TigerVNC-Server软件包" class="headerlink" title="步骤二、 安装TigerVNC Server软件包"></a>步骤二、 安装TigerVNC Server软件包</h3><p>1、打开终端，进入到刚刚你你下载TigerVNC Server的存放目录，我是直接下载到默认的DownLoads下的，因为下载的是zip文件，记得解压出来，得到deb安装文件。</p><p>2、再输入一下安装命令进行安装（需要su密码）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install -f</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i tigervncserver_1.6.80-4_amd64.deb</span></span><br></pre></td></tr></table></figure><h3 id="步骤三、安装xrdp"><a href="#步骤三、安装xrdp" class="headerlink" title="步骤三、安装xrdp"></a>步骤三、安装xrdp</h3><p>　　打开终端，输入一下命令（需要su密码）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xrdp -y</span><br></pre></td></tr></table></figure><h3 id="步骤四、配置xrdp设置"><a href="#步骤四、配置xrdp设置" class="headerlink" title="步骤四、配置xrdp设置"></a>步骤四、配置xrdp设置</h3><p>　　需要通过xrdp连接到桌面，需要正确配置相关信息并填充到.xsession文件（针对每个用户）或/etc/startwm.sh（针对所有用户），输入如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> unity&gt;~/.xsession</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sed -i.bak <span class="string">'/fi/a #xrdp multi-users \n unity \n'</span> /etc/xrdp/startwm.sh</span></span><br></pre></td></tr></table></figure><h3 id="步骤五、重启xrdp"><a href="#步骤五、重启xrdp" class="headerlink" title="步骤五、重启xrdp"></a><strong>步骤五、重启xrdp</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service xrdp restart</span><br></pre></td></tr></table></figure><h3 id="步骤六、开启桌面共享功能"><a href="#步骤六、开启桌面共享功能" class="headerlink" title="步骤六、开启桌面共享功能"></a>步骤六、开启桌面共享功能</h3><p>　　进入系统-》首选项-》桌面共享，或者直接搜索桌面共享，如图所示</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192507153-638048489.png" alt="img"></p><p>　　将【允许其他人查看您的桌面】这一项勾上，如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192521575-517061538.png" alt="img"></p><p>到这一步基本上已经完成了，接下来就是来测试是否能正常连接到Ubuntu了</p><h1 id="三、xrdp测试连接到Ubuntu"><a href="#三、xrdp测试连接到Ubuntu" class="headerlink" title="三、xrdp测试连接到Ubuntu"></a>三、xrdp测试连接到Ubuntu</h1><p>　1、查看Ubuntu服务器的IP地址，如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192537450-1272034628.png" alt="img"></p><p>　　2、启动Windows远程桌面工具(mstc)，输入Ubuntu的IP地址（192.168.226.131），如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192554731-609673171.png" alt="img"></p><p>　　3、点击连接之后，正常情况会自动跳出xrdp的登录界面，需要我们输入用户名和密码即可，模式选择默认就行，如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192718465-137150594.png" alt="img"></p><p> 　　4、我们可以看到xrdp的实时日志，如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192751606-1594868562.png" alt="img"></p><p>　　5、最终我们连接到上了Ubuntu，是不是很熟悉的界面~~（ヾ(๑╹◡╹)ﾉ”）</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192821809-1569937933.png" alt="img"></p><p>　　至此，xrdp连接Ubuntu 16.04的所有步骤已完成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通过XDRP实现Windows远程访问&quot;&gt;&lt;a href=&quot;#通过XDRP实现Windows远程访问&quot; class=&quot;headerlink&quot; title=&quot;通过XDRP实现Windows远程访问&quot;&gt;&lt;/a&gt;通过XDRP实现Windows远程访问&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Ubuntu" scheme="https://nymrli.top/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>staticmethod和classmethod区别</title>
    <link href="https://nymrli.top/2019/07/07/staticmethod%E5%92%8Cclassmethod%E5%8C%BA%E5%88%AB/"/>
    <id>https://nymrli.top/2019/07/07/staticmethod和classmethod区别/</id>
    <published>2019-07-07T02:06:00.000Z</published>
    <updated>2019-07-25T10:21:57.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="staticmethod和classmethod"><a href="#staticmethod和classmethod" class="headerlink" title="staticmethod和classmethod"></a>staticmethod和classmethod</h1><blockquote><p>类的实例化基本遵循创建实例对象、初始化实例对象、最后返回(产生)实例对象这么一个过程</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></span><br><span class="line">    data = <span class="string">'world'</span> <span class="comment"># 类对象的数据成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        self.arg = arg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod# 静态方法，不能访问类数据成员</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod# 类方法,能访问类数据成员</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = Test(<span class="string">'A'</span>)</span><br><span class="line">    Test.func()</span><br><span class="line">    Test.getData()</span><br></pre></td></tr></table></figure><h3 id="共同"><a href="#共同" class="headerlink" title="共同:"></a>共同:</h3><ul><li>两个都是装饰器，装饰的成员函数可以通过<code>类名.方法名(...)</code>来调用</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><ul><li>▲最显著的特点是<code>classmethod</code>需要传递一个参数<code>cls</code>，而<code>staticmethod</code>不需要。因此可以访问、修改类的属性，类的方法，实例化对象等，避免硬编码；而<code>staticmethod</code>不行</li><li><code>classmethod</code>可以判断出自己是通过基类被调用，还是通过某个子类被调用</li></ul><h3 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h3><ul><li><code>classmethod</code>多用于设计模式之<a href="https://stackoverflow.com/a/929273/2684304" target="_blank" rel="noopener">工厂模式</a>，将解析逻辑封装在方法本身内部。（也可认为构造前交互，即在进行<u>实例化类对象之前先进行某些逻辑操作</u>，即可看作进行不同的构造函数，然后返回一个类实例，见<a href="#具体代码">具体代码</a>）,更多拓展见附录<a href="#附录`__new__`和``__init__``"><code>__new__</code>和<code>__init__</code></a></li><li><code>staticmethod</code>用法就跟其他的语言中的静态static用法相同（可看作是属于该类的一个工具、辅助函数）</li></ul><h4 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python program to demonstrate  </span></span><br><span class="line"><span class="comment"># use of class method and static method. </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year)</span>:</span></span><br><span class="line">        super(time, self).__init__()</span><br><span class="line">        self.year = year</span><br><span class="line">        print(self.year)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># a class method to create a time that one day following the data 'year'</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tomorrow</span><span class="params">(cls,year)</span>:</span></span><br><span class="line">        print(type(cls)) <span class="comment"># &gt;&gt;&gt; ▲ Python所有类都继承自`&lt;class 'type'&gt;`，包括新式类`object`</span></span><br><span class="line">        <span class="keyword">return</span> cls(year+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># a static method to check whether the given data 'year' is after 2000.</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoThoundYear</span><span class="params">(year)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> year&gt;<span class="number">2000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = time(<span class="number">1999</span>)</span><br><span class="line">    t2 = time.tomorrow(<span class="number">1999</span>)</span><br><span class="line">    print( time.twoThoundYear(<span class="number">2001</span>) )</span><br></pre></td></tr></table></figure><p>可看下这篇<a href="https://www.geeksforgeeks.org/class-method-vs-static-method-python/" target="_blank" rel="noopener">class method vs static method in Python</a></p><h2 id="附录-new-和-init"><a href="#附录-new-和-init" class="headerlink" title="附录__new__和__init__"></a>附录<code>__new__</code>和<code>__init__</code></h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><blockquote><p>▲1. 首先要弄懂调用顺序<code>__new__</code>–&gt;<code>__init__</code>： 所以<code>__init__</code>其实不是实例化一个类的时候第一个被调用 的方法。当使用 Persion(name, age) 这样的表达式来实例化一个类时，最先被调用的方法 其实是<code>__new__</code>方法。</p><p><code>__new__</code>至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供（实例化时加的参数，也会被认为时cls的属性，见①）。即<strong>系统知道<code>__new__</code>() 方法始终都是类的类方法，即使没有被加上类方法装饰器。</strong></p><p><code>__new__</code>方法接受的参数虽然也是和<code>__init__</code>一样，但<code>__init__</code>是在类实例创建之后调用，而 <code>__new__</code>方法正是创建这个类实例的方法。</p><p>▲2. <code>__init__</code>有一个参数self，就是这个<code>__new__</code>中<strong>return的实例</strong>，<code>__init__</code>在<code>__new__</code>的基础上可以完成一些其它初始化的动作，<code>__init__</code>不需要返回值。而<code>__new__</code>必须有（可以return父类<code>__new__</code>出来的实例，或者直接是object的<code>__new__</code>出来的实例）。<code>__new__</code>方法决定了创建哪个类的实例（可以是父类，也可以是子类），因此不一定调用当前类的<code>__init__</code>。即（若<code>__new__</code>没有正确返回<strong>当前类cls</strong>的实例，那<code>__init__</code>是不会被调用的，即使是父类的实例也不行）</p><p>3.继承自object的<strong>新式类</strong>才有<code>__new__</code>，同时，在任何新式类的<code>__new__</code>()方法，<u>不能调用自身的<code>__new__</code>()来制造实例，因为这会造成死循环</u>，即<code>class Foo(object)</code>的<code>__new__</code>中不能<code>Foo.__new__(cls, *args, **kwargs)。</code></p></blockquote><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p>1.<code>__init__</code> 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。</p><p>2.<code>__new__</code> 通常用于控制生成一个新实例的过程。它是类级别的方法。</p><p>依照Python官方文档的说法，<code>__new__</code>方法主要是当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的metaclass。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span>    <span class="comment"># 新式类:继承自object</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,something)</span>:</span></span><br><span class="line">        print(<span class="string">'init'</span>)</span><br><span class="line">        print(something)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __new__(cls):  不行，因为A("...")参数不匹配</span></span><br><span class="line">    <span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'new'</span>)</span><br><span class="line">        self = object.__new__(cls) <span class="comment"># ①cls中包含了*args, **kwargs信息</span></span><br><span class="line">        self.x = <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># 调用父类的`__new__`方法会返回一个A对象，init里的参数self调用的就是这个self实例</span></span><br><span class="line">        <span class="comment"># `__new__`必须具有返回值，否则无法创建对象，因为`__init__`函数需要这个返回值</span></span><br><span class="line">        <span class="comment"># 自己在定义`__new__`的时候，参数要与`__init__`函数的参数匹配，我可以不用到这些参数，但一定要匹配。或者可以使用*arg和**args的形式。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># a = A.__new__(A) #&gt;&gt;&gt; new</span></span><br><span class="line">    a = A(<span class="string">'do it'</span>)  <span class="comment"># &gt;&gt;&gt; new init</span></span><br><span class="line">    print(a.__dict__)  <span class="comment"># &#123;'x': '1'&#125;</span></span><br><span class="line">    <span class="comment"># 2、new定义在type元类中，必须具有返回值，</span></span><br><span class="line">    <span class="comment"># 3、new的作用就是创建实例，然后将创建的实例传递给init进行初始化</span></span><br></pre></td></tr></table></figure><p>总结：  a = A() –&gt; <code>__new__</code>方法，return调用父类<code>__new__</code>生成一个类实例对象 –&gt;<code>__init__(self,...)</code>中的self实例就是这个父类<code>__new__</code>出来的实例</p><blockquote><p><code>__new__</code>() 是在新式类中新出现的方法，它作用在构造方法建造实例之前，可以这么理解，在 Python 中存在于类里面的构造方法 <code>__init__</code>() 负责将类的实例化，而在 <code>__init__</code>() 启动之前，<code>__new__</code>() 决定是否要使用该 <code>__init__</code>() 方法，因为<code>__new__</code>() 可以调用其他类的构造方法或者直接返回别的对象来作为本类的实例。</p></blockquote><h3 id="用-new-来实现设计模式中的–单例模式"><a href="#用-new-来实现设计模式中的–单例模式" class="headerlink" title="用__new__来实现设计模式中的–单例模式"></a><strong>用<code>__new__</code>来实现设计模式中的–单例模式</strong></h3><blockquote><p>只能实例化一个类对象</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'instance'</span>):</span><br><span class="line">            cls.instance = super(Singleton, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br></pre></td></tr></table></figure><p>▲ Python所有类都继承自<code>&lt;class &#39;type&#39;&gt;</code>，包括新式类<code>object</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;staticmethod和classmethod&quot;&gt;&lt;a href=&quot;#staticmethod和classmethod&quot; class=&quot;headerlink&quot; title=&quot;staticmethod和classmethod&quot;&gt;&lt;/a&gt;staticmethod和c
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>yaml基础语法_spring_boot</title>
    <link href="https://nymrli.top/2019/07/07/yaml%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-spring-boot/"/>
    <id>https://nymrli.top/2019/07/07/yaml基础语法-spring-boot/</id>
    <published>2019-07-07T02:04:35.000Z</published>
    <updated>2019-07-07T02:05:09.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yaml基础语法-spring-boot"><a href="#yaml基础语法-spring-boot" class="headerlink" title="yaml基础语法_spring_boot"></a>yaml基础语法_spring_boot</h1><blockquote><p>yaml aren’t markup language 即yaml不是标语语言：</p><p>xml（标记语言）:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">port</span>&gt;</span>8888<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>java spring boot默认全局配置文件:</p><ol><li><p><code>application.properties</code> 使用的时 <code>key=value</code></p></li><li><p><code>application.yaml</code>:</p><ul><li><p>k:<space>v</space></p></li><li><p>通过缩进，垂直对齐指定层次关系</p><ul><li>字符串可以默认不写引号，写引号中的转义符会被翻译：e.g.<code>&quot;天\n津&quot;</code></li></ul></li><li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">student:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">张三</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">  birthday:</span> <span class="number">2019</span><span class="string">/07/19</span></span><br><span class="line"><span class="attr">  location:</span> <span class="comment"># &lt;==&gt; &#123;province: 陕西, city: 西安&#125; 行内写法</span></span><br><span class="line">  <span class="attr">province:</span> <span class="string">陕西</span></span><br><span class="line">  <span class="attr">city:</span> <span class="string">西安</span></span><br><span class="line">  <span class="comment"># 对应java里的字典map</span></span><br><span class="line"><span class="attr">  hobbies:</span> <span class="comment"># &lt;==&gt; [足球,篮球]</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">足球</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">篮球</span></span><br><span class="line">  <span class="comment"># 对应java里的列表List</span></span><br><span class="line"><span class="attr">  skills:</span> <span class="comment"># &lt;==&gt;[编程,金融]</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">编程</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">金融</span></span><br><span class="line">  <span class="comment"># 对应java里的集合set</span></span><br><span class="line"><span class="attr">  pet:</span><span class="comment"># &lt;==&gt;&#123;name: wc, type: hsq&#125;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wc</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">hsq</span></span><br><span class="line"> <span class="comment"># entity的另一个类pet.java</span></span><br></pre></td></tr></table></figure></li><li><p>[Set,List,数组\Array]、{Map、对象类型的属性StudentPet}，[]可以省略，{}不可以省略 </p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;yaml基础语法-spring-boot&quot;&gt;&lt;a href=&quot;#yaml基础语法-spring-boot&quot; class=&quot;headerlink&quot; title=&quot;yaml基础语法_spring_boot&quot;&gt;&lt;/a&gt;yaml基础语法_spring_boot&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python类的继承-super()使用</title>
    <link href="https://nymrli.top/2019/07/07/Python%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF-super-%E4%BD%BF%E7%94%A8/"/>
    <id>https://nymrli.top/2019/07/07/Python类的继承-super-使用/</id>
    <published>2019-07-07T02:03:49.000Z</published>
    <updated>2019-07-07T02:05:43.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python类的继承即super-使用"><a href="#Python类的继承即super-使用" class="headerlink" title="Python类的继承即super()使用"></a>Python类的继承即super()使用</h1><h2 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h2><blockquote><p><code>super()</code> 函数是用于调用父类(超类)的一个方法，<em>只有在新式类中可以使用</em></p><p>super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO，Method Resolution Order，采用广度优先（区别于深度优先）的规则定义）、重复调用（钻石继承）等种种问题。</p><p>MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。</p></blockquote><p><strong>语法</strong></p><p>以下是 super() 方法的语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 菜鸟教程</span></span><br><span class="line">super(type [, object-<span class="keyword">or</span>-type])</span><br><span class="line"><span class="comment"># 个人理解</span></span><br><span class="line">super( ThisClass [, object(self)])</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li>type – 类（type），通常是当前子类。</li><li>object-or-type – 类实例，一般是 self</li></ul><p><strong>含义</strong></p><p>用<code>self</code>这个实例对象去查找<code>ThisClass</code>类的父类拥有的属性（成员方法、数据成员）</p><p>▲. Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 <strong>super().xxx</strong> 代替 <strong>super(Class, self).xxx</strong> :</p><p>即平时写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *arg, **kwarg)</span>:</span></span><br><span class="line">        super(TestClass, self).__init__() <span class="comment"># 此时init里不用self</span></span><br><span class="line">        <span class="comment"># 等价于 super().__init__() , 含义是用父类的构造函数初始化某些变量</span></span><br><span class="line">        <span class="comment"># 相当于旧式类的 object.__init__(self) # 需要传参self</span></span><br><span class="line">        self.arg = arg</span><br><span class="line">        self.kwarg = kwarg</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsSuper</span><span class="params">(object)</span>:</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsSub</span><span class="params">(clsSuper)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(super().age)</span><br><span class="line">        <span class="comment"># 当只是单继承的时候可以直接使用 print(clsSuper.age)，</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = clsSuper(<span class="string">'cl'</span>)</span><br><span class="line">    b = clsSub()</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><code>super().func()</code>是不用传参<code>self</code>的</li><li><code>super(type, obj).func()</code>函数调用的是obj实例在MRO中下一个父类的可调用func()，而不是type的父类中的func()。即调用最近的可用func()</li><li>使用<code>super()</code>不用指定父类的名称，便于修改维护；同时当继承多个类A、B的时候，用<code>super().__init__()</code>相当于调用多个类的<code>A.__ini__(self)</code>、<code>B.__ini__(self)</code></li></ul><h2 id="与java对比"><a href="#与java对比" class="headerlink" title="与java对比"></a>与java对比</h2><ol><li>Python中子类不会默认调用父类的构造函数，即下面代码。并不会要要求给传<code>name</code>。当然也可以理解为跟java一样调用了一个全空、没有任何内容的构造函数，但是在python中不需要显性写出来，原因部分是特点2（java中存在有参数的构造函数时，必须将空参数的构造函数显式写出，不然子类默认隐式调用空参数的构造函数时会报错说不存在）。</li><li>Python中的构造函数只有一个。但由于存在<code>*arg,**kwarg</code>的存在，所以只要执行类型检查执行不同的代码；即实现了多个构造函数</li><li>Python的类可以多继承，java只能单继承。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsSuper</span><span class="params">(object)</span>:</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        print(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsSub</span><span class="params">(clsSuper)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        print(age)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">class clsSub(clsSuper):</span></span><br><span class="line"><span class="string">    def __init__(self, age):</span></span><br><span class="line"><span class="string">        super().__init__() #调用父类的构造函数</span></span><br><span class="line"><span class="string">        print(age)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    b = clsSub(<span class="number">18</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python类的继承即super-使用&quot;&gt;&lt;a href=&quot;#Python类的继承即super-使用&quot; class=&quot;headerlink&quot; title=&quot;Python类的继承即super()使用&quot;&gt;&lt;/a&gt;Python类的继承即super()使用&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Base64编码原理与应用[转]</title>
    <link href="https://nymrli.top/2019/06/15/Base64%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8-%E8%BD%AC/"/>
    <id>https://nymrli.top/2019/06/15/Base64编码原理与应用-转/</id>
    <published>2019-06-15T04:08:53.000Z</published>
    <updated>2019-06-15T04:09:38.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Base64编码原理与应用-转"><a href="#Base64编码原理与应用-转" class="headerlink" title="Base64编码原理与应用[转]"></a><a href="http://blog.xiayf.cn/2016/01/24/base64-encoding/" target="_blank" rel="noopener">Base64编码原理与应用[转]</a></h1><p>2015年，我们在青云平台上实现了“百度云观测”应用。青云应用本质上是一个iframe，在向iframe服务方发送的请求中会携带一些数据，青云平台会使用<code>Base64 URL</code>对这些数据进行编码，其提供的编码解码算法示例如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// php版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64_URL_encode</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rtrim(strtr(base64_encode($data), <span class="string">'+/'</span>, <span class="string">'-_'</span>), <span class="string">'='</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64_URL_decode</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> base64_decode(str_pad(strtr($data, <span class="string">'-_'</span>, <span class="string">'+/'</span>), </span><br><span class="line">                            strlen($data) % <span class="number">4</span>, <span class="string">'='</span>, STR_PAD_RIGHT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>Base64 URL</code> 是标准Base64编码的一个变种，分别用 <code>-</code>、<code>_</code> 替换标准Base64编码结果中的 <code>+</code> 、 <code>/</code> ，并删除结果最后的 <code>=</code> 。</p><p>在实现 “百度云观测” 青云应用时，我在想：</p><ul><li>为什么要使用Base64编码？</li><li>Base64编码算法是什么样的？</li></ul><p>本文是围绕这两个问题思考和实践的结果。</p><p>我认为，理解Base64或其他类似编码的关键有两点：</p><ol><li>计算机最终存储和执行的是01二进制序列，这个二进制序列的含义则由解码程序/解释程序决定</li><li>很多场景下的数据传输要求数据只能由简单通用的字符组成，比如HTTP协议要求请求的首行和请求头都必须是ASCII编码</li></ol><p>以青云应用为例，简单解释这两点。青云平台通过POST一个表单来获取iframe，表单有 <code>payload</code> 和 <code>signature</code> 两项， <code>payload</code> 原本是一个JSON对象，其中的键值可能包含一些特殊字符，比如 <code>&amp;</code>、<code>/</code> 等，由于青云设计的一种通用的请求交互方案，需要考虑iframe服务方服务器端的各种可能实现，有些服务器端实现没有考虑表单值有这些特殊字符，或者POST请求被中间服务器转换成GET请求再次发出，对于URL来说，<code>&amp;</code>、<code>/</code>都是具有特殊含义的字符，所以需要对请求数据进行特殊编码避免这些字符出现 - 数据发送方对数据按规则进行编码，接收方对应地按规则解码数据。</p><h2 id="Base64编码原理"><a href="#Base64编码原理" class="headerlink" title="Base64编码原理"></a>Base64编码原理</h2><p>Base64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码。标准Base64编码使用的64个字符为：</p><p><img src="http://blog.xiayf.cn/2016/01/24/base64-encoding/media/14542616644295.jpg" alt="img"></p><p>这64个字符是各种字符编码（比如ASCII编码）所使用字符的子集，基本，并且可打印。唯一有点特殊的是最后两个字符，因对最后两个字符的选择不同，Base64编码又有很多变种，比如Base64 URL编码。</p><p>Base64编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续6比特（2的6次方=64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。</p><p>假设我们要对 <code>Hello!</code> 进行Base64编码，按照ASCII表，其转换过程如下图所示：</p><p><img src="http://blog.xiayf.cn/2016/01/24/base64-encoding/media/14542967158550.jpg" alt="img"></p><p>可知 <code>Hello!</code> 的Base64编码结果为 <code>SGVsbG8h</code> ，原始字符串长度为6个字符，编码后长度为8个字符，每3个原始字符经Base64编码成4个字符，编码前后长度比4/3，这个长度比很重要 - 比原始字符串长度短，则需要使用更大的编码字符集，这并不我们想要的；长度比越大，则需要传输越多的字符，传输时间越长。Base64应用广泛的原因是在字符集大小与长度比之间取得一个较好的平衡，适用于各种场景。</p><p>是不是觉得Base64编码原理很简单？</p><p>但这里需要注意一个点：Base64编码是<strong>每3个原始字符编码成4个字符</strong>(如<code>Hel</code>被编成了<code>SGVs</code>)，如果原始字符串长度不能被3整除，那怎么办？使用0值来补充原始字符串。===&gt;Base64的编码长度为4的倍数。</p><p>以 <code>Hello!!</code> 为例，其转换过程为：</p><p><img src="http://blog.xiayf.cn/2016/01/24/base64-encoding/media/14542966298000.jpg" alt="img"></p><p><em>注：图表中蓝色背景的二进制0值是额外补充的。</em></p><p><code>Hello!!</code> Base64编码的结果为 <code>SGVsbG8hIQAA</code> 。最后2个零值只是为了Base64编码而补充的，在原始字符中并没有对应的字符，那么Base64编码结果中的最后两个字符 <code>AA</code> 实际不带有效信息，所以需要特殊处理，以免解码错误。</p><p>标准Base64编码通常用 <code>=</code> 字符来替换最后的 <code>A</code>（完全由补充的0组成的A，跟<code>b&#39;H&#39;</code>的结果<code>SA==</code>区别一下），即编码结果为 <code>SGVsbG8hIQ==</code>。因为 <code>=</code> 字符并不在Base64编码索引表中，其意义在于结束符号，在Base64解码时遇到 <code>=</code> 时即可知道一个Base64编码字符串结束。</p><p>如果Base64编码字符串不会相互拼接再传输，那么最后的 <code>=</code> 也可以省略，解码时如果发现Base64编码字符串长度不能被4整除，则先补充 <code>=</code> 字符，再解码即可。</p><p>解码是对编码的逆向操作，但注意一点：<strong>对于最后的两个 = 字符，转换成两个 A 字符，再转成对应的两个6比特二进制0值，接着转成原始字符之前，需要将最后的两个6比特二进制0值丢弃，因为它们实际上不携带有效信息</strong>。</p><p>为了理解Base64编码解码过程，个人实现了一个非常简陋的Base64编码解码程序，见：<a href="https://github.com/youngsterxyf/xiaBase64" target="_blank" rel="noopener">youngsterxyf/xiaBase64</a>。</p><p>由于Base64应用广泛，所以很多编程语言的标准库都内置Base64编码解码包，如：</p><ul><li>PHP：<a href="http://php.net/manual/en/function.base64-encode.php" target="_blank" rel="noopener">base64_encode</a>、<a href="http://php.net/manual/en/function.base64-decode.php" target="_blank" rel="noopener">base64_decode</a></li><li>Python：<a href="https://docs.python.org/2/library/base64.html" target="_blank" rel="noopener">base64包</a></li><li>Go：<a href="https://golang.org/pkg/encoding/base64/" target="_blank" rel="noopener">encoding/base64</a></li><li>…</li></ul><h2 id="Base64编码应用"><a href="#Base64编码应用" class="headerlink" title="Base64编码应用"></a>Base64编码应用</h2><p>本文开始提到的青云应用例子只是Base64编码的应用场景之一。由于Base64编码在字符集大小与编码后数据长度之间做了较好的平衡，以及Base64编码变种形式的多样，使得Base64编码的应用场景非常广泛。下面举2个常用常见的例子。</p><h3 id="HTML内嵌Base64编码图片"><a href="#HTML内嵌Base64编码图片" class="headerlink" title="HTML内嵌Base64编码图片"></a>HTML内嵌Base64编码图片</h3><p>前端在实现页面时，对于一些简单图片，通常会选择将图片内容直接内嵌在页面中，避免不必要的外部资源加载，增大页面加载时间，但是图片数据是二进制数据，该怎么嵌入呢？<a href="http://caniuse.com/#search=Data URI" target="_blank" rel="noopener">绝大多数现代浏览器</a>都支持一种名为 <code>Data URLs</code> 的特性，允许使用Base64对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。以百度搜索首页为例，其中语音搜索的图标是个背景图片，其内容以 <code>Data URLs</code> 形式直接写在css中，这个css内容又直接嵌在HTML页面中，如下图所示：</p><p><img src="http://blog.xiayf.cn/2016/01/24/base64-encoding/media/14543011032759.jpg" alt="img"></p><p><code>Data URLs</code> 格式为：<code>url(data:文件类型;编码方式,编码后的文件内容)</code>。</p><p>当然，也可以直接基于image标签嵌入图片，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img alt=&quot;Embedded Image&quot; src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIA...&quot; /&gt;</span><br></pre></td></tr></table></figure><p>但请注意：如果图片较大，图片的色彩层次比较丰富，则不适合使用这种方式，因为其Base64编码后的字符串非常大，会明显增大HTML页面，影响加载速度。</p><h3 id="MIME（多用途互联网邮件扩展）"><a href="#MIME（多用途互联网邮件扩展）" class="headerlink" title="MIME（多用途互联网邮件扩展）"></a>MIME（多用途互联网邮件扩展）</h3><p>我们的电子邮件系统，一般是使用SMTP（简单邮件传输协议）将邮件从客户端发往服务器端，邮件客户端使用POP3（邮局协议，第3版本）或IMAP（交互邮件访问协议）从服务器端获取邮件。</p><p>SMTP协议一开始是基于纯ASCII文本的，对于二进制文件（比如邮件附件中的图像、声音等）的处理并不好，所以后来新增MIME标准来编码二进制文件，使其能够通过SMTP协议传输。</p><p>举例来说，我给自己发封邮件，正文为空，带一个名为hello.txt的附件，内容为 <code>您好！世界！</code>。导出邮件源码，其关键部分如下图所示：</p><p><img src="http://blog.xiayf.cn/2016/01/24/base64-encoding/media/14543057568109.jpg" alt="img"></p><p><code>MIME-Version: 1.0</code>：表示当前使用MIME标准1.0版本。</p><p><code>Content-Type: text/plain; name=&quot;hello.txt&quot;</code>：表示附件文件名为 <code>hello.txt</code> ，格式为纯文本。</p><p><code>Content-Transfer-Encoding: base64</code>：表示附件文件内容使用base64编码后传输。</p><p><code>5oKo5aW977yM5LiW55WM77yB</code>：则是文件内容 <code>您好，世界！</code> Base64编码后的结果。</p><p>不过，MIME使用的不是标准Base64编码。</p><h2 id="切忌误用"><a href="#切忌误用" class="headerlink" title="切忌误用"></a>切忌误用</h2><p>可能会有人在不理解Base64编码的情况下，将其误用于数据加密或数据校验。</p><p>Base64是一种数据编码方式，目的是让数据符合传输协议的要求。标准Base64编码解码无需额外信息即完全可逆，即使你自己自定义字符集设计一种类Base64的编码方式用于数据加密，在多数场景下也较容易破解。</p><p>对于数据加密应该使用专门的<strong>目前还没有有效方式快速破解的</strong>加密算法。比如：对称加密算法<code>AES-128-CBC</code>，对称加密需要密钥，只要密钥没有泄露，通常难以破解；也可以使用非对称加密算法，如 <code>RSA</code>，利用极大整数因数分解的计算量极大这一特点，使得使用公钥加密的数据，只有使用私钥才能快速解密。</p><p>对于数据校验，也应该使用专门的消息认证码生成算法，如 <code>HMAC</code> - 一种使用单向散列函数构造消息认证码的方法，其过程是不可逆的、唯一确定的，并且使用密钥来生成认证码，其目的是防止数据在传输过程中被篡改或伪造。将原始数据与认证码一起传输，数据接收端将原始数据使用相同密钥和相同算法再次生成认证码，与原有认证码进行比对，校验数据的合法性。</p><p>那么针对各大网站被脱库的问题，请问应该怎么存储用户的登录密码？</p><p>答案是：在注册时，根据用户设置的登录密码，生成其<strong>消息认证码</strong>，然后存储用户名和消息认证码，不存储原始密码。每次用户登录时，根据登录密码，生成消息认证码，与数据库中存储的消息认证码进行比对，以确认是否为有效用户，这样即使网站被脱库，用户的原始密码也不会泄露，不会为用户使用的其他网站带来账号风险。</p><p>当然，使用的消息认证码算法其哈希碰撞的概率应该极低才行，目前一般在HMAC算法中使用SHA256。对于这种方式需要注意一点：防止用户使用弱密码，否则也可能会被暴力破解。现在的网站一般要求用户密码6个字符以上，并且同时有数字和大小写字母，甚至要求有特殊字符。</p><p>另外，也可以使用加入随机salt的哈希算法来存储校验用户密码。这里暂不细述。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Base64兼顾字符集大小和编码后数据长度，并且可以灵活替换字符集的最后两个字符，以应对多样的需求，使其适用场景非常广泛。</p><p>当然，很多场景下有多种编码方式可选择，并非Base64编码不可，视需求，权衡利弊而定。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Base64、Base32、Base16区别"><a href="#Base64、Base32、Base16区别" class="headerlink" title="Base64、Base32、Base16区别"></a>Base64、Base32、Base16区别</h3><p>标准Base64：<br>包含大写字母（A-Z）,小写字母（a-z），数字（0-9）以及+/;<br>Base32:<br>而Base32中只有大写字母（A-Z）和数字234567；<br>Base16:<br>而Base16就是16进制，他的范围是数字(0-9)，字母（ABCDEF）；</p><p>顺便说一句，当ASCll用Base加密达不到所对应的位数的时候用=号补齐；<br>在这里附带由三种Base加密的:I love you！<br>Base64:SSBsb3ZlIHlvde+8gQ==<br>Base32:JEQGY33WMUQHS33V566IC===<br>Base16:49206c6f766520796f75efbc81</p><hr><p>1.由上可知，Base64编码后字符串长度为4的倍数</p><p>2.标准Base64编码通常用 <code>=</code> 字符来替换最后的 <code>A</code>（完全由补充的0组成的A，跟<code>b&#39;H&#39;</code>的结果<code>SA==</code>区别一下，<code>SA==</code>的A并不是全部由补充的0组成）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Base64编码原理与应用-转&quot;&gt;&lt;a href=&quot;#Base64编码原理与应用-转&quot; class=&quot;headerlink&quot; title=&quot;Base64编码原理与应用[转]&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://blog.xiayf.cn/2016/01/24
      
    
    </summary>
    
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python的构建工具setup.py</title>
    <link href="https://nymrli.top/2019/06/15/Python%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7setup-py/"/>
    <id>https://nymrli.top/2019/06/15/Python的构建工具setup-py/</id>
    <published>2019-06-15T04:08:44.000Z</published>
    <updated>2019-06-15T04:09:21.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python的构建工具setup-py"><a href="#Python的构建工具setup-py" class="headerlink" title="Python的构建工具setup.py"></a>Python的构建工具setup.py</h1><h2 id="setup-py各参数介绍："><a href="#setup-py各参数介绍：" class="headerlink" title="setup.py各参数介绍："></a>setup.py各参数介绍：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">--name 库名称，▲需要注意的是不要大写，不然会有坑</span><br><span class="line">--version (-V) 包版本</span><br><span class="line">--author 程序的作者</span><br><span class="line">--author_email 程序的作者的邮箱地址</span><br><span class="line">--maintainer 维护者</span><br><span class="line">--maintainer_email 维护者的邮箱地址</span><br><span class="line">--url 程序的官网地址</span><br><span class="line">--license 程序的授权信息</span><br><span class="line">--description 程序的简单描述</span><br><span class="line">--long_description 程序的详细描述</span><br><span class="line">--platforms 程序适用的软件平台列表</span><br><span class="line">--classifiers 程序的所属分类列表</span><br><span class="line">--keywords 程序的关键字列表</span><br><span class="line">--packages 需要处理的包目录（包含__init__.py的文件夹） </span><br><span class="line">--py_modules 需要打包的python文件列表</span><br><span class="line">--download_url 程序的下载地址</span><br><span class="line">--cmdclass </span><br><span class="line">--data_files 打包时需要打包的数据文件，如图片，配置文件等</span><br><span class="line">--scripts 安装时需要执行的脚步列表</span><br><span class="line">--package_dir 告诉setuptools哪些目录下的文件被映射到哪个源码包。一个例子：package_dir = &#123;&apos;&apos;: &apos;lib&apos;&#125;，表示“root package”中的模块都在lib 目录中。</span><br><span class="line">--requires 定义依赖哪些模块 </span><br><span class="line">--provides定义可以为哪些模块提供依赖 </span><br><span class="line">--find_packages() 对于简单工程来说，手动增加packages参数很容易，刚刚我们用到了这个函数，它默认在和setup.py同一目录下搜索各个含有 __init__.py的包。</span><br><span class="line">--install_requires = [&quot;requests&quot;] 需要安装的依赖包</span><br><span class="line">--entry_points 动态发现服务和插件，下面详细讲</span><br></pre></td></tr></table></figure><p>find_packages()还可以将包统一放在一个src目录中，另外，这个包内可能还有aaa.txt文件和data数据文件夹。另外，也可以排除一些特定的包 <code>find_packages(exclude=[&quot;*.tests&quot;, &quot;*.tests.*&quot;, &quot;tests.*&quot;, &quot;tests&quot;])</code></p><h2 id="实测操作"><a href="#实测操作" class="headerlink" title="实测操作"></a>实测操作</h2><h3 id="需要事前交代的内容"><a href="#需要事前交代的内容" class="headerlink" title="需要事前交代的内容"></a>需要事前交代的内容</h3><h4 id="模板setup-py"><a href="#模板setup-py" class="headerlink" title="模板setup.py"></a>模板setup.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note: To use the 'upload' functionality of this file, you must:</span></span><br><span class="line"><span class="comment">#   $ pip install twine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> rmtree</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> find_packages, setup, Command</span><br><span class="line"></span><br><span class="line"><span class="comment"># Package meta-data.</span></span><br><span class="line">NAME = <span class="string">'cltest'</span></span><br><span class="line">DESCRIPTION = <span class="string">'know how to'</span></span><br><span class="line">URL = <span class="string">''</span></span><br><span class="line">EMAIL = <span class="string">'10630529664@qq.com'</span></span><br><span class="line">AUTHOR = <span class="string">'Gao Liang'</span></span><br><span class="line">REQUIRES_PYTHON = <span class="string">'&gt;=3.0.0'</span></span><br><span class="line">VERSION = <span class="string">'0.3.0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># What packages are required for this module to be executed?</span></span><br><span class="line">REQUIRED = [</span><br><span class="line">    <span class="string">'requests &gt;= 2.20.0'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The rest you shouldn't have to touch too much :)</span></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"><span class="comment"># Except, perhaps the License and Trove Classifiers!</span></span><br><span class="line"><span class="comment"># If you do change the License, remember to change the Trove Classifier for that!</span></span><br><span class="line"></span><br><span class="line">here = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import the README and use it as the long-description.</span></span><br><span class="line"><span class="comment"># Note: this will only work if 'README.md' is present in your MANIFEST.in file!</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> io.open(os.path.join(here, <span class="string">'README.md'</span>), encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        long_description = <span class="string">'\n'</span> + f.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    long_description = DESCRIPTION</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the package's __version__.py module as a dictionary.</span></span><br><span class="line">about = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> VERSION:</span><br><span class="line">    <span class="keyword">with</span> open(os.path.join(here, NAME, <span class="string">'__version__.py'</span>)) <span class="keyword">as</span> f:</span><br><span class="line">        exec(f.read(), about)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    about[<span class="string">'__version__'</span>] = VERSION</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadCommand</span><span class="params">(Command)</span>:</span></span><br><span class="line">    <span class="string">"""Support setup.py upload."""</span></span><br><span class="line"></span><br><span class="line">    description = <span class="string">'Build and publish the package.'</span></span><br><span class="line">    user_options = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">status</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="string">"""Prints things in bold."""</span></span><br><span class="line">        print(<span class="string">'\033[1m&#123;0&#125;\033[0m'</span>.format(s))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize_options</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finalize_options</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.status(<span class="string">'Removing previous builds…'</span>)</span><br><span class="line">            rmtree(os.path.join(here, <span class="string">'dist'</span>))</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        self.status(<span class="string">'Building Source and Wheel (universal) distribution…'</span>)</span><br><span class="line">        os.system(<span class="string">'&#123;0&#125; setup.py sdist bdist_wheel --universal'</span>.format(sys.executable))</span><br><span class="line"></span><br><span class="line">        self.status(<span class="string">'Uploading the package to PyPI via Twine…'</span>)</span><br><span class="line">        os.system(<span class="string">'twine upload dist/*'</span>)</span><br><span class="line"></span><br><span class="line">        self.status(<span class="string">'Pushing git tags…'</span>)</span><br><span class="line">        os.system(<span class="string">'git tag v&#123;0&#125;'</span>.format(about[<span class="string">'__version__'</span>]))</span><br><span class="line">        os.system(<span class="string">'git push --tags'</span>)</span><br><span class="line"></span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Where the magic happens:</span></span><br><span class="line">setup(</span><br><span class="line">    name=NAME,</span><br><span class="line">    version=about[<span class="string">'__version__'</span>],</span><br><span class="line">    description=DESCRIPTION,</span><br><span class="line">    long_description=long_description,</span><br><span class="line">    long_description_content_type=<span class="string">'text/markdown'</span>,</span><br><span class="line">    author=AUTHOR,</span><br><span class="line">    author_email=EMAIL,</span><br><span class="line">    python_requires=REQUIRES_PYTHON,</span><br><span class="line">    url=URL,</span><br><span class="line">    packages=find_packages(exclude=(<span class="string">'tests'</span>,)),</span><br><span class="line">    <span class="comment"># If your package is a single module, use this instead of 'packages':</span></span><br><span class="line">    <span class="comment"># py_modules=['mypackage'],</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># entry_points=&#123;</span></span><br><span class="line">    <span class="comment">#     'console_scripts': ['mycli=mymodule:cli'],</span></span><br><span class="line">    <span class="comment"># &#125;,</span></span><br><span class="line">    install_requires=REQUIRED,</span><br><span class="line">    include_package_data=<span class="keyword">True</span>,</span><br><span class="line">    license=<span class="string">'MIT'</span>,</span><br><span class="line">    classifiers=[</span><br><span class="line">        <span class="comment"># Trove classifiers</span></span><br><span class="line">        <span class="comment"># Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers</span></span><br><span class="line">        <span class="string">'License :: OSI Approved :: MIT License'</span>,</span><br><span class="line">        <span class="string">'Programming Language :: Python'</span>,</span><br><span class="line">        <span class="string">'Programming Language :: Python :: 3'</span>,</span><br><span class="line">        <span class="string">'Programming Language :: Python :: 3.6'</span>,</span><br><span class="line">        <span class="string">'Programming Language :: Python :: Implementation :: CPython'</span>,</span><br><span class="line">        <span class="string">'Programming Language :: Python :: Implementation :: PyPy'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># $ setup.py publish support.</span></span><br><span class="line">    cmdclass=&#123;</span><br><span class="line">        <span class="string">'upload'</span>: UploadCommand,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="待打包的目录树："><a href="#待打包的目录树：" class="headerlink" title="待打包的目录树："></a>待打包的目录树：</h4><blockquote><p>E:.<br>│  MANIFEST.in<br>│  out.json<br>│  README.md<br>│  setup.py<br>│<br>└─files<br>     in.json<br>     txt.txt<br>     world.py<br>     <code>__init__.py</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ACCOUNT = <span class="string">'mrli'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printHello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello &#123;&#125;"</span>.format(ACCOUNT))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readTXT</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'txt.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        print(f.read())</span><br><span class="line">    <span class="comment"># print( os.listdir() )</span></span><br></pre></td></tr></table></figure><h4 id="MANIFEST-in内容"><a href="#MANIFEST-in内容" class="headerlink" title="MANIFEST.in内容"></a><code>MANIFEST.in</code>内容</h4><p><code>MANIFEST.in</code>决定了除了Py文件外的什么说明、配置文件会被打包进去(如<code>.txt、.json</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Include the README</span><br><span class="line">include *.md</span><br><span class="line"></span><br><span class="line"># Include the txt file</span><br><span class="line">include */*.txt</span><br><span class="line"></span><br><span class="line"># Include the data files</span><br><span class="line"># recursive-include xxxx/utils */*.json</span><br></pre></td></tr></table></figure><p>注意我操作这边时并没有include json文件，所以生成的项目树中也没有任何的json文件（无论是<code>in.json</code>还是<code>out.json</code>），而<code>txt.txt</code>是包含的，并且之后甚至能用readTXT()函数，直接读取打包的<code>txt.txt</code>的内容。</p><h5 id="关于MANIFEST-in"><a href="#关于MANIFEST-in" class="headerlink" title="关于MANIFEST.in"></a>关于<code>MANIFEST.in</code></h5><p>项目里会有一些非py文件，比如html和js等，这时候就要靠<code>include_package_data</code> 和 <code>package_data</code>及<code>packages</code>来指定了。<code>package_data</code>一般写成 <code>{&#39;your_package_name&#39;: [&quot;files&quot;]}</code>。keywords便于pypi索引。</p><p>▲.然而只设置了<code>include_package_data</code>还没完，还需要一个<code>MANIFEST.in</code>文件来明确指定哪些文件需要打到包中。===&gt;如果<code>include_package_data=True</code>的话，那么还需要写个<code>MANIFEST.in</code>来明确。</p><h3 id="python-setup-py-install安装"><a href="#python-setup-py-install安装" class="headerlink" title="python setup.py install安装"></a><code>python setup.py install</code>安装</h3><p>安装后的目录树</p><blockquote><p>│  MANIFEST.in<br>│  out.json(这是原来就在的)<br>│  README.md<br>│  setup.py<br>│<br>├─build（生成的文件夹）<br>│  ├─bdist.win-amd64<br>│  └─lib<br>│      └─files<br>│              txt.txt<br>│              world.py<br>│              <strong>init</strong>.py<br>│<br>├─cltest.egg-info（生成的文件夹）<br>│      dependency_links.txt<br>│      PKG-INFO<br>│      requires.txt<br>│      SOURCES.txt<br>│      top_level.txt<br>│<br>├─dist（生成的文件夹）<br>│      cltest-0.3.0-py3.7.egg<br>│<br>└─files<br>     in.json<br>     txt.txt<br>     world.py<br>     <code>__init__.py</code></p></blockquote><p>一共生成了<strong>3个文件夹</strong>为<code>build</code>、<code>dist</code>、<code>cltest.egg-info</code>，</p><ul><li><p><code>build\lib</code>下的就是自己想要打包的库的内容，即<code>files</code>里的模块。</p></li><li><p><code>dist</code>是加入到虚拟环境库下的文件<code>venv\Lib\site-packages</code>中可以找到<code>cltest-0.3.0-py3.7.egg</code></p></li><li><p><code>cltest.egg-info</code>中有生成很多文件</p><ul><li><p><code>dependency_links.txt</code>空的</p></li><li><p><code>PKG-INFO</code>内容是setup.py中设置的，关于库的描述</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Metadata-Version: 2.1</span><br><span class="line">Name: cltest</span><br><span class="line">Version: 0.3.0</span><br><span class="line">Summary: know how to</span><br><span class="line">Home-page: UNKNOWN</span><br><span class="line">Author: Gao Liang</span><br><span class="line">Author-email: 10630529664@qq.com</span><br><span class="line">License: MIT</span><br><span class="line">Description: </span><br><span class="line">        # 测试Setup工具</span><br><span class="line">        </span><br><span class="line">        hhhh</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">Platform: UNKNOWN</span><br><span class="line">Classifier: License :: OSI Approved :: MIT License</span><br><span class="line">Classifier: Programming Language :: Python</span><br><span class="line">Classifier: Programming Language :: Python :: 3</span><br><span class="line">Classifier: Programming Language :: Python :: 3.6</span><br><span class="line">Classifier: Programming Language :: Python :: Implementation :: CPython</span><br><span class="line">Classifier: Programming Language :: Python :: Implementation :: PyPy</span><br><span class="line">Requires-Python: &gt;=3.0.0</span><br><span class="line">Description-Content-Type: text/markdown</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>requires.txt</code>：内容是<code>setup.py</code>中<code>install_requires=REQUIRED</code>里设置的依赖内容，写法参看<code>requirements.txt</code></p></li><li><p><code>SOURCES.txt</code>：列出了所有被打包的文件</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MANIFEST.in</span><br><span class="line">README.md</span><br><span class="line">setup.py</span><br><span class="line">cltest.egg-info/PKG-INFO</span><br><span class="line">cltest.egg-info/SOURCES.txt</span><br><span class="line">cltest.egg-info/dependency_links.txt</span><br><span class="line">cltest.egg-info/requires.txt</span><br><span class="line">cltest.egg-info/top_level.txt</span><br><span class="line">files/__init__.py</span><br><span class="line">files/txt.txt</span><br><span class="line">files/world.py</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>top_level.txt</code>：列出了可用的模块，应该是由<code>packages=find_packages(exclude=(&#39;tests&#39;,)),</code>决定的，由于我只写了一个包<code>files</code>，所以内容也只有</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p>这边需要注意的是在<code>setup.py</code>中设置<code>name=&#39;cltest&#39;</code>是指的整个库的名字，但真正使用的是要看这个库下有哪些可用的包，包下有哪些模块。</p><p>在我的这个例子下面，可以通过库名<code>cltest</code>来找到、下载我这个库。在安装完以后，导入就得知道包名了，这边是<code>files</code>，所以使用得代码应该是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> files <span class="keyword">import</span> world</span><br><span class="line">world.readTXT()</span><br></pre></td></tr></table></figure><p>这个现象其实还挺常见的，比如<code>beautifulSoup4</code>库，使用的时候是<code>from bs4 import ..</code>；以及<code>python-opencv2</code>库，需要<code>import cv2 as cv</code>。其实就是这边<strong>库名与包名</strong>的区别。</p><h3 id="坑点记录"><a href="#坑点记录" class="headerlink" title="坑点记录:"></a>坑点记录:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> files <span class="keyword">import</span> world</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">def readTXT():</span></span><br><span class="line"><span class="string">    with open('txt.txt', 'r') as f:</span></span><br><span class="line"><span class="string">        print(f.read())</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">world.readTXT()</span><br></pre></td></tr></table></figure><p>由于’txt.txt’是相对路径，所以只有在运行脚本位置有<code>txt.txt</code>文件时才不会报错，一开始<code>from files import world</code>时报错<code>txt.txt</code>以为时<code>txt.txt</code>没有被打包进去（其实可以通过<code>Sources.txt</code>文件查看到底有没有被打包进去），后来才明白是使用<code>readTXT()</code>的当前目录下不存在而已。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python的构建工具setup-py&quot;&gt;&lt;a href=&quot;#Python的构建工具setup-py&quot; class=&quot;headerlink&quot; title=&quot;Python的构建工具setup.py&quot;&gt;&lt;/a&gt;Python的构建工具setup.py&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Oauth2原理、使用</title>
    <link href="https://nymrli.top/2019/06/03/Oauth2%E5%8E%9F%E7%90%86%E3%80%81%E4%BD%BF%E7%94%A8/"/>
    <id>https://nymrli.top/2019/06/03/Oauth2原理、使用/</id>
    <published>2019-06-03T13:22:30.000Z</published>
    <updated>2019-06-03T13:24:00.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oauth2原理、使用"><a href="#Oauth2原理、使用" class="headerlink" title="Oauth2原理、使用"></a>Oauth2原理、使用</h1><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>快递员–&gt;门禁–&gt;小区–&gt;我家    &lt;=====&gt; 第三方应用 –&gt; 微信墙 —&gt;账号–&gt;个人数据</p><blockquote><p>简单说，<em>OAuth</em> 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个<strong>短期的进入令牌</strong>（token），用来<u>代替密码</u>，供第三方应用使用。</p></blockquote><h2 id="OAuth-的核心就是向第三方应用颁发令牌"><a href="#OAuth-的核心就是向第三方应用颁发令牌" class="headerlink" title="OAuth 的核心就是向第三方应用颁发令牌"></a><strong>OAuth 的核心就是向第三方应用颁发令牌</strong></h2><h3 id="令牌特点："><a href="#令牌特点：" class="headerlink" title="令牌特点："></a>令牌特点：</h3><p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p><p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><h2 id="OAuth是什么？"><a href="#OAuth是什么？" class="headerlink" title="OAuth是什么？"></a>OAuth是什么？</h2><p> 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p><h2 id="四种获得令牌的流程"><a href="#四种获得令牌的流程" class="headerlink" title="四种获得令牌的流程:"></a><strong>四种获得令牌的流程</strong>:</h2><ul><li><p>授权码（authorization-code）</p><ul><li><p>1.发送请求A-&gt;B</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure></li><li><p>A（客户端）-&gt;B（）<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p></li></ul></li><li><p>第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像<code>https://a.com/callback?code=AUTHORIZATION_CODE</code></p></li><li><p>第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/token?</span><br><span class="line"> client_id=CLIENT_ID&amp;</span><br><span class="line"> client_secret=CLIENT_SECRET&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p></li></ul></li><li><p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p><ul><li><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="attr">"access_token"</span>:<span class="string">"ACCESS_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"token_type"</span>:<span class="string">"bearer"</span>,</span><br><span class="line">  <span class="attr">"expires_in"</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="attr">"refresh_token"</span>:<span class="string">"REFRESH_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"scope"</span>:<span class="string">"read"</span>,</span><br><span class="line">  <span class="attr">"uid"</span>:<span class="number">100101</span>,</span><br><span class="line">  "info":&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p></li></ul></li></ul></li><li><p>隐藏式（implicit）</p><ul><li><blockquote><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。</p></blockquote></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure><p><code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p></li><li><p><code>https://a.com/callback#token=ACCESS_TOKEN`</code>token`参数就是令牌，A 网站因此直接在前端拿到令牌。</p></li><li><p>▲注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p></li></ul></li><li><p>密码式（password）：</p><ul><li><blockquote><p>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</p></blockquote></li></ul></li><li><p>客户端凭证（client credentials）</p><ul><li><blockquote><p>适用于没有前端的命令行应用，即在命令行下请求令牌。</p></blockquote></li></ul></li></ul><p>clientID和ClientSecret均是App需要申请的API密钥</p><p><img src="/2019/06/03/Oauth2原理、使用/Oauth_ClientID.png" alt="Oauth_ClientID"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="Github-Oauth"><a href="#Github-Oauth" class="headerlink" title="Github Oauth"></a>Github Oauth</h2><h2 id="QQ-Oauth"><a href="#QQ-Oauth" class="headerlink" title="QQ Oauth"></a>QQ Oauth</h2><p>本地测试QQ的写法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 方法一：在hosts中将nymrli.top修改到<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">@app.route('/login')</span><br><span class="line">def login():</span><br><span class="line">params = &#123;</span><br><span class="line">'response_type' : 'code',</span><br><span class="line">'client_id' : '101568872',</span><br><span class="line">'redirect_uri' : 'http://beta.nymrli.top/oauth/qq',</span><br><span class="line">'state' : '1',</span><br><span class="line">&#125;</span><br><span class="line">url = 'https://graph.qq.com/oauth2.0/authorize?'</span><br><span class="line">urlParams = urlencode(params)</span><br><span class="line">    # ▲需要url编码</span><br><span class="line">comleteUrl = url + urlParams</span><br><span class="line"># <span class="keyword">return</span> url_for( )</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line">    ▲应该用redirect，而不是requests.get的text内容或者是url_for</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="keyword">return</span> redirect( comleteUrl)</span><br><span class="line">        </span><br><span class="line">@app.route('/oauth/qq')</span><br><span class="line">def getCode():</span><br><span class="line">return request.args.get('code')</span><br><span class="line">        </span><br><span class="line"># 方法二：随便申请一个应用</span><br><span class="line">@app.route('/login')</span><br><span class="line">def login():</span><br><span class="line">params = &#123;</span><br><span class="line">'response_type' : 'code',</span><br><span class="line">'client_id' : '101584056',</span><br><span class="line"># 'redirect_uri' : 'http://beta.nymrli.top/oauth/qq',</span><br><span class="line">'redirect_uri' : 'http://127.0.0.1:8000/oauth/redirect',</span><br><span class="line">'state' : 'test'</span><br><span class="line">&#125;</span><br><span class="line">url = 'https://graph.qq.com/oauth2.0/authorize?'</span><br><span class="line">urlParams = urlencode(params)</span><br><span class="line">comleteUrl = url + urlParams</span><br><span class="line"><span class="keyword">return</span> redirect( comleteUrl)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route('/oauth/redirect')</span><br><span class="line">def getCode():</span><br><span class="line">print(request.args)</span><br><span class="line">return 'hello'</span><br></pre></td></tr></table></figure><p><img src="/2019/06/03/Oauth2原理、使用/QQoauth_test.png" alt="QQoauth_test"></p><h3 id="坑点记录：部署"><a href="#坑点记录：部署" class="headerlink" title="坑点记录：部署"></a>坑点记录：部署</h3><blockquote><p>经过调试发现部署上去后，在<a href="http://beta.nymrli.top/info" target="_blank" rel="noopener">http://beta.nymrli.top/info</a>页面下获得不到    <code>access_token = session.get(&#39;access_token&#39;)</code>于是猜想session设置有问题。果然linux下<code>os.urandom(24)</code>有问题， 结果是无法获得到信息。经修改后能正常获得结果</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECRET_KEY= os.urandom(<span class="number">24</span>)  <span class="comment"># 设置为24位的字符,每次运行服务器都是不同的，所以服务器启动一次上次的session就清除。</span></span><br></pre></td></tr></table></figure><p><img src="/2019/06/03/Oauth2原理、使用/no.png" alt="no"></p><p>改成随便的SECRET_KEY的就行了，比如<code>SECRET_KEY=&#39;asdzxcqwe&#39;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Oauth2原理、使用&quot;&gt;&lt;a href=&quot;#Oauth2原理、使用&quot; class=&quot;headerlink&quot; title=&quot;Oauth2原理、使用&quot;&gt;&lt;/a&gt;Oauth2原理、使用&lt;/h1&gt;&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="flask" scheme="https://nymrli.top/tags/flask/"/>
    
      <category term="后端" scheme="https://nymrli.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Web" scheme="https://nymrli.top/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>lua学习</title>
    <link href="https://nymrli.top/2019/06/03/lua%E5%AD%A6%E4%B9%A0/"/>
    <id>https://nymrli.top/2019/06/03/lua学习/</id>
    <published>2019-06-03T13:22:03.000Z</published>
    <updated>2019-06-03T13:22:15.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lua学习"><a href="#lua学习" class="headerlink" title="lua学习"></a>lua学习</h1><blockquote><p>动态脚本语言，可嵌入C和C++，Lua负责逻辑，C、C++负责功能</p><p>C编译，跨平台性良好</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 循环结构 [1,10]</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">( ... )</span></span></span><br><span class="line"><span class="comment">-- body</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 选择结构</span></span><br><span class="line"><span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="表-lt-gt-字典"><a href="#表-lt-gt-字典" class="headerlink" title="表{} &lt;==&gt;字典"></a>表<code>{}</code> &lt;==&gt;字典</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Conftg=&#123; hello=<span class="string">"Hello Lua"</span>, world=<span class="string">"World"</span>&#125;</span><br><span class="line">Config.words=<span class="string">"Hello"</span></span><br><span class="line">Config.num=<span class="number">180</span></span><br><span class="line">Config[<span class="string">"name"</span>]=<span class="string">"ZhangSan"</span></span><br><span class="line"><span class="built_in">print</span>(Config[<span class="string">"words"</span>])</span><br><span class="line"><span class="built_in">print</span>(Config. name)</span><br><span class="line"><span class="built_in">print</span>(Config, hello)</span><br><span class="line"><span class="keyword">for</span> key, var <span class="keyword">in</span> <span class="built_in">pairs</span>(Config) <span class="keyword">do</span> </span><br><span class="line"><span class="built_in">print</span>(key, var)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组{}"></a>数组<code>{}</code></h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'hello'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(arr) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="number">3</span> </span><br><span class="line"><span class="number">4</span> hello</span><br></pre></td></tr></table></figure><p>▲索引从1开始</p><p>使用API<code>table</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数组插入</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>( arr , <span class="number">1</span>, i)</span><br><span class="line">    <span class="comment">-- 经sxh发现结果是逆序的,19-&gt;2,20-&gt;1 ， 原因是每次都从头部插入，相当于LIFO , 此时感觉像是数组（带索引key）...并且table.insert( arr , 2, i)结果只有2--&gt;20 ，此时像字典（只有键2）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 正序的顺出</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>( arr , i) <span class="comment">-- 默认在尾部开始插入</span></span><br><span class="line">    <span class="comment">-- 或者arr[i] = i</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 获得数组长度</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">maxn</span>(arr)</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote><p>没有class类关键字，但可以自己实现类的功能：</p><ul><li>复制表<code>table</code></li><li>函数闭包</li></ul></blockquote><h3 id="复制表table"><a href="#复制表table" class="headerlink" title="复制表table"></a>复制表<code>table</code></h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">people = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">people.sayHi</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Hi'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 法二</span></span><br><span class="line">people.sayHi = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Hi'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span><span class="params">( tab )</span></span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">arr[k] = tab[v]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 相当于是构造方法</span></span><br><span class="line">People.new = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span></span></span><br><span class="line"><span class="keyword">local</span> self = clone(People)</span><br><span class="line">self.name = name </span><br><span class="line"><span class="keyword">return</span> self </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 成员函数</span></span><br><span class="line">People.sayHi = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span> <span class="comment">-- self是类示例变量</span></span><br><span class="line"><span class="comment">-- ..是字符串连接 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"People say hi:"</span>.. self. name)</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试可以实现类的功能</span></span><br><span class="line"><span class="comment">--local p = clone(People)</span></span><br><span class="line"><span class="comment">--p.sayHi()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试构造函数</span></span><br><span class="line"><span class="keyword">local</span> p = People.new(<span class="string">"ZhangSan"</span>)</span><br><span class="line"><span class="comment">-- 需要传类示例</span></span><br><span class="line">p.sayHi(p)</span><br><span class="line"><span class="comment">-- 使用：可以不用传类示例</span></span><br><span class="line">p:sayHi()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Man=&#123;&#125;</span><br><span class="line"><span class="comment">-- 实现类的继承的功能</span></span><br><span class="line">Man.new = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span></span></span><br><span class="line"><span class="keyword">local</span> self =People.new(name)</span><br><span class="line">copy(self, Man)</span><br><span class="line"><span class="keyword">return</span> self </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增添成员函数</span></span><br><span class="line">Man.sayHello=<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Man say hello"</span>)</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重写成员函数</span></span><br><span class="line">Man.sayHi = <span class="function"><span class="keyword">function</span> <span class="params">(self)</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Man sayHi"</span>.. self.name)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">local</span> self = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">( name )</span></span></span><br><span class="line">self.name = name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello "</span>..self.name)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">init()</span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span><span class="params">(name)</span></span></span><br><span class="line"><span class="keyword">local</span> self= People(name)</span><br><span class="line"><span class="comment">-- local function init()</span></span><br><span class="line"><span class="comment">-- end </span></span><br><span class="line">self.sayHello=<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello"</span>..self.name)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>学习自 <a href="https://www.bilibili.com/video/av46428956/?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/av46428956/?p=8</a></p><hr><p>通过表的特性实现<code>switch</code>关键字功能</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = <span class="number">1</span>  </span><br><span class="line"><span class="keyword">local</span> switch = &#123;  </span><br><span class="line">    [<span class="number">1</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"switch:"</span>.<span class="number">.1</span>)  </span><br><span class="line">    <span class="keyword">end</span>,  </span><br><span class="line">    [<span class="number">2</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"switch:"</span>.<span class="number">.2</span>)  </span><br><span class="line">    <span class="keyword">end</span>,  </span><br><span class="line">    [<span class="string">"test"</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"switch:test"</span>)  </span><br><span class="line">    <span class="keyword">end</span>,  </span><br><span class="line">&#125;  </span><br><span class="line"> switch[<span class="number">2</span>]()</span><br><span class="line"><span class="comment">-- &gt;&gt;&gt; 2</span></span><br></pre></td></tr></table></figure><p>伪随机数的生成</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 因此“短时间内多次运行程序” 这样的需求下 os.time 还真不大好。可是又没有比 time 函数更方便的种子生成器， 怎么办呢？</span></span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="built_in">tostring</span>(<span class="built_in">os</span>.<span class="built_in">time</span>()):<span class="built_in">reverse</span>():<span class="built_in">sub</span>(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>, <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 就是把 time返回的数值字串倒过来（低位变高位）， 再取高位6位。 这样， 即使 time变化很小， 但是因为低位变了高位， 种子数值变化却很大，就可以使伪随机序列生成的更好一些</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lua学习&quot;&gt;&lt;a href=&quot;#lua学习&quot; class=&quot;headerlink&quot; title=&quot;lua学习&quot;&gt;&lt;/a&gt;lua学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;动态脚本语言，可嵌入C和C++，Lua负责逻辑，C、C++负责功能&lt;/p&gt;
&lt;p&gt;C编译，
      
    
    </summary>
    
    
      <category term="lua" scheme="https://nymrli.top/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Java课程第三次实验报告</title>
    <link href="https://nymrli.top/2019/06/03/Java%E8%AF%BE%E7%A8%8B%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>https://nymrli.top/2019/06/03/Java课程第三次实验报告/</id>
    <published>2019-06-03T13:21:19.000Z</published>
    <updated>2019-06-03T13:21:43.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java课程第三次实验报告"><a href="#Java课程第三次实验报告" class="headerlink" title="Java课程第三次实验报告"></a>Java课程第三次实验报告</h1><p>\1. 在前面实验二已定义的学生类Student的基础上，以Student类为父类，为学生类派生出一个子类为大学生类（CollegeStudent）。</p><p>CollegeStudent 类在学生类上增加一个专业（profession）数据属性；方法上增加获得专业和设置专业两个方法。并对超类中的toString( )方法进行重写，使得CollegeStudent类中的toString( )方法除了显示学生类的信息外，还要显示它的专业属性。</p><p>编写测试程序的主类。在主类中创建一个Student对象和CollegeStudent对象，并显示或修改这两个对象的属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package homework;  </span></span><br><span class="line"><span class="keyword">package</span> student ;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> UID;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> Boolean gender; <span class="comment">// G- B-  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt ;        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> UID,String name,Boolean gender,<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        cnt ++ ;  </span><br><span class="line">        <span class="keyword">this</span>.UID = UID;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.gender = gender;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@target</span> 获得私有参数 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getGender</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> gender;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUID</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> UID;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@target</span> 修改私有参数 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUID</span><span class="params">(<span class="keyword">int</span> uID)</span> </span>&#123;  </span><br><span class="line">        UID = uID;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(Boolean gender)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.gender = gender;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        System.out.println(<span class="string">"对象已被销毁"</span>);;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">if</span> (gender) <span class="keyword">return</span> <span class="string">"该同学的学号为："</span> + UID +<span class="string">"，姓名叫："</span> + name + <span class="string">"，性别：男"</span> + <span class="string">"，年龄："</span> + age;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"该同学的学号为："</span> + UID +<span class="string">"，姓名叫："</span> + name + <span class="string">"，性别：女"</span> + <span class="string">"，年龄："</span> + age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> cnt;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//新建立的CoolegeStudent对象  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeStudent</span> <span class="keyword">extends</span> <span class="title">Student</span></span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> String profession;  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  CollegeStudent(<span class="keyword">int</span> studentID, String name, Boolean sex, <span class="keyword">int</span> age, String profession) &#123;  </span><br><span class="line">      <span class="keyword">super</span>( studentID, name, sex, age );  </span><br><span class="line">      <span class="keyword">this</span>.profession = profession;  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getProfession</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> profession;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProfession</span><span class="params">(String profession)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">this</span>.profession = profession;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="string">"CollegeStudent&#123;"</span> +  </span><br><span class="line">               <span class="string">"profession='"</span> + profession + <span class="string">'\''</span> +  </span><br><span class="line">               <span class="string">"studentID='"</span> + <span class="keyword">super</span>.getUID() + <span class="string">'\''</span> +  </span><br><span class="line">               <span class="string">", name='"</span> + <span class="keyword">super</span>.getName() + <span class="string">'\''</span> +  </span><br><span class="line">               <span class="string">", sex='"</span> + <span class="keyword">super</span>.getGender() + <span class="string">'\''</span> +  </span><br><span class="line">               <span class="string">", age="</span> + <span class="keyword">super</span>.getAge() +  </span><br><span class="line">               <span class="string">'&#125;'</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>设计一个人员类（Person），其中包含一个方法pay，代表人员的工资支出。再从Person类派生出助教类（Assistant）、讲师类（Instructor）、副教授类（Assistant Professor）和教授类（Professor）。其中：工资支出=基本工资+授课时数*每课时兼课金。<br>但助教基本工资为800，每课时兼课金25，讲师基本工资为1000，每课时兼课金35，<br>副教授基本工资为1200，每课时兼课金40，教授基本工资为1400，每课时兼课金50。<br>1.将Person定义为抽象类，pay为抽象方法，设计程序实现多态性。<br>2.将Person定义为接口，设计程序实现多态性。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person写成类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> basic;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> hour;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> charge;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> basic, <span class="keyword">int</span> charge)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.basic = basic;  </span><br><span class="line">        <span class="keyword">this</span>.charge = charge;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;  </span><br><span class="line">        System.out.println( hour + <span class="string">"小时后的工资为"</span> + (basic + hour * charge) );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Assistant</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Assistant</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>( <span class="number">800</span>, <span class="number">25</span> );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Instructor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instructor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>( <span class="number">1000</span>, <span class="number">35</span> );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AssistantProfessor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AssistantProfessor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">super</span>( <span class="number">1200</span>, <span class="number">40</span> );  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Professor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Professor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>( <span class="number">1400</span>, <span class="number">50</span> );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Person写成抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> hour;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> hour)</span></span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assistant</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;  </span><br><span class="line">       System.out.println( hour + <span class="string">"小时后的工资为"</span> + (<span class="number">800</span> + hour * <span class="number">25</span>) );  </span><br><span class="line">  &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instructor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;  </span><br><span class="line">      System.out.println( hour + <span class="string">"小时后的工资为"</span> + (<span class="number">1000</span> + hour * <span class="number">35</span>) );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssistantProfessor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;  </span><br><span class="line">      System.out.println( hour + <span class="string">"小时后的工资为"</span> + (<span class="number">1200</span> + hour * <span class="number">40</span>) );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Professor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;  </span><br><span class="line">      System.out.println( hour + <span class="string">"小时后的工资为"</span> + (<span class="number">1400</span> + hour * <span class="number">50</span>) );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrli </span></span><br><span class="line"><span class="comment"> * 接口写法 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> hour)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">        </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Assistant</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;  </span><br><span class="line">            System.out.println( hour + <span class="string">"小时后的工资为"</span> + (<span class="number">800</span> + hour * <span class="number">25</span>) );  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Instructor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;  </span><br><span class="line">        System.out.println( hour + <span class="string">"小时后的工资为"</span> + (<span class="number">1000</span> + hour * <span class="number">35</span>) );  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AssistantProfessor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;  </span><br><span class="line">        System.out.println( hour + <span class="string">"小时后的工资为"</span> + (<span class="number">1200</span> + hour * <span class="number">40</span>) );  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Professor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;  </span><br><span class="line">        System.out.println( hour + <span class="string">"小时后的工资为"</span> + (<span class="number">1400</span> + hour * <span class="number">50</span>) );  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>从键盘输入两个数，进行相除，显示商。当输入串中含有非数字时或除数为0时，通过异常处理机制，使程序能正确运行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.InputMismatchException;  </span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">yichang</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);  </span><br><span class="line">            System.out.print( <span class="string">"请输入除数:"</span> );  </span><br><span class="line">            <span class="keyword">int</span> dividedNum = scanner.nextInt();  </span><br><span class="line">            System.out.print( <span class="string">"请输入被除数:"</span> );  </span><br><span class="line">            <span class="keyword">int</span> divNum = scanner.nextInt();  </span><br><span class="line">              </span><br><span class="line">            System.out.println( <span class="string">"计算结果："</span> + dividedNum / divNum );  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InputMismatchException e1) &#123;  </span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception  </span></span><br><span class="line">            System.out.println(<span class="string">"输入不为数字!"</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e2) &#123;  </span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception  </span></span><br><span class="line">            System.out.println(<span class="string">"不能除0!"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java课程第三次实验报告&quot;&gt;&lt;a href=&quot;#Java课程第三次实验报告&quot; class=&quot;headerlink&quot; title=&quot;Java课程第三次实验报告&quot;&gt;&lt;/a&gt;Java课程第三次实验报告&lt;/h1&gt;&lt;p&gt;\1. 在前面实验二已定义的学生类Student的基
      
    
    </summary>
    
    
      <category term="java" scheme="https://nymrli.top/tags/java/"/>
    
      <category term="NJUPT" scheme="https://nymrli.top/tags/NJUPT/"/>
    
  </entry>
  
  <entry>
    <title>南京邮电大学java程序设计作业在线编程第八次作业</title>
    <link href="https://nymrli.top/2019/06/03/%E5%8D%97%E4%BA%AC%E9%82%AE%E7%94%B5%E5%A4%A7%E5%AD%A6java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E7%AC%AC%E5%85%AB%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    <id>https://nymrli.top/2019/06/03/南京邮电大学java程序设计作业在线编程第八次作业/</id>
    <published>2019-06-03T13:20:12.000Z</published>
    <updated>2019-06-03T13:20:49.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总分：100"><a href="#总分：100" class="headerlink" title="总分：100"></a>总分：100</h2><h3 id="选择题得分：70"><a href="#选择题得分：70" class="headerlink" title="选择题得分：70"></a>选择题得分：70</h3><ul><li><ol><li><code>int[][] a=new int[2</code>][3]，则该数组包含（ ）个数组元素。<br>A.2<br>B.3<br>C.6<br>D.不确定<br>正确答案是: C</li></ol></li><li><ol start="2"><li>已知类person是类student的父类，以下数组定义和赋值正确的是( )。<br>A.person p[]=new person[3]; p[1]=new student();<br>B.student s[]=new person[3]; s[1]=new person();<br>C.person p[]= new student[3];p[1]= new person();<br>D.student s[]=new student[3];s[1]=new person;<br>正确答案是: A</li></ol></li><li><ol start="3"><li>下面关于java中类的说法不正确的是( )。<br>A.类体中包含了变量定义和成员方法的定义<br>B.构造函数是类中的特殊方法<br>C.类一定要声明为public的，才可以执行<br>D.一个java文件中可以有多个class定义<br>正确答案是: C</li></ol></li><li><ol start="4"><li>关于接口下列说法正确的( )。<br>A.实现一个接口必须实现接口的所有方法<br>B.接口间不能有继承关系<br>C.一个类只能实现一个接口<br>D.接口和抽象类是同一回事<br>正确答案是: A</li></ol></li><li><ol start="5"><li>以下有关构造方法的说法，正确的是( )。<br>A.一个类的构造方法可以有多个<br>B.构造方法不可以重载<br>C.构造方法可以有返回值<br>D.构造方法可以和类同名，也可以和类名不同<br>正确答案是: A</li></ol></li><li><ol start="6"><li>下列论述中，错误的是（ ）。<br>A.Java源代码的后缀名是.java。<br>B.Java源代码中的每个类经过编译后都会生成一个.class文件。<br>C.在一个名为A.java的文件中只能定义一个类。<br>D.Java源代码中可以定义类和接口。<br>正确答案是: C</li></ol></li><li><ol start="7"><li>下列论述中，正确的是（ ）。<br>A.抽象方法是没有方法体的方法。<br>B.抽象方法一定存在于抽象类中。<br>C.抽象类中一定要包含抽象方法。<br>D.抽象类可以创建对象。<br>正确答案是: A</li></ol></li><li><ol start="8"><li>MyClass类定义如下： class MyClass{ public MyClass(int x){ } } 如下方式创建对象，（ ）是正确的<br>A.MyClass myobj=new Myclass;<br>B.MyClass myobj=new Myclass();<br>C.MyClass myobj=new Myclass(1);<br>D.MyClass myobj=new Myclass(1,2);<br>正确答案是: C</li></ol></li><li><ol start="9"><li>关于方法void fjv(int x,int y){}，下面（ ）不能成为它的重载。<br>A.void fjv(int x,float y){}<br>B.void fjv(int x){}<br>C.void fjv(float x,int y){}<br>D.int fjv(int y,int x){}<br>正确答案是: D</li></ol></li><li><ol start="10"><li>下述（ ）说法是不正确的<br>A.实例变量是用static关键字声明的；<br>B.实例变量是类的成员变量；<br>C.方法变量可在方法执行时创建；<br>D.方法变量在使用之前必须初始化；<br>正确答案是: A</li></ol></li><li><ol start="11"><li>如果一个方法被修饰为<strong>____</strong>方法，则这个方法不能被重写。<br>A.final<br>B.static<br>C.void<br>D.protected<br>正确答案是: A</li></ol></li><li><ol start="12"><li>在Java中，下面说法正确的是（ ）。<br>A.一个子类可以有多个父类，一个父类也可以有多个子类<br>B.一个子类可以有多个父类，但一个父类只可以有一个子类<br>C.一个子类可以有一个父类，但一个父类可以有多个子类<br>D.上述说法都不对<br>正确答案是: C</li></ol></li><li><ol start="13"><li><strong><strong>___</strong></strong>变量在内存中只有一个拷贝，被该类的所有对象共享。<br>A.成员<br>B.局部<br>C.全局<br>D.类<br>正确答案是: D</li></ol></li><li><ol start="14"><li>MAX_LENGTH是int型public成员变量, 变量值保持为常量100，下面哪句定义语句是正确的。<br>A.public int MAX_LENGTH=100;<br>B.final int MAX_LENGTH=100;<br>C.final public int MAX_LENGTH=100;<br>D.public final int MAX_LENGTH=100;<br>正确答案是: D</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写Main类，生成若干实例并验证程序的功能，请勿改动Main类的定义内容。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pet pet=<span class="keyword">new</span> Dog(<span class="string">"WangCai"</span>);</span><br><span class="line">        System.out.println(pet.getName()+<span class="string">":"</span>+pet.shout());</span><br><span class="line">        pet=<span class="keyword">new</span> Cat(<span class="string">"XiaoHua"</span>);</span><br><span class="line">        System.out.println(pet.getName()+<span class="string">":"</span>+pet.shout());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请在本行之后添加你的代码内容</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        setName( name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wang Wang Wang"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line">    Cat(String name) &#123;</span><br><span class="line">        setName( name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Miao Miao Miao"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总分：100&quot;&gt;&lt;a href=&quot;#总分：100&quot; class=&quot;headerlink&quot; title=&quot;总分：100&quot;&gt;&lt;/a&gt;总分：100&lt;/h2&gt;&lt;h3 id=&quot;选择题得分：70&quot;&gt;&lt;a href=&quot;#选择题得分：70&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="java" scheme="https://nymrli.top/tags/java/"/>
    
      <category term="NJUPT" scheme="https://nymrli.top/tags/NJUPT/"/>
    
  </entry>
  
  <entry>
    <title>Windows下命令行神器cmder</title>
    <link href="https://nymrli.top/2019/06/03/Windows%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A5%9E%E5%A5%87cmder/"/>
    <id>https://nymrli.top/2019/06/03/Windows下命令行神奇cmder/</id>
    <published>2019-06-03T13:17:28.000Z</published>
    <updated>2019-06-03T13:17:54.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cmder"><a href="#Cmder" class="headerlink" title="Cmder"></a>Cmder</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://cmder.net/" target="_blank" rel="noopener">http://cmder.net/</a> 有两个版本，分别是mini与full版</p><ul><li>mini 没有内建msysgit工具，这是Git for Windows的标准配备；</li><li>全安装版 cmder 自带了 msysgit, 压缩包 108M</li><li>除了 git 本身这个命令之外, 里面可以使用大量的 linux 命令；比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl</li><li>可以交叉使用 <a href="http://www.cygwin.com/" target="_blank" rel="noopener">cygwin</a> 的部分增强命令</li></ul><h2 id="把-cmder-加到环境变量"><a href="#把-cmder-加到环境变量" class="headerlink" title="把 cmder 加到环境变量"></a>把 cmder 加到环境变量</h2><p>将解压后的文件夹路径加入到系统环境变量的Path中</p><h2 id="添加-cmder-到右键菜单"><a href="#添加-cmder-到右键菜单" class="headerlink" title="添加 cmder 到右键菜单"></a>添加 cmder 到右键菜单</h2><p>配置环境变量后，在<strong>管理员权限</strong>的终端输入以下语句</p><blockquote><p>Win 8 或者 Win10 可以直接 <code>win+x</code> 再按 <code>a</code> 键进入</p><p>或者在开始中输入<strong>命令</strong>，然后在弹出的<strong>最佳匹配</strong>中，选择<strong>命令行工具右键</strong>-&gt;以管理员身份打开</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cmder.exe /REGISTER ALL</span><br></pre></td></tr></table></figure><h2 id="修改命令提示符号"><a href="#修改命令提示符号" class="headerlink" title="修改命令提示符号"></a>修改命令提示符号</h2><h3 id="1-3-之后版本"><a href="#1-3-之后版本" class="headerlink" title="1.3 之后版本"></a>1.3 之后版本</h3><p>修改文件 <code>${CMDER_HOME}\vendor\clink.lua</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if env == nil then</span><br><span class="line">    lambda = &quot;λ&quot;</span><br><span class="line">else</span><br><span class="line">    lambda = &quot;(&quot;..env..&quot;) λ&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if env == nil then</span><br><span class="line">    lambda = &quot;$&quot;</span><br><span class="line">else</span><br><span class="line">    lambda = &quot;(&quot;..env..&quot;) $&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>其他符号也行，看你自己的喜好</p></blockquote><h3 id="1-3-以前版本"><a href="#1-3-以前版本" class="headerlink" title="1.3 以前版本"></a>1.3 以前版本</h3><p>编辑Cmder安装目录下的 <code>vendor\init.bat</code> 批处理文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@prompt $E[1;32;40m$P$S&#123;git&#125;&#123;hg&#125;$S$_$E[1;30;40m &#123;lamb&#125; $S$E[0m</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@prompt $E[1;32;40m$P$S&#123;git&#125;&#123;hg&#125;$S$_$E[1;30;40m $$ $S$E[0m</span><br></pre></td></tr></table></figure><p><code>PowerShell.exe</code> 需要另外设置</p><p>打开文件 <code>config/cmder.lua</code>（<code>prompt.lua</code> 也有版本是这个），将第二行中的<strong>λ</strong>修改为<strong>$</strong></p><h2 id="新标签打开个管理员权限终端"><a href="#新标签打开个管理员权限终端" class="headerlink" title="新标签打开个管理员权限终端"></a>新标签打开个管理员权限终端</h2><p>快捷键 Ctrl + t 后勾选<code>Run as administrator</code></p><h2 id="设置默认终端"><a href="#设置默认终端" class="headerlink" title="设置默认终端"></a>设置默认终端</h2><p>如果你有其它的command希望通过 Cmder 打开，可以在 <code>Startup</code> 下的 <code>Tasks</code> 中添加。里面已经默认帮你配置了 <code>Cmder</code>、<code>PowerShell</code>、<code>MinTTY</code>、<code>Git Bash</code>。</p><p>默认启动的是 Cmder ，如果你想默认启动其它的command，你可以在 <code>Startup</code> 设置为其它的command<br><img src="https://s1.ax1x.com/2018/03/08/92aKJO.png" alt="设置默认终端"></p><p>同时还可以快速的切换当前使用的终端，假设你正在使用的 <code>cmd</code> ，这时输入 <code>bash</code> 回车一下，便可以将当前标签页的终端切换成 <code>Git Bash</code></p><h2 id="中文和命令ll支持"><a href="#中文和命令ll支持" class="headerlink" title="中文和命令ll支持"></a>中文和命令ll支持</h2><ul><li>Cmder 是不支持中文，这需要你在 <code>Startup</code> 下的 <code>Environment</code> 中设置一下。将 <code>set LANG=zh_CN.UTF-8</code> </li><li>cmder原生没有 <strong>ll</strong> 命令，但可以通过设置别名来实现：打开cmder安装目录下的<code>\config\user-aliases.cmd</code>文件，添加以下别名设置：</li></ul><h2 id="Chocolatey软件包管理系统"><a href="#Chocolatey软件包管理系统" class="headerlink" title="Chocolatey软件包管理系统"></a><a href="https://chocolatey.org/" target="_blank" rel="noopener">Chocolatey</a>软件包管理系统</h2><p>chocolatey 是windows 下面的 yum brew 这种包管理器<br> 运行如下命令(需要管理员权限)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin</span><br></pre></td></tr></table></figure><p>安装软件命令 <code>choco install softwareName</code>,</p><ul><li>短写是 <code>cinst softwareName</code> </li></ul><p>查询安装包是否存在 <code>clist softwareName</code></p><p><a href="https://chocolatey.org/packages" target="_blank" rel="noopener">可安装包列表</a></p><h3 id="window下常用的开发环境应用"><a href="#window下常用的开发环境应用" class="headerlink" title="window下常用的开发环境应用"></a>window下常用的开发环境应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">choco install autohotkey.portable    #安装 AutoHotkey (Portable)</span><br><span class="line">choco install nodejs.install  #安装 node</span><br><span class="line">choco install git.install     #安装 git</span><br><span class="line">choco install python          #安装 python</span><br><span class="line">choco install ruby            #安装 ruby</span><br><span class="line">choco install jdk8            #安装 JDK8</span><br><span class="line">choco install googlechrome    #安装 Chrome</span><br><span class="line">choco install google-chrome-x64 #Google Chrome (64-bit only)</span><br><span class="line">choco install firefox         #安装 firefox</span><br><span class="line">choco install notepadplusplus.install #安装 notepad++</span><br><span class="line">choco install Atom                    #安装 Atom</span><br><span class="line">choco install SublimeText3            #安装 SublimeText3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cmder&quot;&gt;&lt;a href=&quot;#Cmder&quot; class=&quot;headerlink&quot; title=&quot;Cmder&quot;&gt;&lt;/a&gt;Cmder&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安
      
    
    </summary>
    
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="安利" scheme="https://nymrli.top/tags/%E5%AE%89%E5%88%A9/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号Pyhton</title>
    <link href="https://nymrli.top/2019/05/27/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7Pyhton/"/>
    <id>https://nymrli.top/2019/05/27/微信公众号Pyhton/</id>
    <published>2019-05-27T14:01:10.000Z</published>
    <updated>2019-05-27T14:02:21.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信公众号Pyhton开发"><a href="#微信公众号Pyhton开发" class="headerlink" title="微信公众号Pyhton开发"></a>微信公众号Pyhton开发</h1><h2 id="编写上传代码到SAE"><a href="#编写上传代码到SAE" class="headerlink" title="编写上传代码到SAE"></a>编写上传代码到SAE</h2><p>1.申请SAE（sina application enginer），创建应用，<a href="https://www.sinacloud.com/doc/sae/tutorial/code-deploy.html#shi-yong-git-ke-hu-duan" target="_blank" rel="noopener">SAE使用文档</a></p><p>2.编写上传代码</p><p>weixin.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">import</span> web </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> hashlib </span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeixinInterface</span>:</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.app_root=os.path.dirname(__file__)</span><br><span class="line">self.templates_root=os.path.join(self.app_root,<span class="string">'templates'</span>)</span><br><span class="line">self.render=web.template.render(self.templates_root)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(self)</span>:</span> </span><br><span class="line">data=web.input()</span><br><span class="line">signature=data.signature</span><br><span class="line">timestamp=data.timestamp </span><br><span class="line">nonce=data.nonce </span><br><span class="line">echostr=data.echostr </span><br><span class="line">token=<span class="string">"wxpython"</span></span><br><span class="line"></span><br><span class="line">l=[token,timestamp,nonce]</span><br><span class="line">l.sort()</span><br><span class="line">sha1=hashlib.sha1()</span><br><span class="line">map(sha1.update,l)</span><br><span class="line">hashcode=sha1.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hashcode == signature:</span><br><span class="line"><span class="keyword">return</span> echostr</span><br></pre></td></tr></table></figure><p>index.wsgi</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#-*-coding:utf-8-*-</span><br><span class="line"></span><br><span class="line">import os </span><br><span class="line">import sae</span><br><span class="line">import web </span><br><span class="line">from weixin import WeixinInterface </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urls=(</span><br><span class="line">&apos;/weixin&apos;,&apos;WeixinInterface&apos;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app_root=os.path.dirname(__file__)</span><br><span class="line">templates_root=os.path.join(app_root,&apos;templates&apos;)</span><br><span class="line">render=web.template.render(templates_root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app=web.application(urls,globals()).wsgifunc()</span><br><span class="line">application=sae.create_wsgi_app(app)</span><br></pre></td></tr></table></figure><p>config.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">wxpytest</span> </span><br><span class="line"><span class="attr">version:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">libraries:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">webpy</span> </span><br><span class="line"><span class="attr">  version:</span> <span class="string">"0.36"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">lxml</span> </span><br><span class="line"><span class="attr">  version:</span> <span class="string">"2.3.4"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>​    </p><p>3.微信公众号修改服务器配置</p><p><img src="/2019/05/27/微信公众号Pyhton/weixin.png" alt="weixin"></p><p>Token与代码中编写的保持一致，URL也要与指定的一致(即<code>...\weixin</code>)。</p><p>注意直接访问<code>&lt;http://vxquan.applinzi.com/weixin&gt;</code>是会报错的，但是可以通过微信公众平台的认证（因为直接访问是没有参数的，data=web.input没有异常处理）</p><h2 id="处理普通文本信息"><a href="#处理普通文本信息" class="headerlink" title="处理普通文本信息"></a>处理普通文本信息</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1348831860<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[this is a test]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>1234567890123456<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>▲.注意这边的OpenID不是真正的用户ID，不同公众号对相同用户获得的OpenID是不同的，换言之，这个只是该公众号能获得该用户的一个ID。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">POST</span><span class="params">(self)</span>:</span> </span><br><span class="line">str_xml=web. data()</span><br><span class="line">xml=etree.fromstring(str_xml)</span><br><span class="line">msgType=xml.find(<span class="string">"MsgType"</span>).text </span><br><span class="line">fromuser=xml.find(<span class="string">"FromUserName"</span>).text </span><br><span class="line">touser=xml.find(<span class="string">"ToUserName"</span>).text </span><br><span class="line"><span class="keyword">if</span> msgType==<span class="string">"text"</span>: </span><br><span class="line">content=xml. find(<span class="string">"Content"</span>).text</span><br><span class="line"><span class="keyword">return</span> self.render.reply_text(fromuser,touser,int(time.time()),content)</span><br><span class="line">    <span class="comment"># 注意这边To和from的改变，服务器(发送)--&gt;wx后台--&gt;用户(接收)</span></span><br></pre></td></tr></table></figure><p>记遇到的坑：</p><ul><li>1.POST好像必须要有处理，返回信息</li><li><ol start="2"><li>python2.7下字符串加u</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;微信公众号Pyhton开发&quot;&gt;&lt;a href=&quot;#微信公众号Pyhton开发&quot; class=&quot;headerlink&quot; title=&quot;微信公众号Pyhton开发&quot;&gt;&lt;/a&gt;微信公众号Pyhton开发&lt;/h1&gt;&lt;h2 id=&quot;编写上传代码到SAE&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="环境部署" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
      <category term="Web" scheme="https://nymrli.top/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>DigitalOcean VPS注册</title>
    <link href="https://nymrli.top/2019/05/27/DigitalOcean-VPS%E6%B3%A8%E5%86%8C/"/>
    <id>https://nymrli.top/2019/05/27/DigitalOcean-VPS注册/</id>
    <published>2019-05-27T13:57:56.000Z</published>
    <updated>2019-05-27T13:59:17.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DigitalOcean-VPS搭梯子"><a href="#DigitalOcean-VPS搭梯子" class="headerlink" title="DigitalOcean VPS搭梯子"></a>DigitalOcean VPS搭梯子</h1><h2 id="DigitalOcean-VPS注册"><a href="#DigitalOcean-VPS注册" class="headerlink" title="DigitalOcean VPS注册"></a>DigitalOcean VPS注册</h2><p>首先通过 邀请链接(<a href="https://m.do.co/c/e89da76f57f2" target="_blank" rel="noopener">https://m.do.co/c/e89da76f57f2</a>)点进去<strong>注册</strong>，双方都会获得\$10奖励（注意是注册，我当时就没注意到，少了10\$</p><p>然后在<a href="https://education.github.com/pack" target="_blank" rel="noopener">Github Education</a>申请学生优惠，注意这边的学生优惠邮箱是校园邮箱(<a href="mailto:xxxx@njupt.edu.cn" target="_blank" rel="noopener">xxxx@njupt.edu.cn</a>)那个。我当时是将github账号与校园邮箱进行链接的。</p><p>学生优惠申请到后，pack界面会变成这样</p><p><img src="/2019/05/27/DigitalOcean-VPS注册/1.png" alt="1"></p><p>进入DO的页面后，用学校邮箱注册后，选用Paypal支付（先注册好Paypal），然后支付即可。</p><p>▲由于一开始我并没有使用学校邮箱注册，而是QQ邮箱，后来又注册了以后，发现这个账号被锁了，付的$5也退了回来。按网上的说法，DO会直接锁了我的账号，原因是一个人注册了多个账号。于是找解决方案。</p><p>网上说要发邮件，其中比较关键的是Ticket，一开始一直没找到，后来才发现这个是在<code>support</code>中选出来的.</p><p>等了一天最终收到的答复却是：</p><p><img src="/2019/05/27/DigitalOcean-VPS注册/reply.png" alt="reply"></p><blockquote><p>我们检查了该帐户，发现它符合与违反我们的服务条款和可接受使用策略相关的异常模式。虽然我们无法提供所观察到的特定标志的详细信息，但我们已经确定，恢复对该帐户的访问是不可能的。不便之处，敬请原谅。</p></blockquote><p>最终无奈之下，想起了使用的话跟学校邮箱没关系，那个只是提供优惠券的。于是重新尝试了下第一个注册的账号pay了$5以后就成功了。</p><h2 id="创建主机"><a href="#创建主机" class="headerlink" title="创建主机"></a>创建主机</h2><p><a href="https://blog.ooolg.com/index.php/20181125/131=131.html" target="_blank" rel="noopener"><a href="https://blog.ooolg.com/index.php/20181125/131=131.html" target="_blank" rel="noopener">搭建SSR科学上网（利用DigitalOcean服务器）</a></a></p><h2 id="使用优惠券"><a href="#使用优惠券" class="headerlink" title="使用优惠券"></a>使用优惠券</h2><p><a href="https://www.mf8.biz/digitalocean-github-pack/" target="_blank" rel="noopener">DigitalOcean 的学生包代金券使用教程</a></p><p><img src="/2019/05/27/DigitalOcean-VPS注册/billing.png" alt="billing"></p><p><img src="https://pics.mf8.biz/mf8/ex5gw.jpg" alt=""></p><p>输入<a href="https://education.github.com/pack" target="_blank" rel="noopener">Github Education</a>上获得的优惠券Code，就能拿到$50的优惠券了</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="ubuntu一键更换内核-安装锐速-16-04-14-04可用"><a href="#ubuntu一键更换内核-安装锐速-16-04-14-04可用" class="headerlink" title="ubuntu一键更换内核 安装锐速 - 16.04 14.04可用"></a><a href="https://www.jianshu.com/p/19ab389820ef" target="_blank" rel="noopener">ubuntu一键更换内核 安装锐速 - 16.04 14.04可用</a></h3><h3 id="PAC和全局模式"><a href="#PAC和全局模式" class="headerlink" title="PAC和全局模式"></a>PAC和全局模式</h3><p>1.在全局模式下，所有的网站都默认走代理（使你的所有http/socks数据经过代理服务器的转发送出。）</p><p>2.在PAC模式是只有被墙了的网站才会走代理（连接网站的时候读取PAC文件里的规则，来确定你访问的网站有没有被墙，如果符合，那就会使用代理服务器连接网站）</p><h3 id="优惠网站"><a href="#优惠网站" class="headerlink" title="优惠网站"></a>优惠网站</h3><p><a href="https://xianhuo.org/2016digitalocean-youhuima.html" target="_blank" rel="noopener">https://xianhuo.org/2016digitalocean-youhuima.html</a>  未测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DigitalOcean-VPS搭梯子&quot;&gt;&lt;a href=&quot;#DigitalOcean-VPS搭梯子&quot; class=&quot;headerlink&quot; title=&quot;DigitalOcean VPS搭梯子&quot;&gt;&lt;/a&gt;DigitalOcean VPS搭梯子&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="生活福利" scheme="https://nymrli.top/tags/%E7%94%9F%E6%B4%BB%E7%A6%8F%E5%88%A9/"/>
    
  </entry>
  
  <entry>
    <title>PyWinAuto使用</title>
    <link href="https://nymrli.top/2019/05/27/PyWinAuto%E4%BD%BF%E7%94%A8/"/>
    <id>https://nymrli.top/2019/05/27/PyWinAuto使用/</id>
    <published>2019-05-27T13:54:45.000Z</published>
    <updated>2019-05-27T13:55:06.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PyWinAuto使用"><a href="#PyWinAuto使用" class="headerlink" title="PyWinAuto使用"></a>PyWinAuto使用</h2><p>简单操作示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = application.Application().start(<span class="string">r'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe'</span>)</span><br><span class="line"><span class="comment"># app = application.Application().start('notepad.exe')</span></span><br></pre></td></tr></table></figure><h3 id="一-判断程序的backend"><a href="#一-判断程序的backend" class="headerlink" title="(一) 判断程序的backend"></a>(一) 判断程序的backend</h3><p>注意，首先需要判断你要进行的程序是用什么语言写的，在实例化的时候会有区别，主要是判断backend是什么。 </p><p><img src="https://img-blog.csdn.net/20171007160746542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhd3Bhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><h3 id="二-确定自动化入口点"><a href="#二-确定自动化入口点" class="headerlink" title="(二)确定自动化入口点"></a>(二)确定自动化入口点</h3><p>这里主要是限制自动化控制进程的范围。如一个程序有多个实例，自动化控制一个实例，而保证其他实例(进程)不受影响。<br>主要有两种对象可以建立这种入口点——Application() , Desktop(). </p><ul><li>Application的作用范围是一个进程，如一般的桌面应用程序都为此类。 </li><li>Desktop的作用范围可以跨进程。主要用于像win10的计算器这样包含多个进程的程序。这种目前比较少见。使用方法见<a href="https://pywinauto.readthedocs.io/en/latest/getting_started.html#entry-points-for-automation" target="_blank" rel="noopener">entry-points-for-automation</a></li></ul><h3 id="三-连接到进程"><a href="#三-连接到进程" class="headerlink" title="(三)连接到进程"></a>(三)连接到进程</h3><p>建立好入口后，我们需要连接到进程中。这里有两种方法: </p><ul><li>使用Application对象的start()方法</li></ul><p><code>app = Application().start(r&quot;D:\Program Files (x86)\tlxsoft\屏幕录像专家 共享版 V2017\屏录专家.exe&quot;)</code></p><ul><li>连接到已有的进程。使用Application对象的connect()方法。这个方法对已有进程的绑定非常灵活。</li></ul><p><code>app = Application().connect(process=19188)</code></p><ul><li>使用窗口句柄绑定</li></ul><p>app = Application().connect(handle=0x00230DB6)</p><ul><li>使用程序路径绑定★</li></ul><p><code>app = Application().connect(path=r&quot;D:\Program Files (x86)\tlxsoft\屏幕录像专家 共享版 V2017\屏录专家.exe&quot;)</code></p><ul><li>使用标题、类型等匹配★★（灵活性比较高）</li></ul><p><code>app = Application().connect(title_re=&quot;屏幕录像专家.*&quot;, class_name=&quot;TMainForm&quot;)</code></p><hr><h3 id="菜单操作"><a href="#菜单操作" class="headerlink" title="菜单操作"></a>菜单操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dlg_spec = app.window(title=<span class="string">'屏幕录像专家 V2017'</span>)</span><br><span class="line">dlg_spec.menu_select(<span class="string">r"转换工具-&gt;EXE/LXE转成MP4"</span>)</span><br></pre></td></tr></table></figure><h3 id="快捷键操作"><a href="#快捷键操作" class="headerlink" title="快捷键操作"></a>快捷键操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dlg_spec = app.window(title=<span class="string">'屏幕录像专家 V2017'</span>)</span><br><span class="line">dlg_spec.type_keys(<span class="string">'%TP'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SHIFT                            +      </span><br><span class="line">CTRL                             ^      </span><br><span class="line">ALT                               %</span><br><span class="line">空格键                            &#123;SPACE&#125;</span><br><span class="line"> </span><br><span class="line">BACKSPACE                        &#123;BACKSPACE&#125;、&#123;BS&#125;   or   &#123;BKSP&#125;      </span><br><span class="line">BREAK                            &#123;BREAK&#125;      </span><br><span class="line">CAPS   LOCK                      &#123;CAPSLOCK&#125;      </span><br><span class="line">DEL   or   DELETE                &#123;DELETE&#125;   or   &#123;DEL&#125;      </span><br><span class="line">DOWN   ARROW                     &#123;DOWN&#125;      </span><br><span class="line">END                              &#123;END&#125;      </span><br><span class="line">ENTER                            &#123;ENTER&#125;   or   ~      </span><br><span class="line">ESC                              &#123;ESC&#125;      </span><br><span class="line">HELP                             &#123;HELP&#125;      </span><br><span class="line">HOME                             &#123;HOME&#125;      </span><br><span class="line">INS   or   INSERT                &#123;INSERT&#125;   or   &#123;INS&#125;      </span><br><span class="line">LEFT   ARROW                     &#123;LEFT&#125;      </span><br><span class="line">NUM   LOCK                       &#123;NUMLOCK&#125;      </span><br><span class="line">PAGE   DOWN                      &#123;PGDN&#125;      </span><br><span class="line">PAGE   UP                        &#123;PGUP&#125;      </span><br><span class="line">PRINT   SCREEN                   &#123;PRTSC&#125;      </span><br><span class="line">RIGHT   ARROW                    &#123;RIGHT&#125;      </span><br><span class="line">SCROLL   LOCK                    &#123;SCROLLLOCK&#125;      </span><br><span class="line">TAB                              &#123;TAB&#125;      </span><br><span class="line">UP   ARROW                       &#123;UP&#125;     </span><br><span class="line">+                                &#123;ADD&#125;      </span><br><span class="line">-                                &#123;SUBTRACT&#125;      </span><br><span class="line">*                                &#123;MULTIPLY&#125;      </span><br><span class="line">/                                &#123;DIVIDE&#125;</span><br><span class="line">F1                               &#123;F1&#125; </span><br><span class="line">F2                               &#123;F2&#125; </span><br><span class="line">F3                               &#123;F3&#125; </span><br><span class="line">.....</span><br><span class="line">F15                             &#123;F15&#125; </span><br><span class="line">F16                             &#123;F16&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/qq_37193537/article/details/81207907" target="_blank" rel="noopener">pywinauto 使用</a></p><p><a href="https://www.cnblogs.com/mapu/p/9235587.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/mapu/p/9235587.html" target="_blank" rel="noopener">python自动化工具之pywinauto</a></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PyWinAuto使用&quot;&gt;&lt;a href=&quot;#PyWinAuto使用&quot; class=&quot;headerlink&quot; title=&quot;PyWinAuto使用&quot;&gt;&lt;/a&gt;PyWinAuto使用&lt;/h2&gt;&lt;p&gt;简单操作示例：&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="自动化运维" scheme="https://nymrli.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
</feed>
