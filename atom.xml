<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>果粒橙的博客</title>
  
  <subtitle>别装作很努力，结局不会陪你演戏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nymrli.top/"/>
  <updated>2019-08-30T13:47:00.441Z</updated>
  <id>https://nymrli.top/</id>
  
  <author>
    <name>果粒橙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习——决策树</title>
    <link href="https://nymrli.top/2019/08/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>https://nymrli.top/2019/08/30/机器学习——决策树/</id>
    <published>2019-08-30T13:44:35.000Z</published>
    <updated>2019-08-30T13:47:00.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习——决策树"><a href="#机器学习——决策树" class="headerlink" title="机器学习——决策树"></a>机器学习——决策树</h1><h2 id="决策树基础概念"><a href="#决策树基础概念" class="headerlink" title="决策树基础概念"></a>决策树基础概念</h2><blockquote><p>决策树分为分类树和回归树两种，分类树对离散变量做决策树，回归树对连续变量做决策树。</p><p>每个<strong>内部节点（非叶子节点）</strong>表示一个属性上的测试条件，每个<strong>分支</strong>代表一个测试输出结果，每个<strong>叶节点</strong>代表一种类别</p></blockquote><p>决策树分为分类树和回归树两种，分类树对离散变量做决策树，回归树对连续变量做决策树。</p><p>决策树的构造过程就是找到这些具有决定性作用的特征，根据其决定性程度来构造一个倒立的树–决定性作用最大的那个特征作为根节点，然后递归找到各分支下子数据集中次大的决定性特征，直至子数据集中所有数据都属于同一类。</p><p>特征：</p><ul><li>有监督的学习</li><li>非参数学习算法</li><li>自顶向下递归方式构造决策树</li><li>在每一步选择中都采取在当前状态下最好/优的选择</li></ul><h2 id="决策树生成过程"><a href="#决策树生成过程" class="headerlink" title="决策树生成过程"></a>决策树生成过程</h2><p>一棵决策树的生成过程主要分为以下3个部分:</p><ul><li><strong>特征选择</strong>：特征选择是指从训练数据中众多的特征中选择一个特征作为当前节点的分裂标准，如何选择特征有着很多不同量化评估标准标准，从而衍生出不同的决策树算法。</li><li><strong>决策树生成</strong>： 根据选择的特征评估标准，从上至下递归地生成子节点，直到数据集不可分则停止决策树停止生长。 树结构来说，递归结构是最容易理解的方式。</li><li><strong>剪枝</strong>：决策树容易过拟合，一般来需要剪枝，缩小树结构规模、缓解过拟合。剪枝技术有预剪枝和后剪枝两种。</li></ul><h2 id="基于信息论的三种决策树算法"><a href="#基于信息论的三种决策树算法" class="headerlink" title="基于信息论的三种决策树算法"></a>基于信息论的三种决策树算法</h2><blockquote><p>划分数据集的最大原则是：使无序的数据变的有序。</p><p>熵降低的速度越快越好==&gt;树的高度最矮</p></blockquote><p>基于信息论的决策树算法有ID3、CART和C4.5等算法，其中C4.5和CART两种算法从ID3算法中衍生而来。</p><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><ul><li>信息增益作为评估标准，分支节点选择特征X信息增益最大的</li></ul><p>可用于划分标称型数据集，<strong>没有剪枝的过程</strong>，为了去除过度数据匹配的问题，可通过裁剪合并相邻的无法产生大量信息增益的叶子节点（例如设置信息增益阀值）。使用信息增益的话，其实是有一个缺点，那就是它<strong>偏向于具有大量值的属性</strong>–就是说在训练集中，某个属性所取的不同值的个数越多，那么越有可能拿它来作为分裂属性</p><h3 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h3><p>C4.5是ID3的一个改进算法，继承了ID3算法的优点。</p><ul><li><strong>C4.5算法用信息增益率来选择属性</strong>，</li><li>克服了用信息增益选择属性时偏向选择取值多的属性的不足在树构造过程中进行<strong>剪枝</strong>；</li><li>能够完成对<strong>连续属性的离散化处理</strong>；<strong>能够对不完整数据进行处理</strong>。</li></ul><h3 id="CART算法（Classification-And-Regression-Tree）"><a href="#CART算法（Classification-And-Regression-Tree）" class="headerlink" title="CART算法（Classification And Regression Tree）"></a>CART算法（Classification And Regression Tree）</h3><ul><li><strong>采用的是Gini指数（选Gini指数最小的特征s）</strong>作为分裂标准</li><li>同时它也是包含<strong>后剪枝</strong>操作</li><li>ID3和C4.5虽可尽可能挖掘数据信息，但生成的决策树分支较大。CART可以简化决策树的规模，提高生成决策树的效率</li></ul><h2 id="决策树优缺点"><a href="#决策树优缺点" class="headerlink" title="决策树优缺点"></a>决策树优缺点</h2><p>决策树适用于数值型和标称型（离散型数据，变量的结果只在有限目标集中取值），能够读取数据集合，提取一些列数据中蕴含的规则。在分类问题中使用决策树模型有很多的优点，1.决策树<strong>计算复杂度不高</strong>、便于使用、而且高效，2.决策树<strong>可处理具有不相关特征的数据</strong>、3.可很容易地构造出易于理解的规则，而<strong>规则通常易于解释和理解</strong>。</p><p>决策树模型也有一些缺点，比如1.处理<strong>缺失数据</strong>时的困难、2.<strong>过度拟合</strong>以及3.<strong>忽略数据集中属性之间的相关性</strong>等。</p><h2 id="ID3数学原理"><a href="#ID3数学原理" class="headerlink" title="ID3数学原理"></a>ID3数学原理</h2><h3 id="信息熵-香农熵-："><a href="#信息熵-香农熵-：" class="headerlink" title="信息熵(香农熵)："></a>信息熵(香农熵)：</h3><blockquote><p>一种度量不确定性的方式，是用来衡量随机变量不确定性的，熵就是信息的期望值</p></blockquote><p>如果待分类的事物可能划分在多个分类之中，则符号xi的信息定义为$\mathrm{I}\left(x_{i}\right)=-\log <em>{2} p\left(x</em>{i}\right)$，其中p(xi)是选择该分类的概率。</p><p>有人可能会问，信息为啥这样定义啊？答曰：前辈得出的结论。这就跟1+1等于2一样，记住并且会用即可。上述式中的对数以2为底，也可以e为底(自然对数)。</p><p>若随机事件发生的结果记为X，且待分类的事物可能划分在N类中，分别是x1，x2，……，xn，每一种取到的概率分别是P1，P2，……，Pn，那么X的熵就定义为：</p><p>$\mathrm{H}=-\sum_{\mathrm{i}=1}^{n} \mathrm{p}\left(x_{i}\right) \log <em>{2} p\left(x</em>{i}\right)$</p><p>反映了每一个元素在该类别下的不纯度，如{1,2,3,4}跟{1,1,1,2}相比,每个元素1-4的logPi都很大,因此sum的熵就要大很多。</p><p>注：有”某个类别的结果”的熵（某个特征有多个值），也有”某事件结果”的熵（该事件有多个特征）。直观来讲，结果种类越多，熵值越大。</p><p>当熵中的概率由数据估计(特别是最大似然估计)得到时，所对应的熵称为<strong>经验熵</strong>(empirical entropy)。什么叫由数据估计？比如有10个数据，一共有两个类别，A类和B类。其中有7个数据属于A类，则该A类的概率即为十分之七。其中有3个数据属于B类，则该B类的概率即为十分之三。浅显的解释就是，这概率是我们根据数据数出来的。</p><h4 id="经验熵举例："><a href="#经验熵举例：" class="headerlink" title="经验熵举例："></a>经验熵举例：</h4><p>我们定义<a href="#贷款申请样本数据表">贷款申请样本数据表</a>中的数据为训练数据集D，则训练数据集D的经验熵为H(D)。|D|表示其样本容量，即样本个数。设有K个类Ck, = 1,2,3,…,K,|Ck|为属于类Ck的样本个数，因此经验熵公式就可以写为 ：</p><p>$\mathrm{H}(\mathrm{D})=-\sum_{k=1}^{K} \frac{\left|c_{k}\right|}{|D|} \log <em>{2} \frac{\left|C</em>{k}\right|}{|D|}$ ，即$p(C_k)=\frac{\left|C_{k}\right|}{|D|}$由样本数据出来的结果。</p><p>根据此公式计算经验熵H(D)，分析贷款申请样本数据表中的数据。最终分类结果只有两类，即放贷和不放贷。根据表中的数据统计可知，在15个数据中，9个数据的结果为放贷，6个数据的结果为不放贷。所以数据集D的经验熵H(D)为：</p><p>$\mathrm{H}(\mathrm{D})=-\frac{9}{15} \log _{2} \frac{9}{15}-\frac{6}{15} \log _{2} \frac{6}{15}=0.971$</p><p>经过计算可知，数据集D的经验熵H(D)的值为0.971。</p><p>▲熵值越高，则数据混合的种类越高，其蕴含的含义是一个变量可能的变化越多（反而跟变量具体的取值没有任何关系，只和<strong>值的种类</strong>多少以及<strong>发生概率</strong>有关）</p><h3 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h3><p>表示在已知随机变量X的条件下随机变量Y的不确定性，其定义为X在给定条件下Y的条件概率分布的熵对X的数学期望:</p><p>$H(Y | X)=\sum_{i=1}^{n} p_{i} H\left(Y | X=x_{i}\right)$,其中$p_{i}=P\left(X=x_{i}\right), i=1,2, \cdots, \mathrm{n}$</p><h4 id="经验条件熵举例："><a href="#经验条件熵举例：" class="headerlink" title="经验条件熵举例："></a>经验条件熵举例：</h4><p>设特征A有n个不同的取值{a1,a2,···,an}，根据特征A的取值将D划分为n个子集{D1,D2，···,Dn}，|Di|为Di的样本个数。记子集Di中属于Ck的样本的集合为Dik，即Dik = Di ∩ Ck，|Dik|为Dik的样本个数</p><p>$\begin{align<em>}\mathrm{H}(\mathrm{D} | \mathrm{A}) &amp; =\sum_{i=1}^{\mathrm{n}} \frac{\left|D_{i}\right|}{|D|} \mathrm{H}\left(D_{i}\right) \ &amp; =-\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|} \sum_{k=1}^{K} \frac{\left|D_{i k}\right|}{\left|D_{i}\right|} \log <em>{2} \frac{\left|D</em>{i k}\right|}{\left|D_{i}\right|}\end{align</em>}$</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>信息增益(information gain)表示得知特征X的信息后，而使得Y的不确定性减少的程度。定义为集合D的经验熵H(D)与给定特征A条件下D的经验条件熵H(D|A)之差:</p><p>$g(D, A)=H(D)-H(D| A)$</p><p>一般地，熵H(D)与条件熵H(D|A)之差称为<strong>互信息</strong>(mutual information)。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p><p>举例：以<a href="#贷款申请样本数据表">贷款申请样本数据表</a>为例进行说明。看下年龄这一列的数据，也就是特征A1，一共有三个类别，分别是：青年、中年和老年。我们只看年龄是青年的数据，年龄是青年的数据一共有5个，所以年龄是青年的数据在训练数据集出现的概率是5/15，也就是1/3。同理，年龄是中年和老年的数据在训练数据集出现的概率也都是1/3。现在我们只看年龄是青年的数据的最终得到贷款的概率为2/5，因为在五个数据中，只有两个数据显示拿到了最终的贷款，同理，年龄是中年和老年的数据最终得到贷款的概率分别为3/5、4/5。所以计算年龄的信息增益，过程如下：</p><p>$\begin{aligned} \mathrm{g}\left(\mathrm{D}, A_{1}\right) &amp;=H(D)-H\left(D | A_{1}\right) \ &amp;=H(D)-\sum_{i=1}^{\mathrm{n}} \frac{\left|D_{i}\right|}{|D|} \mathrm{H}\left(D_{i}\right) \ &amp;=H(D)-\left[\frac{\left|D_{1}\right|}{|D|}H\left(\mathrm{D}<em>{1}\right)+\frac{\left|D</em>{2}\right|}{|D|} H\left(D_{2}\right)+\frac{\left|D_{3}\right|}{|D|} H\left(D_{3}\right)\right] \ &amp;=H(D)- \frac{\left|D_{i}\right|}{|D|} \sum_{i=1}^{3} p_{i} * \log <em>{2} p</em>{i} \ &amp;=0.971-\left[\frac{5}{15}\left(-\frac{2}{5} \log _{2} \frac{2}{5}-\frac{3}{5} \log _{2} \frac{3}{5}\right)+\frac{5}{15}\left(-\frac{3}{5} \log _{2} \frac{3}{5}-\frac{2}{5} \log _{2} \frac{2}{5}\right)\right.\ &amp;\left.+\frac{5}{15}\left(-\frac{4}{5} \log _{2} \frac{4}{5}-\frac{1}{5} \log _{2} \frac{1}{5}\right)\right] \ &amp;=0.971-0.888=0.083 \end{aligned}$</p><p>其中|Di|为特征该类别的数量，Pi为该类别下为true（事件发生）的概率</p><h2 id="C4-5数学原理"><a href="#C4-5数学原理" class="headerlink" title="C4.5数学原理"></a>C4.5数学原理</h2><p>以信息增益进行分类决策时，存在偏向于取值较多的特征的问题。于是有了基于<strong>信息增益比</strong>的分类决策方法C4.5。C4.5与ID3都是利用贪心算法进行求解，不同的是分类决策的依据不同。</p><p>信息增益比率度量:信息增益比率度量Gain(D，X) / 分裂信息度量SplitInformation(D，X)</p><p>$SplitInformation(D，X） = -\sum_{i=1}^{n}{P_{x_i}}*log_2{P_{x_i}}$</p><p>$GainRatio(D,X) = Gain(D,X)/SplitInformation(D,X)$</p><h2 id="CART数学原理"><a href="#CART数学原理" class="headerlink" title="CART数学原理"></a>CART数学原理</h2><h3 id="基尼指数GINI"><a href="#基尼指数GINI" class="headerlink" title="基尼指数GINI"></a>基尼指数GINI</h3><p>1、是一种不等性度量，表示一个随机选中的样本在子集中被分错的可能性；<br>2、通常用来度量收入不平衡，可以用来度量任何不均匀分布；<br>3、是介于0~1之间的数，0-完全相等，1-完全不相等；<br>4、总体内包含的类别越杂乱，GINI指数就越大（跟熵的概念很相似）</p><p><strong>Gini系数</strong>的计算方式如下 $Gini(p)=\sum_{k=1}^{K} p_{k}\left(1-p_{k}\right)=1-\sum_{k=1}^{K} p_{k}^{2}$</p><p>上面式子表述的意思就是，加入特征X以后，数据不纯度减小的程度.</p><p>如果D为样本数据集，$\operatorname{Gini}(D)=1-\sum_{k=1}^{K}\left(\frac{\left|C_{k}\right|}{|D|}\right)^{2}$其中Ck是D中属于第k类的样本子集，K是类的个数。</p><p>如果D被特征A划分为D1、D2两部分，这个时候就是<em>统计均值</em>，样本数据集D的基尼系数：</p><p>$\operatorname{Gini}(D, A)=\frac{\left|D_{1}\right|}{|D|} \operatorname{Gini}\left(D_{1}\right)+\frac{\left|D_{2}\right|}{|D|} \operatorname{Gini}\left(D_{2}\right)$</p><p><a href="https://www.cnblogs.com/xingshansi/p/6847334.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/xingshansi/p/6847334.html" target="_blank" rel="noopener">统计学习方法：CART算法</a></a></p><hr><h3 id="最小二乘回归树"><a href="#最小二乘回归树" class="headerlink" title="最小二乘回归树"></a>最小二乘回归树</h3><p>一个回归树对应着输入空间（即特征空间）的一个划分以及在划分的单元上的输出值。假设已将输入空间划分为M个单元R1,R2,…Rm，并且在每个单元Rm上有一个固定的输出值Cm，于是回归树模型可表示为：</p><p>$f(x)=\sum_{m=1}^{M} c_{m} I\left(x \in R_{m}\right)$</p><p>模型输出值与实际值的误差：$\sum_{x_{i} \in R_{m}}\left(y_{i}-f\left(x_{i}\right)\right)^{2}$</p><p>我们希望每个单元上的Cm，可以是的这个平方误差最小化。易知，当<strong>Cm为相应单元的所有实际值的均值时，可以到最优：</strong></p><p>$\hat{c}<em>{m}=\operatorname{ave}\left(y</em>{i} | x_{i} \in R_{m}\right)$</p><p>假设，我们选择变量 xj 为切分变量，它的取值 s 为切分点，那么就会得到两个区域：</p><p>$\mathrm{R}<em>{1}(j, s)=\left{x | x^{(j)} \leq s\right}, \mathrm{R}</em>{2}(j, s)=\left{x | x^{(j)}&gt;s\right}$</p><p>当j和s固定时，我们要找到两个区域的代表值c1，c2使各自区间上的平方差最小：</p><p>$\min _{j, s}\left[\min _{c_{1}} \sum_{x_{i} \in R_{1}(j, s)}\left(y_{i}-c_{1}\right)^{2}+\min _{c_{2}} \sum_{x_{i} \in R_{2}(j, s)}\left(y_{i}-c_{2}\right)^{2}\right]$</p><p>前面已经知道c1，c2为区间上的平均：</p><p>$\hat{c}<em>{1}=\operatorname{ave}\left(y</em>{i} | x_{i} \epsilon R_{1}(j, s)\right), \hat{c}<em>{2}=\operatorname{ave}\left(y</em>{i} | x_{i} \epsilon R_{1}(j, s)\right)$</p><p>那么对固定的 j 只需要找到最优的s，然后通过遍历所有的变量，我们可以找到最优的j，这样我们就可以得到最优对（j，s）,（特征j，特征分类值s），并s得到两个区间。</p><p>这样的回归树通常称为最小二乘回归树（least squares regression tree）。</p><p><strong>上述过程表示的算法步骤为:</strong></p><p><img src="https://cuijiahua.com/wp-content/uploads/2017/12/ml_13_9.png" alt=""></p><h2 id="处理连续数值型特征"><a href="#处理连续数值型特征" class="headerlink" title="处理连续数值型特征"></a>处理连续数值型特征</h2><p>C4.5和CART既可以处理离散型属性，也可以处理连续性属性。对于离散型描述属性，处理方法与ID3相同。对于连续分布的特征，其处理方法是：</p><p>以C4.5为例子，在C4.5中，对连续属性的处理如下：</p><p>1、对特征的取值进行升序排序</p><p>2、两个特征取值之间的中点作为可能的<strong>分裂点</strong>，从分裂点将数据集分成两部分，计算每个可能的分裂点的信息增益（InforGain）。优化算法就是只计算分类属性发生改变的那些特征取值。</p><p>3、选择修正后信息增益(InforGain)最大的分裂点作为该特征的最佳分裂点</p><p>4、计算最佳分裂点的信息增益率（Gain Ratio）作为特征的Gain Ratio。注意，此处需对最佳分裂点的信息增益进行修正：减去log2(N-1)/|D|（N是连续特征的取值个数，D是训练数据数目，此修正的原因在于：当离散属性和连续属性并存时，C4.5算法倾向于选择连续特征做最佳树分裂点）</p><p>Q：为什么这边是使用的信息增益率？</p><p>A：经证明，在决定连续特征的分界点时采用增益这个指标（因为若采用增益率，splittedinfo影响分裂点信息度量准确性，若某分界点恰好将连续特征分成数目相等的两部分时其抑制作用最大），而选择属性的时候才使用增益率这个指标能选择出最佳分类特征。</p><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><h3 id="预剪枝-Pre-pruning"><a href="#预剪枝-Pre-pruning" class="headerlink" title="预剪枝(Pre-pruning)"></a>预剪枝(Pre-pruning)</h3><blockquote><p>在构建决策树的过程时，提前停止。</p></blockquote><ul><li>根据一些原则及早的停止树增长，如树的深度达到用户所要的深度、节点中样本个数少于用户指定个数、不纯度指标下降的最大幅度小于用户指定的幅度等</li><li>采用检验技术对当前结点对应的样本集合进行检验，如果该样本集合的样本数量已小于事先指定的最小允许值，那么停止该结点的继续生长，并将该结点变为叶子结点，否则可以继续扩展该结点。</li><li>▲核心问题是如何事先指定树的最大深度，如果设置的最大深度不恰当，那么将会导致过于限制树的生长，使决策树的表达式规则趋于一般，不能更好地对新数据集进行分类和预测</li></ul><h3 id="后剪枝-Post-pruning"><a href="#后剪枝-Post-pruning" class="headerlink" title="后剪枝(Post-pruning)"></a>后剪枝(Post-pruning)</h3><blockquote><p>决策树构建好后，然后才开始裁剪。</p></blockquote><ul><li>代价复杂性剪枝、最小误差剪枝、悲观误差剪枝等等</li><li>是一个边修剪边检验的过程。<ul><li>在决策树的不断剪枝操作过程中，将原样本集合或新数据集合作为测试数据，检验决策树对测试数据的预测精度，并计算出相应的错误率，如果剪掉某个子树后的决策树对测试数据的预测精度或其他测度不降低，那么剪掉该子树。</li><li>▲关键就是用独立的验证数据集对训练集生长的树进行剪枝</li></ul></li></ul><h3 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a>CART剪枝</h3><p>先来看看剪枝用到的准则函数：$C_{\alpha}(T)=C(T)+\alpha|T_{leaf}|$</p><p>C（T）是叶节点特性的度量，C4.3里它是熵的均值，CART决策树里它是基尼系数的概率均值，原理类似。多一个正则项，就是稀疏性约束。$T_{leaf}$为叶子节点个数，越多，损失越大</p><p>ID3、C4.5算法中的剪枝原理是给定α，事实上很难一次给出理想的α。CART剪枝不再给定一个α，然后选择最优决策树，而是通过设定不同的α，通过交叉验证选择最优CART树，也就是：</p><p><strong>训练集</strong>：得到不同的子树;</p><p><strong>测试集</strong>：交叉验证选择最优树.</p><p>从有限个子树$\left{T_{0}, T_{1}, \ldots, T_{n}\right}$中计算最优子树，最优子树由验证集得出的测试误差决定，哪个最小就是哪个。</p><p>这里就引出了一个问题，每次剪哪一个节点呢？如何让$T_{leaf}$到达一个合适的点呢？先看分析剪枝的两个极端情况：</p><p>1）完全没剪：</p><p>$C_{\alpha}\left(T_{t}\right)=C\left(T_{t}\right)+\alpha\left|T_{t}\right|$</p><p>2）只剩根节点：</p><p>$C_{\alpha}(t)=C(t)+\alpha$</p><p>在α较小或者为0时，有：</p><p>$C_{\alpha}\left(T_{t}\right)&lt;C_{\alpha}(t)$</p><p>在α取+∞大时，有：</p><p>$C_{\alpha}\left(T_{t}\right)&gt;C_{\alpha}(t)$</p><p>α是连续变量，因此总有临界点：</p><p>$C_{\alpha}\left(T_{t}\right)=C_{\alpha}(t)$</p><p>为了不混淆变量，重新定义：</p><p>$g(t)=\frac{C(t)-C\left(T_{t}\right)}{\left|T_{t}\right|-1}$</p><p><strong>α大于g(t)就是该剪</strong>。简而言之：</p><blockquote><p>对于同一棵树的结点，α都是一样的，当α从0开始缓慢增大（或者从+∞慢慢减小），总会有某棵子树该剪，其他子树不该剪的情况，即α超过了某个结点的g(t)，但还没有超过其他结点的g(t)。这样随着alpha不断增大，不断地剪枝，就得到了n+1棵子树，接下来只要用独立数据集测试这n+1棵子树，试试哪棵子树的误差最小 就知道那棵是最好的方案了。</p></blockquote><h4 id="CART剪枝的算法过程"><a href="#CART剪枝的算法过程" class="headerlink" title="CART剪枝的算法过程"></a>CART剪枝的算法过程</h4><p><img src="/2019/08/30/机器学习——决策树/CART剪枝.png" alt="CART剪枝"></p><h2 id="代码编写注意点"><a href="#代码编写注意点" class="headerlink" title="代码编写注意点"></a>代码编写注意点</h2><p>递归的结束条件：</p><h3 id="一-到达叶节点"><a href="#一-到达叶节点" class="headerlink" title="一.到达叶节点"></a>一.到达叶节点</h3><p>1.当某集合的值全是同一类时，那么该子集直接可作为叶子节点，为一个类别，此时不再下探。</p><p>2.在决策树构造过程中可能会出现这种情况：所有特征都作为分裂特征<strong>用光</strong>了，但<strong>子集还不是纯净集</strong>（集合内的元素不属于同一类别）。在这种情况下，由于没有更多信息可以使用了，一般对这些子集进行“<strong>多数表决</strong>”，即使用此子集中出现次数最多的类别作为此节点类别，然后将此节点作为叶子节点，此时不再下探</p><h3 id="二-预剪枝条件"><a href="#二-预剪枝条件" class="headerlink" title="二.预剪枝条件"></a>二.预剪枝条件</h3><p>1.树的深度达到用户所要的深度</p><p>2.节点中样本个数少于用户指定个数</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><img src="https://cuijiahua.com/wp-content/uploads/2017/11/ml_3_1.jpg" alt=""></p><p>借鉴：</p><ul><li><a href="https://cuijiahua.com/blog/2017/11/ml_3_decision_tree_2.html/comment-page-2/#comments" target="_blank" rel="noopener">机器学习实战教程（三）：决策树实战篇之为自己配个隐形眼镜</a></li><li><a href="https://www.cnblogs.com/sxron/p/5471078.html" target="_blank" rel="noopener">决策树算法原理及实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习——决策树&quot;&gt;&lt;a href=&quot;#机器学习——决策树&quot; class=&quot;headerlink&quot; title=&quot;机器学习——决策树&quot;&gt;&lt;/a&gt;机器学习——决策树&lt;/h1&gt;&lt;h2 id=&quot;决策树基础概念&quot;&gt;&lt;a href=&quot;#决策树基础概念&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://nymrli.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Sklearn——决策树</title>
    <link href="https://nymrli.top/2019/08/30/Sklearn%E2%80%94%E2%80%94%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>https://nymrli.top/2019/08/30/Sklearn——决策树/</id>
    <published>2019-08-30T13:43:27.000Z</published>
    <updated>2019-08-30T13:44:19.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sklearn——决策树"><a href="#Sklearn——决策树" class="headerlink" title="Sklearn——决策树"></a>Sklearn——决策树</h1><blockquote><p>注明：转载自<a href="https://cuijiahua.com/wp-content/uploads/2017/11/ml_3_11.jpg" target="_blank" rel="noopener">Jack Gui的博客</a></p></blockquote><h2 id="1、实战背景"><a href="#1、实战背景" class="headerlink" title="1、实战背景"></a>1、实战背景</h2><p>进入本文的正题：眼科医生是如何判断患者需要佩戴隐形眼镜的类型的？一旦理解了决策树的工作原理，我们甚至也可以帮助人们判断需要佩戴的镜片类型。</p><p>隐形眼镜数据集是非常著名的数据集，它包含很多换着眼部状态的观察条件以及医生推荐的隐形眼镜类型。隐形眼镜类型包括硬材质(hard)、软材质(soft)以及不适合佩戴隐形眼镜(no lenses)。数据来源与UCI数据库，数据集下载地址：<a href="[https://github.com/Jack-Cherish/Machine-Learning/blob/master/Decision%20Tree/lenses.txt](https://github.com/Jack-Cherish/Machine-Learning/blob/master/Decision Tree/lenses.txt">lenses.txt)</a>)</p><table><thead><tr><th>young</th><th>myope</th><th>no</th><th>reduced</th><th>no lenses</th></tr></thead><tbody><tr><td>young</td><td>myope</td><td>no</td><td>normal</td><td>soft</td></tr><tr><td>young</td><td>myope</td><td>yes</td><td>reduced</td><td>no lenses</td></tr><tr><td>young</td><td>myope</td><td>yes</td><td>normal</td><td>hard</td></tr><tr><td>young</td><td>hyper</td><td>no</td><td>reduced</td><td>no lenses</td></tr><tr><td>young</td><td>hyper</td><td>no</td><td>normal</td><td>soft</td></tr><tr><td>young</td><td>hyper</td><td>yes</td><td>reduced</td><td>no lenses</td></tr><tr><td>young</td><td>hyper</td><td>yes</td><td>normal</td><td>hard</td></tr><tr><td>pre</td><td>myope</td><td>no</td><td>reduced</td><td>no lenses</td></tr><tr><td>pre</td><td>myope</td><td>no</td><td>normal</td><td>soft</td></tr><tr><td>pre</td><td>myope</td><td>yes</td><td>reduced</td><td>no lenses</td></tr><tr><td>pre</td><td>myope</td><td>yes</td><td>normal</td><td>hard</td></tr><tr><td>pre</td><td>hyper</td><td>no</td><td>reduced</td><td>no lenses</td></tr><tr><td>pre</td><td>hyper</td><td>no</td><td>normal</td><td>soft</td></tr><tr><td>pre</td><td>hyper</td><td>yes</td><td>reduced</td><td>no lenses</td></tr><tr><td>pre</td><td>hyper</td><td>yes</td><td>normal</td><td>no lenses</td></tr><tr><td>presbyopic</td><td>myope</td><td>no</td><td>reduced</td><td>no lenses</td></tr><tr><td>presbyopic</td><td>myope</td><td>no</td><td>normal</td><td>no lenses</td></tr><tr><td>presbyopic</td><td>myope</td><td>yes</td><td>reduced</td><td>no lenses</td></tr><tr><td>presbyopic</td><td>myope</td><td>yes</td><td>normal</td><td>hard</td></tr><tr><td>presbyopic</td><td>hyper</td><td>no</td><td>reduced</td><td>no lenses</td></tr><tr><td>presbyopic</td><td>hyper</td><td>no</td><td>normal</td><td>soft</td></tr><tr><td>presbyopic</td><td>hyper</td><td>yes</td><td>reduced</td><td>no lenses</td></tr><tr><td>presbyopic</td><td>hyper</td><td>yes</td><td>normal</td><td>no lenses</td></tr></tbody></table><p>一共有24组数据，数据的Labels依次是<code>age</code>、<code>prescript</code>、<code>astigmatic</code>、<code>tearRate</code>、<code>class</code>，也就是第一列是年龄，第二列是症状，第三列是是否散光，第四列是眼泪数量，第五列是最终的分类标签。数据如下图所示：</p><h2 id="2、使用Sklearn构建决策树"><a href="#2、使用Sklearn构建决策树" class="headerlink" title="2、使用Sklearn构建决策树"></a>2、使用Sklearn构建决策树</h2><p>官方英文文档地址：<a href="https://cuijiahua.com/wp-content/themes/begin/inc/go.php?url=https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html" target="_blank" rel="noopener">http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html</a></p><p>sklearn.tree模块提供了决策树模型，用于解决分类问题和回归问题：</p><p><img src="https://cuijiahua.com/wp-content/uploads/2017/11/ml_3_11.jpg" alt=""></p><p>本次实战内容使用的是DecisionTreeClassifier和export_graphviz，前者用于决策树构建，后者用于决策树可视化。</p><p><strong>DecisionTreeClassifier构建决策树：</strong></p><p>让我们先看下DecisionTreeClassifier这个函数，一共有12个参数：</p><p>参数说明如下：</p><ul><li><p><strong>criterion：</strong>特征选择标准，可选参数，默认是<code>gini</code>，可以设置为<code>entropy</code>。<code>gini</code>是基尼不纯度，是将来自集合的某种结果随机应用于某一数据项的预期误差率，是一种基于统计的思想。<code>entropy</code>是香农熵，也就是上篇文章讲过的内容，是一种基于信息论的思想。Sklearn把<code>gini</code>设为默认参数，应该也是做了相应的斟酌的，精度也许更高些？ID3算法使用的是<code>entropy</code>，CART算法使用的则是<code>gini</code>。</p></li><li><p><strong>splitter：</strong>特征划分点选择标准，可选参数，默认是<code>best</code>，可以设置为<code>random</code>。每个结点的选择策略。<code>best</code>参数是根据算法选择最佳的切分特征，例如<code>gini</code>、<code>entropy</code>。<code>random</code>随机的在部分划分点中找局部最优的划分点。默认的”best”适合样本量不大的时候，而如果样本数据量非常大，此时决策树构建推荐”random”。</p></li><li><p>max_features：</p><p>划分时考虑的最大特征数，可选参数，默认是None。寻找最佳切分时考虑的最大特征数(n_features为总共的特征数)，有如下6种情况：</p><ul><li>如果max_features是整型的数，则考虑max_features个特征；</li><li>如果max_features是浮点型的数，则考虑int(max_features * n_features)个特征；</li><li>如果max_features设为<code>auto</code>，那么max_features = sqrt(n_features)；</li><li>如果max_features设为<code>sqrt</code>，那么max_featrues = sqrt(n_features)，跟<code>auto</code>一样；</li><li>如果max_features设为<code>log2</code>，那么max_features = log2(n_features)；</li><li>如果max_features设为<code>None</code>，那么max_features = n_features，也就是所有特征都用。</li><li>一般来说，如果样本特征数不多，比如小于50，我们用默认的”None”就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。</li></ul></li><li><p><strong>max_depth：</strong>决策树最大深，可选参数，默认是<code>None</code>。这个参数是这是树的层数的。层数的概念就是，比如在贷款的例子中，决策树的层数是2层。如果这个参数设置为<code>None</code>，那么决策树在建立子树的时候不会限制子树的深度。一般来说，数据少或者特征少的时候可以不管这个值。或者如果设置了<code>min_samples_slipt</code>参数，那么直到少于<code>min_smaples_split</code>个样本为止。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。</p></li><li><p><strong>min_samples_split：</strong>内部节点再划分所需最小样本数，可选参数，默认是2。这个值限制了子树继续划分的条件。如果<code>min_samples_split</code>为整数，那么在切分内部结点的时候，<code>min_samples_split</code>作为最小的样本数，也就是说，如果样本已经少于<code>min_samples_split</code>个样本，则停止继续切分。如果<code>min_samples_split</code>为浮点数，那么<code>min_samples_split</code>就是一个百分比，ceil(min_samples_split * n_samples)，数是向上取整的。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。</p></li><li><p><strong>min_samples_leaf：</strong>叶子节点最少样本数，可选参数，默认是1。这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。叶结点需要最少的样本数，也就是最后到叶结点，需要多少个样本才能算一个叶结点。如果设置为1，哪怕这个类别只有1个样本，决策树也会构建出来。如果<code>min_samples_leaf</code>是整数，那么<code>min_samples_leaf</code>作为最小的样本数。如果是浮点数，那么<code>min_samples_leaf</code>就是一个百分比，同上，celi(min_samples_leaf * n_samples)，数是向上取整的。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。</p></li><li><p><strong>min_weight_fraction_leaf：</strong>叶子节点最小的样本权重和，可选参数，默认是0。这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。</p></li><li><p><strong>max_leaf_nodes：</strong>最大叶子节点数，可选参数，默认是<code>None</code>。通过限制最大叶子节点数，可以防止过拟合。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。</p></li><li><p><strong>class_weight：</strong>类别权重，可选参数，默认是<code>None</code>，也可以字典、字典列表、<code>balanced</code>。指定样本各类别的的权重，主要是为了防止训练集某些类别的样本过多，导致训练的决策树过于偏向这些类别。类别的权重可以通过<code>{class_label：weight}</code>这样的格式给出，这里可以自己指定各个样本的权重，或者用<code>balanced</code>，如果使用<code>balanced</code>，则算法会自己计算权重，样本量少的类别所对应的样本权重会高。当然，如果你的样本类别分布没有明显的偏倚，则可以不管这个参数，选择默认的<code>None</code>。</p></li><li><p><strong>random_state：</strong>可选参数，默认是<code>None</code>。随机数种子。如果是证书，那么<code>random_state</code>会作为随机数生成器的随机数种子。随机数种子，如果没有设置随机数，随机出来的数与当前系统时间有关，每个时刻都是不同的。如果设置了随机数种子，那么相同随机数种子，不同时刻产生的随机数也是相同的。如果是<code>RandomState instance</code>，那么<code>random_state</code>是随机数生成器。如果为<code>None</code>，则随机数生成器使用np.random。</p></li><li><p><strong>min_impurity_split：</strong>节点划分最小不纯度,可选参数，默认是1e-7。这是个阈值，这个值限制了决策树的增长，如果某节点的不纯度(基尼系数，信息增益，均方差，绝对差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。</p></li><li><p><strong>presort：</strong>数据是否预排序，可选参数，默认为<code>False</code>，这个值是布尔值，默认是False不排序。一般来说，如果样本量少或者限制了一个深度很小的决策树，设置为true可以让划分点选择更加快，决策树建立的更加快。如果样本量太大的话，反而没有什么好处。问题是样本量少的时候，我速度本来就不慢。所以这个值一般懒得理它就可以了。</p></li></ul><p>除了这些参数要注意以外，其他在调参时的注意点有：</p><ul><li>当样本数量少但是样本特征非常多的时候，决策树很容易过拟合，一般来说，样本数比特征数多一些会比较容易建立健壮的模型</li><li>如果样本数量少但是样本特征非常多，在拟合决策树模型前，推荐先做维度规约，比如主成分分析（PCA），特征选择（Losso）或者独立成分分析（ICA）。这样特征的维度会大大减小。再来拟合决策树模型效果会好。</li><li>推荐多用决策树的可视化，同时先限制决策树的深度，这样可以先观察下生成的决策树里数据的初步拟合情况，然后再决定是否要增加深度。</li><li>在训练模型时，注意观察样本的类别情况（主要指分类树），如果类别分布非常不均匀，就要考虑用class_weight来限制模型过于偏向样本多的类别。</li><li>决策树的数组使用的是numpy的float32类型，如果训练数据不是这样的格式，算法会先做copy再运行。</li><li>如果输入的样本矩阵是稀疏的，推荐在拟合前调用csc_matrix稀疏化，在预测前调用csr_matrix稀疏化。</li></ul><p>sklearn.tree.DecisionTreeClassifier()提供了一些方法供我们使用，如下图所示：</p><p><a href="https://cuijiahua.com/wp-content/uploads/2017/11/ml_3_13.jpg" target="_blank" rel="noopener"><img src="https://cuijiahua.com/wp-content/uploads/2017/11/ml_3_13.jpg" alt="机器学习实战教程（三）：决策树实战篇之为自己配个隐形眼镜"></a></p><p>Code1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fr = open(<span class="string">'lenses.txt'</span>)</span><br><span class="line">    lenses = [inst.strip().split(<span class="string">'\t'</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()]</span><br><span class="line">    print(lenses)</span><br><span class="line">    lensesLabels = [<span class="string">'age'</span>, <span class="string">'prescript'</span>, <span class="string">'astigmatic'</span>, <span class="string">'tearRate'</span>]</span><br><span class="line">    clf = tree.DecisionTreeClassifier()</span><br><span class="line">    lenses = clf.fit(lenses, lensesLabels)</span><br></pre></td></tr></table></figure><p> ▲    我们可以看到程序报错了，这是为什么？因为在fit()函数不能接收string类型的数据，通过打印的信息可以看到，数据都是string类型的。在使用fit()函数之前，我们需要对数据集进行编码，这里可以使用两种方法：</p><ul><li><a href="https://cuijiahua.com/wp-content/themes/begin/inc/go.php?url=https://scikit-learn.org/dev/modules/generated/sklearn.preprocessing.LabelEncoder.html" target="_blank" rel="noopener">LabelEncoder</a> ：将字符串转换为增量值</li><li><a href="https://cuijiahua.com/wp-content/themes/begin/inc/go.php?url=https://scikit-learn.org/dev/modules/generated/sklearn.preprocessing.OneHotEncoder.html#sklearn.preprocessing.OneHotEncoder" target="_blank" rel="noopener">OneHotEncoder</a>：使用One-of-K算法将字符串转换为整数</li></ul><p>为了对<code>string</code>类型的数据序列化，需要先生成pandas数据，这样方便我们的序列化工作。这里我使用的方法是，原始数据-&gt;字典-&gt;pandas数据，编写代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'lenses.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fr: <span class="comment">#加载文件</span></span><br><span class="line">        lenses = [inst.strip().split(<span class="string">'\t'</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()] <span class="comment">#处理文件</span></span><br><span class="line">    lenses_target = [] <span class="comment">#提取每组数据的类别，保存在列表里</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> lenses:</span><br><span class="line">        lenses_target.append(each[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    lensesLabels = [<span class="string">'age'</span>, <span class="string">'prescript'</span>, <span class="string">'astigmatic'</span>, <span class="string">'tearRate'</span>] <span class="comment">#特征标签       </span></span><br><span class="line">    lenses_list = [] <span class="comment">#保存lenses数据的临时列表</span></span><br><span class="line">    lenses_dict = &#123;&#125; <span class="comment">#保存lenses数据的字典，用于生成pandas</span></span><br><span class="line">    <span class="keyword">for</span> each_label <span class="keyword">in</span> lensesLabels: <span class="comment">#提取信息，生成字典</span></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> lenses:</span><br><span class="line">            lenses_list.append(each[lensesLabels.index(each_label)])</span><br><span class="line">        lenses_dict[each_label] = lenses_list</span><br><span class="line">        lenses_list = []</span><br><span class="line">    print(lenses_dict) <span class="comment">#打印字典信息</span></span><br><span class="line">    lenses_pd = pd.DataFrame(lenses_dict) <span class="comment">#生成pandas.DataFrame</span></span><br><span class="line">    print(lenses_pd)</span><br><span class="line">    <span class="comment"># 顺利生成pandas数据。</span></span><br></pre></td></tr></table></figure><p>接下来，将数据序列化，编写代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pydotplus</span><br><span class="line"><span class="keyword">from</span> sklearn.externals.six <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'lenses.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fr: <span class="comment">#加载文件</span></span><br><span class="line">        lenses = [inst.strip().split(<span class="string">'\t'</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()] <span class="comment">#处理文件</span></span><br><span class="line">    lenses_target = [] <span class="comment">#提取每组数据的类别，保存在列表里</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> lenses:</span><br><span class="line">        lenses_target.append(each[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    lensesLabels = [<span class="string">'age'</span>, <span class="string">'prescript'</span>, <span class="string">'astigmatic'</span>, <span class="string">'tearRate'</span>] <span class="comment">#特征标签       </span></span><br><span class="line">    lenses_list = [] <span class="comment">#保存lenses数据的临时列表</span></span><br><span class="line">    lenses_dict = &#123;&#125; <span class="comment">#保存lenses数据的字典，用于生成pandas</span></span><br><span class="line">    <span class="keyword">for</span> each_label <span class="keyword">in</span> lensesLabels: <span class="comment">#提取信息，生成字典</span></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> lenses:</span><br><span class="line">            lenses_list.append(each[lensesLabels.index(each_label)])</span><br><span class="line">        lenses_dict[each_label] = lenses_list</span><br><span class="line">        lenses_list = []</span><br><span class="line">    <span class="comment"># print(lenses_dict) #打印字典信息</span></span><br><span class="line">    lenses_pd = pd.DataFrame(lenses_dict) <span class="comment"># 生成pandas.DataFrame</span></span><br><span class="line">    print(lenses_pd) <span class="comment">#打印pandas.DataFrame</span></span><br><span class="line">    le = LabelEncoder() <span class="comment">#创建LabelEncoder()对象，用于序列化            </span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> lenses_pd.columns: <span class="comment">#为每一列序列化</span></span><br><span class="line">        lenses_pd[col] = le.fit_transform(lenses_pd[col])</span><br><span class="line">    print(lenses_pd)</span><br></pre></td></tr></table></figure><p>从打印结果可以看到，我们已经将数据顺利序列化，接下来。我们就可以fit()数据，构建决策树了。</p><h2 id="3、使用Graphviz可视化决策树"><a href="#3、使用Graphviz可视化决策树" class="headerlink" title="3、使用Graphviz可视化决策树"></a>3、使用Graphviz可视化决策树</h2><p>Graphviz的是AT&amp;T Labs Research开发的图形绘制工具，他可以很方便的用来绘制结构化的图形网络，支持多种格式输出，生成图片的质量和速度都不错。它的输入是一个用dot语言编写的绘图脚本，通过对输入脚本的解析，分析出其中的点，边以及子图，然后根据属性进行绘制。是使用Sklearn生成的决策树就是dot格式的，因此我们可以直接利用Graphviz将决策树可视化。</p><p>在讲解编写代码之前，我们需要安装两样东西，即pydotplus和Grphviz。</p><p><strong>（1）安装Pydotplus</strong></p><p>pydotplus可以在CMD窗口中，直接使用指令安装：<code>pip3 install pydotplus</code></p><p><strong>（2）安装Graphviz</strong></p><p>Graphviz不能使用<code>pip</code>进行安装，我们需要手动安装，下载地址：<a href="https://cuijiahua.com/wp-content/themes/begin/inc/go.php?url=https://www.graphviz.org/" target="_blank" rel="noopener">https://www.graphviz.org</a>，可能下载比较慢。</p><p>安装以后，需要设置环境变量，如将<code>D:\graphviz-2.38\release\bin</code>加入到Path中，然后运行下之后的代码看是否能正常使用。</p><p><strong>（3）编写代码</strong></p><p>Talk is Cheap, show me the code.(废话少说，放码过来)。可视化部分的代码不难，都是有套路的，直接填参数就好，详细内容可以查看官方教程：<a href="https://cuijiahua.com/wp-content/themes/begin/inc/go.php?url=https://scikit-learn.org/stable/modules/tree.html#tree" target="_blank" rel="noopener">http://scikit-learn.org/stable/modules/tree.html#tree</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder, OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.externals.six <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pydotplus</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'lenses.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fr:                                        <span class="comment">#加载文件</span></span><br><span class="line">        lenses = [inst.strip().split(<span class="string">'\t'</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()]        <span class="comment">#处理文件</span></span><br><span class="line">    lenses_target = []                                                        <span class="comment">#提取每组数据的类别，保存在列表里</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> lenses:</span><br><span class="line">        lenses_target.append(each[<span class="number">-1</span>])</span><br><span class="line">    print(lenses_target)</span><br><span class="line"></span><br><span class="line">    lensesLabels = [<span class="string">'age'</span>, <span class="string">'prescript'</span>, <span class="string">'astigmatic'</span>, <span class="string">'tearRate'</span>]            <span class="comment">#特征标签       </span></span><br><span class="line">    lenses_list = []                                                        <span class="comment">#保存lenses数据的临时列表</span></span><br><span class="line">    lenses_dict = &#123;&#125;                                                        <span class="comment">#保存lenses数据的字典，用于生成pandas</span></span><br><span class="line">    <span class="keyword">for</span> each_label <span class="keyword">in</span> lensesLabels:                                            <span class="comment">#提取信息，生成字典</span></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> lenses:</span><br><span class="line">            lenses_list.append(each[lensesLabels.index(each_label)])</span><br><span class="line">        lenses_dict[each_label] = lenses_list</span><br><span class="line">        lenses_list = []</span><br><span class="line">    <span class="comment"># print(lenses_dict)                                                        #打印字典信息</span></span><br><span class="line">    lenses_pd = pd.DataFrame(lenses_dict)                                    <span class="comment">#生成pandas.DataFrame</span></span><br><span class="line">    <span class="comment"># print(lenses_pd)                                                        #打印pandas.DataFrame</span></span><br><span class="line">    le = LabelEncoder()                                                        <span class="comment">#创建LabelEncoder()对象，用于序列化           </span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> lenses_pd.columns:                                            <span class="comment">#序列化</span></span><br><span class="line">        lenses_pd[col] = le.fit_transform(lenses_pd[col])</span><br><span class="line">    <span class="comment"># print(lenses_pd)                                                        #打印编码信息</span></span><br><span class="line"></span><br><span class="line">    clf = tree.DecisionTreeClassifier(max_depth = <span class="number">4</span>)                        <span class="comment">#创建DecisionTreeClassifier()类</span></span><br><span class="line">    clf = clf.fit(lenses_pd.values.tolist(), lenses_target)                    <span class="comment">#使用数据，构建决策树</span></span><br><span class="line">    dot_data = StringIO()</span><br><span class="line">    tree.export_graphviz(clf, out_file = dot_data,                            <span class="comment">#绘制决策树</span></span><br><span class="line">                        feature_names = lenses_pd.keys(),</span><br><span class="line">                        class_names = clf.classes_,</span><br><span class="line">                        filled=<span class="keyword">True</span>, rounded=<span class="keyword">True</span>,</span><br><span class="line">                        special_characters=<span class="keyword">True</span>)</span><br><span class="line">    graph = pydotplus.graph_from_dot_data(dot_data.getvalue())</span><br><span class="line">    graph.write_pdf(<span class="string">"tree.pdf"</span>)                                                <span class="comment">#保存绘制好的决策树，以PDF的形式存储。</span></span><br></pre></td></tr></table></figure><p>运行代码，在该python文件保存的相同目录下，会生成一个名为tree的PDF文件，打开文件，我们就可以看到决策树的可视化效果图了。</p><p><img src="https://cuijiahua.com/wp-content/uploads/2017/11/ml_3_19.jpg" alt=""></p><p>确定好决策树之后，我们就可以做预测了。可以根据自己的眼睛情况和年龄等特征，看一看自己适合何种材质的隐形眼镜。使用如下代码就可以看到预测结果：<code>print(clf.predict([[1,1,1,0]]))                    #预测</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>决策树的一些优点：</strong></p><ul><li>易于理解和解释。决策树可以可视化。</li><li>几乎不需要数据预处理。其他方法经常需要数据标准化，创建虚拟变量和删除缺失值。决策树还不支持缺失值。</li><li>使用树的花费（例如预测数据）是训练数据点(data points)数量的对数。</li><li>可以同时处理数值变量和分类变量。其他方法大都适用于分析一种变量的集合。</li><li>可以处理多值输出变量问题。</li><li>使用白盒模型。如果一个情况被观察到，使用逻辑判断容易表示这种规则。相反，如果是黑盒模型（例如人工神经网络），结果会非常难解释。</li><li>即使对真实模型来说，假设无效的情况下，也可以较好的适用。</li></ul><p><strong>决策树的一些缺点：</strong></p><ul><li>决策树学习可能创建一个过于复杂的树，并不能很好的预测数据。也就是过拟合。修剪机制（现在不支持），设置一个叶子节点需要的最小样本数量，或者数的最大深度，可以避免过拟合。</li><li>决策树可能是不稳定的，因为即使非常小的变异，可能会产生一颗完全不同的树。这个问题通过decision trees with an ensemble来缓解。</li><li>概念难以学习，因为决策树没有很好的解释他们，例如，XOR, parity or multiplexer problems。</li><li>如果某些分类占优势，决策树将会创建一棵有偏差的树。因此，建议在训练之前，先抽样使样本均衡。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sklearn——决策树&quot;&gt;&lt;a href=&quot;#Sklearn——决策树&quot; class=&quot;headerlink&quot; title=&quot;Sklearn——决策树&quot;&gt;&lt;/a&gt;Sklearn——决策树&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;注明：转载自&lt;a href=&quot;ht
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://nymrli.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Pythton" scheme="https://nymrli.top/tags/Pythton/"/>
    
  </entry>
  
  <entry>
    <title>ACM-博弈论</title>
    <link href="https://nymrli.top/2019/08/30/ACM-%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <id>https://nymrli.top/2019/08/30/ACM-博弈论/</id>
    <published>2019-08-30T13:41:28.000Z</published>
    <updated>2019-08-30T13:42:14.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ACM-博弈论（gambling）"><a href="#ACM-博弈论（gambling）" class="headerlink" title="ACM-博弈论（gambling）"></a>ACM-博弈论（gambling）</h1><blockquote><p>博弈论：是二人或多人在平等的对局中各自利用对方的策略变换自己的对抗策略，达到取胜目标的理论。假设，双方每步都是最优决策</p></blockquote><p>博弈论是研究互动决策的理论。博弈可以分析自己与对手的利弊关系，从而确立自己在博弈中的优势，因此有不少博弈理论，可以帮助对弈者分析局势，从而采取相应策略，最终达到取胜的目的。</p><h2 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h2><blockquote><p>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。</p></blockquote><p>显然，如果n=m+1，1那么由于一次最多只能取m个，所以，<strong>无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜</strong>。因此我们发现了先手如何取胜的法则：除了先手取以外，之后每个双方回合时保证取走m+1个物品则能保证先手胜。</p><p>▲即如果n=(m+1)*r+s，（r为任意自然数，0&lt;s&lt;=m），那么先取者要拿走s个物品，如果后取者拿走k（&lt;=m）个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。</p><p>结论</p><ul><li>编程解题的方法就是判断n是否能表示为(m+1)*r+s，找到这个m，和存在r，s</li><li>s不为0，所以当n=(m+1)*r时，后手必胜</li></ul><p>这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。</p><h3 id="例题HDU1846——Brave-Game，裸题"><a href="#例题HDU1846——Brave-Game，裸题" class="headerlink" title="例题HDU1846——Brave Game，裸题"></a>例题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1846" target="_blank" rel="noopener">HDU1846——Brave Game</a>，裸题</h3><blockquote><p>n为总价、总和，m为每次能取的大小</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n &gt;&gt;m;</span><br><span class="line">        <span class="keyword">int</span> mod = n%(m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mod != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"second"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Public-Sale"><a href="#Public-Sale" class="headerlink" title="Public Sale"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2149" target="_blank" rel="noopener">Public Sale</a></h3><blockquote><p>区别在于还存在n&lt;m的情况，由于题目要求<strong>每次加价的幅度要在1～N之间，当价格大于或等于田地的成本价 M 时，主办方就把这块田地卖给这次叫价的人。</strong>，所以此时，第一次出价n+1~m都可以<strong>直接</strong>将物品买下，需要单独考虑</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;m) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=m;i++) </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mod = n%(m+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (mod == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"none"</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//s=0，后手必胜</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; mod &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//存在s，即先手的Lele能买到</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h2><blockquote><p>有一堆个数为n的石子，游戏双方轮流取石子，满足：<br>1）先手不能在第一次把所有的石子取完；<br>2）之后每次可以取的石子数介于<strong>1到对手刚取的石子数的2倍之间</strong>（包含1和对手刚取的石子数的2倍）。</p></blockquote><p>▲ 游戏规则动态化</p><p>这个游戏叫做Fibonacci Nim，肯定和Fibonacci数列：f[n]：1，2，3，5，8，13，21，34，55，89…有密切的关系。如果试验一番之后，可以猜测：先手胜当且仅当n不是Fibonacci数。换句话说，必败态构成Fibonacci数列。<br>就像“Wythof博弈”需要“Beatty定理”来帮忙一样，这里需要借助<strong>“Zeckendof定理”（齐肯多夫定理）</strong>：<u>任何正整数</u>可以表示为若干个<u>不连续</u>的Fibonacci数之和。定理的证明可以在这里看到，不过我觉得更重要的是自己动手分解一下。<br>e.g.比如，我们要分解83，注意到83被夹在55和89之间，于是把83可以写成83=55+28；然后再想办法分解28，28被夹在21和34之间，于是28=21+7；依此类推7=5+2，故；</p><p>如果n=83，我们看看这个分解有什么指导意义：假如先手取2颗，那么后手无法取5颗或更多，而5是一个Fibonacci数，如果猜测正确的话，（面临这5颗的先手实际上是整个游戏的后手）归纳得如果需要取走斐波那契数n，那么后手必胜，即那么一定是游戏的先手（此时为取5个的后手）取走这5颗石子中的最后一颗，而这个我们可以通过第二类归纳法来绕过，同样的道理，接下去先手取走接下来的后21颗中的最后一颗，再取走后55颗中的最后一颗，那么先手赢。需要注意到的是<strong>分解后不连续的若干个数单个的两倍都小于分解的最大数，即2n&lt;m</strong></p><p>▲如果n是斐波那契数，后手一定赢，如果不是，先手一定赢（先手胜当且仅当n不是斐波那契数列）。因为如果n是斐波那契数，那么先手取走数之后剩下的一定不是斐波那契数，后手必胜</p><h3 id="例题hdoj-2516"><a href="#例题hdoj-2516" class="headerlink" title="例题hdoj 2516"></a>例题hdoj 2516</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">50</span>];</span><br><span class="line"><span class="comment">// feibo</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">2</span>,arr[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">50</span>;i++) arr[i]=arr[i<span class="number">-1</span>]+arr[i<span class="number">-2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]==n) flag=<span class="number">0</span>,<span class="built_in">cout</span>&lt;&lt;<span class="string">"Second win"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">cout</span> &lt;&lt; <span class="string">"First win"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>不需要深究博弈论数学原理，只需要知道结论，就可以写出代码。如，</p><p>巴什博弈：判断mod=n%(m+1)的结果s</p><p>斐波那契博弈：判断n是否为斐波那契数</p><h2 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h2><blockquote><p>有两维各若干个物品(ak, bk)，两个人轮流从<strong>某一堆或同时从两堆中取同样多</strong>的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p></blockquote><p>这种情况下是颇为复杂的。我们用（ak，bk）（ak&lt;=bk，k=0，1，2，.……n）表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。<br>可以看出，a0=b0=0，ak是未在前面出现过的最小自然数，而bk=ak+k，奇异局势有如下三条性质：</p><ul><li><p>1.任何自然数都包含在一个且仅有一个奇异局势中。</p><p>由于ak是未在前面出现过的最小自然数，所以有ak&gt;ak-1，而bk=ak+k&gt;ak-1+k-1=bk-1&gt;ak-1。所以性质1。成立。</p></li><li><p>2.任意操作都可将奇异局势变为非奇异局势。<br>事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。</p></li><li><p>3.采用适当的方法，可以将非奇异局势变为奇异局势。</p></li></ul><p>从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，面对奇异局势，则后拿者取胜。</p><p>Betty定理:…</p><p>▲那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：</p><p>ak =[k（1+V5）/2]，bk=ak+k（k=0，1，2，.……n方括号表示取整函数）奇妙的是其中出现了黄金分割数（1+V5）/2=1.618…，因此，由ak，bk组成的矩形近似为黄金矩形，由于2/（1+V5）=（V5-1）/2，可以先求出j=[a（V5-1）/2]，若a=[（1+V5）/2]，那么a=aj，bj=aj+j，若不等于，那么a=aj+1，bj+1=aj+1+j+1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。===&gt; 如果(b-a)*(sqrt(5.0)+1)/2 == a的话就是奇异局势</p><h3 id="例题poj-1067，裸题"><a href="#例题poj-1067，裸题" class="headerlink" title="例题poj 1067，裸题"></a>例题poj 1067，裸题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a&gt;b) swap(a,b);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">floor</span>((b-a)*(<span class="built_in">sqrt</span>(<span class="number">5.0</span>)+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (a==c) <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尼姆博弈（Nim）"><a href="#尼姆博弈（Nim）" class="headerlink" title="尼姆博弈（Nim）"></a>尼姆博弈（Nim）</h2><blockquote><p>有n堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p></blockquote><p>以n=3为例子，这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情形。</p><p>然而这并不是博弈的重点，博弈之王道乃是SG值，当sg值为0的时候，就是输，不为0就是赢；</p><p>SG值：一个点的SG值就是一个不等于它的后继点SG值的且大于等于零的最小整数。</p><ul><li>不属于它后继点SG值集的值</li></ul><p>大概的意思就是：在步骤允许的情况下，与前面一个必败点的差（也就是说这个差是规定的、能走的、其中一个步数）！<br>后继点：也就是按照题目要求的走法（比如取石子可以取的数量，方法）能够走一步达到的那个点。（sg值的理解很抽象。需要多画画）</p><p>举个栗子：比如一堆石子，我们可以取任意个，那么x个石子的石子的sg值是多少呢？可以知道，0个石子sg为0，1的时候我们可以取一个，剩下0，0的sg是0(SG(0)=0)，那么mex(0)就是1，所以1的sg为1(SG(1)=1)。即SG(1) = mex{SG(0)}=mex{0}=1</p><p>例题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1847" target="_blank" rel="noopener">hdoj 1847</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">15</span>],sg[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mex</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sg[x] != <span class="number">-1</span>) <span class="keyword">return</span> sg[x];</span><br><span class="line">    <span class="comment">// 记忆化搜索,如果存在直接返回</span></span><br><span class="line">    <span class="keyword">bool</span> vis[<span class="number">1005</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1005</span>;i++) vis[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = x - arr[i];</span><br><span class="line">        <span class="keyword">if</span> (temp&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// SG值为非负整数</span></span><br><span class="line">        sg[temp] = mex(temp);</span><br><span class="line">        <span class="comment">// 需要递归调用，分治求出小的部分的结果</span></span><br><span class="line">        vis[sg[temp]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            <span class="comment">// 找到最小的数，mex&#123;0,1,2&#125;=3，mex&#123;1,2,3&#125;=0，mex&#123;0,1,3&#125;=2；</span></span><br><span class="line">            sg[x]=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> sg[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=<span class="number">10</span>; i++)</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(sg,<span class="number">-1</span>,<span class="keyword">sizeof</span>(sg));</span><br><span class="line">        <span class="keyword">if</span> (mex(n)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Kiki"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Cici"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合博弈：（博弈的精华）"><a href="#组合博弈：（博弈的精华）" class="headerlink" title="组合博弈：（博弈的精华）"></a>组合博弈：（博弈的精华）</h2><blockquote><p>组合博弈无疑是对sg值的熟练操作例如：有n堆石子，每次可以从第1堆石子里取1颗、2颗或3颗，可以从第2堆石子里取奇数颗，可以从第3堆及以后石子里取任意颗.……我们可以把它看作3个子游戏，第1个子游戏只有一堆石子，每次可以取1、2、3颗，很容易看出x颗石子的局面的SG值是×%4。第2个子游戏也是只有一堆石子，每次可以取奇数颗，经过简单的画图可以知道这个游戏有x颗石子时的SG值是×%2。第3个游戏有n-2堆石子，就是一个Nim游戏。对于原游戏的每个局面，把三个子游戏的SG值异或一下就得到了整个游戏的SG值，然后就可以根据这个SG值判断是否有必胜策略以及做出决策了。其实看作3个子游戏还是保守了些，干脆看作n个子游戏，其中第1、2个子游戏如上所述，第3个及以后的子游戏都是“1堆石子，每次取几颗都可以”，称为“任取石子游戏”，这个超简单的游戏有x颗石子的SG值显然就是x。</p></blockquote><p><a href="https://www.bilibili.com/video/av9114486?from=search&amp;seid=16453184189041006847" target="_blank" rel="noopener">SWPU-ACM每周算法讲堂-博弈论入门</a></p><h1 id="计算机博弈大赛"><a href="#计算机博弈大赛" class="headerlink" title="计算机博弈大赛"></a>计算机博弈大赛</h1><h2 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h2><blockquote><p>由冯·诺依曼、乌拉姆等人发明，因蒙特卡洛赌场而闻名，一种基于概率的方法的统称。</p><p>一种让人感觉“我去，这也行”的方法——根据大概率逼近真实结果的方法</p></blockquote><p>拉斯维加斯（Las Vegas）方法——找老婆（必须要精确找到那一个答案，其他都不行。采样越多，越有机会找到最优解）</p><ul><li>找1W人才能准确确定</li></ul><p>蒙特卡罗（Monte Carlo）方法——民意调查（一直在找，找的是逐渐贴近于最优解的结果。当样越多，越近似最优解）</p><ul><li>找了2K人大致能确定了</li></ul><p>相关方法：</p><ul><li>蒙特卡罗算法、蒙特卡罗模拟、蒙特卡罗过程</li><li>蒙特卡罗搜索树一—AlphaGo</li></ul><p>工作原理：</p><ul><li>不断抽样（中心极限定理，n-&gt;∞）</li><li>逐渐逼近（依概率逼近）</li></ul><h2 id="蒙特卡洛树搜索-（MCTS，Monte-Carlo-tree-search）"><a href="#蒙特卡洛树搜索-（MCTS，Monte-Carlo-tree-search）" class="headerlink" title="蒙特卡洛树搜索 （MCTS，Monte Carlo tree search）"></a>蒙特卡洛树搜索 （MCTS，Monte Carlo tree search）</h2><blockquote><p>一种用于某些决策过程的启发式搜索算法，最引人注目的是在游戏中的使用</p></blockquote><h3 id="双人有限零和顺序游戏"><a href="#双人有限零和顺序游戏" class="headerlink" title="双人有限零和顺序游戏"></a>双人有限零和顺序游戏</h3><p>MCTS运行所在的框架/环境是一个游戏，它本身是一个非常抽象和宽泛的概念，因此这里我们只关注一种游戏类型：双人有限零和顺序游戏。这个名词一开始听起来会有些复杂，但是实际上非常简单，现在来让我们将它分解一下：</p><ul><li>游戏：意味着我们在一种需要交互的情境中，交互通常会涉及一个或多个角色</li><li>有限：表明在任意时间点，角色之间存在的交互方式都是有限的</li><li>双人：游戏中只有两个角色</li><li>顺序：玩家依次交替进行他们的动作</li><li>零和：参与游戏的两方有完全相反的目标，换句话说就是，游戏的任意结束状态双方的收益之和等于零</li></ul><p>我们可以很轻松的验证，围棋、国际象棋和井字棋都是双人有限零和顺序游戏：有两位玩家参与，玩家能进行的动作总是有限的，双方的游戏目标是完全相反的（所有游戏的结果之和等于0）。</p><h3 id="如何表示一个游戏"><a href="#如何表示一个游戏" class="headerlink" title="如何表示一个游戏"></a>如何表示一个游戏</h3><p>从程序员的角度来看，可以用一种常见的数据结构以来表示游戏——游戏树。</p><p><img src="https://img-blog.csdnimg.cn/20181030191603540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE2MTM3NTY5,size_16,color_FFFFFF,t_70" alt=""></p><p>游戏树是一个数，其中每一个节点代表游戏的一个确定状态。从一个节点到该节点的一个子节点（如果存在）是一个移动。节点的子节点数目称为分支因子。游戏树的根节点代表游戏的初始状态。游戏树的终端节点是没有子节点的节点，至此游戏结束，无法再进行移动。终端节点的状态也就是游戏的结果（输/赢/平局）。</p><p>游戏树是一种递归的数据结构，每次选择完最佳的下一步时，会移动到下一个子节点，而这个子节点又是它子树的根节点。因此我们可以把一局游戏视为“最佳下一步”的一个问题序列，每一次都可以由一个不同根节点的游戏树表示。通常在实际应用中，我们不需要记住到当前状态的路径，因为这不是当前游戏状态的关注点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ACM-博弈论（gambling）&quot;&gt;&lt;a href=&quot;#ACM-博弈论（gambling）&quot; class=&quot;headerlink&quot; title=&quot;ACM-博弈论（gambling）&quot;&gt;&lt;/a&gt;ACM-博弈论（gambling）&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="ACM" scheme="https://nymrli.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Linux三剑客</title>
    <link href="https://nymrli.top/2019/08/30/Linux%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    <id>https://nymrli.top/2019/08/30/Linux三剑客/</id>
    <published>2019-08-30T13:37:36.000Z</published>
    <updated>2019-08-30T13:38:34.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux三剑客"><a href="#Linux三剑客" class="headerlink" title="Linux三剑客"></a>Linux三剑客</h1><h2 id="bash命令执行顺序"><a href="#bash命令执行顺序" class="headerlink" title="bash命令执行顺序"></a>bash命令执行顺序</h2><ol><li>把命令行分成单个命令词</li><li>展开别名</li><li>展开大括号的声明（{}）</li><li>展开波浪符声明（~）</li><li>命令替换$0和”)</li><li>再次把命令行分成命令词</li><li>展开文件通配（*、？、[abc]等等）</li><li>准备I/0重导向（&lt;、&gt;）</li><li>运行命令</li></ol><p>文件查找</p><p>非实时搜索locate</p><blockquote><p>速度快</p></blockquote><ul><li>更新updatabase</li></ul><p>实时搜索工具find</p><blockquote><p>搜索速度略慢</p><p>精确查找</p><p>只能搜索用户具备读取和执行权限的目录</p></blockquote><h2 id="sed-Stream-EDitor"><a href="#sed-Stream-EDitor" class="headerlink" title="sed(Stream EDitor):"></a>sed(Stream EDitor):</h2><blockquote><p>sed使用单引号</p></blockquote><p><code>sed -n &#39;22,$p&#39; test</code></p><p>指令解释:常用选项[-n]，’地址定界[22,$],编辑命令[p]’</p><p>地址定界:</p><ul><li><p>不给地址: 全文处理</p></li><li><p>单地址</p><ul><li><code>#:</code> 指定行</li><li><code>$:</code> 最后一行</li><li><code>/pattern:</code> 正则匹配</li></ul></li><li><p>地址范围</p><ul><li><code>#,#</code>,如<code>1,20</code>即1-20行<ul><li>e.g.<code>sed -n &#39;22,$p&#39; test</code></li></ul></li><li><code>#,+#</code>,如<code>2,+20</code>即2-2+20 行</li><li><code>#;#</code>如<code>3;5</code>即第3和第5行</li><li><code>/pat1/,/pat2/</code></li><li><code>#,/pat1/</code></li></ul></li><li><p>步进~</p><ul><li>1~2 奇数行<ul><li><code>sed -n &quot;1~2p&quot; f1</code></li></ul></li><li>2~2 偶数行</li></ul></li><li><p>正则</p><ul><li><blockquote><p>sed ‘/regex expression/[option] text’ filename</p></blockquote></li><li><p>^匹配每一行的开头</p></li><li><p>$匹配行的结尾</p></li><li><p>匹配包含2、3、或者4的行</p><ul><li><code>sed -n &#39;/[234]/p&#39; employee.txt</code></li></ul></li><li><p>删除所有以#开头的行</p><ul><li><code>**sed -e &#39;s/^#.\*// ; /^$/d&#39; employee.txt**</code></li></ul></li><li><p>删除所有注释和空行</p><ul><li><code>sed -e &#39;s/#.*//;/^$/ d&#39; /etc/profile</code></li></ul></li><li><p>只删除注释行不删除空行</p><ul><li><code>sed &#39;/^#.*/d&#39; /etc/profile</code></li><li></li></ul></li></ul></li></ul><p>常用选项</p><ul><li><p><code>-n</code>不自动打印</p></li><li><p><code>-f</code> 指定文件中读取编辑脚本</p><ul><li><p>script.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2~2p</span><br></pre></td></tr></table></figure><p><code>sed -n -f script.txt f1</code></p></li></ul></li><li><p><code>-r</code>支持使用拓展正则表达式</p><ul><li><code>sed -r &#39;s/(GRUB_CMDLINE_LINUX.*)&quot;$/\1 xyz&quot;/&#39;/etc/default/grub</code></li><li><code>echo&quot;/etc/sysconfig/network/&quot; | sed -r &#39;s/(.*\/)([^/]\/?$)/\1/&#39;</code></li></ul></li><li><p><code>-i.bak</code>生成备份文件bak并原处编辑</p><ul><li>如果没有-i表示只是预览,不会真正执行</li></ul></li><li><p><code>-e</code>多点编辑,即多次处理文件</p></li></ul><p>编辑命令</p><ul><li><p>d删除末世空间匹配的行,并启用下一轮循环</p><ul><li><code>sed -n &#39;d&#39; test</code>全删</li><li><code>sed -n &#39;1d&#39; test</code>只删第一行</li></ul></li><li><p>p打印当前模式空间内容,追加到默认输出后</p></li><li><p><code>a[\]test</code> 指定行追加</p></li><li><p><code>i[\]test</code> 行前插入</p></li><li><p><code>c[\]test</code> 替换行为单行或多行</p></li><li><p>= 为模式空间中的行打印行号</p><ul><li>sed -n ‘3,5{=;p}’ test</li></ul></li><li><p>! 模式空间中匹配行取反</p></li><li><p>w/path/somefile：保存模式匹配的行至指定文件<br>r/path/somefile：读取指定文件的文本至模式空间中匹配到的行后</p><ul><li><code>sed&#39;/User/r sed.txt&#39; .bashrc</code></li></ul></li><li><p>搜索代替</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;s/xxx/xxx/&apos; filename</span><br><span class="line"># sed &apos;s@xxx@xxx&apos; filename</span><br><span class="line"># sed &apos;s#xxx#xxx&apos; filename</span><br></pre></td></tr></table></figure></li><li><p>替换标记：<br>g：行内全局替换<br>p：显示替换成功的行<br>W/PATH/TO/SOMEFILE：将替换成功的行保存至文件中</p></li></ul></li></ul><p>以下命令如果需要在文本中更改 需要加 -i 或者  -ri参数</p><p><strong>用sed在aaa前加#注释</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/^aaa/#&amp;/'</span> zimu.txt      <span class="comment"># &amp;的意思是匹配任意字符（就是说未知数，啥都行）  这条命令是 替换以aaa开头的</span></span><br></pre></td></tr></table></figure><p><strong>用sed取消bbb前面的注释</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/^#(bbb)/\1/'</span> zimu.txt    <span class="comment">#\1的意思 就类似于   前面的 (bbb\） \1就是复制这个位置的内容  如果有 第二个 那么久\2就是复制第二个位置的内容</span></span><br><span class="line">sed <span class="string">'s/^#bbb/bbb/'</span> zimu.txt</span><br></pre></td></tr></table></figure><p>上面那条命令等同于</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><blockquote><p>优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一</p></blockquote><p>ifconfig获得ip_addr的命令</p><p>1.<code>ifconfig | grep inet | awk &#39;{print $2}&#39; | awk -F &#39;addr:&#39; &#39;{print $2}&#39;</code></p><p>2.<code>ifconfig | grep addr:192.168.* | awk &#39;{print$2}&#39; | awk &#39;{split($0,a,\&quot;:\&quot;);print(a[2])}&#39;</code></p><p>▲.尽量使用单引号<code>&#39;&#39;</code>,而不是<code>&quot;&quot;</code></p><p>-F分隔符</p><p>e.g.<code>echo &quot;A|B|C|D&quot; | awk -F &quot;|&quot; &#39;{print($1)}&#39;</code></p><p>NF列的个数</p><p><code>awk -F: &#39;$3&lt;10{print $1 &lt;====&gt; $NF}&#39; /etc/passwd</code></p><p>{}中的内容为要要执行的内容</p><p>NR当前行号</p><h3 id="linux单双引号区别"><a href="#linux单双引号区别" class="headerlink" title="linux单双引号区别"></a>linux单双引号区别</h3><p>双引号：把双引号的内容输出出来；如果内容中有命令，变量等，会先把命令，变量解析出结果，然后再输出最终内容来。双引号内命令或变量的写法为命令或变量或$（命令或变量）</p><p>单引号：所见即所得，将单引号内的内容原样输出，阻止所有字符的转义</p><p>不加引号：不会将含有空格的字符串视为一个整体输出，如果内容中有命令，变量等，会先把命令，变量解析出结果，然后再输出最终内容来，如果字符串含有空格等特殊字符，则不能完整输出，则需改加双引号。</p><p>倒引号（反引号Esc键下方）：进行命令的替换，在倒引号内部的shell命令将会被执行，其结果输出代替用倒引号括起来的文本。</p><p><code>echo &quot;1111\n222&quot;</code>不会转移\n</p><p><code>echo -e &quot;11111\n222&quot;</code>会转义\n</p><p><code>xargs -n1</code>每行1个元素;xargs -n2 每行2个元素;</p><h2 id="grep-Globally-search-a-Regular-Expression-and-Print"><a href="#grep-Globally-search-a-Regular-Expression-and-Print" class="headerlink" title="grep(Globally search a Regular Expression and Print)"></a>grep(Globally search a Regular Expression and Print)</h2><blockquote><p>一种强大的文本搜索工具，它能使用特定模式匹配（包括<strong>正则表达式</strong>）搜索文本，并默认输出匹配行</p></blockquote><p>常见命令<code>ps -aux | grep xxxx</code></p><p>选项与参数：</p><p>-a ：将 binary 文件以 text 文件的方式搜寻数据</p><p>-c ：计算找到 ‘搜寻字符串’ 的次数</p><p>-i ：忽略大小写的不同，所以大小写视为相同</p><p>-n ：顺便输出行号</p><p>-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！</p><p>-x –line-regexp : 只显示全列符合的列。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux三剑客&quot;&gt;&lt;a href=&quot;#Linux三剑客&quot; class=&quot;headerlink&quot; title=&quot;Linux三剑客&quot;&gt;&lt;/a&gt;Linux三剑客&lt;/h1&gt;&lt;h2 id=&quot;bash命令执行顺序&quot;&gt;&lt;a href=&quot;#bash命令执行顺序&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://nymrli.top/tags/Linux/"/>
    
      <category term="运维" scheme="https://nymrli.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>2019_6月编程笔记</title>
    <link href="https://nymrli.top/2019/08/30/2019-6%E6%9C%88%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2019/08/30/2019-6月编程笔记/</id>
    <published>2019-08-30T13:26:03.000Z</published>
    <updated>2019-08-30T13:29:17.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019-6月编程笔记"><a href="#2019-6月编程笔记" class="headerlink" title="2019_6月编程笔记"></a>2019_6月编程笔记</h1><blockquote><p>注，不少内容比较多，已单独分出去成为独立的文章，更详细的介绍可见这些文章</p></blockquote><h2 id="硬盘格式"><a href="#硬盘格式" class="headerlink" title="硬盘格式"></a>硬盘格式</h2><p>fat32 单文件4G， 做引导分区</p><p>系统引导程序能读fat32</p><p>只能主引导记录，选择能找到efi程序</p><p>exfat 支持更大空间，引导识别不了，做不了系统盘</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="all"><a href="#all" class="headerlink" title="all"></a><strong>all</strong></h3><blockquote><p><code>__all__</code>是一个字符串list；</p><p>约束作用：用来定义模块中对于<code>from XXX import *</code>时要对外导出的符号，即要暴露的借口，但它只对<code>import *</code>起作用，对<code>from XXX import XXX</code>不起作用。</p></blockquote><p><code>from njupt.zhengfang  import Zhengfang</code>是在<code>__init__.py</code>里用all标出后在该目录下的其他模块能直接通过<code>from njupt import Zhengfang</code>来调用。修改了导入的方式</p><h3 id="eval-和-exec"><a href="#eval-和-exec" class="headerlink" title="eval 和 exec"></a>eval 和 exec</h3><p>1.exec能执行<strong>多段Python代码</strong>，eval只能执行当行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exec(<span class="string">"""</span></span><br><span class="line"><span class="string">print('hello')</span></span><br><span class="line"><span class="string">print('world')</span></span><br><span class="line"><span class="string">"""</span>)</span><br><span class="line"></span><br><span class="line">eval(<span class="string">"print('hello')"</span>)</span><br></pre></td></tr></table></figure><p>2.而Python中的eval函数可以计算Python表达式，并<strong>返回结果</strong>；（exec不返回结果，print(eval(“…”))打印None）；</p><h3 id="os-environ"><a href="#os-environ" class="headerlink" title="os.environ"></a>os.environ</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用os.environ来读取和修改环境变量：</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (os.environ[<span class="string">"TEMP"</span>])</span><br><span class="line"></span><br><span class="line">mydir = <span class="string">"c:\\mydir"</span></span><br><span class="line">os.environ[<span class="string">"MYDIR"</span>] = mydir</span><br><span class="line"><span class="keyword">print</span> (os.environ[<span class="string">"MYDIR"</span>])</span><br><span class="line"></span><br><span class="line">pathV = os.environ[<span class="string">"PATH"</span>]</span><br><span class="line"><span class="keyword">print</span> (pathV)</span><br><span class="line">os.environ[<span class="string">"PATH"</span>]= mydir + <span class="string">";"</span> + os.environ[<span class="string">"PATH"</span>]</span><br><span class="line"><span class="keyword">print</span> (os.environ[<span class="string">"PATH"</span>])</span><br></pre></td></tr></table></figure><h3 id="sys-path的insert和append"><a href="#sys-path的insert和append" class="headerlink" title="sys.path的insert和append"></a>sys.path的insert和append</h3><p>python程序中使用 import XXX 时，python解析器会在当前目录、已安装和第三方模块中搜索 xxx，如果都搜索不到就会报错。</p><p>使用sys.path.append()方法可以临时添加搜索路径，方便更简洁的import其他包和模块。这种方法导入的路径会在python程序退出后失效。</p><p>1.对于模块和自己写的脚本不在同一个目录下，在脚本开头加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line">sys.path.append(’引用模块的地址<span class="string">')</span></span><br></pre></td></tr></table></figure><p>2.把路径添加到系统的环境变量，或把该路径的文件夹放进已经添加到系统环境变量的路径内。环境变量的内容会自动添加到模块搜索路径中。</p><p><strong>insert</strong>：定义搜索优先顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">1</span>, <span class="string">"./model"</span>)</span><br></pre></td></tr></table></figure><p><code>sys.path.insert(1, &quot;./crnn&quot;)</code>定义搜索路径的优先顺序，序号从0开始，表示最大优先级，<code>sys.path.insert()</code>加入的也是临时搜索路径，程序退出后失效。</p><h3 id="sphinx使用"><a href="#sphinx使用" class="headerlink" title="sphinx使用"></a>sphinx使用</h3><p><code>pip install sphinx</code></p><p>1.新建docs文件夹</p><p>2.<code>sphinx-quickstart</code></p><p>3.配置</p><p>教程说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; Root path <span class="keyword">for</span> the documentation [.]: doc  <span class="comment"># 在当前目录下新建doc文件夹存放sphinx相关信息</span></span><br><span class="line">&gt; Separate <span class="built_in">source</span> and build directories (y/n) [n]:   <span class="comment"># 默认，直接回车</span></span><br><span class="line">&gt; Name prefix <span class="keyword">for</span> templates and static dir [_]:</span><br><span class="line">&gt; Project name: python123   <span class="comment"># 输入项目名称</span></span><br><span class="line">&gt; Author name(s): 123   <span class="comment"># 作者</span></span><br><span class="line">&gt; Project version: 1.0  <span class="comment"># 项目版本</span></span><br><span class="line">&gt; Project release [1.0]:</span><br><span class="line">&gt; Project language [en]:   <span class="comment"># 默认，回车</span></span><br><span class="line">&gt; Source file suffix [.rst]:</span><br><span class="line">&gt; Name of your master document (without suffix) [index]:</span><br><span class="line">&gt; Do you want to use the epub builder (y/n) [n]:</span><br><span class="line">&gt; autodoc: automatically insert docstrings from modules (y/n) [n]: y  <span class="comment"># 这个很重要，输入y</span></span><br><span class="line">&gt; doctest: automatically <span class="built_in">test</span> code snippets <span class="keyword">in</span> doctest blocks (y/n) [n]:</span><br><span class="line">&gt; intersphinx: link between Sphinx documentation of different projects (y/n) [n]:</span><br><span class="line">&gt; todo: write <span class="string">"todo"</span> entries that can be shown or hidden on build (y/n) [n]:</span><br><span class="line">&gt; coverage: checks <span class="keyword">for</span> documentation coverage (y/n) [n]:</span><br><span class="line">&gt; pngmath: include math, rendered as PNG images (y/n) [n]:</span><br><span class="line">&gt; mathjax: include math, rendered <span class="keyword">in</span> the browser by MathJax (y/n) [n]:</span><br><span class="line">&gt; ifconfig: conditional inclusion of content based on config values (y/n) [n]:</span><br><span class="line">&gt; viewcode: include links to the <span class="built_in">source</span> code of documented Python objects (y/n) [n]: y  <span class="comment"># 很重要，输入y，表示将源码也放到文档中，你看很多python的模块的文档，其实都是包含代码的。</span></span><br><span class="line">&gt; Create Makefile? (y/n) [y]:</span><br><span class="line">&gt; Create Windows <span class="built_in">command</span> file? (y/n) [y]:</span><br></pre></td></tr></table></figure><p>windows实测：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(Python_web) E:\Python_web\Code\Quan&gt;sphinx-quickstart</span><br><span class="line"></span><br><span class="line">Welcome to the Sphinx 2.1.0 quickstart utility.</span><br><span class="line"></span><br><span class="line">Please enter values <span class="keyword">for</span> the following settings (just press Enter to</span><br><span class="line">accept a default value, <span class="keyword">if</span> one is given <span class="keyword">in</span> brackets).</span><br><span class="line"></span><br><span class="line">Selected root path: .</span><br><span class="line"></span><br><span class="line">You have two options <span class="keyword">for</span> placing the build directory <span class="keyword">for</span> Sphinx output.</span><br><span class="line">Either, you use a directory <span class="string">"_build"</span> within the root path, or you separate</span><br><span class="line"><span class="string">"source"</span> and <span class="string">"build"</span> directories within the root path.</span><br><span class="line">&gt; Separate <span class="built_in">source</span> and build directories (y/n) [n]: n</span><br><span class="line"></span><br><span class="line">The project name will occur <span class="keyword">in</span> several places <span class="keyword">in</span> the built documentation.</span><br><span class="line">&gt; Project name: TaobaoQuan</span><br><span class="line">&gt; Author name(s): Mrli</span><br><span class="line">&gt; Project release []: 1.0</span><br><span class="line"></span><br><span class="line">If the documents are to be written <span class="keyword">in</span> a language other than English,</span><br><span class="line">you can select a language here by its language code. Sphinx will <span class="keyword">then</span></span><br><span class="line">translate text that it generates into that language.</span><br><span class="line"></span><br><span class="line">For a list of supported codes, see</span><br><span class="line">http://sphinx-doc.org/config.html<span class="comment">#confval-language.</span></span><br><span class="line">&gt; Project language [en]: en</span><br><span class="line"></span><br><span class="line">Creating file .\conf.py.</span><br><span class="line">Creating file .\index.rst.</span><br><span class="line">Creating file .\Makefile.</span><br><span class="line">Creating file .\make.bat.</span><br><span class="line"></span><br><span class="line">Finished: An initial directory structure has been created.</span><br><span class="line"></span><br><span class="line">You should now populate your master file .\index.rst and create other documentation</span><br><span class="line"><span class="built_in">source</span> files. Use the Makefile to build the docs, like so:</span><br><span class="line">   make builder</span><br><span class="line"><span class="built_in">where</span> <span class="string">"builder"</span> is one of the supported builders, e.g. html, latex or linkcheck.</span><br></pre></td></tr></table></figure><p>编写好目录下的所有<code>.rst</code>（默认生成了模板<code>index.rst</code>）文件后<code>.\make.bat html</code>可以生成网页目录</p><h4 id="conf-py默认模板"><a href="#conf-py默认模板" class="headerlink" title="conf.py默认模板"></a>conf.py默认模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Configuration file for the Sphinx documentation builder.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file only contains a selection of the most common options. For a full</span></span><br><span class="line"><span class="comment"># list see the documentation:</span></span><br><span class="line"><span class="comment"># http://www.sphinx-doc.org/en/master/config</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Path setup --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If extensions (or modules to document with autodoc) are in another directory,</span></span><br><span class="line"><span class="comment"># add these directories to sys.path here. If the directory is relative to the</span></span><br><span class="line"><span class="comment"># documentation root, use os.path.abspath to make it absolute, like shown here.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># import os</span></span><br><span class="line"><span class="comment"># import sys</span></span><br><span class="line"><span class="comment"># sys.path.insert(0, os.path.abspath('.'))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Project information -----------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">project = <span class="string">'TaobaoQuan'</span></span><br><span class="line">copyright = <span class="string">'2019, Mrli'</span></span><br><span class="line">author = <span class="string">'Mrli'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The full version, including alpha/beta/rc tags</span></span><br><span class="line">release = <span class="string">'1.0'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- General configuration ---------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add any Sphinx extension module names here, as strings. They can be</span></span><br><span class="line"><span class="comment"># extensions coming with Sphinx (named 'sphinx.ext.*') or your custom</span></span><br><span class="line"><span class="comment"># ones.</span></span><br><span class="line">extensions = [</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add any paths that contain templates here, relative to this directory.</span></span><br><span class="line">templates_path = [<span class="string">'_templates'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># List of patterns, relative to source directory, that match files and</span></span><br><span class="line"><span class="comment"># directories to ignore when looking for source files.</span></span><br><span class="line"><span class="comment"># This pattern also affects html_static_path and html_extra_path.</span></span><br><span class="line">exclude_patterns = [<span class="string">'_build'</span>, <span class="string">'Thumbs.db'</span>, <span class="string">'.DS_Store'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Options for HTML output -------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The theme to use for HTML and HTML Help pages.  See the documentation for</span></span><br><span class="line"><span class="comment"># a list of builtin themes.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">html_theme = <span class="string">'alabaster'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add any paths that contain custom static files (such as style sheets) here,</span></span><br><span class="line"><span class="comment"># relative to this directory. They are copied after the builtin static files,</span></span><br><span class="line"><span class="comment"># so a file named "default.css" will overwrite the builtin "default.css".</span></span><br><span class="line">html_static_path = [<span class="string">'_static'</span>]</span><br></pre></td></tr></table></figure><p><img src="/2019/08/30/2019-6月编程笔记/default.png" alt="default"></p><h4 id="Gaoliang模板"><a href="#Gaoliang模板" class="headerlink" title="Gaoliang模板"></a>Gaoliang模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Configuration file for the Sphinx documentation builder.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file does only contain a selection of the most common options. For a</span></span><br><span class="line"><span class="comment"># full list see the documentation:</span></span><br><span class="line"><span class="comment"># http://www.sphinx-doc.org/en/master/config</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Path setup --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If extensions (or modules to document with autodoc) are in another directory,</span></span><br><span class="line"><span class="comment"># add these directories to sys.path here. If the directory is relative to the</span></span><br><span class="line"><span class="comment"># documentation root, use os.path.abspath to make it absolute, like shown here.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># sys.path.insert(0, os.path.abspath('.'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Insert NJUPT-API' path into the system.</span></span><br><span class="line">sys.path.insert(<span class="number">0</span>, os.path.abspath(<span class="string">'..'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Project information -----------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">project = <span class="string">'...'</span></span><br><span class="line">copyright = <span class="string">'...'</span></span><br><span class="line">author = <span class="string">'...'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The short X.Y version</span></span><br><span class="line">version = <span class="string">''</span></span><br><span class="line"><span class="comment"># The full version, including alpha/beta/rc tags</span></span><br><span class="line">release = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- General configuration ---------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If your documentation needs a minimal Sphinx version, state it here.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># needs_sphinx = '1.0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add any Sphinx extension module names here, as strings. They can be</span></span><br><span class="line"><span class="comment"># extensions coming with Sphinx (named 'sphinx.ext.*') or your custom</span></span><br><span class="line"><span class="comment"># ones.</span></span><br><span class="line">extensions = [</span><br><span class="line">    <span class="string">'sphinx.ext.autodoc'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">html_logo = <span class="string">"_static/logo_tiny.png"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add any paths that contain templates here, relative to this directory.</span></span><br><span class="line">templates_path = [<span class="string">'_templates'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The suffix(es) of source filenames.</span></span><br><span class="line"><span class="comment"># You can specify multiple suffix as a list of string:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># source_suffix = ['.rst', '.md']</span></span><br><span class="line">source_suffix = <span class="string">'.rst'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The master toctree document.</span></span><br><span class="line">master_doc = <span class="string">'index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The language for content autogenerated by Sphinx. Refer to documentation</span></span><br><span class="line"><span class="comment"># for a list of supported languages.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is also used if you do content translation via gettext catalogs.</span></span><br><span class="line"><span class="comment"># Usually you set "language" from the command line for these cases.</span></span><br><span class="line">language = <span class="string">'zh_CN'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of patterns, relative to source directory, that match files and</span></span><br><span class="line"><span class="comment"># directories to ignore when looking for source files.</span></span><br><span class="line"><span class="comment"># This pattern also affects html_static_path and html_extra_path .</span></span><br><span class="line">exclude_patterns = [<span class="string">'_build'</span>, <span class="string">'Thumbs.db'</span>, <span class="string">'.DS_Store'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the Pygments (syntax highlighting) style to use.</span></span><br><span class="line">pygments_style = <span class="string">'sphinx'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Options for HTML output -------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The theme to use for HTML and HTML Help pages.  See the documentation for</span></span><br><span class="line"><span class="comment"># a list of builtin themes.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># html_theme = 'sphinx_rtd_theme'</span></span><br><span class="line"><span class="comment"># html_theme = 'alabaster'</span></span><br><span class="line"><span class="comment"># html_theme = 'flask'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Theme options are theme-specific and customize the look and feel of a theme</span></span><br><span class="line"><span class="comment"># further.  For a list of options available for each theme, see the</span></span><br><span class="line"><span class="comment"># documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">html_theme_options = &#123;</span><br><span class="line">    <span class="comment"># 'show_powered_by': False,</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add any paths that contain custom static files (such as style sheets) here,</span></span><br><span class="line"><span class="comment"># relative to this directory. They are copied after the builtin static files,</span></span><br><span class="line"><span class="comment"># so a file named "default.css" will overwrite the builtin "default.css".</span></span><br><span class="line">html_static_path = [<span class="string">'_static'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom sidebar templates, must be a dictionary that maps document names</span></span><br><span class="line"><span class="comment"># to template names.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default sidebars (for documents that don't match any pattern) are</span></span><br><span class="line"><span class="comment"># defined by theme itself.  Builtin themes are using these templates by</span></span><br><span class="line"><span class="comment"># default: ``['localtoc.html', 'relations.html', 'sourcelink.html',</span></span><br><span class="line"><span class="comment"># 'searchbox.html']``.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">html_show_sourcelink = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Options for HTMLHelp output ---------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output file base name for HTML help builder.</span></span><br><span class="line">htmlhelp_basename = <span class="string">'NJUPT-APIdoc'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Options for LaTeX output ------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">latex_elements = &#123;</span><br><span class="line">    <span class="comment"># The paper size ('letterpaper' or 'a4paper').</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 'papersize': 'letterpaper',</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># The font size ('10pt', '11pt' or '12pt').</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 'pointsize': '10pt',</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Additional stuff for the LaTeX preamble.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 'preamble': '',</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Latex figure (float) alignment</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 'figure_align': 'htbp',</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Grouping the document tree into LaTeX files. List of tuples</span></span><br><span class="line"><span class="comment"># (source start file, target name, title,</span></span><br><span class="line"><span class="comment">#  author, documentclass [howto, manual, or own class]).</span></span><br><span class="line">latex_documents = [</span><br><span class="line">    (master_doc, <span class="string">'NJUPT-API.tex'</span>, <span class="string">'NJUPT-API Documentation'</span>,</span><br><span class="line">     <span class="string">'gaoliang'</span>, <span class="string">'manual'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Options for manual page output ------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># One entry per manual page. List of tuples</span></span><br><span class="line"><span class="comment"># (source start file, name, description, authors, manual section).</span></span><br><span class="line">man_pages = [</span><br><span class="line">    (master_doc, <span class="string">'njupt-api'</span>, <span class="string">'NJUPT-API Documentation'</span>,</span><br><span class="line">     [author], <span class="number">1</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Options for Texinfo output ----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Grouping the document tree into Texinfo files. List of tuples</span></span><br><span class="line"><span class="comment"># (source start file, target name, title, author,</span></span><br><span class="line"><span class="comment">#  dir menu entry, description, category)</span></span><br><span class="line">texinfo_documents = [</span><br><span class="line">    (master_doc, <span class="string">'NJUPT-API'</span>, <span class="string">'NJUPT-API Documentation'</span>,</span><br><span class="line">     author, <span class="string">'NJUPT-API'</span>, <span class="string">'One line description of project.'</span>,</span><br><span class="line">     <span class="string">'Miscellaneous'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Extension configuration -------------------------------------------------</span></span><br></pre></td></tr></table></figure><p><img src="/2019/08/30/2019-6月编程笔记/sphinx_rtd_theme风格.png" alt="sphinx_rtd_theme风格"></p><p><a href="https://www.cnblogs.com/niejinmei/p/8918858.html" target="_blank" rel="noopener">python代码docstring生成文档之sphinx</a></p><h3 id="Python-验证码识别"><a href="#Python-验证码识别" class="headerlink" title="Python 验证码识别"></a>Python 验证码识别</h3><p>通过pytesseract<a href="https://blog.csdn.net/weixin_42812527/article/details/81264189" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42812527/article/details/81264189</a></p><p>windows10安装使用pytesseract坑：<a href="https://blog.csdn.net/weixin_42812527/article/details/81908674" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42812527/article/details/81908674</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">captcha_url = <span class="string">'http://182.92.169.64:8088/808gps/rand.action'</span></span><br><span class="line">captcha_content = requests.get(url=captcha_url)</span><br><span class="line"><span class="comment"># 获得图片的二进制内容</span></span><br><span class="line">captcha_content = captcha_content.content</span><br><span class="line"><span class="comment"># 用BytesIO读取图片</span></span><br><span class="line">image = Image.open(BytesIO(captcha_content))</span><br><span class="line"><span class="comment"># 转化为灰度图</span></span><br><span class="line">imgry = image.convert(<span class="string">'L'</span>)</span><br><span class="line"><span class="comment"># 二值化处理</span></span><br><span class="line">table = [<span class="number">0</span> <span class="keyword">if</span> i &lt; <span class="number">140</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)]</span><br><span class="line"><span class="comment"># 使字体更加突出的显示</span></span><br><span class="line">out = imgry.point(table,<span class="string">'1'</span>)</span><br><span class="line"><span class="comment"># out.show()</span></span><br><span class="line">captcha = pytesseract.image_to_string(out)</span><br><span class="line">captcha = captcha.strip()</span><br><span class="line">captcha = captcha.upper()</span><br><span class="line"><span class="keyword">print</span> (captcha)</span><br></pre></td></tr></table></figure><h2 id="Python异常"><a href="#Python异常" class="headerlink" title="Python异常"></a>Python异常</h2><blockquote><p>Python所有的错误都是从BaseException类派生的，常见的错误类型和继承关系</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StandardError</span><br><span class="line">      |    +-- BufferError</span><br><span class="line">      |    +-- ArithmeticError</span><br><span class="line">      |    |    +-- FloatingPointError</span><br><span class="line">      |    |    +-- OverflowError</span><br><span class="line">      |    |    +-- ZeroDivisionError</span><br><span class="line">      |    +-- AssertionError</span><br><span class="line">      |    +-- AttributeError</span><br><span class="line">      |    +-- EnvironmentError</span><br><span class="line">      |    |    +-- IOError</span><br><span class="line">      |    |    +-- OSError</span><br><span class="line">      |    |         +-- WindowsError (Windows)</span><br><span class="line">      |    |         +-- VMSError (VMS)</span><br><span class="line">      |    +-- EOFError</span><br><span class="line">      |    +-- ImportError</span><br><span class="line">      |    +-- LookupError</span><br><span class="line">      |    |    +-- IndexError</span><br><span class="line">      |    |    +-- KeyError</span><br><span class="line">      |    +-- MemoryError</span><br><span class="line">      |    +-- NameError</span><br><span class="line">      |    |    +-- UnboundLocalError</span><br><span class="line">      |    +-- ReferenceError</span><br><span class="line">      |    +-- RuntimeError</span><br><span class="line">      |    |    +-- NotImplementedError</span><br><span class="line">      |    +-- SyntaxError</span><br><span class="line">      |    |    +-- IndentationError</span><br><span class="line">      |    |         +-- TabError</span><br><span class="line">      |    +-- SystemError</span><br><span class="line">      |    +-- TypeError</span><br><span class="line">      |    +-- ValueError</span><br><span class="line">      |         +-- UnicodeError</span><br><span class="line">      |              +-- UnicodeDecodeError</span><br><span class="line">      |              +-- UnicodeEncodeError</span><br><span class="line">      |              +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">   +-- ImportWarning</span><br><span class="line">   +-- UnicodeWarning</span><br><span class="line">   +-- BytesWarning</span><br></pre></td></tr></table></figure><h3 id="java异常"><a href="#java异常" class="headerlink" title="java异常"></a>java异常</h3><p><img src="https://camo.githubusercontent.com/27aa104d93ba0738be0f3d2e7d5b096c1619d12d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f457863657074696f6e2e706e67" alt=""></p><h2 id="继承、Super"><a href="#继承、Super" class="headerlink" title="继承、Super"></a>继承、Super</h2><blockquote><p><code>super()</code> 函数是用于调用父类(超类)的一个方法，<em>只有在新式类中可以使用</em></p><p>super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO，Method Resolution Order，采用广度优先（区别于深度优先）的规则定义）、重复调用（钻石继承）等种种问题。</p><p>MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。</p></blockquote><p><strong>语法</strong></p><p>以下是 super() 方法的语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 菜鸟教程</span></span><br><span class="line">super(type [, object-<span class="keyword">or</span>-type])</span><br><span class="line"><span class="comment"># 个人理解</span></span><br><span class="line">super( ThisClass [, object(self)])</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li>type – 类（type），通常是当前子类。</li><li>object-or-type – 类实例，一般是 self</li></ul><p><strong>含义</strong></p><p>用<code>self</code>这个实例对象去查找<code>ThisClass</code>类的父类拥有的属性（成员方法、数据成员）</p><p>▲. Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 <strong>super().xxx</strong> 代替 <strong>super(Class, self).xxx</strong> :</p><p>即平时写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *arg, **kwarg)</span>:</span></span><br><span class="line">        super(TestClass, self).__init__() <span class="comment"># 此时init里不用self</span></span><br><span class="line">        <span class="comment"># 等价于 super().__init__() , 含义是用父类的构造函数初始化某些变量</span></span><br><span class="line">        <span class="comment"># 相当于旧式类的 object.__init__(self) # 需要传参self</span></span><br><span class="line">        self.arg = arg</span><br><span class="line">        self.kwarg = kwarg</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsSuper</span><span class="params">(object)</span>:</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsSub</span><span class="params">(clsSuper)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(super().age)</span><br><span class="line">        <span class="comment"># 当只是单继承的时候可以直接使用 print(clsSuper.age)，</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = clsSuper(<span class="string">'cl'</span>)</span><br><span class="line">    b = clsSub()</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><code>super().func()</code>是不用传参<code>self</code>的</li><li><code>super(type, obj).func()</code>函数调用的是obj实例在MRO中下一个父类的可调用func()，而不是type的父类中的func()。即调用最近的可用func()</li><li>使用<code>super()</code>不用指定父类的名称，便于修改维护；同时当继承多个类A、B的时候，用<code>super().__init__()</code>相当于调用多个类的<code>A.__ini__(self)</code>、<code>B.__ini__(self)</code></li></ul><h2 id="与java对比"><a href="#与java对比" class="headerlink" title="与java对比"></a>与java对比</h2><ol><li>Python中子类不会默认调用父类的构造函数，即下面代码。并不会要要求给传<code>name</code>。当然也可以理解为跟java一样调用了一个全空、没有任何内容的构造函数，但是在python中不需要显性写出来，原因部分是特点2（java中存在有参数的构造函数时，必须将空参数的构造函数显式写出，不然子类默认隐式调用空参数的构造函数时会报错说不存在）。</li><li>Python中的构造函数只有一个。但由于存在<code>*arg,**kwarg</code>的存在，所以只要执行类型检查执行不同的代码；即实现了多个构造函数</li><li>Python的类可以多继承，java只能单继承。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsSuper</span><span class="params">(object)</span>:</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        print(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsSub</span><span class="params">(clsSuper)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        print(age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    b = clsSub(<span class="number">18</span>)</span><br></pre></td></tr></table></figure><h2 id="Cmder-Windows-下的终端神器"><a href="#Cmder-Windows-下的终端神器" class="headerlink" title="Cmder Windows 下的终端神器"></a><a href="https://www.cnblogs.com/onlymisaky/p/8534626.html" target="_blank" rel="noopener">Cmder Windows 下的终端神器</a></h2><h2 id="视频字幕制作"><a href="#视频字幕制作" class="headerlink" title="视频字幕制作"></a>视频字幕制作</h2><p>arctime国人自制的免费软件。自动打轴和语音识别功能积分使用注册绑定任务、签到白嫖能鸽很久。</p><p>制作完成后保存工程文件，ass，软件-&gt;导出，可以导出一份srt字母文件，可以直接上传到B站当CC字幕使用</p><p>Pr自带工具一句一句打===&gt;ps批量制作字幕图层===&gt;arctime</p><h2 id="mitmProxy手机抓包软件"><a href="#mitmProxy手机抓包软件" class="headerlink" title="mitmProxy手机抓包软件"></a>mitmProxy手机抓包软件</h2><h3 id="Q-为什么好多加密算法都要用到异或？"><a href="#Q-为什么好多加密算法都要用到异或？" class="headerlink" title="Q:为什么好多加密算法都要用到异或？"></a>Q:为什么好多加密算法都要用到异或？</h3><p>A:位操作 cpu运行非常快</p><blockquote><p>加密的源是形形色色的，其加密结果也要求是尽量差异化。在二元的位运算符中，也就只有”位与”、”位或”、”异或”三种。一个加密过程往往需要经过若干次运算，若采用”位与”运算，竟多次计算的话，其结果值将趋向于比特位全部是0；同样，采用”位或”的话，其结果值将趋向于比特位全部是1。剩下的只有采用”异或”运算了</p></blockquote><h2 id="测试注解的正确性"><a href="#测试注解的正确性" class="headerlink" title="测试注解的正确性"></a>测试注解的正确性</h2><p>注解仅仅起到了注释的作用，不会影响代码的执行，所以即使你类型注解写错了，程序运行的时候还是会按照正确的类型去运行。<br>Python提供了一个工具方便我们测试代码里的类型注解正确性<code>mypy</code></p><p>首先安装：<code>pip install mypy</code></p><p>使用测试：<code>mypy filename.py</code></p><p>Python3.7新特性<code>dataclass</code></p><p>写法对比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for student"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        super(student, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for ClassName"""</span></span><br><span class="line">    name: str</span><br><span class="line">    age: int</span><br></pre></td></tr></table></figure><p>功能对比</p><ul><li><p>传统的class写法的<strong>eq</strong>并不认为两个实例相同，即<strong>存储数据</strong>不同</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for student"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        super(student, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">s1 = student(<span class="string">'cl'</span>, <span class="number">18</span>)</span><br><span class="line">s2 = student(<span class="string">'cl'</span>, <span class="number">18</span>)</span><br><span class="line">print(s1 == s2)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据的角度来讲，这两个实例代表的是同一个Student，理应相等。所以我们可以重写内置的__eq__方法如下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for student"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        super(student, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__class__ <span class="keyword">is</span> <span class="keyword">not</span> other.__class__:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> (self.name, self.age) == (other.name, other.age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = student(<span class="string">'cl'</span>, <span class="number">18</span>)</span><br><span class="line">s2 = student(<span class="string">'cl'</span>, <span class="number">18</span>)</span><br><span class="line">print(s1 == s2)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; True</span></span><br></pre></td></tr></table></figure></li><li></li></ul></li></ul><blockquote><p>注意:</p><p>name和age并不是Class Attribute，也就是不能通过NewStudent.name和NewStudent.age直接访问，大家可以通过dir(NewStudent)验证一下。</p><p>name和age后面的类型指定并没有实际的效果，也就是如果我们实例化传入错误的数据类型，不会报错，比如 s3 = NewStudent(‘Mark’, ‘20’)</p></blockquote><p>更多功能</p><p>通过使用装饰器的选项，可以为用例进一步定制 data class，默认选项是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)</span></span><br></pre></td></tr></table></figure><ul><li><code>init</code>决定是否生成<code>__init__</code> dunder 方法</li><li><code>repr</code>决定是否生成<code>__repr__</code> dunder方法</li><li><code>eq</code>对<code>__eq__</code> dunder 方法也是如此，它决定相等性检查的行为（your_class_instance == another_instance）</li><li><code>order</code> 实际上创建了四种 dunder 方法，它们确定所有检查<code>小于</code>，<code>and/or</code>，<code>大于</code>的行为，如果将其设置为 true，则可以对对象列表进行排序。</li></ul><p>最后两个选项确定对象是否可以被哈希化，如果你想使用你的 class 的对象作为字典键的话，这是必要的。</p><p>链接：<a href="https://www.jianshu.com/p/bea5c202cf85" target="_blank" rel="noopener">https://www.jianshu.com/p/bea5c202cf85</a></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>不是进程，也不是线程，是用户空间调度的完成并发处理的方式。是在用户空间内部完成的。线程和进程是操作系统内完成的。</p><h2 id="Github感谢贡献者"><a href="#Github感谢贡献者" class="headerlink" title="Github感谢贡献者"></a>Github感谢贡献者</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/spencerwooo/dowww/graphs/contributors"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://opencollective.com/dowww/contributors.svg?button=false"</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="equals-和"><a href="#equals-和" class="headerlink" title="equals 和 =="></a>equals 和 ==</h2><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p><p><strong>equals()</strong> : 它的作用也是判断<strong>两个对象是否相等</strong>。但它一般有两种使用情况：</p><ul><li>情况1：类没有覆盖 equals() 方法。<ul><li>即通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li></ul></li><li>情况2：类覆盖了 equals() 方法。<ul><li><u>一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等</u>；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul></li></ul><p><strong>说明：</strong></p><ul><li>String 中的 equals 方法是被重写过的，<strong>因为 object 的 equals 方法是比较的对象的内存地址(即<code>==</code>)</strong>，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><h3 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals（）</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个int整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。<strong><code>hashCode()</code>在散列表中才有用，在其它情况下没用。</strong>在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><h3 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h3><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）==&gt;通过统一哈希值，使两个对象equals时结果返回哈希值一致便输出true</li></ol><h2 id="static-静态代码块与-非静态代码块、构造方法"><a href="#static-静态代码块与-非静态代码块、构造方法" class="headerlink" title="static{}静态代码块与{}非静态代码块、构造方法"></a>static{}静态代码块与{}非静态代码块、构造方法</h2><blockquote><p>类的执行顺序: static{}静态代码块–&gt;{}静态代码块–&gt;构造方法</p></blockquote><p>static{}静态代码块与{}非静态代码块不同点：</p><ul><li>静态代码块只在第一次new执行一次，之后不再执行<ul><li>一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是<strong>主动执行</strong>的。</li></ul></li><li>而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。<ul><li>如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法</li></ul></li></ul><p>两者的区别是 静态代码块是<strong>自动执行</strong>的而静态方法是<strong>被调用才执行</strong>的.</p><p>非静态代码块与构造函数的区别是：</p><ul><li><strong>非静态代码块</strong>是给<u>所有对象进行统一初始化</u>，而<strong>构造函数是</strong>给<u>对应的对象初始化</u>因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">testClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"默认构造方法！--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">"非静态代码块！--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 静态代码块,指挥执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">"静态代码块！--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"静态方法中的内容! --"</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">"静态方法中的代码块！--"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    testClass test = <span class="keyword">new</span> testClass();   </span><br><span class="line">       testClass.test();<span class="comment">//静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！--</span></span><br><span class="line">    System.out.println();</span><br><span class="line">    testClass test2 = <span class="keyword">new</span> testClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！--</span></span><br><span class="line"><span class="comment">非静态代码块！--默认构造方法！--</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/wzlsunice88/article/details/80743160" target="_blank" rel="noopener">Ansible 运维自动化 ( 配置管理工具 )</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019-6月编程笔记&quot;&gt;&lt;a href=&quot;#2019-6月编程笔记&quot; class=&quot;headerlink&quot; title=&quot;2019_6月编程笔记&quot;&gt;&lt;/a&gt;2019_6月编程笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;注，不少内容比较多，已单独分出去成为独立的
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://nymrli.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫常规流程</title>
    <link href="https://nymrli.top/2019/08/30/Python%E7%88%AC%E8%99%AB%E5%B8%B8%E8%A7%84%E6%B5%81%E7%A8%8B/"/>
    <id>https://nymrli.top/2019/08/30/Python爬虫常规流程/</id>
    <published>2019-08-30T13:07:05.000Z</published>
    <updated>2019-08-30T13:23:18.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python爬虫常规流程"><a href="#Python爬虫常规流程" class="headerlink" title="Python爬虫常规流程"></a>Python爬虫常规流程</h1><p>以爬取<strong>有道翻译</strong>为例子。</p><h2 id="挖取可自用的API"><a href="#挖取可自用的API" class="headerlink" title="挖取可自用的API"></a>挖取可自用的API</h2><blockquote><p>web 端的有道翻译，在之前是直接可以爬的。也就是说只要获取到了他的接口，你就可以肆无忌惮的使用他的接口进行翻译而不需要支付任何费用。那么自从有道翻译推出他的API服务的时候，就对这个接口做一个反爬虫机制（如果大家都能免费使用到他的翻译接口，那他的APl服务怎么赚钱）。这个反爬虫机制在爬虫领域算是一个非常经典的技术手段。</p></blockquote><p>1.查看要爬取的内容是否是静态加载的。</p><p>比如在翻译输入框中输入<code>apple</code>，翻译输出框中会出现<code>苹果</code>，然后在<code></code>页面中右键-&gt;查看网页源代码<code>，直接</code>Ctrl+F<code>搜索是否存在</code>apple<code>或者</code>苹果`，如果没有的话，证明不是静态加载的。</p><p>2.查看内容如何加载的</p><ul><li>页面初始化get、post请求</li><li>局部刷新发送ajax请求<ul><li>如果存在局部更新内容产生变化的（Url没有发生变化，或者没有页面发生跳转、刷新的感觉），一般都是采用的AJAX更新技术，发送了POST、GET请求获得局部需要更新的数据，可以直接在Network项的XHR里面找到动态加载的文件 (可以看下Ajax技术实现了解下为什么可以在XHR中找到)</li></ul></li></ul><blockquote><p>这边的话，可以看到输入一个要翻译的内容后，页面没有产生多大的变化，因此猜想是AJAX加载的。在XHR里也找到了相应的Response文件。</p></blockquote><p>使用Chrome自带的抓包工具（<code>页面中右键-&gt;检查</code>或者按<code>F12</code>都可以打开，然后选择<code>-&gt;Network项</code>（网络监听窗口）就可以看到抓包的数据了）</p><p>然后同样在翻译输入框中输入<code>apple</code>，然后可以观察到抓包工具中出现了很多内容。为了确定<code>apple</code>的翻译<code>苹果</code>是在哪个文件中返回的，可以直接<code>Ctrl+F</code>打开搜索框后直接搜索，如图所示。</p><p><img src="/2019/08/30/Python爬虫常规流程/chrome抓包.png" alt="chrome抓包"></p><h2 id="JS加密破解"><a href="#JS加密破解" class="headerlink" title="JS加密破解"></a>JS加密破解</h2><h3 id="1-使用Python进行模仿JS加密计算"><a href="#1-使用Python进行模仿JS加密计算" class="headerlink" title="1.使用Python进行模仿JS加密计算"></a>1.使用Python进行模仿JS加密计算</h3><h3 id="2-运行JS代码获得加密结果"><a href="#2-运行JS代码获得加密结果" class="headerlink" title="2.运行JS代码获得加密结果"></a>2.运行JS代码获得加密结果</h3><ul><li>使用python-js2py模块</li></ul><p>如一个参数生成的结果是这样的<code>{&quot;LoginKey&quot;:&quot;46fd82c2-3108-b2a4-3056-0eaa426f975b&quot;,&quot;data&quot;:&quot;{\&quot;User_Oid\&quot;:\&quot;账号\&quot;,\&quot;User_Password\&quot;:\&quot;密码\&quot;}&quot;}</code></p><p>找到生成<code>LoginKey</code>值的JS文件加密算法是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.floor((<span class="number">1</span> + <span class="built_in">Math</span>.random()) * <span class="number">0x10000</span>).toString(<span class="number">16</span>).substring(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">guid</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s4() + s4() + <span class="string">'-'</span> + s4() + <span class="string">'-'</span> + s4() + <span class="string">'-'</span> + s4() + <span class="string">'-'</span> + s4() + s4() + s4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后安装<code>pip install js2py</code>后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> js2py</span><br><span class="line">LoginKey = js2py.eval_js(<span class="string">'''</span></span><br><span class="line"><span class="string">function s4() &#123;</span></span><br><span class="line"><span class="string">return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">function guid() &#123;</span></span><br><span class="line"><span class="string">return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">var a = guid()  // 在这里是需要调用的</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"><span class="keyword">print</span> LoginKey</span><br></pre></td></tr></table></figure><p>就能获得结果了。</p><ul><li>使用pyexe、PyV8、js2py模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_des_psswd</span><span class="params">(data, key)</span>:</span></span><br><span class="line">    jsstr = get_js()</span><br><span class="line">    ctx = execjs.compile(jsstr) <span class="comment">#加载JS文件</span></span><br><span class="line">    <span class="keyword">return</span> (ctx.call(<span class="string">'strEnc'</span>, data, key))  <span class="comment">#调用js方法  第一个参数是JS的方法名，后面的data和key是js方法的参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_js</span><span class="params">()</span>:</span></span><br><span class="line">    f = open(<span class="string">"./../lib/des.js"</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="comment"># 打开JS文件</span></span><br><span class="line">    line = f.readline()</span><br><span class="line">    htmlstr = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> line:</span><br><span class="line">        htmlstr = htmlstr+line</span><br><span class="line">        line = f.readline()</span><br><span class="line">    <span class="keyword">return</span> htmlstr</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(get_des_psswd(<span class="string">'123456'</span>, <span class="string">'RUY2OTdCRUFFRTg0OUQ0Q0E0ODNDRDMxN0YzOEEzREQudG9tY2F0OTQ='</span>))</span><br></pre></td></tr></table></figure><p>js2py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> js2py</span><br><span class="line">context = js2py.EvalJs()</span><br><span class="line"><span class="comment">#     - 拷贝使用到js文件的内容到本项目中</span></span><br><span class="line"><span class="comment">#     - 读取js文件的内容,使用context来执行它们</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"BigInt.js"</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    context.execute(f.read())</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"RSA.js"</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    context.execute(f.read())</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"Barrett.js"</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    context.execute(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># - 向context环境中添加需要数据</span></span><br><span class="line">context.t = &#123;<span class="string">'password'</span>: password&#125;</span><br><span class="line">context.n = n</span><br><span class="line"><span class="comment">#     - 执行加密密码的js字符</span></span><br><span class="line">js = <span class="string">'''</span></span><br><span class="line"><span class="string">       t.password = t.password.split("").reverse().join(""),</span></span><br><span class="line"><span class="string">       setMaxDigits(130);</span></span><br><span class="line"><span class="string">       var o = new RSAKeyPair(n.e,"",n.n)</span></span><br><span class="line"><span class="string">        , r = encryptedString(o, t.password);</span></span><br><span class="line"><span class="string">      '''</span></span><br><span class="line">context.execute(js)</span><br><span class="line"><span class="comment"># - 通过context获取加密后密码信息</span></span><br><span class="line"><span class="comment"># print(context.r)</span></span><br><span class="line">password = context.r</span><br><span class="line"><span class="comment">#   - 使用session发送登录请求</span></span><br><span class="line"><span class="comment">#     - URL: http://activity.renren.com/livecell/ajax/clog</span></span><br><span class="line"><span class="comment">#     - 请求方法: POST</span></span><br><span class="line"><span class="comment">#     - 数据:</span></span><br><span class="line"><span class="comment">#       - phoneNum: 15565280933</span></span><br><span class="line"><span class="comment">#       - password: (加密后生产的)</span></span><br><span class="line"><span class="comment">#       - c1: 0</span></span><br><span class="line"><span class="comment">#       - rKey: rkey请求获取的</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'phoneNum'</span>: <span class="string">'131....'</span>,</span><br><span class="line">    <span class="string">'password'</span>: password,</span><br><span class="line">    <span class="string">'c1'</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">'rKey'</span>:n[<span class="string">'rkey'</span>]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># print(session.headers)</span></span><br><span class="line">response = session.post(<span class="string">"http://activity.renren.com/livecell/ajax/clog"</span>, data=data)</span><br><span class="line">print(response.content.decode())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 访问登录的资源</span></span><br><span class="line">response = session.get(<span class="string">"http://activity.renren.com/home#profile"</span>)</span><br><span class="line">print(response.content.decode())</span><br><span class="line"><span class="comment"># https://blog.csdn.net/guodejie/article/details/81436556</span></span><br></pre></td></tr></table></figure><p>逐步确定JS对密码的加密逻辑 ==&gt; 定位到加密函数</p><p>两种思路</p><ul><li><p>全局搜索password字段</p></li><li><p>全局搜加密算法的名字</p><blockquote><p>加密一般都是JS加密，加密算法一般比较出名的就那么几个，比如<code>MD5，base64,aes（对称密码），rsa（非对称加密算法）</code>都是可以用来加密的，你可以全局搜这些加密算法的名字</p></blockquote></li></ul><p><a href="https://www.jianshu.com/p/055e1ddf7bb2" target="_blank" rel="noopener">https://www.jianshu.com/p/055e1ddf7bb2</a></p><h3 id="rsa加密"><a href="#rsa加密" class="headerlink" title="rsa加密"></a>rsa加密</h3><blockquote><p>对极大整数做<a href="https://baike.baidu.com/item/因数分解/5827933" target="_blank" rel="noopener">因数分解</a>的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。<strong>今天只有短的RSA钥匙才可能被强力方式解破</strong>==&gt;为什么密码要大于6位。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python爬虫常规流程&quot;&gt;&lt;a href=&quot;#Python爬虫常规流程&quot; class=&quot;headerlink&quot; title=&quot;Python爬虫常规流程&quot;&gt;&lt;/a&gt;Python爬虫常规流程&lt;/h1&gt;&lt;p&gt;以爬取&lt;strong&gt;有道翻译&lt;/strong&gt;为例子。&lt;/
      
    
    </summary>
    
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Word2016配置使用MathType</title>
    <link href="https://nymrli.top/2019/08/30/Word2016%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8MathType/"/>
    <id>https://nymrli.top/2019/08/30/Word2016配置使用MathType/</id>
    <published>2019-08-30T12:58:53.000Z</published>
    <updated>2019-08-30T13:06:39.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Word-2016-使用MathType"><a href="#Word-2016-使用MathType" class="headerlink" title="Word 2016 使用MathType"></a>Word 2016 使用MathType</h1><p>据说MathType 6.9b后就能与Word 2016兼容了，所以不用特地去找7.0以上的版本，据说更新的功能差别也不是很大。</p><h2 id="闲谈"><a href="#闲谈" class="headerlink" title="闲谈"></a>闲谈</h2><blockquote><p>这边的方法是我个人的操作过程，但是感觉应该不是这么搞得。</p></blockquote><p>安装好MathType后，打开word查看工具栏中是否有MathType工具，如果没有的话，则手动选择“插入-&gt;获得加载项-&gt;应用商店”搜索<strong>Mathtype</strong>。如果还是没有的话，然后在“选项-&gt;加载项-&gt;模板”然后指定MathType Commands 6 For Word2016.dotm的路径，之后是能在应用商城搜到Mathtype了，但是每次打开word都会弹出找不到<code>MathPage.wll</code>，而且最麻烦的是还删不掉这个路径，于是找了很多资料后，发现了“<strong>信任中心</strong>”，比较像能解决问题。只不过试了后还是不行，最后发现，自己拷贝的是64位的文件，找到了一个解决方案提醒到：<em><u>如果你复制的是64的<strong>MathPage.wll</strong>还出错换成32的就好了</u></em>。然后按照提示改了后就行了，同时需要注意的是根据路径显示需要将<strong>Mathtype</strong>安装目录中的和<code>MathPage.wll</code></p><hr><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><blockquote><p>需要将安装好的mathtype目录下提取两个文件MathPage.wll和MathType Commands 6 For Word 2016.dotm复制到指定目录</p></blockquote><p>如果使用的Office是32位的话。在Mathtype安装后，安装路径（假设装在C盘的话）C:\Program Files (x86)\MathType\MathPage\32中有文件<strong>MathPage.wll</strong>；</p><p>安装路径C:\Program Files (x86)\MathType\Office Support\32中有文件 <strong>MathType Commands 6 For Word.dotm</strong>；将这两个文件复制到桌面。</p><p><strong>（当然，这里都是针对Windows 64位系统而言的，注windows10是64位操作系统。如果是Windows 32位系统，路径中就不会包含有（x86）了，请注意。）</strong></p><p>如果使用的Office是64位的话。在Mathtype安装后，安装路径（假设装在C盘的话）C:\Program Files (x86)\MathType\MathPage\64中有文件<strong>MathPage.wll</strong>；</p><p>安装路径C:\Program Files (x86)\MathType\Office Support\64中有文件 <strong>MathType Commands 6 For Word 2016.dotm</strong>；将这两个文件复制到桌面。</p><p>**如果不清楚自己的Office是32位还是64位，就按照32位的来，一般来说，向下兼容，实在不行就都试一试。▲.===&gt;我就是以为自己的是64位结果是32位被坑了很久都用不成。</p><p>或者像如下查看自己的word版本，打开word点击“账号”</p><p><img src="/2019/08/30/Word2016配置使用MathType/word%E7%89%88%E6%9C%AC.png" alt="word版本"></p><p>选择“关于word”</p><p><img src="/2019/08/30/Word2016配置使用MathType/bit.png" alt="bit"></p><p>对于自己安装Office 2016的用户，需要找到Office 2016的安装文件夹（假设装在C盘的话）C:\Program Files\Microsoft Office\Office16\STARTUP（<strong>对于**</strong>64位的Office用户<strong>）；或C:\Program Files (x86)\Microsoft Office\Office16\STARTUP（</strong>对于<strong>**32位的Office用户</strong>）。然后，直接将桌面上的那两个文件剪切放进去即可，重新启动Word后就会出现Mathtype插件栏。</p><p>对于Office预装的用户，想找到Office的安装路径就不那么容易了，这个时候就只能发挥一下Windows自身的搜索功能（安利Everythisng搜索）了，从前面提到的可以看出Mathtype安装文件中有两个文件需要手动移植到Office安装路劲下的一个STARTUP文件夹中，因此需要找到这个STARTUP文件夹。</p><p>在搜索框中输入STARTUP。</p><p>找到最后为<strong>~Microsoft\Word\STARTUP</strong>的文件夹子目录，可能会有多个。逐次添加桌面上的两个文件【如下图】到这些文件夹中，并重新启动Word进行查证。</p><p><strong>需要复制的文件</strong></p><p><img src="/2019/08/30/Word2016配置使用MathType/4.png" alt="4"></p><p><img src="/2019/08/30/Word2016配置使用MathType/3.png" alt="3"></p><p><strong>复制到的位置</strong></p><p>1.STARTUP目录，如果没有的话自己新建<code>C:\Users\10630\AppData\Local\Packages\Microsoft.LanguageExperiencePackzh-cn_8wekyb3d8bbwe\LocalCache\Roaming\Microsoft\Word\STARTUP</code></p><p><img src="/2019/08/30/Word2016配置使用MathType/mathpage.png" alt="mathpage"></p><p>2.这个路径我忘记了，但是搜索的时候发现自己复制了<code>C:\Users\10630\AppData\Roaming\Microsoft\AddIns</code></p><p><img src="/2019/08/30/Word2016配置使用MathType/2.png" alt="2"></p><p><strong>注意事项</strong>：如果在<strong>C:\Program Files\Microsoft Office\Office16\STARTUP中，含有MathType Commands 6 For Word.dot，那么就会出现无法粘贴的现象</strong>。（复制的话，word会关闭）</p><p>:smile:总算安好了把，配合Mathpix，感觉应该挺香的.</p><hr><h2 id="兼容模式问题"><a href="#兼容模式问题" class="headerlink" title="兼容模式问题"></a>兼容模式问题</h2><blockquote><p>当拿到低版本打开后出现一些格式或者兼容性不对的提示，其实很简单，我们可以在保存时候，就可以设置为兼容性模式。</p></blockquote><h3 id="如何关闭”兼容模式”"><a href="#如何关闭”兼容模式”" class="headerlink" title="如何关闭”兼容模式”"></a>如何关闭”兼容模式”</h3><p>当自己使用的Word版本较高，打开doc的版本较低时(<code>.doc</code>)，就会进入<strong>“兼容模式”</strong>，这样能保证大致上的排版格式是正确的，但是图片、公式什么的信息很有可能就会丢失（公式变成了图片、图片显示不全），解决的方案是关闭兼容模式。</p><p>兼容模式，如图</p><p><img src="/2019/08/30/Word2016配置使用MathType/jr.png" alt="兼容模式"></p><h4 id="解决步骤1："><a href="#解决步骤1：" class="headerlink" title="解决步骤1："></a>解决步骤1：</h4><p><img src="/2019/08/30/Word2016配置使用MathType/jr1.png" alt="1"></p><h4 id="解决步骤2："><a href="#解决步骤2：" class="headerlink" title="解决步骤2："></a>解决步骤2：</h4><p><img src="/2019/08/30/Word2016配置使用MathType/jr2.png" alt="2"></p><h3 id="如何保存为”兼容模式“？"><a href="#如何保存为”兼容模式“？" class="headerlink" title="如何保存为”兼容模式“？"></a>如何保存为”<strong>兼容模式</strong>“？</h3><p>实质上就是保存为<code>.doc</code>–&gt;<code>.docx</code>的变化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Word-2016-使用MathType&quot;&gt;&lt;a href=&quot;#Word-2016-使用MathType&quot; class=&quot;headerlink&quot; title=&quot;Word 2016 使用MathType&quot;&gt;&lt;/a&gt;Word 2016 使用MathType&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="生活福利" scheme="https://nymrli.top/tags/%E7%94%9F%E6%B4%BB%E7%A6%8F%E5%88%A9/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析C_概念点区分</title>
    <link href="https://nymrli.top/2019/08/22/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90C-%E6%A6%82%E5%BF%B5%E7%82%B9%E5%8C%BA%E5%88%86/"/>
    <id>https://nymrli.top/2019/08/22/算法设计与分析C-概念点区分/</id>
    <published>2019-08-22T12:39:29.000Z</published>
    <updated>2019-08-22T12:40:14.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法设计与分析C"><a href="#算法设计与分析C" class="headerlink" title="算法设计与分析C"></a>算法设计与分析C</h1><h2 id="算法5-分治法"><a href="#算法5-分治法" class="headerlink" title="算法5_分治法"></a>算法5_分治法</h2><p>分治法——将一个复杂的问题分解成若干个规模较小、相互独立，但类型相同的子问题求解；然后再将各子问题的解组合成原始问题的一个完整答案，这样的问题求解策略就叫分治法。</p><p> 分治法所能解决的问题一般具有以下几个特征：<br>该问题的规模缩小到一定的程度就可以容易地解决；<br>该问题可以分解为若干个规模较小的相同问题；<br>利用该问题分解出的子问题的解可以合并为该问题的解；<br>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p><p>反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。<br>由分治法产生的子问题往往是原问题的较小模式。<br>直接或间接地调用自身的算法称为：递归算法。用函数自身给出定义的函数称为：递归函数。<br>分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p><h2 id="算法6-贪心法"><a href="#算法6-贪心法" class="headerlink" title="算法6_贪心法"></a>算法6_贪心法</h2><ul><li>可行解<pre><code>——问题给定某些约束条件，满足约束条件的问题解，即称为可行解。</code></pre></li><li>最优解<pre><code>——问题给出目标函数衡量可行解的好坏，使目标函数取最大（或最小）值的可行解称为最优解。</code></pre></li></ul><p><strong>1.最优子结构性质：</strong></p><p>一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。<br>问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。 </p><p>2.<strong>贪心选择性质</strong></p><p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。<br>这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</p><h2 id="算法7-动态规划法"><a href="#算法7-动态规划法" class="headerlink" title="算法7_动态规划法"></a>算法7_动态规划法</h2><p>（1）<strong>子问题重叠性质</strong><br>    （递归算法求解问题时）每次产生的子问题并不总是新问题，有些子问题被反复计算多次，这种性质称为子问题重叠性质。</p><p>动态规划算法对每一个子问题只解一次，而后将其解保存在一个表格（通常用二维数组）中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。<br>通常不同的子问题个数随问题的大小呈多项式增长。因此用动态规划算法只需要多项式级时间，从而获得较高的解题效率。</p><p>（2）<strong>最优子结构性质</strong>——用动态规划法求解的前提。<br>    当一个问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</p><p>一个问题的活动过程可以分为若干个阶段，每个阶段可包含一个或多个状态，从初始阶段的初始状态出发做出每个阶段的决策，形成一个决策序列。<br>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。</p><h3 id="用动态规划算法求解问题的步骤："><a href="#用动态规划算法求解问题的步骤：" class="headerlink" title="用动态规划算法求解问题的步骤："></a>用动态规划算法求解问题的步骤：</h3><blockquote><p>1、找出最优解的性质，并刻划其结构特征；</p><p>2、递归地定义最优解值；</p><p>3、自底向上求最优解值；</p><p>4、根据计算最优解值时得到的信息构造一个最优解（此步只在要求得到最优解时才需要做） 。</p></blockquote><p>动态规划法是一种求解最优化问题的重要算法策略。</p><p>利用最优子结构性质及所获得的递推关系式（较小子问题最优解与较大子问题最优解之间存在的数值关系）去求取最优解，可以使计算量较之穷举法急剧减少。</p><blockquote><p>共同点：<br>将待求解的问题分解成若干子问题，先求解子问题，然后再从这些子问题的解得到原问题的解。<br>不同点：<br>1、适合于用动态规划法求解的问题，分解得到的各子问题往往不是相互独立的；而分治法中子问题相互独立。</p><p>2、动态规划法用表保存已求解过的子问题的解，再次碰到同样的子问题时不必重新求解，而只需查询答案，故可获得多项式级时间复杂度，效率较高；而分治法中对于每次出现的子问题均求解，导致同样的子问题被反复求解，故产生指数增长的时间复杂度，效率较低。</p></blockquote><h3 id="备忘录方法与动态规划法比较"><a href="#备忘录方法与动态规划法比较" class="headerlink" title="备忘录方法与动态规划法比较"></a>备忘录方法与动态规划法比较</h3><blockquote><p>1、与动态规划法的共同点：用一个表格来保存已求解的子问题的答案，使下次需要解此子问题时，只简单地查看答案，不重新计算。</p><p>2、与动态规划法的区别：备忘录的递归方式是自顶向下，而动态规划法的递归方式是自底向上。</p></blockquote><h3 id="如何选择使用动态规划法或备忘录法？"><a href="#如何选择使用动态规划法或备忘录法？" class="headerlink" title="如何选择使用动态规划法或备忘录法？"></a><strong>如何选择使用动态规划法或备忘录法？</strong></h3><blockquote><p>★当一个问题的所有子问题都至少要解一次时，选用动态规划法较好，此时没有任何多余的计算，还可利用规则的表格存取方式，减少时间和空间需求。</p><p>★当一个问题只有部分子问题需要求解时，选用备忘录法较好，它只解那些确实需要求解的子问题。</p></blockquote><h3 id="备忘录方法与递归方法比较"><a href="#备忘录方法与递归方法比较" class="headerlink" title="备忘录方法与递归方法比较"></a>备忘录方法与递归方法比较</h3><blockquote><p>1、与递归方法的共同点：递归方式均为自顶向下</p><p>2、与递归方法的区别：备忘录方法用一个表格来保存已求解的子问题的答案，使下次需要解此子问题时，只简单地查看答案，不重新计算；而递归方法在每次遇到子问题都要重新计算。</p></blockquote><blockquote><p><strong>共同点：</strong><br> 都是求解最优化问题；都具有最优子结构性质。<br><strong>不同点：</strong><br>1、求解方式不同：<br> 动态规划法：自底向上；<br> 贪心法：自顶向下。以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为一个规模更小的子问题。</p><p>2、对子问题的依赖不同：<br> 动态规划法：依赖于各子问题的解。只有在解出相关子问题后,才能作出选择；应使各子问题最优，才能保证整体最优；<br> 贪心法：不依赖于子问题的解。仅在当前状态下作出最好选择，即局部最优选择。        </p></blockquote><h2 id="算法8-回溯法"><a href="#算法8-回溯法" class="headerlink" title="算法8_回溯法"></a>算法8_回溯法</h2><p>回溯法是比贪心法和动态规划法更一般的方法。<br>解为n-元组(x0,x1,…,xn-1)形式。<br>通过搜索状态空间树来求问题的可行解（满足约束条件）或最优解（使目标函数取最大或最小值）。<br>使用约束函数和限界函数来压缩需要实际生成的状态空间树的结点数。<br>通常情况下，回溯法是为了找出满足约束条件的所有可行解。</p><ul><li>显式约束：规定每个xi取值的约束条件。<br>（显式约束规定了问题的候选解集——解空间）</li><li>隐式约束：给出了判定一个候选解是否为可行解的条件。为满足问题的解而对不同分量之间施加的约束。</li><li>目标函数（代价函数）：衡量每个可行解的优劣，使目标函数取最大（或最小）值的可行解为问题的最优解。<br>状态空间树：描述问题解空间的树形结构。</li></ul><p>树中每个结点称为一个问题状态；<br>若从根到树中某个状态的路径代表一个候选解元组，则该状态为解状态；<br>若从根到某个解状态的路径代表一个可行解元组，则该解状态为答案状态；<br>如果求解的是最优化问题，还要用目标函数衡量每个答案结点，找出其中目标函数取最优值的最优答案结点。</p><blockquote><p>回溯法与穷举搜索不同：回溯法使用约束函数，剪去那些可以断定不含答案状态的子树，从而提高算法效率。回溯法适用于解一些组合数相当大的问题。<br>事实上，状态空间树并不需要事先生成，而只需在求解的过程中，随着搜索算法的进展，逐个生成状态空间树的问题状态结点。</p></blockquote><p>常用的剪枝函数：<br>用约束函数剪去已知不含答案状态（可行解）的子树；<br>用限界函数剪去得不到最优答案结点（最优解）的子树。</p><h3 id="蒙特卡洛估计"><a href="#蒙特卡洛估计" class="headerlink" title="蒙特卡洛估计"></a>蒙特卡洛估计</h3><p>用蒙特卡罗（Monte Carlo）方法估计回溯法处理实例时，实际生成的结点数：</p><p>在状态空间树中,从根开始随机选择一条路径(x0,x1,…,xn-1);<br>假定搜索树中这条随机选出的路径上，代表部分向量(x0,x1,…,xk-1)的结点X处不受限制的孩子数目,和其他路径上与X同层的的结点不受限制的孩子数目一样，都是mk;<br>则可以估计整个状态空间树上实际生成的结点数为: <code>m=1+m0+m0m1+m0m1m2+......</code></p><h2 id="算法9-分枝限界法"><a href="#算法9-分枝限界法" class="headerlink" title="算法9_分枝限界法"></a>算法9_分枝限界法</h2><p>采用广度优先产生状态空间树的结点，并使用剪枝函数的方法称为——分枝限界法。<br>分枝限界法的基本做法是：<br>    以<strong>广度优先</strong>的方式搜索问题的状态空间树。每一个活结点只有一次机会成为扩展结点。<br>    按照广度优先的原则，活结点一旦成为扩展结点（E结点）R后，就依次生成它的所有孩子结点。在这些孩子结点中，导致不可行解或导致非最优解的孩子结点被舍弃，其余孩子结点被一一加入活结点表中。<br>    此后，R自身成为死结点，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。<br>    这个过程一直持续到找到所需的解或活结点表为空时为止。 </p><blockquote><p>一、<strong>分枝限界法与回溯法的共同点</strong><br> 都是在问题的状态空间树上搜索问题解的算法,都通过活结点表实现。都用约束函数剪去不含答案结点的分枝,用限界函数剪去不含最优解的分枝.<br>二、<strong>分枝限界法与回溯法的区别</strong><br>（1）求解目标不同：回溯法的求解目标是找出解空间树中满足约束条件的所有可行解；而分枝限界法的求解目标则是找出满足约束条件的一个可行解，或某种意义下的最优解。</p><p>（2）搜索方式不同：回溯法以深度优先的方式搜索解空间树，而分枝限界法则以广度优先的方式搜索解空间树。</p><p>（3）对当前扩展结点的扩展方式不同：回溯法中的每个活结点可能多次成为当前扩展结点，纵深方向扩展其一个儿子，然后再回溯后扩展其他儿子；而分枝限界法中每一个活结点只有一次机会成为扩展结点，一次产生所有孩子结点，自身成为死结点，之后无需再返回该结点处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法设计与分析C&quot;&gt;&lt;a href=&quot;#算法设计与分析C&quot; class=&quot;headerlink&quot; title=&quot;算法设计与分析C&quot;&gt;&lt;/a&gt;算法设计与分析C&lt;/h1&gt;&lt;h2 id=&quot;算法5-分治法&quot;&gt;&lt;a href=&quot;#算法5-分治法&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://nymrli.top/tags/ACM/"/>
    
      <category term="NJUPT" scheme="https://nymrli.top/tags/NJUPT/"/>
    
      <category term="学业" scheme="https://nymrli.top/tags/%E5%AD%A6%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>通信企业管理_线上考试</title>
    <link href="https://nymrli.top/2019/08/22/%E9%80%9A%E4%BF%A1%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86-%E7%BA%BF%E4%B8%8A%E8%80%83%E8%AF%95/"/>
    <id>https://nymrli.top/2019/08/22/通信企业管理-线上考试/</id>
    <published>2019-08-22T12:37:49.000Z</published>
    <updated>2019-08-30T13:32:04.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通信企业管理"><a href="#通信企业管理" class="headerlink" title="通信企业管理"></a>通信企业管理</h1><blockquote><p>看清题目和选项</p></blockquote><h3 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h3><p>1单选(2分)</p><p>在总公司领导下设立多个分支，各分支有各自独立的产品和市场，实行独立核算，经营管理上拥有自主性和独立性。这是（ A   ）组织结构。</p><ul><li>A.事业部型</li><li>B.矩阵型</li><li>C.职能型</li><li>D.直线型</li></ul><p>2单选(2分)</p><p>按照最新版《中华人民共和国公司法》规定，股份有限公司的发起人最多不超过（    C ）。</p><ul><li>A.100人</li><li>B.50人</li><li>C.200人</li><li>D.150人</li></ul><p>3单选(2分)</p><p>工作或行动之前预先拟定具体的工作内容和步骤是管理的（  D  ）职能。</p><ul><li>A.组织职能</li><li>B.控制职能</li><li>C.领导职能</li><li>D.计划职能</li></ul><p>4单选(2分)</p><p>提出“14项管理原则”的是（C  ）。</p><ul><li>A.巴纳德</li><li>B.梅奥</li><li>C.法约尔</li><li>D.泰勒</li></ul><p>5单选(2分)</p><p>企业战略是关于企业在激烈的竞争中如何与竞争对手相抗衡、同时也是针对来自多方面的冲击、压力、威胁和困难迎击这些挑战的行动方案。这体现了企业战略的（  D  ）。</p><ul><li>A.长远性</li><li>B.协同性</li><li>C.全局性</li><li>D.抗争性</li></ul><p>6单选(2分)</p><p>在对企业总体环境分析中，人们生活方式的变化属于（ B   ）。</p><ul><li>A.经济环境</li><li>B.社会环境</li><li>C.政治环境</li><li>D.技术环境</li></ul><p>7单选(2分)</p><p>为了增强企业实力而与同行业企业进行联合的一种战略称为（ C   ）。</p><ul><li>A.复合多样化</li><li>B.纵向一体化</li><li>C.横向一体化</li><li>D.同心多样化</li></ul><p>8单选(2分)</p><p>在流程型生产过程中，物料是均匀、连续地按一定工艺顺序运动的。它的特点是工艺过程的（ A   ）。</p><ul><li>A.连续性</li><li>B.稳定性</li><li>C.离散性</li><li>D.流动性</li></ul><p>9单选(2分)</p><p>服务是一种活动，在消费之前通常无法为顾客感觉、体验和评价，这体现了服务的（  B   ）。</p><ul><li>A.劳动力密集性</li><li>B.无形性</li><li>C.异质性</li><li>D.易逝性</li></ul><p>10单选(2分)</p><p>尽管不同产品具有不同的外部质量特征，但可以用（ B ）来概括产品质量。</p><ul><li>A.安全性</li><li>B.适用性</li><li>C.经济性</li><li>D.可靠性</li></ul><p>11单选(2分)</p><p>质量管理经历的第四阶段是（  C   ）。</p><ul><li>A.统计质量控制阶段</li><li>B.质量检验阶段 </li><li>C. ISO9000质量管理体系认证阶段</li><li>D.全面质量管理阶段</li></ul><p>12单选(2分)</p><p>下面（ A   ）不是朱兰三部曲中所要求的内容。</p><ul><li>A.质量检验</li><li>B.质量计划</li><li>C.质量提高</li><li>D.质量控制</li></ul><p>13单选(2分)</p><p>职业生涯规划属于 人力资源管理的（ C  ）方面的内容。</p><ul><li>A.用人</li><li>B.进人</li><li>C.育人</li><li>D.留人</li></ul><p>14单选(2分)</p><p>一般来说，我们可以从工作业绩、工作能力和工作态度3个方面来评价员工的绩效体现了绩效的（  C   ）特征。</p><ul><li>A.动态性</li><li>B.多因性</li><li>C.多维性</li><li>D.稳定性</li></ul><p>15单选(2分)</p><p>薪酬中属于间接经济性报酬的是（ D  ）。</p><ul><li>A.津贴</li><li>B.基本工资</li><li>C.奖金</li><li>D.基本社会保险</li></ul><p>16单选(2分)</p><p>企业财务管理的基本内容包括：①资金筹集管理；②成本费用管理；③投资管理；④利润（收支差额）及其分配管理；⑤物资管理；中的（ A   ）。</p><p>A.①②③④<br>B.①③④⑤<br>C.①②④⑤<br>D.①②③④⑤</p><p>17单选(2分)</p><p>以下不属于企业的筹资方式的是（ D   ）。</p><ul><li>A.买方信贷</li><li>B.发行股票</li><li>C.银行贷款</li><li>D.来自个人的闲散资金</li></ul><p>18单选(2分)</p><p>某大学生在4年学习期间，每年年初从银行贷款3000元用于支付学费，若按年利率5%计复利，第4年末需要一次性归还全部本息（  D  ）元。</p><ul><li>A.12000</li><li>B.12930.4</li><li>C.16576.9</li><li>D.13576.9</li></ul><p>19单选(2分)</p><p>为了保证产品达到规定的功能和技术要求所必需的材料消耗是（A   ）。</p><ul><li>A.有效性消耗</li><li>B.工艺性消耗</li><li>C.非工艺性消耗</li><li>D.材料消耗</li></ul><p>20单选(2分)</p><p>设备在使用或闲置过程中，由于新技术出现而引起的设备价值损失，称为（ A  ）。</p><ul><li>A.无形磨损</li><li>B.价值磨损</li><li>C.技术磨损</li><li>D.使用磨损</li></ul><p>21单选(2分)</p><p>企业在相邻两批物资进厂间隔期内，为保证生产正常进行所必需的、经济合理的储备数量是（ D  ）。</p><ul><li>A.保险储备定额</li><li>B.物资储备定额</li><li>C.季节性储备定额</li><li>D.经常储备定额</li></ul><p>22单选(2分)</p><p>快速渗透策略是推广处于生命周期（C   ）产品的企业，可以采用的市场营销策略。</p><ul><li>A.衰退期</li><li>B.成长期</li><li>C.引入期</li><li>D.成熟期</li></ul><p>23单选(2分)</p><p>以下不属于促销组合中的促销工具的是（ D ）。</p><ul><li>A.销售促进</li><li>B.公关宣传</li><li>C.广告</li><li>D.尾数定价</li></ul><p>24单选(2分)</p><p>营销人员可以通过接近和影响消费者群体中的意见领袖的方式来开展营销活动，这体现了影响消费者购买的主要因素中的（ D  ）的作用。</p><ul><li>A.经济因素</li><li>B.个人因素</li><li>C.社会文化因素</li><li>D.心理因素</li></ul><p>25单选(2分)</p><p>品种繁多，每种仅生产一件，生产重复程度低是以下哪种生产方式的特点（ B ）。</p><ul><li>A.批量生产</li><li>B.单件生产</li><li>C.大量生产</li><li>D.备货型生产</li></ul><h3 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h3><p>26判断(2分)<br>个体企业是个人出资兴办的企业，具有法人资格。</p><ul><li>错</li></ul><p>27判断(2分)<br>在管理过程中，只有把人的要素作为根本，才能协调好其他要素，实现高水平的管理。</p><ul><li>对</li></ul><p>28判断(2分)<br>企业不仅是经济性组织，也是社会性组织。</p><ul><li>对</li></ul><p>29判断(2分)<br>梅奥认为，影响人们积极性的因素除了物质方面外，还有社会与心理方面。</p><ul><li>对</li></ul><p>30判断(2分)<br>企业提供的产品服务标新立异，满足顾客特殊的需求，形成竞争优势的战略是差异化战略。</p><ul><li>对</li></ul><p>31判断(2分)<br>高质量的社会物流系统属于战略制定中企业的外部资源。</p><ul><li>对</li></ul><p>32判断(2分)<br>企业价值活动中，技术开发属于基本活动。</p><ul><li>错</li></ul><p>33判断(2分)<br>企业生产系统是由输入、转化、输出、反馈四部分构成，其核心是输出。</p><ul><li>错</li></ul><p>34判断(2分)<br>辅助生产部门主要是为基本生产和辅助生产服务的单位（如仓储、后勤）。</p><ul><li>错</li></ul><p>35判断(2分)<br>对于顾客来说，服务是发生在服务设施环境中的经历，如果服务设施的设计符合消费者的需要，就可以提高服务质量。</p><ul><li>对</li></ul><p>36判断(2分)<br>ISO9000族标准是进行国际贸易时强制要求必须进行的标准认证。</p><ul><li>错</li></ul><p>37判断(2分)<br>质量体系认证中使用的基本标准是产品技术标准。</p><ul><li>错</li></ul><p>38判断(2分)<br>质量管理的目标就是提高产品质量，产品质量越高越好。</p><ul><li>错</li></ul><p>39判断(2分)<br>广义的人力资源概念是指能够推动国民经济和社会发展的具有智力劳动和体力劳动能力的人的总和，包括数量和质量两个方面。</p><ul><li>错</li></ul><p>40判断(2分)<br>工作说明书具体说明了工作的目的与任务、工作内容与特征、工作责任与权力、工作标准与要求、工作时间与地点等问题。</p><ul><li>错</li></ul><p>41判断(2分)<br>设定绩效目标时，管理者一般根据组织总体目标或上级部门的目标，围绕本部门业务重点或职责，制定本部门的工作目标计划，保证部门工作目标与组织的总体目标相一致。</p><ul><li>对</li></ul><p>42判断(2分)<br>企业的运营能力反映了企业资金周转状况，可以用成本费用净利率来衡量。</p><ul><li>错</li></ul><p>43判断(2分)<br>资本公积、盈余公积都属于企业权益资本的范畴。</p><ul><li>对</li></ul><p>44判断(2分)<br>盈亏平衡点是指技术方案的盈利和亏损在产量、单价、成本等方面的临界值。</p><ul><li>对</li></ul><p>45判断(2分)<br>在设备的自然寿命周期中，设备故障率随着使用的时间的延伸而越来越高。</p><ul><li>对</li></ul><p>46判断(2分)<br>设备更新改造时，不仅要考虑设备的自然寿命，还要考察技术寿命和经济寿命。</p><ul><li>对</li></ul><p>47判断(2分)<br>从价值形态上看，无论是有形磨损还是无形磨损都会引起设备价值的降低，因此我们要采取措施尽量减少各种类型的设备磨损。</p><ul><li>错</li></ul><p>48判断(2分)<br>关系营销就是利用亲属关系以及朋友关系来开展营销活动。</p><ul><li>错</li></ul><p>49判断(2分)<br>在目标市场中采用无差异的市场营销策略历来都不是一种明智的选择。</p><ul><li>错</li></ul><p>50判断(2分)<br>招徕定价是一种利用顾客心理因素来进行定价的策略。</p><ul><li>对</li></ul><h2 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h2><blockquote><p> 记个正则替换，本是强哥每题copy到word里的，后来通过正则规范了下格式</p></blockquote><p>复制结果：</p><blockquote><p>\1. int[][] a=new int[2][3]，则该数组包含（ ）个数组元素。</p><p>A.2</p><p>B.3</p><p>C.6</p><p>D.不确定</p><p>正确答案是: C</p><p>\2. 已知类person是类student的父类，以下数组定义和赋值正确的是( )。</p><p>A.person p[]=new person[3]; p[1]=new student();</p><p>B.student s[]=new person[3]; s[1]=new person();</p><p>C.person p[]= new student[3];p[1]= new person();</p><p>D.student s[]=new student[3];s[1]=new person;</p><p>正确答案是: A</p></blockquote><p> 查找<code>(\d.)</code>替换为<code>\n - \1</code></p><p>效果如下:</p><ul><li><ol><li>int[][] a=new int[2][3]，则该数组包含（ ）个数组元素。<br>A.2<br>B.3<br>C.6<br>D.不确定<br>正确答案是: C</li></ol></li><li><ol start="2"><li>已知类person是类student的父类，以下数组定义和赋值正确的是( )。<br>A.person p[]=new person[3]; p[1]=new student();<br>B.student s[]=new person[3]; s[1]=new person();<br>C.person p[]= new student[3];p[1]= new person();<br>D.student s[]=new student[3];s[1]=new person;<br>正确答案是: A</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通信企业管理&quot;&gt;&lt;a href=&quot;#通信企业管理&quot; class=&quot;headerlink&quot; title=&quot;通信企业管理&quot;&gt;&lt;/a&gt;通信企业管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;看清题目和选项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单选题&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="NJUPT" scheme="https://nymrli.top/tags/NJUPT/"/>
    
      <category term="学业" scheme="https://nymrli.top/tags/%E5%AD%A6%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s Encrypt安装配置nginx的SSL证书教程</title>
    <link href="https://nymrli.top/2019/08/22/Let-s-Encrypt%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6%E6%95%99%E7%A8%8B/"/>
    <id>https://nymrli.top/2019/08/22/Let-s-Encrypt安装配置SSL证书教程/</id>
    <published>2019-08-22T12:34:04.000Z</published>
    <updated>2019-08-22T12:36:34.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Let’s-Encrypt-安装配置nginx的SSL证书教程"><a href="#Let’s-Encrypt-安装配置nginx的SSL证书教程" class="headerlink" title="Let’s Encrypt 安装配置nginx的SSL证书教程"></a>Let’s Encrypt 安装配置nginx的SSL证书教程</h1><h2 id="使用cerbot生成证书"><a href="#使用cerbot生成证书" class="headerlink" title="使用cerbot生成证书)"></a><a href="[https://nymrli.top/2018/12/08/%E4%BD%BF%E7%94%A8Cerbot%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6%E5%8D%87%E7%BA%A7-http%E5%88%B0https/](https://nymrli.top/2018/12/08/使用Cerbot申请免费证书升级-http到https/">使用cerbot生成证书</a>)</h2><h3 id="安装Let’s-Encrypt"><a href="#安装Let’s-Encrypt" class="headerlink" title="安装Let’s Encrypt"></a>安装<a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a></h3><p>安装非常简单直接克隆就可以了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/letsencrypt/letsencrypt</span><br></pre></td></tr></table></figure></p><p>如果网速较慢（国外服务器应该快点）</p><p>1.可以登录<a href="https://github.com/letsencrypt/letsencrypt，下载后通过lrzsz传到云服务器上，再解压" target="_blank" rel="noopener">https://github.com/letsencrypt/letsencrypt，下载后通过lrzsz传到云服务器上，再解压</a></p><p>2.修改hosts</p><p><strong>查找域名对应的ip地址，并修改hosts文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">linuxidc@linuxidc:~/linuxidc.com$ nslookup github.global.ssl.fastly.Net</span><br><span class="line">Server:  127.0.0.53</span><br><span class="line">Address: 127.0.0.53<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name: github.global.ssl.fastly.Net</span><br><span class="line">Address: 151.101.229.194</span><br><span class="line"></span><br><span class="line">linuxidc@linuxidc:~/linuxidc.com$ nslookup github.com</span><br><span class="line">Server:  127.0.0.53</span><br><span class="line">Address: 127.0.0.53<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name: github.com</span><br><span class="line">Address: 13.229.188.59</span><br></pre></td></tr></table></figure><p><strong>然后修改hosts文件</strong></p><p><code>sudo vim /etc/hosts</code></p><p><strong>在hosts文件末尾添加两行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github.com 13.229.188.59</span><br><span class="line">github.global.ssl.fastly.Net 151.101.229.194</span><br></pre></td></tr></table></figure><p><strong>刷新DNS缓存</strong></p><p><code>sudo /etc/init.d/networking restart</code></p><h3 id="使用cerbot"><a href="#使用cerbot" class="headerlink" title="使用cerbot:"></a>使用cerbot:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> letsencrypt</span><br><span class="line"><span class="comment"># 根据自己的需求调整代码</span></span><br><span class="line">./certbot-auto certonly --standalone --email admin@example.com -d example.c</span><br></pre></td></tr></table></figure><p><strong>成功提示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IMPORTANT NOTES:</span><br><span class="line">Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/sast.nymrli.top/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/sast.nymrli.top/privkey.pem</span><br><span class="line">   Your cert will expire on 2019-02-08. To obtain a new or tweaked</span><br><span class="line">   version of this certificate in the future, simply run certbot-auto</span><br><span class="line">   again. To non-interactively renew *all* of your certificates, run</span><br><span class="line">   &quot;certbot-auto renew&quot;</span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br></pre></td></tr></table></figure><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx:"></a>配置<em>Nginx</em>:</h3><p>server 不再监听80端口，因为TLS要使用的是443端口，然后引入证书和key</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line"><span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line"><span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">75M</span>;</span><br><span class="line">    <span class="attribute">location</span> /static&#123;</span><br><span class="line">    <span class="attribute">alias</span> /home/mrli/Python_project/QQoauth_remote/static;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"><span class="attribute">include</span> uwsgi_params;</span><br><span class="line"><span class="attribute">uwsgi_pass</span> <span class="number">127.0.0.1:81</span>;</span><br><span class="line"><span class="attribute">uwsgi_param</span> UWSGI_SCRIPT app:app;   <span class="comment"># 启动flask的文件:Flask的实例</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">ssl_certificate</span>   /etc/letsencrypt/live/test.nymrli.top/fullchain.pem; </span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/test.nymrli.top/privkey.pem;   </span><br><span class="line">    <span class="comment">#前面生成的证书，改一下里面的域名就行，不建议更换路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重启Nginx："><a href="#重启Nginx：" class="headerlink" title="重启Nginx："></a>重启<em>Nginx</em>：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure><h2 id="使用acme-sh"><a href="#使用acme-sh" class="headerlink" title="使用acme.sh"></a>使用acme.sh</h2><h3 id="下载acme"><a href="#下载acme" class="headerlink" title="下载acme"></a>下载<strong>acme</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Neilpang/acme.sh.git</span><br><span class="line"><span class="built_in">cd</span> acme.sh</span><br><span class="line">./acme.sh --install</span><br></pre></td></tr></table></figure><p><strong>提示信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Thu Aug 22 19:58:00 CST 2019] It is recommended to install socat first.</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] We use socat for standalone server if you use standalone mode.</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] If you don&apos;t use standalone mode, just ignore this warning.</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] Installing to /home/mrli/.acme.sh</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] Installed to /home/mrli/.acme.sh/acme.sh</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] Installing alias to &apos;/home/mrli/.bashrc&apos;</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] OK, Close and reopen your terminal to start using acme.sh</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] Installing cron job</span><br><span class="line">1 0 * * * &quot;/home/mrli/.acme.sh&quot;/acme.sh --cron --home &quot;/home/mrli/.acme.sh&quot; &gt; /dev/null</span><br><span class="line">[Thu Aug 22 19:58:00 CST 2019] Good, bash is found, so change the shebang to use bash as preferred.</span><br><span class="line">[Thu Aug 22 19:58:01 CST 2019] OK</span><br></pre></td></tr></table></figure><h3 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a><strong>生成证书</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> Ali_Key=<span class="string">"xxxx"</span></span><br><span class="line"><span class="built_in">export</span> Ali_Secret=<span class="string">"yyyy"</span></span><br><span class="line">acme.sh --issue --dns dns_ali -d nymrli.top -d *.nymrli.top</span><br></pre></td></tr></table></figure><p>注：这边的Key和secret需要找到你的阿里云API密钥，<a href="https://usercenter.console.aliyun.com/#/manage/ak" target="_blank" rel="noopener">Acesskey</a></p><p><img src="/2019/08/22/Let-s-Encrypt安装配置SSL证书教程/Users\10630\Documents\Let&#39;s Encrypt 安装配置 SSL 证书教程\accesskeys.png" alt="accesskeys"></p><p><strong>输出信息**</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[Thu Aug 22 20:01:53 CST 2019] Create account key ok.</span><br><span class="line">[Thu Aug 22 20:01:53 CST 2019] Registering account</span><br><span class="line">[Thu Aug 22 20:01:55 CST 2019] Registered</span><br><span class="line">[Thu Aug 22 20:01:55 CST 2019] ACCOUNT_THUMBPRINT=<span class="string">'YljrV0ThIsQxXtfdxksrd91g1fWvM9Btn9Dazt8OWyo'</span></span><br><span class="line">[Thu Aug 22 20:01:55 CST 2019] Creating domain key</span><br><span class="line">[Thu Aug 22 20:01:55 CST 2019] The domain key is here: /home/mrli/.acme.sh/nymrli.top/nymrli.top.key</span><br><span class="line">[Thu Aug 22 20:01:55 CST 2019] Multi domain=<span class="string">'DNS:nymrli.top,DNS:*.nymrli.top'</span></span><br><span class="line">[Thu Aug 22 20:01:55 CST 2019] Getting domain auth token <span class="keyword">for</span> each domain</span><br><span class="line">[Thu Aug 22 20:01:56 CST 2019] Getting webroot <span class="keyword">for</span> domain=<span class="string">'nymrli.top'</span></span><br><span class="line">[Thu Aug 22 20:01:56 CST 2019] Getting webroot <span class="keyword">for</span> domain=<span class="string">'*.nymrli.top'</span></span><br><span class="line">[Thu Aug 22 20:01:57 CST 2019] Adding txt value: NyNt2AxJ3OmW8s_wVn2C3CNN9_yT1o_v2o0MhmdUoTs <span class="keyword">for</span> domain:  _acme-challenge.nymrli.top</span><br><span class="line">[Thu Aug 22 20:01:59 CST 2019] The txt record is added: Success.</span><br><span class="line">[Thu Aug 22 20:01:59 CST 2019] Adding txt value: ADqtxSTlQ0DH7jHZzlP9UZB0dT9U2oVYSk_zTabYN3w <span class="keyword">for</span> domain:  _acme-challenge.nymrli.top</span><br><span class="line">[Thu Aug 22 20:02:01 CST 2019] The txt record is added: Success.</span><br><span class="line">[Thu Aug 22 20:02:01 CST 2019] Let<span class="string">'s check each dns records now. Sleep 20 seconds first.</span></span><br><span class="line"><span class="string">[Thu Aug 22 20:02:22 CST 2019] Checking nymrli.top for _acme-challenge.nymrli.top</span></span><br><span class="line"><span class="string">[Thu Aug 22 20:02:24 CST 2019] Domain nymrli.top '</span>_acme-challenge.nymrli.top<span class="string">' success.</span></span><br><span class="line"><span class="string">[Thu Aug 22 20:02:24 CST 2019] Checking nymrli.top for _acme-challenge.nymrli.top</span></span><br><span class="line"><span class="string">[Thu Aug 22 20:02:25 CST 2019] Domain nymrli.top '</span>_acme-challenge.nymrli.top<span class="string">' success.</span></span><br><span class="line"><span class="string">[Thu Aug 22 20:02:25 CST 2019] All success, let'</span>s <span class="built_in">return</span></span><br><span class="line">[Thu Aug 22 20:02:25 CST 2019] Verifying: nymrli.top</span><br><span class="line">[Thu Aug 22 20:02:28 CST 2019] Success</span><br><span class="line">[Thu Aug 22 20:02:28 CST 2019] Verifying: *.nymrli.top</span><br><span class="line">[Thu Aug 22 20:02:31 CST 2019] Success</span><br><span class="line">[Thu Aug 22 20:02:31 CST 2019] Removing DNS records.</span><br><span class="line">[Thu Aug 22 20:02:31 CST 2019] Removing txt: NyNt2AxJ3OmW8s_wVn2C3CNN9_yT1o_v2o0MhmdUoTs <span class="keyword">for</span> domain: _acme-challenge.nymrli.top</span><br><span class="line">[Thu Aug 22 20:02:34 CST 2019] Removed: Success</span><br><span class="line">[Thu Aug 22 20:02:34 CST 2019] Removing txt: ADqtxSTlQ0DH7jHZzlP9UZB0dT9U2oVYSk_zTabYN3w <span class="keyword">for</span> domain: _acme-challenge.nymrli.top</span><br><span class="line">[Thu Aug 22 20:02:38 CST 2019] Removed: Success</span><br><span class="line">[Thu Aug 22 20:02:38 CST 2019] Verify finished, start to sign.</span><br><span class="line">[Thu Aug 22 20:02:38 CST 2019] Lets finalize the order, Le_OrderFinalize: https://acme-v02.api.letsencrypt.org/acme/finalize/64001779/941369076</span><br><span class="line">[Thu Aug 22 20:02:40 CST 2019] Download cert, Le_LinkCert: https://acme-v02.api.letsencrypt.org/acme/cert/034f6880d75703381da6f5efedb159772580</span><br><span class="line">[Thu Aug 22 20:02:40 CST 2019] Cert success.</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">xxxxx</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">[Thu Aug 22 20:02:40 CST 2019] Your cert is <span class="keyword">in</span>  /home/mrli/.acme.sh/nymrli.top/nymrli.top.cer </span><br><span class="line">[Thu Aug 22 20:02:40 CST 2019] Your cert key is <span class="keyword">in</span>  /home/mrli/.acme.sh/nymrli.top/nymrli.top.key </span><br><span class="line">[Thu Aug 22 20:02:40 CST 2019] The intermediate CA cert is <span class="keyword">in</span>  /home/mrli/.acme.sh/nymrli.top/ca.cer </span><br><span class="line">[Thu Aug 22 20:02:40 CST 2019] And the full chain certs is there:  /home/mrli/.acme.sh/nymrli.top/fullchain.cer</span><br></pre></td></tr></table></figure><h3 id="nginx配置文件内容"><a href="#nginx配置文件内容" class="headerlink" title="nginx配置文件内容"></a>nginx配置文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 443 ssl;</span><br><span class="line">server_name 127.0.0.1;</span><br><span class="line">charset utf-8;</span><br><span class="line">client_max_body_size 75M;</span><br><span class="line">    location /static&#123;</span><br><span class="line">    <span class="built_in">alias</span> /home/mrli/Python_project/QQoauth_remote/static;  </span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">include uwsgi_params;</span><br><span class="line">uwsgi_pass 127.0.0.1:81;</span><br><span class="line">uwsgi_param UWSGI_SCRIPT app:app;   <span class="comment"># 启动flask的文件:Flask的实例</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ssl_certificate   /home/mrli/.acme.sh/nymrli.top/fullchain.cer; </span><br><span class="line">    ssl_certificate_key /home/mrli/.acme.sh/nymrli.top/nymrli.top.key;   </span><br><span class="line">    <span class="comment">#前面生成的证书，改一下里面的域名就行，不建议更换路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阿里云免费SSL证书symantec"><a href="#阿里云免费SSL证书symantec" class="headerlink" title="阿里云免费SSL证书symantec"></a>阿里云免费SSL证书symantec</h2><p>从<a href="https://common-buy.aliyun.com/?spm=5176.2020520163.cas.3.4cce56a7AqzpRw&amp;commodityCode=cas#/buy" target="_blank" rel="noopener">云盾证书服务(包年)</a>中选择免费的symantec生成后，按下载，选择nginx证书</p><p><img src="/2019/08/22/Let-s-Encrypt安装配置SSL证书教程/1.png" alt="1"></p><p>文件内容如下</p><p><img src="/2019/08/22/Let-s-Encrypt安装配置SSL证书教程/cer.png" alt="cer"></p><p>我们需要把这两个文件放到我们的服务器中，如果是linux系统，推荐放到<code>/etc/ssl/</code>目录下</p><p>示例：nginx节点配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="comment">#http节点中可以添加多个server节点</span></span><br><span class="line">    server&#123;</span><br><span class="line">        <span class="comment">#监听443端口</span></span><br><span class="line">        listen 443;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">#对应的域名，把test.nymrli.top改成你们自己的域名就可以了</span></span><br><span class="line">        server_name test.nymrli.top;</span><br><span class="line">        ssl on;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">#从腾讯云获取到的第一个文件的全路径</span></span><br><span class="line">        ssl_certificate /etc/ssl/1474527_www.nymrli.top.pem;</span><br><span class="line">        <span class="comment">#从腾讯云获取到的第二个文件的全路径</span></span><br><span class="line">        ssl_certificate_key /etc/ssl/1474527_www.nymrli.top.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#这是我的主页访问地址，因为使用的是静态的html网页，所以直接使用location就可以完成了。</span></span><br><span class="line">        location / &#123;</span><br><span class="line">                <span class="comment">#文件夹</span></span><br><span class="line">                root /usr/<span class="built_in">local</span>/service/ROOT;</span><br><span class="line">                <span class="comment">#主页文件</span></span><br><span class="line">                index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>▲.<code>crt、pem、key</code>都是证书文件</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决:"></a>问题解决:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Problem binding to port 80: Could not bind to IPv4 or IPv6.</span><br></pre></td></tr></table></figure><p>原因是 nginx 占用了80端口，输入<code>service nginx stop</code>。然后再次执行证书安装命令，即可顺利安装。安装完毕后，输入<code>service nginx start</code>，重启 nginx 服务。</p><p>2.重启nginx失败=&gt;conf配置有问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">See &quot;systemctl status nginx.service&quot; and &quot;journalctl -xe&quot; for details.</span><br><span class="line"> failed!</span><br></pre></td></tr></table></figure><p>A:<code>.conf</code>文件的注释是#而不是//</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Let’s-Encrypt-安装配置nginx的SSL证书教程&quot;&gt;&lt;a href=&quot;#Let’s-Encrypt-安装配置nginx的SSL证书教程&quot; class=&quot;headerlink&quot; title=&quot;Let’s Encrypt 安装配置nginx的SSL证书教
      
    
    </summary>
    
    
      <category term="环境部署" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>时间序列概念及主要模型</title>
    <link href="https://nymrli.top/2019/07/29/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9E%8B/"/>
    <id>https://nymrli.top/2019/07/29/时间序列概念及主要模型/</id>
    <published>2019-07-29T11:05:18.000Z</published>
    <updated>2019-07-30T06:29:07.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间序列概念及主要模型"><a href="#时间序列概念及主要模型" class="headerlink" title="时间序列概念及主要模型"></a>时间序列概念及主要模型</h1><p>Q:什么是时间序列分析?<br>A:时间序列是按照时间顺序，按照一定时间间隔取得的一系列观测值<br>Q:怎样做时间序列分析?<br>A:时间序列分析尝试找出序列值在过去呈现的特征模式，假定这种模式在未来能够持续，进而对未来进行预测</p><h2 id="时间序列三大特征"><a href="#时间序列三大特征" class="headerlink" title="时间序列三大特征"></a>时间序列三大特征</h2><ul><li>序列相关性：当期的序列值和前期某个或某些序列值线性相关<br>√  自相关系数（全相关系数）（ACF）：用来度量同一事件在不同时期之间的相关程度。$\rho_{h}=\frac{r(h)}{r(0)}$，其中r（h）为h期协方差函数，r（0）为方差<br>√  偏自相关系数（PACF）：度量去除中间变量影响后的相关程度。$X_{t}$和$X_{t-2}$通过$X_{t-1}$产生关联，PACF即为去除$X_{t- 1}$的关联后两者的相关程度</li><li>趋势性：序列整体上呈现单调性，如平稳，上涨或下跌<ul><li>ARMA模型是平稳的时间序列模型，在建模前必须去除趋势性</li></ul></li><li>随机性：序列在一定程度上呈现不确定性<ul><li>模型并不能够捕捉到现实世界中的所有特征，总有一些噪声的存在，这些噪声叫做白噪声</li></ul></li></ul><h2 id="时间序列模型预测方法："><a href="#时间序列模型预测方法：" class="headerlink" title="时间序列模型预测方法："></a>时间序列模型预测方法：</h2><p>算术平均法，移动平均法，加权移动平均法，指数平滑法，自回归法和移动平均法（ARIMA）</p><p>算数平均法：对时间序列的过去数据进行简单平均来进行预测<br>移动平均法(ARIMA)：不考虑远期的数据，仅考虑近期数据产生的影响。<br>加权移动平均法：给予近期数据较大的权重，远期数据较小的权重<br>指数平滑法：给予近期数据较大的权重，远期数据较小的权重，但是权重以指<br>数的形式适减<br>自回归法和移动平均法（ARIMA）:先对数据做了差分，之后再使用自回归滑动平均模型[^ARMA]模型。优点信息浪费最少，集趋势性，相关性和随机性于一身</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>T时刻的时间序列值</strong>表示为$X_t$,T-1时刻的序列值表述为$X_{t-1}$或者$X[t-1]$</p><p><strong>一个时间序列</strong>可以表述为：$\left{X_{t} | t=1,2,3 \dots n\right}$</p><p>滞后算子$B X,=X_{t-1}$</p><p>时间序列的差分:$X_{t}-X_{t-1}$或者$X[t]-X[t-1]$<br>一阶差分：$X_{t}-X_{t-1}=X_{t}-B X_{t}=(1-B) X_{t}$<br>二阶差分：$\nabla\left(\nabla X_{t}\right)=\nabla X_{t}-\nabla X_{r-1}=\left(X_{t}-X_{t-1}\right)-\left(X_{t-1}-X_{t-2}\right)=X_{t}-2 X_{t-1}+X_{t-2}=(1-B)^{2} X_{t}$<br>k步差分：$X_{t}-X_{t-k}=X_{t}-B^{k} X_{t}=\left(1-B^{k}\right) X_{t}$</p><p>思考：<br>1.三阶差分如何表达？3步差分如何表达？<br>2.为什么要进行一阶差分？二阶差分？<br>3.为什么要进行k步差分？<br>4.阶次差分与步长差分的区别？</p><h2 id="时间序列分类"><a href="#时间序列分类" class="headerlink" title="时间序列分类"></a>时间序列分类</h2><blockquote><p>Q:什么是序列平稳？</p><p>A:</p><p>1.$E\left(X_{t}\right)=\mu$，对于所有t而言，序列的期望为一常数，见图一</p><p>2.$\operatorname{Var}\left(X_{t}\right)=\sigma$，对于所有t，序列方差为一常数，见图二</p><p>3.$r(h)=\operatorname{Cov}\left(X_{t}, X_{t-l}\right)$对于所有t以及h〉0，序列的协方差为是由h唯一决定的函数，即h阶的相关性只与h有关，与时刻t无关，如：$\left{X_{n}, X_{n+1}, X_{n+2}, \ldots, X_{n}\right},\left{X_{1}, X_{2}, X_{3}, \ldots, X_{n+1}-n\right]$与$\left{X_{h+5}, X_{h+6}, X_{h+7}, \ldots, X_{n+5}\right},\left{X_{6}, X_{7}, X_{8}, \ldots, X_{n+6-h}\right}$的相关性一致</p></blockquote><p>根据序列是否平稳，时间序列可以分为：</p><p>平稳序列：白噪声序列、AR（p）序列，MA（a）序列，ARWA（p.g）序列<br>非平稳序列：ARlMA（P.d.g）序列</p><p>平稳条件:</p><p>1.$E\left(x_{t}\right)=\mu$序列的均值应该是一个常数，而不是随时间变化的函数。下图中左图满足要求，而右图的均值是随时间而变化的。</p><p><img src="/2019/07/29/时间序列概念及主要模型/1.jpg" alt="1"></p><p>2.$\operatorname{Var}\left(X_{t}\right)=\sigma$,序列的方差为一个常数，而不随时间的变化</p><p><img src="/2019/07/29/时间序列概念及主要模型/2.jpg" alt="2"></p><p>3.$\operatorname{Cov}(y t, y t+k)=y 0$,k,序列协方差的值只与时间间隔k有关，与时间t无关</p><p><img src="/2019/07/29/时间序列概念及主要模型/3.jpg" alt="3"></p><h3 id="白噪声序列"><a href="#白噪声序列" class="headerlink" title="白噪声序列"></a>白噪声序列</h3><p>(高斯)白噪声模型:$X_{t}=\mathrm{e}<em>{\mathrm{t}} | \mathrm{e}</em>{\mathrm{t}} \sim \mathrm{WN}\left(0, \sigma^{2}\right)$<br>(高斯)白噪声就是一系列独立分布的正态序列：</p><ul><li>序列相关性：无</li><li>趋势性：无</li><li>随机性：是</li></ul><p>白噪声的每一个时序点都是服从正态分布的</p><p><img src="/2019/07/29/时间序列概念及主要模型/B.jpg" alt="B"></p><p><img src="/2019/07/29/时间序列概念及主要模型/高斯白噪声散点图.jpg" alt="高斯白噪声散点图"></p><p>序列无规律可循，在均值处反复震荡<img src="/2019/07/29/时间序列概念及主要模型/高斯白噪声.jpg" alt="高斯白噪声"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clear,clc;</span><br><span class="line">N=<span class="number">0</span>:<span class="number">1000</span>;</span><br><span class="line">fs=<span class="number">1024</span>;</span><br><span class="line">t=N./fs;</span><br><span class="line">y=<span class="number">3</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*t);</span><br><span class="line">x=wgn(<span class="number">1</span>,<span class="number">1001</span>,<span class="number">2</span>);<span class="comment">% wgn产生高斯白噪声</span></span><br><span class="line"><span class="built_in">i</span>=y+x;<span class="comment">% 给原有信号y叠加高斯白噪声</span></span><br><span class="line"><span class="comment">%i=awgn(y,2); % awgn在信号y中加入高斯白噪声。</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>),plot(x);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>),plot(y);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>),plot(<span class="built_in">i</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="自回归模型AR"><a href="#自回归模型AR" class="headerlink" title="自回归模型AR"></a>自回归模型AR</h3><h4 id="▲AR-p"><a href="#▲AR-p" class="headerlink" title="▲AR(p):"></a>▲AR(p):</h4><p> $X_{t} = \beta_{1}X_{t-1}+\beta_{2} X_{t-2}+\ldots+\beta_{p} X_{t-p}+\mathrm{e}<em>{t} \quad \mathrm{e}</em>{t} \sim \mathrm{WN}\left(0, \sigma^{2}\right)$</p><p>当前时刻的时序值可由其过去值的线性组合加上一个白噪声</p><p>建模的目的就是要搞清过去几期的历史值会影响当前值</p><p>模型特征：</p><ul><li>趋势性：无</li><li>相关性：有</li><li>随机性：有</li></ul><h4 id="▲AR（1）模型"><a href="#▲AR（1）模型" class="headerlink" title="▲AR（1）模型:"></a>▲AR（1）模型:</h4><p>$X_{t}=\beta_{1} X_{t-1}+e_{t}$</p><p>一阶自回归模型是最简单的自回归模型</p><p>该模型在t+1时的情形:$X_{t+1}=\beta_{\perp} X_{t}+e_{t+1}$</p><p>自相关系数：$\rho_{1}=\beta_{1}, \rho_{2}=\beta_{1}^{2}, \ldots, \rho_{k}=\beta_{1}^{k}, \mathrm{k} \geq 3$<br>偏自相关系数：$\varphi_{11}=\rho_{1}, \varphi_{k k}=0, k \geqslant 2$</p><p>AR（1）的序列相关性：</p><ul><li>ACF星现指数下降趋势</li><li>PACF在一阶处出现峰值，之后截断</li></ul><p><img src="/2019/07/29/时间序列概念及主要模型/B2.jpg" alt="B2"></p><p>Q:如何识别自回归阶数</p><p>A:</p><ul><li>PACF显示出剧烈地下降，并截断在P阶，而ACF呈指数下降趋势</li><li>PACF截尾的阶数即为AR模型的阶数</li></ul><hr><h3 id="移动平均模型MA"><a href="#移动平均模型MA" class="headerlink" title="移动平均模型MA"></a>移动平均模型MA</h3><h4 id="▲MA-a"><a href="#▲MA-a" class="headerlink" title="▲MA(a):"></a>▲MA(a):</h4><p>$X_{t}=e_{t}+\dot{\beta}<em>{1} e</em>{t-1}+\beta_{2} e_{t-2}+\ldots+\beta_{q} e_{t-q}$ , $e_{t} \sim W N\left(0, \sigma^{2}\right)$</p><p>序列当前时刻的时序值是过去q阶白噪声的线性组合</p><p>建模的目的在于：</p><ul><li>找出过去几期的白噪声影响了当前值</li><li>找出过去a期冲击效应对当前值的影响</li></ul><p>模型特征：</p><ul><li>趋势性：无</li><li>相关性：有</li><li>随机性：有</li></ul><h4 id="▲MA（1）模型"><a href="#▲MA（1）模型" class="headerlink" title="▲MA（1）模型:"></a>▲MA（1）模型:</h4><p>$X_{t}=e_{t}+\beta_{1} e_{t-1}$</p><p>一阶移动平均模型是最简单的移动平均模型</p><p>该模型在t+1时的情形？$X_{t+1}=e_{t+1}+\beta_{1} e_{t}$</p><p>​    MA（1）模型是利用t时刻的冲击变量值来预测将来</p><p>自相关系数：$\rho_{k}=\frac{\gamma_{k}}{\gamma_{0}}=\left{\begin{array}{cc}{\frac{\beta_{1}}{1+\beta_{1}^{2}},} &amp; {k=1} \ {0} &amp; {k \geq 2}\end{array}\right.$<br>偏自相关系数：$\varphi_{k k}=\left{\begin{array}{cc}{\rho_{1},} &amp; {k=1} \ {\frac{-\rho_{1}^{2}}{1-\rho_{1}^{2}}} &amp; {k=2} \ {\frac{-\varphi_{k-1, k-1} \rho_{1}}{1-\varphi_{k-1,1} \rho_{1}}} &amp; {k \geq 3}\end{array}\right.$</p><hr><h3 id="自回归滑动平均模型ARMA"><a href="#自回归滑动平均模型ARMA" class="headerlink" title="自回归滑动平均模型ARMA"></a>自回归滑动平均模型ARMA</h3><h4 id="▲ARMA（p-q）-X-t-beta-1-X-t-1-ldots-beta-p-X-t-p-e-t-alpha-1-e-t-1-alpha-2-e-t-2-ldots-alpha-q-e-t-q"><a href="#▲ARMA（p-q）-X-t-beta-1-X-t-1-ldots-beta-p-X-t-p-e-t-alpha-1-e-t-1-alpha-2-e-t-2-ldots-alpha-q-e-t-q" class="headerlink" title="▲ARMA（p,q）:$X_{t}=\beta_{1} X_{t-1}+\ldots+\beta_{p} X_{t-p}+e_{t}+\alpha_{1} e_{t-1}+\alpha_{2} e_{t-2}+\ldots+\alpha_{q} e_{t-q}$"></a>▲ARMA（p,q）:$X_{t}=\beta_{1} X_{t-1}+\ldots+\beta_{p} X_{t-p}+e_{t}+\alpha_{1} e_{t-1}+\alpha_{2} e_{t-2}+\ldots+\alpha_{q} e_{t-q}$</h4><p>ARMA（p,q）模型就是AR（p）和MA（q）模型的组合</p><p>ARMA模型是更普遍的一类模型</p><p>模型特征：</p><ul><li>趋势性：无</li><li>相关性：有</li><li>随机性：有</li></ul><h4 id="▲ARMA-1-1-："><a href="#▲ARMA-1-1-：" class="headerlink" title="▲ARMA(1,1)："></a>▲ARMA(1,1)：</h4><p>通过查看自相关函数ACF和偏自相关函数PACF识别相关性<br>ACF呈指数下降趋势<br>PACF呈现指数下降趋势</p><p><img src="/2019/07/29/时间序列概念及主要模型/B3.jpg" alt="B3"></p><p>Q:如何识别一个ARMA的阶数p和q?</p><p>A:<br>1.由于ACF与PACF均呈现指数下降，判断阶数需要靠不断尝试<br>2.在模型的不同尝试中，通过选择AIC较小的为最优模型<br>$A I C=2 k+n * \ln (\frac{R S S}{n})$k为参教数量，RSS为残差平方和</p><h3 id="AR，MA，ARMA模型识别"><a href="#AR，MA，ARMA模型识别" class="headerlink" title="AR，MA，ARMA模型识别"></a>AR，MA，ARMA模型识别</h3><p><img src="/2019/07/29/时间序列概念及主要模型/analyse.jpg" alt="analyse"></p><hr><h3 id="ARIMA模型"><a href="#ARIMA模型" class="headerlink" title="ARIMA模型"></a>ARIMA模型</h3><p>ARIMA是在ARMA基础上发展而来的更加综合性的模型，体现为：<br>■ 趋势性<br>■ 序列相关性<br>■  随机性<br>ARIMA是不平稳的时间序列，不能直接用ARMA建模。ARIMA模型是在ARMA模型演变出来的，它实际上是先对数据做了差分，之后再使用ARMA模型；换句话说，ARIMA模型是先将非平稳数据变得平稳（用差分），之后再用ARMA模型处理平稳数据</p><p>ARIMA（1，1，0）的时间序列：<br>序列有很强的趋势性</p><p><img src="/2019/07/29/时间序列概念及主要模型/arima1.jpg" alt="arima1"></p><ul><li>ARIMA（1，1，0）的序列相关性：<br>ACF下降极其缓慢</li></ul><p><img src="/2019/07/29/时间序列概念及主要模型/arima2.jpg" alt="arima2"></p><ul><li>ARIMA（1，1，0）的序列图和ACF：</li></ul><p><img src="/2019/07/29/时间序列概念及主要模型/arima3.jpg" alt="arima3"></p><p>ARIMA(p,d,q)</p><ul><li>$\nabla_{d} X_{t}=(1-B)^{d} X_{t}=Y_{t}$</li><li>$Y_{t}=\beta_{1} Y_{t-1}+…+\beta_{p} Y_{t-p}+e_{t}+\alpha_{1} e_{t-1}+\alpha_{2} e_{t-2}+\ldots+\alpha_{q} e_{t-q}$</li><li>差分后的序列符合ARMA（p，g）</li></ul><p>符号△为差分算子，$\nabla_{d} X_{t}$代表d阶差分序列</p><p>一阶差分序列$\Delta X_{t}=(1-B)^{*} X_{t}=X_{t}-X_{t-1}$</p><h2 id="预测的评价指标"><a href="#预测的评价指标" class="headerlink" title="预测的评价指标"></a>预测的评价指标</h2><p>ME（误差）：Mean（Actual-Predict）<br>MAE（绝对误差）：Mean（abs（Actual-Predict））<br>MAPE（百分比误差）：Mean（abs（Actual-Predict/Actual）<br>MSE（均方误差平方和）：Mean（（Actual-Predict）2）<br>RMSE（标准差）：Sqrt（Mean（（Actual-Predict）A2））</p><p>在模型选择方法上，通常会结合客户的建议以及其他的时间序列模型方法，选择某个评价指标，进而选择使该评价指标最小的模型方法</p><p>参考:<a href="https://blog.csdn.net/weixin_41636030/article/details/89115370" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41636030/article/details/89115370</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时间序列概念及主要模型&quot;&gt;&lt;a href=&quot;#时间序列概念及主要模型&quot; class=&quot;headerlink&quot; title=&quot;时间序列概念及主要模型&quot;&gt;&lt;/a&gt;时间序列概念及主要模型&lt;/h1&gt;&lt;p&gt;Q:什么是时间序列分析?&lt;br&gt;A:时间序列是按照时间顺序，按照一定
      
    
    </summary>
    
    
      <category term="数学建模" scheme="https://nymrli.top/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>基础知识补充——白噪声、高斯白噪声</title>
    <link href="https://nymrli.top/2019/07/29/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85%E2%80%94%E2%80%94%E7%99%BD%E5%99%AA%E5%A3%B0%E3%80%81%E9%AB%98%E6%96%AF%E7%99%BD%E5%99%AA%E5%A3%B0/"/>
    <id>https://nymrli.top/2019/07/29/基础知识补充——白噪声、高斯白噪声/</id>
    <published>2019-07-29T10:47:04.000Z</published>
    <updated>2019-07-30T06:29:00.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="白噪声、高斯白噪声"><a href="#白噪声、高斯白噪声" class="headerlink" title="白噪声、高斯白噪声"></a>白噪声、高斯白噪声</h1><h2 id="白噪声过程"><a href="#白噪声过程" class="headerlink" title="白噪声过程:"></a>白噪声过程:</h2><p>对于一个随机变量X(t)（t=1，2，3……），如果是由一个不相关的随机变量的序列构成的，即对于所有s不等于t，随机变量X(t)和X(s)的协方差为零，则称其为纯随机过程。对于一个纯随机过程来说，若其期望为0，方差为常数，则称之为白噪声过程。</p><h2 id="白噪声"><a href="#白噪声" class="headerlink" title="白噪声:"></a>白噪声:</h2><p>白噪声序列，是指<u>白噪声过程的样本</u>实称，简称白噪声[^1]。白噪声是<strong>在较宽的频率范围内，各等带宽的频带所含的噪声能量相等的噪声</strong>[^2]，是一种功率频谱密度为常数的随机信号或随机过程，也就是说，此<u>信号在各个频段上的功率是一样的</u>。</p><p>理想的白噪声具有无限的带宽，因而其能量无限大，但这是不可能实际存在的，所以，我们把有限带宽内的平整讯号视为白噪声[^3]，以便我们实际应用当中的分析。<br>近似计算:一般情况下，若一个噪声过程所具有的频谱宽度远远大于它所作用系统的带宽，并且在该带宽中其功率谱密度基本为一常数，那么就能够把其作为白噪声来对待。</p><p>白噪声的功率密度函数恒定，为$P_{n}(t)=\frac{n_{0}}{2}(-\infty&lt;f&lt;+\infty)(\mathrm{W} / \mathrm{HZ})$<br>$P_{n}(t)=n_{0}(0&lt;f&lt;+\infty)(\mathrm{W} / \mathrm{Hz})$，其中$n_0$是常数。</p><h2 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h2><p>高斯噪声指的是它的<strong>概率密度函数服从正态分布的噪声</strong>。</p><p>高斯分布，记为N (μ,σ2)，其中μ为高斯分布的均值（数学期望），σ2为高斯分布的方差，当μ=0，σ2=1时，该分布称为标准正态分布。高斯分布的一维概率密度可表示为式：$P(x)=\frac{1}{\sqrt{2 \pi} \sigma} \exp \left(-\frac{(x-\mu)^{2}}{2 \sigma^{2}}\right)$</p><p>在通信信道中，一般噪声的均值μ=0。，那么可以得知当噪声的均值是零的时候，噪声的平均功率等于其方差。</p><p>高斯白噪声的高斯指的是概率分布为正态分布，白噪声指的是其二阶矩不相关，一阶矩为常数的噪声。故把<strong>瞬时值概率分布服从高斯分布，功率谱密度服从均匀分布的噪声</strong>称为高斯白噪声[^1]。这两个条件是判断高斯白噪声性能的标准。</p><p>由于高斯白噪声能够反映实际通信信道中的噪声情况，能够比较真实的反映信道噪声的一些特性，并且可以用具体的数学表达式表示，适合分析、计算系统的抗噪声性能，所以广泛应用于通信系统的理论分析。</p><p>高斯白噪声模型:$X_{t}=\mathrm{e}<em>{\mathrm{t}} | \mathrm{e}</em>{\mathrm{t}} \sim \mathrm{WN}\left(0, \sigma^{2}\right)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;白噪声、高斯白噪声&quot;&gt;&lt;a href=&quot;#白噪声、高斯白噪声&quot; class=&quot;headerlink&quot; title=&quot;白噪声、高斯白噪声&quot;&gt;&lt;/a&gt;白噪声、高斯白噪声&lt;/h1&gt;&lt;h2 id=&quot;白噪声过程&quot;&gt;&lt;a href=&quot;#白噪声过程&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="信号处理" scheme="https://nymrli.top/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>傅里叶变换-&gt;小波变化</title>
    <link href="https://nymrli.top/2019/07/29/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-%E5%B0%8F%E6%B3%A2%E5%8F%98%E5%8C%96/"/>
    <id>https://nymrli.top/2019/07/29/傅里叶变换-小波变化/</id>
    <published>2019-07-29T01:51:32.000Z</published>
    <updated>2019-07-30T06:29:10.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="傅里叶变换-gt-小波变化"><a href="#傅里叶变换-gt-小波变化" class="headerlink" title="傅里叶变换-&gt;小波变化"></a>傅里叶变换-&gt;小波变化</h1><blockquote><p>声明:文中大多数内容来自(<a href="https://www.zhihu.com/people/zhi-yuan-ya-77" target="_blank" rel="noopener">知乎1335</a>)[<a href="https://www.zhihu.com/people/zhi-yuan-ya-77],matlab源代码:[1368069096/From_FT_to_WT_examples-](https://link.zhihu.com/?target=https%3A//github.com/1368069096/From_FT_to_WT_examples-),部分为个人理解阐明" target="_blank" rel="noopener">https://www.zhihu.com/people/zhi-yuan-ya-77],matlab源代码:[1368069096/From_FT_to_WT_examples-](https://link.zhihu.com/?target=https%3A//github.com/1368069096/From_FT_to_WT_examples-),部分为个人理解阐明</a></p></blockquote><h2 id="一-傅里叶变换FT"><a href="#一-傅里叶变换FT" class="headerlink" title="一.傅里叶变换FT"></a>一.傅里叶变换FT</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote><p>（FOURIER TRANSFORM，简称FT）</p></blockquote><h3 id="为什么傅里叶变换可以把一个信号从时域变换到频域"><a href="#为什么傅里叶变换可以把一个信号从时域变换到频域" class="headerlink" title="为什么傅里叶变换可以把一个信号从时域变换到频域?"></a>为什么傅里叶变换可以把一个信号从时域变换到频域?</h3><p>先给出公式，傅里叶变换的形式为：$X(w)=\int_{-\infty}^{+\infty} x(t) e^{-j w t} d t$</p><p>PS：傅里叶变换还存在系数，有的文章写的是 $\frac{1}{2 \pi}$ ，有的文章写的是$\sqrt\frac{1}{2 \pi}$ ，两个系数只要满足正变换系数乘上逆变换系数等于$\frac{1}{2 \pi}$ 即可。这是为了保证经过一次正变换和反变换之后，得到的信号与原信号幅值相同，与我们接下来的讨论关系不大。</p><h3 id="1-理解变换公式"><a href="#1-理解变换公式" class="headerlink" title="1.理解变换公式"></a>1.理解变换公式</h3><p>我们知道，根据欧拉公式，$e^{-j w t}=\cos (w t)-j \sin (w t)$。也就是说，傅里叶变换的本质就是：将原始信号乘上一组<strong>三角函数</strong>（正余弦），之后<strong>在整个时间域上积分</strong>。就这么简单！</p><h4 id="y-sin-3t-图"><a href="#y-sin-3t-图" class="headerlink" title="y=sin(3t)图"></a>y=sin(3t)图</h4><p>我们来看一个信号：y = sin(3t)，如下图：</p><p><img src="https://pic2.zhimg.com/80/v2-0cd28b5014a967f161a3327a44793ba5_hd.jpg" alt="img"></p><p>很好的周期性质，且每个周期的积分值都是0。如果对这个函数在$(-\infty,+\infty)$积分，那就是基本是0，因为 $(-\infty,+\infty)$包含了无数个周期。</p><p>PS：虽然这个积分在高数上不可积，但是你应该明白这里我要表达的意思：<strong>因为良好的周期性，且每个周期积分值是0，那么最后在很长的一段时间区间上积分，得到的还是一个很小的数，近似为0。</strong></p><p>我们来用一段较长的时间区间计算一下，$\int_{0}^{50} \sin (3 t) d t=0.1002$，结果符合我们的预计。</p><h4 id="y-sin-4t-sin-3t-图"><a href="#y-sin-4t-sin-3t-图" class="headerlink" title="y=sin(4t)sin(3t)图"></a>y=sin(4t)sin(3t)图</h4><p>现在，我们来将这个信号乘上一个sin(4t) ，则信号变为y1 = sin(3t)*sin(4t)，如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-5f0c8596fe05899d0cb5a1acaec70cfe_hd.jpg" alt="img"></p><p>具有一个较短的小幅震动的周期和一个较长的主体周期，对吧？且每个主体周期的积分值都是0。同以上讨论，如果对这个函数在$(-\infty,+\infty)$积分，<strong>基本还接近于0</strong>，因为  $(-\infty,+\infty)$包含了无数个主体周期。</p><h4 id="y-sin-3-1t-sin-3t-图"><a href="#y-sin-3-1t-sin-3t-图" class="headerlink" title="y=sin(3.1t)sin(3t)图"></a>y=sin(3.1t)sin(3t)图</h4><p>之后呢，我们来将这个信号乘上一个sin(3.1t) ，则信号变为y2 = sin(3t)*sin(3.1t)，如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-5af405c36d2d0ef48ab9f91ac7fb1672_hd.jpg" alt="img"></p><p>同样是有一个较短的小幅震动的周期和一个较长的主体周期，对吧？可以判断，每个主体周期的积分值都是0（虽然（0，50）这个区间没有完整地展示主题周期）。那么，依然同以上讨论，如果对这个函数在$(-\infty,+\infty)$ 积分，基本还接近于0，因为$(-\infty,+\infty)$包含了无数个主体周期。</p><p>我们来用之前的时间区间计算一下， $\int_{0}^{50} \sin (3 t) * \sin (3.1 t) d t=-4.7731$ 。</p><p>咦？这一次怎么距离0这么远了呢？</p><p>原因就是：<strong>对于sin(3t)*sin(4t)，它的主体周期较短</strong>，（0，50）是包含了好几个主体周期的，也就是说（0，50）在某种程度上是类似于 $(-\infty,+\infty)$ 的。但是，<strong>对于sin(3t)*sin(3.1t)，它的主体周期很长</strong>，（0，50）连它的一个完整的主体周期都没有包含，那么（0，50）是不能类似于 $(-\infty,+\infty)$ 的，积分值自然就比较大。</p><p>我们此时可以这样小小总结一下，对于信号y = sin(3t)，它的频率是3rad/s，（如果你喜欢用HZ，那就除以$2\pi$ ，就是 $\frac{3}{2\pi}$HZ，这里使用rad/s，是为了与前面的傅里叶变换的公式中的w一致），而sin(4t)的频率是4rad/s，sin(3.1t)的频率是3.1rad/s。</p><p>如果在 $(-\infty,+\infty)$ 积分，那么y1 = sin(3t)<em>sin(4t)，y2 = sin(3t)</em>sin(3.1t)的积分值都是0，也就是说，sin(4t)和sin(3.1t)在这里是没差别的。</p><p>但是！！！<strong>如果在一个<u>有限区间内</u>积分，由于sin(3.1t)的频率3.1rad/s，距离原信号y = sin(3t)的频率3rad/s更近，那么sin(3.1t)和sin(3t)的乘积，也就是y2 = sin(3t)*sin(3.1t)的积分的绝对值会更大，也就是会离0更远。这里已经显示出一定的频率选择性了。</strong></p><p>最后，让我们请出我们今天的主角，将这个信号乘上一个自己同频率的sin(3t) ，则信号变为y3 = sin(3t)*sin(3t)，如图：</p><p><img src="https://pic2.zhimg.com/80/v2-639fbf1ab8e20ee318da83b21c641da1_hd.jpg" alt="img"></p><p>Amazing！！！发现了什么？良好的周期性？还有呢？<strong>由于乘上了自己，任何时间的幅值都大于等于0了！不再满足周期内积分值为0这个条件了！</strong>那么，此时，我们对这个信号在 $(-\infty,+\infty)$ 积分，就会得到一个非常非常大的数字。<strong>这个很大很大的数字就告诉你，这个信号和你乘的信号是同频率的！这就是可以知道信号中具有哪些频率部分了，不是吗？</strong></p><p>我们还是来用之前的时间区间计算一下， $\int_{0}^{50} \sin (3 t) * \sin (3 t) d t=25.0833$。<strong>是不是比其他的积分值都大了好多？</strong></p><p>好了，我们已经知道，<strong>▲.将一个信号乘上一个特定频率的sin函数，在 $(-\infty,+\infty)$ 上积分，可以将信号中与sin函数同频率的部分筛选出来。那么，原则上讲，只要乘上所有频率的sin函数，并积分，不就知道原始信号中的所有频率部分了吗？</strong></p><p><strong>但是这样做需要把所有频率乘进去，做无数次计算哈！</strong>算不出来的。所以，<strong>我们将所乘的sin函数的频率作为符号变量w，来进行积分，即：</strong></p><p>$X(w)=\int_{-\infty}^{+\infty} x(t) \sin (w t) d t$</p><p>注意：这里的w只是一个符号变量，这样的话，<strong>就只需要做一次积分，可以计算了。</strong></p><p><strong>计算出来X(w)之后，想知道特定的频率w0对应的积分值，直接将w0带入X(w)就立马得到积分值。</strong>，如想知道是否含有w0=3rad/s分量,那么久计算X(3)看结果是否为0，这样就能知道原信号中是否含有这一频率的部分了。</p><p>好了，我们推导的这个式子，是不是与傅里叶变换的式子：</p><p>$X(w)=\int_{-\infty}^{+\infty} x(t) e^{-j w t} d t=\int_{-\infty}^{+\infty} x(t)(\cos (w t)-j \sin (w t)) d t$</p><p>很像了呢？</p><p><strong>这就是傅里叶变换的原理！乘上带有符号变量的sin、cos函数，并积分，就知道原始信号中的所有频率部分啦！</strong></p><h3 id="2、傅里叶变换（FT）的正交性"><a href="#2、傅里叶变换（FT）的正交性" class="headerlink" title="2、傅里叶变换（FT）的正交性"></a><strong>2、傅里叶变换（FT）的正交性</strong></h3><p>傅里叶变换是一种变换。在变换中，我们<strong>将原始信号乘上的变化信号称为基函数</strong>。</p><p>在傅里叶变换中，一系列不同频率的sin、cos等函数称为这个变换的基函数。至于为什么需要既使用sin，又使用cos，这涉及到一点点正交函数的概念。傅里叶变换中的不同频率的<strong>sin、cos等函数是正交函数</strong>，使用正交函数组成的基函数会带给变换一些方便。</p><h4 id="什么是正交性"><a href="#什么是正交性" class="headerlink" title="什么是正交性?"></a>什么是正交性?</h4><h5 id="向量正交"><a href="#向量正交" class="headerlink" title="向量正交:"></a>向量正交:</h5><p>我们都知道，向量 <img src="https://www.zhihu.com/equation?tex=a%2Cb" alt="[公式]"> 的内积为<img src="https://www.zhihu.com/equation?tex=a%5Ccdot+b" alt="[公式]"> 。<strong>正交的定义为内积为0</strong>，即$a \cdot b=0$。如$a=(1,0)$ 表示x轴，$b=(0,1) $表示y轴，则 $a \cdot b=0$即意味着x轴与y轴正交。</p><p>假设有一个向量 $v=\left(x_{0}, y_{0}\right)$， $x_0$ 在x轴上定位v，$y_0$ 在y轴上定位v。<strong>当x轴与y轴正交时，意味着x坐标和y坐标表示的信息是彼此独立的，两坐标可以完全定位v。</strong></p><p>那么，当我们已知向量v，已知x轴a与y轴b，如果知道v的坐标呢？答案就是，<strong>投影/内积</strong>。</p><p>将v向x轴a做投影/内积： <img src="https://www.zhihu.com/equation?tex=x_0+%3D+v%5Ccdot+a" alt="[公式]"> ，可以得到<img src="https://www.zhihu.com/equation?tex=x_0" alt="[公式]">；将v向y轴b做投影/内积： <img src="https://www.zhihu.com/equation?tex=y_0+%3D+v%5Ccdot+b" alt="[公式]">，可以得到<img src="https://www.zhihu.com/equation?tex=y_0" alt="[公式]">。</p><h5 id="正交基"><a href="#正交基" class="headerlink" title="正交基"></a>正交基</h5><p>类似的，函数$  f_{1}(x), f_{2}(x)  $的内积定义如下：$\int_{-\infty}^{+\infty} f_{1}(x) f_{2}(x) d x$。<strong>函数正交的定义同样为内积为0</strong>，即 $\int_{-\infty}^{+\infty} f_{1}(x) f_{2}(x) d x=0$ 。PS：对于周期函数，定义中的积分区间为一个周期T。</p><p>我们来看，</p><p>$\int_{0}^{T} \sin \left(w_{1} x\right) \cos \left(w_{2} x\right) d x=0   (1)$ </p><p>$\int_{0}^{T} \sin \left(w_{1} x\right) \sin \left(w_{2} x\right) d x=0, w_{1} \neq w_{2}(2)$</p><p>$\int_{0}^{T} \cos \left(w_{1} x\right) \cos \left(w_{2} x\right) d x=0, w_{1} \neq w_{2}(3)$</p><p>▲.因此，傅里叶变换中的不同频率的sin、cos等函数都是正交函数。我们<strong>将cos想象为一个轴，将sin想象为一个轴</strong> ，这两个轴，就张了一个<strong>函数空间</strong>。</p><p>我们已经知道，x(t)的傅里叶变换为：</p><p>$X(w)=\int_{-\infty}^{+\infty} x(t)(\cos (w t)-j \sin (w t)) d t=\int_{-\infty}^{+\infty} x(t) \cos (w t) d t-j \int_{-\infty}^{+\infty} x(t) \sin (w t) d t$</p><p>我们来看，实部 $\int_{-\infty}^{+\infty} x(t) \cos (w t) d t$ 即相当于将x(t)与cos做内积，即向cos轴投影，得到的是在这个<strong>函数空间</strong>内的cos坐标，也就是与cos的相似度；虚部$\int_{-\infty}^{+\infty} x(t) \sin (w t) d t$ 即相当于将x(t)与sin做内积，即向sin轴投影，得到的是在这个函数空间内的sin坐标，也就是与sin的相似度。cos坐标和sin坐标都确定后，该信号就确定了。</p><p>因此，傅里叶变换之后，<strong>实部是与cos的相似度，虚部是与sin的相似度</strong>，傅里叶变换也就是与cos的相似度和与sin的相似度的总和，也就表示了相应的频率信息。</p><p>相似度的理解：通过相似度，可以将跟本身频率相似的频率挑选出来</p><p><strong>3、小例子</strong></p><p>最后，我们对于y=sin(3t)做傅里叶变换（这里画图用的matlab的FFT，是FT的离散快速算法，不是积分出来的，但是原理是相同的，仅做展示使用），变换后的图像如下：</p><p><img src="https://pic4.zhimg.com/80/v2-ffb3a17723fa1ef528dfc2350a36bd6f_hd.jpg" alt="img"></p><p>可以看到，与我们的预期相同，变换之后，在  $\omega=3 rad/ s$  处，出现了峰值，即表示该信号中包含了 的  $\omega=3 rad/ s$ 频率成分。</p><h3 id="这里需要说明三点："><a href="#这里需要说明三点：" class="headerlink" title="这里需要说明三点："></a>这里需要说明三点：</h3><p>1、这边的作图结果不是理想FT，如果是理想的FT，即在 $(-\infty,+\infty)$ 上积分，那么除了   $\omega=3 rad/ s$ 的积分值将是 $+\infty$ 之外，其他任意频率处的值都应该是0，得到的将是一个冲激函数。但是，这里我用的是离散傅里叶变换（详见我的下一篇文章），可以暂时理解为<strong>类似于我们讨论过的有限区间</strong>，当频率靠近3rad/s时（如之前提到的3.1rad/s的例子），也会积分出来一个较大的数值，所以这里不是一个冲击函数，而是一个山峰状的函数；</p><p>2、傅里叶变换之后是具有<strong>实部和虚部的</strong>，实部是与cos的相似度，虚部是与sin的相似度。我们要频率信息的时候，不管是与某一频率w的cos的相似还是与某一频率w的sin的相似，都是这一频率w嘛，不需要区分。因此，这里画图取了模，就不存在实部和虚部了。</p><p>3、在$\omega=3 r a d / s$处之所以没有出现我们讨论的很大很大很大的值，是因为画图之前对于变换之后的幅值统一除以了信号取样点的个数，统一压缩了一定的倍数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.由于sin和cos是一对正交基，所以所有的信号都可以分解成正弦信号与余弦信号的线性叠加。</p><p>2.除了与乘以本身频率w的正余弦相同信号再在$(-\infty,+\infty)$范围上积分的结果会是非0以外，乘以其他频率信号的结果都是0.通过这个特性可以将是否含有w频率信号鉴别出</p><p>2.傅里叶变化的基函数$e^{jwt}$由欧拉公式可分解为$e^{-j w t}=\cos (w t)-j \sin (w t)$,所以根据公式:$X(w)=\int_{-\infty}^{+\infty} x(t) \cos (w t) d t-j \int_{-\infty}^{+\infty} x(t) \sin (w t) d t$，前部分乘以cos(wt)能挑出cos成分中的信号频率，后部分乘以的sin(wt)能挑出sin成分中的信号频率。再将挑出的各信号频率线性叠加的结果就是分解信号总的含有各谐波分量的频率</p><hr><h2 id="二-傅里叶变换（FT）的缺点与短时傅里叶变换（STFT）"><a href="#二-傅里叶变换（FT）的缺点与短时傅里叶变换（STFT）" class="headerlink" title="二.傅里叶变换（FT）的缺点与短时傅里叶变换（STFT）"></a>二.傅里叶变换（FT）的缺点与短时傅里叶变换（STFT）</h2><h3 id="离散傅里叶变换（DFT）"><a href="#离散傅里叶变换（DFT）" class="headerlink" title="离散傅里叶变换（DFT）"></a>离散傅里叶变换（DFT）</h3><p>在本文正式开始之前，我们需要明确一下实际信号进行的FT的一些特殊之处。实际采集的信号往往是这样的：</p><p><img src="https://pic4.zhimg.com/80/v2-fb5df4498e5bd43450ec0476c56129f3_hd.jpg" alt="img"></p><p>实际的信号往往具有两个特点：</p><p>1、<strong>离散性</strong>，就是采集数据不连续，很容易理解，采集信号肯定是一个一个数据采集的；</p><p>2、<strong>有限性</strong>，虽然理想的傅里叶变换是从 $(-\infty,+\infty)$ 进行积分，但是实际信号往往实在一个区间内(a,b)的。</p><p>所以，我们要用到离散傅里叶变换（DISCRETE FOURIER TRANSFORM，简称DFT），DFT与FT相比，就是多了两个特征：<strong>1、离散型，2、有限性</strong>。</p><p>我们来一起试一试如何推导DFT公式。首先设采集了N个信号点，其时刻为 $t_{0}, t_{1}, \ldots t_{N-1}$，对应时刻采集到的信号值为$x\left(t_{0}\right), x\left(t_{1}\right), \ldots x\left(t_{N-1}\right)$ 。很自然的，原来信号连续，是积分，现在数据离散了，那就是把积分变成累加。于是我们得到： $X(w)=\sum_{i=0}^{N-1} x\left(t_{i}\right) e^{-j w t_{i}}$</p><p>这么一来，我们发现，原信号有N个数据点，DFT变换后的信号却变成连续的了，我们将之称为<strong>离散时间傅里叶变换（</strong>DISCRETE TIME FOURIER TRANSFORM，简称<strong>DTFT）</strong>。</p><p>DTFT有两个缺点，第一， <img src="https://www.zhihu.com/equation?tex=w+%5Cin+%28-%5Cinfty%2C%2B%5Cinfty%29" alt="[公式]"> 且连续，需要进行无数次计算，计算机无法计算；第二，在进行计算的时候，我们需要已知：$t_{0}, t_{1}, \ldots t_{N-1}$和 $x\left(t_{0}\right), x\left(t_{1}\right), \ldots x\left(t_{N-1}\right)$ ，但是调用过FFT函数的同学都知道，FFT只需要已知$x\left(t_{0}\right), x\left(t_{1}\right), \ldots x\left(t_{N-1}\right)$就可以进行。</p><p>这是怎么回事呢？</p><p>首先，我们<strong>使用相对采样时间 <img src="https://www.zhihu.com/equation?tex=n+%3D+0%2C1%2C...N-1" alt="[公式]"> 代替真实采样时间 <img src="https://www.zhihu.com/equation?tex=t_0%2Ct_1%2C...t_%7BN-1%7D" alt="[公式]"> ，</strong>可以得到： <img src="https://www.zhihu.com/equation?tex=X%28w%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-jwn%7D" alt="[公式]"> 。</p><p>此时我们发现， $X(w)$ 变成了以 $2\pi$为周期的函数，即 <img src="https://www.zhihu.com/equation?tex=X%28w%2B2%5Cpi%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-j%28w%2B2%5Cpi%29n%7D+%3D++%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-jwn%7De%5E%7B-j2%5Cpi+n%7D+%3D++%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-jwn%7D+%3D+X%28w%29" alt="[公式]"></p><p>那么，我们只需要计算 $w \in(0,2 \pi)$ 区间的 $X(w)$ ，就可以得到 $w \in(-\infty,+\infty)$ 区间的$X(w)$了。也就是说，通过使用相对采样时间 <img src="https://www.zhihu.com/equation?tex=n+%3D+0%2C1%2C...N-1" alt="[公式]"> 代替真实采样时间$t_{0}, t_{1}, \ldots t_{N-1}$，我们将 <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> 的范围从 $(-\infty,+\infty)$ 缩小到了(0,$2\pi$).</p><p>自然地，我们希望将(0,$2\pi$)离散化称为N个点，这样计算机就可以计算了！则取$w=\frac{2 \pi k}{N}, k=0,1, \ldots N-1$，则有： $X(k)=\sum_{n=0}^{N-1} x(n) e^{-j \frac{2 \pi k}{N} n}, k=0,1 \ldots N-1$</p><p>好了，这就是<strong>离散傅里叶变换DFT</strong>了！</p><p>接下来，来看DFT的两个性质：</p><ul><li><p>第一， <img src="https://www.zhihu.com/equation?tex=X%280%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29" alt="[公式]"> ，即 <img src="https://www.zhihu.com/equation?tex=X%280%29" alt="[公式]"> 是所有元素的和，通常会比其他的元素大几个数量级。</p></li><li><p>第二， <img src="https://www.zhihu.com/equation?tex=X%281%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-j+2%5Cpi%5Cfrac%7B1%7D%7BN%7D+n%7D" alt="[公式]"> ，<img src="https://www.zhihu.com/equation?tex=X%28N-1%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-j+2%5Cpi%5Cfrac%7BN-1%7D%7BN%7D+n%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=X%281%29+%3D+%5Ctilde%7BX%28N-1%29%7D" alt="[公式]"> ，即第二个元素和最后一个元素共轭，同理有<img src="https://www.zhihu.com/equation?tex=X%282%29+%3D+%5Ctilde%7BX%28N-2%29%7D" alt="[公式]"> 等等。</p></li></ul><p>如下图所示，DFT之后的N 个元素中，第一个为均值；之后的 N-1个元素，只有一半元素是独立的。</p><p><img src="https://pic3.zhimg.com/80/v2-7779743b0ad81ce875fe42c0f69adbc2_hd.jpg" alt="img"></p><p>需要说明，这里 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 是一种相对频率，独立元素中，最小相对频域为1，最大相对频率为 $\frac{N}{2}$ 。<strong>要想把</strong> <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> <strong>还原到真实的频率</strong> <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> <strong>，只需要 <img src="https://www.zhihu.com/equation?tex=w+%3D+%5Cfrac%7Bk-1%7D%7BN%7DFs" alt="[公式]"> ，将</strong> <img src="https://www.zhihu.com/equation?tex=k%3D1%2C2...%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> <strong>映射到</strong> <img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29" alt="[公式]"> <strong>即可</strong>， <img src="https://www.zhihu.com/equation?tex=Fs" alt="[公式]"> <strong>为采样频率。</strong></p><p>PS：简单说一下，根据香农采样定理，当采样频率为 <img src="https://www.zhihu.com/equation?tex=Fs" alt="[公式]"> 时，能采到的最大信号频率为<img src="https://www.zhihu.com/equation?tex=%5Cfrac%7BFs%7D%7B2%7D" alt="[公式]">。因此，将相对频率 <img src="https://www.zhihu.com/equation?tex=k%3D1%2C2...%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> 通过公式 <img src="https://www.zhihu.com/equation?tex=w+%3D+%5Cfrac%7Bk-1%7D%7BN%7DFs" alt="[公式]"> ，得到的 <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> 就在区间<img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29" alt="[公式]">内，也就是真实频率的区间了。</p><p>所以DFT公式为： <img src="https://www.zhihu.com/equation?tex=X%28k%29+%3D+%5Csum_%7Bn%3D0%7D%5E%7BN-1%7Dx%28n%29+e%5E%7B-j%5Cfrac%7B2%5Cpi+k%7D%7BN%7Dn%7D%2C+k+%3D+0%2C1...N-1" alt="[公式]"></p><p>PS：DFT公式的形式很多，有的是从时域到频域，有的是从空间域到频域，但是本质都是一样的，抓住<strong>离散性</strong>和<strong>有限性</strong>两个特点即可。<strong>离散性是指积分变成了累加，有限性是指积分/累加区间不是 $(-\infty,+\infty)$ 了，而是一个有限区间了。</strong></p><h3 id="傅里叶变换（FT）的缺点"><a href="#傅里叶变换（FT）的缺点" class="headerlink" title="傅里叶变换（FT）的缺点"></a><strong>傅里叶变换（FT）的缺点</strong></h3><p>应该说明，虽然本小节的题目是FT的缺点，但是FT和DFT的本质是相同的。由于信号都是有限长度的、离散的，所以接下来进行的都是DFT，不过在某些部分为了方便理解，还是写了FT的公式。在看本文的时候，你不需要刻意区分这两个概念。</p><p>我们现在来看两个信号，如下图：</p><p>$y 1=\sin (5 t) <em>(0&lt;t&lt;25)+\sin (t) </em>(25&lt;t&lt;50)$<br>$y 2=\sin (t) <em>(0&lt;t&lt;25)+\sin (5 t) </em>(25&lt;t&lt;50)$</p><p><img src="https://pic3.zhimg.com/80/v2-023a9ca6d0985e9dc271a08a199269de_hd.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-4ea09915e3f6f18391df410eab709da4_hd.jpg" alt="img"></p><p>这两个信号都是由sin(t)和sin(5t)组成的，y1是先出现了sin(5t)，再出现了sin(t)，y2是先出现了sin(t)，再出现了sin(5t)。</p><p>我们对它们进行FT，看看他们包含怎么样的频率，如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-8a1cd705a0354cb0cbeb067e1f7ce992_hd.jpg" alt="img">                                                                    y1,FT</p><p><img src="https://pic1.zhimg.com/80/v2-c95d1c9d11a72b51447425f5fbd0e0c8_hd.jpg" alt="img">                                                                        y2,FT</p><p>Amazing！发现了什么？<strong>变换后的结果是一模一样的，都在w=1rad/s和w=5rad/s出现了峰值！这就可以说明FT的缺点了——FT只能提供频域信息，而完全丢失了时域信息！！！</strong></p><p><strong>不管某一频率的信号出现的时间是早还是晚，FT都是将它一视同仁地乘上sin和cos(FT的变换基函数)，然后在整个时间区间加和。因此，它不能提供某一频率信号出现的时间。</strong></p><p>比如，对于上面两个信号，FT只能告诉我们，它们都有1rad/s和5rad/s的频率，而不能告诉我们1rad/s和5rad/s分别出现在哪个时间段。</p><p>所以，怎么办呢？？？</p><p><strong>那就是把信号分成左右两半啊！左边进行一次FT，右边进行一次FT，很简单吧！好了，这就是短时傅里叶变换（STFT）的基本原理。</strong></p><p>所以，接下来我们要正式开始步入——短时傅里叶变换（STFT），看看它是如何解决这个问题的。</p><h3 id="短时傅里叶变换（STFT）"><a href="#短时傅里叶变换（STFT）" class="headerlink" title="短时傅里叶变换（STFT）"></a><strong>短时傅里叶变换（STFT）</strong></h3><p>如上所述，我们将信号从中间截断，左边进行一次FT，右边进行一次FT，分别来看看。</p><p><img src="https://pic4.zhimg.com/80/v2-43e0b0a1d3e8758f32fc784a35b00183_hd.jpg" alt="img">y1左</p><p><img src="https://pic3.zhimg.com/80/v2-6ccbe7a93f390033d4444a949bcd356e_hd.jpg" alt="img">y1右</p><p><img src="https://pic2.zhimg.com/80/v2-271124958efcef10cd9a370d3f5061b9_hd.jpg" alt="img">y2左</p><p><img src="https://pic4.zhimg.com/80/v2-417fda7319483f84086bc73b299c5b03_hd.jpg" alt="img">y2右</p><p>可以看出，y1的左半部分是5rad/s，右半部分是1rad/s，y2恰好相反。这就说明，在y1中，(0, 25)的信号是5rad/s的频率，(25, 50)的信号是5rad/s的频率，y2恰好相反。<strong>这就是短时傅里叶变换的基本原理。</strong></p><p>但是数学嘛，能用一个公式表达的，就别用一段话表达，截断、切开这些语句太不专业了。<strong>截断、切开的操作，更专业的讲叫作分窗，其实是可以通过数学上的处理变成DFT变换的基函数的一部分的。接下来我们来看一看。</strong></p><p>首先，你可以想象一下，有一个窗子在这个信号上从左向右滑动，每次你都只能看到这个信号的一部分，<strong>所以我们把这个长度叫作窗长width。</strong></p><p>现在我们来定义一个方窗函数$y_{\text {window}}=1 *(-\text {width} / 2&lt;t&lt;\text {width} / 2)$ ，如下图，即是width = 10 的一个方窗函数：</p><p><img src="https://pic2.zhimg.com/80/v2-bd998377f53a5dffc8546cf019d119a1_hd.jpg" alt="img"></p><p>定义了方窗函数之后，我们<strong>只需要对方窗函数进行平移，再与原信号作乘，就相当于原来的截断、切开的操作，因此这种操作更专业地叫作分窗。</strong></p><p>那么，<strong>将方窗函数向右平移了 <img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]">（s可能是sliding的意思吧），再与原信号相乘，由于方窗函数除了中心的width部分是1外，其他部分都是0，这就相当于提取出了原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处，宽度为width的部分</strong>，这个信号分窗这个操作就可以写成： <img src="https://www.zhihu.com/equation?tex=y_%7Bwindow%7D%28t+-+t_s%29++y%28t%29" alt="[公式]"> 。</p><p>如下两图所示，将 <img src="https://www.zhihu.com/equation?tex=y%28t%29%3Dsin%285t%29" alt="[公式]"> 与 <img src="https://www.zhihu.com/equation?tex=y_%7Bwindow%7D%28t+-+25%29" alt="[公式]"> 相乘，就相当于取出来了 <img src="https://www.zhihu.com/equation?tex=y%28t%29%3Dsin%285t%29" alt="[公式]"> 中的(20,30)中的一段。</p><p>那么，我们对原信号中被提取出来的这一部分进行FT，就可以写成： $X\left(w, t_{s}\right)=\int_{-\infty}^{+\infty} y_{w i n d o w}\left(t-t_{s}\right) y(t) e^{-j w\left(t-t_{s}\right)} d t$</p><p>PS：这里之所以 <img src="https://www.zhihu.com/equation?tex=e%5E%7B-jwt%7D" alt="[公式]"> 要变成 <img src="https://www.zhihu.com/equation?tex=e%5E%7B-jw%28t-t_s%29%7D" alt="[公式]"> ，是为了保证做FT的时候相乘的基函数具有统一性。</p><p>如此，变换后的<img src="https://www.zhihu.com/equation?tex=X%28w%2Ct_s%29" alt="[公式]">代表<strong>原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处、宽度为width的部分的傅里叶变换</strong>，也就可以提取出来<strong>原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处、宽度为width的部分，包含各个频率部分的多少！带入不同的</strong> <img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"> <strong>，也就是随着窗子的滑动，就可以知道不同的时间段内频率的成分。</strong></p><p>我们采用width为10的方窗函数对$y 3=\sin (20 t) <em>(0&lt;t&lt;25)+\sin (t) </em>(25&lt;t&lt;50)$进行STFT，如下：</p><p>首先，方窗函数位于 <img src="https://www.zhihu.com/equation?tex=t+%3D+5s" alt="[公式]"> 处，与原始信号相乘，选择出(0,10)的信号。</p><p><img src="https://pic4.zhimg.com/80/v2-9c184aa29068c665f5ead3439d42cd0b_hd.jpg" alt="img"></p><p>对选择出来的信号进行FT。可以看到，当t=5s时，选择的时间区间为(0,10)，这一部分只包含了 <img src="https://www.zhihu.com/equation?tex=w+%3D+20rad%2Fs" alt="[公式]"> 的频率成分。</p><p><img src="https://pic4.zhimg.com/80/v2-ec4cc9c93dc4d7b763ac5843fd02be8b_hd.jpg" alt="img"></p><p>之后，方窗函数向右移动，与原始信号相乘，选择出不同时间区间的信号，进行FT。这里选择t=25s进行展示。</p><p><img src="https://pic1.zhimg.com/80/v2-6df4bbf241bd086b20e7db05a31cf7d0_hd.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-3bd9b031d41ce1e3349d762e74b850fa_hd.jpg" alt="img"></p><p>可以看到，当t=25s时，选择的时间区间为(20,30)，这一部分即包含了 <img src="https://www.zhihu.com/equation?tex=w+%3D+20rad%2Fs" alt="[公式]"> 的频率成分，也包含了 <img src="https://www.zhihu.com/equation?tex=w+%3D+1rad%2Fs" alt="[公式]"> 的频率成分。</p><p>重复以上过程，我们可以<strong>将方窗函数选择的不同时间区间的信号的FT的结果拼合起来，形成一张三维图</strong>。由此，我们即可知道，<strong>在 <img src="https://www.zhihu.com/equation?tex=%28t_s-width%2F2%2C+t_s%2Bwidth%2F2%29" alt="[公式]"> 的时间区间内，信号具有怎么样的频率成分。</strong></p><p><img src="https://pic4.zhimg.com/80/v2-389958865460686e1d15a0b2f9ddb277_hd.jpg" alt="img"></p><p>通过width = 10的方窗的STFT结果，我们可以知道，对于信号：<img src="https://www.zhihu.com/equation?tex=y3%3Dsin%2820t%29%2A%280%3Ct%3C25%29%2Bsin%28t%29%2A%2825%3Ct%3C50%29" alt="[公式]"> ，在(0,10)、(10,20)时间区间内，具有20rad/s的频率成分；在(20,30)时间区间内，具有1rad/s和20rad/s的频率成分；在(30,40)、(40,50)时间区间内，具有1rad/s的频率成分。</p><p>最后，进行三点重要的讨论。</p><p>第一点，<strong>变换之后的</strong> <img src="https://www.zhihu.com/equation?tex=X%28w%2Ct_s%29" alt="[公式]"> <strong>是一个三维函数，它有两个自变量，</strong> <img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"> <strong>和w。</strong><img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"> 指的是<strong>原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处，</strong>w上一篇文章我们已经讨论过了，就是频率。所以，STFT提取出来的信息就是：<strong>原信号在</strong><img src="https://www.zhihu.com/equation?tex=t+%3D+t_s" alt="[公式]"><strong>处、宽度为width的部分，包含的频率信息。</strong></p><p><strong>原则上讲，可以得到任一<img src="https://www.zhihu.com/equation?tex=+t_s" alt="[公式]">对应的频率成分，如下图。</strong></p><p><img src="https://pic2.zhimg.com/80/v2-dccf7c6b239c4777b934a1c871f86aed_hd.jpg" alt="img"></p><p><strong>但是</strong> <strong><img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"> 是连续的，并不意味着你知道了每个时刻的频率成分，你知道的还只是 <img src="https://www.zhihu.com/equation?tex=%28t_s-width%2F2%2C+t_s%2Bwidth%2F2%29" alt="[公式]">这一段区间内的频率信息。所以一般不需要计算所有的</strong> <img src="https://www.zhihu.com/equation?tex=t_s" alt="[公式]"><strong>，每隔width计算一次即可。</strong></p><p>你或许会想，我<strong>把width缩小一些，不就可以知道更精确的时间范围内的频率了吗？</strong>是的，你的猜想很对！但是，<strong>如此做也会带来一些频域分辨率的问题。</strong>这一点涉及到一些时域分辨率和频域分辨率的知识，我们下一篇文章会着重讲。</p><h4 id="本质变化"><a href="#本质变化" class="headerlink" title="本质变化:"></a>本质变化:</h4><p>第二点，<strong>方窗函数是可以包含入变换基函数内部的，这组成了新的基函数，同时反映了STFT的本质。</strong></p><p>我们来看， 如果定义 <img src="https://www.zhihu.com/equation?tex=%5Cphi+%28t%29+%3D+e%5E%7B-jwt%7D+y_%7Bwindow%7D%28t%29" alt="[公式]"> ，那么<img src="https://www.zhihu.com/equation?tex=%5Cphi+%28t+-+t_s%29+%3D+e%5E%7B-jw%28t-+t_s%29%7D+y_%7Bwindow%7D%28t-+t_s%29" alt="[公式]"></p><p>那么，STFT的公式： <img src="https://www.zhihu.com/equation?tex=X%28w%2Ct_s%29+%3D++%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7Dy_%7Bwindow%7D%28t+-+t_s%29++y%28t%29e%5E%7B-jw%28t-+t_s%29%7Ddt" alt="[公式]"> 就可以写成： <img src="https://www.zhihu.com/equation?tex=X%28w%2C+t_s%29++%3D++%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7Dy%28t%29%5Cphi%28t+-+t_s%29+dt" alt="[公式]"></p><p>我们在上一篇文章里说过，<strong>变换就是将原信号乘上一个基函数，再积分的过程，那么，SDFT的基函数就是 <img src="https://www.zhihu.com/equation?tex=%5Cphi%28t%29+%3D+e%5E%7B-jwt%7D+y_%7Bwindow%7D%28t%29" alt="[公式]"> ！</strong></p><p>Amazing！所以，STFT的本质是什么呢？</p><p><strong>STFT的本质就是将FT的基函数 <img src="https://www.zhihu.com/equation?tex=e%5E%7B-jwt%7D" alt="[公式]"> 乘上一个方窗函数，形成了一个新的基函数<img src="https://www.zhihu.com/equation?tex=%5Cphi%28t%29+%3D+e%5E%7B-jwt%7D+y_%7Bwindow%7D%28t%29" alt="[公式]"> ！</strong>前面说的分窗、截断之类的都是表象，<strong>STFT的本质是基函数的改变！</strong></p><p>那么，为什么STFT的基函数可以用于分窗，而FT的基函数不行呢？我们来看，我用正弦函数sin(5t)表示原来的基函数<img src="https://www.zhihu.com/equation?tex=e%5E%7B-jwt%7D" alt="[公式]"> ，那么FT基函数和STFT基函数如下：</p><p><img src="https://pic4.zhimg.com/80/v2-9fb003e0c1ca9b79cba81b58a6d06003_hd.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-02cb52f656bb597ba81ea90af534044b_hd.jpg" alt="img"></p><p>原因就是：FT的基函数是在时域无限延伸的，因此，无论怎么平移，都是任分布在整个时域的，起不到分窗的作用。<strong>而STFT的基函数只在时域一段不为0，在剩下的时域都是0，因此，STFT的基函数的平移，就相当于自动加了窗子啦！</strong></p><h4 id="紧支撑性"><a href="#紧支撑性" class="headerlink" title="紧支撑性:"></a>紧支撑性:</h4><p><strong>这种只在时域一段不为0，在剩下的时域都是0的性质被称为“紧支撑性”（compactly supported），具有这种性质的函数，平移之后与一个信号相乘，就相当于分窗操作。这一点很重要，我们之后讲小波变换的基函数的时候还会讲。</strong></p><p>第三点，<strong>我们前面对于分窗操作使用的函数一直称为“方窗函数”</strong>，这是一种最理想的窗函数。<strong>还有一些其他的窗函数，比如，汉宁窗、海明窗、高斯窗等</strong>。窗函数本质都是一个窗子而已，原理是一模一样的，上面所有的讨论也都成立，只是这些窗子会让信号稍稍变形一丢丢而已。你就想像方窗函数就是一面平面镜，其他的窗函数就是哈哈镜就行了。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h3><p>Q:为什么要用相对采样时间代替真实采样时间?</p><p>A:原来做傅立叶变换，既需要知道真实采样时间，也需要知道采样数据，用相对采样时间替代真实采样时间之后，只需要知道采样数据。这极大地拓展了傅立叶变换的使用范围。比如，并不是所有傅立叶变换的对象都可以具有真实采样时间。一副图像也是可以傅立叶变换的，但是在图像里，并没有采样时间这个概念，只有0123456这些像素索引值，对图像做傅立叶变换，就是把索引值作为相对采样时间。</p><hr><h2 id="三-短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）"><a href="#三-短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）" class="headerlink" title="三.短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）"></a>三.短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）</h2><p><strong>三、短时傅里叶变换（STFT）的缺点与连续小波变换（CWT）</strong></p><p><strong>1、分辨率问题</strong></p><p>首先，我们需要了解一下海德堡测不准原理： <img src="https://www.zhihu.com/equation?tex=%5CDelta+t%5CDelta+f+%3E+C" alt="\Delta t\Delta f &gt; C"> ， <img src="https://www.zhihu.com/equation?tex=%5CDelta+t" alt="\Delta t"> 为信号的时间不确定度， <img src="https://www.zhihu.com/equation?tex=%5CDelta+f" alt="\Delta f"> 为信号的频率不确定度。即，我们永远<strong>无法同时确定一个信号的确切时间和确切频率。</strong></p><p>原因比较简单，频率其实就是时域周期性。如果我只给你一个数据点，问你这个数据点的频率是多少，这肯定是做不到的。<strong>要确定频率，就需要一个时域区间（包含几个时域周期）的信号。</strong></p><p>时域区间越宽，信号的时间定位越不准，时间不确定度 <img src="https://www.zhihu.com/equation?tex=%5CDelta+t" alt="\Delta t"> 越大，但是得到的频率越准，频率不确定度<img src="https://www.zhihu.com/equation?tex=%5CDelta+f+" alt="\Delta f "> 越小；我们称之为：<strong>低的时域分辨率，高的频域分辨率。</strong></p><p>时域区间越窄，信号的时间定位越准，时间不确定度 <img src="https://www.zhihu.com/equation?tex=%5CDelta+t" alt="\Delta t"> 越小，但是得到的频率越不准，频率不确定度 <img src="https://www.zhihu.com/equation?tex=%5CDelta+f+" alt="\Delta f "> 越大；我们称之为：<strong>高的时域分辨率，低的频域分辨率。</strong></p><p><img src="https://pic4.zhimg.com/80/v2-a6610ab6df91401343647ba4b27363db_hd.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-36716e2b22423bae8d2ff5bcbf796324_hd.jpg" alt="img"></p><p>如上两图，对于第一个图中 <img src="https://www.zhihu.com/equation?tex=sin%280.5t%29" alt="sin(0.5t)"> 的信号，要确定频率，即使把 <img src="https://www.zhihu.com/equation?tex=%280%2C20%29" alt="(0,20)"> 都拿来，还是不太准，因为只包含了一个周期；对于第二个图中 <img src="https://www.zhihu.com/equation?tex=sin%285t%29" alt="sin(5t)"> 的信号，要确定频率，取个 <img src="https://www.zhihu.com/equation?tex=%280%2C5%29" alt="(0,5)"> 就差不多了，因为已经包含了好几个周期了。</p><p>我们来总结一下。</p><p>对于低频信号，为了更好地确定频率，我们希望，时域区间宽一些，即时间不确定度 <img src="https://www.zhihu.com/equation?tex=%5CDelta+t" alt="\Delta t"> 大一些，根据海德堡测不准原理，频率不确定度<img src="https://www.zhihu.com/equation?tex=%5CDelta+f+" alt="\Delta f "> 自然小一些；即<strong>低频信号，我们希望：宽窗子，低的时域分辨率，高的频域分辨率。</strong></p><p>对于高频信号，为了更好地在时域定位，我们希望，时域区间窄一些，即时间不确定度 <img src="https://www.zhihu.com/equation?tex=%5CDelta+t" alt="\Delta t"> 小一些，根据海德堡测不准原理，频率不确定度<img src="https://www.zhihu.com/equation?tex=%5CDelta+f+" alt="\Delta f "> 自然大一些；即<strong>高频信号，我们希望：窄窗子，高的时域分辨率，低的频域分辨率。</strong></p><p><img src="https://pic2.zhimg.com/80/v2-21c6a20541f75b7789039730c3ba9691_hd.jpg" alt="img"></p><p>上图所示是我们希望的动态分辨率。图中每个小矩形的 <img src="https://www.zhihu.com/equation?tex=Time" alt="Time"> 轴方向的宽度是时间区间大小， <img src="https://www.zhihu.com/equation?tex=Frequency" alt="Frequency"> 轴方向的宽度是频率区间大小。注意，每个小矩形的面积是相等的，这保证了时域分辨率乘上频域分辨率是定值，最大程度满足海德堡测不准原理。通过图可以看出，我们希望，<strong>对于低频信号：低的时域分辨率，高的频域分辨率；对于高频信号：高的时域分辨率，低的频域分辨率。</strong></p><p>对于整体低频、局部高频的信号，这种动态调整分辨率的规则特别有用。在实际信号中，频率非常高的高频信号往往是一种噪声，只在局部出现，基本都满足整体低频、局部高频这一条件。</p><p>最后，我们再来看两张分辨率图来强化一下对于分辨率的理解。</p><p><img src="https://pic2.zhimg.com/80/v2-5fcb8ea67c4dd7d0cd8af79cb5cdc561_hd.jpg" alt="img"></p><p>上图是一张采集信号的分辨率图。每个小矩形的 <img src="https://www.zhihu.com/equation?tex=Time" alt="Time"> 轴方向的宽度是很小， <img src="https://www.zhihu.com/equation?tex=Frequency" alt="Frequency">轴方向的宽度很大。也就是说，<strong>其时域分辨率很好，可以确切地确定每个信号采样点的时间，但是其频域分辨率很差，或者说完全不具有频域分辨率。</strong></p><p><img src="https://pic3.zhimg.com/80/v2-dfa64287fea73b71b2fde5acf491b1be_hd.jpg" alt="img"></p><p>上图是一张傅里叶变换（FT）的分辨率图。每个小矩形的 <img src="https://www.zhihu.com/equation?tex=Time" alt="Time"> 轴方向的宽度是很大， <img src="https://www.zhihu.com/equation?tex=Frequency" alt="Frequency"> 轴方向的宽度很小。也就是说，<strong>其频域分辨率很好，可以比较精确地确定信号中的频率成分，但是其时域分辨率很差，或者说完全丢失了时域分辨率。</strong></p><p>傅里叶变换的这一特性，这一点我在上一篇文章里讲过，这也是我们转而使用短时傅里叶变换（STFT）的原因。</p><p><strong>2、短时傅里叶变换（STFT）的缺点</strong></p><p>我们来回忆一下STFT（详见：<a href="https://zhuanlan.zhihu.com/p/66246381" target="_blank" rel="noopener">1335：从傅里叶变换进阶到小波变换（二）</a>），STFT的窗长是固定的，即时域分辨率是固定的，根据海德堡测不准原理，其频域分辨率也是固定的。其分辨率图如下：</p><p><img src="https://pic3.zhimg.com/80/v2-65ff13878c7d01a12deb42e2f3fd0ce6_hd.jpg" alt="img"></p><p>每个小矩形的 <img src="https://www.zhihu.com/equation?tex=Time" alt="Time"> 轴方向的宽度和<img src="https://www.zhihu.com/equation?tex=Frequency" alt="Frequency"> 轴方向的宽度是恒定的！也就是说，不论高频低频，其时域和频域分辨率都不可调，这与我们之前讨论的“对于低频信号：低的时域分辨率，高的频域分辨率；对于高频信号：高的时域分辨率，低的频域分辨率”这一原则不符合。</p><p>这种不符合会带来什么后果呢？</p><p>如图所示正弦信号，0~250ms：300HZ，250~500ms：200HZ ，500~750ms：100HZ ， 750~1000ms：50HZ。</p><p><img src="https://pic4.zhimg.com/80/v2-318f8c13aaeb3d6a2cd468ab8501f99f_hd.jpg" alt="img">)</p><p>选择一个较窄的窗子<img src="https://www.zhihu.com/equation?tex=width+%3D+0.02" alt="width = 0.02"> 做STFT，结果如下：</p><p><img src="https://pic1.zhimg.com/80/v2-69b82763a3aee3f97d70b53c42737734_hd.jpg" alt="img"></p><p>当窗子较窄的时候，STFT的时域分辨率还行，但是频域分辨率不佳。</p><p>我们选择一个宽一些的窗子 <img src="https://www.zhihu.com/equation?tex=width+%3D+0.1" alt="width = 0.1"> 做STFT，结果如下：</p><p><img src="https://pic1.zhimg.com/80/v2-8c698423bfab908971ca6604643ff4f8_hd.jpg" alt="img"></p><p>当窗子较宽的时候，STFT的频域分辨率很好，基本可以确定频率，但是时间轴上开始出现交叠了，也就是时域分辨率下降了。</p><p>我们选择一个更宽的窗子 <img src="https://www.zhihu.com/equation?tex=width+%3D+0.3" alt="width = 0.3"> 做STFT，结果如下：</p><p><img src="https://pic4.zhimg.com/80/v2-acaf61759eb23c708094463a6060f667_hd.jpg" alt="img"></p><p>当窗子更宽的时候，STFT的频域分辨率非常好了，但是时域分辨率已经很差了，时间轴上出现了大规模的交叠现象。</p><p>我们来总结一下，对于STFT，如果窗子的宽度选择合适，是可以得到时域和频域分辨率都“还可以”的结果的（由于STFT的分辨率固定，只能说“还可以”，不能说“满意”，因为我们最想要的是动态分辨率）。但是，在变换之前，我们也不知道选择多宽的窗子是合适的。</p><p>这就是STFT的缺点：<strong>1、时间和频率分辨率都固定，不能随着频率的高低实现动态可调；2、选择一个合适的窗宽十分困难。</strong></p><p><strong>3、连续小波变换（CWT）</strong></p><p>为了实现动态分辨率，我们引入了小波母函数。</p><p>需要说明，小波母函数并不是一个特定的函数，而是一种函数的集合，满足了一定条件的函数均可以作为小波母函数。小波母函数 <img src="https://www.zhihu.com/equation?tex=%5Cpsi%28t%29" alt="\psi(t)"> 需要满足的有：</p><p>条件1，紧支撑性： <img src="https://www.zhihu.com/equation?tex=%5Cexists+a+%3E0+%2C+%5Cforall+%7Ct%7C%3Ea%2C+%5Cpsi%28t%29+%3D+0" alt="\exists a &gt;0 , \forall |t|&gt;a, \psi(t) = 0"> ，即<strong>仅在一小部分定义域里不为0</strong>，剩下部分均为0。这个性质带来的便利我们在前一篇文章讲过了，就是<strong>具有紧支撑性的基函数，在原信号的时间轴上平移，就相当于对于原信号就行了加窗操作。</strong></p><p>条件2，波动性： <img src="https://www.zhihu.com/equation?tex=%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7D%5Cpsi%28t%29+dt+%3D+0" alt="\int_{-\infty}^{+\infty}\psi(t) dt = 0"> ，即在所有定义域内积分值为0，这说明小波母函数是一个波。</p><p>条件3，容许条件： <img src="https://www.zhihu.com/equation?tex=c_%5Cpsi+%3D+2%5Cpi+%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D+%5Cfrac%7B%7C%5Ctilde%7B%5Cpsi%28f%29%7D%7C%5E2%7D%7B%7Cf%7C%7Ddf+%3C+%2B%5Cinfty" alt="c_\psi = 2\pi \int_{-\infty}^{\infty} \frac{|\tilde{\psi(f)}|^2}{|f|}df &lt; +\infty"> ，这个条件使变换可逆。其中， <img src="https://www.zhihu.com/equation?tex=%5Ctilde%7B%5Cpsi%28f%29+%7D" alt="\tilde{\psi(f) }"> 是小波函数傅里叶变换的共轭。由3可知 <img src="https://www.zhihu.com/equation?tex=%5Cpsi%28f%29%7C_%7Bf+%3D+0%7D+%3D+0" alt="\psi(f)|_{f = 0} = 0"> ，也就是条件2。</p><p>条件4，正交性：这个条件也是为了使变换可逆。</p><p>PS：条件3、4的数学证明比较复杂，所以仅仅提了一下他们的作用，就是使得变换可逆。</p><p><img src="https://pic1.zhimg.com/80/v2-6df078be94ca2129af2bba0298599c88_hd.jpg" alt="img"></p><p>上图就是一个小波母函数的例子，我们看到了：</p><p>1、紧支撑性：<strong>仅在一小部分定义域里不为0</strong>，剩下部分均为0；2、波动性： 在所有定义域内积分值为0。这两个条件是满足的。</p><p>小波母函数既然是一个波，那么就具有频率。根据我们第一篇文章讲的内容（<a href="https://zhuanlan.zhihu.com/p/66189212" target="_blank" rel="noopener">1335：从傅里叶变换进阶到小波变换（一）</a>），将小波母函数作为基函数，与采集到的信号相乘并积分，可以筛选出：<strong>信号在小波母函数非0部分，频率与小波母函数相近的成分。</strong></p><p>需要说明，不同于FT的基函数 <img src="https://www.zhihu.com/equation?tex=sin%2Ccos" alt="sin,cos"> ，小波母函数不具有特定的某一频率，而是具有一个范围内的频率，因此筛选的是一定范围的频率，类似于一个带通滤波器。</p><p>接下来我们讲一讲，小波母函数的变换，变换公式如下：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cpsi%5E%2A%28%5Ctau%2C%F0%9D%91%A0%29%3D++%5Cfrac%7B1%7D%7B%5Csqrt%7B%F0%9D%91%A0%7D%7D+%5Cpsi%28%5Cfrac%7B%F0%9D%91%A1%7D%7B%7B%F0%9D%91%A0%7D%7D%E2%88%92%5Ctau%29" alt="\psi^*(\tau,𝑠)=  \frac{1}{\sqrt{𝑠}} \psi(\frac{𝑡}−\tau)"></p><p>一是平移，用上式中的 <img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="\tau"> 控制，<img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="\tau">改变，就相当于 <img src="https://www.zhihu.com/equation?tex=%5Cpsi%28t%29" alt="\psi(t)"> 在时间轴上不断的平移。</p><p>二是缩放，用上式中的 <img src="https://www.zhihu.com/equation?tex=s" alt="s"> 控制。</p><p>变换后的函数 <img src="https://www.zhihu.com/equation?tex=%5Cpsi%5E%2A%28%5Ctau%2C%F0%9D%91%A0%29" alt="\psi^*(\tau,𝑠)"> 称为小波函数。</p><p>如下图，<strong>中间的图，<img src="https://www.zhihu.com/equation?tex=s" alt="s">较小，相当于挤压；右侧的图，</strong> <img src="https://www.zhihu.com/equation?tex=s" alt="s"> <strong>较大，相当于拉伸。</strong>变换公式前的<img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B%5Csqrt+s%7D" alt="\frac{1}{\sqrt s}">是为了能量守恒，没有特别目的。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;948&#39; height=&#39;234&#39;&gt;&lt;/svg" alt="img"></p><p>我们再来仔细观察一下上图。<strong>中间的图，</strong><img src="https://www.zhihu.com/equation?tex=s" alt="s"><strong>较小，相当于挤压，是不是频率提高了？右侧的图，</strong><img src="https://www.zhihu.com/equation?tex=s" alt="s"><strong>较大，相当于拉伸，是不是频率降低了？</strong>咦？有点意思了吧？缩放就是改变频率！另外，<strong>一定记住， <img src="https://www.zhihu.com/equation?tex=s" alt="s"> 越大，频率 <img src="https://www.zhihu.com/equation?tex=f" alt="f"> 越低， <img src="https://www.zhihu.com/equation?tex=s%2Cf" alt="s,f"> 是倒数关系。</strong></p><p>我们再来更仔细地观察一下上图。回忆一下上一篇文章，具有紧支撑性的基函数，滑动相当于分窗。那么，这个窗长有多大呢？是不是就是基函数不为零的长度呢？那么，<strong>中间的图，</strong><img src="https://www.zhihu.com/equation?tex=s" alt="s"><strong>较小，相当于挤压，频率提高了，窗长是不是变小了？右侧的图，</strong><img src="https://www.zhihu.com/equation?tex=s" alt="s"><strong>较大，相当于拉伸，频率降低了，窗长是不是变大了？</strong></p><p>这不正是我们需要的<strong>“低频，宽窗，差的时间分辨率，好的频域分辨率；高频，窄窗，好的时间分辨率，差的频域分辨率”吗？</strong></p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;474&#39; height=&#39;386&#39;&gt;&lt;/svg" alt="img"></p><p>和上图对一下，是不是一模一样了呢？这就是动态调分辨率，得来全不费工夫啊！</p><p>接下来我们对一个信号就行一次连续小波变换（CWT）。下图中蓝色部分为小波函数（但原图没画成波的形式，只是表示小波函数的时间轴位置和不为0的部分的宽度），黄色部分为信号。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;586&#39; height=&#39;496&#39;&gt;&lt;/svg" alt="img">图源：THE WAVELET TUTORIAL</p><p>如上图，选择较小的<img src="https://www.zhihu.com/equation?tex=s" alt="s"> 对小波母函数进行缩放，此时小波函数频率较高，窗子较窄（小波函数不为0的部分窄），用来筛选高频部分。小波函数在时间轴上平移，每一次平移就先相乘，再积分，筛选出信号中与自己频率相近的部分。</p><p>此时，窗子较窄（小波函数不为0的部分窄），时间分辨率好，频率分辨率差。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;587&#39; height=&#39;489&#39;&gt;&lt;/svg" alt="img">图源：THE WAVELET TUTORIAL</p><p>如上图，将<img src="https://www.zhihu.com/equation?tex=s" alt="s"> 增大，对小波母函数进行缩放，此时小波函数频率降低，窗子变宽（小波函数不为0的部分变宽），用来筛选中频部分。小波函数在时间轴上平移，每一次平移就先相乘，再积分，筛选出信号中与自己频率相近的部分。</p><p>此时，窗子变宽了（小波函数不为0的部分变宽），时间分辨率变差，频率分辨率变好。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;587&#39; height=&#39;486&#39;&gt;&lt;/svg" alt="img">图源：THE WAVELET TUTORIAL</p><p>如上图，将<img src="https://www.zhihu.com/equation?tex=s" alt="s"> 进一步增大，对小波母函数进行缩放，此时小波函数频率再次降低，窗子更宽（小波函数不为0的部分更宽），用来筛选低频部分。小波函数在时间轴上平移，每一次平移就先相乘，再积分，筛选出信号中与自己频率相近的部分。</p><p>此时，窗子很宽（小波函数不为0的部分很宽），时间分辨率差，频率分辨率很好。</p><p><strong>这就是连续小波变换CWT啦！</strong></p><p>将上述CWT的过程写成公式就是： <img src="https://www.zhihu.com/equation?tex=CWT_x%5E%5Cpsi+%28%5Ctau%2Cs%29+%3D+%5Cfrac%7B1%7D%7B%5Csqrt%7Bs%7D%7D+%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7Dx%28t%29%5Cpsi%28%5Cfrac%7Bt%7D%7Bs%7D-%5Ctau%29+dt" alt="CWT_x^\psi (\tau,s) = \frac{1}{\sqrt{s}} \int_{-\infty}^{+\infty}x(t)\psi(\frac{t}{s}-\tau) dt"></p><p>注意：上图中我们只列举了三种 <img src="https://www.zhihu.com/equation?tex=s" alt="s"> （即三次缩放）和4种 <img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="\tau"> （每种缩放对应四个时间位置，但是事实上， <img src="https://www.zhihu.com/equation?tex=s%2C%5Ctau" alt="s,\tau"> 是连续的，无穷多个的。</p><p>还是这个正弦信号，0~250ms：300HZ，250~500ms：200HZ ，500~750ms：100HZ ， 750~1000ms：50HZ。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;450&#39;&gt;&lt;/svg" alt="img"></p><p>其小波变换如下图所示（忽略图中坐标，原图如此，坐标不太对，还得映射一下，有空了我自己再画一张改一改）：</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;582&#39; height=&#39;448&#39;&gt;&lt;/svg" alt="img">图源：THE WAVELET TUTORIAL</p><p>我们来看，绿色的小峰，对应小的 <img src="https://www.zhihu.com/equation?tex=s%28scale%29" alt="s(scale)"> ，也就是高的频率。他们的<strong>时间分辨率很好</strong>， <img src="https://www.zhihu.com/equation?tex=s" alt="s"> 的区间很小，根据<img src="https://www.zhihu.com/equation?tex=s%2Cf" alt="s,f"> 的倒数关系，对应的 <img src="https://www.zhihu.com/equation?tex=f" alt="f"> 的区间就很大，因此<strong>频率分辨率不好</strong>。</p><p>粉色的高峰，对应高的<img src="https://www.zhihu.com/equation?tex=s%28scale%29" alt="s(scale)"> ，也就是低的频率， <img src="https://www.zhihu.com/equation?tex=s" alt="s"> 的区间很大，根据<img src="https://www.zhihu.com/equation?tex=s%2Cf" alt="s,f"> 的倒数关系，对应的 <img src="https://www.zhihu.com/equation?tex=f" alt="f"> 的区间就很小，因此<strong>频率分辨率很好，时间分辨率不好（有混叠）。</strong></p><p>这也就再一次说明了CWT是动态分辨率的，这也是CWT相对于STFT的优势所在。</p><p><strong>4、FT、STFT、CWT基函数对比</strong></p><p>最后，再来看看，FT、STFT、CWT的基函数之间的不同，以便加深理解。</p><p><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;508&#39; height=&#39;529&#39;&gt;&lt;/svg" alt="img">图源：百度图片</p><p>FT的基函数，是分布在 <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%2C%2B%5Cinfty%29" alt="(-\infty,+\infty)"> 的 <img src="https://www.zhihu.com/equation?tex=sin%2Ccos" alt="sin,cos">，不具有紧支撑性，只能筛选频率，使得FT完全丧失了时间信息，不具有时间分辨率。</p><p>STFT的基函数，是用窗函数截断的<img src="https://www.zhihu.com/equation?tex=sin%2Ccos" alt="sin,cos"> （图中是被高斯窗截断的），具有了紧支撑性，时域平移等同于分窗，使得STFT既能筛选频率，也能筛选时间。但是STFT基函数是：先确定频率，再与窗函数相乘构成的。因此不同的频率，具有同样的时间和频率分辨率。另外，窗函数的长短也比较难以确定。</p><p>CWT的基函数，是小波函数，具有紧支撑性，时域平移等同于分窗，使得CWT既能筛选频率，也能筛选时间。小波函数在改变频率的时候，是通过<strong>“缩放”</strong>实现的，<strong>这使得小波函数在改变频率的同时，改变了窗长。</strong>因此不同的频率，具有不同的时间和频率分辨率，实现了分辨率动态可调。</p><p>最后，再说一下，有很多类型的小波母函数，比如haar小波，db系列小波，sym系列小波，coif系列小波等等等等。具体哪一个小波适应哪种情况，估计都能写一本书了，我也没深入钻研过。我在利用小波变换做肌电信号识别的时候就是读一读有关肌电信号识别的论文，看看别人试过哪些小波，是一种上手比较快的方法。</p><hr><h2 id="连续小波变换（CWT）的缺点与离散小波变换（DWT）"><a href="#连续小波变换（CWT）的缺点与离散小波变换（DWT）" class="headerlink" title="连续小波变换（CWT）的缺点与离散小波变换（DWT）"></a>连续小波变换（CWT）的缺点与离散小波变换（DWT）</h2><p><strong>四、连续小波变换（CWT）的缺点与离散小波变换（DWT）</strong></p><p><strong>1、连续小波变换（CWT）的缺点</strong></p><p>在上一篇文章（<a href="https://zhuanlan.zhihu.com/p/68323379）中我们讲解了" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68323379）中我们讲解了</a> CWT可以实现动态分辨率的时频分析。CWT公式为：<img src="https://www.zhihu.com/equation?tex=CWT_x%5E%5Cpsi+%28%5Ctau%2Cs%29+%3D+%5Cfrac%7B1%7D%7B%5Csqrt%7Bs%7D%7D+%5Cint_%7B-%5Cinfty%7D%5E%7B%2B%5Cinfty%7Dx%28t%29%5Cpsi%28%5Cfrac%7Bt-%5Ctau%7D%7Bs%7D%29+dt" alt="[公式]">， <img src="https://www.zhihu.com/equation?tex=x%28t%29" alt="[公式]"> 表示原始信号。你可能已经注意到了，这里的 <img src="https://www.zhihu.com/equation?tex=x%28t%29" alt="[公式]"> 是一个<strong>连续函数</strong>。</p><p>但是在第二篇文章（<a href="https://zhuanlan.zhihu.com/p/66246381）中我们讲过，实际采样信号往往具有两个特点：1、**离散性**，就是采集数据不连续，很容易理解，采集信号肯定是一个一个数据采集的；2、**有限性**，虽然理想的CWT是从" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66246381）中我们讲过，实际采样信号往往具有两个特点：1、**离散性**，就是采集数据不连续，很容易理解，采集信号肯定是一个一个数据采集的；2、**有限性**，虽然理想的CWT是从</a> <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%2C%2B%5Cinfty%29" alt="[公式]"> 进行积分的，但是实际信号往往实在一个区间内 <img src="https://www.zhihu.com/equation?tex=%28a%2Cb%29" alt="[公式]"> 的。如下图所示。</p><p>所以，由于CWT需要一个连续信号，但是实际采样信号往往是离散的，我们无法直接对实际信号进行CWT。</p><p>或许你想，我们对实际采样信号进行插值连续化不就可以使得其连续了吗？</p><p>是的。将实际采样信号插值连续化之后，我们——人，是可对它进行CWT的。</p><p>但是，我们也都知道，<strong>我们的帮手——计算机，是无法处理连续问题的</strong>。计算机只能处理离散问题。如果计算机要进行CWT，就意味着需要计算机做无穷次运算，计算机计算能力再强也是做不到的。</p><p>因此，为了使得计算机可以进行小波变换，我们需要引入离散小波变换（DWT）。</p><p><strong>2、离散小波变换（DWT）的Wallet算法</strong></p><p>DWT有很多种实现方式，我们在这里介绍Wallet算法，它是DWT的以一种经典的快速算法，也比较易懂。</p><p>我们首先来回顾一下上一篇文章讲过的动态分辨率图：<strong>高频部分，窄窗，高的时域分辨率，低的频域分辨率；低频部分，宽窗，低的时域分辨率，高的频域分辨率。</strong></p><p>我们是利用小波母函数的挤压和拉伸来实现动态分辨率的：</p><p><strong>当小波母函数被挤压的时候，频率就高，此时窗子窄，时域分辨率就好，根据海森堡测不准原理，频域分辨率就差；</strong></p><p><strong>当小波母函数被拉伸的时候，频率就低，此时窗子宽，时域分辨率就差，根据海森堡测不准原理，频域分辨率就好。</strong></p><p>也就是说，我们<strong>控制的是不同频率对应的窗长（即时域分辨率），频率分辨率是通过海森堡测不准原理得到的，从而达到了动态分辨率</strong>。</p><p>那么，如果我们这次不控制窗长（即时域分辨率），转而控制频域分辨率，能否达到动态分辨率呢？</p><p>答案是可以，这就是Wallet算法要解决的问题。</p><p><strong>半子带滤波</strong></p><p>我们知道，小波母函数本质上是一种带通滤波器。那么，假设可以通过小波母函数构造得到两个滤波器（至于怎么得到后续会介绍一下），包括<strong>一个高通滤波器和一个低通滤波器</strong>。</p><p>假设信号中的最高频率为 <img src="https://www.zhihu.com/equation?tex=Fs" alt="[公式]"> 。那么，高通滤波器的作用就是得到 <img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B2%7D%2CFs%29" alt="[公式]"> 的部分，低通滤波器的作用就是得到 <img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29" alt="[公式]"> 的部分。如下图所示：</p><p>我们将这个过程称为一次<strong>半子带滤波</strong>。</p><p><strong>下采样与上采样</strong></p><p>我们定义一个N倍下采样过程：<strong>将采样点N倍稀释</strong>。如下，就是一个2倍下采样过程，将采样点稀释2倍，即：每2个点采样数据点，就去除一个点。</p><p>N倍上采样过程：<strong>将采样点数量增加N倍</strong>。一般通过补0，或者插值的方法实现上采样。</p><p><strong>离散小波分解</strong></p><p>我们将一次半子带滤波+一次2倍下采样称为一层小波分解。如下图所示，图中的“箭头+2”表示一次2倍下采样。</p><p>假设原采样信号有 N 个点，信号最高频率为 <img src="https://www.zhihu.com/equation?tex=F_s" alt="[公式]"> （根据采样定律， <img src="https://www.zhihu.com/equation?tex=F_s" alt="[公式]"> 为采样频率的一半）。</p><p>经过一次高通滤波后，得到了 <img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B2%7D%2CFs%29" alt="[公式]"> 的部分，也是 N 个点，再经过一次2倍下采样，变成了 $\frac{N}{2}$ 个点，我们将这$\frac{N}{2}$个点称为<strong>小波分解的高频系数</strong>（为什么叫作系数会在后面解释）。</p><p>经过一次低通滤波后，得到了 <img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29" alt="[公式]"> 的部分，也是 N 个点，再经过一次2倍下采样，变成了 $\frac{N}{2}$ 个点，我们将这$\frac{N}{2}$个点称为<strong>小波分解的低频系数</strong>。</p><p>也就是说，<strong>经过一层小波分解的信号，它的总长度加起来，还是</strong> N ，<strong>是不变的</strong>。</p><p>现在，我们已经对 <img src="https://www.zhihu.com/equation?tex=%280%2CFs%29%2CN" alt="[公式]"> 个点的原信号进行了第一层小波分解，得到了<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B2%7D%2CFs%29%2C%5Cfrac%7BN%7D%7B2%7D" alt="[公式]">个点的高频系数和<img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29%2C%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> 个点的低频系数。</p><p>那么，我们<strong>保持 <img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B2%7D%2CFs%29%2C%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> 个点的高频系数不变</strong>，把<img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B2%7D%29%2C%5Cfrac%7BN%7D%7B2%7D" alt="[公式]"> 个点的低频系数作为信号，再进行一次小波分解。于是可以得到 <img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B4%7D%2C%5Cfrac%7BFs%7D%7B2%7D%29%2C%5Cfrac%7BN%7D%7B4%7D" alt="[公式]"> 个点的高频系数和 <img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B4%7D%29%2C%5Cfrac%7BN%7D%7B4%7D" alt="[公式]">个点的低频系数。</p><p>这个过程被称为<strong>第2层小波分解。</strong>我们验证一下，经过2层小波分解的信号，它的总长度加起来，还是N ，是不变的。</p><p>依此类推，我们可以进行第三层，第四层小波分解，如图所示，直到第 <img src="https://www.zhihu.com/equation?tex=log_2N" alt="[公式]"> 层小波分解。在第 <img src="https://www.zhihu.com/equation?tex=log_2N" alt="[公式]"> 层小波分解，由于不断的下采样，低频系数和高频系数都只剩1个数了，小波分解无法进行下去了。</p><p>因此，小波分解的原始信号个数一般也需要是<strong>2的幂次</strong>。不过，在各种数学计算软件里，如果输入不是2的幂次，它会自动帮你补零到2的幂次。</p><p>我们取4层小波分解的结果来看一下。</p><p>在频域上，我们得到的是 <img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B2%7D%2CFs%29" alt="[公式]"> ，<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B4%7D%2C%5Cfrac%7BFs%7D%7B2%7D%29" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B8%7D%2C%5Cfrac%7BFs%7D%7B4%7D%29" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B16%7D%2C%5Cfrac%7BFs%7D%7B8%7D%29" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B16%7D%29" alt="[公式]">频域区间的系数。</p><p>在时域上，由于不断的2倍下采样，不断地丢弃数据，所以最后一层分解得到的<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B16%7D%2C%5Cfrac%7BFs%7D%7B8%7D%29" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=%280%2C%5Cfrac%7BFs%7D%7B16%7D%29" alt="[公式]">的时域分辨率最差，第一层分解保留的<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7BFs%7D%7B2%7D%2CFs%29" alt="[公式]"> 时域分辨率最好。</p><p>那么，我们得到的分辨率就是这样子的：</p><p>这，不就是上一篇文章我们讲过的小波变换得到的动态分辨率吗？</p><p>是的！这就是离散小波变换的快速算法之一——Wallet算法，<strong>通过不断的半子带滤波和下采样，控制不同频率成分的频域分辨率，进而达到动态分辨率。</strong></p><p>最后，用一张比较经典的图，再来演示一下小波分解的过程。 <img src="https://www.zhihu.com/equation?tex=%5Cpi" alt="[公式]"> 为采样信号的最高频率。 <img src="https://www.zhihu.com/equation?tex=g%28n%29" alt="[公式]">代表高通滤波器， <img src="https://www.zhihu.com/equation?tex=h%28n%29" alt="[公式]"> 代表低通滤波器，“箭头+2”表示2倍下采样。</p><p>图源：THE WAVELET TUTORIAL</p><p>再来举个例子形象地说明一下DWT的使用吧。</p><p>希望对于一个采样率为1000HZ的非稳态信号进行小波分解，下图为包含了256个采样点（即256ms）的原始采样信号。</p><p>1、首先，选择小波分解的层次。</p><p>可以根据<strong>对最低频率区间的要求</strong>来选择小波分解的层数。比如，我之前做项目的时候，采样率为1000HZ，那么信号的最高频率为 <img src="https://www.zhihu.com/equation?tex=F_s+%3D+500HZ" alt="[公式]"> 。我认为对于频率低于20HZ的成分，不需要再进一步区分了。因此，我选择５层小波分解，得到的最低一层的频率区间为 <img src="https://www.zhihu.com/equation?tex=%280%2CF_S%2F2%5E5%29" alt="[公式]"> ，即为 <img src="https://www.zhihu.com/equation?tex=%280%2C16%29HZ" alt="[公式]"> ，这就够用了。</p><p>2、接下来，进行5层小波分解，得到小波分解系数。</p><p>如下图中，图1依然是原始采样信号 ，图2到图6为第1层到第5层小波分解的高频系数，图7为第5层小波分解的低频系数。如图所示，这些小波分解系数对应着不同的频率区间。</p><p>这就是DWT了，又称为小波分解。</p><p>这里提一下，小波分解是可逆的，即可以通过不同频率区间的小波分解系数进行重构，得到不同频率区间的<strong>重构信号</strong>。</p><p>3、所以，最后，进行小波重构，得到重构信号。</p><p>如下图中，图1依然是原始采样信号，图2到图7为通过不同频率区间的小波系数进行重构，得到的重构信号。将图2到图7加起来就可以得到重构原始信号，其和原始采样信号的误差称为重构误差。</p><p><strong>3、Wallet算法背后的数学原理简介</strong></p><p>这一部分主要是为了解答上一部分中的两个问题。</p><p>1、在上一部分，我们“假设可以通过小波母函数构造得到两个滤波器”，那么，怎么得到刚好可以具有以上特性的滤波器呢？</p><p>2、在上一部分，我们将小波分解之后的结果称为“系数”，那么，为什么称为系数呢？</p><p>先说一下，这部分我不是弄得非常懂，毕竟我只是个做工程的本科生，不是做数学的大佬。我凭自己的理解写一写大概，并推荐了两篇个人觉得讲得很好的回答。</p><p>我们用Haar小波做例子。</p><p>首先，介绍一个Haar尺度函数（又称为父小波），记为 <img src="https://www.zhihu.com/equation?tex=%5Cphi%28x%29" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=%5Cphi%28x%29+%3D+1%2A+%280+%5Cleq+x%3C1%29+" alt="[公式]">，如下图。</p><p>通过Haar尺度函数 <img src="https://www.zhihu.com/equation?tex=%5Cphi%28x%29" alt="[公式]"> ，可以得到Haar母小波 <img src="https://www.zhihu.com/equation?tex=%5Cpsi%28x%29" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=%5Cpsi%28x%29+%3D+%5Cphi%282x%29+-+%5Cphi%282x-1%29" alt="[公式]">，如下图。</p><p>现在，对于一个 N 点的原始采样信号，如果我们可以用 N 个<strong>做了时域平移</strong>的Haar尺度函数和 N 个<strong>做了时域平移</strong>的Haar母小波，来逼近原信号，就可以得到用 N 个Haar尺度函数的系数和 N 个Haar母小波的系数。</p><p>从直观上看，Haar尺度函数只是一条线，而Haar母小波则是一个波。所以，Haar母小波所能表示出来的信息应该更加细致。因此，N 个Haar母小波组合起来，应该代表的是原始信号的细节部分，也就是高频部分；N 个Haar尺度函数组合起来，代表的是原始信号的粗略部分，也就是低频部分。</p><p>我们将N 个Haar母小波的系数称为高频系数，将N 个Haar尺度函数的系数称为低频系数。</p><p>所以，<strong>DWT的滤波功能，是通过利用尺度函数和母小波重构信号，获取重构系数来获得的</strong>，这已经定性地解决了本部分提出的问题。</p><p>关于DWT背后的数学原理，推荐两篇回答：</p><p><a href="https://zhuanlan.zhihu.com/p/28575472" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28575472</a></p><p><a href="https://zhuanlan.zhihu.com/p/44217268" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44217268</a></p><p>最后，由于DWT分解得到的是高频系数和低频系数，也就是用尺度函数以及母小波表示原信号的时候的一些重构系数，所以通过重构系数可以重构该信号，这被称为<strong>小波分解的重构。</strong>这也说明了小波分解是可逆的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;傅里叶变换-gt-小波变化&quot;&gt;&lt;a href=&quot;#傅里叶变换-gt-小波变化&quot; class=&quot;headerlink&quot; title=&quot;傅里叶变换-&amp;gt;小波变化&quot;&gt;&lt;/a&gt;傅里叶变换-&amp;gt;小波变化&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;声明:文中大多数内容来
      
    
    </summary>
    
    
      <category term="信号处理" scheme="https://nymrli.top/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Vim记忆</title>
    <link href="https://nymrli.top/2019/07/26/Vim%E8%AE%B0%E5%BF%86/"/>
    <id>https://nymrli.top/2019/07/26/Vim记忆/</id>
    <published>2019-07-26T02:34:34.000Z</published>
    <updated>2019-07-26T02:44:56.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VIM记忆技巧"><a href="#VIM记忆技巧" class="headerlink" title="VIM记忆技巧"></a>VIM记忆技巧</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><ul><li>i(insert)</li><li>I最前面insert</li><li>a(append)</li><li>A最后面append</li><li>o(open a line)往下开启一行</li><li>O往上开启一行</li></ul><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><ul><li>d（delete）</li><li>dw（delet word）</li><li>dd（删除一行）</li><li>x（删除一个字符）</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li>diw(delete inner word)</li><li>daw(delete around word)</li></ul><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><ul><li>c（change）</li><li>ciw（change inner word）</li><li>ci”(change inner “)</li><li>ct）修改到右括号</li></ul><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><ul><li>fs(find s) 跳到本行第一个s字符</li><li><code>/</code>往后查找,如/xxx 全文搜索xxx<ul><li><code>;</code>查找下一个</li></ul></li><li><code>?</code>往前查找</li></ul><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><ul><li>h←</li><li>j↓</li><li>k↑</li><li><p>l→</p></li><li><p>w(word)往后跳一个单词</p></li><li><p>b(back word)往前返回一个单词</p><ul><li>以空格为界区分单词</li></ul></li><li>行间跳转<ul><li><code>:18</code> 跳转到第18行</li><li><code>18G</code> 跳转到第18行</li></ul></li><li>行内跳转:<ul><li><code>0</code>行首</li><li><code>$</code>行尾</li></ul></li><li><code>ctrl+o</code>返回上一个位置</li><li><code>G</code>文件结尾</li><li><code>gg</code>文件开头</li><li><code>ctrl+f</code>(forward)往后翻页</li><li><code>ctrl+u</code>(upward)往前翻页</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VIM记忆技巧&quot;&gt;&lt;a href=&quot;#VIM记忆技巧&quot; class=&quot;headerlink&quot; title=&quot;VIM记忆技巧&quot;&gt;&lt;/a&gt;VIM记忆技巧&lt;/h1&gt;&lt;h2 id=&quot;增&quot;&gt;&lt;a href=&quot;#增&quot; class=&quot;headerlink&quot; title=&quot;增&quot;&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://nymrli.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用</title>
    <link href="https://nymrli.top/2019/07/25/Docker%E4%BD%BF%E7%94%A8/"/>
    <id>https://nymrli.top/2019/07/25/Docker使用/</id>
    <published>2019-07-25T02:58:19.000Z</published>
    <updated>2019-08-22T12:32:55.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h1><blockquote><p>轻部署,省成本,易迁移</p></blockquote><h2 id="docker和虚拟机VM的区别"><a href="#docker和虚拟机VM的区别" class="headerlink" title="docker和虚拟机VM的区别"></a>docker和虚拟机VM的区别</h2><h3 id="一、本质上的区别："><a href="#一、本质上的区别：" class="headerlink" title="一、本质上的区别："></a>一、本质上的区别：</h3><p><img src="https://img-blog.csdn.net/20180711090727241?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmd6aHVuYmlhbmNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用；</p><p>Container(Docker容器)，在宿主机器、宿主机器操作系统上创建Docker引擎，在引擎的基础上再安装应用。</p><p>那么问题来了，没有操作系统，怎么运行程序？</p><p>可以在Docker中创建一个ubuntu的镜像文件，这样就能将ubuntu系统集成到Docker中，运行的应用就都是ubuntu的应用。</p><h3 id="二、使用上的区别："><a href="#二、使用上的区别：" class="headerlink" title="二、使用上的区别："></a>二、使用上的区别：</h3><p><img src="https://img-blog.csdn.net/20180711094611205?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmd6aHVuYmlhbmNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>Size:</p><ul><li>虚拟机ubuntu大小为:24.1GB</li><li>Docker中镜像文件占用内存: 81.2MB</li></ul><p>Startup：</p><ul><li>Docker在宿主机器的操作系统上创建Docker引擎，直接在宿主主机的操作系统上调用硬件资源，而不是虚拟化操作系统和硬件资源，所以操作速度快。</li><li>这个其实安装一个ubuntu的虚拟机和拉取一个Docker的ubuntu镜像文件，运行一下就知道了，区别很明显，虚拟机开一下大概得2分多钟，而Docker只需要2秒钟。</li></ul><h2 id="宿主机、镜像与容器"><a href="#宿主机、镜像与容器" class="headerlink" title="宿主机、镜像与容器"></a>宿主机、镜像与容器</h2><p>宿主机器: 运行docker的机器</p><p>镜像:不可以修改内容</p><p>容器:可以修改能内容,相当于虚拟机,默认情况下彼此相互独立（容器之间可以通信）</p><p>△.可以依据镜像来创建容器,也可以封装容器为一个镜像,即<strong>容器&lt;===&gt;镜像</strong></p><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><p>搜索镜像: <code>docker search python</code></p><p>下载镜像: <code>docker pull NAME</code></p><p>创新容器: <code>docker run -tid  (--name xxx)  IMAGE ID</code></p><ul><li><code>ti</code>表示以交互的形式创建容器，<code>d</code>表示不进入<ul><li><code>-d, --detach=false</code>， 指定容器运行于前台还是后台，默认为false</li><li><code>-i, --interactive=false</code>， 打开STDIN，用于控制台交互</li><li><code>-t, --tty=false</code>， 分配tty设备，该可以支持终端登录，默认为false</li></ul></li></ul><p>运行容器: <code>docker start CONTAINER_ID</code>  </p><p>进入容器： <code>docker attach CONTAINER_ID</code></p><ul><li>进入容器前得前运行容器</li></ul><p>退出容器： <code>ctrl + p + q</code> , 以<code>ctrl + z</code> 、<code>exit</code>将会终止容器运行</p><p>封装容器为镜像: <code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a :提交的镜像作者；</span><br><span class="line">-c :使用Dockerfile指令来创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line">-p :在commit时，将容器暂停。</span><br></pre></td></tr></table></figure><p>容器通信-创建子节点链接中心节点: <code>docker run -tid  (--name xxx)  (--link CONTAINER_NAMES) IMAGE ID</code></p><p>查看容器ip: <code>cat /ect/hosts</code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@b68943564e76:/# cat /etc/hosts </span><br><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">ff00::0ip6-mcastprefix</span><br><span class="line">ff02::1ip6-allnodes</span><br><span class="line">ff02::2ip6-allrouters</span><br><span class="line">172.17.0.2test 4e02c004539e</span><br><span class="line">172.17.0.3b68943564e76</span><br></pre></td></tr></table></figure><p>▲初次使用,  <code>ifconfig</code>使用无效,<code>ping</code>也无效,原因如下</p><blockquote><p>我创建的容器是拉取的Base镜像，而因为用Docker拉取的<strong>Base镜像</strong>如Centos和Ubuntu的话都是<strong>最简版本</strong>，不包含Ping工具，而对Docker进行Docker network和Docker链接操作时往往要用到Ping工具测试两个容器间的网络，此时就要用到Ping工具了，下面是Ubuntu下安装Ping工具的命令：<code>apt-get update &amp;&amp; apt-get install iputils-ping</code>、安装ifconfig工具:<code>apt install net-tools</code></p></blockquote><p><strong>从容器里面拷文件到宿主机</strong></p><p> docker cp 容器名：要拷贝的文件在容器里面的路径       要拷贝到宿主机的相应路径 </p><p>宿主机上执行:<code>$ docker cp testtomcat：/usr/local/tomcat/webapps/test/js/test.js /opt</code></p><p><strong>从宿主机拷文件到docker容器里面</strong></p><p> docker cp 要拷贝的文件路径 容器名：要拷贝到容器里面对应的路径</p><p>宿主机上执行<code>$ docker cp requirements.txt apptest:/app</code></p><p>▲注:容器NAME可以通过<code>docker ps</code>命令查看</p><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><blockquote><p>Dockerfile文件D一定要大写</p><p><code>$ docker build -t=&quot;dormanctpress/df_test2&quot; .</code></p><ul><li>.为Dockerfile的路径</li></ul></blockquote><p>1.<code>FROM &lt;image&gt;:&lt;tag&gt;</code></p><p>2.MAINTAINER</p><p>3.RUN</p><ul><li>镜像构建中运行的命令</li></ul><p>4.EXPOSE</p><ul><li>如果是端口的话，只是声明会使用xx端口,但是实际使用时还是需要run -p xx    <code>$ docker build -t=&quot;dormanctpress/df_test2&quot; .</code></li><li>设置环境变量</li></ul><p>CMD</p><ul><li>在容器运行时运行的默认命令(命令行中添加的命令可以代替掉Dokcerfile中写的CMD指令)</li><li>每个Dockerfile只能够包含一个CMD，多个CMD 只有最后一个能有效</li><li>定义的三种方式<ul><li>CMD<cmd>这个会当做/bin/sh-c“cmd”来执行</cmd></li><li>CMD[“executable”，”arg1”，”arg2”]<ul><li>一定要双引号</li></ul></li><li>CMD[“arg1”，”arg2”]，这个时候CMD作为ENTRYPOINT的参数</li></ul></li></ul><p>ENTRYPOINT</p><ul><li><p>每个Dockerfile只能够包含一个ENTRYPOINI，多个ENTRYPOINT只有最后一个能有效</p></li><li><p>不会像CMD命令一样被覆盖,除非使用<code></code></p></li><li>当定义了ENTRYPOINT后,CMD将被作为参数使用。如果定义了CMD，那么<code>docker run -t test/osf2 xxxx</code>后面即xxxx的内容全会被当做参数传递ENTRYPOINT</li></ul><p>组合使用ENTRYPOINT和CMD: ENTRYPOINT指定命令,CMD指定默认参数</p><p>ADD&amp;COPY</p><p>共同点</p><ul><li><p>ADD&amp;COPY的源必须在context路径下</p></li><li><p>当在源代码构建的方式下，可以通过ADD和COPY的方式，把Host上的文件或者目录复制到Image</p><p>ADD</p></li><li><p>包含类似tar解压的功能</p></li><li><p>当src为网络URL的情况下，ADD指令可以把它下载到Dest的指定位置，这个在任何build的方式下都可以Work</p></li></ul><p>COPY</p><ul><li>如果单纯复制文件,Docker推荐COPY</li><li>ADD&amp;COPY的源必须在context路径下</li><li>当在源代码构建的方式下，可以通过ADD和COPY的方式，把Host上的文件或者目录复制到Image</li></ul><p>VOLUME[‘/data’]</p><ul><li>设置数据卷</li></ul><p>WORKDIR /path/to/workdir</p><ul><li>一般使用绝对路径</li></ul><p>ENV <key> <value></value></key></p><ul><li>用来设置环境变量，后续的RUN可以使用它所创建的环境变量。</li><li>当创建基于该镜像的Container的时候，会自动拥有设置的环境变量</li></ul><p>USER daemon</p><ul><li><p>指定UID或者username，来决定运行RUN指令的用户</p></li><li><p>如果不指定,则默认root</p></li></ul><p>ONBUILD</p><ul><li>触发器</li></ul><h3 id="dockerfile构建过程"><a href="#dockerfile构建过程" class="headerlink" title="dockerfile构建过程"></a>dockerfile构建过程</h3><ol><li>从基础镜像运行一个容器</li><li>执行一条指令，对容器做出修改</li><li>执行类似docker commit的操作，提交一个新的镜像层</li><li>再基于刚提交的镜像运行一个新容器</li><li>执行Dockerfile中的下一条指令，直至所有指令执行完毕</li></ol><h3 id="使用中间层镜像进行调试"><a href="#使用中间层镜像进行调试" class="headerlink" title="使用中间层镜像进行调试"></a>使用中间层镜像进行调试</h3><p>查找错误</p><h3 id="Dockerfile-镜像缓存"><a href="#Dockerfile-镜像缓存" class="headerlink" title="Dockerfile 镜像缓存"></a>Dockerfile 镜像缓存</h3><p>构建缓存：将之前的镜像缓存</p><p>不使用缓存<code>docker build --no-cache</code></p><h3 id="查看镜像构建的过程"><a href="#查看镜像构建的过程" class="headerlink" title="查看镜像构建的过程"></a>查看镜像构建的过程</h3><p>查看构建过程:<code>docker history xxx/yyy</code></p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>sudo docker run -v ~/container_data:/data -it ubuntu /bin/bash</code></p><p>参数说明:使用-v选项,第一个参数为宿主机目录,:后的目录为在容器中使用的目录(挂载);ubuntu为镜像</p><h3 id="查看容器是否挂载了数据卷"><a href="#查看容器是否挂载了数据卷" class="headerlink" title="查看容器是否挂载了数据卷"></a>查看容器是否挂载了数据卷</h3><p><code>docker inspect CONTAINER_ID</code>可以查看容器是否挂载了数据卷</p><h3 id="给数据卷增加权限"><a href="#给数据卷增加权限" class="headerlink" title="给数据卷增加权限"></a>给数据卷增加权限</h3><p><code>sudo docker run -v ~/datavolume:/data:ro -it ubuntu/bin/bash</code></p><p>ro是read-only</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><blockquote><p>命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器</p></blockquote><p>挂载数据卷容器的方法</p><p><code>docker run--volumes-from [CONTAINER NAME]</code></p><h2 id="MySQL通信"><a href="#MySQL通信" class="headerlink" title="MySQL通信"></a>MySQL通信</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; can<span class="string">'t connect to MySQL server on '</span>172.17.0.8<span class="string">'(111)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/mvsal/my.cnf </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将<span class="built_in">bind</span>-address=127.0.0.1注释掉</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Host <span class="string">'2eaf92ef2ff6'</span>is not allowed to connect to this MySQL server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> create user <span class="string">"weiwei"</span>@<span class="string">"%"</span>identified by<span class="string">"weijc7789"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grant create, select, update, delete, insert on *.* to weiwei;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增添权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysq1-h 172.17.0.8-u weiwei-p</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 链接</span></span><br></pre></td></tr></table></figure><h2 id="redis通信"><a href="#redis通信" class="headerlink" title="redis通信"></a>redis通信</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 172.17.0.8</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Could not connect to Redis at 172.17.0.8:6379:Connection refused</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/redis /redis.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将<span class="built_in">bind</span>-address=127.0.0.1注释掉</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果修改后/ect/init.d/redis-server restart后还是链接不了,重启进入容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli-h 172.17.0.8-p 6379</span></span><br></pre></td></tr></table></figure><p>一条命令实现停用并删除容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>一条命令删除所有镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi `docker images -q`</span><br></pre></td></tr></table></figure><p>一条命令删除创建失败的镜像:</p><p><code>docker images | sed -n &#39;2p&#39; | awk &#39;{print$3}&#39; | xargs docker rmi</code></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Dockerfile-RUN，CMD，ENTRYPOINT命令区别"><a href="#Dockerfile-RUN，CMD，ENTRYPOINT命令区别" class="headerlink" title="Dockerfile RUN，CMD，ENTRYPOINT命令区别"></a>Dockerfile RUN，CMD，ENTRYPOINT命令区别</h3><blockquote><p>RUN命令执行命令并创建新的镜像层，通常用于安装软件包</p><p>CMD命令设置容器启动后默认执行的命令及其参数，但CMD设置的命令能够被<code>docker run</code>命令后面的命令行参数替换</p><p>ENTRYPOINT配置容器启动时的执行命令（不会被忽略，一定会被执行，即使运行 <code>docker run</code>时指定了其他命令）</p></blockquote><p>Shell格式和Exec格式运行命令</p><p>我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式：</p><ul><li>Shell格式：<instruction> <command>。例如：apt-get install python3<ul><li>多条命令用&amp;&amp;链接</li></ul></instruction></li><li>Exec格式：<instruction> [“executable”, “param1”, “param2”, …]。例如： [“apt-get”, “install”, “python3”]</instruction></li></ul><p><strong>CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。</strong></p><p>### </p><p><strong>总结</strong></p><ul><li>使用 RUN 指令安装应用和软件包，构建镜像。</li><li>如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。</li><li>如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。</li></ul><hr><h3 id="Docker-运行python-flask的web程序"><a href="#Docker-运行python-flask的web程序" class="headerlink" title="Docker 运行python flask的web程序"></a>Docker 运行python flask的web程序</h3><h4 id="1创建镜像"><a href="#1创建镜像" class="headerlink" title="1创建镜像"></a>1创建镜像</h4><h5 id="1-1-ubuntu16-04-python3-6"><a href="#1-1-ubuntu16-04-python3-6" class="headerlink" title="1.1 ubuntu16.04+python3.6"></a>1.1 ubuntu16.04+python3.6</h5><blockquote><p>18.04卡在了PPA环节,并且git安装也没安装上,后来使用了<a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">dockerHub</a>上搜素到的github仓库中的<a href="https://github.com/tianon/docker-brew-ubuntu-core/tree/105329f5da5f205e3d2bcb1f96ce32a472e56239/xenial" target="_blank" rel="noopener">16.04 Xenial</a>就解决了。</p><p>注：<strong>镜像TAG版本需要到dockerHub上才能查看，最初下载成18.04就是因为这个原因被坑了</strong></p><p>18.04PPA问题:</p><p><code>aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Ubuntu/bionic</code>意思是18.04该PPA没有资源.bionic是<a href="#附Uuntu版本代号:">版本代号</a>,如16.04的  Xenial</p></blockquote><p>⑴使用下载好的Xenial的Dockerfile进行创建镜像<code>docker run 1604ubuntu .</code></p><p>为了使用国内源用阿里云，先编辑一个sources.list，放在dokcerfile同目录下，作为docker创建镜像时的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><p>⑵根据官方的镜像来编写自己的Dockerfile创建具有工具的Ubuntu1604</p><blockquote><p>涉及交互式选择项（如下），docker build的时候会报错。设置 DEBIAN_FRONTEND=noninteractive</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">FROM 1604ubuntu</span><br><span class="line">MAINTAINER mrli</span><br><span class="line">#用ubuntu国内源替换默认源</span><br><span class="line">RUN rm /etc/apt/sources.list</span><br><span class="line">COPY sources.list /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">#安装python3.6必要的包。源镜像太精简了，ip ifconfig之类的都没有。后续安装python pip也需要一些。但是build_essential似乎不必须，先去了。如果后面安装numpy之类需要gcc了，再加上</span><br><span class="line">RUN apt update</span><br><span class="line">#RUN apt upgrade</span><br><span class="line"></span><br><span class="line">RUN apt install -y apt-utils apt-transport-https  vim iproute2 net-tools ca-certificates curl build-essential wget python-software-properties software-properties-common psmisc</span><br><span class="line"></span><br><span class="line">#安装python3.6 来自第三方</span><br><span class="line">RUN add-apt-repository ppa:jonathonf/python-3.6</span><br><span class="line">RUN apt update</span><br><span class="line">RUN apt install -y python3.6</span><br><span class="line">RUN apt install -y python3.6-dev</span><br><span class="line">RUN apt install -y python3.6-venv</span><br><span class="line"></span><br><span class="line">#为3.6安装pip</span><br><span class="line">RUN wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">RUN python3.6 get-pip.py</span><br><span class="line"></span><br><span class="line">#设置默认python为python3</span><br><span class="line">RUN update-alternatives --install /usr/bin/python python /usr/bin/python2 100</span><br><span class="line">RUN update-alternatives --install /usr/bin/python python /usr/bin/python3 150</span><br><span class="line"></span><br><span class="line">#和自带的3.5共存,设置python3默认为3.6</span><br><span class="line">#RUN update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.5 1</span><br><span class="line">RUN update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.6 2</span><br><span class="line"></span><br><span class="line"># 更新配置</span><br><span class="line">RUN update-alternatives --config python3</span><br><span class="line">#print()时在控制台正常显示中文</span><br><span class="line">ENV PYTHONIOENCODING=utf-8</span><br></pre></td></tr></table></figure><p>在dockerfile所在路径下执行，建立image</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t uos:1604 .</span><br></pre></td></tr></table></figure><p>因为开头几步用了国内源，所以非常快。</p><h5 id="1-2-开发环境"><a href="#1-2-开发环境" class="headerlink" title="1.2 开发环境"></a>1.2 开发环境</h5><p>再建一个dockerfile，开头使用刚才建立的镜像uos1604</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FROM uos:1604</span><br><span class="line">MAINTAINER mrli</span><br><span class="line"></span><br><span class="line">#代码复制过来后的路径</span><br><span class="line">RUN mkdir /app</span><br><span class="line"># 指定容器启动时执行的命令都在app目录下执行</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 将本地app目录下的内容拷贝到容器的app目录下</span><br><span class="line">COPY ./app/ /app/</span><br><span class="line"></span><br><span class="line"># 安装nginx</span><br><span class="line">RUN apt -y install nginx mysql-server </span><br><span class="line"></span><br><span class="line">RUN /etc/init.d/nginx start</span><br><span class="line"># 替换nginx的配置</span><br><span class="line">RUN rm  /etc/nginx/sites-enabled/default</span><br><span class="line">RUN cp nginx.conf /etc/nginx/sites-enabled/nginx.conf</span><br><span class="line"></span><br><span class="line">RUN pip3 install uwsgi</span><br><span class="line"></span><br><span class="line">#安装需要的python库</span><br><span class="line"># 启动nginx和uwsgi</span><br><span class="line">#ENTRYPOINT pip install -r requirements.txt  -i  https://pypi.tuna.tsinghua.edu.cn/simple some-package --no-cache-dir &amp;&amp; service nginx restart &amp;&amp; uwsgi --ini uwsgi.ini</span><br><span class="line"></span><br><span class="line"># 为了保证能之后进入所以最后一个命令为/bin/sh</span><br><span class="line">ENTRYPOINT pip install -r requirements.txt  -i  https://pypi.tuna.tsinghua.edu.cn/simple some-package --no-cache-dir &amp;&amp; service nginx restart &amp;&amp; uwsgi --ini uwsgi.ini &amp; &amp;&amp; /bin/sh</span><br></pre></td></tr></table></figure><p>创建uflask镜像:<code>docker build -t uflask .</code></p><p><a href="#2启动容器">根据镜像创建运行容器</a>:<code>docker run -tid -p 12345:80 flaskdemo IMAGE_ID</code></p><p>此时就可以通过<code>VPS的IP地址:宿主机端口</code>访问这个应用程序</p><p>查看日志:<code>docker logs 应用名(NAMES)</code>如<code>docker logs flaskdemo</code></p><h5 id="关于mysql的建议"><a href="#关于mysql的建议" class="headerlink" title="关于mysql的建议"></a>关于mysql的建议</h5><blockquote><p>mysql建议作为单独容器来跑数据库,然后远程连接数据库.或是使用数据卷</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line"># 搜索</span><br><span class="line"># docker search mysql</span><br><span class="line"># 拉取</span><br><span class="line"># docker pull mysql:5.7</span><br><span class="line">#运行</span><br><span class="line"># docker run --name mysql5.7 -e MYSQL_ROOT_PASSWORD=123456 -p 3307:3306 -d mysql:5.7</span><br></pre></td></tr></table></figure><h4 id="2启动容器-转"><a href="#2启动容器-转" class="headerlink" title="2启动容器(转)"></a>2启动容器(转)</h4><ul><li><p>Docker</p><p>一种开源容器应用，供开发者打包自己的开发环境，可以任意移植</p></li></ul><ul><li>docker-compose<br>一种管理多个Docker容器的工具，可以简化我们启动容器的各种命令</li></ul><h5 id="2-1手动敲docker命令"><a href="#2-1手动敲docker命令" class="headerlink" title="2.1手动敲docker命令"></a>2.1手动敲docker命令</h5><p>先试试用docker命令行启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name quotation_api -itd -p 5000:5000 -v /home/quotation:/code quotation_dev:latest</span><br></pre></td></tr></table></figure><p>用到的参数分别是</p><blockquote><p>–name为容器命名；</p><p>-itd  输入输出终端，后台运行</p><p>-p   host端口:容器端口</p><ul><li>将宿主机5000端口的请求转发到容器5000端口,用5000是flask默认</li></ul><p>-v  host路径:容器内路径(挂载数据卷)</p><p>quotation_dev:latest 最后是使用的镜像名（前面刚用dockerfile build出来的）</p></blockquote><p>然后进入容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach quotation_api</span><br></pre></td></tr></table></figure><p>用python3 main.py启动flask，OK。</p><p>这样flask运行在docker里了。</p><p>在host改代码，可以看见docker的控制台在更新，和在host一样了。(使用数据卷)</p><h5 id="2-2使用dock-compose"><a href="#2-2使用dock-compose" class="headerlink" title="2.2使用dock-compose"></a>2.2使用dock-compose</h5><blockquote><p>如果没有安装先进行安装<code>apt install docker-compose</code></p></blockquote><p>dock-compose用来管理多个container的运行，特别适合1个host上跑多个container的情况。</p><p>得天独厚，<a href="https://docs.docker.com/compose/gettingstarted/" target="_blank" rel="noopener">docker官网上dock-compose的gettingstarted文档</a>就是flask的(说明flask+docker代表了先进生产力的前进方向O Yeah！),看完了基本就能用了。</p><p>dock-compose采用yaml作为配置文件。查了一下，yaml参考了xml和json，以及python的语法，采用了python之缩进，无XML之标记，无json之括号，无字符串之引号。特别适合作为配置文件用。</p><p>建立docker-compose.yaml文件(无镜像,但有dockerfile)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos; # 表示该 Docker-Compose 文件使用的是 Version 2 file</span><br><span class="line">services:</span><br><span class="line">  docker-demo:  # 指定服务名称</span><br><span class="line">    build: .  # 指定 Dockerfile 所在路径</span><br><span class="line">    ports:    # 指定端口映射</span><br><span class="line">      - &quot;9000:8761&quot;</span><br></pre></td></tr></table></figure><p>建立docker-compose.yaml文件(已有镜像)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  quotation_api: # 指定服务名称</span><br><span class="line">    image: quotation_dev:latest  # 指定镜像</span><br><span class="line">    volumes:# 选择数据卷</span><br><span class="line">      - /home/quotation:/code</span><br><span class="line">    ports:# 端口映射</span><br><span class="line">      - &quot;5000:5000&quot;</span><br><span class="line">    command: python3 main.py# 执行命令</span><br></pre></td></tr></table></figure><p>基本对应手动敲的docker命令，最后还省了敲python3 main.py。</p><p>当然如果是部署，这句可以用CMD 写进Dockfile。但是开发过程，文件名之类的会改变，比如最终部署运行用可能是gunicorn+wsgi.py，所以还是写在dockerfile外面比较方便</p><p>运行，在控制台执行：<code>docker-compose up</code>、<code>docker-compose up -d  // 后台启动并运行容器</code></p><p><a href="https://www.jianshu.com/p/658911a8cff3" target="_blank" rel="noopener">docker-compose更多介绍</a></p><h3 id="坑点记录"><a href="#坑点记录" class="headerlink" title="坑点记录"></a>坑点记录</h3><h4 id="docker容器启动后马上退出解决方案"><a href="#docker容器启动后马上退出解决方案" class="headerlink" title="docker容器启动后马上退出解决方案"></a><strong>docker容器启动后马上退出解决方案</strong></h4><blockquote><p>dokcerfile中的最后一个命令不能在后台执行,不然会启动后马上退出</p></blockquote><p><strong>原因</strong></p><p>Docker容器同时只能管理一个进程，如果这个进程退出那么容器也就退出了，但这不表示容器只能运行一个进程(其他进程可在后台运行)，但是要使容器不退出必须有一个前台执行的进程。</p><p><strong>解决方法</strong>：</p><p>脚本中最后一个进程一定要用前台运行方式即在进程最后不加&amp;(&amp;表示后台运行)，否则容器会退出。</p><h4 id="如何正确的使用docker-attach"><a href="#如何正确的使用docker-attach" class="headerlink" title="如何正确的使用docker attach"></a><a href="http://dockone.io/question/399" target="_blank" rel="noopener">如何正确的使用docker attach</a></h4><p>Q:由于执行着<code>uwsgi --ini uwsig.ini</code>命令,用户就无法直接进入到容器中去，<code>docker attach CONTAINER_id</code> 就会一直卡着。</p><p>A: attach早已过时了，可用: <code>docker exec -it containerID /bin/bash</code>，一开始使用的是<code>/bin/sh</code>然后还是一直卡住.但是/bin/bash是可以的</p><h3 id="附Uuntu版本代号"><a href="#附Uuntu版本代号" class="headerlink" title="附Uuntu版本代号:"></a>附Uuntu版本代号:</h3><table><thead><tr><th>版本号</th><th>代号</th><th>发布时间</th></tr></thead><tbody><tr><td>18.04</td><td>Bionic Beaver（仿生海狸）</td><td>即将发布2018年4月(LTS)</td></tr><tr><td>17.10</td><td>Artful Aardvark(机灵的土豚)</td><td>2017年10月</td></tr><tr><td><strong>16.04 LTS</strong></td><td>Xenial Xerus <code>好客的非洲地松鼠</code></td><td>即将发布 2016/4</td></tr><tr><td>15.10</td><td>Wily Werewolf <code>狡诈的狼人</code></td><td>2015/10/22</td></tr><tr><td>15.04</td><td>Vivid Vervet <code>活泼的小猴</code></td><td>2015/04/23</td></tr><tr><td>14.10</td><td>Utopic Unicorn <code>乌托邦独角兽</code></td><td>2014/10/23</td></tr><tr><td><strong>14.04 LTS</strong></td><td>Trusty Tahr <code>值得信赖的塔尔羊</code></td><td>2014/04/18</td></tr><tr><td>13.10</td><td>Saucy Salamander <code>活泼的蝾螈</code></td><td>2013/10/17</td></tr><tr><td>13.04</td><td>Raring Ringtail <code>铆劲浣熊</code></td><td>2013/04/25</td></tr><tr><td>12.10</td><td>Quantal Quetzal <code>缤纷的绿咬鹃</code></td><td>2012/10/18</td></tr><tr><td><strong>12.04 LTS</strong></td><td>Precise Pangolin <code>精准的穿山甲</code></td><td>2012/04/26</td></tr><tr><td>11.10</td><td>Oneiric Ocelot <code>有梦的虎猫</code></td><td>2011/10/13</td></tr><tr><td>11.04 <code>Unity成为默认桌面环境</code></td><td>Natty Narwhal <code>敏捷的独角鲸</code></td><td>2011/04/28</td></tr><tr><td>10.10</td><td>Maverick Meerkat <code>标新立异的的狐獴</code></td><td>2010/10/10</td></tr><tr><td><strong>10.04 LTS</strong></td><td>Lucid Lynx <code>清醒的猞猁</code></td><td>2010/04/29</td></tr><tr><td>9.10</td><td>Karmic Koala <code>幸运的无尾熊</code></td><td>2009/10/29</td></tr><tr><td>9.04</td><td>Jaunty Jackalope <code>活泼的兔子</code></td><td>2009/04/23</td></tr><tr><td>8.10</td><td>Intrepid Ibex <code>无畏的高地山羊</code></td><td>2008/10/30</td></tr><tr><td>8.06 <code>官方查不到此版本发布信息</code></td><td>Haughty Husky <code>骄傲的哈士奇</code></td><td>2008/06/07</td></tr><tr><td><strong>8.04 LTS</strong></td><td>Hardy Heron <code>坚强的苍鹭</code></td><td>2008/04/24</td></tr><tr><td>7.10</td><td>Gutsy Gibbon <code>勇敢的长臂猿</code></td><td>2007/10/18</td></tr><tr><td>7.04</td><td>Feisty Fawn <code>烦躁不安的小鹿</code></td><td>2007/04/19</td></tr><tr><td>6.10</td><td>Edgy Eft <code>尖利的小蜥蜴</code></td><td>2006/10/26</td></tr><tr><td><strong>6.06 LTS</strong></td><td>Dapper Drake <code>整洁的公鸭</code></td><td>2006/06/01</td></tr><tr><td>5.10</td><td>Breezy Badger <code>活泼的獾</code></td><td>2005/10/13</td></tr><tr><td>5.04</td><td>Hoary Hedgehog <code>白发得刺猬</code></td><td>2005/04/08</td></tr><tr><td><strong>4.10 </strong><code>初始发布版本</code></td><td>Warty Warthog <code>多疣的疣猪</code></td><td>2004/10/20</td></tr></tbody></table><h3 id="docker-compose使用-转"><a href="#docker-compose使用-转" class="headerlink" title="docker-compose使用[转]"></a>docker-compose使用[转]</h3><h4 id="docker-compose常见命令"><a href="#docker-compose常见命令" class="headerlink" title="docker-compose常见命令"></a>docker-compose常见命令</h4><ul><li><strong>ps</strong>：列出所有运行容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><ul><li><strong>logs</strong>：查看服务日志输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs</span><br></pre></td></tr></table></figure><ul><li><strong>port</strong>：打印绑定的公共端口，下面命令可以输出 eureka 服务 8761 端口所绑定的公共端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose port eureka 8761</span><br></pre></td></tr></table></figure><ul><li><strong>build</strong>：构建或者重新构建服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br></pre></td></tr></table></figure><ul><li><strong>start</strong>：启动指定服务已存在的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose start eureka</span><br></pre></td></tr></table></figure><ul><li><strong>stop</strong>：停止已运行的服务的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop eureka</span><br></pre></td></tr></table></figure><ul><li><strong>rm</strong>：删除指定服务的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose rm eureka</span><br></pre></td></tr></table></figure><ul><li><strong>up</strong>：构建、启动容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><ul><li><strong>kill</strong>：通过发送 SIGKILL 信号来停止指定服务的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose kill eureka</span><br></pre></td></tr></table></figure><ul><li><strong>pull</strong>：下载服务镜像</li><li><strong>scale</strong>：设置指定服务运气容器的个数，以 service=num 形式指定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose scale user=3 movie=3</span><br></pre></td></tr></table></figure><ul><li><strong>run</strong>：在一个服务上执行一个命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run web bash</span><br></pre></td></tr></table></figure><p>### </p><h4 id="docker-compose-yml-字段含义"><a href="#docker-compose-yml-字段含义" class="headerlink" title="docker-compose.yml 字段含义"></a>docker-compose.yml 字段含义</h4><ul><li><strong>version</strong>：指定 docker-compose.yml 文件的写法格式</li><li><strong>services</strong>：多个容器集合</li><li><strong>build</strong>：配置构建时，Compose 会利用它自动构建镜像，该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">build: ./dir</span><br><span class="line">---------------</span><br><span class="line">build:</span><br><span class="line">    context: ./dir</span><br><span class="line">    dockerfile: Dockerfile</span><br><span class="line">    args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure><ul><li><strong>command</strong>：覆盖容器启动后默认执行的命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command: bundle exec thin -p 3000</span><br><span class="line">----------------------------------</span><br><span class="line">command: [bundle,exec,thin,-p,3000]</span><br></pre></td></tr></table></figure><ul><li><strong>dns</strong>：配置 dns 服务器，可以是一个值或列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line">------------</span><br><span class="line">dns:</span><br><span class="line">    - 8.8.8.8</span><br><span class="line">    - 9.9.9.9</span><br></pre></td></tr></table></figure><ul><li><strong>dns_search</strong>：配置 DNS 搜索域，可以是一个值或列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line">------------------------</span><br><span class="line">dns_search:</span><br><span class="line">    - dc1.example.com</span><br><span class="line">    - dc2.example.com</span><br></pre></td></tr></table></figure><ul><li><strong>environment</strong>：环境变量配置，可以用数组或字典两种方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">    RACK_ENV: development</span><br><span class="line">    SHOW: &apos;ture&apos;</span><br><span class="line">-------------------------</span><br><span class="line">environment:</span><br><span class="line">    - RACK_ENV=development</span><br><span class="line">    - SHOW=ture</span><br></pre></td></tr></table></figure><ul><li><strong>env_file</strong>：从文件中获取环境变量，可以指定一个文件路径或路径列表，其优先级低于 environment 指定的环境变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line">---------------</span><br><span class="line">env_file:</span><br><span class="line">    - ./common.env</span><br></pre></td></tr></table></figure><ul><li><strong>expose</strong>：暴露端口，只将端口暴露给连接的服务，而不暴露给主机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line">    - &quot;3000&quot;</span><br><span class="line">    - &quot;8000&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>image</strong>：指定服务所使用的镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: java</span><br></pre></td></tr></table></figure><ul><li><strong>network_mode</strong>：设置网络模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name/id]&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>ports</strong>：对外暴露的端口定义，和 expose 对应</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ports:   # 暴露端口信息  - &quot;宿主机端口:容器暴露端口&quot;</span><br><span class="line">- &quot;8763:8763&quot;</span><br><span class="line">- &quot;8763:8763&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>links</strong>：将指定容器连接到当前连接，可以设置别名，避免ip方式导致的容器重启动态改变的无法连接情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">links:    # 指定服务名称:别名 </span><br><span class="line">    - docker-compose-eureka-server:compose-eureka</span><br></pre></td></tr></table></figure><ul><li><strong>volumes</strong>：卷挂载路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - /lib</span><br><span class="line">  - /var</span><br></pre></td></tr></table></figure><ul><li><strong>logs</strong>：日志输出信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--no-color          单色输出，不显示其他颜.</span><br><span class="line">-f, --follow        跟踪日志输出，就是可以实时查看日志</span><br><span class="line">-t, --timestamps    显示时间戳</span><br><span class="line">--tail              从日志的结尾显示，--tail=200</span><br></pre></td></tr></table></figure><h4 id="更新容器"><a href="#更新容器" class="headerlink" title="更新容器"></a>更新容器</h4><ul><li>当服务的配置发生更改时，可使用 docker-compose up 命令更新配置</li><li>此时，Compose 会删除旧容器并创建新容器，新容器会以不同的 IP 地址加入网络，名称保持不变，任何指向旧容起的连接都会被关闭，重新找到新容器并连接上去</li></ul><h4 id="links"><a href="#links" class="headerlink" title="links"></a>links</h4><ul><li>服务之间可以使用服务名称相互访问，links 允许定义一个别名，从而使用该别名访问其它服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">    web:</span><br><span class="line">        build: .</span><br><span class="line">        links:</span><br><span class="line">            - &quot;db:database&quot;</span><br><span class="line">    db:</span><br><span class="line">        image: postgres</span><br></pre></td></tr></table></figure><ul><li>这样 Web 服务就可以使用 db 或 database 作为 hostname 访问 db 服务了</li></ul><h3 id="docker-stop-containerID，以后再重新启动时报错"><a href="#docker-stop-containerID，以后再重新启动时报错" class="headerlink" title="docker stop containerID，以后再重新启动时报错"></a>docker stop containerID，以后再重新启动时报错</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: driver failed programming external connectivity on endpoint app (3c0c01ac6b42b7a420644fc2b4debfbbcc0e1d2e74e6294155c28aca82f794c4):  (iptables failed: iptables --<span class="built_in">wait</span> -t nat -A DOCKER -p tcp -d 0/0 --dport 12345 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name.</span><br></pre></td></tr></table></figure><p>A: 重启docker即可：<code>systemctl restart docker</code></p><p>再开启你的容器： <code>docker run xxxx</code>或<code>docker start xxx</code></p><p>查看docker容器的运行日志</p><p><code>docker logs containerID</code></p><h3 id="docker端口映射到宿主机后外网仍无法访问容器的web"><a href="#docker端口映射到宿主机后外网仍无法访问容器的web" class="headerlink" title="docker端口映射到宿主机后外网仍无法访问容器的web"></a>docker端口映射到宿主机后外网仍无法访问容器的web</h3><p>A：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决办法：</span></span><br><span class="line">$ sudo vi /etc/sysctl.conf</span><br><span class="line">或者</span><br><span class="line">$ sudo  vi /usr/lib/sysctl.d/00-system.conf</span><br><span class="line"><span class="comment"># 添加如下代码：</span></span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line">重启network服务</span><br><span class="line">$ sudo systemctl restart network</span><br><span class="line"></span><br><span class="line">查看是否修改成功</span><br><span class="line">$ sudo sysctl net.ipv4.ip_forward</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果返回为“net.ipv4.ip_forward = 1”则表示成功了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker学习&quot;&gt;&lt;a href=&quot;#Docker学习&quot; class=&quot;headerlink&quot; title=&quot;Docker学习&quot;&gt;&lt;/a&gt;Docker学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;轻部署,省成本,易迁移&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="自动化运维" scheme="https://nymrli.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Python中的正则匹配</title>
    <link href="https://nymrli.top/2019/07/25/Python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"/>
    <id>https://nymrli.top/2019/07/25/Python中的正则匹配/</id>
    <published>2019-07-25T01:50:19.000Z</published>
    <updated>2019-07-25T01:59:58.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的正则匹配"><a href="#Python中的正则匹配" class="headerlink" title="Python中的正则匹配"></a>Python中的正则匹配</h1><blockquote><p>虽然正则早就会用了,但是有些使用方法老是忘记,因此还是写篇记录一下</p></blockquote><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table><thead><tr><th style="text-align:left">特别字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。</td></tr><tr><td style="text-align:left">( )</td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。要匹配 <em> 字符，请使用 \</em>。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td></tr><tr><td style="text-align:left">.</td><td style="text-align:left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。</td></tr><tr><td style="text-align:left">{</td><td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用 {。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left"></td><td>指明两项之间的一个选择。要匹配 \</td><td>，请使用 \</td><td>。</td></tr></tbody></table><hr><h2 id="特殊字符-1"><a href="#特殊字符-1" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <strong>runoo*b</strong> 中的 <strong>*</strong>，简单的说就是表示任何字符串的意思。如果要查找字符串中的 <strong>*</strong> 符号，则需要对 <strong>*</strong> 进行转义，即在其前加一个 <strong>\</strong>: <strong>runo*ob</strong> 匹配 runo*ob。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符<strong>\</strong> 放在它们前面。下表列出了正则表达式中的特殊字符：</p><table><thead><tr><th style="text-align:left">特别字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。</td></tr><tr><td style="text-align:left">( )</td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。要匹配 <em> 字符，请使用 \</em>。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td></tr><tr><td style="text-align:left">.</td><td style="text-align:left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。</td></tr><tr><td style="text-align:left">{</td><td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用 {。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left"></td><td>指明两项之间的一个选择。要匹配 \</td><td>，请使用 \</td><td>。</td></tr></tbody></table><hr><p><strong>*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。</strong></p><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 <strong>*</strong> 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td style="text-align:left">{n}</td><td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td style="text-align:left">{n,}</td><td style="text-align:left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td style="text-align:left">{n,m}</td><td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>定位符用来描述字符串或单词的边界，<strong>^</strong> 和 <strong>$</strong> 分别指字符串的开始与结束，<strong>\b</strong> 描述单词的前或后边界，<strong>\B</strong> 表示非单词边界。</p><p>正则表达式的定位符有：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td style="text-align:left">\B</td><td style="text-align:left">非单词边界匹配。</td></tr></tbody></table><h2 id="捕获与非捕获"><a href="#捕获与非捕获" class="headerlink" title="捕获与非捕获"></a>捕获与非捕获</h2><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。</p><p>其中 <strong>?:</strong> 是非捕获元之一，还有两个非捕获元是 <strong>?=</strong> 和 <strong>?!</strong>，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p><hr><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <strong>\n</strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p><p>可以使用非捕获元字符 <strong>?:</strong>、<strong>?=</strong> 或 <strong>?!</strong> 来重写捕获，忽略对相关匹配的保存。</p><p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：</p><h2 id="正则-lt-和-用法-https-www-cnblogs-com-whaozl-p-5462865-html"><a href="#正则-lt-和-用法-https-www-cnblogs-com-whaozl-p-5462865-html" class="headerlink" title="正则 ?&lt;= 和 ?= 用法](https://www.cnblogs.com/whaozl/p/5462865.html)"></a>正则 ?&lt;= 和 ?= 用法](<a href="https://www.cnblogs.com/whaozl/p/5462865.html" target="_blank" rel="noopener">https://www.cnblogs.com/whaozl/p/5462865.html</a>)</h2><p><strong>方法1： 匹配，捕获(存储)</strong></p><p>正则表达式：(?&lt;=(href=”)).{1,200}(?=(“&gt;))</p><p>解释：</p><p>(?&lt;=(href=”)) 表示 <strong>匹配</strong>以(href=”)<strong>开头</strong>的字符串，并且<strong>捕获(存储)</strong>到分组中</p><p>(?=(“&gt;)) 表示 <strong>匹配</strong>以(“&gt;)<strong>结尾</strong>的字符串，并且<strong>捕获(存储)</strong>到分组中</p><p><strong>方法2： 匹配，不捕获(不存储)</strong></p><p> 正则表达式：(?&lt;=(<strong>?:</strong>href=”)).{1,200}(?=(<strong>?:</strong>“&gt;))</p><p>​       解释：(?&lt;=(<strong>?:</strong>href=”)) 表示 <strong>匹配</strong>以(href=”)<strong>开头</strong>的字符串，并且<strong>不捕获(不存储)</strong>到分组中</p><p>​               (?=(<strong>?:</strong>“&gt;)) 表示 <strong>匹配</strong>以(“&gt;)<strong>结尾</strong>的字符串，并且<strong>不捕获(不存储)</strong>到分组中</p><table><thead><tr><th>(?:pattern)</th><th>非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(\</th><th>)”来组合一个模式的各个部分是很有用。例如“industr(?:y\</th><th>ies)”就是一个比“industry\</th><th>industries”更简略的表达式。</th></tr></thead><tbody><tr><td>(?=pattern)</td><td>非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95\</td><td>98\</td><td>NT\</td><td>2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95\</td><td>98\</td><td>NT\</td><td>2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。</td></tr><tr><td>(?&lt;=pattern)</td><td>非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95\</td><td>98\</td><td>NT\</td><td>2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td></tr><tr><td>(?&lt;!pattern)</td><td>非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95\</td><td>98\</td><td>NT\</td><td>2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题</td></tr></tbody></table><p> <strong>分组语法 捕获</strong><br><strong>(exp)</strong> 匹配exp,并捕获文本到自动命名的组里<br><strong>(?<name>exp)</name></strong> 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)<br><strong>(?:exp)</strong> 匹配exp,不捕获匹配的文本<br><strong>位置指定</strong><br><strong>(?=exp)</strong> 匹配exp前面的位置<br><strong>(?&lt;=exp)</strong> 匹配exp后面的位置<br><strong>(?!exp)</strong> 匹配后面跟的不是exp的位置<br><strong>(?&lt;!exp)</strong> 匹配前面不是exp的位置<br><strong>注释</strong><br><strong>(?#comment)</strong> 这种类型的组不对正则表达式的处理产生任何影响，只是为了提供让人阅读注释</p><p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面。</p><p><strong>位置指定</strong><br>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们用于指定一个位置，就像\b,^,$那样，因此它们也被称为零宽断言。最好还是拿例子来说明吧：</p><p>(?=exp)也叫零宽先行断言，它匹配文本中的某些位置，这些位置的后面能匹配给定的后缀exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如果在查找I’m singing while you’re dancing.时，它会匹配sing和danc。</p><p>(?&lt;=exp)也叫零宽后行断言，它匹配文本中的某些位置，这些位置的前面能给定的前缀匹配exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。</p><p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})*\b。请仔细分析这个表达式，它可能不像你第一眼看出来的那么简单。</p><p>下面这个例子同时使用了前缀和后缀：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><h3 id="常见正则表达式"><a href="#常见正则表达式" class="headerlink" title="常见正则表达式"></a>常见正则表达式</h3><ul><li><p>Email地址：^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$ </p></li><li><p>域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? </p></li><li><p>InternetURL：[a-zA-z]+://[^\s]<em> 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]</em>)?$ </p></li><li><p>手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ </p></li><li><p>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$  </p></li><li><p>身份证号(15位、18位数字)：^\d{15}|\d{18}$ </p></li><li><p>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</p></li><li><p>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$</p></li><li><p>日期格式：^\d{4}-\d{1,2}-\d{1,2}</p></li><li><p>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</p></li><li><p>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python中的正则匹配&quot;&gt;&lt;a href=&quot;#Python中的正则匹配&quot; class=&quot;headerlink&quot; title=&quot;Python中的正则匹配&quot;&gt;&lt;/a&gt;Python中的正则匹配&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;虽然正则早就会用了,但是有些使用方
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>利用wireshark抓取TCP的整个过程分析[转]</title>
    <link href="https://nymrli.top/2019/07/24/%E5%88%A9%E7%94%A8wireshark%E6%8A%93%E5%8F%96TCP%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://nymrli.top/2019/07/24/利用wireshark抓取TCP的整个过程分析/</id>
    <published>2019-07-24T07:51:29.000Z</published>
    <updated>2019-07-25T01:50:26.413Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://www.cnblogs.com/NickQ/p/9226579.html" target="_blank" rel="noopener">https://www.cnblogs.com/NickQ/p/9226579.html</a> </p><p>最近，已经很久都没有更新博客了。看看时间，想想自己做了哪些事情，突然发现自己真的是太贪心，到头来却一个都没搞好。手头的嵌入式都还没学出名堂，竟然还想着学FPGA,物联网，机器学习。然而，遇到新奇的事物，就会控制不住的去想，去找资料，实际上只是逃避遇到的问题，不想去解决而已。。最后的结果就是手头的活堆起来了，然后花大把整块的时间解决。真的是讨厌现在的自己。</p><p>以后还是慢慢记录吧，不管做了什么，都慢慢尝试积累。。其他的东西，像FPGA，机器学习什么的，让他随风去吧，用到啥学啥。其他的当看客，了解了解就好。</p><p>这是计算机网络的一次作业，学习抓取TCP/IP建立连接和断开连接的过程，以下是正文：</p><p><strong>步骤：</strong></p><p>首先尝试抓百度，腾讯等网络连接，发现会有许多问题需要考虑，断开连接操作不好操作，且数据冗杂不利于学习。</p><p><img src="https://images2018.cnblogs.com/blog/1249999/201806/1249999-20180625223300726-249267524.png" alt="img"></p><p>所以借助手机和电脑完成此次过程，操作如下：</p><p>1、在手机端，安装TCP测试工具，开启TCP监听，端口8088；</p><p><img src="https://images2018.cnblogs.com/blog/1249999/201806/1249999-20180625221400357-2132003606.jpg" alt="img"></p><p>2、打开wireshark监听WIFI网卡。</p><p>3、打开电脑端TCP测试客户端，连接TCP服务器。</p><p>此处，我的手机IP为192.168.255.5，端口8088；电脑的IP地址为192.168.255.6。</p><p>4、通过电脑客户端，发送两次信息到手机。</p><p>5、通过手机客户端，发送两次信息到电脑。</p><p>6、断开连接。</p><p>7、通过ip.addr eq 192.168.255.5 and ip.addr eq 192.168.255.6 and tcp过滤掉其他报文。</p><p>至于wireshark过滤的语法，可以参考其他的一些博文：<a href="https://blog.csdn.net/wojiaopanpan/article/details/69944970" target="_blank" rel="noopener">https://blog.csdn.net/wojiaopanpan/article/details/69944970</a></p><p><strong>协议及过程分析：</strong></p><p>TCP三次握手：如下图中蓝色方框所示。</p><p>TCP握手协议在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p><p>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；如下图中报文No.7</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；如下图中报文No.8</p><p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据。如下图中报文No.9</p><p><img src="https://images2018.cnblogs.com/blog/1249999/201806/1249999-20180625221206712-792100790.png" alt="img"></p><p>TCP四次挥手：如上图中红色方框所示。</p><p>注：此处，由于先断开的服务器，所以手机服务器是客户端A。</p><p>第一次挥手：客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</p><p>如图中报文No.255</p><p>第二次挥手：服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。如图中报文No.256</p><p>第三次挥手：服务器B关闭与客户端A的连接，发送一个FIN给客户端A。如图中报文No.257</p><p>第四次挥手：客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。如图中报文No.258</p><p><strong>其他:</strong></p><p>下图是其中一帧数据解析，可以看到数据是由192.168.255.6:62643(电脑客户端)发送给192.168.255.5:8088(手机服务端）。</p><p>消息内容为：201521111083</p><p><img src="https://images2018.cnblogs.com/blog/1249999/201806/1249999-20180625223511076-53478793.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/NickQ/p/9226579.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/NickQ/p/9226579.html&lt;/
      
    
    </summary>
    
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="https://nymrli.top/2019/07/13/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2019/07/13/C-学习笔记/</id>
    <published>2019-07-13T01:00:50.000Z</published>
    <updated>2019-07-13T01:01:29.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-学习笔记"><a href="#C-学习笔记" class="headerlink" title="C++学习笔记"></a>C++学习笔记</h1><blockquote><p>system（）就是调用（DOS）系统命令（和shell命令）。<br>pause ，即DOS命令集合中的暂停命令；</p></blockquote><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main( void )</span><br><span class="line">&#123;</span><br><span class="line">  char  buffer[200], s[] = &quot;computer&quot;, c = &apos;l&apos;;</span><br><span class="line">  int   i = 35, j;</span><br><span class="line">  float fp = 1.7320534f;  // 格式化并打印各种数据到buffer</span><br><span class="line">  j  = sprintf( buffer,    &quot;   String:    %s\n&quot;, s ); // C4996</span><br><span class="line">  j += sprintf( buffer + j,&quot;   Character: %c\n&quot;, c );</span><br><span class="line">  j += sprintf( buffer + j,&quot;   Integer:   %d\n&quot;, i );</span><br><span class="line">  j += sprintf( buffer + j,&quot;   Real:      %f\n&quot;, fp );</span><br><span class="line">  printf( &quot;Output:\n%s\ncharacter count = %d\n&quot;, buffer, j );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>返回写入buffer 的字符数，出错则返回-1. 如果 buffer 或 format 是空指针，且不出错而继续，函数将返回-1</li><li>sprintf 返回以format为格式argument为内容组成的结果被写入buffer 的字节数，结束字符‘\0’不计入内。即，如果“Hello”被写入空间足够大的buffer后，函数sprintf 返回5。</li></ul></blockquote><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>声明引用：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int &amp;c=a;  //int &amp; c=a;   △.声明引用时必须初始化</span><br></pre></td></tr></table></figure><p><strong>传引用参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func(int&amp; a)&#123;&#125; //函数名(xxx)xxx其实是创建形参变量的过程</span><br><span class="line">func(b);</span><br></pre></td></tr></table></figure><p><strong>传指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void func2(int *a)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>返回引用</strong></p><p>返回值不能是局部变量（局部变量在生命期结束后会被销毁）<br>​    （c中生命周期结束后，立马销毁，而在python中垃圾回收机制会在判断之后不使用的情况下再销毁）<br>func2(&amp;b);</p><h2 id="增强的for循环"><a href="#增强的for循环" class="headerlink" title="增强的for循环:"></a>增强的for循环:</h2><blockquote><p>在vc6.0中 for(int i=4;i&gt;0;i–)  i的作用域为　整个外部作用域如<br>void main()<br>{<br>​    for(int i=4;i&gt;0;i–) //作用域为整个main函数<br>}<br>   而在vs中 for(int i=4;i&gt;0;i–)  i的作用域为　该个for循环内<br>void main()<br>{<br>​    for(int i=4;i&gt;0;i–) //作用域为该个for循环<br>}</p></blockquote><hr><p>默认参数　从右往左连续</p><p>返回值不是函数重载的条件</p><hr><blockquote><p>malloc和free　不会触发构造函数或是析构函数<br>new和delete　可以</p></blockquote><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote><p>不做特别说明，类的数据成员和成员函数都被认为是private</p></blockquote><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><ul><li>this 是类成员函数的隐含参数，不是类的数据成员</li><li>静态成员无this指针</li></ul><h2 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h2><ul><li><p>常函数不能修改类中的数据成员的值</p></li><li><p>析构函数和构造函数不能是常函数</p></li><li>常变量只能调用常函数，不能调用普通函数</li><li>常对象只能调用常函数，不能调用普通函数</li></ul><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><ul><li>是类本身的属性，无对象时也可以直接调用Cstu::sta</li><li>静态成员函数只能调用静态数据成员<br>类外初始化　不需要static关键字 如： int Cstu::sta = 12;</li></ul><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = new int[2];</span><br><span class="line">delete[] a;</span><br></pre></td></tr></table></figure><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><ul><li>系统默认的为浅拷贝</li><li>有指针承运啊时得内存拷贝，所以使用深拷贝，</li><li>为了避免拷贝构造，运算符重载应该传引用</li></ul><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p><strong>何时会调用</strong></p><blockquote><p>1.新建一个对象，并将其初始化为同类现有对象</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cstu a;</span><br><span class="line">- Cstu a1(a);</span><br><span class="line">- Cstu a2 = a;</span><br><span class="line">- Cstu a3 = Cstu(a);　//创建了临时对象</span><br><span class="line">- Cstu a4 = new Cstu(a);</span><br><span class="line">- △.赋值并不会发生拷贝构造</span><br></pre></td></tr></table></figure><blockquote><p>2.当程序生成对象副本时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 参数是本类的常引用Cstu(const Cstu&amp;)</span><br><span class="line"></span><br><span class="line">- 普通构造函数如果空的话是不执行内容的，拷贝构造空的话是执行内容的</span><br><span class="line">- 默认的复制构造函数，逐个复制非静态成员的值，</span><br><span class="line"></span><br><span class="line">## 内联函数inline</span><br><span class="line"></span><br><span class="line">- 函数代码少，流程直接，调用频繁，如循环</span><br><span class="line">- 类内定义的都是内联函数（隐式），写inline为显性</span><br><span class="line">- 内联函数的定义一般写在头文件内</span><br><span class="line"></span><br><span class="line">- 只在声明位置写inline不管用，定义与声明都要有inline关键字</span><br><span class="line">- 空间换时间，使用频率低时速度快，频率高时，比较占用内存，主要看性价比</span><br><span class="line">- 递归不能是内联函数</span><br><span class="line"></span><br><span class="line">## 操作符重载</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 为了避免拷贝构造，运算符重载应该传引用或是传地址</span><br><span class="line">- 操作符重载必须有一个类类型的参数</span><br><span class="line">- =、[]、()、-&gt;必须是诚邀</span><br><span class="line">- 复合赋值运算符通常是成员</span><br><span class="line">- 改变对象状态的运算符，递增、解引用，通常是成员</span><br><span class="line"></span><br><span class="line">### 输出运算符重载:</span><br><span class="line"></span><br><span class="line">- 参数1是ostream引用，参数2是对象的常引用</span><br><span class="line">- 必须是类外重载，原因为1</span><br><span class="line">- 输出私有成员时，要用友元</span><br></pre></td></tr></table></figure></p></blockquote><p>void operator &lt;&lt; (ostream&amp; os,const &amp;Csty)，os &lt;&lt;st.nAge;<br>ostream&amp; operator &lt;&lt; (ostream&amp; os,const &amp;Csty)，os &lt;&lt;st.nAge;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 输入运算符重载:</span><br><span class="line"></span><br><span class="line">- 参数不匹配用ist.fail()检测</span><br><span class="line">- 输出=&gt;  ist&gt;&gt;st.nAge &gt;&gt; st.dbHeight;</span><br></pre></td></tr></table></figure></p><p>istream&amp; operator &gt;&gt;(istream&amp; ist,CStu&amp; st)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 前置+ +与后置+ +重载</span><br></pre></td></tr></table></figure></p><p>int operator++(Cstu* st){} =&gt;前置++</p><p>int operator++(Cstu* st,int n) =&gt;后置++<br>{<br>    int a =st.nage;<br>    st.nage +=1;<br>    return a;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">类型转换重载</span><br></pre></td></tr></table></figure></p><p>operator int()const{}            //无返回值，但有return </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">△.必须在类内。▲.const</span><br><span class="line"></span><br><span class="line">## 模板</span><br></pre></td></tr></table></figure><p>template <typename y=""><br>void func(Y a) cout &lt;&lt; a　&lt;&lt; endl;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">模板的具体化:</span><br></pre></td></tr></table></figure></typename></p><p>temlpate &lt;&gt; void func<node>(Node&amp; a){}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 模板具体化的执行优先级高于通用的优先级，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">◇.注意，STL头文件没有扩展名.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"># CPP</span><br><span class="line"></span><br><span class="line">```该类接受2个参数</span><br><span class="line">初始化列表</span><br><span class="line">class CStu</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int arr[4];</span><br><span class="line">    float b;</span><br><span class="line">//构造函数： </span><br><span class="line">CStu(*float c,int d*):a(2),b(2.2f),arr()    #成员初始化顺序只与声明顺序有关，与此处书写顺序无关</span><br><span class="line">    &#123;#新增语法，arr数组全初始化为0</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></node></p><p>▲.类必须先初始化成员变量。</p><p>​    。float c和int d 两个变量的作用域仅限于构造函数内.所以要想在整个类中使用该变量，就得将传入的参数初始化赋值给类中的变量。</p><p>​    若有多个构造函数，会执行初始化列表绑定所在的构造函数（构造函数的重载）</p><blockquote><p>数组的赋值：</p><blockquote><ul><li>初始化列表arr()</li><li>构造函数中for循环赋值</li><li>memset(&amp;arr[0],0,16)</li></ul></blockquote></blockquote><p>△.析构函数没有重载，且不接受参数。对象声明调用周期结束时自动调用。</p><p>▲构造函数和析构函数都必须写在public访问控制符下</p><hr><h2 id="malloc和new、free和delete区别"><a href="#malloc和new、free和delete区别" class="headerlink" title="malloc和new、free和delete区别"></a>malloc和new、free和delete区别</h2><ul><li>malloc不会触发构造函数，new可以</li><li>free不会触发析构函数，delete可以</li></ul><hr><h2 id="This指针"><a href="#This指针" class="headerlink" title="This指针"></a>This指针</h2><p>指针类型为类的类型。</p><p>this不是类的成员。</p><p>this指针为成员函数的隐含参数，相当于python类中的self…..(所以this指针的作用域为类内部)</p><hr><h2 id="常函数-1"><a href="#常函数-1" class="headerlink" title="常函数"></a>常函数</h2><figure class="highlight plain"><figcaption><span>CStu&#123;&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CStu</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    void show() const  #在括号之后</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>◆.析构函数、构造函数不能是常函数</p><p>◆.常函数不能修改数据成员（是类的），但可以修改常函数内的变量。</p><p>▲常函数的this指针的类型为const CStu*</p><p>★常对象(const CStu st)只能调用常函数，不能调用普通函数</p><hr><h2 id="静态成员-1"><a href="#静态成员-1" class="headerlink" title="静态成员"></a>静态成员</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CStu</span><br><span class="line">&#123;</span><br><span class="line">static int b;</span><br><span class="line">    public:</span><br><span class="line">    void show() const  #在括号之后</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>∷不能在构造函数的初始化列表中初始化，但可以类外初始化</p><p>∷类外初始化不用加static，而是int CStu::b = 12;</p><p>▲static受访问控制符约束。</p><p>调用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名作用域：cout&lt;&lt; CStu::b &lt;&lt; endl;</span><br><span class="line">对象：</span><br></pre></td></tr></table></figure><p>○只有静态常量整型数据才能直接在类中初始化，其他得在初始化列表或者构造函数中赋值（静态数据成员可以类外赋值），普通数据成员不能类外初始化。</p><p>●静态成员是跟类一一对应的，跟对象无关。</p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><blockquote><p>他是属于类的属性，不是对象的，即同一个类的所有对象共有一个（可以作为指挥类所有对象的方法）</p><p>无this指针</p><p>不能调用普通成员，只能调用静态成员</p></blockquote><hr><h2 id="拷贝构造-1"><a href="#拷贝构造-1" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><blockquote><p>public:</p><p>​    Cstu(const Cstu &amp;a){} 形式。参数是本类的常引用</p></blockquote><p>何时调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.新建一个对象，并将其初始化为同类时：</span><br><span class="line">- Cstu a1(a);#a为一个Cstu对象</span><br><span class="line">- Cstu a2 = a;  将不会再触发构造函数。</span><br><span class="line">- Cstu a3 = Cstu(a);   用a来拷贝构造一个临时对象，再用这个临时对象给a3</span><br><span class="line">- Cstu* a4 = new Cstu(a);</span><br><span class="line">2.当程序生成对象副本时：</span><br><span class="line">函数参数传递对象的值void fun(Cstu a)&#123;&#125;   （∵当调用这个函数的时候会为这个形参生成空间）</span><br><span class="line">▲有时为了效率要避免这种拷贝构造的产生，解决：传引用</span><br><span class="line">函数返回值 Cstu fun()&#123; Cstu a; return a;&#125; 返回值为创建了临时对象承接，然后再把临时变量返回。</span><br></pre></td></tr></table></figure><p>赋值不会调用：</p><blockquote><p>Cstu s1;</p><p>Cstu s2;</p><p>s2 = s1;</p></blockquote><h3 id="默认拷贝构造（浅拷贝）"><a href="#默认拷贝构造（浅拷贝）" class="headerlink" title="默认拷贝构造（浅拷贝）"></a>默认拷贝构造（浅拷贝）</h3><blockquote><p>逐个赋值非静态成员，（即默认拷贝构造中是有内容的，默认的构造函数是没有内容的）</p><p>内存排布一样，地址不同</p></blockquote><h3 id="深拷贝-涉及类中有指针"><a href="#深拷贝-涉及类中有指针" class="headerlink" title="深拷贝(涉及类中有指针)"></a>深拷贝(涉及类中有指针)</h3><p>如果是浅拷贝，则两个对象的指针都会指向同一个空间，如果第一个对象被消除后，这个空间就会被delete（free掉），所以第二个对象被删除时再操作（free）这个被释放掉的空间（已经还给系统），就相当于控制野指针，所以会报错。</p><p>解决方法1深拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this-&gt;a = new int[2];</span><br><span class="line">memcpy(this-&gt;a,b.a,8);</span><br><span class="line">strcpy(...)</span><br></pre></td></tr></table></figure><p>解决方法2传引用（不经过拷贝构造）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cstu&amp; fun(CStu&amp; a)</span><br><span class="line">&#123;return a;&#125;</span><br><span class="line">fun(a);</span><br></pre></td></tr></table></figure><p>解决方法3传地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cstu* fun(CStu* a)</span><br><span class="line">&#123;return a;&#125;</span><br><span class="line">fun(&amp;a);</span><br></pre></td></tr></table></figure><hr><h2 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h2><p>常规函数的调用过程：调用时，根据函数地址，跳到函数代码空间，执行指令，执行完再跳转到调用的位置。</p><p>内联函数：将函数代码直接复制到执行部分，不跳转。</p><blockquote><p>比常规函数稍快</p><p>占用更多内存（增加代码长度）</p></blockquote><p>▲声明和定义都要加inline 关键字</p><p>▲递归不能是内联函数</p><p>△.函数代码少时、调用频繁（for循环里）大多用内联函数（常规函数的话，跳转所耗时间占比就大）</p><p>▲.类内定义的函数都是内联函数，但如果定义在类外的话加inline为内联函数，不加就不是内联函数。</p><p>△.内联函数通常定义在头文件里。</p><hr><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>operator为关键字</p><p>“operator+”必须有一个类类型的形参；</p><hr><h2 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h2><blockquote><p>继承控制符：</p><p>public 父类：父类为什么访问控制符，子类就继承什么样的。</p><p>protected 父类:继承之后，父类的public降级为protected，低级或者同级的访问控制符不变（即protectedh和private)</p><p>private 父类：继承之后，父类全变为私有。</p></blockquote><h2 id="多态和虚函数"><a href="#多态和虚函数" class="headerlink" title="多态和虚函数"></a>多态和虚函数</h2><h3 id="多态：同样的调用有多种结果"><a href="#多态：同样的调用有多种结果" class="headerlink" title="多态：同样的调用有多种结果"></a>多态：同样的调用有多种结果</h3><p>通过虚函数调用子类的成员函数，形式为virtual void Show(){}  (函数名与子类相同)</p><blockquote><p>具体执行那个子类的函数由父类所指向的子类所决定. CFather* fa = new CSon1;</p></blockquote><hr><p>C++中声明结构体变量不需要‘struct’，struct默认为public,class 默认为private</p><p>c静态变量在预处理时声明。</p><p>cpp静态成员在类声明时声明。</p><h2 id="STL初始化"><a href="#STL初始化" class="headerlink" title="STL初始化"></a>STL初始化</h2><hr><ul><li><p>(1): vector<int> v;</int></p><blockquote><p>默认初始化，vector为空， size为0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。</p></blockquote></li><li><p>(2): vector<int> v2(v);</int></p><p>vector<int> v2= v; </int></p><blockquote><p>两种方式等价 ，ilist2 初始化为ilist 的拷贝，ilist必须与ilist2 类型相同，也就是同为int的vector类型，ilist2将具有和ilist相同的容量和元素</p></blockquote></li><li><p>(3): vector<int> ilist = {1,2,3.0,4,5,6,7};</int></p><p>vector<int> ilist {1,2,3.0,4,5,6,7};</int></p></li></ul><blockquote><p>初始化为列表中元素的拷贝，列表中元素必须与ilist的元素类型相容 </p></blockquote><ul><li><p>(4): vector<int> ilist3(ilist.begin()+2,ilist.end()-1); </int></p><blockquote><p>初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与ilist3 的元素类型相容 </p></blockquote></li><li><p>(5): vector<int> ilist4(7); </int></p><blockquote><p>默认值初始化，ilist4中将包含7个元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0， </p></blockquote></li><li><p>(6):vector<int> ilist5(7,3); </int></p><blockquote><p>指定值初始化，ilist5被初始化为包含7个值为3的int </p></blockquote></li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; idxs中</span><br><span class="line">for(int i : idxs)  ====&gt; for i in indx ..... i 为idxs中元素</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-学习笔记&quot;&gt;&lt;a href=&quot;#C-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;C++学习笔记&quot;&gt;&lt;/a&gt;C++学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;system（）就是调用（DOS）系统命令（和shell命令）。&lt;br&gt;pau
      
    
    </summary>
    
    
      <category term="C++" scheme="https://nymrli.top/tags/C/"/>
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>通过XDRP实现Windows远程访问ubuntu桌面</title>
    <link href="https://nymrli.top/2019/07/13/%E9%80%9A%E8%BF%87XDRP%E5%AE%9E%E7%8E%B0Windows%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEubuntu%E6%A1%8C%E9%9D%A2/"/>
    <id>https://nymrli.top/2019/07/13/通过XDRP实现Windows远程访问ubuntu桌面/</id>
    <published>2019-07-13T00:57:05.000Z</published>
    <updated>2019-07-13T00:57:31.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过XDRP实现Windows远程访问"><a href="#通过XDRP实现Windows远程访问" class="headerlink" title="通过XDRP实现Windows远程访问"></a>通过XDRP实现Windows远程访问</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装xrdp </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install xrdp </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装vnc4server </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install vnc4server tightvncserver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装xubuntu-desktop </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install xubuntu-desktop </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">向xsession中写入xfce4-session </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> “xfce4-session” &gt;~/.xsession </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">开启xrdp服务 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service xrdp restart</span></span><br></pre></td></tr></table></figure><p>上面是网上大多数示例所展示的，都是依靠第三方桌面系统实现远程访问，下面讲解的是如何直接访问原生系统。</p><h3 id="步骤一、下载TigerVNC-Server软件包"><a href="#步骤一、下载TigerVNC-Server软件包" class="headerlink" title="步骤一、下载TigerVNC Server软件包"></a>步骤一、下载TigerVNC Server软件包</h3><p>　　下载地址：<a href="http://www.c-nergy.be/downloads/tigervncserver_1.6.80-4_amd64.zip" target="_blank" rel="noopener">Tigervnc Deb软件包（适用于Ubuntu 16.04.1 - 64位）</a></p><h3 id="步骤二、-安装TigerVNC-Server软件包"><a href="#步骤二、-安装TigerVNC-Server软件包" class="headerlink" title="步骤二、 安装TigerVNC Server软件包"></a>步骤二、 安装TigerVNC Server软件包</h3><p>1、打开终端，进入到刚刚你你下载TigerVNC Server的存放目录，我是直接下载到默认的DownLoads下的，因为下载的是zip文件，记得解压出来，得到deb安装文件。</p><p>2、再输入一下安装命令进行安装（需要su密码）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install -f</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i tigervncserver_1.6.80-4_amd64.deb</span></span><br></pre></td></tr></table></figure><h3 id="步骤三、安装xrdp"><a href="#步骤三、安装xrdp" class="headerlink" title="步骤三、安装xrdp"></a>步骤三、安装xrdp</h3><p>　　打开终端，输入一下命令（需要su密码）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xrdp -y</span><br></pre></td></tr></table></figure><h3 id="步骤四、配置xrdp设置"><a href="#步骤四、配置xrdp设置" class="headerlink" title="步骤四、配置xrdp设置"></a>步骤四、配置xrdp设置</h3><p>　　需要通过xrdp连接到桌面，需要正确配置相关信息并填充到.xsession文件（针对每个用户）或/etc/startwm.sh（针对所有用户），输入如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> unity&gt;~/.xsession</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sed -i.bak <span class="string">'/fi/a #xrdp multi-users \n unity \n'</span> /etc/xrdp/startwm.sh</span></span><br></pre></td></tr></table></figure><h3 id="步骤五、重启xrdp"><a href="#步骤五、重启xrdp" class="headerlink" title="步骤五、重启xrdp"></a><strong>步骤五、重启xrdp</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service xrdp restart</span><br></pre></td></tr></table></figure><h3 id="步骤六、开启桌面共享功能"><a href="#步骤六、开启桌面共享功能" class="headerlink" title="步骤六、开启桌面共享功能"></a>步骤六、开启桌面共享功能</h3><p>　　进入系统-》首选项-》桌面共享，或者直接搜索桌面共享，如图所示</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192507153-638048489.png" alt="img"></p><p>　　将【允许其他人查看您的桌面】这一项勾上，如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192521575-517061538.png" alt="img"></p><p>到这一步基本上已经完成了，接下来就是来测试是否能正常连接到Ubuntu了</p><h1 id="三、xrdp测试连接到Ubuntu"><a href="#三、xrdp测试连接到Ubuntu" class="headerlink" title="三、xrdp测试连接到Ubuntu"></a>三、xrdp测试连接到Ubuntu</h1><p>　1、查看Ubuntu服务器的IP地址，如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192537450-1272034628.png" alt="img"></p><p>　　2、启动Windows远程桌面工具(mstc)，输入Ubuntu的IP地址（192.168.226.131），如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192554731-609673171.png" alt="img"></p><p>　　3、点击连接之后，正常情况会自动跳出xrdp的登录界面，需要我们输入用户名和密码即可，模式选择默认就行，如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192718465-137150594.png" alt="img"></p><p> 　　4、我们可以看到xrdp的实时日志，如图所示：</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192751606-1594868562.png" alt="img"></p><p>　　5、最终我们连接到上了Ubuntu，是不是很熟悉的界面~~（ヾ(๑╹◡╹)ﾉ”）</p><p><img src="https://images2017.cnblogs.com/blog/506829/201709/506829-20170927192821809-1569937933.png" alt="img"></p><p>　　至此，xrdp连接Ubuntu 16.04的所有步骤已完成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通过XDRP实现Windows远程访问&quot;&gt;&lt;a href=&quot;#通过XDRP实现Windows远程访问&quot; class=&quot;headerlink&quot; title=&quot;通过XDRP实现Windows远程访问&quot;&gt;&lt;/a&gt;通过XDRP实现Windows远程访问&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Ubuntu" scheme="https://nymrli.top/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>自动化运维工具Ansible</title>
    <link href="https://nymrli.top/2019/07/08/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7Ansible/"/>
    <id>https://nymrli.top/2019/07/08/自动化运维工具Ansible/</id>
    <published>2019-07-08T06:45:45.000Z</published>
    <updated>2019-08-22T12:47:19.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动化运维工具Ansible笔记"><a href="#自动化运维工具Ansible笔记" class="headerlink" title="自动化运维工具Ansible笔记"></a>自动化运维工具Ansible笔记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​        ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。<br>　　ansible是基于 paramiko 开发的,并且基于模块化工作，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。ansible不需要在远程主机上安装client/agents，因为它们是基于ssh来和远程主机通讯的。ansible目前已经已经被红帽官方收购，是自动化运维工具中大家认可度最高的，并且上手容易，学习简单。是每位运维工程师必须掌握的技能之一。</p><h2 id="ansible-特点"><a href="#ansible-特点" class="headerlink" title="ansible 特点"></a>ansible 特点</h2><ol><li>部署简单，只需在主控端部署Ansible环境，被控端无需做任何操作；</li><li>默认使用<strong>SSH协议</strong>对设备进行管理；</li><li>有大量常规运维操作模块，可实现日常绝大部分操作；</li><li>配置简单、功能强大、扩展性强；</li><li>支持API及自定义模块，<strong>可通过Python轻松扩展</strong>；</li><li>通过Playbooks来定制强大的配置、状态管理；</li><li>轻量级，<strong>无需在客户端安装agent(代理)</strong>，更新时，只需在操作机上进行一次更新即可；</li><li>提供一个功能强大、操作性强的<strong>Web管理界面和REST API接口</strong>——AWX平台。</li><li>Ansible适用于中小型应用环境；SaltStack适合大型（Ansible由于不需要代理,只是通过ssh,因此只能性能不如Saltstack高）</li></ol><h2 id="Ansible安装"><a href="#Ansible安装" class="headerlink" title="Ansible安装"></a>Ansible安装</h2><p>法1.在已有<code>python-pip</code>的情况下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install ansible</span></span><br></pre></td></tr></table></figure><p>法2:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo apt-add-repository ppa:ansible/ansible</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ansible</span><br></pre></td></tr></table></figure><p>如果安装失败请换源<code>sudo sed  -i  -re  &#39;s/\w+\.archive\.ubuntu\.com/archive.ubuntu.com/g&#39;  /etc/apt/sources.list</code>,更新安装库<code>sudo apt-get update</code></p><h2 id="ansible-架构图"><a href="#ansible-架构图" class="headerlink" title="ansible 架构图"></a>ansible 架构图</h2><p><img src="https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171205163000628-69838828.png" alt="img"><br>　　上图中我们看到的主要模块如下：</p><blockquote><p><code>Ansible</code>：Ansible核心程序。<br><code>HostInventory</code>：<strong>主机清单</strong> , 记录由Ansible管理的主机信息，包括端口、密码、ip等。<br><code>Playbooks</code>：“剧本”YAML格式文件，多个任务定义在一个文件中，定义主机需要调用哪些模块来完成的功能。<br><code>CoreModules</code>：<strong>核心模块</strong>，主要操作是通过调用核心模块来完成管理任务。<br><code>CustomModules</code>：自定义模块，完成核心模块无法完成的功能，支持多种语言。<br><code>ConnectionPlugins</code>：连接插件，Ansible和Host通信使用</p></blockquote><h2 id="ansible配置文件查找顺序"><a href="#ansible配置文件查找顺序" class="headerlink" title="ansible配置文件查找顺序"></a>ansible配置文件查找顺序</h2><ol><li>检查环境变量<code>ANSIBLE_CONFIG</code>指向的路径文件(export ANSIBLE_CONFIG=/etc/ansible.cfg)；</li><li>HOME目录下的配置文件<code>~/.ansible.cfg</code></li><li>检查当前目录下的ansible.cfg配置文件；</li><li><code>/etc/ansible.cfg</code>检查etc目录的配置文件。</li></ol><h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><ul><li>模块化：调用特定的模块，完成特定任务</li><li>有Paramiko，PyYAML，Jinja2（模板语言）三个关键模块支持自定义模块</li><li>基于Python语言实现</li><li>部署简单，基于python和SSH（默认已安装），agentless安全，基于OpenSSH支持playbook编排任务</li><li><strong>幂等性</strong>：一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况</li><li>无需代理不依赖PKI（无需ssl）可使用任何编程语言写模块</li><li>YAML格式，编排任务，支持丰富的数据结构</li><li>较强大的多层解决方案</li></ul><h2 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式:"></a>管理方式:</h2><ul><li>Ad-Hoc，及Ansible命令，主要用于临时命令使用场景</li><li>Ansible-Playbook，脚本，用于长期规划好，大型项目的场景，需要有提前的规划</li></ul><p>Ansible-playbook（剧本）执行过程：</p><ul><li>将已有编排好的任务集写入Ansible-Playbook</li><li>通过ansible-playbook命令分拆任务集至逐条ansible命令，按预定规则逐条执行</li></ul><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>/etc/ansible/ansible.cfg 主配置文件，配置ansible工作特性<br>/etc/ansible/hosts 主机清单<br>/etc/ansible/roles/存放角色的目录</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>/usr/bin/ansible 主程序，临时命令执行工具<br>/usr/bin/ansible-doc 查看配置文档，模块功能查看工具<br>/usr/bin/ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台<br>/usr/bin/ansible-playbook定制自动化任务，编排剧本工具/usr/bin/ansible-pull远程执行命令的工具<br>/usr/bin/ansible-vault 文件加密工具<br>/usr/bin/ansible-console 基于console界面与用户交互的执行工具</p><p>1.设置被管理的主机清单<code>vim /etc/ansible/hosts</code></p><p>2.1口令验证方式.<code>ansible 192.168.30.101 -m ping -k</code>用账号密码去确认受控端的身份</p><p>▲如果出现了这样的情况,需要先安装sshpass , <code>sudo apt install sshpass</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.100.180 | FAILED! =&gt; &#123;</span><br><span class="line">    "failed": true, </span><br><span class="line">    "msg": "ERROR! to use the 'ssh' connection type with passwords, you must install the sshpass program"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2基于key验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-copy-id 192.168.30.101</span></span><br><span class="line"></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/xxxxxx/): </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in xxxxxxxxx.</span><br><span class="line">Your public key has been saved in xxxxx.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:xxxxxxxxxxxxxx</span><br><span class="line">The key's randomart image is:</span><br></pre></td></tr></table></figure><p>如果设置了passphrase,那么链接时需要输入passphrase,如果是ad-hoc就相当麻烦,而playbooks中有解决方法</p><h2 id="ad-hoc使用"><a href="#ad-hoc使用" class="headerlink" title="ad-hoc使用"></a>ad-hoc使用</h2><p>将<code>host_key_checking</code>取消注释,否则链接对象必须在known_hosts中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/ansible/ansible.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> uncomment this to <span class="built_in">disable</span> SSH key host checking</span></span><br><span class="line"><span class="meta">#</span><span class="bash">host_key_checking = False</span></span><br></pre></td></tr></table></figure><p>显示日志,取消注释<code>log_path = /var/log/ansible.log</code></p><p>△.ansible不是长期执行的服务,不长期执行,因此修改配置后不需要重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ansible &lt;host-pattern&gt;[-m module_name][-a args]</span><br><span class="line"></span><br><span class="line">ansible dbsrvs -m command -a 'ls /root'-u wang-k -b-K</span><br><span class="line"><span class="meta">#</span><span class="bash"> -u 以wang的身份登录,-b将wang切换成root,-K 输入root密码.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -m 指定模块名,-a指定模块参数</span></span><br></pre></td></tr></table></figure><h2 id="ansible的Host-pattern即匹配主机的列表"><a href="#ansible的Host-pattern即匹配主机的列表" class="headerlink" title="ansible的Host-pattern即匹配主机的列表"></a>ansible的Host-pattern即匹配主机的列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">All：表示所有Inventory中的所有主机</span><br><span class="line">ansible all-m ping</span><br><span class="line">：通配符</span><br><span class="line">ansible&quot;&quot;-m ping</span><br><span class="line">ansible 192.168.1.-m ping</span><br><span class="line">ansible&quot;srvs&quot;-m ping</span><br><span class="line">或关系</span><br><span class="line">ansible&quot;websrvsiappsrvs&quot;-m ping</span><br><span class="line">ansible&quot;192.168.1.10：192.168.1.20&quot;-m ping</span><br></pre></td></tr></table></figure><p>逻辑与<br><code>ansible&quot;websrvs:&amp;dbsrvs&quot;-m ping</code>在websrvs组并且在dbsrvs组中的主机,单引号、双引号都行</p><p>逻辑非<br><code>ansible websrvs:ldbsrvs&#39;-m ping</code>在websrvs组，但不在dbsrvs组中的主机<br>注意：<strong>此处为单引号</strong></p><p>综合逻辑<br><code>ansible‘websrvs:dbsrvs:&amp;appsrvs:lftpsrvs&#39;-m ping</code></p><p>正则表达式<br><code>ansible&quot;websrvs:&amp;dbsrvs&quot;-m ping</code></p><p><code>ansible&quot;~（webldb）.*\.magedu\.com&quot;-m ping</code></p><h2 id="ansible-command"><a href="#ansible-command" class="headerlink" title="ansible command"></a>ansible command</h2><ul><li>creates=<ul><li>存在,不执行</li></ul></li><li>removes=<ul><li>不存在,不执行</li></ul></li><li>chdir=<ul><li>切换目录后执行</li></ul></li></ul><h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><ul><li>command</li><li>shell<ul><li><code>ansible all -m shel1-a &#39;getenforce&#39;</code></li></ul></li><li>script</li><li>copy<ul><li><code>ansible all -m copy -a&#39;src=/root/ansible/selinux dest=/etc/selinux/config backup=yes&#39;</code></li><li><code>ansible all -m copy-a &#39;src=/etc/shadow dest=/data/mode=000 owner=wang&#39;</code></li></ul></li><li>fetch<ul><li><code>ansible srv-m fetch -a &#39;src=/root/a. sh dest=/data/scripts&#39;</code></li></ul></li><li>file<ul><li>文件操作,删除、创建</li></ul></li><li>unachieve、achieve<ul><li>压缩解压</li></ul></li><li>cron<ul><li>开启<code>ansible all-m cron -a &#39;minute=* weekday=1,3,5 jcb=&quot;/usr/bin/wall FBI warning&quot; name=warningcron&#39;</code></li><li>禁用<code>ansible all -m cron -a &#39;disabled=true job=&quot;/usr/bin/wall FBI warning&quot;name=warningcron&#39;</code>、启用<code>ansible all -m cron -a &#39;disabled=falsejob=&quot;/usr/bin/wall FBI warning&quot;name=warningcron&#39;</code></li><li>删除<code>ansible all -m cron -a &#39;job=&quot;/usr/bin/wall FBI warning&quot;name=warningcron state=absent&#39;</code></li></ul></li><li>apt、yum</li><li>user</li><li>group</li><li>service<ul><li><code>service:name=httpd state=started enabled=yes</code></li></ul></li><li>setup<ul><li><code>ansible websrvs -m setup -a &#39;filter=*address*&#39;</code></li></ul></li><li>template(不能放在ad-hoc)中,只能在playbook中使用</li></ul><p>command模块在针对<strong>管道</strong>、<strong>重定向有*…</strong>有问题==&gt;使用shell模块</p><p><a href="https://www.cnblogs.com/ExzaiTin/p/7918415.html" target="_blank" rel="noopener">常用模块介绍</a></p><h2 id="系列命令"><a href="#系列命令" class="headerlink" title="系列命令"></a>系列命令</h2><h3 id="galaxy"><a href="#galaxy" class="headerlink" title="galaxy"></a>galaxy</h3><p><code>ansible-galaxy install geerlingguy.nginx</code>    其中<code>geerlingguy</code>为角色在<code>./ansible/roles/</code></p><h3 id="playbooks"><a href="#playbooks" class="headerlink" title="playbooks"></a>playbooks</h3><blockquote><p>Yaml</p><p>YAML Ain’t Markup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</p></blockquote><h4 id="核心元素"><a href="#核心元素" class="headerlink" title="核心元素"></a>核心元素</h4><ul><li>Hosts 执行的远程主机列表</li><li>Tasks 任务集</li><li>Varniables 内置变量或自定义变量在playbook中调用Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件Handlers 和notity结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行</li><li>tags 标签指定某条任务执行，用于选择运行playbook中的部分代码。<ul><li>ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断<br>ansible-playbook-t tagsname useradd.yml</li></ul></li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>加密<code>ansible-vault encrypt hello.yml</code></p><p>解密查看<code>ansible-vault view hello.yml</code></p><p>重新制定口令<code>ansible-vault rekey hello.yml</code></p><h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p>如果命令或脚本的退出码不为零，可以使用如下方式替代</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span><span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line"><span class="attr">    shell:</span><span class="string">/usr/bin/somecommand</span> <span class="string">||/bin/true</span></span><br></pre></td></tr></table></figure><p>或者使用ignore_errors来忽略错误信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tasks：</span></span><br><span class="line"><span class="attr">  - name:</span><span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line"><span class="attr">    shell:</span><span class="string">/usr/bin/somecommand</span></span><br><span class="line"><span class="attr">ignore_errors:</span><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="运行playbook的方式"><a href="#运行playbook的方式" class="headerlink" title="运行playbook的方式"></a>运行playbook的方式</h2><p><code>ansible-playbook &lt;filename.yml&gt;..[options]</code><br>常见选项<br><code>-check(-C)</code>只检测可能会发生的改变，但不真正执行操作<br><code>--list-hosts</code>列出运行任务的主机<br><code>--limit</code>主机列表只针对主机列表中的主机执行<br><code>-V</code>显示过程-vw-vwv更详细</p><h2 id="handlers和notify"><a href="#handlers和notify" class="headerlink" title="handlers和notify"></a>handlers和notify</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span><span class="string">instal1</span> <span class="string">httpd</span> <span class="string">package</span> </span><br><span class="line"><span class="attr">    yum:</span><span class="string">name=httpd</span> </span><br><span class="line"><span class="attr">  - name:</span><span class="string">copy</span> <span class="string">conf</span> <span class="string">file</span> <span class="attr">copy:src=files/httpd.conf</span> <span class="string">dest=/etc/httpd/conf/backup=yes</span> </span><br><span class="line"><span class="attr">    notify:</span><span class="string">restart</span> <span class="string">service</span> </span><br><span class="line"><span class="attr">  - name:</span><span class="string">start</span> <span class="string">service</span></span><br><span class="line"><span class="attr">    service:</span><span class="string">name=httpd</span> <span class="string">state=started</span> <span class="string">enabled=yes</span> </span><br><span class="line"><span class="attr">  handlers:</span></span><br><span class="line"><span class="attr">    - name:</span><span class="string">restart</span> <span class="string">service</span> </span><br><span class="line"><span class="attr">      service:</span><span class="string">name=httpd</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure><p>标签</p><blockquote><p>指定标签来执行指定任务</p></blockquote><p><code>ansible-playbook -t  rshttp,xxxx httpd.yml</code></p><h2 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h2><p>jinjia2语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; var &#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>法一：ansible setup facts 远程主机的所有变量都可直接调用</li><li>法二：在<code>/etc/ansible/hosts</code>中定义普通变量：主机组中主机单独定义，优先级高于公共变量公共（组）变量：针对主机组中所有主机定义统一变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[websrvs]</span><br><span class="line">192.168.30.101 http_port=81</span><br><span class="line">192.168.30.102 http_port=82</span><br><span class="line">[websrvs:vars]</span><br><span class="line">nodename=www </span><br><span class="line">domainname=magedu.com</span><br></pre></td></tr></table></figure><ul><li>法三：<code>ansible-playbook -e &#39;var=xxx&#39; app.html</code>，优先级比法二高</li><li>法四:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> </span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  vars:</span> </span><br><span class="line"><span class="attr">    - var:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> </span><br><span class="line"><span class="attr">       yum:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="迭代机制"><a href="#迭代机制" class="headerlink" title="迭代机制"></a>迭代机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - name:</span><br><span class="line">    file: name=/data/&#123;&#123; item &#125;&#125;</span><br><span class="line">    with_items: </span><br><span class="line">      - file1</span><br><span class="line">      - file2</span><br><span class="line">      - file3</span><br></pre></td></tr></table></figure><h3 id="迭代嵌套自变量"><a href="#迭代嵌套自变量" class="headerlink" title="迭代嵌套自变量"></a>迭代嵌套自变量</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">websrvs</span> </span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span> </span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">add</span> <span class="string">some</span> <span class="string">groups</span> </span><br><span class="line"><span class="attr">    group:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item</span> <span class="string">]&#125;</span> <span class="string">state=present</span> </span><br><span class="line"><span class="attr">    with_items:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">group1</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">group2</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">group3</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">add</span> <span class="string">some</span> <span class="string">users</span> </span><br><span class="line"><span class="attr">      user:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item.</span> <span class="string">name</span> <span class="string">]&#125;</span> <span class="string">group=&#123;&#123;</span> <span class="string">item.</span> <span class="string">group</span> <span class="string">)&#125;</span> <span class="string">state=present</span> </span><br><span class="line">      <span class="string">with</span> <span class="attr">items:</span></span><br><span class="line"><span class="bullet">        -</span><span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">user1,</span> <span class="attr">group:'</span> <span class="string">group1'&#125;</span></span><br><span class="line"><span class="bullet">        -</span><span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'user2, group:'</span> <span class="string">group2'&#125;</span></span><br><span class="line"><span class="bullet">        -</span><span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'user3'</span><span class="string">,</span> <span class="attr">group:'</span> <span class="string">group3'&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for vhost in nginx_vhosts%&#125;</span><br><span class="line">server&#123;</span><br><span class="line">listen&#123;&#123; vhost &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span><span class="string">websrvs</span> </span><br><span class="line"><span class="attr">  remote_user:</span><span class="string">root</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">      - listen_port:</span><span class="number">81</span></span><br><span class="line"><span class="attr">      - listen_port:</span><span class="number">82</span></span><br><span class="line"><span class="attr">      - listen_port:</span><span class="number">83</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span><span class="string">copy</span> <span class="string">conf</span> </span><br><span class="line"><span class="attr">    template:</span><span class="string">src=forl.conf.j2</span> <span class="string">dest=/data/for1.conf</span></span><br></pre></td></tr></table></figure><h2 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h2><blockquote><p>ansilbe自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用<strong>include</strong>指令即可。简单来讲，roles就是通过分别将<strong>变量</strong>、<strong>文件</strong>、<strong>任务</strong>、<strong>模板</strong>及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中</p></blockquote><p>复杂场景：建议使用roles，代码复用度高</p><ul><li>变更指定主机或主机组</li><li>如命名不规范维护和传承成本大</li><li>某些功能需多个Playbook，通过Includes即可实现</li></ul><p>roles目录结构：<br>playbook.yml<br>roles/<br>project/<br>tasks/<br>files/<br>vars/不常用<br>default/不常用<br>templates/<br>handlers/<br>meta/不常用</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Ansible-配置SSH公钥认证"><a href="#Ansible-配置SSH公钥认证" class="headerlink" title="Ansible 配置SSH公钥认证"></a>Ansible 配置SSH公钥认证</h3><p>安装好Ansible之后，要开始工作，还需要创建一个被控制主机列表清单.默认读取/etc/ansible/hosts,如果该文件不存在，则要收到进行创建.</p><p> 也可以通过环境变量 <strong>ANSIBLE_INVENTORY</strong> 来设置默认清单文件,1.9版本之前用 <strong>ANSIBLE_HOSTS</strong><code>export ANSIBLE_INVENTORY=~/ansible_hosts</code>  </p><p><strong>创建SSH认证文件</strong></p><blockquote><p>该操作是在控制主机中进行。</p></blockquote><p>SSH认证文件创建成功之后，将控制主机的公钥文件 id_rsa.pub 添加到被控制主机的~/.ssh/authorized_keys。</p><p><code>\#  ~</code>指的是控制主机和被控制主机通信的用户家目录。</p><p><code>\#  id_rsa</code> 是控制主机的私钥文件，要严格保管。</p><p><code>\#  id_rsa.pub</code>是控制主机的公钥文件，可随意分发。</p><p>法一:<code>ansible all -m shell -a &quot;cat /tmp/authorized_keys &gt;&gt; /root/.ssh/authorized_keys&quot; -k</code></p><p>▲注意</p><blockquote><p><strong>如果被控制主机中用户家目录中不存在.ssh目录，就创建。</strong></p><p><strong>然后将上传的公钥文件追加到用户的authorized_keys文件中</strong></p></blockquote><p>法二: </p><p>通过authorized_key模块来进行添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible para -i /tmp/inventory.txt -m authorized_key -a <span class="string">"user=root key='&#123;&#123; lookup('file','/root/.ssh/id_rsa.pub') &#125;&#125;'"</span> -k</span><br></pre></td></tr></table></figure><blockquote><p><code>lookup(&#39;file&#39;,&#39;/root/.ssh/id_rsa.pub&#39;)</code> 是读取/root/.ssh/id_rsa.pub的内容</p></blockquote><p>一键挂载NFS:</p><p><code>ansible full -m mount -a &quot;name=/data src=192.168.100.179:/data fstype=nfs state=mounted&quot; -b -K</code></p><p>挂载需要用SUDO权限,所以-K必不可少.同时,在这之前已经使用过ssh进行了配对因此不需要输入登录用户密码.</p><p><code>ss -ntl | grep 80</code></p><p><code>vim /etc/sysconfig/network-scripts/ifcfg-eth0</code>建议可以使用Alias</p><p><code>service network restart</code>重启网络服务</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自动化运维工具Ansible笔记&quot;&gt;&lt;a href=&quot;#自动化运维工具Ansible笔记&quot; class=&quot;headerlink&quot; title=&quot;自动化运维工具Ansible笔记&quot;&gt;&lt;/a&gt;自动化运维工具Ansible笔记&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="运维" scheme="https://nymrli.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
</feed>
