<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>学点Kotlin · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">学点Kotlin</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2021/09/13</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Kotlin"> Kotlin</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">5,682</span> | Reading time: <span class="post-count">23</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h2 id="Kotlin-基础语法"><a href="#Kotlin-基础语法" class="headerlink" title="Kotlin 基础语法"></a>Kotlin 基础语法</h2><p>Kotlin 文件以 .kt 为后缀。</p>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>函数定义使用关键字 fun，参数格式为：参数 : 类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;   <span class="comment">// Int 参数，返回值 Int</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表达式作为函数体，返回类型自动推断：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a + b   <span class="comment">// public 方法则必须明确写出返回类型</span></span><br></pre></td></tr></table></figure>
<p>无返回值的函数(类似Java中的void)：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Unit</span> &#123; </span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> &#123; </span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可变长参数函数"><a href="#可变长参数函数" class="headerlink" title="可变长参数函数"></a>可变长参数函数</h4><p>函数的变长参数可以用 <strong>vararg</strong> 关键字进行标识：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">vars</span><span class="params">(<span class="keyword">vararg</span> v:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vt <span class="keyword">in</span> v)&#123;</span><br><span class="line">        print(vt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    vars(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)  <span class="comment">// 输出12345</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda(匿名函数)"></a>lambda(匿名函数)</h4><p>lambda表达式使用实例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sumLambda: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x,y -&gt; x+y&#125;</span><br><span class="line">    println(sumLambda(<span class="number">1</span>,<span class="number">2</span>))  <span class="comment">// 输出 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NULL检查机制"><a href="#NULL检查机制" class="headerlink" title="NULL检查机制"></a>NULL检查机制</h3><p>Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型后面加?表示可为空</span></span><br><span class="line"><span class="keyword">var</span> age: String? = <span class="string">"23"</span> </span><br><span class="line"><span class="comment">// 不能为空，否则抛出空指针异常</span></span><br><span class="line"><span class="keyword">val</span> ages = age!!.toInt()</span><br><span class="line"><span class="comment">//不做处理返回 null</span></span><br><span class="line"><span class="keyword">val</span> ages1 = age?.toInt()</span><br><span class="line"><span class="comment">//age为空返回-1</span></span><br><span class="line"><span class="keyword">val</span> ages2 = age?.toInt() ?: <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。</p>
<p>当 str 中的字符串内容不是一个整数时, 返回 null:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kotlin-基本数据类型"><a href="#Kotlin-基本数据类型" class="headerlink" title="Kotlin 基本数据类型"></a>Kotlin 基本数据类型</h2><p> Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。 </p>
<p><strong>Kotlin 中没有基础数据类型，只有封装的数字类型</strong>。你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所以在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。</p>
<p>在 Kotlin 中，<u>三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小</u>。</p>
<ul>
<li><code>var x = 1..16</code>:  [1,16]</li>
<li><code>var x = 1 until 16</code>: [1, 16)</li>
</ul>
<h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>可变变量定义：var 关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span><br><span class="line"><span class="keyword">val</span> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span><br></pre></td></tr></table></figure>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><ul>
<li><code>$</code> 表示一个变量名或者变量值</li>
<li><code>$varName</code>表示变量值</li>
<li><code>${varName.fun()}</code>表示变量的方法返回值:</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span><span class="comment">// 模板中的简单名称：val s1 = "a is $a" a = 2// 模板中的任意表达式：val s2 = "$&#123;s1.replace("is", "was")&#125;, but now is $a"</span></span><br></pre></td></tr></table></figure>
<h2 id="Kotlin-条件控制"><a href="#Kotlin-条件控制" class="headerlink" title="Kotlin 条件控制"></a><a href="https://www.runoob.com/kotlin/kotlin-condition-control.html" target="_blank" rel="noopener">Kotlin 条件控制</a></h2><h2 id="Kotlin-循环控制"><a href="#Kotlin-循环控制" class="headerlink" title="Kotlin 循环控制"></a>Kotlin 循环控制</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对任何提供迭代器（iterator）的**对象**进行遍历for (item in collection) print(item)// 通过**索引**遍历一个数组或者一个 listfor (i in array.indices) &#123;    print(array[i])&#125;// 索引+值，相当于Python中的enumeratefor ((index, value) in array.withIndex()) &#123;    println("the element at $index is $value")&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while循环while( 布尔表达式 ) &#123;  //循环内容&#125;// do循环do &#123;       //代码语句&#125;while(布尔表达式);</span></span><br></pre></td></tr></table></figure>
<h3 id="返回和跳转"><a href="#返回和跳转" class="headerlink" title="返回和跳转"></a>返回和跳转</h3><p>Kotlin 有三种结构化跳转表达式：</p>
<ul>
<li><em>return</em>。默认从最直接包围它的函数或者匿名函数返回。</li>
<li><em>break</em>。终止最直接包围它的循环。</li>
<li><em>continue</em>。继续下一次最直接包围它的循环。</li>
</ul>
<h3 id="Break-和-Continue-的跳转标签"><a href="#Break-和-Continue-的跳转标签" class="headerlink" title="Break 和 Continue 的跳转标签"></a>Break 和 Continue 的跳转标签</h3><p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为<code>标识符+跟 @</code>，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;        <span class="keyword">if</span> (……) <span class="keyword">break</span><span class="symbol">@loop</span>    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>标签限制使得 break 跳转到刚好位于该标签指定循环的后面执行点。 continue 继续标签指定的循环的下一次迭代。 </p>
<h4 id="标签处返回"><a href="#标签处返回" class="headerlink" title="标签处返回"></a>标签处返回</h4><p>Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 <strong>标签处返回的最重要的一个用途就是从 lambda 表达式中返回</strong>。回想一下我们这么写的时候：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    ints.forEach &#123;        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span>        print(it)    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    ints.forEach <span class="symbol">lit@</span> &#123;        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@lit</span>        print(it)    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    ints.forEach &#123;        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@forEach</span>        print(it)    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    ints.forEach(<span class="function"><span class="title">fun</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;        <span class="keyword">if</span> (value == <span class="number">0</span>) <span class="keyword">return</span>        print(value)    &#125;)&#125;</span><br></pre></td></tr></table></figure>
<p>当要返一个回值的时候，解析器优先选用标签限制的 return，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return@a 1</span><br></pre></td></tr></table></figure>
<p>意为”从标签 @a 返回 1”，而不是”返回一个标签标注的表达式 (@a 1)”。</p>
<h2 id="Kotlin-类和对象"><a href="#Kotlin-类和对象" class="headerlink" title="Kotlin 类和对象"></a>Kotlin 类和对象</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> <span class="keyword">constructor</span></span>(name: String) &#123;    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"Foo"</span>) &#125; <span class="comment">// 成员函数    var url: String = ……            // 次构造函数    constructor (name: String, alexa: Int) : this(name) &#123;        println("Alexa 排名 $alexa")    &#125;    var lastName: String = "zhang"        get() = field.toUpperCase()   // 将变量赋值后转换为大写        set    var no: Int = 100        get() = field                // 后端变量        set(value) &#123;            if (value &lt; 10) &#123;       // 如果传入的值小于 10 返回该值                field = value            &#125; else &#123;                field = -1         // 如果传入的值大于等于 10 返回 -1            &#125;        &#125;    var heiht: Float = 145.4f        private set    &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="对象的声明"><a href="#对象的声明" class="headerlink" title="对象的声明"></a>对象的声明</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> site = Runoob() <span class="comment">// Kotlin 中没有 new 关键字site.name           // 使用 . 号来引用site.url</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Koltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123;    init &#123;        println(<span class="string">"FirstName is <span class="variable">$firstName</span>"</span>)    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(firstName: String) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>次构造函数</p>
<p>类也可以有二级构造函数，需要加前缀 constructor:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;     constructor(parent: Person) &#123;        parent.children.add(this)     &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name: String) &#123;    constructor (name: String, age:Int) : this(name) &#123;        // 初始化...    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class DontCreateMe private constructor () &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]    [&lt;getter&gt;]    [&lt;setter&gt;]<span class="comment">// var变量可设置getter 和 setter, 都是可选// 如果属性类型可以从初始化语句或者类的成员函数中推断出来，那就可以省去类型，val不允许设置setter函数，因为它是只读的。var allByDefault: Int? // 错误: 需要一个初始化语句, 默认实现了 getter 和 setter 方法var initialized = 1    // 类型为 Int, 默认实现了 getter 和 setterval simple: Int?       // 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化val inferredType = 1   // 类型为 Int 类型,默认实现 getter</span></span><br></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象是面向对象编程的特征之一，类本身，或类中的部分成员，都可以声明为abstract的。抽象成员在类中不存在具体的实现。</p>
<p>注意：无需对抽象类或抽象成员标注open注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class Base &#123;    open fun f() &#123;&#125;&#125;abstract class Derived : Base() &#123;    override abstract fun f()&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>我们可以把类嵌套在其他类中，看以下实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;                  // 外部类    private val bar: Int = 1    class Nested &#123;             // 嵌套类        fun foo() = 2    &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>内部类使用 inner 关键字来表示。</p>
<p>内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span>    <span class="keyword">var</span> v = <span class="string">"成员属性"</span>    <span class="comment">/**嵌套内部类**/</span>    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar  <span class="comment">// 访问外部类成员        fun innerTest() &#123;            var o = this@Outer //获取外部类的成员变量            println("内部类可以引用外部类的成员，例如：" + o.v)        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>使用对象表达式来创建匿名内部类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    <span class="keyword">var</span> v = <span class="string">"成员属性"</span>    <span class="function"><span class="keyword">fun</span> <span class="title">setInterFace</span><span class="params">(test: <span class="type">TestInterFace</span>)</span></span> &#123;        test.test()    &#125;&#125;<span class="comment">/** * 定义接口 */</span><span class="class"><span class="keyword">interface</span> <span class="title">TestInterFace</span> </span>&#123;    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#125;<span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;    <span class="keyword">var</span> test = Test()    <span class="comment">/**     * 采用对象表达式来创建接口对象，即匿名内部类的实例。     */</span>    test.setInterFace(<span class="keyword">object</span> : TestInterFace &#123;        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;            println(<span class="string">"对象表达式创建匿名内部类的实例"</span>)        &#125;    &#125;)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h3><p>类的修饰符包括 classModifier 和<em>accessModifier</em>:</p>
<ul>
<li><p>classModifier: 类属性修饰符，标示类本身特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract    // 抽象类  final       // 类不可继承，默认属性enum        // 枚举类open        // 类可继承，类默认是final的annotation  // 注解类</span><br></pre></td></tr></table></figure>
</li>
<li><p>accessModifier: 访问权限修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private    // 仅在同一个文件中可见protected  // 同一个文件中或子类可见public     // 所有调用的地方都可见internal   // 同一个模块中可见</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Kotlin-继承"><a href="#Kotlin-继承" class="headerlink" title="Kotlin 继承"></a>Kotlin 继承</h2><p>Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：</p>
<p>Any 默认提供了三个函数：</p>
<ul>
<li>equals()</li>
<li>hashCode()</li>
<li>toString()</li>
</ul>
<p>注意：Any 不是 java.lang.Object。</p>
<p>如果一个类要被继承，可以使用 open 关键字进行修饰。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="built_in">Int</span>)           <span class="comment">// 定义基类class Derived(p: Int) : Base(p)</span></span><br></pre></td></tr></table></figure>
<h2 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="子类有主构造函数"><a href="#子类有主构造函数" class="headerlink" title="子类有主构造函数"></a>子类有主构造函数</h3><p>如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class Person(var name : String, var age : Int)&#123;// 基类&#125;class Student(name : String, age : Int, var no : String, var score : Int) : Person(name, age) &#123;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123;    val s =  Student(&quot;Runoob&quot;, 18, &quot;S12346&quot;, 89)    println(&quot;学生名： $&#123;s.name&#125;&quot;)    println(&quot;年龄： $&#123;s.age&#125;&quot;)    println(&quot;学生号： $&#123;s.no&#125;&quot;)    println(&quot;成绩： $&#123;s.score&#125;&quot;)&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生名： Runoob年龄： 18学生号： S12346成绩： 89</span><br></pre></td></tr></table></figure>
<h3 id="子类没有主构造函数"><a href="#子类没有主构造函数" class="headerlink" title="子类没有主构造函数"></a>子类没有主构造函数</h3><p>如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person &#123;    constructor</span></span>(ctx: Context) : <span class="keyword">super</span>(ctx) &#123;    &#125;     <span class="keyword">constructor</span>(ctx: Context, attrs: AttributeSet) : <span class="keyword">super</span>(ctx,attrs) &#123;    &#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**用户基类**/</span><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">study</span><span class="params">()</span></span>&#123;       <span class="comment">// 允许子类重写        println("我毕业了")    &#125;&#125;/**子类继承 Person 类**/class Student : Person() &#123;    override fun study()&#123;    // 重写方法        println("我在读大学")    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val s =  Student()    s.study();&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果有多个相同的方法（继承或者实现自其他类，如A、B类），则必须要重写该方法，使用super范型去选择性地调用父类的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class A &#123;    open fun f () &#123; print(&quot;A&quot;) &#125;    fun a() &#123; print(&quot;a&quot;) &#125;&#125;interface B &#123;    fun f() &#123; print(&quot;B&quot;) &#125; //接口的成员变量默认是 open 的    fun b() &#123; print(&quot;b&quot;) &#125;&#125;class C() : A() , B&#123;    override fun f() &#123;        super&lt;A&gt;.f()//调用 A.f()        super&lt;B&gt;.f()//调用 B.f()    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val c =  C()    c.f();&#125;</span><br></pre></td></tr></table></figure>
<p>C 继承自 a() 或 b(), C 不仅可以从 A 或则 B 中继承函数，而且 C 可以继承 A()、B() 中共有的函数。此时该函数在中只有一个实现，为了消除歧义，该函数必须调用A()和B()中该函数的实现，并提供自己的实现。</p>
<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AB</span><br></pre></td></tr></table></figure>
<h3 id="属性重写"><a href="#属性重写" class="headerlink" title="属性重写"></a>属性重写</h3><p>属性重写使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class Foo &#123;    open val x: Int get &#123; …… &#125;&#125;class Bar1 : Foo() &#123;    override val x: Int = ……&#125;</span><br></pre></td></tr></table></figure>
<p>注：可以用一个var属性重写一个val属性，但是反过来不行。</p>
<h2 id="Kotlin-接口"><a href="#Kotlin-接口" class="headerlink" title="Kotlin 接口"></a>Kotlin 接口</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>    <span class="comment">// 未实现    fun foo() &#123;  //已实现      // 可选的方法体      println("foo")    &#125;    // 接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性：    var name:String //name 属性, 抽象的&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>一个类或者对象可以实现一个或多个接口。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;    override fun bar</span></span>() &#123;        <span class="comment">// 方法体    &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Kotlin-扩展"><a href="#Kotlin-扩展" class="headerlink" title="Kotlin 扩展"></a>Kotlin 扩展</h2><blockquote>
<p>Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。</p>
<p>扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。</p>
</blockquote>
<h3 id="将函数扩展"><a href="#将函数扩展" class="headerlink" title="将函数扩展"></a>将函数扩展</h3><p>扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式：</p>
<ul>
<li>receiverType：表示函数的接收者，也就是函数扩展的对象</li>
<li>functionName：扩展函数的名称</li>
<li>params：扩展函数的参数，可以为NULL</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数扩展原型fun receiverType.functionName(params)&#123;    body&#125;class User(var name:String)/**扩展函数**/fun User.Print()&#123;    print("用户名 $name")&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="扩展函数是静态解析的"><a href="#扩展函数是静态解析的" class="headerlink" title="扩展函数是静态解析的"></a>扩展函数是静态解析的</h4><p>扩展函数是<strong>静态解析</strong>的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由<strong>调用函数的的对象表达式来决定</strong>的，而不是动态的类型决定的:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Cclass</span> <span class="title">D</span>: <span class="type">C</span></span>()<span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span>   <span class="comment">// 扩展函数 foofun D.foo() = "d"   // 扩展函数 foofun printFoo(c: C) &#123;    println(c.foo())  // 类型是 C 类&#125;fun main(arg:Array&lt;String&gt;)&#123;    printFoo(D())&#125;// 输出c</span></span><br></pre></td></tr></table></figure>
<p> 若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。 </p>
<h3 id="扩展一个空对象"><a href="#扩展一个空对象" class="headerlink" title="扩展一个空对象"></a>扩展一个空对象</h3><p>在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun Any?.toString(): String &#123;    if (this == null) return &quot;null&quot;    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()    // 解析为 Any 类的成员函数    return toString()&#125;fun main(arg:Array&lt;String&gt;)&#123;    var t = null    println(t.toString())&#125;</span><br></pre></td></tr></table></figure>
<p>实例执行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null</span><br></pre></td></tr></table></figure>
<p>扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val Foo.bar = 1 // 错误：扩展属性不能有初始化器</span><br></pre></td></tr></table></figure>
<p>扩展属性只能被声明为 val。</p>
<h3 id="伴生对象的扩展"><a href="#伴生对象的扩展" class="headerlink" title="伴生对象的扩展"></a>伴生对象的扩展</h3><blockquote>
<p> 伴生对象内的成员相当于 Java 中的静态成员，其生命周期伴随类始终，在伴生对象内部可以定义变量和函数，这些变量和函数可以直接用类名引用。 </p>
</blockquote>
<p>如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性。</p>
<p>伴生对象通过”类名.”形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;    companion object &#123; &#125;  // 将被称为 &quot;Companion&quot;&#125;fun MyClass.Companion.foo() &#123;    println(&quot;伴随对象的扩展函数&quot;)&#125;val MyClass.Companion.no: Int    get() = 10fun main(args: Array&lt;String&gt;) &#123;    println(&quot;no:$&#123;MyClass.no&#125;&quot;)    MyClass.foo()&#125;</span><br></pre></td></tr></table></figure>
<p>实例执行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no:10伴随对象的扩展函数</span><br></pre></td></tr></table></figure>
<p>注：对于伴生对象扩展函数，有两种形式，一种是在类内扩展，一种是在类外扩展，这两种形式扩展后的函数互不影响（甚至名称都可以相同），即使名称相同，它们也完全是两个不同的函数，并且有以下特点：</p>
<ul>
<li>（1）类内扩展的伴随对象函数和类外扩展的伴随对象可以同名，它们是两个独立的函数，互不影响；</li>
<li>（2）当类内扩展的伴随对象函数和类外扩展的伴随对象同名时，类内的其它函数优先引用类内扩展的伴随对象函数，即对于类内其它成员函数来说，类内扩展屏蔽类外扩展；</li>
<li>（3）类内扩展的伴随对象函数只能被类内的函数引用，不能被类外的函数和伴随对象内的函数引用；</li>
<li>（4）类外扩展的伴随对象函数可以被伴随对象内的函数引用，；</li>
</ul>
<h2 id="Kotlin-对象表达式和对象声明"><a href="#Kotlin-对象表达式和对象声明" class="headerlink" title="Kotlin 对象表达式和对象声明"></a>Kotlin 对象表达式和对象声明</h2><h2 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h2><p>通过对象表达式实现一个匿名内部类的对象用于方法的参数中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;        <span class="comment">// ...    &#125;    override fun mouseEntered(e: MouseEvent) &#123;        // ...    &#125;&#125;)</span></span><br></pre></td></tr></table></figure>
<h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><blockquote>
<p>Kotlin 使用 object 关键字来声明一个对象。</p>
<p>Kotlin 中我们可以方便的通过<strong>对象object声明</strong>来获得一个单例。</p>
</blockquote>
<p> 当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;    <span class="keyword">var</span> name = <span class="string">"菜鸟教程"</span>    <span class="keyword">object</span> DeskTop&#123;        <span class="keyword">var</span> url = <span class="string">"www.runoob.com"</span>        <span class="function"><span class="keyword">fun</span> <span class="title">showName</span><span class="params">()</span></span>&#123;            print&#123;<span class="string">"desk legs <span class="variable">$name</span>"</span>&#125; <span class="comment">// 错误，不能访问到外部类的方法和变量        &#125;    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    var site = Site()    site.DeskTop.url // 错误，不能通过外部类的实例访问到该对象    Site.DeskTop.url // 正确, 类似静态内部类，这个类是属于外部类的，而不是某个实例&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>类内部的对象声明可以用 <code>companion</code> 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。</p>
<h3 id="对象表达式和对象声明之间的语义差异"><a href="#对象表达式和对象声明之间的语义差异" class="headerlink" title="对象表达式和对象声明之间的语义差异"></a>对象表达式和对象声明之间的语义差异</h3><p>对象表达式和对象声明之间有一个重要的语义差别：</p>
<ul>
<li>对象表达式是在使用他们的地方立即执行的</li>
<li>对象声明是在第一次被访问到时延迟初始化的</li>
<li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配</li>
</ul>
<h2 id="kotlin-委托"><a href="#kotlin-委托" class="headerlink" title="kotlin 委托"></a>kotlin 委托</h2><blockquote>
<p><a href="https://www.runoob.com/w3cnote/delegate-mode.html" target="_blank" rel="noopener">委托模式</a>是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。</p>
<p>Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。</p>
</blockquote>
<h3 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建接口interface Base &#123;       fun print()&#125;// 实现此接口的被委托的类class BaseImpl(val x: Int) : Base &#123;    override fun print() &#123; print(x) &#125;&#125;// 通过关键字 by 建立委托类class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) &#123;    val b = BaseImpl(10)    Derived(b).print() // 输出 10&#125;</span></span><br></pre></td></tr></table></figure>
<p>在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。</p>
<h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><p> 属性委托指的是一个<strong>类的某个属性值</strong>不是在类中直接进行定义，而是将<strong>其托付给一个代理类</strong>，从而实现对该类的属性统一管理。 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty<span class="comment">// 定义包含属性委托的类class Example &#123;    var p: String by Delegate()    // val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;&#125;// 委托的类class Delegate &#123;    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;        return "$thisRef, 这里委托了 $&#123;property.name&#125; 属性"    &#125;    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;        println("$thisRef 的 $&#123;property.name&#125; 属性赋值为 $value")    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val e = Example()    println(e.p)     // 访问该属性，调用 getValue() 函数    e.p = "Runoob"   // 调用 setValue() 函数    println(e.p)&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="标准委托"><a href="#标准委托" class="headerlink" title="标准委托"></a>标准委托</h3><p>Kotlin 的标准库中已经内置了很多工厂方法来实现属性的委托。</p>
<h4 id="延迟属性-Lazy"><a href="#延迟属性-Lazy" class="headerlink" title="延迟属性 Lazy"></a>延迟属性 Lazy</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lazyValue: String <span class="keyword">by</span> lazy &#123;    println(<span class="string">"computed!"</span>)     <span class="comment">// 第一次调用输出，第二次调用不执行    "Hello"&#125;fun main(args: Array&lt;String&gt;) &#123;    println(lazyValue)   // 第一次执行，执行两次输出表达式    println(lazyValue)   // 第二次执行，只输出返回值&#125;/*computed!HelloHello*/</span></span><br></pre></td></tr></table></figure>
<h4 id="可观察属性-Observable"><a href="#可观察属性-Observable" class="headerlink" title="可观察属性 Observable"></a>可观察属性 Observable</h4><blockquote>
<p>observable 可以用于实现观察者模式。</p>
<p>Delegates.observable() 函数接受两个参数: 第一个是初始化值, 第二个是属性值变化事件的响应器(handler)。</p>
<p>在属性赋值后会执行事件的响应器(handler)，它有三个参数：被赋值的属性、旧值和新值：</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegatesclass User &#123;    <span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">"初始值"</span>) &#123;        prop, old, new -&gt;        println(<span class="string">"旧值：<span class="variable">$old</span> -&gt; 新值：<span class="variable">$new</span>"</span>)    &#125;&#125;<span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;    <span class="keyword">val</span> user = User()    user.name = <span class="string">"第一次赋值"</span>    user.name = <span class="string">"第二次赋值"</span>&#125;<span class="comment">/*旧值：初始值 -&gt; 新值：第一次赋值旧值：第一次赋值 -&gt; 新值：第二次赋值*/</span></span><br></pre></td></tr></table></figure>
<h4 id="把属性储存在映射中"><a href="#把属性储存在映射中" class="headerlink" title="把属性储存在映射中"></a>把属性储存在映射中</h4><h4 id="Not-Null"><a href="#Not-Null" class="headerlink" title="Not Null"></a>Not Null</h4><p>notNull 适用于那些无法在初始化阶段就确定属性值的场合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;    var notNullBar: String by Delegates.notNull&lt;String&gt;()&#125;foo.notNullBar = &quot;bar&quot;println(foo.notNullBar)</span><br></pre></td></tr></table></figure>
<p>需要注意，如果属性在赋值前就被访问的话则会抛出异常。</p>
<h4 id="局部委托属性"><a href="#局部委托属性" class="headerlink" title="局部委托属性"></a>局部委托属性</h4><p>你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun example(computeFoo: () -&gt; Foo) &#123;    val memoizedFoo by lazy(computeFoo)    if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123;        memoizedFoo.doSomething()    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。</p>
<h3 id="属性委托要求"><a href="#属性委托要求" class="headerlink" title="属性委托要求"></a>属性委托要求</h3><p>对于只读属性(也就是说val属性), 它的委托必须提供一个名为getValue()的函数。该函数接受以下参数：</p>
<ul>
<li>thisRef —— 必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型</li>
<li>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型</li>
</ul>
<p>这个函数必须返回与属性相同的类型（或其子类型）。</p>
<p>对于一个值可变(mutable)属性(也就是说,var 属性),除 getValue()函数之外,它的委托还必须 另外再提供一个名为setValue()的函数, 这个函数接受以下参数:</p>
<p>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型new value —— 必须和属性同类型或者是它的超类型。</p>
<h3 id="提供委托"><a href="#提供委托" class="headerlink" title="提供委托"></a>提供委托</h3></article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2021/09/13/学点Kotlin/">https://nymrli.top/2021/09/13/学点Kotlin/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2021/09/21/docker部署springboot项目/" title="docker部署springboot项目"><span>< PreviousPost</span><br><span class="prevTitle">docker部署springboot项目</span></a><a class="nextSlogan" href="/2021/09/09/ZJU开学摸底考试——操作系统复习/" title="ZJU开学摸底考试——操作系统复习"><span>NextPost ></span><br><span class="nextTitle">ZJU开学摸底考试——操作系统复习</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '学点Kotlin',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><span>备案号:苏ICP备18015439号</span></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kotlin-基础语法"><span class="toc-number">1.</span> <span class="toc-text">Kotlin 基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数定义"><span class="toc-number">1.1.</span> <span class="toc-text">函数定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#可变长参数函数"><span class="toc-number">1.1.1.</span> <span class="toc-text">可变长参数函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda-匿名函数"><span class="toc-number">1.1.2.</span> <span class="toc-text">lambda(匿名函数)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NULL检查机制"><span class="toc-number">1.2.</span> <span class="toc-text">NULL检查机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kotlin-基本数据类型"><span class="toc-number">2.</span> <span class="toc-text">Kotlin 基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变量和常量"><span class="toc-number">2.1.</span> <span class="toc-text">变量和常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串模板"><span class="toc-number">2.2.</span> <span class="toc-text">字符串模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kotlin-条件控制"><span class="toc-number">3.</span> <span class="toc-text">Kotlin 条件控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kotlin-循环控制"><span class="toc-number">4.</span> <span class="toc-text">Kotlin 循环控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#返回和跳转"><span class="toc-number">4.1.</span> <span class="toc-text">返回和跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Break-和-Continue-的跳转标签"><span class="toc-number">4.2.</span> <span class="toc-text">Break 和 Continue 的跳转标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#标签处返回"><span class="toc-number">4.2.1.</span> <span class="toc-text">标签处返回</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kotlin-类和对象"><span class="toc-number">5.</span> <span class="toc-text">Kotlin 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类的定义"><span class="toc-number">5.1.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的声明"><span class="toc-number">5.2.</span> <span class="toc-text">对象的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">5.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getter-和-setter"><span class="toc-number">5.4.</span> <span class="toc-text">getter 和 setter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-number">5.5.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套类"><span class="toc-number">5.6.</span> <span class="toc-text">嵌套类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内部类"><span class="toc-number">5.6.1.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#匿名内部类"><span class="toc-number">5.6.2.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的修饰符"><span class="toc-number">5.7.</span> <span class="toc-text">类的修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kotlin-继承"><span class="toc-number">6.</span> <span class="toc-text">Kotlin 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数-1"><span class="toc-number">7.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#子类有主构造函数"><span class="toc-number">7.1.</span> <span class="toc-text">子类有主构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子类没有主构造函数"><span class="toc-number">7.2.</span> <span class="toc-text">子类没有主构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写"><span class="toc-number">7.3.</span> <span class="toc-text">重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性重写"><span class="toc-number">7.4.</span> <span class="toc-text">属性重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kotlin-接口"><span class="toc-number">8.</span> <span class="toc-text">Kotlin 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接口定义"><span class="toc-number">8.1.</span> <span class="toc-text">接口定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现接口"><span class="toc-number">8.2.</span> <span class="toc-text">实现接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kotlin-扩展"><span class="toc-number">9.</span> <span class="toc-text">Kotlin 扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将函数扩展"><span class="toc-number">9.1.</span> <span class="toc-text">将函数扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展函数是静态解析的"><span class="toc-number">9.1.1.</span> <span class="toc-text">扩展函数是静态解析的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展一个空对象"><span class="toc-number">9.2.</span> <span class="toc-text">扩展一个空对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#伴生对象的扩展"><span class="toc-number">9.3.</span> <span class="toc-text">伴生对象的扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kotlin-对象表达式和对象声明"><span class="toc-number">10.</span> <span class="toc-text">Kotlin 对象表达式和对象声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象表达式"><span class="toc-number">11.</span> <span class="toc-text">对象表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象声明"><span class="toc-number">11.1.</span> <span class="toc-text">对象声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#伴生对象"><span class="toc-number">11.2.</span> <span class="toc-text">伴生对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象表达式和对象声明之间的语义差异"><span class="toc-number">11.3.</span> <span class="toc-text">对象表达式和对象声明之间的语义差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin-委托"><span class="toc-number">12.</span> <span class="toc-text">kotlin 委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类委托"><span class="toc-number">12.1.</span> <span class="toc-text">类委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性委托"><span class="toc-number">12.2.</span> <span class="toc-text">属性委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准委托"><span class="toc-number">12.3.</span> <span class="toc-text">标准委托</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#延迟属性-Lazy"><span class="toc-number">12.3.1.</span> <span class="toc-text">延迟属性 Lazy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可观察属性-Observable"><span class="toc-number">12.3.2.</span> <span class="toc-text">可观察属性 Observable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#把属性储存在映射中"><span class="toc-number">12.3.3.</span> <span class="toc-text">把属性储存在映射中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Not-Null"><span class="toc-number">12.3.4.</span> <span class="toc-text">Not Null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#局部委托属性"><span class="toc-number">12.3.5.</span> <span class="toc-text">局部委托属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性委托要求"><span class="toc-number">12.4.</span> <span class="toc-text">属性委托要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提供委托"><span class="toc-number">12.5.</span> <span class="toc-text">提供委托</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>