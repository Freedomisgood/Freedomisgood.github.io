<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>浙江大学期末考试——Go语言 · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">浙江大学期末考试——Go语言</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2021/12/30</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Go"> Go</a><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="考试"> 考试</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">16,820</span> | Reading time: <span class="post-count">70</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="浙江大学期末考试go语言"><a class="markdownIt-Anchor" href="#浙江大学期末考试go语言"></a> 浙江大学期末考试——Go语言</h1>
<blockquote>
<p>期末复习对学习知识的帮助是巨大的，相比于看视频，本篇点到为止的知识点形的期末复习笔记，我相信更能让人学会。我相信，只要把本笔记全部看完了必然就会Go了。如果你做到了但还没有学会Go，那你大可来找我/doge。</p>
</blockquote>
<h2 id="概论"><a class="markdownIt-Anchor" href="#概论"></a> 概论</h2>
<ul>
<li><strong>指令</strong>：计算机的一个最基本的功能，如实现一次加法运算或实现一次大小的判别</li>
<li><strong>计算机的指令系统</strong>：计算机所能实现的指令的集合</li>
<li><strong>程序</strong>：一系列计算机指令的有序组合</li>
</ul>
<h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法：</h3>
<blockquote>
<p>求解<strong>特定问题</strong>的一组<strong>有限</strong>的操作序列</p>
</blockquote>
<ul>
<li>目的性：算法有运算结果，程序强调过程性</li>
<li>抽象性：算法独立于编程语言和指令系统</li>
<li>研究性：算法是理论研究，载体可以是伪码，文字，图片等，载体为某一编程语言时就是程序</li>
</ul>
<h3 id="基本特征"><a class="markdownIt-Anchor" href="#基本特征"></a> 基本特征：</h3>
<ul>
<li>有限性：一个算法在执行有限步之后必须会终止。</li>
<li>确定性：一个算法的每个步骤都必须精确地定义，可以严格地、无歧义地执行。</li>
<li>输入：一个算法在运行之前赋给它的量，或在运行过程中动态地赋给它的量。</li>
<li>输出：一个算法运行结束时的结果。</li>
<li>有效性：一个算法在运行过程中，所有运算必须是充分基本的，是可行的，原则上人们可以用笔和纸在有限的时间内精确地完成这些运算。</li>
</ul>
<p><strong>结构化程序设计</strong></p>
<ul>
<li>程序=算法+数据结构  								----获得图灵奖的Pascal之父Nicklaus Wirth</li>
<li>将复杂程序划分为若干个相互独立的模块</li>
<li>模块：一条语句（Statement）、一段程序或一个函数（子程序）等</li>
</ul>
<h3 id="结构化程序设计特点"><a class="markdownIt-Anchor" href="#结构化程序设计特点"></a> <strong>结构化程序设计特点</strong></h3>
<ul>
<li>自顶向下</li>
<li>模块化设计</li>
<li>结构化编码</li>
</ul>
<h3 id="oop"><a class="markdownIt-Anchor" href="#oop"></a> <strong>OOP</strong></h3>
<ul>
<li>封装和数据隐藏</li>
<li>继承和重用</li>
<li>多态性</li>
</ul>
<h3 id="go-特性"><a class="markdownIt-Anchor" href="#go-特性"></a> <strong>GO 特性</strong></h3>
<p>静态编译型<br>
语法强调少即是多<br>
强调组合，更简洁的OOP<br>
Duck模型的非侵入式接口<br>
原生支持并发编程<br>
支持多种操作系统和体系结构的交叉编译<br>
大量使用内置函数和接口来提高代码复用度<br>
支持和C 语言相互调用的机制（CGO）</p>
<h3 id="语言环境变量"><a class="markdownIt-Anchor" href="#语言环境变量"></a> <strong>语言环境变量</strong></h3>
<p><code>$GOROOT</code>  GO 语言环境在计算机的安装位置<br>
<code>$GOPATH</code>  GO 语言工作目录，可以有多个</p>
<h3 id="go语言的源码文件有三大类"><a class="markdownIt-Anchor" href="#go语言的源码文件有三大类"></a> <strong>Go语言的源码文件有三大类：</strong></h3>
<ul>
<li>命令源码文件，可执行的程序的入口</li>
<li>库源码文件，集中放置各种待被使用的程序实体</li>
<li>测试源码文件，用于对前两种源码文件中的程序实体的功能和性能进行测试</li>
</ul>
<h3 id="go-token标记"><a class="markdownIt-Anchor" href="#go-token标记"></a> Go Token(标记)</h3>
<ul>
<li>关键字：25个</li>
<li>标识符：40个</li>
<li>分隔符</li>
<li>字面量</li>
</ul>
<h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> <strong>变量</strong></h2>
<ul>
<li>变量代表<strong>某块内存区域</strong></li>
<li>变量的使用包括两个分开的步骤：变量声明、变量赋值</li>
<li>变量声明后会立即分配存储空间</li>
<li>变量声明后会<strong>初始化为该类型的零值</strong></li>
<li>同一代码块内不能多次声明同名变量</li>
<li>子代码块可声明父代码块同名变量，子遮盖父</li>
<li>变量<strong>未声明直接使用</strong>会出现编译错误</li>
<li>变量在函数中<strong>声明了但未使用</strong>也会出现编译错误</li>
<li>GO 是<strong>强类型语言</strong>，编译器会确认每个变量应有的类型，错误使用将引发错误</li>
<li>GO 是<strong>静态语言</strong>，但支持<u>编译时自动推断类型</u></li>
<li>变量声明后需按对应类型赋值</li>
<li>变量声明赋值可以同时进行</li>
<li>变量声明赋值同时进行可以忽略类型，由编译器推断</li>
<li>可在函数内部使用  :=   进行短类型声明赋值</li>
</ul>
<p>注：</p>
<ul>
<li>多变量同时赋值，只能在函数体内。<code>a, b = 3, 4</code></li>
<li>短类型声明赋值,只能在函数体内。<code>c := true</code></li>
<li>全局变量可以不被使用</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span> 	<span class="comment">//声明赋值同时进行</span></span><br><span class="line"><span class="comment">//a =bool 		//错误赋值</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span> 		<span class="comment">// 声明未加类型，自动推断类型</span></span><br><span class="line">a, b = <span class="number">3</span>, <span class="number">4</span> 	<span class="comment">//多变量同时赋值，只能在函数体内</span></span><br><span class="line"><span class="comment">//c := true   	//短类型声明赋值,只能在函数体内</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, b = <span class="number">3</span>, <span class="number">4</span> <span class="comment">//多变量同时赋值，只能在函数体内</span></span><br><span class="line">	c := <span class="literal">true</span>   <span class="comment">//短类型声明赋值,只能在函数体内</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"a address: %v  value: %v \n"</span>, &amp;a, a)</span><br><span class="line">	fmt.Printf(<span class="string">"b address: %v  value: %v \n"</span>, &amp;b, b)</span><br><span class="line">	fmt.Printf(<span class="string">"c address: %v  value: %v \n"</span>, &amp;c, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iota枚举"><a class="markdownIt-Anchor" href="#iota枚举"></a> iota枚举</h2>
<p>Go里面的关键字<code>iota</code>，可以在声明<code>enum</code>时采用，它默认开始值是0，每调用一次加1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">	x = <span class="literal">iota</span>  <span class="comment">// x == 0</span></span><br><span class="line">	y = <span class="literal">iota</span>  <span class="comment">// y == 1</span></span><br><span class="line">	z = <span class="literal">iota</span>  <span class="comment">// z == 2</span></span><br><span class="line">	w  <span class="comment">// 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用"= iota"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="literal">iota</span> <span class="comment">// 每遇到一个const关键字，iota就会重置，此时v == 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( </span><br><span class="line">  e, f, g = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//e=0,f=0,g=0 iota在同一行值相同</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除非被显式设置为其它值或<code>iota</code>，每个<code>const</code>分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是<code>iota</code>，则它也被设置为<code>iota</code>。</p>
</blockquote>
<h1 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h1>
<h2 id="条件语句"><a class="markdownIt-Anchor" href="#条件语句"></a> <strong>条件语句</strong></h2>
<h3 id="if"><a class="markdownIt-Anchor" href="#if"></a> if</h3>
<ul>
<li>GO不支持 ?: 三元运算符</li>
<li>if 后面的条件不需要( )</li>
<li>if 可带一个初始化子语句用;跟条件分开</li>
</ul>
<h3 id="switch"><a class="markdownIt-Anchor" href="#switch"></a> switch</h3>
<blockquote>
<p>case 按照<strong>从上到下的顺序进行求值，直到找到匹配的项</strong>后执行并退出switch（除非使用fallthrough）。如果 switch 没有表达式，则对 true 进行匹配，因此，可以将 if else-if else 改写成一个 switch。</p>
</blockquote>
<ul>
<li>switch 一样可以带初始化子语句</li>
<li>switch 条件表达式不要求必须为整型，类型本身也可作条件判断</li>
<li>case 后的break 可以省略</li>
<li>多个case连在一起是为了满足连续的条件范围</li>
<li>也可以直接把多个case条件连在一起，在最后一个case写执行语句</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">    fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">    fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">"hello"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> s != <span class="string">"world"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">world</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注：新编写的代码，不建议使用 fallthrough。</p>
<h2 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h2>
<h3 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h3>
<ul>
<li>GO 的循环语句只有for ,没有while/do while</li>
<li>★：for 语句后面不能加( )</li>
<li>for语句的三个部分,省略任何一个时，分号不能省略</li>
<li>只留条件判断时，可以不用分号 （相当于while语句）</li>
<li>全部省略,变为无限循环</li>
</ul>
<h2 id="转移语句"><a class="markdownIt-Anchor" href="#转移语句"></a> 转移语句</h2>
<ul>
<li>
<p>break：语句用于跳出代码块或循环, 除了用在switch之外,还用于结束整个循环，不再进行循环条件判断</p>
</li>
<li>
<p>continue：语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环</p>
</li>
<li>
<p>标签</p>
<blockquote>
<p>如果存在多重循环，默认情况下break语句和continue语句都只针对最内层循环。</p>
<p>所以Go提供了标签，标签允许指定跳出的循环</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用标签</span></span><br><span class="line">    flag := <span class="literal">false</span></span><br><span class="line">end:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i*j == <span class="number">651</span> &#123;</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">                <span class="comment">//一次跳出</span></span><br><span class="line">                <span class="keyword">break</span> end </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(flag)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1>
<p><strong>分类</strong></p>
<ul>
<li>命名类型：
<ul>
<li>基础数据类型（整型、浮点型等）</li>
<li>用户自定义类型（type关键字定义的结构、接口等）</li>
</ul>
</li>
<li>未命名类型
<ul>
<li>集合类型（数组、切片、映射等）</li>
<li>函数等</li>
</ul>
</li>
</ul>
<h2 id="bool类型"><a class="markdownIt-Anchor" href="#bool类型"></a> Bool类型</h2>
<ul>
<li>布尔值包括true、false，类型长度为1字节</li>
<li>布尔类型无法被其他类型赋值，也不支持类型转换</li>
<li>布尔类型不支持用0和1表示真假</li>
</ul>
<p>注：由于 Go语言是强类型的语言，如果不满足自动转换的条件，则必须进行强制类型转换。（C/C++等语言有隐式类型转换，golang中没有，即无法自动强转）</p>
<h2 id="字符类型"><a class="markdownIt-Anchor" href="#字符类型"></a> 字符类型</h2>
<ul>
<li>byte ，对应整型里的uint8 ，代表 ASCII 码一个字符</li>
<li>rune，对应整型里的int32 ，代表Unicode码一个字符</li>
</ul>
<p>格式化输出时，可用%c 输出对应值，如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浙</span></span><br><span class="line">fmt.Printf(<span class="string">"%c"</span>,<span class="number">27993</span>)</span><br></pre></td></tr></table></figure>
<h2 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h2>
<ul>
<li>字符串类型string，采用UTF-8编码格式的不可改变的字符序列</li>
<li>字符串单行用双引号 ,多行可用反引号`，空格和缩进都会被保留</li>
</ul>
<p>字符串标准库：</p>
<ul>
<li>strings包提供了很多操作字符串的简单函数</li>
<li>strconv包提供了基本数据类型和字符串之间的转换</li>
<li>regexp包提供了正则表达式功能</li>
<li>unicode包及其子包 utf8、utf16 中，提供了对 Unicode 相关编码、解码的支持</li>
</ul>
<p>strings包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子串 substr 在 s 中，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">// <span class="title">chars</span> 中任何一个 <span class="title">Unicode</span> 代码点在 <span class="title">s</span> 中，返回 <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ContainsAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">// <span class="title">Unicode</span> 代码点 <span class="title">r</span> 在 <span class="title">s</span> 中，返回 <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ContainsRune</span><span class="params">(s <span class="keyword">string</span>, r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">/** 子串出现次数 */</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Count</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">// 字符串重复几次 </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Repeat</span><span class="params">(s <span class="keyword">string</span>, count <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>unicode 包主要包含3个部分：</p>
<ul>
<li>unicode  ：基本的字符判断函数</li>
<li>utf8 ：负责 rune 和 byte 之间的转换</li>
<li>utf16 ：负责 rune 和 uint16 数组之间的转换</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsControl</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>  // 是否控制字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsDigit</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>  // 是否阿拉伯数字字符，即 0-9</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsGraphic</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否图形字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsLetter</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否字母</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsLower</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否小写字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsMark</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否符号字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsNumber</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否数字字符，比如罗马数字Ⅷ也是数字字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsOneOf</span><span class="params">(ranges []*RangeTable, r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否是 <span class="title">RangeTable</span> 中的一个</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsPrint</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否可打印字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsPunct</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否标点符号</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsSpace</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否空格</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsSymbol</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否符号字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsTitle</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否 <span class="title">title</span> <span class="title">case</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsUpper</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否大写字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Is</span><span class="params">(rangeTab *RangeTable, r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // <span class="title">r</span> 是否为 <span class="title">rangeTab</span> 类型的字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">In</span><span class="params">(r <span class="keyword">rune</span>, ranges ...*RangeTable)</span> <span class="title">bool</span>  // <span class="title">r</span> 是否为 <span class="title">ranges</span> 中任意一个类型的字符</span></span><br></pre></td></tr></table></figure>
<h1 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h1>
<ul>
<li>算术运算符
<ul>
<li>自增、自减，直支持a++，不支持++a ==&gt; 设计思想是保证只有一种写法</li>
</ul>
</li>
<li>关系运算符
<ul>
<li>因为bool类型不能转为整型，所以不支持不等式连写：比如 x&lt;y&lt;z 这种语法是错误的</li>
</ul>
</li>
<li>逻辑运算符
<ul>
<li>注意短路</li>
</ul>
</li>
<li>赋值运算符</li>
<li>位运算符</li>
</ul>
<p>注：Go中的运算优先级跟C<ins>不太一样，比如Go中位移运算符的优先级是高于算数运算符的，而C</ins>中相反</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++ --&gt; 2</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span> + <span class="number">4</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"><span class="comment">// go --&gt; 3</span></span><br><span class="line"><span class="built_in">println</span>( <span class="number">1</span> + <span class="number">4</span> &gt;&gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>见：</p>
<ul>
<li><a href="http://c.biancheng.net/view/5559.html" target="_blank" rel="noopener">Go语言运算符的优先级</a></li>
<li><a href="https://www.sojson.com/operation/cxx.html" target="_blank" rel="noopener">C++运算符优先级</a></li>
</ul>
<h1 id="集合数据类型"><a class="markdownIt-Anchor" href="#集合数据类型"></a> 集合数据类型</h1>
<h2 id="数组array"><a class="markdownIt-Anchor" href="#数组array"></a> 数组（Array）</h2>
<ul>
<li>数组是同类元素的集合，它的元素排列在连续的空间中，按下标来标记和访问</li>
<li>数组类型定义包括元素类型，数组长度（元素个数）</li>
<li>元素类型相同的两个数组，数组长度不同则类型不同，相互不能复制</li>
<li>数组变量声明后，其元素类型、数组长度均不可变  （定长性）</li>
</ul>
<p>注：数组传参问题——实参拷贝一份给形参，二者相互独立，传递大数组时效率较低，尽量用指向数组的指针来传参</p>
<p><strong>数组声明</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只声明未赋值</span></span><br><span class="line"><span class="comment">//数组元素都被初始化为对应类型零值</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"><span class="comment">//声明3个元素的整型数组</span></span><br><span class="line"><span class="comment">//直接赋值</span></span><br><span class="line">arr2 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="comment">//声明整型数组</span></span><br><span class="line"><span class="comment">//直接赋值</span></span><br><span class="line"><span class="comment">//数组长度由初始化值的数量来确定</span></span><br><span class="line">arr3 := [...]<span class="keyword">int</span>&#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125; <span class="comment">//...不可省略</span></span><br><span class="line"><span class="comment">//声明4个元素的整型数组</span></span><br><span class="line"><span class="comment">//对下标为0和3的元素直接赋值</span></span><br><span class="line"><span class="comment">//其余元素保持零值</span></span><br><span class="line">arr4 := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>: <span class="number">99</span>, <span class="number">3</span>: <span class="number">100</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v,%v,%v,%v"</span>, arr1, arr2, arr3, arr4)</span><br><span class="line"><span class="comment">//[0 0 0 0 0],[11 12 13],[11 12 13 14 15],[99 0 0 100]</span></span><br></pre></td></tr></table></figure>
<h2 id="切片-slice"><a class="markdownIt-Anchor" href="#切片-slice"></a> 切片（ Slice）</h2>
<blockquote>
<p>数组的定长性和值拷贝限制其使用</p>
</blockquote>
<ul>
<li>切片封装底层的数组，提供长度可变的数组引用</li>
<li>切片是<strong>引用类型</strong>，不支持==运算（除了nil)</li>
<li>切片包括三个变量
<ul>
<li>底层数组指针</li>
<li>切片当前长度</li>
<li>切片容量（小于等于底层数组长度，超过时要变更底层数组）</li>
</ul>
</li>
</ul>
<p><strong>切片使用</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建指定的底层数组，然后创建切片</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>&#125;</span><br><span class="line">s1 := a[<span class="number">0</span>:<span class="number">4</span>] <span class="comment">// from a[0] to a[3]</span></span><br><span class="line">s2 := a[:<span class="number">4</span>]  <span class="comment">// from a[0] to a[3]</span></span><br><span class="line"><span class="comment">//不指定数组大小，同时创建匿名数组和返回切片引用 </span></span><br><span class="line">d := []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;  </span><br><span class="line"><span class="comment">// 直接通过make函数创建切片</span></span><br><span class="line">i := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>) <span class="comment">// 为什么不用构造函数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片动态增加</span></span><br><span class="line">sli = <span class="built_in">append</span>(sli, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// 切片合并：内置函数 append()  还支持切片的合并，用...运算符把对应切片所有元素都取出</span></span><br><span class="line">veggies := []<span class="keyword">string</span>&#123;<span class="string">"potatoes"</span>, <span class="string">"tomatoes"</span>, <span class="string">"brinjal"</span>&#125;</span><br><span class="line">fruits := []<span class="keyword">string</span>&#123;<span class="string">"oranges"</span>, <span class="string">"apples"</span>&#125;</span><br><span class="line">food := <span class="built_in">append</span>(veggies, fruits...) <span class="comment">//... 不可忽略</span></span><br></pre></td></tr></table></figure>
<p><strong>语法糖<code>...</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MySum</span><span class="params">(p ...<span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span>&#123;		<span class="comment">// 第一个用法主要是用于函数有多个不定参数的情况，可以接受多个不确定数量的参数。</span></span><br><span class="line">	sum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> p&#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line">	i := MySum(arr...)		<span class="comment">// 第二个用法是将slice打散进行传递。</span></span><br><span class="line">	fmt.Printf(<span class="string">"i: %v\n"</span>, i)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="映射-map"><a class="markdownIt-Anchor" href="#映射-map"></a> 映射（ Map）</h2>
<blockquote>
<p>映射用于存储一系列无序的键值对</p>
</blockquote>
<ul>
<li>映射的键（key） 只支持值类型（可以使用==运算符作比较）</li>
<li>映射的值(value)不限制，但所有元素的值类型一致</li>
<li>GO 映射的底层实现是哈希数组链表，不是 C++的红黑树</li>
</ul>
<p>注：</p>
<ul>
<li>
<p>只声明不初始化的映射为nil值，未分配底层存储空间，不能添加元素</p>
</li>
<li>
<p>用字面量或make函数进行初始化后可以添加元素</p>
<p>即：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(m1 == <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//m1["a"] = 1 //error</span></span><br><span class="line"></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">fmt.Println(m2 == <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line">m2[<span class="string">"a"</span>] = <span class="number">1</span> <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(m3 == <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line">m3[<span class="string">"a"</span>] = <span class="number">1</span> <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>Map映射元素查找</strong></p>
<ul>
<li>
<p>映射元素通过下标直接查找访问</p>
<ul>
<li>存在对应key的，返回对应value</li>
<li>不存在对应key的，返回value 类型的零值</li>
</ul>
<p>==&gt; Q: 如果返回零值，那如何判断是否存在呢？</p>
<p>A:映射元素通过下标访问其实可以返回两个值</p>
<ul>
<li>对应的value</li>
<li>对应的key是否存在的布尔值</li>
</ul>
</li>
</ul>
<p><strong>映射元素删除</strong>：使用内置函数delete()删除映射元素，如<code>delete(personSalary,&quot;steve&quot;)</code></p>
<p>二维映射map创建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">comEmp := <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="string">"IBM"</span>: &#123;</span><br><span class="line">        <span class="string">"steve"</span>: <span class="number">12000</span>,</span><br><span class="line">        <span class="string">"jamie"</span>: <span class="number">15000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"HP"</span>: &#123;</span><br><span class="line">        <span class="string">"mike"</span>: <span class="number">15000</span>,</span><br><span class="line">        <span class="string">"joe"</span>:  <span class="number">9000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若顶级类型只是一个类型名，你可以在文法的元素中省略它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo1</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">	<span class="string">"Bell Labs"</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">	<span class="string">"Google"</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo2.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPAddr [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 给 IPAddr 添加一个 "String() string" 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f IPAddr)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	str := <span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span>  _ ,v:= <span class="keyword">range</span> f&#123;</span><br><span class="line">		<span class="keyword">if</span> str !=<span class="string">""</span> &#123;</span><br><span class="line">			str += <span class="string">","</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(strconv.Itoa(<span class="keyword">int</span>(v)))</span><br><span class="line">		str += strconv.Itoa(<span class="keyword">int</span>(v))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hosts := <span class="keyword">map</span>[<span class="keyword">string</span>]IPAddr&#123;</span><br><span class="line">		<span class="string">"loopback"</span>:  &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		<span class="string">"googleDNS"</span>: &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> name, ip := <span class="keyword">range</span> hosts &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%v: %v\n"</span>, name, ip)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1>
<p>概念：</p>
<p>函数是程序执行的基本语法结构：</p>
<ul>
<li>函数或方法编译成程序体代码区的一段指令序列</li>
<li>进程执行模型大多基于“栈堆”</li>
<li>函数抽象逻辑模块</li>
<li>通过函数调用函数,层层叠叠的函数构成树结构组织代码</li>
<li>函数效率高则程序效率高，建议多用标准库函数</li>
</ul>
<p>函数为<strong>第一等公民</strong>（与其他数据类型地位平等）</p>
<ul>
<li>赋值给变量</li>
<li>作为参数传递给其他函数</li>
<li>作为函数的结果被返回</li>
<li>支持闭包</li>
</ul>
<h2 id="语法格式"><a class="markdownIt-Anchor" href="#语法格式"></a> 语法格式：</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数可以有<strong>多个返回值</strong></li>
<li>返回值可以有变量名</li>
<li><strong>不支持函数重载</strong></li>
</ul>
<h2 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> <strong>函数参数：</strong></h2>
<ul>
<li><strong>参数传递方式都是值拷贝</strong></li>
<li>形参与实参是值传递时，形参的变化不影响实参</li>
<li>形参与实参传递指针时，形参的变化有可能会影响实参
<ul>
<li>===&gt; 注意：引用类型其实传的就是指针</li>
</ul>
</li>
<li><strong>不支持默认值参数</strong></li>
</ul>
<h3 id="不定参数"><a class="markdownIt-Anchor" href="#不定参数"></a> 不定参数</h3>
<ul>
<li>不定参数，形参数目可变、不确定</li>
<li>不定参数声明语法格式：<code>param … type</code></li>
<li>不定参数<strong>类型必须相同</strong></li>
<li>不定参数必须是<strong>函数的最后一个参数</strong></li>
<li>不定参数的<strong>形参在函数内是切片</strong></li>
<li><u>切片传递给不定参数时，要用…运算符取出各元素</u> ==&gt;多于函数定参数的参数将会被放到不定参数中</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//不定参数函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(items ...<span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> items &#123; <span class="comment">//items 相当于切片</span></span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切片参数函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumS</span><span class="params">(items []<span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> items &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	<span class="comment">//array := [...]int&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line">	fmt.Println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">	fmt.Println(sum(slice...)) <span class="comment">//不定参数函数参数为切片时，需用...运算符</span></span><br><span class="line">	<span class="comment">//fmt.Println(sum(array...)) //数组不支持...运算符</span></span><br><span class="line">	fmt.Println(sumS(slice)) <span class="comment">//切片参数函数可直接用切片变量，不用...运算符</span></span><br><span class="line">	<span class="comment">//fmt.Println(sumS(array)) //切片参数函数不能用数组传参</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>, sum)</span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>, sumS)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数类型"><a class="markdownIt-Anchor" href="#函数类型"></a> 函数类型</h2>
<ul>
<li>函数类型又叫函数签名，显示函数类型fmt.Printf(&quot;%T\n&quot;, funcname)</li>
<li>函数类型包括形参列表和返回值列表
<ul>
<li>形参列表：形参的次序、个数和类型（形参名无关）</li>
<li>返回值列表：返回值的次序、个数和类型（返回值名无关）</li>
</ul>
</li>
<li>可以使用type定义函数类型</li>
<li>函数类型是<strong>引用类型</strong>，未初始化的零值为nil</li>
<li>标准定义的函数名为常量，不可修改指向</li>
<li>函数是第一公民，函数变量可赋值、传参等</li>
</ul>
<h2 id="匿名函数"><a class="markdownIt-Anchor" href="#匿名函数"></a> 匿名函数</h2>
<blockquote>
<p>匿名函数相当于函数字面量，可以使用函数变量的地方就可以使用匿名函数</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名函数直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="keyword">int</span> )</span><span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line">&#125;(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">//匿名函数赋值给函数变量</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="keyword">int</span> )</span><span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数作为返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFun</span><span class="params">(op <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">(a,b <span class="keyword">int</span> )</span><span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="keyword">int</span> )</span><span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h2>
<blockquote>
<p>闭包=函数+引用环境，常见于匿名函数引用了函数定义环境的变量</p>
</blockquote>
<ul>
<li>如果函数返回的闭包引用了该函数的局部变量
<ul>
<li>每次调用函数都会为局部变量分配内存</li>
<li>每次使用闭包都会影响局部变量</li>
</ul>
</li>
</ul>
<h2 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h2>
<p>允许返回指定变量名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addT1</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123; <span class="comment">//多值返回，返回值不命名</span></span><br><span class="line">	c := a + b</span><br><span class="line">	d := a &gt; b</span><br><span class="line">	<span class="keyword">return</span> c, d <span class="comment">//按顺序输入返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addT2</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(c <span class="keyword">int</span>, d <span class="keyword">bool</span>)</span></span> &#123; <span class="comment">//多值返回，返回值命名</span></span><br><span class="line">    <span class="comment">// 注, c，d变量的类型声明在函数签名中已经声明了，因此直接赋值即可，不用:=</span></span><br><span class="line">	c = a + b</span><br><span class="line">	d = a &gt; b</span><br><span class="line">	<span class="keyword">return</span> <span class="comment">//直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数作为类型，以及函数赋值给变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span> )</span><span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(f <span class="keyword">func</span>(a, b <span class="keyword">int</span>)</span><span class="title">int</span> )</span>&#123;</span><br><span class="line">	f = <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a - b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span><span class="title">int</span> = <span class="title">add</span></span></span><br><span class="line"><span class="function">	<span class="title">change</span><span class="params">(f)</span>			// 未起作用</span></span><br><span class="line"><span class="function">	<span class="title">i</span> := <span class="title">f</span><span class="params">(1, 2)</span></span></span><br><span class="line">	fmt.Printf("i: %v\n", i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="defer"><a class="markdownIt-Anchor" href="#defer"></a> defer</h1>
<p>Go 函数支持defer进行延迟调用<br>
defer 类似OO语言异常处理中的finally子句，常用来保证系统资源的回收和释放</p>
<ul>
<li>在注册defer函数时，会把当时的实参值传递给形参，后续实参的变化不影响函数结果，如</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="number">5</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"defer注册函数时的a值"</span>,a)	<span class="comment">// a=5的时候，记录了defer</span></span><br><span class="line">a=<span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"普通函数的a值"</span>,a)				<span class="comment">// 后续变化了</span></span><br><span class="line"><span class="comment">//普通函数的a值10</span></span><br><span class="line"><span class="comment">//defer注册函数时的a值5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用多个defer时，这些defer 调用 以**先进后出（FILO）**顺序在函数返回前被执行</li>
</ul>
<h1 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h1>
<ul>
<li>结构把有内在联系的不同类型的数据统一成一个整体，使它们相互关联</li>
<li>结构是变量的集合，从外部看是一个实体</li>
<li>结构支持嵌套</li>
<li>结构的字段类型不限</li>
<li>结构的存储空间连续，按声明时的顺序存放</li>
</ul>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用：</h2>
<h3 id="命名类型结构"><a class="markdownIt-Anchor" href="#命名类型结构"></a> <strong>命名类型结构</strong></h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    firstName <span class="keyword">string</span></span><br><span class="line">    lastName  <span class="keyword">string</span></span><br><span class="line">    age       <span class="keyword">int</span></span><br><span class="line">    salary    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    firstName, lastName <span class="keyword">string</span></span><br><span class="line">    age, salary         <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名类型结构直接创建结构变量"><a class="markdownIt-Anchor" href="#匿名类型结构直接创建结构变量"></a> <strong>匿名类型结构（直接创建结构变量）</strong></h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myemployee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName, lastName <span class="keyword">string</span></span><br><span class="line">    age, salary         <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>带标签的结构体</strong></p>
<ul>
<li>标签是一个附属于字段的字符串，用于描述字段信息</li>
<li>标签还可以按<code>key1:“value1” key2:“value2”</code>键值对进行修饰，来提供编码、解码、ORM等转化辅助，比如JSON、BSON 等格式序列化</li>
</ul>
<p><strong>结构变量初始化</strong></p>
<ul>
<li>
<p>用命名类型结构或匿名类型结构声明的结构变量，各字段<strong>初始化为相关类型的零值</strong></p>
</li>
<li>
<p>按<strong>字段名</strong>初始化，<strong>不用按顺序</strong>，<strong>未指定的字段为零值</strong></p>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">emp1 := Employee&#123;</span><br><span class="line">    firstName: <span class="string">"Sam"</span>,</span><br><span class="line">    age:       <span class="number">25</span>,</span><br><span class="line">    salary:    <span class="number">500</span>,</span><br><span class="line">    lastName:  <span class="string">"Anderson"</span>, <span class="comment">//逗号不能忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>用<strong>字面量</strong>初始化，按字段类型声明顺序并全部设置，顺序不对或遗漏字段报错</p>
<ul>
<li><code>emp2 := Employee{&quot;Thomas&quot;, &quot;Paul&quot;, 29, 800}</code></li>
</ul>
</li>
</ul>
<h3 id="访问结构体数据"><a class="markdownIt-Anchor" href="#访问结构体数据"></a> <strong>访问结构体数据</strong></h3>
<ul>
<li>
<p>采用 结构变量.字段</p>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emp := Employee&#123;<span class="string">"Thomas"</span>, <span class="string">"Paul"</span>, <span class="number">29</span>, <span class="number">800</span>&#125;</span><br><span class="line">fmt.Println(emp.age)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>采用（*结构变量指针）.字段  *为间访符</p>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emp := &amp;Employee&#123;<span class="string">"Sam"</span>, <span class="string">"Anderson"</span>, <span class="number">55</span>, <span class="number">6000</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"First Name:"</span>, (*emp).firstName)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>采用 结构变量指针.字段，不支持-&gt;</p>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emp := &amp;Employee&#123;<span class="string">"Sam"</span>, <span class="string">"Anderson"</span>, <span class="number">55</span>, <span class="number">6000</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"First Name:"</span>, emp.firstName)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>匿名字段</strong>:结构体字段也可以省略字段名，字段名默认为对应数据类型名称（数据类型不能重复）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">p := Person&#123;<span class="string">"Naveen"</span>, <span class="number">50</span>&#125;</span><br><span class="line">p.<span class="keyword">int</span> =<span class="number">60</span></span><br></pre></td></tr></table></figure>
<h2 id="嵌套结构"><a class="markdownIt-Anchor" href="#嵌套结构"></a> 嵌套结构</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    city, state <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="keyword">string</span></span><br><span class="line">    age     <span class="keyword">int</span></span><br><span class="line">    address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line">    p.name = <span class="string">"Naveen"</span></span><br><span class="line">    p.age = <span class="number">50</span></span><br><span class="line">    p.address = Address&#123;</span><br><span class="line">        city:  <span class="string">"Chicago"</span>,</span><br><span class="line">        state: <span class="string">"Illinois"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Name:"</span>, p.name)</span><br><span class="line">    fmt.Println(<span class="string">"Age:"</span>, p.age)</span><br><span class="line">    fmt.Println(<span class="string">"City:"</span>, p.address.city)</span><br><span class="line">    fmt.Println(<span class="string">"State:"</span>, p.address.state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子结构字段提升"><a class="markdownIt-Anchor" href="#子结构字段提升"></a> 子结构字段提升</h3>
<blockquote>
<p><strong>匿名子结构</strong>的<u>字段</u>可以像父结构的字段一样被父访问（没有同名父结构字段）</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;  </span><br><span class="line">    city, state <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">    Address  <span class="comment">//子结构匿名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line">    p.name = <span class="string">"Naveen"</span></span><br><span class="line">    p.age = <span class="number">50</span></span><br><span class="line">    p.Address = Address&#123;</span><br><span class="line">        city:  <span class="string">"Chicago"</span>,</span><br><span class="line">        state: <span class="string">"Illinois"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Name:"</span>, p.name)</span><br><span class="line">    fmt.Println(<span class="string">"Age:"</span>, p.age)</span><br><span class="line">    fmt.Println(<span class="string">"City:"</span>, p.city) 	<span class="comment">//city 提升, 可以直接以父.city的形式使用</span></span><br><span class="line">    fmt.Println(<span class="string">"State:"</span>, p.state) 	<span class="comment">//state 提升</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h1>
<blockquote>
<p>方法是对具体类型行为的封装，本质上是<a href="#%E5%87%BD%E6%95%B0"><strong>绑定到该类型的函数</strong></a></p>
</blockquote>
<ul>
<li>
<p><mark>非命名类型不能定义方法</mark></p>
</li>
<li>
<p>OO语言的方法通常有个<u>隐藏的this或self指针</u>来指向对象</p>
</li>
<li>
<p>GO 把这个隐藏指针暴露出来，称为<strong>接收者（receiver）</strong></p>
</li>
<li>
<p>接收者可自定义名称，类型有值类型和指针类型两种，语法格式：</p>
<ul>
<li>值类型：<code>func (t Type) funcName(paramList)(resultList)</code></li>
<li>指针类型 ：<code>func (t *Type) funcName(paramList)(resultList)</code></li>
</ul>
<p>方法接收者</p>
<ul>
<li>
<p>方法接收者的本质是形参</p>
<ul>
<li>方法接收者为值时，方法修改对象属性将不能成功</li>
<li>方法接收者为值时，需要在内存复制一份对象，效率低</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//方法接收者是值</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">changeName</span><span class="params">(newName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    	e.name = newName</span><br><span class="line">    	fmt.Printf(<span class="string">"\nEmployee name in func is: %s"</span>, e.name)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法接收者是指针</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">changeAge</span><span class="params">(newAge <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    	e.age = newAge</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实际上是拷贝了一个e对象，然后吧这个对象的name改掉了</span></span><br><span class="line">    <span class="comment">// Print(e.Name)实际上还是没有修改</span></span><br><span class="line">    e.changeName(<span class="string">"Michael"</span>)</span><br><span class="line">    <span class="comment">// 而接收者为指针的函数就能修改</span></span><br><span class="line">    e.changeAge(<span class="number">18</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了上述调用以外，还可以通过类型调用的方式</span></span><br><span class="line">    Employee.changeName(e, <span class="number">52</span>) <span class="comment">//类型调用</span></span><br><span class="line">    (*Employee).changeAge(&amp;e, <span class="number">52</span>) <span class="comment">//类型调用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>总结：Go中的方法实现跟C<ins>比较类似，都是在体外完成对方法的具体实现。C</ins>是在类中声明函数原型，在类外以<code>Class::FuncMethod(){ xxx }</code>中具体实现函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    name     <span class="keyword">string</span></span><br><span class="line">    salary   <span class="keyword">int</span></span><br><span class="line">    currency <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">displaySalary</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Salary of %s is %s%d"</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    emp1 := Employee&#123;</span><br><span class="line">        name:     <span class="string">"Sam Adolf"</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">"$"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    emp1.displaySalary() </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Target：实际等价</span></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name     <span class="keyword">string</span></span><br><span class="line">    salary   <span class="keyword">int</span></span><br><span class="line">    currency <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">displaySalary</span><span class="params">(e Employee)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"Salary of %s is %s%d"</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp1 := Employee&#123;</span><br><span class="line">        name:     <span class="string">"Sam Adolf"</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">"$"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    displaySalary(emp1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Q：方法可用等价函数实现，为什么还要方法？</p>
<ul>
<li><strong>GO 的函数不能重载</strong>(即不准存在只是参数不同的同名函数)，导致不同类型不能用同名函数，而不同类型的方法可以同名</li>
<li>GO 不支持class ,使用结构代替类，<strong><u>结构字段用来封装对象属性，方法用来封装对象的行为</u></strong></li>
</ul>
<h2 id="方法提升"><a class="markdownIt-Anchor" href="#方法提升"></a> 方法提升</h2>
<blockquote>
<p>匿名子结构的方法可以像父结构的方法一样被父使用（没有同名父结构方法）</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	city  <span class="keyword">string</span></span><br><span class="line">	state <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	firstName ptring</span><br><span class="line">	lastName  <span class="keyword">string</span></span><br><span class="line">	Address</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Address)</span> <span class="title">fullAddress</span><span class="params">()</span></span> &#123; <span class="comment">//接收者是子结构指针</span></span><br><span class="line">	fmt.Printf(<span class="string">"Full Address: %s, %s\n"</span>, a.city, a.state)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := Person&#123;</span><br><span class="line">		firstName: <span class="string">"Elon"</span>,</span><br><span class="line">		lastName:  <span class="string">"Musk"</span>,</span><br><span class="line">		Address: Address&#123;</span><br><span class="line">			city:  <span class="string">"Los Angeles"</span>,</span><br><span class="line">			state: <span class="string">"California"</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	p.Address.fullAddress() <span class="comment">//完整调用方法</span></span><br><span class="line">	p.fullAddress()         <span class="comment">//父结构对象直接调用子结构方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 修改匿名字段Address变成指针，则2</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	firstName <span class="keyword">string</span></span><br><span class="line">	lastName  <span class="keyword">string</span></span><br><span class="line">	*Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := &amp;Person&#123;</span><br><span class="line">		firstName: <span class="string">"Elon"</span>,</span><br><span class="line">		lastName:  <span class="string">"Musk"</span>,</span><br><span class="line">		Address: &amp;Address&#123;			<span class="comment">// 2. 则这边传的时候应该是传地址</span></span><br><span class="line">			city:  <span class="string">"Los Angeles"</span>,</span><br><span class="line">			state: <span class="string">"California"</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义类型扩展方法</strong></p>
<blockquote>
<p>方法并非结构体专有，所有自定义类型都可以定义方法</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="keyword">int</span> 		<span class="comment">// 命名类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *myInt)</span> <span class="title">add</span><span class="params">(b myInt)</span> <span class="title">myInt</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num1 := myInt(<span class="number">5</span>)</span><br><span class="line">num2 := myInt(<span class="number">10</span>)</span><br><span class="line">sum := num1.add(num2)</span><br></pre></td></tr></table></figure>
<h2 id="方法值"><a class="markdownIt-Anchor" href="#方法值"></a> 方法值</h2>
<ul>
<li>方法本质上还是函数，所以方法可以赋值给函数变量</li>
<li>方法值是对象变量初始化后的方法</li>
<li>方法值其实是带有闭包的函数变量，<strong>接收者被隐式地保存在闭包里</strong></li>
<li>方法值赋给函数变量后，函数变量可直接调用</li>
<li><u>方法也可以直接通过<strong>类型</strong>来调用，把接收者作为第一个参数</u>：<code>e.play() &lt;==&gt;Employee.play(e)</code>, <code>(*Employee).changeAge(&amp;e, 52) //类型调用</code></li>
</ul>
<h1 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h1>
<ul>
<li>接口是编程规约，一组<strong>方法签名</strong>的<em>集合</em>
<ul>
<li>方法声明的两个组件构成了方法签名 - <strong>方法的名称</strong>和<strong>参数类型</strong>。</li>
</ul>
</li>
<li>传统OO里，接口通常用来抽象定义对象的行为，具体过程在类里实现 ，类在定义时要声明实现了哪些接口</li>
<li>GO 接口采用非侵入式，即具体类型实现接口不用显式声明，只要其方法集是接口的超集，<strong>编译时</strong>会进行对应校验</li>
<li>GO 接口只有方法签名，没有数据字段，没有函数体代码</li>
<li><strong>类型的方法集</strong>是多个接口的超集，则<strong>实现多个接口</strong></li>
</ul>
<p>类型定义：</p>
<ul>
<li>
<p>命名接口类型</p>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> interfaceName <span class="keyword">interface</span>&#123;<span class="comment">//接口类型命名通常以er为后缀</span></span><br><span class="line">    methodName(paramList)(resultList)</span><br><span class="line">    otherInterfaceName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>匿名接口类型</p>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span>&#123;</span><br><span class="line">    methodName(paramList)(resultList)</span><br><span class="line">    interfaceName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="空接口"><a class="markdownIt-Anchor" href="#空接口"></a> 空接口</h2>
<ul>
<li>空接口 interface{} 是一种<strong>匿名接口类型</strong></li>
<li>空接口的方法集为空，<strong>所有类型都实现了空接口，都可以赋值或传递给空接口</strong></li>
<li>非命名类型不能定义自己的方法，其方法集为空，只能传递给空接口==&gt;map，slice
<ul>
<li>方法需要接收类型参数，所以非命名类型不能定义自己的方法</li>
</ul>
</li>
</ul>
<h2 id="接口初始化"><a class="markdownIt-Anchor" href="#接口初始化"></a> 接口初始化</h2>
<ul>
<li>只声明未赋值的接口变量为nil</li>
<li>接口变量初始化需要把接口<strong>绑定到具体类型实例</strong></li>
<li>未初始化的接口变量不能调用其方法</li>
<li>方法的接收者才能给接口变量赋值</li>
<li>接口变量的值包括底层类型的值和具体类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Printer <span class="keyword">interface</span> &#123; </span><br><span class="line">    Print()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">Print</span><span class="params">()</span></span> &#123; </span><br><span class="line">    fmt.Println(<span class="string">"print"</span>)</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = S&#123;&#125;</span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123; <span class="comment">//通过v才能调用接口函数</span></span><br><span class="line">    <span class="keyword">case</span> Printer:</span><br><span class="line">    v.Print()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"unknown type\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内部，接口值可以看做包含值和具体类型的元组：<code>(value, type)</code></p>
<p>接口值保存了一个具体底层类型的具体值。接口值调用方法时会执行其底层类型的同名方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">	M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line">	i = &amp;T&#123;<span class="string">"Hello"</span>&#125;</span><br><span class="line">	describe(i)</span><br><span class="line">	i.M()</span><br><span class="line"></span><br><span class="line">	i = F(math.Pi)</span><br><span class="line">	describe(i)</span><br><span class="line">	i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">(&amp;&#123;Hello&#125;, *main.T)</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">(3.141592653589793, main.F)</span></span><br><span class="line"><span class="comment">3.141592653589793</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="go-的面向对象"><a class="markdownIt-Anchor" href="#go-的面向对象"></a> GO 的面向对象</h2>
<blockquote>
<p>Go 没有类，而是松耦合的类型、方法对接口的实现</p>
</blockquote>
<p>封装</p>
<ul>
<li>用结构代替类</li>
<li>用New函数代替构造函数</li>
</ul>
<p>继承</p>
<ul>
<li>用类型组合来实现继承</li>
<li>多重继承通过内嵌多个类型实现</li>
</ul>
<p>多态</p>
<h1 id="类型断言"><a class="markdownIt-Anchor" href="#类型断言"></a> 类型断言</h1>
<p>Go语言里面有一个语法，可以直接判断是否是该类型的变量：<code>value, ok = element.(T)</code>，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。</p>
<p>下面有个例子。只有当某个interface{}的类型 存储的是int时才打印出来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    r := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++&#123;</span><br><span class="line">        v = i </span><br><span class="line">        <span class="keyword">if</span> (r.Intn(<span class="number">100</span>) % <span class="number">2</span>) == <span class="number">0</span> &#123; </span><br><span class="line">            v = <span class="string">"hello"</span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span> _, ok := v.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d\n"</span>, v)</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个比较典型的应用场景就是：<code>errors.(*MyError)</code></p>
<h1 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h1>
<ul>
<li>反射可以在运行时检查变量的类型和值，是元编程的一种形式，在没有源代码时帮助调试程序</li>
<li>反射包  ” reflect” 通过空接口获取变量的类型和值</li>
<li>用接口实现多态</li>
<li>实例可以赋给它所实现的任意接口类型的变量</li>
<li>反射包 ” reflect” 通过空接口获取变量的类型和值
<ul>
<li>func TypeOf(i interface{}) Type</li>
<li>func ValueOf(i interface{}) Value</li>
</ul>
</li>
<li>reflect.Type 和 reflect.Value 各有许多方法，比如kind方法用于返回底层类型名称的常量</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将函数包装为反射值对象</span></span><br><span class="line">funcValue := reflect.ValueOf(add)</span><br><span class="line"><span class="comment">// 生成函数参数, 传入两个整型值</span></span><br><span class="line">paramList := []reflect.Value&#123;reflect.ValueOf(<span class="number">10</span>), reflect.ValueOf(<span class="number">20</span>)&#125;</span><br><span class="line"><span class="comment">// 反射调用函数</span></span><br><span class="line">retList := funcValue.Call(paramList)</span><br><span class="line"><span class="comment">// 获取第一个返回值, 取整数值</span></span><br><span class="line">fmt.Println(retList[<span class="number">0</span>].Int())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Money <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Money = <span class="number">58.9</span></span><br><span class="line">	fmt.Println(<span class="string">"type:"</span>, reflect.TypeOf(x))</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	fmt.Println(<span class="string">"value:"</span>, v)</span><br><span class="line">	fmt.Println(<span class="string">"type:"</span>, v.Type())</span><br><span class="line">	fmt.Println(<span class="string">"kind:"</span>, v.Kind())               <span class="comment">//查看底层类型</span></span><br><span class="line">	fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet()) <span class="comment">//能否被修改 x的地址不能修改</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    type: main.Money</span></span><br><span class="line"><span class="comment">    value: 58.9</span></span><br><span class="line"><span class="comment">    type: main.Money</span></span><br><span class="line"><span class="comment">    kind: float64</span></span><br><span class="line"><span class="comment">    settability of v: false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h1>
<ul>
<li>传统OO里，异常是一种程序控制机制，依附于栈结构,却可以同时设置多个异常类型作为网捕条件,从而以类型匹配在栈机制中跳跃回馈</li>
<li>GO 语言里没有异常机制，只有<strong>错误处理</strong>，错误通过函数的多返回值来处理</li>
<li>GO 语言的错误主要有：
<ul>
<li>编译错误</li>
<li>运行时错误</li>
<li>逻辑错误</li>
</ul>
</li>
<li>GO错误处理方式
<ul>
<li>错误可处理，通过函数返回错误进行处理</li>
<li>错误不可处理，通过panic抛出错误，退出程序</li>
</ul>
</li>
</ul>
<h2 id="错误实现"><a class="markdownIt-Anchor" href="#错误实现"></a> 错误实现</h2>
<blockquote>
<p>通过error 接口 实现错误处理的标准模式，打印错误时自动调用Error()函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">type</span> error <span class="keyword">interface</span>&#123;</span><br><span class="line">&gt;     Error() <span class="keyword">string</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>实际使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Op   <span class="keyword">string</span></span><br><span class="line">    Path <span class="keyword">string</span></span><br><span class="line">    Err  error</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.Op + <span class="string">" "</span> + e.Path + <span class="string">": "</span> + e.Err.Error() &#125;</span><br><span class="line"></span><br><span class="line">f, err := os.Open(<span class="string">"/test.txt"</span>)</span><br><span class="line"><span class="comment">// 类型断言</span></span><br><span class="line"><span class="keyword">if</span> perr, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"File at path"</span>, perr.Path, <span class="string">"failed to open"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(f.Name(), <span class="string">"opened successfully"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="创建错误"><a class="markdownIt-Anchor" href="#创建错误"></a> 创建错误</h3>
<ul>
<li>
<p>根据errors 包对错误的基本定义</p>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>fmt包的Errorf 函数</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circleArea1</span><span class="params">(radius <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"Area calculation failed, radius is less than zero"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> math.Pi * radius * radius, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circleArea2</span><span class="params">(radius <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"Area calculation failed, radius %0.2f is less than zero"</span>, radius)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> math.Pi * radius * radius, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建自定义错误"><a class="markdownIt-Anchor" href="#创建自定义错误"></a> 创建自定义错误</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> areaError <span class="keyword">struct</span> &#123;</span><br><span class="line">	err    <span class="keyword">string</span>  <span class="comment">//error description</span></span><br><span class="line">	length <span class="keyword">float64</span> <span class="comment">//length which caused the error</span></span><br><span class="line">	width  <span class="keyword">float64</span> <span class="comment">//width which caused the error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//error的方法用来明确错误原因</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span> <span class="title">lengthNegative</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.length &lt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span> <span class="title">widthNegative</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.width &lt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectArea</span><span class="params">(length, width <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">	err := <span class="string">""</span></span><br><span class="line">	<span class="keyword">if</span> length &lt; <span class="number">0</span> &#123;</span><br><span class="line">		err += <span class="string">"length is less than zero"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> width &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err == <span class="string">""</span> &#123;</span><br><span class="line">			err = <span class="string">"width is less than zero"</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			err += <span class="string">", width is less than zero"</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="string">""</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 返回的是对象的地址</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, &amp;areaError&#123;err, length, width&#125;</span><br><span class="line">	&#125; <span class="comment">//err 文本用来给错误提示信息</span></span><br><span class="line">	<span class="keyword">return</span> length * width, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	length, width := <span class="number">-5.0</span>, <span class="number">-9.0</span></span><br><span class="line">    <span class="comment">// 2. 所以这边err是指针</span></span><br><span class="line">	area, err := rectArea(length, width)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Print(err)</span><br><span class="line">        <span class="comment">// 3. 所以这边类型断言得判断是不是areaError的指针</span></span><br><span class="line">		<span class="keyword">if</span> err, ok := err.(*areaError); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> err.lengthNegative() &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"error: length %0.2f is less than zero\n"</span>, err.length)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err.widthNegative() &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"error: width %0.2f is less than zero\n"</span>, err.width)</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"area of rect"</span>, area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义错误的实现逻辑：</p>
<ol>
<li>自定义的错误都会重写Error() string的方法，即实现了error 接口。</li>
<li>在抛出自定义错误的函数中错误的返回值类型都是error接口</li>
<li>因此，在外部使用的时候<code>data, err = Myfunc()</code>，这边得到的err是error接口，至于捕捉自定义的错误就是通过对接口的类型断言来判断的了，即自定义的错误都能看到下面有<code>if errObj, ok := err.(*MyError); ok</code>的代码</li>
</ol>
<p><strong>使用 goto 集中处理错误</strong>——Go特性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规的写法</span></span><br><span class="line">err := firstCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = secondCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go借助标签特殊的写法</span></span><br><span class="line">err := firstCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">goto</span> onExit</span><br><span class="line">&#125;</span><br><span class="line">err = secondCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">goto</span> onExit</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常处理代码</span></span><br><span class="line">onExit:</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br></pre></td></tr></table></figure>
<h2 id="panic恐慌"><a class="markdownIt-Anchor" href="#panic恐慌"></a> panic（恐慌）</h2>
<ul>
<li>通常情况下，向报告错误状态的方式是返回一个额外的error类型值。但是，当遇到<strong>不可恢复的错误状态</strong>，导致程序不能简单继续执行时引发panic</li>
<li>引发panic的两种情况
<ul>
<li><strong>主动调用panic 函数</strong>，会产生一个运行时错误，该错误提供RuntimeError() 方法用于区别普通错误</li>
<li><u>程序运行时</u><strong>出现未处理错误</strong>自动触发，比如当发生像数组下标越界或类型断言失败等运行时错误时，Go 运行时会自动触发panic</li>
</ul>
</li>
<li>不应通过调用panic()函数来报告普通的错误，而应该只把它作为报告致命错误的一种方式</li>
</ul>
<h3 id="panicking终止过程"><a class="markdownIt-Anchor" href="#panicking终止过程"></a> panicking终止过程</h3>
<ul>
<li>panic 类似异常会<strong>逐级上传</strong></li>
<li>在多层嵌套的函数调用中触发或调用panic，会马上中止当前函数的执行，逐级冒泡上传到最顶层，并<u>执行（每层的） defer</u>，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况</li>
</ul>
<h2 id="recover"><a class="markdownIt-Anchor" href="#recover"></a> recover</h2>
<ul>
<li>panic一旦被引发就会导致程序崩溃，但无法保证程序不会发生任何运行时错误。</li>
<li>recover<strong>专用于“拦截”运行时panic</strong>，让进入恐慌的程序恢复过来并重新获得流程控制权。</li>
<li>recover 可以<u>阻止panic继续向上传递</u></li>
<li>▲.为确保捕获panic， <strong>recover 必须在延迟函数（defer）中执行</strong></li>
</ul>
<p>总结：</p>
<ul>
<li>程序发生的错误导致程序不能容错继续执行，应主动调用panic或由运行时抛出panic</li>
<li>程序发生错误，但能容错继续执行的，正常情况用错误返回值，运行时错误非关键分支用recover 捕获panic</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverName</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"recovered from fullName"</span>, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverMain</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"recovered from main"</span>, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fullName</span><span class="params">(firstName *<span class="keyword">string</span>, lastName *<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> recoverName()</span><br><span class="line">	<span class="keyword">if</span> firstName == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"runtime error: first name cannot be nil"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> lastName == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"runtime error: last name cannot be nil"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%s %s\n"</span>, *firstName, *lastName)</span><br><span class="line">	fmt.Println(<span class="string">"returned normally from fullName"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> recoverMain()</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"deferred call in main"</span>)</span><br><span class="line">	<span class="comment">//firstName := "Elon"</span></span><br><span class="line">	lastName := <span class="string">"Potter"</span></span><br><span class="line">	<span class="comment">//fullName(&amp;firstName, &amp;lastName)</span></span><br><span class="line">	fullName(<span class="literal">nil</span>, &amp;lastName)</span><br><span class="line">	fmt.Println(<span class="string">"returned normally from main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h1>
<ul>
<li>GO使用包来<strong>组织</strong>源代码和代码编译，实现代码复用</li>
<li>任何源代码<strong>必须属于某个包</strong>，同时源码文件的<strong>第一行有效代码必须是package</strong> pacakge packageName 语句，声明自己所在的包。</li>
<li>▲.包名为 main 为应用程序的<strong>入口包</strong>，编译不包含 main 包的源码文件时不会得到可执行文件</li>
<li>一个文件夹下的所有源码文件只能属于同一个包，同样<u>属于同一个包的源码文件不能放在多个文件夹下</u></li>
</ul>
<h2 id="包的引用格式"><a class="markdownIt-Anchor" href="#包的引用格式"></a> 包的引用格式</h2>
<ul>
<li>
<p>标准引用格式</p>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">fmt.Printf(<span class="string">"Hello world！"</span>)</span><br></pre></td></tr></table></figure>
<p>通过：<code>库/包.func</code>的方式调用</p>
</li>
</ul>
</li>
<li>
<p>自定义别名引用格式</p>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> F <span class="string">"fmt"</span></span><br><span class="line">F.Printf(<span class="string">"Hello world！"</span>)</span><br></pre></td></tr></table></figure>
<p>通过：<code>定义的名称，如F.func</code>的方式调用</p>
</li>
</ul>
</li>
<li>
<p>省略引用格式</p>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//不需要加前缀 fmt.</span></span><br><span class="line">Printf(<span class="string">"Hello world！"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>匿名引用格式</p>
<blockquote>
<ul>
<li>引用包，但是代码中却没有使用包，编译器会报错</li>
<li>在引用某个包时，如果只是希望执行包初始化的 init 函数，而不使用包内部的数据时，可以使用匿名引用格式(<code>_</code>)</li>
</ul>
</blockquote>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"fmt"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="init"><a class="markdownIt-Anchor" href="#init"></a> init( )</h2>
<ul>
<li>init( )是特殊的函数，<strong>不能够被人为调用</strong>，而是在<strong>每个包完成初始化后自动执行</strong>，并且<u>执行优先级比 main 函数高</u></li>
<li>init( )常用于在开始执行程序之前<strong>对数据进行检验或修复</strong>，或者在程序开始之前调用后台执行的 goroutine</li>
<li>每个源码可以使用 1 个 init() 函数，<u>一个包可以有多个 init 函数，包加载时会执行全部的 init 函数，但并不能保证执行顺序</u></li>
</ul>
<h2 id="包加载顺序"><a class="markdownIt-Anchor" href="#包加载顺序"></a> 包加载顺序</h2>
<ul>
<li>程序从 main 函数引用的包开始，<strong>逐级查找包的引用</strong>，直到找到没有引用其他包的包，最终生成一个<strong>包引用的有向无环图</strong></li>
<li>每个包会先①初始化常量，然后②是全局变量，③最后执行包的 init 函数</li>
</ul>
<p><img src="/2021/11/02/浙江大学期末考试——Go语言/E:%5Chexo%5Csource_posts%5C%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E2%80%94%E2%80%94Go%E8%AF%AD%E8%A8%80%5C%E5%8C%85%E5%BC%95%E7%94%A8%E9%A1%BA%E5%BA%8F.png" alt="包引用顺序"></p>
<h2 id="包内标识符导出向外暴露"><a class="markdownIt-Anchor" href="#包内标识符导出向外暴露"></a> 包内标识符导出——向外暴露</h2>
<ul>
<li>
<p>一个包里的标识符（如类型、变量、常量等）要被<strong>外部访问</strong>，需将要导出的标识符的<strong>首字母大写</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar = <span class="number">100</span> <span class="comment">//内部引用</span></span><br><span class="line"><span class="keyword">const</span> MyConst = <span class="string">"hello"</span> <span class="comment">//导出</span></span><br><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;  <span class="comment">//导出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在被导出的<em>结构体</em>或接口中，如果它们的<strong>字段</strong>或<strong>方法</strong>首字母是大写，外部可以访问这些字段和方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;			<span class="comment">//结构体要被导出    </span></span><br><span class="line">    ExportedField <span class="keyword">int</span>			<span class="comment">// 包外可以访问的字段    </span></span><br><span class="line">    privateField <span class="keyword">int</span> 			<span class="comment">// 仅限包内访问的字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;	<span class="comment">//接口要被导出   </span></span><br><span class="line">    ExportedMethod() 			<span class="comment">// 包外可以访问的方法    </span></span><br><span class="line">    privateMethod()				<span class="comment">// 仅限包内访问的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：Go没有提供权限控制符，而是通过了<strong>首字母是否大小写的统一规定</strong>来加上权限控制，这个跟Python中私有权限加<code>__</code>，保护权限加<code>_</code>颇为类似</p>
</li>
</ul>
<h2 id="gomod"><a class="markdownIt-Anchor" href="#gomod"></a> go.mod</h2>
<ul>
<li>
<p>使用GOPATH 不太方便</p>
</li>
<li>
<p>go.mod是Go1.11版本新引入的官方包管理工具</p>
</li>
<li>
<p>在项目目录下用go.mod 文件来记录依赖包具体版本，方便依赖包、源代码和版本控制的管理、</p>
</li>
<li>
<p><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">https://github.com/golang/go/wiki/Modules</a></p>
</li>
<li>
<p>go.mod 文件内容</p>
<ul>
<li>module：指定包的名字</li>
<li>go：用于标识当前模块的 Go 语言版本，值为初始化模块时的版本</li>
<li>require：指定的依赖项模块</li>
<li>replace：可以替换依赖项模块</li>
<li>exclude：可以忽略依赖项模块</li>
</ul>
</li>
<li>
<p>go mod命令</p>
<p><img src="/2021/11/02/浙江大学期末考试——Go语言/E:%5Chexo%5Csource_posts%5C%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E2%80%94%E2%80%94Go%E8%AF%AD%E8%A8%80%5Cgomod.png" alt="gomod"></p>
</li>
</ul>
<h3 id="gosum-文件"><a class="markdownIt-Anchor" href="#gosum-文件"></a> go.sum 文件</h3>
<ul>
<li>go.sum 文件 在执行 go get xxxx之后或直接编译使用第三方包的源代码时自动生成</li>
<li>详细罗列了当前项目<u>直接或间接</u>依赖的<strong>所有模块版本</strong>，并写明了那些模块版本的 <strong>SHA-256 哈希值</strong>以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改</li>
</ul>
<p><strong>go.mod 使用基本过程</strong></p>
<ul>
<li>创建项目目录Dir</li>
<li>在项目目录运行 <code>go mod init projectName</code>,生成go.mod 文件</li>
<li>在项目目录执行 go get xxxx 下载第三方包， 会生成go.sum文件 （可选）</li>
<li>在项目目录下新建子目录，创建项目子包（可选，无需再生成go.mod)</li>
</ul>
<h1 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h1>
<ul>
<li>并行是在<strong>任一粒度的时间瞬间</strong>都同时执行，比如多机并行</li>
<li>并发是在<strong>规定的时间期限内</strong>多个任务都在执行，实际底层是分时操作</li>
<li>并行强调<strong>瞬时性</strong>、并发强调<strong>过程性</strong></li>
<li>并行关键在于<strong>执行</strong>、并发关键在于<strong>结构</strong></li>
<li>单机运行时，并行通过使用多处理器以提高速度，并发程序可以是并行的，也可以不是</li>
<li>应用程序具备好的并发结构，操作系统才能更好地利用硬件并行执行</li>
</ul>
<h2 id="进程-process-线程-thread-和协程-coroutine"><a class="markdownIt-Anchor" href="#进程-process-线程-thread-和协程-coroutine"></a> 进程( process )、线程( thread )和协程( coroutine )</h2>
<ul>
<li>进程是程序在内存中<strong>运行时</strong>，<strong>操作系统</strong>对其进行资源分配和调度的独立单位</li>
<li>线程是进程的一个执行实体，是 <strong>CPU 调度和</strong>分派的基本单位，它是比进程更小的能独立运行的基本单位</li>
<li>每个进程至少包括一个线程</li>
<li>每个进程的初始线程被称为主线程，主线程终止，进程终止</li>
<li>协程是轻量级的线程，一个线程可以拥有多个协程</li>
<li>进程和线程是<strong>操作系统级</strong>的，协程<strong>是编译器级</strong>的。协程不被操作系统内核管理，而完全由程序控制，因此没有线程切换的开销。</li>
<li>和多线程比，数量越多，协程的性能优势就越明显。协程的最大优势在于其轻量级，可以轻松创建上万个而不会导致系统资源衰竭</li>
</ul>
<h2 id="go-routine-特性"><a class="markdownIt-Anchor" href="#go-routine-特性"></a> go routine 特性</h2>
<blockquote>
<ul>
<li>多数语言在语法层不支持协程，而是通过库方式，效率不高，容易阻塞</li>
<li>Go 在语言级别支持协程
<ul>
<li>命名为goroutine，关键字go</li>
<li>由Go语言运行时统一调度，合理分配给各个CPU</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>各goroutine<strong>非阻塞</strong>，不会等待</li>
<li>goroutine <strong>可以并行执行</strong></li>
<li>goroutine执行的<strong>函数返回值被忽略</strong>===&gt;因此需要得到返回结果的话需要通过chan</li>
<li><u>运行时不保证各goroutine的执行顺序</u></li>
<li>goroutine之间被<u>平等</u>地调度和执行</li>
<li>main函数会单独创建和分配一个go routine</li>
</ul>
<h2 id="协程间的通信通道"><a class="markdownIt-Anchor" href="#协程间的通信通道"></a> 协程间的通信——通道</h2>
<ul>
<li>通道是一种特殊的类型，同时只能有一个 goroutine 访问通道进行发送和获取数据。</li>
<li>通道是一个队列，遵循<strong>先入先出</strong>（FIFO）的规则</li>
<li>通道默认是<strong>阻塞</strong>的，使goroutine有效通信，不需要使用其他语言的<u>显式锁</u>或<u>条件变量</u></li>
<li>通道是<strong>引用类型</strong>，需要使用chan关键字和内置函数make 进行创建</li>
<li>通道写入和读取使用  <code>&lt;-</code>  运算符
<ul>
<li>写入 ：通道&lt;-变量</li>
<li>读取： 变量&lt;-通道</li>
</ul>
</li>
<li>通道包括无缓冲通道和有缓冲通道
<ul>
<li>无缓冲通道   make(chan  datatype)</li>
<li>有缓冲通道   make(chan  datatype，capacity)</li>
</ul>
</li>
<li>无缓冲通道只能存储一条消息，有缓冲通道可以根据make函数的capacity参数存储n条消息，按FIFO读出</li>
<li>缓冲与阻塞
<ul>
<li>无缓冲通道，写入等待读取，读取等待写入，在双方准备好之前是阻塞的</li>
<li>有缓冲通道，通道已满时的写入会等待，通道已空的读取会等待</li>
</ul>
</li>
</ul>
<p><strong>单向通道</strong></p>
<ul>
<li>通道默认为双向的，单向通道只能用于发送或接收数据</li>
<li>所谓单向通道只是对通道作为函数参数的一种使用限制，跟C语言使用const修饰函数参数为只读类似</li>
<li>通常先创建双向通道，在函数形参中利用&lt;-运算符修饰通道，使之变为只读或只写通道
<ul>
<li><code>func pull(ch &lt;-chan int) //只读 func pump(ch chan&lt;- int) //只写</code></li>
</ul>
</li>
<li>关闭通道:
<ul>
<li>关闭通道使用内置函数close(),实际上是关闭写入，即发送者告诉接收者不会再有数据发往通道</li>
<li>接收者能够在通道接收数据的同时，获取通道是否已关闭的参数  v, ok := &lt;-ch</li>
<li><code>for range</code>语句能自动判断通道是否已关闭</li>
</ul>
</li>
</ul>
<h3 id="channel底层实现"><a class="markdownIt-Anchor" href="#channel底层实现"></a> channel底层实现</h3>
<blockquote>
<p>src/runtime/chan.go:hchan定义了channel的数据结构</p>
<p>缓冲区是一个<strong>环形队列</strong></p>
<p>一个channel只能传递一种类型的值，类型信息存储在hchan数据结构</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">      qcount   	<span class="keyword">uint</span>           <span class="comment">// 当前队列中剩余元素个数</span></span><br><span class="line">      dataqsiz 	<span class="keyword">uint</span>           <span class="comment">// 环形队列长度，即可以存放的元素个数</span></span><br><span class="line">	  buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">      elemsize 	<span class="keyword">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">      closed   	<span class="keyword">uint32</span>	        <span class="comment">// 标识关闭状态</span></span><br><span class="line">      elemtype 	*_type          <span class="comment">// 元素类型</span></span><br><span class="line">      sendx   	<span class="keyword">uint</span>           <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">      recvx    	<span class="keyword">uint</span>           <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">       recvq    	waitq          <span class="comment">// 等待读消息的goroutine队列，读阻塞的goroutine会被向channel写入数据的goroutine唤醒</span></span><br><span class="line">      sendq    	waitq          <span class="comment">// 等待写消息的goroutine队列，写阻塞的goroutine会被从channel读数据的goroutine唤醒</span></span><br><span class="line">      lock 		mutex         <span class="comment">// 互斥锁，一个channel同时仅允许被一个goroutine读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通道底层实现 <strong>向channel写数据</strong></p>
<ul>
<li>如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；</li>
<li>如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；</li>
<li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒</li>
</ul>
<p><img src="/2021/11/02/浙江大学期末考试——Go语言/E:%5Chexo%5Csource_posts%5C%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E2%80%94%E2%80%94Go%E8%AF%AD%E8%A8%80%5Cchan_send.png" alt="chan_send"></p>
<p>通道底层实现 <strong>从channel读数据</strong></p>
<ul>
<li>如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；</li>
<li>如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；</li>
<li>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；</li>
<li>将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；</li>
</ul>
<p><img src="/2021/11/02/浙江大学期末考试——Go语言/E:%5Chexo%5Csource_posts%5C%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E2%80%94%E2%80%94Go%E8%AF%AD%E8%A8%80%5Cchan_recv.png" alt="chan_recv"></p>
<h2 id="定时器"><a class="markdownIt-Anchor" href="#定时器"></a> 定时器</h2>
<h3 id="timer"><a class="markdownIt-Anchor" href="#timer"></a> Timer</h3>
<blockquote>
<p>协程间的通信需设置超时等辅助机制</p>
</blockquote>
<ul>
<li>
<p>一次性定时器：定时器只计时一次，结束便停止</p>
</li>
<li>
<p>主要方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span> *<span class="title">Timer</span> // 指定一个时间创建一个<span class="title">Timer</span>，<span class="title">Timer</span>一经创建便开始计时，不需要额外的启动命令</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(t *Timer)</span> <span class="title">Stop</span><span class="params">()</span> <span class="title">bool</span>  // 停止计时器，返回值<span class="title">true</span>：定时器超时前停止， <span class="title">false</span>: 定时器超时后停止</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(t *Timer)</span> <span class="title">Reset</span><span class="params">(d Duration)</span> <span class="title">bool</span>  // 停掉定时器，再启动，返回值同上</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">After</span><span class="params">(d Duration)</span> &lt;-<span class="title">chan</span> <span class="title">Time</span>  // 创建匿名不需控制的计时器</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span>) *<span class="title">Timer</span>  // 延迟方法调用</span></span><br></pre></td></tr></table></figure>
<p>注：Timer一经创建便开始计时，不需要额外的启动命令</p>
</li>
</ul>
<h3 id="ticker"><a class="markdownIt-Anchor" href="#ticker"></a> Ticker</h3>
<blockquote>
<p>周期性定时器：定时器周期性进行计时，除非主动停止，否则将永久运行</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTicker</span><span class="params">(d Duration)</span> *<span class="title">Ticker</span> // 指定一个时间创建一个<span class="title">Ticker</span> ， <span class="title">Ticker</span>一经创建便开始计时，不需要额外的启动命令</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(t *Ticker)</span> <span class="title">Stop</span><span class="params">()</span> // 停止计时，但管道不会被关闭</span></span><br></pre></td></tr></table></figure>
<h2 id="并发函数"><a class="markdownIt-Anchor" href="#并发函数"></a> 并发函数</h2>
<h3 id="waitgroup"><a class="markdownIt-Anchor" href="#waitgroup"></a> WaitGroup</h3>
<blockquote>
<p>WaitGroup提供<strong>多个协程同步</strong>（平级）的机制，用来等待多个协程完成</p>
<p>信号量， Unix中保护共享资源的机制，用于防止多个线程同时访问某个资源</p>
</blockquote>
<ul>
<li>信号量&gt;0，表示资源可用，获取信号量时系统自动将信号量减1</li>
<li>信号量==0时，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒</li>
</ul>
<p>WaitGroup 的方法</p>
<ul>
<li>Add(delta int)  添加等待信号量</li>
<li>Done() 释放等待信号，每次减少1</li>
<li>Wait() 阻塞调用该方法的协程，直到等待信号量为0</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(i <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"started Goroutine "</span>, i)</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">"Goroutine %d ended\n"</span>, i)</span><br><span class="line">	wg.Done() <span class="comment">//goroutine执行结束后将信号量减1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">//增加信号量</span></span><br><span class="line">		<span class="keyword">go</span> process(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">//主goroutine阻塞调用该方法的协程，直到等待信号量为0</span></span><br><span class="line">	fmt.Println(<span class="string">"All go routines finished executing"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h3>
<blockquote>
<p>多路复用是在一个信道上传输多路信号或数据流，比如网线</p>
</blockquote>
<ul>
<li>select 借用网络多路复用的概念，用于监听多个通道，同时响应多个通道</li>
<li>多个通道都没有可写或可读的状态，select 会阻塞</li>
<li>有一个通道是可写或可读的， select 会执行该通道语句</li>
<li>有多个通道是可写或可读的， select 会随机选择其中一个执行</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server1</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">//可取消</span></span><br><span class="line">	ch &lt;- <span class="string">"from server1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server2</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second) <span class="comment">//可取消</span></span><br><span class="line">	ch &lt;- <span class="string">"from server2"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	output2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> server1(output1)</span><br><span class="line">	<span class="keyword">go</span> server2(output2)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> reply = &lt;-output1:</span><br><span class="line">		fmt.Println(reply)</span><br><span class="line">	<span class="keyword">case</span> reply = &lt;-output2:</span><br><span class="line">		fmt.Println(reply)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="context"><a class="markdownIt-Anchor" href="#context"></a> context</h3>
<ul>
<li>
<p>WaitGroup用来控制多个<strong>平级goroutine同时完成</strong></p>
</li>
<li>
<p>goroutine本身是平等的，但逻辑上可能有父子关系，context 表示程序上下文，是程序的运行状态，用来<strong>控制具有逻辑父子关系</strong>的多个goroutine</p>
</li>
<li>
<p>Context接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">//返回超时时间和是否已设置超时时间</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">//返回信道，当Context被撤销或过期时，该信道是关闭的</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//Done信道关闭后，Err方法表明Context被撤销的原因</span></span><br><span class="line">    Err() error</span><br><span class="line">    <span class="comment">//协程间的数据共享</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="context-使用"><a class="markdownIt-Anchor" href="#context-使用"></a> <strong>context 使用</strong></h4>
<ul>
<li>
<p>用context的树结构来给平等的goroutine 设置父子逻辑</p>
</li>
<li>
<p>context树的<strong>根节点</strong>通常是一个<strong>空的context</strong> ,由<u>第一个goroutine用Background()</u> 函数创建，该context不能被取消、没有值、也没有过期时间</p>
</li>
<li>
<p>创建子节点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将父节点复制到子节点，返回一个可以主动撤销Context的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function">//过期时间由<span class="title">deadline</span>和<span class="title">parent</span>的过期时间共同决定，<span class="title">parent</span>过期时间优先</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function">//与<span class="title">WithDeadline</span>类似，只不过传入的是从现在开始<span class="title">Context</span>剩余的生命时长</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function">//将父节点复制到子节点，子节点可扩展新的<span class="title">key</span>存储的值</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key <span class="keyword">interface</span>&#123;&#125;, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>e.g.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandelRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> WriteLog(ctx)</span><br><span class="line">	<span class="keyword">go</span> WriteDB(ctx)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">"请求处理完毕"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"请求处理中……"</span>)</span><br><span class="line">			time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteLog</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">"写日志完成"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"写日志中……"</span>)</span><br><span class="line">			time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"日志ing"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteDB</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">"写数据库完成"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"写数据库中……"</span>)</span><br><span class="line">			time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//WithCancel	一旦触发该子context的cancel, 那么该context绑定上的子协程都会被关闭</span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	ctx, cancel := context.WithCancel(context.Background())</span></span><br><span class="line"><span class="comment">	go HandelRequest(ctx)</span></span><br><span class="line"><span class="comment">	time.Sleep(5 * time.Second)</span></span><br><span class="line"><span class="comment">	fmt.Println("所有子协程都需要结束!")</span></span><br><span class="line"><span class="comment">	cancel()</span></span><br><span class="line"><span class="comment">	//Just for test whether sub goroutines exit or not</span></span><br><span class="line"><span class="comment">	time.Sleep(5 * time.Second) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//WithTimeout	子context会在5s后过期, 所以其执行的协程最多只能运行5s，相当于绑定了一个定时器</span></span><br><span class="line">	ctx, _ := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">	<span class="keyword">go</span> HandelRequest(ctx)</span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注： 关于context.WithValue和context.Value的使用方式见：<a href="https://blog.csdn.net/u012190809/article/details/107700495" target="_blank" rel="noopener">https://blog.csdn.net/u012190809/article/details/107700495</a></p>
<h3 id="mutex"><a class="markdownIt-Anchor" href="#mutex"></a> mutex</h3>
<ul>
<li>多个线程同时竞争使用某个变量可能会导致结果失控</li>
<li>mutex，互斥锁，用来保证<u>某个变量在任一时刻，只能有一个线程访问</u></li>
<li>mutex 用Lock()和Unlock()来创建资源的临界区，这一区间内的代码是线程安全的，任何一个时间点都只能有一个goroutine执行这段区间的代码</li>
<li>mutex 也可以用通道来代替，二者无优劣之分，通常不涉及<strong>线程交互数据</strong>的用<strong>mutex</strong>，其他用通道</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(wg *sync.WaitGroup, m *sync.Mutex)</span></span> &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	x = x + <span class="number">1</span> <span class="comment">//锁定后访问全局变量</span></span><br><span class="line">	m.Unlock()</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用Mutex可以用Chan中自带的Mutex来实现互斥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementByChan</span><span class="params">(wg *sync.WaitGroup, ch <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	ch &lt;- <span class="literal">true</span></span><br><span class="line">	x = x + <span class="number">1</span> <span class="comment">//锁定后访问全局变量</span></span><br><span class="line">	&lt;- ch</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> w sync.WaitGroup</span><br><span class="line">	<span class="comment">// var m sync.Mutex</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>) </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		w.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">// go increment(&amp;w, &amp;m)</span></span><br><span class="line">		<span class="keyword">go</span> incrementByChan(&amp;w, ch)</span><br><span class="line">	&#125;</span><br><span class="line">	w.Wait()</span><br><span class="line">	fmt.Println(<span class="string">"final value of x"</span>, x) <span class="comment">//结果确定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rwmutex"><a class="markdownIt-Anchor" href="#rwmutex"></a> RWMutex</h3>
<ul>
<li>
<p>RWMutex在Mutex的基础之上增加了读、写的信号量，并使用了类似引用计数的读锁数量</p>
</li>
<li>
<p>可以同时申请多个读锁</p>
</li>
<li>
<p>有读锁时申请写锁将阻塞</p>
</li>
<li>
<p>只要有写锁，后续申请读锁和写锁都将阻塞</p>
</li>
<li>
<p>主要方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span> //申请写锁</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span> //释放写锁</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span> //申请读锁</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span>//释放读锁</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>e.g.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">var</span> rm sync.RWMutex</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">20</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">			rm.Lock()</span><br><span class="line">			j++</span><br><span class="line">			fmt.Printf(<span class="string">"Write lock %d\n"</span>, j)</span><br><span class="line">			rm.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">18</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">			rm.RLock()</span><br><span class="line">			k++</span><br><span class="line">			<span class="comment">//fmt.Printf("Read lock %d\n", j)</span></span><br><span class="line">			fmt.Printf(<span class="string">"Read lock %d\n"</span>, k)</span><br><span class="line">			rm.RUnlock()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cond-condition-条件变量"><a class="markdownIt-Anchor" href="#cond-condition-条件变量"></a> Cond （ condition 条件变量）</h3>
<ul>
<li>
<p>互斥锁保证在同一时刻仅有一个线程访问某一个共享数据</p>
</li>
<li>
<p>条件变量在共享数据的状态发生变化时，通知其他因此而被阻塞的线程</p>
</li>
<li>
<p>条件变量需要用互斥锁来创建</p>
</li>
<li>
<p>主要方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个带有Locker的Cond变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br><span class="line"><span class="function">//<span class="title">Unlock</span><span class="params">()</span>-&gt;阻塞等待通知<span class="params">(等待Signal()</span>或<span class="title">Broadcast</span><span class="params">()</span>的通知)-&gt;收到通知-&gt;<span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">//激活执行<span class="title">Wait</span><span class="params">()</span>的通知队列的第一个协程</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">//激活执行<span class="title">Wait</span><span class="params">()</span>的通知队列所有协程 </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">//使用内置的互斥锁</span></span><br><span class="line"><span class="function"><span class="title">cond</span>.<span class="title">L</span>.<span class="title">Lock</span><span class="params">()</span>和<span class="title">cond</span>.<span class="title">L</span>.<span class="title">Unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>e.g.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> locker = <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			cond.L.Lock()         <span class="comment">// wait 前，必须要先加锁</span></span><br><span class="line">			<span class="keyword">defer</span> cond.L.Unlock() <span class="comment">//保障释放资源</span></span><br><span class="line">			cond.Wait()</span><br><span class="line">			fmt.Println(x)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="string">"Signal...."</span>)</span><br><span class="line">	cond.Signal() <span class="comment">// 下发一个通知给已经获取锁的goroutine</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">	fmt.Println(<span class="string">"Signal...."</span>)</span><br><span class="line">	cond.Signal() <span class="comment">// 3 秒之后，下发一个通知给已经获取锁的goroutine</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">	fmt.Println(<span class="string">"Broadcast..."</span>)</span><br><span class="line">	cond.Broadcast() <span class="comment">// 3 秒之后，下发通知给所有已经获取锁的goroutine</span></span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="附"><a class="markdownIt-Anchor" href="#附"></a> 附：</h1>
<h2 id="语言设计思想"><a class="markdownIt-Anchor" href="#语言设计思想"></a> 语言设计思想</h2>
<ul>
<li>
<p>保证只有一种写法</p>
</li>
<li>
<p>少即是多</p>
</li>
<li>
<p>GO 不支持class ,使用结构代替类，<strong><u>结构字段用来封装对象属性，方法用来封装对象的行为</u></strong></p>
</li>
<li>
<p>用类型组合来实现继承</p>
</li>
<li>
<p>多态：Go中只要结构体实现了接口的部分方法，就可以通过接口指向该结构体，并且使用被实现的方法。因此，可以看到Go的代码中函数传参很多都是接口，但真正使用的时候传入的是实现了该接口的struct，这就是Go中多态提现的一个例子。</p>
</li>
</ul>
<h2 id="new-和-make区别"><a class="markdownIt-Anchor" href="#new-和-make区别"></a> new 和 make区别</h2>
<ul>
<li>new和make是内建的两个函数，主要用来在堆上创建分配类型的内存</li>
<li>new用于普通类型的内存分配，内存清零，返回<strong>该类型指针</strong></li>
<li>make（专门）用于slice、map以及channel的初始化，返回<strong>引用</strong></li>
</ul>
<h2 id="golang中分为值类型和引用类型"><a class="markdownIt-Anchor" href="#golang中分为值类型和引用类型"></a> golang中分为值类型和引用类型</h2>
<ul>
<li>
<p>值类型分别有：int系列、float系列、bool、string、数组和结构体</p>
</li>
<li>
<p>引用类型有：指针、slice切片、管道channel、接口interface、map、函数等</p>
</li>
<li>
<p>值类型的特点是：变量直接存储值，内存通常在栈中分配</p>
</li>
<li>
<p>引用类型的特点是：变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在堆中分配</p>
</li>
</ul>
<h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2>
<h3 id="go中引用类型有哪些"><a class="markdownIt-Anchor" href="#go中引用类型有哪些"></a> Go中引用类型有哪些？</h3>
<p>在 Go 语言中，引用类型有 切片 (slice) 、 字典 (map) 、 接口 (interface) 、 函数 (func) 以及 通道 (chan) 。</p>
<p>引用类型之所以可以引用，是因为我们创建引用类型的变量，其实是一个标头值，标头值里包含一个<strong>指针</strong>，指向底层的数据结构，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递，这也是引用类型传递高效的原因。</p>
<p>注：用户自定义类型不是引用类型===&gt;所以函数传参的时候都传的是地址，形参都是指针类型。And: 引用类型不支持<code>==</code>运算符，无法直接比较</p>
<p>总结：Go中规定的引用类型就5个：切片 (slice) 、 字典 (map) 、 接口 (interface) 、 函数 (func) 以及 通道 (chan)，但传参为这几个类型的时候，不需要传指针，直接用相应的类型即可。</p>
<h2 id="课上训练题"><a class="markdownIt-Anchor" href="#课上训练题"></a> 课上训练题</h2>
<h3 id="自定义排序"><a class="markdownIt-Anchor" href="#自定义排序"></a> 自定义排序</h3>
<blockquote>
<p>标准库的 sort 包采用的是快速排序</p>
</blockquote>
<p>请模仿其实现，基于Sorter 接口实现冒泡排序</p>
<h3 id="请按如下要求设计协程交互代码"><a class="markdownIt-Anchor" href="#请按如下要求设计协程交互代码"></a> 请按如下要求设计协程交互代码</h3>
<ul>
<li>协程一随机给出0~100的数</li>
<li>协程二猜协程一的数，猜中的话协程一返回信号0，结束程序；猜小了协程一返回信号-1，猜大了协程一返回信号1，继续猜</li>
<li>打印猜数过程</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> gg</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> up = <span class="number">100</span></span><br><span class="line"> <span class="keyword">var</span> down = <span class="number">0</span></span><br><span class="line"> <span class="keyword">var</span> last = <span class="number">-1</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">guest</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	 <span class="keyword">for</span> &#123;</span><br><span class="line">		signn := &lt;- ch</span><br><span class="line">		fmt.Printf(<span class="string">"协程得到的sign: %v\n"</span>, signn)</span><br><span class="line">		<span class="keyword">var</span> ths <span class="keyword">int</span></span><br><span class="line">		<span class="keyword">switch</span> signn&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">				<span class="comment">// down ~ last</span></span><br><span class="line">				down = last</span><br><span class="line">				ths = rand.Intn(up - down) + down</span><br><span class="line">				fmt.Printf(<span class="string">"协程随机到的ths: %v\n"</span>, ths)</span><br><span class="line">				ch &lt;- ths</span><br><span class="line">				last = ths</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="comment">// last ~ up</span></span><br><span class="line">				up = last</span><br><span class="line">				ths = rand.Intn(up-down) + down</span><br><span class="line">				fmt.Printf(<span class="string">"协程随机到的ths: %v\n"</span>, ths)</span><br><span class="line">				ch &lt;- ths</span><br><span class="line">				last = ths</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	 rand.Seed(time.Now().UnixNano())</span><br><span class="line">	 num := rand.Intn(<span class="number">100</span>)</span><br><span class="line">	 fmt.Printf(<span class="string">"随机到的数为: %v\n"</span>, num)</span><br><span class="line">	 ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">	 ch &lt;- <span class="number">-1</span></span><br><span class="line">	 <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">	 <span class="keyword">go</span> guest(ch)</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">for</span> &#123;</span><br><span class="line">		 n = &lt;- ch</span><br><span class="line">		 fmt.Printf(<span class="string">"主线程得到数值为%v\n"</span>, n)</span><br><span class="line">		 <span class="keyword">if</span> ( n == num )&#123;</span><br><span class="line">			 ch &lt;- <span class="number">0</span></span><br><span class="line">			 fmt.Printf(<span class="string">"协程猜中啦, 数值为%v\n"</span>, n)</span><br><span class="line">			 <span class="keyword">break</span></span><br><span class="line">		 &#125;<span class="keyword">else</span> <span class="keyword">if</span> (n &lt; num)&#123;</span><br><span class="line">			 ch &lt;- <span class="number">-1</span></span><br><span class="line">		 &#125;<span class="keyword">else</span> <span class="keyword">if</span> (n&gt; num)&#123;</span><br><span class="line">			 ch &lt;- <span class="number">1</span></span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="go复习题目"><a class="markdownIt-Anchor" href="#go复习题目"></a> Go复习题目：</h2>
<ul>
<li><a href="https://geektutu.com/post/qa-golang-1.html" target="_blank" rel="noopener">Go 语言笔试面试题(基础语法)</a>——基础知识题</li>
<li>★<a href="https://www.cnblogs.com/double-W/p/12774095.html" target="_blank" rel="noopener">GO语言测试题</a></li>
<li>同学推荐的<a href="https://tour.go-zh.org/basics/1" target="_blank" rel="noopener">Go指南</a>——可以根据概念实现做点题</li>
</ul>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>
<h2 id="考试中容易出的坑题"><a class="markdownIt-Anchor" href="#考试中容易出的坑题"></a> 考试中容易出的坑题：</h2>
<ul>
<li>▲与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换</li>
<li>▲与 C 不同，Go 没有指针运算。</li>
</ul>
<p>容易踩的坑：</p>
<ul>
<li>
<p>nil 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。</p>
</li>
<li>
<p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map添加元素则会造成运行时 panic</p>
</li>
<li>
<p>string 类型的变量值不能为 nil ==&gt; string 的零值为&quot;&quot;</p>
</li>
<li>
<p>访问 map 中不存在的 key，Go中返回的是零值，而不是报错</p>
</li>
<li>
<p>range后迭代对象：数组、通道、string、map</p>
<ul>
<li>数组：for i, v := range arr，i为索引，v为arr[i]的值</li>
<li>通道：for data := ch, data为数据</li>
<li><strong>range 迭代 string 得到的值:</strong>
<ul>
<li>range 得到的索引是字符值（Unicode point / rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。</li>
<li>注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用norm 包。</li>
<li>for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。</li>
</ul>
</li>
<li>range 迭代 map
<ul>
<li>如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。</li>
<li>Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的</li>
<li>如果你去 Go Playground 重复运行上边的代码，输出是不会变的，只有你<u>更新代码它才会重新编译</u>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>string 与 byte slice 之间的转换：Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配：</p>
<ul>
<li>在 map[string] 中查找 key 时，使用了对应的 []byte，避免做 m[string(key)] 的内存分配</li>
<li>使用 for range 迭代 string 转换为 []<strong>byte</strong> 的迭代：for i,v := range []byte(str) {…}</li>
</ul>
</li>
<li>
<p>在多行 array、slice、map 语句的末尾缺少 , 号</p>
</li>
<li>
<p>switch 中的 fallthrough 语句：switch 语句中的 case 代码块会默认带上 break，但可以使用 fallthrough 来强制执行下一个 case 代码块。  &lt;=等价于=&gt;改写成 case 为多条件判断：</p>
</li>
<li>
<p>自增和自减运算： Go 特立独行，<strong>去掉了前置操作</strong>，同时 ++、-- 只作为运算符而非表达式。</p>
</li>
<li>
<p>不导出的 struct 字段无法被 encode。以小写字母开头的字段成员是无法被外部直接访问的，所以 struct 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：</p>
</li>
<li>
<p>Go程序默认不等所有 goroutine 都执行完才退出</p>
</li>
<li>
<p>常用解决办法：使用 “WaitGroup” 变量，它会让主程序等待所有 goroutine 执行完毕再退出。</p>
</li>
<li>
<p>向已关闭的 channel 发送数据会造成 panic</p>
</li>
<li>
<p>在一个值为 nil 的 channel 上发送和接收数据将永久阻塞：</p>
</li>
<li>
<p>▲<strong>若函数 receiver 传参是传值方式，则无法修改参数的原有值</strong></p>
</li>
<li>
<p>从一个现有的非 interface 类型创建新类型时，并不会继承原有的方法：</p>
</li>
<li>
<p>跳出 for-switch 和 for-select 代码块：没有指定标签的 break 只会跳出 switch/select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块：</p>
</li>
<li>
<p>Go里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main）</p>
</li>
<li>
<p>对Slice使用append，当长度超出时会返回新的Slice，因此无法在递归的时候不能直接传引用对象，而是需要传指针<code>*[]int</code>指针，并且在append的时候改成<code>*ans = append(*ans, root.Val)</code></p>
<ul>
<li>
<p>见<strong>Leetcode94树的中层遍历：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	OrderTravel(root, &amp;ans)</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果ans不传指针，而是直接ans []int传参，关注ans地址变化，输出地址得到：</span></span><br><span class="line"><span class="comment">append前:0xc000004078</span></span><br><span class="line"><span class="comment">append后:0xc000004078</span></span><br><span class="line"><span class="comment">append前:0xc0000040c0</span></span><br><span class="line"><span class="comment">append后:0xc0000040c0</span></span><br><span class="line"><span class="comment">append前:0xc0000040a8</span></span><br><span class="line"><span class="comment">append后:0xc0000040a8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderTravel</span><span class="params">(root *TreeNode, ans *[]<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	OrderTravel(root.Left, ans)</span><br><span class="line">	*ans = <span class="built_in">append</span>(*ans, root.Val)</span><br><span class="line">	OrderTravel(root.Right, ans)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 修改成传指针后ans的地址就始终是一致的了</span></span><br><span class="line"><span class="comment">append前: 0xc000004078</span></span><br><span class="line"><span class="comment">append后: 0xc000004078</span></span><br><span class="line"><span class="comment">append前: 0xc000004078</span></span><br><span class="line"><span class="comment">append后: 0xc000004078</span></span><br><span class="line"><span class="comment">append前: 0xc000004078</span></span><br><span class="line"><span class="comment">append后: 0xc000004078</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	root := &amp;TreeNode&#123;</span><br><span class="line">		Val: <span class="number">1</span>,</span><br><span class="line">		Left: <span class="literal">nil</span>,</span><br><span class="line">		Right: &amp;TreeNode&#123;</span><br><span class="line">			Val: <span class="number">2</span>,</span><br><span class="line">			Left: &amp;TreeNode&#123;Val: <span class="number">3</span>&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	res := inorderTraversal(root)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>from：<a href="https://www.topgoer.com/%E8%B5%84%E6%96%99%E4%B8%8B%E8%BD%BD/Golang%E6%96%B0%E6%89%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%B8%A9%E7%9A%8450%E4%B8%AA%E5%9D%91.html" target="_blank" rel="noopener">Golang新手可能会踩的50个坑</a></p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2021/11/02/浙江大学期末考试——Go语言/">https://nymrli.top/2021/11/02/浙江大学期末考试——Go语言/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2022/01/26/语义化的版本控制/" title="语义化的版本控制"><span>< PreviousPost</span><br><span class="prevTitle">语义化的版本控制</span></a><a class="nextSlogan" href="/2021/09/27/物联网基础与应用-课程笔记/" title="物联网基础与应用-课程笔记"><span>NextPost ></span><br><span class="nextTitle">物联网基础与应用-课程笔记</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '浙江大学期末考试——Go语言',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><a href="https://beian.miit.gov.cn/"> <span>备案号:苏ICP备18015439号</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#浙江大学期末考试go语言"><span class="toc-number">1.</span> <span class="toc-text"> 浙江大学期末考试——Go语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概论"><span class="toc-number">1.1.</span> <span class="toc-text"> 概论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 算法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本特征"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 基本特征：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构化程序设计特点"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 结构化程序设计特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oop"><span class="toc-number">1.1.4.</span> <span class="toc-text"> OOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-特性"><span class="toc-number">1.1.5.</span> <span class="toc-text"> GO 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语言环境变量"><span class="toc-number">1.1.6.</span> <span class="toc-text"> 语言环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go语言的源码文件有三大类"><span class="toc-number">1.1.7.</span> <span class="toc-text"> Go语言的源码文件有三大类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-token标记"><span class="toc-number">1.1.8.</span> <span class="toc-text"> Go Token(标记)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-number">1.2.</span> <span class="toc-text"> 变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iota枚举"><span class="toc-number">1.3.</span> <span class="toc-text"> iota枚举</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#语法"><span class="toc-number">2.</span> <span class="toc-text"> 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#条件语句"><span class="toc-number">2.1.</span> <span class="toc-text"> 条件语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if"><span class="toc-number">2.1.1.</span> <span class="toc-text"> if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">2.1.2.</span> <span class="toc-text"> switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环语句"><span class="toc-number">2.2.</span> <span class="toc-text"> 循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-number">2.2.1.</span> <span class="toc-text"> for</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移语句"><span class="toc-number">2.3.</span> <span class="toc-text"> 转移语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据类型"><span class="toc-number">3.</span> <span class="toc-text"> 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bool类型"><span class="toc-number">3.1.</span> <span class="toc-text"> Bool类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符类型"><span class="toc-number">3.2.</span> <span class="toc-text"> 字符类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串类型"><span class="toc-number">3.3.</span> <span class="toc-text"> 字符串类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运算符"><span class="toc-number">4.</span> <span class="toc-text"> 运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合数据类型"><span class="toc-number">5.</span> <span class="toc-text"> 集合数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组array"><span class="toc-number">5.1.</span> <span class="toc-text"> 数组（Array）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#切片-slice"><span class="toc-number">5.2.</span> <span class="toc-text"> 切片（ Slice）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#映射-map"><span class="toc-number">5.3.</span> <span class="toc-text"> 映射（ Map）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">6.</span> <span class="toc-text"> 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#语法格式"><span class="toc-number">6.1.</span> <span class="toc-text"> 语法格式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数参数"><span class="toc-number">6.2.</span> <span class="toc-text"> 函数参数：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不定参数"><span class="toc-number">6.2.1.</span> <span class="toc-text"> 不定参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数类型"><span class="toc-number">6.3.</span> <span class="toc-text"> 函数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名函数"><span class="toc-number">6.4.</span> <span class="toc-text"> 匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-number">6.5.</span> <span class="toc-text"> 闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#返回值"><span class="toc-number">6.6.</span> <span class="toc-text"> 返回值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#defer"><span class="toc-number">7.</span> <span class="toc-text"> defer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结构体"><span class="toc-number">8.</span> <span class="toc-text"> 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用"><span class="toc-number">8.1.</span> <span class="toc-text"> 使用：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#命名类型结构"><span class="toc-number">8.1.1.</span> <span class="toc-text"> 命名类型结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名类型结构直接创建结构变量"><span class="toc-number">8.1.2.</span> <span class="toc-text"> 匿名类型结构（直接创建结构变量）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问结构体数据"><span class="toc-number">8.1.3.</span> <span class="toc-text"> 访问结构体数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#嵌套结构"><span class="toc-number">8.2.</span> <span class="toc-text"> 嵌套结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#子结构字段提升"><span class="toc-number">8.2.1.</span> <span class="toc-text"> 子结构字段提升</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法"><span class="toc-number">9.</span> <span class="toc-text"> 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#方法提升"><span class="toc-number">9.1.</span> <span class="toc-text"> 方法提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法值"><span class="toc-number">9.2.</span> <span class="toc-text"> 方法值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#接口"><span class="toc-number">10.</span> <span class="toc-text"> 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#空接口"><span class="toc-number">10.1.</span> <span class="toc-text"> 空接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口初始化"><span class="toc-number">10.2.</span> <span class="toc-text"> 接口初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-的面向对象"><span class="toc-number">10.3.</span> <span class="toc-text"> GO 的面向对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型断言"><span class="toc-number">11.</span> <span class="toc-text"> 类型断言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反射"><span class="toc-number">12.</span> <span class="toc-text"> 反射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理"><span class="toc-number">13.</span> <span class="toc-text"> 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#错误实现"><span class="toc-number">13.1.</span> <span class="toc-text"> 错误实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建错误"><span class="toc-number">13.1.1.</span> <span class="toc-text"> 创建错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建自定义错误"><span class="toc-number">13.1.2.</span> <span class="toc-text"> 创建自定义错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#panic恐慌"><span class="toc-number">13.2.</span> <span class="toc-text"> panic（恐慌）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#panicking终止过程"><span class="toc-number">13.2.1.</span> <span class="toc-text"> panicking终止过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#recover"><span class="toc-number">13.3.</span> <span class="toc-text"> recover</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#包"><span class="toc-number">14.</span> <span class="toc-text"> 包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#包的引用格式"><span class="toc-number">14.1.</span> <span class="toc-text"> 包的引用格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init"><span class="toc-number">14.2.</span> <span class="toc-text"> init( )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包加载顺序"><span class="toc-number">14.3.</span> <span class="toc-text"> 包加载顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包内标识符导出向外暴露"><span class="toc-number">14.4.</span> <span class="toc-text"> 包内标识符导出——向外暴露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gomod"><span class="toc-number">14.5.</span> <span class="toc-text"> go.mod</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gosum-文件"><span class="toc-number">14.5.1.</span> <span class="toc-text"> go.sum 文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发"><span class="toc-number">15.</span> <span class="toc-text"> 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程-process-线程-thread-和协程-coroutine"><span class="toc-number">15.1.</span> <span class="toc-text"> 进程( process )、线程( thread )和协程( coroutine )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-routine-特性"><span class="toc-number">15.2.</span> <span class="toc-text"> go routine 特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协程间的通信通道"><span class="toc-number">15.3.</span> <span class="toc-text"> 协程间的通信——通道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#channel底层实现"><span class="toc-number">15.3.1.</span> <span class="toc-text"> channel底层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定时器"><span class="toc-number">15.4.</span> <span class="toc-text"> 定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#timer"><span class="toc-number">15.4.1.</span> <span class="toc-text"> Timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ticker"><span class="toc-number">15.4.2.</span> <span class="toc-text"> Ticker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发函数"><span class="toc-number">15.5.</span> <span class="toc-text"> 并发函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#waitgroup"><span class="toc-number">15.5.1.</span> <span class="toc-text"> WaitGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select"><span class="toc-number">15.5.2.</span> <span class="toc-text"> select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#context"><span class="toc-number">15.5.3.</span> <span class="toc-text"> context</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#context-使用"><span class="toc-number">15.5.3.1.</span> <span class="toc-text"> context 使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mutex"><span class="toc-number">15.5.4.</span> <span class="toc-text"> mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rwmutex"><span class="toc-number">15.5.5.</span> <span class="toc-text"> RWMutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cond-condition-条件变量"><span class="toc-number">15.5.6.</span> <span class="toc-text"> Cond （ condition 条件变量）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附"><span class="toc-number">16.</span> <span class="toc-text"> 附：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#语言设计思想"><span class="toc-number">16.1.</span> <span class="toc-text"> 语言设计思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-和-make区别"><span class="toc-number">16.2.</span> <span class="toc-text"> new 和 make区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#golang中分为值类型和引用类型"><span class="toc-number">16.3.</span> <span class="toc-text"> golang中分为值类型和引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题"><span class="toc-number">16.4.</span> <span class="toc-text"> 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#go中引用类型有哪些"><span class="toc-number">16.4.1.</span> <span class="toc-text"> Go中引用类型有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#课上训练题"><span class="toc-number">16.5.</span> <span class="toc-text"> 课上训练题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义排序"><span class="toc-number">16.5.1.</span> <span class="toc-text"> 自定义排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请按如下要求设计协程交互代码"><span class="toc-number">16.5.2.</span> <span class="toc-text"> 请按如下要求设计协程交互代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go复习题目"><span class="toc-number">16.6.</span> <span class="toc-text"> Go复习题目：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#"><span class="toc-number">16.7.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#考试中容易出的坑题"><span class="toc-number">16.8.</span> <span class="toc-text"> 考试中容易出的坑题：</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>