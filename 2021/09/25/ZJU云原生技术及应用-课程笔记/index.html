<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>ZJU云原生技术及应用-课程笔记 · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">ZJU云原生技术及应用-课程笔记</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2022/03/15</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="ZJU课程"> ZJU课程</a><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="云原生"> 云原生</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">7,517</span> | Reading time: <span class="post-count">29</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="zju要求"><a class="markdownIt-Anchor" href="#zju要求"></a> ZJU要求</h1>
<h2 id="课程内容"><a class="markdownIt-Anchor" href="#课程内容"></a> 课程内容</h2>
<ul>
<li>云计算基本概念和Docker容器原理（4课时）</li>
<li>Kubernetes核心原理与关键组件 （8课时）</li>
<li>微服务技术原理与治理 （4课时）</li>
<li>容器监控与分析 （4课时）</li>
<li>云原生边缘计算技术（4课时）</li>
<li>IBM讲座-混合云架构（4课时）</li>
<li>云原生应用实践与案例分析（4课时）</li>
</ul>
<h2 id="考核方式"><a class="markdownIt-Anchor" href="#考核方式"></a> <strong>考核方式</strong></h2>
<blockquote>
<p>平时（20%）+ 课程设计（80%，含报告）</p>
</blockquote>
<p><strong>课程设计（三选一）</strong></p>
<ol>
<li>
<p>云原生技术研究报告或综述</p>
<p>围绕云原生关键技术点，如容器安全、多集群管理、云边协同和边缘智能等，综述当前技术现状并进行必要的分析</p>
</li>
<li>
<p>源代码分析报告</p>
<p>分析Kubernetes或者KubeEdge等云原生项目相关源代码，撰写代码分析报告（行级代码标注+工作流分析），不少于10页，原创。</p>
</li>
<li>
<p>开源贡献</p>
<p>修改Kubernetes/KubeEdge/Docker提交PR，根据代码行数折算（100行源代码或者5个commit）</p>
<p>未能通过社区审核，通过测试验证的代码可以作为参考评分</p>
</li>
</ol>
<h1 id="云原生"><a class="markdownIt-Anchor" href="#云原生"></a> 云原生</h1>
<h2 id="docker技术原理与实践"><a class="markdownIt-Anchor" href="#docker技术原理与实践"></a> Docker技术原理与实践</h2>
<blockquote>
<p>Docker是Docker公司开源的一个基于<strong>轻量级虚拟化技术</strong>的容器引擎项目,整个项目基于Go语言开发，并遵从Apache 2.0协议</p>
<p>目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术 (namespaces及cgroups等)来提供容器的资源隔离与安全保障等。</p>
<p>由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，不需要类 似虚拟机(VM)额外的操作系统开销，提高资源利用率，并且提升诸如IO等方面的性能。</p>
</blockquote>
<h3 id="docker本质就是进程"><a class="markdownIt-Anchor" href="#docker本质就是进程"></a> docker本质就是进程？</h3>
<p>A: 理解这句话得具备linux的基础知识，从基础知识角度来进行理解。首先docker的两大关键技术是Namespace和cgroup：Namespace技术改变了容器的视图，让容器以为自己在一个房间里，起到了隔离作用；cgroup(Linux Control Group)起到对容器资源的限制作用</p>
<p>namespace和cgroup共同为创造了一个容器沙盒。</p>
<p>==&gt;容器是个进程，通过namespace作为障眼法进行屏蔽，结合cgroup进行资源限制，并以容器镜像的方式打包的一个沙盒</p>
<p><strong>Docker应用场景</strong></p>
<ul>
<li>web应用的自动化打包和发布</li>
<li>自动化测试和持续集成、 发布</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用</li>
<li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li>
</ul>
<p><strong>Docker优势</strong></p>
<ul>
<li>更低的资源损耗</li>
<li>更快的启动速度</li>
<li>更好的应用耦合</li>
<li>更强的弹性伸缩</li>
</ul>
<p><strong>Docker架构</strong></p>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cdocker%E6%9E%B6%E6%9E%84.png" alt="docker架构"></p>
<p><strong>基本要素</strong></p>
<ul>
<li>Docker Images是一个只读模板，用来运行Docker容器</li>
<li>Docker Containers负责应用程序的运行，包括操作系统、用户添加的文件以及元数据。</li>
<li>DockerFile是文件指令集，用来说明如何自动创建Docker镜像。</li>
</ul>
<p><strong>核心组件</strong></p>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cdocker%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" alt="docker核心组件"></p>
<p><strong>容器和镜像的关系</strong></p>
<blockquote>
<p>好比静态的源码和运行时的程序，使用执行源码即可得到想要功能的程序，同样的依据镜像从而能够构建通过镜像制定的容器。</p>
</blockquote>
<p><strong>镜像特点：</strong></p>
<ul>
<li>layer： 分层
<ul>
<li>读写层</li>
<li>init层</li>
<li>只读层</li>
</ul>
</li>
<li>based on another image ： 基于其他镜像</li>
<li>a read-only template：是只读的模板</li>
<li>copy-on-write： 下层只读，上层可写</li>
<li>union filesystem：有独立的文件系统</li>
<li>DockerFile or docker commit：通过dockerfile或者docker commit生成</li>
</ul>
<p><strong>数据卷：</strong></p>
<blockquote>
<p>▲当一个容器被删除时，任何写入该容器的、没有存储在数据卷中的数据都会和该容器一起被删除。==&gt;因此需要个可以独立于容器存储的外存。</p>
</blockquote>
<ul>
<li>数据卷不受存储驱动器的控制。</li>
<li>你可以把任何数量的数据卷装入一个容器。</li>
<li>多个容器也可以共享一个或多个数据卷</li>
</ul>
<p><strong>docker CLI</strong></p>
<img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/hexo\source\_posts\ZJU云原生技术及应用-课程笔记\dockerCLI.png" alt="dockerCLI" style="zoom:50%;">
<p><strong>docker pull过程</strong></p>
<img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/hexo\source\_posts\ZJU云原生技术及应用-课程笔记\dockerpull.jpg" alt="dockerpull" style="zoom:50%;">
<p><strong>docker run过程</strong></p>
<img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/hexo\source\_posts\ZJU云原生技术及应用-课程笔记\dockerrun.jpg" alt="dockerrun" style="zoom:50%;">
<p><strong>Dockerfile指令说明</strong></p>
<ul>
<li>FROM：初始化一个<strong>新的构建阶段</strong>，并为后续指令<strong>设置基础镜像</strong></li>
<li>ENV：为你的容器安装的软件更新PATH环境变量。</li>
<li>RUN： 在容器构建过程中运行的命令，如apt。为了使你的Docker文件更易读、易懂、易维护，请将长的或复杂的RUN语句分成多行，用反斜线分开</li>
<li><strong>COPY and ADD</strong>: 复制文件到指定路径，ADD相比之下多个类似tar<strong>解压</strong>的功能</li>
<li><strong>EXPOSE</strong>： 容器将监听连接的端口</li>
<li><strong>WORKDIR</strong>： 指定工作目录，并以绝对路径的形式给出</li>
<li><strong>CMD</strong>：容器构建完成后执行命令，主要目的是为执行中的容器提供默认值。这些默认值可以包括一个可执行文件，也可以省略可执行文件，在这种情况下，你必须同时指定一个ENTRYPOINT指令。一个Docker文件中只能有一条CMD指令。如果有多个CMD，那么只有最后一个CMD才会生效。</li>
<li>ENTRYPOINT：允许你配置一个将作为可执行文件运行的容器。<br>
<code>docker run &lt;image&gt;</code>的命令行参数将被附加在exec形式的ENTRYPOINT的所有元素之后，并将覆盖所有使用CMD指定的元素。这允许将参数传递给入口点，例如，docker run <image> -d将把-d参数传递给入口点。你可以使用docker run --entrypoint标志来覆盖ENTRYPOINT指令。<br>
只有Docker文件中的最后一条ENTRYPOINT指令才会有效果。</image></li>
</ul>
<p>Q:如何使得镜像轻量？</p>
<p>A:从一个合适的基础镜像开始；使用多阶段构建；如果你有多个有很多共同点的镜像，考虑用<strong>共享的组件</strong>创建你自己的基础镜像，并在此基础上创建你的独特镜像；为了保持你的生产图像的精简，但允许调试，考虑使用生产图像作为调试图像的基础图像；当建立图像时，总是用有用的tags来标记它们</p>
<h2 id="云计算技术基本原理"><a class="markdownIt-Anchor" href="#云计算技术基本原理"></a> 云计算技术基本原理</h2>
<h2 id="kubernetes核心原理与关键组件"><a class="markdownIt-Anchor" href="#kubernetes核心原理与关键组件"></a> Kubernetes核心原理与关键组件</h2>
<p><strong>云计算</strong>定义：云计算是一种动态扩展的计算模式，通过网络将虚拟化的资源作为服务提供</p>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5C%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F.png" alt="云计算服务模式"></p>
<p><strong>云架构图</strong></p>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5C%E4%BA%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="云架构图"></p>
<h3 id="cloud-foundry云平台"><a class="markdownIt-Anchor" href="#cloud-foundry云平台"></a> Cloud Foundry云平台</h3>
<blockquote>
<p>Cloud Foundry是VMware于推出的业界第一个开源PaaS云平台，专为私有云计算环境、企业级数据中心和公有云服务提供商所打造，可以简化现代应用程序的开发、交付和运行过程，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题。</p>
</blockquote>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5CCloudFoundry.png" alt="CloudFoundry"></p>
<p><strong>Router</strong></p>
<p>Router是整个平台的流量入口，负责分发所有的请求到对应的组件，包括来自外部用户对app的请求和平台内部的管理请求。</p>
<p>Router是PaaS平台中至关重要的一个组件，它在内存中维护了一张路由表，记录了域名与实例的对应关系，所谓的实例自动迁移，靠得就是这张路由表，某实例宕掉了，就从路由表中剔除，新实例创建了，就加入路由表。</p>
<p><strong>状态服务</strong></p>
<ul>
<li><strong>无状态服务</strong>在容器化的世界里很受欢迎，因为它们是一次性的，而且很容易用容器镜像重新创建。<br>
除了像Web服务器这样的无状态服务，用户越来越多地使用容器来部署有状态服务，以受益于 “<strong>一次构建，随地运行</strong>”，并提高裸机效率/利用率。<br>
这些 &quot;宠物 &quot;（需要满足的需求）带来了新的要求，包括更长的生命周期、配置依赖性和有状态的故障转移。容器编排必须解决这些需求，以成功部署和扩展应用程序。</li>
</ul>
<h3 id="k8s命令"><a class="markdownIt-Anchor" href="#k8s命令"></a> K8s命令</h3>
<p><strong>K8s设计原则</strong></p>
<ul>
<li>声明式 状态驱动<br>
用户通过声明式的配置文件（例如 YAML 文件）向 Kubernetes 告白自己希望达到的系统状态（例如：运行拥有 5 个副本的 nginx 服务）。</li>
<li>行动（React）<br>
Kubernetes 的控制组件负责具体执行这些指令，使得用户声明的系统状态得以实现；在此过程中不需要任何人工的参与。</li>
<li>观测（Observe）：<br>
Kubernetes会观测到新的用户声明，并自动分析出需要执行的操作以达到用户声明的系统状态（例如在集群中选取5个合适的节点，并在这 5 个节点上下载合适的 nginx 镜像并启动容器，以及配置相应的负载均衡策略等）。</li>
</ul>
<h3 id="k8s架构"><a class="markdownIt-Anchor" href="#k8s架构"></a> <strong>K8s架构</strong></h3>
<blockquote>
<p>Kubernetes主要组件有：API Server、Controller Manager、Scheduler、kubelet、kube-proxy，其中前三者运行于集群的Master节点，后两者运行于集群的Worker节点。</p>
</blockquote>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Ck8s%E6%9E%B6%E6%9E%84.png" alt="k8s架构"></p>
<p><strong>Master</strong></p>
<ul>
<li>集群控制节点，负责集群管理与控制，通常运行在独立物理节点或者虚拟机</li>
<li>运行各类关键进程
<ul>
<li>
<p>API Server （kube-apiserver）：提供REST接口的关键服务进程</p>
<ul>
<li>
<p>集群管理的API入口</p>
<p>资源配额控制的入口</p>
<p>提供了完备的集群安全机制</p>
</li>
</ul>
</li>
<li>
<p>Controller Manager（kube-controller-manager)：所有资源的自动化控制中心</p>
<ul>
<li>ResourceQuota Controller</li>
<li>Namespace Controller</li>
<li>Endpoints Controller</li>
</ul>
</li>
<li>
<p>Scheduler（Kube-scheduler）：负责Pod资源调度</p>
</li>
<li>
<p>Etcd Server：所有资源对象的数据全部保存在etcd中</p>
</li>
</ul>
</li>
</ul>
<p><strong>Node</strong></p>
<blockquote>
<p>Kubernetes集群中除Master外的节点，又叫Minion，同样可以是物理主机或者虚拟机</p>
</blockquote>
<ul>
<li>作为集群中的工作负载节点，承担Master分配的工作负载<br>
Node可以动态增减，新增node会自动到master节点注册</li>
<li>Node运行的进程：
<ul>
<li>kubelet：pod启停及与master节点协作
<ul>
<li>Ø节点管理</li>
<li>ØPod管理</li>
<li>Ø容器健康检查</li>
<li>Ø资源监控</li>
</ul>
</li>
<li>kube-proxy：实现Kubenetes Service通信与负载均衡机制</li>
<li>Docker Engine：负责本机容器的创建和管理工作</li>
</ul>
</li>
</ul>
<p><strong>Pod：</strong></p>
<ul>
<li>Pod是一组紧密关联的容器集合，是Kubernetes 调度的基本单位，不可分割。</li>
<li>一个Pod里的多个容器可以共享存储和网络，可以看作一个逻辑的主机。共享的如 namespace,cgroups或者其他的隔离资源。</li>
</ul>
<p>创建Pod时的大概流程：<br>
1：<strong>kubectl</strong> 向K8s API发送一个REST HTTP请求<br>
2：调度器将其调度到一个工作节点上<br>
3：被调度的工作节点上的<strong>kubelet</strong>会告知Node节点上的Docker engine拉取镜像，下载后运行容器。</p>
<p><strong>创建pod</strong></p>
<blockquote>
<p>创建Pod可以使用两种方式，一种是通过命令行加各种命令行参数的方式，另一种是文件方式创建（推荐）</p>
</blockquote>
<ol>
<li>
<p>通过命令行直接创建: <code>kubectl run ${name} --image=${imageName} --port=${port}</code> (实际是运行了一个deployment，让deployment自动创建并维护pod)</p>
</li>
<li>
<p>通过yml文件创建， 文件可以为yml或者json: <code>kubectl apply -f ${fiileName}</code></p>
</li>
</ol>
<p><strong>删除Pods</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line">  # Delete a pod using the type and name specified in pod.json.</span><br><span class="line">  kubectl delete -f ./pod.json</span><br><span class="line">  </span><br><span class="line">  # Delete resources from a directory containing kustomization.yaml - e.g. dir/kustomization.yaml.</span><br><span class="line">  kubectl delete -k dir</span><br><span class="line">  </span><br><span class="line">  # Delete a pod based on the type and name in the JSON passed into stdin.</span><br><span class="line">  cat pod.json | kubectl delete -f -</span><br><span class="line">  </span><br><span class="line">  # Delete pods and services with same names &quot;baz&quot; and &quot;foo&quot;</span><br><span class="line">  kubectl delete pod,service baz foo</span><br><span class="line">  </span><br><span class="line">  # Delete pods and services with label name=myLabel.</span><br><span class="line">  kubectl delete pods,services -l name=myLabel</span><br><span class="line">  </span><br><span class="line">  # Delete a pod with minimal delay</span><br><span class="line">  kubectl delete pod foo --now</span><br><span class="line">  </span><br><span class="line">  # Force delete a pod on a dead node</span><br><span class="line">  kubectl delete pod foo --grace-period=0 --force</span><br><span class="line">  </span><br><span class="line">  # Delete all pods</span><br><span class="line">  kubectl delete pods --all</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --all=false: Delete all resources, including uninitialized ones, in the namespace of the specified resource types.</span><br><span class="line">  -A, --all-namespaces=false: If present, list the requested object(s) across all namespaces. Namespace in current context is ignored even if specified with --namespace.</span><br><span class="line">      --cascade=true: If true, cascade the deletion of the resources managed by this resource (e.g. Pods created by a ReplicationController).  Default true.</span><br><span class="line">      --field-selector=&apos;&apos;: Selector (field query) to filter on, supports &apos;=&apos;, &apos;==&apos;, and &apos;!=&apos;.(e.g. --field-selector key1=value1,key2=value2). The server only supports a limited number of field queries per type.</span><br><span class="line">  -f, --filename=[]: containing the resource to delete.</span><br><span class="line">      --force=false: Only used when grace-period=0. If true, immediately remove resources from API and bypass graceful deletion. Note that immediate deletion of some resources may result in inconsistency or data loss and requires confirmation.</span><br><span class="line">      --grace-period=-1: Period of time in seconds given to the resource to terminate gracefully. Ignored if negative. Set to 1 for immediate shutdown. Can only be set to 0 when --force is true (force deletion).</span><br><span class="line">      --ignore-not-found=false: Treat &quot;resource not found&quot; as a successful delete. Defaults to &quot;true&quot; when --all is specified.</span><br><span class="line">  -k, --kustomize=&apos;&apos;: Process a kustomization directory. This flag can&apos;t be used together with -f or -R.</span><br><span class="line">      --now=false: If true, resources are signaled for immediate shutdown (same as --grace-period=1).</span><br><span class="line">  -o, --output=&apos;&apos;: Output mode. Use &quot;-o name&quot; for shorter output (resource/name).</span><br><span class="line">  -R, --recursive=false: Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory.</span><br><span class="line">  -l, --selector=&apos;&apos;: Selector (label query) to filter on, not including uninitialized ones.</span><br><span class="line">      --timeout=0s: The length of time to wait before giving up on a delete, zero means determine a timeout from the size of the object</span><br><span class="line">      --wait=true: If true, wait for resources to be gone before returning. This waits for finalizers.</span><br></pre></td></tr></table></figure>
<p><strong>Pod API 对象的基本构成及书写格式</strong></p>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cpod_api.jpg" alt="pod_api"></p>
<p><strong>Pod各生命周期说明</strong></p>
<ul>
<li>Pending：挂起，Pod已被Kubernetes系统接受，但有一个或者多个容器镜像尚未创建。 等待时间包括Pod被调度的时间和通过网络下载镜像的时间</li>
<li>Running：运行中，该Pod已经绑定到了一个节点上，Pod中所有的容器都已被创建。至 少有一个容器正在运行，或者正处于启动或重启状态</li>
<li>Succeeded：Pod中的所有容器都被成功终止</li>
<li>Failed：失败，Pod中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也 就是说，容器以非0状态退出或者被系统终止</li>
<li>Unknown：因为某些原因无法取得Pod的状态，通常是因为与Pod所在主机通信失败</li>
<li>CrashLoopBackoff：Pod循环重启崩溃，通常是容器中的应用崩溃造成</li>
</ul>
<p><strong>pod配置</strong></p>
<ul>
<li>
<p>ImagePullPolicy</p>
<ul>
<li>Always：不管镜像是否存在都会进行一次拉取</li>
<li>Never：不管镜像是否存在都不会进行拉取</li>
<li>IfNotPresent：只有镜像不存在时，才会进行镜像拉取</li>
</ul>
</li>
<li>
<p>RestartPolicy</p>
<blockquote>
<p>在Pod中的容器可能会由于异常等原因导致其终止退出，Kubernetes提供了重 启策略以重启容器。重启策略对同一个Pod的所有容器起作用，容器的重启由 Node上的kubelet执行。</p>
</blockquote>
<ul>
<li>Always：只要退出就重启</li>
<li>OnFailure：失败退出（exit code不等于0）时重启</li>
<li>Never：只要退出就不再重启</li>
</ul>
<p>注意，这里的重启是指在Pod所在Node上面本地重启，并不会调度到其他Node上去。</p>
</li>
<li>
<p>resources</p>
<ul>
<li>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">tomcat:8.2.59</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"500Mi"</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">"500m"</span></span><br><span class="line"><span class="attr">      limits:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"1G"</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">"1"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>健康检查</p>
<blockquote>
<p>为了确保容器在部署后确实处在正常运行状态，Kubernetes提供了两种探针（Probe）探测状态：</p>
<ul>
<li><strong>LivenessProbe</strong>：探测应用是否处于健康状态，如果不健康则删除并重启容器</li>
<li><strong>ReadinessProbe</strong>：探测应用是否启动完成并且处于正常服务状态，如果不正常则不会接收来自Kubernetes Service的流量</li>
</ul>
</blockquote>
<p>Kubernetes支持三种方式来执行探针：</p>
<ul>
<li>
<p>exec：在容器中执行一个命令，如果命令退出码返回0则表示探测成功，否则表示失败</p>
</li>
<li>
<p>tcpSocket：对指定的容器IP及端口执行一个TCP检查，如果端口是开放的则表示探测成功，否则表示失败</p>
</li>
<li>
<p>httpGet：对指定的容器IP、端口及路径执行一个HTTP Get请求，如果返回的状态码在[200,400)之间则表示探 测成功，否则表示失败</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line"><span class="attr">  httpGet:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    httpHeaders:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">X-Custom-Header</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">Awesome</span></span><br><span class="line"><span class="attr">  initialDelaySeconds:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  periodSeconds:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Probe的精确配置:</p>
<ul>
<li>initialDelaySeconds：容器启动后第一次执行探测是需要等待多少秒</li>
<li>periodSeconds：执行探测的频率。默认是10秒，最小1秒</li>
<li>timeoutSeconds：探测超时时间。默认1秒，最小1秒</li>
<li>successThreshold：探测失败后，最少连续探测成功多少次才被认定为成功。默认是1 对于liveness必须是1，最小值是1</li>
<li>failureThreshold：探测成功后，最少连续探测失败多少次才被认定为失败。默认是3 最小值是1</li>
</ul>
</li>
</ul>
<p><strong>Label和Label Selector</strong></p>
<p>Label</p>
<ul>
<li>定义label： kubectl label ${sourceType} ${name} key=value</li>
<li>查看label： kubectl get ${type} --show-labels</li>
<li>删除label： kubectl label ${type} ${name} key-</li>
</ul>
<p>Labels Selector：</p>
<blockquote>
<p>通过标签选择器（Labels Selectors），进行查询和筛选拥有特定Label的资源对象</p>
</blockquote>
<p>目前支持两种选择器：equality-based（基于平等）和set-based（基于集合）的</p>
<ul>
<li>Equality-based：基于相等的或者不相等的条件允许用标签的keys和values进行过滤。匹配 的对象必须满足所有指定的标签约束，尽管他们可能也有额外的标签。有三种运算符是允 许的，“=”，“==”和“!=”。前两种代表相等性（他们是同义运算符），后一种代表 非相等性，多个可用逗号隔开如，非生产nginx：environment!=production,app=nginx</li>
<li>Set-based：用一组value来过滤key。支持三种操作符: In ，NotIn，Exists，DoesNotExists，  前两个value不能为空，后两个仅针对于key，没有value</li>
</ul>
<p><strong>labels，selector操作</strong></p>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Clabel.png" alt="label"></p>
<p><strong>Controller</strong></p>
<blockquote>
<p>controller manager 是各种controller的管理者,是集群内部的管理控制中心。</p>
<p>在K8S 拥有很多controller 他们的职责是保证集群中各种资源的状态和用户定义(yaml)的状态一致, 确保任何时候都在运行指定数量的Pod副本。 换句话说,Controller确保一个容器或一组相同的容器始终处于可用状态。</p>
</blockquote>
<ul>
<li>ReplicationController</li>
<li>ReplicaSet</li>
<li>Deployments</li>
<li>DaemonSet</li>
<li>StatefulSets</li>
</ul>
<h3 id="deployment"><a class="markdownIt-Anchor" href="#deployment"></a> <strong>Deployment</strong></h3>
<blockquote>
<p>Deployment面向的是部署无状态应用， statefulset  : 部署有状态应用</p>
</blockquote>
<p>Deployment的典型应用场景</p>
<ul>
<li>
<p><strong>定义Deployment来创建Pod和ReplicaSet</strong></p>
</li>
<li>
<p>滚动升级和回滚应用</p>
<ul>
<li>
<p>`•kubectl rollout undo deployment/nginx-deployment</p>
<p>•deployment “nginx-deployment” rolled back`</p>
</li>
</ul>
</li>
<li>
<p>扩容和缩容</p>
</li>
<li>
<p>暂停和继续</p>
</li>
</ul>
<p><strong>Kubernetes上有状态服务</strong></p>
<ul>
<li>Volume</li>
<li>Persistent Volume</li>
</ul>
<p>demo：创建包含3个nginx应用pod的deployment</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1 </span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">    name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">    replicas: 3</span><br><span class="line">    template:</span><br><span class="line">        metadata: </span><br><span class="line">            labels:</span><br><span class="line">                app: nginx</span><br><span class="line">        spec:</span><br><span class="line">            containers:</span><br><span class="line">            -  name: nginx</span><br><span class="line">                image:  nginx:1.7.9 </span><br><span class="line">                ports:</span><br><span class="line">                -  containerPort: 80</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>您可以决定运行 Pod，但当它们死去时，它们就会死去。</p>
</li>
<li>
<p>部署将使您的 pod 能够连续运行。</p>
</li>
<li>
<p>部署允许您在不停机的情况下更新正在运行的应用程序。</p>
</li>
<li>
<p>部署还指定了在 Pod 死亡时重启 Pod 的策略</p>
</li>
<li>
<h3 id="replicasets"><a class="markdownIt-Anchor" href="#replicasets"></a> replicaSets</h3>
<ul>
<li>Deployment 还可以创建 ReplicaSet</li>
<li>ReplicaSet 可确保您的应用拥有所需数量的 Pod</li>
<li>ReplicaSets 将基于 Deployment 创建和扩展 Pods</li>
<li>Deployments、ReplicaSets、Pods 不是独占的，但可以是</li>
</ul>
</li>
</ul>
<h3 id="deamonsets"><a class="markdownIt-Anchor" href="#deamonsets"></a> deamonSets</h3>
<ul>
<li>DaemonSets 用于连续进程</li>
<li>他们每个节点运行一个 Pod。</li>
<li>每个添加到集群的新节点都会启动一个 pod</li>
<li>用于监控和日志收集等后台任务</li>
</ul>
<h3 id="statefulsets"><a class="markdownIt-Anchor" href="#statefulsets"></a> StatefulSets</h3>
<ul>
<li>
<p>您的应用程序是否要求您保留有关其状态的信息？</p>
</li>
<li>
<p>数据库需要状态</p>
</li>
<li>
<p>StatefulSet 的 Pod 不可互换。</p>
</li>
<li>
<p>每个 Pod 都有一个唯一的、持久的标识符，控制器在任何重新调度时都会维护该标识符。</p>
</li>
<li></li>
</ul>
<h3 id="service详解"><a class="markdownIt-Anchor" href="#service详解"></a> <strong>Service详解：</strong></h3>
<ul>
<li>
<p>Kubernetes中最核心的资源对象之一，Pod、RC等其实都是Service</p>
</li>
<li>
<p>Service是对<strong>一组提供相同功能</strong>的<strong>Pods的抽象</strong>，并为它们提供一个统一的入口，简单来说，可以把service理解为一个负载均衡器。借助Service，应用可以方便的实现 <u>服务发现与负载均衡</u>，并实现应用的稳定升级。Service通过<strong>标签</strong>来选取服务后端，一般配合Replication  Controller或者Deployment来保证后端容器的正常运行。这些<u>匹配标签的Pod IP和端口列表</u>组成<strong>endpoints</strong>，由 kube-proxy负责将服务IP负载均衡到这些endpoints上。</p>
</li>
<li>
<p>它定义了一组Pod的逻辑集合和一个用于访问它们的策略，其实这个概念和微服务非常类似。一个Serivce下面包含的Pod集合一般是由Label Selector来决定的。</p>
</li>
<li>
<p>Service默认有自己的ip和端口的叫<strong>cluster-ip</strong>和<strong>port</strong>构成了endpoint，内部可以直接通过这个endpoint去访问应用。</p>
<ul>
<li>不过有一点需要注意，这个cluster-ip是个Virtual IP，它是ping不通的，底层转发是通过node节点上的kube-proxy调用iptables生成对应的转发规则。
<ul>
<li>ClusterIP：默认类型，自动分配一个仅cluster内部可以访问的虚拟IP</li>
<li>NodePort：在ClusterIP基础上为Service在每台机器上绑定一个端口，这样就可以通过<code>&lt;NodeIP&gt;:NodePort</code>来 访问该服务</li>
<li>LoadBalancer：在NodePort的基础上，借助cloud provider创建一个外部的负载均衡器，并将请求转发到</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Service有四种类型：</p>
<ul>
<li>ClusterIP</li>
<li>NodePort</li>
<li>LoadBalancer</li>
<li>ExternalName</li>
</ul>
</li>
<li>
<p><strong>Service定义</strong></p>
<ul>
<li>
<p>Service的定义也是通过yaml或json，比 如下面定义了一个名为nginx的服务， 将 服 务 的 80 端 口 转 发 到 default namespace中带有标签run=nginx的Pod 的80端口</p>
</li>
<li>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">nginx</span>  </span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span>			<span class="comment"># k8s 集群内部访问service端口， 通过cluster_ip:port 请求某个service</span></span><br><span class="line"><span class="attr">     protocol:</span> <span class="string">TCP</span>  </span><br><span class="line"><span class="attr">     targetPort:</span> <span class="number">80</span>  </span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">nginx</span>  </span><br><span class="line"><span class="attr">    sessionAffinity:</span> <span class="string">None</span>  </span><br><span class="line"><span class="attr">    type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>Q: 如何访问服务?</strong></p>
<blockquote>
<p>每个Pod都提供独立的EndPoint（Pod IP + Container Port），访问请求如何映射到具体的Pod？</p>
</blockquote>
<p>A: 开启负载均衡器kube-proxy，客户端通过负载均衡器调度到相应的pod，每个Service分配一个全局唯一的虚拟IP地址（Cluster IP），Pod的Endpoint地址会随着pod的销毁和创新创建而改变，但是cluster ip在Service生命周期内不会改变，因此用servcie name和cluster ip作为DNS域名，就可以解决服务访问问题</p>
<p><strong>外部系统访问Service:</strong></p>
<ul>
<li>Node IP： 节点IP地址，<u>真实网络网卡的IP</u></li>
<li>Pod IP：Pod的IP地址，<u>根据docker0网桥的IP段进行分配</u>，虚拟二层网络，实现Pod之间的通信</li>
<li>Cluster IP: Service IP地址
<ul>
<li>仅服务Kubernetes Service对象</li>
<li>没有对应的实体网络，无法直接ping通</li>
<li>只能结合Service Port组成具体通信端口，集群之外无法访问</li>
<li>集群内可以使用内部路由规则进行通信，如何在外部访问？NodePort</li>
</ul>
</li>
</ul>
<p><strong>IP和Port</strong></p>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cip_port.jpg" alt="ip_port"></p>
<p>见： <a href="https://zhuanlan.zhihu.com/p/358916098" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/358916098</a></p>
<p><strong>各port之间的区别</strong>：</p>
<ul>
<li>port：k8s集群内部服务之间访问service的入口（ClusterIP:Port）</li>
<li>targetPort：容器应用运行端口（最终的流量端口），如nginx是80、mysql是3306</li>
<li>nodePort：外部流量访问k8s集群中service入口的一种方式(NodeIP:NodePort)</li>
</ul>
<h3 id="如何将服务暴露给外部客户端"><a class="markdownIt-Anchor" href="#如何将服务暴露给外部客户端"></a> <strong>如何将服务暴露给外部客户端？</strong></h3>
<ul>
<li>
<p>将服务的类型设置成NodePort</p>
<ul>
<li>
<p>每个集群节点都会在节点上打开一个端口，对于NodePort服务，每个集群节点在节点本身上打开一个端口，并将在该端口上接收到的流量重定向到基础服务。所以该服务仅在内部集群IP 和端口上才可访问</p>
</li>
<li>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span>      		<span class="comment">#为NodePort设置服务类型</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span>               <span class="comment"># k8s 集群内部访问service端口[服务集群IP (service cluster IP)的端口号]， 通过clusterip:port 请求某个service</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">8080</span>  	<span class="comment"># 背后Pod的目标端口号</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30123</span>  		<span class="comment"># 通过集群节点的30123端口可以访问该服务</span></span><br><span class="line"><span class="attr">   selector:</span> </span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
<p>保存好yaml文件可用通过以下命令创建并且查看目标服务, <code>$ kubectl apply –f service.yaml</code>, <code>$ kubectl get svc my-service</code></p>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Csvc_nodeport.png" alt="svc_nodeport"></p>
<p>PORT(S)列显示集群IP (80) 的内部端口和节点端口(30123)</p>
<p>可以通过以下地址访问该服务：10.11.254.223:80</p>
</li>
<li>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cexpose_NodePort.png" alt="expose_NodePort"></p>
<ul>
<li>服务暴露在两个集群节点的端口30123上，它到达任何一个端口的传入连接将都被重定向到一个随机选择的pod, 该pod是否位于接收到连接的节点上是不确定的。</li>
<li>在第一个节点的端口30123收到的连接， 可以被重定向到第一节点个上运行的 pod, 也可能是第二个节点上运行的pod</li>
<li>所以在通过节点端口访间服务之前， 有时需要配置防火墙， 来允许外部连接到该端口上的节点。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>将服务的类型设置成LoadBalance（负载均衡器）</p>
<ul>
<li>
<p>负载均衡器拥有自己独一无二的可公开访问的 IP 地址， 并将所有连接重定向到服务。用户可以通过负载均衡器的 IP 地址访问服务。</p>
</li>
<li>
<p>如果Kubernetes在不支持Load Balancer服务的环境中运行， 则不会调配负载平衡器， 但该服务仍将表现得像一个NodePort服务。 这是因为Load Balancer服务是NodePort服务的扩展。</p>
</li>
<li>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">loadbalancer-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">LoadBalancer</span>        <span class="comment"># 为LoadBalance设置服务类型</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span>              <span class="comment"># 服务集群IP的端口号</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">8080</span>  	<span class="comment"># 背后Pod的目标端口号</span></span><br><span class="line"><span class="attr">   selector:</span> </span><br><span class="line"><span class="attr">      app:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Csvc_LoadBalancer.png" alt="svc_LoadBalancer"></p>
<p>PORT(S)列显示集群IP (80) 的内部端口和节点端口(31698)</p>
<p>可以通过以下地址访问该服务：10.99.34.164:80</p>
</li>
</ul>
</li>
<li>
<p>创建一个Ingress资源</p>
<ul>
<li>
<p>为什么需要 Ingress ？</p>
</li>
<li>
<p>一个重要的原因是每个 LoadBalancer 服务都需要自己的负载均衡器， 以及独有的公有IP 地址，而 Ingress 只需要一个公网 IP 就能为许多服务提供访问。 当客户端向 Ingress 发送 HTTP请求时，Ingress 会根据<strong>请求的主机名和路径</strong>决定请求转发到的服务。</p>
</li>
<li>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Csvc_ingress%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" alt="svc_ingress工作原理"></p>
</li>
<li>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单规则的 Ingress</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">test-ingress</span>  </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  backend:</span>     		   <span class="comment"># </span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">test</span>    <span class="comment"># 将所有的请求发送到test服务的80端口</span></span><br><span class="line"><span class="attr">  servicePort:</span> <span class="number">80</span>      <span class="comment"># </span></span><br><span class="line"><span class="comment"># 根据不同路径转发到不同服务器</span></span><br><span class="line"><span class="string">…</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">website.com</span> </span><br><span class="line"><span class="attr">     http:</span></span><br><span class="line"><span class="attr">        paths:</span> </span><br><span class="line"><span class="attr">        - path:</span> <span class="string">/web</span></span><br><span class="line"><span class="attr">           backend:</span></span><br><span class="line"><span class="attr">             serviceName:</span> <span class="string">s1</span>   </span><br><span class="line"><span class="attr">             servicePort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">       - path:</span> <span class="string">/api</span></span><br><span class="line"><span class="attr">           backend:</span></span><br><span class="line"><span class="attr">             serviceName:</span> <span class="string">s2</span></span><br><span class="line"><span class="attr">       servicePort:</span> <span class="number">8081</span></span><br><span class="line"><span class="comment"># 根据不同的主机（host) 暴露出多种服务</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">foo.bar.com</span> </span><br><span class="line"><span class="attr">     http:</span></span><br><span class="line"><span class="attr">        paths:</span> </span><br><span class="line"><span class="attr">        - backend:</span></span><br><span class="line"><span class="attr">           serviceName:</span> <span class="string">s1</span>   </span><br><span class="line"><span class="attr">           servicePort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">bar.foo.com</span> </span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">       paths:</span> </span><br><span class="line"><span class="attr">       - backend:</span>  </span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">s2</span></span><br><span class="line"><span class="attr">    servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>service与deployment区别</strong></p>
<ul>
<li>pod： pod 是 kubernetes 中最小的编排单位，通常由一个容器组成 (有时候会有多个容器组成)</li>
<li>service： 一个网络下的pod集合。service 使用labels标签来<strong>选择</strong>代理的pod。</li>
<li>Deployment：为了在 k8s 中编排应用可以更好地做弹性扩容，负载均衡，deployment 作用于一组pods的创建和运行</li>
</ul>
<p>▲所以service 和deployment的区别，就是一个是从<strong>网络角度</strong>的<strong>抽象概念</strong>service，类型nginx做负载均衡提供的统一网络入口。而pod是<strong>最终的应用部署实体</strong>。 deoplyment <strong>负责创建和保持</strong>pod运行状态</p>
<p>service 可以独立于deployment工作，但是需要一个个去创建pod，而不是像deployment那样一次性创建。deployment也可以独立于service工作。虽然service和deployment是有区别的，但不影响他们一同协同工作</p>
<p><strong>ConfigMap</strong></p>
<ul>
<li>ConfigMap用于保存配置数据的键值对，可以用来保存单个属性，也可以用来保存配置文件。</li>
<li>可以使用kubectl create configmap从文件、目录或者key-value字符串创建等创建 ConfigMap。也可以通过<code>kubectl create -f file</code>创建。</li>
</ul>
<p><strong>HPA(Horizontal Pod Autoscaler)</strong></p>
<ul>
<li>Kubernetes资源对象，支持Pod横向自动扩容</li>
<li>Pod负载度量指标：
<ul>
<li>CPU utilizaiton — Pod CPU利用率均值</li>
<li>TPS or Qps</li>
</ul>
</li>
</ul>
<p><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5CHPA.png" alt="HPA"></p>
<h3 id="容器化改造过程"><a class="markdownIt-Anchor" href="#容器化改造过程"></a> 容器化改造过程</h3>
<p>第一步：<strong>简单容器化，应用无改造</strong>—&gt;<strong>效果：自动化应用上线、升级、版本回滚、监控、报警</strong></p>
<p>第二步：<strong>应用去状态</strong>—&gt; <strong>效果：自动化故障恢复、高可用</strong></p>
<p>第三步：<strong>微服务，可重用</strong></p>
<p>传统单体架构缺点：</p>
<ul>
<li>加载、编译耗时长</li>
<li>代码管理复杂</li>
<li>横向扩展难</li>
<li>各模块之间耦合度高</li>
<li>模块问题排查困难</li>
</ul>
<p>微服务架构优点：</p>
<ul>
<li>允许不同语言编写，易于引入新技术</li>
<li>微服务商店模式，快速组合与重构</li>
<li>模块解耦，不同的SLA保障计划</li>
<li>更高的扩展性和可用性</li>
</ul>
<h3 id="kubernetes网络原理"><a class="markdownIt-Anchor" href="#kubernetes网络原理"></a> Kubernetes网络原理</h3>
<p>Kubernetes网络设计主要考虑了几种通信场景</p>
<ul>
<li>同一个Pod内容器间互通
<ul>
<li><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cnet%E5%90%8C%E4%B8%80%E4%B8%AAPod%E5%86%85%E5%AE%B9%E5%99%A8%E9%97%B4%E4%BA%92%E9%80%9A.png" alt="net同一个Pod内容器间互通"></li>
</ul>
</li>
<li>同一个Node上Pod间互通
<ul>
<li>Pod1与Pod2都是通过虚拟网络设备Veth，  连接到同一个docker0 bridge的，这两个 Pod的IP地址也是通过docker0网段动态分配 的，与docker0 bridge属于同一个网段。</li>
<li>Pod的默认路由都是docker0 bridge的地址，  所有非本地地址的网络数据，默认都会发送 到docker0网桥上，由docker0网桥中转</li>
<li>Pod与docker0之间是Veth设备对连接的，而 docker0 bridge与Node的eth0是路由转发的，  Docker0上默认网关就是Node的eth0</li>
<li><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cnet%E5%90%8C%E4%B8%80%E4%B8%AANode%E4%B8%8APod%E9%97%B4%E4%BA%92%E9%80%9A.png" alt="net同一个Node上Pod间互通"></li>
</ul>
</li>
<li>不同Node上Pod间的互通
<ul>
<li><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5Cnet%E4%B8%8D%E5%90%8CNode%E4%B8%8APod%E9%97%B4%E7%9A%84%E4%BA%92%E9%80%9A%E3%80%90Overlay%E6%96%B9%E6%A1%88%E3%80%91.png" alt="net不同Node上Pod间的互通【Overlay方案】"></li>
</ul>
</li>
<li>Service与Pod之间的通信
<ul>
<li><strong>实现方式为kube-proxy</strong>: 以暴露NodePort的Service为例，NodePort的工作原理与ClusterIP大致相同，发送到某个 NodeIP:NodePort的请求，通过iptables重定向到kube-proxy对应的端口(Node上的随机端口)上，然 后由kube-proxy再将请求发送到其中的一个Pod:TargetPort</li>
<li>三种proxyMode：
<ul>
<li>Userspace Mode：v1.0及之前版本的默认模式</li>
<li>Iptables Mode：v1.1开始增加支持，v1.2正式成为默认模式</li>
<li>IPVS Mode：v1.8开始增加支持，v1.11正式成为默认模式</li>
</ul>
</li>
</ul>
</li>
<li>K8s集群内外组件间通信
<ul>
<li><img src="/2021/09/25/ZJU云原生技术及应用-课程笔记/E:%5Chexo%5Csource_posts%5CZJU%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%5CnetK8s%E9%9B%86%E7%BE%A4%E5%86%85%E5%A4%96%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1.png" alt="netK8s集群内外组件间通信"></li>
</ul>
</li>
</ul>
<h3 id="调用k8s服务的过程"><a class="markdownIt-Anchor" href="#调用k8s服务的过程"></a> 调用K8S服务的过程</h3>
<p>当外部client访问服务器时，首先访问服务器一致对外提供的接口，通过这一接口再将请求<strong>workload</strong>到每台主机上（每台主机上都有相对应的NodePort端口即notePort的Service来接受这一请求），每个service服务上都有一个对应的ClusterIP,通过ClusterIP和每台主机上的IPTables表以及label筛选，service就可以将请求workload到具体的每个pod上（endpoint）。</p>
<p><img src="https://img-blog.csdn.net/2018080517460013?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODI4MTQ1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录：</h1>
<h2 id="vscode环境配置"><a class="markdownIt-Anchor" href="#vscode环境配置"></a> Vscode环境配置</h2>
<ul>
<li>docker插件下载：</li>
<li>k8s插件下载:
<ul>
<li><a href="https://www.cnblogs.com/xuelong3/p/12873022.html" target="_blank" rel="noopener">icepanel</a></li>
<li><a href="https://blog.csdn.net/shenhonglei1234/article/details/95471305" target="_blank" rel="noopener">Kubernetes Tools</a></li>
</ul>
</li>
</ul>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2021/09/25/ZJU云原生技术及应用-课程笔记/">https://nymrli.top/2021/09/25/ZJU云原生技术及应用-课程笔记/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2021/09/26/学点Gradle/" title="学点Gradle"><span>< PreviousPost</span><br><span class="prevTitle">学点Gradle</span></a><a class="nextSlogan" href="/2021/09/21/docker部署springboot项目/" title="docker部署springboot项目"><span>NextPost ></span><br><span class="nextTitle">docker部署springboot项目</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: 'ZJU云原生技术及应用-课程笔记',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><span>备案号:苏ICP备18015439号</span></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#zju要求"><span class="toc-number">1.</span> <span class="toc-text"> ZJU要求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#课程内容"><span class="toc-number">1.1.</span> <span class="toc-text"> 课程内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#考核方式"><span class="toc-number">1.2.</span> <span class="toc-text"> 考核方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#云原生"><span class="toc-number">2.</span> <span class="toc-text"> 云原生</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker技术原理与实践"><span class="toc-number">2.1.</span> <span class="toc-text"> Docker技术原理与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker本质就是进程"><span class="toc-number">2.1.1.</span> <span class="toc-text"> docker本质就是进程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#云计算技术基本原理"><span class="toc-number">2.2.</span> <span class="toc-text"> 云计算技术基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kubernetes核心原理与关键组件"><span class="toc-number">2.3.</span> <span class="toc-text"> Kubernetes核心原理与关键组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cloud-foundry云平台"><span class="toc-number">2.3.1.</span> <span class="toc-text"> Cloud Foundry云平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k8s命令"><span class="toc-number">2.3.2.</span> <span class="toc-text"> K8s命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k8s架构"><span class="toc-number">2.3.3.</span> <span class="toc-text"> K8s架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deployment"><span class="toc-number">2.3.4.</span> <span class="toc-text"> Deployment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replicasets"><span class="toc-number">2.3.5.</span> <span class="toc-text"> replicaSets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deamonsets"><span class="toc-number">2.3.6.</span> <span class="toc-text"> deamonSets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#statefulsets"><span class="toc-number">2.3.7.</span> <span class="toc-text"> StatefulSets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#service详解"><span class="toc-number">2.3.8.</span> <span class="toc-text"> Service详解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何将服务暴露给外部客户端"><span class="toc-number">2.3.9.</span> <span class="toc-text"> 如何将服务暴露给外部客户端？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器化改造过程"><span class="toc-number">2.3.10.</span> <span class="toc-text"> 容器化改造过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kubernetes网络原理"><span class="toc-number">2.3.11.</span> <span class="toc-text"> Kubernetes网络原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用k8s服务的过程"><span class="toc-number">2.3.12.</span> <span class="toc-text"> 调用K8S服务的过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附录"><span class="toc-number">3.</span> <span class="toc-text"> 附录：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vscode环境配置"><span class="toc-number">3.1.</span> <span class="toc-text"> Vscode环境配置</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>