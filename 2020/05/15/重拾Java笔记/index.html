<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>重拾Java笔记 · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">重拾Java笔记</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2021/12/01</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="java"> java</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">19,583</span> | Reading time: <span class="post-count">80</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="重拾java笔记"><a class="markdownIt-Anchor" href="#重拾java笔记"></a> 重拾Java笔记</h1>
<blockquote>
<p>工作主要用Java, 因此开始准备Java基础再补补。根据<a href="http://www.monkey1024.com/javaseroute" target="_blank" rel="noopener">小猴子1024-JAVA基础</a>整理笔记</p>
</blockquote>
<h2 id="命名规范"><a class="markdownIt-Anchor" href="#命名规范"></a> <a href="https://www.jianshu.com/p/511cc270400f" target="_blank" rel="noopener">命名规范:</a></h2>
<blockquote>
<p>没怎么写， 所以一直忘， 这次写在最前面， 便于翻阅。</p>
</blockquote>
<p>大驼峰命名（UpperCamelCase）：<strong>每个单词的第一个字母大写</strong>，其他字母小写。e.g.MyException</p>
<p>小驼峰命名（lowerCamelCase）：如果仅有一个单词，那么所有字母全部小写，如果是两个及以上的单词组成的名称，那么除了第一个单词是全部小写外，其他都是的首字母大写，其他字母小写。e.g.getMyName</p>
<hr>
<p>1.1 包的命名</p>
<p>包的命名由全部小写的单词组成。一般使用公司的域名的作为自己程序包的唯一前缀，使用倒域名规则，例如：com.baidu.项目名，然后针对每个具体的模块在区分每个模块包名，例如：论坛模块的整体包名：<code>com.baidu.项目名.tribune</code>(域名倒写)</p>
<p>1.2 类的命名</p>
<p>类的命名遵循大驼峰命名的规则</p>
<p>1.3 接口的命名</p>
<p>接口命名遵循大驼峰命名的规则，以大写的I开头，表示这是一个接口，以able或ible截尾。</p>
<p>1.4 变量命名</p>
<p>变量的命名遵循小驼峰命名的规则，其中控件的变量建议使用控件缩写+逻辑名称的格式，例如：</p>
<p>1.5 常量的命名</p>
<p>常量名称的每个单词都大写，并且每个单词之间通过下划线（_）连接，例如：</p>
<p>1.6 方法的命名</p>
<p>方法的命名遵循小驼峰命名的规则，以动词+名词的方式组成，例如初始化view：initView()。</p>
<p>1.7 资源文件命名</p>
<p>全部小写，并通过下划线连接。</p>
<hr>
<h2 id="class与文件名"><a class="markdownIt-Anchor" href="#class与文件名"></a> class与文件名:</h2>
<blockquote>
<p>在一个Java文件里面，可以声明多个class，但是只能声明一个public class</p>
</blockquote>
<ul>
<li>如果使用class来声明类，文件名可以是任何合法的文件名称，文件名不需要和Class类一致</li>
<li>如果采用public class来声明class，那么文件名必须和类名一致</li>
</ul>
<p>结论: 使用javac命令所编译出的<strong>class文件</strong>的名称<strong>跟java的文件名没有关系</strong>，而是<strong>跟类名一致</strong>。</p>
<h2 id="函数传参"><a class="markdownIt-Anchor" href="#函数传参"></a> 函数传参:</h2>
<ul>
<li>如果参数是基本数据类型, 是会生成一个新的形参</li>
<li>如果参数是引用数据类型(不包括封装数据类型), 那么会生成该对象的引用（类、 接口类型、 <u>数组类型</u>、 枚举类型、 注解类型、 字符串型）==&gt;引用数据类型变量，调用方法时作为参数是按<strong>引用传递</strong>的</li>
</ul>
<p>参看: <a href="https://www.cnblogs.com/maskwolf/p/9972982.html" target="_blank" rel="noopener">Java中的基本数据类型和引用数据类型的区别</a></p>
<h2 id="代码块的分类"><a class="markdownIt-Anchor" href="#代码块的分类"></a> 代码块的分类</h2>
<p>使用{}括起来的代码被称为代码块，根据其位置和声明的不同可以分为下面4种：</p>
<ul>
<li><strong>局部代码块</strong>，在方法中出现，限定变量生命周期，及早释放，提高内存利用率</li>
<li><strong>构造代码块</strong>，在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</li>
<li><strong>静态代码块</strong>， 在类中方法外出现，并加上static修饰；用于给<strong>类进行初始化，在加载的时候就执行</strong>，并且只执行一次。一般用于加载驱动。</li>
<li><strong>同步代码块</strong>(后面多线程部分会讲解)</li>
</ul>
<h3 id="执行顺序"><a class="markdownIt-Anchor" href="#执行顺序"></a> 执行顺序:</h3>
<p>1.<strong>静态代码块</strong>，随着类加载而加载,且只执行一次<br>
2.<strong>构造代码块</strong>，每创建一个对象就会执行一次，优先于构造方法执行<br>
3.<strong>构造方法</strong>，每创建一个对象就会执行一次</p>
<h2 id="this指针"><a class="markdownIt-Anchor" href="#this指针"></a> this指针</h2>
<p>▲注意点: 在构造函数中调用该对象的另一个构造方法时,  this(实参)必须写在最前面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//构造方法</span><br><span class="line">//需求：在创建日期对象的时候，默认的日期是:1970-1-1</span><br><span class="line">MyDate()&#123;</span><br><span class="line">    //通过this调用有参的构造方法</span><br><span class="line">    this(1970,1,1);//必须出现在第一行，否则将编译报错</span><br><span class="line">    //构造方法不能这样调用</span><br><span class="line">    //MyDate(1970,1,1);Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承问题"><a class="markdownIt-Anchor" href="#继承问题"></a> 继承问题：</h2>
<p>静态代码块Fu<br>
静态代码块Zi<br>
构造代码块Fu<br>
构造方法Fu<br>
构造代码块Zi<br>
构造方法Zi</p>
<p>分析：<br>
1.系统将Fu.class和Zi.class分别加载到方法区的内存里面，<strong>静态代码</strong>会随着.class文件一块<strong>加载到方法区</strong>里面，所以先打印出了静态代码块中的内容。<br>
2.<strong>构造代码块优先于构造方法执行</strong>，父类初始化之前，所以打印出父类中的构造代码块和构造方法中的内容。</p>
<h2 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态：</h2>
<blockquote>
<p>在工作当中尽量面向抽象编程，不要面向具体编程，即合理利用多态——<strong>SOLID原则</strong>中依赖倒置：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。换言之，要针对接口编程，而不是针对实现编程。</p>
</blockquote>
<p><strong>多态的优点</strong></p>
<ul>
<li>提高程序的扩展性</li>
<li>降低代码之间的耦合</li>
</ul>
<p><strong>用法</strong></p>
<ul>
<li>向上转型：上面代码中子类向父类型进行转换，是<strong>自动类型转换</strong>。</li>
<li>向下转型： 父类向子类型转换，是<strong>强制类型转换</strong>。</li>
</ul>
<h2 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h2>
<p>重写，也叫做覆盖，当父类中的方法无法满足子类需求时，子类可以将父类的方法进行重写编写来满足需求。比如孩子继承了父亲的房子，可以将房子重新装修。<br>
方法重写的条件：</p>
<ul>
<li>两个类必须是继承关系</li>
<li>必须具有相同的方法名，相同的返回值类型，相同的参数列表.</li>
<li>重写的方法不能比被重写的方法拥有更低的访问权限。</li>
<li>重写的方法不能比被重写的方法抛出更宽泛的异常。(关于异常后面的章节再讲。)</li>
<li>私有的方法不能被重写。</li>
<li>构造方法无法被重写，因为构造方法无法被继承。</li>
<li>静态的方法不存在重写。</li>
<li>重写指的是成员方法，和成员变量无关。</li>
</ul>
<h2 id="super关键字"><a class="markdownIt-Anchor" href="#super关键字"></a> Super关键字:</h2>
<p>什么时候使用super？</p>
<ul>
<li>子类和父类中都有某个数据，例如，子类和父类中都有name这个属性。如果要再子类中访问父类中的name属性，需要使用super。例1</li>
<li>子类重写了父类的某个方法（假设这个方法名叫m1），如果在子类中需要调用父类中的m1方法时，需要使用super。例1</li>
<li>子类调用父类中的构造方法时，需要使用super。</li>
</ul>
<h2 id="object类之finalize方法"><a class="markdownIt-Anchor" href="#object类之finalize方法"></a> Object类之finalize方法</h2>
<blockquote>
<p>java对象如果没有更多的引用指向它（引用技术），则该java对象成为垃圾数据，等待垃圾回收器的回收，垃圾回收器在回收这个java对象之前会自动调用该对象的finalize方法==&gt;可以理解为解析函数</p>
</blockquote>
<h2 id="访问控制权限"><a class="markdownIt-Anchor" href="#访问控制权限"></a> 访问控制权限</h2>
<p><strong>方法访问控制权限</strong></p>
<table>
<thead>
<tr>
<th><strong>修饰词</strong></th>
<th><strong>本类</strong></th>
<th><strong>同一个包的类</strong></th>
<th><strong>子类</strong></th>
<th><strong>任何地方</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>default（默认）</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p><strong>方法访问控制权限</strong></p>
<p>▲。注意以上对类的修饰只有：public和default，内部类除外(只有内部类可以设置为protected/private)</p>
<p>priavte和public都比较好理解和记忆，这里就不演示了，主要演示一下不同包下的两个具有父子关系的类里面使用protected和default的区别。</p>
<h3 id="构造函数的权限问题"><a class="markdownIt-Anchor" href="#构造函数的权限问题"></a> 构造函数的权限问题:</h3>
<p>public是一个<a href="https://www.baidu.com/s?wd=%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">访问权限</a>（访问修复饰符）。一般<a href="https://www.baidu.com/s?wd=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">构造函数</a>可加可不加public。</p>
<ul>
<li>如果加上制public,就代表此类可以对外开放,其他的类可以继承它,外部也可以实例化该对象。</li>
<li>如果不加public,则默认的修饰词是default,表示可以被这个类的子类或者和这个类同包的类调用。</li>
</ul>
<p>除了这两个,你还可以添加private和default</p>
<p><strong>记录一下默认修饰符</strong>：</p>
<ul>
<li>类（class）: ****缺省****就是没有修饰符，在同一个包中的类中可见，在其他包中不能用import导入。</li>
<li>变量（variable）: <strong>缺省</strong>在同一个包中可见，子类不在一个包中，子类中也不可见</li>
<li>方法(method)：<strong>缺省</strong>在同一个包中可见，子类不在一个包中，子类中也不可见</li>
<li>接口（interface）： <strong>缺省</strong>同一个包中可见
<ul>
<li>Java的interface中，成员变量的默认修饰符为：public static final；方法的默认修饰符，方法的默认修饰符是：public abstract（接口中的方法只能使用<strong>public</strong>和<strong>abstract</strong>修饰符 ）==&gt; <strong>接口只是对一类事物属性和行为的更高次抽象；对修改关闭，对扩展开放，可以说是java中开闭原则的一种体现吧。</strong></li>
</ul>
</li>
</ul>
<h2 id="final关键字"><a class="markdownIt-Anchor" href="#final关键字"></a> <strong>Final关键字:</strong></h2>
<blockquote>
<p>特点为确定不可变</p>
</blockquote>
<ul>
<li>final修饰的类无法被继承。</li>
<li>final修饰的方法无法被重写。</li>
<li>final修饰的局部变量，一旦赋值，不可再改变。</li>
<li>final修饰的成员变量必须初始化值。</li>
</ul>
<h2 id="static关键字"><a class="markdownIt-Anchor" href="#static关键字"></a> static关键字</h2>
<h3 id="static的作用"><a class="markdownIt-Anchor" href="#static的作用"></a> static的作用</h3>
<ul>
<li>static可以修饰变量，被static修饰的变量叫做静态变量，<u>静态变量在类加载阶段赋值，并且只赋值一次</u>。请看例1</li>
<li>static可以修饰方法，被static修饰的方法叫做静态方法，<strong>不用创建对象就能能直接访问该方法</strong>，即使用类名.静态方法名的方式。静态方法不能访问非静态的数据，静态方法不能使用this。请看例2</li>
<li>static可以定义静态语句块，<u>静态语句块在类加载阶段执行，并且只执行一次，并且是自上而下的顺序执行，在构造方法之前执行</u>。请看例3</li>
</ul>
<p>static修饰的变量、方法、代码块都是隶属于**类(class)**级别的,跟对象无关。某一类物体如果可以被多个其他物体所共享，那么可以将这类物体使用static修饰。<br>
比如wifi，多个人可以共同使用同一个wifi，所以wifi可以使用static修饰。手机是每人使用自己的，就不能用static修饰。</p>
<h2 id="抽象类的特点"><a class="markdownIt-Anchor" href="#抽象类的特点"></a> 抽象类的特点</h2>
<ul>
<li>抽象类无法被实例化，无法创建抽象类的对象。</li>
<li>虽然抽象类没有办法实例化，但是<strong>抽象类也有构造方法</strong>，该构造方法是给子类创建对象用的。这也算是多态的一种。</li>
<li>抽象类中不一定有抽象方法，但抽象方法必须出现在抽象类中。</li>
<li>抽象类中的子类可以是抽象类，如果不是抽象类的话必须对抽象类中的抽象方法进行重写。</li>
<li>抽象类和抽象方法不能被final修饰</li>
</ul>
<h2 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口：</h2>
<ul>
<li>接口中只能出现常量和抽象方法（jdk8之后可以有default方法）</li>
<li>接口里面<strong>没有构造方法</strong>，无法创建接口的对象</li>
<li>接口和接口之间支持多继承，即一个接口可以有多个父接口</li>
<li>一个类可以实现多个接口，即一个类可以有多个父接口</li>
<li>一个类如果实现了接口，那么这个类需要重写接口中所有的抽象方法（建议），如果不重写则这个类需要声明为抽象类（不建议）</li>
</ul>
<h2 id="equals"><a class="markdownIt-Anchor" href="#equals"></a> equals</h2>
<blockquote>
<p>== 两边如果是引用类型，则比较内存地址，地址相同则是true,反之则false.</p>
</blockquote>
<ul>
<li>Object中的equals方法比较的是两个引用的内存地址。</li>
<li>但是在现实的业务逻辑当中，不应该比较内存地址，<strong>应该比较地址里面的内容</strong>，所以需要对equals方法进行重写。</li>
</ul>
<p>==&gt;▲注意：在使用自己创建的类进行equals比较时，一定要先重写equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据需求规定重写equals方法</span></span><br><span class="line"><span class="comment">//s1.equals(s2);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Star)&#123;</span><br><span class="line">        Star s = (Star)obj;</span><br><span class="line">        <span class="keyword">if</span>(s.id == id &amp;&amp; s.name.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内部类的分类"><a class="markdownIt-Anchor" href="#内部类的分类"></a> 内部类的分类</h2>
<p>内部类，顾名思义就是在一个类的内部声明一个类。内部类主要分为：</p>
<ul>
<li>静态内部类</li>
<li>匿名内部类</li>
<li>成员内部类</li>
<li>局部内部类</li>
</ul>
<h2 id="异常的分类"><a class="markdownIt-Anchor" href="#异常的分类"></a> 异常的分类</h2>
<blockquote>
<p>异常: 指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止——JVM处理异常的方式是中断处理。</p>
</blockquote>
<p>异常主要分为：Error、一般性异常、RuntimeException</p>
<ul>
<li>Error(强制中断错误)：如果程序出现了Error，那么将无法恢复，只能重新启动程序，最典型的Error的异常是：OutOfMemoryError</li>
<li>Exception（一般性异常（<strong>编译时</strong>异常）：出现了这种异常必须在程序里面显示的处理，否则程序无法编译通过</li>
<li>RuntimeException（<strong>运行时</strong>异常）：此种异常可以不用显示的处理，例如被0除异常，java没有要求我们一定要处理。</li>
</ul>
<p><img src="http://www.monkey1024.com/wp-content/uploads/2017/04/1%E5%BC%82%E5%B8%B8%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="å¼å¸¸ç»§æ¿ç»æå¾"></p>
<h3 id="jvm是如何处理异常的"><a class="markdownIt-Anchor" href="#jvm是如何处理异常的"></a> JVM是如何处理异常的</h3>
<ul>
<li>main方法自己将该问题处理,然后继续运行</li>
<li>自己没有针对的处理方式,只有交给调用main的jvm来处理，jvm有一个默认的异常处理机制。例如上面出现的ArithmeticException，jvm在控制台里面打印出来了异常信息。</li>
</ul>
<p>大致流程: native method自己解决-&gt;交给Main解决-&gt;交给JVM解决</p>
<p>更好的讲解: <a href="https://www.bilibili.com/video/BV1A4411K7Gx?p=282" target="_blank" rel="noopener">B站视频</a></p>
<h3 id="throw和throws"><a class="markdownIt-Anchor" href="#throw和throws"></a> throw和throws</h3>
<p>throws</p>
<ul>
<li>用在方法声明后面，跟的是<strong>异常类名</strong>    <code>public void m1() throws Exception</code></li>
<li>可以跟多个异常类名，用逗号隔开</li>
<li>表示抛出异常，由<strong>该方法的调用者来处理</strong> (<strong>向上抛出指定异常</strong>)</li>
</ul>
<p>throw</p>
<ul>
<li>用在方法体内，跟的是<strong>异常对象名</strong>    ==&gt; <code>throw new Exception()</code></li>
<li>只能抛出一个异常对象名</li>
<li>表示抛出异常，由方法体内的语句处理，<strong>需要直接在此处解决异常</strong>(在当前语句抛出指定异常)</li>
</ul>
<h3 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h3>
<p>1.自定义异常类一般都是以Exception结尾，说明该类是一个异常类<br>
2.自定义异常类，必须的继承Exception或者RuntimeException<br>
- 继承Exception：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try…catch<br>
- 继承RuntimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个空参数的构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个带异常信息的构造方法</span></span><br><span class="line"><span class="comment">     * 查看源码发现，所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的构造方法，让父类来处理这个异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="catch"><a class="markdownIt-Anchor" href="#catch"></a> catch</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (ArithmeticException | ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="comment">// 出现多个异常,采取同样的处理措施</span></span><br><span class="line">            <span class="comment">// 多个异常见用 | 隔开</span></span><br><span class="line">            <span class="comment">// 多个异常必须是平级关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串的不可变性"><a class="markdownIt-Anchor" href="#字符串的不可变性"></a> 字符串的不可变性</h2>
<h3 id="string类不能被继承"><a class="markdownIt-Anchor" href="#string类不能被继承"></a> String类不能被继承</h3>
<p>通过源码可以看到String类前面加了final修饰，因此String类是不能够被继承的。将其设置为不能被继承的原因是为了减少歧义。</p>
<h3 id="字符串string的不可变性"><a class="markdownIt-Anchor" href="#字符串string的不可变性"></a> 字符串（String）的不可变性</h3>
<p>String创建好之后值是不可以被改变的，这里指的是<strong>在堆中的字符串的值</strong>是不可以被改变。</p>
<p>String不可变的主要原因是其底层使用了一个final修饰的byte数组(jdk9之后版本中)，final修饰的变量是不能被改变的。在jdk8版本中，String底层使用的是final修饰的char数组。这个版本之间的变化。</p>
<h3 id="string-stringbuffer-stringbuilder"><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder"></a> String、StringBuffer、StringBuilder</h3>
<ul>
<li>
<p>拼接执行效率: <code>String &lt; StringBuffer &lt; StringBuilder</code></p>
</li>
<li>
<p>线程安全:</p>
<table>
<thead>
<tr>
<th></th>
<th>线程安全</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>安全</td>
<td>常量无线程安全问题</td>
</tr>
<tr>
<td>stringBuffer</td>
<td>安全</td>
<td>方法全为syncronized关键字修饰</td>
</tr>
<tr>
<td>stringbuilder</td>
<td>不安全</td>
<td>无</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="字符串常量池"><a class="markdownIt-Anchor" href="#字符串常量池"></a> 字符串常量池</h3>
<p>我们声明的字符串会放到一个叫做字符串常量池的地方，这样可以减少内存的使用，字符串常量池是堆的一部分。</p>
<p>如果用<code>new String(&quot;monkey&quot;)</code>会在字符串常量池中再建一个monkey, 其实是浪费了内存。所以开发中建议使用String s = “monkey1024”;这种方式创建字符串对象，可以减少堆内存的使用。==&gt;<strong>比较两个字符串是否一致最好使用equals方法</strong>(看引用的内存地址是否一致)</p>
<p>详细请看: <a href="http://www.monkey1024.com/javase/481" target="_blank" rel="noopener">http://www.monkey1024.com/javase/481</a></p>
<p><img src="/2020/05/15/重拾Java笔记/JVM%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="JVM内存图"></p>
<h2 id="string-stringbuffer-stringbuilder-2"><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder-2"></a> String、StringBuffer、StringBuilder</h2>
<ul>
<li>如果需要对字符串进行频繁拼接的话，建议使用StringBuffer或者StringBuilder</li>
</ul>
<h3 id="stringbuffer"><a class="markdownIt-Anchor" href="#stringbuffer"></a> StringBuffer</h3>
<ul>
<li>StringBuffer是一个字符串缓冲区，如果需要频繁的对字符串进行拼接时，建议使用StringBuffer。</li>
<li>StringBuffer的底层是byte数组（jdk9之后），jdk8中底层是char数组，如果没有明确设定，则系统会默认创建一个长度为16的byte类型数组，在使用时如果数组容量不够了，则会通过数组的拷贝对数组进行扩容，所以在使用StringBuffer时最好预测并手动初始化长度，这样能够减少数组的拷贝，从而提高效率。</li>
</ul>
<h3 id="stringbuilder和stringbuffer的区别"><a class="markdownIt-Anchor" href="#stringbuilder和stringbuffer的区别"></a> StringBuilder和StringBuffer的区别</h3>
<p>通过API可以看到StringBuilder和StringBuffer里面的方法是一样的，那他们有什么区别呢？<br>
StringBuffer是jdk1.0版本中加入的，是<strong>线程安全的</strong>，效率低<br>
StringBuilder是jdk5版本加入的，是<strong>线程不安全的</strong>，效率高</p>
<h2 id="什么是自动拆箱和自动装箱"><a class="markdownIt-Anchor" href="#什么是自动拆箱和自动装箱"></a> 什么是自动拆箱和自动装箱？</h2>
<ul>
<li>自动装箱：把基本类型转换为包装类类型</li>
<li>自动拆箱：把包装类类型转换为基本类型</li>
</ul>
<h2 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h2>
<blockquote>
<p>接口Collection: 由三个接口组成——List / Set / Queue</p>
</blockquote>
<h3 id="集合的由来"><a class="markdownIt-Anchor" href="#集合的由来"></a> 集合的由来</h3>
<p>数组长度是固定,如果要改变数组的长度需要创建新的数组将旧数组里面的元素拷贝过去，使用起来不方便。<br>
java给开发者提供了一些集合类，能够存储任意长度的对象，长度可以随着元素的增加而增加,随着元素的减少而减少，使用起来方便一些。</p>
<h3 id="集合类的一些特点"><a class="markdownIt-Anchor" href="#集合类的一些特点"></a> 集合类的一些特点</h3>
<ul>
<li>List：里面存放的数据是有顺序的，可以存放重复的数据。</li>
<li>Set：里面存放的数据是没有顺序的，不能存放重复的数据。</li>
<li>Queue：是一个队列，里面的数据是先进先出，可以存放重复的数据。</li>
</ul>
<h3 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3>
<ul>
<li>区别1:
<ul>
<li>数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值</li>
<li>集合只能存储引用数据类型(对象)，如果存储基本数据类型时，会自动装箱变成相应的包装类</li>
</ul>
</li>
<li>区别2:
<ul>
<li>数组长度是固定的,不能自动增长</li>
<li>集合的长度的是可变的,可以根据元素的增加而自动增长</li>
</ul>
</li>
</ul>
<h2 id="list两个子类的特点"><a class="markdownIt-Anchor" href="#list两个子类的特点"></a> List两个子类的特点</h2>
<p>ArrayList:</p>
<ul>
<li>底层数据结构是数组，查询快，增删慢。</li>
</ul>
<p>LinkedList:</p>
<ul>
<li>底层数据结构是链表，查询慢，增删快。</li>
</ul>
<p>ArrayList和LinkedList的区别</p>
<ul>
<li>ArrayList底层是数组结果,查询和修改快</li>
<li>LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢</li>
<li>共同点:都是<strong>线程不安全的</strong></li>
</ul>
<h3 id="arraylist线程安全的方案"><a class="markdownIt-Anchor" href="#arraylist线程安全的方案"></a> ArrayList线程安全的方案</h3>
<p>如果使用ArrayList需要考虑线程安全的问题，有两种方案：</p>
<ul>
<li>
<p>可以使用Collections工具类中的synchronizedList方法可以将ArrayList变成线程安全的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(new ArrayList());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用java.util.concurrent包下面的CopyOnWriteArrayList，使用方式跟ArrayList一样</p>
</li>
</ul>
<h2 id="集合数组的互转"><a class="markdownIt-Anchor" href="#集合数组的互转"></a> <a href="http://www.monkey1024.com/javase/565" target="_blank" rel="noopener">集合数组的互转</a></h2>
<p>集合转数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line">list.add(<span class="string">"c"</span>);</span><br><span class="line">list.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当集合转换数组时,数组长度如果是&lt;=集合的size时,转换后的数组长度等于集合的size</span></span><br><span class="line"><span class="comment">//如果数组的长度大于了size,分配的数组长度就和你指定的长度一样</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> String[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">for</span>(String s : array)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组转集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意转换后的集合不能调用其add方法向里面添加数据，否则会报出UnsupportedOperationException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组转集合</span></span><br><span class="line">String[] arr = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line"><span class="comment">//将数组转换成集合</span></span><br><span class="line">List&lt;String&gt; listArray = Arrays.asList(arr);                </span><br><span class="line"><span class="comment">//不能添加</span></span><br><span class="line"><span class="comment">//listArray.add("d");                                    </span></span><br><span class="line">System.out.println(listArray);</span><br><span class="line"><span class="comment">//通过这种方式将listArray转换成真正的ArrayList</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(listArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Arrays.asList((T… a))的源码可以看到，这里面返回的ArrayList是在Arrays类里面定义的一个内部类，并非java.util包下的ArrayList。</span></span><br></pre></td></tr></table></figure>
<p>基本数据类型的数组转换成集合,会将整个数组当作一个对象转换，下面程序将会打印出list的对象地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;            </span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; list = Arrays.asList(arr);            </span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// ==&gt;[[I@282ba1e]</span></span><br></pre></td></tr></table></figure>
<p>==&gt;▲.将数组转换成集合,数组中的数据必须是引用数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;                    </span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(arr);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// ==&gt;[11, 22, 33, 44, 55]</span></span><br></pre></td></tr></table></figure>
<h2 id="collection集合"><a class="markdownIt-Anchor" href="#collection集合"></a> Collection集合</h2>
<h3 id="set的特点"><a class="markdownIt-Anchor" href="#set的特点"></a> Set的特点</h3>
<p>Set里面存储的元素不能重复，没有索引，存取顺序不一致。</p>
<p><strong>▲.这里需要注意：在向HashSet中存放自定义类型对象时，一定要<a href="###HashCode%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8">重写hashCode和equals方法</a></strong>，原因是无重复的话需要比较， 所以得。</p>
<h3 id="treeset简介"><a class="markdownIt-Anchor" href="#treeset简介"></a> TreeSet简介</h3>
<p>TreeSet的特点是可以对存放进去的元素<strong>进行排序</strong>。</p>
<p>∴ 使用TreeSet存储自定义类型。这里还是存储之前定义的Person对象，<strong>需要实现Comparable接口并且重写compareTo方法</strong>，先根据name的字典顺序排序，然后再根据年龄进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.nymrli.day07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.scene.PerspectiveCamera;</span><br><span class="line"><span class="keyword">import</span> javafx.util.converter.PercentageStringConverter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: testIDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Set测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: MrLi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2020-05-16 09:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">day07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        boolean b1 = hs.add("a");</span></span><br><span class="line"><span class="comment">//        System.out.println(hs);</span></span><br><span class="line"><span class="comment">//        boolean c1 = hs.add("b");</span></span><br><span class="line"><span class="comment">//        System.out.println(hs);</span></span><br><span class="line"><span class="comment">//        for (String s : hs) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(s);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Q1:</span></span><br><span class="line"><span class="comment">//        HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        Random random = new Random();</span></span><br><span class="line"><span class="comment">//        while (hashSet.size() &lt; 10) &#123;</span></span><br><span class="line"><span class="comment">//            int num = random.nextInt(20);</span></span><br><span class="line"><span class="comment">//            hashSet.add(num);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        for (Integer i : hashSet) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(i);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Q2;Treeset</span></span><br><span class="line">        TreeSet&lt;Person&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"cl"</span>, <span class="number">30</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"qsy"</span>, <span class="number">25</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"sxh"</span>, <span class="number">30</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"ll"</span>, <span class="number">15</span>));</span><br><span class="line">        <span class="keyword">for</span> (Person p : ts) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(getName(), person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nameSame = <span class="keyword">this</span>.name.compareTo(o.name);</span><br><span class="line">        <span class="keyword">if</span> (nameSame != <span class="number">0</span>)&#123;     <span class="comment">// 如果name不相等</span></span><br><span class="line">            <span class="comment">// 当compareTo方法返回正数的时候，系统将元素存储到右边，所以集合存取顺序一致</span></span><br><span class="line">            <span class="keyword">return</span> nameSame;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map接口概述"><a class="markdownIt-Anchor" href="#map接口概述"></a> Map接口概述</h3>
<blockquote>
<p>map中的元素是以键-值的方式存在的，通过键可以获取到值，键是不可以重复的，跟地图比较像，通过一个坐标就可以找到具体的位置。该接口由三个类实现: <code>HashMap / HashTable / AbstractMap</code></p>
</blockquote>
<p>▲与前两个相比，添加元素的函数由<code>add =&gt; put</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">day08_Map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashmap.put(<span class="string">"Cl"</span>, <span class="number">18</span>);</span><br><span class="line">        hashmap.put(<span class="string">"GJQ"</span>, <span class="number">15</span>);</span><br><span class="line">        hashmap.put(<span class="string">"SXH"</span>, <span class="number">10</span>);</span><br><span class="line">        hashmap.put(<span class="string">"HSR"</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(hashmap);</span><br><span class="line">        System.out.println(hashmap.containsValue(<span class="string">"CL"</span>));</span><br><span class="line">        System.out.println(hashmap.containsKey(<span class="string">"GJQ"</span>));</span><br><span class="line">        System.out.println(<span class="string">"------"</span>);</span><br><span class="line">        Collection&lt;Integer&gt; values = hashmap.values();</span><br><span class="line">        System.out.println(values);</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        Integer res = hashmap.remove(<span class="string">"SXH"</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map的遍历</span></span><br><span class="line">        <span class="comment">// 方法一</span></span><br><span class="line">        Set&lt;String&gt; keySet = hashmap.keySet();</span><br><span class="line">        Iterator&lt;String&gt; iterator = keySet.iterator();</span><br><span class="line">        System.out.println(keySet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"Key: "</span> + key + <span class="string">" value: "</span> + hashmap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"---------"</span>);</span><br><span class="line">        <span class="comment">// 上述的代替写法</span></span><br><span class="line"><span class="comment">//        for (String key : keySet) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Key:" + key + "value: " + hashmap.get(key));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二</span></span><br><span class="line">        <span class="comment">// Map中的键和值被封装成了Entry对象,并存储在Set集合中，通过entrySet()可以获取到这个Set集合。</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = hashmap.entrySet();</span><br><span class="line"><span class="comment">//        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entriesIterator = entries.iterator();</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; en : entries) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Key:"</span> + en.getKey() + <span class="string">" value: "</span> + en.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"_______________"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>LinkedHashMap</strong></p>
<ul>
<li>LinkedHashMap的特点：存取顺序一致</li>
</ul>
<p><strong>TreeMap</strong></p>
<ul>
<li>TreeMap的特点：可以对存储的元素进行排序</li>
</ul>
<h4 id="hashmap和hashtable的区别"><a class="markdownIt-Anchor" href="#hashmap和hashtable的区别"></a> HashMap和Hashtable的区别</h4>
<ul>
<li>Hashtable是JDK1.0版本出现的,是线程安全的,效率低，不可以存储null键和null值</li>
<li>HashMap是JDK1.2版本出现的，是线程不安全,效率高，可以存储null键和null值</li>
</ul>
<h3 id="collection工具"><a class="markdownIt-Anchor" href="#collection工具"></a> Collection工具</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list);</span><br><span class="line">Collections.shuffle(list);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">Collections.binarySearch(list, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<h3 id="collection总结"><a class="markdownIt-Anchor" href="#collection总结"></a> Collection总结</h3>
<ul>
<li>
<p><strong>List(存取有序,有索引,可以重复)</strong></p>
<ul>
<li>ArrayList<br>
底层是数组实现的,线程不安全,查找和修改快,增和删比较慢</li>
<li>LinkedList<br>
底层是链表实现的,线程不安全,增和删比较快,查找和修改比较慢</li>
<li>Vector<br>
底层是数组实现的,线程安全的,无论增删改查都慢</li>
</ul>
</li>
</ul>
<p>如果查找和修改多,用ArrayList<br>
如果增和删多,用LinkedList<br>
如果都多,用ArrayList</p>
<ul>
<li>
<p><strong>Set(存取无序,无索引,不可以重复)</strong></p>
<ul>
<li>HashSet<br>
底层是哈希算法实现</li>
<li>LinkedHashSet<br>
底层是链表实现,可以保证元素唯一,存取顺序一致</li>
<li>TreeSet<br>
底层是二叉树算法实现，可以排序，存储自定义类型时需要注意实现Comparable接口并重写compareTo方法</li>
</ul>
<p>一般在开发的时候不需要对存储的元素排序,所以在开发的时候大多用HashSet,HashSet的效率比较高.TreeSet在面试的时候比较多</p>
</li>
<li>
<p><strong>Map</strong></p>
<ul>
<li>HashMap<br>
底层是哈希算法</li>
<li>LinkedHashMap<br>
底层是链表，存取顺序一致</li>
<li>TreeMap<br>
<strong>底层是二叉树算法</strong>，可以排序</li>
</ul>
<p>开发中用HashMap比较多</p>
</li>
</ul>
<h2 id="hashcode"><a class="markdownIt-Anchor" href="#hashcode"></a> HashCode</h2>
<h3 id="hashcode方法的作用"><a class="markdownIt-Anchor" href="#hashcode方法的作用"></a> HashCode方法的作用</h3>
<p>在HashSet中的元素是不能重复的，jvm可以通过equals方法来判断两个对象是否相同，假设自定义一个Person类里面有10个成员变量，每调用一次equals方法需要做10次if判断分别比较这10个成员变量是否相等，如果想HashSet中存放100个对象，那就会做1000次if判断，数据量大的话会严重影响性能。<br>
要解决这个问题的话可以这样做，将一些特征相似或相近的对象归类放到一起给他们一个编号，在做equals判断时，先比较这些编号，编号相同的话再去比较equals，这样可以减少一些比较次数。这个编号可以通过HashCode方法获得。<strong>HashCode方法的作用就是将对象进行分类，然后获取到编号值。</strong><br>
举个例子，图书馆里面的书都是分好类的，想找《java编程思想》这本书，先找到计算机类的书架，然后再去找就行，倘若图书馆里面的书籍没有分类，那找起来就如大海捞针。</p>
<h3 id="如何重写hashcode"><a class="markdownIt-Anchor" href="#如何重写hashcode"></a> 如何重写HashCode</h3>
<p>HashCode算法决定了对象的归类，如果算法编写的不好可能不会对性能有所提升。在编写时最好可以让对象均匀的散列开，这里假设可以将对象分为10个种类，那么每个种类中存放的对象的数量最好不要相差太多。</p>
<p>将Person的name和age属性都加上了，可以将Person进行细分，开发中建议使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    result = prime * result + age;</span><br><span class="line">    result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么上面的prime的值是31？其实这个值改成别的也可以，只不过定义为31之后有一些好处：</p>
<ul>
<li>31是一个质数,质数是能被1和自己本身整除的数，并且这个数不大也不小</li>
<li>31这个数好算,2的五次方-1,2向左移动5位</li>
</ul>
<h3 id="关于重写hashcode方法的一些说明"><a class="markdownIt-Anchor" href="#关于重写hashcode方法的一些说明"></a> 关于重写HashCode方法的一些说明</h3>
<ul>
<li>任何时候对同一对象多次调用 hashCode 方法，都必须一直返回同样的整数。</li>
<li>如果两个对象通过 equals(Object) 方法来比较相等，那么这两个对象的 hashCode的值必须相等。</li>
<li>如果两个对象通过 equals(Object) 方法比较结果不等，可以相等也可以不相等。</li>
</ul>
<h2 id="properties类"><a class="markdownIt-Anchor" href="#properties类"></a> Properties类</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> FileReader(<span class="string">"store.txt"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String k : set) &#123;</span><br><span class="line">            String value = properties.getProperty(k);</span><br><span class="line">            System.out.println(k + <span class="string">"="</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">storeInto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileWriter fileWriter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.setProperty(<span class="string">"陈力"</span>, <span class="string">"18"</span>);</span><br><span class="line">            properties.setProperty(<span class="string">"SQY"</span>, <span class="string">"19"</span>);</span><br><span class="line">            properties.store(fileWriter, <span class="string">"Save data"</span>);</span><br><span class="line">            fileWriter = <span class="keyword">new</span> FileWriter(<span class="string">"store.txt"</span>);</span><br><span class="line">            fileWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型的概念"><a class="markdownIt-Anchor" href="#泛型的概念"></a> 泛型的概念</h2>
<p>在编写集合相关代码时在eclipse里面总有一些黄色警告，在不使用注解的情况下，使用泛型之后，就不会有这些黄色警告了。<br>
通过API可以看到Collection,List,ArrayList,这几个类里面都有,这个就是泛型，里面的E可以是任何引用数据类型，使用泛型指明了数据类型之后，这个集合里面只能存储这种数据类型的对象。</p>
<p>不使用泛型时，要进行多次类型强制转换。如<code>List list = new ArrayList();</code></p>
<p>使用泛型: <code>List&lt;Person&gt; list = new ArrayList&lt;Person&gt;();</code></p>
<h3 id="泛型的优点"><a class="markdownIt-Anchor" href="#泛型的优点"></a> <strong>泛型的优点</strong></h3>
<ul>
<li>可以统一集合中的数据类型，提高安全性</li>
<li>可以减少强制类型转换</li>
</ul>
<h3 id="自定义泛型"><a class="markdownIt-Anchor" href="#自定义泛型"></a> 自定义泛型</h3>
<p>通过JDK的源码可以看到，泛型一般写的都是或者，里面的T和E就是表示使用者指定的类型。可以自己定义一个使用泛型的类</p>
<h3 id="泛型通配符"><a class="markdownIt-Anchor" href="#泛型通配符"></a> 泛型通配符</h3>
<p>在实际工作当中，有可能通过调用某个方法来接受一个返回值List的数据，这样就不<strong>太好确定返回值中的数据类型</strong>，这样可以使用泛型通配符&lt;?&gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//=号右边可能是通过调用某个方法返回的List</span></span><br></pre></td></tr></table></figure>
<p>使用泛型通配符限定子类或者父类</p>
<ul>
<li><code>? extends E</code><br>
向下限定，E及其子类，可以存储当前类型的子类</li>
<li><code>? super E</code><br>
向上限定，E及其父类，可以存储当前类型的父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ? extends E 向下限定，E及其子类，可以存储当前类型的子类 </span></span><br><span class="line"><span class="comment"> * ? super E 向上限定，E及其父类，可以存储当前类型的父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Student&gt; studentList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//因为studentList中存放的Student是Person类的子类，所以可以将studentList放入personList中</span></span><br><span class="line">        personList.addAll(studentList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合框架中的三种迭代方式删除数据"><a class="markdownIt-Anchor" href="#集合框架中的三种迭代方式删除数据"></a> 集合框架中的三种迭代方式删除数据</h2>
<ul>
<li>
<p>普通for循环,可以删除,注意让索引做自减运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,普通for循环删除,索引做自减运算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"b"</span>.equals(list.get(i))) &#123;</span><br><span class="line">        list.remove(i);        </span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常</p>
</li>
<li>
<p>增强for循环不能删除</p>
</li>
</ul>
<h2 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h2>
<blockquote>
<p><strong>注意：如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰符 返回值类型 方法名(数据类型…  变量名)&#123;&#125;</span></span><br><span class="line"><span class="comment">//可变参数其实是一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> ... arr)</span> </span>&#123;            </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解:</h2>
<blockquote>
<p>之前也看过一些Java-Spring Boot的视频, 有些讲的详细的会去讲源码，然后当时就是看到有很多注解， 就不懂是什么意思， 形成了理解障碍。 所以这次特地又去了解了一下</p>
</blockquote>
<p>Spring-Boot的入口函数是由<code>@SpringBootApplication</code>注解的main，无疑<code>@SpringBootApplication</code>这个注解是非常重要的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), <span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述一共七个注解，一共可以分成三类： 元注解、配置注解、Component组件注解。之前学的时候就是被这么多注解给吓到了，而且课上对注解的讲解也特别小， 所以一直感觉注解是个高深莫测的东西。</p>
<ul>
<li>
<p>元注解讲解： <a href="https://www.cnblogs.com/kingsonfu/p/10634174.html" target="_blank" rel="noopener">Java 元注解</a></p>
<ul>
<li>@Target： 描述注解的范围，即注解在哪用 —— 最重要的
<ul>
<li>CONSTRUCTOR:用于描述构造器</li>
<li>FIELD:用于描述域即类成员变量</li>
<li>METHOD:用于描述方法</li>
<li>PACKAGE:用于描述包</li>
<li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li>
</ul>
</li>
<li>@Retention： 描述注解的生命周期</li>
<li>@Documented： 标记注解，没有参数</li>
<li><code>@Inherited</code>使用该注解的注解父类的子类可以继承父类的注解。请注意，<u>如果使用注释类型来注释除类之外的任何内容，则此元注释类型不起作用</u>。 还要注意，这个元注释只会导致从超类继承注释; 已实现的接口上的注释无效。——比较少用</li>
</ul>
</li>
<li>
<p>配置注解源码讲解: <a href="https://www.bilibili.com/video/BV1gW411W76m/?p=7&amp;t=428" target="_blank" rel="noopener">尚硅谷SpringBoot顶尖教程(springboot之idea版spring boot)</a></p>
<ul>
<li>
<p><code>@AutoConfigurationPackage</code>由<code>@Import({Registrar.class})</code>注解，其中<code>Registrar</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));	<span class="comment">// 后面第二个参数的结果是metadata中的所有包==&gt;即获得主配置类所在包及以下子包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将主配置类(<code>@SpringBootApplication</code>标注的类)所在包及下面子包里面的所有组件扫描到Spring容器中</p>
</li>
</ul>
</li>
</ul>
<p>注解（Annontion）是Java5开始引入的新特征。它提供了一种<strong>安全的类似注释的机制</strong>，用来将<strong>任何的信息或元数据</strong>（metadata）与程序元素（类、方法、成员变量等）进行关联。==&gt;类似注释，但能将内容传递给程序，对修饰对象有约束作用。</p>
<p>代码demo： <a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" target="_blank" rel="noopener">注解Annotation实现原理与自定义注解例子</a></p>
<h2 id="io流"><a class="markdownIt-Anchor" href="#io流"></a> IO流</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次调用的时候会读取一个字节的数据，如果read返回结果是-1，则说明读取完毕</span></span><br><span class="line"><span class="keyword">int</span> temp;<span class="comment">//保存当前读取的字节数据</span></span><br><span class="line"><span class="comment">//将读取的数据赋值给temp，然后再判断</span></span><br><span class="line"><span class="keyword">while</span> ((temp = f.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用fileseparator解决不同系统的路径问题"><a class="markdownIt-Anchor" href="#使用fileseparator解决不同系统的路径问题"></a> 使用File.separator解决不同系统的路径问题</h3>
<p>在windos中的文件路径是以&quot;“来分隔<br>
在linux中的文件路径是以”/&quot;来分隔<br>
如果将上面代码部署到linux中会读取不到文件，为了保证编写的代码跨平台需要使用java.io包下的File.separator来替代文件路径的分隔符，如下：<code>fis = new FileInputStream(&quot;file&quot; + File.separator + &quot;monkey.txt&quot;);</code></p>
<h3 id="文件io读写fileinputstream"><a class="markdownIt-Anchor" href="#文件io读写fileinputstream"></a> 文件IO读写FileInputStream</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">copy_io</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\10630\\Desktop\\TODO\\ok.yml"</span>);</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"good.txt"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> newFile = file.createNewFile();</span><br><span class="line">                System.out.println(<span class="string">"Yes, Create it~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"good.txt"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] arr= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line">            <span class="keyword">while</span> ((length = fis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// f.read(arr)和f.read()不一样， </span></span><br><span class="line">                <span class="comment">// f.read(arr)会一次性读取arr大小的数据， 然后长度用length来记录读取了多少字符</span></span><br><span class="line">                <span class="comment">// write写的时候， 将数组arr中length写入文件</span></span><br><span class="line">                <span class="comment">// 在while中输出了length的大小， 为1024， 842</span></span><br><span class="line">                fos.write(arr, <span class="number">0</span>, length);</span><br><span class="line">                System.out.println(length);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用缓冲流进行文件拷贝bufferedinputstream"><a class="markdownIt-Anchor" href="#使用缓冲流进行文件拷贝bufferedinputstream"></a> 使用缓冲流进行文件拷贝BufferedInputStream</h3>
<p>Java中提供了<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>缓冲流用来读取和写出， <code>BufferedInputStream</code>读取时会创建一个长度为8192的byte类型数组，程序一次读取8192个字节数据到数组中 使用缓冲流之后就不用再自定义byte类型数组了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bufferStream_io</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedInputStream ` = <span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\10630\\Desktop\\TODO\\ok.yml"</span>));</span><br><span class="line">            bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">            <span class="comment">// 其实不存在会自动创建, 不需要下面的代码</span></span><br><span class="line">            File f = <span class="keyword">new</span> File(<span class="string">"text.txt"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> newFile = f.createNewFile();</span><br><span class="line">                System.out.println(<span class="string">"创建成功~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp;</span><br><span class="line">            <span class="keyword">while</span> ((tmp = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.monkey1024.com/javase/608" target="_blank" rel="noopener">使用自定义数组和buffer的图解</a></p>
<h3 id="jdk7的新写法"><a class="markdownIt-Anchor" href="#jdk7的新写法"></a> jdk7的新写法</h3>
<p>在jdk7中新加入了AutoCloseable接口，IO流中的类都实现了这个接口，这样在读取或者写出操作结束之后，系统会自动close相关资源，开发者不需要再手动close了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\10630\\Desktop\\TODO\\ok.yml"</span>)); BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"auto.txt"</span>));) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> ((tmp = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用字符流解决乱码问题filereader"><a class="markdownIt-Anchor" href="#使用字符流解决乱码问题filereader"></a> 使用字符流解决乱码问题FileReader</h2>
<blockquote>
<p>字符流FileReader主要用来读取字符的IO流，使用字符流读取文本文件可以解决乱码问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader_io</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">"G:\\C与C++、\\java\\testIDEA\\src\\testForChinests.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">while</span> ((c = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用缓冲流bufferedreader可以一次读取一行的文字"><a class="markdownIt-Anchor" href="#使用缓冲流bufferedreader可以一次读取一行的文字"></a> 使用缓冲流<strong>BufferedReader</strong>可以一次读取一行的文字：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">try</span> (BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"G:\\C与C++、\\java\\testIDEA\\src\\testForChinests.txt"</span>))) &#123;</span><br><span class="line">          String s;</span><br><span class="line">          <span class="keyword">while</span> ((s = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">              System.out.print(s);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>写入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">      <span class="keyword">try</span>(FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"newword.txt"</span>);)&#123;</span><br><span class="line">          fw.write(<span class="string">"我喜欢学习java"</span>);</span><br><span class="line">          fw.write(<span class="number">32</span>);       <span class="comment">// 空格</span></span><br><span class="line">          fw.write(<span class="number">97</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span>(BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"newword.txt"</span>));)&#123;</span><br><span class="line">          bw.write(<span class="string">"我喜欢打篮球"</span>);</span><br><span class="line">          bw.newLine();<span class="comment">//换行</span></span><br><span class="line">          bw.write(<span class="string">"我喜欢踢足球"</span>);</span><br><span class="line">          bw.flush();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>BufferedWriter、BufferedInputStream内的参数都是原有的FileWrite、FileInputStream，实际上使用了装饰模式（设计模式）</li>
<li>BufferedWriter、BufferedReader多了writeLine、readLine方法</li>
</ul>
<p><strong>装饰者设计模式的优点：</strong><br>
不用修改被装饰对象的源码，装饰者与被装饰者耦合度不高。</p>
<h3 id="转换流"><a class="markdownIt-Anchor" href="#转换流"></a> <a href="http://www.monkey1024.com/javase/624" target="_blank" rel="noopener">转换流</a>——编码格式转换InputStreamReader：</h3>
<blockquote>
<p>字节-&gt;字符</p>
</blockquote>
<p>如果要解决上面问题，需要使用InputStreamReader和OutputStreamWriter指明文本文件的编码，这两个类都属于字符流，可以将字节流输出为字符流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用FileInputStream读取文本内容，然后通过InputStreamReader和指定的编码将字符转换为字节</span></span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"utf-8.txt"</span>), <span class="string">"utf-8"</span>));</span><br><span class="line">            BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">                    <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"gbk.txt"</span>), <span class="string">"gbk"</span>));) &#123;</span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">while</span>((msg = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        bw.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException | FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中再FileInputStream对象上使用了InputStreamReader装饰，从而将字节转换为字符，之后再InputStreamReader对象上又使用了BufferedReader将字符进行缓冲，从而提高。==&gt;都有reader</p>
<h2 id="输出指定目录下的所有文件名称"><a class="markdownIt-Anchor" href="#输出指定目录下的所有文件名称"></a> 输出指定目录下的所有文件名称</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputAllFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> File file = getFile();</span><br><span class="line">        getListFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getListFiles</span><span class="params">(File f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> File[] files = f.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">'\t'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(files[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (files[i].isDirectory()) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                getListFiles(files[i]);</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">getFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"请输入要遍历的目录: "</span>);</span><br><span class="line">        <span class="keyword">final</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> String next = scanner.nextLine();</span><br><span class="line">            <span class="comment">//　next()不会吸取字符前/后的空格/Tab键，只吸取字符，开始吸取字符（字符前后不算）直到遇到空格/Tab键/回车截止吸取；</span></span><br><span class="line">            <span class="comment">//　nextLine()吸取字符前后的空格/Tab键，回车键截止。</span></span><br><span class="line">            <span class="keyword">final</span> File file = <span class="keyword">new</span> File(next);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"输出的路径错误, 请重新输入"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"请输入一个文件夹路径"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> file;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="序列化和反序列化"><a class="markdownIt-Anchor" href="#序列化和反序列化"></a> 序列化和反序列化</h2>
<blockquote>
<ul>
<li>在工作中有可能遇到多台机器远程通信的情况，如果要将机器A中的某个java对象传输到机器B上面，需要将这个java对象转换为字节序列然后进行传输。将对象转换为字节序列的过程叫做序列化，反之叫做反序列化。</li>
<li>使用序列化还可以将一个对象保存到硬盘中，然后再通过反序列化将该对象读取到内存里面。</li>
</ul>
<p>一个对象如果支持序列化，需要实现Serializable的接口，<u>这个接口中没有任何方法</u>，实现该接口后，JVM会给这个对象做特殊待遇</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Student s = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream zhangsan = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"zhangsan"</span>))) &#123;</span><br><span class="line">            <span class="comment">// try()括号中，如果是多句， 则加;， 单句不需要加;</span></span><br><span class="line">            <span class="comment">// ObjectOutputStream也是一个装饰模式</span></span><br><span class="line">            zhangsan.writeObject(s);</span><br><span class="line">            zhangsan.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个类实现Serializable接口后，系统会给每个对象一个序列化版本号，当这个类的源码被修改后，系统会重新分配一个新的序列化版本号，这样做的好处就是保证序列化和反序列化的对象内容一致。例如将一个对象序列化到硬盘之后，修改这个对象所对应类的源码，在进行反序列化是就会报出InvalidClassException异常。如果手动编写序列化版本号之后，就不会出现这个异常了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动生成序列化版本号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">716323668524282676L</span>;</span><br></pre></td></tr></table></figure>
<h3 id="transient关键字"><a class="markdownIt-Anchor" href="#transient关键字"></a> transient关键字</h3>
<p>如果不希望将Student类中的age属性序列化，可以使用transient声明该属性，在序列化时将忽略这个属性。<code>transient private int age;</code></p>
<h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h2>
<h3 id="三种创建方式"><a class="markdownIt-Anchor" href="#三种创建方式"></a> 三种创建方式</h3>
<ul>
<li>
<p>继承Thread类， 重写run方法</p>
<ul>
<li>优点:可以直接使用Thread类中的方法,代码简单</li>
<li>缺点:继承Thread类之后就不能继承其他的类</li>
</ul>
</li>
<li>
<p>实现runnable接口， 重写run方法</p>
<ul>
<li>优点:即时自定义类已经有父类了也不受影响，因为可以实现多个接口</li>
<li>缺点:在run方法内部需要获取到当前线程的Thread对象后才能使用Thread中的方法</li>
</ul>
</li>
<li>
<p>实现Callable接口创建线程</p>
<ul>
<li>
<p>优点：可以获取返回值，可以抛出异常</p>
</li>
<li>
<p>缺点：代码编写较为复杂</p>
<p>1.自定义一个类实现java.util.concurrent包下的Callable接口<br>
2.重写call方法<br>
3.将要在线程中执行的代码编写在call方法中<br>
4.创建<code>ExecutorService</code>线程池<br>
5.将自定义类的对象放入线程池里面<br>
6.获取线程的返回结果<br>
7.关闭线程池，不再接收新的线程，未执行完的线程不会被关闭</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义一个类实现Callable&lt;V&gt;接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 2.重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 3.将要执行的代码写在call方法中</span></span><br><span class="line">        <span class="comment">//返回一个随机数</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> num = r.nextInt(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread_callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//4.创建ExecutorService线程池</span></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.将自定义类的对象放入线程池里面</span></span><br><span class="line">        <span class="comment">//开启两个线程</span></span><br><span class="line">        Future&lt;Integer&gt; result1 = exec.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        Future&lt;Integer&gt; result2 = exec.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断线程是否计算完毕</span></span><br><span class="line">        <span class="keyword">while</span> (!result1.isDone() &amp;&amp; !result2.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"等待线程计算完毕"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.获取线程的返回结果</span></span><br><span class="line">        Integer i1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i1 = result1.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Integer i2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i2 = result2.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(i1);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.关闭线程池，不再接收新的线程，未执行完的线程不会被关闭</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3>
<p>线程池是初始化一个多线程应用程序过程中创建一个<strong>线程集合</strong>，即一次创建多个线程，然后在需要执行新的任务时直接去这个线程集合中获取，而不是重新创建一个线程。任务执行结束后，线程放回到池子中等待下一次的分配。</p>
<p><strong>线程池的作用</strong></p>
<p>解决创建单个线程耗费时间和资源的问题。</p>
<p><strong>创建线程池</strong></p>
<p>上面代码中演示了两种方式创建线程池</p>
<ul>
<li><code>Executors.newFixedThreadPool(int nThreads);</code><br>
通过传入的int类型参数来指定创建线程池中的线程数，如果任务数量大于线程数量，则任务会进行等待。</li>
<li><code>Executors.newCachedThreadPool();</code><br>
会根据需要创建新线程的线程池，如果线程池中的线程数量小于任务数时，会创建新的线程，线程池中的线程最大数量是Integer.MAX_VALUE，int类型的最大值。如果线程的处理速度小于任务的提交速度时，会不断创建新的线程来执行任务，这样有可能会因为创建过多线程而耗尽CPU 和内存资源。</li>
</ul>
<p>匿名内部类、labmbda表达式创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewWayCreateThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 匿名内部类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: MrLi        </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [args] </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Return</span>: void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/5/18 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    System.out.println( Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">                    System.out.println( getClass() + <span class="string">" "</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: labmbda表达式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: MrLi</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [args]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Return</span>: void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/5/18</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized同步方法与同步代码块"><a class="markdownIt-Anchor" href="#synchronized同步方法与同步代码块"></a> synchronized同步方法与同步代码块</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> begin1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> end1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> begin2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> end2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LongTask ts = <span class="keyword">new</span> LongTask();</span><br><span class="line">        Thread t1 =<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            begin1 = System.currentTimeMillis();</span><br><span class="line">            ts.add();</span><br><span class="line">            end1 = System.currentTimeMillis();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//        new Thread(syncValue::add).start();</span></span><br><span class="line">             begin2 = System.currentTimeMillis();</span><br><span class="line">            ts.add();</span><br><span class="line">             end2 = System.currentTimeMillis();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(begin1 &gt; begin2)&#123;</span><br><span class="line">            begin = begin2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            begin = begin1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(end1 &gt; end2)&#123;</span><br><span class="line">            end = end1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            end = end2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"两个线程总共耗时："</span> + (end -begin) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public synchronized void add() &#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(3000L);</span></span><br><span class="line"><span class="comment">//            System.out.println("执行耗时任务");</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        num++;</span></span><br><span class="line"><span class="comment">//        System.out.println(num);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//两个线程总共耗时：6001ms</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">            System.out.println(<span class="string">"执行耗时任务"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个线程总共耗时：3001ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后将需要同步的代码放到synchronized代码块中，再次运行SynchronizedTest02类，打印结果是3秒，因为那段耗时较长的代码是在异步情况下运行，所以节省了一些时间。</p>
<p><strong>注意：多个线程在执行synchronized同步代码块时，代码块括号里面可以传入任意对象，但一定要保证多个线程访问的是同一个对象。</strong>(这里代码只有一个实例, 这个实例的obj是相同的)</p>
<h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2>
<h3 id="饿汉式"><a class="markdownIt-Anchor" href="#饿汉式"></a> 饿汉式</h3>
<ul>
<li>构造方法私有化</li>
<li>创建当前类对象</li>
<li>对外提供公共的访问方法将SingletonHungary对象暴露给外部</li>
</ul>
<h3 id="懒汉式"><a class="markdownIt-Anchor" href="#懒汉式"></a> 懒汉式</h3>
<ul>
<li>构造方法私有化</li>
<li>创建当前类的引用</li>
<li>对外提供公共的访问方法将SingletonHungary对象暴露给外部</li>
</ul>
<h3 id="单例模式的案例runtime"><a class="markdownIt-Anchor" href="#单例模式的案例runtime"></a> 单例模式的案例Runtime</h3>
<p>java.lang包下的Runtime类使用了单例模式，使用该类可以执行windows系统里面的一些命令，例如：mspaint（打开画图软件），shutdown（关机）等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Runtime rt = Runtime.getRuntime();</span><br><span class="line">    rt.exec(<span class="string">"mspaint"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用timer类来实现定时任务"><a class="markdownIt-Anchor" href="#使用timer类来实现定时任务"></a> 使用Timer类来实现定时任务</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Timer t = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">//        t.schedule(new TimerTask() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//                final Date date = new Date();</span></span><br><span class="line"><span class="comment">//                System.out.println(date);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;, new SimpleDateFormat("yyyy-MM-dd hh:mm:ss SSS").parse("2017-07-03 18:09:00 000"), 5000);</span></span><br><span class="line">        <span class="comment">//第一个参数接收TimerTask对象，即上面创建的MyTimerTask</span></span><br><span class="line">        <span class="comment">//第二参数的Date类型是定时任务执行的开始时间</span></span><br><span class="line">        <span class="comment">//第三个参数指定定时任务每隔多少毫秒执行一次</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        t.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lambda表达式和匿名内部类"><a class="markdownIt-Anchor" href="#lambda表达式和匿名内部类"></a> Lambda表达式和匿名内部类</h2>
<blockquote>
<p>使用lambda表达式的前提是： 必须为<strong>函数式接口</strong>（有且只有一个抽象方法的接口，可以用<code>@FunctionalInterface</code>,接口中可以包含默认、静态、私有方法）</p>
</blockquote>
<ul>
<li>匿名内部类会生成一个<code>xxxx$1.class</code>文件， 而lambda表达式不会生成</li>
<li>lambda 有延迟加载的效果，从而不存在性能浪费——优化日志</li>
</ul>
<p>From: <a href="https://www.bilibili.com/video/BV1A4411K7Gx?p=417" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1A4411K7Gx?p=417</a></p>
<h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2>
<p>获得字节码class的三种方式</p>
<ul>
<li>Source源代码阶段=&gt;<code>Class.forName(&quot;全类名&quot;)</code>
<ul>
<li>多用于配i文件，捋类名定义在配文件中。读取文件，加载类</li>
</ul>
</li>
<li>Class类对象阶段=&gt;<code>类名.class</code>
<ul>
<li>多用于参数的传递</li>
</ul>
</li>
<li>Runtime运行阶段=&gt;<code>对象.getClass()</code>
<ul>
<li>多用于对象的获取字节码的方式</li>
</ul>
</li>
</ul>
<p>▲结论: 同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1： Class.forName</span></span><br><span class="line">Class cls1 = Class.forName(<span class="string">"top.nymrli.day17_reflect.Person"</span>);</span><br><span class="line">System.out.println(cls1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// way2:</span></span><br><span class="line">Class&lt;Person&gt; cls2 = Person.class;</span><br><span class="line">System.out.println(cls2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// way3:</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Class cls3 = person.getClass();</span><br><span class="line">System.out.println(cls3);</span><br><span class="line"></span><br><span class="line">System.out.println(cls3 == cls2);</span><br><span class="line">System.out.println(cls1 == cls2);</span><br></pre></td></tr></table></figure>
<h3 id="class对象功能"><a class="markdownIt-Anchor" href="#class对象功能"></a> Class对象功能:</h3>
<p>获取功能:</p>
<ol>
<li>
<p>获得成员变量</p>
<ul>
<li>
<p><code>Filed[] getFields()</code>——获得public修饰的字段</p>
</li>
<li>
<p><code>Field getField(String name)</code>——获得所有字段，无视修饰符</p>
</li>
<li>
<p><code>Field[] getDeclaredFields()</code></p>
</li>
<li>
<p><code>Field getDeclaredField(String name)</code></p>
</li>
</ul>
</li>
<li>
<p>获得构造方法</p>
<ul>
<li>
<p><code>Constructor constructor = cls1.getConstructor(String name);</code></p>
</li>
<li>
<p><code>Constructor[] constructors = cls1.getConstructors();</code></p>
</li>
<li>
<p><code>Constructor declaredConstructor = cls1.getDeclaredConstructor(String name);</code></p>
</li>
<li>
<p><code>Constructor[] declaredConstructors = cls1.getDeclaredConstructors();</code></p>
</li>
</ul>
</li>
<li>
<p>获得成员方法</p>
<ul>
<li>
<p><code>Method method = cls1.getMethod(String name);</code></p>
</li>
<li>
<p><code>Method[] methods = cls1.getMethods();</code></p>
</li>
<li>
<p><code>Method declaredMethod = cls1.getDeclaredMethod(String name);</code></p>
<p><code>Method[] declaredMethods = cls1.getDeclaredMethods();</code></p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Class cls1 = Class.forName(<span class="string">"top.nymrli.day17_reflect.Person"</span>);</span><br><span class="line">System.out.println(cls1);</span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Field name = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    name = cls1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">Object o = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);		<span class="comment">// private私有方法, 暴力反射</span></span><br><span class="line">    o = name.get(p);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(o);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    name.set(p, <span class="string">"cl"</span>);</span><br><span class="line">    o = name.get(p);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(o);</span><br></pre></td></tr></table></figure>
<h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例：</h3>
<p>*需求：写一个“框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法</p>
<p><strong>实现：</strong><br>
1.配置文件<br>
2.反射</p>
<p><strong>步骤</strong><br>
1.捋需要创建的对象的全类名和需要执行的方法定义在配置文件中<br>
2.在程序中加载读取配置文件<br>
3.使用反射技术来加载类文件进内存<br>
4.创建对象<br>
5.执行方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="comment">//    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        ClassLoader classLoader = Example.class.getClassLoader();</span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">"prop.properties"</span>);</span><br><span class="line">        properties.load(is);</span><br><span class="line"></span><br><span class="line">        String className = properties.getProperty(<span class="string">"className"</span>);</span><br><span class="line">        String classMethod = properties.getProperty(<span class="string">"classMethod"</span>);</span><br><span class="line"></span><br><span class="line">        Class cls = Class.forName(className);</span><br><span class="line">        <span class="comment">// 直接newInstance在java 9已被弃用</span></span><br><span class="line">        Object o = cls.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        Method method = cls.getMethod(classMethod);</span><br><span class="line">        method.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的加载与初始化"><a class="markdownIt-Anchor" href="#类的加载与初始化"></a> 类的加载与初始化</h2>
<h4 id="类加载器classloader"><a class="markdownIt-Anchor" href="#类加载器classloader"></a> 类加载器（ClassLoader）</h4>
<p>我们都知道 Java 文件被运行，第一步，需要通过 javac 编译器编译为 class 文件；第二步，JVM 运行 class 文件，实现跨平台。而 JVM 虚拟机第一步肯定是 加载 class 文件，所以，类加载器实现的就是：——通过一个类的全限定名来获取描述此类的二进制字节流（来自《深入理解Java虚拟机》）</p>
<p><strong>类加载器有几个重要的特性：</strong></p>
<ul>
<li>每个类加载器都有自己的预定义的搜索范围，用来加载 class 文件；</li>
<li>每个类和加载它的类加载器共同确定了这个类的唯一性，也就是说如果一个 class 文件被不同的类加载器加载到了 JVM 中，那么这两个类就是不同的类，虽然他们都来自同一份 class 文件；</li>
<li>双亲委派模型。</li>
</ul>
<p><strong>类的加载过程</strong>：</p>
<p>加载–&gt;链接（验证、准备（为静态量开辟空间并赋予初始值）、解析（将class中的符号引用转变为运行时的地址的直接引用））–&gt;初始化</p>
<p>为类的静态变量赋值，然后执行类的初始化（static）语句<br>
<strong>初始化的详细过程</strong>：</p>
<ul>
<li>如果类还没有被加载和链接，那就先进行加载和链接</li>
<li>如果类存在父类，并且父类还没有初始化，那就先初始化直接父类</li>
<li>如果类中存在初始化语句，顺序执行初始化语句</li>
</ul>
<p><strong>class初始化时机</strong></p>
<ul>
<li>创建类的实例（四种方式）</li>
<li>访问类中的某个静态变量，或者对静态变量进行赋值</li>
<li>主动调用类的静态方法</li>
<li>Class.forName（“包类名&quot;）完成子类的初始化，也会完成对本类的初始化（接口例外）</li>
<li>该类是程序引导入口（mian入口或者test入口）</li>
</ul>
<p><strong>双亲委派机制</strong></p>
<blockquote>
<p>bootstrap的加载过程是用c来完成的，在java中输出bootstrap加载器结果为null</p>
</blockquote>
<p>加载类的过程： 不断将加载任务交给父类加载器，是个递归的过程。如果父类能够加载，那么就加载，如果不能加载，那么就交给子类去加载。</p>
<ul>
<li>bootstrap：提供核心环境 、extension classloader负责拓展内容、application classloader负责程序运行期间自己写的class对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这边是递归的过程，会去找父加载器， 直至parent为null即用bootstrap加载</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/15/重拾Java笔记/%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpg" alt="类加载"></p>
<p>作用：</p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心的JAVA语言环境遭受破坏</li>
</ul>
<h3 id="classgetresource和classloadergetresource的区别"><a class="markdownIt-Anchor" href="#classgetresource和classloadergetresource的区别"></a> Class.getResource和ClassLoader.getResource的区别</h3>
<blockquote>
<p>Class.getResource和ClassLoader.getResource 最终调用的是ClassLoader 类的getResource方法</p>
</blockquote>
<p><strong><code>Class.getResource(String path)</code></strong></p>
<ul>
<li>path不以’/'开头时，默认是从此类所在的包下取资源；</li>
<li>path  以’/'开头时，则是从ClassPath根下获取；</li>
</ul>
<p><strong><code>Class.getClassLoader().getResource(String path)</code></strong></p>
<ul>
<li>path不能以’/'开头时；</li>
<li>path是从ClassPath根下获取；</li>
</ul>
<h2 id="正则匹配"><a class="markdownIt-Anchor" href="#正则匹配"></a> 正则匹配</h2>
<p><img src="/2020/05/15/重拾Java笔记/java%E6%AD%A3%E5%88%99.jpg" alt="java正则"></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除&quot;\r\n&quot;之外的任何单个字符。若要匹配包括&quot;\r\n&quot;在内的任意字符，请使用诸如&quot;[\s\S]&quot;之类的模式。</td>
</tr>
<tr>
<td>*</td>
<td>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配&quot;z&quot;和&quot;zoo&quot;。* 等效于 {0,}。</td>
</tr>
<tr>
<td>+</td>
<td>一次或多次匹配前面的字符或子表达式。例如，&quot;zo+&quot;与&quot;zo&quot;和&quot;zoo&quot;匹配，但与&quot;z&quot;不匹配。+ 等效于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>零次或一次匹配前面的字符或子表达式。例如，&quot;do(es)?“匹配&quot;do&quot;或&quot;does&quot;中的&quot;do”。? 等效于 {0,1}。</td>
</tr>
</tbody>
</table>
<p><strong>方法说明：</strong></p>
<ul>
<li><strong>matches</strong> ：尝试将<u>整个</u>区域与模式匹配。</li>
<li><strong>lookingAt</strong>： 方法虽然不需要整句都匹配，但是需要从<em>第一个字符</em>开始匹配。</li>
<li><strong>find</strong>： 尝试查找与该模式匹配的输入序列的下一个子序列。</li>
<li><strong>find(int start）</strong>：重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</li>
<li>替换： replaceFirst 替换首次匹配，replaceAll 替换所有匹配。</li>
</ul>
<p>▲强调: 使用<code>group()</code>之前一定得指定个以上的匹配方法</p>
<p><strong>匹配模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pattern compile = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    private static final int ALL_FLAGS = CASE_INSENSITIVE | MULTILINE |</span></span><br><span class="line"><span class="comment">            DOTALL | UNICODE_CASE | CANON_EQ | UNIX_LINES | LITERAL |</span></span><br><span class="line"><span class="comment">            UNICODE_CHARACTER_CLASS | COMMENTS;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="java泛型体系"><a class="markdownIt-Anchor" href="#java泛型体系"></a> Java泛型体系</h2>
<h3 id="通配符"><a class="markdownIt-Anchor" href="#通配符"></a> 通配符</h3>
<h3 id="上边界extends-下边界super"><a class="markdownIt-Anchor" href="#上边界extends-下边界super"></a> 上边界extends、下边界super</h3>
<blockquote>
<ol>
<li>为什么限制参数的范围</li>
<li>为了限制参数的写入或者写出权限</li>
</ol>
</blockquote>
<p><code>? extends T</code>代表的是泛型可以传入T和T的子类的类型上边界<br>
<code>？super T</code>代表的是传入的必须是T和T的父类类型下边界</p>
<p>Q:什么时候用上边界什么时候用下边界？——会使容器性质改变</p>
<ul>
<li>上边界: 在读取T这个类型数据的时候，但不写入数据的时候使用上边界——可以看父亲做的事， 但不能改变</li>
<li>下边界: 需要写入T这个类型数据的时候，但不获取的时候使用下边界——已经是在教儿子写数据了，他也不知道未来会是什么样子的。</li>
<li>如果既要读又要写，则不要使用通配符了， 直接传父类。</li>
</ul>
<p>请记住PECS原则：生产者（Producer）使用extends，消费者（Consumer）使用super；如果一个列表即要生产，又要消费，则不能使用泛型通配符声明列表，比如<code>List&lt;Integer&gt;</code>。</p>
<p><a href="https://www.cnblogs.com/cangqinglang/p/11626410.html" target="_blank" rel="noopener">https://www.cnblogs.com/cangqinglang/p/11626410.html</a></p>
<h2 id="messageformat"><a class="markdownIt-Anchor" href="#messageformat"></a> MessageFormat</h2>
<p>在Python中format使用起来非常方便，而Java中得使用字符串拼接或者占位符都比较麻烦，而且特别是针对占位字符串的问题更是没有好的解决方案，因此找了找Java中类似的功能：一个是String.format另一个是MessageFormat，据了解MessageFormat性能高于String.format，因此直接学MessageFormat使用。</p>
<p>函数原型为：<code>MessageFormat.format(String pattern, Object ... arguments)</code></p>
<p>MessageFormat模式，指花括号内可填写项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FormatElement:</span><br><span class="line">         &#123; ArgumentIndex &#125;：是从0开始的入参位置索引。</span><br><span class="line">         &#123; ArgumentIndex , FormatType &#125;</span><br><span class="line">         &#123; ArgumentIndex , FormatType , FormatStyle &#125;</span><br><span class="line"> </span><br><span class="line"> FormatType: ：指定使用不同的Format子类对入参进行格式化处理。值范围如下：</span><br><span class="line">         number：调用NumberFormat进行格式化</span><br><span class="line">         date：调用DateFormat进行格式化</span><br><span class="line">         time：调用DateFormat进行格式化</span><br><span class="line">         choice：调用ChoiceFormat进行格式化</span><br><span class="line"> </span><br><span class="line"> FormatStyle:：设置FormatType中使用的格式化样式。值范围如下：</span><br><span class="line">         short</span><br><span class="line">         medium</span><br><span class="line">         long</span><br><span class="line">         full</span><br><span class="line">         integer</span><br><span class="line">         currency</span><br><span class="line">         percent</span><br><span class="line">         SubformatPattern (子格式模式，形如#.##)</span><br><span class="line">         </span><br><span class="line">子模式：</span><br><span class="line">String value = MessageFormat.format(&quot;oh, &#123;0,number,#.#&#125; is good num&quot;, Double.valueOf(&quot;3.1415&quot;));</span><br><span class="line">System.out.println(value);  // 输出：oh, 3.1 is good num</span><br></pre></td></tr></table></figure>
<ul>
<li>ArgumentIndex必须是非负整数，它的个数不只限于0到9这10个，它可以用0到9的数字组成，因此可以有好多个，如：</li>
<li>格式化字符串时，两个单引号才表示一个单引号，单个单引号会被省略，除非中文单引号不会被省略。如果需要显示双引号要进行转义，比如：String msg = “oh, {0} is \”a\” pig”;</li>
<li>单引号会使其后面的占位符均失效，导致直接输出占位符。（采坑）</li>
<li>花括号的输出: <code>MessageFormat.format(&quot;oh, '{', }},''{0}'' is a pig&quot;, &quot;ZhangSan&quot;);</code>，注：右括号可以通过两个<code>}}</code>or<code>'}'</code>得到，但是左括号不行，只能通过<code>'{}'</code>得到</li>
<li>因此对于简单的格式化或字符串组装，以及若要多次格式同一个模式的字符串，那么创建一个MessageFormat实例在执行格式化操作比较好些。但要格式化处理更丰富的话要是用 String.format方法.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(MessageFormat.format(&quot;&#123;0&#125;输出结果&#123;1&#125;&quot;, traceLocation, aBoolean));</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/GarfieldEr007/article/details/89397843" target="_blank" rel="noopener">https://blog.csdn.net/GarfieldEr007/article/details/89397843</a></p>
<h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1>
<h2 id="qjava-定义long和float为什么要加l和f"><a class="markdownIt-Anchor" href="#qjava-定义long和float为什么要加l和f"></a> Q:java 定义long和float为什么要加L和F？</h2>
<p>A:整形默认值为int，如果定义long 必须要加L来区分，浮点型默认值为double双精度，定义单精度float要加F来区分。</p>
<h2 id="java中suppresswarnings的作用"><a class="markdownIt-Anchor" href="#java中suppresswarnings的作用"></a> <a href="https://www.cnblogs.com/huanglog/p/11587077.html" target="_blank" rel="noopener">Java中@SuppressWarnings的作用</a></h2>
<p>A:作用：告诉编译器忽略指定的警告，不用在编译完成后出现警告信息。如<code>@SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)</code>等同于@SuppressWarnings(“unchecked”, “deprecation”)</p>
<h2 id="输出变量类型python中type关键字"><a class="markdownIt-Anchor" href="#输出变量类型python中type关键字"></a> 输出变量类型——Python中type关键字</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Object o)</span></span>&#123;  <span class="comment">//通过反射来获取变量类型方法</span></span><br><span class="line">	<span class="keyword">return</span> o.getClass().toString(); <span class="comment">//使用int类型的getClass()方法</span></span><br><span class="line">    <span class="comment">// return o.getClass().getName(); //使用int类型的getClass()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>▲. 基本数据类型无效， 如int， 但可以查看包装数据类型。</p>
<h2 id="jdbc链接mysql"><a class="markdownIt-Anchor" href="#jdbc链接mysql"></a> JDBC链接MYSQL</h2>
<h3 id="maven的pomxml中的配置"><a class="markdownIt-Anchor" href="#maven的pomxml中的配置"></a> Maven的pom.xml中的配置</h3>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>top.nymrli.jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入mysql驱动jar包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="java文件内容"><a class="markdownIt-Anchor" href="#java文件内容"></a> java文件内容</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1.加载驱动程序， 这个包名是固定的</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">// 2.创建连接</span></span><br><span class="line">        String url=<span class="string">"jdbc:mysql://localhost:3306/fortest?useSSL=false&amp;serverTimezone=UTC"</span>;</span><br><span class="line">        String username=<span class="string">"root"</span>;</span><br><span class="line">        String userpwd=<span class="string">"cl123123"</span>;</span><br><span class="line">        Connection conn = DriverManager.getConnection(url,username,userpwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.定义SQL语句</span></span><br><span class="line">        String table = <span class="string">"stu"</span>;</span><br><span class="line"><span class="comment">//        String sql = String.format("SELECT * FROM %s;", table);</span></span><br><span class="line">        String sql = String.format(<span class="string">"UPDATE %s set age = 50 where name = 'cl';"</span>, table);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取执行sql的对象</span></span><br><span class="line">        Statement stat = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.执行SQL语句</span></span><br><span class="line"><span class="comment">//        ResultSet resultSet = stat.executeQuery(sql);</span></span><br><span class="line">        <span class="keyword">int</span> res = stat.executeUpdate(sql);</span><br><span class="line"><span class="comment">//        System.out.println(resultSet);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 查看执行结果</span></span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.释放资源</span></span><br><span class="line">        stat.close();</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DriverManager：驱动管理对象<br>
Connection：数据库连接对象<br>
statement：执行sql的对象<br>
Resultset：结果集对象<br>
Preparedstatement：执行sq1的对象roper</p>
<h2 id="sql操作"><a class="markdownIt-Anchor" href="#sql操作"></a> SQL操作</h2>
<h3 id="分页操作"><a class="markdownIt-Anchor" href="#分页操作"></a> 分页操作</h3>
<p>语法：limit开始索引，每页查询的记录数<br>
注：索引从0开始<br>
<code>公式：开始索引=（当前页码-1）*每页查询的记录数</code>即 <code>index = (nowPageNum - 1) * pageSize</code></p>
<h3 id="插入语句"><a class="markdownIt-Anchor" href="#插入语句"></a> 插入语句：</h3>
<p><code>insert into `train`.`student` (`name`, `age`) values (&quot;gb&quot;, 19);</code></p>
<p>▲注意这边是<code>`train`.`student`</code>，如果写成<code>`train.student`</code>是会找不到表的</p>
<h2 id="try-catch-finally中return"><a class="markdownIt-Anchor" href="#try-catch-finally中return"></a> try-catch-finally中return</h2>
<p>try中没有异常，则顺序为try→finally，如果try中有异常，则顺序为try→catch→finally。但是当try、catch、finally中加入return之后，那么return会变成什么样呢。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int newT()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        System.out.println(<span class="string">"error"</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;						<span class="comment">// 就算在try中执行了return 1，这边的finally也会执行，hh最终会被输出</span></span><br><span class="line">        System.out.println(<span class="string">"hh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当写catch的时候，最后需要写return 语句，如果没有catch则不需要==&gt;执行不到</span></span><br><span class="line">public int newT()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"hh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/pcheng/p/10968841.html" target="_blank" rel="noopener"><strong>总结：</strong></a></p>
<p>1、finally中的代码总会被执行。</p>
<p>2、当try、catch中有return时，也会执行finally。return的时候，要注意返回值的类型，是否受到finally中代码的影响。</p>
<p>3、finally中有return时，会直接在finally中退出，导致try、catch中的return失效。==&gt;最好不要在finally中使用return——IDEA中会报<code>请不要在finally中使用return</code></p>
<h2 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h2>
<p><strong>Q:首先得知道什么是代理？</strong></p>
<p>A:代理模式是Java常见的设计模式之一。所谓代理模式是指客户端并不直接调用实际的对象，而是通过<strong>调用代理，来间接的调用实际的对象</strong>。</p>
<blockquote>
<p>为什么要采用这种间接的形式来调用对象呢？一般是因为客户端不想直接访问实际的对象，或者访问实际的对象存在困难，因此通过一个代理对象来完成间接的访问。<br>
在现实生活中，这种情形非常的常见，比如请一个律师代理来打官司。</p>
</blockquote>
<h3 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h3>
<p>代理模式的主要角色如下。</p>
<ol>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 &lt;----外部接口主要调用对象</li>
</ol>
<p><img src="/2020/05/15/重拾Java笔记/.%5C%E9%87%8D%E6%8B%BEJava%E7%AC%94%E8%AE%B0%5C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="代理模式"></p>
<p>从UML图中，可以看出代理类与真正实现的类都是继承了抽象的主题类，这样的好处在于代理类可以与实际的类有相同的方法，可以保证客户端使用的透明性。</p>
<p><strong>代理模式实现三要素</strong></p>
<ul>
<li>有接口定义</li>
<li>目标对象与代理对象必须<u>实现统一接口</u></li>
<li>代理对象<u>持有目标对象的引用</u>增强目标对象行为</li>
</ul>
<h3 id="静态代理和动态代理"><a class="markdownIt-Anchor" href="#静态代理和动态代理"></a> 静态代理和动态代理</h3>
<blockquote>
<p>代理模式可以有两种实现的方式，一种是静态代理类，另一种是各大框架都喜欢的动态代理。</p>
</blockquote>
<h4 id="静态代理"><a class="markdownIt-Anchor" href="#静态代理"></a> 静态代理</h4>
<p>静态代理模式的特点，代理类接受一个实现了Subject接口的对象，由于任何实现该接口的对象都可以通过代理类进行代理，从而增加了通用性。但是也有缺点，每一个代理类都必须实现一遍委托类（也就是real subject）的接口，如果接口增加方法，则代理类也必须跟着修改。其次，代理类每一个接口对象对应一个委托对象，如果委托对象非常多，则静态代理类就非常臃肿，难以胜任。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonPerson</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am just a normal person"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lawyer</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person commonPerson;</span><br><span class="line">    Lawyer(Person p)&#123;</span><br><span class="line">        commonPerson = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am Lawyer"</span>);</span><br><span class="line">        commonPerson.say();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Speaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lawyer lawyer = <span class="keyword">new</span> Lawyer(<span class="keyword">new</span> CommonPerson());</span><br><span class="line">        lawyer.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态代理的缺点</strong></p>
<p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来（需要实现Subject主题接口的缺点）。</p>
<p>1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p>
<ul>
<li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong></li>
<li>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></li>
</ul>
<p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护。</strong></p>
<h4 id="动态代理-2"><a class="markdownIt-Anchor" href="#动态代理-2"></a> 动态代理</h4>
<p>动态代理有别于静态代理，是根据代理的对象，动态创建代理类。这样，就可以避免静态代理中代理类接口过多的问题。动态代理是实现方式，是通过<strong>反射来实现</strong>的，1. 可以借助Java自带的<code>java.lang.reflect.Proxy</code>,通过固定的规则生成。 2. 通过CGLli库来实现</p>
<p><strong>为什么类可以动态的生成？</strong></p>
<p>这就涉及到Java虚拟机的<strong>类加载机制</strong>了，推荐翻看《深入理解Java虚拟机》7.3节 类加载的过程。</p>
<p>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据访问入口</li>
</ol>
<p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，<strong>获取类的二进制字节流</strong>（class字节码）就有很多途径：</p>
<ul>
<li>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</li>
<li>从网络中获取，典型的应用是 Applet</li>
<li><strong>运行时计算生成</strong>，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</li>
<li>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类</li>
<li>从数据库中获取等等</li>
</ul>
<p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。</p>
<p><strong>常见的字节码操作类库</strong></p>
<blockquote>
<p>这里有一些介绍：<a href="https://link.zhihu.com/?target=https%3A//java-source.net/open-source/bytecode-libraries" target="_blank" rel="noopener">java-source.net/open-source…</a></p>
</blockquote>
<ul>
<li>Apache BCEL (Byte Code Engineering Library)：是Java classworking广泛使用的一种框架，它可以深入到JVM汇编语言进行类操作的细节。</li>
<li>ObjectWeb ASM：是一个Java字节码操作框架。它可以用于直接以二进制形式动态生成stub根类或其他代理类，或者在加载时动态修改类。</li>
<li>CGLIB(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展JAVA类并在运行时实现接口。</li>
<li>Javassist：是Java的加载时反射系统，它是一个用于在Java中编辑字节码的类库; 它使Java程序能够在运行时定义新类，并在JVM加载之前修改类文件。</li>
</ul>
<p><strong>实现动态代理的思考方向</strong></p>
<p>为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：</p>
<ol>
<li>通过实现接口的方式 -&gt; JDK动态代理</li>
<li>通过继承类的方式 -&gt; CGLIB动态代理</li>
</ol>
<p>注：使用ASM对使用者要求比较高，使用Javassist会比较麻烦。</p>
<h5 id="jdk动态代理"><a class="markdownIt-Anchor" href="#jdk动态代理"></a> JDK动态代理</h5>
<p>JDK提供的动态代理实现步骤如下：</p>
<ol>
<li>编写一个委托类的接口，即静态代理的（Subject接口）</li>
<li>实现一个真正的委托类，即静态代理的（RealSubject类）</li>
<li>创建一个<strong>动态代理类，实现<code>InvocationHandler</code>接口</strong>，并重写该<code>invoke</code>方法</li>
<li>在测试类中，生成动态代理的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am just a normal person"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynasticProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object o;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynasticProxy</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.o = o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object invoke = method.invoke(o, args);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dynastic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DynasticProxy dynastic_proxy = <span class="keyword">new</span> DynasticProxy(<span class="keyword">new</span> RealSubject());</span><br><span class="line">        Subject p =(Subject)Proxy.newProxyInstance(Dynastic.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;</span><br><span class="line">                        Subject.class</span><br><span class="line">                &#125;, dynastic_proxy);</span><br><span class="line">        p.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建动态代理的对象，需要借助<code>Proxy.newProxyInstance</code>。该方法的三个参数分别是：</p>
<ul>
<li>ClassLoader loader表示当前使用到的appClassloader。</li>
<li>Class&lt;?&gt;[] interfaces表示目标对象实现的一组接口。</li>
<li>InvocationHandler h表示当前的InvocationHandler实现实例对象。</li>
</ul>
<p>此外， 使用JDK实现的代理，还有一个问题：Proxy.newProxyInstance的参数中有一个是委托类的接口，也就是说，▲如果使用JDK实现动态代理，则必须有委托接口（本体必须实现接口），而无法针对没有接口的类。对此情况，CGlib可以解决（是JDK代理的补充，不要求本体实现接口）</p>
<h5 id="cglib动态代理"><a class="markdownIt-Anchor" href="#cglib动态代理"></a> CGLib动态代理</h5>
<p><strong>什么是CGLib</strong></p>
<p>CGLib是一个强大的、高性能的代码生成库，它可以在<strong>运行期</strong>扩展Java类与实现Java接口。Hibernate支持它来实现PO(Persistent Object 持久化对象)字节码的动态生成。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供<strong>方法拦截操作</strong>。例如Spring AOP就是他们提供方法的interception（拦截）。</p>
<p>实现步骤如下：</p>
<ol>
<li>导入CGlib库</li>
<li>定义委托类</li>
<li>创建代理类：实现一个MethodInterceptor接口，方法调用会被转发到该类重写的intercept()方法中。</li>
<li>使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"早上好"</span>+msg);</span><br><span class="line">        <span class="keyword">return</span>  msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGDynastic</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="comment">// Object为由CGLib动态生成的代理类实例, Method为上文中实体类所调用的被代理的方法引用, Object[]为参数值列表, MethodProxy为生成的代理类对方法的代理引用。 变量名可以修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这里可以插入执行关键代码之前的逻辑"</span>);</span><br><span class="line">        <span class="comment">// 调用代理类实例上的methodProxy方法的父类方法（即实体类SomeService中对应的方法）,然后返回目标方法的返回值result，然后实现增强的逻辑</span></span><br><span class="line">        Object o1 = methodProxy.invokeSuper(o, objects);<span class="comment">//关键代码:</span></span><br><span class="line">        System.out.println(<span class="string">"这里可以插入执行关键代码之后的逻辑"</span>);</span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代理类class文件存入本地磁盘方便我们反编译查看源码</span></span><br><span class="line">        <span class="comment">// System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "D:\\code");</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();  <span class="comment">// 通过CGLIB动态代理获取代理对象的过程</span></span><br><span class="line">        enhancer.setSuperclass(User.class);     <span class="comment">// 设置enhancer对象的父类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> CGDynastic());    <span class="comment">// 设置enhancer的回调对象</span></span><br><span class="line">        User user = (User) enhancer.create();   <span class="comment">// 创建代理对象</span></span><br><span class="line">        String world = user.say(<span class="string">"world"</span>);  <span class="comment">// 通过代理对象调用目标方法</span></span><br><span class="line">        System.out.println(world);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">CGDynasticInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGDynasticInterceptor</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这里可以插入执行关键代码之前的逻辑"</span>);</span><br><span class="line">        method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">"这里可以插入执行关键代码之后的逻辑"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGDynastic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CGDynasticInterceptor cgDynasticInterceptor = <span class="keyword">new</span> CGDynasticInterceptor(<span class="keyword">new</span> User());</span><br><span class="line">        User user = (User)Enhancer.create(User.class, cgDynasticInterceptor);</span><br><span class="line">        user.say(<span class="string">"good"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CGLIB 创建动态代理类的模式是：</p>
<ol>
<li>查找目标类上的所有非final 的public类型的方法定义；</li>
<li>将这些方法的定义转换成字节码；</li>
<li>将组成的字节码转换成相应的代理的class对象；</li>
<li>实现 MethodInterceptor接口，用来处理对代理类上所有方法的请求</li>
</ol>
<p>原理：</p>
<p>CGLib采用底层的字节码技术ASM, 可以为一个类创建子类, 在子类中采用方法拦截的技术拦截所有父类方法的调用, 并<strong>织入横切逻辑</strong>。(代理对象执行目标方法时会调用回调接口的方法即CGDynasticInterceptor的intercept)</p>
<img src="https://i.loli.net/2021/08/19/sxzU1b6qfHewivj.png" style="zoom:50%;">
<p>流程：我们通过<code>CGLIB</code>的<code>Enhancer</code>来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用<code>create()</code>方法得到代理对象，对这个代理对象所有<strong>非<code>final</code>方法</strong>的调用都会转发给<code>MethodInterceptor.intercept()</code>方法，在<code>intercept()</code>方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；通过调用<code>MethodProxy.invokeSuper()</code>方法，我们将调用转发给原始对象调用其具体方法。<code>CGLIG</code>中<code>MethodInterceptor</code>的作用跟JDK动态代理代理中的<code>InvocationHandler</code>很类似，都是方法调用的中转站。</p>
<h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
<p><strong>代理模式实现分类以及对应区别</strong></p>
<p>1.静态代理：<strong>手动</strong>为目标对象<strong>制作代理对象</strong>，即在程序<u>编译阶段</u>完成代理对象的创建<br>
2.动态代理：在程序<u>运行期</u><strong>动态创建目标对象对应代理对象</strong>。<br>
3.jdk动态代理：被代理目标对象必须实现某一或某一组接口实现方式通过<strong>回调</strong>创建代理对象。<br>
4.cglib动态代理：被代理目标对象可以不必实现接口，<strong>继承</strong>的方式实现。</p>
<p><strong>动态代理相比较静态代理，提高开发效率，可以批量化创建代理，提高代码复用率。</strong></p>
<p>我们学习了通过CGLIB实现动态增强，但是CGLIB也有其缺陷，那就是必须目标类必须是可以继承的，如果目标类不可继承，那么我们就无法使用CGLIB来增强该类（因为CGLib是通过继承来实现的），现在我们已经学习完了Spring AOP中两种AOP的实现机制，我们可以称JDK动态代理实现的AOP为<code>面向接口的动态增强</code>，将CGLIB实现的AOP称为<code>面向子类的动态增强</code>。</p>
<p>参考：</p>
<ul>
<li>★源代码级别解析JDK动态代理——<a href="https://www.jianshu.com/p/9bcac608c714" target="_blank" rel="noopener">深入理解Java动态代理</a></li>
<li>基于MAVEN项目的CGLib动态代理原理及实现——<a href="https://blog.csdn.net/weixin_46460843/article/details/112649900" target="_blank" rel="noopener">https://blog.csdn.net/weixin_46460843/article/details/112649900</a></li>
<li>细说Spring——AOP详解（使用CGLIB实现AOP）——<a href="https://zhuanlan.zhihu.com/p/37886319" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37886319</a></li>
</ul>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2020/05/15/重拾Java笔记/">https://nymrli.top/2020/05/15/重拾Java笔记/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2020/05/15/IDEA配置——自定义快捷键、生成注释/" title="IDEA配置——自定义快捷键、生成注释"><span>< PreviousPost</span><br><span class="prevTitle">IDEA配置——自定义快捷键、生成注释</span></a><a class="nextSlogan" href="/2020/04/29/华为春招4-29笔试题/" title="华为春招4.29笔试题"><span>NextPost ></span><br><span class="nextTitle">华为春招4.29笔试题</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '重拾Java笔记',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><a href="https://beian.miit.gov.cn/"> <span>备案号:苏ICP备18015439号</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#重拾java笔记"><span class="toc-number">1.</span> <span class="toc-text"> 重拾Java笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#命名规范"><span class="toc-number">1.1.</span> <span class="toc-text"> 命名规范:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class与文件名"><span class="toc-number">1.2.</span> <span class="toc-text"> class与文件名:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数传参"><span class="toc-number">1.3.</span> <span class="toc-text"> 函数传参:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码块的分类"><span class="toc-number">1.4.</span> <span class="toc-text"> 代码块的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行顺序"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 执行顺序:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this指针"><span class="toc-number">1.5.</span> <span class="toc-text"> this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承问题"><span class="toc-number">1.6.</span> <span class="toc-text"> 继承问题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多态"><span class="toc-number">1.7.</span> <span class="toc-text"> 多态：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重写"><span class="toc-number">1.8.</span> <span class="toc-text"> 重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super关键字"><span class="toc-number">1.9.</span> <span class="toc-text"> Super关键字:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object类之finalize方法"><span class="toc-number">1.10.</span> <span class="toc-text"> Object类之finalize方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问控制权限"><span class="toc-number">1.11.</span> <span class="toc-text"> 访问控制权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数的权限问题"><span class="toc-number">1.11.1.</span> <span class="toc-text"> 构造函数的权限问题:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final关键字"><span class="toc-number">1.12.</span> <span class="toc-text"> Final关键字:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static关键字"><span class="toc-number">1.13.</span> <span class="toc-text"> static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static的作用"><span class="toc-number">1.13.1.</span> <span class="toc-text"> static的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象类的特点"><span class="toc-number">1.14.</span> <span class="toc-text"> 抽象类的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-number">1.15.</span> <span class="toc-text"> 接口：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equals"><span class="toc-number">1.16.</span> <span class="toc-text"> equals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内部类的分类"><span class="toc-number">1.17.</span> <span class="toc-text"> 内部类的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常的分类"><span class="toc-number">1.18.</span> <span class="toc-text"> 异常的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm是如何处理异常的"><span class="toc-number">1.18.1.</span> <span class="toc-text"> JVM是如何处理异常的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw和throws"><span class="toc-number">1.18.2.</span> <span class="toc-text"> throw和throws</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义异常"><span class="toc-number">1.18.3.</span> <span class="toc-text"> 自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#catch"><span class="toc-number">1.18.4.</span> <span class="toc-text"> catch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串的不可变性"><span class="toc-number">1.19.</span> <span class="toc-text"> 字符串的不可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string类不能被继承"><span class="toc-number">1.19.1.</span> <span class="toc-text"> String类不能被继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串string的不可变性"><span class="toc-number">1.19.2.</span> <span class="toc-text"> 字符串（String）的不可变性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-stringbuffer-stringbuilder"><span class="toc-number">1.19.3.</span> <span class="toc-text"> String、StringBuffer、StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串常量池"><span class="toc-number">1.19.4.</span> <span class="toc-text"> 字符串常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-stringbuffer-stringbuilder-2"><span class="toc-number">1.20.</span> <span class="toc-text"> String、StringBuffer、StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stringbuffer"><span class="toc-number">1.20.1.</span> <span class="toc-text"> StringBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stringbuilder和stringbuffer的区别"><span class="toc-number">1.20.2.</span> <span class="toc-text"> StringBuilder和StringBuffer的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是自动拆箱和自动装箱"><span class="toc-number">1.21.</span> <span class="toc-text"> 什么是自动拆箱和自动装箱？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-number">1.22.</span> <span class="toc-text"> 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#集合的由来"><span class="toc-number">1.22.1.</span> <span class="toc-text"> 集合的由来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合类的一些特点"><span class="toc-number">1.22.2.</span> <span class="toc-text"> 集合类的一些特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区别"><span class="toc-number">1.22.3.</span> <span class="toc-text"> 区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list两个子类的特点"><span class="toc-number">1.23.</span> <span class="toc-text"> List两个子类的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist线程安全的方案"><span class="toc-number">1.23.1.</span> <span class="toc-text"> ArrayList线程安全的方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合数组的互转"><span class="toc-number">1.24.</span> <span class="toc-text"> 集合数组的互转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collection集合"><span class="toc-number">1.25.</span> <span class="toc-text"> Collection集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#set的特点"><span class="toc-number">1.25.1.</span> <span class="toc-text"> Set的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#treeset简介"><span class="toc-number">1.25.2.</span> <span class="toc-text"> TreeSet简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map接口概述"><span class="toc-number">1.25.3.</span> <span class="toc-text"> Map接口概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmap和hashtable的区别"><span class="toc-number">1.25.3.1.</span> <span class="toc-text"> HashMap和Hashtable的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collection工具"><span class="toc-number">1.25.4.</span> <span class="toc-text"> Collection工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collection总结"><span class="toc-number">1.25.5.</span> <span class="toc-text"> Collection总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashcode"><span class="toc-number">1.26.</span> <span class="toc-text"> HashCode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashcode方法的作用"><span class="toc-number">1.26.1.</span> <span class="toc-text"> HashCode方法的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何重写hashcode"><span class="toc-number">1.26.2.</span> <span class="toc-text"> 如何重写HashCode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于重写hashcode方法的一些说明"><span class="toc-number">1.26.3.</span> <span class="toc-text"> 关于重写HashCode方法的一些说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#properties类"><span class="toc-number">1.27.</span> <span class="toc-text"> Properties类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型的概念"><span class="toc-number">1.28.</span> <span class="toc-text"> 泛型的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型的优点"><span class="toc-number">1.28.1.</span> <span class="toc-text"> 泛型的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义泛型"><span class="toc-number">1.28.2.</span> <span class="toc-text"> 自定义泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型通配符"><span class="toc-number">1.28.3.</span> <span class="toc-text"> 泛型通配符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合框架中的三种迭代方式删除数据"><span class="toc-number">1.29.</span> <span class="toc-text"> 集合框架中的三种迭代方式删除数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可变参数"><span class="toc-number">1.30.</span> <span class="toc-text"> 可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注解"><span class="toc-number">1.31.</span> <span class="toc-text"> 注解:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io流"><span class="toc-number">1.32.</span> <span class="toc-text"> IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用fileseparator解决不同系统的路径问题"><span class="toc-number">1.32.1.</span> <span class="toc-text"> 使用File.separator解决不同系统的路径问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件io读写fileinputstream"><span class="toc-number">1.32.2.</span> <span class="toc-text"> 文件IO读写FileInputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用缓冲流进行文件拷贝bufferedinputstream"><span class="toc-number">1.32.3.</span> <span class="toc-text"> 使用缓冲流进行文件拷贝BufferedInputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk7的新写法"><span class="toc-number">1.32.4.</span> <span class="toc-text"> jdk7的新写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用字符流解决乱码问题filereader"><span class="toc-number">1.33.</span> <span class="toc-text"> 使用字符流解决乱码问题FileReader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用缓冲流bufferedreader可以一次读取一行的文字"><span class="toc-number">1.33.1.</span> <span class="toc-text"> 使用缓冲流BufferedReader可以一次读取一行的文字：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换流"><span class="toc-number">1.33.2.</span> <span class="toc-text"> 转换流——编码格式转换InputStreamReader：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输出指定目录下的所有文件名称"><span class="toc-number">1.34.</span> <span class="toc-text"> 输出指定目录下的所有文件名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#序列化和反序列化"><span class="toc-number">1.35.</span> <span class="toc-text"> 序列化和反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transient关键字"><span class="toc-number">1.35.1.</span> <span class="toc-text"> transient关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">1.36.</span> <span class="toc-text"> 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#三种创建方式"><span class="toc-number">1.36.1.</span> <span class="toc-text"> 三种创建方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-number">1.36.2.</span> <span class="toc-text"> 线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized同步方法与同步代码块"><span class="toc-number">1.37.</span> <span class="toc-text"> synchronized同步方法与同步代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式"><span class="toc-number">1.38.</span> <span class="toc-text"> 单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#饿汉式"><span class="toc-number">1.38.1.</span> <span class="toc-text"> 饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#懒汉式"><span class="toc-number">1.38.2.</span> <span class="toc-text"> 懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式的案例runtime"><span class="toc-number">1.38.3.</span> <span class="toc-text"> 单例模式的案例Runtime</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用timer类来实现定时任务"><span class="toc-number">1.39.</span> <span class="toc-text"> 使用Timer类来实现定时任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda表达式和匿名内部类"><span class="toc-number">1.40.</span> <span class="toc-text"> Lambda表达式和匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射"><span class="toc-number">1.41.</span> <span class="toc-text"> 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#class对象功能"><span class="toc-number">1.41.1.</span> <span class="toc-text"> Class对象功能:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例"><span class="toc-number">1.41.2.</span> <span class="toc-text"> 案例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的加载与初始化"><span class="toc-number">1.42.</span> <span class="toc-text"> 类的加载与初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类加载器classloader"><span class="toc-number">1.42.0.1.</span> <span class="toc-text"> 类加载器（ClassLoader）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#classgetresource和classloadergetresource的区别"><span class="toc-number">1.42.1.</span> <span class="toc-text"> Class.getResource和ClassLoader.getResource的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正则匹配"><span class="toc-number">1.43.</span> <span class="toc-text"> 正则匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java泛型体系"><span class="toc-number">1.44.</span> <span class="toc-text"> Java泛型体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通配符"><span class="toc-number">1.44.1.</span> <span class="toc-text"> 通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上边界extends-下边界super"><span class="toc-number">1.44.2.</span> <span class="toc-text"> 上边界extends、下边界super</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#messageformat"><span class="toc-number">1.45.</span> <span class="toc-text"> MessageFormat</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附录"><span class="toc-number">2.</span> <span class="toc-text"> 附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#qjava-定义long和float为什么要加l和f"><span class="toc-number">2.1.</span> <span class="toc-text"> Q:java 定义long和float为什么要加L和F？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java中suppresswarnings的作用"><span class="toc-number">2.2.</span> <span class="toc-text"> Java中@SuppressWarnings的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输出变量类型python中type关键字"><span class="toc-number">2.3.</span> <span class="toc-text"> 输出变量类型——Python中type关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdbc链接mysql"><span class="toc-number">2.4.</span> <span class="toc-text"> JDBC链接MYSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#maven的pomxml中的配置"><span class="toc-number">2.4.1.</span> <span class="toc-text"> Maven的pom.xml中的配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java文件内容"><span class="toc-number">2.4.2.</span> <span class="toc-text"> java文件内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql操作"><span class="toc-number">2.5.</span> <span class="toc-text"> SQL操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分页操作"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 分页操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入语句"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 插入语句：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-catch-finally中return"><span class="toc-number">2.6.</span> <span class="toc-text"> try-catch-finally中return</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态代理"><span class="toc-number">2.7.</span> <span class="toc-text"> 动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代理模式"><span class="toc-number">2.7.1.</span> <span class="toc-text"> 代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态代理和动态代理"><span class="toc-number">2.7.2.</span> <span class="toc-text"> 静态代理和动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#静态代理"><span class="toc-number">2.7.2.1.</span> <span class="toc-text"> 静态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态代理-2"><span class="toc-number">2.7.2.2.</span> <span class="toc-text"> 动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#jdk动态代理"><span class="toc-number">2.7.2.2.1.</span> <span class="toc-text"> JDK动态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cglib动态代理"><span class="toc-number">2.7.2.2.2.</span> <span class="toc-text"> CGLib动态代理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">2.7.2.3.</span> <span class="toc-text"> 总结</span></a></li></ol></li></ol></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>