<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>toy reimplementation of an event loop in Python[翻译] · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">toy reimplementation of an event loop in Python[翻译]</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2022/05/09</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Python"> Python</a><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="翻译"> 翻译</a><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="并发"> 并发</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">6,277</span> | Reading time: <span class="post-count">31</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="事件循环的一个小故事"><a class="markdownIt-Anchor" href="#事件循环的一个小故事"></a> 事件循环的一个小故事</h1>
<blockquote>
<p>Translated from: <a href="https://github.com/AndreLouisCaron/a-tale-of-event-loops" target="_blank" rel="noopener">https://github.com/AndreLouisCaron/a-tale-of-event-loops</a></p>
</blockquote>
<p>我最近被伯克利大学的研究员Nathaniel J. Smith关于 <a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="noopener">asyncio</a> 的惊人见解所困。他的文章《关于后async/await世界中异步API设计的一些想法》( <a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/" target="_blank" rel="noopener">Some thoughts on asynchronous API design in a post-async/await world</a>) 使得我 在最近大量使用asyncio后，对它有了一些（略）复杂的感受。</p>
<p>虽然这或多或少是他文章的重点，但他认为 <a href="https://github.com/dabeaz/curio" target="_blank" rel="noopener">curio</a> 的实现比asyncio简单得多，因为它预先假定你有一个实现<a href="https://www.python.org/dev/peps/pep-0492/" target="_blank" rel="noopener">PEP 492</a>（<code>async</code>和<code>await</code>关键字）的Python版本。</p>
<p>我很感兴趣，看了一下curio的源代码，…由于它获得了很多功能（有希望使它更接近于一个可生产的库），我认为它现在已经拥有足够的功能，主要的本质已经被淡化。这绝对不是一件坏事，但如果是像我一样，想了解Nathaniel在说什么，并学习一些整洁的Python技巧的话，阅读curio的源代码几乎不是一个好的起点。</p>
<p>Python核心开发人员Brett Cannon在他的帖子《<a href="http://www.snarky.ca/how-the-heck-does-async-await-work-in-python-3-5" target="_blank" rel="noopener">How the heck does async/await work in Python 3.5?</a>》中提供了一些关于如何使用协程对象（例如，如果你正在实现事件循环）非常好的见解，他的重点是实现细节，至少对我来说，要摸清coroutine还是缺少一小块。</p>
<p>TL; DR: 这是我试图抓住curio所基于的核心基本原理的尝试。希望它能成为熟悉curio源代码的一个好的垫脚石。</p>
<p>让我们开始吧 😃</p>
<h2 id="协程的本质"><a class="markdownIt-Anchor" href="#协程的本质"></a> 协程的本质</h2>
<p>首先，让我们来看看当调用一个协程时会发生什么。</p>
<p><strong>提示</strong>：你得到一个 “coroutine对象”，它有一个<code>.send()</code>和一个<code>.throw()</code>方法，就像生成器对象那样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro = hello(<span class="string">'world'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(coro)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">coroutine</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(coro.send)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">builtin_function_or_method</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(coro.throw)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">builtin_function_or_method</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br><span class="line"><span class="class">...</span></span><br></pre></td></tr></table></figure>
<p>当然，你通常不会使用这些方法，因为它们隐藏在<code>await coro</code>和<code>asyncio.get_event_loop().run_until_complete()</code>后面，但既然我们想研究它的工作原理… 😃</p>
<p>请注意，上面的代码从来没有打印过我们的 <code>&quot;Hello, world!&quot;</code>信息。这是因为我们从未在coroutine函数中实际执行过语句——我们只是创建了coroutine对象。事实上，如果你在解释器中实际运行这段代码，你会得到一个警告，说明我们的hello coroutine从未完成。</p>
<p>如果你想执行coroutine函数，你需要以某种方式安排它。为了做到这一点，我们将调用<code>.send()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>task = hello(<span class="string">'world'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    task.send(<span class="keyword">None</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> StopIteration:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<p>就像生成器对象一样，一个协程对象的<code>.send()</code>方法在协程结束时引发<code>StopIteration</code>事件。</p>
<p>我们将在后面看到，我们可以使用.send()方法在第二次、第三次或第N次调用<code>.send()</code>方法重新开始时将信息传递给coroutine。</p>
<p>如果该循环程序没有正常返回，而是出现了异常，那么该异常将通过<code>.send()</code>传播回来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">HelloException</span><span class="params">(Exception)</span>:</span></span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>       self._name = name</span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>       <span class="keyword">return</span> <span class="string">'Hello, %s!'</span> % (self._name,)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> HelloException(name)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>task = hello(<span class="string">'world'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    task.send(<span class="keyword">None</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> Exception <span class="keyword">as</span> error:</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: exception will be propagated here!</span></span><br><span class="line"><span class="meta">... </span>    print(error)</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<p>我还提到了一个<code>.throw()</code>方法。和<code>.send()</code>一样，它恢复了协程，但它不是传递一个值，而是在协程中的暂停点引发一个异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(Exception)</span>:</span></span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>       self._name = name</span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>       <span class="keyword">return</span> <span class="string">'Hello, %s!'</span> % (self._name,)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>task = hello()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: inject exception.</span></span><br><span class="line"><span class="meta">... </span>    task.throw(Hello(<span class="string">'world'</span>))</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> Exception <span class="keyword">as</span> error:</span><br><span class="line"><span class="meta">... </span>    print(error)</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<p>在这一点上，你应该对这样一个事实感到满意：coroutine 对象与生成器对象非常非常相似，后者从 Python 2.2 (<a href="https://www.python.org/dev/peps/pep-0255/" target="_blank" rel="noopener">PEP 255</a>) 开始就存在，并且从 Python 2.5 (<a href="https://www.python.org/dev/peps/pep-0342/" target="_blank" rel="noopener">PEP 342</a>) 开始就有 <code>.send()</code>和 <code>.throw()</code>方法。</p>
<h2 id="与事件循环的对话"><a class="markdownIt-Anchor" href="#与事件循环的对话"></a> 与事件循环的对话</h2>
<p>如果你仔细观察（或尝试），你会发现，与生成器函数相反，coroutine函数不能使用<code>yield</code>表达式。这就提出了（而不是 <a href="http://grammarist.com/usage/begging-the-question-usage/" target="_blank" rel="noopener">begs</a>）一个问题：到底怎样才能让coroutine函数将控制权交还给调用<code>.send()</code>的代码？</p>
<p>答案是在一个<em>awaitalbe</em>对象上使用<code>await</code>。对于一个对象来说，它必须实现特殊的<code>__await__()</code>方法，以返回一个iterable对象。在实践中，这有点尴尬，所以在标准库中有一个<code>@types.coroutine</code>装饰器，允许你以一种类似<code>@contextlib.contextmanager</code>的风格来创建awaitable对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: this is an awaitable object!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">nice</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: this makes ``.send()`` return!</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> nice()</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>task = hello(<span class="string">'world'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: call send twice!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>task.send(<span class="keyword">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    task.send(<span class="keyword">None</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> StopIteration:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<p>当然，我们的<code>nice()</code>对象是非常无用的。别着急，我们很快就会做一些更有用的事情。</p>
<h2 id="looping"><a class="markdownIt-Anchor" href="#looping"></a> Looping</h2>
<p>我们前面的例子正好调用<code>.send()</code>两次，因为它知道<code>hello()</code>只产生一次控制。当我们不知道时（常见的情况），我们需要把它放在一个循环中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">nice</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: yield many times!</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">await</span> nice()</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>task = hello(<span class="string">'world'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: loop!</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="meta">... </span>        task.send(<span class="keyword">None</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> StopIteration:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<p>我们逐渐开始得到了一些最简单的实现，其类似于<code>asyncio.get_event_loop().run_until_complete()</code>。所以我们让它在语法上更加相似。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">nice</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">await</span> nice()</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: now a reusable function!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(task)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="meta">... </span>            task.send(<span class="keyword">None</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: call it as a function!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_until_complete(hello(<span class="string">'world'</span>))</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<h2 id="生成子任务"><a class="markdownIt-Anchor" href="#生成子任务"></a> 生成子任务</h2>
<p>现在我们已经有了一个可以完成单个任务的事件循环，我们可能想开始做一些有用的事情。我们期望做许多不同的事情，但由于这是关于并发的，让我们从允许创建子任务开始。</p>
<p>我们在这里需要做的主要事情是引入一个新的原语<code>spawn()</code>，用于安排新的子任务。一旦任务被安排好，我们要把控制权返回给父任务，这样它就可以继续前进了。</p>
<p><strong>注意</strong>：这个例子是故意不完整的。我们以后会看到如何join任务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> iscoroutine</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: awaitable object that sends a request to launch a child task!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">spawn</span><span class="params">(task)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> task</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> nice()</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: parent task!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>     <span class="comment"># NEW: create a child task!</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> spawn(hello(<span class="string">'world'</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(task)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: schedule the "root" task.</span></span><br><span class="line"><span class="meta">... </span>    tasks = [(task, <span class="keyword">None</span>)]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> tasks:</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># NEW: round-robin between a set tasks (we may now have more</span></span><br><span class="line"><span class="meta">... </span>        <span class="comment">#      than one and we'd like to be as "fair" as possible).</span></span><br><span class="line"><span class="meta">... </span>        queue, tasks = tasks, []</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> task, data <span class="keyword">in</span> queue:</span><br><span class="line"><span class="meta">... </span>            <span class="comment"># NEW: resume the task *once*.</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>                data = task.send(data)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">except</span> StopIteration:</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">except</span> Exception <span class="keyword">as</span> error:</span><br><span class="line"><span class="meta">... </span>                <span class="comment"># NEW: prevent crashed task from ending the loop.</span></span><br><span class="line"><span class="meta">... </span>                print(error)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>                <span class="comment"># NEW: schedule the child task.</span></span><br><span class="line"><span class="meta">... </span>                <span class="keyword">if</span> iscoroutine(data):</span><br><span class="line"><span class="meta">... </span>                    tasks.append((data, <span class="keyword">None</span>))</span><br><span class="line"><span class="meta">... </span>                <span class="comment"># NEW: reschedule the parent task.</span></span><br><span class="line"><span class="meta">... </span>                tasks.append((task, <span class="keyword">None</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_until_complete(main())</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<p><strong>哇</strong>! 这比我们之前版本的<code>run_until_complete()</code>要复杂得多。这些都是怎么来的？</p>
<p>好吧…现在我们可以运行多个任务了，我们需要担心的事情包括:</p>
<ol>
<li>等待所有的子任务完成（递归），尽管任何任务都有错误</li>
<li>在任务之间交替进行，让所有的任务同时完成</li>
</ol>
<p>注意，我们现在有一个嵌套循环。</p>
<ul>
<li>外循环负责检查我们是否完成了任务</li>
<li>内循环负责处理一次调度器的 “tick”（倒计时完成）。</li>
</ul>
<p>还有其他方法可以做到这一点，而且我们为什么要这样做可能不是很明显，但这很重要，因为事件循环中还缺少两个关键部分：定时器和I/O。当我们以后增加对这些的支持时，我们也需要以一种 &quot;公平 &quot;的方式来安排内部检查。外循环为我们提供了一个检查计时器和轮询I/O操作状态的方便位置。</p>
<ol>
<li>检查定时器，恢复已经过了延迟期的睡眠任务。</li>
<li>检查I/O操作，安排那些待定I/O操作已经完成的任务。</li>
<li>执行一次调度器的&quot;tick&quot;，以恢复我们刚刚调度的所有任务。</li>
</ol>
<p>简而言之，这就是基于coroutine的调度器循环的要点。</p>
<p><strong>然而</strong>，在我们进入更复杂的定时器和I/O之前…还记得我在前面提到这个例子是故意不完整的吗？我们知道如何生成新的子任务，但我们还不知道如何等待它们完成。这是一个很好的机会来学习如何扩展，由我们的awaitable对象发送事件循环 &quot;请求&quot;的词汇表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">nice</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">spawn</span><span class="params">(task)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: recover the child task handle to pass it back to the parent.</span></span><br><span class="line"><span class="meta">... </span>    child = <span class="keyword">yield</span> (<span class="string">'spawn'</span>, task)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> child</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: awaitable object that sends a request to be notified when a</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#      concurrent task completes.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(task)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> (<span class="string">'join'</span>, task)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> nice()</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: recover the child task handle.</span></span><br><span class="line"><span class="meta">... </span>    child = <span class="keyword">await</span> spawn(hello(<span class="string">'world'</span>))</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: wait for the child task to complete.</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> join(child)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'(after join)'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(task)</span>:</span></span><br><span class="line"><span class="meta">... </span>    tasks = [(task, <span class="keyword">None</span>)]</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: keep track of tasks to resume when a task completes.</span></span><br><span class="line"><span class="meta">... </span>    watch = defaultdict(list)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> tasks:</span><br><span class="line"><span class="meta">... </span>        queue, tasks = tasks, []</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> task, data <span class="keyword">in</span> queue:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>                data = task.send(data)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">except</span> StopIteration:</span><br><span class="line"><span class="meta">... </span>                <span class="comment"># NEW: wait up tasks waiting on this one.</span></span><br><span class="line"><span class="meta">... </span>                tasks.extend((t, <span class="keyword">None</span>) <span class="keyword">for</span> t <span class="keyword">in</span> watch.pop(task, []))</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>                <span class="comment"># NEW: dispatch request sent by awaitable object since</span></span><br><span class="line"><span class="meta">... </span>                <span class="comment">#      we now have 3 different types of requests.</span></span><br><span class="line"><span class="meta">... </span>                <span class="keyword">if</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">'spawn'</span>:</span><br><span class="line"><span class="meta">... </span>                    tasks.append((data[<span class="number">1</span>], <span class="keyword">None</span>))</span><br><span class="line"><span class="meta">... </span>                    tasks.append((task, data[<span class="number">1</span>]))</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">elif</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">'join'</span>:</span><br><span class="line"><span class="meta">... </span>                    watch[data[<span class="number">1</span>]].append(task)</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>                    tasks.append((task, <span class="keyword">None</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_until_complete(main())</span><br><span class="line">Hello, world!</span><br><span class="line">(after join)</span><br></pre></td></tr></table></figure>
<p>由于实际原因，我们可能希望有某种Task包装器用于coroutine对象。这对于暴露cancle的API和处理一些竞争情况是很方便的，比如子任务在父任务试图<code>join()</code>它之前就结束了（你能发现这个bug吗？）</p>
<p>将子任务的返回值作为<code>await join()</code> 的结果传回，并传播使子任务崩溃的异常，这些都是留给读者的练习。</p>
<h2 id="sleeping-timers"><a class="markdownIt-Anchor" href="#sleeping-timers"></a> Sleeping &amp; timers</h2>
<p>现在我们已经控制了任务调度，我们可以开始处理一些更高级的东西，比如定时器和I/O。I/O是最终的目标，但它牵涉到很多新的东西，所以我们先看看定时器。</p>
<p>如果你需要休眠Sleep，你不能只调用<code>time.sleep()</code>，因为你会阻塞所有的任务，而不仅仅是你想暂停的那个。</p>
<p>你现在可能已经发现了这个模式。我们将添加两样东西。</p>
<ol>
<li>一种新的请求类型</li>
<li>一段基于<code>task.send()</code>返回值的调度代码。</li>
</ol>
<p>我们还将添加一些bookKeeping以跟踪那些被暂停的任务。请记住，tasks是一个预定在下一个tick中运行的coroutine列表，但沉睡的任务在准备再次运行之前可能会跳过一个或多个tick。</p>
<p>请记住，休眠的任务不太可能按照先进先出的顺序重新安排，所以我们需要一些更进化的东西。维护计时器，最实用的方法（直到你允许取消它们）是使用一个优先级队列，感谢标准库的 <a href="https://docs.python.org/3.5/library/heapq.html" target="_blank" rel="noopener">heapq</a> 模块使之超级简单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> heapq <span class="keyword">import</span> heappop, heappush</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> time <span class="keyword">import</span> sleep <span class="keyword">as</span> _sleep</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> default_timer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: we need to keep track of elapsed time.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clock = default_timer</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: request that the event loop reschedule us "later".</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(seconds)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> (<span class="string">'sleep'</span>, seconds)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: verify elapsed time matches our request.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    ref = clock()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> sleep(<span class="number">3.0</span>)</span><br><span class="line"><span class="meta">... </span>    now = clock()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">assert</span> (now - ref) &gt;= <span class="number">3.0</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(task)</span>:</span></span><br><span class="line"><span class="meta">... </span>    tasks = [(task, <span class="keyword">None</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: keep track of tasks that are sleeping.</span></span><br><span class="line"><span class="meta">... </span>    timers = []</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: watch out, all tasks might be suspended at the same time.</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> tasks <span class="keyword">or</span> timers:</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># NEW: if we have nothing to do for now, don't spin.</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> <span class="keyword">not</span> tasks:</span><br><span class="line"><span class="meta">... </span>            _sleep(max(<span class="number">0.0</span>, timers[<span class="number">0</span>][<span class="number">0</span>] - clock()))</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># NEW: schedule tasks when their timer has elapsed.</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">while</span> timers <span class="keyword">and</span> timers[<span class="number">0</span>][<span class="number">0</span>] &lt; clock():</span><br><span class="line"><span class="meta">... </span>            _, task = heappop(timers)</span><br><span class="line"><span class="meta">... </span>            tasks.append((task, <span class="keyword">None</span>))</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>        queue, tasks = tasks, []</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> task, data <span class="keyword">in</span> queue:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>                data = task.send(data)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">except</span> StopIteration:</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>                <span class="comment"># NEW: set a timer and don't reschedule right away.</span></span><br><span class="line"><span class="meta">... </span>                <span class="keyword">if</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">'sleep'</span>:</span><br><span class="line"><span class="meta">... </span>                    heappush(timers, (clock() + data[<span class="number">1</span>], task))</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>                    tasks.append((task, <span class="keyword">None</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_until_complete(hello(<span class="string">'world'</span>))</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<p>哇，我们真的掌握了这个窍门! 也许这个异步的东西毕竟没有那么难？</p>
<p>让我们看看我们能为I/O做什么!</p>
<h2 id="处理io"><a class="markdownIt-Anchor" href="#处理io"></a> 处理I/O</h2>
<p>现在我们已经经历了所有其他的事情，是时候进行终极对决了：I/O。</p>
<p>可伸缩的 I/O 通常使用native C的APIs 来实现 I/O 的复用。通常，这是 I/O 库中最困难的部分，但值得庆幸的是，Python 的 <a href="https://docs.python.org/3/library/selectors.html" target="_blank" rel="noopener">selectors</a> 模块使其非常容易实现。</p>
<p>至于到目前为止我们添加的所有其他操作，我们将在事件循环中添加一些新的I/O请求和相应的请求处理程序。另外，像计时器一样，我们需要在每个调度器的开始阶段做一些内部检查。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> selectors <span class="keyword">import</span> (</span><br><span class="line"><span class="meta">... </span>    DefaultSelector,</span><br><span class="line"><span class="meta">... </span>    EVENT_READ,</span><br><span class="line"><span class="meta">... </span>    EVENT_WRITE,</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> socket <span class="keyword">import</span> socketpair <span class="keyword">as</span> _socketpair</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: request that the event loop tell us when we can read.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">recv</span><span class="params">(stream, size)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> (EVENT_READ, stream)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> stream.recv(size)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: request that the event loop tell us when we can write.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(stream, data)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> data:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> (EVENT_WRITE, stream)</span><br><span class="line"><span class="meta">... </span>        size = stream.send(data)</span><br><span class="line"><span class="meta">... </span>        data = data[size:]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: connect sockets, make sure they never, ever block the loop.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">socketpair</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    lhs, rhs = _socketpair()</span><br><span class="line"><span class="meta">... </span>    lhs.setblocking(<span class="keyword">False</span>)</span><br><span class="line"><span class="meta">... </span>    rhs.setblocking(<span class="keyword">False</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> lhs, rhs</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: send a message through the socket pair.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    lhs, rhs = <span class="keyword">await</span> socketpair()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> send(lhs, <span class="string">'Hello, world!'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="meta">... </span>    data = <span class="keyword">await</span> recv(rhs, <span class="number">1024</span>)</span><br><span class="line"><span class="meta">... </span>    print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="meta">... </span>    lhs.close()</span><br><span class="line"><span class="meta">... </span>    rhs.close()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(task)</span>:</span></span><br><span class="line"><span class="meta">... </span>    tasks = [(task, <span class="keyword">None</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: prepare for I/O multiplexing.</span></span><br><span class="line"><span class="meta">... </span>    selector = DefaultSelector()</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: watch out, all tasks might be suspended at the same time.</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> tasks <span class="keyword">or</span> selector.get_map():</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># NEW: poll I/O operation status and resume tasks when ready.</span></span><br><span class="line"><span class="meta">... </span>        timeout = <span class="number">0.0</span> <span class="keyword">if</span> tasks <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> key, events <span class="keyword">in</span> selector.select(timeout):</span><br><span class="line"><span class="meta">... </span>            tasks.append((key.data, <span class="keyword">None</span>))</span><br><span class="line"><span class="meta">... </span>            selector.unregister(key.fileobj)</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>        queue, tasks = tasks, []</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> task, data <span class="keyword">in</span> queue:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>                data = task.send(data)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">except</span> StopIteration:</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>                <span class="comment"># NEW: register for I/O and suspend the task.</span></span><br><span class="line"><span class="meta">... </span>                <span class="keyword">if</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == EVENT_READ:</span><br><span class="line"><span class="meta">... </span>                    selector.register(data[<span class="number">1</span>], EVENT_READ, task)</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">elif</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == EVENT_WRITE:</span><br><span class="line"><span class="meta">... </span>                    selector.register(data[<span class="number">1</span>], EVENT_WRITE, task)</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>                    tasks.append((task, <span class="keyword">None</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_until_complete(hello(<span class="string">'world'</span>))</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<h2 id="取消任务"><a class="markdownIt-Anchor" href="#取消任务"></a> 取消任务</h2>
<p>最后，但也是最重要的一块拼图是——取消任务，这就是我们利用coroutine对象的<code>.throw()</code>方法的地方。</p>
<p>由于取消任务有一个竞争条件（它可能与尝试取消任务同时完成），所以需要跟踪所有正在运行的任务，以了解它们的 “状态”。</p>
<p>否则，它就是任务生成和加入的简单扩展。</p>
<p><strong>注意</strong>：这个实现是故意不完整的。它没有正确处理取消一个已经安排在下一个tick中运行的任务的可能性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> iscoroutine</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">spawn</span><span class="params">(task)</span>:</span></span><br><span class="line"><span class="meta">... </span>    task = <span class="keyword">yield</span> (<span class="string">'spawn'</span>, task)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> task</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(task)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> (<span class="string">'join'</span>, task)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: exception to be raised inside tasks when they are cancelled.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">CancelledError</span><span class="params">(Exception)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: request that CancelledError be raised inside the task.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">cancel</span><span class="params">(task)</span>:</span></span><br><span class="line"><span class="meta">... </span>    cancelled = <span class="keyword">yield</span> (<span class="string">'cancel'</span>, task, CancelledError())</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">assert</span> cancelled <span class="keyword">is</span> <span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: pause the task without plans to reschedule it (this is simply to</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#      guarantee execution order in this demo).</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@coroutine</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">suspend</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> (<span class="string">'suspend'</span>,)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">await</span> suspend()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> CancelledError:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">raise</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># NEW: spawn a task and then cancel it.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    child = <span class="keyword">await</span> spawn(hello(<span class="string">'world'</span>))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> cancel(child)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> join(child)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(task)</span>:</span></span><br><span class="line"><span class="meta">... </span>    tasks = [(task, <span class="keyword">None</span>)]</span><br><span class="line"><span class="meta">... </span>    watch = defaultdict(list)</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># NEW: keep track of all tasks in the tree.</span></span><br><span class="line"><span class="meta">... </span>    tree = &#123;task&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> tasks:</span><br><span class="line"><span class="meta">... </span>        queue, tasks = tasks, []</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> task, data <span class="keyword">in</span> queue:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>                <span class="comment"># NEW: we may need to pass data or inject an exception.</span></span><br><span class="line"><span class="meta">... </span>                <span class="keyword">if</span> isinstance(data, Exception):</span><br><span class="line"><span class="meta">... </span>                    data = task.throw(data)</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>                    data = task.send(data)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">except</span> (StopIteration, CancelledError):</span><br><span class="line"><span class="meta">... </span>                tasks.extend((t, <span class="keyword">None</span>) <span class="keyword">for</span> t <span class="keyword">in</span> watch.pop(task, []))</span><br><span class="line"><span class="meta">... </span>                <span class="comment"># NEW: update bookkeeping.</span></span><br><span class="line"><span class="meta">... </span>                tree.discard(task)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">if</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">'spawn'</span>:</span><br><span class="line"><span class="meta">... </span>                    tasks.append((data[<span class="number">1</span>], <span class="keyword">None</span>))</span><br><span class="line"><span class="meta">... </span>                    tasks.append((task, data[<span class="number">1</span>]))</span><br><span class="line"><span class="meta">... </span>                    <span class="comment"># NEW: update bookkeeping.</span></span><br><span class="line"><span class="meta">... </span>                    tree.add(data[<span class="number">1</span>])</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">elif</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">'join'</span>:</span><br><span class="line"><span class="meta">... </span>                    watch[data[<span class="number">1</span>]].append(task)</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">elif</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">'cancel'</span>:</span><br><span class="line"><span class="meta">... </span>                    <span class="comment"># NEW: schedule to raise the exception in the task.</span></span><br><span class="line"><span class="meta">... </span>                    <span class="keyword">if</span> data[<span class="number">1</span>] <span class="keyword">in</span> tree:</span><br><span class="line"><span class="meta">... </span>                        tasks.append((data[<span class="number">1</span>], data[<span class="number">2</span>]))</span><br><span class="line"><span class="meta">... </span>                        tasks.append((task, <span class="keyword">True</span>))</span><br><span class="line"><span class="meta">... </span>                    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>                        tasks.append((task, <span class="keyword">False</span>))</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">elif</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">'suspend'</span>:</span><br><span class="line"><span class="meta">... </span>                    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>                <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>                    tasks.append((task, <span class="keyword">None</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_until_complete(main())</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<h2 id="许可证"><a class="markdownIt-Anchor" href="#许可证"></a> 许可证</h2>
<p>本文件的版权归Andre Caron <a href="mailto:andre.l.caron@gmail.com" target="_blank" rel="noopener">andre.l.caron@gmail.com</a>所有，并在知识共享 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode" target="_blank" rel="noopener">CC-BY-SA</a>  许可下向您提供。</p>
<h1 id="个人收获"><a class="markdownIt-Anchor" href="#个人收获"></a> 个人收获</h1>
<p>一个异步框架通常主要包括事件循环、<a href="https://www.zhihu.com/search?q=%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A555273313%7D" target="_blank" rel="noopener">事件队列</a>、polling、timer队列，所有的异步框架皆不例外，asyncio也是如此。本文的toy event loop也是如此，在自己实现的时候就是关注这几个部分。</p>
<p>文中的实验都表明了，协程的<code>send()</code>、<code>throw()</code>、<code>await</code>与<code>send()</code>、<code>throw()</code>、<code>yield</code>使用都类似。</p>
<h1 id="个人实验"><a class="markdownIt-Anchor" href="#个人实验"></a> 个人实验</h1>
<p>针对<a href="#%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%AF%B9%E8%AF%9D">与事件循环的对话</a>的实验代码，我又增加了一些内容看效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># NEW: this is an awaitable object!</span></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nice</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'before yield'</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    print(<span class="string">"after yield"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># NEW: this makes ``.send()`` return!</span></span><br><span class="line">    <span class="keyword">await</span> nice()</span><br><span class="line">    print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task = hello(<span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># NEW: call send twice!</span></span><br><span class="line">task.send(<span class="keyword">None</span>)</span><br><span class="line">print(<span class="string">"after first sned"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    task.send(<span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">before yield</span></span><br><span class="line"><span class="string">after first sned</span></span><br><span class="line"><span class="string">after yield</span></span><br><span class="line"><span class="string">Hello, world!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>通过输出我们可以发现， <code>task.send()</code>会在<code>nice()</code>的<code>yield</code>处停下来。<code>@coroutine</code>的注解，让<code>nice()</code>函数成为了awaitalbe对象，从而可以<code>await nice()</code>调用。</p>
<p>针对<a href="#%E7%94%9F%E6%88%90%E5%AD%90%E4%BB%BB%E5%8A%A1">生成子任务</a>，发现main协程结束的比hello协程早。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> iscoroutine</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nice</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"before nice"</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    print(<span class="string">"after nice"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># NEW: awaitable object that sends a request to launch a child task!</span></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spawn</span><span class="params">(task)</span>:</span></span><br><span class="line">    print(<span class="string">"before spawn"</span>)</span><br><span class="line">    <span class="keyword">yield</span> task</span><br><span class="line">    print(<span class="string">"after spawn"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"hello: before await"</span>)</span><br><span class="line">    <span class="keyword">await</span> nice()</span><br><span class="line">    print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># NEW: parent task!</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"main: before"</span>)</span><br><span class="line">    <span class="comment"># NEW: create a child task!</span></span><br><span class="line">    <span class="keyword">await</span> spawn(hello(<span class="string">'world'</span>))</span><br><span class="line">    print(<span class="string">"main: after"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(task)</span>:</span></span><br><span class="line">    <span class="comment"># NEW: schedule the "root" task.</span></span><br><span class="line">    tasks = [(task, <span class="keyword">None</span>)]</span><br><span class="line">    <span class="keyword">while</span> tasks:</span><br><span class="line">        <span class="comment"># NEW: round-robin between a set tasks (we may now have more than one and we'd like to be as "fair" as possible).</span></span><br><span class="line">        <span class="comment"># 新：一组任务之间的循环（我们现在可能有多个任务，我们希望尽可能“公平”）。</span></span><br><span class="line">        queue, tasks = tasks, []</span><br><span class="line">        <span class="keyword">for</span> task, data <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="comment"># NEW: resume the task *once*.</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = task.send(data)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> error:</span><br><span class="line">                <span class="comment"># NEW: prevent crashed task from ending the loop.</span></span><br><span class="line">                print(error)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># NEW: schedule the child task.</span></span><br><span class="line">                <span class="keyword">if</span> iscoroutine(data):</span><br><span class="line">                    tasks.append((data, <span class="keyword">None</span>))</span><br><span class="line">                <span class="comment"># NEW: reschedule the parent task.</span></span><br><span class="line">                tasks.append((task, <span class="keyword">None</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run_until_complete(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">main: before</span></span><br><span class="line"><span class="string">before spawn</span></span><br><span class="line"><span class="string">hello: before await</span></span><br><span class="line"><span class="string">before nice</span></span><br><span class="line"><span class="string">after spawn</span></span><br><span class="line"><span class="string">main: after</span></span><br><span class="line"><span class="string">after nice</span></span><br><span class="line"><span class="string">Hello, world!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>等待子任务join</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nice</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"nice: before yield"</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    print(<span class="string">"nice: after yield"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spawn</span><span class="params">(task)</span>:</span></span><br><span class="line">    <span class="comment"># NEW: recover the child task handle to pass it back to the parent.</span></span><br><span class="line">    print(<span class="string">"spawn: before yield"</span>)</span><br><span class="line">    child = <span class="keyword">yield</span> (<span class="string">'spawn'</span>, task)</span><br><span class="line">    print(<span class="string">"spawn: after yield"</span>)</span><br><span class="line">    <span class="keyword">return</span> child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># NEW: awaitable object that sends a request to be notified when a</span></span><br><span class="line"><span class="comment">#      concurrent task completes.</span></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(task)</span>:</span></span><br><span class="line">    print(<span class="string">"join: before yield"</span>)</span><br><span class="line">    <span class="keyword">yield</span> (<span class="string">'join'</span>, task)</span><br><span class="line">    print(<span class="string">"join: after yield"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"hello: before nice()"</span>)</span><br><span class="line">    <span class="keyword">await</span> nice()</span><br><span class="line">    print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># NEW: recover the child task handle.</span></span><br><span class="line">    child = <span class="keyword">await</span> spawn(hello(<span class="string">'world'</span>))</span><br><span class="line">    print(<span class="string">"main: after spawn and before join()"</span>)</span><br><span class="line">    <span class="comment"># NEW: wait for the child task to complete.</span></span><br><span class="line">    <span class="comment"># 等待子协程完成</span></span><br><span class="line">    <span class="keyword">await</span> join(child)</span><br><span class="line">    print(<span class="string">'(after join)'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(task)</span>:</span></span><br><span class="line">    tasks = [(task, <span class="keyword">None</span>)]</span><br><span class="line">    <span class="comment"># NEW: keep track of tasks to resume when a task completes.</span></span><br><span class="line">    watch = defaultdict(list)</span><br><span class="line">    <span class="keyword">while</span> tasks:</span><br><span class="line">        queue, tasks = tasks, []</span><br><span class="line">        <span class="keyword">for</span> task, data <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = task.send(data)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="comment"># NEW: wait up tasks waiting on this one.</span></span><br><span class="line">                <span class="comment"># 子协程退出时, 唤醒被join阻塞的父协程</span></span><br><span class="line">                <span class="comment"># 对watch中的task进行pop, 如果没有则返回[]</span></span><br><span class="line">                tasks.extend((t, <span class="keyword">None</span>) <span class="keyword">for</span> t <span class="keyword">in</span> watch.pop(task, []))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># NEW: dispatch request sent by awaitable object since we now have 3 different types of requests.</span></span><br><span class="line">                <span class="comment"># NEW: 由等待对象发送的调度请求，因为我们现在有 3 种不同类型的请求</span></span><br><span class="line">                <span class="comment"># 1. 如果是会产生新协程的操作</span></span><br><span class="line">                <span class="keyword">if</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">'spawn'</span>:</span><br><span class="line">                    <span class="comment"># 将新协程加入</span></span><br><span class="line">                    tasks.append((data[<span class="number">1</span>], <span class="keyword">None</span>))</span><br><span class="line">                    <span class="comment"># 将父协程和新协程写入, 在task.send(data)中可以使得父协程中赋值child=yield epx为子协程值</span></span><br><span class="line">                    tasks.append((task, data[<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">elif</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">'join'</span>:</span><br><span class="line">                    <span class="comment"># 如果父协程执行的快, 那么把子协程与父协程的绑定关系记录下来</span></span><br><span class="line">                    watch[data[<span class="number">1</span>]].append(task)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 正常协程执行结果</span></span><br><span class="line">                    tasks.append((task, <span class="keyword">None</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run_until_complete(main())</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">spawn: before yield</span></span><br><span class="line"><span class="string">hello: before nice()</span></span><br><span class="line"><span class="string">nice: before yield</span></span><br><span class="line"><span class="string">spawn: after yield</span></span><br><span class="line"><span class="string">main: after spawn and before join()</span></span><br><span class="line"><span class="string">--- 此时main执行完成, join等待nice()被执行</span></span><br><span class="line"><span class="string">join: before yield</span></span><br><span class="line"><span class="string">nice: after yield</span></span><br><span class="line"><span class="string">--- nice执行完成</span></span><br><span class="line"><span class="string">Hello, world!</span></span><br><span class="line"><span class="string">--- hello执行完成</span></span><br><span class="line"><span class="string">join: after yield</span></span><br><span class="line"><span class="string">--- join结束</span></span><br><span class="line"><span class="string">(after join)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>多了两样东西：</p>
<ul>
<li>新的请求类型:
<ul>
<li><code>spawn</code></li>
<li><code>join</code></li>
<li><code>push</code></li>
</ul>
</li>
<li>基于<code>task.send()</code>返回值的调度代码。</li>
</ul>
<p>针对[Sleeping &amp; timers](#Sleeping &amp; timers)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappop, heappush</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep <span class="keyword">as</span> _sleep</span><br><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> default_timer</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line"></span><br><span class="line"><span class="comment"># NEW: we need to keep track of elapsed time.</span></span><br><span class="line">clock = default_timer</span><br><span class="line"></span><br><span class="line"><span class="comment"># NEW: request that the event loop reschedule us "later".</span></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(seconds)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> (<span class="string">'sleep'</span>, seconds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># NEW: verify elapsed time matches our request.</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    ref = clock()</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">3.0</span>)</span><br><span class="line">    now = clock()</span><br><span class="line">    <span class="keyword">assert</span> (now - ref) &gt;= <span class="number">3.0</span></span><br><span class="line">    print(<span class="string">'Hello, %s!'</span> % (name,))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(task)</span>:</span></span><br><span class="line">    tasks = [(task, <span class="keyword">None</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># NEW: keep track of tasks that are sleeping.</span></span><br><span class="line">    timers = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># NEW: watch out, all tasks might be suspended at the same time.</span></span><br><span class="line">    <span class="keyword">while</span> tasks <span class="keyword">or</span> timers:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># NEW: if we have nothing to do for now, don't spin.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tasks:</span><br><span class="line">            _sleep(max(<span class="number">0.0</span>, timers[<span class="number">0</span>][<span class="number">0</span>] - clock()))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># NEW: schedule tasks when their timer has elapsed.</span></span><br><span class="line">        <span class="comment"># 如果times队列中有任务, 且最近的时间已经到了, 则取出任务</span></span><br><span class="line">        <span class="keyword">while</span> timers <span class="keyword">and</span> timers[<span class="number">0</span>][<span class="number">0</span>] &lt; clock():</span><br><span class="line">            _, task = heappop(timers)</span><br><span class="line">            tasks.append((task, <span class="keyword">None</span>))</span><br><span class="line"></span><br><span class="line">        queue, tasks = tasks, []</span><br><span class="line">        <span class="keyword">for</span> task, data <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = task.send(data)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># NEW: set a timer and don't reschedule right away.</span></span><br><span class="line">                <span class="keyword">if</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">'sleep'</span>:</span><br><span class="line">                    <span class="comment"># 往堆里面添加任务, 默认以时间最近的在上(最小堆)</span></span><br><span class="line">                    heappush(timers, (clock() + data[<span class="number">1</span>], task))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 递归添加下一次要做的协程任务</span></span><br><span class="line">                    tasks.append((task, <span class="keyword">None</span>))</span><br><span class="line"></span><br><span class="line">run_until_complete(hello(<span class="string">'world'</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> (</span><br><span class="line">    DefaultSelector,</span><br><span class="line">    EVENT_READ,</span><br><span class="line">    EVENT_WRITE,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socketpair <span class="keyword">as</span> _socketpair</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># NEW: request that the event loop tell us when we can read.</span></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv</span><span class="params">(stream, size)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> (EVENT_READ, stream)</span><br><span class="line">    <span class="keyword">return</span> stream.recv(size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># NEW: request that the event loop tell us when we can write.</span></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(stream, data)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> data:</span><br><span class="line">        <span class="keyword">yield</span> (EVENT_WRITE, stream)</span><br><span class="line">        size = stream.send(data)</span><br><span class="line">        data = data[size:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># NEW: connect sockets, make sure they never, ever block the loop.</span></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">socketpair</span><span class="params">()</span>:</span></span><br><span class="line">    lhs, rhs = _socketpair()</span><br><span class="line">    lhs.setblocking(<span class="keyword">False</span>)</span><br><span class="line">    rhs.setblocking(<span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">return</span> lhs, rhs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># NEW: send a message through the socket pair.</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    lhs, rhs = <span class="keyword">await</span> socketpair()</span><br><span class="line">    <span class="keyword">await</span> send(lhs, <span class="string">'Hello, world!'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    data = <span class="keyword">await</span> recv(rhs, <span class="number">1024</span>)</span><br><span class="line">    print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    lhs.close()</span><br><span class="line">    rhs.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(task)</span>:</span></span><br><span class="line">    tasks = [(task, <span class="keyword">None</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># NEW: prepare for I/O multiplexing.</span></span><br><span class="line">    selector = DefaultSelector()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># NEW: watch out, all tasks might be suspended at the same time.</span></span><br><span class="line">    <span class="keyword">while</span> tasks <span class="keyword">or</span> selector.get_map():</span><br><span class="line"></span><br><span class="line">        <span class="comment"># NEW: poll I/O operation status and resume tasks when ready.</span></span><br><span class="line">        timeout = <span class="number">0.0</span> <span class="keyword">if</span> tasks <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> key, events <span class="keyword">in</span> selector.select(timeout):</span><br><span class="line">            tasks.append((key.data, <span class="keyword">None</span>))</span><br><span class="line">            selector.unregister(key.fileobj)</span><br><span class="line"></span><br><span class="line">        queue, tasks = tasks, []</span><br><span class="line">        <span class="keyword">for</span> task, data <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = task.send(data)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># NEW: register for I/O and suspend the task.</span></span><br><span class="line">                <span class="keyword">if</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == EVENT_READ:</span><br><span class="line">                    selector.register(data[<span class="number">1</span>], EVENT_READ, task)</span><br><span class="line">                <span class="keyword">elif</span> data <span class="keyword">and</span> data[<span class="number">0</span>] == EVENT_WRITE:</span><br><span class="line">                    selector.register(data[<span class="number">1</span>], EVENT_WRITE, task)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tasks.append((task, <span class="keyword">None</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run_until_complete(hello(<span class="string">'world'</span>))</span><br></pre></td></tr></table></figure>
<p>Q: socketpair是什么？</p>
<ul>
<li><code>socket.socketpair()</code>函数仅返回两个已经连接的套接字对象，参数和socket.socket()里的参数一样的用法。</li>
<li><code>socket.socketpair()</code>可以理解为 创建了两个socket, 比喻为一个server的 socket，一个client的socket，这两个socket是已经connected连接状态</li>
<li>socket.socketpair()`是全双工模式，也就是每个socket都能收发，比喻为\server.send—&gt;client.recv,和 client.send—&gt;server.recv</li>
<li>socket.socketpair()`默认是创建unix套接字</li>
</ul>
<p>总结：</p>
<ul>
<li>函数加上<code>async def</code>变成了<code>coroutine object</code></li>
<li>函数加上<code>@types.coroutine</code>变成了<code>awaitable</code>的function</li>
</ul>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2022/05/08/toy-reimplementation-of-an-event-loop-in-Python-翻译/">https://nymrli.top/2022/05/08/toy-reimplementation-of-an-event-loop-in-Python-翻译/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2022/05/09/《代码整洁之道》——阅读笔记/" title="《代码整洁之道》——阅读笔记"><span>< PreviousPost</span><br><span class="prevTitle">《代码整洁之道》——阅读笔记</span></a><a class="nextSlogan" href="/2022/05/05/selenium不行的工作-pyppeteer上/" title="selenium不行的工作,pyppeteer上"><span>NextPost ></span><br><span class="nextTitle">selenium不行的工作,pyppeteer上</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: 'toy reimplementation of an event loop in Python[翻译]',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><span>备案号:苏ICP备18015439号</span></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#事件循环的一个小故事"><span class="toc-number">1.</span> <span class="toc-text"> 事件循环的一个小故事</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#协程的本质"><span class="toc-number">1.1.</span> <span class="toc-text"> 协程的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#与事件循环的对话"><span class="toc-number">1.2.</span> <span class="toc-text"> 与事件循环的对话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#looping"><span class="toc-number">1.3.</span> <span class="toc-text"> Looping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生成子任务"><span class="toc-number">1.4.</span> <span class="toc-text"> 生成子任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleeping-timers"><span class="toc-number">1.5.</span> <span class="toc-text"> Sleeping &amp; timers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理io"><span class="toc-number">1.6.</span> <span class="toc-text"> 处理I/O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#取消任务"><span class="toc-number">1.7.</span> <span class="toc-text"> 取消任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#许可证"><span class="toc-number">1.8.</span> <span class="toc-text"> 许可证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#个人收获"><span class="toc-number">2.</span> <span class="toc-text"> 个人收获</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#个人实验"><span class="toc-number">3.</span> <span class="toc-text"> 个人实验</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>