<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mrli&#39;s Blog</title>
  
  <subtitle>别装作很努力，结局不会陪你演戏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nymrli.top/"/>
  <updated>2022-06-03T02:18:07.863Z</updated>
  <id>https://nymrli.top/</id>
  
  <author>
    <name>Mrli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>爬虫——请求参数逆向</title>
    <link href="https://nymrli.top/2022/06/01/%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91/"/>
    <id>https://nymrli.top/2022/06/01/爬虫——请求参数逆向/</id>
    <published>2022-06-01T15:13:46.000Z</published>
    <updated>2022-06-03T02:18:07.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="登陆参数类"><a class="markdownIt-Anchor" href="#登陆参数类"></a> 登陆参数类</h1><h2 id="新浪博客登陆"><a class="markdownIt-Anchor" href="#新浪博客登陆"></a> <a href="http://blog.sina.com.cn/" target="_blank" rel="noopener">新浪博客登陆</a></h2><p>Input输入:</p><ol><li>Username账号</li><li>password密码</li></ol><p>params请求参数：</p><ol><li><a href="https://login.sina.com.cn/sso/prelogin.php?entry=boke&amp;callback=sinaSSOController.preloginCallBack&amp;su=MTUyMzIxMzEy&amp;rsakt=mod&amp;checkpin=1&amp;client=ssologin.js(v1.4.19)&amp;_=1654090585990" target="_blank" rel="noopener">https://login.sina.com.cn/sso/prelogin.php?entry=boke&amp;callback=sinaSSOController.preloginCallBack&amp;su=MTUyMzIxMzEy&amp;rsakt=mod&amp;checkpin=1&amp;client=ssologin.js(v1.4.19)&amp;_=1654090585990</a><ul><li>entry: boke——固定值</li><li>callback: sinaSSOController.preloginCallBack——固定值</li><li>su: MTUyMzIxMzEy——变：加密</li><li>rsakt: mod——固定值</li><li>checkpin: 1——固定值</li><li>client: ssologin.js(v1.4.19)——固定值</li><li>_: 1654090585990——变：13位时间戳</li></ul></li><li><a href="https://login.sina.com.cn/sso/login.php?client=ssologin.js(v1.4.19)&amp;_=1654090586051" target="_blank" rel="noopener">https://login.sina.com.cn/sso/login.php?client=ssologin.js(v1.4.19)&amp;_=1654090586051</a><ul><li>client: ssologin.js(v1.4.19)——固定值</li><li>_: 1654090586051——13位时间戳</li></ul></li></ol><h3 id="针对su参数的解密流程"><a class="markdownIt-Anchor" href="#针对su参数的解密流程"></a> 针对<code>su</code>参数的解密流程</h3><ol><li><p><code>Ctrl+Shift+F</code>全局搜索: <code>su =</code></p></li><li><p>搜索结果中定位到具体的文件：<code>ssologin.js</code></p></li><li><p>Jsonify后阅读代码，定位具体行数：971</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request = objMerge(request, me.loginExtraFlag);</span><br><span class="line">request = objMerge(request, me.loginExtraQuery);</span><br><span class="line">request.su = sinaSSOEncoder.base64.encode(urlencode(username));</span><br><span class="line"><span class="keyword">if</span> (me.service) &#123;</span><br><span class="line">    request.service = me.service</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给971行: <code>request.su = sinaSSOEncoder.base64.encode(urlencode(username));</code>加上断点</p></li><li><p>重新输入账号密码后，提交登陆请求</p></li><li><p>捕捉4中打的断点，查看参数运行时的值</p></li><li><p>观察971行具体的加密逻辑：</p></li><li><p>扣出sinaSSOEncoder类的定义：</p></li></ol><h3 id="附js中call调用"><a class="markdownIt-Anchor" href="#附js中call调用"></a> 附——JS中call调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =  a||&#123;&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.say =&#123;</span><br><span class="line">        what: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"what"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).call(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="built_in">console</span>.log(a.say.what())</span><br></pre></td></tr></table></figure><h1 id="请求参数类"><a class="markdownIt-Anchor" href="#请求参数类"></a> 请求参数类</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;登陆参数类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#登陆参数类&quot;&gt;&lt;/a&gt; 登陆参数类&lt;/h1&gt;
&lt;h2 id=&quot;新浪博客登陆&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#新浪博客登陆&quot;&gt;&lt;/a&gt; &lt;
      
    
    </summary>
    
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="JS" scheme="https://nymrli.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>每周一个开源项目——ddt-sharp-shooter</title>
    <link href="https://nymrli.top/2022/05/29/%E6%AF%8F%E5%91%A8%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94ddt-sharp-shoote/"/>
    <id>https://nymrli.top/2022/05/29/每周一个开源项目——ddt-sharp-shoote/</id>
    <published>2022-05-29T10:04:15.000Z</published>
    <updated>2022-05-30T15:40:16.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ddt-sharp-shooter"><a class="markdownIt-Anchor" href="#ddt-sharp-shooter"></a> <a href="https://github.com/boring-plans/ddt-sharp-shooter" target="_blank" rel="noopener">ddt-sharp-shooter</a></h1><blockquote><p>这是一个基于 <a href="https://github.com/moses-palmer/pynput" target="_blank" rel="noopener">Pynput</a> 的 DDT 工具。基本原理在于，得知风力、角度、距离的情况下，参考力度表得出发射力度，而后发射。<br>其中，风力、角度通过 <a href="https://github.com/sml2h3/ddddocr" target="_blank" rel="noopener">ddddocr</a>（An awesome captcha recognition library）识别，屏距通过标记屏距测量框、敌我位置来推算，力度通过按压时长来体现，具体见<a href="https://github.com/boring-plans/ddt-sharp-shooter/tree/master" target="_blank" rel="noopener">这里</a>。</p></blockquote><h2 id="使用到的库"><a class="markdownIt-Anchor" href="#使用到的库"></a> 使用到的库:</h2><p><code>screeninfo、pillow、ddddocr、pynput、py2app</code></p><ul><li>pynput: 控制和监视输入设备；类似的有PyHook3（监视键鼠）、pywin32 （模拟键鼠）</li><li>ddddocr：识别验证码，这边用来识别数字</li><li>py2app: 将Python程序打包成MacOS应用程序</li><li>screeninfo: 获得屏幕显示信息：<code>monitors = screeninfo.get_monitors()</code>、<code>_screen_size = (monitors[0].width, monitors[0].height)</code></li><li>pillow: 进行屏幕截图</li></ul><h2 id="whats-new"><a class="markdownIt-Anchor" href="#whats-new"></a> What’s New:</h2><h3 id="1进程间通信"><a class="markdownIt-Anchor" href="#1进程间通信"></a> 1.进程间通信</h3><blockquote><p>Tkinter界面开启mainloop进程，其中又开辟出一个子线程来侦听其他进程发送的数据消息，然后通过<code>tk.Text</code>控件来展示</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="comment"># 声明全局对象及类型</span></span><br><span class="line">_tk: tkinter.Tk</span><br><span class="line">_text: tkinter.Text</span><br><span class="line">_terminate = <span class="keyword">False</span></span><br><span class="line">_queue: multiprocessing.Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_text</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""子线程侦听进程消息"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> _terminate:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _queue.empty():</span><br><span class="line">            text = _queue.get(<span class="keyword">False</span>)</span><br><span class="line">            append_text(text)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append_text</span><span class="params">(text)</span>:</span></span><br><span class="line">    _text.config(state=<span class="string">'normal'</span>)</span><br><span class="line">    _text.insert(<span class="string">'end'</span>, <span class="string">f'\n<span class="subst">&#123;text&#125;</span>'</span>)</span><br><span class="line">    _text.see(<span class="string">'end'</span>)</span><br><span class="line">    _text.config(state=<span class="string">'disabled'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(gui_queue)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> _tk, _text, _queue, _screen_size</span><br><span class="line">    _queue = gui_queue</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    threading.Thread(target=update_text).start()</span><br><span class="line">    </span><br><span class="line">    _tk.mainloop()</span><br></pre></td></tr></table></figure><h3 id="2py2app创建macos应用"><a class="markdownIt-Anchor" href="#2py2app创建macos应用"></a> 2.py2app创建MacOS应用</h3><p><code>py2app setup</code>，在macos下创建python应用， <code>python setup.py py2app</code></p><h3 id="3ddddocr识别数字并清晰"><a class="markdownIt-Anchor" href="#3ddddocr识别数字并清晰"></a> 3.ddddocr识别数字并清晰</h3><p>对纯数字识别结果进行清洗</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recognize_digits</span><span class="params">(image: bytes)</span>:</span></span><br><span class="line">    <span class="string">"""进行数字识别"""</span></span><br><span class="line">    ocr = ddddocr.DdddOcr(show_ad=<span class="keyword">False</span>)</span><br><span class="line">    result = ocr.classification(image)</span><br><span class="line">    <span class="keyword">return</span> wash_digits(result)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wash_digits</span><span class="params">(digits: str)</span>:</span></span><br><span class="line">    <span class="string">"""由于不会出现非数字, 所以对易识别错误的字符进行替换"""</span></span><br><span class="line">    washed = digits \</span><br><span class="line">        .replace(<span class="string">'g'</span>, <span class="string">'9'</span>).replace(<span class="string">'q'</span>, <span class="string">'9'</span>) \</span><br><span class="line">        .replace(<span class="string">'l'</span>, <span class="string">'1'</span>).replace(<span class="string">'i'</span>, <span class="string">'1'</span>) \</span><br><span class="line">        .replace(<span class="string">'z'</span>, <span class="string">'2'</span>) \</span><br><span class="line">        .replace(<span class="string">'o'</span>, <span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">r'\D'</span>, <span class="string">'0'</span>, washed)</span><br></pre></td></tr></table></figure><h3 id="4pynput处理键鼠事件"><a class="markdownIt-Anchor" href="#4pynput处理键鼠事件"></a> 4.pynput处理键鼠事件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># km.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Keyboard and mouse input/output,</span></span><br><span class="line"><span class="string">and ScreenGrabbing</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> pynput <span class="keyword">import</span> keyboard, mouse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_click</span><span class="params">(x, y, btn_type, down)</span>:</span></span><br><span class="line">    <span class="string">"""鼠标点击回调函数"""</span></span><br><span class="line">    <span class="keyword">if</span> btn_type == mouse.Button.left <span class="keyword">and</span> down:</span><br><span class="line">        _queue.put((int(x), int(y)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_press</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="string">"""按键回调函数"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 处理正常的ASCII字符</span></span><br><span class="line">        <span class="keyword">if</span> event.char == <span class="string">'q'</span>:</span><br><span class="line">            <span class="comment"># 设置毒药, 当queue.get()获得None的时候, 消费端应该被kill</span></span><br><span class="line">            _queue.put(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _queue.put(event.char)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="comment"># 处理特殊的按键</span></span><br><span class="line">        <span class="keyword">if</span> event == keyboard.Key.esc:</span><br><span class="line">            _queue.put(<span class="string">'esc'</span>)</span><br><span class="line">        <span class="keyword">elif</span> event == keyboard.Key.enter:</span><br><span class="line">            _queue.put(<span class="string">'enter'</span>)</span><br><span class="line">        <span class="keyword">elif</span> event == keyboard.Key.space:</span><br><span class="line">            _queue.put(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">elif</span> event == keyboard.Key.backspace:</span><br><span class="line">            _queue.put(<span class="string">'delete'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">space_press_and_release</span><span class="params">(duration)</span>:</span></span><br><span class="line">    <span class="string">"""Press the key 'space' down for a while, and then release"""</span></span><br><span class="line">    <span class="comment"># @param duration: 持续时间</span></span><br><span class="line">    k = keyboard.Controller()</span><br><span class="line">    k.press(keyboard.Key.space)</span><br><span class="line">    time.sleep(duration)</span><br><span class="line">    k.release(keyboard.Key.space)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_press_and_release</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="string">"""Press certain key several times down, and then release immediately"""</span></span><br><span class="line">    <span class="comment"># @param key: 按下按键</span></span><br><span class="line">    k = keyboard.Controller()</span><br><span class="line">    k.press(key)</span><br><span class="line">    k.release(key)</span><br><span class="line">    time.sleep(<span class="number">0.37</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(km_queue)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> _queue</span><br><span class="line">    _queue = km_queue</span><br><span class="line"><span class="comment"># 注册键盘事件监听与回调函数</span></span><br><span class="line">    keyboard_listener = keyboard.Listener(on_press=on_press)</span><br><span class="line">    keyboard_listener.start()</span><br><span class="line">    time.sleep(<span class="number">.5</span>)</span><br><span class="line">    <span class="comment"># 注册鼠标事件监听与回调函数</span></span><br><span class="line">    mouse_listener = mouse.Listener(on_click=on_click)</span><br><span class="line">    mouse_listener.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run(<span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>on_press函数只是产生了queue的数据，数据具体是在main.py中的<code>handle_inputs</code>中被消费的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">km_listen_queue</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        inputs = _km_queue.get()</span><br><span class="line">        <span class="keyword">if</span> inputs <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># poison bill</span></span><br><span class="line">            <span class="comment"># 接收毒药, 毒药的设置可见上文Listener中回调函数是何时put None的</span></span><br><span class="line">            <span class="keyword">if</span> len(_wind_degree_points) &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">with</span> open(_W_D_POINTS_DUMP_NAME, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    pickle.dump(_wind_degree_points, f)</span><br><span class="line">            _gui_process.terminate()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># handle inputs</span></span><br><span class="line">            handle_inputs(inputs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_inputs</span><span class="params">(inputs)</span>:</span></span><br><span class="line">    <span class="string">"""To handle inputs"""</span></span><br><span class="line">    <span class="keyword">global</span> _command_flag, _direct_force_typing, _wind_direction</span><br><span class="line">    inputs_type = type(inputs)</span><br><span class="line">    <span class="comment"># 键盘事件on_press, 返回str</span></span><br><span class="line">    <span class="keyword">if</span> inputs_type == str:</span><br><span class="line">        <span class="comment"># press ESC to cancel</span></span><br><span class="line">        <span class="keyword">if</span> inputs == <span class="string">'esc'</span>:</span><br><span class="line">            reset_inputs()</span><br><span class="line">        <span class="keyword">elif</span> inputs == <span class="string">'-'</span>:</span><br><span class="line">            _wind_direction = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> inputs == <span class="string">'='</span>:</span><br><span class="line">            _wind_direction = <span class="number">1</span></span><br><span class="line">        <span class="comment"># press the key 't' twice to enable command mode</span></span><br><span class="line">        <span class="keyword">elif</span> inputs == <span class="string">'t'</span>:</span><br><span class="line">            _command_flag += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 最大t的次数为4, 所以4为一个周期</span></span><br><span class="line">            _command_flag %= <span class="number">4</span></span><br><span class="line">            <span class="keyword">if</span> _command_flag == <span class="number">2</span>:</span><br><span class="line">                _gui_queue.put(<span class="string">"指令输入开启💡"</span>)</span><br><span class="line">            <span class="keyword">elif</span> _command_flag == <span class="number">0</span>:</span><br><span class="line">                _gui_queue.put(<span class="string">"指令输入关闭🔒"</span>)</span><br><span class="line">        <span class="keyword">elif</span> _command_flag == <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># _command_flag == 2此时为命令模式, 输入enter完成设置, reset_inputs</span></span><br><span class="line">            <span class="comment"># press enter to submit command and fire</span></span><br><span class="line">            <span class="keyword">if</span> inputs == <span class="string">'enter'</span>:</span><br><span class="line">                direct_force = analyse_direct_force()</span><br><span class="line">                <span class="keyword">if</span> direct_force &gt; <span class="number">0</span>:</span><br><span class="line">                    fire(force=direct_force)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    wind, degree, distance = analyse_wind(), analyse_degree(), analyse_distance()</span><br><span class="line">                    fire(wind, degree, distance)</span><br><span class="line">                reset_inputs()</span><br><span class="line">            <span class="comment"># edit command</span></span><br><span class="line">            <span class="keyword">elif</span> inputs == <span class="string">'delete'</span>:</span><br><span class="line">                _direct_force_typing = _direct_force_typing[:<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _direct_force_typing += inputs</span><br><span class="line">        <span class="comment"># when not in command mode</span></span><br><span class="line">        <span class="comment"># any key except 't' will reset mode flag</span></span><br><span class="line">        <span class="comment"># which means only consecutive 't' input can enable command mode</span></span><br><span class="line">        <span class="keyword">elif</span> _command_flag == <span class="number">1</span>:</span><br><span class="line">            reset_inputs()</span><br><span class="line">    <span class="comment"># 鼠标事件on_click, 返回(x, y)</span></span><br><span class="line">    <span class="keyword">elif</span> inputs_type == tuple:</span><br><span class="line">        <span class="keyword">if</span> _command_flag == <span class="number">2</span>:</span><br><span class="line">            _distance_points.append(inputs)</span><br><span class="line">            _gui_queue.put(<span class="string">f'<span class="subst">&#123;len(_distance_points)&#125;</span> 个点已标记'</span>)</span><br><span class="line">        <span class="comment"># 按三次t之后再点击, 进入设置“角度中心位置、风力中心位置”</span></span><br><span class="line">        <span class="keyword">if</span> _command_flag == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> len(_wind_degree_points) == <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 如果标记过了风力和角度, 则重新标记</span></span><br><span class="line">                _wind_degree_points.clear()</span><br><span class="line">            _wind_degree_points.append(inputs)</span><br><span class="line">            <span class="keyword">if</span> len(_wind_degree_points) == <span class="number">1</span>:</span><br><span class="line">                _gui_queue.put(<span class="string">'角度位置已标记📐️'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _gui_queue.put(<span class="string">'风力位置已标记🌪️'</span>)</span><br></pre></td></tr></table></figure><h3 id="5屏幕截图"><a class="markdownIt-Anchor" href="#5屏幕截图"></a> 5.屏幕截图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grab_box</span><span class="params">(box: tuple)</span> -&gt; bytes:</span></span><br><span class="line">    <span class="comment"># 开启内存IO</span></span><br><span class="line">    bytes_io = io.BytesIO()</span><br><span class="line">    <span class="comment"># 截图</span></span><br><span class="line">    image = ImageGrab.grab().resize((_screen_size[<span class="number">0</span>], _screen_size[<span class="number">1</span>])).crop(box)</span><br><span class="line">    <span class="comment"># 写入内存IO</span></span><br><span class="line">    image.save(bytes_io, format=<span class="string">'png'</span>)</span><br><span class="line">    <span class="comment"># 获得bytes值</span></span><br><span class="line">    <span class="keyword">return</span> bytes_io.getvalue()</span><br></pre></td></tr></table></figure><h2 id="执行流程"><a class="markdownIt-Anchor" href="#执行流程"></a> 执行流程</h2><blockquote><p><code>mian.py</code>为程序入口</p></blockquote><ol start="0"><li><p>定义全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_W_D_POINTS_DUMP_NAME = <span class="string">'wind_degree_points.list'</span></span><br><span class="line">_PRESS_DURATION_PER_FORCE = <span class="number">4.1</span> / <span class="number">100</span></span><br><span class="line">_screen_size: tuple</span><br><span class="line">_command_flag = <span class="number">0</span></span><br><span class="line">_direct_force_typing = <span class="string">''</span></span><br><span class="line">_wind_direction = <span class="number">-1</span></span><br><span class="line">_distance_unit = <span class="number">0</span>  <span class="comment"># 用于像素与屏距转换</span></span><br><span class="line">_distance_points = []  <span class="comment"># 用于计算 _distance_unit 以及 屏距</span></span><br><span class="line">_wind_degree_points = []  <span class="comment"># 用于配置角度、风力 屏幕截取位置的点</span></span><br><span class="line">_gui_process: multiprocessing.Process</span><br><span class="line"><span class="comment"># GUI是另外的进程, 所以需要使用进程间的队列</span></span><br><span class="line">_gui_queue = multiprocessing.Queue()</span><br><span class="line"><span class="comment"># 相比之下, km是主进程中的, 不涉及进程间数据通信, 所以直接使用普通Queue就行</span></span><br><span class="line">_km_queue = Queue()</span><br></pre></td></tr></table></figure></li><li><p>获得屏幕信息：<code>_screen_size = (monitors[0].width, monitors[0].height)</code></p></li><li><p>开启GUI进程: <code>_gui_process = multiprocessing.Process(target=gui_run, args=(_gui_queue,))</code></p></li><li><p>开启pynput的键鼠侦听Listener线程</p></li><li><p>开启键鼠处理线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threading.Thread(target=km_listen_queue).start()</span><br><span class="line"><span class="comment"># km_listen_queue中接收poison bill(即按下"q")时, 关闭进程</span></span><br><span class="line">threading.Thread(target=gui_check_alive).start()</span><br><span class="line"><span class="comment"># GUI检测心跳线程, 当GUI的状态不是is_alive时, 向queue中投递毒药, 将terminate设置为False. 从而关闭GUI进程中的update_text线程</span></span><br></pre></td></tr></table></figure></li><li><p>在键鼠处理线程中，根据键鼠输入值，进行功能生效</p></li></ol><h2 id="代码风格特点"><a class="markdownIt-Anchor" href="#代码风格特点"></a> 代码风格特点：</h2><p>每个模块（py文件）都有自己的全局变量，通过主程序调用模块函数时进行传引用，而变量全在主程序<code>main.py</code>中定义。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2><p>涉及了<strong>多线程、多进程、图像识别、屏幕截图识别、键鼠检测、打包应用</strong>等内容，其中对于①多线程和多进程使用、②识别结果后的针对纯数字数据进行清洗；③消息队列的使用、毒药设置；都比较让人有收获。</p><h1 id="视频思路"><a class="markdownIt-Anchor" href="#视频思路"></a> 视频思路</h1><ol><li>讲解程序功能</li><li>介绍使用到的库</li><li>讲解程序文件结构</li><li>讲解每个文件实现</li><li>介绍优点和有价值的</li><li>介绍缺点<ol><li>C式的全局变量风格</li></ol></li></ol><p><a href="https://www.bilibili.com/video/BV1iz411b7Fa/" target="_blank" rel="noopener">【PR教程】2分钟学会制作视频内容导航条</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ddt-sharp-shooter&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ddt-sharp-shooter&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://github.com/boring-plans/ddt-sharp-sh
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="开源项目" scheme="https://nymrli.top/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>爬虫App——夜神模拟器xposed+inspeckage</title>
    <link href="https://nymrli.top/2022/05/10/%E7%88%AC%E8%99%ABApp%E2%80%94%E2%80%94xposed-inspeckage/"/>
    <id>https://nymrli.top/2022/05/10/爬虫App——xposed-inspeckage/</id>
    <published>2022-05-10T06:34:49.000Z</published>
    <updated>2022-05-10T12:47:02.087Z</updated>
    
    <content type="html"><![CDATA[<p>头一次接触到App参数加密的，因此需要对加密参数进行反编译，了解到有工具inspeckage可以方便的来找寻加密参数。而其使用的条件为</p><ul><li>手机已ROOT</li><li>在Xposed框架下运行</li></ul><p>于是开始在夜神模拟器上捣鼓安装xposed、inspeckage。</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><h3 id="xposed框架"><a class="markdownIt-Anchor" href="#xposed框架"></a> xposed框架</h3><p>在不少地方都下载了xposed框架，但都不太使用，后来了解到模拟器的xposed是专用的，根据夜神模拟器官网介绍的<a href="https://support.yeshen.com/zh-CN/qt/xp" target="_blank" rel="noopener">夜神模拟器如何安装xposed框架</a>后，决定还是在<strong>模拟器的应用商店</strong>进行安装xposed，下载安装后的名称为&quot;xposed 派大星&quot;。</p><p>下载安装后立马打开还是会显示没安装，需要点击&quot;安装/更新&quot;下的选项进行安装才行。在安装完成后再选择<strong>重启模拟器</strong>。</p><h3 id="inspeckage模块"><a class="markdownIt-Anchor" href="#inspeckage模块"></a> inspeckage模块</h3><blockquote><p>Inspeckage是一个用于提供Android应用程序动态分析的工具。通过对Android API的函数使用hook技术，帮助用户了解应用程序在运行时的行为——crypto菜单栏下会hook捕捉常见的加密，Hash菜单栏下会hook捕捉常见的hash。</p></blockquote><p>原以为需要额外去搜寻下载，后来发现推荐的都是安装好xposed软件后，在其菜单栏的&quot;下载&quot;中搜寻&quot;inspeckage&quot;模块使用（搜索结果为Inspeckage-Andriod package inspector）后安装，安装成功切换到菜单栏的&quot;模块&quot;中，勾选&quot;inspeckage&quot;后<strong>重启模拟器</strong>。</p><p>注：xposed的作用只是为了给inspeckage提供运行环境。</p><h2 id="启动inspeckage"><a class="markdownIt-Anchor" href="#启动inspeckage"></a> 启动inspeckage</h2><blockquote><p>参考：Inspeckage插件的运用</p></blockquote><ol><li><p>打开模拟器的inspeckage程序，<code>choose target</code>：选择目标app程序</p><p><img src="/2022/05/10/爬虫App——xposed-inspeckage/E:%5Chexo%5Csource_posts%5C%E7%88%AC%E8%99%ABApp%E2%80%94%E2%80%94xposed-inspeckage%5C%E6%A8%A1%E6%8B%9F%E5%99%A8inspeckage.jpg" alt="模拟器inspeckage"></p></li><li><p>点击&quot;Lauch APP&quot;打开要捕获程序</p></li><li><p>在宿主机cmd里面输入命令<code>adb forward tcp:8008 tcp:8008</code>，然后在浏览器里输入http://127.0.0.1:8008 就会看到Inspeckage的界面</p></li></ol><p><img src="/2022/05/10/爬虫App——xposed-inspeckage/E:%5Chexo%5Csource_posts%5C%E7%88%AC%E8%99%ABApp%E2%80%94%E2%80%94xposed-inspeckage%5Cinspeckage%E7%BD%91%E9%A1%B5.png" alt="inspeckage网页"></p><p>注：得手动点击ON才能实时抓信息。</p><p>更多介绍见：<a href="https://blog.csdn.net/tom__chen/article/details/78216732" target="_blank" rel="noopener">Inspeckage使用笔记（app安全检测工具）</a></p><h2 id="使用inspeckage"><a class="markdownIt-Anchor" href="#使用inspeckage"></a> 使用inspeckage</h2><p>菜单页说明</p><table><thead><tr><th style="text-align:center">模块名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">Logcat</td><td style="text-align:center">查看该app的logcat输出</td></tr><tr><td style="text-align:center">Tree View</td><td style="text-align:center">浏览app的数据目录并直接下载文件到本地</td></tr><tr><td style="text-align:center">Package Information</td><td style="text-align:center">应用基本信息（组件信息、权限信息、共享库信息）</td></tr><tr><td style="text-align:center">Shared Preferences</td><td style="text-align:center">LOG：app XML文件读写记录；Files：具体XML写入内容</td></tr><tr><td style="text-align:center">Serialization</td><td style="text-align:center">反序列化记录</td></tr><tr><td style="text-align:center">Crypto</td><td style="text-align:center">常见加解密记录，AES、DES、RSA（KEY、IV值）</td></tr><tr><td style="text-align:center">Hash</td><td style="text-align:center">常见的哈希算法记录</td></tr><tr><td style="text-align:center">SQLite</td><td style="text-align:center">SQLite数据库操作记录</td></tr><tr><td style="text-align:center">HTTP</td><td style="text-align:center">HTTP网络请求记录</td></tr><tr><td style="text-align:center">File System</td><td style="text-align:center">文件读写记录</td></tr><tr><td style="text-align:center">Misc.</td><td style="text-align:center">调用Clipboard,URL.Parse()记录</td></tr><tr><td style="text-align:center">WebView</td><td style="text-align:center">调用webview内容</td></tr><tr><td style="text-align:center">IPC</td><td style="text-align:center">进程之间通信记录</td></tr><tr><td style="text-align:center">+Hooks</td><td style="text-align:center">运行过程中用户自定义Hook记录</td></tr></tbody></table><p>注：inspeckage主要是用来hook加密的，对hash检测的效果可能不是很好——AXHC</p><p><strong>使用说明</strong>：</p><p>如果是要参看加密前的数据（解密数据），可以直接查看Crypto菜单栏下的内容，搜索你所需要找的加密参数就可以得到原文和使用的加密、Hash类型，直接秒杀！</p><p>比如:<code>Algorithm( MD5 ) [eexssdsd : zxcxzc]</code>，说明使用的算法为MD5， <code>[plaintext : encrypted]</code></p><p><strong>原理分析</strong>：那么这个效果是怎么做到的呢？其实很简单，就是直接将Java标准库中常见的被用于生成加密参数的方法给Hook了，监听它们的输入参数和返回值，这样就能直接得到加密、Hash前的原文、密钥、IV等内容了，怎么样？是不是很简单？——相对于反编译app，自己再看代码实现简单、快捷多了。</p><p><strong>实战</strong>：</p><ul><li>解析sign参数的明文：<a href="https://blog.csdn.net/qq_38832624/article/details/100897605" target="_blank" rel="noopener">https://blog.csdn.net/qq_38832624/article/details/100897605</a></li><li><a href="https://blog.csdn.net/fatesunlove/article/details/105146882" target="_blank" rel="noopener">inspeckage使用实战两例</a></li><li><a href="https://blog.csdn.net/z434890/article/details/100528704" target="_blank" rel="noopener">app反编译实战三：工具inspeckage的使用</a>——识货MD5参数解析</li><li>Jadx反编译：<a href="https://cloud.tencent.com/developer/article/1447630?from=article.detail.1548593" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1447630?from=article.detail.1548593</a></li><li>视频教程：<ul><li><a href="https://space.bilibili.com/175052335" target="_blank" rel="noopener">APP逆向解密 安卓HOOK</a>——恰恰小视频，复合加密: MD5(password, “saltA” + phoneNum + “saltB”)</li><li><a href="https://www.bilibili.com/video/BV1Qa4y1J7bc?spm_id_from=333.337.search-card.all.click" target="_blank" rel="noopener">安卓逆向 HOOK APP加密字段sign解密</a>——众赢时空</li></ul></li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="mudule-disabled"><a class="markdownIt-Anchor" href="#mudule-disabled"></a> Mudule disabled</h2><p><strong>Module disabled</strong>表明<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>环境中没有安装<em><strong>Xposed框架*</strong>，用户可以在没有Xposed的情况下运行</em><em>Inspeckage</em>*，但是绝大部分功能都要依赖Xposed框架，所以建议在测试环境中安装该框架。</p><p>如果安装Xposed后，并且inspeckage就是通过对应的Xposed软件下载的，那么检查&quot;模块&quot;中是否将&quot;inspeckage&quot;勾选，然后重启。</p><h2 id="手机目录"><a class="markdownIt-Anchor" href="#手机目录"></a> 手机目录</h2><p>MT管理器能看到</p><ul><li><code>/data/data/</code> 下是手机系统文件和你安装软件的数据文件，不建议随便删除，或造成死机或开不了机。需要root</li><li><code>/etc/data</code></li></ul><h2 id="反编译"><a class="markdownIt-Anchor" href="#反编译"></a> 反编译</h2><blockquote><p>如果程序被加固(加壳，腾讯乐固、360加固)，则需要去壳后反编译，比如脱壳工具FDex2，脱壳后得到多个dex文件，将其压缩成压缩包，再使用反编译如jadx导入分析。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;头一次接触到App参数加密的，因此需要对加密参数进行反编译，了解到有工具inspeckage可以方便的来找寻加密参数。而其使用的条件为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手机已ROOT&lt;/li&gt;
&lt;li&gt;在Xposed框架下运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是开始在夜神模拟器上捣
      
    
    </summary>
    
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>使用Python转义实现前端加密算法-记录笔记</title>
    <link href="https://nymrli.top/2022/04/29/%E4%BD%BF%E7%94%A8Python%E8%BD%AC%E4%B9%89%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95-%E8%AE%B0%E5%BD%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2022/04/29/使用Python转义实现前端加密算法-记录笔记/</id>
    <published>2022-04-29T01:22:28.000Z</published>
    <updated>2022-04-29T04:36:04.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境安装"><a class="markdownIt-Anchor" href="#环境安装"></a> 环境安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall crypto</span><br><span class="line">pip uninstall pycryptodome</span><br><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure><p>前面两个卸载命令是为了防止一些安装环境问题，具体请看<a href="https://blog.csdn.net/chouzhou9701/article/details/106432497/" target="_blank" rel="noopener">文章</a></p><h1 id="pycryptodome"><a class="markdownIt-Anchor" href="#pycryptodome"></a> pycryptodome</h1><h2 id="aes加密"><a class="markdownIt-Anchor" href="#aes加密"></a> AES加密</h2><p><strong>加密模式</strong></p><p>AES 加密最常用的模式就是 ECB模式 和 CBC 模式，当然还有很多其它模式，他们都属于AES加密。ECB模式和CBC 模式俩者区别就是 ECB 不需要 iv偏移量，而CBC需要。</p><p><strong>AES加密使用参数</strong></p><p>以下参数都是在python中使用的。</p><p>参数作用及数据类型<br>秘钥加密的时候用秘钥，解密的时候需要同样的秘钥才能解出来; 数据类型为bytes<br>明文需要加密的参数; 数据类型为bytes<br>模式aes 加密常用的有 ECB 和 CBC 模式（我只用了这两个模式，还有其他模式）;数据类型为aes类内部的枚举量<br>iv 偏移量这个参数在 ECB 模式下不需要，在 CBC 模式下需要；数据类型为bytes</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ECB模式加密解密</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">password = <span class="string">b'1234567812345678'</span> <span class="comment">#秘钥，b就是表示为bytes类型</span></span><br><span class="line">text = <span class="string">b'abcdefghijklmnhi'</span> <span class="comment">#需要加密的内容，bytes类型</span></span><br><span class="line">aes = AES.new(password,AES.MODE_ECB) <span class="comment">#创建一个aes对象</span></span><br><span class="line"><span class="comment"># AES.MODE_ECB 表示模式是ECB模式</span></span><br><span class="line">en_text = aes.encrypt(text) <span class="comment">#加密明文</span></span><br><span class="line">print(<span class="string">"密文："</span>,en_text) <span class="comment">#加密明文，bytes类型</span></span><br><span class="line"></span><br><span class="line">den_text = aes.decrypt(en_text) <span class="comment"># 解密密文</span></span><br><span class="line">print(<span class="string">"明文："</span>,den_text)</span><br></pre></td></tr></table></figure><p>以上是针对ECB模式的加密解密，从这个例子中可以看出参数中有几个限制。</p><ol><li>秘钥必须为16字节或者16字节的倍数的字节型数据。</li><li>明文必须为16字节或者16字节的倍数的字节型数据，如果不够16字节需要进行补全，关于补全规则，后面会在补全模式中具体介绍。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CBC</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">password = <span class="string">b'1234567812345678'</span> <span class="comment">#秘钥，b就是表示为bytes类型</span></span><br><span class="line">iv = <span class="string">b'1234567812345678'</span> <span class="comment"># iv偏移量，bytes类型</span></span><br><span class="line">text = <span class="string">b'abcdefghijklmnhi'</span> <span class="comment">#需要加密的内容，bytes类型</span></span><br><span class="line">aes = AES.new(password,AES.MODE_CBC,iv) <span class="comment">#创建一个aes对象</span></span><br><span class="line"><span class="comment"># AES.MODE_CBC 表示模式是CBC模式</span></span><br><span class="line">en_text = aes.encrypt(text) </span><br><span class="line">print(<span class="string">"密文："</span>,en_text) <span class="comment">#加密明文，bytes类型</span></span><br><span class="line"></span><br><span class="line">aes = AES.new(password,AES.MODE_CBC,iv) <span class="comment">#CBC模式下解密需要重新创建一个aes对象</span></span><br><span class="line">den_text = aes.decrypt(en_text)</span><br><span class="line">print(<span class="string">"明文："</span>,den_text)</span><br></pre></td></tr></table></figure><h1 id="hashlib"><a class="markdownIt-Anchor" href="#hashlib"></a> hashlib</h1><h2 id="md5"><a class="markdownIt-Anchor" href="#md5"></a> MD5</h2><blockquote><p>hashlib模块下的&quot;加密&quot;</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">string=<span class="string">'任性的90后boy'</span></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(string.encode(<span class="string">'utf-8'</span>))<span class="comment">#转码，update里的必须是字节型</span></span><br><span class="line"><span class="comment"># 默认是32位小写</span></span><br><span class="line">res = md5.hexdigest() <span class="comment">#返回字符型摘要信息print(md5.digest())#返回字节型的摘要信息</span></span><br><span class="line"><span class="comment"># 切换到16位大写</span></span><br><span class="line"><span class="comment"># res=md5.hexdigest()[8:-8]</span></span><br><span class="line">print(<span class="string">"md5加密结果:"</span>,res)</span><br></pre></td></tr></table></figure><h2 id="sha256"><a class="markdownIt-Anchor" href="#sha256"></a> Sha256</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">string=<span class="string">'任性的90后boy'</span></span><br><span class="line">sha256 = hashlib.sha256()</span><br><span class="line">sha256.update(string.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">res = sha256.hexdigest()</span><br><span class="line">print(<span class="string">"sha256加密结果:"</span>,res)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#环境安装&quot;&gt;&lt;/a&gt; 环境安装&lt;/h2&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>总得学点Elasticsearch吧</title>
    <link href="https://nymrli.top/2022/04/11/%E6%80%BB%E5%BE%97%E5%AD%A6%E7%82%B9Elasticsearch%E5%90%A7/"/>
    <id>https://nymrli.top/2022/04/11/总得学点Elasticsearch吧/</id>
    <published>2022-04-11T14:18:04.000Z</published>
    <updated>2022-04-12T14:29:28.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="倒排索引"><a class="markdownIt-Anchor" href="#倒排索引"></a> 倒排索引</h2><p>反向索引（inverted index）更熟悉的名字是倒排索引。</p><p>什么是倒排索引: 倒排索引也叫反向索引，通俗来讲正向索引是通过key找value，反向索引则是通过value找key。</p><p>举个具体的例子：我们一般是通过<strong>标题</strong>来找<strong>文章内容</strong>，即通过目录（正向索引）；而反向索引的运用场景就是通过<strong>内容</strong>来找到是<strong>哪一篇文章</strong>（标题，作者……），而怎么建立反向索引呢？怎么更快更好地找到结果呢？这个就是<strong>搜索引擎</strong>做的事了、</p><p>正向索引：例如一个“文档1”经过分词，提取了20个关键词，每个关键词都会记录它在文档中的出现次数和出现位置。那我们就可以直接通过对&quot;文档1&quot;Document这个结构进行解析，从而得到每个关键词的信息。</p><p>反向索引：那么我们希望通过关键词来找到它在哪几篇“文档”中出现怎么办呢？那么其实在遍历文章的时候，如果当前文章出现了keyword，则对Keyword的结构（简单点可以想成是一个hashmap）添加上这篇文章的信息</p><p>再举个生活例子： 当用户在主页上搜索关键词“<u>华为手机</u>”时，假设只存在正向索引（forward index），那么就需要<strong>实时扫描完索引库中的所有文档</strong>，找出所有包含关键词“华为手机”的文档，再根据打分模型进行打分，排出名次后呈现给用户。因为互联网上收录在搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足<strong>实时</strong>返回排名结果的要求。</p><p>所以，<strong>搜索引擎</strong>会将正向索引<strong>重新构建</strong>为倒排索引，即把<strong>文件ID</strong>对应到<strong>关键词</strong>的映射转换为<strong>关键词到文件ID的映射</strong>，每个关键词都对应着一系列的文件，这些文件中都出现这个关键词。从而大大减少了遍历的大小，加快了检索的速度。</p><p><strong>本质上是通过设计数据结构，并花了额外的空间去换检索时的时间。</strong></p><p>论文查重就是这种的典型应用：<a href="https://www.bilibili.com/video/BV1iK4y1M7XR?spm_id_from=444.41.0.0" target="_blank" rel="noopener">B站视频——论文查重是如何实现的</a>——将段落通过标点符号分隔成一个个句子，再将句子每每7个分隔成一个个section，比如长度为9的句子则可以分成3个section，预处理创建<code>preDict={&quot;section1&quot;: [doc1, ], &quot;section2&quot;: [doc1, ], &quot;section&quot;3: [doc1, ]}</code>的倒排索引，当进行查重时，也是分隔成句子后每每7个字进行检查是否在preDict中，如果在则是知道了在哪些文章中出现（最简单版）。视频后又提出了增加LCS最长公共子串的增强，有效地检验出了添加“的”字or调整字位置的偷鸡方法——建立4字倒排，如果4个字已经出现在了别的文章A里，则把当前句子S1与文章A中的句子S2进行LCS，如果公共子串长度大于7则判定为重复。</p><h2 id="搜索引擎elasticsearch"><a class="markdownIt-Anchor" href="#搜索引擎elasticsearch"></a> 搜索引擎——Elasticsearch</h2><p>Elastic Stack 如果你没有听过，那么 ELK 一定听过。ELK 是三款软件的简称，分别是 <code>Elasticsearch</code>、<code>Logstash</code>、<code>Kibana</code> 组成。那什么是 Elasticsearch呢？——全文搜索是很多网站常见功能，比如 GitHub 站内搜索、JD 商品搜索、B 站视频搜索。<code>Elasticsearch</code> 是当今最火的<strong>搜索引擎</strong>之一，它的底层基于另外一个 <code>java</code> 开源搜索引擎 <code>Lucene</code>，是一款开源分布式搜索引擎，并且提供了一系列 <code>REST API</code> 操作接口。</p><h2 id="es的核心概念"><a class="markdownIt-Anchor" href="#es的核心概念"></a> ES的核心概念</h2><ol><li>索引（Index）：ES将数据存储于一个或多个索引中。类比传统的关系型数据库领域来说，索引相当于SQL中的一个数据库，或者一个数据存储方案（schema）。索引由其名称（必须为全小写字符）进行标识。一个ES集群中可以按需创建任意数目的索引。</li><li>类型（type）：类型是索引内部的逻辑分区（category/partition），一个索引内部可定义一个或多个类型（type）。类比传统的关系型数据库领域来说，类型相当于“表”。</li><li>文档（Document）：文档是索引和搜索的原子单位，它是包含了一个或多个域（Fild）的容器，每个域拥有一个名字及一个或多个值，有多个值的域通常称为“多值域”，文档基于JSON格式进行表示。每个文档可以存储不同的域集，但同一类型下的文档至应该有某种程度上的相似之处。</li><li>集群（Cluster）：一个或者多个拥有相同cluster…name配置的节点组成，它们共同承担数据和负载的压力。</li><li>节点（Node）：一个运行中的Elasticsearch实例称为一个节点。<br>ES集群中的节点有三种不同的类型：<ul><li>主节点：负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。主节点并不需要涉及到文档级别的变更和搜索等操作。可以通过属性node.masteri进行设置。</li><li>数据节点：存储数据和其对应的倒排索引。默认每一个节点都是数据节点（包括主节点），可以通过ode.data属性进行设置。</li><li>协调节点：如果node.master和node.data属性均为false，则此节点称为协调节点，用来响应客户请求，均衡每个节点的负载。</li></ul></li></ol><h2 id="python操作elasticsearch"><a class="markdownIt-Anchor" href="#python操作elasticsearch"></a> Python操作Elasticsearch</h2><p>安装es库<code>pip install Elasticsearch</code></p><p>参考：</p><ul><li><a href="https://www.bilibili.com/video/BV1CJ411L7uV?from=search&amp;seid=16833887069453710612&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener"><em>python</em>操作<em>ElasticSearch</em>-创建、插入、检索</a></li><li><a href="https://www.bilibili.com/video/BV1Nk4y1R7Hf?p=5&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">【狂神说Java】ElasticSearch搜索实战仿京东搜索</a>——Java操作ES+仿京东搜索+vue与thymeleft单页面实现前端</li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="docker-运行-elasticsearch"><a class="markdownIt-Anchor" href="#docker-运行-elasticsearch"></a> docker 运行 Elasticsearch</h2><blockquote><p>根据官网推荐，ES配套 Kibana 只能安装 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.elastic.co%2Fguide%2Fen%2Fkibana%2F6.8%2Fdocker.html" target="_blank" rel="noopener">6.8.19</a>， 所以安装</p></blockquote><ol><li><p>拉取镜像:<code>docker pull docker.io/elasticsearch:7.17.2</code>，拉取其他版本可见<a href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E7%89%88%E6%9C%AC%EF%BC%9Adocker-search-tag">查看镜像版本：docker-search-tag</a></p></li><li><p>es配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/apollo3d/cl/dockerdata/elasticsearch/config </span><br><span class="line">mkdir -p /home/apollo3d/cl/dockerdata/elasticsearch/data</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"http.host: 0.0.0.0"</span> &gt;&gt; /home/apollo3d/cl/dockerdata/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure></li><li><p>启动容器:<code>docker run --name es -p 9200:9200 -p 9300:9300 \ -e &quot;discovery.type=single-node&quot; \ -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \ -v /home/apollo3d/dockerdata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \ -v /home/apollo3d/dockerdata/elasticsearch/data:/usr/share/elasticsearch/data \ -v /home/apollo3d/dockerdata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \ -d docker.io/elasticsearch:7.17.2</code>，注：<code>&lt;image_id&gt;</code>可以通过<code>docker images</code>查看刚刚pull下来的镜像；需要去ESC上打开防火墙的指定端口；</p></li><li><p>测试：浏览器访问 Elasticsearch 地址：<code>ECS_IP:9200</code>， 如果返回JSON数据则<strong>启动正确</strong></p></li><li><p>安装 ik 分词器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入es容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it es bash</span><br><span class="line"><span class="comment"># 下载ik分词器</span></span><br><span class="line">$ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.1.1/elasticsearch-analysis-ik-7.1.1.zip</span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line">$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li><li><p>安装 ik 分词器后重启 Elasticsearch：<code>docker restart es</code></p></li><li><p>postman 测试 ik 分词器（注意：把 Content-Type 设置为 application/json ）</p></li></ol><h2 id="启动-es-head-可视化界面"><a class="markdownIt-Anchor" href="#启动-es-head-可视化界面"></a> 启动 es-head (可视化界面):</h2><blockquote><p>Elasticsearch 5.x后不支持插件，head作为单独服务独立运行。</p></blockquote><ol><li><p>拉取镜像：<code>docker pull mobz/elasticsearch-head:5</code></p></li><li><p>启动容器：<code>docker run -d -p 9100:9100 --name esh elasticsearch-head</code></p></li><li><p>访问 es-head：<code>ECS_IP:9100</code></p><p>当你输入 <a href="https://link.zhihu.com/?target=http%3A//192.168.232.128%3A9200/" target="_blank" rel="noopener">http://192.168.232.128:9200/</a> 点击连接时，会发现无法连接。是因为前后端分离开发，存在跨域问题，需要在服务端做 CORS 的配置。我们再次进入 Elasticsearch 容器内部，修改 <code>elasticsearch.yml</code> 配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it es /bin/bash</span><br><span class="line">[root@7f213e9fb6bb elasticsearch]<span class="comment"># vi config/elasticsearch.yml</span></span><br><span class="line"><span class="comment"># 添加如下两条配置，注意冒号后面有空格，保存并退出。</span></span><br><span class="line">http.cors.enabled: <span class="literal">true</span> </span><br><span class="line">http.cors.allow-origin: <span class="string">"*"</span></span><br></pre></td></tr></table></figure></li><li><p>最后退出容器，并重启 Elasticsearch: <code>docker restart esh</code></p></li><li><p>再次访问 es-head，就能看到可视化的界面了。</p></li></ol><h2 id="启动-kibana可视化界面"><a class="markdownIt-Anchor" href="#启动-kibana可视化界面"></a> ★启动 kibana（可视化界面）</h2><blockquote><p>Kibana 是为 <a href="https://so.csdn.net/so/search?q=Elasticsearch&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">Elasticsearch</a>设计的开源分析和可视化平台。可以使用 Kibana 来搜索，查看存储在 Elasticsearch 索引中的数据并与之交互。你可以很容易实现高级的数据分析和可视化，并且以<u>图表的形式</u>展现出来。</p><p>是ELK技术栈中的K，也是ES比较主流的可视化界面，也是官方推荐的</p><p>Elasticsearch 5.x后不支持插件，跟Elasticsearch  head一样，kibana需要作为单独服务独立运行。</p></blockquote><ol><li><p>拉取镜像：<code>docker pull docker.io/kibana:7.17.2</code></p></li><li><p>配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/dockerdata/elk7/kibana/config/</span><br><span class="line">vi ~/dockerdata/elk7/kibana/config/kibana.yml</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ** THIS IS AN AUTO-GENERATED FILE **</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Default Kibana configuration for docker target</span></span><br><span class="line"></span><br><span class="line">server.name: kibana</span><br><span class="line">server.host: <span class="string">"0"</span> <span class="comment"># 对外访问kibana的地址</span></span><br><span class="line">elasticsearch.hosts: [ <span class="string">"http://127.0.0.1:9200"</span> ]<span class="comment"># elasticsearch的地址</span></span><br><span class="line">xpack.monitoring.ui.container.elasticsearch.enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>启动容器: <code>docker run -d --name=kibana --restart=always -p 5601:5601 -v ~/dockerdata/elk7/kibana/config/kibana.yml:/usr/share/kibana/config/kibana.yml kibana:7.17.2</code></p></li><li><p>查看日志: <code>docker logs -f kibana</code></p></li><li><p>等待30秒，如果出现以下信息，说明启动成功了：<code>{&quot;type&quot;:&quot;log&quot;,&quot;@timestamp&quot;:&quot;2020-08-27T03:00:28Z&quot;,&quot;tags&quot;:[&quot;listening&quot;,&quot;info&quot;],&quot;pid&quot;:6,&quot;message&quot;:&quot;Server running at http://0:5601&quot;}</code></p></li><li><p>访问页面：<code>ECS_IP:5601</code>就可以看到Welcome to Kibana啦~</p></li></ol><p>Kibana server is not ready yet问题：</p><ul><li><a href="https://blog.csdn.net/fbvukn/article/details/107289027?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;utm_relevant_index=2" target="_blank" rel="noopener">kibana解决Kibana server is not ready yet问题</a></li><li><a href="https://blog.csdn.net/whatday/article/details/107879989" target="_blank" rel="noopener">kibana 报错 server is not ready yet 可能的原因</a></li></ul><h2 id="docker-compose"><a class="markdownIt-Anchor" href="#docker-compose"></a> docker-compose:</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    elasticsearch:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">docker.io/elasticsearch:7.17.2</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">es2</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">discovery.type=single-node</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">           -</span> <span class="string">"9200:9200"</span></span><br><span class="line"><span class="bullet">           -</span> <span class="string">"9300:9300"</span></span><br><span class="line"><span class="attr">    kinaba:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">docker.io/kibana:7.17.2</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">kibana2</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"5601:5601"</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">/home/apollo3d/cl/dockerdata/elk7/kibana/config/kibana.yml:/usr/share/kibana/config/kibana.yml</span></span><br><span class="line"><span class="attr">        depends_on:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">elasticsearch</span></span><br></pre></td></tr></table></figure><h2 id="查看镜像版本docker-search-tag"><a class="markdownIt-Anchor" href="#查看镜像版本docker-search-tag"></a> 查看镜像版本：docker-search-tag</h2><p><a href="http://xn--docker-show-repo-tag-2x06a431biq1j2e4clo2cqoe.sh" target="_blank" rel="noopener">使用自制脚本docker-show-repo-tag.sh</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Simple script that will display docker repository tags.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line"><span class="comment">#   $ docker-show-repo-tags.sh ubuntu centos</span></span><br><span class="line"><span class="keyword">for</span> Repo <span class="keyword">in</span> $* ; <span class="keyword">do</span></span><br><span class="line">  curl -s -S <span class="string">"https://registry.hub.docker.com/v2/repositories/library/<span class="variable">$Repo</span>/tags/"</span> | \</span><br><span class="line">    sed -e <span class="string">'s/,/,\n/g'</span> -e <span class="string">'s/\[/\[\n/g'</span> | \</span><br><span class="line">    grep <span class="string">'"name"'</span> | \</span><br><span class="line">    awk -F\<span class="string">" '&#123;print <span class="variable">$4</span>;&#125;' | \</span></span><br><span class="line"><span class="string">    sort -fu | \</span></span><br><span class="line"><span class="string">    sed -e "</span>s/^/<span class="variable">$&#123;Repo&#125;</span>:/<span class="string">"</span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure><p>然后在终端运行<code>$ ./docker-show-repo-tags.sh elasticsearch</code>即可获得结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">elasticsearch:8.0.1</span><br><span class="line">elasticsearch:8.1.0</span><br><span class="line">elasticsearch:8.1.1</span><br><span class="line">elasticsearch:8.1.2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;倒排索引&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#倒排索引&quot;&gt;&lt;/a&gt; 倒排索引&lt;/h2&gt;
&lt;p&gt;反向索引（inverted index）更熟悉的名字是倒排索引。&lt;/p&gt;
&lt;p&gt;什么是倒排索引: 倒排索引也叫反向索引，通俗来讲正向
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法与数据结构——滑动窗口、尺取法</title>
    <link href="https://nymrli.top/2022/04/10/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>https://nymrli.top/2022/04/10/算法与数据结构——滑动窗口/</id>
    <published>2022-04-10T03:14:53.000Z</published>
    <updated>2022-04-11T08:35:58.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Sliding window algorithm is used to perform required operation on specific window size of given large buffer or array.滑动窗口算法是在给定<strong>特定窗口大小</strong>的<u>数组或字符串</u>上执行要求的操作。</p><p>This technique shows how a nested for loop in few problems can be converted to single for loop and hence reducing the time complexity.该技术可以将一部分问题中的嵌套循环转变为一个单循环，因此它可以减少时间复杂度。</p></blockquote><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p>滑动窗口是一种基于双指针的一种思想，两个指针指向的元素之间形成一个窗口，可以看做是一种双指针方法的特例。</p><p>窗口的做法分为定长窗口和不定长窗口，有些人把涉及窗口移动的都统称为<strong>滑动窗口</strong>做法。而在此，我们进行进一步的细分：</p><ul><li>定长滑动窗口</li><li>变长滑动窗口——尺取法</li></ul><p><strong>应用</strong>：</p><blockquote><p>利用窗口的特性，可以用来解决一些查找满足一定条件的<strong>连续区间的</strong>性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过<u>旧有的计算结果</u>进行修改，从而对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。</p></blockquote><p>Q：那么，具体什么情况可以用滑动窗口来解决实际问题呢？</p><ol><li>一般给出的数据结构是<u>数组或者字符串</u></li><li>求取某个子串或者<u>子序列</u><u>最长最短等最值问题</u>或者求某个目标值时</li><li>该问题<u>本身可以通过暴力求解</u>——★滑动窗口跟双指针一样，针对一些问题能降低时间复杂度。</li></ol><h2 id="核心思路"><a class="markdownIt-Anchor" href="#核心思路"></a> <strong>核心思路</strong></h2><p><strong>窗口的形成</strong></p><p>在具体使用之前，我们知道窗口实际是两个指针之间形成的区域，那关键就是这两个指针是如何移动的。</p><p>《挑战程序设计竞赛》这本书中把滑动窗口叫做「虫取法」，这也非常生动形象。因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：前脚(right指针)不动，把后脚(left指针)移动过来；后脚不动，把前脚向前移动。</p><p>滑动窗口中用到了左右两个指针，它们移动的思路是：<strong>以右指针作为驱动，拖着左指针向前走。<u>右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步</u>。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间</strong>。</p><p>为了得到符合要求的最长子数组的长度，应遵循以下两点原则：</p><ul><li>当 start 的值固定时，end 的值应尽可能大；</li><li>当 end 的值固定时, start 的值应尽可能小。</li></ul><p><strong>模板的执行思想是：</strong></p><ol><li>定义两个指针 left 和 right 分别指向区间的开头和结尾，注意是<strong>闭区间</strong>；定义 sums 用来统计该区间内的各个字符出现次数；</li><li>第一重 while 循环是为了判断 right 指针的位置是否超出了数组边界；当 right 每次到了新位置，需要增加 right 指针的求和/计数 --&gt; sum；</li><li>第二重 while 循环是让 left 指针向右移动到 [left, right] 区间符合题意的位置；当 left 每次移动到了新位置，需要减少 left 指针的求和/计数；</li><li>在第二重 while 循环之后，成功找到了一个符合题意的 [left, right] 区间，便跳出循环，更新题目要求最大的区间长度，即 <code>res = max(res, right - left + 1)</code>。</li><li>right 指针每次向右移动一步，开始探索新的区间。</li></ol><h2 id="代码模板"><a class="markdownIt-Anchor" href="#代码模板"></a> 代码模板</h2><h3 id="变长窗口模板"><a class="markdownIt-Anchor" href="#变长窗口模板"></a> 变长窗口模板</h3><p>伪代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 滑动窗口模板</span></span><br><span class="line">left,right = <span class="number">0</span>, (<span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line">ans = target = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> right &lt; len(nums):</span><br><span class="line">   根据 right 更新 target 值</span><br><span class="line">   <span class="keyword">while</span> 窗口内数据不满足要求</span><br><span class="line">      <span class="comment"># 1. 更新 target 值</span></span><br><span class="line">      <span class="comment"># 2. 收缩左边界 ==&gt; 使得新窗口满足要求</span></span><br><span class="line">      <span class="comment"># or: 更新 ans： 窗口相关最小值，则在此更新</span></span><br><span class="line">    <span class="comment"># or: 更新 ans： 求窗口相关最大值，则在此更新</span></span><br><span class="line">    更新right(移动右边界)</span><br><span class="line">返回 ans</span><br></pre></td></tr></table></figure><p>具象化的Python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSubArray</span><span class="params">(nums)</span>:</span></span><br><span class="line">    N = len(nums) <span class="comment"># 数组/字符串长度</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 双指针，表示当前遍历的区间[left, right]，闭区间</span></span><br><span class="line">    sums = <span class="number">0</span> <span class="comment"># 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数</span></span><br><span class="line">    res = <span class="number">0</span> <span class="comment"># 保存最大的满足题目要求的 子数组/子串 长度</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; N: <span class="comment"># 当右边的指针没有搜索到 数组/字符串 的结尾</span></span><br><span class="line">        sums += nums[right] <span class="comment"># 增加当前右边指针的数字/字符的求和/计数</span></span><br><span class="line">        <span class="keyword">while</span> 区间[left, right]不符合题意：<span class="comment"># 此时需要一直移动左指针，直至找到一个符合题意的区间</span></span><br><span class="line">            sums -= nums[left] <span class="comment"># 移动左指针前需要从counter中减少left位置字符的求和/计数</span></span><br><span class="line">            left += <span class="number">1</span> <span class="comment"># 真正的移动左指针，注意顺序不能跟上面一行代码写反</span></span><br><span class="line">        <span class="comment"># 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串</span></span><br><span class="line">        res = max(res, right - left + <span class="number">1</span>) <span class="comment"># 需要更新结果</span></span><br><span class="line">        right += <span class="number">1</span> <span class="comment"># 移动右指针，去探索新的区间</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>另一种模板：</p><blockquote><p>(right++在前)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">string s, t;</span><br><span class="line">    <span class="comment">// 在 s 中寻找 t 的「最小覆盖子串」</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    string res = s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">        window.add(s[right]);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 如果符合要求，说明窗口构造完成，移动 left 缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> (window 符合要求) &#123;</span><br><span class="line">            <span class="comment">// 如果这个窗口的子串更短，则更新 res</span></span><br><span class="line">            <span class="comment">// or: ans更新位置</span></span><br><span class="line">            res = minLen(res, window);</span><br><span class="line">            window.remove(s[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// or: ans更新位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h3 id="固定长窗口模板"><a class="markdownIt-Anchor" href="#固定长窗口模板"></a> <a href="https://www.cnblogs.com/huansky/p/13488234.html" target="_blank" rel="noopener">固定长窗口模板：</a></h3><blockquote><p>right更新在第一层while最后，且while中没有<code>if (right &gt; k)</code>类似的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxVowels</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> maxAns = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 初始构造定长窗口</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; k) &#123;</span><br><span class="line">            <span class="comment">// 更新这段初始化窗口中的 target 值</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ★更新 ans 值 maxAns = Math.max(maxAns, );</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 让 right (有边界)</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="comment">// 更新 target 值</span></span><br><span class="line">            <span class="comment">// 更新 ans 值 maxAns = Math.max(maxAns, );</span></span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch == <span class="string">'a'</span> || ch == <span class="string">'e'</span> || ch == <span class="string">'i'</span> || ch == <span class="string">'o'</span> || ch == <span class="string">'u'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种模板：</p><blockquote><ul><li>(right++在前) --&gt; 这个是可以调整的，相应地修改<code>if</code></li><li>有<code>if right &gt; k</code>的判断，即窗口是否已经构造完成</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定窗口大小为 k</span></span><br><span class="line">   <span class="built_in">string</span> s;</span><br><span class="line">   <span class="comment">// 在 s 中寻找窗口大小为 k 时的所包含最大元音字母个数</span></span><br><span class="line">   <span class="keyword">int</span>  right = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">       window.add(s[right]);</span><br><span class="line">       <span class="comment">// 注：如果放最后，则下面的if改成 right &gt; k</span></span><br><span class="line">       right++;</span><br><span class="line">       <span class="comment">// 如果符合要求，说明窗口构造完成，</span></span><br><span class="line">       <span class="keyword">if</span> (right&gt;=k) &#123;</span><br><span class="line">           <span class="comment">// 这是已经是一个窗口了，根据条件做一些事情</span></span><br><span class="line">          <span class="comment">// ... 可以计算窗口最大值等 </span></span><br><span class="line">           <span class="comment">// 最后不要忘记把 right - k 位置元素从窗口里面移除</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>可以发现此时不需要依赖 left 指针了。因为窗口固定所以其实就没必要使用left。可以直接通过 right 指针来控制窗口。</p><p>由于窗口是固定的，因此可以轻易获取到 left 的位置，此处 left = right - k，所以在第二层while中可以通过<code>nums[right-k]</code>来获得left位置得值，从而从窗口中删除。</p><p>注： 虽然提供了两种模板，但不要贪多，跟二分模板一样，只要记住一种就行了。</p><h2 id="easy-point"><a class="markdownIt-Anchor" href="#easy-point"></a> easy point:</h2><ul><li>窗口的长度: <code>right - left + 1</code>，</li><li>假设窗口长度为k，则窗口内容为<code>[right-k+1, right-k+2, ..., right]</code>，要被剔除的<code>left</code>的索引为<code>right-k</code>：固定长窗口的题目中，可以通过right位置找到left位置。</li></ul><h2 id="一起做几题"><a class="markdownIt-Anchor" href="#一起做几题"></a> 一起做几题</h2><ul><li><a href="https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">1456. 定长子串中元音的最大数目</a>——固定长窗口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxVowels</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> maxAns = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = &#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'u'</span>, <span class="string">'o'</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (right - left + <span class="number">1</span> &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (contains(chars, s.charAt(right))) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxAns = Math.max(maxAns, ans);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (contains(chars, s.charAt(right))) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 被排除的是元音</span></span><br><span class="line">            <span class="keyword">if</span> (contains(chars, s.charAt(right - k))) &#123;</span><br><span class="line">                ans -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxAns = Math.max(maxAns, ans);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">char</span> chars[], <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的做法:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxVowels</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            sum += isYuan(s.charAt(right)) ;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (right &gt;=k) &#123;</span><br><span class="line">                max = Math.max(max, sum);</span><br><span class="line">                sum -= isYuan(s.charAt(right-k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isYuan</span><span class="params">(<span class="keyword">char</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s==<span class="string">'a'</span> || s==<span class="string">'e'</span> ||s==<span class="string">'i'</span> ||s==<span class="string">'o'</span> ||s==<span class="string">'u'</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener"> #3 无重复字符的最长子串</a> ——用set来模拟窗口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="comment">// 把删除之前s.charAt(right)位置内所有的字符</span></span><br><span class="line">            <span class="keyword">while</span> (set.contains(s.charAt(right))) &#123;</span><br><span class="line">                set.remove(s.charAt(left++));</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(s.charAt(right));</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener"> #209 长度最小的子数组</a> —— 变长窗口板子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( right &lt; len) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                <span class="comment">// 由于需要求最小, 因此这边在left收缩过程中更新minVal</span></span><br><span class="line">                minLen = Math.min(minLen, right - left +<span class="number">1</span>);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener"> #1004 最大连续1的个数 III</a> —— 变长窗口板子略有变形</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> zeroTimes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = nums[right];</span><br><span class="line">            <span class="comment">// 把当前修改成1</span></span><br><span class="line">            <span class="keyword">if</span> (now == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroTimes ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果欠了k，则需要从左边进行挪动补偿；保证下一次添加nums[right]时 k一定非负</span></span><br><span class="line">            <span class="keyword">while</span>( zeroTimes &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == <span class="number">0</span>) &#123;</span><br><span class="line">                    zeroTimes--;</span><br><span class="line">                &#125;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获得最大长度</span></span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener"> #643 子数组最大平均数 I</a>——固定长窗口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; k) &#123;</span><br><span class="line">          sum += nums[i++];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">double</span> maxV = -<span class="number">10000</span>;</span><br><span class="line">      maxV = Math.max(maxV, (<span class="keyword">double</span>) sum / k);</span><br><span class="line">      <span class="keyword">for</span> (; i &lt; nums.length; i++) &#123;</span><br><span class="line">          sum = sum - nums[i - k] + nums[i];</span><br><span class="line">          maxV = Math.max(maxV, (<span class="keyword">double</span>) sum / k);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> maxV;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener"> #219 存在重复元素 II</a>——使用set作为窗口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化构造窗口</span></span><br><span class="line">        <span class="keyword">while</span> (set.size() &lt; k) &#123;</span><br><span class="line">            set.add(nums[right++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.length)</span><br><span class="line">            <span class="keyword">if</span> (set.contains(nums[right])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.remove(nums[right-k]);</span><br><span class="line">            set.add(nums[right]);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a>——固定长窗口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> plen = p.length();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 保证p比s短</span></span><br><span class="line">        <span class="keyword">if</span> (plen &gt; len) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span>[] mp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] targetmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> mpSize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 记录p中各个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plen; i++) &#123;</span><br><span class="line">            targetmp[ p.charAt(i) - <span class="string">'a'</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            mp[c-<span class="string">'a'</span>]++; mpSize++;</span><br><span class="line">            <span class="comment">// while和if效果是一样的，因为mp大小是通过right一次次增大的</span></span><br><span class="line">            <span class="keyword">if</span> (mpSize &gt; plen) &#123;</span><br><span class="line">                <span class="comment">// 缩小左边界</span></span><br><span class="line">                <span class="keyword">char</span> removeChar = s.charAt(right - plen);</span><br><span class="line">                mpSize--;</span><br><span class="line">                mp[removeChar-<span class="string">'a'</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right(mp, targetmp)) &#123;</span><br><span class="line">                list.add(right - plen + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span>[] chars1, <span class="keyword">int</span>[] chars2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars1[i] != chars2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/" target="_blank" rel="noopener">1208. 尽可能使字符串相等</a>——变长窗口板子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(String s, String t, <span class="keyword">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 现在已经花费的cost</span></span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            cost += Math.abs(s.charAt(right) - t.charAt(right));</span><br><span class="line">            <span class="comment">// 此时cost不满足条件</span></span><br><span class="line">            <span class="keyword">while</span> (cost &gt; maxCost) &#123;</span><br><span class="line">                <span class="comment">// 通过移动left, 将cost补偿回来</span></span><br><span class="line">                cost -= Math.abs(s.charAt(left) - t.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求最大长度，则更新在第一层while里面</span></span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值(困难)</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = nums[right];</span><br><span class="line">            <span class="comment">// 保持list递减</span></span><br><span class="line">            <span class="keyword">while</span> (!list.isEmpty() &amp;&amp; list.peekLast() &lt; now) &#123;</span><br><span class="line">                list.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            list.addLast(now);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (right &gt;= k) &#123;</span><br><span class="line">                ans[idx++] = list.peekFirst();</span><br><span class="line">                <span class="comment">// 下一次的时候将不会再在窗口里面， 所以判断是否出局</span></span><br><span class="line">                <span class="keyword">if</span> (list.peekFirst() == nums[right - k]) &#123;</span><br><span class="line">                    list.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a>——固定长度窗口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一开始都没看出来怎么需要用到窗口， 后来发现s1的排列必须是s2的子串, 所以字符是相同的, 子串长度也是固定。 所以是道定长窗口题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            arr1[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = s1.length(), right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s2.length();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            arr2[s2.charAt(right) - <span class="string">'a'</span>]++;</span><br><span class="line">            cnt ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; k) &#123;</span><br><span class="line">                arr2[ s2.charAt(right - k) - <span class="string">'a'</span>]--;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (contains(arr1, arr2)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 一旦arr2不符合</span></span><br><span class="line">            <span class="keyword">if</span> (arr1[i] &gt; arr2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章：</h2><ul><li><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/" target="_blank" rel="noopener">分享滑动窗口模板，秒杀滑动窗口问题</a>——形象的理解：虫取法</li><li><a href="https://www.cnblogs.com/huansky/p/13488234.html" target="_blank" rel="noopener">滑动窗口算法基本原理与实践</a>——例题+模板</li><li><a href="https://blog.csdn.net/Dby_freedom/article/details/89066140" target="_blank" rel="noopener">算法与数据结构（一）：滑动窗口法总结</a>——概念+例题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Sliding window algorithm is used to perform required operation on specific window size of given large buffer or array.滑动窗口算法
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://nymrli.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>[翻译]设计Pastebin.com(or Bit.ly)系统</title>
    <link href="https://nymrli.top/2022/04/05/%E7%BF%BB%E8%AF%91-%E8%AE%BE%E8%AE%A1Pastebin-com-or-Bit-ly-%E7%B3%BB%E7%BB%9F/"/>
    <id>https://nymrli.top/2022/04/05/翻译-设计Pastebin-com-or-Bit-ly-系统/</id>
    <published>2022-04-05T09:34:50.000Z</published>
    <updated>2022-04-05T11:30:43.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计pastebincom"><a class="markdownIt-Anchor" href="#设计pastebincom"></a> <a href="http://xn--Pastebin-xx5xji.com" target="_blank" rel="noopener">设计Pastebin.com</a> (or <a href="http://Bit.ly" target="_blank" rel="noopener">Bit.ly</a>)系统</h1><p>注：本文档直接链接到系统设计主题中的相关领域，以避免重复。请参考链接内容来了解总体的讨论要点、利弊权衡以及替代方案。</p><p>**设计<a href="https://www.baidu.com/s?wd=bit.ly&amp;rsv_spt=1&amp;rsv_iqid=0x97c01cce002338c1&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=0&amp;rsv_dl=tb&amp;oq=bit.ly&amp;rsv_btype=t&amp;rsv_t=e8762eu5%2B6DVVq%2BNlFhLqorUp3QSNtSJ5UjqS%2FLmbVRjAw3gHUzdZ5VW%2F%2BJORNxD3z1%2F&amp;rsv_sug3=7&amp;rsv_sug1=7&amp;rsv_sug7=100&amp;rsv_pq=ce550397001e64ee&amp;prefixsug=bit.ly&amp;rsp=1&amp;rsv_sug4=5598" target="_blank" rel="noopener">Bit.ly</a>**是一个类似的问题。只是Pastebin还具有一个额外的功能，即存储粘贴的内容，而不是原始的未缩短过的url。</p><h2 id="第一步列出用例和约束的大纲"><a class="markdownIt-Anchor" href="#第一步列出用例和约束的大纲"></a> 第一步：列出用例和约束的大纲</h2><blockquote><p>确定应用场景：收集需求和范围问题；提问来弄清阐明用例和约束，讨论来作出假设。</p></blockquote><p>在没有面试官来阐明清这些问题的情况下，我们将定义一些用例和约束。</p><h3 id="用例"><a class="markdownIt-Anchor" href="#用例"></a> 用例</h3><h4 id="我们将确定问题的范围只处理以下使用情况"><a class="markdownIt-Anchor" href="#我们将确定问题的范围只处理以下使用情况"></a> 我们将确定问题的范围，只处理以下使用情况</h4><ul><li><strong>用户</strong>：输入一段文本后，获得一个随机生成的链接<ul><li>过期<ul><li>默认设置是不会过期的</li><li>可以选择一个时间过期</li></ul></li></ul></li><li><strong>用户</strong>：输入一个paste的url链接，便可以看到内容</li><li><strong>用户</strong>：是匿名的</li><li><strong>服务</strong>：可以追踪得到页面分析结果<ul><li>每月的访问数据</li></ul></li><li><strong>服务</strong>：删除过期的pasten内容</li><li><strong>服务</strong>：具有高可用性</li></ul><h4 id="范围之外"><a class="markdownIt-Anchor" href="#范围之外"></a> 范围之外</h4><ul><li><strong>用户</strong>：注册一个帐户<ul><li><strong>用户</strong>：认证邮箱</li></ul></li><li><strong>用户</strong>：登录注册账户<ul><li><strong>用户</strong>：编辑文档</li></ul></li><li><strong>用户</strong>：可以设置可见性</li><li><strong>用户</strong>：可以设置短链接</li></ul><h3 id="约束和假设"><a class="markdownIt-Anchor" href="#约束和假设"></a> 约束和假设</h3><h4 id="情况假设"><a class="markdownIt-Anchor" href="#情况假设"></a> 情况假设</h4><ul><li>流量不是均匀分布的</li><li>产生一个短链接应该是快速的</li><li>粘贴paste内容只能是文本</li><li>页面浏览分析不需要是实时的</li><li>1000万用户</li><li>每月1000万次的粘贴paste写入量</li><li>每月1亿次的粘贴paste阅读</li><li>10:1的读与写比例</li></ul><h3 id="计算用量"><a class="markdownIt-Anchor" href="#计算用量"></a> 计算用量</h3><p><strong>向你的面试官说明你是否应该对用量进行粗略估计。</strong></p><ul><li>每次粘贴paste的大小<ul><li>每次粘贴的内容为1KB</li><li><code>shortlink</code>- 7 bytes</li><li><code>expiration_length_in_minutes</code> - 4 bytes</li><li><code>created_at</code> - 5 bytes</li><li><code>paste_path</code> - 255 bytes</li><li><code>total</code> = ~1.27 KB</li></ul></li><li>每月12.7GB的新粘贴内容<ul><li>每个1.27 KB 的粘贴paste * 每月1000万个paste</li><li>3年内约有450GB的新粘贴内容</li><li>3年内有3.6亿个短链接</li><li>假设大多数是新的粘贴内容，而不是对现有内容的更新</li></ul></li><li>平均每秒钟写4次粘贴内容</li><li>平均每秒40次读取请求</li></ul><p>方便的转换指南：</p><ul><li>每月250万秒</li><li>每秒1个请求=每月250万个请求</li><li>每秒40个请求=每月1亿个请求</li><li>每秒400个请求=每月10亿个请求</li></ul><h2 id="第二步-创建一个高水平的设计"><a class="markdownIt-Anchor" href="#第二步-创建一个高水平的设计"></a> 第二步: 创建一个高水平的设计</h2><blockquote><p>勾勒出一个包含所有重要组成部分的高层次设计。</p></blockquote><p><img src="http://i.imgur.com/BKsBnmG.png" alt="Imgur"></p><h2 id="第三步设计核心组件"><a class="markdownIt-Anchor" href="#第三步设计核心组件"></a> 第三步：设计核心组件</h2><p><strong>用例: 用户输入一段文本后，获得一个随机生成的链接</strong></p><p>我们可以使用一个<a href="https://github.com/donnemartin/system-design-primer#relational-database-management-system-rdbms" target="_blank" rel="noopener">关系数据库</a>作为一个大的哈希表，将生成的url映射到文件服务器和包含粘贴paste文件的路径。</p><p>我们不采用管理文件服务器的方式，而是使用一个可管理的<strong>对象存储</strong>，如Amazon S3或<a href="https://github.com/donnemartin/system-design-primer#document-store" target="_blank" rel="noopener">NoSQL文档存储</a>。</p><p>作为一个大型哈希表的关系数据库的替代品，我们可以使用<a href="https://github.com/donnemartin/system-design-primer#key-value-store" target="_blank" rel="noopener">NoSQL键值存储</a>。我们应该讨论<a href="https://github.com/donnemartin/system-design-primer#sql-or-nosql" target="_blank" rel="noopener">选择SQL或NoSQL之间的利弊权衡</a>。下面的讨论使用了关系型数据库的方法。</p><ul><li><strong>客户端</strong>向作为反向代理的<strong>web服务器</strong>发送一个创建粘贴paste请求</li><li><strong>web服务器</strong>将该请求转发给 <strong>Write API 服务器</strong></li><li><strong>Write API 服务器</strong>做以下工作。<ul><li>生成一个唯一的url<ul><li>通过查看<strong>SQL数据库</strong>是否有重复的网址，来检查该网址是否是唯一的。</li><li>如果url不是唯一的，它将生成另一个网址</li><li>如果我们支持自定义url，我们可以使用用户提供的url（也检查是否有重复的）。</li></ul></li><li>保存到<strong>SQL数据库</strong>中的<code>粘贴paste</code>表</li><li>将粘贴的数据保存到<strong>对象存储</strong>中</li><li>返回url</li></ul></li></ul><p><strong>与你的面试官明确说明你要写多少代码</strong></p><p><code>pastes</code>表的结构可以设计成下面的样子。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shortlink char(7) NOT NULL</span><br><span class="line">expiration_length_in_minutes int NOT NULL</span><br><span class="line">created_at datetime NOT NULL</span><br><span class="line">paste_path varchar(255) NOT NULL</span><br><span class="line">PRIMARY KEY(shortlink)</span><br></pre></td></tr></table></figure><p>将主键设置为基于<code>shortlink</code>列的<a href="https://github.com/donnemartin/system-design-primer#use-good-indices" target="_blank" rel="noopener">索引</a>，数据库会使用这个索引来强制执行唯一性。我们将在<code>creative_at</code>上创建一个额外的索引，以加快查询速度（用日志时间代替扫描整个表），并将数据保存在内存中。从内存中连续读取1MB的数据需要250微秒，而从SSD中读取需要4倍，从磁盘中读取需要80倍的时间。<sup><a href="https://github.com/donnemartin/system-design-primer#latency-numbers-every-programmer-should-know" target="_blank" rel="noopener">1</a></sup></p><p>为了生成唯一的url，我们可以:</p><ul><li>对用户的<code>ip_address</code> + 时间戳进行<a href="https://en.wikipedia.org/wiki/MD5" target="_blank" rel="noopener"><strong>MD5</strong></a> 哈希<ul><li>MD5是一个广泛使用的散列函数，产生一个128位的哈希值</li><li>MD5是均匀分布的</li><li>另外，我们也可以取随机生成的数据的MD5哈希值</li></ul></li><li>使用<a href="https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/" target="_blank" rel="noopener"><strong>Base62</strong></a>对MD5哈希结果值进行编码<ul><li>Base 62 编码字符为<code>[a-zA-Z0-9]</code>，不需要转义特殊字符，这对Urls来说很有效。</li><li>原始输入只有一个哈希结果，而且Base 62是确定性的（不涉及随机性）。</li><li>Base 64 是另一种流行的编码，但由于有额外的<code>+</code>和<code>/</code>字符，所以对urls有问题。</li><li>下面的<a href="http://stackoverflow.com/questions/742013/how-to-code-a-url-shortener" target="_blank" rel="noopener">Base 62伪代码</a>在O(k)时间内运行，其中k=7。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base_encode</span><span class="params">(num, base=<span class="number">62</span>)</span>:</span></span><br><span class="line">    digits = []</span><br><span class="line">    <span class="keyword">while</span> num &gt; <span class="number">0</span></span><br><span class="line">      remainder = modulo(num, base)</span><br><span class="line">      digits.push(remainder)</span><br><span class="line">      num = divide(num, base)</span><br><span class="line">    digits = digits.reverse</span><br></pre></td></tr></table></figure><ul><li>取输出的前7个字符，结果是62^7个可能的值，应该足以处理我们3年内3.6亿个短链接的约束。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url = base_encode(md5(ip_address+timestamp))[:URL_LENGTH]</span><br></pre></td></tr></table></figure><p>我们将使用一个公共<a href="https://github.com/donnemartin/system-design-primer#representational-state-transfer-rest" target="_blank" rel="noopener"><strong>REST API</strong></a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST --data <span class="string">'&#123; "expiration_length_in_minutes": "60", \</span></span><br><span class="line"><span class="string">    "paste_contents": "Hello World!" &#125;'</span> https://pastebin.com/api/v1/paste</span><br></pre></td></tr></table></figure><p>Response:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"shortlink"</span>: <span class="string">"foobar"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于内部通信，我们可以使用<a href="https://github.com/donnemartin/system-design-primer#remote-procedure-call-rpc" target="_blank" rel="noopener">远程过程调用</a>。</p><h3 id="用例用户输入一个paste-url并查看其内容"><a class="markdownIt-Anchor" href="#用例用户输入一个paste-url并查看其内容"></a> 用例：用户输入一个paste url并查看其内容</h3><ul><li><strong>客户端</strong>向<strong>web服务器</strong>发送一个获取粘贴paste的请求</li><li><strong>Web服务器</strong>将该请求转发给 <strong>Read API 服务器</strong></li><li><strong>Read API服务器</strong>做以下工作。<ul><li>检查<strong>SQL数据库</strong>中生成的url<ul><li>如果url在<strong>SQL数据库</strong>中，则从<strong>对象存储</strong>中获取粘贴内容</li><li>否则，给用户返回一个错误信息</li></ul></li></ul></li></ul><p>REST API:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://pastebin.com/api/v1/paste?shortlink=foobar</span><br></pre></td></tr></table></figure><p>Response:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"paste_contents"</span>: <span class="string">"Hello World"</span></span><br><span class="line">    <span class="string">"created_at"</span>: <span class="string">"YYYY-MM-DD HH:MM:SS"</span></span><br><span class="line">    <span class="string">"expiration_length_in_minutes"</span>: <span class="string">"60"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用例网页跟踪分析服务"><a class="markdownIt-Anchor" href="#用例网页跟踪分析服务"></a> 用例：网页跟踪分析服务</h3><p>由于实时分析不是一个要求，我们可以简单地对<strong>Web服务器</strong>的日志进行 <strong>MapReduce</strong> 以生成点击数。</p><p><strong>与你的面试官明确说明你要写多少代码</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HitCounts</span><span class="params">(MRJob)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extract_url</span><span class="params">(self, line)</span>:</span></span><br><span class="line">        <span class="string">"""Extract the generated url from the log line."""</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extract_year_month</span><span class="params">(self, line)</span>:</span></span><br><span class="line">        <span class="string">"""Return the year and month portions of the timestamp."""</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapper</span><span class="params">(self, _, line)</span>:</span></span><br><span class="line">        <span class="string">"""Parse each log line, extract and transform relevant lines.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Emit key value pairs of the form:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        (2016-01, url0), 1</span></span><br><span class="line"><span class="string">        (2016-01, url0), 1</span></span><br><span class="line"><span class="string">        (2016-01, url1), 1</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        url = self.extract_url(line)</span><br><span class="line">        period = self.extract_year_month(line)</span><br><span class="line">        <span class="keyword">yield</span> (period, url), <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer</span><span class="params">(self, key, values)</span>:</span></span><br><span class="line">        <span class="string">"""Sum values for each key.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        (2016-01, url0), 2</span></span><br><span class="line"><span class="string">        (2016-01, url1), 1</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">yield</span> key, sum(values)</span><br></pre></td></tr></table></figure><h3 id="用例删除过期paste的服务"><a class="markdownIt-Anchor" href="#用例删除过期paste的服务"></a> 用例：删除过期paste的服务</h3><p>要删除过期的粘贴，我们可以直接扫描<strong>SQL数据库</strong>中所有过期时间戳大于当前时间戳的条目。然后，所有过期的条目将被从表中删除（或标记为过期）。</p><h2 id="第四步扩展设计"><a class="markdownIt-Anchor" href="#第四步扩展设计"></a> 第四步：扩展设计</h2><blockquote><p>鉴于约束条件，识别并解决瓶颈问题。</p></blockquote><p><img src="http://i.imgur.com/4edXG0T.png" alt="Imgur"></p><p><strong>重要：不要简单地从最初的设计直接跳到最终的设计中去!</strong></p><p>说明你会迭代地做这件事。1) <strong>基准测试/负载测试</strong>；2) <strong>剖析</strong>瓶颈；3) 解决瓶颈问题，同时评估替代方案和利弊权衡；4) 重复。参看<a href="../scaling_aws/README.md">设计一个可以在AWS上扩展到数百万用户的系统</a>，作为一个如何对初始设计进行迭代扩展的样例。</p><p>讨论初始设计可能遇到的瓶颈以及如何解决每个瓶颈是很重要的。例如，通过添加一个带有多个<strong>Web服务器</strong>的<strong>负载平衡器</strong>、<strong>CDN</strong>、<strong>主从复制</strong>，可以解决哪些问题？各自的替代方案和<strong>利弊权衡</strong>是什么？</p><p>我们将介绍一些组件来完成设计并解决可扩展性问题。内部负载均衡器没有显示，以减少混乱。</p><p><em>为了避免重复讨论</em>，请参考下面的<a href="https://github.com/donnemartin/system-design-primer#index-of-system-design-topics" target="_blank" rel="noopener">系统设计主题</a>来了解主要的论文要点、利弊权衡和替代方案。</p><ul><li><a href="https://github.com/donnemartin/system-design-primer#domain-name-system" target="_blank" rel="noopener">DNS</a></li><li><a href="https://github.com/donnemartin/system-design-primer#content-delivery-network" target="_blank" rel="noopener">CDN</a></li><li><a href="https://github.com/donnemartin/system-design-primer#load-balancer" target="_blank" rel="noopener">Load balancer</a></li><li><a href="https://github.com/donnemartin/system-design-primer#horizontal-scaling" target="_blank" rel="noopener">Horizontal scaling</a></li><li><a href="https://github.com/donnemartin/system-design-primer#reverse-proxy-web-server" target="_blank" rel="noopener">Web server (reverse proxy)</a></li><li><a href="https://github.com/donnemartin/system-design-primer#application-layer" target="_blank" rel="noopener">API server (application layer)</a></li><li><a href="https://github.com/donnemartin/system-design-primer#cache" target="_blank" rel="noopener">Cache</a></li><li><a href="https://github.com/donnemartin/system-design-primer#relational-database-management-system-rdbms" target="_blank" rel="noopener">Relational database management system (RDBMS)</a></li><li><a href="https://github.com/donnemartin/system-design-primer#fail-over" target="_blank" rel="noopener">SQL write master-slave failover</a></li><li><a href="https://github.com/donnemartin/system-design-primer#master-slave-replication" target="_blank" rel="noopener">Master-slave replication</a></li><li><a href="https://github.com/donnemartin/system-design-primer#consistency-patterns" target="_blank" rel="noopener">Consistency patterns</a></li><li><a href="https://github.com/donnemartin/system-design-primer#availability-patterns" target="_blank" rel="noopener">Availability patterns</a></li></ul><p><strong>数据库分析</strong>可以使用数据仓库解决方案，如亚马逊 Redshift 或谷歌 BigQuery。</p><p>像亚马逊S3这样的<strong>对象存储</strong>可以从容地处理每月12.7 GB 的新内容的约束。</p><p>为了解决每秒40次的平均读取请求（高峰时更高），热门内容的流量应该由<strong>内存缓存</strong>而不是数据库来处理。<strong>内存缓存</strong>对于处理分布不均的流量和流量高峰也很有用。<strong>SQL Read 多副本</strong>应该能够处理缓存的缺失，只要副本没有被副本写入所拖累。</p><p>对于单个<strong>SQL Write 主从</strong>来说，每秒<em>平均</em>4次粘贴写（高峰时更多）应该是可以做到的。否则，我们就需要采用额外的SQL扩展模式。</p><ul><li><a href="https://github.com/donnemartin/system-design-primer#federation" target="_blank" rel="noopener">Federation</a></li><li><a href="https://github.com/donnemartin/system-design-primer#sharding" target="_blank" rel="noopener">Sharding</a></li><li><a href="https://github.com/donnemartin/system-design-primer#denormalization" target="_blank" rel="noopener">Denormalization</a></li><li><a href="https://github.com/donnemartin/system-design-primer#sql-tuning" target="_blank" rel="noopener">SQL Tuning</a></li></ul><p>我们还应该考虑将一些数据转移到<strong>NoSQL数据库</strong>。</p><h2 id="额外的讨论要点"><a class="markdownIt-Anchor" href="#额外的讨论要点"></a> 额外的讨论要点</h2><blockquote><p>根据问题的范围和剩余时间，可以深入研究其他的话题。</p></blockquote><h4 id="nosql"><a class="markdownIt-Anchor" href="#nosql"></a> NoSQL</h4><ul><li><a href="https://github.com/donnemartin/system-design-primer#key-value-store" target="_blank" rel="noopener">Key-value store</a></li><li><a href="https://github.com/donnemartin/system-design-primer#document-store" target="_blank" rel="noopener">Document store</a></li><li><a href="https://github.com/donnemartin/system-design-primer#wide-column-store" target="_blank" rel="noopener">Wide column store</a></li><li><a href="https://github.com/donnemartin/system-design-primer#graph-database" target="_blank" rel="noopener">Graph database</a></li><li><a href="https://github.com/donnemartin/system-design-primer#sql-or-nosql" target="_blank" rel="noopener">SQL vs NoSQL</a></li></ul><h3 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h3><ul><li>缓存到哪里？<ul><li><a href="https://github.com/donnemartin/system-design-primer#client-caching" target="_blank" rel="noopener">Client caching</a></li><li><a href="https://github.com/donnemartin/system-design-primer#cdn-caching" target="_blank" rel="noopener">CDN caching</a></li><li><a href="https://github.com/donnemartin/system-design-primer#web-server-caching" target="_blank" rel="noopener">Web server caching</a></li><li><a href="https://github.com/donnemartin/system-design-primer#database-caching" target="_blank" rel="noopener">Database caching</a></li><li><a href="https://github.com/donnemartin/system-design-primer#application-caching" target="_blank" rel="noopener">Application caching</a></li></ul></li><li>缓存什么？<ul><li><a href="https://github.com/donnemartin/system-design-primer#caching-at-the-database-query-level" target="_blank" rel="noopener">Caching at the database query level</a></li><li><a href="https://github.com/donnemartin/system-design-primer#caching-at-the-object-level" target="_blank" rel="noopener">Caching at the object level</a></li></ul></li><li>何时更新缓存？<ul><li><a href="https://github.com/donnemartin/system-design-primer#cache-aside" target="_blank" rel="noopener">Cache-aside</a></li><li><a href="https://github.com/donnemartin/system-design-primer#write-through" target="_blank" rel="noopener">Write-through</a></li><li><a href="https://github.com/donnemartin/system-design-primer#write-behind-write-back" target="_blank" rel="noopener">Write-behind (write-back)</a></li><li><a href="https://github.com/donnemartin/system-design-primer#refresh-ahead" target="_blank" rel="noopener">Refresh ahead</a></li></ul></li></ul><h3 id="异步性和微服务"><a class="markdownIt-Anchor" href="#异步性和微服务"></a> 异步性和微服务</h3><ul><li><a href="https://github.com/donnemartin/system-design-primer#message-queues" target="_blank" rel="noopener">Message queues</a></li><li><a href="https://github.com/donnemartin/system-design-primer#task-queues" target="_blank" rel="noopener">Task queues</a></li><li><a href="https://github.com/donnemartin/system-design-primer#back-pressure" target="_blank" rel="noopener">Back pressure</a></li><li><a href="https://github.com/donnemartin/system-design-primer#microservices" target="_blank" rel="noopener">Microservices</a></li></ul><h3 id="通信"><a class="markdownIt-Anchor" href="#通信"></a> 通信</h3><ul><li>对利弊权衡进行讨论：<ul><li>与客户的外部通信 - <a href="https://github.com/donnemartin/system-design-primer#representational-state-transfer-rest" target="_blank" rel="noopener">HTTP APIs following REST</a><ul><li>内部通信 - <a href="https://github.com/donnemartin/system-design-primer#remote-procedure-call-rpc" target="_blank" rel="noopener">RPC</a></li></ul></li></ul></li><li><a href="https://github.com/donnemartin/system-design-primer#service-discovery" target="_blank" rel="noopener">服务发现</a></li></ul><h3 id="安全"><a class="markdownIt-Anchor" href="#安全"></a> 安全</h3><p>见 <a href="https://github.com/donnemartin/system-design-primer#security" target="_blank" rel="noopener">security section</a>.</p><h3 id="延迟数"><a class="markdownIt-Anchor" href="#延迟数"></a> 延迟数</h3><p>见 <a href="https://github.com/donnemartin/system-design-primer#latency-numbers-every-programmer-should-know" target="_blank" rel="noopener">每个程序员应该知道的延迟数字</a>。</p><h3 id="持续推进"><a class="markdownIt-Anchor" href="#持续推进"></a> 持续推进</h3><ul><li>继续对你的系统进行基准测试和监测，以解决出现的瓶颈问题</li><li>扩展是一个反复的过程</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计pastebincom&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#设计pastebincom&quot;&gt;&lt;/a&gt; &lt;a href=&quot;http://xn--Pastebin-xx5xji.com&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="翻译" scheme="https://nymrli.top/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="系统设计" scheme="https://nymrli.top/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>理了一天彻底弄懂元类——分享给你一起弄懂</title>
    <link href="https://nymrli.top/2022/04/05/%E7%90%86%E4%BA%86%E4%B8%80%E5%A4%A9%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E5%85%83%E7%B1%BB%E2%80%94%E2%80%94%E5%88%86%E4%BA%AB%E7%BB%99%E4%BD%A0%E4%B8%80%E8%B5%B7%E5%BC%84%E6%87%82/"/>
    <id>https://nymrli.top/2022/04/05/理了一天彻底弄懂元类——分享给你一起弄懂/</id>
    <published>2022-04-05T05:26:39.000Z</published>
    <updated>2022-04-05T05:42:12.847Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是一个在看开源代码时配到了单例元类写法后的一个原理贴，可以帮你彻底弄清元类、以及<code>__new__</code>和<code>__call__</code>，相信我，看完你绝对会有收获。</p><p>首先，关于元类的结论说在前头，先有个印象——<strong>小总结</strong>：</p><ul><li>现在我们能知道为什么元类必须继承type了：因为我们实例化对象<code>Foo(xxx)</code>时调用了<code>type.__call__</code>,而<code>type.__call__</code>又会调用<code>type.__new__</code>因此如果type子类重写实现了<code>__new__</code>（返回的类实例对象的类型作控制）、<code>__call__</code>（对实例化的流程做控制），则可以对<strong>类对象的类型和类属性</strong>起到自定义的功能，而重写就必须继承type=&gt;需要元类必须继承type</li><li>所以按照上述的逻辑，如果定义了一个元类让自定义类用的话<code>class Foo(metaclass=MyMetaClass)</code>，在其实例化过程中<code>Foo()</code>会直接调用重写后的<code>MyMetaClass.__call__</code>，而只要记住在<code>MyMetaClass.__call__</code>中使用到<code>return super(Singleton, cls).__call__(*args, **kwargs)</code>就可以把<code>type.__call__</code>生成的实例返回啦。所以这也是为什么<u>编写元类，一般都是继承了type，然后根据想控制实例化流程就重写<code>__call__</code>方法，想添加属性就重写<code>__new__</code>方法就行了。</u></li><li><strong>★元类产生影响的时间点是在实例化的时候</strong></li></ul></blockquote><p>看开源代码时，看到了下面一段代码，于是对withMetaclass产生了好奇，经过了解发现其作用是six对python2和python3使用元类兼容的写法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python2和3兼容使用元类写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigHandler</span><span class="params">(withMetaclass<span class="params">(Singleton)</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>因此，上述代码在Python3中相当于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python3元类使用写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigHandler</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那么，问题来了，withMetaclass到底是怎么实现兼容的呢？下面是其实现代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">withMetaclass</span><span class="params">(meta, *bases)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span><span class="params">(meta)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, this_bases, d)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> meta(name, bases, d)</span><br><span class="line">    <span class="keyword">return</span> type.__new__(MetaClass, <span class="string">'temporary_class'</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure><p>可以看到其中出现了不少我们很少看到的使用方法。接下来我们就仔细的学习上述写法为什么可以成功。</p><p>元类使用可以参考：<a href="https://zhuanlan.zhihu.com/p/49158035" target="_blank" rel="noopener">Python3 元类（metaclass）</a></p><h3 id="预置知识type和object"><a class="markdownIt-Anchor" href="#预置知识type和object"></a> 预置知识：type和object</h3><blockquote><p>object 和 type的关系很像鸡和蛋的关系，先有object还是先有type没法说，obejct和type是共生的关系，必须同时出现的。</p><p>记住一点：<strong>在Python里面，所有的东西都是对象的概念</strong>，即包括类（类是type的实例对象）</p></blockquote><p>最重要的两点</p><ul><li>object类是所有类的超类（也是type类的父类）</li><li>type是所有类的类（类型，所有类都是type的实例对象，object<u>类型</u>也是type的实例对象；type 创建的对象拥有创建对象的能力(也就是类)）–&gt;是所有类的元类</li></ul><p>此外：</p><ul><li>type是所有<strong>元类</strong>的父亲。我们可以通过<strong>继承type来创建元类</strong>（通过重写<code>type.__new__</code>和<code>type.__call__</code>来拦截自定义类的创建过程）。</li><li>object是所有类的父亲。</li><li>实例是对象关系链的末端，不能再被子类化和实例化。</li></ul><p>了解到这些关键的点后，我们继续看代码中出现的一些内容：</p><h3 id="__new__"><a class="markdownIt-Anchor" href="#__new__"></a> <code>__new__</code></h3><blockquote><p><code>__new__()</code> 是一种负责<strong>创建类实例</strong>的<strong>静态方法</strong>，它无需使用 staticmethod 装饰器修饰，且该方法会优先 <code>__init__()</code> 初始化方法被调用。</p></blockquote><p><code>__new__()</code>通常会返回该类的一个实例，但有时也可能会返回其他类的实例，其<code>super().__new__(cls)</code>中会调用<code>object.__init__</code>来<code>Create and return a new object.</code>，因此我们可以通过改写子类的<code>__new__</code>可以添加一些逻辑来控制实例的产生，然后再通过<code>super().__new__(cls)</code>来生成一个instance并返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demoClass</span>:</span></span><br><span class="line">    instances_created = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># __new__(): &lt;class '__main__.demoClass'&gt; ('abc',) &#123;&#125;</span></span><br><span class="line">        print(<span class="string">"__new__():"</span>, cls, args, kwargs)</span><br><span class="line">        <span class="comment"># 1. 通过父类__new__生成一个实例: 调用父类object.__new__生成实例(Create and return a new object.) </span></span><br><span class="line">        instance = super().__new__(cls)</span><br><span class="line">        <span class="comment"># 2. 自己重写要实现的逻辑</span></span><br><span class="line">        instance.number = cls.instances_created</span><br><span class="line">        cls.instances_created += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 3. 将父类生成的实例返回</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, attribute)</span>:</span></span><br><span class="line">        <span class="comment"># __init__(): &lt;__main__.demoClass object at 0x00000185A6466EB0&gt; abc</span></span><br><span class="line">        print(<span class="string">"__init__():"</span>, self, attribute)</span><br><span class="line">        self.attribute = attribute</span><br><span class="line"></span><br><span class="line">test1 = demoClass(<span class="string">"abc"</span>)</span><br><span class="line">test2 = demoClass(<span class="string">"xyz"</span>)</span><br><span class="line">print(test1.number, test1.instances_created)</span><br><span class="line">print(test2.number, test2.instances_created)</span><br></pre></td></tr></table></figure><p>Q:什么情况下重写类的<code>__new__()</code>呢？答案很简单，在<code>__init__()</code>不够用的时候。</p><p><code>__new__()</code>通常会返回该类的一个实例，但有时也可能会返回其他类的实例，如果发生了这种情况，则会跳过对 <code>__init__()</code>方法的调用。而在某些情况下（比如需要修改<strong>不可变类实例</strong>（<a href="http://c.biancheng.net/python/" target="_blank" rel="noopener">Python</a> 的某些内置类型）的创建行为），利用这一点会事半功倍。比如：<a href="http://c.biancheng.net/view/5484.html%EF%BC%8C%E5%AF%B9" target="_blank" rel="noopener">http://c.biancheng.net/view/5484.html，对</a> Python 不可变的内置类型（如 int、str、float 等）进行了子类化，这是因为一旦创建了这样不可变的对象实例，就无法在<code>__init__()</code>方法中对其进行修改。</p><p>注：由于 <code>__new__()</code> 不限于返回同一个类的实例，所以很容易被滥用，不负责任地使用这种方法可能会对代码有害，所以要谨慎使用。</p><h3 id="metaclass元类"><a class="markdownIt-Anchor" href="#metaclass元类"></a> <a href="http://c.biancheng.net/view/2293.html" target="_blank" rel="noopener">MetaClass元类</a></h3><blockquote><p>承接上文<code>__new__</code>，Python中大量使用<code>__new__()</code>方法且合理的地方，就是 MetaClass 元类。</p><p>MetaClass元类，并不是某一个类的名字，它是一个概念，是一种Python的思想。当然其本质也是一个类，但和普通类的用法不同，它可以对<strong>类内部的定义</strong>（包括类属性和类方法）进行<strong>动态的修改</strong>。可以这么说，使用元类的主要目的就是为了实现在创建类时，能够动态地改变类中定义的属性或者方法。其可以将<strong>创建对象的过程拦截</strong>下来，从而对这个对象进行自定义（这个需要<strong>类继承type</strong>，与前文继承object的做区别）。</p><p>明确一点：元类可以理解成是自定义类继承的父类（从兼容写法中也能看出），但元类的特点是<strong>不会出现在自定义类的继承关系(<code>__mro__</code>)之中</strong></p></blockquote><p>举个例子，根据实际场景的需要，我们要为多个类添加一个 name 属性和一个 say() 方法。显然有多种方法可以实现，但其中一种方法就是使用 MetaClass 元类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个元类，继承type。因为只有继承type才能通过重写__new__来拦截创建过程</span></span><br><span class="line"><span class="comment"># ▲注意，继承type后__new__能拿到的参数信息跟不继承type的有天壤之别，原因继续看下去</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstMetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="comment"># cls代表元类的类: FirstMetaClass</span></span><br><span class="line">    <span class="comment"># name代表自定义类的类名: CLanguage</span></span><br><span class="line">    <span class="comment"># bases代表被动态修改的类的所有父类</span></span><br><span class="line">    <span class="comment"># attr代表被动态修改的类的所有属性、方法组成的字典</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="comment"># 动态为该类添加一个name属性</span></span><br><span class="line">        attrs[<span class="string">'name'</span>] = <span class="string">"C语言中文网"</span></span><br><span class="line">        attrs[<span class="string">'say'</span>] = <span class="keyword">lambda</span> self: print(<span class="string">"调用 say() 实例方法"</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls,name,bases,attrs)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 定义类时，指定元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLanguage</span><span class="params">(object, metaclass=FirstMetaClass)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">clangs = CLanguage()</span><br><span class="line">print(clangs.name)</span><br><span class="line">clangs.say()</span><br></pre></td></tr></table></figure><p>可以看到，在创建类时，通过在标注父类的同时指定元类（格式为<code>metaclass=元类名</code>），则当 <a href="http://c.biancheng.net/python/" target="_blank" rel="noopener">Python</a> 解释器在创建该类实例时，<code>FirstMetaClass(type)</code>元类中的<code>__new__</code>方法就会被调用，其中bases和attrs能拿到自定义类的参数，从而实现动态修改类属性或者类方法的目的。</p><p><strong>元类和父类的区别：</strong></p><p>在定义子类的时候，我们有两个选择：①是传需要继承的父类；②自定义的元类。</p><ul><li>父类是子类的模板，子类的功能是跟父类紧耦合的，子类和父类一般是一一对应的</li><li>元类是子类的修饰器，可以为该子类和其他子类都添加自定义功能，并且不在继承关系中(<code>Class.__mro__</code>查看)，子类和元类是一对多的关系。元类并不是特地为某个子类服务的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMeta3</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        print(cls)    <span class="comment"># 当前类 </span></span><br><span class="line">        print(<span class="string">"name"</span>, name)<span class="comment"># 如果是通过metaclass触发的，此处为调用metaclass的类的类型</span></span><br><span class="line">        print(<span class="string">"bases"</span>, bases)<span class="comment"># 如果是通过metaclass触发的，此处为调用metaclass的类的父类</span></span><br><span class="line">        print(<span class="string">"attrs"</span>, attrs)<span class="comment"># 如果是通过metaclass触发的，此处为调用metaclass的类的属性</span></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pa3</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python3中可以直接通过metaclass关键字参数来指定类的元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg3</span><span class="params">(Pa3, metaclass=TestMeta3)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        kkk = []</span><br><span class="line">        kkk.append(self.__skiless__)</span><br><span class="line">        <span class="keyword">return</span> kkk</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acc2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'a2'</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出</span></span><br><span class="line"><span class="string">&lt;class '__main__.TestMeta3'&gt;</span></span><br><span class="line"><span class="string">name Eg3</span></span><br><span class="line"><span class="string">bases (&lt;class '__main__.Pa3'&gt;,)</span></span><br><span class="line"><span class="string">attrs &#123;'__module__': '__main__', '__qualname__': 'Eg3', 'get': &lt;classmethod object at 0x00000263511C6FA0&gt;, 'acc2': &lt;function Eg3.acc2 at 0x00000263511C5310&gt;&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>在定义的时候，发现竟然有输出。因为定义的时候，python解释器会在当前类中查找metaclass[3]，如果找到了，就<strong>使用该metaclass创建Eg3类</strong>。所以打印出来的name、bases、attrs都和Eg3有关。</p><p><strong>with_metaclass</strong></p><blockquote><p>由于python2和python3中元类使用方法的不同，我们需要使用一种兼容的方式[1]，如下所示：</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">withMetaclass</span><span class="params">(meta, *bases)</span>:</span></span><br><span class="line">    <span class="string">"""Create a base class with a metaclass."""</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span><span class="params">(meta)</span>:</span></span><br><span class="line"><span class="comment"># 如果删除__new__，则类.__mro__中能看到meta类</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, this_bases, d)</span>:</span></span><br><span class="line">            <span class="comment"># 因为meta是类，所以这边是在调用meta的__call__()。▲bases，d为ConfigHandler的父类和属性</span></span><br><span class="line">            <span class="keyword">return</span> meta(name, bases, d)</span><br><span class="line"><span class="comment"># 返回一个新类型, type.__new__()要求第一个必须是type的子类</span></span><br><span class="line">    <span class="keyword">return</span> type.__new__(MetaClass, <span class="string">'temporary_class'</span>, (), &#123;&#125;)</span><br><span class="line"><span class="comment"># 下面两句话等价，withMetaclass是为了兼容python2和python3,2中没有metaclass关键字</span></span><br><span class="line"><span class="comment"># 其在创建实例时，__new__方法会被MetaClass拦截(其实就是子类没定义__new__，走了父类的__new__)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigHandler</span><span class="params">(withMetaclass<span class="params">(Singleton)</span>)</span></span></span><br><span class="line"><span class="class"># <span class="title">python3</span>写法</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ConfigHandler</span><span class="params">(metaclass=Singleton)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"># 因为ConfigHandler相当于继承了 type.__new__返回的类MetaClass，所以在c = ConfigHandler()实例化的时候，会触发Metaclass的__new__然后调用meta.__call__从而返回一个对象</span><br></pre></td></tr></table></figure><p><code>with_metaclass</code>返回的临时类中，本身无任何属性，但包含了元类和基类的所有信息，并在<strong>下一步定义类时</strong>将所有信息解包出来[1]。</p><p>见：<a href="https://zhuanlan.zhihu.com/p/354828950" target="_blank" rel="noopener">★Python 元类及with_metaclass</a></p><h3 id="type"><a class="markdownIt-Anchor" href="#type"></a> <a href="http://c.biancheng.net/view/2292.html" target="_blank" rel="noopener"><code>type</code>动态创建类</a></h3><ul><li>type() 函数属于 <a href="http://c.biancheng.net/python/" target="_blank" rel="noopener">Python</a> 内置函数，通常用来查看某个变量的具体类型。<ul><li><code>type(obj)</code></li></ul></li><li>其实，type() 函数还有一个更高级的用法，即<strong>创建</strong>一个自定义<strong>类型</strong>（也就是创建一个类）。<ul><li><code>type(name, bases, dict)</code>：其中 name 表示类的名称；bases 表示一个元组，其中存储的是该类的父类；dict 表示一个字典，用于表示类内定义的属性或者方法。</li></ul></li></ul><p>实际上<code>type(name, bases, dict)</code>是调用了type类的<code>type.__init__(cls, what, bases=None, dict=None)</code>方法，创建了一个type的实例（类类型就是一个type实例），类型是<code>&lt;class 'type'&gt;</code></p><p><strong>&lt;class ‘type’&gt;是所有类型的类型。&lt;class ‘object’&gt;也是所有对象的超类（除了它自己，包括type）</strong></p><p>▲. 此外type还有<code>type.__new__(*args, **kwargs)</code>，其作用是<code>Create and return a new object.</code>，可以写成<code>type.__new__(ClassTpye, name, base, dicts)</code>，但ClassType必须是type的子类。会返回一个跟ClassType有关系的新类型</p><h3 id="通过元类创建单例类"><a class="markdownIt-Anchor" href="#通过元类创建单例类"></a> 通过元类创建单例类</h3><blockquote><p>现在让我们正式看，我在开源代码里看到的内容：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这边继承了type, 所以下面的__call__是重写type的__call__，即创建实例的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Singleton Metaclass</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    _inst = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._inst:</span><br><span class="line">            cls._inst[cls] = super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._inst[cls]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">withMetaclass</span><span class="params">(meta, *bases)</span>:</span></span><br><span class="line">    <span class="string">"""Create a base class with a metaclass."""</span></span><br><span class="line">    <span class="comment"># 这需要一点解释：基本思想是为一个级别的类实例化创建一个虚拟元类，用实际的元类替换它自己。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># KeyPoint1. 继承meta类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span><span class="params">(meta)</span>:</span></span><br><span class="line">        <span class="comment"># 实际上下面的__new__不影响</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, this_bases, d)</span>:</span></span><br><span class="line">            <span class="comment"># cls为withMetaclass; name为使用者的类型; this_bases为使用者的父类们; d为使用者的属性</span></span><br><span class="line">            <span class="keyword">return</span> meta(name, bases, d)</span><br><span class="line">    <span class="comment"># KeyPoint2. type.__new__创建一个名称叫temporary_class，类型为MetaClass的类</span></span><br><span class="line">    <span class="comment"># ▲注意type.__new__中的类类型必须是type的子类</span></span><br><span class="line">    <span class="keyword">return</span> type.__new__(MetaClass, <span class="string">'temporary_class'</span>, (), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigHandler</span><span class="params">(withMetaclass<span class="params">(Singleton)</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"__init__"</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @LazyProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serverHost</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> os.environ.get(<span class="string">"HOST"</span>, setting.HOST)</span><br><span class="line"><span class="comment"># res=withMetaclass(Singleton)的类型为&lt;class 'util.six.withMetaclass.&lt;locals&gt;.MetaClass'&gt;</span></span><br><span class="line"><span class="comment"># 将其传给ConfigHandler作为父类，在定义 ConfigHandler 时会触发MetaClass.__new__, 于是调用meta(name, bases, d)，此处的meta为Singleton，而name为ConfigHandler类, bases为空, d为ConfigHandler的属性和方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(type(ConfigHandler)) ==&gt;  &lt;class 'util.singleton.Singleton'&gt;</span></span><br><span class="line"><span class="comment"># 因此 c = ConfigHandler() ==&gt; Singleton的__call__方法，</span></span><br><span class="line">当c = ConfigHandler()时会因为type.__new__(MetaClass, <span class="string">'temporary_class'</span>, (), &#123;&#125;)去找MetaClass的__call__进行调用，MetaClass没有__call__则找到了其父类meta(Singleton)的__call__</span><br></pre></td></tr></table></figure><p>注：类也是对象，是元类的对象，即我们实例化一个类时，调用其元类的<code>__call__(cls, *args, **kwargs)</code>方法进行创建对象。</p><h2 id="__call__"><a class="markdownIt-Anchor" href="#__call__"></a> <code>__call__</code></h2><blockquote><p>一个非常特殊的实例方法，即<code>__call__()</code>。该方法的功能是在类中<strong>重载了对象的 () 运算符</strong>，使得类实例对象可以像调用普通函数那样，以“<strong>对象名()</strong>”的形式使用。</p></blockquote><p>实际上，如果不重写<code>__call__</code>的话，<code>Class.__call__(*args, **kwargs)</code>还承担着产生类实例的功能（会调用父类（可以通过<code>Class.__class__</code>来查看父类）的<code>type.__call__</code>其会返回一个实例）</p><p>案例一:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认继承的是object, 而不是type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">"init"</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"call"</span>)</span><br><span class="line"><span class="comment"># 当没有重写__call__时，无论是显式的调用__call__，还是通过()运算符调用，都会调用type.__call__返回一个实例</span></span><br><span class="line">res = Meta.__call__(<span class="string">"asd"</span>)</span><br><span class="line">print(res, type(res))</span><br><span class="line">res = Meta(<span class="string">"asd"</span>)</span><br><span class="line">print(res, type(res))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">init</span></span><br><span class="line"><span class="string">&lt;__main__.Meta object at 0x0000014FB5115EE0&gt; &lt;class '__main__.Meta'&gt;</span></span><br><span class="line"><span class="string">init</span></span><br><span class="line"><span class="string">&lt;__main__.Meta object at 0x0000014FB5115A90&gt; &lt;class '__main__.Meta'&gt;</span></span><br><span class="line"><span class="string">上述两种都能创建对象</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 当重写__call__以后, __call__()返回实例的效果就失效了==&gt;因为上述代码没有return</span></span><br><span class="line"><span class="comment"># 此时 Meta()与Meta.__call__()不再等价</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">call</span></span><br><span class="line"><span class="string">None &lt;class 'NoneType'&gt;</span></span><br><span class="line"><span class="string">init</span></span><br><span class="line"><span class="string">&lt;__main__.Meta object at 0x0000016CC2745EE0&gt; &lt;class '__main__.Meta'&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>Q:我们在实例化一个对象的时候<code>f = Foo(1, y=2)</code>，可以发现在<code>__init__()</code>中并没有返回实例，但调用<code>Foo(1, y=2)</code><strong>确实</strong>返回了一个对象，而且，<code>__init__</code>预期一个<code>self</code>参数，但是当我们调用<code>Foo(1, y=2)</code>时这里并没有这个参数。那么类实例化的过程到底是怎么样的呢？</p><p>A:构造顺序——<a href="https://www.jianshu.com/p/f63ad9d550f1" target="_blank" rel="noopener">理解python的类实例化</a></p><p>首先明确一点，Python中的<strong>类也是对象</strong>！类、函数、方法以及实例都是对象——<strong>类类型是type的对象</strong>，并且无论何时你将一对括号放在它们的名字后面时，就会调用<code>type.__call__()</code>方法。为什么呢？因为type是类型的父类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>所以<code>Foo</code>是类型<code>type</code>的一个对象，并且调用type类的<code>__call__(self, *args, **kwargs)</code>返回一个<code>Foo</code>类的对象。让我们看下<code>type</code>中的<code>__call__</code>方法是什么样的。这个方法相当的复杂，但是我们将其C代码转成Python代码，并尝试尽量简化它，结果如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="comment"># 这边的obj_type跟cls一样</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(obj_type, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 通过__new__创建一个空的类实例，如果obj_type没有__new__则使用type.__new__</span></span><br><span class="line">        obj = obj_type.__new__(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 进行类型检查</span></span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> issubclass(obj, obj_type):</span><br><span class="line">            <span class="comment"># 对类进行__init__初始化</span></span><br><span class="line">            obj.__init__(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 返回类实例</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><p>可见<code>__new__</code>方法为对象分配了内存空间，构建它为一个“空&quot;对象然后<code>__init__</code>方法被调用来初始化它。</p><p>那我们定义了一个具体类来讲解这个过程。首先明确一点：<strong>Foo相对于产生了一个type实例化对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure><p>获得实例化对象**<code>Foo(*args, **kwargs)</code><strong>也可以看作是<code>type对象()</code>即</strong>调用了type中()运算符的触发的函数<code>type.__call__</code>从而创建一个Foo的实例**</p><ul><li>至于<code>type.__call__</code>发生了什么就是上面抽象代码中介绍的那般，调用<code>type.__new__(Foo, *args, **kwargs)</code>然后返回一个对象实例obj。</li><li><code>obj</code>随后通过调用<code>obj.__init__(*args, **kwargs)</code>被初始化。</li><li><code>obj</code>被<code>type.__call__</code>中返回。</li></ul><p>▲注意：<code>Foo.__call__</code>重载的是<code>foo对象</code>的()运算符，而<code>Foo()</code>实例化foo对象，则执行的是<code>type对象</code>的()运算符。</p><p><strong>小总结</strong>：</p><ul><li>现在我们能知道为什么元类必须继承type了：因为我们实例化对象<code>Foo(xxx)</code>时调用了<code>type.__call__</code>,而<code>type.__call__</code>又会调用<code>type.__new__</code>因此如果type子类重写实现了<code>__new__</code>（返回的类实例对象的类型作控制）、<code>__call__</code>（对实例化的流程做控制），则可以对<strong>类对象的类型和类属性</strong>起到自定义的功能，而重写就必须继承type=&gt;需要元类必须继承type</li><li>所以按照上述的逻辑，如果定义了一个元类让自定义类用的话<code>class Foo(metaclass=MyMetaClass)</code>，在其实例化过程中<code>Foo()</code>会直接调用重写后的<code>MyMetaClass.__call__</code>，而只要记住在<code>MyMetaClass.__call__</code>中使用到<code>return super(Singleton, cls).__call__(*args, **kwargs)</code>就可以把<code>type.__call__</code>生成的实例返回啦。所以这也是为什么<u>编写元类，一般都是继承了type，然后根据想控制实例化流程就重写<code>__call__</code>方法，想添加属性就重写<code>__new__</code>方法就行了。</u></li><li><strong>★元类产生影响的时间点是在实例化的时候</strong></li></ul><p>注意点：元类继承了type，所以实例化元类是在产生一个类类型，就要以type创建类类型的参数去产生。而元类的使用一般都是自定义类<code>class MyClass(metaclass=元类)</code>，然后实例化自定义类<code>MyClass(xxx)</code></p><p><strong>总结</strong>：看完上述知识点后，我们能知道为什么withclass能起到metaclass的作用(类的<code>__mro__</code>中不出现指定的元类)了：</p><ul><li>首先分析流程：<code>return type.__new__(Metaclass)</code>返回了一个类型供自定义类继承，由于MetaClass继承的是真正的元类(元类都继承type)，所以在自定义类实例化的时候会被Metaclass的<code>__new__</code>方法拦截，在<code>MetaClass.__new__</code>里return了一个自定义实例，并把对象加入到了Singleton字典中了。</li><li>其次讲解为什么MetaClass中没有MetaClass：因为根据<a href="#"><code>__new__</code></a>知识点中讲到的，<code>__new__</code>控制了实例产生，<code>return type.__new__(Metaclass)</code>中创建了<code>Metaclass</code>，但其在<code>__new__</code>中返回的并不是MetaClass，因此<code>__mro__</code>中不会出现<code>Metaclass</code></li><li>最后还要讲讲Singleton中的执行逻辑：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    _inst = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._inst:</span><br><span class="line">            <span class="comment"># super(Singleton, cls).__call__调用的是type.__call__(自定义类类名name, 自定义类父类bases, 自定义类属性attrs)</span></span><br><span class="line">            cls._inst[cls] = super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._inst[cls]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是一个在看开源代码时配到了单例元类写法后的一个原理贴，可以帮你彻底弄清元类、以及&lt;code&gt;__new__&lt;/code&gt;和&lt;code&gt;__call__&lt;/code&gt;，相信我，看完你绝对会有收获。&lt;/p&gt;
&lt;p&gt;首先，关于元类的结论说在前头，先有个
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>开源项目代码阅读记录</title>
    <link href="https://nymrli.top/2022/03/29/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>https://nymrli.top/2022/03/29/开源项目代码阅读记录/</id>
    <published>2022-03-29T09:54:46.000Z</published>
    <updated>2022-05-29T10:01:40.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="爬虫系列"><a class="markdownIt-Anchor" href="#爬虫系列"></a> 爬虫系列</h1><h2 id="抢购-秒杀"><a class="markdownIt-Anchor" href="#抢购-秒杀"></a> 抢购、秒杀</h2><h3 id="taobao_seckill"><a class="markdownIt-Anchor" href="#taobao_seckill"></a> <strong><a href="https://github.com/jerry3747/taobao_seckill" target="_blank" rel="noopener"> taobao_seckill</a></strong></h3><blockquote><p>淘宝秒杀物品：分为selenium版和request网络请求版，微小的区别在于，api先请求的是购物车的物品信息，selenium则是勾选选择框。</p><p>流程大致都相同：①keep_wait等待临近抢购时间-----&gt;②将需要的信息缓存住，不再刷新（比如要抢购的物品信息、cookies…）-----&gt;③进行结算(/点击按钮)-----&gt;④提交订单(/点击按钮)-----&gt;⑤支付订单(/点击按钮)；</p></blockquote><ul><li><p><a href="https://www.cnblogs.com/amiza/p/10175543.html" target="_blank" rel="noopener">使用browsercookie来管理浏览器cookies</a>——从浏览器提取保存的cookies的工具。它是一个很有用的爬虫工具，通过加载你浏览器的cookies到一个cookiejar对象里面，让你轻松下载需要登录的网页内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cj = browsercookie.chrome()<span class="comment"># browsercookie.load() 在不知道或者不关心浏览器时使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url, cookies=cj)</span><br></pre></td></tr></table></figure><p>一般情况下，作为开发者的我们都是将cookies手动写入或者是传入程序的，而browsercookie用途，我想可以是将需要传入cookies的程序打包给不会提取Cookies的用户使用。（类似通过selenium登陆后，拿取cookies再发送网络请求，这边是让/借助用户自己的浏览器来拿取cookies）</p></li><li><p>使用tkinter搭建简单的GUI：点击“开始”的按钮后会将密码框和抢购设置时间框的内容传入，作为实例化ChromeDriverSpider的参数，并运行实例的sec_kill方法开始执行抢购</p></li><li><p>配置chromeDriver启动配置项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_chrome_options</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""配置启动项"""</span></span><br><span class="line">    chrome_options = webdriver.ChromeOptions()</span><br><span class="line">    chrome_options.accept_untrusted_certs = <span class="keyword">True</span></span><br><span class="line">    chrome_options.assume_untrusted_cert_issuer = <span class="keyword">True</span></span><br><span class="line">    arguments = [<span class="string">'--no-sandbox'</span>, <span class="string">'--disable-impl-side-painting'</span>, <span class="string">'--disable-setuid-sandbox'</span>, <span class="string">'--disable-seccomp-filter-sandbox'</span>,</span><br><span class="line">    <span class="string">'--disable-breakpad'</span>, <span class="string">'--disable-client-side-phishing-detection'</span>, <span class="string">'--disable-cast'</span>,</span><br><span class="line">    <span class="string">'--disable-cast-streaming-hw-encoding'</span>, <span class="string">'--disable-cloud-import'</span>, <span class="string">'--disable-popup-blocking'</span>,</span><br><span class="line">    <span class="string">'--ignore-certificate-errors'</span>, <span class="string">'--disable-session-crashed-bubble'</span>, <span class="string">'--disable-ipv6'</span>,</span><br><span class="line">    <span class="string">'--allow-http-screen-capture'</span>, <span class="string">'--start-maximized'</span>]</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> arguments:</span><br><span class="line">    chrome_options.add_argument(arg)</span><br><span class="line">    chrome_options.add_argument(<span class="string">f'--user-agent=<span class="subst">&#123;choice(get_useragent_data())&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> chrome_options</span><br></pre></td></tr></table></figure></li></ul><h3 id="taobao_api"><a class="markdownIt-Anchor" href="#taobao_api"></a> <strong><a href="https://github.com/gaoxt/taobao_api" target="_blank" rel="noopener">taobao_api</a></strong></h3><blockquote><p>selenium和api结合：登陆逻辑使用了selenium，刷新购物车和下单调用了手机淘宝taobao_api，自动付款也使用了selenium，能自动模拟触摸输入密码付款，接口签名sign生成方法参考get_sign_val。</p></blockquote><ul><li><p>同步阿里云时间服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一次性设置</span></span><br><span class="line">sudo sntp -sS ntp.aliyun.com</span><br><span class="line"><span class="comment">#永久设置</span></span><br><span class="line">sudo systemsetup -setnetworktimeserver ntp.aliyun.com</span><br><span class="line">sudo systemsetup -setusingnetworktime on</span><br></pre></td></tr></table></figure></li><li><p>展示QRCode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"># 找到二维码图片的链接</span></span><br><span class="line">   img = WebDriverWait(browser, <span class="number">2</span>, <span class="number">0.1</span>).until(</span><br><span class="line">       EC.presence_of_element_located((By.XPATH, <span class="string">"//div[@id='J_QRCodeImg']/img"</span>))).get_attribute(<span class="string">'src'</span>)</span><br><span class="line">   <span class="comment"># 获得图片字节流内容</span></span><br><span class="line">   img_content = requests.get(img, timeout=<span class="number">5</span>).content</span><br><span class="line">   <span class="comment"># 保存到本地图片中</span></span><br><span class="line">   file_name = <span class="string">'taobao_qrcode.png'</span></span><br><span class="line">   fp = open(file_name, <span class="string">'wb'</span>)</span><br><span class="line">   fp.write(img_content)</span><br><span class="line">   fp.close()</span><br><span class="line"><span class="comment"># 将其解码成链接， pyzbar为二维码和条形码库 ==&gt; 个人觉得保存后可以直接转成PIL的Image然后img.show()</span></span><br><span class="line">   <span class="keyword">from</span> pyzbar.pyzbar <span class="keyword">import</span> decode</span><br><span class="line">   barcode_url = <span class="string">''</span></span><br><span class="line">   barcodes = decode(Image.open(file_name))</span><br><span class="line">   <span class="keyword">for</span> barcode <span class="keyword">in</span> barcodes:</span><br><span class="line">       <span class="comment"># 解析获得二维码后的内容；如果是条形码，则返回条形码数</span></span><br><span class="line">       barcode_url = barcode.data.decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment"># 生成二维码并通过控制台打印</span></span><br><span class="line">   qr = qrcode.QRCode()</span><br><span class="line">   qr.add_data(barcode_url)</span><br><span class="line">   qr.print_ascii(invert=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>注：<a href="http://zbar.sourceforge.net/" target="_blank" rel="noopener">ZBar</a>是一个开源软件套件，用于从各种来源（如视频流、图像文件和原始强度传感器）读取条形码；<code>pyzbar</code> 是通过 <code>Python2</code>和<code>3</code>接口，使用 <code>ZBar</code> 库读取一维条形码和QR码 。=&gt;<a href="https://blog.csdn.net/qq_37924224/article/details/109582507" target="_blank" rel="noopener">读取条形码</a>、<a href="https://blog.csdn.net/hxj0323/article/details/112969622" target="_blank" rel="noopener">读取二维码</a></p></li></ul><h3 id="jd_seckill"><a class="markdownIt-Anchor" href="#jd_seckill"></a> <strong><a href="https://github.com/andyzys/jd_seckill" target="_blank" rel="noopener">jd_seckill</a></strong></h3><blockquote><ol><li>预约商品</li><li>秒杀抢购商品: ①<strong>访问</strong>商品的抢购<strong>链接</strong>（用于设置cookie等—&gt;②访问抢购订单<strong>结算页面</strong>----&gt;③<strong>提交抢</strong>购（秒杀）<strong>订单</strong> [_get_seckill_order_data生成提交抢购订单所需的请求体参数、获取秒杀初始化信息（包括：地址，发票，token）]</li></ol></blockquote><ul><li><p>从UAList中通过<code>random.choice(USER_AGENTS)</code>随机UA</p></li><li><p>使用内置configparser模块解析config.ini</p><ul><li>RawConfigParser是最基础的INI文件读取类；ConfigParser、SafeConfigParser<a href="https://blog.csdn.net/miner_k/article/details/77857292" target="_blank" rel="noopener">支持对%(value)s变量的解析</a>，SafeConfigParser类实现了ConfigParser相同的接口，新增如下方法：set存在保存的方法</li><li>section下的option(key)可以不填value值，即为空。</li><li>from: <a href="https://blog.csdn.net/tianzhu123/article/details/6893755" target="_blank" rel="noopener">python中RawConfigParser类、ConfigParser类、SafeConfigParser类中函数介绍</a>、</li></ul></li><li><p>多进程池：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor(work_count) <span class="keyword">as</span> pool:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(work_count):</span><br><span class="line">        pool.submit(self.seckill)</span><br></pre></td></tr></table></figure></li><li><p>秒杀时间比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buy_time = datetime.strptime(global_config.getRaw(<span class="string">'config'</span>,<span class="string">'buy_time'</span>), <span class="string">"%Y-%m-%d %H:%M:%S.%f"</span></span><br><span class="line">now_time = datetime.now</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">if</span> now_time() &gt;= buy_time:</span><br><span class="line">        logger.info(<span class="string">'时间到达，开始执行……'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">time.sleep(self.sleep_interval)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/woxiqingxian/jd_seckill/pull/2/commits/63a41a0609912d5643bc11f3419fe7dd8e84a00a" target="_blank" rel="noopener">获取京东服务器时间</a>：<code>https://api.m.jd.com/client.action?functionId=queryMaterialProducts&amp;client=wh5</code></p></li></ul><h3 id="jd-assistant"><a class="markdownIt-Anchor" href="#jd-assistant"></a> <strong><a href="https://github.com/tychxn/jd-assistant" target="_blank" rel="noopener">jd-assistant★</a></strong></h3><blockquote><p>是<a href="#jd_seckill">jd_seckill</a>的优化进阶版本</p><ul><li><p>普通商品购买主要流程：<code>(1)清空购物车</code> --&gt; <code>(2)添加商品到购物车</code> --&gt; <code>(3)提交订单</code></p></li><li><p>预约抢购商品特点：</p><ol><li>需要提前点击预约</li><li>大部分此类商品在预约后自动加入购物车，但是无法勾选✓，也无法️进入到结算页面</li><li>到了抢购的时间点后将商品加入购物车，此时才能勾选并下单</li></ol></li><li><p>普通商品：能加入购物车🛒，然后进入购物车结算下单.</p></li><li><p>抢购商品：需提提前预约，开始抢购时有“立即抢购”按钮🔘，点击按钮后商品加入购物车，然后结算下单.</p></li></ul><p>⭐️抢购受多种因素影响：<strong>网速、账号质量、运气</strong>等等，仅供娱乐，认真就输了.</p></blockquote><ul><li><p>deprecated、check_login装饰器：传入了self参数，并通过self实例调用了类的其他成员方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_login</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""用户登陆态校验装饰器。若用户未登陆，则调用扫码登陆"""</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_login:</span><br><span class="line">            logger.info(<span class="string">"&#123;0&#125; 需登陆后调用，开始扫码登陆"</span>.format(func.__name__))</span><br><span class="line">            self.login_by_QRcode()</span><br><span class="line">        <span class="keyword">return</span> func(self, *args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> new_func</span><br></pre></td></tr></table></figure></li><li><p>密码加密——<strong><a href="https://github.com/Legrandin/pycryptodome" target="_blank" rel="noopener">pycryptodome</a></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5 <span class="keyword">as</span> Cipher_pkcs1_v1_5</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_pwd</span><span class="params">(password, public_key=RSA_PUBLIC_KEY)</span>:</span></span><br><span class="line">    rsa_key = RSA.importKey(public_key)</span><br><span class="line">    encryptor = Cipher_pkcs1_v1_5.new(rsa_key)</span><br><span class="line">    cipher = b64encode(encryptor.encrypt(password.encode(<span class="string">'utf-8'</span>)))</span><br><span class="line">    <span class="keyword">return</span> cipher.decode(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure></li><li><p>提供JS脚本文件来获取商品的信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码在订单结算页面的开发者工具Console中执行，用于获取必要的参数</span></span><br><span class="line"><span class="keyword">var</span> eid = $(<span class="string">'#eid'</span>).val();</span><br><span class="line"><span class="keyword">var</span> fp = $(<span class="string">'#fp'</span>).val();</span><br><span class="line"><span class="keyword">var</span> trackId = getTakId();</span><br><span class="line"><span class="keyword">var</span> riskControl = $(<span class="string">'#riskControl'</span>).val();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`eid = <span class="subst">$&#123;eid&#125;</span>\nfp = <span class="subst">$&#123;fp&#125;</span>\ntrack_id = <span class="subst">$&#123;trackId&#125;</span>\nrisk_control = <span class="subst">$&#123;riskControl&#125;</span>`</span>);</span><br></pre></td></tr></table></figure></li><li><p>cookies验证-通过读取本地保存的cookies时要先验证下cookies是否有效：requests库的使用方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_validate_cookies</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""验证cookies是否有效（是否登陆）</span></span><br><span class="line"><span class="string">    通过访问用户订单列表页进行判断：若未登录，将会重定向到登陆页面。</span></span><br><span class="line"><span class="string">    :return: cookies是否有效 True/False</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    url = <span class="string">'https://order.jd.com/center/list.action'</span></span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">'rid'</span>: str(int(time.time() * <span class="number">1000</span>)),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = self.sess.get(url=url, params=payload, allow_redirects=<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">if</span> resp.status_code == requests.codes.OK:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(e)</span><br><span class="line">    <span class="comment"># 创建新的session</span></span><br><span class="line">    self.sess = requests.session()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li><li><p>二维码登录：下载二维码<code>_get_QRcode</code>–&gt;询问获取二维码扫描状态<code>_get_QRcode_ticket</code>—&gt;验证二维码信息(<code>_validate_QRcode_ticket</code>)–&gt;设置<code>is_login=True和save_cookies</code>（二维码有效期约120s，浏览器大约2s发送一个请求询问扫描状态）——看代码是assistant参考了2018年的**<a href="https://github.com/adyzng/jd-autobuy" target="_blank" rel="noopener">jd-autobuy</a>**</p></li><li><p>扫描二维码：写入图片和打开图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_image</span><span class="params">(resp, image_file)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(image_file, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 从网络请求中下载内容</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> resp.iter_content(chunk_size=<span class="number">1024</span>):</span><br><span class="line">            f.write(chunk)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_image</span><span class="params">(image_file)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">"nt"</span>:</span><br><span class="line">        os.system(<span class="string">'start '</span> + image_file)  <span class="comment"># for Windows</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> os.uname()[<span class="number">0</span>] == <span class="string">"Linux"</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"deepin"</span> <span class="keyword">in</span> os.uname()[<span class="number">2</span>]:</span><br><span class="line">                os.system(<span class="string">"deepin-image-viewer "</span> + image_file)  <span class="comment"># for deepin</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                os.system(<span class="string">"eog "</span> + image_file)  <span class="comment"># for Linux</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            os.system(<span class="string">"open "</span> + image_file)  <span class="comment"># for Mac</span></span><br></pre></td></tr></table></figure><p>注：判断操作系统还可以借助内置的platform库<code>platform.system().lower()</code>得到[linux、windows、mac]</p></li></ul><p>▲cookies和二维码结合使用：</p><ol><li>如果登陆成功则吧cookies持久化</li><li>使用二维码登陆前，先加载验证之前持久化的cookies是否有效，如果有效则无需再次扫码登陆(在QRCode_login的起始位置判断validation中修改的is_login是否为True)</li></ol><h3 id="jd-seckill-maotai"><a class="markdownIt-Anchor" href="#jd-seckill-maotai"></a> <strong><a href="https://github.com/hello8817/jd-seckill-maotai" target="_blank" rel="noopener"> jd-seckill-maotai</a></strong></h3><blockquote><ul><li><h2 id="主要功能"><a class="markdownIt-Anchor" href="#主要功能"></a> 主要功能</h2><ul><li>登陆京东商城（<a href="http://www.jd.com" target="_blank" rel="noopener">www.jd.com</a>）<ul><li>用京东APP扫码给出的二维码</li></ul></li><li>预约茅台<ul><li>定时自动预约</li></ul></li><li>秒杀预约后等待抢购<ul><li>定时开始自动抢购</li></ul></li></ul></li></ul><p><strong>特别声明：</strong></p><ul><li>本仓库发布的<code>jd_seckill_maotai</code>项目中涉及的任何脚本，仅用于测试和学习研究，禁止用于商业用途，不能保证其合法性，准确性，完整性和有效性，请根据情况自行判断。</li><li>本项目内所有资源文件，禁止任何公众号、自媒体进行任何形式的转载、发布。</li><li><code>ChinaVolvocars</code> 对任何脚本问题概不负责，包括但不限于由任何脚本错误导致的任何损失或损害.</li><li>请勿将<code>jd_seckill_maotai</code>项目的任何内容用于商业或非法目的，否则后果自负。</li><li>如果任何单位或个人认为该项目的脚本可能涉嫌侵犯其权利，则应及时通知并提供身份证明，所有权证明，我们将在收到认证文件后删除相关脚本。</li><li>您必须在下载后的24小时内从计算机或手机中完全删除以上内容。</li><li>本项目遵循<code>GPL-3.0 License</code>协议，如果本特别声明与<code>GPL-3.0 License</code>协议有冲突之处，以本特别声明为准。</li><li><em><strong>您使用或者复制了本仓库且本人制作的任何代码或项目，则视为<code>已接受</code>此声明，请仔细阅读</strong></em><br><em><strong>您在本声明未发出之时点使用或者复制了本仓库且本人制作的任何代码或项目且此时还在使用，则视为<code>已接受</code>此声明，请仔细阅读</strong></em></li></ul></blockquote><blockquote><p>根据12月14日以来抢茅台的日志分析，大胆推断再接再厉返回Json消息中<code>resultCode</code>与<strong>小白信用</strong>的关系。<br>这里主要分析出现频率最高的<code>90016</code>和<code>90008</code>。</p><table><thead><tr><th>案例</th><th>小白信用</th><th>90016</th><th>90008</th><th>抢到耗时</th></tr></thead><tbody><tr><td>张三</td><td>63.8</td><td>59.63%</td><td>40.37%</td><td>暂未抢到</td></tr><tr><td>李四</td><td>92.9</td><td>72.05%</td><td>27.94%</td><td>4天</td></tr><tr><td>王五</td><td>99.6</td><td>75.70%</td><td>24.29%</td><td>暂未抢到</td></tr><tr><td>赵六</td><td>103.4</td><td>91.02%</td><td>8.9%</td><td>2天</td></tr></tbody></table><p>风控放行后才会进行抢购，这时候用的应该是水库计数模型，假设无法一次性拿到所有数据的情况下来尽量的做到抢购成功用户的均匀分布，这样就和概率相关了。</p><p><strong>抢购结果确认</strong></p><p>抢购是否成功通常在程序开始的一分钟内可见分晓！<br>搜索日志，出现“抢购成功，订单号xxxxx&quot;，代表成功抢到了，务必半小时内支付订单！程序暂时不支持自动停止，需要手动STOP！<br>若两分钟还未抢购成功，基本上就是没抢到！程序暂时不支持自动停止，需要手动STOP！</p></blockquote><ul><li><p>在程序开始运行后，会检测本地时间与京东服务器时间，输出的差值为【本地时间-京东服务器时间】，即-50为本地时间比京东服务器时间慢50ms。 本代码的执行的抢购时间以本地电脑/服务器时间为准</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ...)</span>:</span></span><br><span class="line">    <span class="comment"># 初始化误差</span></span><br><span class="line">self.diff_time = self.local_time() - self.jd_time()</span><br><span class="line"><span class="comment"># ....</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 本地时间减去与京东的时间差(ms)，能够将时间误差提升到0.1秒附近, 具体精度依赖获取京东服务器时间的网络时间损耗</span></span><br><span class="line">    <span class="keyword">if</span> self.local_time() - self.diff_time &gt;= self.buy_time_ms:</span><br><span class="line">        logger.info(<span class="string">'时间到达，开始执行……'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.sleep(self.sleep_interval)</span><br></pre></td></tr></table></figure><p>补充：Python的时间戳默认都是秒级别的，如果要ms级别的，则要乘以1000</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">通过time，以元组（struct_time）为核心实现时间戳和格式化时间字符串的相互转换。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 获得10位秒级时间戳</span></span><br><span class="line">seconds = time.time()</span><br><span class="line"><span class="comment"># 获得13位毫秒级时间戳==&gt;java默认13位</span></span><br><span class="line">millis = int(round(time.time() * <span class="number">1000</span>))</span><br><span class="line"><span class="comment"># 同样，time下的mktime也需要*1000</span></span><br><span class="line">time.mktime(self.buy_time.timetuple()) * <span class="number">1000.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">通过datetime，以datetime类实例对象为核心实现时间戳和格式化时间字符串的相互转换。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># 获得当前时间</span></span><br><span class="line">now = datetime.now()</span><br><span class="line">timestamp = datetime.timestamp(now)</span><br><span class="line">print(<span class="string">"时间戳 ="</span>, timestamp)</span><br><span class="line"><span class="comment"># 也是10位s级</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1648622589.624272</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="jd_mask"><a class="markdownIt-Anchor" href="#jd_mask"></a> <strong><a href="https://github.com/Lasx/jd_mask" target="_blank" rel="noopener">jd_mask</a></strong></h3><blockquote><p>此tool只单独支持<strong>预约-抢购-成功后直接提交订单</strong>的商品，如[口罩]，只提供学习参考用途.</p></blockquote><p>Ⓜ️阅读了多份京东抢购的代码后，发现基本都是从一个模板里不断优化发展出来的，反应了开源的意义，也反应了京东部分细节的修改，同时也能得到一个告示：在实现相同功能前，不妨多看看、借鉴下以往可行的代码。</p><h3 id="automatic_ticket_purchase"><a class="markdownIt-Anchor" href="#automatic_ticket_purchase"></a> <strong><a href="https://github.com/MakiNaruto/Automatic_ticket_purchase" target="_blank" rel="noopener">Automatic_ticket_purchase</a></strong></h3><p>大麦网抢购流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[开始] --&gt; B(登陆)</span><br><span class="line">    B --&gt; C&#123;是否利用cookies登陆&#125;</span><br><span class="line">    C --&gt; |否| D[页面登陆]</span><br><span class="line">    C --&gt; |是| E[登陆验证]</span><br><span class="line">    D --&gt; E</span><br><span class="line">    E --&gt; G&#123;是否登陆成功&#125;</span><br><span class="line">    G --&gt; |是| F[获取购票必要信息]</span><br><span class="line">    G --&gt; |否|ED</span><br><span class="line">    F --&gt; L[检测抢票现在购票状态]</span><br><span class="line">    L --&gt; M&#123;目标票可进行抢购&#125;</span><br><span class="line">    M --&gt; |即将开抢|L</span><br><span class="line">    M --&gt; |缺货登记|ED((结束))</span><br><span class="line">M --&gt; |立刻购买|N&#123;抢购&#125;</span><br></pre></td></tr></table></figure><blockquote><p>跟限时、定时秒杀不同的是，大麦网的抢购信息是靠不断刷新的，需要通过不断检测页面内容，判断目前票的可否购买情况。如果刷新为可购买则进行抢购购买。</p></blockquote><ul><li><p>点击购买是对指定接口发送请求，并更新cookies(cookies嫌少不嫌多)：step2_click_buy_now</p></li><li><p>提交订单：step3_submit_order</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">response = self.session.post(<span class="string">'https://buy.damai.cn/multi/trans/createOrder'</span>,</span><br><span class="line">                             headers=headers,</span><br><span class="line">                             params=params,</span><br><span class="line">                             data=submit_order_info,</span><br><span class="line">                             cookies=self.login_cookies)</span><br><span class="line">buy_status = json.loads(response.text)</span><br><span class="line"><span class="keyword">if</span> buy_status.get(<span class="string">'success'</span>) <span class="keyword">is</span> <span class="keyword">True</span> <span class="keyword">and</span> buy_status.get(<span class="string">'module'</span>).get(<span class="string">'alipayOrderId'</span>):</span><br><span class="line">    print(<span class="string">'-'</span> * <span class="number">10</span>, <span class="string">'抢票成功, 请前往 大麦网-&gt;我的大麦-&gt;交易中心-&gt;订单管理 确认订单'</span>, <span class="string">'-'</span> * <span class="number">10</span>)</span><br><span class="line">    print(<span class="string">'alipayOrderId: '</span>, buy_status.get(<span class="string">'module'</span>).get(<span class="string">'alipayOrderId'</span>))</span><br><span class="line">    print(<span class="string">'支付宝支付链接: '</span>, buy_status.get(<span class="string">'module'</span>).get(<span class="string">'alipayWapCashierUrl'</span>))</span><br></pre></td></tr></table></figure></li></ul><h3 id="nikerobot"><a class="markdownIt-Anchor" href="#nikerobot"></a> <strong><a href="https://github.com/cxiaoer/NikeRobot" target="_blank" rel="noopener"> NikeRobot</a></strong></h3><ul><li><p>pdb调试断点：==&gt;实际上Pycharm的调试更加好用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">pdb.set_trace()</span><br></pre></td></tr></table></figure></li><li><p>将类成员属性转成字典形式: <code>NikeLoginParam().__dict__</code></p></li><li><p>自己管理线程：创建继承Thread的执行类，重写run方法，在main中进行创建多个实例MyThread().start()，并join住。</p></li></ul><h3 id="hpv4g"><a class="markdownIt-Anchor" href="#hpv4g"></a> <strong><a href="https://github.com/xiangmingzhe0928/hpv4g" target="_blank" rel="noopener">hpv4g</a>★</strong></h3><ul><li><p>是否使用代理：<code>init_ip_proxy_pool</code></p></li><li><p>多线程参数设置: python3.8中ThreadPoolExecutor的默认worker：<code>max_workers = min(32, os.cpu_count() + 4)</code></p></li><li><p>线程池：ThreadPoolExecutor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, FIRST_COMPLETED</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=max_workers) <span class="keyword">as</span> t:</span><br><span class="line">    fs = [t.submit(sec_kill_task, miao_miao, params[i % _params_len],</span><br><span class="line">                   <span class="keyword">None</span> <span class="keyword">if</span> <span class="keyword">not</span> _ip_proxys_len <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="string">'http'</span>: <span class="keyword">None</span> <span class="keyword">if</span> (index := i % _ip_proxys_len) == <span class="number">0</span> <span class="keyword">else</span> ip_proxys[index]&#125;) <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">          range(max_workers + <span class="number">5</span>)]</span><br><span class="line">    <span class="comment"># 120S后结束任务, 有一个完成则完成</span></span><br><span class="line">    wait(fs, <span class="number">120</span>, return_when=FIRST_COMPLETED)</span><br><span class="line">    <span class="keyword">global</span> KILL_FLAG</span><br><span class="line">    KILL_FLAG = <span class="keyword">True</span></span><br><span class="line">    print(<span class="string">'&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;本轮未成功秒杀到疫苗&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;'</span>)</span><br></pre></td></tr></table></figure></li><li><p>缓存配置——非默认参数的装饰器：考虑提前缓存疫苗列表 秒杀开始后跳过查询列表等操作 直接调用秒杀接口</p></li><li><p>获取服务器当前时间戳</p></li><li><p>直接设置logging中的log</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="comment"># 设置配置</span></span><br><span class="line">logging.basicConfig(handlers=[logging.FileHandler(filename=LOG_NAME,</span><br><span class="line">                                                  encoding=<span class="string">'utf-8'</span>, mode=<span class="string">'a+'</span>)],</span><br><span class="line">                    format=<span class="string">'%(asctime)s %(message)s'</span>,</span><br><span class="line">                    level=getattr(logging, args.log))</span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">logging.info(<span class="string">"xxx"</span>)</span><br><span class="line">logging.debug(<span class="string">"yyy"</span>)</span><br></pre></td></tr></table></figure></li><li><p>argueparser使用：</p><ul><li><p>action参数: <code>parser.add_argument('-reload_cache', action='store_true', help='刷新--region_code疫苗列表本地缓存')</code>，出现reload_cache参数则为true，所以默认为false</p></li><li><p><code>parser.add_argument('--log', default='WARNING', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'],help='日志级别 默认WARNING')</code></p></li><li><p>add_argument中的type实际上是个类型转化器，如type=int，如果无法转成int则报错，因此可以借此参数对输入进行约束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_valid_int_type</span><span class="params">(i)</span>:</span></span><br><span class="line">    valid_int = int(i)</span><br><span class="line">    <span class="keyword">if</span> valid_int &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> argparse.ArgumentTypeError(<span class="string">f'invalid int argument:<span class="subst">&#123;i&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> valid_int</span><br></pre></td></tr></table></figure></li></ul></li><li><p>requests使用：</p><ul><li><p><code>raise_for_status</code>状态码非成功时抛出异常</p></li><li><p>自定义<code>_get(url, params=None, error_exit=True, **kwargs)</code>方法，添加参数：error_exit:返回4XX 5XX错误时 是否退出</p></li><li><p>cookies除了放在requests.get(cookies=xxxCookieDict)，还可以作为字符串设置在header[“<strong>cookie</strong>”]中（无s），如<code>self._headers[&quot;cookie&quot;]=&quot;k1=v1;_xxhm_=%7B%2x%7D;k3=wxapptoken:v3&quot;</code>，通过<code>;</code>来分割</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># disable ssl warnings</span></span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="抢购型代码总结"><a class="markdownIt-Anchor" href="#抢购型代码总结"></a> 抢购型代码总结：</h3><ul><li><p>实现主要分为selenium(自动测试工具)模拟点击；api模拟网络请求</p></li><li><p>登陆之后会对cookies进行持久化，使用pickle的好处是无法明文看懂、复制</p></li><li><p>可以通过持久化的cookies来登陆，但会检测cookies是否仍然有效</p></li><li><p>定时抢购会等待sleep到临近时间(while True+sleep(time)的方式 or sleepUntil+while try)，然后再进行多次抢购请求（如果抢购的2分钟内没抢到，大多没希望了，只好等待下次）；如果是<a href="#Automatic_ticket_purchase">等待页面刷新的</a>，则不断请求页面，等到结果改变。</p><ul><li>注意：等待间隔不要超过时间阈值，如180s前检查，如果不符合不能让其等待190s</li></ul></li><li><p>推送工具：提供一个自己写的</p><p>config.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[pusher]</span></span><br><span class="line"><span class="attr">pusher_type</span> = pushplus</span><br><span class="line"><span class="attr">push_title</span> = 飞鱼秒杀</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://sct.ftqq.com/</span></span><br><span class="line"><span class="section">[serverchan]</span></span><br><span class="line"><span class="attr">sec_key</span> = SCU35113Te369cebc21f6e483c03fffc400c4c5c05bdad63995c32</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://open.dingtalk.com/document/group/custom-robot-access</span></span><br><span class="line"><span class="section">[dingding]</span></span><br><span class="line"><span class="attr">access_token</span> =</span><br><span class="line"><span class="attr">secret</span> =</span><br><span class="line"></span><br><span class="line"><span class="comment"># http://www.pushplus.plus/</span></span><br><span class="line"><span class="section">[pushplus]</span></span><br><span class="line"><span class="attr">pushplus_token</span> = fedcf6b08f6f4aaeb2948b7d7010eb93</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Mrli'</span></span><br><span class="line"></span><br><span class="line">CONFIG_INI_FILENAME = <span class="string">"push_config.ini"</span></span><br><span class="line">CONFIG_INI_PATH = Path(__file__).resolve().parent.with_name(<span class="string">"push_config.ini"</span>)</span><br><span class="line"></span><br><span class="line">REMIND_MSG = <span class="string">"""</span></span><br><span class="line"><span class="string">[pusher]</span></span><br><span class="line"><span class="string">pusher_type = pushplus</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[serverchan]</span></span><br><span class="line"><span class="string">sec_key =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[dingding]</span></span><br><span class="line"><span class="string">access_token =</span></span><br><span class="line"><span class="string">secret =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[pushplus]</span></span><br><span class="line"><span class="string">pushplus_token = </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PusherException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, message)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        super().__init__(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPushUtil</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, content: str, title: str = <span class="string">""</span>)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PushplusPush</span><span class="params">(IPushUtil)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, push_title, options: dict)</span>:</span></span><br><span class="line">        self.pushplus_token = options.get(<span class="string">"pushplus_token"</span>)</span><br><span class="line">        self.push_title = push_title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, content: str, title: str = <span class="string">""</span>)</span> -&gt; bool:</span></span><br><span class="line">        d = &#123;</span><br><span class="line">            <span class="string">"token"</span>: self.pushplus_token,</span><br><span class="line">            <span class="string">"template"</span>: <span class="string">"markdown"</span>,</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"&#123;push_title&#125;-&#123;title&#125;"</span>.format(push_title=self.push_title, title=title),</span><br><span class="line">            <span class="string">"content"</span>: content</span><br><span class="line">        &#125;</span><br><span class="line">        res = requests.post(<span class="string">"http://www.pushplus.plus/send"</span>, data=d)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">200</span> &lt;= res.json().get(<span class="string">"code"</span>) &lt; <span class="number">300</span>):</span><br><span class="line">            print(res.json())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span> &lt;= res.json().get(<span class="string">"code"</span>) &lt; <span class="number">300</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerChanPush</span><span class="params">(IPushUtil)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, push_title, options: dict)</span>:</span></span><br><span class="line">        self.sec_key = options.get(<span class="string">"sec_key"</span>)</span><br><span class="line">        self.push_title = push_title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, content: str, title: str = <span class="string">""</span>)</span> -&gt; bool:</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">'text'</span>: <span class="string">"&#123;push_title&#125;-&#123;title&#125;"</span>.format(push_title=self.push_title, title=title),</span><br><span class="line">            <span class="string">'desp'</span>: content</span><br><span class="line">        &#125;</span><br><span class="line">        res = requests.post(url=<span class="string">'https://sc.ftqq.com/&#123;&#125;.send'</span>.format(self.sec_key), data=data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (res.json().get(<span class="string">"errmsg"</span>) == <span class="string">"success"</span>):</span><br><span class="line">            print(res.json())</span><br><span class="line">        <span class="keyword">return</span> res.json().get(<span class="string">"errmsg"</span>) == <span class="string">"success"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DingDingPush</span><span class="params">(IPushUtil)</span>:</span></span><br><span class="line">    URL = <span class="string">"https://oapi.dingtalk.com/robot/send"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, push_title, options: dict)</span>:</span></span><br><span class="line">        self.access_token = options.get(<span class="string">"access_token"</span>)</span><br><span class="line">        self.secret = options.get(<span class="string">"secret"</span>)</span><br><span class="line">        self.target_url = self.get_url()</span><br><span class="line">        self.push_title = push_title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(self)</span>:</span></span><br><span class="line">        timestamp = round(time.time() * <span class="number">1000</span>)</span><br><span class="line">        secret_enc = bytes(self.secret, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">        string_to_sign = <span class="string">"&#123;&#125;\n&#123;&#125;"</span>.format(timestamp, self.secret)</span><br><span class="line">        string_to_sign_enc = bytes(string_to_sign, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">        hmac_code = hmac.new(</span><br><span class="line">            secret_enc, string_to_sign_enc, digestmod=hashlib.sha256</span><br><span class="line">        ).digest()</span><br><span class="line">        sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))</span><br><span class="line">        <span class="keyword">return</span> self.URL + <span class="string">"?access_token=&#123;access_token&#125;&amp;timestamp=&#123;timestamp&#125;&amp;sign=&#123;sign&#125;"</span>.format(</span><br><span class="line">            access_token=self.access_token, timestamp=timestamp, sign=sign)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, content: str, title: str = <span class="string">""</span>)</span> -&gt; bool:</span></span><br><span class="line">        msg = self.gen_markdown_msg(title, content)</span><br><span class="line">        <span class="keyword">return</span> self.send(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, message)</span>:</span></span><br><span class="line">        resp = requests.post(self.target_url, json=message)</span><br><span class="line">        <span class="keyword">return</span> resp.json()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_text_msg</span><span class="params">(content, at=None, at_all=False)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> at <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            at = []</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">"msgtype"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="string">"text"</span>: &#123;<span class="string">"content"</span>: content&#125;,</span><br><span class="line">            <span class="string">"at"</span>: &#123;<span class="string">"atMobiles"</span>: at, <span class="string">"isAtAll"</span>: at_all&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_markdown_msg</span><span class="params">(self, title, text, at=None, at_all=False)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generateText</span><span class="params">()</span>:</span></span><br><span class="line">            res = <span class="string">""</span></span><br><span class="line">            <span class="comment"># 最顶行显示标题</span></span><br><span class="line">            res += <span class="string">"# "</span> + <span class="string">"&#123;&#125;-"</span>.format(self.push_title) + title + <span class="string">"\n"</span></span><br><span class="line">            <span class="comment"># 内容</span></span><br><span class="line">            res += text</span><br><span class="line">            <span class="comment"># at对象</span></span><br><span class="line">            res += reduce(<span class="keyword">lambda</span> x, y: x + <span class="string">"@"</span> + y, at, <span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">"msgtype"</span>: <span class="string">"markdown"</span>,</span><br><span class="line">            <span class="string">"markdown"</span>: &#123;</span><br><span class="line">                <span class="string">"title"</span>: title,</span><br><span class="line">                <span class="string">"text"</span>: generateText()</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"at"</span>: &#123;<span class="string">"atMobiles"</span>: at, <span class="string">"isAtAll"</span>: at_all&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pusher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, logger=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> logger:</span><br><span class="line">            self.cout = logger.info</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.cout = <span class="keyword">print</span></span><br><span class="line">        self._pusher = self.init()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        实例化pusher</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">from</span> configparser <span class="keyword">import</span> RawConfigParser</span><br><span class="line">        cp = RawConfigParser()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(CONFIG_INI_PATH):</span><br><span class="line">            <span class="keyword">raise</span> PusherException(</span><br><span class="line">                <span class="string">"请创建&#123;filename&#125;配置文件\npusher配置信息如下:\n&#123;msg&#125;"</span>.format(filename=CONFIG_INI_FILENAME, msg=REMIND_MSG))</span><br><span class="line">        cp.read(CONFIG_INI_PATH, encoding=<span class="string">"utf8"</span>)</span><br><span class="line">        pusher_type = cp.get(<span class="string">"pusher"</span>, <span class="string">"pusher_type"</span>).lower()</span><br><span class="line">        push_title = cp.get(<span class="string">"pusher"</span>, <span class="string">"push_title"</span>)</span><br><span class="line">        <span class="comment"># 是否使用了pusher</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pusher_type:</span><br><span class="line">            self.cout(<span class="string">"初始化Pusher: 当前未配置Pusher, 如果需要推送功能, 则在&#123;filename&#125;"</span>.format(filename=CONFIG_INI_FILENAME))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        generator_info = dict(cp.items(pusher_type))</span><br><span class="line">        <span class="comment"># 检查pusher配置</span></span><br><span class="line">        <span class="keyword">if</span> pusher_type <span class="keyword">and</span> <span class="keyword">not</span> self._valid(generator_info):</span><br><span class="line">            <span class="keyword">raise</span> PusherException(<span class="string">"&#123;&#125;_pusher配置错误，不能为空~"</span>.format(pusher_type))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pusher_type == <span class="string">"serverchan"</span>:</span><br><span class="line">            <span class="keyword">return</span> ServerChanPush(push_title, generator_info)</span><br><span class="line">        <span class="keyword">elif</span> pusher_type == <span class="string">"dingding"</span>:</span><br><span class="line">            <span class="keyword">return</span> DingDingPush(push_title, generator_info)</span><br><span class="line">        <span class="keyword">elif</span> pusher_type == <span class="string">"pushplus"</span>:</span><br><span class="line">            <span class="keyword">return</span> PushplusPush(push_title, generator_info)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> PusherException(<span class="string">"不可知pusher类型~"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_valid</span><span class="params">(config_dict: dict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断字典值是否为空</span></span><br><span class="line"><span class="string">        :param dict:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> config_dict.values():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> v:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, content: str, title: str = <span class="string">""</span>)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._pusher:</span><br><span class="line">            self.cout(<span class="string">"当前未配置pusher, 消息无法发送"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self._pusher.push(content, title)</span><br></pre></td></tr></table></figure><h2 id="weibospider"><a class="markdownIt-Anchor" href="#weibospider"></a> <a href="https://github.com/dataabc/weiboSpider" target="_blank" rel="noopener">weiboSpider</a></h2><blockquote><p>可以连续爬取<strong>一个</strong>或<strong>多个</strong>新浪微博用户（如<a href="https://weibo.cn/u/1223178222" target="_blank" rel="noopener">胡歌</a>、<a href="https://weibo.cn/u/1669879400" target="_blank" rel="noopener">迪丽热巴</a>、<a href="https://weibo.cn/u/1729370543" target="_blank" rel="noopener">郭碧婷</a>）的数据，并将结果信息写入<strong>文件</strong>或<strong>数据库</strong>。</p></blockquote><ul><li>①允许用户指定自定义配置文件，否则使用默认配置文件；②对配置文件进行校验，并对非法项进行提示</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">config = _get_config()</span><br><span class="line">    config_util.validate_config(config)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_config</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""获取config.json数据"""</span></span><br><span class="line">    src = os.path.split(</span><br><span class="line">        os.path.realpath(__file__))[<span class="number">0</span>] + os.sep + <span class="string">'config_sample.json'</span></span><br><span class="line">    config_path = os.getcwd() + os.sep + <span class="string">'config.json'</span></span><br><span class="line">    <span class="keyword">if</span> FLAGS.config_path:</span><br><span class="line">        config_path = FLAGS.config_path</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_config</span><span class="params">(config)</span>:</span></span><br><span class="line">    <span class="string">"""验证配置是否正确"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证filter、pic_download、video_download</span></span><br><span class="line">    argument_list = [<span class="string">'filter'</span>, <span class="string">'pic_download'</span>, <span class="string">'video_download'</span>]</span><br><span class="line">    <span class="keyword">for</span> argument <span class="keyword">in</span> argument_list:</span><br><span class="line">        <span class="keyword">if</span> config[argument] != <span class="number">0</span> <span class="keyword">and</span> config[argument] != <span class="number">1</span>:</span><br><span class="line">            logger.warning(<span class="string">u'%s值应为0或1,请重新输入'</span>, config[argument])</span><br><span class="line">            sys.exit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证since_date</span></span><br><span class="line">    since_date = config[<span class="string">'since_date'</span>]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> _is_date(str(since_date))) <span class="keyword">and</span> (<span class="keyword">not</span> isinstance(since_date, int)):</span><br><span class="line">        logger.warning(<span class="string">u'since_date值应为yyyy-mm-dd形式或整数,请重新输入'</span>)</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><h2 id="proxy_pool"><a class="markdownIt-Anchor" href="#proxy_pool"></a> <strong><a href="https://github.com/jhao104/proxy_pool" target="_blank" rel="noopener">proxy_pool</a>★</strong></h2><blockquote><p>爬虫代理IP池项目,主要功能为定时采集网上发布的免费代理验证入库，定时验证入库的代理保证代理的可用性，提供API和CLI两种使用方式。同时你也可以扩展代理源以增加代理池IP的质量和数量。</p><p>模块组成：获取功能、存储功能、校验功能、接口管理</p><p>⭐️程序主要是启动了<code>startServer</code>的API接口服务、<code>startScheduler</code>定时服务</p><ul><li><code>startServer-&gt;runFlask</code>：是向外提供了通过<strong>proxyHandler</strong>来获得Redis中的proxy数据</li><li><code>startScheduler-&gt;sche.add_task(__runProxyFetch)、sche.add_task(__runProxyCheck)</code>，<ul><li><code>__runProxyFetch:proxy_fetcher.run()-&gt;proxy_queue-&gt;Checker(&quot;raw&quot;, proxy_queue)</code>获得各个代理网站的代理信息后，进行校验，校验成功则入库</li><li><code>__runProxyCheck:proxy in proxy_handler.getAll()-&gt;proxy_queue-&gt;Checker(&quot;use&quot;, proxy_queue)</code>：通过proxy_handler拿到库里所有现存的数据后，进行有效性校验，无效的则删除，有效的则更新信息</li></ul></li></ul><p>作为存储功能的接口proxyHandler，也是两个API服务与定时服务的中介。程序也是通过存储功能，将核心的两个功能：<u>定时抓取的proxy数据</u>与<u>提供proxy数据给用户使用</u>成功联系在了一起</p></blockquote><ul><li><p>通过元类实现单例模式：ConfigHandler，其可以在任意模块中以c = ConfigHandler()的形式获得，而不是<code>ConfigHandler.getInstance()</code></p></li><li><p><code>@LazyProperty</code>懒加载属性的装饰器： 只有用到时才会加载并将值注入到<code>__dict__</code>、加载一次后值就不再变化、；讲解可见：<a href="https://www.jianshu.com/p/708dc26f9b92%E2%80%94%E2%80%94%E6%8F%8F%E8%BF%B0%E7%AC%A6or%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">https://www.jianshu.com/p/708dc26f9b92——描述符or修饰符实现</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyProperty</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 在被注解类方法被解释器运行的时候就会创建LazyProperty实例并返回</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="string">"""通过python描述符来实现"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 会将结果值通过setattr方法存入到instance对象实例的__dict__中</span></span><br><span class="line">            value = self.func(instance)</span><br><span class="line">            setattr(instance, self.func.__name__, value)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigHandler</span><span class="params">(withMetaclass<span class="params">(Singleton)</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 返回一个LazyProperty实例 </span></span><br><span class="line"><span class="meta">    @LazyProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serverHost</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> os.environ.get(<span class="string">"HOST"</span>, setting.HOST)</span><br><span class="line">c = ConfigHandler()</span><br><span class="line"><span class="comment"># 会触发ConfigHandler.__dict__["serverHost"], 然后接而触发LazyProperty的__get__，value = self.func(instance)会得到真正serverHost函数的值后将其设置在ConfigHandler instance对象的__dict__中，由于对象的__dict__["serverHost"]=value优先级高于类的__dict__["serverHost"]=LazyProperty()对象，因此之后调用得到的是value结果</span></span><br><span class="line">print(c.serverHost)</span><br></pre></td></tr></table></figure><p><code>__get__</code>只有访问类属性的时候才会生效，这边是通过setattr将serverHost设置成了ConfigHandler的类属性</p></li><li><p>封装了一个请求工具类<code>WebRequest</code>:</p><ul><li>增加了异常处理的功能</li><li>增加了日志功能</li><li>请求头会得到随机UA</li><li>设置重试</li></ul></li><li><p>使用click创建子命令：</p><ol><li>得到一个click_group</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONTEXT_SETTINGS = dict(help_option_names=[<span class="string">'-h'</span>, <span class="string">'--help'</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.group(context_settings=CONTEXT_SETTINGS)</span></span><br><span class="line"><span class="meta">@click.version_option(version=VERSION)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""ProxyPool cli工具"""</span></span><br></pre></td></tr></table></figure><ol start="2"><li>指定group下的子命令</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@cli.command(name="server")</span></span><br><span class="line"><span class="comment"># 还可以设置参数: @click.option('--count', default=1, help='Number of greetings.') --&gt; def server(count)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" 启动api服务 """</span></span><br><span class="line">    click.echo(BANNER)</span><br><span class="line">    startServer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    cli()</span><br></pre></td></tr></table></figure><p>然后通过bash脚本同时开启两个进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">python proxyPool.py server &amp;</span><br><span class="line">python proxyPool.py schedule</span><br></pre></td></tr></table></figure></li><li><p>DbClient DB工厂类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbClient</span><span class="params">(withMetaclass<span class="params">(Singleton)</span>)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, db_conn)</span>:</span></span><br><span class="line">        self.parseDbConn(db_conn)</span><br><span class="line">        self.__initDbClient()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parseDbConn</span><span class="params">(cls, db_conn)</span>:</span></span><br><span class="line">        <span class="comment"># 可以关注一下urlparse的使用</span></span><br><span class="line">        db_conf = urlparse(db_conn)</span><br><span class="line">        cls.db_type = db_conf.scheme.upper().strip()</span><br><span class="line">        <span class="comment"># _NetlocResultMixinBase对象来获取想要的参数</span></span><br><span class="line">        cls.db_host = db_conf.hostname</span><br><span class="line">        cls.db_port = db_conf.port</span><br><span class="line">        cls.db_user = db_conf.username</span><br><span class="line">        cls.db_pwd = db_conf.password</span><br><span class="line">        cls.db_name = db_conf.path[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__initDbClient</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        init DB Client</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        __type = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"SSDB"</span> == self.db_type:</span><br><span class="line">            __type = <span class="string">"ssdbClient"</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">"REDIS"</span> == self.db_type:</span><br><span class="line">            __type = <span class="string">"redisClient"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">assert</span> __type, <span class="string">'type error, Not support DB type: &#123;&#125;'</span>.format(self.db_type)</span><br><span class="line">        self.client = getattr(__import__(__type), <span class="string">"%sClient"</span> % self.db_type.title())(host=self.db_host,</span><br><span class="line">port=self.db_port,</span><br><span class="line">username=self.db_user,</span><br><span class="line">password=self.db_pwd,</span><br><span class="line">db=self.db_name)</span><br></pre></td></tr></table></figure></li><li><p>python中使用redis</p><blockquote><p>Redis中代理存放的结构为hash：hash  是一个键值(key=&gt;value)对集合；是一个 string 类型的 field（字段） 和 value（值） 的<strong>映射表</strong>，hash 特别适合用于存储对象。</p><p>本项目中应用：key为ip:port, value为代理属性的字典;</p></blockquote><ul><li>python与创建连接</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip install redis</span></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis, BlockingConnectionPool</span><br><span class="line">conn_dict = &#123;</span><br><span class="line">    <span class="string">"host"</span>: <span class="string">"49.235.118.244"</span>,</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">6379</span>,</span><br><span class="line">    <span class="string">"db"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">r = Redis(connection_pool=BlockingConnectionPool(decode_responses=<span class="keyword">True</span>,</span><br><span class="line">                                                 timeout=<span class="number">5</span>,</span><br><span class="line">                                                 socket_timeout=<span class="number">15</span>,</span><br><span class="line">                                                 **conn_dict)</span><br><span class="line">         )</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/jhao104/proxy_pool/blob/master/db/redisClient.py" target="_blank" rel="noopener">★hash使用封装</a></li></ul><blockquote><p>添加：set、zset为add、list为push、string和hash为set</p></blockquote><p>参考:<a href="https://blog.csdn.net/weixin_39576234/article/details/87603701" target="_blank" rel="noopener">Redis基本概念及使用</a>、<a href="https://www.runoob.com/redis/redis-sorted-sets.html%E3%80%81" target="_blank" rel="noopener">https://www.runoob.com/redis/redis-sorted-sets.html、</a><a href="https://www.runoob.com/w3cnote/python-redis-intro.html" target="_blank" rel="noopener">★Python redis 使用介绍</a></p><p><img src="/2022/03/29/开源项目代码阅读记录/E:%5Chexo%5Csource_posts%5C%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95%5Credis.jpg" alt="redis"></p></li><li><p>继承重写logging.logger，可选参数为<code>name, level=DEBUG, stream=True, file=True</code>，让每个功能函数都能生成单独的日志文件，并进行了可选控制。</p><p>相比单例，日志精度更细，但也使用起来也更麻烦，需要考虑什么地方需要。</p></li><li><p>提供&quot;扩展代理&quot;接口</p><ol><li><p>在<a href="https://github.com/jhao104/proxy_pool/blob/1a3666283806a22ef287fba1a8efab7b94e94bac/fetcher/proxyFetcher.py#L21" target="_blank" rel="noopener">ProxyFetcher</a>类中添加自定义的获取代理的静态方法， 该方法需要以生成器(yield)形式返回<code>host:ip</code>格式的代理</p></li><li><p>添加好方法后，修改<a href="https://github.com/jhao104/proxy_pool/blob/1a3666283806a22ef287fba1a8efab7b94e94bac/setting.py#L47" target="_blank" rel="noopener">setting.py</a>文件中的<code>PROXY_FETCHER</code>项下添加自定义方法的名字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PROXY_FETCHER = [</span><br><span class="line">    <span class="string">"freeProxy01"</span>,    </span><br><span class="line">    <span class="string">"freeProxy02"</span>,</span><br><span class="line">    <span class="comment"># ....</span></span><br><span class="line">    <span class="string">"freeProxyCustom1"</span>  <span class="comment">#  # 确保名字和你添加方法名字一致</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>schedule</code> 进程会每隔一段时间抓取一次代理，下次抓取时会自动识别调用你定义的方法。</p></li></ol><p><a href="https://github.com/jhao104/proxy_pool/blob/master/helper/fetch.py" target="_blank" rel="noopener">实现方式</a>：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">self.log.info(<span class="string">"ProxyFetch : start"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从配置中拿执行函数</span></span><br><span class="line"><span class="keyword">for</span> fetch_source <span class="keyword">in</span> self.conf.fetchers:</span><br><span class="line">    <span class="comment"># 判断ProxyFetcher中是否有定义、是否可调用</span></span><br><span class="line">fetcher = getattr(ProxyFetcher, fetch_source, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fetcher:</span><br><span class="line">self.log.error(<span class="string">"ProxyFetch - &#123;func&#125;: class method not exists!"</span>.format(func=fetch_source))</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> callable(fetcher):</span><br><span class="line">self.log.error(<span class="string">"ProxyFetch - &#123;func&#125;: must be class method"</span>.format(func=fetch_source))</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">thread_list.append(_ThreadFetcher(fetch_source, proxy_dict))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> thread_list:</span><br><span class="line">    thread.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">    thread.start()</span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> thread_list:</span><br><span class="line">    thread.join()</span><br><span class="line">self.log.info(<span class="string">"ProxyFetch - all complete!"</span>)</span><br></pre></td></tr></table></figure><ul><li><p>Cpython(默认安装的都是Cpython)中Dict和list、tuple都是<strong>线程安全</strong>的</p><ul><li><p>以装饰器的形式将过滤器将入到容器中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyValidator</span><span class="params">(withMetaclass<span class="params">(Singleton)</span>)</span>:</span></span><br><span class="line">    pre_validator = []</span><br><span class="line">    http_validator = []</span><br><span class="line">    https_validator = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addPreValidator</span><span class="params">(cls, func)</span>:</span></span><br><span class="line">        cls.pre_validator.append(func)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上执行了 formatValidator=ProxyValidator.addPreValidator(formatValidator)</span></span><br><span class="line"><span class="comment"># 由于addPreValidator返回了func, 所以formatValidator还是原来的addPreValidator, 但在类定义的时候ProxyValidator.pre_validator添加了formatValidator方法</span></span><br><span class="line"><span class="meta">@ProxyValidator.addPreValidator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">formatValidator</span><span class="params">(proxy)</span>:</span></span><br><span class="line">    <span class="string">"""检查代理格式"""</span></span><br><span class="line">    verify_regex = <span class="string">r"\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;:\d&#123;1,5&#125;"</span></span><br><span class="line">    _proxy = findall(verify_regex, proxy)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> len(_proxy) == <span class="number">1</span> <span class="keyword">and</span> _proxy[<span class="number">0</span>] == proxy <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoValidator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">""" 校验执行器 """</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validator</span><span class="params">(cls, proxy)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        校验入口</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            proxy: Proxy Object</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            Proxy Object</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        http_r = cls.httpValidator(proxy)</span><br><span class="line">        https_r = <span class="keyword">False</span> <span class="keyword">if</span> <span class="keyword">not</span> http_r <span class="keyword">else</span> cls.httpsValidator(proxy)</span><br><span class="line"></span><br><span class="line">        proxy.check_count += <span class="number">1</span></span><br><span class="line">        proxy.last_time = datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">        proxy.last_status = <span class="keyword">True</span> <span class="keyword">if</span> http_r <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> http_r:</span><br><span class="line">            <span class="keyword">if</span> proxy.fail_count &gt; <span class="number">0</span>:</span><br><span class="line">                proxy.fail_count -= <span class="number">1</span></span><br><span class="line">            proxy.https = <span class="keyword">True</span> <span class="keyword">if</span> https_r <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            proxy.fail_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> proxy</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preValidator</span><span class="params">(cls, proxy)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> func <span class="keyword">in</span> ProxyValidator.pre_validator:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> func(proxy):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><a href="http://www.network-science.de/ascii/" target="_blank" rel="noopener">starter-banner</a>：启动横幅</p><ul><li>reflection: No、adjustment: cewnter、Stretch: Yes、width: 80</li><li>还不错的font：<ul><li>5lineoblique——好看</li><li>banner3——清楚</li><li>bell——抽象</li><li>big——清晰</li><li>bigchief——等高线版本、艺术</li><li>block——块状</li><li>bulbhead——可爱</li><li>larry3d——立体3d</li><li>ogre——清晰</li><li>puffy——清晰+一点可爱</li><li>slant——清晰+斜体</li></ul></li></ul></li><li><p>定时器框架apschedule配置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scheduler = BlockingScheduler(logger=scheduler_log, timezone=timezone)</span><br><span class="line"></span><br><span class="line">scheduler.add_job(__runProxyCheck, <span class="string">'interval'</span>, minutes=<span class="number">2</span>, id=<span class="string">"proxy_check"</span>, name=<span class="string">"proxy检查"</span>)</span><br><span class="line"></span><br><span class="line">executors = &#123;</span><br><span class="line">    <span class="comment"># job_defaults中的max_instances也受限于max_workers, 所以要大于max_instances；此外max_workers也决定了同时能处理几个同时发生的task</span></span><br><span class="line">    <span class="string">'default'</span>: &#123;<span class="string">'type'</span>: <span class="string">'threadpool'</span>, <span class="string">'max_workers'</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    <span class="string">'processpool'</span>: ProcessPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line">job_defaults = &#123;</span><br><span class="line">    <span class="comment"># 合并将所有这些错过的执行合并为一个, 默认为True。 如果是定时的存储任务的话，参数肯定不同，不能合并所以得手动设置False</span></span><br><span class="line">    <span class="comment"># 像本项目每隔一段时间抓取到的数据也不太一样，所以无法直接当作一次错误任务合并</span></span><br><span class="line">    <span class="string">'coalesce'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="comment"># 默认情况下，每个作业只允许同时运行一个实例。这意味着，如果作业即将运行，但前一次运行尚未完成，则认为最近一次运行失败。通过在添加作业时使用关键字参数，可以设置调度程序允许同时运行的特定作业的最大实例数。默认为1</span></span><br><span class="line">    <span class="string">'max_instances'</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="comment"># 框架会检查每个错过的执行时间，如果当前还在misfire_grace_time时间内，则会重新尝试执行任务，设高点就可以避免任务被漏掉执行。默认为1</span></span><br><span class="line">    <span class="comment"># "misfire_grace_time": 5  该项目未使用，而是采用了多任务实例来规避任务错过执行==&gt;即官方给出两种方案中的另一种。任务错过信息：Run time of job "say (trigger: interval[0:00:02])" was missed by 0:00:03.010383</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scheduler.configure(executors=executors, job_defaults=job_defaults, timezone=timezone)</span><br><span class="line">scheduler.start()</span><br></pre></td></tr></table></figure><p>job_defaults参数含义见<a href="https://apscheduler.readthedocs.io/en/3.x/userguide.html?highlight=max_instances#modifying-jobs" target="_blank" rel="noopener">官方文档</a>、<a href="https://blog.csdn.net/weixin_44301439/article/details/124062178" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44301439/article/details/124062178</a></p><p>注： 经过测试，在add_task中的func如果起了多个线程，其执行不受限于sche的配置</p></li><li><p>Python中如果只是使用全局变量则不需要用global声明（因为变量搜寻会由内往外），但是如果需要修改则需要用global声明，否则无法找到相应变量</p></li><li><p>生成器：使用了yield关键字的函数就是生成器，生成器是一类特殊的迭代器。</p><p>作用：</p><ul><li>处理大量数据：生成器一次返回一个结果，而不是一次返回所有结果。比如<code>sum([i for i in range(10000000000000)])</code>会卡机；<code>sum(i for i in range(10000000000000))</code>则不会</li><li><a href="https://blog.csdn.net/a200822146085/article/details/89388362" target="_blank" rel="noopener">代码更加简洁</a>：可以减少变量、空间</li><li>迭代器本身的作用</li></ul><p>yield关键字有两点作用：</p><p>保存当前运行状态（<strong>断点</strong>），然后暂停执行，即将生成器（函数）挂起；可以使用next()函数让生成器从断点处<strong>继续执行</strong>，即唤醒生成器（函数）<br>将yield关键字后面表达式的值作为<strong>返回值返回</strong>，此时可以理解为起到了return的作用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__runProxyFetch</span><span class="params">()</span>:</span>     </span><br><span class="line">    <span class="keyword">for</span> proxy <span class="keyword">in</span> proxy_fetcher.run():</span><br><span class="line">        proxy_queue.put(proxy)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span><span class="params">(object)</span>:</span></span><br><span class="line">    name = <span class="string">"fetcher"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># 相比使用生成推导式 return [p for p in proxy_dict.values() if DoValidator.preValidator(p.proxy)]， 使用yield生成器可以节省空间</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> proxy_dict.values():</span><br><span class="line">                <span class="keyword">if</span> DoValidator.preValidator(_.proxy):</span><br><span class="line">                    <span class="keyword">yield</span> _</span><br></pre></td></tr></table></figure></li><li><p>应用部署：</p><p>①对apk换源；②设置时区</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span>-alpine</span><br><span class="line"><span class="comment"># ..</span></span><br><span class="line"><span class="comment"># apk repository</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g'</span> /etc/apk/repositories</span></span><br><span class="line"><span class="bash"><span class="comment"># timezone</span></span></span><br><span class="line"><span class="bash">RUN apk add -U tzdata &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; apk del tzdata</span></span><br><span class="line"><span class="bash"><span class="comment"># ...</span></span></span><br><span class="line"><span class="bash">ENTRYPOINT [ <span class="string">"sh"</span>, <span class="string">"start.sh"</span> ]</span></span><br></pre></td></tr></table></figure><p><code>docker-compose.yml</code>： 镜像还没编译好的情况。（如果自己改了功能并启用的话，需要用这种；或者自己发布镜像后用后一种）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  proxy_pool:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">proxy_pool</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"5010:5010"</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">proxy_redis</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      DB_CONN:</span> <span class="string">"redis://@proxy_redis:6379/0"</span></span><br><span class="line"><span class="attr">  proxy_redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">"redis"</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">proxy_redis</span></span><br></pre></td></tr></table></figure><p><code>docker-compose.yml</code>：别人镜像已经编译好并上传</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">jhao104/proxy_pool</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DB_CONN=redis://redis:6379/0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"5010:5010"</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="scheduler的逻辑"><a class="markdownIt-Anchor" href="#scheduler的逻辑"></a> scheduler的逻辑</h3><p><img src="/2022/03/29/开源项目代码阅读记录/E:%5Chexo%5Csource_posts%5C%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95%5Cproxy_pool%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="proxy_pool时序图"></p><h3 id="项目目录结构默写"><a class="markdownIt-Anchor" href="#项目目录结构默写"></a> 项目目录结构默写：</h3><ul><li>settings: 配置文件</li><li>main：启动文件</li><li>api：提供获取proxy数据接口</li><li>handler:<ul><li>loggerHandler：日志类</li><li>configHandler：单例的配置接口类</li><li>ProxyHandler: Proxy CRUD操作类</li></ul></li><li>fetcher: 代理数据获取类</li><li>db:<ul><li>dbClinet： 存储功能接口类</li><li>redisClient：存储功能实现类</li></ul></li><li>helper<ul><li>scheduler: 定时任务的定义与启动类</li><li>validator: proxy有效性校验类</li><li>check: 具体执行校验逻辑类</li><li>proxy: 获取的proxy数据封装类</li></ul></li><li>utils:<ul><li>lazyProperty： 懒加载描述器</li><li>singleton: 单例管理器类</li><li>six： python2与python3兼容类</li><li>webRequest: 网络请求封装类</li></ul></li></ul><h2 id="极验滑块验证码破解与研究三滑块缺口识别"><a class="markdownIt-Anchor" href="#极验滑块验证码破解与研究三滑块缺口识别"></a> 极验滑块验证码破解与研究（三）：滑块缺口识别</h2><p>首先我们需要准备两张图片：1. 带缺口的背景图；2. 与之对应的接口图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> PIL</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imshow</span><span class="params">(img, winname=<span class="string">'test'</span>, delay=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""cv2展示图片"""</span></span><br><span class="line">    cv2.imshow(winname, img)</span><br><span class="line">    cv2.waitKey(delay)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pil_to_cv2</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    pil转cv2图片</span></span><br><span class="line"><span class="string">    :param img: pil图像, &lt;type 'PIL.JpegImagePlugin.JpegImageFile'&gt;</span></span><br><span class="line"><span class="string">    :return: cv2图像, &lt;type 'numpy.ndarray'&gt;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    img = cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bytes_to_cv2</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    二进制图片转cv2</span></span><br><span class="line"><span class="string">    :param img: 二进制图片数据, &lt;type 'bytes'&gt;</span></span><br><span class="line"><span class="string">    :return: cv2图像, &lt;type 'numpy.ndarray'&gt;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 将图片字节码bytes, 转换成一维的numpy数组到缓存中</span></span><br><span class="line">    img_buffer_np = np.frombuffer(img, dtype=np.uint8)</span><br><span class="line">    <span class="comment"># 从指定的内存缓存中读取一维numpy数据, 并把数据转换(解码)成图像矩阵格式</span></span><br><span class="line">    img_np = cv2.imdecode(img_buffer_np, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> img_np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv2_open</span><span class="params">(img, flag=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    统一输出图片格式为cv2图像, &lt;type 'numpy.ndarray'&gt;</span></span><br><span class="line"><span class="string">    :param img: &lt;type 'bytes'/'numpy.ndarray'/'str'/'Path'/'PIL.JpegImagePlugin.JpegImageFile'&gt;</span></span><br><span class="line"><span class="string">    :param flag: 颜色空间转换类型, default: None</span></span><br><span class="line"><span class="string">        eg: cv2.COLOR_BGR2GRAY（灰度图）</span></span><br><span class="line"><span class="string">    :return: cv2图像, &lt;numpy.ndarray&gt;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(img, bytes):</span><br><span class="line">        img = bytes_to_cv2(img)</span><br><span class="line">    <span class="keyword">elif</span> isinstance(img, (str, Path)):</span><br><span class="line">        img = cv2.imread(str(img))</span><br><span class="line">    <span class="keyword">elif</span> isinstance(img, np.ndarray):</span><br><span class="line">        img = img</span><br><span class="line">    <span class="keyword">elif</span> isinstance(img, PIL.Image):</span><br><span class="line">        img = pil_to_cv2(img)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f'输入的图片类型无法解析: <span class="subst">&#123;type(img)&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">if</span> flag <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        img = cv2.cvtColor(img, flag)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_distance</span><span class="params">(bg, tp, im_show=False, save_path=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param bg: 背景图路径或Path对象或图片二进制</span></span><br><span class="line"><span class="string">        eg: 'assets/bg.jpg'</span></span><br><span class="line"><span class="string">            Path('assets/bg.jpg')</span></span><br><span class="line"><span class="string">    :param tp: 缺口图路径或Path对象或图片二进制</span></span><br><span class="line"><span class="string">        eg: 'assets/tp.jpg'</span></span><br><span class="line"><span class="string">            Path('assets/tp.jpg')</span></span><br><span class="line"><span class="string">    :param im_show: 是否显示结果, &lt;type 'bool'&gt;; default: False</span></span><br><span class="line"><span class="string">    :param save_path: 保存路径, &lt;type 'str'/'Path'&gt;; default: None</span></span><br><span class="line"><span class="string">    :return: 缺口位置</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 读取图片</span></span><br><span class="line">    bg_gray = cv2_open(bg, flag=cv2.COLOR_BGR2GRAY)</span><br><span class="line">    tp_gray = cv2_open(tp, flag=cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># 边缘检测</span></span><br><span class="line">    tp_gray = cv2.Canny(tp_gray, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">    bg_gray = cv2.Canny(bg_gray, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">    <span class="comment"># 目标匹配</span></span><br><span class="line">    result = cv2.matchTemplate(bg_gray, tp_gray, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">    <span class="comment"># 解析匹配结果</span></span><br><span class="line">    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)</span><br><span class="line"></span><br><span class="line">    distance = max_loc[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> save_path <span class="keyword">or</span> im_show:</span><br><span class="line">        <span class="comment"># 需要绘制的方框高度和宽度</span></span><br><span class="line">        tp_height, tp_width = tp_gray.shape[:<span class="number">2</span>]</span><br><span class="line">        <span class="comment"># 矩形左上角点位置</span></span><br><span class="line">        x, y = max_loc</span><br><span class="line">        <span class="comment"># 矩形右下角点位置</span></span><br><span class="line">        _x, _y = x + tp_width, y + tp_height</span><br><span class="line">        <span class="comment"># 绘制矩形</span></span><br><span class="line">        bg_img = cv2_open(bg)</span><br><span class="line">        cv2.rectangle(bg_img, (x, y), (_x, _y), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 保存缺口识别结果到背景图</span></span><br><span class="line">        <span class="keyword">if</span> save_path:</span><br><span class="line">            save_path = Path(save_path).resolve()</span><br><span class="line">            save_path = save_path.parent / <span class="string">f"<span class="subst">&#123;save_path.stem&#125;</span>.<span class="subst">&#123;distance&#125;</span><span class="subst">&#123;save_path.suffix&#125;</span>"</span></span><br><span class="line">            save_path = save_path.__str__()</span><br><span class="line">            cv2.imwrite(save_path, bg_img)</span><br><span class="line">        <span class="comment"># 显示缺口识别结果</span></span><br><span class="line">        <span class="keyword">if</span> im_show:</span><br><span class="line">            imshow(bg_img)</span><br><span class="line">    <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    d = get_distance(</span><br><span class="line">        bg=<span class="string">'assets/bg.jpg'</span>,</span><br><span class="line">        tp=<span class="string">'assets/tp.png'</span>,</span><br><span class="line">        im_show=<span class="keyword">True</span>,</span><br><span class="line">        save_path=<span class="string">'assets/bg.jpg'</span></span><br><span class="line">    )</span><br><span class="line">    print(d)</span><br></pre></td></tr></table></figure><p>类似代码：<strong><a href="https://github.com/lixi5338619/lxBook" target="_blank" rel="noopener">lxBook</a></strong></p><p>相关文章：</p><ol><li><a href="https://blog.csdn.net/qq_42857999/article/details/121586389" target="_blank" rel="noopener">极验滑块验证码破解与研究（一）：AST还原混淆JS</a></li><li><a href="https://blog.csdn.net/qq_42857999/article/details/121628908" target="_blank" rel="noopener">极验滑块验证码破解与研究（二）：缺口图片还原</a></li><li><a href="https://blog.csdn.net/qq_42857999/article/details/121635961" target="_blank" rel="noopener">极验滑块验证码破解与研究（三）：滑块缺口识别</a></li><li><a href="https://blog.csdn.net/qq_42857999/article/details/121659205" target="_blank" rel="noopener">极验滑块验证码破解与研究（四）：滑块轨迹构造</a></li><li><a href="https://blog.csdn.net/qq_42857999/article/details/121674134" target="_blank" rel="noopener">极验滑块验证码破解与研究（五）：请求分析及加密参数破解</a></li></ol><h1 id="机器学习"><a class="markdownIt-Anchor" href="#机器学习"></a> 机器学习</h1><h2 id="cardrecorder"><a class="markdownIt-Anchor" href="#cardrecorder"></a> <strong><a href="https://github.com/ZDZX-T/cardRecorder" target="_blank" rel="noopener">cardRecorder</a></strong></h2><blockquote><p>通过pyautoGUI实现的斗地主记牌器，提供了tkinter的界面</p></blockquote><ul><li><p>使用pyAutoGui找到类似的图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"># 进行截图</span></span><br><span class="line">   img = pyautogui.screenshot(region=myPos)</span><br><span class="line"><span class="comment"># 遍历所有排类型    </span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> myCardsNum.keys():</span><br><span class="line">       <span class="comment"># 进行定位, 找到pics\\m1.png在当前图片img里的位置</span></span><br><span class="line">       result = pyautogui.locateAll(needleImage=<span class="string">'pics\\m'</span> + i + <span class="string">'.png'</span>, haystackImage=img, confidence=myConfidence)</span><br><span class="line">       </span><br><span class="line">       myCardsNum[i] = cardsFilter(list(result), myFilter)</span><br></pre></td></tr></table></figure><p>pyautoGUI图片识别功能介绍：</p><blockquote><p>PyAutoGUI可以截取屏幕截图（截图），将其保存到文件中，并在屏幕中查找图像(定位)。</p></blockquote><ul><li>截图</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 截全屏</span></span><br><span class="line">pg.screenshot()  <span class="comment"># 只会保存到内存，不会缓存到本地</span></span><br><span class="line">pg.screenshot(<span class="string">'data/screenshot.jpg'</span>)  <span class="comment"># 指定路径，则会保存到本地</span></span><br><span class="line"><span class="comment"># 按照指定区域截屏, region(x坐标,y坐标,宽度,高度)，坐标为指定截图的左上角坐标</span></span><br><span class="line">pg.screenshot(imageFilename=<span class="string">'data/screenshot.jpeg'</span>, region=(<span class="number">300</span>, <span class="number">300</span>, <span class="number">500</span>, <span class="number">500</span>))</span><br></pre></td></tr></table></figure><ul><li>图片定位</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在屏幕中匹配图片，并返回位置相关数据，匹配不到则返回 None</span></span><br><span class="line">locate_1 = pg.locateOnScreen(image=<span class="string">'data/test.png'</span>)</span><br><span class="line">print(locate_1)  <span class="comment"># Box(left=177, top=614, width=43, height=37)</span></span><br><span class="line">print(locate_1.left)  <span class="comment"># 177  可以通过 .left 等属性获取相应的值</span></span><br><span class="line">print(locate_1[<span class="number">0</span>])  <span class="comment"># 177  也可以通过下标获取相应的值</span></span><br><span class="line"><span class="comment"># “模糊”匹配  --  可以使用参数 confidence 来指定模糊程度，默认是 1，范围是 0 - 1（当然，太低就没意义了）, 使用该参数要求已经安装好 openCV</span></span><br><span class="line"><span class="comment"># 这里的路径关键字是 image，和上面的 imageFilename 不同，所以建议不要写关键字，直接写路径就好，防止写错</span></span><br><span class="line">locate_2 = pg.locateOnScreen(image=<span class="string">'data/test.png'</span>, confidence=<span class="number">0.9</span>)</span><br><span class="line"><span class="comment"># 返回匹配到的图片的中心位置坐标</span></span><br><span class="line">center_point_1 = pg.center(locate_1)</span><br><span class="line">print(center_point_1)  <span class="comment"># Point(x=198, y=632)</span></span><br></pre></td></tr></table></figure><p>注：屏幕截图功能需要Pillow模块、置信度需要cv</p><p>参考：<a href="https://www.cnblogs.com/math98/p/14399644.html" target="_blank" rel="noopener">PyAutoGui 图片识别+定位+截图函数文档</a>、<a href="https://zhuanlan.zhihu.com/p/417147884" target="_blank" rel="noopener">pyautogui 的截图及图片匹配</a>、<a href="https://www.cnblogs.com/gexbooks/p/10790063.html" target="_blank" rel="noopener">pyautogui 文档（五）：截图及定位功能</a></p></li><li><p>tkinter使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量使用</span></span><br><span class="line">num_8 = tkinter.StringVar()  <span class="comment"># 8</span></span><br><span class="line">num_8.set(strCards[<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">root = tkinter.Tk()</span><br><span class="line"><span class="comment"># 显示</span></span><br><span class="line">x_start = <span class="number">20</span></span><br><span class="line">y_start = <span class="number">5</span></span><br><span class="line">x_add = <span class="number">30</span></span><br><span class="line">x_dif = <span class="number">2</span></span><br><span class="line">y_dif = <span class="number">25</span></span><br><span class="line"><span class="comment"># 标签</span></span><br><span class="line">tkinter.Label(root, text=<span class="string">'大'</span>, font=(<span class="string">''</span>, <span class="number">14</span>), width=<span class="number">1</span>).place(x=x_start, y=y_start)</span><br><span class="line"><span class="comment"># 输入框</span></span><br><span class="line">tkinter.Entry(root, textvariable=num_dw, font=(<span class="string">''</span>, <span class="number">14</span>), width=<span class="number">1</span>).place(x=x_start + x_dif, y=y_start + y_dif)</span><br><span class="line"><span class="comment"># 进行循环等待事件发生</span></span><br><span class="line">root.main_loop()</span><br></pre></td></tr></table></figure><p>布局</p><ul><li>pack()：将控件放置在父控件内之前，规划此控件在区块内的位置。</li><li>grid()：将控件放置在父控件内之前，规划此控件为一个网格类型的架构。</li><li>place()：将控件放置在父控件内的特定(指定)位置。</li></ul></li></ul><h2 id="wiki_zh_word2vec"><a class="markdownIt-Anchor" href="#wiki_zh_word2vec"></a> <strong><a href="https://github.com/AimeeLee77/wiki_zh_word2vec" target="_blank" rel="noopener">wiki_zh_word2vec</a></strong></h2><blockquote><p>利用Python构建Wiki中文语料词向量模型试验——找到给定词相似的词语</p><p>代码涉及：开发环境准备、数据的获取、数据的预处理、模型构建和模型测试四大内容，对应的是实现模型构建的五个步骤。</p></blockquote><ol><li><p>开发环境准备: Python + gensim (NLP神器库) +jieba + <a href="https://bintray.com/package/files/byvoid/opencc/OpenCC" target="_blank" rel="noopener">OpenCC</a>(中文繁体替换成简体)</p></li><li><p>数据获取: 到wiki官网下载<a href="https://dumps.wikimedia.org/zhwiki/latest/zhwiki-latest-pages-articles.xml.bz2" target="_blank" rel="noopener">中文语料</a>、将XML的Wiki数据转换为text格式，使用到了gensim.corpora中的WikiCorpus函数</p></li><li><p>Wiki数据预处理：①使用OpenCC进行繁简转换；②jieba分词</p></li><li><p>Word2Vec模型训练：分好词的文档即可进行word2vec词向量模型的训练了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练skip-gram模型</span></span><br><span class="line">model = Word2Vec(LineSentence(inp), size=<span class="number">400</span>, window=<span class="number">5</span>, min_count=<span class="number">5</span>,</span><br><span class="line">                 workers=multiprocessing.cpu_count())</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">model.save(outp1)</span><br><span class="line">model.wv.save_word2vec_format(outp2, binary=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>代码运行完成后得到如下四个文件，其中wiki.zh.text.model是建好的模型，wiki.zh.text.vector是词向量。</p></li><li><p>模型测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">model = gensim.models.Word2Vec.load(fdir + <span class="string">'wiki.zh.text.model'</span>)</span><br><span class="line">word = model.most_similar(<span class="string">u"足球"</span>)</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> word:</span><br><span class="line">    <span class="keyword">print</span> (t[<span class="number">0</span>],t[<span class="number">1</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">足球运动 0.531202495098</span></span><br><span class="line"><span class="string">国际足球 0.510423064232</span></span><br><span class="line"><span class="string">足球比赛 0.499910503626</span></span><br><span class="line"><span class="string">国家足球队 0.488919615746</span></span><br><span class="line"><span class="string">排球 0.488108128309</span></span><br><span class="line"><span class="string">男体子篮球0.482638418674</span></span><br><span class="line"><span class="string">体育 0.47221454978</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></li></ol><p>附：什么是词向量? ——词向量技术是将词转化成为稠密向量，并且对于相似的词，其对应的词向量也相近。</p><p>在<a href="https://so.csdn.net/so/search?q=%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">自然语言处理</a>任务中，首先需要考虑词如何在计算机中表示。通常，有两种表示方式：</p><ul><li>one-hot representation(离散表示)<ul><li>传统的基于规则或基于统计的自然语义处理方法将单词看作一个原子符号</li><li>把每个词表示为一个长向量。这个向量的维度是词表大小，向量中只有一个维度的值为1，其余维度为0，这个维度就代表了当前的词。</li><li>one-hot representation相当于给每个词分配一个id，这就导致这种表示方式不能展示词与词之间的关系。另外，one-hot representation将会导致特征空间非常大，但也带来一个好处，就是在高维空间中，很多应用任务线性可分。</li></ul></li><li>distribution representation(分布式表示)<ul><li>word embedding指的是将词转化成一种分布式表示，又称词向量。分布式表示将词表示成一个定长的连续的稠密向量。</li><li>分布式表示优点:<ol><li>词之间存在相似关系：是词之间存在“距离”概念，这对很多自然语言处理的任务非常有帮助。</li><li>包含更多信息：词向量能够包含更多信息，并且每一维都有特定的含义。在采用one-hot特征时，可以对特征向量进行删减，词向量则不能。</li></ol></li></ul></li></ul><h1 id="系统设计"><a class="markdownIt-Anchor" href="#系统设计"></a> 系统设计</h1><h2 id="python-自制屏幕翻译工具"><a class="markdownIt-Anchor" href="#python-自制屏幕翻译工具"></a> <a href="https://pythondict.com/python-work/screen-translate-tools/" target="_blank" rel="noopener">Python 自制屏幕翻译工具</a></h2><p>程序的功能主要由3个模块组成</p><ol><li><p>screenshot：截图</p><blockquote><p>使用Pillow库</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装PIL依赖: pip install pillow</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step1: 从剪切板读取图片</span></span><br><span class="line">img = ImageGrab.grabclipboard()</span><br><span class="line"><span class="comment"># 保存到本地 or 内存中</span></span><br><span class="line">image_result = <span class="string">'./temp.png'</span></span><br><span class="line">img.save(image_result)</span><br></pre></td></tr></table></figure></li><li><p>recognition：将截图中的问题识别成文字</p><blockquote><p>使用easyocr或者pytesseract</p></blockquote><p>easyocr：</p><ul><li>编程使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> easyocr</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行的过程中会安装所需要的模型文件, 也可以自己下载后放到对应路径下</span></span><br><span class="line"><span class="comment"># Windows：C:\Users\用户名.EasyOCR\model</span></span><br><span class="line"><span class="comment"># Linux：~/ .EasyOCR / model</span></span><br><span class="line">reader = easyocr.Reader([<span class="string">'ch_sim'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用GPU，看是否会有提示 CUDA not available</span></span><br><span class="line"><span class="comment"># reader = easyocr.Reader(['ch_sim'])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持同时多个语言, 虽然可以一次性识别许多种语言，</span></span><br><span class="line"><span class="comment"># 但并非所有语言都可以一起用，通常是公共语言和一个特殊语种可以一起识别，相互兼容，比如英语和日语。</span></span><br><span class="line"><span class="comment"># reader = easyocr.Reader(['ch_sim','en'])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 识别</span></span><br><span class="line">resp = requests.get(<span class="string">'https://images.zsxq.com/Fsl4plilMdpd_C8gXVJT1mKJDui9?e=1656604799&amp;token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:Pg0990rjMMQUAlf2bJlNL9lmLSU='</span>)</span><br><span class="line">result = reader.readtext(resp.content)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><ul><li>命令行运行： <code>easyocr -l ch_sim en -f test.png --detail=1 --gpu=True</code></li></ul><p>图片加载函数<code>readtext</code>接收三种参数</p><ul><li>文件路径</li><li>图片的<code>np_array</code></li><li>字节流对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> easyocr</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从剪切板中获得图片</span></span><br><span class="line">r = easyocr.Reader([<span class="string">"ch_sim"</span>])</span><br><span class="line"></span><br><span class="line">img = ImageGrab.grabclipboard()</span><br><span class="line">print(img, type(img))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数为: file path or numpy-array or a byte stream object</span></span><br><span class="line"><span class="comment"># 1: file path</span></span><br><span class="line">img_path = <span class="string">"ttt.png"</span></span><br><span class="line">img.save(img_path)</span><br><span class="line">reg_result = r.readtext(img_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2: numpy-array</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np_img = np.array(img)</span><br><span class="line">reg_result = r.readtext(np_img)</span><br><span class="line">print(reg_result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3: a byte stream object</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">resp = requests.get(<span class="string">'https://images.zsxq.com/Fsl4plilMdpd_C8gXVJT1mKJDui9?e=1656604799&amp;token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:Pg0990rjMMQUAlf2bJlNL9lmLSU='</span>)</span><br><span class="line">reg_result = r.readtext(resp.content)</span><br><span class="line">print(reg_result)</span><br></pre></td></tr></table></figure></li><li><p>Translation：将文字翻译</p><blockquote><p>可以使用网上的有道翻译API、或者直接使用Google提供的翻译库<code>googletrans</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Google翻译</span></span><br><span class="line">translator = Translator(service_urls=[<span class="string">'translate.google.cn'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译成中文</span></span><br><span class="line">content_chinese = translator.translate(content_eng, src=<span class="string">'en'</span>, dest=<span class="string">'zh-cn'</span>).text</span><br></pre></td></tr></table></figure></li><li><p>GUI：将翻译后的结果展示</p><blockquote><p>使用 Python 自带的 GUI tkinker，将识别后的中文显示出来。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">root = Tk()</span><br><span class="line">root.withdraw()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示翻译后的结果，以对话框的形式</span></span><br><span class="line">tkinter.messagebox.showinfo(<span class="string">'翻译结果'</span>, content_chinese)</span><br></pre></td></tr></table></figure></li></ol><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> easyocr</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab, Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = easyocr.Reader(["ch_sim"])</span></span><br><span class="line">r = easyocr.Reader([<span class="string">"en"</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">screenShot</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""1. 从剪切板中获得图片"""</span></span><br><span class="line">    img = ImageGrab.grabclipboard()</span><br><span class="line">    print(img, type(img))</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">identify</span><span class="params">(img: Image)</span>:</span></span><br><span class="line">    <span class="string">"""2. 识别文字"""</span></span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    np_img = np.array(img)</span><br><span class="line">    reg_result = r.readtext(np_img)</span><br><span class="line">    rs = sorted(reg_result, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>], reverse=<span class="keyword">True</span>)[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> rs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">(rs: str)</span>:</span></span><br><span class="line">    <span class="string">"""3. 翻译：googletrans 库"""</span></span><br><span class="line">    <span class="keyword">from</span> googletrans <span class="keyword">import</span> Translator</span><br><span class="line">    <span class="comment"># Google翻译</span></span><br><span class="line">    translator = Translator(service_urls=[<span class="string">'translate.google.cn'</span>])</span><br><span class="line">    <span class="comment"># 翻译成中文</span></span><br><span class="line">    translated_str = translator.translate(rs, src=<span class="string">'en'</span>, dest=<span class="string">'zh-cn'</span>).text</span><br><span class="line">    <span class="keyword">return</span> translated_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showText</span><span class="params">(s: str)</span>:</span></span><br><span class="line">    <span class="string">"""4. tk展示"""</span></span><br><span class="line">    <span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line">    <span class="keyword">from</span> tkinter.messagebox <span class="keyword">import</span> showinfo  <span class="comment"># 弹窗库</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到主应用</span></span><br><span class="line">    root = tk.Tk()</span><br><span class="line">    <span class="comment"># 隐藏主界面</span></span><br><span class="line">    root.withdraw()</span><br><span class="line">    print(s)</span><br><span class="line">    showinfo(<span class="string">"翻译结果"</span>, s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    img = screenShot()</span><br><span class="line">    <span class="comment"># 识别出来的文字</span></span><br><span class="line">    rs = identify(img)</span><br><span class="line">    translated_str = translate(rs)</span><br><span class="line">    showText(translated_str)</span><br></pre></td></tr></table></figure><h2 id="system-design-primer"><a class="markdownIt-Anchor" href="#system-design-primer"></a> <strong><a href="https://github.com/donnemartin/system-design-primer" target="_blank" rel="noopener">system-design-primer</a></strong></h2><h2 id="go-package-plantuml"><a class="markdownIt-Anchor" href="#go-package-plantuml"></a> <strong><a href="https://github.com/qquunn/go-package-plantuml" target="_blank" rel="noopener"> go-package-plantuml</a></strong></h2><ul><li>go中的argueparser：<code>&quot;import github.com/jessevdk/go-flags&quot;</code>。除此之外，还有flag、pflag来处理输入参数</li></ul><h2 id="id-maker"><a class="markdownIt-Anchor" href="#id-maker"></a> <a href="https://github.com/yongxinz/id-maker" target="_blank" rel="noopener">id-maker</a></h2><h2 id="health_checker"><a class="markdownIt-Anchor" href="#health_checker"></a> <a href="https://github.com/Freedomisgood/When_Coding_in_ZJU/blob/main/Health_Checkin/health_checkin_helper_cst.py" target="_blank" rel="noopener">health_checker</a></h2><blockquote><p>浙大的登陆加密</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python转义实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_rsa_encrypt</span><span class="params">(self, password_str, e_str, M_str)</span>:</span></span><br><span class="line">    <span class="comment"># 将str转化为ascii的字节</span></span><br><span class="line">    password_bytes = bytes(password_str, <span class="string">'ascii'</span>)</span><br><span class="line">    <span class="comment"># 大端填充</span></span><br><span class="line">    password_int = int.from_bytes(password_bytes, <span class="string">'big'</span>)</span><br><span class="line">    <span class="comment"># 将其按照16进制的形式转成10进制</span></span><br><span class="line">    e_int = int(e_str, <span class="number">16</span>)</span><br><span class="line">    M_int = int(M_str, <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># password_int^e%M</span></span><br><span class="line">    result_int = pow(password_int, e_int, M_int)</span><br><span class="line">    <span class="comment"># 10进制转成16进制str, 并 rjust() 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。</span></span><br><span class="line">    <span class="comment"># "hello".rjust(8, "0") ==&gt; 000hello</span></span><br><span class="line">    <span class="keyword">return</span> hex(result_int)[<span class="number">2</span>:].rjust(<span class="number">128</span>, <span class="string">'0'</span>)</span><br></pre></td></tr></table></figure><p>Js加密</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">RSAUtils.encryptedString = <span class="function"><span class="keyword">function</span>(<span class="params">key, s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">    <span class="comment">// s为反向的password, 如321321aaa</span></span><br><span class="line"><span class="keyword">var</span> sl = s.length;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; sl) &#123;</span><br><span class="line">a[i] = s.charCodeAt(i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 补足0</span></span><br><span class="line"><span class="keyword">while</span> (a.length % key.chunkSize != <span class="number">0</span>) &#123;</span><br><span class="line">a[i++] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a ==&gt; 321312aaa000000 的 ascii字符数组</span></span><br><span class="line"><span class="keyword">var</span> al = a.length;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> j, k, block;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al; i += key.chunkSize) &#123;</span><br><span class="line">block = <span class="keyword">new</span> BigInt();</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (k = i; k &lt; i + key.chunkSize; ++j) &#123;</span><br><span class="line">block.digits[j] = a[k++];</span><br><span class="line">block.digits[j] += a[k++] &lt;&lt; <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> crypt = key.barrett.powMod(block, key.e);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> text = key.radix == <span class="number">16</span> ? RSAUtils.biToHex(crypt) : RSAUtils.biToString(crypt, key.radix);</span><br><span class="line">result += text + <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.substring(<span class="number">0</span>, result.length - <span class="number">1</span>); <span class="comment">// Remove last space.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>new BigInt();</code>得到的是digits.len=130的int数组</li></ul><h2 id="cookiecutter-golang"><a class="markdownIt-Anchor" href="#cookiecutter-golang"></a> <strong><a href="https://github.com/lacion/cookiecutter-golang" target="_blank" rel="noopener">cookiecutter-golang</a></strong></h2><blockquote><p>快速生成Go项目的cookiecutter模板</p></blockquote><ul><li><a href="https://github.com/lacion/cookiecutter-golang/blob/master/%7B%7Bcookiecutter.app_name%7D%7D/main.go" target="_blank" rel="noopener">cobar使用</a>与<a href="https://github.com/lacion/cookiecutter-golang/blob/master/%7B%7Bcookiecutter.app_name%7D%7D/cmd/root.go" target="_blank" rel="noopener">cobar命令定义</a>，相当于Python中的Click模块</li></ul><h2 id="dddd_trainer"><a class="markdownIt-Anchor" href="#dddd_trainer"></a> <strong><a href="https://github.com/sml2h3/dddd_trainer" target="_blank" rel="noopener"> dddd_trainer</a></strong></h2><ul><li><p>Cli命令使用fire库：fire是python中用于生成命令行界面(Command Line Interfaces, CLIs)的工具，不需要做任何额外的工作，只需要从主模块中调用fire.Fire()，它会自动将你的代码转化为CLI，<u>Fire()的参数可以说任何的python对象</u></p><p>特点：所有的<strong>子命令</strong>都能以函数、类等形式书写，流程和参数获取都比较清晰；传参可以自动被解析成Python类型：字符串、元组、列表、字典</p><p>★使用指南： <a href="https://blog.csdn.net/qq_17550379/article/details/79943740" target="_blank" rel="noopener">https://blog.csdn.net/qq_17550379/article/details/79943740</a></p></li><li><p><a href="https://www.jianshu.com/p/476478c17b8e" target="_blank" rel="noopener">ONNXRuntime</a>： 通常我们在训练模型时可以使用很多不同的框架，比如有的同学喜欢用 <code>Pytorch</code>，有的同学喜欢使用 <code>TensorFLow</code>，也有的喜欢 <code>MXNet</code>，以及深度学习最开始流行的 <code>Caffe</code>等等，这样不同的训练框架就导致了产生不同的模型结果包，在模型进行部署推理时就需要不同的依赖库，而且同一个框架比如<code>tensorflow</code> 不同的版本之间的差异较大， 为了解决这个混乱问题，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Flfaidata.foundation%2F" target="_blank" rel="noopener">LF AI</a> 这个组织联合 Facebook, MicroSoft等公司制定了机器学习模型的标准，这个标准叫做<strong>ONNX, Open Neural Network Exchage</strong>，<em>所有其他框架产生的模型包 (<code>.pth</code>, <code>.pb</code>) 都可以转换成这个标准格式，转换成这个标准格式后，就可以使用统一的 ONNX Runtime等工具进行统一部署。</em></p></li><li><p><a href="https://pythondict.com/life-intelligent/tools/loguru/" target="_blank" rel="noopener">Loguru — 最强大的 Python 日志记录器</a>： 强大的全局日志对象，具有开箱即用的特性、美观的输出，支持<code>f-string</code>、支持在主进程和线程中捕获异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger.add(<span class="string">"file.log"</span>, rotation=<span class="string">"12:00"</span> , format=<span class="string">"&#123;time:YYYY-MM-DD at HH:mm:ss&#125; | &#123;level&#125; | &#123;message&#125;"</span>, level=<span class="string">"INFO"</span>)</span><br><span class="line">logger.info(<span class="string">"That's it, beautiful and simple logging!"</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="njupt-api"><a class="markdownIt-Anchor" href="#njupt-api"></a> <strong><a href="https://github.com/gaoliang/NJUPT-API" target="_blank" rel="noopener">NJUPT-API</a></strong></h2><blockquote><p>南京邮电大学网站接口, Python模块</p></blockquote><ul><li><p><code>@login_required</code> 装饰器: 由于有些操作必须登录后才会有正确结果，所以相当于在执行前做了一层校验（至于抛出异常or转向登录就看装饰器中怎么写了）—&gt; 由于是封装成了package库，所以在这一层需要进行限制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_required</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.verified:</span><br><span class="line">            self.login_by_sso()</span><br><span class="line">        <span class="keyword">return</span> func(self, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></li><li><p>setuptools使用</p><ul><li><a href="http://setup.py" target="_blank" rel="noopener">setup.py</a></li><li><a href="http://MANIFEST.in" target="_blank" rel="noopener">MANIFEST.in</a></li></ul></li><li><p>模块暴露：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># njupt/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> njupt.card <span class="keyword">import</span> Card  <span class="comment"># noqa</span></span><br><span class="line"><span class="keyword">from</span> njupt.zhengfang <span class="keyword">import</span> Zhengfang  <span class="comment"># noqa</span></span><br><span class="line"><span class="keyword">from</span> njupt.library <span class="keyword">import</span> Library  <span class="comment"># noqa</span></span><br><span class="line"><span class="keyword">from</span> njupt.runningman <span class="keyword">import</span> RunningMan  <span class="comment"># noqa</span></span><br><span class="line"><span class="keyword">from</span> njupt.sso <span class="keyword">import</span> SSO  <span class="comment"># noqa</span></span><br><span class="line"><span class="comment"># 表示njupt模块提供以下5个接口</span></span><br><span class="line">__all__ = [<span class="string">'SSO'</span>, <span class="string">'Card'</span>, <span class="string">'Zhengfang'</span>, <span class="string">'Library'</span>, <span class="string">'RunningMan'</span>]</span><br></pre></td></tr></table></figure></li><li><p>验证码识别</p><blockquote><p>字符型验证码：把图片去噪、分割、归类。收集了足够多的样本，然后对新的图片也分割。将分隔后的每个字符与样本集匹配，选概率最大的字符，将组合</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CardCaptcha</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    一卡通系统的验证码工具类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, im)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param im: PIL.image对象</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.im = im.convert(<span class="string">'L'</span>)</span><br><span class="line">        self.image_pre_process()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">image_pre_process</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 二值化, 去除杂色点</span></span><br><span class="line">        threshold = <span class="number">200</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(self.im.width):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(self.im.height):</span><br><span class="line">                pix = self.im.getpixel((x, y))</span><br><span class="line">                <span class="keyword">if</span> pix &gt; threshold:</span><br><span class="line">                    self.im.putpixel((x, y), BLACK)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.im.putpixel((x, y), WHITE)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_split_image</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 切割验证码，返回包含五个字符图像的列表</span></span><br><span class="line">        y_min, y_max = <span class="number">0</span>, <span class="number">82</span></span><br><span class="line">        <span class="comment"># 字符位置大致固定([7,49], [49, 91], ...)</span></span><br><span class="line">        split_lines = [<span class="number">7</span>, <span class="number">49</span>, <span class="number">91</span>, <span class="number">133</span>, <span class="number">175</span>, <span class="number">217</span>]</span><br><span class="line">        ims = [self.im.crop([u, y_min, v, y_max]) <span class="keyword">for</span> u, v <span class="keyword">in</span> zip(split_lines[:<span class="number">-1</span>], split_lines[<span class="number">1</span>:])]</span><br><span class="line">        <span class="keyword">return</span> ims</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crack</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 装载训练数据集</span></span><br><span class="line">        <span class="keyword">with</span> open(os.path.join(current_dir, <span class="string">'image_data.json'</span>), <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            image_data = json.load(f)</span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> self.handle_split_image():</span><br><span class="line">            <span class="comment"># build_vector将图片转成一维向量: for pixel in image.getdata():</span></span><br><span class="line">            letter_vector = build_vector(letter)</span><br><span class="line">            guess = []</span><br><span class="line">            <span class="comment"># 在模型数据中, 找一个汉明距离最小(最像的结果)</span></span><br><span class="line">            <span class="keyword">for</span> image <span class="keyword">in</span> image_data:</span><br><span class="line">                <span class="comment"># x为key, 当前匹配的字符; y为向量</span></span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> image.items():</span><br><span class="line">                    <span class="keyword">if</span> len(y) != <span class="number">0</span>:</span><br><span class="line">                        <span class="comment"># 计算两个一维向量的汉明距（向量只包含0，1时）:(只要元素值不等, 距离就+1)</span></span><br><span class="line">                        guess.append((distance_hanmming(y, letter_vector), x))</span><br><span class="line">            guess.sort()</span><br><span class="line">            <span class="comment"># 找出距离最小的, 即最匹配的字符</span></span><br><span class="line">            result.append(guess[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.crack()</span><br></pre></td></tr></table></figure><p>注：PIL中image.convert()函数使用</p><ol><li>模式“1”：为二值图像，非黑即白。但是它每个像素用8个bit表示，0表示黑，255表示白。</li><li>模式“L”： 为灰色图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。在PIL中，从模式“RGB”转换为“L”模式是按照下面的公式转换的：<code>L = R * 299/1000 + G * 587/1000+ B * 114/1000</code></li><li>模式“P”为8位彩色图像、模式“RGBA”(alpha透明度)为32位彩色图像、模式“CMYK”为32位彩色图像</li></ol></li><li><p>自制打码工具</p><ol><li><code>captcha_getter.py</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据图片自己输入识别结果, 将图片保存下来, 图片名为正确的打码结果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaptchaGUI</span>:</span></span><br><span class="line">    BASE_URL = <span class="string">"http://yktapp.njupt.edu.cn:8070"</span></span><br><span class="line">    CAPTCHA_URL = BASE_URL + <span class="string">"/Login/GetValidateCode"</span></span><br><span class="line">    LOGIN_URL = BASE_URL + <span class="string">"/Login/LoginBySnoQuery"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s = requests.session()</span><br><span class="line">        self.r = self.s.get(self.CAPTCHA_URL)</span><br><span class="line">        self.im = Image.open(BytesIO(self.r.content))</span><br><span class="line">        self.root = tkinter.Tk()</span><br><span class="line">        self.tkimg = ImageTk.PhotoImage(self.im)</span><br><span class="line">        self.imgLabel = tkinter.Label(self.root, image=self.tkimg)</span><br><span class="line">        self.imgLabel.pack()</span><br><span class="line">        self.message = tkinter.Entry(self.root)</span><br><span class="line">        self.message.pack()</span><br><span class="line">        self.root.bind(<span class="string">'&lt;Return&gt;'</span>, self.judge_and_save)</span><br><span class="line">        self.root.mainloop()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judge_and_save</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        <span class="comment"># 输出输入框的内容</span></span><br><span class="line">        captcha_value = self.message.get()</span><br><span class="line">        print(captcha_value)</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">"sno"</span>: self.account,</span><br><span class="line">            <span class="string">"pwd"</span>: base64.b64encode(self.pwd.encode(<span class="string">"utf8"</span>)),</span><br><span class="line">            <span class="string">"ValiCode"</span>: captcha_value,</span><br><span class="line">            <span class="string">"remember"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">"uclass"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">"zqcode"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"json"</span>: <span class="keyword">True</span>,</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment"># 只有输入正确的才保存</span></span><br><span class="line">        r = self.s.post(self.LOGIN_URL, data=data)</span><br><span class="line">        <span class="keyword">if</span> r.json()[<span class="string">"IsSucceed"</span>]:</span><br><span class="line">            print(<span class="string">"成功！"</span>)</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"captchas/&#123;&#125;.gif"</span>.format(captcha_value), <span class="string">'wb+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(self.r.content)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(r.json())</span><br><span class="line">            print(<span class="string">"验证码输错了"</span>)</span><br><span class="line"><span class="comment"># 刷新, 进行打码下一张</span></span><br><span class="line">        self.r = self.s.get(self.CAPTCHA_URL)</span><br><span class="line">        self.im = Image.open(BytesIO(self.r.content))</span><br><span class="line">        <span class="comment"># 刷新图片框</span></span><br><span class="line">        self.tkimg = ImageTk.PhotoImage(self.im)</span><br><span class="line">        self.imgLabel.config(image=self.tkimg)</span><br><span class="line">        <span class="comment"># ▲. 将输入框清空</span></span><br><span class="line">        self.message.delete(<span class="number">0</span>, <span class="string">'end'</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li><code>captcha_gen.py</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spilt2chars</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    分割已有的数据为字符并保存</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        shutil.rmtree(<span class="string">'captcha_chars'</span>)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    os.mkdir(<span class="string">"captcha_chars"</span>)</span><br><span class="line">    values = <span class="string">"1234567890"</span></span><br><span class="line">    <span class="comment"># 每个字符创建对应的文件夹</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">        os.mkdir(<span class="string">'captcha_chars/&#123;&#125;'</span>.format(value))</span><br><span class="line"></span><br><span class="line">    file_names = os.listdir(<span class="string">'captchas'</span>)</span><br><span class="line">    <span class="comment"># 遍历所有字符文件夹</span></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> file_names: </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(<span class="string">'captchas/&#123;&#125;'</span>.format(file_name)) <span class="keyword">and</span> file_name != <span class="string">'.DS_Store'</span>:</span><br><span class="line">            <span class="comment"># 获得打码img的图片名称(正确结果)</span></span><br><span class="line">            values = file_name[:<span class="number">4</span>]</span><br><span class="line">            im = Image.open(<span class="string">'captchas/&#123;&#125;'</span>.format(file_name))</span><br><span class="line">            captcha = CardCaptcha(im)</span><br><span class="line">            <span class="comment"># handle_split_image为切割后的四个字符图片, values为3fgc的值</span></span><br><span class="line">            <span class="keyword">for</span> im_part, value <span class="keyword">in</span> zip(captcha.handle_split_image(), values):</span><br><span class="line">                <span class="comment"># 进行md5随机取名保存</span></span><br><span class="line">                m = hashlib.md5()</span><br><span class="line">                m.update(<span class="string">"&#123;&#125;&#123;&#125;"</span>.format(time.time(), value).encode(<span class="string">'utf8'</span>))</span><br><span class="line">                <span class="comment"># captcha_chars/3/asdz.png</span></span><br><span class="line">                im_part.save(<span class="string">"captcha_chars/&#123;&#125;/&#123;&#125;.png"</span>.format(value, m.hexdigest()))</span><br><span class="line">                </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_models</span><span class="params">()</span>:</span></span><br><span class="line">    iconset = list(<span class="string">'0123456789'</span>)</span><br><span class="line">    <span class="comment"># 将图像数据转为向量数据并保存</span></span><br><span class="line">    image_data = []</span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> iconset:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 遍历字符3下面所有的图片</span></span><br><span class="line">            <span class="keyword">for</span> img <span class="keyword">in</span> os.listdir(<span class="string">'captcha_chars/&#123;&#125;/'</span>.format(letter)):</span><br><span class="line">                <span class="keyword">if</span> img != <span class="string">"Thumbs.db"</span> <span class="keyword">and</span> img != <span class="string">".DS_Store"</span>:</span><br><span class="line">                    <span class="comment"># 得到其图片向量</span></span><br><span class="line">                    temp = build_vector(Image.open(<span class="string">"captcha_chars/&#123;&#125;/&#123;&#125;"</span>.format(letter, img)))</span><br><span class="line">                    <span class="comment"># models_list中添加[&#123;1: [0,1,1...]&#125;]</span></span><br><span class="line">                    image_data.append(&#123;letter: temp&#125;)</span><br><span class="line">        <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">            print(letter)</span><br><span class="line">image_data = [ &#123;<span class="number">1</span>: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,...]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">0</span>,...]&#125;, ..., &#123;<span class="number">2</span>: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,...]&#125;]</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'image_data.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(image_data, f)</span><br></pre></td></tr></table></figure><p>附：找到最合适的旋转角度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate_img</span><span class="params">(image)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    根据图像在x轴方向投影大小确定字符的摆放方向</span></span><br><span class="line"><span class="string">    -45~+45循环, 当x轴上投影得到的白色像素数量最小，此时就是正确的角度</span></span><br><span class="line"><span class="string">    :param image: PIL.Image object</span></span><br><span class="line"><span class="string">    :return: rotated Image object</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    min_count = <span class="number">1000</span></span><br><span class="line">    final_angle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> angle <span class="keyword">in</span> range(<span class="number">-45</span>, <span class="number">45</span>):</span><br><span class="line">        x_count = <span class="number">0</span></span><br><span class="line">        ti = image.rotate(angle, expand=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(ti.width):</span><br><span class="line">            <span class="comment"># 当前y列只要有一个像素为white, 那么就+1结束, 进行下一列判断</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(ti.height):</span><br><span class="line">                <span class="keyword">if</span> ti.getpixel((x, y)) == WHITE:</span><br><span class="line">                    x_count += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> x_count &lt; min_count:</span><br><span class="line">            min_count = x_count</span><br><span class="line">            final_angle = angle</span><br><span class="line">    image = image.rotate(final_angle, expand=<span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure></li></ul><h2 id="rss-monitor"><a class="markdownIt-Anchor" href="#rss-monitor"></a> <strong><a href="https://github.com/Freedomisgood/Rss-Monitor" target="_blank" rel="noopener">Rss-Monitor</a></strong></h2><blockquote><p>一个通用的RSS订阅通知器，和**<a href="https://github.com/DIYgod/RSSHub" target="_blank" rel="noopener">RSSHub</a>**一起食用效果更好哦。<br>RSS(Really Simple Syndication,简易信息聚合)是一种描述和同步网站内容的格式你可以认为是一种定制个性化推送信息的服务。它能够解决你漫无目的的浏览网页的问题。</p></blockquote><ul><li><p>动态导入模块</p></li><li><p>获得Rss链接信息——<a href="https://pypi.python.org/pypi/feedparser/" target="_blank" rel="noopener">feedparser</a>库</p><blockquote><p>feedparser是一个Python的Feed解析库，可以处理RSS ，CDF，Atom 。使用它我们可从任何 RSS 或 Atom 订阅源得到标题、链接和文章的条目了。</p></blockquote><p>标准的item格式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;![CDATA[厦门公交车放火案死者名单公布&lt;br/&gt;警方公布嫌犯犯罪证据]]&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span>http://www.infzm.com/content/91404<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[6月11日下午，厦门BRT公交车放火案47名死亡者名单公布。厦门政府新闻办6月10日发布消息称，有证据表明，陈水总携带汽油上了闽DY7396公交车。且有多名幸存者指认其在车上纵火，致使整部车引起猛烈燃烧。经笔迹鉴定，陈水总6月7日致妻、女的两封绝笔书系陈水总本人所写。]]&gt;<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">category</span>&gt;</span>南方周末-热点新闻<span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>infzm<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pubDate</span>&gt;</span>2013-06-11 11:24:32<span class="tag">&lt;/<span class="name">pubDate</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure><p>feedparser模块api</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line">d=feedparser.parse(<span class="string">'http://feed.cnblogs.com/blog/sitehome/rss'</span>)</span><br><span class="line"><span class="comment"># d.feed为数据字典, 与entries相比一个是dict一个是list, 其次entries中是更加凝练点的数据</span></span><br><span class="line"><span class="comment">#   输出字典中的键值有哪些，一共有10中如下：</span></span><br><span class="line">[<span class="string">'feed'</span>, <span class="string">'status'</span>, <span class="string">'version'</span>, <span class="string">'encoding'</span>, <span class="string">'bozo'</span>, <span class="string">'headers'</span>, <span class="string">'href'</span>, <span class="string">'namespaces'</span>, <span class="string">'entries'</span>, <span class="string">'bozo_exception'</span>]</span><br><span class="line">&#123;<span class="string">'feed'</span>: &#123;&#125;, <span class="string">'encoding'</span>: <span class="string">u'utf-8'</span>, <span class="string">'bozo'</span>: <span class="number">1</span>, <span class="string">'version'</span>: <span class="string">u''</span>, <span class="string">'namespaces'</span>: &#123;&#125;, <span class="string">'entries'</span>: [], <span class="string">'bozo_exception'</span>: SAXParseException(<span class="string">'no element found'</span>,)&#125;</span><br><span class="line"><span class="comment"># d.channel下的属性为channel中中的字段，比如title、link、description、generator、webMaster、lastBuildDate</span></span><br><span class="line">&gt;&gt;&gt;d[<span class="string">'feed'</span>][<span class="string">'title'</span>]</span><br><span class="line"><span class="string">'博客园_首页'</span></span><br><span class="line">&gt;&gt;&gt;d.feed.title    <span class="comment">#通过属性的方式访问</span></span><br><span class="line"><span class="string">'博客园_首页'</span></span><br><span class="line">&gt;&gt;&gt;d.feed.subtitle</span><br><span class="line"><span class="string">'代码改变世界'</span></span><br><span class="line">&gt;&gt;&gt;d.feed.link</span><br><span class="line"><span class="string">'uuid:1b90fd0c-6080-4ea5-86b1-b87c64b95d69;id=4466'</span></span><br><span class="line">d.entries <span class="comment">#该属性类型为列表，表示一组文章的条目</span></span><br><span class="line">&gt;&gt;&gt;type(d.entries)    <span class="comment">#类型为列表, 为item标签中的内容</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;<span class="title">len</span><span class="params">(d.entries)</span>   #一共20篇文章</span></span><br><span class="line"><span class="class">20</span></span><br></pre></td></tr></table></figure><p>每个RSS和Atom订阅源都包含一个标题（d.feed.title）和一组文章条目(d.entries)</p><p><strong>通常</strong>每个文章条目都有一段摘要（d.entries[i].summary）,或者是包含了条目中实际文本的描述性标签（d.entries[i].description）</p></li><li><p>自定义添加Rss链接-&gt;<a href="https://docs.rsshub.app/joinus/quick-start.html%E3%80%81" target="_blank" rel="noopener">https://docs.rsshub.app/joinus/quick-start.html、</a><a href="https://github.com/DIYgod/RSSHub/pull/1768/files#" target="_blank" rel="noopener"><br>添加浙江工商大学教务处和学校首页通知</a></p><blockquote><p>除了按照Rsshub来自定义Rss订阅源以外，还可以使用 <a href="https://github.com/huginn/huginn" target="_blank" rel="noopener">Huginn</a>、Feed43等工具，如<a href="https://www.jianshu.com/p/1024956c8396" target="_blank" rel="noopener">用Feed43为教务处网站制作RSS</a></p></blockquote><ol><li><p>暴露路由链接：在 <a href="https://github.com/DIYgod/RSSHub/blob/master/lib/router.js" target="_blank" rel="noopener">/lib/router.js (opens new window)</a>里添加路由</p></li><li><p>编写数据源脚本：在 <a href="https://github.com/DIYgod/RSSHub/tree/master/lib/routes" target="_blank" rel="noopener">/lib/routes/ (opens new window)</a>中的路由对应路径下创建新的 js 脚本：</p><ol><li>使用 got 请求 HTML 数据：</li><li>使用 cheerio 解析返回的 HTML:</li><li>使用 map 遍历数组，解析出每一个 item 的结果 ——对数据进行进一步处理，生成符合 RSS 规范的对象，把获取的标题、链接、描述、发布时间等数据赋值给 ctx.state.data, <a href="https://docs.rsshub.app/joinus/quick-start.html#%E7%94%9F%E6%88%90-rss-%E6%BA%90" target="_blank" rel="noopener">生成 RSS 源</a>：</li></ol><blockquote><p>生成 RSS 源原理：获取到的数据赋给 ctx.state.data, 然后数据会经过 <a href="https://github.com/DIYgod/RSSHub/blob/master/lib/middleware/template.js" target="_blank" rel="noopener">template.js (opens new window)</a>中间件处理，最后传到 <a href="https://github.com/DIYgod/RSSHub/blob/master/lib/views/rss.art" target="_blank" rel="noopener">/lib/views/rss.art (opens new window)</a>来生成最后的 RSS 结果，每个字段的含义如下：<a href="https://docs.rsshub.app/joinus/quick-start.html#ti-jiao-xin-de-rsshub-gui-ze-bian-xie-jiao-ben" target="_blank" rel="noopener">https://docs.rsshub.app/joinus/quick-start.html#ti-jiao-xin-de-rsshub-gui-ze-bian-xie-jiao-ben</a></p></blockquote></li></ol><p>3.添加脚本文档: <code>&lt;Route author=&quot;HenryQW&quot; example=&quot;/github/issue/DIYgod/RSSHub&quot; path=&quot;/github/issue/:user/:repo&quot; :paramsDesc=&quot;['用户名', '仓库名']&quot; /&gt;</code></p></li></ul><h2 id="ddt-sharp-shooter"><a class="markdownIt-Anchor" href="#ddt-sharp-shooter"></a> <strong><a href="https://github.com/boring-plans/ddt-sharp-shooter" target="_blank" rel="noopener"> ddt-sharp-shooter</a></strong></h2><blockquote><p>使用到的库: <code>screeninfo、pillow、ddddocr、pynput</code></p><ul><li>pynput: 控制和监视输入设备；类似的有PyHook3（监视键鼠）、pywin32 （模拟键鼠）</li><li>ddddocr：识别验证码，这边用来识别数字</li></ul></blockquote><ol><li><p>进程间通信。 Tkinter界面开启mainloop进程，其中又开辟出一个子线程来侦听其他进程发送的数据消息，然后通过<code>tk.Text</code>控件来展示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="comment"># 声明全局对象及类型</span></span><br><span class="line">_tk: tkinter.Tk</span><br><span class="line">_text: tkinter.Text</span><br><span class="line">_terminate = <span class="keyword">False</span></span><br><span class="line">_queue: multiprocessing.Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_text</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""子线程侦听进程消息"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> _terminate:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _queue.empty():</span><br><span class="line">            text = _queue.get(<span class="keyword">False</span>)</span><br><span class="line">            append_text(text)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append_text</span><span class="params">(text)</span>:</span></span><br><span class="line">    _text.config(state=<span class="string">'normal'</span>)</span><br><span class="line">    _text.insert(<span class="string">'end'</span>, <span class="string">f'\n<span class="subst">&#123;text&#125;</span>'</span>)</span><br><span class="line">    _text.see(<span class="string">'end'</span>)</span><br><span class="line">    _text.config(state=<span class="string">'disabled'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(gui_queue)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> _tk, _text, _queue, _screen_size</span><br><span class="line">    _queue = gui_queue</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    threading.Thread(target=update_text).start()</span><br><span class="line">    </span><br><span class="line">    _tk.mainloop()</span><br></pre></td></tr></table></figure></li><li><p><code>py2app setup</code>，在macos下创建python应用， <code>python setup.py py2app</code></p></li><li><p>对纯数字识别结果进行清洗</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recognize_digits</span><span class="params">(image: bytes)</span>:</span></span><br><span class="line">    ocr = ddddocr.DdddOcr(show_ad=<span class="keyword">False</span>)</span><br><span class="line">    result = ocr.classification(image)</span><br><span class="line">    <span class="keyword">return</span> wash_digits(result)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wash_digits</span><span class="params">(digits: str)</span>:</span></span><br><span class="line">    <span class="string">"""由于不会出现非数字, 所以对易识别错误的字符进行替换"""</span></span><br><span class="line">    washed = digits \</span><br><span class="line">        .replace(<span class="string">'g'</span>, <span class="string">'9'</span>).replace(<span class="string">'q'</span>, <span class="string">'9'</span>) \</span><br><span class="line">        .replace(<span class="string">'l'</span>, <span class="string">'1'</span>).replace(<span class="string">'i'</span>, <span class="string">'1'</span>) \</span><br><span class="line">        .replace(<span class="string">'z'</span>, <span class="string">'2'</span>) \</span><br><span class="line">        .replace(<span class="string">'o'</span>, <span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">r'\D'</span>, <span class="string">'0'</span>, washed)</span><br></pre></td></tr></table></figure></li></ol><h1 id="文章记录"><a class="markdownIt-Anchor" href="#文章记录"></a> 文章记录</h1><h2 id="github优秀的文章项目"><a class="markdownIt-Anchor" href="#github优秀的文章项目"></a> Github优秀的文章项目</h2><ul><li><strong><a href="https://github.com/danistefanovic/build-your-own-x" target="_blank" rel="noopener">build-your-own-x</a></strong>——自己造轮子</li><li><strong><a href="https://github.com/donnemartin/system-design-primer" target="_blank" rel="noopener">system-design-primer</a></strong>——系统架构设计</li><li><strong><a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">advanced-java</a></strong>——互联网 Java 工程师进阶知识完全扫盲</li><li><a href="https://juejin.cn/post/6844903624062009352" target="_blank" rel="noopener">https://juejin.cn/post/6844903624062009352</a></li><li></li></ul><h2 id="go好用的三方库"><a class="markdownIt-Anchor" href="#go好用的三方库"></a> Go好用的三方库</h2><ul><li><p>丰富原生数据结构map、slice的工具库：<a href="https://github.com/samber/lo" target="_blank" rel="noopener">https://github.com/samber/lo</a></p></li><li><p>输入参数解析库: <a href="https://github.com/jessevdk/go-flags" target="_blank" rel="noopener">go-flags</a></p></li><li><p>操作excel的库：<a href="https://github.com/qax-os/excelize" target="_blank" rel="noopener">excelize</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;爬虫系列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#爬虫系列&quot;&gt;&lt;/a&gt; 爬虫系列&lt;/h1&gt;
&lt;h2 id=&quot;抢购-秒杀&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#抢购-秒杀&quot;&gt;&lt;/a&gt; 抢购、秒杀&lt;
      
    
    </summary>
    
    
      <category term="代码阅读" scheme="https://nymrli.top/tags/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>深入学习使用Spring</title>
    <link href="https://nymrli.top/2022/02/27/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8Spring/"/>
    <id>https://nymrli.top/2022/02/27/深入学习使用Spring/</id>
    <published>2022-02-27T05:52:08.000Z</published>
    <updated>2022-02-27T05:54:23.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>From : <a href="https://www.bilibili.com/video/BV1fr4y1Y7UH?p=6" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1fr4y1Y7UH?p=6</a></p></blockquote><h2 id="创建bean的方式"><a class="markdownIt-Anchor" href="#创建bean的方式"></a> 创建bean的方式：</h2><h3 id="声明式"><a class="markdownIt-Anchor" href="#声明式"></a> 声明式</h3><h4 id="beanbean"><a class="markdownIt-Anchor" href="#beanbean"></a> <code>&lt;bean&gt;&lt;/bean&gt;</code></h4><ul><li><p><code>&lt;bean&gt;&lt;/bean&gt;</code>： 通过xml来配置bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"p1"</span> <span class="attr">class</span>=<span class="string">"top.nymrli.tryboot.po.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testPerson()</span><br><span class="line">    &#123;</span><br><span class="line"> ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");</span><br><span class="line"></span><br><span class="line">        User user = annotationConfigApplicationContext.getBean("p1", User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="bean"><a class="markdownIt-Anchor" href="#bean"></a> <code>@Bean</code></h4><ul><li><p><code>@Bean</code>: 通过注解来标注SpringBean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"name"</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        ctx.register(Config.class);</span><br><span class="line">        <span class="comment">// 或者 AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Config.class);</span></span><br><span class="line"></span><br><span class="line">        ctx.refresh();</span><br><span class="line"></span><br><span class="line">        User user = ctx.getBean(<span class="string">"user"</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Config.class);</code>与<code>ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code>一样，都是指定bean的配置路径后解析，获得bean的配置。</p></li></ul><h4 id="component"><a class="markdownIt-Anchor" href="#component"></a> <code>@Component</code></h4><ul><li><p><code>@Component</code>: 通过标注来创建一个组件SpringBean对象，如下的User。 ==&gt; 等价于<code>ctx.registerBean(User.class)</code>，registerBean方法的实现最终也是调用了registerBeanDefinition</p><p>而Config不是一个bean，他的作用跟applicationContext.xml一样，他是存放bean定义路径的一个配置文件，在这里是通过ComponentScan让Spring能够找到top.nymrli.tryboot.po下的所有Bean并解析成SpringBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"top.nymrli.tryboot.po"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">// ==&gt; beanName为user, 类名小写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(Config.class);</span><br><span class="line"></span><br><span class="line">    User user = ctx.getBean(User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会自动调用User的无参构造方式来创建JavaBean， 因此得到的User是<code>User(name=null, age=0)</code></p></li></ul><p>▲.上述三种创建方式本质上都是创建了BeanDefinition，只不过Spring进行了封装，因此使用起来比较简单直观</p><h4 id="import"><a class="markdownIt-Anchor" href="#import"></a> @Import</h4><blockquote><p>spring4.2之后<code>@Import</code>注解可以实例化普通类的bean实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import</span>(Role.class)<span class="comment">// @Import(&#123;Role.class, User.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Role role;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(role);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring在创建MyConfig的时候，会根据@Import将Role也实例化成一个Bean</p><h3 id="编程式"><a class="markdownIt-Anchor" href="#编程式"></a> 编程式</h3><h4 id="beandefinition"><a class="markdownIt-Anchor" href="#beandefinition"></a> BeanDefinition</h4><blockquote><p>通过创建并配置 BeanDefinition 来创建一个Bean</p><p>Q: 什么是BeanDefinition?</p><p>A: BeanDefinition表示Bean的定义信息， Spring会根据BeanDefinition来创建Bean对象。BeanDefinition有很多的属性用来描述Bean， BeanDefinition是Spring中非常核心的概念。</p><ul><li>beanClass: 表示Bean对象的类类型， Spring在创建Bean的过程中根据此属性来判断实例化对象具体的类类型</li><li>scope：作用域，[singleton、prototype]，单例或者原型bean</li><li>isLazy：是否需要懒加载，原型Bean的懒加载不奏效。懒加载的单例bean，会在第一次getBean的时候生成该bean，非懒加载的单例bean，则会在Spring.启动过程中直接生成好。</li><li>dependsOn：表示一个bean在创建之前所依颗的其他bean，在一个bean创建之前，它所依赖的这些bean得先全部创建好。</li><li>primary：表示一个bean是主bean，在Spring中一个类型可以有多个bean对象，在进行依赖注入时，如果根据类型找到了多个b©an，此时会判断这些bean中是否存在一个主bean，如果存在，则直接将这个bean注入给属性。</li><li>initMethodName： 表示一个bean的初始化方法，一个bean的生命周期过程中有一个步骤叫初始化，Spring会在这个步骤中去调用bean的初始化方法。初始化逻辑由程序员自己控制，使得程序员可以自定义逻辑对bean进行加工。</li></ul><p>通过<code>&lt;bean&gt;&lt;/bean&gt;</code>、<code>@Bean</code>、<code>@Component</code>标注的类都会解析为BeanDefinition，供Spring创建（实例化）具体的Bean。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(Config.class);</span><br><span class="line">    AbstractBeanDefinition bd = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">    bd.setBeanClass(User.class);</span><br><span class="line">    <span class="comment">// 将BeanDefinition注册到上下文中</span></span><br><span class="line">    ctx.registerBeanDefinition(<span class="string">"user"</span>, bd);</span><br><span class="line">    <span class="comment">// 获得Bean对象</span></span><br><span class="line">    User user = (User)ctx.getBean(<span class="string">"user"</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="factorybean"><a class="markdownIt-Anchor" href="#factorybean"></a> FactoryBean</h4><blockquote><p>FactoryBean是Spring.所提供的一种较灵活的创建Bean的方式，可以通过实现FactoryBean：接口中的getObject()方法来返回一个对象，这个对象就是最终的Bean对象。</p></blockquote><p>FactoryBean接口中的方法</p><ul><li>Object getObject()：返回的是Bean对象</li><li>boolean isSingleton()：返回的是否是单例Bean对象</li><li>Class getObjectType()：返回的是Bean对象的类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"zhouyu"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"cl"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，实际上对应了两个Bean对象：<br>1、beanName为&quot;zhouyu’，bean对象为getObject方法所返回的User对象。=&gt;<code>applicationcontext.getBean(name：&quot;zhouyu&quot;，ZhouyuFactory.class);</code><br>2、beanName为&quot;&amp;zhouyu’，bean对象为ZhouyuFactoryBean类的实例对象。=&gt;<code>applicationcontext.getBean(name：&quot;&amp;zhouyu&quot;，ZhouyuFactoryBean.class);</code></p><p>与BeanFactory的区别：</p><ul><li>FactoryBean对象本身也是一个Bean，同时它相当于一个小型工厂，可以生产出<strong>另外</strong>的Bean。==》指定类型的Bean对象<ul><li>FactoryBean机制被广泛的应用在Spring内部和Spring-与第三方框架或组件的整合过程中。</li></ul></li><li>BeanFactory是一个Spring容器，是一个大型工厂，它可以生产出<strong>各种各样</strong>的Beano</li></ul><h4 id="supplier"><a class="markdownIt-Anchor" href="#supplier"></a> Supplier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(Config.class);</span><br><span class="line">        ctx.registerBean(User.class, <span class="keyword">new</span> Supplier&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                User userx = <span class="keyword">new</span> User();</span><br><span class="line">                userx.setAge(<span class="number">222</span>);</span><br><span class="line">                userx.setName(<span class="string">"supplier"</span>);</span><br><span class="line">                <span class="keyword">return</span> userx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        User user = (User)ctx.getBean(<span class="string">"user"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="beanfactory"><a class="markdownIt-Anchor" href="#beanfactory"></a> BeanFactory</h2><p>BeanFactory是一种“Spring容器”， BeanFactory翻译过来就是Bean工厂，顾名思义，它可以用来创建Bean、获取Bean。</p><p>概念区分：</p><ul><li>BeanFactory将利用BeanDefinition：来生成Bean对象</li><li>BeanDefinition相当于BeanFactory的原材料</li><li>Bean对象就相当于BeanFactory）所生产出来的产品</li></ul><p>BeanFactory的核心子接口和实现类：</p><ul><li>ListableBeanFactory</li><li>ConfigurableBeanFactory</li><li>AutowireCapableBeanFactory</li><li>AbstractBeanFactory</li><li>DefaultListableBeanFactory</li></ul><p>···</p><h2 id="bean生命周期"><a class="markdownIt-Anchor" href="#bean生命周期"></a> Bean生命周期</h2><blockquote><p>Bean生命周期描述的是Spring中一个Bean创建过程和销毁过程中所经历的步骤，其中Bean创建过程是重点。程序员可以利用Bean生命周期机制对Bean进行自定义加工。</p></blockquote><ul><li>Bean定义：通过xml或者编写类的形式来创建BeanDefinition</li><li>构造方法推断：从bean的多个构造方法中选出一个构造方法</li><li>实例化：通过构造方法反射获得对象，在Spring中可以通过BeanPostProcessor机制对实例化进行干预</li><li>属性填充(自动注入、依赖注入)：给属性进行自动填充，比如@Value，@AutoWired</li><li>初始化：在一个对象的属性填充之后，Spring提供了初始化机制，让程序员可以对其他属性进行赋值、校验等自定义加工(利用InitializingBean接口)</li><li>初始化后：Aop、生成代理对象。常说的Aop机制就是在这个步骤中通过BeanPostProcessor机制实现的，这步之后获得的对象才是真正的Bean对象</li></ul><p>创建过程：</p><p><img src="/2022/02/27/深入学习使用Spring/E:%5Chexo%5Csource_posts%5C%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8Spring%5Cbean%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg" alt="bean创建过程"></p><p>生命周期图：</p><p><img src="/2022/02/27/深入学习使用Spring/E:%5Chexo%5Csource_posts%5C%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8Spring%5Cbean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1.jpg" alt="bean生命周期-1"></p><h2 id="属性填充注解autowired-resource-value"><a class="markdownIt-Anchor" href="#属性填充注解autowired-resource-value"></a> 属性填充注解：@Autowired、@Resource、@Value</h2><h3 id="autowired"><a class="markdownIt-Anchor" href="#autowired"></a> @Autowired.</h3><p>表示某个属性是否需要进行依赖注入，可以写在属性和方法上。注解中的required属性默认为ture，表示如果没有对象可以注入给属性则抛异常。</p><ul><li><p>@Autowired：加在某个<strong>属性</strong>上，Spring在进行Bean的生命周期过程中，在<strong>属性填充</strong>这一步会基于实例化出来的对象，对该对象中加了@Autowired的属性自动给属性赋值。具体实现为： Spring会先根据属性的类型去Spring容器中找出该类型所有的Bean对象，如果找出来多个，则再根据属性的名字从多个中再确定一个。如果required属性为true，并且根据属性信息找不到对象，则直接抛异常。</p></li><li><p>当@Autowired注解写在<strong>某个方法</strong>上时，Spring在B ean生命周期的属性填充阶段，会根据方法的参数类型、参数名字从Spring容器找到对象当做方法入参，自动反射调用该方法。</p></li><li><p>@Autowired加在<strong>构造方法</strong>上时，Spring会在<strong>推断构造方法阶段</strong>，<u>选择该构造方法来进行实例化</u>，在反射调用构造方法之前，会先根据构造方法参数类型、参数名从Spring容器中找到Bean对象，当做构造方法入参。</p></li></ul><h3 id="resource"><a class="markdownIt-Anchor" href="#resource"></a> @Resource</h3><p>@Resource注解与@Autowired类似，也是用来进行依赖注入的，@Resource是<strong>Java层面</strong>所提供的注解，@Autowired.是<strong>Spring</strong>所提供的注解，它们依赖注入的底层实现逻辑也不同。</p><p>@Resource：注解中有一个name属性，针对na me属性是否有值，@Resource的依赖注入底层流程是不同的。</p><ul><li>@Reousrce：如果name属性有值，那么Spring会直接根据所指定的name值去Spring容器找Bean对象，如果找到了则成功，如果没有找到，则报错。</li><li>如果@Resource中的name属性没有值，则：<ol><li>先判断该属性名字在Spring容器中是否存在Bean对象。</li><li>如果存在，则成功找到Bean对象进行注入。</li><li>如果不存在，则根据属性类型去Spring容器找Bean对象，找到一个则进行注入。</li></ol></li></ul><h3 id="value"><a class="markdownIt-Anchor" href="#value"></a> @Value</h3><p>@Value注解和@Resource、@Autowired类似，也是用来对属性进行依赖注入的，只不过@Value是用来从<strong>Properties.文件中</strong>来获取<strong>值</strong>的，并且@Value可以解析SpEL（Spring表达式）。</p><ul><li><p><code>@Value(&quot;yuzhou&quot;)</code>: 直接将字符串“zhouyu”赋值给属性，如果属性类型不是String，或无法进行类型转化，则报错。</p></li><li><p><code>@Value(${&quot;yuzhou&quot;})</code>： 将会把<code>${}</code>中的字符串当做key，从Properties文件中找出对应的value赋值给属性，如果没找到，则会把<code>${zhouyu}</code>当做普通字符串注入给属性。</p></li><li><p><code>@Value(#{&quot;yuzhou&quot;})</code>:会将<code>#{}</code>中的字符串当做Spring表达式进行解析，Spring会把&quot;zhouyu&quot;当做beanName，并从Spring容器中找对应bean，如果找到则进行属性注入，没找到则报错。</p></li><li></li></ul><h2 id="applicationcontext"><a class="markdownIt-Anchor" href="#applicationcontext"></a> ApplicationContext</h2><p>ApplicationContext是比BeanFactory更加强大的Spring容器，它既可以创建bean、获取bean，还支持国际化、事件广播、获取资源等BeanFactor y不具备的功能。</p><p>Application Context，所继承的接口</p><ul><li>EnvironmentCapable：拥有获取环境变量的能力：操作系统环境变量和Jvm环境变量</li><li>ListableBeanFactory：拥有了获取所有beanNames、判断某个bean Name是否存在peanDefinition对象、统计Be anDefinition个数、获取某个类型对应的所有beanNames等功能。</li><li>HierarchicalBeanFactory：拥有了获取父BeanFactory、。判断某个name是否存在bean对象的功能。</li><li>MessageSource：拥有了国际化功能，比如可以直接利用Messa geSource对象获取某个国际化资源（比如不同国家语言所对应的字符）</li><li>ApplicationEventPublisher： 拥有了事件发布功能，可以发布事件，这是Application Context相对于BeanFactory比较突出、常用的功能。</li><li>ResourcePatternResolver: 拥有了加载并获取资源的功能，这里的资源可以是文件，图片等某个URL资源都可以。</li></ul><h3 id="获得bean的方式"><a class="markdownIt-Anchor" href="#获得bean的方式"></a> 获得bean的方式：</h3><blockquote><p><em>getBean() API</em></p></blockquote><ul><li><p>按名称获取Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object lion = context.getBean(<span class="string">"lion"</span>);</span><br><span class="line"> </span><br><span class="line">assertEquals(Lion.class, lion.getClass());</span><br></pre></td></tr></table></figure><p>根据bean名称获取bean，如果在spring ico容器中存在和bean，则返回<em>Object</em> 类的实例。否则，抛出如下异常NoSuchBeanDefinitionException。</p><p>▲: 主要的缺点是，在获取bean之后，我们<strong>必须将它指定转换为所需的类型</strong>。如果返回的bean的类型与我们期望的不同，则可能会产生异常。</p></li><li><p>通过名称和类型获取Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lion lion = context.getBean(<span class="string">"lion"</span>, Lion.class);</span><br><span class="line"><span class="comment">// 与按名称获取Bean相比，此方法更安全，因为我们可以编译阶段就发现错误而不是在运行阶段。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">assertThrows(BeanNotOfRequiredTypeException.class, () -&gt; </span><br><span class="line">    context.getBean(<span class="string">"lion"</span>, Tiger.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按类型获取Bean</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// right</span></span><br><span class="line">Lion lion = context.getBean(Lion.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 在下面的情况下，需要特别注意可能存在的歧义：</span></span><br><span class="line">assertThrows(NoUniqueBeanDefinitionException.class, () -&gt; </span><br><span class="line">    context.getBean(Animal.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<em>Lion</em>和<em>Tiger都</em>实现了<em>Animal</em>接口，因此仅指定类型不足以明确确定结果。因此，我们会得到一个*<code>NoUniqueBeanDefinitionException</code>*。即在<strong>同一个IOC 容器中，如果<u>有相同类型的多个bean</u>，则不能通过类型获取bean</strong>。</p><ul><li>按名称和构造函数参数对Bean进行筛选</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tiger tiger = (Tiger) context.getBean(<span class="string">"tiger"</span>, <span class="string">"Siberian"</span>);</span><br><span class="line">Tiger secondTiger = (Tiger) context.getBean(<span class="string">"tiger"</span>, <span class="string">"Striped"</span>);</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="string">"Siberian"</span>, tiger.getName());</span><br><span class="line">assertEquals(<span class="string">"Striped"</span>, secondTiger.getName());</span><br></pre></td></tr></table></figure><ul><li><p>按类型和构造函数参数对Bean进行筛选</p><blockquote><p>▲: 这个方法有点不同，因为它<strong>只适用于具有原型作用域</strong>的bean。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tiger tiger = context.getBean(Tiger.class, <span class="string">"Shere Khan"</span>);</span><br><span class="line">assertEquals(<span class="string">"Shere Khan"</span>, tiger.getName());</span><br></pre></td></tr></table></figure></li></ul><h2 id="beanpostprocessor机制"><a class="markdownIt-Anchor" href="#beanpostprocessor机制"></a> BeanPostProcessor机制</h2><p>BeanPostProcessor是Spring所提供的一种扩展机制，可以利用该机制对Bean进行定制化加工，在Spring底层源码实现中，也广泛的用到了该机制，BeanPostProcessor通常也叫做<strong>Bean后置处理器</strong>。</p><p>BeanPostProcessor在Spring中是一个接口，我们定义一个后置处理器，就是提供一个类实现该接口，在Spring中还存在一些接口继承了BeanPostProcessor，这些子接口是在BeanPostProcessor的基础上增加了一些其他的功能。</p><p>BeanPostProcessori中的方法</p><ul><li>postProcessBeforelnitialization()：初始化前方法，表示可以利用这个方法来对Bean在初始化前进行自定义加工。</li><li>postProcessAfterInitialization()：初始化后方法，表示可以利用这个方法来对Bean在初始化后进行自定义加工。</li></ul><h3 id="instantiationawarebeanpostprocessor"><a class="markdownIt-Anchor" href="#instantiationawarebeanpostprocessor"></a> InstantiationAwareBeanPostProcessor</h3><blockquote><p>BeanPostProcessor的一个子接口</p></blockquote><ul><li>postProcessBeforelnstantiation()：实例化前</li><li>postProcessAfterInstantiation()：实例化后</li><li>postProcessProperties()：属性注入后</li></ul><h2 id="aop是什么"><a class="markdownIt-Anchor" href="#aop是什么"></a> AOP是什么？</h2><p>AOP就是面向切面编程，是一种非常适合在<strong>无需修改业务代码的前提</strong>下，对<u>某个或某些业务增加统一的功能</u>（横向增加功能），比如日志记录、权限控制、事务管理等，能很好的使得代码解耦，提高开发效率。</p><ul><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;From : &lt;a href=&quot;https://www.bilibili.com/video/BV1fr4y1Y7UH?p=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/vid
      
    
    </summary>
    
    
      <category term="Web" scheme="https://nymrli.top/tags/Web/"/>
    
      <category term="Spring" scheme="https://nymrli.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>研究生work——地图匹配</title>
    <link href="https://nymrli.top/2022/02/26/%E7%A0%94%E7%A9%B6%E7%94%9Fwork%E2%80%94%E2%80%94%E5%9C%B0%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    <id>https://nymrli.top/2022/02/26/研究生work——地图匹配/</id>
    <published>2022-02-26T07:24:46.000Z</published>
    <updated>2022-03-09T13:33:00.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="地图匹配"><a class="markdownIt-Anchor" href="#地图匹配"></a> 地图匹配</h1><p>概念：</p><blockquote><ul><li>地图匹配（Map-Matching）是将运营车辆的有序的GPS位置关联到电子地图的路网上，将GPS坐标下采样序列转换为数字路网坐标序列的过程；本质上是平面线段序列的模式匹配问题（ Alt等，2003）</li><li>地图匹配是一种将原始GPS位置映射到路网上的路段的过程，以创建对车辆所走路线的估算。</li></ul></blockquote><p>两个主要的地图匹配用例</p><ul><li>乘车结束时，计算驾驶员行进的距离，以计算票价。——路线图匹配(EORMM)</li><li><strong>实时</strong> ，为ETA团队提供准确的位置并做出<strong>调度</strong>决策，并在rider应用程序上<strong>显示</strong>驾驶员的汽车。——实时地图匹配(RTMM)</li></ul><p>不同点在于，<em>实时地图匹配</em>的要求比较高，必须低延时，因此相比之下，<em>路线图匹配</em>对等待时间的要求不那么严格，并且可以使用乘车的全部历史记录</p><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h3><ul><li><p><a href="https://zhuanlan.zhihu.com/p/83039334" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/83039334</a></p></li><li><p><a href="https://blog.csdn.net/weixin_26713521/article/details/108134220" target="_blank" rel="noopener">Lyft的地图匹配算法论文翻译</a></p><ul><li><p>地图匹配算法的性能取决于<strong>道路网络数据</strong>的<strong>质量</strong></p></li><li><p>解决问题的一种好的方法是使用<strong>状态空间模型</strong> 。 状态空间模型是时间序列模型，其中系统具有“隐藏”状态，这些状态无法直接观察到，但会引起可见的观察。 在这里，我们的隐藏状态是我们要估算的汽车在道路网络上的实际位置。 我们仅观察到隐藏状态的修改版本：观察值(原始位置数据)。 我们假设系统的状态以仅取决于当前状态的方式演化(马尔可夫假设)，并进一步定义了从隐藏状态到隐藏状态的转移密度和从隐藏状态到观察的密度。</p><p>常用的地图匹配状态空间模型是离散状态<strong>隐马尔可夫模型</strong> (Newson＆Krumm [2]，DiDi的IJCAI-19教程[3]，Uber的Map Matching [4])。 在该系统中，我们通过查看路段上的最近点来生成候选对象，并使用<a href="https://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="noopener">维特比算法</a>查找最可能的隐藏状态序列。</p><ul><li>对于不同的建模选择和输入数据而言，它相对不灵活</li><li>它缩放严重(O(N²)，其中N是每个状态下可能的候选数)</li><li>它不能很好地应对高频观测(请参阅Newson＆Krumm [2])。</li></ul></li></ul></li><li><p><a href="http://qikan.cqvip.com/Qikan/Article/Detail?id=1000359922&amp;from=Qikan_Search_Index" target="_blank" rel="noopener">GPS定位与地图匹配方法研究</a></p><ul><li>地图匹配算法从原理上可以解释为两个独立的过程：（1）找到车辆当前行使的道路——确定候选路段（2）将当前GPS定位点投影到车辆行使的道路上——候选路段匹配规则<ul><li>圆心拓展半径找到最近的路段（唯一）——构建第一条边的算法</li></ul></li></ul></li><li><p>[1]苏洁, 周东方, 岳春生. GPS车辆导航中的实时地图匹配算法[J]. 测绘学报, 2001, 30(3):5.</p><ul><li>另外，为了提高算法的鲁棒性，对于误差引起 的速度异常，我们利用推测航位法和线性插值来 进行 GPS数据补偿，以消除部分GPS接收外部 粗差</li></ul></li><li><p>[1]李清泉, 黄练. 基于GPS轨迹数据的地图匹配算法[J]. 测绘学报, 2010(2):6.</p><ul><li>针对传统导航系统的地图匹配方法的研究较多。其中点到线的匹配由于缺乏对整体轨迹趋势的考虑，在复杂的道路网环境下的匹配易导致误匹配。也有方法使用DR、差分GPS等辅助设备，采用滤波、模糊逻辑、证据理论等方法提高地图匹配的准确率。GPS浮动车轨迹数据提供了整体曲线的变化趋势，可以采用全局整体匹配的思想，保证轨迹的完整性和准确性14？。基于曲线相似度的算法一般 较为复杂，但匹配精度高，利于轨迹的直接恢复，适合进行数据的后处理</li><li>与整个轨迹相对 应的路径必然是连通 的路段集 ，可以基于道路拓扑与连通性设计地图匹配算法</li><li>key：除了道路的几何连通性，实际行车还会受到交通规则的限制，本文基于道路网的行车限制信息提出了一种GPS浮动车轨迹数据的全局地图匹配算法，综合考虑备选路段的几何连通性与交通网络条件约束构建整体备选路径，然后使用<strong>改进的扫描线法</strong>判断全局轨迹曲线与备选路径的相似度，完成地图匹配 。<ul><li>一句话概括算法：通过行车限制将候选线段找出来后，选择曲线相似度最高的</li></ul></li></ul></li><li><p>[1]陈滨, 王平, 施文灶,等. GPS轨迹数据的综合地图匹配算法研究[J]. 电子科技, 2014, 27(12):4.</p><ul><li>从实际的匹配效果来看，此匹配算法在交叉路口等路段较复杂的地方可有较高地匹配准确率，但该方法依赖于前后GPS定位点匹配准确度，若前一定位点匹配错误就会出现连锁反应，从而导致后面一系列点匹配错误；且历史轨迹推算匹配法计算量较大，匹配速度较慢，不利于高速实时定位。因此，需和其他地图匹配方法相结合使用才能取得较好的匹配效果。</li></ul></li><li><p>智能交通系统中GPS地图匹配算法设计与实现_罗杰涛</p><ul><li>模糊逻辑： 效率高，实时性好，对绝大多数的路段状况都适用。不过在车俩拐弯处以及车速较慢的情况下匹配效果不尽如人意，且不同路段建模的系数凭靠经验值，没有相应的缺乏理论依据。——01、06、08论文</li></ul></li><li><p>高级地图匹配算法：研究现状和趋势[2021]</p><ul><li><p>从实现技术或模型角度对近十年提出的算法进行分类，箭头标记算法间的继承关系。从图2可见，HMM模型是主流，其次是基于最大权重的模型.HMM-News-on、ST-Matching2 3IVMM3和HRIS8被引用对比最多，是具有开创性的工作。另外，从2019年开始，有研究采用深度学习技术来解决地图匹配问题。</p><p><img src="/2022/02/26/研究生work——地图匹配/E:%5Chexo%5Csource_posts%5C%E7%A0%94%E7%A9%B6%E7%94%9Fwork%E2%80%94%E2%80%94%E5%9C%B0%E5%9B%BE%E5%8C%B9%E9%85%8D%5C09-20%E5%B9%B4%E5%9C%B0%E5%9B%BE%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.jpg" alt="09-20年地图匹配算法发展历程"></p></li></ul></li></ul><h3 id="points"><a class="markdownIt-Anchor" href="#points"></a> Points:</h3><ul><li><p>另外，一个重要的实际问题是，即使车辆定位精度可以保证在10米以内，当电子地图缩放到较大的比例尺时，也会<br>出现车辆偏离行使的道路而造成的视觉混乱现象.</p></li><li><p>由于城区内地物特征复杂，受密集的高大建筑物、隧道、立交桥、树木等地物的反射和遮蔽等影响，车栽GPS接收机接收到的卫星信号存在严重的多径效应，在某些区域内甚至会形成GPS定位育区，解决GPS盲区问题，一种方法是采用航位推算法（DR-Dead Reckoning），这种方法需要将DR设备装在车辆前端，一般在GPS接收机卫星信号受阻时一样可以得到正确的用户位置，但这种方法需要附加设备。另一种方法是在记忆正确GPS位置信息的基础上在一段时间内预测车辆位置，这种方法的优点是易于实现，缺点是精度不够（没有，作者使用卡尔曼滤波进行位置预测，预测结果如图所示。在规则行进时，预测效果较好，见图3、图4.但是当车辆转弯时，效果很差，见图5、图6</p></li><li><p>到折线的距离定义为点到折线上所有直线段的最短距离：点到线段的距离定义为如果点到直线段所在直线的投影在直线段上，则为垂线长度，否则为其到两个端点的最短距离。</p></li><li><p>定位误差： GPS误差、电子地图库误差、坐标投影变换投影</p></li><li><p>难点：</p><ul><li><a href="http://qikan.cqvip.com/Qikan/Article/ReadIndex?id=33650279&amp;info=X19Wa%2bQedw8TOqUh1eM7U0SrEn1nIM08tSny4w0YhPo%3d" target="_blank" rel="noopener">Y-junction问题</a>——点到线的匹配方式，没有考虑全局匹配</li><li>平行双线路</li></ul></li><li><p>MapMatching实现的思路</p><ul><li><strong>离散点集匹配</strong>：相对简单，随机离散点没有形状和拓扑关系，用欧氏距离作吸附即可，典型应用如离散热力图。</li><li><strong>曲线拟合</strong>： 实际中更有应用价值的是曲线拟合匹配关系，比如轨迹和路网，GPS序列和导航路的相似性。</li></ul></li><li><p>MapMatching算法的分类：</p><p><strong>以使用到的信息来划分</strong></p><p>现有的算法可被分成四类：几何、拓扑、概率、高级。</p><p>a）基于几何的算法考虑GPS点与道路的几何信息，如距离、角度等；</p><p>b）基于拓扑的算法使用道路拓扑信息来控制；</p><p>c）概率方法通过考虑GPS点的概率；</p><p>d）高级的算法往往综合考虑使用全面信息，有卡尔曼滤波、模糊逻辑模型、隐式马尔可夫模型等等。</p><p><strong>2.2 以考虑采样点的范围来划分</strong></p><p>根据考虑采样点的范围，可分成局部/增量算法、全局算法。</p><p>a）局部/增量算法是贪婪算法，每次确定一个匹配点，下个点从已经确定的匹配点开始。这些方法根据距离和方向相似性来找到局部最优点或边。（在线匹配）</p><p>b）全局算法是要从路网中找到一条与采样轨迹最接近的匹配轨迹。为了测量采样轨迹和匹配轨迹的相似性，大多数算法使用“Frechet距离”或者是“弱Frechet距离”。还有时空匹配算法、投票算法等。（离线匹配）</p><p><strong>以采样点的频率来划分</strong></p><p>根据轨迹数据的采样频率，现有的地图匹配算法可分成：</p><p>a）高频采样算法（所有局部算法、部分全局算法如Frechet距离判别法等）</p><p>b）低频采样算法（ST-matching算法、IVVM算法）</p><p>一般认为30s及其以上为低频采样，1s～10s为高频采样。</p><p><a href="https://www.cnblogs.com/LBSer/p/4612031.html#!comments" target="_blank" rel="noopener">https://www.cnblogs.com/LBSer/p/4612031.html#!comments</a></p></li><li><p>智能交通系统中GPS地图匹配算法设计与实现</p><p><img src="/2022/02/26/研究生work——地图匹配/E:%5Chexo%5Csource_posts%5C%E7%A0%94%E7%A9%B6%E7%94%9Fwork%E2%80%94%E2%80%94%E5%9C%B0%E5%9B%BE%E5%8C%B9%E9%85%8D%5C%E5%9C%B0%E5%9B%BE%E5%8C%B9%E9%85%8D%E7%BB%84%E4%BB%B6.jpg" alt="地图匹配组件"></p></li></ul><h3 id="算法评估的标准"><a class="markdownIt-Anchor" href="#算法评估的标准"></a> 算法评估的标准</h3><ul><li>实时性</li><li>可靠性(鲁棒性)</li><li>匹配的精度</li></ul><h2 id="朴素算法"><a class="markdownIt-Anchor" href="#朴素算法"></a> 朴素算法：</h2><p>快速匹配算法的执行步骤如下：</p><ol><li>步1接收GPS定位数据；</li><li>步2判断定位数据是否无效，若无效，则根据历史定位数据进行推测匹配，然后转（8）；</li><li>步3判断车辆当前是否处于停止或低速滑行状态，若是，对其作相应处理，然后转（8）；</li><li>步4由车辆当前位置点计算其对应的候选网格，进而获取其中的路段；</li><li>步5对步4得到的路段进行<strong>连接性拓扑检查</strong>，将通过拓扑检查的路段作为匹配候选路段；</li><li>步6判断匹配候选路段数目，若唯一，则直接将其作为匹配路段，并由定位点向其作投影，然后转（8）；否则，计算所有候选路段的匹配度度量值f，（i=1,2，…，N），从中选出最大值fm和次大值fm；</li><li>步7判断最大值fm和次大值fm之差是否大于阈值fh，且最大值fm是否大于阈值fh，如果大于，则将路段m作为匹配路段，并由定位点向其作投影；否则，暂不对本次定位结果进行匹配，待后面对其进行延时匹配处理；</li><li>步8结束本次匹配</li></ol><p>from : <a href="https://wenku.baidu.com/view/14551bfcfab069dc50220144.html?fr=xueshu_top" target="_blank" rel="noopener">一种适于车辆导航系统的快速地图匹配算法</a>——2003</p><h2 id="key"><a class="markdownIt-Anchor" href="#key"></a> Key:</h2><ul><li><p>出行数据：采用GPS定位，那么是否是WGS-84数据，但是GIS部门的路网数据坐标是什么坐标系下的</p></li><li><p>双线路：</p></li><li><p>当下，现在很多用于MapMatching的方法，大多来自于推理、预测的数学方法，如隐马尔可夫链、贝叶斯模型、神经网络模型等，但在数据结构上的创新比较少，GIS算法，更多要在计算机的基础上，结合比如时空观念、数据特征、拓扑关系等对于GIS相关的基础理论</p></li></ul><h2 id="软件"><a class="markdownIt-Anchor" href="#软件"></a> 软件</h2><ul><li>mapinfo: 当今世界上流行的桌面地理信息系统</li><li>graphhopper: 路径规划库</li><li>arcgis</li><li>openstreetmap——开源地图，简称为OSM</li></ul><p>线要素的匹配，主要通过几何、拓扑或语义相似度来进行识别，其中通过空间距离来进行要素匹配的常用方式有：</p><ul><li>闵可夫斯基距离(Minkowski Distance)</li><li>欧氏距离(Euclidean Distance)</li><li>曼哈顿距离(Manhattan Distance)</li><li>切比雪夫距离(Chebyshev Distance)</li><li>汉明距离(Hamming distance)</li><li>杰卡德相似系数(Jaccard similarity coefficient)</li><li>豪斯多夫距离(Hausdorff Distance)</li><li>弗雷歇距离(Fréchet距离)</li></ul><p>from：<a href="http://www.biaozhu.net/9224.html" target="_blank" rel="noopener">高德地图：地图数据处理之道路匹配篇</a></p><h1 id="隐马尔科夫hmm"><a class="markdownIt-Anchor" href="#隐马尔科夫hmm"></a> 隐马尔科夫HMM</h1><p><strong>HMM有三个典型(canonical)问题</strong>:</p><ul><li><strong>概率计算问题</strong>：已知模型参数，计算某一特定输出序列的概率.通常使用**<a href="http://en.wikipedia.org/wiki/Forward_algorithm" target="_blank" rel="noopener">Forward</a>算法**解决；</li><li><strong>预测问题或者解码（decoding）问题</strong>：已知模型参数，寻找最可能的能产生某一特定输出序列的<strong>隐含状态</strong>的序列。通常使用**<a href="http://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="noopener">Viterbi</a>算法**解决；</li><li><strong>学习问题</strong>：已知输出序列，寻找最可能的状态转移以及输出概率。通常使用**<a href="http://en.wikipedia.org/wiki/Baum-Welch_algorithm" target="_blank" rel="noopener">Baum-Welch</a>算法**。</li></ul><h2 id="hmm的几个重要元素"><a class="markdownIt-Anchor" href="#hmm的几个重要元素"></a> HMM的几个重要元素：</h2><ul><li><p>π(startprob_): 隐藏状态初始向量</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi><mo>=</mo><mrow><mo fence="true">(</mo><msub><mi>π</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo>:</mo><msub><mi>π</mi><mi>i</mi></msub><mo>=</mo><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>=</mo><mi>i</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\pi=\left(\pi_{i}\right): \pi_{i}=P\left(q_{1}=i\right), 1 \leq i \leq N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">i</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></span></p></li><li><p>A(transmat_):  状态转移概率矩阵:</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><msub><mrow><mo fence="true">[</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo fence="true">]</mo></mrow><mrow><mi>N</mi><mo>×</mo><mi>N</mi></mrow></msub><mtext>, 其中 </mtext><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>q</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>j</mi><mo>∣</mo><msub><mi>q</mi><mi>t</mi></msub><mo>=</mo><mi>i</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">A=\left[a_{i j}\right]_{N \times N} \text {, 其中 } a_{i j}=P\left(q_{t+1}=j \mid q_{t}=i\right), 1 \leq i, j \leq N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.144139em;vertical-align:-0.394139em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.14252299999999996em;"><span style="top:-2.364192em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394139em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">, </span><span class="mord cjk_fallback">其中</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">i</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></span></p></li><li><p>B(emissionprob_): 观测状态概率矩阵</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><msub><mrow><mo fence="true">[</mo><msub><mi>b</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo fence="true">]</mo></mrow><mrow><mi>N</mi><mo>×</mo><mi>M</mi></mrow></msub><mi mathvariant="normal">，</mi><mtext> 其中 </mtext><msub><mi>b</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>o</mi><mi>t</mi></msub><mo>=</mo><msub><mi>o</mi><mi>k</mi></msub><mo>∣</mo><msub><mi>q</mi><mi>t</mi></msub><mo>=</mo><mi>j</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>N</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">B=\left[b_{j}(k)\right]_{N \times M} ， \text { 其中 } b_{j}(k)=P\left(o_{t}=o_{k} \mid q_{t}=j\right), 1 \leq j \leq N, 1 \leq k \leq M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.144139em;vertical-align:-0.394139em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.14252299999999996em;"><span style="top:-2.364192em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394139em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">，</span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">其中</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></span></p></li><li><p>HMM的状态变量数目：N</p></li><li><p>HMM的观察变量数目：M</p></li></ul><p>如果观测序列是一维的，则观测状态的概率密度函数是一维的普通高斯分布。如果观测序列是N维的，则隐藏状态对应的观测状态的概率密度函数是N维高斯分布。高斯分布的概率密度函数参数可以用μμ表示高斯分布的期望向量，Σ表示高斯分布的协方差矩阵。在GaussianHMM类中，“means”用来表示各个隐藏状态对应的高斯分布期望向量μ形成的矩阵，而“covars”用来表示各个隐藏状态对应的高斯分布协方差矩阵Σ形成的三维张量。</p><p>from :<a href="https://www.cnblogs.com/pinard/p/7001397.html" target="_blank" rel="noopener">用hmmlearn学习隐马尔科夫模型HMM</a></p><h2 id="mapmatching与hmm"><a class="markdownIt-Anchor" href="#mapmatching与hmm"></a> MapMatching与Hmm</h2><ul><li>观察变量：从GPS设备中得到的位置信息（经度，纬度）</li><li>隐藏状态：拥有GPS设备的物体（车，人等）实际所在的位置路段。</li><li>观测概率：例如，现测的GPS点离旁边路段上的位置越近，那么这个真实点在这个路段上的概率越大状态。</li><li>状态转移概率：例如，前后两个真实的位置点的距离越近，那么状态转移的概率越大</li></ul><p>在下面相关论文工作中会说明在这几篇论文中其实只用到了预测问题的<a href="http://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="noopener">Viterbi</a>算法,下面也会另开一小节具体描述下<a href="http://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="noopener">Viterbi</a>算法。</p><p><strong>Map-Matching的两个变量</strong>：</p><ul><li>从GPS设备中得到的位置信息（经度，纬度）：HMM中观察变量；</li><li>拥有GPS设备的物体（车，人等）实际所在的位置：HMM中的隐藏状态变量，实际地图是不知道GPS设备的准确位置的。</li></ul><p>这样就把Map-Matching问题与HMM结合起来了。三个问题在Map-Matching中有用的是两个问题：（1）预测问题；（2）学习问题。</p><p>在论文中，定义的规则要满足人的直观上的感觉，即人的先验知识，主要有以下两种：</p><ul><li>观测概率：观测的GPS点离旁边路段上的位置越近，那么这个真实点在这个路段上的概率越大。</li><li>状态转移概率：这里有两种解决思路：（1）前后两个真实的位置点的距离越近，那么状态转移的概率越大；或者（2）真实路段上的前后两个点的距离与GPS观测的前后两个点的距离越接近，状态转移概率越大。</li></ul><p>from: <a href="https://www.cnblogs.com/mindpuzzle/p/3653043.html" target="_blank" rel="noopener">基于隐马尔科夫模型(HMM)的地图匹配(Map-Matching)算法</a></p><h3 id="barefoot"><a class="markdownIt-Anchor" href="#barefoot"></a> <a href="https://github.com/bmwcarit/barefoot/wiki#stand-alone-servers" target="_blank" rel="noopener">barefoot</a></h3><ul><li>观测概率: 测量位置与其真实位置之间的距离，用于对测量误差进行建模，测量误差用具有一些标准偏差<em>σ</em>的高斯分布来描述（默认为<em>σ = 5 米</em>）。</li><li>转移概率: 用各个位置测量之间的路由距离和视线距离的差异来量化的。转移概率呈负指数分布，速率参数<em>λ</em>（默认为<em>λ = 0.1</em>）是均值的倒数</li></ul><p>==&gt;</p><ul><li><p><em><strong>序列概率</strong></em>： 定义<em>p(s 0 … s t |z 0 … z t )<em>为最可能的序列到达匹配候选</em>s t</em>的概率，称为 s t 的序列概率， 可以通过递归确定</p></li><li><p><em><strong>过滤概率</strong></em>：我们的 HMM 滤波器确定对象当前位置的估计值<em>s̅ t</em>，它是最可能匹配的候选对象<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub><mo>∈</mo><msub><mi>S</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">s_t ∈ S_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 给定测量值<code>z0 ... zt</code>，其定义为：<code>s̅t = argmax(st ∈ St) p(st|z0 ... zt)</code>, <code>p(st|z0 ... zt)</code>称为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">s_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的过滤概率***，可以递归确定：</p><p><code>p(st|z0...zt) = p(st|zt) · Σ(st-1 ∈ St-1) p(st|st-1) · p(st-1|z0 ... zt-1)</code>。</p></li></ul><p>from: <a href="https://github.com/bmwcarit/barefoot/wiki#stand-alone-servers" target="_blank" rel="noopener">https://github.com/bmwcarit/barefoot/wiki#stand-alone-servers</a></p><h2 id="coding"><a class="markdownIt-Anchor" href="#coding"></a> Coding</h2><blockquote><p>在之前的<a href="http://www.cnblogs.com/pinard/p/6945257.html" target="_blank" rel="noopener">HMM系列</a>中，我们对隐马尔科夫模型HMM的原理以及三个问题的求解方法做了总结。本文我们就从实践的角度用Python的<a href="https://hmmlearn.readthedocs.io/en/latest/api.html#hmmlearn-hmm" target="_blank" rel="noopener">hmmlearn</a>库来学习HMM的使用。sklearn库中将HMM弃用了，新开了一个<code>hmmlearn</code>的新库，安装命令为：<code>pip install hmmlearn</code>，关于hmmlearn的更多资料在<a href="http://hmmlearn.readthedocs.io/" target="_blank" rel="noopener">官方文档</a>有介绍。</p></blockquote><p>hmmlearn实现了三种HMM模型类，按照观测状态是连续状态还是离散状态，可以分为两类。</p><ol><li>GaussianHMM 观测状态连续型且符合高斯分布</li><li>GMMHMM 观测状态连续型且符合混合高斯分布</li><li>MultinomialHMM 观测状态离散型</li></ol><p><strong>HMM主要解决的三个问题</strong><br>假设隐藏状态序列和观测状态序列分别使用Z和X表示，则解决的3个问题可表示为:<br>1.解码问题：已知模型参数和X，估计最可能的Z；维特比算法<br>2.概率问题：已知模型参数和X，估计X出现的概率；向前-向后算法<br>3.学习问题：仅给出X和隐藏层个数，估计模型参数。 B-W算法，通常是经过一定数量的训练以后，得到模型，然后解决问题1和2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Created on 2017-12-4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">解码问题：本例为天气和行为的关系</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># hmmlearn可以在安装numpy以后，再使用pip install hmmlearn安装</span></span><br><span class="line"><span class="keyword">from</span> hmmlearn <span class="keyword">import</span> hmm</span><br><span class="line"></span><br><span class="line">states = [<span class="string">"Rainy"</span>, <span class="string">"Sunny"</span>]<span class="comment">##隐藏状态</span></span><br><span class="line">n_states = len(states)<span class="comment">##隐藏状态长度</span></span><br><span class="line"></span><br><span class="line">observations = [<span class="string">"walk"</span>, <span class="string">"shop"</span>, <span class="string">"clean"</span>]<span class="comment">##可观察的状态</span></span><br><span class="line">n_observations = len(observations)<span class="comment">##可观察序列的长度</span></span><br><span class="line"></span><br><span class="line">start_probability = np.array([<span class="number">0.6</span>, <span class="number">0.4</span>])<span class="comment">##开始转移概率，即开始是Rainy和Sunny的概率</span></span><br><span class="line"><span class="comment">##隐藏间天气转移混淆矩阵，即Rainy和Sunny之间的转换关系，例如[0,0]表示今天Rainy，明天Rainy的概率</span></span><br><span class="line">transition_probability = np.array([</span><br><span class="line">  [<span class="number">0.7</span>, <span class="number">0.3</span>],</span><br><span class="line">  [<span class="number">0.4</span>, <span class="number">0.6</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">##隐藏状态天气和可视行为混淆矩阵，例如[0,0]表示今天Rainy，walk行为的概率为0.1</span></span><br><span class="line">emission_probability = np.array([</span><br><span class="line">  [<span class="number">0.1</span>, <span class="number">0.4</span>, <span class="number">0.5</span>],</span><br><span class="line">  [<span class="number">0.6</span>, <span class="number">0.3</span>, <span class="number">0.1</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建了一个MultinomialHMM模型，这模型包括开始的转移概率，隐藏间天气转换混淆矩阵（transmat），隐藏状态天气和可视行为混淆矩阵emissionprob，对模型参数初始化</span></span><br><span class="line">model = hmm.MultinomialHMM(n_components=n_states)</span><br><span class="line">model.startprob_= start_probability</span><br><span class="line">model.transmat_ = transition_probability</span><br><span class="line">model.emissionprob_ = emission_probability</span><br><span class="line"></span><br><span class="line"><span class="comment">#给出一个可见序列</span></span><br><span class="line">bob_Actions = np.array([[<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>]]).T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决问题1,解码问题,已知模型参数和X，估计最可能的Z； 维特比算法 </span></span><br><span class="line">logprob, weathers = model.decode(bob_Actions, algorithm=<span class="string">"viterbi"</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Bob Actions:"</span>, <span class="string">", "</span>.join(map(<span class="keyword">lambda</span> x: observations[x], bob_Actions))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"weathers:"</span>, <span class="string">", "</span>.join(map(<span class="keyword">lambda</span> x: states[x], weathers))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">解码问题： 盒子</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> hmmlearn <span class="keyword">import</span> hmm</span><br><span class="line"></span><br><span class="line">states = [<span class="string">"box 1"</span>, <span class="string">"box 2"</span>, <span class="string">"box3"</span>]</span><br><span class="line">n_states = len(states)</span><br><span class="line"></span><br><span class="line">observations = [<span class="string">"red"</span>, <span class="string">"white"</span>]</span><br><span class="line">n_observations = len(observations)</span><br><span class="line"></span><br><span class="line">start_probability = np.array([<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.4</span>])</span><br><span class="line"></span><br><span class="line">transition_probability = np.array([</span><br><span class="line">  [<span class="number">0.5</span>, <span class="number">0.2</span>, <span class="number">0.3</span>],</span><br><span class="line">  [<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.2</span>],</span><br><span class="line">  [<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.5</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">emission_probability = np.array([</span><br><span class="line">  [<span class="number">0.5</span>, <span class="number">0.5</span>],</span><br><span class="line">  [<span class="number">0.4</span>, <span class="number">0.6</span>],</span><br><span class="line">  [<span class="number">0.7</span>, <span class="number">0.3</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model = hmm.MultinomialHMM(n_components=n_states)</span><br><span class="line">model.startprob_=start_probability</span><br><span class="line">model.transmat_=transition_probability</span><br><span class="line">model.emissionprob_=emission_probability</span><br><span class="line"></span><br><span class="line">seen = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]).T</span><br><span class="line">logprob, box = model.decode(seen, algorithm=<span class="string">"viterbi"</span>)</span><br><span class="line">print(<span class="string">"The ball picked:"</span>, <span class="string">", "</span>.join(map(<span class="keyword">lambda</span> x: observations[x], seen)))</span><br><span class="line">print(<span class="string">"The hidden box"</span>, <span class="string">", "</span>.join(map(<span class="keyword">lambda</span> x: states[x], box)))</span><br><span class="line">(<span class="string">'The ball picked:'</span>, <span class="string">'red, white, red'</span>)</span><br><span class="line">(<span class="string">'The hidden box'</span>, <span class="string">'box3, box3, box3'</span>)</span><br></pre></td></tr></table></figure><h2 id="限制"><a class="markdownIt-Anchor" href="#限制"></a> 限制</h2><ul><li>对于不同的建模选择和输入数据而言，它相对不灵活</li><li>它缩放严重(O(N²)，其中N是每个状态下可能的候选数)</li><li>它不能很好地应对高频观测(请参阅Newson＆Krumm [2])。</li></ul><p>基于(无味)卡尔曼滤波器的新模型——<a href="https://blog.csdn.net/weixin_26713521/article/details/108134220" target="_blank" rel="noopener">https://blog.csdn.net/weixin_26713521/article/details/108134220</a></p><h1 id="help-code"><a class="markdownIt-Anchor" href="#help-code"></a> help Code:</h1><ul><li><a href="https://github.com/bmwcarit/barefoot" target="_blank" rel="noopener">https://github.com/bmwcarit/barefoot</a></li><li><a href="https://github.com/oldrev/mapmatchingkit" target="_blank" rel="noopener">https://github.com/oldrev/mapmatchingkit</a></li></ul><h1 id="网络文章"><a class="markdownIt-Anchor" href="#网络文章"></a> 网络文章</h1><ul><li><a href="https://blog.csdn.net/weixin_42599077/article/details/114801735" target="_blank" rel="noopener">地图匹配实例-几何匹配</a>——效果图</li><li><a href="https://blog.csdn.net/weixin_26713521/article/details/108134220" target="_blank" rel="noopener">定位匹配 模板匹配 地图_什么是地图匹配？</a></li><li><a href="https://blog.csdn.net/Feng512275/article/details/96199675?spm=1001.2014.3001.5502" target="_blank" rel="noopener">出租车轨迹点地图匹配研究</a></li><li><a href="https://blog.csdn.net/yixianfeng41/article/details/73010792" target="_blank" rel="noopener">地图匹配小结</a></li><li><a href="https://www.cnblogs.com/mindpuzzle/p/3653043.html" target="_blank" rel="noopener">基于隐马尔科夫模型(HMM)的地图匹配(Map-Matching)算法</a></li></ul><h1 id="工作安排"><a class="markdownIt-Anchor" href="#工作安排"></a> 工作安排</h1><p>你的工作主要完成什么（概括说明就行），分为那几步，每一步完成什么（概括说明就行），每一步的工作量（预计完成这步工作需要多少个小时），每一步工作预计在什么时候完成（比如 3.5）</p><ul><li>工作包含：地图匹配，将车辆的有序GPS位置数据关联到电子地图的路网上，将GPS坐标下采样序列转换为数字路网路径序列的过程。工作内容：解析过滤点并进行坐标转换-&gt;点过滤(点稀疏)-&gt;地图匹配算法-&gt;点映射</li></ul><table><thead><tr><th>内容</th><th>预估时间</th></tr></thead><tbody><tr><td>查阅地图匹配算法相关的论文-&gt;找到解决方案(16小时)</td><td>2022年2月28日</td></tr><tr><td>学习隐马尔科夫模型相关理论知识 (6小时)</td><td>2022年3月2日</td></tr><tr><td>找寻隐马尔科夫模型资料、代码(8小时)——barefoot、graphhopper</td><td>2022年3月4日</td></tr><tr><td>熟悉项目中有关地图对象的代码（4小时）</td><td>2022年3月5日</td></tr><tr><td>移植隐马尔科夫模型到项目中，目前参考：开源<a href="https://github.com/bmwcarit/barefoot/wiki#stand-alone-servers" target="_blank" rel="noopener">barefoot</a>实现：熟悉代码(16小时)、坐标转换（3小时）、输入输出数据格式改造(10小时)、适配类(56小时)、效果检验（10小时）</td><td>2022年3月20日</td></tr><tr><td>点过滤（24小时）: 栅格化（16小时） + 双队列（8小时）</td><td>2022年3月24日</td></tr><tr><td>点映射（6小时）</td><td>2022年3月25日</td></tr></tbody></table><h1 id="库"><a class="markdownIt-Anchor" href="#库"></a> 库：</h1><ul><li><a href="https://developers.arcgis.com/javascript/latest/api-reference/esri-geometry-geometryEngine.html" target="_blank" rel="noopener">geometryEngine</a></li><li>net.sf.geographiclib</li><li>com.esri.core.geometry——QuadTree</li><li>graphhopper——org.locationtech.jts.geom  ==&gt; Envelope --&gt; findCandidateSnapsInBBox</li></ul><hr><h1 id="简单版实现思路"><a class="markdownIt-Anchor" href="#简单版实现思路"></a> 简单版实现思路</h1><ol><li>找到起始点O和终点D，以两点为半径画圆，把所有范围内的NormalEdge全部加入List（只要起始点or终止点有一个在范围内）</li><li>确定第一条===&gt; 找离第一个GPS点最近的边</li><li>likelyRoute.forEach从上一条的lowerNormalEdge中(保证拓扑可达连接)，从中选择得分最高（距离和方向）的边作为后续边 。  如果没有lowerNormalEdge（如果所有剩余的点都能映射到最后的这条边上，则认为是终点，此时不在意死路）， 平常如果是死路，则放弃这条序列路径。TODO：没有后续路径时是否要考虑增加可能边集？</li><li>到达终点边结束</li><li>从likelyRoute中选择得分最高的路径</li></ol><p>用到的结构：</p><ul><li><code>likelyRoute: list[list]</code>, 存放多条可能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;地图匹配&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#地图匹配&quot;&gt;&lt;/a&gt; 地图匹配&lt;/h1&gt;
&lt;p&gt;概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;地图匹配（Map-Matching）是将运营车辆的有序的GPS位置关联到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>私有Gitlab配置SSH连接</title>
    <link href="https://nymrli.top/2022/02/25/%E7%A7%81%E6%9C%89Gitlab%E9%85%8D%E7%BD%AESSH%E8%BF%9E%E6%8E%A5/"/>
    <id>https://nymrli.top/2022/02/25/私有Gitlab配置SSH连接/</id>
    <published>2022-02-25T05:38:19.000Z</published>
    <updated>2022-02-25T06:04:05.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SSH连接并不是像<a href="https://so.csdn.net/so/search?q=http&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">http</a>连接一样，输入用户名和密码就可以了。SSH连接需要一些额外的配置</p></blockquote><h1 id="生成ssh秘钥和公钥"><a class="markdownIt-Anchor" href="#生成ssh秘钥和公钥"></a> 生成SSH秘钥和公钥</h1><h2 id="查询有效邮箱"><a class="markdownIt-Anchor" href="#查询有效邮箱"></a> 查询有效邮箱</h2><p>首先要确定使用的邮箱，是不是自己认为的邮箱，比如我以为是<code>chenli@sucsoft.com</code>结果，却发现是<code>399-chenli@sucsoft.com</code>，那么按照自认为的邮箱申请的keys那自然不会work。——一般情况不会有歧义邮箱出现，但我这边确实跟想的不太一样</p><h3 id="查询方法一新建项目"><a class="markdownIt-Anchor" href="#查询方法一新建项目"></a> 查询方法(一)——新建项目</h3><p>创建空的仓库，提示中提及的邮箱就是有效邮箱</p><p><img src="/2022/02/25/私有Gitlab配置SSH连接/gitlab-ssh.jpg" alt="gitlab-ssh"></p><h3 id="查询方法二个人preference"><a class="markdownIt-Anchor" href="#查询方法二个人preference"></a> 查询方法(二)——个人Preference</h3><ol><li>打开<code>User Settings-&gt;Profile</code>，其中有<code>Email</code>、<code>public email</code>和<code>commit email</code>三个邮箱，其中跟我们开发命令比较有关的就是这个Commit Email，之前我的默认是<code>399-chenli@sucsoft.com</code>，这边要设置自己想要的，比如<code>chenli@sucsoft.com</code></li></ol><p><img src="/2022/02/25/私有Gitlab配置SSH连接/email_settings.jpg" alt="email_settings"></p><p>▲选择完成后，滑到最下面选择Update profile settings</p><ol start="2"><li>打开<code>User Settings-&gt;Emails</code>可以看到，<code>chenli@sucsoft@sucsoft.com</code>的标签中有commit email，即设置成功</li></ol><p><img src="/2022/02/25/私有Gitlab配置SSH连接/preference_email.jpg" alt="preference_email"></p><h2 id="gitlab设置公钥"><a class="markdownIt-Anchor" href="#gitlab设置公钥"></a> Gitlab设置公钥</h2><p>确保邮箱是有效的后就可以生成秘钥了。</p><ol><li>设置git信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 设置git信息</span></span><br><span class="line">git config --global user.name <span class="string">"chenli"</span></span><br><span class="line">git config --global user.email <span class="string">"chenli@sucsoft.com"</span></span><br><span class="line"><span class="comment"># 2. 生成秘钥和公钥</span></span><br><span class="line">$ ssh-keygen -t rsa -C chenli@sucsoft.com</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/mrli/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /c/Users/mrli/.ssh/id_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /c/Users/mrli/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:zKPeKkm0bNzDqZcHUEDcvvDqPG2znRqDrD30yoBb8MM chenli@sucsoft.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|   ooo           |</span></span><br><span class="line"><span class="string">|    . o          |</span></span><br><span class="line"><span class="string">|     o           |</span></span><br><span class="line"><span class="string">|    + .o         |</span></span><br><span class="line"><span class="string">|.  + B oS        |</span></span><br><span class="line"><span class="string">| = .B.O. .       |</span></span><br><span class="line"><span class="string">|. E+o*++         |</span></span><br><span class="line"><span class="string">| o BB.B=..       |</span></span><br><span class="line"><span class="string">|. ..*B=*+        |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><p>根据命令输出结果可以看到，生成的结果在<code>C:\Users\mrli\.ssh</code>路径下，有<code>id_rsa</code>、<code>id_rsa.pub</code>，其中<code>id_rsa.pub</code>为公钥。</p><ol start="2"><li><p>将SSH公钥添加到GitHub账户</p><ol><li>复制文件路径内.pub后缀里的内容</li><li>进入SSH Keys的设置页面（登录GitHub，在右上角头像点击设置）</li></ol><p><img src="/2022/02/25/私有Gitlab配置SSH连接/add_ssh.jpg" alt="add_ssh"></p><ol start="3"><li>粘贴后，Title会自动提取生成，点击<code>Add key</code>则完成添加</li></ol></li></ol><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@gitlab.sucsoft.com</span><br><span class="line">Welcome to GitLab, @chenli!</span><br></pre></td></tr></table></figure><h1 id="more"><a class="markdownIt-Anchor" href="#more"></a> More</h1><h2 id="配置多个git信息"><a class="markdownIt-Anchor" href="#配置多个git信息"></a> 配置多个Git信息</h2><ol><li>将默认的<code>id_rsa</code>和<code>id_rsa.pub</code>改成指定的如<code>id_rsa_sucsoft.pub</code></li><li><code>.ssh/</code>路径下添加<code>config</code>配置文件，对应填写</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Host github.com                 </span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile C:\\Users\\mrli\\.ssh\\id_rsa_github</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    User Freedomisgood</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Host gitlab.sucsoft.com</span><br><span class="line">    HostName gitlab.sucsoft.com</span><br><span class="line">    IdentityFile C:\\Users\\mrli\\.ssh\\id_rsa_sucsoft</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    User chenli</span><br></pre></td></tr></table></figure><p>注意：Host后写的就是<code>ssh -T git@gitlab.sucsoft.com</code>中@后面的内容，如果写的是<code>sucsoft</code>，则写成<code>ssh -T git@sucsoft</code>，但是这样其实跟Gitlab页面中直接提供的不一样: <code>git@gitlab.sucsoft.com:suc-frame/xxxx.git</code>，所以最好还是规范的写<code>gitlab.sucsoft.com</code></p><p>★配置完成后最终文件夹中的内容：</p><p><img src="/2022/02/25/私有Gitlab配置SSH连接/more-1.jpg" alt="more-1"></p><p>注： known_host是自动生成的，如果第一次SSH连接网站，则会将host添加到这个文件中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;SSH连接并不是像&lt;a href=&quot;https://so.csdn.net/so/search?q=http&amp;amp;spm=1001.2101.3001.7020&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http&lt;/a&gt;连
      
    
    </summary>
    
    
      <category term="git" scheme="https://nymrli.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>语义化的版本控制</title>
    <link href="https://nymrli.top/2022/01/26/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    <id>https://nymrli.top/2022/01/26/语义化的版本控制/</id>
    <published>2022-01-26T14:30:00.000Z</published>
    <updated>2022-01-26T14:40:45.998Z</updated>
    
    <content type="html"><![CDATA[<p>语义化的版本控制： 用一组简单的规则及条件来约束版本号的配置和增长</p><blockquote><p>作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。</p><p>如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。</p><p>如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函数库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">此页链接</a>，让别人也知道这些规则并从中受益。</p></blockquote><h2 id="target"><a class="markdownIt-Anchor" href="#target"></a> Target:</h2><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p><ol><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li></ol><p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p><h2 id="语义化版本控制规范semver"><a class="markdownIt-Anchor" href="#语义化版本控制规范semver"></a> 语义化版本控制规范（SemVer）</h2><p>以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。</p><ol><li>使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。</li><li>标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</li><li>标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。</li><li>主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。</li><li>1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。</li><li><strong>修订号</strong> Z（x.y.Z <code>|</code> x &gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。</li><li><strong>次版本号</strong> Y（x.Y.z <code>|</code> x &gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。</li><li><strong>主版本号</strong> X（X.y.z <code>|</code> X &gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。</li><li><strong>先行版本号</strong>：可以（MAY）被标注在修订版之后，先加上<strong>一个连接号</strong>再加上<strong>一连串以句点分隔</strong>的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。</li><li><strong>版本编译信息</strong>可以（MAY）被标注在修订版或先行版本号之后，先加上<strong>一个加号</strong>再加上一连串以<strong>句点分隔</strong>的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。</li><li>版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符比非数字的标识符优先层级低。若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0。</li></ol><h2 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h2><p><strong>在 0.y.z 初始开发阶段，我该如何进行版本控制？</strong></p><p>最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。</p><p><strong>如何判断发布 1.0.0 版本的时机？</strong></p><p>当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。</p><p><strong>这不会阻碍快速开发和迭代吗？</strong></p><p>主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。</p><p><strong>对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？</strong></p><p>这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。</p><p><strong>为整个公共 API 写文件太费事了！</strong></p><p>为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。</p><p><strong>万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？</strong></p><p>一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。</p><p><strong>如果我更新了自己的依赖但没有改变公共 API 该怎么办？</strong></p><p>由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。</p><p><strong>如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）</strong></p><p>自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。</p><p><strong>我该如何处理即将弃用的功能？</strong></p><p>弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。</p><p><strong>语义化版本对于版本的字串长度是否有限制呢？</strong></p><p>没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。</p><h2 id="版本alpha-beta-rc"><a class="markdownIt-Anchor" href="#版本alpha-beta-rc"></a> 版本：Alpha、beta、RC</h2><blockquote><p>这些叫做先行版本号。被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰，如1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92</p></blockquote><p>常见的 RC 版本，全称是 Release Candidate。其中 Release 是发行、发布的意思。Candidate 是候选人的意思，用在软件或者操作系统上就是候选版本。因此 Release Candidate 就是发行候选版本。</p><table><thead><tr><th>版本名称</th><th>介绍</th><th>说明</th></tr></thead><tbody><tr><td>Alpha</td><td>内测版本</td><td>内部测试版本。</td></tr><tr><td>Beta</td><td>公测版本</td><td>Beta 阶段会一直加入新的功能。</td></tr><tr><td>RC</td><td>候选版本</td><td>几乎就不会加入新的功能了，而主要着重于除错。</td></tr><tr><td>Release</td><td>正式版本</td><td>稳定版本。</td></tr></tbody></table><p>RC 版本和 Beta 版最大的差别在于 Beta 阶段会<strong>一直加入新的功能</strong>，但是到了 RC 阶段，几乎就不会加入新的功能了，而主要着重于<strong>除错</strong>。</p><p>RC 版本，它不是最终的版本，而是最终版（RTM，Release To Manufacture）之前的最后一个版本。广义上对测试有三个传统的称呼：Alpha（α）、Beta（β）、Gamma（γ），用来标识测试的阶段和范围。Alpha 是指内测，即现在说的 CB，指开发团队内部测试的版本或者有限用户体验测试版本。Beta 是指公测，即针对所有用户公开的测试版本。然后做过一些修改，成为正式发布的候选版本时叫做 Gamma，现在叫做 RC。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;语义化的版本控制： 用一组简单的规则及条件来约束版本号的配置和增长&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>理解SpringBoot注解s</title>
    <link href="https://nymrli.top/2021/12/30/%E7%90%86%E8%A7%A3SpringBoot%E6%B3%A8%E8%A7%A3s/"/>
    <id>https://nymrli.top/2021/12/30/理解SpringBoot注解s/</id>
    <published>2021-12-30T12:30:45.000Z</published>
    <updated>2021-12-30T14:25:40.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="reuqestbody和requestparam"><a class="markdownIt-Anchor" href="#reuqestbody和requestparam"></a> @ReuqestBody和@RequestParam</h2><p>这两个注解都是在Controller某个Mapping函数的形参前加上的，但两个具体有什么区别呢？在使用的时候我们该如何选择呢? 这跟我们希望用户以什么形式来请求接口有关。</p><p>众所周知，请求头的Content-type有多个，如</p><p>常见的媒体格式类型如下：</p><ul><li>text/html ： HTML格式</li><li>text/plain ：纯文本格式</li><li>text/xml ： XML格式</li><li>image/gif ：gif图片格式</li><li>image/jpeg ：jpg图片格式</li><li>image/png：png图片格式</li></ul><p>以application开头的媒体格式类型：</p><ul><li>application/xhtml+xml ：XHTML格式</li><li>application/xml： XML数据格式</li><li>application/atom+xml ：Atom XML聚合格式</li><li>⭐️application/json： JSON数据格式</li><li>application/pdf：pdf格式</li><li>application/msword ： Word文档格式</li><li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li><li>⭐️application/x-www-form-urlencoded ：<code>&lt;form encType=&quot;&quot;&gt;</code>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li></ul><p>另外一种常见的媒体格式是上传文件之时使用的：</p><ul><li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li></ul><p>其中，POST请求最常用的是<code>application/x-www-form-urlencoded</code>,浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。请求类似于下面这样</p><p><img src="/2021/12/30/理解SpringBoot注解s/E:%5Chexo%5Csource_posts%5C%E7%90%86%E8%A7%A3SpringBoot%E6%B3%A8%E8%A7%A3s%5Cpost-www.png" alt="post-www"></p><p>此外，<code>application/json</code>也是POST比较常用的一种形式，也是目前比较推荐的，用来告诉服务端消息主体是序列化后的 JSON 字符串。在这种编码方式下，请求内容如下：</p><p><img src="/2021/12/30/理解SpringBoot注解s/E:%5Chexo%5Csource_posts%5C%E7%90%86%E8%A7%A3SpringBoot%E6%B3%A8%E8%A7%A3s%5Cpost-json.png" alt="post-json"></p><p>可以看出，无论是哪种编码，POST基本上都是从请求体中取数据解析的。而<code>@RequestBody</code>正是对应的请求体；<code>@RequestParam</code>呢，接收的参数是<strong>来自requestHeader</strong>中，即<strong>请求头</strong>。<strong>通常用于GET请求</strong>，功能是<em>从URL中提取请求参数</em>。比如常见的url：<code>http://localhost:8081/spring-boot-study/novel/findByAuthorAndType?author=唐家三少&amp;type=已完结</code>。对应的接口为<code>public List&lt;NovelEntity&gt; findByAuthorAndType(@RequestParam(value=&quot;author&quot;, required=false,defaultValue=&quot;天蚕土豆&quot;) String author, @RequestParam(value=&quot;type&quot;) String type)</code></p><p>@RequestParam有三个配置参数：</p><ul><li><code>required</code> 表示是否必须，默认为 <code>true</code>，必须。</li><li><code>defaultValue</code> 可设置请求参数的默认值。</li><li><code>value</code> 为接收url参数的参数名（相当于key值）。</li></ul><p><strong>@RequestParam用来处理 <code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 编码的内容，<code>Content-Type</code>默认为该属性。</strong></p><p><strong>@RequestParam也可用于其它类型的请求，例如：GET、POST、DELETE等请求</strong>。比如向表中插入单条数据，<code>Controller</code> 层的写法如下图所示：</p><p>但是，这样不支持批量插入数据，相对之下，json来表达的优势就很明显，但是@RequestParam没办法处理<code>application/json</code>，点击发送的话，会报错后台接收不到值，为 <code>null</code>。</p><p>此时就需要使用对应的<code>@RequestBody</code>，它一般用于处理非 <code>Content-Type: application/x-www-form-urlencoded</code>编码格式的数据，比如：<code>application/json</code>、<code>application/xml</code>等类型的数据。就<code>application/json</code>类型的数据而言，使用注解@RequestBody可以将body里面所有的json数据传到后端，后端再进行解析。如<code>public Map&lt;String, Boolean&gt; saveBatchNovel(@RequestBody List&lt;NovelEntity&gt; novelEntityList)</code></p><p>此外，针对希望用户传入的为指定参数的话，有相应的Entity，使用@RequestBody会根据请求主体中的参数名与对象的属性名进行匹配并绑定值，自动将参数封装成该对象，并且还可以通过@Valid注解对请求主体中的参数进行校验。</p><p>总结：</p><ul><li><code>@RequestParam</code>的核心功能是<em>从URL中提取请求参数</em>，即接收的参数是来自HTTP请求头的QueryString中。</li><li><code>@RequestBody</code>功能是从请求体重提取参数，并封装成对象</li></ul><p>额外经验总结：</p><blockquote><p>标准协议下，通常认为GET请求是没有请求体的，只有POST请求有请求体</p></blockquote><ul><li><p>get请求只能传query参数，query参数都是拼在请求地址上的</p></li><li><p>post可以同时传body和query两种形式的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/post/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">postHello</span><span class="params">(@PathVariable Long id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         @RequestParam(value = <span class="string">"name"</span>, required = <span class="keyword">false</span>, defaultValue = <span class="string">"CL"</span>)</span> String name,</span></span><br><span class="line"><span class="function">                                         @RequestBody User user</span></span><br><span class="line"><span class="function">    ) </span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">"name"</span>, name);</span><br><span class="line">            put(<span class="string">"id"</span>, String.valueOf(id));</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>talent-API</p><p><img src="/2021/12/30/理解SpringBoot注解s/E:%5Chexo%5Csource_posts%5C%E7%90%86%E8%A7%A3SpringBoot%E6%B3%A8%E8%A7%A3s%5Cpost-query+body.png" alt="post-query+body"></p><p>postman-web</p><p><img src="/2021/12/30/理解SpringBoot注解s/E:%5Chexo%5Csource_posts%5C%E7%90%86%E8%A7%A3SpringBoot%E6%B3%A8%E8%A7%A3s%5Cpost+body+query2.png" alt="post+body+query2"></p><p>针对接口的测试，最好还是手动设置Content-type比较好</p></li></ul><p><strong>@PathVariable</strong></p><blockquote><p>承接上文，同样作为参数传入的还有@PathVariable，它可以从URL中提取变量</p></blockquote><p><code>@PathVariable</code>注解是将方法中的参数绑定到请求URI中的模板变量上。可以通过<code>@RequestMapping</code>注解来指定URI的模板变量，然后使用<code>@PathVariable</code>注解将方法中的参数绑定到模板变量上。特别地，<code>@PathVariable</code>注解允许我们使用value或name属性来给参数取一个别名。下面是使用此注解的一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/users/&#123;id&#125;/roles/&#123;roleId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Role <span class="title">getUserRole</span><span class="params">(@PathVariable <span class="keyword">long</span> id, @PathVariable <span class="keyword">long</span> roleId)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板变量名需要使用<code>{ }</code>进行包裹，如果方法的参数名与URI模板变量名一致，则在<code>@PathVariable</code>中就可以省略别名的定义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;reuqestbody和requestparam&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#reuqestbody和requestparam&quot;&gt;&lt;/a&gt; @ReuqestBody和@RequestParam&lt;/h2&gt;
&lt;p&gt;这两个注
      
    
    </summary>
    
    
      <category term="开发笔记" scheme="https://nymrli.top/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用七牛云作图床+PicGo</title>
    <link href="https://nymrli.top/2021/12/29/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E4%BD%9C%E5%9B%BE%E5%BA%8A-PicGo/"/>
    <id>https://nymrli.top/2021/12/29/使用七牛云作图床-PicGo/</id>
    <published>2021-12-29T13:48:37.000Z</published>
    <updated>2021-12-29T14:12:11.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自己在写博客的时候，通过图片来表达自己的思路无疑是种非常有效的方法，平常我的笔记都是通过hexo生成的，因此保存在本地路径即可。但是如果想把文章发表在第三方的平台上，那么这些相对路径的图片在上传过程中就无法被检索，因此如果能在一个大家都能访问到的地方存放这些图片，再给出这些地方的链接时那就解决了这个问题。要达到这个需求，则就需要使用OSS对象存储服务。</p><p>这边我推荐的是七牛云。七牛云在注册认证后有10G永久免费空间，每月10G国内和10G国外流量，速度相当快，七牛云是国内专业CDN服务商，插件支持比较多，有免费SSL证书，但https流量收费。同时七牛云还会提供30天的测试域名，不过要注意的一点是，七牛云30天后会回收测试域名，并且通过测试域名存储的文件会在30天后一起被杀出，因此最好还是要绑定自己的已备案的域名。</p></blockquote><h1 id="七牛云"><a class="markdownIt-Anchor" href="#七牛云"></a> <a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a>创建与配置</h1><h2 id="创建空间"><a class="markdownIt-Anchor" href="#创建空间"></a> 创建空间</h2><p>可以根据自己的需求来新建自己的存储空间，点击【新建空间】，对空间进行配置，这里要注意，以下几点：</p><ul><li>存储空间名称不能重复，我这里也新建一个名称为：onestar-blog-img</li><li>存储区域选择一个离你近点的，我选的是华东，每个地点有个编号的，后面要用来配置PicGo，这里先说一下区域对应编号: 华东：z0；华北：z1；华南：z2：北美：na0：东南亚：as0</li><li>访问控制选择公开，因为要作为外链进行访问</li></ul><p><img src="/2021/12/29/使用七牛云作图床-PicGo/%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%97%B4.png" alt="创建空间"></p><p><img src="/2021/12/29/使用七牛云作图床-PicGo/%E5%88%9B%E5%BB%BA%E6%88%90%E5%8A%9F.png" alt="创建成功"></p><h2 id="配置域名并绑定"><a class="markdownIt-Anchor" href="#配置域名并绑定"></a> 配置域名并绑定</h2><ol><li>点击&quot;+绑定域名&quot;按钮</li></ol><p><img src="/2021/12/29/使用七牛云作图床-PicGo/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D.png" alt="绑定域名"></p><p>2.就会进入如下的添加域名页面，需要做的就是填入一个三级域名，如我申请的二级域名为nymrli.top，那么这边我可以写<code>xxx.nymrli.top</code>，这个xxx就是nymrli.top下的子域名，但是这个毕竟是我们临时想出来的，因此要让他生效的话，我们还需要在DNS服务商那边进行配置。</p><p><img src="/2021/12/29/使用七牛云作图床-PicGo/%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D.png" alt="添加域名"></p><p><img src="/2021/12/29/使用七牛云作图床-PicGo/%E7%82%B9%E5%87%BB%E9%85%8D%E7%BD%AECname.png" alt="点击配置Cname"></p><ol start="3"><li>接下来开始配置CNAME解析，由于我的域名解析是在阿里云做的，因此需要到阿里云的域名管理控制台添加这个CNAME的解析</li></ol><p><img src="/2021/12/29/使用七牛云作图床-PicGo/DNS%E8%AE%B0%E5%BD%95.png" alt="DNS记录"></p><p>添加好CNAME记录后等待一会让其生效后，就能到七牛云的“域名管理”页面查看状态啦，如下所示，这边的“状态”显示成功了</p><p><img src="/2021/12/29/使用七牛云作图床-PicGo/%E6%9F%A5%E7%9C%8B%E5%9F%9F%E5%90%8D%E6%98%AF%E5%90%A6%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F%E6%88%90%E5%8A%9F.png" alt="查看域名是否配置成功成功"></p><h1 id="picgo图床软件"><a class="markdownIt-Anchor" href="#picgo图床软件"></a> <a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0" target="_blank" rel="noopener">Picgo图床软件</a>配置</h1><p>自带免费的SM.MS图床配置，可以直接使用。但是用别人的配置，占别人的资源毕竟不太好，容易超额，而且安全性也不高。因此配置自己的存储API，这边使用上述配置好的七牛云。</p><p><img src="/2021/12/29/使用七牛云作图床-PicGo/picgo%E9%85%8D%E7%BD%AE.png" alt="picgo配置"></p><ul><li>accessKey和SecretKey可以点击头像到“个人中心”去查看并复制进去</li><li>存储空间名就是一开始创建空间的名字</li><li>网址的话就是自己绑定的三级域名</li><li>这边比较容易填错的是存储区域，对应的其实是华南、华东……但需要填编号，这边编号关系如下：<ul><li>z0；华北：z1；华南：z2：北美：na0：东南亚：as0</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;自己在写博客的时候，通过图片来表达自己的思路无疑是种非常有效的方法，平常我的笔记都是通过hexo生成的，因此保存在本地路径即可。但是如果想把文章发表在第三方的平台上，那么这些相对路径的图片在上传过程中就无法被检索，因此如果能在一个大家都能访问到的地
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开发方向-技术栈</title>
    <link href="https://nymrli.top/2021/12/28/%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>https://nymrli.top/2021/12/28/开发方向-技术栈/</id>
    <published>2021-12-28T13:02:43.000Z</published>
    <updated>2021-12-28T16:10:43.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cloud-微服务全家桶"><a class="markdownIt-Anchor" href="#cloud-微服务全家桶"></a> Cloud 微服务全家桶</h1><blockquote><p>微服务开发的主流技术栈</p></blockquote><ul><li>服务注册中心<ul><li>:error:eureka 停止更新</li><li>❌consul</li><li>zookeeper</li><li>⭐️nacos</li></ul></li><li>服务负载与调用<ul><li>❌ netflix oss ribbon ==&gt; spring cloud loadbalance</li><li>netflix feign ==&gt; Spring cloud OpenFeign</li></ul></li><li>容量限流(熔断)<ul><li>❌hystrix: 最先的老大哥</li><li>resilience4j：国外使用较多</li><li>⭐️spring cloud alibaba sentinel</li></ul></li><li>配置中心<ul><li>❌spring cloud config</li><li>携程: apollo</li><li>spring cloud alibaba nacos</li></ul></li><li>服务开发<ul><li>spring boot</li></ul></li><li>流量监控</li><li>服务总线:<ul><li>❌spring cloud bus</li><li>spring cloud alibaba nacos</li></ul></li><li>服务治理</li><li>链路追踪<ul><li>spring cloud sleuth</li></ul></li><li>服务网关<ul><li>❌(netflix) zuul</li><li>zuul2: 胎死腹中</li><li>⭐️spring cloud gateway</li></ul></li><li>matrics（指标）监控：<ul><li>kairosDB</li></ul></li><li>日志监控：<ul><li>ELK</li></ul></li><li>健康检查和告警：<ul><li>zalando</li><li>zmon</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cloud-微服务全家桶&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cloud-微服务全家桶&quot;&gt;&lt;/a&gt; Cloud 微服务全家桶&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;微服务开发的主流技术栈&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
    
      <category term="开发" scheme="https://nymrli.top/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>开发过程中Mysql API记录</title>
    <link href="https://nymrli.top/2021/12/26/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%ADMysql-API%E8%AE%B0%E5%BD%95/"/>
    <id>https://nymrli.top/2021/12/26/开发过程中Mysql-API记录/</id>
    <published>2021-12-26T12:52:57.000Z</published>
    <updated>2021-12-26T13:27:57.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间操作"><a class="markdownIt-Anchor" href="#时间操作"></a> 时间操作</h1><h2 id="time_to_sec"><a class="markdownIt-Anchor" href="#time_to_sec"></a> TIME_TO_SEC</h2><blockquote><p><a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">MySQL</a> TIME_TO_SEC(time) 函数返回将<strong>参数 time 转换为秒数的时间值</strong>，转换公式为“小时 ×3600+ 分钟 ×60+ 秒”。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT TIME_TO_SEC(&apos;15:15:15&apos;);</span><br><span class="line">+-------------------------+</span><br><span class="line">| TIME_TO_SEC(&apos;15:15:15&apos;) |</span><br><span class="line">+-------------------------+</span><br><span class="line">|                   54915 |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select TIME_TO_SEC(&quot;2021-02-02 04:04:04&quot;);-- 只会考虑时分秒，不会考虑年月日</span><br><span class="line">+-------------------------+</span><br><span class="line">| TIME_TO_SEC(&quot;2021-02-02 04:04:04&quot;) |</span><br><span class="line">+-------------------------+</span><br><span class="line">|                   14644 |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure><p>具体实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SEC_TO_TIME(TIME_TO_SEC(时间字段)- TIME_TO_SEC(时间字段)%(15*60)) as intervals from tablename</span><br><span class="line">group by intervals</span><br></pre></td></tr></table></figure><h2 id="sec_to_time"><a class="markdownIt-Anchor" href="#sec_to_time"></a> SEC_TO_TIME</h2><blockquote><p>返回将参数 seconds 转换为小时、分钟和秒数的时间值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SEC_TO_TIME(&apos;54925&apos;);</span><br><span class="line">+----------------------+</span><br><span class="line">| SEC_TO_TIME(&apos;54925&apos;) |</span><br><span class="line">+----------------------+</span><br><span class="line">| 15:15:25             |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="date_format"><a class="markdownIt-Anchor" href="#date_format"></a> <a href="https://www.w3school.com.cn/sql/func_date_format.asp" target="_blank" rel="noopener">DATE_FORMAT</a></h2><blockquote><p>用于以不同的格式显示日期/时间数据: <code>DATE_FORMAT(date, format)</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DATE_FORMAT(NOW(),&apos;%b %d %Y %h:%i %p&apos;)</span><br><span class="line">DATE_FORMAT(NOW(),&apos;%m-%d-%Y&apos;)</span><br><span class="line">DATE_FORMAT(NOW(),&apos;%d %b %y&apos;)</span><br><span class="line">DATE_FORMAT(NOW(),&apos;%d %b %Y %T:%f&apos;)</span><br><span class="line"></span><br><span class="line">Dec 29 2008 11:45 PM</span><br><span class="line">12-29-2008</span><br><span class="line">29 Dec 08</span><br><span class="line">29 Dec 2008 16:25:46.635</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时间操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#时间操作&quot;&gt;&lt;/a&gt; 时间操作&lt;/h1&gt;
&lt;h2 id=&quot;time_to_sec&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#time_to_sec&quot;
      
    
    </summary>
    
    
      <category term="Mysql" scheme="https://nymrli.top/tags/Mysql/"/>
    
      <category term="开发记录" scheme="https://nymrli.top/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>软件架构课程学习笔记</title>
    <link href="https://nymrli.top/2021/12/12/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2021/12/12/软件架构课程学习笔记/</id>
    <published>2021-12-12T06:44:53.000Z</published>
    <updated>2021-12-13T14:51:58.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="术语"><a class="markdownIt-Anchor" href="#术语"></a> 术语</h1><p>–微服务</p><p>–云化</p><p>–分布式</p><p>–高并发</p><p>–高可用</p><h2 id="架构角色"><a class="markdownIt-Anchor" href="#架构角色"></a> 架构角色</h2><ul><li>探索者</li><li>设计师</li><li>倡导人</li></ul><h2 id="到底如何区分什么是架构-框架-模式和平台"><a class="markdownIt-Anchor" href="#到底如何区分什么是架构-框架-模式和平台"></a> 到底如何区分什么是架构、框架、模式和平台 ？</h2><p>设计模式&lt;框架&lt;架构&lt;平台，从复用角度讲，设计模式是代码级复用、框架是模块级复用、架构是系统级复用、平台是企业应用级复用。</p><p>模式:分为代码模式、设计模式、框架模式这些</p><ul><li>设计模式有不同的分类，如下<ul><li>创建型设计模式，如工厂方法（Factory Method）模式、抽象工厂（Abstract Factory）模式、原型（Prototype）模式、单例（Singleton）模式，建造（Builder）模式等</li><li>结构型设计模式，如合成（Composite）模式、装饰（Decorator）模式等</li></ul></li><li>框架：也有叫构架的，一般等同于ＭＶＣ、MVP、MVVM这种。</li></ul><p>举个栗子，农村要盖房，架构就是：你得考虑自己的经济实力、喜欢什么样的房子、有什么要求，选哪个靠谱的施工队。选好了之后，比如说要盖楼房，那么框架就是施工队的模式，有的施工队先这样做再那样做，而有的却相反，反正能把楼给你盖起来就行。模式就是局部的具体实现，比如说门这样安、窗户这样。</p><h2 id="目标"><a class="markdownIt-Anchor" href="#目标"></a> 目标</h2><p>达到最佳的功能和服务表现</p><p>资源利用率</p><p>灵活的开发、部署、运行、维护和创新</p><p>安全性、稳定性、可靠性等质量属性</p><h2 id="影响结构的因素"><a class="markdownIt-Anchor" href="#影响结构的因素"></a> 影响结构的因素</h2><p>利益相关者</p><p>开发团队</p><p>架构师</p><p>环境其他因素，比如冲突，隐性需求</p><h2 id="typical-design-trade-offs"><a class="markdownIt-Anchor" href="#typical-design-trade-offs"></a> <strong>Typical Design Trade-offs</strong></h2><p>功能和可用性</p><p>性能和可修改性</p><p>成本与鲁棒性效率和可移植性</p><p>快速开发vs.功能性</p><p>成本与可重用性</p><p>向后兼容性与可读性</p><p>架构：做一个基准让软件能够不断完善。架构本身在做的事情就是衔接软件从无序的需求变成有组织、有序的软件设计实现的中间转换环节。==&gt;注意架构的很多关注点都是来自于架构本身驱动的因素和非功能性的点（architectural driver）：性能、使用中的高可用、</p><p>质量属性：</p><ul><li>易用性高——一个中等业务水平的储蓄所人员能够在5个工作日内熟练掌握本系统80%功能</li></ul><p>问题？可修改性和性能，是否可以可以同时满足？ A: 这两个很容易冲突</p><p>近几年的毕业论文——把功能实现了，但非功能性需求就只是列了几个点。非功能性需求反应了这个系统关注的哪些指标点。同时要考虑非功能性需求之间的优先级，要体现了哪个目标是高的，是低的。这种优先级的，</p><p>单点–&gt;分布式==》集群化的，集群化服务的一些点就慢慢会形成一个高可用的架构，比如主备、热备、温备、冷备，还有一些通过集群化的方式来实现的高可用，比如多活、两地三总线。</p><p>多实例化应用：提高冗余数据虽然提高了可用性但是增加了安全性的影响、应用层管理实现方式：统一身份认证（统一的认证中心，避免了每个点的认证），权限层、认证层、网关层</p><p>组件间信息通信来探活，保证组件的可用性</p><p>性能：</p><ul><li>优先级调度，有优先能执行</li><li>有足够的资源</li></ul><p>安全</p><ul><li>拦截请求</li><li>加密、认证</li></ul><p>大型商业银行的主要特征：</p><ul><li>24小时不间断的高效核心银行系统</li><li>跨渠道、跨业务线、跨区域的集成服务能力</li><li>集团一体化架构模式下的差异化、个性化支持能力</li></ul><p>每一层都有不同的关注点，每一个关注点都有各自的解决方案，比如接入层有高并发的需求，业务处理层有安全可靠的去求。将关注点分层以后。</p><p>优势：每一个层能看地更清晰，并且更好地关注自身地处理方式。</p><p>劣势：层次层次交互过程中地trade-off问题</p><p>从quality地角度考虑，分布式是在解决高并发的访问，实现系统更好的应用性与交互性</p><p>核心银行系统的非功能性需求</p><ul><li>规模</li><li>性能</li><li>安全性</li><li>可用性和弹性</li><li>运维管理</li></ul><h2 id="用户接入平台技术架构"><a class="markdownIt-Anchor" href="#用户接入平台技术架构"></a> 用户接入平台技术架构</h2><p>所有接入的模块都不止一个，不管是tcp、http、还是身份认证的还是可视化管理的，都是通过增加多个实例来实现高可用。==&gt;主备、多活</p><p>应用平台-&gt;应用系统-&gt;系统进程-&gt;技术模块</p><p>关键技术组件模块：</p><ul><li>数据访问接口</li><li>后台进程运行模型</li><li>容错平台架构</li><li>数据可视化</li><li>公共服务框架<ul><li>监控管理<ul><li>统一的数据格式</li><li>监控数据定义</li><li>统一展示</li></ul></li><li>日志管理</li><li>时间管理</li></ul></li><li>撮合应用框架</li><li>行情处理应用框架</li><li>交易控制架构</li></ul><p>大型网站系统特点<br>高并发，大流量<br>高可用<br>用户分布广泛<br>需求快速变更<br>发布频繁<br>海量数据<br>安全环境恶劣<br>渐进式发展</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;术语&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#术语&quot;&gt;&lt;/a&gt; 术语&lt;/h1&gt;
&lt;p&gt;–微服务&lt;/p&gt;
&lt;p&gt;–云化&lt;/p&gt;
&lt;p&gt;–分布式&lt;/p&gt;
&lt;p&gt;–高并发&lt;/p&gt;
&lt;p&gt;–高可用&lt;/p&gt;
&lt;h2 id=&quot;架构角色&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Zju" scheme="https://nymrli.top/tags/Zju/"/>
    
  </entry>
  
  <entry>
    <title>创建Vue工程（包含Vue2和Vue3）</title>
    <link href="https://nymrli.top/2021/12/08/%E5%88%9B%E5%BB%BAVue%E5%B7%A5%E7%A8%8B%EF%BC%88%E5%8C%85%E5%90%ABVue2%E5%92%8CVue3%EF%BC%89/"/>
    <id>https://nymrli.top/2021/12/08/创建Vue工程（包含Vue2和Vue3）/</id>
    <published>2021-12-08T08:28:19.000Z</published>
    <updated>2021-12-08T08:28:51.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vuecli-init"><a class="markdownIt-Anchor" href="#vuecli-init"></a> @vue/cli-init</h2><blockquote><p><code>vue init</code> 是vue-cli2.x的初始化方式</p></blockquote><ul><li><code>vue init</code> ： 需要<code>npm i -g @vue/cli-init</code><ul><li><code>vue init webpack [project-name]</code>, webpack为模板<code>&lt;generate a project from a remote template&gt;</code>，然后按照交互信息提示输入即可完成工程创建</li><li>init创建工程时，交互信息中有一个比较有意思的是选择包管理工具： npm、yarn，两者<a href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">见</a></li></ul></li></ul><h2 id="vuecli"><a class="markdownIt-Anchor" href="#vuecli"></a> @vue/cli</h2><blockquote><p>会让选择Vue2还是Vue3</p></blockquote><ul><li><code>vue create router_project</code>: 需要<code>npm install -g @vue/cli</code></li><li><code>vue ui</code>通过UI创建： 需要<code>npm install -g @vue/cli</code><ul><li><code>vue create [project-name]</code></li></ul></li></ul><p>注：经测试，<code>Vue CLI v4.5.15</code>会提示选择yarn还是npm；<code>@vue/cli 4.5.13</code>没提示==&gt;后来发现貌似是平台的区别，linux上会提示选择，win上默认是yarn</p><p>Vue CLI 的包名称由vue-cli已经改成了@vue/cli，如果通过vue-cli来构建Vue3项目则需要通过 <code>npm uninstall vue-cli -g</code> 或 <code>yarn global remove vue-cli</code> 卸载它，然后安装@vue/cli，并且@vue/cli安装好后，如果不安装yarn，那么在vue create创建的时候报错<code>ERROR Error: spawn yarn ENOENT</code></p><h2 id="npm-init-vite-app-hello-vue"><a class="markdownIt-Anchor" href="#npm-init-vite-app-hello-vue"></a> <code>npm init vite-app hello-vue</code></h2><ul><li><blockquote><p><a href="https://so.csdn.net/so/search?from=pc_blog_highlight&amp;q=Vue" target="_blank" rel="noopener">Vue</a>3刚发布不久，官方文档中推荐的创建方法之一就是通过脚手架Vite来创建一个vue3项目</p><p>需要安装<code>create-vite-app</code></p></blockquote><ul><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ npm init vite-app vue3-vite</span><br><span class="line">Scaffolding project <span class="keyword">in</span> F:\Documents\HBuilderProjects\vue3-vite...</span><br><span class="line">Done. Now run:</span><br><span class="line">$ <span class="built_in">cd</span> vue3-vite</span><br><span class="line">$ npm install (or `yarn`)</span><br><span class="line">$ npm run dev (or `yarn dev`)</span><br></pre></td></tr></table></figure><p>可以看到，这个时需要进入项目目录后，里面没有<code>package-lock</code>或者<code>yarn.loca</code>，而是需要自己主动选择包管理工具进行安装依赖的；<code>vue create</code>和<code>vue init</code>的不需要可以直接运行</p></li></ul></li></ul><h2 id="vitejsapp"><a class="markdownIt-Anchor" href="#vitejsapp"></a> @vitejs/app</h2><ul><li><code>npm init @vitejs/app</code>然后选择project的框架</li></ul><p>注：2既可以创建Vue2，也可以创建vue3；3只能创建vue3；在创建速度上，法3比法2快上很多</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vuecli-init&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vuecli-init&quot;&gt;&lt;/a&gt; @vue/cli-init&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;vue init&lt;/code&gt; 是vue-cli
      
    
    </summary>
    
    
      <category term="前端" scheme="https://nymrli.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://nymrli.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>前后端-实现上传和下载</title>
    <link href="https://nymrli.top/2021/12/05/%E5%89%8D%E5%90%8E%E7%AB%AF-%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
    <id>https://nymrli.top/2021/12/05/前后端-实现上传和下载/</id>
    <published>2021-12-05T02:56:46.000Z</published>
    <updated>2021-12-05T04:06:54.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端"><a class="markdownIt-Anchor" href="#前端"></a> 前端</h1><h2 id="上传"><a class="markdownIt-Anchor" href="#上传"></a> 上传</h2><p>前端上传主要是把文件发送过去，一般采用表单的形式，或者也可以针对上传接口发送请求</p><ul><li>表单</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://127.0.0.1:5000/"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"toupdate"</span>/&gt;</span># file的input不允许设置value</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传咯"</span> /&gt;</span>      # 按钮显示的文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"># action为表单要提交到的路径, 必须填写，如果省略则默认当前页面</span><br></pre></td></tr></table></figure><ul><li>针对接口，发送网络请求</li></ul><h2 id="下载"><a class="markdownIt-Anchor" href="#下载"></a> 下载</h2><h3 id="a标签"><a class="markdownIt-Anchor" href="#a标签"></a> a标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>法一: 通过`a`标签来实现下载 <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:5000/download"</span>&gt;</span>ss<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外，HTML 5 里面为 <code>&lt;a&gt;</code> 标签添加了一个 <code>download</code> 的属性，我们可以轻易的利用它来实现下载重命名的功能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>法一: 通过`a`标签来实现下载 <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:5000/download"</span> <span class="attr">download</span>=<span class="string">"something.txt"</span>&gt;</span>ss<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="javascript"><a class="markdownIt-Anchor" href="#javascript"></a> JavaScript</h3><h4 id="添加a元素并点击"><a class="markdownIt-Anchor" href="#添加a元素并点击"></a> 添加a元素并点击</h4><p>用 JavaScript 来下载文件也是利用这一特性来实现的，我们的 JavaScript 代码不外乎就是：</p><ul><li>用 JavaScript 创建一个隐藏的 <code>&lt;a&gt;</code> 标签</li><li>设置它的 <code>href</code> 属性</li><li>设置它的 <code>download</code> 属性</li><li>用 JavaScript 来触发这个它的 <code>click</code> 事件</li></ul><p>翻译成 JavaScript 代码就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    downit()&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">        <span class="comment">// 已经知道下载链接</span></span><br><span class="line">        <span class="keyword">var</span> url = <span class="string">"http://127.0.0.1:5000/download"</span></span><br><span class="line">        <span class="keyword">var</span> filename = <span class="string">'what-you-want.txt'</span>;</span><br><span class="line">        a.href = url;</span><br><span class="line">        a.download = filename;</span><br><span class="line">        a.click();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fetch-blob"><a class="markdownIt-Anchor" href="#fetch-blob"></a> fetch + blob</h4><p>Blob 全称是 Binary large object，它表示一个类文件对象，可以用它来表示一个文件。根据 <a href="https://link.segmentfault.com/?enc=VjebWZdzKAs9tWBhcUlrkA%3D%3D.DafZfdpskf4%2Bt0pOrxaB0VaeWLs5jCpvfpnGscxz6HFF5viGq4H6%2BYROIgptJNW6PIjakO8ABb0PcnSyKwUkvA%3D%3D" target="_blank" rel="noopener">MDN</a> 上面的说法，<code>File API</code> 也是基于 blob 来实现的。<br>我们构建 blob 的方式就是通过服务器返回的文件来创建 blob 拉！而最简单的方式就是用 <code>fetch API</code> 了，我们可以整合上面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'http://somehost/somefile.zip'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.blob().then(<span class="function"><span class="params">blob</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">    <span class="keyword">var</span> filename = <span class="string">'myfile.zip'</span>;</span><br><span class="line">    a.href = url;</span><br><span class="line">    a.download = filename;</span><br><span class="line">    a.click();</span><br><span class="line">    <span class="built_in">window</span>.URL.revokeObjectURL(url);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>已知下载接口URL， 并传入相应的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downLoad</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 下载接口+请求参数</span></span><br><span class="line">    fetch(<span class="string">'http://somehost/download'</span>, options).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.code === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">            <span class="comment">// 得到请求文件完整的请求路径</span></span><br><span class="line">            <span class="keyword">var</span> url = res.data.url;</span><br><span class="line">            <span class="keyword">var</span> filename = <span class="string">'myfile.zip'</span>;</span><br><span class="line">            a.href = url;</span><br><span class="line">            a.download = filename;<span class="comment">// w3c: value: filename——规定被下载的超链接目标。从这边也可以看出其实就是指定文件名</span></span><br><span class="line">            a.click();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">'You have no permission to download the file!'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程为：通过后端服务器来计算出用户的下载链接，然后再利用之前提到的<strong>动态创建</strong> <code>&lt;a&gt;</code> 标签的方式来实现下载</p><p>跟: <a href="https://blog.csdn.net/weixin_41305441/article/details/85003066" target="_blank" rel="noopener">JS实现文件下载的三种方式—a标签下载、form表单下载、blob转换url下载</a>中的一样，也都是先计算出资源所在真实的URL位置，然后再请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downLoadFile</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ele = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">          ele.setAttribute(<span class="string">'href'</span>,res.url); <span class="comment">//设置下载文件的url地址</span></span><br><span class="line">          ele.setAttribute(<span class="string">'download'</span> , <span class="string">'download'</span>);<span class="comment">//用于设置下载文件的文件名</span></span><br><span class="line">          ele.click();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url:<span class="string">"get-file"</span>,</span><br><span class="line">        type:<span class="string">"get"</span>,</span><br><span class="line">        dataType:<span class="string">'JSON'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.bizNO &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            downLoadFile(res);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(res.bizMsg);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;).always(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"连接异常"</span>)；</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么要用-javascript-下载文件"><a class="markdownIt-Anchor" href="#为什么要用-javascript-下载文件"></a> 为什么要用 JavaScript 下载文件</h2><p>好拉，说了半天，其实我们一直说的都是：「不要用 JavaScript 下载文件拉，限制多多，又不好用，直接用 html 就好拉，简单方便又快捷」这个论调。事实上也确实如此，但有些时候我们确实需要通过 JavaScript 来做一些<strong>预</strong>处理， 如权限校验。</p><h3 id="下载文件前的权限校验"><a class="markdownIt-Anchor" href="#下载文件前的权限校验"></a> 下载文件前的权限校验</h3><p>有些时候，我们需要对下载做一些限制，最常见的就是权限校验了，如检查该用户是否有下载的权限，是否有高速下载的权限等等。这时候，我们可以利用 JavaScript 做一些预处理。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'http://somehost/check-permission'</span>, options).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.code === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">var</span> url = res.data.url;</span><br><span class="line">        <span class="keyword">var</span> filename = <span class="string">'myfile.zip'</span>;</span><br><span class="line">        </span><br><span class="line">        a.href = url;</span><br><span class="line">        a.download = filename;</span><br><span class="line">        a.click();</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//   const ele = document.createElement('a');</span></span><br><span class="line">       <span class="comment">//   ele.setAttribute('href',res.url); //设置下载文件的url地址</span></span><br><span class="line">       <span class="comment">//   ele.setAttribute('download' , 'download');//用于设置下载文件的文件名</span></span><br><span class="line">       <span class="comment">//   ele.click();</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'You have no permission to download the file!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://blog.csdn.net/weixin_41305441/article/details/85003066" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41305441/article/details/85003066</a></li><li><a href="https://segmentfault.com/a/1190000005863250" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005863250</a></li><li><a href="https://www.jianshu.com/p/8ef2c7b8b46c" target="_blank" rel="noopener">前端接受后端文件流并下载的几种方法</a></li></ul><h1 id="python-flask实现上传和下载接口"><a class="markdownIt-Anchor" href="#python-flask实现上传和下载接口"></a> Python Flask实现上传和下载接口</h1><h2 id="上传-2"><a class="markdownIt-Anchor" href="#上传-2"></a> 上传</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, url_for, send_from_directory</span><br><span class="line"><span class="keyword">from</span> werkzeug.utils <span class="keyword">import</span> secure_filename</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> send_from_directory, make_response</span><br><span class="line"><span class="comment"># 设置上传文件允许种类</span></span><br><span class="line">ALLOWED_EXTENSIONS = &#123;<span class="string">'png'</span>, <span class="string">'jpg'</span>, <span class="string">'jpeg'</span>, <span class="string">'gif'</span>&#125;</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 设置上传路径</span></span><br><span class="line">app.config[<span class="string">'UPLOAD_FOLDER'</span>] = os.path.join(os.getcwd(), <span class="string">"updates"</span>)</span><br><span class="line"><span class="comment"># 设置上传文件最大大小</span></span><br><span class="line">app.config[<span class="string">'MAX_CONTENT_LENGTH'</span>] = <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">    &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Upload File&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Photo Upload&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;form method=post enctype=multipart/form-data&gt;</span></span><br><span class="line"><span class="string">         &lt;input type=file name=file&gt;</span></span><br><span class="line"><span class="string">         &lt;input type=submit value=upload&gt;</span></span><br><span class="line"><span class="string">    &lt;/form&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;a href='http://127.0.0.1:5000/download'&gt;&lt;p&gt;下载&lt;/p&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allowed_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    是否是允许上传的文件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'.'</span> <span class="keyword">in</span> filename <span class="keyword">and</span> \</span><br><span class="line">           filename.rsplit(<span class="string">'.'</span>, <span class="number">1</span>)[<span class="number">1</span>] <span class="keyword">in</span> ALLOWED_EXTENSIONS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/uploads/&lt;filename&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uploaded_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获得上传后的链接</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> send_from_directory(app.config[<span class="string">'UPLOAD_FOLDER'</span>],</span><br><span class="line">                               filename)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        file = request.files[<span class="string">'file'</span>]<span class="comment"># 可以通过requests.files属性拿到multipart/form-data上传的数据</span></span><br><span class="line">        <span class="keyword">if</span> file <span class="keyword">and</span> allowed_file(file.filename):</span><br><span class="line">            filename = secure_filename(file.filename)</span><br><span class="line">            <span class="comment"># 保存文件</span></span><br><span class="line">            file.save(os.path.join(app.config[<span class="string">'UPLOAD_FOLDER'</span>], filename))</span><br><span class="line">            <span class="comment"># 获得保存后的图片链接</span></span><br><span class="line">            file_url = url_for(<span class="string">'uploaded_file'</span>, filename=filename)</span><br><span class="line">            print(file_url)</span><br><span class="line">            <span class="keyword">return</span> html + <span class="string">'&lt;br&gt;&lt;img src='</span> + file_url + <span class="string">'&gt;'</span></span><br><span class="line">    <span class="keyword">return</span> html</span><br></pre></td></tr></table></figure><h2 id="下载-2"><a class="markdownIt-Anchor" href="#下载-2"></a> 下载</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route("/download")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 可以看到上传代码中也用到了send_from_directory；这边的区别主要是添加了as_attachment参数, 使得可以下载</span></span><br><span class="line">    <span class="comment"># return make_response(send_from_directory("./", "test.txt", as_attachment=True))</span></span><br><span class="line">    <span class="keyword">return</span> send_from_directory(<span class="string">"./"</span>, <span class="string">"./"</span>, filename=<span class="string">"test.txt"</span>, as_attachment=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><h1 id="java实现上传下载"><a class="markdownIt-Anchor" href="#java实现上传下载"></a> Java实现上传下载</h1><h2 id="上传-3"><a class="markdownIt-Anchor" href="#上传-3"></a> 上传</h2><p>application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 用来指定服务器端文件大小的限制</span><br><span class="line">spring.servlet.multipart.max-file-size=300MB</span><br><span class="line"># 用来指定客户端文件大小的限制</span><br><span class="line">spring.servlet.multipart.max-request-size=300MB</span><br><span class="line"></span><br><span class="line">fileLocation=static/files</span><br></pre></td></tr></table></figure><p>FileUploadController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取配置文件中的路径 static/files</span></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;fileLocation&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String fileLocation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"upload"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获得 classpath 的绝对路径</span></span><br><span class="line">    String realPath = ResourceUtils.getURL(<span class="string">"classpath:"</span>).getPath() + fileLocation;</span><br><span class="line">    File newFile = <span class="keyword">new</span> File(realPath);</span><br><span class="line">    <span class="comment">// 如果文件夹不存在、则新建</span></span><br><span class="line">    <span class="keyword">if</span> (!newFile.exists()) newFile.mkdirs();</span><br><span class="line">     <span class="comment">// 上传</span></span><br><span class="line">    String fileName = date.getTime() +<span class="string">"@"</span> + file.getOriginalFilename();</span><br><span class="line">    file.transferTo(<span class="keyword">new</span> File(newFile, fileName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下载-3"><a class="markdownIt-Anchor" href="#下载-3"></a> 下载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;fileLocation&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String fileLocation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"download"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String fileName, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获得待下载文件所在文件夹的绝对路径</span></span><br><span class="line">    String realPath = ResourceUtils.getURL(<span class="string">"classpath:"</span>).getPath() + fileLocation;</span><br><span class="line">    <span class="comment">// 获得文件输入流</span></span><br><span class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(realPath, fileName));</span><br><span class="line">    <span class="comment">// 设置响应头、以附件形式打开文件</span></span><br><span class="line">    response.setHeader(<span class="string">"content-disposition"</span>, <span class="string">"attachment; fileName="</span> + fileName);</span><br><span class="line">    ServletOutputStream outputStream = response.getOutputStream();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        outputStream.write(data, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    outputStream.close();</span><br><span class="line">    inputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前端&quot;&gt;&lt;/a&gt; 前端&lt;/h1&gt;
&lt;h2 id=&quot;上传&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#上传&quot;&gt;&lt;/a&gt; 上传&lt;/h2&gt;
&lt;p&gt;前端上传主要是
      
    
    </summary>
    
    
      <category term="后端" scheme="https://nymrli.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="前端" scheme="https://nymrli.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
