<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>果粒橙的博客</title>
  
  <subtitle>别装作很努力，因为结局不会陪你演戏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nymrli.top/"/>
  <updated>2018-10-24T10:53:11.813Z</updated>
  <id>https://nymrli.top/</id>
  
  <author>
    <name>果粒橙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sublime Text3 Python虚拟环境（补充）——解决控制台中文乱码情况</title>
    <link href="https://nymrli.top/2018/10/24/Sublime-Text3-Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E6%83%85%E5%86%B5/"/>
    <id>https://nymrli.top/2018/10/24/Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况/</id>
    <published>2018-10-24T10:52:35.000Z</published>
    <updated>2018-10-24T10:53:11.813Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://www.cnblogs.com/guiyuhua/p/8627091.html" target="_blank" rel="noopener">edwardgui的博客</a></p><blockquote><p>正常的用python编译控制台是不会出现乱码的，但是在使用虚拟环境的情况下中文总是乱码，一开始以为是windows控制台编码的问题。找了挺久后发现是python+virtualenv编译系统的问题，现在我就带领大家解决这个问题。</p></blockquote><h5 id="▲注：Windows环境下"><a href="#▲注：Windows环境下" class="headerlink" title="▲注：Windows环境下"></a>▲注：Windows环境下</h5><ul><li>首先看下是否已经安装了Virtualenv package插件，如果没有，则Ctrl+Shift+P，install Package,输入Virtualenv安装。</li><li>找到插件安装的地方：C:\Users{Username}\AppData\Roaming\Sublime Text 3\Installed Packages ==&gt;注意改变一下Username</li><li>解压Virtualenv.sublime-package文件，可以通过先添加后缀.zip变为Virtualenv.sublime-package.zip再解压</li></ul><p>包含文件如下：<br><img src="https://images2018.cnblogs.com/blog/1350574/201808/1350574-20180827155724022-2032122286.jpg" alt=""><br>修改Python + Virtualenv.sublime-build文件， 增加一行：<code>&quot;env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf8&quot;},</code><br>使其变成<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"env"</span>: &#123;<span class="attr">"PYTHONIOENCODING"</span>: <span class="string">"utf8"</span>&#125;,</span><br><span class="line"><span class="attr">"target"</span>: <span class="string">"virtualenv_exec"</span>,</span><br><span class="line"><span class="attr">"shell_cmd"</span>: <span class="string">"python -u \"$file\""</span>,</span><br><span class="line"><span class="attr">"file_regex"</span>: <span class="string">"^[ ]*File \"(...*?)\", line ([0-9]*)"</span>,</span><br><span class="line"><span class="attr">"selector"</span>: <span class="string">"source.python"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后保存，再把该文件打包为Virtualenv.sublime-package.zip再去掉后缀，就大功告成了。</p><hr><p>最后打开Sublime Text3使用Python + Virtualenv 编译，就能看到中文正常输出啦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：&lt;a href=&quot;https://www.cnblogs.com/guiyuhua/p/8627091.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;edwardgui的博客&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正常的用pyth
      
    
    </summary>
    
    
      <category term="Sublime Text" scheme="https://nymrli.top/tags/Sublime-Text/"/>
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——将Cookie保存到本地的多种方法介绍</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E5%B0%86Cookie%E4%BF%9D%E5%AD%98%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/</id>
    <published>2018-10-24T10:43:34.000Z</published>
    <updated>2018-10-24T10:45:29.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法一：urllib2"><a href="#方法一：urllib2" class="headerlink" title="方法一：urllib2"></a>方法一：urllib2</h3><blockquote><p>结合cookielib及urllib2，Python2时期比较常用的方法，年代比较久远了。个人觉得太麻烦，改用requests.</p><p><strong>▲需要注意的是cookielib在python3中已经改成了http.cookiejar</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#该方法本人未测试</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> cookielib</span><br><span class="line"></span><br><span class="line"><span class="comment">#将cookie保存在文件中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveCookie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#设置保存cookie的文件</span></span><br><span class="line">    filename = <span class="string">'cookie.txt'</span></span><br><span class="line">    <span class="comment">#声明一个MozillaCookieJar对象来保存cookie，之后写入文件</span></span><br><span class="line">    cookie = cookielib.MozillaCookieJar(filename)</span><br><span class="line">    <span class="comment">#创建cookie处理器</span></span><br><span class="line">    handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class="line">    <span class="comment">#构建opener</span></span><br><span class="line">    opener = urllib2.build_opener(handler)</span><br><span class="line">    <span class="comment">#创建请求</span></span><br><span class="line">    res = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">    <span class="comment">#保存cookie到文件</span></span><br><span class="line">    <span class="comment">#ignore_discard的意思是即使cookies将被丢弃也将它保存下来</span></span><br><span class="line">    <span class="comment">#ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入</span></span><br><span class="line">    cookie.save(ignore_discard=<span class="keyword">True</span>,ignore_expires=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#从文件中获取cookie并且访问(我们通过这个方法就可以打开保存在本地的cookie来模拟登录)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCookie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#创建一个MozillaCookieJar对象</span></span><br><span class="line">    cookie = cookielib.MozillaCookieJar()</span><br><span class="line">    <span class="comment">#从文件中的读取cookie内容到变量</span></span><br><span class="line">    cookie.load(<span class="string">'cookie.txt'</span>,ignore_discard=<span class="keyword">True</span>,ignore_expires=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment">#打印cookie内容,证明获取cookie成功</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'name:'</span> + item.name + <span class="string">'-value:'</span> + item.value</span><br><span class="line">    <span class="comment">#利用获取到的cookie创建一个opener</span></span><br><span class="line">    handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class="line">    opener = urllib2.build_opener(handler)</span><br><span class="line">    res = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">    <span class="keyword">print</span> res.read()</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h3><blockquote><p>使用requests.cookie</p></blockquote><h5 id="读取cookies"><a href="#读取cookies" class="headerlink" title="读取cookies"></a>读取cookies</h5><p>在这里我用的是LWPCookieJar保存在txt文件中，还有个是MozillaCookieJar，都是由FileCookieJar 派生而来，实现了save()方法，而FileCookieJar 没有实现save()</p><blockquote><ul><li>MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。</li><li>LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。</li></ul></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#实例化一个LWPCookieJar对象</span><br><span class="line">load_cookiejar = cookielib.LWPCookieJar()</span><br><span class="line">#从文件中加载cookies(LWP格式)</span><br><span class="line"></span><br><span class="line">load_cookiejar.load(<span class="string">'cookies.txt'</span>, ignore_discard=True, ignore_expires=True)</span><br><span class="line">#工具方法转换成字典</span><br><span class="line">load_cookies = requests<span class="selector-class">.utils</span><span class="selector-class">.dict_from_cookiejar</span>(load_cookiejar)</span><br><span class="line">#工具方法将字典转换成RequestsCookieJar，赋值给session的cookies.</span><br><span class="line">self<span class="selector-class">.session</span><span class="selector-class">.cookies</span> = requests<span class="selector-class">.utils</span><span class="selector-class">.cookiejar_from_dict</span>(load_cookies)</span><br></pre></td></tr></table></figure><h5 id="存储cookies"><a href="#存储cookies" class="headerlink" title="存储cookies"></a>存储cookies</h5><p>将cookies转换成LWP格式然后保存为文本格式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#实例化一个LWPcookiejar对象</span><br><span class="line">new_cookie_jar = cookielib.LWPCookieJar(<span class="string">'cookie.txt'</span>)</span><br><span class="line"></span><br><span class="line">#将转换成字典格式的RequestsCookieJar（这里我用字典推导手动转的）保存到LWPcookiejar中</span><br><span class="line">===&gt;RequestsCookieJar没有实现save()方法</span><br><span class="line">requests<span class="selector-class">.utils</span><span class="selector-class">.cookiejar_from_dict</span>(&#123;c<span class="selector-class">.name</span>: c<span class="selector-class">.value</span> <span class="keyword">for</span> c <span class="keyword">in</span> self<span class="selector-class">.session</span><span class="selector-class">.cookies</span>&#125;, new_cookie_jar)</span><br><span class="line"></span><br><span class="line">#保存到本地文件</span><br><span class="line">new_cookie_jar.save(<span class="string">'cookies.txt'</span>, ignore_discard=True, ignore_expires=True)</span><br></pre></td></tr></table></figure><p><img src="/2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/Users\10630\Desktop\Txt\爬虫知识点\cookie3.jpg" alt="cookie3"></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h3><blockquote><p>将cookie字典弄成字典形式然后pickle或者json写入文件中</p></blockquote><h5 id="存储cookie"><a href="#存储cookie" class="headerlink" title="存储cookie"></a>存储cookie</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,json,pprint</span><br><span class="line">s = requests.session()</span><br><span class="line">s.headers = <span class="meta">&#123;...&#125;</span></span><br><span class="line">a = s.get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">cookies = requests.utils.dict_from_cookiejar(s.cookies)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">".\\cook.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    json.dump(cookies, fp)</span><br><span class="line">pprint.pprint(cookies,width=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h5 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(<span class="string">".\cook.txt"</span>, <span class="string">"w"</span>) as fp:</span><br><span class="line">    load_cookies=son.load(fp)</span><br><span class="line">session<span class="selector-class">.cookie</span> = requests<span class="selector-class">.utils</span><span class="selector-class">.cookiejar_from_dict</span>(load_cookies)</span><br></pre></td></tr></table></figure><p>方法四:</p><blockquote><p>将requests.cookie设置为LWPCookieJar、或MozillaCookieJar保存</p></blockquote><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session</span> = requests.Session()</span><br><span class="line"><span class="comment">#创建个 LWPCookieJar对象</span></span><br><span class="line">session.<span class="attr">cookies</span> = LWPCookieJar(<span class="attr">filename='cook.txt')</span></span><br><span class="line">s.get('https://www.baidu.com/',<span class="attr">headers=headers)</span></span><br><span class="line">session.cookies.save(<span class="attr">ignore_discard=True,</span> <span class="attr">ignore_expires=True)</span></span><br><span class="line"><span class="comment">#如果save()时没有写filename参数，则默认为实例化LWPCookieJar时给的文件名</span></span><br></pre></td></tr></table></figure><p><img src="/2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/Users\10630\Desktop\Txt\爬虫知识点\cookie4.jpg" alt="cookie4"></p><hr><h4 id="save-方法的两个重要参数"><a href="#save-方法的两个重要参数" class="headerlink" title="save()方法的两个重要参数"></a>save()方法的两个重要参数</h4><blockquote><ul><li>ignore_discard: save even cookies set to be discarded.</li><li>ignore_expires: save even cookies that have expired.The file is overwritten if it already exists</li></ul></blockquote><p><code>ignore_discard的意思是即使cookies将被丢弃也将它保存下来，ignore_expires的意思是如果cookies已经过期也将它保存并且文件已存在时将覆盖</code></p><p>总结方法二和方法三可以看出，就是要将cookie转换成然后save()</p><hr><p>简单介绍下<strong>cookielib模块</strong>作用，科普下实现cookie知识</p><blockquote><p>python3中将cookielib模块改为了http.cookiejar</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">   cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。例如可以利用本模块 的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送。coiokielib模块用到的对象主要有下面几个：CookieJar、 FileCookieJar、MozillaCookieJar、LWPCookieJar。其中他们的关系如下：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                     CookieJar                       </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                         | </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">      FileCookieJar      </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">          /                   \    </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p> MozillaCookieJar          LWPCookieJar            </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;方法一：urllib2&quot;&gt;&lt;a href=&quot;#方法一：urllib2&quot; class=&quot;headerlink&quot; title=&quot;方法一：urllib2&quot;&gt;&lt;/a&gt;方法一：urllib2&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;结合cookielib及urllib2，P
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——Session与Cookie</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94Session%E4%B8%8ECookie/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——Session与Cookie/</id>
    <published>2018-10-24T10:36:56.000Z</published>
    <updated>2018-10-24T10:41:34.630Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Session和Cookie："><a href="#Session和Cookie：" class="headerlink" title="Session和Cookie："></a>Session和Cookie：</h4><blockquote><p>Cookie：保持登录后的认证状态而保存在本地的数据</p><p>session:用cookie来标记用户，cookie携带了会话ID消息，通过检查cookie就能找到会话(session)</p></blockquote><p>cookie与session相互配合，一个处于客户端，一个处于服务端，两者相互协作。</p><h5 id="会话cookie和持久cookie"><a href="#会话cookie和持久cookie" class="headerlink" title="会话cookie和持久cookie"></a>会话cookie和持久cookie</h5><blockquote><p>会话Cookie：把cookie放在浏览器内存里，浏览器关闭后失效。</p><p>持久Cookie：保存cookie到客户端的硬盘中，下次继续使用。</p></blockquote><p>由Cookie的Max Age和Expires决定了过期的时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Session和Cookie：&quot;&gt;&lt;a href=&quot;#Session和Cookie：&quot; class=&quot;headerlink&quot; title=&quot;Session和Cookie：&quot;&gt;&lt;/a&gt;Session和Cookie：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Cooki
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——代理</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——代理/</id>
    <published>2018-10-24T10:36:28.000Z</published>
    <updated>2018-10-24T10:41:27.406Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h6 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h6><p>代理实际上指代理服务器。功能是代理 网络用户去取得网络信息，是网络信息的中转站。</p><p>正常的请求过程为：发送请求给服务器===&gt;web服务器吧响应传回</p><p>设置代理服务器后：==&gt;向代理服务器发送请求==&gt;请求发送给代理服务器==&gt;再由代理服务器发送web服务器==&gt;由代理服务器把web服务器返回的响应转发给本机</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>突破自身IP访问限制，访问些平时不能访问的站点。</p><p>访问一些单位或团体内部资源:比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</p><p>提高访问速度:通常代理服务器都设置-一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息传给用户，以提高访问速度。</p><p>隐藏真实IP:上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP,防止自身的IP被封锁。 </p><h3 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h3><h5 id="根据代理的协议，代理可以分为如下类别。"><a href="#根据代理的协议，代理可以分为如下类别。" class="headerlink" title="根据代理的协议，代理可以分为如下类别。"></a>根据代理的协议，代理可以分为如下类别。</h5><ul><li>FTP代理服务器:  主要用于访问FTP服务器，一般有上传、 下载以及缓存功能，端口一般为   21、2121等。   </li><li>HTTP代理服务器:主要用于访问网页，一般有内容过滤和缓存功能，端口一般为808080、3128 等。 </li><li>SSL/TLS代理:主要用于访同加密网站，般有 SsL 或TLS 加密功能(最高支持128位加密强度)，端口一般为443。</li><li>RTSP代理:主要用于访问Real流媒体服务器，一般有缓存功能， 端口般为554。   </li><li>Telnet代理: 主要用于tenei远程控制黑客人侵计算机时常用于隐藏身份)，端口一般为23</li><li>POP3/SMTP代理:主要用于POP3/SMTP方式收发邮件，一般有缓存功能，端口-般为1025.口SOCKS代理:只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般 有   存功能，端口一般为1080。SOCKS代理协议又分为SOCKS4和SOCKS5,前者只支持TCP而后者支持TCP和UDP，还支持各种身份验证机制、服务器端域名解析等。简单来说SOCKS4能做到的SOCKS5都可以做到，但SOCKSS能做到的SOCKS4不一定能做到。</li></ul><h5 id="2-根据匿名程度区分-根据代理的匿名程度，代理可以分为如下类别。"><a href="#2-根据匿名程度区分-根据代理的匿名程度，代理可以分为如下类别。" class="headerlink" title="2.根据匿名程度区分   根据代理的匿名程度，代理可以分为如下类别。"></a>2.根据匿名程度区分   根据代理的匿名程度，代理可以分为如下类别。</h5><ul><li><p>高度匿名代理：会将数据包原封不动地转发，在服务端看来就好像真的是一 个普通客户端访问，而记录的IP是代理服务器的IP。</p></li><li><p>普通匿名代理：会在数据包上做一些改动， 服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实IP。代理服务器通常会加人的HTTP头有HTTP_VIA和HTTP_X_FORWARDED_FOR.</p></li><li><p>透明代理：不但改动了数据包，还会告诉服务器客户端的真实IP。这种代理除了能用缓存技术调高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。</p></li><li><p>间谍代理：指组织或个人创建的用于记录用户传输的数据， 然后进行研究、监控等目的代理服务器。</p><p>常用代理设置</p></li><li><p>网上的免费代理</p></li><li><p>付费的代理服务</p></li><li><p>ADSL拨号</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;代理&quot;&gt;&lt;a href=&quot;#代理&quot; class=&quot;headerlink&quot; title=&quot;代理&quot;&gt;&lt;/a&gt;代理&lt;/h4&gt;&lt;h6 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——请求</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——请求/</id>
    <published>2018-10-24T10:36:21.000Z</published>
    <updated>2018-10-24T10:40:33.145Z</updated>
    
    <content type="html"><![CDATA[<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><blockquote><p>:请求方法、请求网址、请求头、请求体</p></blockquote><h5 id="请求方法："><a href="#请求方法：" class="headerlink" title="请求方法："></a>请求方法：</h5><blockquote><p>常见的为:GET、POST</p><p>GET与POST主要区别：</p><ul><li>GET请求参数包含在URL，可从URL中看出。POST请求的URL不包含参数，都是通过表单的形式传输的，包含在请求体中</li><li>GET请求提交的数据最多只有1024字节，POST无限制</li></ul></blockquote><p>其他还有HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE</p><h5 id="请求的网址："><a href="#请求的网址：" class="headerlink" title="请求的网址："></a>请求的网址：</h5><blockquote><p>即URL，我们想要请求的资源</p></blockquote><h5 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h5><p>用来说明服务器要使用的附加信息，比较总要的有Cookie、Referer、User-Agent等。</p><blockquote><p>Accept:请求报头域，用于指定客户端可接受哪些类型的信息。   </p><p>Accept-Language:指定客户端可接受的语言类型。</p><p>Accept-Encoding:指定客户端可接受的内容编码。   </p><p> Host:用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位   置。从HTTP1.1版本开始，请求必须包含此内容。  </p><p>Cookie:也常用复数形式Cookies, 是网站为了<u>辨别用户进行会话跟踪</u>而存储在用户<strong>本地</strong>的数据。它的主要功能是维持当前访问会话。例如，我们输人用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies 并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。   </p><p>Referer:此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、<u>防盗链处理</u>等。   </p><p>User-Agent: 简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等消息。在做爬虫时加上此信息，可以伪装成浏览器；如果不加，很可能被识别出为爬虫</p><p>Content-Type:也叫互联网媒体类型( Intermet Media Type)或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。更多对应关系可以查看此对表:<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a></p></blockquote><table><thead><tr><th>文件扩展名</th><th>Content-Type(Mime-Type)</th></tr></thead><tbody><tr><td>.html、 .htx 、 .htm</td><td>text/html</td></tr><tr><td>.gif</td><td>image/gif</td></tr><tr><td>.json</td><td>application/json</td></tr></tbody></table><p>​                    <strong>Content-Type与POST提交数据方式的关系</strong></p><table><thead><tr><th>Content-Type</th><th>提交数据的方式</th></tr></thead><tbody><tr><td>appication/x-www-urlencodeed</td><td>表单数据</td></tr><tr><td>multipart/form-data</td><td>表单文件上传</td></tr><tr><td>applicatiobn/json</td><td>序列化json数据</td></tr><tr><td>text/html</td><td>XML数据</td></tr></tbody></table><blockquote><p>如果构造POST请求，需要使用正确的Content-Type，不然可能导致POST提交后无法正常响应</p></blockquote><p>==&gt;因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p><h5 id="请求体："><a href="#请求体：" class="headerlink" title="请求体："></a>请求体：</h5><blockquote><p>请求体一般承载的内容是POST请求中的表单数据，而对GET请求，请求体则为空。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;请求&quot;&gt;&lt;a href=&quot;#请求&quot; class=&quot;headerlink&quot; title=&quot;请求&quot;&gt;&lt;/a&gt;请求&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;:请求方法、请求网址、请求头、请求体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;请求方法：&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——响应</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E5%93%8D%E5%BA%94/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——响应/</id>
    <published>2018-10-24T10:36:17.000Z</published>
    <updated>2018-10-24T10:42:19.208Z</updated>
    
    <content type="html"><![CDATA[<h4 id="响应："><a href="#响应：" class="headerlink" title="响应："></a>响应：</h4><p>响应状态码、响应头、响应体</p><h5 id="响应状态码："><a href="#响应状态码：" class="headerlink" title="响应状态码："></a>响应状态码：</h5><pre><code>表2-3常见的错误代码及错误原因</code></pre><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</td></tr><tr><td>101</td><td>切换协议</td><td>请求者已要求服务器切换协议，服务器已确认并准备切换。</td></tr><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</td></tr><tr><td>201</td><td>已创建</td><td>请求成功并且服务器创建了新的资源。</td></tr><tr><td>202</td><td>已接受</td><td>服务器已接受请求，但尚未处理。</td></tr><tr><td>203</td><td>非授权信息</td><td>服务器已成功处理了请求，但返回的信息可能来自另一来源。</td></tr><tr><td>204</td><td>无内容</td><td>服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td>205</td><td>重置内容</td><td>服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td>206</td><td>部分内容</td><td>服务器成功处理了部分 GET 请求。</td></tr><tr><td>300</td><td>多种选择</td><td>针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</td></tr><tr><td>301</td><td>永久移动</td><td>请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td></tr><tr><td>302</td><td>临时移动</td><td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td>303</td><td>查看其他位置</td><td>请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td></tr><tr><td>304</td><td>未修改</td><td>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</td></tr><tr><td>305</td><td>使用代理</td><td>请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</td></tr><tr><td>307</td><td>临时重定向</td><td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td>400</td><td>错误请求</td><td>服务器不理解请求的语法。</td></tr><tr><td>401</td><td>未授权</td><td>请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</td></tr><tr><td>403</td><td>禁止</td><td>服务器拒绝请求。</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的网页。</td></tr><tr><td>405</td><td>方法禁用</td><td>禁用请求中指定的方法。</td></tr><tr><td>406</td><td>不接受</td><td>无法使用请求的内容特性响应请求的网页。</td></tr><tr><td>407</td><td>需要代理授权</td><td>此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td></tr><tr><td>408</td><td>请求超时</td><td>服务器等候请求时发生超时。</td></tr><tr><td>409</td><td>冲突</td><td>服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。</td></tr><tr><td>410</td><td>已删除</td><td>如果请求的资源已永久删除，服务器就会返回此响应。</td></tr><tr><td>411</td><td>需要有效长度</td><td>服务器不接受不含有效内容长度标头字段的请求。</td></tr><tr><td>412</td><td>未满足前提条件</td><td>服务器未满足请求者在请求中设置的其中一个前提条件。</td></tr><tr><td>413</td><td>请求实体过大</td><td>服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</td></tr><tr><td>414</td><td>请求的 URI 过长</td><td>请求的 URI（通常为网址）过长，服务器无法处理。</td></tr><tr><td>415</td><td>不支持的媒体类型</td><td>请求的格式不受请求页面的支持。</td></tr><tr><td>416</td><td>请求范围不符合要求</td><td>如果页面无法提供请求的范围，则服务器会返回此状态代码。</td></tr><tr><td>417</td><td>未满足期望值</td><td>服务器未满足”期望”请求标头字段的要求。</td></tr><tr><td>500</td><td>服务器内部错误</td><td>服务器遇到错误，无法完成请求。</td></tr><tr><td>501</td><td>尚未实施</td><td>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理，从上游服务器收到无效响应。</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</td></tr><tr><td>504</td><td>网关超时</td><td>服务器作为网关或代理，但是没有及时从上游服务器收到请求。</td></tr><tr><td>505</td><td>HTTP 版本不受支持</td><td>服务器不支持请求中所用的 HTTP 协议版本。</td></tr></tbody></table><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><p> 响应头包含了服务器对请求的应答信息，如Cmene-Type. Serve. Set-cookie等。 下面简要说有 一些常用的头信息。 </p><ul><li>Date:标识响应产生的时间。 </li><li>Last-Modifed:指定资源的最后修改时间。 公有地会 </li><li>Content-Encoding:指定响应内容的编码。 </li><li>Server:包含服务器的信息，比如名称、版本号等。 </li><li>Content-Type:文档类型，指定返回的数据类型是什么，如texthtmI代表返回HTML文档， application/x-javascript则代表返回JavaScript文件，imagefjpeg 则代表返回图片。</li><li>Set-Cookie:设置Cookies。 响应头中的Set-Cookie 告诉浏览器需要将此内容放在Cooke 中，下次请求携带Cookies请求。</li><li>Expires:指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。立 果再次访问时，就可以直接从缓存中加载，降低服务器负载，编短加载时间。</li></ul><h5 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h5><p>最重要的当属响应体的内容了。 响应的正文数据都在响应体中，比如请求网页时，它的响应体就 是网页的HTML代码:请求一张图片时， 它的响应体就是图片的二进制数据。我们做爬虫请求后主 要解析的内容就是响应体。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;响应：&quot;&gt;&lt;a href=&quot;#响应：&quot; class=&quot;headerlink&quot; title=&quot;响应：&quot;&gt;&lt;/a&gt;响应：&lt;/h4&gt;&lt;p&gt;响应状态码、响应头、响应体&lt;/p&gt;
&lt;h5 id=&quot;响应状态码：&quot;&gt;&lt;a href=&quot;#响应状态码：&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——爬虫的基本原理</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——爬虫的基本原理/</id>
    <published>2018-10-24T10:36:10.000Z</published>
    <updated>2018-10-24T10:42:36.885Z</updated>
    
    <content type="html"><![CDATA[<h4 id="爬虫的基本原理"><a href="#爬虫的基本原理" class="headerlink" title="爬虫的基本原理"></a>爬虫的基本原理</h4><blockquote><p>爬虫就是<u>获取网页</u>并<u>提取</u>和<u>保存信息</u>的<u>自动化程序</u></p></blockquote><h5 id="获取网页："><a href="#获取网页：" class="headerlink" title="获取网页："></a>获取网页：</h5><p>获取网页就是获取网页的源码，只要把源码获取下来，就可以从中提取想要的消息</p><blockquote><p>爬虫的流程：想网站的服务器发送一个请求，返回的响应体就是网页的源代码。</p><p>​    ==&gt;1,构造请求发送给服务器===&gt;2.接受响应并解析</p></blockquote><h5 id="提取信息："><a href="#提取信息：" class="headerlink" title="提取信息："></a>提取信息：</h5><p>通过分析网页结构，提取网页信息。通常使用的解析库有:BeautifulSoup、lxml、pyquery，也可以使用正则，但是构造正则表达式比较复杂且易错</p><h5 id="保存数据："><a href="#保存数据：" class="headerlink" title="保存数据："></a>保存数据：</h5><p>将提取的数据保存到某处以便后续利用。保存形式有：TXT、Json、数据库：MySQL、MongoDB、或远程服务器SFTP…</p><h5 id="自动化程序"><a href="#自动化程序" class="headerlink" title="自动化程序"></a>自动化程序</h5><p>替人完成完成爬取工作的自动化程序，可以在抓取过程中进行异常处理……保证爬取的高效运行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;爬虫的基本原理&quot;&gt;&lt;a href=&quot;#爬虫的基本原理&quot; class=&quot;headerlink&quot; title=&quot;爬虫的基本原理&quot;&gt;&lt;/a&gt;爬虫的基本原理&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;爬虫就是&lt;u&gt;获取网页&lt;/u&gt;并&lt;u&gt;提取&lt;/u&gt;和&lt;u&gt;保存信息&lt;/u&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——URL与URI</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94URL%E4%B8%8EURI/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——URL与URI/</id>
    <published>2018-10-24T10:35:53.000Z</published>
    <updated>2018-10-24T10:41:12.634Z</updated>
    
    <content type="html"><![CDATA[<h4 id="URL与URI"><a href="#URL与URI" class="headerlink" title="URL与URI"></a>URL与URI</h4><ul><li><p>URL全称：Uniform Resource Locator(统一资源定位符)</p></li><li><p>URI全称：Uniform Resource Identifier(统一资源标识符)</p><p>如<a href="https://github.com/favicon.ico为例，它既是一个URL又是一个URI。我们通过URL/URI唯一指定了它的访问方式。其中包括访问协议https、访问路径、资源名称favicon.ico。通过这个链接提供的消息，我们就可以直接访问到此资源所在的位置。这便是URL、URI的作用。" target="_blank" rel="noopener">https://github.com/favicon.ico为例，它既是一个URL又是一个URI。我们通过URL/URI唯一指定了它的访问方式。其中包括访问协议https、访问路径、资源名称favicon.ico。通过这个链接提供的消息，我们就可以直接访问到此资源所在的位置。这便是URL、URI的作用。</a></p><blockquote><p>URL是URI的子集。===&gt;每个URL都是URI，但不是每个URI都是URL。</p><p>URI包括两个子类:URN和URL。其中URN只命名资源但不指定如何定位资源(如urn:isbn:0451450523)指定了一本书的ISBN，可以唯一标识，但未定位。</p><p>▲.目前互联网中URN用得很少，几乎所有的URI都是URL。</p></blockquote></li></ul><p><img src="/2018/10/24/Python爬虫知识点——URL与URI/URL_URI_URN.jpg" alt="URL_URI_URN"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;URL与URI&quot;&gt;&lt;a href=&quot;#URL与URI&quot; class=&quot;headerlink&quot; title=&quot;URL与URI&quot;&gt;&lt;/a&gt;URL与URI&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;URL全称：Uniform Resource Locator(统一资源定位符)&lt;/
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——Chrome开发者工具Network</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7Network/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——Chrome开发者工具Network/</id>
    <published>2018-10-24T10:35:31.000Z</published>
    <updated>2018-10-24T10:38:09.294Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Chrome开发者工具中Network功能介绍"><a href="#Chrome开发者工具中Network功能介绍" class="headerlink" title="Chrome开发者工具中Network功能介绍"></a>Chrome开发者工具中Network功能介绍</h4><ul><li>第一列Name:请求的名称，一般会将URL的最后一 部分内容当作名称。  </li><li>第二列Status: 响应的状态码，这里显示为200，代表响应是正常的。通过状态码，我们可   以判断发送了请求之后是否得到了正常的响应。   </li><li>第三列Type: 请求的文档类型。这里为document, 代表我们这次请求的是一个HTML文档,内容就是一些HTML代码。  </li><li>第四列initiator: 请求源。用来标记请求是由哪个对象或进程发起的。   </li><li>第五列Size: 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示from cache。</li><li>第六列Time:发起请求到获取响应所用的总时间。</li><li>第七列Waterfall:网络请求的可视化瀑布流。  </li></ul><p>响应中分General部分，请求头、响应头：</p><blockquote><p>其中General含：</p><ul><li>Request URL为请求的URL，</li><li>Request Method为请求的方法</li><li>Status Code为响应状态码，</li><li>Remote Address为远程服务器的地址和端口</li><li>Referrer Policy为Referrer判别策略。</li></ul></blockquote><p><img src="/2018/10/24/Python爬虫知识点——Chrome开发者工具Network/Chrome.jpg" alt="Chrome"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Chrome开发者工具中Network功能介绍&quot;&gt;&lt;a href=&quot;#Chrome开发者工具中Network功能介绍&quot; class=&quot;headerlink&quot; title=&quot;Chrome开发者工具中Network功能介绍&quot;&gt;&lt;/a&gt;Chrome开发者工具中Netwo
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>XShell通过SSH远程连接云服务器通过SSH远程连接云服务器</title>
    <link href="https://nymrli.top/2018/10/24/XShell%E9%80%9A%E8%BF%87SSH%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://nymrli.top/2018/10/24/XShell通过SSH远程连接云服务器/</id>
    <published>2018-10-24T10:32:05.000Z</published>
    <updated>2018-10-24T10:33:38.150Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-账号密码登录"><a href="#1-账号密码登录" class="headerlink" title="1.账号密码登录"></a>1.账号密码登录</h3><h5 id="法一"><a href="#法一" class="headerlink" title="法一:"></a>法一:</h5><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/1.jpg" alt="1"></p><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/2.jpg" alt="2"></p><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/3.jpg" alt="3"></p><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/4.jpg" alt="4"></p><hr><h5 id="法二"><a href="#法二" class="headerlink" title="法二:"></a>法二:</h5><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/11.jpg" alt="11"></p><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/22.jpg" alt="22"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-账号密码登录&quot;&gt;&lt;a href=&quot;#1-账号密码登录&quot; class=&quot;headerlink&quot; title=&quot;1.账号密码登录&quot;&gt;&lt;/a&gt;1.账号密码登录&lt;/h3&gt;&lt;h5 id=&quot;法一&quot;&gt;&lt;a href=&quot;#法一&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="服务器" scheme="https://nymrli.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Django邮箱</title>
    <link href="https://nymrli.top/2018/10/24/Django%E9%82%AE%E7%AE%B1/"/>
    <id>https://nymrli.top/2018/10/24/Django邮箱/</id>
    <published>2018-10-24T10:27:12.000Z</published>
    <updated>2018-10-24T10:27:52.316Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Django邮件"><a href="#Django邮件" class="headerlink" title="Django邮件"></a>Django邮件</h3><p>EmailMessage: 标题. 内容.发件人.收件人</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"></span><br><span class="line">send_mail(<span class="string">u'邮件标题'</span>, <span class="string">u'邮件内容'</span>, <span class="string">'from@example.com'</span>,</span><br><span class="line">    [<span class="string">'to@example.com'</span>], fail_silently=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><h4 id="send-mail"><a href="#send-mail" class="headerlink" title="send_mail()"></a>send_mail()</h4><blockquote><p><code>subject</code>, <code>message</code>, <code>from_email</code> and <code>recipient_list</code> 这四个参数是必须的。</p><ul><li><code>subject</code>: 字符串，表示邮件标题。</li><li><code>message</code>: 字符串，表示邮件内容。</li><li><code>from_email</code>: 字符串，表示发件邮箱。</li><li><code>recipient_list</code>: 字符串列表，列表中每个成员都是一个邮箱地址，而且每个收件人都会在 “收件人/To:” 栏看到出现在 <code>recipient_list</code> 中的其他收件人。</li><li><code>fail_silently</code>: （可选）布尔值。为 <code>False</code> 时， <code>send_mail</code> 会抛出 <a href="https://docs.python.org/2.7/library/smtplib.html#smtplib.SMTPException" target="_blank" rel="noopener"><code>smtplib.SMTPException</code></a> 异常。 <a href="https://docs.python.org/2.7/library/smtplib.html#module-smtplib" target="_blank" rel="noopener"><code>smtplib</code></a> 文档列出了所有可能的异常。 这些异常都是 <a href="https://docs.python.org/2.7/library/smtplib.html#smtplib.SMTPException" target="_blank" rel="noopener"><code>SMTPException</code></a> 的子类。</li><li><code>auth_user</code>: （可选）SMTP服务器的认证用户名。没提供该参数的情况下，Django会使用 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-EMAIL_HOST_USER" target="_blank" rel="noopener"><code>EMAIL_HOST_USER</code></a> 配置项的设置。</li><li><code>auth_password</code>: （可选）SMTP服务器的认证密码，没提供该参数的情况下，Django会使用 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-EMAIL_HOST_PASSWORD" target="_blank" rel="noopener"><code>EMAIL_HOST_PASSWORD</code></a>配置项的设置。</li><li><code>connection</code>: （可选）发送邮件的后端。没提供该参数的情况下，Django会使用默认后端的实例。可查看 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#topic-email-backends" target="_blank" rel="noopener">Email backends</a> 了解更多细节。</li></ul></blockquote><p><a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.send_mass_mail" target="_blank" rel="noopener"><code>send_mass_mail()</code></a> 和 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.send_mail" target="_blank" rel="noopener"><code>send_mail()</code></a> 的区别在于： <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.send_mail" target="_blank" rel="noopener"><code>send_mail()</code></a> 每发送一封邮件就会打开一次邮件服务器链接，而<a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.send_mass_mail" target="_blank" rel="noopener"><code>send_mass_mail()</code></a> 则是打开一次链接，发送所有的邮件。 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.send_mass_mail" target="_blank" rel="noopener"><code>send_mass_mail()</code></a> 明显更高效。</p><h3 id="main-admins"><a href="#main-admins" class="headerlink" title="main_admins()"></a>main_admins()</h3><p><code>mail_admins</code>(<em>subject</em>, <em>message</em>, <em>fail_silently=False</em>, <em>connection=None</em>, <em>html_message=None</em>)</p><p><code>django.core.mail.mail_admins()</code> 是一个给网站后台管理员(admin)发邮件的快捷方法，管理员设置放在 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-ADMINS" target="_blank" rel="noopener"><code>ADMINS</code></a> 配置项。</p><p><code>mail_admins()</code> 使用 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-EMAIL_SUBJECT_PREFIX" target="_blank" rel="noopener"><code>EMAIL_SUBJECT_PREFIX</code></a> 配置项的值做为邮件标题的前缀，默认情况下是 <code>&quot;[Django] &quot;</code> 。</p><h2 id="mail-managers"><a href="#mail-managers" class="headerlink" title="mail_managers()"></a>mail_managers()</h2><p>mail_managers`(<em>subject</em>, <em>message</em>, <em>fail_silently=False</em>, <em>connection=None</em>, <em>html_message=None</em>)</p><p>mail_managers<code>(*subject*, *message*, *fail_silently=False*, *connection=None*, *html_message=None*)</code>django.core.mail.mail_managers()<code>is just like</code>mail_admins()<code>，不同之处在于该方法的邮件接收人是网站负责人(manager)， 可以在 [</code>MANAGERS`]配置项设置网站负责人</p><h4 id="EmailMessage-对象"><a href="#EmailMessage-对象" class="headerlink" title="EmailMessage 对象"></a>EmailMessage 对象</h4><ul><li><em>class </em><code>EmailMessage</code></li></ul><p><a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.EmailMessage" target="_blank" rel="noopener"><code>EmailMessage</code></a> 类使用下列参数初始化（除非使用位置参数，否则默认顺序如下）。所有参数均可选，均可在调用 <code>send()</code>方法之前的任何时间对其赋值。</p><p>加入了 <code>cc</code> 参数（cc是抄送）</p><ul><li><p><code>subject</code>: 邮件的标题行</p></li><li><p><code>body</code>: 邮件的主体内容文本，须是纯文本信息。</p></li><li><p><code>from_email</code>: 发送者的地址。 <a href="mailto:`fred@example.com" target="_blank" rel="noopener">`fred@example.com</a><code>或</code>Fred <a href="mailto:&#x66;&#114;&#101;&#100;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#x66;&#114;&#101;&#100;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;</a><code>格式都是合法的。如果忽略该参数，Django就会使用 [</code>DEFAULT_FROM_EMAIL`](<a href="https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-DEFAULT_FROM_EMAIL" target="_blank" rel="noopener">https://django-chinese-docs-14.readthedocs.io/en/latest/ref/settings.html#std:setting-DEFAULT_FROM_EMAIL</a>) 配置项。</p></li><li><p><code>to</code>: 收件人地址列表或元组。</p></li><li><p><code>bcc</code>: 发送邮件时用于”Bcc”头信息的一组列表或元组，也就是暗送的收件人。</p></li><li><p><code>connection</code>: 一个邮件后端实例。用同一个链接发送多封邮件就要用到该参数。忽略该参数时，会在调用 <code>send()</code> 时自动创建一个新链接。</p></li><li><p><code>attachments</code>: 置于邮件报文内的附件列表。列表元素可以是　<code>email.MIMEBase.MIMEBase</code> 实例，也可以是 <code>(filename, content, mimetype)</code> 三部分构成的元组。</p></li><li><p><code>headers</code>: 置于邮件报文内的其他头信息(header)的字典。字典的key是头信息的名称，字典的value是头信息的值。 这样做能确保头信息的名称和对应值会以正确的格式保存于邮件报文中。</p></li><li><p><code>cc</code>: 发送邮件时放于”Cc”头信息的一系列列表或元组。</p><p>例如:</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">email = <span class="type">EmailMessage</span>(<span class="symbol">'Hello'</span>, <span class="symbol">'Body</span> goes here', <span class="symbol">'from</span>@example.com',</span><br><span class="line">            [<span class="symbol">'to1</span>@example.com', <span class="symbol">'to2</span>@example.com'], [<span class="symbol">'bcc</span>@example.com'],</span><br><span class="line">            headers = &#123;<span class="symbol">'Reply</span>-<span class="type">To'</span>: <span class="symbol">'another</span>@example.com'&#125;)</span><br></pre></td></tr></table></figure><p>该类方法如下:</p><ul><li><p><code>send(fail_silently=False)</code> 发送邮件报文。如果在构造邮件时如果指定了某个链接(connection)，就会使用该链接发邮件。 否则，就会使用默认后端的实例发邮件。如果关键字参数 <code>fail_silently</code> 为 <code>True</code> ，就会忽略邮件发送时抛出的异常。</p></li><li><p><code>message()</code> 构造了一个 <code>django.core.mail.SafeMIMEText</code> 对象 (Python的 <code>email.MIMEText.MIMEText</code> 类的子类) 或是 <code>django.core.mail.SafeMIMEMultipart</code> 对象（该对象保存即将发送出去邮件报文）。如需扩展 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.EmailMessage" target="_blank" rel="noopener"><code>EmailMessage</code></a>类，一般情况下要覆写该方法，将你所需的内容添加到MIME对象中。</p></li><li><p><code>recipients()</code> 返回邮件中所有收件人的列表，不管收件人是在 <code>to</code> 还是 <code>bcc</code> 属性中。这是另一个经常被继承覆写的方法， 因为SMTP服务器在发送邮件报文时，要接收完整的收件人列表。即使你自己的类使用其他方式来指定收件人，也仍然需要使用该方法返回收件人列表。</p></li><li><p><code>attach()</code> 创建一个新的文件附件，并把它添加到邮件报文中。 有两种方法调用 <code>attach()</code>:</p><ul><li><p>传递一个单独的 <code>email.MIMEBase.MIMEBase</code> 实例做为参数。该实例会直接添加到最终的邮件报文中。</p></li><li><p>或者，给 <code>attach()</code> 传递三个参数: <code>filename</code>, <code>content</code> 和 <code>mimetype</code>. <code>filename</code> 是出现在邮件中的附件文件的名称， <code>content</code> 是附件的内容，而 <code>mimetype</code> 是附件所使用的MIME类型。 如果忽略 <code>mimetype</code>, Django会自动根据附件文件名来推测MIME内容类型。</p><p>例如:</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.attach(<span class="symbol">'design</span>.png', img_data, <span class="symbol">'image</span>/png')</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>attach_file()</code> 使用当前文件系统下的某个文件做为附件。调用时，传入某个文件的完整路径，以及该附件的MIME类型(可选的)。 忽略MIME类型的话，Django会自动根据附件文件名来推测MIME类型。最简单的用法如下:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>.attach_file(<span class="string">'/images/weather_map.png'</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="发送多用途邮件"><a href="#发送多用途邮件" class="headerlink" title="发送多用途邮件"></a>发送多用途邮件</h4><p>在同一封邮件中包含多种版本的内容是非常有用的；典型的例子就是发送既有纯文本版本内容又有HTML版本内容的邮件。 在Django的邮件库中，可以使用 <code>EmailMultiAlternatives</code> 类来达到该目的。 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.EmailMessage" target="_blank" rel="noopener"><code>EmailMessage</code></a> 的子类有一个<code>attach_alternative()</code> 方法用来包含其他版本的邮件主体内容。所有其他方法(包括类的初始化方法)都直接继承自 <a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.EmailMessage" target="_blank" rel="noopener"><code>EmailMessage</code></a> 。</p><p>发送一封文本/HTML混合邮件，代码如下:</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail import EmailMultiAlternatives</span><br><span class="line"></span><br><span class="line">subject, from_email, <span class="keyword">to</span> = <span class="comment">'hello', 'from@example.com', 'to@example.com'</span></span><br><span class="line">text_content = <span class="comment">'This is an important message.'</span></span><br><span class="line">html_content = <span class="comment">'<span class="doctag">&lt;p&gt;</span>This is an <span class="doctag">&lt;strong&gt;</span>important<span class="doctag">&lt;/strong&gt;</span> message.<span class="doctag">&lt;/p&gt;</span>'</span></span><br><span class="line">msg = EmailMultiAlternatives(subject, text_content, from_email, [<span class="keyword">to</span>])</span><br><span class="line">msg.attach_alternative(html_content, <span class="string">"text/html"</span>)</span><br><span class="line">msg.send()</span><br></pre></td></tr></table></figure><p>默认情况下，<a href="https://django-chinese-docs-14.readthedocs.io/en/latest/topics/email.html#django.core.mail.EmailMessage" target="_blank" rel="noopener"><code>EmailMessage</code></a> 类中的 <code>body</code> 参数的MIME类型是 <code>&quot;text/plain&quot;</code> 。 大多数情况下，没必要更改该MIME，因为这样能保证每个收件人能够阅读该邮件，而不论他们使用的是什么邮件客户端。 不过，在能确保收件人能处理多用途邮件的情况下，可以使用:class:~django.core.mail.EmailMessage 类的 <code>content_subtype</code> 属性 来更改邮件内容类型。主类型总是 <code>&quot;text&quot;</code> ，子类型可以设置为别的版本(比如html)，例如:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = EmailMessage(subject, html_content, from_email, [<span class="keyword">to</span>])</span><br><span class="line">msg.content_subtype = <span class="string">"html"</span>  <span class="meta"># 主内体现在变成 text/html</span></span><br><span class="line">msg.<span class="built_in">send</span>()</span><br></pre></td></tr></table></figure><h4 id="获取邮件发送后端的实例"><a href="#获取邮件发送后端的实例" class="headerlink" title="获取邮件发送后端的实例"></a>获取邮件发送后端的实例</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">django.core.mail 的 get_connection() 函式返回你当前使用的邮件后端的实例。</span><br><span class="line"></span><br><span class="line">get_connection(<span class="attribute">backend</span>=None, <span class="attribute">fail_silently</span>=<span class="literal">False</span>, <span class="number">*a</span>rgs, **kwargs)</span><br></pre></td></tr></table></figure><ul><li><h4 id="SMTP-backend-–默认的后端"><a href="#SMTP-backend-–默认的后端" class="headerlink" title="SMTP backend    –默认的后端"></a>SMTP backend    –默认的后端</h4></li><li><h4 id="Console-backend"><a href="#Console-backend" class="headerlink" title="Console backend"></a>Console backend</h4></li><li><h4 id="File-backend-–该后端并不建议在生产环境下使用–它仅仅是为开发提供方便"><a href="#File-backend-–该后端并不建议在生产环境下使用–它仅仅是为开发提供方便" class="headerlink" title="File backend –该后端并不建议在生产环境下使用–它仅仅是为开发提供方便"></a>File backend –该后端并不建议在生产环境下使用–它仅仅是为开发提供方便</h4></li><li><h4 id="In-memory-backend-内存后端"><a href="#In-memory-backend-内存后端" class="headerlink" title="In-memory backend(内存后端)"></a>In-memory backend(内存后端)</h4></li><li><h4 id="Dummy-backend-空后端"><a href="#Dummy-backend-空后端" class="headerlink" title="Dummy backend(空后端)"></a>Dummy backend(空后端)</h4></li></ul><hr><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>需要一个安全的连接，例如SSL，因此接下来我们会使用SSL的方式去登录，但是在那之前，我们需要做一些准备，打开qq邮箱，点击设置-&gt;账户，找到<strong>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</strong>，开启IMAP/SMTP服务，然后根据要求使用手机发送到指定号码，获取授权码，这个<strong>授权码就是你接下来登录要使用的密码</strong>.</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">_user</span> = <span class="string">'1063052964@qq.com'</span></span><br><span class="line"><span class="variable">_pwd</span> = <span class="string">'pykhotuhghdjbeci'</span></span><br><span class="line"><span class="variable">_to</span> = <span class="string">'2035420834@qq.com'</span></span><br><span class="line">msg = MIMEText(mail_body)<span class="comment">//MIMEText中_subtype默认为plain,html格式,只需改这个参数</span></span><br><span class="line">msg[<span class="string">"Subject"</span>] = <span class="string">'来自[不吐不快]网站的网友意见'</span></span><br><span class="line">msg[<span class="string">"From"</span>] = <span class="variable">_user</span></span><br><span class="line">msg[<span class="string">"To"</span>] = <span class="variable">_to</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = smtplib.SMTP_SSL(<span class="string">"smtp.qq.com"</span>, <span class="number">465</span>)  <span class="comment">//或是使用s = smtplib.SMTP("smtp.qq.com",25)</span></span><br><span class="line">    s.login(<span class="variable">_user</span>, <span class="variable">_pwd</span>)</span><br><span class="line">    s.sendmail(<span class="variable">_user</span>, <span class="variable">_to</span>, msg.as_string())</span><br><span class="line">    s.quit()</span><br><span class="line">    message = <span class="string">'感谢你的来信'</span></span><br><span class="line">except:</span><br><span class="line">    message = <span class="string">'发送失败'</span></span><br></pre></td></tr></table></figure><p>▲smtplib.SMTP_SSL([host[, port[, local_hostname[, keyfile[, certfile[, timeout]]]]]])</p><p>这是一个派生自SMTP的子类，通过SSL加密的套接字连接（使用此类，您需要使用SSL支持编译的套接字模块）。如果未指定主机，则使用“（本地主机）”。如果省略端口，则使用标准的SMTP-over-SSL端口（465）</p><p>本机已安装了支持 SMTP 的服务，如：sendmail:</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line">from email.mime.<span class="keyword">text</span> <span class="keyword">import</span> MIMEText</span><br><span class="line">from email.header <span class="keyword">import</span> Header</span><br><span class="line">message[<span class="string">'From'</span>] = Header(<span class="string">"菜鸟教程"</span>, <span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><p>第三方SMTP发送邮件:</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr</span><br><span class="line">msg[<span class="string">'From'</span>]=formataddr([<span class="string">"FromRunoob"</span>,my_sender])  # 括号里的对应发件人邮箱昵称、发件人邮箱账号</span><br><span class="line">msg[<span class="string">'To'</span>]=formataddr([<span class="string">"FK"</span>,my_user])              # 括号里的对应收件人邮箱昵称、收件人邮箱账号</span><br><span class="line">*没有formataddr的昵称默认为账号*</span><br></pre></td></tr></table></figure><h4 id="Python-发送带附件的邮件"><a href="#Python-发送带附件的邮件" class="headerlink" title="Python 发送带附件的邮件:"></a>Python 发送带附件的邮件:</h4><blockquote><p>发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"> </span><br><span class="line">sender = <span class="string">'from@runoob.com'</span></span><br><span class="line">receivers = [<span class="string">'429240967@qq.com'</span>]  <span class="comment"># 接收邮件，可设置为你的QQ邮箱或者其他邮箱</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#创建一个带附件的实例</span></span><br><span class="line">message = MIMEMultipart()</span><br><span class="line">message[<span class="string">'From'</span>] = Header(<span class="string">"菜鸟教程"</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">message[<span class="string">'To'</span>] =  Header(<span class="string">"测试"</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">subject = <span class="string">'Python SMTP 邮件测试'</span></span><br><span class="line">message[<span class="string">'Subject'</span>] = Header(subject, <span class="string">'utf-8'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#邮件正文内容</span></span><br><span class="line">message.attach(MIMEText(<span class="string">'这是菜鸟教程Python 邮件发送测试……'</span>, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 构造附件1，传送当前目录下的 test.txt 文件</span></span><br><span class="line">att1 = MIMEText(open(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>).read(), <span class="string">'base64'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">att1[<span class="string">"Content-Type"</span>] = <span class="string">'application/octet-stream'</span></span><br><span class="line"><span class="comment"># 这里的filename可以任意写，写什么名字，邮件中显示什么名字</span></span><br><span class="line">att1[<span class="string">"Content-Disposition"</span>] = <span class="string">'attachment; filename="test.txt"'</span></span><br><span class="line">message.attach(att1)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 构造附件2，传送当前目录下的 runoob.txt 文件</span></span><br><span class="line">att2 = MIMEText(open(<span class="string">'runoob.txt'</span>, <span class="string">'rb'</span>).read(), <span class="string">'base64'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">att2[<span class="string">"Content-Type"</span>] = <span class="string">'application/octet-stream'</span></span><br><span class="line">att2[<span class="string">"Content-Disposition"</span>] = <span class="string">'attachment; filename="runoob.txt"'</span></span><br><span class="line">message.attach(att2)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    smtpObj = smtplib.SMTP(<span class="string">'localhost'</span>)</span><br><span class="line">    smtpObj.sendmail(sender, receivers, message.as_string())</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"邮件发送成功"</span></span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Error: 无法发送邮件"</span></span><br></pre></td></tr></table></figure><h4 id="在-HTML-文本中添加图片"><a href="#在-HTML-文本中添加图片" class="headerlink" title="在 HTML 文本中添加图片"></a>在 HTML 文本中添加图片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"> </span><br><span class="line">sender = <span class="string">'from@runoob.com'</span></span><br><span class="line">receivers = [<span class="string">'429240967@qq.com'</span>]  <span class="comment"># 接收邮件，可设置为你的QQ邮箱或者其他邮箱</span></span><br><span class="line"> </span><br><span class="line">msgRoot = MIMEMultipart(<span class="string">'related'</span>)//创建MIMEMultipart()实例</span><br><span class="line">msgRoot[<span class="string">'From'</span>] = Header(<span class="string">"菜鸟教程"</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">msgRoot[<span class="string">'To'</span>] =  Header(<span class="string">"测试"</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">subject = <span class="string">'Python SMTP 邮件测试'</span></span><br><span class="line">msgRoot[<span class="string">'Subject'</span>] = Header(subject, <span class="string">'utf-8'</span>)</span><br><span class="line"> </span><br><span class="line">msgAlternative = MIMEMultipart(<span class="string">'alternative'</span>)</span><br><span class="line">msgRoot.attach(msgAlternative)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">mail_msg = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;&lt;a href="http://www.runoob.com"&gt;菜鸟教程链接&lt;/a&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;图片演示：&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;&lt;img src="cid:image1"&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">msgAlternative.attach(MIMEText(mail_msg, <span class="string">'html'</span>, <span class="string">'utf-8'</span>))//内容</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定图片为当前目录</span></span><br><span class="line">fp = open(<span class="string">'test.png'</span>, <span class="string">'rb'</span>)</span><br><span class="line">msgImage = MIMEImage(fp.read())</span><br><span class="line">fp.close()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义图片 ID，在 HTML 文本中引用</span></span><br><span class="line">msgImage.add_header(<span class="string">'Content-ID'</span>, <span class="string">'&lt;image1&gt;'</span>)</span><br><span class="line">msgRoot.attach(msgImage)//附件</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    smtpObj = smtplib.SMTP(<span class="string">'localhost'</span>)</span><br><span class="line">    smtpObj.sendmail(sender, receivers, msgRoot.as_string())</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"邮件发送成功"</span></span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Error: 无法发送邮件"</span></span><br></pre></td></tr></table></figure><h5 id="Python-SMTP发送邮件"><a href="#Python-SMTP发送邮件" class="headerlink" title="Python SMTP发送邮件"></a><a href="http://www.runoob.com/python/python-email.html" target="_blank" rel="noopener">Python SMTP发送邮件</a></h5><h4 id="需要在-settings-py中设置的东西"><a href="#需要在-settings-py中设置的东西" class="headerlink" title="需要在 settings.py中设置的东西:"></a>需要在 settings.py中设置的东西:</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">EMAIL_BACKEND</span> = <span class="string">'django.core.mail.backends.smtp.EmailBackend'</span></span><br><span class="line"><span class="attr">EMAIL_USE_SSL</span> = <span class="literal">True</span></span><br><span class="line"><span class="attr">EMAIL_HOST</span> = <span class="string">'smtp.gmail.com'</span></span><br><span class="line"><span class="attr">EMAIL_PORT</span> = <span class="number">587</span></span><br><span class="line"><span class="attr">EMAIL_HOST_USER</span> = <span class="string">'urusername@gmail.com'</span></span><br><span class="line"><span class="attr">EMAIL_HOST_PASSWORD</span> = <span class="string">'password'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Django邮件&quot;&gt;&lt;a href=&quot;#Django邮件&quot; class=&quot;headerlink&quot; title=&quot;Django邮件&quot;&gt;&lt;/a&gt;Django邮件&lt;/h3&gt;&lt;p&gt;EmailMessage: 标题. 内容.发件人.收件人&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="后端" scheme="https://nymrli.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Django" scheme="https://nymrli.top/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>复制Django项目时需要注意、修改的地方</title>
    <link href="https://nymrli.top/2018/10/24/%E5%A4%8D%E5%88%B6Django%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E3%80%81%E4%BF%AE%E6%94%B9%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
    <id>https://nymrli.top/2018/10/24/复制Django项目时需要注意、修改的地方/</id>
    <published>2018-10-24T10:25:37.000Z</published>
    <updated>2018-10-24T10:26:19.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="复制Django项目"><a href="#复制Django项目" class="headerlink" title="复制Django项目:"></a>复制Django项目:</h3><blockquote><p>manage.py中需要修改的地方</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os<span class="selector-class">.environ</span><span class="selector-class">.setdefault</span>(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"window.settings"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>settings.py中需要修改的地方</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Django settings for window project.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">ROOT_URLCONF = <span class="string">'window.urls'</span></span><br><span class="line">WSGI_APPLICATION = <span class="string">'window.wsgi.application'</span></span><br></pre></td></tr></table></figure><blockquote><p>urls.py中需要改动的地方</p></blockquote><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""window URL Configuration</span></span><br></pre></td></tr></table></figure><blockquote><p>wsgi.py中需要修改的地方</p></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>"</span><br><span class="line">WSGI config <span class="keyword">for</span> <span class="keyword">window</span> project.</span><br><span class="line">os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"window.settings"</span>)</span><br></pre></td></tr></table></figure><h4 id="django可复用模板"><a href="#django可复用模板" class="headerlink" title="django可复用模板"></a>django可复用模板</h4><blockquote><p>在project_name文件下的*.py</p><p>再在终端键入django-admin startproject xx –template=<em>  (</em>为文件夹中py文件名)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line">DEBUG = os.environ.get(<span class="string">'DEBUG'</span>,<span class="string">'on'</span>)== <span class="string">'on'</span></span><br><span class="line">ALLOW_HOSTS = [<span class="string">'*'</span>]</span><br><span class="line">SECRET_KEY = os.environ.get(<span class="string">'SECRET'</span>,<span class="string">'&#123;&#123; secret_key &#125;&#125;'</span>)</span><br><span class="line">settings.configure(</span><br><span class="line">    DEBUG = DEBUG,</span><br><span class="line">    ALLOW_HOSTS = ALLOW_HOSTS,</span><br><span class="line">    SECRET_KEY = SECRET_KEY,</span><br><span class="line">    ROOT_URLCONF = __name__,</span><br><span class="line">    MIDDLEWARE_CLASSES = (</span><br><span class="line">        <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">        <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">        <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> django.core.wsgi <span class="keyword">import</span> get_wsgi_application</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Hello Word'</span>)</span><br><span class="line"></span><br><span class="line">urlpatterns = (</span><br><span class="line">   url(<span class="string">r'$'</span>,index),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">application = get_wsgi_application()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> django.core.management <span class="keyword">import</span> execute_from_command_line</span><br><span class="line"></span><br><span class="line">    execute_from_command_line(sys.argv)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;复制Django项目&quot;&gt;&lt;a href=&quot;#复制Django项目&quot; class=&quot;headerlink&quot; title=&quot;复制Django项目:&quot;&gt;&lt;/a&gt;复制Django项目:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;manage.py中需要修改的地方&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="后端" scheme="https://nymrli.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Django" scheme="https://nymrli.top/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>网络宽带和网络延迟</title>
    <link href="https://nymrli.top/2018/10/24/%E7%BD%91%E7%BB%9C%E5%AE%BD%E5%B8%A6%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F/"/>
    <id>https://nymrli.top/2018/10/24/网络宽带和网络延迟/</id>
    <published>2018-10-24T08:42:27.000Z</published>
    <updated>2018-10-24T08:44:50.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络宽带和网络延迟"><a href="#网络宽带和网络延迟" class="headerlink" title="网络宽带和网络延迟"></a>网络宽带和网络延迟</h3><p><strong>网络带宽，网络延迟是2个概念（网络延迟往往更容易被忽略！）</strong></p><p>国内大陆 建立在互联网基础上 很多对延迟性要求比较高的应用，体验效果都不如人意。比如高清晰度网络电视、在线视频语音实时业务（qq、skype） 某些在线游戏 等等。<br>最简单的例子：如果ping某个网站，高于50ms的网站，打开就慢。10-30ms的网站，打开就比较快。<br>如果都是同一个宽带服务商，即使升级到10M 20M 100M的宽带，这种网络延迟情况，短时间内应该也不会有改善</p><p>1、“下载电影这种活儿就看带宽，不在乎服务器发出数据后晚几秒钟收到，传输层有“窗口协议”，不必等到上一段数据的应答再传下一段数据，可以看做是一种“异步应用”。一般说，交互性的应用比较讲究低延迟，我用“同步应用”来描述之。同步应用别说晚几秒钟，就是晚0.1秒收到数据，影响也很大,如<br>a、比如fps游戏会觉得很不爽，明明瞄准了怎么打不到。<br>b、至于视频语音等，对带宽、延迟都有一定要求，带宽太小无法传输清晰的图像和声音，延迟太大你一句话“我爱你”，对方的mm没有任何反应……<br>另外还有一个指标是抖动，通俗说是数据能不能平稳传输，还是一会儿快一会儿慢一会儿堵塞。”    </p><p>  2、理论上说，带宽越大，在网络拓扑中的优先级就越高，所对应的响应速度就越快，对于用户和ISP之间来说带宽越高，每秒传输的数据越多，延迟就越小。但是延迟高低是由很多个因素决定的，网络上的每一个服务器（路由器）都是一个节点，所有的节点加在一起的响应速度，才是你的网络延迟，如果某一中间节点出现出题，无法提供服务，其它节点就会重新计算路由，但是重新计算路由之前会有一个超时记时器，只有目的节点的响应时间超出记时器时才会重新进行路由计算。还有DNS服务器的影响等等，</p><p>所以把网络带宽和网络延迟扯在一起谈是没用的，ISP只能保证你的接入网络带宽和网络延迟无问题，与其它节点的服务就没法保证了。（世界上最远的距离不是天涯和海角，而是电信和网通）”  </p><p>3、“任何FPS游戏，网络条件是最关键的——到服务器的ping稳定性和延迟时间，对战绩的影响最大。<br>比如ping服务器5分钟，延迟ms数一直不变，或者误差不超过5%，随便什么FPS，哪怕你从没玩过没有经验不熟悉地图和武器，你的成绩也差不了。<br>如果这ms数比多数人还少，那你更屌了。</p><p>  ADSL线路分交织模式interleave和快速模式fast,区别在于交织模式在本地会对数据包进行纠错加密，因此可保证线路的稳定，当然相应的延迟就会上升，电信提供的线路默认也都是交织模式，于是有种减低延迟的方法就是让电信帮你线路改成FAST,当然随之而来的问题是可能导致线路的不稳定，尤其是家里离接入网机房比较远的情况。</p><p>延迟这个问题只要是网络都会存在,差别在于大小,标志着整个架构的合理性和完善性。可以简单的认为带宽相当于马路上的车道数量，延迟就相当于堵塞的程度。因此，营运商即使是相同带宽的情况下对延迟不同的线路收费也是不同的。当然一般家庭用户是不会享受这个的。  </p><h4 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h4><p>ADSL（Asymmetric Digital Subscriber Loop）技术是一种不对称数字用户线实现宽带接入互连网的技术。</p><p>实际<a href="https://www.baidu.com/s?wd=%E4%BC%A0%E8%BE%93%E9%80%9F%E5%BA%A6&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">传输速度</a>也要分上行和下行，上行速率就是发送出去数据的速度(上传速度)，下行就是收到数据的速度(下载速度).</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>带宽代表一定时间内能运多少货。</li></ul><p>延迟代表货物运输时间。<br>比如万吨轮就是属于大带宽，高延迟。<br>私人飞机属于低延迟，小带宽。<br>比如都给一个月的时间，万吨轮拉的东西肯定比私人飞机多,如果土豪做生意，血汗工厂t恤运去去美国，肯定用轮船，对带宽敏感，对延迟不敏感的业务。<br>但是如果土豪要移植肾了，这玩意路上放久会臭，就属于对延迟比较敏感的应用，还是用私人飞机运比较好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网络宽带和网络延迟&quot;&gt;&lt;a href=&quot;#网络宽带和网络延迟&quot; class=&quot;headerlink&quot; title=&quot;网络宽带和网络延迟&quot;&gt;&lt;/a&gt;网络宽带和网络延迟&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;网络带宽，网络延迟是2个概念（网络延迟往往更容易被忽略！）&lt;/str
      
    
    </summary>
    
    
      <category term="计算机知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>linux下apt-get介绍</title>
    <link href="https://nymrli.top/2018/10/24/linux%E4%B8%8Bapt-get%E4%BB%8B%E7%BB%8D/"/>
    <id>https://nymrli.top/2018/10/24/linux下apt-get介绍/</id>
    <published>2018-10-24T08:42:20.000Z</published>
    <updated>2018-10-24T08:43:14.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h3><blockquote><p>Advanced Package Tool又名apt-get，是一条<a href="https://baike.baidu.com/item/linux%E5%91%BD%E4%BB%A4/1750369" target="_blank" rel="noopener">linux命令</a>，适用于deb包管理式的操作系统如<a href="https://baike.baidu.com/item/Unix" target="_blank" rel="noopener">Unix</a>和<a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>系统的应用程序管理器，主要用于自动从互联网的软件仓库中搜索、安装、升级、<a href="https://baike.baidu.com/item/%E5%8D%B8%E8%BD%BD" target="_blank" rel="noopener">卸载</a>软件或操作系统。</p></blockquote><p>rpm包和deb包是两种<a href="https://www.baidu.com/s?wd=Linux%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Linux系统</a>下最常见的安装包格式，在安装一些软件或服务的时候免不了要和它们打交道。rpm包主要应用在RedHat系列包括 Fedora等发行版的<a href="https://www.baidu.com/s?wd=Linux%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Linux系统</a>上，deb包主要应用于Debian系列包括现在比较流行的Ubuntu等发行版上。</p><p>我们知道如果要安装现成的这两种包的话，安装rpm包的命令是“rpm -参数”，安装deb包的命令是“dpkg -参数”。而<a href="https://www.baidu.com/s?wd=Linux%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Linux系统</a>很方便和人性化的一点就是很多软件或服务根本就不用我们去下载，直接使用相应的命令就可以管理了，可能这就是传说中的 “云”的概念。</p><ul><li>yum可以用于运作rpm包，例如在Fedora系统上对某个软件的管理：<br>安装：yum install &lt;package_name&gt;<br>卸载：yum remove &lt;package_name&gt;<br>更新：yum update &lt;package_name&gt;</li><li>apt-get可以用于运作deb包，例如在<a href="https://www.baidu.com/s?wd=Ubuntu%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Ubuntu系统</a>上对某个软件的管理：<br>安装：apt-get install &lt;package_name&gt;<br>卸载：apt-get remove &lt;package_name&gt;<br>更新：apt-get update &lt;package_name&gt;  </li></ul><p>▲.apt-get命令一般需要<a href="https://baike.baidu.com/item/root%E6%9D%83%E9%99%90" target="_blank" rel="noopener">root权限</a>执行，所以一般跟着sudo命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line"><span class="meta">#</span><span class="bash">1、apt-get update是同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2、apt-get update只是更新了apt的资源列表，没有真正的对系统执行更新。如果需要，要使用apt-get upgrade来更新。</span></span><br><span class="line"></span><br><span class="line">apt-get upgrade</span><br><span class="line"><span class="meta">#</span><span class="bash">可以使用这条命令更新软件包，apt-get upgrade不仅可以从相同版本号的发布版中更新软件包，也可以从新版本号的发布版中更新软件包，尽管实现后一种更新的推荐命令为apt-get dist-upgrade(将系统升级到新版本)。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">dpkg -l</span></span><br><span class="line"><span class="meta">#</span><span class="bash">列出所有已安装的软件包。</span></span><br></pre></td></tr></table></figure><h3 id="在Ubuntu中，有时候运用sudo-apt-get-install-安装软件时，会出现一下的情况"><a href="#在Ubuntu中，有时候运用sudo-apt-get-install-安装软件时，会出现一下的情况" class="headerlink" title="在Ubuntu中，有时候运用sudo  apt-get install 安装软件时，会出现一下的情况"></a>在Ubuntu中，有时候运用sudo  apt-get install 安装软件时，会出现一下的情况</h3><blockquote><p>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)<br>E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?</p></blockquote><p>主要是因为apt还在运行,解决方案是</p><h5 id="1-找到并且杀掉所有的apt-get-和apt进程"><a href="#1-找到并且杀掉所有的apt-get-和apt进程" class="headerlink" title="1.找到并且杀掉所有的apt-get 和apt进程"></a>1.找到并且杀掉所有的apt-get 和apt进程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps -A | grep apt</span><br><span class="line">找出所有的 apt 以及 apt-get 进程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">kill</span> -9 processnumber 或者$ sudo <span class="built_in">kill</span> -SIGKILL processnumber</span></span><br><span class="line">比如，下面命令中的9是 SIGKILL 的信号数，它会杀掉第一个 apt 进程$ sudo kill -9 进程ID 或者$ sudo kill -SIGKILL 进程ID</span><br></pre></td></tr></table></figure><h5 id="2、删除锁定文件"><a href="#2、删除锁定文件" class="headerlink" title="2、删除锁定文件"></a>2、删除锁定文件</h5><p>锁定的文件会阻止 Linux 系统中某些文件或者数据的访问，这个概念也存在于 Windows 或者其他的操作系统中。</p><blockquote><p>一旦你运行了 apt-get 或者 apt 命令，锁定文件将会创建于 /var/lib/apt/lists/、/var/lib/dpkg/、/var/cache/apt/archives/ 中。</p></blockquote><p>这有助于运行中的 apt-get 或者 apt 进程能够避免被其它需要使用相同文件的用户或者系统进程所打断。当该进程执行完毕后，锁定文件将会删除。</p><p>当你没有看到 apt-get 或者 apt 进程的情况下在上面两个不同的文件夹中看到了锁定文件，这是因为进程由于某个原因被杀掉了，因此你需要删除锁定文件来避免该错误。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">首先运行下面的命令来移除 /var/lib/dpkg/ 文件夹下的锁定文件：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm /var/lib/dpkg/lock</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">之后像下面这样强制重新配置软件包：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg --configure -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">也可以删除 /var/lib/apt/lists/ 以及缓存文件夹下的锁定文件：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm /var/lib/apt/lists/lock</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm /var/cache/apt/archives/lock</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">接下来，更新你的软件包源列表：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update或者$ sudo apt-get update</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;apt-get&quot;&gt;&lt;a href=&quot;#apt-get&quot; class=&quot;headerlink&quot; title=&quot;apt-get&quot;&gt;&lt;/a&gt;apt-get&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Advanced Package Tool又名apt-get，是一条&lt;a 
      
    
    </summary>
    
    
      <category term="linux" scheme="https://nymrli.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>python中关于round函数的注意事项</title>
    <link href="https://nymrli.top/2018/10/18/python%E4%B8%AD%E5%85%B3%E4%BA%8Eround%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://nymrli.top/2018/10/18/python中关于round函数的注意事项/</id>
    <published>2018-10-18T03:37:00.000Z</published>
    <updated>2018-10-18T03:37:23.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python中关于round函数的注意事项"><a href="#python中关于round函数的注意事项" class="headerlink" title="python中关于round函数的注意事项"></a>python中关于round函数的注意事项</h3><blockquote><p>round函数很简单，对浮点数进行近似取值，保留几位小数。</p></blockquote><p>比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">10.0</span>/<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">3.33</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">20</span>/<span class="number">7</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">#第一个参数是一个浮点数，第二个参数是保留的小数位数，可选，如果不写的话默认保留到整数。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[round]函数文档-py3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">round</span><span class="params">(number, ndigits=None)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    round(number[, ndigits]) -&gt; number</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Round a number to a given precision in decimal digits (default 0 digits).</span></span><br><span class="line"><span class="string">    This returns an int when called with one argument, otherwise the</span></span><br><span class="line"><span class="string">    same type as the number. ndigits may be negative.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>翻译一下什么意思呢?: 将数字四舍五入到给定精度,如果不给第二个精度参数的话就默认保留到0位(即整数)</p></blockquote><h4 id="这么简单的函数，能有什么坑呢？"><a href="#这么简单的函数，能有什么坑呢？" class="headerlink" title="这么简单的函数，能有什么坑呢？"></a>这么简单的函数，能有什么坑呢？</h4><p><strong>1、round的结果跟python版本有关</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-------python2---------</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.5</span>)</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#======python3==========</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.5</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>原因在于:</p><p>在python2.7的doc中，round()的最后写着，“Values are rounded to the closest multiple of 10 to the power minus <em>ndigits</em>; if two multiples are equally close, rounding is done away from 0.” 保留值将保留到离上一位更近的一端（四舍六入），<u>如果距离两端一样远，则保留到离0远的一边</u>。所以round(0.5)会近似到1，而round(-0.5)会近似到-1。</p><p>但是到了python3.5的doc中，文档变成了“values are rounded to the closest multiple of 10 to the power minus <em>ndigits</em>; if two multiples are equally close, rounding is done toward the even choice.” <u>如果距离两边一样远，会保留到偶数的一边</u>。比如round(0.5)和round(-0.5)都会保留到0，而round(1.5)会保留到2。</p></blockquote><p><strong>然而需要注意的是</strong></p><p><strong>2、特殊数字round出来的结果可能未必是想要的。</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; round(<span class="number">2.675</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">2.67</span></span><br></pre></td></tr></table></figure><p>官方举例:python2和python3的doc</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note</span><br><span class="line"></span><br><span class="line">The behavior <span class="keyword">of</span> <span class="built_in">round</span>() <span class="keyword">for</span> floats can be surprising: <span class="keyword">for</span> example, <span class="built_in">round</span>(<span class="number">2.675</span>, <span class="number">2</span>) gives <span class="number">2.67</span> instead <span class="keyword">of</span> <span class="keyword">the</span> expected <span class="number">2.68</span>. This is <span class="keyword">not</span> <span class="keyword">a</span> bug: <span class="keyword">it</span>’s <span class="keyword">a</span> <span class="built_in">result</span> <span class="keyword">of</span> <span class="keyword">the</span> fact that most decimal fractions can’t be represented exactly <span class="keyword">as</span> <span class="keyword">a</span> float. See Floating Point Arithmetic: Issues <span class="keyword">and</span> Limitations <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure><p>简单的说就是，round(2.675, 2) 的结果，不论我们从python2还是3来看，结果都应该是2.68的，结果它偏偏是2.67，为什么？这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串1和0后可能是无限位数的，机器已经做出了截断处理)。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离2.67要更近一点点，所以保留两位小数时就近似到了2.67。</p><p><strong>例子</strong>2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">123.45</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">123.5</span></span><br></pre></td></tr></table></figure><p>意思就是说计算机需要先将十进制123.45转换为二进制,这个过程会导致二进制的值比123.45略大(比如123.45000001之类的),那么自然就得到123.5这个值了.</p><hr><p>以上。除非对精确度没什么要求，否则尽量避开用round()函数。近似计算我们还有其他的选择：</p><ol><li><ul><li>使用math模块中的一些函数，比如math.ceiling（天花板除法）。</li></ul></li><li><ul><li>python自带整除，python2中是/，3中是//，还有div函数。</li></ul></li><li><ul><li>字符串格式化可以做截断使用，例如 “%.2f” % value（保留两位小数并变成字符串……如果还想用浮点数请披上float()的外衣）。</li></ul></li><li><ul><li>当然，对浮点数精度要求如果很高的话，请用嘚瑟馍，不对不对，请用decimal模块。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python中关于round函数的注意事项&quot;&gt;&lt;a href=&quot;#python中关于round函数的注意事项&quot; class=&quot;headerlink&quot; title=&quot;python中关于round函数的注意事项&quot;&gt;&lt;/a&gt;python中关于round函数的注意事项&lt;/
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>HDOJ Problem 1002 - A + B Problem II</title>
    <link href="https://nymrli.top/2018/10/18/HDOJ-Problem-1002-A-B-Problem-II/"/>
    <id>https://nymrli.top/2018/10/18/HDOJ-Problem-1002-A-B-Problem-II/</id>
    <published>2018-10-18T03:36:23.000Z</published>
    <updated>2018-10-18T03:36:44.900Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HDOJ-Problem-1002-A-B-Problem-II"><a href="#HDOJ-Problem-1002-A-B-Problem-II" class="headerlink" title="HDOJ Problem 1002 - A + B Problem II:"></a>HDOJ Problem 1002 - A + B Problem II:</h4><p><strong>大数定理</strong></p><h5 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h5><blockquote><p>I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B.</p></blockquote><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><blockquote><p>The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000.</p></blockquote><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><blockquote><p>For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line is the an equation “A + B = Sum”, Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases.</p></blockquote><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">112233445566778899 </span><span class="number">998877665544332211</span></span><br></pre></td></tr></table></figure><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Case</span> <span class="number">1</span>:</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Case</span> <span class="number">2</span>:</span><br><span class="line"><span class="number">112233445566778899</span> + <span class="number">998877665544332211</span> = <span class="number">1111111111111111110</span></span><br></pre></td></tr></table></figure><hr><p>解法一:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">1000</span>],b[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> aar[<span class="number">1001</span>],bar[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> alen,blen,maxlen;</span><br><span class="line"><span class="keyword">int</span> time;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; time;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=time;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">alen = <span class="built_in">strlen</span>(a);</span><br><span class="line">blen = <span class="built_in">strlen</span>(b);</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=alen<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">aar[tmp++] = a[j]-<span class="string">'0'</span>;</span><br><span class="line">tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=blen<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">bar[tmp++] = b[j]-<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//123 ==&gt;  321 为了保证之后便于计算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( alen &gt; blen)&#123;</span><br><span class="line">maxlen = alen;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=blen;j&lt;alen;j++)&#123;<span class="comment">//长度不同时,短的那个需要补零</span></span><br><span class="line">bar[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">aar[alen] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( alen &lt; blen)&#123;</span><br><span class="line">maxlen = blen;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=alen;j&lt;blen;j++)</span><br><span class="line">&#123;</span><br><span class="line">aar[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar[blen] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">maxlen = alen;</span><br><span class="line">aar[maxlen]=<span class="number">0</span>;</span><br><span class="line">bar[maxlen]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxlen;j++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; aar[j] &lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bar[j] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">aar[j] += bar[j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(aar[j] &gt;= <span class="number">10</span>)&#123;<span class="comment">//如果当前位大于10则进一位</span></span><br><span class="line">aar[j] -=<span class="number">10</span>;</span><br><span class="line">aar[j+<span class="number">1</span>] += <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//将a+b的和保存在aar数组里</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Case:"</span> &lt;&lt; i&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" + "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aar[maxlen] == <span class="number">0</span> )<span class="comment">//判断第一位是否为0,如果是的话就从第二位开始读,这个是逆序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=maxlen<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) <span class="built_in">cout</span> &lt;&lt; aar[j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=maxlen;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; aar[j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i != time)<span class="comment">//注意要求的输出格式</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i,j,y,n,k,h,p,lena,lenb;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>],b[<span class="number">1000</span>],sum[<span class="number">1000</span>],f[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> a1,b1;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(y=<span class="number">1</span>;y&lt;=n;y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a1&gt;&gt;b1;</span><br><span class="line">lena=a1.length();</span><br><span class="line">lenb=b1.length();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">a[i]=<span class="number">0</span>;b[i]=<span class="number">0</span>;f[i]=<span class="number">0</span>;<span class="comment">//f数组是记录a+b和</span></span><br><span class="line">        <span class="comment">//这个补零是先全都设为0,再把不为0的填入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=lena<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">/*1234 ==&gt; 4321*/</span></span><br><span class="line">    a[lena<span class="number">-1</span>-i]=a1[i]-<span class="string">'0'</span>;<span class="comment">//字符'9' - '0' 才是数字9</span></span><br><span class="line"><span class="keyword">for</span>(i=lenb<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    b[lenb<span class="number">-1</span>-i]=b1[i]-<span class="string">'0'</span>;</span><br><span class="line">    k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lenb || i&lt;lena;i++)&#123;<span class="comment">//i--&gt; max( lena , lenb )</span></span><br><span class="line">h=a[i]+b[i]+k;<span class="comment">//k是下一位是否进一</span></span><br><span class="line">f[i]=h%<span class="number">10</span>;<span class="comment">//f[i]必然是0-9</span></span><br><span class="line">k=h/<span class="number">10</span>;<span class="comment">//如果h大于10,则k=1,如果h小于10,则k=0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k!=<span class="number">0</span>)<span class="comment">//如果k=1,则最高位加一</span></span><br><span class="line">    f[i++]=k; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;y&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt; a1 &lt;&lt;<span class="string">" + "</span>&lt;&lt; b1 &lt;&lt;<span class="string">" = "</span>;</span><br><span class="line">p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;<span class="comment">//将之前为了计算时的倒序,再反正过来</span></span><br><span class="line"> <span class="keyword">if</span>(p==<span class="number">0</span> &amp;&amp; f[j]==<span class="number">0</span>)&#123;<span class="comment">//目的是去前导0,实则这步多余了</span></span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//如果最高位是0的话i就不会++,如果是1的话,那么f[j]就不会是0,所以这步必然是进入else</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">     p=<span class="number">1</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;f[j];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="▲总结"><a href="#▲总结" class="headerlink" title="▲总结:"></a>▲总结:</h5><ul><li>1.为什么用字符数组==&gt;因为数字太大,long long也存储不下</li><li>2.用int数组记录每一位的数字,然后模拟手算</li><li>3.为什么倒置==&gt;因为为了让末尾对齐,方便计算”个位对个位,十位对十位……”</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;HDOJ-Problem-1002-A-B-Problem-II&quot;&gt;&lt;a href=&quot;#HDOJ-Problem-1002-A-B-Problem-II&quot; class=&quot;headerlink&quot; title=&quot;HDOJ Problem 1002 - A + B Pr
      
    
    </summary>
    
    
      <category term="ACM竞赛入门" scheme="https://nymrli.top/tags/ACM%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 26. 删除排序数组中的重复项</title>
    <link href="https://nymrli.top/2018/10/18/LeetCode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>https://nymrli.top/2018/10/18/LeetCode-26-删除排序数组中的重复项/</id>
    <published>2018-10-18T03:35:36.000Z</published>
    <updated>2018-10-18T03:35:50.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-26-删除排序数组中的重复项"><a href="#LeetCode-26-删除排序数组中的重复项" class="headerlink" title="LeetCode 26. 删除排序数组中的重复项"></a>LeetCode 26. 删除排序数组中的重复项</h3><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span>。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">len</span> = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="方法：双指针法"><a href="#方法：双指针法" class="headerlink" title="方法：双指针法"></a>方法：双指针法</h4><p><strong>算法</strong></p><p>数组完成排序后，我们可以放置两个指针 i和 j，其中 i 是慢指针，而 j 是快指针。<strong>只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项</strong>。</p><p>当我们遇到 nums[j] != nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)， 假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。</li><li>空间复杂度：O(1)。</li></ul><h5 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现:"></a>Python实现:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[s] != nums[f]:</span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                nums[s] = nums[f]</span><br><span class="line">        <span class="keyword">return</span> s + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-26-删除排序数组中的重复项&quot;&gt;&lt;a href=&quot;#LeetCode-26-删除排序数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;LeetCode 26. 删除排序数组中的重复项&quot;&gt;&lt;/a&gt;LeetCode 26. 删除排
      
    
    </summary>
    
    
      <category term="ACM竞赛入门" scheme="https://nymrli.top/tags/ACM%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>素数判别</title>
    <link href="https://nymrli.top/2018/10/15/%E7%B4%A0%E6%95%B0%E5%88%A4%E5%88%AB/"/>
    <id>https://nymrli.top/2018/10/15/素数判别/</id>
    <published>2018-10-15T14:30:55.000Z</published>
    <updated>2018-10-15T14:31:57.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="素数判别"><a href="#素数判别" class="headerlink" title="素数判别"></a>素数判别</h3><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime_2</span><span class="params">( <span class="keyword">int</span> num )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> tmp =<span class="built_in">sqrt</span>( num);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">2</span>;i &lt;=tmp; i++)</span><br><span class="line">        <span class="keyword">if</span>(num %i== <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于<span class="built_in">sqrt</span>(n)，一个大于等于<span class="built_in">sqrt</span>(n)。若<span class="built_in">sqrt</span>(n)左侧找不到约数，那么右侧也一定找不到约数</span><br></pre></td></tr></table></figure><h5 id="方法二-筛选法"><a href="#方法二-筛选法" class="headerlink" title="方法二(筛选法)"></a>方法二(筛选法)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cstdio"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cstring"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100000<span class="comment">//求MAX范围内的素数</span></span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> su[MAX],cnt;</span><br><span class="line"><span class="keyword">bool</span> isprime[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(isprime,<span class="number">1</span>,<span class="keyword">sizeof</span>(isprime));<span class="comment">//初始化认为所有数都为素数</span></span><br><span class="line">    isprime[<span class="number">0</span>]=isprime[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//0和1不是素数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;i&lt;=MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isprime[i])<span class="comment">//保存素数</span></span><br><span class="line">        &#123;</span><br><span class="line">            su[cnt++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j=i*<span class="number">2</span>;j&lt;=MAX;j+=i)<span class="comment">//素数的倍数都为合数</span></span><br><span class="line">        &#123;</span><br><span class="line">            isprime[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    prime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;cnt;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,su[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法三-剪枝"><a href="#方法三-剪枝" class="headerlink" title="方法三(剪枝)"></a>方法三(剪枝)</h5><blockquote><p>证明：令x≥1，将大于等于5的自然数表示如下：</p><p><code>······ 6x-1，6x，6x+1，6x+2，6x+3，6x+4 | 6x+5，6(x+1），6(x+1)+1 ······</code></p><p>可以看到，不在6的倍数两侧，即6x两侧的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。这里有个题外话，关于孪生素数，有兴趣的道友可以再另行了解一下，由于与我们主题无关，暂且跳过。这里要注意的一点是，在6的倍数相邻两侧并不是一定就是质数。===&gt;只需判断6两侧的是不是质数(6x-1、6x+1)</p><p>此时判断质数可以6个为单元快进，即将方法（2）循环中i++步长加大为6，加快判断速度，原因是，假如要判定的数为n，则n必定是6x-1或6x+1的形式，对于循环中6i-1，6i，6i+1,6i+2，6i+3，6i+4，其中如果n能被6i，6i+2，6i+4整除，则n至少得是一个偶数，但是6x-1或6x+1的形式明显是一个奇数，故不成立；另外，如果n能被6i+3整除，则n至少能被3整除，但是6x能被3整除，故6x-1或6x+1（即n）不可能被3整除，故不成立。===&gt;综上，循环中只需要考虑6i-1和6i+1的情况(被本身更小的因数所除如22/11)，即循环的步长可以定为6，每次判断循环变量k和k+2的情况即可，理论上讲整体速度应该会是方法（2）的3倍。代码如下：</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isPrime_3( <span class="built_in">int</span> <span class="built_in">num</span> )</span><br><span class="line">&#123;</span><br><span class="line">                 <span class="comment">//两个较小数另外处理</span></span><br><span class="line">                 <span class="keyword">if</span>(<span class="built_in">num</span> ==<span class="number">2</span>|| <span class="built_in">num</span>==<span class="number">3</span> )</span><br><span class="line">                                 <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">                 <span class="comment">//不在6的倍数两侧的一定不是质数</span></span><br><span class="line">                 <span class="keyword">if</span>(<span class="built_in">num</span> %<span class="number">6</span>!= <span class="number">1</span>&amp;&amp;<span class="built_in">num</span> %<span class="number">6</span>!= <span class="number">5</span>)</span><br><span class="line">                                 <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">                 <span class="built_in">int</span> tmp =sqrt( <span class="built_in">num</span>);</span><br><span class="line">                 <span class="comment">//在6的倍数两侧的也可能不是质数</span></span><br><span class="line">                 <span class="keyword">for</span>(<span class="built_in">int</span> i= <span class="number">5</span>;i &lt;=tmp; i+=<span class="number">6</span> )</span><br><span class="line">                                 <span class="keyword">if</span>(<span class="built_in">num</span> %i== <span class="number">0</span>||<span class="built_in">num</span> %(i+ <span class="number">2</span>)==<span class="number">0</span> )</span><br><span class="line">                                                 <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">                 <span class="comment">//排除所有，剩余的是质数</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>for循环i从5开始而不是从7开始的原因</strong>:</p><p>从5、7开始的区别在于i &lt;= sqrt(num)..如果是5的话，判断条件为25；如果是7的话，判断的条件就为49。 </p><p>而仔细观察49内的所有质数，发现25之前的质数都是6k左右的数(6k-1,6k+1)，而25以后，就不定都有了。如26则不为质数。 所以如果从5开始的话，那么25以内的数 都不会进入for循环，经过<code>if(num %6!= 1&amp;&amp;num %6!= 5)</code>的筛选后，就都是素数了。 而如果是从7开始，那么25-49之内的数不符合条件却不会进入for循环，所以26缺少这个for的循环判断后就被误判为素数了。</p><p> ==&gt;以我浅薄的数学见识理解，25以内素数规律的巧合性使得 这些数不需要进入for循环判断，所以相比于从7开始的错误，5开始是正确的 </p><h5 id="给出Py代码"><a href="#给出Py代码" class="headerlink" title="给出Py代码"></a>给出Py代码</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">def prime_num(<span class="built_in">num</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">num</span> == <span class="number">2</span> <span class="keyword">or</span> <span class="built_in">num</span> == <span class="number">3</span>:</span><br><span class="line"><span class="literal">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">num</span>%<span class="number">6</span> != <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">num</span>%<span class="number">6</span>!=<span class="number">5</span>:</span><br><span class="line"><span class="literal">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>,math.ceil(math.<span class="built_in">sqrt</span>(<span class="built_in">num</span>))+<span class="number">1</span>,<span class="number">6</span>):  <span class="comment">#就剩6k-1 和 6k+1</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">num</span>%i == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">num</span>%(i<span class="number">-2</span>)==<span class="number">0</span>:</span><br><span class="line"><span class="literal">return</span> <span class="number">0</span></span><br><span class="line"><span class="literal">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>参考:<a href="https://blog.csdn.net/huang_miao_xin/article/details/51331710" target="_blank" rel="noopener">https://blog.csdn.net/huang_miao_xin/article/details/51331710</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;素数判别&quot;&gt;&lt;a href=&quot;#素数判别&quot; class=&quot;headerlink&quot; title=&quot;素数判别&quot;&gt;&lt;/a&gt;素数判别&lt;/h3&gt;&lt;h5 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法
      
    
    </summary>
    
    
      <category term="ACM竞赛入门" scheme="https://nymrli.top/tags/ACM%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>\r - \n - \r\n的区别</title>
    <link href="https://nymrli.top/2018/10/13/%E5%9B%9E%E8%BD%A6%E5%92%8C%E6%8D%A2%E8%A1%8C%E5%8C%BA%E5%88%AB/"/>
    <id>https://nymrli.top/2018/10/13/回车和换行区别/</id>
    <published>2018-10-13T12:33:33.000Z</published>
    <updated>2018-10-13T12:34:31.882Z</updated>
    
    <content type="html"><![CDATA[<h4 id="r-n-r-n-的区别"><a href="#r-n-r-n-的区别" class="headerlink" title="\r  -  \n - \r\n  的区别"></a>\r  -  \n - \r\n  的区别</h4><h5 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示:"></a>代码演示:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:              string s1 = <span class="string">"已经习惯了回车和换行一次搞定\n，敲一个回车键，即是回"</span>;</span><br><span class="line"><span class="number">2</span>:   </span><br><span class="line"><span class="number">3</span>:              Console.WriteLine(s1);</span><br><span class="line"><span class="number">4</span>:              s1 = <span class="string">"已经习惯了回车和换行一次搞定\r，敲一个回车键，即是回"</span>;</span><br><span class="line"><span class="number">5</span>:              Console.WriteLine(s1);</span><br><span class="line"><span class="number">6</span>:              s1 = <span class="string">"已经习惯了回车和换行一次搞定\r\n，敲一个回车键，即是回"</span>;</span><br><span class="line"><span class="number">7</span>:              Console.WriteLine(s1);</span><br><span class="line"><span class="number">8</span>:              Console.ReadLine();</span><br></pre></td></tr></table></figure><p>Result:==&gt;</p><p><img src="https://images0.cnblogs.com/blog/535270/201401/08141919-a381bad2fd714daea5e652c4bd18f41e.png" alt=""></p><h5 id="回车、换行的区别"><a href="#回车、换行的区别" class="headerlink" title="回车、换行的区别:"></a>回车、换行的区别:</h5><blockquote><p>\r , \n, \r\n的区别其实是回车与换行的区别 </p></blockquote><table><thead><tr><th>符号</th><th>ASCII码</th><th>意义</th></tr></thead><tbody><tr><td>\n</td><td>10</td><td>换行</td></tr><tr><td>\r</td><td>13</td><td>回车CR</td></tr></tbody></table><p><strong>先来段历史</strong></p><blockquote><p>回车”（Carriage Return）和“换行”（Line Feed）这两个概念的来历和区别。</p><p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33，Linux/Unix下的tty概念也来自于此）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p><p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。</p><p>后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。</p></blockquote><p>在Windows中：</p><p>‘\r’ 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖；</p><p>‘\n’ 换行，换到当前位置的下一行，而不会回到行首；</p><p>Unix系统里，每行结尾只有“&lt;换行&gt;”，即”\n”；Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“\r\n”；Mac系统里，每行结尾是“&lt;回车&gt;”，即”\r”；。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</p><p><code>例 $ echo -en &#39;12\n34\r56\n\r78\r\n&#39; &gt; tmp.txt</code></p><p><img src="http://img.my.csdn.net/uploads/201301/02/1357098340_3393.jpg" alt=""></p><p><img src="http://img.my.csdn.net/uploads/201301/02/1357098349_7560.jpg" alt=""></p><p>==&gt;Linux中遇到换行符(“\n”)会进行回车+换行的操作，回车符反而只会作为控制字符(“^M”)显示，不发生回车的操作。而windows中要回车符+换行符(“\r\n”)才会回车+换行，缺少一个控制符或者顺序不对都不能正确的另起一行。</p><hr><p>▲注意点：</p><p>在解析文本或其他格式的文件内容时，常常要碰到判定回车换行的地方，这个时候就要注意既要判定”**r**\n”又要判定”\n”。</p><p>写程序时可能得到一行,将其进行trim掉’**r**’,这样能得到你所需要的string了。</p><hr><h5 id="拓展程序测试"><a href="#拓展程序测试" class="headerlink" title="拓展程序测试"></a>拓展程序测试</h5><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*==========================程序二===============================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        FILE *fp;</span><br><span class="line">        <span class="keyword">if</span>((fp=fopen(<span class="string">"test.txt"</span>,<span class="string">"w"</span>)) == <span class="literal">NULL</span>)    &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"open file error\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">"test\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==========================程序二===============================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        FILE *fp;</span><br><span class="line">        <span class="keyword">if</span>((fp=fopen(<span class="string">"test.bin"</span>,<span class="string">"wb"</span>)) == <span class="literal">NULL</span>)    &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"open file error\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">"test\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>​    程序一输出文件大小是600字节，程序二输出文件大小是500字节，用记事本打开程序一的输出没有什么问题，每行一个test，打开程序二的输出发现所有的test连成一行，test之间是一个黑色方框符号分隔。用UltraEdit-32以16进制编辑模式打开test.bin可以查看到黑色方框符号就是0A也就是\n，打开test.txt则会发现换行是\r\n，这就是两个文件大小相差100字节的原因。Unix类系统用户打开windows中的文件就会遇到这种苦恼。<br>为什么会有这种区别呢？<br>     毕竟是源自Unix系统，C语言中使用\n表示换行，而在实际的文件中换行符号需要同操作系统一致，所以当我们在<strong>C中使用fopen打开一个文本文件时流实现了实际换行符与C中\n之间的转换</strong>。在windows中当我们用fopen打开文本文件，然后从中读到\r\n时流会转换为\n，而当我们往文件中写入\n时流会转换为\r\n。<strong>程序一是打开文本文件，程序二打开的是二进制文件，因为流只对文本文件进行换行表示的转换，以二进制模式打开流不会做任何处理</strong>。所以当你以二进制模式打开一个文本文件时将产生错乱，你必须亲自将\r\n解释为\n,同样的问题也会出现在以文本模式打开二进制文件的情况.这也解释了为什么Unix类系统中的文件不区分文本文件和二进制文件的原因。</p></blockquote><p>当我们使用标准输入输出函数时有这种情况吗？<br>再回到我们熟悉的标准输入输出stdin,stdout<br>​    C的控制台程序在加载进内存成为进程运行前C运行时库自动打开三个设备并关联到三个流：标准输入流stdin，标准输出流stdout，标准出错流stderr</p><p>​    通常在通用计算机中，没有重定向前这三个流对应的设备是：键盘，显示器，显示器。<strong>这三个都是字符设备，所以是以文本文件的模式打开的</strong>，在windows下当我们在键盘上敲入回车键时产生字符\r\n，但是在OS内核把键盘驱动中读到的字符发送给流的缓冲区时流会将之转换为\n，当我们向控制台输出\n时流将之转换为\r\n再传递至内核，当我们绕过标准输入输出直接调用windows中coredll.lib进行控制台输入输出时就必须面对这一现实，程序员负责实现这一转换。</p><p>摘自:<a href="https://www.cnblogs.com/xiaotiannet/p/3510586.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaotiannet/p/3510586.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;r-n-r-n-的区别&quot;&gt;&lt;a href=&quot;#r-n-r-n-的区别&quot; class=&quot;headerlink&quot; title=&quot;\r  -  \n - \r\n  的区别&quot;&gt;&lt;/a&gt;\r  -  \n - \r\n  的区别&lt;/h4&gt;&lt;h5 id=&quot;代码演示&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="编程" scheme="https://nymrli.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>云服务器Ubuntu更改默认python版本</title>
    <link href="https://nymrli.top/2018/10/12/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8Ubuntu%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4python%E7%89%88%E6%9C%AC/"/>
    <id>https://nymrli.top/2018/10/12/云服务器Ubuntu更改默认python版本/</id>
    <published>2018-10-12T05:07:48.000Z</published>
    <updated>2018-10-12T05:08:26.679Z</updated>
    
    <content type="html"><![CDATA[<h4 id="云服务器Ubuntu更改默认python版本"><a href="#云服务器Ubuntu更改默认python版本" class="headerlink" title="云服务器Ubuntu更改默认python版本"></a>云服务器Ubuntu更改默认python版本</h4><h5 id="1、基于用户修改-Python-版本："><a href="#1、基于用户修改-Python-版本：" class="headerlink" title="1、基于用户修改 Python 版本："></a><strong>1、基于用户修改 Python 版本：</strong></h5><p>想要为某个特定用户修改 Python 版本，只需要在其 home 目录下创建一个 <code>alias</code>(别名) 即可。打开该用户的 <code>~/.bashrc</code>文件，添加新的别名信息来修改默认使用的 Python 版本。</p><blockquote><p><code>vim ~/.bashrc</code></p><p>增加一行<code>alias python=python3</code></p><p><code>source ~/.bashrc</code><br>再输入<code>python --version</code>,就能发现显示的是Python 3.x啦</p></blockquote><h5 id="2、-在系统级修改-Python-版本-建议"><a href="#2、-在系统级修改-Python-版本-建议" class="headerlink" title="2、 在系统级修改 Python 版本(建议)"></a><strong>2、 在系统级修改 Python 版本</strong>(建议)</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> update-alternatives --list python</span></span><br><span class="line">update-alternatives: error: no alternatives for python</span><br></pre></td></tr></table></figure><p>如果出现以上所示的错误信息，则表示 Python 的替代版本尚未被 <code>update-alternatives</code> 命令识别。想解决这个问题，我们需要更新一下替代列表，将 <code>python2.7</code> 和 <code>python3.4</code> 放入其中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1</span></span><br><span class="line">update-alternatives: using /usr/bin/python2.7 to provide /usr/bin/python (python) in auto mode</span><br><span class="line"><span class="meta">#</span><span class="bash"> update-alternatives --install /usr/bin/python python /usr/bin/python3.4 2</span></span><br><span class="line">update-alternatives: using /usr/bin/python3.4 to provide /usr/bin/python (python) in auto mode</span><br></pre></td></tr></table></figure><blockquote><p>–install 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。这个例子中，我们为 /usr/bin/python3.4 设置的优先级为2，所以update-alternatives 命令会自动将它设置为默认 Python 版本。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 接下来，我们再次列出可用的 Python 替代版本。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> update-alternatives --list python</span></span><br><span class="line">/usr/bin/python2.7</span><br><span class="line">/usr/bin/python3.4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;云服务器Ubuntu更改默认python版本&quot;&gt;&lt;a href=&quot;#云服务器Ubuntu更改默认python版本&quot; class=&quot;headerlink&quot; title=&quot;云服务器Ubuntu更改默认python版本&quot;&gt;&lt;/a&gt;云服务器Ubuntu更改默认python
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="服务器" scheme="https://nymrli.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
</feed>
