{"meta":{"title":"果粒橙的博客","subtitle":"别装作很努力，因为结局不会陪你演戏。","description":"想和你讲，说了会心动 ，缄默会心安。","author":"果粒橙","url":"https://nymrli.top"},"pages":[{"title":"css","date":"2018-08-31T11:13:48.000Z","updated":"2018-08-31T11:19:21.810Z","comments":false,"path":"tags/index.html","permalink":"https://nymrli.top/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-08-31T07:56:42.000Z","updated":"2018-08-31T11:25:02.929Z","comments":true,"path":"about/index.html","permalink":"https://nymrli.top/about/index.html","excerpt":"","text":"本人南邮自动化本科学生一枚.热爱捣鼓计算机,涉及Python、C、Java等语言.目前在弄Apollo,未来打算弄机器学习、数据挖掘方面"},{"title":"","date":"2018-09-01T04:34:24.592Z","updated":"2018-09-01T04:34:24.592Z","comments":true,"path":"baidu_verify_05A5IQD4CU.html","permalink":"https://nymrli.top/baidu_verify_05A5IQD4CU.html","excerpt":"","text":"layout:false 05A5IQD4CU"}],"posts":[{"title":"python pywin32 PyUserInput实现自动化脚本","slug":"python-win32api-win32gui-win32con-PyUserInput实现自动化脚本","date":"2018-08-31T11:43:00.000Z","updated":"2018-08-31T11:56:56.677Z","comments":true,"path":"2018/08/31/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本/","link":"","permalink":"https://nymrli.top/2018/08/31/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本/","excerpt":"","text":"pywin32用spy++工具查找到句柄，再结合PyUserInput就能很好地实现自动化脚本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import win32guiimport win32conimport win32api# 从顶层窗口向下搜索主窗口，无法搜索子窗口# FindWindow(lpClassName=None, lpWindowName=None) 窗口类名 窗口标题名handle = win32gui.FindWindow(\"Notepad\", None) # 获取窗口位置left, top, right, bottom = win32gui.GetWindowRect(handle)#获取某个句柄的类名和标题title = win32gui.GetWindowText(handle) clsname = win32gui.GetClassName(handle)# 打印句柄# 十进制print(handle)# 十六进制print(\"%x\" %(handle) )# 搜索子窗口# 枚举子窗口hwndChildList = [] win32gui.EnumChildWindows(handle, lambda hwnd, param: param.append(hwnd), hwndChildList)# FindWindowEx(hwndParent=0, hwndChildAfter=0, lpszClass=None, lpszWindow=None) # 父窗口句柄 若不为0，则按照z-index的顺序从hwndChildAfter向后开始搜索子窗体，否则从第一个子窗体开始搜索。 子窗口类名 子窗口标题subHandle = win32gui.FindWindowEx(handle, 0, \"EDIT\", None)# 获得窗口的菜单句柄menuHandle = win32gui.GetMenu(subHandle)# 获得子菜单或下拉菜单句柄 # 参数：菜单句柄 子菜单索引号subMenuHandle = win32gui.GetSubMenu(menuHandle, 0)# 获得菜单项中的的标志符，注意，分隔符是被编入索引的 # 参数：子菜单句柄 项目索引号 menuItemHandle = win32gui.GetMenuItemID(subMenuHandle, 0)# 发送消息，加入消息队列，无返回 # 参数：句柄 消息类型 WParam IParamwin32gui.postMessage(subHandle, win32con.WM_COMMAND, menuItemHandle, 0)# wParam的定义是32位整型，high word就是他的31至16位，low word是它的15至0位。# 当参数超过两个，wParam和lParam不够用时，可以将wParam就给拆成两个int16来使用。# 这种时候在python里记得用把HIWORD的常数向左移16位，再加LOWORD，即wParam = HIWORD&lt;&lt;16+LOWORD。# 下选框内容更改# 参数：下选框句柄； 消息内容； #参数下选框的哪一个item，以0起始的待选选项的索引；如果该值为-1，将从组合框列表中删除当前选项，并使当前选项为空；# 参数CB_Handle为下选框句柄，PCB_handle下选框父窗口句柄if win32api.SendMessage(CB_handle, win32con.CB_SETCURSEL, 1, 0) == 1:# 下选框的父窗口命令# 参数：父窗口句柄； 命令； # 参数：WParam：高位表示类型，低位表示内容；参数IParam，下选框句柄# CBN_SELENDOK当用户选择了有效的列表项时发送，提示父窗体处理用户的选择。 LOWORD为组合框的ID. HIWORD为CBN_SELENDOK的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x90000, CB_handle) # CBN_SELCHANGE当用户更改了列表项的选择时发送，不论用户是通过鼠标选择或是通过方向键选择都会发送此通知。LOWORD为组合框的ID. HIWORD为CBN_SELCHANGE的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x10000, CB_handle) # 设置文本框内容，等窗口处理完毕后返回true。中文需编码成gbk # 参数：句柄；消息类型；# 参数WParam，无需使用； # 参数IParam，要设置的内容，字符串win32api.SendMessage(handle, win32con.WM_SETTEXT, 0, os.path.abspath(fgFilePath).encode('gbk'))# 控件点击确定,处理消息后返回0# 参数:窗口句柄; 消息类型; 参数WParam HIWORD为0（未使用），LOWORD为控件的ID; 参数IParam 0（未使用）,确定控件的句柄win32api.SendMessage(Mhandle, win32con.WM_COMMAND, 1, confirmBTN_handle)# 获取窗口文本不含截尾空字符的长度# 参数：窗口句柄； 消息类型； 参数WParam； 参数IParambufSize = win32api.SendMessage(subHandle, win32con.WM_GETTEXTLENGTH, 0, 0) +1# 利用api生成BufferstrBuf = win32gui.PyMakeBuffer(bufSize)print(strBuf)# 发送消息获取文本内容# 参数：窗口句柄； 消息类型；文本大小； 存储位置length = win32gui.SendMessage(subHandle, win32con.WM_GETTEXT, bufSize, strBuf)# 反向内容，转为字符串# text = str(strBuf[:-1])address, length = win32gui.PyGetBufferAddressAndLen(strBuf) text = win32gui.PyGetString(address, length) # print('text: ', text)# 鼠标单击事件#鼠标定位到(30,50)win32api.SetCursorPos([30,150])#执行左单键击，若需要双击则延时几毫秒再点击一次即可win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP | win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)#右键单击win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP | win32con.MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0)def click1(x,y): #第一种 win32api.SetCursorPos((x,y)) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,0,0) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,0,0)def click2(x,y): #第二种 ctypes.windll.user32.SetCursorPos(x,y) ctypes.windll.user32.mouse_event(2,0,0,0,0) ctypes.windll.user32.mouse_event(4,0,0,0,0)def click_it(pos): #第三种 handle= win32gui.WindowFromPoint(pos) client_pos =win32gui.ScreenToClient(handle,pos) tmp=win32api.MAKELONG(client_pos[0],client_pos[1]) win32gui.SendMessage(handle, win32con.WM_ACTIVATE,win32con.WA_ACTIVE,0) win32gui.SendMessage(handle, win32con.WM_LBUTTONDOWN,win32con.MK_LBUTTON,tmp) win32gui.SendMessage(handle, win32con.WM_LBUTTONUP,win32con.MK_LBUTTON,tmp)# 发送回车win32api.keybd_event(13,0,0,0)win32api.keybd_event(13,0,win32con.KEYEVENTF_KEYUP,0)# 关闭窗口win32gui.PostMessage(win32lib.findWindow(classname, titlename), win32con.WM_CLOSE, 0, 0)# 检查窗口是否最小化，如果是最大化if(win32gui.IsIconic(hwnd)):# win32gui.ShowWindow(hwnd, win32con.SW_SHOWNORMAL) win32gui.ShowWindow(hwnd, 8) sleep(0.5)# SW_HIDE：隐藏窗口并激活其他窗口。nCmdShow=0。# SW_MAXIMIZE：最大化指定的窗口。nCmdShow=3。# SW_MINIMIZE：最小化指定的窗口并且激活在Z序中的下一个顶层窗口。nCmdShow=6。# SW_RESTORE：激活并显示窗口。如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置。在恢复最小化窗口时，应用程序应该指定这个标志。nCmdShow=9。# SW_SHOW：在窗口原来的位置以原来的尺寸激活和显示窗口。nCmdShow=5。# SW_SHOWDEFAULT：依据在STARTUPINFO结构中指定的SW_FLAG标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递给CreateProcess函数的。nCmdShow=10。# SW_SHOWMAXIMIZED：激活窗口并将其最大化。nCmdShow=3。# SW_SHOWMINIMIZED：激活窗口并将其最小化。nCmdShow=2。# SW_SHOWMINNOACTIVE：窗口最小化，激活窗口仍然维持激活状态。nCmdShow=7。# SW_SHOWNA：以窗口原来的状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=8。# SW_SHOWNOACTIVATE：以窗口最近一次的大小和状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=4。# SW_SHOWNORMAL：激活并显示一个窗口。如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小。应用程序在第一次显示窗口的时候应该指定此标志。nCmdShow=1。 感谢python win32api win32gui win32con 窗口句柄 发送消息 常用方法 键盘输入，代码主要来自于他 ▲.需要注意在windows和mac下接口参数可能有所不同。win32虽然也可控制键盘，但不如使用PyUserInput的方便。安装PyUserInput教程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pymouse import PyMousefrom pykeyboard import PyKeyboard#实例化m = PyMouse() k = PyKeyboard()x_dim, y_dim = m.screen_size()# 鼠标点击 参数:x,y,button=1(左键)、2(右键)、3(中间),次数m.click(x_dim, y_dim, button=1,n=1) # 键盘输入 参数:str,间隔k.type_string('Hello, World!',interval=0)# 按住一个键k.press_key('H')# 松开一个键k.release_key('H')# 相当于===&gt;按住并松开，tap一个键k.tap_key('e')# tap支持重复的间歇点击键,参数:str,次数,间隔k.tap_key('l',n=2,interval=5) #创建组合键===&gt;press_key和release_key结合使用k.press_key(k.alt_key)k.tap_key(k.tab_key)k.release_key(k.alt_key)# 特殊功能键k.tap_key(k.function_keys[5]) # Tap F5k.tap_key(k.numpad_keys['Home']) # Tap 'Home' on the numpadk.tap_key(k.numpad_keys[5], n=3) # Tap 5 on the numpad, thrice# Mac系统按键k.press_keys(['Command','shift','3'])# Windows系统按键k.press_keys([k.windows_l_key,'d'])其中pymouse的PyMouseEvent和pykeyboard的PyKeyboardEvent还可用于监听鼠标和键盘事件的输入class Clickonacci(PyMouseEvent): def __init__(self): PyMouseEvent.__init__(self) self.fibo = fibo() def click(self, x, y, button, press): '''Print Fibonacci numbers when the left click is pressed.''' if button == 1: if press: print('Press times:%d'.format(press)) else: # Exit if any other mouse button used self.stop()C = Clickonacci()C.run()class TapRecord(PyKeyboardEvent): def __init__(self): PyKeyboardEvent.__init__(self) def tap(self, keycode, character, press): print(time.time(), keycode, character, press)t = TapRecord()t.run()#这些对象是一个架构用于监听鼠标和键盘的输入；他们除了监听之外不会做任何事，需要继承重构他们#PyKeyboardEvent为编写完成，所以这里是一个继承PyMouseEvent的例子：","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"Hello Hexo","slug":"hello-hexo","date":"2018-08-30T13:14:27.000Z","updated":"2018-08-31T12:24:13.509Z","comments":true,"path":"2018/08/30/hello-hexo/","link":"","permalink":"https://nymrli.top/2018/08/30/hello-hexo/","excerpt":"","text":"电脑环境是Windows，安装好git后，所有搭建操作均在git bash内完成 1.需要安装git, node.js, npm 注:第一次安装Git会让配置user信息 123&gt; $git config --global user.name \"yourname\" #（yourname是git的用户名）&gt; $git config --global user.email \"youremail\"）&gt; 2.使用npm安装hexo： npm install -g hexo 3.创建hexo文件夹，并单击鼠标右键选择 Git bash：(我的创建路径是：E:\\hexo） 4.在刚刚打开的git bash命令框中操作： 1234$hexo init #hexo 会自动创建网站所需要的文件$npm install #安装依赖包$hexo generate # 等价于hexo g$hexo server #现在可以用127.0.0.1:4000访问hexo默认的hello world界面,等价于hexo s 5.部署到github (https://github.com/)， 首先注册登录,然后创建页面仓库，Repository name 命名必须是 youname.github.io ，（youname 就是你注册时候用的name） ssh-keygen -t rsa -C &quot;email&quot; #生成ssh密钥，按三次回车键，密码为空,这边会生成id_rsa和_rsa.pub文件，打开id_rsa.pub，复制全文添加到GitHub 的Add SSH key中。 最后可以验证一下ssh -T git@github.com,看出现的是不是Hi &quot;Yourname&quot;如果出现了你的github用户名,则成功了 6.下载Hexo主题 $git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载hexo的yilia 模板到自己的文件目录下 打开项目目录下的_config.yml文件，更改theme：yilia ▲注意: _config.yml文件中配置时:后面都要加空格,与:隔开 7.开启评论功能：使用gitment $npm install gitment --save #安装gitment 然后在 https://github.com/settings/applications/new 进行注册，获取Client ID和Client Secret 打开themes/yilia目录下的_config.yml文件进行修改并保存： 再次生成网站,提交网站:hexo d -g就可以输入网址:https://yourname.github.io打开你的博客了","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://nymrli.top/tags/hexo/"}]},{"title":"Python字典基本操作介绍","slug":"Python字典基本操作介绍","date":"2018-08-30T13:14:27.000Z","updated":"2018-08-31T11:03:36.767Z","comments":true,"path":"2018/08/30/Python字典基本操作介绍/","link":"","permalink":"https://nymrli.top/2018/08/30/Python字典基本操作介绍/","excerpt":"","text":"创建字典 info={} info=dict() 初始化字典法一123key = 'name'info = &#123; key 'cold'&#125;==&#123;'name''cold'&#125; 法二12info = dict(key = 'cold')==&#123;'key''cold'&#125; 法三1#还有可以使用dict(zip(a,b))其中a,b都是列表,会生成以A中元素为键,B中元素为值的字典 插入新的键值对(更新) info.update(name=’cold’, blog=’www.linuxzen.com&#39;) 在字典有没有k这个键时可以使用dict.setdefault(key,value) 还可以使用dict(var = value)其中var可以是变量,也可以不是,注意不用加 或是_dict[‘xxx’]=’yyy’ 获得键值 确定存在的情况下- info.get(‘xxx’) info[‘xxx’] 不确定是否存在 info.get(‘xxx’) 遍历字典 获得key,再通过key来获得valuefor key in dicprint(%d,%d%(key,_dict[key])) 使用dict.items()for key,value in dic.items()print ‘key is %s,value is %s’%(key,value) 字典删除del info[&#39;xxx&#39;]","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]}]}