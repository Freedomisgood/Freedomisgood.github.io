<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>学点Kotlin · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">学点Kotlin</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2021/12/02</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Kotlin"> Kotlin</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">7,574</span> | Reading time: <span class="post-count">31</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h2 id="kotlin-基础语法"><a class="markdownIt-Anchor" href="#kotlin-基础语法"></a> Kotlin 基础语法</h2>
<p>Kotlin 文件以 .kt 为后缀。</p>
<h3 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h3>
<p>函数定义使用关键字 fun，参数格式为：参数 : 类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;   <span class="comment">// Int 参数，返回值 Int</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表达式作为函数体，返回类型自动推断：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a + b   <span class="comment">// public 方法则必须明确写出返回类型</span></span><br></pre></td></tr></table></figure>
<p>无返回值的函数(类似Java中的void)：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Unit</span> &#123; </span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> &#123; </span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可变长参数函数"><a class="markdownIt-Anchor" href="#可变长参数函数"></a> 可变长参数函数</h4>
<p>函数的变长参数可以用 <strong>vararg</strong> 关键字进行标识：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">vars</span><span class="params">(<span class="keyword">vararg</span> v:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vt <span class="keyword">in</span> v)&#123;</span><br><span class="line">        print(vt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    vars(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)  <span class="comment">// 输出12345</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lambda匿名函数"><a class="markdownIt-Anchor" href="#lambda匿名函数"></a> lambda(匿名函数)</h4>
<p>lambda表达式使用实例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sumLambda: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x,y -&gt; x+y&#125;</span><br><span class="line">    println(sumLambda(<span class="number">1</span>,<span class="number">2</span>))  <span class="comment">// 输出 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="null检查机制"><a class="markdownIt-Anchor" href="#null检查机制"></a> NULL检查机制</h3>
<p>Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型后面加?表示可为空</span></span><br><span class="line"><span class="keyword">var</span> age: String? = <span class="string">"23"</span> </span><br><span class="line"><span class="comment">// 不能为空，否则抛出空指针异常</span></span><br><span class="line"><span class="keyword">val</span> ages = age!!.toInt()</span><br><span class="line"><span class="comment">//不做处理返回 null</span></span><br><span class="line"><span class="keyword">val</span> ages1 = age?.toInt()</span><br><span class="line"><span class="comment">//age为空返回-1</span></span><br><span class="line"><span class="keyword">val</span> ages2 = age?.toInt() ?: <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。</p>
<p>当 str 中的字符串内容不是一个整数时, 返回 null:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kotlin-基本数据类型"><a class="markdownIt-Anchor" href="#kotlin-基本数据类型"></a> Kotlin 基本数据类型</h2>
<p>Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。</p>
<p><strong>Kotlin 中没有基础数据类型，只有封装的数字类型</strong>。你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所以在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。</p>
<p>在 Kotlin 中，<u>三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小</u>。</p>
<ul>
<li><code>var x = 1..16</code>:  [1,16]</li>
<li><code>var x = 1 until 16</code>: [1, 16)</li>
</ul>
<h3 id="变量和常量"><a class="markdownIt-Anchor" href="#变量和常量"></a> 变量和常量</h3>
<p>可变变量定义：var 关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span><br><span class="line"><span class="keyword">val</span> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span><br></pre></td></tr></table></figure>
<h3 id="字符串模板"><a class="markdownIt-Anchor" href="#字符串模板"></a> 字符串模板</h3>
<ul>
<li><code>$</code> 表示一个变量名或者变量值</li>
<li><code>$varName</code>表示变量值</li>
<li><code>${varName.fun()}</code>表示变量的方法返回值:</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span><span class="comment">// 模板中的简单名称：val s1 = "a is $a" a = 2// 模板中的任意表达式：val s2 = "$&#123;s1.replace("is", "was")&#125;, but now is $a"</span></span><br></pre></td></tr></table></figure>
<h2 id="kotlin-条件控制"><a class="markdownIt-Anchor" href="#kotlin-条件控制"></a> <a href="https://www.runoob.com/kotlin/kotlin-condition-control.html" target="_blank" rel="noopener">Kotlin 条件控制</a></h2>
<h2 id="kotlin-循环控制"><a class="markdownIt-Anchor" href="#kotlin-循环控制"></a> Kotlin 循环控制</h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对任何提供迭代器（iterator）的**对象**进行遍历for (item in collection) print(item)// 通过**索引**遍历一个数组或者一个 listfor (i in array.indices) &#123;    print(array[i])&#125;// 索引+值，相当于Python中的enumeratefor ((index, value) in array.withIndex()) &#123;    println("the element at $index is $value")&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while循环while( 布尔表达式 ) &#123;  //循环内容&#125;// do循环do &#123;       //代码语句&#125;while(布尔表达式);</span></span><br></pre></td></tr></table></figure>
<h3 id="返回和跳转"><a class="markdownIt-Anchor" href="#返回和跳转"></a> 返回和跳转</h3>
<p>Kotlin 有三种结构化跳转表达式：</p>
<ul>
<li><em>return</em>。默认从最直接包围它的函数或者匿名函数返回。</li>
<li><em>break</em>。终止最直接包围它的循环。</li>
<li><em>continue</em>。继续下一次最直接包围它的循环。</li>
</ul>
<h3 id="break-和-continue-的跳转标签"><a class="markdownIt-Anchor" href="#break-和-continue-的跳转标签"></a> Break 和 Continue 的跳转标签</h3>
<p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为<code>标识符+跟 @</code>，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;        <span class="keyword">if</span> (……) <span class="keyword">break</span><span class="symbol">@loop</span>    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>标签限制使得 break 跳转到刚好位于该标签指定循环的后面执行点。 continue 继续标签指定的循环的下一次迭代。</p>
<h4 id="标签处返回"><a class="markdownIt-Anchor" href="#标签处返回"></a> 标签处返回</h4>
<p>Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 <strong>标签处返回的最重要的一个用途就是从 lambda 表达式中返回</strong>。回想一下我们这么写的时候：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    ints.forEach &#123;        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span>        print(it)    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    ints.forEach <span class="symbol">lit@</span> &#123;        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@lit</span>        print(it)    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    ints.forEach &#123;        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@forEach</span>        print(it)    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    ints.forEach(<span class="function"><span class="title">fun</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;        <span class="keyword">if</span> (value == <span class="number">0</span>) <span class="keyword">return</span>        print(value)    &#125;)&#125;</span><br></pre></td></tr></table></figure>
<p>当要返一个回值的时候，解析器优先选用标签限制的 return，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return@a 1</span><br></pre></td></tr></table></figure>
<p>意为&quot;从标签 @a 返回 1&quot;，而不是&quot;返回一个标签标注的表达式 (@a 1)&quot;。</p>
<h2 id="kotlin-类和对象"><a class="markdownIt-Anchor" href="#kotlin-类和对象"></a> Kotlin 类和对象</h2>
<h3 id="类的定义"><a class="markdownIt-Anchor" href="#类的定义"></a> 类的定义</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> <span class="keyword">constructor</span></span>(name: String) &#123;    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"Foo"</span>) &#125; <span class="comment">// 成员函数    var url: String = ……            // 次构造函数    constructor (name: String, alexa: Int) : this(name) &#123;        println("Alexa 排名 $alexa")    &#125;    var lastName: String = "zhang"        get() = field.toUpperCase()   // 将变量赋值后转换为大写        set    var no: Int = 100        get() = field                // 后端变量        set(value) &#123;            if (value &lt; 10) &#123;       // 如果传入的值小于 10 返回该值                field = value            &#125; else &#123;                field = -1         // 如果传入的值大于等于 10 返回 -1            &#125;        &#125;    var heiht: Float = 145.4f        private set    &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="对象的声明"><a class="markdownIt-Anchor" href="#对象的声明"></a> 对象的声明</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> site = Runoob() <span class="comment">// Kotlin 中没有 new 关键字site.name           // 使用 . 号来引用site.url</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3>
<p>Koltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123;    init &#123;        println(<span class="string">"FirstName is <span class="variable">$firstName</span>"</span>)    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(firstName: String) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>次构造函数</p>
<p>类也可以有二级构造函数，需要加前缀 constructor:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;     constructor(parent: Person) &#123;        parent.children.add(this)     &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name: String) &#123;    constructor (name: String, age:Int) : this(name) &#123;        // 初始化...    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class DontCreateMe private constructor () &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getter-和-setter"><a class="markdownIt-Anchor" href="#getter-和-setter"></a> getter 和 setter</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]    [&lt;getter&gt;]    [&lt;setter&gt;]<span class="comment">// var变量可设置getter 和 setter, 都是可选// 如果属性类型可以从初始化语句或者类的成员函数中推断出来，那就可以省去类型，val不允许设置setter函数，因为它是只读的。var allByDefault: Int? // 错误: 需要一个初始化语句, 默认实现了 getter 和 setter 方法var initialized = 1    // 类型为 Int, 默认实现了 getter 和 setterval simple: Int?       // 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化val inferredType = 1   // 类型为 Int 类型,默认实现 getter</span></span><br></pre></td></tr></table></figure>
<h3 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h3>
<p>抽象是面向对象编程的特征之一，类本身，或类中的部分成员，都可以声明为abstract的。抽象成员在类中不存在具体的实现。</p>
<p>注意：无需对抽象类或抽象成员标注open注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class Base &#123;    open fun f() &#123;&#125;&#125;abstract class Derived : Base() &#123;    override abstract fun f()&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套类"><a class="markdownIt-Anchor" href="#嵌套类"></a> 嵌套类</h3>
<p>我们可以把类嵌套在其他类中，看以下实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;                  // 外部类    private val bar: Int = 1    class Nested &#123;             // 嵌套类        fun foo() = 2    &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h4>
<p>内部类使用 inner 关键字来表示。</p>
<p>内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span>    <span class="keyword">var</span> v = <span class="string">"成员属性"</span>    <span class="comment">/**嵌套内部类**/</span>    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar  <span class="comment">// 访问外部类成员        fun innerTest() &#123;            var o = this@Outer //获取外部类的成员变量            println("内部类可以引用外部类的成员，例如：" + o.v)        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类</h4>
<p>使用对象表达式来创建匿名内部类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    <span class="keyword">var</span> v = <span class="string">"成员属性"</span>    <span class="function"><span class="keyword">fun</span> <span class="title">setInterFace</span><span class="params">(test: <span class="type">TestInterFace</span>)</span></span> &#123;        test.test()    &#125;&#125;<span class="comment">/** * 定义接口 */</span><span class="class"><span class="keyword">interface</span> <span class="title">TestInterFace</span> </span>&#123;    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#125;<span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;    <span class="keyword">var</span> test = Test()    <span class="comment">/**     * 采用对象表达式来创建接口对象，即匿名内部类的实例。     */</span>    test.setInterFace(<span class="keyword">object</span> : TestInterFace &#123;        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;            println(<span class="string">"对象表达式创建匿名内部类的实例"</span>)        &#125;    &#125;)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类的修饰符"><a class="markdownIt-Anchor" href="#类的修饰符"></a> 类的修饰符</h3>
<p>类的修饰符包括 classModifier 和_accessModifier_:</p>
<ul>
<li>
<p>classModifier: 类属性修饰符，标示类本身特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract    // 抽象类  final       // 类不可继承，默认属性enum        // 枚举类open        // 类可继承，类默认是final的annotation  // 注解类</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>accessModifier: 访问权限修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private    // 仅在同一个文件中可见protected  // 同一个文件中或子类可见public     // 所有调用的地方都可见internal   // 同一个模块中可见</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="kotlin-继承"><a class="markdownIt-Anchor" href="#kotlin-继承"></a> Kotlin 继承</h2>
<p>Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：</p>
<p>Any 默认提供了三个函数：</p>
<ul>
<li>equals()</li>
<li>hashCode()</li>
<li>toString()</li>
</ul>
<p>注意：Any 不是 java.lang.Object。</p>
<p>如果一个类要被继承，可以使用 open 关键字进行修饰。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="built_in">Int</span>)           <span class="comment">// 定义基类class Derived(p: Int) : Base(p)</span></span><br></pre></td></tr></table></figure>
<h2 id="构造函数-2"><a class="markdownIt-Anchor" href="#构造函数-2"></a> 构造函数</h2>
<h3 id="子类有主构造函数"><a class="markdownIt-Anchor" href="#子类有主构造函数"></a> 子类有主构造函数</h3>
<p>如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class Person(var name : String, var age : Int)&#123;// 基类&#125;class Student(name : String, age : Int, var no : String, var score : Int) : Person(name, age) &#123;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123;    val s =  Student(&quot;Runoob&quot;, 18, &quot;S12346&quot;, 89)    println(&quot;学生名： $&#123;s.name&#125;&quot;)    println(&quot;年龄： $&#123;s.age&#125;&quot;)    println(&quot;学生号： $&#123;s.no&#125;&quot;)    println(&quot;成绩： $&#123;s.score&#125;&quot;)&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生名： Runoob年龄： 18学生号： S12346成绩： 89</span><br></pre></td></tr></table></figure>
<h3 id="子类没有主构造函数"><a class="markdownIt-Anchor" href="#子类没有主构造函数"></a> 子类没有主构造函数</h3>
<p>如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person &#123;    constructor</span></span>(ctx: Context) : <span class="keyword">super</span>(ctx) &#123;    &#125;     <span class="keyword">constructor</span>(ctx: Context, attrs: AttributeSet) : <span class="keyword">super</span>(ctx,attrs) &#123;    &#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h3>
<p>在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**用户基类**/</span><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">study</span><span class="params">()</span></span>&#123;       <span class="comment">// 允许子类重写        println("我毕业了")    &#125;&#125;/**子类继承 Person 类**/class Student : Person() &#123;    override fun study()&#123;    // 重写方法        println("我在读大学")    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val s =  Student()    s.study();&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果有多个相同的方法（继承或者实现自其他类，如A、B类），则必须要重写该方法，使用super范型去选择性地调用父类的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class A &#123;    open fun f () &#123; print(&quot;A&quot;) &#125;    fun a() &#123; print(&quot;a&quot;) &#125;&#125;interface B &#123;    fun f() &#123; print(&quot;B&quot;) &#125; //接口的成员变量默认是 open 的    fun b() &#123; print(&quot;b&quot;) &#125;&#125;class C() : A() , B&#123;    override fun f() &#123;        super&lt;A&gt;.f()//调用 A.f()        super&lt;B&gt;.f()//调用 B.f()    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val c =  C()    c.f();&#125;</span><br></pre></td></tr></table></figure>
<p>C 继承自 a() 或 b(), C 不仅可以从 A 或则 B 中继承函数，而且 C 可以继承 A()、B() 中共有的函数。此时该函数在中只有一个实现，为了消除歧义，该函数必须调用A()和B()中该函数的实现，并提供自己的实现。</p>
<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AB</span><br></pre></td></tr></table></figure>
<h3 id="属性重写"><a class="markdownIt-Anchor" href="#属性重写"></a> 属性重写</h3>
<p>属性重写使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class Foo &#123;    open val x: Int get &#123; …… &#125;&#125;class Bar1 : Foo() &#123;    override val x: Int = ……&#125;</span><br></pre></td></tr></table></figure>
<p>注：可以用一个var属性重写一个val属性，但是反过来不行。</p>
<h2 id="kotlin-接口"><a class="markdownIt-Anchor" href="#kotlin-接口"></a> Kotlin 接口</h2>
<h3 id="接口定义"><a class="markdownIt-Anchor" href="#接口定义"></a> 接口定义</h3>
<p>Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>    <span class="comment">// 未实现    fun foo() &#123;  //已实现      // 可选的方法体      println("foo")    &#125;    // 接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性：    var name:String //name 属性, 抽象的&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="实现接口"><a class="markdownIt-Anchor" href="#实现接口"></a> 实现接口</h3>
<p>一个类或者对象可以实现一个或多个接口。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;    override fun bar</span></span>() &#123;        <span class="comment">// 方法体    &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="kotlin-扩展"><a class="markdownIt-Anchor" href="#kotlin-扩展"></a> Kotlin 扩展</h2>
<blockquote>
<p>Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。</p>
<p>扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。</p>
</blockquote>
<h3 id="将函数扩展"><a class="markdownIt-Anchor" href="#将函数扩展"></a> 将函数扩展</h3>
<p>扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式：</p>
<ul>
<li>receiverType：表示函数的接收者，也就是函数扩展的对象</li>
<li>functionName：扩展函数的名称</li>
<li>params：扩展函数的参数，可以为NULL</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数扩展原型fun receiverType.functionName(params)&#123;    body&#125;class User(var name:String)/**扩展函数**/fun User.Print()&#123;    print("用户名 $name")&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="扩展函数是静态解析的"><a class="markdownIt-Anchor" href="#扩展函数是静态解析的"></a> 扩展函数是静态解析的</h4>
<p>扩展函数是<strong>静态解析</strong>的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由<strong>调用函数的的对象表达式来决定</strong>的，而不是动态的类型决定的:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Cclass</span> <span class="title">D</span>: <span class="type">C</span></span>()<span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span>   <span class="comment">// 扩展函数 foofun D.foo() = "d"   // 扩展函数 foofun printFoo(c: C) &#123;    println(c.foo())  // 类型是 C 类&#125;fun main(arg:Array&lt;String&gt;)&#123;    printFoo(D())&#125;// 输出c</span></span><br></pre></td></tr></table></figure>
<p>若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。</p>
<h3 id="扩展一个空对象"><a class="markdownIt-Anchor" href="#扩展一个空对象"></a> 扩展一个空对象</h3>
<p>在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun Any?.toString(): String &#123;    if (this == null) return &quot;null&quot;    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()    // 解析为 Any 类的成员函数    return toString()&#125;fun main(arg:Array&lt;String&gt;)&#123;    var t = null    println(t.toString())&#125;</span><br></pre></td></tr></table></figure>
<p>实例执行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null</span><br></pre></td></tr></table></figure>
<p>扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val Foo.bar = 1 // 错误：扩展属性不能有初始化器</span><br></pre></td></tr></table></figure>
<p>扩展属性只能被声明为 val。</p>
<h3 id="伴生对象的扩展"><a class="markdownIt-Anchor" href="#伴生对象的扩展"></a> 伴生对象的扩展</h3>
<blockquote>
<p>伴生对象内的成员相当于 Java 中的静态成员，其生命周期伴随类始终，在伴生对象内部可以定义变量和函数，这些变量和函数可以直接用类名引用。</p>
</blockquote>
<p>如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性。</p>
<p>伴生对象通过&quot;类名.&quot;形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;    companion object &#123; &#125;  // 将被称为 &quot;Companion&quot;&#125;fun MyClass.Companion.foo() &#123;    println(&quot;伴随对象的扩展函数&quot;)&#125;val MyClass.Companion.no: Int    get() = 10fun main(args: Array&lt;String&gt;) &#123;    println(&quot;no:$&#123;MyClass.no&#125;&quot;)    MyClass.foo()&#125;</span><br></pre></td></tr></table></figure>
<p>实例执行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no:10伴随对象的扩展函数</span><br></pre></td></tr></table></figure>
<p>注：对于伴生对象扩展函数，有两种形式，一种是在类内扩展，一种是在类外扩展，这两种形式扩展后的函数互不影响（甚至名称都可以相同），即使名称相同，它们也完全是两个不同的函数，并且有以下特点：</p>
<ul>
<li>（1）类内扩展的伴随对象函数和类外扩展的伴随对象可以同名，它们是两个独立的函数，互不影响；</li>
<li>（2）当类内扩展的伴随对象函数和类外扩展的伴随对象同名时，类内的其它函数优先引用类内扩展的伴随对象函数，即对于类内其它成员函数来说，类内扩展屏蔽类外扩展；</li>
<li>（3）类内扩展的伴随对象函数只能被类内的函数引用，不能被类外的函数和伴随对象内的函数引用；</li>
<li>（4）类外扩展的伴随对象函数可以被伴随对象内的函数引用，；</li>
</ul>
<h2 id="kotlin-对象表达式和对象声明"><a class="markdownIt-Anchor" href="#kotlin-对象表达式和对象声明"></a> Kotlin 对象表达式和对象声明</h2>
<h2 id="对象表达式"><a class="markdownIt-Anchor" href="#对象表达式"></a> 对象表达式</h2>
<p>通过对象表达式实现一个匿名内部类的对象用于方法的参数中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;        <span class="comment">// ...    &#125;    override fun mouseEntered(e: MouseEvent) &#123;        // ...    &#125;&#125;)</span></span><br></pre></td></tr></table></figure>
<h3 id="对象声明"><a class="markdownIt-Anchor" href="#对象声明"></a> 对象声明</h3>
<blockquote>
<p>Kotlin 使用 object 关键字来声明一个对象。</p>
<p>Kotlin 中我们可以方便的通过<strong>对象object声明</strong>来获得一个单例。</p>
</blockquote>
<p>当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;    <span class="keyword">var</span> name = <span class="string">"菜鸟教程"</span>    <span class="keyword">object</span> DeskTop&#123;        <span class="keyword">var</span> url = <span class="string">"www.runoob.com"</span>        <span class="function"><span class="keyword">fun</span> <span class="title">showName</span><span class="params">()</span></span>&#123;            print&#123;<span class="string">"desk legs <span class="variable">$name</span>"</span>&#125; <span class="comment">// 错误，不能访问到外部类的方法和变量        &#125;    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    var site = Site()    site.DeskTop.url // 错误，不能通过外部类的实例访问到该对象    Site.DeskTop.url // 正确, 类似静态内部类，这个类是属于外部类的，而不是某个实例&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="伴生对象"><a class="markdownIt-Anchor" href="#伴生对象"></a> 伴生对象</h3>
<p>类内部的对象声明可以用 <code>companion</code> 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。</p>
<h3 id="对象表达式和对象声明之间的语义差异"><a class="markdownIt-Anchor" href="#对象表达式和对象声明之间的语义差异"></a> 对象表达式和对象声明之间的语义差异</h3>
<p>对象表达式和对象声明之间有一个重要的语义差别：</p>
<ul>
<li>对象表达式是在使用他们的地方立即执行的</li>
<li>对象声明是在第一次被访问到时延迟初始化的</li>
<li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配</li>
</ul>
<h2 id="kotlin-委托"><a class="markdownIt-Anchor" href="#kotlin-委托"></a> kotlin 委托</h2>
<blockquote>
<p><a href="https://www.runoob.com/w3cnote/delegate-mode.html" target="_blank" rel="noopener">委托模式</a>是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。</p>
<p>Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。</p>
</blockquote>
<h3 id="类委托"><a class="markdownIt-Anchor" href="#类委托"></a> 类委托</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建接口interface Base &#123;       fun print()&#125;// 实现此接口的被委托的类class BaseImpl(val x: Int) : Base &#123;    override fun print() &#123; print(x) &#125;&#125;// 通过关键字 by 建立委托类class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) &#123;    val b = BaseImpl(10)    Derived(b).print() // 输出 10&#125;</span></span><br></pre></td></tr></table></figure>
<p>在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。</p>
<h3 id="属性委托"><a class="markdownIt-Anchor" href="#属性委托"></a> 属性委托</h3>
<p>属性委托指的是一个<strong>类的某个属性值</strong>不是在类中直接进行定义，而是将<strong>其托付给一个代理类</strong>，从而实现对该类的属性统一管理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty<span class="comment">// 定义包含属性委托的类class Example &#123;    var p: String by Delegate()    // val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;&#125;// 委托的类class Delegate &#123;    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;        return "$thisRef, 这里委托了 $&#123;property.name&#125; 属性"    &#125;    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;        println("$thisRef 的 $&#123;property.name&#125; 属性赋值为 $value")    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val e = Example()    println(e.p)     // 访问该属性，调用 getValue() 函数    e.p = "Runoob"   // 调用 setValue() 函数    println(e.p)&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="标准委托"><a class="markdownIt-Anchor" href="#标准委托"></a> 标准委托</h3>
<p>Kotlin 的标准库中已经内置了很多工厂方法来实现属性的委托。</p>
<h4 id="延迟属性-lazy"><a class="markdownIt-Anchor" href="#延迟属性-lazy"></a> 延迟属性 Lazy</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lazyValue: String <span class="keyword">by</span> lazy &#123;    println(<span class="string">"computed!"</span>)     <span class="comment">// 第一次调用输出，第二次调用不执行    "Hello"&#125;fun main(args: Array&lt;String&gt;) &#123;    println(lazyValue)   // 第一次执行，执行两次输出表达式    println(lazyValue)   // 第二次执行，只输出返回值&#125;/*computed!HelloHello*/</span></span><br></pre></td></tr></table></figure>
<h4 id="可观察属性-observable"><a class="markdownIt-Anchor" href="#可观察属性-observable"></a> 可观察属性 Observable</h4>
<blockquote>
<p>observable 可以用于实现观察者模式。</p>
<p>Delegates.observable() 函数接受两个参数: 第一个是初始化值, 第二个是属性值变化事件的响应器(handler)。</p>
<p>在属性赋值后会执行事件的响应器(handler)，它有三个参数：被赋值的属性、旧值和新值：</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegatesclass User &#123;    <span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">"初始值"</span>) &#123;        prop, old, new -&gt;        println(<span class="string">"旧值：<span class="variable">$old</span> -&gt; 新值：<span class="variable">$new</span>"</span>)    &#125;&#125;<span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;    <span class="keyword">val</span> user = User()    user.name = <span class="string">"第一次赋值"</span>    user.name = <span class="string">"第二次赋值"</span>&#125;<span class="comment">/*旧值：初始值 -&gt; 新值：第一次赋值旧值：第一次赋值 -&gt; 新值：第二次赋值*/</span></span><br></pre></td></tr></table></figure>
<h4 id="把属性储存在映射中"><a class="markdownIt-Anchor" href="#把属性储存在映射中"></a> 把属性储存在映射中</h4>
<h4 id="not-null"><a class="markdownIt-Anchor" href="#not-null"></a> Not Null</h4>
<p>notNull 适用于那些无法在初始化阶段就确定属性值的场合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;    var notNullBar: String by Delegates.notNull&lt;String&gt;()&#125;foo.notNullBar = &quot;bar&quot;println(foo.notNullBar)</span><br></pre></td></tr></table></figure>
<p>需要注意，如果属性在赋值前就被访问的话则会抛出异常。</p>
<h4 id="局部委托属性"><a class="markdownIt-Anchor" href="#局部委托属性"></a> 局部委托属性</h4>
<p>你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun example(computeFoo: () -&gt; Foo) &#123;    val memoizedFoo by lazy(computeFoo)    if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123;        memoizedFoo.doSomething()    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。</p>
<h3 id="属性委托要求"><a class="markdownIt-Anchor" href="#属性委托要求"></a> 属性委托要求</h3>
<p>对于只读属性(也就是说val属性), 它的委托必须提供一个名为getValue()的函数。该函数接受以下参数：</p>
<ul>
<li>thisRef —— 必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型</li>
<li>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型</li>
</ul>
<p>这个函数必须返回与属性相同的类型（或其子类型）。</p>
<p>对于一个值可变(mutable)属性(也就是说,var 属性),除 getValue()函数之外,它的委托还必须 另外再提供一个名为setValue()的函数, 这个函数接受以下参数:</p>
<p>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型new value —— 必须和属性同类型或者是它的超类型。</p>
<h3 id="提供委托"><a class="markdownIt-Anchor" href="#提供委托"></a> 提供委托</h3>
<h1 id="附"><a class="markdownIt-Anchor" href="#附"></a> 附：</h1>
<h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h2>
<h3 id="构造函数-3"><a class="markdownIt-Anchor" href="#构造函数-3"></a> 构造函数</h3>
<p>Kotlin 中构造函数分为<strong>主构造函数</strong>和**次构造函数，**主构造函数只能有一个，次构造函数个数不限制，可以有一个或者多个。</p>
<ul>
<li>主构造函数就是类后的小括号中定义的，会定义类有哪些数据成员并初始化。——然而那一些初始化的方法该怎么调用呢==&gt; 在init{}中编写需要在主构造函数中完成的业务</li>
<li>而次构造函数需要用constructor关键字来声明。</li>
</ul>
<p>基础概念：</p>
<ul>
<li><a href="https://www.jianshu.com/p/fc54d2241ba7" target="_blank" rel="noopener">Kotlin 构造函数、继承</a></li>
</ul>
<p>进阶：</p>
<ul>
<li><a href="https://www.codeleading.com/article/33773156838/" target="_blank" rel="noopener">kotlin的主构造函数, 次构造函数, init代码块, 伴生对象的执行顺序, 特点, 使用场景, 及跟java的比较</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Person(var name: String, var age: Int) &#123;</span><br><span class="line">    <span class="comment">// 次构造函数中传入了主构造函数中没有的数据成员的时候，需要在这里定义</span></span><br><span class="line">    var sex: Boolean?=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(<span class="string">"main constructor init $&#123;name&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(name:String, age: Int, sexy: Boolean): <span class="keyword">this</span>(name, age)&#123;</span><br><span class="line">        println(<span class="string">"constructor"</span>)</span><br><span class="line">        <span class="keyword">this</span>.sex = sexy</span><br><span class="line">        println(<span class="keyword">this</span>.sex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataClassTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function">fun <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        val person = Person(name = <span class="string">"a"</span>, age = <span class="number">12</span>)</span><br><span class="line">        println(person.age)</span><br><span class="line">        println(<span class="string">"________________________"</span>)</span><br><span class="line">        val person2 = Person(name = <span class="string">"b"</span>, age = <span class="number">14</span>, sexy = <span class="keyword">false</span>)</span><br><span class="line">        println(person2.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">main constructor init a</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">________________________</span></span><br><span class="line"><span class="comment">main constructor init b</span></span><br><span class="line"><span class="comment">constructor</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol>
<li>默认情况下class是有不带参数的主构造函数， 当class具有有参的构造函数时， 无参的就会失效， 除非参数全有默认值。如果在定义了上述构造函数的情况下， 输入Person(), idea会提示报错，并提示如下Person类有如下构造函数。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/309640/1628758129977-581aaa97-2f71-4e17-91f8-a1fb3765b529.png" alt="img"></p>
<p>但如果将主构造函数的参数全部设置为null，即<code>class Person(var name: String? =null, var age: Int? = null)</code>， 那么就可以直接创建不带参数的对象了, <code>var person0 = Person();</code></p>
<ol>
<li>
<p>主构造函数的参数如果使用了var或val修饰符，就相当于在类中声明了对应名称的属性。</p>
</li>
<li>
<p>Kotlin 中规定，当一个类既有主构造函数又有次构造函数时，所有次构造函数都<strong>必须使用<strong><strong>this</strong></strong>关键字直接或间接的调用主构造函数</strong>（间接指多层调用次构造函数）：</p>
</li>
<li>
<p>调用顺序:  ( 伴生对象成员变量初始化 -&gt; 伴生对象的init )-&gt; ( 主构造函数的参数赋值  -&gt; init 代码块 ) -&gt; 次构造函数代码块</p>
</li>
</ol>
<h4 id="throwable-kotlin-demo"><a class="markdownIt-Anchor" href="#throwable-kotlin-demo"></a> Throwable kotlin demo:</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Throwable</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> message: String?, <span class="keyword">open</span> <span class="keyword">val</span> cause: Throwable?) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(message: String?) : <span class="keyword">this</span>(message, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(cause: Throwable?) : <span class="keyword">this</span>(cause?.toString(), cause)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="data-class数据类"><a class="markdownIt-Anchor" href="#data-class数据类"></a> data class数据类</h3>
<p>在 Kotlin 中，不需要自己动手去写一个 JavaBean，可以直接使用 DataClass，使用 DataClass 编译器会默默地帮我们生成以下函数</p>
<ul>
<li>equals()</li>
<li>hashCode()</li>
<li>toString()</li>
<li>componentN()</li>
<li>copy()</li>
</ul>
<p>定义一个： <code>dataclassCountry(var id: Int,var name: String,var continent: String)</code></p>
<p>如何申明一个简单的数据类？ 有一下几点要求：</p>
<ul>
<li>
<p>主构造函数必须要<strong>至少有一个参数</strong></p>
</li>
<li>
<p>在主构造函数中的所有参数必须被标记为val或者var （var就表示可读写，val就表示只读）</p>
</li>
<li>
<p>数据类不能有以下修饰符：abstract，inner ,open, sealed  ==》 数据类本身是不能被继承的 final</p>
</li>
<li>
<p>data class只能实现接口（Kotlin1.1以前的规则），现在也可以继承其它类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(<span class="string">"daf_FiledDetail"</span>)</span><br><span class="line"><span class="meta">@ApiModel</span>(<span class="string">"字段类型表"</span>)</span><br><span class="line"><span class="function">data class <span class="title">FiledDetail</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @ApiModelProperty(<span class="string">"字段名称"</span>)</span></span></span><br><span class="line"><span class="function">     val name: String,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    @<span class="title">ApiModelProperty</span><span class="params">(<span class="string">"字段类型"</span>)</span></span></span><br><span class="line"><span class="function">     val type: FieldTypeEnum,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    @<span class="title">ApiModelProperty</span><span class="params">(<span class="string">"选项"</span>)</span></span></span><br><span class="line"><span class="function">     val choices: String,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    @<span class="title">ApiModelProperty</span><span class="params">(<span class="string">"字段分组"</span>)</span></span></span><br><span class="line"><span class="function">     val fieldGroup: String</span></span><br><span class="line"><span class="function">): <span class="title">MongoTableBean</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class DataClassTest </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function">fun <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        val filedDetail = FiledDetail(<span class="string">"name"</span>, FieldTypeEnum.ADMINISTRATIVE, <span class="string">"YES"</span>, <span class="string">"NO"</span>)</span><br><span class="line">        println(filedDetail)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h2>
<ul>
<li>序列化和反序列化其实就是方便传输对象.</li>
<li>这里是需要在几个系统 Service 里通过 Bundle 传递数据.</li>
<li>Parcelable 全部都在内存,效率高,<s>需要实现部分多,使用繁琐.</s>(在 kotlin 不成立)</li>
<li>Serializable 实现简单,但是是基于反射实现的,故有性能损失,但是是最通用的.</li>
</ul>
<h1 id="kotlin-中class-data-class-object-companion-object区别"><a class="markdownIt-Anchor" href="#kotlin-中class-data-class-object-companion-object区别"></a> Kotlin 中class、data class、object、companion object区别</h1>
<h3 id="data-class"><a class="markdownIt-Anchor" href="#data-class"></a> data class：</h3>
<p>kotlin中的数据类，只保存一些数据字段，类似于java bean，oc中的model。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">yourClassName</span></span>(			<span class="comment">// 这边是小括号</span></span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> sex: <span class="built_in">Boolean</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="object"><a class="markdownIt-Anchor" href="#object"></a> object：</h3>
<p>kotlin中使用&quot;<strong>object</strong>&quot;修饰静态类，可用于util工具类中。</p>
<ul>
<li>对象声明（object declaration）
<ul>
<li>将类的声明和定义该类的单例对象结合在一起（即通过object就实现了单例模式）</li>
<li>对象声明中不能包含构造器（包括主构造器和次级构造器）</li>
</ul>
</li>
<li>伴生对象（companion object）</li>
<li>对象表达式（object expression）</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> UserUtil &#123;</span><br><span class="line">    <span class="keyword">val</span> guoji = <span class="string">"中国"</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"小红"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="伴生对象companion-object"><a class="markdownIt-Anchor" href="#伴生对象companion-object"></a> 伴生对象（companion object）</h3>
<blockquote>
<p>因为在kotlin中是没有static关键字的，也就意味着没有静态方法和静态成员。那么在kotlin中如果想要表达这种概念，可以使用包级别函数（package-level funcation）和伴生对象（companion object）。</p>
</blockquote>
<p>伴生对象语法形式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 伴生对象名可以省略，默认为Companion</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> 伴生对象名 &#123;</span><br><span class="line">        <span class="comment">// define field and method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>from ： <a href="https://www.jianshu.com/p/1a0cf2ca87cc" target="_blank" rel="noopener">Kotlin：object关键字总结</a></li>
</ul>
<h3 id="相应结果封装类"><a class="markdownIt-Anchor" href="#相应结果封装类"></a> 相应结果封装类：</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sucsoft.dispatch.utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sucsoft.daf.enums.OperationEnum</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mrli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 结果返回封装类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/8/6 13:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>(<span class="keyword">var</span> <span class="keyword">data</span>: Any? = <span class="literal">null</span>, <span class="keyword">var</span> code: <span class="built_in">Int</span>? = <span class="literal">null</span>, <span class="keyword">var</span> message: String? =<span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">of</span><span class="params">(<span class="keyword">data</span>: <span class="type">Any</span>, code: <span class="type">Int</span>, message: <span class="type">String</span>)</span></span>: Result &#123;</span><br><span class="line">            <span class="keyword">return</span> Result(<span class="keyword">data</span>, code, message)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">make</span><span class="params">(<span class="keyword">data</span>: <span class="type">Any</span>?, op: <span class="type">OperationEnum</span>)</span></span>: Result &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (<span class="literal">null</span> == <span class="keyword">data</span>) <span class="keyword">this</span>.err(op.cn) <span class="keyword">else</span> <span class="keyword">this</span>.ok(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">ok</span><span class="params">(<span class="keyword">data</span>: <span class="type">Any</span>)</span></span>: Result &#123;</span><br><span class="line">            <span class="keyword">return</span> of(<span class="keyword">data</span>, <span class="number">200</span>, OperationEnum.SUCCESS.cn)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">err</span><span class="params">(msg: <span class="type">String</span>)</span></span>: Result &#123;</span><br><span class="line">            <span class="keyword">return</span> of(&#123;&#125;, <span class="number">500</span>, msg)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">badRequest</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">            <span class="keyword">return</span> of(&#123;&#125;, <span class="number">400</span>, OperationEnum.PARAM_ERROR.cn)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">serverError</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">            <span class="keyword">return</span> of(&#123;&#125;, <span class="number">500</span>, OperationEnum.SERVER_ERROR.cn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="踩坑"><a class="markdownIt-Anchor" href="#踩坑"></a> 踩坑：</h3>
<ul>
<li>swagger里面不填时，对应传的值为空， 因此需要对应接口的参数类型上是否能接受空?, （即比在写swagger（required）上比java对写个对类型的限制），</li>
</ul>
<p><img src="/2021/09/13/学点Kotlin/C:%5CUsers%5Cmrli%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210817152123083.png" alt="image-20210817152123083"></p>
<ul>
<li>data class 中字段的定义， 如果需要默认值则<code>sortNum : Int = 0</code>, 而对于String的话，如果是不可为空写成 <code>id :String,</code>即可，如果为空则定义为<code>id: String?</code>， 至于之后的默认值还是根据需求来看。</li>
</ul>
<h3 id="和的区分"><a class="markdownIt-Anchor" href="#和的区分"></a> ?. 和?:的区分</h3>
<p>code1?.code2   翻译为 ：if code1 Not Null 执行 code2;<br>
code1?:code2   翻译为：if code1 Null 执行 code2;<br>
?. 翻译为： <code>If Not Null</code><br>
?: 翻译为： <code>If Null</code></p>
<p>注意点：</p>
<p>【?.】后面的方法是前者的相关调用<br>
【?:】后面的方法与前者的无关调用</p>
<p>?.表示当前对象如果为空则不执行，<br>
!!.表示当前对象如果为空也执行，然后会抛出空异常</p>
<h2 id="open"><a class="markdownIt-Anchor" href="#open"></a> open</h2>
<p>在 Java 中，一个类除了被手动加上 <strong>final</strong> 关键字以外，它总能能被任意一个类继承并重写它的非 final 方法，这就可能会导致某些子类出现不符合其父类的设计初衷，特别是在多人协作的开发环境下。</p>
<p>这类问题被 Kotlin 语言设计者注意到了并切引起了他们的重视，因此，在 Kotlin 中的<strong>类和方法默认都是 final 的</strong>，如果要继承或者重写一个<strong>类和其方法</strong>时，必须将他们都显式地声明为 <strong>open</strong> , 成员变量不需要，会自动认为是open 的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name : String = <span class="string">""</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"yes"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="抛弃-java-改用-kotlin-的六个月后我后悔了"><a class="markdownIt-Anchor" href="#抛弃-java-改用-kotlin-的六个月后我后悔了"></a> <a href="https://blog.csdn.net/csdnnews/article/details/80746096" target="_blank" rel="noopener">抛弃 Java 改用 Kotlin 的六个月后，我后悔了</a>——Kotlin特性有哪些？</h1>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2021/09/13/学点Kotlin/">https://nymrli.top/2021/09/13/学点Kotlin/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2021/09/21/docker部署springboot项目/" title="docker部署springboot项目"><span>< PreviousPost</span><br><span class="prevTitle">docker部署springboot项目</span></a><a class="nextSlogan" href="/2021/09/09/ZJU开学摸底考试——操作系统复习/" title="ZJU开学摸底考试——操作系统复习"><span>NextPost ></span><br><span class="nextTitle">ZJU开学摸底考试——操作系统复习</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '学点Kotlin',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><span>备案号:苏ICP备18015439号</span></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin-基础语法"><span class="toc-number">1.</span> <span class="toc-text"> Kotlin 基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数定义"><span class="toc-number">1.1.</span> <span class="toc-text"> 函数定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#可变长参数函数"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 可变长参数函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda匿名函数"><span class="toc-number">1.1.2.</span> <span class="toc-text"> lambda(匿名函数)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null检查机制"><span class="toc-number">1.2.</span> <span class="toc-text"> NULL检查机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin-基本数据类型"><span class="toc-number">2.</span> <span class="toc-text"> Kotlin 基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变量和常量"><span class="toc-number">2.1.</span> <span class="toc-text"> 变量和常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串模板"><span class="toc-number">2.2.</span> <span class="toc-text"> 字符串模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin-条件控制"><span class="toc-number">3.</span> <span class="toc-text"> Kotlin 条件控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin-循环控制"><span class="toc-number">4.</span> <span class="toc-text"> Kotlin 循环控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#返回和跳转"><span class="toc-number">4.1.</span> <span class="toc-text"> 返回和跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break-和-continue-的跳转标签"><span class="toc-number">4.2.</span> <span class="toc-text"> Break 和 Continue 的跳转标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#标签处返回"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 标签处返回</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin-类和对象"><span class="toc-number">5.</span> <span class="toc-text"> Kotlin 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类的定义"><span class="toc-number">5.1.</span> <span class="toc-text"> 类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的声明"><span class="toc-number">5.2.</span> <span class="toc-text"> 对象的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">5.3.</span> <span class="toc-text"> 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getter-和-setter"><span class="toc-number">5.4.</span> <span class="toc-text"> getter 和 setter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-number">5.5.</span> <span class="toc-text"> 抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套类"><span class="toc-number">5.6.</span> <span class="toc-text"> 嵌套类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内部类"><span class="toc-number">5.6.1.</span> <span class="toc-text"> 内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#匿名内部类"><span class="toc-number">5.6.2.</span> <span class="toc-text"> 匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的修饰符"><span class="toc-number">5.7.</span> <span class="toc-text"> 类的修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin-继承"><span class="toc-number">6.</span> <span class="toc-text"> Kotlin 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数-2"><span class="toc-number">7.</span> <span class="toc-text"> 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#子类有主构造函数"><span class="toc-number">7.1.</span> <span class="toc-text"> 子类有主构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子类没有主构造函数"><span class="toc-number">7.2.</span> <span class="toc-text"> 子类没有主构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写"><span class="toc-number">7.3.</span> <span class="toc-text"> 重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性重写"><span class="toc-number">7.4.</span> <span class="toc-text"> 属性重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin-接口"><span class="toc-number">8.</span> <span class="toc-text"> Kotlin 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接口定义"><span class="toc-number">8.1.</span> <span class="toc-text"> 接口定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现接口"><span class="toc-number">8.2.</span> <span class="toc-text"> 实现接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin-扩展"><span class="toc-number">9.</span> <span class="toc-text"> Kotlin 扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将函数扩展"><span class="toc-number">9.1.</span> <span class="toc-text"> 将函数扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展函数是静态解析的"><span class="toc-number">9.1.1.</span> <span class="toc-text"> 扩展函数是静态解析的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展一个空对象"><span class="toc-number">9.2.</span> <span class="toc-text"> 扩展一个空对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#伴生对象的扩展"><span class="toc-number">9.3.</span> <span class="toc-text"> 伴生对象的扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin-对象表达式和对象声明"><span class="toc-number">10.</span> <span class="toc-text"> Kotlin 对象表达式和对象声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象表达式"><span class="toc-number">11.</span> <span class="toc-text"> 对象表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象声明"><span class="toc-number">11.1.</span> <span class="toc-text"> 对象声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#伴生对象"><span class="toc-number">11.2.</span> <span class="toc-text"> 伴生对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象表达式和对象声明之间的语义差异"><span class="toc-number">11.3.</span> <span class="toc-text"> 对象表达式和对象声明之间的语义差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin-委托"><span class="toc-number">12.</span> <span class="toc-text"> kotlin 委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类委托"><span class="toc-number">12.1.</span> <span class="toc-text"> 类委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性委托"><span class="toc-number">12.2.</span> <span class="toc-text"> 属性委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准委托"><span class="toc-number">12.3.</span> <span class="toc-text"> 标准委托</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#延迟属性-lazy"><span class="toc-number">12.3.1.</span> <span class="toc-text"> 延迟属性 Lazy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可观察属性-observable"><span class="toc-number">12.3.2.</span> <span class="toc-text"> 可观察属性 Observable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#把属性储存在映射中"><span class="toc-number">12.3.3.</span> <span class="toc-text"> 把属性储存在映射中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#not-null"><span class="toc-number">12.3.4.</span> <span class="toc-text"> Not Null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#局部委托属性"><span class="toc-number">12.3.5.</span> <span class="toc-text"> 局部委托属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性委托要求"><span class="toc-number">12.4.</span> <span class="toc-text"> 属性委托要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提供委托"><span class="toc-number">12.5.</span> <span class="toc-text"> 提供委托</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附"><span class="toc-number"></span> <span class="toc-text"> 附：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin"><span class="toc-number">1.</span> <span class="toc-text"> Kotlin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数-3"><span class="toc-number">1.1.</span> <span class="toc-text"> 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#throwable-kotlin-demo"><span class="toc-number">1.1.1.</span> <span class="toc-text"> Throwable kotlin demo:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data-class数据类"><span class="toc-number">1.2.</span> <span class="toc-text"> data class数据类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#序列化"><span class="toc-number">2.</span> <span class="toc-text"> 序列化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kotlin-中class-data-class-object-companion-object区别"><span class="toc-number"></span> <span class="toc-text"> Kotlin 中class、data class、object、companion object区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#data-class"><span class="toc-number">0.1.</span> <span class="toc-text"> data class：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object"><span class="toc-number">0.2.</span> <span class="toc-text"> object：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#伴生对象companion-object"><span class="toc-number">0.3.</span> <span class="toc-text"> 伴生对象（companion object）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相应结果封装类"><span class="toc-number">0.4.</span> <span class="toc-text"> 相应结果封装类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#踩坑"><span class="toc-number">0.5.</span> <span class="toc-text"> 踩坑：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#和的区分"><span class="toc-number">0.6.</span> <span class="toc-text"> ?. 和?:的区分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#open"><span class="toc-number">1.</span> <span class="toc-text"> open</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#抛弃-java-改用-kotlin-的六个月后我后悔了"><span class="toc-number"></span> <span class="toc-text"> 抛弃 Java 改用 Kotlin 的六个月后，我后悔了——Kotlin特性有哪些？</span></a></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>