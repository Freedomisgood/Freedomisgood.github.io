<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>2022年5月劳动节爬虫项目记录 · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">2022年5月劳动节爬虫项目记录</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2022/05/07</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="爬虫"> 爬虫</a><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Python"> Python</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">11,013</span> | Reading time: <span class="post-count">46</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="鱼"><a class="markdownIt-Anchor" href="#鱼"></a> 鱼</h1>
<h2 id="retry模块"><a class="markdownIt-Anchor" href="#retry模块"></a> retry模块</h2>
<p>retry是一个用于错误处理的模块，功能类似try-except，但可以更加快捷方便的设置重试的次数，以及每次重试之间相隔的时间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@retry()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_trouble</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''Retry until succeed'''</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'retrying...'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>exceptions：传入指定的错误类型，默认为Exception，即捕获所有类型的错误，也可传入<strong>元组形式的多种指定错误类型</strong>。</p>
</li>
<li>
<p>tries：定义捕获错误之后重复运行次数，默认为-1，即为无数次。</p>
</li>
<li>
<p>delay：定义每次重复运行之间的停顿时长，单位秒，默认为0，即无停顿。</p>
</li>
<li>
<p>backoff：呈指数增长的每次重复运行之间的停顿时长，需要配合delay来使用，譬如delay设置为3，backoff设置为2，则第一次间隔为<code>3*2^0=3</code>秒，第二次<code>3*2^1=6</code>秒，第三次<code>3*2^2</code>=12秒，以此类推，默认为1。</p>
</li>
<li>
<p>max_delay：定义backoff和delay配合下出现的最大等待时间上限，当</p>
<p><code>delay*backoff**n</code>大于max_delay时，等待间隔固定为该值而不再增长。</p>
</li>
</ul>
<h2 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h2>
<blockquote>
<p>关于项目结构组织。由于Python在执行程序时，会自动将<code>.</code>即当前路径加入到库搜索路径，所以当下路径下的包（文件夹下有<code>__init__.py</code>）都能被检测到使用，如下面的handler、helper都可以直接在其他文件里通过<code>helper.xxx</code>来调用，但是顶层的<code>settings.py</code>不能通过<code>feiyu_shoot.settings</code>来调用，即使feiyu_shoot工程下也有<code>__init__.py</code>，因为项目工程的上层目录并没有加入到Python环境搜索中，所以他实际不知道谁是<code>feiyu_shoot</code></p>
<p>因此，根据这种设计，可以将项目结构组织成两种</p>
</blockquote>
<ol>
<li>
<p>不依赖子模块的放在root目录的top接口：需要被其他文件引用的列入文件夹中作为库使用，不需要被引用的可以直接放顶层</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># helper/runner.py</span></span><br><span class="line"><span class="comment"># handler/ 在.下作为包导入</span></span><br><span class="line"><span class="keyword">from</span> handler imoprt ConfigHandler</span><br><span class="line"><span class="comment"># settings.py 在.下作为模块导入</span></span><br><span class="line"><span class="keyword">from</span> settings <span class="keyword">import</span> USER_AGENT</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/02/2022年5月劳动节爬虫项目记录/F:%5CaDevelopment%5CPython%5CpythonGitProject%5Cfeiyu_shoot%5Cdebugs%5CtopFile.jpg" alt="topFile"></p>
</li>
<li>
<p>★将入口放在最外层，核心内容作为单独一个文件夹（模块）：由于feiyu是个整体的包，所以在feiyu下的任意Python文件中都可以通过<code>from feiyu.xxx import yyy</code>来导入。</p>
</li>
</ol>
<p><img src="/2022/05/02/2022年5月劳动节爬虫项目记录/F:%5CaDevelopment%5CPython%5CpythonGitProject%5Cfeiyu_shoot%5Cdebugs%5ConeEntry.jpg" alt="oneEntry"></p>
<p>根据<a href="https://www.jianshu.com/p/e33b4f0373bc" target="_blank" rel="noopener">Python打包利器：auto-py-to-exe</a>中打包计算机程序的方式，更推荐第二种，这样代码资源文件位置更统一，也更加清晰一些。</p>
<p>more： [Python中模块、包、库定义](</p>
<h2 id="pyinstaller"><a class="markdownIt-Anchor" href="#pyinstaller"></a> pyinstaller</h2>
<blockquote>
<p>自我学Python以来推荐的就是这个，经过时光变迁，这个仍然是主流。</p>
<ul>
<li>PyInstaller是<strong>一个跨平台</strong>的Python应用打包工具，支持 Windows/Linux/MacOS三大主流平台，能够把 Python 脚本及其所在的 Python 解释器打包成可执行文件，从而允许最终用户在无需安装 Python 的情况下执行应用程序。</li>
<li>PyInstaller 制作出来的<strong>执行文件并不是跨平台的</strong>，如果需要为不同平台打包，就要在相应平台上运行PyInstaller进行打包。</li>
<li>PyInstaller打包的流程：读取编写好的Python项目–&gt;分析其中条用的模块和库，并收集其文件副本（包括Python的解释器）–&gt;将副本和Python项目文件（放在一个文件夹//封装在一个可执行文件）中。</li>
</ul>
</blockquote>
<p>安装就不细说了，主要讲用法：</p>
<ul>
<li>
<p>通过命令行命令打包<code>pyinstaller -F main.py</code>，常用参数</p>
<ul>
<li>-F： 表示生成单个可执行文件；对应的是-D： 生成文件夹形式的可执行程序（默认）</li>
<li>-w： 表示去掉控制台窗口，这在GUI界面时非常有用。不过如果是命令行程序的话那就把这个选项删除吧！</li>
<li>-p： 表示你自己自定义需要加载的库路径，一般情况下用不到</li>
<li>-i： 表示可执行文件的图标</li>
</ul>
</li>
<li>
<p>通过<code>.spec</code>打包定义文件来打包，对应命令行的参数，<code>.spec</code>文件都会有对应的生成内容。</p>
<blockquote>
<p>首先根据main文件生成spec文件: <code>pyi-makespec -D main.py</code>、填写好后再<code>pyinstaller main.spec</code></p>
</blockquote>
<ul>
<li>-D是让spec中多一个coll的实例，从而变成文件夹</li>
<li><code>-i</code>相当于<code>.spec</code>中EXE中<code>icon=&quot;.\\debugs\\favicon.ico&quot;</code></li>
<li>…(更多spec文件参数选择见：<a href="https://blog.csdn.net/tangfreeze/article/details/112240342" target="_blank" rel="noopener">https://blog.csdn.net/tangfreeze/article/details/112240342</a>)</li>
<li>-p: 相当于Analysis实例中的<code>pathex</code>，就是填入自己的模块</li>
<li>–hiden-import: 相当于Analysis实例中的hiddenimports</li>
</ul>
</li>
</ul>
<p>实际上，根据命令行的参数会生成对应的<code>.spec</code>文件。</p>
<p>注：可以看到无论是<code>pyinstaller</code>、<code>pyi-makespec</code>后面都是<code>main.py</code>，因为其是main函数入口文件</p>
<p>附：根据feiyu，在此列两个可行的：</p>
<ul>
<li>
<p><code>F:\aDevelopment\Python\ShowYourCode\env\Scripts\pyinstaller.exe main.py --add-data=&quot;feiyu\push_config.ini;.\feiyu&quot; --add-data=&quot;feiyu\user_config.toml;.\feiyu&quot; -i debugs\favicon.ico</code></p>
</li>
<li>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- mode: python ; coding: utf-8 -*-</span></span><br><span class="line">block_cipher = <span class="keyword">None</span> <span class="comment"># 此处在使用--key= 会有变化</span></span><br><span class="line"></span><br><span class="line">a = Analysis([<span class="string">'ai\\main.py'</span>],</span><br><span class="line">             pathex=[<span class="string">'C:\\Users\\Admin\\Downloads\\marsai-master'</span>],</span><br><span class="line">             binaries=[],</span><br><span class="line">             datas=[],<span class="comment"># 此处可以添加静态资源，例如你有个图片文件夹imgs，可以这样写[('imgs','imgs'),('test.txt','.')]，打包以后会有一个一样的文件夹，点表示当前文件夹。</span></span><br><span class="line">             hiddenimports=[],</span><br><span class="line">             hookspath=[],</span><br><span class="line">             runtime_hooks=[],</span><br><span class="line">             excludes=[],</span><br><span class="line">             win_no_prefer_redirects=<span class="keyword">False</span>,</span><br><span class="line">             win_private_assemblies=<span class="keyword">False</span>,</span><br><span class="line">             cipher=block_cipher,</span><br><span class="line">             noarchive=<span class="keyword">False</span>)</span><br><span class="line">pyz = PYZ(a.pure, a.zipped_data,</span><br><span class="line">             cipher=block_cipher)</span><br><span class="line">exe = EXE(pyz,</span><br><span class="line">          a.scripts,</span><br><span class="line">          [],</span><br><span class="line">          exclude_binaries=<span class="keyword">True</span>,</span><br><span class="line">          name=<span class="string">'main'</span>, <span class="comment"># 生成的exe的名字</span></span><br><span class="line">          debug=<span class="keyword">False</span>,</span><br><span class="line">          bootloader_ignore_signals=<span class="keyword">False</span>,</span><br><span class="line">          strip=<span class="keyword">False</span>,</span><br><span class="line">          upx=<span class="keyword">True</span>, <span class="comment"># 打包的时候进行压缩，False表示不压缩</span></span><br><span class="line">          console=<span class="keyword">True</span> <span class="comment"># 是否显示黑窗口，刚开始打包的时候一般都会有问题，建议设为True，解决所有问题后可以设置为False)</span></span><br><span class="line">coll = COLLECT(exe,</span><br><span class="line">               a.binaries,</span><br><span class="line">               a.zipfiles,</span><br><span class="line">               a.datas,</span><br><span class="line">               strip=<span class="keyword">False</span>,</span><br><span class="line">               upx=<span class="keyword">True</span>,</span><br><span class="line">               upx_exclude=[],</span><br><span class="line">               name=<span class="string">'main'</span> <span class="comment"># 文件夹的名字)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>pyinstaller全都是控制台的命令，因此没那么直观，有人做了GUI相对直白、简单些，见<a href="https://www.jianshu.com/p/e33b4f0373bc" target="_blank" rel="noopener">Python打包利器：auto-py-to-exe</a>，其关于计算器程序与<code>Additional Files</code>的使用会让人对项目该如果布置结构和使用<code>-p</code>参数有个更确信的认识（导入自己些的模块）。</p>
<h2 id="dataclass"><a class="markdownIt-Anchor" href="#dataclass"></a> dataclass</h2>
<h4 id="dataclasses嵌套"><a class="markdownIt-Anchor" href="#dataclasses嵌套"></a> dataclasses嵌套</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nested_dataclass</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(cls)</span>:</span></span><br><span class="line">        cls = dataclass(cls, **kwargs)</span><br><span class="line">        original_init = cls.__init__</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">                <span class="comment"># 注意__annotations__属性</span></span><br><span class="line">                field_type = cls.__annotations__.get(name, <span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">if</span> is_dataclass(field_type) <span class="keyword">and</span> isinstance(value, dict):</span><br><span class="line">                    new_obj = field_type(**value)</span><br><span class="line">                    kwargs[name] = new_obj</span><br><span class="line">                <span class="keyword">if</span> isinstance(value, list) <span class="keyword">and</span> is_dataclass(field_type[<span class="number">0</span>]):</span><br><span class="line">                    res = []</span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> value:</span><br><span class="line">                        new_obj = field_type[<span class="number">0</span>](**c)</span><br><span class="line">                        res.append(new_obj)</span><br><span class="line">                    kwargs[name] = res</span><br><span class="line">            original_init(self, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        cls.__init__ = __init__</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    <span class="keyword">return</span> wrapper(args[<span class="number">0</span>]) <span class="keyword">if</span> args <span class="keyword">else</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="meta">@nested_dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TagResult</span>:</span></span><br><span class="line">    <span class="string">"""拍卖展示的分页结果"""</span></span><br><span class="line">    <span class="comment"># 当前页下具体商品的信息</span></span><br><span class="line">    content: [Content]</span><br><span class="line">	<span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p><code>**</code>解包得到的额外信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 额外信息</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_kwargs</span><span class="params">(cls, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># split the kwargs into native ones and new ones</span></span><br><span class="line">        native_args, new_args = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> cls.__annotations__:</span><br><span class="line">                native_args[name] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_args[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># use the native ones to create the class ...</span></span><br><span class="line">        ret = cls(**native_args)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ... and add the new ones by hand</span></span><br><span class="line">        <span class="keyword">for</span> new_name, new_val <span class="keyword">in</span> new_args.items():</span><br><span class="line">            setattr(ret, new_name, new_val)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="keyword">return</span> Goods.from_kwargs(**resp) <span class="keyword">if</span> resp <span class="keyword">else</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<p><code>pydantic.dataclasses.dataclass</code>是<code>dataclasses.dataclass with validation</code>的替代品, 而不是<code>pydantic.BaseModel</code> 的替代品（在初始化挂钩的工作方式上有一点不同），在某些情况下，将<code>pydanticis.BaseModel</code>子类化是更好的选择.</p>
<h2 id="toml语法学习"><a class="markdownIt-Anchor" href="#toml语法学习"></a> toml语法学习</h2>
<blockquote>
<p>TOML是前GitHub CEO， Tom Preston-Werner，于2013年创建的语言，其目标是成为一个小规模的易于使用的语义化配置文件格式.TOML是大小写敏感的，必须是UTF-8编码。</p>
</blockquote>
<h3 id="toml对象"><a class="markdownIt-Anchor" href="#toml对象"></a> toml对象</h3>
<p><strong>字符串</strong>：跟python中一样，<code>&quot;&quot;&quot;</code>、<code>&quot;</code>、<code>'</code>、<code>'''</code></p>
<p><strong>注释</strong>：<code>#</code></p>
<p><strong>数组</strong>：数组使用方括号包裹。空格会被忽略，包括换行符。元素使用逗号分隔。</p>
<p><strong>日期时间</strong>：toml中日期是一等公民，跟数组一样</p>
<p><strong>键值对</strong></p>
<blockquote>
<p>TOML 文档的主要构建块</p>
</blockquote>
<ul>
<li><strong>键</strong>可以是裸露的<strong>裸键</strong>，也可以是被包裹在一对 <code>&quot;</code> 的内部的<strong>引用键</strong>。<strong>裸键</strong>只能存在字母、数字、下划线和破折号（<code>a-z、A-Z、0-9、-</code>）。注意，<strong>裸键</strong>可以只由数字组成，例如 <code>1234</code>，但它总是被解析为字符串。<strong>引用键</strong>遵循与<strong>基本字符串</strong>或<strong>字面字符串</strong>完全相同的规范，并允许使用更广泛的键名称。最好的做法是使用<strong>裸键</strong>，除非必要情况。</li>
<li><em>值<strong>可以是以下类型：<strong>字符串</strong>、<strong>整数</strong>、<strong>浮点数</strong>、<strong>布尔值</strong>、<strong>时间</strong>、<strong>数组</strong>或</strong>内联表</em>*。未确定的值是非法的。</li>
<li>注：<strong>键</strong>和<strong>值</strong>周围的空白符忽略不计，<strong>键</strong>、<code>=</code> 和<strong>值</strong>必须位于同一行</li>
</ul>
<p><strong>表格</strong></p>
<ul>
<li>
<p>空表是允许的，只要里面没有键值对就行了。</p>
</li>
<li>
<p><strong>表不能定义多于一次</strong>，不允许使用 <code>[table]</code> 头重定义这样的表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 不要这样做</span><br><span class="line"></span><br><span class="line">[fruit]</span><br><span class="line">apple = &quot;红&quot;</span><br><span class="line"></span><br><span class="line">[fruit]</span><br><span class="line">orange = &quot;橙&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>同样地，使用点分隔键来重定义已经以 <code>[table]</code> 形式定义过的表也是不允许的。</p>
</li>
<li>
<p>不过，<code>[table]</code> 形式可以被用来定义通过点分隔键定义的表中的<strong>子表</strong>。</p>
</li>
<li>
<p>不鼓励无序地定义表，即同级别子表建议放在一起定义</p>
</li>
</ul>
<p><strong>内联表</strong>：</p>
<blockquote>
<p>内联表提供了一种更为<strong>紧凑的语法</strong>来表示表。</p>
<p>内联表被完整地定义在花括号之中：<code>{</code> 和 <code>}</code>。 括号中，可以出现零或更多个以逗号分隔的键值对。</p>
</blockquote>
<ul>
<li>内联表得出现在同一行内。</li>
<li>内联表中，最后一对键值对后<strong>不允许终逗号</strong>（也称为尾逗号）。</li>
<li>不允许花括号中出现任何换行，除非在值中它们合法。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span> = &#123; first = <span class="string">"Tom"</span>, last = <span class="string">"Preston-Werner"</span> &#125;</span><br><span class="line"><span class="attr">point</span> = &#123; x = <span class="number">1</span>, y = <span class="number">2</span> &#125;</span><br><span class="line"><span class="attr">animal</span> = &#123; type.name = <span class="string">"pug"</span> &#125;</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="section">[name]</span></span><br><span class="line"><span class="attr">first</span> = <span class="string">"Tom"</span></span><br><span class="line"><span class="attr">last</span> = <span class="string">"Preston-Werner"</span></span><br><span class="line"><span class="section">[point]</span></span><br><span class="line"><span class="attr">x</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">y</span> = <span class="number">2</span></span><br><span class="line"><span class="section">[animal]</span></span><br><span class="line">type.name = "pug"</span><br></pre></td></tr></table></figure>
<p>实际上就是表的另一种紧凑写法，定义的还是表</p>
<p><strong><a href="https://toml.io/cn/v1.0.0#%E8%A1%A8%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">表数组</a></strong></p>
<blockquote>
<p>表头的第一例定义了这个数组及其首个表元素，而后续的每个则在该数组中创建并定义一个新的表元素。<br>
这些表按出现顺序插入该数组。</p>
<p>首先是个数组；其次，数组中的元素为表内容。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[products]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"Hammer"</span></span><br><span class="line"><span class="attr">sku</span> = <span class="number">738594937</span></span><br><span class="line"><span class="section">[[products]]</span>  <span class="comment"># 数组里的空表</span></span><br><span class="line"><span class="section">[[products]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"Nail"</span></span><br><span class="line"><span class="attr">sku</span> = <span class="number">284758393</span></span><br><span class="line"><span class="attr">color</span> = <span class="string">"gray"</span></span><br><span class="line"><span class="comment"># 等价于 JSON 的如下结构。</span></span><br><span class="line">&#123;</span><br><span class="line">  "products": [</span><br><span class="line">    &#123; "name": "Hammer", "sku": 738594937 &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">    &#123; "name": "Nail", "sku": 284758393, "color": "gray" &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📖<a href="https://toml.io/cn/v1.0.0#%E8%A1%A8" target="_blank" rel="noopener">Tom 的（语义）明显、（配置）最小化的语言——中文手册</a></p>
<p>库：</p>
<ul>
<li>
<p>Python：toml</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> toml</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserConfigHandler</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(USER_PARAM_FILE, <span class="string">'r'</span>, encoding=<span class="string">"utf8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            self.r = toml.load(f)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Go: <code>go get github.com/BurntSushi/toml</code></p>
</li>
</ul>
<h2 id="自用抢购尝试"><a class="markdownIt-Anchor" href="#自用抢购尝试"></a> 自用抢购尝试</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order_auction_goods</span><span class="params">(self, goodsId: int, goodsName: str = <span class="string">""</span>, by_fail_time=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    立刻抢拍, 提供①指定尝试次数; ②直到没抢到为止 两种策略</span></span><br><span class="line"><span class="string">    @param by_fail_time: 失败次数重试 or 不断重试</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    tryTimes = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> by_fail_time:</span><br><span class="line">        resp = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 3次重试</span></span><br><span class="line">        <span class="keyword">while</span> tryTimes &lt; self.config.userConfig.maxFailCount:</span><br><span class="line">            data = &#123;</span><br><span class="line">                <span class="string">'goodsId'</span>: str(goodsId),</span><br><span class="line">            &#125;</span><br><span class="line">            resp = self._post(self.URL.orderAuctionGoods, data=data, timeout=self.config.timeoutTime)</span><br><span class="line">            <span class="keyword">if</span> resp.get(<span class="string">"code"</span>) != <span class="number">0</span>:</span><br><span class="line">                tryTimes += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 抢购成功说明有</span></span><br><span class="line">                resp.update(&#123;<span class="string">"goodsId"</span>: str(goodsId), <span class="string">"goodsName"</span>: str(goodsName)&#125;)</span><br><span class="line">                <span class="keyword">return</span> resp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        resp = &#123;&#125;</span><br><span class="line">        <span class="comment"># 3次重试</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> resp.get(<span class="string">"msg"</span>) <span class="keyword">or</span> <span class="string">"规定时间内抢拍"</span> <span class="keyword">in</span> resp.get(<span class="string">"msg"</span>):</span><br><span class="line">            data = &#123;</span><br><span class="line">                <span class="string">'goodsId'</span>: str(goodsId),</span><br><span class="line">            &#125;</span><br><span class="line">            resp = self._post(self.URL.orderAuctionGoods, data=data, timeout=self.config.timeoutTime)</span><br><span class="line">            tryTimes += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 抢购成功 resp.get("result") == true</span></span><br><span class="line">            <span class="keyword">if</span> resp.get(<span class="string">"result"</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    resp.update(&#123;<span class="string">"goodsId"</span>: goodsId, <span class="string">"goodsName"</span>: goodsName&#125;)</span><br><span class="line">    <span class="keyword">return</span> resp, tryTimes</span><br></pre></td></tr></table></figure>
<h1 id="base数据库"><a class="markdownIt-Anchor" href="#base数据库"></a> base数据库</h1>
<h2 id="判断重定向"><a class="markdownIt-Anchor" href="#判断重定向"></a> 判断重定向</h2>
<blockquote>
<p>由于有个需求是，没有investor就不进行爬取，而是否有investor可以通过<code>https://xxxx.com/company_finance/investors</code>会不会进行重定向进行判断</p>
</blockquote>
<p>那么如何判断是否发生重定向呢？两种</p>
<ol>
<li>禁止<code>requests.get</code>的<code>allow_redirect</code>属性<br>
1.</li>
<li>运行<code>allow_redirect</code>，然后通过重定向history查看</li>
</ol>
<h2 id="图片懒加载"><a class="markdownIt-Anchor" href="#图片懒加载"></a> 图片懒加载</h2>
<blockquote>
<p>图片懒加载是一种网页优化技术。图片作为一种网络资源，在被请求时也与普通静态资源一样，将占用网络资源，而一次性将整个页面的所有图片加载完，将大大增加<strong>页面的首屏加载时间</strong>。为了解决这种问题，通过前后端配合，使图片仅在浏览器当前视窗内出现时才加载该图片，达到减少首屏图片请求数的技术就被称为“图片懒加载”——优先加载网页结构，以及逻辑脚本，等重要内容全部加载完成之后再加载重要优先级低一些的图片资源（同时也比较耗网络资源），是一个从用户体验上进行分层的技术。</p>
</blockquote>
<p><strong>网站一般如何实现图片懒加载技术呢？</strong></p>
<p>在网页源码中，在img标签中首先会使用一个“<code>伪属性</code>”（通常使用<code>src2</code>、<code>origin</code>……）去存放真正的图片链接而并非是直接存放在src属性中。当图片出现到页面的可视化区域中，会动态将伪属性替换成src属性，完成图片的加载。</p>
<p>比如：<a href="https://blog.csdn.net/weixin_38507813/article/details/100010232" target="_blank" rel="noopener">站长素材案例后续分析</a>：通过细致观察页面的结构后发现，网页中图片的链接是存储在了src2这个伪属性中。</p>
<p>因此针对爬取这类图片而言，可以</p>
<ol>
<li>找到要爬取图片的位置（网页上的位置）</li>
<li>查看该网址的链接img_url</li>
<li>查看网页源代码，Ctrl+F后文本搜索该图片链接img_url</li>
<li>如果3没有则在开发者工具中Ctrl+F搜索带img_url的资源</li>
<li>如果是3，则通过找到的真正的xpath路径获取，或者re提取；如果是4则模仿接口去请求图片</li>
</ol>
<h3 id="本项目案例"><a class="markdownIt-Anchor" href="#本项目案例"></a> 本项目案例</h3>
<h2 id="pathlib库使用"><a class="markdownIt-Anchor" href="#pathlib库使用"></a> pathlib库使用</h2>
<ul>
<li>
<p>获得当前脚本的绝对路径:<code>Path(__file__).resolve()</code></p>
</li>
<li>
<p>获得当前脚本所在目录的绝对路径: <code>Path(__file__).resolve().parent</code></p>
</li>
<li>
<p>根据路径创建文件夹: <code>LOG_PATH = Path(__file__).resolve().with(&quot;logs&quot;)</code>–&gt;<code>./logs/</code>，<code>LOG_PATH.mkdir(parents=True, exist_ok=True)</code>，</p>
<ul>
<li>parents:如果父目录不存在，是否创建父目录，即支持递归创建</li>
<li>exist_ok：只有在目录不存在时创建目录，目录已存在时不会抛出异常。</li>
</ul>
</li>
<li>
<p>获得当前路径下的所有文件(遍历文件夹): <code>[path for path in example_path.iterdir()]</code></p>
</li>
<li>
<p>返回目录中最后一个部分的扩展名：<code>Path('/Users/Anders/Documents/abc.gif').suffix</code></p>
</li>
<li>
<p>返回目录中多个扩展名列表： <code>Path('/Users/Anders/Documents/abc.tar.gz').suffixes</code></p>
</li>
<li>
<p>返回目录中最后一个部分的文件名: <code>Path('/Users/Anders/Documents/abc.gif').name</code></p>
</li>
<li>
<p>返回目录中最后一个部分的文件名（但是不包含后缀）: <code>Path('/Users/Anders/Documents/abc.gif').stem</code></p>
</li>
<li>
<p><strong>文件操作</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example_path = Path(<span class="string">'/Users/Anders/Documents/information/JH.txt'</span>)</span><br><span class="line"><span class="comment"># 以open的形式</span></span><br><span class="line"><span class="keyword">with</span> example_path.open(encoding = <span class="string">'GB2312'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="comment"># 或者直接用pathlib提供的获取内容的方式</span></span><br><span class="line">example_path = Path(<span class="string">'/Users/Anders/Documents/information/JH.txt'</span>)</span><br><span class="line">example_path.read_text(encoding=<span class="string">'GB2312'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>.read_text(): 以文本模式打开路径并并以字符串形式返回内容。</p>
</li>
<li>
<p>.read_bytes(): 以二进制/字节模式打开路径并以字节串的形式返回内容。</p>
</li>
<li>
<p>.write_text(): 打开路径并向其写入字符串数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">'data.json'</span>)</span><br><span class="line">path.write_text(<span class="string">'&#123;"id": 123, "name": "James"&#125;'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>.write_bytes(): 以二进制/字节模式打开路径并向其写入数据。</p>
</li>
</ul>
</li>
</ul>
<p>参考：<a href="https://blog.csdn.net/itanders/article/details/88754606" target="_blank" rel="noopener">https://blog.csdn.net/itanders/article/details/88754606</a></p>
<h2 id="按住验证码"><a class="markdownIt-Anchor" href="#按住验证码"></a> 按住验证码</h2>
<p>该网站对频率检测十分敏感，很快就会出现&quot;按住&quot;验证码，模拟按住倒不难，但是按完以后有时并不能解决验证…</p>
<p>但是意外发现，在“无痕模式”下进行重新登录后，就可以解决验证…但是通过requests进行模拟登录后cookies还是无效。</p>
<p>🌟记录一下这个问题，之后看看有没有时间弄清楚这个问题。</p>
<p><strong>解决方案</strong>：</p>
<blockquote>
<p>既然模拟不行，那么就手动，因此想用selenium来模拟点击登陆。但是因为俄罗斯的问题，无法登陆。</p>
</blockquote>
<p><img src="/2022/05/02/2022年5月劳动节爬虫项目记录/E:%5Chexo%5Csource_posts%5C2022%E5%B9%B45%E6%9C%88%E5%8A%B3%E5%8A%A8%E8%8A%82%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%5C%E8%A2%AB%E5%B0%81.jpg" alt="被封"></p>
<p>于是只好更换selenium为pyppeteer。之前就听说了pyppeteer是可以代替selenium的模拟神器，相比Selenium 不太方便的地方：比如速度太慢、对版本配置要求严苛，最麻烦是经常要更新对应的驱动，还有些网页是可以检测到是否使用了Selenium ，pyppeteer都有提升，这次也借机会学习一下。</p>
<blockquote>
<p>安装：<code>pip install pyppeteer</code>, 需要Python3.6以上（因为用了async）</p>
</blockquote>
<h3 id="pyppeteer"><a class="markdownIt-Anchor" href="#pyppeteer"></a> pyppeteer</h3>
<p>最简单demo：打开网页，并截图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 启动浏览器</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(headless=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># 打开并跳转页面</span></span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://example.com'</span>)</span><br><span class="line">    <span class="comment"># 截图</span></span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123;<span class="string">'path'</span>: <span class="string">'example.png'</span>&#125;)</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>
<p>执行JS，相当于requests-html中的render</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dimensions = <span class="keyword">await</span> page.evaluate(<span class="string">'''() =&gt; &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">        width: document.documentElement.clientWidth,</span></span><br><span class="line"><span class="string">        height: document.documentElement.clientHeight,</span></span><br><span class="line"><span class="string">        deviceScaleFactor: window.devicePixelRatio,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'''</span>)</span><br><span class="line"></span><br><span class="line">print(dimensions)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; &#123;'width': 800, 'height': 600, 'deviceScaleFactor': 1&#125;</span></span><br><span class="line"><span class="keyword">await</span> browser.close()</span><br></pre></td></tr></table></figure>
<p><strong>元素选择器</strong>：</p>
<p><code>Page.querySelector()</code>/<code>Page.querySelectorAll()</code>/<code>Page.xpath()</code>缩写为<code>Page.J()</code>, <code>Page.JJ()</code>, and <code>Page.Jx()</code>.</p>
<p>xpath进阶：</p>
<ul>
<li>starts-with 顾名思义，匹配一个属性开始位置的关键字</li>
<li>contains 匹配一个属性值中包含的<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">字符串</a></li>
<li><code>text()</code> 匹配的是显示文本信息： <code>//a[contains(text(), &quot;百度搜索&quot;)]</code></li>
</ul>
<p><a href="https://blog.csdn.net/weixin_48615832/article/details/107319268" target="_blank" rel="noopener">xpath的contains用法</a></p>
<p><strong>元素操作：点击、输入</strong></p>
<ul>
<li><code>pyppeteer.input.Mouse</code>
<ul>
<li><code>click(x: float*, y: float, options: dict = None*, ***kwargs)</code>
<ul>
<li><code>button</code> (str): <code>left</code>, <code>right</code>, or <code>middle</code>, defaults to <code>left</code>：
<ul>
<li>右键点击：<code>await page.click('a#cccccc',{&quot;button&quot;: &quot;right&quot;})</code></li>
</ul>
</li>
<li><code>clickCount</code> (int): defaults to 1.</li>
<li><code>delay</code> (int|float): Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</li>
</ul>
</li>
<li><code>down</code>(options: dict = None, *<em>kwargs</em>) `</li>
<li><code>button</code> (str): <code>left</code>, <code>right</code>, or <code>middle</code>, defaults to <code>left</code>.</li>
<li><code>clickCount</code> (int): defaults to 1.</li>
<li><code>move(x: float, y: float, options: dict = None, **kwargs*)</code></li>
<li><code>p(options: dict = None, **kwargs*)</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用xpath</span></span><br><span class="line"><span class="keyword">await</span> page.waitForXPath(<span class="string">'//input[contains(@id, "mat-input")]'</span>)</span><br><span class="line"><span class="keyword">await</span> asyncio.sleep(<span class="number">10</span>)</span><br><span class="line">inputs = <span class="keyword">await</span> page.xpath(<span class="string">'//input[contains(@id, "mat-input")]'</span>)</span><br><span class="line">print(len(inputs))</span><br><span class="line"><span class="keyword">await</span> inputs[<span class="number">1</span>].type(<span class="string">'janetgao@indiana.edu'</span>)</span><br><span class="line"><span class="keyword">await</span> inputs[<span class="number">2</span>].type(<span class="string">'KAProject2021'</span>)</span><br><span class="line"><span class="comment"># 使用selector</span></span><br><span class="line"><span class="keyword">await</span> page.waitForSelector(<span class="string">'#mat-input-1'</span>)</span><br><span class="line"><span class="keyword">await</span> page.type(<span class="string">'#mat-input-1'</span>, <span class="string">'janetgao@indiana.edu'</span>)</span><br><span class="line"><span class="keyword">await</span> page.type(<span class="string">'#mat-input-2'</span>, <span class="string">'KAProject2021'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>launch</strong></p>
<ul>
<li>
<p><code>headless</code>：无界面模式</p>
</li>
<li>
<p><code>devtools</code> ：启用开发者助手</p>
</li>
<li>
<p><code>userDataDir='./userdata'</code>： 记录些用户信息，比如cookies</p>
</li>
<li>
<p><code>dumpio=True</code> 防止浏览器开多个页面而卡死</p>
</li>
<li>
<p><code>executablePath</code>: 指定自定义的chrome路径</p>
</li>
<li>
<p>参数args设置，可以类比selenium</p>
<ul>
<li>
<p><code>--start-maximized</code>: 页面全屏</p>
</li>
<li>
<p><code>--window-size={width},{height}</code>：设置窗口大小，区别于页面的<code>page.setViewport({'width': 1366, 'height': 768})</code></p>
</li>
<li>
<p><code>--disable-infobars</code>:不显示信息栏  比如 chrome正在受到自动测试软件的控制</p>
</li>
<li>
<p><code>--incognito</code>：百度搜到的chrome.exe无痕命令(selenium是如此，pyppeteer不推荐)</p>
</li>
<li>
<p><code>--user-agent</code>： 比如<code>'--user-agent=Mozilla/5.0'</code></p>
</li>
<li>
<p><code>--proxy-server={proxy}</code>: 浏览器代理 配合某些中间人代理使用</p>
</li>
<li>
<p><code>--no-sandbox</code>,  # 取消沙盒模式 沙盒模式下权限太小</p>
</li>
<li>
<p><code>'--log-level=3'</code></p>
</li>
<li>
<p><code>'--load-extension={}'.format(chrome_extension)</code>、<code>'--disable-extensions-except={}'.format(chrome_extension)</code> # 加载插件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chrome_extension_path = <span class="string">"插件所在目录"</span></span><br><span class="line">args = [</span><br><span class="line">    <span class="string">"--load-extension=&#123;&#125;"</span>.format(chrome_extension_path),</span><br><span class="line">    <span class="string">"--disable-extensions-except=&#123;&#125;"</span>.format(chrome_extension_path),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/dyfblog/p/12225796.html" target="_blank" rel="noopener">pyppeteer控制Chromium在隐身模式下启用插件 </a></p>
</li>
</ul>
</li>
<li>
<p>more: <a href="https://blog.csdn.net/Coding_CLearLove/article/details/110265509" target="_blank" rel="noopener">launch参数说明</a></p>
</li>
</ul>
<p>执行JS：</p>
<ul>
<li>
<p><code>page.evaluate('window.scrollBy(100, document.body.scrollHeight)')</code></p>
</li>
<li>
<p><code>await page.evaluate('alert(&quot;在浏览器执行js脚本!&quot;)')</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相当于拿到了dom对象</span></span><br><span class="line">element = <span class="keyword">await</span> page.J(<span class="string">'#ul&gt;a[name="tj_trtieba"]'</span>)</span><br><span class="line">print(<span class="keyword">await</span> page.evaluate(<span class="string">'el =&gt; el.innerHTML'</span>, element))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>page.evaluateOnNewDocument(pageFunction[, …args]), 指定的函数在所属的页面被创建并且所属页面的任意script执行之前被调用。常用于修改页面JS环境。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line"><span class="keyword">await</span> page.setViewPort(&#123;<span class="string">'width'</span>: <span class="number">1366</span>, <span class="string">'height'</span>: <span class="number">768</span>&#125;)</span><br><span class="line"><span class="keyword">await</span> page.evaluateOnNewDocument(<span class="string">'''() =&gt; &#123;</span></span><br><span class="line"><span class="string">        Object.defineProperty(navigator, 'webdriver', &#123;get: () =&gt; false &#125;);</span></span><br></pre></td></tr></table></figure>
<p>附—ElementHandle元素操作：</p>
<ol>
<li>获取元素边界框坐标：boundingBox()，返回元素的边界框（相对于主框架）=&gt; x 坐标、 y 坐标、width、height</li>
<li>元素是否可见：isIntersectingViewport()</li>
<li>上传文件：uploadFile(*filpaths)</li>
<li>ElementHandle 类 转 Frame类：contentFrame()，如果句柄未引用iframe，则返回None。</li>
<li>聚焦该元素：focus()</li>
<li>与鼠标相关：hover () ，将鼠标悬停到元素上面</li>
<li>与键盘相关：press (key[, options])，按键，key 表示按键的名称，option可配置:
<ul>
<li>text (string) - 如果指定，则使用此文本生成输入事件</li>
<li>delay (number) - keydown 和 keyup 之间等待的时间。默认是 0</li>
<li><code>page.keyboard.down('Shift')</code>：按下shift</li>
</ul>
</li>
</ol>
<p>more: <a href="https://blog.csdn.net/weizhen11/article/details/102509230" target="_blank" rel="noopener">页面元素操作</a></p>
</li>
</ul>
<p><strong>安全性：</strong></p>
<ol>
<li>在使用 Pyppeteer 仍然会遇到无头浏览器检测，这里安利一个第三方库「pyppeteer-stealth」，「puppeteer-extra-plugin-stealth」引用Github上的说明「Applies various evasion techniques to make detection of headless puppeteer harder.」「A plugin for puppeteer-extra to prevent detection.」（Github地址：<a href="https://github.com/berstend/puppeteer-extra/tree/master/packages/puppeteer-extra-plugin-stealth" target="_blank" rel="noopener">https://github.com/berstend/puppeteer-extra/tree/master/packages/puppeteer-extra-plugin-stealth</a> ）。可见，「pyppeteer-stealth」也是用于防止机器人检测的。用法也很简单，给page加上stealth</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">from</span> pyppeteer_stealth <span class="keyword">import</span> stealth</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(headless=<span class="keyword">True</span>)</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">await</span> stealth(page)  <span class="comment"># &lt;-- Here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">"https://bot.sannysoft.com/"</span>)</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>
<p>这样就可以省去隐藏WebDriver等操作，可谓省时省力省心。</p>
<ol start="2">
<li><code>await page.evaluateOnNewDocument('Object.defineProperty(navigator,&quot;webdriver&quot;,{get:()=&gt;undefined})')</code></li>
<li><code>stealth.min.js</code><a href="https://cloud.tencent.com/developer/article/1755513" target="_blank" rel="noopener">最完美方案！模拟浏览器如何正确隐藏特征</a></li>
</ol>
<p><strong>无痕隐身模式访问</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">start_browser</span><span class="params">()</span>:</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(**&#123;<span class="string">"headless"</span>: <span class="keyword">False</span>&#125;)</span><br><span class="line">    <span class="comment"># 创建隐身上下文</span></span><br><span class="line">    browser_context = <span class="keyword">await</span> browser.createIncognitoBrowserContext()</span><br><span class="line">    page = <span class="keyword">await</span> browser_context.newPage()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>较全的API说明：<a href="https://blog.csdn.net/Qwertyuiop2016/article/details/92667875" target="_blank" rel="noopener">pyppeteer的基本使用</a>、<a href="https://blog.csdn.net/weizhen11/article/details/102497647" target="_blank" rel="noopener">页面信息、设置</a></p>
<h3 id="问题按钮不生效"><a class="markdownIt-Anchor" href="#问题按钮不生效"></a> 问题：按钮不生效</h3>
<p>网页输入账号和密码之前，按钮状态为<code>disable=true</code>，两个都输入后才能按下，而使用pyppeteer时，发现无论怎么尝试都不能使得其disable变化（用开发者助手修改后，无法生成正确的提交请求）。突然巧合之中，想到了是不是元素没加载成功，于是确实在开发者助手的<code>console</code>中看到有很多不支持的，比如angular、bootstrap……</p>
<p>于是百度问题，看看是不是什么设置没开，但都没找到。后来想到升级下pyppeteer版本会不会好一点，发现自己的版本为1.0.2，已经是最新的了(<a href="https://github.com/miyakogi/pyppeteer/issues/306" target="_blank" rel="noopener">https://github.com/miyakogi/pyppeteer/issues/306</a>)。由于不通过程序直接通过浏览器进入程序也出现了无法点击的问题。再加上下面有人提出chromium有点难下载，并通过源码找道了默认的配置和设置，于是经过一阵的折腾过后，我发现**“按钮无法点击”的问题就在于chromium版本过低**。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyppeteer.chromium_downloader</span><br><span class="line">print(<span class="string">'默认版本是：&#123;&#125;'</span>.format(pyppeteer.__chromium_revision__))</span><br><span class="line">print(<span class="string">'可执行文件默认路径：&#123;&#125;'</span>.format(pyppeteer.chromium_downloader.chromiumExecutable.get(<span class="string">'win64'</span>)))</span><br><span class="line">print(<span class="string">'win64平台下载链接为：&#123;&#125;'</span>.format(pyppeteer.chromium_downloader.downloadURLs.get(<span class="string">'win64'</span>)))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">默认版本是：588429</span></span><br><span class="line"><span class="string">可执行文件默认路径：C:\Users\mrli\AppData\Local\pyppeteer\pyppeteer\local-chromium\588429\chrome-win32\chrome.exe</span></span><br><span class="line"><span class="string">win64平台下载链接为：https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/588429/chrome-win32.zip</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>登录这个storage的网站可以看到，上面所记录的chromium全都是2013年的版本，必然版本落后了。于是下载最新的chromium覆盖<code>C:\Users\mrli\AppData\Local\pyppeteer\pyppeteer\local-chromium\588429\chrome-win32</code>目录后再运行，按钮不能点击的问题就消失了!~😄</p>
<p>chromium下载地址：<a href="https://registry.npmmirror.com/binary.html?path=chromium-browser-snapshots/Win_x64/%EF%BC%8C%E6%B3%A8%EF%BC%9Achromium%E8%B7%9Fchromedriver%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%8C%E4%BB%96%E8%B7%9F%E8%87%AA%E5%B7%B1%E5%B7%B2%E7%BB%8F%E5%AE%89%E8%A3%85%E7%9A%84chrome%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%85%B3%E8%81%94%E3%80%82chromium%E8%87%AA%E5%B8%A6%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8E%E6%A0%B8%E5%BF%83%EF%BC%8C%E6%89%80%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%9A%84%E7%89%88%E6%9C%AC%E5%8D%B3%E5%8F%AF%EF%BC%8C%E6%AF%94%E5%A6%82%E6%88%91%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%B0%B1%E6%98%AF999303%E3%80%82" target="_blank" rel="noopener">https://registry.npmmirror.com/binary.html?path=chromium-browser-snapshots/Win_x64/，注：chromium跟chromedriver不一样，他跟自己已经安装的chrome并没有关联。chromium自带浏览器引擎核心，所以直接下载最新的版本即可，比如我直接下载的就是999303。</a></p>
<p>启发于：<a href="https://cloud.tencent.com/developer/article/1731720" target="_blank" rel="noopener">使用pyppeteer 下载chromium 报错 或速度慢</a>、<a href="https://www.cnblogs.com/Summer-skr--blog/p/12020207.html" target="_blank" rel="noopener">pyppeteer使用时常见的bug及解决办法【转载】 </a></p>
<ul>
<li>📖pyppeteer实战案例：<a href="https://blog.csdn.net/weixin_44826986/article/details/124114130" target="_blank" rel="noopener">Pyppeteer的使用——爬取京东</a>——消除指纹、页面滑动事件、获取数据，获取到的是Json数据：<code>(await a[0].getProperty(&quot;textContent&quot;)).jsonValue()</code></li>
<li>📖官方API： <a href="https://pyppeteer.github.io/pyppeteer/reference.html#pyppeteer.page.Page.xpath%E3%80%81" target="_blank" rel="noopener">https://pyppeteer.github.io/pyppeteer/reference.html#pyppeteer.page.Page.xpath、</a><a href="https://learnku.com/docs/puppeteer/3.1.0/class-mouse/8549" target="_blank" rel="noopener">puppeteer中文手册</a></li>
<li><a href="https://www.pythonheidong.com/blog/article/1133668/afc4477523a740d64a23/" target="_blank" rel="noopener">setViewport全屏</a></li>
</ul>
<h1 id="zsxq"><a class="markdownIt-Anchor" href="#zsxq"></a> zsxq</h1>
<h2 id="操作worddocx"><a class="markdownIt-Anchor" href="#操作worddocx"></a> 操作word——docx</h2>
<blockquote>
<p>安装: <code>pip install python-docx</code></p>
</blockquote>
<ul>
<li>插入图片</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">doc = Document()</span><br><span class="line"><span class="comment"># 增加标题</span></span><br><span class="line">doc.add_heading(<span class="string">'python-docx 基础讲解（二）'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文档中增加图片,并对设置图片大小</span></span><br><span class="line"><span class="comment"># 当只设置一个方向的长度（宽或高）时，另一方向会自动缩放</span></span><br><span class="line">doc.add_picture(<span class="string">'1.png'</span>,width=shared.Inches(<span class="number">1</span>))  <span class="comment"># 按英寸设置</span></span><br><span class="line">doc.add_picture(<span class="string">'1.png'</span>,height=shared.Cm(<span class="number">2</span>))  <span class="comment"># 按厘米设置</span></span><br></pre></td></tr></table></figure>
<ul>
<li>插入节</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_heading(text=<span class="string">u''</span>, level=<span class="number">1</span>)	        <span class="comment"># 写入标题段落</span></span><br><span class="line">add_paragraph(text =<span class="string">u''</span>,style=<span class="keyword">None</span>)	<span class="comment"># 写入普通段落</span></span><br><span class="line">add_picture(image_path_or_stream，width = <span class="keyword">None</span>，height = <span class="keyword">None</span> )	<span class="comment">#插入指定图片</span></span><br><span class="line">add_table(rows, cols)					<span class="comment"># 插入指定行数、列数的表格</span></span><br><span class="line">add_section(self, start_type=<span class="number">2</span>)     		 <span class="comment"># 添加节；</span></span><br><span class="line">add_page_break(self)               			 <span class="comment"># 分页符；</span></span><br><span class="line">add_paragraph(self, text=<span class="string">''</span>, style=<span class="keyword">None</span>)      <span class="comment"># 添加段落；</span></span><br></pre></td></tr></table></figure>
<ul>
<li>添加页眉</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>document = Document()</span><br><span class="line"><span class="comment"># 每个节section都有其页眉header</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>section = document.sections[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>header = section.header</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>paragraph = header.paragraphs[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>paragraph.text = <span class="string">"Title of my document"</span></span><br><span class="line"><span class="comment"># 设置页眉是否连接上一节</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>header.is_linked_to_previous = <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>注：“页眉也是一个块级对象，里面也包含了 Paragraph 对象,” “所以对齐方式，文字格式设置方式和前文介绍一致。”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head_par = head.paragraphs[<span class="number">0</span>]</span><br><span class="line">head_par.add_run(<span class="string">'页眉'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>修改页脚</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">font0 = sec0.footer  <span class="comment"># 返回页脚对象</span></span><br><span class="line"><span class="comment"># 设置页脚</span></span><br><span class="line">font0_par = font0.paragraphs[<span class="number">0</span>]</span><br><span class="line">font0_par.add_run(<span class="string">'页脚'</span>)</span><br><span class="line"><span class="comment"># 注: 设置页脚按序列增加的方式暂未找到</span></span><br></pre></td></tr></table></figure>
<ul>
<li>添加表格</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">table1 = doc.add_table(<span class="number">2</span>,<span class="number">3</span>,style =<span class="string">'Table Grid'</span> )</span><br><span class="line"><span class="comment"># 表格设置自动调整列宽，（默认也为真）</span></span><br><span class="line">table1.autofit = <span class="keyword">True</span></span><br><span class="line"><span class="comment"># 为表格对象增加列</span></span><br><span class="line">table1.add_column(shared.Inches(<span class="number">3</span>)) <span class="comment"># 需指定宽度</span></span><br><span class="line"><span class="comment"># 为表格对象增加行</span></span><br><span class="line">table1.add_row() <span class="comment"># 只能逐行添加</span></span><br><span class="line"><span class="comment"># 获取行对象</span></span><br><span class="line">row0 = table1.rows[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 获取列对象</span></span><br><span class="line">col0 = table1.columns[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 设置单元格对齐方式: 垂直对齐方式</span></span><br><span class="line"><span class="keyword">from</span> docx.enum.table <span class="keyword">import</span> WD_ALIGN_VERTICAL</span><br><span class="line">table1.cell(<span class="number">0</span>,<span class="number">0</span>).vertical_alignment = WD_ALIGN_VERTICAL.TOP</span><br><span class="line"><span class="comment"># 合并单元格</span></span><br><span class="line">cell_new = table1.cell(<span class="number">2</span>,<span class="number">0</span>).merge(table1.cell(<span class="number">2</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>注: 单元格内其实也是有 paragraph 对象的，即对单元格内字体设置方式，和对段落中文字格式设置方法一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cell_par = cell_new.paragraphs[<span class="number">0</span>] <span class="comment"># 获取到对象</span></span><br><span class="line"><span class="comment"># 设置对齐方式</span></span><br><span class="line"><span class="keyword">from</span> docx.enum.text <span class="keyword">import</span> WD_ALIGN_PARAGRAPH</span><br><span class="line">cell_par.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER</span><br><span class="line"><span class="comment"># 获取 run 对象</span></span><br><span class="line">cell_run = cell_new.paragraphs[<span class="number">0</span>].runs[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 设置字体</span></span><br><span class="line">cell_run.font.name = <span class="string">'Times New Roman'</span></span><br><span class="line"><span class="keyword">from</span> docx.oxml.ns <span class="keyword">import</span> qn</span><br><span class="line">cell_run.font.element.rPr.rFonts.set(qn(<span class="string">'w:eastAsia'</span>),<span class="string">'楷体'</span>)</span><br><span class="line"><span class="comment"># 设置字体颜色</span></span><br><span class="line"><span class="keyword">from</span> docx.shared <span class="keyword">import</span> RGBColor</span><br><span class="line">cell_run.font.color.rgb = RGBColor(<span class="number">255</span>,<span class="number">55</span>,<span class="number">55</span>) <span class="comment"># 红色</span></span><br></pre></td></tr></table></figure>
<ul>
<li>段落设置</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置段落缩进</span></span><br><span class="line"><span class="keyword">from</span> docx.shared <span class="keyword">import</span> Inches</span><br><span class="line">paragraph = document.add_paragraph(<span class="string">"你说啥"</span>)</span><br><span class="line">paragraph_format = paragraph.paragraph_format</span><br><span class="line">paragraph_format.left_indent = Inches(<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 首行缩进</span></span><br><span class="line">paragraph_format.first_line_indent = Inches(<span class="number">-0.25</span>)</span><br><span class="line"><span class="comment"># 段落行距</span></span><br><span class="line"><span class="keyword">from</span> docx.shared <span class="keyword">import</span> Length</span><br><span class="line"></span><br><span class="line">paragraph.line_spacing_rule = WD_LINE_SPACING.EXACTLY <span class="comment">#固定值</span></span><br><span class="line">paragraph_format.line_spacing = Pt(<span class="number">18</span>) <span class="comment"># 固定值18磅</span></span><br><span class="line">paragraph.line_spacing_rule = WD_LINE_SPACING.MULTIPLE <span class="comment">#多倍行距</span></span><br><span class="line">paragraph_format.line_spacing = <span class="number">1.75</span> <span class="comment"># 1.75倍行间距</span></span><br></pre></td></tr></table></figure>
<p>更多操作样式见：</p>
<ul>
<li>★<a href="https://blog.csdn.net/lly1122334/article/details/109669667" target="_blank" rel="noopener">Python操纵Word神器——python-docx大全（含插入pptx图表）</a></li>
<li><a href="https://blog.csdn.net/zhouz92/article/details/107066709" target="_blank" rel="noopener">Python-docx 读写 Word 文档：插入图片、表格，设置表格样式，章节，页眉页脚等</a>——表格、页眉页脚</li>
<li><a href="https://zhuanlan.zhihu.com/p/61340025" target="_blank" rel="noopener">python-docx处理word文档</a>——段落操作（字体属性可选项）</li>
</ul>
<h3 id="save后操作document对象再save会覆盖"><a class="markdownIt-Anchor" href="#save后操作document对象再save会覆盖"></a> Save后操作Document对象再save会覆盖</h3>
<p>Document对象在save之后，对其操作仍然有效，后续的操作在新的save中会保留上次save的记录，然后再添加新的（实则是覆盖）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">d = Document()</span><br><span class="line">resp = requests.get(<span class="string">"https://images.zsxq.com/FodneHQIMESZXJWe4SahoZ_J_vGs?imageMogr2/auto-orient/quality/100!/ignore-error/1&amp;e=1656604799&amp;token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:onEkC9y8uloYeHTrEIpYk4dstaw="</span>)</span><br><span class="line">bf = BytesIO()</span><br><span class="line">bf.write(resp.content)</span><br><span class="line">d.add_picture(bf)</span><br><span class="line">bf.close()</span><br><span class="line">d.save(<span class="string">"test.docx"</span>)</span><br><span class="line"><span class="comment"># save之后可以继续 **插入**, 然后再保存</span></span><br><span class="line">d.add_paragraph(<span class="string">"he"</span>)</span><br><span class="line">d.save(<span class="string">"test.docx"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="编辑已存在的word文档"><a class="markdownIt-Anchor" href="#编辑已存在的word文档"></a> 编辑已存在的word文档</h3>
<p><a href="https://link.zhihu.com/?target=https%3A//python-docx.readthedocs.io/en/latest/" target="_blank" rel="noopener">python-docx</a> 不仅可以创建word文档，还可以编辑已存在的word文档。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line">document = Document(<span class="string">'existing-document-file.docx'</span>)</span><br><span class="line"><span class="comment"># 可以将 已存在 docx的内容保存到新的docx中</span></span><br><span class="line">document.save(<span class="string">'new-file-name.docx'</span>)</span><br><span class="line"><span class="comment"># 也可以 覆盖当前docx 成新的docx</span></span><br></pre></td></tr></table></figure>
<p>但其实吧，这玩意儿<strong>只能编辑已存在的word文档</strong>，之所以有个“创建空白文档”的功能，只不过是拷贝一份空白word文档到工作区间，再在空白文档上编辑，看起来似乎是“创建空白文档”罢了。本质上还是编辑已存在的word文档…</p>
<p>打开一个word文档，编辑完后，一定要记得保存。如果保存文件名和原文件名不一样，则会另存为一份word文档；若文件名一样，则会不加提示的保存修改内容。</p>
<h2 id="__slots__作用"><a class="markdownIt-Anchor" href="#__slots__作用"></a> <code>__slots__</code>作用</h2>
<p>用于需要维护两个Saver, 因此中间根据返回值来获得了枚举确定saver对象, 但是saver对象有个saver_name的属性并没有绑定起来, 因此想到<br>
通过<code>setattr</code>来添加属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="comment"># 使用__slots__后添加age属性报错: AttributeError: 'A' object has no attribute 'age'</span></span><br><span class="line">    __slots__ = (<span class="string">"name"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=<span class="string">"cl"</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">a = A()</span><br><span class="line">setattr(a, <span class="string">"age"</span>, <span class="number">18</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(a.__dict__)</span><br><span class="line">print(a.age)</span><br></pre></td></tr></table></figure>
<p>但不幸的是Document中也无法通过<code>setattr</code>添加属性, 原因应该是Document类也定义了<code>__slots__</code>。</p>
<p>在此, 也明确下<code>__slots__</code>的特点：</p>
<ul>
<li><code>__slots__</code>数据类型为元组</li>
<li><code>__slots__</code>只对当前类生效，对其子类不生效</li>
</ul>
<h2 id="bytesio使用"><a class="markdownIt-Anchor" href="#bytesio使用"></a> BytesIO使用</h2>
<p>说起IO，很多人首先想到的是磁盘中的文件，将磁盘中的文件读到<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">内存</a>以及内存内容写入文件，显然这种文件与内存的File-IO是种非常典型的IO。然而其实还存在一种内存和内存之间的IO，叫类文件对象（file-like object，在内存中创建，可以像文件一样被操作）。Python原生提供两个类文件对象：StringIO和BytesIO。</p>
<p>Q问题一：为什么要有内存级别的IO？</p>
<p>A：磁盘上的文件，就是将数据持久化到磁盘的一块区域，供后面重复使用。其优点就是持久化稳定不丢失，但是缺点也很明显，就是每次要使用都要从磁盘读入，相对内存而言很缓慢；如果只是短时间的重复利用，并不希望长期持久化，而且对速度的要求比较高，这时候就可以考虑缓存。说到缓存，很多朋友就想到redis，熟悉python的朋友还会想到装饰器和闭包函数。不过python已经原生为我们准备好了类文件对象：StringIO和BytesIO，用于临时缓冲</p>
<p>Q问题二：StringIO和BytesIO区别？</p>
<p>A:StringIO只能存储字符串，遇到从网络下载的图片视频等Bytes类型的内容就不行了，需要用到专门存储Bytes类型的BytesIO对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> io <span class="keyword">import</span> BytesIO           </span><br><span class="line">In [<span class="number">2</span>]: b=BytesIO()         </span><br><span class="line">In [<span class="number">3</span>]: b.write(<span class="string">'小付'</span>.encode(<span class="string">'utf-8'</span>))    </span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">6</span></span><br><span class="line">In [<span class="number">4</span>]: b.getvalue()                          </span><br><span class="line">Out[<span class="number">4</span>]: <span class="string">b'\xe5\xb0\x8f\xe4\xbb\x98'</span></span><br></pre></td></tr></table></figure>
<p>Q问题三：那么这两个IO有什么作用呢？</p>
<p>A: BytesIO真正实用的地方还是在于存储图片视频等数据，比如网络请求了一个图片，拿到了<code>resp.content</code>的字节流，然后需要打开展示图片，但①pillow库打开的都是文件IO对象，无法直接通过字节流展示；②保存到本地作为文件打开又没必要，既占用存储空间，效率又低–&gt;此时就可以写入到内存中的IO(BytesIO)中</p>
<p>Q问题四：那么StringIO和BytesIO跟普通用的<code>f = open()</code>的FileIO有什么相同点呢</p>
<p>A:StringIO和BytesIO仍然为IO，但拥有和读写文件具有一致的接口，其本质是将内存作为一个文件看待，只是在内存中操作str和bytes。</p>
<h3 id="本项目案例-2"><a class="markdownIt-Anchor" href="#本项目案例-2"></a> 本项目案例：</h3>
<blockquote>
<p><code>python-docx</code>库中Document对象可以通过<code>add_picture()</code>方法插入图片到word中，但是<code>add_picture</code>的参数为<code>img_path</code>或者<code>stream</code>，那么这个Stream流指的肯定是图片的字节流，但是直接通过bytes数据肯定是没办法传入的，因此可以<strong>将其写入到BytesIO中，供其读取</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> d = Document()</span><br><span class="line">   resp = requests.get(</span><br><span class="line">       <span class="string">"https://images.zsxq.com/FodneHQIMESZXJWe4SahoZ_J_vGs?imageMogr2/auto-orient/quality/100!/ignore-error/1&amp;e=1656604799&amp;token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:onEkC9y8uloYeHTrEIpYk4dstaw="</span>)</span><br><span class="line">   bf = BytesIO()</span><br><span class="line">   bf.write(resp.content)</span><br><span class="line">   d.add_picture(bf)</span><br><span class="line">   <span class="comment"># 一张图片</span></span><br><span class="line">   bf.close()</span><br><span class="line">   d.save(<span class="string">"test.docx"</span>)</span><br><span class="line">   <span class="comment"># save之后可以继续 **插入**, 然后再保存</span></span><br><span class="line">   d.add_paragraph(<span class="string">"he"</span>)</span><br><span class="line">   d.save(<span class="string">"test.docx"</span>)</span><br><span class="line"><span class="comment"># 一张图片，生成一个BytesIO</span></span><br><span class="line">   bf = BytesIO()</span><br><span class="line">   resp = requests.get(</span><br><span class="line">       <span class="string">"https://images.zsxq.com/FrqnoTw_W2Pqhn1107HLd3jveuSz?e=1656604799&amp;token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:MJuNvGjp8XcfDNLPB5eLcouRFRg="</span>)</span><br><span class="line">   bf.write(resp.content)</span><br><span class="line">   d.add_picture(bf)</span><br><span class="line">   d.save(<span class="string">"test.docx"</span>)</span><br><span class="line">   bf.close()</span><br></pre></td></tr></table></figure>
<p>注：通过bf.flush()无法清空内容, 必须close(), 否则<code>bf.write(新图片)</code>然后再添加时第二张图片内容仍然为第一张。</p>
<p>★ --&gt; 网上没能找到清除BytesIO已有内容，因此结论为：一个bytes内容占用一个BytesIO，用完就关闭</p>
<h2 id="loguru"><a class="markdownIt-Anchor" href="#loguru"></a> loguru</h2>
<blockquote>
<p>loguru中提供全局的logger, 可以直接通过 <code>from loguru import logger</code> 来获得 logger, 但是这就意味着, 这样获得的都是都一个logger<br>
对象, 因此不太方便用于分模块的日志管理, 而是全局的日志管理。</p>
</blockquote>
<p>loguru的便捷体现在其<strong>开箱即用</strong>(少配置)的特点, 下面两行代码就能输出美观的日志输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line">logger.info(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>
<p>其次, loguru配置日志文件也非常方便, 他提出属于为**“沉量”**<code>sink</code><br>
<code>logger.add(sink='log.txt', format=&quot;{time} {level} {message}&quot;, filter=&quot;my_module&quot;, level=&quot;INFO&quot;)</code><br>
将上面两个功能合起来，就能实现最基本的日志功能了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line">logger.add(sink=<span class="string">'log.log'</span>, format=<span class="string">"&#123;time&#125; - &#123;level&#125; - &#123;message&#125;"</span>, level=<span class="string">"INFO"</span>)</span><br><span class="line">logger.info(<span class="string">"That's it, beautiful and simple logging!"</span>)</span><br></pre></td></tr></table></figure>
<p>可以用rotation、retention、compression进行日志窗口、更新、压缩管理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logger.add(<span class="string">"file_1.log"</span>, rotation=<span class="string">"500 MB"</span>)    <span class="comment"># 日志文件的窗口大小是500M</span></span><br><span class="line">logger.add(<span class="string">"file_2.log"</span>, rotation=<span class="string">"12:00"</span>)     <span class="comment"># 每天中午12点创建新日志文件</span></span><br><span class="line">logger.add(<span class="string">"file_3.log"</span>, rotation=<span class="string">"1 week"</span>)    <span class="comment"># 自动更新旧文件</span></span><br><span class="line">logger.add(<span class="string">"file_X.log"</span>, retention=<span class="string">"10 days"</span>)  <span class="comment"># 清理旧文件</span></span><br><span class="line">logger.add(<span class="string">"file_Y.log"</span>, compression=<span class="string">"zip"</span>)    <span class="comment"># 压缩文件</span></span><br></pre></td></tr></table></figure>
<p>more:</p>
<ul>
<li>修改日志文字的颜色<br>
<code>logger.add(sys.stdout, colorize=True, format=&quot;&lt;green&gt;{time}&lt;/green&gt; &lt;level&gt;{message}&lt;/level&gt;&quot;)</code></li>
<li>使用enqueue，可以保证多线程安全、多进程安全<br>
<code>logger.add(&quot;somefile.log&quot;, enqueue=True)</code><br>
参考: <a href="https://www.jianshu.com/p/0c27ac960546" target="_blank" rel="noopener">Loguru：优雅的Python程序日志</a></li>
</ul>
<h3 id="本项目自用loguru配置"><a class="markdownIt-Anchor" href="#本项目自用loguru配置"></a> 本项目自用loguru配置</h3>
<ol>
<li><code>settings.py</code>中找到项目绝对路径: <code>basedir = Path(__file__).resolve().parent.parent</code></li>
<li>将loguru中的logger注册为全局LOG, 暴露给其他模块使用</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> helper.settings <span class="keyword">import</span> basedir</span><br><span class="line"></span><br><span class="line">log_folder_path = Path(basedir, <span class="string">'logs'</span>)</span><br><span class="line">log_path = Path(log_folder_path, time.strftime(<span class="string">"%F"</span>))  <span class="comment"># 日志根目录 ../logs/yyyy-mm-dd/</span></span><br><span class="line"><span class="comment"># 创建日志文件夹</span></span><br><span class="line">log_path.mkdir(parents=<span class="keyword">True</span>, exist_ok=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 设置logger</span></span><br><span class="line">logger.add(sink=Path(log_path, <span class="string">"log.txt"</span>), format=<span class="string">"&#123;time&#125; &#123;level&#125; &#123;message&#125;"</span>, level=<span class="string">"INFO"</span>)</span><br><span class="line"><span class="comment"># 暴露LOG给其他模块使用</span></span><br><span class="line">LOG = logger</span><br></pre></td></tr></table></figure>
<h2 id="retry模块-2"><a class="markdownIt-Anchor" href="#retry模块-2"></a> retry模块</h2>
<blockquote>
<p>▲本项目中不知为何原因，options+get之后总会出现<code>{'succeeded': False, 'code': 1059, 'info': '', 'resp_data': {}}</code>的数据，但是进行重试发送请求后又能解决，因此retry模块在这个项目中发挥中较大的作用。</p>
</blockquote>
<p>retry是一个用于错误处理的模块，功能类似try-except，但可以更加快捷方便的设置重试的次数，以及每次重试之间相隔的时间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@retry()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_trouble</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''Retry until succeed'''</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'retrying...'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>exceptions：传入指定的错误类型，默认为Exception，即捕获所有类型的错误，也可传入<strong>元组形式的多种指定错误类型</strong>。</p>
</li>
<li>
<p>tries：定义捕获错误之后重复运行次数，默认为-1，即为无数次。</p>
</li>
<li>
<p>delay：定义每次重复运行之间的停顿时长，单位秒，默认为0，即无停顿。</p>
</li>
<li>
<p>backoff：呈指数增长的每次重复运行之间的停顿时长，需要配合delay来使用，譬如delay设置为3，backoff设置为2，则第一次间隔为<code>3*2^0=3</code>秒，第二次<code>3*2^1=6</code>秒，第三次<code>3*2^2</code>=12秒，以此类推，默认为1。</p>
</li>
<li>
<p>max_delay：定义backoff和delay配合下出现的最大等待时间上限，当</p>
<p><code>delay*backoff**n</code>大于max_delay时，等待间隔固定为该值而不再增长。</p>
</li>
</ul>
<h1 id="qkl"><a class="markdownIt-Anchor" href="#qkl"></a> qkl</h1>
<h2 id="requests-html"><a class="markdownIt-Anchor" href="#requests-html"></a> requests-html</h2>
<blockquote>
<p>安装: <code>pip install requests-html</code>，只支持python3.6及以上</p>
</blockquote>
<p>由于其用了<code>nuxt</code>框架，因此有些路由数据保存在<code>windows.__NUXT__.data</code>中，而这些数据都是变量，无法直接通过正则提取出来，但是因为其可以在控制台输出已经渲染生成好的<code>windows.__NUXT__.data</code>数据，因此考虑到用chromium后执行渲染脚本应该可以实现。但之前有了解过requets-html，其相对于要开浏览器而言更加便捷一些，于是本次使用的是requests-html。</p>
<p><strong>快速上手：</strong></p>
<p>由于与requests库出于同一作者，因此API和<code>requests库</code>都差不多，主要的区别在于<code>resp.html</code>这个属性,它是整个<code>requests_html库</code>中最核心的一个类，负责对HTML进行解析。比如分页、渲染等功能都是由该对象提供的。</p>
<p>相比requests的新功能有：</p>
<ul>
<li>支持JavaScript</li>
<li>支持页面解析：CSS选择器（又名jQuery风格, 感谢PyQuery）、支持Xpath选择器</li>
<li>可自定义模拟User-Agent（模拟得更像真正的web浏览器）</li>
<li>自动追踪重定向</li>
<li>连接池与cookie持久化</li>
<li>支持异步请求</li>
<li>智能多页</li>
</ul>
<p><strong>获取链接</strong></p>
<p>links和absolute_links两个属性分别返回HTML对象(URL)所包含的所有链接和绝对链接（均不包含锚点）（已经自动去掉了html标签）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取响应页面下的所有链接</span></span><br><span class="line">print(r.html.links)</span><br><span class="line">print(r.html.absolute_links)</span><br></pre></td></tr></table></figure>
<p><strong>获取元素</strong></p>
<p>request-html支持CSS选择器(借助PyQuery)和XPATH(借助lxml)两种语法来选取HTML元素，我一般用xpath比较多，因此就介绍xpath了，selector的用法是类似的。</p>
<p>XPAT语法，需要另一个函数xpath的支持，它有4个参数：</p>
<ul>
<li>selector，要用的XPATH选择器；</li>
<li>clean，布尔值，如果为真会忽略HTML中style和script标签造成的影响（原文是sanitize，大概这么理解）;</li>
<li>first，布尔值，如果为真会返回第一个元素，否则会返回满足条件的元素列表；</li>
<li><code>_encoding</code>，编码格式。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(r.html.xpath(<span class="string">"//div[@id='menu']"</span>, first=<span class="keyword">True</span>).text)</span><br><span class="line">print(r.html.xpath(<span class="string">"//div[@id='menu']/a"</span>))</span><br><span class="line"><span class="comment"># 如果XPATH中包含text()或@href这样的子属性，那么结果相应的会变成简单的字符串类型，而不是HTML元素。</span></span><br><span class="line">print(r.html.xpath(<span class="string">"//div[@class='content']/span/text()"</span>))</span><br></pre></td></tr></table></figure>
<p><strong>元素内容</strong></p>
<p>要搜索元素的文本内容，用search函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(e.search(<span class="string">'还是&#123;&#125;没头脑'</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 输出为： 那个</span></span><br></pre></td></tr></table></figure>
<p>两个链接属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(e.links) <span class="comment"># 相对路径 </span></span><br><span class="line">print(e.absolute_links) <span class="comment"># 绝对路径</span></span><br></pre></td></tr></table></figure>
<p><strong>JavaScript支持</strong></p>
<p>有些网站是使用JavaScript渲染的，直接爬取页面结构或者是接口获得数据可能不是想要的数据，这样的网站requests-html也可以处理JS渲染。关键一步就是在HTML结果上调用一下render函数，它会在用户目录（默认是~/.pyppeteer/）中下载一个chromium，然后用它来执行JS代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h = session.get(<span class="string">'http://python-requests.org/'</span>) </span><br><span class="line">h.html.render()</span><br><span class="line">r.html.search(<span class="string">'Python 2 will retire in only &#123;months&#125; months!'</span>)[<span class="string">'months'</span>] <span class="string">'&lt;time&gt;25&lt;/time&gt;'</span></span><br></pre></td></tr></table></figure>
<p>render函数还有一些参数：</p>
<ul>
<li>retries: 加载页面失败的次数</li>
<li>script: 页面上需要执行的JS脚本（可选）</li>
<li>wait: 加载页面前的等待时间（秒），防止超时（可选）</li>
<li>scrolldown: 页面向下滚动的次数</li>
<li>sleep: 在页面初次渲染之后的等待时间</li>
<li>reload: 如果为假，那么页面不会从浏览器中加载，而是从内存中加载</li>
<li>keep_page: 如果为真，允许你用r.html.page访问页面</li>
</ul>
<p><strong>智能分页</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rq = session.get(<span class="string">"https://reddit.com"</span>) </span><br><span class="line"><span class="keyword">for</span> html <span class="keyword">in</span> rq.html:</span><br><span class="line">	print(html)</span><br></pre></td></tr></table></figure>
<p><strong>直接使用HTML</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests_html </span><br><span class="line"><span class="keyword">import</span> HTML doc = <span class="string">"&lt;a href='https://httpbin.org'&gt;"</span> </span><br><span class="line">html = HTML(html=doc) </span><br><span class="line">print(html.links) &#123;<span class="string">'https://httpbin.org'</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>直接渲染JS代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">script = <span class="string">""" </span></span><br><span class="line"><span class="string">	() =&gt; &#123; </span></span><br><span class="line"><span class="string">		return &#123; </span></span><br><span class="line"><span class="string">			width: document.documentElement.clientWidth, height: document.documentElement.clientHeight, deviceScaleFactor: window.devicePixelRatio, </span></span><br><span class="line"><span class="string">				&#125; </span></span><br><span class="line"><span class="string">			&#125; </span></span><br><span class="line"><span class="string">		"""</span> </span><br><span class="line">val= html.render(script=script,reload=<span class="keyword">False</span>) </span><br><span class="line">print(val) print(html.html)</span><br></pre></td></tr></table></figure>
<h3 id="rhtmlpage与浏览器交互"><a class="markdownIt-Anchor" href="#rhtmlpage与浏览器交互"></a> r.html.page与浏览器交互</h3>
<blockquote>
<p>requests-html将对chromium的键盘和鼠标API操作聚合在了<code>r.html.page</code>对象下</p>
</blockquote>
<p><strong>键盘事件</strong></p>
<ul>
<li>keyboard.down(‘键盘名称’):按下键盘不弹起(与键盘有点不太down(‘h’)只会出现一个h而不是hhhhhhh…)</li>
<li>keyboard.up(‘键盘名称’):抬起按键</li>
<li>keyboard.press(‘键盘名称’):按下+弹起</li>
<li>keyboard.type(‘输入的字符串内容’，{‘delay’:100}) delay为每个子输入后延迟时间单位为<code>ms</code></li>
</ul>
<p><strong>鼠标事件</strong></p>
<p><strong>点击</strong></p>
<ul>
<li>click(‘css选择器’,{ ‘button’：‘left’, ‘clickCount’:1,‘delay’:0})
<ul>
<li>button为鼠标的按键<code>left</code>, <code>right</code>, or <code>middle</code>,</li>
<li>clickCount:点击次数默认次数为1</li>
<li>delay:点击延迟时间,单位是毫秒</li>
</ul>
</li>
<li>mouse.click(x, y,{ ‘button’：‘left’, ‘clickCount’:1,‘delay’:0})
<ul>
<li>x,y:muber数据类型,代表点击对象的坐标</li>
</ul>
</li>
</ul>
<p><strong>点下去不抬起</strong></p>
<ul>
<li>mouse.down({‘button’:xxx,clickCount:xxx})</li>
</ul>
<p><strong>抬起鼠标</strong></p>
<ul>
<li>mouse.up({‘button’:xxx,clickCount:xxx})</li>
</ul>
<p><strong>等待</strong></p>
<ul>
<li>waitFor(‘选择器, 方法 或者 超时时间’)
<ul>
<li>选择器: css 选择器或者一个xpath 根据是不是<code>//</code>开头</li>
<li>方法:时候此方法是<a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#?product=Puppeteer&amp;version=v1.19.0&amp;show=api-pagewaitforfunctionpagefunction-options-args" target="_blank" rel="noopener">page.waitForFunction()</a>的简写</li>
<li>超时时间:单位毫秒</li>
</ul>
</li>
</ul>
<p><strong>等待元素加载</strong>: <code>waitForSelector('css选择器')</code></p>
<p><strong>获取x,y坐标</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydic =await r.html.page.evaluate(<span class="string">''</span><span class="string">'() =&gt;&#123; </span></span><br><span class="line"><span class="string">       var a = document.querySelector('</span><span class="comment">#kw')   #对象的css选择器</span></span><br><span class="line">       var b = a.getBoundingClientRect()</span><br><span class="line">       <span class="keyword">return</span> &#123;<span class="string">'x'</span><span class="symbol">:b</span>.x,<span class="string">'y'</span><span class="symbol">:b</span>.y , <span class="string">'width'</span><span class="symbol">:b</span>.width , <span class="string">'height'</span><span class="symbol">:b</span>.height &#125;</span><br><span class="line">       &#125;<span class="string">''</span><span class="string">')</span></span><br></pre></td></tr></table></figure>
<p>📖</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_52182640/article/details/119741570" target="_blank" rel="noopener">python自学爬虫之requests-html</a>——整体API介绍</li>
<li><a href="https://www.cnblogs.com/guapitomjoy/p/12153557.html" target="_blank" rel="noopener">requests-html库render方法的使用 </a>——与浏览器交互操作</li>
</ul>
<h2 id="request-html异步"><a class="markdownIt-Anchor" href="#request-html异步"></a> request-html异步</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests_html <span class="keyword">import</span> AsyncHTMLSession</span><br><span class="line">asession = AsyncHTMLSession()</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_pyclock</span><span class="params">(index)</span>:</span></span><br><span class="line">    r = <span class="keyword">await</span> asession.get(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">    <span class="keyword">await</span> r.html.arender()</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">results = asession.run(get_pyclock, get_pyclock,</span><br><span class="line">                       get_pyclock)  <span class="comment"># 这里作者将同一个页面使用异步方式进行了3次渲染，但是实际上使用的时间并不是平时的3倍！可能只是比平时渲染一个页面多花了一点时间而已！这就是异步的好处！</span></span><br><span class="line">print(results)</span><br></pre></td></tr></table></figure>
<p>and:<a href="https://cloud.tencent.com/developer/article/1575104" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1575104</a></p>
<ul>
<li>📖asession.run无法传参的问题——<a href="https://www.cnblogs.com/angelyan/p/13913926.html" target="_blank" rel="noopener">修改requests_html.AsyncHTMLSessions使得支持url参数</a></li>
</ul>
<h2 id="charlesvpn无法共用解决方案"><a class="markdownIt-Anchor" href="#charlesvpn无法共用解决方案"></a> charles+VPN无法共用——解决方案</h2>
<blockquote>
<p>由于两个都是代理型的软件，因此往往默认都指定了一个端口，导致另一个失效，所以需要通过设置让他们端口互知。</p>
</blockquote>
<p>最近需要抓一个需要翻墙才能访问的网页的包，发现VPN直连时会导致 Fiddler 和 Charles 抓包工具无法正常进行抓包，网上找了以后发现了一些解决方案：<a href="https://github.com/mopduan/team/issues/13" target="_blank" rel="noopener">Github:VPN直连，导致 Fiddler 和 Charles 抓包工具无法正常进行抓包解决方案 </a>——试了貌似没用、<a href="https://www.jianshu.com/p/651ee335f97f?from=singlemessage" target="_blank" rel="noopener">windows下，实现vpn访问下的charles抓包设置中无网络问题的解决</a>——收此启发指导了在charles的<code>Proxy-&gt;external proxy</code>允许其他端口代理</p>
<p><strong>1.找到VPN软件的代理端口proxy port</strong></p>
<p>我这边使用的是vmess，可以在<code>选项-&gt;参数设置</code>中查看，需要明确的参数是端口和协议，我这边是10808和socks协议</p>
<p><img src="/2022/05/02/2022年5月劳动节爬虫项目记录/.%5C2022%E5%B9%B45%E6%9C%88%E5%8A%B3%E5%8A%A8%E8%8A%82%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%5Cvmess%E5%8F%82%E6%95%B0.jpg" alt="vmess参数"></p>
<p><strong>2.设置charles：</strong></p>
<p><code>Proxy-&gt;external proxy</code>, 首先允许其他proxy，然后根据刚刚查看到的vmess端口和协议进行填写</p>
<p><img src="/2022/05/02/2022年5月劳动节爬虫项目记录/.%5C2022%E5%B9%B45%E6%9C%88%E5%8A%B3%E5%8A%A8%E8%8A%82%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%5Ccharles.jpg" alt="charles"></p>
<p><strong>3.设置完成，开始抓包</strong></p>
<p>完结撒花~</p>
<h3 id="requests使用代理"><a class="markdownIt-Anchor" href="#requests使用代理"></a> requests使用代理</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cookies = &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'authority'</span>: <span class="string">'cn.v2ex.com'</span>,</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 核心是要配置下面的代理</span></span><br><span class="line">http_proxy = <span class="string">"socks5h://127.0.0.1:10808"</span></span><br><span class="line">https_proxy = <span class="string">"socks5h://127.0.0.1:10808"</span></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">"https"</span>: https_proxy,</span><br><span class="line">    <span class="string">"http"</span>: http_proxy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">'https://cn.v2ex.com/about'</span>, cookies=cookies, headers=headers, proxies=proxies)</span><br></pre></td></tr></table></figure>
<p>注：一开始在Sublime里运行的，结果一直在<code>response.text</code>时报编码错误，但是通过网页的content-type和meta charset进行确认过没问题，后来经过一个启发想到会不会是控制台有编码显示不了，于是在Pycharm中运行，成功!</p>
<h3 id="aiohttp使用socks代理"><a class="markdownIt-Anchor" href="#aiohttp使用socks代理"></a> aiohttp使用socks代理</h3>
<blockquote>
<p>from: <a href="https://pypi.org/project/aiohttp-socks/%E3%80%81https://www.cnblogs.com/john-xiong/p/13812567.html" target="_blank" rel="noopener">https://pypi.org/project/aiohttp-socks/、https://www.cnblogs.com/john-xiong/p/13812567.html</a></p>
</blockquote>
<ol>
<li>
<p><code>pip install aiohttp_socks</code></p>
</li>
<li>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">connector = ProxyConnector.from_url(<span class="string">'socks5://127.0.0.1:10808'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">getDataByChromeDriver</span><span class="params">(url)</span>:</span></span><br><span class="line">	<span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(connector=connector) <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">        loop.run_until_complete(asyncio.wait([getDataByChromeDriver(index) <span class="keyword">for</span> title, index <span class="keyword">in</span> title_list.items()]))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行即可</p>
</li>
</ol>
<h3 id="request-html使用代理"><a class="markdownIt-Anchor" href="#request-html使用代理"></a> request-html使用代理</h3>
<blockquote>
<p><a href="https://baijiahao.baidu.com/s?id=1701142223076604985&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">Python爬虫一个requests_html模块足矣！（支持JS加载&amp;异步请求）</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests_html <span class="keyword">import</span> AsyncHTMLSession</span><br><span class="line"></span><br><span class="line">http_proxy = <span class="string">"socks5h://127.0.0.1:10808"</span></span><br><span class="line">https_proxy = <span class="string">"socks5h://127.0.0.1:10808"</span></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">"https"</span>: https_proxy,</span><br><span class="line">    <span class="string">"http"</span>: http_proxy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session = AsyncHTMLSession()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">getDataByChromeDriver</span><span class="params">(index: Union[int, str])</span>:</span></span><br><span class="line">	response = <span class="keyword">await</span> session.get(<span class="string">'https://www.qkl123.com/sector/&#123;&#125;'</span>.format(index), headers=headers, proxies=proxies)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2022/05/02/2022年5月劳动节爬虫项目记录/">https://nymrli.top/2022/05/02/2022年5月劳动节爬虫项目记录/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2022/05/05/selenium不行的工作-pyppeteer上/" title="selenium不行的工作,pyppeteer上"><span>< PreviousPost</span><br><span class="prevTitle">selenium不行的工作,pyppeteer上</span></a><a class="nextSlogan" href="/2022/04/29/mitmproxy拦截代理——PC版HttpCanary/" title="mitmproxy拦截代理——PC版HttpCanary"><span>NextPost ></span><br><span class="nextTitle">mitmproxy拦截代理——PC版HttpCanary</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '2022年5月劳动节爬虫项目记录',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><span>备案号:苏ICP备18015439号</span></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#鱼"><span class="toc-number">1.</span> <span class="toc-text"> 鱼</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#retry模块"><span class="toc-number">1.1.</span> <span class="toc-text"> retry模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#项目结构"><span class="toc-number">1.2.</span> <span class="toc-text"> 项目结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pyinstaller"><span class="toc-number">1.3.</span> <span class="toc-text"> pyinstaller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dataclass"><span class="toc-number">1.4.</span> <span class="toc-text"> dataclass</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dataclasses嵌套"><span class="toc-number">1.4.0.1.</span> <span class="toc-text"> dataclasses嵌套</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toml语法学习"><span class="toc-number">1.5.</span> <span class="toc-text"> toml语法学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#toml对象"><span class="toc-number">1.5.1.</span> <span class="toc-text"> toml对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自用抢购尝试"><span class="toc-number">1.6.</span> <span class="toc-text"> 自用抢购尝试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#base数据库"><span class="toc-number">2.</span> <span class="toc-text"> base数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#判断重定向"><span class="toc-number">2.1.</span> <span class="toc-text"> 判断重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图片懒加载"><span class="toc-number">2.2.</span> <span class="toc-text"> 图片懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#本项目案例"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 本项目案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pathlib库使用"><span class="toc-number">2.3.</span> <span class="toc-text"> pathlib库使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#按住验证码"><span class="toc-number">2.4.</span> <span class="toc-text"> 按住验证码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pyppeteer"><span class="toc-number">2.4.1.</span> <span class="toc-text"> pyppeteer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题按钮不生效"><span class="toc-number">2.4.2.</span> <span class="toc-text"> 问题：按钮不生效</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zsxq"><span class="toc-number">3.</span> <span class="toc-text"> zsxq</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#操作worddocx"><span class="toc-number">3.1.</span> <span class="toc-text"> 操作word——docx</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#save后操作document对象再save会覆盖"><span class="toc-number">3.1.1.</span> <span class="toc-text"> Save后操作Document对象再save会覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编辑已存在的word文档"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 编辑已存在的word文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#__slots__作用"><span class="toc-number">3.2.</span> <span class="toc-text"> __slots__作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bytesio使用"><span class="toc-number">3.3.</span> <span class="toc-text"> BytesIO使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#本项目案例-2"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 本项目案例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loguru"><span class="toc-number">3.4.</span> <span class="toc-text"> loguru</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#本项目自用loguru配置"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 本项目自用loguru配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#retry模块-2"><span class="toc-number">3.5.</span> <span class="toc-text"> retry模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#qkl"><span class="toc-number">4.</span> <span class="toc-text"> qkl</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#requests-html"><span class="toc-number">4.1.</span> <span class="toc-text"> requests-html</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rhtmlpage与浏览器交互"><span class="toc-number">4.1.1.</span> <span class="toc-text"> r.html.page与浏览器交互</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#request-html异步"><span class="toc-number">4.2.</span> <span class="toc-text"> request-html异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#charlesvpn无法共用解决方案"><span class="toc-number">4.3.</span> <span class="toc-text"> charles+VPN无法共用——解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#requests使用代理"><span class="toc-number">4.3.1.</span> <span class="toc-text"> requests使用代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aiohttp使用socks代理"><span class="toc-number">4.3.2.</span> <span class="toc-text"> aiohttp使用socks代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#request-html使用代理"><span class="toc-number">4.3.3.</span> <span class="toc-text"> request-html使用代理</span></a></li></ol></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>