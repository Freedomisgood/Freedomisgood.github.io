<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>重拾Java笔记 · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">重拾Java笔记</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2020/05/18</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="java"> java</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">12,186</span> | Reading time: <span class="post-count">49</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="重拾java笔记"><a class="markdownIt-Anchor" href="#重拾java笔记"></a> 重拾Java笔记</h1>
<blockquote>
<p>工作主要用Java, 因此开始准备Java基础再补补。根据<a href="http://www.monkey1024.com/javaseroute" target="_blank" rel="noopener">小猴子1024-JAVA基础</a>整理笔记</p>
</blockquote>
<h2 id="命名规范"><a class="markdownIt-Anchor" href="#命名规范"></a> <a href="https://www.jianshu.com/p/511cc270400f" target="_blank" rel="noopener">命名规范:</a></h2>
<blockquote>
<p>没怎么写， 所以一直忘， 这次写在最前面， 便于翻阅。</p>
</blockquote>
<p>大驼峰命名（UpperCamelCase）：<strong>每个单词的第一个字母大写</strong>，其他字母小写。e.g.MyException</p>
<p>小驼峰命名（lowerCamelCase）：如果仅有一个单词，那么所有字母全部小写，如果是两个及以上的单词组成的名称，那么除了第一个单词是全部小写外，其他都是的首字母大写，其他字母小写。e.g.getMyName</p>
<hr>
<p>1.1 包的命名</p>
<p>包的命名由全部小写的单词组成。一般使用公司的域名的作为自己程序包的唯一前缀，使用倒域名规则，例如：com.baidu.项目名，然后针对每个具体的模块在区分每个模块包名，例如：论坛模块的整体包名：<code>com.baidu.项目名.tribune</code>(域名倒写)</p>
<p>1.2 类的命名</p>
<p>类的命名遵循大驼峰命名的规则</p>
<p>1.3 接口的命名</p>
<p>接口命名遵循大驼峰命名的规则，以大写的I开头，表示这是一个接口，以able或ible截尾。</p>
<p>1.4 变量命名</p>
<p>变量的命名遵循小驼峰命名的规则，其中控件的变量建议使用控件缩写+逻辑名称的格式，例如：</p>
<p>1.5 常量的命名</p>
<p>常量名称的每个单词都大写，并且每个单词之间通过下划线（_）连接，例如：</p>
<p>1.6 方法的命名</p>
<p>方法的命名遵循小驼峰命名的规则，以动词+名词的方式组成，例如初始化view：initView()。</p>
<p>1.7 资源文件命名</p>
<p>全部小写，并通过下划线连接。</p>
<p>1.7.1 布局文件的命名</p>
<p>作者：summer_七七<br>
链接：<a href="https://www.jianshu.com/p/511cc270400f" target="_blank" rel="noopener">https://www.jianshu.com/p/511cc270400f</a><br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<hr>
<h2 id="class与文件名"><a class="markdownIt-Anchor" href="#class与文件名"></a> class与文件名:</h2>
<blockquote>
<p>在一个Java文件里面，可以声明多个class，但是只能声明一个public class</p>
</blockquote>
<ul>
<li>如果使用class来声明类，文件名可以是任何合法的文件名称，文件名不需要和Class类一致</li>
<li>如果采用public class来声明class，那么文件名必须和类名一致</li>
</ul>
<p>结论: 使用javac命令所编译出的<strong>class文件</strong>的名称<strong>跟java的文件名没有关系</strong>，而是<strong>跟类名一致</strong>。</p>
<h2 id="函数传参"><a class="markdownIt-Anchor" href="#函数传参"></a> 函数传参:</h2>
<ul>
<li>如果参数是基本数据类型, 是会生成一个新的形参</li>
<li>如果参数是引用数据类型(不包括封装数据类型), 那么会生成该对象的引用（类、 接口类型、 <u>数组类型</u>、 枚举类型、 注解类型、 字符串型）==&gt;引用数据类型变量，调用方法时作为参数是按<strong>引用传递</strong>的</li>
</ul>
<p>参看: <a href="https://www.cnblogs.com/maskwolf/p/9972982.html" target="_blank" rel="noopener">Java中的基本数据类型和引用数据类型的区别</a></p>
<h2 id="代码块的分类"><a class="markdownIt-Anchor" href="#代码块的分类"></a> 代码块的分类</h2>
<p>使用{}括起来的代码被称为代码块，根据其位置和声明的不同可以分为下面4种：</p>
<ul>
<li><strong>局部代码块</strong>，在方法中出现，限定变量生命周期，及早释放，提高内存利用率</li>
<li><strong>构造代码块</strong>，在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</li>
<li><strong>静态代码块</strong>， 在类中方法外出现，并加上static修饰；用于给<strong>类进行初始化，在加载的时候就执行</strong>，并且只执行一次。一般用于加载驱动。</li>
<li><strong>同步代码块</strong>(后面多线程部分会讲解)</li>
</ul>
<h3 id="执行顺序"><a class="markdownIt-Anchor" href="#执行顺序"></a> 执行顺序:</h3>
<p>1.<strong>静态代码块</strong>，随着类加载而加载,且只执行一次<br>
2.<strong>构造代码块</strong>，每创建一个对象就会执行一次，优先于构造方法执行<br>
3.<strong>构造方法</strong>，每创建一个对象就会执行一次</p>
<h2 id="this指针"><a class="markdownIt-Anchor" href="#this指针"></a> this指针</h2>
<p>▲注意点: 在构造函数中调用该对象的另一个构造方法时,  this(实参)必须写在最前面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//构造方法</span><br><span class="line">//需求：在创建日期对象的时候，默认的日期是:1970-1-1</span><br><span class="line">MyDate()&#123;</span><br><span class="line">    //通过this调用有参的构造方法</span><br><span class="line">    this(1970,1,1);//必须出现在第一行，否则将编译报错</span><br><span class="line">    //构造方法不能这样调用</span><br><span class="line">    //MyDate(1970,1,1);Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承问题"><a class="markdownIt-Anchor" href="#继承问题"></a> 继承问题：</h2>
<p>静态代码块Fu<br>
静态代码块Zi<br>
构造代码块Fu<br>
构造方法Fu<br>
构造代码块Zi<br>
构造方法Zi</p>
<p>分析：<br>
1.系统将Fu.class和Zi.class分别加载到方法区的内存里面，<strong>静态代码</strong>会随着.class文件一块<strong>加载到方法区</strong>里面，所以先打印出了静态代码块中的内容。<br>
2.<strong>构造代码块优先于构造方法执行</strong>，父类初始化之前，所以打印出父类中的构造代码块和构造方法中的内容。</p>
<h2 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态：</h2>
<blockquote>
<p>在工作当中尽量面向抽象编程，不要面向具体编程，即合理利用多态——<strong>SOLID原则</strong>中依赖倒置：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。换言之，要针对接口编程，而不是针对实现编程。</p>
</blockquote>
<p><strong>多态的优点</strong></p>
<ul>
<li>提高程序的扩展性</li>
<li>降低代码之间的耦合</li>
</ul>
<p><strong>用法</strong></p>
<ul>
<li>向上转型：上面代码中子类向父类型进行转换，是<strong>自动类型转换</strong>。</li>
<li>向下转型： 父类向子类型转换，是<strong>强制类型转换</strong>。</li>
</ul>
<h2 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h2>
<p>重写，也叫做覆盖，当父类中的方法无法满足子类需求时，子类可以将父类的方法进行重写编写来满足需求。比如孩子继承了父亲的房子，可以将房子重新装修。<br>
方法重写的条件：</p>
<ul>
<li>两个类必须是继承关系</li>
<li>必须具有相同的方法名，相同的返回值类型，相同的参数列表.</li>
<li>重写的方法不能比被重写的方法拥有更低的访问权限。</li>
<li>重写的方法不能比被重写的方法抛出更宽泛的异常。(关于异常后面的章节再讲。)</li>
<li>私有的方法不能被重写。</li>
<li>构造方法无法被重写，因为构造方法无法被继承。</li>
<li>静态的方法不存在重写。</li>
<li>重写指的是成员方法，和成员变量无关。</li>
</ul>
<h2 id="super关键字"><a class="markdownIt-Anchor" href="#super关键字"></a> Super关键字:</h2>
<p>什么时候使用super？</p>
<ul>
<li>子类和父类中都有某个数据，例如，子类和父类中都有name这个属性。如果要再子类中访问父类中的name属性，需要使用super。例1</li>
<li>子类重写了父类的某个方法（假设这个方法名叫m1），如果在子类中需要调用父类中的m1方法时，需要使用super。例1</li>
<li>子类调用父类中的构造方法时，需要使用super。</li>
</ul>
<h2 id="object类之finalize方法"><a class="markdownIt-Anchor" href="#object类之finalize方法"></a> Object类之finalize方法</h2>
<blockquote>
<p>java对象如果没有更多的引用指向它（引用技术），则该java对象成为垃圾数据，等待垃圾回收器的回收，垃圾回收器在回收这个java对象之前会自动调用该对象的finalize方法==&gt;可以理解为解析函数</p>
</blockquote>
<h2 id="访问控制权限"><a class="markdownIt-Anchor" href="#访问控制权限"></a> 访问控制权限</h2>
<p><strong>方法访问控制权限</strong></p>
<table>
<thead>
<tr>
<th><strong>修饰词</strong></th>
<th><strong>本类</strong></th>
<th><strong>同一个包的类</strong></th>
<th><strong>子类</strong></th>
<th><strong>任何地方</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>default（默认）</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p><strong>方法访问控制权限</strong></p>
<p>▲。注意以上对类的修饰只有：public和default，内部类除外</p>
<p>priavte和public都比较好理解和记忆，这里就不演示了，主要演示一下不同包下的两个具有父子关系的类里面使用protected和default的区别。</p>
<h3 id="构造函数的权限问题"><a class="markdownIt-Anchor" href="#构造函数的权限问题"></a> 构造函数的权限问题:</h3>
<p>public是一个<a href="https://www.baidu.com/s?wd=%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">访问权限</a>（访问修复饰符）。一般<a href="https://www.baidu.com/s?wd=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">构造函数</a>可加可不加public。</p>
<ul>
<li>如果加上制public,就代表此类可以对外开放,其他的类可以继承它,外部也可以实例化该对象。</li>
<li>如果不加public,则默认的修饰词是default,表示可以被这个类的子类或者和这个类同包的类调用。</li>
</ul>
<p>除了这两个,你还可以添加private和default</p>
<h2 id="final关键字"><a class="markdownIt-Anchor" href="#final关键字"></a> <strong>Final关键字:</strong></h2>
<blockquote>
<p>特点为确定不可变</p>
</blockquote>
<ul>
<li>final修饰的类无法被继承。</li>
<li>final修饰的方法无法被重写。</li>
<li>final修饰的局部变量，一旦赋值，不可再改变。</li>
<li>final修饰的成员变量必须初始化值。</li>
</ul>
<h2 id="static关键字"><a class="markdownIt-Anchor" href="#static关键字"></a> static关键字</h2>
<h3 id="static的作用"><a class="markdownIt-Anchor" href="#static的作用"></a> static的作用</h3>
<ul>
<li>static可以修饰变量，被static修饰的变量叫做静态变量，<u>静态变量在类加载阶段赋值，并且只赋值一次</u>。请看例1</li>
<li>static可以修饰方法，被static修饰的方法叫做静态方法，<strong>不用创建对象就能能直接访问该方法</strong>，即使用类名.静态方法名的方式。静态方法不能访问非静态的数据，静态方法不能使用this。请看例2</li>
<li>static可以定义静态语句块，<u>静态语句块在类加载阶段执行，并且只执行一次，并且是自上而下的顺序执行，在构造方法之前执行</u>。请看例3</li>
</ul>
<p>static修饰的变量、方法、代码块都是隶属于**类(class)**级别的,跟对象无关。某一类物体如果可以被多个其他物体所共享，那么可以将这类物体使用static修饰。<br>
比如wifi，多个人可以共同使用同一个wifi，所以wifi可以使用static修饰。手机是每人使用自己的，就不能用static修饰。</p>
<h2 id="抽象类的特点"><a class="markdownIt-Anchor" href="#抽象类的特点"></a> 抽象类的特点</h2>
<ul>
<li>抽象类无法被实例化，无法创建抽象类的对象。</li>
<li>虽然抽象类没有办法实例化，但是<strong>抽象类也有构造方法</strong>，该构造方法是给子类创建对象用的。这也算是多态的一种。</li>
<li>抽象类中不一定有抽象方法，但抽象方法必须出现在抽象类中。</li>
<li>抽象类中的子类可以是抽象类，如果不是抽象类的话必须对抽象类中的抽象方法进行重写。</li>
<li>抽象类和抽象方法不能被final修饰</li>
</ul>
<h2 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口：</h2>
<ul>
<li>接口中只能出现常量和抽象方法（jdk8之后可以有default方法）</li>
<li>接口里面<strong>没有构造方法</strong>，无法创建接口的对象</li>
<li>接口和接口之间支持多继承，即一个接口可以有多个父接口</li>
<li>一个类可以实现多个接口，即一个类可以有多个父接口</li>
<li>一个类如果实现了接口，那么这个类需要重写接口中所有的抽象方法（建议），如果不重写则这个类需要声明为抽象类（不建议）</li>
</ul>
<h2 id="equals"><a class="markdownIt-Anchor" href="#equals"></a> equals</h2>
<blockquote>
<p>== 两边如果是引用类型，则比较内存地址，地址相同则是true,反之则false.</p>
</blockquote>
<ul>
<li>Object中的equals方法比较的是两个引用的内存地址。</li>
<li>但是在现实的业务逻辑当中，不应该比较内存地址，<strong>应该比较地址里面的内容</strong>，所以需要对equals方法进行重写。</li>
</ul>
<p>==&gt;▲注意：在使用自己创建的类进行equals比较时，一定要先重写equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据需求规定重写equals方法</span></span><br><span class="line"><span class="comment">//s1.equals(s2);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Star)&#123;</span><br><span class="line">        Star s = (Star)obj;</span><br><span class="line">        <span class="keyword">if</span>(s.id == id &amp;&amp; s.name.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内部类的分类"><a class="markdownIt-Anchor" href="#内部类的分类"></a> 内部类的分类</h2>
<p>内部类，顾名思义就是在一个类的内部声明一个类。内部类主要分为：</p>
<ul>
<li>静态内部类</li>
<li>匿名内部类</li>
<li>成员内部类</li>
<li>局部内部类</li>
</ul>
<h2 id="异常的分类"><a class="markdownIt-Anchor" href="#异常的分类"></a> 异常的分类</h2>
<blockquote>
<p>异常: 指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止——JVM处理异常的方式是中断处理。</p>
</blockquote>
<p>异常主要分为：Error、一般性异常、RuntimeException</p>
<ul>
<li>Error(强制中断错误)：如果程序出现了Error，那么将无法恢复，只能重新启动程序，最典型的Error的异常是：OutOfMemoryError</li>
<li>Exception（一般性异常（<strong>编译时</strong>异常）：出现了这种异常必须在程序里面显示的处理，否则程序无法编译通过</li>
<li>RuntimeException（<strong>运行时</strong>异常）：此种异常可以不用显示的处理，例如被0除异常，java没有要求我们一定要处理。</li>
</ul>
<p><img src="http://www.monkey1024.com/wp-content/uploads/2017/04/1%E5%BC%82%E5%B8%B8%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="å¼å¸¸ç»§æ¿ç»æå¾"></p>
<h3 id="jvm是如何处理异常的"><a class="markdownIt-Anchor" href="#jvm是如何处理异常的"></a> JVM是如何处理异常的</h3>
<ul>
<li>main方法自己将该问题处理,然后继续运行</li>
<li>自己没有针对的处理方式,只有交给调用main的jvm来处理，jvm有一个默认的异常处理机制。例如上面出现的ArithmeticException，jvm在控制台里面打印出来了异常信息。</li>
</ul>
<p>大致流程: native method自己解决-&gt;交给Main解决-&gt;交给JVM解决</p>
<p>更好的讲解: <a href="https://www.bilibili.com/video/BV1A4411K7Gx?p=282" target="_blank" rel="noopener">B站视频</a></p>
<h3 id="throw和throws"><a class="markdownIt-Anchor" href="#throw和throws"></a> throw和throws</h3>
<p>throws</p>
<ul>
<li>用在方法声明后面，跟的是<strong>异常类名</strong>    <code>public void m1() throws Exception</code></li>
<li>可以跟多个异常类名，用逗号隔开</li>
<li>表示抛出异常，由<strong>该方法的调用者来处理</strong> (<strong>向上抛出指定异常</strong>)</li>
</ul>
<p>throw</p>
<ul>
<li>用在方法体内，跟的是<strong>异常对象名</strong>    ==&gt; <code>throw new Exception()</code></li>
<li>只能抛出一个异常对象名</li>
<li>表示抛出异常，由方法体内的语句处理，<strong>需要直接在此处解决异常</strong>(在当前语句抛出指定异常)</li>
</ul>
<h3 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h3>
<p>1.自定义异常类一般都是以Exception结尾，说明该类是一个异常类<br>
2.自定义异常类，必须的继承Exception或者RuntimeException<br>
- 继承Exception：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try…catch<br>
- 继承RuntimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个空参数的构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个带异常信息的构造方法</span></span><br><span class="line"><span class="comment">     * 查看源码发现，所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的构造方法，让父类来处理这个异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="catch"><a class="markdownIt-Anchor" href="#catch"></a> catch</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (ArithmeticException | ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="comment">// 出现多个异常,采取同样的处理措施</span></span><br><span class="line">            <span class="comment">// 多个异常见用 | 隔开</span></span><br><span class="line">            <span class="comment">// 多个异常必须是平级关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串的不可变性"><a class="markdownIt-Anchor" href="#字符串的不可变性"></a> 字符串的不可变性</h2>
<h3 id="string类不能被继承"><a class="markdownIt-Anchor" href="#string类不能被继承"></a> String类不能被继承</h3>
<p>通过源码可以看到String类前面加了final修饰，因此String类是不能够被继承的。将其设置为不能被继承的原因是为了减少歧义。</p>
<h3 id="字符串string的不可变性"><a class="markdownIt-Anchor" href="#字符串string的不可变性"></a> 字符串（String）的不可变性</h3>
<p>String创建好之后值是不可以被改变的，这里指的是<strong>在堆中的字符串的值</strong>是不可以被改变。</p>
<p>String不可变的主要原因是其底层使用了一个final修饰的byte数组(jdk9之后版本中)，final修饰的变量是不能被改变的。在jdk8版本中，String底层使用的是final修饰的char数组。这个版本之间的变化。</p>
<h3 id="字符串常量池"><a class="markdownIt-Anchor" href="#字符串常量池"></a> 字符串常量池</h3>
<p>我们声明的字符串会放到一个叫做字符串常量池的地方，这样可以减少内存的使用，字符串常量池是堆的一部分。</p>
<p>如果用<code>new String(&quot;monkey&quot;)</code>会在字符串常量池中再建一个monkey, 其实是浪费了内存。所以开发中建议使用String s = “monkey1024”;这种方式创建字符串对象，可以减少堆内存的使用。==&gt;<strong>比较两个字符串是否一致最好使用equals方法</strong>(看引用的内存地址是否一致)</p>
<p>详细请看: <a href="http://www.monkey1024.com/javase/481" target="_blank" rel="noopener">http://www.monkey1024.com/javase/481</a></p>
<p><img src="/2020/05/15/重拾Java笔记/JVM%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="JVM内存图"></p>
<h2 id="string-stringbuffer-stringbuilder"><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder"></a> String、StringBuffer、StringBuilder</h2>
<ul>
<li>如果需要对字符串进行频繁拼接的话，建议使用StringBuffer或者StringBuilder</li>
</ul>
<h3 id="stringbuffer"><a class="markdownIt-Anchor" href="#stringbuffer"></a> StringBuffer</h3>
<ul>
<li>StringBuffer是一个字符串缓冲区，如果需要频繁的对字符串进行拼接时，建议使用StringBuffer。</li>
<li>StringBuffer的底层是byte数组（jdk9之后），jdk8中底层是char数组，如果没有明确设定，则系统会默认创建一个长度为16的byte类型数组，在使用时如果数组容量不够了，则会通过数组的拷贝对数组进行扩容，所以在使用StringBuffer时最好预测并手动初始化长度，这样能够减少数组的拷贝，从而提高效率。</li>
</ul>
<h3 id="stringbuilder和stringbuffer的区别"><a class="markdownIt-Anchor" href="#stringbuilder和stringbuffer的区别"></a> StringBuilder和StringBuffer的区别</h3>
<p>通过API可以看到StringBuilder和StringBuffer里面的方法是一样的，那他们有什么区别呢？<br>
StringBuffer是jdk1.0版本中加入的，是<strong>线程安全的</strong>，效率低<br>
StringBuilder是jdk5版本加入的，是<strong>线程不安全的</strong>，效率高</p>
<h2 id="什么是自动拆箱和自动装箱"><a class="markdownIt-Anchor" href="#什么是自动拆箱和自动装箱"></a> 什么是自动拆箱和自动装箱？</h2>
<ul>
<li>自动装箱：把基本类型转换为包装类类型</li>
<li>自动拆箱：把包装类类型转换为基本类型</li>
</ul>
<h2 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h2>
<blockquote>
<p>接口Collection: 由三个接口组成——List / Set / Queue</p>
</blockquote>
<h3 id="集合的由来"><a class="markdownIt-Anchor" href="#集合的由来"></a> 集合的由来</h3>
<p>数组长度是固定,如果要改变数组的长度需要创建新的数组将旧数组里面的元素拷贝过去，使用起来不方便。<br>
java给开发者提供了一些集合类，能够存储任意长度的对象，长度可以随着元素的增加而增加,随着元素的减少而减少，使用起来方便一些。</p>
<h3 id="集合类的一些特点"><a class="markdownIt-Anchor" href="#集合类的一些特点"></a> 集合类的一些特点</h3>
<ul>
<li>List：里面存放的数据是有顺序的，可以存放重复的数据。</li>
<li>Set：里面存放的数据是没有顺序的，不能存放重复的数据。</li>
<li>Queue：是一个队列，里面的数据是先进先出，可以存放重复的数据。</li>
</ul>
<h3 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3>
<ul>
<li>区别1:
<ul>
<li>数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值</li>
<li>集合只能存储引用数据类型(对象)，如果存储基本数据类型时，会自动装箱变成相应的包装类</li>
</ul>
</li>
<li>区别2:
<ul>
<li>数组长度是固定的,不能自动增长</li>
<li>集合的长度的是可变的,可以根据元素的增加而自动增长</li>
</ul>
</li>
</ul>
<h2 id="list两个子类的特点"><a class="markdownIt-Anchor" href="#list两个子类的特点"></a> List两个子类的特点</h2>
<p>ArrayList:</p>
<ul>
<li>底层数据结构是数组，查询快，增删慢。</li>
</ul>
<p>LinkedList:</p>
<ul>
<li>底层数据结构是链表，查询慢，增删快。</li>
</ul>
<p>ArrayList和LinkedList的区别</p>
<ul>
<li>ArrayList底层是数组结果,查询和修改快</li>
<li>LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢</li>
<li>共同点:都是<strong>线程不安全的</strong></li>
</ul>
<h3 id="arraylist线程安全的方案"><a class="markdownIt-Anchor" href="#arraylist线程安全的方案"></a> ArrayList线程安全的方案</h3>
<p>如果使用ArrayList需要考虑线程安全的问题，有两种方案：</p>
<ul>
<li>
<p>可以使用Collections工具类中的synchronizedList方法可以将ArrayList变成线程安全的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(new ArrayList());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用java.util.concurrent包下面的CopyOnWriteArrayList，使用方式跟ArrayList一样</p>
</li>
</ul>
<h2 id="集合数组的互转"><a class="markdownIt-Anchor" href="#集合数组的互转"></a> <a href="http://www.monkey1024.com/javase/565" target="_blank" rel="noopener">集合数组的互转</a></h2>
<p>集合转数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line">list.add(<span class="string">"c"</span>);</span><br><span class="line">list.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当集合转换数组时,数组长度如果是&lt;=集合的size时,转换后的数组长度等于集合的size</span></span><br><span class="line"><span class="comment">//如果数组的长度大于了size,分配的数组长度就和你指定的长度一样</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> String[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">for</span>(String s : array)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组转集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意转换后的集合不能调用其add方法向里面添加数据，否则会报出UnsupportedOperationException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组转集合</span></span><br><span class="line">String[] arr = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line"><span class="comment">//将数组转换成集合</span></span><br><span class="line">List&lt;String&gt; listArray = Arrays.asList(arr);                </span><br><span class="line"><span class="comment">//不能添加</span></span><br><span class="line"><span class="comment">//listArray.add("d");                                    </span></span><br><span class="line">System.out.println(listArray);</span><br><span class="line"><span class="comment">//通过这种方式将listArray转换成真正的ArrayList</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(listArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Arrays.asList((T… a))的源码可以看到，这里面返回的ArrayList是在Arrays类里面定义的一个内部类，并非java.util包下的ArrayList。</span></span><br></pre></td></tr></table></figure>
<p>基本数据类型的数组转换成集合,会将整个数组当作一个对象转换，下面程序将会打印出list的对象地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;            </span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; list = Arrays.asList(arr);            </span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// ==&gt;[[I@282ba1e]</span></span><br></pre></td></tr></table></figure>
<p>==&gt;▲.将数组转换成集合,数组中的数据必须是引用数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;                    </span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(arr);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// ==&gt;[11, 22, 33, 44, 55]</span></span><br></pre></td></tr></table></figure>
<h2 id="collection集合"><a class="markdownIt-Anchor" href="#collection集合"></a> Collection集合</h2>
<h3 id="set的特点"><a class="markdownIt-Anchor" href="#set的特点"></a> Set的特点</h3>
<p>Set里面存储的元素不能重复，没有索引，存取顺序不一致。</p>
<p><strong>▲.这里需要注意：在向HashSet中存放自定义类型对象时，一定要<a href="###HashCode%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8">重写hashCode和equals方法</a></strong>，原因是无重复的话需要比较， 所以得。</p>
<h3 id="treeset简介"><a class="markdownIt-Anchor" href="#treeset简介"></a> TreeSet简介</h3>
<p>TreeSet的特点是可以对存放进去的元素<strong>进行排序</strong>。</p>
<p>∴ 使用TreeSet存储自定义类型。这里还是存储之前定义的Person对象，<strong>需要实现Comparable接口并且重写compareTo方法</strong>，先根据name的字典顺序排序，然后再根据年龄进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.nymrli.day07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.scene.PerspectiveCamera;</span><br><span class="line"><span class="keyword">import</span> javafx.util.converter.PercentageStringConverter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: testIDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Set测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: MrLi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2020-05-16 09:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">day07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        boolean b1 = hs.add("a");</span></span><br><span class="line"><span class="comment">//        System.out.println(hs);</span></span><br><span class="line"><span class="comment">//        boolean c1 = hs.add("b");</span></span><br><span class="line"><span class="comment">//        System.out.println(hs);</span></span><br><span class="line"><span class="comment">//        for (String s : hs) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(s);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Q1:</span></span><br><span class="line"><span class="comment">//        HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        Random random = new Random();</span></span><br><span class="line"><span class="comment">//        while (hashSet.size() &lt; 10) &#123;</span></span><br><span class="line"><span class="comment">//            int num = random.nextInt(20);</span></span><br><span class="line"><span class="comment">//            hashSet.add(num);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        for (Integer i : hashSet) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(i);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Q2;Treeset</span></span><br><span class="line">        TreeSet&lt;Person&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"cl"</span>, <span class="number">30</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"qsy"</span>, <span class="number">25</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"sxh"</span>, <span class="number">30</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"ll"</span>, <span class="number">15</span>));</span><br><span class="line">        <span class="keyword">for</span> (Person p : ts) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(getName(), person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nameSame = <span class="keyword">this</span>.name.compareTo(o.name);</span><br><span class="line">        <span class="keyword">if</span> (nameSame != <span class="number">0</span>)&#123;     <span class="comment">// 如果name不相等</span></span><br><span class="line">            <span class="comment">// 当compareTo方法返回正数的时候，系统将元素存储到右边，所以集合存取顺序一致</span></span><br><span class="line">            <span class="keyword">return</span> nameSame;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map接口概述"><a class="markdownIt-Anchor" href="#map接口概述"></a> Map接口概述</h3>
<blockquote>
<p>map中的元素是以键-值的方式存在的，通过键可以获取到值，键是不可以重复的，跟地图比较像，通过一个坐标就可以找到具体的位置。该接口由三个类实现: <code>HashMap / HashTable / AbstractMap</code></p>
</blockquote>
<p>▲与前两个相比，添加元素的函数由<code>add =&gt; put</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">day08_Map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashmap.put(<span class="string">"Cl"</span>, <span class="number">18</span>);</span><br><span class="line">        hashmap.put(<span class="string">"GJQ"</span>, <span class="number">15</span>);</span><br><span class="line">        hashmap.put(<span class="string">"SXH"</span>, <span class="number">10</span>);</span><br><span class="line">        hashmap.put(<span class="string">"HSR"</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(hashmap);</span><br><span class="line">        System.out.println(hashmap.containsValue(<span class="string">"CL"</span>));</span><br><span class="line">        System.out.println(hashmap.containsKey(<span class="string">"GJQ"</span>));</span><br><span class="line">        System.out.println(<span class="string">"------"</span>);</span><br><span class="line">        Collection&lt;Integer&gt; values = hashmap.values();</span><br><span class="line">        System.out.println(values);</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        Integer res = hashmap.remove(<span class="string">"SXH"</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map的遍历</span></span><br><span class="line">        <span class="comment">// 方法一</span></span><br><span class="line">        Set&lt;String&gt; keySet = hashmap.keySet();</span><br><span class="line">        Iterator&lt;String&gt; iterator = keySet.iterator();</span><br><span class="line">        System.out.println(keySet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"Key: "</span> + key + <span class="string">" value: "</span> + hashmap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"---------"</span>);</span><br><span class="line">        <span class="comment">// 上述的代替写法</span></span><br><span class="line"><span class="comment">//        for (String key : keySet) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Key:" + key + "value: " + hashmap.get(key));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二</span></span><br><span class="line">        <span class="comment">// Map中的键和值被封装成了Entry对象,并存储在Set集合中，通过entrySet()可以获取到这个Set集合。</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = hashmap.entrySet();</span><br><span class="line"><span class="comment">//        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entriesIterator = entries.iterator();</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; en : entries) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Key:"</span> + en.getKey() + <span class="string">" value: "</span> + en.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"_______________"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>LinkedHashMap</strong></p>
<ul>
<li>LinkedHashMap的特点：存取顺序一致</li>
</ul>
<p><strong>TreeMap</strong></p>
<ul>
<li>TreeMap的特点：可以对存储的元素进行排序</li>
</ul>
<h4 id="hashmap和hashtable的区别"><a class="markdownIt-Anchor" href="#hashmap和hashtable的区别"></a> HashMap和Hashtable的区别</h4>
<ul>
<li>Hashtable是JDK1.0版本出现的,是线程安全的,效率低，不可以存储null键和null值</li>
<li>HashMap是JDK1.2版本出现的，是线程不安全,效率高，可以存储null键和null值</li>
</ul>
<h3 id="collection工具"><a class="markdownIt-Anchor" href="#collection工具"></a> Collection工具</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list);</span><br><span class="line">Collections.shuffle(list);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">Collections.binarySearch(list, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<h3 id="collection总结"><a class="markdownIt-Anchor" href="#collection总结"></a> Collection总结</h3>
<ul>
<li>
<p><strong>List(存取有序,有索引,可以重复)</strong></p>
<ul>
<li>ArrayList<br>
底层是数组实现的,线程不安全,查找和修改快,增和删比较慢</li>
<li>LinkedList<br>
底层是链表实现的,线程不安全,增和删比较快,查找和修改比较慢</li>
<li>Vector<br>
底层是数组实现的,线程安全的,无论增删改查都慢</li>
</ul>
</li>
</ul>
<p>如果查找和修改多,用ArrayList<br>
如果增和删多,用LinkedList<br>
如果都多,用ArrayList</p>
<ul>
<li>
<p><strong>Set(存取无序,无索引,不可以重复)</strong></p>
<ul>
<li>HashSet<br>
底层是哈希算法实现</li>
<li>LinkedHashSet<br>
底层是链表实现,可以保证元素唯一,存取顺序一致</li>
<li>TreeSet<br>
底层是二叉树算法实现，可以排序，存储自定义类型时需要注意实现Comparable接口并重写compareTo方法</li>
</ul>
<p>一般在开发的时候不需要对存储的元素排序,所以在开发的时候大多用HashSet,HashSet的效率比较高.TreeSet在面试的时候比较多</p>
</li>
<li>
<p><strong>Map</strong></p>
<ul>
<li>HashMap<br>
底层是哈希算法</li>
<li>LinkedHashMap<br>
底层是链表，存取顺序一致</li>
<li>TreeMap<br>
<strong>底层是二叉树算法</strong>，可以排序</li>
</ul>
<p>开发中用HashMap比较多</p>
</li>
</ul>
<h2 id="hashcode"><a class="markdownIt-Anchor" href="#hashcode"></a> HashCode</h2>
<h3 id="hashcode方法的作用"><a class="markdownIt-Anchor" href="#hashcode方法的作用"></a> HashCode方法的作用</h3>
<p>在HashSet中的元素是不能重复的，jvm可以通过equals方法来判断两个对象是否相同，假设自定义一个Person类里面有10个成员变量，每调用一次equals方法需要做10次if判断分别比较这10个成员变量是否相等，如果想HashSet中存放100个对象，那就会做1000次if判断，数据量大的话会严重影响性能。<br>
要解决这个问题的话可以这样做，将一些特征相似或相近的对象归类放到一起给他们一个编号，在做equals判断时，先比较这些编号，编号相同的话再去比较equals，这样可以减少一些比较次数。这个编号可以通过HashCode方法获得。<strong>HashCode方法的作用就是将对象进行分类，然后获取到编号值。</strong><br>
举个例子，图书馆里面的书都是分好类的，想找《java编程思想》这本书，先找到计算机类的书架，然后再去找就行，倘若图书馆里面的书籍没有分类，那找起来就如大海捞针。</p>
<h3 id="如何重写hashcode"><a class="markdownIt-Anchor" href="#如何重写hashcode"></a> 如何重写HashCode</h3>
<p>HashCode算法决定了对象的归类，如果算法编写的不好可能不会对性能有所提升。在编写时最好可以让对象均匀的散列开，这里假设可以将对象分为10个种类，那么每个种类中存放的对象的数量最好不要相差太多。</p>
<p>将Person的name和age属性都加上了，可以将Person进行细分，开发中建议使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    result = prime * result + age;</span><br><span class="line">    result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么上面的prime的值是31？其实这个值改成别的也可以，只不过定义为31之后有一些好处：</p>
<ul>
<li>31是一个质数,质数是能被1和自己本身整除的数，并且这个数不大也不小</li>
<li>31这个数好算,2的五次方-1,2向左移动5位</li>
</ul>
<h3 id="关于重写hashcode方法的一些说明"><a class="markdownIt-Anchor" href="#关于重写hashcode方法的一些说明"></a> 关于重写HashCode方法的一些说明</h3>
<ul>
<li>任何时候对同一对象多次调用 hashCode 方法，都必须一直返回同样的整数。</li>
<li>如果两个对象通过 equals(Object) 方法来比较相等，那么这两个对象的 hashCode的值必须相等。</li>
<li>如果两个对象通过 equals(Object) 方法比较结果不等，可以相等也可以不相等。</li>
</ul>
<h2 id="泛型的概念"><a class="markdownIt-Anchor" href="#泛型的概念"></a> 泛型的概念</h2>
<p>在编写集合相关代码时在eclipse里面总有一些黄色警告，在不使用注解的情况下，使用泛型之后，就不会有这些黄色警告了。<br>
通过API可以看到Collection,List,ArrayList,这几个类里面都有,这个就是泛型，里面的E可以是任何引用数据类型，使用泛型指明了数据类型之后，这个集合里面只能存储这种数据类型的对象。</p>
<p>不使用泛型时，要进行多次类型强制转换。如<code>List list = new ArrayList();</code></p>
<p>使用泛型: <code>List&lt;Person&gt; list = new ArrayList&lt;Person&gt;();</code></p>
<h3 id="泛型的优点"><a class="markdownIt-Anchor" href="#泛型的优点"></a> <strong>泛型的优点</strong></h3>
<ul>
<li>可以统一集合中的数据类型，提高安全性</li>
<li>可以减少强制类型转换</li>
</ul>
<h3 id="自定义泛型"><a class="markdownIt-Anchor" href="#自定义泛型"></a> 自定义泛型</h3>
<p>通过JDK的源码可以看到，泛型一般写的都是或者，里面的T和E就是表示使用者指定的类型。可以自己定义一个使用泛型的类</p>
<h3 id="泛型通配符"><a class="markdownIt-Anchor" href="#泛型通配符"></a> 泛型通配符</h3>
<p>在实际工作当中，有可能通过调用某个方法来接受一个返回值List的数据，这样就不<strong>太好确定返回值中的数据类型</strong>，这样可以使用泛型通配符&lt;?&gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//=号右边可能是通过调用某个方法返回的List</span></span><br></pre></td></tr></table></figure>
<p>使用泛型通配符限定子类或者父类</p>
<ul>
<li><code>? extends E</code><br>
向下限定，E及其子类，可以存储当前类型的子类</li>
<li><code>? super E</code><br>
向上限定，E及其父类，可以存储当前类型的父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ? extends E 向下限定，E及其子类，可以存储当前类型的子类 </span></span><br><span class="line"><span class="comment"> * ? super E 向上限定，E及其父类，可以存储当前类型的父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Student&gt; studentList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//因为studentList中存放的Student是Person类的子类，所以可以将studentList放入personList中</span></span><br><span class="line">        personList.addAll(studentList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合框架中的三种迭代方式删除数据"><a class="markdownIt-Anchor" href="#集合框架中的三种迭代方式删除数据"></a> 集合框架中的三种迭代方式删除数据</h2>
<ul>
<li>
<p>普通for循环,可以删除,注意让索引做自减运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,普通for循环删除,索引做自减运算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"b"</span>.equals(list.get(i))) &#123;</span><br><span class="line">        list.remove(i);        </span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常</p>
</li>
<li>
<p>增强for循环不能删除</p>
</li>
</ul>
<h2 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h2>
<blockquote>
<p><strong>注意：如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰符 返回值类型 方法名(数据类型…  变量名)&#123;&#125;</span></span><br><span class="line"><span class="comment">//可变参数其实是一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> ... arr)</span> </span>&#123;            </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解:</h2>
<blockquote>
<p>之前也看过一些Java-Spring Boot的视频, 有些讲的详细的会去讲源码，然后当时就是看到有很多注解， 就不懂是什么意思， 形成了理解障碍。 所以这次特地又去了解了一下</p>
</blockquote>
<p>Spring-Boot的入口函数是由<code>@SpringBootApplication</code>注解的main，无疑<code>@SpringBootApplication</code>这个注解是非常重要的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), <span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述一共七个注解，一共可以分成三类： 元注解、配置注解、Component组件注解。之前学的时候就是被这么多注解给吓到了，而且课上对注解的讲解也特别小， 所以一直感觉注解是个高深莫测的东西。</p>
<ul>
<li>
<p>元注解讲解： <a href="https://www.cnblogs.com/kingsonfu/p/10634174.html" target="_blank" rel="noopener">Java 元注解</a></p>
<ul>
<li><code>@Inherited</code>使用该注解的注解父类的子类可以继承父类的注解。请注意，<u>如果使用注释类型来注释除类之外的任何内容，则此元注释类型不起作用</u>。 还要注意，这个元注释只会导致从超类继承注释; 已实现的接口上的注释无效。</li>
</ul>
</li>
<li>
<p>配置注解源码讲解: <a href="https://www.bilibili.com/video/BV1gW411W76m/?p=7&amp;t=428" target="_blank" rel="noopener">尚硅谷SpringBoot顶尖教程(springboot之idea版spring boot)</a></p>
<ul>
<li>
<p><code>@AutoConfigurationPackage</code>由<code>@Import({Registrar.class})</code>注解，其中<code>Registrar</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));	<span class="comment">// 后面第二个参数的结果是metadata中的所有包==&gt;即获得主配置类所在包及以下子包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将主配置类(<code>@SpringBootApplication</code>标注的类)所在包及下面子包里面的所有组件扫描到Spring容器中</p>
</li>
</ul>
</li>
</ul>
<p>注解（Annontion）是Java5开始引入的新特征。它提供了一种<strong>安全的类似注释的机制</strong>，用来将<strong>任何的信息或元数据</strong>（metadata）与程序元素（类、方法、成员变量等）进行关联。==&gt;类似注释，但能将内容传递给程序，对修饰对象有约束作用。</p>
<h2 id="io流"><a class="markdownIt-Anchor" href="#io流"></a> IO流</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次调用的时候会读取一个字节的数据，如果read返回结果是-1，则说明读取完毕</span></span><br><span class="line"><span class="keyword">int</span> temp;<span class="comment">//保存当前读取的字节数据</span></span><br><span class="line"><span class="comment">//将读取的数据赋值给temp，然后再判断</span></span><br><span class="line"><span class="keyword">while</span> ((temp = f.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用fileseparator解决不同系统的路径问题"><a class="markdownIt-Anchor" href="#使用fileseparator解决不同系统的路径问题"></a> 使用File.separator解决不同系统的路径问题</h3>
<p>在windos中的文件路径是以&quot;“来分隔<br>
在linux中的文件路径是以”/&quot;来分隔<br>
如果将上面代码部署到linux中会读取不到文件，为了保证编写的代码跨平台需要使用java.io包下的File.separator来替代文件路径的分隔符，如下：<code>fis = new FileInputStream(&quot;file&quot; + File.separator + &quot;monkey.txt&quot;);</code></p>
<h3 id="文件io读写fileinputstream"><a class="markdownIt-Anchor" href="#文件io读写fileinputstream"></a> 文件IO读写FileInputStream</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">copy_io</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\10630\\Desktop\\TODO\\ok.yml"</span>);</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"good.txt"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> newFile = file.createNewFile();</span><br><span class="line">                System.out.println(<span class="string">"Yes, Create it~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"good.txt"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] arr= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line">            <span class="keyword">while</span> ((length = fis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// f.read(arr)和f.read()不一样， </span></span><br><span class="line">                <span class="comment">// f.read(arr)会一次性读取arr大小的数据， 然后长度用length来记录读取了多少字符</span></span><br><span class="line">                <span class="comment">// write写的时候， 将数组arr中length写入文件</span></span><br><span class="line">                <span class="comment">// 在while中输出了length的大小， 为1024， 842</span></span><br><span class="line">                fos.write(arr, <span class="number">0</span>, length);</span><br><span class="line">                System.out.println(length);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用缓冲流进行文件拷贝bufferedinputstream"><a class="markdownIt-Anchor" href="#使用缓冲流进行文件拷贝bufferedinputstream"></a> 使用缓冲流进行文件拷贝BufferedInputStream</h3>
<p>Java中提供了<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>缓冲流用来读取和写出， <code>BufferedInputStream</code>读取时会创建一个长度为8192的byte类型数组，程序一次读取8192个字节数据到数组中 使用缓冲流之后就不用再自定义byte类型数组了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bufferStream_io</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\10630\\Desktop\\TODO\\ok.yml"</span>));</span><br><span class="line">            bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">            <span class="comment">// 其实不存在会自动创建, 不需要下面的代码</span></span><br><span class="line">            File f = <span class="keyword">new</span> File(<span class="string">"text.txt"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> newFile = f.createNewFile();</span><br><span class="line">                System.out.println(<span class="string">"创建成功~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp;</span><br><span class="line">            <span class="keyword">while</span> ((tmp = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.monkey1024.com/javase/608" target="_blank" rel="noopener">使用自定义数组和buffer的图解</a></p>
<h3 id="jdk7的新写法"><a class="markdownIt-Anchor" href="#jdk7的新写法"></a> jdk7的新写法</h3>
<p>在jdk7中新加入了AutoCloseable接口，IO流中的类都实现了这个接口，这样在读取或者写出操作结束之后，系统会自动close相关资源，开发者不需要再手动close了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\10630\\Desktop\\TODO\\ok.yml"</span>)); BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"auto.txt"</span>));) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> ((tmp = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用字符流解决乱码问题filereader"><a class="markdownIt-Anchor" href="#使用字符流解决乱码问题filereader"></a> 使用字符流解决乱码问题FileReader</h2>
<blockquote>
<p>字符流FileReader主要用来读取字符的IO流，使用字符流读取文本文件可以解决乱码问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader_io</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">"G:\\C与C++、\\java\\testIDEA\\src\\testForChinests.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">while</span> ((c = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用缓冲流bufferedreader可以一次读取一行的文字"><a class="markdownIt-Anchor" href="#使用缓冲流bufferedreader可以一次读取一行的文字"></a> 使用缓冲流<strong>BufferedReader</strong>可以一次读取一行的文字：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">try</span> (BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"G:\\C与C++、\\java\\testIDEA\\src\\testForChinests.txt"</span>))) &#123;</span><br><span class="line">          String s;</span><br><span class="line">          <span class="keyword">while</span> ((s = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">              System.out.print(s);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>写入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">      <span class="keyword">try</span>(FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"newword.txt"</span>);)&#123;</span><br><span class="line">          fw.write(<span class="string">"我喜欢学习java"</span>);</span><br><span class="line">          fw.write(<span class="number">32</span>);       <span class="comment">// 空格</span></span><br><span class="line">          fw.write(<span class="number">97</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span>(BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"newword.txt"</span>));)&#123;</span><br><span class="line">          bw.write(<span class="string">"我喜欢打篮球"</span>);</span><br><span class="line">          bw.newLine();<span class="comment">//换行</span></span><br><span class="line">          bw.write(<span class="string">"我喜欢踢足球"</span>);</span><br><span class="line">          bw.flush();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>BufferedWriter、BufferedInputStream内的参数都是原有的FileWrite、FileInputStream，实际上使用了装饰模式（设计模式）</p>
<p><strong>装饰者设计模式的优点：</strong><br>
不用修改被装饰对象的源码，装饰者与被装饰者耦合度不高。</p>
<h3 id="转换流"><a class="markdownIt-Anchor" href="#转换流"></a> <a href="http://www.monkey1024.com/javase/624" target="_blank" rel="noopener">转换流</a>——编码格式转换InputStreamReader</h3>
<p>如果要解决上面问题，需要使用InputStreamReader和OutputStreamWriter指明文本文件的编码，这两个类都属于字符流，可以将字节流输出为字符流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用FileInputStream读取文本内容，然后通过InputStreamReader和指定的编码将字符转换为字节</span></span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"utf-8.txt"</span>), <span class="string">"utf-8"</span>));</span><br><span class="line">            BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">                    <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"gbk.txt"</span>), <span class="string">"gbk"</span>));) &#123;</span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">while</span>((msg = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        bw.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException | FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中再FileInputStream对象上使用了InputStreamReader装饰，从而将字节转换为字符，之后再InputStreamReader对象上又使用了BufferedReader将字符进行缓冲，从而提高。==&gt;都有reader</p>
<h2 id="输出指定目录下的所有文件名称"><a class="markdownIt-Anchor" href="#输出指定目录下的所有文件名称"></a> 输出指定目录下的所有文件名称</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputAllFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> File file = getFile();</span><br><span class="line">        getListFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getListFiles</span><span class="params">(File f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> File[] files = f.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">'\t'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(files[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (files[i].isDirectory()) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                getListFiles(files[i]);</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">getFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"请输入要遍历的目录: "</span>);</span><br><span class="line">        <span class="keyword">final</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> String next = scanner.nextLine();</span><br><span class="line">            <span class="comment">//　next()不会吸取字符前/后的空格/Tab键，只吸取字符，开始吸取字符（字符前后不算）直到遇到空格/Tab键/回车截止吸取；</span></span><br><span class="line">            <span class="comment">//　nextLine()吸取字符前后的空格/Tab键，回车键截止。</span></span><br><span class="line">            <span class="keyword">final</span> File file = <span class="keyword">new</span> File(next);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"输出的路径错误, 请重新输入"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"请输入一个文件夹路径"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> file;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="序列化和反序列化"><a class="markdownIt-Anchor" href="#序列化和反序列化"></a> 序列化和反序列化</h2>
<blockquote>
<ul>
<li>在工作中有可能遇到多台机器远程通信的情况，如果要将机器A中的某个java对象传输到机器B上面，需要将这个java对象转换为字节序列然后进行传输。将对象转换为字节序列的过程叫做序列化，反之叫做反序列化。</li>
<li>使用序列化还可以将一个对象保存到硬盘中，然后再通过反序列化将该对象读取到内存里面。</li>
</ul>
<p>一个对象如果支持序列化，需要实现Serializable的接口，<u>这个接口中没有任何方法</u>，实现该接口后，JVM会给这个对象做特殊待遇</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Student s = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream zhangsan = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"zhangsan"</span>))) &#123;</span><br><span class="line">            <span class="comment">// try()括号中，如果是多句， 则加;， 单句不需要加;</span></span><br><span class="line">            <span class="comment">// ObjectOutputStream也是一个装饰模式</span></span><br><span class="line">            zhangsan.writeObject(s);</span><br><span class="line">            zhangsan.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个类实现Serializable接口后，系统会给每个对象一个序列化版本号，当这个类的源码被修改后，系统会重新分配一个新的序列化版本号，这样做的好处就是保证序列化和反序列化的对象内容一致。例如将一个对象序列化到硬盘之后，修改这个对象所对应类的源码，在进行反序列化是就会报出InvalidClassException异常。如果手动编写序列化版本号之后，就不会出现这个异常了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动生成序列化版本号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">716323668524282676L</span>;</span><br></pre></td></tr></table></figure>
<h3 id="transient关键字"><a class="markdownIt-Anchor" href="#transient关键字"></a> transient关键字</h3>
<p>如果不希望将Student类中的age属性序列化，可以使用transient声明该属性，在序列化时将忽略这个属性。<code>transient private int age;</code></p>
<h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h2>
<h3 id="三种创建方式"><a class="markdownIt-Anchor" href="#三种创建方式"></a> 三种创建方式</h3>
<ul>
<li>
<p>继承Thread类， 重写run方法</p>
<ul>
<li>优点:可以直接使用Thread类中的方法,代码简单</li>
<li>缺点:继承Thread类之后就不能继承其他的类</li>
</ul>
</li>
<li>
<p>实现runnable接口， 重写run方法</p>
<ul>
<li>优点:即时自定义类已经有父类了也不受影响，因为可以实现多个接口</li>
<li>缺点:在run方法内部需要获取到当前线程的Thread对象后才能使用Thread中的方法</li>
</ul>
</li>
<li>
<p>实现Callable接口创建线程</p>
<ul>
<li>
<p>优点：可以获取返回值，可以抛出异常</p>
</li>
<li>
<p>缺点：代码编写较为复杂</p>
<p>1.自定义一个类实现java.util.concurrent包下的Callable接口<br>
2.重写call方法<br>
3.将要在线程中执行的代码编写在call方法中<br>
4.创建<code>ExecutorService</code>线程池<br>
5.将自定义类的对象放入线程池里面<br>
6.获取线程的返回结果<br>
7.关闭线程池，不再接收新的线程，未执行完的线程不会被关闭</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义一个类实现Callable&lt;V&gt;接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 2.重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 3.将要执行的代码写在call方法中</span></span><br><span class="line">        <span class="comment">//返回一个随机数</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> num = r.nextInt(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread_callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//4.创建ExecutorService线程池</span></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.将自定义类的对象放入线程池里面</span></span><br><span class="line">        <span class="comment">//开启两个线程</span></span><br><span class="line">        Future&lt;Integer&gt; result1 = exec.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        Future&lt;Integer&gt; result2 = exec.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断线程是否计算完毕</span></span><br><span class="line">        <span class="keyword">while</span> (!result1.isDone() &amp;&amp; !result2.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"等待线程计算完毕"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.获取线程的返回结果</span></span><br><span class="line">        Integer i1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i1 = result1.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Integer i2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i2 = result2.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(i1);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.关闭线程池，不再接收新的线程，未执行完的线程不会被关闭</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3>
<p>线程池是初始化一个多线程应用程序过程中创建一个<strong>线程集合</strong>，即一次创建多个线程，然后在需要执行新的任务时直接去这个线程集合中获取，而不是重新创建一个线程。任务执行结束后，线程放回到池子中等待下一次的分配。</p>
<p><strong>线程池的作用</strong></p>
<p>解决创建单个线程耗费时间和资源的问题。</p>
<p><strong>创建线程池</strong></p>
<p>上面代码中演示了两种方式创建线程池</p>
<ul>
<li><code>Executors.newFixedThreadPool(int nThreads);</code><br>
通过传入的int类型参数来指定创建线程池中的线程数，如果任务数量大于线程数量，则任务会进行等待。</li>
<li><code>Executors.newCachedThreadPool();</code><br>
会根据需要创建新线程的线程池，如果线程池中的线程数量小于任务数时，会创建新的线程，线程池中的线程最大数量是Integer.MAX_VALUE，int类型的最大值。如果线程的处理速度小于任务的提交速度时，会不断创建新的线程来执行任务，这样有可能会因为创建过多线程而耗尽CPU 和内存资源。</li>
</ul>
<p>匿名内部类、labmbda表达式创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewWayCreateThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 匿名内部类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: MrLi        </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [args] </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Return</span>: void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/5/18 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    System.out.println( Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">                    System.out.println( getClass() + <span class="string">" "</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: labmbda表达式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: MrLi</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [args]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Return</span>: void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/5/18</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized同步方法与同步代码块"><a class="markdownIt-Anchor" href="#synchronized同步方法与同步代码块"></a> synchronized同步方法与同步代码块</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> begin1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> end1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> begin2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> end2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LongTask ts = <span class="keyword">new</span> LongTask();</span><br><span class="line">        Thread t1 =<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            begin1 = System.currentTimeMillis();</span><br><span class="line">            ts.add();</span><br><span class="line">            end1 = System.currentTimeMillis();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//        new Thread(syncValue::add).start();</span></span><br><span class="line">             begin2 = System.currentTimeMillis();</span><br><span class="line">            ts.add();</span><br><span class="line">             end2 = System.currentTimeMillis();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(begin1 &gt; begin2)&#123;</span><br><span class="line">            begin = begin2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            begin = begin1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(end1 &gt; end2)&#123;</span><br><span class="line">            end = end1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            end = end2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"两个线程总共耗时："</span> + (end -begin) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public synchronized void add() &#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(3000L);</span></span><br><span class="line"><span class="comment">//            System.out.println("执行耗时任务");</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        num++;</span></span><br><span class="line"><span class="comment">//        System.out.println(num);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//两个线程总共耗时：6001ms</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">            System.out.println(<span class="string">"执行耗时任务"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个线程总共耗时：3001ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后将需要同步的代码放到synchronized代码块中，再次运行SynchronizedTest02类，打印结果是3秒，因为那段耗时较长的代码是在异步情况下运行，所以节省了一些时间。</p>
<p><strong>注意：多个线程在执行synchronized同步代码块时，代码块括号里面可以传入任意对象，但一定要保证多个线程访问的是同一个对象。</strong>(这里代码只有一个实例, 这个实例的obj是相同的)</p>
<h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2>
<h3 id="饿汉式"><a class="markdownIt-Anchor" href="#饿汉式"></a> 饿汉式</h3>
<ul>
<li>构造方法私有化</li>
<li>创建当前类对象</li>
<li>对外提供公共的访问方法将SingletonHungary对象暴露给外部</li>
</ul>
<h3 id="懒汉式"><a class="markdownIt-Anchor" href="#懒汉式"></a> 懒汉式</h3>
<ul>
<li>构造方法私有化</li>
<li>创建当前类的引用</li>
<li>对外提供公共的访问方法将SingletonHungary对象暴露给外部</li>
</ul>
<h3 id="单例模式的案例runtime"><a class="markdownIt-Anchor" href="#单例模式的案例runtime"></a> 单例模式的案例Runtime</h3>
<p>java.lang包下的Runtime类使用了单例模式，使用该类可以执行windows系统里面的一些命令，例如：mspaint（打开画图软件），shutdown（关机）等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Runtime rt = Runtime.getRuntime();</span><br><span class="line">    rt.exec(<span class="string">"mspaint"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用timer类来实现定时任务"><a class="markdownIt-Anchor" href="#使用timer类来实现定时任务"></a> 使用Timer类来实现定时任务</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Timer t = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">//        t.schedule(new TimerTask() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//                final Date date = new Date();</span></span><br><span class="line"><span class="comment">//                System.out.println(date);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;, new SimpleDateFormat("yyyy-MM-dd hh:mm:ss SSS").parse("2017-07-03 18:09:00 000"), 5000);</span></span><br><span class="line">        <span class="comment">//第一个参数接收TimerTask对象，即上面创建的MyTimerTask</span></span><br><span class="line">        <span class="comment">//第二参数的Date类型是定时任务执行的开始时间</span></span><br><span class="line">        <span class="comment">//第三个参数指定定时任务每隔多少毫秒执行一次</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        t.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1>
<h2 id="qjava-定义long和float为什么要加l和f"><a class="markdownIt-Anchor" href="#qjava-定义long和float为什么要加l和f"></a> Q:java 定义long和float为什么要加L和F？</h2>
<p>A:整形默认值为int，如果定义long 必须要加L来区分，浮点型默认值为double双精度，定义单精度float要加F来区分。</p>
<h2 id="java中suppresswarnings的作用"><a class="markdownIt-Anchor" href="#java中suppresswarnings的作用"></a> <a href="https://www.cnblogs.com/huanglog/p/11587077.html" target="_blank" rel="noopener">Java中@SuppressWarnings的作用</a></h2>
<p>A:作用：告诉编译器忽略指定的警告，不用在编译完成后出现警告信息。如<code>@SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)</code>等同于@SuppressWarnings(“unchecked”, “deprecation”)</p>
<h2 id="输出变量类型python中type关键字"><a class="markdownIt-Anchor" href="#输出变量类型python中type关键字"></a> 输出变量类型——Python中type关键字</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Object o)</span></span>&#123;  <span class="comment">//通过反射来获取变量类型方法</span></span><br><span class="line">	<span class="keyword">return</span> o.getClass().toString(); <span class="comment">//使用int类型的getClass()方法</span></span><br><span class="line">    <span class="comment">// return o.getClass().getName(); //使用int类型的getClass()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>▲. 基本数据类型无效， 如int， 但可以查看包装数据类型。</p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2020/05/15/重拾Java笔记/">https://nymrli.top/2020/05/15/重拾Java笔记/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2020/05/15/IDEA配置——自定义快捷键、生成注释/" title="IDEA配置——自定义快捷键、生成注释"><span>< PreviousPost</span><br><span class="prevTitle">IDEA配置——自定义快捷键、生成注释</span></a><a class="nextSlogan" href="/2020/04/29/华为春招4-29笔试题/" title="华为春招4.29笔试题"><span>NextPost ></span><br><span class="nextTitle">华为春招4.29笔试题</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '重拾Java笔记',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><span>备案号:苏ICP备18015439号</span></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#重拾java笔记"><span class="toc-number">1.</span> <span class="toc-text"> 重拾Java笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#命名规范"><span class="toc-number">1.1.</span> <span class="toc-text"> 命名规范:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class与文件名"><span class="toc-number">1.2.</span> <span class="toc-text"> class与文件名:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数传参"><span class="toc-number">1.3.</span> <span class="toc-text"> 函数传参:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码块的分类"><span class="toc-number">1.4.</span> <span class="toc-text"> 代码块的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行顺序"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 执行顺序:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this指针"><span class="toc-number">1.5.</span> <span class="toc-text"> this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承问题"><span class="toc-number">1.6.</span> <span class="toc-text"> 继承问题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多态"><span class="toc-number">1.7.</span> <span class="toc-text"> 多态：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重写"><span class="toc-number">1.8.</span> <span class="toc-text"> 重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super关键字"><span class="toc-number">1.9.</span> <span class="toc-text"> Super关键字:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object类之finalize方法"><span class="toc-number">1.10.</span> <span class="toc-text"> Object类之finalize方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问控制权限"><span class="toc-number">1.11.</span> <span class="toc-text"> 访问控制权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数的权限问题"><span class="toc-number">1.11.1.</span> <span class="toc-text"> 构造函数的权限问题:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final关键字"><span class="toc-number">1.12.</span> <span class="toc-text"> Final关键字:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static关键字"><span class="toc-number">1.13.</span> <span class="toc-text"> static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static的作用"><span class="toc-number">1.13.1.</span> <span class="toc-text"> static的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象类的特点"><span class="toc-number">1.14.</span> <span class="toc-text"> 抽象类的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-number">1.15.</span> <span class="toc-text"> 接口：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equals"><span class="toc-number">1.16.</span> <span class="toc-text"> equals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内部类的分类"><span class="toc-number">1.17.</span> <span class="toc-text"> 内部类的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常的分类"><span class="toc-number">1.18.</span> <span class="toc-text"> 异常的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm是如何处理异常的"><span class="toc-number">1.18.1.</span> <span class="toc-text"> JVM是如何处理异常的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw和throws"><span class="toc-number">1.18.2.</span> <span class="toc-text"> throw和throws</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义异常"><span class="toc-number">1.18.3.</span> <span class="toc-text"> 自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#catch"><span class="toc-number">1.18.4.</span> <span class="toc-text"> catch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串的不可变性"><span class="toc-number">1.19.</span> <span class="toc-text"> 字符串的不可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string类不能被继承"><span class="toc-number">1.19.1.</span> <span class="toc-text"> String类不能被继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串string的不可变性"><span class="toc-number">1.19.2.</span> <span class="toc-text"> 字符串（String）的不可变性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串常量池"><span class="toc-number">1.19.3.</span> <span class="toc-text"> 字符串常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-stringbuffer-stringbuilder"><span class="toc-number">1.20.</span> <span class="toc-text"> String、StringBuffer、StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stringbuffer"><span class="toc-number">1.20.1.</span> <span class="toc-text"> StringBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stringbuilder和stringbuffer的区别"><span class="toc-number">1.20.2.</span> <span class="toc-text"> StringBuilder和StringBuffer的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是自动拆箱和自动装箱"><span class="toc-number">1.21.</span> <span class="toc-text"> 什么是自动拆箱和自动装箱？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-number">1.22.</span> <span class="toc-text"> 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#集合的由来"><span class="toc-number">1.22.1.</span> <span class="toc-text"> 集合的由来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合类的一些特点"><span class="toc-number">1.22.2.</span> <span class="toc-text"> 集合类的一些特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区别"><span class="toc-number">1.22.3.</span> <span class="toc-text"> 区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list两个子类的特点"><span class="toc-number">1.23.</span> <span class="toc-text"> List两个子类的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist线程安全的方案"><span class="toc-number">1.23.1.</span> <span class="toc-text"> ArrayList线程安全的方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合数组的互转"><span class="toc-number">1.24.</span> <span class="toc-text"> 集合数组的互转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collection集合"><span class="toc-number">1.25.</span> <span class="toc-text"> Collection集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#set的特点"><span class="toc-number">1.25.1.</span> <span class="toc-text"> Set的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#treeset简介"><span class="toc-number">1.25.2.</span> <span class="toc-text"> TreeSet简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map接口概述"><span class="toc-number">1.25.3.</span> <span class="toc-text"> Map接口概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmap和hashtable的区别"><span class="toc-number">1.25.3.1.</span> <span class="toc-text"> HashMap和Hashtable的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collection工具"><span class="toc-number">1.25.4.</span> <span class="toc-text"> Collection工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collection总结"><span class="toc-number">1.25.5.</span> <span class="toc-text"> Collection总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashcode"><span class="toc-number">1.26.</span> <span class="toc-text"> HashCode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashcode方法的作用"><span class="toc-number">1.26.1.</span> <span class="toc-text"> HashCode方法的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何重写hashcode"><span class="toc-number">1.26.2.</span> <span class="toc-text"> 如何重写HashCode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于重写hashcode方法的一些说明"><span class="toc-number">1.26.3.</span> <span class="toc-text"> 关于重写HashCode方法的一些说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型的概念"><span class="toc-number">1.27.</span> <span class="toc-text"> 泛型的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型的优点"><span class="toc-number">1.27.1.</span> <span class="toc-text"> 泛型的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义泛型"><span class="toc-number">1.27.2.</span> <span class="toc-text"> 自定义泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型通配符"><span class="toc-number">1.27.3.</span> <span class="toc-text"> 泛型通配符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合框架中的三种迭代方式删除数据"><span class="toc-number">1.28.</span> <span class="toc-text"> 集合框架中的三种迭代方式删除数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可变参数"><span class="toc-number">1.29.</span> <span class="toc-text"> 可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注解"><span class="toc-number">1.30.</span> <span class="toc-text"> 注解:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io流"><span class="toc-number">1.31.</span> <span class="toc-text"> IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用fileseparator解决不同系统的路径问题"><span class="toc-number">1.31.1.</span> <span class="toc-text"> 使用File.separator解决不同系统的路径问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件io读写fileinputstream"><span class="toc-number">1.31.2.</span> <span class="toc-text"> 文件IO读写FileInputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用缓冲流进行文件拷贝bufferedinputstream"><span class="toc-number">1.31.3.</span> <span class="toc-text"> 使用缓冲流进行文件拷贝BufferedInputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk7的新写法"><span class="toc-number">1.31.4.</span> <span class="toc-text"> jdk7的新写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用字符流解决乱码问题filereader"><span class="toc-number">1.32.</span> <span class="toc-text"> 使用字符流解决乱码问题FileReader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用缓冲流bufferedreader可以一次读取一行的文字"><span class="toc-number">1.32.1.</span> <span class="toc-text"> 使用缓冲流BufferedReader可以一次读取一行的文字：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换流"><span class="toc-number">1.32.2.</span> <span class="toc-text"> 转换流——编码格式转换InputStreamReader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输出指定目录下的所有文件名称"><span class="toc-number">1.33.</span> <span class="toc-text"> 输出指定目录下的所有文件名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#序列化和反序列化"><span class="toc-number">1.34.</span> <span class="toc-text"> 序列化和反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transient关键字"><span class="toc-number">1.34.1.</span> <span class="toc-text"> transient关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">1.35.</span> <span class="toc-text"> 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#三种创建方式"><span class="toc-number">1.35.1.</span> <span class="toc-text"> 三种创建方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-number">1.35.2.</span> <span class="toc-text"> 线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized同步方法与同步代码块"><span class="toc-number">1.36.</span> <span class="toc-text"> synchronized同步方法与同步代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式"><span class="toc-number">1.37.</span> <span class="toc-text"> 单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#饿汉式"><span class="toc-number">1.37.1.</span> <span class="toc-text"> 饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#懒汉式"><span class="toc-number">1.37.2.</span> <span class="toc-text"> 懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式的案例runtime"><span class="toc-number">1.37.3.</span> <span class="toc-text"> 单例模式的案例Runtime</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用timer类来实现定时任务"><span class="toc-number">1.38.</span> <span class="toc-text"> 使用Timer类来实现定时任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附录"><span class="toc-number">2.</span> <span class="toc-text"> 附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#qjava-定义long和float为什么要加l和f"><span class="toc-number">2.1.</span> <span class="toc-text"> Q:java 定义long和float为什么要加L和F？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java中suppresswarnings的作用"><span class="toc-number">2.2.</span> <span class="toc-text"> Java中@SuppressWarnings的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输出变量类型python中type关键字"><span class="toc-number">2.3.</span> <span class="toc-text"> 输出变量类型——Python中type关键字</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>