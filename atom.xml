<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>果粒橙的博客</title>
  
  <subtitle>别装作很努力，因为结局不会陪你演戏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nymrli.top/"/>
  <updated>2018-11-08T04:26:35.059Z</updated>
  <id>https://nymrli.top/</id>
  
  <author>
    <name>果粒橙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写爬虫过程中碰到的编码问题</title>
    <link href="https://nymrli.top/2018/11/08/%E5%86%99%E7%88%AC%E8%99%AB%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://nymrli.top/2018/11/08/写爬虫过程中碰到的编码问题/</id>
    <published>2018-11-08T04:23:19.000Z</published>
    <updated>2018-11-08T04:26:35.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写爬虫过程中碰到的编码问题"><a href="#写爬虫过程中碰到的编码问题" class="headerlink" title="写爬虫过程中碰到的编码问题"></a>写爬虫过程中碰到的编码问题</h2><h4 id="遇到-‘-uxxxx-‘-的16进制字符串编解码问题，使用-unicode-escape-解决之。"><a href="#遇到-‘-uxxxx-‘-的16进制字符串编解码问题，使用-unicode-escape-解决之。" class="headerlink" title="遇到 ‘ \uxxxx ‘ 的16进制字符串编解码问题，使用 unicode-escape 解决之。"></a>遇到 ‘ \uxxxx ‘ 的16进制字符串编解码问题，使用 unicode-escape 解决之。</h4><p>实际上，在将unicode存储到文本的过程中，还有一种存储方式，不需要将unicode转换为实际的文本存储字符集，而是将unicode的内存编码值进行存储，读取文件的时候再反向转换回来，是采用：unicode-escape的转换方式。 </p><blockquote><p><strong>将unicode的内存编码值进行存储，读取文件时在反向转换回来。这里就采用了unicode-escape的方式</strong>  </p></blockquote><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(u'中文测试'.encode('utf-8'))</span><br><span class="line">print('中文测试'.encode('utf-8'))</span><br><span class="line">print(u'中文测试'.encode('unicode-escape'))</span><br><span class="line">print('中文测试'.encode('unicode-escape'))</span><br><span class="line">==&gt;b'<span class="symbol">\x</span>e4<span class="symbol">\x</span>b8<span class="symbol">\x</span>ad<span class="symbol">\x</span>e6<span class="symbol">\x</span>96<span class="symbol">\x</span>87<span class="symbol">\x</span>e6<span class="symbol">\x</span>b5<span class="symbol">\x</span>8b<span class="symbol">\x</span>e8<span class="symbol">\x</span>af<span class="symbol">\x</span>95'</span><br><span class="line">==&gt;b'<span class="symbol">\x</span>e4<span class="symbol">\x</span>b8<span class="symbol">\x</span>ad<span class="symbol">\x</span>e6<span class="symbol">\x</span>96<span class="symbol">\x</span>87<span class="symbol">\x</span>e6<span class="symbol">\x</span>b5<span class="symbol">\x</span>8b<span class="symbol">\x</span>e8<span class="symbol">\x</span>af<span class="symbol">\x</span>95'</span><br><span class="line">==&gt;b'<span class="symbol">\\</span>u4e2d<span class="symbol">\\</span>u6587<span class="symbol">\\</span>u6d4b<span class="symbol">\\</span>u8bd5'</span><br><span class="line">==&gt;b'<span class="symbol">\\</span>u4e2d<span class="symbol">\\</span>u6587<span class="symbol">\\</span>u6d4b<span class="symbol">\\</span>u8bd5'</span><br></pre></td></tr></table></figure><hr><blockquote><p>ASCII码只有128个字符，符合英文，一个英文字符只用1个字节</p></blockquote><blockquote><p>ANSI：面向中文编码的GBK、GB2312是ANSI码的一种，ANSI码是对ASCII的拓展，所以一个英文只用一个字节，而中文需要拓展ASCII，所以用到两个字节。  0x80~0xFFFF =&gt;2**16</p></blockquote><blockquote><p>Unicode编码:为了解决不同国家ANSI编码的冲突问题，最常用的是用<strong>两个字节</strong>表示一个字符 。但是这样的话，原本可以用一个字节存储的英文字母在Unicode里面必须存两个字节，这就产生了浪费。那么有没有一种既能消除乱码，又能避免浪费的编码方式呢？===&gt;答案就是UTF-8 。000000 -10FFFF </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; UNICODE 的范围是 <span class="number">0x0000</span> - <span class="number">0xFFFF</span> 共<span class="number">6</span>万多个字符，其中光汉字就占用了<span class="number">4</span>万多个</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>UTF-8编码：当字符在ASCII码的范围时，就用一个字节表示 ，所以英文字符也只用一个字节，▲值得注意的是unicode编码中一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。utf-8长度是1-6个字节 （可变的）</strong></p></blockquote><table><thead><tr><th><strong>Unicode编码(十六进制)</strong></th><th><strong>UTF-8 字节流(二进制)</strong></th></tr></thead><tbody><tr><td>000000-00007F</td><td>0xxxxxxx</td></tr><tr><td>000080-0007FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>000800-00FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>010000-10FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx10xxxxxx</td></tr></tbody></table><p>超出10FFFF后，UTF-8与Unicode不再对应</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><blockquote><p>UTF-8 vs GBK：</p><p>UTF-8版本虽然具有良好的国际兼容性，但中文需要比GBK/BIG5版本多占用50%的数据库存储空间，因此并非推荐使用，仅供对国际兼容性有特殊要求的用户使用。简单地说：对于中文较多的网站，适宜用GBK编码节省数据库空间。对于英文较多的网站，适宜用UTF-8节省数据库空间。</p></blockquote><p><strong><a href="https://blog.csdn.net/xiangxianghehe/article/details/77574965" target="_blank" rel="noopener"> 字符编码ANSI和ASCII区别、Unicode和UTF-8区别 </a></strong></p><h3 id="Python中编码问题"><a href="#Python中编码问题" class="headerlink" title="Python中编码问题"></a>Python中编码问题</h3><hr><p>在python中，unicode是内存编码集，一般我们将数据存储到文件时，需要将数据先编码为其他编码集，比如utf-8、gbk等。</p><p>读取数据的时候再通过同样的编码集进行解码即可。</p><p>但是其实还有一种unicode-escape编码集，他是将unicode内存编码值直接存储： </p><blockquote><p>在使用python3的requests模块时，发现获取响应有两种方式</p><ul><li>其一，为文本响应内容, r.text是Unicode的响应内容 </li><li>其二，为二进制响应内容，r.content是二进制的响应内容 </li></ul></blockquote><hr><p>Python2 的编码问题一直非常让人恼火，不过你的问题稍微简单一些。<br>在交互式命令模式(Interactive shell)下，可以这样来明白你遇到的问题的根源： </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys </span><br><span class="line">sys<span class="selector-class">.stdout</span><span class="selector-class">.encoding</span> </span><br><span class="line">在 Windows 下，如果你的系统是简体中文，一般输出会是 cp936 </span><br><span class="line"></span><br><span class="line">import codecs </span><br><span class="line">codecs.lookup(<span class="string">'cp936'</span>)<span class="selector-class">.name</span> </span><br><span class="line"><span class="string">'gbk'</span></span><br></pre></td></tr></table></figure><blockquote><p>这就是在 Windows 终端里面使用的编码。在 print 的时候，无论字符串源采取什么样的编码，最终输出的字符串的编码必须跟 shell 的编码一致，也就是说:<br>print some_string<br>Python 会做这样一个动作：<br>codecs.encode(some_string, coding, errors=’strict’)<br>在你遇到的情况下，some_string 是一个 unicode 字符串，coding 是 gbk。由于你的 unicode 字符串里面包含 gbk 字符集里面没有的字符，Python 就会抛出一个 UnicodeEncodeError. </p></blockquote><p>对于输出到文件中情况是类似的，Python2 的 open() 函数不会传入 encoding，以 ‘w’ 方式打开文件，如果写入 unicode 字符串，Python 会获取当前默认的编码，然后以此种编码把字符串写入文件。可惜的是，“默认编码”只是 Python 自己默认的，在 Objects/unicodeobject.c 中，用一个全局变量 unicode_default_encoding 来表示默认的编码： </p><blockquote><p>/* Default encoding to use and assume when NULL is passed as encoding<br>    parameter; it is initialized by _PyUnicode_Init(). </p><p>​    Always use the PyUnicode_SetDefaultEncoding() and<br>​    PyUnicode_GetDefaultEncoding() APIs to access this global. </p></blockquote><p><code>static char unicode_default_encoding[100 + 1] = &quot;ascii&quot;;</code><br>这个值在 Python 中有C接口（PyUnicode_SetDefaultEncoding）去改变，但可惜的是没有 Python 层的接口。<br>所以在调用到类似 file.write(some_string) 的时候，首先会有这样的编码过程:<br>codecs.encode(some_string, coding, errors=’restrict’)<br>当你的 some_string 是一个 unicode 字符串，并且包含 ascii 字符串不存在的字符时，就会抛出一个 UnicodeEncodeError。 </p><blockquote><p>所以，为了解决这个问题，可以这么处理： </p><p>(1) 在 Windows shell 下面:<br>     &gt;&gt;&gt; print some_string.encode(‘gbk’, errors=’ignore’) # replace 也可，只要不是 restrict<br>(2) 在写入文件时，两种方法：<br>    a. 忽略不存在的字符，同(1)<br>    &gt;&gt;&gt; f = open(filename, ‘w’)<br>    &gt;&gt;&gt; f.write(some_string.encode(‘gbk’, errors=’ignore’)<br>    b. byte 方式写入：<br>    &gt;&gt;&gt; f = open(filename, ‘wb’)<br>    &gt;&gt;&gt; f.write(some_string.encode(‘utf-8’))<br>​    a 会损失字符，b 不会。 </p></blockquote><p>来自<a href="http://www.newsmth.net/nForum/#!article/Python/124657" target="_blank" rel="noopener">http://www.newsmth.net/nForum/#!article/Python/124657</a></p><hr><h3 id="如果CMD命令行是gbk编码的，则输出的utf-8字符有些也显示不了"><a href="#如果CMD命令行是gbk编码的，则输出的utf-8字符有些也显示不了" class="headerlink" title="如果CMD命令行是gbk编码的，则输出的utf-8字符有些也显示不了"></a>如果CMD命令行是gbk编码的，则输出的utf-8字符有些也显示不了</h3><hr><h4 id="Win10-临时修改cmd命令行窗口UTF-8编码"><a href="#Win10-临时修改cmd命令行窗口UTF-8编码" class="headerlink" title="Win10 临时修改cmd命令行窗口UTF-8编码"></a>Win10 临时修改cmd命令行窗口UTF-8编码</h4><blockquote><p>只作用于当前打开的窗口</p><p>进入cmd窗口后，直接执行“chcp 65001”，执行完后，cmd的编码格式就是UTF-8</p></blockquote><p><a href="https://blog.csdn.net/tfs411082561/article/details/78416569" target="_blank" rel="noopener">永远修改</a></p><h4 id="Windows-控制台使用注册表永久修改编码问题"><a href="#Windows-控制台使用注册表永久修改编码问题" class="headerlink" title="Windows 控制台使用注册表永久修改编码问题"></a>Windows 控制台使用注册表永久修改编码问题</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>1.在cmd中输入<code>regedit</code>进入注册表</p><p>2.找到<code>HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe</code></p><p>3.新建一个 DWORD（32位值）,命名为CodePage，值设为65001 </p><p>4.已有CodePage的话，修改它，改为十进制，65001</p><h5 id="方法二：-亲测有效"><a href="#方法二：-亲测有效" class="headerlink" title="方法二：(亲测有效)"></a>方法二：(亲测有效)</h5><p>1.新建一个cmd.reg注册表文件:</p><p>2.内容输入如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version <span class="number">5.00</span></span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe]</span><br><span class="line"><span class="string">"CodePage"</span>=<span class="string">dword:</span><span class="number">0000</span>fde9</span><br><span class="line"><span class="string">"FontFamily"</span>=<span class="string">dword:</span><span class="number">00000036</span></span><br><span class="line"><span class="string">"FontWeight"</span>=<span class="string">dword:</span><span class="number">00000190</span></span><br><span class="line"><span class="string">"FaceName"</span>=<span class="string">"Consolas"</span></span><br><span class="line"><span class="string">"ScreenBufferSize"</span>=<span class="string">dword:</span><span class="number">232900</span>d2</span><br><span class="line"><span class="string">"WindowSize"</span>=<span class="string">dword:</span><span class="number">002</span>b00d2</span><br></pre></td></tr></table></figure><p>3.双击运行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写爬虫过程中碰到的编码问题&quot;&gt;&lt;a href=&quot;#写爬虫过程中碰到的编码问题&quot; class=&quot;headerlink&quot; title=&quot;写爬虫过程中碰到的编码问题&quot;&gt;&lt;/a&gt;写爬虫过程中碰到的编码问题&lt;/h2&gt;&lt;h4 id=&quot;遇到-‘-uxxxx-‘-的16进制字符串
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本基础</title>
    <link href="https://nymrli.top/2018/11/08/Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"/>
    <id>https://nymrli.top/2018/11/08/Shell脚本基础/</id>
    <published>2018-11-08T04:19:49.000Z</published>
    <updated>2018-11-08T04:20:26.700Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><h3 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h3><p>打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#!/usr/bin/php</span></span><br></pre></td></tr></table></figure><p>“#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。</p><h4 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x <span class="keyword">test</span>.<span class="keyword">sh</span></span><br><span class="line">./<span class="keyword">test</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">"qinjx"</span></span><br><span class="line">▲.变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。</span><br></pre></td></tr></table></figure><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">"qinjx"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></span><br></pre></td></tr></table></figure><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> skill <span class="keyword">in</span> Ada Coffe Action Java; <span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"I am good at <span class="variable">$&#123;skill&#125;</span>Script"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了，哈哈），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p><h5 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">str</span>=<span class="string">'this is a string'</span></span><br></pre></td></tr></table></figure><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li><li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li></ul><h5 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">your_name</span>=<span class="string">'qinjx'</span></span><br><span class="line"><span class="attr">str</span>=<span class="string">"Hello, I know your are \"$your_name\"! \n"</span></span><br></pre></td></tr></table></figure><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h5 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">your_name</span>=<span class="string">"qinjx"</span></span><br><span class="line"><span class="attribute">greeting</span>=<span class="string">"hello, "</span><span class="variable">$your_name</span><span class="string">" !"</span></span><br><span class="line"><span class="attribute">greeting_1</span>=<span class="string">"hello, <span class="variable">$&#123;your_name&#125;</span> !"</span></span><br><span class="line"></span><br><span class="line">echo <span class="variable">$greeting</span> <span class="variable">$greeting_1</span></span><br></pre></td></tr></table></figure><h5 id="获取字符串长度："><a href="#获取字符串长度：" class="headerlink" title="获取字符串长度："></a>获取字符串长度：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">"abcd"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment">#输出：4</span></span><br></pre></td></tr></table></figure><h5 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>=<span class="string">"alibaba is a great company"</span></span><br><span class="line">echo $&#123;<span class="built_in">string</span>:<span class="number">1</span>:<span class="number">4</span>&#125; <span class="comment">#输出：liba</span></span><br></pre></td></tr></table></figure><h5 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>=<span class="string">"alibaba is a great company"</span></span><br><span class="line">echo `<span class="built_in">expr</span> index <span class="string">"$string"</span> <span class="keyword">is</span>`<span class="comment">#输出：3，这个语句的意思是：找出字母i在这名话中的位置，要在linux下运行，mac下会报错</span></span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>和Java、PHP等语言不一样，sh的流程控制不可为空，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">"q"</span>])) &#123;</span></span><br><span class="line"><span class="php">search(q);</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"><span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php"><span class="comment">//do nothing</span></span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p><p>还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll /usr/bin/[</span><br><span class="line">-rwxr-xr-x. <span class="number">1</span> root root <span class="number">33408</span> <span class="number">6</span>月  <span class="number">22</span> <span class="number">2012</span> /usr/bin/[</span><br></pre></td></tr></table></figure><p>正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0]</p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line">then</span><br><span class="line"><span class="keyword">command</span>1 </span><br><span class="line"><span class="keyword">command</span>2</span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="keyword">command</span>N </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>写成一行（适用于终端命令提示符）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> `ps -ef | grep ssh`;  <span class="keyword">then</span> <span class="built_in">echo</span> hello; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>末尾的fi就是if倒过来拼写，后面还会遇到类似的</p><h4 id="if-else-1"><a href="#if-else-1" class="headerlink" title="if else"></a>if else</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line">then</span><br><span class="line"><span class="keyword">command</span>1 </span><br><span class="line"><span class="keyword">command</span>2</span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="keyword">command</span>N</span><br><span class="line">else</span><br><span class="line"><span class="keyword">command</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">command1</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line">command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="for-while"><a href="#for-while" class="headerlink" title="for while"></a>for while</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>在开篇的示例里演示过了：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 <span class="string">...</span> itemN</span><br><span class="line">do</span><br><span class="line"><span class="keyword">command</span>1</span><br><span class="line"><span class="keyword">command</span>2</span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="keyword">command</span>N</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>写成一行：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> <span class="keyword">in</span> item1 item2 ... itemN; <span class="keyword">do</span> command1; command2… done;</span><br></pre></td></tr></table></figure><h4 id="C风格的for"><a href="#C风格的for" class="headerlink" title="C风格的for"></a>C风格的for</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for <span class="comment">(( EXP1; EXP2; EXP3 )</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">comma<span class="symbol">nd1</span></span><br><span class="line">comma<span class="symbol">nd2</span></span><br><span class="line">comma<span class="symbol">nd3</span></span><br><span class="line"><span class="keyword">do</span><span class="symbol">ne</span></span><br></pre></td></tr></table></figure><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (( <span class="comment">; ; ))</span></span><br></pre></td></tr></table></figure><h4 id="until"><a href="#until" class="headerlink" title="until"></a>until</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">until</span> condition</span><br><span class="line"><span class="built_in">do</span></span><br><span class="line"><span class="keyword">command</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">case <span class="string">"$&#123;opt&#125;"</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">"Install-Puppet-Server"</span> )</span><br><span class="line">install_master <span class="variable">$1</span></span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line"><span class="string">"Install-Puppet-Client"</span> )</span><br><span class="line">install_client <span class="variable">$1</span></span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line"><span class="string">"Config-Puppet-Server"</span> )</span><br><span class="line">config_puppet_master</span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line"><span class="string">"Config-Puppet-Client"</span> )</span><br><span class="line">config_puppet_client</span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line"><span class="string">"Exit"</span> )</span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">* ) echo <span class="string">"Bad option, please choose again"</span></span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break</p><p>学习自：<a href="https://github.com/qinjx/30min_guides/blob/master/shell.md#if-else" target="_blank" rel="noopener">Shell脚本编程30分钟入门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Shell&quot;&gt;&lt;a href=&quot;#Shell&quot; class=&quot;headerlink&quot; title=&quot;Shell&quot;&gt;&lt;/a&gt;Shell&lt;/h3&gt;&lt;h3 id=&quot;编写&quot;&gt;&lt;a href=&quot;#编写&quot; class=&quot;headerlink&quot; title=&quot;编写&quot;&gt;&lt;/a&gt;编
      
    
    </summary>
    
    
      <category term="Shell" scheme="https://nymrli.top/tags/Shell/"/>
    
      <category term="linux" scheme="https://nymrli.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>多媒体Au使用</title>
    <link href="https://nymrli.top/2018/11/08/%E5%A4%9A%E5%AA%92%E4%BD%93Au%E4%BD%BF%E7%94%A8/"/>
    <id>https://nymrli.top/2018/11/08/多媒体Au使用/</id>
    <published>2018-11-08T04:18:47.000Z</published>
    <updated>2018-11-08T04:19:20.150Z</updated>
    
    <content type="html"><![CDATA[<h4 id="AU使用。"><a href="#AU使用。" class="headerlink" title="AU使用。"></a>AU使用。</h4><blockquote><p>留人声、去伴奏</p></blockquote><h4 id="First"><a href="#First" class="headerlink" title="First."></a>First.</h4><p><img src="/2018/11/08/多媒体Au使用/立体声-中置声道提取.jpg" alt="立体声-中置声道提取"></p><p>▲侧边声道电平控制微弱，中置声道电平控制效果强。</p><p><img src="/2018/11/08/多媒体Au使用/立体声-中置声道提取2.jpg" alt="立体声-中置声道提取2"></p><p>▲交叉渗透，越大伴奏声音越不明显</p><h4 id="Second"><a href="#Second" class="headerlink" title="Second."></a>Second.</h4><p><img src="/2018/11/08/多媒体Au使用/图示均衡器.jpg" alt="图示均衡器"></p><p>前面几排调低到满意。（童声高音频率范围为260-880Hz,低音频率范围为196-700Hz,女声高音频率范围为220-1.1KHz,低音频率范围为200-700KHz,男声高音频率范围为160-523KHz低音频率范围为80-358Hz. 国际通信标准制定为300Hz-3400Hz! ）</p><hr><blockquote><p>留伴奏、去人声</p></blockquote><p>···选中所有，菜单栏-收藏夹-移除人声</p><p><img src="/2018/11/08/多媒体Au使用/移除人声.jpg" alt="移除人声"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;AU使用。&quot;&gt;&lt;a href=&quot;#AU使用。&quot; class=&quot;headerlink&quot; title=&quot;AU使用。&quot;&gt;&lt;/a&gt;AU使用。&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;留人声、去伴奏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;First&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Au" scheme="https://nymrli.top/tags/Au/"/>
    
  </entry>
  
  <entry>
    <title>定时执行Python脚本</title>
    <link href="https://nymrli.top/2018/11/07/%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8CPython%E8%84%9A%E6%9C%AC/"/>
    <id>https://nymrli.top/2018/11/07/定时执行Python脚本/</id>
    <published>2018-11-07T09:51:16.000Z</published>
    <updated>2018-11-07T10:01:53.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定时任务执行python脚本"><a href="#定时任务执行python脚本" class="headerlink" title="定时任务执行python脚本"></a>定时任务执行python脚本</h2><h3 id="使用linux的crontab"><a href="#使用linux的crontab" class="headerlink" title="使用linux的crontab"></a>使用linux的crontab</h3><h5 id="1-开启crontab日志。"><a href="#1-开启crontab日志。" class="headerlink" title="1.开启crontab日志。"></a>1.开启crontab日志。</h5><p>crontab默认不开启日志，所以先开启定时任务的日志来查看</p><blockquote><p>修改rsyslog服务，将<code>/etc/rsyslog.d/50-default.conf</code> 文件中的<code>#cron.*</code>前的 <code>#</code>删掉；用<code>service rsyslog restart</code>重启rsyslog服务：</p></blockquote><h5 id="2-写定时任务"><a href="#2-写定时任务" class="headerlink" title="2.写定时任务"></a>2.写定时任务</h5><p>开启本用户的定时任务,即创建以本用户名为文件名的定时任务文件，位置在<code>/var/spool/cron/crontabs/</code>。<code>crontab -e</code></p><p>定时任务语句格式为：<strong>执行周期+命令</strong>，周期有5个域，分别是</p><ul><li>M: 分（0-59） </li><li>H：时（0-23） </li><li>D：天（1-31）</li><li>m: 月（1-12） </li><li>d: 周（0-6）   //0为星期日</li></ul><p>▲每个域不加限制任意的话用*</p><p>所以命令语句就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*/5 * * * * <span class="built_in">cd</span> /home/iris/; python aa.py</span><br><span class="line"><span class="comment">#时间#      #command ; commond</span></span><br></pre></td></tr></table></figure><p>写完后需要重启cron服务:<code>service  cron restart</code></p><h5 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h5><hr><p>常用周期格式:</p><blockquote><ul><li>每五分钟执行  <em>/5 </em> <em> </em> *</li><li>每小时执行       0   <em> </em> <em> </em></li><li>每天执行           0   0 <em> </em> *</li><li>每周执行           0   0 <em> </em> 0</li><li>每月执行           0   0 1 <em> </em></li><li>每年执行          0   0 1 1 *</li></ul></blockquote><blockquote><p>5        <em>       </em>           <em>     </em>     ls         指定每小时的第5分钟执行一次ls命令<br>30      5       <em>           </em>     <em>     ls         指定每天的 5:30 执行ls命令<br>30      7       8           </em>     <em>     ls         指定每月8号的7：30分执行ls命令<br>30      5       8           6     </em>     ls         指定每年的6月8日5：30执行ls命令<br>30      5       8           6     <em>     ls         指定每年的6月8日5：30执行ls命令<br>30      6       </em>           <em>     0     ls         指定每星期日的6:30执行ls命令<br>30      3     10,20     </em>     <em>     ls         每月10号及20号的3：30执行ls命令<br>25     8-11  </em>           <em>     </em>     ls         每天8-11点的第25分钟执行ls命令<br><em>/15   </em>      <em>           </em>     <em>     ls         每15分钟执行一次ls命令<br>30      6     </em>/10       <em>     </em>     ls         每个月中，每隔10天6:30执行一次ls命令<br>22      4       <em>           </em>     *     root     run-parts     /etc/cron.daily  每天4：22以root身份执行/etc/cron.daily目录中的所有可执行文件，run-parts参数表示，执行后面目录中的所有可执行文件。</p></blockquote><h5 id="Python-project-SeverChan-Nyedu"><a href="#Python-project-SeverChan-Nyedu" class="headerlink" title="~/Python_project/SeverChan_Nyedu"></a>~/Python_project/SeverChan_Nyedu</h5><h3 id="使用python-crontab设置linux定时任务"><a href="#使用python-crontab设置linux定时任务" class="headerlink" title="使用python crontab设置linux定时任务"></a>使用python crontab设置linux定时任务</h3><blockquote><p>通过python 来写 crontab配置</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> crontab <span class="keyword">import</span> CronTab</span><br><span class="line"><span class="comment"># 创建当前用户的crontab，当然也可以创建其他用户的，但得有足够权限</span></span><br><span class="line">my_user_cron = CronTab(user=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 创建任务</span></span><br><span class="line">job = my_user_cron.new(command=<span class="string">'echo date &gt;&gt; ~/time.log'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置任务执行周期，每两分钟执行一次</span></span><br><span class="line">job.setall(<span class="string">'*/2 * * * *'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然还支持其他更人性化的设置方式，简单列举一些</span></span><br><span class="line">job.minute.during(<span class="number">5</span>,<span class="number">50</span>).every(<span class="number">5</span>)</span><br><span class="line">job.hour.every(<span class="number">4</span>)</span><br><span class="line">job.day.on(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">job.dow.on(<span class="string">'SUN'</span>)</span><br><span class="line">job.dow.on(<span class="string">'SUN'</span>, <span class="string">'FRI'</span>)</span><br><span class="line">job.month.during(<span class="string">'APR'</span>, <span class="string">'NOV'</span>)</span><br><span class="line">job.setall(time(<span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">job.setall(date(<span class="number">2000</span>, <span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line">job.setall(datetime(<span class="number">2000</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时可以给任务设置comment，这样就可以根据comment查询，很方便</span></span><br><span class="line">job.set_comment(<span class="string">"time log job"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据comment查询，当时返回值是一个生成器对象，不能直接根据返回值判断任务是否#存在，如果只是判断任务是否存在，可直接遍历my_user_cron.crons</span></span><br><span class="line">iter = my_user_cron.find_comment(<span class="string">'time log job'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时还支持根据command和执行周期查找，基本类似，不再列举</span></span><br><span class="line"><span class="comment"># 任务的disable和enable， 默认enable</span></span><br><span class="line">job.enable(<span class="keyword">False</span>)</span><br><span class="line">job.enable()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后将crontab写入配置文件</span></span><br><span class="line">my_user_cron.write()</span><br></pre></td></tr></table></figure><h3 id="python中的轻量级定时任务调度库：schedule"><a href="#python中的轻量级定时任务调度库：schedule" class="headerlink" title="python中的轻量级定时任务调度库：schedule"></a>python中的轻量级定时任务调度库：schedule</h3><p>提供博客<a href="https://www.cnblogs.com/anpengapple/p/8051923.html" target="_blank" rel="noopener">python中的轻量级定时任务调度库：schedule</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定时任务执行python脚本&quot;&gt;&lt;a href=&quot;#定时任务执行python脚本&quot; class=&quot;headerlink&quot; title=&quot;定时任务执行python脚本&quot;&gt;&lt;/a&gt;定时任务执行python脚本&lt;/h2&gt;&lt;h3 id=&quot;使用linux的crontab&quot;&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="linux" scheme="https://nymrli.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>ServerChan+南邮教务处</title>
    <link href="https://nymrli.top/2018/11/07/ServerChan-%E5%8D%97%E9%82%AE%E6%95%99%E5%8A%A1%E5%A4%84/"/>
    <id>https://nymrli.top/2018/11/07/ServerChan-南邮教务处/</id>
    <published>2018-11-07T09:32:10.000Z</published>
    <updated>2018-11-07T09:35:10.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SeverChan-Nyedu"><a href="#SeverChan-Nyedu" class="headerlink" title="SeverChan_Nyedu"></a>SeverChan_Nyedu</h1><p>Crawl the infomation about competitons, when new infos comes, remind people on Wechat by ServerChan:</p><p>😍该程序通过爬取<a href="http://jwc.njupt.edu.cn/1594/list.htm" target="_blank" rel="noopener">南邮教务处</a>,将当前时间与最新时间进行匹配,如果是当日则通过ServerChan发送到本人的微信,提醒有新的竞赛.</p><h4 id="完成笔记"><a href="#完成笔记" class="headerlink" title="完成笔记:"></a>完成笔记:</h4><h5 id="1-关于lxml中etree-xpath-对于tbody的处理"><a href="#1-关于lxml中etree-xpath-对于tbody的处理" class="headerlink" title="1.关于lxml中etree.xpath()对于tbody的处理"></a>1.关于<code>lxml</code>中<code>etree.xpath()</code>对于<code>tbody</code>的处理</h5><blockquote><p>该网页通过<code>table</code>对页面进行分布设置,其中<code>table</code>标签会自动生成<code>tbody</code>标签,如图..此时用<code>xpath</code>进行匹配的时候就不需要将<code>tbody</code>加上,否则匹配不到</p></blockquote><p>布局<code>&lt;Table&gt;</code></p><p><img src="https://github.com/Freedomisgood/SeverChan_Nyedu/Nonetbody.jpg" alt="Nonetbody"></p><p>表格<code>&lt;table&gt;</code></p><p><img src="https://github.com/Freedomisgood/SeverChan_Nyedu/Table_tbody.jpg" alt="Table_tbody"></p><p>可以看到的是在Chrome调试助手里面,<code>&lt;table&gt;</code>下面都是会自动生成<code>&lt;tbody&gt;</code>标签的<u>(一般<code>tbody</code>是浏览器自动产生的，一般情况要去掉)</u>,而我们再通过<strong>网页源码</strong>看看..==&gt;可以发现的是:</p><p><strong><code>&lt;table&gt;</code>布局是没有<code>&lt;tbody&gt;</code>的,只有表格才有</strong>,所以这也是为什么用xpath()表格里必须加上<code>tbody</code>才能匹配,而<code>table</code>布局中不能加<code>tbody</code>的原因</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#布局获得内容</span></span><br><span class="line"><span class="keyword">for</span> content <span class="keyword">in</span> contentList:</span><br><span class="line">    title = content.xpath(<span class="string">'td/table/tr/td[1]/a/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">    href = content.xpath(<span class="string">'td/table/tr/td[1]/a/@href'</span>)[<span class="number">0</span>]</span><br><span class="line">    submittime = content.xpath(<span class="string">'td/table/tr/td[2]/div/text()'</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#表格</span></span><br><span class="line"><span class="keyword">if</span> content.tag == <span class="string">'table'</span>:</span><br><span class="line">    tabletitle = content.xpath(<span class="string">'tbody/tr[1]/td'</span>)  <span class="comment"># 表格头</span></span><br><span class="line">    tabletitleList = map(<span class="keyword">lambda</span> x: x.xpath(<span class="string">'string(.)'</span>), tabletitle)</span><br><span class="line">    tablehead = <span class="string">'|'</span> + <span class="string">'|'</span>.join(tabletitleList) + <span class="string">'|'</span> </span><br><span class="line">    tableover = <span class="string">'|'</span> + <span class="string">':---:|'</span> * len(tabletitle)  <span class="comment"># 居中显示</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/Freedomisgood/SeverChan_Nyedu/real_code.jpg" alt="real_code"></p><h5 id="2-requests-get-获得的response的编码问题"><a href="#2-requests-get-获得的response的编码问题" class="headerlink" title="2.requests.get()获得的response的编码问题"></a>2.<code>requests.get()</code>获得的response的编码问题</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html = requests.get(<span class="string">'http://jwc.njupt.edu.cn/1594/list.htm'</span>,headers = headers)</span><br><span class="line">html.encoding = <span class="string">'utf-8'</span></span><br><span class="line"><span class="comment">#Requests库的自身编码为: r.encoding = ‘ISO-8859-1’</span></span><br></pre></td></tr></table></figure><p>Github地址:<a href="https://github.com/Freedomisgood/SeverChan_Nyedu" target="_blank" rel="noopener">Freedomisgood/<strong>SeverChan_Nyedu</strong></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SeverChan-Nyedu&quot;&gt;&lt;a href=&quot;#SeverChan-Nyedu&quot; class=&quot;headerlink&quot; title=&quot;SeverChan_Nyedu&quot;&gt;&lt;/a&gt;SeverChan_Nyedu&lt;/h1&gt;&lt;p&gt;Crawl the infomati
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>高科GSWIFI江苏破解教程</title>
    <link href="https://nymrli.top/2018/11/04/%E9%AB%98%E7%A7%91GSWIFI%E6%B1%9F%E8%8B%8F%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/"/>
    <id>https://nymrli.top/2018/11/04/高科GSWIFI江苏破解教程/</id>
    <published>2018-11-04T02:06:34.000Z</published>
    <updated>2018-11-04T04:01:07.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-重置路由器设置"><a href="#1-重置路由器设置" class="headerlink" title="1.重置路由器设置"></a>1.重置路由器设置</h4><blockquote><p>为了以防之前其他人已经设置过某些东西,可能会影响到之后的使用，所以干脆直接重置。</p></blockquote><h4 id="2-连接路由器电源-不用插任何的wan口或者lan口"><a href="#2-连接路由器电源-不用插任何的wan口或者lan口" class="headerlink" title="2.连接路由器电源,不用插任何的wan口或者lan口"></a>2.连接路由器电源,不用插任何的wan口或者lan口</h4><blockquote><p>P.S.如果第二步,手机和电脑无法直接通过IP地址进入管理界面的话,可以考虑将 网线一头插入2号口,一头插入电脑的插口 , 然后再通过IP地址进入管理界面</p></blockquote><h4 id="3-登录路由器管理界面"><a href="#3-登录路由器管理界面" class="headerlink" title="3.登录路由器管理界面"></a>3.登录路由器管理界面</h4><p>▲注意： 大多数路由器的管理界面IP地址为 <code>192.168.1.1</code>或者<code>192.168.100.1</code>,虽然高科路由器后面贴纸上说明的IP地址是<code>192.168.8.1</code>,但是那个不是初始的IP,需要自己设置到<code>192.168.8.1</code>.</p><p>如下是我已经修改好的IP为<code>192.168.8.1</code>的登录界面,默认密码为<code>admin</code>,登录后选择<strong>不保存密码</strong></p><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/1.jpg" alt="1"></p><h4 id="4-进入管理界面后先观察"><a href="#4-进入管理界面后先观察" class="headerlink" title="4.进入管理界面后先观察"></a>4.进入管理界面后先观察</h4><ul><li><p>首先是要观察软件版本与 GSWIFI 公众号中的最新能用的版本进行匹配,如果是一样的话就不需要升级<em>系统固件</em>,如果当前软件版本比较低就可能无法使用.</p></li><li><p>其次,由于没接网线,所以<strong>网线状态</strong>是<u>WAN口未连接</u></p></li></ul><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/2.jpg" alt="IMG_20181103_194258"></p><h4 id="5-修改配置"><a href="#5-修改配置" class="headerlink" title="5.修改配置"></a>5.修改配置</h4><h5 id="修改WAN口设置"><a href="#修改WAN口设置" class="headerlink" title="修改WAN口设置"></a>修改WAN口设置</h5><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/3.jpg" alt="3"></p><h5 id="如何查看手机MAC地址说明"><a href="#如何查看手机MAC地址说明" class="headerlink" title="如何查看手机MAC地址说明:"></a>如何查看手机MAC地址说明:</h5><p>由于我使用的是英文系统…可能手机界面有点不同</p><p>1<strong>.进入WLAN</strong></p><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/5.png" alt="5"></p><p>2.<strong>进入更多设置</strong></p><blockquote><p>最下面的<code>MAC address</code>就是</p></blockquote><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/4.png" alt="4"></p><h4 id="6-WIFI设置2-4G"><a href="#6-WIFI设置2-4G" class="headerlink" title="6.WIFI设置2.4G"></a>6.WIFI设置2.4G</h4><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/6.jpg" alt="6"></p><h4 id="7-LAN口设置"><a href="#7-LAN口设置" class="headerlink" title="7.LAN口设置"></a>7.LAN口设置</h4><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/7.jpg" alt="7"></p><p>该步之后,等30s配置完成后,你会无法进入<code>192.168.1.1</code>,页面也会无响应,此时访问<code>192.168.8.1</code>重进管理界面</p><h4 id="8-开始连接网线-查看网线状态"><a href="#8-开始连接网线-查看网线状态" class="headerlink" title="8.开始连接网线(查看网线状态)"></a>8.开始连接网线(查看网线状态)</h4><p>▲▲.由于该路由器的WAN口被商家调到了<code>3号LAN口</code>,我也被这步坑了挺久..所以上述步骤都完成以后,将网线插入路由器的<code>3号LAN口</code>,再登录管理界面,此时应该就能看到这样的界面了</p><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/8.jpg" alt="8"></p><p>能够正常显示这几个,则路由器已设置完成.</p><h4 id="9-使用GSWIFI小助手对路由器再次设置"><a href="#9-使用GSWIFI小助手对路由器再次设置" class="headerlink" title="9.使用GSWIFI小助手对路由器再次设置"></a>9.使用GSWIFI小助手对路由器再次设置</h4><blockquote><p>▲注意,使用客服提供的APP,网盘链接在附录中</p></blockquote><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/9.jpg" alt="9"></p><p><strong>按照我们的教程来,IP地址填为<code>192.168.8.1</code></strong>,然后按下”<strong>开始联网</strong>“,之后会有4步,这个过程中WIFI会不断的掉线,需要自己不断重连自己的WIFI(“<strong>Hello</strong>“),等到4步完成后就可以开始用<strong>掌上大学</strong>连上WIFI后<strong>一键上网</strong>了</p><h5 id="完成图如下"><a href="#完成图如下" class="headerlink" title="完成图如下"></a>完成图如下</h5><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/10.png" alt="10"></p><h4 id="10-使用掌上大学一键上网"><a href="#10-使用掌上大学一键上网" class="headerlink" title="10.使用掌上大学一键上网"></a>10.使用掌上大学<strong>一键上网</strong></h4><hr><p>教程到此就结束了,按照上述步骤应该就能完成高科GSWIFI路由器的破解上网了…</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h4><h5 id="GSWIFI小助手江苏版"><a href="#GSWIFI小助手江苏版" class="headerlink" title="GSWIFI小助手江苏版:"></a>GSWIFI小助手江苏版:</h5><p>网盘:<a href="https://pan.baidu.com/share/init?surl=vwza9BJd9kjjMKH6f3ek3g" target="_blank" rel="noopener">https://pan.baidu.com/share/init?surl=vwza9BJd9kjjMKH6f3ek3g</a> 提取码:svdg</p><h5 id="更新系统固件"><a href="#更新系统固件" class="headerlink" title="更新系统固件"></a>更新系统固件</h5><p>找到GSWIFI公众号:  选择<code>系统升级</code> 然后查看<code>升级教程</code> 和 <code>1082正式版系统</code>(目前最新的系统固件)，然后根据里面提供的网盘将文件下载下来</p><blockquote><p>下载后===&gt;解压===&gt;进入管理界面===&gt;系统升级===&gt;选择文件===&gt;刷写固件===&gt;执行（其中过程千万不能关闭电源或是乱动，就算按错了，等2-3分钟好了以后再重新刷写也无妨，但是千万不能断电源）</p></blockquote><p><img src="/2018/11/04/高科GSWIFI江苏破解教程/11.jpg" alt="11"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-重置路由器设置&quot;&gt;&lt;a href=&quot;#1-重置路由器设置&quot; class=&quot;headerlink&quot; title=&quot;1.重置路由器设置&quot;&gt;&lt;/a&gt;1.重置路由器设置&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;为了以防之前其他人已经设置过某些东西,可能会影响到之后的使
      
    
    </summary>
    
    
      <category term="生活福利" scheme="https://nymrli.top/tags/%E7%94%9F%E6%B4%BB%E7%A6%8F%E5%88%A9/"/>
    
  </entry>
  
  <entry>
    <title>WSGI uWSGI uwsgi及nginx说明</title>
    <link href="https://nymrli.top/2018/11/02/WSGI-uWSGI-uwsgi%E5%8F%8Anginx%E8%AF%B4%E6%98%8E/"/>
    <id>https://nymrli.top/2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/</id>
    <published>2018-11-02T07:50:12.000Z</published>
    <updated>2018-11-02T08:16:15.520Z</updated>
    
    <content type="html"><![CDATA[<h4 id="客户端发出请求-gt-服务器接受、处理请求与响应-的过程示意图"><a href="#客户端发出请求-gt-服务器接受、处理请求与响应-的过程示意图" class="headerlink" title="客户端发出请求==&gt;服务器接受、处理请求与响应 的过程示意图"></a>客户端发出请求==&gt;服务器接受、处理请求与响应 的过程示意图</h4><p><img src="/2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/过程.png" alt="过程"></p><h4 id="1-WSGI："><a href="#1-WSGI：" class="headerlink" title="1. WSGI："></a>1. <strong>WSGI：</strong></h4><blockquote><p>全称是<code>Web Server Gateway Interface(服务器网关接口)</code>。<code>WSGI</code>不是服务器，<code>python</code>模块，框架，<code>API</code>或者任何软件，只是一种规范( 是一个<strong>Web服务器（如nginx）</strong>与<strong>应用服务器（如uWSGI）</strong>通信的一种规范（协议）==&gt; 可以理解为服务器与应用程序通信的接口规范要求)，描述<code>web server</code>如何与<code>web application</code>通信的规范。<code>server</code>和<code>application</code>的规范在<a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP 3333</a>中有具体描述。因为WSGI没有官方的实现, 所以WSGI更像一个协议，只要遵照这些协议，都可以在任何服务器(Server)上运行</p></blockquote><h4 id="2-uwsgi："><a href="#2-uwsgi：" class="headerlink" title="2.uwsgi："></a>2.<strong>uwsgi：</strong></h4><blockquote><p>与<code>WSGI</code>一样是一种通信协议，是<code>uWSGI</code>服务器的独占协议，用于定义传输信息的类型(<code>type of information</code>)，每一个<code>uwsgi packet</code>前<code>4byte</code>为传输信息类型的描述，与WSGI协议是两种不同的协议。该协议据说性能非常高，是<code>fcgi</code>协议的10倍快;而且内存占用率低，为<code>mod_wsgi</code>的一半左右，同时它还支持多应用的管理及应用的性能监控</p></blockquote><h4 id="3-uWSGI："><a href="#3-uWSGI：" class="headerlink" title="3.uWSGI："></a>3.<strong>uWSGI：</strong></h4><blockquote><p>是一个<code>web</code>服务器，而且也可以当做中间件。它实现了<code>WSGI</code>协议、<code>uwsgi</code>协议、<code>http</code>协议等。在生产环境中使用uWSGI作为python web的服务器,可以用来托管 Python WSGI应用。它具有应用服务器，代理，进程管理及应用监控等功能(但可以把看作是一个应用程序，帮助我们实现WSGI协议)，这样我们可以不再关注网络通信的底层实现，将精力更多放在处理HTTP请求数据，返回HTML。</p></blockquote><h4 id="4-uWSGI-nginx"><a href="#4-uWSGI-nginx" class="headerlink" title="4.uWSGI+nginx"></a>4.uWSGI+nginx</h4><blockquote><p>综上所述可以看出uWSGI可以直接当做服务器，而为了<strong>进一步的并发提升</strong>就需要加上nginx(<strong>提高负载均衡</strong>) </p><p>▲.当uWSGI+nginx使用时，nginx作为web服务器，而uWSGI作为中间件(这边不一定正确,个人理解)</p></blockquote><h5 id="uWSGI不足的地方"><a href="#uWSGI不足的地方" class="headerlink" title="uWSGI不足的地方:"></a>uWSGI不足的地方:</h5><ul><li><p>uWIGS也可以返回静态文件(css,js,img…)，但是很笨拙，所以更好的做法是用反向代理服务器（比如Nginx）来处理此类请求，减轻应用服务器的负载，获得更好的性能。</p><ul><li>利用uWIGS可以是我们的web应用得到更强的并发能力，uWIGS也可以返回静态文件(css,js,img…)，但是很笨拙，一般静态文件都交由Nginx进行传输，所以配置中一般不配置static-map,如果直接由uWIGS接受HTTP请求则需要设置http:xxxx，如果只需要与反向代理服务器进行交互则只需要接受socket，uWIGS与Nginx交互相当于两个进程间交互，一般使用的是.sock文件或者指定端口接受socket。指定端口时再使用浏览器访问相应端口，uWIGS会提示skip，跳过该HTTP请求。</li></ul></li><li><p>同时还有的是uWSGI本身的负载均衡没有nginx牛逼。所以阉割掉不用。</p></li></ul><h4 id="5-Nginx是一个Http和反向代理服务器"><a href="#5-Nginx是一个Http和反向代理服务器" class="headerlink" title="5.Nginx是一个Http和反向代理服务器"></a>5.Nginx是一个Http和反向代理服务器</h4><blockquote><p>什么是反向代理服务器呢？</p></blockquote><p>▲正向的就是由浏览器主动的想代理服务器发出请求，经代理服务器做出处理后再转给目标服务器<br>▲反向的就是不管浏览器同不同意，请求都会经过代理服务器处理再发给目标服务器</p><p>这其中的区别就是必须经过Nginx反向代理服务器，这就有了使用Nginx的几个好处：</p><ul><li>安全：不管什么请求都要经过代理服务器，这样就避免了外部程序直接攻击web服务器</li><li><p>负载均衡：根据请求情况和服务器负载情况，将请求分配给不同的web服务器，保证服务器性能</p></li><li><p>提高web服务器的IO性能：这个我也没看懂，总结来说就是请求从客户端传到web服务器是需要时间的，传递多长时间就会让这个进程阻塞多长时间，而通过反向代理，就可以在反向代理这完整接受请求，然后再传给web服务器，从而保证服务器性能，而且有的一些简单的事情（比如静态文件）可以直接由反向代理处理，不经过web服务器</p></li></ul><p><img src="/2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/nginx.png" alt="nginx"></p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2018/11/02/WSGI-uWSGI-uwsgi及nginx说明/总结.jpg" alt="总结"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;客户端发出请求-gt-服务器接受、处理请求与响应-的过程示意图&quot;&gt;&lt;a href=&quot;#客户端发出请求-gt-服务器接受、处理请求与响应-的过程示意图&quot; class=&quot;headerlink&quot; title=&quot;客户端发出请求==&amp;gt;服务器接受、处理请求与响应 的过程
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
      <category term="后端" scheme="https://nymrli.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>apt-get update无法连接</title>
    <link href="https://nymrli.top/2018/11/02/apt-get-update%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5/"/>
    <id>https://nymrli.top/2018/11/02/apt-get-update无法连接/</id>
    <published>2018-11-02T05:21:45.000Z</published>
    <updated>2018-11-02T05:44:44.227Z</updated>
    
    <content type="html"><![CDATA[<h4 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h4><p>原因是在apt-get update时遇到了Unable to connect to 代理，（由于<code>apt-get update</code>一直显示无法连接<code>172.17.18.141</code>百度后发现这并不是个特殊的IP,而且也可以ping到百度）于是想到是否使用了代理。</p><p><img src="/2018/11/02/apt-get-update无法连接/hexo\source\_posts\apt-get-update无法连接\1.jpg" alt="1"></p><p><img src="/2018/11/02/apt-get-update无法连接/1.jpg" alt="1"></p><p><img src="/2018/11/02/apt-get-update无法连接/2.jpg" alt="2"></p><h3 id="apt代理的设置："><a href="#apt代理的设置：" class="headerlink" title="apt代理的设置："></a>apt代理的设置：</h3><h4 id="临时方法"><a href="#临时方法" class="headerlink" title="临时方法"></a>临时方法</h4><p><code>export http_proxy=http://10.3.0.1:80</code></p><h4 id="长久方法"><a href="#长久方法" class="headerlink" title="长久方法"></a>长久方法</h4><p>(1) 需要在/etc/apt/apt.conf中添加以下代码： (如果您希望apt-get(而不是其他应用程序)一直使用http代理,您可以使用这种方式。)</p><p><code>Acquire::http::proxy &quot;http://用户名:密码@地址:端口&quot;;</code></p><p><code>Acquire::ftp::proxy &quot;http://用户名:密码@地址:端口&quot;;</code></p><p><code>Acquire::https::proxy &quot;http://用户名:密码@地址:端口&quot;;</code></p><p>保存apt.conf文件。</p><p>(2)新建一个代理配置文件,在apt-get 时使用配置,15.10可用(针对需要下载的单个不同文件)</p><p>建立文件  <code>vim proxyfile</code></p><p><code>Acquire::http::proxy &quot;http://10.3.0.1:80&quot;;</code></p><p><code>Acquire::ftp::proxy &quot;http://10.3.0.1:80&quot;;</code></p><p><code>Acquire::https::proxy &quot;http://10.3.0.1:80&quot;;</code></p><p>使用时<code>sudo apt-get install  xxx -c proxyfile</code></p><p>(2)在主目录下的.bashrc文件中添加两行。(如果您希望apt-get和其他应用程序如wget等都使用http代理,您可以使用这种方式。 )</p><p>在您的.bashrc文件末尾添加如下内容<br><code>export http_proxy=http://用户名:密码@地址:端口/</code><br><code>export https_proxy=http://用户名:密码@地址:端口/</code></p><p><code>export ftp_proxy=http://用户名:密码@地址:端口/</code></p><hr><p>附上一篇ubuntu设置代理的文章:<a href="https://blog.csdn.net/qq3399013670/article/details/81300497" target="_blank" rel="noopener">ubuntu设置代理</a></p><h3 id="Ubuntu下让终端走SS代理的方法"><a href="#Ubuntu下让终端走SS代理的方法" class="headerlink" title="Ubuntu下让终端走SS代理的方法"></a>Ubuntu下让终端走SS代理的方法</h3><p>Ubuntu下让终端走SS代理需要第三方软件的帮助，即privoxy。<br>privoxy 是非快取式 (non-caching) 的网页代理伺服器，具有进阶的过滤能力，可强化隐私权，还可以修改网页资料、管理 HTTP cookies、去除广告等。</p><h5 id="安装-privoxy"><a href="#安装-privoxy" class="headerlink" title="安装 privoxy"></a>安装 privoxy</h5><p><code>sudo apt-get install privoxy</code></p><p>安装完成后在 /etc/privoxy 目录下可以找到配置文件 config。</p><h5 id="配置-privoxy"><a href="#配置-privoxy" class="headerlink" title="配置 privoxy"></a>配置 privoxy</h5><p>一般地，改配置前应该备份配置。</p><p><code>mv /etc/privoxy/config /etc/privoxy/config.back</code></p><p>然后打开 config 文件，找到<code>listen-address</code>那一行，修改值为 privoxy 监听的地址，一般使用默认。</p><p>然后再找到<code>forward-socks5</code>那一行，去掉注释，值为SS代理监听的地址。</p><p>让终端走SS代理,修改配置后，重启 privoxy。</p><p><code>sudo /etc/init.d/privoxy restart</code></p><p>然后在终端下添加 http 代理。</p><p><code>export http_proxy=”127.0.0.1:8118”</code></p><p><code>export https_proxy=”127.0.0.1:8118”</code></p><p>然后就可以愉快的用终端翻墙了。</p><p>原文：<a href="https://blog.csdn.net/tailgo/article/details/52075643" target="_blank" rel="noopener">https://blog.csdn.net/tailgo/article/details/52075643</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;出现的问题&quot;&gt;&lt;a href=&quot;#出现的问题&quot; class=&quot;headerlink&quot; title=&quot;出现的问题&quot;&gt;&lt;/a&gt;出现的问题&lt;/h4&gt;&lt;p&gt;原因是在apt-get update时遇到了Unable to connect to 代理，（由于&lt;code&gt;apt
      
    
    </summary>
    
    
      <category term="linux" scheme="https://nymrli.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Windows控制台Cmd乱码（及永久修改编码）解决方法</title>
    <link href="https://nymrli.top/2018/10/28/Windows-%E6%8E%A7%E5%88%B6%E5%8F%B0Cmd%E4%B9%B1%E7%A0%81%EF%BC%88%E5%8F%8A%E6%B0%B8%E4%B9%85%E4%BF%AE%E6%94%B9%E7%BC%96%E7%A0%81%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://nymrli.top/2018/10/28/Windows-控制台Cmd乱码（及永久修改编码）解决方法/</id>
    <published>2018-10-28T08:42:20.000Z</published>
    <updated>2018-10-28T08:47:00.882Z</updated>
    
    <content type="html"><![CDATA[<p>我本机的系统环境：`OS Name: Microsoft Windows 10 家庭中文版</p><h4 id="Windows-控制台Cmd乱码的解决办法-一次性"><a href="#Windows-控制台Cmd乱码的解决办法-一次性" class="headerlink" title="Windows 控制台Cmd乱码的解决办法(一次性)"></a>Windows 控制台Cmd乱码的解决办法(一次性)</h4><p>在cmd中输入 <code>CHCP 65001</code></p><blockquote><p> 注：CHCP是一个计算机指令，能够显示或设置活动代码页编号。</p><p>代码页  描述</p><ul><li><p>65001   UTF-8代码页</p></li><li><p>950 繁体中文</p></li><li><p>936 简体中文默认的GBK</p></li><li><p>437 MS-DOS 美国英语</p></li></ul></blockquote><p><strong>但是通过CHCP设置编码是治标不治本的,想永久的更改cmd编码值需要修改注册表</strong></p><h4 id="Windows-控制台Cmd乱码的解决办法-永久性"><a href="#Windows-控制台Cmd乱码的解决办法-永久性" class="headerlink" title="Windows 控制台Cmd乱码的解决办法(永久性)"></a>Windows 控制台Cmd乱码的解决办法(永久性)</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>1.在cmd中输入<code>regedit</code>进入注册表</p><p>2.找到<code>HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe</code></p><p>3.新建一个 DWORD（32位值）,命名为CodePage，值设为65001 </p><p>4.已有CodePage的话，修改它，改为十进制，65001</p><h5 id="方法二：-亲测有效"><a href="#方法二：-亲测有效" class="headerlink" title="方法二：(亲测有效)"></a>方法二：(亲测有效)</h5><p>1.新建一个cmd.reg注册表文件:</p><p>2.内容输入如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version <span class="number">5.00</span></span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe]</span><br><span class="line"><span class="string">"CodePage"</span>=<span class="string">dword:</span><span class="number">0000</span>fde9</span><br><span class="line"><span class="string">"FontFamily"</span>=<span class="string">dword:</span><span class="number">00000036</span></span><br><span class="line"><span class="string">"FontWeight"</span>=<span class="string">dword:</span><span class="number">00000190</span></span><br><span class="line"><span class="string">"FaceName"</span>=<span class="string">"Consolas"</span></span><br><span class="line"><span class="string">"ScreenBufferSize"</span>=<span class="string">dword:</span><span class="number">232900</span>d2</span><br><span class="line"><span class="string">"WindowSize"</span>=<span class="string">dword:</span><span class="number">002</span>b00d2</span><br></pre></td></tr></table></figure><p>3.双击运行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我本机的系统环境：`OS Name: Microsoft Windows 10 家庭中文版&lt;/p&gt;
&lt;h4 id=&quot;Windows-控制台Cmd乱码的解决办法-一次性&quot;&gt;&lt;a href=&quot;#Windows-控制台Cmd乱码的解决办法-一次性&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JS正则及常用方法函数总结</title>
    <link href="https://nymrli.top/2018/10/25/JS%E6%AD%A3%E5%88%99%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>https://nymrli.top/2018/10/25/JS正则及常用方法函数总结/</id>
    <published>2018-10-25T03:55:20.000Z</published>
    <updated>2018-10-25T04:30:29.832Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS正则及常用方法函数总结"><a href="#JS正则及常用方法函数总结" class="headerlink" title="JS正则及常用方法函数总结"></a><a href="https://www.cnblogs.com/myzhibie/p/4365142.html" target="_blank" rel="noopener">JS正则及常用方法函数总结</a></h3><blockquote><p>正则表达式作为一种匹配处理字符串的利器在很多语言中都得到了广泛实现和应用，web开发本质上是处理字符串（服务端接受请求处理后拼接字符串作为响应，这在早期的CGI编程中最明显，然后客户端解析字符串进行渲染和执行），所以说，JS作为一门常用于web开发的语言，必然要具备正则这种强大的特性，本文将对JS中的正则用法及常用函数进行一番总结。</p></blockquote><h4 id="1-正则对象及其属性"><a href="#1-正则对象及其属性" class="headerlink" title="1.正则对象及其属性"></a><strong>1.正则对象及其属性</strong></h4><p>首先正则对象是JS中内置的一个对象，好比Array以及Math一样，不需要第三方库的支持，通常我们采取两种方式来定义一个正则对象.</p><h5 id="1）构造函数方式"><a href="#1）构造函数方式" class="headerlink" title="1）构造函数方式"></a>1）构造函数方式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'abc'</span>,<span class="string">'gi'</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里，第一个参数是正则的内容，第二个参数是修饰符，</span></span><br><span class="line"><span class="comment">修饰符通常有三种，i,g,m，i表示的含义是忽略大小写进行匹配，g表示全局匹配即匹配到第一个之后不停止继续匹配，m表示多行匹配即遇到换行后不停止匹配继续直到被匹配字符串结束。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>/i (忽略大小写)</li><li>/g (全文查找出现的所有匹配字符,否则只匹配第一个出现的)</li><li>/m (多行查找)</li><li>/gi(全文查找、忽略大小写)</li><li>/ig(全文查找、忽略大小写)</li></ul></blockquote><h5 id="2）字面量方式"><a href="#2）字面量方式" class="headerlink" title="2）字面量方式"></a>2）字面量方式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  reg=<span class="regexp">/abc/gi</span>;</span><br><span class="line">consolo.dir(reg);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*▲.两个斜杠之间的是定义的正则内容*，最后一个斜杠之后的是修饰符，</span></span><br><span class="line"><span class="comment">这种方式比第一种简单高效，所以通常使用第二种方式来定义正则。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a><strong>2.属性</strong></h4><p>在控制台中打印一个正则对象如下：</p><p><img src="/2018/10/25/JS正则及常用方法函数总结/1.png" alt="1"></p><ul><li><p><code>global</code>属性，该属性为布尔类型，用来表示该正则是否是全局匹配，</p></li><li><p><code>ignoreCase</code>属性，布尔类型，用来指示是否忽略大小写，</p></li><li><p><code>lastIndex</code>为number类型，用来表示上次匹配成功的位置，</p></li><li><p><code>multiline</code>，布尔类型，用来表示是否是多行匹配，source，string类型，用来表示正则的内容。</p></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex" target="_blank" rel="noopener"><code>lastIndex</code></a> 属性表示的索引处为目标字符串匹配（并且不会尝试从后续索引匹配）,你不能直接更改这个属性，它是只读的。可以通过<code>^</code></li><li><code>unicode</code>标志开启了多种 Unicode 相关的特性。使用 “u” 标志，任何 Unicode 代码点的转义都会被解释。</li></ul><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a><strong>3.方法</strong></h4><p>通常对于一个正则对象来讲，我们能够使用的方法基本上有三个，即<code>regObj.test</code>,<code>regObj.exec</code>及<code>regObj.compile</code></p><h5 id="1）test方法"><a href="#1）test方法" class="headerlink" title="1）test方法"></a>1）test方法</h5><p>该方法用来测试某个字符串是否与正则匹配，匹配就返回true，否则返回false。该方法接受一个字符串作为参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> reg=<span class="regexp">/boy(s)?\s+and\s+girl(s)?/gi</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(reg.test(<span class="string">'boy    and   girl'</span>));</span><br><span class="line"><span class="comment">//==&gt;true</span></span><br></pre></td></tr></table></figure><h5 id="2-compile方法"><a href="#2-compile方法" class="headerlink" title="2)compile方法"></a>2)compile方法</h5><p>该方法的作用是能够对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，<u>适合于对一个正则对象(模式)多次调用的情况下</u>，如果对一个正则只使用一两次，那么该方法没有特别显著的效应。</p><p>接受的参数也是一个正则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/[abc]/gi</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(reg.test(<span class="string">'a'</span>)); <span class="comment">//==&gt;true</span></span><br><span class="line">    reg=<span class="regexp">/[cde]/gi</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(reg.test(<span class="string">'a'</span>)); <span class="comment">//==&gt;false</span></span><br><span class="line">    reg.compile(reg);</span><br><span class="line">    <span class="built_in">console</span>.log(reg.test(<span class="string">'a'</span>)); <span class="comment">//==&gt;false</span></span><br><span class="line"><span class="comment">//被编译的正则和没有编译的正则在测试结果上没有任何区别，只是多次调用的效率上会更高一些。</span></span><br></pre></td></tr></table></figure><h5 id="3）exec方法"><a href="#3）exec方法" class="headerlink" title="3）exec方法"></a>3）exec方法</h5><p>该方法属于一个比较复杂的方法，它接受一个字符串，返回的是一个数组，数组中第0个元素是匹配的子字符串，第二个元素是正则中的第一个子分组匹配的结果（如果有子分组，即正则中存在用圆括号括起来的分组），第三个是正则中第二个子分组匹配的结果（如果有第二个子分组）…以此类推，如果没有正则子分组，那么该数组长度仅仅为1，就是匹配到的那个子字符串。同时，返回的这个数组同时还是一个对象，它拥有两个属性，分别为index表示当前匹配到的子字符串所处的位置，input属性表示被匹配的原始字符串。最后，该方法中的正则对象如果不是全局匹配，即没有g修饰符，则每次调用只会从字符串开头处匹配第一个结果，且每次调用结果都是一样的。只有指定为全局匹配，才能够按照从左往右依次去匹配，每次调用匹配一个结果，正则对象的lastIndex属性前进到本次匹配的末尾位置，下回再调用的时候，会从lastIndex处开始匹配而不是从头匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/(\w)l(\w)/g</span>;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world hello 123 hello programmer hello test"</span>;</span><br><span class="line"><span class="keyword">var</span> arr=reg.exec(str);</span><br><span class="line">    <span class="keyword">while</span>(arr)&#123;</span><br><span class="line">        <span class="built_in">console</span>.dir(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"lastIndex:"</span>+reg.lastIndex);</span><br><span class="line">        arr=reg.exec(str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2018/10/25/JS正则及常用方法函数总结/2.png" alt="3"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非全局匹配代码：</span></span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/(\w)l(\w)/</span>;</span><br><span class="line">   <span class="keyword">var</span> str=<span class="string">"hello world hello 123 hello programmer hello test"</span>;</span><br><span class="line">   <span class="keyword">var</span> arr=reg.exec(str);</span><br><span class="line">   <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(arr)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.dir(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"lastIndex:"</span>+reg.lastIndex);</span><br><span class="line">        arr=reg.exec(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/JS正则及常用方法函数总结/3.png" alt="3"></p><p>这个时候每次调用的结果都一样，lastIndex根本没有发生变化。</p><p>以上就是正则对象及其方法，其实在使用的过程中，JS中的String类型的对象也拥有一些和正则相关的方法，如下：</p><h4 id="String类型的对象的正则方法"><a href="#String类型的对象的正则方法" class="headerlink" title="String类型的对象的正则方法"></a>String类型的对象的正则方法</h4><h5 id="1）search方法"><a href="#1）search方法" class="headerlink" title="1）search方法"></a><strong>1）search方法</strong></h5><p>该方法是string对象的一个方法，用来<strong>查找第一次匹配的子字符串的位置</strong>，如果找到就返回一个number类型的index值，否则返回-1,它返回的只是第一次匹配的位置。</p><p>它接受一个正则或者子字符串为参数，这里我们只讨论正则的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/o/g</span>));</span><br><span class="line"><span class="comment">//输出结果为4，可以看到尽管具有多个匹配结果而且也声明为全局匹配，但是还是返回的是第一个匹配到的子串的位置；</span></span><br></pre></td></tr></table></figure><h5 id="2）replace方法"><a href="#2）replace方法" class="headerlink" title="2）replace方法"></a><strong>2）replace方法</strong></h5><p>该方法用来<strong>将字符串中的某些子串替换为需要的内容</strong>，接受两个参数，第一个参数可以为正则或者子字符串，表示匹配需要被替换的内容，第二个参数为被替换的新的子字符串。如果声明为全局匹配则会替换所有结果，否则只替换第一个匹配到的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello world,hello test"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="regexp">/hello/g</span>,<span class="string">'hi'</span>));</span><br><span class="line"><span class="comment">//结果为hi world,hi test</span></span><br><span class="line"><span class="comment">//如果将上面代码中的g修饰符去掉，则返回的结果是hi world,hello test</span></span><br></pre></td></tr></table></figure><h5 id="3）split方法"><a href="#3）split方法" class="headerlink" title="3）split方法"></a><strong>3）split方法</strong></h5><p>该方法主要用来<strong>将一个字符串拆分成一个数组</strong>，它接受一个正则或者子字符（串）作为参数，返回一个数组，简单情况下，我们不需要使用正则，只有在字符串拆分规则不统一的情况下才需要使用正则，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"how|old*are    you"</span>;</span><br><span class="line"><span class="keyword">var</span> arr=str.split(<span class="regexp">/\||\*|\s+/</span>);</span><br><span class="line"><span class="comment">// 以|、*、多项空格为分隔符</span></span><br><span class="line"><span class="comment">// \s 匹配任何空白字符,包括空格、制表符、换页符等等</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><p>这里需要将str拆分为单词数组，由于每个单词之间存在不一样的分隔符，我们采取正则来匹配，结果如下：</p><p><img src="/2018/10/25/JS正则及常用方法函数总结/4.png" alt="4"></p><h5 id="4）match方法"><a href="#4）match方法" class="headerlink" title="4）match方法"></a><strong>4）match方法</strong></h5><p>该方法接受一个正则作为参数，用来匹配一个字符串，它的输出结果在不是全局匹配的情况下和exec方法的结果一致即一个数组并带有额外的属性，如果采用全局匹配，则不返回任何和其被匹配字符串相关的信息，只返回匹配的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非全局匹配代码：</span></span><br><span class="line"><span class="keyword">var</span> reg2=<span class="regexp">/(\w)s(\w)/</span>;</span><br><span class="line"><span class="keyword">var</span> str2=<span class="string">"ws1esr"</span>;</span><br><span class="line"><span class="keyword">var</span> result=str2.match(reg2);</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(result)&#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(result);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"lastIndex:"</span>+reg2.lastIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//非全局匹配下，结果和exec非全局匹配方法返回的完全一致，</span></span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/JS正则及常用方法函数总结/5.png" alt="5"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局匹配代码：</span></span><br><span class="line"><span class="keyword">var</span> reg3=<span class="regexp">/(\w)s(\w)/g</span>;</span><br><span class="line"><span class="keyword">var</span> str4=<span class="string">"ws1estqsa"</span>;</span><br><span class="line"><span class="built_in">console</span>.dir(str4.match(reg3));</span><br><span class="line"><span class="comment">//可以看到，在全局匹配下的时候，它不同于exec方法，它会一次性将所有匹配结果以数组形式返回，且这个数组没有其他属性用来指向被匹配字符串的信息，而exec方法在全局匹配下每次返回的依然是本次匹配的结果数组，且这个数组中只包含本次匹配信息，同时又拥有指向被匹配字符串的信息，即match方法在全局匹配下一次性返回了所有匹配结果，而exec在全局匹配下返回的依然是当次匹配结果。</span></span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/JS正则及常用方法函数总结/6.png" alt="6"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS正则及常用方法函数总结&quot;&gt;&lt;a href=&quot;#JS正则及常用方法函数总结&quot; class=&quot;headerlink&quot; title=&quot;JS正则及常用方法函数总结&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/myzhibie/p/436
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="前端" scheme="https://nymrli.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="小程序" scheme="https://nymrli.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="JavaScript" scheme="https://nymrli.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text3 Python虚拟环境（补充）——解决控制台中文乱码情况</title>
    <link href="https://nymrli.top/2018/10/24/Sublime-Text3-Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E6%83%85%E5%86%B5/"/>
    <id>https://nymrli.top/2018/10/24/Sublime-Text3-Python虚拟环境（补充）——解决控制台中文乱码情况/</id>
    <published>2018-10-24T10:52:35.000Z</published>
    <updated>2018-10-24T10:53:11.813Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://www.cnblogs.com/guiyuhua/p/8627091.html" target="_blank" rel="noopener">edwardgui的博客</a></p><blockquote><p>正常的用python编译控制台是不会出现乱码的，但是在使用虚拟环境的情况下中文总是乱码，一开始以为是windows控制台编码的问题。找了挺久后发现是python+virtualenv编译系统的问题，现在我就带领大家解决这个问题。</p></blockquote><h5 id="▲注：Windows环境下"><a href="#▲注：Windows环境下" class="headerlink" title="▲注：Windows环境下"></a>▲注：Windows环境下</h5><ul><li>首先看下是否已经安装了Virtualenv package插件，如果没有，则Ctrl+Shift+P，install Package,输入Virtualenv安装。</li><li>找到插件安装的地方：C:\Users{Username}\AppData\Roaming\Sublime Text 3\Installed Packages ==&gt;注意改变一下Username</li><li>解压Virtualenv.sublime-package文件，可以通过先添加后缀.zip变为Virtualenv.sublime-package.zip再解压</li></ul><p>包含文件如下：<br><img src="https://images2018.cnblogs.com/blog/1350574/201808/1350574-20180827155724022-2032122286.jpg" alt=""><br>修改Python + Virtualenv.sublime-build文件， 增加一行：<code>&quot;env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf8&quot;},</code><br>使其变成<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"env"</span>: &#123;<span class="attr">"PYTHONIOENCODING"</span>: <span class="string">"utf8"</span>&#125;,</span><br><span class="line"><span class="attr">"target"</span>: <span class="string">"virtualenv_exec"</span>,</span><br><span class="line"><span class="attr">"shell_cmd"</span>: <span class="string">"python -u \"$file\""</span>,</span><br><span class="line"><span class="attr">"file_regex"</span>: <span class="string">"^[ ]*File \"(...*?)\", line ([0-9]*)"</span>,</span><br><span class="line"><span class="attr">"selector"</span>: <span class="string">"source.python"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后保存，再把该文件打包为Virtualenv.sublime-package.zip再去掉后缀，就大功告成了。</p><hr><p>最后打开Sublime Text3使用Python + Virtualenv 编译，就能看到中文正常输出啦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：&lt;a href=&quot;https://www.cnblogs.com/guiyuhua/p/8627091.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;edwardgui的博客&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正常的用pyth
      
    
    </summary>
    
    
      <category term="Sublime Text" scheme="https://nymrli.top/tags/Sublime-Text/"/>
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——将Cookie保存到本地的多种方法介绍</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E5%B0%86Cookie%E4%BF%9D%E5%AD%98%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/</id>
    <published>2018-10-24T10:43:34.000Z</published>
    <updated>2018-10-24T10:45:29.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法一：urllib2"><a href="#方法一：urllib2" class="headerlink" title="方法一：urllib2"></a>方法一：urllib2</h3><blockquote><p>结合cookielib及urllib2，Python2时期比较常用的方法，年代比较久远了。个人觉得太麻烦，改用requests.</p><p><strong>▲需要注意的是cookielib在python3中已经改成了http.cookiejar</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#该方法本人未测试</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> cookielib</span><br><span class="line"></span><br><span class="line"><span class="comment">#将cookie保存在文件中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveCookie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#设置保存cookie的文件</span></span><br><span class="line">    filename = <span class="string">'cookie.txt'</span></span><br><span class="line">    <span class="comment">#声明一个MozillaCookieJar对象来保存cookie，之后写入文件</span></span><br><span class="line">    cookie = cookielib.MozillaCookieJar(filename)</span><br><span class="line">    <span class="comment">#创建cookie处理器</span></span><br><span class="line">    handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class="line">    <span class="comment">#构建opener</span></span><br><span class="line">    opener = urllib2.build_opener(handler)</span><br><span class="line">    <span class="comment">#创建请求</span></span><br><span class="line">    res = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">    <span class="comment">#保存cookie到文件</span></span><br><span class="line">    <span class="comment">#ignore_discard的意思是即使cookies将被丢弃也将它保存下来</span></span><br><span class="line">    <span class="comment">#ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入</span></span><br><span class="line">    cookie.save(ignore_discard=<span class="keyword">True</span>,ignore_expires=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#从文件中获取cookie并且访问(我们通过这个方法就可以打开保存在本地的cookie来模拟登录)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCookie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#创建一个MozillaCookieJar对象</span></span><br><span class="line">    cookie = cookielib.MozillaCookieJar()</span><br><span class="line">    <span class="comment">#从文件中的读取cookie内容到变量</span></span><br><span class="line">    cookie.load(<span class="string">'cookie.txt'</span>,ignore_discard=<span class="keyword">True</span>,ignore_expires=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment">#打印cookie内容,证明获取cookie成功</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'name:'</span> + item.name + <span class="string">'-value:'</span> + item.value</span><br><span class="line">    <span class="comment">#利用获取到的cookie创建一个opener</span></span><br><span class="line">    handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class="line">    opener = urllib2.build_opener(handler)</span><br><span class="line">    res = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">    <span class="keyword">print</span> res.read()</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h3><blockquote><p>使用requests.cookie</p></blockquote><h5 id="读取cookies"><a href="#读取cookies" class="headerlink" title="读取cookies"></a>读取cookies</h5><p>在这里我用的是LWPCookieJar保存在txt文件中，还有个是MozillaCookieJar，都是由FileCookieJar 派生而来，实现了save()方法，而FileCookieJar 没有实现save()</p><blockquote><ul><li>MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。</li><li>LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。</li></ul></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#实例化一个LWPCookieJar对象</span><br><span class="line">load_cookiejar = cookielib.LWPCookieJar()</span><br><span class="line">#从文件中加载cookies(LWP格式)</span><br><span class="line"></span><br><span class="line">load_cookiejar.load(<span class="string">'cookies.txt'</span>, ignore_discard=True, ignore_expires=True)</span><br><span class="line">#工具方法转换成字典</span><br><span class="line">load_cookies = requests<span class="selector-class">.utils</span><span class="selector-class">.dict_from_cookiejar</span>(load_cookiejar)</span><br><span class="line">#工具方法将字典转换成RequestsCookieJar，赋值给session的cookies.</span><br><span class="line">self<span class="selector-class">.session</span><span class="selector-class">.cookies</span> = requests<span class="selector-class">.utils</span><span class="selector-class">.cookiejar_from_dict</span>(load_cookies)</span><br></pre></td></tr></table></figure><h5 id="存储cookies"><a href="#存储cookies" class="headerlink" title="存储cookies"></a>存储cookies</h5><p>将cookies转换成LWP格式然后保存为文本格式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#实例化一个LWPcookiejar对象</span><br><span class="line">new_cookie_jar = cookielib.LWPCookieJar(<span class="string">'cookie.txt'</span>)</span><br><span class="line"></span><br><span class="line">#将转换成字典格式的RequestsCookieJar（这里我用字典推导手动转的）保存到LWPcookiejar中</span><br><span class="line">===&gt;RequestsCookieJar没有实现save()方法</span><br><span class="line">requests<span class="selector-class">.utils</span><span class="selector-class">.cookiejar_from_dict</span>(&#123;c<span class="selector-class">.name</span>: c<span class="selector-class">.value</span> <span class="keyword">for</span> c <span class="keyword">in</span> self<span class="selector-class">.session</span><span class="selector-class">.cookies</span>&#125;, new_cookie_jar)</span><br><span class="line"></span><br><span class="line">#保存到本地文件</span><br><span class="line">new_cookie_jar.save(<span class="string">'cookies.txt'</span>, ignore_discard=True, ignore_expires=True)</span><br></pre></td></tr></table></figure><p><img src="/2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/Users\10630\Desktop\Txt\爬虫知识点\cookie3.jpg" alt="cookie3"></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h3><blockquote><p>将cookie字典弄成字典形式然后pickle或者json写入文件中</p></blockquote><h5 id="存储cookie"><a href="#存储cookie" class="headerlink" title="存储cookie"></a>存储cookie</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,json,pprint</span><br><span class="line">s = requests.session()</span><br><span class="line">s.headers = <span class="meta">&#123;...&#125;</span></span><br><span class="line">a = s.get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">cookies = requests.utils.dict_from_cookiejar(s.cookies)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">".\\cook.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    json.dump(cookies, fp)</span><br><span class="line">pprint.pprint(cookies,width=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h5 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(<span class="string">".\cook.txt"</span>, <span class="string">"w"</span>) as fp:</span><br><span class="line">    load_cookies=son.load(fp)</span><br><span class="line">session<span class="selector-class">.cookie</span> = requests<span class="selector-class">.utils</span><span class="selector-class">.cookiejar_from_dict</span>(load_cookies)</span><br></pre></td></tr></table></figure><p>方法四:</p><blockquote><p>将requests.cookie设置为LWPCookieJar、或MozillaCookieJar保存</p></blockquote><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session</span> = requests.Session()</span><br><span class="line"><span class="comment">#创建个 LWPCookieJar对象</span></span><br><span class="line">session.<span class="attr">cookies</span> = LWPCookieJar(<span class="attr">filename='cook.txt')</span></span><br><span class="line">s.get('https://www.baidu.com/',<span class="attr">headers=headers)</span></span><br><span class="line">session.cookies.save(<span class="attr">ignore_discard=True,</span> <span class="attr">ignore_expires=True)</span></span><br><span class="line"><span class="comment">#如果save()时没有写filename参数，则默认为实例化LWPCookieJar时给的文件名</span></span><br></pre></td></tr></table></figure><p><img src="/2018/10/24/Python爬虫知识点——将Cookie保存到本地的多种方法介绍/Users\10630\Desktop\Txt\爬虫知识点\cookie4.jpg" alt="cookie4"></p><hr><h4 id="save-方法的两个重要参数"><a href="#save-方法的两个重要参数" class="headerlink" title="save()方法的两个重要参数"></a>save()方法的两个重要参数</h4><blockquote><ul><li>ignore_discard: save even cookies set to be discarded.</li><li>ignore_expires: save even cookies that have expired.The file is overwritten if it already exists</li></ul></blockquote><p><code>ignore_discard的意思是即使cookies将被丢弃也将它保存下来，ignore_expires的意思是如果cookies已经过期也将它保存并且文件已存在时将覆盖</code></p><p>总结方法二和方法三可以看出，就是要将cookie转换成然后save()</p><hr><p>简单介绍下<strong>cookielib模块</strong>作用，科普下实现cookie知识</p><blockquote><p>python3中将cookielib模块改为了http.cookiejar</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">   cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。例如可以利用本模块 的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送。coiokielib模块用到的对象主要有下面几个：CookieJar、 FileCookieJar、MozillaCookieJar、LWPCookieJar。其中他们的关系如下：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                     CookieJar                       </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                         | </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">      FileCookieJar      </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">          /                   \    </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p> MozillaCookieJar          LWPCookieJar            </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;方法一：urllib2&quot;&gt;&lt;a href=&quot;#方法一：urllib2&quot; class=&quot;headerlink&quot; title=&quot;方法一：urllib2&quot;&gt;&lt;/a&gt;方法一：urllib2&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;结合cookielib及urllib2，P
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——Session与Cookie</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94Session%E4%B8%8ECookie/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——Session与Cookie/</id>
    <published>2018-10-24T10:36:56.000Z</published>
    <updated>2018-10-24T10:41:34.630Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Session和Cookie："><a href="#Session和Cookie：" class="headerlink" title="Session和Cookie："></a>Session和Cookie：</h4><blockquote><p>Cookie：保持登录后的认证状态而保存在本地的数据</p><p>session:用cookie来标记用户，cookie携带了会话ID消息，通过检查cookie就能找到会话(session)</p></blockquote><p>cookie与session相互配合，一个处于客户端，一个处于服务端，两者相互协作。</p><h5 id="会话cookie和持久cookie"><a href="#会话cookie和持久cookie" class="headerlink" title="会话cookie和持久cookie"></a>会话cookie和持久cookie</h5><blockquote><p>会话Cookie：把cookie放在浏览器内存里，浏览器关闭后失效。</p><p>持久Cookie：保存cookie到客户端的硬盘中，下次继续使用。</p></blockquote><p>由Cookie的Max Age和Expires决定了过期的时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Session和Cookie：&quot;&gt;&lt;a href=&quot;#Session和Cookie：&quot; class=&quot;headerlink&quot; title=&quot;Session和Cookie：&quot;&gt;&lt;/a&gt;Session和Cookie：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Cooki
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——代理</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——代理/</id>
    <published>2018-10-24T10:36:28.000Z</published>
    <updated>2018-10-24T10:41:27.406Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h6 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h6><p>代理实际上指代理服务器。功能是代理 网络用户去取得网络信息，是网络信息的中转站。</p><p>正常的请求过程为：发送请求给服务器===&gt;web服务器吧响应传回</p><p>设置代理服务器后：==&gt;向代理服务器发送请求==&gt;请求发送给代理服务器==&gt;再由代理服务器发送web服务器==&gt;由代理服务器把web服务器返回的响应转发给本机</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>突破自身IP访问限制，访问些平时不能访问的站点。</p><p>访问一些单位或团体内部资源:比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</p><p>提高访问速度:通常代理服务器都设置-一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息传给用户，以提高访问速度。</p><p>隐藏真实IP:上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP,防止自身的IP被封锁。 </p><h3 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h3><h5 id="根据代理的协议，代理可以分为如下类别。"><a href="#根据代理的协议，代理可以分为如下类别。" class="headerlink" title="根据代理的协议，代理可以分为如下类别。"></a>根据代理的协议，代理可以分为如下类别。</h5><ul><li>FTP代理服务器:  主要用于访问FTP服务器，一般有上传、 下载以及缓存功能，端口一般为   21、2121等。   </li><li>HTTP代理服务器:主要用于访问网页，一般有内容过滤和缓存功能，端口一般为808080、3128 等。 </li><li>SSL/TLS代理:主要用于访同加密网站，般有 SsL 或TLS 加密功能(最高支持128位加密强度)，端口一般为443。</li><li>RTSP代理:主要用于访问Real流媒体服务器，一般有缓存功能， 端口般为554。   </li><li>Telnet代理: 主要用于tenei远程控制黑客人侵计算机时常用于隐藏身份)，端口一般为23</li><li>POP3/SMTP代理:主要用于POP3/SMTP方式收发邮件，一般有缓存功能，端口-般为1025.口SOCKS代理:只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般 有   存功能，端口一般为1080。SOCKS代理协议又分为SOCKS4和SOCKS5,前者只支持TCP而后者支持TCP和UDP，还支持各种身份验证机制、服务器端域名解析等。简单来说SOCKS4能做到的SOCKS5都可以做到，但SOCKSS能做到的SOCKS4不一定能做到。</li></ul><h5 id="2-根据匿名程度区分-根据代理的匿名程度，代理可以分为如下类别。"><a href="#2-根据匿名程度区分-根据代理的匿名程度，代理可以分为如下类别。" class="headerlink" title="2.根据匿名程度区分   根据代理的匿名程度，代理可以分为如下类别。"></a>2.根据匿名程度区分   根据代理的匿名程度，代理可以分为如下类别。</h5><ul><li><p>高度匿名代理：会将数据包原封不动地转发，在服务端看来就好像真的是一 个普通客户端访问，而记录的IP是代理服务器的IP。</p></li><li><p>普通匿名代理：会在数据包上做一些改动， 服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实IP。代理服务器通常会加人的HTTP头有HTTP_VIA和HTTP_X_FORWARDED_FOR.</p></li><li><p>透明代理：不但改动了数据包，还会告诉服务器客户端的真实IP。这种代理除了能用缓存技术调高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。</p></li><li><p>间谍代理：指组织或个人创建的用于记录用户传输的数据， 然后进行研究、监控等目的代理服务器。</p><p>常用代理设置</p></li><li><p>网上的免费代理</p></li><li><p>付费的代理服务</p></li><li><p>ADSL拨号</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;代理&quot;&gt;&lt;a href=&quot;#代理&quot; class=&quot;headerlink&quot; title=&quot;代理&quot;&gt;&lt;/a&gt;代理&lt;/h4&gt;&lt;h6 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——请求</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——请求/</id>
    <published>2018-10-24T10:36:21.000Z</published>
    <updated>2018-10-24T10:40:33.145Z</updated>
    
    <content type="html"><![CDATA[<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><blockquote><p>:请求方法、请求网址、请求头、请求体</p></blockquote><h5 id="请求方法："><a href="#请求方法：" class="headerlink" title="请求方法："></a>请求方法：</h5><blockquote><p>常见的为:GET、POST</p><p>GET与POST主要区别：</p><ul><li>GET请求参数包含在URL，可从URL中看出。POST请求的URL不包含参数，都是通过表单的形式传输的，包含在请求体中</li><li>GET请求提交的数据最多只有1024字节，POST无限制</li></ul></blockquote><p>其他还有HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE</p><h5 id="请求的网址："><a href="#请求的网址：" class="headerlink" title="请求的网址："></a>请求的网址：</h5><blockquote><p>即URL，我们想要请求的资源</p></blockquote><h5 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h5><p>用来说明服务器要使用的附加信息，比较总要的有Cookie、Referer、User-Agent等。</p><blockquote><p>Accept:请求报头域，用于指定客户端可接受哪些类型的信息。   </p><p>Accept-Language:指定客户端可接受的语言类型。</p><p>Accept-Encoding:指定客户端可接受的内容编码。   </p><p> Host:用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位   置。从HTTP1.1版本开始，请求必须包含此内容。  </p><p>Cookie:也常用复数形式Cookies, 是网站为了<u>辨别用户进行会话跟踪</u>而存储在用户<strong>本地</strong>的数据。它的主要功能是维持当前访问会话。例如，我们输人用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies 并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。   </p><p>Referer:此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、<u>防盗链处理</u>等。   </p><p>User-Agent: 简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等消息。在做爬虫时加上此信息，可以伪装成浏览器；如果不加，很可能被识别出为爬虫</p><p>Content-Type:也叫互联网媒体类型( Intermet Media Type)或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。更多对应关系可以查看此对表:<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a></p></blockquote><table><thead><tr><th>文件扩展名</th><th>Content-Type(Mime-Type)</th></tr></thead><tbody><tr><td>.html、 .htx 、 .htm</td><td>text/html</td></tr><tr><td>.gif</td><td>image/gif</td></tr><tr><td>.json</td><td>application/json</td></tr></tbody></table><p>​                    <strong>Content-Type与POST提交数据方式的关系</strong></p><table><thead><tr><th>Content-Type</th><th>提交数据的方式</th></tr></thead><tbody><tr><td>appication/x-www-urlencodeed</td><td>表单数据</td></tr><tr><td>multipart/form-data</td><td>表单文件上传</td></tr><tr><td>applicatiobn/json</td><td>序列化json数据</td></tr><tr><td>text/html</td><td>XML数据</td></tr></tbody></table><blockquote><p>如果构造POST请求，需要使用正确的Content-Type，不然可能导致POST提交后无法正常响应</p></blockquote><p>==&gt;因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p><h5 id="请求体："><a href="#请求体：" class="headerlink" title="请求体："></a>请求体：</h5><blockquote><p>请求体一般承载的内容是POST请求中的表单数据，而对GET请求，请求体则为空。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;请求&quot;&gt;&lt;a href=&quot;#请求&quot; class=&quot;headerlink&quot; title=&quot;请求&quot;&gt;&lt;/a&gt;请求&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;:请求方法、请求网址、请求头、请求体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;请求方法：&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——响应</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E5%93%8D%E5%BA%94/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——响应/</id>
    <published>2018-10-24T10:36:17.000Z</published>
    <updated>2018-10-24T10:42:19.208Z</updated>
    
    <content type="html"><![CDATA[<h4 id="响应："><a href="#响应：" class="headerlink" title="响应："></a>响应：</h4><p>响应状态码、响应头、响应体</p><h5 id="响应状态码："><a href="#响应状态码：" class="headerlink" title="响应状态码："></a>响应状态码：</h5><pre><code>表2-3常见的错误代码及错误原因</code></pre><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</td></tr><tr><td>101</td><td>切换协议</td><td>请求者已要求服务器切换协议，服务器已确认并准备切换。</td></tr><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</td></tr><tr><td>201</td><td>已创建</td><td>请求成功并且服务器创建了新的资源。</td></tr><tr><td>202</td><td>已接受</td><td>服务器已接受请求，但尚未处理。</td></tr><tr><td>203</td><td>非授权信息</td><td>服务器已成功处理了请求，但返回的信息可能来自另一来源。</td></tr><tr><td>204</td><td>无内容</td><td>服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td>205</td><td>重置内容</td><td>服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td>206</td><td>部分内容</td><td>服务器成功处理了部分 GET 请求。</td></tr><tr><td>300</td><td>多种选择</td><td>针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</td></tr><tr><td>301</td><td>永久移动</td><td>请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td></tr><tr><td>302</td><td>临时移动</td><td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td>303</td><td>查看其他位置</td><td>请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td></tr><tr><td>304</td><td>未修改</td><td>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</td></tr><tr><td>305</td><td>使用代理</td><td>请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</td></tr><tr><td>307</td><td>临时重定向</td><td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td>400</td><td>错误请求</td><td>服务器不理解请求的语法。</td></tr><tr><td>401</td><td>未授权</td><td>请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</td></tr><tr><td>403</td><td>禁止</td><td>服务器拒绝请求。</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的网页。</td></tr><tr><td>405</td><td>方法禁用</td><td>禁用请求中指定的方法。</td></tr><tr><td>406</td><td>不接受</td><td>无法使用请求的内容特性响应请求的网页。</td></tr><tr><td>407</td><td>需要代理授权</td><td>此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td></tr><tr><td>408</td><td>请求超时</td><td>服务器等候请求时发生超时。</td></tr><tr><td>409</td><td>冲突</td><td>服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。</td></tr><tr><td>410</td><td>已删除</td><td>如果请求的资源已永久删除，服务器就会返回此响应。</td></tr><tr><td>411</td><td>需要有效长度</td><td>服务器不接受不含有效内容长度标头字段的请求。</td></tr><tr><td>412</td><td>未满足前提条件</td><td>服务器未满足请求者在请求中设置的其中一个前提条件。</td></tr><tr><td>413</td><td>请求实体过大</td><td>服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</td></tr><tr><td>414</td><td>请求的 URI 过长</td><td>请求的 URI（通常为网址）过长，服务器无法处理。</td></tr><tr><td>415</td><td>不支持的媒体类型</td><td>请求的格式不受请求页面的支持。</td></tr><tr><td>416</td><td>请求范围不符合要求</td><td>如果页面无法提供请求的范围，则服务器会返回此状态代码。</td></tr><tr><td>417</td><td>未满足期望值</td><td>服务器未满足”期望”请求标头字段的要求。</td></tr><tr><td>500</td><td>服务器内部错误</td><td>服务器遇到错误，无法完成请求。</td></tr><tr><td>501</td><td>尚未实施</td><td>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理，从上游服务器收到无效响应。</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</td></tr><tr><td>504</td><td>网关超时</td><td>服务器作为网关或代理，但是没有及时从上游服务器收到请求。</td></tr><tr><td>505</td><td>HTTP 版本不受支持</td><td>服务器不支持请求中所用的 HTTP 协议版本。</td></tr></tbody></table><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><p> 响应头包含了服务器对请求的应答信息，如Cmene-Type. Serve. Set-cookie等。 下面简要说有 一些常用的头信息。 </p><ul><li>Date:标识响应产生的时间。 </li><li>Last-Modifed:指定资源的最后修改时间。 公有地会 </li><li>Content-Encoding:指定响应内容的编码。 </li><li>Server:包含服务器的信息，比如名称、版本号等。 </li><li>Content-Type:文档类型，指定返回的数据类型是什么，如texthtmI代表返回HTML文档， application/x-javascript则代表返回JavaScript文件，imagefjpeg 则代表返回图片。</li><li>Set-Cookie:设置Cookies。 响应头中的Set-Cookie 告诉浏览器需要将此内容放在Cooke 中，下次请求携带Cookies请求。</li><li>Expires:指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。立 果再次访问时，就可以直接从缓存中加载，降低服务器负载，编短加载时间。</li></ul><h5 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h5><p>最重要的当属响应体的内容了。 响应的正文数据都在响应体中，比如请求网页时，它的响应体就 是网页的HTML代码:请求一张图片时， 它的响应体就是图片的二进制数据。我们做爬虫请求后主 要解析的内容就是响应体。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;响应：&quot;&gt;&lt;a href=&quot;#响应：&quot; class=&quot;headerlink&quot; title=&quot;响应：&quot;&gt;&lt;/a&gt;响应：&lt;/h4&gt;&lt;p&gt;响应状态码、响应头、响应体&lt;/p&gt;
&lt;h5 id=&quot;响应状态码：&quot;&gt;&lt;a href=&quot;#响应状态码：&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——爬虫的基本原理</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——爬虫的基本原理/</id>
    <published>2018-10-24T10:36:10.000Z</published>
    <updated>2018-10-24T10:42:36.885Z</updated>
    
    <content type="html"><![CDATA[<h4 id="爬虫的基本原理"><a href="#爬虫的基本原理" class="headerlink" title="爬虫的基本原理"></a>爬虫的基本原理</h4><blockquote><p>爬虫就是<u>获取网页</u>并<u>提取</u>和<u>保存信息</u>的<u>自动化程序</u></p></blockquote><h5 id="获取网页："><a href="#获取网页：" class="headerlink" title="获取网页："></a>获取网页：</h5><p>获取网页就是获取网页的源码，只要把源码获取下来，就可以从中提取想要的消息</p><blockquote><p>爬虫的流程：想网站的服务器发送一个请求，返回的响应体就是网页的源代码。</p><p>​    ==&gt;1,构造请求发送给服务器===&gt;2.接受响应并解析</p></blockquote><h5 id="提取信息："><a href="#提取信息：" class="headerlink" title="提取信息："></a>提取信息：</h5><p>通过分析网页结构，提取网页信息。通常使用的解析库有:BeautifulSoup、lxml、pyquery，也可以使用正则，但是构造正则表达式比较复杂且易错</p><h5 id="保存数据："><a href="#保存数据：" class="headerlink" title="保存数据："></a>保存数据：</h5><p>将提取的数据保存到某处以便后续利用。保存形式有：TXT、Json、数据库：MySQL、MongoDB、或远程服务器SFTP…</p><h5 id="自动化程序"><a href="#自动化程序" class="headerlink" title="自动化程序"></a>自动化程序</h5><p>替人完成完成爬取工作的自动化程序，可以在抓取过程中进行异常处理……保证爬取的高效运行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;爬虫的基本原理&quot;&gt;&lt;a href=&quot;#爬虫的基本原理&quot; class=&quot;headerlink&quot; title=&quot;爬虫的基本原理&quot;&gt;&lt;/a&gt;爬虫的基本原理&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;爬虫就是&lt;u&gt;获取网页&lt;/u&gt;并&lt;u&gt;提取&lt;/u&gt;和&lt;u&gt;保存信息&lt;/u&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——URL与URI</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94URL%E4%B8%8EURI/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——URL与URI/</id>
    <published>2018-10-24T10:35:53.000Z</published>
    <updated>2018-10-24T10:41:12.634Z</updated>
    
    <content type="html"><![CDATA[<h4 id="URL与URI"><a href="#URL与URI" class="headerlink" title="URL与URI"></a>URL与URI</h4><ul><li><p>URL全称：Uniform Resource Locator(统一资源定位符)</p></li><li><p>URI全称：Uniform Resource Identifier(统一资源标识符)</p><p>如<a href="https://github.com/favicon.ico为例，它既是一个URL又是一个URI。我们通过URL/URI唯一指定了它的访问方式。其中包括访问协议https、访问路径、资源名称favicon.ico。通过这个链接提供的消息，我们就可以直接访问到此资源所在的位置。这便是URL、URI的作用。" target="_blank" rel="noopener">https://github.com/favicon.ico为例，它既是一个URL又是一个URI。我们通过URL/URI唯一指定了它的访问方式。其中包括访问协议https、访问路径、资源名称favicon.ico。通过这个链接提供的消息，我们就可以直接访问到此资源所在的位置。这便是URL、URI的作用。</a></p><blockquote><p>URL是URI的子集。===&gt;每个URL都是URI，但不是每个URI都是URL。</p><p>URI包括两个子类:URN和URL。其中URN只命名资源但不指定如何定位资源(如urn:isbn:0451450523)指定了一本书的ISBN，可以唯一标识，但未定位。</p><p>▲.目前互联网中URN用得很少，几乎所有的URI都是URL。</p></blockquote></li></ul><p><img src="/2018/10/24/Python爬虫知识点——URL与URI/URL_URI_URN.jpg" alt="URL_URI_URN"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;URL与URI&quot;&gt;&lt;a href=&quot;#URL与URI&quot; class=&quot;headerlink&quot; title=&quot;URL与URI&quot;&gt;&lt;/a&gt;URL与URI&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;URL全称：Uniform Resource Locator(统一资源定位符)&lt;/
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="计算机网络知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫知识点——Chrome开发者工具Network</title>
    <link href="https://nymrli.top/2018/10/24/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7Network/"/>
    <id>https://nymrli.top/2018/10/24/Python爬虫知识点——Chrome开发者工具Network/</id>
    <published>2018-10-24T10:35:31.000Z</published>
    <updated>2018-10-24T10:38:09.294Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Chrome开发者工具中Network功能介绍"><a href="#Chrome开发者工具中Network功能介绍" class="headerlink" title="Chrome开发者工具中Network功能介绍"></a>Chrome开发者工具中Network功能介绍</h4><ul><li>第一列Name:请求的名称，一般会将URL的最后一 部分内容当作名称。  </li><li>第二列Status: 响应的状态码，这里显示为200，代表响应是正常的。通过状态码，我们可   以判断发送了请求之后是否得到了正常的响应。   </li><li>第三列Type: 请求的文档类型。这里为document, 代表我们这次请求的是一个HTML文档,内容就是一些HTML代码。  </li><li>第四列initiator: 请求源。用来标记请求是由哪个对象或进程发起的。   </li><li>第五列Size: 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示from cache。</li><li>第六列Time:发起请求到获取响应所用的总时间。</li><li>第七列Waterfall:网络请求的可视化瀑布流。  </li></ul><p>响应中分General部分，请求头、响应头：</p><blockquote><p>其中General含：</p><ul><li>Request URL为请求的URL，</li><li>Request Method为请求的方法</li><li>Status Code为响应状态码，</li><li>Remote Address为远程服务器的地址和端口</li><li>Referrer Policy为Referrer判别策略。</li></ul></blockquote><p><img src="/2018/10/24/Python爬虫知识点——Chrome开发者工具Network/Chrome.jpg" alt="Chrome"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Chrome开发者工具中Network功能介绍&quot;&gt;&lt;a href=&quot;#Chrome开发者工具中Network功能介绍&quot; class=&quot;headerlink&quot; title=&quot;Chrome开发者工具中Network功能介绍&quot;&gt;&lt;/a&gt;Chrome开发者工具中Netwo
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>XShell通过SSH远程连接云服务器通过SSH远程连接云服务器</title>
    <link href="https://nymrli.top/2018/10/24/XShell%E9%80%9A%E8%BF%87SSH%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://nymrli.top/2018/10/24/XShell通过SSH远程连接云服务器/</id>
    <published>2018-10-24T10:32:05.000Z</published>
    <updated>2018-10-24T10:33:38.150Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-账号密码登录"><a href="#1-账号密码登录" class="headerlink" title="1.账号密码登录"></a>1.账号密码登录</h3><h5 id="法一"><a href="#法一" class="headerlink" title="法一:"></a>法一:</h5><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/1.jpg" alt="1"></p><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/2.jpg" alt="2"></p><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/3.jpg" alt="3"></p><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/4.jpg" alt="4"></p><hr><h5 id="法二"><a href="#法二" class="headerlink" title="法二:"></a>法二:</h5><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/11.jpg" alt="11"></p><p><img src="/2018/10/24/XShell通过SSH远程连接云服务器/22.jpg" alt="22"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-账号密码登录&quot;&gt;&lt;a href=&quot;#1-账号密码登录&quot; class=&quot;headerlink&quot; title=&quot;1.账号密码登录&quot;&gt;&lt;/a&gt;1.账号密码登录&lt;/h3&gt;&lt;h5 id=&quot;法一&quot;&gt;&lt;a href=&quot;#法一&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="服务器" scheme="https://nymrli.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
</feed>
