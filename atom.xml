<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mrli&#39;s Blog</title>
  
  <subtitle>别装作很努力，结局不会陪你演戏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nymrli.top/"/>
  <updated>2020-09-04T08:46:36.947Z</updated>
  <id>https://nymrli.top/</id>
  
  <author>
    <name>Mrli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL练习</title>
    <link href="https://nymrli.top/2020/09/04/SQL%E7%BB%83%E4%B9%A0/"/>
    <id>https://nymrli.top/2020/09/04/SQL练习/</id>
    <published>2020-09-04T07:54:57.000Z</published>
    <updated>2020-09-04T08:46:36.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sql练习"><a class="markdownIt-Anchor" href="#sql练习"></a> SQL练习</h1><blockquote><p>鉴于同学被字节狂问SQL题，因此也激发了我的危机感。 作为非科班的， 写SQL还是比较慌的， 因此做下专题训练。</p></blockquote><h2 id="理论知识"><a class="markdownIt-Anchor" href="#理论知识"></a> 理论知识:</h2><p>SQL语句执行顺序</p><h3 id="1sql执行顺序"><a class="markdownIt-Anchor" href="#1sql执行顺序"></a> 1.<a href="https://www.cnblogs.com/yyjie/p/7788428.html" target="_blank" rel="noopener">sql执行顺序 </a></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(1)from </span><br><span class="line">(3) join </span><br><span class="line">(2) on </span><br><span class="line">(4) where </span><br><span class="line">(5)group by(开始使用<span class="keyword">select</span>中的别名，后面的语句中都可以使用)</span><br><span class="line">(<span class="number">6</span>) <span class="keyword">avg</span>,sum.... </span><br><span class="line">(<span class="number">7</span>)<span class="keyword">having</span> </span><br><span class="line">(<span class="number">8</span>) <span class="keyword">select</span> </span><br><span class="line">(<span class="number">9</span>) <span class="keyword">distinct</span> </span><br><span class="line">(<span class="number">10</span>) <span class="keyword">order</span> <span class="keyword">by</span></span><br></pre></td></tr></table></figure><p>2.<a href="https://blog.csdn.net/u013887008/article/details/93377939" target="_blank" rel="noopener">sql语句执行顺序</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(8) <span class="keyword">SELECT</span> (<span class="number">9</span>)<span class="keyword">DISTINCT</span>&lt;select_list&gt;</span><br><span class="line">(<span class="number">1</span>) <span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line">(<span class="number">3</span>) &lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line">(<span class="number">2</span>)         <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">(<span class="number">4</span>) <span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line">(<span class="number">5</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">6</span>) <span class="keyword">WITH</span> &#123;<span class="keyword">CUBE</span>|<span class="keyword">ROLLUP</span>&#125;</span><br><span class="line">(<span class="number">7</span>) <span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line">(<span class="number">10</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_list&gt;</span><br><span class="line">(<span class="number">11</span>) <span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure><h3 id="用group-by需要注意的"><a class="markdownIt-Anchor" href="#用group-by需要注意的"></a> 用<code>group by</code>需要注意的:</h3><ul><li>在select<strong>指定的字段</strong><ul><li>要么就要<strong>包含在Group By语句</strong>的后面，作为分组的依据；</li><li>要么就要<strong>被包含在聚合函数</strong>中。</li></ul></li></ul><h3 id="sql查询语句中的-limit-与-offset-的区别"><a class="markdownIt-Anchor" href="#sql查询语句中的-limit-与-offset-的区别"></a> SQL查询语句中的 limit 与 offset 的区别：</h3><ul><li><code>limit y</code> 分句表示: 读取 y 条数据</li><li><code>limit x, y</code> 分句表示: 跳过 x 条数据，读取 y 条数据</li><li><code>limit y offset x</code> 分句表示: 跳过 x 条数据，读取 y 条数据</li></ul><h4 id="分页操作"><a class="markdownIt-Anchor" href="#分页操作"></a> 分页操作</h4><p>语法：limit开始索引，每页查询的记录数<br>注：索引从0开始<br><code>公式：开始索引=（当前页码-1）*每页查询的记录数</code>即 <code>index = (nowPageNum - 1) * pageSize</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> </span><br><span class="line"><span class="keyword">WHERE</span> 查询条件 </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序条件 </span><br><span class="line"><span class="keyword">LIMIT</span> ((页码<span class="number">-1</span>)*页大小),页大小;</span><br><span class="line"><span class="comment">-- LIMIT (pageNum-1)*pageSize, pageSize</span></span><br><span class="line"><span class="comment">-- 第一个参数是偏移量， 第二个是所取数据数</span></span><br></pre></td></tr></table></figure><hr><h2 id="查找最晚入职员工的所有信息"><a class="markdownIt-Anchor" href="#查找最晚入职员工的所有信息"></a> <a href="https://www.nowcoder.com/practice/218ae58dfdcd4af195fff264e062138f?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 查找最晚入职员工的所有信息</a>(入门题)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="查找入职员工时间排名倒数第三的员工所有信息"><a class="markdownIt-Anchor" href="#查找入职员工时间排名倒数第三的员工所有信息"></a> <a href="https://www.nowcoder.com/practice/ec1ca44c62c14ceb990c3c40def1ec6c?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">查找入职员工时间排名倒数第三的员工所有信息</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">desc</span> <span class="comment">-- 递减排序</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">2</span>,<span class="number">1</span> ;<span class="comment">-- offset 2， 取1</span></span><br></pre></td></tr></table></figure><p>SQL查询语句中的 limit 与 offset 的区别：</p><ul><li><code>limit y</code> 分句表示: 读取 y 条数据</li><li><code>limit x, y</code> 分句表示: 跳过 x 条数据，读取 y 条数据</li><li><code>limit y offset x</code> 分句表示: 跳过 x 条数据，读取 y 条数据</li></ul><h2 id="查找各个部门当前领导当前薪水详情以及其对应部门编号dept_no"><a class="markdownIt-Anchor" href="#查找各个部门当前领导当前薪水详情以及其对应部门编号dept_no"></a> <a href="https://www.nowcoder.com/practice/c63c5b54d86e4c6d880e4834bfd70c3b?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 查找各个部门当前领导当前薪水详情以及其对应部门编号dept_no</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.*, d.dept_no </span><br><span class="line"><span class="keyword">from</span> salaries <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">join</span> dept_manager <span class="keyword">as</span> d</span><br><span class="line"><span class="keyword">on</span> s.emp_no = d.emp_no</span><br><span class="line"><span class="keyword">where</span> d.to_date=<span class="string">'9999-01-01'</span> <span class="keyword">and</span> s.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> s.emp_no;</span><br></pre></td></tr></table></figure><h2 id="牛客每个人最近的登录日期一"><a class="markdownIt-Anchor" href="#牛客每个人最近的登录日期一"></a> <a href="https://www.nowcoder.com/practice/ca274ebe6eac40ab9c33ced3f2223bb2?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">牛客每个人最近的登录日期(一)</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="built_in">date</span>)</span><br><span class="line"><span class="keyword">from</span> login</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id</span><br></pre></td></tr></table></figure><h2 id="牛客每个人最近的登录日期二"><a class="markdownIt-Anchor" href="#牛客每个人最近的登录日期二"></a> <a href="https://www.nowcoder.com/practice/7cc3c814329546e89e71bb45c805c9ad?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">牛客每个人最近的登录日期(二)</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user.name,client.name,<span class="keyword">max</span>(login.date)</span><br><span class="line"><span class="keyword">from</span> login</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> <span class="keyword">on</span> login.user_id = user.id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">client</span> <span class="keyword">on</span> login.client_id = client.id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> user.name;</span><br></pre></td></tr></table></figure><p>用<code>group by</code>需要注意的:</p><ul><li>在select<strong>指定的字段</strong><ul><li>要么就要<strong>包含在Group By语句</strong>的后面，作为分组的依据；</li><li>要么就要<strong>被包含在聚合函数</strong>中。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sql练习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sql练习&quot;&gt;&lt;/a&gt; SQL练习&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;鉴于同学被字节狂问SQL题，因此也激发了我的危机感。 作为非科班的， 写SQL还是比较慌的， 因此做
      
    
    </summary>
    
    
      <category term="后端" scheme="https://nymrli.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SQL" scheme="https://nymrli.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>IDEA插件开发</title>
    <link href="https://nymrli.top/2020/07/11/IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>https://nymrli.top/2020/07/11/IDEA插件开发/</id>
    <published>2020-07-11T07:50:42.000Z</published>
    <updated>2020-07-11T12:02:09.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新建idea-插件工程"><a class="markdownIt-Anchor" href="#新建idea-插件工程"></a> 新建IDEA 插件工程</h2><p>File -&gt; new -&gt; Project -&gt; Plugin即可</p><p>初始会生成一个项目xml配置文件, 以下是我进行修改后的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">idea-plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>top.nymrli.privatesee<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>privateSee<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vendor</span> <span class="attr">email</span>=<span class="string">"nymrli99@163.com"</span> <span class="attr">url</span>=<span class="string">"http://nymrli.top"</span>&gt;</span>Mrli<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">      Highlight when private methods are called.</span><br><span class="line">    ]]&gt;<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">change-notes</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;em&gt;First created. This time will be tried&lt;/em&gt;</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">    ]]&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">change-notes</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- please see https://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/build_number_ranges.html for description --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">idea-version</span> <span class="attr">since-build</span>=<span class="string">"173.0"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- please see https://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/plugin_compatibility.html</span></span><br><span class="line"><span class="comment">       on how to target different products --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depends</span>&gt;</span>com.intellij.modules.platform<span class="tag">&lt;/<span class="name">depends</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">"com.intellij"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Add your actions here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">id</span>=<span class="string">"FirstPluginActionId"</span> <span class="attr">class</span>=<span class="string">"top.nymrli.privatesee.FirstPluginAction"</span> <span class="attr">text</span>=<span class="string">"测试"</span> <span class="attr">description</span>=<span class="string">"测试描述"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">add-to-group</span> <span class="attr">group-id</span>=<span class="string">"ToolsMenu"</span> <span class="attr">anchor</span>=<span class="string">"first"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">keyboard-shortcut</span> <span class="attr">keymap</span>=<span class="string">"$default"</span> <span class="attr">first-keystroke</span>=<span class="string">"ctrl I"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">idea-plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="新建action"><a class="markdownIt-Anchor" href="#新建action"></a> 新建action</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstPluginAction</span> <span class="keyword">extends</span> <span class="title">AnAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(AnActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> insert action logic here</span></span><br><span class="line">        NotificationGroup notificationgroup = <span class="keyword">new</span> NotificationGroup(<span class="string">"flugin_id"</span>, NotificationDisplayType.BALLOON, <span class="keyword">true</span>);</span><br><span class="line">        Notification notification = notificationgroup.createNotification(<span class="string">"点击测试"</span>, MessageType.INFO);</span><br><span class="line">        Notifications.Bus.notify(notification);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试: edit configuration选择plugin, 然后选择运行</p><h2 id="启动初始化"><a class="markdownIt-Anchor" href="#启动初始化"></a> 启动初始化</h2><p>新建一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationComponent</span> <span class="keyword">implements</span> <span class="title">ApplicationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"插件初始化"</span>);</span><br><span class="line">        TanChuanDialog dialog = <span class="keyword">new</span> TanChuanDialog();</span><br><span class="line">        dialog.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在xml配置指定</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application-components</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">implementation-class</span>&gt;</span></span><br><span class="line">        top.nymrli.privatesee.MyApplicationComponent</span><br><span class="line">      <span class="tag">&lt;/<span class="name">implementation-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application-components</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="弹窗效果"><a class="markdownIt-Anchor" href="#弹窗效果"></a> 弹窗效果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TanChuanDialog</span> <span class="keyword">extends</span> <span class="title">DialogWrapper</span> </span>&#123;</span><br><span class="line">    JPanel jPanel;</span><br><span class="line">    JLabel label;</span><br><span class="line">    JButton btn;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TanChuanDialog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 设置弹窗的标题</span></span><br><span class="line">        setTitle(<span class="string">"启动弹窗"</span>);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置弹窗中间展示内容</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JComponent <span class="title">createCenterPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jPanel = <span class="keyword">new</span> JPanel();</span><br><span class="line">        label = <span class="keyword">new</span> JLabel(<span class="string">"显示内容"</span>);</span><br><span class="line">        jPanel.add(label);</span><br><span class="line">        <span class="keyword">return</span> jPanel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义设置底部的按钮</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JComponent <span class="title">createSouthPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jPanel = <span class="keyword">new</span> JPanel();</span><br><span class="line">         btn = <span class="keyword">new</span> JButton(<span class="string">"再干一杯"</span>);</span><br><span class="line">         btn.addActionListener(e-&gt;&#123;</span><br><span class="line">             label.setText(<span class="string">"被点击了哦"</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">        jPanel.add(btn);</span><br><span class="line">        <span class="keyword">return</span> jPanel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;新建idea-插件工程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#新建idea-插件工程&quot;&gt;&lt;/a&gt; 新建IDEA 插件工程&lt;/h2&gt;
&lt;p&gt;File -&amp;gt; new -&amp;gt; Project -&amp;gt; Plugin即可&lt;/
      
    
    </summary>
    
    
      <category term="Java" scheme="https://nymrli.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>getBargains的record和Solution</title>
    <link href="https://nymrli.top/2020/05/24/getBargains%E7%9A%84record%E5%92%8CSolution/"/>
    <id>https://nymrli.top/2020/05/24/getBargains的record和Solution/</id>
    <published>2020-05-24T08:44:25.000Z</published>
    <updated>2020-05-31T11:38:26.323Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该篇为**<a href="https://github.com/Freedomisgood/getBargains" target="_blank" rel="noopener">getBargains</a>**仓库README.md直接搬运，记录一些appnium和andriod 10碰到的问题</p></blockquote><h2 id="自动拿券"><a class="markdownIt-Anchor" href="#自动拿券"></a> 自动拿券</h2><blockquote><p>通过别人发的口令, 打开淘宝APP进行抢券</p></blockquote><h3 id="1itchat接收群消息"><a class="markdownIt-Anchor" href="#1itchat接收群消息"></a> 1.itchat接收群消息</h3><h3 id="2将口令复制到剪贴板"><a class="markdownIt-Anchor" href="#2将口令复制到剪贴板"></a> 2.将口令复制到剪贴板</h3><h3 id="3打开淘宝app点击抢券"><a class="markdownIt-Anchor" href="#3打开淘宝app点击抢券"></a> 3.打开淘宝APP点击抢券</h3><h2 id="碰到的问题"><a class="markdownIt-Anchor" href="#碰到的问题"></a> 碰到的问题:</h2><ol><li><p>出现如下警告:<code>Warning: Activity not started, its current task has been brought to the front</code> or <code>Warning: Activity not started, intent has been delivered to currently running top-most instance.</code></p><ul><li>A: 不用管他就行, 只是个警告, 提示你有应用切到了顶层</li></ul></li><li><p>出现提示: <code>/system/bin/sh: adb: inaccessible or not found</code></p><ul><li>A: 已经在adb shell中输入的命令不需要再加上<code>adb shell</code>前缀<br>e.g.<code>umi:/ $ adb shell am start ca.zgrs.clipper/.Main</code> (umi:/)提示已经在adb shell中了</li></ul></li><li><p>查找app包名和Activity活动页面(Andriod 10)</p><ul><li>A: 原本的<code>adb shell dumpsys activity | find &quot;mFocusedActivity&quot;</code>在andriod 10上好像检测不出来</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看包名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adb shell pm list packages</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Activity</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> $ adb shell dumpsys activity com.taobao.taobao | grep ACTIVITY</span></span><br></pre></td></tr></table></figure><ol start="4"><li>adb打开应用的命令?</li></ol><ul><li>A: <code>adb shell am start -n package/launch activity</code></li></ul><ol start="5"><li><p>appnium声明driver的时候是打开指定app程序, 但如果每次都是重新打开, 那么加载淘宝的速度会很慢。应该使用切换后台</p><ul><li>A: 使用<code>driver.start_activity('com.taobao.taobao', 'com.taobao.tao.TBMainActivity')</code></li></ul><p><a href="https://blog.csdn.net/jianglianye21/article/details/89850033" target="_blank" rel="noopener">appium：一个手机运行两个APP，APP之间相互切换</a></p></li><li><p>ADB滑动解锁问题: 在一个位置按住</p><ul><li>A: 暂时还没解决, appnium可以, 但ADB好像没有找到解决方案</li></ul></li><li><p>桌面的activity:</p><ul><li>A: <code>.launcher.Launcher</code></li></ul></li><li><p>报错<code>selenium.common.exceptions.InvalidSessionIdException: Message: A session is either terminated or not started</code></p><ul><li>A: 原因是driver长时间没收到command自动关闭了, 与使用<code>driver.quit()</code>后再用driver执行操作报相同的错误。</li><li>-&gt;解决方案: 在desirable_caps中将<code>newCommandTimeout</code>设置大一点: <code>'newCommandTimeout': 1800</code></li></ul></li></ol><p>附录：</p><ul><li><p><a href="https://blog.csdn.net/lollipop666/article/details/82480403" target="_blank" rel="noopener">python3使用appnium运行手机上的APP</a></p></li><li><p><a href="https://github.com/majido/clipper/issues/9" target="_blank" rel="noopener">clipper - Broken on Android 10 (Android Q) #9</a></p></li><li><p><a href="https://testerhome.com/topics/3711" target="_blank" rel="noopener">Appium Python API 中文版 By-HZJ</a></p></li><li><p><a href="https://blog.csdn.net/u012002125/article/details/80870549" target="_blank" rel="noopener">Appium配置desired_capability详解</a></p></li><li><p>查看包名和activity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  # 在米6(Andriod 10)上尝试可行</span><br><span class="line">  $ adb shell dumpsys window windows | findstr mFocusedApp</span><br><span class="line">  $ adb shell dumpsys window windows | findstr &quot;Current&quot;</span><br><span class="line">  </span><br><span class="line"># 下失效</span><br><span class="line">  $ adb shell dumpsys activity | find  mFocusedActivity</span><br></pre></td></tr></table></figure><ul><li><p>如果在有apk的情况下, <code>aapt dump badging d:\\test.apk</code></p></li><li><p>打开APP-&gt;<code>adb logcat &gt; D:/log.txt</code>  -&gt; 胡乱的对APP做一些操作-&gt;Ctrl+c 结束adb命令-&gt;打开log.txt文件，搜索：Displayed</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该篇为**&lt;a href=&quot;https://github.com/Freedomisgood/getBargains&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;getBargains&lt;/a&gt;**仓库README.md直接搬运，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IDEA配置——自定义快捷键、生成注释</title>
    <link href="https://nymrli.top/2020/05/15/IDEA%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E3%80%81%E7%94%9F%E6%88%90%E6%B3%A8%E9%87%8A/"/>
    <id>https://nymrli.top/2020/05/15/IDEA配置——自定义快捷键、生成注释/</id>
    <published>2020-05-15T02:22:20.000Z</published>
    <updated>2020-06-14T08:03:13.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="idea配置自定义快捷键-生成注释"><a class="markdownIt-Anchor" href="#idea配置自定义快捷键-生成注释"></a> IDEA配置——自定义快捷键、生成注释</h1><blockquote><p>以前因为上JAVA课，还是不常用Java， 所以安装了个Eclipse， 但是现在要经常使用java的话， 感觉还是IDEA的支持做的可能更加到位一点</p></blockquote><h2 id="maven换源"><a class="markdownIt-Anchor" href="#maven换源"></a> Maven换源:</h2><blockquote><p>因为有段时间写SpringBoot被依赖给坑过，所以把Maven换源写在最前面。</p></blockquote><p>IDEA是会有默认的Maven工具的， 因此之前如果修改过Maven配置， 还需要在IDEA中指定具体使用的是哪一个MAVEN，使用哪一个配置文件。</p><p>▲(Ctrl + Alt + S修改的是当前工程)， 如果需要对新工程进行修改， 则点击<code>File-&gt;New Projects Settings-&gt;Settings for new Projects</code></p><p><img src="/2020/05/15/IDEA配置——自定义快捷键、生成注释/maven_idea.jpg" alt="maven_idea"></p><p>其中<code>User settings file</code>选择之前配置过的Maven_settings就行了，换源在里面修改。注意， mirror标签要放在mirrors标签内才能生效, 跟dependencies一样， 我后来才发现我竟然没放进去。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">   | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">   | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">   | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">  &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">    &lt;id&gt;mirrorId&lt;/id&gt;</span></span><br><span class="line"><span class="comment">    &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">    &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">    &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span></span><br><span class="line"><span class="comment">  &lt;/mirror&gt;</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>补充:</p><p>还可以在pom.xml文件中指定改源, 填下下列字段:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="自动补全提示"><a class="markdownIt-Anchor" href="#自动补全提示"></a> 自动补全提示:</h2><p>菜单栏Settings(快捷键ctrl + alt + s)-&gt;Editr-&gt;General-&gt;Code Completion-&gt; 取消选中&quot;Match case&quot;</p><h2 id="idea自定义快捷键"><a class="markdownIt-Anchor" href="#idea自定义快捷键"></a> IDEA自定义快捷键</h2><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">英文描述</th><th style="text-align:center">快捷键</th></tr></thead><tbody><tr><td style="text-align:center">回退上一次光标位置</td><td style="text-align:center">back</td><td style="text-align:center">Ctrl +alt + ←</td></tr><tr><td style="text-align:center">前进到下一次光标位置</td><td style="text-align:center">forward</td><td style="text-align:center">Ctrl +alt + →</td></tr><tr><td style="text-align:center">选中当前部分</td><td style="text-align:center">extend selection</td><td style="text-align:center">Ctrl + D</td></tr><tr><td style="text-align:center">复制当前行↑</td><td style="text-align:center">Duplicate Line or Selection</td><td style="text-align:center">shift + alt + ↑</td></tr><tr><td style="text-align:center">复制当前行↓</td><td style="text-align:center">Duplicate Entire Lines</td><td style="text-align:center">shift + alt + ↓</td></tr><tr><td style="text-align:center">切换到上行</td><td style="text-align:center">Move Line Up</td><td style="text-align:center">alt+↑</td></tr><tr><td style="text-align:center">切换到下行</td><td style="text-align:center">Move Line Down</td><td style="text-align:center">alt+↓</td></tr><tr><td style="text-align:center">下一个方法</td><td style="text-align:center">next Method</td><td style="text-align:center">ctrl + alt+ ↓</td></tr><tr><td style="text-align:center">上一个方法</td><td style="text-align:center">Previous Method</td><td style="text-align:center">ctrl + alt+ ↑</td></tr><tr><td style="text-align:center">生成getter等方法</td><td style="text-align:center">generate</td><td style="text-align:center">ctrl + L</td></tr><tr><td style="text-align:center">在下生成空白一行</td><td style="text-align:center">Start New Line</td><td style="text-align:center">Shift + Enter</td></tr><tr><td style="text-align:center">在上生成空白一行</td><td style="text-align:center">Start New Line Before Current</td><td style="text-align:center">Ctrl+ Shift + Ctrl</td></tr><tr><td style="text-align:center">完成该行——添加末尾分号+换到下行</td><td style="text-align:center">Complete Current Statement</td><td style="text-align:center">ctrl + shift + enter</td></tr><tr><td style="text-align:center">剪切改行（可当成删除改行使用）</td><td style="text-align:center">Cut</td><td style="text-align:center">ctrl + X</td></tr><tr><td style="text-align:center">工程中跳转指定class</td><td style="text-align:center">Navigate-class</td><td style="text-align:center">Ctrl + M</td></tr><tr><td style="text-align:center">新建</td><td style="text-align:center">Main Menu-File-New</td><td style="text-align:center">Ctrl + N</td></tr><tr><td style="text-align:center">关闭当前标签页</td><td style="text-align:center">Editor Tabs - Close</td><td style="text-align:center">Ctrl + W</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>未改变的快捷键设置</p><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">英文描述</th><th style="text-align:center">快捷键</th></tr></thead><tbody><tr><td style="text-align:center">格式化代码</td><td style="text-align:center">Reformat Code</td><td style="text-align:center">ctrl + alt + L</td></tr><tr><td style="text-align:center">根据上下文完成动作（导包）</td><td style="text-align:center">Show Context Actions</td><td style="text-align:center">Alt + enter</td></tr><tr><td style="text-align:center">优化import导入</td><td style="text-align:center">Optimize lmports</td><td style="text-align:center">Shift + Ctrl + O</td></tr><tr><td style="text-align:center">插入生成模板(psvm)</td><td style="text-align:center">Insert Live Template</td><td style="text-align:center">Ctrl + J</td></tr><tr><td style="text-align:center">打开设置面板</td><td style="text-align:center">open settings</td><td style="text-align:center">Ctrl + alt + s</td></tr><tr><td style="text-align:center">统一修改变量名</td><td style="text-align:center">Main Menu - Refactor- Rename</td><td style="text-align:center">Shift + F6</td></tr><tr><td style="text-align:center">搜索指定Class</td><td style="text-align:center">Main Menu-Navigate-class</td><td style="text-align:center">Ctrl + M</td></tr><tr><td style="text-align:center">重写方法</td><td style="text-align:center">override Methods</td><td style="text-align:center">Ctrl + o</td></tr></tbody></table><p>▲、以上以windows设置为模板修改</p><h2 id="生成类注释-文件注释"><a class="markdownIt-Anchor" href="#生成类注释-文件注释"></a> <a href="%5Bhttps://blog.csdn.net/qq_34581118/article/details/78409782#%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A%5D(https://blog.csdn.net/qq_34581118/article/details/78409782#%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A)">生成类注释、文件注释</a></h2><blockquote><p>没弄图， 主要是按照<a href="%5Bhttps://blog.csdn.net/qq_34581118/article/details/78409782#%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A%5D(https://blog.csdn.net/qq_34581118/article/details/78409782#%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A)">idea生成类注释和方法注释的正确方法</a>配置的</p></blockquote><h3 id="生成类注释"><a class="markdownIt-Anchor" href="#生成类注释"></a> 生成类注释</h3><ol><li>打开Preferences</li><li>Editor -&gt; File and Code Templates -&gt; Files -&gt; Class</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != "")package $&#123;PACKAGE_NAME&#125;;#end</span><br><span class="line">#parse("File Header.java")</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@program</span>: $&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span>: $&#123;description&#125;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>: MrLi</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span>: $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;HOUR&#125;:$&#123;MINUTE&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $</span>&#123;NAME&#125; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成方法注释"><a class="markdownIt-Anchor" href="#生成方法注释"></a> 生成方法注释</h3><ol><li>打开Preferences</li><li>Editor -&gt; Live Templates -&gt; 点击右边加号为自己添加一个Templates Group -&gt; 然后选中自己的Group-&gt;再次点击加号添加Live Templates</li><li><a href="http://xn--c1h978l9vlkycv0b31ip06ax0emv6bxteeq1b.No" target="_blank" rel="noopener">记得要把最下面的提示▲.No</a> applicable contexts yet.Define-&gt;设置为java</li><li>然后在Edit variables里面添加参数和返回值的自动取值</li></ol><p>按上述步骤设置完后就可以使用了： 在方法上面直接输入<code>/ + 你设置的Abbreviation快捷键 + tab</code>键就直接生成了 （我设置的是<code>/ + q + tab</code>）</p><p>神秘密码(Template text中填的):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">** </span><br><span class="line">* @Description: $description$ </span><br><span class="line">* @Param: $params$ </span><br><span class="line">* @Return: $returns$ </span><br><span class="line">* @Author: MrLi</span><br><span class="line">* @Date: $date$ </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="intellij-idea-报错error-java-不支持发行版本5"><a class="markdownIt-Anchor" href="#intellij-idea-报错error-java-不支持发行版本5"></a> Intellij idea 报错：Error : java 不支持发行版本5</h2><p>解决方案： <a href="https://blog.csdn.net/qq_22076345/article/details/82392236" target="_blank" rel="noopener">https://blog.csdn.net/qq_22076345/article/details/82392236</a></p><h2 id="intellij-idea-神器居然还有这些小技巧"><a class="markdownIt-Anchor" href="#intellij-idea-神器居然还有这些小技巧"></a> <a href="https://blog.csdn.net/kl28978113/article/details/80305974" target="_blank" rel="noopener">Intellij IDEA 神器居然还有这些小技巧</a>[转]</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;idea配置自定义快捷键-生成注释&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#idea配置自定义快捷键-生成注释&quot;&gt;&lt;/a&gt; IDEA配置——自定义快捷键、生成注释&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;以前因为上JAVA课，还
      
    
    </summary>
    
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>重拾Java笔记</title>
    <link href="https://nymrli.top/2020/05/15/%E9%87%8D%E6%8B%BEJava%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2020/05/15/重拾Java笔记/</id>
    <published>2020-05-15T02:22:04.000Z</published>
    <updated>2020-08-04T16:20:06.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重拾java笔记"><a class="markdownIt-Anchor" href="#重拾java笔记"></a> 重拾Java笔记</h1><blockquote><p>工作主要用Java, 因此开始准备Java基础再补补。根据<a href="http://www.monkey1024.com/javaseroute" target="_blank" rel="noopener">小猴子1024-JAVA基础</a>整理笔记</p></blockquote><h2 id="命名规范"><a class="markdownIt-Anchor" href="#命名规范"></a> <a href="https://www.jianshu.com/p/511cc270400f" target="_blank" rel="noopener">命名规范:</a></h2><blockquote><p>没怎么写， 所以一直忘， 这次写在最前面， 便于翻阅。</p></blockquote><p>大驼峰命名（UpperCamelCase）：<strong>每个单词的第一个字母大写</strong>，其他字母小写。e.g.MyException</p><p>小驼峰命名（lowerCamelCase）：如果仅有一个单词，那么所有字母全部小写，如果是两个及以上的单词组成的名称，那么除了第一个单词是全部小写外，其他都是的首字母大写，其他字母小写。e.g.getMyName</p><hr><p>1.1 包的命名</p><p>包的命名由全部小写的单词组成。一般使用公司的域名的作为自己程序包的唯一前缀，使用倒域名规则，例如：com.baidu.项目名，然后针对每个具体的模块在区分每个模块包名，例如：论坛模块的整体包名：<code>com.baidu.项目名.tribune</code>(域名倒写)</p><p>1.2 类的命名</p><p>类的命名遵循大驼峰命名的规则</p><p>1.3 接口的命名</p><p>接口命名遵循大驼峰命名的规则，以大写的I开头，表示这是一个接口，以able或ible截尾。</p><p>1.4 变量命名</p><p>变量的命名遵循小驼峰命名的规则，其中控件的变量建议使用控件缩写+逻辑名称的格式，例如：</p><p>1.5 常量的命名</p><p>常量名称的每个单词都大写，并且每个单词之间通过下划线（_）连接，例如：</p><p>1.6 方法的命名</p><p>方法的命名遵循小驼峰命名的规则，以动词+名词的方式组成，例如初始化view：initView()。</p><p>1.7 资源文件命名</p><p>全部小写，并通过下划线连接。</p><p>1.7.1 布局文件的命名</p><p>作者：summer_七七<br>链接：<a href="https://www.jianshu.com/p/511cc270400f" target="_blank" rel="noopener">https://www.jianshu.com/p/511cc270400f</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><h2 id="class与文件名"><a class="markdownIt-Anchor" href="#class与文件名"></a> class与文件名:</h2><blockquote><p>在一个Java文件里面，可以声明多个class，但是只能声明一个public class</p></blockquote><ul><li>如果使用class来声明类，文件名可以是任何合法的文件名称，文件名不需要和Class类一致</li><li>如果采用public class来声明class，那么文件名必须和类名一致</li></ul><p>结论: 使用javac命令所编译出的<strong>class文件</strong>的名称<strong>跟java的文件名没有关系</strong>，而是<strong>跟类名一致</strong>。</p><h2 id="函数传参"><a class="markdownIt-Anchor" href="#函数传参"></a> 函数传参:</h2><ul><li>如果参数是基本数据类型, 是会生成一个新的形参</li><li>如果参数是引用数据类型(不包括封装数据类型), 那么会生成该对象的引用（类、 接口类型、 <u>数组类型</u>、 枚举类型、 注解类型、 字符串型）==&gt;引用数据类型变量，调用方法时作为参数是按<strong>引用传递</strong>的</li></ul><p>参看: <a href="https://www.cnblogs.com/maskwolf/p/9972982.html" target="_blank" rel="noopener">Java中的基本数据类型和引用数据类型的区别</a></p><h2 id="代码块的分类"><a class="markdownIt-Anchor" href="#代码块的分类"></a> 代码块的分类</h2><p>使用{}括起来的代码被称为代码块，根据其位置和声明的不同可以分为下面4种：</p><ul><li><strong>局部代码块</strong>，在方法中出现，限定变量生命周期，及早释放，提高内存利用率</li><li><strong>构造代码块</strong>，在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</li><li><strong>静态代码块</strong>， 在类中方法外出现，并加上static修饰；用于给<strong>类进行初始化，在加载的时候就执行</strong>，并且只执行一次。一般用于加载驱动。</li><li><strong>同步代码块</strong>(后面多线程部分会讲解)</li></ul><h3 id="执行顺序"><a class="markdownIt-Anchor" href="#执行顺序"></a> 执行顺序:</h3><p>1.<strong>静态代码块</strong>，随着类加载而加载,且只执行一次<br>2.<strong>构造代码块</strong>，每创建一个对象就会执行一次，优先于构造方法执行<br>3.<strong>构造方法</strong>，每创建一个对象就会执行一次</p><h2 id="this指针"><a class="markdownIt-Anchor" href="#this指针"></a> this指针</h2><p>▲注意点: 在构造函数中调用该对象的另一个构造方法时,  this(实参)必须写在最前面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//构造方法</span><br><span class="line">//需求：在创建日期对象的时候，默认的日期是:1970-1-1</span><br><span class="line">MyDate()&#123;</span><br><span class="line">    //通过this调用有参的构造方法</span><br><span class="line">    this(1970,1,1);//必须出现在第一行，否则将编译报错</span><br><span class="line">    //构造方法不能这样调用</span><br><span class="line">    //MyDate(1970,1,1);Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承问题"><a class="markdownIt-Anchor" href="#继承问题"></a> 继承问题：</h2><p>静态代码块Fu<br>静态代码块Zi<br>构造代码块Fu<br>构造方法Fu<br>构造代码块Zi<br>构造方法Zi</p><p>分析：<br>1.系统将Fu.class和Zi.class分别加载到方法区的内存里面，<strong>静态代码</strong>会随着.class文件一块<strong>加载到方法区</strong>里面，所以先打印出了静态代码块中的内容。<br>2.<strong>构造代码块优先于构造方法执行</strong>，父类初始化之前，所以打印出父类中的构造代码块和构造方法中的内容。</p><h2 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态：</h2><blockquote><p>在工作当中尽量面向抽象编程，不要面向具体编程，即合理利用多态——<strong>SOLID原则</strong>中依赖倒置：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。换言之，要针对接口编程，而不是针对实现编程。</p></blockquote><p><strong>多态的优点</strong></p><ul><li>提高程序的扩展性</li><li>降低代码之间的耦合</li></ul><p><strong>用法</strong></p><ul><li>向上转型：上面代码中子类向父类型进行转换，是<strong>自动类型转换</strong>。</li><li>向下转型： 父类向子类型转换，是<strong>强制类型转换</strong>。</li></ul><h2 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h2><p>重写，也叫做覆盖，当父类中的方法无法满足子类需求时，子类可以将父类的方法进行重写编写来满足需求。比如孩子继承了父亲的房子，可以将房子重新装修。<br>方法重写的条件：</p><ul><li>两个类必须是继承关系</li><li>必须具有相同的方法名，相同的返回值类型，相同的参数列表.</li><li>重写的方法不能比被重写的方法拥有更低的访问权限。</li><li>重写的方法不能比被重写的方法抛出更宽泛的异常。(关于异常后面的章节再讲。)</li><li>私有的方法不能被重写。</li><li>构造方法无法被重写，因为构造方法无法被继承。</li><li>静态的方法不存在重写。</li><li>重写指的是成员方法，和成员变量无关。</li></ul><h2 id="super关键字"><a class="markdownIt-Anchor" href="#super关键字"></a> Super关键字:</h2><p>什么时候使用super？</p><ul><li>子类和父类中都有某个数据，例如，子类和父类中都有name这个属性。如果要再子类中访问父类中的name属性，需要使用super。例1</li><li>子类重写了父类的某个方法（假设这个方法名叫m1），如果在子类中需要调用父类中的m1方法时，需要使用super。例1</li><li>子类调用父类中的构造方法时，需要使用super。</li></ul><h2 id="object类之finalize方法"><a class="markdownIt-Anchor" href="#object类之finalize方法"></a> Object类之finalize方法</h2><blockquote><p>java对象如果没有更多的引用指向它（引用技术），则该java对象成为垃圾数据，等待垃圾回收器的回收，垃圾回收器在回收这个java对象之前会自动调用该对象的finalize方法==&gt;可以理解为解析函数</p></blockquote><h2 id="访问控制权限"><a class="markdownIt-Anchor" href="#访问控制权限"></a> 访问控制权限</h2><p><strong>方法访问控制权限</strong></p><table><thead><tr><th><strong>修饰词</strong></th><th><strong>本类</strong></th><th><strong>同一个包的类</strong></th><th><strong>子类</strong></th><th><strong>任何地方</strong></th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>default（默认）</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p><strong>方法访问控制权限</strong></p><p>▲。注意以上对类的修饰只有：public和default，内部类除外(只有内部类可以设置为protected/private)</p><p>priavte和public都比较好理解和记忆，这里就不演示了，主要演示一下不同包下的两个具有父子关系的类里面使用protected和default的区别。</p><h3 id="构造函数的权限问题"><a class="markdownIt-Anchor" href="#构造函数的权限问题"></a> 构造函数的权限问题:</h3><p>public是一个<a href="https://www.baidu.com/s?wd=%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">访问权限</a>（访问修复饰符）。一般<a href="https://www.baidu.com/s?wd=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">构造函数</a>可加可不加public。</p><ul><li>如果加上制public,就代表此类可以对外开放,其他的类可以继承它,外部也可以实例化该对象。</li><li>如果不加public,则默认的修饰词是default,表示可以被这个类的子类或者和这个类同包的类调用。</li></ul><p>除了这两个,你还可以添加private和default</p><p><strong>记录一下默认修饰符</strong>：</p><ul><li>类（class）: ****缺省****就是没有修饰符，在同一个包中的类中可见，在其他包中不能用import导入。</li><li>变量（variable）: <strong>缺省</strong>在同一个包中可见，子类不在一个包中，子类中也不可见</li><li>方法(method)：<strong>缺省</strong>在同一个包中可见，子类不在一个包中，子类中也不可见</li><li>接口（interface）： <strong>缺省</strong>同一个包中可见<ul><li>Java的interface中，成员变量的默认修饰符为：public static final；方法的默认修饰符，方法的默认修饰符是：public abstract（接口中的方法只能使用<strong>public</strong>和<strong>abstract</strong>修饰符 ）==&gt; <strong>接口只是对一类事物属性和行为的更高次抽象；对修改关闭，对扩展开放，可以说是java中开闭原则的一种体现吧。</strong></li></ul></li></ul><h2 id="final关键字"><a class="markdownIt-Anchor" href="#final关键字"></a> <strong>Final关键字:</strong></h2><blockquote><p>特点为确定不可变</p></blockquote><ul><li>final修饰的类无法被继承。</li><li>final修饰的方法无法被重写。</li><li>final修饰的局部变量，一旦赋值，不可再改变。</li><li>final修饰的成员变量必须初始化值。</li></ul><h2 id="static关键字"><a class="markdownIt-Anchor" href="#static关键字"></a> static关键字</h2><h3 id="static的作用"><a class="markdownIt-Anchor" href="#static的作用"></a> static的作用</h3><ul><li>static可以修饰变量，被static修饰的变量叫做静态变量，<u>静态变量在类加载阶段赋值，并且只赋值一次</u>。请看例1</li><li>static可以修饰方法，被static修饰的方法叫做静态方法，<strong>不用创建对象就能能直接访问该方法</strong>，即使用类名.静态方法名的方式。静态方法不能访问非静态的数据，静态方法不能使用this。请看例2</li><li>static可以定义静态语句块，<u>静态语句块在类加载阶段执行，并且只执行一次，并且是自上而下的顺序执行，在构造方法之前执行</u>。请看例3</li></ul><p>static修饰的变量、方法、代码块都是隶属于**类(class)**级别的,跟对象无关。某一类物体如果可以被多个其他物体所共享，那么可以将这类物体使用static修饰。<br>比如wifi，多个人可以共同使用同一个wifi，所以wifi可以使用static修饰。手机是每人使用自己的，就不能用static修饰。</p><h2 id="抽象类的特点"><a class="markdownIt-Anchor" href="#抽象类的特点"></a> 抽象类的特点</h2><ul><li>抽象类无法被实例化，无法创建抽象类的对象。</li><li>虽然抽象类没有办法实例化，但是<strong>抽象类也有构造方法</strong>，该构造方法是给子类创建对象用的。这也算是多态的一种。</li><li>抽象类中不一定有抽象方法，但抽象方法必须出现在抽象类中。</li><li>抽象类中的子类可以是抽象类，如果不是抽象类的话必须对抽象类中的抽象方法进行重写。</li><li>抽象类和抽象方法不能被final修饰</li></ul><h2 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口：</h2><ul><li>接口中只能出现常量和抽象方法（jdk8之后可以有default方法）</li><li>接口里面<strong>没有构造方法</strong>，无法创建接口的对象</li><li>接口和接口之间支持多继承，即一个接口可以有多个父接口</li><li>一个类可以实现多个接口，即一个类可以有多个父接口</li><li>一个类如果实现了接口，那么这个类需要重写接口中所有的抽象方法（建议），如果不重写则这个类需要声明为抽象类（不建议）</li></ul><h2 id="equals"><a class="markdownIt-Anchor" href="#equals"></a> equals</h2><blockquote><p>== 两边如果是引用类型，则比较内存地址，地址相同则是true,反之则false.</p></blockquote><ul><li>Object中的equals方法比较的是两个引用的内存地址。</li><li>但是在现实的业务逻辑当中，不应该比较内存地址，<strong>应该比较地址里面的内容</strong>，所以需要对equals方法进行重写。</li></ul><p>==&gt;▲注意：在使用自己创建的类进行equals比较时，一定要先重写equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据需求规定重写equals方法</span></span><br><span class="line"><span class="comment">//s1.equals(s2);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Star)&#123;</span><br><span class="line">        Star s = (Star)obj;</span><br><span class="line">        <span class="keyword">if</span>(s.id == id &amp;&amp; s.name.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类的分类"><a class="markdownIt-Anchor" href="#内部类的分类"></a> 内部类的分类</h2><p>内部类，顾名思义就是在一个类的内部声明一个类。内部类主要分为：</p><ul><li>静态内部类</li><li>匿名内部类</li><li>成员内部类</li><li>局部内部类</li></ul><h2 id="异常的分类"><a class="markdownIt-Anchor" href="#异常的分类"></a> 异常的分类</h2><blockquote><p>异常: 指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止——JVM处理异常的方式是中断处理。</p></blockquote><p>异常主要分为：Error、一般性异常、RuntimeException</p><ul><li>Error(强制中断错误)：如果程序出现了Error，那么将无法恢复，只能重新启动程序，最典型的Error的异常是：OutOfMemoryError</li><li>Exception（一般性异常（<strong>编译时</strong>异常）：出现了这种异常必须在程序里面显示的处理，否则程序无法编译通过</li><li>RuntimeException（<strong>运行时</strong>异常）：此种异常可以不用显示的处理，例如被0除异常，java没有要求我们一定要处理。</li></ul><p><img src="http://www.monkey1024.com/wp-content/uploads/2017/04/1%E5%BC%82%E5%B8%B8%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="å¼å¸¸ç»§æ¿ç»æå¾"></p><h3 id="jvm是如何处理异常的"><a class="markdownIt-Anchor" href="#jvm是如何处理异常的"></a> JVM是如何处理异常的</h3><ul><li>main方法自己将该问题处理,然后继续运行</li><li>自己没有针对的处理方式,只有交给调用main的jvm来处理，jvm有一个默认的异常处理机制。例如上面出现的ArithmeticException，jvm在控制台里面打印出来了异常信息。</li></ul><p>大致流程: native method自己解决-&gt;交给Main解决-&gt;交给JVM解决</p><p>更好的讲解: <a href="https://www.bilibili.com/video/BV1A4411K7Gx?p=282" target="_blank" rel="noopener">B站视频</a></p><h3 id="throw和throws"><a class="markdownIt-Anchor" href="#throw和throws"></a> throw和throws</h3><p>throws</p><ul><li>用在方法声明后面，跟的是<strong>异常类名</strong>    <code>public void m1() throws Exception</code></li><li>可以跟多个异常类名，用逗号隔开</li><li>表示抛出异常，由<strong>该方法的调用者来处理</strong> (<strong>向上抛出指定异常</strong>)</li></ul><p>throw</p><ul><li>用在方法体内，跟的是<strong>异常对象名</strong>    ==&gt; <code>throw new Exception()</code></li><li>只能抛出一个异常对象名</li><li>表示抛出异常，由方法体内的语句处理，<strong>需要直接在此处解决异常</strong>(在当前语句抛出指定异常)</li></ul><h3 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h3><p>1.自定义异常类一般都是以Exception结尾，说明该类是一个异常类<br>2.自定义异常类，必须的继承Exception或者RuntimeException<br>- 继承Exception：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try…catch<br>- 继承RuntimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个空参数的构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个带异常信息的构造方法</span></span><br><span class="line"><span class="comment">     * 查看源码发现，所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的构造方法，让父类来处理这个异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="catch"><a class="markdownIt-Anchor" href="#catch"></a> catch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (ArithmeticException | ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="comment">// 出现多个异常,采取同样的处理措施</span></span><br><span class="line">            <span class="comment">// 多个异常见用 | 隔开</span></span><br><span class="line">            <span class="comment">// 多个异常必须是平级关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串的不可变性"><a class="markdownIt-Anchor" href="#字符串的不可变性"></a> 字符串的不可变性</h2><h3 id="string类不能被继承"><a class="markdownIt-Anchor" href="#string类不能被继承"></a> String类不能被继承</h3><p>通过源码可以看到String类前面加了final修饰，因此String类是不能够被继承的。将其设置为不能被继承的原因是为了减少歧义。</p><h3 id="字符串string的不可变性"><a class="markdownIt-Anchor" href="#字符串string的不可变性"></a> 字符串（String）的不可变性</h3><p>String创建好之后值是不可以被改变的，这里指的是<strong>在堆中的字符串的值</strong>是不可以被改变。</p><p>String不可变的主要原因是其底层使用了一个final修饰的byte数组(jdk9之后版本中)，final修饰的变量是不能被改变的。在jdk8版本中，String底层使用的是final修饰的char数组。这个版本之间的变化。</p><h3 id="string-stringbuffer-stringbuilder"><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder"></a> String、StringBuffer、StringBuilder</h3><ul><li><p>拼接执行效率: <code>String &lt; StringBuffer &lt; StringBuilder</code></p></li><li><p>线程安全:</p><table><thead><tr><th></th><th>线程安全</th><th>原因</th></tr></thead><tbody><tr><td>String</td><td>安全</td><td>常量无线程安全问题</td></tr><tr><td>stringBuffer</td><td>安全</td><td>方法全为syncronized关键字修饰</td></tr><tr><td>stringbuilder</td><td>不安全</td><td>无</td></tr></tbody></table></li></ul><h3 id="字符串常量池"><a class="markdownIt-Anchor" href="#字符串常量池"></a> 字符串常量池</h3><p>我们声明的字符串会放到一个叫做字符串常量池的地方，这样可以减少内存的使用，字符串常量池是堆的一部分。</p><p>如果用<code>new String(&quot;monkey&quot;)</code>会在字符串常量池中再建一个monkey, 其实是浪费了内存。所以开发中建议使用String s = “monkey1024”;这种方式创建字符串对象，可以减少堆内存的使用。==&gt;<strong>比较两个字符串是否一致最好使用equals方法</strong>(看引用的内存地址是否一致)</p><p>详细请看: <a href="http://www.monkey1024.com/javase/481" target="_blank" rel="noopener">http://www.monkey1024.com/javase/481</a></p><p><img src="/2020/05/15/重拾Java笔记/JVM%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="JVM内存图"></p><h2 id="string-stringbuffer-stringbuilder-2"><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder-2"></a> String、StringBuffer、StringBuilder</h2><ul><li>如果需要对字符串进行频繁拼接的话，建议使用StringBuffer或者StringBuilder</li></ul><h3 id="stringbuffer"><a class="markdownIt-Anchor" href="#stringbuffer"></a> StringBuffer</h3><ul><li>StringBuffer是一个字符串缓冲区，如果需要频繁的对字符串进行拼接时，建议使用StringBuffer。</li><li>StringBuffer的底层是byte数组（jdk9之后），jdk8中底层是char数组，如果没有明确设定，则系统会默认创建一个长度为16的byte类型数组，在使用时如果数组容量不够了，则会通过数组的拷贝对数组进行扩容，所以在使用StringBuffer时最好预测并手动初始化长度，这样能够减少数组的拷贝，从而提高效率。</li></ul><h3 id="stringbuilder和stringbuffer的区别"><a class="markdownIt-Anchor" href="#stringbuilder和stringbuffer的区别"></a> StringBuilder和StringBuffer的区别</h3><p>通过API可以看到StringBuilder和StringBuffer里面的方法是一样的，那他们有什么区别呢？<br>StringBuffer是jdk1.0版本中加入的，是<strong>线程安全的</strong>，效率低<br>StringBuilder是jdk5版本加入的，是<strong>线程不安全的</strong>，效率高</p><h2 id="什么是自动拆箱和自动装箱"><a class="markdownIt-Anchor" href="#什么是自动拆箱和自动装箱"></a> 什么是自动拆箱和自动装箱？</h2><ul><li>自动装箱：把基本类型转换为包装类类型</li><li>自动拆箱：把包装类类型转换为基本类型</li></ul><h2 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h2><blockquote><p>接口Collection: 由三个接口组成——List / Set / Queue</p></blockquote><h3 id="集合的由来"><a class="markdownIt-Anchor" href="#集合的由来"></a> 集合的由来</h3><p>数组长度是固定,如果要改变数组的长度需要创建新的数组将旧数组里面的元素拷贝过去，使用起来不方便。<br>java给开发者提供了一些集合类，能够存储任意长度的对象，长度可以随着元素的增加而增加,随着元素的减少而减少，使用起来方便一些。</p><h3 id="集合类的一些特点"><a class="markdownIt-Anchor" href="#集合类的一些特点"></a> 集合类的一些特点</h3><ul><li>List：里面存放的数据是有顺序的，可以存放重复的数据。</li><li>Set：里面存放的数据是没有顺序的，不能存放重复的数据。</li><li>Queue：是一个队列，里面的数据是先进先出，可以存放重复的数据。</li></ul><h3 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3><ul><li>区别1:<ul><li>数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值</li><li>集合只能存储引用数据类型(对象)，如果存储基本数据类型时，会自动装箱变成相应的包装类</li></ul></li><li>区别2:<ul><li>数组长度是固定的,不能自动增长</li><li>集合的长度的是可变的,可以根据元素的增加而自动增长</li></ul></li></ul><h2 id="list两个子类的特点"><a class="markdownIt-Anchor" href="#list两个子类的特点"></a> List两个子类的特点</h2><p>ArrayList:</p><ul><li>底层数据结构是数组，查询快，增删慢。</li></ul><p>LinkedList:</p><ul><li>底层数据结构是链表，查询慢，增删快。</li></ul><p>ArrayList和LinkedList的区别</p><ul><li>ArrayList底层是数组结果,查询和修改快</li><li>LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢</li><li>共同点:都是<strong>线程不安全的</strong></li></ul><h3 id="arraylist线程安全的方案"><a class="markdownIt-Anchor" href="#arraylist线程安全的方案"></a> ArrayList线程安全的方案</h3><p>如果使用ArrayList需要考虑线程安全的问题，有两种方案：</p><ul><li><p>可以使用Collections工具类中的synchronizedList方法可以将ArrayList变成线程安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(new ArrayList());</span><br></pre></td></tr></table></figure></li><li><p>使用java.util.concurrent包下面的CopyOnWriteArrayList，使用方式跟ArrayList一样</p></li></ul><h2 id="集合数组的互转"><a class="markdownIt-Anchor" href="#集合数组的互转"></a> <a href="http://www.monkey1024.com/javase/565" target="_blank" rel="noopener">集合数组的互转</a></h2><p>集合转数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line">list.add(<span class="string">"c"</span>);</span><br><span class="line">list.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当集合转换数组时,数组长度如果是&lt;=集合的size时,转换后的数组长度等于集合的size</span></span><br><span class="line"><span class="comment">//如果数组的长度大于了size,分配的数组长度就和你指定的长度一样</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> String[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">for</span>(String s : array)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组转集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意转换后的集合不能调用其add方法向里面添加数据，否则会报出UnsupportedOperationException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组转集合</span></span><br><span class="line">String[] arr = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line"><span class="comment">//将数组转换成集合</span></span><br><span class="line">List&lt;String&gt; listArray = Arrays.asList(arr);                </span><br><span class="line"><span class="comment">//不能添加</span></span><br><span class="line"><span class="comment">//listArray.add("d");                                    </span></span><br><span class="line">System.out.println(listArray);</span><br><span class="line"><span class="comment">//通过这种方式将listArray转换成真正的ArrayList</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(listArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Arrays.asList((T… a))的源码可以看到，这里面返回的ArrayList是在Arrays类里面定义的一个内部类，并非java.util包下的ArrayList。</span></span><br></pre></td></tr></table></figure><p>基本数据类型的数组转换成集合,会将整个数组当作一个对象转换，下面程序将会打印出list的对象地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;            </span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; list = Arrays.asList(arr);            </span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// ==&gt;[[I@282ba1e]</span></span><br></pre></td></tr></table></figure><p>==&gt;▲.将数组转换成集合,数组中的数据必须是引用数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;                    </span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(arr);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// ==&gt;[11, 22, 33, 44, 55]</span></span><br></pre></td></tr></table></figure><h2 id="collection集合"><a class="markdownIt-Anchor" href="#collection集合"></a> Collection集合</h2><h3 id="set的特点"><a class="markdownIt-Anchor" href="#set的特点"></a> Set的特点</h3><p>Set里面存储的元素不能重复，没有索引，存取顺序不一致。</p><p><strong>▲.这里需要注意：在向HashSet中存放自定义类型对象时，一定要<a href="###HashCode%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8">重写hashCode和equals方法</a></strong>，原因是无重复的话需要比较， 所以得。</p><h3 id="treeset简介"><a class="markdownIt-Anchor" href="#treeset简介"></a> TreeSet简介</h3><p>TreeSet的特点是可以对存放进去的元素<strong>进行排序</strong>。</p><p>∴ 使用TreeSet存储自定义类型。这里还是存储之前定义的Person对象，<strong>需要实现Comparable接口并且重写compareTo方法</strong>，先根据name的字典顺序排序，然后再根据年龄进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.nymrli.day07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.scene.PerspectiveCamera;</span><br><span class="line"><span class="keyword">import</span> javafx.util.converter.PercentageStringConverter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: testIDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Set测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: MrLi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2020-05-16 09:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">day07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        boolean b1 = hs.add("a");</span></span><br><span class="line"><span class="comment">//        System.out.println(hs);</span></span><br><span class="line"><span class="comment">//        boolean c1 = hs.add("b");</span></span><br><span class="line"><span class="comment">//        System.out.println(hs);</span></span><br><span class="line"><span class="comment">//        for (String s : hs) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(s);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Q1:</span></span><br><span class="line"><span class="comment">//        HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        Random random = new Random();</span></span><br><span class="line"><span class="comment">//        while (hashSet.size() &lt; 10) &#123;</span></span><br><span class="line"><span class="comment">//            int num = random.nextInt(20);</span></span><br><span class="line"><span class="comment">//            hashSet.add(num);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        for (Integer i : hashSet) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(i);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Q2;Treeset</span></span><br><span class="line">        TreeSet&lt;Person&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"cl"</span>, <span class="number">30</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"qsy"</span>, <span class="number">25</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"sxh"</span>, <span class="number">30</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"ll"</span>, <span class="number">15</span>));</span><br><span class="line">        <span class="keyword">for</span> (Person p : ts) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(getName(), person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nameSame = <span class="keyword">this</span>.name.compareTo(o.name);</span><br><span class="line">        <span class="keyword">if</span> (nameSame != <span class="number">0</span>)&#123;     <span class="comment">// 如果name不相等</span></span><br><span class="line">            <span class="comment">// 当compareTo方法返回正数的时候，系统将元素存储到右边，所以集合存取顺序一致</span></span><br><span class="line">            <span class="keyword">return</span> nameSame;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map接口概述"><a class="markdownIt-Anchor" href="#map接口概述"></a> Map接口概述</h3><blockquote><p>map中的元素是以键-值的方式存在的，通过键可以获取到值，键是不可以重复的，跟地图比较像，通过一个坐标就可以找到具体的位置。该接口由三个类实现: <code>HashMap / HashTable / AbstractMap</code></p></blockquote><p>▲与前两个相比，添加元素的函数由<code>add =&gt; put</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">day08_Map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashmap.put(<span class="string">"Cl"</span>, <span class="number">18</span>);</span><br><span class="line">        hashmap.put(<span class="string">"GJQ"</span>, <span class="number">15</span>);</span><br><span class="line">        hashmap.put(<span class="string">"SXH"</span>, <span class="number">10</span>);</span><br><span class="line">        hashmap.put(<span class="string">"HSR"</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(hashmap);</span><br><span class="line">        System.out.println(hashmap.containsValue(<span class="string">"CL"</span>));</span><br><span class="line">        System.out.println(hashmap.containsKey(<span class="string">"GJQ"</span>));</span><br><span class="line">        System.out.println(<span class="string">"------"</span>);</span><br><span class="line">        Collection&lt;Integer&gt; values = hashmap.values();</span><br><span class="line">        System.out.println(values);</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        Integer res = hashmap.remove(<span class="string">"SXH"</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map的遍历</span></span><br><span class="line">        <span class="comment">// 方法一</span></span><br><span class="line">        Set&lt;String&gt; keySet = hashmap.keySet();</span><br><span class="line">        Iterator&lt;String&gt; iterator = keySet.iterator();</span><br><span class="line">        System.out.println(keySet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"Key: "</span> + key + <span class="string">" value: "</span> + hashmap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"---------"</span>);</span><br><span class="line">        <span class="comment">// 上述的代替写法</span></span><br><span class="line"><span class="comment">//        for (String key : keySet) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Key:" + key + "value: " + hashmap.get(key));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二</span></span><br><span class="line">        <span class="comment">// Map中的键和值被封装成了Entry对象,并存储在Set集合中，通过entrySet()可以获取到这个Set集合。</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = hashmap.entrySet();</span><br><span class="line"><span class="comment">//        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entriesIterator = entries.iterator();</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; en : entries) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Key:"</span> + en.getKey() + <span class="string">" value: "</span> + en.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"_______________"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedHashMap</strong></p><ul><li>LinkedHashMap的特点：存取顺序一致</li></ul><p><strong>TreeMap</strong></p><ul><li>TreeMap的特点：可以对存储的元素进行排序</li></ul><h4 id="hashmap和hashtable的区别"><a class="markdownIt-Anchor" href="#hashmap和hashtable的区别"></a> HashMap和Hashtable的区别</h4><ul><li>Hashtable是JDK1.0版本出现的,是线程安全的,效率低，不可以存储null键和null值</li><li>HashMap是JDK1.2版本出现的，是线程不安全,效率高，可以存储null键和null值</li></ul><h3 id="collection工具"><a class="markdownIt-Anchor" href="#collection工具"></a> Collection工具</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list);</span><br><span class="line">Collections.shuffle(list);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">Collections.binarySearch(list, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h3 id="collection总结"><a class="markdownIt-Anchor" href="#collection总结"></a> Collection总结</h3><ul><li><p><strong>List(存取有序,有索引,可以重复)</strong></p><ul><li>ArrayList<br>底层是数组实现的,线程不安全,查找和修改快,增和删比较慢</li><li>LinkedList<br>底层是链表实现的,线程不安全,增和删比较快,查找和修改比较慢</li><li>Vector<br>底层是数组实现的,线程安全的,无论增删改查都慢</li></ul></li></ul><p>如果查找和修改多,用ArrayList<br>如果增和删多,用LinkedList<br>如果都多,用ArrayList</p><ul><li><p><strong>Set(存取无序,无索引,不可以重复)</strong></p><ul><li>HashSet<br>底层是哈希算法实现</li><li>LinkedHashSet<br>底层是链表实现,可以保证元素唯一,存取顺序一致</li><li>TreeSet<br>底层是二叉树算法实现，可以排序，存储自定义类型时需要注意实现Comparable接口并重写compareTo方法</li></ul><p>一般在开发的时候不需要对存储的元素排序,所以在开发的时候大多用HashSet,HashSet的效率比较高.TreeSet在面试的时候比较多</p></li><li><p><strong>Map</strong></p><ul><li>HashMap<br>底层是哈希算法</li><li>LinkedHashMap<br>底层是链表，存取顺序一致</li><li>TreeMap<br><strong>底层是二叉树算法</strong>，可以排序</li></ul><p>开发中用HashMap比较多</p></li></ul><h2 id="hashcode"><a class="markdownIt-Anchor" href="#hashcode"></a> HashCode</h2><h3 id="hashcode方法的作用"><a class="markdownIt-Anchor" href="#hashcode方法的作用"></a> HashCode方法的作用</h3><p>在HashSet中的元素是不能重复的，jvm可以通过equals方法来判断两个对象是否相同，假设自定义一个Person类里面有10个成员变量，每调用一次equals方法需要做10次if判断分别比较这10个成员变量是否相等，如果想HashSet中存放100个对象，那就会做1000次if判断，数据量大的话会严重影响性能。<br>要解决这个问题的话可以这样做，将一些特征相似或相近的对象归类放到一起给他们一个编号，在做equals判断时，先比较这些编号，编号相同的话再去比较equals，这样可以减少一些比较次数。这个编号可以通过HashCode方法获得。<strong>HashCode方法的作用就是将对象进行分类，然后获取到编号值。</strong><br>举个例子，图书馆里面的书都是分好类的，想找《java编程思想》这本书，先找到计算机类的书架，然后再去找就行，倘若图书馆里面的书籍没有分类，那找起来就如大海捞针。</p><h3 id="如何重写hashcode"><a class="markdownIt-Anchor" href="#如何重写hashcode"></a> 如何重写HashCode</h3><p>HashCode算法决定了对象的归类，如果算法编写的不好可能不会对性能有所提升。在编写时最好可以让对象均匀的散列开，这里假设可以将对象分为10个种类，那么每个种类中存放的对象的数量最好不要相差太多。</p><p>将Person的name和age属性都加上了，可以将Person进行细分，开发中建议使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    result = prime * result + age;</span><br><span class="line">    result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么上面的prime的值是31？其实这个值改成别的也可以，只不过定义为31之后有一些好处：</p><ul><li>31是一个质数,质数是能被1和自己本身整除的数，并且这个数不大也不小</li><li>31这个数好算,2的五次方-1,2向左移动5位</li></ul><h3 id="关于重写hashcode方法的一些说明"><a class="markdownIt-Anchor" href="#关于重写hashcode方法的一些说明"></a> 关于重写HashCode方法的一些说明</h3><ul><li>任何时候对同一对象多次调用 hashCode 方法，都必须一直返回同样的整数。</li><li>如果两个对象通过 equals(Object) 方法来比较相等，那么这两个对象的 hashCode的值必须相等。</li><li>如果两个对象通过 equals(Object) 方法比较结果不等，可以相等也可以不相等。</li></ul><h2 id="properties类"><a class="markdownIt-Anchor" href="#properties类"></a> Properties类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> FileReader(<span class="string">"store.txt"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String k : set) &#123;</span><br><span class="line">            String value = properties.getProperty(k);</span><br><span class="line">            System.out.println(k + <span class="string">"="</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">storeInto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileWriter fileWriter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.setProperty(<span class="string">"陈力"</span>, <span class="string">"18"</span>);</span><br><span class="line">            properties.setProperty(<span class="string">"SQY"</span>, <span class="string">"19"</span>);</span><br><span class="line">            properties.store(fileWriter, <span class="string">"Save data"</span>);</span><br><span class="line">            fileWriter = <span class="keyword">new</span> FileWriter(<span class="string">"store.txt"</span>);</span><br><span class="line">            fileWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型的概念"><a class="markdownIt-Anchor" href="#泛型的概念"></a> 泛型的概念</h2><p>在编写集合相关代码时在eclipse里面总有一些黄色警告，在不使用注解的情况下，使用泛型之后，就不会有这些黄色警告了。<br>通过API可以看到Collection,List,ArrayList,这几个类里面都有,这个就是泛型，里面的E可以是任何引用数据类型，使用泛型指明了数据类型之后，这个集合里面只能存储这种数据类型的对象。</p><p>不使用泛型时，要进行多次类型强制转换。如<code>List list = new ArrayList();</code></p><p>使用泛型: <code>List&lt;Person&gt; list = new ArrayList&lt;Person&gt;();</code></p><h3 id="泛型的优点"><a class="markdownIt-Anchor" href="#泛型的优点"></a> <strong>泛型的优点</strong></h3><ul><li>可以统一集合中的数据类型，提高安全性</li><li>可以减少强制类型转换</li></ul><h3 id="自定义泛型"><a class="markdownIt-Anchor" href="#自定义泛型"></a> 自定义泛型</h3><p>通过JDK的源码可以看到，泛型一般写的都是或者，里面的T和E就是表示使用者指定的类型。可以自己定义一个使用泛型的类</p><h3 id="泛型通配符"><a class="markdownIt-Anchor" href="#泛型通配符"></a> 泛型通配符</h3><p>在实际工作当中，有可能通过调用某个方法来接受一个返回值List的数据，这样就不<strong>太好确定返回值中的数据类型</strong>，这样可以使用泛型通配符&lt;?&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//=号右边可能是通过调用某个方法返回的List</span></span><br></pre></td></tr></table></figure><p>使用泛型通配符限定子类或者父类</p><ul><li><code>? extends E</code><br>向下限定，E及其子类，可以存储当前类型的子类</li><li><code>? super E</code><br>向上限定，E及其父类，可以存储当前类型的父类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ? extends E 向下限定，E及其子类，可以存储当前类型的子类 </span></span><br><span class="line"><span class="comment"> * ? super E 向上限定，E及其父类，可以存储当前类型的父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Student&gt; studentList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//因为studentList中存放的Student是Person类的子类，所以可以将studentList放入personList中</span></span><br><span class="line">        personList.addAll(studentList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合框架中的三种迭代方式删除数据"><a class="markdownIt-Anchor" href="#集合框架中的三种迭代方式删除数据"></a> 集合框架中的三种迭代方式删除数据</h2><ul><li><p>普通for循环,可以删除,注意让索引做自减运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,普通for循环删除,索引做自减运算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"b"</span>.equals(list.get(i))) &#123;</span><br><span class="line">        list.remove(i);        </span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常</p></li><li><p>增强for循环不能删除</p></li></ul><h2 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h2><blockquote><p><strong>注意：如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰符 返回值类型 方法名(数据类型…  变量名)&#123;&#125;</span></span><br><span class="line"><span class="comment">//可变参数其实是一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> ... arr)</span> </span>&#123;            </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解:</h2><blockquote><p>之前也看过一些Java-Spring Boot的视频, 有些讲的详细的会去讲源码，然后当时就是看到有很多注解， 就不懂是什么意思， 形成了理解障碍。 所以这次特地又去了解了一下</p></blockquote><p>Spring-Boot的入口函数是由<code>@SpringBootApplication</code>注解的main，无疑<code>@SpringBootApplication</code>这个注解是非常重要的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), <span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述一共七个注解，一共可以分成三类： 元注解、配置注解、Component组件注解。之前学的时候就是被这么多注解给吓到了，而且课上对注解的讲解也特别小， 所以一直感觉注解是个高深莫测的东西。</p><ul><li><p>元注解讲解： <a href="https://www.cnblogs.com/kingsonfu/p/10634174.html" target="_blank" rel="noopener">Java 元注解</a></p><ul><li><code>@Inherited</code>使用该注解的注解父类的子类可以继承父类的注解。请注意，<u>如果使用注释类型来注释除类之外的任何内容，则此元注释类型不起作用</u>。 还要注意，这个元注释只会导致从超类继承注释; 已实现的接口上的注释无效。</li></ul></li><li><p>配置注解源码讲解: <a href="https://www.bilibili.com/video/BV1gW411W76m/?p=7&amp;t=428" target="_blank" rel="noopener">尚硅谷SpringBoot顶尖教程(springboot之idea版spring boot)</a></p><ul><li><p><code>@AutoConfigurationPackage</code>由<code>@Import({Registrar.class})</code>注解，其中<code>Registrar</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));<span class="comment">// 后面第二个参数的结果是metadata中的所有包==&gt;即获得主配置类所在包及以下子包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将主配置类(<code>@SpringBootApplication</code>标注的类)所在包及下面子包里面的所有组件扫描到Spring容器中</p></li></ul></li></ul><p>注解（Annontion）是Java5开始引入的新特征。它提供了一种<strong>安全的类似注释的机制</strong>，用来将<strong>任何的信息或元数据</strong>（metadata）与程序元素（类、方法、成员变量等）进行关联。==&gt;类似注释，但能将内容传递给程序，对修饰对象有约束作用。</p><h2 id="io流"><a class="markdownIt-Anchor" href="#io流"></a> IO流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次调用的时候会读取一个字节的数据，如果read返回结果是-1，则说明读取完毕</span></span><br><span class="line"><span class="keyword">int</span> temp;<span class="comment">//保存当前读取的字节数据</span></span><br><span class="line"><span class="comment">//将读取的数据赋值给temp，然后再判断</span></span><br><span class="line"><span class="keyword">while</span> ((temp = f.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用fileseparator解决不同系统的路径问题"><a class="markdownIt-Anchor" href="#使用fileseparator解决不同系统的路径问题"></a> 使用File.separator解决不同系统的路径问题</h3><p>在windos中的文件路径是以&quot;“来分隔<br>在linux中的文件路径是以”/&quot;来分隔<br>如果将上面代码部署到linux中会读取不到文件，为了保证编写的代码跨平台需要使用java.io包下的File.separator来替代文件路径的分隔符，如下：<code>fis = new FileInputStream(&quot;file&quot; + File.separator + &quot;monkey.txt&quot;);</code></p><h3 id="文件io读写fileinputstream"><a class="markdownIt-Anchor" href="#文件io读写fileinputstream"></a> 文件IO读写FileInputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">copy_io</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\10630\\Desktop\\TODO\\ok.yml"</span>);</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"good.txt"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> newFile = file.createNewFile();</span><br><span class="line">                System.out.println(<span class="string">"Yes, Create it~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"good.txt"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] arr= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line">            <span class="keyword">while</span> ((length = fis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// f.read(arr)和f.read()不一样， </span></span><br><span class="line">                <span class="comment">// f.read(arr)会一次性读取arr大小的数据， 然后长度用length来记录读取了多少字符</span></span><br><span class="line">                <span class="comment">// write写的时候， 将数组arr中length写入文件</span></span><br><span class="line">                <span class="comment">// 在while中输出了length的大小， 为1024， 842</span></span><br><span class="line">                fos.write(arr, <span class="number">0</span>, length);</span><br><span class="line">                System.out.println(length);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用缓冲流进行文件拷贝bufferedinputstream"><a class="markdownIt-Anchor" href="#使用缓冲流进行文件拷贝bufferedinputstream"></a> 使用缓冲流进行文件拷贝BufferedInputStream</h3><p>Java中提供了<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>缓冲流用来读取和写出， <code>BufferedInputStream</code>读取时会创建一个长度为8192的byte类型数组，程序一次读取8192个字节数据到数组中 使用缓冲流之后就不用再自定义byte类型数组了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bufferStream_io</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedInputStream ` = <span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\10630\\Desktop\\TODO\\ok.yml"</span>));</span><br><span class="line">            bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">            <span class="comment">// 其实不存在会自动创建, 不需要下面的代码</span></span><br><span class="line">            File f = <span class="keyword">new</span> File(<span class="string">"text.txt"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> newFile = f.createNewFile();</span><br><span class="line">                System.out.println(<span class="string">"创建成功~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp;</span><br><span class="line">            <span class="keyword">while</span> ((tmp = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.monkey1024.com/javase/608" target="_blank" rel="noopener">使用自定义数组和buffer的图解</a></p><h3 id="jdk7的新写法"><a class="markdownIt-Anchor" href="#jdk7的新写法"></a> jdk7的新写法</h3><p>在jdk7中新加入了AutoCloseable接口，IO流中的类都实现了这个接口，这样在读取或者写出操作结束之后，系统会自动close相关资源，开发者不需要再手动close了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\10630\\Desktop\\TODO\\ok.yml"</span>)); BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"auto.txt"</span>));) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> ((tmp = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用字符流解决乱码问题filereader"><a class="markdownIt-Anchor" href="#使用字符流解决乱码问题filereader"></a> 使用字符流解决乱码问题FileReader</h2><blockquote><p>字符流FileReader主要用来读取字符的IO流，使用字符流读取文本文件可以解决乱码问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader_io</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">"G:\\C与C++、\\java\\testIDEA\\src\\testForChinests.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">while</span> ((c = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用缓冲流bufferedreader可以一次读取一行的文字"><a class="markdownIt-Anchor" href="#使用缓冲流bufferedreader可以一次读取一行的文字"></a> 使用缓冲流<strong>BufferedReader</strong>可以一次读取一行的文字：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">try</span> (BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"G:\\C与C++、\\java\\testIDEA\\src\\testForChinests.txt"</span>))) &#123;</span><br><span class="line">          String s;</span><br><span class="line">          <span class="keyword">while</span> ((s = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">              System.out.print(s);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">      <span class="keyword">try</span>(FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"newword.txt"</span>);)&#123;</span><br><span class="line">          fw.write(<span class="string">"我喜欢学习java"</span>);</span><br><span class="line">          fw.write(<span class="number">32</span>);       <span class="comment">// 空格</span></span><br><span class="line">          fw.write(<span class="number">97</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span>(BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"newword.txt"</span>));)&#123;</span><br><span class="line">          bw.write(<span class="string">"我喜欢打篮球"</span>);</span><br><span class="line">          bw.newLine();<span class="comment">//换行</span></span><br><span class="line">          bw.write(<span class="string">"我喜欢踢足球"</span>);</span><br><span class="line">          bw.flush();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ul><li>BufferedWriter、BufferedInputStream内的参数都是原有的FileWrite、FileInputStream，实际上使用了装饰模式（设计模式）</li><li>BufferedWriter、BufferedReader多了writeLine、readLine方法</li></ul><p><strong>装饰者设计模式的优点：</strong><br>不用修改被装饰对象的源码，装饰者与被装饰者耦合度不高。</p><h3 id="转换流"><a class="markdownIt-Anchor" href="#转换流"></a> <a href="http://www.monkey1024.com/javase/624" target="_blank" rel="noopener">转换流</a>——编码格式转换InputStreamReader：</h3><blockquote><p>字节-&gt;字符</p></blockquote><p>如果要解决上面问题，需要使用InputStreamReader和OutputStreamWriter指明文本文件的编码，这两个类都属于字符流，可以将字节流输出为字符流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用FileInputStream读取文本内容，然后通过InputStreamReader和指定的编码将字符转换为字节</span></span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"utf-8.txt"</span>), <span class="string">"utf-8"</span>));</span><br><span class="line">            BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">                    <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"gbk.txt"</span>), <span class="string">"gbk"</span>));) &#123;</span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">while</span>((msg = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        bw.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException | FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中再FileInputStream对象上使用了InputStreamReader装饰，从而将字节转换为字符，之后再InputStreamReader对象上又使用了BufferedReader将字符进行缓冲，从而提高。==&gt;都有reader</p><h2 id="输出指定目录下的所有文件名称"><a class="markdownIt-Anchor" href="#输出指定目录下的所有文件名称"></a> 输出指定目录下的所有文件名称</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputAllFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> File file = getFile();</span><br><span class="line">        getListFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getListFiles</span><span class="params">(File f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> File[] files = f.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">'\t'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(files[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (files[i].isDirectory()) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                getListFiles(files[i]);</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">getFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"请输入要遍历的目录: "</span>);</span><br><span class="line">        <span class="keyword">final</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> String next = scanner.nextLine();</span><br><span class="line">            <span class="comment">//　next()不会吸取字符前/后的空格/Tab键，只吸取字符，开始吸取字符（字符前后不算）直到遇到空格/Tab键/回车截止吸取；</span></span><br><span class="line">            <span class="comment">//　nextLine()吸取字符前后的空格/Tab键，回车键截止。</span></span><br><span class="line">            <span class="keyword">final</span> File file = <span class="keyword">new</span> File(next);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"输出的路径错误, 请重新输入"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"请输入一个文件夹路径"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> file;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列化和反序列化"><a class="markdownIt-Anchor" href="#序列化和反序列化"></a> 序列化和反序列化</h2><blockquote><ul><li>在工作中有可能遇到多台机器远程通信的情况，如果要将机器A中的某个java对象传输到机器B上面，需要将这个java对象转换为字节序列然后进行传输。将对象转换为字节序列的过程叫做序列化，反之叫做反序列化。</li><li>使用序列化还可以将一个对象保存到硬盘中，然后再通过反序列化将该对象读取到内存里面。</li></ul><p>一个对象如果支持序列化，需要实现Serializable的接口，<u>这个接口中没有任何方法</u>，实现该接口后，JVM会给这个对象做特殊待遇</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Student s = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream zhangsan = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"zhangsan"</span>))) &#123;</span><br><span class="line">            <span class="comment">// try()括号中，如果是多句， 则加;， 单句不需要加;</span></span><br><span class="line">            <span class="comment">// ObjectOutputStream也是一个装饰模式</span></span><br><span class="line">            zhangsan.writeObject(s);</span><br><span class="line">            zhangsan.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个类实现Serializable接口后，系统会给每个对象一个序列化版本号，当这个类的源码被修改后，系统会重新分配一个新的序列化版本号，这样做的好处就是保证序列化和反序列化的对象内容一致。例如将一个对象序列化到硬盘之后，修改这个对象所对应类的源码，在进行反序列化是就会报出InvalidClassException异常。如果手动编写序列化版本号之后，就不会出现这个异常了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动生成序列化版本号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">716323668524282676L</span>;</span><br></pre></td></tr></table></figure><h3 id="transient关键字"><a class="markdownIt-Anchor" href="#transient关键字"></a> transient关键字</h3><p>如果不希望将Student类中的age属性序列化，可以使用transient声明该属性，在序列化时将忽略这个属性。<code>transient private int age;</code></p><h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h2><h3 id="三种创建方式"><a class="markdownIt-Anchor" href="#三种创建方式"></a> 三种创建方式</h3><ul><li><p>继承Thread类， 重写run方法</p><ul><li>优点:可以直接使用Thread类中的方法,代码简单</li><li>缺点:继承Thread类之后就不能继承其他的类</li></ul></li><li><p>实现runnable接口， 重写run方法</p><ul><li>优点:即时自定义类已经有父类了也不受影响，因为可以实现多个接口</li><li>缺点:在run方法内部需要获取到当前线程的Thread对象后才能使用Thread中的方法</li></ul></li><li><p>实现Callable接口创建线程</p><ul><li><p>优点：可以获取返回值，可以抛出异常</p></li><li><p>缺点：代码编写较为复杂</p><p>1.自定义一个类实现java.util.concurrent包下的Callable接口<br>2.重写call方法<br>3.将要在线程中执行的代码编写在call方法中<br>4.创建<code>ExecutorService</code>线程池<br>5.将自定义类的对象放入线程池里面<br>6.获取线程的返回结果<br>7.关闭线程池，不再接收新的线程，未执行完的线程不会被关闭</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义一个类实现Callable&lt;V&gt;接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 2.重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 3.将要执行的代码写在call方法中</span></span><br><span class="line">        <span class="comment">//返回一个随机数</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> num = r.nextInt(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread_callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//4.创建ExecutorService线程池</span></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.将自定义类的对象放入线程池里面</span></span><br><span class="line">        <span class="comment">//开启两个线程</span></span><br><span class="line">        Future&lt;Integer&gt; result1 = exec.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        Future&lt;Integer&gt; result2 = exec.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断线程是否计算完毕</span></span><br><span class="line">        <span class="keyword">while</span> (!result1.isDone() &amp;&amp; !result2.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"等待线程计算完毕"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.获取线程的返回结果</span></span><br><span class="line">        Integer i1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i1 = result1.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Integer i2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i2 = result2.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(i1);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.关闭线程池，不再接收新的线程，未执行完的线程不会被关闭</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3><p>线程池是初始化一个多线程应用程序过程中创建一个<strong>线程集合</strong>，即一次创建多个线程，然后在需要执行新的任务时直接去这个线程集合中获取，而不是重新创建一个线程。任务执行结束后，线程放回到池子中等待下一次的分配。</p><p><strong>线程池的作用</strong></p><p>解决创建单个线程耗费时间和资源的问题。</p><p><strong>创建线程池</strong></p><p>上面代码中演示了两种方式创建线程池</p><ul><li><code>Executors.newFixedThreadPool(int nThreads);</code><br>通过传入的int类型参数来指定创建线程池中的线程数，如果任务数量大于线程数量，则任务会进行等待。</li><li><code>Executors.newCachedThreadPool();</code><br>会根据需要创建新线程的线程池，如果线程池中的线程数量小于任务数时，会创建新的线程，线程池中的线程最大数量是Integer.MAX_VALUE，int类型的最大值。如果线程的处理速度小于任务的提交速度时，会不断创建新的线程来执行任务，这样有可能会因为创建过多线程而耗尽CPU 和内存资源。</li></ul><p>匿名内部类、labmbda表达式创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewWayCreateThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 匿名内部类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: MrLi        </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [args] </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Return</span>: void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/5/18 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    System.out.println( Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">                    System.out.println( getClass() + <span class="string">" "</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: labmbda表达式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: MrLi</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [args]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Return</span>: void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/5/18</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized同步方法与同步代码块"><a class="markdownIt-Anchor" href="#synchronized同步方法与同步代码块"></a> synchronized同步方法与同步代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> begin1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> end1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> begin2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> end2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LongTask ts = <span class="keyword">new</span> LongTask();</span><br><span class="line">        Thread t1 =<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            begin1 = System.currentTimeMillis();</span><br><span class="line">            ts.add();</span><br><span class="line">            end1 = System.currentTimeMillis();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//        new Thread(syncValue::add).start();</span></span><br><span class="line">             begin2 = System.currentTimeMillis();</span><br><span class="line">            ts.add();</span><br><span class="line">             end2 = System.currentTimeMillis();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(begin1 &gt; begin2)&#123;</span><br><span class="line">            begin = begin2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            begin = begin1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(end1 &gt; end2)&#123;</span><br><span class="line">            end = end1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            end = end2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"两个线程总共耗时："</span> + (end -begin) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public synchronized void add() &#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(3000L);</span></span><br><span class="line"><span class="comment">//            System.out.println("执行耗时任务");</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        num++;</span></span><br><span class="line"><span class="comment">//        System.out.println(num);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//两个线程总共耗时：6001ms</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">            System.out.println(<span class="string">"执行耗时任务"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个线程总共耗时：3001ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后将需要同步的代码放到synchronized代码块中，再次运行SynchronizedTest02类，打印结果是3秒，因为那段耗时较长的代码是在异步情况下运行，所以节省了一些时间。</p><p><strong>注意：多个线程在执行synchronized同步代码块时，代码块括号里面可以传入任意对象，但一定要保证多个线程访问的是同一个对象。</strong>(这里代码只有一个实例, 这个实例的obj是相同的)</p><h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2><h3 id="饿汉式"><a class="markdownIt-Anchor" href="#饿汉式"></a> 饿汉式</h3><ul><li>构造方法私有化</li><li>创建当前类对象</li><li>对外提供公共的访问方法将SingletonHungary对象暴露给外部</li></ul><h3 id="懒汉式"><a class="markdownIt-Anchor" href="#懒汉式"></a> 懒汉式</h3><ul><li>构造方法私有化</li><li>创建当前类的引用</li><li>对外提供公共的访问方法将SingletonHungary对象暴露给外部</li></ul><h3 id="单例模式的案例runtime"><a class="markdownIt-Anchor" href="#单例模式的案例runtime"></a> 单例模式的案例Runtime</h3><p>java.lang包下的Runtime类使用了单例模式，使用该类可以执行windows系统里面的一些命令，例如：mspaint（打开画图软件），shutdown（关机）等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Runtime rt = Runtime.getRuntime();</span><br><span class="line">    rt.exec(<span class="string">"mspaint"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用timer类来实现定时任务"><a class="markdownIt-Anchor" href="#使用timer类来实现定时任务"></a> 使用Timer类来实现定时任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Timer t = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">//        t.schedule(new TimerTask() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//                final Date date = new Date();</span></span><br><span class="line"><span class="comment">//                System.out.println(date);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;, new SimpleDateFormat("yyyy-MM-dd hh:mm:ss SSS").parse("2017-07-03 18:09:00 000"), 5000);</span></span><br><span class="line">        <span class="comment">//第一个参数接收TimerTask对象，即上面创建的MyTimerTask</span></span><br><span class="line">        <span class="comment">//第二参数的Date类型是定时任务执行的开始时间</span></span><br><span class="line">        <span class="comment">//第三个参数指定定时任务每隔多少毫秒执行一次</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        t.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lambda表达式和匿名内部类"><a class="markdownIt-Anchor" href="#lambda表达式和匿名内部类"></a> Lambda表达式和匿名内部类</h2><blockquote><p>使用lambda表达式的前提是： 必须为<strong>函数式接口</strong>（有且只有一个抽象方法的接口，可以用<code>@FunctionalInterface</code>,接口中可以包含默认、静态、私有方法）</p></blockquote><ul><li>匿名内部类会生成一个<code>xxxx$1.class</code>文件， 而lambda表达式不会生成</li><li>lambda 有延迟加载的效果，从而不存在性能浪费——优化日志</li></ul><p>From: <a href="https://www.bilibili.com/video/BV1A4411K7Gx?p=417" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1A4411K7Gx?p=417</a></p><h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2><p>获得字节码class的三种方式</p><ul><li>Source源代码阶段=&gt;<code>Class.forName(&quot;全类名&quot;)</code><ul><li>多用于配i文件，捋类名定义在配文件中。读取文件，加载类</li></ul></li><li>Class类对象阶段=&gt;<code>类名.class</code><ul><li>多用于参数的传递</li></ul></li><li>Runtime运行阶段=&gt;<code>对象.getClass()</code><ul><li>多用于对象的获取字节码的方式</li></ul></li></ul><p>▲结论: 同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1： Class.forName</span></span><br><span class="line">Class cls1 = Class.forName(<span class="string">"top.nymrli.day17_reflect.Person"</span>);</span><br><span class="line">System.out.println(cls1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// way2:</span></span><br><span class="line">Class&lt;Person&gt; cls2 = Person.class;</span><br><span class="line">System.out.println(cls2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// way3:</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Class cls3 = person.getClass();</span><br><span class="line">System.out.println(cls3);</span><br><span class="line"></span><br><span class="line">System.out.println(cls3 == cls2);</span><br><span class="line">System.out.println(cls1 == cls2);</span><br></pre></td></tr></table></figure><h3 id="class对象功能"><a class="markdownIt-Anchor" href="#class对象功能"></a> Class对象功能:</h3><p>获取功能:</p><ol><li><p>获得成员变量</p><ul><li><p><code>Filed[] getFields()</code>——获得public修饰的字段</p></li><li><p><code>Field getField(String name)</code>——获得所有字段，无视修饰符</p></li><li><p><code>Field[] getDeclaredFields()</code></p></li><li><p><code>Field getDeclaredField(String name)</code></p></li></ul></li><li><p>获得构造方法</p><ul><li><p><code>Constructor constructor = cls1.getConstructor(String name);</code></p></li><li><p><code>Constructor[] constructors = cls1.getConstructors();</code></p></li><li><p><code>Constructor declaredConstructor = cls1.getDeclaredConstructor(String name);</code></p></li><li><p><code>Constructor[] declaredConstructors = cls1.getDeclaredConstructors();</code></p></li></ul></li><li><p>获得成员方法</p><ul><li><p><code>Method method = cls1.getMethod(String name);</code></p></li><li><p><code>Method[] methods = cls1.getMethods();</code></p></li><li><p><code>Method declaredMethod = cls1.getDeclaredMethod(String name);</code></p><p><code>Method[] declaredMethods = cls1.getDeclaredMethods();</code></p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Class cls1 = Class.forName(<span class="string">"top.nymrli.day17_reflect.Person"</span>);</span><br><span class="line">System.out.println(cls1);</span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Field name = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    name = cls1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">Object o = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);<span class="comment">// private私有方法, 暴力反射</span></span><br><span class="line">    o = name.get(p);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(o);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    name.set(p, <span class="string">"cl"</span>);</span><br><span class="line">    o = name.get(p);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(o);</span><br></pre></td></tr></table></figure><h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例：</h3><p>*需求：写一个“框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法</p><p><strong>实现：</strong><br>1.配置文件<br>2.反射</p><p><strong>步骤</strong><br>1.捋需要创建的对象的全类名和需要执行的方法定义在配置文件中<br>2.在程序中加载读取配置文件<br>3.使用反射技术来加载类文件进内存<br>4.创建对象<br>5.执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="comment">//    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        ClassLoader classLoader = Example.class.getClassLoader();</span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">"prop.properties"</span>);</span><br><span class="line">        properties.load(is);</span><br><span class="line"></span><br><span class="line">        String className = properties.getProperty(<span class="string">"className"</span>);</span><br><span class="line">        String classMethod = properties.getProperty(<span class="string">"classMethod"</span>);</span><br><span class="line"></span><br><span class="line">        Class cls = Class.forName(className);</span><br><span class="line">        <span class="comment">// 直接newInstance在java 9已被弃用</span></span><br><span class="line">        Object o = cls.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        Method method = cls.getMethod(classMethod);</span><br><span class="line">        method.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的加载与初始化"><a class="markdownIt-Anchor" href="#类的加载与初始化"></a> 类的加载与初始化</h2><p><strong>类的加载过程</strong>：</p><p>加载–&gt;链接（验证、准备（为静态量开辟空间并赋予初始值）、解析（将class中的符号引用转变为运行时的地址的直接引用））–&gt;初始化</p><p>为类的静态变量赋值，然后执行类的初始化（static）语句<br><strong>初始化的详细过程</strong>：</p><ul><li>如果类还没有被加载和链接，那就先进行加载和链接</li><li>如果类存在父类，并且父类还没有初始化，那就先初始化直接父类</li><li>如果类中存在初始化语句，顺序执行初始化语句</li></ul><p><strong>class初始化时机</strong></p><ul><li>创建类的实例（四种方式）</li><li>访问类中的某个静态变量，或者对静态变量进行赋值</li><li>主动调用类的静态方法</li><li>Class.forName（“包类名&quot;）完成子类的初始化，也会完成对本类的初始化（接口例外）</li><li>该类是程序引导入口（mian入口或者test入口）</li></ul><p><strong>双亲委派机制</strong></p><blockquote><p>bootstrap的加载过程是用c来完成的，在java中输出bootstrap加载器结果为null</p></blockquote><p>加载类的过程： 不断将加载任务交给父类加载器，是个递归的过程。如果父类能够加载，那么就加载，如果不能加载，那么就交给子类去加载。</p><ul><li>bootstrap：提供核心环境 、extension classloader负责拓展内容、application classloader负责程序运行期间自己写的class对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这边是递归的过程，会去找父加载器， 直至parent为null即用bootstrap加载</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/15/重拾Java笔记/%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpg" alt="类加载"></p><p>作用：</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心的JAVA语言环境遭受破坏</li></ul><h2 id="正则匹配"><a class="markdownIt-Anchor" href="#正则匹配"></a> 正则匹配</h2><p><img src="/2020/05/15/重拾Java笔记/java%E6%AD%A3%E5%88%99.jpg" alt="java正则"></p><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除&quot;\r\n&quot;之外的任何单个字符。若要匹配包括&quot;\r\n&quot;在内的任意字符，请使用诸如&quot;[\s\S]&quot;之类的模式。</td></tr><tr><td>*</td><td>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配&quot;z&quot;和&quot;zoo&quot;。* 等效于 {0,}。</td></tr><tr><td>+</td><td>一次或多次匹配前面的字符或子表达式。例如，&quot;zo+&quot;与&quot;zo&quot;和&quot;zoo&quot;匹配，但与&quot;z&quot;不匹配。+ 等效于 {1,}。</td></tr><tr><td>?</td><td>零次或一次匹配前面的字符或子表达式。例如，&quot;do(es)?“匹配&quot;do&quot;或&quot;does&quot;中的&quot;do”。? 等效于 {0,1}。</td></tr></tbody></table><p><strong>方法说明：</strong></p><ul><li><strong>matches</strong> ：尝试将<u>整个</u>区域与模式匹配。</li><li><strong>lookingAt</strong>： 方法虽然不需要整句都匹配，但是需要从<em>第一个字符</em>开始匹配。</li><li><strong>find</strong>： 尝试查找与该模式匹配的输入序列的下一个子序列。</li><li><strong>find(int start）</strong>：重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</li><li>替换： replaceFirst 替换首次匹配，replaceAll 替换所有匹配。</li></ul><p>▲强调: 使用<code>group()</code>之前一定得指定个以上的匹配方法</p><p><strong>匹配模式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pattern compile = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    private static final int ALL_FLAGS = CASE_INSENSITIVE | MULTILINE |</span></span><br><span class="line"><span class="comment">            DOTALL | UNICODE_CASE | CANON_EQ | UNIX_LINES | LITERAL |</span></span><br><span class="line"><span class="comment">            UNICODE_CHARACTER_CLASS | COMMENTS;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="qjava-定义long和float为什么要加l和f"><a class="markdownIt-Anchor" href="#qjava-定义long和float为什么要加l和f"></a> Q:java 定义long和float为什么要加L和F？</h2><p>A:整形默认值为int，如果定义long 必须要加L来区分，浮点型默认值为double双精度，定义单精度float要加F来区分。</p><h2 id="java中suppresswarnings的作用"><a class="markdownIt-Anchor" href="#java中suppresswarnings的作用"></a> <a href="https://www.cnblogs.com/huanglog/p/11587077.html" target="_blank" rel="noopener">Java中@SuppressWarnings的作用</a></h2><p>A:作用：告诉编译器忽略指定的警告，不用在编译完成后出现警告信息。如<code>@SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)</code>等同于@SuppressWarnings(“unchecked”, “deprecation”)</p><h2 id="输出变量类型python中type关键字"><a class="markdownIt-Anchor" href="#输出变量类型python中type关键字"></a> 输出变量类型——Python中type关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Object o)</span></span>&#123;  <span class="comment">//通过反射来获取变量类型方法</span></span><br><span class="line"><span class="keyword">return</span> o.getClass().toString(); <span class="comment">//使用int类型的getClass()方法</span></span><br><span class="line">    <span class="comment">// return o.getClass().getName(); //使用int类型的getClass()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>▲. 基本数据类型无效， 如int， 但可以查看包装数据类型。</p><h2 id="jdbc链接mysql"><a class="markdownIt-Anchor" href="#jdbc链接mysql"></a> JDBC链接MYSQL</h2><h3 id="maven的pomxml中的配置"><a class="markdownIt-Anchor" href="#maven的pomxml中的配置"></a> Maven的pom.xml中的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>top.nymrli.jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入mysql驱动jar包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="java文件内容"><a class="markdownIt-Anchor" href="#java文件内容"></a> java文件内容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1.加载驱动程序， 这个包名是固定的</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">// 2.创建连接</span></span><br><span class="line">        String url=<span class="string">"jdbc:mysql://localhost:3306/fortest?useSSL=false&amp;serverTimezone=UTC"</span>;</span><br><span class="line">        String username=<span class="string">"root"</span>;</span><br><span class="line">        String userpwd=<span class="string">"cl123123"</span>;</span><br><span class="line">        Connection conn = DriverManager.getConnection(url,username,userpwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.定义SQL语句</span></span><br><span class="line">        String table = <span class="string">"stu"</span>;</span><br><span class="line"><span class="comment">//        String sql = String.format("SELECT * FROM %s;", table);</span></span><br><span class="line">        String sql = String.format(<span class="string">"UPDATE %s set age = 50 where name = 'cl';"</span>, table);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取执行sql的对象</span></span><br><span class="line">        Statement stat = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.执行SQL语句</span></span><br><span class="line"><span class="comment">//        ResultSet resultSet = stat.executeQuery(sql);</span></span><br><span class="line">        <span class="keyword">int</span> res = stat.executeUpdate(sql);</span><br><span class="line"><span class="comment">//        System.out.println(resultSet);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 查看执行结果</span></span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.释放资源</span></span><br><span class="line">        stat.close();</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DriverManager：驱动管理对象<br>Connection：数据库连接对象<br>statement：执行sql的对象<br>Resultset：结果集对象<br>Preparedstatement：执行sq1的对象roper</p><h2 id="sql操作"><a class="markdownIt-Anchor" href="#sql操作"></a> SQL操作</h2><h3 id="分页操作"><a class="markdownIt-Anchor" href="#分页操作"></a> 分页操作</h3><p>语法：limit开始索引，每页查询的记录数<br>注：索引从0开始<br><code>公式：开始索引=（当前页码-1）*每页查询的记录数</code>即 <code>index = (nowPageNum - 1) * pageSize</code></p><h3 id="插入语句"><a class="markdownIt-Anchor" href="#插入语句"></a> 插入语句：</h3><p><code>insert into `train`.`student` (`name`, `age`) values (&quot;gb&quot;, 19);</code></p><p>▲注意这边是<code>`train`.`student`</code>，如果写成<code>`train.student`</code>是会找不到表的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重拾java笔记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重拾java笔记&quot;&gt;&lt;/a&gt; 重拾Java笔记&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;工作主要用Java, 因此开始准备Java基础再补补。根据&lt;a href=&quot;htt
      
    
    </summary>
    
    
      <category term="java" scheme="https://nymrli.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>华为春招4.29笔试题</title>
    <link href="https://nymrli.top/2020/04/29/%E5%8D%8E%E4%B8%BA%E6%98%A5%E6%8B%9B4-29%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>https://nymrli.top/2020/04/29/华为春招4-29笔试题/</id>
    <published>2020-04-29T14:43:54.000Z</published>
    <updated>2020-04-29T14:47:07.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="429三道笔试题"><a class="markdownIt-Anchor" href="#429三道笔试题"></a> 4.29三道笔试题：</h1><blockquote><p>做了其他大厂的笔试题后，好像确实华为的稍微简单点。只不过其他的笔试题是有模拟题的，华为的这三道题基本上都是DFS</p></blockquote><h2 id="a"><a class="markdownIt-Anchor" href="#a"></a> A：</h2><blockquote><p>带有重复元素的全排列问题，求不重复的排列数。以下做法50%, TLE了。正确做法是直接用公式计算</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">@Author: Mrli</span></span><br><span class="line"><span class="string">@Date: 2020-04-29 20:23:34</span></span><br><span class="line"><span class="string">@LastEditTime: 2020-04-29 21:24:40</span></span><br><span class="line"><span class="string">@Description: </span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">s = input().strip()</span><br><span class="line">ans = list(s)</span><br><span class="line">sz = len(s)</span><br><span class="line">res = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(depth)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> depth &gt; sz<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">if</span> depth == sz<span class="number">-1</span>:</span><br><span class="line">        enter = <span class="string">''</span>.join(ans)</span><br><span class="line">        <span class="keyword">if</span> enter <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            res.add(enter)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(sz):</span><br><span class="line">        swap(i, depth)</span><br><span class="line">        dfs(depth+<span class="number">1</span>)</span><br><span class="line">        swap(i, depth)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    tmp = ans[x]</span><br><span class="line">    ans[x] = ans[y]</span><br><span class="line">    ans[y] = tmp</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br><span class="line">print(len(res))</span><br></pre></td></tr></table></figure><h2 id="b"><a class="markdownIt-Anchor" href="#b"></a> B</h2><blockquote><p>求去掉K个字母，留下字典序最小的字符串。当时</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">@Author: Mrli</span></span><br><span class="line"><span class="string">@Date: 2020-04-29 19:01:55</span></span><br><span class="line"><span class="string">@LastEditTime: 2020-04-29 22:31:07</span></span><br><span class="line"><span class="string">@Description: </span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># 看错题, 以为是从开头去掉k个。一分钟写的过了40%</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># s = input().strip()</span></span><br><span class="line"><span class="comment"># n = int(input().strip())</span></span><br><span class="line"><span class="comment"># print( s[n:])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"># 第一次尝试, ''-&gt;加n-k个-&gt;   过10%</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 选择移除K个字母, 要使留下来的字符串字典序最小</span></span><br><span class="line"><span class="comment"># s = input().strip()</span></span><br><span class="line"><span class="comment"># n = int(input().strip())</span></span><br><span class="line"><span class="comment"># fans = s</span></span><br><span class="line"><span class="comment"># def dfs(ans, index, depth):</span></span><br><span class="line"><span class="comment">#     global fans</span></span><br><span class="line"><span class="comment">#     if index &gt;= len(s): return </span></span><br><span class="line"><span class="comment">#     if depth &gt; n: return</span></span><br><span class="line"><span class="comment">#     if depth == n:</span></span><br><span class="line"><span class="comment">#         if ans &lt;= fans:</span></span><br><span class="line"><span class="comment">#             fans = ans</span></span><br><span class="line"><span class="comment">#     print(ans + s[index])</span></span><br><span class="line"><span class="comment">#     dfs(ans + s[index], index+1, depth + 1)</span></span><br><span class="line"><span class="comment">#     dfs(ans, index+1, depth)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># dfs('', 0, 0)</span></span><br><span class="line"><span class="comment"># print(fans)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">当时dfs('', 0, 0)的写法报了点错, 以为不能这么写, 于是换成s中去k个</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># s = input().strip()</span></span><br><span class="line"><span class="comment"># sz = len(s)</span></span><br><span class="line"><span class="comment"># n = int(input().strip())</span></span><br><span class="line"><span class="comment"># fans = ''.join('z' for i in range(sz))</span></span><br><span class="line"><span class="comment"># def dfs(ans, index, depth):</span></span><br><span class="line"><span class="comment">#     global fans</span></span><br><span class="line"><span class="comment">#     if index &gt;= sz: return </span></span><br><span class="line"><span class="comment">#     if depth == n:</span></span><br><span class="line"><span class="comment">#         if ans &lt;= fans:</span></span><br><span class="line"><span class="comment">#             fans = ans</span></span><br><span class="line"><span class="comment">#     # print(ans[0:index] + ans[index+1:])</span></span><br><span class="line"><span class="comment">#     dfs(ans[0:index] + ans[index+1:], index+1, depth + 1)</span></span><br><span class="line"><span class="comment">#     dfs(ans, index+1, depth)</span></span><br><span class="line"><span class="comment"># dfs(s, 0, 0)</span></span><br><span class="line"><span class="comment"># print(fans)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第三次尝试, 重新接回第一种到n-k个数时结束的写法. 考完以后写出来的. 但不知道能不能过全部样例</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">s = input().strip()</span><br><span class="line">sz = len(s)</span><br><span class="line">n = int(input().strip())</span><br><span class="line"></span><br><span class="line">fans = <span class="string">''</span>.join(<span class="string">'z'</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(sz))<span class="comment"># 初始化为最大</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(ans, index)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> fans</span><br><span class="line">    <span class="keyword">if</span> index == sz: <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">if</span> len(ans) == sz-n:</span><br><span class="line">        <span class="comment"># print(ans, fans, ans &lt;= fans)</span></span><br><span class="line">        <span class="keyword">if</span> ans &lt;= fans:</span><br><span class="line">            fans = ans</span><br><span class="line">    </span><br><span class="line">    dfs(ans + s[index], index+<span class="number">1</span>)</span><br><span class="line">    dfs(ans, index+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dfs(<span class="string">''</span>, <span class="number">0</span>)</span><br><span class="line">print(fans)</span><br></pre></td></tr></table></figure><h2 id="c"><a class="markdownIt-Anchor" href="#c"></a> C:</h2><blockquote><p>k, n, r： 有k个硬币， n个城市， r条单向边</p><p>要求在硬币足够的情况下的最短距离</p><p>▲一开始以为是<strong>dijistra+硬币数(第二指标)<strong>判断，但是实际情况并不是在求</strong>最短距离的情况下的硬币数</strong>，而是在硬币充足的情况下最短距离是多少===&gt;实际就变成了一个非常简单的DFS</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Mrli</span></span><br><span class="line"><span class="comment"> * @Date: 2020-04-29 19:05:27</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-29 21:12:04</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> T[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int d[MAXN];</span></span><br><span class="line"><span class="comment">// int cost[MAXN];</span></span><br><span class="line"><span class="keyword">int</span> mans = INF;</span><br><span class="line"><span class="keyword">bool</span> haveans = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, n ,r;        <span class="comment">// 硬币数、城市数、道路数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dijistra做法的尝试 */</span></span><br><span class="line"><span class="comment">// void dijistra(int s)&#123;</span></span><br><span class="line"><span class="comment">//     d[s] = 0;</span></span><br><span class="line"><span class="comment">//     cost[s] = 0;</span></span><br><span class="line"><span class="comment">//     for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        int u = -1, MIN = INF;</span></span><br><span class="line"><span class="comment">//        for (int j = 1; j &lt;= n; j++) &#123;</span></span><br><span class="line"><span class="comment">//           if (visited[j] == false &amp;&amp; d[j] &lt; MIN)&#123;</span></span><br><span class="line"><span class="comment">//               u = j;</span></span><br><span class="line"><span class="comment">//               MIN = d[j];</span></span><br><span class="line"><span class="comment">//           &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if ( u == -1) return;</span></span><br><span class="line"><span class="comment">//        visited[u] = true;</span></span><br><span class="line"><span class="comment">//         // 保证路径最短, 再确定硬币</span></span><br><span class="line"><span class="comment">//     //    for (int v = 1; v &lt;= n; v++) &#123;</span></span><br><span class="line"><span class="comment">//     //       if (visited[v] == false &amp;&amp; dist[u][v] != INF)&#123;</span></span><br><span class="line"><span class="comment">//     //           if ( dist[u][v] + d[u] &lt; d[v] )&#123;</span></span><br><span class="line"><span class="comment">//     //               d[v] = dist[u][v] + d[u];</span></span><br><span class="line"><span class="comment">//     //               cost[v] = T[u][v] + cost[u]; </span></span><br><span class="line"><span class="comment">//     //           &#125;else if (dist[u][v] + d[u] == d[v])&#123;</span></span><br><span class="line"><span class="comment">//     //               if( cost[u] + T[u][v] &lt; cost[v] )&#123;</span></span><br><span class="line"><span class="comment">//     //                   cost[v] = cost[u] + T[u][v];</span></span><br><span class="line"><span class="comment">//     //               &#125;</span></span><br><span class="line"><span class="comment">//     //           &#125;</span></span><br><span class="line"><span class="comment">//     //       &#125;</span></span><br><span class="line"><span class="comment">//     //    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         // 保证硬币足够的情况下</span></span><br><span class="line"><span class="comment">//         for (int v = 1; v &lt;= n; v++) &#123;</span></span><br><span class="line"><span class="comment">//           if (visited[v] == false &amp;&amp; dist[u][v] != INF)&#123;</span></span><br><span class="line"><span class="comment">//               if ( T[u][v] + cost[u] &lt; cost[v] )&#123;   </span></span><br><span class="line"><span class="comment">//                   if ( dist[u][v] + d[u] &lt; d[v] )&#123;</span></span><br><span class="line"><span class="comment">//                        d[v] = dist[u][v] + d[u];</span></span><br><span class="line"><span class="comment">//                   &#125;</span></span><br><span class="line"><span class="comment">//                   cost[v] = T[u][v] + cost[u]; </span></span><br><span class="line"><span class="comment">//               &#125;else if ( T[u][v] + cost[u] == cost[v] )&#123;</span></span><br><span class="line"><span class="comment">//                   if( dist[u][v] + d[u] &lt; d[v] )&#123;</span></span><br><span class="line"><span class="comment">//                         d[v] = dist[u][v] + d[u];</span></span><br><span class="line"><span class="comment">//                         // cost[v] = T[u][v] + cost[u]; </span></span><br><span class="line"><span class="comment">//                   &#125;</span></span><br><span class="line"><span class="comment">//               &#125;</span></span><br><span class="line"><span class="comment">//           &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 思考过用BFS */</span></span><br><span class="line"><span class="comment">// void bfs(int s)&#123;</span></span><br><span class="line"><span class="comment">//     queue&lt;int&gt; q;</span></span><br><span class="line"><span class="comment">//     q.push(s);</span></span><br><span class="line"><span class="comment">//     visited[s] = true;</span></span><br><span class="line"><span class="comment">//     while (!q.empty())&#123;</span></span><br><span class="line"><span class="comment">//         int u = q.front();</span></span><br><span class="line"><span class="comment">//         q.pop();</span></span><br><span class="line"><span class="comment">//         for (int v = 0; v &lt; n; v++) &#123;</span></span><br><span class="line"><span class="comment">//            if ( visited[v] == false &amp;&amp; dist[u][v] != INF)&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> ans, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( u == n )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( q &lt;= k)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &lt;= mans)&#123;</span><br><span class="line">                mans = ans;</span><br><span class="line">            &#125;</span><br><span class="line">            haveans = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">2</span>; v &lt;= n; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( visited[v] == <span class="literal">false</span> &amp;&amp; dist[u][v] != INF)&#123;</span><br><span class="line">            visited[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; "next: " &lt;&lt;v &lt;&lt;endl; </span></span><br><span class="line">            dfs(v, ans + dist[u][v], q + T[u][v]);</span><br><span class="line">            visited[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fill(dist[<span class="number">0</span>], dist[<span class="number">0</span>] + MAXN* MAXN, INF);</span><br><span class="line">    fill(T[<span class="number">0</span>], T[<span class="number">0</span>] + MAXN* MAXN, INF);</span><br><span class="line">    <span class="comment">// fill(d, d+MAXN, INF);</span></span><br><span class="line">    <span class="comment">// fill(cost, cost+MAXN, INF);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; n &gt;&gt; r;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">       <span class="keyword">int</span> s, d, w, cost;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; d &gt;&gt; w &gt;&gt; cost;</span><br><span class="line">       dist[s][d] = w;</span><br><span class="line">       T[s][d] = cost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (haveans) <span class="built_in">cout</span> &lt;&lt; mans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//    for (int j = 1; j &lt;= n; j++) &#123;</span></span><br><span class="line">    <span class="comment">//       cout &lt;&lt; dist[i][j] &lt;&lt;" ";</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// visited[1] = true;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//    for (int j = 1; j &lt;= n; j++) &#123;</span></span><br><span class="line">    <span class="comment">//       cout &lt;&lt; T[i][j] &lt;&lt;" ";</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dijistra(1);</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; d[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;"---" &lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; cost[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; d[n] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// if ( cost[n] &lt;= k)&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; d[n] &lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; -1 &lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="牛客网华为练习题"><a class="markdownIt-Anchor" href="#牛客网华为练习题"></a> <a href="https://www.nowcoder.com/ta/huawei?page=0" target="_blank" rel="noopener">牛客网华为练习题</a></h1><h2 id="合并表记录"><a class="markdownIt-Anchor" href="#合并表记录"></a> <a href="https://www.nowcoder.com/practice/de044e89123f4a7482bd2b214a685201?tpId=37&amp;tqId=21231&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">合并表记录</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">odict = dict()</span><br><span class="line">n = int(input().strip())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    ids, val = map(int, input().split())</span><br><span class="line">    odict[ids]  = odict.setdefault(ids, <span class="number">0</span>) + val</span><br><span class="line">slist = sorted(odict.items(), key= <span class="keyword">lambda</span> d: d[<span class="number">0</span>], reverse=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> odict.items():</span><br><span class="line">    print(k, v)</span><br></pre></td></tr></table></figure><p>Python 中字典的有序无序针对的是<strong>插入顺序而不是键值大小顺序</strong>,要想根据key或value排序可以直接用sort后再输出。而如果输出要保持输入的顺序，则使用 collections下的 OrderedDict(‘记住插入顺序的字典’)</p><p><strong>Python逆序输出</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reverse</span></span><br><span class="line">n = input().strip()</span><br><span class="line"><span class="comment"># for i in range()</span></span><br><span class="line">rev = reversed(n)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rev:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># range(-1)</span></span><br><span class="line">s = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    print(s[i])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;429三道笔试题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#429三道笔试题&quot;&gt;&lt;/a&gt; 4.29三道笔试题：&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;做了其他大厂的笔试题后，好像确实华为的稍微简单点。只不过其他的笔试题是有模拟题
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VsCode环境、配置Latex(texLive)</title>
    <link href="https://nymrli.top/2020/03/23/VsCode%E9%85%8D%E7%BD%AELatex(texLive)%E7%8E%AF%E5%A2%83/"/>
    <id>https://nymrli.top/2020/03/23/VsCode配置Latex(texLive)环境/</id>
    <published>2020-03-23T07:04:53.000Z</published>
    <updated>2020-05-15T02:58:24.695Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面: 除了配置VsCode以外， 我还配置了Sublime，一开始是不想用<a href="https://www.sumatrapdfreader.org/download-free-pdf-viewer.html" target="_blank" rel="noopener">SumatraPDF</a>，以为能省的。事实上，Vscode也确实提供了三种方法：在web browser、编辑器tab、外部PDF阅读器，共三种办法。个人感觉tab界面太小、浏览器查看毕竟还是没有PDF舒服，最后都体验下来还是选择了外部阅读器，而且SumatraPDF支持正向、反向搜索，挺香的。当然，还有种做法是把PDF编译出来以后，再用日常使用的阅读器打开PDF阅读也是可以的，我个人平时用福昕PDF阅读器会多一点</p><p>SumatraPDF阅读器是个非常轻量级的PDF阅读器，开源轻巧，免安装，共14.6MB。要想配套使用PDF阅读器，网上教程基本上推荐的都是SumatraPDF，应该是SumatraPDF在适配Latex上做的比较好。我试了试指定福昕失败了。</p></blockquote><h1 id="安装texlive"><a class="markdownIt-Anchor" href="#安装texlive"></a> 安装Texlive</h1><p>上Texlive的官网， 有<em>在线安装</em>和<em>DVD安装</em>两种方式，我们选择后者。在http://mirrors.sjtug.sjtu.edu.cn/ctan/systems/texlive/Images/中下载<code>texlive2019.iso</code>的镜像，之后解压，选择<code>install-tl-advanced.bat</code>配置高级版(最好右键<strong>管理员身份运行</strong>)。</p><p>可以点击“Advanced”进入高级安装来修改安装位置、取消你不需要安装的宏包。其中<em>TeXworks 前端</em>就是它自带的编辑器，不需要的可以取消。语言我基本就只选了<code>Chinese, Chinese/Janpanse/Korean, English</code></p><p><img src="https://pic4.zhimg.com/80/v2-e4af1253d81437690bea363d923bddeb_hd.jpg" alt=""></p><p>点击“Customize”来取消勾选不需要的宏包。</p><p><img src="https://pic4.zhimg.com/80/v2-f3e77646f2b270dd94ea6463a8c7d2ab_hd.jpg" alt=""></p><p>很多宏包和功能我个人并不需要，因此我在这里取消勾选，大家可以根据需要勾选自己需要的功能，如果嫌麻烦全部安装也可以，并不消耗多少空间。</p><p>设置完安装路径等选项之后点击“安装”，之后静坐 20 分钟等待安装完成。</p><h1 id="安装vscode"><a class="markdownIt-Anchor" href="#安装vscode"></a> 安装VsCode</h1><p>略, 基本安装就行了。用了很久的Sublime， 突然间想换个新的了， 而且VsCode确实也非常好看。</p><h1 id="安装vscode中latex插件-latex-workshop"><a class="markdownIt-Anchor" href="#安装vscode中latex插件-latex-workshop"></a> 安装VsCode中Latex插件—— LaTeX Workshop</h1><p><img src="https://pic2.zhimg.com/80/v2-9f0a10a9f3fc21f1c67d0a33c9cdfb09_hd.jpg" alt=""></p><p>此时导入Latex工程，查看tex文件就可以看到关键字高亮了。</p><h2 id="配置latex-workshop-插件"><a class="markdownIt-Anchor" href="#配置latex-workshop-插件"></a> 配置LaTeX Workshop 插件</h2><p>菜单栏&quot;File-&gt;Preference-&gt;Settings&quot;然后选择右上角三个按钮中最左边的(Open settings(JSON)), 然后将括号里的内容填充到大括号里就行了，下面已经是我JSON配置的安装文件，可复制直接替换。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "latex-workshop.showContextMenu":true, //右键菜单</span><br><span class="line">    "latex-workshop.latex.tools": [</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-synctex=1"</span>,</span><br><span class="line">        <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">        <span class="string">"-file-line-error"</span>,</span><br><span class="line">        <span class="string">"-pdf"</span>,</span><br><span class="line">        <span class="string">"%DOC%"</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-synctex=1"</span>,</span><br><span class="line">        <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">        <span class="string">"-file-line-error"</span>,</span><br><span class="line">        <span class="string">"%DOC%"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,          </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"pdflatex"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"pdflatex"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-synctex=1"</span>,</span><br><span class="line">        <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">        <span class="string">"-file-line-error"</span>,</span><br><span class="line">        <span class="string">"%DOC%"</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"%DOCFILE%"</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">"latex-workshop.latex.recipes": [</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">        <span class="attr">"tools"</span>: [</span><br><span class="line">        <span class="string">"xelatex"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">        <span class="attr">"tools"</span>: [</span><br><span class="line">        <span class="string">"latexmk"</span></span><br><span class="line">                    ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"pdflatex -&gt; bibtex -&gt; pdflatex*2"</span>,</span><br><span class="line">        <span class="attr">"tools"</span>: [</span><br><span class="line">        <span class="string">"pdflatex"</span>,</span><br><span class="line">        <span class="string">"bibtex"</span>,</span><br><span class="line">        <span class="string">"pdflatex"</span>,</span><br><span class="line">        <span class="string">"pdflatex"</span></span><br><span class="line">                    ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">"latex-workshop.view.pdf.viewer": "browser",  </span><br><span class="line">//"latex-workshop.view.pdf.viewer": "external",</span><br><span class="line">//"latex-workshop.view.pdf.ref.viewer":"external",</span><br><span class="line"></span><br><span class="line">//"latex-workshop.view.pdf.external.viewer.command": "E:\\a常用工具\\SumatraPDF-3.2-64\\SumatraPDF-3.2-64.exe", // 注意修改路径</span><br><span class="line">//"latex-workshop.view.pdf.external.synctex": &#123;</span><br><span class="line">//    "command": "E:\\a常用工具\\SumatraPDF-3.2-64\\SumatraPDF-3.2-64.exe",</span><br><span class="line">//    "args": [</span><br><span class="line">//        "-forward-search",</span><br><span class="line"> //       "%TEX%",</span><br><span class="line">//        "%LINE%",</span><br><span class="line">//        "%PDF%"</span><br><span class="line">//    ]</span><br><span class="line">//&#125;,</span><br><span class="line">"latex-workshop.latex.clean.fileTypes": [</span><br><span class="line">    "*.aux",</span><br><span class="line">    "*.bbl",</span><br><span class="line">    "*.blg",</span><br><span class="line">    "*.idx",</span><br><span class="line">    "*.ind",</span><br><span class="line">    "*.lof",</span><br><span class="line">    "*.lot",</span><br><span class="line">    "*.out",</span><br><span class="line">    "*.toc",</span><br><span class="line">    "*.acn",</span><br><span class="line">    "*.acr",</span><br><span class="line">    "*.alg",</span><br><span class="line">    "*.glg",</span><br><span class="line">    "*.glo",</span><br><span class="line">    "*.gls",</span><br><span class="line">    "*.ist",</span><br><span class="line">    "*.fls",</span><br><span class="line">    "*.log",</span><br><span class="line">    <span class="string">"*.fdb_latexmk"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>▲保存后，一定要重启VsCode，不然无法生效。我当时就是直接去编译了，报了<code>Recipe terminated with fatal error: spawn pdflatex ENOENT.</code>的错误提示。</p><p>其中需要指出的是：<code>&quot;latex-workshop.view.pdf.viewer&quot;: &quot;browser&quot;,</code>设置的是默认阅览PDF的方式，一共有3种：web browser、编辑器tab、外部PDF阅读器。我注释掉的是设置SumatraPDF的方式。这个设置好后，再在Vscode中选择<code>View Latex PDF</code>时就会根据这个配置打开默认阅读PDF的方式，当然也可以点开<code>View Latex PDF</code>的下拉选项，进行指定方式的查阅。</p><h4 id="正向搜索"><a class="markdownIt-Anchor" href="#正向搜索"></a> 正向搜索</h4><blockquote><p>查看code中选中的内容在PDF中什么位置。</p></blockquote><p>选择外部阅读器后，可以通过加入下列实现正向搜索功能。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.view.pdf.external.synctex": &#123;</span><br><span class="line">    "command": "E:/Programs/SumatraPDF/SumatraPDF.exe",// 修改SumatraPDF路径</span><br><span class="line">    "args": [</span><br><span class="line">        "-forward-search",</span><br><span class="line">        "%TEX%",</span><br><span class="line">        "%LINE%",</span><br><span class="line">        <span class="string">"%PDF%"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>正向搜索的使用</strong>：将光标移动到TeX文件的正文。<code>ctrl+alt+x</code>，找到&quot;navigator,select and edit&quot;，点击第一项<code>syncTeX from cursor</code>(或右键选择，或<strong>快捷键</strong><code>ctrl+alt+j</code>)，会切换到PDF文件的相应位置。——设置“Latex右键菜单”后也可以右键选择<code>syncTeX from cursor</code></p><h4 id="反向搜索"><a class="markdownIt-Anchor" href="#反向搜索"></a> 反向搜索</h4><blockquote><p>查看PDF中选中的内容在code中什么位置。</p></blockquote><p>选择&quot;设置-&gt;选项&quot;</p><p><img src="/2020/03/23/VsCode配置Latex(texLive)环境/E:%5Chexo%5Csource_posts%5CVsCode%E9%85%8D%E7%BD%AELatex(texLive)%E7%8E%AF%E5%A2%83%5C1.jpg" alt="1"></p><p><img src="https://pic1.zhimg.com/80/v2-2df9b5aacaeb4a26e216a951f98b893c_hd.jpg" alt=""></p><p>将下列内容填入箭头所指位置，路径修改下即可（为一行内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Users\Marvey\AppData\Local\Programs\Microsoft VS Code\Code.exe&quot; &quot;C:\Users\Marvey\AppData\Local\Programs\Microsoft VS Code\resources\app\out\cli.js&quot; -g &quot;%f&quot;:&quot;%l&quot;</span><br></pre></td></tr></table></figure><p>感谢 <a href="https://www.zhihu.com/people/f5b398ec143be394e91c762ed6cda2f9" target="_blank" rel="noopener">@Macrofuns</a>指出，如果不加双引号，在文件路径有空格的情况下会导致无法反向搜索）</p><h4 id="其他设置"><a class="markdownIt-Anchor" href="#其他设置"></a> 其他设置</h4><ul><li>LaTeX Workshop 默认保存的时候自动编译，如果不喜欢这个设置，可以添加以下代码进入设置区：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.showContextMenu":true, //右键菜单 </span><br><span class="line">"latex-workshop.intellisense.package.enabled": true, //根据加载的包，自动完成命令或包 </span><br><span class="line">"latex-workshop.latex.autoBuild.run": "never", //禁止保存文件时自动build</span><br></pre></td></tr></table></figure><p>借鉴From： <a href="https://www.liangzl.com/get-article-detail-136508.html" target="_blank" rel="noopener">使用VSCode编写LaTeX(latex+vscode+SumatraPDF)</a></p><p>最后推荐两个配置视频：</p><ul><li><a href="https://www.bilibili.com/video/BV1Et411f7GV?t=581" target="_blank" rel="noopener">使用 Sublime Text +TexLive 搭建 LaTeX 编写环境</a>——用sublime看这个视频基本就够了</li><li><a href="https://www.bilibili.com/video/BV1JE411K7ij" target="_blank" rel="noopener">为VSCode配置LaTex编译环境(TeXLive)</a></li></ul><hr><h1 id="vscode其他配置"><a class="markdownIt-Anchor" href="#vscode其他配置"></a> VsCode其他配置</h1><blockquote><p>不准备单独再开一篇文章介绍我怎么配置的了， 就在此篇文章里略微提及下把。</p></blockquote><p>首先是插件介绍：</p><ul><li>Code run</li></ul><blockquote><p>能够让你的IDE基本上运行大多数代码，只好安装编程语言时Path设置正确，默认配置就可以直接运行。</p><p>默认编译运行的快捷键是<code>ctrl + Alt + N</code>，由于之前用的都是Sublime， 里面编译是<code>Ctrl+B</code>， 因此用习惯后有点不想改就直接修改掉了。方法为：<code>Ctrl + Shift + P</code>打开输入框，输入<code>Keyboard Shortcuts</code>, 就会弹出目前所有的快捷键，然后再将原来的<code>Ctrl +B</code>的快捷键取消(直接输入<code>Ctrl +B</code>就能找到目前谁的快捷键是<code>Ctrl +B</code>)，然后再输入<code>Code run</code>，将其快捷键设置为<code>Ctrl +B</code>即可。</p></blockquote><p>在运行Python代码的过程中，一直报错: <code>The environment variable 'Path' seems to have some paths containing the '&quot;' character. The existence of such a character is known to have caused the Python extension to not load. If the extension fails to load please modify your paths to remove this '&quot;' character.</code>后来在找到<a href="https://blog.csdn.net/liao1049164366/article/details/102988435" target="_blank" rel="noopener">解决方案</a>😗* 是因为你在添加其他环境变量时，加了; 分号—&gt;删掉就好了**</p><ul><li>open in browser</li></ul><blockquote><p>编写html页面调试时比较方便</p></blockquote><ul><li>koroFileHeader</li></ul><blockquote><p>自动生成头部注释和函数注释的，测试了一下，除了html以外基本上都能用，挺好使的。</p></blockquote><p>如果不满意默认配置， 可以自己再稍微调一调，展示下我的设置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * @description: Latex相关配置</span><br><span class="line">     */    </span><br><span class="line">    "latex-workshop.showContextMenu":true, //右键菜单</span><br><span class="line">    // ...Latex的太多了, 就不一一展示了.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: koroFileHeader相关配置</span><br><span class="line">     * ctrl+alt+i,添加文件头注释, ctrl+alt+t,添加函数注释</span><br><span class="line">     * "Do not edit"的内容会自动添加</span><br><span class="line">     */</span><br><span class="line">    "fileheader.customMade": &#123;         //文件头部注释</span><br><span class="line">        "Author": "Mrli",</span><br><span class="line">        "Date": "Do not edit",              // 文件创建事件</span><br><span class="line">        "LastEditTime": "Do not edit",      // 文件最后编辑时间</span><br><span class="line">        "Description": "",</span><br><span class="line">    &#125;,</span><br><span class="line">    "fileheader.cursorMode": &#123;          // 函数注释 </span><br><span class="line">        "Author": "Mrli",</span><br><span class="line">        "Date": "Do not edit",              // 当前时间, 函数的开始编写、完成编写时间</span><br><span class="line">        "Description": "",</span><br><span class="line">        "param": "",</span><br><span class="line">        "return": "",</span><br><span class="line">    &#125;,</span><br><span class="line">    "editor.fontFamily": "Monaco, 'Courier New', monospace"</span><br><span class="line">&#125;// 好用插件推荐 https://blog.csdn.net/qq_41139830/article/details/85221330</span><br></pre></td></tr></table></figure><p>用户对插件的自定义配置基本上都是写在这个settings.json下。当然，可以对某个项目单独设置配置，即会在项目文件夹下生成<code>.vscode</code>文件夹，里面会有个<code>settings.json</code>来进行配置.</p><ul><li>Bracket Pair Colorizer</li></ul><blockquote><p>编写JS代码时我是感觉真的好用，JS里大括号和括号有时真的很难记得匹配次序。</p></blockquote><ul><li>Anaconda Extension Pack</li></ul><blockquote><p>就图他的关键字提醒补全。</p></blockquote><p>插件比较大， 安装了挺久的，好像还自带一个Python Extension插件。</p><ul><li>Autopep8</li></ul><p>测试自动规范代码(<code>Alt + Shift + F</code>)时，提示要安装Autopep8，那就安装咯。但这个应该只能算Python的插件，<code>python.exe -m pip install -U autopep8 --user</code></p><ul><li><h3 id="path-autocomplete"><a class="markdownIt-Anchor" href="#path-autocomplete"></a> Path Autocomplete</h3></li></ul><blockquote><p>有时候程序需要读取文件，自己手动去复制文件路径还是比较麻烦的，不过有了这个插件就方便多了，它能自动感知当前目录下所有的文件，只需要你自己选择就好了。</p></blockquote><ul><li>windows opacity</li></ul><blockquote><p>设置窗口透明度的，一开始以为挺好用， 用了后发现自己还想不太喜欢， 真的是太透明了，可以设置0-255， 240我用着差不多。（0的话会消失的）</p></blockquote><p>还有些可以网上再找找，推个挺不错的博客：</p><ul><li><a href="https://blog.csdn.net/hnshhshjq/article/details/80140401" target="_blank" rel="noopener">https://blog.csdn.net/hnshhshjq/article/details/80140401</a></li><li>★  <a href="https://mp.weixin.qq.com/s?__biz=MzAxOTcxNTIwNQ==&amp;mid=2457918435&amp;idx=2&amp;sn=78a94468973f701e674246f1d520434b&amp;chksm=8cb6be09bbc1371fc6582cc7eda6791278165c6527e385f49ee56ceea94e9ca2e3f45efce368&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxOTcxNTIwNQ==&amp;mid=2457918435&amp;idx=2&amp;sn=78a94468973f701e674246f1d520434b&amp;chksm=8cb6be09bbc1371fc6582cc7eda6791278165c6527e385f49ee56ceea94e9ca2e3f45efce368&amp;scene=21#wechat_redirect</a></li></ul><hr><p>快捷键: <a href="https://www.cnblogs.com/schut/p/10461840.html" target="_blank" rel="noopener">https://www.cnblogs.com/schut/p/10461840.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;写在前面: 除了配置VsCode以外， 我还配置了Sublime，一开始是不想用&lt;a href=&quot;https://www.sumatrapdfreader.org/download-free-pdf-viewer.html&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记Codeup题解</title>
    <link href="https://nymrli.top/2020/03/04/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0Codeup%E9%A2%98%E8%A7%A3/"/>
    <id>https://nymrli.top/2020/03/04/算法笔记Codeup题解/</id>
    <published>2020-03-04T06:21:49.000Z</published>
    <updated>2020-03-04T14:22:59.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="100000612-算法笔记93小节数据结构专题2-树的遍历"><a class="markdownIt-Anchor" href="#100000612-算法笔记93小节数据结构专题2-树的遍历"></a> <a href="http://codeup.cn/contest.php?cid=100000612" target="_blank" rel="noopener">100000612 - 《算法笔记》9.3小节——数据结构专题(2)-&gt;树的遍历</a></h2><h3 id="问题-a-树查找"><a class="markdownIt-Anchor" href="#问题-a-树查找"></a> 问题 A: 树查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fast_pow</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> base)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = d;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( n &amp; <span class="number">1</span>) res = res*base;</span><br><span class="line">        base = base * base;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, d;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt;n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; arr[i]; </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt;d;</span><br><span class="line">        <span class="keyword">if</span> ( n &lt; fast_pow(d, <span class="number">2</span>) )&#123;      <span class="comment">// d层没有节点</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"EMPTY"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> beginn = fast_pow(d<span class="number">-1</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> endn = fast_pow(d, <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; beginn;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = beginn+ <span class="number">1</span>; i &lt; n &amp;&amp; i&lt; endn; ++i)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt; <span class="string">" "</span> &lt;&lt; i ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-b-树的高度"><a class="markdownIt-Anchor" href="#问题-b-树的高度"></a> 问题 B: 树的高度</h3><blockquote><p>题目要求我们练习树的静态写法。但其实这道题直接计算每个节点的高度就行了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> height;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125;Nodearr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Nodearr[i].height &gt; m)</span><br><span class="line">            m = Nodearr[i].height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    Nodearr[<span class="number">1</span>].height = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b)!=EOF)&#123;</span><br><span class="line">        <span class="comment">// Nodearr[a].child.push_back(b);</span></span><br><span class="line">        Nodearr[b].height = Nodearr[a].height +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; getHeight() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正规写法：先构建树， 然后再层次遍历计算高度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m=<span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> layer;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125;tree[m];</span><br><span class="line"><span class="keyword">int</span> MaxHigh;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树的静态写法的层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">MaxHigh=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">tree[root].layer =<span class="number">1</span>;</span><br><span class="line">q.push(root);</span><br><span class="line"><span class="keyword">if</span>(tree[root].layer&gt;MaxHigh) MaxHigh=tree[root].layer;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> front=q.front() ;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[front].child.size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> child=tree[front].child[i];</span><br><span class="line">tree[child].layer =tree[front].layer +<span class="number">1</span>;</span><br><span class="line">q.push(child);</span><br><span class="line"><span class="keyword">if</span>(tree[child].layer&gt;MaxHigh) MaxHigh=tree[child].layer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,a,b;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b)!=EOF)&#123;</span><br><span class="line">tree[a].child.push_back(b);</span><br><span class="line">&#125;</span><br><span class="line">BFS(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,MaxHigh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="100000613-算法笔记94小节数据结构专题2-二叉查找树bst"><a class="markdownIt-Anchor" href="#100000613-算法笔记94小节数据结构专题2-二叉查找树bst"></a> 100000613 - 《算法笔记》9.4小节——数据结构专题(2)-&gt;二叉查找树（BST）</h2><h3 id="问题-a-二叉排序树"><a class="markdownIt-Anchor" href="#问题-a-二叉排序树"></a> 问题 A: 二叉排序树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> data[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Node *lc, *rc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Node *now = <span class="keyword">new</span> Node;</span><br><span class="line">    now-&gt;v = x;</span><br><span class="line">    now-&gt;lc = now-&gt;rc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* &amp;root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;   </span><br><span class="line">        root = newNode(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;v == x) <span class="keyword">return</span>; <span class="comment">// 已存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;v ) insert(root-&gt;lc, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;v ) insert(root-&gt;rc, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">createTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;  <span class="comment">// ▲注意此处是NULL， 而不是new Node</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    preOrder(root-&gt;lc);</span><br><span class="line">    preOrder(root-&gt;rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root-&gt;lc);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    inOrder(root-&gt;rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root-&gt;lc);</span><br><span class="line">    postOrder(root-&gt;rc);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; data[i];</span><br><span class="line">        Node* root = createTree();</span><br><span class="line">        preOrder(root);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        postOrder(root);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-b-二叉搜索树"><a class="markdownIt-Anchor" href="#问题-b-二叉搜索树"></a> 问题 B: 二叉搜索树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> data[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> v;</span><br><span class="line">    Node *lc, *rc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">newNode</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">    Node *now = <span class="keyword">new</span> Node;</span><br><span class="line">    now-&gt;v = x;</span><br><span class="line">    now-&gt;lc = now-&gt;rc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* &amp;root, <span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        root = newNode(x);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == root-&gt;v ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;v ) insert(root-&gt;lc, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;v ) insert(root-&gt;rc, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">createTree</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">        insert(root, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node *root, <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    s += root-&gt;v;</span><br><span class="line">    preOrder(root-&gt;lc, s);</span><br><span class="line">    preOrder(root-&gt;rc, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node *root, <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root-&gt;lc, s);</span><br><span class="line">    s += root-&gt;v;</span><br><span class="line">    inOrder(root-&gt;rc, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node *root, <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root-&gt;lc, s);</span><br><span class="line">    postOrder(root-&gt;rc, s);</span><br><span class="line">    s += root-&gt;v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="built_in">string</span> target;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; target;</span><br><span class="line">        <span class="built_in">string</span> preans, postans;</span><br><span class="line">        Node *ans = createTree(target);</span><br><span class="line">        preOrder(ans, preans);</span><br><span class="line">        postOrder(ans, postans);</span><br><span class="line">        <span class="comment">// inOrder(root, in);     // 由于中序遍历的结果就是排序的结果, 因此都一样</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="built_in">string</span> in, pre, post;</span><br><span class="line">            Node *root = createTree(s);</span><br><span class="line">            preOrder(root, pre);</span><br><span class="line">            <span class="keyword">if</span> (pre == preans)&#123;</span><br><span class="line">                postOrder(root, post);</span><br><span class="line">                <span class="keyword">if</span> (post == postans) <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">else</span>  <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>  <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;100000612-算法笔记93小节数据结构专题2-树的遍历&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#100000612-算法笔记93小节数据结构专题2-树的遍历&quot;&gt;&lt;/a&gt; &lt;a href=&quot;http://codeup.cn/c
      
    
    </summary>
    
    
      <category term="C++" scheme="https://nymrli.top/tags/C/"/>
    
      <category term="Algorithm" scheme="https://nymrli.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>PAT冲冲冲——乙级</title>
    <link href="https://nymrli.top/2020/02/02/PAT%E5%86%B2%E5%86%B2%E5%86%B2%E2%80%94%E2%80%94%E4%B9%99%E7%BA%A7/"/>
    <id>https://nymrli.top/2020/02/02/PAT冲冲冲——乙级/</id>
    <published>2020-02-02T08:26:41.000Z</published>
    <updated>2020-02-21T12:24:17.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pat冲冲冲乙级"><a class="markdownIt-Anchor" href="#pat冲冲冲乙级"></a> PAT冲冲冲——乙级</h1><blockquote><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/type/7?page=1" target="_blank" rel="noopener">PAT甲级练习题 ——PAT (Advanced Level) Practice </a><br><a href="https://www.nowcoder.com/pat/5/problems?page=1" target="_blank" rel="noopener">PAT甲级(Advanced Level)真题</a><br><a href="https://www.liuchuo.net/archives/8091" target="_blank" rel="noopener">柳婼 の blog经验</a><br><a href="https://saquarius.com/2019/08/pat%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">saquarius’s blog</a></p><p><a href="https://blog.csdn.net/a617976080/article/details/89676670" target="_blank" rel="noopener">PAT甲级题目及分类总结</a><br><a href="https://blog.csdn.net/richenyunqi/article/details/79958195" target="_blank" rel="noopener">pat甲级题解目录</a></p></blockquote><p>▲报名费256，可以刷<a href="https://www.nowcoder.com/pat" target="_blank" rel="noopener">牛客网</a>的题来获得-50的优惠券，该练习场下的所有题目只要通过都算</p><h2 id="乙级练习题"><a class="markdownIt-Anchor" href="#乙级练习题"></a> 乙级练习题</h2><h3 id="nowcoder数列"><a class="markdownIt-Anchor" href="#nowcoder数列"></a> <a href="https://www.nowcoder.com/pat/2/problem/250" target="_blank" rel="noopener">NowCoder数列</a></h3><blockquote><p>没想到第二题就是考了个数据范围，由于0≤n≤1000000，所以F(n)必然比long long大，而判断3的倍数可表示为===&gt; F(n) % 3 —&gt; (F(n-1)%3 + F(n-2)%3) % 3</p><p>求余运算性质：a = b+c --&gt;  a%d = (b%d+c%d) % d</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">1000000</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">7</span>;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">        f[i]=(f[i<span class="number">-1</span>]%<span class="number">3</span>+f[i<span class="number">-2</span>]%<span class="number">3</span>)%<span class="number">3</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[n]!=<span class="number">0</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="养兔子"><a class="markdownIt-Anchor" href="#养兔子"></a> <a href="https://www.nowcoder.com/pat/2/problem/251" target="_blank" rel="noopener">养兔子</a></h3><blockquote><p>非常经典的斐波那契数列题</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 90+5</span></span><br><span class="line">ll arr[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[n] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客似云来"><a class="markdownIt-Anchor" href="#客似云来"></a> <a href="https://www.nowcoder.com/pat/2/problem/252" target="_blank" rel="noopener">客似云来</a></h3><blockquote><p>斐波那契数列的拓展题，将其中某个区间的值累加输出（需要特判是否为某个点）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 80+5</span></span><br><span class="line">ll arr[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line"></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; arr[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to)&#123;</span><br><span class="line">        ll tmp = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 注意需要特判是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (from == to) tmp = arr[from];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=from; i&lt;= to;i++)&#123;</span><br><span class="line">                tmp += arr[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契凤尾"><a class="markdownIt-Anchor" href="#斐波那契凤尾"></a> <a href="https://www.nowcoder.com/pat/2/problem/253" target="_blank" rel="noopener">斐波那契凤尾</a></h3><blockquote><p>一遍还挺难过的，有不少的坑点</p><p>1.虽然也是斐波那契数列，但是一定要注意前两项的取值<br>2.输出末尾的6位，那么就是%1e6，但是如果有前置0，需要补零，我是使用iomanip中的setw和setfill实现的<br>3.怎么判断超过6位：找出超过6位的n应该算比较简单的方法了吧</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000 + 5</span></span><br><span class="line">ll arr[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        用来找到超过1e6的n</span></span><br><span class="line"><span class="comment">        arr[i] = (arr[i-1] + arr[i-2]);</span></span><br><span class="line"><span class="comment">        if (arr[i] &gt; 1000000)&#123;</span></span><br><span class="line"><span class="comment">             cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">             break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        arr[i] = (arr[i<span class="number">-1</span>]%<span class="number">1000000</span> + arr[i<span class="number">-2</span>]%<span class="number">1000000</span>)%<span class="number">1000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;= <span class="number">30</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">6</span>)&lt;&lt;setfill(<span class="string">'0'</span>) &lt;&lt; arr[n] &lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Po个C的代码，使用printf的格式化输出的特性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    a[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">100000</span>;i++)</span><br><span class="line">      a[i]=(a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>])%<span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=<span class="number">30</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%06d\n"</span>,a[n]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="星际密码"><a class="markdownIt-Anchor" href="#星际密码"></a> <a href="https://www.nowcoder.com/pat/2/problem/254" target="_blank" rel="noopener"> 星际密码</a></h3><blockquote><p>说实话，一开始没看懂题，因为输入的n跟题目里提到的n不是同一个东西：矩阵X为[[1 1],[0 1]]，题目中的n是指多少次幂；而输入里的n是指有多少个密码，真正的n其实是第二行的输入Xi</p><p>那么分析下思路，Xi=1时<mark>1，Xi=2时</mark>2，Xi=3时==3</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000 + 5</span></span><br><span class="line">ll arr[N];</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initFib</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        arr[i] = (arr[i<span class="number">-1</span>]%<span class="number">10000</span> + arr[i<span class="number">-2</span>]%<span class="number">10000</span>)%<span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> input[<span class="number">100</span>+<span class="number">5</span>];</span><br><span class="line">    initFib();</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>)&lt;&lt;setfill(<span class="string">'0'</span>) &lt;&lt; arr[tmp] ;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/PAT冲冲冲——乙级/E:%5Chexo%5Csource_posts%5CPAT%E5%86%B2%E5%86%B2%E5%86%B2%5CFib.jpg" alt="Fib"></p><h3 id="母牛的故事"><a class="markdownIt-Anchor" href="#母牛的故事"></a> <a href="https://www.nowcoder.com/pat/2/problem/255" target="_blank" rel="noopener"> 母牛的故事</a></h3><blockquote><p>变形的Fib，公式更新为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = f(n-1) + f(n-3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></p><p>最主要的就是确定前几项，比较好的是样例都给出了2==&gt;2,4==&gt;4,5==&gt;6，这样就比较好确定<strong>每头小母牛从第四个年头开始，每年年初也生一头小母牛</strong>到底是什么意思了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000 + 5</span></span><br><span class="line">ll arr[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initFib</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; arr[<span class="number">2</span>] = <span class="number">2</span>;arr[<span class="number">3</span>]=<span class="number">3</span>;arr[<span class="number">4</span>]=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    initFib();</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="童年生活二三事"><a class="markdownIt-Anchor" href="#童年生活二三事"></a> <a href="https://www.nowcoder.com/pat/2/problem/256" target="_blank" rel="noopener">童年生活二三事</a></h3><blockquote><p>Fib数列的板子题，只不过需要理解一下</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 90 + 5</span></span><br><span class="line">ll arr[N];</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initFib</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    initFib();</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[n]  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蜜蜂寻路"><a class="markdownIt-Anchor" href="#蜜蜂寻路"></a> <a href="https://www.nowcoder.com/pat/2/problem/257" target="_blank" rel="noopener">蜜蜂寻路</a></h3><blockquote><p>如果固定起点为1，计算到某个位置的走法数的话，跟走阶梯其实是一种思路，就是f(n) = f(n-1) + f(n-2)，即第n个位置的走法数=第n-1位置走法数 + 第n-2位置走法数</p></blockquote><table><thead><tr><th>1-&gt;2</th><th>1</th><th>2-&gt;3</th><th>1</th><th>3-&gt;4</th><th>1</th></tr></thead><tbody><tr><td>1-&gt;3</td><td>2</td><td>2-&gt;4</td><td>2</td><td>3-&gt;5</td><td>2</td></tr><tr><td>1-&gt;4</td><td>3</td><td>2-&gt;5</td><td>3</td><td>3-&gt;6</td><td>3</td></tr><tr><td>1-&gt;5</td><td>5</td><td>2-&gt;6</td><td>5</td><td>3-&gt;7</td><td>5</td></tr><tr><td>1-&gt;6</td><td>8</td><td>2-&gt;7</td><td>8</td><td>3-&gt;8</td><td>8</td></tr></tbody></table><p>可以发现其中的规律：走法数一直是Fib数列，而值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mrow><mi>t</mi><mi>o</mi></mrow></msub><mo>−</mo><msub><mi>N</mi><mrow><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">fib(N_{to} - N_{from})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>▲但这题还有一个难点在于用例的范围(0 &lt; a &lt; b &lt; 2<sup>31)，即b-a~=2</sup>32-1，为int最大范围，会导致的问题有两个</p><ol><li><p>fib数列通常使用数组来存储，但是无法开个2^32大小的数组</p><p>==&gt;滚动数组、递推（不用数组）</p></li><li><p>输出的Fib(n)就远远超过long long了，因此要么模拟大数相加，那么另寻他法。</p><p>==&gt;△还需要注意到的一点是,<strong>输出数据结果范围是 [0, 2^63)</strong>，那么意思是题目要求的输出其实是在long long 范围内的，那么就可以考虑截取输出了</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">// ll credit = 9.2e18;开的足够大能过样例就行</span></span><br><span class="line">ll credit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 幂计算</span></span><br><span class="line"><span class="comment"> * @author mrli 2019-10-27</span></span><br><span class="line"><span class="comment"> * @param  n [less than 63]</span></span><br><span class="line"><span class="comment"> * @return   [long long type]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        ans *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> del)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (del == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(del == <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll f1 = <span class="number">1</span>; ll f2=<span class="number">2</span>;</span><br><span class="line">        ll ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=del;i++)&#123;</span><br><span class="line"><span class="comment">// ans = f1 + f2 ;也过了</span></span><br><span class="line">            ans = ( f1%(credit) + f2%(credit) )%credit;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    credit = <span class="built_in">pow</span>(<span class="number">63</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>( n-- )&#123;</span><br><span class="line">        <span class="keyword">int</span> from, to;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to;</span><br><span class="line">        ll ans;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Fib(to-from) &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了别人的题解后,发现想多了。题目的意思是<strong>得分点的输出值都在long long 范围内，而不是需要你把输出值压缩在long long范围内</strong>，果然去掉 %运算也过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//蜜蜂寻路</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(x, n) memset(x,n,sizeof(x));</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">2147483648</span>+<span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line">LL dp[<span class="number">3</span>]; <span class="comment">//滚动数组</span></span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(dp, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; b-a+<span class="number">1</span>; i++)</span><br><span class="line">        dp[i%<span class="number">3</span>] = dp[<span class="number">0</span>]+dp[<span class="number">1</span>]+dp[<span class="number">2</span>]-dp[i%<span class="number">3</span>]; <span class="comment">//即dp[i]=dp[i-1]+dp][i-2]</span></span><br><span class="line"> </span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        ans = max(dp[i], ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//从1到4和从2到5答案是一样的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分数运算"><a class="markdownIt-Anchor" href="#分数运算"></a> <a href="https://www.nowcoder.com/pat/2/problem/261" target="_blank" rel="noopener"> 分数运算</a></h3><blockquote><p>牛客网周赛做到过一次，感觉当时写的比现在的简单。难点在<strong>使用GCD进行约分</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辗转相除法,求最大公约数</span></span><br><span class="line"><span class="comment"> * @author mrli 2019-10-28</span></span><br><span class="line"><span class="comment"> * @param  a [description]</span></span><br><span class="line"><span class="comment"> * @param  b [description]</span></span><br><span class="line"><span class="comment"> * @return   [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1,a2,b1,b2;</span><br><span class="line">    <span class="keyword">char</span> op3;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">scanf</span>(<span class="string">"%d/%d %d/%d %c"</span>, &amp;a1, &amp;a2, &amp;b1, &amp;b2, &amp;op3) != EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> fenmu;</span><br><span class="line">        <span class="keyword">int</span> fenzi;</span><br><span class="line">        <span class="keyword">if</span> (op3 == <span class="string">'+'</span>)&#123;</span><br><span class="line">            fenmu = a2*b2;</span><br><span class="line">            fenzi = a1*b2+a2*b1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op3 == <span class="string">'-'</span>)&#123;</span><br><span class="line">            fenmu = a2*b2;</span><br><span class="line">            fenzi = a1*b2-a2*b1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op3 == <span class="string">'*'</span>)&#123;</span><br><span class="line">            fenmu = a2*b2;</span><br><span class="line">            fenzi = a1*b1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//if (op3 == '*')&#123;</span></span><br><span class="line">            fenmu = a2*b1;</span><br><span class="line">            fenzi = a1*b2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出最大公因子,约分</span></span><br><span class="line">        <span class="keyword">int</span> common = gcd(fenmu,fenzi);</span><br><span class="line">        <span class="keyword">int</span> res_zi = fenzi/common;</span><br><span class="line">        <span class="keyword">int</span> res_mu = fenmu/common;</span><br><span class="line">        <span class="keyword">if</span> ( res_mu * res_zi &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(fenzi/common) &lt;&lt; <span class="string">'/'</span> &lt;&lt; <span class="built_in">abs</span>(fenmu/common) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt;<span class="built_in">abs</span>(fenzi/common) &lt;&lt; <span class="string">'/'</span> &lt;&lt; <span class="built_in">abs</span>(fenmu/common) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解因数"><a class="markdownIt-Anchor" href="#分解因数"></a> <a href="https://www.nowcoder.com/pat/2/problem/262" target="_blank" rel="noopener"> 分解因数</a></h3><blockquote><p>使用小学的短除法，我们很清楚的知道，要想求出它的每一个质因数，我们需要用质数去试除。<code>90</code>能被<code>2</code>整除，那就拿商继续除以<code>2</code>，除不尽就换<code>3</code>，一直到除到质数为止。基础代码框架类似判断质数，只是被判断的数字在过程中不断被除，最终循环结束的时候，那个被处理过的数字，就是最后一个质因数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpn = n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span> ( tmpn%i == <span class="number">0</span> &amp;&amp; tmpn != i)&#123;</span><br><span class="line">                tmpn /= i;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" * "</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmpn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的第一次做法：</p><blockquote><p>一直TLE，估计这种的话，必须得线性筛，我搜了几个题解的结果也证明除了上述题解，其他的都是线性筛，上面的就比较巧妙</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> num )</span></span>&#123;</span><br><span class="line">     <span class="comment">//两个较小数另外处理</span></span><br><span class="line">     <span class="keyword">if</span> (num==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">if</span>(num ==<span class="number">2</span>|| num==<span class="number">3</span> )</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">     <span class="comment">//不在6的倍数两侧的一定不是质数</span></span><br><span class="line">     <span class="keyword">if</span>(num %<span class="number">6</span>!= <span class="number">1</span>&amp;&amp;num %<span class="number">6</span>!= <span class="number">5</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">//在6的倍数两侧的也可能不是质数</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">5</span>;i &lt;= <span class="built_in">sqrt</span>( num); i+=<span class="number">6</span> )</span><br><span class="line">         <span class="keyword">if</span>(num %i== <span class="number">0</span>||num %(i+ <span class="number">2</span>)==<span class="number">0</span> )</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">     <span class="comment">//排除所有，剩余的是质数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> ;</span><br><span class="line">        <span class="keyword">int</span> tmpn = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tmpn;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> ( isPrime(i) &amp;&amp; n%i == <span class="number">0</span>)&#123;</span><br><span class="line">                n /= i;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    first = <span class="literal">false</span>;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; i ; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt;  <span class="string">" * "</span> &lt;&lt; i ; </span><br><span class="line">                <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="因子个数"><a class="markdownIt-Anchor" href="#因子个数"></a> <a href="https://www.nowcoder.com/pat/2/problem/264" target="_blank" rel="noopener">因子个数</a></h3><blockquote><p>用到了上题的结论，<strong>一个正整数总可以分解成一个或多个素数的积</strong>，一开始理解错题目了，以为是所有因数的个数，其实是<strong>因数的种数</strong>，比如20-&gt;2是因为2，2，5；30-&gt;3是因为2，3，5。</p><p>因此这边还是需要素数判别，卡的点也在这，要用线性筛，其实就是上题的回答方式不同罢了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (tmp%i==<span class="number">0</span>)&#123;</span><br><span class="line">                tmp/=i;</span><br><span class="line">                <span class="keyword">if</span> (first)&#123;</span><br><span class="line">                    first = !first;</span><br><span class="line">                    ans ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while( cin &gt;&gt; n)&#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        int tmp = n;</span><br><span class="line"></span><br><span class="line">        for (int i = 2; i &lt;= sqrt(n); ++i)&#123;</span><br><span class="line">            // bool first = true;</span><br><span class="line">            if (tmp%i==0)&#123;</span><br><span class="line">                while (tmp%i==0)&#123;</span><br><span class="line">                   tmp/=i;</span><br><span class="line">                &#125;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (tmp!=1) ans++;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="skew数"><a class="markdownIt-Anchor" href="#skew数"></a> <a href="https://www.nowcoder.com/pat/2/problem/266" target="_blank" rel="noopener"> skew数</a></h3><blockquote><p>模拟题、实现一个幂运算</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        ans *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; s )&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'2'</span>)&#123;</span><br><span class="line">                ans += <span class="number">2</span>*(pow2(size-i)<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (s[i]-<span class="string">'0'</span>)*(pow2(size-i)<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一的个数"><a class="markdownIt-Anchor" href="#一的个数"></a> <a href="https://www.nowcoder.com/pat/2/problem/267" target="_blank" rel="noopener"> 一的个数</a></h3><blockquote><p>非常基础的一道题：r进制表示</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, r;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n%r==<span class="number">1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            n /= r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外星人的语言"><a class="markdownIt-Anchor" href="#外星人的语言"></a> <a href="https://www.nowcoder.com/pat/2/problem/268" target="_blank" rel="noopener"> 外星人的语言</a></h3><blockquote><p>r进制的拓展，需要将各位输出出来，由于是逆序的，所以需要一1.个栈来反转一下、或是2.使用string的反转功能</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, r;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="comment">// 0-9</span></span><br><span class="line">            <span class="keyword">char</span> c = n%r+<span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span> (n%r&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// A-F</span></span><br><span class="line">                c = n%r<span class="number">-10</span>+<span class="number">65</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n /= r;</span><br><span class="line">            <span class="comment">// 不直接cout，而是存栈</span></span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="comment">// 取出栈里的内容</span></span><br><span class="line">            <span class="keyword">char</span> c = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数位和"><a class="markdownIt-Anchor" href="#数位和"></a> <a href="https://www.nowcoder.com/pat/2/problem/270" target="_blank" rel="noopener"> 数位和</a></h3><blockquote><p>代码为<a href="#%E4%B8%80%E7%9A%84%E4%B8%AA%E6%95%B0">一的个数</a>+<a href="#%E5%A4%96%E6%98%9F%E4%BA%BA%E7%9A%84%E8%AF%AD%E8%A8%80">外星人的语言</a>的结合版。</p><p>题目要求，将数n，先表示成r进制的形式，然后再计算r进制下n的位数和，然后再用r进制来表示位数和的结果</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ACM比赛中cin,的使用比较耗时,因为默认的时候，cin与stdin总是保持同步的，使用这句可以使cin达到和scanf相差无几的输入效率。</span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, r;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            ans += n%r;</span><br><span class="line">            n /= r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(ans)&#123;</span><br><span class="line">            <span class="comment">// 0-9</span></span><br><span class="line">            <span class="keyword">char</span> c = ans%r+<span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans%r&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// A-F</span></span><br><span class="line">                c = ans%r<span class="number">-10</span>+<span class="number">65</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans /= r;</span><br><span class="line">            <span class="comment">// 不直接cout，而是存栈</span></span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="comment">// 取出栈里的内容</span></span><br><span class="line">            <span class="keyword">char</span> c = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进制回文数"><a class="markdownIt-Anchor" href="#进制回文数"></a> <a href="https://www.nowcoder.com/pat/2/problem/272" target="_blank" rel="noopener">进制回文数</a></h3><blockquote><p>还是r进制的拓展，</p><p>1.r需要用个2-16的循环<br>2.判断字符串的镜像对称s[i] != s[ssize-i-1]<br>3.踩了个坑,n每次都会被除到很小,因此需要用个临时变量来处理</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; N)&#123;</span><br><span class="line">        <span class="keyword">bool</span> yes=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">2</span>; r &lt;= <span class="number">16</span>; ++r)&#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">int</span> n = N;</span><br><span class="line">            <span class="keyword">while</span>(n)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = n%r+<span class="number">48</span>;</span><br><span class="line">                <span class="keyword">if</span> (n%r&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">                    c = n%r<span class="number">-10</span>+<span class="number">65</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                n /= r;</span><br><span class="line">                s += c;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测出r进制变换时,n已经被除的很小了,因此需要用个临时变量</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; r &lt;&lt; "进制：" &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// for (int i = 0; i &lt; s.size(); ++i)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; s[i] &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//     /* code */</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">bool</span> mirror = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> ssize = s.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ssize/<span class="number">2</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[ssize-i<span class="number">-1</span>])&#123;</span><br><span class="line">                    mirror = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mirror)&#123;</span><br><span class="line">                 yes=<span class="literal">true</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (yes) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发邮件"><a class="markdownIt-Anchor" href="#发邮件"></a> <a href="https://www.nowcoder.com/pat/2/problem/274" target="_blank" rel="noopener"> 发邮件</a></h3><blockquote><p>一道数学题，递推公式为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f(n) = (n-1)*[f(n-1)+f(n-2)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></p><p>坑点:超出了int，需要用longlong</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">email</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n<span class="number">-1</span>)*(email(n<span class="number">-1</span>)+email(n<span class="number">-2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n )&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; email(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说反话-20"><a class="markdownIt-Anchor" href="#说反话-20"></a> <a href="https://www.nowcoder.com/pat/2/problem/4075" target="_blank" rel="noopener"> 说反话 (20)</a></h3><blockquote><p>考查了：对行的读取、字符串的切割。</p><p>本来还以为考了个string的反转，结果比想象中的更简单一点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( getline(<span class="built_in">cin</span>, s) )&#123;</span><br><span class="line">        <span class="built_in">stringstream</span> strings;</span><br><span class="line">        <span class="built_in">string</span> tmps;</span><br><span class="line">        strings &lt;&lt; s;</span><br><span class="line">        <span class="keyword">while</span>( getline(strings, tmps, <span class="string">' '</span>) )&#123;</span><br><span class="line">            ss.push(tmps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!ss.empty())&#123;</span><br><span class="line">            <span class="built_in">string</span> couts = ss.top();</span><br><span class="line">            ss.pop();</span><br><span class="line">            <span class="keyword">if</span> (!ss.empty())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; couts &lt;&lt;<span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; couts ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充string的反转"><a class="markdownIt-Anchor" href="#补充string的反转"></a> 补充——string的反转：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*法一:使用string::reverse_iterator迭代器,直接用iterator会报错*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span>::reverse_iterator it=couts.rbegin(); it != couts.rend() ; ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*法二:使用algorithm算法中的reverse函数*/</span></span><br><span class="line"><span class="comment">// 会修改str中的内容</span></span><br><span class="line">reverse(str.begin(),str.end());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*法三:使用使用string.h中的strrev函数</span></span><br><span class="line"><span class="comment">△只能处理char[],不支持string类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span> s[]=<span class="string">"hello"</span>;</span><br><span class="line">strrev(s);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*法四:自己编写*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;i&lt;j;i++,j--)&#123;</span><br><span class="line">        <span class="keyword">char</span> c=s[i];</span><br><span class="line">        s[i]=s[j];</span><br><span class="line">        s[j]=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一元多项式求导-25"><a class="markdownIt-Anchor" href="#一元多项式求导-25"></a> <a href="https://www.nowcoder.com/pat/2/problem/4076" target="_blank" rel="noopener">一元多项式求导 (25)</a></h3><blockquote><p>被读取方式卡了会</p><p>这边有个坑点: 忽略了常数项的问题<br>比如 输入 2 0<br>应该输出 0 0</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span>,coe;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;coe,&amp;<span class="built_in">exp</span>)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span>!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,coe*<span class="built_in">exp</span>,<span class="built_in">exp</span><span class="number">-1</span>);</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="literal">false</span>) <span class="built_in">printf</span>(<span class="string">"0 0\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别人的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poly</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> coef;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125;<span class="keyword">typedef</span> poly;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> coef;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;poly&gt; q;</span><br><span class="line">    <span class="comment">// scanf和getchar合用比较方便,cin再用getchar无效</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;coef, &amp;index) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span> (index!=<span class="number">0</span>)&#123;</span><br><span class="line">            poly *p = <span class="keyword">new</span> poly();</span><br><span class="line">            p-&gt;coef = coef*index;</span><br><span class="line">            p-&gt;index = index<span class="number">-1</span> ;</span><br><span class="line">            q.push(*p);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放最后能过,放最初的时候有些过不了</span></span><br><span class="line">        <span class="keyword">if</span> (getchar()==<span class="string">'\n'</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q.size()==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"0 0\n"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            poly p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (p.coef != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (q.empty())</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, p.coef, p.index );</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d "</span>, p.coef, p.index );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷完了牛客网PAT乙级练习题的第一、第三页。大多都是些模拟题、简单题，相当于弱一点的蓝桥杯省赛。由于报名考的是甲级，所以就没继续做下去了…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pat冲冲冲乙级&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pat冲冲冲乙级&quot;&gt;&lt;/a&gt; PAT冲冲冲——乙级&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sshpass——shell脚本实现SSH连接其他主机并执行终端命令</title>
    <link href="https://nymrli.top/2019/12/25/sshpass%E2%80%94%E2%80%94shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0SSH%E8%BF%9E%E6%8E%A5%E5%85%B6%E4%BB%96%E4%B8%BB%E6%9C%BA%E5%B9%B6%E6%89%A7%E8%A1%8C%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/"/>
    <id>https://nymrli.top/2019/12/25/sshpass——shell脚本实现SSH连接其他主机并执行终端命令/</id>
    <published>2019-12-25T09:29:08.000Z</published>
    <updated>2019-12-25T10:16:16.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sshpass"><a class="markdownIt-Anchor" href="#sshpass"></a> sshpass</h1><blockquote><p>ssh登陆不能在命令行中指定密码。sshpass的出现，解决了这一问题。即sshpass可以用于非交互SSH的密码验证，<strong>一般用在sh脚本中，无须再次输入密码</strong>。</p></blockquote><p>sshpass允许用<code>-p</code>参数指定明文密码，然后直接登录远程服务器。(支持密码从命令行、文件、环境变量中读取)</p><p>1.安装<code>sudo apt install sshpass</code></p><p>2.使用说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -p 直接指定密码</span></span><br><span class="line">sshpass -p '123456' ssh user_name@host_ip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f: -f filename <span class="comment">#后跟保存密码的文件名，密码是文件内容的第一行。</span></span></span><br><span class="line">[root@zhu ~]# cat 1.txt</span><br><span class="line">123456</span><br><span class="line">[root@zhu ~]# sshpass -f 1.txt  ssh root@192.168.56.102</span><br><span class="line">Last login: Fri Apr 18 13:48:20 2014 from 192.168.56.101</span><br><span class="line">[root@jiang ~]# exit</span><br><span class="line">logout</span><br><span class="line">Connection to 192.168.56.102 closed.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -e <span class="comment">#将环境变量SSHPASS作为密码</span></span></span><br><span class="line">[root@zhu ~]# export SSHPASS=123456</span><br><span class="line">[root@zhu ~]# sshpass -e  ssh root@192.168.56.102</span><br><span class="line">Last login: Fri Apr 18 13:51:45 2014 from 192.168.56.101</span><br><span class="line">[root@jiang ~]# exit</span><br><span class="line">logout</span><br><span class="line">Connection to 192.168.56.102 closed.</span><br></pre></td></tr></table></figure><h1 id="shell脚本实现ssh连接其他主机并执行终端命令"><a class="markdownIt-Anchor" href="#shell脚本实现ssh连接其他主机并执行终端命令"></a> shell脚本实现SSH连接其他主机并执行终端命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">command</span> -v &lt;the_command&gt; 检测命令是否存在返回命令所在路径,等价于<span class="built_in">which</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> [ -x file ] 如果文件存在且可执行</span></span><br><span class="line">if ! [ -x "$(command -v sshpass)" ]; then</span><br><span class="line">  sudo apt-get install sshpass</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">port=20005</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> -e 会进行转义</span></span><br><span class="line">echo -e "\n请输入用户名！\n"</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">read</span>-将交互输入保存在变量中</span></span><br><span class="line">read name</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获得当前脚本的工作路径</span></span><br><span class="line">dir=$(cd $(dirname $0);pwd)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 分割-&gt;获得文件名</span></span><br><span class="line">file_name="$&#123;dir##*/&#125;"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 传输文件</span></span><br><span class="line">echo -e "\n[开始传输文件]\n"</span><br><span class="line">sshpass -p "$key" scp -r -P  $port $dir username@IP_address:/data/cluster/$name</span><br><span class="line">if [ $pool -eq 1 ]||[ $pool -eq 2 ]||[ $pool -eq 3 ]</span><br><span class="line">then </span><br><span class="line">    # remotessh为标记符,下面的内容全部重定向到ssh连接的终端中, 一定要保证下面的全是以字符串的形式</span><br><span class="line">    # 由于shell会进行预转换,所以shell特殊的量需要额外注意,否则结果将只会是当前主机的。因此需要加\</span><br><span class="line">    # man sshpass中提示:多个-t选项强制分配tty，即使ssh没有本地tty,所以使用-tt参数来强制伪终端分配(表示为这个连接分配TTY)，即使标准输入不是终端，否则退出后会提示`Pseudo-terminal will not be allocated because stdin is not a terminal的错`。 即指明是来自脚本的调用</span><br><span class="line">    # 控制终端（/dev/tty）就是当前进程的控制终端的设备特殊文件，可以进行写入写出</span><br><span class="line">    sshpass -p "$key" ssh -tt -p $(($port+$pool)) username@IP_address &lt;&lt; remotessh</span><br><span class="line">Condor_number=\`condor_q | grep jobs | awk '&#123;print \$1&#125;'\`</span><br><span class="line">if [ \$Condor_number -le 1 ]</span><br><span class="line">then echo -e "\n创建任务失败！\n"</span><br><span class="line">else echo -e "\n创建任务成功！\n"</span><br><span class="line">fi</span><br><span class="line">exit</span><br><span class="line">remotessh</span><br><span class="line">else</span><br><span class="line">echo -e "没有该资源池\n"</span><br><span class="line">exit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><code>man sshpass</code>中关于-t参数的说明</p><blockquote><p>Force pseudo-terminal allocation.  This can be used to execute arbitrary screen-based programs on a remote machine, which can be very useful, e.g. when implementing menu services.  Multiple -t options force tty allocation, even if ssh has no local tty.</p></blockquote><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h1><p>所以实现的方法主要是:</p><ul><li>SSHpass非交互式登录</li><li>SSH终端执行多条命令</li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><p><a href="https://blog.csdn.net/wyl9527/article/details/72770455" target="_blank" rel="noopener">ssh@host:ssh切换到其他机器上执行多条命令</a><br><a href="https://blog.csdn.net/qq_39584315/article/details/87189114" target="_blank" rel="noopener">Shell表达式，${file##*/} 取后缀</a><br><a href="https://blog.csdn.net/liyyzz33/article/details/84836255" target="_blank" rel="noopener">shell-if表达式（-f,-d,-s,-r,-w,-x,-eq,-ne,-ge,-gt,-le,-lt ）</a><br><a href="https://majing.io/posts/10000009411212" target="_blank" rel="noopener">Linux检测命令是否存在</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sshpass&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sshpass&quot;&gt;&lt;/a&gt; sshpass&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;ssh登陆不能在命令行中指定密码。sshpass的出现，解决了这一问题。即sshpass
      
    
    </summary>
    
    
      <category term="运维" scheme="https://nymrli.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Linux" scheme="https://nymrli.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>树莓派初始化操作</title>
    <link href="https://nymrli.top/2019/12/12/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C/"/>
    <id>https://nymrli.top/2019/12/12/树莓派初始化操作/</id>
    <published>2019-12-12T10:59:06.000Z</published>
    <updated>2019-12-12T11:21:49.504Z</updated>
    
    <content type="html"><![CDATA[<p>安装系统镜像:</p><p><a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">官网下载镜像</a>，解压下载好的Zip文件会得到.img镜像文件。下载win32DiskImage</p><p>方式:</p><ul><li>SSH</li><li>VNC</li><li>Xrdp</li></ul><p>系统设置:</p><p>$ sudo raspi-reconfig</p><p>1.安装字体</p><blockquote><p>默认安装的是英文字体，如果时区选择中文，将会乱码，因此需要安装中文字体进行汉化。</p></blockquote><p><code>sudo apt-get install ttf-wqy-zenhei</code></p><p>2.安装中文输入发</p><p>3.修改键盘布局</p><blockquote><p>键盘布局默认是英标的，需要将其改成美标</p></blockquote><p>输入<code>sudo dpkg-reconfigure keyboard-configuration</code>后选择通用的104键PC键盘(Generic 104 Key PC),在Layout中选择Ohter,然后在选项中选择English(US)，然后不断选择OK退出即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装系统镜像:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.raspberrypi.org/downloads/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网下载镜像&lt;/a&gt;，解压下载好的Zip文件会得到.img镜像文件。下载win32D
      
    
    </summary>
    
    
      <category term="嵌入式" scheme="https://nymrli.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ACM-网络流</title>
    <link href="https://nymrli.top/2019/12/08/ACM-%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>https://nymrli.top/2019/12/08/ACM-网络流/</id>
    <published>2019-12-08T11:03:34.000Z</published>
    <updated>2019-12-08T11:48:50.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大流"><a class="markdownIt-Anchor" href="#最大流"></a> 最大流</h1><h2 id="ff算法"><a class="markdownIt-Anchor" href="#ff算法"></a> FF算法</h2><blockquote><p>最基本找増广路的算法</p></blockquote><h3 id="dinic实现基础的ff算法"><a class="markdownIt-Anchor" href="#dinic实现基础的ff算法"></a> dinic实现(基础的FF算法)</h3><blockquote><p><strong>反边</strong>：我们知道，当我们在寻找增广路的时候，在前面找出的不一定是最优解，如果我们在减去残量网络中正向边的同时将相对应的反向边加上对应的值，我们就相当于可以反悔从这条边流过。</p></blockquote><p>技巧：flow[u]正边，flow[u^1]反边<br>建边的时候是同时建的，比如1的反边为2，2的反边为1，▲边不能从0开始</p><p>主要思路：</p><ul><li>求增广路</li><li>分层图</li></ul><h4 id="dinic的优化"><a class="markdownIt-Anchor" href="#dinic的优化"></a> dinic的优化</h4><ul><li><p>当前弧优化(作用不明显)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最原始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now==aim)<span class="keyword">return</span> fl;</span><br><span class="line">    <span class="keyword">int</span> f=e;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=fir[now];u &amp;&amp; fl;u=nxt[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(flow[uj&amp;&amp;deep[to[u]]==deep[now]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=dfs(to[u],min(fl,flow[u]));</span><br><span class="line">            flow[u]-=x;flow[u^<span class="number">1</span>]+=x;fl-=x;f+=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lf)deep[now]=<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前弧优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now==aim) <span class="keyword">return</span> fl;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 修改为curfir[now]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=curfir[now];u&amp;&amp;fl;u=nxt[u])&#123;</span><br><span class="line">        curfir=u;<span class="comment">// 加了此处</span></span><br><span class="line">        <span class="keyword">if</span>(flow[u]&amp;&amp;deep[to[u]]==deep[now]+<span class="number">1</span>)&#123;</span><br><span class="line">            int dfs(to[u],min(fl,flow[u]));</span><br><span class="line">            flow[u]-=x;flow[u^<span class="number">1</span>]+=x;fl-=x;f+=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)deep[now]=<span class="number">-2</span>;<span class="comment">// 炸点优化</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多路增广</p></li><li><p>炸点</p></li></ul><p><strong>最大流最小割定理</strong>：最小割总和的权值==最大流的值，对于每张图都是成立的。（网络流的对称形式）</p><p>具体代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;<span class="comment">// 外层循环</span></span><br><span class="line">aim = T;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs(s, t))&#123;</span><br><span class="line">ret += dfs(s, <span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;<span class="comment">// 建立分层图</span></span><br><span class="line"><span class="built_in">memset</span>(deep,<span class="number">0</span>,(tot+<span class="number">2</span>)&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    deep[S]=<span class="number">1</span>;d1[<span class="number">1</span>]=S;<span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head!=tail)&#123;</span><br><span class="line">    <span class="keyword">int</span> v=dl[++head];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=fir[v];u;u=nxt[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(flow[u]&amp;&amp;!deep[to[u]])&#123;</span><br><span class="line">            deep[to[u]]=deep[v]+<span class="number">1</span>;</span><br><span class="line">            d1[++tail]=to[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fl)</span></span>&#123;<span class="comment">// dfs找増广路</span></span><br><span class="line">    <span class="keyword">if</span>(now==aim) <span class="keyword">return</span> fl;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// // 当前弧优化,修改为curfir[now]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=curfir[now];u&amp;&amp;fl;u=nxt[u])&#123;</span><br><span class="line">        curfir=u;<span class="comment">// 加了此处</span></span><br><span class="line">        <span class="keyword">if</span>(flow[u]&amp;&amp;deep[to[u]]==deep[now]+<span class="number">1</span>)&#123;</span><br><span class="line">            int dfs(to[u],min(fl,flow[u]));</span><br><span class="line">            flow[u]-=x;flow[u^<span class="number">1</span>]+=x;fl-=x;f+=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)deep[now]=<span class="number">-2</span>;<span class="comment">// 炸点优化</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ek算法"><a class="markdownIt-Anchor" href="#ek算法"></a> EK算法</h2><blockquote><p>引入了反相边：在原有的有向图上引入了反向的边，且容量相等</p></blockquote><p><strong>执行过程：</strong><br>BFS找増广路</p><ul><li>找到的话，更新最大流、残余网路</li><li>找不到则走完了</li></ul><p>两者的思想都是：找増广路，找到找不到为止</p><p>参考:</p><p><a href="https://www.bilibili.com/video/av18567992?p=1" target="_blank" rel="noopener">最大流（最小割）的EK算法</a></p><h1 id="最小费用最大流"><a class="markdownIt-Anchor" href="#最小费用最大流"></a> 最小费用最大流</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最大流&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#最大流&quot;&gt;&lt;/a&gt; 最大流&lt;/h1&gt;
&lt;h2 id=&quot;ff算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ff算法&quot;&gt;&lt;/a&gt; FF算法&lt;/h2&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ACM-树状数组和线段树</title>
    <link href="https://nymrli.top/2019/12/07/ACM-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://nymrli.top/2019/12/07/ACM-树状数组和线段树/</id>
    <published>2019-12-07T05:04:53.000Z</published>
    <updated>2019-12-08T11:44:32.293Z</updated>
    
    <content type="html"><![CDATA[<p><strong>高性能问题：</strong><br>Q：需求：（老板给你分了台2GHz单核，内存500M的服务器然后让你写程序）程序每秒会收到一组数据，每组数据包含10万条命令，总共会有100万个仓库，每个仓库库存没有上限且可为负，库存初始为0。<strong>你需要在一秒内完成全部的命令</strong>，然后将查询结果按顺序得出后传回，命令如下：</p><ul><li><code>Add i j</code>，i和j为正整数，表示第i个仓库增加j个库存（j不超过220）</li><li><code>Sub i j</code>，i和j为正整数，表示第i个仓库减少个库存（j不超过220）</li><li><code>Query i j</code>，i和j为正整数，i&lt;=j，表示询问第i到第个仓库的总库存；End 表示结束，这条命令在每组数据最后出现；</li></ul><p>思路一：用array去存储每个仓库的容量，在查询时用循环取出(L,R)的总容量。此时Update为O(1)，Query为O(N)</p><p>思路二：<strong>前缀数组和</strong>：在array1储存每个仓库容量的同时维护array2来记录前n个仓库的总容量，当计算某个区间的容量(L,R)可以通过s[R]-s[L-1]求出。此时Query为O(1)，但Update为O(N)</p><p>思路三：树状数组：Update和Query的时间复杂度进行折中后都为O(logN)</p><h1 id="树状数组"><a class="markdownIt-Anchor" href="#树状数组"></a> 树状数组</h1><blockquote><p>又叫二叉索引树，最早是为了解决数据压缩里的累积频率问题，现多用来解决数组区间查询问题的数据结构，即高效解决数列的<strong>前缀和</strong>、<strong>区间和</strong>问题。</p></blockquote><h2 id="low-bit算法"><a class="markdownIt-Anchor" href="#low-bit算法"></a> low bit算法</h2><blockquote><p>核心：将一个数拆分成若干个二进制数相加，原理：每一个数都有二进制表示，即所有数都可以表示成x个不同的2的幂之和。</p><p>做法：找到二进制最后低一位1表示的数。<br>代码：通过计算<code>n&amp;-n</code>找到n最右边的1。</p></blockquote><p>举个栗子：<br>Q： 6可以怎么计算得到呢？<br>A： 6==0110，i=110，通过lowbit可以拆分成两个数100+010=110</p><p>因此树状数组的维护更新过程如下：已知i=6<br>①S+= C[6]<br>②找到<strong>i</strong>最右边的1，即得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mn>10</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><msub><mo stretchy="false">)</mo><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">lowbit=(10)_{2}=(2)_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>③更新i:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>i</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0110</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>−</mo><mo stretchy="false">(</mo><mn>0010</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>0100</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">i&#x27;= i - lowbit = (0110)_{2}-(0010)_{2}=(0100)_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mn>6</mn><mo>−</mo><mn>2</mn><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><msub><mo stretchy="false">)</mo><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">i&#x27;=6-2=(4)_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；<br>④S+= C[4]<br>⑤再继续找<strong>i</strong>最右边的1，即得到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mn>100</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><msub><mo stretchy="false">)</mo><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">lowbit=(100)_{2}=(4)_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<br>⑥更新i:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>i</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0100</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>−</mo><mo stretchy="false">(</mo><mn>0100</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>0000</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">i&#x27;= i - lowbit =(0100)_{2}-(0100)_{2}=(0000)_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<br>⑦此时i最右边无1(即全零为0)，算法结束，即最终C[6]=C[4] + C[2]</p><h2 id="计算步骤"><a class="markdownIt-Anchor" href="#计算步骤"></a> 计算步骤：</h2><ol><li>找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(n)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>最右边的1的数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mn>1</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(n1)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>更新<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mn>1</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n&#x27;=(n)_2 - (n1)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mi>n</mi><mo mathvariant="normal">′</mo></msup><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(n&#x27;)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>还能找到1，那么重复1-2</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">1e6</span> + <span class="number">5</span></span><br><span class="line">arr = [<span class="number">0</span>] * N</span><br><span class="line"><span class="comment"># 自底向上建树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(i, j)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    修改第i仓库Ci。但注意执行某个仓库的update操作，后面所有仓库都得更新</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= N:</span><br><span class="line">        arr[i] += j </span><br><span class="line">        <span class="comment"># 加上low bit位</span></span><br><span class="line">        i += i&amp;-i</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(i, j)</span>:</span></span><br><span class="line">    add(i, -j)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    通过Ci求出1-i仓库的总库存</span></span><br><span class="line"><span class="string">    S[6] = C[6] + C[4], 推导如下:</span></span><br><span class="line"><span class="string">    如果i=6,那么</span></span><br><span class="line"><span class="string">    ans += c[6] , i &lt;- i-2 = 6-2 = 4,</span></span><br><span class="line"><span class="string">    ans += c[4] , i &lt;- i-4 = 4-4 = 0</span></span><br><span class="line"><span class="string">    ∴ans = c[6] + c[4] = A[6]+A[5]+A[4]+A[3]+A[2]+A[1]</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        ans += arr[i]</span><br><span class="line">        i -= i&amp;(-i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def query(i, j);</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">查询某个区间的总库存，sum(i, j) = S(R) - S(L-1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">return</span> sum(j) - sum(i<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>符号说明：</p><ol><li><p>Ai：第i个仓库的库存数</p></li><li><p>Ci：所构建的数的第i个节点的值，C[i] = A[i-lowbit(i)+1] + …+A[i]</p></li><li><p>Si：第1个仓库到第i个仓库库存数之和</p></li><li><p>Ans（i，j）：显然就等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>R</mi></msub><mo>−</mo><msub><mi>S</mi><mrow><mi>L</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{R}-S_{L-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p></li></ol><h2 id="形式"><a class="markdownIt-Anchor" href="#形式"></a> 形式</h2><p>一.从原数组A[],维护树状数组C[]</p><p>▲lowbit又叫子叶数，表示了有多少个A[]相加，C[i]表示从C[i] = A[i-lowbit(i)+1] + …+A[i] (&lt;===&gt;C[i] = A[i-2^x+1] + … + A[i])，</p><p>For Example： i=6</p><p><img src="/2019/12/07/ACM-树状数组和线段树/t2.jpg" alt="t2"></p><p><img src="/2019/12/07/ACM-树状数组和线段树/t.jpg" alt="t"></p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h2><p><a href="https://www.bilibili.com/video/av26371798/?spm_id_from=333.788.videocard.1" target="_blank" rel="noopener">树状数组</a>——黑板讲解,NICE</p><p><a href="https://www.bilibili.com/video/av54027849/?spm_id_from=333.788.videocard.9" target="_blank" rel="noopener">树状数组算法</a>——初步了解，有些点讲的并不那么纤细</p><p><img src="/2019/12/07/ACM-树状数组和线段树/t3.jpg" alt="t3"></p><p>洛谷:<a href="https://www.luogu.com.cn/problem/P3374" target="_blank" rel="noopener"> P3374 【模板】树状数组 1</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500000 + 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = i;</span><br><span class="line">    <span class="keyword">while</span> (index&lt;=N)&#123;</span><br><span class="line">        c[index] += k;</span><br><span class="line">        index += index&amp;(-index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index)&#123;</span><br><span class="line">        ans += c[index];</span><br><span class="line">        index -= index&amp;(-index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(r) - sum(l<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">        add(i, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="keyword">int</span> x, k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op &gt;&gt; x &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (op==<span class="number">1</span>) add(x, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; query(x, k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h1><p>在求解前缀和、区间和问题上，两者是没有差别的，并且树状数组的空间复杂度更低。但是线段树还有更多的功能，比如求取区间最大值。</p><blockquote><p>完满二叉树(Full Binary Tree)<br>根据元素的下标进行划分<br>一个节点代表一个区间的信息</p></blockquote><h2 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点：</h2><ul><li>每个节点维护一个闭区间<a href="1%3C=r">1,r</a>的信息。</li><li>根节点表示[1,n]的信息。如果1=r那就是叶子结点.</li><li>如果1&lt;r那就是内部节点,它有两个子节点[1,(1+r)/2]，[(1+r)/2+1,r].</li></ul><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用1表示根节点。</span></span><br><span class="line"><span class="comment">下标为x的点的左子节点下标为2x，右子节点2x+1。</span></span><br><span class="line"><span class="comment">用sum[x]表示x代表的区间里所有数的和。</span></span><br><span class="line"><span class="comment">对于叶子结点x，它代表[1，r]（1=r），sum[x]=a[1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 更新某个节点X的值</span></span><br><span class="line">sum[x]= sum[x*<span class="number">2</span>] + sum[x*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建, 自顶向下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于存储在i号位置的节点，它的左孩子存在2i号位置，右孩子2i+1号位置。</span></span><br><span class="line"><span class="comment">同时我们也不需要记录每个位置对应的区间，只要在递归的找这个点的时候边找边修改即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> <span class="number">1</span>,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;<span class="comment">//叶子结点</span></span><br><span class="line">        sum[x]=a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(<span class="number">1</span>+r)&gt;〉<span class="number">1</span>;</span><br><span class="line">    build(<span class="number">1</span>,mid,x*<span class="number">2</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    update(x);<span class="comment">//更新信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设询问区间是[A,B],现在所在的节点表示的区间为[1,r]- 计算mid=(1+r)/2,左子节点的区间为[1,mid],右子节点的区间为[mid+1,r].</span></span><br><span class="line"><span class="comment">如果A&lt;=mid,即询问区间与左子节点有重合,需要递归到左子节点。</span></span><br><span class="line"><span class="comment">如果B&gt;=mid+1,即询问区间与右子节点有重合,需要递归到右子节点。</span></span><br><span class="line"><span class="comment">递归完之后,需要把两个孩子询问的结果加起来作为返回值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> A,<span class="keyword">int</span> B,<span class="keyword">int</span> <span class="number">1</span>,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A&lt;=<span class="number">1</span>&amp;&amp;r&lt;=B)</span><br><span class="line">    <span class="keyword">return</span> sum[x];</span><br><span class="line">    <span class="keyword">int</span> mid=(<span class="number">1</span>+r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A&lt;=mid)</span><br><span class="line">    ans+=query(A,B,<span class="number">1</span>,mid,x*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;B)</span><br><span class="line">    ans+=query(A,B,mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由于修改是对单个元素进行修改。</span></span><br><span class="line"><span class="comment">比如修改第i个元素。</span></span><br><span class="line"><span class="comment">我们先找到[i，i]所在的节点，然后修改它的sum，然后一路向上更新每个祖先的sum即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> v,<span class="keyword">int</span> <span class="number">1</span>,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( l==r)&#123; <span class="comment">//找到了要修改的叶子结点</span></span><br><span class="line">            sum[x]=v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=(<span class="number">1</span>+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)<span class="comment">//pos在左子节点</span></span><br><span class="line">        change(pos,v,<span class="number">1</span>,mid,x*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        change(pos,v,mid+<span class="number">1</span>,r,x*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        update(x);<span class="comment">//一定要加！因为这条路上的sum值发生了改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性质"><a class="markdownIt-Anchor" href="#性质"></a> 性质</h2><ul><li>节点数：假设线段树处理的数列长度为n，即根节点的区间为[1，n].那么结点数不超过2n个.因此线段树的空间复杂度是0（n）。是完满二叉树(Full Binary Tree)，但一般申请4*n的空间大小</li><li>深度：可以看作满二叉树，深度不超过log2(n-1)+1</li><li>线段树能把区间上的任意一条长度为L的线段都分成不超过2*log(L)条线段。</li></ul><p>注意：</p><ul><li>由于链表表示的内存是不连续的，且申请指针比较费时间，所以采用数组矩阵的形式存储。</li><li>数组存储也有一点不好，因为线段树并不是真正的完全二叉树。<br>最后一层可能很空。且空节点的数量可以达到2n个。<br>因此维护长度为n的序列，用数组存线段树的话，最好要开到4*n的长度，才能保证数组不越界。</li></ul><h2 id="形式-2"><a class="markdownIt-Anchor" href="#形式-2"></a> 形式</h2><p><img src="/2019/12/07/ACM-树状数组和线段树/%E7%BA%BF%E6%AE%B5%E6%A0%91.jpg" alt="线段树"></p><p>例题：</p><p>Q：对于第i个数，我们要统计前面有多少个数大于a[i]。<br>对每个数都统计一遍加起来即是答案。<br>假设我们可以对[0，109]建一个线段树（实际上太大了）每次先查询[a[i]+1，109]的区间和，加入答案。</p><p>e.g.如果一个值为1，一个值为10<sup>8，那么要开10</sup>8大小</p><p>Solve: 10^9范围太大了，因此我们先要对n个数进行<strong>离散化</strong>。离散化的过程，就是对n个数进行排序，<strong>最小的数赋值为1</strong>，<strong>第二小的赋值为2</strong>，以此类推，这样n个数的取值范围就在[1，n]中了。</p><p>e.g.上面的情况，将会把1–&gt;1,10^8–&gt;2,那么只要开长度为2的线段树就够了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 离散化代码，假设对a[1,2...,n]进行离散化</span></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i ++)</span><br><span class="line">    <span class="comment">// 另外的数组存储</span></span><br><span class="line">bin[++cnt]=a[i];</span><br><span class="line">sort(bin+<span class="number">1</span>,bin+n+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 消重</span></span><br><span class="line">cnt=unique(bin+<span class="number">1</span>,bin+cnt+<span class="number">1</span>)-bin<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(inti=<span class="number">1</span>;i&lt;=n;i ++)</span><br><span class="line">a[i]=lower_bound(bin+<span class="number">1</span>,bin+cnt+<span class="number">1</span>,a[i])-bin;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.bilibili.com/video/av37087480?p=2" target="_blank" rel="noopener">高中信息学竞赛线段树与树状数组</a>——万门教育</p><p><a href="https://www.bilibili.com/video/av9350697?from=search&amp;seid=15345495634828896152" target="_blank" rel="noopener">SWPU-ACM每周算法讲堂-线段树入门（一）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;高性能问题：&lt;/strong&gt;&lt;br&gt;
Q：需求：（老板给你分了台2GHz单核，内存500M的服务器然后让你写程序）程序每秒会收到一组数据，每组数据包含10万条命令，总共会有100万个仓库，每个仓库库存没有上限且可为负，库存初始为0。&lt;strong&gt;你需要在
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KM(Kuhn-Munkres)算法</title>
    <link href="https://nymrli.top/2019/12/05/KM-Kuhn-Munkres-%E7%AE%97%E6%B3%95/"/>
    <id>https://nymrli.top/2019/12/05/KM-Kuhn-Munkres-算法/</id>
    <published>2019-12-05T13:52:58.000Z</published>
    <updated>2019-12-10T14:15:29.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kmkuhn-munkres算法"><a class="markdownIt-Anchor" href="#kmkuhn-munkres算法"></a> KM(Kuhn-Munkres)算法</h1><blockquote><p>带权二分图最佳完美匹配，O(n^3)，（运用匈牙利算法辅助求解），同时也是完备匹配</p></blockquote><ol><li>只适用于带权最大匹配一定是完备匹配的情况，实践中建议用费用流来解决。</li><li>完全二分图一定是偶数个点</li><li><strong>可行顶标</strong>（Feasible Labeling）：结点函数（x），任意边（x，y）：1（x）+l（y）≥w（xiy）。</li><li><strong>相等子图</strong>：G的生成子图，包含所有点以及满足l（x）+I（y）=w（x，y）的边（x，y）</li><li>如果EL有完美匹配为PM，则该M是原图的最大权匹配：<ul><li>PM的权和等于所有点的顶标之和SV。</li><li>G的任一个最大权匹配M，边满足w（xy）≤l（x）+（y）→M边权和≤SV=PM边权和</li><li>关键就是寻找好的可行顶标，使相等子图有完美匹配。</li></ul></li></ol><p>==&gt;找到原图的完美匹配–只要–&gt;找到相等子图的完美匹配即可</p><p>▲KM完成之后所有的l(x)之和最小</p><h2 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h2><p>一般对KM算法的描述，基本上可以概括成以下几个步骤：<br><strong>1.用邻接矩阵（或其他方法也行啦）来储存图。</strong><br><strong>2.运用贪心算法初始化标杆。</strong><br><strong>3.运用匈牙利算法找到完备匹配。</strong><br><strong>4.如果找不到，则通过修改标杆，增加一些边。</strong><br><strong>5.重复3，4的步骤，直到完全匹配时可结束。</strong></p><p>二分图匹配里面我们找最大边进行连边!但是遇到某个点被匹配了两次怎么办？<br>那就用匈牙利算法进行<strong>更改匹配</strong>！</p><p>这就是KM算法的思路了：<strong>尽量找最大的边进行连边，如果不能则换一条较大的</strong>。</p><h2 id="找对象例子理解重点"><a class="markdownIt-Anchor" href="#找对象例子理解重点"></a> 找对象例子理解重点：</h2><ol><li>女生的每轮选择都是从第一个男生开始往后选择一个男生，使男女两人的<strong>期望和要等于两人之间的好感度</strong>。</li><li>注意：每一轮匹配，<strong>每个男生只会被尝试匹配一次！</strong></li><li>如果找对象失败，那么此时参与匹配过的女生期望值都降低d，本轮被选择的男生期望值都增加d：d为<u>任意一个</u><strong>这轮参与过匹配的女生</strong>能<em><strong>换到***<u>任意一个</u><strong>这轮没有被选择过的男生</strong>所需要</strong>降低的最小值</em>*（遍历左边已配对的X，标杆值Lx，与右边<strong>这一轮</strong>没被选择过的男生Y，标杆值Ly，挑出需要降低的最小值，即 d=min(Lx+Ly-W, d) ）</li></ol><h2 id="复杂度"><a class="markdownIt-Anchor" href="#复杂度"></a> 复杂度</h2><p>朴素的实现方法，时间复杂度为O(n4)——需要找O(n)次增广路，每次增广最多需要修改O(n)次顶标，每次修改顶标时由于要枚举边来求d值，复杂度为O(n2)。</p><p>实际上KM算法的复杂度是可以做到O(n3) 的。我们给每个Y顶点一个“松弛量”函数slack，每次开始找增广路时初始化为无穷大。在寻找增广路的过程中，检查边(i,j)时，如果它不在相等子图中，则让slack[j]变成原值与A[i]+B[j]-w[i,j]的较小值。这样，在修改顶标时，取所有不在交错树中的Y顶点的slack值中的最小值作为d值即可。但还要注意一点：修改顶标后，要把所有的slack值都减去d。（即用在执行匈牙利算法的时候，进行对slack的更新，从而减少一层找到最小d的循环）</p><h2 id="举个栗子"><a class="markdownIt-Anchor" href="#举个栗子"></a> 举个栗子:</h2><h3 id="少林决胜golden-tiger-clawuva11383"><a class="markdownIt-Anchor" href="#少林决胜golden-tiger-clawuva11383"></a> <strong>少林决胜(Golden Tiger Claw，UVa11383)</strong></h3><p>给定一个N*N矩阵，每个格子里都有一个正整数w(i,j)。你的任务是给每行确定一个整数row(i)，每列也确定一个整数col(i)，使得对于任意格子(i, j)，w(i, j)≤row(i)+colj)。所有row(i)和col(i)之和应尽量小。</p><p>【分析】<br>1.行看作二分图X点，列看作二分图Y点。<br>2.和最佳匹配没有任何关系，KM算法副产品。<br>3.KM中算法等式l（x）+l（y）≥w（x，y）。行X，列Y。<br>4.KM过程中，所有顶标不断减小，算法结束后，所有顶标之和是最小的。</p><h3 id="蚂蚁antsneerc2008la4043"><a class="markdownIt-Anchor" href="#蚂蚁antsneerc2008la4043"></a> <strong>蚂蚁（Ants，NEERC2008，LA4043）</strong></h3><p>给出n个白点和n个黑点的坐标，要求用n条不相交的线段把它们连接起来，其中每条线段恰好连接一个白点和一个黑点，每个点恰好连接到一条线段，如图所示。</p><p>【分析】</p><ol><li>点有黑白两色，构造二分图，白X黑Y。每个黑点和每个白点相连，权值等于欧氏距离。</li><li>连接方案实际上是计算一个完美匹配，匹配中假设al-b1与a2-b2相交，那么<code>dist(a1，b1)+dist(a2，b2)&gt;dist(al，b2)+dist(a2，b1)</code>，这两条线段改成al-b2和a2-b1后总长度会变少。</li><li>所以最小匹配中不会出现线段相交。</li><li>套KM算法即可计算最小完美匹配即可。</li></ol><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2><h3 id="on3代码"><a class="markdownIt-Anchor" href="#on3代码"></a> O(n^3)代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// X为女生节点， Y为男生节点</span></span><br><span class="line"><span class="keyword">int</span> love[MAXN][MAXN];   <span class="comment">// 记录每个妹子和每个男生的好感度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ex_girl[MAXN];      <span class="comment">// 每个妹子的期望值</span></span><br><span class="line"><span class="keyword">int</span> ex_boy[MAXN];       <span class="comment">// 每个男生的期望值</span></span><br><span class="line"><span class="keyword">bool</span> vis_girl[MAXN];    <span class="comment">// 记录每一轮匹配匹配过的女生</span></span><br><span class="line"><span class="keyword">bool</span> vis_boy[MAXN];     <span class="comment">// 记录每一轮匹配匹配过的男生</span></span><br><span class="line"><span class="keyword">int</span> match[MAXN];        <span class="comment">// 记录每个男生匹配到的妹子 如果没有则为-1</span></span><br><span class="line"><span class="keyword">int</span> slack[MAXN];        <span class="comment">// 记录每个汉子如果能被妹子倾心最少还需要多少期望值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> girl)</span></span>&#123;</span><br><span class="line">    vis_girl[girl] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> boy = <span class="number">0</span>; boy &lt; N; ++boy) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vis_boy[boy]) <span class="keyword">continue</span>; <span class="comment">// 每一轮匹配 每个男生只尝试一次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> gap = ex_girl[girl] + ex_boy[boy] - love[girl][boy];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gap == <span class="number">0</span>) &#123;  <span class="comment">// 如果符合要求</span></span><br><span class="line">            vis_boy[boy] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[boy] == <span class="number">-1</span> || dfs( match[boy] )) &#123;    <span class="comment">// 找到一个没有匹配的男生 或者该男生的妹子可以找到其他人</span></span><br><span class="line">                match[boy] = girl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slack[boy] = min(slack[boy], gap);  <span class="comment">// slack 可以理解为该男生要得到女生的倾心 还需多少期望值 取最小值 备胎的样子【捂脸</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ▲初始化有关被选择的男生的量1-2 [选择他的女生、男生方标杆]</span></span><br><span class="line">    <span class="built_in">memset</span>(match, <span class="number">-1</span>, <span class="keyword">sizeof</span> match);    <span class="comment">// 初始每个男生都没有匹配的女生</span></span><br><span class="line">    <span class="built_in">memset</span>(ex_boy, <span class="number">0</span>, <span class="keyword">sizeof</span> ex_boy);   <span class="comment">// 初始每个男生的期望值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ▲初始化3 [女生方的标杆]</span></span><br><span class="line">    <span class="comment">// 每个女生的初始期望值是与她相连的男生最大的好感度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        ex_girl[i] = love[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            ex_girl[i] = max(ex_girl[i], love[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试为每一个女生解决归宿问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ▲初始化4 [slack-找到最小的d]</span></span><br><span class="line">        fill(slack, slack + N, INF);    <span class="comment">// 因为要取最小值 初始化为无穷大</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 为每个女生解决归宿问题的方法是 ：如果找不到就降低期望值，直到找到为止</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化5-6 [该轮中那些女生已经尝试匹配过，该轮中那些男生被选择过]</span></span><br><span class="line">            <span class="comment">// 记录每轮匹配中男生女生是否被尝试匹配过</span></span><br><span class="line">            <span class="built_in">memset</span>(vis_girl, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis_girl);</span><br><span class="line">            <span class="built_in">memset</span>(vis_boy, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis_boy);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dfs(i)) <span class="keyword">break</span>;  <span class="comment">// 找到归宿 退出</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不能找到 就降低期望值</span></span><br><span class="line">            <span class="comment">// 最小可降低的期望值</span></span><br><span class="line">            <span class="keyword">int</span> d = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">                <span class="keyword">if</span> (!vis_boy[j]) d = min(d, slack[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">// 所有访问过的女生降低期望值</span></span><br><span class="line">                <span class="keyword">if</span> (vis_girl[j]) ex_girl[j] -= d;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 所有访问过的男生增加期望值</span></span><br><span class="line">                <span class="keyword">if</span> (vis_boy[j]) ex_boy[j] += d;</span><br><span class="line">                <span class="comment">// 没有访问过的boy 因为girl们的期望值降低，距离得到女生倾心又进了一步！</span></span><br><span class="line">                <span class="keyword">else</span> slack[j] -= d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配完成 求出所有配对的好感度的和</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        res += love[ match[i] ][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;love[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, KM());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>裸题:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2255" target="_blank" rel="noopener">HDU2255 奔小康赚大钱</a><br>输入数据包含多组测试用例，每组数据的第一行输入n,表示房子的数量(也是老百姓家的数量)，接下来有n行,每行n个数表示第i个村名对第j间房出的价格(n&lt;=300)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2// 一共有两个房子</span><br><span class="line">100 10// 村民1对第一间出价100, 第二间10</span><br><span class="line">15 23   // 村民1对第一间出价15, 第二间23</span><br><span class="line">Sample Output</span><br><span class="line">123// 第一间给1,第二间给2</span><br></pre></td></tr></table></figure><p>获得其他数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    N = <span class="number">3</span>;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = rand() % <span class="number">3</span>*N + <span class="number">1</span>;</span><br><span class="line">            love[i][j] = tmp;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, love[i][j] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, KM());</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, match[i], i);</span><br><span class="line">        sum += love[match[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"和最大：%d\n"</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            love[i][j] = -love[i][j] ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, love[i][j] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"和最小：%d\n"</span>, -KM());</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, match[i], i);</span><br><span class="line">        sum += love[match[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">4 1 7 </span></span><br><span class="line"><span class="comment">1 4 7 </span></span><br><span class="line"><span class="comment">1 7 4 </span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">0-&gt;0</span></span><br><span class="line"><span class="comment">2-&gt;1</span></span><br><span class="line"><span class="comment">1-&gt;2</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">-4 -1 -7 </span></span><br><span class="line"><span class="comment">-1 -4 -7 </span></span><br><span class="line"><span class="comment">-1 -7 -4 </span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">1-&gt;0</span></span><br><span class="line"><span class="comment">0-&gt;1</span></span><br><span class="line"><span class="comment">2-&gt;2</span></span><br><span class="line"><span class="comment">-6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料：</h2><p><a href="https://www.cnblogs.com/Lanly/p/6291214.html" target="_blank" rel="noopener">二分图匹配之最佳匹配——KM算法</a></p><p><a href="https://blog.csdn.net/chenshibo17/article/details/79933191" target="_blank" rel="noopener">KM算法详解+模板</a>——男女相亲匹配</p><p><a href="https://blog.csdn.net/NIeson2012/article/details/94472313" target="_blank" rel="noopener">带你入门多目标跟踪（三）匈牙利算法&amp;KM算法</a>——以图像目标跟踪距离</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kmkuhn-munkres算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#kmkuhn-munkres算法&quot;&gt;&lt;/a&gt; KM(Kuhn-Munkres)算法&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;带权二分图最佳完美匹配，O(n
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://nymrli.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>ACM-二分图</title>
    <link href="https://nymrli.top/2019/12/05/ACM-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>https://nymrli.top/2019/12/05/ACM-二分图/</id>
    <published>2019-12-05T09:45:57.000Z</published>
    <updated>2019-12-08T14:21:09.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分图的判定"><a class="markdownIt-Anchor" href="#二分图的判定"></a> 二分图的判定：</h1><p>染色法1：假设DFS初始点A涂黑色，与它相邻的点就涂白色。如果搜到某一个点u的相邻点v已经涂色并且与u同色，就不可能是二分图啦~</p><p>染色法2：就是给每个点进行标号，标为-1，1如果存在一条边连接的两个点标号相同，那么就是存在一个奇数环…</p><p>热身题：</p><h2 id="判断无向图是否有环"><a class="markdownIt-Anchor" href="#判断无向图是否有环"></a> 判断无向图是否有环</h2><blockquote><p>用DFS遍历图g，如果访问到已经访问过的顶点，那么有环</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100+5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 起点编号从0开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> en;                 <span class="comment">// 边数</span></span><br><span class="line">    <span class="keyword">int</span> vn;                 <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">map</span>[SIZE][SIZE];    <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> vis[SIZE];          <span class="comment">// 记录矩阵</span></span><br><span class="line">    <span class="keyword">bool</span> huan = <span class="literal">false</span>;      <span class="comment">// 是否有环</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">u: 当前节点节点</span></span><br><span class="line"><span class="comment">prev: 记录上一个节点</span></span><br><span class="line"><span class="comment">g: 图指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> prev, graph *g)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vn; ++v)&#123;    <span class="comment">// v为下一个可达的节点</span></span><br><span class="line">        <span class="comment">// 自己到自己为0, 是没有边的</span></span><br><span class="line">        <span class="keyword">if</span> (v == prev) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ( g-&gt;vis[v] != <span class="number">2</span> &amp;&amp; g-&gt;<span class="built_in">map</span>[u][v] )&#123;</span><br><span class="line">            g-&gt;vis[v] = <span class="number">1</span>;</span><br><span class="line">            dfs(v, u, g);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(g-&gt;vis[v] == <span class="number">2</span> &amp;&amp; g-&gt;<span class="built_in">map</span>[u][v] )&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"now: %d %d\n"</span>,u ,v );</span><br><span class="line">             g-&gt;huan = <span class="literal">true</span>;</span><br><span class="line">             <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(<span class="keyword">const</span> graph *g)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vn; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vn; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"v:%d\t"</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g-&gt;vn; ++j)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, g-&gt;<span class="built_in">map</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    graph *g = <span class="keyword">new</span> graph();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;g-&gt;vn, &amp;g-&gt;en);</span><br><span class="line">    <span class="built_in">memset</span>(g-&gt;<span class="built_in">map</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*g-&gt;en*g-&gt;vn);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g-&gt;en; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        g-&gt;<span class="built_in">map</span>[u][v] = g-&gt;<span class="built_in">map</span>[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    showGraph(g);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vn; ++i)&#123;</span><br><span class="line">        <span class="comment">// 如果节点i没被访问过</span></span><br><span class="line">        <span class="keyword">if</span> (g-&gt;vis[i] == <span class="number">0</span> &amp;&amp; g-&gt;huan == <span class="literal">false</span>)&#123;</span><br><span class="line">            g-&gt;vis[i] = <span class="number">2</span>;</span><br><span class="line">            dfs(i, <span class="number">-1</span>, g);</span><br><span class="line">            g-&gt;vis[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(g-&gt;huan == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;huan) <span class="built_in">printf</span>(<span class="string">"有环\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"无环\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断一个环是否为奇数环"><a class="markdownIt-Anchor" href="#判断一个环是否为奇数环"></a> <a href="https://www.cnblogs.com/ziyi--caolu/p/3632644.html" target="_blank" rel="noopener">判断一个环是否为奇数环</a></h2><p><a href="http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1356" target="_blank" rel="noopener">1356: Catch</a></p><p>题意：给出一个起始点，一些边，有人从这个起始点开始随意走，问在某一个时候，它是否可以处于任意位置。</p><p>思路：思考下，就可以明白，只要是一个联通图，并且存在奇数点形成的环，那么在某一个时候就可以处于任意位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最大匹配数匈牙利算法"><a class="markdownIt-Anchor" href="#最大匹配数匈牙利算法"></a> 最大匹配数——匈牙利算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line[maxn][maxn]; <span class="comment">// 邻接矩阵,表示男生是否有好感(可达)</span></span><br><span class="line"><span class="keyword">int</span> used[maxn];       <span class="comment">// 在位男生i匹配的那轮中,女生i是否被尝试过匹配</span></span><br><span class="line"><span class="keyword">int</span> nxt[maxn];        <span class="comment">// 如果匹配到了的话,那么男生是谁,女生i的对象为nxt[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为男生x匹配到一个女生i,如果匹配到的女生有主,那么让已配对女生的对象(男)修改匹配对象</span></span><br><span class="line"><span class="comment"> * @author mrli 2019-12-08</span></span><br><span class="line"><span class="comment"> * @param  x 男生</span></span><br><span class="line"><span class="comment"> * @return   男生x是否能匹配到女生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有妹子Y节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="comment">// 如果男生对女生互有好感(即边可达) 且 妹子没有匹配过</span></span><br><span class="line">        <span class="keyword">if</span> (line[x][i] &amp;&amp; !used[i])&#123;</span><br><span class="line">            <span class="comment">// 在男生该轮,将该女生i标记为已经被尝试匹配过</span></span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//  如果妹子没有对象  或者  已匹配到的男生是可以转移对象的</span></span><br><span class="line">            <span class="keyword">if</span> ( nxt[i]==<span class="number">0</span> || Find( nxt[i]) )&#123;</span><br><span class="line">                <span class="comment">// 将女生的已配对对象改为x</span></span><br><span class="line">                nxt[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为所有男生进行匹配</span></span><br><span class="line"><span class="comment"> * @author mrli 2019-12-08</span></span><br><span class="line"><span class="comment"> * @return 最大匹配数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 最大匹配数</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历所有男生X节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="comment">// 在男生i该轮,所有女生都没有被修改过匹配</span></span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">        <span class="comment">// 如果当前男生能找到匹配女生,那么最大匹配数++</span></span><br><span class="line">        <span class="keyword">if</span> (Find(i)) sum++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="comment">// XY节点数</span></span><br><span class="line">    n = m = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">memset</span>(line, <span class="number">0</span>, <span class="keyword">sizeof</span>(line));</span><br><span class="line">    <span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="keyword">sizeof</span>(nxt));</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        line[u][v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; match();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">4 3</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>拓展题:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2236" target="_blank" rel="noopener">无题II HDU2236</a></p><blockquote><p><strong>二分图</strong>：为什么会想到用二分图呢？<strong>不同行不同列</strong>，仔细想一下，如果某点（x,y），被选中，那么横坐标上x的值不能再选，纵坐标上的y值也不能再选，这相当于二维上有很多值，但是每个值都只能用一次，这就可以想到用二分图匹配求完美匹配了。</p><p><strong>二分答案</strong>：求n个数的最大最小的差值最小，首先这个差值一定是**0-(maxv-minv)**区间的，然后我们二分差值为外循环，枚举下界为内循环，得到一个区间。做法：修改二分图匹配模板：如果这个二分图的匹配点是在这个区间里的前去匹配，hungry()函数中返回是否为完美匹配，<u>对于每一个二分的差值，只要它能找到一个满足区间条件的完美匹配，就记录一下答案。</u></p></blockquote><p>Q：首先明白在求什么</p><p>A： 首先需要明白：图中每个数值X + 最大差值 &lt;= 最大值</p><p>我对上面的理解：</p><p>1.最大的差值是个具体的数值δ，最初可以确定的范围在[0, maxv - minv] 之间，因此可以通过二分搜索的方式来找到这个值==&gt;二分搜索</p><p>2.那怎么进行二分来缩小这个区间范围呢?Ans：如果符合<strong>最大差值</strong>的条件(表中所有数都满足 ：数值x+差值 &lt;= 最大值)，即所有点都能完成匹配，那么证明最大差值在这个区间中----&gt;完美匹配==&gt;匈牙利算法</p><p>▲所以算法变成了，不断缩小<u>最大差值</u>可以取值的区间，核心： 判断所有数是否在[p, p+差值]区间内</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line[maxn][maxn]; <span class="comment">// 邻接矩阵,表示男生是否有好感(可达)</span></span><br><span class="line"><span class="keyword">int</span> used[maxn];       <span class="comment">// 在位男生i匹配的那轮中,女生i是否被尝试过匹配</span></span><br><span class="line"><span class="keyword">int</span> nxt[maxn];        <span class="comment">// 如果匹配到了的话,那么男生是谁,女生i的对象为nxt[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, t, maxv, minv;</span><br><span class="line"><span class="keyword">int</span> l, r, mid;</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1 1 1 1</span></span><br><span class="line"><span class="comment">2 2 2 2</span></span><br><span class="line"><span class="comment">3 3 3 3</span></span><br><span class="line"><span class="comment">4 4 4 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="comment">// 修改模板：增加界定二分[p, p+mid]的区间</span></span><br><span class="line">        <span class="comment">// 判断边x是否还在[minv, minv+差值]之间</span></span><br><span class="line">        <span class="comment">/*if条件解释:执行过程分析</span></span><br><span class="line"><span class="comment">        如题,l=0, r=4,</span></span><br><span class="line"><span class="comment">        第一次mid=2,p=1, 此时并不是所有点都在[1, 1+2]之间,所以匹配失败</span></span><br><span class="line"><span class="comment">        因为1+2&lt;=4(maxv),所以p++后再进入,此时mid=2,p=2,此时仍然不是所有点在这个范围[2,2+2]内,所以失败,第一次二分失败,区间不在[l,mid]即[0,2]之间</span></span><br><span class="line"><span class="comment">  第二次更新l=mid+1=2+1=3,mid=(3+4)/2=3</span></span><br><span class="line"><span class="comment">  p=1时,判断是否所有点都在[1,1+3]范围,==&gt;结果是的,hungarian返回true,二分确定在[mid, r]即[3,4]之间,更新r=mid-1=3,mid=(l+r)/2=3,此时有l=r=3所以找到了最大差值mid</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(p &lt;= line[x][i] &amp;&amp; line[x][i]&lt;= p+mid &amp;&amp; !used[i])&#123;</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( nxt[i]==<span class="number">0</span> || Find( nxt[i]) )&#123;</span><br><span class="line">                nxt[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungarian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这边改了，每次都是新情况</span></span><br><span class="line">    <span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="keyword">sizeof</span>(nxt));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">        <span class="keyword">if</span> (Find(i)) sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改模板</span></span><br><span class="line">    <span class="keyword">return</span> sum==n?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line">    m = n = size;</span><br><span class="line">        maxv = -inf;</span><br><span class="line">        minv = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= size; ++j)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; line[i][j];</span><br><span class="line">                maxv = max(maxv, line[i][j]);</span><br><span class="line">                minv = min(minv, line[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = maxv - minv;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 二分搜索，不断缩小区间</span></span><br><span class="line">        <span class="keyword">while</span>( l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            mid = (l+r) &gt;&gt; <span class="number">1</span>;<span class="comment">// mid为差值</span></span><br><span class="line">            <span class="comment">// 遍历下界的搜索,枚举最小值，检查当前差值是否可以匹配成功,条件是“最小值+差值&lt;=最大值”</span></span><br><span class="line">            <span class="comment">// 核心： 判断所有数是否在[p, p+差值]区间内</span></span><br><span class="line">            <span class="keyword">for</span> (p = minv; p+mid &lt;= maxv; ++p)&#123;</span><br><span class="line">                <span class="keyword">if</span> (hungarian())&#123;</span><br><span class="line">                <span class="comment">// 这句类似二分搜索里的if一旦找到哪个区间，就直接在这个区间里继续二分，</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 因为是从[min,min+mid]~[max-mid, max]的搜索,区间大小为mid,如果true,意思是最大差值mid就在[l, mid]之间</span></span><br><span class="line">            <span class="keyword">if</span> (flag) ans = mid,r = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 如果全不符合,那么区间小了,mid得大点,所以mid范围变为[mid, r]</span></span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 二分搜索中如果l==r，那么搜索数x的索引就是最后的mid</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最佳匹配km算法"><a class="markdownIt-Anchor" href="#最佳匹配km算法"></a> 最佳匹配——KM算法</h1><blockquote><p>解决有权的完美匹配问题，成为最佳匹配，又称为有权完美匹配。最佳匹配同时也是完备匹配</p></blockquote><p><a href="https://www.cnblogs.com/wenruo/p/5264235.html" target="_blank" rel="noopener">KM算法详解+模板</a>——含图讲解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二分图的判定&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#二分图的判定&quot;&gt;&lt;/a&gt; 二分图的判定：&lt;/h1&gt;
&lt;p&gt;染色法1：假设DFS初始点A涂黑色，与它相邻的点就涂白色。如果搜到某一个点u的相邻点v已经涂色并且与u同色，就不可能是
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://nymrli.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Hungarian algorithm匈牙利算法</title>
    <link href="https://nymrli.top/2019/12/05/Hungarian-algorithm%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    <id>https://nymrli.top/2019/12/05/Hungarian-algorithm匈牙利算法/</id>
    <published>2019-12-05T05:08:11.000Z</published>
    <updated>2019-12-22T13:50:20.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hungarian-algorithm匈牙利算法"><a class="markdownIt-Anchor" href="#hungarian-algorithm匈牙利算法"></a> Hungarian algorithm匈牙利算法</h1><blockquote><p>主要用来解决不带权的分配问题，O(V*E)</p></blockquote><p>首先，需要明白二分图（又名二部图）的概念</p><h2 id="二分图bipartite-graph"><a class="markdownIt-Anchor" href="#二分图bipartite-graph"></a> 二分图Bipartite Graph</h2><p>二分图是图论中一种特殊模型。设G=(V,E)是一个<strong>无向图</strong>(当且仅当图中不存在长度为奇数的环。)，如果顶点V可分割为<strong>两个互不相交</strong>的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j<strong>分别属于这两个不同的顶点集</strong>(i in A,j in B)，则称图G为一个二分图。</p><p>注意：如果一图是二分图，那么它<strong>一定没有奇环</strong>。如果一图没有奇环的话，那么它可以是二分图。(没有奇环是二分图的必要条件)</p><p>▲通常被用来解决分配、匹配问题，如资源分配、工作安排、任务调度……任务的核心本质是求配对关系，或者给顶点和边赋权，求某种条件下的最优分配问题。</p><p>△匹配问题可以用网络流解决，或者KM算法（KM算法是一种计算机算法，功能是求完备匹配下的最大权匹配），但是增广路算法更加简洁。</p><h3 id="二分图的判定"><a class="markdownIt-Anchor" href="#二分图的判定"></a> 二分图的判定：</h3><p>染色法1：假设DFS初始点A涂黑色，与它相邻的点就涂白色。如果搜到某一个点u的相邻点v已经涂色并且与u同色，就不可能是二分图啦~</p><p>染色法2：就是给每个点进行标号，标为-1，1如果存在一条边连接的两个点标号相同，那么就是存在一个奇数环…</p><h3 id="二分图的匹配"><a class="markdownIt-Anchor" href="#二分图的匹配"></a> 二分图的匹配</h3><ul><li><strong>匹配</strong>：将E的子集M称作一个<strong>匹配</strong>(子集M中的任意两条边都没有公共端点)</li><li><strong>最大匹配</strong>：边数最多的匹配称作最大匹配——maximal matching</li><li><strong>X(Y)完全匹配</strong>：如果X（Y）中的所有的顶点都出现在匹配M中，则称M是X(Y)完全匹配——perfect matching</li><li><strong>M完全匹配</strong>：如果M既是X-完全匹配，又是Y-完全匹配，称M是完全匹配。此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>Y</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|X| = |Y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span></span></span></span>，也就是说这个匹配里的所有边刚好经过所有点一次。</li></ul><h3 id="最大匹配和完全匹配的应用"><a class="markdownIt-Anchor" href="#最大匹配和完全匹配的应用"></a> 最大匹配和完全匹配的应用：</h3><p>Q：教师-课程安排，G=&lt;U,E,V&gt;，U为教师集合，V为课程集合，E中的边&lt;u,v&gt;表示某位教师u可以上课程v。需要求<strong>最大匹配</strong>，使得每门课程有人教，每人都有课上。</p><p>A:匈牙利算法</p><h2 id="匈牙利算法"><a class="markdownIt-Anchor" href="#匈牙利算法"></a> 匈牙利算法</h2><h3 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h3><p>①任意取一个匹配M（可以是空集或只有一条边）<br>②令S是非饱和点（尚未匹配的点）的集合自如果S=0，则M已经是最大匹配<br>④从S中取出一个非饱和点山作为起点，从此起点走交错路（交替属于M和非M的边构成的极大无重复点通路或回路）P<br>③如果P是一个增广路（P的终点也是非饱和点），则令M=MeP=（M-P）U（P-M）<br>⑥如果P都不是增广路，则从S中去掉uo，转到step3</p><p>▲.顶点数不同，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">≠</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|X| \neq |Y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span></span></span></span>的二分图一定没有完全匹配</p><p>▲正则的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">≠</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|X| \neq |Y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span></span></span></span>的二分图一定有完全匹配(正则:每个顶点的度数都相同)</p><p>核心思想：不断挪</p><h4 id="増广路定理"><a class="markdownIt-Anchor" href="#増广路定理"></a> 増广路定理：</h4><blockquote><p>任意一个非最大匹配的匹配一定存在增广路。</p></blockquote><ol><li>从一个未匹配点（未盖点）出发，<strong>依次</strong>经过<u>非匹配边</u>、<u>匹配边</u>、<u>非匹配边</u>…形成的路径叫<strong>交替路</strong>。</li><li>两个端点都是未盖点→增广路（Augmenting Path，AP）<ul><li>比如：8→4→7→1→5→2，图中红色是匹配边。</li><li>特殊的：3-6也是增广路。</li></ul></li><li>把AP上的匹配边和非匹配边互换，得到的匹配比刚才多一条边。</li><li>匹配点只连一条匹配边（？），这样做不会破坏匹配的性质。</li><li>增广路定理：即一个匹配是最大匹配等价于不存在增广路。<ul><li>匈牙利算法的核心原理：就是不断找増广路（依据性质3），直至无法找到新的増广路，即为最大匹配。——使用递归（<strong>一直找增广路，不断交换匹配</strong>）</li></ul></li><li>增广路可以用来改进匹配，最大匹配可以通过反复找增广路来求解。</li><li><strong>已经匹配的点永远不会退出匹配，只会更换匹配</strong></li></ol><p>注：（匹配点又叫做盖点，非匹配点叫做未盖点（所谓“盖”指的是被一条边盖住）</p><p><img src="/2019/12/05/Hungarian-algorithm匈牙利算法/E:%5Chexo%5Csource_posts%5CHungarian-algorithm%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%5C%E5%A2%97%E5%B9%BF%E8%B7%AF.jpg" alt="増广路"></p><h3 id="实现的细节"><a class="markdownIt-Anchor" href="#实现的细节"></a> 实现的细节：</h3><p><img src="/2019/12/05/Hungarian-algorithm匈牙利算法/E:%5Chexo%5Csource_posts%5CHungarian-algorithm%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%5Czgl2.jpg" alt="zgl2"></p><p>每次选一个未盖点u进行DFS。如果找不到<strong>u开头</strong>的增广路，则换一个未盖点进行DFS，且以后<strong>再也不从u出发找增广路</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BPM</span>&#123;</span><span class="comment">//二分图最大基数匹配，邻接矩阵写法</span></span><br><span class="line">    <span class="keyword">int</span> n，m，G[maxn][maxn];<span class="comment">//左右顶点个数，G[x][y]=1，边x-y</span></span><br><span class="line">    <span class="keyword">int</span> left[maxn];<span class="comment">//1eft[i]为右边第i个点的匹配点编号，-1表示不存在</span></span><br><span class="line">    <span class="keyword">bool</span> T[maxn];<span class="comment">//T[i]为右边第i个点是否已标记</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n，<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n=n，<span class="keyword">this</span>-&gt;m=m;_zero(G);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">// 递归进行挪</span></span><br><span class="line"><span class="keyword">for</span>(intv=e;v&lt;m;v++)</span><br><span class="line">        <span class="keyword">if</span>(G[u][v]&amp;&amp;！T[v])&#123;</span><br><span class="line">            T[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(left[v]==<span class="number">-1</span> || match(left[v]))&#123;</span><br><span class="line">            <span class="comment">//left[v]！=-1，1eft[v]-v是匹配边</span></span><br><span class="line">            left[v]=u;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> solve（)&#123; <span class="comment">//求最大匹配</span></span><br><span class="line">    <span class="built_in">memset</span>(left，<span class="number">-1</span>，<span class="keyword">sizeof</span>(left));</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=e;u&lt;n;u++)&#123;<span class="comment">//从左边结点u开始增广</span></span><br><span class="line">        _zero(T); </span><br><span class="line">        <span class="keyword">if</span>(match(u)) ans++;<span class="comment">//u是未盖点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体实现代码见文章：《ACM-二分图》</p><h3 id="其他相关概念"><a class="markdownIt-Anchor" href="#其他相关概念"></a> 其他相关概念：</h3><h4 id="最小顶点覆盖"><a class="markdownIt-Anchor" href="#最小顶点覆盖"></a> 最小顶点覆盖：</h4><p>是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相连<br>&amp;二分图的最小顶点覆盖数=二分图的最大匹配数</p><h4 id="dag最小不相交路径覆盖"><a class="markdownIt-Anchor" href="#dag最小不相交路径覆盖"></a> DAG最小不相交路径覆盖</h4><p>也称为最小边覆盖，是指用尽量少的顶点<strong>不相交</strong>（只经过一次）的简单路径覆盖二分图中的所有顶点<br>路径长度可以为0<br>&amp;二分图的最小路径覆盖数=|V|-二分图的最大匹配数<br>*最小可相交路径覆盖</p><h4 id="最大独立集"><a class="markdownIt-Anchor" href="#最大独立集"></a> 最大独立集</h4><p>最大独立集是指寻找一个点集，使得其中任意两点在图中无对应边。<br>对于一般图来说，最大独立集是一个NP完全问题，对于二分图来说最大独立集<br>=|V| - 二分图的最大匹配数</p><h2 id="kmkuhn-munkres算法"><a class="markdownIt-Anchor" href="#kmkuhn-munkres算法"></a> KM(Kuhn-Munkres)算法</h2><blockquote><p>带权二分图最佳完美匹配，O(n^3)，（运用匈牙利算法辅助求解）</p></blockquote><ol><li>只适用于带权最大匹配一定是完备匹配的情况，实践中建议用费用流来解决。</li><li>完全二分图一定是偶数个点</li><li><strong>可行顶标</strong>（Feasible Labeling）：结点函数（x），任意边（x，y）：1（x）+l（y）≥w（xiy）。</li><li><strong>相等子图</strong>：G的生成子图，包含所有点以及满足l（x）+I（y）=w（x，y）的边（x，y）</li><li>如果EL有完美匹配为PM，则该M是原图的最大权匹配：<ul><li>PM的权和等于所有点的顶标之和SV。</li><li>G的任一个最大权匹配M，边满足w（xy）≤l（x）+（y）→M边权和≤SV=PM边权和</li><li>关键就是寻找好的可行顶标，使相等子图有完美匹配。</li></ul></li></ol><p>==&gt;找到原图的完美匹配–只要–&gt;找到相等子图的完美匹配即可</p><p>▲KM完成之后所有的l(x)之和最小</p><h3 id="举个栗子"><a class="markdownIt-Anchor" href="#举个栗子"></a> 举个栗子:</h3><h4 id="少林决胜golden-tiger-clawuva11383"><a class="markdownIt-Anchor" href="#少林决胜golden-tiger-clawuva11383"></a> <strong>少林决胜(Golden Tiger Claw，UVa11383)</strong></h4><p>给定一个N*N矩阵，每个格子里都有一个正整数w(i,j)。你的任务是给每行确定一个整数row(i)，每列也确定一个整数col(i)，使得对于任意格子(i, j)，w(i, j)≤row(i)+colj)。所有row(i)和col(i)之和应尽量小。</p><p>【分析】<br>1.行看作二分图X点，列看作二分图Y点。<br>2.和最佳匹配没有任何关系，KM算法副产品。<br>3.KM中算法等式l（x）+l（y）≥w（x，y）。行X，列Y。<br>4.KM过程中，所有顶标不断减小，算法结束后，所有顶标之和是最小的。</p><h4 id="蚂蚁antsneerc2008la4043"><a class="markdownIt-Anchor" href="#蚂蚁antsneerc2008la4043"></a> <strong>蚂蚁（Ants，NEERC2008，LA4043）</strong></h4><p>给出n个白点和n个黑点的坐标，要求用n条不相交的线段把它们连接起来，其中每条线段恰好连接一个白点和一个黑点，每个点恰好连接到一条线段，如图所示。</p><p>【分析】</p><ol><li>点有黑白两色，构造二分图，白X黑Y。每个黑点和每个白点相连，权值等于欧氏距离。</li><li>连接方案实际上是计算一个完美匹配，匹配中假设al-b1与a2-b2相交，那么dist(a1，b1)+dist(a2，b2)&gt;dist(al，b2)+dist(a2，b1)，这两条线段改成al-b2和a2-b1后总长度会变少。</li><li>所以最小匹配中不会出现线段相交。</li><li>套KM算法即可计算最小完美匹配即可。</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料：</h2><p><a href="https://www.bilibili.com/video/av14223723?from=search&amp;seid=7889448616401707001" target="_blank" rel="noopener">离散数学：图论：二分图的匹配</a>——陈斌 北京大学地球与空间科学学院</p><p><a href="https://blog.csdn.net/D5__J9/article/details/80754657" target="_blank" rel="noopener">二分匹配——匈牙利算法和KM算法</a>——里面推荐的文章更值得一看</p><p><a href="https://blog.csdn.net/NIeson2012/article/details/94472313" target="_blank" rel="noopener">带你入门多目标跟踪（三）匈牙利算法&amp;KM算法</a>——以图像目标跟踪距离</p><p><a href="https://skywt.cn/posts/bipartite-matching" target="_blank" rel="noopener">二分图匹配问题与匈牙利算法</a>——里面包含概念挺全的</p><p><a href="https://blog.csdn.net/ling_wang/article/details/79830980?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">二分图大合集——二分图最大匹配（最小覆盖数），完美匹配以及最优匹配（带权最大匹配）</a>——对概念的介绍比上个更准确点，推荐</p><p><a href="https://www.bilibili.com/video/av70803534/?spm_id_from=333.788.videocard.1" target="_blank" rel="noopener">二分图最大匹配以及常见模型——ACM角度</a></p><p><a href="https://www.cnblogs.com/dwdxdy/p/3261742.html" target="_blank" rel="noopener">任务分配问题—匈牙利算法</a>——含Gungary算法执行过程伪代码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hungarian-algorithm匈牙利算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hungarian-algorithm匈牙利算法&quot;&gt;&lt;/a&gt; Hungarian algorithm匈牙利算法&lt;/h1&gt;
&lt;blockquo
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://nymrli.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>PIL的Image笔记</title>
    <link href="https://nymrli.top/2019/11/26/PIL%E7%9A%84Image%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2019/11/26/PIL的Image笔记/</id>
    <published>2019-11-26T10:06:58.000Z</published>
    <updated>2019-11-26T10:07:16.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pil的image学习"><a class="markdownIt-Anchor" href="#pil的image学习"></a> PIL的Image学习</h1><h2 id="transpose和rotate"><a class="markdownIt-Anchor" href="#transpose和rotate"></a> transpose和rotate</h2><ul><li>transpose</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = getCaptcha()</span><br><span class="line"><span class="comment"># 对称反转</span></span><br><span class="line">img.transpose(Image.FLIP_LEFT_RIGHT)</span><br></pre></td></tr></table></figure><ul><li>rotate</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = getCaptcha()</span><br><span class="line"><span class="comment"># expand默认为False时,超出原有尺寸的部分将用黑色填充,不会拓展尺寸</span></span><br><span class="line">img = img.rotate(<span class="number">45</span>)</span><br><span class="line"><span class="comment"># expand为True时,会根据图片大小,拓展尺寸</span></span><br><span class="line">img = img.rotate(<span class="number">45</span>,expand=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p><a href="https://pillow.readthedocs.io/en/3.1.x/reference/Image.html#PIL.Image.Image.transpose" target="_blank" rel="noopener">Pillow官网介绍</a></p><p><a href="https://blog.csdn.net/chenriwei2/article/details/42071517" target="_blank" rel="noopener">【图像处理】Python-Image 基本的图像处理</a></p><h2 id="convert函数"><a class="markdownIt-Anchor" href="#convert函数"></a> convert函数</h2><p>参数为mode(图像模式)。这是一个字符串，指定图像使用的像素格式。典型值为“1”，“L”，“RGB”或“CMYK”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = img.convert(<span class="string">"1"</span>)</span><br></pre></td></tr></table></figure><ul><li><code>1</code> (1-bit pixels, black and white, stored with one pixel per byte)</li><li><code>L</code> (8-bit pixels, black and white)</li><li><code>P</code> (8-bit pixels, mapped to any other mode using a color palette)</li><li><code>RGB</code> (3x8-bit pixels, true color)</li><li><code>RGBA</code> (4x8-bit pixels, true color with transparency mask)</li><li><code>CMYK</code> (4x8-bit pixels, color separation)</li><li><code>YCbCr</code> (3x8-bit pixels, color video format)</li><li><code>LAB</code> (3x8-bit pixels, the L<em>a</em>b color space)</li><li><code>HSV</code> (3x8-bit pixels, Hue, Saturation, Value color space)</li><li><code>I</code> (32-bit signed integer pixels)</li><li><code>F</code> (32-bit floating point pixels)</li></ul><h2 id="pil-image与nparray互转"><a class="markdownIt-Anchor" href="#pil-image与nparray互转"></a> PIL image与np.array互转</h2><h3 id="1-pil-image转换成array"><a class="markdownIt-Anchor" href="#1-pil-image转换成array"></a> 1. PIL image转换成array</h3><p><code>img = np.asarray(image)</code>或<code>img=np.array(image)</code></p><p>需要注意的是，如果出现read-only错误，并不是转换的错误，一般是你读取的图片的时候，默认选择的是&quot;r&quot;,&quot;rb&quot;模式有关。</p><p>修正的办法:　手动修改图片的读取状态<br>img.flags.writeable = True # 将数组改为读写模式</p><h3 id="2-array转换成image"><a class="markdownIt-Anchor" href="#2-array转换成image"></a> 2. array转换成image</h3><p><strong>方法1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">Image.fromarray(np.uint8(img))</span><br></pre></td></tr></table></figure><p><strong>方法2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">cv2.imwrite(<span class="string">"output.png"</span>, out)</span><br><span class="line"><span class="comment"># out可以是uint16类型数据</span></span><br><span class="line"><span class="comment"># 16位深度图像转8位灰度</span></span><br></pre></td></tr></table></figure><p><strong>方法3</strong></p><p>matlab</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img=imread(<span class="string">'output.png'</span>)</span><br><span class="line">img1=im2uint8(img)</span><br><span class="line">imwrite(img1,<span class="string">'result.jpg'</span>)</span><br></pre></td></tr></table></figure><p><strong>Numpy将二维数组添加到空数组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=np.empty(shape=[<span class="number">0</span>,<span class="number">3</span>], dtype=np.int32)</span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">c=[[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line"> </span><br><span class="line">print(a.shape)</span><br><span class="line">print(b.shape)</span><br><span class="line"> </span><br><span class="line">a = np.append(a, b, axis=<span class="number">0</span>)</span><br><span class="line">a = np.append(a, c, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 当axis为0时，数组是加在下面（列数要相同）：</span></span><br><span class="line"><span class="comment"># 当axis为1时，数组是加在右边（行数要相同）：</span></span><br><span class="line">print(a.shape)</span><br><span class="line">print(b.shape)</span><br></pre></td></tr></table></figure><p>reshape函数是numpy中一个很常用的函数，作用是在不改变矩阵的数值的前提下修改矩阵的形状。</p><p>1.简单使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y = np.reshape([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1, 2, 3, 4]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>2.使用缺省值-1</p><p>缺省值-1代表我不知道要给行（或者列）设置为几，reshape函数会根据原矩阵的形状自动调整。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">y = np.reshape([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],(<span class="number">4</span>,<span class="number">-1</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [3],</span></span><br><span class="line"><span class="string">       [4]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PIL.Image <span class="keyword">as</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line">IMAGES_PATH = <span class="string">'E:\picture\新垣结衣\\'</span>  <span class="comment"># 图片集地址</span></span><br><span class="line">IMAGES_FORMAT = [<span class="string">'.jpg'</span>, <span class="string">'.JPG'</span>]  <span class="comment"># 图片格式</span></span><br><span class="line">IMAGE_SIZE = <span class="number">256</span>  <span class="comment"># 每张小图片的大小</span></span><br><span class="line">IMAGE_ROW = <span class="number">4</span>  <span class="comment"># 图片间隔，也就是合并成一张图后，一共有几行</span></span><br><span class="line">IMAGE_COLUMN = <span class="number">4</span>  <span class="comment"># 图片间隔，也就是合并成一张图后，一共有几列</span></span><br><span class="line">IMAGE_SAVE_PATH = <span class="string">'E:\\picture\\新垣结衣\\final.jpg'</span>  <span class="comment"># 图片转换后的地址</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取图片集地址下的所有图片名称</span></span><br><span class="line">image_names = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(IMAGES_PATH) <span class="keyword">for</span> item <span class="keyword">in</span> IMAGES_FORMAT <span class="keyword">if</span></span><br><span class="line">               os.path.splitext(name)[<span class="number">1</span>] == item]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 简单的对于参数的设定和实际图片集的大小进行数量判断</span></span><br><span class="line"><span class="keyword">if</span> len(image_names) != IMAGE_ROW * IMAGE_COLUMN:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"合成图片的参数和要求的数量不能匹配！"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义图像拼接函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_compose</span><span class="params">()</span>:</span></span><br><span class="line">    to_image = Image.new(<span class="string">'RGB'</span>, (IMAGE_COLUMN * IMAGE_SIZE, IMAGE_ROW * IMAGE_SIZE)) <span class="comment">#创建一个新图</span></span><br><span class="line">    <span class="comment"># 循环遍历，把每张图片按顺序粘贴到对应位置上</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, IMAGE_ROW + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, IMAGE_COLUMN + <span class="number">1</span>):</span><br><span class="line">            from_image = Image.open(IMAGES_PATH + image_names[IMAGE_COLUMN * (y - <span class="number">1</span>) + x - <span class="number">1</span>]).resize(</span><br><span class="line">                (IMAGE_SIZE, IMAGE_SIZE),Image.ANTIALIAS)</span><br><span class="line">            to_image.paste(from_image, ((x - <span class="number">1</span>) * IMAGE_SIZE, (y - <span class="number">1</span>) * IMAGE_SIZE))</span><br><span class="line">    <span class="keyword">return</span> to_image.save(IMAGE_SAVE_PATH) <span class="comment"># 保存新图</span></span><br><span class="line">image_compose() <span class="comment">#调用函数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pil的image学习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pil的image学习&quot;&gt;&lt;/a&gt; PIL的Image学习&lt;/h1&gt;
&lt;h2 id=&quot;transpose和rotate&quot;&gt;&lt;a class=&quot;markdownIt-A
      
    
    </summary>
    
    
      <category term="编程笔记" scheme="https://nymrli.top/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
      <category term="科学计算" scheme="https://nymrli.top/tags/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>2019年8月23号运维笔记</title>
    <link href="https://nymrli.top/2019/11/26/2019%E5%B9%B48%E6%9C%8823%E5%8F%B7%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2019/11/26/2019年8月23号运维笔记/</id>
    <published>2019-11-26T07:50:55.000Z</published>
    <updated>2019-11-26T07:51:12.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019年8月23号运维笔记"><a class="markdownIt-Anchor" href="#2019年8月23号运维笔记"></a> 2019年8月23号运维笔记</h1><h2 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> docker</h2><h3 id="docker-stop-containerid以后再重新启动时报错"><a class="markdownIt-Anchor" href="#docker-stop-containerid以后再重新启动时报错"></a> docker stop containerID，以后再重新启动时报错</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: driver failed programming external connectivity on endpoint app (3c0c01ac6b42b7a420644fc2b4debfbbcc0e1d2e74e6294155c28aca82f794c4):  (iptables failed: iptables --<span class="built_in">wait</span> -t nat -A DOCKER -p tcp -d 0/0 --dport 12345 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name.</span><br></pre></td></tr></table></figure><p>A: 重启docker即可：<code>systemctl restart docker</code></p><p>再开启你的容器： <code>docker run xxxx</code>或<code>docker start xxx</code></p><p>查看docker容器的运行日志</p><p><code>docker logs containerID</code></p><h3 id="docker端口映射到宿主机后外网仍无法访问容器的web"><a class="markdownIt-Anchor" href="#docker端口映射到宿主机后外网仍无法访问容器的web"></a> docker端口映射到宿主机后外网仍无法访问容器的web</h3><p>A：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决办法：</span></span><br><span class="line">$ sudo vi /etc/sysctl.conf</span><br><span class="line">或者</span><br><span class="line">$ sudo  vi /usr/lib/sysctl.d/00-system.conf</span><br><span class="line"><span class="comment"># 添加如下代码：</span></span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line">重启network服务</span><br><span class="line">$ sudo systemctl restart network</span><br><span class="line"></span><br><span class="line">查看是否修改成功</span><br><span class="line">$ sudo sysctl net.ipv4.ip_forward</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果返回为“net.ipv4.ip_forward = 1”则表示成功了</span></span><br></pre></td></tr></table></figure><h2 id="nginx"><a class="markdownIt-Anchor" href="#nginx"></a> nginx</h2><h3 id="查看nginx安装路径"><a class="markdownIt-Anchor" href="#查看nginx安装路径"></a> 查看nginx安装路径</h3><p><code>ps -ef | grep nginx</code></p><h2 id="查看nginx日志"><a class="markdownIt-Anchor" href="#查看nginx日志"></a> 查看nginx日志</h2><p><code>systemctl status nginx.service</code></p><p><code>journalctl -xe</code></p><h3 id="指定运行配置文件"><a class="markdownIt-Anchor" href="#指定运行配置文件"></a> 指定运行配置文件</h3><p>直接运行nginx可执行文件即可启动，nginx会自动读取配置文件目录下的“nginx.conf”配置文件，也可以在后面接“-c”参数来指定配置文件：</p><p><code>/usr/sbin/nginx -c /etc/nginx/sites-enabled/nginx.conf</code></p><h2 id="校验配置文件是否正确"><a class="markdownIt-Anchor" href="#校验配置文件是否正确"></a> 校验配置文件是否正确</h2><p>由于nginx的配置文件比较复杂容易出错，修改配置后可以用“-t”参数来校验配置文件是否正确：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -t    # 校验默认的配置文件</span><br><span class="line">nginx -t -c /path/to/configfile    # 校验指定配置文件</span><br></pre></td></tr></table></figure><h2 id="了解日志管理"><a class="markdownIt-Anchor" href="#了解日志管理"></a> 了解日志管理</h2><p>我们查看nginx安装目录下（<code>/var/log/nginx</code>）有个logs，包含了三个文件 “<strong>access.log</strong> 、<strong>error.log</strong>、<strong>nginx.pid</strong>”。</p><p>当然，日志配置肯定也是通过nginx.conf配置文件来进行配置的 ，那我先来看配置文件是怎么写的。</p><ul><li><code>access_log logs/access.log main</code>这个是指access.log日志用main格式来显示。</li><li><code>error_log logs/error.log error</code></li></ul><p>main格式是什么？mian格式是我们已经定义好了的一种各种，并取个名字便于引用。</p><p>默认的main格式中具体用了哪些选项来记录日志呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$remote_addr, $http_x_forwarded_for 记录客户端IP地址</span><br><span class="line">$remote_user 记录客户端用户名称</span><br><span class="line">$request 记录请求的URL和HTTP协议</span><br><span class="line">$status 记录请求状态</span><br><span class="line">$body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。</span><br><span class="line">$bytes_sent 发送给客户端的总字节数。</span><br><span class="line">$connection 连接的序列号。</span><br><span class="line">$connection_requests 当前通过一个连接获得的请求数量。</span><br><span class="line">$msec 日志写入时间。单位为秒，精度是毫秒。</span><br><span class="line">$pipe 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。</span><br><span class="line">$http_referer 记录从哪个页面链接访问过来的</span><br><span class="line">$http_user_agent 记录客户端浏览器相关信息</span><br><span class="line">$request_length 请求的长度（包括请求行，请求头和请求正文）。</span><br><span class="line">$request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。</span><br><span class="line">$time_iso8601 ISO8601标准格式下的本地时间。</span><br><span class="line">$time_local 通用日志格式下的本地时间。</span><br></pre></td></tr></table></figure><p>nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//该文件是存放到nginx安装目录下conf文件夹中</span><br><span class="line"> </span><br><span class="line">//全局区</span><br><span class="line"> </span><br><span class="line">//代表着当前有一个工作的子进程，可以自行修改，但是太多了无益因为会争夺cpu资源。一般最多设置成cpu数*核数</span><br><span class="line">worker_processes  1;</span><br><span class="line"> </span><br><span class="line">//一般配置nginx的连接特性</span><br><span class="line">events &#123;</span><br><span class="line">    //这里是指一个子进程最大允许连接1024个连接</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//这里是配置http服务器的主要段</span><br><span class="line">http &#123;</span><br><span class="line">    </span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    //这里配置的是日志的显示格式</span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                 &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                 &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    </span><br><span class="line">    //这里调用指定日志显示的格式</span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    //这里是配置虚拟主机段</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;//监听的端口</span><br><span class="line">        server_name  localhost;//监听访问地址</span><br><span class="line"> </span><br><span class="line">        #charset koi8-r;</span><br><span class="line"> </span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"> </span><br><span class="line">        //定位，把特殊的文件或者路径再次定位</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;//定位的目录，默认是ngxin安装目录下的html文件夹中</span><br><span class="line">            index  index.html index.htm;//定位的具体文件</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="nginx日志分析"><a class="markdownIt-Anchor" href="#nginx日志分析"></a> nginx日志分析</h2><p>分析截止目前为止访问量最高的IP排20名。</p><p><code>awk'{print $1}' /usr/local/nginx/logs/access.log |sort | uniq-c I|sort -nr</code></p><p>分析从早上9点至中午12点总的访问量。</p><p><code>sed-n&quot;/2016:09:00/,/2016:12:00/&quot; paccess_20161121.log</code></p><p>分析上一秒的访问请求数。</p><p><code>sed -n&quot;/2016：09：00：00/&quot; paccess_20161121.log</code></p><p>https签名：<a href="https://www.jianshu.com/p/0d455c7a9326" target="_blank" rel="noopener">https://www.jianshu.com/p/0d455c7a9326</a></p><h2 id="qnginx和uwsgi区别"><a class="markdownIt-Anchor" href="#qnginx和uwsgi区别"></a> Q：nginx和uwsgi区别</h2><p>nginx的作用：<br>1.反向代理，可以拦截一些web攻击，保护后端的web服务器<br>2.负载均衡，根据轮询算法，分配请求到多节点web服务器<br>3.缓存静态资源，加快访问速度，释放web服务器的内存占用，专项专用</p><p>uWSGI的适用：<br>1.单节点服务器的简易部署<br>2.轻量级，好部署</p><p>Q：已知一个使用nginx配置的web服务器的域名为www.my.com监听80端口,假设在服务器的/var/www/html这个目录下面有静态文件index.html,那么在配置文件其它部分相同的情况下，分别使用下面两种配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Location /abc &#123;</span><br><span class="line">    root /var/www/html; </span><br><span class="line">    index index.html; </span><br><span class="line">&#125;</span><br><span class="line">location/abc &#123; </span><br><span class="line">    alias /var/ww/html/; </span><br><span class="line">    index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问http://www.my.com/abc分别会有什么结果？</p><p>A：</p><ul><li>root 的为<code>/var/www/html/abc/index.html</code></li><li>alias的为<code>/var/www/html/index.html</code></li></ul><p>Q：所以使用浏览器访问的话这两种配置会有什么区别？</p><p>A：root的为404，alias的为200.</p><p>注：如果通过两个路径都能访问到的话，那无论哪个配置都是200</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019年8月23号运维笔记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2019年8月23号运维笔记&quot;&gt;&lt;/a&gt; 2019年8月23号运维笔记&lt;/h1&gt;
&lt;h2 id=&quot;docker&quot;&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="编程笔记" scheme="https://nymrli.top/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="运维" scheme="https://nymrli.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>app测试</title>
    <link href="https://nymrli.top/2019/11/26/app%E6%B5%8B%E8%AF%95/"/>
    <id>https://nymrli.top/2019/11/26/app测试/</id>
    <published>2019-11-26T07:49:58.000Z</published>
    <updated>2019-11-26T07:50:10.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="app测试"><a class="markdownIt-Anchor" href="#app测试"></a> app测试</h1><h2 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h2><p><code>adb shell monkey 500</code>随机执行500次</p><p><code>adb shell pm list packages -3</code> 查看第三方包</p><p><code>adb shell monkey -p tv.danmaku.bili</code>指定在某个软件中随机压力测试</p><p><code>adb shell monkey -p tv.danmaku.bili -p com.umaman.laiyifen 500</code>会先执行来伊份</p><p>▲.在测试应用程序某些选项的同时，也会进行系统级功能的测试，如截图、调音量等</p><p><code>adb shell monkey [-options] times</code></p><h3 id="参数说明"><a class="markdownIt-Anchor" href="#参数说明"></a> 参数说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-s seed种子值：种子相同时，就能产生一样的伪随机操作序列</span><br><span class="line">-p package指定包名：压力测试执行在某个软件内</span><br><span class="line">--pct-touch percentage：指定触摸的比例</span><br><span class="line">--throttle MILLSEC ：设置每个操作之间的间隔为xx毫秒</span><br><span class="line"></span><br><span class="line">-v [-v [-v]]：输出日志，v越多越详细</span><br><span class="line">--ignore-crashes ：不管程序有无崩溃，都执行完所有操作</span><br></pre></td></tr></table></figure><h2 id="各事件比例event-percentages"><a class="markdownIt-Anchor" href="#各事件比例event-percentages"></a> 各事件比例（Event percentages:）</h2><ul><li>0: 50.0%      -pct-touch  触摸操作</li><li>1: 5.8823533%-pct-motion 移动操作</li><li>2: 1.1764706%-pct-pinchzoom 缩放操作</li><li>3: 8.82353%-pct-traceball 滚动操作</li></ul><h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2><p>event injected数量不对</p><p>crash闪退</p><p>ANR没有响应</p><h2 id="出现异常后需要提供给开发的东西"><a class="markdownIt-Anchor" href="#出现异常后需要提供给开发的东西"></a> 出现异常后，需要提供给开发的东西</h2><p>l.被测手机详细信息<br>2.monkey测试日志<br>3.手机运行截图<br>4.monkey运行射手机日志</p><h1 id="测试用例"><a class="markdownIt-Anchor" href="#测试用例"></a> 测试用例</h1><h2 id="测试用例设计三部曲"><a class="markdownIt-Anchor" href="#测试用例设计三部曲"></a> 测试用例设计三部曲</h2><ul><li>要测试什么  -业务</li><li>怎么纠样测试           -测试环境搭建</li><li>如何判新正确与否    -需求</li></ul><h2 id="测试计划"><a class="markdownIt-Anchor" href="#测试计划"></a> 测试计划</h2><p>不同的环境下（兼容性）<br>正常安装</p><p>空间不足-&gt;验证松勤安卓APP在HWX空间不足的条件下的安装行为</p><ul><li>√正常行为：提示空间不够</li><li>x死机</li><li>提示错误代码，emor code201</li></ul><p>安装过程没电-重新安装</p><p>断网-网络Fiddler</p><h2 id="常用功能测试点"><a class="markdownIt-Anchor" href="#常用功能测试点"></a> 常用功能测试点</h2><p>常用的功能测试方法有“界面测试方法”和“黑盒测试技术”，具体可参见测试组配置库中的相应文档。下面列举了一些常用的功能测试点：<br>1.页面链接检查每一个链接是否都有对应的页面，并且页面之间切换正确。<br>2.相关性检查：删除/增加一项会不会对其他项产生影响，如果产生影响，这些影响是否都正确。<br>3.检查按钮的功能是否正确：如新增、修改、取消、删除、保存等功能是否正确。<br>4.字符串长度检查：输入超出需求规定的字符串长度的内容，看系统是否检查字符串长度，会不会有提示窗口。<br>5.字符类型检查：在应该输入指定类型的内容的地方输入其他类型的内容（如在应该输入整型的地方输入其他字符类型），看系统是否检查字符类型，是否会有提示窗口。<br>6.标点符号检查：输入内容包括各种标点符号，特别是空格，各种引号，回车键，看系统是否会有异常错误。<br>7.信息重复：在一些需要命名，且名字应该唯一的地方输入重复的名字或ID，看系统怎么处理，是否报错；重名是否区分大小写，以及在输入内容的前后输入空格，系统是否作出正确处理。<br>8.检查删除功能：在一些可以一次删除多个信息的地方，不选择任何信息，进行删除，看系统如何处理，是否出错；选择一个和多个信息，进行删除，看是否正确处理。<br>9.检查添加和修改是否一致：检查添加和修改信息的要求是否一致，如添加要求必填的项，修改也应该必填；添加规定为整型的项，修改也必须为整型。<br>10.检查修改重名：修改时把不能重名的项改为已存在的内容，看系统是否处理，报重名的错。<br>11.重复提交表单：一条已经成功提交的纪录，退出后再提交，看看系统是否会做什么处理。<br>12.查询功能：在有查询功能的地方输入系统存在和不存在的内容，结果是否正确；如果可以输入多个查询条件，同时添加合理和不合理的条件，看系统处理是否正确。<br>13.输入信息位置：注意在光标停留的地方输入信息时，光标和所输入的信息是否跳到别的地方。<br>14.上传下载文件检查：上传下载文件的功能是否实现，上传文件是否能打开。对上传文件的格式有何规定，系统是否有提示信息。<br>15.必填项检查：应该填写的项没有填写时系统是否都做了处理，对必填项是否有提示信息，如在必填项放加*。<br>16.快捷键检查：是否支持常用快捷键，如Ctl+C Ctrl+V Backspace等，对一些不允许输入信息的字段，如选人，选日期是否也有快捷键。<br>17.回车键检查：在输入结束后直接按回车键，看系统处理如何，会否报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;app测试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#app测试&quot;&gt;&lt;/a&gt; app测试&lt;/h1&gt;
&lt;h2 id=&quot;命令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#命令&quot;&gt;&lt;/a&gt; 命令&lt;/h2&gt;
&lt;
      
    
    </summary>
    
    
      <category term="测试" scheme="https://nymrli.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>2019-9月7号C++编程笔记</title>
    <link href="https://nymrli.top/2019/11/26/2019-9%E6%9C%887%E5%8F%B7C-%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2019/11/26/2019-9月7号C-编程笔记/</id>
    <published>2019-11-26T07:47:55.000Z</published>
    <updated>2019-11-26T07:48:23.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019-9月7号c编程笔记"><a class="markdownIt-Anchor" href="#2019-9月7号c编程笔记"></a> 2019-9月7号C++编程笔记</h1><h2 id="auto"><a class="markdownIt-Anchor" href="#auto"></a> auto</h2><p>定义变量时放在变量前，无需知道具体变量类型，系统可自行<strong>推断类型</strong>，减少编程工作，特别是在<strong>模板使用时，使用更方便</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> b=<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">auto</span> s=<span class="string">"abdc"</span>;</span><br><span class="line"><span class="keyword">auto</span> c;<span class="comment">//这样使用时错误的，系统无法自动推断出变量类型</span></span><br><span class="line"><span class="comment">//下面为迭代指针使用，很方便</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> it=vec.begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">模板使用案例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">creatTree</span><span class="params">(InputIterator in_beg,InputIterator in_end...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       .....</span><br><span class="line">        <span class="keyword">auto</span> inRootPos=find(in_beg,in_end,val);</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="stdnext"><a class="markdownIt-Anchor" href="#stdnext"></a> <strong>std::next</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Defined in header &lt;iterator&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">next</span>( <span class="title">ForwardIt</span> <span class="title">it</span>, <span class="title">typename</span> <span class="title">std</span>:</span>:iterator_traits&lt;ForwardIt&gt;::difference_type n = <span class="number">1</span> );</span><br></pre></td></tr></table></figure><ul><li><h3 id="parameters"><a class="markdownIt-Anchor" href="#parameters"></a> Parameters:</h3><ul><li>it  – 迭代指针</li><li>n  – 向前进的元素个数，缺省默认为1</li></ul></li><li><p><strong>Return value</strong></p><p>The nth successor of iterator it.（返回it的第n个后继迭代指针）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vals.size(); ++i) &#123;</span><br><span class="line"><span class="comment">// *std::next(vals.cbegin(), i)遍历set的所有值，每次取出一个val</span></span><br><span class="line"><span class="comment">// count为计算values中包含val的个数</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="built_in">std</span>::count(values.cbegin(), values.cend(), *<span class="built_in">std</span>::next(vals.cbegin(), i));</span><br></pre></td></tr></table></figure><h2 id="stdprev"><a class="markdownIt-Anchor" href="#stdprev"></a> <strong>std::prev</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法与next相似，不同的是prev返回的是it的第n个前驱迭代指针,即返回指针是begin()和rbegin()区别</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">BidirIt</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">BidirIt</span> <span class="title">prev</span>( <span class="title">BidirIt</span> <span class="title">it</span>, <span class="title">typename</span> <span class="title">std</span>:</span>:iterator_traits&lt;BidirIt&gt;::difference_type n = <span class="number">1</span> );</span><br></pre></td></tr></table></figure><h2 id="stdadvance"><a class="markdownIt-Anchor" href="#stdadvance"></a> std::advance</h2><blockquote><p><strong>方法与prev和next相似，只是无返回指针</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">next</span>(<span class="title">ForwardIt</span> <span class="title">it</span>, <span class="title">typename</span> <span class="title">std</span>:</span>:iterator_traits&lt;ForwardIt&gt;::difference_type n = <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::advance(it, n);</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const_cast"><a class="markdownIt-Anchor" href="#const_cast"></a> const_cast</h2><ul><li><p><strong>去掉const属性</strong>：<code>const_cast&lt;int*&gt; (&amp;num)</code>，常用，因为不能把一个const变量直接赋给一个非const变量，必须要转换。</p></li><li><p><strong>加上const属性</strong>：<code>const int* k = const_cast&lt;const int*&gt;(j)</code>，一般很少用，因为可以把一个非const变量直接赋给一个const变量，比如：const int* k = j;</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary_tree* tmp = <span class="keyword">const_cast</span>&lt;binary_tree*&gt;(node);</span><br></pre></td></tr></table></figure><h2 id="c11对vector成员函数的扩展"><a class="markdownIt-Anchor" href="#c11对vector成员函数的扩展"></a> C++11对vector成员函数的扩展</h2><h3 id="emplace_back"><a class="markdownIt-Anchor" href="#emplace_back"></a> emplace_back</h3><h3 id="stdvectorcbegin和stdvectorcend"><a class="markdownIt-Anchor" href="#stdvectorcbegin和stdvectorcend"></a> <strong>std::vector::cbegin和std::vector::cend</strong></h3><p>这两个方法是与std::vector::begin和std::vector::end相对应的，从字面就能看出来，多了一个’c’，顾名思义就是const的意思。同理，<strong>std::vector::crbegin和std::vector::crend</strong></p><h3 id="stdvectoremplace"><a class="markdownIt-Anchor" href="#stdvectoremplace"></a> <strong>std::vector::emplace</strong></h3><p>之前已经对emplace_back进行了讨论，其实还有一个方法叫emplace。<br>我想说的就是，emplace之于emplace_back就像insert之于push_back。如下使用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;code <span class="class"><span class="keyword">class</span>="<span class="title">hljs</span> <span class="title">cpp</span>"&gt;</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">main</span> ()</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> it = myvector.emplace ( myvector.begin()+<span class="number">1</span>, <span class="number">100</span> );</span><br><span class="line">  myvector.emplace ( it, <span class="number">200</span> );</span><br><span class="line">  myvector.emplace ( myvector.end(), <span class="number">300</span> );</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: myvector)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">myvector contains: 10 200 100 20 30 300&lt;/int&gt;&lt;/vector&gt;&lt;/iostream&gt;&lt;/code&gt;</span><br></pre></td></tr></table></figure><h3 id="stdvectordata"><a class="markdownIt-Anchor" href="#stdvectordata"></a> <strong>std::vector::data</strong></h3><p>Returns a direct pointer to the memory array used internally by the vector to store its owned elements.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;code <span class="class"><span class="keyword">class</span>="<span class="title">hljs</span> <span class="title">cpp</span>"&gt;#<span class="title">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">main</span> ()</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">int</span>* p = myvector.data();</span><br><span class="line">  *p = <span class="number">10</span>;</span><br><span class="line">  ++p;</span><br><span class="line">  *p = <span class="number">20</span>;</span><br><span class="line">  p[<span class="number">2</span>] = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;myvector.size(); ++i)</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myvector[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">      =<span class="string">""</span> output:=<span class="string">""</span> myvector=<span class="string">""</span> contains:=<span class="string">""</span> <span class="number">10</span>=<span class="string">""</span> <span class="number">20</span>=<span class="string">""</span> <span class="number">0</span>=<span class="string">""</span> <span class="number">100</span>=<span class="string">""</span> <span class="number">0</span>&lt;/<span class="keyword">int</span>&gt;&lt;/<span class="built_in">vector</span>&gt;&lt;/iostream&gt;&lt;/code&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019-9月7号c编程笔记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2019-9月7号c编程笔记&quot;&gt;&lt;/a&gt; 2019-9月7号C++编程笔记&lt;/h1&gt;
&lt;h2 id=&quot;auto&quot;&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="编程笔记" scheme="https://nymrli.top/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
