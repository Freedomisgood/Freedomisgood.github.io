<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>玩玩Stm32 · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">玩玩Stm32</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2019/10/18</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="嵌入式"> 嵌入式</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">4,390</span> | Reading time: <span class="post-count">19</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="玩玩Stm32"><a href="#玩玩Stm32" class="headerlink" title="玩玩Stm32"></a>玩玩Stm32</h1><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">G:.</span><br><span class="line">├───CORE	<span class="comment"># startup_stm32f10x_hd.s汇编编写的启动文件</span></span><br><span class="line">|			<span class="comment"># core_cm3.c底层函数</span></span><br><span class="line">├───HARDWARE	<span class="comment"># 相关外设的初始化代码</span></span><br><span class="line">├───OBJ</span><br><span class="line">├───STM32F10x_FWLib	<span class="comment"># 固件库包: GPIO/i2c/...</span></span><br><span class="line">│   ├───inc</span><br><span class="line">│   └───src</span><br><span class="line">├───SYSTEM			<span class="comment"># 正点原子提供的常用、通用模块</span></span><br><span class="line">│   ├───delay</span><br><span class="line">│   ├───sys</span><br><span class="line">│   └───usart</span><br><span class="line">└───USER <span class="comment"># stm32f10x_it.c 中断管理文件</span></span><br><span class="line">    |	 <span class="comment"># stm32f10x.h </span></span><br><span class="line">    ├───Listings</span><br><span class="line">    └───Objects</span><br></pre></td></tr></table></figure>
<h3 id="编写规范："><a href="#编写规范：" class="headerlink" title="编写规范："></a>编写规范：</h3><p>用户编写的执行代码写在main.c中,其中<code>#include &quot;stm32f10x.h&quot;</code>作用相当于C51的<code>#include &lt;reg51.h&gt;</code>，是操作寄存器的主要固件库文件,在任何地方引用到固件库函数时都需要导入这个文件。</p>
<p><code>stm32f10x_it.c、stm32f10x_it.h</code>, 专门存放中断服务函数的C文件 ,大多中断函数都 写在此文件中,方便 管理中断函数,但并不是一定要写在这里面。 </p>
<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>◆端口复用功能<br>STM32的大部分端口都具有复用功能。<br>所谓复用,就是一些端口<em>不仅仅</em>可以做为通用lO口,还可以<em>复用</em>为一些外设引脚,比如PA9,PA10可以复用为STM32的<strong>串口</strong>1引脚。<br>▲作用：最大限度的利用端口资源</p>
<p>◆端口重映射功能<br>就是可以把某些功能引脚映射到其他引脚。<br>比如串口1默认引脚是PA9,PA10可以通过配置重映射映射到PB6,PB7<br>作用：为了方便布线</p>
<p>▲所有I0口都可以作为中断输入</p>
<h3 id="工作模式："><a href="#工作模式：" class="headerlink" title="工作模式："></a>工作模式：</h3><ul>
<li>推挽输出：可以输出强高低电平</li>
<li>上拉输入: 一端是接地低电平,所以<strong>默认情况</strong>下另一端需要检测到<strong>高电平</strong>(按键扫描中,三个引脚需要设置为IPU,按下时&lt;==&gt;输入口检测到低电平)</li>
<li>下拉输入：(按下时&lt;==&gt;输入口检测到低电平)</li>
</ul>
<h3 id="GPIO重要函数"><a href="#GPIO重要函数" class="headerlink" title="GPIO重要函数"></a>GPIO重要函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1个初始化函数：</span></span><br><span class="line">void GPIO_Init(GPIO_TypeDef* GPIOx,GPIO_InitTypeDef* GPIO_InitStruct)；</span><br><span class="line"><span class="comment">//2个读取输入电平函数：</span></span><br><span class="line">uint8t GPIO_ReadlinputDataBit(GPIO TypeDef* GPIOx,uint16_t GPIO_Pin)；</span><br><span class="line"><span class="keyword">uint16_t</span> GPIO_ReadinputData(GPIO_TypeDef* GPIOx)；</span><br><span class="line"><span class="comment">//2个读取输出电平函数：</span></span><br><span class="line">uint8t GPIO_ReadOutputDataBit(GPiO_TypeDef* GPiOx,uint16_t GPIO_Pin)；</span><br><span class="line">uint16t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)；</span><br><span class="line"><span class="comment">//4个设置输出电平函数：前两个常用,后两个不常用</span></span><br><span class="line">void GPIO_SetBits(GPIOTypeDef* GPIOx, uint16_t GPIOPin)；</span><br><span class="line">void GP1O_ResetBits(GPIOTypeDef GPIOx,uint16_t GPIOPin)；</span><br><span class="line">void GPIO_WriteBit(GPIOTypeDef* GPIOx,uint16_t GPIO_Pin,BitAction BitVal)；</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Write</span><span class="params">(GPIOTypeDef* GPIOx, <span class="keyword">uint16_t</span> PortVal)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">GPIO_TypeDef为GPIO寄存器组合的类型</span></span></span><br><span class="line"><span class="function"><span class="comment">typedef struct&#123;	</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t CRL;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t CRH;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t IDR;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t ODR;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t BSRR;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t BRR;</span></span></span><br><span class="line"><span class="function"><span class="comment">  __IO uint32_t LCKR;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125; GPIO_TypeDef;</span></span></span><br><span class="line"><span class="function"><span class="comment">GPIOx的选择可以为GPIOA-&gt;GPIOG</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">typedef struct&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  uint16_t GPIO_Pin;           </span></span></span><br><span class="line"><span class="function"><span class="comment">  GPIOSpeed_TypeDef GPIO_Speed; </span></span></span><br><span class="line"><span class="function"><span class="comment">  GPIOMode_TypeDef GPIO_Mode;    </span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;GPIO_InitTypeDef;</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure>
<p>初始化示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明结构体变量</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure；</span><br><span class="line"><span class="comment">//LEDO--&gt;PB.5端口配置</span></span><br><span class="line">GPIO InitStructure.GPIO Pin =GPIO_Pin_5；</span><br><span class="line"><span class="comment">//推挽输出</span></span><br><span class="line">GPIO InitStructure.GPIO Mode=GPIO_Mode_Out_PP；</span><br><span class="line"><span class="comment">//IO口速度为50MHz</span></span><br><span class="line">GPIO InitStructure.GPIO Speed=GPIO_Speed_50MHz；</span><br><span class="line"><span class="comment">//根据设定参数初始化GPIOB.5</span></span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure></p>
<p>▲在使用GPIO前,需要使能IO口时钟,调用函数<code>RCC_APB2PeriphColckCmd();</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="keyword">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*RCC_APB2Periph 可以为</span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_AFIO  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOA </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOB </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOC </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOD </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOE </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOF </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_GPIOG </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_ADC1  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_ADC2  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM1  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_SPI1  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM8  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_USART1 </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_ADC3  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM15 </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM16 </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM17 </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM9  </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM10 </span></span></span><br><span class="line"><span class="function"><span class="comment">RCC_APB2Periph_TIM11 </span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">NewState 为ENABLE / DISABLE</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure>
<p>提示：不能通过IO口直接驱动大功率器件。</p>
<p>△复位之后，IO口默认为浮空状态，如果不接下拉电阻，那么电平不确定为高还是低电平。(到是小电流的时候，电流会直接通过下拉电阻到地，不会经过三极管；只有电流足够大，才会经过三极管)</p>
<h3 id="demo-跑马灯实验"><a href="#demo-跑马灯实验" class="headerlink" title="demo : 跑马灯实验"></a>demo : 跑马灯实验</h3><p><img src="/2019/10/15/玩玩Stm32/跑马灯.jpg" alt="跑马灯"></p>
<p>当将PE5设置为低电平时,通过上拉电阻连到VCC后,LED就能点亮。PE5被设置为高电平时与上拉高电平之间没有压差,此时LED熄灭。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码:"></a>完整代码:</h4><p>led.c文件内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span> </span></span><br><span class="line"><span class="comment">// 在任何地方引用到固件库时都需要导入这个文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOE,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_Init(GPIOE,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 设置为高电平,熄灭</span></span><br><span class="line">	GPIO_SetBits(GPIOB, GPIO_Pin_5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.c文件内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;	</span><br><span class="line">	 delay_init();</span><br><span class="line">	 LED_Init();</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">         GPIO_SetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">         delay_ms(<span class="number">500</span>);</span><br><span class="line">     	 GPIO_ResetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">     	 GPIO_ResetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">         delay_ms(<span class="number">500</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="操作IO口的三种方式："><a href="#操作IO口的三种方式：" class="headerlink" title="操作IO口的三种方式："></a>操作IO口的三种方式：</h3><ul>
<li>位操作：<code>#define BEEP PBout(8);</code>后<code>BEEP = 1</code></li>
<li>库函数：<code>GPIO_SetBits(GPIOB, GPIO_Pin_8);</code></li>
<li>寄存器：</li>
</ul>
<h2 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h2><blockquote>
<p>对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。IP bit决定了对每个中断共有2^4(位) = 16级的中断优先级设置</p>
</blockquote>
<p><img src="/2019/10/15/玩玩Stm32/中断分组.jpg" alt="中断分组"></p>
<ul>
<li>高优先级的抢占优先级是可以<strong>打断</strong>正在进行的低抢占优先级中断的。</li>
<li>抢占优先级相同的中断，高响应优先级<strong>不可以打断</strong>低响应优先级的中断。</li>
<li>抢占优先级相同的中断，当两个中断<strong>同时发生</strong>的情况下，哪个响应优先级高，哪个先执行。</li>
<li>如果两个中断的抢占优先级和响应优先级<strong>都是一样</strong>的话，则看哪个中断先发生就先执行；</li>
</ul>
<p>总结：中断嵌套执行看抢占优先级；占优先级相同时,响应优先级高的先响应；两者都一样的话，执行顺序看发生的时间</p>
<p>△.优先级0最高，4最低。</p>
<p>▲.系统代码执行过程中，只设置一次中断优先，一般不会再改变分组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断优先级分组函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_PriorityGroupConfig</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_PriorityGroup)</span></span></span><br><span class="line"><span class="function"><span class="comment">// demo: NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 对某个中断设置优先级</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_Init</span><span class="params">(NVIC_InitTypeDef* NVIC_InitStruct)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">typedef struct&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  uint8_t NVIC_IRQChannel;                    </span></span></span><br><span class="line"><span class="function"><span class="comment">  uint8_t NVIC_IRQChannelPreemptionPriority;  </span></span></span><br><span class="line"><span class="function"><span class="comment">  uint8_t NVIC_IRQChannelSubPriority;         </span></span></span><br><span class="line"><span class="function"><span class="comment">  FunctionalState NVIC_IRQChannelCmd;         </span></span></span><br><span class="line"><span class="function"><span class="comment">&#125; NVIC_InitTypeDef;</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>中断优先级控制的寄存器组：IP[240]对每个中断进行管理,STM32F10x系列一共有60个可屏蔽中断。全称是：Interrupt Priority Registers</p>
</blockquote>
<h3 id="中断优先级设置步骤"><a href="#中断优先级设置步骤" class="headerlink" title="中断优先级设置步骤"></a>中断优先级设置步骤</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①统运行后先设置中断优先级分组。调用函数：//整个系统执行过程中，只设置一次中断分组。</span></span><br><span class="line">void NVIC_Priority_GroupConfig(uint32_t NVIC_PriorityGroup)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//②针对每个中断，设置对应的抢占优先级和响应优先级：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> NVIC <span class="title">Init</span><span class="params">(NVIC_InitTypeDef* NVIC_Initstructy；</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* demo:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">NVIC_InitStructure.NVIC_IRQChannel=EXTI3_IRQn://使能按键KEY1所在的外部中断通道</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0x02：//抢占优先级2</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">NVIC_InitStructure.NVIC_IRQChannelSubPriority =0x01：</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">∥字优先级1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">NVIC_InitStructure.NVIC_IRQChannelCmd =ENABLE://使能外部中断通道</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">NWIC_Init(&amp;WIC_Init Structure)：/根据NIC_InitStruct中指定的参数初始化外设NVIC寄存器</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">*/</span></span></span></span><br><span class="line"><span class="function"><span class="params">               </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//③如果需要挂起/解挂，查看中断当前激活状态，分别调用相关函数即可。</span></span></span></span><br></pre></td></tr></table></figure>
<h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><blockquote>
<p>异步: 跟系统时钟无关</p>
<p>同步: 跟系统时钟有关</p>
</blockquote>
<p>波特率计算方法:$\mathrm{Tx} / \mathrm{Rx} \quad Baud rate=\frac{f_{P C L K x}}{(16 * U S A R T D I V)}$</p>
<h3 id="配置的一般步骤"><a href="#配置的一般步骤" class="headerlink" title="配置的一般步骤:"></a><img src="/2019/10/15/玩玩Stm32/baud_rate.jpg" alt="baud_rate">配置的一般步骤:</h3><p><img src="/2019/10/15/玩玩Stm32/hexo\source\_posts\玩玩Stm32\串口配置的一般步骤.jpg" alt="串口配置的一般步骤"></p>
<ol>
<li>串口作为外设，需要使能:<code>RCC_APB2PeriphClockCmdO;</code>、以及使能GPIO的时钟</li>
<li>GPIO端口模式设置<code>GPIOInit0;</code>，模式设置为<code>GPIO_Mode_AFPP</code>复用推挽(PA.9/10复用为串口1)</li>
<li>串口参数初始化</li>
<li>使能串口USART Cma); </li>
<li>串口数据收发</li>
</ol>
<p>▲ <strong>UART串口<a href="http://bbs.elecfans.com/zhuti_wireless_1.html" target="_blank" rel="noopener">通信</a>只需连接TX，RX，GND</strong> ， <strong>一般不需要连接VCC</strong> </p>
<blockquote>
<p> A：TX、RX是正负压的，所以有个地做参考就行了 </p>
<p>A： 通信两端一般都有各自的供电电压，所以不需要VCC，只有一端没有电源的情况下才会用VCC向对方输送电源 </p>
<p> A：就像像耳机只要联地、音频左、音频右，而不联vcc一个道理 </p>
</blockquote>
<h3 id="正点原子提供的USART库："><a href="#正点原子提供的USART库：" class="headerlink" title="正点原子提供的USART库："></a><strong>正点原子提供的USART库：</strong></h3><blockquote>
<p>以回车换行结束的协议</p>
</blockquote>
<p>usart.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART_REC_LEN  			200  	<span class="comment">//定义最大接收字节数 200</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EN_USART1_RX 			1		<span class="comment">//使能（1）/禁止（0）串口1接收</span></span></span><br><span class="line">	  	</span><br><span class="line"><span class="keyword">extern</span> u8  USART_RX_BUF[USART_REC_LEN]; <span class="comment">//接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 </span></span><br><span class="line"><span class="keyword">extern</span> u16 USART_RX_STA;         		<span class="comment">//接收状态标记	</span></span><br><span class="line"><span class="comment">//如果想串口中断接收，请不要注释以下宏定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(u32 bound)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/15/玩玩Stm32/hexo\source\_posts\玩玩Stm32\USART_RX_STA.jpg" alt="USART_RX_STA"></p>
<p>数据全保存在USART_RX_BUF中。根据STA的有效数据个数比如50个，将USART_RX_BUF中前50个数据拿出处理。处理完所有标志位将被清零</p>
<p>▲程序要求，发送的字符是以回车换行结束(Ox0D,0x0A)。</p>
<p>△串口调试助手里勾选”发送新行”选项</p>
<p>usart.c 程序理解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span>                	<span class="comment">//串口1中断服务程序</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	u8 Res;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYSTEM_SUPPORT_OS 		<span class="comment">//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.</span></span></span><br><span class="line">	OSIntEnter();    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  <span class="comment">//接收中断(接收到的数据必须是0x0d 0x0a结尾)</span></span><br><span class="line">		&#123;</span><br><span class="line">		Res =USART_ReceiveData(USART1);	<span class="comment">//读取接收到的数据(单个字符)</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>((USART_RX_STA&amp;<span class="number">0x8000</span>)==<span class="number">0</span>)<span class="comment">//没收到\n,即接收未完成</span></span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x4000</span>)<span class="comment">//接收到了0x0d(\r)</span></span><br><span class="line">				&#123;</span><br><span class="line">				<span class="keyword">if</span>(Res!=<span class="number">0x0a</span>)USART_RX_STA=<span class="number">0</span>;<span class="comment">//如果下一个不是\n,那么接收错误,重新开始</span></span><br><span class="line">				<span class="keyword">else</span> USART_RX_STA|=<span class="number">0x8000</span>;	<span class="comment">//如果接受到\n,则接收完成,将USART_RX_STA bit15置1</span></span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="comment">//还没收到0X0D,即处理真正数据</span></span><br><span class="line">				&#123;	</span><br><span class="line">                <span class="comment">// 如果当前接收到\r,那么将Bit14置1</span></span><br><span class="line">				<span class="keyword">if</span>(Res==<span class="number">0x0d</span>)USART_RX_STA|=<span class="number">0x4000</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">                    <span class="comment">// 将当前收到的字符Res存到数组USART_RX_BUF保存</span></span><br><span class="line">					USART_RX_BUF[USART_RX_STA&amp;<span class="number">0X3FFF</span>]=Res ;</span><br><span class="line">                    <span class="comment">// 索引+1</span></span><br><span class="line">					USART_RX_STA++;</span><br><span class="line">                    <span class="comment">// 如果数据超额,那么判断为接收错误</span></span><br><span class="line">					<span class="keyword">if</span>(USART_RX_STA&gt;(USART_REC_LEN<span class="number">-1</span>))USART_RX_STA=<span class="number">0</span>;<span class="comment">//接收数据错误,重新开始接收	  </span></span><br><span class="line">					&#125;		 </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;   		 </span><br><span class="line">     &#125; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYSTEM_SUPPORT_OS 	<span class="comment">//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.</span></span></span><br><span class="line">	OSIntExit();  											 </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Res =USART_ReceiveData(USART1);</code>获得的是当前接收的字符，如果使用中断，那么调用<code>USART_SendData(USART1, Res)</code>就能接收一个字符，发送一个字符。</li>
<li>USART_RX_BUF的作用是，保存一次字符串发送过来的所有数据</li>
<li>USART_RX_STA是个寄存器，通过Bit14，Bit15来判断接收是否有效</li>
</ul>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;		</span><br><span class="line"> 	u16 t;  </span><br><span class="line">	u16 len;	</span><br><span class="line">	u16 times=<span class="number">0</span>;</span><br><span class="line">	delay_init();	    	 <span class="comment">//延时函数初始化	  </span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="comment">//设置NVIC中断分组2:2位抢占优先级，2位响应优先级</span></span><br><span class="line">	uart_init(<span class="number">115200</span>);	 <span class="comment">//串口初始化为115200</span></span><br><span class="line"> 	LED_Init();			     <span class="comment">//LED端口初始化</span></span><br><span class="line">	KEY_Init();          <span class="comment">//初始化与按键连接的硬件接口</span></span><br><span class="line"> 	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x8000</span>)&#123;					   </span><br><span class="line">			len=USART_RX_STA&amp;<span class="number">0x3fff</span>;<span class="comment">//得到此次接收到的数据长度</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\r\n您发送的消息为:\r\n\r\n"</span>);</span><br><span class="line">			<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)&#123;</span><br><span class="line">				USART_SendData(USART1, USART_RX_BUF[t]);<span class="comment">//向串口1发送数据</span></span><br><span class="line">				<span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);<span class="comment">//等待发送结束</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\r\n\r\n"</span>);<span class="comment">//插入换行</span></span><br><span class="line">			USART_RX_STA=<span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			times++;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">5000</span>==<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\r\n战舰STM32开发板 串口实验\r\n"</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"正点原子@ALIENTEK\r\n\r\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">200</span>==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"请输入数据,以回车键结束\n"</span>);  </span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">30</span>==<span class="number">0</span>)LED0=!LED0;<span class="comment">//闪烁LED,提示系统正在运行.</span></span><br><span class="line">			delay_ms(<span class="number">10</span>);   </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	 </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>▲printf可以将发送到串口，默认是USART1，如果需要修改，在usart.c的fputc函数中,将USART1修改即可</p>
<h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><p>每个IO口都可以作为外部中断输入</p>
<blockquote>
<p>IO与中断线的映射,16* 7 = 112, 一共有16个中断线</p>
<p>Q:什么是中断线,能干什么? A:中断线能发出中断请求</p>
</blockquote>
<p>△.同一时刻只有一个引脚能映射到某根中断线</p>
<p>原理:</p>
<p>GPIOX.0映射到EXT10<br>GPIOX.1映射到EXT11<br>GPIOX.15映射到EXTI15<br>e.g.PA.0~PG.0可以映射到EXIT0</p>
<p>I0口外部中断在中断向量表中只分配了7个<strong>中断向量</strong>，也就是只能使用7个中断服务函数</p>
<h3 id="常用库函数"><a href="#常用库函数" class="headerlink" title="常用库函数"></a>常用库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_EXTILineConig</span><span class="params">(<span class="keyword">uint8_t</span> GPIO,<span class="keyword">uint8_t</span> PortSource,<span class="keyword">uint8_t</span> GPIO_PinSource)</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置IO口与中断线的映射关系：</span></span></span><br><span class="line">exp:GPIO_EXTILineContig(GPIO_PortSourceGPIOE, GPIO_PinSource2)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTIInit</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span></span>;</span><br><span class="line"><span class="comment">//初始化中断线：触发方式等</span></span><br><span class="line"><span class="function">ITStatus <span class="title">EXTI_GetlTStatus</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_hLine)</span></span>;</span><br><span class="line"><span class="comment">//判断中断线中断状态，是否发生</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_ClearlTPendingBit</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span></span><br><span class="line"><span class="function"><span class="comment">//清除中断线上的中断标志位</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitStructure.EXTI_Line=EXTI_Line2;<span class="comment">// 指定要配置的中断线</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode =EXTI_Mode_Interrupt;<span class="comment">// 模式:事件or中断</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger =EXTI_Trigger_Faling;<span class="comment">//上升沿、下降沿、双触发沿</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd =ENABLE;<span class="comment">// 使能、失能</span></span><br><span class="line">EXTI_Init(&amp; EXTI_InitStructure);</span><br></pre></td></tr></table></figure>
<h3 id="配置的一般步骤-1"><a href="#配置的一般步骤-1" class="headerlink" title="配置的一般步骤"></a>配置的一般步骤</h3><p><img src="/2019/10/15/玩玩Stm32/hexo\source\_posts\玩玩Stm32\外部中断.jpg" alt="外部中断"></p>
<p>demo：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTIX_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> 	<span class="comment">// 声明初始化结构体变量</span></span><br><span class="line"> 	EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line"> 	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">    KEY_Init();	 <span class="comment">//	按键端口初始化</span></span><br><span class="line"></span><br><span class="line">  	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);	<span class="comment">//使能复用功能时钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GPIOE.2 中断线以及中断初始化配置   下降沿触发</span></span><br><span class="line">  GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2);</span><br><span class="line"></span><br><span class="line">  	EXTI_InitStructure.EXTI_Line=EXTI_Line2;	<span class="comment">//KEY2</span></span><br><span class="line">  	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;	</span><br><span class="line">  	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">  	EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">  	EXTI_Init(&amp;EXTI_InitStructure);	 	<span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// ▲由于参数一致，所以不需要修改EXTI_InitStructure的功能参数</span></span><br><span class="line">   <span class="comment">//GPIOE.3	  中断线以及中断初始化配置 下降沿触发 //KEY1</span></span><br><span class="line">  GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource3);</span><br><span class="line">  	EXTI_InitStructure.EXTI_Line=EXTI_Line3;</span><br><span class="line">  	EXTI_Init(&amp;EXTI_InitStructure);	  	<span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//GPIOA.0	  中断线以及中断初始化配置 上升沿触发 PA0  WK_UP</span></span><br><span class="line"> GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0); </span><br><span class="line"></span><br><span class="line">  	EXTI_InitStructure.EXTI_Line=EXTI_Line0;</span><br><span class="line">  	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;</span><br><span class="line">  	EXTI_Init(&amp;EXTI_InitStructure);		<span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;			<span class="comment">//使能按键WK_UP所在的外部中断通道</span></span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0x02</span>;	<span class="comment">//抢占优先级2， </span></span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0x03</span>;					<span class="comment">//子优先级3</span></span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;								<span class="comment">//使能外部中断通道</span></span><br><span class="line">  	NVIC_Init(&amp;NVIC_InitStructure); </span><br><span class="line"></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;			<span class="comment">//使能按键KEY2所在的外部中断通道</span></span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0x02</span>;	<span class="comment">//抢占优先级2， </span></span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0x02</span>;					<span class="comment">//子优先级2</span></span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;								<span class="comment">//使能外部中断通道</span></span><br><span class="line">  	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;			<span class="comment">//使能按键KEY1所在的外部中断通道</span></span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0x02</span>;	<span class="comment">//抢占优先级2 </span></span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0x01</span>;					<span class="comment">//子优先级1 </span></span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;								<span class="comment">//使能外部中断通道</span></span><br><span class="line">  	NVIC_Init(&amp;NVIC_InitStructure);  	  <span class="comment">//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//外部中断2服务程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI2_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	delay_ms(<span class="number">10</span>);<span class="comment">//消抖</span></span><br><span class="line">	<span class="keyword">if</span>(KEY2==<span class="number">0</span>)	  <span class="comment">//按键KEY2</span></span><br><span class="line">	&#123;</span><br><span class="line">		LED0=!LED0;</span><br><span class="line">	&#125;		 </span><br><span class="line">	EXTI_ClearITPendingBit(EXTI_Line2);  <span class="comment">//清除LINE2上的中断标志位  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部中断3服务程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI3_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delay_ms(<span class="number">10</span>);<span class="comment">//消抖</span></span><br><span class="line">	<span class="keyword">if</span>(KEY1==<span class="number">0</span>)	 <span class="comment">//按键KEY1</span></span><br><span class="line">	&#123;				 </span><br><span class="line">		LED1=!LED1;</span><br><span class="line">	&#125;		 </span><br><span class="line">	EXTI_ClearITPendingBit(EXTI_Line3);  <span class="comment">//清除LINE3上的中断标志位  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI4_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	delay_ms(<span class="number">10</span>);<span class="comment">//消抖</span></span><br><span class="line">	<span class="keyword">if</span>(KEY0==<span class="number">0</span>)	 <span class="comment">//按键KEY0</span></span><br><span class="line">	&#123;</span><br><span class="line">		LED0=!LED0;</span><br><span class="line">		LED1=!LED1; </span><br><span class="line">	&#125;		 </span><br><span class="line">	EXTI_ClearITPendingBit(EXTI_Line4);  <span class="comment">//清除LINE4上的中断标志位  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;		</span><br><span class="line">	delay_init();	    	 <span class="comment">//延时函数初始化	  </span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="comment">//设置NVIC中断分组2:2位抢占优先级，2位响应优先级</span></span><br><span class="line">	uart_init(<span class="number">115200</span>);	 <span class="comment">//串口初始化为115200</span></span><br><span class="line"> 	LED_Init();		  		<span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">	BEEP_Init();         	<span class="comment">//初始化蜂鸣器端口</span></span><br><span class="line">	KEY_Init();         	<span class="comment">//初始化与按键连接的硬件接口</span></span><br><span class="line">	EXTIX_Init();		 	<span class="comment">//外部中断初始化</span></span><br><span class="line">	LED0=<span class="number">0</span>;					<span class="comment">//点亮LED0</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;	    </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"OK\r\n"</span>);	</span><br><span class="line">		delay_ms(<span class="number">1000</span>);	  </span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><h3 id="u8、u16、Size-t是什么类型"><a href="#u8、u16、Size-t是什么类型" class="headerlink" title="u8、u16、Size_t是什么类型?"></a>u8、u16、Size_t是什么类型?</h3><h4 id="u8、u16"><a href="#u8、u16" class="headerlink" title="u8、u16"></a>u8、u16</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!&lt; Signed integer types  */</span></span><br><span class="line"><span class="keyword">typedef</span>   <span class="keyword">signed</span> <span class="keyword">char</span>     <span class="keyword">int8_t</span>;	<span class="comment">//有符号8位数</span></span><br><span class="line"><span class="keyword">typedef</span>   <span class="keyword">signed</span> <span class="keyword">short</span>    <span class="keyword">int16_t</span>;	<span class="comment">//有符号16位数</span></span><br><span class="line"><span class="keyword">typedef</span>   <span class="keyword">signed</span> <span class="keyword">long</span>     <span class="keyword">int32_t</span>;	<span class="comment">//有符号32位数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*!&lt; Unsigned integer types  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>     <span class="keyword">uint8_t</span>;  <span class="comment">//无符号8位数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>    <span class="keyword">uint16_t</span>;	<span class="comment">//无符号16位数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>     <span class="keyword">uint32_t</span>;	<span class="comment">//无符号32位数</span></span><br></pre></td></tr></table></figure>
<h4 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h4><p>size_t是C++标准在stddef.h中定义的。这个类型足以用来表示对象的大小。size_t的真实类型与操作系统有关。size_t在32位架构上是4字节，在64位架构上是8字节，在不同架构上进行编译时需要注意这个问题。而int在不同架构下都是4字节，与size_t不同；且int为带符号数，size_t为无符号数。</p>
<h3 id="电平相关知识"><a href="#电平相关知识" class="headerlink" title="电平相关知识"></a>电平相关知识</h3><p> 单片机是一种数字集成芯片，数字电路中只有两种电平高电平和低电平。为了让大家在刚起步的时候对电平特性有一个清晰的认识，我们暂且定义单片机输出与输入为<strong>TTL</strong>电平，其中高电平为+5V,低电平为0V。计算机的串口为<strong>RS-232C</strong>电平。这里要强调的是，RS-232C电平为负逻辑电平。因此当计算机与单片机之间要通信时，需要加电平转换芯片，我们在TX-1C单片机实验板上所加的电平转换芯片是MAX232 。</p>
<p> 常用的逻辑电平有TTL、CMOS、LVTTL、ECL、PECL、 GTL 、RS-232. RS-422. RS-485、LVDS等.其中TTL和CMOS的逻辑电平按典型电压可分为四类：5V系列(5V TL和5V CMOS)、3.3V 系列，2.5V 系列和1.8V系列，</p>
<p>T电平信号用的最多，这是因为，数据表示通常采用二进制，+5V等价于逻辑1，0V等价于逻辑0）.这被称为TTL（晶体管一晶体管逻辑电平）信号系统，这是计算机处理器控制的设备内部各部分之间通信的标准技术。TTL电平信号对于计算机处理器控制的设备内部的数据传输是很理想的，首先计算机处理器控制的设备内部的数据传输对于电源的要求不高，热损耗也较低，另外TTL电平信号直接与集成电路连接而不需要价格昂贵的线路驱动器</p>
<h3 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h3><p>判断u8数组开头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/////////////////////////</span></span><br><span class="line"><span class="comment">// 判断u8 arr开头是否为str //</span></span><br><span class="line"><span class="comment">////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">u8cmp</span><span class="params">(u8 *arr, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( arr[i] != str[i])&#123;</span><br><span class="line">                <span class="comment">// arr shorter than str</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i] == <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">// not start with</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// arr start with str</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2019/10/15/玩玩Stm32/">https://nymrli.top/2019/10/15/玩玩Stm32/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2019/10/18/软件测试笔记/" title="软件测试笔记"><span>< PreviousPost</span><br><span class="prevTitle">软件测试笔记</span></a><a class="nextSlogan" href="/2019/10/07/蒙特卡洛树搜索MCTS/" title="蒙特卡洛树搜索MCTS"><span>NextPost ></span><br><span class="nextTitle">蒙特卡洛树搜索MCTS</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '玩玩Stm32',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><span>备案号:苏ICP备18015439号</span></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#玩玩Stm32"><span class="toc-number">1.</span> <span class="toc-text">玩玩Stm32</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#文件结构"><span class="toc-number">1.1.</span> <span class="toc-text">文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编写规范："><span class="toc-number">1.1.1.</span> <span class="toc-text">编写规范：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO"><span class="toc-number">1.2.</span> <span class="toc-text">GPIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#工作模式："><span class="toc-number">1.2.1.</span> <span class="toc-text">工作模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPIO重要函数"><span class="toc-number">1.2.2.</span> <span class="toc-text">GPIO重要函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#具体说明"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">具体说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#demo-跑马灯实验"><span class="toc-number">1.2.3.</span> <span class="toc-text">demo : 跑马灯实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#完整代码"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">完整代码:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作IO口的三种方式："><span class="toc-number">1.2.4.</span> <span class="toc-text">操作IO口的三种方式：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断管理"><span class="toc-number">1.3.</span> <span class="toc-text">中断管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#中断优先级设置步骤"><span class="toc-number">1.3.1.</span> <span class="toc-text">中断优先级设置步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#串口通信"><span class="toc-number">1.4.</span> <span class="toc-text">串口通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置的一般步骤"><span class="toc-number">1.4.1.</span> <span class="toc-text">配置的一般步骤:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正点原子提供的USART库："><span class="toc-number">1.4.2.</span> <span class="toc-text">正点原子提供的USART库：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外部中断"><span class="toc-number">1.5.</span> <span class="toc-text">外部中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常用库函数"><span class="toc-number">1.5.1.</span> <span class="toc-text">常用库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置的一般步骤-1"><span class="toc-number">1.5.2.</span> <span class="toc-text">配置的一般步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录"><span class="toc-number">1.6.</span> <span class="toc-text">附录:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u8、u16、Size-t是什么类型"><span class="toc-number">1.6.1.</span> <span class="toc-text">u8、u16、Size_t是什么类型?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u8、u16"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">u8、u16</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#size-t"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">size_t</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#电平相关知识"><span class="toc-number">1.6.2.</span> <span class="toc-text">电平相关知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#功能函数"><span class="toc-number">1.6.3.</span> <span class="toc-text">功能函数</span></a></li></ol></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>