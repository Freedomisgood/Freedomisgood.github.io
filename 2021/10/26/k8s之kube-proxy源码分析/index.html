<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>k8s之kube-proxy源码分析 · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">k8s之kube-proxy源码分析</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2022/03/29</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="环境部署"> 环境部署</a><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="源码解析"> 源码解析</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">13,991</span> | Reading time: <span class="post-count">69</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="kubernetes-简单介绍"><a class="markdownIt-Anchor" href="#kubernetes-简单介绍"></a> kubernetes 简单介绍</h1>
<h2 id="背景介绍"><a class="markdownIt-Anchor" href="#背景介绍"></a> 背景介绍</h2>
<p>Kubernetes最初源于谷歌内部的Borg，提供了面向应用的<strong>容器集群部署和管理</strong>系统，目前为主流的微服务应用编排管理工具。</p>
<p>Kubernetes的目标旨在消除编排物理/虚拟计算、网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原理上进行自助运营。</p>
<p>Kubernetes具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。</p>
<blockquote>
<p>Borg是谷歌内部的大规模集群管理系统，负责对谷歌内部很多核心服务的调度和管理。Borg的目的是让用户能够不必操心资源管理的问题，从而更专注于自己的核心业务。Borg甚至能做到跨多个数据中心的资源利用率最大化。</p>
</blockquote>
<h2 id="架构设计"><a class="markdownIt-Anchor" href="#架构设计"></a> 架构设计</h2>
<p><img src="/2021/10/26/k8s之kube-proxy源码分析/C:%5CUsers%5Cmrli%5CDesktop%5Ck8s.png" alt="k8s"></p>
<p>Kubernetes属于主从分布式架构，主要由Master和Node组成，以及包括客户端命令行工具kubectl和其它附加项。</p>
<ul>
<li>Master：作为控制节点，对集群所有工作节点Node进行调度管理；由kube-apiServer、kube-scheduler、kube-controller-manager和etcd组成。</li>
<li>Node：作为工作节点，运行业务应用的容器；由kubelet、kube-proxy和docker（目前仍是主流的运行时）组成。</li>
</ul>
<h2 id="代码整体分析"><a class="markdownIt-Anchor" href="#代码整体分析"></a> 代码整体分析</h2>
<p><strong>目录分析</strong></p>
<p>通过<code>git clone</code>下来最新的K8S代码后，目前v1.22.2版本的代码结构通过<code>tree</code>命令可看到如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── api						</span><br><span class="line">├── build</span><br><span class="line">├── CHANGELOG</span><br><span class="line">├── cluster</span><br><span class="line">├── cmd</span><br><span class="line">├── docs</span><br><span class="line">├── hack</span><br><span class="line">├── LICENSES</span><br><span class="line">├── logo</span><br><span class="line">├── pkg</span><br><span class="line">├── plugin</span><br><span class="line">├── staging</span><br><span class="line">├── test</span><br><span class="line">├── third_party</span><br><span class="line">└── vendor</span><br></pre></td></tr></table></figure>
<p>k8s的程序入口都在cmd目录下面，核心逻辑都在pkg目录下面。这么做的好处是把程序入口和逻辑分开，因为程序入口只做了一些最简单的调用，具体逻辑是模块化的类库，即增强了程序的可读性，也便于一人负责一个模块多人互相协作，这一点在大型项目中非常重要。我们可以看到pkg目录下面有很多子目录，每一个子目录都包含了一个重要的组件。</p>
<h3 id="proxy源码目录结构分析"><a class="markdownIt-Anchor" href="#proxy源码目录结构分析"></a> proxy源码目录结构分析</h3>
<blockquote>
<p>要学习一份项目代码，除了学习其实现的原理外，其代码的组织结构也是非常有借鉴和学习价值的，并且先看明白目录结构更有助于我们检索想要阅读的代码段。</p>
</blockquote>
<p>cmd/kube-proxy目录负责kube-proxy的创建，是启动的入口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">│   ├── conntrack.go	 // 全局sysctl的一个接口, 各种sysctl字段的描述和辅助方法可以在这里找到</span><br><span class="line">│   ├── init_others.go	 // 判断Cli参数中OS, 并根据结果进行设置非 Win OS配置参数</span><br><span class="line">│   ├── init_windows.go	 // 判断Cli参数中OS, 并根据结果进行设置配置Win OS参数</span><br><span class="line">│   ├── server.go		 //Options、ProxyServer 结构定义及其创建(NewProxyServerDefault)和运行(Run)的方法。</span><br><span class="line">│   ├── server_others.go	// 非Win OS下的 NewProxyServer实现，创建好匹配 ProxyMode 的ProxyServer</span><br><span class="line">│   ├── server_others_test.go</span><br><span class="line">│   ├── server_test.go</span><br><span class="line">│   └── server_windows.go	// Win OS下的 NewProxyServer 实现，创建好匹配 ProxyMode 的ProxyServer</span><br><span class="line">├── OWNERS</span><br><span class="line">└── proxy.go			//kube-proxy的入口文件，提供main方法, 通过NewProxyCommand()产生Cobra.Command命令</span><br></pre></td></tr></table></figure>
<p>pkg/proxy是kube-proxy核心实现的代码目录，通过<code>tree -L 3</code>展示其3层深度的目录结构如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── apis</span><br><span class="line">│   ├── config</span><br><span class="line">│   │   ├── doc.go</span><br><span class="line">│   │   ├── fuzzer</span><br><span class="line">│   │   ├── OWNERS</span><br><span class="line">│   │   ├── register.go</span><br><span class="line">│   │   ├── register_test.go</span><br><span class="line">│   │   ├── scheme</span><br><span class="line">│   │   ├── types.go</span><br><span class="line">│   │   ├── v1alpha1</span><br><span class="line">│   │   ├── validation</span><br><span class="line">│   │   └── zz_generated.deepcopy.go</span><br><span class="line">│   └── well_known_labels.go</span><br><span class="line">├── config</span><br><span class="line">│   ├── api_test.go</span><br><span class="line">│   ├── config.go			 //定义ServiceUpdate,EndpointUpdate结构体以及ServiceConfigHandler,EndpointConfigHandler来处理Service和Endpoint的Update</span><br><span class="line">│   ├── config_test.go</span><br><span class="line">│   ├── doc.go</span><br><span class="line">│   └── OWNERS</span><br><span class="line">├── doc.go</span><br><span class="line">├── endpoints.go			// 定义了基础的BaseEndpoints， 实现了 endpoints 的更新与维护</span><br><span class="line">├── endpointslicecache.go	 // endpoints缓存实现</span><br><span class="line">├── endpointslicecache_test.go</span><br><span class="line">├── endpoints_test.go</span><br><span class="line">├── healthcheck				// 健康检查, 负责service listener和endpoint的health check，add/delete请求。</span><br><span class="line">│   ├── common.go</span><br><span class="line">│   ├── doc.go</span><br><span class="line">│   ├── healthcheck_test.go</span><br><span class="line">│   ├── proxier_health.go</span><br><span class="line">│   └── service_health.go</span><br><span class="line">├── iptables				 //proxy mode为 iptables 的实现</span><br><span class="line">│   ├── OWNERS</span><br><span class="line">│   ├── proxier.go</span><br><span class="line">│   └── proxier_test.go</span><br><span class="line">├── ipvs					 //proxy mode为 ipvs 的实现</span><br><span class="line">│   ├── graceful_termination.go</span><br><span class="line">│   ├── graceful_termination_test.go</span><br><span class="line">│   ├── ipset.go</span><br><span class="line">│   ├── ipset_test.go</span><br><span class="line">│   ├── netlink.go</span><br><span class="line">│   ├── netlink_linux.go</span><br><span class="line">│   ├── netlink_unsupported.go</span><br><span class="line">│   ├── OWNERS</span><br><span class="line">│   ├── proxier.go</span><br><span class="line">│   ├── proxier_test.go</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── safe_ipset.go</span><br><span class="line">│   └── testing</span><br><span class="line">│       ├── fake.go</span><br><span class="line">│       ├── fake_test.go</span><br><span class="line">│       └── util.go</span><br><span class="line">├── metaproxier</span><br><span class="line">│   └── meta_proxier.go</span><br><span class="line">├── metrics</span><br><span class="line">│   └── metrics.go</span><br><span class="line">├── OWNERS</span><br><span class="line">├── service.go</span><br><span class="line">├── service_test.go</span><br><span class="line">├── topology.go					 // 实现对 Endpoint 的路由过滤：提供FilterLocalEndpoint、FilterEndpoints两个方法</span><br><span class="line">├── topology_test.go</span><br><span class="line">├── types.go					 // ServicePort、Endpoint 重要接口定义</span><br><span class="line">├── userspace					 // proxy mode为 userspace 的实现</span><br><span class="line">│   ├── loadbalancer.go</span><br><span class="line">│   ├── OWNERS</span><br><span class="line">│   ├── port_allocator.go</span><br><span class="line">│   ├── port_allocator_test.go</span><br><span class="line">│   ├── proxier.go</span><br><span class="line">│   ├── proxier_test.go</span><br><span class="line">│   ├── proxysocket.go</span><br><span class="line">│   ├── rlimit.go</span><br><span class="line">│   ├── rlimit_windows.go</span><br><span class="line">│   ├── roundrobin.go</span><br><span class="line">│   └── roundrobin_test.go</span><br><span class="line">├── util</span><br><span class="line">│   ├── endpoints.go</span><br><span class="line">│   ├── endpoints_test.go</span><br><span class="line">│   ├── iptables</span><br><span class="line">│   │   ├── traffic.go</span><br><span class="line">│   │   └── traffic_test.go</span><br><span class="line">│   ├── network.go</span><br><span class="line">│   ├── testing</span><br><span class="line">│   │   └── fake.go</span><br><span class="line">│   ├── utils.go</span><br><span class="line">│   └── utils_test.go</span><br><span class="line">├── winkernel						// Win OS下的Kernel实现</span><br><span class="line">│   ├── hns_test.go</span><br><span class="line">│   ├── hnsV1.go</span><br><span class="line">│   ├── hnsV2.go</span><br><span class="line">│   ├── metrics.go</span><br><span class="line">│   ├── OWNERS</span><br><span class="line">│   ├── proxier.go</span><br><span class="line">│   └── proxier_test.go</span><br><span class="line">└── winuserspace					 // 系统为windows OS时，proxy mode为 userspace 的实现</span><br><span class="line">    ├── loadbalancer.go</span><br><span class="line">    ├── proxier.go</span><br><span class="line">    ├── proxier_test.go</span><br><span class="line">    ├── proxysocket.go</span><br><span class="line">    ├── roundrobin.go</span><br><span class="line">    ├── roundrobin_test.go</span><br><span class="line">    └── types.go</span><br></pre></td></tr></table></figure>
<h1 id="kube-proxy分析"><a class="markdownIt-Anchor" href="#kube-proxy分析"></a> kube-proxy分析</h1>
<p>kube-proxy是管理service的访问入口，实现Kubenetes Service通信与负载均衡机制，提供了集群内Pod对Service的访问和集群外访问service的方式。当用户创建 service 的时候，endpointController 会根据service 的 selector 找到对应的 pod，然后生成 endpoints 对象保存到 etcd 中。运行在每个节点上的Kube-proxy会通过api-server 获得etcd 中 Service和Endpoints的变化信息，并调用 kube-proxy 配置的代理模式来更新主机上的iptables 转发规则，通过修改iptables规则从而改变报文的流向，让集群中服务解析。从而实现了将业务请求连接到Service后具体的执行结点（endpoints）。</p>
<p>接下来我将会以iptables 代理模式为例,对proxy 的功能实现进行分析。基于iptables模式的kube-proxy的主要职责包括两大块：一是侦听service更新事件，并更新service相关的iptables规则；二是侦听endpoint更新事件，更新endpoint相关的iptables规则。</p>
<p><strong>分析目标</strong></p>
<p>带着问题看代码能收获的内容更多，因此在此，我们在心里保留两个问题：</p>
<ol>
<li>kube-proxy如何让集群内节点无法ping通clusterIP的？</li>
<li>为什么集群内节点可以通过<code>ClusterIP:Port</code>形式访问服务；集群外可以通过<code>NodeIP:NodePort</code>形式访问到服务</li>
</ol>
<p>好了，明确了以上两个问题后就让我们来让代码吧</p>
<h2 id="重要结构体说明"><a class="markdownIt-Anchor" href="#重要结构体说明"></a> 重要结构体说明</h2>
<p><code>kubernetes/cmd/proxy-server/app/server.go</code>作为cmd/kube-proxy入口的真正执行文件，主要是围绕ProxyServer和两个结构体进行了一系列初始化赋值的操作。因此，针对这两个结构体，我们需要详细了解下有什么内容</p>
<h3 id="proxyserver"><a class="markdownIt-Anchor" href="#proxyserver"></a> ProxyServer</h3>
<p>ProxyServer 结构体中定义的属性代表了kube-proxy server 运行时需要的所有变量。kube-proxy server 调用的方法均来该结构体内变量拥有的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ProxyServer <span class="keyword">struct</span> &#123;</span><br><span class="line">    Client                 clientset.Interface</span><br><span class="line">    EventClient            v1core.EventsGetter  </span><br><span class="line">    IptInterface           utiliptables.Interface <span class="comment">// 接口中定义了更新iptables 的方法集合，如DeleteChian,DeleteRule, EnsureChain,EnsureRule</span></span><br><span class="line">    IpvsInterface          utilipvs.Interface   <span class="comment">// 定义操作 ipvs 的方法集</span></span><br><span class="line">    IpsetInterface         utilipset.Interface <span class="comment">//定义了操作 ipset 的方法集</span></span><br><span class="line">    execer                 exec.Interface	   <span class="comment">// 定义包装os/exec库中Command, Commandcontext, LookPath方法的接口</span></span><br><span class="line">    Proxier                proxy.ProxyProvider <span class="comment">//Proxier 有五种实现方式，分别对应Linux环境中三种的代理模式和Windows环境下的三种的代理模式</span></span><br><span class="line">    Broadcaster            record.EventBroadcaster 	<span class="comment">//接受Event，交于各个处理函数进行处理</span></span><br><span class="line">    Recorder               record.EventRecorder 	<span class="comment">// Event 记录者</span></span><br><span class="line">    ConntrackConfiguration kubeproxyconfig.KubeProxyConntrackConfiguration</span><br><span class="line">    Conntracker            Conntracker 			   <span class="comment">// if nil, ignored</span></span><br><span class="line">    ProxyMode              <span class="keyword">string</span></span><br><span class="line">    NodeRef                *v1.ObjectReference</span><br><span class="line">    CleanupAndExit         <span class="keyword">bool</span></span><br><span class="line">    CleanupIPVS            <span class="keyword">bool</span></span><br><span class="line">    MetricsBindAddress     <span class="keyword">string</span>  			<span class="comment">//127.0.0.1:10249  http prometheus metrics port;</span></span><br><span class="line">    EnableProfiling        <span class="keyword">bool</span></span><br><span class="line">    OOMScoreAdj            *<span class="keyword">int32</span> 			<span class="comment">//通过一个数值用来表征进程当发生OOM时系统对该进程的行为</span></span><br><span class="line">    ResourceContainer      <span class="keyword">string</span></span><br><span class="line">    ConfigSyncPeriod       time.Duration 	<span class="comment">//Default 15m0s</span></span><br><span class="line">    ServiceEventHandler    config.ServiceHandler <span class="comment">//</span></span><br><span class="line">    EndpointsEventHandler  config.EndpointsHandler <span class="comment">//</span></span><br><span class="line">    HealthzServer          *healthcheck.HealthzServer <span class="comment">// 0.0.0.0:10256  http healthz port;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据源代码的注释提醒，以上数据成员都是必须有值的。</p>
<h3 id="options"><a class="markdownIt-Anchor" href="#options"></a> Options</h3>
<p>kube各组件中都以Options结构体提供配置参数，kube-scheduler中创建了专门的options目录以及options.go文件，kube-proxy中直接将其放在了cmd/app/server.go中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Options中记录了创建和运行proxy服务器所需的一切 */</span></span><br><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">	ConfigFile <span class="keyword">string</span>	    <span class="comment">// 记录了proxy服务器配置文件的位置</span></span><br><span class="line">	WriteConfigTo <span class="keyword">string</span>	<span class="comment">// 默认配置将被写入的路径。</span></span><br><span class="line">	CleanupAndExit <span class="keyword">bool</span> <span class="comment">// 当CleanupAndExit为真时，proxy服务器将会清理iptables和ipvs规则，然后退出。</span></span><br><span class="line">	WindowsService <span class="keyword">bool</span>	<span class="comment">// kube-proxy是否在Windows上作为一个服务运行，其对应的标志只在Windows构建中被注册</span></span><br><span class="line">	config *kubeproxyconfig.KubeProxyConfiguration		<span class="comment">// proxy服务器的配置对象，方便运行时读取配置</span></span><br><span class="line">	watcher filesystem.FSWatcher	 				<span class="comment">// 用于观察ConfigFile的更新变化。</span></span><br><span class="line">	proxyServer proxyRun		  	  				<span class="comment">// 启动proxy服务器的接口</span></span><br><span class="line">	errCh <span class="keyword">chan</span> error								<span class="comment">// 发送错误的通道</span></span><br><span class="line">	<span class="comment">// 下面的字段是占位符，不能直接映射到 config.KubeProxyConfiguration.</span></span><br><span class="line">	<span class="comment">// TODO remove these fields once the deprecated flags are removed.</span></span><br><span class="line">	master <span class="keyword">string</span>			<span class="comment">// master用于覆盖kubeconfig对apiserver的URL。</span></span><br><span class="line">	healthzPort <span class="keyword">int32</span>		<span class="comment">// healthz 服务器的端口</span></span><br><span class="line">	metricsPort <span class="keyword">int32</span>		<span class="comment">// metrics 服务器的端口</span></span><br><span class="line">	hostnameOverride <span class="keyword">string</span>	<span class="comment">// 如果从命令行标志中设置该值，则将优先于配置文件中的`HostnameOverride`值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="proxier"><a class="markdownIt-Anchor" href="#proxier"></a> Proxier</h3>
<p>在每一种代理模式下，都定义了自己的Proxier 结构体，该结构体及方法实现了该模式下的代理规则的更新方法。在Iptables 模式下，kubernetes/pkg/proxy/iptables/proxier.go文件中Proxier 结构体的定义如下所示：</p>
<p>kubernetes/pkg/proxy/iptables/proxier.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Proxier <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// the ipfamily on which this proxy is operating on.</span></span><br><span class="line">    ipFamily v1.IPFamily</span><br><span class="line">    <span class="comment">//EndpointChangeTracker中items属性为一个两级map,用来保存所有namespace 下endpoints 的变化信息。</span></span><br><span class="line">    <span class="comment">//第一级map以 types.NamespacedName 为键，value 值为该namespace下所有endpoints 更新前（previous)、后(current)的信息：前、后信息分别为一个map ,即第二级map: ServiceMap。</span></span><br><span class="line">    <span class="comment">//第二级map的key为ServicePortName 结构，[]Endpoint为值, 标记endpoints 对应的service，value为endpoint信息。 </span></span><br><span class="line">    <span class="comment">// EndpointChangeTracker 中实现了更新 endpoint 的方法</span></span><br><span class="line">    endpointsChanges *proxy.EndpointChangeTracker   </span><br><span class="line">    serviceChanges   *proxy.ServiceChangeTracker    <span class="comment">// 同理，ServiceChangeTracker 中使用一个两级map保存所有namespace 下的service的变化信息，并定义了更新service的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥锁，保护下列字段</span></span><br><span class="line">    mu           sync.Mutex                         </span><br><span class="line">    serviceMap   proxy.ServiceMap                   <span class="comment">// 同serviceChanges 的第二级 map 结构，记录了所有namespace下需要更新iptables规则的service </span></span><br><span class="line">    endpointsMap proxy.EndpointsMap                 <span class="comment">// 同endpointsChanges 的第二级 map 结构，记录了所有namespace 需要更新iptables规则的endpoints</span></span><br><span class="line">    portsMap     <span class="keyword">map</span>[utilproxy.LocalPort]utilproxy.Closeable</span><br><span class="line">    endpointsSynced <span class="keyword">bool</span>                            <span class="comment">// Proxier 初始化时为False </span></span><br><span class="line">    servicesSynced  <span class="keyword">bool</span>                            <span class="comment">// Proxier 初始化时为False</span></span><br><span class="line">    initialized     <span class="keyword">int32</span></span><br><span class="line">    syncRunner      *async.BoundedFrequencyRunner   <span class="comment">// async.BoundedFrequencyRunner 具有QPS功能，控制被托管方法的发生速率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// These are effectively const and do not need the mutex to be held.</span></span><br><span class="line">    syncPeriod    time.Duration</span><br><span class="line">    minSyncPeriod time.Duration</span><br><span class="line">    <span class="comment">// Values are CIDR's to exclude when cleaning up IPVS rules.</span></span><br><span class="line">    excludeCIDRs []*net.IPNet</span><br><span class="line">    <span class="comment">// Set to true to set sysctls arp_ignore and arp_announce</span></span><br><span class="line">    strictARP      <span class="keyword">bool</span></span><br><span class="line">    iptables       utiliptables.Interface                    <span class="comment">// iptables 的执行器，定义了 Iptables 的操作方法</span></span><br><span class="line">    ipvs           utilipvs.Interface                        <span class="comment">// iptables 的执行器，定义了 IPVS 的操作方法</span></span><br><span class="line">    ipset          utilipset.Interface                      </span><br><span class="line">    exec           utilexec.Interface                       </span><br><span class="line">    masqueradeAll  <span class="keyword">bool</span></span><br><span class="line">    masqueradeMark <span class="keyword">string</span></span><br><span class="line">    localDetector  proxyutiliptables.LocalTrafficDetector</span><br><span class="line">    hostname       <span class="keyword">string</span></span><br><span class="line">    nodeIP         net.IP</span><br><span class="line">    portMapper     netutils.PortOpener                       <span class="comment">// 已打开的UDP或TCP端口</span></span><br><span class="line">    recorder       events.EventRecorder                      <span class="comment">// 事件记录者</span></span><br><span class="line"></span><br><span class="line">    serviceHealthServer healthcheck.ServiceHealthServer</span><br><span class="line">    healthzServer       healthcheck.ProxierHealthUpdater</span><br><span class="line"></span><br><span class="line">    ipvsScheduler <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">    ipGetter IPGetter</span><br><span class="line">    <span class="comment">// The following buffers are used to reuse memory and avoid allocations</span></span><br><span class="line">    <span class="comment">// that are significantly impacting performance.</span></span><br><span class="line">    iptablesData     *bytes.Buffer</span><br><span class="line">    filterChainsData *bytes.Buffer</span><br><span class="line">    natChains        *bytes.Buffer</span><br><span class="line">    filterChains     *bytes.Buffer</span><br><span class="line">    natRules         *bytes.Buffer</span><br><span class="line">    filterRules      *bytes.Buffer</span><br><span class="line">    <span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">    netlinkHandle NetLinkHandle</span><br><span class="line">    <span class="comment">// ipsetList is the list of ipsets that ipvs proxier used.</span></span><br><span class="line">    ipsetList <span class="keyword">map</span>[<span class="keyword">string</span>]*IPSet</span><br><span class="line">    <span class="comment">// Values are as a parameter to select the interfaces which nodeport works.</span></span><br><span class="line">    nodePortAddresses []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// networkInterfacer defines an interface for several net library functions.</span></span><br><span class="line">    <span class="comment">// Inject for test purpose.</span></span><br><span class="line">    networkInterfacer     utilproxy.NetworkInterfacer</span><br><span class="line">    gracefuldeleteManager *GracefulTerminationManager</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="程序启动过程"><a class="markdownIt-Anchor" href="#程序启动过程"></a> 程序启动过程</h2>
<p>从CLI命令接收参数输入的入口切入，我们可以看到一个从初始化到服务启动的完整的流程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step1. 命令入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxyCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建空的Options结构体对象</span></span><br><span class="line">	opts := NewOptions()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建kube-proxy命令，并定义执行函数</span></span><br><span class="line">	cmd := &amp;cobra.Command&#123;</span><br><span class="line">		Use: <span class="string">"kube-proxy"</span>,</span><br><span class="line">		Long: <span class="string">`The Kubernetes network proxy runs on each node. This</span></span><br><span class="line"><span class="string">reflects services as defined in the Kubernetes API on each node and can do simple</span></span><br><span class="line"><span class="string">TCP, UDP, and SCTP stream forwarding or round robin TCP, UDP, and SCTP forwarding across a set of backends.</span></span><br><span class="line"><span class="string">Service cluster IPs and ports are currently found through Docker-links-compatible</span></span><br><span class="line"><span class="string">environment variables specifying ports opened by the service proxy. There is an optional</span></span><br><span class="line"><span class="string">addon that provides cluster DNS for these cluster IPs. The user must create a service</span></span><br><span class="line"><span class="string">with the apiserver API to configure the proxy.`</span>,</span><br><span class="line">		Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			verflag.PrintAndExitIfRequested()</span><br><span class="line">			cliflag.PrintFlags(cmd.Flags())</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err := initForOS(opts.WindowsService); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Failed OS init"</span>)</span><br><span class="line">				<span class="comment">// ACTION REQUIRED: Exit code changed from 255 to 1</span></span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err := opts.Complete(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Failed complete"</span>)</span><br><span class="line">				<span class="comment">// ACTION REQUIRED: Exit code changed from 255 to 1</span></span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err := opts.Validate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Failed validate"</span>)</span><br><span class="line">				<span class="comment">// ACTION REQUIRED: Exit code changed from 255 to 1</span></span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Options结构体初始化完成后, 根据配置启动proxy server</span></span><br><span class="line">			<span class="keyword">if</span> err := opts.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Error running ProxyServer"</span>)</span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		Args: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(arg) &gt; <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> fmt.Errorf(<span class="string">"%q does not take any arguments, got %q"</span>, cmd.CommandPath(), args)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="comment">// 为opts对象中的记录运行时配置的config对象进行默认初始化</span></span><br><span class="line">	opts.config, err = opts.ApplyDefaults(opts.config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">"Unable to create flag defaults"</span>)</span><br><span class="line">		<span class="comment">// ACTION REQUIRED: Exit code changed from 255 to 1</span></span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 接收命令FlagSet</span></span><br><span class="line">	fs := cmd.Flags()</span><br><span class="line">	<span class="comment">// 增加Flag参数</span></span><br><span class="line">	opts.AddFlags(fs)</span><br><span class="line">	fs.AddGoFlagSet(goflag.CommandLine) <span class="comment">// for --boot-id-file and --machine-id-file</span></span><br><span class="line">	<span class="comment">// 对以下文件类型进行命令补全提示</span></span><br><span class="line">	_ = cmd.MarkFlagFilename(<span class="string">"config"</span>, <span class="string">"yaml"</span>, <span class="string">"yml"</span>, <span class="string">"json"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step2. ①完善Options中的Config运行时配置对象；②启动具体的ProxyServer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Options)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(o.errCh)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(o.WriteConfigTo) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> o.writeConfigFile()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 创建ProxyServer</span></span><br><span class="line">	proxyServer, err := NewProxyServer(o)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果参数为真, 则清理iptables和ipvs规则，然后退出。</span></span><br><span class="line">	<span class="keyword">if</span> o.CleanupAndExit &#123;</span><br><span class="line">		<span class="keyword">return</span> proxyServer.CleanupAndExit()</span><br><span class="line">	&#125;</span><br><span class="line">	o.proxyServer = proxyServer</span><br><span class="line">	<span class="keyword">return</span> o.runLoop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Step3. runLoop阻塞循环将不断侦听proxy server配置文件的更新变化。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Options)</span> <span class="title">runLoop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果有监听器的话启动监听器</span></span><br><span class="line">	<span class="keyword">if</span> o.watcher != <span class="literal">nil</span> &#123;</span><br><span class="line">		o.watcher.Run()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 另起协程运行proxy server</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := o.proxyServer.Run()</span><br><span class="line">		o.errCh &lt;- err</span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">// while循环等待, 并通过o.errCh阻塞，如果错误通道中读取到异常则退出程序</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		err := &lt;-o.errCh</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="proxyserver创建过程"><a class="markdownIt-Anchor" href="#proxyserver创建过程"></a> ProxyServer创建过程</h3>
<p><code>cmd/kube-proxy/app/server_others.go</code>中根据Options中已初始化好的参数创建ProxyServer实例，其中会根据<code>getProxyMode(string(config.Mode), canUseIPVS, iptables.LinuxKernelCompatTester{})</code>来确定具体使用哪个proxier实例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ProxyServer对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxyServer</span><span class="params">(o *Options)</span> <span class="params">(*ProxyServer, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> newProxyServer(o.config, o.CleanupAndExit, o.master)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newProxyServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	config *proxyconfigapi.KubeProxyConfiguration,</span></span></span><br><span class="line"><span class="function"><span class="params">	cleanupAndExit <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	master <span class="keyword">string</span>)</span> <span class="params">(*ProxyServer, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"config is required"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c, err := configz.New(proxyconfigapi.GroupName); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Set(config)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to register configz: %s"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> iptInterface utiliptables.Interface</span><br><span class="line">	<span class="keyword">var</span> ipvsInterface utilipvs.Interface</span><br><span class="line">	<span class="keyword">var</span> kernelHandler ipvs.KernelHandler</span><br><span class="line">	<span class="keyword">var</span> ipsetInterface utilipset.Interface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建iptables工具，包装了os/exec中的command,LookPath,CommandContext 方法，组装一个系统调用的命令和参数</span></span><br><span class="line">	execer := exec.New()</span><br><span class="line"></span><br><span class="line">	kernelHandler = ipvs.NewLinuxKernelHandler()</span><br><span class="line">	<span class="comment">// 得到操作 ipset 的方法集接口</span></span><br><span class="line">	ipsetInterface = utilipset.New(execer)</span><br><span class="line">	<span class="comment">// 判断是否能够使用IPVS模式, IPVS在一定条件下会被退化成iptables</span></span><br><span class="line">	canUseIPVS, err := ipvs.CanUseIPVSProxier(kernelHandler, ipsetInterface, config.IPVS.Scheduler)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">string</span>(config.Mode) == proxyModeIPVS &amp;&amp; err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">"Can't use the IPVS proxier"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> canUseIPVS &#123;</span><br><span class="line">		ipvsInterface = utilipvs.New(execer)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We omit creation of pretty much everything if we run in cleanup mode</span></span><br><span class="line">	<span class="keyword">if</span> cleanupAndExit &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;ProxyServer&#123;</span><br><span class="line">			execer:         execer,</span><br><span class="line">			IpvsInterface:  ipvsInterface,</span><br><span class="line">			IpsetInterface: ipsetInterface,</span><br><span class="line">		&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(config.ShowHiddenMetricsForVersion) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		metrics.SetShowHidden()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从运行时配置中得到hostname</span></span><br><span class="line">	hostname, err := utilnode.GetHostname(config.HostnameOverride)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从给定的配置中创建与apiserver相匹配的kube客户端和event客户端。</span></span><br><span class="line">	client, eventClient, err := createClients(config.ClientConnection, master)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 得到proxy server使用的NodeIP</span></span><br><span class="line">	nodeIP := detectNodeIP(client, hostname, config.BindAddress)</span><br><span class="line">	klog.InfoS(<span class="string">"Detected node IP"</span>, <span class="string">"address"</span>, nodeIP.String())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create event recorder</span></span><br><span class="line">     <span class="comment">//EventBroadcaster会将收到的Event交于各个处理函数进行处理。接收Event的缓冲队列长为1000，不停地取走Event并广播给各个watcher;</span></span><br><span class="line">    <span class="comment">//watcher通过recordEvent()方法将Event写入对应的EventSink里，最大重试次数为12次，重试间隔随机生成(见staging/src/k8s.io/client-go/tools/record/event.go);</span></span><br><span class="line">    <span class="comment">// EnventSink  将在ProxyServer.Run() 中调用s.Broadcaster.StartRecordingToSink（） 传进来;</span></span><br><span class="line">    <span class="comment">// NewBroadcaster() 最后会启动一个goroutine 运行Loop 方法（staging/src/k8s.io/apimachinery/pkg/watch/mux.go)</span></span><br><span class="line">	eventBroadcaster := events.NewBroadcaster(&amp;events.EventSinkImpl&#123;Interface: client.EventsV1()&#125;)</span><br><span class="line">     <span class="comment">//EventRecorder通过generateEvent()实际生成各种Event，并将其添加到监视队列。</span></span><br><span class="line">	recorder := eventBroadcaster.NewRecorder(scheme.Scheme, <span class="string">"kube-proxy"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得节点Node</span></span><br><span class="line">	nodeRef := &amp;v1.ObjectReference&#123;</span><br><span class="line">		Kind:      <span class="string">"Node"</span>,</span><br><span class="line">		Name:      hostname,</span><br><span class="line">		UID:       types.UID(hostname),</span><br><span class="line">		Namespace: <span class="string">""</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> healthzServer healthcheck.ProxierHealthUpdater</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(config.HealthzBindAddress) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//服务健康检查的 IP 地址和端口(IPv4默认为0.0.0.0:10256，对于所有 IPv6 接口设置为 ::)</span></span><br><span class="line">		healthzServer = healthcheck.NewProxierHealthServer(config.HealthzBindAddress, <span class="number">2</span>*config.IPTables.SyncPeriod.Duration, recorder, nodeRef)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 声明proxier接口, 是kube-proxy work的真正实现类</span></span><br><span class="line">	<span class="keyword">var</span> proxier proxy.Provider</span><br><span class="line">	<span class="keyword">var</span> detectLocalMode proxyconfigapi.LocalMode</span><br><span class="line">	<span class="comment">// 得到代理模式，有三种: Userspace、IPTables、IPVS; 注：IPVS可能会退化成IPTables, IPTables也可能退化成Userspace</span></span><br><span class="line">	proxyMode := getProxyMode(<span class="keyword">string</span>(config.Mode), canUseIPVS, iptables.LinuxKernelCompatTester&#123;&#125;)</span><br><span class="line">	<span class="comment">// 选择CIDR模式，目前有两种: NodeCIDR、ClusterCIDR</span></span><br><span class="line">	detectLocalMode, err = getDetectLocalMode(config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"cannot determine detect-local-mode: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 声明节点信息</span></span><br><span class="line">	<span class="keyword">var</span> nodeInfo *v1.Node</span><br><span class="line">	<span class="keyword">if</span> detectLocalMode == proxyconfigapi.LocalModeNodeCIDR &#123;</span><br><span class="line">		klog.InfoS(<span class="string">"Watching for node, awaiting podCIDR allocation"</span>, <span class="string">"hostname"</span>, hostname)</span><br><span class="line">		nodeInfo, err = waitForPodCIDR(client, hostname)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		klog.InfoS(<span class="string">"NodeInfo"</span>, <span class="string">"PodCIDR"</span>, nodeInfo.Spec.PodCIDR, <span class="string">"PodCIDRs"</span>, nodeInfo.Spec.PodCIDRs)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.V(<span class="number">2</span>).InfoS(<span class="string">"DetectLocalMode"</span>, <span class="string">"LocalMode"</span>, <span class="keyword">string</span>(detectLocalMode))</span><br><span class="line">	<span class="comment">// 根据IP协议确定合适的更新iptables的实现类</span></span><br><span class="line">	primaryProtocol := utiliptables.ProtocolIPv4</span><br><span class="line">	<span class="keyword">if</span> netutils.IsIPv6(nodeIP) &#123;</span><br><span class="line">		primaryProtocol = utiliptables.ProtocolIPv6</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="comment">//iptInterface 赋值为runner结构体，该结构体实现了接口utiliptables.Interface中定义的方法，</span></span><br><span class="line">	<span class="comment">//各方法中通过runContext()方法调用execer的命令包装方法返回一个被包装的iptables 命令</span></span><br><span class="line">    iptInterface = utiliptables.New(execer, primaryProtocol)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ipt [<span class="number">2</span>]utiliptables.Interface</span><br><span class="line">	dualStack := <span class="literal">true</span> <span class="comment">// While we assume that node supports, we do further checks below</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> proxyMode != proxyModeUserspace &#123;</span><br><span class="line">		<span class="comment">// Create iptables handlers for both families, one is already created</span></span><br><span class="line">		<span class="comment">// Always ordered as IPv4, IPv6</span></span><br><span class="line">		<span class="comment">// 以IPv4-&gt;IPv6的顺序创建iptables处理程序</span></span><br><span class="line">		<span class="keyword">if</span> primaryProtocol == utiliptables.ProtocolIPv4 &#123;</span><br><span class="line">			ipt[<span class="number">0</span>] = iptInterface</span><br><span class="line">			ipt[<span class="number">1</span>] = utiliptables.New(execer, utiliptables.ProtocolIPv6)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ipt[<span class="number">0</span>] = utiliptables.New(execer, utiliptables.ProtocolIPv4)</span><br><span class="line">			ipt[<span class="number">1</span>] = iptInterface</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查内核是否支持iptable接口</span></span><br><span class="line">		<span class="keyword">for</span> _, perFamilyIpt := <span class="keyword">range</span> ipt &#123;</span><br><span class="line">			<span class="keyword">if</span> !perFamilyIpt.Present() &#123;</span><br><span class="line">				klog.V(<span class="number">0</span>).InfoS(<span class="string">"kube-proxy running in single-stack mode, this ipFamily is not supported"</span>, <span class="string">"ipFamily"</span>, perFamilyIpt.Protocol())</span><br><span class="line">				dualStack = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果代理模式为IPTables</span></span><br><span class="line">	<span class="keyword">if</span> proxyMode == proxyModeIPTables &#123;</span><br><span class="line">		klog.V(<span class="number">0</span>).InfoS(<span class="string">"Using iptables Proxier"</span>)</span><br><span class="line">		<span class="keyword">if</span> config.IPTables.MasqueradeBit == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// MasqueradeBit must be specified or defaulted.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to read IPTables MasqueradeBit from config"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 是否支持双栈</span></span><br><span class="line">		<span class="keyword">if</span> dualStack &#123;</span><br><span class="line">			klog.V(<span class="number">0</span>).InfoS(<span class="string">"kube-proxy running in dual-stack mode"</span>, <span class="string">"ipFamily"</span>, iptInterface.Protocol())</span><br><span class="line">			klog.V(<span class="number">0</span>).InfoS(<span class="string">"Creating dualStackProxier for iptables"</span>)</span><br><span class="line">			<span class="comment">// Always ordered to match []ipt</span></span><br><span class="line">			<span class="keyword">var</span> localDetectors [<span class="number">2</span>]proxyutiliptables.LocalTrafficDetector</span><br><span class="line">			localDetectors, err = getDualStackLocalDetectorTuple(detectLocalMode, config, ipt, nodeInfo)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create proxier: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// TODO this has side effects that should only happen when Run() is invoked.</span></span><br><span class="line">			proxier, err = iptables.NewDualStackProxier(</span><br><span class="line">				ipt,</span><br><span class="line">				utilsysctl.New(),</span><br><span class="line">				execer,</span><br><span class="line">				config.IPTables.SyncPeriod.Duration,</span><br><span class="line">				config.IPTables.MinSyncPeriod.Duration,</span><br><span class="line">				config.IPTables.MasqueradeAll,</span><br><span class="line">				<span class="keyword">int</span>(*config.IPTables.MasqueradeBit),</span><br><span class="line">				localDetectors,</span><br><span class="line">				hostname,</span><br><span class="line">				nodeIPTuple(config.BindAddress),</span><br><span class="line">				recorder,</span><br><span class="line">				healthzServer,</span><br><span class="line">				config.NodePortAddresses,</span><br><span class="line">			)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Create a single-stack proxier if and only if the node does not support dual-stack (i.e, no iptables support).</span></span><br><span class="line">			<span class="keyword">var</span> localDetector proxyutiliptables.LocalTrafficDetector</span><br><span class="line">			localDetector, err = getLocalDetector(detectLocalMode, config, iptInterface, nodeInfo)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create proxier: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// TODO this has side effects that should only happen when Run() is invoked.</span></span><br><span class="line">			proxier, err = iptables.NewProxier(</span><br><span class="line">				iptInterface,</span><br><span class="line">				utilsysctl.New(),</span><br><span class="line">				execer,</span><br><span class="line">				config.IPTables.SyncPeriod.Duration,</span><br><span class="line">				config.IPTables.MinSyncPeriod.Duration,</span><br><span class="line">				config.IPTables.MasqueradeAll,</span><br><span class="line">				<span class="keyword">int</span>(*config.IPTables.MasqueradeBit),</span><br><span class="line">				localDetector,</span><br><span class="line">				hostname,</span><br><span class="line">				nodeIP,</span><br><span class="line">				recorder,</span><br><span class="line">				healthzServer,</span><br><span class="line">				config.NodePortAddresses,</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create proxier: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 注册指标</span></span><br><span class="line">		proxymetrics.RegisterMetrics()</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> proxyMode == proxyModeIPVS &#123;</span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	useEndpointSlices := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> proxyMode == proxyModeUserspace &#123;</span><br><span class="line">		<span class="comment">// userspace mode doesn't support endpointslice.</span></span><br><span class="line">		useEndpointSlices = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;ProxyServer&#123;</span><br><span class="line">		Client:                 client,</span><br><span class="line">		EventClient:            eventClient,</span><br><span class="line">		IptInterface:           iptInterface,</span><br><span class="line">		IpvsInterface:          ipvsInterface,</span><br><span class="line">		IpsetInterface:         ipsetInterface,</span><br><span class="line">		execer:                 execer,</span><br><span class="line">		Proxier:                proxier,</span><br><span class="line">		Broadcaster:            eventBroadcaster,</span><br><span class="line">		Recorder:               recorder,</span><br><span class="line">		ConntrackConfiguration: config.Conntrack,</span><br><span class="line">		Conntracker:            &amp;realConntracker&#123;&#125;,</span><br><span class="line">		ProxyMode:              proxyMode,</span><br><span class="line">		NodeRef:                nodeRef,</span><br><span class="line">		MetricsBindAddress:     config.MetricsBindAddress,</span><br><span class="line">		BindAddressHardFail:    config.BindAddressHardFail,</span><br><span class="line">		EnableProfiling:        config.EnableProfiling,</span><br><span class="line">		OOMScoreAdj:            config.OOMScoreAdj,</span><br><span class="line">		ConfigSyncPeriod:       config.ConfigSyncPeriod.Duration,</span><br><span class="line">		HealthzServer:          healthzServer,</span><br><span class="line">		UseEndpointSlices:      useEndpointSlices,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完成后，即可通过<code>err := o.proxyServer.Run()</code>启动proxyServer，接下来我们以iptables模式为例继续分析。</p>
<h3 id="iptables-proxy-server"><a class="markdownIt-Anchor" href="#iptables-proxy-server"></a> iptables proxy server</h3>
<p>代码主要在pkg/proxy/iptables/proxier.go中实现，首先以单栈proxier分析iptables proxier构造特性见NewProxier函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个iptables proxier实例, 由于iptables的逻辑, 我们假设一台机器上只有一个Proxier在工作。如果iptables未能更新或获得初始锁，将返回一个错误。一旦代理服务器被创建，它将在后台保持iptables的更新，如果某个iptables调用失败，它将不会终止。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxier</span><span class="params">(ipt utiliptables.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	sysctl utilsysctl.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	exec utilexec.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	syncPeriod time.Duration,</span></span></span><br><span class="line"><span class="function"><span class="params">	minSyncPeriod time.Duration,</span></span></span><br><span class="line"><span class="function"><span class="params">	masqueradeAll <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	masqueradeBit <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	localDetector proxyutiliptables.LocalTrafficDetector,</span></span></span><br><span class="line"><span class="function"><span class="params">	hostname <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	nodeIP net.IP,</span></span></span><br><span class="line"><span class="function"><span class="params">	recorder events.EventRecorder,</span></span></span><br><span class="line"><span class="function"><span class="params">	healthzServer healthcheck.ProxierHealthUpdater,</span></span></span><br><span class="line"><span class="function"><span class="params">	nodePortAddresses []<span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Proxier, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// kube-proxy要求NODE节点操作系统中有/sys/module/br_netfilter模块，还要设置bridge-nf-call-iptables=1；</span></span><br><span class="line">    <span class="comment">//如果不满足要求，kube-proxy在运行过程中设置的某些iptables规则就不会工作。</span></span><br><span class="line">	<span class="keyword">if</span> err := utilproxy.EnsureSysctl(sysctl, sysctlRouteLocalnet, <span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当容器连接到Linux网桥（但不是SDN网桥）时，代理需要br_netfilter和bridge-nf-call-iptables=1。 在大多数插件处理这个问题之前，当配置缺失时要记录日志</span></span><br><span class="line">	<span class="keyword">if</span> val, err := sysctl.GetSysctl(sysctlBridgeCallIPTables); err == <span class="literal">nil</span> &amp;&amp; val != <span class="number">1</span> &#123;</span><br><span class="line">		klog.InfoS(<span class="string">"Missing br-netfilter module or unset sysctl br-nf-call-iptables, proxy may not work as intended"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成用于SNAT规则的mark标记</span></span><br><span class="line">	masqueradeValue := <span class="number">1</span> &lt;&lt; <span class="keyword">uint</span>(masqueradeBit)</span><br><span class="line">	masqueradeMark := fmt.Sprintf(<span class="string">"%#08x"</span>, masqueradeValue)</span><br><span class="line">	klog.V(<span class="number">2</span>).InfoS(<span class="string">"Using iptables mark for masquerade"</span>, <span class="string">"ipFamily"</span>, ipt.Protocol(), <span class="string">"mark"</span>, masqueradeMark)</span><br><span class="line"></span><br><span class="line">	serviceHealthServer := healthcheck.NewServiceHealthServer(hostname, recorder, nodePortAddresses)</span><br><span class="line"></span><br><span class="line">	ipFamily := v1.IPv4Protocol</span><br><span class="line">	<span class="keyword">if</span> ipt.IsIPv6() &#123;</span><br><span class="line">		ipFamily = v1.IPv6Protocol</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipFamilyMap := utilproxy.MapCIDRsByIPFamily(nodePortAddresses)</span><br><span class="line">	nodePortAddresses = ipFamilyMap[ipFamily]</span><br><span class="line">	<span class="comment">// Log the IPs not matching the ipFamily</span></span><br><span class="line">	<span class="keyword">if</span> ips, ok := ipFamilyMap[utilproxy.OtherIPFamily(ipFamily)]; ok &amp;&amp; <span class="built_in">len</span>(ips) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		klog.InfoS(<span class="string">"Found node IPs of the wrong family"</span>, <span class="string">"ipFamily"</span>, ipFamily, <span class="string">"IPs"</span>, strings.Join(ips, <span class="string">","</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proxier := &amp;Proxier&#123;</span><br><span class="line">		portsMap:                 <span class="built_in">make</span>(<span class="keyword">map</span>[netutils.LocalPort]netutils.Closeable),</span><br><span class="line">		serviceMap:               <span class="built_in">make</span>(proxy.ServiceMap),</span><br><span class="line">		serviceChanges:           proxy.NewServiceChangeTracker(newServiceInfo, ipFamily, recorder, <span class="literal">nil</span>),</span><br><span class="line">		endpointsMap:             <span class="built_in">make</span>(proxy.EndpointsMap),</span><br><span class="line">		endpointsChanges:         proxy.NewEndpointChangeTracker(hostname, newEndpointInfo, ipFamily, recorder, <span class="literal">nil</span>),</span><br><span class="line">		syncPeriod:               syncPeriod,</span><br><span class="line">		iptables:                 ipt,</span><br><span class="line">		masqueradeAll:            masqueradeAll,</span><br><span class="line">		masqueradeMark:           masqueradeMark,</span><br><span class="line">		exec:                     exec,</span><br><span class="line">		localDetector:            localDetector,</span><br><span class="line">		hostname:                 hostname,</span><br><span class="line">		nodeIP:                   nodeIP,</span><br><span class="line">		portMapper:               &amp;netutils.ListenPortOpener,</span><br><span class="line">		recorder:                 recorder,</span><br><span class="line">		serviceHealthServer:      serviceHealthServer,</span><br><span class="line">		healthzServer:            healthzServer,</span><br><span class="line">		precomputedProbabilities: <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">1001</span>),</span><br><span class="line">		iptablesData:             bytes.NewBuffer(<span class="literal">nil</span>),</span><br><span class="line">		existingFilterChainsData: bytes.NewBuffer(<span class="literal">nil</span>),</span><br><span class="line">		filterChains:             bytes.NewBuffer(<span class="literal">nil</span>),</span><br><span class="line">		filterRules:              bytes.NewBuffer(<span class="literal">nil</span>),</span><br><span class="line">		natChains:                bytes.NewBuffer(<span class="literal">nil</span>),</span><br><span class="line">		natRules:                 bytes.NewBuffer(<span class="literal">nil</span>),</span><br><span class="line">		nodePortAddresses:        nodePortAddresses,</span><br><span class="line">		networkInterfacer:        utilproxy.RealNetwork&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	burstSyncs := <span class="number">2</span></span><br><span class="line">	klog.V(<span class="number">2</span>).InfoS(<span class="string">"Iptables sync params"</span>, <span class="string">"ipFamily"</span>, ipt.Protocol(), <span class="string">"minSyncPeriod"</span>, minSyncPeriod, <span class="string">"syncPeriod"</span>, syncPeriod, <span class="string">"burstSyncs"</span>, burstSyncs)</span><br><span class="line">	<span class="comment">// We pass syncPeriod to ipt.Monitor, which will call us only if it needs to.</span></span><br><span class="line">	<span class="comment">// We need to pass *some* maxInterval to NewBoundedFrequencyRunner anyway though.</span></span><br><span class="line">	<span class="comment">// time.Hour is arbitrary.</span></span><br><span class="line">	proxier.syncRunner = async.NewBoundedFrequencyRunner(<span class="string">"sync-runner"</span>, proxier.syncProxyRules, minSyncPeriod, time.Hour, burstSyncs)</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 开启iptables监视的协程, 主要的通过 proxier.syncProxyRules 的方法来维护iptables规则变化</span></span><br><span class="line">	<span class="keyword">go</span> ipt.Monitor(kubeProxyCanaryChain, []utiliptables.Table&#123;utiliptables.TableMangle, utiliptables.TableNAT, utiliptables.TableFilter&#125;,</span><br><span class="line">		proxier.syncProxyRules, syncPeriod, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ipt.HasRandomFully() &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).InfoS(<span class="string">"Iptables supports --random-fully"</span>, <span class="string">"ipFamily"</span>, ipt.Protocol())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).InfoS(<span class="string">"Iptables does not support --random-fully"</span>, <span class="string">"ipFamily"</span>, ipt.Protocol())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxier, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="proxyserverrun"><a class="markdownIt-Anchor" href="#proxyserverrun"></a> ProxyServer.Run()</h3>
<p>是proxyServer的启动命令，在<code>cmd/kube-proxy/app/server.go</code>中统一定义的模板方法，并没有被具体的proxier实现。开启了<code>go serviceConfig.Run(wait.NeverStop)</code>、<code>go endpointsConfig.Run(wait.NeverStop)</code>or<code>go endpointSliceConfig.Run(wait.NeverStop)</code>、<code>go nodeConfig.Run(wait.NeverStop)</code>、<code>go s.Proxier.SyncLoop()</code>多个协程，自身被errCh通道阻塞，等待接收从子协程抛出的err</p>
<p>在Run() 方法中，大致做了如下工作：</p>
<ul>
<li>准备工作，如设置OOMScoreAdj并设置连接跟踪</li>
<li>注册service 和endpoints 的处理方法，使用list-watch 机制对service，endpoints资源监听。</li>
<li>最后进入一个无限循环，对service与endpoints的变化进行iptables规则的同步。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ProxyServer)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// To help debugging, immediately log version</span></span><br><span class="line">	klog.InfoS(<span class="string">"Version info"</span>, <span class="string">"version"</span>, version.Get())</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** 1.1 设置oom数值 */</span></span><br><span class="line">    <span class="comment">//    //在用户空间通过写oomScoreAdj参数到/proc/self/oom_score_adj文件来改变进程的 oom_adj 内核参数；</span></span><br><span class="line">    <span class="comment">//oom_adj的值的大小决定了进程被 OOM killer，取值范围[-1000,1000] 选中杀掉的概率,值越低越不容易被杀死.此处默认值是-999。</span></span><br><span class="line">	<span class="comment">// TODO(vmarmol): Use container config for this.</span></span><br><span class="line">	<span class="keyword">var</span> oomAdjuster *oom.OOMAdjuster</span><br><span class="line">	<span class="keyword">if</span> s.OOMScoreAdj != <span class="literal">nil</span> &#123;</span><br><span class="line">		oomAdjuster = oom.NewOOMAdjuster()</span><br><span class="line">		<span class="keyword">if</span> err := oomAdjuster.ApplyOOMScoreAdj(<span class="number">0</span>, <span class="keyword">int</span>(*s.OOMScoreAdj)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">"Failed to apply OOMScore"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/** 设置oom数值 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 1.2 设置连接跟踪 */</span></span><br><span class="line">	<span class="keyword">if</span> s.Broadcaster != <span class="literal">nil</span> &amp;&amp; s.EventClient != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// EventSinkImpl 包装了处理event 的方法create ,update, patchs</span></span><br><span class="line">        <span class="comment">//s.Broadcaster 已经在ProxyServer 初始化中作为一个goroutine 在运行。</span></span><br><span class="line">		stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		s.Broadcaster.StartRecordingToSink(stopCh)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// TODO(thockin): make it possible for healthz and metrics to be on the same port.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> errCh <span class="keyword">chan</span> error</span><br><span class="line">	<span class="keyword">if</span> s.BindAddressHardFail &#123;</span><br><span class="line">		errCh = <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start up a healthz server if requested</span></span><br><span class="line">	serveHealthz(s.HealthzServer, errCh)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start up a metrics server if requested</span></span><br><span class="line">	serveMetrics(s.MetricsBindAddress, s.ProxyMode, s.EnableProfiling, errCh)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tune conntrack, if requested</span></span><br><span class="line">	<span class="comment">// Conntracker is always nil for windows</span></span><br><span class="line">	<span class="keyword">if</span> s.Conntracker != <span class="literal">nil</span> &#123;</span><br><span class="line">		max, err := getConntrackMax(s.ConntrackConfiguration)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> max &gt; <span class="number">0</span> &#123;</span><br><span class="line">			err := s.Conntracker.SetMax(max)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err != errReadOnlySysFS &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// errReadOnlySysFS is caused by a known docker issue (https://github.com/docker/docker/issues/24000),</span></span><br><span class="line">				<span class="comment">// the only remediation we know is to restart the docker daemon.</span></span><br><span class="line">				<span class="comment">// Here we'll send an node event with specific reason and message, the</span></span><br><span class="line">				<span class="comment">// administrator should decide whether and how to handle this issue,</span></span><br><span class="line">				<span class="comment">// whether to drain the node and restart docker.  Occurs in other container runtimes</span></span><br><span class="line">				<span class="comment">// as well.</span></span><br><span class="line">				<span class="comment">// TODO(random-liu): Remove this when the docker bug is fixed.</span></span><br><span class="line">				<span class="keyword">const</span> message = <span class="string">"CRI error: /sys is read-only: "</span> +</span><br><span class="line">					<span class="string">"cannot modify conntrack limits, problems may arise later (If running Docker, see docker issue #24000)"</span></span><br><span class="line">				s.Recorder.Eventf(s.NodeRef, <span class="literal">nil</span>, api.EventTypeWarning, err.Error(), <span class="string">"StartKubeProxy"</span>, message)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> s.ConntrackConfiguration.TCPEstablishedTimeout != <span class="literal">nil</span> &amp;&amp; s.ConntrackConfiguration.TCPEstablishedTimeout.Duration &gt; <span class="number">0</span> &#123;</span><br><span class="line">			timeout := <span class="keyword">int</span>(s.ConntrackConfiguration.TCPEstablishedTimeout.Duration / time.Second)</span><br><span class="line">			<span class="keyword">if</span> err := s.Conntracker.SetTCPEstablishedTimeout(timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> s.ConntrackConfiguration.TCPCloseWaitTimeout != <span class="literal">nil</span> &amp;&amp; s.ConntrackConfiguration.TCPCloseWaitTimeout.Duration &gt; <span class="number">0</span> &#123;</span><br><span class="line">			timeout := <span class="keyword">int</span>(s.ConntrackConfiguration.TCPCloseWaitTimeout.Duration / time.Second)</span><br><span class="line">			<span class="keyword">if</span> err := s.Conntracker.SetTCPCloseWaitTimeout(timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/** 设置连接跟踪 */</span></span><br><span class="line">	noProxyName, err := labels.NewRequirement(apis.LabelServiceProxyName, selection.DoesNotExist, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	noHeadlessEndpoints, err := labels.NewRequirement(v1.IsHeadlessService, selection.DoesNotExist, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	labelSelector := labels.NewSelector()</span><br><span class="line">	labelSelector = labelSelector.Add(*noProxyName, *noHeadlessEndpoints)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建informer，过滤出期望以非默认service proxy运行的对象。</span></span><br><span class="line">	informerFactory := informers.NewSharedInformerFactoryWithOptions(s.Client, s.ConfigSyncPeriod,</span><br><span class="line">		informers.WithTweakListOptions(<span class="function"><span class="keyword">func</span><span class="params">(options *metav1.ListOptions)</span></span> &#123;</span><br><span class="line">			options.LabelSelector = labelSelector.String()</span><br><span class="line">		&#125;))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 2.创建配置记录变量, 创建ServiceConfig、endpointsConfig or EndpointSliceConfig 结构体，注册informer包括回调函数 */</span> </span><br><span class="line">    <span class="comment">//ServiceConfig结构体跟踪记录Service配置信息的变化</span></span><br><span class="line">	serviceConfig := config.NewServiceConfig(informerFactory.Core().V1().Services(), s.ConfigSyncPeriod)</span><br><span class="line">    <span class="comment">//RegisterEventHandler 是将Service的处理方法追加到serviceConfig的eventHandlers 中，eventHandlers为一个列表，元素类型ServiceHandler接口</span></span><br><span class="line">    <span class="comment">// ServiceHandler接口定义了每个hanlder 处理service的api方法:OnServiceAdd,OnServiceUpdate,OnServiceDelete,OnServiceSynced</span></span><br><span class="line">    <span class="comment">// 此处 s.ServiceEventHandler 为proxier，s.Proxier实现了 ServiceHandler 接口定义的方法</span></span><br><span class="line">	serviceConfig.RegisterEventHandler(s.Proxier)</span><br><span class="line">	<span class="keyword">go</span> serviceConfig.Run(wait.NeverStop)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果 s.Proxier 的类型为 EndpointsHandler</span></span><br><span class="line">	<span class="keyword">if</span> endpointsHandler, ok := s.Proxier.(config.EndpointsHandler); ok &amp;&amp; !s.UseEndpointSlices &#123;</span><br><span class="line">		endpointsConfig := config.NewEndpointsConfig(informerFactory.Core().V1().Endpoints(), s.ConfigSyncPeriod)</span><br><span class="line">        <span class="comment">// 注册事件处理handler</span></span><br><span class="line">		endpointsConfig.RegisterEventHandler(endpointsHandler)</span><br><span class="line">		<span class="keyword">go</span> endpointsConfig.Run(wait.NeverStop)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		endpointSliceConfig := config.NewEndpointSliceConfig(informerFactory.Discovery().V1().EndpointSlices(), s.ConfigSyncPeriod)</span><br><span class="line">        <span class="comment">//RegisterEventHandler 是将EndpointSliceHandler的处理方法追加到EndpointSliceConfig的eventHandlers 中，eventHandlers为一个列表，元素类型 EndpointSliceHandler 接口</span></span><br><span class="line">		endpointSliceConfig.RegisterEventHandler(s.Proxier)</span><br><span class="line">		<span class="keyword">go</span> endpointSliceConfig.Run(wait.NeverStop)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This has to start after the calls to NewServiceConfig and NewEndpointsConfig because those</span></span><br><span class="line">	<span class="comment">// functions must configure their shared informer event handlers first.</span></span><br><span class="line">	informerFactory.Start(wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.TopologyAwareHints) &#123;</span><br><span class="line">		<span class="comment">// Make an informer that selects for our nodename.</span></span><br><span class="line">		currentNodeInformerFactory := informers.NewSharedInformerFactoryWithOptions(s.Client, s.ConfigSyncPeriod,</span><br><span class="line">			informers.WithTweakListOptions(<span class="function"><span class="keyword">func</span><span class="params">(options *metav1.ListOptions)</span></span> &#123;</span><br><span class="line">				options.FieldSelector = fields.OneTermEqualSelector(<span class="string">"metadata.name"</span>, s.NodeRef.Name).String()</span><br><span class="line">			&#125;))</span><br><span class="line">		nodeConfig := config.NewNodeConfig(currentNodeInformerFactory.Core().V1().Nodes(), s.ConfigSyncPeriod)</span><br><span class="line">		nodeConfig.RegisterEventHandler(s.Proxier)</span><br><span class="line">		<span class="keyword">go</span> nodeConfig.Run(wait.NeverStop)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// This has to start after the calls to NewNodeConfig because that must</span></span><br><span class="line">		<span class="comment">// configure the shared informer event handler first.</span></span><br><span class="line">		currentNodeInformerFactory.Start(wait.NeverStop)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/** 2.创建配置记录变量 */</span> </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Birth Cry after the birth is successful</span></span><br><span class="line">	s.birthCry()</span><br><span class="line">    <span class="comment">/** 3.开启新协程进入无限Loop循环进行工作，对service与endpoints的变化进行iptables规则的同步。*/</span></span><br><span class="line">	<span class="keyword">go</span> s.Proxier.SyncLoop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &lt;-errCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：XxxxxConfig.RegisterEventHandler(s.Proxier)中s.Proxier都是实现了对应其接口的实体proxier，详细的实现可以去找具体的proxier，如iptables/proxier.go有很多On开头的方法</p>
<p>附：Service和Endpoint、EndpointSlice资源类结构体，可以看到其中全都有个eventHandlers的Slice维护了处理Handler。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceConfig tracks a set of service configurations.</span></span><br><span class="line"><span class="keyword">type</span> ServiceConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	listerSynced  cache.InformerSynced</span><br><span class="line">	eventHandlers []ServiceHandler</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// EndpointsConfig tracks a set of endpoints configurations.</span></span><br><span class="line"><span class="keyword">type</span> EndpointsConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	listerSynced  cache.InformerSynced</span><br><span class="line">	eventHandlers []EndpointsHandler</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// EndpointSliceConfig tracks a set of endpoints configurations.</span></span><br><span class="line"><span class="keyword">type</span> EndpointSliceConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	listerSynced  cache.InformerSynced</span><br><span class="line">	eventHandlers []EndpointSliceHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么具体的proxier是如何侦听endpoint和service的变化的呢？这个就要见上述各资源的注册过程中配置了什么，见kubernetes/pkg/proxy/config/config.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewServiceConfig creates a new ServiceConfig.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServiceConfig</span><span class="params">(serviceInformer coreinformers.ServiceInformer, resyncPeriod time.Duration)</span> *<span class="title">ServiceConfig</span></span> &#123;</span><br><span class="line">	result := &amp;ServiceConfig&#123;</span><br><span class="line">		listerSynced: serviceInformer.Informer().HasSynced,</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// serviceInformer.Informer() 返回一个sharedIndexInformer 实例(staing/src/k8s.io/client-go/tools/cache/shared_informer.go)，通过其AddEventHandlerWithResyncPeriod() 方法，将ResourceEventHandler实例赋值给processorListener结构体的handler属性，作为其事件发生的处理函数</span></span><br><span class="line">	serviceInformer.Informer().AddEventHandlerWithResyncPeriod(</span><br><span class="line">        <span class="comment">//结构体cache.ResourceEventHandlerFuncs 是一个ResourceEventHandler接口类型(staing/src/k8s.io/client-go/tools/cache/controller.go)，将ServicConfig 结构体的handleAddService 等方法赋予了cache.ResourceEventHandlerFuncs,实现一个ResourceEventHandler实例</span></span><br><span class="line">		cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">			AddFunc:    result.handleAddService,</span><br><span class="line">			UpdateFunc: result.handleUpdateService,</span><br><span class="line">			DeleteFunc: result.handleDeleteService,</span><br><span class="line">		&#125;,</span><br><span class="line">		resyncPeriod,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果发生了增加Service事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ServiceConfig)</span> <span class="title">handleAddService</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	service, ok := obj.(*v1.Service)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"unexpected object type: %v"</span>, obj))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c.eventHandlers &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">"Calling handler.OnServiceAdd"</span>)</span><br><span class="line">        <span class="comment">// 转而调用 注册的事件handler接口,即proxyServer.Proxier 来处理</span></span><br><span class="line">		c.eventHandlers[i].OnServiceAdd(service)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从(s *ProxyServerproxier)Run的方法中可以看到service处理方法的被调用流程：通过serviceConfig.RegisterEventHandler()方法注册挂载了proxyServer.Proxier实例，然后在serviceConfig中的handleAddService()等方法中以<code>c.eventHandlers[i].OnServiceAdd(service)</code>的形式调用proxier中的OnServiceAdd()等对应的方法。</p>
<p>其中，可以看到proxier的处理函数都以订阅者的模式被注册好了等待事件发生触发，此时的执行权力都转交给了上层，那么serviceInformer.Informer().AddEventHandlerWithResyncPeriod就成了新的执行的入口，因此我们可以看看它是怎么work的，<code>\staging\src\k8s.io\client-go\tools\cache\shared_informer.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">AddEventHandlerWithResyncPeriod</span><span class="params">(handler ResourceEventHandler, resyncPeriod time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="comment">//... 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将加载好的handler注册到listener监听器中</span></span><br><span class="line">	listener := newProcessListener(handler, resyncPeriod, determineResyncPeriod(resyncPeriod, s.resyncCheckPeriod), s.clock.Now(), initialBufferSize)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !s.started &#123;</span><br><span class="line">		s.processor.addListener(listener)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.blockDeltas.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line">	<span class="comment">// processor为sharedProcessor类型，其有一个 processorListener 的集合，可以向其监听器分发通知对象。 分发操作有两种， 会被同步分发到listener的子集中，（a）在运行时偶尔调用shouldResync时被重新得到的listener（b）每个最初被放入listener。</span></span><br><span class="line">	s.processor.addListener(listener)</span><br></pre></td></tr></table></figure>
<p>看到上面的代码，proxier 中OnServiceAdd() 等方法的调用流程大致就有数了：在上述serviceInformer.Informer()返回之前，还将调用SharedIndexInformer.InformerFor()方法给informerFactory的informers属性赋值f.informers[informerType] = informer，如下所示<code>\staging\src\k8s.io\apiextensions-apiserver\examples\client-go\pkg\client\informers\externalversions\factory.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InternalInformerFor returns the SharedIndexInformer for obj using an internal</span></span><br><span class="line"><span class="comment">// client.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">InformerFor</span><span class="params">(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	informerType := reflect.TypeOf(obj)</span><br><span class="line">    <span class="comment">// 判断是否有 informerType 类型的informers</span></span><br><span class="line">    <span class="comment">// f.informers为map[reflect.Type]cache.SharedIndexInformer</span></span><br><span class="line">	informer, exists := f.informers[informerType]</span><br><span class="line">	<span class="keyword">if</span> exists &#123;</span><br><span class="line">		<span class="keyword">return</span> informer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resyncPeriod, exists := f.customResync[informerType]</span><br><span class="line">	<span class="keyword">if</span> !exists &#123;</span><br><span class="line">		resyncPeriod = f.defaultResync</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	informer = newFunc(f.client, resyncPeriod)</span><br><span class="line">	f.informers[informerType] = informer</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> informer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此段代码的意义可理解为：从api server 监听到 informerType类型资源变化的处理者记录(映射)为informer。此处的资源类型即为service, informer 便为sharedIndexInformer。具体的调用时机和最上层方法入口就要去看informerFactory这个东西了，这又是k8s 中另一个比较系统的公共组件了，即它涉及到client-go的SharedInformer的触发规则和实现原理了。</p>
<h2 id="记录资源变化"><a class="markdownIt-Anchor" href="#记录资源变化"></a> 记录资源变化</h2>
<p>Proxier 实现了 services 和 endpoints 事件各种最终的观察者，最终的事件触发都会在 proxier 中进行处理。对于通过监听 API Server 变化的信息，通过调用ResourceHandler将变化的信息保存到 endpointsChanges 和 serviceChanges。那么一个ResourceHandler是如何实现的呢？service 和endpoints 的变化如何记录为servriceChanges 和endpointsChanges？回看上边源码中被注册的对象s.ServiceEventHandler，s.EndpointsEventHandler的具体实现便可明白。</p>
<p>service 和endpoints 的处理原则相似，以对servcie 的处理为例，看一下对service 的处理方法，<code>pkg/proxy/iptables/proxier.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加Service</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">OnServiceAdd</span><span class="params">(service *v1.Service)</span></span> &#123; </span><br><span class="line">    proxier.OnServiceUpdate(<span class="literal">nil</span>, service)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 更新Service</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">OnServiceUpdate</span><span class="params">(oldService, service *v1.Service)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> proxier.serviceChanges.Update(oldService, service) &amp;&amp; proxier.isInitialized() &#123;</span><br><span class="line">        proxier.syncRunner.Run() <span class="comment">// 通过channel 发送一个信号，调用tryRun()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除Service时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">OnServiceDelete</span><span class="params">(service *v1.Service)</span></span> &#123; </span><br><span class="line">    proxier.OnServiceUpdate(service, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OnServiceUpdate is called whenever modification of an existing</span></span><br><span class="line"><span class="comment">// service object is observed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">OnServiceUpdate</span><span class="params">(oldService, service *v1.Service)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> proxier.serviceChanges.Update(oldService, service) &amp;&amp; proxier.isInitialized() &#123;</span><br><span class="line">		proxier.Sync()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，上述三个情况：增加、删除service 都是给proxier.OnServiceUpdate() 传入参数后，由OnServiceUpdate() 方法处理，而proxier.OnServiceUpdate() 中又是通过proxier.serviceChanges.Update(oldService, service)实现的 ，因此重点看一下serviceChanges的Update() 方法是如何实现的。见<code>pkg/proxy/service.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据&lt;previous, current&gt;服务对，更新给定服务的变化图。 如果项目发生了变化，它返回true。</span></span><br><span class="line"><span class="comment">// 否则返回false。 Update可以用来添加/更新/删除ServiceChangeMap的项目。 例如。</span></span><br><span class="line"><span class="comment">// 添加项目</span></span><br><span class="line"><span class="comment">// - 传递&lt;nil, service&gt;作为&lt;previous, current&gt;对。</span></span><br><span class="line"><span class="comment">// 更新项目</span></span><br><span class="line"><span class="comment">// - 传递&lt;oldService, service&gt;作为&lt;previous, current&gt;对。</span></span><br><span class="line"><span class="comment">// 删除项目</span></span><br><span class="line"><span class="comment">// - 传递&lt;service, nil&gt;作为&lt;previous, current&gt;对。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sct *ServiceChangeTracker)</span> <span class="title">Update</span><span class="params">(previous, current *v1.Service)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    svc := current</span><br><span class="line">    <span class="keyword">if</span> svc == <span class="literal">nil</span> &#123;</span><br><span class="line">        svc = previous</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// previous == nil &amp;&amp; current == nil is unexpected, we should return false directly.</span></span><br><span class="line">    <span class="keyword">if</span> svc == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    namespacedName := types.NamespacedName&#123;Namespace: svc.Namespace, Name: svc.Name&#125;</span><br><span class="line"> </span><br><span class="line">    sct.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> sct.lock.Unlock()</span><br><span class="line"> </span><br><span class="line">    change, exists := sct.items[namespacedName] </span><br><span class="line">    <span class="keyword">if</span> !exists &#123; <span class="comment">// 在serviceChanges 中不存在一个以namespacedName 为key 的资源 </span></span><br><span class="line">        change = &amp;serviceChange&#123;&#125;  <span class="comment">// 初始化一个serviceChange</span></span><br><span class="line">        change.previous = sct.serviceToServiceMap(previous)</span><br><span class="line">        sct.items[namespacedName] = change</span><br><span class="line">    &#125;</span><br><span class="line">    change.current = sct.serviceToServiceMap(current)</span><br><span class="line">    <span class="comment">// if change.previous equal to change.current, it means no change</span></span><br><span class="line">    <span class="keyword">if</span> reflect.DeepEqual(change.previous, change.current) &#123; <span class="comment">// 从update传递进来的资源没有变化，则从serviceChanges中删除。</span></span><br><span class="line">        <span class="built_in">delete</span>(sct.items, namespacedName) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(sct.items) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Update 方法就是根据`&lt;previous ,current&gt; 参数对新生成一个change 或者修改一个存在的change。并且把无变化的资源从serviceChanges 中删除。serviceChanges.items 会在将变化信息更新到proxier.serviceMap 后清空。</p>
<h2 id="iptables相关"><a class="markdownIt-Anchor" href="#iptables相关"></a> IPTables相关</h2>
<h3 id="iptables-创建kube自定义链和规则"><a class="markdownIt-Anchor" href="#iptables-创建kube自定义链和规则"></a> Iptables 创建KUBE自定义链和规则</h3>
<p>介绍了kube-proxy关于资源监听和记录的实现后，再来看一下kube-proxy是如何将资源的变化反馈到iptables规则中的。在具体proxier的创建过程中，以iptables为例，是创建了iptable监视器的，其会通过不断调用proxier.syncProxyRules来同步更新iptables规则。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxier</span><span class="params">(ipt utiliptables.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">                //	... </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">    </span><br><span class="line">	 <span class="comment">// 开启iptables监视的协程, 主要的通过 proxier.syncProxyRules 的方法来维护iptables规则变化</span></span><br><span class="line">	<span class="keyword">go</span> ipt.Monitor(kubeProxyCanaryChain, []utiliptables.Table&#123;utiliptables.TableMangle, utiliptables.TableNAT, utiliptables.TableFilter&#125;,</span><br><span class="line">		proxier.syncProxyRules, syncPeriod, wait.NeverStop)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续研读syncProxyRule()方法看看其实修改iptables规则的细节流程，我们将能明白在node节点观察到的新链及规则产生的方式及目的，见<code>kubernetes/pkg/proxy/iptables/proxier.go</code>，更新proxier.endpointsMap，proxier.servieMap以及产生和维护Kube自定义链。</p>
<ul>
<li>proxier.serviceMap：把sercvieChanges.current 写入proxier.serviceMap，再把存在于sercvieChanges.previous 但不存在于sercvieChanges.current 的service 从 proxier.serviceMap中删除，并且删除的时候，把使用UDP协议的cluster_ip 记录于UDPStaleClusterIP 。</li>
<li>proxier.endpointsMap：把endpointsChanges.previous 从proxier.endpointsMap 删除，再把endpointsChanges.current 加入proxier.endpointsMap。把存在于endpointsChanges.previous 但不存在于endpointsChanges.current 的endpoint 组装为ServiceEndpoint 结构，把该结构记录于staleEndpoints。</li>
</ul>
<p>具体相关代码流程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syncProxyRules是所有iptables-save/restore调用发生的地方。</span></span><br><span class="line"><span class="comment">// 唯一的其他iptables规则是那些在iptablesInit()中设置的规则。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">syncProxyRules</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    </span><br><span class="line">    serviceUpdateResult := proxy.UpdateServiceMap(proxier.serviceMap, proxier.serviceChanges)</span><br><span class="line">    endpointUpdateResult := proxy.UpdateEndpointsMap(proxier.endpointsMap, proxier.endpointsChanges)</span><br><span class="line">    </span><br><span class="line">    staleServices := serviceUpdateResult.UDPStaleClusterIP</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用endpointUpdateResult.StaleServiceNames，再次更新 staleServices</span></span><br><span class="line">    <span class="keyword">for</span> _, svcPortName := <span class="keyword">range</span> endpointUpdateResult.StaleServiceNames &#123;</span><br><span class="line">        <span class="keyword">if</span> svcInfo, ok := proxier.serviceMap[svcPortName]; ok &amp;&amp; svcInfo != <span class="literal">nil</span> &amp;&amp; svcInfo.GetProtocol() == v1.ProtocolUDP &#123;</span><br><span class="line">            klog.V(<span class="number">2</span>).Infof(<span class="string">"Stale udp service %v -&gt; %s"</span>, svcPortName, svcInfo.ClusterIPString())</span><br><span class="line">            staleServices.Insert(svcInfo.ClusterIPString())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;   </span><br><span class="line"> </span><br><span class="line"><span class="comment">//kubernetes/pkg/proxy/servcie.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateServiceMap</span><span class="params">(serviceMap ServiceMap, changes *ServiceChangeTracker)</span> <span class="params">(result UpdateServiceMapResult)</span></span> &#123;</span><br><span class="line">    result.UDPStaleClusterIP = sets.NewString()</span><br><span class="line">    <span class="comment">// apply 方法中，继续调用了merge，filter, umerge</span></span><br><span class="line">    <span class="comment">// merge:将change.current的servicemap 信息合入proxier.servicemap中。</span></span><br><span class="line">    <span class="comment">// filter:将change.previous和change.current共同存在的servicemap从将change.previous删除</span></span><br><span class="line">    <span class="comment">// unmerge: 将change.previous 中使用UDP 的servicemap 从 proxier.serviceMap 中删除，并记录删除的服务IP 到UDPStaleClusterIP</span></span><br><span class="line">    <span class="comment">//apply中最后重置了proxy.serviceChanges.items</span></span><br><span class="line">    serviceMap.apply(changes, result.UDPStaleClusterIP)</span><br><span class="line">    <span class="comment">//HCServiceNodePorts 保存proxier.serviceMap 中所有服务的健康检查端口</span></span><br><span class="line">    result.HCServiceNodePorts = <span class="built_in">make</span>(<span class="keyword">map</span>[types.NamespacedName]<span class="keyword">uint16</span>)</span><br><span class="line">    <span class="keyword">for</span> svcPortName, info := <span class="keyword">range</span> serviceMap &#123;</span><br><span class="line">        <span class="keyword">if</span> info.GetHealthCheckNodePort() != <span class="number">0</span> &#123;</span><br><span class="line">            result.HCServiceNodePorts[svcPortName.NamespacedName] = <span class="keyword">uint16</span>(info.GetHealthCheckNodePort())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//kubernetes/pkg/proxy/endpoints.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateEndpointsMap</span><span class="params">(endpointsMap EndpointsMap, changes *EndpointChangeTracker)</span> <span class="params">(result UpdateEndpointMapResult)</span></span> &#123;</span><br><span class="line">    result.StaleEndpoints = <span class="built_in">make</span>([]ServiceEndpoint, <span class="number">0</span>)</span><br><span class="line">    result.StaleServiceNames = <span class="built_in">make</span>([]ServicePortName, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从proixer.endpointsMap 中删除和change.previous 相同的elelment.</span></span><br><span class="line">    <span class="comment">// 将change.current 添加至proixer.endpointsMap</span></span><br><span class="line">    <span class="comment">// StaleEndpoints 保存了存在于previous 但不存在current的endpoints</span></span><br><span class="line">    <span class="comment">// StaleServicenames保存了一种ServicePortName,这样的ServicePortName在change.previous不存在对应的endpoints，在change.current存在endpoints。</span></span><br><span class="line">    <span class="comment">// 最后重置了了proxy.endpointsChanges.items</span></span><br><span class="line">    endpointsMap.apply(changes, &amp;result.StaleEndpoints, &amp;result.StaleServiceNames)</span><br><span class="line">    <span class="comment">// computing this incrementally similarly to endpointsMap.</span></span><br><span class="line">    result.HCEndpointsLocalIPSize = <span class="built_in">make</span>(<span class="keyword">map</span>[types.NamespacedName]<span class="keyword">int</span>)</span><br><span class="line">    localIPs := GetLocalEndpointIPs(endpointsMap)</span><br><span class="line">    <span class="keyword">for</span> nsn, ips := <span class="keyword">range</span> localIPs &#123;</span><br><span class="line">        result.HCEndpointsLocalIPSize[nsn] = <span class="built_in">len</span>(ips)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备好更新iptables需要的资源变量后，接下来就是调用iptables 命令建立自定义链了，并在对应的内核链上引用这些自定义链。这些自定义链在k8s 服务中是必须的，不会跟随资源变化而变化，所以在更新规则之前，提前无条件生成这些链，做好准备工作，随后会在这些自定义链上创建相应的规则。</p>
<p>继续看<code>kubernetes/pkg/proxy/iptables/proxier.go</code>，就是kube自定义链的创建过程了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并连接kube链</span></span><br><span class="line"><span class="keyword">for</span> _, jump := <span class="keyword">range</span> iptablesJumpChains &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := proxier.iptables.EnsureChain(jump.table, jump.dstChain); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.ErrorS(err, <span class="string">"Failed to ensure chain exists"</span>, <span class="string">"table"</span>, jump.table, <span class="string">"chain"</span>, jump.dstChain)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    args := <span class="built_in">append</span>(jump.extraArgs,</span><br><span class="line">                   <span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, jump.comment,</span><br><span class="line">                   <span class="string">"-j"</span>, <span class="keyword">string</span>(jump.dstChain),</span><br><span class="line">                  )</span><br><span class="line">    <span class="keyword">if</span> _, err := proxier.iptables.EnsureRule(utiliptables.Prepend, jump.table, jump.srcChain, args...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.ErrorS(err, <span class="string">"Failed to ensure chain jumps"</span>, <span class="string">"table"</span>, jump.table, <span class="string">"srcChain"</span>, jump.srcChain, <span class="string">"dstChain"</span>, jump.dstChain)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ensure KUBE-MARK-DROP chain exist but do not change any rules</span></span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> iptablesEnsureChains &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := proxier.iptables.EnsureChain(ch.table, ch.chain); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.ErrorS(err, <span class="string">"Failed to ensure chain exists"</span>, <span class="string">"table"</span>, ch.table, <span class="string">"chain"</span>, ch.chain)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EnsureChain is part of Interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(runner *runner)</span> <span class="title">EnsureChain</span><span class="params">(table Table, chain Chain)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	fullArgs := makeFullArgs(table, chain)</span><br><span class="line">	runner.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> runner.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	out, err := runner.run(opCreateChain, fullArgs)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ee, ok := err.(utilexec.ExitError); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> ee.Exited() &amp;&amp; ee.ExitStatus() == <span class="number">1</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"error creating chain %q: %v: %s"</span>, chain, err, out)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于涉及到iptables内容了，以目前的能力再阅读代码已经深入不进了，因此只好借助网上的代码来分析实现了。据网上资料，上边代码完成的iptables命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在filter表中创建KUBE-EXTERNAL-SERVICES链</span></span><br><span class="line">iptables -w -N KUBE-EXTERNAL-SERVICES  -t filter</span><br><span class="line"><span class="comment"># 在filter表的INPUT链头增加跳转到 自定义KUBE-EXTERNAL-SERVICES 链的规则</span></span><br><span class="line">iptables -w -I  INPUT -t filter -m conntrack --ctstate NEW  -m  comment --comment -j KUBE-EXTERNAL-SERVICES  kubernetes externally-visible service portals</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 在filter表中创建KUBE-SERVICES链</span></span><br><span class="line">iptables -w -N KUBE-SERVICES  -t filter  </span><br><span class="line"><span class="comment"># 在filter表的OUTPUT链头增加跳转到 自定义 KUBE-SERVICES 链的规则</span></span><br><span class="line">iptables -w -I OUTPUT -t filter  -m conntrack --ctstate NEW  -m  comment --comment -j  KUBE-SERVICES  kubernetes service portals</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 nat 表中创建KUBE-SERVICES链</span></span><br><span class="line">iptables -w -N KUBE-SERVICES  -t nat</span><br><span class="line"><span class="comment"># 在 nat 表的OUTPUT链头增加跳转到 自定义 KUBE-SERVICES 链的规则</span></span><br><span class="line">iptables -w -I OUTPUT -t nat  -m conntrack --ctstate NEW  -m  comment --comment -j  KUBE-SERVICES  kubernetes service portals</span><br><span class="line"> </span><br><span class="line">iptables -w -N KUBE-SERVICES  -t nat</span><br><span class="line"><span class="comment"># 在 nat 表的 PREROUTING 链头增加跳转到 自定义 KUBE-SERVICES 链的规则</span></span><br><span class="line">iptables -w -I PREROUTING -t nat  -m conntrack --ctstate NEW  -m  comment --comment -j  KUBE-SERVICES  kubernetes service portals</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 在 nat 表中创建KUBE-POSTROUTING 链</span></span><br><span class="line">iptables -w -N KUBE-POSTROUTING  -t nat</span><br><span class="line"><span class="comment"># 在 nat 表的 PREROUTING 链头增加跳转到 自定义 KUBE-POSTROUTING 链的规则</span></span><br><span class="line">iptables -w -I POSTROUTING -t nat  -m conntrack --ctstate NEW  -m  comment --comment -j  KUBE-POSTROUTING  kubernetes postrouting rules</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在 filter 表中创建 KUBE-FORWARD 链</span></span><br><span class="line">iptables -w -N KUBE-FORWARD  -t filter</span><br><span class="line"><span class="comment"># 在 filter 表的 FORWARD 链头增加跳转到 自定义 KUBE-FORWARD 链的规则</span></span><br><span class="line">iptables -w -I FORWARD -t filter  -m conntrack --ctstate NEW  -m  comment --comment -j KUBE-FORWARD  kubernetes forwarding rules</span><br></pre></td></tr></table></figure>
<p>可见的是，在IPTables做了以下修改：</p>
<ul>
<li>filter表：
<ul>
<li>创建 KUBE-EXTERNAL-SERVICES 链</li>
<li>创建 KUBE-SERVICES 链</li>
<li>创建 KUBE-FORWARD 链</li>
</ul>
</li>
<li>nat 表：创建KUBE-SERVICES链
<ul>
<li>创建 KUBE-SERVICES 链</li>
<li>创建 KUBE-POSTROUTING 链</li>
</ul>
</li>
</ul>
<p>并且在nat和filter表上原有的固定链前都增加了跳转到Kube自定义链的转发规则，从而使得所有进入固定链的流包在nat或filter 时，都会导入自定义链中。</p>
<p>可见通过上述的创建，在内核固定链中引用 K8S 的链时，这些新链都是作为内核固定链在nat表或filter表中的第一条规则。这样，所有进入固定链的流包在nat或filter 时，都会导入自定义链中。特别地，PREROUTING 和OUTPUT 的首条NAT规则都先将所有流量导入KUBE-SERVICE 链中，这样就截获了所有的入流量和出流量，进而可以对k8s 相关流量进行重定向处理。</p>
<p>继续沿着syncProxyRules函数看下去：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, chainName := <span class="keyword">range</span> []utiliptables.Chain&#123;kubeServicesChain, kubeExternalServicesChain, kubeForwardChain, kubeNodePortsChain&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> chain, ok := existingFilterChains[chainName]; ok &#123;</span><br><span class="line">        proxier.filterChains.WriteBytes(chain)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        proxier.filterChains.Write(utiliptables.MakeChainLine(chainName))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这边新出来了三条chain：kubeNodePortsChain、KubeMarkMasqChain</span></span><br><span class="line"><span class="keyword">for</span> _, chainName := <span class="keyword">range</span> []utiliptables.Chain&#123;kubeServicesChain, kubeNodePortsChain, kubePostroutingChain, KubeMarkMasqChain&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> chain, ok := existingNATChains[chainName]; ok &#123;</span><br><span class="line">        proxier.natChains.WriteBytes(chain)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//KUBE-NODEPORTS，KUBE-MARK-MASQ 之前并未被创建，现在创建</span></span><br><span class="line">        proxier.natChains.Write(utiliptables.MakeChainLine(chainName))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，iptables/proxier.go中定义的8个chain我们已经见到了6个了，剩下的两个分别是KUBE-MARK-DROP、KUBE-PROXY-CANARY，这两个对我们走读执行逻辑就没有太多关联了，因此就不继续分析这两个链了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// the services chain</span></span><br><span class="line">	kubeServicesChain utiliptables.Chain = <span class="string">"KUBE-SERVICES"</span></span><br><span class="line">	<span class="comment">// the external services chain</span></span><br><span class="line">	kubeExternalServicesChain utiliptables.Chain = <span class="string">"KUBE-EXTERNAL-SERVICES"</span></span><br><span class="line">	<span class="comment">// the nodeports chain</span></span><br><span class="line">	kubeNodePortsChain utiliptables.Chain = <span class="string">"KUBE-NODEPORTS"</span></span><br><span class="line">	<span class="comment">// the kubernetes postrouting chain</span></span><br><span class="line">	kubePostroutingChain utiliptables.Chain = <span class="string">"KUBE-POSTROUTING"</span></span><br><span class="line">	<span class="comment">// KubeMarkMasqChain is the mark-for-masquerade chain</span></span><br><span class="line">	KubeMarkMasqChain utiliptables.Chain = <span class="string">"KUBE-MARK-MASQ"</span></span><br><span class="line">	<span class="comment">// KubeMarkDropChain is the mark-for-drop chain</span></span><br><span class="line">	KubeMarkDropChain utiliptables.Chain = <span class="string">"KUBE-MARK-DROP"</span></span><br><span class="line">	<span class="comment">// the kubernetes forward chain</span></span><br><span class="line">	kubeForwardChain utiliptables.Chain = <span class="string">"KUBE-FORWARD"</span></span><br><span class="line">	<span class="comment">// kube proxy canary chain is used for monitoring rule reload</span></span><br><span class="line">	kubeProxyCanaryChain utiliptables.Chain = <span class="string">"KUBE-PROXY-CANARY"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>KUBE-MARK-DROP和KUBE-MARK-MASQ本质上就是使用了iptables的MARK命令:</p>
<ul>
<li>对于KUBE-MARK-MASQ链中所有规则设置了kubernetes独有MARK标记，在KUBE-POSTROUTING链中对NODE节点上匹配kubernetes独有MARK标记的数据包，当报文离开node节点时进行SNAT，MASQUERADE源IP</li>
<li>而对于KUBE-MARK-DROP设置标记的报文则会在KUBE_FIREWALL中全部丢弃</li>
</ul>
<h3 id="service类型分析"><a class="markdownIt-Anchor" href="#service类型分析"></a> Service类型分析</h3>
<p>继续往下看，终于到了重点的地方：proxy如果通过service找到对应的EndPoints</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">syncProxyRules</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Build rules for each service.</span></span><br><span class="line">    <span class="keyword">for</span> svcName, svc := <span class="keyword">range</span> proxier.serviceMap &#123;</span><br><span class="line">        svcInfo, ok := svc.(*serviceInfo)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        allEndpoints := proxier.endpointsMap[svcName]</span><br><span class="line">		<span class="comment">// 对拓扑感知端点进行过滤。该函数仅在适当的功能gates被启用，并且该服务没有冲突的配置（如externalTrafficPolicy=Local）时才会过滤端点。</span></span><br><span class="line">		allEndpoints = proxy.FilterEndpoints(allEndpoints, svcInfo, proxier.nodeLabels)</span><br><span class="line">		<span class="comment">// svcChain通过utiliptables.Chain("KUBE-SVC-" + portProtoHash(servicePortName, protocol))创建的chain</span></span><br><span class="line">		svcChain := svcInfo.servicePortChainName</span><br><span class="line">		<span class="comment">// 	...</span></span><br></pre></td></tr></table></figure>
<p><strong>clusterIP</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">/*** 				Capture the clusterIP.			***/</span></span><br><span class="line"><span class="keyword">if</span> hasEndpoints &#123;</span><br><span class="line">          <span class="comment">// 填充转发选项-d和--dport</span></span><br><span class="line">	args = <span class="built_in">append</span>(args[:<span class="number">0</span>],</span><br><span class="line">		<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"%s cluster IP"`</span>, svcNameString),</span><br><span class="line">		<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">		<span class="string">"-d"</span>, utilproxy.ToCIDR(svcInfo.ClusterIP()),</span><br><span class="line">		<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.Port()),</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> proxier.masqueradeAll &#123;</span><br><span class="line">              <span class="comment">// 生成结果-A KUBE-SERVICES ...--comment $&#123;svc-port-name&#125; cluster IP ...  -d $&#123;cluster_ip&#125;/32 -dport xxx  -j KUBE-MARK-MASQ </span></span><br><span class="line">		args := prepend(args, <span class="string">"-A"</span>, <span class="keyword">string</span>(svcChain))</span><br><span class="line">		args = <span class="built_in">append</span>(args, <span class="string">"-j"</span>, <span class="keyword">string</span>(KubeMarkMasqChain))</span><br><span class="line">		proxier.natRules.Write(args...)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> proxier.localDetector.IsImplemented() &#123;</span><br><span class="line">		<span class="comment">// 生成结果 -A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; cluster IP ... -d $&#123;cluster_ip&#125;/32 -dport XXX  ! -s $&#123;cluster_cidr&#125;  -j KUBE-MARK-MASQ</span></span><br><span class="line">		args := prepend(args, <span class="string">"-A"</span>, <span class="keyword">string</span>(svcChain))</span><br><span class="line">		args = proxier.localDetector.JumpIfNotLocal(args, <span class="keyword">string</span>(KubeMarkMasqChain))</span><br><span class="line">		proxier.natRules.Write(args...)</span><br><span class="line">	&#125;</span><br><span class="line">	args = prepend(args, <span class="string">"-A"</span>, <span class="keyword">string</span>(kubeServicesChain))</span><br><span class="line">          <span class="comment">// 总是将将目的地址是&#123;cluster_ip:port&#125; 的流量导入到KUBE-SVC-XXX， 即-A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; cluster IP ... -d $&#123;cluster_ip&#125;/32 -dport xxx  -j  KUBE-SVC-XXX</span></span><br><span class="line">	args = <span class="built_in">append</span>(args, <span class="string">"-j"</span>, <span class="keyword">string</span>(svcChain))</span><br><span class="line">	proxier.natRules.Write(args...)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// No endpoints.</span></span><br><span class="line">          <span class="comment">// 如果服务没有endpoints, 在KUBE-SERVICES链上建立filter 规则（（将规则写入proxier.filterRules ，下同），表示放弃访问目的地址&#123;cluster_ip:port&#125;的包。 省略</span></span><br><span class="line">          <span class="comment">// 生成结果：-A KUBE-SERVICES ...--comment &#123;svc-port-name&#125; has no endpoints ... -d $&#123;cluster_ip&#125;/32  -dport xxx  -j REJECT </span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">/*** 				Capture the clusterIP.			***/</span></span><br></pre></td></tr></table></figure>
<p>externalIPs</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*** 				Capture externalIPs.		***/</span></span><br><span class="line"><span class="keyword">for</span> _, externalIP := <span class="keyword">range</span> svcInfo.ExternalIPStrings() &#123;</span><br><span class="line">	<span class="comment">// 如果 "外部 "IP恰好是本机的IP，则保持本机端口开放，这样就没有其他进程可以打开它（因为套接字可能会打开，但它永远不会工作）。</span></span><br><span class="line">	<span class="keyword">if</span> (svcInfo.Protocol() != v1.ProtocolSCTP) &amp;&amp; localAddrSet.Has(netutils.ParseIPSloppy(externalIP)) &#123;</span><br><span class="line">		lp := netutils.LocalPort&#123;</span><br><span class="line">			Description: <span class="string">"externalIP for "</span> + svcNameString,</span><br><span class="line">			IP:          externalIP,</span><br><span class="line">			IPFamily:    localPortIPFamily,</span><br><span class="line">			Port:        svcInfo.Port(),</span><br><span class="line">			Protocol:    netutils.Protocol(svcInfo.Protocol()),</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> proxier.portsMap[lp] != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">"Port was open before and is still needed"</span>, <span class="string">"port"</span>, lp)</span><br><span class="line">			replacementPortsMap[lp] = proxier.portsMap[lp]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			socket, err := proxier.portMapper.OpenLocalPort(&amp;lp)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				msg := fmt.Sprintf(<span class="string">"can't open port %s, skipping it"</span>, lp.String())</span><br><span class="line"></span><br><span class="line">				proxier.recorder.Eventf(</span><br><span class="line">					&amp;v1.ObjectReference&#123;</span><br><span class="line">						Kind:      <span class="string">"Node"</span>,</span><br><span class="line">						Name:      proxier.hostname,</span><br><span class="line">						UID:       types.UID(proxier.hostname),</span><br><span class="line">						Namespace: <span class="string">""</span>,</span><br><span class="line">					&#125;, <span class="literal">nil</span>, v1.EventTypeWarning, err.Error(), <span class="string">"SyncProxyRules"</span>, msg)</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Can't open port, skipping it"</span>, <span class="string">"port"</span>, lp)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">"Opened local port"</span>, <span class="string">"port"</span>, lp)</span><br><span class="line">			replacementPortsMap[lp] = socket</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> hasEndpoints &#123;</span><br><span class="line">		args = <span class="built_in">append</span>(args[:<span class="number">0</span>],</span><br><span class="line">			<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"%s external IP"`</span>, svcNameString),</span><br><span class="line">			<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">			<span class="string">"-d"</span>, utilproxy.ToCIDR(netutils.ParseIPSloppy(externalIP)),</span><br><span class="line">			<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.Port()),</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		destChain := svcXlbChain</span><br><span class="line">		<span class="keyword">if</span> !svcInfo.NodeLocalExternal() &#123;</span><br><span class="line">			destChain = svcChain</span><br><span class="line">			args := prepend(args, <span class="string">"-A"</span>, <span class="keyword">string</span>(svcChain))</span><br><span class="line">			<span class="comment">// This masquerades off-cluster traffic to a External IP.</span></span><br><span class="line">                  <span class="comment">//   -A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; external IP ... -d $&#123;external_ip&#125;/32 -dport xxx -m physdev ! --physdev-is-in -m addrtype ! --src-type LOCAL -j KUBE-SVC-xxx</span></span><br><span class="line">			<span class="keyword">if</span> proxier.localDetector.IsImplemented() &#123;</span><br><span class="line">				proxier.natRules.Write(</span><br><span class="line">					proxier.localDetector.JumpIfNotLocal(args, <span class="keyword">string</span>(KubeMarkMasqChain))...)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				proxier.natRules.Write(</span><br><span class="line">					<span class="built_in">append</span>(args, <span class="string">"-j"</span>, <span class="keyword">string</span>(KubeMarkMasqChain))...)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send traffic bound for external IPs to the service chain.</span></span><br><span class="line">               <span class="comment">//   -A KUBE-SERVICES ... --comment $&#123;svc-port-name&#125; external IP ... -d $&#123;external_ip&#125;/32 -dport xxx -m addrtype --dst-type LOCAL -j KUBE-SVC-xxx</span></span><br><span class="line">		args = prepend(args, <span class="string">"-A"</span>, <span class="keyword">string</span>(kubeServicesChain))</span><br><span class="line">		proxier.natRules.Write(</span><br><span class="line">			<span class="built_in">append</span>(args, <span class="string">"-j"</span>, <span class="keyword">string</span>(destChain))...)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// No endpoints.</span></span><br><span class="line">              <span class="comment">// -A KUBE-EXTERNAL-SERVICES ...--comment $&#123;svc-port-name&#125; has no endpoints ... -d $&#123;external_ip&#125;/32  -dport xxx  -j REJECT </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/*** 				Capture externalIPs.		***/</span></span><br></pre></td></tr></table></figure>
<p><strong>load-balancer</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... Capture load-balancer ingress. 省略</span></span><br></pre></td></tr></table></figure>
<p><strong>NodePort.</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">/*** 				Capture NodePort.		***/</span></span><br><span class="line">      <span class="comment">// 如果我们有2条以上的规则，也许值得为节点端口规则做一个新的每个服务链，但只有2条规则，最终是一种浪费和认知上的负担。</span></span><br><span class="line"><span class="keyword">if</span> svcInfo.NodePort() != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">//  保持本地端口的开放，因此没有其他进程可以打开它（因为套接字可能会打开，但它永远不会工作）。</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nodeAddresses) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lps := <span class="built_in">make</span>([]netutils.LocalPort, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> address := <span class="keyword">range</span> nodeAddresses &#123;</span><br><span class="line">		lp := netutils.LocalPort&#123;</span><br><span class="line">			Description: <span class="string">"nodePort for "</span> + svcNameString,</span><br><span class="line">			IP:          address,</span><br><span class="line">			IPFamily:    localPortIPFamily,</span><br><span class="line">			Port:        svcInfo.NodePort(),</span><br><span class="line">			Protocol:    netutils.Protocol(svcInfo.Protocol()),</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> utilproxy.IsZeroCIDR(address) &#123;</span><br><span class="line">			<span class="comment">// Empty IP address means all</span></span><br><span class="line">			lp.IP = <span class="string">""</span></span><br><span class="line">			lps = <span class="built_in">append</span>(lps, lp)</span><br><span class="line">			<span class="comment">// If we encounter a zero CIDR, then there is no point in processing the rest of the addresses.</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		lps = <span class="built_in">append</span>(lps, lp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For ports on node IPs, open the actual port and hold it.</span></span><br><span class="line">	<span class="keyword">for</span> _, lp := <span class="keyword">range</span> lps &#123;</span><br><span class="line">		<span class="keyword">if</span> proxier.portsMap[lp] != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">"Port was open before and is still needed"</span>, <span class="string">"port"</span>, lp)</span><br><span class="line">			replacementPortsMap[lp] = proxier.portsMap[lp]</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> svcInfo.Protocol() != v1.ProtocolSCTP &#123;</span><br><span class="line">			socket, err := proxier.portMapper.OpenLocalPort(&amp;lp)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				msg := fmt.Sprintf(<span class="string">"can't open port %s, skipping it"</span>, lp.String())</span><br><span class="line"></span><br><span class="line">				proxier.recorder.Eventf(</span><br><span class="line">					&amp;v1.ObjectReference&#123;</span><br><span class="line">						Kind:      <span class="string">"Node"</span>,</span><br><span class="line">						Name:      proxier.hostname,</span><br><span class="line">						UID:       types.UID(proxier.hostname),</span><br><span class="line">						Namespace: <span class="string">""</span>,</span><br><span class="line">					&#125;, <span class="literal">nil</span>, v1.EventTypeWarning, err.Error(), <span class="string">"SyncProxyRules"</span>, msg)</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Can't open port, skipping it"</span>, <span class="string">"port"</span>, lp)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">"Opened local port"</span>, <span class="string">"port"</span>, lp)</span><br><span class="line">			replacementPortsMap[lp] = socket</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="comment">/*** 				Capture externalIPs.		***/</span></span><br><span class="line"></span><br><span class="line">          	</span><br><span class="line">	<span class="keyword">if</span> hasEndpoints &#123;</span><br><span class="line">		args = <span class="built_in">append</span>(args[:<span class="number">0</span>],</span><br><span class="line">			<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, svcNameString,</span><br><span class="line">			<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">			<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.NodePort()),</span><br><span class="line">		)</span><br><span class="line">                <span class="comment">//if hasEndpoints &amp;&amp; if !svcInfo.NodeLocalExternal, 在NAT表写入：-A KUBE-NODEPORTS ... --comment $&#123;svc-port-name&#125; --dport &#123;nodeport&#125; -j KUBE-MARK-MASQ、  -A KUBE-NODEPORTS ... --comment $&#123;svc-port-name&#125; --dport $&#123;nodeport&#125; -j KUBE-SVC-xxx</span></span><br><span class="line">		<span class="keyword">if</span> !svcInfo.NodeLocalExternal() &#123;</span><br><span class="line">			<span class="comment">// Nodeports need SNAT, unless they're local.</span></span><br><span class="line">			proxier.natRules.Write(</span><br><span class="line">				<span class="built_in">append</span>(prepend(args, <span class="string">"-A"</span>, <span class="keyword">string</span>(svcChain)), <span class="string">"-j"</span>, <span class="keyword">string</span>(KubeMarkMasqChain))...)</span><br><span class="line">			<span class="comment">// Jump to the service chain.</span></span><br><span class="line">			proxier.natRules.Write(</span><br><span class="line">				<span class="built_in">append</span>(prepend(args, <span class="string">"-A"</span>, <span class="keyword">string</span>(kubeNodePortsChain)), <span class="string">"-j"</span>, <span class="keyword">string</span>(svcChain))...)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 否则-A KUBE-NODEPORTS ... --comment $&#123;svc-port-name&#125; --dport $&#123;nodeport&#125; -s 127.0.0.0/8 -j KUBE-SVC-xxx、  -A KUBE-NODEPORTS ... --comment $&#123;svc-port-name&#125; --dport $&#123;nodeport&#125; -j KUBE-XLB-xxx</span></span><br><span class="line">			<span class="comment">// Fix localhost martian source error</span></span><br><span class="line">			loopback := <span class="string">"127.0.0.0/8"</span></span><br><span class="line">			<span class="keyword">if</span> isIPv6 &#123;</span><br><span class="line">				loopback = <span class="string">"::1/128"</span></span><br><span class="line">			&#125;</span><br><span class="line">			args = prepend(args, <span class="string">"-A"</span>, <span class="keyword">string</span>(kubeNodePortsChain))</span><br><span class="line">			proxier.natRules.Write(</span><br><span class="line">				<span class="built_in">append</span>(args, <span class="string">"-s"</span>, loopback, <span class="string">"-j"</span>, <span class="keyword">string</span>(KubeMarkMasqChain))...)</span><br><span class="line">			proxier.natRules.Write(</span><br><span class="line">				<span class="built_in">append</span>(args, <span class="string">"-j"</span>, <span class="keyword">string</span>(svcXlbChain))...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// No endpoints.</span></span><br><span class="line">          	<span class="comment">// 增加REJECT规则拒绝该流量, 省略</span></span><br><span class="line">              <span class="comment">//   -A KUBE-EXTERNAL-SERVICES ... -m addrtype --dst-type LOCAL ... --dport $&#123;nodeport&#125; -j REJECT</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/*** 				Capture NodePort.		***/</span></span><br></pre></td></tr></table></figure>
<p>上述代码主要针对四种情况做了规则处理：</p>
<ol>
<li>为cluster_ip 设置访问规则</li>
</ol>
<ul>
<li>为有endpints 的服务在KUBE-SERVICES 链上建立nat表规则（将规则写入proxier.natRules ，下同）：
<ul>
<li>如果设置了proxier.masqueradeAll , kube-proxy 会对所有目的地址是{cluster_ip:port}的包打标签，进 而做SNAT；或者如果指定了–cluster–cidr , kube-proxy 会对目的地址是{cluster_ip:port} 的集群外部（! -s ${cluster_cidr}）流量包打标签，进而做SNAT；（以上规则二选一）</li>
<li>总是将将目的地址是{cluster_ip:port} 的流量导入到KUBE-SVC-XXX</li>
</ul>
</li>
<li>如果服务没有endpoints, 在KUBE-SERVICES链上建立filter 规则，表示放弃访问目的地址{cluster_ip:port}的包。</li>
</ul>
<p>得到的iptable命令如下：</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SERVICES ...--comment <span class="variable">$&#123;svc-port-name&#125;</span> cluster IP ...  -d <span class="variable">$&#123;cluster_ip&#125;</span>/32 -dport xxx  -j KUBE-MARK-MASQ  <span class="comment"># if proxier.masqueradeAll =True</span></span><br><span class="line">-A KUBE-SERVICES ... --comment <span class="variable">$&#123;svc-port-name&#125;</span> cluster IP ... -d <span class="variable">$&#123;cluster_ip&#125;</span>/32 -dport XXX  ! -s <span class="variable">$&#123;cluster_cidr&#125;</span>  -j KUBE-MARK-MASQ  <span class="comment"># else if len(proxier.clusterCIDR) &gt; 0</span></span><br><span class="line">-A KUBE-SERVICES ... --comment <span class="variable">$&#123;svc-port-name&#125;</span> cluster IP ... -d <span class="variable">$&#123;cluster_ip&#125;</span>/32 -dport xxx  -j  KUBE-SVC-XXX  <span class="comment"># 有endpoints 时总是添加此规则</span></span><br><span class="line"></span><br><span class="line">-A KUBE-SERVICES ...--comment &#123;svc-port-name&#125; has no endpoints ... -d <span class="variable">$&#123;cluster_ip&#125;</span>/32  -dport xxx  -j REJECT  // 没有endpoint时，直接将发往此IP：Port的包丢弃</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>为externalIP 类型服务建立规则</p>
<p>如果external IP 是本机IP，并且服务使用的协议不是SCTP, 生成结构体LocalPort 以记录这样的服务的external IP , port ,协议，以及描述信息。 确认在本机上打开服务端口(可以把这个socket理解为“占位符”，以便让操作系统为本机其他应用程序分配端口时让开该端口），并且添加{LocalPort ：socket} 到replacementPortsMap。</p>
<ul>
<li>如果该服务有endpoints ，在KUBE-SERVICES 链添加 nat 表规则
<ul>
<li>对于到external_ip:port 的包打标签；</li>
<li>对于从集群外发送的目的地址是extenralIP 的包建立规则</li>
<li>对于目的地址和node 地址相同的包建立规则</li>
</ul>
</li>
<li>如果该服务没有endpoints ，在KUBE-EXTERNAL-SERVICES 添加 filter 规则，表示放弃目的地址是<code>{ {external_ip:xxx}</code>的包</li>
</ul>
<p>得到的iptable命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SERVICES ... --comment <span class="variable">$&#123;svc-port-name&#125;</span> external IP ... -d <span class="variable">$&#123;external_ip&#125;</span>/32 -dport xxx -j KUBE-MARK-MASQ</span><br><span class="line"></span><br><span class="line">-A KUBE-SERVICES ... --comment <span class="variable">$&#123;svc-port-name&#125;</span> external IP ... -d <span class="variable">$&#123;external_ip&#125;</span>/32 -dport xxx -m physdev ! --physdev-is-in -m addrtype ! --src-type LOCAL -j KUBE-SVC-xxx</span><br><span class="line"></span><br><span class="line">-A KUBE-SERVICES ... --comment <span class="variable">$&#123;svc-port-name&#125;</span> external IP ... -d <span class="variable">$&#123;external_ip&#125;</span>/32 -dport xxx -m addrtype --dst-type LOCAL -j KUBE-SVC-xxx</span><br><span class="line"></span><br><span class="line">-A KUBE-EXTERNAL-SERVICES ...--comment <span class="variable">$&#123;svc-port-name&#125;</span> has no endpoints ... -d <span class="variable">$&#123;external_ip&#125;</span>/32  -dport xxx  -j REJECT</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>服务类型为LoadBalancer时，设置外部负载均衡相关规则</p>
</li>
<li>
<p>为NodePort 类型服务规则建立：</p>
<p>得到的iptable命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">replacementPortsMap[lp] = proxier.portsMap[lp] ,并且打开端口</span><br><span class="line"></span><br><span class="line">//<span class="keyword">if</span> hasEndpoints &amp;&amp; <span class="keyword">if</span> !svcInfo.OnlyNodeLocalEndpoints, 在NAT表写入：</span><br><span class="line">-A KUBE-NODEPORTS ... --comment <span class="variable">$&#123;svc-port-name&#125;</span> --dport &#123;nodeport&#125; -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-NODEPORTS ... --comment <span class="variable">$&#123;svc-port-name&#125;</span> --dport <span class="variable">$&#123;nodeport&#125;</span> -j KUBE-SVC-xxx</span><br><span class="line"></span><br><span class="line">//<span class="keyword">if</span> hasEndpoints &amp;&amp; <span class="keyword">if</span> svcInfo.OnlyNodeLocalEndpoints，在NAT表写入：</span><br><span class="line">-A KUBE-NODEPORTS ... --comment <span class="variable">$&#123;svc-port-name&#125;</span> --dport <span class="variable">$&#123;nodeport&#125;</span> -s 127.0.0.0/8 -j KUBE-SVC-xxx</span><br><span class="line">-A KUBE-NODEPORTS ... --comment <span class="variable">$&#123;svc-port-name&#125;</span> --dport <span class="variable">$&#123;nodeport&#125;</span> -j KUBE-XLB-xxx</span><br><span class="line"></span><br><span class="line">// !<span class="keyword">if</span> hasEndpoints ,在Filter表写入：</span><br><span class="line">-A KUBE-EXTERNAL-SERVICES ... -m addrtype --dst-type LOCAL ... --dport <span class="variable">$&#123;nodeport&#125;</span> -j REJECT</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上讲解了IPTables模式下将流量转发到相应的具体的KUBE-SERVICE-XXX上，而之后还需要解决的是将service的流量发给具体的EndPoint即执行Pod——建立 endpoints 相关的链和规则</p>
<ol>
<li>
<p>为同一个service 的所有endpoints 在nat 表建立链 <code>KUBE-SEP-XXX : KUBE-SEP-XXX -[0:0]</code>，并且记录 <code>activeNATChains[endpointChain] = true</code>，endpointChain为<code>endpointChain := epInfo.endpointChain(svcNameString, protocol)</code>中创建的KUBE-SEP-XXX</p>
</li>
<li>
<p>如果服务设置了”clientIP“ 亲和性， 则为该服务的每一个endpoint 设置会话亲和性<code>-A KUBE-SVC-XXX -m recent --name KUBE-SEP-XXX --rcheck --seconds xxx --reap -j KUBE-SEP-XXX //多个endpoints,则有多条类似规则</code></p>
</li>
<li>
<p>在endpointsChain 链上建立NAT规则</p>
<ul>
<li>
<p>对于多个endpoints (n &gt;1) ,利用iptables 的随机和概率转发的功能，循环建立规则。概率计算是通过查表（precomputeProbabilities 字符串数组）或者现场计算（n&gt;= len(precomputeProbabilities) 的方式完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 概率是通过1.0/float64(n-i)计算出来的，n 代表endpoints的个数 */</span></span><br><span class="line"><span class="comment">// 前n-1个endpoints使用此规则</span></span><br><span class="line">-A KUBE-SVC-XXX -m static --mode random  --probability xxx -j  KUBE-SEP-XXX </span><br><span class="line"> <span class="comment">// 第n个endpoint 建立此规则</span></span><br><span class="line">-A KUBE-SVC-XXX  -j  KUBE-SEP-XXX </span><br><span class="line"> </span><br><span class="line">-A KUBE-SEP-XXX -s $&#123;endpoint_ip&#125;/<span class="number">32</span> -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SEP-XXX -m recent --name  KUBE-SEP-XXX --set  -j DNAT --to-destination xxx <span class="comment">// 如果设置了会话亲和性，写入该条规则</span></span><br><span class="line">-A KUBE-SEP-XXX -j DNAT  --to-destination xxx  <span class="comment">//如果没有设置会话亲和性，写入该条规则</span></span><br></pre></td></tr></table></figure>
<p>在KUBE-SEP-XXX链上通过DNAT规则，真正把流量交到了对应POD的服务上。</p>
</li>
<li>
<p>如果服务还具有OnlyNodeLocalEndpoints 属性，表示只将流量导入到本机上的后端pod上。挑选出和proxy 在相同机器运行的endpoints，在nat 表建立如下规则</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-XLB-XXX ... -s $&#123;cluster-ip&#125; -j KUBE-SVC-XXX  <span class="comment">// 设置了clusterCIDR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有Local POD</span></span><br><span class="line">-A KUBE-XLB-XXX ... --comment $&#123;svc-port-name&#125; has no local endpoints -j KUBE-MARK-DROP</span><br><span class="line"><span class="comment">//如果有Local POD </span></span><br><span class="line">-A KUBE-XLB-XXX ... -m recent --name KUBE-SEP-XXX -rchenck --seconds xxx -j  KUBE-SEP-XXX <span class="comment">//设置了亲和性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有多个pods,设置</span></span><br><span class="line">-A KUBE-XLB-XXX ... -m static --mode  --probability xxx -j KUBE-SEP-XXX</span><br><span class="line">-A KUBE-XLB-XXX ... -m static --mode  --probability xxx -j KUBE-SEP-XXX</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>至此，我们看完了<code>func (proxier *Proxier) syncProxyRules()</code>中的核心内容：遍历完成了对serviceMap 中所有服务及对应的endpoints 建立规则。针对Service的不同类型，我们也知道了为什么可以Work。也知道了为什么本地服务可以通过ClusterIP:Port的方式找到服务，外网的请求可以通过NodeIP:NodePort的方式找到服务。至于如何找到相应Pod的再详细说明可以见网上的样例分析：<a href="https://www.cnblogs.com/xuxinkun/p/5799986.html" target="_blank" rel="noopener">kubernetes入门之kube-proxy实现原理</a></p>
<h2 id="总结图"><a class="markdownIt-Anchor" href="#总结图"></a> 总结图</h2>
<p>最后的最后，放张我自己画的CLI启动ProxyServer Run()的顺序图，和大佬总结的资源更新示意图以及链、规则建立顺序图吧。</p>
<p><img src="/2021/10/26/k8s之kube-proxy源码分析/Proxy.png" alt="Proxy"></p>
<p><img src="/2021/10/26/k8s之kube-proxy源码分析/seq.png" alt="seq"></p>
<p><img src="/2021/10/26/k8s之kube-proxy源码分析/iptables.png" alt="iptables"></p>
<h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference:</h1>
<ol>
<li><a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">spf13/<em>cobra</em></a></li>
<li><a href="https://blog.csdn.net/weixin_30797027/article/details/96805134" target="_blank" rel="noopener">flag–命令行参数解析之StringVar</a></li>
<li><a href="https://blog.csdn.net/zhonglinzhang/article/details/86074298" target="_blank" rel="noopener">【kubernetes/k8s概念】kube-proxy启动参数</a></li>
<li><a href="https://blog.csdn.net/cbmljs/article/details/102688708" target="_blank" rel="noopener">k8s源码分析——kube-proxy 源码分析</a>——梳理了整体的执行过程</li>
<li><a href="https://www.cnblogs.com/xuxinkun/p/5799986.html" target="_blank" rel="noopener">kubernetes入门之kube-proxy实现原理</a>——分析了外网如何通过NodePort找到相应EndPoint的案例</li>
<li><a href="https://www.cnblogs.com/charlieroro/p/9588019.html" target="_blank" rel="noopener">理解kubernetes环境的iptables</a>——对链上关系分析的比较好</li>
</ol>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2021/10/26/k8s之kube-proxy源码分析/">https://nymrli.top/2021/10/26/k8s之kube-proxy源码分析/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2021/11/02/浙江大学期末考试——Go语言/" title="浙江大学期末考试——Go语言"><span>< PreviousPost</span><br><span class="prevTitle">浙江大学期末考试——Go语言</span></a><a class="nextSlogan" href="/2021/10/25/CICD-Jenkins与Travis/" title="CICD-Jenkins与Travis"><span>NextPost ></span><br><span class="nextTitle">CICD-Jenkins与Travis</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: 'k8s之kube-proxy源码分析',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><span>备案号:苏ICP备18015439号</span></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#kubernetes-简单介绍"><span class="toc-number">1.</span> <span class="toc-text"> kubernetes 简单介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景介绍"><span class="toc-number">1.1.</span> <span class="toc-text"> 背景介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#架构设计"><span class="toc-number">1.2.</span> <span class="toc-text"> 架构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码整体分析"><span class="toc-number">1.3.</span> <span class="toc-text"> 代码整体分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy源码目录结构分析"><span class="toc-number">1.3.1.</span> <span class="toc-text"> proxy源码目录结构分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kube-proxy分析"><span class="toc-number">2.</span> <span class="toc-text"> kube-proxy分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重要结构体说明"><span class="toc-number">2.1.</span> <span class="toc-text"> 重要结构体说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#proxyserver"><span class="toc-number">2.1.1.</span> <span class="toc-text"> ProxyServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#options"><span class="toc-number">2.1.2.</span> <span class="toc-text"> Options</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxier"><span class="toc-number">2.1.3.</span> <span class="toc-text"> Proxier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序启动过程"><span class="toc-number">2.2.</span> <span class="toc-text"> 程序启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#proxyserver创建过程"><span class="toc-number">2.2.1.</span> <span class="toc-text"> ProxyServer创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iptables-proxy-server"><span class="toc-number">2.2.2.</span> <span class="toc-text"> iptables proxy server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxyserverrun"><span class="toc-number">2.2.3.</span> <span class="toc-text"> ProxyServer.Run()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#记录资源变化"><span class="toc-number">2.3.</span> <span class="toc-text"> 记录资源变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iptables相关"><span class="toc-number">2.4.</span> <span class="toc-text"> IPTables相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iptables-创建kube自定义链和规则"><span class="toc-number">2.4.1.</span> <span class="toc-text"> Iptables 创建KUBE自定义链和规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#service类型分析"><span class="toc-number">2.4.2.</span> <span class="toc-text"> Service类型分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结图"><span class="toc-number">2.5.</span> <span class="toc-text"> 总结图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number">3.</span> <span class="toc-text"> Reference:</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>